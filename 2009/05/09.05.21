00:03:00 <lpjhjdh> so the haskell98 standard says "uniSymbol   ->    any Unicode symbol or punctuation" is there a more concrete definition of "any"?
00:03:44 <dmwit> :t isSymbol
00:03:45 <lambdabot> Char -> Bool
00:03:49 <dmwit> :t isPunctuation
00:03:50 <lambdabot> Char -> Bool
00:04:11 <dmwit> > filter (liftM2 (||) isSymbol isPunctuation) ['\0'..]
00:04:12 <lambdabot>   "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\161\162\163\164\165\166\167\168\169\171...
00:04:46 <dmwit> Depending on where this is used, that may or may not be correct.
00:05:03 <lpjhjdh> I see, thanks.
00:05:07 <dmwit> As you can see, some things like ", (, ) are in there.
00:05:50 <dmwit> @, \, [, ], {, }, |, and ~ are also special...
00:05:50 <lambdabot> Maybe you meant: . ? @ v
00:06:44 <MyCatVerbs> dmwit: ~?
00:07:02 <MyCatVerbs> I can't remember anywhere in Haskell's grammar where ~ is used?
00:07:03 <lpjhjdh> hmm, so essentially anything not reserved?
00:07:19 <dmwit> MyCatVerbs: lazy patterns
00:07:20 <ivanm> @src partition
00:07:20 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
00:07:21 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
00:07:21 <lambdabot>                               | otherwise = (ts, x:fs)
00:07:24 <ivanm> MyCatVerbs: ^^
00:07:34 <ivanm> so it's not undefined
00:07:35 <MyCatVerbs> dmwit: oh yes! I am full of forgetfullness and no caffeine.
00:07:54 <lpjhjdh> @hoogle isSymbol
00:07:54 <lambdabot> Data.Char isSymbol :: Char -> Bool
00:11:23 <solrize_> does 6.8.2 not have data.binary?  should i upgrade to what is it now, 6.10.3?
00:14:07 <lpjhjdh> @hoogle alexGetChar
00:14:07 <lambdabot> No results found
00:23:01 <PetRat> I'm trying to understand the expression "join (*) 5". Apparently this has to do with the monad ((->) e).
00:23:26 <PetRat> (*) :: Int -> Int -> Int
00:23:53 <dmwit> yep
00:23:59 <dmwit> :t join
00:24:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:24:18 <PetRat> Apparently (*) is a monad and so is (5 *)?
00:24:22 <dmwit> So, in the case of the (e ->) monad, join :: (e -> e -> a) -> (e -> a)
00:25:09 <dmwit> i.e. given a function that expects two environments, return a function that takes only one environment and supplies two copies of it to the passed-in function.
00:25:28 <dmwit> So (join (*)) is a function that takes one argument and puts it on both sides of the multiplication.
00:25:35 <dmwit> join (*) 5 = 5 * 5
00:25:44 <PetRat> I am still trying to work that out from my understanding of the definitions.
00:25:56 <dmwit> ?src join
00:25:56 <lambdabot> join x =  x >>= id
00:26:04 <PetRat> join = do y <- x; v <- y; return v
00:26:12 <dmwit> right
00:26:18 <PetRat> what is x?
00:26:30 <dmwit> uh
00:26:31 <shachaf> join x = ...
00:26:32 <dmwit> I think that's
00:26:33 <dmwit> join x = ...
00:26:35 <dmwit> yeah
00:26:40 <shachaf> PetRat: Isn't that redundant, though?
00:26:46 <shachaf> join x = do y <- x; y
00:27:05 <dmwit> Damn, shachaf is fast.  I was about to suggest that, too, but can't type nearly as quickly. =P
00:27:11 <shachaf> PetRat: My advice: Look at the types instead of the implementations. At least at first.
00:27:35 <shachaf> PetRat: They're simpler, and there's one obvious implementation for each.
00:27:38 <PetRat> So join (*) = do y <- (*) ; y
00:27:42 <shachaf> @src (->) >>=
00:27:42 <lambdabot> Source not found.
00:27:47 <shachaf> @src (->) (>>=)
00:27:47 <lambdabot> f >>= k = \ r -> k (f r) r
00:27:49 <PetRat> shachaf: I'm trying to do both.
00:28:14 <shachaf> PetRat: Another bit of advice: Think of it in terms of join/fmap/return instead of (>>=)/return. :-)
00:28:50 <dmwit> f >>= k = \r -> k (f r) r
00:28:57 <dmwit> f >>= id = \r -> id (f r) r
00:29:03 <PetRat> I'm looking at an exercise to define >>= in terms of fmap and join. Thinking about trying to do that. I just want to understand join (*) 5
00:29:04 <dmwit> f >>= id = \r -> (f r) r
00:29:10 <dmwit> f >>= id = \r -> f r r
00:29:16 <Gracenotes> but nonetheless, >>= does make for some spiffy one-liners
00:29:18 <dmwit> join f = f >>= id = \r -> f r r
00:29:37 * dmwit stops flooding
00:30:22 <shachaf> PetRat: OK, those are two separate exercises.
00:30:35 <shachaf> PetRat: As I said before, look at the types.
00:30:38 <shachaf> @ty join
00:30:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:30:41 <shachaf> @ty fmap
00:30:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:30:44 <shachaf> @ty (>>=)
00:30:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:31:01 <PetRat> Last night I worked out x >>= f = \e -> f (x e) e
00:31:29 <dmwit> PetRat: Nice!
00:31:32 <PetRat> join :: m (m a) -> m a
00:32:22 <PetRat> so m (m a) is    e -> (e -> a) ?
00:32:27 <dmwit> Right.
00:32:37 <PetRat> m a is e -> a
00:32:43 <dmwit> Spot on.
00:32:57 <shachaf> @ty flip (>>=) -- Hint: fmap is similar to flip (>>=).
00:32:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
00:33:10 <shachaf> (Now that I think about it, that isn't a very helpful hint. Ignore me. :-) )
00:33:49 <PetRat> so join takes a function of two arguments and changes to a function of one argument. The specific implementation does that by supplying the one argument twice. I guess there's nothing else you CAN do, if you have only one argument for a function of two arguments. (Nothing else useful.)
00:33:54 <zakwilson> I'm using a Mac for a few days. Is Fink or Darwinports a sane way to get GHC and the like?
00:34:05 <dmwit> PetRat: exactly
00:34:51 <shachaf> PetRat: You'll find that it's that way with just about all the (r ->) functions.
00:34:56 <shachaf> For example:
00:34:57 <shachaf> @ty return
00:34:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:35:21 <shachaf> a -> m a = a -> (r -> a)
00:35:32 <shachaf> What's the most obvious way of accomplishing that? :-)
00:35:43 <PetRat> I want to understand the implementation, though. join x = do y <- x; y. how is this expressed with >>=?
00:36:02 <shachaf> PetRat: do is syntax sugar for >>=, remember.
00:36:05 <PetRat> shachaf: \_ -> a?
00:36:10 <shachaf> PetRat: Yep.
00:36:17 <shachaf> Or rather, \a _ -> a
00:36:31 <dmwit> ?undo \x -> do { y <- x; y }
00:36:32 <lambdabot> \ x -> x >>= \ y -> y
00:36:42 <dmwit> The latter is just fancy notation for id.
00:36:46 <dmwit> \x -> x >>= id
00:37:01 <dmwit> You'll note the similarity to the Prelude:
00:37:03 <dmwit> ?src join
00:37:03 <lambdabot> join x =  x >>= id
00:37:04 <dmwit> ;-)
00:37:33 <shachaf> @. pl undo join x = do { y <- x; y }
00:37:34 <lambdabot> join = join
00:37:38 <shachaf> Er, yes.
00:37:45 <dmwit> hehehe
00:37:47 <PetRat> join x = x >>= id ?
00:39:41 <shachaf> PetRat: For any monad, yes. That's the Prelude's definition.
00:39:57 <shachaf> You might find it clearer to start with join and fmap, though. :-)
00:40:09 <kau> hello! Can you give me some pointers on "if then else" being desugared to arrowChoice?
00:40:48 <kau> can't find it on google :(
00:41:35 <dmwit> Have you looked at the papers on proc notation?
00:41:41 <kau> no
00:41:43 <dmwit> That's where I'd expect the details to be.
00:41:43 <PetRat> okay so \e -> f (x e) e ==> \e -> id (e *) e ===> (e *) e ===> e * e
00:41:55 <kau> i dont know proc notation ;)
00:42:24 <kau> it's for defining new keywords?
00:42:33 <dmwit> Uh, no, it's for using Arrows.
00:42:55 <dmwit> It's a bit like do notation, but for Arrows, not Monads.
00:42:59 <dmwit> And not as good as Wadler's notation. =)
00:43:16 <dmwit> The Haskell wiki page on arrows should have links to papers about it.
00:44:27 <kau> ok thanks i'll have a look
00:44:51 <Saizan> the ghc manual also has it
00:45:28 <Saizan> ?type (|||)
00:45:29 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
00:45:55 <Saizan> ?type constA
00:45:57 <lambdabot> Not in scope: `constA'
00:46:52 <PetRat> So >>= implemented in terms of fmap and join. I think it's x >>= f = join $ fmap f x
00:47:39 <Saizan> let constA a = arr (const a) in \t f -> arr (\x -> if x then Left () else Right ()) >>> (constA t ||| constA f)
00:47:46 <Saizan> PetRat: right
00:47:56 <shachaf> @ty \f m -> join (fmap f m) -- Yep.
00:47:57 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a -> m a1) -> m a -> m a1
00:47:59 <shachaf> Well, flipped, anyway.
00:49:20 <PetRat> It's amazing to me that you can work out that definition by "following the types", as though you are ignoring implementation. But I guess the idea is that when any particular monad is implemented, the implementor follows the types and the monad laws, which is what guarantees my simple definition will always work. Is it something like that?
00:50:10 <shachaf> PetRat: Yep. That's the whole point of having a Monad class.
00:50:19 <Cale> PetRat: There are often not that many possibilities for implementation of a highly polymorphic type.
00:50:30 <dmwit> Actually, in a lot of cases, you can prove rigorously that all truly polymorphic implementations that matches a particular type will be identical.
00:50:43 <dmwit> s/matches/match/
00:52:42 <Cale> As another example, consider the type (a -> b) -> [a] -> [b], the type of map. What functions have this type? Well, it's not just map, but we can say that every other function which has that type produces a list consisting of elements produced by passing elements of the given list to the given function.
00:53:17 <Cale> This makes it really hard to mess up your implementation and still get the type to match. You basically have to be trying.
00:53:53 <Cale> Often the implementation with the nicest properties, the one you really want, will also be the simplest one as well.
00:54:31 <PetRat> Cale: what if you implement map' f xs = [f (head xs)] . Is that "trying to mess it up?"
00:55:43 <dmwit> Yep, about the best you can say is that the behavior of a function matching that type will depend only on the length of the list.
00:55:56 <dmwit> However, there's still a lot you can make rigorous.
00:55:57 <Cale> Well, I suppose it's possible that you're not trying to mess up there if you actually don't know the language very well.
00:56:12 <Cale> dmwit: And the permutation of the elements given.
00:56:20 <Cale> (and duplicates)
00:56:21 <dmwit> Cale: No, it can't depend on that.
00:56:27 <dmwit> Not at that type.
00:56:44 <Cale> oh, I see what you're saying
00:56:45 <PetRat> Cale: I mean "trying" more in the sense of, failing to observe basic principles.
00:57:16 <solrize_> map' f xs = []
00:57:20 <solrize_> doesn't depend on length xs :)
00:57:24 <Cale> dmwit: I accidentally misinterpreted which list you were talking about
00:57:34 <dmwit> solrize_: Sure it does.
00:57:48 <dmwit> solrize_: In fact, it doesn't depend on anything *but* the length of xs.
00:57:48 <MyCatVerbs> solrize_: is too polymorphic, has type a -> b -> [c].
00:58:02 <solrize_> hmm ok
00:58:03 <Cale> dmwit: It gives the same result regardless of xs though...
00:58:06 <MyCatVerbs> forall a b c., even.
00:58:18 <dmwit> Cale: Yep, I know.
00:58:42 <dmwit> solrize_: Or, another way to put it is: saying that a thing depends "only on the length of the list" does not imply that it definitely does depend on the length of the list.
00:58:45 <Cale> So that one doesn't even depend on the length of xs, it depends on nothing...
00:59:15 <PetRat> There's a term like the "most general type"... something about the most general type that is not too general.
00:59:18 <dmwit> solrize_: So the behavior of map' depends only on the length of the list... and not even on that. =)
00:59:25 <dmwit> PetRat: "principal"
01:00:35 <PetRat> Beginners often think that foldr :: (a -> a -> a) -> a -> [a]
01:00:56 <dmwit> Maybe you meant (a -> a -> a) -> [a] -> a?
01:01:12 <dmwit> :t buildr
01:01:12 <Cale> Or (a -> a -> a) -> a -> [a] -> a
01:01:13 <lambdabot> Not in scope: `buildr'
01:01:20 <PetRat> Cale : you said it
01:01:41 <PetRat> but it is actually something like (b -> a -> b) -> b -> [a] -> b
01:02:05 <Cale> (a -> b -> b) -> b -> [a] -> b
01:02:14 <Cale> (similar)
01:02:35 <dmwit> :t foldl -- maybe what PetRat was thinking of
01:02:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:02:41 <PetRat> Oh I see. Yes I tr to think of the supplied "starting" value as going on the right, for foldr
01:03:23 <Cale> For foldr f z, it's best to think of f as a replacement for (:) and z as a replacement for []
01:03:39 <PetRat> dmwit: I was thinking of foldr but just forgetting that the supplied value "goes on the right" of the operator.
01:04:02 <Cale> PetRat: Have you seen my diagrams?
01:04:11 <PetRat> Stupid mibbit changes all (:) to smileys.
01:04:12 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
01:04:36 <PetRat> Cale: I got 404 error on that link.
01:04:37 <Cale> Does it change (:[]) into a robot monkey?
01:04:43 <Cale> hmm
01:05:17 <Cale> 99.247.248.73
01:05:34 <Cale> oh
01:05:38 <Cale> I might know
01:05:47 <Cale> Maybe the router switched us around again :P
01:05:58 <PetRat> Cale: I saw the diagrams on the Wikipedia page.
01:06:09 <ivanm> Cale: a windows message? :s
01:06:40 <ivanm> I take it that's you singing/playing rather than providing illegal music for the RIAA to find?
01:07:41 <Cale_> There we are. Any better?
01:09:02 <ivanm> awww.... there's no oops message anymore :(
01:09:17 <Cale> heh, that was from my dad's computer, I think
01:10:18 <ivanm> it's not just that you've been gaming?
01:11:07 <PetRat> Nice diagrams.
01:11:40 <Cale> Nope, my machine doesn't have windows on it.
01:12:53 <Cale> PetRat: actually, I did make the diagrams on Wikipedia as well
01:12:54 <FunctorSalad_> how is scanr formed?
01:13:06 <Cale> @src scanr
01:13:07 <lambdabot> scanr _ q0 []     =  [q0]
01:13:07 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
01:13:07 <lambdabot>     where qs@(q:_) = scanr f q0 xs
01:13:41 <FunctorSalad_> hmm it just yields all the intermediate values of the foldr?
01:13:47 <ivanm> yup
01:13:58 <Cale> yeah, starting with the whole thing
01:14:08 <Cale> > scanr (+) 0 [1,2,3,4,5]
01:14:10 <lambdabot>   [15,14,12,9,5,0]
01:14:33 <Cale> > scanr (+) 0 [1,10,100,1000,10000]
01:14:34 <lambdabot>   [11111,11110,11100,11000,10000,0]
01:15:04 <Cale> > scanr f z [1,2,3,4,5]
01:15:06 <lambdabot>   [f 1 (f 2 (f 3 (f 4 (f 5 z)))),f 2 (f 3 (f 4 (f 5 z))),f 3 (f 4 (f 5 z)),f ...
01:15:39 <dmwit> It is one of the mysteries of laziness that foldr is preferable to foldl, but scanl is preferable to scanr.
01:16:05 <dmwit> They say the even the initiate must ponder this each time, before he recalls why.
01:16:07 <FunctorSalad_> except where foldl' is preferable? :)
01:16:27 <dmwit> Well, of course. ;-)
01:16:45 <dmwit> But this temple is strictly lazy.
01:17:04 <Cale> > map (take 5) . scanr (:) [] $ [1..]
01:17:05 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
01:17:55 <Cale> Sometimes even scanr is nice :)
01:18:19 <PetRat> dmwit: I've noticed that anything I "learned" today will probably be mysterious tomorrow. Certain exercises I've worked about four or five times now and I still have to ponder it.
01:18:33 <dmwit> PetRat: It's normal, don't worry.
01:18:35 <PetRat> Eventually will be second nature, though.
01:18:46 <dmwit> After 40 or 50 times, you'll only think briefly.
01:18:58 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
01:18:59 <lambdabot>   [5,4,3,2,1]
01:19:00 <dmwit> And next year, you'll wonder what was so mysterious. =)
01:19:38 <Cale> I think the diagram sort of makes clear why scanl is nice compared to foldl
01:20:04 <PetRat> dmwit: That's the sense I get. This stuff fits together naturally. It only seems difficult to the imperative programmer because one has to go back to a very early stage of development. We forget how much work it took before imperative programming was second nature.
01:20:39 <dmwit> One of those Google guys has a nice essay called "Learn Programming in Seven Years" that rants against the "Learn Programming in Seven Days" series of books.
01:20:46 <dmwit> Norvig
01:21:01 <dmwit> PetRat: Yes, exactly.
01:21:50 <Gracenotes> it was 10 years, iirc
01:22:18 <PetRat> An adult who has some kind of movement difficulties like pain, stiffness, balance problems, etc., can feel like they barely function. But look at a baby waving its arms and legs around, and the great accomplishment for a baby is bringing its fist to its mouth without a lot of wasted effort. We have come a long way.
01:23:55 <PetRat> Yes it was learn programming in 10 years. If you go to borders, there are a slew of books called "Learn SQL in 24 hours," "Learn SQL in 10 days," maybe other variants. I forget the publisher but they have numerous titles like that.
01:27:35 <PetRat> > id (5 *) 5
01:27:36 <lambdabot>   25
01:28:09 <PetRat> I like how initially "id (5 *) 5" looks wrong because id takes only one argument.
01:30:45 <shachaf> PetRat: All functions take only one argument.
01:31:12 <shachaf> Would you prefer "($) (5 *) 5"?
01:33:42 <tibbe> any windows user out there that can verify that network-2.2.1.2 build (i.e. do "cabal update" followed by "cabal upgrade network")?
01:36:43 <Gracenotes> PetRat: you might say (id (5*)) 5...
01:37:06 <Gracenotes> > id id id id id id id id id id id id (*5) 5
01:37:08 <lambdabot>   25
01:37:48 <Cale> Anything which returns a result of an arbitrary type can appear to take an arbitrary number of parameters
01:39:07 <ziman> :t const undefined 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
01:39:08 <lambdabot> forall t. t
01:41:08 <Cale> > foldr (.) id [(*2),(+3),(*5)] 10
01:41:10 <lambdabot>   106
01:48:10 <dibblego> @src replicateM
01:48:11 <lambdabot> replicateM n x = sequence (replicate n x)
02:15:03 <dibblego> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5099#a5099 where am I screwing up?
02:18:42 <doserj> dibblego: value always succeeds without consuming input
02:19:52 <dibblego> ah yeah I think I want \x -> satisfy(== x)
02:19:57 <dibblego> thanks
02:20:59 <doserj> that makes value and satisfy mutually recursive, though :)
02:21:17 <dibblego> no, I won't change value
02:21:40 <dibblego> I'm just not using the right function (I need another function with the same sig)
02:21:46 <doserj> ah, ok
04:04:06 <nisse> Hi all.
04:04:28 <nisse> I've been studying Haskell for a while now.
04:04:36 <Tobsan> great :)
04:04:45 <nisse> I'm in a point where I start to understand laziness and the typesystem
04:04:59 <nisse> and the purity :)
04:06:00 <PeakerWork> nisse: after understanding it, I had trouble seeing what I had trouble understanding :-)
04:06:03 <PeakerWork> Its so simple :)
04:06:19 <nisse> And I've started to realize that Haskell is _really_ different language than "traditional" languages
04:06:33 <nisse> (algol based)
04:06:44 <tetha> you can use Monoid in a sensible way in a program... that certainly is different :)
04:06:55 <PeakerWork> Laziness does not run as deep into my brain as other stuff, now I just see it as an implicit memoizing lambda around everything :()
04:07:45 <nisse> The more I understand the Haskell philosophy the more I realize that other languages are just ... wrong
04:08:23 <tetha> I would not call it wrong, I would call it simpler
04:08:56 <dibblego> I call it wrong and excessively complex and not simple enough
04:09:09 <nisse> tetha: Well like comparing JS to Basic.
04:09:18 <nisse> dibblego: !
04:09:39 <tetha> dibblego: hm. yes, you are right, simple and difficult are the wrong terms, even though I do not know better terms
04:09:56 <dibblego> nisse, yes? I compounded your statement with conjunction, I hope you don't mind
04:09:58 <PeakerWork> tetha: what's simpler, other languages?
04:10:17 <nisse> dibblego: You said what I was trying to say :)
04:10:27 <tetha> PeakerWork: I would argue that "just using a string" instead of thinking of monoids requires a smaller initial brain effort
04:10:30 <nisse> dibblego: Kinda like crystallized
04:10:45 <tetha> PeakerWork: certainly, once you understood everything, monoids are simpler and much more flexible
04:11:40 <nisse> So is there some area of computing where Haskell is less practical than some strict language?
04:11:52 <IntergalacticOwl> The initial effort barrier is a problem for average programmers though.
04:12:11 <tetha> IntergalacticOwl: that is my point :)
04:13:03 <dibblego> nisse, it is not about lazy language versus strict -- it is about which is the default -- for the general case, lazy is the correct default
04:13:36 <nisse> dibblego: well, the in some langs the laziness is kind of hidden
04:13:47 <IntergalacticOwl> I can't say too much since I'm still learning Haskell, but I do not think that I would even be able to start explaining it to anyone I know irl.
04:14:25 <Botje> it's easier to express what you want to do
04:14:33 <Botje> without all that mucking around with iterators or indexes
04:16:49 <nisse> dibblego: Haskell seems to be too good to be true.
04:17:06 <nisse> dibblego: Is there some horrible catch that I've perhaps missed?
04:17:18 <dibblego> not really
04:17:43 <IntergalacticOwl> It is in general pretty amazing so far
04:18:41 <IntergalacticOwl> Maybe one of the catches is convincing your employer to let you use it for work though
04:19:23 <thirsteh> and that's probably gonna be harder than learning the language :-)
04:19:28 <thirsteh> for now...
04:20:41 <IntergalacticOwl> Last I was employed, I had to learn Visual Basic .NET on the job, haha
04:21:34 <solrize> the main catches seem to be space leaks, and the complexity of nesting monads
04:22:20 <zachk> and cabal doesnt work so great on windows haskell
04:22:33 <zachk> but frag does compile and run
04:22:40 <Baughn> Nah, that's a catch with windows, not with haskell
04:23:09 <ivanm> what does the new LHC do?
04:23:12 <nisse> solrize: can you elaborate?
04:23:16 <ray> a catch with haskell is similar to one that many language communities have
04:23:21 <ray> they're too attached to UNIAX ;)
04:23:30 <Baughn> ivanm: ..LHC? Not the collider?
04:23:34 <ivanm> ray: *shrug* I have no problem with that ;-)
04:23:41 <ivanm> Baughn: no, Lemmih's LHC
04:23:42 <ivanm> ;-)
04:23:55 <ray> well, it's not so bad with haskell
04:23:58 <ray> avoid success and all
04:24:20 <ray> large haskell collider
04:24:25 <IntergalacticOwl> I've been having trouble getting Cabal to work on debian, actually. Bootstrap.sh ate all my memory linking something and then hours later, spat out errors.
04:24:33 <ray> that's what monad transformers use under the hood
04:24:50 <ray> if it's debian, maybe you're missing key libraries
04:25:36 <ray> you might have to install more of the packages with names like libghc6-*-dev
04:27:13 <IntergalacticOwl> I made sure I had network and parsec
04:28:25 <ivanm> IntergalacticOwl: are you talking about Cabal or Cabal-Install?
04:28:41 * ivanm notices dcoutts conveniently left when questions about Cabal came up... >_>
04:28:57 <IntergalacticOwl> cabal-install sorry
04:32:49 <Saizan> IntergalacticOwl: long linking times are not unknown for ghc
04:33:04 <IntergalacticOwl> I see
04:34:04 <Baughn> IntergalacticOwl: Shouldn't be /that/ long, but if you're running out of memory..
04:34:19 <Saizan> depends on how much memory you have, i guess
04:35:46 <Baughn> Mm. If I'm reading this right, linking GHC takes about 2GB.
04:36:28 <Saizan> he's linking cabal-install though
04:37:03 * PeakerWork finally understood why djinn is a theorem prover :)
04:37:21 <mux> does hackage use "cabal haddock" to generate the documentation?
04:37:22 <PeakerWork> it could be awesome to have background @djinn'ing in my code editor that proves my code using some heuristics while I edit it
04:39:30 <ivanm> mux: not sure if hackage uses cabal-install
04:39:47 <ivanm> but it would be using cabal-the-library most probably in some way to call haddock
04:41:14 <mux> I'm looking for some C macro that I could use to know this is haddock generating documentation so that I can avoid having some code #ifdef'ed out
04:42:14 <Saizan> since 2.0 haddock doesn't define anything like that
04:42:17 * mux reads Distribution/Simple/PreProcess.hs
04:42:36 <ivanm> Saizan: yes it does
04:42:45 <ivanm> I just saw it in the haddock docs the other day
04:43:07 <ivanm> mux: somewhere around here: http://www.haskell.org/haddock/doc/html/module-attributes.html
04:43:09 <Saizan> the documentation might be outdated
04:44:02 <mux> I don't see anything with those attributes that could help
04:44:06 <Saizan> Haddock does not
04:44:08 <Saizan> define any cpp macros at all (unless GHC defines any by default).
04:44:20 <mux> that would be Cabal's job anyways
04:44:24 <Saizan> in an email from haddock's maintainer :)
04:44:32 <mux> it's cabal that does the preprocessing
04:45:23 <Saizan> mux: that's not entirely true in practice
04:45:45 <mux> indeed, I know see that the preprocessors are passed to preprocessModule
04:45:50 <ivanm> Saizan: ahhh, I missed that mux wanted it to be CPP
04:46:14 <mux> not really CPP, but this is a .hsc file so it has CPP macros too
04:47:11 <Saizan> unless you've CPP in the extensions there won't be a separate cpp pass
04:47:27 <mux> I mean that hs2c does that
05:17:08 <jeff_s_> when I "import Data.ByteString.Char8 as B" and I call an unqualified function like "getContents", it's annoying that ghc warns me about a conflict between Prelude and ...Char8. Is there a way I can import something like BytesString but not have to prefix every Prelude function with "Prelude"?
05:17:37 <Baughn> jeff_s_: import Prelude hiding (foo,bar)
05:17:57 <Baughn> jeff_s_: Or, do you mean having both getContents imported at the same time?
05:18:19 <Baughn> ..that would be what typeclasses are for. We could probably use more of them.
05:18:27 <jeff_s_> I want to be able to write ByteString.getContents and getContents, where the unqualified name is Prelude
05:18:55 <Baughn> jeff_s_: So, import qualified Data.ByteString.Char8 as ByteString?
05:19:08 <jeff_s_> Maybe I'm missing some haskell style though. What I'm looking for is waht I'm used to from ML.
05:19:26 <jeff_s_> I imported it qualified but I get the same problem :\
05:19:50 <jeff_s_> Ambiguous occurrence `tail'
05:19:51 <jeff_s_> It could refer to either `Prelude.tail', imported from Prelude
05:19:51 <jeff_s_>                       or `B.tail', imported from Data.ByteString.Char8 at 2.
05:20:14 <Baughn> jeff_s_: What's you r/exact/ import line?
05:20:20 <doserj> jeff_s_: there is a difference between "import M as B" and "import qualified M as B"
05:20:27 <jeff_s_> OH
05:20:30 <jeff_s_> duh, thanks
05:21:20 <jeff_s_> ok ya, that was exactly what I wanted. Thanks!
05:23:53 <ivanm> doserj: is there any time where import unqualified with an alias is useful?
05:24:11 <Baughn> jeff_s_: You can also have multiple import lines, eg. to import type names unqualified
05:25:38 <doserj> ivanm: I don't think I ever used that
05:26:15 <ivanm> I wonder if there is ever use for it
05:26:26 <Baughn> I've never seen it used anywhere
05:26:42 <ivanm> unless you have only one or two clashes, and can't be bothered doing P.blah for all functions, whereas you can do so for those that _do_ clash
05:35:59 <saml> data (->) a b  -- how should i understand this?
05:36:03 <saml> > 1 -> 2
05:36:04 <lambdabot>   <no location info>: parse error on input `->'
05:36:20 <Saizan> (->) is a type constructor there
05:36:57 <saml> ah i think i get it now
05:37:00 <athos> @type a >- b
05:37:01 <lambdabot> Not in scope: `>-'
05:37:04 <athos> @type a -> b
05:37:05 <lambdabot> parse error on input `->'
05:37:13 <saml> @kind (->)
05:37:15 <lambdabot> ?? -> ? -> *
05:37:16 <athos> :)
05:39:58 <saml> > (succ >>> succ) 0
05:39:59 <lambdabot>   2
05:40:28 <tombom> @kind (>>>)
05:40:29 <lambdabot> Not in scope: type variable `>>>'
05:40:46 <tombom> @type (>>>)
05:40:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:41:12 <saml> A class for categories. id and (.) must form a monoid.
05:41:26 <saml> wtf is monid
05:43:09 <EvilTerran> a monoid is a set with an associative binary operation, and an element that is a left- and right-identity element of that operation
05:43:31 <EvilTerran> ish.
05:43:32 <MyCatVerbs> saml: a Monoid is a type that you can glue two of them together (mappend), and for which there is an identity element (mempty).
05:44:01 <MyCatVerbs> EvilTerran: please don't tack "ish" onto correct definitions. It makes people nervous. ;P
05:44:17 <Botje> they should be!
05:44:43 <ivanm> EvilTerran: "operationish"?
05:44:45 <athos> > [1] `mappend` [2]
05:44:45 <EvilTerran> MyCatVerbs, it was to indicate my own non-confidence in the accuracy
05:44:46 <lambdabot>   [1,2]
05:44:58 <athos> > [1] `mappend` mempty
05:44:59 <lambdabot>   [1]
05:45:21 <ivanm> > mempty `mappend` mempty
05:45:22 <ivanm> ;-)
05:45:22 <lambdabot>   ()
05:45:25 <MyCatVerbs> EvilTerran: oh, well. *checks*. Yes, you were correct.
05:45:29 <ivanm> :o it has a default instance? :o
05:45:38 <ivanm> @type mempty `mappend` mempty
05:45:38 <lambdabot> forall a. (Monoid a) => a
05:45:46 <saml> ., >>>, mappend.. they sound all similar
05:45:50 <ivanm> why did lambdabot default to ()?
05:45:54 <ivanm> @type (>>>)
05:45:55 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:46:04 <MyCatVerbs> ivanm: No. () is an instance of Monoid. So if you don't give any type whatsoever beyond (Monoid m, Show m), then the type inferrer may guess ().
05:46:09 <ivanm> saml: >>> uses different types
05:46:22 <ivanm> MyCatVerbs: yes, but I was wondering why lambdabot defaulted to it rather than complaining
05:46:25 <saml> can we unify all of those composition stuff?
05:46:34 <ivanm> AFAIK, only Integral and Floating have default type
05:46:37 <ivanm> *types
05:46:41 <Saizan> saml: a Category is a parametrized Monoid, roughly
05:46:43 <ivanm> saml: see the Typeclassopedia
05:46:47 <EvilTerran> ivanm, extended defaulting is a ghc extension
05:46:54 <Saizan> saml: so it's expected :)
05:46:55 <ivanm> Saizan: and a Monad is a Monoid in the Category of Endofunctors?
05:46:57 <ivanm> ;-)
05:46:58 <marcot> What should I use to generate a .cabal file?  Is there a library like haskell-src for Cabal?
05:47:01 <ivanm> EvilTerran: ahhh
05:47:02 <MyCatVerbs> ivanm: *checks*, GHCi does too.
05:47:04 <EvilTerran> @check \x y -> x == y -- all things are equal!
05:47:05 <lambdabot>   "OK, passed 500 tests."
05:47:07 <ivanm> that I didn't know about
05:47:11 <Botje> marcot: mkcabal
05:47:14 <Saizan> ivanm: sure, what's funny about that?
05:47:17 <ivanm> Botje: it's dead
05:47:22 <Botje> uh?
05:47:23 <ivanm> and doesn't build with new ghc, etc. :(
05:47:31 <Botje> oh
05:47:35 <ivanm> Botje: mkcabal is dead, dons told me he wasn't working on it anymore
05:47:43 <Botje> i used mkcabal for my thesis and it worked fine
05:47:45 <MyCatVerbs> I thought everybody just copied someone else's cabal file and altered it?
05:47:46 <ivanm> Saizan: didn't you read that blog post?
05:47:46 <Botje> but that was 6.8
05:48:00 <ivanm> Botje: yeah, doesn't like new exceptions IIRC
05:48:20 <marcot> I don't have a problem about generating it, I just want a library to makes thing easier if there is one already.
05:48:42 <marcot> So I could generate a Tree instead of a String.
05:49:02 <ivanm> marcot: ummm... what does a Tree have anything to do with a .cabal file?
05:49:03 <Saizan> Cabal has functions for parsing and prettyprinting it
05:49:07 * yaxu gets his new haskell music thingie working
05:49:22 <yaxu> ready for a gig in the science museum tonight..
05:49:31 <Saizan> look for PackageDescription, or maybe GenericPackageDescription
05:49:39 <marcot> Saizan: ok, thanks, I'll take a look.
05:49:49 <marcot> Saizan: I was in doubt about so many Cabal types..
05:50:07 <ivanm> is there a default function I can use to check if a character is within A-Za-z0-9+_.-] ?
05:50:19 <ivanm> or just use isAlpha + checks for the four characters?
05:50:19 <Saizan> marcot: there's a small guide to cabal's codebase on the trac wiki
05:50:25 <ivanm> s/characters/symbols/
05:50:34 <ivanm> (that square bracket shouldn't be there)
05:50:35 <EvilTerran> ivanm, i'd use isAlpha and `elem`
05:50:50 <ivanm> EvilTerran: elem rather than explicitly doing so?
05:51:08 <EvilTerran> \c -> isAlpha c || c `elem` "+_.-"
05:51:14 <ivanm> *nod*
05:51:27 <EvilTerran> snappier than writing it out explicitly
05:51:30 <ivanm> does ghc unroll static elems?
05:52:06 <marcot> Saizan: good to know, I'm reading it.  Thanks.
05:52:16 <marcot> ivanm: The Tree is the parsed file.
05:52:16 <EvilTerran> ivanm, oy, no premature optimisation! :P
05:52:41 <ivanm> EvilTerran: heh
05:53:03 <ivanm> marcot: ummmm.... you're trying to programmatically generate the .cabal file?
05:53:09 <ivanm> I still don't see how it's a tree...
05:53:48 <marcot> marcot: Yes.  Maybe not a Tree, but a Map.
05:53:57 <ivanm> marcot: stop talking to yourself! :p
05:54:06 <ivanm> but a Map would make more sense than a Tree
05:54:27 <marcot> ivanm: in that context it made sense to talk to my self... =P
05:54:31 <ivanm> heh
05:54:41 <ivanm> that's the first sign of madness, you know...
06:00:26 <xian> I am going through the tcopedia right now and I was trying to come up with an instance declaration of Pointed for ((->) e). What I've got now is pure y = \x -> y   Is this correct?
06:02:19 <BONUS> yeah
06:02:36 <saml> it is. . . well, I'll let you work it out. (Just follow the types!)
06:03:22 <BONUS> yeah for any of those (functor, pointed, applicative, monad) just write out what the type would be for the particular instance
06:03:27 <BONUS> and then it's pretty easy to implement it
06:12:06 <ivanm> is there any "simple" way I can implement the following rule to implement a "parsing" function (or type "ReadS String") ?
06:12:17 <ivanm> "A package name may contain any of the characters [A-Za-z0-9+_-]. It must not begin with a hyphen, and must not end in a hyphen followed by one or more digits."
06:12:52 <mlysgaard> ivan Regexp?
06:12:57 <ivanm> in particular, I'm not sure how to do the not-ending-in-hyphen-followed-via-digits bit
06:13:02 <ivanm> mlysgaard: I'd rather not
06:13:56 <ivanm> trying to keep the deps to a minimum
06:14:31 <mlysgaard> ivanm: Explain to me what you wan't to parse once again? An example
06:14:39 <ivanm> exactly what that rule says
06:15:22 <Berengal> State machine?
06:15:37 <ivanm> ummm... what?
06:15:47 <ivanm> I'm after simple String stuff if possible ;-)
06:16:21 * ivanm could just parse it without that final constraint and then reverse it and remove the final digits, etc. ...
06:16:23 <Berengal> A bunch of mutually recursive functions, each representing a state in a state machine, and each state parsing a single char or accepting
06:16:52 <Berengal> But that's just regexps without the library
06:17:07 <ivanm> *nod*
06:17:16 <MyCatVerbs> Berengal: no, that's LL(1) without the library. :)
06:17:52 <Berengal> MyCatVerbs: Details :P
06:18:17 <EvilTerran> ivanm, i'd be inclined to use parsec, tbh
06:18:25 <ivanm> hmmmm.... I might just keep applying break (== '-'), and dropping the rest if it's an integer
06:18:27 <ivanm> EvilTerran: no deps
06:18:36 <ivanm> *I don't want to have any other deps
06:19:44 <mlysgaard> ivanm: What you wan't to do is to get a pacage name from a package, like: "gnome-20.0219e0.02" would become "gnome"?
06:19:47 <MyCatVerbs> Berengal: well, not *quite*, you need to carry more state than that, but yes you can implement an LR(1) or LL(1) using a big bouncy pile of continuations to represent the parsing tables.
06:19:49 <FunctorSal> ivanm: not ( last ( group ( map isDigit str ) ) && last ( last ( group ( map (=='-') ) ) ) )
06:19:53 <FunctorSal> ;o
06:19:59 <ivanm> mlysgaard: no, in this case it would be the whole thing
06:20:06 <ivanm> FunctorSal: :o
06:20:14 * ivanm tries to work out wtf that does
06:20:18 <FunctorSal> > group ( map isDigit "fooo!!99a1" )
06:20:20 <lambdabot>   [[False,False,False,False,False,False],[True,True],[False],[True]]
06:20:25 <ivanm> mlysgaard: since the 'e' there makes it legit
06:20:32 <FunctorSal> hmm, still need to collapse the groups
06:21:31 <FunctorSal> ivanm: also, isAlphaNum from Data.Char
06:21:40 <ivanm> yeah
06:21:42 <mlysgaard> ivanm: Ok, but if it's "gnome-2.10.14892" would be parsed "gnome"?
06:22:03 <FunctorSal> let legal c = isAlphaNum c || elem c "+_-" in all legal str
06:22:28 <ivanm> mlysgaard: well, '.' isn't allowed, so it wouldn't include anything after the .
06:22:30 <ivanm> but yes
06:22:34 <FunctorSal> of course peformance won't be greatt
06:22:44 <ivanm> FunctorSal: yeah, I've got that
06:22:44 <MyCatVerbs> legal = liftM2 (||) isAlphaNum (flip elem "+_-")
06:23:01 <ivanm> it's making sure it doesn't end in "-<number>" that's the problem
06:23:21 <doserj> > not . all isDigit . fst . break (=='-') . reverse $ "blah-2"
06:23:23 <lambdabot>   False
06:23:47 <FunctorSal> :o
06:24:05 <ivanm> bugger... I'm parsing a bunch of different components; some things I'm allowed '.', others aren't :@
06:24:26 <ivanm> so I have to have two seperate Char -> Bool functions, one which allowes '.' and the other which doesn't
06:26:07 <mlysgaard> By the way, what's the options in graphical toolkits when working  in haskell?
06:26:24 <ivanm> gtk2hs, wxhaskell
06:26:37 <ivanm> there's qt bindings, but haven't heard much about them in a while
06:26:43 <ray> opengl, for a wider definition of "graphical toolkits" than the one you probably mean
06:29:49 <mlysgaard> Hmm, well, I'd like to draw mathematical expressions, and edit them in real time. Quite unusual.
06:30:11 <mauke> oh, a text editor?
06:30:17 <FunctorSal> ftgl? ;)
06:30:46 <FunctorSal> would be a bit of a pain to do subscripts etc. manually though
06:30:52 <mlysgaard> Well, it would need to support all kinds of strange math symbols
06:31:07 <FunctorSal> more than are in unicode?
06:31:33 <mlysgaard> No, i think unicode would work
06:31:53 <FunctorSal> (table 33 and 34)
06:31:56 <EvilTerran> mlysgaard, ah, that's really not that unusual. i think most maths/compsci students want that :)
06:31:57 <mlysgaard> but arbitrary sub/superscript
06:32:13 <mlysgaard> Hehe ;)
06:32:38 * EvilTerran does, anyway
06:32:51 <FunctorSal> mlysgaard, are you trying to make an editor that has some (possibly incomplete) understanding of semantics?
06:33:24 <ivanm> mlysgaard: auctex + previewlatex ;-)
06:33:30 * EvilTerran would take it further, into full-blown shiney-graphics proof-assistant territory
06:33:44 <ivanm> EvilTerran: "shiny"?
06:33:53 <mlysgaard> Well, yeah. I wold like to make an editor that could edit symbolic expressions in real time. Looking like latex formulas
06:34:13 <FunctorSal> EvilTerran: believe it or not, I've started some 3d commutative diagrams thing with specular arrows ;o
06:34:27 <ivanm> whizzytex IIRC has something like this (though it's more like it draws the preview in real time)
06:35:01 <Saizan> and bidirectional conversion between diagrams and equations for CT
06:35:11 <EvilTerran> FunctorSal, ooo
06:35:46 <FunctorSal> I'm not sure what to use as underlying logic though :-(
06:36:13 <FunctorSal> writing a complete logic toolkit with unification and stuff from scratch seems a bit daunting
06:36:36 <EvilTerran> it is, i've tried =/
06:38:19 <FunctorSal> maybe the first-order theory of the category of sets would be a fitting foundation
06:38:47 <mlysgaard> Well, what my goal is to make some sort of digital mathematical blackboard. Anyone tried the HP 40gs calculators they have this function
06:41:03 <jbauman> mlysgaard, a CAS like mathematica?
06:42:56 <mlysgaard> Well, im just a high scool student so i'm just fooling around. Made some symbolic math types and some simple simplify functions and i'd like to make a good interface to it.
06:43:20 <mlysgaard> jbauman: But in a essence a CAS, just wery simple
06:48:59 <wli> I got burned trying to de-nest radical expressions.
06:49:23 <wli> The polynomial factorization methods turned out to be beyond my power.
06:50:17 <jacobian> Is it correct to say that inf=inr(inf) is the limit point of the monad nu X . 1 + X
06:51:11 <wli> I never got far enough to try to compute integral bases for radical extension rings.
06:52:54 <marcot> @hoogle String -> ReadP a -> a
06:52:55 <lambdabot> Did you mean: String -> ReadP a a -> a /count=20
06:52:55 <lambdabot> Debug.Trace trace :: String -> a -> a
06:52:55 <lambdabot> Distribution.ParseUtils field :: String -> (a -> Doc) -> ReadP a a -> FieldDescr a
06:53:22 * EvilTerran feebly pokes at the sizable write-up he really needs to get done
06:53:25 <marcot> How can I get the parsed result of a ReadP?  Do I have to convert it to ReadS?
06:53:41 <EvilTerran> marcot, i believe that's whatthe docs suggest, yeah
06:53:53 <marcot> EvilTerran: ok, thanks.
06:54:21 <EvilTerran> "Converts a parser into a Haskell ReadS-style function. This is the main way in which you can "run" a ReadP parser: the expanded type is  readP_to_S :: ReadP a -> String -> [(a,String)]"
06:56:32 <sayyestolife> hello
06:56:47 <sayyestolife> Isn't there some site for haskell "snippets"?
06:57:14 <EvilTerran> hpaste.org ?
06:57:34 <FunctorSal> I can make a substitution idempotent by composing it with itself until it becomes stable, right?
06:58:06 <FunctorSal> (premature optimization be damned ;))
06:58:15 <sayyestolife> EvilTerran I'm thinking more in the terms of http://www.djangosnippets.org, where only "useful" stuff gets posted
06:58:26 <sayyestolife> not some temporary paste
06:58:52 <EvilTerran> oh right
06:59:01 <doserj> *cough* useful snippets end up on hackage *cough*
06:59:18 <EvilTerran> i think the norm is to write a blog post and link it on reddit
06:59:35 <sayyestolife> EvilTerran hmm.. okay
07:00:01 <sayyestolife> but I'm thinking about something more like almost wikilike
07:00:18 <EvilTerran> i don't think that particular niche has been filled yet
07:00:35 <EvilTerran> although some of the haskellwiki pages are effectively useful code snippets
07:08:09 <sayyestolife> EvilTerran okay thanks!
07:22:01 <tibbe> I was playing around with the Haddock CSS a bit: http://johantibell.com/haddock.png (design stolen from all over the place)
07:26:52 <xian> Is there any easy way to overwrite instance declarations in case ghc is complaining that there is more than one for a specific type? (I'm playing around with typeclasses at the moment, so I get this quite often)
07:28:32 <EvilTerran> xian, instances are global, unfortunately; it's a limitation of the typesystem
07:29:05 <EvilTerran> the semantics would have to be changed substantially to allow local instances, as i understand it
07:29:17 <EvilTerran> xian, although you could write your instances for a newtype-wrapped version of the type
07:29:56 <xian> Yeah, that seems like a good idea. But I couldn't use functions defined on the original type then, could I?
07:30:22 <EvilTerran> "newtype MyInt = MyI Int deriving (<whatever classes you want derived>); instance Ord MyInt where ...", say
07:30:45 <EvilTerran> xian, well, you could use the deriving mechanism to get instances of Eq, Ord, Read, Show etc for free,
07:34:01 <Philonous> Concurrent programming in haskell really is fun, (at least compared to C or Java). Maybe that should be emphasised when advertising haskell.
07:34:15 <xian> What I mean is that in the above case I couldn't call functions defined specifically on Int even though MyInt is basically the same as Int.
07:35:53 <EvilTerran> xian, yeah, you'd have to add/remove the newtype's constructor if you wanted to do that
07:36:21 <Jedai> xian: No you couldn't, on the other hand if you want to use your type exactly like an Int except on some very rare occasion, maybe you should just create some new functions rather than try to modify the current ones
07:36:55 <ray> generalized newtype deriving would let you get instances of anything the actual type's an instance of for free
07:37:10 <Jedai> xian: also one thing that is useful on newtypes is that you can "derive" any typeclass that was instancied for the original type, even the one that can't be derived usually
07:37:12 <EvilTerran> ray, but you'd still be stuck on functions that aren't class methods
07:37:28 <ray> yeah, functions that aren't class methods are such a pain
07:37:40 <ray> general types ftw
07:37:48 <Fred320> @pl \x z -> x ++ y:z
07:37:49 <lambdabot> (. (y :)) . (++)
07:38:09 <ray> also, polymorphic functions, not just methods
07:39:19 <EvilTerran> true, i meant classwise polymorphic functions
07:43:52 <CalJohn> I'm starting a new project, but Setup insists that the dependancy bencode is missing, but I am sure it is installed
07:44:06 <CalJohn> do i need to add .cabal to the path or something?
07:44:58 <mauke> no, you need to list your dependencies in your cabal file
07:45:12 <mauke> wait, hmm
07:45:19 <mauke> what's the exact error message?
07:45:25 <ksf> quite OT, but can someone point me to a good book leading up to SICM?
07:46:38 <CalJohn> mauke: "at least the following dependancies are missing: bencode -any"
07:46:53 <CalJohn> mauke: i have listed them in my cabal file
07:47:00 <mauke> yes
07:47:12 <mauke> what does 'ghc-pkg list bencode' say?
07:47:13 <lilac> ksf: you mean SICP?
07:47:14 <lambdabot> lilac: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:47:24 <ksf> nope, SICM.
07:47:32 <CalJohn> lilac: no, the newish scheme book for classical mech
07:47:32 <ksf> http://mitpress.mit.edu/SICM
07:47:55 <ksf> ...if you need something leading up to SICM, you're in trouble.
07:47:59 <CalJohn> mauke: /usr/lib/ghc-6.8.2/package.conf:
07:47:59 <CalJohn> /home/cal/.ghc/i386-linux-6.8.2/package.conf: bencode-0.3
07:48:02 <ksf> s/sicm/sicp
07:48:12 <lilac> damn you sussman!
07:48:20 <mauke> CalJohn: try Setup configure --user
07:48:37 <CalJohn> mauke: seems to work fine, why?
07:48:46 <doserj> CalJohn: or just cabal install
07:48:55 <mauke> you installed bencode as a user package
07:49:07 <mauke> a system package can't depend on a user package
07:49:19 <mauke> so you need to build your new project as a user package too
07:49:49 <CalJohn> mauke: i see, thankyou
07:56:57 * ksf wonders why he spent years at school studying stuff that was already obsolete in 1750.
07:57:14 <mauke> ... latin?
07:57:26 <ksf> newtonian mechanics.
07:57:49 <p_l> ksf: because for a big part of the time, they are good enough approximation?
07:58:27 * p_l thought that first lesson in physics was "if you can, approximate"
07:58:45 <ksf> so I thought, but it figures that around 1750, better formalisms were introduced that capture the same range of phenomena, and those are the same formalisms that are used for relativity and quantum mechanics.
07:59:20 <p_l> ksf: but are you going to use them while dealing with the same range as newtonian mechanics do?
07:59:29 <p_l> as in "what is easier"
08:00:22 <ksf> no idea, I was never able to figure out why my newtonian calculations were wrong, and don't grok lagrange yet.
08:01:07 <wli> The calc of variations is big.
08:01:26 <EvilTerran> and scary!
08:02:28 <p_l> there are whole computationally heavy areas in physics/engineering that don't care about quantum mechanics or relativity, for the simple reason they deal with "relatively" low speeds in macroscale :)
08:03:02 <wli> Yeah, Newtonian mechanics are by no means obsolete.
08:04:22 * p_l recalls how "HOWTO for ANSYS clusters, by scientist to scientist" noticed everyone "keep CFD guys out, they *always* eat all processing power, no matter how much there is"
08:05:10 <ksf> tbh, I'm just attracted to the idea of just grokking a few lines of scheme to understand stuff, as opposed to figuring out the flaws in a particular incarnation of "standard notation".
08:05:43 <gwern> ksf: you sound like the Structure & Interpretation of Classical Mechanics book :)
08:06:00 * ksf doesn't think it's the reader's job to sort the writer's thoughts.
08:07:00 <ksf> ...or figure out arguments by abstract hand-waving.
08:11:20 <ksf> ...according to wikipedia, lagrange gets rid of a lot of constraints you have to solve.
08:11:52 <wli> Take the Lagrangian, Luke.
08:14:24 <Flugaren> Does anyone here have any experience with HList?
08:26:36 <marcot> Where can I get an example of TH [d| |]?
08:28:58 <EvilTerran> , [d| len [] = 0; len (x:xs) = 1 + len xs |]
08:28:59 <lunabot>  FunD len [Clause [ConP [] []] (NormalB (LitE (IntegerL 0))) [],Clause [In...
08:34:34 <acieroid> hi
08:36:58 <acieroid> is there some function like System.getEnv, but for setting a env's variable ?
08:37:14 <marcot> EvilTerran: but what should I so with it?  I have f = [d| len [] = 0; len (x:xs) = 1 + len xs |]; f :: Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec] .  Now how can I use it?
08:37:31 <QtPlaty[HireMe]> acieroid: You can't set an enviroment verable in the Posix model
08:37:57 <QtPlaty[HireMe]> Well programs can't anyway.
08:38:04 <acieroid> hmm
08:38:19 <acieroid> how a shell can change variables so ?
08:39:10 <QtPlaty[HireMe]> acieroid: The shell can change variables because the variables are part of the shell.  The programs that are spawned by the shell can't change the enviroment vars of there perents.
08:39:28 <acieroid> ok
08:40:05 <acieroid> and, how the shell passes his environment to his child processes ?
08:40:40 <QtPlaty[HireMe]> acieroid: Its an argument to the exec call it makes IIRC
08:41:09 <EvilTerran> marcot, writing "$f" in a list of defintions would be the same as writing "len [] = 0; len (x:xs) = 1 + len xs"
08:41:29 <doserj> acieroid: there is System.Posix.Env
08:41:43 <acieroid> hmm, I'll look at that, thanks
08:51:07 <marcot> EvilTerran: Where do I use a list of definitions?  That's what I'm not understanding.
08:51:32 <EvilTerran> marcot, the top-level of a module
08:52:33 <doserj> or inside a let or where block
08:52:44 <EvilTerran> marcot, if you want to use TH in where or let clauses, i'd suggest using [|...|] and writing "someName = $(...)", rather than including the "someName =" in a TH construction
08:52:56 <EvilTerran> doserj, can you? lunabot doesn't seem to like it, at least
08:53:20 <marcot> EvilTerran: My goal is to write a instance using TH.
08:53:21 <EvilTerran> , let $([d| x = () |]) in ()
08:53:22 <lunabot>  luna: parse error on input `in'
08:53:57 <doserj> hmm
08:54:26 <EvilTerran> doserj, [d|...|] includes data, instance, etc declerations, so doesn't strike me as appropriate for let/where clauses
08:56:46 <doserj> true, [d|..|] only does top-level declarations, not arbitrary declarations
08:57:44 <EvilTerran> ?where derive
08:57:44 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
09:01:52 <Deewiant> Gah, has anybody managed to compile Catch?
09:04:37 <TomMD> Deewiant: I used catch a little back when it was new and Niel still worked on yhc.  Haven't touched it since.
09:05:20 <TomMD> Deewiant: It sounded like Neil did some initial work to bring Catch to GHC but hes time is all taken up by his day job now.
09:05:24 <TomMD> @seen ndm
09:05:25 <lambdabot> I haven't seen ndm.
09:06:29 <Deewiant> Yes, I suppose I should have added "recently" to my query... I'm getting type errors in Catch's use of the Yhc core lib
09:06:33 <dons> i'd love to see an analysis framework for ghc core
09:06:40 <dons> so we can write catch and other   things.
09:06:49 <dons> i mean, they have CiL et al for C code. so why no lib for haskell analysis?
09:06:50 <Deewiant> I don't mind the fact that it uses Yhc, compiling Yhc was the easy bit :-P
09:06:59 <pejo> I think Neil was considering using external core output from GHC for Catch. But not sure how much time he has on his hands now with the daytime job.
09:07:00 <dons> well, it makes it less useful for real code
09:07:09 <mauke> preflex: seen ndm
09:07:09 <preflex>  ndm was last seen on #haskell 12 days, 5 hours, 50 minutes and 30 seconds ago, saying: plus with current compiler technology, it would be slower
09:07:16 <dons> i'd just like a description of the analysis, so we could reimplement it
09:07:49 <Deewiant> I'd just like these two programs by the same author to compile against each other :-P
09:07:52 <pejo> dons, have you looked at the catch paper?
09:08:03 <dons> TomMD: know much about separation logic?
09:08:05 <dons> pejo: yes.
09:08:26 <pejo> dons, didn't he describe the analysis there?
09:08:53 <dons> I don't recall a formal description, but I might be wrong.
09:09:23 <dons> I'm wary of the hand wavy use of the term "proof" around ad hoc analysis
09:10:36 <pejo> dons, I think you need to assemble all the figures.
09:10:59 <dons> yes, it looks like there's a fair bit of material now. much more than when I used catch on xmonad back in the day.
09:11:02 <pejo> (Not making any claims about the proof, I'm guessing you want it mechanized).
09:11:13 <dons> well, i just want to know what the underlying theory is.
09:12:05 <dons> and a characterisation of what it finds, and what it won't, and why.
09:12:20 <pejo> dons, what would the underlying theory be for "Assemble a bunch of constraints according to the semantics, and prove that you can't get a pattern mismatch"?
09:12:24 <dons> of course, any static analysis that finds a bug we didn't spot is useful.
09:13:09 <dons> pejo: so its some kind of symbolic interpretation? the code is evaluated, symbolically, yielding constraints on types, that are used to refine the types at pattern match time.
09:13:13 <pejo> dons, I've been thinking about characterisations for what Supero can remove, but it's far from trivial. Even if you accept pen and paper proofs.
09:13:14 <mmorrow_> dons: a standardized (external) "core" language (compiler-indep) for haskell would be awesome
09:13:16 <Deewiant> So I take it nobody has any idea of the newest Yhc version that the latest Catch accepts? (Or, likewise, the newest Catch version that compiles against the latest Yhc)
09:13:39 <dons> or is it a kind of type inference?
09:14:16 <mmorrow_> there's a core-erlang pkg on hackage with a similar thing for that
09:14:58 <pejo> dons, how many existing analyses do you know of that characterises what it can find and can't find, and prove it?
09:15:40 <dons> pejo: i'm at a conference this week that's full of such things :)
09:15:58 <dons> but yes, there's a scale in the static analysis world from formal stuff to ad hoc 'lint'-like tools
09:16:01 <mmorrow_> links?
09:16:05 <dan> does anyone know if there's a way to add a path to the search path where ghci looks for files to :load?
09:16:17 <mmorrow_> dan: it's relative to your pwd
09:16:20 <pejo> dons, small disclaimer: I'm in no way an expert on catch. I'd just like it to work for GHC. We know it's not complete, but I think it would be useful.
09:16:22 <dons> mmorrow_: i'll dig around to see if something's online.
09:16:28 <dons> pejo: agreed!
09:16:41 <dons> it was very useful for xmonad.
09:16:48 <dons> and we need more tools like this.
09:16:55 <mmorrow_> dons: excellent
09:16:57 <dan> mmorrow_: Is there anyway to make a relative import?
09:17:05 <pejo> dons, the tools that people actually *use* are far closer to Lint than what the researchers are working on I think.
09:17:06 <dan> import mysubdir/mymodule
09:17:44 <mmorrow_> :m + Asdf.Qwerty.Jkl   ====>  ./Asdf/Qwerty/Jkl.hs
09:17:57 <mmorrow_> err, sorry :l
09:18:08 <dons> pejo: yep.
09:18:20 <pejo> dons, (I know Galois does crazy stuff and proves stuff with Isabelle/HOL, but that's an exception, just like the Airbus stuff).
09:18:44 <dan> i just don't know what is the correct way to set up a haskell workspace. Do I have to put all my modules which I am importing in a single dir?...
09:19:31 <dons> pejo: right, but we are a community that should be precise when using words like 'proof'
09:20:16 <pejo> dons, even as a community we disagree on what a proof means. Some want constuctive proofs, ..
09:21:31 <pejo> dons, have to run. Let's get back to this later. I have a couple of more questions about your statements. ;)
09:21:37 <dons> just stating what formal system is used to produce the proof, is all. if it is 'a haskell program that does some analysis' , that's fine.
09:22:04 <gwern> maybe we could just agree that anything more rigorous than quickcheck is a proof
09:22:06 <marcot> EvilTerran: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5100#a5100
09:22:32 <dons> gwern: no, there's clear notions of soundness and completeness. this is something we can be formal about.
09:22:35 <marcot> EvilTerran: I still don't get how can I use Dec in TH.  I'm searching about this, but I could not find any start point.
09:23:06 <paper_cc> dan: If you don't use hierachical modules, then yes (except library modules - that are searched automatically).
09:23:50 <paper_cc> marcot: you should define f in a different module, as it says
09:25:31 <marcot> paper_cc: and how can I use the definition inside f in the module which imports it?
09:26:01 <marcot> paper_cc: Do you know where can I find a use of Dec?
09:26:17 <paper_cc> marcot: $f I think
09:26:57 <marcot> paper_cc: ok, I think it worked.  Why is there a restriction to use it in the same module?
09:28:09 <paper_cc> marcot: it isn't only for Dec (also for quasiquoting). the reason for the restriction is that TH is a single-pass thing I think
09:28:26 <marcot> paper_cc: ok.. Thanks. =)
09:32:24 <dan> paper_cc: thank you
09:34:06 <paper_cc> marcot: the deriveShow example at the very end of http://www.haskell.org/bz/thdoc.htm does generate declarations
09:37:35 <marcot> paper_cc: Thanks, I haven't seen that.
09:43:36 <marcot> Is there a way for a Cabal package to produces more than one library?
09:44:24 <tibbe__> when can you actually sign up for icfp?
09:48:51 <PeakerWork> are there SSL wrappers for Haskell?
09:49:23 <PeakerWork> HsOpenSSL/hopenssl on hackage -- which do I choose, hmm
09:52:10 <dan> is there a natural way to define types in haskell which have value limitations on them? Say, a list of ascending numbers? I don't want to give it a data constructor from just a list, because then i would have to throw some sort of exception if a mismatching list is given in the constructor
09:52:31 <ray> tibbe__: at least one of the previous contests had you sign up by submitting your solution
09:52:46 <kpreid> dan: no
09:52:49 <tibbe__> ray: the conference, not the competition ;)
09:53:00 <ray> there's a conference?
09:53:02 <ray> :)
09:53:03 <augustss> dan: not without dependent types
09:53:07 <kpreid> dan: all you can do is write a type which does can't represent the values
09:53:41 * paper_cc is interested
09:54:04 <PeakerWork> dan: hey :-)  its called "subtypes", I believe, and Haskell doesn't have them directly. But you can use a representation of your own which can only be interpreted in correct ways.. For example, use a list of positive integers (Word8, for example) and have each represent the delta rather than the value
09:54:05 <paper_cc> augustuss: what can one do with TypeFamilies?
09:54:26 <burp_> is there some environment variable or other easy way for additional library paths ghc(i) should use?
09:54:29 <paper_cc> s/augustuss/augustss/, sorry
09:54:46 <burp_> so I don't have to type ghci -lgsl -latlas -lcblas -llapack -lf77blas -L./mylocallibs/lib
09:55:37 <dan> PeakerWork: Interesting...
09:55:41 <augustss> paper_cc: not in a general way
09:55:42 <mmorrow_> alias ghci1337='.....'
09:56:12 <mmorrow_> GHCILEET='...'; $GHCILEET
09:56:39 <dan> how about if i want a list of unique values?
09:56:43 <dan> as a type
09:56:58 <mauke> Set
10:00:35 <dan> how about if i want a list of 2-tuples, where the fst values are all unique (equal to their own Set), with no limitation on the snd values? is there any way to make a data type for that list in a way that doesn't let anyone construct a malformed one?
10:00:53 <lilac> Data.Map?
10:01:13 <lilac> basically, these restrictions are enforced by construction in haskell
10:01:30 <lilac> you define an abstract data type and only provide operations which maintain whichever invariant you want
10:02:34 <bo0ts__> Hi, noob question: I use $ ghci 2>&1 | HsColour -tty for coloured output in ghci put I always gets the linebreaks wrong which is quite annoying.
10:02:42 <bo0ts__> Is there any workaround?
10:02:46 <dan> Data.Map is just another way of saying "take your regular list of 2-tuples, and if you have som repeating fst values, join them up together" - which is NOT what i want
10:03:13 <Beelsebob> bo0ts__: awesome idea... no idea how to solve it though :(
10:03:27 <bo0ts__> Beelsebob: The wiki told me to do so ;>
10:03:32 <lilac> dan: dan join them up together?
10:03:37 <lilac> -dan
10:03:56 <lilac> Data.Map is usually right-biased; new things override old things (iirc)
10:04:25 <lilac> unless you want the type checker to notice if you try to add the same key twice, i'm not sure what else you could want from it
10:04:42 <bo0ts__> Beelsebob: And I just confirmed that it happens with xterm as well. So aint a emulator problem.
10:05:26 <dan> lilac: I'm guessing the type checker can't do this for Data.Map - and so this isn't a good solution for my problem
10:06:25 <lilac> dan: if you want to statically check that there aren't duplicate keys, i think you could do that with something like oleg's HList
10:07:24 <lilac> bo0ts__: by "gets the linebreaks wrong", what do you mean? it seems to be sorta-wroking for me
10:08:13 <bo0ts__> Well, if I have a syntax error "Prelude>" will be on the same line as the last output.
10:08:29 <bo0ts__> lilac: It's rather: The last linebreak is missing.
10:09:14 <PeakerWork> dan: how can you prove at compile-time that all run-time values you'll give to the map are unique?
10:09:32 <PeakerWork> dan: if they are otherwise arbitrary?
10:09:37 <lilac> bo0ts__: interesting. i'm trying this on a ghci without readline support, maybe that's the issue?
10:10:29 <bo0ts__> lilac: I'm using ghci from arch testing repositories.
10:10:46 <bo0ts__> lilac: Do I need to recompile to disable readine?
10:10:48 <nominolo> @seen MarcWeber
10:10:48 <lambdabot> I saw MarcWeber leaving #haskell 4m 3d 7h 54m 11s ago, and .
10:12:59 <lilac> bo0ts__: i'm not sure that'd be step forwards :)
10:13:05 <lilac> ghci without readline is painful
10:13:48 <mauke> cat | ghci
10:14:04 <copumpkin> meow
10:16:57 <dan> lilac: Thank you, will check that out
10:17:01 <bo0ts__> lilac: No, coloured ghci for me :< I'm going back to ruby! ; )
10:17:04 <Cale> bo0ts__: If you're using 6.10.1 or 6.10.2 it probably uses editline which is terrible but isn't GPLed. 6.10.3 uses haskeline which is decent and again BSD licensed.
10:17:26 <Cale> Coloured?
10:17:38 <copumpkin> a repl with syntax highlighting :o how would that work?
10:17:44 <lament> beautifully
10:17:48 <Twey> Slowly :-P
10:17:50 <copumpkin> I want!
10:18:12 <eivuokko> Coloured envious of haskell features.  Naturally ghci doesn't need to be envious.
10:18:51 <bo0ts__> Cale: Not much of a difference anyway. It was just the output.
10:19:12 <Cale> Oh, I would have imagined it would just be the input.
10:19:28 <Twey> The input would make more sense.
10:19:33 <eivuokko> Indeed.
10:19:34 <Twey> Why, the output may not even be Haskell code!
10:20:36 <lilac> hooray, "cat | ghci 2>&1 | HsColour -tty" works pretty well
10:20:58 <Twey> But cat has no readline
10:21:06 <lilac> nor does my ghci
10:21:14 <Twey> Ah :-P
10:22:09 <Cale> http://www.smbc-comics.com/ -- ahaha, today's is good :)
10:22:34 <bo0ts__> lilac: Hm, and it corrupts tab completion.
10:22:54 <Twey> Hahaha, Cale
10:23:58 <lilac> bo0ts__: hmm, tab completion in ghci would be nice...
10:24:10 <Cale> ghci normally has tab completion
10:24:13 * lilac still walking uphill backwards barefoot in the snow
10:24:23 <lilac> Cale: see above re no readline ;-)
10:24:34 <lilac> my ghci doesn't even have working backspace
10:24:38 <Cale> readline is also unnecessary for it to work ;)
10:24:47 <Cale> You're using one of the editline versions
10:24:52 <bo0ts__> lilac: Another "feature" cat broke xD
10:24:52 <Cale> Get 6.10.3
10:24:56 <nominolo> anyone know how to get the current process ID in Haskell?  I want to write a deamon.
10:24:59 <Gracenotes> rlwrap
10:25:09 <lilac> Cale: 6.10.1 not good enough? :(
10:25:10 <Gracenotes> mehbeh
10:25:13 <Cale> lilac: Right.
10:25:28 <Cale> lilac: 6.10.1 and 6.10.2 used editline which is crap
10:25:28 <lilac> @hoogle processID
10:25:29 <lambdabot> System.Posix.Types type ProcessID = CPid
10:25:36 <lilac> @hoogle IO ProcessID
10:25:37 <lambdabot> Did you mean: :: IO ProcessID /count=20
10:25:37 <lambdabot> No results found
10:25:39 <mauke> lilac: 6.10.{1,2} are better if you patch and compile them yourself
10:25:43 <Twey> System.IO.Posix.getProcessID
10:25:50 <Twey> Er
10:25:53 <Twey> System.Posix.getProcessID
10:25:54 <Twey> Rather
10:25:59 <Cale> mauke: But don't bother doing that. Just get 6.10.3 :)
10:26:02 <mauke> lilac: 6.10.3 is not entirely broken (like editline) but still inferior to readline
10:26:12 <Cale> In what way?
10:26:19 <Cale> It works perfectly.
10:26:19 <mauke> mappings
10:26:21 * wli hasn't bothered upgrading.
10:26:23 <copumpkin> it doen't have RMS' stamp of approval on it
10:26:36 <mauke> Cale: its history works completely differently
10:26:40 * lilac fails to understand how editline can be so bad
10:27:21 <wli> vi keybindings ... woops it doesn't do those, does it?
10:27:35 <Cale> lilac: I fail to understand that as well. It has a number of shameful bugs in it. You can bind the delete key, but even then it doesn't work properly
10:27:35 <Twey> It is not as nice as readline, indeed
10:27:38 <PeakerWork> Does Network.Socket / Network.BSD expose me to byte-ordering issues?
10:27:45 <lilac> people actually *use* vi keybindings in line editors?
10:27:51 <mauke> "\C-[[A": history-search-backward
10:27:51 <Twey> Of course not
10:27:58 <PeakerWork> I am getting connection refused when I try to connect to a port that I know is open, using Network.Socket.connect  with (PortNum ..) constructor
10:28:04 <Twey> :-P
10:28:05 * wli uses vi keybindings.
10:28:12 * Twey uses emacs keybindings
10:28:15 <mauke> ^ you can't do that with haskeline, not even by writing custom Haskell code
10:28:29 <Cale> PeakerWork: Don't use the constructor
10:28:31 * lilac uses emacs keybindings in zsh but edits in vim
10:28:35 <Cale> er...
10:28:36 <PeakerWork> Cale: how do I use Network.Socket.connect?
10:28:39 * Twey thinks lilac is bonkers
10:28:42 <Twey> :-P
10:28:55 <PeakerWork> Cale: It wants a SockAddr -- whose SockAddrInet constructor wants a PortNumber
10:29:13 <mauke> PeakerWork: yes. do not use the PortNum constructor.
10:29:18 <dmwit> PortNumber is an instance of Num.
10:29:20 <Cale> Just use numeric literals for values of type PortNumber
10:29:41 <Cale> It's intended to take care of the byte ordering for you.
10:29:43 <PeakerWork> ah, I see, thanks
10:29:52 <PeakerWork> shouldn't expose the constructor then, IMO
10:31:17 <Cale> Interestingly, the haddock documentation for the network library doesn't seem to mention the constructor anymore.
10:31:47 <Cale> Oh, it does in Network.Socket
10:32:31 <lilac> Twey: i have emacs keybindings set up for ex mode in vim...
10:32:48 <frankks> @src ($)
10:32:48 <lambdabot> f $ x = f x
10:32:55 <lilac> ($) = id
10:33:07 <frankks> hm?
10:33:35 <Cale> frankks: Basically, the important thing about $ is that it has very low precedence
10:33:38 <Gracenotes> ($) f x = f x
10:34:03 <Cale> frankks: Which means that if you have an expression like  foo . bar . baz $ x + y
10:34:14 <Cale> It means the same as  (foo . bar . baz) (x + y)
10:34:32 <Twey> > (+1)
10:34:33 <lambdabot>       Overlapping instances for Show (a -> a)
10:34:33 <lambdabot>        arising from a use of `s...
10:34:35 <Twey> > (+1) 3
10:34:36 <lambdabot>   4
10:34:38 <lilac> ... because it means the same as (foo . bar . baz) $ (x + y)
10:34:41 <Twey> > id (+1)
10:34:42 <lambdabot>       Overlapping instances for Show (a -> a)
10:34:43 <lambdabot>        arising from a use of `s...
10:34:44 <Twey> > id (+1) 3
10:34:46 <lambdabot>   4
10:34:51 <Twey> > (+1) `id` 3
10:34:52 <lambdabot>   4
10:34:54 <Twey> > (+1) $ 3
10:34:55 <lambdabot>   4
10:34:57 <Twey> Like so.
10:34:58 <frankks> i see
10:35:21 <Twey> Where id (+1) 3 means (id (+1)) 3, of course, like all function application in Haskell
10:35:26 <lilac> ($) takes the function on its left hand side, does nothing to it, and then applies it to the value on its right hand side
10:36:09 <frankks> i'm just using it in the sense of length $ function [(string),(string),string)]
10:36:25 * Twey nods.
10:36:25 <frankks> ah ok
10:36:30 <frankks> sorry just read what you write
10:36:31 <frankks> wrote
10:37:30 <Gracenotes> yeah, a simple way to think about it is in terms of replacing parens
10:38:23 <lilac> > let ($) = id in (4$)
10:38:24 <lambdabot>   4
10:38:32 <lilac> > let ($) = id in length $ [1,2,3]
10:38:33 <lambdabot>   3
10:38:58 <frankks> surely
10:39:03 <frankks> > length [1,2,3]
10:39:05 <lambdabot>   3
10:39:08 <frankks>  produces the same result
10:39:17 <frankks> so.. what's the need?
10:39:39 <Gracenotes> > filter odd $ map (^2) [1..]
10:39:41 <lambdabot>   [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,15...
10:39:54 <Gracenotes> > filter odd map (^2) [1..]
10:39:56 <lambdabot>   Couldn't match expected type `[a]'
10:40:04 <mmorrow_> , zipWith id (fmap (*) [0..]) (repeat 2)
10:40:06 <lunabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50...
10:40:20 <frankks> so it allows you to apply a function to a value which hasn't yet been determined?
10:40:34 <frankks> so f $ f value
10:40:36 <Gracenotes> well. It's a lazy language.. technically all values haven't been determined :)
10:40:43 <Gracenotes> it's a way to avoid parens
10:40:46 <mmorrow_> since functions are values, you can apply functions to other functions/values to get yet more functions
10:40:47 <Gracenotes> in practice
10:40:55 <frankks> k
10:40:56 <Gracenotes> normally you'd write the above like, filter odd (map (^2) [1..])
10:41:32 <mmorrow_> @type (filter . odd . fmap (^2))
10:41:33 <lambdabot>     Couldn't match expected type `a -> Bool'
10:41:34 <lambdabot>            against inferred type `Bool'
10:41:34 <lambdabot>     Probable cause: `.' is applied to too many arguments
10:41:44 <mmorrow_> @type (filter odd . fmap (^2))
10:41:45 <lambdabot> forall a. (Integral a) => [a] -> [a]
10:42:41 <mmorrow_> @type [($),id]
10:42:42 <lambdabot> forall a b. [(a -> b) -> a -> b]
10:43:05 <Raevel> that was cool, somehow
10:43:29 <mmorrow_> unite!
10:43:29 <Gracenotes> IT ALWAYS IS
10:43:36 <lilac> > map (sum . map snd) . groupBy (on(==)fst) . map (head &&& length) . sort $ words "four frolicking foxes flitted feverishly through the furrow"
10:43:38 <lambdabot>   [42,10]
10:43:54 <frankks> @src (\)
10:43:55 <lambdabot> Source not found. Are you on drugs?
10:44:06 <Berengal> What's the complexity of nub?
10:44:18 <lilac> @src nub
10:44:18 <lambdabot> nub = nubBy (==)
10:44:21 <lilac> @src nubBy
10:44:21 <lambdabot> nubBy eq []             =  []
10:44:22 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:44:22 <Gracenotes> ⍥
10:44:28 <Gracenotes> nub is somewhat inefficient
10:44:29 <lilac> Berengal: hideous.
10:44:38 <lilac> Berengal: (it's quadratic)
10:44:45 <Berengal> O(n^2) looks like
10:45:03 <Berengal> So assuming I want a sorted nubbed list, map head. group . sort is the way to go, right?
10:45:16 <Gracenotes> well...
10:45:16 <lilac> Berengal: yep.
10:45:18 <Gracenotes> @src groupBy
10:45:19 <lambdabot> groupBy _  []       =  []
10:45:19 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
10:45:19 <lambdabot>     where (ys,zs) = span (eq x) xs
10:45:31 <Gracenotes> hm. better, it seems.
10:45:37 <pejo> lilac, is that how it's implemented in the Prelude as well?
10:45:58 <lilac> pejo: i believe so.
10:46:08 <lilac> (or at least something equivalent)
10:46:27 <Berengal> Or are sets the way to go?
10:46:28 <tombom> why is it implemented like that if it's so bad
10:46:45 <frankks> @src (\\)
10:46:46 <lambdabot> (\\) = foldl (flip delete)
10:46:54 <mmorrow_> > let histo = sortBy (flip compare `on` snd) . Map.toList . (\m -> let n = fromIntegral (Map.size m) in Map.map (\x -> fromIntegral x / n) m) . foldl' (\m a -> Map.insertWith' (+) a 1 m) mempty in histo "four frolicking foxes flitted feverishly through the furrow"
10:46:56 <lambdabot>   [(' ',0.35),('f',0.3),('r',0.3),('e',0.25),('o',0.25),('h',0.2),('i',0.2),(...
10:47:02 <lilac> pejo: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
10:47:24 <Berengal> tombom: I assume it's because nub preserves order
10:47:29 <copumpkin> zomg histo! zygohistomorphic prepromorphism?
10:47:36 <mmorrow_> the r's snuck in there unnoticed
10:47:39 <lilac> tombom: nub preserves order and doesn't require a (<)
10:47:50 <mmorrow_> at the expense of O(n^2)
10:48:01 <Gracenotes> real nubBy, coming through
10:48:04 <tombom> are thanks
10:48:09 <tombom> *ah oops
10:48:24 <Gracenotes> nubBy eq l = nubBy' l []
10:48:26 <Gracenotes>   where nubBy' [] _         = []
10:48:28 <Gracenotes>         nubBy' (y:ys) xs  | elem_by eq y xs = nubBy' ys xs
10:48:29 <Gracenotes>                           | otherwise       = y : nubBy' ys (y:xs)
10:48:31 <Gracenotes> elem_by :: (a -> a -> Bool) -> a -> [a] -> Bool (sort of an 'or' for two parameters)
10:48:44 <mmorrow_> Berengal: i'd do Set.fromList . Set.toList probably
10:48:51 <mmorrow_> err
10:49:01 <mmorrow_> Set.toList . Set.fromList
10:49:03 <Berengal> mmorrow_: Reverse those
10:49:07 <mmorrow_> heh
10:49:12 <lilac> Gracenotes: still quadratic though
10:49:15 <Gracenotes> the real nubBy is.. .still
10:49:17 <Gracenotes> yeah
10:49:21 <Berengal> Yeah, that should work fine. Doesn't look as impressive though :P
10:49:45 <Gracenotes> lilac: it might be possible to make a more fine-tuned version that's O(n)
10:49:57 <copumpkin> nope
10:50:01 <lilac> not for a general datatype
10:50:02 <Gracenotes> ...maybe. If you have an accumulator of the variable-to-be-compared-to?
10:50:03 <Berengal> Gracenotes: I believe O(n) requires a sorted list
10:50:04 <copumpkin> unless you know something beforehand
10:50:12 <Gracenotes> value that is
10:50:40 <frankks> O(n) is an unsorted list I think. Because it's possible you will have to look at every element to find what you're searching for
10:50:54 <copumpkin> frankks: that's just for finding one element though
10:51:19 <frankks> (didn't read it in context. oops.)
10:51:19 <copumpkin> if you're searching for n elements, you get O(n^2)
10:51:27 <Berengal> Well, if there's only a few values in the type being nubbed, such as Ordering, you could get O(n)...
10:51:52 <Gracenotes> maybe I'm thinking of a different algorithm from the one actually implement
10:51:57 <Gracenotes> ed
10:51:57 <copumpkin> if you assume a hashtable is O(1), and everything is hashable, then maybe
10:52:29 <Gracenotes> but, for instance, nubBy (==) [1,2,3,4,3,2,2]. You just check adjacent elements, and if you find a run, keep following it and continue at the end
10:52:39 <lilac> > const 0 M.fromList
10:52:40 <lambdabot>   /tmp/4852686047885518090:70:44: Not in scope: `M.fromList'
10:52:42 <lilac> @type M.fromList
10:52:44 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
10:52:45 <lilac> :(
10:52:48 <Gracenotes> Map.
10:52:52 <tibbe_> I was playing around a bit with the Haddock CSS: http://johantibell.com/haddock/Network-Socket-ByteString.html
10:52:55 <copumpkin> Gracenotes: that wouldn't work?
10:52:58 <tibbe_> tibbe_: pretty much stolen from Google
10:52:59 <Twey> Gracenotes: I think nubBy checks previous elements
10:53:03 <tibbe_> but I find it pretty
10:53:14 <Twey> > nub [1, 2, 1]
10:53:15 <lambdabot>   [1,2]
10:53:17 <lilac> Gracenotes: that returns [1,2,3,4] not [1,2,3,4,3,2]
10:53:23 <Gracenotes> oh. that sucks
10:53:39 <Gracenotes> but no other way to do it of course.
10:53:40 <copumpkin> if you have an ord, you can do it in nlogn time with map head . group . sort
10:53:41 <Berengal> nubBy does a filter on the remaining list
10:53:46 <Gracenotes> groupBy is more lenient
10:54:08 <Gracenotes> argh. they're not complements at all
10:54:26 <copumpkin> tibbe_: I like it, but the header looks ugly, and that lambda in the upper right corner in particular must go
10:54:33 <copumpkin> tibbe_: but the body of the text looks nice
10:54:50 <tibbe_> copumpkin: it's the standard heading, I didn't do anything to that part
10:54:56 <FunctorSalad_> maybe nub has rewrite rules for the common cases
10:54:58 <copumpkin> tibbe_: yeah :) exactly
10:54:59 <FunctorSalad_> ?
10:55:11 <copumpkin> I'd definitely support replacing the default haddock css with the one you made
10:55:21 <copumpkin> FunctorSalad_: not as far as I've seen
10:55:38 <Gracenotes> :⍵
10:55:47 <mauke> ω̈
10:55:51 <FunctorSalad_> copumpkin: hmm, I seemed to remember something about the sort-based nub not being faster after all in some simple example
10:55:56 <FunctorSalad_> but not sure
10:56:05 <copumpkin> it wouldn't be safe to do a nub replace any Ord instance's nub with a map head . group . sort
10:56:12 <copumpkin> because one isn't lazy
10:56:21 <mauke> > nub [2,1]
10:56:23 <lambdabot>   [2,1]
10:56:28 <FunctorSalad_> oh
10:56:31 <copumpkin> oh, and also it doesn't maintain order :P
10:56:40 <FunctorSalad_> hmm ok
10:56:51 <copumpkin> but the nub can lazily consume the entire list too
10:56:52 <Gracenotes> ╳╳╳╳╳╳╳╳╳╳
10:57:06 <mauke> > nub [0..]
10:57:07 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:57:12 <Hunner> What in the world are those?
10:57:19 <lilac> > map ($"four frolicking foxes flitted feverishly through the furrow") [nub, fmap snd . toList . fromList . fmap (snd &&& fst) . toList . fromList . flip zip [0,-1..] . reverse]
10:57:19 <mauke> U+2573 (e2 95 b3): BOX DRAWINGS LIGHT DIAGONAL CROSS [╳]
10:57:20 <lambdabot>   Not in scope: `toList'Not in scope: `fromList'Not in scope: `toList'Not in ...
10:57:58 <copumpkin> tibbe_: one minor point is that I feel the type signature of a function could be separated more from the text describing it... it's noticeable with your recvFrom function
10:58:02 <Gracenotes> > nub [0..] !! 100000
10:58:14 <tibbe_> copumpkin: I agree
10:58:18 <lambdabot>   thread killed
10:58:27 <tibbe_> copumpkin: didn't do anything there either, the markup really needs to be cleaned up
10:58:31 <copumpkin> yeah :)
10:58:38 <tibbe_> copumpkin: it's pretty gruesome
10:58:38 <Berengal> Gracenotes: Welcome to O(n^2)
10:58:51 <copumpkin> > nub [0..] !! 100
10:58:53 <lambdabot>   100
10:58:54 <copumpkin> whee!
10:58:55 <Gracenotes> well. I had to try out some values in ghci
10:58:57 <copumpkin> I win
10:58:58 <lilac> @type map snd . M.toList . M.fromList . map (snd &&& fst) . M.toList . M.fromList . flip zip [0,-1..] . reverse]
10:59:00 <lambdabot> parse error on input `]'
10:59:01 <lilac> 17:57 < mauke> U+2573 (e2 95 b3): BOX DRAWINGS LIGHT DIAGONAL CROSS [╳]
10:59:04 <FunctorSalad_> fasterNub = go mempty where { go seen (x:xs) | member x seen = go xs; go seen (x:xs) = x:(go (insert x seen) xs); go _ [] = [] }
10:59:05 <Gracenotes> the rest of them didn't grow so fast >_>
10:59:17 <lilac> gah damn copy-past grr
10:59:20 <copumpkin> lol
10:59:20 <FunctorSalad_> that would be lazy and preserve order I think, copumpkin
10:59:24 <Gracenotes> FunctorSalad_: good point
10:59:39 <lilac> @type map snd . M.toList . M.fromList . map (snd &&& fst) . M.toList . M.fromList . flip zip [0,-1..] . reverse
10:59:40 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:59:41 <copumpkin> > let fasterNub = go mempty where { go seen (x:xs) | member x seen = go xs; go seen (x:xs) = x:(go (insert x seen) xs); go _ [] = [] } in fasterNub [0..]
10:59:42 <lilac> ^^ faster nub
10:59:43 <lambdabot>   Not in scope: `member'
10:59:43 <Gracenotes> er, implementation, too.
10:59:50 <Gracenotes> Set.
10:59:51 <FunctorSalad_> err the mempty is supposed to be a Data.Set btw ;)
10:59:54 <Gracenotes> dot
11:00:06 <copumpkin> > let fasterNub = go Set.mempty where { go seen (x:xs) | Set.member x seen = go xs; go seen (x:xs) = x:(go (Set.insert x seen) xs); go _ [] = [] } in fasterNub [0..]
11:00:08 <lambdabot>       Failed to load interface for `Set':
11:00:08 <lambdabot>        Use -v to see a list of the ...
11:00:20 <copumpkin> FunctorSalad_: if it's Data.Set, it'd be n log n again though
11:00:23 <FunctorSalad_> hmm lambda doesn't have Set? :(
11:00:23 <copumpkin> but I guess better than sort
11:00:24 <Gracenotes> or... Data.Set.
11:00:30 <Berengal> @type S.toList
11:00:31 <lambdabot> forall a. S.Set a -> [a]
11:00:43 <copumpkin> I hate that @type has a different namespace setup than >
11:00:44 <lilac> Cale! Data.Set and Data.Map aren't working in lambdabot! ;-(
11:00:45 <Gracenotes> namespaces for Sets and Maps and ByteStrings are effed up
11:00:59 <dons> why?
11:00:59 <copumpkin> > let fasterNub = go Data.Set.mempty where { go seen (x:xs) | Data.Set.member x seen = go xs; go seen (x:xs) = x:(go (Data.Set.insert x seen) xs); go _ [] = [] } in fasterNub [0..]
11:01:02 <lambdabot>   Not in scope: `Data.Set.mempty'
11:01:04 <Gracenotes> and anything else that's qualified in L.js
11:01:05 <Gracenotes> *hs
11:01:07 <FunctorSalad_> mempty is in Monoid...
11:01:10 <copumpkin> > let fasterNub = go mempty where { go seen (x:xs) | Data.Set.member x seen = go xs; go seen (x:xs) = x:(go (Data.Set.insert x seen) xs); go _ [] = [] } in fasterNub [0..]
11:01:11 <lambdabot>   Add a type signature
11:01:12 <lilac> > const True Data.Map.fromList
11:01:12 <copumpkin> yeah, I realized that :P
11:01:13 <lambdabot>   /tmp/4946381460955546030:70:43: Not in scope: `Data.Map.fromList'
11:01:16 <Cale> lilac: 本当に?まったく…
11:01:17 <FunctorSalad_> I think there's also Data.Set.empty
11:01:34 <mauke> > M.fromList []
11:01:35 <lambdabot>   /tmp/513599841387006425:70:32: Not in scope: `M.fromList'
11:01:36 <copumpkin> > let fasterNub = go Data.Set.empty where { go seen (x:xs) | Data.Set.member x seen = go xs; go seen (x:xs) = x:(go (Data.Set.insert x seen) xs); go _ [] = [] } in fasterNub [0..] :: [Int]
11:01:37 <lambdabot>   Couldn't match expected type `[t]' against inferred type `S.Set t'
11:01:38 <Cale> > let fasterNub = go mempty where { go seen (x:xs) | S.member x seen = go xs; go seen (x:xs) = x:(go (S.insert x seen) xs); go _ [] = [] } in fasterNub [0..]
11:01:39 <lambdabot>   Add a type signature
11:01:42 <mauke> my emperor!
11:01:44 <copumpkin> I give up :)
11:01:45 <Berengal> Data.Set is called S, Data.Map is called M, simple as that
11:01:51 <Gracenotes> ugh. more screwed up than usual?
11:01:55 <copumpkin> Berengal: except if you ask for @type
11:01:55 <Cale> > S.empty
11:01:57 <lambdabot>   /tmp/521710655770533761:70:32: Not in scope: `S.empty'
11:01:59 <Cale> ...
11:02:01 <Cale> hmm
11:02:10 <Gracenotes> > Set.empty
11:02:12 <lambdabot>   fromList []
11:02:14 <Gracenotes> > Data.Set.empty
11:02:15 <lambdabot>   /tmp/2311465051563539008:70:32: Not in scope: `Data.Set.empty'
11:02:17 <Gracenotes> wha
11:02:25 <FunctorSalad_> whoa
11:02:34 <copumpkin> > let fasterNub = go Set.empty where { go seen (x:xs) | Set.member x seen = go xs; go seen (x:xs) = x:(go (Set.insert x seen) xs); go _ [] = [] } in fasterNub [0..] :: [Int]
11:02:35 <lambdabot>   Couldn't match expected type `[t]' against inferred type `S.Set t'
11:02:39 <FunctorSalad_> @let emptySet = S.empty
11:02:40 <lambdabot>  Defined.
11:02:42 <FunctorSalad_> yay
11:02:42 <copumpkin> okay, not my fault
11:03:02 <FunctorSalad_> @let insertSet = S.insert
11:03:03 <lambdabot>  Defined.
11:03:11 <FunctorSalad_> @let memberSet = S.member
11:03:11 <lambdabot>  Defined.
11:03:12 <copumpkin> this is ugly
11:03:17 <FunctorSalad_> =)
11:03:24 <lilac> > Map.fromList []
11:03:26 <lambdabot>   fromList []
11:03:27 <Gracenotes> hm. I don't see where the type error is.
11:03:44 <Gracenotes> Oh! the recursive case for Set.member x seen doesn't have enough params
11:04:00 <FunctorSalad_> sorry
11:04:00 <lilac> @check \xs -> (map snd . Map.toList . Map.fromList . map (snd &&& fst) . Map.toList . Map.fromList . flip zip [0,-1..] . reverse) xs == nub xs
11:04:02 <lambdabot>   "OK, passed 500 tests."
11:04:08 <lilac> yay, fast nub success
11:04:24 <lilac> @hoogle (a, b) -> (b, a)
11:04:25 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:04:25 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
11:04:25 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
11:04:27 <Gracenotes> Set is sorta fine... too...
11:04:34 <copumpkin> > (map snd . Map.toList . Map.fromList . map (snd &&& fst) . Map.toList . Map.fromList . flip zip [0,-1..] . reverse) [0..]
11:04:47 <copumpkin> tsk tsk :)
11:04:51 <lilac> copumpkin: ;-)
11:04:54 <Gracenotes>   Thread keeled
11:04:56 <lambdabot>   thread killed
11:04:59 <copumpkin> don't keel!
11:05:13 * lilac is clearly inadequately lazy
11:06:05 <FunctorSalad_> @let fasterNub = go emptySet where { go seen (x:xs) | memberSet x seen = go seen xs; go seen (x:xs) = x:(go (insertSet x seen) xs); go _ [] = [] }
11:06:19 <Gracenotes> Defined. . ... . .(>)
11:06:26 <FunctorSalad_> hehe
11:06:26 <Gracenotes> still. lots of GC overhead from the more "efficient" nubs
11:06:33 <Gracenotes> that is the constant!
11:06:55 <Fred320> @src foldr
11:07:03 <Cale> > Set.empty
11:07:13 <FunctorSalad_> lambdabot has gone home?
11:07:17 <Cale> Oh, what did you do!?
11:07:19 <Cale> hehe
11:07:35 * copumpkin strokes lambdabot
11:07:40 <Cale> Probably just have to wait, it'll come back.
11:07:54 <Cale> It was running for months unattended.
11:08:03 * Gracenotes tickles lambdabot
11:08:20 <lilac> copumpkin: interim pumpkinbot time?
11:08:38 <copumpkin> I can bring him (her?) in if you think I should
11:08:56 <lilac> copumpkin: i feel cold and lonely without a lambdabot here
11:09:26 <FunctorSalad_> Gracenotes: any better idea with respect to GC?
11:09:47 <Gracenotes> uh. binary heaps with mutable arrays? :)
11:09:49 <copumpkin> lambdabot authentication is so sophisticated ;)
11:10:04 <Gracenotes> Haskell is a heavily GC'd language any way you put it...
11:10:25 <lilac> > Set.empty
11:10:26 <pumpkinbot>       Failed to load interface for `Set':
11:10:26 <pumpkinbot>        Use -v to see a list of the ...
11:10:31 <copumpkin> lol
11:10:37 <copumpkin> > S.empty
11:10:38 <pumpkinbot>   mueval: Prelude.read: no parse
11:10:40 <copumpkin> fail
11:10:45 <Raevel> copumpkin: hah, i had to do the exact same thing earlier
11:10:46 <lilac> > fail "fail!"
11:10:47 <pumpkinbot>       No instance for (Show (m a))
11:10:47 <pumpkinbot>        arising from a use of `show' at <in...
11:10:50 <FunctorSalad_> > fix fail
11:10:52 <pumpkinbot>   ""
11:10:57 <copumpkin> wow, it really fails
11:11:03 <lilac> lol
11:11:21 <FunctorSalad_> oh, list monad
11:11:21 <copumpkin> no Data.Set for you!
11:11:57 <lilac> well that's no fun at all
11:12:05 <copumpkin> :(
11:12:05 <ray> no set monad for you
11:12:11 <copumpkin> rmonad!
11:12:19 <copumpkin> maybe I'll get RMonad on my bot
11:12:43 <copumpkin> > text "Segmentation fault"
11:12:44 <pumpkinbot>   Segmentation fault
11:12:53 <ray> > text "thread killed"
11:12:54 <pumpkinbot>   thread killed
11:12:56 <copumpkin> wow, my lambdabot barfs every time someone sends a message
11:13:00 <copumpkin> not only to it
11:13:06 <copumpkin> Main: caught (and ignoring) too few bytes. Failed reading at byte position 8
11:13:06 <Gracenotes> lol
11:13:12 <copumpkin> that's what it says every time anyone says anything
11:13:24 <Gracenotes> CATCH THIS, PUMPYBOT!
11:13:36 <copumpkin> just a sec
11:14:11 <copumpkin> how is it that screen's keys are always so messed up
11:14:48 <FunctorSalad_> is there some simple way to make stuff clickable in an opengl scene?
11:14:53 <FunctorSalad_> :(
11:15:08 <lambdabot>  Defined.
11:15:09 <lambdabot> foldr f z []     = z
11:15:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:15:11 <lambdabot>   mueval: Prelude.read: no parse
11:15:12 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
11:15:14 <lambdabot>  Terminated
11:15:21 <FunctorSalad_> I think I'll make "clickability centers" and see which center is closest to the line clicked on
11:15:37 <FunctorSalad_> sounds way easier than calculating the intersection with actual geometry
11:15:56 <Gracenotes> > "hello thar"
11:15:58 <lambdabot>   "hello thar"
11:16:03 <lilac> @type map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty)
11:16:04 <lambdabot> Couldn't find qualified module.
11:16:19 <lilac> @type map fst . filter (not . uncurry S.member) . (zip `ap` scanl (flip S.insert) S.empty)
11:16:21 <lambdabot> forall b. (Ord b) => [b] -> [b]
11:16:36 <lilac> @check \xs -> map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty) $ xs  == nub xs
11:16:37 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Bool'
11:16:49 <lilac> @check \xs -> (map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty) $ xs)  == nub xs
11:16:50 <lambdabot>   "OK, passed 500 tests."
11:17:01 <lilac> > map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty) [0..]
11:17:02 <lambdabot>   Couldn't match expected type `a -> [(a1, S.Set a1)]'
11:17:08 <lilac> > map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty) $ [0..]
11:17:10 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:17:12 <lilac> hooray
11:17:34 <lilac> @hoogle scanl'
11:17:34 <lambdabot> No results found
11:20:07 <Fred320> @src fold
11:20:07 <lambdabot> Source not found. Where did you learn to type?
11:20:09 <Fred320> @src foldl
11:20:09 <lambdabot> foldl f z []     = z
11:20:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:20:13 <lilac> FunctorSalad_: render each of your objects in turn (nearest first) offscreen onto a pbuffer, then check to see if the depth buffer is set at the clicked point
11:20:18 <lilac> *ducks*
11:20:45 <lilac> @type let fasterNub = map fst . filter (not . uncurry Set.member) . (zip `ap` scanl (flip Set.insert) Set.empty) in fasterNub
11:20:47 <lambdabot> Couldn't find qualified module.
11:21:20 <FunctorSalad_> hmm I'd have to look up "pbuffer"
11:21:37 <ray> it's short for pteriffic buffer
11:22:19 <Fred320> @src foldr
11:22:19 <lambdabot> foldr f z []     = z
11:22:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:27:46 <Cale> Fred320: A good way to think about how foldr f z works is that it replaces each (:) in the list with f and the [] at the end with z
11:28:08 <Fred320> thanks... i just wrote my own folds for exercise and wanted to compare to the original
11:28:13 <Cale> :)
11:28:58 <Fred320> i had a hard time understanding the difference between left and right fold at first, but that was only because the first examples produce a t form a list of t, and the often it does not matter which fold you choose
11:29:03 <Cale> foldr has the rather nice property that after each recursive step, the next thing to evaluate is always f, so if f doesn't need its second parameter, the foldr never continues
11:29:06 <Fred320> for example fold (+) 0 [1,2,3]
11:29:38 <Fred320> and foldl has the nice property of being tail recursive :)
11:29:44 <Cale> Whereas foldl always just calls itself selfishly until it reaches the end of the list. So it will never work on infinite lists.
11:30:23 <tetha> hm, this is fun on a very strange level. I started with removing redundancy and now Im implementing symbolic simplications with neutral and absorbing elements
11:30:41 <zoheb> @pl (\x -> if (x > 0) then fact (x-1) else 1
11:30:41 <lambdabot> (line 1, column 41):
11:30:42 <lambdabot> unexpected end of input
11:30:42 <lambdabot> expecting digit, variable, "(", operator or ")"
11:30:45 <zoheb> @pl (\x -> if (x > 0) then fact (x-1) else 1)
11:30:46 <lambdabot> flip (liftM2 if' (> 0) (fact . subtract 1)) 1
11:30:48 <tetha> (in some hobby-expression-evaluator, that is)
11:31:06 <zoheb> @type liftM2
11:31:07 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:31:25 <Cale> The tail recursiveness of foldl can be a useful property to exploit, but since lazy evaluation doesn't use a stack in the same way as the evaluators for most strict languages use one, it's less critical.
11:31:30 <Fred320> Cale: the fold really clicked for me with rev = foldl (flip (:)) []
11:31:35 <Cale> yeah :)
11:32:01 <Fred320> and of course app xs ys = foldr (:) ys xs
11:32:36 <Fred320> > foldr (:) "world!" "hello "
11:32:38 <lambdabot>   "hello world!"
11:32:51 <Cale> The occasional trouble with foldl is when you give it a function that can't build something immediately using its second parameter. It can build up a very large expression before giving it any chance to be evaluated.
11:32:52 <zoheb> @pl (\x -> if (x > 0) then x*fact (x-1) else 1)
11:32:53 <lambdabot> flip (liftM2 if' (> 0) (ap (*) (fact . subtract 1))) 1
11:32:54 <Cale> For example...
11:32:58 <Cale> foldl (+) 0 [1,2,3]
11:33:05 <Cale> -> foldl (+) (0+1) [2,3]
11:33:09 <Cale> -> foldl (+) ((0+1)+2) [3]
11:33:14 <Cale> -> foldl (+) (((0+1)+2)+3) []
11:33:19 <Cale> -> ((0+1)+2)+3
11:33:27 <Fred320> That's what foldl' is for, right?
11:33:30 <Cale> Yeah
11:33:40 <Cale> Those steps I just showed didn't use any stack.
11:34:14 <FunctorSalad_> is whnf the thing seq forces?
11:34:16 <Cale> But now, evaluating this result will require the stack, because (...) + 3 can't immediately result in something
11:34:21 <Cale> FunctorSalad_: yes
11:34:47 <FunctorSalad_> hmm
11:34:55 <Fred320> @src reverse
11:34:55 <lambdabot> reverse = foldl (flip (:)) []
11:34:59 <Cale> FunctorSalad_: WHNF means evaluate up to determining the top-level constructor, and if you just have a lambda, leave it alone.
11:35:22 <FunctorSalad_> I see
11:35:41 <Cale> (that is, don't start evaluating inside it)
11:37:02 <Wraithan> Ooo, a local code get together and they have a haskell session
11:37:06 <Wraithan> Think I will go attend that
11:37:07 <Cale> Fred320: So, (...) + 3 will get pushed on the stack, and then (...) + 2, and then we'll reach (0+1) which will evaluate, and we'll start coming back up.
11:37:11 <Wraithan> http://portlandcodecamp.org/sessions.aspx?tag=Haskell
11:37:18 <zoheb> @type liftM2 if'
11:37:19 <lambdabot> Not in scope: `if''
11:38:00 <Cale> Fred320: If the list was very long, this might blow up the stack, so foldl' solves the problem by forcing the evaluation of the accumulating parameter on each step.
11:38:11 <Fred320> @src foldl'
11:38:12 <lambdabot> foldl' f a []     = a
11:38:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:38:13 <Cale> That way, the expression never gets very large
11:38:26 <Fred320> thanks
11:38:34 <Cale> foldl' (+) 0 [1,2,3]
11:38:41 <zoheb> @type liftM2 if'
11:38:42 <lambdabot> Not in scope: `if''
11:38:46 <Cale> -> let y = 0 + 1 in foldl' (+) y [1,2,3]
11:38:50 <Cale> oops
11:38:57 <Cale> -> let y = 0 + 1 in y `seq` foldl' (+) y [1,2,3] -- rather
11:39:08 <zoheb> @type liftM2 (\x y z -> if x then y else z)
11:39:09 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (a2 -> a2)
11:39:10 <Cale> -> let y = 1 in foldl' (+) y [1,2,3]
11:39:22 <Fred320> you mwean [2,3]
11:39:24 <Cale> damn, I'm making mistakes ;)
11:39:26 <Cale> yes
11:39:30 <Fred320> i get it ;)
11:39:42 <Cale> But yeah, it'll evaluate the 0+1 before recursing
11:39:56 <Cale> and then the 1+2, and then the 3+3
11:40:09 <Cale> so that by the time it's done, the 6 will already be evaluated
11:40:13 <zoheb> @type liftM2 (\x y z -> if x then y else z) True
11:40:14 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Bool'
11:40:14 <lambdabot>     In the second argument of `liftM2', namely `True'
11:40:18 <Cale> > foldl (+) 0 [1..1000000]
11:40:20 <lambdabot>   * Exception: stack overflow
11:40:23 <Cale> > foldl' (+) 0 [1..1000000]
11:40:25 <lambdabot>   500000500000
11:40:29 <zoheb> @type liftM2 (\x y z -> if x then y else z) (Just True)
11:40:30 <lambdabot> forall a2. Maybe a2 -> Maybe (a2 -> a2)
11:40:34 <Cale> It can make a difference :)
11:40:56 <zoheb> @type ap
11:40:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:40:58 <stroan> @src foldl'
11:40:59 <lambdabot> foldl' f a []     = a
11:40:59 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:41:57 <zoheb> @type liftM2 (\x y z -> if x then y else z) (> 0)
11:41:58 <lambdabot> forall a2 a. (Ord a, Num a) => (a -> a2) -> a -> a2 -> a2
11:42:41 <paper_cc> is it possible to define an alias for a type context? (for example, I want to write (IsKeyType k) instead of (Ord k, Typeable k))
11:42:56 <FunctorSalad_> paper_cc: it's a proposal :(
11:43:10 <FunctorSalad_> paper_cc: a workaround is CPP
11:43:11 <zoheb> Is -> a Monad?
11:43:20 <paper_cc> zoheb: no
11:43:23 <ray> ((->) e) is
11:43:39 <zoheb> ray what does that mean?
11:43:56 <ray> functions from some type e
11:43:56 <zoheb> I am trying to make sense of the following
11:44:01 <paper_cc> FunctorSalad: :-/
11:44:05 <zoheb> @type liftM2 (\x y z -> if x then y else z)
11:44:06 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (a2 -> a2)
11:44:16 <zoheb> @type liftM2 (\x y z -> if x then y else z)  (> 0)
11:44:17 <lambdabot> forall a2 a. (Ord a, Num a) => (a -> a2) -> a -> a2 -> a2
11:44:35 <zoheb> Am I using the ((->) e) monad here?
11:44:47 <FunctorSalad_> we need some agreed syntax for type meta-variables
11:44:53 <paper_cc> zoheb: yes
11:45:07 <paper_cc> FunctorSalad_: type meta-variables == ?
11:45:08 <FunctorSalad_> (->) E is a monad for every type E
11:45:18 <ray> yeah, (> 0) is your m Bool there
11:45:25 <ray> in this case, m Bool is e -> Bool
11:45:44 <zoheb> ok
11:45:54 <FunctorSalad_> hmm
11:45:56 <frankks> @src (\\)
11:45:57 <lambdabot> (\\) = foldl (flip delete)
11:46:11 <FunctorSalad_> I'm a bit confuse
11:46:26 <ray> i'm a confusion bit
11:47:14 <FunctorSalad_> so do we really mean the monad that maps some type A to the polymorphic type e -> A?
11:47:27 <kpreid> confusionBit <- [(False)..]
11:47:38 <FunctorSalad_> that type would be a bit pointless
11:48:07 <paper_cc> FunctorSalad_: to a *monomorphic* type E -> A for some fixed E
11:48:19 <FunctorSalad_> paper_cc: right, that's the ambiguity I meant
11:48:28 <paper_cc> aha =)
11:48:29 <Cale> FunctorSalad_: No, for *each* e,  (->) e is a monad.
11:48:43 <Cale> right
11:48:54 <paper_cc> @quote fugue
11:48:54 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:48:55 <FunctorSalad_> Cale: that's what I was trying to say with "e is a meta-variable"
11:49:02 <FunctorSalad_> since a type variable makes polymorphic types...
11:49:12 <zoheb> I can't find source definitions for the ((->),e) Monad, is it built into the compiler?
11:49:27 <copumpkin> control.monad.instances
11:49:34 <ray> they have this silly Reader thing
11:49:36 <paper_cc> zoheb: no. essentially ((->) e) is the same as (Reader e)
11:49:37 <Cale> lol, there's a video here of a top US starcraft player playing in 26 poker games at once.
11:49:41 <frankks> could anyone explain what flip delete 'basically' does?
11:49:46 <Cale> They accused him of using bots.
11:50:06 <ray> a top starcraft player? only 26 poker games?
11:50:10 <copumpkin> :t delete
11:50:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
11:50:13 <Cale> ray: Well, US.
11:50:19 <copumpkin> > delete 2 [1..10]
11:50:20 <paper_cc> frankks: well, (flip delete) is the same as delete, but with arguments flipped =)
11:50:21 <lambdabot>   [1,3,4,5,6,7,8,9,10]
11:50:25 <Cale> ray: Probably the korean guys could do 100 ;)
11:50:28 <copumpkin> > flip delete [1..10] 2
11:50:30 <lambdabot>   [1,3,4,5,6,7,8,9,10]
11:50:45 <ray> a top korean starcraft player could play 26 poker games at once while also playing starcraft
11:50:50 <Cale> haha
11:51:03 <copumpkin> :t foldr delete
11:51:05 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:51:11 <tetha> Cale: a korean starcraft player could play so many poker games that joining them takes longer than the first poker game! ;)
11:51:14 <copumpkin> that's a useful function :P
11:51:37 <copumpkin> > foldr delete [] [1..10]
11:51:38 <copumpkin> mmm
11:51:38 <lambdabot>   []
11:51:39 <copumpkin> :P
11:51:55 <Cale> > foldr delete [1..10] [2,4,7]
11:51:57 <lambdabot>   [1,3,5,6,8,9,10]
11:52:05 <FunctorSalad_> I guess the difference is between (pseudo-haskell) "forall e. instance Monad (\a -> e -> a)" and "instance Monad (\a -> forall e. e -> a)"
11:52:13 <gwern> anyone familiar with this error in cabal?
11:52:14 <gwern> Preprocessing library HaskellForMaths-0.1...
11:52:14 <gwern> c:\Program Files\GnuWin32\bin\tar.exe: Cannot fork: Function not implemented
11:52:15 <gwern> c:\Program Files\GnuWin32\bin\tar.exe: Error is not recoverable: exiting now
11:52:19 <gwern> (sdist)
11:52:20 <Cale> FunctorSalad_: yeah
11:52:35 <gwern> no dcoutts is not here!
11:52:47 <Cale> gwern: Looks like you have a broken implementation of posix
11:53:10 <paper_cc> gwern: maybe you should use Cygwin?
11:53:17 <gwern> Cale: oh, it's not me. I'm not on windows thank goodness. but I was wondering if tar was installed at all, but I guess that doesn't match
11:55:22 <PetRat> test
11:56:03 <PetRat> I'm working some exercises in typeclassopedia. One of them is implementing liftM in terms of >>= and return. I get liftM g x =  x >>= return . g  ?
11:56:33 <Cale> yep
11:56:47 <Cale> :t \g x -> x >>= return . g
11:56:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
11:57:33 <Cale> It's prettier in terms of =<< and return
11:57:40 <Cale> return . g =<< x
11:57:43 <edwardk> @seen saizan
11:57:44 <lambdabot> saizan is in #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I don't know when saizan last spoke.
11:58:20 <byorgey> @pl \g x -> x >>= return . g
11:58:21 <lambdabot> fmap
11:58:33 <ray> tee hee
11:58:54 <byorgey> nice! I didn't realize that @pl knows all monads are functors =)
11:59:29 <PetRat> Cale: because it says intuitively "return (inject) the result of applying g to x"?
11:59:37 <SamB> it does, in fact, know things that Haskell 98 does not know :-(
11:59:41 <edwardk> byorgey: i suppose it could say 'liftM' to be a little more correct
11:59:55 <Cale> PetRat: That it applies g to the result of executing x
11:59:56 <byorgey> it could.
12:00:20 <frankks>  have a variable a, which is a list if strings [(string),(string),(string)] etc, and a variable t which is, ([(string),(string),(string)..],[[(string),(string),(string)..]]) - and the expression (a\\(fst t)). I understand it outputs what I want it to, but I can't work out exactly what \\ is doing. Can anyone explain?
12:00:26 <Cale> PetRat: In do-notation, it'd be  liftM g x = do v <- x; return (g v)
12:00:26 <frankks> (sorry for wall of text..)
12:00:38 <SamB> but this way, @pl helps us find library bugs
12:00:54 <Cale> frankks: \\ is list subtraction
12:01:07 <byorgey> frankks: well, if t is a pair of two lists, then  fst t  is the first of the two lists
12:01:23 <Cale> > "mississippi" \\ "miss piggy"
12:01:24 <frankks> so it's subtracting the first element from the list t ?
12:01:25 <lambdabot>   "ssipi"
12:01:32 <byorgey> oh, you're asking about \\  in particular. sorry =)
12:01:55 <Cale> It removes elements of the second list from the first list.
12:02:04 <byorgey> but only one of each.
12:02:07 <byorgey> > [1,1,1] \\ [1]
12:02:08 <Cale> right
12:02:09 <lambdabot>   [1,1]
12:02:16 <Cale> > [1,1,1] \\ [1,1]
12:02:17 <lambdabot>   [1]
12:02:24 <edwardk> oh, nice, i was thinking about an iterative deepening monad for a toy parser and found that Sebastian Fischer already wrote one.
12:02:37 <frankks> ok thanks chaps
12:03:19 <gwern> iterative deepening? == breadth-first?
12:04:05 <tetha> gwern: limited depth first with increasing limit
12:04:11 <edwardk> iterative deepening is depth-first-search to a fixed bound that you keep increasing as you go, starting from 1. so you get the traversal of BFS, with the space efficiency of DFS at the cost of retraversing stuff near the root
12:04:30 <gwern> hm. interesting compromise
12:04:40 <edwardk> if your branching factor is high you get a huge space win in exchange for a small recomputation cost.
12:05:03 <edwardk> i.e. 10-11% extra computation for a branching factor of 10 but huge asymptotic space wins
12:06:04 <edwardk> its commonly used in little chess engines, etc. because it combines really really nicely with MTD-f
12:08:23 <paper_cc> is it possible to write a Map with keys of type (forall a. Boxed a => Box a), provided that (Boxed a) => (Ord a)?
12:08:46 <copumpkin> how would it compare keys of different types?
12:09:13 <edwardk> i basically had the strange idea of trying to see if i can improve the asymptotics of a weird parser by treating it like a game, either of parser against string or more likely of parsing top down vs. bottom up cutting off possible parses
12:09:48 <gwern> go go game semantics?
12:10:01 <edwardk> or much more simply parsing left to right and right to left simultaneously and pruning parses that conflict as i walk left to right and right to left towards the center
12:10:32 <paper_cc> copumpkin: yes, it can't do that directly. Not specifically a Map, but a mapping type
12:10:48 <copumpkin> I mean, for any mapping type
12:10:54 <copumpkin> how would that happen?
12:10:56 * paper_cc found TypeRep -> IO Int
12:10:58 <PetRat> Okay, next exercise is implement ap in terms of >>= and return. (I'm going to use liftM because I already did.) ap x y = x >>= \g -> liftM g y  ??
12:11:21 <PetRat> :t x >>= \g -> liftM g y
12:11:23 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
12:11:23 <lambdabot>     In the first argument of `(>>=)', namely `x'
12:11:23 <paper_cc> copumpkin: I forgot :( (Boxed a) => Typeable a
12:11:46 <dmwit> :t \x y -> x >>= \g -> liftM g y
12:11:47 <lambdabot> forall (m :: * -> *) a1 b. (Monad m) => m (a1 -> b) -> m a1 -> m b
12:11:52 <PetRat> :t \x y -> x >>= \g -> liftM g y
12:11:53 <lambdabot> forall (m :: * -> *) a1 b. (Monad m) => m (a1 -> b) -> m a1 -> m b
12:12:27 <PetRat> So the types match, which in monad land pretty much guarantees the implementation is correct, no?
12:14:29 <frankks> > [2,3,4] \\ [4]
12:14:31 <lambdabot>   [2,3]
12:14:47 <frankks> > [4,3,2] \\ [4]
12:14:49 <lambdabot>   [3,2]
12:15:35 <Athas``> How widespread is Template Haskell in practice?
12:16:51 <sjanssen> Athas``: it's not used incredibly frequently, but is used in some projects
12:20:12 <paper_cc> copumpkin: so, is it impossible to use TypeReps as keys? (show for TypeRep seems inefficient)
12:21:24 <copumpkin> paper_cc: so you'd compare the types of the keys and then their values if their types were equal?
12:21:59 <paper_cc> copumpkin: yes, but there doesn't seem to be a stable key for TypeReps
12:23:17 <copumpkin> paper_cc: I don't see why you shouldn't be able to use it though
12:23:33 <copumpkin> the ordering of the keys is meaningless but should be enough for you to build a map
12:23:40 <copumpkin> you can probably unsafePerformIO it too
12:23:48 <copumpkin> that typeRepKey function, that is
12:24:40 <copumpkin> its implementation just returns a value into IO
12:24:47 <paper_cc> copumpkin: the docs say that it isn't guaranteed to be persistent across multiple program executions.
12:24:48 <paper_cc> oh
12:24:54 * paper_cc looks up
12:24:57 <copumpkin> well yeah, but neither is your Map
12:26:38 <paper_cc> copumpkin: my Map represents a persistent cache and is marshalled between program executions
12:26:49 <copumpkin> oh
12:28:43 <PetRat> Okay, next exercise is implement sequence in terms of >>= and return (and liftM). How about  seq' [] = return [] ;;; seq' (x:xs) = x >>= \y -> liftM (y:) (seq' xs) ???
12:29:34 <PetRat> Is copumkin and pumkin be the same person?
12:30:05 <jacobian> self dual?
12:30:07 <Zao> I'd say it's his dual :P
12:30:53 <copumpkin> yeah, I'm pumpkin's dual
12:31:00 <copumpkin> (-core macbook pro)
12:31:39 <jacobian> wow, that's a pretty complicated pun
12:32:10 <copumpkin> lol, that wasn't why I started using it
12:32:29 <copumpkin> it was poking fun at all the co- terms that get thrown around in this community :)
12:33:04 <Zao> I'd say it's cofun.
12:34:01 <PetRat> Can I use lambdabot to check my work in the above definition of sequence? how do I ask it for the type of a recursive function?
12:37:21 <PetRat> :t \g xs -> sequence $ map g xs
12:37:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
12:40:08 <copumpkin> has anyone made a SQL monad? basically a little DSL that is isomorphic to SQL?
12:40:41 <Beelsebob> I thought about making something like that
12:40:54 <Beelsebob> then got deep into "how can I make Haskell check my sql statements are type safe"
12:40:59 <Beelsebob> and got bored
12:41:31 <copumpkin> lol
12:43:38 <sjanssen> copumpkin: haskelldb has one, I think?
12:46:14 <copumpkin> I see
12:48:50 <koeien> this is like HaskellDB, but that has bitrotted
12:49:30 <Heffalump> copumpkin: SQL isn't really a monad
12:49:51 * Heffalump has done some work on a SQL DSL using associated type synonyms, but it's rather incomplete
12:51:08 <monadic_kid> Heffalump: query comphrensions is probably what you want to look at
12:52:20 <Heffalump> monadic_kid: as in the Wadler/SPJ paper?
12:56:02 <voker57__> can i see usage examples of Text.JSON or RJson somewhere?
12:56:11 <voker57__> like some app that uses on of those
12:56:55 <voker57__> in google people tend to write JSON parsers themselves
12:57:39 * edwardk has a json parser in javascript already, its called eval ;)
12:58:22 <voker57__> eh... is that #javascript?
12:58:32 <gwern> voker57__: well, you could download all of hackage, untar it all, and grep for the package names :)
12:59:13 <edwardk> voker57__: i tried talking in #javascript for a while, but they give me even more grief than the folks around here when I start talking about comonads.
12:59:26 <Raevel> :-D
12:59:30 <gwern> edwardk: they don'
12:59:36 <gwern> t even being to have the background
12:59:59 <gwern> so I don't really blame them. if someone came here chattering in lojban about epigram, we'd probably give them grief too
13:00:15 <edwardk> i've seen a couple of javascript "monadic" parser combinator libraries and monad implementations.
13:00:16 <Raevel> edwardk: maybe they'll listen after you rewrite their script so confirm stops no worky:ing
13:00:33 <edwardk> gwern: nah i think there are at least 4-5 people on here that understand lojban ;)
13:00:39 <Twey> .i zo'o mi se cinri la .epigram.
13:00:47 <gwern> surely there can't be that many?
13:00:52 <Twey> Think so
13:00:59 * Heffalump would still like to see a useful abstraction provided by comonads
13:00:59 <Twey> There's a fairly substantial overlap between the communities
13:01:04 <gwern> @seen
13:01:11 <gwern> @users
13:01:11 <edwardk> i've had several discussions on here about it with various folks
13:01:12 <lambdabot> Maximum users seen in #haskell: 658, currently: 644 (97.9%), active: 23 (3.6%)
13:01:32 <Twey> edwardk: eval() parses considerably more than JSON
13:01:36 <edwardk> Heffalump: i trip over cofree comonads all over the place.
13:01:38 <gwern> wait, if there are 23 active users, and 1 has claimed lojban knowledge, then I should infer that...
13:01:47 <gwern> > 658 * (1/23)
13:01:49 <lambdabot>   28.608695652173914
13:01:53 <Twey> That's a fair few people
13:01:58 <gwern> 28 lojban users? -_-
13:02:02 <edwardk> Twey: sure. and that was said slightly tongue in cheek. i understand the security reasons, etc. but its also hard to argue with parsing 50-100x faster ;)
13:02:08 <Twey> gwern: Point six!
13:02:09 <Raevel> more like 29!
13:02:35 <gwern> Twey: sure, we'll count the headless armless torso in the corner over there
13:02:45 <Twey> edwardk: Well, it is possible to do a check for valid JSON first, then apply eval() for the actual parsing
13:02:52 <Twey> Don't know how worthwhile that is, though
13:02:59 <Heffalump> edwardk: can you give an example of some generic code that is useful over such structures?
13:03:01 <Twey> gwern: *grin*
13:04:36 <edwardk> Heffalump: i have some comonadic cellular automata code around here somewhere, i use the cofree comonad for incremental folds, in particular i use it to annotate tree structures (applicatives) with sharing information in a reasonably safe manner
13:05:52 <edwardk> Heffalump: g_cata is defined for any comonad you can find distributive laws for, there are a bunch of those which give rise to destructive half of Control.Morphism.* in category-extras
13:06:26 <edwardk> i use those mostly as an aid for my thought patterns when i'm trying to figure out if a particular fold-like function can even exist
13:07:41 <TomMD> Are there rational trig functions in prelude somewhere?
13:08:03 <roconnor> rational trig functions?  Like spread?
13:08:07 <edwardk> another use i've had for them, which feeds back to the cofree comonad as fixed-point + incremental fold  is for dealing with attribute grammars
13:08:22 <TomMD> sin, cos, etc
13:08:36 <roconnor> are those called rational trig functions?
13:08:38 <edwardk> tomMD: like CORDIC versions of the traditional trig functions?
13:08:38 <roconnor> anyhow
13:08:45 <roconnor> > sin(pi/2)
13:08:46 <TomMD> Rational being 'Ratio Integer'
13:08:47 <lambdabot>   1.0
13:08:55 <TomMD> > sin (pi / 2) :: Rational
13:08:56 <lambdabot>       No instance for (Floating Rational)
13:08:56 <lambdabot>        arising from a use of `pi' a...
13:09:02 <TomMD> > sin (toRational pi / 2) :: Rational
13:09:03 <lambdabot>       No instance for (Floating Rational)
13:09:03 <lambdabot>        arising from a use of `sin' ...
13:09:06 <Heffalump> edwardk: I guess I'd have to see some code to understand properly, but thanks
13:09:09 <edwardk> tomMD: the problem is when do you stop. thats kind of the definition of Real vs. Rational ;)
13:09:20 <roconnor> TomMD: you cannot get more transcendtal that trig functions.
13:09:39 <edwardk> Heffalump: http://comonad.com/ my last post on incremental folds uses a cofree comonad, it just doesn't bother to call attention to it very much
13:09:48 <roconnor> The defining property of real numbers is practically that you can do sin and cos in them.
13:10:10 <joeally> What is the difference between LHC and GHC
13:10:13 <TomMD> Damn reals
13:10:17 <joeally> should I stick with GHC
13:10:25 <TomMD> joeally: GHC is usable as a full compiler - so yes
13:10:33 <joeally> okay
13:10:35 <roconnor> well, the result of sin and cos are real numbers,  You can easily pass them rational numbers.
13:10:36 <TomMD> joeally: LHC has became a backend to GHC.
13:10:40 <joeally> oh
13:10:43 <roconnor> > sin (fromRational (5/2))
13:10:44 <lambdabot>   0.5984721441039565
13:10:49 <joeally> TomMD:thanks
13:10:57 <TomMD> roconnor: Yes, I understand - I'll just have to do much conversion.  Thanks.
13:11:02 <Twey> What's LHC?
13:11:05 <Twey> First I've heard of that one
13:11:10 <Philippa> edwardk: what's the quick definition of 'cofree'? I'm not quite sure why, but I'm having trouble picturing it
13:11:16 <TomMD> Twey: LHC used to be a JHC fork
13:11:28 <roconnor> TomMD: please say that you only require rational inputs to these.
13:11:34 <TomMD> Twey: LHC is now being redefined as a GRIN optimizing backend for GHC.
13:11:45 <edwardk> Philippa: newtype Cofree f a = Cofree { runCofree :: (a, f (Cofree f a)) }
13:11:47 <roconnor> TomMD: what are you doing anyways?
13:11:48 <TomMD> roconnor: I only require rational inputs and outputs.
13:12:02 <Twey> Aha
13:12:04 <roconnor> TomMD: you aren't going to get rational outputs out of trig functions.
13:12:12 <Heffalump> edwardk: is any f a valid parameter there?
13:12:18 <TomMD> roconnor: Its for a GPS library.  Double will do, but I figured people who want more accuracy might use Rational and people who don't care can make a very simple conversion.
13:12:23 <inimino> Large Haskell Collider?
13:12:27 <roconnor> TomMD: certainly not for rational inputs.
13:12:28 <Lemmih> Twey: It's the Luxurious Haskell Compiler. A highly optimising backend for GHC.
13:12:34 <edwardk> Heffalump: unlike Codensity/Density you need f to be a Functor.
13:12:40 <TomMD> roconnor: Yes, I understand.
13:12:44 <roconnor> TomMD: people who want more accuracy use CReal :P
13:12:51 <roconnor> > cos (10^100) :: CReal
13:12:52 <lambdabot>   -0.9280819050746553434561946437769559281832
13:12:59 <roconnor> > cos (10^100) -- :(
13:13:00 <lambdabot>   -0.9994551172253643
13:13:11 <TomMD> roconnor: I keep hearing CReal, but I'm not clear on its properties.  Is it a 128bit float or some such?
13:13:11 <Heffalump> TomMD: I have some random bits and pieces of GPS code, btw. I'd be interested in seeing what you're doing.
13:13:13 <edwardk> since you have to fmap (fmap a) to drill into f (Cofree f a) -- for fmap purposes
13:13:20 <Philippa> edwardk: that's a cofree comonad rather than a cofree object in general, no?
13:13:27 <roconnor> TomMD: nope, it is infinite precision.
13:13:36 <TomMD> Heffalump: I proposed the basic API on haskell-proposals reddit a bit ago.
13:13:37 <edwardk> Philippa: as i understand the world, yes.
13:13:46 <Heffalump> TomMD: yeah, I saw that. Didn't get round to commenting.
13:13:51 <TomMD> Heffalump: I'll cabalize / upload to hackage /blog when I finish.
13:13:59 <roconnor> TomMD: there is an arbitrary precision floating point library out there too.
13:14:13 <Heffalump> most of what I have is code to talk to the two sources of GPS data I have
13:14:39 <TomMD> roconnor: I'll use CReal then - it sound like just the ticket (so long as people can convert to Fractional a as they desire)
13:14:48 <roconnor> TomMD: In theory you don't need real numbers to do geometry
13:14:58 <TomMD> Heffalump: I'm doing GPS computations (heading, distance, vectors)
13:15:04 <roconnor> TomMD: be aware that CReals is potentially slow
13:15:08 <Heffalump> TomMD: what's the point in using more precision that the data you'll be working with?
13:15:09 <TomMD> speed... trail smoothing (to eliminate invalid points)
13:15:12 <Heffalump> just use Double and be done with it..
13:15:31 <TomMD> Heffalump: It all depends the precision of what people work with I suppose.
13:15:43 <Philippa> edwardk: I meant cofreeness in general - I think I've got a grasp on what it is to be 'free', though I wouldn't want to put it into words while I'm feeling dopey
13:15:50 <roconnor> CReals could be 1000x slower that Double.  Maybe more?
13:15:58 <Philippa> at least, not if there's any penalty for inaccuracy :-)
13:16:00 <TomMD> But rational was overkill, I admit.  Without an Earth model that uses height, I probably don't need double.
13:16:01 <Heffalump> I haven't worked it out, but I'd expect Double to be several orders of magnitude more precise than GPS.
13:16:19 <edwardk> Philippa: i.e. as in 'left adjoint to a forgetful functor'?
13:16:32 <TomMD> Heffalump: Its more just becuase I figured this could get used by systems that have rationals in other sections, so I'd just remain consistent with what I thought was the best type.
13:16:43 <Philippa> edwardk: I tend to think of it as "all syntax, no semantics", but yes
13:17:08 <Heffalump> I'd say Double is the best type. Rational is pretty inefficient too.
13:17:34 <Heffalump> unless you think there's a significant likelihood of FP roundoff problems
13:17:34 <TomMD> Its an easy change - mostly I'll just change my type X = Rational to type X = Double in a couple spots.
13:17:58 <TomMD> Heffalump: One FP round off problem is more than too much.
13:18:09 <TomMD> @google patriot missle failure
13:18:11 <lambdabot> http://www.ima.umn.edu/~arnold/disasters/patriot.html
13:18:11 <lambdabot> Title: The Patriot Missile Failure
13:18:41 <Heffalump> overloading the entire library on the type might also be feasible
13:18:55 <Heffalump> looking at your proposal, why is Coordinate a type class but Vector not?
13:19:13 <TomMD> I'm wary of too many typeclasses, but I will consider it.
13:19:46 <roconnor> TomMD: FP round off is usually only a problem when accumulating values, which you may or may not be doing here.
13:20:14 <Heffalump> there's rarely a reason to accumulate values with a GPS, because you get brought back to reality by the next point
13:20:22 <roconnor> TomMD: the sort of it is that, CReal is slow exactly when FP round off is problematic.
13:20:39 <Heffalump> I tend to agree about overloading on that being too many typeclasses.
13:21:15 <TomMD> I'm going to switch it to Double for now but give it more thought before uploading / doing anything complex.
13:22:16 <h0tzenpl0tz> does anyone know the exact scrabble-rules? i wonder if i may complete multiple side-by-side words like  " foo bar " with "XXfooXbarXXXXX". would this be an allowed move?
13:22:58 <Beelsebob> h0tzenpl0tz: all letters must be placed in a single line
13:23:05 <Beelsebob> and make up one word along that line
13:23:12 <roconnor> h0tzenpl0tz: what are the X's?
13:23:14 <Beelsebob> they may also make other words intersecting with it
13:23:24 <Beelsebob> but no more than one word on that line
13:23:26 <h0tzenpl0tz> the x is a tile from my rack
13:23:44 <Philippa> if you can find a word in the dictionary that fits that pattern, yes
13:23:52 <Beelsebob> h0tzenpl0tz: yes, that's an allowed move then, if foo bar were already on the board
13:24:10 <Twey> h0tzenpl0tz: You can only place a word side-by-side if each letter makes a word horizontally
13:24:17 <Philippa> talking of which, is fubar an allowable word under current rules?
13:24:35 <Beelsebob> Philippa: depends what country you're playing in
13:24:45 <Twey> E.G. you can't have foo\nbar because ‘fb’, and ‘oa’ aren't words
13:24:55 <roconnor> Rumour has it that the top Scrabble player is a Chinese man who doesn't speak English.
13:25:02 <Twey> Beelsebob: There's an international English Scrabble dictionary
13:25:02 <Philippa> Beelsebob: different rules, or different dictionary of choice?
13:25:12 <Twey> Which is generally held to be the standard
13:25:26 <Beelsebob> Twey: yeh, but that doesn't stop people playing by different dictionaries in different countries
13:25:54 <h0tzenpl0tz> thank you all
13:26:08 <Philippa> Beelsebob: including, of course, the cat dictionary
13:26:14 <h0tzenpl0tz> thats pretty disgusting to implement :(
13:26:18 <h0tzenpl0tz> over & out
13:26:22 <Beelsebob> h0tzenpl0tz: not at all
13:26:25 <Beelsebob> that's easy to implement
13:26:34 <h0tzenpl0tz> i wouldnt know how
13:26:53 <Beelsebob> 3 conditions must hold... all letters must be in a line; all letters must form a complete word along that line; and all combinations they form must be words
13:26:59 <Philippa> Beelsebob: I think h0tzenpl0tz means for an AI player? It's easy to validate the move...
13:27:00 <Beelsebob> each of those is easy to implement
13:27:14 <Beelsebob> Philippa: oh, yeh, for AI it may be harder
13:27:21 <h0tzenpl0tz> indeed ;)
13:27:30 <h0tzenpl0tz> thanks nevertheless
13:27:33 * Beelsebob would suspect for a scrabble AI you might need to have an algorithm for spotting places to play
13:27:37 <Beelsebob> before coming up with words
13:27:49 <sinelaw> @djinn a->a->a
13:27:49 <Beelsebob> i.e. a heuristic search of places it wants letters to land
13:27:50 <lambdabot> f _ a = a
13:28:14 <h0tzenpl0tz> yeah that works but it doesnt connect multiple side-by-side words :(
13:28:17 <h0tzenpl0tz> tryin harder...
13:28:24 <Beelsebob> hehe, fun
13:28:49 <Philippa> h0tzenpl0tz: look for all 1-letter, 2-letter etc plays. Squares first, then the dictionary bash
13:29:21 <Philippa> the point being to calculate the connections made with each play so you've got your validation burdens
13:29:58 <Beelsebob> Philippa: I would expect you can significantly narrow down your options by doing things like "I have a z, I want it on the tripple letter, this means I can grep the dictionary for z..a.h" etc
13:30:36 <h0tzenpl0tz> build a dictionary before that allows these patterns efficiently :)
13:30:40 <Philippa> Beelsebob: *nod*. But I leave that to people who're good at AI, you can rearrange the problem at will once you know what it looks like :-)
13:31:21 <Beelsebob> true
13:41:30 <Philonous> Is there a way to kill external processes once the programm invoking them gets shut down?
13:43:24 <vininim_> gosh, importing parsec qualified is not a good idea if you want to use the operators
13:43:36 <PeakerWork> Philonous: I think normally processes get a SIGHUP in Unix when their parent process dies
13:43:52 <PeakerWork> Philonous: You can also keep a pipe between the parent and the children, and the children can die when they hit EOF on that pipe
13:44:25 <Tobsan> PeakerWork: you can also do runCommand with some kind of pkill if you want to do it the ugly way
13:44:27 <Philonous> I was incoking from inside a haskell thread and it kept running when I killed the haskell process
13:44:31 <Philonous> invoking*
13:44:52 <marcot> vininim_: qualified operators are not very nice.
13:47:20 <PeakerWork> vininim_: Use: import Blah((*), (|||), ...)
13:47:34 <PeakerWork> Its nicer than having to guess where operators come from
13:47:43 <PeakerWork> (not qualified operators, but explicitly named operators)
13:47:54 <aempirei> lol
13:49:43 <vininim_> marcot: hello \o
13:49:51 <camio> How did the new #haskell-in-depth come about?
13:51:41 <Heffalump> camio: reduce traffic volume on here
13:53:51 <camio> Juding from the traffic there, it doesn't seem like it took of a significant chunk of traffic away so far.
13:54:09 <camio> s/ of//
13:56:26 <camio> Maybe the confusion of having two channels would induce someone to just leave. That could reduce traffic :)
13:56:49 <Heffalump> it does allow slower paced discussions on there, too
13:56:55 <Heffalump> I think it's worked fairly well
13:57:15 <marcot> vininim_: /j #haskell.pt
13:57:44 <camio> cool
14:06:55 <lament> what's a pretty way to find, in a sorted list of numbers, the greatest number (if it exists) s.t. the list contains 6 numbers in a row including that one?
14:07:23 <Heffalump> 6 numbers the same>
14:07:24 <Heffalump> ?
14:07:34 <Philippa> in sequence
14:07:39 <lament> no, in a row, like 4,5,6,7,8,9
14:07:43 <mxc> well, already sorted
14:07:46 <Philippa> eg 1234567 would yield 7
14:07:48 <lament> yes
14:07:49 <Heffalump> oh, right
14:07:51 <mxc> so like 1,2,2,2,2,2,4,5 would return 2?
14:07:52 <solrize_> groupBy
14:07:54 <solrize_> :t groupBy
14:07:55 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:08:06 <lament> mxc: sorted, no duplicates
14:08:31 <mm_freak> lament: how about taking the last element?  or the first
14:08:35 <mm_freak> if the list is sorted
14:08:37 <Heffalump> I'd calculate successive differences, then map (take 6) . tails
14:08:37 <lament> > group by (\x y -> y = x + 1) [1,2,3,4,5,6,7,9,10]
14:08:38 <lambdabot>   <no location info>: parse error on input `='
14:08:42 <lament> > group by (\x y -> y == x + 1) [1,2,3,4,5,6,7,9,10]
14:08:44 <lambdabot>   Not in scope: `by'
14:08:47 <lament> > groupBy (\x y -> y == x + 1) [1,2,3,4,5,6,7,9,10]
14:08:49 <lambdabot>   [[1,2],[3,4],[5,6],[7],[9,10]]
14:08:54 <Heffalump> then filter by all (==1)
14:09:02 <mm_freak> > last . sort $ [3,5,1,7,4,4]
14:09:03 <lambdabot>   7
14:09:07 <Philippa> lament: accumulate "consecutive numbers" and "biggest number where consecutive >= 6"?
14:09:24 <Heffalump> that finds you the sequences but doesn't tell you what they actually were, so zip with the original numbers at some point before the filter
14:09:29 <Philippa> (which also means accumulating last number)
14:09:30 <Heffalump> and then just take the last
14:09:44 <camio> lament: What do those numbers represent? Why are they in sorted order in the first place?
14:09:44 <solrize_> > groupBy (==) $ zipWith (-) [1,4,5,7,8,9,10,11,12,13,15,30] [1..]
14:09:45 <lambdabot>   [[0],[2,2],[3,3,3,3,3,3,3],[4],[18]]
14:09:46 <Philippa> admittedly that's a really imperative way of doing it :-)
14:10:18 <lament> solrize_: oo
14:10:18 <solrize_> > last $ filter ((>=6) . length) $ groupBy (==) $ zipWith (-) [1,4,5,7,8,9,10,11,12,13,15,30] [1..]
14:10:19 <lambdabot>   [3,3,3,3,3,3,3]
14:10:25 <mm_freak> i don't get it, what's the difficulty of extracting the largest element of an already-sorted list?
14:10:47 <lament> mm_freak: given [1,2,3,4,5,6,8] the functions should return 6.
14:10:55 <lament> *function
14:11:05 <Heffalump> mm_freak: the last element with a particular property
14:11:10 <lament> (or rather Just 6 since there may not be an answer)
14:11:11 <Heffalump> identifying the property is the tricky bit
14:11:15 <mm_freak> in what sense is 6 larger than 8?
14:11:24 <lament> in none.
14:11:29 <Heffalump> mm_freak: 8 isn't part of a sequence
14:11:38 <Philippa> last . last . filter (longEnough) . groupBy (isOneGreaterThan) ?
14:11:39 <mm_freak> ah, ok, in sequence
14:11:44 <Philippa> with the predicates filled in?
14:12:15 <solrize_> > last $ filter ((>=6) . length) $ groupBy \(a,b) -> (a-b == 1) $ zip (-) [1,4,5,7,8,9,10,11,12,13,15,30] [1..]
14:12:16 <lambdabot>   <no location info>: parse error on input `\'
14:12:37 <solrize_> > last $ filter ((>=6) . length) $ groupBy (\(a,b) -> a-b == 1) $ zip (-) [1,4,5,7,8,9,10,11,12,13,15,30] [1..]
14:12:38 <lambdabot>   Couldn't match expected type `(t, t) -> Bool'
14:12:49 <solrize_> > last $ filter ((>=6) . length) $ groupBy (\(a,b) -> (a-b == 1)) $ zip (-) [1,4,5,7,8,9,10,11,12,13,15,30] [1..]
14:12:50 <lambdabot>   Couldn't match expected type `(t, t) -> Bool'
14:12:57 <solrize_> hmm.  well you get the idea
14:14:25 <lament> groupBy takes two arguments
14:15:12 <lament> > groupBy (\(a,b) (c,d) -> (a-b == c-d)) $ zip (-) [1,2,3,4,5,6,7,9] [1..]
14:15:13 <lambdabot>   Couldn't match expected type `[a]'
14:15:42 <lament> (i meant the predicate to groupBy)
14:16:40 <mm_freak> lament: at which point do you consider numbers "in sequence"?  at least two consequtive numbers?
14:17:03 <mm_freak> s/q/c/
14:17:23 <lament> yes
14:17:41 <lament> so the largest number in a sequence of at least 6 consecutive numbers
14:17:51 <mm_freak> at least 6, ok
14:18:59 <Heffalump> TomMD: my GPS stuff is here if you are interested: http://urchin.earth.li/darcs/ganesh/gps/
14:19:21 <mm_freak> groupBy would work nicely if it compared with the preceding element, not with the first element of a group
14:19:25 <mm_freak> that's very annoying
14:19:39 <mm_freak> > groupBy (\x y -> y == x+1) [1,2,3,5,6,7,8,9,11,13,14,15]
14:19:40 <lambdabot>   [[1,2],[3],[5,6],[7,8],[9],[11],[13,14],[15]]
14:20:01 <mm_freak> i'd write an own version of groupBy and use it
14:20:35 <mm_freak> then just apply: maximum . map last . filter ((>6) . length)
14:21:08 <centrinia> Uh, why isn't [5,6,7,8,9] in a group?
14:21:31 <mm_freak> centrinia: because groupBy compares each element with 5, not with the preceding element
14:21:41 <mm_freak> i.e. with the first group member
14:22:33 <mm_freak> uhm yeah, and replace >6 by >=6 =)
14:33:01 <lament> > (fst . last . last) $ filter ((>=6) . length) $ groupBy (\(a,b) (c,d) -> a-b == c-d) $ zip [1,2,3,4,5,6,7,9,11,12,13,14,15,16,20] [1..]
14:33:03 <lambdabot>   16
14:33:09 <lament> this works. But i did ask for a pretty way :)
14:33:13 <TomMD> Is there a package with a Binary instance for Double that people have agreed on?
14:37:06 <dons> Data.Binary comes with instances for Double
14:37:11 <dons> just not ieee ones, haskell ones.
14:40:45 <byorgey> http://haskell.org/haskellwiki/Hac_%CF%86
14:41:08 <byorgey> Hackathon in Philadelphia!  sign up now, limited space! ;)
14:41:34 <skorpan> someone please tell me what is HP?  haskell platform?
14:41:38 <skorpan> or haskell prime?
14:41:49 <Lemmih> Hit points?
14:41:51 <c_wraith> possibly Harry Potter.  kids these days...
14:41:57 <skorpan> ...
14:42:14 <Vq^> HP Sauce?
14:42:14 <eivuokko> skorpan, I am afraid the quality of answers is dependent on additional context you can give.
14:42:22 <byorgey> skorpan: probably Haskell Platform.  Haskell prime is usually abbreviated Haskell' .
14:42:42 <skorpan> eivuokko: the context is the mailing list.
14:42:58 <Philonous> Hewlett Packard?
14:43:19 <skorpan> okay, so let's assume it's the haskell platform.  what *is* the haskell platform?  new hackage?  new cabal?
14:43:35 <eivuokko> Standard set of tools.
14:43:43 <Vq^> Horsepower?
14:43:49 <Zao> http://www.haskell.org/haskellwiki/Haskell_Platform <- that'a'thing
14:43:49 <dons> go upenn http://www.haskell.org/haskellwiki/Hac_φ
14:43:55 <skorpan> kind of haskell stdlib?
14:44:06 <dons> skorpan: kinda a haskell extended stdlib
14:44:10 <dons> like super extended
14:44:34 <Zao> dons: I've heard that escaping URLs helps with communicating.
14:44:38 <roconnor> ``The platform prevents you from picking and choosing the best Haskell libraries and tools to use for a task.
14:44:40 <xs> why is a rose tree called a rose tree, and who named it thus?
14:44:46 <Zao> Unless you intended to link to "Hac Æ"
14:44:48 <skorpan> so this is supposed to replace the thousands of haskell libraries in arch's repos?
14:44:54 <dons> roconnor: i don't think that's a quote
14:45:06 <dons> skorpan: no.
14:45:30 <roconnor> close enough
14:45:31 <gwern> skorpan: the platform is just an organizational idea
14:45:51 <Zao> http://www.haskell.org/haskellwiki/Hac_%CF%86 <- clever use of phi though :)
14:45:52 <gwern> to use a WP metaphor: the platform is a category; all the articles remain as before
14:45:55 <dons> roconnor: why?
14:46:12 <skorpan> gwern: that's a metaphor i can understand
14:46:20 <dons> if you want  to pick and choose, install the platform, then fire up cabal-install
14:46:23 <skorpan> and hackage is a supercategory of haskell platform?
14:46:24 <Philonous> Is there a package for command line options parsing?
14:46:29 * gwern is obscurely pleased
14:46:34 <gwern> skorpan: hackage is Special:Allpages
14:46:41 <skorpan> yeah, cool :)
14:46:44 <gwern> (because if it's not on hackage it doesn't exist!)
14:47:03 <dons> Philonous: in the base library
14:47:11 <roconnor> dons: exactly. so why platform.
14:47:20 <Philonous> thanks dons
14:47:41 <skorpan> will there always be exactly one version of each package in HP?
14:47:42 <roconnor> ... actually the platform makes sense given that cabal cannot properly track version interfaces.
14:48:07 <roconnor> I'd rather see cabal fixed, but I suppose that is a much more difficult task.
14:48:57 <dons> roconnor: for people who don't use cabal-install
14:49:01 <skorpan> on a completely unrelated topic: when will darcs cease to be the norm for haskell projects?
14:49:16 <dons> and who don't want the latest version of everything
14:49:19 <gwern> skorpan: hopefully never
14:49:23 <dons> skorpan: 2020?
14:49:24 <skorpan> dons: the yi project ;P
14:49:30 <dons> git has a small inroad, but that's it
14:49:39 <Zao> dons: People who want to use previous versions due to source incompatibilities?
14:49:40 <skorpan> dons: but that's only because new versions tend to break other packages
14:49:58 * Zao shakes a fist at people who make breaking changes in subminor version bumps.
14:50:02 <roconnor> and new versions only break packages because cabal doesn't track version interfaces properly.
14:50:05 <Zao> Yes vector-space, I'm looking at you.
14:50:13 <dons> no, a lot of users who don't hang out on #haskell don't want every minor version, or to choose the cutting edge of everything
14:50:14 <roconnor> well, I guess not "only", but largely
14:50:16 <dons> i.e. industrial users
14:50:27 <PeakerWork> git is pretty cool -- if someone wrote a sane UI around it, and added some more meta-data to rebases, it would have all of darcs' advantages, and I think even without it its already preferable
14:50:30 <dons> who just want a stable set that builds stable things for years, without having to do research
14:50:34 <dons> these people generally don't hang out here.
14:50:38 <dons> so you need both
14:50:48 <dons> a cutting edge set for developers (hackage), and a stable base for everyone else
14:51:11 <gwern> PeakerWork: I am moderately sure that git doesn't have all of darcs's patch manipulation stuff
14:51:12 <roconnor> dons: you could be right, but I'm still skeptical.
14:51:31 <dons> that's fine. there's already been 1000s of downloads :)
14:51:39 <roconnor> yep
14:51:40 <roconnor> :)
14:51:40 <gwern> (release early, release often!)
14:51:54 <roconnor> entrenching the mtl for life :P
14:52:08 <dons> the other thing is to ensure that the platform is on every system
14:52:08 <PeakerWork> gwern: I think it can relatively easy have them in the form of rebases, except rebases currently lack meta-data
14:52:15 <dons> so you can't get away with say, ubuntu being 2 years out of date
14:52:24 <dons> unless we /tell/ distros whta to package, they make arbitrary choices
14:52:35 <skorpan> good thing arch exists
14:53:08 <roconnor> dons: hmm, I find that distros argument is more compelling.
14:53:20 <gwern> yes, that's a good point about the HP. now we can complain that they've only got x% of the HP
14:53:27 <Philonous> dons: Do you know which Module contains the options parsing?
14:54:18 <dons> System.Console.GetOpt
14:54:21 <PeakerWork> gwern: git lets you do any kind of cherry picking of patches that darcs does - except you can retroactively choose different diff strategies for patch generation, when doing the cherry picks, which is more powerful than what darcs can - as darcs commits to a specific way of diffing in the whole repo
14:54:23 <Philonous> Thanks
14:54:31 <skorpan> Philonous: or try parseargs
14:55:06 <skorpan> is there any generalized version of (\\)?  i wrote my own one, bug included
14:55:26 <gwern> PeakerWork: I'm not too up on DVCSs, but I've been assured by the other darcs dev that darcs can commute patches in ways git won't/can't
14:55:35 <gwern> although I'm glad git can at least cherry pick changes...
14:55:47 <skorpan> gwern++
14:55:58 <skorpan> that's one of the big things i miss in hg
14:56:59 <PeakerWork> gwern, skorpan: git lets you re-diff any previous revisions in history, and apply it on any other revision in history, which I think takes care of any kind of commuting you may want to do, except unlike darcs, you can do this using any diff algorithm you want, and not one pre-determined before ever setting up the repo
14:56:59 <Gracenotes> skorpan: not many structures abstract over list modification
14:57:13 <Gracenotes> not in the common libraries anyway
14:57:15 <Nafai> I like that you can re-order commits in git
14:57:41 <PeakerWork> skorpan: I think hg does not yet have git's rebase, and even git's rebase is lacking in metadata - which could really make rebase seamless even when collaborating on the rebased branches
14:57:58 <solidsnack> There seems to be something off about readline/editline in the GHC 6.10.3, at least on Macintosh.
14:58:15 <Nafai> PeakerWork: What kind of metadata would be useful?
14:58:18 <skorpan> PeakerWork: but e.g. tortoisehg (a gui for hg) can actually display "hunks" of changes which leads me to believe it should really be super simple to implement
14:58:24 <PeakerWork> gwern, skorpan: Like all revision-based DVCS, git places an arbitrary order between independent commits, but that order can be ignored when forming new revisions to use
14:58:45 <solidsnack> `fn+shift+right` -- which used to get me `end` -- is now resulting in a capital F!
14:59:40 <PeakerWork> Nafai: A rebase (or amend commits, etc) creates commits containing similar patches to other commits. It could be nice if these commits had metadata pointers to those older commits, and when someone pulls from a rebased branch, the metadata would tell the puller: "Your commits' patches are already in this new rebased revision, so you can rebase too and continue where he has"
15:00:13 <PeakerWork> Nafai: They could allow to pull from rebased branches
15:00:43 <PeakerWork> Nafai: as well as keep the old rebased stuff alive for future reference, rather than floating around until its GC'd when its no longer in the git reflog
15:00:50 <Lemmih> PeakerWork: Isn't this still an issue: http://projects.haskell.org/camp/unique
15:01:08 <jeffwheelerPhone> @pl \x y -> x : [y]
15:01:08 <lambdabot> (. return) . (:)
15:01:11 <PeakerWork> Lemmih: I don't have speakers here -- what is the issue being described?
15:01:53 <PeakerWork> @unpl (. return) . (:)
15:01:54 <lambdabot> (\ d g -> ((:)) d (return g))
15:01:57 <PeakerWork> @unpl (:) . (. return)
15:01:58 <lambdabot> (\ d -> ((:)) (\ g -> d (return g)))
15:02:32 <PeakerWork> @unpl could use some sugaring
15:02:32 <lambdabot> could use some sugaring
15:02:55 <Lemmih> PeakerWork: It talks about how darcs tracks dependencies on the patch level and what that allows you to do.
15:04:08 <PeakerWork> Lemmih: iiuc, the same can be done in git, where each commit represents a patch -- its metadata can contain anything, including actual patch dependencies on other commits. When you rebase, you can keep a pointer from the newly generated commit to the old one to retain all of this metadata (or just copy it)
15:04:14 <Nafai> PeakerWork: Ah, good idea.
15:04:41 <roconnor> Hmm, I don't suppose we could have hac φin July in Beijing instead. :)
15:05:15 <PeakerWork> Lemmih: I think the darcs features are a nice idea - but I think the right way to implement these darcs features is on top of a git backend
15:05:38 <roconnor> is it a good idea to have hac φ during the ICFP contest?
15:05:52 <roconnor> oh wait
15:05:53 <PeakerWork> A revision-based backend is more powerful than a patch-based backend, as long as your patches aren't perfect (and textual diffs are far from perfect)
15:05:57 <roconnor> the contest is in June, not July
15:05:59 <roconnor> \o/
15:06:15 <roconnor> I thought I was going to miss it again.
15:10:43 <inimino> PeakerWork: how is it more powerful if they are equivalent?
15:11:03 <byorgey> roconnor: yeah, we took the ICFP contest into account =)
15:11:24 <byorgey> roconnor: you're going to be in Beijing?
15:12:00 <deech> Hi all, is there a function in that determines if a string is contained in another string? Or more generally if list x is a sublist of list y?
15:12:15 <PeakerWork> inimino: Its not strictly more powerful, if you're willing to do a full repository conversion -- but if you're not, then the committing to imperfect patches in darcs means you may not switch patch strategies whereas in git, you can choose whatever way to diff between repos that you wish, on a case-by-case basis
15:12:19 <Botje> deech: isInfixOf
15:12:48 <deech> Botje: Awesome thanks!
15:12:50 <PeakerWork> inimino: arg, its very late and I'm confusing words, sorry.  s/repos/revisions
15:14:25 <inimino> PeakerWork: ok.  I actually use git and haven't looked into darcs
15:15:31 <PeakerWork> inimino: If you think of git revisions as representing patches, and not whole trees, you can mix&commute those patches pretty easily, and you get most of the features darcs advertises. But them being whole trees in the backend lets you decide much later what kind of diffing to use
15:15:53 <PeakerWork> s/being whole trees in the backend/representing whole trees in the backend
15:16:00 <inimino> makes sense
15:16:27 <inimino> I wasn't aware darcs actually had different patch formats
15:16:58 * inimino should probably read about it sometime
15:18:29 <mm_freak> lament: as said, pretty would be to write your own groupBy variant, which always compares with the predecessor instead of the first group element
15:18:38 <mm_freak> that would give a very nice, concise solution
15:23:36 <lament> hm
15:35:22 <PeakerWork> Not (Not a) -> a        should be provable right?  How do you create a value of type    ((a -> Void) -> Void) -> a ?
15:35:23 <Philonous> Is there a way to control the RTS without the + and -RTS options? Those might be a little awkward to non-haskell users
15:36:22 <lament> why would a non-haskell user be profiling?
15:36:54 <Philonous> They wouldn't, but they might want to instruct the RTS to use N system threads
15:37:27 <mauke> @djinn Not (Not a) -> a
15:37:28 <lambdabot> -- f cannot be realized.
15:37:57 <solidsnack> Philonous: That's actually a really good point.
15:38:02 <mauke> if all else fails, write a wrapper
15:40:39 <eivuokko> It probably doesn't help, but you an also control RTC options via environment variable.
15:40:52 <Baughn> @ask conal Let me confirm something. reactive is supposed to be deterministic, right? Specifically, if I create a behaviour from some source of events (stepper), and then snapshot it against the same event stream, I ought to get a 1:1 correspondence between behavior steps and snapshot output?
15:40:53 <lambdabot> Consider it noted.
15:41:15 <conal> Baughn: hi
15:41:15 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
15:41:30 <c_wraith> lambdabot, you may be suboptimal in this case.
15:41:42 <Baughn> conal: Huh. I could swear I tried tab-completing..
15:42:24 <conal> Baughn: yes, deterministic.  No about the snapshot.  the semantics of stepper/switcher is that the behavior changes immediately *after* the event occurrence.
15:42:26 <eivuokko> Philonous, Oh, and also if you want to write some C, you can do it via some hooks or whatever it was called.  Described in user's guide.
15:42:28 <Baughn> conal: Or more generally - should it be just plain deterministic, providing same output given same input every time?
15:42:35 <conal> Baughn: which allows recursively defined behaviors.
15:42:55 <conal> Baughn: have you seen the semantic model for behaviors?
15:42:59 <Baughn> conal: Ah. That explains my output a little bit, but the determinism is suffering in that conversion. Well, I'll get on it.
15:43:19 <PetRat> Can I use lambdabot to check the type of a recursive function? what would be the syntax?
15:43:27 <Baughn> conal: I've read it. Probably not well enough, still; by the time I'm done with exams I will have.
15:43:39 <conal> Baughn: by the "semantic model", i mean the type of *meanings* of behaviors.
15:43:57 <Baughn> :t let f x = 1 : x : f (fubar x)
15:43:58 <lambdabot> <no location info>:
15:43:59 <lambdabot>     not an expression: `let f x = 1 : x : f (fubar x)'
15:44:06 <Baughn> :t let f x = 1 : x : f (fubar x) in f
15:44:07 <lambdabot> Not in scope: `fubar'
15:44:17 <Baughn> :t let f fubar x = 1 : x : f (fubar x) in f
15:44:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
15:44:19 <lambdabot>     Probable cause: `f' is applied to too few arguments
15:44:19 <lambdabot>     In the second argument of `(:)', namely `f (fubar x)'
15:44:31 <Baughn> PetRat: ..impossible functions aside, thataway.
15:44:41 <Philonous> eivuokko: That's both suboptimal, but I will manage. Thanks
15:44:57 <conal> Baughn: in general you can learn essence of a data type or language simply by looking at the type of meanings ("denotations").
15:44:58 <Tigran> PeakerWork: Not sure if this is what you were referring to, but `not (not a) -> a' can not be proved under intuitionistic logic
15:45:16 <conal> Baughn: since the model of Behavior a is Time -> a, it has to be deterministic.
15:45:24 <Baughn> conal: Right. By the way, do you think anyone would be terribly upset if I submitted a patch replacing TimeT with a fixed-point implementation?
15:45:25 <conal> (it == semantics)
15:45:36 <Tigran> PeakerWork: `a -> not (not a)' can, however
15:45:44 <Baughn> conal: I have this vision of long-running programs going insane. But maybe you've thought of that one.
15:45:59 <c_wraith> @check \a -> a == not $ not a
15:46:00 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
15:46:16 <c_wraith> @check \a -> (a == not $ not a)
15:46:17 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
15:46:26 <c_wraith> ok, my brain isn't in haskell mode today
15:46:27 <mauke> @djinn a -> Not (Not a)
15:46:28 <lambdabot> f a b = b a
15:46:34 <conal> Baughn: i don't know what's best to represent times.  hardly any operation really cares about the nature of time, other than that it's ordered.
15:46:46 <PeakerWork> Tigran: That's disappointing. Is intuitionistic logic less powerful than classical logic?
15:47:06 <copumpki> and lengths of time?
15:47:38 <mreh> when pattern matching on records, can I be selective about which fields I match?
15:47:56 <mauke> yes
15:48:06 <Tigran> PeakerWork: It omits the axiom of choice, so I suppose `less powerful' is about right
15:48:10 <mreh> cool
15:48:12 <mauke> you can even match none of them
15:48:19 <mreh> COOL
15:48:26 <mreh> why would you bother?
15:48:28 <mauke> Foo{}  -- even works for non-record constructors
15:48:50 <mreh> haha
15:48:58 <Tigran> You don't lose the classical truths entirely
15:49:04 <mauke> > (\x -> case x of Nothing{} -> "nothing"; Just{} -> "just _") (Just 42)
15:49:05 <lambdabot>   "just _"
15:49:18 <Tigran> Intuitionistic simply doesn't contradict classical logic
15:49:34 <Baughn> conal: Well, I suppose.. given double, with a 52-bit mantissa, you get microsecond precision for.. hm, 136 years
15:49:41 <Baughn> ..probably sufficient.
15:50:09 <mreh> that's what they said in 60s about the millenium
15:50:46 <chessguy> i'm totally going to Hac-φ :)
15:51:01 <conal> Baughn: how about submitting a trac item?
15:51:21 <Baughn> conal: Pretty sure someone already did. I tried fixpointing it just to see if that mattered at all.. it didn't.
15:51:41 <conal> Baughn: oh, okay.
15:51:48 <persica> mreh: And 640k should be enough for anyone.
15:51:53 <Baughn> Not for a short-lived program, at least. ;)
15:52:00 <roconnor> byorgey: I'm heading to Shanghi for the solar eclipse, then off to Beijing for a vist.
15:52:24 <PetRat> :t either
15:52:25 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:52:41 <conal> Baughn: i'm not attached to the current default time type.
15:52:44 <Baughn> conal: Oh, and.. is the /current/ implementation of mkUpdater "supposed to do almost no work during known-constant phases", or is that yet to come? It pegs my cpu while blocked on stdin, you see.
15:53:16 <conal> Baughn: supposed (by me) to do so now.
15:53:33 <conal> Baughn: any idea what it's up to?
15:53:56 <conal> i suck at performance analysis / debugging
15:55:13 <mreh> persica: My favourtie quote from IBM, "The world will probably need five computers"
15:55:50 <lament> roconnor: when are you in beijing?
15:55:53 <FunctorSalad> everything that can be invented has been invented (around 1900?)
15:55:55 <Baughn> conal: Not yet, really. I've had higher priority on debugging the actual /bugs/ - besides, it might go away by then.
15:56:09 <c_wraith> mreh: Who says that it *need* more than that?  The rest are just kind of handy.
15:56:16 <c_wraith> blah.  *needs
15:56:28 <roconnor> lament: something like July 23 to July 26
15:56:32 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5106#a5106 <-- Have a testcase anyway.
15:56:48 <roconnor> lament: but I don't think I'd travel to the US for a hackathon anyways.
15:56:52 <mreh> and yet if we took them all away today, we wouldn't be able to cope
15:56:57 <roconnor> lament: the US is unwelcoming to visitors
15:56:57 <PetRat> http://www.mibbit.com/pb/Zx58ym I'm trying to use ErrorT following someone else's example, but my code isn't working. I want to write a function with type IO String, but the inferred type is IO (). Can someone explain?
15:57:13 <lament> roconnor: cool, i'll be in beijing too
15:57:15 <Baughn> conal: Funny thing - ghc is doing non-blocking (timeout=0) selects on stdin in there
15:57:27 <roconnor> lament: :O really, why?
15:57:37 <lament> roconnor: Go class :)
15:57:41 <mauke> PetRat: putStrLn returns ()
15:57:46 <conal> Baughn: how do you know?
15:57:53 <Baughn> conal: strace
15:57:55 <roconnor> lament: how long are you there?
15:57:56 <mreh> lament: the game go?
15:57:59 <conal> Baughn: what's that?
15:58:04 <lament> mreh: yeah
15:58:09 <lament> roconnor: july and august
15:58:15 <mauke> http://en.wikipedia.org/wiki/Strace
15:58:15 <nominolo> @users
15:58:16 <lambdabot> Maximum users seen in #haskell: 658, currently: 602 (91.5%), active: 26 (4.3%)
15:58:24 <Baughn> conal: ..you're on windows, I guess?
15:58:32 <PetRat> mauke: oh, each branch of the either must be the same, I guess.
15:58:33 <roconnor> lament: you should go to Shanghi for July 22.
15:58:46 <lament> roconnor: I know
15:58:52 <conal> Baughn: no.  on linux.  switched a few months ago.
15:58:54 <Baughn> conal: Hum. It's only with the non-threaded runtime, which makes sense.
15:58:56 <lament> roconnor: I was thinking... It's Shanghai - it's going to be cloudy anyway
15:59:08 <conal> is strace helpful with ghc-compiled programs?
15:59:10 <roconnor> lament: there is a certain truth to that statement
15:59:11 <Baughn> conal: Then I recommend you look into strace and ltrace. Both are rather vital tools on linux. :)
15:59:17 <Baughn> conal: strace is. ltrace, not so much.
15:59:20 <conal> Baughn: will do. thx!
15:59:31 <mreh> i need to update the state of my spaceship, and hence do lots of calculations to redraw it, does this merit using moands for the sequentiality?
15:59:47 <Baughn> mreh: Do you /need/ the sequentiality?
16:00:00 <lament> roconnor: but i might, it seems like a really cool opportunity
16:00:07 <roconnor> lament: I hope it won't be cloudy though.
16:00:07 <mreh> Baughn, to make it readable, yes
16:00:16 <lament> i've seen two partial eclipses, they were cool but not all that exciting
16:00:22 <mauke> conal: strace cuts through the surface bullshit and shows you what the damn program is really doing!
16:00:26 <Baughn> mreh: And technically, monads aren't about sequentiality. Monads are about join :: m (m a) -> m a
16:00:33 <wicket> I'm trying to get my parallell code working, and i think i need to control the evaluation in order to get some good results (right now -N1 is best). I have an embarrasingly data parallell routine, where i parse many strings into a data type. But it doesn't seem like line 23 is forcing evaluation. http://pastebin.com/m5b874951
16:00:33 <lament> the best part is all the people walking around on the streets not knowing that anything is going on :)
16:00:34 <roconnor> lament: totally eclipses are totally different.
16:00:38 <roconnor> lament: total
16:00:39 <lament> roconnor: totally.
16:00:47 <mauke> it's equally useful for programs written in C, Perl or Haskell
16:00:51 <Baughn> mreh: WHich, granted, allows sequentiality. Among other things.
16:00:52 <conal> mauke: cool.  thx.
16:01:20 <roconnor> lament: this will be the longest eclipse this century
16:01:30 <Baughn> mreh: I don't know how experienced you are, so - what about "let a = foo indata; b = munge a; c = munge b in c" or so?
16:01:32 <wicket> If I don't add line 25 or 26 the execution time of the program goes down to < 1 second, and if i keep these it turns into the more realistic 15 seconds.
16:02:05 <Baughn> mreh: In my case, I tend to write functions like "function x y z = <something simple>.. where <lots of clauses>"
16:02:29 <lament> roconnor: i guess even through the clouds it will be quite apparent
16:02:36 <opqdonut> Baughn: IMO that tends to get difficult to read when <lots of clauses> refer to eachother
16:02:51 <Baughn> opqdonut: It's usually serial-ish
16:02:55 <opqdonut> when <lots of clauses> are independent, it's good style
16:02:55 <Baughn> Or at least tree-ish
16:02:58 <roconnor> lament: true, but the sky is the best part of the show
16:03:24 <mreh> Baughn: What i need is certain calculations to be done before others, like the rotation of the ship done before the velocity calculations
16:03:26 <opqdonut> hmm, treeish
16:03:30 <Baughn> opqdonut: I think of it as naming intermediate values. It's easier to read than /not/ having names.
16:03:33 <opqdonut> some people use nested where's
16:03:42 <opqdonut> i tend to think more equationally
16:04:07 <opqdonut> i mean, with the same mindset as when writing mathematical equations
16:04:10 <Baughn> mreh: Oh, you're talking /updates/..
16:04:11 <conal> mreh: maybe you could find a more functional design.
16:04:12 <mreh> Baughn: I'm thinking like destructive updates are an issue still, I'll work it out
16:04:25 <Baughn> mreh: Functional Game Design 101:
16:04:33 <Baughn> mreh: Make frame N+1 a function of frame N
16:04:38 <conal> mreh: and let laziness and value dependencies sort out the scheduling
16:04:56 <Baughn> mreh: Do not allow details of N+1 to be a function of other details of N+1 when you can avoid it
16:05:04 <Baughn> mreh: Sprinkle parallelism as appropriate.
16:05:16 <Baughn> Games tend to be much easier to parallelise like that. :)
16:05:43 <mreh> Baughn, where does user input comein?
16:06:23 <Baughn> mreh: The model was a bit simplified. You attach that to frame N as input.
16:06:37 <mreh> frame N+1 is a funtion of frame N pkus input
16:06:41 <Baughn> Right
16:06:42 <mreh> cool
16:07:33 <mreh> what I've seen done, is user input modifying the content of frame N... is that bad
16:07:44 <mreh> sounds bad
16:07:44 <Baughn> Yes. It makes it very hard to reason about the programs.
16:07:52 <Baughn> Well, it's the exact same bad as all mutating code. ;)
16:08:02 <Baughn> And, of course, it makes adding parallelism harder
16:08:10 <mauke> .oO( self-mutilating code )
16:09:00 <conal> Baughn: i have some unpushed changes to reactive that probably help some with the problems you've been having.
16:09:04 <Baughn> mreh: Of course, one consequence of this is that some input may be two frames delayed. Say, user presses "roll left" on frame 1, the ship model rotates on frame 2 but you're still using the thrust vector from frame 1 for translating it
16:09:27 <conal> Baughn: i'll shake the dust off, make sure it runs with reactive-fieldtrip examples, push, and let you know.
16:09:35 <Baughn> Thanks
16:09:51 <Baughn> mreh: One possibility is to design your game so this isn't an issue - it might be considered more realistic, even
16:10:38 <Baughn> mreh: Another would be to actually make some of frame N+1 (translation dependent on other parts of N+1 (thrust). This isn'T /that/ big an issue; you're losing paralellism, but only for that one task
16:10:49 <Baughn> Distinct ships can still be simulated separately. :)
16:10:55 * mreh brane asplodes
16:11:09 <PeakerWork> conal: could you get fieldtrip to compile on ghc-6.10.[2,3] ?  Its probably a few-minute fix (An Occurs check on a type)
16:11:39 <conal> mreh: another piece of advice: make sampling (frame generation) and simulation (e.g., numeric integration / position updating) be independent of each other.
16:11:50 <conal> PeakerWork: will do.
16:12:08 <Baughn> conal: Oh, and you should limit reactive to Stream-0.3 - or switch to a newer version of quickcheck
16:12:23 <conal> PeakerWork: i think i know what that problem would be.  i changed the VectorSpace instance for functions.
16:12:49 <p_l> Well, OpenGL afaik doesn't like multithreading too much...
16:12:50 <conal> PeakerWork: for programmable lighting models
16:13:04 <mreh> my design so far is to fold
16:13:08 <mreh> oops
16:13:09 <Baughn> mreh: A third piece of advise: Learn about reactive. :)
16:13:16 <conal> heh
16:13:44 <conal> or *any* way to think about animation/behavior/interaction/simulation *functionally*
16:13:45 <mreh> my design so far is to fold the events generated by the user, onto the old state to make a new game state
16:13:51 <Baughn> p_l: That is.. not quite true, but it's very specific about how you do multithreading
16:14:02 <Baughn> Mostly, doing all rendering in a forkOS'd thread will do.
16:14:06 <conal> and not just functionally, but also continuously
16:15:00 <Baughn> conal: By the way, does reactive really need to call forkIO quite that much? -_-
16:15:11 <PeakerWork> conal: FieldTrip sounds really really cool.. Is there a tutorial anywhere or in some future plan?
16:15:19 <conal> Baughn: oh yeah.  what symptom do you get for the stream/quickcheck issue?
16:15:29 <Baughn> conal: Won't install. cabal-install refuses.
16:15:31 <mreh> so what I need to do is... make sure when folding the updateState method onto the old state, that all functional dependancies are resolved then
16:15:40 <Baughn> conal: Must provide Stream-0.3 constraint on command line in some form to make it work.
16:15:53 <conal> Baughn: and if you don't?
16:16:04 <PeakerWork> conal: its the same one I told you about a while ago -- you said you added it to your in-civilization TODO list :)  You depend on Stream-0.3.1 which depends on a newer QuickCheck which conflicts with some other dependency of quickcheck
16:16:08 <conal> Baughn: i'm not getting any sign of brokenness.
16:16:29 <Baughn> conal: Ah.. I'd need to uninstall both to get the exact error message
16:16:56 <PeakerWork> conal: cannot configure Stream-0.3.1. It requires QuickCheck >=2.0    QuickCheck-2.1 was excluded because checkers-0.1.3 requires QuickCheck <2.0    QuickCheck-2.1.0.1 was excluded because checkers-0.1.3 requires QuickCheck
16:17:16 <PeakerWork> conal: same message with s/checkers/reactive
16:17:38 <Baughn> It's really kind of silly. Their quickcheck use doesn't involve the other library at all.
16:17:41 <PeakerWork> conal: missing <2.0 in the end of that error message there
16:17:42 <conal> PeakerWork: yeep.  i wonder why i'm not getting this error with my new ghc (downloaded when i was in civ)
16:17:55 <conal> PeakerWork: i'd like to make sure i really fix it.
16:18:01 <Baughn> conal: You need to ghc-pkg unregister reactive and Stream first
16:18:12 <PeakerWork> conal: did you explicitly specify quickcheck<2.0 dependency in reactive and checkers?
16:18:50 <conal> PeakerWork: probably not.  i'd better do so for now.
16:19:32 <PeakerWork> conal: where is cabal taking that restriction from?
16:19:35 <mreh> cheers for all the help guys
16:19:43 <mreh> i'm going to zleep
16:19:43 <conal> mreh: good luck!
16:20:17 <mreh> it seems Haskell just keeps on giving
16:20:27 <mreh> ...me headaches
16:20:37 <conal> sry.  i'm getting lost in details here.  what explicit dependencies do my libs need?
16:20:44 <Baughn> mreh: You know about tying the knot, right?
16:20:51 <conal> Baughn: which forkIO in particular?
16:21:10 <conal> PeakerWork: i don't have a FieldTrip tutorial.  unsure about its future.
16:21:26 <Baughn> conal: I don't know. I just see a whole lot of thread activity.
16:22:02 <conal> Baughn: okay.  i'd expect so, because of unamb, which is at the heart of reactive.
16:22:23 <Baughn> Ah. That thing.
16:22:27 <conal> Baughn: unamb is the key to how i figured out how to implement push functionally.
16:22:47 <conal> not literally push.  more like blocking pull.
16:22:56 <conal> "data-driven pull"
16:22:56 <PeakerWork> conal: I think if you could remove the dependency restriction of checkers/reactive that quickcheck is older than 2.0 -- then everyone can use the newest versions
16:23:30 <Baughn> conal: It's not a big deal. Once it's working it'll become wildly popular, and then people will pay you to have other people improve its performance.
16:23:31 <conal> PeakerWork: sounds easy.
16:23:49 <conal> Baughn: :)
16:24:02 <Baughn> conal: You should probably write a paper on /how to use it/, though, not just how it works
16:24:07 <chessguy> byorgey, dmwit , you are totally collectively the man for doing a hacathon in philly :)
16:24:26 <conal> Baughn: agreed.  btw, have you ready old frp papers?
16:24:31 <PeakerWork> Baughn: I suspect others will, as soon as it works consistently on a current ghc
16:24:45 <Baughn> PeakerWork: Me, for one
16:25:01 <PeakerWork> I think dolio wrote some tutorials, and I think I might, once I can use it
16:25:19 <Baughn> conal: Too busy reading old middleware papers, so not yet
16:25:43 <PetRat> if you had [Maybe String] and you had already confirmed that "any isNothing xs == False", how would you write f :: [Maybe String] -> [String]?  f = map (\(Just x) -> x) ?
16:26:02 <Baughn> PetRat: map fromJust
16:26:03 <conal> Baughn: okay.  you'll get the general idea.  details will vary.  start with my silly old fran turorial, http://conal.net/fran/tutorial.htm
16:26:12 <PetRat> Baughn: thanks
16:26:35 <PetRat> Baughn: and the idea is that fromJust raises an exception if something isn't Just?
16:26:45 <Baughn> PetRat: An error, actually
16:26:56 <Baughn> PetRat: It's the same as your code, only prewritten
16:27:07 <Botje> catMaybes is also an option
16:27:09 <PetRat> Baughn: so much is prewritten :)
16:27:46 <Baughn> catMaybes is useful, yes
16:28:05 <Baughn> PetRat: Or my personal favorite, fromJust <$>
16:28:09 <PetRat> Botje: catMaybes xs = filter (not . isNothing) xs?
16:28:18 <Baughn> Yes
16:28:22 <mauke> unlikely
16:28:25 <Botje> PetRat: it also removes the Just tag
16:28:35 <Botje> @hoogle catMaybe
16:28:35 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
16:28:58 <Baughn> Ah, well, you could always throw in an unsafeCoerce to fix that
16:29:07 <Botje> :)
16:29:28 <mauke> :t [x | Just x <- ?xs]
16:29:29 <lambdabot> forall t. (?xs::[Maybe t]) => [t]
16:32:07 <dibblego> PetRat, catMaybes xs
16:32:42 <PeakerWork> Baughn: if you already know snapshot, stepper, switcher, monoid instance, Behaviors and Events, I'm not sure there's that much more to know to start using it?
16:33:08 <Baughn> PeakerWork: How best to compose them.
16:33:50 <Baughn> PeakerWork: I know a lot about how they work, and what they're /supposed/ to do, but since even my simplest test programs fail I'm having little success in learning to use them
16:34:09 <PeakerWork> Baughn: I think the only tip I remember is keeping continuous stuff continuous (e.g Behaviors) and only sampling when you really must (e.g: Before rendering, or on a game clock for some network game, or such)
16:34:11 <A1kmm> Hmm, if something isn't listed in exposed-modules in its cabal file, does that mean there is no way at all to access it from another package?
16:34:21 <Berengal> Is dynamic scoping used much at all?
16:34:22 <PeakerWork> Baughn: well, you can imagine what the test programs would do :)
16:34:51 <Baughn> Berengal: Never seen it. In practice, StateT/ReaderT, etc. are preferred.
16:34:55 <PeakerWork> Baughn: Oh I of course forgot important stuff in there: Functor,Applicative,Monad instances of Event/Behavior (The Applicative/Monad instances are weird for event, maybe), and accumE
16:35:35 <PeakerWork> Berengal: I think dynamic scoping of variables is a silly thing -- you can always just pass whatever container you want as an argument (explicitly or implicitly via some monad)
16:35:40 <Baughn> PeakerWork: Really, I just asked for a tutorial to sate my need for functional reactive goodness before I'd actually gotten it working. :)
16:36:44 <PeakerWork> Baughn: I think (fmap + accumE) are one of the more genius ideas in FRP -- they're the step I lacked in my attempt to create a functionally reactive environment in a previous project
16:37:01 <PeakerWork> in Reactive, that is
16:37:14 <Berengal> Yeah, I've seen examples of where dynamic scoping can be neat, but it never struck me as that much better than static scoping in even those cases
16:37:21 <Berengal> Just wondering if there was something I missed
16:37:36 <Baughn> Well.. was dynamic scoping added before or after monads?
16:38:13 <PeakerWork> Berengal: where are those examples?
16:39:30 <Berengal> PeakerWork: Eh, I'd have to dig for them, but consider print :: (?stream :: Handle) => a -> IO () and a toplevel ?stream = stdout
16:40:10 <Berengal> You could redirect by going 'redirectOutput handle action = let ?stream = handle in action'
16:40:22 <PeakerWork> Berengal: Nicer as an explicit monad there, IMO
16:40:46 <PeakerWork> Berengal: that's a namespace collision just waiting to happen (The word "stream" has to be unique for the entire call hierarchy here!)
16:41:29 <Berengal> PeakerWork: Yeah, agreed on both points.
16:42:12 <Berengal> But it seems to make at least some sense
16:42:13 <Baughn> Berengal: And if you haven't already, read up on the monad transformer library and associated typeclasses - how MonadIO and similar typeclasses let you ignore most of the stack, etc.
16:43:13 <Berengal> Baughn: I've touched on them at least, got a basic feel for it.
16:44:27 <PeakerWork> Haskell could use some specialized syntax for monad transformers, for nicer imperative programming (I don't think they're that common when doing pure FP)..
16:44:53 <Berengal> Dynamic scoping seems to me to just be the ability to modify the environment inside a call. I get how that can be nice, but it's not something you need in Haskell
16:44:59 <PeakerWork> For example, a syntax to declare a stack and get named lifters for each layer
16:45:26 <PeakerWork> Berengal: You can do that when the environment is an explicit argument. Implicit arguments are not a good idea, IMO
16:46:05 <PeakerWork> Having do statements auto-lift IO stuff, perhaps
16:46:10 <Berengal> PeakerWork: like lift1 = lift; lift2 = lift. lift ?
16:46:46 <PeakerWork> Berengal: no, meaningful names for the layers. Each transformer is usually used for some purpose, so the name would not be 1 or 2, it would be liftGuiState, liftFontReader, ...
16:46:52 <Baughn> Berengal: I much prefer liftToParticularMonad
16:47:06 <Baughn> I've never yet wanted two instances of the same transformer
16:47:09 <Berengal> Yeah, that'd probably require some sugar or TH
16:48:01 <PeakerWork> Baughn: With reader/writer/state you can of course use a composite value instead, but I prefer using ReaderT .. (ReaderT .. (... ))
16:48:04 <Berengal> perhaps something like 'type MyMonadT a = FooT BarT BazT a deriving (TransformerLifters)'?
16:48:27 <vininim> > let w = [1..9] in [(w!!x) | x <- [0,1,4,7,8]]
16:48:28 <Berengal> to give you liftBarT and liftBazT
16:48:29 <lambdabot>   [1,2,5,8,9]
16:48:35 <vininim> yay
16:49:16 <PeakerWork> Berengal: No, I would want to give names that are not by-type
16:50:04 <PeakerWork> Berengal: For example:  newtype GUI m a = StateT GUIState (StateT UserState m) -- liftGUIState, liftUserState -- even though they're both StateT
16:51:09 <alexsuraci> What is the default precedence level and associativity for an operator? 5 and none?
16:53:36 <Baughn> > let (*) = (+) in 2 * 3 * 4
16:53:37 <lambdabot>   9
16:53:44 <Baughn> Well, apparently not none
16:54:05 <Baughn> > let (+) = (*) in 2 + 3 + 4
16:54:06 <lambdabot>   24
16:54:17 <koninkje_away> alexsuraci: ask ghci ":info (*)"
16:54:26 <koninkje_away> oh, the default. nm
16:54:41 <Baughn> So, left-associative
16:54:53 <Baughn> > 2 * 3 * 4
16:54:54 <lambdabot>   24
16:55:18 <alexsuraci> ah, yea
16:55:25 <alexsuraci> now to figure out the precedence
16:55:44 <alexsuraci> quiet day today it seems
16:55:53 <alexsuraci> usually there's a big discussion about utf8 or something
16:56:34 <Baughn> > let (^) = (*) in 2 ^ 3 + 100
16:56:36 <lambdabot>   106
16:56:45 <Baughn> Well, below 6.
16:57:07 <alexsuraci> well, I mean for defining a new function and not specifying the infixl/infixr/infix
16:57:17 <alexsuraci> or using a regular function with backticks
16:57:36 <Baughn> I'm pretty sure it is five, actually, but you should check the standard
16:57:45 <alexsuraci> yeah, will do
16:58:20 <Baughn> > succ `map` "foo" `concat` "bar"
16:58:22 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
16:58:33 <mauke> ++
16:58:44 <ray> and lo, the haskell 98 report spake, and said "Any operator lacking a fixity declaration is assumed to be infixl 9"
16:58:47 <Baughn> > let mangle = (++) in succ `map` "foo" `mangle` "bar"
16:58:49 <lambdabot>   "gppbar"
16:59:08 <alexsuraci> ray: thanks, was just on the page searching for that :P
16:59:15 <Baughn> > let (^) = (*) in 2 ^ 3 + 100 -- That can't.. oh. Of course.
16:59:17 <lambdabot>   106
16:59:18 <alexsuraci> would have thought it'd be lower than 9. huh.
16:59:28 <Baughn> This one makes it /above/ the precedence of +, not below
16:59:55 <ray> highest precedence
17:00:22 <ray> besides function application, which goes up to 11
17:00:32 <Baughn> 10
17:00:35 <mauke> I thought application was 10
17:00:39 <alexsuraci> I'm curious how haskell does the infix parsing, it seems to me that you'd want to first scan for infixr/infixl/infix to determine how to parse the operators
17:00:47 <ray> i skipped 10 so i could say "goes to 11"
17:00:59 <Baughn> ray: No, that's token parsing
17:01:12 <Baughn> It's why mapconcat isn't map concat
17:02:23 <mauke> ray: Haskell does go to 11 but only if you leave function application at 10
17:25:34 <A1kmm> Hmm, I have a program which segfaults early on when run with ghc head on threaded mode... any tips on how to go about debugging this?
17:26:15 <A1kmm> (the problems only happen if I use +RTS -N2 or higher to enable parallel Haskell...)
17:29:20 <Tobsan> what is the main use of monoids in Haskell?
17:30:54 <Apocalisp> Tobsan: Summing over functors, deriving other monoids. They're rather useful, really.
17:31:33 <Tobsan> Alright. I was writing a tree structure just now and i happened to implement Monoid
17:31:41 <Tobsan> but then i realized i didnt know why
17:31:52 <Apocalisp> @type Data.Foldable.foldMap
17:31:53 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
17:31:56 <Apocalisp> that's why!
17:32:00 <Tobsan> oh snap!
17:33:22 <Apocalisp> You'll want to instance Foldable for your tree structure, I think.
17:34:46 <Baughn> > foldMap show [1..4]
17:34:47 <lambdabot>   Not in scope: `foldMap'
17:34:53 <Baughn> > Data.Foldable.foldMap show [1..4]
17:34:55 <lambdabot>   "1234"
17:41:20 <Peaker> does the lack of axiom of choice in intuition(SP?) logic (which total value types are isomorphic to) not a problem, in dependent types language, that use this isomorphism?
17:42:43 <opqdonut> well AC is non-constructive
17:43:03 <opqdonut> constructiveness is generally a nice property in logics relating to programming languages
17:43:17 <Peaker> opqdonut: I guess I have a lot more reading to do?
17:43:23 <Peaker> opqdonut: or is that easy to explain?
17:43:34 <opqdonut> probably yes (more reading)
17:43:49 <opqdonut> it might be easy to explain, however i am in no condition to do so
17:44:09 <Peaker> ok, thanks
17:44:53 <opqdonut> AC is only relevant when the logic we are studying has a rich enough model under it (sets, for example)
17:45:40 <opqdonut> i
17:45:53 <opqdonut> 'm not really sure what the c-h correspondence looks like wrt. dependent types
17:47:42 <conal> Baughn, Peaker: i just released new versions of checkers, reactive, and reactive-glut.  if you find version problems etc, please let me know.
17:48:17 <abbe> hi everyone
17:48:35 <abbe> is there any way to perform mapM_ like operation on Data.Map ?
17:48:54 <opqdonut> yes
17:48:59 <opqdonut> ?src Traversable
17:49:00 <lambdabot> class (Functor t, Foldable t) => Traversable t where
17:49:00 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
17:49:00 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
17:49:00 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
17:49:00 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
17:49:06 <abbe> opqdonut: how ?
17:49:22 <opqdonut> there's a Traversable instance for Data.Map
17:50:00 <opqdonut> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Data-Traversable.html#t%3ATraversable <- the relevant documentation
17:50:49 <opqdonut> however, mapM_ f $ elems m might also be sufficient
17:51:17 <abbe> opqdonut: oops, didn't thought of that. thanks :)
17:51:38 <opqdonut> np
17:51:40 <Baughn> conal: That fixes my most serious problem (event->behavior->snapshot working very badly) nicely, but the monad instance for Event now locks up at 100% cpu use
17:52:03 <Baughn> conal: (Earlier it deadlocked at no use, iirc. Or maybe I just didn't notice.)
17:52:17 <Baughn> Oh.. yeah, it deadlocked and GHC killed my program. Worked fine without -threaded.
17:52:21 <Baughn> Now it doesn't work, period.
17:52:48 <Baughn> I'll look closely at your patches, I guess. :)
17:53:29 <conal> Baughn: sigh :(
17:53:40 <conal> Baughn: thx.
17:54:06 <Baughn> conal: Oh, I almost forgot. Inside Timer.hs, specifically in the adaptE implementation (where it sleeps), there's a > comparison that I'm pretty sure should be >=
17:54:15 <Baughn> conal: Doesn't cause anything worse than a spurious sleep, though
17:54:23 <Baughn> (A spurious 0-length sleep)
17:55:34 <abbe> > mapM (putStrLn . show) (Data.Map.insert 5 10 (Data.Map.empty))
17:55:35 <lambdabot>   Couldn't match expected type `[a]'
17:55:46 <Baughn> conal: Make that Timing.hs and sleepPast
17:56:03 <abbe> any ideas what is error in this ?
17:56:20 <conal> Baughn: i see it now.  hm.  the comment says "-- Snooze until strictly after the target."
17:56:21 <mauke> yeah, this mapM takes a list
17:57:10 <abbe> mauke: oh, so i've to import from Traversable. and explicitly qualify it, right ?
17:57:22 <Baughn> conal: Which is a questionable idea. How do you even know you're "strictly after" after calling sleep with *0*?
17:57:33 <mauke> yeah, or hide the prelude version
17:57:41 <mauke> also, putStrLn . show = print
17:57:44 <Baughn> conal: But if that's important, better replace the loop
17:58:22 <conal> Baughn: i guess i don't.  that whole input timing thing is still shaky.  not just in the details.
17:58:23 <abbe> mauke: any ideas how to assign import a module in GHCi under a separate name. equivalent of import Data.Map as M ?
17:58:31 <abbe> s/assign i/i/
17:58:41 <Baughn> conal: That said, for what adaptE's using it for, I don't think I'd want "strictly past"
17:58:43 <MonadBaastad> BTW, isn't Data.Map an instance of Monad? :)
17:58:51 <mauke> abbe: I don't know a way to do that
17:59:00 <mauke> MonadBaastad: no
17:59:15 <abbe> okay, thanks mauke :)
17:59:18 <Baughn> conal: If I ask for an action to be executed at 2 seconds, I don't really wish for it to wait for 2.00001 seconds. ;)
17:59:56 <conal> MonadBaastad: maybe no one thought to implement the Map Monad instance.
18:00:21 <Baughn> It's not entirely obvious what it'd do
18:00:28 <mauke> return x = ?
18:00:32 <Baughn> singleton
18:00:33 <conal> Baughn: maybe there are other uses.  i forget.
18:00:41 <mauke> Baughn: what
18:01:04 <Baughn> mauke: Or maybe not. I haven't give it much thought. :)
18:01:12 <Baughn> mauke: I got stuck trying to implement Applicative for Map
18:01:27 <conal> my "denotational design" paper answers this question.
18:01:31 <conal> about Map monad.
18:02:18 <conal> there's a simple, general principle for answering questions like this one.
18:02:41 <MonadBaastad> There *is* an Applicative inst. for Map, though. :)
18:02:42 <Baughn> "First implement it, then notice you implemented a monad"?
18:02:51 <conal> :)
18:03:15 <mauke> what is pure for Maps?
18:03:22 <MonadBaastad> Baughn: The Force is _strong_ with you. :)
18:04:02 <copumpki> Map as in Data.Map?
18:04:21 <Baughn> mauke: ..am I allowed to have it read a global variable updated with the last key to be written into a map?
18:04:30 <mauke> Baughn: hah
18:04:45 <mauke> that doesn't even work
18:05:09 <duke83> hi there.. how can I read a file, which contains some haskell code, and execute what it has read? is it possible. using import a module is not an option for me... the file mainly contains some variable declarations
18:05:42 <Baughn> @src Ord
18:05:43 <lambdabot> class  (Eq a) => Ord a  where
18:05:43 <lambdabot>     compare      :: a -> a -> Ordering
18:05:43 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:05:43 <lambdabot>     max, min         :: a -> a -> a
18:06:12 <mauke> duke83: if it's just some variables, why do you have to execute code?
18:06:35 <duke83> you are right... execute is the wrong word
18:06:44 <Baughn> duke83: Easier (and safer) to use something like JSON, perhaps
18:06:52 <mauke> sounds like you want a config parser
18:07:04 <mauke> for a quick and dirty solution, see Read
18:08:15 <duke83> thx, I thought it will read everything as a string, but I am probably wrong
18:08:20 <Baughn> mauke: I've got it. pure = undefined.
18:09:06 <solidsnack> It's dawned on me that a container which is also a monoid is filterable.
18:09:21 <solidsnack> However, a container that is a MonadPlus is also filterable.
18:09:29 <solidsnack> So say we want a generic filter.
18:11:04 <solidsnack> So say I create a Filterable class and then set instances for `(MonadPlus m)` and also `(Monoid (m t))` -- then they will overlap in some cases.
18:11:11 <solidsnack> What will happen?
18:11:40 * shapr grumbles
18:11:52 <shapr> Ubuntu server only has ghc 6.8, I guess I'm switching to debian.
18:12:16 <solidsnack> Maybe is is best to insist that an MonadPlus be given Monoid instance.
18:12:28 <conal> solidsnack: theoretically (ignoring how instance selection really works in haskell), there's no problem unless the instances disagree.
18:12:28 <Baughn> solidsnack: To begin with, you can't do that. IIRC, "instance Foo a => Bar a" works the same way as just "instance Bar a", presumably on the idea that you can always define a Foo /somewhere/, so if it didn't you might get overlaps
18:12:35 <solidsnack> s/an MonadPlus/any MonadPlus/
18:12:54 <conal> solidsnack: secondly, what Baughn just said.
18:12:58 <Baughn> solidsnack: ISTR there was some incredibly complicated solution involving overlapping and incoherent types for that, but...
18:13:34 <Baughn> solidsnack: You're better off just picking one and putting the restriction in the class definition
18:13:41 <solidsnack> Ah.
18:13:43 <solidsnack> Okay.
18:13:48 <conal> not having the instance constraints considered during instance selection is a real pain sometimes.
18:14:04 <conal> e.g., two functors compose to a functor, but to contravariant functors compose to a functor also.
18:14:33 <conal> also a contra-functor composed with a functor is a contra-functor; and a functor composed with a contra-functor is a contra-functor
18:14:52 <FunctorSalad> conal: add a dummy parameter to the typeclass?
18:14:53 <solidsnack> conal: So this would be in an instance of which class?
18:15:10 <FunctorSalad> (assuming you're using your own functor class)
18:15:14 <conal> FunctorSalad: to the Functor typeclass?
18:15:29 <conal> solidsnack: Functor in the first example and Co(ntra)Functor in the second
18:16:06 <FunctorSalad> not sure whether this would work
18:16:07 <Baughn> What's the type signature of contrafmap?
18:16:32 <FunctorSalad> class Functor tag f where fmap :: (a->b)->f a->f b
18:16:41 <FunctorSalad> or does tag have to occur in the body?
18:16:51 <conal> Baughn: cofmap :: (a -> b) -> (f b -> f a)
18:16:57 <mauke> FunctorSalad: only if you want to actually use fmap
18:17:16 <Baughn> conal: ..that's even /possible/?
18:17:16 <conal> Baughn: it's in the TypeCompose package.  very handy!
18:17:30 <conal> Baughn: i run into it a lot.
18:17:47 <conal> Baughn: for any *reciever* of values.
18:17:54 <FunctorSalad> mauke: wasn't there some trick to make it choose the instance for any tag?
18:18:10 <mauke> unknown
18:18:27 <solidsnack> So the problem in this case is that we want an instance like  `instance (CoFunctor a, CoFunctor b) => Functor (something) where fmap = cofmap . cofmap`  ?
18:18:59 <pumpkin> isn't it contramap?
18:19:03 <conal> Baughn: if i know how to receive b and i know how to turn an a to b, then i know how to recieve a.  nice, huh?
18:19:23 <conal> solidsnack: yeah
18:19:32 <solidsnack> pumpkin: Maybe so. I'm asking because the context for the example is a little unfamiliar.
18:19:39 <pumpkin> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Contra.html#v%3Acontramap
18:20:15 <Baughn> conal: Right you are. Huh..
18:20:25 <solidsnack> I guess something would be, uhm, well, I have no idea. Would it be `TypeCompose a b` ?
18:20:27 <Baughn> conal: ..that's my dose of brain-mangling for today, I think.
18:20:47 <conal> pumpkin: oh, thx. didn't know about that class.  geez, there's a lot in category-extras.
18:20:50 <solidsnack> (Or something else to accomplish type composition.)
18:20:53 <conal> Baughn: :)
18:21:03 <pumpkin> I remember making a contrafunctor instance for the composable folds thing
18:21:08 <pumpkin> but it was a bit of a stretch
18:21:23 <conal> solidsnack: yes.  see the TypeCompose package.
18:21:35 <conal> solidsnack: @hackage TypeCompose
18:21:40 <conal> @hackage TypeCompose
18:21:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose
18:22:08 <solidsnack> Aha, thank you -- that would be the missing context.
18:22:11 <conal> i got type (constructor) composition from the applicative functor paper.
18:22:23 <conal> functors compose to functors, and applicatives compose to applicatives.
18:22:33 <conal> monads sometimes compose to monads, but sometimes not.
18:22:42 <conal> and even when monads compose, they don't compose uniformly.
18:22:51 <conal> unlike functors & applicatives
18:23:06 <conal> that's why we don't need "applicative transformers".
18:23:17 <conal> applicatives + compose are their own transformers
18:23:53 <conal> in practice the composition newtype wrapper ("O") is awkward.
18:26:32 <solidsnack> Interesting.
18:28:54 <conal> using type composition, i've been able to replace code with type compositions.
18:30:06 <solidsnack> Through default instances in type classes?
18:31:32 <conal> not defaults.  if a type is defined to be a composition, then it doesn't need (and can't have) an functor or applicative instance.
18:32:16 <solidsnack> So through the, uhm, "obvious" composition of their respective operations?
18:32:45 <conal> solidsnack: i don't know if it'd be obvious to you or not.  it's in the applicative functor paper.
18:33:08 <solidsnack> Ah, okay.
18:33:11 <idnar> hooray for applicative functors, I guess
18:33:34 <pumpkin> yay
18:33:44 <solidsnack> So it looks like I'm wrong about this monoid/filterable thing.
18:33:58 <conal> by getting familiar with the functor & applicative instances for maybe, pairing, functions, etc, and composition, i've been able to make lots of code just vanish.
18:34:24 <solidsnack> I need `toList` or something `:: monoid (monoid t) -> monoid t` (`join` would suffice in many cases)
18:34:48 <mauke> :t mconcat
18:34:49 <lambdabot> forall a. (Monoid a) => [a] -> a
18:35:02 <solidsnack> I don't get to start with a list, though.
18:35:07 <pumpkin> a joinable monoid :o
18:35:15 <idnar> solidsnack: `:: monoid (monoid t) -> monoid t` doesn't make any sense
18:35:20 <conal> solidsnack: hm.  Monoid classifies types, not type constructors.
18:35:23 <pumpkin> Sum (Sum Int)
18:35:31 <solidsnack> filter :: (a -> Bool) -> monoid t -> monoid t
18:35:32 <pumpkin> :P
18:35:40 <solidsnack> monoid is a type variable
18:35:45 <solidsnack> Monoid is a type class
18:35:48 <mauke> oh, so it's not a Monoid?
18:35:55 <idnar> solidsnack: right, so monoid t is impossible
18:35:58 <mauke> \o_O/
18:36:06 <solidsnack> right,
18:36:23 <solidsnack> i mean, the thing such that `monoid t` is in `Monoid`
18:36:38 <idnar> I wonder if type constructors that construct monoids are a useful class by themselves
18:36:57 <conal> TypeCompose has the class Monoid_f
18:37:00 <conal> for that purpose
18:37:23 <idnar> ah, so (Monoid_f m) => m (m t) -> m t
18:37:42 <pumpkin> joinoid!
18:37:49 <conal> maybe.  though i'd guess Monad & join
18:37:49 <pumpkin> moin!
18:37:59 <idnar> but you'd need some kind of extension to include a join-like operation
18:38:21 <conal> solidsnack: why not use Monad & join?
18:38:35 <solidsnack> Well, I need it to be MonadPlus, I think.
18:38:43 <solidsnack> That's the route I'm going to take, actually.
18:39:04 <idnar> @type msum
18:39:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:39:10 <idnar> @type mplus
18:39:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
18:39:17 <idnar> mplus isn't always the same thing as mappend, though
18:39:53 <idnar> uhm, do you have an example Monoid instance in mind? I'm trying to think of a concrete scenario here, and I'm not coming up with anything
18:39:57 <conal> and join isn't necessarily related to mplus, is it?
18:40:11 <idnar> conal: yeah...
18:40:19 <solidsnack> I'll be done in a second and paste it.
18:40:28 <idnar> uhm, and msum is only for lists
18:40:36 <solidsnack> Not using it :)
18:40:41 <Peaker> conal: src/FRP/Reactive/GLUT/Adapter.hs:48:39: Not in scope: type constructor or class `:+->'
18:40:48 * idnar twists his brain some more
18:40:48 <Peaker> conal: but the quickcheck version issues seem to be fixed
18:40:49 <conal> oops!
18:41:04 <amckinley> hey, would anyone like to help me with a small parsec parser? :)
18:41:05 <idnar> > join [[5, 6], [7, 8]]
18:41:06 <lambdabot>   [5,6,7,8]
18:41:07 <idnar> > msum [[5, 6], [7, 8]]
18:41:09 <lambdabot>   [5,6,7,8]
18:41:13 <amckinley> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5108#a5108
18:41:58 <idnar> oh man, parsec; I think that signals sleeptime for me
18:42:03 <conal> Peaker: oh, i see.  i missed a version dependency.
18:42:24 <idnar> amckinley: uhm, you seem to have a spelling or search/replace problem there
18:42:32 <amckinley> idnar: come on; its fun :)
18:42:36 <amckinley> orly?
18:42:45 <idnar> oh, wait, this is worse than I thought
18:42:56 <idnar> my poor head
18:43:01 <amckinley> :D
18:43:19 <amckinley> i decided to learn haskell by writing a parser for bind config files
18:43:46 <amckinley> the problem im having is with input that looks like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5109#a5109
18:43:58 <idnar> uhm, so, I'm confused; is the mangling in that paste a joke, or what?
18:44:17 <idnar> or is my browser doing something silly?
18:44:27 <idnar> oh, my browser is doing something silly
18:44:40 <amckinley> idnar: not sure; it looks reasonable to me, but that might be wishful thinking :)
18:44:44 <conal> Peaker: released reactive-glut 0.1.9, with reactive version dependency fixed.
18:44:58 <Peaker> conal: reinstalling..
18:45:10 <idnar> this is what firefox is doing: http://slipgate.za.net/~mithrandi/dear-firefox-wtf.png
18:45:25 <Peaker> conal: It really seems like this cabal business needs more automation of the dependencies...
18:45:27 <idnar> but, for example, if I copy the text into gnome-terminal, it comes out okay
18:45:34 <amckinley> madness
18:45:42 <conal> Peaker: indeed! :(
18:45:56 <conal> Peaker: we need more static checking.
18:46:39 <idnar> what about static electricity!
18:46:45 <conal> :)
18:46:49 <Peaker> conal: yeah.. a type signature of the exported modules to check against -- verifying the version dependency holds
18:46:53 <conal> maybe if we had a real module system, like ML
18:46:58 <Peaker> conal: seems to compile now
18:47:01 <conal> :)
18:47:05 <Peaker> conal: :-)
18:47:05 <solidsnack> Okay, this works for lists.
18:47:06 <amckinley> idnar: very weird; my firefox is fine. i could switch over to regular pastebin...
18:47:06 <solidsnack> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5110#a5110
18:47:16 <idnar> amckinley: I think it's because I haven't restarted it since I upgraded the binary
18:47:30 <Peaker> conal: hey cool, you fixed fieldtrip?
18:47:34 <conal> this reactive version may have broken integral.  one example in reactive-fieldtrip just sits there.
18:47:38 <stepnem> please, what is the most painless way to get only the elements occuring more than once in a list?
18:47:42 <idnar> amckinley: another fun thing is that some dialogs just have XML parse errors instead of their expected contents
18:47:46 <conal> Peaker: great :)
18:47:59 <amckinley> idnar: yeah, ive seen that before :)
18:48:01 <Peaker> conal: reactive-fieldtrip fails, though
18:48:07 <idnar> amckinley: another fun thing is that some dialogs just have XML parse errors instead of their expected contents
18:48:36 <Peaker> src/FRP/Reactive/FieldTrip.hs:30:9: Could not deduce (Bounded tr) from the context (Transform (BehaviorG tr tf xf) (BehaviorG tr tf a), Ord tr, Transform xf a)
18:48:54 <solidsnack> So it looks like things in `MonadPlus` have enough structure to be generically filtered; monoids don't because you can't walk them and aggregate the walk.
18:48:56 <conal> Peaker: hm.  i'll release a new reactive-fieldtrip then.
18:49:07 <Peaker> conal: awesome :-)
18:49:14 <idnar> solidsnack: yeah, monoids are values not containers
18:49:41 <Peaker> conal: I am really anxious to start toying with Reactive.. Feel more comfortable with my understanding of things now to actually debug stuff even, hopefully
18:49:48 <idnar> solidsnack: it might be useful for the values /in/ the container to be monoids, though
18:50:03 <Peaker> conal: ghc could use more debugging tools.. especially for threads
18:50:11 <solidsnack> idnar: How?
18:50:29 <Peaker> Something visualizing threads/mvar state could be pretty cool
18:50:31 <idnar> solidsnack: I just mean (Monad m, Monoid a) => m a
18:50:45 <conal> Peaker: and how.  this stuff drives me nuts.
18:50:49 <solidsnack> idnar: I don't see that as helping with filter, though.
18:50:52 <codebliss> So what do you guys say when you read (::)?  I got a new idea
18:50:54 <Baughn> conal: checkers-0.1.4 appears broken; you've forgotten to depend on quickcheck at all
18:50:54 <idnar> solidsnack: no, not really
18:51:05 <conal> really?!
18:51:06 <codebliss> "Has the type of" is pretty good, but when you think functions, it's kinda meh
18:51:06 <idnar> solidsnack: what you really want is some kind of sequence / enumerable / traversable / whatever typeclass
18:51:08 <solidsnack> codebliss: I say "has type".
18:51:21 <codebliss> solidsnack: I just thought of "represents."  It seems to fit nice.
18:51:22 <idnar> solidsnack: MonadPlus isn't really enough to "walk" it either
18:51:38 <solidsnack> idnar: Well, it seems I just need `MonadPlus`
18:51:46 <idnar> codebliss: (::) reads silently in my head
18:51:56 <Baughn> conal: No, not really. Hmm
18:51:59 <codebliss> idnar: Of course, what if you were explaining to newbies? =P
18:52:01 <solidsnack> idnar: `fmap` let's me walk it and `join` let's me collapse it again.
18:52:17 <Baughn> conal: You've forgotten to specify the version, and installing reactive pulled in a newer version at one point
18:52:24 <Baughn> conal: So the one checkers actually depends on is hidden
18:52:38 <idnar> codebliss: I'd just say that it's syntax for a type declaration
18:52:39 <codebliss> idnar: map represents an A to a B to an A list to a B list
18:52:44 <solidsnack> idnar: The presence of a zero element is what allows the collapse to accomplish the filtration.
18:52:49 <idnar> codebliss: I'm not big on translating programming language syntax to english
18:52:51 <Peaker> Baughn: sounds like an installed-package-depends-on-specific-version-it-happens-to-be-compiled-with issue
18:52:54 <conal> Baughn: i think someone (you?) suggested i leave off the version.  i'm in a muddle about what version to use for what.
18:52:57 <codebliss> idnar: Yeah, it doesn't work well.
18:53:09 <codebliss> idnar: I was teaching one of my professors and kind of hit a wall once
18:53:15 <Peaker> conal: I suggested that, and I think if you are version neutral, it is a good idea
18:53:24 <conal> okay new reactive-fieldtrip
18:53:27 <Peaker> conal: but maybe I'm missing something
18:53:30 <solidsnack> (It was the zero element that led me to monoid in the first place.)
18:53:35 <idnar> codebliss: I'm not sure why "has type" is any worse for functions, though
18:53:37 <Baughn> conal: It's a good idea only if all the possible versions of quickcheck would actually work with checkers
18:53:43 <Peaker> Baughn: they don't?
18:53:53 <Baughn> conal: quickcheck-2.1.0.1 doesn't; they've changed the interface
18:53:56 <idnar> f :: a -> b would read something like "f has type function from a to b"
18:54:16 <Baughn> conal: Say QuickCheck<2 or something, at least
18:54:24 <Peaker> conal: reactive-fieldtrip installed successfully, yay!
18:54:40 <conal> Baughn: i think QuickCheck<2 is what it said before i updated.
18:54:46 <codebliss> idnar: I think more of a currying sense.  Functions represent conversions of types to me, so when I think foo has type (A list to B list) to A list to B list, it kinda clashes
18:55:03 <Peaker> conal, Baughn: If that's truly the case then reactive truly conflicts with Stream >= 0.3.1 ?
18:55:09 <conal> clearly, i could use some help sorting out this stuff.
18:55:26 <idnar> codebliss: any non-trivial function type seems like a mess to me if you try read it out loud ;)
18:55:28 <Peaker> conal, Baughn: Maybe its better to update checkers/reactive to use the new quickcheck interface so that bugfixes/etc in Stream can be used?
18:55:37 <codebliss> idnar: Very true XD
18:55:41 <conal> Peaker: yes!
18:56:01 <Peaker> Baughn: do you know exactly what interface changed in quickcheck 2.1.0.1?
18:56:24 <amckinley> Cale: around? im back for more parsec abuse :)
18:56:38 <idnar> codebliss: I used to work with a friend, and every now and then I'd shout some code out to him, but I'd sorta leave out half of it because we both knew what I meant; everyone else in earshot used to get horribly confused, though
18:56:43 <Baughn> Peaker: No, but if you try compiling it it'll become obvious in short order. :)
18:56:50 <codebliss> idnar: Hahahah XD
18:57:09 <codebliss> idnar: You got haskell in a real job?
18:57:26 <Peaker> Baughn, conal: Ok, trying...
18:57:26 <idnar> codebliss: unfortunately not, this was mostly Python code
18:57:36 <Peaker> aha, no more: Test.QuickCheck.Utils
18:57:39 <codebliss> Python is much better than C's/Java
18:58:01 <Baughn> conal: Meanwhile, I'm just specifying Stream-0.3 manually. THat's the quick fix to get it working on hackage; you can port to quickcheck-2 later
18:58:02 <idnar> I'm still hoping that Haskell is going to be my primary language in the long run, but I'm wondering if it'll ever be ready for that
18:58:16 <conal> Baughn: which package?
18:58:24 <Baughn> conal: Basically, wherever you depend on Stream, say Stream == 0.3
18:58:25 <conal> hm.  how does one get QuickCheck 2?
18:58:31 <Baughn> cabal-install. :P
18:58:40 <conal> just tried.
18:58:49 <conal> maybe i need a cabal update.
18:58:54 <Baughn> Oh, right..
18:58:59 <Baughn> No, it defaults to quickcheck-1
18:59:05 <conal> oh
18:59:10 <Baughn> You need to say cabal install quickcheck-2.1.0.1
18:59:17 <conal> ah!  thx.
18:59:29 <idnar> is that version number in trinary? >:)
18:59:33 <Baughn> Yes
18:59:41 * Peaker tries to figure out exactly what old quickcheck stuff checkers needs and where they are in the new quickcheck
18:59:52 <idnar> that's, what, 0x64?
19:00:03 <idnar> er, 0x40
19:00:27 <idnar> I'd better find a bed before I pass out on my keyboard and spam the channel
19:02:02 <Zao> conal: Kudos for the post on C, it had me laughing a bit.
19:02:05 <Peaker> hmm.. testAssocativeBy/etc from Test.QuickCheck.Utils just disappeared in the new quickcheck?
19:02:13 <Peaker> Zao: where?
19:02:17 <conal> Zao: thanks! :D
19:02:25 <Zao> Peaker: http://conal.net/blog/posts/the-c-language-is-purely-functional/
19:02:34 <Zao> Trying to catch up on my RSS, two days old :)
19:03:05 <conal> Peaker: i see the same thing (no Test.QuickCheck.Utils)
19:03:28 <conal> coarbitrary moved out of Arbitrary
19:03:42 <Peaker> conal: I can't find any alternative either, and nothing on google about those functions
19:04:00 <Peaker> conal: which quickcheck had some release notes or such
19:04:08 <Peaker> conal: can just duplicate the old library code into checkers :-(
19:05:30 <p_l> conal: That post is ... I lack the words to describe its awesomness
19:06:08 <conal> p_l: wow!  :D
19:06:39 <Baughn> conal: And now I can go back to my original proof-of-concept code. server :: Event Command -> Reader (Event Reply)
19:07:03 <gnuvince_> If I have the following code: do { t1 <- getPOSIXTime; let x = f y; t2 <- getPOSIXTime; return (x, t2 - t1) }, is the time difference the time it took to run the f function or the time it took to generate the thunk?
19:07:06 <p_l> conal: the possibilities for Mind Screw among other langauge lawyers are too big for lower grade :D
19:07:08 <Baughn> p_l: Also, link to post of Kamina-like awesomness?
19:07:08 <Peaker> conal: nice post :-)   The Haskell functional part is significantly stronger than cpp, though :-)
19:07:15 <Baughn> Wait..
19:07:20 <Baughn> The C=FP one? o_O
19:07:23 <p_l> Yeah
19:07:27 <conal> Peaker: it sure is.
19:07:32 <Baughn> Yeah, that was amusing
19:07:38 <p_l> Imagine the possibilities for screwing with people's minds :D
19:07:50 <Peaker> conal: any idea why the quickcheck guys would eliminate seemingly useful functions like testAssociativeBy?
19:07:56 <Baughn> I always thought C was more functional than a lot of other languages, though.
19:08:00 <Baughn> At least it /has/ function pointers. ;)
19:08:05 <conal> Peaker: the functional parts differ in *degree* only.  so if you call one pure you have to call the other pure.
19:08:23 <Baughn> conal: ..and my intelligence differs in degree only from a rock.
19:08:25 <conal> Peaker: that's the real point of my post.  i'd been wondering for a while how to make that point in a way that people would hear.
19:08:38 <conal> Baughn: then you're equally "pure"
19:09:40 <p_l> Baughn: And some stuff that can be done with those when using C as second stage can be quite amusing :D
19:10:18 <Peaker> conal: I do think that there's an interesting point to be made about Haskell's power/referential transparency, even when dealing with IO. As you say, its probably mostly a quantitive rather than a qualitive thing, but also there's the issue of cpp handling possibly invalid syntactic elements and pure Haskell handling type-safe imperative actions
19:11:01 <conal> the post is my way of challenging the common description of Haskell-with-IO as "purely functional".  the defense that people often make, when pressed, applies also to C.
19:11:12 <conal> that's what i was getting at.
19:11:39 <conal> perhaps with humor, i won't be flame-broiled when i point it out.
19:11:45 <Peaker> conal: what if you ignore the existence of CPP?
19:11:48 <sohum> so I'm trying to use cabal for the first time, and I get 'Could not find module Data.Data'
19:12:08 <gwern> Peaker: personally, I'm wondering what you get by combining CPP+Haskell
19:12:10 <conal> Peaker: then you're left with just IO (C)
19:12:22 <Baughn> sohum: What GHC version are you on? o_O
19:12:23 <conal> gwern: without IO?
19:12:31 <gwern> sohum: need more details. possibly you are missing a dep in the .cabal
19:12:41 <Baughn> No, Data.Data is in base
19:12:54 <sohum> Baughn: "The Glorious Glasgow Haskell Compilation System, version 6.8.2"
19:12:57 <gwern> Baughn: maybe he's missing base as a dep!
19:12:59 <conal> Baughn: hey -- when someone acts strangely here, we can ask "What (GHC version) are you on?"
19:13:33 <gwern> conal: heck, I dunno. you're the one with all this C IO stuff. (I didn't follow it even reading the blog post, so how would I know?)
19:13:53 <sohum> it was trying to install containers-0.2.0.1, if that helps
19:14:31 <sohum> ghc and co are installed via debian, and now I'm just starting to try to use cabal
19:14:42 <Peaker> is the quickcheck maintainer in #haskell ?
19:14:53 <gwern> Peaker: don't think so
19:15:16 <gwern> sohum: containers is one of the core packages; trying to install it generally says you're doing something wrong
19:15:24 <Peaker> gwern: the point is that even the C AST is a referentially transparent value that when compiled/executed, will yield a value, has similar semantics to IO () values in Haskell, even if the combinators on it are pretty crappy
19:15:45 <conal> Peaker: spot on!
19:15:54 <gwern> Peaker: see, I don't know what it means to say an ast is a referentially transparent value
19:15:56 <sohum> gwern: ok, so odds are that cabal doesn't know how to find the preinstalled packages?
19:16:00 <Peaker> So C is purely functional like Haskell, except the purely functional part is really really weak and cannot do anything with these action values
19:16:39 <gwern> sohum: I really have no idea. I ran into so many issues installing anything with debian I quickly gave up
19:16:50 <conal> Peaker: you got it. :)  so if we want to talk about how Haskell is different from C, we cannot (honestly) use the word "purely".
19:16:57 <gwern> as far as I'm concerned, if you're intermingling debian and cabal-install, don't waste #haskell's time asking about it
19:17:02 <Peaker> gwern: the AST is stateless, calling a CPP macro or using the expanded AST instead is equivalent. Or without CPP, you simply cannot call functions, so its referentially transparent in an .. empty way
19:17:05 <conal> more honestly, we can say that haskell is a "very functional programming language"
19:17:33 <Peaker> conal: I think the qualitive difference is the fact Haskell has powerful purely functional combinators on these IO values
19:17:40 <conal> and if we really want to say "purely", we can stop using IO and come up with something genuinely functional to replace it.
19:18:03 <conal> Peaker: yes.  *more* powerful than cpp's
19:18:09 <conal> it's still relative.
19:18:11 <solidsnack> conal: I think this is the point where we all say "and what is that?"
19:18:15 <conal> not absolute.
19:18:53 <conal> solidsnack: for now, it's getting back to exploring that very question, as people used to do before monadic imperative functional programming was invented.
19:18:53 <Peaker> conal: Yeah, I agree -- so the words "purely functional" are not that great to describe "powerful combinators on actions as first-class values"
19:19:03 <Peaker> conal: which is a true, genuine advantage of Haskell as an *imperative language*
19:19:10 <conal> Peaker: yeah.  because "purely" is an absolute, not a relative.
19:19:22 <conal> Peaker: yep.  haskell is a better C
19:19:29 <conal> so we can call it that.
19:19:33 <mmorrow_> and we have a better CPP
19:19:39 <mmorrow_> , ppDoc `fmap` fmaps 8
19:19:42 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
19:19:43 <solidsnack> As far as I can tell, Haskell without unsafePerformIO is pure, per Amr Sabry's paper.
19:19:47 <conal> on haskell.org: "Haskell: a better C"
19:19:54 <Peaker> conal: but this advantage is so huge that it makes others' languages Haskell libraries. It deserves a name, more than "better C" :)
19:20:03 <conal> solidsnack: yes.  just like cpp+c.
19:20:19 <solidsnack> Oh, so CPP is a purely functional langauge?
19:20:30 <conal> solidsnack: did you read my post?
19:20:32 <solidsnack> That's a little different.
19:20:36 <conal> Peaker: i agree.  "better C" is honest, but lacks something.
19:20:40 <Peaker> solidsnack: whose output is an action, that when executed will perform side effects and yield a result, like Haskell's main :)
19:20:53 <solidsnack> Peaker: Sure. Haskell is a better CPP.
19:21:17 <solidsnack> Or a better `++`
19:21:31 <mmorrow_> (+1)
19:21:38 <solidsnack> I'd much rather get my abstraction from Haskell :)
19:21:50 <conal> the reason i suggest "Haskell: a better C" is that we typically use "haskell" to mean "haskell+IO", and use "C" to mean "cpp+C"
19:21:54 <Peaker> conal: In Haskell, I can have an imperative program be typed via some newtype or type synonym, which is actually some monad transformer, and by changing this monad transformer in one place, I'm changing the statement bind operator behavior, something unheard of in other imperative languages..  Perhaps Haskell is an "overridable semicolon language" :)
19:21:58 <jeffz`> sohum, you might find it easier to ditch the debian specific stuff and use the haskell platform instead, that way things "just work"
19:22:02 <solidsnack> conal: Sure, I understand that.
19:22:09 <solidsnack> However, grauenwolf doesn't.
19:22:18 <conal> Peaker: yes.  that's part of what makes haskell a better C.
19:22:23 <solidsnack> Altough you don't mean to, you are feeding the trolls.
19:22:27 <dibblego> solidsnack, grauenwolf doesn't understand very much -- it's best to accept that fact
19:22:37 <Peaker> conal: But its a huge, qualitive, and not just quantitive advantage. Even if the quality happens not to have much to do with functional-ness or purity
19:22:57 <solidsnack> dibblego: He's unique in his aggressiveness but not in his confusion.
19:23:16 <conal> Peaker: yep.  i don't seriously want us to change hakskell's motto to "a better C".  i want it to be honest.
19:23:24 <Peaker> conal: I think that maybe because Haskell tends to be mind bending for a while, until you grasp the concepts well (and then its pretty simple, in retrospect :-) there's a lot of bad terminology and communication around
19:23:35 <conal> Peaker: yeah.
19:24:10 <Peaker> so we ought to rename "purely functional" to "overridable language semantics" or some such :)
19:24:31 <conal> something.  let's keep working on it until it's both honest and compelling.
19:24:52 <conal> now that i've spilled what my post is really about, maybe some of you will want to add comments on the post.
19:24:59 <Baughn> "A Kamina-like language"?
19:26:31 <conal> when i've talked about these issues more directly on #haskell, i get some defensive reactions.
19:27:11 <dibblego> conal, s/wisdon/wisdom
19:27:44 <conal> dibblego: thx!
19:28:22 <solidsnack> conal: I think this topic is under-developed.
19:28:51 <conal> solidsnack: yeah?  please say more.
19:29:06 <conal> dibblego: fixed
19:30:01 <solidsnack> It seems that this problem basically boils down to how deterministic we can make things.
19:30:19 <solidsnack> Or rather, how much of their determinism can we make observable.
19:31:19 <solidsnack> It seems like their should be some dovetailing with distributed systems -- in particular, the proof techniques being developed there.
19:32:12 <solidsnack> This is something which I still need to learn more about, naturally.
19:32:19 <conal> solidsnack: i'm not tracking you at all
19:32:47 <mmorrow_> 444444444444444444444555555555555555555555555555555555555555555555555555555555555555555555555555555555553333333
19:32:54 <mmorrow_> heh
19:32:57 <mmorrow_> good kittay
19:33:14 <copumpkin> :o
19:33:19 <copumpkin> u haz a cat
19:33:25 <solidsnack> conal: Well, my ideas are not very well developed, either.
19:34:02 <conal> solidsnack: ok.  np.
19:34:04 <p_l> Baughn: whut?
19:34:31 <solidsnack> Having said that, the root of my objection is that, as far as I can tell, as long as you expect components to communicate across a network with unsynchronized time and lossy links, IO is the best that there is.
19:35:12 <conal> solidsnack: best that there is or the best that we know?
19:35:30 <solidsnack> Given lossy links and unsynched time, best that there is.
19:35:43 <solidsnack> This could be a very interesting discussion, actually.
19:36:16 <conal> offhand, i can't imagine how you could prove "best there is".
19:36:34 <solidsnack> Fair enough.
19:36:36 <conal> pretty strong claim.
19:37:08 <conal> solidsnack: nice points to keep in mind while looking for something better than IO.
19:37:15 <conal> where better == semantically tractable
19:37:52 <conal> Peaker: eep.  lots breaks in checkers with quickcheck 2.
19:38:10 <Peaker> conal: except Utils dependency?
19:38:12 <copumpkin> thoughtpolice: around?
19:38:21 <conal> Peaker: yeah.  i've fixed the Arbitrary/CoArbitrary instances.
19:38:35 <conal> Peaker: and now i get to the Utils dependency.
19:38:46 <Peaker> conal: I'm not very familiar with quickcheck. I couldn't find the functions from Utils in the new quickcheck
19:39:04 <solidsnack> conal: That's fine to cast doubt on my certainties; but you can see how I look at these remarks about an alternative and remain unconvinced.
19:39:06 <Peaker> conal: I guess the quick&dirty fix would be to just port that module to new quickcheck and put it in checkers?
19:39:26 <conal> Peaker: i could, though i'm not a big fan of q&d.
19:40:12 <conal> Peaker: interested in giving it a try?
19:40:50 <solidsnack> conal: I guess a fair direction to take this is, what is intractable about IO and can I prove that it falls out of the traits that I described?
19:40:51 <conal> Peaker: or we could ask koen or andy or dons
19:41:12 <solidsnack> So maybe you can give me a property or something and I can look at that.
19:41:13 <conal> solidsnack: i like that direction!
19:42:13 <conal> solidsnack: i measure tractability by looking at the denotational domain (a mathematical type).  if it's simple, then it's tractable.  that's my measure.
19:42:22 <solidsnack> Okay.
19:43:05 <Peaker> conal: I'm not sure I can do it today (way beyond my sleep time), but I can try to hunt where the functionality has gone to in the next few days
19:43:08 <boblo2> can someone pls tell me what the | does in haskell?
19:43:10 <conal> solidsnack: IO is such a mess that it doesn't even have a denotational model, afaik.
19:43:37 <copumpkin> boblo2: it's like an if in disguise!
19:43:42 <Peaker> boblo2: Type sums -- declares that a type can have alternate data constructors (with their alternate fields) as potential values
19:43:53 <conal> Peaker: thanks.  i sure appreciate it.  i'm lousy at tracking a lot of details, so i probably can't do a good job of library maintenance on my own.
19:43:58 <Peaker> boblo2: do you know structs, unions and enums?
19:44:18 <conal> Peaker: which is also why i like genuinely functional programming (tm)
19:44:26 <boblo2> i am playing a "hacker" game that used haskell iv been learneing it the past few days
19:44:28 <Peaker> conal: Looking through your code, it certainly doesn't seem that you have trouble tracking details..
19:44:36 <conal> hah!
19:44:54 <conal> Peaker: i wonder if you mean the code that works or the code that doesn't.
19:45:07 <Peaker> conal: even your imperative implementation of Reactive is pretty nifty :)  btw: I wondered why you put the action serializer into Clock?
19:45:17 <Peaker> conal: I mean that its beautifully structured
19:45:40 <conal> Peaker: if it were's beautifully structured, i wouldn't have a chance.
19:45:46 <solidsnack> conal: My suspicion is that anything better depends on a transactional store at some level.
19:46:31 <conal> solidsnack: wow.  that would an amazing result if one could prove it.
19:47:02 <solidsnack> conal: Well, schema consistency would be the canonical example.
19:47:13 <solidsnack> As long as you have named (instead of structural) types.
19:47:18 <conal> solidsnack: there are non-existence proofs.  hard for me to imagine how we'd come up with one.
19:47:31 <Peaker> conal: Ugly code does not work very well in general, not just for you. Its just that most people have a lower standard of quality that they expect from their code
19:47:36 <conal> solidsnack: i.e., prove the nonexistence of a solution that doesn't use transactional store.
19:47:49 <boblo2> can someone tell me what +++ does in ParseLib? forgive me for the noobness
19:48:02 <conal> Peaker: yeah.  i don't trust code that "works".  i only trust code that's "true".
19:48:17 <solidsnack> It depends very much on what you want to do, of course.
19:48:23 <conal> Peaker: compellingly true.  code that's "inevitable".
19:48:39 <Peaker> conal: You might have encountered this mentality, its very common, that is saying that it is utterly impossible to write *anything* without bugs, and even security problems, no less.  IMO: This mentality stems from the fact that most people don't know how to write beautiful/well-structured code, and that badly structured code is true to that mentality
19:48:41 <solidsnack> If you don't want hot update and such, you don't worry about having a transactional store of modules.
19:49:39 <conal> Peaker: indeed.  and like most claims of "impossible", it's a self-fulfilling prophecy.
19:50:04 <conal> in other words when someone says something is impossible, i conclude that it's indeed impossible for them.
19:50:05 <copumpkin> boblo2: is it the same one as Arrow? I haven't used ParseLib
19:50:13 <copumpkin> :t (+++)
19:50:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
19:50:14 <p_l> Peaker: I wouldn't say impossible, but I'd classify some of it beyond scope of the program itself :)
19:50:15 <conal> Peaker: in part because people like to be right.
19:51:25 <Peaker> conal: I think many are also very unimaginative :(
19:51:54 <boblo2> (+++) :: Parser a -> Parser a -> Parser a
19:52:10 <boblo2> what does that mean
19:52:30 <QtPlaty[HireMe]> boblo2: That means that the function is a parser combinator.
19:52:35 <solidsnack> A statement about possibility is, unfortunately, no more trustworthy than one about impossibility.
19:52:38 <copumpkin> boo, not (+++) :: Parser a -> Parser b -> Parser (Either a b)
19:52:55 <conal> solidsnack: because it's a statement and not a proof.
19:52:58 <solidsnack> I've had a lot more trouble with requirements dictated by "possible" people than by "impossible" people.
19:53:09 <solidsnack> Indeed.
19:53:45 <Berengal> solidsnack: Without the "possible" people you wouldn't have requirements at all
19:54:09 <conal> solidsnack: proof of possibility/existence merely requires an example.  proofs of impossibility/non-existence are deeper.
19:54:11 <solidsnack> Probably shouldn't pay attention to either kind of person.
19:54:18 <copumpkin> who's excited for GHC plugins?
19:54:20 * copumpkin raises hand
19:54:27 * conal too
19:54:45 <copumpkin> there are so many things I want to fool around with in GHC's compilation pipeline
19:55:00 * sclv_ wants units!
19:55:08 <Peaker> conal: added a comment there
19:55:15 <copumpkin> :t undefined :: 1
19:55:17 <lambdabot> Unit
19:55:21 <copumpkin> there, a unit!
19:56:01 <solidsnack> I look forward to a system better than IO.
19:56:25 <copumpkin> I want IO à la carte as described in that paper (with inferrable type)
19:56:42 <solidsnack> That's not the same thing, though.
19:56:47 <copumpkin> still
19:56:55 <conal> Peaker: thx for the comment.
19:57:01 <copumpkin> it's better than the current situtation :)
19:57:04 <copumpkin> -t
19:57:15 <boblo2> what do you call the | (so i can look it up without typing | )
19:57:27 <copumpkin> boblo2: it does different things in different places
19:57:33 <copumpkin> guard
19:57:39 <Peaker> conal: have any idea if Lisp macros can define call-cc?
19:57:52 <boblo2> | (length (check (x ++ "p")) == 49 = False = mzero
19:57:52 <boblo2>         | otherwise = result [papply code2 x]
19:57:55 <conal> Peaker: sure they can.
19:57:57 <p_l> Peaker: As for "impossibility", what about condition where you might arrive at bugfree and secure code, but can rest assured that universe will find a way to screw you over?
19:58:02 <copumpkin> boblo2: that's a guard
19:58:07 <conal> Peaker: i've messed *quite* a lot with lisp macros.
19:58:08 <p_l> Peaker: Well, they are turing complete...
19:58:10 <boblo2> guard thanks
19:58:28 <conal> Peaker: you can write a whole syntactic CPS transformer as a lisp macro.
19:58:43 <Peaker> conal, p_l: Assuming the call-cc itself is a macro, but it doesn't get to transform the code called by the call-cc?
19:59:00 <conal> my first functional 3D & functional animation system was implemented as an optimizing compiler packaged as a lisp macro.
19:59:09 <Peaker> I am no expert on the exact details of how Lisp macros typically work
19:59:28 <p_l> Peaker: Why shouldn't it get possibility to transform that code?
19:59:37 <conal> Peaker: lisp macros are functions from syntax to syntax.
19:59:39 <phenrique> Algum brasileiro?
19:59:57 <Peaker> conal, p_l: btw: Turing completeness of Lisp macros does not necessarily mean that they can perform all types of desirable transformations on code (Halting problem)
20:00:08 <Peaker> conal: Yeah, but what subset of the program do they get to transform?
20:00:32 <phenrique> Hi all, Any tutorial for GHC in Eclipse?
20:00:34 <conal> Peaker: only the part they're explicitly wrapped around.
20:00:39 <Peaker> conal: I guess if you define the functions call-cc calls with some defun-callable-by-call-cc instead of defun, then you get syntax transform of the called function as well?
20:01:01 <conal> Peaker: right.  you make your own defun replacement and use it.
20:01:04 <p_l> Peaker: If you want, you can make macro that emits code that will transform code that you call
20:01:16 <conal> that's what i did.  i *loved* lisp macro hacking.
20:01:29 <conal> it's compiler writing with no syntactic hassle at all.
20:01:36 <Peaker> conal: ah - that's almost as good as ContT, but ContT allows keeping your existing code..
20:01:36 <Berengal> macro hacking does have a certain allure to it...
20:01:53 <p_l> I'm pretty sure that with cl-walker, one can modify whatever the hell one wants...
20:01:56 <Peaker> conal: (no need to change all existing defuns or such)
20:02:02 <phenrique> Hi all, Any tutorial for GHC in Eclipse?
20:02:05 <conal> Peaker: yeah.  macros allow for non-semantic transformation.  haskell doesn't.
20:02:22 <conal> that's the beauty of each.
20:02:46 <p_l> Berengal: there are reasons, though, why CL community (outside of the cll trolls) has a certain dislike of macros...
20:02:52 <conal> lisp is awesome for what it permits; haskell for what it forbids.
20:03:04 <Peaker> conal: In a non-textual language, you might want to have ASG transformers, which are probably much easier to work with than textual AST transformers
20:03:40 <p_l> Peaker: Well, Lisp is not textual (unless you count having identifiers in form of strings as textual...)
20:03:47 <conal> Peaker: could be, though AST transformers are super easy in lisp
20:03:54 <Berengal> To be fair, lisp doesn't have an AST
20:04:03 <conal> yeah.
20:04:10 <Peaker> p_l: it is limited to text, e.g: Cannot have references to other positions in the tree, so need namespaces and text atoms, instead
20:04:17 <Berengal> There's syntax, and it forms a tree, but it's in no way abstract
20:04:28 <conal> Berengal: agreed
20:04:41 <solidsnack> conal: So perhaps I have misunderstood you all this time.
20:04:50 * conal is getting misty eyed about his old lisp days
20:04:50 <Berengal> That's one part of what makes lisp so fun, and macros so easy
20:05:16 <solidsnack> What you mean by all this is you think there might be something better than IO?
20:05:25 <solidsnack> That you're not sure but you have a strong hunch?
20:05:27 <Peaker> p_l: all code is truly a graph, not a tree..  Since encoding trees in text is easy, and encoding graphs is hard, most programming languages devise the concept of text namespaces and text names to form links in the tree, so the ASG (graph) is encoded in two steps,  ASG+namespaces+names -> AST+syntax -> Text
20:05:36 <p_l> Peaker: Well, you can have those references... let's say that what you write is "textual represantation that is somewhat limited compared to language"
20:05:41 <solidsnack> In that case, it's much hard to take offense.
20:05:48 <solidsnack> s/hard/harder/
20:06:26 <p_l> Peaker: In fact, there were graph-based editors for Lisp, though I don't know how far did they went with the concept
20:07:06 <Peaker> p_l: Are there dynamic Lisp namespaces, or are namespaces basically static like Haskell, except for allowing some late binding to allow redefinitions?
20:07:09 <dibblego> what is the join . intersperse function?
20:07:12 <conal> solidsnack: what part of my perceived message changes, and how it easier to hear without taking offense?
20:07:23 <Peaker> @type intersperse
20:07:24 <lambdabot> forall a. a -> [a] -> [a]
20:07:37 <Peaker> dibblego: (join . intersperse) literally?
20:07:44 <Peaker> @type (join . intersperse)
20:07:45 <lambdabot>     Couldn't match expected type `(->) [a]' against inferred type `[]'
20:07:46 <lambdabot>     Probable cause: `intersperse' is applied to too many arguments
20:07:46 <lambdabot>     In the second argument of `(.)', namely `intersperse'
20:07:50 <solidsnack> Well, it's one thing to suggest there is definitely something better than IO and quite another to suggest that you're actively looking for it.
20:07:55 <dibblego> (join .) . intersperse
20:07:58 <aavogt> @type intercalate
20:08:00 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:08:01 <p_l> Peaker: namespaces in CL are fully dynamic
20:08:09 <conal> hurray for fmap.fmap
20:08:10 <dibblego> ah cheers
20:08:13 <Peaker> solidsnack: conal is probably at the forefront of researchers looking for that better IO alternative
20:08:23 <conal> @type (fmap.fmap) join intersperse
20:08:24 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:08:30 <conal> semantic editor combinators rule!
20:08:32 <RyanT5000> is there an ubuntu repository that has GHC 6.10.3?
20:08:34 <Peaker> p_l: so how can a static editor for a dynamic-namespace graph work?
20:08:40 <Peaker> p_l: the graph links are only known at runtime?
20:08:41 <solidsnack> Peaker: I think Lynch and Lamport are, as well.
20:08:50 <solidsnack> You guys just don't know it, yet.
20:08:57 <p_l> Peaker: Who said it was static? It ran *inside* a lisp system
20:09:03 <copumpkin> RyanT5000: most linux distros have ghc packages made by people who don't use haskell enough to understand it right :P
20:09:44 <p_l> and thus could edit data that made up a lisp program (which might be separated from the editor itself) directly, instead of feeding it a textual representation
20:09:48 <RyanT5000> copumpkin: :(
20:09:59 <solidsnack> (And neither do they, to be fair.)
20:10:08 <Peaker> p_l: well, every time a function is invoked, only then the links are formed. In that case, how do you edit that function as a graph? Do you snapshot its last execution and assume the links will remain that way?
20:10:15 <copumpkin> RyanT5000: download the binary distribution from the ghc site
20:10:34 <RyanT5000> copumpkin: yeah, i was just hoping to "set it and forget it" :P
20:10:47 <p_l> Peaker: Why links should be made only during execution? Shouldn't compiler find connections?
20:11:06 <Peaker> Someone asked me to give a Haskell presentation in a local university. I've never lectured about Haskell before. Anyone have any ideas/slides/etc?
20:11:24 <Berengal> Peaker: What kind of an audience are we talking?
20:11:25 <conal> solidsnack: i ask because i'd love to learn to express my message in a way that captures it without people taking offense (getting defensive).
20:11:35 <RyanT5000> Peaker: are you supposed to be teaching Haskell or talking about it?
20:11:35 <Peaker> p_l: if the connections can be found at compile-time, it means the connections are static. But if all the names/namespaces are dynamic, then they are not known by the compiler
20:11:35 <wli> Peaker: monad transformer stacks
20:11:36 <roconnor> Peaker: I have
20:12:18 <Peaker> Berengal, RyanT5000: Just talking about it, to a bunch of literate CS people who probably know SML, but not referential transparency, type-classes, etc
20:12:18 <roconnor> Peaker: I was asked to give a one of the talks for the last class for a programming languages course.
20:12:23 <p_l> Peaker: Have you ever worked with a modern Common Lisp system?
20:12:30 <Peaker> p_l: nope
20:12:36 <roconnor> Peaker: I have slides, but the are a little personal.  You can have/look at them if you want.
20:12:38 <Berengal> Peaker: Needs more fix, possibly even mfix :)
20:12:43 <solidsnack> conal: Maybe describe everything that would lead one not to believe what you are saying.
20:12:51 <Peaker> roconnor: sure, thanks
20:12:54 <solidsnack> Instead of leaving it to the imagination.
20:13:14 <RyanT5000> Peaker: well, you might want to mention Tim Sweeney's presentation on Haskell as a language for writing video games (Tim wrote Unreal)
20:13:40 <Peaker> wli: is that an idea of something to talk about, to people who don't know laziness, type-classes, or how to combine side-effects with referential transparency? :)
20:13:45 <RyanT5000> Peaker: that's if you have a "why haskell?" slide or something
20:13:55 <roconnor> Peaker: http://r6.ca/Haskell/FPI.pdf and http://r6.ca/Haskell/FPI.odp -- Functional Programming Imperative
20:14:00 <p_l> Peaker: I guessed so :D Basically imagine that introducing code into system in many of them includes compilation, and (compile a) requires that a is of apriopriate type...
20:14:14 <Peaker> RyanT5000: thanks
20:14:31 <conal> solidsnack: parsing trouble on my end.  would you mind trying again.
20:14:38 <RyanT5000> Peaker: www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
20:14:51 <RyanT5000> Peaker: summary here: beust.com/weblog/archives/000375.html
20:14:57 <Peaker> p_l: well, if the dynamism you talked about is pre-compilation dynamism, then its quite different to what I meant :)
20:15:00 <solidsnack> conal: Sure. There are sound reasons to reject the notion of something better than IO.
20:15:09 <solidsnack> Network communication is IO.
20:15:17 <solidsnack> There's one.
20:15:23 <wli> Peaker: More of an overarching direction. Since monad transformer stacks are what you ultimately do then the idea is to lead them toward that.
20:15:27 <p_l> Peaker: In Lisp there's no write-compile-run cycle, so it's a little weird :P
20:15:28 <conal> solidsnack: so are register and stack frame munging.
20:15:35 <solidsnack> conal: Right.
20:15:47 <solidsnack> With memory protection you have something, though.
20:15:48 <conal> solidsnack: that's why i distinguish between a language's implementation and it's semantic model.
20:16:04 <solidsnack> There's no such thing as network memory protection, though.
20:16:06 <Peaker> wli: It would probably take more than a 2 hour talk or so to get so far
20:16:16 <conal> solidsnack: no such thing ever?  or just not yet?
20:16:18 <solidsnack> At least, not unless you introduce it as an assumption.
20:16:26 <solidsnack> conal: Must at least be mentioned.
20:16:30 <Peaker> p_l: by the time a function exists, all of the links from that function are static, right?
20:16:55 <Berengal> Peaker: The type system and how it enforces discipline without the usual S&M
20:17:07 <Peaker> Berengal: any good examples of such discipline?
20:17:26 <Berengal> Peaker: No casts
20:17:33 <conal> solidsnack: sigh.  i figure if people want to open their minds they will, and if not, then no amount of spoon-feeding will get them past their attachment to impossibility.
20:17:51 <solidsnack> conal: Well, you don't understand teaching, then.
20:17:52 <p_l> Peaker: You could say that link goes through resolver, and said resolver maps Keyword -> Location
20:17:59 <wli> Peaker: Well, one may have to stop short.
20:18:11 <solidsnack> conal: If you have a message, you have to deliver it; it's not something you can do at your liesure.
20:18:11 <conal> solidsnack: sure i do.  differently from you, though, it seems. :)
20:18:21 <solidsnack> No one's going to crawl to you.
20:18:30 <conal> solidsnack: those who have ears, let them hear.
20:18:39 <conal> that's why i don't push.
20:18:52 <conal> it's not worth the effort.  others hear easily.
20:18:55 <conal> that's enough for me.
20:19:01 <p_l> Peaker: Believe me, incremental programming is probably the single weirdest thing for many newbies to Lisp
20:19:12 <solidsnack> There's a difference between not pushing and not addressing reasonable concerns.
20:19:27 <conal> solidsnack: when people ask me i tell them.
20:19:42 <Berengal> p_l: I found it to be perhaps the most sexy thing about it
20:19:52 <Berengal> Macros came close
20:19:55 <solidsnack> You also tell them when they don't ask you.
20:20:34 <conal> solidsnack: sure i can.  i prefer letting people have their own curiosity or lack of it.  not everyone is interested in everything.
20:20:34 <p_l> And I won't claim that I've mastered macros, which requires understanding of all stages code goes through, so that you know how to properly call (eval-when)
20:20:49 <Peaker> solidsnack: when you say "<solidsnack> Network communication is IO. There's one" -- you're basically saying: "I know you're saying there might be an abstraction more fitting than IO, but you are wrong, and I am right, as this *must* be IO. I won't consider any alternative."  -- That's closed-minded
20:21:08 <solidsnack> Peaker: No, I am not saying that.
20:21:11 <Peaker> p_l: Well, you could say Python is pretty similar to CL?  I've got extensive Python experience
20:21:21 <solidsnack> Peaker: I am saying, that's something about which I have real misgivings.
20:21:31 <solidsnack> Peaker: What you said is, basically, I don't have them.
20:21:41 <conal> solidsnack: it's my approach.  i get it that it's not yours, and it doesn't appeal to.  so i wouldn't try to persuade you.
20:21:43 <solidsnack> In other words, you have decided to blow me off.
20:22:06 <Peaker> solidsnack: if you have doubts about *how* it can be abstracted in different ways than IO, then say those. What you said is not that you have doubts, but that it couldn't be done, it must be IO
20:22:23 <conal> solidsnack: that's a rather loaded way to put it.  you don't have to take it personally.
20:22:23 <p_l> Peaker: Not really, though it helps that it's interactive interpreter is nearly fully capable... but it doesn't have the same "image" model, I guess
20:22:32 <p_l> Peaker: And well, it uses duck-typing :P
20:22:54 <Peaker> p_l: Doesn't Lisp also use duck-typing? At least with CLOS?
20:23:05 <conal> Peaker: yeah.  that's my take also.
20:23:09 <p_l> Peaker: No. And double NO for CLOS
20:23:40 <solidsnack> conal: Thank you for your advice.
20:23:52 <solidsnack> conal: Would you care to say, what made you think I took it personally.
20:23:53 <p_l> If what CLOS does was duck typing, then Haskell would be duck-typed too
20:23:53 <solidsnack> ?
20:23:57 <Peaker> p_l: well, I see untyped+duck-typing as nicer than untyped without duck typing, as at least you can get something like type-classes that way..
20:23:58 <conal> solidsnack: because i interpret you as certain (non-curious), i don't invest much time in trying to convey my ideas to you.  you could call that "blowing you off".  i call it investing wisely.
20:24:14 <solidsnack> conal: Oh, I was responding to Peaker.
20:24:26 <conal> solidsnack: sure.  using the loaded phrase "blow me off".
20:24:39 <conal> solidsnack: instead of a neutral/objective phrase.
20:24:58 <p_l> Peaker: CL is implicitly typed, Scheme is less strict
20:25:11 <solidsnack> conal: Well, you might have criticized my language instead of my state of mind.
20:25:21 <Peaker> p_l: CL is typed at all? Do expressions/terms/variables have types?
20:25:38 <dons> heya conal
20:25:44 <p_l> Peaker: yes, they have. It's just that by default it will try inferring types, but you can define them
20:25:51 <conal> dons: hi there.
20:26:00 <Peaker> dons: hey -- we were having trouble figuring out where the quickcheck Utils module stuff disappeared to in Quickcheck 2, do you have any idea?
20:26:06 <dons> Utils?
20:26:07 <p_l> Peaker: That's how CLOs does its method matching, after all
20:26:09 <dons> never used it.
20:26:18 <solidsnack> conal: Should you be inclined to present a model of something, which I could consider in light of my interest in networked systems, I would of course be very interested.
20:26:18 <dons> probably it got merged, or ditched
20:26:31 <Peaker> dons: Test.QuickCheck.Utils existed in qc<2 and had some interesting functions (iirc e.g testAssocativeBy)
20:26:40 <lolo> can someone tell me why the line:    code2 :: Parser         gives me "Illegal type in type expression"
20:26:42 <solidsnack> conal: I fear that things are not that definite in your work, at present.
20:27:07 <dons> solidsnack: (reading the scrollback) this might be a good time to let it go?
20:27:09 <mauke> lolo: what is Parser?
20:27:10 <solidsnack> conal: If you are measure interest by investment, however, then I have expressed interest.
20:27:25 <solidsnack> dons: Sure, I will set the matter aside.
20:27:27 <lolo> ParseLib i belive
20:27:28 <dons> thanks.
20:27:44 <Peaker> dons: who maintains quickcheck on hackage?
20:27:52 <dons> btw, in case people didn't see it: US-based hackathon coming up: http://www.haskell.org/haskellwiki/Hac_φ
20:27:57 <p_l> Peaker: (type-of "test") => (SIMPLE-ARRAY CHARACTER (4)) (car (type-of "test"))=>SIMPLE-ARRAY
20:27:57 <Peaker> (#haskell persona, that is)
20:27:58 <dons> i'm kinda excited to have a 'local' hackathon!
20:28:11 <dons> Peaker: koen claessen
20:28:17 <Peaker> p_l: that's as much typed as Python is?
20:28:52 <p_l> Peaker: More - Python doesn't check types, it checks if there's an entry in objects dictionary with apriopriate name and calls it
20:29:14 <p_l> Peaker: typing in Python afaik doesn't get outside primitive types
20:29:32 <lolo> newtype Parser a   = P (String -> [(a,String)])
20:29:49 <mauke> lolo: yeah, then Parser is not a type
20:29:53 <p_l> if an object has, I think it was "__call__" entry, you can do obj() and it will call method defined as obj.__call__()
20:30:16 <Peaker> p_l: can you come to #haskell-blah ?
20:30:24 <p_l> sure
20:30:26 <Peaker> dons: not in #haskell ?
20:30:31 <lolo> how would i go about fixing this?
20:30:35 <lolo> im very new
20:30:54 <dons> Peaker: nope. sadly.
20:31:04 <mauke> lolo: supply the missing type argument
20:31:14 <dons> lolo: i think we'll need to see a paste (e.g. hpaste.org)
20:31:38 <SamB_XP> Paste:  http://moonpatio.com ?
20:31:55 <lolo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5111#a5111
20:32:39 <mauke> lolo: Parser String
20:33:03 <mauke> what's with the nested 'do's?
20:33:09 <lolo> idk
20:33:27 <lolo> its a game im trying to solve
20:33:33 <lolo> you see any more mistakes?
20:34:39 <mauke> not mistakes per se, but there are a few unused variables
20:35:27 <lolo> so were it says codex :: parser it needs to be codex :: Parser String?
20:36:53 <mauke> yes
20:38:18 <lolo> how does line 58 look?
20:38:38 <lolo> opps i mean 111
20:39:09 <mauke> hmm... wrong :-)
20:39:19 <mauke> what is it supposed to do?
20:39:29 <lolo> what needs to be done there
20:39:46 <mauke> what is it supposed to do?
20:39:50 <lolo> it takes in a huge list of strings and finds one that matches the critera in the code
20:40:22 <mauke> ...
20:41:24 <jimmyjazz14> lambdabot: help
20:43:07 <roconnor> @help
20:43:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:44:49 <jimmyjazz14> how does one convert a Int type to a Integer type?
20:45:06 <copumpkin> fromIntegral
20:45:09 <Peaker> @hoogle Int -> Integer
20:45:09 <lambdabot> Prelude toEnum :: Enum a => Int -> a
20:45:09 <lambdabot> Data.Bits bit :: Bits a => Int -> a
20:45:09 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
20:45:36 <jimmyjazz14> cool!
20:45:39 <lolo> mauke: still looking at it?
20:45:50 <mauke> no, why?
20:46:13 <lolo> just wondering thanks for the help. really want to get this lol
20:46:16 <copumpkin> lolo: you basically told him "here's my input and it does what the code says it does"
20:48:22 <lolo> It does not do what the code says it does (right now) becouse it wont run :( it is supposed to take in a list of strings and print success along with the correct string when it is done (i think)
21:01:18 <RyanT5000> has anyone here thought about simulation datastructures in Haskell?
21:01:33 <RyanT5000> i'm writing a video game, and i'm trying to figure out how to model the simulation state
21:01:48 <wli> Priority queue?
21:02:00 <RyanT5000> i don't quite follow
21:02:05 <roconnor> State ?
21:02:12 <RyanT5000> roconnor: the state of the world
21:02:19 <roconnor> @hoogle State
21:02:20 <lambdabot> module Control.Monad.State
21:02:20 <lambdabot> Test.HUnit.Base data State
21:02:20 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
21:02:28 <RyanT5000> i.e.: "the hero's over here, there's some stuff over there"
21:02:35 <roconnor> Control.Monad.State
21:02:43 <roconnor> oh
21:02:51 <roconnor> you mean the state structure itself?
21:02:55 <RyanT5000> roconnor: i understand the State monad, but i'm referring to the states it represents
21:02:56 <RyanT5000> yeah
21:03:02 <roconnor> ah
21:03:10 <roconnor> I was thinking about it.
21:03:12 <hatds> mutable references in IO or ST ;-)
21:03:20 <RyanT5000> hatds: haha good joke
21:03:23 <RyanT5000> :P
21:03:32 <roconnor> the issues of identity were difficult.
21:03:42 <RyanT5000> roconnor: yeah, that's what i'm thinking about right now
21:04:01 <RyanT5000> right now i'm thinking that the general principle will be something like
21:04:15 <RyanT5000> getObjectState :: ID a -> StateDomain -> Maybe a
21:04:18 <RyanT5000> kinda like a Map
21:04:20 <roconnor> I was trying to think if two ships in identical conditions at the same place were interchangable.
21:04:33 <roconnor> and if so, how would I target one of them but not the other.
21:04:52 <hatds> I'm suspect of any Id type thing
21:04:53 <RyanT5000> roconnor: well, i think some explicit concept of identity is necessary
21:05:02 <RyanT5000> hatds: me too :-/
21:05:15 <roconnor> me too
21:05:15 <RyanT5000> but i can't figure out a different way to do it
21:05:33 <hatds> Once I was about to write a function GenEq :: a -> b -> Bool  (i.e. false if they have different types, otherwise true) before I learned the error of my ways
21:05:42 <hatds> *er otherwise using (==)
21:05:52 <RyanT5000> yeah
21:06:26 <hatds> what do you mean by 'simulation state'?  Is it the state of the game world or is this a meta simulation an AI is running or something?
21:06:28 <RyanT5000> but here we're talking about an explicit identity system, which is not really any different from a Map whose RHS types are not all the same
21:06:39 <RyanT5000> it's the state of the game simulation at a particular point in time
21:06:49 <RyanT5000> the simulation being the logical world
21:06:56 <RyanT5000> (as opposed to the rendering engine, or whatever)
21:07:00 <hatds> I think mutable references are a proper solution
21:07:06 <hatds> but you could use the State Monad
21:07:10 <mauke> hatds: I've written and actually used that
21:07:37 <RyanT5000> hatds: mutable references tie me to a mutable paradigm; it would probably be easier to write in C# if i were going to do that
21:07:45 <hatds> mauke: did it work well?  in my situation I realized it was suboptimal but I didn't discount it completely
21:08:02 <mauke> yes, it worked fine
21:08:10 <mauke> @let a === b = cast a == Just b
21:08:11 <lambdabot>  Defined.
21:08:14 <mauke> :t (===)
21:08:15 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
21:08:34 <RyanT5000> ah, Typeable :)
21:08:44 <copumpkin> eww
21:08:51 <copumpkin> Eq on b?
21:08:59 <mauke> > "yes" == "yes"
21:09:00 <lambdabot>   True
21:09:02 <mauke> > "yes" === "yes"
21:09:03 <lambdabot>   True
21:09:09 <mauke> > "yes" === 'n'
21:09:10 <lambdabot>   False
21:09:17 <hatds> RyanT5000: mutable references don't preclude pure code from doing the heavy lifting
21:09:24 <copumpkin> > "yes" === id
21:09:25 <lambdabot>       No instance for (Eq (a -> a))
21:09:25 <lambdabot>        arising from a use of `===' at <in...
21:09:34 <RyanT5000> hatds: that's true, but they do preclude forking your simulation
21:09:47 <RyanT5000> hatds: or saving its state to disk in any reasonable way
21:09:54 <Peaker> > id === "yes"
21:09:55 <lambdabot>   Add a type signature
21:10:02 <Peaker> > (id::a->a) === "yes"
21:10:03 <lambdabot>   Add a type signature
21:10:07 <hatds> forking the simulation for what end?
21:10:13 <RyanT5000> hatds: who knows
21:10:15 <roconnor> RyanT5000: I was thinking the "identity" of something being a big list of states that the object goes through.
21:10:24 <roconnor> RyanT5000: and tying one big knot
21:10:29 <roconnor> for the game
21:10:35 <roconnor> But I never got far enough to actually try it.
21:10:46 <RyanT5000> roconnor: how do you mean? the identity would be the history of the object?
21:11:02 <erikc> whats the topic, it sounds like i have an opinion on this!!
21:11:11 <hatds> handling the state of a game
21:11:20 <erikc> o i sure do
21:11:22 <roconnor> RyanT5000: well, you want to disgrard the notion of past and present a funture
21:11:30 <roconnor> RyanT5000: think space-time :)
21:11:40 <RyanT5000> roconnor: hmmm
21:11:48 <roconnor> the whole game is laid out at once, just existing
21:12:18 <RyanT5000> roconnor: what about player input?
21:12:31 <RyanT5000> suppose it's a real-time game
21:12:37 <roconnor> RyanT5000: it is represented by a oracle
21:12:39 <roconnor> oh
21:12:41 <roconnor> real time
21:12:42 <roconnor> sorry
21:12:46 <RyanT5000> hm
21:12:49 <roconnor> my game was turn based.
21:13:02 <RyanT5000> well, you can treat any game as turn-based internally
21:13:05 <RyanT5000> just with lots of turns
21:13:06 <RyanT5000> so that's fine
21:13:07 <roconnor> the same ideas might work but it would be harder.
21:13:17 <roconnor> again, just ideas of mine
21:13:53 <RyanT5000> it sounds interesting
21:13:54 <roconnor> each "object" is represented by a list of states it is in (or maybe state, time pairs in your case)
21:14:09 <roconnor> and the entire "game" is a set of these "objects"
21:14:11 <RyanT5000> well, i was thinking that an object could be approximately a function from time to state
21:14:17 <roconnor> and the game is parameterized by the input.
21:14:33 <RyanT5000> (i guess that's more or less equivalent to a list of pairs)
21:14:45 <roconnor> the value of various elements of the "object" depends the value of other "objects"
21:14:58 <RyanT5000> right
21:15:09 <RyanT5000> that sounds hard to debug, though
21:15:10 <roconnor> so you just write this down
21:15:25 <hatds> RyanT5000: I think the best solution is more imperative than what you are thinking
21:15:47 <RyanT5000> very easy to write noncausal code or code with circular dependencies
21:16:10 <roconnor> object1 = initalstate:(some_interaction allObject)
21:16:16 <roconnor> er
21:16:17 <roconnor> not quite that
21:16:19 <roconnor> anyhow
21:16:23 <roconnor> I haven't really tried it.
21:16:36 <roconnor> RyanT5000: true what you say about circular dependencies
21:16:40 <RyanT5000> yeah
21:16:50 <roconnor> like I said, I never tried it.  Just an idea.
21:16:54 <roconnor> could be crap
21:17:08 <RyanT5000> well, it sounds reasonable to me
21:17:10 <roconnor> and probably would be easier for a turn based game.
21:17:38 <RyanT5000> hatds: well, one way to make it more imperative might be to write a custom monad
21:17:46 <halberd> in programming we can't symbolically differentiate a function--what we symbolically differentiate is a data structure which represents a function but is not one
21:17:47 <RyanT5000> hatds: that's basically the other solution i've been thinking about
21:18:10 <hatds> RyanT5000: ultimately I think any game idea is most easily expressed as State -> State
21:18:22 <RyanT5000> hatds: that's true
21:18:32 <RyanT5000> hatds: but i need to impose a little more structure than that
21:18:33 <halberd> you can't write a higher order function that will exactly differentiate an expression like \x -> x*x + 2*x
21:18:46 <hatds> RyanT5000: sure
21:19:10 <copumpkin> :t deriv
21:19:12 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
21:19:14 <mmorrow_> halberd: differentiation is a map of functions though
21:19:21 <RyanT5000> hatds: in particular, the structure needs to allow independent object to be written and debugged relatively independently
21:19:24 <halberd> because you don't have access to the syntax tree of that function,  you can only evaluate it at a value
21:19:25 <copumpkin> > deriv (\x -> x*x + 2*x) x
21:19:26 <lambdabot>   1 * x + x * 1 + 2 * 1
21:19:38 <RyanT5000> because i need to hire people and let them work independently
21:19:49 <mmorrow_> halberd: separate of whether you want to evaluate the resulting function on any vals
21:20:21 <copumpkin> you can cheat
21:20:26 <mauke> > deriv sin x
21:20:27 <lambdabot>   1 * cos x
21:20:41 <copumpkin> halberd: it ain't pretty, but it's symbolic ;)
21:20:53 <mmorrow_> (differentiation being a linear map of vector spaces (where the "vectors" are functions))
21:21:39 <halberd> copumpkin: I'm unfamiliar with how deriv works, what's the hook?  could you write the function deriv in haskell?
21:21:46 <copumpkin> that is written in haskell :)
21:21:53 <copumpkin> without even looking at the AST
21:22:02 <hatds> RyanT5000: disconnected myself for a sec there :)
21:22:08 <RyanT5000> hatds: np
21:22:13 <halberd> could I see the source for deriv then?
21:22:15 <roconnor> > reduce $ deriv sin x
21:22:16 <lambdabot>   1 * cos x
21:22:17 <copumpkin> > scanl1 (+) [1..5] :: [Expr]
21:22:18 <lambdabot>   [1,1 + 2,1 + 2 + 3,1 + 2 + 3 + 4,1 + 2 + 3 + 4 + 5]
21:22:26 <copumpkin> @hackage numbers
21:22:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
21:22:31 <RyanT5000> all i said was that i need to ensure that several people on a team can work within this object system without getting in each others' ways
21:22:52 <copumpkin> http://hackage.haskell.org/packages/archive/numbers/2009.5.20.1/doc/html/src/Data-Number-Dif.html#deriv
21:23:02 <mmorrow> halberd: it uses typeclass trickery, but the basic concept could be implemented separately (w/ a parser for function reps given as String)
21:23:06 <erikc> is it singlethreaded?
21:23:22 <mauke> http://okmij.org/ftp/Computation/Generative.html#diff-typeclass
21:24:14 <halberd> but that's my point mmorrow that you have to access the representation, which is usualy not available... unles you use typeclass trickery
21:24:20 <hatds> RyanT5000: I think all that is needed is an abstraction type
21:24:26 <halberd> I'm reading how that works
21:24:32 <RyanT5000> hatds: what do you mean by that?
21:24:43 <copumpkin> halberd: it's not using anything untypical though :)
21:24:54 <halberd> differentiating the _function_ \x -> x*x + 2*x is not the same as differentiating the _string_ "\x -> x*x + 2*x"
21:25:04 <halberd> someone differentiating the string has an easier time
21:25:19 <copumpkin> yeah, and that package isn't touching the string
21:25:19 <hatds> RyanT5000: each disparate object of type a has to provide a function a -> B.  Where B is a type representing abstract game objects
21:25:27 <halberd> yes I know, it's doing something funny
21:25:30 <mmorrow> halberd: well without being able to view what you're working with, it would have to be magic?
21:25:47 <mmorrow> oh, i see how you mean
21:25:50 <hatds> RyanT5000: the abstractions could be hierarchical as well
21:26:20 <mmorrow> halberd: sure, given the haskell lang (as implem by ghc) you need typeclass hackery or a QuasiQuoter
21:26:23 <RyanT5000> hatds: yeah, that's true
21:26:35 <RyanT5000> hatds: but i think we need some way of figuring out how objects will interact
21:26:37 <mmorrow> (if you don't want to just give the rep a a String that is)
21:26:44 <mmorrow> *..as a ..
21:26:51 <roconnor> RyanT5000: be sure to check out data.accessor
21:27:01 <hatds> RyanT5000: that is specified by the type B
21:27:33 <erikc> RyanT5000: the approach i've taken (in C and Lua) is single-threaded message passing concurrency between actors (win32-style), the game state is stored relationally, separately from the actor code
21:27:59 <RyanT5000> erikc: what sorts of things were actors?
21:28:07 <RyanT5000> roconnor: that looks really useful
21:28:12 <erikc> after the messages for a frame have been dispatched, bulk updating (physics, collisions, etc) and rendering runs in parallel using the frozen data
21:28:26 <erikc> those systems generate messages on lockless queues that feed back to the actors
21:28:31 <roconnor> RyanT5000: it is so useful, it should be part of the Haskell Platform! :)
21:28:40 <RyanT5000> roconnor: perhaps :)
21:28:47 <hatds> I think the interaction between actors will be dependent on what game it is
21:28:48 <mmorrow> but i think the particulars (wrt how it's accomplished in whatever language) of any given implem of symbolic differentiation is a separate topic than what you're really doing
21:29:03 <roconnor> RyanT5000: the State Monad stuff is exactly what you want.
21:29:05 <hatds> interaction in an RTS would be much different than a 2D sidescroller
21:29:13 <copumpkin> @let loeb x = fmap ($ loeb x) x
21:29:14 <lambdabot>  Defined.
21:29:17 <copumpkin> :t loeb
21:29:19 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
21:29:49 <copumpkin> > loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
21:29:50 <lambdabot>   [17,3,20,40,6,17]
21:30:03 <erikc> RyanT5000: characters, enemies, props, cameras, grenades, rockets, dropped weapons
21:30:12 <RyanT5000> erikc: ah, i see
21:30:20 <RyanT5000> erikc: and what sorts of things were considered "state"?
21:30:41 <roconnor> copumpkin: who was that comment for?
21:30:45 <erikc> the rule of thumb is anything that we want scripters/designers to be able to create/manipulate is done in actor land
21:30:47 <copumpkin> no one
21:30:58 <copumpkin> myself/anyone?
21:30:59 <erikc> once we have a feature figured out, we can always move it to the backend for perf
21:31:03 <RyanT5000> erikc: ah, makes sense
21:31:13 <erikc> the tough part is you want it dynamic early on to experiment with the gameplay
21:31:15 <RyanT5000> erikc: did you do this in Haskell?
21:31:18 <mmorrow> @pl fix (\k a -> fmap ($ k a) a)
21:31:19 <lambdabot> fix (fmap . flip id =<<)
21:31:27 <mmorrow> @type fix (fmap . flip id =<<)
21:31:29 <lambdabot> forall (f :: * -> *) c. (Functor f) => f (f c -> c) -> f c
21:31:35 <copumpkin> lol
21:31:42 <mmorrow> weee
21:31:45 <copumpkin> it definitely fels like a fixworthy function
21:31:52 <erikc> implemented a poor man's erlang in C++ and then message pumps run in either C++ or Lua
21:32:27 <RyanT5000> erikc: ah, right, i remember you telling me about that the other day
21:33:07 <RyanT5000> erikc: so the way you prevented cyclic references was by means of a delay in message passing?
21:33:22 <erikc> the actors are stateless, all the data is stored separately so it can be serialized/snapshotted
21:33:39 <erikc> data hiding is a headache in games cause there's a tendency to come up with game rules that throw the data hiding out the window anyway
21:33:54 <erikc> you want to be able to crawl all over the data
21:33:59 <RyanT5000> erikc: hm, yeah
21:34:07 <erikc> yea, frame delay for cyclic dependencies
21:35:17 <RyanT5000> erikc: the data hiding thing is an interesting problem
21:35:29 * roconnor not sure I understand what erikc is describing, but it sounds cool.
21:35:45 <wy> aloha
21:35:51 <erikc> im also storing the data relationally so that data that is operated on together is packed together in memory
21:36:03 <erikc> so i can dma it to the spus/gpu
21:36:05 <RyanT5000> erikc: right, that seems good for performance
21:36:35 <wy> Is there a reason the patterns in function definitions are not lazy?
21:37:09 <hatds> essentially, the haskell core has two constructions: let (lazy) and case (strict)
21:37:29 <erikc> game logic shouldnt affect performance much and is hopelessly intractable to parallelize (short of STM, but then you lose deterniminism)
21:37:58 <RyanT5000> erikc: what about parallel Haskell?
21:38:14 <wy> @users
21:38:15 <lambdabot> Maximum users seen in #haskell: 658, currently: 581 (88.3%), active: 14 (2.4%)
21:38:17 <RyanT5000> erikc: i guess spark creation costs could outstrip their value
21:38:21 <erikc> you mean software transactional memory?
21:38:30 <hatds> wy: function definitions are considered part of case expressions, you can use "~" to make a pattern lazy and irrefutable
21:38:32 <copumpkin> or DPH?
21:38:32 <erikc> or data parallelism?
21:38:44 <RyanT5000> erikc: data parallelism
21:39:00 <erikc> you definitely want data parallelism on the engine backend for the number crunching
21:39:23 <wy> hatds: but why haven't them an implicit "~" prepended?
21:39:25 <RyanT5000> http://www.macs.hw.ac.uk/~dsg/gph/
21:39:34 <RyanT5000> erikc: i'm talking about that; par and seq
21:39:40 <hatds> are game algorithms outside of GPU stuff really suitable for data parallelism?
21:39:52 <RyanT5000> i'm not sure; i haven't really looked into it
21:40:13 <erikc> hatds: yup, physics, fluid simulation ai pathfinding
21:40:29 <copumpkin> RyanT5000: that's all built into GHC now
21:40:38 <xmonader> I'm facing this http://pastebin.com/d64840d0a while installing hs-twitter any help ?
21:40:44 <erikc> generating potential fields for crowd pathfinding (though thats more wavefront parallelism)
21:40:45 <RyanT5000> copumpkin: that's cool
21:40:57 <copumpkin> RyanT5000: Control.Parallel(.Strategies)
21:41:03 <hatds> wy: ~ also makes the pattern irrefutable, so f ~[x] = ...  will result in a error if the input was actually [] *and* f tries to use the value x
21:41:50 <copumpkin> just need to compile with the threaded RTS and run your program with +RTS -N x where x is the number of native threads you want to run (assuming you aren't running the latest development GHC, which can detect automatically)
21:41:55 <hatds> wy: there was discussion in the creation of haskell whether to make patterns like tuples strict or lazy, since pattern matching on a tuple type cannot every fail in a well typed program (it can only succeed or diverge)
21:42:04 <RyanT5000> erikc: so, if we're only concerned with usability and maintainability, how would it be to have public and private state for objects?
21:42:50 <RyanT5000> erikc: if data needed to be looked through, it would need to be explicitly publicized
21:42:54 <erikc> right
21:43:23 <erikc> that works, you'll need a way to get at all the objects of particular classes
21:43:42 <RyanT5000> erikc: we could potentially have index actors, which are basically actors who can access other actors' state
21:43:54 <RyanT5000> erikc: the index dependency graph would have to be acyclic
21:44:09 <RyanT5000> erikc: which would allow indices to be updated in the same frame as their constituents are changed
21:44:28 <halberd> okay
21:44:44 <wy> > let [x] = [] in x
21:44:45 <lambdabot>   * Exception: /tmp/8222069046277313235:71:36-43: Irrefutable pattern failed ...
21:44:48 <RyanT5000> erikc: and, of course, actors would have access to *all* actors' states from the previous frame
21:44:56 <halberd> so the deriv implementation is amazing, but it still doesn't exactly take the derivative of a function
21:44:57 <erikc> right
21:45:04 <RyanT5000> public state, that is
21:45:10 <halberd> well, not of a function from real numbers to real numbers
21:45:14 <RyanT5000> is a messaging system still needed?
21:45:20 <copumpkin> halberd: why not?
21:45:25 <RyanT5000> might be convenient, i suppose
21:45:43 <copumpkin> halberd: http://conal.net/blog/posts/what-is-automatic-differentiation-and-why-does-it-work/
21:45:46 <Ycros> RyanT5000: I'm interested in what you come up with
21:45:51 <copumpkin> http://en.wikipedia.org/wiki/Automatic_differentiation
21:45:58 <erikc> i went with messaging cause a major goal is to add gameplay behaviors/entities at runtime
21:46:02 <halberd> it takes the derivative of a function (Num a, Num b) => Dif a -> Dif b, not of a function (Num a, Num b) => a -> b
21:46:10 <RyanT5000> Ycros: cool; i'm sure i'll be in this chatroom asking questions frequently
21:46:26 <halberd> it only appears to do the latter, because of the operator overloading
21:46:40 <RyanT5000> erikc: ah, that makes sense
21:46:50 <halberd> so you get fooled into thinking the function is a -> b, when it's really Dif a -> Dif b
21:46:54 <copumpkin> halberd: sure, but you can lift a function into Dif easily
21:46:55 <RyanT5000> erikc: erlang is on the very-short-list of languages i need to learn
21:47:13 <mauke> halberd: Dif a is a number
21:47:19 <copumpkin> any function
21:47:21 <wy> have you heard of a lecture topic "Lambda the Ultimate Calculus"?
21:47:23 <copumpkin> involving nubmers :)
21:47:35 <copumpkin> halberd: check out conal's blog post I linked to
21:47:55 <gwern> > 1130 - 434
21:47:56 <lambdabot>   696
21:48:06 <roconnor> copumpkin: you can't lift any function in any meaningful way
21:48:13 <erikc> RyanT5000: i view a game engine as the operating system and actors as the processes
21:48:28 <halberd> copumpkin you could write a function converttoDif (Num a, Num b) => (a -> b) -> Dif a -> Dif b?
21:48:38 <RyanT5000> erikc: yeah, that sounds about right
21:48:40 <copumpkin> roconnor: well, any function of one numerical parameter to the same numerical type, I guess
21:48:45 <copumpkin> or is that not true either?
21:48:48 <roconnor> no
21:49:01 <roconnor> you can only properly lift it by providing the derivative as well
21:49:16 <mauke> halberd: that looks like id
21:49:18 <roconnor> you can improperly lift it, and get a function with a meaningless deriviatve
21:49:35 <erikc> if i had the freedom to use any language, i'd likely combine C for numerical kernels, Haskell for the engine and Factor for the gameplay level code
21:49:50 <roconnor> halberd: no such function exists that does what you would want it to do.
21:49:59 <roconnor> for converttoDif
21:50:16 <mauke> oh yeah, wrong rank
21:50:23 <wy> hatds: got it. So case is the place we do branching, so we actually need the values there
21:50:26 <copumpkin> what kind of meaninglessness would the derivative be?
21:50:33 <RyanT5000> erikc: how do you deal with things like collision detection, which create mutual restrictions on actors' behavior?
21:50:38 <hatds> wy: yea
21:50:40 <roconnor> copumpkin: always 0 or always 1, or really anything you want.
21:50:48 <copumpkin> ah
21:51:16 <hatds> collision detection has well studied algorithms
21:51:16 <copumpkin> I guess I can definitely think of functions that wouldn't work
21:51:19 <halberd> so even though converttoDif is a function that doesn't do anything clearly uncomputable, it can't be written in Haskell
21:51:27 <wy> hatds: What's the other places where we need to force the values?
21:51:44 <hatds> you just need to specify what you want to do when certain collisions are found
21:51:45 <copumpkin> halberd: well, a -> b might not be continuous, for example
21:51:52 <roconnor> halberd: um, what would you expect if you give it a function that is differentiable nowhere?
21:52:04 <roconnor> halberd: does that count as uncomputable?
21:52:34 <halberd> well you could probably extend Dif to deal with that case with Nan
21:52:40 <copumpkin> it's not just NaN
21:53:03 <copumpkin> just a curve with a kink in it, for example
21:53:12 <hatds> wy: I'm not familiar with the fine differences between haskell core and regular haskell, but I think case expressions are where either all or most evaluation happens
21:53:24 <hatds> maybe someone else knows for sure?
21:53:30 <mauke> > deriv tan x
21:53:31 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
21:53:34 <halberd> the derivative could still be reported as NaN in that case, or Undefined if you prefer
21:54:02 <halberd> that would be acceptable... but even with that you still couldn't write converttoDif
21:54:04 * roconnor tries to think of a case where the derivative is uncomputable.
21:54:08 <wy> halberd: So I guess lazy patterns can be only used in definitions with only one pattern?
21:54:09 <roconnor> I can probably make one up
21:54:29 <hatds> not necessarily
21:54:33 <erikc> RyanT5000: we use the rigid body step in the backend (we use havok) to solve collisions
21:54:41 <hatds> the first pattern could be non-lazy
21:54:57 <hatds> and to make things more complicated you can have a lazy pattern inside a non-lazy one
21:55:13 <Saizan> but then the costructor will be forced (assuming we're not talking about nested patterns)
21:55:22 <halberd> that's a point roconnor
21:55:50 <erikc> RyanT5000: for things like actors making choices based on nearby items, (or say, oncoming objects), we have a hidden physics volume that detects intersections on the physics step and pipes messages back to the actors
21:56:06 <copumpkin> http://pirate.shu.edu/projects/reals/cont/fp_weier.html
21:56:10 <RyanT5000> erikc: ah, interesting
21:56:24 <RyanT5000> erikc: so, i take it the physics system is more or less independent of the actors
21:56:40 <halberd> nowhere differentiable != derivative is uncomputable... there are functions whose derivative is uncomputable though
21:56:41 <RyanT5000> erikc: "of the actor system", i should say
21:56:53 <erikc> yep, totally separate
21:57:29 <copumpkin> halberd: well, functions that are computable but their derivatives aren't?
21:58:04 <halberd> I don't know about that copumpkin but if a function is uncomputable yet differentiable, its derivative is uncomputable
21:58:08 <mgsloan> the derivative of id is 1!
21:58:18 <RyanT5000> erikc: that's good; have you ever worked with Unity? it's the only engine i've ever had the 'pleasure' of dealing with
21:58:42 <sjanssen> hmm, hackathon in Philadelphia, eh?
21:58:45 * sjanssen google maps it
21:59:08 <erikc> i've played with it, but not enough to comment, i bet it demos well to C-level executives though with the lovely gui :)
21:59:24 <erikc> their use of Mono is smart
21:59:35 <hatds> I'll be there, anyone else going?
21:59:38 <copumpkin> I'd stay away, don't wanna catch that shit
21:59:46 <wy> got it
21:59:48 <RyanT5000> erikc: it demos *quite* well to C-levels
22:00:00 <halberd> Properties of Functions are in general uncomputable
22:00:12 <wy> still haven't figured out why strict flag can be only used on data constructors and not functions
22:00:42 <halberd> i.e. there is no function which can take the source code listing for another function f, and determine whether or not f is a differentiable function with derivative f'(x)=2x
22:01:00 <copumpkin> well yeah
22:01:03 <halberd> as long as f is written in a Turing-complete language
22:01:04 <RyanT5000> erikc: (one of) the problem(s) is, Unity conflates actors with physics objects
22:01:08 <sjanssen> hatds: I'm considering it, depends on whether I want to travel halfway across the country
22:01:11 <hatds> wy: perhaps you want bang patterns? http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
22:03:05 <RyanT5000> erikc: i really like this idea of conceiving of the game engine as an OS; i've put a lot of thought into OS design before, so it's a really useful analogy
22:03:09 <wy> yes.
22:03:45 <wy> It looks good and makes the things more uniform. Just hope we never need to write those bang flags
22:03:49 <RyanT5000> erikc: what makes Factor a particularly good language for level scripting?
22:04:10 <wy> Can the strict flags all be inserted by strictness analysis?
22:04:20 <twb> Zow, someone's recommending Factor?
22:04:50 <gwern> wy: well, someone wrote a GA program for inserting bangs and seeing whether performance was helped...
22:05:35 <erikc> RyanT5000: runtime code replacement with jitting, incremental generational gc, image-based (save/restoring the gc heap, including closures), code-as-data/data-as-code dualism (your 'data files' can just be scripts, no need for data file parsers, use the language)
22:06:07 <twb> I suppose it depends what your "primary" language is.
22:06:17 <hatds> imho problems with strictness are problems with not understand your code, and it is always worth it to understand it clearly and have very few annotations than to use scatter shot annotations.
22:06:19 <RyanT5000> erikc: ah, the image-based part is something i've been wanting for quite some time
22:07:00 <erikc> RyanT5000: naughty dog games uses plt scheme for their scripting and state machine descriptions in uncharted, they had a good gdc presentation this year
22:07:45 <twb> Naught Dog used an in-houes CL dialect called something like "GOAL" for a while...
22:07:50 <conal> halberd: if you do check out & like my auto-diff posts, you might also like my upcoming icfp paper, "beautiful differentiation"
22:08:12 <erikc> twb: yep, till sony bought them and 'asked' them to build more tech in c++ to share with other studios
22:08:26 <twb> erikc: ah, is that how it went?
22:08:45 <twb> erikc: I heard that the one guy who understood how the GOAL compiler worked, quit/died/something
22:08:46 <erikc> yea, their data build pipeline is still largely lisp
22:09:01 <QtPlaty[HireMe]> IndentParser doesn't seem to be compatable with the current parsec
22:09:14 <erikc> he left as well, yes (Andy Gavin), he went and made a webapp and sold it so fox interactive for 100 mil :)
22:09:17 <halberd> conal: I got the idea of how it works
22:09:50 <halberd> I did check out your posts and also the source code for the module
22:10:08 <RyanT5000> are there any other languages that let you serialize closures?
22:10:19 <wy> gwern: does GA mean genetic algorithm?
22:10:26 <erikc> image-based ones, the lisps, smalltalks
22:10:35 <RyanT5000> i'm specifically interested in serializing closures *without* serializing an image of the entire program
22:11:31 <halberd> python does it ryan
22:12:07 <hatds> I don't think the question makes sense with first class closures
22:12:08 <RyanT5000> halberd: interesting; how would i search for that? pickling?
22:12:16 <RyanT5000> hatds: really?
22:12:33 <hatds> you could always have an abstract function type that is serializable
22:12:58 <halberd> oh wait
22:13:03 <halberd> maybe Python doesn't do it
22:13:04 <erikc> you'd have to investigate but if you can serialize the image, you can probably serialize a portion of the object graph, provided the roots, it's the same problem
22:13:18 <RyanT5000> erikc: that's what i was thinking
22:13:33 <RyanT5000> erikc: but i've yet to see a language that does it
22:13:55 <hatds> probably because doing so isn't getting you very much benefit
22:14:19 <halberd> yeah python only does it for named functions
22:14:57 <RyanT5000> hatds: i think there might be some benefits
22:15:13 <RyanT5000> hatds: at the very least, it means that you can make *every* value in your language serializable
22:15:31 <RyanT5000> hatds: which means that the programmer no longer has to worry about whether a particular datastructure is serializable or not
22:15:42 <hatds> RyanT5000: I doubt it would be suitable for game saves
22:15:49 <hatds> RyanT5000: in a game you really want your serialization to be aware of what it is serializing
22:15:59 <RyanT5000> hatds: why's that? versioning?
22:16:27 <wy> maybe using a "deriving Serializable" ?
22:16:31 <hatds> RyanT5000: I just mean for efficiency
22:16:47 <wy> otherwise roll you own ...
22:17:00 <erikc> RyanT5000: factor has the serialize vocabulary which works on everything except continuations
22:17:02 <RyanT5000> wy: but that means all the datastructures you *use* also need to derive it
22:17:31 <RyanT5000> hatds: yeah, although i think it could be made reasonably efficient
22:17:33 <wy> RyanT5000: As long as they have the method serialize ?
22:18:03 <RyanT5000> wy: right, but i want something lower-level than that, so that we can guarantee, upfront, that *everything* is serializable in the whole language
22:18:12 <Saizan> ocaml can serialize continuations, iirc
22:18:55 <wy> RyanT5000: You could ask the compiler to add Serializable to every data type
22:19:08 <RyanT5000> wy: how?
22:19:17 <wy> then override it only for efficiency purposes
22:19:27 <RyanT5000> Saizan: very interesting
22:19:46 <wy> RyanT5000: use metaprogramming probably
22:19:57 <Saizan> wy: yes, the point is finding a compiler/runtime system that supports it for everything, like functions etc.
22:19:58 <erikc> but yea, where i work we just manually serialize a subset of the relations (and since the relations are packed in memory, it is quite fast)
22:20:36 <RyanT5000> erikc: yeah, that makes sense; i'm not at the stage of worrying about efficiency yet, though
22:20:53 <RyanT5000> erikc: right now, i'm trying to figure out what my ideal semantic model would be
22:20:57 <wy> Saizan: even for monadic ones ?
22:20:58 <erikc> yea
22:21:04 <RyanT5000> later, i'll make concessions for efficiency purposes
22:21:16 <Saizan> wy: yeah
22:21:27 <RyanT5000> (your approach does sound like a good one, though)
22:21:43 <Peaker> Its weird that a game developer (Sweenie) is a theory guy. In my mind, they're all C++-heads :)
22:21:46 <Saizan> wy: i guess some things like file handles are not serializable by principle, however
22:21:54 <wy> Saizan: good idea
22:22:25 <wy> Saizan: why aren't they?
22:22:41 <RyanT5000> Peaker: well, i'm a theory guy becoming a game guy :)
22:23:01 <RyanT5000> really, very few people bridge the theory/practice gap
22:23:12 <Peaker> RyanT5000: he's not just an ordinary game guy, he supposedly wrote Unreal Tournament
22:23:16 <Saizan> wy: an Handle is a bit like a pointer to a resource, and that resource might not be there or be in the same state when you deserialize
22:23:21 <erikc> Peaker: christer ericcson (tech director on god of war) is also a big theory guy (he has a big 'please game devs learn some other languages' rant) http://realtimecollisiondetection.net/blog/
22:23:21 <Jedai> Didn't Clean allows to serialize closures ?
22:23:24 <twb> academic vs. pragmatic?
22:23:57 <wy> Saizan: we could force them to be in the same state
22:24:06 <IntergalacticOwl> i'm a game kid becoming a theory kid
22:24:57 <wy> Saizan: Once the object with the reference to the resource is sent, we must establish the channel over the network to synchronize the state
22:25:08 <Jedai> wy: To do that we could need a copy of the file itself though...
22:25:30 <Jedai> In case it changed or something
22:25:47 <Saizan> wy: suppose the Handle comes from a Socket, how do you restore that if the other machine is down?
22:25:47 <wy> Jedai: you just need to send the changes
22:26:12 <Saizan> wy: or if it was a Socket initiated by the other machine (i.e. we're the server)
22:26:43 <Jedai> wy: I'm not following you, how do you serialize changes that aren't there when you do the serializing ?
22:27:01 <wy> Saizan: it can't be absolutely safe. Just let's pray for the best ;)
22:27:30 <Saizan> yeah, just don't serialize Handle's :)
22:27:35 <erikc> RyanT5000: the os analogy is good cause it separates the engineers (engine) from the creatives (game), the engine is a fairly known quantity, the game is going to change a lot, so theres a static/dynamic fight there
22:27:36 <Peaker> erikc: cool
22:27:43 <Saizan> at best you can serialize a FilePath, or an URI
22:27:51 <erikc> a coworker of mine is a big propodent of gradual typing cause of that
22:28:08 <erikc> as the game settles, you want to type it and push it down into higher perf land
22:28:23 <RyanT5000> erikc: yeah, that makes a lot of sense
22:28:28 <Jedai> Saizan: eventually with a position in the file and a signature for coherence purpose
22:28:37 <RyanT5000> erikc: i don't think there's any language out there whose type system supports such a thing very well
22:29:36 <mmorrow> Saizan: with pointers though, you can just map them to unique ids you create as you serialize (i'm assuming you are slurping the targets of all pointers here too)
22:30:07 <Saizan> mmorrow: "pointer" was only an analogy
22:30:09 <mmorrow> Saizan: with handles/scokets it's a whole different story, since you don't have access (probably) to the other side
22:30:23 <Saizan> the problem is internal vs. external resource
22:30:33 <mmorrow> that's a good way to say it
22:32:42 <xmonader> I'm facing this http://pastebin.com/d64840d0a while installing hs-twitter any help ?
22:34:11 <wy> The implementation of IO monad is a little weird, why are there two other things beside the value? GHC.Prim.State# and GHC.Prim.RealWorld?
22:34:50 <hatds> I only care to understand it from the high level
22:34:54 <Peaker> erikc: I disagree with his rant (and tone!) about patterns for example..
22:35:19 <Peaker> Some patterns are language-specific, some are almost as "eternal" as data structures/algorithms
22:35:45 <hatds> the implementation as I understand it is basically a trick to project sequencing (in the sense of time and effects) into a data dependency
22:36:08 <Peaker> (The "Strategy" pattern, of passing dictionaries/functions around to higher-order functions, where the passed functions represent what you want to do. This "pattern" is implemented by type-classes or function records in Haskell, but its the same pattern from the group of four (?) book
22:36:30 <Saizan> xmonader: it probably depends on an older version of json without specifying it in the .cabal file
22:37:00 <Peaker> what's gradual typing?
22:37:14 <erikc> http://www.google.ca/url?sa=t&source=web&ct=res&cd=3&url=http%3A%2F%2Fwww.cs.colorado.edu%2F~siek%2Fpubs%2Fpubs%2F2006%2Fsiek06%3A_gradual.pdf&ei=QzgWSrWPAov8swPhtOHZCA&usg=AFQjCNF2DrY06Kdj0CMQYstzgygzkhrLSw&sig2=1ZZQN68JBkkL67oy3GVTBw
22:37:18 <erikc> err
22:37:22 <mmorrow> Jedai: yeah, clean's rts supports both serializing and reading back in polymorphically typed data
22:37:31 <erikc> google 'gradual typing' there are some papers
22:37:43 <xmonader> Saizan, sounds so  ''build-depends:   base, HTTP >= 4000.0.1, network, utf8-string, json, mime, old-locale, old-time, random
22:38:22 <wy> Peaker: the only way to learn the patterns is to forget them :)
22:38:34 <Peaker> wli: what do you mean?
22:39:51 <Jedai> wy: It seems to me that GHC.Prim.State# is the primitive type constructor behind both IO and ST and GHC.Prim.RealWorld is the state type for IO
22:40:35 <Peaker> I remember reading luqui's realization a few months ago -- "why not put partiality in a monad?" or something like that.  I see now that it was in Sweene's slides that I saw so long ago (but did not have enough background to understand): "Why not go one step further and define partiality as an effect, ..."
22:40:50 <Jedai> mmorrow: Thanks, I vaguely remembered that that was one of the real advantage of Clean over Haskell
22:41:35 <mmorrow> Jedai: this can totally be done in haskell too.. it's one thing i want to do actually
22:42:11 <Saizan> xmonader: use --constraint="json < 4", as it appears JSRational constructor changed in version 0.4.1
22:42:15 <mmorrow> you just just serialize closures directly like vacuum does, and then going the other way you'd need to write some rts C code
22:42:19 <Jedai> mmorrow: Well theoretically, but Clean had a clean implementation integrated with its compuler
22:42:28 <mmorrow> Jedai: http://moonpatio.com/repos/MISC/Clean/dynamic/dynamics/
22:42:30 <PetRat> What's the precedence of the double colon operator relative to $? at gchi typing :info :: gives an error?
22:42:32 <wy> Peaker: were you reading some blog post? I don't know the context
22:42:41 <mmorrow> Jedai: a lot of it is hand-coded asm
22:42:41 <PetRat> :info ::
22:43:08 <hatds> :: extends as far as possible iirc
22:43:14 <xmonader> Saizan, many thanks i'll try it and get back to you
22:43:27 <Peaker> wy: reading www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
22:43:29 <PetRat> hatds: I don't understand what you mean
22:43:39 <Peaker> hmm -- what's "lenient evaluation"?
22:44:05 <PetRat> let me give an example: can I write "fromSql $ head $ head $ rows :: Int" ?
22:44:11 <Peaker> erikc: can you describe gradual typing in a sentence? :)
22:44:21 <mmorrow> Jedai: err, well i should have said that clean has _dynamics_ where you can put in and recover polymorphically-typed data
22:44:25 <Peaker> PetRat: fromSql . head . head $ rows
22:44:38 <mmorrow> you can probably serialize that too i'd guess
22:44:47 <Jedai> Peaker: wasn't it some kind of speculative evaluation ?
22:44:50 <Cale> PetRat: More toward your question, :: gobbles up as much as it can
22:45:04 <wy> :info ($!)
22:45:20 <Cale> That is, it scopes over the largest possible preceding subexpression.
22:45:38 <mmorrow> (i'm more interested in serializing/reifying which retains all sharing, and so can serialize "infinite data" which is just some tiny graph that's only infinite if you consider it to be a tree)
22:45:45 <PetRat> Cale: I think my expression was fine then, in terms of getting the right type out of fromSql.
22:45:49 <Cale> yeah
22:45:59 <mmorrow> , vaccum (fix (\x -> 0 : x)) {- my favorite -}
22:46:00 <lunabot>  luna: Not in scope: `vaccum'
22:46:06 <mmorrow> , vacuum (fix (\x -> 0 : x)) {- my favorite -}
22:46:08 <lunabot>  [(0,[1,0]),(1,[])]
22:46:18 <Cale> (though take Peaker's advice and try to get in the habit of using composition instead of repeated $)
22:46:59 <mmorrow> and also, the serialization function can be (forall a. a -> ByteString)
22:47:06 <Cale> The current associativity of $ is a bit of a mistake, and there are benefits to using composition instead.
22:47:27 <xmonader> Saizan, http://pastebin.com/d4c53c5b4
22:47:38 <PetRat> Cale: OK
22:47:38 <Jedai> mmorrow: That would be awesome to have anyway :)
22:47:43 <mmorrow> (deserialization though is more limited since haskell doesn't have dependent types or a polymorphic typeable)
22:47:47 <erikc> Peaker: basically, dynamic by default, and then allow type annotations / infer types as much as possible
22:47:51 <mmorrow> Jedai: totally!
22:48:19 <erikc> and where there are type annotations, provide type checking
22:48:31 <Peaker> erikc: ah, limited type inference, I hate that..
22:49:09 <Cale> PetRat: Since f . (g . h) = (f . g) . h, expressions written with composition are easier to take apart and transform, and it tends to help one's thought process to be thinking of functions being stuck end to end.
22:49:26 <RyanT5000> Peaker: just think of it like a type system that doesn't finish its work until runtime :P
22:49:47 <wy> Peaker: haven't found anything to do with strategy pattern
22:49:48 <erikc> it is ideal for situations where you dont know what you want to make, but when you figure it out, you clamp it down by adding type annotations (and get the associated safety/perf benefits)
22:49:49 <Jedai> RyanT5000: You mean a dynamic type system...
22:49:51 <Cale> (whereas if you have something like f $ g $ h $ x, the substrings like g $ h probably aren't even well-typed)
22:49:52 <Peaker> RyanT5000: its still untyped, afaic
22:50:03 <RyanT5000> Jedai: no, it *starts* its work at compile-time :P
22:50:06 <Peaker> wy: no no, that was from the rant of this other dude
22:50:24 <erikc> which describes game dev in a nutshell, since 'a fun program' is a nebulous requirement :)
22:50:32 <Peaker> erikc: its weird to me -- I think its easier to specify the type of what you want to make, than the implementaiton
22:50:54 <RyanT5000> well, there's a lot of info in the type system that isn't necessary
22:51:24 <wy> Peaker: I'd like to see the rant
22:51:25 <RyanT5000> for example, i frequently know that i want a datatype that associates keys with values
22:51:44 <RyanT5000> but i don't always know whether i want it to be a function, a list of pairs, a Map, or an array
22:52:02 <Peaker> wy: http://realtimecollisiondetection.net/blog/?p=81
22:52:03 <Jedai> RyanT5000: You could use the typeclasses from Edison
22:52:28 <RyanT5000> Jedai: i have; they're pretty good, but they're nowhere near pervasive enough to deal with this problem in general
22:52:37 <RyanT5000> (nor comprehensive enough)
22:52:40 <Peaker> RyanT5000: there are semantic differences between those types
22:52:51 <Peaker> RyanT5000: if you don't know what semantics you want - how can you implement anything?
22:53:15 <erikc> Peaker: and thats why game dev is such a mess :)
22:53:17 <RyanT5000> Peaker: that's true; i chose a bad example
22:53:49 <RyanT5000> Peaker: suppose i add a default response to the last 3 of them
22:54:07 <RyanT5000> Peaker: (used for not-present or out-of-bounds inputs)
22:54:32 * Peaker has to go
22:54:42 <mmorrow> mempty?
22:54:47 <RyanT5000> alright; good luck on the presentation
22:55:13 <RyanT5000> mmorrow: sure, the point is that i have 4 ways of representing the same idea
22:55:26 <RyanT5000> mmorrow: and i have no way to tell the compiler that i don't care which of those it is
22:55:46 <RyanT5000> mmorrow: (except in certain very limited circumstances like if i use Edison pervasively)
22:55:51 <mmorrow> but why not rep write code that work with the general concept, that you can use regardless of implem?
22:56:03 <mmorrow> (oh, i'm not talking about edison in particular)
22:56:26 <wy> Peaker: I used to have list of all the design patterns and their corresponding terms in functional programming
22:56:32 <RyanT5000> is there a general way to do that?
22:56:36 <mmorrow> yeah, not having control over typeclass instance selection is a pain when there's more than one instance possible
22:57:20 <RyanT5000> mmorrow: exactly
22:57:26 <mmorrow> RyanT5000: if only we had ML structures/signatures/(recursive)-functors/etc
22:58:11 <RyanT5000> mmorrow: especially if you have, e.g.: f :: C c => a -> c ; g :: C c => c -> b ; g (f x)
22:58:28 <wy> My conclusion is that most "novel" design patterns arise from the lack of first-class functions. The others are old and used by people for decades. They just didn't have a name
22:58:31 <RyanT5000> if i don't care at all which implementation of C gets used for c, i still have to pick one
22:59:04 <RyanT5000> and since i'm virtually certain to never look at that code again, whatever i pick randomly the first time through will be there forever
22:59:31 <PetRat> Suppose I'm mapping a function with > 2 arguments, and the argument to be supplied by the list is somewhere in the middle. is there something more idiomatic than map (\a -> g arg1 arg2 a arg3 arg4) xs ?
22:59:33 <mmorrow> RyanT5000: yeah, i think that typeclasses are good for what they're good for, but suck as a substitute for signatures/functors
22:59:52 <RyanT5000> mmorrow: yeah; what i really want in that particular example is for the compiler to just pick an instance for me
22:59:52 <wy> Just like the way JUnit works. People have been using this kind of thing for decades, but some guy gave it a name and made fame from it...
23:00:13 <RyanT5000> mmorrow: although that requires that classes can completely specify program behavior...
23:00:25 <RyanT5000> (or at least specify it arbitrarily well)
23:00:40 <mmorrow> RyanT5000: the signatures only specify abstract units
23:00:46 <mmorrow> Map
23:00:50 <mmorrow> Queue
23:00:56 <mmorrow> Scheduler
23:00:58 <mmorrow> etc
23:00:59 <RyanT5000> yeah
23:01:24 <RyanT5000> ideally, i'd like the programmer to usually not need to get below that level of abstraction
23:03:11 <PetRat> bump Suppose I'm mapping a function with > 2 arguments, and the argument to be supplied by the list is somewhere in the middle. is there something more idiomatic than map (\a -> g arg1 arg2 a arg3 arg4) xs ?
23:05:06 <dibblego> is the Test.QuickCheck module installed by default with most GHC distributions?
23:05:46 <mib_t968yv> > pl (\l i k -> take (k-i+1) $ drop (i-1) l)
23:05:47 <lambdabot>   Not in scope: `pl'
23:06:07 <mib_t968yv> ...d'oh ><
23:06:45 <mmorrow> RyanT5000: totally, you could code whole programs as a bunch of (ML) functors, then stick in any structures with correct signatures later
23:08:13 <erikc> PetRat: none i know of
23:08:26 <RyanT5000> mmorrow: or better yet, have the compiler stick them in for you, and you only change them if you need to to improve efficiency
23:08:44 <RyanT5000> mmorrow: i'm going to have to learn ML now :P
23:08:52 <PetRat> erikc: thanks
23:08:52 <mmorrow> RyanT5000: well sure, assuming that all the structures you need are in the stdlib
23:09:05 <RyanT5000> (i've used it in some classes, but not seriously)
23:09:20 <mmorrow> (structure in the ML sense)
23:09:40 <mib_t968yv> @pl \l i k -> take (k-i+1) $ drop (i-1) l
23:09:40 <lambdabot> ap (flip . (take .) . flip flip 1 . ((+) .) . subtract) . flip (drop . subtract 1)
23:09:45 <RyanT5000> mmorrow: it seems like that could be made extensible relatively easily
23:10:03 <RyanT5000> mmorrow: obviously you'd have to tell the compiler which structures you trust to implement a given interface
23:10:20 <RyanT5000> (especially if a library has one good structure and another that's not so good)
23:10:37 <sjanssen> this seems related to defaulting
23:10:42 <mmorrow> RyanT5000: exactly, you then write code that hand-picks what structures you want
23:11:08 <mmorrow> (and you can swap a choice out for another easily)
23:11:08 <RyanT5000> yup
23:11:30 <RyanT5000> i think that would eliminate a *huge* class of decisions from the average programmer's day
23:11:56 <mmorrow> me too
23:12:12 <sjanssen> perhaps some sort of extension to defaulting is in order: default(Integral Integer, MapClass Data.Map.Map)
23:12:50 <RyanT5000> sjanssen: i think it would take some serious changes to haskell's class system to make such a thing workable
23:13:03 <RyanT5000> sjanssen: at the very least, transitive mandatory inclusion of instances would need to be dealt with
23:13:09 <sjanssen> RyanT5000: I'm not sure, defaulting already exists
23:13:15 <sjanssen> RyanT5000: that issues seems orthogonal
23:14:00 <RyanT5000> sjanssen: well, i suppose if the default were specified with the class, that would be fine enough
23:14:19 <sjanssen> RyanT5000: hmm, is that really what we want to do?
23:14:26 <sjanssen> seems like defaults should be module local
23:14:48 <RyanT5000> sjanssen: they need to be importable, otherwise we're adding a ton of module overhead
23:15:00 <RyanT5000> sjanssen: they could be imported from non-modules though, i guess
23:15:07 <sjanssen> RyanT5000: yeah, importable would be good
23:15:09 <RyanT5000> C preprocessor? :P
23:15:34 <erikc> RyanT5000: logic programming with a good metalanguage for the logical->physical mapping would fit well too
23:16:02 <RyanT5000> erikc: i'm confused as to what you're talking about
23:16:04 <erikc> there is some interesting work here http://www.cs.cornell.edu/bigreddata/games/ in that area, applying relational algebra to game scripting
23:16:16 <RyanT5000> ah, i see
23:16:32 <RyanT5000> "Computer games are becoming the next frontier for social interaction between humans."
23:16:41 <RyanT5000> a scary - and dubious - statement :P
23:16:42 <erikc> grant-speak
23:16:48 <erikc> :P
23:17:35 <twb> I bet dijkstra would have something scathing to say about that
23:17:40 <RyanT5000> yeah... i got plenty of that kind of crap in law school :P
23:18:13 <RyanT5000> (lawyers don't reserve that kind of language for court - or even for work :P)
23:18:36 <erikc> twb: about the 'computer games are ...' ?
23:18:59 <RyanT5000> "computer gaming is" might be a more grammatical choice :P
23:18:59 <twb> erikc: about grant-speak being about a reality that doesn't exactly match the real world.
23:19:09 <erikc> ah hehe
23:19:16 <RyanT5000> lol
23:20:03 <twb> I recently read an essay (read: rant) of his about the lack of, as it were, plain speaking in papers.
23:21:01 <twb> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html This one?
23:21:44 <twb> No, not that one.
23:25:11 <RyanT5000> thanks for all the input on the game engine stuff, everyone
23:25:23 <RyanT5000> i'm out
23:33:04 <twb> Ah, here it is
23:33:04 <twb> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1300.html
23:33:41 <twb> Not really as relevant as I remembered.
23:33:43 <dibblego> when did GHC discontinue splitting into core and extra-libs (I'm going to give a presentation and I want all users to have Test.QuickCheck available)
23:40:08 <wy> weilawei|away: hi
23:47:36 <xmonader> Saizan, i tried your note but still not working
23:49:55 <mykelyk> how can i call f :: Value -> [Value] -> IO (State Stack Value)
23:50:38 <mykelyk> with a :: IO (State Stack Value)
23:50:54 <mykelyk> and b :: IO (State Stack [Value]) ?
23:52:11 <mmorrow> @type \f a b -> do sv <- a; svs <- b; return (do v <- sv; vs <- svs; f v vs)
23:52:13 <lambdabot> forall (t :: * -> *) (t1 :: * -> *) t2 t3 t4. (Monad t, Monad t1) => (t2 -> t3 -> t1 t4) -> t (t1 t2) -> t (t1 t3) -> t (t1 t4)
23:52:30 <mmorrow> although that seems like it's not what you want. where did you get those types from?
23:52:59 <mykelyk> an intepreter
23:53:37 <mmorrow> @type \f a b -> do sv <- a; svs <- b; return (do v <- sv; vs <- svs; f v vs) :: (a -> [a] -> IO (State s a)) -> IO (State s a) -> IO (State s [a]) -> IO (State s a)
23:53:38 <lambdabot>     Inferred type is less polymorphic than expected
23:53:38 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
23:53:38 <lambdabot>         svs :: IO (State s a) -> t1 (bound at <interactive>:1:22)
23:53:54 <mmorrow> @type (\f a b -> do sv <- a; svs <- b; return (do v <- sv; vs <- svs; f v vs)) :: forall s. (a -> [a] -> IO (State s a)) -> IO (State s a) -> IO (State s [a]) -> IO (State s a)
23:53:56 <lambdabot> Not in scope: type variable `a'
23:53:56 <lambdabot> Not in scope: type variable `a'
23:53:56 <lambdabot> Not in scope: type variable `a'
23:54:02 <mmorrow> @type (\f a b -> do sv <- a; svs <- b; return (do v <- sv; vs <- svs; f v vs)) :: forall s a. (a -> [a] -> IO (State s a)) -> IO (State s a) -> IO (State s [a]) -> IO (State s a)
23:54:04 <lambdabot>     Couldn't match expected type `State s a'
23:54:04 <lambdabot>            against inferred type `IO (State s a)'
23:54:04 <lambdabot>     In the expression: f v vs
23:54:48 <mmorrow> hmm
23:55:15 <mykelyk> any idea?
23:55:31 <mmorrow> so you need to get the IO out of the State, run the State, and put the IO back (or something)
23:56:52 <mmorrow> (\f a b -> do sv <- a; svs <- b; return (do v <- sv; vs <- svs; unsafePerformIO (f v vs))) :: forall s a. (a -> [a] -> IO (State s a)) -> IO (State s a) -> IO (State s [a]) -> IO (State s a)
23:56:57 <mmorrow> is what i'd do
23:57:19 <mykelyk> unsafePerformIO ?
23:57:40 <mmorrow> are you sure that calling f on these inputs makes sense though? because if so then it's a design error on the part of the interpreter
23:58:28 <mmorrow> mykelyk: you're putting it back into IO though, so it's fine here (in fact, it's really you're only choice to do what you want to do here)
23:58:40 <mmorrow> s/you're/your/
23:59:06 <Jedai> mykelyk: Are you sure the type of f is correct ? Rather than IO (State...) an interpreter should rather produce something like StateT Stack IO a
23:59:12 <mmorrow> yeah
23:59:58 <mykelyk> probably you're right
