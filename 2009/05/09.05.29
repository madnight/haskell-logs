00:00:13 <Gracenotes> mmorrow: that's not recursive fib :)
00:00:20 <mmorrow> but doing "void *xs[2]; xs[0] = xs; xs[1] = xs;" is kinda a different concept than a while loop
00:00:29 <mmorrow> Gracenotes: it's recursing :)
00:00:30 <Cale> Gracenotes: But it sort of is...
00:00:53 <Cale> fix f = x where x = f x
00:01:01 <Cale> So...
00:01:05 <Cale> fix (\k m n -> m : k n (m+n)) 0 1
00:01:39 <Cale> = x 0 1 where x = (\k m n -> m : k n (m+n)) x
00:01:55 <Cale> = x 0 1 where x = \m n -> m : x n (m+n)
00:01:57 <Gracenotes> > fix (\k b -> if b <= 1 then b else k (b - 1) + k (b - 2)) 10
00:01:59 <lambdabot>   55
00:02:03 <Cale> = x 0 1 where x m n = m : x n (m+n)
00:02:57 <cads> http://aclinks.wordpress.com/ how to become a successful researcher :D
00:03:09 <mmorrow> Gracenotes: you can do that with a while loop too, you just have to maintain your own call stack
00:03:15 <Gracenotes> you can do branching recursion, it seems. probably even ackermann
00:03:18 <cads> a talk by peyton jones on the subject is listed there, that ought to be entertaining
00:03:32 <Gracenotes> which is just about as primitive-recursive-y as you can go
00:03:36 <mmorrow> Gracenotes: err, fix is general recursion
00:03:37 <Cale> Gracenotes: You can write *all* recursion in terms of fix
00:03:57 <cads> can't fix do corecursion and junk?
00:03:59 <Gracenotes> mmorrow: okay, why didn't you say so? :)
00:04:20 <mmorrow> Gracenotes: heh, i didn't know what you were saying until just now
00:04:30 <Gracenotes> you can write all recursion in terms of while(1) too, although when you need an explicit call stack... hrm
00:04:39 <Gracenotes> as you just said
00:05:02 <Gracenotes> just not tail recursive then.
00:05:05 <mmorrow> well, you need the stack if you want to write it in the same style
00:05:26 <mmorrow> you can always transform it i guess (maybe)
00:06:02 <cads> if we have   f = g . f for nonrecursive g, then doesn't   f = fix g ?
00:06:07 <mmorrow> as in, just compute it bottom-up
00:06:19 <Gracenotes> @free fix
00:06:22 <lambdabot> f . g = h . f => f (fix g) = fix h
00:06:23 <mmorrow> like that bottom-up fib
00:07:13 <cads> Gracenotes: so yes, neat
00:07:30 <Gracenotes> hm... for what values of f, g, and h does it == your theorem?
00:08:21 <cads> the rolling theorem is neat too     fix (f . g) = g (fix (g . f))
00:08:23 <Gracenotes> (of course both may be independant)
00:08:45 <Gracenotes> cads: ooh, that's neat f . g . f . g . f . g
00:09:00 <Cale> if we put g = id, then we get if f = h . f then f (fix id) = fix h
00:09:20 <mmorrow> , fix ((h::Expr->Expr) . (g::Expr->Expr) . f) {- never gets old -}
00:09:22 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
00:09:25 <cads> thanks cale
00:09:42 <Cale> Which means that f = const (fix h)
00:09:55 <Gracenotes> hm
00:10:54 <Cale> cads: Not f (fix (g . f)) ?
00:11:17 <Cale> > fix ((1:) . (2:))
00:11:18 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
00:11:31 <Cale> > (1:) (fix ((2:) . (1:)))
00:11:33 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
00:11:58 <cads> hrm
00:12:28 <thomastc> lambdabot: can Haskell take over the world?
00:12:46 <Cale> @faq can Haskell take over the world?
00:12:47 <lambdabot> The answer is: Yes! Haskell can do that.
00:13:07 <thomastc> ah, confused with syntax of other bot, thanks :)
00:14:05 <mmorrow> , fix ((0:) . scanl (+) 1)
00:14:07 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
00:14:11 <cads> ahh, cale, (f . g . f . g ...) = f (g . f . g ...), you're right; f is the "last" function we apply before our point is fixed. We can pull it out, and roll over the variables
00:14:19 <cads> err, functions
00:14:26 <Cale> cads: yeah
00:14:37 <Cale> Or the first
00:14:46 <Cale> Depending on the way you look at it
00:15:29 <cads> grr, I wish I knew function composition like I knew addition and multiplication
00:15:31 * Cale is geared to thinking of evaluation as being outermost-first
00:19:12 <copumpkin> fail: http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=ghc&id=4
00:25:12 <cads> Let's say a corecursive function fixes after a few iterations, like 1)  (f . g . f . g) = g (f . g . f . g). Then obviously 2)  f (g . f . g) is the same thing as the lhs of 1). But then 1) = fix(f . g) = 2) = f . (fix (g . f)). This is true for functions which fix in a given number of recursion, and for functions that fix in a number of recursions greater than that. I think there are a few holes, but QED.
00:25:19 <cads> hehe, I need to go to bed
00:25:31 <cads> take care all
00:26:22 * cads handwaves all the way to bed
00:28:55 <copumpkin> night :)
00:39:52 <copumpkin> is a unitary matrix positive definite?
00:42:57 * Raynes huggles copumpkin
00:44:16 <ivanm> "huggles"?
00:44:35 * copumpkin huggles ivanm and Raynes
00:44:50 <ivanm> stay away from me!
00:45:01 <Raynes> ivanm: It's a word used by sophisticated IRC/Haskellers.
00:45:20 * ivanm quickly builds a barrier out of handy objects, furniture, people, etc. to protect against copumpkin 
00:45:37 <ivanm> Raynes: since when did "sophisticated" imply "can't use normal English words"?
00:45:54 <olsner> ivanm: hasn't that always been the case?
00:46:06 <ivanm> not that I know of
00:46:17 <^Someone^> "normal"?
00:46:18 <Raynes> ivanm: Since I invented the word glaseymaster.
00:46:24 <copumpkin> Raynes: there's a @spam twitter account btw
00:46:49 <Raynes> To report spammers?
00:46:51 <Raynes> Neato.
00:46:58 <ivanm> ^Someone^: normal, as in words that already exist, etc.
00:47:05 <^Someone^> "huggles" does exist
00:47:29 <hackagebot> explicit-sharing 0.4.0
00:47:30 <ivanm> Raynes: oh, I would have thought it would have been to get your daily fix of spam...
00:47:34 <^Someone^> It's recently been added to the dictionary too
00:47:38 <ivanm> ^Someone^: formally?
00:47:45 * ivanm checks his dictionaries
00:48:02 <^Someone^> Yes
00:48:47 <ivanm> I can't find it in the copy of the Pocket Oxford Dictionary I have handy
00:48:55 <ivanm> but there is "hugger-mugger" :s
00:49:11 <^Someone^> Somewhat recently -_-
00:49:19 <^Someone^> Anyway!
00:49:23 <^Someone^> That's not the point
00:49:51 <^Someone^> The point is that it makes sense to create and use such a word
00:51:05 <^Someone^> Especially for a functional programmer, I should think : o
00:51:31 <ivanm> it does?
00:51:35 <ivanm> in what way?
00:51:38 <^Someone^> It's almost like function composition
00:51:42 <ivanm> since I have no idea wtf it means... >_>
00:51:58 <^Someone^> It's a hug and a snuggle combined
00:52:09 <ivanm> *shudder*
00:52:38 <ivanm> function composition -/-> "making up new words by juxtapositioning one word upon another"
00:52:47 <^Someone^> "almost like"
00:53:35 <copumpkin> huggle = hug . cuddle
00:53:39 <ivanm> *usage of function composition
00:53:52 <ivanm> copumpkin: that makes even less sense than ^Someone^'s definition
00:54:08 <ivanm> and it goes to show, that if you can't even decide what your made-up words mean, then we shouldn't be using them!
00:54:18 <copumpkin> who says it isn't an overloaded word?
00:54:22 <copumpkin> language are full of them
00:54:28 <copumpkin> *languages
00:54:31 <ivanm> heh
00:54:43 <olsner> "portmonteau" is a nice term that I think might apply to 'huggle'
00:55:01 <dmwit> ?wn portmanteau
00:55:03 <lambdabot> *** "portmanteau" wn "WordNet (r) 2.0"
00:55:03 <lambdabot> portmanteau
00:55:03 <lambdabot>      n 1: a new word formed by joining two others and combining their
00:55:03 <lambdabot>           meanings; "`smog' is a blend of `smoke' and `fog'";
00:55:03 <lambdabot>           "`motel' is a portmanteau word made by combining `motor'
00:55:05 <lambdabot> [5 @more lines]
00:55:09 <dmwit> Your spelling sucks, but your vocabulary is impeccable.
00:55:11 <copumpkin> besides, it may just be a proof that snuggle == cuddle assuming hug is a monomorphism
00:55:14 <ivanm> class Definition ^Someone^ where huggle = hug . snuggle; class Definition copumpkin where huggle = hug . cuddle
00:55:15 <ivanm> ;-)
00:55:19 <^Someone^> Yes, the words were MELDed together
00:55:21 <^Someone^> ; )
00:55:25 <ivanm> olsner: no, IIRC portmanteau means they just join them together
00:55:28 <^Someone^> Like Melt and weld xD
00:55:41 <ivanm> whereas both ^Someone^ and copumpkin have dropped intermediary letters
00:55:44 * copumpkin wonders if he used monomorphism correctly there
00:56:09 * copumpkin is still reading awodey
00:56:29 <dmwit> I think you used it correctly.
00:56:44 <dmwit> The only other choice is epimorphism, but it's not that. =)
00:56:57 <copumpkin> I prefer to call it an epic morphism win
00:57:12 <ivanm> dmwit: hmmm, maybe he did
00:58:12 <mornfall> ivanm: "just joining" is juxtaposition, portmanteau is smacking them together at high speed. ;)
00:58:26 <ivanm> *nod*
00:58:42 <ski> forall A,B. forall f : A -> B. mono f <=> forall T. forall x,y : T -> A. f . x = f . x => x = y
00:58:43 <ivanm> ahhh, I used the wrong term
00:58:45 <copumpkin> epic word fusion
00:58:56 <copumpkin> I mean monic
00:58:57 <ivanm> not juxtaposition.... which word means you put one on top of the other?
00:58:57 <copumpkin> ;)
00:58:58 <Gracenotes> o nos
00:59:34 <mornfall> ivanm: overlay maybe?
00:59:45 <ivanm> maybe
01:00:00 <ivanm> there's a semi-technical term though... *shrug* not that big a deal
01:00:12 <dmwit> superposition?
01:00:16 <osfameron> superimpose?
01:00:17 <mornfall> Like jumbled printing? : - )
01:00:18 <dmwit> But that's not really the same.
01:00:38 <mornfall> Sounds perfectly technical to me.
01:00:49 <ivanm> dmwit: that's the one
01:00:57 <ivanm> that's what I was thinking of, anyway
01:01:26 * ski . o O ( M-x dissociated-press )
01:02:09 <olsner> ski executes the dissociated press?
01:02:13 <mornfall> Err. --> bassoon, anyway. Cya. :)
01:02:49 <ivanm> ski: hmmmm, my version of emacs doesn't have that function
01:02:57 <ivanm> is it from an external elisp file?
01:04:45 <ski> `dissociate.el' according to <http://en.wikipedia.org/wiki/Dissociated_press>
01:17:14 <dancor_> i want to be able to sequentially modify all the occurrences of the datatype Expr in my Stmt datatype
01:17:31 <dancor_> it sounds like Traversable, but it's complicated by having a second type i think
01:22:29 <ski> Detect Loop <http://www.getacoder.com/projects/detect_loop_106243.html>
01:23:27 <dmwit> troll
01:23:37 <dmwit> Hint #1: username is fermat.
01:23:44 <dcoutts> ski: no problem, so long as they don't mind occasionally getting "dunno" as the answer
01:27:09 <ski> dancor_ : "complicated by having a second type" ?
01:27:33 <WorkyBob> ski: hehe, that one is fun
01:27:42 <copumpkin> halting is decidable on LBAs anyway isn't it?
01:27:59 <dmwit> LBA?
01:28:04 <copumpkin> linear bounded automaton
01:28:34 <copumpkin> hrm
01:28:42 <dancor_> ski: Traversable vs views? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2516#a2516
01:29:02 <Twey> « Hi Will be done within time and budget .............. If you have any query plz ask without any hesitation ....... Best Regards »
01:29:05 * Twey chuckles.
01:29:30 <WorkyBob> shame someone pointed out the imposibility to them
01:29:30 <dancor_> i think that if i had data Stmt expr = StmtBreak expr Other Stuff | ..   then Traversable would be perfect
01:29:59 <dancor_> but since i have  data Stmt = StmtBreak Expr Other Stuff | ..  i don't think i can use Traversable, is that correct?
01:30:15 <Twey> « I will build the program that not only detect infinite loop as well as it will checked also improper if condition and also switch.Program also trying to read the logic of recursion and if it is improper then it will prompt the list of suggesstion.So I am confident to build your project in c# with Sql Sever.I would accept payment after you satishfied with the work. Regards Sumanta »
01:30:28 <Twey> This is a real lesson in why not to use rent-a-coder sites
01:30:32 <copumpkin> is that a real reasponse?
01:30:33 <copumpkin> wow
01:30:35 <Twey> Yeah
01:30:49 <WorkyBob> >.<
01:30:51 <Twey> (or C# programmers :-P)
01:30:55 <Ycros> Twey: oh, I was reading that earlier, it was totally hilarious
01:30:56 <copumpkin> he should've mentioned active directory, and used the word enterprise at least twice
01:31:02 <Twey> Hahaha
01:31:07 <WorkyBob> hahahahaha
01:31:36 <copumpkin> :)
01:31:40 <WorkyBob> he didn't mention XML either
01:31:45 <Twey> Or Java
01:31:47 <ski> dancor_ : have you seen mmorrow's `Cxt'/`View' ?
01:31:48 <WorkyBob> surely XML would be needed to solve the halting problem
01:31:51 <Twey> Or is Java no longer the In Thing?
01:31:55 <WorkyBob> no, Java's old
01:31:56 <WorkyBob> sorry
01:32:00 <Twey> Damn
01:32:04 <WorkyBob> you're obviously a bad programmer Twey
01:32:07 <WorkyBob> not keeping up with the times
01:32:34 <ski> dancor_ : btw, i'm doubtful of `class Look a b where look :: a -> View a b' to be that useful
01:33:25 <dancor_> ski: i haven't where is mmorrow's stuff, #haskellogs?
01:33:28 <Twey> I know, it's shocking
01:33:57 <ski> mmorrow : well, <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2486> at least .. possibly mmorrow can give better reference
01:34:38 <ski> er
01:34:48 <ski> s/mmorrow :/dancor_ :/
01:35:56 <ski> (dancor_ : e.g. see `accumView' there)
01:37:52 <dancor_> hm
01:38:14 <dancor_> it is true that Traversable isn't appropriate here right?
01:38:18 <dancor_> it seems so close
01:39:18 <ski> `Traversable' wants to work with a parameterized type
01:39:35 <dancor_> ya
01:39:36 <dancor_> ok
01:39:39 <ski> you just want to work with "all substructures of type `Expr'"
01:39:50 <ski> there might be some SYB you could use ..
01:40:13 <mmorrow> dancor: here's a paste from a few days ago http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2486
01:40:23 <ski> you could of course write an `traverseExpr :: Applicative i => (Expr -> i Expr) -> (Stmt -> i Stmt)' yourself
01:40:43 <dancor_> mmorrow: yes that's very interesting and your TH skills are way beyond me :)
01:41:26 <mmorrow> dancor_: heh, what are you going for?
01:41:57 <dancor_> well i will probably want to do this with other datatypes besides Stmt and Expr as well
01:42:16 <dancor_> but maybe i'll just write traverseExpr for now then consider insane TH later
01:42:36 <dancor_> mmorrow: i'm just trying to do abstract syntax tree manipulations
01:43:48 <mmorrow> what i really want to be able to do is (and andyjgill's KURE pkg does this, but i haven't worked out how to generate all the instance, functions, etc code i need to be able to use it quite yet) is to be able to write a function that does some little/specific transformation to an AST, and then be able to apply that, with the choice of top-down or bottom-up, to an expression. and syb doesn't quite do it for me since i need to also thread a
01:43:48 <mmorrow>  monad through it.
01:43:59 <mmorrow> dancor_: totally, me too
01:44:07 <dancor_> hah nice
01:44:21 <ski>   Data.Generics.Schemes.everywhereM :: Monad m => (forall a. Data a => a -> m a) -> (forall a. Data a => a -> m a)
01:44:36 <mmorrow> dancor_: (and all this is a product of being completely fed up with writing (essentially) the same traversals over each new AST)
01:44:46 <ski> dancor_ : that's what i was thinking about
01:45:21 <mmorrow> ski: yeah, the thing with everywhereM though is that you have no control over traversal strategy
01:45:44 <mmorrow> (but everywhere(M) is totally handay, don't get me wrong)
01:46:01 <ski> *nod*
01:46:42 <mmorrow> hmm, i wonder ... you could find out what it's doing by using a state monad..
01:46:48 <mmorrow> > everywhereM
01:46:49 <lambdabot>   Overlapping instances for GHC.Show.Show
01:46:50 <lambdabot>                              (Data....
01:47:55 * ski wonders whether `everywhere' traverses into existentially hidden structures, having the `Data' constraints
01:47:59 <Gracenotes> :t everywhereM
01:48:00 <lambdabot> forall (m :: * -> *) a. (Data a, Monad m) => GenericM m -> a -> m a
01:48:09 <mmorrow> > flip runState 0 (everywhereM (\_ -> do i <- get; put (i+1); return (i::Int)) (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]]))
01:48:10 <lambdabot>   Couldn't match expected type `a'
01:48:26 <mmorrow> oh, what is the monadic mkT?
01:48:59 <mmorrow> > flip runState 0 (everywhereM (mkM (\_ -> do i <- get; put (i+1); return (i::Int))) (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]]))
01:49:01 <lambdabot>   (Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {...
01:49:19 <mmorrow> > levels (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]]))
01:49:20 <lambdabot>   <no location info>: parse error on input `)'
01:49:23 <mmorrow> > levels (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]])
01:49:24 <lambdabot>   [[0],[1,3],[2,4]]
01:49:30 <mmorrow> > levels $ flip runState 0 (everywhereM (mkM (\_ -> do i <- get; put (i+1); return (i::Int))) (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]]))
01:49:31 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
01:50:01 <ski> @type levels
01:50:02 <lambdabot> forall a. Tree a -> [[a]]
01:50:06 <re__> hi there
01:50:19 <re__> anyone there who likes to help me a little with profiling?
01:50:32 <mmorrow> > levels $ flip evalState 0 (everywhereM (mkM (\_ -> do i <- get; put (i+1); return (i::Int))) (Node 0 [Node 1 [Node 2 []], Node 3 [Node 4 []]]))
01:50:34 <lambdabot>   [[0],[1,3],[2,4]]
01:50:50 <mmorrow> so i guess it's depth-first
01:50:56 <mmorrow> err
01:51:04 <mmorrow> yeah
01:51:15 <mmorrow> no
01:51:28 <mmorrow> breadth-first
01:51:46 <mmorrow> top-down
01:53:59 <JaffaCake> mmorrow: have you tried using StableName for vacuum, instead of unsafePtrEquality?
01:54:50 <mmorrow> dancor_: anyways, the code to generate those instances of View was semi-epic... you have to build the graph of all reachable types from a type, compute the SCC that that type's in, build a Map of Type -> [(Int{-con tag-},[(Int{-field index-}, Type)]], and finally generate the View instance picking out the 'b' in (View a b) from all the places in 'a' where it occurs
01:55:32 <mmorrow> JaffaCake: i haven't. do you think it would be a lot of overhead for a graph of, say, 1000+ nodes?
01:55:58 <JaffaCake> well, using ptr equality is quadratic, whereas with StableName you could have a hash table
01:56:20 <mmorrow> ahhh, yeah true. i have to do linear search through seen nodes with ptr equality..
01:56:25 <JaffaCake> there might be a constant factor, but I think you'd win with large graphs
01:56:52 <mmorrow> hmm, interesting. i'll try it out.
01:57:23 <mmorrow> JaffaCake: what about the possibility of false negatives?
01:57:52 <JaffaCake> I don't think it's any worse than with ptr equality
01:58:03 <mmorrow> nice
01:59:07 <ski> @hoogle GenParser t s [t] -> GenParser t s ()
01:59:08 <lambdabot> No results found
01:59:43 <dancor_> mmorrow: sorry i was playing with the tree example.  it's depth-first right, since the numbering is the same
01:59:44 <ski> @hoogle GenParser t s [t] -> GenParser t s a -> GenParser t s a
01:59:45 <lambdabot> No results found
02:00:01 <ski> > levels $ flip evalState 0 (everywhereM (mkM (\_ -> do i <- get; put (i+1); return (i::Int))) (Node 0 [fix $ \t -> Node 1 [Node 2 [t]], Node 3 [Node 4 []]]))
02:00:03 <lambdabot>   [[0],[1,3],[2,4],[1],[2],[1],[2],[1],[2],[1],[2],[1],[2],[1],[2],[1],[2],[1...
02:00:29 <mmorrow> dancor: ah yeah, depth-first (i confused myself)
02:00:51 <dancor_> mmorrow: and, about TH, it all seems very epic to me :)
02:01:58 <mmorrow> dancor_: heh. once you get a code-base of it though, it starts to get self-supporting in that you can use it to generate more of it to use it to ...
02:02:24 <dancor_> you don't change TH.  it changes you (and itself)
02:03:16 <mmorrow> for instance, once i finally figure out howtf to generate the KURE support code for the TH AST itself, then i can use kure to manipulate the TH which'll then generate the kure support code for other ast's more easily..
02:03:30 <mmorrow> dancor_: totally
02:05:40 <mmorrow> well, kure is more for transforming an ast than it is for building expression/whatever with that ast, but you know what i mean :)
02:06:00 <dancor_> i'm reading about kure now
02:06:52 <mmorrow> dancor_: it's interesting. the trickyness comes in when your ast's cons have fields like:
02:07:17 <mmorrow> data Exp = ... | Foo [Exp] (Maybe Exp) ([Stmt],Maybe ..) | ....
02:07:39 <mmorrow> then you have to figure out how to see through/something the []s and Maybes
02:08:03 <mmorrow> (and (,,...,)s)
02:08:12 <mmorrow> which is a total pita
02:09:59 <quicksilver> is implementing Num to lift things into your EDSL *actually* a sensible technique
02:10:08 <quicksilver> or is it in fact a rather despicable hack?
02:10:43 <mmorrow> heh, it'd be nice if there was a class with only fromInteger..
02:11:12 <mmorrow> because i feel like whenever i make Num instances, at least abs and signum are error "..."
02:11:26 * quicksilver nods
02:11:34 <quicksilver> well I was looking at the cafe thread about bool as a type class.
02:11:44 <quicksilver> but to me, it's always felt like rather an abuse to do this at all.
02:11:49 * quicksilver shrugs
02:12:04 <lars9> how to understand fmap vs. map?
02:12:12 <quicksilver> map only works on lists
02:12:20 <quicksilver> fmap works on all functors (including lists)
02:12:41 <mmorrow> @src [] fmap
02:12:41 <lambdabot> fmap = map
02:12:47 <mmorrow> @src [] Maybe
02:12:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:12:54 <mmorrow> > fmap (*2) (Just 4)
02:12:55 <lambdabot>   Just 8
02:13:08 <dancor_> @src Maybe fmap
02:13:09 <lambdabot> fmap _ Nothing       = Nothing
02:13:09 <lambdabot> fmap f (Just a)      = Just (f a)
02:13:14 <mmorrow> heh, oops
02:13:30 <dancor_> allyoops
02:13:33 <lars9> >fmap (*2) [1,2,3]
02:13:42 <lars9> > fmap (*2) [1,2,3]
02:13:43 <lambdabot>   [2,4,6]
02:13:57 <lars9> > fmap (*2) (*3)
02:13:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
02:13:58 <lambdabot>    arising from a use of `...
02:14:09 <mmorrow> > (fmap . fmap . fmap) (*2) [Just [4]]
02:14:10 <lambdabot>   [Just [8]]
02:14:13 <WorkyBob> > fmap (*2) (*3) $ 6
02:14:14 <lambdabot>   36
02:14:27 <WorkyBob> > fmap fmap fmap fmap fmap (*2) [Just [4]]
02:14:29 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
02:14:34 <WorkyBob> damn, need parens for that one
02:14:44 <lars9> > (fmap (*2) (*3)) 4
02:14:44 <WorkyBob> > fmap (fmap fmap fmap) fmap (*2) [Just [4]]
02:14:45 <lambdabot>   24
02:14:46 <lambdabot>   [Just [8]]
02:15:17 <lars9> hey, is fmap (*2) (*3) equal to (*6) ?
02:15:22 <WorkyBob> yes
02:15:30 <WorkyBob> fmap (*2) (*3) is (*2) . (*3)
02:15:41 <Axman6> hmm, this seems wrong to me, but i can't think of a situation  that disproves it. are powers of 2 only dividible by smaller powers of 2?
02:15:53 <WorkyBob> Axman6: yes
02:15:57 <WorkyBob> and it's easily proved
02:16:01 <Axman6> @src (->) fmap
02:16:01 <lambdabot> fmap = (.)
02:16:05 <WorkyBob> break them down to prime factors
02:16:15 <WorkyBob> 2, 2, 2, 2, 2..... 2, 2
02:16:15 <Axman6> and all you get is 2's
02:16:18 <qebab> Axman6: Prime factorisation of a power of 2 consists only of 2s.
02:16:27 <lars9> what does this command mean? @src
02:16:37 <WorkyBob> lars9: it displays the source for a function
02:16:45 <Axman6> @src map
02:16:45 <lambdabot> map _ []     = []
02:16:45 <lambdabot> map f (x:xs) = f x : map f xs
02:16:46 <WorkyBob> as defined by the haskell report IIRC
02:17:30 <lars9> @src fmap (*2) (+3)
02:17:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:17:46 <lars9> @src (fmap (*2) (+3))
02:17:46 <lambdabot> Source not found. Are you on drugs?
02:17:55 <WorkyBob> you can't ask for the source for an expresison
02:17:57 <WorkyBob> only for a function
02:18:03 <Axman6> lars9: only things in the haskell report (and possibly some others) are in @src
02:18:07 <ski> Axman6 : `2' is a power of `2', `2' divides `2', `2' is not smaller than `2'
02:18:08 <WorkyBob> what Axman6 did was ask for the source of fmap
02:18:08 <lars9> @src fmap
02:18:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:18:09 <Axman6> @src Maybe
02:18:09 <lambdabot> data Maybe a = Nothing | Just a
02:18:11 <WorkyBob> and a specific fmap
02:18:19 <WorkyBob> the fmap for the type (->)
02:18:22 <WorkyBob> i.e. for functions
02:18:27 <WorkyBob> @src (->) fmap
02:18:27 <lambdabot> fmap = (.)
02:18:55 <Axman6> ski: yeah, that's true.
02:19:24 <ski> @src [] mzero
02:19:25 <lambdabot> mzero = []
02:19:42 <ski> (`[]' is not a function)
02:19:45 <quicksilver> Axman6: the fundamental theorem of arithmetic explains why/how you can generate all factors from the prime factorisation.
02:19:49 <lars9> @src forM
02:19:49 <lambdabot> forM = flip mapM
02:20:00 <WorkyBob> bah
02:20:05 <WorkyBob> @src mapM
02:20:06 <lambdabot> mapM f as = sequence (map f as)
02:20:12 <WorkyBob> fmap fmap fmap sequence fmap is way better
02:20:13 <WorkyBob> :(
02:21:01 <lars9> ive still not got used to xxxM functions, often confused by them...
02:21:28 <WorkyBob> what do you find confusing about them specifically?
02:21:39 <WorkyBob> and do you understand the functor and applicative functions?
02:22:05 <WorkyBob> (is guessing not, because most of the xxxM functions are actually applicative ones)
02:22:42 <lars9> e.g. liftM, it converts a (a -> a) to (a -> m a) ?
02:22:51 <quicksilver> :t liftM
02:22:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:22:54 <WorkyBob> liftM is also known as fmap
02:23:05 <quicksilver> ^^ no, it converts an (a -> a) to a (m a -> m a)
02:23:07 <quicksilver> or more generally
02:23:13 <WorkyBob> it converts an (a -> b) to a (m a -> m b)
02:23:14 <quicksilver> it converts an (a -> b) to a (m a -> m b)
02:23:18 <WorkyBob> jnix!
02:23:20 <WorkyBob> :D
02:23:53 <lars9> so, liftM (*2) can twice all items in a list?
02:24:00 <WorkyBob> indeed
02:24:10 <WorkyBob> but in general, calling it fmap is better style
02:24:18 <lars9> i see.
02:24:20 <WorkyBob> or calling it (<$>) if you want to use it infix
02:24:31 <WorkyBob> > (*2) <$> [1,2,3]
02:24:33 <lambdabot>   [2,4,6]
02:25:24 <lars9> and 'return' converts a -> m a?
02:25:38 <lars9> :t return
02:25:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:25:48 <WorkyBob> yes, but it should really be called pure
02:25:58 <lars9> :t pure
02:25:59 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
02:26:11 <lars9> @src pure
02:26:11 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:26:17 <WorkyBob> @src [] pure
02:26:18 <lambdabot> pure = return
02:26:19 <Gracenotes> return makes some sense for IO
02:26:30 <WorkyBob> yeh, return makes sense as a synonym
02:26:34 <Gracenotes> like sequence and forever
02:26:36 <WorkyBob> in a lot of cases
02:26:48 <WorkyBob> heh, but sequence is an applicative function
02:27:15 <lars9> multiple notations on one function ... is sometimes confusing too
02:27:20 <Gracenotes> monadic naming seems to be influenced by IO and effectful ordering in that context
02:27:21 <WorkyBob> yep
02:27:32 <WorkyBob> lars9: it's because monads were discovered to be useful early on
02:27:43 <WorkyBob> but the more general classes higher up the tree only later
02:28:10 <lars9> i dunno Applicative yet, need more reading on it.
02:28:15 <WorkyBob> lars9: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/ <-- try this as another take on monads^H^H^H^H^H^H the tree that builds up to monads
02:28:59 <lars9> :t forM
02:29:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
02:29:49 <lars9> :t zipWithM_
02:29:51 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
02:30:09 <lars9> :t mapM
02:30:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:30:16 <WorkyBob> all 3 of those should be in applicative
02:30:17 <WorkyBob> not monad
02:30:45 <lars9> is forM x y = mapM y x?
02:30:49 <WorkyBob> yes
02:30:56 <Axman6> @src forM
02:30:57 <lambdabot> forM = flip mapM
02:31:00 <Axman6> @src flip
02:31:01 <lambdabot> flip f x y = f y x
02:31:12 <WorkyBob> some people like to write in the style of for x in [1,3,5,6,7] do this stuff
02:31:13 <Gracenotes> totally yessssssss dude
02:31:15 <Axman6> > flip f x y
02:31:16 <lambdabot>   Add a type signature
02:31:20 <Axman6> > flip f x y :: Expr
02:31:22 <lambdabot>   f y x
02:32:05 <Gracenotes> > forM [1,2,3] (replicate 2)
02:32:07 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
02:32:20 <lars9> i do prefer python's 'there is only one way for one thing' way... more friendly to newbies
02:32:23 <lars9> :D
02:32:33 <quicksilver> but it's not actually true.
02:32:37 <Axman6> but there isn't only one way to do things
02:32:45 <quicksilver> all languages have multiple ways to do things
02:33:04 <Gracenotes> lars9: that's the Python commuity's way of forcing idiomatic behavior in a hodge-podge language :P
02:33:12 <dancor_> well, there is more consensus in python
02:33:19 <dancor_> ya
02:33:25 <Gracenotes> the "pythonic" epithet ;)
02:34:06 <WorkyBob> I'm not sure there is more consensus in python
02:34:09 <ski> @type replicateM
02:34:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:34:23 <WorkyBob> there's more consensus about how to write things that don't tend to trip over runtime type checking
02:34:28 <WorkyBob> but that's not a problem we hit
02:34:40 <lars9> if i have a function a -> b, but i want a -> m b, i should just use pure f?
02:34:43 <dancor_> i do prefer qualified imports
02:34:47 <WorkyBob> lars9: no
02:34:48 <eivuokko> The scope is usually different.  The python "one-way" usually refers to expression/statement level, and there are very strong idioms at that level.  Haskell has only few idioms at that level.  (Function composition in few forms, really.)
02:34:53 <WorkyBob> pure f would give you m (a -> b)
02:35:02 <ski> lars9 : `pure . f'
02:35:08 <WorkyBob> or fmap pure f
02:35:17 <WorkyBob> or pure <$> f
02:35:18 <Gracenotes> useless use of fmap! >_>
02:35:21 <lars9> :t (pure . length)
02:35:22 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [a] -> f Int
02:35:26 <WorkyBob> Gracenotes: so true
02:35:30 <Gracenotes> :P
02:35:45 <lars9> :t pure <$> length
02:35:46 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [a] -> f Int
02:35:52 <lars9> :t pure $ length
02:35:53 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f ([a] -> Int)
02:36:00 <WorkyBob> :t return `liftM` length
02:36:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m Int
02:36:54 <lars9> :t (.)
02:36:56 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:37:05 <Axman6> > pure <$> length [1..10] :: Maybe Int
02:37:06 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:37:07 <lars9> :t ($)
02:37:08 <lambdabot> forall a b. (a -> b) -> a -> b
02:37:21 <ski> @type mapAndUnzipM
02:37:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
02:37:40 <quicksilver> I hate the way that error message exposes something implementation dependent where the type was defined.
02:37:48 <copumpkin> that's a pretty intense function
02:37:56 <Gracenotes> > (pure <$> length) [1..10] :: Maybe Int
02:37:57 <lambdabot>   Just 10
02:38:22 <ski> (quicksilver : .. seconded)
02:38:33 <Axman6> oh right, bount the list to length
02:39:24 <quicksilver> ski: the standard should mandate certain things about error messages. E.g. "In error messages built in types like Int may be referred to as Prelude.Int or Int, but by no other names"
02:39:28 <Gracenotes> speaking about useless uses of cat, echo "hello" | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat | cat
02:39:55 * Gracenotes wonders how long that can go on
02:41:44 <copumpkin> until you run out of FDs?
02:42:08 <lars9> what kind of projects do you use haskell on?
02:42:12 <dancor_> or bash 65k char limit?
02:42:20 <copumpkin> lars9: I do porn administration
02:42:56 <dancor_> does that make use of Set
02:42:58 <Gracenotes> I ray trace .. images of pumpkin doing porn administration.
02:43:05 <shapr> copumpkin: wtf?
02:43:10 * copumpkin whistles
02:43:28 <dancor_> i'm just glad that copumpkin is being safe
02:43:34 <shapr> Gee, I've used Haskell to index and sort mailing lists, hack on irc bots, get paid hack on webservers, and lots more.
02:43:34 <copumpkin> :)
02:43:44 <ski> echo "hello" | fix (cat |)
02:43:49 <Gracenotes> really though, I've made hash rainbow tables, a ray tracer, working on IRC bot, regexen...
02:43:49 <shapr> porn may be free of side-effects, but it's also very lonely.
02:43:57 <ivanm> shapr: you use haskell to hack on webservers?
02:44:03 <ivanm> so you write haskell code that writes code?
02:44:03 <ivanm> ;-)
02:44:07 <shapr> ivanm: Well, I got paid to work on HAppS for a year.
02:44:17 <ivanm> it's just the way you said it ;-)
02:44:28 <shapr> ivanm: And yes, pesco and I had a QuickCheckM instance that fuzzed http at one point years ago.
02:44:35 <ivanm> heh
02:44:36 <shapr> But John Hughes beat us to the punch with quviq, so we gave it up.
02:44:46 <ivanm> quviq? never heard of it
02:44:51 <ivanm> and what do you mean by "fuzzed"?
02:44:59 <shapr> @go protocol fuzzing
02:45:00 <lambdabot> http://en.wikipedia.org/wiki/Fuzz_testing
02:45:19 <ivanm> ahhhhh
02:45:27 <lars9> :t zipWithM_
02:45:28 <Gracenotes> garbage in, garbage out, huh
02:45:28 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
02:45:40 <shapr> I wonder if I still have the code for that lying around, that would be fun to resurrect.
02:45:57 <lars9> :t zipWithM
02:45:58 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
02:46:06 <quicksilver> a random thread interleave tester would be a very good tool for GHC.Conc testing.
02:46:44 <lars9> i can understand m [c], it's a monad containing a list of c, but what is m ()?
02:46:48 <lars9> :t ()
02:46:49 <lambdabot> ()
02:47:02 <lars9> :t m ()
02:47:03 <lambdabot>     Couldn't match expected type `() -> t' against inferred type `Expr'
02:47:03 <lambdabot>     In the expression: m ()
02:47:13 <Gracenotes> lars9: "m ()" is used when the result of the monad computation doesn't matter as much as the effects from it
02:47:15 <Gracenotes> generally
02:47:26 <Gracenotes> for example, print is IO ()
02:47:29 <shapr> How else could you do a void return in Haskell?
02:47:47 <ski> lars9 : s/it's a monad containing/it's a monadic action returning/
02:47:56 <eivuokko> lars9, () is called unit type, you can think of it as data () = () (not valid syntax).  It usually means "don't care" when you need concrete type (not type variable)
02:48:05 <shapr> hei eivuokko! long time no see.
02:49:12 <eivuokko> shapr, Hello.  Yes, been away.  How are you?
02:49:44 <shapr> Busy writing C#, how's life with you?
02:49:47 <Gracenotes> boolean is True | False... it's binary. Unit is unary: not two values, but one...
02:50:01 <copumpkin> or two
02:50:11 <copumpkin> or a hunded
02:50:15 <Gracenotes> no bottoms for you
02:50:18 <eivuokko> shapr, tried F# ? :)  I've been playing it with lately.  Although it's kinda horrible...wtb haskell for .net ;)
02:50:23 <copumpkin> *hundred even
02:50:49 <Axman6> Gracenotes: :(
02:50:58 <copumpkin> Gracenotes: do you like bottom?
02:51:23 <Gracenotes> well. you can catch most of them in the IO monad
02:51:42 <lars9> :t _|_
02:51:43 <lambdabot> parse error on input `|'
02:51:54 <lars9> m(_ _)m
02:52:13 <hatds> ?instances MonadIO
02:52:14 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
02:52:22 <Axman6> it always annoyed me that _|_ isn;t actually haskell
02:52:23 <Gracenotes> > let ~ (_,_) = undefined in 0.0
02:52:25 <lambdabot>   0.0
02:52:35 <shapr> eivuokko: I haven't tried F#, everytime I get the urge to do something fun with .NET I have SharePoint flashbacks and buy more hardware instead.
02:52:49 <Axman6> haha
02:52:54 <Gracenotes> actually, ~ is implicit but anyways
02:53:14 <Axman6> @quote shapr I haven't tried F#, everytime I get the urge to do something fun with .NET I have SharePoint flashbacks and buy more hardware instead.
02:53:14 <lambdabot> No quotes match.
02:53:22 <Axman6> @remember shapr I haven't tried F#, everytime I get the urge to do something fun with .NET I have SharePoint flashbacks and buy more hardware instead.
02:53:22 <lambdabot> Okay.
02:53:25 <Axman6> even
02:53:38 <shapr> At this point I have enough hardware that I could actually run a usable SharePoint server. Specifically, I have an eight core Xeon with 16gb of ram.
02:53:46 <eivuokko> shapr, Heh.  -.-'
02:53:50 <lars9> i wonder what haskell looks like in the eyes of someone who learn haskell as his/her 1st programming language.
02:54:14 <shapr> lars9: I find it more interesting to hear about what C looks like to someone who learns Haskell as his/her first language.
02:54:21 <Axman6> lars9: hopefully pretty nice
02:54:37 <Axman6> shapr: i could go find some and ask them
02:54:43 <shapr> lars9: I heard that there were a few student at Chalmers who had exactly that experience.
02:54:48 <lars9> maybe as easy as we see C
02:55:15 <shapr> I think it was either Anders or Björn who said that they had lots of trouble understanding C until someone told them that every function was in IO.
02:55:30 <eivuokko> lars9, With somewhat right background, haskell's pretty intuitive.
02:56:41 <quicksilver> shapr: that sounds a little too like what someone would say they thought because they knew other people wanted to hear it :)
02:56:44 * Axman6 likes writing referencially transparent C functions
02:56:46 <quicksilver> shapr: if it's true, though :)
02:57:10 <shapr> quicksilver: I don't know, I haven't spoken to anyone myself who had learned Haskell first.
02:57:13 <Gracenotes> Axman6: but how do you prove it??????? *wags eyebrows*
02:57:20 <Axman6> hmm, i thought i'd just written one, but it may not be, considering it will be have differently on differing hardware
02:57:22 * mux likes to use __attribute__((pure))
02:57:24 <lars9> i guess so, but i have no chance to experience that anymore. I'm already used to break down a problem into C code pieces. and found it's hard to think in the haskell's pure functional way.
02:57:42 <Axman6> mux: is that a real thing?
02:57:49 <mux> Axman6: GCC extension
02:57:50 <eivuokko> It's a gcc thing.
02:57:58 <quicksilver> mux: I like __attribute__((can_you_believe_how_ugly_this_syntax_is))
02:57:59 <Axman6> good enough for me. what's it do?
02:58:03 <mux> quicksilver: :-)
02:58:04 <Gracenotes> Axman6: well. I'd like to think of referential transparency within a runtime. not from runtime instance to runtime instance.
02:58:09 <mux> Axman6: tells the compiler your function is pure
02:58:12 <quicksilver> Axman6: gives the optimiser a hint.
02:58:21 <Axman6> and how do you use it?
02:58:24 <mux> except that there are pure and pure2 attributes with subtle differences but you get the idea
02:58:32 * Axman6 wants to show off to his lecturer is his current comp course
02:58:32 <quicksilver> Axman6: it can for example CSE expressions using that function
02:58:39 <quicksilver> Axman6: just like it can (already) CSE + and *
02:58:46 <quicksilver> because it already knows + and * are pure.
02:58:47 <Axman6> bah, i do CSE myself :P
02:59:06 <mux> Axman6: you add that __attribute__((pure)) stuff at the end of your function prototype
02:59:07 <ski> (Gracenotes : how about code mobility ? image save & restore ?)
02:59:14 <Axman6> ok, thanks :)
02:59:26 <quicksilver> as the optimiser gets better, opportunities for CSE may appear which aren't immediately obvious on inspection of the input source
02:59:30 <Gracenotes> ski: well. Then I guess it's part of the same runtime, in the context of that code.
02:59:30 <mux> oh, it seems pure2 is now named 'const'
02:59:48 <mux> what a bad naming
03:00:35 <Gracenotes> hmmm
03:00:43 <mornfall> quicksilver: I think it's that ugly so there's no risk of conflict with any sensible future standard. ;)
03:01:01 <mux> the 'const' attribute should be named 'pure', but I don't know how 'pure' should be named then
03:02:30 <Axman6> quicksilver: the thing we're doing at the moment involves speeding up a fucntion by checking for powers of 2 and replacing multiplies and modulus' with <<, >> and &
03:02:53 <Axman6> my version runs about 80% faster than the original :)
03:03:26 <Axman6> j =  j/k + (j%(k))*(n/k); --> j = (j >> powk) + ((j & mask) << nkpow);
03:03:26 <lars9> im learning xmobar's source code. could anybody help me on some problems? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5372#a5372
03:03:55 <mux> yay, STM code
03:03:57 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2519#a2519
03:04:06 <Neut> what is wrong with my list comprehension in that code?
03:04:10 <Axman6> g'day Neut
03:04:11 <mux> lars9: what are the problems?
03:04:21 <Neut> I get a non-exhaustive pattern error :/
03:04:24 <Neut> hey Axman
03:04:31 <Axman6> Neut: were you in the 1100 lecture today?
03:04:35 <Neut> good to see you
03:04:37 <Neut> sure was,
03:04:41 <Neut> were you?
03:04:41 <lars9> here is the code http://tinyurl.com/npu66q
03:04:50 <shapr> I wasn't!
03:05:00 <Axman6> yep :)
03:05:04 <mux> Neut: your healthPeople function takes a PeopleStats parameters, which is a list of triples
03:05:11 <Axman6> man, clem's so awesome
03:05:16 <Neut> why were you there lol?
03:05:19 <mux> Neut: yet you only define healthyPeople for the case where your list contains only one element
03:05:23 <Axman6> funsies :P
03:05:35 <mux> Neut: foo [x] = ... means you're matching the case where you get a list with exactly one element
03:05:45 <Axman6> heard there were baloons, and a friend of mine hasn't ever been to a clem lecture
03:06:32 <Neut> mux: how do I modify it so that isnt the case?
03:06:47 <Neut> Axman6: yeah he is good fun xD
03:07:32 <mux> Neut: healthyPeople peoples = [ name | (name,height,weight) <- peoples, healthy height weight ]
03:07:38 <Axman6> Neut: i think the function you want is: healthyPeople people = [(name, height, weight) | (name, height, weight) <- names, healthy height weight]
03:07:52 <mux> Neut: note the == True is redundant in your list compreension
03:07:52 <Axman6> uh, s/names/people
03:08:03 <mux> Axman6: no, he only wants to return the names of the persons
03:08:06 <Teggy> G'day all.
03:08:08 <Neut> why is that mux?
03:08:10 <Axman6> ah ok
03:08:31 <Axman6> @check \x -> (x == True) == x
03:08:33 <lambdabot>   "OK, passed 500 tests."
03:08:45 <mux> Neut: because the healthy function already returns boolean
03:08:47 <Axman6> G'day Teggy
03:08:50 <Neut> oh of course
03:08:54 <Neut> thanks alot
03:09:02 <mux> you're welcome
03:09:27 <Neut> say Axman6, if your in the exam hall next week and wana put my ID on your paper that would be fine too
03:09:29 <Neut> xD
03:09:45 <Axman6> mux: when i was taking the course Neut is now, i used to see if blah then True else False all the time
03:09:46 <mux> > 70/(1.83^2)
03:09:47 <lambdabot>   20.902385858042937
03:09:53 <mux> yay, I'm healthy.
03:10:00 <mux> Axman6: heh :-)
03:10:11 <Axman6> > 90/(1.9^2)
03:10:13 <lambdabot>   24.930747922437675
03:10:16 <Axman6> :(
03:10:20 <Axman6> only just
03:10:26 <mux> Axman6: nearly not healthy ;-)
03:10:33 <Axman6> bmi's not a great measure though
03:10:35 <Neut> *Argh*, I updated my kernal today and my computer is fail slow :(
03:10:38 * mux nods
03:10:56 <Axman6> i mean, i'm a bit tubby, but not exactly fat
03:12:09 <Neut> Axman6: we are pushed away from using ifs for some reason
03:12:19 <Axman6> good
03:12:22 <mux> because ifs are unaesthetic
03:12:28 <Axman6> they're often misused
03:12:47 <Axman6> they have their place, but there's often better waysx
03:12:49 <mux> I always try to have pattern guards instead of ifs if possible
03:13:10 <Axman6> i'll use if if the alternative is a case statement
03:13:24 <Neut> epic, I have to use Kate because emacs lags too hard.. what an update *cries*
03:13:39 <Axman6> tried vim?
03:13:45 <Axman6> (or... a good OS?)
03:13:45 <Axman6> >_>
03:13:55 <Neut> what do you use?
03:14:06 <WorkyBob> SubEthaEdit
03:14:09 <Axman6> OS X
03:14:19 <Neut> bleh not a mac fan
03:14:29 <WorkyBob> what do you use?
03:14:38 <Neut> ubuntu
03:14:40 <Axman6> Clem's got one, so's Ben L, and all the other awesome people :P
03:14:45 <WorkyBob> oh, no reason not to use a mac then
03:14:46 <Neut> hahaha
03:15:02 <WorkyBob> just a unix box... just happens to also run more apps
03:15:30 <Axman6> Neut: the reason we like macs is that basically you get the benefits of both windows and linux, without much of the fail of either
03:15:47 <WorkyBob> indeed
03:16:21 <Axman6> though, i do have a wintendo partition now
03:16:35 <Axman6> but the windows was free, so...
03:16:36 <Axman6> >_>
03:16:47 <WorkyBob> what do you need that for Axman6?
03:16:53 <Neut> if I win the lottery/find a wad of cash I might just buy one ;)
03:16:58 <Axman6> for wintendoing
03:17:10 <WorkyBob> oh, I have a PS3 for that
03:17:20 <WorkyBob> Neut: meh, the expensive thing is a lie
03:17:28 <Axman6> i want a PS3, but only because of the blu-ray and Cell
03:17:51 <WorkyBob> you can get them for $600 brand new
03:17:51 <WorkyBob> $450 even for refurbs
03:17:54 <Neut> WorkyBob: the fact it isn't free makes it expensive for me
03:18:09 <Axman6> was your current computer free?
03:18:13 <WorkyBob> hardware always costs money
03:18:26 <Axman6> not always
03:18:32 <WorkyBob> Axman6: meh, BluRay is actually about the only toy I haven't used on it
03:18:41 <Axman6> i can see three computers in this room that didn't cost me a cent
03:18:47 <Neut> sure wasn't, Im just saying Im not going to buy a new pc sa'll
03:18:52 <WorkyBob> ah, k
03:18:59 <Neut> dont have the dosh,
03:19:03 <WorkyBob> :(
03:19:25 * WorkyBob wants replicators
03:19:39 <Axman6> anyway, back to this assignment
03:19:47 <Neut> ditto
03:19:47 <WorkyBob> don't you mean binding?
03:19:50 <WorkyBob> >.>
03:24:59 <ivanm> @seen dibblego
03:25:00 <lambdabot> dibblego is in #haskell-in-depth, #xmonad, #functionaljava, #haskell and #scala. I last heard dibblego speak 1h 23m ago.
03:25:11 <ivanm> dibblego: isn't it cheating to ask proggit for help on an interview question? :p
03:26:15 <^Someone^> Look for dobblego
03:26:33 <ivanm> @seen dobblego
03:26:33 <lambdabot> dobblego is in #functionaljava, #scala and #haskell. I last heard dobblego speak 25m 19s ago.
03:26:41 <ivanm> *shrug* whichever nick he's using ;-)
03:27:01 <dobblego> yo
03:27:10 <ivanm> isn't it cheating to ask proggit for help on an interview question? :p
03:27:39 <dobblego> I've already submitted it -- just playing now :)
03:28:20 <dobblego> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5373#a5373
03:28:43 <ivanm> heh
03:28:47 <quicksilver> well if you can get proggit to help with your interview, then perhaps you can get proggit to help with the job when you get it. So it's not cheating, it's just an indication of one of your skill sets.
03:28:54 <ivanm> quicksilver: lol
03:29:11 <ivanm> @remember quicksilver well if you can get proggit to help with your interview, then perhaps you can get proggit to help with the job when you get it. So it's not cheating, it's just an indication of one of your skill sets.
03:29:12 <lambdabot> Good to know.
03:29:31 <WorkyBob> dobblego: perhaps tests might be better with quickcheck and a property that you can convert a number to words and back and get an id function
03:29:33 <WorkyBob> and the reverse
03:29:58 <dobblego> WorkyBob, g'luck using QC for testing that function
03:30:35 <dobblego> WorkyBob, I considered using QC for testing parts of it
03:30:36 * WorkyBob writes a quick parser for the word based version
03:30:40 <WorkyBob> done
03:30:42 <WorkyBob> etc...
03:31:23 <Neut> btw im doing your exam from last year ;()
03:31:50 <Axman6> i think i aced that exam
03:32:04 <Axman6> though... i did finish the course with 94%, so there's a good chance :P
03:34:31 <Saizan> is there a general name for the kind of testing QuickCheck does?
03:34:42 <Axman6> excessive
03:34:46 <Axman6> >_>
03:35:28 <dobblego> automated specification-based testing
03:36:28 <Saizan> looks like it, thanks
03:39:56 <ivanm> dobblego: well, I'd _hope_ you'd know :p
03:40:25 <ivanm> dobblego: though that guy I was telling you about that loves C# wanted to know why you listed NUnit (I think... one of them) as a "manual" test tool
03:40:40 <dobblego> because it is?
03:40:47 <dobblego> what guy who what?
03:41:01 <ivanm> at dinner, I was saying about a guy that loves C#
03:41:16 <dobblego> I've considered writing a proper test automation tool for .NET using C#
03:41:42 <Axman6> ivanm: still thinking of coming to ANU?
03:41:50 <ivanm> Axman6: yes
03:41:53 <ivanm> but it won't be till next year
03:41:55 <Axman6> :)
03:42:00 <dobblego> a better question might be, "what do you think is automated about nunit?"
03:42:08 <ivanm> true
03:42:22 <Axman6> i gave a talk today at my uni about how awesome ANU is. (which i think is true, it's an amazing place)
03:42:58 <Axman6> campus wide 802.11n wireless with WPA2, connected to a 100mbit internet connection
03:42:58 <ivanm> Axman6: I thought you _went_ to ANU... >_>
03:43:14 <Axman6> uh, not at my uni, my old college
03:43:28 <Axman6> (years 11 and 12)
03:43:39 <ivanm> ahhh
03:44:01 <ivanm> Axman6: so if you have old HW that can't use WPA, then you can't use wireless at ANU?
03:44:31 <Axman6> nah. there's an older network too, but it's less secure and slower
03:44:53 <Axman6> and you have tpo log in through a webpage before you can do anything on the network
03:45:21 <ivanm> ahhh, fair enough
03:45:24 <ivanm> that's what UQ uses
03:45:43 <ivanm> PITA, really, when I have to start up a browser just to let my email client work :@
03:45:58 <Axman6> and it's more restrictive. ANU-Secure (the awesome one) is basically a direct net connection, so you can do what ever you want (even torrent at 100mbit)
03:46:10 <Axman6> s/net/internet
04:18:57 <inbuninbu> i think i've got an interesting problem for you guys...
04:19:12 <inbuninbu> my problem is that i want to wait for input, process the input, and output the result
04:19:27 <inbuninbu> BUT! some of the evaluation might take a long time, and some of it won't. and i want to output as soon as the result becomes available
04:19:39 <inbuninbu> (there will continuously be more chunks of input coming in)
04:19:52 <inbuninbu> the crux: i could just use forkIO, but i need to avoid two threads outputting at the same time.
04:20:14 <inbuninbu> i could try to implement some kind of concurrent mailbox... but is there a more elegant solution that i'm overlooking?
04:20:54 <fR0D> hi i am new to haskell and so i am trying to write programs in it to learn it
04:21:07 <Baughn> inbuninbu: The output functions are lazy
04:21:15 <fR0D> can someone tell me how to take a series of integers enetered per line
04:21:17 <Baughn> inbuninbu: Or, rather, they accept lazy data structures just fine
04:21:25 <fR0D> and then process them one by one
04:21:30 <Baughn> fR0D: One per line?
04:21:42 <fR0D> yes each line has a integer
04:21:53 <Baughn> inbuninbu: So "print [1..]", for example, is not going to wait for all of [1..] to be evaluated before it starts printing
04:21:54 <fR0D> and say there are n such lines
04:21:55 <burp> from stdin or file?
04:22:01 <fR0D> stdin
04:22:17 <Baughn> fR0D: do ...; int <- fmap read getLine; ...
04:22:24 <mauke> readLn
04:22:31 <Baughn> ..or that. I keep forgetting that one.
04:22:36 <mauke> :t replicateM n readLn
04:22:37 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
04:22:37 <lambdabot>     In the first argument of `replicateM', namely `n'
04:22:37 <lambdabot>     In the expression: replicateM n readLn
04:22:40 <mauke> :t replicateM ?n readLn
04:22:41 <lambdabot> forall a. (?n::Int, Read a) => IO [a]
04:23:04 <Baughn> inbuninbu: That is, of course, assuming that you care about the order of your output
04:23:22 <inbuninbu> Baughn: yes that's it exactly. i don't care about the order of my output
04:23:29 <Baughn> inbuninbu: If you just want to print stuff as soon as it's evaluated, and don't care about the order, then a mailbox would be best
04:23:57 <Baughn> inbuninbu: (But take care to evaluate your data /before/ putting it in the MVar, otherwise it'll just be putting a thunk in there)
04:24:08 <fR0D> ok thanks i will try that
04:24:59 <inbuninbu> Baughn: i was afraid of that; i was hoping there was some beautiful trick using functors or something that i could use; i guess not
04:25:24 <Baughn> inbuninbu: Nope. What you're asking for is basically nondeterminicy
04:25:31 <Baughn> inbuninbu: You can't have that outside IO. :)
04:25:36 <Baughn> This is a feature. :P
04:25:52 <Baughn> inbuninbu: Oh, and be sure to know about the tradeoffs between MVar and Chan
04:26:20 <inbuninbu> Baughn: LOL. i thought though, that the list functor sort of provided nondeterminacy in some sense
04:26:55 <Baughn> inbuninbu: The list /functor/ just maps. The list applicative instance does, in a sense, but only through providing every possible option. In a deterministic order.
04:27:29 <Baughn> inbuninbu: And you're specifically wanting to get the result that evaluates fastest first in your result list. This is very, very indeterminate.
04:27:40 <Baughn> inbuninbu: Not referentially transparent at all. :)
04:28:06 <Baughn> inbuninbu: If your result values happen to be /equal/ you can use unamb, but I don't expect they are
04:28:41 <inbuninbu> Baughn: ok, i think i've got it. at least to move forward. haskell is one deep forest :-)
04:28:57 <inbuninbu> Baughn: thanks!
04:31:08 <Baughn> inbuninbu: Re: the functor/applicative confusion. I suggest you read the Typeclassopedia.
04:32:10 <inbuninbu> Baugn: thanks. actually i started chewing on that earlier today. it helps some, but will take more work on my part to really understand it well
04:37:48 <ski> @type Control.Concurrent.mergeIO
04:37:49 <ski> @type Control.Concurrent.nmergeIO
04:37:50 <lambdabot> forall a. [a] -> [a] -> IO [a]
04:37:51 <lambdabot> forall a. [[a]] -> IO [a]
04:38:08 <ski> inbuninbu : maybe those're helpful ?
04:38:47 <inbuninbu> ski: i saw those, but the documentation is sparse; almost a haiku
04:38:57 <inbuninbu> ski: so i'll have to play with them to really understand them, maybe
04:39:59 <fR0D> i am still unable to get it, suppose i have to print the sum of all the numbers how will i do it replicateM
04:40:19 <fR0D> *using rreplicateM
04:40:20 <Gracenotes> :O
04:40:54 <ski> compute the sum of the list monadically returned by the call to `replicateM'
04:41:14 <Gracenotes> hm. What is mergeIO supposed to do?
04:41:28 <Gracenotes> seems to merge two lists concurrently... why would you need it
04:42:22 <Saizan> Gracenotes: parallelize the evaluation, i guess
04:43:08 <ski> <http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v%3AmergeIO> "The mergeIO and nmergeIO functions fork one thread for each input list that concurrently evaluates that list; the results are merged into a single output list."
04:43:11 <Gracenotes> Saizan: hmmm. *checks out source*
04:43:29 * shapr boings
04:43:46 <Gracenotes> looks complicated.
04:43:57 <Gracenotes> uses an MVar and a semaphore
04:45:01 <Gracenotes> and involving a function called "suckIO"
04:45:53 <Gracenotes> and the MVar seems to be used for an impromptu Chan
04:46:33 <jacobian> I haven't really properly though this through yet, but I have a tree which is infinite and lazy, I want to have errors as a I produce the tree, is this difficult?
04:46:58 <Baughn> jacobian: No, that's what throw is for
04:47:00 <jacobian> And if not, what is an easy approach
04:47:34 <Gracenotes> exceptions. breaking control in exceptional cases
04:47:38 <ivanm> jacobian: why do you want errors?
04:47:46 <ivanm> aren't errors _bad_? :o
04:47:51 <Baughn> jacobian: Just realize that since it's lazy, the exceptions will show up as the tree is produced - eg. while it's being consumed
04:48:05 <Baughn> Nah, error-throwing from pure code is handy - to point out programming errors
04:48:46 <jacobian> So Control.Exception is the way to go
04:48:49 <Baughn> jacobian: For pure code, normally you'd augment the structure with some explicit error value. Either or Maybe exist for this purpose
04:48:59 <Baughn> Assuming you actually want to handle the error
04:49:10 <Baughn> jacobian: Read the documentation for throw carefully
04:49:21 <Gracenotes> there's also monads for this
04:49:31 <eivuokko> Maybe also a writer monad, if you need "a log."
04:49:34 <Gracenotes> er. what he said.
04:50:12 <jacobian> I need to give up if something goes wrong, so a log isn't really what I need
04:50:29 <quicksilver> Maybe is great for give up if something goes wrong
04:50:36 <quicksilver> give up (but with no more information abotu why you did)
04:51:07 <jacobian> Information about why would also be useful
04:51:19 <jacobian> I was using a hand rolled exception monad previously
04:51:36 <eivuokko> And why are you switching off it?
04:51:41 <ski> what if part of the tree "goes wrong" but you aren't actually using that part (for one use) ?
04:55:29 <jacobian> It should be ok for parts to go wrong that aren't encountered.
05:00:14 <ivanm> ^Someone^: surely you can get rid of the last two carets as well...
05:00:56 <^Someone^> I think when I tried Someone, it was in use/registered, but it was sometime abck
05:00:57 <^Someone^> back*
05:01:05 <^Someone^> However, I like this nickname now lol
05:01:58 <paper_cc> hmm, is <^Someone^> an infix lifted Someone constructor?
05:02:19 <ivanm> paper_cc: can't be infix, it has alphanumeric characters in it
05:02:28 <quicksilver> it is infix in that syntax though
05:02:30 <ivanm> and constructors have to start with a capital letter
05:02:38 <mauke> S is a capital letter
05:02:38 <quicksilver> it does.
05:02:39 <quicksilver> S
05:02:54 <ivanm> quicksilver: it starts with <, not S though...
05:02:58 <paper_cc> ivanm: Control.Applicative.Infix defines (<^) and (^>)
05:03:06 <quicksilver> no, that parses as <^ Someone ^>
05:03:13 <quicksilver> and as paper_cc says..
05:03:16 <ivanm> ahhh
05:03:26 * ivanm didn't think of that
05:05:45 <Gracenotes> but the parsing is only legal if something's on both sides of <^Someone^>
05:06:09 <Gracenotes> well. It lexes properly, but there are infixity issues, etc...
05:06:10 <^Someone^> Find two girls ; )
05:06:35 <Gracenotes> (blah <^ Someone ^>) isn't a legal section >_>
05:06:41 <Gracenotes> <_<
05:07:25 <ivanm> @slap ^Someone^
05:07:25 * lambdabot smashes a lamp on ^Someone^'s head
05:07:28 <Gracenotes> even if blah is a girl
05:07:36 <^Someone^> >.>
05:07:41 <ivanm> @type (<^)
05:07:42 <lambdabot> Not in scope: `<^'
05:07:50 <ivanm> @hoogle (<^)
05:07:50 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
05:07:56 <ivanm> what's just <^
05:07:58 <ivanm> ?
05:07:59 * paper_cc gives up the idea of lifted Num instances for his Applicative
05:08:08 <paper_cc> , [$ty|(<^)]
05:08:09 <lunabot>  luna: lexical error in string/character literal at end of input
05:08:12 <Gracenotes> @hoogle InfixApplicative
05:08:13 <lambdabot> No results found
05:08:18 <Gracenotes> @hackage InfixApplicative
05:08:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
05:08:27 <Gracenotes> yeah. weird thing.
05:08:41 <Gracenotes> but omg ^(+)^
05:09:01 <paper_cc> ivanm: (<^) = flip fmap, (^>) = (<*>)
05:09:21 <Gracenotes> it's like liftA2
05:09:26 <ivanm> @type (<*>)
05:09:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:10:00 <Gracenotes> type \f x y -> f <^ x ^> y == type liftA2
05:10:20 <paper_cc> err, x <^f^> y rather?
05:10:38 <Gracenotes> oh. right. it's flip fmap. yes
05:10:51 <ivanm> Gracenotes: I didn't know there was a type function...
05:10:52 <ivanm> ;-)
05:11:03 <ivanm> @hoogle type
05:11:03 <lambdabot> keyword type
05:11:04 <lambdabot> Language.Haskell.TH data Type
05:11:04 <lambdabot> Language.Haskell.TH.Syntax data Type
05:11:08 <paper_cc> , [$ty|flip fmap]
05:11:09 <lunabot>  luna: lexical error in string/character literal at end of input
05:11:13 <paper_cc> oh
05:11:15 <Gracenotes> |]
05:11:20 <paper_cc> , [$ty|flip fmap|]
05:11:21 <Gracenotes> ivanm: in my imaginary Haskell extension
05:11:23 <lunabot>  forall a b c . Functor a => a c -> (c -> b) -> a b
05:11:30 <ivanm> Gracenotes: ahhh
05:11:34 <Gracenotes> :P
05:16:27 <cnwdup> When loading haskell code using plugins' make and load_ I get "unknown symbol `base_GHCziBase_unpackCStringzh_closure'" Does anyone know how this can be caused? I do not know what to look for.
05:19:41 <quicksilver> JaffaCake: any idea?
05:19:45 <quicksilver> dons: ping
05:20:00 <JaffaCake> no idea
05:20:06 * JaffaCake is not plugin-compatible
05:20:17 <cnwdup> Lemmih, from the logs I know you have had this issue once. Can you help?
05:21:09 <paper_cc> @seen Lemmih
05:21:10 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 17h 30m 37s ago.
05:29:17 <paper_cc> , typ "flip id"
05:29:20 <lunabot>  "forall b c. b -> (b -> c) -> c"
05:29:26 <paper_cc> ivanm: ^^ =)
05:29:46 <ivanm> hmmm?
05:30:02 <paper_cc> the type function
05:30:21 <ivanm> that's a plugin
05:30:24 <ivanm> not a function AFAIK
05:30:30 <paper_cc> it is.
05:30:47 * paper_cc is reading $ty quasiquoter code
05:30:51 <ivanm> ahhhh
05:31:08 <mauke> , typ typ
05:31:09 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
05:31:17 <mauke> , typ "typ"
05:31:19 <lunabot>  "GHC.Base.String -> GHC.Base.String"
05:31:33 <paper_cc> , typQ "typ"
05:31:36 <lunabot>  AppT (AppT ArrowT (ConT String)) (ConT String)
05:34:29 <quicksilver> lots of the stuff in lunabot is not technically functions
05:34:37 <quicksilver> because it's not referentially transparent, etc.
05:34:41 <quicksilver> at least - not haskell functions.
05:34:49 <lars9> > (*2) 2
05:34:50 <lambdabot>   4
05:34:54 <quicksilver> more like functions on the syntax of haskell.
05:40:14 <lilac> , fix typ
05:42:07 <ivanm> lilac: which function's type do you want fixed?
05:42:08 <ivanm> :p
05:42:55 <idnar> haha
05:43:03 <jacobian> erg, the most annoying thing about layout is changing the name of things can screw up the code.
05:43:29 * ivanm agrees
05:43:44 <ivanm> it wouldn't be so bad if emacs' haskell-mode could auto-indent properly
05:43:59 <quicksilver> ivanm: it can.
05:44:04 <fasta> jacobian: like how?
05:44:06 <quicksilver> ivanm: if you get the correct indentation package.
05:44:07 <nvoorhies> keep hitting tab
05:44:12 <quicksilver> @where kuribas-indentation
05:44:12 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
05:44:17 <quicksilver> I don't recommend you keep hitting tab
05:44:19 <ivanm> quicksilver: oh?
05:44:24 <quicksilver> I recommend you get the better indentation mode :P
05:44:34 <ivanm> how do you integrate that into haskell-mode?
05:44:45 <fasta> I use Kuribas-indentation, although I hate some features of it deeply.
05:44:57 <fasta> E.g. "Illegal token <something>"
05:44:59 <ivanm> fasta: oh? which features?
05:45:01 <quicksilver> ivanm: I shall paste the relevant parts of my .emacs
05:45:07 <jacobian> complaining is always a good idea :) otherwise I'd never have seen that!
05:45:09 <ivanm> what does it call an "illegal token"?
05:45:18 <ivanm> jacobian: heh
05:45:20 <mmorrow> , help
05:45:22 <lunabot>  type of an expression:      , [$ty| \x -> x |]
05:45:22 <lunabot>  get info for a type/class:  , src ''Monad
05:45:22 <lunabot>  get info for a var/con:     , src 'fix
05:45:53 <fasta> ivanm: in short, its parser is broken. As a result you get those errors.
05:46:17 <fasta> ivanm: I have a complete example, if you really want it.
05:46:25 <ivanm> fasta: but its parser must be better than the default one if its indentation stuff is better?
05:46:47 <quicksilver> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5374#a5374
05:46:59 <quicksilver> its parser is better, but it is more painful when you find bugs in it
05:47:06 * mmorrow realizes that no one actually needed any help
05:47:08 <quicksilver> it is pretty unrepetent when it fails.
05:47:22 <ivanm> quicksilver: *nod*
05:47:25 <quicksilver> to be fair, kuribas fixed both bugs I found within a day.
05:47:31 <quicksilver> and I think he fixed one of fasta's bugs
05:47:42 <quicksilver> I'm sure he'd be open to fixing whichever one is bothering fasta now :)
05:47:54 <fasta> quicksilver: oh, he did? :) I didn't know he was developing it.
05:48:04 <mmorrow> paper_cc: did you find the $ty code somewhere?
05:48:08 <quicksilver> he's not developing it into new exciting directions
05:48:14 <quicksilver> but he is fixing bugs as they are reported.
05:48:20 <ivanm> quicksilver: just bug fixing?
05:48:24 <fasta> quicksilver: that's good enough for me for now
05:48:29 <quicksilver> I think stefan said it's going into the next release of haskell-mode, too.
05:48:32 <ivanm> is it going to be integrated into haskell-mode anytime soon?
05:48:35 * fasta happily installs the new version
05:48:37 <mmorrow> paper_cc: i need to put the rest of lunabot stuff into the repo (which currently just has the bare (rewritten) infrastructure)
05:48:57 <ivanm> quicksilver: are you psychic? :o
05:49:06 <ivanm> you answered my question before I asked it! :o
05:49:07 <paper_cc> mmorrow: looks like you put it on hpaste about 3 months ago
05:49:12 <paper_cc> mmorrow: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1514
05:49:15 <mmorrow> paper_cc: nice, totally
05:49:16 <quicksilver> ivanm: no, it's just network lag that makes it seem that way to you.
05:49:21 <quicksilver> ivanm: relativity is a bitch.
05:49:30 <quicksilver> actually I had 2 hours to research the answr and reply to you.
05:49:31 <ivanm> network lag of something _I_ said? :o
05:49:38 <ivanm> heh
05:49:41 <mmorrow> hpaste2search++
05:50:45 <mmorrow> paper_cc: ooh, that code needs to be cleaned :)
05:51:31 <paper_cc> mmorrow: that code looks evil :(
05:52:08 <fasta> ivanm: you should just be less predictable. ;)
05:52:08 <paper_cc> , (\[$ty|foo|] -> "bar") "baz"
05:52:12 <lunabot>  luna: <interactive>:1:51-70: Non-exhaustive patterns in lambda
05:52:17 <mmorrow> hehe
05:52:21 <paper_cc> , (\[$ty|foo|] -> "bar") "zOMG epic fail."
05:52:23 <lunabot>  "bar"
05:52:25 <mmorrow> haha
05:52:42 <ivanm> fasta: heh
05:53:03 <ivanm> quicksilver: would you know how much of that is necessary?
05:53:14 <quicksilver> of my paste?
05:53:18 <ivanm> yeah
05:53:27 <ivanm> I don't have any auto-mode-alist in my config, but it's still loaded
05:53:36 <ivanm> IIRC, I use the haskell-site-file that comes with haskell-mode
05:53:39 <quicksilver> then you don't need that.
05:53:48 <ivanm> *nod*
05:53:50 <quicksilver> I can certainly tell you what every line does :)
05:53:58 <ivanm> heh
05:54:05 <quicksilver> the autoloads set up certain files to be launched when certain symbols are called as functions.
05:54:20 <ivanm> what's max-lisp-eval-depth for?
05:54:27 <quicksilver> the -mode-hook makes sure all my haskell buffers have doc-mode, decl-scan and indentation-mode
05:54:31 <quicksilver> the parser is rec-descent
05:54:39 <quicksilver> I tend to write very deep haskell expressions
05:54:49 <ivanm> *nod*
05:55:05 <quicksilver> so the default level wasn't enough
05:55:05 <McManiaC> how can i easily download the whole sourcecode of the standard lib? is there something like darcs for that?
05:55:33 <fasta> quicksilver: what is the default level?
05:55:41 <mmorrow> @where+ lunabot http://moonpatio.com/repos/lunabot/ {- currently just the bare bot + ghc-api-eval + eval-rlimit-sandboxed-stdin->stdout (and no docs) -}
05:55:41 <lambdabot> Done.
05:55:45 <fasta> quicksilver: 900 seems a bit high.
05:56:08 <fasta> quicksilver: 600
05:56:14 <fasta> quicksilver: never mind. And o.O
05:56:45 <mmorrow> quicksilver: select! http://moonpatio.com/repos/lunabot/Dup.hs
05:56:56 <mmorrow> (stolen from oleg)
05:57:06 <ivanm> quicksilver: so I replace this with kuribas' indentation? (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
05:58:40 <Saizan> McManiaC: each package has its own repo
05:58:43 <hackagebot> Emping 0.6
05:58:55 <Saizan> McManiaC: they live under darcs.haskell.org/libraries/
06:02:11 <ivanm> "haskell-indent-region: Auto-reindentation of a region is not supported" :(
06:02:29 <ivanm> at least it shows kuribas' mode is loaded
06:03:44 <hackagebot> explicit-sharing 0.4.0.1
06:03:48 <quicksilver> mmorrow: awesome.
06:04:05 <quicksilver> ivanm: learn how to use indent-rigidly if you want to move regions left + right
06:04:08 <McManiaC> Saizan: darcs get darcs.haskell.org/libraries/getopt/        for example?
06:04:12 <quicksilver> ivanm: or the rectangle commands
06:04:21 <McManiaC> darcs failed:  Not a repository: darcs.haskell.org/libraries/haskell98 (darcs.haskell.org/libraries/haskell98/_darcs/inventory: openBinaryFile: does not exist (No such file or directory))
06:04:25 <McManiaC> is what i get
06:04:25 <quicksilver> ivanm: C-4 C-x TAB = region 4 places to the right.
06:04:30 <ivanm> quicksilver: I wanted to try re-indenting my entire file ;-)
06:04:31 <McManiaC> s/haskell98/whatever ^^
06:04:45 <Saizan> McManiaC:  with http:// in front
06:05:01 <McManiaC> ah! great :)
06:05:11 <paper_cc> is it possible to extend wxHaskell bindings?
06:06:07 * paper_cc wants dockable windows from contrib/fl but doesn't know how the bindings are actually generated
06:09:20 <shapr> @seen pesco
06:09:20 <lambdabot> I haven't seen pesco.
06:10:36 <cnwdup> Is it possible to express this pattern: \dyn -> maybe (maybe (...) (doSomethingElse) (fromDynamic dyn)) (doSomething) (fromDynamic dyn) into something like handle [doSomething, doSomethingElse] msg?
06:11:08 <cnwdup> Or is there another convenient way to avoid boilerplate?
06:11:47 <cnwdup> doSomething, doSomethingElse :: a -> m (), although not of the same a.
06:12:09 <fasta> cnwdup: sounds like you need rank-2 types.
06:12:26 <paper_cc> cnwdup: you can wrap doSomething* into Dynamic too if they are monomorphic
06:12:41 <paper_cc> cnwdup: (if you're sure you really need dynamics)
06:12:57 <ivanm> kuribas' mode isn't perfect, it still seems to be doing the whole indentation-cycle stuff
06:13:07 <cnwdup> paper_cc, for the signals (dyn), yes.
06:13:18 <cnwdup> Thanks. I'll use that approach if I cannot get it working with rank-2 types.
06:14:00 <lilac> you might be able to do something with an existential list type
06:14:56 <nibro> what's the language flag to GHC to enable generalized list comprehensions?
06:15:17 <nibro> the docs don't say, and there doesn't seem to be a suitable one in Language.Haskell.Extension in cabal
06:15:36 <ivanm> nibro: you mean the pragma to use in 6.10?
06:15:36 <lilac> looks like you want a list :: [exists a. Typeable a => a -> b]
06:15:40 <quicksilver> ivanm: it doesn't cycle in the same way. It's always TAB for the next valid position to the right, and BACKSPACE for the next valid position to the left
06:16:04 <quicksilver> ivanm: much more consistent. It's also much better at getting a concise list of valid positions.
06:16:05 <dcoutts> nibro: ParallelListComp
06:16:15 <ivanm> quicksilver: unless the two modes are interfering, since I haven't restarted emacs since I put that in
06:16:31 <nibro> dcoutts: so ParallelListComp enables both parallel and generalized comprehensions?
06:16:34 <ivanm> quicksilver: is there actually any docs for this?
06:16:53 <cnwdup> lilac, that gives me a parse error on `.'.
06:16:54 <dcoutts> nibro: oh, no sorry, perhaps they have not registered one. Is it in a released ghc yet?
06:17:02 <quicksilver> ivanm: only what is readable in the lisp source
06:17:15 <quicksilver> ivanm: you probably need to turn off the old indent mode
06:17:19 <ivanm> oh, if backspace is back one indent, how do you delete the char to the left of the cursor?
06:17:36 <quicksilver> it's only back one indent if the cursor is at the beignning of a line
06:17:44 <quicksilver> (beginning except for the intiial indentation, that is)
06:17:44 <nibro> dcoutts: not sure, I'm just reading the docs, there's no mention of a version or that it's not yet supported
06:18:02 <dcoutts> nibro: you're looking at the user guide for 6.10?
06:18:14 <nibro> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
06:18:20 <nibro> I believe so
06:18:36 <ivanm> quicksilver: *nod*
06:19:20 <dcoutts> nibro: bah, they're being naughty
06:19:41 <dcoutts> nibro: no hackage packages can use that extension therefore
06:19:58 <nibro> dcoutts: I wonder if that's deliberate... :)
06:20:04 <dcoutts> heh
06:20:21 <ivanm> what? what can't a hackage package use?
06:20:31 <nibro> generalized list comprehensions
06:20:55 <ivanm> why doesn't hackage accept them?
06:20:58 <nibro> I can dig around in the ghc source to see what they're doing there
06:21:04 <dcoutts> nibro: please
06:21:16 <nibro> ivanm: because the extension is not registered with cabal, so cabal wouldn't recognize the flag
06:22:26 <cnwdup> Reading the Rank-N types wiki article: One can unpack existential types?
06:22:51 <ivanm> nibro: as in a compile-time-flag?
06:23:03 <ivanm> would it accept it if it's listed as a PRAGMA in the actual source file?
06:23:30 <fasta> cnwdup: you cannot unpack existential types.
06:23:39 <quicksilver> well, arguably that's what "case" does
06:23:44 <quicksilver> it depends what you think unpacking means.
06:24:09 <nibro> ivanm: as in a flag corresponding to -XParallelListComp for the parallel ones
06:24:09 <cnwdup> quicksilver, then how can Iunpack a type and how I cannot?
06:24:50 <nibro> ivanm: yes, a source pragma would still work, but that's assuming that there actually is a flag to use
06:25:07 <quicksilver> cnwdup: case x of MkFoo y -> ....
06:25:14 <nibro> ivanm: and since GHC supposedly defers to cabal for the flags, that doesn't seem like it would be the case
06:25:23 <quicksilver> where MkFoo is the constructor of an existential
06:25:33 <quicksilver> is one possible interpretation of the phrase "unpack an existential"
06:25:46 <cnwdup> Ah, but I cannot pattern match against y, right?
06:26:28 <cnwdup> Although -- as I understand the example given on the Rank-N types page -- I can. Oo
06:27:09 <cnwdup> Ah, my bad. No it doesn't suggest that.
06:27:13 <quicksilver> depends what you think pattern match means.
06:27:22 <quicksilver> case x of MkFoo y -> *is* a pattern match.
06:27:27 <dcoutts> nibro: ohhh, it's called TransformListComp
06:27:43 <dcoutts> nibro: but has no documentation
06:27:55 <quicksilver> case x of MkFoo (y:ys) -> would be a more complex pattern match, and still permitted.
06:28:03 <quicksilver> (if it made type-sense)
06:28:18 <quicksilver> what you can't do is unpack the MkFoo constructor with a let. It has to be a case.
06:29:05 <cnwdup> But I cannot do case foo of MkFoo (Bar a b) -> ...; MkFoo (Baz a) -> ...?
06:29:41 <nibro> dcoutts: Transform O_o
06:29:44 <dcoutts> nibro: you might like to point out on the ghc users list that it's a silly name given what it's called everywhere else
06:30:00 <dcoutts> nibro: adding new alias and deprecating old ones is possible
06:30:24 <nibro> dcoutts: indeed, it sounds like a verb form of the "AllowOverlappingInstances" style rather than the nicer "OverlappingInstances" kind
06:30:38 <dcoutts> nibro: it's also annoying that in the user guide where the extensions are described the extension name is not given.
06:30:48 <nibro> dcoutts: I'll flag this on the ghc list
06:30:50 <dcoutts> nibro: the state of docs for the extensions is pretty poor
06:31:23 <dcoutts> nibro: perhaps we can shame someone into cross referencing them and adding haddock docs for the existing ones in Language.Haskell.Extension
06:32:54 <nibro> dcoutts: maybe I should wait to post until I've gone through the whole documentation, there may be more rocks to overturn... ;-)
06:33:08 <dcoutts> nibro: I expect there are
06:33:18 <dcoutts> nibro: a barrage of complaint is no bad thing though :-)
06:33:19 <nibro> fun times ahead then :)
06:33:36 <nibro> indeed, criticism is only healthy :-)
06:34:03 <quicksilver> cnwdup: you can do that, yes.
06:34:12 <quicksilver> cnwdup: or, I'd be surprised if you couldn't.
06:34:58 <cnwdup> quicksilver, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2520#a2520 ghci doesn't like that.
06:35:44 <RayNbow> > let weird ~(x,y) = (1,x); crazy = weird crazy in crazy
06:35:45 <lambdabot>   (1,1)
06:36:08 <RayNbow> > let weird (x,y) = (1,x); crazy = weird crazy in crazy  -- this crashes GHC 6.10.1 in Windows :p
06:36:13 * nibro thinks there should be an NPlusK flag
06:36:13 <lambdabot>   mueval-core: Prelude.read: no parse
06:36:13 <lambdabot>  mueval: ExitFailure 1
06:37:40 <quicksilver> cnwdup: yes, but that's not becausey ou can't use case on them
06:37:44 <astrobunny> phew. parsec is pretty cool.
06:37:48 <quicksilver> cnwdup: it's because you don't know what type is inside the box.
06:37:52 <cnwdup> quicksilver, ok
06:37:52 <astrobunny> i never thought i would write parsers like this
06:38:28 <quicksilver> cnwdup: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2520#a2521
06:38:51 <cnwdup> quicksilver, ok. Now I get what you meant.
06:38:52 <cnwdup> Thanks.
06:38:54 <quicksilver> cnwdup: example of how you can pattern match through an existential.
06:39:08 <quicksilver> cnwdup: what you tried to do was take a different branch depending what the actual type in the box was.
06:39:12 <quicksilver> cnwdup: you can't do that, because you don't know
06:39:24 <quicksilver> nobody knows what the type is inside the box :)
06:39:31 <quicksilver> this is the problem that Typeable solves
06:39:44 <quicksilver> - giving you a reification for every type so you can dispatch on that.
06:39:51 <quicksilver> it's a pretty big hammer, though.
06:47:58 <nibro> hmm, unboxed tuples (# x, y #) are presumably enabled with UnboxedTuples, but the docs say the (# and #) lexemes are enabled by MagicHash
06:48:27 <nibro> when would you ever want those lexemes without UnboxedTuples, and vice versa?
06:50:06 <Baughn> nibro: For functions with # in the name
06:50:27 <Baughn> touch#, unsafeCoerce#, etc.
06:51:15 <ivanm> with # denoting unboxed?
06:51:22 <Baughn> No, denoting internal
06:51:35 <nibro> Baughn: sure, I'm aware of those, what I meant was that (# #) lexemes have no use if UnboxedTuples aren't on, and you can't use UnboxedTuples without the (# #) lexemes, or?
06:52:00 <Baughn> nibro: The lexeme MagicHash turns on is #, not (#
06:52:35 <Baughn> (# is a combination of two lexemes
06:53:02 <nibro> Baughn: nope
06:53:17 <nibro> Baughn: you can still use # as an operator with MagicHash on
06:53:37 <nibro> Baughn: and the Lexer generator lists the lexemes as (# and #)
06:53:47 <Baughn> Hm. Well, that's odd then
06:54:08 <nibro> Baughn:... but now you got me to look at the source, which solved the mystery
06:54:10 <fasta> Is there a zip type class?
06:54:10 <nibro> :)
06:54:35 <nibro> Baughn: those things *are* enabled by the UnboxedTuples extension, it's just the docs that are wrong
06:54:48 <fasta> There is a type class for map, fold, filter, with some trouble, but no zips, AFAIK.
06:55:03 <nibro> fasta: what would you want to parametrize the class over?
06:55:40 <fasta> nibro: I can write it myself, that is not the problem. But I was thinking of e.g. zipping a Data.Sequence.
06:56:01 <fasta> nibro: or zipping arrays
06:56:07 <nibro> fasta: right, I see, that's not an unreasonable idea I guess
06:56:13 <fasta> nibro: really, there is a lot of things one could zip.
06:56:31 <nibro> fasta: I would guess Data.Sequence already has a zip-like function, no?
06:57:06 <fasta> nibro: it doesn't.
06:57:37 <fasta> nibro: you can easily write one, though, which is what I did now, but this was not just about Data.Sequence.
06:58:07 <quicksilver> fasta: you can zip an arbitrary Traversable with an arbitrary Foldable
06:58:16 <quicksilver> fasta: my code for this is on the wiki
06:58:40 <quicksilver> zipWithTF :: (Traversable t,Foldable f) => (a -> b -> c) -> t a -> f b -> t c
07:00:03 <quicksilver> although some unmentionable "improved" my code by replacing it with a less clear version which uses an unnecessarily generic monad while my version used a neat supply monad.
07:00:06 <quicksilver> but that's wikis for you.
07:00:44 <fasta> quicksilver: why don't you put it on hackage? It certainly is more useful than hnop.
07:00:59 <quicksilver> seems silly to put a single function on hackage.
07:01:07 <quicksilver> If anything it should just go into Traversable
07:01:17 <quicksilver> http://www.haskell.org/haskellwiki/Foldable_and_Traversable
07:02:44 <fasta> quicksilver: it's not silly. Putting a package that does not compile on hackage is silly.
07:03:01 <nibro> infix type constructors are enabled by -XTypeOperators ?
07:03:13 <quicksilver> something else being *more* silly is not a good enough reason ;)
07:05:20 <nibro> apparently they are on by default. Hrm!
07:06:30 <fasta> quicksilver: it's just less work to do cabal install $function than to do copy paste. Also, think of the network effects. When someone just browses Hackage they might think, oh, that's nice and install it. As a result more code becomes more general.
07:07:09 <Baughn> Well, except in practice Hackage is becoming too big to just browse. :)
07:07:17 <dcoutts> search!
07:07:22 <quicksilver> yes, but I think those advantages are also observed if I get the functions added to Data.Traversable itsel.
07:07:23 <dcoutts> hoogle/hayoo
07:07:37 <_SamB_> maybe it's just too disorganized
07:07:55 * dcoutts agrees with quicksilver 
07:08:14 <nibro> dcoutts: is there a reason why infix type constructors are allowed without naming a specific extension?
07:08:15 <fasta> quicksilver: yes, that would even be better.
07:08:41 <fasta> And there are too many (useless) packages on Hackage too.
07:08:41 <nibro> dcoutts: I'm letting you answer to all the sins of the GHC team here ;)
07:08:54 <ivanm> quicksilver: why do you use (lambda nil haskell-indentation-mode)?
07:09:12 <dcoutts> nibro: sorry, you'll have to ask on the ghc list or ask JaffaCake in #ghc
07:09:32 <nibro> dcoutts: alright, I'll do that
07:10:55 <quicksilver> ivanm: because there isn't (or wasn't) a turn-on-haskell-indentation-mode I could use.
07:10:57 <jav> Hi there! cabal question: My application includes a shell script that I would like to have installed in some way alongside the main program. How do I go about this? Is this some sort of special 'executable' or a 'data file' or something?
07:11:18 <ivanm> quicksilver: you can't just use it directly? seems to be working here... >_>
07:11:29 <quicksilver> then i dunno ;)
07:11:47 <ivanm> heh
07:11:48 <ivanm> also, why do you make (quote (...)) explicit rather than just '(..) ?
07:11:58 <dev31212> hi all
07:12:08 <ivanm> quicksilver: ahhh, looks like there is now
07:12:12 <ivanm> turn-on-haskell-indentation
07:12:17 <dev31212> is there any standard, sort of scientigfic process for identifying redundant cases in functions
07:12:20 <dev31212> and reducing them out?
07:13:07 <dev31212> Like one might perform in binary algebra, etc..
07:13:43 * doserj remembers why he doesn't use haskell-indentation-mode. It somehow kills delete-selection-mode...
07:14:41 <Baughn> Ugh, delete-selection mode..
07:15:04 <Baughn> I need to mark regions for so many /other/ reasons than copying them, that would make me lose my mind. :/
07:15:19 <ivanm> quicksilver: I take it back... the documentation says it's there, but it isn't :s
07:15:37 <dev31212> Is there any such proecess, or must I rely on intuition and experience?
07:15:39 <dev31212> Which is fine
07:15:40 <ivanm> doserj: oh? what's delete-selection-mode? selecting something and pressing delete/backspace to delete it?
07:15:47 <dev31212> Just thought there might be some method to this
07:15:48 <Baughn> dev31212: In the absence of guards, it should be possible to automate it. With guards..
07:16:01 <dev31212> hmmm
07:16:02 <Baughn> dev31212: Well, -Wall does some of it (without guards)
07:16:03 <doserj> ivanm: yes
07:16:23 <dev31212> Baugn, I see, thanks
07:16:38 <Baughn> I think it assumes guards are always true, though
07:16:55 <dev31212> ok
07:17:57 <fasta> quicksilver: The generic filter definition seems to be wrong: filter (>(23::Int)) [1..50] :: (Control.Applicative.Applicative f,
07:17:57 <fasta>                                 Monoid (f Int)) =>
07:17:57 <fasta>                                f Int
07:18:21 <fasta> quicksilver: or is it so general that it also overloads on the return container?
07:19:13 <fasta> Oh, yes, it appears it does that. It's not something I like :)
07:22:29 <quicksilver> yes that was more by way of example
07:22:51 <quicksilver> it wasn't clear what would be useful.
07:25:24 <fasta> quicksilver: a filter which returns the same type as it got would make sense to me. No unresolved overloading errors etc.
07:27:17 <dev31212> If I post a small code segment, Baugn, would you mind just taking a quick look to see if it can be reduced?
07:27:20 <dev31212> Its just 15 lines
07:27:24 <Zao> dev31212: hpaste it.
07:27:30 <dev31212> The code works, I just dont want to enforce  bad habits
07:27:31 <dev31212> ok Zao
07:28:46 <dev31212> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5375#a5375
07:28:51 <dev31212> Ok I posted the whole thing actually
07:29:02 <dev31212> The function I am seeing if it is reducible is the my_remove function
07:29:07 <dev31212> which removes an elemt from the list.
07:29:43 <quicksilver> fasta: well if you constrain its type signature, it does?
07:29:57 <quicksilver> @type foldMap
07:29:58 <lambdabot> Not in scope: `foldMap'
07:30:08 <fasta> quicksilver: yes, that's what I did a few minutes ago.
07:30:21 <Apocalisp> @type Foldable.foldMap
07:30:21 <quicksilver> my code has the type sig constrained too :)
07:30:22 <lambdabot> Couldn't find qualified module.
07:30:28 <Apocalisp> @type data.Foldable.foldMap
07:30:29 <lambdabot> parse error on input `data'
07:30:49 <fasta> quicksilver: there was no Applicative instance for Data.Sequence, so, I just wrote one. Although, I haven't checked the laws.
07:30:54 <Apocalisp> @type Data.Foldable.foldMap
07:30:55 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
07:31:00 <Apocalisp> \o/
07:31:08 <doserj> dev31212: typically you don't have to pattern match on the case for a single element list.
07:31:18 <Berengal> Is there a way to hide a package in just one module?
07:32:04 <doserj> dev31212: my_concat just seems wrong.
07:32:30 <Saizan> Berengal: tried {-# OPTIONS_GHC -hide-package foo #-} ?
07:33:29 <dev31212> doserj, yeah Im looking at my_remove at the moment though
07:33:40 <dev31212> doserj, ok
07:33:53 <dev31212> yeah I wwas thinking single ement matching might noit be needed
07:34:29 <Berengal> Saizan: That tells me "unknown flag"
07:34:52 <dev31212> ok, let me see if I can remove the single element case
07:35:58 <doserj> dev31212: you expect my_remove to be called with counter = 0?
07:36:32 <dev31212> yes doserj
07:36:42 <dev31212> I could add another wrapper to do that by default
07:36:54 <dev31212> the function is my_remove;
07:36:58 <lilac> fasta: if you used the normal Applicative instance for Monads, it will obey the laws
07:36:59 <dev31212> my_remove'
07:37:10 <dev31212> I was going to add simply My_remove which calls it with 0 for the counter
07:37:22 <cnwdup> > (+1, 'h':) &&& (42, "ello")
07:37:23 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)A section must be encl...
07:37:35 <cnwdup> > ((+1), ('h':)) &&& (42, "ello")
07:37:36 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
07:37:36 <lambdabot>    arising from a use of `Control...
07:37:44 <doserj> dev31212: well, instead of incrementing counter and testing index==counter, you can also decrement index, and test index==0
07:37:48 <cnwdup> Mh, what was the function to change both values of a tupel?
07:37:50 <fasta> lilac: What do you mean? I haven't really used Applicatives.
07:37:57 <dev31212> soderj, ahh!
07:38:03 <dev31212> thanks, thats much better
07:38:36 <lilac> fasta: instance Monad m => Applicative m where pure = return; (<*>) = ap
07:38:50 <fasta> lilac: but Sequence is not a monad.
07:39:05 <fasta> lilac: never mind
07:39:08 <fasta> lilac: it is.
07:40:07 <doserj> dev31212: of course, then you can directly pattern match agains 0, instead of having a guard
07:40:10 <lilac> fasta: remember that a Seq is semantically just a stricter form of []
07:41:14 <fasta> lilac: What exactly does an Applicative do? Pure is obvious, but <*>?
07:41:21 <quicksilver> fasta: ap
07:41:23 <quicksilver> :t ap
07:41:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:41:25 <fasta> lilac: I thought it was just like fmap
07:41:36 <dev31212> doserj, right
07:41:40 <dev31212> sounds much better
07:41:40 <fasta> :t fmap
07:41:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:41:48 <dev31212> thats exactly the jkind of info I needed
07:41:51 <dev31212> best practices
07:41:53 <dev31212> thanks
07:42:06 <quicksilver> fasta: instead of defining applicative with pure + <*>, you can define it with pure + sequence
07:42:10 <doserj> fasta: (<*>) = ap = liftM2 ($)
07:42:15 <quicksilver> fasta: maybe that's a better intuition.
07:42:32 <quicksilver> fasta: ... it says you can run lots of actions, one after another, but none of them depends on the results of the earlier ones
07:42:41 <quicksilver> (i.e. you accumulate all the results in a list)
07:42:41 <fasta> quicksilver: but if they are the same, why don't we just have deriving Applicative?
07:42:49 <fasta> Or just dump Applicative?
07:42:58 <quicksilver> it's not the same as monad
07:43:01 <Berengal> Saizan: I got it working with {-# OPTIONS_GHC -ignore-package=foo #-}
07:43:03 <quicksilver> sequence isn't engouhg to define monad
07:43:09 <quicksilver> you can't derive >>= from sequence
07:43:12 <quicksilver> which is rather the point, here.
07:43:29 <quicksilver> monads can use the result of earlier effects in later effects
07:43:33 <quicksilver> applicatives can't.
07:43:39 <quicksilver> actually the paper is rather readable.
07:44:39 <fasta> I never ran into any performance problems with monads, so when I read the Applicative paper, it seemed kind of pointless.
07:45:03 <fasta> Actually, I had some laziness issuess, but nothing with parsers or anything like that.
07:45:04 <byorgey> performance isn't the issue.
07:45:23 <fasta> For _high-performance_ parsing, I would not use Haskell.
07:45:26 <byorgey> or at least, not the only one.
07:45:39 <byorgey> Applicative often lets you code things in a more natural (*applicative*) style.
07:45:50 <Berengal> Saizan: Actually, I didn't... It doesn't complain, but it doesn't hide the package either
07:46:27 <quicksilver> byorgey: not really, you can code in that style with monads too :P
07:46:36 <lilac> fasta: <*> applies a function in the functor to a value in the functor to produce a result in the functor
07:46:43 <quicksilver> byorgey: I think that's not really the point of applicative, although it's possible an insight Applicative makes.
07:46:52 <fasta> byorgey: doserj defined one of the methods in terms of monads and the other one is equivalent to return.
07:47:03 <gwern> @quote stricter
07:47:03 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
07:47:06 <fasta> byorgey: or what quicksilver said.
07:47:29 <quicksilver> the point of applicative is that some things are applicative which aren't actually monads.
07:47:41 <lilac> not many things, though...
07:47:46 <quicksilver> no, not many at all :)
07:48:29 <Berengal> ZipList
07:48:45 <lilac> Berengal: got a second example? ;-)
07:48:47 <Berengal> It's the only non-monad applicative I know of...
07:49:10 <Berengal> Zip... maps?
07:49:14 <lilac> hehe
07:49:20 <quicksilver> ZipList is actually a monad.
07:49:35 <quicksilver> just a different one to []
07:49:37 <lilac> quicksilver: you sure?
07:49:45 <quicksilver> if you restrict to infinite streams
07:49:48 <quicksilver> then diagonal is join
07:49:56 <lilac> ah right, on infinite streams it's a monad
07:50:01 <lilac> but not on finite ones
07:50:07 <quicksilver> well it is, if they're fixed length
07:50:15 <quicksilver> e.g. streams of length 8
07:50:23 <quicksilver> again, diagonal
07:50:24 <lilac> that's also true, but that's a rather boring case of applicative
07:50:25 <quicksilver> (I think)
07:50:32 * quicksilver shrugs
07:50:37 <Berengal> Does that make arrays of a gievn size monads?
07:50:44 <Berengal> given*
07:50:45 <quicksilver> makes ZipList a bad example of an Applicative which isn't a monad, though.
07:50:49 <lilac> any fixed structure F a built from a's is an applicative
07:51:03 <quicksilver> Berengal: yes, same idea.
07:51:11 <quicksilver> Berengal: given an array of arrays, take the diagonal
07:51:22 <lilac> quicksilver: ZipList for finite lists is still a good example
07:51:37 <lilac> (finite but not necessarily equally sized lists)
07:51:40 <quicksilver> I think the applicative parsers is a good example.
07:51:51 <lilac> aren't they usually monads too?
07:51:54 <quicksilver> no
07:52:01 <quicksilver> because that's the point
07:52:10 <quicksilver> the applicative-ness lets you do first-letter optimisation
07:52:17 <quicksilver> build parser tables as you go
07:52:21 <lilac> i thought the point was, you could semantically make them monads, but you'd lose optimization opportunities
07:52:28 * quicksilver ponders
07:52:34 <lilac> so in a sense they /are/ monads, but don't have a Monad instance
07:52:42 <quicksilver> depends how you define them.
07:52:51 <quicksilver> if you define them concretely with the first-letter tables visible
07:52:55 <quicksilver> then there is no way to make them a monad
07:53:10 <Berengal> lilac: Depends on if you want to pull their inner workings into the semantics...
07:53:11 * lilac ponders
07:53:37 <quicksilver> data Parser a = ([Char],String -> (a,String))
07:53:43 <jacobian> I have a routine that as it searches also carries out some side computation as a result which is quite expensive and I want to keep.
07:53:48 <quicksilver> or something.
07:53:49 <jacobian> I want something like 'find' with type (a -> Maybe b) -> [a] -> Maybe b
07:54:00 <jacobian> Does such a thing already exist?
07:54:01 <quicksilver> the error applicative which collects multiple errors is another good one
07:54:05 <quicksilver> (Which is not a monad)
07:54:29 <lilac> quicksilver: data Parser a = Data.Map Char (Either (Maybe a) (Parser a))?
07:54:54 <quicksilver> jacobian: head . catMaybes . map f
07:55:02 <quicksilver> lilac: that kind of thing, yes. more than one way to do it.
07:55:19 <quicksilver> jacobian: well, need a safe version of head.
07:55:19 <centrinia> Is catMaybes similar to mappend?
07:55:20 <jacobian> cool
07:55:26 <quicksilver> msum . map f
07:55:29 <quicksilver> that's better
07:55:39 <quicksilver> > msum [Just 3, Just 4, Nothing, Just 5]
07:55:40 <lambdabot>   Just 3
07:55:41 <doserj> Compose f g in general, for applicatives f and g
07:55:48 <quicksilver> > msum [Nothing, Just 3, Just 4, Nothing, Just 5]
07:55:49 <lambdabot>   Just 3
07:55:59 <quicksilver> msum is "first success" for a list of maybes.
07:56:02 <jacobian> perfuct
07:56:04 <centrinia> msum [Nothing]
07:56:08 <centrinia> > msum [Nothing]
07:56:09 <lambdabot>   Nothing
07:56:22 <quicksilver> doserj: sure, but that's only useful if you have a stock of other interesting applicatives to compose.
07:56:43 <doserj> quicksilver: you have, any monad for example :)
07:57:15 <quicksilver> well yes, but in many cases that does in fact lead to a monad again
07:57:19 <centrinia> Is there a function ( \x -> case x of { Nothing -> []; Just x' -> [x'] } ) in the Prelude?
07:57:25 <quicksilver> but agreed there are cases where it doesn't.
07:57:30 <lilac> @type fmap (fmap msum) fmap :: (a -> Maybe b) -> [a] -> Maybe b
07:57:30 <quicksilver> centrinia: maybeToList
07:57:31 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> Maybe b
07:57:34 <quicksilver> @hoogle maybeToList
07:57:35 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:57:53 <lilac> @type (msum <$>) <$> fmap :: (a -> Maybe b) -> [a] -> Maybe b
07:57:54 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> Maybe b
07:58:00 <lilac> @type (msum <$>) <$> (<$>) :: (a -> Maybe b) -> [a] -> Maybe b
07:58:01 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> Maybe b
07:58:03 <lilac> yeah
07:58:17 <centrinia> Okay, catMaybes = concatMap maybeToList ?
07:58:24 <lilac> @src catMaybes
07:58:25 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:58:27 <fasta> quicksilver: the module "illegal token" error in the haskell indent mode has not been corrected, btw.
07:58:34 <idnar> @type concatMap maybeToList
07:58:36 <lambdabot> forall b. [Maybe b] -> [b]
07:58:54 <lilac> @check \x -> catMaybes x == concatMap maybeToList x
07:58:55 <lambdabot>   "OK, passed 500 tests."
07:59:04 <centrinia> @type catMaybes
07:59:05 <lambdabot> forall a. [Maybe a] -> [a]
07:59:16 <centrinia> Their types are different. :(
07:59:19 <quicksilver> fasta: send an email to kuribas. Or me :)
07:59:48 <lilac> centrinia: hehe :)
07:59:58 <dev31212> hi centrenia
08:00:02 <dev31212> do any great good?
08:00:12 <centrinia> dev31212, not yet.
08:00:19 <doserj> quicksilver: I have a 2-line patch to make it work together with delete-selection-mode :)
08:01:06 <lilac> dev31212: FOR GREAT JUSTICE!
08:01:13 <centrinia> > bmi' 85 (5*12+7) -- I wonder if anyone cleared lambdabot's defined functions buffer.
08:01:14 <lambdabot>   Not in scope: `bmi''
08:01:19 <quicksilver> doserj: email that to kuribas too then :)
08:01:49 <fasta> quicksilver: Are you this one btw? http://www.linkedin.com/pub/jules-bean/1/5b5/29a
08:03:28 <gwern> @fact XMC
08:03:28 <lambdabot> I know nothing about xmc
08:06:49 <lilac> gwern: XMC! = XMC * (XMC - 1) * ... * 1
08:07:07 <gwern> lilac: lol?
08:07:28 <gwern> anyways, I'm starting to suspect that the reason there's no happstack entry in the HCAR is because happs has never been in HCAR...
08:09:11 <gwern> no wait. here's one, from 2007
08:11:29 <gwern> ...and only in 2007
08:11:39 <gwern> although it's interesting to look at the very first HCAR http://www.haskell.org/communities/11-2001/html/report.html
08:11:47 <gwern> haskell has come a very long way in just 8 yearsz
08:12:55 <gwern> for exmaple, where did all those dialects go?
08:16:17 <hackagebot> hashed-storage 0.3
08:18:55 <fasta> gwern: a PhD lasts 4 years. 8 - 4 > 0 :)
08:19:47 <Beelsebob> depends on the PhD
08:19:54 <Beelsebob> some last 3 years, some never get finished
08:19:58 <pejo> gwern, Concurrent Haskell is in GHC, isn't it? Phil Trinder has lots of research around GpH or similar projects. Bjrn Lisper's group is doing WCET analysis nowdays, O'Haskell is abandoned in favour of Timber, not sure about pH, Rita Loogen seems to still work on Eden, Generic Haskell.. is that one alive still?
08:21:55 <gwern> fasta: yes, I suppose the cynical explanation is best
08:22:27 <gwern> too bad, because I would've liked mobile haskell functionality - why *can't* we serialize computations and incidentally send parts of our programs over the network?
08:22:28 <quicksilver> well for what ever reasons the ones that died didn't attract enough blood to stay alive
08:22:39 <quicksilver> I was just about to say :)
08:22:43 <quicksilver> GdH is probably the most surprising
08:22:46 <quicksilver> of the casualties
08:22:47 <lars9> hi, i'm using archlinux, which uses pacman as package manager. if i use cabal to install some package. will pacman conficts with cabal when installing the same package? such as haskell-x11
08:22:58 <quicksilver> I would have thought distribution was a pretty intersting topi.
08:22:59 <Peaker> gwern: People have done this for Python, btw
08:23:13 <quicksilver> people have done it for almost every language ever written
08:23:13 <gwern> Peaker: well, being interpreted, I understand makes it easier
08:23:20 <Peaker> gwern: Send lambdas over a network of powerful computers to compute and send back results
08:23:52 * quicksilver sends Peaker a lambda with a hacksaw hidden inside so he can escape from his computation factory.
08:23:58 <SamB> Peaker: think I've heard about something like that in connection with Yhc ...
08:24:21 <gwern> quicksilver: and it's hard to blame new blood for not showing up; it'd probably take me at least a year fulltime to get up to speed and  start merging mobile haskell stuff into mainline ghc, and who's going to support me?
08:24:35 <Peaker> Python makes it easier, having a serialized lambda form (bytecode)  (except you're not allowed to use globals/etc in such a lambda, just the args)
08:24:37 <SamB> does malcolmw know what I'm talking about ?
08:24:49 <SamB> 'cause I sure don't
08:25:05 <malcolmw> SamB: so what are you talking about?
08:25:23 <quicksilver> mobile code for yhc
08:25:25 <SamB> malcolmw: serializing lambdas over the network
08:25:28 <quicksilver> is what he's trying to talk about.
08:25:39 <gwern> SamB: yhc is like fusion - the compiler backend of the future
08:25:54 <quicksilver> gwern: yeah, but how did it degrade this far? I'd have expected steady interest.
08:25:59 <SamB> doesn't exist yet, you mean?
08:26:05 <lilac> "the monomorphism restriction, when rendered in a system of inference rules, compromises the principal type property"
08:26:05 <quicksilver> gwern: of course, in reality 0.1% of the community does 80% of the work,
08:26:11 <malcolmw> Yes, Yhc can transmit its bytecodes over a network to be executed on another VM, with results being transmitted back.
08:26:23 <gwern> SamB: it's the backend of the future, and always will be, is the joke I was going to
08:26:35 <quicksilver> lilac: yes, and that's not all it breaks.
08:26:43 <quicksilver> lilac: it breaks (one form of) eta expansion too.
08:26:57 <SamB> not to mention my code
08:27:01 <gwern> quicksilver: well, if there's a massive learning hump, and it's not obvious in advance it's going to die, then no new blood will show up in time
08:27:23 <quicksilver> malcolmw: I didn't know that.
08:27:28 <fasta> It has been done a number of times in the past already. It does not qualify as research anymore.
08:27:35 <quicksilver> malcolmw: does all live data get carried over with it?
08:27:37 <SamB> quicksilver: how is that possible when the community has only 610 members ?
08:27:54 <gwern> SamB: I think haskell is bigger than 610
08:27:58 <quicksilver> SamB: for 0.39% of his time, JaffaCake does other things :P
08:28:03 <SamB> hahaha
08:28:06 <quicksilver> SamB: erm, 39%.
08:29:54 <malcolmw> quicksilver: I don't recall the details.  Basically, you can send a value containing unevaluated thunks over the wire, and the unevaluated bits get sent as bytecodes.  When they are executed, they might refer to entities which are not present on the remote machine, so those get transferred later on demand.
08:31:43 <quicksilver> malcolmw: ah, so the live data gets transferred on demand
08:31:50 <quicksilver> malcolmw: in the terminology I was using.
08:31:53 <quicksilver> that's interesting.
08:32:51 <doserj> how does garbage collection work there?
08:33:24 <quicksilver> doserj: a garbage truck drives from one machine to the other
08:33:30 <quicksilver> doserj: once a week, on Thursdays.
08:33:49 <doserj> :)
08:34:03 <doserj> even on holidays?
08:34:24 <hatds> ?instances Category
08:34:25 <lambdabot> Couldn't find class `Category'. Try @instances-importing
08:34:33 <hatds> ?instances Control.Category
08:34:34 <lambdabot> Couldn't find class `Control.Category'. Try @instances-importing
08:34:38 <quicksilver> if there a bank holiday, the major GC will be on Friday.
08:34:47 <quicksilver> in cases of extended holidays, minor GCs will be arranged.
08:35:16 <jgriffin> Hi there. I'm in the process of learning Haskell, but I need a bit of advice on which direction to take. I'm self-teaching, and I have experience programming prior to learning Haskell. If I read "Programming Haskell" and "Real World Haskell", will those two books alone be sufficient for teaching the language? Some suggest also reading Haskell: The Craft
08:35:24 <jgriffin> of function programming, but is it necessary?
08:35:44 <quicksilver> no.
08:35:45 <Peaker> jgriffin: RWH should be enough, as far as I heard. I haven't heard of Programming Haskell
08:35:52 <quicksilver> many people learn by reading no books at all.
08:35:55 <hatds> ?instances Arrow
08:35:56 <lambdabot> (->), Kleisli m
08:35:59 <quicksilver> the two you mention are both good books.
08:36:12 <quicksilver> Of course, all the authors visit this channel, so I have to say that :)
08:36:14 <Peaker> jgriffin: I learned Haskell by experimenting with it, reading some tutorials on the web, and hanging out in #haskell
08:36:22 <aledge> RWH is really good, you should be fine if you have prior experience. You'll learn the most by trying to code something, of course
08:36:41 <quicksilver> I believe Hutton's book is good but aimed at undergraduate students
08:36:49 <quicksilver> whilst RWH is aimed more at programmers wanting to code
08:37:04 <jgriffin> Peaker: I've actually found that I retain the information best when I code myself, not when I read what others have written. I agree. :D
08:37:18 <smarmy> i'd at least read RWH.  yes, you can learn yourself, but like any subject, you miss a lot of the small insights that someone with experience can convey to you earlier than later
08:37:26 <jgriffin> right
08:37:28 <jgriffin> Okay then.
08:37:44 <jgriffin> Thanks guys.
08:37:45 <hatds> you should watch "A Taste of Haskell"
08:37:51 <hatds> very good first pass of the language
08:38:20 <jgriffin> hatds: I'll check it out.
08:48:14 <Cale> jgriffin: It also might be worth pointing out
08:48:15 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
08:48:18 <Cale> @where lyah
08:48:19 <lambdabot> www.learnyouahaskell.com
08:48:27 <Cale> which looks fun :)
08:48:45 <Cale> I think most people end up using a mishmash of sources :)
08:49:17 <jgriffin> I'm kind of getting that vibe...
08:49:18 <Cale> jgriffin: and ask lots of questions here :)
08:49:43 <jgriffin> I like this channel. The people don't bite too frequently...
08:49:47 <TomMD> Grrrr
08:49:54 <Cale> We are the documentation. :)
08:50:35 <dev31212> learnyouahaskell is the first site where I started to feel like I knew what I was doing :)
08:50:38 <dev31212> great site...
08:50:42 <Athas> Just out of curiosity, but are the GHC hackers still going to switch away from Darcs?
08:50:44 <dev31212> moved on since, of course
08:51:26 <TomMD> Athas: They were talking in #ghc ten minutes ago, you could ask them.
08:51:42 <shapr> I want to build GHC with eight cores and 16GB of ram, are there any command line options I can change to take advantage of the extra resources?
08:52:06 <dev31212> what a beast machine.
08:52:16 <jgriffin> dev31212: I think I'm past the point of "Learn you a Haskell". I've already absorbed the first half of Programming Haskell, and it looks like I've covered what goes on in that tutorial.
08:52:17 <TomMD> shapr: Couldn't you use -j5?
08:52:25 <TomMD> or -j9
08:52:29 <dev31212> jgriffan, cool
08:52:34 <shapr> TomMD: I'm using -j10, but that won't use more memory, right?
08:52:38 <Cale> jgriffin: Ah, okay :)
08:52:41 <CosmicRay> still trying to work around the API change in time in convertible.  MIN_VERSION_time() doesn't work because it only matches the first three bits of the version number
08:52:50 <CosmicRay> how else might I do it?
08:52:52 <TomMD> shapr: No more than needed - it won't do cool caching.
08:52:56 <dev31212> Real World Haskell...And the wikibooks book on Haskell are what I am on at the moment
08:53:05 <dev31212> Well Im half way through Real World Haskell
08:53:21 <shapr> I'm pretty sure GHC can build faster if each GHC compile is given more heap or something.
08:53:23 <TomMD> And how many worlds have you realized?
08:53:37 <dev31212> I have realized the Monadic world
08:53:42 <dev31212> where the universe is just one object
08:53:45 <dev31212> I have seen past
08:53:48 <dev31212> present and future at once
08:53:53 <dev31212> Like The Quizat Kadderach
08:54:33 <hackagebot> convertible 1.0.3
08:55:23 <CosmicRay> damn, that was fast
08:55:31 <Baughn> conal: I realized there's a bit of a semantic problem with my implementation of makeEvent - namely, the next occurence. It's not known when (or even if) it'll happen, but it /is/ known that it won't happen before the current time, which I ought to take advantage of - otherwise, merging the event with another would be impossible, never mind joining it
08:55:36 <mornfall> dev31212: How much for that stuff you are smoking? ; - )
08:56:07 <Baughn> conal: I have a suspicion you already fixed this at some point in the past, though. (And also that it involves improving values). Any thoughts?
08:56:40 <dev31212> mornfall, $42 :)
08:56:51 <quicksilver> Baughn: that's the key problem of making "joinE" efficient, yes
08:57:00 <quicksilver> Baughn: "observing information about non-occurrence"
08:57:22 <quicksilver> Baughn: it's actually not required to make it semantically possible, but if you can't observe and remember non-occurrence you waste a lot of time cheking for it
08:59:17 <Baughn> quicksilver: When it comes to events whose next occurence, if any, is driven by an IO sink instead of being computed some other way?
09:00:18 <quicksilver> Baughn: well in some sense your implementation has to cope with all four permutations
09:00:42 <quicksilver> Baughn: IOsink / IOsink, IOsink / purely computed, etc.
09:00:45 <quicksilver> hmm. 3 permutations ;)
09:01:00 <BioHazardSoftwar> Hey everyone
09:01:04 <Baughn> quicksilver: I'd use a special Time type
09:01:09 <quicksilver> one place where I disagree with conal's implementation is the amount of stuff working directly on events.
09:01:16 <quicksilver> I believe it makes more sense to define most primitives on futures
09:01:42 <Baughn> quicksilver: Whose exact value can't be checked without waiting for the event to occur (or the finalizer to trigger and cap it), but can be checked for inequality using unsafePerformIO to read the clock
09:02:46 * Baughn sighs
09:03:07 <quicksilver> well my preference is not to use unsafePerformIO to hide things away like that
09:03:10 <quicksilver> but we'll see.
09:03:13 <Baughn> ..it might be simpler to try implementing reactive from scratch, for learning to understand this. The existing code is.. convoluted, and I don't really understand why
09:03:22 <quicksilver> my approach may fail to yield an efficient implementation.
09:03:44 <hatds> is there a simple reactive example available that represents a runnable, interactive program with stdin?
09:04:05 <Baughn> I've got a couple
09:04:08 <Baughn> Let me see..
09:05:15 <conal> Baughn: yeah.  i have dealt with this issue.  it's *very* important.
09:05:16 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:06:36 <hackagebot> Hieroglyph 2.24
09:06:38 <Baughn> hatds: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5376#a5376 <-- OKay, I guess this is about the minimal one
09:06:57 <conal> Baughn: you've run into all of the awkward spots i know of in reactive: external input, correct unamb implementation, and event join.
09:07:10 <Baughn> conal: Right. Obviously my current makeEvent doesn't handle it, but I did at least figure out how to get the finalizers working right
09:07:21 <hatds> can you put in the imports for me?
09:07:23 <Baughn> conal: So if you've already dealt with it, I'm hoping you can adapt it. :)
09:07:34 <conal> Baughn: i'll look
09:08:08 <Baughn> hatds: ..I'm not really sure what they are. Umh.. LegacyAdapters, Control.Applicative.. yeah, I think it's just those two.
09:08:50 <Baughn> conal: If I've run into all of them, it's because I started deliberately looking for bugs. :P
09:09:20 <hatds> is Reactive not really runnable then?
09:10:15 <Baughn> hatds: Well, there are enough bugs that you're pretty much bound to run into them. I'm smacking them as fast as I can, but since that involves figuring out conal's code at the same time..
09:10:43 <Baughn> hatds: I may be introducing new ones too. Like the makeEvent/mappend bug I just figured out I'd caused. :P
09:11:24 <LeCamarade> Baughn, When I run a program in runhaskell, to what level does it get compiled?
09:11:34 <Baughn> LeCamarade: Not at all.
09:11:44 <LeCamarade> Ah.
09:11:50 <Baughn> Well, it's compiled to bytecode; ghci/hugs aren't pure interpreters.
09:11:56 <LeCamarade> Hence the variation!
09:13:05 <LeCamarade> It's so surprising. There is that deadlock I told you about, and it never ever shows up when I runhaskell. But once I get the code compile, it is consistent. And I just can't trace it. (I really want to know why I'm getting it, but I may never.)
09:13:32 <conal> LeCamarade: multi-threaded code?
09:13:48 <conal> i think ghci runs as if linked with -threaded.
09:13:57 <Cale> Yeah... try with -threaded
09:14:07 <Cale> I had some strange problems like that too
09:14:38 <Cale> It seems that some C library bindings don't work very well without -threaded
09:15:42 <conal> i think C calls block the RTS unless -threaded
09:16:26 <conal> ksf: poing
09:16:33 <conal> ksf: i mean "ping"
09:17:19 <bos31337_> pyongyang
09:17:40 <conal> pyin/pyang
09:17:56 <aledge> pinyin?
09:19:04 <heatsink> If you're going to make many data types have the same field, how would you do that?
09:19:31 <heatsink> I can think of adding the field to each constructor and defining a class HasField a where getField :: a -> Field; setField :: Field -> a -> a
09:19:56 <heatsink> Or creating a wrapper data type, data WithField a = WithField Field a
09:20:34 <lars9> :t id
09:20:35 <heatsink> The latter makes pattern matching slightly more convenient, but I think the former may be easier to maintain
09:20:35 <lambdabot> forall a. a -> a
09:20:44 <lars9> @src id
09:20:44 <lambdabot> id x = x
09:21:59 <heatsink> Has anyone here seen an idiom for this in an existing project?
09:22:03 <lars9> :t  pure id <*> v
09:22:05 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
09:22:05 <lambdabot>     In the second argument of `(<*>)', namely `v'
09:22:05 <lambdabot>     In the expression: pure id <*> v
09:22:20 <lars9> :t  pure id <*> (*2)
09:22:22 <lambdabot> forall a. (Num a) => a -> a
09:22:29 <lars9> :t  pure id <*>
09:22:30 <lambdabot> parse error (possibly incorrect indentation)
09:22:40 <lars9> :t  ( pure id <*> )
09:22:41 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f a
09:22:50 <glguy> :t (id <$> )
09:22:52 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
09:23:19 <lars9> :t  ( pure id )
09:23:21 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> a)
09:23:38 <quicksilver> lars9: lambdabot replies to private messages.
09:23:45 <quicksilver> lars9: also you can install GHCi on your own machine :)
09:24:00 <quicksilver> lars9: the purpose of lamdabot in a public channel is to form part of an ongoing discussion ;)
09:24:06 <lilac> heatsink: i vaguely recall a GHC extension where field names could be reused across multiple 'data'
09:24:13 <quicksilver> heatsink: I've see variations of both of those.
09:24:31 <quicksilver> heatsink: in the very very rare case where I want that, I favour the class HasField approach.
09:24:46 <quicksilver> but I don't find the idiom that useful.
09:24:53 <lilac> heatsink: do you want to be able to treat such things polymorphically?
09:24:57 <quicksilver> (there is often a more useful class or HOF to use than HasField)
09:25:20 <lilac> (are there any higher-level operations you wish to perform over all such data types?)
09:25:37 <LeCamarade> conal, Yes, multithreaded.
09:25:41 <hackagebot> checkers 0.2
09:25:55 <lilac> heatsink: does this field have the same type for all datatypes? does the datatype make sense if you remove the field?
09:26:48 <heatsink> lilac: I don't expect to do any interesting HOFs over such data types.  They make sense without the field.
09:27:20 <heatsink> lilac: In my case, the extra field is information about the source of a data structure that was produced from an input file.
09:28:01 <heatsink> If it were removed, you could still do everything except report source line information together with the output.
09:28:54 <Cale> heatsink: Maybe separate it into another type?
09:29:13 <Cale> I don't know how inconvenient that would be...
09:29:34 <lilac> heatsink: ... yeah, what Cale said :)
09:29:38 <heatsink> Cale: what do you mean?  Source information is another type, but it has to be attached to other data types somehow.
09:30:07 <lilac> heatsink: data WithSourceInformation a = WSI { sourceInformation :: SourceInformation, body :: a }
09:30:25 <lars9> what's the applicative functor in "pure id <*> (+2)"
09:30:33 <lilac> lars9: reader
09:30:45 <heatsink> That was one of my two proposals, above: data WithField a = WithField Field a
09:30:57 <Cale> ah, okay
09:30:59 <Cale> I missed that
09:32:54 <heatsink> I guess the two things that I don't like about that are that it's not composable and that it introduces extra levels of indirection.
09:33:17 <heatsink> What I mean about composability is, suppose I had two bits of extra information: source position and user annotations.
09:33:33 <heatsink> Now WithSourceInformation (WithUserAnnotations a) /= WithUserAnnotations (WithSourceInformation a)
09:34:17 <mmorrow> so it's not commutative
09:34:42 <lilac> lars9: you can tell it's the reader monad because <*> takes an Appliactive on both sides and the RHS is a function
09:34:46 <heatsink> Right.
09:34:52 <Saizan_> you could implement extensible records in ghc
09:34:56 <Saizan_> or use HList
09:34:58 <heatsink> With type classes, you'd have (HasSourceInformation a, HasUserAnnotations a) => a
09:35:03 <Cale> One thing you could do is just include the fields with a Maybe type.
09:35:18 <Cale> But that's perhaps a little less typesafe
09:35:27 <heatsink> Which is "commutative" in the sense that type class constraints are unordered.
09:35:43 <lilac> lars9: incidentally, pure f <*> x = f <$> x = fmap f x, so pure id <*> x = fmap id x = x
09:37:00 <Cale> (In the sense that whether the fields are present or not is a runtime property then.)
09:37:07 <heatsink> right
09:37:41 <lilac> lars9: (the first equality comes from the Applicative laws, the second from the Functor laws)
09:38:26 <Cale> You can also have your datatype (assuming it's recursive, or else this is kind of silly) take an extra arbitrary type parameter for all the extra information that it's annotated with.
09:38:35 <Athas> How do people use Parsec nowadays?  Through an applicative functor interface?
09:38:42 <lars9> lilac: where is <$> defined? not defed in control.applicative and control.monad
09:38:46 <Cale> and then just construct a big enough type for all the annotations you want to make
09:38:56 <Cale> Athas: and monadically
09:39:07 <Beelsebob> lars9: Control.Applicative
09:39:14 <Cale> Athas: Applicative notation is convenient sometimes though.
09:39:30 <lilac> @index (<$>)
09:39:30 <lambdabot> bzzt
09:39:52 <Athas> Cale: yes, I noticed.  But it looks like it can easily become unreadable if used indiscriminately as well.
09:40:08 <heatsink> Cale: That's true, but since the code statically knows what annotations are there, I think that's kind of overkill.
09:40:42 <lilac> quicksilver: (thinking back to applicative parsers), you could still make a monad instance assuming your parser is pure, by trying it on all possible first letters
09:41:29 <Cale> heatsink: Well, the type that you apply it at can be different in different parts of the code then
09:42:10 <heatsink> Cale: Yeah, I do that when the type changes in different parts of the code :)
09:45:08 <heatsink> In my experience, overusing type variables can lead to having to insert/remove type variables in lots of signatures, even when there's no change to the code.
09:45:45 <heatsink> And not solving the field problem I was asking about can lead to having to insert/remove underscores in lots of patterns, even when there's no real change to the code.
09:46:12 <Cale> Well, that's what the record syntax is primarily for...
09:46:26 <Cale> (not having to insert/remove underscores in patterns)
09:46:44 <heatsink> oh yeah
09:46:50 <heatsink> I forgot about that
09:47:15 <heatsink> So that's what Saizan_ meant about extensible records
09:47:29 <Cale> Actually, probably not :)
09:47:34 <ray> record syntax is pretty useful, but i feel like i have to take a shower every time i use it
09:47:39 <Cale> Extensible records are something that Haskell doesn't have
09:47:46 <Cale> But would make your life much easier
09:49:25 <Cale> Basically, it gives you a particular new kind of record type with labelled/typed fields, and a way to write functions which are polymorphic over any record that has certain fields
09:50:45 <heatsink> I see
09:50:57 <quicksilver> lilac: well really it's first-token not first-letter
09:51:10 <quicksilver> lilac: and if the intention was for it to be 0-lookahead then you can't do that.
09:51:29 <quicksilver> lilac: you can make the monad instance by backtracking, which breaks the idea of the parser, yes.
09:51:58 <Cale> (and polymorphically extend any record with additional fields)
09:58:04 <nibro> Cale: depends on what you mean by Haskell - there's TRex for hugs
09:58:18 <Berengal> Cale: Sort of like creating a type class for each accessor function?
10:01:44 <Cale> nibro: That's true
10:01:58 <heatsink> Well, I feel better about going with the type class solution then :)
10:02:53 <quicksilver> Berengal: well, some record typing systems allow upper as well as lower bounds on the fields
10:03:02 <quicksilver> IIRC ocamls' extensible variants has this
10:03:04 <quicksilver> <: and :>
10:03:14 <quicksilver> that would not be easy to express with typeclasses
10:03:21 <quicksilver> TCs are not good at negative information.
10:03:30 <quicksilver> due to being open.
10:03:35 <quicksilver> hence all the hoops oleg builds around HFalse
10:06:24 <Cale> With sufficiently complicated typeclasses, you can approximate it, and some libraries, like HaskellDB, actually do this
10:06:51 <Cale> But it's something which would really be a lot nicer if you didn't have to use typeclasses to do it.
10:07:29 <Cale> Oh, that was in reference to extensible records, though I suppose with extensible variants it also somewhat applies
10:07:56 <Cale> You can use existentials and typeclasses to approximate extensible variants, like the new exceptions library does
10:08:05 <Cale> But again, not the prettiest result.
10:08:58 <quicksilver> Cale: but on the other hand, true extensible variants break the type system pretty badly
10:09:03 <quicksilver> Cale: so maybe it's not abad thing we can't do it.
10:11:00 <Cale> quicksilver: Oh? How so?
10:11:21 <Cale> I think it's possible to do true extensible variants without breaking the type system.
10:12:15 <quicksilver> Cale: well FSOV of "breaking"
10:12:24 <quicksilver> Cale: you get something not remotely as pleasant as we have now.
10:12:39 <quicksilver> Cale: in particular with the subtype/supertype polymorphism
10:13:25 <quicksilver> that's the <: and :> stuff
10:13:30 <quicksilver> I can't remember the details, alas.
10:14:40 <Cale> As long as you confine subtyping/supertyping to the kind of variants, then I think it should be okay.
10:16:09 <Cale> Well, what you really want is more or less a row variable of possible labels/types for the variant. So it's almost identical to the extensible record system.
10:17:58 <hackagebot> haskeline 0.6.1.6
10:35:44 <ksf> conal, pong
10:42:48 <jeffersonheard> crud...  is wouter swierstra on here?
10:47:54 <conal> ksf: hi.  i see you ran into trouble with quickcheck versions.
10:49:21 <conal> ksf: i've pushed a new checkers.  will push other libs as well.
10:49:59 <conal> jeffersonheard: i think so.  anyone remember wouter's irc handle?
10:50:02 <ksf> conal, yes, C calls block, even when threaded, at least that's my best guess from how stuff behaves, I never wrote a test or something to pin the semantics down.
10:50:43 <ksf> cabal update
10:50:45 <ksf> grr.
10:53:41 <ksf> conal, still, I'd like to have ifdef's around all test code, just to calm my engineering intuition after hitting upon that BinOp thing.
10:54:00 <ksf> production code depending on test cases freaks me out.
10:55:09 <conal> ksf: ifdefs around Arbitrary & CoArbitrary instances?
10:56:04 <ksf> yes, around those, around the quickcheck imports, and the rest of the test case, so that you can build a version of reactive without tests enabled, and not depending on quickcheck, at all.
10:58:37 <conal> ksf: does that desire come from a general wish to reduce package dependencies where possible?  or maybe something more specific to quickcheck or checkers?
10:59:22 <ksf> uhhh... both.
10:59:26 <conal> ksf: what's the BinOp thing?
11:00:43 <ksf> merge in PrimReactive uses BinOp, and it's used in a thousand instances that don't look like tests. It's out of checkers afair.
11:01:34 <conal> ksf: oh, i see.  yeah.  BinOp has nothing do with testing, so it's not logical for me to get it from checkers.
11:01:36 <ksf> ...or, rather it's used in the Monoid Event instance, and that's used all over the place.
11:02:05 <conal> ksf: i don't know how to manage *not* including QC instances in my libraries.  other libraries & apps will need them.
11:02:14 <conal> ksf: i.e., they're not just for testing *my* libs.
11:02:43 <conal> i want all libs that i use to define & export QC instances.  and i expect others will want the same from me.
11:02:44 <ksf> well, if someone wants to run tests, they can compile with --enable-testing
11:03:11 <conal> ksf: that's a separate issue, don't you think?
11:03:32 <conal> and sure, for running my tests, --enable-testing would be fine.
11:03:52 <conal> btw, is --enable-testing a standard flag or one i'd define in my .cabal files?
11:04:07 <ksf> well, I think that test and production code should be sharply seperated, and ifdef's are the best way to ensure that, even if noone ever compiles without tests enabled.
11:04:43 <ksf> dunno, I didn't look at how to integrate with cabal, yet.
11:05:18 <dcoutts> conal: right, you can't (or at least should not) conditionally export stuff
11:05:21 <kynky> ksf, ideal world vs real world (there are always side effects)
11:05:25 <ksf> it probably should be a standard flag, though, like enable docs.
11:05:40 <dcoutts> ksf: the difference is that docs do not affect the exported API
11:06:02 <dcoutts> cabal flags are not supposed to affect the exported API
11:06:27 <dcoutts> dependency planning relies on that, and there's deliberately no way to express a dependency on a package built with some set of flags
11:07:01 <dcoutts> also such conditional package building does not translate into binary distro packages
11:08:38 <Berengal> An alternative is to break a package in two, foo and foo-tests
11:09:39 <dcoutts> I think it's better just to depend on QC
11:10:00 <conal> Berengal: or even three: foo, foo-QC (with QC instances), and foo-tests
11:10:01 <dcoutts> we'll soon get to the stage where we've got a sensible QC version as standard
11:10:24 <conal> dcoutts: yeah.  it's an awkward moment w.r.t QC now.
11:10:32 <conal> transitional
11:10:36 <dcoutts> problem is that the release of ghc-6.10 and QC2 happened at almost the same time
11:10:44 <dcoutts> so ghc-6.10 shipped QC 1.2
11:10:52 <dcoutts> and the platform had to follow that
11:11:09 <dcoutts> but the next major release will undoubtedly update to QC2
11:11:35 <conal> i was surprised at how much work it took me to change checkers over from QC1 to QC2.  some pretty big changes.
11:17:57 * ksf stays stubborn and still reserves the right to write #ifndef ENABLE_TESTS around code and nag about things like BinOp
11:19:15 <conal> ksf: to eliminate a QC dependency?
11:20:02 <ksf> well, that's just a nice side-effect of being a nazi about minimal dependencies.
11:20:29 <conal> ksf: i could split reactive into two or three packages.
11:20:42 <conal> ksf: since the exports would differ
11:21:05 <conal> ksf: although it depends on other package(s) that depend on QC
11:21:17 <ksf> don't you need to tests non-exported functions?
11:21:48 <conal> ksf: and representation.  it'd be painful and ultimately unsatisfactory.
11:22:19 <dcoutts> conal: I'd just stick to depending on QC, it's not a heavy dep, it's just the current issue of the transition
11:22:33 <conal> ksf: and if i don't split the package, i can't support libs that build on top of reactive
11:22:44 <ksf> I still don't understand why changing exports would be bad, but I've missed some of the discussion due to my network.
11:22:47 <conal> ksf: i mean if i don't somehow provide dependable QC instances for reactive types.
11:23:01 <ksf> otoh, the tests exports could just be calls to errors.
11:24:07 <conal> dcoutts keeping QC dependence is my leaning as well.  however, i want to hear ksf out.  i figure he wouldn't be complaining if he didn't have a good reason in there somewhere.
11:24:21 <dcoutts> ksf: the problem is that conditional exports breaks package management
11:24:22 <dcoutts> conal: sure
11:24:41 <ksf> the reason is BinOp, and catching such things.
11:24:53 <kynky> maybe package management could be cleverer
11:25:04 <Baughn> conal: Yep, figured out another problem with unamb. This one is relatively obscure, depending on the exact behavior of the caller.. you can thank Dupree for making me think about it. :P
11:25:25 <Baughn> As a plus, the solution should also make unamb cleaner
11:25:36 <dcoutts> kynky: it's a bit hard to change the distro package management systems
11:25:38 <conal> Baughn: great!  thanks Dupree!
11:25:50 <dcoutts> kynky: just changing our own is not enough
11:25:51 <ksf> so, in the end, it doesn't matter if reactive can be cabal-installed without test code, as long as you can complie it without tests during development, to check if stuff's in the right place.
11:26:40 <conal> ksf: i don't even know how to define "in the right place" in such a way that i'd know BinOp wasn't.  help?
11:26:44 <kynky> gentoo package management is pretty flexible now, but some others are archaic i guess
11:27:31 <ksf> well, checkers is a test library, and whole reactive depends on it in a crucial way, not just the tests.
11:28:03 <ksf> I figure it should be in a package both checkers and reactive depend upon.
11:28:22 <conal> ksf: yeah.  or duplicated.
11:28:28 <ksf> or that, yes.
11:28:41 <conal> type UnOp a = a -> a
11:28:53 <conal> i never know what to do with such trivial but widely useful things
11:29:08 <ksf> Prelude.Conal?
11:30:34 <ksf> actually, it'd be nice to have a collection of Prelude.*s, just to have a library of different coding styles, and a repository to draw from to extend the prelude.
11:32:07 <Berengal> ksf: I actually like that idea...
11:32:22 <conal> ksf: i can deal with UnOp/BinOp one way or another.  also tests.  that leaves testing functionality, which still has to get exported.  don't know what to do there.
11:32:31 <dcoutts> kynky: right, the binary ones are more restrictive
11:33:12 <ksf> conal, don't worry.
11:33:29 <conal> ksf: where testing functionality includes QC instances and other reusable support.
11:35:44 <ksf> I'm going to write those defines, and leave you alone if it compiles with the test dependencies removed, I don't really care about really _installing_ a test-less reactive.
11:36:15 <sayyestolife> what are some good mailing lists that one should subscribe to? (except the haskell ones, already got them!)
11:36:26 <ksf> regard them as another test case, testing the independency of code from tests.
11:40:04 <Berengal> Hmmm, splitting packages does make it hard to test unexported functions, ifdefs are ugly and complicate dependencies, and putting the tests in the same package as the code doesn't /really/ make sense; couldn't match expected type Code against inferred type Test in the expression 'testModule : package'
11:41:56 <Berengal> If you were somehow able to give a package full access to all modules (perhaps even private declarations) in another package, splitting wouldn't be so bad
11:44:42 <ksf> Berengal, you'd have to recompile the package you depend on, due to inlining and stuff.
11:45:12 <Berengal> ksf: Yes, I realize that. This is the "somehow" part in my previous statement
11:45:36 <Berengal> Somehow == magic, usually
11:46:11 <kynky> ===
11:46:39 <ksf> #ifndef DISABLE_TESTS isn't ugly, but useful documentation.
11:46:59 <Berengal> ksf: It mixes tests and code in files
11:47:37 <ksf> yeah, but you won't get your full-access cake, ever, without recompiling.
11:47:43 <Berengal> They might be separate at compile time, but to me it's more important that they're separate in the source as well
11:48:29 <ksf> file-based structuring is overrated.
11:48:50 <ksf> I know, I once failed an exercise because I didn't split up 200 lines of C into 4 files.
11:49:00 <kynky> just a hierarchy, simple rules though
11:50:57 <Berengal> ksf: I once handed in a java assignment consisting of n files of n ±2 lines each
11:51:30 <ksf> yay there's a reason that there are inner classes.
11:51:31 <Berengal> So I agree that it's overrated. Tests don't belong in the same code they're testing though
11:52:11 <kynky> Berengal, agreed
11:52:35 <kynky> or stuff that is only used by tests
11:52:41 <Berengal> To me the reason why is similar enough to why we use exceptions instead of return values and nested ifs
11:52:54 <ksf> hmmm. I would agree on "tests testing the api don't belong in the code they're testing"
12:00:52 <rubendv> I get an occurs check error on the definition of >>= here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2522
12:01:01 <rubendv> Anyone knows what I'm doing wrong?
12:01:12 <ksf> you're defining a recursive type.
12:01:34 <ksf> usually, that's an error, if it's not, you still need a newtype or data declaration to get it past the type checker.
12:01:50 <rubendv> Yes, but I don't see how it is recursive?
12:02:13 <byorgey> what? how is rubendv defining a recursive type?
12:02:42 <rubendv> Occurs check: cannot construct the infinite type: a = structure a
12:02:45 <rubendv> is what I get
12:02:53 <byorgey> rubendv: well, let's see, what's the type of >>= ?
12:02:57 <byorgey> @type (>>=)
12:02:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:03:13 <byorgey> so here,  m = (Chat structure)
12:03:32 <byorgey> so it should be of type  Chat structure a -> (a -> Chat structure b) -> Chat structure b
12:03:57 <byorgey> rubendv: so if you have   (Chat ms) >>= f,  what is the type of ms?
12:04:03 <byorgey> and what is the type of f?
12:04:22 <rubendv> ms :: (structure a)
12:04:26 <byorgey> right
12:05:06 <rubendv> oh and a itself has to be a structure too
12:05:10 <rubendv> I se
12:05:12 <rubendv> *see
12:05:30 <byorgey> why would a have to be a structure too?
12:05:57 <rubendv> because f is applied to something of type (structure a)
12:06:04 <byorgey> ok, right.
12:06:39 <byorgey> you can't directly apply a function  a -> Chat structure b  to a  (structure a).
12:07:01 <byorgey> if you use fmap you can get a  (structure (Chat structure b))
12:07:17 <byorgey> which is really just a  (structure (structure b)) (after removing the 'Chat' constructor)
12:07:25 <byorgey> and then you can use join to turn that into a  (structure b).
12:07:39 <rubendv> o_O
12:07:51 <rubendv> okay let me think on that for a while :p
12:08:13 <rubendv> Well it isn't really necessary for it to be a monad
12:08:37 <byorgey> it isn't necessary for what to be a monad?  Chat?
12:08:40 <rubendv> I wanted it to be an instance of a class like Monoid or MonadPlus
12:08:42 <rubendv> yes
12:08:53 <rubendv> but Monoid needs things of kind *
12:09:10 <rubendv> so I thought MonadPlus was the only other option?
12:09:19 <rubendv> and than it had to be a Monad too
12:09:22 <rubendv> *then
12:09:41 <byorgey> you could use Monoid, just give it another argument
12:09:56 <byorgey> like   instance (Monoid (structure a)) => Monoid (Chat structure a)
12:10:30 <rubendv> oh yes of course
12:10:32 <byorgey> in fact if you make Chat a newtype instead of data you can just say  (deriving Monoid) after it, I think
12:11:15 <byorgey> also, the MonadPlus constraint on the data declaration is actually kind of useless
12:12:08 <seliopou> byorgey, I believe the newtype deriving requires a language extension
12:12:28 <byorgey> yes, it does
12:12:31 <byorgey> GeneralizedNewtypeDeriving
12:18:50 <Baughn> conal: Actually, there is no bug. This makes me nervous, since it means I don't understand how unsafePerformIO interacts with exceptions.
12:19:23 <conal> Baughn: i don't understand either.
12:19:48 <Baughn> conal: I'm going to try reading the source.
12:19:58 <conal> cool
12:21:01 <conal> Baughn: i think Sterling Clover (sclv) and Bertram Felgenhauer (forgot nick) understand.  at least better than i do.
12:21:45 <Baughn> @seen sclv
12:21:45 <lambdabot> I saw sclv leaving #haskell-in-depth, #ghc, #haskell-blah and #haskell 2d 7h 25m 34s ago, and .
12:22:04 <Baughn> conal: It might be a case for haskell-cafe, but I'll at least figuring out the source code first
12:24:18 <Baughn> Oh yeah. Is it possible to have Emacs read non-Prelude function signatures for eldoc-mode somehow? Perhaps through ghci?
12:27:18 <Baughn> "unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)" <-- *sigh*
12:33:45 <defun> I am confused. Are monads not pure? or is it only the IO monad that is not pure? Furthermore, what is the definition of 'purity' (in the way haskell coders use the term).
12:34:14 <Cale> Well, it's subtle. Even the IO monad is pure if you look at it in one way.
12:34:25 <byorgey> defun: it is only *running* IO computations which is not pure.
12:34:25 <rubendv> I think only the IO a values themselves are magic?
12:34:41 <Cale> The IO a values needn't be magic, but interpreting them is.
12:34:48 <pejo> defun, "What is a purely functional language": http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.7800
12:35:06 <byorgey> defun: often monads are used as a way to package up operations which *appear* to be unpure (e.g. mutable state) in a purely functional way.
12:35:08 <Cale> A value of type (IO a) is like a *description* of some stuff to do in order to produce a value of type a
12:35:38 <Cale> Carrying out those instructions is the impure bit.
12:35:52 <Cale> But just building up a description is pure.
12:35:57 <rubendv> So you could say there is a hidden interpreter that executes the IO actions it gets in a lazy list?
12:36:30 <Cale> Sort of, or pattern matches on a structure that's been built up (maybe not too list-like)
12:36:41 <Cale> and carries out the steps
12:37:07 <defun> thanks.
12:37:07 <Cale> In a compiled Haskell program, it pattern matches against main, and recursively carries out the instructions described.
12:37:22 <Cale> That pattern matching causes Haskell evaluation to happen, which is itself pure.
12:37:50 <Cale> So if you were writing a Haskell implementation in Haskell, one possible implementation of IO (if you don't mind the GADT syntax) would be:
12:37:54 <Cale> data IO t where
12:37:58 <Cale>   ReturnIO :: a -> IO a
12:38:08 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
12:38:14 <Cale>   GetChar :: IO Char
12:38:20 <Cale>   PutChar :: Char -> IO ()
12:38:28 <Cale>   ... other IO primitives ...
12:38:41 <Cale> and then the RTS would have an interpreter for this datatype
12:39:10 <Cale> Which, when written in Haskell, looks a bit circular :)
12:39:20 <rubendv> :)
12:39:24 <Cale> execute (ReturnIO v) = return v
12:39:56 <Cale> execute (BindIO x f) = do v <- execute x; execute (f v)
12:40:11 <Cale> execute (GetChar) = getChar
12:40:37 <Cale> But of course, the first time, it would probably actually be written in something lower level, like C.
12:40:51 <aias_> Why does the following not work: http://paste.pocoo.org/show/119808/ (Error message in the code)
12:41:03 <olsner> Cale: is that a hypothetical implementation of the RTS in haskell? or would you actually write that as part of the base library?
12:41:20 <Cale> olsner: Hypothetical implementation of the RTS.
12:41:37 <olsner> so, something like execute :: IO a -> RealIO a?
12:41:43 <Cale> yeah
12:42:23 <Cale> Just because I didn't feel like writing C-like code for pattern matching ;)
12:42:34 <olsner> how would you extend that IO system later? would that only be possible in the base library's definition of the IO type?
12:42:49 <Cale> aias_: Because / isn't implemented for Int
12:43:07 <Cale> aias_: you'll need to convert x to a fractional type using fromIntegral
12:43:21 <Cale> aias_: So you could use  f (round (fromIntegral x / 2))
12:43:29 <Cale> But you should also know about div
12:43:42 <Cale> olsner: Yeah, FFI is tricky like this.
12:44:12 <Cale> olsner: Adding new IO *primitives* needs to be done in that algebraic datatype.
12:44:51 <olsner> (unless, of course, the IO type also contains a trapdoor-like thing like UnsafeJumpToAddress :: Word -> IO ())
12:44:55 <Cale> olsner: Though perhaps you could just store enough information to figure out how to do the FFI call.
12:45:03 <Cale> yeah
12:45:22 <aias_> Cale: Thank you very much. It works perfectly now.
12:45:32 <olsner> or FFIFunctionDescriptor a b -> a -> IO b
12:45:44 <Cale> aias_: f (x `div` 2) is another option, but it means something slightly different
12:45:53 <olsner> which actually also looks kind of sane
12:45:59 <ninjasamauri> are you sure that's proper syntax?
12:46:18 <Cale> ninjasamauri: what syntax?
12:47:53 <Cale> rubendv: Anyway, to get at your actual question more...
12:48:09 <Cale> Er, defun rather
12:48:22 <ninjasamauri> nevermind i was confused
12:49:12 <ninjasamauri> cale you were helping me with a hierarchy db problem
12:49:18 <ninjasamauri>  decided on a nested set representation
12:49:23 <aias_> Cale: Sorry, but I can't see the difference.
12:49:50 <Cale> aias_: div is like floor (x/2) and works reliably for large values of x
12:50:10 <Cale> defun: The property we usually mean by purity is referential transparency
12:50:51 <Cale> defun: What this is, is the property that if two functions f and g always give the same result for the same parameter, then it's safe to replace f with g in the code, without affecting the meaning of the program.
12:51:05 <Cale> defun: All mathematical functions have this property
12:51:33 <Cale> defun: But, for example, a function which prints something on the screen before producing its result does not.
12:51:39 <aias_> Cale: Thank you. I use div now.
12:54:05 <Cale> defun: does that help?
12:54:29 <kuribas> What does this syntax mean: Module M (Module L,
12:55:05 <kuribas> ?
12:55:33 <Heffalump> assuming you mean that with module not Module, it means that M re-exports everything it imported from L
12:56:40 <kuribas> Ah, yes, module.
12:56:49 <kuribas> Heffalump: Ok, I see.
13:00:13 <gwern> @quote Zombie.*Jesus
13:00:13 <lambdabot> No quotes match.
13:00:20 <gwern> @quote zombie
13:00:21 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
13:00:30 <gwern> @quote zombie
13:00:30 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
13:00:44 <gwern> @quote bacon
13:00:44 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
13:00:47 <gwern> @quote bacon
13:00:47 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
13:00:56 <gwern> drat. what *do* all you people talk about? only one bacon and one zombie quote
13:11:11 <hackagebot> convertible 1.0.5
13:14:55 <sm>  is there a way to cabal install --reinstall -p (all libs I depend on ?)
13:16:12 <hackagebot> HDBC 2.1.1
13:16:53 <dcoutts> sm: not yet no, sorry
13:17:06 <sm> ok, thx dcoutts
13:17:14 <dcoutts> sm: not automatically, you'll have to track back which things need rebuilding
13:18:38 * sm depends on five regex libs.. that's just silly
13:18:40 <ksf> @remember gwern drat. what *do* all you people talk about? only one bacon and one zombie quote
13:18:41 <lambdabot> Good to know.
13:19:10 <ksf> lambdabot is a metaquotolar database now.
13:20:53 <wabash> curious: do many haskellers dabble in Ocaml, MLton, etc?
13:21:45 <CosmicRay> I used ocaml before switching to haskell
13:21:49 <CosmicRay> but I made a pretty clean break of it.
13:21:58 <CosmicRay> I think there are a number of folks that are familiar with those languages at least
13:22:26 <wabash> CosmicRay: How do you feel? Haskell better in some way (your opinion).
13:23:01 <CosmicRay> yes, quite so.  quite a few things about ocaml annoyed me.  the build process was extremely complicated and non-standardized.  The I/O library was very weak
13:23:16 <CosmicRay> and the separate lists vs. streams was also annoying.
13:23:21 <CosmicRay> I like the purity in Haskell
13:23:47 <ksf> I know of enough ocaml to prefer haskell, mostly because of purity, and going all the way. I went down the shootout list in search of a proper language to learn, and haskell was (and becomes more and more, all the time) impressive.
13:23:57 <Cale> It also seems like a trivial point, but I like Haskell's syntax a lot better.
13:24:01 <Heffalump> still a long way to go though
13:24:05 <CosmicRay> Cale: I do too.
13:24:13 <sm> "Haskell goes all the way"
13:24:40 <ksf> well, coming from scheme and c, looking for a replacement for scheme, not c, i wasn't really comfortable with "for".
13:25:18 <bos31337> ocaml's only substantial advantage is the module system it inherits from ML.
13:25:50 <CosmicRay> that's an advantage?
13:26:39 <ksf> modules not messing with semantics, only scoping can be seen as an advantage.
13:26:49 <wabash> So... How about math overflow and underflow? Haskell catch it ok?
13:26:53 <bos31337> i think so.
13:27:10 <ksf> instance exporting is an issue, though, especially the haddock situation.
13:27:28 <ksf> I don't care much about math.
13:28:00 <wabash> Can anyone tell me about haskell's math performance and overflow/underflow?
13:28:35 <Heffalump> none of the standard types catch it
13:28:50 <Heffalump> Integer is unbounded so its irrelevant
13:28:52 <Cale> But overflow is impossible with Integer :)
13:28:53 <Cale> yeah
13:28:58 <ksf> it's not too hard to get close enough to c to embarrass c coders, and the semantics are mostly the same.
13:29:18 <Cale> and Rational, of course
13:29:33 <ksf> (regarding Double, Float and Int, that is)
13:29:42 <wabash> none of the types catch it? That sucks. Dose Haskell compile down to 32 bit ints? Or does it go 31 with a tag bit?
13:29:57 <bos31337> Double and Int. Float is slow.
13:30:00 <Heffalump> 32 bit ints
13:30:17 <Cale> wabash: Int is a full machine integer with GHC, so 32 or 64 bits
13:30:17 <wabash> Ah, that's why not catch...
13:30:17 <Heffalump> at least that's what GHC does
13:30:23 <ksf> Int can be as small as 29, but then there's Int32 and Int64, as well as Word equivalents.
13:30:28 <wabash> M.
13:30:30 <Cale> Though the Haskell standard says something like at least 30 bits
13:30:31 <wabash> Ok, thanks everyone.
13:30:51 <Heffalump> you could write your own type with checking quite easily, actually
13:30:59 <Cale> Integer is unbounded and has nearly the performance of Int for small values
13:31:02 <Heffalump> since you just have to implement the numeric classes which are all quite small
13:31:08 <Cale> So I would usually recommend using that instead.
13:31:08 <wabash> ok, cool.
13:31:30 <ksf> > (!!)
13:31:31 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Types.Int -> a)
13:31:32 <lambdabot>    aris...
13:31:38 <ksf> > (!!) :: Int
13:31:38 <Cale> > 1/0
13:31:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:31:40 <lambdabot>   Infinity
13:31:43 <ksf> :t (!!) :: Int
13:31:44 <lambdabot>     Couldn't match expected type `Int'
13:31:44 <lambdabot>            against inferred type `[a] -> Int -> a'
13:31:44 <lambdabot>     In the expression: (!!) :: Int
13:31:47 <ksf> :t (!!)
13:31:48 <lambdabot> forall a. [a] -> Int -> a
13:31:49 <Cale> > isInfinite (1/0)
13:31:50 <lambdabot>   True
13:31:52 <ksf> ther's the heresy.
13:32:06 <sm> odd.. a heap profile with ghc 6.10.2 shows 60Mbseconds on my mac and 500Mbseconds on linux
13:32:47 <ksf> ...should be (!!) :: Natural n -> [a] > n -> a
13:33:14 <bos31337> > 1`div`0
13:33:15 <lambdabot>   * Exception: divide by zero
13:34:04 <bos31337> i've decided that the reason the C pidgits code isn't beating the haskell version is that its authors were too clever for their own good.
13:35:00 <sm> oh I see.. on the server it took much longer, maybe it was thrashing
13:35:03 <bos31337> they use global variables instead of allocating new bignums all the time and never freeing them.
13:35:23 <sm> still peak heap usage is twice as high as on the mac
13:37:04 <Heffalump> so it frees them when it shuts down? :-)
13:37:19 <Heffalump> hangon, this isn't C++, so the destructors won't run
13:37:24 <Heffalump> s/the //
13:38:32 <Cale> bos31337: I thought it switched around for a bit?
13:38:47 <bos31337> Cale: eh?
13:39:01 <Cale> er, oh, we're basically tied?
13:39:04 <Cale> http://shootout.alioth.debian.org/u32q/benchmark.php?test=pidigits&lang=all
13:41:37 <Cale> I wonder if it's at all possible to parallelise that...
13:44:24 <Cale> Maybe just sticking a parListChunk in the right place would work
13:44:51 <Cale> hmm, but the data dependencies sort of mess things up
13:48:47 <bos31337> Cale: yes, each digit depends on its predecessor with that algorithm
14:02:11 <iop> hey
14:02:27 <eivuokko> Hello.
14:02:27 <iop> is case of if-then-else more idiomatic when it doesn matter
14:02:35 <iop> for some reason i find if-then-else ugly
14:02:41 <monochrom> it doesn't matter
14:02:42 <Heffalump> do whatever suits you
14:02:47 <iop> is or expensive since i need to construct a list?
14:02:59 <eivuokko> Guards are common as well.
14:03:25 <iop> guards?
14:03:58 <eivuokko> foo x | x==1 = ...
14:04:29 <iop> can i lambda that?
14:04:35 <iop> in a fold
14:05:08 <eivuokko> Nope.
14:06:41 <RyanT5000> what's an efficient datastructure to use for tagging? i.e.: each object has has zero or more tags associated with it
14:06:58 <RyanT5000> need to be able to look up tags given objects or objects given tags
14:07:30 <RyanT5000> (obviously, an immutable datastructure is preferred, given the chatroom i'm asking in :P)
14:07:39 <mle> what sort of modifications and change semantics?
14:08:11 <RyanT5000> mle: should be able to add or remove a tag to or from a given object, and add and remove objects
14:09:29 <mmorrow> RyanT5000: Map and IntMap
14:10:27 <iop> how can I map with a state?
14:10:41 <mmorrow> so then you need some sort of "object id" that you can use the key on to get at tags
14:10:51 <abbe> iop, map with a state ?
14:10:52 <iop> like if i want to if-then-else in the lambda abd either id or !! index where i want to update the index if i use it
14:10:59 <mmorrow> Map ObjId (Set Tag)
14:11:45 <mle> probably should wrap in something that tracks tag or object updates and updates your indexes
14:11:47 <mmorrow> , fmap (\x -> if 3 < x && x < 7 then 42 else x) [0..9]
14:11:49 <lunabot>  [0,1,2,3,42,42,42,7,8,9]
14:11:51 <mmorrow> ?
14:11:59 <mle> and maybe use TVars to do so safely
14:12:16 <mmorrow> STM gets pretty slow though if there's contention
14:13:01 <RyanT5000> well, Map Object (Set Tag) won't cut it; i could use (Map Object (Set Tag), Map Tag (Set Object)), i suppose
14:13:04 <iop> @indx mapAccum
14:13:05 <lambdabot> Data.IntMap, Data.Map
14:13:24 <mmorrow> the only thing is, what's your comparison for objects?
14:13:39 <RyanT5000> mmorrow: well, i think we can safely assume Object is in Ord
14:13:47 <mmorrow> (if it's really inefficient, performance'll suffer)
14:14:00 <RyanT5000> no, i'm assuming that "object" will be basically just an ID
14:14:19 <mmorrow> oh, beautiful. if it's an Int, i'd use IntMap
14:14:28 <RyanT5000> yeah
14:14:42 <mle> ints would be pretty fast, yep :p
14:14:46 <mmorrow> (and if you can wiggle the Tags to be Ints, IntSet too)
14:14:56 <RyanT5000> now, what i'd really like to do is combine that with a quadtree
14:15:03 <RyanT5000> to give each object a location as well
14:15:26 <RyanT5000> i'd like to be able to make compound queries like "Possessing these tags and within these boundaries"
14:15:34 <mmorrow> you can build pretty much anything my using (Int)Map,(Int)Set,Tree,Sequence like legos
14:15:39 <mmorrow> s/my/by/
14:16:14 <RyanT5000> yeah, but i'm not really sure how to make it efficient to do spatial lookups together with tag-based ones
14:16:14 <jmcarthur_work> it took me some time to convince myself that such an approach elegant at all
14:16:43 <RyanT5000> it's really subqueries i'm interested in
14:17:01 <mmorrow> jmcarthur_work: legos are great! ;)
14:17:10 <jmcarthur_work> mmorrow, yes indeed
14:17:11 <mle> spatial structures are a bit trickier.  I not familiar with any good functional implementations, but there probably are some?
14:17:36 <RyanT5000> yeah, Data.SpacePart.QuadTree,e.g.
14:17:43 <mmorrow> RyanT5000: yeah, i'm not sure exactly what you'd consider wrt that (mixing spatial with stuff)
14:17:57 <jmcarthur_work> speaking of sets... does anybody know if there are any known set-like data types with a very fast intersection operation?
14:18:10 <RyanT5000> mmorrow: i was thinking of interspersing the datastructures, since they're both trees
14:18:26 <jmcarthur_work> better the O(m+n), that is?
14:18:29 <jmcarthur_work> *than
14:18:33 <mmorrow> jmcarthur: IntMap(Set) has super fast union, not sure about intersection though
14:18:33 <RyanT5000> mmorrow: e.g.: have a quadtree node, whose children are all Map nodes, whose children are all quadtree nodes, etc.
14:18:44 <mmorrow> jmcarthur: IntMap is best-case O(1) union
14:19:01 <mmorrow> (not counting the trivial case)
14:19:14 <mmorrow> RyanT5000: oh cool, yeah
14:19:44 <jmcarthur_work> eh, i'm really looking for intersection though
14:20:26 <pejo> jmcarthur_work, could you elaborate why there should be something faster than O(n+m)?
14:20:28 <RyanT5000> mmorrow: i just have two problems with that plan: 1) how do i represent it in the Haskell type system (is TH required?)? (2) can the same idea be expanded to hash tables or arrays or other lookup-based datastructures?
14:20:59 <jmcarthur_work> pejo, i'm not saying there should be. just wondering if there is anything known, or if there is some reasoning to say that it's impossible. i would be happy with either
14:21:09 <RyanT5000> (by TH being "required", i mean "for it to be practical to use")
14:21:51 <pejo> jmcarthur_work, just realized that you could have the complexity some elsewhere, having sorted sets for example. So there probably is an algorithm atleast.
14:22:08 <mmorrow> type M f k a = Map k (Maybe a, f (M k a)); type Four a = (a,a,a,a); data QMap k a = QMap (Four (M (QMap k) k a))
14:24:39 <RyanT5000> mmorrow: that's similar to what i was thinking, except that i was thinking of putting just a single Map-style node at each level (instead of a whole Map)
14:24:45 <jmcarthur_work> pejo, well, sorted sets is where i got the O(m+n) algorithm
14:24:54 <RyanT5000> mmorrow: the types are much cleaner than i was expecting, though :P
14:34:33 <camio> I just finished reading "Fun with type functions". I love the idea of algebraic data kinds! Anyone else relate?
14:35:03 <mmorrow> RyanT5000: i'd probably try something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5379#a5379
14:37:23 <camio> Ah well, I suppose most of you are algebraic data kind fans, but just don't know it yet.
14:39:53 <mmorrow> camio: heh
14:41:07 <mmorrow> newtype QTree a = QT (Four (a, QTree a))
14:41:32 <mmorrow> RyanT5000: you mean something like that (w/out the map)?
14:42:36 * mmorrow becomes interested in QuadTrees all of a sudden..
14:44:19 <Cale> camio: Yeah, GHC's kind system is not very impressive at the moment.
14:45:30 <camio> Cale: I'm sure it'll get there and go in that direction once people bear witness to that power.
14:46:29 <camio> Especially with Omega making its mark.
14:46:35 <Cale> camio: Well, we can do type-level programming, but it's all *untyped* type level programming
14:46:48 <camio> yeah, exactly
14:47:12 <camio> From the paper I got a sense that it wouldn't be to difficult to add typed type programming to ghc.
14:47:29 <heatsink> Maybe I'm being simplistic, but since type classes are sets of types, don't they act like kinds?
14:47:43 * jmcarthur_work wishes for a direct jump into dependent types
14:48:22 <jmcarthur_work> of course dependently typed languages, so far, have been rather complex, but only when using dependent types to do... EVERYTHING
14:48:29 <Cale> heatsink: They are like sets of types which are *open* in the sense that you can't for certain while compiling a module say that a type is *not* a member of some typeclass.
14:48:35 <jmcarthur_work> if used more conservatively i think it would be no harder to use than haskell currently is
14:48:57 <heatsink> Cale: problematic if you want to do case analysis I guess
14:49:31 <Cale> heatsink: and it's impossible to decide that some type-level expression is ill-kinded because of it
14:49:49 <Cale> For example, I might have
14:49:54 <Cale> data Zero = Zero
14:49:59 <Cale> data Succ n = Succ n
14:50:08 <Cale> class Nat n where
14:50:20 <Cale>   realise :: n -> Integer
14:50:27 <jmcarthur_work> i think researchers are hesitant to not use dependent types all over the place in dependently typed languages because it goes against the ultimate goal of 100% verified programs. the real practice of dependent types doesn't _have_ to be that way though, at least as a stepping stone
14:50:29 <heatsink> Cale: data Nat n => Succ n = Succ n
14:50:37 <Cale> heatsink: sure
14:50:41 <jmcarthur_work> eek, confusing double negative there
14:50:54 <Cale> heatsink: But nothing will stop me from making Integer an instance of Nat
14:51:30 <camio> Type programming without types reminds me a lot of c++ template programming.
14:51:40 <jmcarthur_work> camio, yes!
14:52:33 <Eelis> jmcarthur_work: one rather big issue one encounters when writing simply-typed programs in a dependently-typed language is the need to prove that all recursions terminate.
14:53:02 <jmcarthur_work> Eelis, a termination checker is not required for dependent types if you accept the possibility of nonterminating type checking
14:53:05 <heatsink> Cale: I see.  The definition of 'realise' can always be extended with junk.
14:53:15 <Eelis> jmcarthur_work: and you would propose that?
14:53:36 <Cale> heatsink: Or even seemingly sensible things like realise x = x :)
14:54:08 <Eelis> jmcarthur_work: also, you not only lose decideable type checking, you also lose logical consistency, defeating much of the point of using dependent types.
14:54:10 <jmcarthur_work> Eelis, tentatively, unless i am convince that it is such a bad thing
14:54:27 <jmcarthur_work> how do you lose logical consistency?
14:54:41 <Eelis> jmcarthur_work:   Fixpoint silly: False := silly.
14:55:51 <defun> I have trouble understanding the paper on arrows; particularly where they state that arrows are better suited for parser-combinators than monads. Can someone explain why this is the case?
14:56:23 <jmcarthur_work> Eelis, okay good point. still, i don't see what would be wrong with only allowing values in the type level if they are provably terminating. that doesn't require that _everything_ terminate, at least
14:56:30 <mmorrow> Eelis: sure, if you want to be a theorem checker.
14:56:49 <jmcarthur_work> has the same problem you said, but i'm with mmorrow on that
14:56:50 <Cale> defun: Well, there is the fact that arrow-based parsers allow more runtime optimisation
14:57:01 <Eelis> mmorrow: as one's types become more expressive, the distinction between programming and theorem proving vanishes :)
14:57:07 <jmcarthur_work> and it wouldn't be used as a type
14:57:19 <Cale> defun: With a monad, when you have a function of type a -> M b, there's no way to say anything about the structure of that function. All you can do is apply it.
14:57:49 * jmcarthur_work thinks that ideally the compiler does the proving for you, but of course we are _far_ from such a thing, if it's even possible
14:57:51 <Cale> defun: But with an arrow, you can have some special cases of P a b where you know the structure of what's going on.
14:58:04 <Cale> defun: and your evaluator can take advantage of that
14:58:04 <jmcarthur_work> well, it is simplistically possible
14:58:09 <defun> So arrows are more abstract?
14:58:11 <jmcarthur_work> but maybe not practically
14:58:17 <Cale> defun: Yeah.
14:58:24 <defun> thanks.
14:58:46 <Cale> defun: But in practice, arrows have not really caught on very well, because they are somewhat unwieldy.
14:59:08 <Cale> (in terms of syntax, particularly)
15:00:16 <jmcarthur_work> i think a lot of people view arrows as more general than necessary for most possible applications, too
15:00:30 <Cale> yeah
15:00:56 <jmcarthur_work> which is kind of disappointing, considering that arrows are cool
15:01:16 <Cale> With Applicative, you get your applicative instance basically for free, once you have a Monad instance
15:01:29 <Cale> So there are a lot of Applicative instances.
15:01:49 <Cale> With Arrow, you have to do clumsy wrapping and unwrapping to turn a monad into an Arrow
15:02:21 <jmcarthur_work> yes, but the instance is still free
15:02:39 <Cale> If you write the wrapper, yes.
15:02:44 <jmcarthur_work> you just don't necessarily gain much due to the extra syntactical cost
15:03:58 <jmcarthur_work> :t runKleisli
15:03:59 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
15:04:02 <jmcarthur_work> :t runReaderT
15:04:03 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
15:04:10 <jmcarthur_work> shame those two can just be the same thing :(
15:04:13 <jmcarthur_work> *can't
15:06:16 <Cale> Some people are really silly when it comes to using compression. I downloaded a rar with 3 parts, unpacked it, and it unpacks a rar with 36 parts... and the data is all practically incompressible to begin with.
15:06:25 <jmcarthur_work> ...
15:06:55 <bd_> Cale: usenet rars repacked for IRC bots, I'd guess?
15:07:17 <Cale> Probably something like that, though I got it from the web
15:07:29 <bd_> or split up for an uploader, I guess
15:07:58 <Cale> I've even seen torrents doing that
15:08:04 <Cale> Torrents!
15:08:17 <bd_> yep. people don't want to take time to decompress things before moving them to a new protocol
15:11:04 <ksf> with torrents, any compression hurts the swarm, as many people don't keep around both compressed and uncompressed versions of stuff, so they don't seed.
15:11:43 <ksf> OTOH, they could add transparent compression to the protocol.
15:12:14 <Cale> haha, it turns out that just converting the bin/cue to an iso compresses it by more than rar can manage.
15:12:18 <ray> i don't even bother with those torrents that are archived
15:12:33 <ray> you can generally find another one
15:12:41 <Cale> (or more than it did manage, anyway)
15:17:29 * lysgaard leaving
15:17:56 <cads> salut prieteni!
15:19:40 <cads> if haskell had dependent tuple types, what'd be a good notation for the type declaration of a function operating over tuples of arbitrary dimension and type?
15:21:26 <cads> hrm, I think that's too involved of a question for me to ask it and expect someone else to figure it out for me ;)
15:22:31 <cads> I've been afraid of agda and co. for a long time, I think it's time to read a intro paper
15:26:01 <Cale> cads: Well, would it really need the dependent types part?
15:26:11 <Cale> cads: I suppose it depends on what operation you mean.
15:26:24 <Cale> cads: But type functions basically give you a decent syntax
15:26:48 <Cale> (You can sort of do this already)
15:43:03 <ole__> Hey, may I ask a noob question.
15:43:13 <ole__> I have trouble with ghci importing modules that I have created myself.
15:43:24 <ole__> The module that I wish to load are located in the same dir as the Main module.
15:43:40 <Absolute0> ole__: ':l ModuleName' for ModuleName.hs
15:43:41 <Philonous> Why does ghc give me an overlapping instances error here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5384#a5384 ? The first instance it mentions doesn't even hold
15:52:22 <ksf> cads, thanks for reminding me to continue grokking CT.
15:54:00 <ksf> http://books.google.de/books?id=SJVsb1jCZu8C&printsec=frontcover
15:54:32 <ksf> it's the best CT intro I've come across
15:57:16 <cads> thanks for that ksf
15:57:39 <cads> cya'll later!
16:07:09 <conal> i'm having a Cabal problem, with License-File: UnknownLicense "foo".  I get "Parse of field 'license-file' failed."  When I try 'read' on that string in ghci, it works fine.
16:07:30 <conal> the string being: "UnknownLicense \"foo\""
16:07:41 <conal> for type License.
16:08:20 <ksf> did you try it without "UnknownLicense"?
16:08:33 <conal> oops!  never mind.  license-file instead of license
16:08:50 <conal> oh.  same problem.  odd.
16:08:59 <dcoutts> conal: license-file is a path, licence is a license
16:09:13 <dcoutts> conal: it parses, it's not using read
16:09:53 <dcoutts> conal: so if you use license: foo, then that'll parse to UnknownLicense "foo"
16:10:09 <dcoutts> (and you'll not be able to upload it to hackage)
16:10:46 <conal> dcoutts: oh!  so i guess OtherLicense is my best shot, plus a license-file?
16:10:51 <dcoutts> conal: yep
16:11:21 <conal> dcoutts: thanks.  doesn't that mean someone viewing the hackage page can't know what license i use?
16:11:36 <dcoutts> conal: right, not without reading it
16:11:42 <conal> dcoutts: oh -- i guess i'd put the license name in a .cabal comment .
16:11:58 <conal> dcoutts: thanks.  that's what i'll do.
16:12:03 <dcoutts> conal: the point of the license field is not to be exhaustive for all possible names of licenses that exist or you might make up, it's so that when people use common licenses that they use the same name for the same thing
16:12:16 <dcoutts> conal: out of interest, which license is that?
16:12:28 <conal> dcoutts: AGPLv3
16:12:38 <dcoutts> ah
16:12:52 <conal> dcoutts: may be worth adding.  seems to be a worthwhile patch to GPLv3
16:13:24 <dcoutts> conal: yeah, I occasionally survey the ones using OtherLicense to see which others are most popular
16:14:20 <dcoutts> added MIT and versioned (L)GPL as a result
16:14:40 <dcoutts> the other popular ones were unions or intersections of GPL & BSD
16:14:55 <conal> dcoutts: nice.  have you seen AGPL in use yet?
16:15:01 <dcoutts> conal: not yet
16:15:33 <conal> dcoutts: glad to see the versioned GPL.  thanks!
16:16:37 <ksf> hmmm... agpl... reactive web framework...
16:16:53 <conal> ksf: good idea
16:19:41 <conal> Baughn: ping
16:33:29 <hackagebot> unamb 0.2
16:34:23 <ksf> zomg: "Given no objects, there is an object 1 with no maps, and given any other object K and no maps, there is a unique arrow  ! : X -> 1 making nothing further commute."
16:34:42 <ksf> oh, s/K/X/
16:35:06 <conal> @tell Baughn i just release unamb-0.2 to hackage, with your contributions.  thanks!  reactive is next.
16:35:07 <lambdabot> Consider it noted.
16:37:01 <conal> i love cabal-make.  i say "make release", and i get automatic clean build, haddock docs, version tagging, push, tarball, and hackage upload
16:50:32 <hackagebot> reactive 0.11
17:15:11 <phenrique> ex = [2,4,7]
17:15:11 <phenrique> ex1 = [ a | a <- ex, a 'mod' 2 == 0]
17:15:37 <phenrique> lexical error in string/character literal at character 'o'
17:15:40 <phenrique> why?
17:15:53 <phenrique> only work if mod a 2
17:15:57 <phenrique> ghci
17:16:12 <ClaudiusMaximus> you probably mean `mod` (infix operator) instead of 'mod' (character literal)
17:16:35 <ClaudiusMaximus> > 42 `mod` 5
17:16:36 <lambdabot>   2
17:17:35 <Jedai> phenrique: the ` around `mod` are backquotes
17:20:53 <phenrique> Thanks Jedai :)
17:22:21 <phenrique> Thanks CladiusMaximus
17:29:35 <PetRat> I'm trying to install HDBC-mysql on a Windows box. HDBC is already installed. I downloaded the tar file and put it in a directory. I went into that directory and ran cabal install. cabal got as far as saying "Linking .\dist\setup\setup.exe and has now hung for ten minutes. What should I check next?
17:34:23 <jaredj> help, my brain isn't quickcheck shaped
17:34:38 <Gracenotes> :o
17:34:41 <MyCatVerbs> jaredj: just write a function from random data to Bool.
17:34:47 * Baughn grabs jaredj's brain and starts cutting it in shape
17:34:47 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
17:34:58 <jaredj> owowow
17:35:05 <MyCatVerbs> @check \a b c -> (a + b) + (c :: Int) == a + (b + c)
17:35:06 <lambdabot>   "OK, passed 500 tests."
17:35:37 <PetRat> I'm trying to install HDBC-mysql on a Windows box. HDBC is already installed. I downloaded the tar file and put it in a directory. I went into that directory and ran cabal install. cabal got as far as saying "Linking .\dist\setup\setup.exe and has now hung for ten minutes. What should I check next?
17:35:38 <MyCatVerbs> Okay, easy version. You need to write an expression which is Testable.
17:35:44 <MyCatVerbs> A Bool is Testable.
17:36:12 <MyCatVerbs> A function from something that QC knows how to generate random instances of is Testable too.
17:36:16 <MyCatVerbs> @check True
17:36:17 <lambdabot>   "OK, passed 500 tests."
17:36:30 <MyCatVerbs> jaredj: does that make sense?
17:37:12 <jaredj> MyCatVerbs: for little simple things
17:37:28 <jaredj> MyCatVerbs: i'm trying to test a parser, so i need to make arbitrary strings
17:38:09 <MyCatVerbs> Oh, so you need to write an Arbitrary instance.
17:38:22 <jaredj> of the form "KEY:VALUE\r\nKEY2:VALUE2\r\n\r\n"
17:38:38 <MyCatVerbs> Right. Make a newtype for it, and put an Arbitrary instance together for the newtype.
17:38:51 <PetRat> Okay I tried again to get it from the web and got this error: http://www.mibbit.com/pb/nM797u
17:39:01 <PetRat> (tried to get HDBC-mysql)
17:39:32 <MyCatVerbs> So, newtype TestString = TS [Char]. instance (Arbitrary TestString). Then your checks look like (\(TS input) -> ...)
17:39:54 <jaredj> MyCatVerbs: i think i have too many newtypes
17:40:12 <jaredj> i made a newtype Key and a newtype Value
17:40:29 <Gracenotes> newtypes for instances... a necessary evil? News at 11
17:40:34 <MyCatVerbs> So? That doesn't even necessarily matter, it'll just be a bit verbose.
17:40:35 <jaredj> and an Arbitrary Key (a choice from a fixed list)
17:41:02 <jaredj> and an Arbitrary Value (made via an Arbitrary String out of Arbitrary Chars)
17:41:41 <jaredj> I think arbitrary 2-tuples are constructed for me, and arbitrary lists are too
17:42:15 <MyCatVerbs> jaredj: sounds like you're getting along just fine. What's your issue?
17:43:21 <jaredj> those last two things that get automatically constructed
17:43:37 <jaredj> they make my mind slip off of what type my property function should be
17:44:21 <jaredj> out of an Arbitrary [(Key,Value)] i make a String, then parse the String into [(String, String)]
17:44:54 <MyCatVerbs> Yep.
17:45:30 <jaredj> so - prop_blabla :: [(Key, Value)] -> Bool?
17:46:09 <MyCatVerbs> So you want something like (\keyvaluepairs -> parse (buildString keyvaluepairs) == map (\(Key k,Value v) -> (k,v)) keyvaluepairs)
17:46:53 <MyCatVerbs> i.e. run the constructed string through your parser, and check that the output of that was correct for the keys and values that were passed in.
17:48:54 <jaredj> :d
17:51:18 <PetRat> Okay I tried to get HDBC-mysql and got this error: http://www.mibbit.com/pb/nM797u
17:52:15 <gwern> PetRat: guessing you didn't install mysql
17:57:07 <PetRat> gwern: I installed mysql in the sense of downloading a thing from the mysql website and extracting it. I now have several programs available on the start menu including the query browser. Is there something else I need to do?
17:57:24 <gwern> find out where the missing binary comes from
17:57:34 <gwern> a complex package like mysql may be broken up several ways
17:58:17 <PetRat> is the error telling my that mysql_config can't be found? That doesn't sound like a binary.
17:58:33 <PetRat> Or is that a file that would come with the source for mysql?
17:58:35 <jaredj> got it! thanks MyCatVerbs
17:59:12 <gwern> PetRat: mysql_config sounds like a binary to me
17:59:45 <PetRat> gwern: by the way I'm not installing a mysql db itself on my machine... I only need the interface to connect to a mysql server on another machine. Can you give me any clue what to search for to find this binary?
17:59:53 <gwern> nope
18:12:17 <Badger> PeakerWork: ping
18:18:24 <Qriva> What is "Literate Haskell"?
18:21:09 <dolio> It's haskell where the default mode is commenting.
18:21:16 <dolio> And you have to put delimiters around the code.
18:21:31 <dolio> (Or in front of it on a line, as the case may be.
18:21:36 <Qriva> dolio: ahh
18:21:36 <Qriva> thanks
18:21:45 <MyCatVerbs> There are two formats for it. Bird script, where the Haskell lines have > at the front and everything without a > is a comment.
18:22:15 <MyCatVerbs> The other one is TeX notation, where Haskell code is between \begin{code} and \end{code} markers, and everything else is treated as a comment.
18:22:36 <MyCatVerbs> The markers have to be on lines by themselves in that one.
18:23:32 <dolio> I'm not sure if you can mix and match, so it may not be strictly the inverse of commenting.
18:23:39 <dolio> Converse?
18:24:15 <dolio> Obviously you can't mix and match if you want to produce correct looking latex at the end.
18:24:30 <MyCatVerbs> AFAIK mixing and matching is not supported at all.
18:25:48 <MyCatVerbs> Oh, no, you're right. You can mix and match them freely. It's just that nobody thinks that that is a good idea.
18:26:19 <J11> Is the TeX notation used much?
18:26:45 <SamB> J11: not too unoften
18:27:11 <SamB> the bird feet are used in a lot of the emails that Oleg writes ...
18:27:17 <MyCatVerbs> J11: AFAIK people sometimes use it in papers.
18:27:33 <MyCatVerbs> You see Bird notation an awful lot more online, in people's blogs and such.
18:28:06 <J11> Because I use Literate.lhs to delit lhs, but I only see bird notation there
18:28:38 <povman> My brother wanted me to make a set of functions e.g. isOne = (== 1), isTwo = (== 2) etc.
18:28:45 <povman> I got the chance to say
18:28:47 <povman> @faq
18:28:47 <lambdabot> The answer is: Yes! Haskell can do that.
18:29:07 <SamB> > map (==) [1..]
18:29:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
18:29:08 <lambdabot>    arising fro...
18:29:14 <MyCatVerbs> povman: better yet, don't hardcode the values directly into the code like that!
18:29:19 <SamB> > map (==) [1..] :: [Int -> Bool]
18:29:20 <lambdabot>   Overlapping instances for GHC.Show.Show
18:29:20 <lambdabot>                              (GHC.T...
18:29:25 <povman> I was thinking of TH
18:29:26 <SamB> > map (==) [1..] :: [Expr -> Bool]
18:29:27 <lambdabot>   Overlapping instances for GHC.Show.Show
18:29:27 <lambdabot>                              (Simpl...
18:29:39 <povman> He doesn't care what it actually does, he just wants the symbols there
18:29:42 <MyCatVerbs> povman: {-# LANGUAGE Cpp #-}, then #define ONE 1... isOne = (== ONE)
18:30:10 <povman> Even better, use an english number generator in TH
18:30:58 <povman> But then I decided that was entirely useless and didn't.
18:31:09 <povman> </story>
18:31:15 <Qriva> I don't think Haskell is working properly -- it doesn't seem to know what putStrLn is, and it doesn't like me using "name <- getLine"
18:31:57 <povman> Qriva: moonpatio.com
18:32:40 <MyCatVerbs> povman: the disturbing thing is that the TH solution almost sounds appealing.
18:32:55 <povman> :D
18:33:39 <Qriva> povman: it's up there
18:33:40 <povman> The only downside is that it's completely RIDICULOUS
18:34:32 <Qriva> povman: something messed up with my indentation i guess
18:34:43 <povman> Qriva: I see your indenting is all out of whack. All the stuff in the 'do' should be lined up. I'd use spaces rather than tabs.
18:34:54 <Qriva> povman: i have textmate setting my tabs as 2 spaces
18:35:00 <Qriva> but for some reason it used actual tabs
18:35:02 <povman> not in that paste
18:35:06 <Qriva> yeah i know that's weird
18:35:09 <Qriva> thanks though
18:35:11 <povman> hang on
18:35:28 <povman> make sure it's set to 'soft tabs'
18:35:38 <Qriva> povman: yeah it is now, i think it's on a per bundle basis
18:35:44 <povman> ah
18:36:14 <Qriva> i have to do it: "damn kids and their fancy textmates"
18:36:30 <Qriva> in MY day we had to hit the space bar
18:36:40 <povman> you still do in tm
18:36:47 <Qriva> well sure, it was a joke
18:36:56 <povman> it's emacs users that get it easy
18:37:02 <Qriva> not at first ;)
18:37:45 <Qriva> and by "not at first" i mean: i've tried to learn emacs a few times now with limited amounts of success
18:38:15 <povman> I'm quite sure it's possible to make emacs work exactly like textmate, but noone has yet
18:39:28 <thoughtpolice> for snippet functionality there's the yasnippet extension
18:39:32 <thoughtpolice> there's one for vim too
18:39:49 <povman> say, isn't  haskell ~ yi  ==  lisp ~ emacs ?
18:39:58 <thoughtpolice> something like that, yes :)
18:40:12 <povman> I ought to have a go at it
18:47:20 <povman> ha. ghc-6.10.1 requires old-time ==1.0.0.2 however old-time-1.0.0.2 was excluded because ghc-6.10.1 requires old-time ==1.0.0.1
18:55:27 <shapr> @seen luqui
18:55:27 <lambdabot> I saw luqui leaving #haskell 4m 10d 20h 25m 26s ago, and .
18:59:10 <kniu> de bruijn representations,
18:59:20 <kniu> as described in TaPL, confuse me.
18:59:38 <kniu> why define a "family of sets" containing the terms?
19:00:25 <kniu> also, by just choosing a hard number with which to represent free variables, what if the lambda terms extend too far and collide with the chosen numbers?
19:00:36 <kniu> Ain't that the same problem as before?
19:06:56 <iop> > Just 5 >>= (+1)
19:06:57 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
19:06:57 <lambdabot>    arising from the lite...
19:07:02 <iop> > Just 5 >>= return (+1)
19:07:03 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
19:07:03 <lambdabot>  but its type `Data.Maybe.May...
19:07:06 <iop> > Just 5 >>= return . (+1)
19:07:08 <lambdabot>   Just 6
19:07:22 <iop> > Just 5 >>= return $ (+1)
19:07:23 <lambdabot>   Couldn't match expected type `a -> a1'
19:07:31 <iop> > Just 5 >>= \j -> return $ (+1) j
19:07:32 <lambdabot>   Just 6
19:07:39 <iop> > Just 5 >>= return . (+1)
19:07:41 <lambdabot>   Just 6
19:07:54 <iop> > fmap (+1) (Just 5)
19:07:55 <lambdabot>   Just 6
19:07:59 <iop> > <$> (+1) (Just 5)
19:08:01 <lambdabot>   <no location info>: parse error on input `<$>'
19:08:06 <iop> > (+1) <$> (Just 5)
19:08:08 <lambdabot>   Just 6
19:08:27 <iop> > (+1) . (Just 5)
19:08:28 <lambdabot>   Couldn't match expected type `a -> b'
19:08:41 <iop> do you use fmao a lot?
19:08:53 <iop> fmap
19:09:00 <glguy> iop, you can send those commands to lambdabot in /msg
19:09:05 <glguy> if you want to avoid flooding the channel
19:10:28 <iop> is there a funcvtion mapcat?
19:13:29 <enolan> :t concatMap
19:13:30 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:13:32 <ski> > concatMap show [1,23,456]
19:13:34 <lambdabot>   "123456"
19:14:44 <ski> > concatMap tails . inits $ [0,1,2,3]
19:14:46 <lambdabot>   [[],[0],[],[0,1],[1],[],[0,1,2],[1,2],[2],[],[0,1,2,3],[1,2,3],[2,3],[3],[]]
19:29:36 <jaredj> i'm  a text-only terminal. w3ming through hathe docs is killing me. is there any text command to list functions in a module, or show documentaton for one function?
19:30:46 <MyCatVerbs> :browse
19:31:05 <MyCatVerbs> e.g. :browse Data.Map, prints all the function names and types exported by Data.Map.
19:31:46 <MyCatVerbs> Unfortunately there's no exporting of plaintext documentation to anywhere where GHCi can see it.
19:33:19 <jaredj> ah. well thx. stuff gets old over screen at 19200 bps
19:33:41 <MyCatVerbs> Ouch. Slow terminals suck. :/
19:34:06 <MyCatVerbs> Might lynx be a better choice of browser for a slow terminal than w3m?
19:34:27 <jaredj> 486 running kermit in dos, serial port -> gumstix running linux, wifi -> ssh -> normal box :)
19:34:35 <jaredj> probably
19:34:36 <hdh> BONUS: the sentence before http://learnyouahaskell.com/syntax-in-functions#case-expressions says "and some that's more readable."
19:34:41 <MyCatVerbs> Dear me. Why...?
19:34:50 <hdh> missing a "think"
19:35:05 <p_l> jaredj: any chance of modding it to use >1MBit serial? :)
19:35:54 <jaredj> two computers, one screen, one wife on facebook :)
19:36:18 <MyCatVerbs> Ye gods, that's inhumane.
19:37:07 <jaredj> look out, she got off facebook and now she's watching ;)
19:37:36 <Ralith> tell her her treatment of you is cruel and unusual
19:38:59 <MyCatVerbs> Better idea, tell her she looks gorgeous in whatever she's wearing, and that perhaps she might like to take it off.
19:39:08 <MyCatVerbs> Then forget about IRC and facebook for a few hours.
19:39:19 <jaredj> *blush*
19:39:37 <MyCatVerbs> Bah, humbug. Married humans should be banned from blushing.
19:39:55 <gwern> and married women should be in wimples
19:39:58 <gwern> and burkhas!
19:40:26 <MyCatVerbs> gwern: let's please have exactly the opposite of that rule.
19:40:33 <jaredj> i agree (says the wife who is typing this sentence) and for teh record he's just too lazy to move and go back to the other computer which i did offer him
19:40:38 <gwern> thye... should be naked?
19:40:54 * gwern ponders the opposite of wearing a wimple. becoming bald?
19:41:10 <jaredj> bahaha bad timing
19:41:30 <MyCatVerbs> gwern: no, they should be wearing more or less whatever they feel like, rather than constrained to any given outfit. :P
19:50:11 <iop> > return . (+1) =<< Just 5
19:50:12 <lambdabot>   Just 6
19:58:23 <hatds> is there a way to view fixities in ghci?
19:58:39 <bos> :info
19:59:01 <bos> as in, ":info (+)"
19:59:31 <hatds> thanks
20:01:10 <chessguy> :info (+)
20:01:14 <chessguy> @info (+)
20:01:15 <lambdabot> (+)
20:01:28 <chessguy> wow. thanks, LB...
20:01:37 <chessguy> @help info
20:01:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:08:47 <BMeph> bos: Actually, I don't think you even need the parens around it.
20:09:09 <dmwit> chessguy: ?info corrects to ?undo
20:09:23 <chessguy> uh
20:09:25 <chessguy> wow
20:09:28 <chessguy> @help undo
20:09:28 <lambdabot> undo <expr>
20:09:29 <lambdabot> Translate do notation to Monad operators.
20:09:37 <chessguy> oh, _that_ undo
20:09:38 <dmwit> ?info do { x <- f; return (g x) }
20:09:39 <lambdabot> f >>= \ x -> return (g x)
20:09:54 <chessguy> that's...awesome
20:09:58 <dmwit> ?undo do { (Foo x) <- f; return (g x) }
20:09:59 <lambdabot> f >>= \ a -> case a of { (Foo x) -> return (g x); _ -> fail ""}
20:10:07 <dmwit> Wow, it actually gets that right!
20:10:10 <dmwit> undo++
20:12:44 <hatds> ?undo return ()
20:12:44 <lambdabot> return ()
20:12:48 <hatds> ?undo do return ()
20:12:49 <lambdabot> return ()
20:12:51 <hatds> :)
20:14:38 <BMeph> I wish I had "undo" on my system... :)
20:14:52 <Berengal> Ctrl-Z
20:14:57 <Berengal> :)
20:15:09 <gwern> BMeph: you could install lambdabot
20:15:27 <Gracenotes> FAIL
20:15:42 <BMeph> gwern: Well, I could _try_, you mean. ;p
20:16:12 <gwern> lambdabot isn't as impossible to install as it used to be...
20:17:09 <chessguy> so it only requires one advanced degree instead of 4?
20:17:11 <Berengal> lambdabot doesn't do bf anymore :(
20:17:12 <Gracenotes> man the cabal
20:17:14 <MyCatVerbs> I swear lambdabot used to rely on bugs in GHC at one point.
20:17:15 <Berengal> @bf .,
20:17:16 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
20:17:33 <gwern> Berengal: that's because the brainfuck interpreter isn't installed on the machine lambdabot is running on
20:17:33 <MyCatVerbs> But that's just a pessimistic overstatement, I think.
20:17:36 <gwern> (probably)
20:17:38 <Gracenotes> you need to pass Computer Science III to install a lambdabot
20:17:43 <Gracenotes> fact
20:17:52 <gwern> Gracenotes: really, a 'cabal install lambdabot' should work!
20:19:08 * MyCatVerbs tries it.
20:19:28 <MyCatVerbs> Compiling HTTP... binary...
20:19:48 <MyCatVerbs> Brainfuck? It seriously has a brainfuck interpreter in it? ô_Ô
20:19:59 <Berengal> @help bf
20:20:00 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
20:20:02 <michaeljt> so far, that's all thats installed for me
20:20:47 <michaeljt> now unlambda....
20:20:47 <MyCatVerbs> @oeis map (join (*)) [1..10]
20:20:48 <lambdabot>  Sequence not found.
20:21:05 <MyCatVerbs> @oeis [1,4,9,16,25]
20:21:06 <lambdabot>  Sequence not found.
20:21:35 <gwern> MyCatVerbs: no, it shells out to a bf interpreter
20:21:42 <MyCatVerbs> Oh, right. It doesn't want the args in list notation or anything.
20:21:48 <gwern> since I thought it was silly to have a bf interpreter in lambdabot...
20:22:11 <MyCatVerbs> Hrmn. The lambdabot build failed loading ncurses.
20:22:23 <Berengal> ncurses?!
20:22:33 <Berengal> What does \b need ncurses for?
20:22:36 <gwern> template haskell. what a flaky tech
20:23:03 <gwern> sometimes I wish for a haskell-scheme hybrid, with macros and all
20:23:05 <MyCatVerbs> TH uses ncurses!?
20:23:24 <outchanter> liskell?
20:23:29 <Berengal> gwern: liskell
20:23:34 <gwern> Berengal: dead
20:24:01 <gwern> (and that doesn't get us various advantages of scheme like a less bdsm type system)
20:24:02 <Berengal> gwern: "Make it live again, then", I suppose is the reply I should be making
20:24:13 <gwern> Berengal: it's a fork of ghc; that's madness
20:24:17 <bnijk> what is this "pony" package?
20:24:21 <bnijk> i want to install it real badly
20:24:38 <bnijk> in hackage
20:24:41 <gwern> bnijk: everyone wants a pony
20:24:45 <gwern> just give in already'
20:24:49 <Berengal> gwern: Haskell without the types is basically lisp with ml-syntax already...
20:24:49 <bnijk> what is it!
20:25:36 <gwern> MyCatVerbs: also, TH probably links in ncurses because of the whole ghci infrastructure; lambdabot itself isn't declaring or using anything with ncurses
20:25:52 <gwern> it has a prompt, yes, but it's your normal repl
20:26:09 <MyCatVerbs> Hrmn.
20:27:55 <bnijk> is there a list somewhere of really weird linux programs
20:28:00 <bnijk> stuff like amor and cowsay
20:28:13 <p_l> bnijk: afaik no such list
20:28:47 <p_l> bnijk: unfortunately that's why sometimes you need to grab a book or get a course - a lot of interesting stuff passes by unnoticed without those :)
20:29:11 <gwern> (well, lambdabot installs and runs without a problem here)
20:29:18 <bnijk> hm
20:29:19 <gwern> psnively says: All your Data.Foldable are belong to base.
20:29:19 <outchanter> wouldn't it be easy to reimplement liskell as a scheme preprocessor that produces .hs files?
20:29:26 <michaeljt> oh, here's the you-can-have-pony film  http://www.youtube.com/watch?v=Tu0iuHxL3z8
20:29:49 <dolio> What's the deal with -XMonoLocalBinds?
20:30:04 <kniu> bnijk, for some fun, check out "sex"
20:30:09 <gwern> outchanter: what happens when you write something that doesn't type in haskell but would be fine scheme?
20:30:27 <michaeljt> repent
20:30:29 <kniu> I've had my share of amusement trolling IRC channels with its output.
20:30:37 * MyCatVerbs grumbles about Arch Linux and linker scripts.
20:30:56 <bnijk> ²²ooo
20:31:04 <bnijk> this looks funny
20:31:06 <gwern> michaeljt: repent and rethink one's sins^Wsource eh
20:31:13 <bnijk> i write poetry like this
20:31:32 <bnijk> "Help!" stammered the saucy sausage abuser as the pile-driving faggot butler sucked her rosebud paps and crammed his miniscule meat loaf into her gobbling slot machine.
20:31:50 <bnijk> hmmm
20:32:04 <outchanter> gwern: a scheme embedded in Haskell as a scripting language?
20:32:32 <MyCatVerbs> gwern: lambdabot doesn't seem to depend on mueval for some reason?
20:32:36 <michaeljt> gwern: lambdabot cabal-installed, amazing
20:32:51 <gwern> MyCatVerbs: cabal can't express runtime deps on executables
20:33:23 <gwern> MyCatVerbs: since mueval also exposes a library, I *could* add a dep on mueval-library, but I feel like dcoutts turns in his grave everything I do that hack
20:33:37 <MyCatVerbs> Heh. Good reason. :)
20:33:41 <gwern> outchanter: or maybe the other way around ala typed scheme
20:34:14 <outchanter> gwern: qi? http://en.wikipedia.org/wiki/Qi_(programming_language)
20:34:40 <Gracenotes> hm, GHC says it doesn't recognize -XNoHugeExecutable!
20:34:56 <gwern> outchanter: well, qi is weird. but any language with a easily turing complete type system is weird
20:35:20 <dolio> Qi's type system seems to be very programmable.
20:35:34 <gwern> Gracenotes: just as well. the pragma could only throw an error telling you to go try jhc
20:35:52 <gwern> dolio: well, yeah. that's the point of qi, iirc
20:36:03 <dolio> The author posted something about implementing a dependent type theory checker on comp.lang.functional not too long ago.
20:37:16 <p_l> publishing it under GPL was a clever trick (Qi, that is)
20:37:41 <PHO_> Bigloo the Scheme compiler has an optional type annotations. http://www-sop.inria.fr/mimosa/fp/Bigloo/bigloo-1.html#Features
20:37:50 <dolio> At least, I thought he did.
20:38:02 <gwern> p_l: why? gpl is pretty common
20:38:19 <gwern> PHO_: are those stronger than just common lisp's hints?
20:38:24 <dolio> It seems to no longer be in my news reader, due to spam.
20:38:32 <p_l> gwern: because publishing Qi under GPL makes sure no one can use any other license unless they pay the authors for the commercial one
20:38:51 <PHO_> dolio: I don't know well about common lisp
20:39:05 <gwern> I'm not familiar with how gpl interacts with interpreters, but surely that doesn't mean that any qi code must be gpl...
20:39:17 <p_l> gwern: GPL interacts badly with Lisp
20:39:38 <p_l> gwern: Also, in this case, there's no interpreter, afaik
20:39:39 <PHO_> ah, sorry. I mean gwern
20:40:59 <p_l> gwern: the closest to GPL license that is used which doesn't mess up licensing of every other part of your app is LLGPL, which is a relaxed variant of LGPL
20:41:24 <gwern> hard to believe rms would write the gpl to be so obnoxious for lispers
20:42:42 <SamB> he doesn't seem to understand that not everyone can give away all of their code all the time :-(
20:42:44 <p_l> gwern: rms doesn't seem to have much clout in Lisp world ;-)
20:43:03 <MyCatVerbs> gwern: RMS has a somewhat different idea of "obnoxious" to most people.
20:43:18 <outchanter> IIRC clisp was going to be released under another license but because it was linked with GNU readline it had to move to GPL.
20:43:20 <p_l> also, afaik, he started GNU after he got whooped for breaking copyrights on Symbolics LispM code
20:43:30 <SamB> he's always "But NOOOOOO that could allow people to use this with PROPRIETARY CODE!"
20:43:33 <p_l> outchanter: yup
20:43:35 <gwern> p_l: well, his favored dialects are dead.
20:44:05 <gwern> p_l: if he had started emacs using scheme, instead of rejecting scheme as impossible to run efficiently, then the story would probably be quite different
20:44:27 <p_l> gwern: Last versions of Symbolics' Lisp are ANSI Common Lisp compatible, afaik
20:44:43 <p_l> haven't tried running test suite on it
20:44:52 <gwern> outchanter: my recollection was that clisp was proprietary, but it linked to readline and one couldn't swap out gnu readline for another readline, and this latter part was why clisp had to be gpl
20:45:11 <gwern> p_l: sure, I could believe that. they were involved in the process after all
20:45:22 <p_l> gwern: clisp wasn't much proprietary, more like freeware/public domain stuff
20:45:36 <gwern> freeware is proprietary :)
20:45:50 <PHO_> I heard that RMS even created the GCC in really non-modular way just to prevent GCC from being stolen by proprietary softwares
20:46:00 <p_l> PHO_: AFAIK that one is true
20:46:09 <gwern> yeah, it's been covered recently
20:46:31 <p_l> because of that, there's a chance LLVM will kick its ass ;-)
20:46:37 <gwern> on the other hand, I can't really blame him for that. it's not paranoia when they really are out to get you...
20:47:00 <p_l> gwern: more like the other way around, he is out to get them... :P
20:47:40 <SamB> gwern: I don't think most of them are out to make proprietary distributions of Emacs ...
20:48:18 <p_l> and proprietary compilers enjoy good life
20:48:29 <bnijk> what's the best c compiler
20:48:38 <kyevan> Ok. I am an idiot.
20:48:38 <bnijk> or the top 5
20:48:46 <gwern> bnijk: well, there aren't too many to choose from these days
20:48:51 <kyevan> I just reimplemented modulo.
20:48:58 <kyevan> Without realizing that's what I was doing
20:49:00 <p_l> I recall someone saying that the only reason GCC ever got any foothold was because of Sun decoupling their C compiler from standard SunOS license
20:49:06 <gwern> I remember reading material from before the 90s; there used to be so many c compilers around
20:49:13 <jaredj> everyone had one
20:49:27 <p_l> bnijk: there is still quite a lot of them, mostly specialized stuff
20:49:32 <gwern> these days we have like gcc, icc, llvm, and then niche products like whatever the bsds are trying to use these days
20:49:48 <p_l> gwern: also ton of platform-specific and HPC compilers
20:50:11 <jaredj> e.g. plan 9, portland group (pgi), respectively
20:50:28 <gwern> plan 9? people're still using that? :)
20:50:29 <SamB> plan9 still comes with some
20:50:34 <bnijk> plan9++
20:50:39 * gwern decides to call it a night, though
20:50:40 <SamB> gwern: he WAS using the past tense
20:50:40 <p_l> bnijk: swallow that
20:50:52 <bnijk> people are mostly using inferno now gwern
20:50:54 <p_l> gwern: Plan9 still enjoys some life :)
20:50:54 * Berengal wonders if plan9 will ever have a comeback
20:50:58 <bnijk> to the extent they use it
20:51:09 <kyevan> Plan 9 is awesome :J
20:51:12 <SamB> bnijk: nah
20:51:26 <p_l> Berengal: it enjoys comeback in form of crippled mods to other OSes :P
20:51:26 <kyevan> Conceptually, anyway
20:51:27 <jaredj> i'm a fan. but i don't run it. that pisses off #plan9 :)
20:51:34 <SamB> inferno can't run C apps -- kinda crippled, don'tcha think ?
20:51:34 <p_l> jaredj: haha
20:51:36 <kyevan> The implementation, eh. :P
20:51:42 <Berengal> p_l: I wouldn't call that "enjoy" as much as "suffer"
20:51:47 <bnijk> you run inferno inside of another OS i mean
20:51:48 <kyevan> jaredj: EXISTING pisses off #plan9
20:51:49 <p_l> SamB: Because C is unmanaged
20:52:02 <SamB> p_l: still ?
20:52:04 <jaredj> it's sorta like #lisp that way :(
20:52:07 <SamB> it seems managed to me ;-P
20:52:26 <jaredj> you can do c + inferno - from outside the system
20:52:50 <SamB> jaredj: well, wouldn't it be nicer to run the C in a VM or something ?
20:52:53 <p_l> SamB: C is certainly "unmanaged code". Inferno was designed for usage in places where a runaway pointer wasn't an option, and MMU was too costly/slow ;-)
20:52:55 <jaredj> given that it was supposed to be for embedded / set top box sorts of things, that's not bad
20:53:07 <SamB> p_l: oh. well, okay. sure, it's good for that
20:53:33 <SamB> but it's hardly appropriate for machines that HAVE mmus
20:53:39 <Berengal> If it can't run C, what can it run?
20:53:43 <jaredj> limbo
20:53:45 <SamB> Berengal: limbo!
20:53:50 <bnijk> LIMBO
20:53:52 <SamB> rc!
20:53:52 <jaredj> it's a pretty interesting little language
20:53:57 <SamB> mk!
20:54:01 <p_l> SamB: Even those that have MMUs run faster without memory protection :)
20:54:06 * Berengal wikis
20:54:06 <bnijk> <3 arch
20:54:19 <bnijk> how many of you guys are arch users
20:54:23 <jaredj> arch ... linux?
20:54:23 <SamB> p_l: not worth the time it takes to rewrite everything from scratch, though
20:54:28 <bnijk> yes
20:54:44 <SamB> no, I use nifty doorways
20:54:48 <p_l> SamB: Usually if you're going to use Inferno you're not going to replace your OS - it wasn't and isn't for that :)
20:54:54 * SamB actually uses Debian
20:54:57 * jaredj too
20:55:02 * p_l uses Arch64
20:55:07 <SamB> p_l: yeah
20:55:09 <bnijk> arch rocks
20:55:14 <jaredj> it's sad: inferno is so small and simple i wish i could replace my os with it
20:55:20 <jaredj> but it doesn't run firefox :/
20:55:29 <SamB> but, I mean, if you want to use plan9-style stuff on your desktop, there are more flexible ways
20:55:42 <SamB> jaredj: that's the thing in a nutshell!
20:55:47 <p_l> jaredj: ... getting a small and simple OS only too run one of the most bloated programs in the world?
20:55:52 <bnijk> there's 9p compatability for arch
20:55:56 <outchanter> in the future, firefox will BE an OS
20:55:56 <bnijk> i don't remember what the name is
20:56:03 <bnijk> plan9port
20:56:03 <p_l> jaredj: man, it would be easier to add OS to firefx
20:56:15 <Berengal> The trouble with plan9 is that it sucks
20:56:16 <p_l> bnijk: it's Plan9's equivalent of Cygwin :P
20:56:18 <jaredj> p_l: yeah #plan9 loves to hear that too. "does it run firefox?" "bugger off"
20:56:22 <bnijk> yep
20:56:23 <SamB> outchanter: thankfully, Chromium will run on Linux/X by then
20:56:38 <Berengal> Does it run emacs?
20:56:47 <SamB> jaredj: at least plan9 is capable of running firefox
20:56:54 <SamB> it's just that firefox hasn't been ported
20:56:58 <jaredj> who was it, pike, who made the "operating systems research is irrelevant" presentation?
20:57:07 <bnijk> chromium's already in the arch repos
20:57:17 <p_l> SamB: Well, properly compiled Firefox runs in Plan9 :)
20:57:25 <jaredj> thanks to browsers and web apps, operating systems practice is also irrelevant :P
20:58:02 <Berengal> Sometimes I wish someone would make a WebOS
20:58:08 <jaredj> they have dude
20:58:09 <SamB> I think operating system research is like rat research
20:58:10 <jaredj> (ette)
20:58:14 <PHO_> I don't want to develop any applications for Firefox because I dislike JavaScript...
20:58:15 <SamB> bnijk: is it now?
20:58:17 <bnijk> yes
20:58:18 <Berengal> Just so people could be scared off the idea for good
20:58:19 <p_l> jaredj: till you find out that you waste so much time because of webapps being broken, internet failing etc. that you wish someone found the inventor of "Web Apps" and hanged him
20:58:26 <SamB> bnijk: I hope I see it in Debian soon ...
20:58:41 <bnijk> don't count on it ;)
20:58:43 <p_l> Berengal: There's several of them. People seem enthusiastic
20:58:51 <SamB> PHO_: JS isn't so bad
20:58:56 <SamB> it's just that the APIs are terrible
20:59:08 <SamB> and not nearly standardized enough
20:59:26 <SamB> p_l: say what ?
20:59:42 <SamB> what's a "web os"?
20:59:52 <bnijk> a bad idea
21:00:04 <SamB> I haven't figured out how to launch program on the web
21:00:21 <SamB> and if I had, the security people would be after me by now!
21:00:22 <bnijk> i'm going to port virtualbox to php
21:00:24 <bnijk> just watch me
21:00:33 <PHO_> SamB: If JS had a type checker I could like it
21:00:41 <p_l> SamB: Imagine an OS which runs in web browser...
21:00:43 <SamB> bnijk: you might get, like, 2 minutes per frame!
21:00:46 <bnijk> lol
21:00:55 <bnijk> i'll make it distributed while i'm at it
21:00:58 <SamB> bnijk: including the time for transferring
21:00:58 <Berengal> PHO_: Write one
21:01:01 <bnijk> through some insane sort of magic
21:01:19 <PHO_> yuck
21:01:36 <Berengal> Or just write a fully fledged haskell interpreter...
21:01:52 <SamB> I don't think JS offers sufficiently standard introspection tools to allow a typechecker to be written
21:02:13 <PHO_> Berengal: like yhc's JS backend?
21:02:32 <Berengal> PHO_: Don't know, haven't check that out properly yet
21:02:40 <Berengal> But possibly
21:03:26 <PHO_> I think no programs can run fast if they're written in JS
21:03:56 <SamB> PHO_: you'd be surprised
21:04:02 <SamB> chrome does pretty well
21:04:07 <Berengal> JS is pretty fast compared to other scripting langauges...
21:04:18 <bnijk> depends on the interpreter Berengal
21:04:20 <PHO_> humm
21:04:25 <bnijk> i want to make a pizza the size of an umbrella
21:04:34 <bnijk> i just need the right oven
21:04:41 * p_l was disgusted with chrome perf.
21:04:44 <Berengal> bnijk: Well, yes. I should've qualified that to mean the most recent interpreters
21:04:45 <SamB> bnijk: I was just going to point that out
21:04:47 <SamB> p_l: hmm ?
21:05:02 <bnijk> can you imagine it
21:05:32 <p_l> SamB: at least the version that was available in Arch (cxChromium), left me disgusted with Chrome :)
21:06:26 <SamB> p_l: oh, well, I tried it on XP
21:07:21 <SamB> and suddenly I noticed animations on rainwave.cc that I'd never known had been there
21:07:42 <bnijk> what's the matter with it p_l
21:07:57 <jimmyjazz14> any good games written in haskell?
21:08:02 <bnijk> jimmyjazz14: yes
21:08:02 <p_l> bnijk: slower than FF ;P
21:08:10 <bnijk> p_l: wow
21:08:23 <bnijk> http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
21:08:43 <PHO_> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
21:09:23 <SamB> p_l: I'm guessing they didn't port V8 too good yet ...
21:09:23 <jimmyjazz14> well yes there is that but has anyone tried any of them?
21:09:54 <SamB> or maybe the sandbox code performed poorly ...
21:10:17 <p_l> Also, Chromium lacks way too many things to displace Firefox for me
21:10:26 <SamB> I'm not sure Linux provides sufficient facilities for the sandboxing
21:10:41 <SamB> well, yah, chromium is missing lots at the moment ...
21:10:53 <bnijk> chromium has a pretty interface
21:10:55 <bnijk> seems to work like shit
21:10:56 <PHO_> jimmyjazz14: I tried Shu-thing but it wasn't so amusing
21:11:21 <SamB> ... but it seems like a reasonable escape plan from the potential Firefox-OS problem
21:11:21 <p_l> SamB: Google is making kernel patches to seccomp to be used with Chrome
21:11:39 <SamB> p_l: sensible of them
21:11:45 <bd_> about time someone did something useful with seccomp
21:12:00 <p_l> SamB: Except that I have much better sandboxing already running on my system :P
21:12:28 <bd_> wouldn't uid/net namespaces be closer to what chrome is looking for though? that way it can still open o+rx libraries, etc
21:12:30 <SamB> Chrome is, like, the most sandboxed app I've ever seen ...
21:12:51 <p_l> bd_: they want to specify what type of syscalls an app can call
21:13:34 <SamB> ... and that's based mostly on looking at it in Process Explorer
21:13:36 <p_l> also, linux devs are still against letting normal users mount anything (like it's done in Plan9). "Security Reasons"
21:13:47 <bd_> p_l: fuse lets you do that today :)
21:13:53 <SamB> indeed
21:13:54 <p_l> bd_: No it doesn't.
21:13:57 <SamB> yes it does
21:13:59 <bd_> and there are some patches floating around for user mounts
21:14:25 <bd_> p_l: It does. If you're in the fuse group, you can mount a fuse filesystem on any directory you own and mangle its contents in any way you like :)
21:14:25 <p_l> Eh, you're mixing it up with something different. What I meant was editing namespaces by users
21:14:27 <SamB> you have to be in some group, maybe, but that can be made ordinary easily enough
21:14:27 <halberd> is it possible in type theory to "automatically generate" the inference rules for a set, given the formation rule?
21:14:39 <bd_> However, it'll return EPERM for accesses from another user
21:14:40 <p_l> bd_: that's far from changing namespace
21:15:00 <SamB> p_l: oh, no, you can't shadow /usr/ or anything
21:15:07 <SamB> I dunno why ...
21:15:18 <halberd> and perhaps also given the introduction rule
21:15:19 <p_l> SamB: Because they fear that someone will exploit /etc/
21:15:27 <SamB> I guess because they're afraid you'll horribly confuse some suid thing
21:15:57 <p_l> SamB: If they repaired security model, they wouldn't have that problem...
21:15:57 <halberd> that is, deriving the primitive non-canonical constant, and the elimination and equality rules, automatically from the formation and introduction rules
21:15:58 <SamB> reasonable fear, really
21:16:09 <bd_> p_l: changing uid namespace is theoretically quite safe - as long as it's implemented completely... But you'll need fs namespaces too for it to be useful for anything other than sandboxing, I think...
21:16:16 <SamB> p_l: do you have any idea how much code would need changing to deal with potential shadowing ?
21:16:33 <p_l> SamB: I have it done on my system :P
21:16:47 <SamB> p_l: oh?
21:16:58 <p_l> Never bothered to actually use it, cause I don't have a need, but I can set it with few lines of rules
21:17:45 <SamB> you mean every suid program or potentially-used-from-suid library checks whether all the config files it accesses are coming from the right place ?
21:17:53 <p_l> like "changes to namespaces that touch /etc are locked down to people with those and those perms"
21:18:02 <SamB> not just /etc, but that they actually have the appropriate permissions and so forth ?
21:18:05 <SamB> oh.
21:18:26 <SamB> (I guess plan9 probably doesn't have suid?)
21:18:54 <p_l> SamB: Also, "Any setuid program launched from non-root namespace has it's setuid perms dropped" is a possible rule
21:19:15 <p_l> SamB: Plan9 doesn't have that problem at all, because of slightly different security model
21:19:33 <SamB> p_l: well, google needs to be able to do their sandbox thing without user configuration ...
21:19:57 <SamB> I mean, besides maybe applying kernel patches
21:20:33 <SamB> but, you know, without having to set up some whole complicated infrastructure with all those decisions about how to make things safe ;-)
21:21:01 <p_l> SamB: Yes, but I think getting private namespaces and apriopriate guards as default setting would be simpler than crazy seccomp patches
21:21:40 * p_l needs a new fan for his router
21:21:51 <SamB> p_l: they may not be crazy patches!
21:22:12 <SamB> I mean, really, anything that helps us catch up with NT where we've been lagging behind -- is it crazy ?
21:22:22 <SamB> (besides bloat, I mean ;-)
21:23:18 <bd_> Really, seccomp's existing design is laughable. Once it's activated, you're only allowed to use read(), write(), _exit() - and the latter has to be via syscall(1, exitcode), since glibc will invoke exit_group() for _exit(). You can't allocate memory, pass file descriptors over sockets, etc.
21:23:43 <bd_> Passing a bitfield or something to describe what syscalls are allowed would be a minor and sensible extension
21:24:20 <SamB> and changing default settings would require a lot more coordination with ALL distributions then adding a few system calls and whatnot that we should've had anyway ...
21:24:44 <p_l> bd_: Getting equivalent of TOMOYO's access policies + API that would only allow you to drop permissions/increase restrictions would give you a much more flexible system
21:25:42 <SamB> who's tomoyo?
21:26:24 <p_l> SamB: long story. http://tomoyo.sourceforge.jp/
21:27:32 <p_l> I'm joking that TOMOYO is the perfect stalker (due to her namesake from CCS)
21:28:45 <PHO_> Sakura and Tomoyo http://www.kaenbin.com/sakura24.html
21:29:22 <SamB> p_l: I'm thinking google wanted to minimize the size of the patches needed ...
21:29:45 <p_l> SamB: It's just that I consider current default Linux security flawed in that aspect
21:30:01 <ClaudiusMaximus> i'm writing an untyped lambda calculus interpreter.  i've almost added desugaring to the input, but not sure how to approach making the output look pretty too (as False and 0 and [] are all represented by (\x.(\y.y)) ). any ideas?
21:31:16 <p_l> with private namespaces the way they work in Plan9, I could rfork() with new namespace, mount a filesystem to talk with parent app (provided by the app), mount network stack (possibly a special filtering one) etc., then drop mount capability and exec into sandboxed code
21:33:03 <p_l> PHO_: BTW, TOMOYO Linux in fact consists of SAKURA, TOMOYO, SYAORAN, CERBERUS and YUE :)
21:33:15 <ClaudiusMaximus> also, why does getLine in ghci not provide any editing capabilities?  it's hard typing unsugared lambda expressions when a typo means restarting the line
21:33:34 <PHO_> p_l: yeah. I know that :)
21:33:39 <hatds> are you on windows, Claudius?
21:33:48 <ClaudiusMaximus> no
21:34:13 * p_l was really nicely surprised by TOMOYO Eclipse plugin. It's the only reason I have Eclipse installed :D
21:34:15 <ClaudiusMaximus> editing works fine within ghci, but as soon as i type "main" (which uses getLine) those editing abilities disappear
21:34:42 <idnar> @src getLine
21:34:43 <lambdabot> getLine = hGetLine stdin
21:35:24 <bos> you'd need to use one of the packages that provides input with line editing.
21:35:29 <bos> e.g. haskeline
21:37:36 * PHO_ has a full set of comics of the Card Captor Sakura, if he hasn't discarded them
21:38:04 * p_l has them but still haven't got around to reading
21:38:38 <hatds> hm, my getLine handle editing
21:38:52 <hatds> *handles
21:39:12 <bos> hatds: using an old ghci?
21:39:25 <hatds> probably
21:39:29 <hatds> it's not the newest for sure
21:39:48 <hatds> they changed it?
21:40:08 <Berengal> The newest ghci uses haskelline
21:41:33 <Berengal> And I can't delete characters in ghci, but I can outside of it
21:41:47 <hatds> so there was an intermediate period where they didn't have editing capabilities?
21:42:04 <Berengal> No, they used editline before switching
21:42:45 <bos> we used to use readline, which i think gave editing capabilities to hGetLine (maybe)
21:43:00 <bos> then switched to editline, which had a better license but made everyone sad because it's crap
21:43:12 <bos> now haskeline, which i haven't used yet
21:43:48 <Berengal> Fortunately editline and readline are binary compatible. I removed editline.so on my machine and replaced it with readline without any problems
21:44:23 <hatds> readline lets you edit but editline only reads.. eiya
22:08:11 <hatds> :t fix
22:08:12 <lambdabot> forall a. (a -> a) -> a
22:33:06 <DOKKA> hey yall
22:36:53 <DOKKA> http://learnyouahaskell.com/ I just found this
22:39:21 <Nafai> great site :)
22:39:40 <outchanter> it's the first language tutorial I've seen that goes right into simulated annealing
22:40:06 <DOKKA> Yeah, way better than real world haskell
22:42:05 <Twey> « Simulated annealing (SA) is a generic probabilistic metaheuristic for the global optimization problem of applied mathematics »
22:42:15 * Twey decides he doesn't want to know after all
22:43:21 <DOKKA> that went right over my head
22:43:48 <DOKKA> but it's okay :-)
22:44:01 <outchanter> it's just a search heuristic...
22:46:03 <DOKKA> I see.
22:46:04 <outchanter> although I can't find that part in the new version of Learn You a Haskell. Maybe they decided to move it to a later chapter
22:47:21 <DOKKA> well, that's fine with me. I was doing just fine without them
22:48:11 <DOKKA> anyways I wanted to ask yall, when do you use a guard vs. an if statement
22:49:21 <DOKKA> or rather, is there something that a guard can't do as compared to an if statement?
22:50:16 <outchanter> it can only be used as part of a function definition?
22:51:48 <DOKKA> so that's really the only thing a guard is limited by? can one contain a let block?
22:52:41 <hatds> you mean a let block for the boolean part of the guard?
22:52:56 <DOKKA> right
22:53:11 <hatds> if you can cram it in there, I think any boolean expression is allowed.  But you normally would keep it short
22:53:39 <outchanter> > let f x | (let y = x in y > 0) = x+1
22:53:40 <lambdabot>   not an expression: `let f x | (let y = x in y > 0) = x+1'
22:54:06 <outchanter> > f x | (let y = x in y > 0) = x+1
22:54:07 <lambdabot>   <no location info>: parse error on input `|'
22:54:17 <byorgey> > let f x | (let y = x in y > 0) = x+1  in  f 3
22:54:18 <lambdabot>   4
22:54:18 <hatds> you need to put the guard on the next line
22:54:38 <hatds> ah nvm ignore me :)
22:54:45 <DOKKA> wow
22:54:50 <byorgey> just needed an 'in' to go with the 'let' =)
22:55:14 <outchanter> yep, sorry, I initially just copied what worked in ghci. Not familiar with lambdabot
22:55:59 <hatds> you can use guards in case expressions too, but the syntax is a little different
22:57:07 <DOKKA> that makes sense, so guards are just as powerful
22:57:42 <DOKKA> I just couldn't find an example of a let block in a guard
22:57:46 <hatds> "patern | boolexpr -> expr" instead of "function pattern | boolexpr = expr"
23:14:01 <DOKKA> then why won't this work?
23:14:13 <DOKKA> test xs let x="asdf" in | xs==x=xs++x | otherwise=xs
23:14:29 <DOKKA> > test xs let x="asdf" in | xs==x=xs++x | otherwise=xs
23:14:31 <lambdabot>   <no location info>: parse error on input `let'
23:16:17 <outchanter> I think you can't put them both on one line, at least not without adding braces/semicolons
23:17:28 <DOKKA> but even then, where should they go?
23:18:09 <Gracenotes> otherwise.... :o
23:18:48 <Gracenotes> DOKKA: maybe you want a "where" clause.
23:19:32 <Gracenotes> test xs | blahblah = this
23:19:37 <Gracenotes>         | yadda = that
23:19:44 <Gracenotes>    where x = something
23:19:51 <DOKKA> Gracenotes: yeah, I know about them, i just want to see what I am allowed to do
23:20:46 <Gracenotes> well, you can do let guards
23:21:13 <Gracenotes> But essentially, where you can do guards is limited to (afaik) either in functions or in let clauses
23:21:37 <hatds> hmm.. let guards?
23:21:41 <hatds> what's that?
23:21:51 <DOKKA> ah, cool
23:22:00 <Gracenotes> let x | blah = this
23:22:05 <Gracenotes>     | whatev = that
23:22:13 <Gracenotes> oops. indentation. but you get the idea
23:22:46 <Gracenotes> acts somewhat like let x = case True of { blah -> this; whatev -> that; }.
23:28:17 <DOKKA> test xs
23:28:17 <DOKKA>  | let {xd="asdf"}
23:28:17 <DOKKA>    in xs==xd=xs++xd
23:28:39 <DOKKA> oops sorry
23:29:07 <Cale> the xd there, being defined inside the let inside the guard, won't be in scope after the = ... provided that even parses
23:29:34 <DOKKA> Yeah, but why won't it be in scope?
23:30:33 <DOKKA> Oh, wait, I understand
23:31:17 <DOKKA> it only works for the conditional half
23:32:13 <Cale> Well, (let ... in ...) only makes the declarations in scope for the 'in' part
23:32:30 <Cale> They don't extend any further outside the let :)
23:32:40 <DOKKA> exactly, thanks
23:32:51 <Cale> brb
23:40:46 <Bacta> @fag can Haskell get me a girlfriend?
23:40:47 <lambdabot> The answer is: Yes! Haskell can do that.
23:43:06 <ray> @faq can haskell get me his girlfriend?
23:43:07 <lambdabot> The answer is: Yes! Haskell can do that.
23:43:09 <Cale> Bacta: btw, the command is @faq, you're misspelling it :)
23:44:08 <Bacta> Yeah I know @fag is acceptable, that's what makes it funny
23:46:15 <hatds> let me = (=="hatds") in find me ["a girlfriend"]
23:46:19 <hatds> > let me = (=="hatds") in find me ["a girlfriend"]
23:46:21 <lambdabot>   Nothing
23:46:23 <hatds> hehe
23:47:39 <DOKKA> > Just a
23:47:41 <lambdabot>   Just a
23:47:58 <walter_> In
23:48:30 <walter_> In "renderJValue (JString s)   = show s
23:48:30 <walter_> " is (JString s) a pattern method ?
23:49:00 <hatds> starts with a capital and appears in a pattern, so JString is a constructor
23:49:59 <walter_> Still don't understand how can a type JString s conver to a s
23:50:34 <hatds> Constructors don't really convert, they just box up the values
23:50:52 <hatds> pattern matching opens the box and assigns names ('s', in this case) to the values inside
23:51:09 <walter_> hatds, I see. Thanks!
23:52:37 <Reiv> Hrm.
23:52:54 <Reiv> I'm trying to write a parser for the language TINY.
23:53:03 <Reiv> Anyone mind giving a quick look to see if my Haskell is on the right track?
23:54:10 <Reiv> http://pastebin.com/d7a6dddea
23:55:15 <Bacta> girlHasA = Pussy
23:56:31 <jbjohns> Hi.  GHC on windows has no dependency on Cygwin, MGW or any of that stuff right?
23:58:18 <hatds> I don't believe so
23:59:29 <Saizan_> Reiv: it seems weird that you can use symbol for Strings
