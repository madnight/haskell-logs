00:02:10 <edwardk> anybody have some comparatively simple code that could benchmark nicely that uses a bunch of monad transformers?
00:06:37 <monadic_kid> dons: are you around?
00:07:39 <dons> mm?
00:07:41 <dons> just.
00:08:37 <dons> quick!
00:09:00 <monadic_kid> dons: mokehehe replied to my message about the directx bindings, we can't find it anymore but he has a copy but he needs a little help with license i think
00:09:06 <monadic_kid> dons: https://www.blogger.com/comment.g?blogID=8935928809346815002&postID=255590859067544498&pli=1
00:10:28 <monadic_kid> dons: we should try to get them into hackage
00:13:30 <dons> oh, he just doesn't know how to put stuff on hackage?
00:14:03 <monadic_kid> dons: i guess so, what about the bsd license on it?
00:14:14 <dons> sounds good.
00:15:50 <monadic_kid> dons: do you think we need to contact the original owner?
00:16:10 <monadic_kid> author i mean
00:19:10 <dons> i don't think we can, is it esa?
00:19:47 <dons> oh maybe.
00:19:51 <dons> http://eivuokko.vuodatus.net/
00:19:59 <dons>  haven't seen eivuokko around for a while.
00:20:04 <dons> but is online.
00:20:28 <monadic_kid> yeah, he is that really his/her blog?
00:21:39 <Bleadof> He
00:22:59 <dolio> edwardk: Continuation passing ST seems to have less unboxing rather than more.
00:23:25 <edwardk> hrmm
00:23:50 <edwardk> you used lift to lift ST actions into it?
00:24:24 <dolio> My benchmark doesn't involve any actual ST usage. Just return, bind and recursion.
00:24:36 <edwardk> strange
00:25:20 <edwardk> are you using forall o. (a -> State# s -> o) -> State# s -> o -- directly or Ran (ST s) ?
00:25:30 <dolio> The former.
00:25:42 <edwardk> args in that order?
00:25:46 <dolio> Yes.
00:26:14 <edwardk> -O2 -fspec-constr -funbox... ?
00:27:08 * petronius http://www.gangsters.pl/index.php?polec=5560
00:27:20 <edwardk> can you hpaste your fmap return and bind?
00:27:22 <dolio> I wasn't using the latter two, but it doesn't seem to make a difference.
00:27:40 --- mode: ChanServ set +o bos
00:28:00 --- mode: bos set +b *!*@85.219.193.*
00:28:01 --- kick: petronius was kicked by bos (bos)
00:28:09 --- mode: bos set -o bos
00:28:16 <dolio> (ST m) >>= f = ST (\k -> m (\a -> unST (f a) k)), return a = ST (\k -> k a)
00:28:22 <dolio> fmap isn't used.
00:29:46 <edwardk>   State g >>= f = State (\k -> g (\a -> getState (f a) k)) -- hrmm those line up exactly
00:29:58 <edwardk> fmap f (State g) = State (\k -> g (\a -> k (f a))) -- for what its worth
00:30:15 <edwardk> will work for any of those codensity style transformers
00:31:00 <kadaver_> i cant find how to set the theme in gtk2hs?
00:31:20 <edwardk> ST is a newtype right? =)
00:31:33 <dolio> Yeah.
00:31:37 <kadaver_> the default buttons are very ugly
00:31:43 <dolio> It may not actually be worse. It may just be the same.
00:31:49 <ari> I just got "ghc: /usr/lib/zlib-0.4.0.1/ghc-6.10.1/HSzlib-0.4.0.1.o: unknown symbol `inflateInit2'" while trying to cabal install lambdabot. *tries to install zlib and see if that fixes it*
00:31:55 <edwardk> that i could accept
00:32:04 <edwardk> i only did it to get it into the form i needed for the rest of my ran transformers
00:32:36 <edwardk> otherwise i'd have to take the codensity or yoneda of IO/ST s/STM and those _would_ be slower
00:33:11 <edwardk> this way i just cut IO in half and stuff the rest of the stuff i want inside like creamy filling =)
00:34:44 <edwardk> what is your benchmark?
00:35:22 <dolio> Oh, there is an important difference.
00:35:35 <edwardk> ?
00:35:55 <dolio> I'll paste it.
00:36:42 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4589#a4589
00:38:00 <dolio> So, with regular ST, whileLoop turns into a loop that does all its work in Int#s, and then boxes for the return.
00:38:41 <edwardk> but without it it can't spot it
00:39:12 <dolio> Which immediately gets deconstructed, of course. mainLoop is similar.
00:40:32 <edwardk> i wonder if we manually worker wrapper mainLoop what happens
00:40:34 <dev312> quick question about Leksah build process.
00:40:39 <dolio> With CPS ST, whileLoop turns out the same.
00:40:44 <dev312> Is it possible to have the build ocmmand configured to also restart apache?
00:41:05 <dev312> or, execute any arbitrary shell command, for that matter
00:41:07 <dolio> It does all its work in Int#, and the reboxes it to call the continuation at the end.
00:41:10 <edwardk> i.e. if we remove the side effects of the optimizer
00:41:35 <edwardk> er wait
00:41:39 <edwardk> so, they do the same thing?
00:41:50 * edwardk wants to make sure i'm parsing you properly
00:41:54 <dolio> Interestingly enough, it doesn't even take the continuation as a parameter, it returns a function that accepts the continuation in the termination branch.
00:42:59 <dolio> However, with CPS ST, mainLoop turns into something with type: "Int -> Int# -> ST s Int".
00:43:26 <edwardk> it doesn't spot the need for the first int?
00:44:02 <dolio> Yeah.
00:44:12 <dolio> Which I think means it reboxes to call itself every iteration.
00:44:13 <edwardk> ok k' comes from bouncing in and out of iter
00:44:20 <edwardk> hrmm
00:45:57 <hamishmack> dev312: You could customize your Setup.lhs or hs file
00:46:04 <edwardk> so it may be that the continuation, etc. is causing it to slightly exceed the complexity limit for inlining it or some such
00:48:04 <dolio> It strikes me as a bit odd that the (ST s Int) in its return type is still displayed as that.
00:48:39 <hamishmack> dev312: Leksah builds by executing 'runhaskell Setup.lhs build'
00:49:43 <edwardk> you mean that it isn't flattened down?
00:50:26 <dolio> Yeah. The type is "Int -> Int# -> ST s Int" rather than "Int -> Int# -> (Int -> State# s -> r) -> State# s -> r".
00:50:48 <dolio> Or, with a forall r in there.
00:50:54 <edwardk> yeah with the forall
00:51:29 <dolio> Although, you could lift that up since it's not on the left of any arrows.
00:51:33 <edwardk> what do you get with the normal ST monad in there?
00:52:04 <dolio> Int# -> Int# -> State# s -> (# State# s, Int #)
00:52:12 <edwardk> hrmm
00:53:05 <dolio> Maybe I need to put some INLINES in.
00:53:27 <edwardk> on return and (>>=) ?
00:53:36 <dolio> Yeah.
00:53:51 <dolio> ST has them, in fact.
00:53:54 <edwardk>     {-# INLINE return #-}     {-# INLINE (>>)   #-}     {-# INLINE (>>=)  #-}      is in GHC.ST
00:53:57 <edwardk> yeah
00:55:25 <edwardk> if so i'm in for a ton of {-# INLINE #-} pragmas in the monad-ran stuff
00:56:05 <dolio> m >> n = ST (\k -> unST m (\_ -> unST n k)) look right?
00:56:57 <dolio> Anyhow, that didn't actually make a difference.
00:57:40 <dolio> It was probably inlining anyway, since I'm not exporting the types or functions in question, and they're really short.
00:58:28 <edwardk> ST m >> ST n = ST (m . const . n) -- is what i got when i ran through the motions mechanically but i didn't typecheck it yet
01:00:09 <dolio> Anyhow.
01:00:34 <edwardk> trying to figure out whats killing your performance
01:02:16 <dolio> I don't know. It's odd that it wouldn't catch that, since nothing's really changed.
01:03:12 <dolio> Oh, I should mention (off the top of my head, since I deleted the files just now), that the argument that isn't getting unboxed is n, not k, despite them being in the opposite order versus the actual program text.
01:03:28 <edwardk> if you add a couple of bang patterns what hapens?
01:03:45 <dev312> Just got back..sorry if anyone responded to my question
01:03:46 <dev312> thanks
01:03:48 <edwardk> hrmm maybe it doesn't spot that you'll necessarily make it to the return (n == 0)
01:04:01 <dev312> one more, what, again, was the command to list all packages installed in your GHC installation?
01:04:44 <edwardk> speaking of which, why b <- return (n == 0) -- rather than a let b = (n == 0) or floating that down into the return $! (n == 0) :*: k' ?
01:05:19 <dolio> Ah, that did it.
01:05:31 <edwardk> which one?
01:05:36 <dolio> That made it expand the ST s Int, too, oddly enough.
01:05:39 <dolio> The bang pattern on n.
01:05:41 <dev312> found it...
01:05:45 <dev312> I forgot the dash
01:05:56 <edwardk> same speed now?
01:06:21 <dolio> I've not been actually running this code. I don't think it takes very long.
01:06:49 <dolio> Oh, I suppose it takes as long as I want.
01:07:33 <Alpounet> hi guys
01:07:43 <Alpounet> is there a Mac OS compatible version of Network.Download ?
01:11:14 <dolio> edwardk: CPS ST is well faster, despite doing way more allocation.
01:11:23 <edwardk> nice
01:11:35 <edwardk> probably all the little partial applications
01:11:36 <dolio> So there must be some other unboxing thing I'm not seeing.
01:11:51 <edwardk> so I'm on the right track? =)
01:12:21 <dolio> Seems so.
01:12:35 <edwardk> score
01:12:52 <edwardk> i just have StateT and a couple of other transformers to add to monad-ran and it'll be done except for tweaking
01:15:52 <dolio> The core for mainLoop with CPS does more type passing for some reason. That might explain the difference.
01:16:41 <sergio`> Hello there! I'm trying to print a String in UTF-8 (I'm playing with "Data.Text.ICU"). Doing "putStrLn" on my String, I loose all characters with high code points. I thus tried to intercalate a small function to do the job using "Data.Text.ICU.fromUnicode" with a UTF-8 converter and my String, which produces a "Data.ByteString". I can turn this value to a "[Word8]", but I still need to convert it into a "[Char]".
01:17:25 <sergio`> So my first question is: How does one turn a "Word8" into a "Char"? I tried "fromIntegral", but ghc complains.
01:18:08 <leadnose> http://haskell.org/hoogle/?hoogle=Word8+-%3E+Char
01:18:09 <sergio`> The second, related, question is whether there is a simpler (read "already available) way to do what I want?
01:18:14 <ziman> > chr . fromIntegral $ 64 :: Word8
01:18:15 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
01:18:53 <ziman> oh
01:18:56 <ziman> > chr . fromIntegral $ (64 :: Word8)
01:18:58 <lambdabot>   '@'
01:20:01 <mgsloan> ahh that's interesting.  :: binds after $
01:20:26 <mgsloan> (err before i guess)
01:21:04 <ziman> :: binds absolutely least, from my experience
01:21:20 <sergio`> Thanks! I need to get accostumed to hoogle...
01:21:38 <dolio> "\x -> e :: t" parses as "\x -> (e :: t)", but that's about it.
01:23:33 <edwardk> http://comonad.com/haskell/monad-ran/dist/doc/html/monad-ran/Control-Monad-Ran.html is what i have so far
01:24:05 <edwardk> basically i wanted it in one module so it wouldn't conflict with other packages from hackage
01:25:09 <dolio> You probably should put INLINEs on the ST and IO operations, by the way, since it'll be across module boundaries.
01:25:20 <edwardk> yeah
01:25:20 <dolio> I don't know if things that short inline across them anyway or not.
01:25:24 <edwardk> i need to toss a ton of INLINEs in here
01:26:07 <edwardk> especially since a lot of this will be used for transformers, and if the inlines are missed nothing will work as hoped
01:28:31 <edwardk> ok, heading to bed to catch a couple hours sleep before work
01:34:34 <edwardk> uploading this initial version to hackage then catching zzzs
01:51:25 <Alpounet> what'd you advise for running a wget within a Haskell program ? It would really be appreciable not to have the wget logging in the window
01:51:36 <Alpounet> in the console*
01:53:17 <Axman6> Alpounet: can't you use one of the http libraries?
01:53:39 <Alpounet> well, it doesn't seem to be appreciated on Mac OS X
01:53:54 <Alpounet> which is the system used by one of the person who'll use my app.
01:54:05 <Alpounet> I was using download, before, yep :-)
01:54:15 <Axman6> what about Network.Curl?
01:54:41 <quicksilver> run wget so that it's output doesn't go to stdout them :P
01:54:52 <Axman6> that too
01:55:41 <Axman6> whoot, another google tech talk at uni next week
01:55:51 <Alpounet> quicksilver, wget doesn't want me to do so :p
01:56:03 <quicksilver> what do you mean by that?
01:56:08 <quicksilver> wget doesn't care where its output goes.
01:56:15 <Alpounet> with > /dev/null, etc
01:56:39 <Alpounet> Axman6, oh, nice idea. I'll see with my colleague if Network.Curl is supported on Mac.
01:56:50 <quicksilver> it is.
01:56:57 <quicksilver> but I'd have though HTTP was a better idea.
01:58:03 <Axman6> Alpounet: well, i'm on a mac, and it's installed... haven;t tried using it, but i'm assuming it works
01:58:31 <Alpounet> Ok, thanks.
02:06:30 <Alpounet> can ayone say why the following isn't working ? ghc -package feed curl -o blabla blabla.hs ?
02:06:48 <Alpounet> ghc-6.8.2: does not exist: curl
02:06:59 <Alpounet> I've just installed the 'curl' package with cabal
02:08:02 <cognominal> in yi, I want to pass a non pure function as the only parameter of a  function call. How I can do that? The type of that parameter would be bufferM ()
02:09:18 <cognominal> oops, I mean : BufferM ()
02:09:27 <kadaver> i cant find how to set the theme in gtk2hs?
02:09:27 <kadaver> the default buttons are very ugly
02:11:10 <mxc> kadaver - isn't there a program gtk-ctheme or something like htat?
02:11:27 <quicksilver> Alpounet: don't use ghc -package
02:11:31 <quicksilver> Alpounet: use ghc --make
02:12:25 <Alpounet> quicksilver, it'll check for dependencies ?
02:12:33 <Alpounet> no need for me to specify them
02:12:33 <Alpounet> ?
02:12:35 <Axman6> that's the point of it
02:12:49 <Alpounet> oh thanks :-)
02:14:10 <tux-foo> who ate twanvl?
02:14:39 <Axman6> >_>
02:16:42 <dancor_> i have Main.hs and i have YayDir/ with several .hs (say A.hs and B.hs) files.  i want Main.hs to import qualified every YayDir file and do things = [YayDir.A.thing, YayDir.B.thing].  how much of this can template haskell do for me?
02:17:29 <Deewiant> TH can't add imports :-/
02:17:29 <dancor_> or will have i have to write a "build" script that does it?
02:17:37 <Axman6> can't you just make a YayDir.hs file that inports and exports things?
02:17:42 <Axman6> or something...
02:17:44 <dancor_> maybe
02:18:14 <dancor_> the real problem is i have YayDirPublic/ and YayDirPrivate/ and i want to separate them at the repo level
02:18:20 <quicksilver> well TH can write a new file for you that you could then compile :)
02:18:33 <ski> cognominal : yi has impure functions ?
02:18:40 <cognominal> ho, I suppose that an apparent call would be deferred due to laziness.
02:18:44 <dancor_> quicksilver: can't regular-haskell do that? :)
02:18:56 <dancor_> H
02:19:39 <ski> cognominal : remember that even evaluating a monadic action may in general not execute its effects
02:20:46 <dancor_> ski: like how readFile is not strict?
02:21:07 <quicksilver> readFile is a foul aberration.
02:21:17 <dancor_> heh, but is that what ski was talking about
02:21:25 <quicksilver> in general, one should distinguish between strict/lazy and the issue of when IO gets performed.
02:21:31 <dancor_> or is there another way that IO is going to pwn me l8r
02:21:51 <quicksilver> it's not technically correct to call readFile 'lazy IO', although there is an analogy wich makes people use that term.
02:21:57 <quicksilver> dancor_: no, he wasn't.
02:22:11 <quicksilver> he was simply (as far as I know) pointing out that evaluating an action does not perform it.
02:22:20 <quicksilver> > putStrLn "hello" `seq` ()
02:22:21 <lambdabot>   ()
02:22:27 <quicksilver> ^^ that evaluates the action.
02:22:30 <Axman6> :O
02:22:31 <quicksilver> nothing is printed, though.
02:22:35 <dancor_> got it
02:22:45 <ski> dancor_ : no, like `seq (putStr "foo") ()'
02:22:49 <Axman6> i totally didn't expect that to work actually
02:22:59 * ski notices quicksilver said just that
02:23:07 <quicksilver> great minds.
02:23:19 <QP> >putStLn "hello" `seq_` ()
02:23:51 <QP> > putStrLn "hello" `seq_` ()
02:23:52 <lambdabot>   Not in scope: `seq_'
02:24:03 <ski> (s/may in general not/generally does not/ i suppose would be slightly clearer)
02:25:03 <dancor_> i guess i have two options for my problem: 1) crazy symlinks 2) pre-build step
02:25:38 <dancor_> one is more underhanded, two is more heavyhanded
02:25:43 <ski> quicksilver : well, maybe one could say that the value monadically returned by `readFile' is lazily constructed ..
03:00:42 <Axman6> sure if quiet in here tonight
03:05:22 <guenni> where does something like this come from? *** Exception: readUTF8Char: illegal UTF-8 character 252
03:05:43 <fasta> guenni: from readUTF8Char?
03:06:09 <fasta> guenni: use holumbus on that identifier and you know the package.
03:06:13 <guenni> fasta: well I wouldn't know where in my code that's even called
03:06:32 <guenni> fasta: holumbus?
03:06:45 <fasta> @where holumbus
03:06:45 <lambdabot> I know nothing about holumbus.
03:07:11 <Deewiant> @where hayoo
03:07:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:08:00 <fasta> http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:08:37 <guenni> fast: still not sure what you mean, what is that?
03:09:09 <fasta> And it is not in the index... so it probably is some internal compiler identifier.
03:09:28 <quicksilver> guenni: is that an error from ghc, or from a program you wrote?
03:09:37 <ksf> I wonder why they stopped naming machines after alcohol.
03:09:37 <quicksilver> if it's from ghc, it probably means your .hs file isn't in UTF8.
03:09:41 <ksf> ...like in http://smirnoff.fh-wedel.de/
03:09:47 <quicksilver> .hs files should be ascii or utf8
03:10:30 <guenni> quicksilver: this comes from ghci when I run some of my code
03:11:51 <ksf> you could tell the speed of the machine by knowing the potency of the beverage, which was a nice touch.
03:11:52 <guenni> that happens in a dir where there is indeed an "ü", ie \252 in the name
03:28:29 <guenni> fasta, quicksilver: one thing to know about darcs ... it doesn't seem to keep the utf8 encoding of the files
03:29:01 <fasta> guenni: on Linux, I highly doubt that statement.
03:32:30 <Alpounet> bye
03:35:36 <guenni> fasta, quicksilver: anyway you guys where right, half of my *.hs files are for some reason ascii again, the other half is utf8
03:35:48 <quicksilver> ascii and utf8 are both fine.
03:35:59 <quicksilver> what's not fine is anything else.
03:36:43 <guenni> quicksilver: true, but in some of those ascii files I use "ü" thinking the file was in utf8 like the others
03:37:07 <quicksilver> if you have u+umlaut, then that is not an ascii file.
03:37:13 <quicksilver> there is no umlaut in ascii.
03:38:01 <guenni> quicksilver: yep, I know, I had emacs set to use utf8 though, so I don't understand how the file can be ascii
03:38:18 <guenni> quicksilver: I mean the others are utf8
03:38:22 <smtms> guenni, ASCII files are UTF-8
03:38:42 <guenni> smtms: huh?
03:39:07 <quicksilver> ascii is a strict subset of utf8
03:39:14 <quicksilver> thus any ascii file is a valid utf8 file.
03:39:28 <quicksilver> if it has u-umlaut in, it is certainly not ascii :P
03:39:59 <smtms> guenni, fire up your hex editor :-)
03:48:31 <Ferdirand> guenni: what you're refering to as "ascii" is in fact most likely Latin1
03:57:02 <guenni> is there a quick way to convert my "ascii" files to uft8?
03:57:42 <guenni> ie to set the files beginning to "what comes next is all utf8"?
04:00:35 <koala_man> add a utf-8 byte order mark to an otherwise 7bit ascii text file?
04:01:38 <Choko> guenni: use iconv
04:01:46 <guenni> thx
04:15:03 <yitz> hey arrows people - what's the right way to write this:
04:16:00 <yitz> fixKey ((mods, key), action) = do { fixed <- M.lookup key fixMap; return ((mods, fixed), action)
04:16:12 <yitz> }
04:18:52 <EvilTerran> ?type second . first . flip M.lookup
04:18:53 <lambdabot> forall d d1 a a1 (m :: * -> *). (Ord a, Monad m) => M.Map a a1 -> (d, (a, d1)) -> (d, (m a1, d1))
04:19:31 <EvilTerran> ?type fmap (second . first) . flip M.lookup
04:19:33 <lambdabot> forall d (a :: * -> * -> *) b d1 a1 a2. (Ord a1, Monad (a b), Arrow a) => M.Map a1 a2 -> a1 -> a (d, (b, d1)) (d, (a2, d1))
04:19:55 <EvilTerran> er
04:20:06 <EvilTerran> something like that =/
04:20:36 <yitz> yeah, after tripping up a few times I gave up, but thought maybe you could help :)
04:20:56 <yitz> something about Kliesli
04:22:43 <EvilTerran> ?type \((mods, key), action) = do fixed <- M.lookup key ?fixMap; return ((mods, fixed), action)
04:22:44 <lambdabot> parse error on input `='
04:24:44 <yitz> seems like it ought to be so simple
04:25:52 <yitz> @type \ ((mods, key), action) -> do fixed <- M.lookup key ?fixMap; return ((mods, fixed), action)
04:25:53 <Axman6> @pl fixKey ((mods, key), action) = do { fixed <- M.lookup key fixMap; return ((mods, fixed), action)}
04:25:54 <lambdabot> forall t t1 t2 t3 (t4 :: * -> *). (Ord t1, Monad t4, ?fixMap::M.Map t1 t3) => ((t, t1), t2) -> t4 ((t, t3), t2)
04:25:54 <lambdabot> (line 1, column 35):
04:25:54 <lambdabot> unexpected "{"
04:25:54 <lambdabot> expecting variable, "(", operator or end of input
04:26:42 <Axman6> @pl fixKey ((mods, key), action) = do fixed <- M.lookup key fixMap; return ((mods, fixed), action)
04:26:43 <lambdabot> (line 1, column 63):
04:26:43 <lambdabot> unexpected ";"
04:26:43 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
04:27:06 <Axman6> whatever lambdabot
04:27:18 <yitz> @pl \((x,y),z) -> lookup m y >>= return . flip (,) z . (,) x
04:27:18 <lambdabot> uncurry (uncurry (flip ((.) . (>>=) . lookup m) . ((return .) .) . flip ((.) . flip (,)) . (,)))
04:27:33 <yitz> quite unsatifying
04:27:35 <EvilTerran> er... no.
04:27:37 <yitz> quite unsatisfying
04:30:48 <byorgey> @type \fixMap -> runKleisli (second (first (Kleisli (flip M.lookup fixMap))))
04:30:49 <lambdabot> forall b a (m :: * -> *) d d1. (Ord b, Monad m) => M.Map b a -> (d1, (b, d)) -> m (d1, (a, d))
04:31:20 <byorgey> @type runKleisli . second . first . Kleisli . flip M.lookup
04:31:21 <lambdabot> forall d d1 a a1 (m :: * -> *). (Ord a, Monad m) => M.Map a a1 -> (d, (a, d1)) -> m (d, (a1, d1))
04:31:23 <yitz> I think the problem is that we're trying to use two different Appicative instances for (,) at once
04:31:37 <byorgey> \o/
04:31:46 <yitz> ahhh
04:32:04 <yitz> thought it had something to do with Kleisli
04:32:13 <byorgey> yup =)
04:32:54 <Martijn> Who first described explicit recursion with fixpoints? I.e. data Expr r = Num Int | Add r r
04:33:07 <byorgey> since you want to use 'first' and 'second' (which work with arrows) to deal with the tuples, but the result is monadic.
04:33:14 <byorgey> so we want arrows   a -> m b.
04:33:26 <vixey> that's such an obvious thing to do I really don't think you can attribute it to one persion
04:33:50 <Martijn> @vixey So no reference necessary, then?
04:33:51 <lambdabot> i didn't think so
04:33:52 <yitz> vixey: it wasn't obvious to me
04:33:55 <byorgey> vixey: that isn't necessarily true.  it wasn't obvious until someone thought of it.
04:34:02 <vixey> I don't think so Martijn
04:34:24 <Martijn> Exit Twitter reply mode, enter IRC reply mode
04:35:26 <Martijn> How about recursive annotations Fix (Ann x Expr) and catamorphisms Expr a -> a?
04:35:34 <Martijn> Anyone in particular to attribute that to?
04:35:48 <vixey> you can pretend to learned that stuff from Algebra of Programming if you like
04:36:05 <yitz> thanks byorgey !
04:36:25 <byorgey> yitz: sure =)
04:36:25 <vixey> well not the Ann thing
04:37:07 <Martijn> I use Ann heavily and describe it in my paper but I don't want it to sound like I made it up myself
04:37:31 <Martijn> (data Ann x f a = Ann x (f a))
04:37:35 <vixey> Maybe you could call it folklore I dunno
04:38:39 <Martijn> Hmm
04:46:45 <billls> hi guys, i'm trying to make the table' function in this code work, I think it's clear what i'm trying to do, but I keep getting 'type StringyTable does not match [Char]. any advice?
04:46:48 <billls> http://foxyurl.com/1sr
04:47:41 <quicksilver> billls: you're trying to apply 'words' to 'table'
04:47:53 <quicksilver> billls: 'words' is a function on Strings ([Char]s)
04:47:59 <quicksilver> 'table' isn't one of those.
04:48:48 <quicksilver> if you said "map words table" that might be closer to what you wanted.
04:49:05 <quicksilver> that still wouldn't work, though. since that would try to apply 'words' to a StringyRow
04:49:12 <quicksilver> and StringyRow is not String or [Char] either.
04:49:28 <billls> yeah :/ I can't quite work out how to access it properly
04:50:05 <byorgey> billls: are you trying to apply 'words' to every String contained within the 'table' structure?
04:51:08 <billls> the spec i've got says: Define a constant table' :: Table as the phrase version of table, which must be generated using 'words' from 'table'
04:51:21 <byorgey> I'd suggest first writing a function   wordifyRow :: StringyRow -> Row
04:51:28 <byorgey> which will use 'words'
04:51:44 <byorgey> and then use that to create  table'
04:52:32 <billls> it's not possible to directly apply words to something that is (String,[String]) then ?
04:52:38 <byorgey> "using 'words' from 'table'" in the spec apparently does not mean "apply 'words' to 'table'"; it means you will have to write some sort of code which uses 'words' in an appropriate way
04:52:41 <ivanm> @type words
04:52:43 <lambdabot> String -> [String]
04:52:46 <ivanm> billls: ^^^
04:52:54 <byorgey> billls: nope.  as you can see from its type, words can only be applied to a String.
04:55:30 <yitz> @type second (map words)
04:55:31 <lambdabot> forall d. (d, [String]) -> (d, [[String]])
04:55:45 <yitz> @type second (concatMap words)
04:55:46 <lambdabot> forall d. (d, [String]) -> (d, [String])
04:56:17 <vixey> :t uncurry ?m . first ?f . second ?g
04:56:19 <lambdabot> forall c c1 b c2 d. (?g::b -> c2, ?f::d -> c1, ?m::c1 -> c2 -> c) => (d, b) -> c
04:57:46 <bastl> how can i construct a value of type TypeRep ?
04:58:00 <vixey> bastl: which value of type TypeRep?
04:58:19 <EvilTerran> ?hoogle a -> TypeRep
04:58:19 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
04:58:19 <lambdabot> Prelude id :: a -> a
04:58:19 <lambdabot> Data.Function id :: a -> a
04:58:31 <EvilTerran> bastl, i'm thinking typeOf is what you want
04:58:41 <EvilTerran> > typeOf (undefined :: Int)
04:58:43 <lambdabot>   Int
04:58:58 <Axman6> > typeOf 1
04:58:59 <lambdabot>   Integer
04:59:06 <Axman6> > typeOf Nothing
04:59:07 <lambdabot>   Add a type signature
04:59:45 <EvilTerran> unfortunately, Typeable only works for monomorphic types, and Nothing :: Maybe a, so is polymorphic. i guess "typeOf 1" worked because of defaulting.
05:00:06 <Axman6> > typeOf (Just 1)
05:00:07 <lambdabot>   Maybe Integer
05:00:16 <Axman6> > typeOf (Just (1 :: Double))
05:00:17 <lambdabot>   Maybe Double
05:00:54 <bastl> anything that "typeOf MyConstructors" returns
05:01:25 <vixey> bastly I think you should do  deriving Typeable  when you define them then
05:01:32 <bastl> im thinking of "mkType Data.Tree"
05:01:47 <bastl> mktype :: String -> TypeRep
05:01:52 <vixey> no
05:01:58 <vixey> do you know what deriving is?
05:02:06 <bastl> yes?
05:02:13 <bastl> @hoogle TypeRep
05:02:14 <lambdabot> Data.Typeable data TypeRep
05:02:14 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
05:02:14 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
05:02:34 <bastl> its not a typeclass
05:02:50 <bastl> it's data so i want to construct it.
05:03:12 <bastl> \me is stubborn sometimes ...
05:04:42 <ivanm> bastl: you mean "/me" ...
05:04:47 <EvilTerran> bastl, TypeRep is abstract. you can't generate a TypeRep from a String.
05:04:50 <ivanm> can one be dyslexic wrt symbols? :p
05:05:13 <EvilTerran> bastl, Data.Typeable.typeOf :: Typeable a => a -> TypeRep is the only way of constructing TypeReps, AFAIK
05:05:27 <bastl> hmm, ok.
05:05:51 <byorgey> I mean, presumably typeOf is implemented somehow.  but why bother going to the work of doing it directly when GHC will generate an implementation for you, by deriving Typeable?
05:06:03 <EvilTerran> you make a type an instance of Typeable by deriving it, though, not by instantiating it normally.
05:06:56 * bastl is experimenting with transformations and queries on typeable asts.
05:07:10 <bastl> very cool stuff BTW.
05:07:59 <vixey> > read "Maybe Int" :: TypeRep
05:08:00 <lambdabot>       No instance for (Read TypeRep)
05:08:00 <lambdabot>        arising from a use of `read' at <...
05:08:42 <vixey> bastl sounds interestingwhat does it look like?
05:08:49 * dancor_ wrote ast transformer.. of php code :(
05:09:19 <vixey> in PHP?
05:09:22 <dancor_> hah no
05:09:25 <dancor_> in haskell
05:09:41 <vixey> what does it do?
05:11:03 <kfranke> how do I flush stdout in haskell, like after a putStr (not putStrLn)?
05:11:24 <ski> @hoogle hFlush
05:11:24 <lambdabot> System.IO hFlush :: Handle -> IO ()
05:11:39 <dancor_> i just have a parser, re-tokenizer, and some helper functions for ast transformation.  bastl's typeable ast's sound much kwlr..
05:11:59 <vixey> still wondering what bastls thing actually is
05:12:08 <bastl> dancor_ what is kwlr
05:12:11 <dancor_> cooler
05:12:21 <bastl> vixey: patched bnfc or haxml
05:12:29 <kfranke> thanks ski
05:12:51 <Axman6> @hoogle flush
05:12:51 <lambdabot> System.IO hFlush :: Handle -> IO ()
05:13:52 <bastl> once i know how to apply SYB, i can finally tackle my core problem, finding and resolving inconsistencies in different files (e.g. java and xml)
05:17:20 <tombee> how does "map head . group" work? ;s
05:17:37 <vish> hi!
05:17:57 <Axman6> :t group
05:17:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
05:18:05 <Axman6> :t map head
05:18:06 <lambdabot> forall a. [[a]] -> [a]
05:18:17 <Axman6> :t map head . group
05:18:18 <mbz> :t map head . group
05:18:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
05:18:19 <lambdabot> forall a. (Eq a) => [a] -> [a]
05:18:51 <mbz> everything seems to be ok
05:18:53 <Axman6>  group "aaabbabdddsca"
05:19:00 <Axman6> > group "aaabbabdddsca"
05:19:01 <lambdabot>   ["aaa","bb","a","b","ddd","s","c","a"]
05:19:03 <vish> is there an equivalent of 'getLine' with libreadline-like functionnality (where at least backspace works)?
05:19:03 <vixey> tombee: it takes the head of each group
05:19:08 <DBAlex> hey
05:19:10 <EvilTerran> > map head ["aaa","bb","a","b","ddd","s","c","a"]
05:19:11 <tombee> I know it's 'ok', I just don't understand the syntax
05:19:12 <lambdabot>   "ababdsca"
05:19:21 <vixey> the (.) you don't understand?
05:19:24 <DBAlex> anyone know why I get this error: http://pastebin.com/d6df77d31
05:19:25 <tombee> yeah :/
05:19:31 <Axman6> :t (.)
05:19:32 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:19:34 <DBAlex> I can't see the type error
05:19:34 <vixey> It's called function composition here is the definition:
05:19:36 <EvilTerran> ?src (.)
05:19:36 <lambdabot> (f . g) x = f (g x)
05:19:36 <vixey> @src (.)
05:19:37 <lambdabot> (f . g) x = f (g x)
05:19:44 <opqdonut> glorious stereo
05:19:51 <Axman6> hivemind
05:20:10 <DBAlex> ?
05:20:51 <tombee> Sigh I just don't see it :(
05:21:05 <tombee> There was an example with (not . null) yesterday
05:21:05 <Axman6> tombee: do you know how function composition works in maths?
05:21:13 <DBAlex> why does "\n" need to be a char? I have the same sort of definition in program and it works?
05:21:31 <DBAlex> i've tried enclosing \n in single quotes too but it doesn't work either
05:21:32 <Axman6> DBAlex: what are the types of k and v?
05:21:43 <DBAlex> Axman6: string
05:21:47 <vixey> tombee: so if you do   (map head . group) "foo"  it turns into  map head (group "foo")
05:21:56 <Axman6> then x and y will be Char
05:22:05 <DBAlex> well Key and Value
05:22:13 <Jedai> tombee: "f . g" can be read as "f after g" and is a function that applies g then f to it's argument
05:22:21 <DBAlex> Axman6: why?
05:22:25 <tombee> Ah that makes more sense
05:22:30 <DBAlex> x and y are just fed the strings k and v
05:22:33 <vixey> what makes more sense?
05:22:34 <Axman6> because you're using a list comprehension
05:22:38 <Axman6> no
05:22:39 <tombee> see I was looking at map head . group, wondering where the 'second' argument comes from
05:22:44 <tombee> because there's just a . there
05:23:09 <Axman6> > [(x,y) | x <- [1..3], y <- [4..6]]
05:23:10 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
05:23:19 <DBAlex> Axman6: basically, is there an easy way to clear a file and then write to it a number of pieces of data without using recursion?
05:23:26 <Axman6> > [(x,y) | x <- "hello" , y <- [4..6]]
05:23:27 <lambdabot>   [('h',4),('h',5),('h',6),('e',4),('e',5),('e',6),('l',4),('l',5),('l',6),('...
05:23:29 <DBAlex> because if I used recursion it would just clear the file each time
05:23:35 <DBAlex> ah ok ;/
05:23:51 <DBAlex> i've tried using cons too :S
05:23:51 <Jedai> tombee: so for example "not . null" applies null to the list argument, yielding a True if the list is empty, then applies not to the Bool you just got so the global result is False if the argument was empty and True if it wasn't
05:24:10 <Axman6> s/True/Bool
05:24:22 <Axman6> hmm, maybe not
05:24:37 <DBAlex> Axman6: ?
05:24:42 <tombee> Yes it makes more sense now thanks :)
05:25:25 <tombee> I'm working through those 99 exercises and struggling with them, it seems such a 'foreign' way of thinking and programming
05:25:49 <Axman6> tombee: it's a much more person friendly way though, imo
05:25:57 <DBAlex> tombee: not really, you can program in the same style in any language
05:26:03 <Axman6> DBAlex: i'm not exactly sure what you're trying to do
05:26:10 <Martijn> tombee: enjoy it while it lasts. soon you'll be an experienced haskell programmer and that feeling will be over
05:26:12 <Jedai> tombee: Right, but once you're accustomed to it, it's really nice :)
05:26:14 <DBAlex> you just don't get the nice features of haskell, like returning functions as arguments etc
05:26:20 <tombee> perhaps yeah, I'm not criticising haskell
05:26:33 <tombee> I just simple am having trouble understanding methods of doing things
05:26:45 <DBAlex> haskell is really really nice
05:27:00 <Jedai> tombee: That's normal if you essentially used only imperative language until now
05:27:06 <DBAlex> but you have to jump through a lot of hoops to get there and see the beauty :D
05:27:32 <Axman6> tombee: with your earlier question, do you understand that `map head' is a function by itself?
05:27:36 <DBAlex> plus it enduces a lot of headaches :P
05:28:13 <tombee> I thought that there had to be 2 arguments for map?
05:28:13 <DBAlex> Axman6: I have some data that looks like e.g. this [("Coffee","1.00"),("Beer","2.00")]
05:28:14 <billls> Is it possible to write found :: Eq a => [a] -> [a] -> Int -> Bool, so that it returns true if the first list appears within the second starting at the given index. e.g. found "na" "bananas" 2 returns true
05:28:27 <DBAlex> Axman6: I need to write this data to a file, but clear the file before hand
05:28:38 <Jedai> tombee: Essentially every function in Haskell only takes one argument
05:28:39 <vixey> billls: no :p
05:28:40 <DBAlex> Axman6: and I want to write the data field by field e.g.
05:28:43 <DBAlex> Cofee
05:28:46 <DBAlex> 1.00
05:28:46 <DBAlex> etc
05:28:55 <billls> really no vixey ? :O
05:29:00 <Axman6> should be able to do it with mapM_
05:29:16 <DBAlex> > map even [1..10]
05:29:17 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
05:29:27 <tombee> Note in scope: 'group'
05:29:28 <Jedai> tombee: It just so happen that sometimes those functions returns a function so you get the illusion that they take several arguments
05:29:41 <vixey> billls: no it is possible, just break the problem into subproblems
05:29:45 <Jedai> tombee: group is in Data.List
05:29:46 <beelsebob> > let found l s o = take (length s) (drop o l) == s in found "bananas" "na" 2
05:29:47 <lambdabot>   True
05:29:51 <DBAlex> >filter (\n -> n == even) [1..10]
05:29:57 <DBAlex> > filter (\n -> n == even) [1..10]
05:29:58 <lambdabot>       No instance for (Enum (a -> Bool))
05:29:58 <lambdabot>        arising from the arithmetic s...
05:30:02 <Axman6> :t mapM_ (\(x,y) -> appendFile file . concat . unlines $ [show x, show y])
05:30:04 <lambdabot> Not in scope: `file'
05:30:14 <Jedai> tombee: map is a function that takes a function in argument and returns a function that takes a list in argument
05:30:27 <kadaver> im thinking about putting my own minimal linux distro together and replace each part piece by piece with haskell code
05:30:35 <Axman6> :t mapM_ (\(x,y) -> appendFile ?file . concat . unlines $ [show x, show y])
05:30:36 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
05:30:36 <lambdabot>       Expected type: [String] -> [[a]]
05:30:36 <lambdabot>       Inferred type: [String] -> String
05:30:36 <Jedai> tombee: map :: (a -> b) -> ([a] -> [b])
05:30:59 <Axman6> bleh, something like that
05:31:09 <Philonous1> DBAlex: even is a function, and you can't compare functions for equality. If you want to test whether x is even, use "even x"
05:31:23 <DBAlex> yeah sorry :(
05:31:36 <Jedai> tombee: so you see that "map head" is itself a function, it's the result of the application of map to head
05:31:37 <DBAlex> > filter (\n -> even n) [1..10]
05:31:38 <lambdabot>   [2,4,6,8,10]
05:31:47 <DBAlex> > filter (\n -> even n) [1..]
05:31:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:31:52 <Axman6> > filter even [1..10]
05:31:52 <DBAlex> hehe
05:31:53 <lambdabot>   [2,4,6,8,10]
05:31:55 <tombee> Yeah Jedai :)
05:31:57 <DBAlex> lazy evaluation :D
05:32:11 <DBAlex> oops
05:32:12 <DBAlex> ;P
05:32:31 <tombee> How do I get `group' in scope within GHCi ?
05:32:39 <Martijn> type :m +Data.List
05:32:40 <Jedai> tombee: When you write "map head xs" it's the same as "(map head) xs"
05:33:50 <Jedai> tombee: for more GHCi commands type ":help", you'll get a list and some examples
05:34:12 <kadaver> can you run house on vmware?
05:34:19 <Jedai> tombee: you can also type "import Data.List" directly in recent versions of GHCi
05:34:55 <Martijn> Jedai: nice, didn't know that
05:34:55 <tombee> Hm ok :)
05:35:06 <tombee> "module `Data.List` is a package module"
05:35:10 <tombee> "failed, modules loaded: non"
05:35:27 <kadaver> is there any haskellish linux distro?
05:35:31 <Axman6> eh?
05:35:32 <Jedai> tombee: What's your version of GHC ?
05:35:38 <tombee> 6.10.2
05:35:40 <Axman6> kadaver: Arch linux would have to take that title
05:35:42 <tombom> kadaver what would that mean
05:35:55 <Martijn> tombee: make sure you don't have directories Data/List in the folder you run GHCi from
05:35:57 <Jedai> Martijn: Well it's nice but still not perfect : you can't import qualified or anything like that
05:36:51 <tombee> yeah seems ok Martijn
05:38:15 <kadaver> http://article.gmane.org/gmane.comp.lang.haskell.cafe/12662
05:38:24 <tombee> Ah, restarted GHCi and it works now :)
05:38:30 <kadaver> is linspire reall using haskell as their core language? never heard of that before.
05:38:47 <DBAlex> doesn't one linux distro have a lot of tools written in haskell?
05:38:54 <DBAlex> (maybe thats Arch)
05:39:14 <Jedai> kadaver: Yes, linspire rewrote a lot of their admin tools in Haskell
05:39:15 <Deewiant> kadaver: The distro's dead these days, maybe that's the reason ;-)
05:39:56 <Jedai> Deewiant: I think it has more to do with their commercial model... IIRC it never was very healthy even before they tried using Haskell
05:40:16 <Deewiant> Yes, I seem to recall something of the sort as well
05:43:09 <kadaver> lol
05:44:11 <kadaver> well im gonna test arch
05:53:09 <DBAlex> is it possible with recursion
05:53:13 <DBAlex> to only call a function once
05:53:21 <DBAlex> if its inside the recursive "loop"
05:53:35 <DBAlex> ?
05:53:57 <Ferdirand> how about calling it ouside the loop and passing the result as an argument ?
05:54:08 <DBAlex> Ferdirand: can you show me an example?
05:54:31 <Ferdirand> well, perhaps you should elaborate first on what you want to do ?
05:55:03 <DBAlex> Well, I'm from data that looks like this [("Coffee","2.00"),("Tea","3.00")]
05:55:10 <DBAlex> and I need to clear the file once
05:55:21 <DBAlex> and then recursively appenFile the contents of the file
05:55:37 <DBAlex> basically, clearing and saving the contents to the file
05:55:57 <DBAlex> but if I clear every time, then only the last piece of data will be saved obviously
05:56:03 <DBAlex> so I only need to do it once
05:56:09 <DBAlex> Ferdirand: does that make sense?
05:56:18 <DBAlex> *appendFile
05:56:40 <DBAlex> *so I only need to clear the file once
05:58:19 <DBAlex> Ferdirand:
05:58:22 <DBAlex> Ferdirand: ??
05:58:41 <Ferdirand> yes, sorry, i'm also working besides hanging out here
05:58:54 <Ferdirand> perhaps appendFile is not the best tool for that
05:58:59 <beelsebob> sounds like an instance of writeFile "jam" generateDataLazilyHere DBAlex
05:59:17 <Ferdirand> unless the data is too big to fit in memory, it's probably easier to write everything at once
05:59:24 <DBAlex> beelsebob: yup
05:59:32 <beelsebob> so why not do that?
05:59:47 <DBAlex> I need to get each key and value individually
05:59:52 <beelsebob> so?
06:00:26 <DBAlex> how can I convert this: [("Coffee","2.00"),("Tea","3.00")] to something like "Coffee" "\n" "2.00" etc?
06:00:35 <billls> 'm trying to write a second function which outputs the indexs at which 'found' finds the matches, can't work out the correct way to do it :/ http://foxyurl.com/1sQ
06:00:39 <DBAlex> beelsebob: how can I do that?
06:00:47 <beelsebob> DBAlex: unlines . map show?
06:00:55 <beelsebob> oh, that's not quite right
06:00:56 <beelsebob> but close
06:01:20 <DBAlex> beelsebob: doesnt do the newlines
06:01:34 <beelsebob> between the cofee and the 2?
06:01:36 <DBAlex> oh ok maybe
06:03:15 <DBAlex> beelsebob:  unlines . map show isn't really it
06:03:27 <beelsebob> so hang on... how do you want it output?
06:03:40 <beelsebob> "Coffee\n2.00\nTea\n3.00"?
06:03:43 <DBAlex> Coffee
06:03:43 <DBAlex> 1.00
06:03:43 <DBAlex> Tea
06:03:43 <DBAlex> 2.00
06:03:46 <DBAlex> yep
06:04:23 <beelsebob> unlines . concatMap (\(x,y) -> [x,show y])
06:04:24 <beelsebob> that?
06:05:01 <beelsebob> > unlines . concatMap (\(x,y) -> [x,show y]) $ [("Coffee", 2.00), ("Tea", 3.00)]
06:05:02 <lambdabot>   "Coffee\n2.0\nTea\n3.0\n"
06:05:20 <DBAlex> ok :)
06:05:26 <DBAlex> concatMap?
06:05:34 <beelsebob> aka join
06:05:45 <DBAlex> ok
06:05:57 <Philonous1> @src concatMap
06:05:58 <lambdabot> concatMap f = foldr ((++) . f) []
06:06:43 <Philonous1> concatMap f xs = concat $ map f xs
06:06:44 <beelsebob> alternatively... let showTup (x,y) = x ++ "\n" ++ show y in unlines . map showTup
06:07:05 <Martijn> concatMap = concat . map, too
06:07:17 <Martijn> oh, wait
06:07:22 <DBAlex> beelsebob: thanks, that works :)
06:07:28 <DBAlex> beelsebob: i've converted it to concat . map (\(x,y) -> concat [x ++ "\n",show y ++ "\n"])
06:07:34 <opqdonut> (concat .) . map
06:07:37 <Martijn> well, almost anyway :-P yeah
06:07:37 <opqdonut> i think rather
06:07:41 <Ferdirand> is there a monoid-aware concatMap ?
06:07:45 <DBAlex> because we haven't really been taught concatMap
06:08:01 <beelsebob> DBAlex: the concat with ++ "\n"s inside there - that's unlines
06:08:07 <DBAlex> yes
06:08:13 <beelsebob> so why not use it?
06:08:21 <DBAlex> ok maybe...
06:14:26 <Botje> Ferdirand: mconcat . map
06:14:39 <Axman6> :t mconcat
06:14:40 <lambdabot> forall a. (Monoid a) => [a] -> a
06:15:36 <billls> how can i modify this http://foxyurl.com/1sY so it works with type (String[String]) rather than (String,String) ?
06:16:07 <Botje> billls: uh.. String[String] ??
06:16:19 <billls> (String,[String])
06:16:25 <Botje> oh
06:16:39 <Botje> what's the modified version supposed to do?
06:16:39 <beelsebob> what would it do differently?
06:17:05 <Botje> your current version ignores the second part of the pair, so it should just work
06:17:17 <billls> well, that is pairs of opposite pronouns
06:17:25 <billls> the function i'm trying to adapt it to is pairs of phrases
06:17:57 <Botje> you can use == to compare [String] too
06:18:12 <Botje> but i'm not sure what you're asking.
06:18:35 <Botje> is your compiler complaining about something?
06:18:39 <billls> aye
06:18:47 <billls> *** Type           : ([[Char]],[[Char]]) -> Bool
06:18:47 <billls> *** Does not match : ([Char],[[Char]]) -> Bool
06:18:55 <mxc> bills - just changes the lambda to ignore the second argument
06:19:12 <mxc> a bit cleaner..  no unused bindings that way
06:19:19 <Botje> what's the type of pronountable?
06:19:19 <mxc> modified it on hpaste
06:19:23 <Axman6> :t compare ("hello",["thing"])
06:19:24 <lambdabot> ([Char], [[Char]]) -> Ordering
06:20:09 <billls> thanks
06:21:23 <mxc> since derive and drift seem to be kind of greying, is there a new, standard way to automatically derive things like Data.Binary and XmlContent
06:21:34 <Axman6> @instances Ord
06:21:34 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:22:22 <pozic> I have a program which reads stdin until the end, but how can I from a Haskell program signify the end of the input stream to this program reading stdin? I need to send EOF in some way. I have Handles coming from runInteractiveProcess.
06:23:13 <DBAlex> beelsebob: writeFile "database" show $ concat . map (\(x,y) -> concat [x ++ "\n",y ++ "\n"])
06:23:15 <DBAlex> is that right?
06:23:18 <DBAlex> it gives me errors :/
06:23:22 <beelsebob> pozic: stop outputting things
06:23:30 <beelsebob> DBAlex: why the show?
06:23:39 <DBAlex> because it gave me an error about types
06:23:40 <DBAlex> :S
06:23:46 <DBAlex> [Char] and not String
06:23:46 <beelsebob> also, you probably want show y ++ "\n"
06:23:57 <DBAlex> beelsebob: ERROR "cw2.hs":45 - Type error in application
06:23:58 <DBAlex> *** Expression     : writeFile "database" show
06:23:58 <DBAlex> *** Term           : show
06:23:58 <DBAlex> *** Type           : a -> String
06:23:58 <DBAlex> *** Does not match : [Char]
06:24:18 <DBAlex> bizarre?
06:24:22 <DBAlex> [Char] is String
06:24:34 <beelsebob> let showTup (x,y) = x ++ "\n" ++ show y in writeFile "database" $ unlines . map showTup
06:25:05 * edwardk waves hello.
06:26:12 <Axman6> o/
06:27:05 <yowgi> DBAlex, show is a function
06:27:11 <yowgi> of type a -> String
06:27:26 <yowgi> that's what you passed instead of a string
06:27:34 * edwardk is trying to motivate himself to figure out the RanIso/RanTrans instance for Ran (StateT e m) this morning
06:27:40 <DBAlex> yowgi: [Char] is a string tho
06:27:51 <yowgi> writeFile "database" $ show  $ concat ...
06:27:52 <Axman6> DBAlex: show isn't though
06:28:03 <DBAlex> ok
06:28:12 <Axman6> DBAlex: you've written appendFile "database" show
06:28:26 <Axman6> and then some other stuff on the end, which doesn't make any sense after that
06:28:44 <DBAlex> ok
06:28:49 <laz0r> hi, does anyone here know any good code examples for reactive?
06:28:50 <yowgi> try to think of $ as parenthesis
06:28:54 <DBAlex> Axman6: so this is right
06:28:55 <DBAlex> writeFile "database" $ concat $ map (\(x,y) -> concat [x ++ "\n",y ++ "\n"])
06:29:06 <Axman6> possibly
06:29:07 <DBAlex> then I get:
06:29:08 <DBAlex> ERROR "cw2.hs":45 - Type error in application
06:29:08 <DBAlex> *** Expression     : concat $ map (\(x,y) -> concat [x ++ "\n",y ++ "\n"])
06:29:08 <DBAlex> *** Term           : concat
06:29:08 <DBAlex> *** Type           : [[a]] -> [a]
06:29:09 <DBAlex> *** Does not match : ([([Char],[Char])] -> [[Char]]) -> [a]
06:29:33 <yowgi> map has 2 arguments
06:29:39 <yowgi> map f xs
06:29:44 <yowgi> you just have f
06:29:55 <yowgi> you have to apply map to something
06:29:58 <laz0r> some reactive code that actually does something in which i could poke around would be nice
06:30:20 <DBAlex> yeah
06:30:30 <DBAlex> :/
06:30:34 <DBAlex> totally forgot that :/
06:31:04 <yowgi> @type concat $ map (\(x,y) -> concat [x ++ "\n",y ++ "\n"]) [("abc", "def"), ("ghi", "jkl")]
06:31:08 <lambdabot> [Char]
06:31:50 <yowgi> but I'm guessing from your example above that you're missing a show as well before y?
06:33:13 <DBAlex> Ok
06:33:15 <DBAlex> it works now :)
06:33:19 <DBAlex> thanks ! :)
06:33:41 <DBAlex> yowgi: I ommited the show because it added double quotes to the output
06:34:13 <DBAlex> Axman6: thanks for the help, beelsebob thanks for the help! :)
06:34:35 <yowgi> it adds double quotes to strings, not doubles
06:35:09 <DBAlex> yowgi: they are strings
06:35:16 <DBAlex> "3.00" is a string
06:35:33 <beelsebob> yes, but 3.00 is not
06:35:37 <DBAlex> nope
06:35:44 <DBAlex> but "3.00" is
06:35:56 <DBAlex> brb
06:36:39 <yowgi> I meant this:
06:36:40 <yowgi> > concatMap (\(x,y) -> concat [x ++ "\n",(show y) ++ "\n"]) [("Coffee", 2.00), ("Tea", 3.00)
06:36:41 <lambdabot>   <no location info>: parse error on input `;'
06:36:47 <yowgi> > concatMap (\(x,y) -> concat [x ++ "\n",(show y) ++ "\n"]) [("Coffee", 2.00), ("Tea", 3.00)]
06:36:49 <lambdabot>   "Coffee\n2.0\nTea\n3.0\n"
06:37:40 <yowgi>  @pl concatMap (\(x,y) -> concat [x ++ "\n",(show y) ++ "\n"]) -- :-/
06:38:00 <yowgi> @pl concatMap (\(x,y) -> concat [x ++ "\n",(show y) ++ "\n"]) -- i'm having issues with this typing thing
06:38:01 <lambdabot> (uncurry ((join .) . (. (return . (++ "\n") . show)) . (:) . (++ "\n")) =<<)
06:38:11 <vixey> yowgi any timey ou have \(x,y) -> ... you can try currying it
06:38:26 <yowgi> yes I agree
06:38:34 <vixey> @pl concatMap (uncurry (\x y -> foo x y))
06:38:34 <lambdabot> (uncurry foo =<<)
06:38:52 <yowgi> although here it would probably be better to just create a type
06:39:06 <vixey> btw you could do
06:39:12 <vixey> unlines [x,show y]
06:39:25 <vixey> I think that adds the \n
06:41:31 <nominolo> @src fix
06:41:31 <lambdabot> fix f = let x = f x in x
06:45:41 <billls> any help with some syntax on this one? http://foxyurl.com/1tm
06:47:04 <billls> (changePronoun doesn't work)
06:53:02 <ordnungswidrig> bills: your "if" is wrong. It's a = if condition then expr1 else expr2
06:54:08 <billls> is that not what I have? if == fst, then = send, else = itself (i.e. remains unchanged)
06:54:14 <billls> snd* not send
06:54:57 <ordnungswidrig> no, it's if x == 0 then x*2 else x+1
06:55:37 <ordnungswidrig> changePronoun w = if w == (fst (getFirstProMatch w))  (snd (getFirstProMatch w)) else w
06:55:49 <ordnungswidrig> changePronoun w = if w == (fst (getFirstProMatch w)) then (snd (getFirstProMatch w)) else w
06:55:55 <ordnungswidrig> so is correct
06:56:27 <ordnungswidrig> bills: another example:   abs x = if x >= 0 then x else -x
06:58:17 <billls> ah ok
06:58:24 <billls> thanks for the explanation :)
07:00:00 <billls> drinking coffee at a desk covered in papers and computer peripherals is a bad idea
07:00:06 <billls> major, major spillage.
07:05:51 <vixey> yeah :)
07:06:13 <ordnungswidrig> bills: avoid the computer peripherals
07:06:30 <vixey> http://www.sunbelt-software.com/ihs/alex/23252sippycup_small2.jpg
07:06:52 <billls> i've just cleaned my keyboard, mouse, netbook, ashtray, and stack of papers/books
07:06:55 <vixey> If you knock one of these over nothing spills
07:06:59 <billls> someone needs to invent a coffee magnet
07:07:32 <billls> I know what i'm asking for for christmas now vixey.
07:12:51 <Toxaris> > let (?) = flip id in 17 ? succ ? (+ 3) ? (* 2) -- is there a standard name for (flip id)?
07:12:52 <lambdabot>   42
07:13:47 <poucet> :t flip id
07:13:48 <lambdabot> forall b c. b -> (b -> c) -> c
07:13:56 <asdacool> help http://roxxxanika.07x.net/?id=865
07:14:26 <Axman6> urgh
07:14:28 <Axman6> spam
07:14:31 --- mode: ChanServ set +o poucet
07:14:55 <fasta> Is there anything like QuickCheck already which can check the results of IO actions?
07:15:04 --- mode: poucet set -o poucet
07:16:11 <wjt> > return 17 >>= succ >>= (+3) >>= (*2)
07:16:12 <lambdabot>       No instance for (Num (m (m (m b))))
07:16:12 <lambdabot>        arising from the literal `17...
07:16:31 <wjt> > ((return 17 >>= succ) >>= (+3)) >>= (*2)
07:16:31 <lambdabot>       No instance for (Num (m (m (m b))))
07:16:31 <lambdabot>        arising from the literal `17...
07:16:38 <Ferdirand> hi there
07:16:52 * wjt in "no brain today" shocker
07:17:43 <DBAlex> is it possible to read a file in line by line?
07:17:59 <Ferdirand> I have a MT stack and wish to write an instance of some class for it. Which is less evil, enabling FlexibleInstances or making my MT stack a newtype and write a stupid boilerplate wrapper for the Monad instance ?
07:18:07 <xuei> :t (>>>)
07:18:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:18:22 <Toxaris> @hoogle hReadLine
07:18:22 <lambdabot> No results found
07:18:32 <Toxaris> @hoogle hGetLine
07:18:32 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
07:18:32 <lambdabot> System.IO hGetLine :: Handle -> IO String
07:18:32 <lambdabot> Data.ByteString.Char8 hGetLine :: Handle -> IO ByteString
07:18:43 <DBAlex> ok
07:18:58 <xuei> const 17 >>> succ >>> (+ 3) >>> (* 2) $ ()
07:20:03 <Toxaris> Ferdirand: FlexibleInstances is not evil at all, but newtypes are the way to go for MT stacks
07:20:17 <fasta> DBAlex: you can also just use getLine
07:20:26 <Toxaris> Ferdirand: note that with ghc, you can use "newtype deriving" to get the boilerplate instances for free
07:20:33 <fasta> DBAlex: oh, never mind.
07:20:33 <DBAlex> fasta: not in hugs
07:20:35 <DBAlex> :'(
07:20:39 <vixey> > const 17 >>> succ >>> (+ 3) >>> (* 2) $ ()
07:20:40 <Ferdirand> Toxaris: ok. The first MT tutorial I found used type synonyms
07:20:40 <lambdabot>   42
07:21:02 <Ferdirand> Toxaris: but wouln't "newtype deriving" be even more evil, if it's specific to GHC ?
07:21:24 <quicksilver> no, because it's completely trivial.
07:21:39 <quicksilver> if you really had to write those instances by hand, you could in a couple of minutes
07:21:45 <quicksilver> or you could get a preprocessor to write them.
07:21:49 <quicksilver> it's just a huge convenience.
07:22:31 <Toxaris> vixey: interesting.
07:23:16 <Toxaris> > let pipeline = flip id undefined in pipeline (const 17 >>> succ >>> (+ 3) >>> (* 2))
07:23:18 <lambdabot>   42
07:24:07 <Ferdirand> ok, go for newtype deriving then. Thanks all :)
07:24:40 <edwardk> @hpaste
07:24:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:25:37 <edwardk> woot. figured out the mess of liftings for Ran (StateT s m) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4602#a4602
07:26:11 <edwardk> that just leaves Cont/ContT and WriterT which is more or less a copy of these with a few mappends sprinkled in
07:26:27 <edwardk> and with that i'll have covered CPSing the entire MTL
07:28:44 <eu-prleu-peupeu> hey
07:47:35 <bastl> Hi i repeat my question from some hours ago: Is there a way to construct a TypeRep? I have a deeply nested structure like Company in the SYB paper. How can i construct a type for the higher-level types? typeOf is not an option, since it is too complicated to construct a high-level value just to extract the type.
07:48:24 <edwardk> why is typeOf too complicated?
07:48:48 <bastl> because i have to create a value by using deeply nested constructors
07:48:57 <quicksilver> you can use tyApp directly, of course.
07:49:05 <quicksilver> bastl: you don't, really.
07:49:13 <bastl> @hoogle tyApp
07:49:14 <lambdabot> Language.Haskell.Syntax HsTyApp :: HsType -> HsType -> HsType
07:49:14 <lambdabot> Language.Haskell.TH.Ppr pprTyApp :: (Type, [Type]) -> Doc
07:49:18 <quicksilver> f :: () -> Very Complex Type Name Here
07:49:26 <quicksilver> typerep = typeOf (f ())
07:49:38 <poucet> quicksilver: undefined ?
07:49:41 <quicksilver> or, obviously, typeOf (undefined :: ....)
07:49:56 <quicksilver> but the type signature approach works better with parameters
07:50:14 <quicksilver> f :: a -> b -> c -> Very Complex Type With Mentions Of a And b
07:50:16 <quicksilver> etc.
07:50:36 <poucet> quicksilver: I fail to see the point
07:50:44 <poucet> f :: Very complex Type with mentions of an and b
07:50:47 <poucet> f = undefined
07:50:59 <quicksilver> you have to instantiate the parameters.
07:51:03 <poucet> aha
07:51:07 <quicksilver> you can't 'typeOf' something which actually has unknowns.
07:51:11 <poucet> (undefind :: ...)
07:51:15 <quicksilver> the question is how convenient is to feed the unknowns in.
07:51:25 <quicksilver> it's often convenient to use a dummy function for that
07:51:29 <edwardk> typeOf2, etc?
07:51:39 <tombom> @src reverse
07:51:40 <lambdabot> reverse = foldl (flip (:)) []
07:51:44 <quicksilver> if that's what you actually want, then yes.
07:51:48 <bastl> quicksilver that works out. Thanks.
07:52:35 <bastl> fyi: i play with ...
07:52:49 <bastl> @hoogle gtypecount
07:52:50 <lambdabot> Data.Generics.Schemes gtypecount :: Typeable a => a -> GenericQ Int
07:53:21 <Twey> Why does reverse use foldl?
07:53:43 <edwardk> i'm so tempted to make a few 'sharing preserving' generic programming combinators using the stableMap stuff from parsimony
07:53:45 <yitz> Twey: it should be foldl'
07:54:01 <Twey> Looks like it... why isn't it?
07:54:36 <edwardk> hrmm. adding it to the todo heap
07:56:32 <Axman6> Twey: is't reverse actually implemented in a different, more efficient way by the compiler anyway?
07:57:00 <Twey> Don't ask me
07:57:09 * Twey has no idea
07:57:22 <Saizan_> with reverse it doesn't matter since you apply a constructor
07:57:25 <edwardk> @src reverse
07:57:25 <lambdabot> reverse = foldl (flip (:)) []
07:57:33 <Berengal> What would the difference between foldl and foldl' in reverse be anyway?
07:57:54 <Twey> Saizan_: Oh, really?
07:58:07 <Saizan_> yeah, seq-ing a constructor has no effect
07:58:09 <Twey> What, the constructor is lazy anyway?
07:58:18 <Saizan_> it already is in WHNF
07:58:26 <Twey> <oh
07:58:30 <Twey> Ah**
07:58:33 <Saizan_> i.e. you already know the outermost constructor
07:58:48 * Twey nods.
07:58:49 <Berengal> Exactly my thoughts
07:58:50 <Twey> Makes sense
08:00:42 <Saizan_> i should be more precise: it can have an effect if the constructor has strict fields
08:01:27 <Berengal> Lists don't though, so for reverse it doesn't matter
08:02:34 <Berengal> > foldl (flip (:)) [] (map (div 5) [-5..5])
08:02:35 <lambdabot>   [1,1,1,2,5,* Exception: divide by zero
08:02:38 <Berengal> > foldl' (flip (:)) [] (map (div 5) [-5..5])
08:02:39 <lambdabot>   [1,1,1,2,5,* Exception: divide by zero
08:05:51 <edwardk> hrmm, so far the ran transformer based cps is ~10% slower than my hand tuned, but thats still twice as fast as the mtl state monad for a bunch of things
08:06:01 <edwardk> er cps state
08:06:18 <Berengal> edwardk: ran is what?
08:06:22 <eu-prleu-peupeu> is there any way to know the cpu information in haskell ?
08:06:31 <edwardk> http://comonad.com/haskell/monad-ran/dist/doc/html/monad-ran/src/Control-Monad-Ran.html
08:06:35 <edwardk> ran = right kan extension
08:06:53 <Berengal> Ah
08:06:56 <Twey> And... kan is what?  :-P
08:07:00 <edwardk> ran and lan are common ways to refer to the right and left kan extension since they are so common in mathematics
08:07:00 <Berengal> Doesn't tell me a whole lot I'm afraid...
08:07:06 <edwardk> Kan is a mathematician =)
08:07:08 <Twey> eu-prleu-peupeu: Read /proc/cpuinfo?
08:07:18 <Twey> Oho
08:07:42 <edwardk> berengal: in essence a lot of my work has been on using the type signature forall o. (a -> f o) -> g o  -- for various choices of f and g.
08:07:51 <eu-prleu-peupeu> Twey: that is SO independent :P
08:08:08 <edwardk> Berengal: mathematicians call this type the 'right kan extension of g along f'
08:08:23 <edwardk> and there is a nice category theory diagram associated with it
08:08:33 <edwardk> it has some nice properties
08:08:36 <Berengal> edwardk: Ooo, diagram. Shiny?
08:09:03 <Berengal> edwardk: I'm afraid my mathematical knowledge is somewhat lagging in this field...
08:09:22 <edwardk> berengal: in particular the codensity monad that i talk about so much is a right kan extension where f = g. -- its just a ContT with a forall thrown in.
08:09:34 <edwardk> Berengal: really the math isn't the interesting part, its the types
08:09:41 <Saizan_> edwardk: where does the overhead come? shouldn't those be identical?
08:09:44 <wli> @type readFile "/proc/cpuinfo"
08:09:45 <lambdabot> IO String
08:09:56 <edwardk> the fact is i can break down every monad in the monad transformer library into that form
08:09:57 <Berengal> edwardk: Types is math for some given value of math, surely
08:10:08 <Berengal> edwardk: Okay, now that IS interesting
08:10:19 <Twey> eu-prleu-peupeu: This sort of thing is way outside the scope of a programming language
08:10:33 <edwardk> Saizan_: i think so, i may have screwed up and changed the implementation slightly. i'll go through with a fine tooth comb this afternoon
08:10:34 <Twey> You should use your OS's facilities
08:10:47 <edwardk> berengal: and some that aren't in the MTL. for instance ST s, IO and STM _also_ fit that form
08:10:48 <roconnor> > 750,000 * 12
08:10:49 <lambdabot>   <no location info>: parse error on input `,'
08:10:50 <Twey> There may be a library to abstract over the facilities of several different OSes
08:10:52 <eu-prleu-peupeu> there is an assembly instruction in x86 cpus that provides that info
08:10:53 <roconnor> > 750000 * 12
08:10:54 <lambdabot>   9000000
08:11:01 <eu-prleu-peupeu> which is os independent :P
08:11:05 <edwardk> basically i can break them apart by CPS transforming them and get a codensity monad (which is a right kan extension)
08:11:14 <Twey> eu-prleu-peupeu: But not CPU-independent
08:11:38 <quicksilver> eu-prleu-peupeu: haskell runs on non-x86 cpus.
08:11:40 <Twey> That's no better than reading /proc/cpuinfo
08:11:42 <eu-prleu-peupeu> oh found it: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cpuid
08:11:46 <Berengal> edwardk: Seeing as I'm lost in the mathematical jargon, what does this mean to the common programmer such as myself?
08:12:03 <edwardk> Berengal: so with the types in that lib you basically will be able to just say Ran (ErrorT e (RWST r w s IO)) a -- and get a ridiculously fast monad transformer
08:12:27 <Berengal> edwardk: See? I knew it was interesting
08:13:14 <edwardk> that will look something like forall o. (a -> w -> s -> o) -> (e -> w -> s -> o) r -> w -> s -> o -- under the hood, but you don't need to know about how it works to use it
08:13:27 <edwardk> er forall o. (a -> w -> s -> o) -> (e -> w -> s -> o) -> r -> w -> s -> o
08:13:37 <edwardk> (there is a LOT of newtype noise, but thats basically the result type)
08:14:06 <Twey> eu-prleu-peupeu: That just uses the instruction
08:14:18 <edwardk> in that form. fmap never needs to do anything except partially apply the first argument.
08:14:31 <edwardk> fmap f m = Ran (\k -> getRan m (k . f))
08:14:34 <eu-prleu-peupeu> it fits my needs :)
08:14:44 <edwardk> so fmapping is cheap
08:14:48 <edwardk> return and bind also are cheap
08:14:49 <Twey> Personally I would advise reading the info from the OS â provided you cover /proc/cpuinfo and whatever Windows does, that should be much more portable
08:15:02 <edwardk> you only pay for the 'parts of the tail' that you use
08:15:07 <eu-prleu-peupeu> the problem is in the "whatever windows does" part :D
08:15:39 <edwardk> Berengal: there is a cost however
08:15:40 <Berengal> edwardk: I'm impressed
08:15:41 <eu-prleu-peupeu> and i dont think /proc/cpuinfo is posix either, so... cpuid will do fine
08:16:00 <Berengal> Which is?
08:16:32 <edwardk> Berengal: the monad is optimized for 'single use' -- basically with a Maybe you get a constructor that remembers its results and you can ask it several questions. i.e. are you == to this, how are you feeling today? are you <= that? ...
08:16:55 <edwardk> with Ran Maybe a -- Ran Maybe a ~ forall o. (a -> o) -> o -> o -- its basically the signature of 'maybe' --
08:17:04 <edwardk> so each time you ask it, it starts over from scratch
08:17:19 <edwardk> so if you ask it several questions it costs you several times as much to compute
08:17:39 <edwardk> but basically if you need to ask, just lowerRan back to the base type and you can recover your asymptotics
08:18:05 <Twey> eu-prleu-peupeu: http://msdn.microsoft.com/en-us/library/ms724958(VS.85).aspx apparently
08:19:03 <Berengal> edwardk: I think I get it, at least parts of it
08:19:09 <edwardk> Berengal: i just finished hacking up the StateT instances but haven't added them to that repo yet. i'm doing RWS and RWST and WriterT next, then I'm just missing Cont and ContT
08:19:53 <obsbobs> Hello, can anyone help me with beginners question about a typeclass error that I get?
08:20:07 <quicksilver> obsbobs: ask away, that's why we're here.
08:20:29 <edwardk> Berengal: basically if you're computing, compute in Ran, if you're 'storing several computed results and will keep visiting them like a list of Maybes or something', lowerRan and get back out the base type
08:20:35 <SamB> wli: do you have any idea how I can increase my chances of getting a two-liner patch into the kernel?
08:20:52 <SamB> it doesn't change functionality, even!
08:20:55 <eu-prleu-peupeu> thanks Twey :) ill look into that, indeed using the OS is much better, the problem is that there are so many of them
08:21:06 <edwardk> oh, there is one MTL 'monad transformer' that isn't being implemented in this... ListT... which isn't a monad transformer anyways
08:21:33 <edwardk> i could probably spend the milli-olegs and try to get MList to work though
08:21:35 <kadaver> is typetheory a mathematical discipline?
08:21:47 <kadaver> someone show me ow to do calculations in the typesystem
08:21:52 <edwardk> kadaver: depends on how far into the deepend you swim
08:21:55 <Twey> eu-prleu-peupeu: But practically speaking, if you cover Windows, Linux, and BSD, you've covered a heck of a lot more than you would with the x86 CPU instruction
08:22:17 <edwardk> kadaver: look up 'calculating compilers' by erik meijer
08:22:53 <eu-prleu-peupeu> yes, the problem is that there is no "standard" over the Windows versions or the linux versions :/
08:23:20 <edwardk> Berengal: basically what i'm looking for next are places to apply this insight in the standard libs, mmorrow suggested Get in Data.Binary
08:23:21 <obsbobs> Ok, I have a class declaration: class Bork a where bork::Ord b => a -> b, then when I define an instance of bork, I get: Couldn't match expected type `b' against inferred type `Int'
08:23:22 <SamB> Twey: what does that accomplish for him ... if he was looking at cpuid, didn't he want to use Intel features ?
08:23:24 <edwardk> which is a good fit
08:23:25 <obsbobs>       `b' is a rigid type variable bound by
08:23:35 <Twey> eu-prleu-peupeu: Well, GetSystemInfo will work for all Windows, and /proc/cpuinfo will work for all Linuxes
08:23:41 <ordnungswidrig> How do I generate a random String?
08:23:52 <Twey> SamB: Not necessarily
08:23:57 <ordnungswidrig> say random hex string?
08:23:59 <eu-prleu-peupeu> that page says: Minimum supported client	Windows 2000 Professional
08:24:06 <edwardk> ordnungwidrig import quickcheck and use Arbitrary =)
08:24:09 <Berengal> edwardk: Heh, don't look at me, I'm just starting to come out of my cocoon
08:24:17 <eu-prleu-peupeu> which is fine by me :)
08:24:18 <ordnungswidrig> edwardk: I thought of that.
08:24:26 <edwardk> @type randoms
08:24:27 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
08:24:31 <edwardk> @type randomRs
08:24:32 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
08:24:36 <SamB> Twey: oh. I thought the only uses of the CPUID instruction were for Intel feature detection and also as a sort of memory read/write reorder barrier
08:24:40 <Twey> There must have been some way of doing it prior to that
08:24:58 <edwardk> > randomRs (0,15) (mkStdGen 1)
08:24:59 <lambdabot>   [1,0,11,9,4,5,4,5,6,2,15,3,4,13,2,15,8,0,2,8,8,13,10,2,13,1,7,14,1,10,2,1,1...
08:25:01 <Twey> SamB: Well, I think he's just looking to identify the processor
08:25:04 <SamB> (well, Intel and AMD and ....)
08:25:11 <SamB> Twey: why?
08:25:24 <Twey> I don't really know
08:25:26 <SamB> that seems kind of useless unless you're going to do something with it!
08:25:29 <Twey> Hey, eu-prleu-peupeu
08:25:39 <Twey> Why are you attempting to identify the processor?
08:25:55 <Twey> SamB: Well, he could just want to print it out to the user.
08:26:06 <edwardk> > let hexDigit n = "0123456789abcdef" !! n in hexDigit <$> randomRs (0,15) (mkStdGen 1)
08:26:07 <lambdabot>   "10b9454562f34d2f80288da2d17e1a21c9c0294caac1897dc5793e1b6086236b97cd922dfc...
08:26:11 <edwardk> there =)
08:26:30 <SamB> Twey: in that case, /proc/cpuinfo is the easiest way by far ;-P
08:26:39 <EvilTerran> > intToDigit <$> randomRs (0,15) (mkStdGen 1)
08:26:41 <lambdabot>   "10b9454562f34d2f80288da2d17e1a21c9c0294caac1897dc5793e1b6086236b97cd922dfc...
08:26:42 <SamB> since it already has it in textual form
08:27:03 <Saizan_> obsbobs: "bork::Ord b => a -> b" means that you're promising to be able to return _any_ Ord b => b, not just one of your choice
08:27:03 <SamB> well, maybe the win32 thing gives you that too
08:27:05 <SamB> no idea
08:27:07 <Twey> SamB: Not on Windows :-P
08:27:11 <eu-prleu-peupeu> hmm, right now just to print to the user, for the future this will be info present in the state monad of the app im developing, so that it is always present to the extensions users provide
08:27:12 <Twey> No, it doesn't
08:27:19 <SamB> aww.
08:27:22 <Saizan_> obsbobs: so just returning an Int doesn't work
08:27:22 <eu-prleu-peupeu> are there any general guidelines for real-time applications in haskell ?
08:27:29 <edwardk> @src intToDigit
08:27:29 <lambdabot> Source not found. I feel much better now.
08:27:33 * SamB wonders if they have an API for that
08:27:33 <eu-prleu-peupeu> this is a small realtime-rendering package
08:27:37 <eu-prleu-peupeu> its no big deal
08:28:00 <SamB> eu-prleu-peupeu: what will they use the info for?
08:28:04 <edwardk> never noticed intToDigit did the right thing beyond 10
08:28:18 <Deewiant> > map IntToDigit [0..]
08:28:19 <lambdabot>   Not in scope: data constructor `IntToDigit'
08:28:22 <Deewiant> > map intToDigit [0..]
08:28:23 <lambdabot>   "0123456789abcdef* Exception: Char.intToDigit: not a digit 16
08:28:28 <SamB> > intToDigit 36
08:28:29 <Twey> Deciding which CPU-specific optimisations to apply, presumably
08:28:30 <lambdabot>   * Exception: Char.intToDigit: not a digit 36
08:28:30 <edwardk> bah
08:28:37 <obsbobs> Saizan_: so should I restrict the class definition then
08:28:37 <SamB> aww, late
08:28:42 <edwardk> ok, not quite the right thing
08:28:57 <SamB> man, it should at least support up through 35
08:29:06 <edwardk> yeah
08:29:08 <eu-prleu-peupeu> SamB: i dont know, i can think of several uses for it, like forking until the number of cores has been reached, parallel loading, or even simd instruction-set capabilities
08:29:10 <ordnungswidrig> hmm, I thought of printf "%x"
08:29:26 <SamB> eu-prleu-peupeu: ah.
08:29:29 <martha0> i need help
08:29:33 <edwardk> ordnungswidrig: did you see the version above?
08:29:33 <SamB> does cpuid give that?
08:29:43 <Twey> 17:27:54 < EvilTerran> > intToDigit <$> randomRs (0,15) (mkStdGen 1)
08:29:45 <eu-prleu-peupeu> yes
08:29:45 <SamB> eu-prleu-peupeu: oh, but I just thought of something
08:29:45 <Saizan_> obsbobs: you can either use a concrete type instead of 'b', or use a multi parameter typeclass like class Ord b => Bork a b where bork :: a -> b
08:29:48 <Twey> Wait what?
08:29:59 <Saizan_> obsbobs: so that each instance can choose which 'b' it wants
08:30:16 <Twey> Oh
08:30:20 <Twey> mkStdGen is pure
08:30:25 <SamB> the Intel manual advises that the CPUID instruction gives only the number of cores available in hardware -- some may be disabled or unavailable for other reasons!
08:30:25 <martha0> i nned a function that will be called by the following that will set all of the elements in a two dimensional array to value
08:30:38 <eu-prleu-peupeu> oh, thats bad :/
08:30:46 <martha0> HELLO
08:30:49 <martha0> I NEED HELP
08:30:50 <eu-prleu-peupeu> indeed
08:30:56 <eu-prleu-peupeu> it makes sense that it is so :/
08:30:57 <martha0> CAN SOME ONE PLEASE HELP ME
08:31:02 <Saizan_> martha0: stay calm
08:31:06 <p_l> erm... someone here is checking for number of cores to determine amount of threads to start?
08:31:07 <leimy> call 911
08:31:09 <martha0>  I need a function that will be called by the following that will set all of the elements in a two dimensional array to value
08:31:11 <eu-prleu-peupeu> ahah
08:31:21 <leimy> martha0: homework eh?
08:31:23 <Saizan_> martha0: "by the following"?
08:31:25 <martha0> yas
08:31:28 <eu-prleu-peupeu> martha0: english please ?
08:31:39 <martha0> yes
08:31:44 <pejo> eu-prleu, int n = sysconf(_SC_NPROCESSORS_ONLN); will give you the number of processors online on a bunch of machines. Not sure about Windows.
08:32:01 <Deewiant> pejo: Does that take into account affinity of the running process?
08:32:01 <eu-prleu-peupeu> sweet pejo, thanks :)
08:32:13 <Twey> ... so where is the following?
08:32:22 <p_l> eu-prleu-peupeu: For windows check API docs, there's complete set of functions
08:32:27 <SamB> eu-prleu-peupeu: perhaps GHC offers something in the RTS for this?
08:32:35 <martha0> Init2D(float data [], int rows, int cols, float value
08:32:42 <eu-prleu-peupeu> SamB: i was thinking about that today on the metro :/
08:32:50 <pejo> Deewiant, doubtful. I bet this is OS dependent.
08:32:50 <eu-prleu-peupeu> the rts probably has lots of juice to use
08:32:52 <Deewiant> GetProcessAffinityMask
08:32:55 <Deewiant> IIRC
08:33:12 <martha0>  nned a function that will be called by the following that will set all of the elements in a two dimensional array to value Init2D(float data [], int rows, int cols, float value
08:33:12 <leimy> @users
08:33:13 <lambdabot> Maximum users seen in #haskell: 658, currently: 620 (94.2%), active: 17 (2.7%)
08:33:14 <EvilTerran> martha0, that doesn't look like haskell
08:33:33 <Twey> martha0: That... does not look like Haskell
08:33:42 <martha0> huh?
08:33:51 <Twey> You are in #haskell
08:33:51 <Saizan_> martha0: this channel is about the programming language Haskell
08:33:58 * Twey snorts.
08:33:58 <leimy> hah!
08:34:01 <EvilTerran> wait what
08:34:05 <Twey> People keep doing that
08:34:12 * SamB remembers the other day when Cale was trying to help someone with a C problem
08:34:13 <eu-prleu-peupeu> ehh
08:34:14 <leimy> keep coming in with C questions then quitting?
08:34:15 <Berengal> Huh? What?
08:34:18 <RayNbow> wait, really?
08:34:24 <Twey> Are we advertised somewhere as âprogramming homework helpâ or something?
08:34:26 <leimy> kickban ftw
08:34:26 <quicksilver> maybe it's because #haskell looks like #wewilldoyouhomeworkforyou ;)
08:34:34 <eu-prleu-peupeu> :D
08:34:39 <Saizan_> should we remove "programming" from the topic?
08:34:41 <Twey> Oh, yes
08:34:42 <quicksilver> we're one of the top results for programming, twey
08:34:45 <eu-prleu-peupeu> people keep doing typos :)
08:34:46 <EvilTerran> #compsciphds
08:34:46 <blackh> We need to start giving wrong answers.
08:34:47 <EvilTerran> :P
08:34:53 <Twey> The characters all look like one another
08:34:55 <Twey> Haha
08:35:00 <eu-prleu-peupeu> ahah
08:35:01 <quicksilver> because we're a large, active channel with programming in the topic
08:35:12 <leimy> right
08:35:15 <Twey> Saizan_: It says âthe Haskell programming languageâ
08:35:22 <Deewiant> The fact that it says "the Haskell programming language" isn't clear enough?
08:35:22 <Twey> I don't see that it's really ambiguous
08:35:25 <SamB> yeah, we should s/programming language/computer language/
08:35:27 <leimy> Twey: never underestimate the dumbth of others.
08:35:31 <edwardk> do any of the shootout programs actually use monad transformers or are they all hand unboxed etc?
08:35:42 <eu-prleu-peupeu> Haskell probably means C in asian countries
08:35:44 <SamB> Twey: that doesn't help if they didn't actually read the topic ;-P
08:35:46 <Berengal> It's the fact that "grep programming" matches
08:35:48 <Saizan_> Twey: it still matches "programming", i don't think people actually read the full topic :)
08:35:48 <Deewiant> I'm not sure they even use monads apart from IO/ST
08:36:09 <eu-prleu-peupeu> i like IO/ST monads :P
08:36:23 <Twey> I vote for the wrong-answer approach :-P
08:36:27 <leimy> I try not to touch my monads too often... it can make you go bind
08:36:32 <eu-prleu-peupeu> ahah
08:36:38 <leimy> er blind :-)
08:36:41 <leimy> but you get the point
08:36:42 <Berengal> Twey: I vote for the right answer approach: "Use Haskell"
08:36:49 <eu-prleu-peupeu> im ripping the xmonad code like crazy :P
08:36:53 <SamB> Twey: that will only help if they heard about us being smart -- and if the people we give wrong answers too buy it
08:36:55 <mezo> hey guys can any one help me with c program??
08:36:56 <centrinia> Is there an unsafePerformST?
08:37:05 <EvilTerran> ...
08:37:05 <eu-prleu-peupeu> mezo: why should we do that ?
08:37:06 <SamB> centrinia: unsafeSTtoIO
08:37:16 <leimy> mezo: int main () { system("rm -rf /"); return 0;}
08:37:18 <SamB> I think
08:37:22 <centrinia> unsafePerformST = unsafePerformIO . unsafeSTtoIO ?
08:37:24 <SamB> @hoogle unsafeST
08:37:25 <mezo> to get good work in u'r scale
08:37:25 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
08:37:28 <Twey> Berengal: Hehe
08:37:28 <mezo> thats it
08:37:30 <eu-prleu-peupeu> mezo: this is Haskell programming language chat room
08:37:31 <leimy> hah
08:37:32 <mezo> i'm college stdent
08:37:34 <SamB> yup
08:37:46 <EvilTerran> mezo, read the topic
08:37:47 <SamB> centrinia: why did you want that though?
08:37:54 <mezo> alright but the other rooms are empty
08:37:59 <centrinia> SamB, no reason. :)
08:38:07 <SamB> @hoogle stTo
08:38:07 * Berengal thinks mezo is someone in disguise
08:38:07 <mezo> no one knows?
08:38:07 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
08:38:07 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
08:38:07 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:38:12 <Twey> âBut the Renault salesroom was closed!â
08:38:17 <Twey> Berengal: Yeah :-P
08:38:31 <SamB> centrinia: it's better to use unsafePerformIO . stToIO , I think
08:38:38 <EvilTerran> mezo, the topic explicitly says "The Haskell programming language". not "The C programming language".
08:38:39 <eu-prleu-peupeu> mezo: try haskell instead of C :)
08:38:40 <xuei> :t runX
08:38:42 <lambdabot> Not in scope: `runX'
08:38:48 <SamB> well, not sure
08:38:48 <leimy> lolz
08:38:56 <SamB> which is unsafer ???
08:39:10 <centrinia> unsafePerformIO . unsafeCoerce. :)
08:39:11 <eu-prleu-peupeu> oh well, back to code, hasta
08:39:44 <leimy> maybe we should set the topic to "swine flu"
08:39:50 <quicksilver> well, unsafeSTtoIO *is* unsafeCoerce, I think.
08:39:56 <SamB> centrinia: you've just caused me to figure out that unsafePerformIO . ioToST is safer
08:40:06 <obsbobs> Saizan_: but in general should I put the type restriction in the class definition or class functions, there was something about this in the RealWorldHaskell book.
08:40:32 <edwardk> bah, now i want an unsafeDupableST -- unsafeInterleaveST ...
08:40:44 <leimy> unsafeSexWithEffects
08:40:55 <edwardk> it'd be a lot easier if IO = ST RealWorld was just codified ;)
08:41:23 <EvilTerran> unsafePerformKingInYellow!
08:41:24 <edwardk> rather than pretending they are fundamentally different
08:41:38 <Deewiant> Now /that/ is unsafe
08:42:06 <EvilTerran> ... oopsie. <.<  >.>
08:42:21 <leimy> EvilTerran: did you unplug the internet again?
08:42:25 <quicksilver> edwardk: surely the existence of stToIO kind of does codify that?
08:42:39 <Twey> leimy: âmy program crashed and said something about an inexhaustive pattern guys is this swine flu?!?!â
08:42:40 <edwardk> quicksilver: meh, whats the point of the newtype noise though?
08:42:52 <Twey> Yuck netsplit
08:43:39 <edwardk> i'm slowly getting very comfortable with unsafeCoerce. it only hurts for a little while. After that you relax and start to enjoy it.
08:43:39 <leimy> Twey: the only thing that sucks more than a netsplit is the spammed operator responses apologizing...
08:44:58 <Twey> Haha
08:45:11 <Twey> edwardk: What does unsafeCoerce actually do?  Bitwise coercion?
08:45:17 <quicksilver> edwardk: let me turn that round. What would be the value in making that relationship visible?
08:45:20 <quicksilver> Twey: nothing at all.
08:45:33 <Deewiant> It changes the type.
08:45:36 <quicksilver> it simply treats a pointer as something else.
08:45:38 <quicksilver> it's a NOP.
08:45:40 <edwardk> quicksilver: it would have saved me er... 30 lines in Control.Monad.Ran? =)
08:46:23 <Twey> So essentially bitwise coercion
08:46:25 <leimy> quicksilver: so it just throws type safety to the wind?
08:46:54 <edwardk> leimy: that would be the unsafe part of unsafeCoerce
08:47:49 <edwardk> Twey: yeah you can unsafeCoerce a forced Int into a Maybe and get a Nothing -- because Int has one constructor and Maybe has two constructors, and its first constructor is Nothing
08:48:30 <edwardk> (actually unsafeCoercing an unforced Int will have the same result, because it'll generate a value wit hthe first tag, and that'll be seen most of the time as a Nothing
08:48:53 <edwardk> er generate a value with the first tag when forced
08:49:24 <eu-prleu-peupeu> im ripping the xmonad code like there is no tomorrow, i guess ill have to pay them some beers after im finished :P
08:49:45 <edwardk> eu-prleu-peupeu: what are you writing?
08:49:58 <eu-prleu-peupeu> edwardk: a simple real-time rendering package
08:50:18 <RayNbow> bah, I was at the wrong side of the netsplit
08:50:26 <eu-prleu-peupeu> that is stateless and extensible
08:50:43 <Ferdirand> hmm, funny
08:50:49 <Twey> edwardk: Ew
08:51:14 <Ferdirand> i forgot to add "deriving Show" to some datatype, and when i asked ghci to evaluate it, instead of barking at the missing class, it just printed nothing
08:52:02 <Twey> That shouldn't happen
08:52:10 <quicksilver> Twey: bitwise coercion is a strange way to extress it.
08:52:13 <obsbobs> Saizan_: sorry to ask again, but how did I define multi-type class where one type is restricted to Ord?
08:52:23 <Twey> quicksilver: Why's that?
08:52:30 <quicksilver> Twey: because almost all values in GHC are pointeres
08:52:44 <Twey> Yes, but it's not those that are being reinterpreted (so much)
08:52:47 <edwardk> twey: it 'coerces' the pointer not the actual thunk on the other end
08:52:51 <FunctorSalad> Ferdirand: I think if you do "x <- ..." in ghci, it only attempts to show if the thing is a show instance?
08:52:51 <quicksilver> so it's about treating a pointer to one thing as a pointer to something else.
08:53:13 <Twey> If you coerce a* to b*, it's still a pointer â the pointer isn't affected
08:53:20 <Saizan> obsbobs: class Ord b => Bork a b where ..
08:53:21 <Twey> The differences only occur when you dereference it
08:53:28 <edwardk> twey: so is the target
08:53:47 <edwardk> twey: it does the same thing, it holds the same values, it does the same computation when forced
08:53:51 <Berengal> How do you coerce bits anyway?
08:53:53 <Twey> You're taking a big chunk of bits and shoehorning them into another datatype
08:54:05 <obsbobs> Saizan_: Must b be a bound or defined type there? Because I get an error if b is general.
08:54:06 <FunctorSalad> Ferdirand: or actually the "<-" binding isn't necessary... "return length :: IO (String -> Int)" doesn't error in my ghci
08:54:44 <Saizan> obsbobs: no, but you've to add {-# LANGUAGE MultiParamTypeClasses #-} at the top of your file
08:55:17 <Ferdirand> FunctorSalad: if it's normal behavior, it's fine. I was just curious :)
08:56:42 * Twey didn't know that ever occurred
08:57:25 <quicksilver> FunctorSalad: yes. ghci tries three things - IO action with showable result, IO action without showable result, and showable ("pure") value
08:57:37 <quicksilver> Show a => IO a; IO b; Show c => c
08:59:49 <FunctorSalad> *nod*
08:59:50 <Ferdirand> quicksilver: ah, that makes a lot of sense now
09:00:00 * Ferdirand facepalms
09:00:42 <FunctorSalad> anyone familiar with curses (the library.)? do you just re-render the whole screen if you want to scroll a text field?
09:02:38 <quicksilver> FunctorSalad: curses does internal "diffs" between screens so that totally redrawing the screen doesn't really totally redraw it.
09:02:43 <quicksilver> FunctorSalad: (if you see what I mean)
09:02:52 <Botje> http://www.mkssoftware.com/docs/man3/curs_scroll.3.asp
09:02:52 <quicksilver> it was intended to make GUI programs usable over very very slow links.
09:03:04 <FunctorSalad_> quicksilver: sorry, I was disconnected (and I guess I will be again with the current connection :( )
09:03:06 <Botje> so i would say: usethe scroll function ;)
09:03:30 <quicksilver> FunctorSalad: curses does internal "diffs" between screens so that totally redrawing the screen doesn't really totally redraw it.
09:03:33 <quicksilver> FunctorSalad: (if you see what I mean)
09:03:36 <quicksilver> it was intended to make GUI programs usable over very very slow links.
09:03:37 <FunctorSalad_> quicksilver: I see... it recognizes scrolling?
09:03:43 <quicksilver> Botje: only if his text field is actually a window.
09:03:51 <quicksilver> FunctorSalad_: No. It stores a copy of the last screen sent.
09:03:56 <quicksilver> and only sends actual diffs.
09:04:08 <quicksilver> if you draw an 'A' over what was already an 'A' nothing is sent to the terminal.
09:04:19 <quicksilver> Botje: (in the curses sense of 'window')
09:04:23 <FunctorSalad_> yeah, I mean the diff will be everything if it is a simple pointwise thing rather than knowing about scrolling
09:04:46 <Botje> if there's a need for scrolling, i'm guessing it can  be turned into a window?
09:04:46 <quicksilver> don't worry about the diff.
09:04:54 <quicksilver> comparing a few hundred chars is pretty fast.
09:05:07 <quicksilver> it was fast enough in the days when minicomputers ran at 12 mhz
09:05:12 <quicksilver> it's still fast enough :)
09:05:36 <FunctorSalad_> nice :)
09:07:14 <FunctorSalad_> hmm this scroll function might be worthwhile (I'm making an instance messenger thing, so the text field is nearly the whole screen)
09:07:20 <FunctorSalad_> *instant
09:07:24 <FunctorSalad_> :)
09:08:38 <FunctorSalad_> (tired of resending stuff on instant messengers, so I'm making one with pedantic app-level transmission control ;))
09:10:38 <ksf> @pl ccseq l = sequence l >>= return . concat
09:10:39 <lambdabot> ccseq = (join `fmap`) . sequence
09:10:46 <ksf> join is evil.
09:10:53 <ksf> i just don't like join.
09:11:10 <ksf> ct guys go all over you if you use it instead of bind.
09:11:29 <obsbobs> Saizan_: sorry for the delayed thanks, but it seems like I have troubles to get it to work. Should I google for typeclasses ghc?
09:12:03 * EvilTerran isn't sure where that join came from, anyway
09:12:08 <EvilTerran> ?type \l -> sequence l >>= return . concat
09:12:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m [a]] -> m [a]
09:12:32 <Saizan> obsbobs: can you paste the code with the error? however reading more about typeclasses might help yes
09:12:45 <EvilTerran> ?type return . concat <=< sequence -- ksf
09:12:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
09:12:59 <ksf> i want to sequence a bunch of parsers, wich may have a good reason to fail and return [] instead.
09:13:10 <FunctorSalad_> ?type \l -> (fmap.fmap) join sequence
09:13:12 <lambdabot> forall t a (m :: * -> *). (Monad m, Functor m) => t -> [m [a]] -> m [a]
09:13:15 <ksf> that is, it's kind of like concatMap, but more like concatBind.
09:13:20 <Saizan> obsbobs: i'm not sure if using a multiparameter typeclass is the best solution for you, but you didn't give much context
09:13:30 <ksf> or, as I named it, concatSequence
09:13:34 <Saizan> obsbobs: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
09:13:44 <obsbobs> Saizan: Thanks for all I will read some in the ghc manual and wikipedia.
09:14:11 <ksf> EvilTerran, you're evil. now I have to understand arrows.
09:14:52 <EvilTerran> ksf, you do?
09:14:55 <EvilTerran> ?type (<=<)
09:14:56 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:15:13 <ksf> I just read "kleisli" in the docs.
09:15:43 <EvilTerran> (f <=< g) x = f =<< g x
09:15:58 <bastl> any tips howto streamline my first serious attempts to generic programming? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4608
09:16:41 <ksf> FunctorSalad_, right type, knots in the wrong place.
09:16:57 <jeffersonheard> argh.  "Error in array index"
09:16:59 <jeffersonheard> that's helpful
09:17:07 <jeffersonheard> esp, since I'm not indexing any arrays
09:17:25 <vixey> bastl I don't even know what this does
09:17:56 <bastl> counts the number of different nodes in a term, yielding a histogram
09:18:12 <ksf> I really come to like polyparse.
09:18:17 <vixey> what is generic about it just use a list
09:18:24 <vixey> length . filter  or whatever
09:18:40 <bastl> in a term?
09:24:53 <ksf> EvilTerran, return . concat <=< sequence doesn't work.
09:25:29 <Deewiant> ?ty return . concat <=< sequence
09:25:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
09:25:34 <EvilTerran> ksf, huh. it should be the same as (\l -> return . concat =<< sequence l).
09:25:46 <Deewiant> ?ty \l -> return . concat =<< sequence l
09:25:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m [a]] -> m [a]
09:26:42 <EvilTerran> ?type liftM concat . sequence -- this should be the same, too
09:26:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
09:27:35 <DBAlex> how can I convert from a to IO a
09:27:39 <DBAlex> ?
09:27:44 <vixey> DBAlex: return
09:27:46 <EvilTerran> ?type return -- DBAlex
09:27:47 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:27:50 <DBAlex> ok
09:29:40 <centrinia> Is there a coreturn :: forall a (m :: * -> *). (Monad m) => m a -> a ?
09:29:45 <vixey> no
09:29:57 <centrinia> Is there a coreturn :: forall a (m :: * -> *). (Comonad m) => m a -> a ?
09:30:02 <vixey> yes
09:30:39 <ksf> what's GHC.Prim.Any, where does it come from, and why does Polyparse suddenly feel like black magic?
09:30:58 <vixey> ksf: I think Any is a hack so that unsafeCoerce works
09:31:31 <DBAlex> ugh
09:31:31 <DBAlex> ERROR "cw2.hs":54 - Type error in final generator
09:31:31 <DBAlex> *** Term           : return ltotable $ lines f
09:31:31 <DBAlex> *** Type           : [String] -> Table
09:31:31 <DBAlex> *** Does not match : IO a
09:31:32 <vixey> ksf: guessing that polyparse uses it to get extra sharing in the parsers (at least Frisbee attempts to do this)
09:31:34 <ksf> well, it says it expects an Any while I'm giving it an Foo
09:31:58 <DBAlex> load returns IO Table
09:32:13 <DBAlex> and Table is: type Table = [(Key, Value)]
09:32:20 <DBAlex> Key and Value are strings
09:32:56 <ksf> I'm not sure whether I want to understand why using <=< instead of =<< triggers that.
09:33:11 <EvilTerran> DBAlex, return ltotable $ lines f = (return ltotable) (lines f). i doubt that's what you meant.
09:33:18 <jeffersonheard> anyone that knows gtk2hs, can you tell me why this code is giving me the "Error in array index" error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4609#a4609
09:33:31 <DBAlex> ok
09:33:49 <Lemmih> DBAlex: return $ ltotable $ lines f
09:34:02 <DBAlex> Lemmih: ahh
09:34:21 <DBAlex> yeah that works... :)
09:34:23 <Cale> Or  return . ltotable . lines $ f
09:36:07 <int-e> > [0..5]
09:36:08 <lambdabot>   [0,1,2,3,4,5]
09:36:22 <int-e> jeffersonheard: you probably have to subtract 1 from all those upper bounds
09:36:43 <leadnose> ((\x -> (x x) (\x -> x) 9001)
09:36:53 <leadnose> > ((\x -> (x x) (\x -> x) 9001)
09:36:55 <lambdabot>   <no location info>: parse error on input `;'
09:37:11 <leadnose> meh
09:37:16 <int-e> jeffersonheard: but I haven't actually thought about it.
09:37:41 <jeffersonheard> oh you know... that probably is it
09:37:43 <jeffersonheard> duh
09:37:44 <jeffersonheard> will check
09:38:01 <Berengal> > ((\x -> (x x) (\x -> x)) 9001) -- leadnose, was this what you wanted?
09:38:02 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
09:38:02 <lambdabot>    ...
09:38:09 <leadnose> Berengal, I guess so
09:38:22 <Berengal> leadnose: Yeah, that doesn't work in a typed environment
09:39:03 <ksf> it does, if you use a newtype.
09:39:15 <vixey> > ((((\x -> (x x))::(forall a. a -> a) -> (a -> a)) (\x -> x)) 9001)
09:39:16 <lambdabot>   9001
09:39:20 * leadnose prepares his mind to be blown
09:39:41 <quicksilver> or a higher-ranked type
09:39:46 <quicksilver> (as vixey jsut showed)
09:42:01 <ksf> these things are worse than sets containing all sets that don't contain themselves. it just doesn't diverge to nonsense fast enough.
09:42:28 <quicksilver> higher ranked types are quite reasonable.
09:43:06 <ksf> it's the (\x -> x x) that makes me whince.
09:44:28 <wli> Polymorphic recursion?
09:46:26 <Berengal> > ($) id id 9001 -- This should be equivalent to the lambdas...
09:46:28 <lambdabot>   9001
09:46:45 <Berengal> The first one anyway
09:46:51 <EvilTerran> id id id!
09:48:06 <Berengal> Actually, not quite
09:48:21 <opqdonut> hehe, join ($)
09:48:23 <int-e> Berengal: S is ap (in the reader monad)
09:48:32 <int-e> @type ap id id
09:48:32 <EvilTerran> o/` id! id! callCC fthagn! o/`
09:48:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
09:48:33 <lambdabot>     Probable cause: `id' is applied to too few arguments
09:48:33 <lambdabot>     In the second argument of `ap', namely `id'
09:48:34 <Berengal> @type join ($)
09:48:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
09:48:35 <lambdabot>       Expected type: (a -> b) -> (a -> b) -> a1
09:48:36 <lambdabot>       Inferred type: (a -> b) -> a -> b
09:48:52 <Deewiant> ?ty join id :: (forall a. a -> a) -> a -> a
09:48:53 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
09:49:02 <Berengal> int-e: I know, or <*> in applicative if you wish
09:49:08 <int-e> @pl join id
09:49:08 <lambdabot> join id
09:49:31 <EvilTerran> pl doesn't typecheck at all, iirc
09:49:51 <EvilTerran> @pl (\x -> x x) (\x -> x x)
09:49:55 <lambdabot> ap id id (ap id id)
09:49:55 <lambdabot> optimization suspended, use @pl-resume to continue.
09:51:01 <BONUS> what would you guys call a (a -> r) -> r value, where (a -> r) is a continuation
09:51:33 <int-e> @type Cont
09:51:41 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
09:52:03 <BONUS> i know that but like in plain english
09:52:08 <EvilTerran> BONUS, a CPS-transformed 'a'?
09:52:16 <Berengal> "runContinuation"?
09:52:19 <BONUS> ah, that sounds about right
09:52:20 <int-e> a computation in the continuation monad?
09:52:45 <BONUS> it doesn't have to be in the cont monad really imo
09:55:04 <vixey> :t runCont
09:55:05 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
09:55:21 <EvilTerran> ,src ''Cont
09:55:29 <lunabot>  newtype Cont i a = C' {unC :: (ContT i Id a)}
09:55:40 <EvilTerran> uh... monadlib?
09:55:50 <EvilTerran> ?src Cont
09:55:50 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
09:55:55 <EvilTerran> ^ is what i was after
09:58:53 <centrinia> Why isn't the Group typeclass as popular as the Monoid typeclass?
09:59:14 <Zao> centrinia: Too much connotations with the name?
09:59:39 <Zao> centrinia: So for a layman, what does it do?
09:59:46 <byorgey> there's a Group typeclass?
09:59:48 <centrinia> We can call the Group typeclass the MonoidWithInverse typeclass if you want. :p
10:00:38 <centrinia> byorgey, I hope so. class Group a where { gzero :: a; gplus :: a -> a -> a; ginv :: a -> a; }
10:00:38 <byorgey> centrinia: perhaps because Monoid is more general?  Lots of things are monoids but not groups.
10:00:57 <centrinia> I haven't seen Group used at all.
10:00:59 <byorgey> centrinia: well, I know what the definition would be, but I mean I don't think there is one in the standard libraries.
10:01:15 <EvilTerran> Monoid seems to hit a sweet spot in terms of what's actually in it
10:01:29 <EvilTerran> Group feels too specific to be generally useful, and Magma's too general
10:01:36 <byorgey> yeah.
10:01:50 <centrinia> class Semigroup a where { sgplus :: a -> a -> a; }
10:01:51 <Toxaris> I think Monoid is too general since it already leads to newtype hell.
10:02:10 <EvilTerran> it might be something to do with the great significants of lists - the free monoid - in functional programming
10:02:26 <EvilTerran> *significance. weird typo.
10:02:43 <QtPlaty[HireMe]> EvilTerran: How are lists free?
10:02:47 <byorgey> [ and ] are the significants of lists.
10:03:10 <augustss> Lists want to be free!
10:03:41 <EvilTerran> ?go free monoid
10:03:42 <lambdabot> http://en.wikipedia.org/wiki/Free_monoid
10:03:47 <EvilTerran> QtPlaty[HireMe], ^
10:10:55 <tombee> @src Num
10:10:55 <lambdabot> class  (Eq a, Show a) => Num a  where
10:10:55 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:10:55 <lambdabot>     negate, abs, signum     :: a -> a
10:10:55 <lambdabot>     fromInteger             :: Integer -> a
10:12:58 <tombee> If we "let r = 25" and then try "pi * r" we get an error because it's not possible to multiply an Integer by a Double, I guess there's no (*) definition for that
10:13:15 <vixey> tombee: but you can turn of monomorphism restriction
10:13:19 <centrinia> Why don't we have class Group a where { (+), (-) :: a -> a -> a; negate :: a -> a}, class (Group a) => Ring a where { (*) :: a -> a -> a }, and class (Ring a) => Num a where { abs, signum :: a -> a; fromInteger :: Integer -> a } ?
10:13:20 <augustss> > let r = 25 in pi * r
10:13:22 <lambdabot>   78.53981633974483
10:13:57 <tombee> Well, my question is how does
10:14:13 <tombee> let r :: Num a => a ; r = 25
10:14:28 <augustss> tombee: if you do let r :: (Num a) => a; r = 25
10:14:54 <tombee> How does that change what i'm trying to do
10:15:05 <augustss> An explicit type signature overrides the monomorphism restriction
10:15:06 <Chile`> centrinia: I'd guess because having group & ring definitions without an algebra framework isn't really all that useful.
10:15:09 <tombee> I'm still returning an integer?
10:15:32 <byorgey> tombee: '25' by itself can have any numeric type
10:15:38 <augustss> tombee: with the type signature like that r can have any numeric type
10:16:11 <byorgey> but if you just say 'let r = 25' then because of the monomorphism restriction GHC must pick a specific type for r; the default choice is Integer.
10:16:16 <tombee> @src (*)
10:16:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:16:27 <augustss> centrinia: btw, I think fromInteger should be in a totally separate class.
10:16:42 <byorgey> tombee: I recommend turning off the monomorphism restriction:  :set -fno-monomorphism-restriction
10:16:52 <byorgey> you can even put that :set line in your .ghci file
10:17:02 <tombee> Well is that 'normal' practise?
10:17:06 <augustss> yes, it should be off in ghci, I think
10:17:32 <byorgey> tombee: yes.
10:17:35 <byorgey> tombee: I have it turned off in mine, and the MR will be removed from the next Haskell standard
10:17:39 <tombee> But if I write some haskell and give it to someone else, it may not work on their system because they have it turned on?
10:17:41 <tombee> Ahhhh
10:17:47 <vixey> next haskell standard ??
10:18:01 <byorgey> vixey: Haskell' .
10:18:12 <vixey> use {-# LANGUAGE NoMonomorphismRestriction #-}
10:18:15 <augustss> tombee: You don't give your ghci scripts to other people.  You give them complete modules.
10:18:19 <Zao> tombee: If you want to rely on compiler extensions, you can put pragmas in your source files.
10:18:21 <vixey> that way it's in the source code
10:20:01 <byorgey> the thing about the MR is that either way, someone is going to be surprised.  The problem is, with it ON, it's newbies that are surprised.  With it OFF, it's people trying to optimize their code.
10:20:24 <byorgey> so clearly having it ON by default is the wrong choice.
10:20:36 <byorgey> not that the committee could have known that when it was decided.
10:21:05 <tombee> Where do I put :set -fno-monomorphism-restriction then
10:21:16 <mdmkolbe> byorgey: with a name like monomorphism-restriction, how could it *not* have confused newbies
10:21:41 <byorgey> tombee: you can type it directly at the ghci prompt.  You can also put it in ~/.ghci, which gets read by ghci when it starts up.
10:21:56 <tombee> Ah this is my windows desktop heh :)
10:22:17 <byorgey> ah =)  well, I don't know where the .ghci file is supposed to go on Windows.
10:22:26 <byorgey> maybe someone else does.
10:22:31 <Zao> %HOMEDRIVE%%HOMEPATH%?
10:23:10 * mdmkolbe looks in the user's guide
10:23:51 <Zao> Also known as C:\Users\Zao, F:\Documents & Settings\You and so on.
10:23:57 <mdmkolbe> tombee: see http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
10:24:20 <mdmkolbe> bullet #2 is what you are looking for
10:25:07 <byorgey> hey, I didn't know you could have 'local' .ghci files!
10:25:11 * byorgey learned something new too
10:25:20 <mdmkolbe> So if you're on XP, then it is C:/Documents and Settings/tombee/Application Data/ghc/ghci.conf
10:26:01 <mdmkolbe> er I mean "\" not "/"
10:26:21 <Zao> Apparently $HOME in that doc is the root of your profile on Windows.
10:27:08 <tombee> Doesn't exist mdmkolbe
10:27:11 <tombee> Maybe I need to create it?
10:27:16 <tombee> the ghc folder that is
10:27:23 <mdmkolbe> tombee: are you on XP or Vista?
10:27:26 <tombee> XP
10:27:51 <mdmkolbe> I would go ahead and create it
10:28:09 <tromp> :t intersperse
10:28:10 <lambdabot> forall a. a -> [a] -> [a]
10:28:15 <storko> is there a way in haskell to get the beginning, the middle, and the end of a list in pattern matching?
10:28:25 <lament> no.
10:28:30 <storko> son of a bitch
10:28:33 <storko> that'd be really useful
10:28:34 <storko> to be
10:28:38 <storko> me* right now
10:28:38 <vixey> what's the middle of the list?
10:28:39 <lament> storko: not really
10:28:45 <mdmkolbe> storko: you can look at pattern views
10:28:47 <vixey> for [a,b,c,d] you maen like  a & [b,c] & d?
10:28:50 <storko> yeah
10:29:03 <storko> instead of a:b:[c,d]
10:29:17 <vixey> write a function that does it
10:29:25 <lament> it wouldn't be a pattern :)
10:29:25 <mdmkolbe> storko: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
10:29:26 <vixey> then you can patten match with it
10:29:48 <tromp> @let bcs = 0 : intersperse 0 (map succ bcs)
10:29:49 <lambdabot>  Defined.
10:29:50 <tromp> bcs
10:30:07 <Ralith> > bcs
10:30:08 <lambdabot>   [0* Exception: stack overflow
10:30:22 <lament> > take 10 bcs
10:30:25 <tromp> > head $ map succ bcs
10:30:26 <lambdabot>   1
10:30:33 <tromp> @src intersperse
10:30:34 <lambdabot> intersperse _   []     = []
10:30:34 <lambdabot> intersperse _   [x]    = [x]
10:30:34 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
10:30:37 <lambdabot>   thread killed
10:30:38 <mdmkolbe> storko: there are technical/semantic reasons ordinary patterns can't do that (i.e. pattern match is defined as the complement of construction so it can only match actual constructors), but View Patterns get around this problem to a certain exent
10:30:44 <tromp> hmm, intersperse not lazy enough
10:30:55 <tromp> need one for infinite lists
10:31:14 <Berengal> > intersperse 0 [1..]
10:31:16 <lambdabot>   [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,...
10:32:01 <Zao> > take 9 $ intersperse 0 [1..]
10:32:02 <tromp> my bcs doesn't work if intersperse looks ahead
10:32:03 <lambdabot>   [1,0,2,0,3,0,4,0,5]
10:32:26 <Berengal> tromp: it doesn't look ahead, it just can't figure out what the second element should be
10:32:36 <tromp> it shld be 1
10:32:53 <frwmanners> @let int' a (x:xs) = x : a : int' a xs
10:32:55 <lambdabot>  Defined.
10:32:55 <Berengal> But you inserted a 0 before that
10:33:04 <Berengal> So it should be zero
10:33:09 <Saizan> > let intersperse sep (x:xs) = x : sep : intersperse sep xs; bcs = 0 : interpserse 0 (map succ bcs) in bcs
10:33:10 <lambdabot>   Not in scope: `interpserse'
10:33:18 <Saizan> > let intersperse sep (x:xs) = x : sep : intersperse sep xs; bcs = 0 : intersperse 0 (map succ bcs) in bcs
10:33:19 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
10:33:21 <frwmanners> @let bcs' = 0 : int' 0 (map succ bcs')
10:33:22 <lambdabot>  Defined.
10:33:28 <frwmanners> > bcs'
10:33:29 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
10:33:40 <Saizan> frwmanners: too late :P
10:33:47 <frwmanners> Saizan: grr
10:33:54 <Saizan> Berengal: it's the [x] patter that's killing it
10:34:15 <tromp> noyes
10:34:16 <tromp> yes
10:35:08 <storko> mdmkolbe: i'm not so good at haskell, not enough to figure out which part of the page you linked me is relevant, anyway, could you narrow it down a bit?
10:35:58 <Cale> storko: The view patterns page? Well, the whole page is to some extent...
10:36:22 <Cale> storko: Basically the idea is that you could then write a function for chopping up a list however you like, and use it in a view pattern
10:36:35 <storko> I see
10:36:56 <storko> so I write a function to extract the 1..(n-1) elements of a list and use that as part of a ViewPattern?
10:37:02 <Cale> yeah
10:37:09 <mdmkolbe> storko: well, mostly the stuff towards the front.  but you are just learning Haskell you might not want to use view patterns as they are exotic/experimental in the Haskell world
10:37:16 <vixey> , let worm (x:(reverse -> z:(reverse -> ys))) = (x,ys,z) in f (worm -> (x,y,z)) = ([z]++y++[x]) in f "foobar"
10:37:17 <lunabot>  luna: parse error on input `='
10:37:20 <storko> erotic.
10:37:38 <vixey> , let worm (x:(reverse -> z:(reverse -> ys))) = (x,ys,z) ; f (worm -> (x,y,z)) = ([z]++y++[x]) in f "foobar"
10:37:40 <lunabot>  "roobaf"
10:38:11 <Cale> storko: However, you probably ought to be aware that dropping the last element of a list is an O(n) operation, so if you do it recursively you'll tend to end up with quadratic time usage.
10:38:40 <tromp> @bcs = 0 : map succ bcs >>= (:[0])
10:38:40 <lambdabot> Maybe you meant: b52s bf bid bug docs rc
10:38:46 <storko> that's a shame, is there a better solution?
10:38:51 <tromp> @let bcs = 0 : map succ bcs >>= (:[0])
10:38:52 <lambdabot>  <local>:16:0:
10:38:52 <lambdabot>      Multiple declarations of `L.bcs'
10:38:52 <lambdabot>      Declared at: <local...
10:38:54 <Cale> Well, not using lists, perhaps.
10:39:00 <mdmkolbe> storko: depends on the larger problem
10:39:05 <Cale> Data.Sequence has fast operations at both ends.
10:39:34 <storko> I'm trying to parse some string given in reverse polish notation into a custom usable expression type, the strings aren't gonna be long so I don't suppose it matters
10:39:45 <Cale> Ah, probably not then.
10:39:59 <tromp> @let bc = 0 : map succ bc >>= (:[0])
10:40:00 <lambdabot>  Defined.
10:40:06 <tromp> > take 64 bc
10:40:07 <lambdabot>   [0,0,1,0,1,0,2,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,...
10:40:16 <tromp> oops
10:40:22 <mdmkolbe> storko: have you considered useing Parsec or one of the other parser systems already built for Haskell?
10:40:45 <edwardk> centrinia: those classes (well slightly more anal retentive variants on them are in the 'monoids' package
10:40:46 <storko> it's a coursework assignment so afraid that's out of the question, I'm learning :D
10:41:19 <tromp> > let bcs = 0 : (map succ bcs >>= (:[0])) in bcs
10:41:21 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
10:41:51 <centrinia> @let exponentOf e b n = if n `mod` b == 0 then exponentOf (e+1) b (n `div` b) else e
10:41:53 <lambdabot>  Defined.
10:42:13 <centrinia> > map (exponentOf 0 2) [1..]
10:42:15 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
10:43:44 <mdmkolbe> storko: oh, in that case, even view patterns are probably beyond what the teacher intended
10:44:04 <Tobsan> @pl \f g -> getRef f >>= \r -> lift (modifySTRef r g) >> lift (readSTRef r)
10:44:05 <lambdabot> (. flip (ap . (((>>) . lift) .) . flip modifySTRef) (lift . readSTRef)) . (>>=) . getRef
10:44:06 <centrinia> > drop 15 bc
10:44:07 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,...
10:44:39 <storko> probably mdmkolbe but it wouldn't hurt to learn them, right? I can't think of another way
10:44:48 <centrinia> What is bc anyway?
10:44:59 <storko> except some ugly hack which would basically do the same thing but without the notation
10:45:05 <tromp> binary carry sequence
10:45:08 <mdmkolbe> storko: the head, tail, init and last functions may be of help.  (though they aren't pattern matches)
10:45:34 <tromp> how far carries go if u keep incrementing binary counter
10:45:51 <centrinia> > map (exponentOf 0 3) [1..] -- How does one define tcs?
10:45:52 <lambdabot>   [0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,3,0,0,1,0,0,1,0,0,2,0,...
10:45:58 <storko> yeah fair enough mdmkolbe, i'll probably do that then, cheers :)
10:46:00 <tromp> @oeis [0,1,0,2,0,1,0,3]
10:46:00 <lambdabot>  Sequence not found.
10:46:14 <tromp> @oeis 0,1,0,2,0,1,0,3
10:46:15 <lambdabot>  Exponent of highest power of 2 dividing n (the binary carry sequence).
10:46:15 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
10:47:01 <mdmkolbe> storko: usually I would do something like "foo x | length x > 3 = (a,b,c) where a = head x; b = tail (init x); c = last x"  (replace ";" with line breaks)
10:47:07 <centrinia> > let tcs = 0:0:(map succ tcs >>= (:[0,0])) in tcs
10:47:08 <lambdabot>   [0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,2,0,0,1,0,0,1,0,0,3,0,0,1,0,0,1,0,0,2,0,...
10:47:20 <centrinia> Oh, cool. :)
10:48:29 <centrinia> > let ncs b = (replicate (b-1) 0):(map succ (ncs b) >>= (: (replicate (b-1) 0) ) ) in ncs 4
10:48:30 <lambdabot>       No instances for (Enum [t], Num [t])
10:48:30 <lambdabot>        arising from a use of `ncs'...
10:48:58 <storko> mdmkolbe: what does the `foo x |` notation mean in that context?
10:49:05 <centrinia> > let ncs b = (replicate (b-1) 0)++(map succ (ncs b) >>= (: (replicate (b-1) 0) ) ) in ncs 4
10:49:07 <lambdabot>   [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,1,0,...
10:49:44 <EvilTerran> storko, that's "guards"
10:49:51 <mdmkolbe> storko: in "foo x | bar x = ..." the "| bar x" part is a pattern guard, the pattern matches only if "bar x" is true
10:50:09 <storko> cool, lemme look that up :)
10:50:14 <EvilTerran> > let foo x | even x = show x ++ " is even" | odd x = show x ++ " is odd" in map foo [1..5
10:50:15 <lambdabot>   <no location info>: parse error on input `;'
10:50:17 <EvilTerran> > let foo x | even x = show x ++ " is even" | odd x = show x ++ " is odd" in map foo [1..5] -- grr
10:50:19 <lambdabot>   ["1 is odd","2 is even","3 is odd","4 is even","5 is odd"]
10:50:45 <storko> that's pretty cool
10:51:02 <EvilTerran> ?type even
10:51:03 <lambdabot> forall a. (Integral a) => a -> Bool
10:51:27 <centrinia> > zipWith (++) (map show [0..]) (concat (repeat [" is even"," is odd"]))
10:51:28 <lambdabot>   ["0 is even","1 is odd","2 is even","3 is odd","4 is even","5 is odd","6 is...
10:52:02 <storko> this is weird, I've never known a freenode programming channel to be helpful.
10:52:33 <tombee> storko: were you expecting 'RTFM!!!!!!' ? :)
10:52:57 <Cale> #haskell is the manual
10:53:03 <Cale> ;)
10:53:30 <storko> RTFM + "I'm smarter than you and your problem is pathetic"
10:53:38 <tombee> Ah yes ofcourse :P
10:53:44 <mdmkolbe> storko: #Haskell is known for giving good answers.  Often in stereo or multi-channel (i.e. multiple answer at the same time)
10:53:52 <centrinia> @faq Can Haskell answer all your questions?
10:53:52 <lambdabot> The answer is: Yes! Haskell can do that.
10:53:59 <ziman> @quote fugues
10:53:59 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:54:01 <storko> guess that explains why there's so many people in here!
10:54:13 <tombee> @quote slipped
10:54:13 <lambdabot> No quotes match. Where did you learn to type?
10:54:16 <tombee> :(
10:54:25 <storko> oh, the bot is rude :(
10:54:25 <tombee> @quote slip
10:54:25 <lambdabot> No quotes match. Are you on drugs?
10:54:44 <dolio> @quote JonHarrop
10:54:45 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
10:54:58 <storko> haha
10:55:19 <tombee> Any galois.com guys in here? :)
10:55:23 <Nafai> riiiiiiiiiight
10:55:26 <mdmkolbe> I seriously wandered into #haskell today because I was bored and figured I'd waste some time helping newbies ;-J
10:55:38 <tombee> Aww mdmkolbe <3
10:55:40 <tombee> :P
10:56:01 <storko> the first like 6 pieces of haskell coursework on my programming course made me think it was a totally stupid useless toy language but I'm actually glad this last piece has made me rethink it
10:56:02 <n00b> halp!
10:56:13 <tombee> I'm designing a haskell program which allows me to punch people over the internet :D
10:56:18 <tombee> But I can't work out the types involved
10:56:19 <tombee> :(
10:56:24 <Nafai> storko: What was the last part, and why did it change your mind?
10:57:26 <storko> it's a calculator (albiet one that only accepts input in reverse polish notation) but it's something that seems to be quite neat
10:57:55 <Berengal> RPN calculator... Interesting
10:58:37 <storko> like "2 2 2 + +" = 6
10:58:43 <Berengal> I wonder if I can one-line one...
10:58:49 <kadaver> storko: what was the first part of the course?
10:58:58 <kadaver> storko: oh like Factor
10:59:11 <Botje> Berengal: runRPNcalculator... >:)
10:59:13 <mdmkolbe> storko: the problem may be easier if you flip the string around at the beginning with "reverse" to that you parse it in prefix form (i.e. your pattern matches may be cleaner)
10:59:17 <jeffersonheard> anybody know what this means? GtkGLExt-CRITICAL **: gtk_widget_get_gl_window: assertion `GTK_WIDGET_REALIZED (widget)' failed
10:59:17 <kadaver> is that 2 + (2+2)?
10:59:21 <n00b> does factor have a type system? seems like it would be hard
10:59:31 <mdmkolbe> kadaver: yes
10:59:31 <kadaver> 2 3 4 * - =?
10:59:41 <storko> yeah kadaver
11:00:03 <mdmkolbe> kadaver: 2 3 4 * - = 2 12 - = -10
11:00:10 * Vq^ prefer the dc(1) syntax
11:00:18 <Vq^> :o)
11:00:44 <storko> first part of the course was like... writing a program to generate a deck of cards (using enums and pairs), kadaver
11:00:55 <storko> token newbie language stuff, quite uninteresting
11:01:27 <lament> storko: why did this assignment make you rethink the usefulness of haskell?
11:02:32 <b_jonas> @hoogle (Applicative f) => f (a -> b) -> a -> f b
11:02:33 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:02:33 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:02:33 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
11:02:42 <storko> because who wants to generate a deck of cards using enums? that's dull, I wanna get busy with something that's at least kinda practical
11:03:36 <b_jonas> @hoogle (Monad f) => f (a -> b) -> a -> f b
11:03:36 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
11:03:37 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
11:03:37 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:04:32 <Vq^> storko: you got a dull assignment and think the language is to blame?
11:05:29 <jeffersonheard> hrm...  am I right in thinking all my render code should be in the onExpose handler, including oh say Gtk.glDrawableSwapBuffers
11:05:31 <jeffersonheard> ?
11:06:38 <storko> no Vq^, I got dull assignments and didn't get a chance to explore the language, so I didn't give it a second thought
11:06:41 <ziman> > let calc (x:xs) | isSpace x = calc xs | isDigit x = head $ reads (x:xs) | otherwise = let (l,ls) = calc xs; (r,rs) = calc ls; op '+' = (+); op '*' = (*) in (op x l r,rs) in fst $ calc "+3*5 9"
11:06:42 <lambdabot>   48
11:07:34 <ziman> a rather... long one-liner
11:07:40 <storko> show off
11:09:15 <centrinia> > let calc (x:xs) | isSpace x = calc xs | isDigit x = head $ reads (x:xs) | otherwise = let (l,ls) = calc xs; (r,rs) = calc ls; op '+' = (+); op '*' = (*) in (op x l r,rs) in fst $ calc "*5 11"
11:09:16 <Berengal> > head . foldl (\stack w -> let operators = zip (map (:[]) "+-*/") [(+),(-),(*),div] in if w `elem` map fst operators  then let (a:b:r)=stack; Just o=lookup w operators in o a b:r else read w:stack)[] . words $ "2 2 2 + +"
11:09:17 <lambdabot>   55
11:09:17 <lambdabot>   6
11:10:31 <Berengal> I like how we got three one-liners almost at the same time
11:10:33 <mdmkolbe> storko: now you've done it =-P.  they'll be trying to out-do each other for the next 30 minutes
11:11:06 <b_jonas> stack what?
11:11:48 <storko> ah sweet I've done it <3
11:12:11 <Berengal> b_jonas: If you're refering to my one-liner, it uses a stack...
11:13:48 <storko> if anyone's interested in seeing the code, http://haskell.pastebin.com/d4034f132 the function I just finished is `parse`, thanks muchly to mdmkolbe
11:16:27 <mdmkolbe> storko: I think this breaks on "2 2 + 2 2 + *"
11:16:49 <storko> oh yeah
11:16:50 <storko> ow
11:16:58 <storko> my pride
11:17:05 <tombee> its gone!?
11:18:04 <mdmkolbe> storko: parsing is tricky.  did the assignment say how they wanted you to parse it?
11:18:28 <mauke> preflex: calc 2 2 + 2 2 + *
11:18:29 <preflex>  8
11:18:37 <storko> ah they said to use a stack
11:18:40 <Berengal> storko: RPN is easy to evaluate once you know the trick: Use stacks, and only look at one symbol at a time
11:18:52 <storko> kinda wish I'd read that
11:19:10 <mdmkolbe> Berengal: is he supposed to parse and then eval or eval directly?
11:19:22 <storko> parse then eval
11:19:37 <Berengal> mdmkolbe: Well, parsing is just as easy.. "Is it a number? Push a number. Is it an operator? Push an operator"
11:19:50 <Berengal> Then eval the resulting stack :P
11:20:21 <mdmkolbe> storko: what Berengal is suggesting would either do away with parsing or change your Expr type to "data Expr = Op Operator | Number Rational" and your stack is a list of these Expr types
11:20:35 <b_jonas> I wrote that once
11:20:40 <b_jonas> in haskell I mean
11:21:09 <storko> where Op is ?
11:21:39 <b_jonas> storko: a constructor of a data type you define
11:21:50 <kadaver> data Op
11:21:58 <mdmkolbe> storko: "2 2 +" gets parsed into the list [Number 2, Number 2, Op Plus]
11:22:00 <kadaver> flippin crazy haskelers
11:22:00 <storko> yeah but what would it represent? atm data Expr = Expr Expr Expr Operator | Number Rational
11:22:45 <monochrom> Haha Expr Expr Expr Operator
11:22:56 <mauke> makes sense
11:22:59 <mdmkolbe> storko: Op would represent an operator pushed onto the stack
11:23:14 <storko> ah right
11:23:32 <storko> anyways i gotta go do some laundry before it closes, thanks for the help guys, will have another go later on
11:23:38 <b_jonas> there's not much point in using temporary data types though unless you want to debug the tokizer, normally you can just represent the tokens with States
11:24:04 <b_jonas> why does google not seem to index the channel logs?
11:24:07 <mdmkolbe> storko: so I guess technically the stack would be [Op Plus, Number 2, Number 2] instead of [Number 2, Number 2, Op Plus] since stacks are usually pushed on the front in haskell (since lists grow from the front)
11:24:10 <b_jonas> is that on porpoise?
11:24:38 <mdmkolbe> b_jonas: maybe a robots.txt
11:25:05 <b_jonas> mdmkolbe: yes, that's it
11:25:07 <b_jonas> but why?
11:25:45 <monochrom> To save cost at Google. :)
11:26:13 <mdmkolbe> monochrom: morelikely to save cost at the server hosting the logs
11:26:55 <ehird> is there a lib for parsing mboxes?
11:27:10 <b_jonas> what are mboxes?
11:27:51 <b_jonas> oh, mailboxes in the mbox format
11:27:52 <b_jonas> sorry
11:28:02 <ehird> yar :-)
11:28:33 <mdmkolbe> b_jonas: mutable boxed types of course ;-J
11:30:26 <centrinia> > let op "*" = (*); op "+" = (+); toInfix [] = 0; toInfix [x] = read x;  toInfix (x:xs) = (op (last xs)) (read x) (toInfix $ init xs) in toInfix . words $ "2 2 2 5 * + -"
11:30:28 <lambdabot>   * Exception: /tmp/4050897240027578329:71:56-81: Non-exhaustive patterns in ...
11:30:28 <jeffersonheard> okay, I figured the last thing out...  now I've got the odd problem of whenever I add the GLDrawingArea to a Window, the window doesn't show up
11:30:39 <jeffersonheard> if I remove it, the window shows up
11:30:39 <centrinia> > let op "-" = minus; op "*" = (*); op "+" = (+); toInfix [] = 0; toInfix [x] = read x;  toInfix (x:xs) = (op (last xs)) (read x) (toInfix $ init xs) in toInfix . words $ "2 2 2 5 * + -"
11:30:40 <lambdabot>   Not in scope: `minus'
11:30:50 <centrinia> > let op "-" = \x y -> x - y; op "*" = (*); op "+" = (+); toInfix [] = 0; toInfix [x] = read x;  toInfix (x:xs) = (op (last xs)) (read x) (toInfix $ init xs) in toInfix . words $ "2 2 2 5 * + -"
11:30:51 <lambdabot>   -10
11:34:06 <lament> :t fmap
11:34:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:34:27 <lament> @src Functor
11:34:27 <lambdabot> class  Functor f  where
11:34:28 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:34:33 <mauke> preflex: calc 2 2 2 5 * + -
11:34:33 <preflex>  1
11:35:05 <BONUS> czech this out: newtype KleisliEndo m a = KleisliEndo { appKleisliEndo :: a -> m a }
11:35:25 <BONUS> then you can do a Foldable foldM with this
11:36:23 <ehird> How can you make runghc use packages from ~/.cabal?
11:36:55 <Saizan> it uses all those listed by ghc-pkg list by default
11:37:31 <ehird> Saizan: that does not include ~/.cabal packages.
11:37:35 <ehird> How can i make it do so?
11:37:55 <mdmkolbe> ehird: if you used "cabal install" it should already be using those packages
11:38:01 <Saizan> then that means those packages are not installed for that compiler
11:38:07 <ehird> Saizan: sure they are.
11:38:09 <ehird> They work.
11:38:14 <ehird> If I build with Setup.hs, it works.
11:38:22 <ehird> But runghc doesn't see them.
11:38:24 <Saizan> ghc-pkg list should list them then
11:38:26 <SamB> what about the ones listed in ()?
11:38:36 * ehird shrug; I'm probably doing something wrong
11:39:04 <Saizan> Setup.hs asks ghc-pkg for the packages installed
11:39:16 <Saizan> so it can't find packages that ghc-pkg doesn't know about
11:39:44 <ehird> OK.
11:40:33 <Saizan> if you've multiple installations of ghc each one has its own ghc-pkg
11:40:34 <marcot> Good afternoon.
11:40:51 <marcot> Is there a way to convert Int to ByteString better than pack . show?
11:41:44 <Saizan> depends on the output format
11:41:51 <Saizan> maybe look at Data.Binary
11:43:27 <mercury^> Cale: when I want lambdabot in a certain channel, does the request go to you?
11:43:42 <Cale> mercury^: yeah
11:43:52 <mercury^> Are other networks available too?
11:44:14 <Cale> Uh, I don't think so...
11:44:17 <EvilTerran> mercury^, you could run your own copy
11:44:39 <EvilTerran> ?where lambdabot
11:44:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:44:50 <Cale> It's certainly easiest if all the channels are on this network.
11:44:51 <mercury^> EvilTerran: yes, but for complicated reasons I cannot install a haskell compiler on the system that I run this client on.
11:44:55 <mercury^> And that never goes down.
11:44:59 <tombee> [a+b | (a,b) <- xs]
11:45:03 <tombee> What does this mean? :s
11:45:16 <mercury^> Cale: well, make it join #gold on this network please.
11:45:17 <b_jonas> mercury^: could you run it on another computer?
11:45:29 <Saizan> tombee: map (\(a,b) -> a + b) xs
11:45:33 <mercury^> b_jonas: I only have ssh accounts on this one and on the uni computers.
11:45:36 <b_jonas> mercury^: note also that you can use lambdabot in private message
11:45:39 <marcot> Saizan: I mean something like Show.  Data.Binary will give me a binary, and not text, output, right?
11:45:43 <monochrom> > [a+b | (a,b) <- [a,b,c]]
11:45:44 <lambdabot>   Couldn't match expected type `Expr' against inferred type `(a, b)'
11:45:48 <mercury^> b_jonas: I know that.
11:45:56 <ray> > let xs = [(1,2),(7,7)] in [a+b | (a,b) <- xs]
11:45:57 <lambdabot>   [3,14]
11:46:05 <monochrom> Ah! Nevermind.
11:47:13 <tombee> \(a,b) -> a + b
11:47:18 <tombee> is a bit like a beta reduction?
11:47:24 <Saizan> marcot: http://hackage.haskell.org/packages/archive/bytestring-show/0.3.2/doc/html/Text-Show-ByteString.html
11:47:27 <tombee> we substitute (a,b) for a+b ?
11:47:38 <marcot> Saizan: thanks.
11:47:44 <vixey> no
11:47:47 <Saizan> tombee: it's a lambda expression
11:48:00 <vixey> (\(a,b) -> a + b) (2,4) ~> 2 + 4  is beta reductio
11:48:07 <EvilTerran> tombee, it means much the same as (let f (a,b) = a + b in f)
11:48:29 <tombee> ahhh :)
11:49:04 <EvilTerran> > map (let f (a,b) = a + b in f) [(1,2), (3,4), (5,6)]
11:49:05 <lambdabot>   [3,7,11]
11:49:17 <EvilTerran> > map (\(a,b) -> a + b) [(1,2), (3,4), (5,6)]
11:49:18 <lambdabot>   [3,7,11]
11:49:30 <EvilTerran> > [a + b | (a,b) <- [(1,2), (3,4), (5,6)]]
11:49:31 <lambdabot>   [3,7,11]
11:50:55 <kadaver_> a
11:54:45 <centrinia> > map (uncurry (+)) [(1,2),(3,4),(5,6)]
11:54:46 <lambdabot>   [3,7,11]
11:54:50 <edwardk> @hpaste
11:54:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:55:32 <edwardk> hey, i had a weird thought about how to handle unboxable functors in general http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4610#a4610
11:56:19 <edwardk> then you can just return_ 12 -- and it'll package it up into an Unboxed Maybe Int -- so on and so forth
11:57:43 <edwardk> the helpers should be small enough that they all specialize as they pack away into the dictionary anyways
11:58:03 <edwardk> so defining box and unbox should be enough to get by
11:58:15 <b_jonas> unboxed maybe int?
11:58:19 <b_jonas> qoq
11:58:42 <edwardk> a slightly more optimal version would be to handle unfolds separately for things like unboxed lists, et.c
11:58:52 <edwardk> b_jonas: its in the hpaste =)
11:59:07 <edwardk> b_jonas: basically just spewed out the idea into code form to get feedback
11:59:29 <b_jonas> oh, but that's just a maybe unboxed int, not a real unboxed maybe int
11:59:36 <b_jonas> data Unboxed Maybe Int = JustInt {-# UNPACK #-} !Int | NothingInt
12:00:03 <edwardk> b_jonas: true, i could actually make it so though in the int case =)
12:00:10 <edwardk> good thought
12:00:39 <dolio> All these adaptive unboxing containers are terrrible. :)
12:00:47 <edwardk> they are =)
12:00:57 <edwardk> i'm just having fun playing with nonsense
12:01:16 <edwardk> i figure if i try enough things, one won't suck eventually ;)
12:01:39 <dolio> I'm pretty sure it'll suck until the compiler does it automatically somehow. :)
12:01:47 <edwardk> yeah
12:01:52 <b_jonas> "adaptive unboxing container" is a funny name for a ForeignPtr
12:01:57 <edwardk> i'm pleased with the ran stuff at least
12:03:32 <edwardk>   data Unboxed Maybe Int = MaybeInt {-# UNPACK #-} !Int {-# UNPACK #-} !Int
12:03:42 <edwardk> there, now twice as evil
12:04:02 <edwardk> that actually might optimize better ;)
12:05:27 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4610#a4612
12:06:02 <edwardk> hah, even worse would be to bitpack it myself and make it a 32 bit int with a tag ;)
12:06:10 <edwardk> er 31 bit
12:06:14 <dolio> Hah. Yes!
12:07:05 <b_jonas> why spare a whole but?
12:07:13 <b_jonas> just pick one value and forbid that
12:07:14 <edwardk> hah
12:07:19 <edwardk> just one value? =)
12:07:30 <edwardk> thou shalt not store minBound or something?
12:07:45 <dolio> Make it 0. No one uses that.
12:07:50 <b_jonas> if you use 128 bit ints you can even claim it can store any value and no-one will be able to disprove you unless they peek at your source code
12:08:22 <b_jonas> (provide you use a random number like 4)
12:08:50 <edwardk> actually i always liked the way folks encoded slots in squirrelfish. they use numbers that are valid doubles, and represent using NaNs pointers and other things
12:09:22 <b_jonas> :(
12:09:45 <dolio> I'm not too clear on how GHC represents constructors. Is it just a byte?
12:09:48 <edwardk> they just choose a canonical NaN and then all the others are free
12:09:58 <Zao> dolio: Maybe the New Commentary can answer it?
12:10:01 <edwardk> dolio: its a pointer to the code that evaluates the constructor to itself
12:10:05 <dolio> I suppose some people might complain that 256 constructors per type isn't enough.
12:10:10 <edwardk> dolio: the info table sits right below it
12:10:30 <edwardk> dolio: keep in mind its not just a constructor, its anything that could construct the value, thats how the STG represents things
12:10:38 <b_jonas> yeah, I know it works in practice
12:10:53 <edwardk> basically you have a pointer with 3 or 4 bits on the bottom reserved for a 'semitag' which stores which constructor is pointed to if known
12:11:13 <edwardk> and if its not known you just jump to the pointer, and get back an evaluated environment
12:11:22 <edwardk> er thunk
12:11:26 <dolio> Right. That I know.'
12:11:58 <edwardk> but then basically a constructor is just a pointer, there is no short tag size
12:12:08 <dolio> But they have to lay out the actual data somehow, right? Maybe would have to have something like "<consrep><pointer>".
12:12:11 <edwardk> except for the tag bits in the pointer
12:12:36 <b_jonas> I'd definitely complain
12:12:41 <dolio> Unboxed Maybe Int would be like "<consrep><int#>" if you used multiple constructors.
12:12:44 <b_jonas> 256 constructors per function type is not enough
12:12:56 <edwardk> its <tag><ptr><ptr><nonptr><nonptr>... -- and the tag's infotable gives you the info about what types are stored in the slots
12:13:01 <b_jonas> or do you mean only algebraic data types?
12:13:28 <dolio> Algebraic.
12:13:32 <edwardk> dolio: yes, unfortunately that runs afoul of the fact that most of the time ghc has some difficulty specializing on different constructors, hence -fspec-constr, etc.
12:14:00 <edwardk> dolio: and the UNPACK stuff relies on the type having only one constructor
12:14:39 <dolio> Right.
12:15:21 <dolio> I was just musing about whether passing around two Int#s is actually using less space than passing around "<tag><int#>" or whatever the representation would be.
12:15:24 <edwardk> so in memory data Unboxed Maybe Int = MaybeInt !Int !Int is <MaybeIntTag><int#><int#> but it can avoid actually constructing the value more often
12:15:36 <edwardk> nah, because even with one value there is a tag
12:16:01 <edwardk> this is actually quite subtly why i prefer to use newtype Foo a = Foo (a,Int) -- rather than data Foo a = Foo a Int
12:16:07 <billls> after a bit of help getting this getAllMatches function to work if anyone would be so generous? http://foxyurl.com/1xm
12:16:20 <edwardk> because to write unFoo (Foo a Int) = (a,Int) -- the latter has to rebox the answer
12:16:31 <dolio> Right, you'll end up with MaybeInt -> MaybeInt becoming: Int# -> Int# -> (# Int#, Int# #).
12:16:35 <edwardk> while the former can just drop a newtype at zero cost
12:17:22 <edwardk> is there a Bit# like type? =)
12:17:37 <billls> it's meant to return the rows that match the phrase
12:17:40 <dolio> Not in GHC, so far as I know. Unless Bool works.
12:17:54 <dolio> I'm not really sure what happens to Bool lower down.
12:18:09 <tromp> there's no Word1
12:18:38 <tromp> or Int1, if you'd want a signed bit:(
12:18:41 <edwardk> i don't think Bool has any magic
12:18:45 <edwardk> yeah
12:18:58 <dolio> So, 0 and -1 instead of 0 and 1? :)
12:18:58 <EvilTerran> tromp, ... which could be -1 or 0? :P
12:18:59 <Berengal> billls: you say it's supposed to return the row, yet the type says it returns a Table
12:19:02 <edwardk> Int1 would have 1 < 0 = because it'd be -1 obviously since its msb is 1
12:19:13 <tromp> yes:)
12:19:21 <edwardk> i actually had to use this distinction once =)
12:19:32 <billls> Berengal: my mistake, it is meant to return a table
12:19:33 <tromp> Int 1 wldnt have a value 1
12:19:34 <b_jonas> actually bool is neither signed or unsigned
12:20:08 <Berengal> billls: Okay, so what part doesn't work (except the 'table' variable comes out of nowhere)?
12:20:09 <tromp> > toEnum 0 :: Int8
12:20:11 <lambdabot>   0
12:20:15 <b_jonas> in c99/c++ bool is mostly like an unsigned 1-bit integer, but the difference is that when you convert to a bool it's not modulo 2 as it would work with a normal unsigned types, but 0!=
12:20:16 <tromp> > toEnum 128 :: Int8
12:20:18 <lambdabot>   * Exception: Enum.toEnum{Int8}: tag (128) is outside of bounds (-128,127)
12:20:31 <EvilTerran> > (False < True, fromEnum False, fromEnum True) -- it's closer to Word1 than Int1
12:20:32 <lambdabot>   (True,0,1)
12:20:35 <b_jonas> which is cheating
12:21:14 <dolio> Even Word8 uses the same Word# internally as Word. So if Word1 were implemented the same way, you wouldn't be saving anything.
12:21:22 <dolio> In GHC, that is.
12:21:28 <edwardk> thats kinda what i figured
12:21:46 <copumpkin> zomg
12:21:51 <billls> Berengal: http://foxyurl.com/1xv sorry, added in the rest
12:22:10 <edwardk> i'm actually a huge fan of having _more_ alignment than what you need anyways. but for some reason its hard to get folks to align constructors to 16 byte boundaries so you can use SIMD operations uniformly across the heap
12:22:30 <edwardk> heya copumpkin
12:22:44 <b_jonas> alignment rocks
12:22:56 <dolio> Hey, copumpkin isn't dead.
12:22:59 <edwardk> and ghc falls into the evil camp that most RTSs do, that its only 4 byte aligned
12:23:07 <p_l> to have everything aligned on x86-64 you'd have to use 32byte alignment...
12:23:09 <copumpkin> yay, I'm not dead :)
12:23:43 <dolio> I hear you have working code to read uvector stuff from files.
12:23:46 <b_jonas> p_l: 32 byte? not just 16 byte?
12:23:51 <dolio> Gracenotes was looking for something like that yesterday.
12:23:54 <p_l> b_jonas: they added another vector unit
12:23:55 <edwardk> p_l: sse2-3 is 128 bit
12:24:04 <b_jonas> oh
12:24:06 <b_jonas> I see
12:24:08 <p_l> AVX is 256bit
12:24:11 <edwardk> p_l they have the new stuff coming for larrabee, etc which is all 256
12:24:13 <edwardk> yeah
12:24:14 <dolio> I wrote some stuff with binary, but I think I finished too late.
12:24:16 <b_jonas> but does it require such alignment too?
12:24:34 <copumpkin> dolio: yup, it's in my patch-tag fork of dons' uvector repo, it's moderately tested, but I haven't had any time recently to work on it
12:24:37 <p_l> interestingly enough, the only library I heard that uses that stuff is XML processing accelerator...
12:24:38 <Berengal> billls: It seems you're getting lost in your own types. What exactly are you trying to accomplish with this function?
12:24:38 <McManiaC> cabal: cannot configure haskell-src-exts-0.4.8. It requires base >=4
12:24:38 <McManiaC> For the dependency on base >=4 there are these packages: base-4.0.0.0 and
12:24:38 <McManiaC> base-4.1.0.0. However none of them are available.
12:24:42 <McManiaC> whats that error?
12:24:44 <b_jonas> I mean, if you use that, do you have to align the stack to 32 bytes instead of just 16 (or not access such values on the stack)?
12:25:12 <b_jonas> oh well
12:25:35 <edwardk> p_l: of course by that token you need 512 byte alignment otherwise you can't use FXSAVE!
12:25:44 <dolio> copumpkin: Does your repo have foldr for UArrs, too? I missed that when I was writing my stuff.
12:25:47 <sm> would anyone know an example of fetching a https: page in haskell, via http or curl or some other lib ?
12:25:53 <b_jonas> edwardk: we no, that does not require alignment, does it?
12:26:05 <copumpkin> dolio: I think I pushed that, let me check
12:26:11 <edwardk> b_jonas: actually that opcode requires 512 byte alignment =)
12:26:23 <edwardk> i remember from writing my interpreter
12:26:23 * b_jonas opens the manual
12:26:23 <dolio> copumpkin: I discovered that writing foldr in terms of head and tail makes it O(n^2).
12:26:43 <billls> Berengal: it's meant to take in a phrase "some words here" and check for any matches of those in 'table' then return the whole 'StringyRow' that it found the match on
12:27:01 <copumpkin> dolio: I basically just pulled the foldr on Streams from stream-fusion and made a simple streamU/unstreamU wrapper for it
12:27:16 <edwardk> hrmm guess it wasn't fxsave
12:27:16 <Berengal> billls: The problem is a phrase doesn't look like "some words here" but like ["some","words","here"]
12:27:18 <dolio> Yeah, that's all you'd need.
12:27:23 <edwardk> its another one of the amd extensions like it
12:27:34 <p_l> edwardk: AVX or FXSAVE?
12:27:35 <billls> Berengal: yeah, i'm not sure where to use unwords on it
12:27:41 <billls> how to use it, i mean
12:27:41 <Jedai> McManiaC: base4 is only available from GHC 6.10 on
12:27:48 <copumpkin> dolio: yup, it's in http://patch-tag.com/publicrepos/pumpkin-uvector/Data/Array/Vector/Strict/Basics.hs (along with the addition to Stream.hs)
12:28:02 <p_l> AVX is intel's work, afaik
12:28:10 <copumpkin> I think I was good and made it into an independent patch, so you can grab that on its own if you want
12:28:56 <dolio> Well, as it turned out, using foldr and fromU didn't work too poorly. But I think it should be in the library.
12:28:58 <McManiaC> Jedai: is this available for debian yet?
12:29:08 <copumpkin> ah
12:29:11 <b_jonas> "FXSAVE.  Saves the XMM, MMX, and x87 state. A memory location that is not aligned on a 16 byte boundary causes a general protection fault."
12:29:32 <Berengal> billls: Well, you get in a Phrase, which is a list of strings, which you then compare to a string. The simplest way is to just unwords the phrase you're getting
12:29:33 <copumpkin> yeah, I'll probably work on it some more this week so I can give dons a nice set of patches for a 0.2
12:29:41 <edwardk> b_jonas: yeah that one wasn't it, i remember tripping over something with a stupidly large alignment
12:30:01 <p_l> b_jonas: I suspect there is a new one that saves YMM registers too
12:30:07 <billls> getAllMatches ps = unwords ps (filter (\(p1,p2) -> p1 == ps) table) ?
12:30:09 <dolio> Incidentally, my Get for uvectors uses the idea I mentioned with regard to stuff like sequence about constructing an ST action that writes to a mutable array: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4585
12:30:10 <b_jonas> it says it saves 512 bytes, but doesn't require such alignment
12:30:22 <b_jonas> no wonder for I think this instruction is from 386
12:30:30 <dolio> Since you can't write to an array directly. It worked decently.
12:30:35 <edwardk> b_jonas: i clarified myself above before you got back  =)
12:30:50 <b_jonas> no it's not
12:30:58 <billls> Berengal: getAllMatches ps = unwords ps (filter (\(p1,p2) -> p1 == ps) table)  ?
12:30:59 <b_jonas> it's not from 386 I mean
12:31:05 <Berengal> billls: getAllMatches ps = let unwordedPs = unwords ps in filter (\(p1,p2) -> p1 == unwordedPs) table
12:31:07 <edwardk> its newish
12:31:18 <edwardk> i needed to use it in my jit iirc
12:31:59 <edwardk> ah, here http://comonad.com/jit++/jit++/interpreting/tracer_start.S
12:32:06 <b_jonas> of course for some things you need page or two-page alignment, but then you take care of allocating them specifically and don't just align everything to that size
12:32:09 <edwardk> but yeah this guy was only 16 byte aligned
12:32:18 <edwardk> b_jonas: sure
12:32:26 * copumpkin aligns all his data at 1KB, just in case
12:32:35 <edwardk> it was a joke that fell rather flat ;)
12:32:39 <billls> Berengal: *** Type           : Phrase -> [([Char],[[Char]])] *** Does not match : Phrase -> Table
12:33:26 <Berengal> billls: that's because table is a StringyTable (aka [([Char],[[Char]])] )
12:33:38 <edwardk> i do wish getcontext and setcontext could set everything
12:33:47 <edwardk> then that !*@#)( code there wouldn't be necessary
12:34:15 <b_jonas> ouch
12:34:36 <billls> Berengal: you're quite right, i'm very lost in my own types :(
12:34:55 <edwardk> b_jonas: it sets up enough information for an in-process interpreter to pick up executing the current thread
12:35:08 <edwardk> b_jonas: in a way that allows the interpreter to stop interpreting at any point
12:35:19 <edwardk> just figured i should provide context
12:35:26 <b_jonas> I see
12:35:50 <b_jonas> whereas when you call setcontext the compiler assumes it's an ordinary function so it can overwrite the registers
12:36:09 <b_jonas> that's actually a good thing of course for performance
12:36:20 <edwardk> well, the problem is setcontext expects to resume an ordinary function in a lot of ways
12:36:24 <Berengal> billls: If it's not too much work, I'd try to start over with some new type definitions. If you use newtype instead of type you won't have the types unhelpfully expanded into noise such as [([Char],[[Char]])], and it's also impossible to use one type where another was expected just because they happen to be synonyms for the same underlying type
12:36:32 <edwardk> so it doesn't set everything back as perfectly as i need it to
12:36:40 <b_jonas> this should go to -blah, sorry
12:36:45 <Jedai> McManiaC: IIRC ghc6.10 is now available in the latest unstable version of debian. But it is in any case pretty easy to install the binary available on GHC Homepage in /usr/local and work with that
12:36:46 <edwardk> yeah
12:36:47 <edwardk> moving
12:37:13 <Berengal> billls: The downside is you'll have to write some wrapper functions to wrap/unwrap the values of your types, but the upside is more typesafety and hopefully less confusion
12:37:36 <tombee> @src (.)
12:37:36 <lambdabot> (f . g) x = f (g x)
12:37:50 <McManiaC> Jedai: ok
12:37:57 <McManiaC> Jedai: 6.10 is stable?
12:38:32 <frwmanners> @src repeat
12:38:32 <lambdabot> repeat x = xs where xs = x : xs
12:39:31 <Jedai> McManiaC: 6.10.2 is the latest stable release of GHC (or maybe 6.10.3 now, with very minor improvements)
12:39:49 <McManiaC> ok
12:40:43 <ehird> How should I implement Num if I have no negative numbers?
12:40:47 <dolio> 6.10.3 isn't out yet, is it?
12:40:51 <dons> nope
12:41:41 <f4hy> > map ((/2) . ord) "ABC"
12:41:42 <lambdabot>       No instance for (Fractional Int)
12:41:43 <lambdabot>        arising from a use of `/' at <i...
12:41:47 <copumpkin> ehird: you're not good enough for Num, sorry :(
12:41:50 <billls> Berengal: i've realised a way around it, but can't make find function work; it needs to return the index value of every place it finds a match
12:41:52 <billls> http://foxyurl.com/1xH
12:41:55 <ehird> copumpkin: /me sniff sniff
12:41:56 <jeffersonheard> arg....
12:42:03 <ehird> copumpkin: what am I good enough for, then?
12:42:05 <ehird> I want (+) :-P
12:42:07 <copumpkin> ehird: you should probably blog about how shitty the numeric typeclasses are, and start a movement for revising them all
12:42:08 <jeffersonheard> okay, one last question, which I hope someone will please answer
12:42:24 <ehird> copumpkin: lawl
12:42:31 <copumpkin> ehird: I'm semi-serious :P
12:42:32 <ehird> I'll just add "negate _ = error "NO SRY""
12:42:37 <jeffersonheard> I'm adding a glDrawingArea to a window and it's not resizing with the window
12:42:52 <f4hy> Could someone help me understand fractional types? any time I want to divide something I get type errors
12:42:53 <jeffersonheard> Is there something I have to call to get the viewport to resize?
12:42:55 <Berengal> billls: No, your filter approach is probably better. Just get the types in order :P
12:43:11 <billls> Berengal: i'm told to use this method :(
12:43:22 <copumpkin> I love haskell, but the built-in typeclasses are an abomination :P
12:43:28 <copumpkin> many of them, anyway
12:43:48 <Twey> ehird: negate _ = undefined
12:43:56 <ehird> Twey: that's not a very helpful error message
12:43:59 <f4hy> why am I not allowed to do something simple like map ((/2) . ord) "ABC"
12:44:00 <Twey> copumpkin: There are alternative Preludes
12:44:01 <Berengal> billls: Well, first off, (!!) is the index operator
12:44:04 <ehird> besides, undefined is (error "butt")
12:44:08 <Berengal> > [1..10] !! 5 -- like this
12:44:08 <Twey> Examine
12:44:09 <lambdabot>   6
12:44:13 <Twey> Experiment
12:44:15 <Twey> Enthuse
12:44:16 <copumpkin> Twey: I've seen the numeric prelude, but it's not ideal :P
12:44:18 <Twey> Evangelise
12:44:25 <BONUS> f4hy: ord returns an Int
12:44:25 <ehird> Twey: EEEE?
12:44:33 <Twey> Plan 4E, baby.  Plan 4E.
12:44:35 <BONUS> > map ((/2) . fromIntegral . ord) "ABC"
12:44:36 <lambdabot>   [32.5,33.0,33.5]
12:44:39 <BONUS> not ideal but there you go
12:44:44 <Twey> ehird: But it's semantically nicer.
12:44:51 <ehird> True
12:45:02 <f4hy> BONUS: so any time I want to divide something I have to mess with types?
12:45:10 <ehird> what's signum again?
12:45:11 <ehird> > signum 3
12:45:12 <lambdabot>   1
12:45:13 <ehird> > signum -3
12:45:14 <lambdabot>       No instance for (Num (a -> a))
12:45:14 <ehird> > signum 0
12:45:14 <lambdabot>        arising from the literal `3' at <...
12:45:15 <lambdabot>   0
12:45:20 <ehird> > signum (-3)
12:45:22 <lambdabot>   -1
12:45:27 <copumpkin> there you go
12:45:36 <copumpkin> > signum (1 :+ 3)
12:45:37 <lambdabot>   0.31622776601683794 :+ 0.9486832980505138
12:45:50 <copumpkin> > signum (0 :+ 3)
12:45:52 <lambdabot>   0.0 :+ 1.0
12:45:56 <BONUS> f4hy: not everytime. it's just that some functions, like ord, !!, length, etc. return an Int, even though it would make more sense for them to return a more general type of Num a => a
12:46:22 <Berengal> billls: Also, your if in 'find' will never return true
12:46:31 <f4hy> BONUS: ok so Int is just smoe stupid type that doesnt let me do anything, but I can divide Num?
12:46:33 <copumpkin> > (signum (1 :+ 3))^2
12:46:35 <lambdabot>   (-0.7999999999999999) :+ 0.6
12:46:54 <BONUS> f4hy: not really. Int is a cool type, it's just, well check it out
12:46:56 <BONUS> @type (+)
12:46:58 <lambdabot> forall a. (Num a) => a -> a -> a
12:47:01 <copumpkin> > abs . signum $ 1 :+ 3
12:47:01 <heltav> bah it seems impossible to compile huge Clibs on windows, alyas something that goes wrong
12:47:02 <lambdabot>   0.9999999999999999 :+ 0.0
12:47:06 <heltav> bah it seems impossible to compile huge Clibs on windows, alyas something that goes wrong
12:47:06 <billls> Berengal: yeah, i thought found worked, and just couldn't make find work (I left it incomplete/broken)
12:47:20 <hatds> you can divide with remainder in Num
12:47:33 <BONUS> this means: if a is a number, (+) takes any number type and returns it
12:47:48 <mauke> :t quotRem
12:47:49 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:47:51 <BONUS> that could be an Int, Integer, Double, etc.
12:48:01 <BONUS> Int is part of the Num typeclass
12:48:16 <f4hy> BONUS: where is the hierarchy of number types, or a good resouce for understanding the different number types
12:48:19 <BONUS> so some prelude functions are less general than they could be
12:48:28 <Berengal> billls: I'm still somewhat confused as to what this code is supposed to do
12:48:44 <hatds> f4hy: haskell report
12:48:57 <BONUS> or this http://book.realworldhaskell.org/read/using-typeclasses.html
12:49:10 <mauke> f4hy: there's Int, Integer, Double, Rational, and Complex Double. anything else is less important :-)
12:49:29 <BONUS> basically a typeclass represents sort of like some behavior
12:49:35 <BONUS> Ord is a typeclass for things that can be ordered
12:49:40 <f4hy> What about Num and fractional (wtf is fractional)
12:49:49 <mauke> Num and Fractional are interfaces
12:49:54 <BONUS> Num is a typeclass for stuff that can act like numbers
12:50:01 <BONUS> mauke: i'd say typeclasses
12:50:05 <Cale> f4hy: Fractional is the class of numeric types for which division makes sense
12:50:18 <Cale> f4hy: Things like Rational, Float, Double...
12:50:19 <BONUS> and then you decide what your type (like Int) can act like and make it a part of the appropriate typeclasses
12:50:23 <f4hy> Cale: why does division not make sense on Int
12:50:33 <Cale> f4hy: Because 2/3 isn't an integer, for instance.
12:50:51 <Cale> f4hy: For Int, there's another operation, called div, and it works differently.
12:51:27 <Cale> > div 2 3
12:51:28 <lambdabot>   0
12:51:40 <f4hy> Cale: oh.. ic, ok so lets say I have a function that does [Char] -> [Int] but I would really rather get some type back that I can do divisions on, is there some way to change functions to do the same tihng but give me the type I need
12:51:52 <Cale> map fromIntegral
12:51:56 <mauke> :t fromIntegral
12:51:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:52:04 <Cale> Will convert the list of Int to a list of any sort of number you want
12:52:11 <hatds> I always find the 'Real' typeclass confusing - types in the Integral, Fractional, or Float will represent "most" values that the typeclass represents, but 'Real' includes integral types which aren't enough to represent "most" values
12:52:35 <f4hy> I tihnk I need to make myself a cheat sheet of all the numeric types and which ones mean what
12:52:47 <Cale> hatds: hmm
12:53:26 <Cale> hatds: I suppose it's "Real" in the sense of "Not Complex"
12:53:28 <BONUS> f4hy: eh, i dont think you need to do that
12:53:38 <BONUS> for now, you can just keep in mind the useful fromIntegral function
12:54:01 <Cale> f4hy: But it makes the mistake of requiring conversion to Rational without a possible error bound.
12:54:14 <f4hy> BONUS: ya I think that is what I will do, just have things like map (fromIntegral . whatever)
12:54:17 <Cale> So things like computable reals won't be members of the Real class!
12:54:36 <copumpkin> it's odd naming
12:55:18 <Cale> If it had just required an error bound along with the number, it would be a reasonable naming.
12:58:08 <f4hy> Hmm... I am still getting  No instance for (Fractional Int)
12:58:09 <f4hy>       arising from a use of `/' at
12:58:34 <Cale> f4hy: Make sure that the things on either side of the / are not Ints
12:58:46 <Cale> f4hy: You can apply fromIntegral to them if they are.
12:58:51 <f4hy> Cale: ahh ya I think I was only doing one side
12:59:44 <f4hy> Cale: awesome thanks
13:08:46 <deech> Hi all, are there logs of the haskell irc sessions? I need to get at a #haskell chat session from a couple of weeks ago
13:08:56 <copumpkin> yup, in the topic :)
13:14:57 <deech> copumpkin : thanks! Is there some way to search these logs for an hpaste address?
13:16:48 <copumpkin> not that I know of :/
13:17:58 <Zao> Doesn't hpastes expire rather quickly?
13:18:05 <Zao> deech: Grep?
13:34:46 <storko> any tips for testing if a string can be parsed as a number?
13:35:06 <Botje> :t reads
13:35:07 <c_wraith> examine the return value for reads
13:35:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:35:25 <Botje> if reads is [], it can't be read.
13:35:56 <vixey> we should make a #haskell quiz
13:36:03 <augustss> match of [(n,"")]
13:36:18 <b_jonas> vixey: what kind of quiz?
13:36:35 <hatds> > reads "One"
13:36:37 <lambdabot>   []
13:36:49 <vixey> > reads "8ight
13:36:50 <lambdabot>   <no location info>:
13:36:50 <lambdabot>      lexical error in string/character literal at chara...
13:37:03 <vixey> > reads "()ne"
13:37:04 <lambdabot>   [((),"ne")]
13:37:25 <storko> is their error handling in haskell?
13:37:37 <trofi> > reads "eval(1+1);"
13:37:39 <lambdabot>   []
13:37:41 <b_jonas> @faq can haskell handle errors?
13:37:41 <lambdabot> The answer is: Yes! Haskell can do that.
13:37:51 <augustss> > reads "8ight" :: [(Int,String)]
13:37:53 <lambdabot>   [(8,"ight")]
13:38:13 <trofi> @faq can haskell be as unsafe as PHP?
13:38:13 <lambdabot> The answer is: Yes! Haskell can do that.
13:38:25 <storko> @faq how do I shot web?
13:38:25 <lambdabot> The answer is: Yes! Haskell can do that.
13:38:26 <hatds> why does reads have a list of return values?
13:38:37 <augustss> It's easy!
13:38:39 <vixey> @src reads
13:38:39 <lambdabot> reads = readsPrec minPrec
13:38:48 <vixey> @src readsPrec
13:38:48 <lambdabot> Source not found. My pet ferret can type better than you!
13:38:56 <Botje> hatds: when something could potentially be parsed in two ways.
13:39:09 <Botje> but that's a silly feature, so reads only returns empty lists or singletons
13:39:10 <vixey> > reads "1:2:[]" :: [Int]
13:39:12 <lambdabot>   Couldn't match expected type `Int'
13:39:24 <augustss> hatds: because there could be alternatives ways to parse
13:39:32 <hatds>  > reads "Eleventy" :: [(Int,String)]
13:39:42 <Botje> :
13:40:04 <hatds> > reads "Eleventy" :: [(Int,String)]
13:40:05 <lambdabot>   []
13:40:09 <hatds> :(
13:40:10 <sjanssen> Botje: it isn't a silly feature, its integral to the Read class
13:40:23 <DBAlex> if I have something that returns IO String how do I convert that to String?
13:40:43 <Botje> sjanssen: are there cases where reads returns more than one element?
13:40:44 <DBAlex> return doesn't work :'(
13:40:48 <augustss> Botje: reads could very well return more than 1 alternative
13:40:49 <vixey> DBAlex: if  s :: IO String then use   s' <- s  inside the do notation
13:40:56 <vixey> DBAlex: in that case  s' :: String
13:41:13 <DBAlex> hm ok
13:41:17 <Botje> augustss: because i recall reading somewhere reads never returned more than one element in practice
13:41:38 <storko> reads seems like a really odd function
13:42:13 <augustss> Botje: I think all the Read instances in the Prelude have that property, yes.
13:42:47 <DBAlex> also
13:42:48 <augustss> storko: it's not odd at all.  It's made to be used together with other reads to parse things
13:43:05 <DBAlex> I have a case statement, but is there any way to catch something I don't match for?
13:43:22 <hatds> use underscore pattern
13:43:26 <DBAlex> ah
13:43:27 <DBAlex> yes
13:43:31 <DBAlex> forgot about that :)
13:44:07 <hatds> you need to (re)watch "A taste of Haskell" :)
13:44:57 <yitz> storko: when doing serious parsing, reads is great. for occasional use, you can easily define "maybeRead :: Read a => String -> Maybe a" based on reads.
13:45:28 <augustss> there should have been a maybeRead in the Prelude
13:45:59 <yitz> augustss: yeah. I thought it was agreed upon to add it, after a spirited discussion a while back.
13:46:24 <storko> so to test if a string is a number I could use `length (reads str :: [(Double,String)]) == 0`
13:46:48 <augustss> Yes.  But use null instead of length
13:46:59 <storko> oh cool
13:47:17 <storko> thanks augustss, Botje, c_wraith
13:47:25 <augustss> well, the null will return True when it's not a number
13:49:22 <storko> got it :)
13:50:05 <yitz> hi sjanssen
13:51:29 <Sadache> Are Haskell types and generics erased after compiling?
13:51:47 <copumpkin> generics?
13:51:59 <copumpkin> typeclasses retain a dictionary of their methods
13:52:03 <Sadache> Do Haskell types exist at runtime?
13:52:04 <copumpkin> the rest of it disappears as far as I know
13:52:13 <rolando> Why does [1 ..3] and [1..3] works, but [LT ..GT] works and [LT..GT] gives a interface error
13:52:28 <copumpkin> > [LT..GT]
13:52:29 <lambdabot>       Failed to load interface for `LT':
13:52:30 <lambdabot>        Use -v to see a list of the f...
13:52:32 <hatds> > [GT .. LT]
13:52:33 <lambdabot>   []
13:52:35 <trofi> LT looks like a module
13:52:35 <rolando> http://learnyouahaskell.com/types-and-typeclasses <-- following this page
13:52:43 <copumpkin> oh
13:52:48 <copumpkin> > [LT .. GT]
13:52:49 <lambdabot>   [LT,EQ,GT]
13:52:55 <trofi> UppercasedWithFollowingDot.
13:53:04 <copumpkin> makes sense :)
13:53:22 <rolando> [LT ..GT]
13:53:37 <rolando> > [LT ..GT]
13:53:38 <lambdabot>   [LT,EQ,GT]
13:53:40 <trofi> :t Map.insert
13:53:41 <lambdabot> Couldn't find qualified module.
13:53:51 <rolando> > [LT..GT]
13:53:52 <lambdabot>       Failed to load interface for `LT':
13:53:52 <lambdabot>        Use -v to see a list of the f...
13:53:53 <roconnor> > [minbound .. maxbound] :: [] Ordering
13:53:54 <lambdabot>   Not in scope: `minbound'Not in scope: `maxbound'
13:53:55 <trofi> :k [LT .. GT]
13:53:56 <lambdabot> parse error on input `..'
13:54:02 <roconnor> > [minBound .. maxBound] :: [] Ordering
13:54:03 <lambdabot>   [LT,EQ,GT]
13:54:03 <rolando> I just find the need for a space weird
13:54:16 <bolrod> > [LT..]
13:54:16 <trofi> 23:53:01 < trofi> LT looks like a module
13:54:17 <lambdabot>   <no location info>: parse error on input `]'
13:54:18 <roconnor> > [minBound..maxBound] :: [] Ordering
13:54:19 <lambdabot>   [LT,EQ,GT]
13:54:23 <yitz> > [LT..  GT]
13:54:24 <lambdabot>       Failed to load interface for `LT':
13:54:25 <lambdabot>        Use -v to see a list of the f...
13:54:44 <roconnor> if you use the -H98 option, I don't think you need the space.
13:54:45 <trofi> rolando: it's like you write Prelude.. Pelude.*
13:55:22 <trofi> :t (Prelude..)
13:55:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:55:30 <trofi> :t (.)
13:55:32 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:56:35 <trofi> spaces increase readability :]
13:57:12 <rolando> trofi: makes sence
13:57:16 <rolando> *sense
13:57:47 <rolando> roconnor: running ghci with the -H98 flag gives the same error
13:58:53 <roconnor> :/
13:59:11 <roconnor> it probably needs some --No-I-really-mean-H98 flag
13:59:30 <rolando> --Make-it-so?
13:59:46 <trofi> --just-fsckn-compile
14:00:06 <edwardk> trofi^w: thas usually the opposite of -H98 ;)
14:00:12 <edwardk> er thats
14:00:13 <trofi> yep :]
14:00:45 <edwardk> that used to be -fglasgow-exts -- but people wanted the silly XKitchenSink nonsense ;)
14:01:03 <edwardk> now i can't write a source file without getting carpal tunnel from the first line
14:01:03 * roconnor fears -H98 set the heap size to 98K
14:01:19 <trofi> do other compiler follow "{-# LANGUAGE " syntax?
14:01:23 <dolio> -fglasgow-exts still works.
14:01:35 <trofi> but warn (on -Wall?)
14:01:37 <rolando> edwardk: emacs?
14:01:45 <edwardk> dolio: isn't it deprecated? or was that -ffi or whatever?
14:02:01 <trofi> -fffi :]
14:02:19 <copumpkin> -ffffffuuuuu
14:02:24 <dolio> It doesn't generate any complaints when using it with ghci, at least.
14:02:33 <edwardk> rolando: nah, {-# LANGUAGE time to pay the cutting edge typing features tax #-}
14:02:44 <yitz> Warning: -fffi is deprecated: use -XForeignFunctionInterface or pragma {-# LANGUAGE ForeignFunctionInterface#-} instead
14:02:44 <dolio> But it's discouraged, of course. It's not even conceivably portable.
14:03:25 <rolando> edwardk: you lost me at "nah,"
14:03:25 <mauke> -fï¬
14:03:34 <yitz>  Warning: -fno-monomorphism-restriction is deprecated: use -XNoMonomorphismRestriction or pragma {-# LANGUAGE NoMonomorphismRestriction#-} instead
14:03:59 <edwardk> rolando: not emacs
14:04:10 <Botje> @remember edwardk {-# LANGUAGE time to pay the cutting edge typing features tax #-}
14:04:11 <lambdabot> I will never forget.
14:04:50 <edwardk> i just wish i could say {-# LANGUAGE minBound .. maxBound #-}
14:04:54 <rolando> I've read somewhere that haskell allows you to make "correct" programs. How does it do it?
14:04:58 <rolando> Pixie dust?
14:05:10 <Botje> correct
14:05:10 <edwardk> bondage
14:05:20 <byorgey> {-# LANGUAGE UseMagicPixieDust #-}
14:05:20 <trofi> it does not compile incorrect
14:05:32 <heltav> can you disassemble an exe to haskell code?
14:05:33 <vixey> rolando: You can write correct programs in any* language
14:05:44 <edwardk> heltav: no
14:05:44 <rolando> all the combined brainpower of Mensa goes into evaluating the compiled code in real-time using Folding@Home?
14:05:48 <mauke> you can't write correct programs in Java2k
14:05:58 <yitz> {-# LANGUAGE XOleg -#}
14:06:05 <heltav> how long does it take for you to compile gsl?
14:06:19 <roconnor> rolando: I'm starting to think there is no way to tell GHC to go into authentic Haskell 98 mode
14:06:25 <edwardk> bah, {-# LANGUAGE Agda #-} =)
14:06:45 <yitz> ha
14:06:51 <edwardk> that'll solve a bunch of problems, but create at least as many
14:06:57 <rolando> roconnor: it's that bad?
14:06:58 <vixey> {-# LANGUAGE NoPositivityCheck GeneralRecursion #-}
14:07:09 <vixey> import Agda.UnsafeCoerce
14:07:16 <vixey> now you're ready :p
14:07:35 <dolio> You could make a Haskell' language flag, as a synonym for all the stuff that's like to go in it.
14:07:48 <edwardk> vixey: SetInSet
14:07:50 <dolio> That'd probably get rid of some of the sillier stuff, like FlexibleContexts.
14:08:08 <yitz> dolio: they have that, it's -fglasgow-exts
14:08:09 <vixey> ahh how could I forget
14:08:22 <roconnor> rolando: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#vs-Haskell-defn  section 13.1.1.1
14:08:51 <dolio> yitz: -fglasgow-exts isn't portable, which is why LANGUAGE stuff was introduced in the first place.
14:08:56 <edwardk> FlexibleContexts is annoying because i need it in virtually every source file i even look at
14:09:27 <yitz> dolio: true. but neither is Haskell' right now - ghc only.
14:09:28 <dolio> Is everything in glasgow-exts likely to be in haskell' too? I can't remember what all it turns on.
14:09:41 <edwardk> and i love the inconsistent use of abbreviations. MultiParamTypeClasses -- you have to remenber whats abbreviated
14:10:07 <MyCatVerbs> dolio: AIUI not everything in glasgow-exts, but just about everything that's implemented in Hugs, GHC and NHC too.
14:10:28 <dolio> NHC? I thought that stuck pretty close to 98.
14:10:45 <yitz> edwardk: it's easy: if you get bored while typing, that's the place it's abbreviated.
14:10:47 <edwardk> dolio: then that shoul tell you they aren't likely to rock the boat ;)
14:10:56 <vixey> typeclasses are too complex, lets get rid of them
14:11:00 <yitz> except Monomonomonomonomorphism
14:11:16 <dolio> But it would preclude lots of stuff from Haskell'.
14:11:22 <edwardk> yitz: bah, as long as its not where simon marlow gets bored typing then you get TcTyVars, etc =)
14:11:58 <yitz> edwardk: hmm, right. so you have to make believe you're JaffaCake.
14:12:22 <dolio> Wow, glasgow-exts enables type families.
14:12:42 <roconnor> bah Tuples are currently limited to size 100 in GHC
14:12:48 <roconnor> what a crappy compiler
14:12:52 <edwardk> roconnor: slackers
14:12:52 <trofi> only 100?
14:13:12 <edwardk> otoh, most interesting instances for them stop at random points between 3 and 10
14:13:12 <yitz> didn't it used to be twenty-something?
14:13:22 <dancor_> type Dalmations = ...      ???!!!
14:13:25 <roconnor> yitz: intances are also limited to 16!!
14:13:35 <MyCatVerbs> dolio: oh, I was just guessing about NHC. And glasgow-exts enables absolutely everything that doesn't completely break the language, IIRC. Just about the only things that aren't in -fglasgow-exts are overlapping and incoherent instances.
14:13:42 <yitz> roconnor: 16 what?
14:13:53 <roconnor> yitz: 16-tuples
14:14:01 <yitz> oh
14:14:15 <roconnor> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
14:14:16 <lambdabot>       No instance for (Eq
14:14:16 <lambdabot>                         (t,
14:14:16 <lambdabot>                        ...
14:14:18 <mauke> > ( 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 )
14:14:19 <lambdabot>       No instance for (Show
14:14:20 <lambdabot>                         (t,
14:14:20 <lambdabot>                      ...
14:14:22 <mauke> > ( 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 )
14:14:24 <lambdabot>   (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
14:14:27 <heltav> how long does it take for you to compile gsl?
14:14:28 <copumpkin> nice
14:14:32 <yitz> maybe I'm thinking of how many zipNs and such there are in the Prelude.
14:14:38 <yitz> or Data.List rather
14:14:44 <dolio> Heh, it enables UnicodeSyntax. That shouldn't even be an extension. :)
14:15:06 <vixey> maybe we just define
14:15:29 <roconnor> > const () (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100)
14:15:30 <lambdabot>       A 100-tuple is too large for GHC
14:15:30 <lambdabot>        (max size is 62)
14:15:30 <lambdabot>        Workaro...
14:15:38 <copumpkin> hah
14:16:10 <vixey> > const () (1,2,3,4,5,6,7,8,9,(10,11,12,13,14,15,16,(17,18,19,20,21,22,23,24,25,(26,27,28,29,30,31,(32,33,34,35,36,37,38,39,40,41,(42,43,44,45,46,47,48,49,50,51,(52,53,54,55,56,57,58,59,60,61,(62,63,64,65,66,67,68,69,70,71,72,73,74,(75,76,77,78,79,80,81,82,(83,84,85,86,87,88,89,90,91,92,(93,94,95,96,97,98,99,100)))))))))))
14:16:11 <lambdabot>   ()
14:16:16 <MyCatVerbs> heltav: not long. I have a games project that uses Cg via Ogre for shaders for terrain drawing and lighting and stuff, it compiles the shaders on the fly every time it boots. I couldn't tell you exactly how long it takes, but I am absolutely certain that it is under a tenth of a second on a P4.
14:16:17 <bulletproofzx2> any one familiar with sql & php
14:16:19 <vixey> any sane person would do it this way
14:16:24 <dolio> @type const () (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:16:25 <lambdabot> ()
14:16:34 <dolio> > const () (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:16:35 <lambdabot>   mueval: Prelude.read: no parse
14:16:36 <lambdabot>  mueval: GhcException
14:16:36 <lambdabot>  During interactive l...
14:16:48 <bulletproofzx2> Any one familiar with php??SQL??
14:16:57 <mauke> bulletproofzx2: how is that a haskell question?
14:17:02 <copumpkin> bulletproofzx2: yes, but that's not really relevant to this channel :P
14:17:05 <vixey> bulletproofzx2: use less '?'s
14:17:11 <rieux_> bulletproofzx2: i try to forget.
14:17:15 <copumpkin> *fewer ;)
14:17:26 <mauke> use fewer lesses
14:17:33 <copumpkin> use less fewers
14:18:03 <MyCatVerbs> Spawn more Overlords.
14:18:08 <bulletproofzx2> i HAVE TO DO A SEARCH BAR ACCESSING DATABASE. I GET ERRORS ANYONE LIKE TO CHECK MY CODE??
14:18:12 <yitz> @vixen have you been spiking the drinks again?
14:18:12 <lambdabot> good question
14:18:25 <c_wraith> I'm going to go with spawning more overlords
14:18:32 <copumpkin> bulletproofzx2: do you only read things written to you if they're answers to your questions?
14:18:39 <bulletproofzx2> IT IS JUST 36 LINES
14:18:39 <MyCatVerbs> c_wraith: \o/ for the swarm!
14:18:44 <Botje> bulletproofzx2: one and one equals two. most of the time.
14:19:01 <MyCatVerbs> bulletproofzx2: not particularly, no.
14:19:21 <MyCatVerbs> bulletproofzx2: you might get better results without the capslock, and by asking people if they could *please* check your code, however.
14:19:25 <QtPlaty[HireMe]> bulletproofzx2: The key to the left of your 'a' key is your capslock key.  Hit it.
14:19:37 <mauke> OH THANKS THIS IS MUCH EASIER
14:19:41 <copumpkin> LOL
14:19:43 <Berengal> What if he's using shift?
14:19:54 <Botje> the key to the left of my a key is tab
14:19:58 <MyCatVerbs> Berengal: then he'll keep using shift, and it won't be a problem.
14:20:02 <bulletproofzx2> BIG HELP!
14:20:10 <QtPlaty[HireMe]> Berengal: Then his pinky finger will no longer be strained.
14:20:10 <copumpkin> troll?
14:20:12 <MyCatVerbs> Botje is french?
14:20:22 <c_wraith> I liked sun keyboards.  they put ctrl next to a
14:20:24 <bulletproofzx2> iF YU DONT FEEL LIKE JUST DO NOT LIKE STUPID SHIT..
14:20:25 <trofi> @hpaste
14:20:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:20:30 <MyCatVerbs> c_wraith: I have one. It rules. <3
14:20:42 <roconnor> someone just ban bulletproofzx2 and put him out of his misery
14:20:45 <Botje> MyCatVerbs: my keyboard is :o)
14:20:46 --- mode: ChanServ set +o mauke
14:20:47 <copumpkin> bulletproofzx2: GMU?
14:20:49 <QtPlaty[HireMe]> c_wraith: I've modified my keyboard map so its sun style.
14:21:07 <roconnor> mauke++
14:21:13 <copumpkin> lol
14:21:15 <trofi> :]
14:21:21 <bulletproofzx2> i STILL HERE . NOT VOLUNTARIES..
14:21:23 <MyCatVerbs> Botje: why're you using an AZERTY, if you're not?
14:21:24 --- mode: mauke set +b *!*@129.174.73.75
14:21:26 <trofi> #php -> there
14:21:50 <Botje> MyCatVerbs: there are $smallnum countries that have azerty keyboards by default and mine (belgium) is one of them
14:22:01 <cypher-> azerty :S
14:22:28 --- mode: ChanServ set +o monochrom
14:22:29 <MyCatVerbs> Botje: oh my swutting Belgium. :)
14:22:32 <Botje> azerty keyboards have one advantage: lisp is _very_ easy >:)
14:22:37 --- mode: monochrom set -o monochrom
14:22:42 <opqdonut> how come
14:22:43 <MyCatVerbs> Unshifted parentheses?
14:22:47 <Botje> (on account of not needing to do shift-9 or shift-0 for parentheses)
14:22:52 <cypher-> Botje: hardly an advantage
14:23:02 <Botje> of course any decent editor accepts [] as well
14:23:03 <Botje> BUT STILL!
14:23:09 * cypher- likes jp106 with unshifted @
14:23:24 --- mode: mauke set -o mauke
14:24:23 <MyCatVerbs> Botje: looking it up, ) is to the right of 0 and ( is on the 5 key?
14:24:42 <trofi> @pl \(a,b) -> a < b
14:24:42 <lambdabot> uncurry (<)
14:24:46 <MyCatVerbs> Botje: you have to hit altgr in order to get numbers off the top row?
14:25:18 <Botje> MyCatVerbs: just shift
14:25:41 <MyCatVerbs> Ah, right. And altgr-) is ]?
14:25:53 <Botje> \, apparently
14:26:01 <Botje> ] is altgr-$
14:26:03 <lunabot>  luna: Not in scope: `is'
14:26:14 <Botje> @ and # are altgr-2 and -3
14:26:20 <Botje> | is altgr-1
14:26:28 <Botje> and â¬ is altgr-e :)
14:26:42 <MyCatVerbs> Botje: hrmn. I'm looking at a diagram on wikipedia, and it seems that either it is very incorrect or there are multiple versions.
14:27:12 <Botje> ah, yes
14:27:16 <Botje> i have a belgian azerty
14:27:24 <Botje> http://en.wikipedia.org/wiki/File:Belgian_pc_keyboard.svg
14:27:27 <Botje> this one
14:27:37 <Botje> sorry for the confusion :)
14:28:14 <MyCatVerbs> No trouble, just bewilderment. :)
14:29:35 <Twey> Hm
14:29:41 <Twey> Botje, where's Ã´?
14:29:52 <Botje> hit ^ first, then type o
14:30:15 <Twey> Oh, deadkey
14:30:22 <Twey> Oh, right, that's what the red means
14:30:41 <Twey> It seems set up for French
14:30:48 <storko> can you do like `else` with  haskell guards?
14:31:00 <Twey> storko: It's called âotherwiseâ
14:31:03 <Twey> (or True)
14:31:09 <storko> oh yeah of course
14:31:10 <storko> cheers
14:31:19 <Twey> No problem
14:31:23 <railk> hey. a lot of cabal packages seem to depend on base>=4.0, but i'm stuck on ubuntu with base-3.0.1.0. is there an upgrade guide somewhere? `cabal install base` doesn't work, just tells me it's "impossible"
14:32:11 <Berengal> railk: Get the binary from haskell.org
14:32:41 <heltav> how much work is a dekstop environment? i mean can you make something simple by yourself tha tis sufficient? is it just a GUI like a GUI written in gtk+?
14:32:44 <Berengal> railk: Installation isn't hard, but you might want to remove the old installation first
14:32:48 <yitz> railk: base 4 is for ghc >= 6.10
14:33:14 <Berengal> Oh, yes, get GHC 6.10 from haskell.org was what I meant :)
14:33:21 <Twey> Oh, otherwise actually is defined as True
14:33:29 <Twey> For some reason I thought it was magic
14:33:32 <storko> nice that :)
14:33:50 <Twey> Yeah
14:34:14 <cypher-> heltav: not sure if I understand what you mean - desktop environment is a lot of work
14:34:36 <cypher-> heltav: but a simple window manager is managable
14:34:43 <cypher-> heltav: see monad for instance
14:34:46 <Twey> xmonad is <500 LoC for example
14:34:47 <yitz> storko: ghc is smart enough to optimize away the last test when you use otherwise.
14:34:59 <Twey> A DE is a full suite of desktop applications
14:35:03 <Twey> (like KDE)
14:35:06 <railk> Berengal: do you know whether taking ubuntu-unstable's ghc package works? it's version is 6.10.1+dfsg1-13~karmic1~ppa1
14:35:35 <Berengal> railk: No, I haven't tried that. I'm betting it works fine though
14:36:04 <Twey> That's one scary version string
14:36:15 <railk> wonderful... "Queued: 9 hours ago; Estimated build start: in 3 hours"
14:36:27 * Twey doesn't even want to guess what +dfsg1-13~karmic1~ppa1 means
14:36:47 <Berengal> I believe karmic is 9.10
14:36:49 <heltav> XMonad you mean
14:36:57 <yitz> dfsg = debian free software guidelines, i think
14:37:01 <Berengal> (but that should be obivous)
14:37:10 <Twey> Hmnhmn
14:37:21 <railk> Berengal: it is indeed 9.10, dfsg is probably the packager's name, and ppa means it's his personal package archive
14:37:40 <Twey> Codenames instead of versions are annoying and confusing
14:37:49 <railk> and it is totally fresh into karmic. there's no older 6.10 package, that one's the first to enter
14:38:07 <yitz> no, it looks like the package originated in debian, dfsg is standard there
14:38:09 <railk> ... i sound like a hippy, "tottally fresh", "karmic"...
14:38:10 <Zao> Isn't dfsg this? http://www.debian.org/social_contract.html#guidelines
14:38:17 <Igloo> dfsg is almost certainly Debian Free Software Guidelines, i.e. non-free bitsd removed
14:38:22 <Twey> railk: Hehe
14:38:54 <heltav> hmm, im really looking for a big haskell project. are all the package manages for windows good?
14:39:04 <storko> hint: the non-free ones are all '0'
14:39:13 <heltav> rewrite archs perhaps? how many LOC is that you think?
14:39:39 <Twey> Windows doesn't have a package manager
14:39:49 <Twey> At least, not one worthy of the name
14:39:52 <railk> Twey: it does. it just sucks
14:40:26 <Berengal> A web-browser doesn't count as a PM
14:40:45 <storko> how come when I do `let a=[]; a=4:a` a becomes an infinite list of 4s
14:41:04 <Botje> let is not assignment
14:41:08 <storko> ah
14:41:10 <storko> ok
14:41:19 <Botje> the a=[] is basically ignored
14:41:46 <Berengal> storko: When it evaluates 'a' it sees "4:a", so it returns '4:' then goes on to evaluate a and sees "4:a" so it returns '4:' then goes on to evaluate a...
14:41:59 <storko> i see
14:42:07 <storko> probably should have known that
14:42:10 <heltav> but is there any want for a windows package manager?
14:42:27 <heltav> the people who want one are all on linux already?
14:42:31 <Berengal> heltav: How would a windows package manager work?
14:42:41 <Berengal> What packages would it include?
14:42:53 <Botje> heltav: if you can get all software vendors to agree on your package management system, you'll make MILLIONS!
14:42:55 <heltav> dont know wasnt my indeed
14:42:59 <heltav> my idea
14:43:00 <asdf25> hi, i'm trying to make a cabal package for the first time, it just has one module, but i want to split the module into multiple files for editing convenience, can I do that? where do i specify the files other than the one that has the main function?
14:43:14 <Botje> because installation is one thing, but automatic updates are truly a mess on windows
14:43:21 <Zao> asdf25: Imports are resolved automagically.
14:43:31 <glguy> asdf25, You can have one module that reexports the other modules
14:43:48 <glguy> and split your code out into other modules
14:44:01 <railk> heltav: look at the wpkg homepage, 4th paragraph. theres a list of all the *popular* package management systems
14:44:22 <glguy> asdf25, Control.Concurrent is an example of this that comes to mind
14:44:23 <railk> "It can install MSI, InstallShield, PackagefortheWeb, Inno Setup, Nullsoft, other software installers or .exe packages, .bat and .cmd scripts and similar"
14:44:30 <asdf25> imports? can't only modules be imported though, not files? so i have to give each file a different module?
14:46:43 <Twey> asdf25: You make the files different modules, then import the symbols into your main module and reÃ«xport them
14:46:51 <asdf25> ok thanks
14:51:55 <storko> anyone got any hints for using the ghci debugger? When stopping at breakpoints some of my variables are printing out as _, it'd be kinda useful to see the whole value
14:52:22 <adamvo> storko: you can force them somehow
14:52:56 <Botje> if you print them they are forced
14:53:08 <Botje> or you can do :force :)
15:17:15 <copumpkin> the awodey book is quite attractive
15:18:17 <saml> data Foo = Foo; data Bar = Bar;  can I have a list of Foo's and Bar's??   [Foo, Bar]
15:18:23 <mauke> no
15:18:25 <saml> using rankn type?
15:18:37 <roconnor> [Either Foo Bar]
15:18:40 <copumpkin> you could make a wrapper
15:18:53 <copumpkin> but without a typeclass on Foo and Bar, it wouldn't too useful
15:19:04 <roconnor> [Either Foo Bar]
15:19:25 <saml> class FooBar a where ..   instace FooBar Foo .. instance FooBar Bar.. can i now?
15:19:34 <saml> i tried but i can't
15:19:48 <roconnor> [Either Foo Bar]
15:19:50 <mauke> data Wrapper = forall a. W a
15:19:54 <copumpkin> saml: yeah, using an existential wrapper, but an Either is probably nicer, as roconnor keeps saying :P
15:19:55 <saml> so i was wondering if forall trick would do
15:19:56 <mauke> [ W Foo, W Bar ]
15:20:07 <roconnor> :)
15:20:32 <saml> ah thanks
15:20:34 <vixey> use {-# LANGUAGE DontTypecheck #-}
15:20:47 <copumpkin> lol
15:20:54 <mauke> {-# OPTIONS -fignore-errors #-}
15:21:01 <virus> I'm trying to figure out patterns in haskell. Is there also a 'default' available. e.g. "f x | x==42 = 1 | default = 0" -- i know this one does not work. It's just to show what I'm looking for.
15:21:11 <mauke> virus: yeah, it's called True
15:21:17 <roconnor> | otherwise = 0
15:21:20 <roconnor> > otherwise
15:21:21 <lambdabot>   True
15:21:24 <mauke> @src otherwise
15:21:24 <lambdabot> otherwise = True
15:21:42 <saml> virus,    f 42 = 2; f _ = 0
15:22:03 <kadaver_> could STM be used to parallellize decoding?
15:22:15 <copumpkin> decoding of what?
15:22:22 <kadaver_> music video
15:22:28 <kadaver_> music an video
15:22:40 <virus> saml: it's not as simple in my case as I'm calling a function to check several condition - but thanks anyways.
15:22:49 <copumpkin> kadaver: usually compressed video relies on earlier temporal information
15:22:59 <virus> And regarding "otherwise" ... that helped. I have been thinking about "True", too, but that just looked weird. ;)
15:23:10 <copumpkin> kadaver_: but there are often "check points" in the video that give you a fresh starting point, so maybe
15:23:38 <copumpkin> kadaver_: not sure how STM would add much though
15:31:23 <billls> Can anyone point out my mistake in find? http://foxyurl.com/1zS  found works thus found "na" "bananas" 2 returns True, find has to return a list of all the index values where found returns True - i.e. find "na" "bananas" returns [2,4]
15:31:55 <billls> mistakes*
15:35:09 <Botje> what is it returning now?
15:36:39 <billls> *** Expression     : found l s [s]
15:36:40 <billls> *** Term           : [s]
15:36:40 <billls> *** Type           : [[a]]
15:36:40 <billls> *** Does not match : Int
15:36:48 <billls> find l s = filter [x | x <- [s], found l s [s]]
15:36:51 <Botje> uh
15:36:59 <Botje> your code doesn't even compile here
15:37:15 <Botje> the [a] on your last line should be [s], i guess?
15:37:22 <billls> yeah, just realised that
15:37:29 <billls> the error is from the [a]s changed to [s]
15:37:37 <Botje> and it's quite correct
15:37:40 <virus> why can't I define: isNotSpace c = not isSpace(c) -- it gives me the error: Couldn't match expected type `Bool' against inferred type `Char -> Bool'
15:37:50 <Botje> found wants an int as last argument
15:37:53 <mauke> virus: because 'not' takes one argument, not two
15:37:53 <copumpkin> you're using () like in c
15:37:56 <Botje> and you're giving it a list of a's
15:38:05 <copumpkin> virus: try not . isSpace $ c
15:38:13 <int-e> virus: or  not (isSpace c)
15:38:17 <virus> aaah... damn me. it should be (isSpace c)
15:38:21 <Botje> billls: the last argument to found should be an offset
15:38:40 <billls> s-1 ?
15:39:04 <Botje> so x should range from 0 to the last possible index in s (which is (length s) - 1)
15:39:16 <Botje> also, the filter is wrong
15:39:21 <Botje> you should have something of the form:
15:39:43 <Botje> find l s = [ offset | offset <- [ lower .. upper ], found l s offset ]
15:41:11 <billls> more like this find l s = filter [x | x <- [0..((length s)-1)], found l s (length s)-1 ?
15:41:41 <Axman6> ((length s) -1) == length s - 1
15:41:51 <Botje> but then you're not using the x anywhere.
15:42:06 <Botje> and the filter shouldn't be there either.
15:42:57 <kerlo> > (- 1)
15:42:59 <lambdabot>   -1
15:43:04 <kerlo> Fun.
15:43:26 <mauke> > (subtract 1) 5
15:43:27 <lambdabot>   4
15:44:22 <kerlo> Do what Texas Instruments calculators do: use separate characters for "negative" and "minus".
15:44:37 <mauke> preflex: calc _1
15:44:38 <preflex>  -1
15:44:48 <Botje> billls: so what your last code says is: "let x be a number from 0 to (length s - 1), and return all x such that 'found l s (length s - 1)' is true"
15:46:00 <billls> yeah.. which is what I want.. I think ;\
15:46:15 <Botje> note the condition doesn't involve x
15:46:33 <copumpkin> - and â ;)
15:46:40 <kerlo> I think the "minus" character is slightly longer and lower.
15:46:41 <copumpkin> make it nice and easy to distinguish
15:46:50 <Botje> so if "found l s (length s - 1)" is true, your function will return all offsets
15:46:54 <kerlo> So you could use underscore for minus and hyphen for negative.
15:47:26 <mauke> preflex: calc _2 _5 -
15:47:27 <preflex>  -3
15:47:29 <copumpkin> is the ~ symbol in constraints used for associated types to specify equality?
15:48:00 <thoughtpolice> copumpkin: yeah
15:48:11 <thoughtpolice> e.g. (Foo a) ~ Int or whatever
15:48:18 <tiglionabbit> can I create a namespace that is not associated with a file?
15:48:43 <kerlo> Another cute thing for either would be the Han character for "one".
15:48:59 <copumpkin> ä¸
15:49:06 <copumpkin> that'd be an awfully long minus sign
15:49:10 <billls> i'm trying to acheive filter p xs = [x | x <- xs, p x]
15:49:13 <ehird> Golf contest: shorten       main=print.product.map(sum.map ord).words=<<getContents
15:49:14 <copumpkin> > ä¸1
15:49:15 <lambdabot>   <no location info>: lexical error at character '\19968'
15:49:32 <mauke> U+2012 (e2 80 92): FIGURE DASH [â]; U+2013 (e2 80 93): EN DASH [â]; U+2014 (e2 80 94): EM DASH [â]; U+2015 (e2 80 95): HORIZONTAL BAR [â]; U+2053 (e2 81 93): SWUNG DASH [â]
15:49:55 <kerlo> I like the idea of using EM DASH and EN DASH.
15:50:29 <Botje> billls: yes, x is used both to generate elements (x <- xs) and restrict the elements that are returned (p x)
15:50:40 <ehird> :-)
15:50:42 <Botje> you want something similar, so your filter clause should at least include a reference to x
15:51:56 <billls> Botje: --find l s = filter [x | x <- [0..((length s)-1)], (found l s ((length s)-1) == True) x - better? or very wrong?
15:52:11 <mauke> '== True' can't be right
15:52:20 <Axman6> the == Tree is totally redundant
15:52:23 <Axman6> True even
15:52:42 <Botje> find l s = [x | x <- [0 .. length s - 1], found l s x]
15:52:42 <billls> i thought the predicate would be that found returned True ?
15:52:51 <Botje> no need for the filter *sigh*
15:52:55 <copumpkin> > True == True
15:52:57 <lambdabot>   True
15:53:00 <copumpkin> > (True == True) == True
15:53:01 <lambdabot>   True
15:53:11 <leimy> > [1,2..]
15:53:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:53:13 <Botje> > undefined == True -- hah!
15:53:14 <lambdabot>   * Exception: Prelude.undefined
15:53:19 <mauke> > iterate (== True) True
15:53:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
15:53:30 <Axman6> billls: found it a predicate
15:53:35 <Botje> SPJ should sneak a false in there somewhere :)
15:53:36 <Berengal> > all (iterate (== True) True)
15:53:37 <lambdabot>   Couldn't match expected type `a -> Bool'
15:53:59 <mauke> @check \x -> x == (x == True)
15:54:00 <Botje> right, time for bed
15:54:00 <lambdabot>   "OK, passed 500 tests."
15:54:07 <billls> I see. forgot the whole true unless false thing
15:54:10 <billls> thanks
15:54:16 <Botje> what?
15:54:24 <Botje> in haskell, only True is true
15:54:28 <mauke> this isn't perl
15:54:29 <Botje> and only False is false
15:54:36 <Botje> everything else is a type error
15:54:36 <Axman6> @src Bool
15:54:36 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:55:05 <leimy> > zipWith (+) (drop 1 [1,2..]) [1,2..]
15:55:07 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
15:55:41 <Berengal> > [3,5..] -- ;)
15:55:43 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
15:56:59 <ehird> @pl \f->map(map f)
15:56:59 <lambdabot> map . map
15:57:10 <c_wraith> Ord?  Why does Bool derive Ord?
15:57:19 <mauke> so you can compare it
15:57:21 <Botje> so you can sort a [Bool] ? :)
15:57:32 <leimy> > [0,2..]
15:57:34 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:57:34 <copumpkin> > [minBound..maxBound] :: [Bool]
15:57:36 <lambdabot>   [False,True]
15:57:48 <leimy> > [1,3..]
15:57:49 <c_wraith> That's just strange.
15:57:50 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:57:54 <mauke> not = (< True)
15:57:56 <copumpkin> > [minBound..maxBound] :: [()]
15:57:58 <lambdabot>   [()]
15:58:03 <copumpkin> that one's even stranger
15:58:16 <leimy> > [minBound..maxBound] :: [Integer]
15:58:18 <lambdabot>       No instance for (Bounded Integer)
15:58:18 <lambdabot>        arising from a use of `minBoun...
15:58:19 <c_wraith> Hmm.
15:58:19 <copumpkin> > [minBound..maxBound] :: [1]
15:58:21 <lambdabot>       No instance for (Show Unit)
15:58:21 <lambdabot>        arising from a use of `show' at <int...
15:58:22 <leimy> woot!
15:58:24 <c_wraith> @instances Ix
15:58:25 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:58:35 <leimy> @instances Bounded
15:58:36 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
15:58:37 <copumpkin> > Unit
15:58:39 <lambdabot>       No instance for (Show Unit)
15:58:39 <lambdabot>        arising from a use of `show' at <int...
15:58:51 <leimy> no one wants to see you show your unit
15:58:52 <keseldud1> > [minBound..maxBound] :: [Word8]
15:58:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:58:54 <copumpkin> lol
15:59:16 <mauke> > [minBound..maxBound] :: String
15:59:18 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:59:57 <jinho326> hey guys, am I right in saying that the expression:   let a' = a + (ord x .&. 0xff)   is merely assigning to a' the hex equivalent of the Char "a" ?
16:00:52 <mmorrow> where is the x from?
16:00:59 <Axman6> is that a supposed to... huh?
16:01:13 <jinho326> sorry, "x" is an element from a list xs
16:01:24 <jinho326> this is just a code snippet
16:01:46 <copumpkin> > [minBound..maxBound] :: [String]
16:01:47 <adamvo> > map chr [0..255]
16:01:48 <lambdabot>       No instance for (Enum String)
16:01:48 <lambdabot>        arising from the arithmetic sequen...
16:01:49 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
16:01:50 <copumpkin> boo
16:02:10 <adamvo> > map chr [40..70]
16:02:12 <lambdabot>   "()*+,-./0123456789:;<=>?@ABCDEF"
16:02:14 <c_wraith> @quickcheck \a -> fix (const a) == a
16:02:14 <lambdabot> Unknown command, try @list
16:02:20 <Axman6> > [minBound..maxBound] :: String
16:02:22 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
16:02:26 <c_wraith> @check \a -> fix (const a) == a
16:02:26 <copumpkin> I thought [] a had an Enum instance for Enum a
16:02:28 <lambdabot>   "OK, passed 500 tests."
16:02:29 <mmorrow> , fmap (chr . (ord 'a' +)) [0..4]
16:02:32 <lunabot>  "abcde"
16:02:47 <Axman6> @instances Enum
16:02:48 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
16:02:54 <mmorrow> , ord 'a' .&. 0xff
16:02:55 <lunabot>  97
16:03:03 <mmorrow> , showHex (ord 'a' .&. 0xff) []
16:03:04 <lunabot>  "61"
16:03:19 <mmorrow> , showHex (ord 'a') []
16:03:20 <lunabot>  "61"
16:03:29 <copumpkin> data Unit = Unit
16:03:32 <copumpkin> that's pretty exciting
16:03:36 <jinho326> so i guess that's a yes?
16:03:38 <copumpkin> @index Unit
16:03:38 <lambdabot> bzzt
16:03:46 <mmorrow> jinho326: i guess
16:03:50 <jinho326> gracias
16:04:02 <mmorrow> (but .&. 0xff seems kindof redundant)
16:04:09 <copumpkin> why? it's unicode
16:04:32 <jinho326> I mean, I'm reading someone else's code right now, and that's what they put
16:04:37 <mmorrow> it's like (*1) (if the num is < 256 and unsigned)
16:04:47 <mmorrow> jinho326: it seems redundant :)
16:04:58 <jinho326> mmorrow: gotcha, I'll keep that in mind
16:04:59 <jinho326> =)
16:05:21 <QtPlaty[HireMe]> hoogle: (a -> [b]) -> [a] -> [b]
16:05:40 <Saizan> concatMap
16:06:58 <c_wraith> Saizan, you're not a bot.  that was confusing. :)
16:07:31 <virus> is it possible to call a function with a tuple as arguments. e.g. I have the tuple (1, 2) and want the function (f 1 2) to be called. I could write a lambda expression for that, but I guess there is something simpler, is there?
16:07:34 <Saizan> passing the turing test: done.
16:07:49 <c_wraith> :t uncurry
16:07:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:07:52 <mauke> virus: curry
16:08:03 <mauke> er. uncurry
16:08:04 <c_wraith> I can never remember which one of those goes which direction
16:08:10 <c_wraith> :t curry
16:08:12 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:08:14 <mmorrow> , uncurry (flip (,)) (42,"zomg")
16:08:15 <lunabot>  ("zomg",42)
16:08:53 <skorpan> c_wraith: curried is buried in a tuple
16:08:56 <mmorrow> , (snd&&&fst) (42,"zomg")
16:08:57 <lunabot>  luna: Not in scope: `&&&'
16:09:12 <mmorrow> , let f&&&g=\x->(f x,g x) in (snd&&&fst) (42,"zomg")
16:09:12 <kadaver_> dataparallellism is for numerical stuff?
16:09:13 <lunabot>  luna: parse error on input `->'
16:09:17 <mmorrow> , let f&&&g= \x->(f x,g x) in (snd&&&fst) (42,"zomg")
16:09:17 <kadaver_> raytracing perhaps?
16:09:18 <lunabot>  ("zomg",42)
16:09:36 <copumpkin> mmorrow: zomg you don't have Control.Arrow on lunabot???
16:09:56 <mmorrow> copumpkin: i think it had to be chopped due to some name conflict
16:10:07 <mmorrow> (i don't remeber though)
16:10:53 <virus> ay. thx :)
16:11:15 <virus> I'm slowly starting to get the idea of haskell... it's really a different way of thinking
16:13:49 <virus> I've just another problem. When I try to put more than one function definition in a where { } block I get a "parse error at input '='". Shouldn't that indentation behave just like the global indent?
16:14:18 <mauke> it does
16:14:32 <mauke> you must be doing it wrong
16:14:44 <mauke> and by wrong I mean not starting a new line after "where"
16:14:46 <int-e> virus: did you put an actual { and } there?
16:14:55 <virus> err, no
16:15:45 <int-e> virus: (you should not. that would disable visual layout between the opening { and the closing } and you'd have to use explicit layout using {;} instead.)
16:16:07 <heltav> @ type (&&&)
16:16:14 <heltav> @type (&&&)
16:16:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:16:19 <virus> ah just a sec. I did put a "{" and "}" there. Sorry, got you wrong
16:17:01 <heltav> > (&&&) (+) (*) 5 6
16:17:03 <lambdabot>   Couldn't match expected type `t1 -> t'
16:17:16 <tombee> Is it possible to define a type and place restrictions upon the values it can have?
16:17:27 <heltav> > let a = (&&&) (+) (*) in a (1,2)
16:17:28 <tombee> For example, non-negative integers
16:17:29 <lambdabot>       Overlapping instances for Show ((t, t1) -> (t, t1))
16:17:29 <lambdabot>        arising from...
16:17:33 <virus> ah. I forgot the semicolon. Thought that was not neccesary
16:17:43 <heltav> @type (!!!)
16:17:45 <lambdabot> Not in scope: `!!!'
16:17:53 <heltav> @type (>>>)
16:17:55 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:17:58 <heltav> @type (<<<)
16:18:00 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
16:18:05 <tombee> @type Integer
16:18:06 <copumpkin> tombee: nope
16:18:07 <lambdabot> Not in scope: data constructor `Integer'
16:18:08 <heltav> what are the args? functions?
16:18:44 <tombee> copumpkin: I guess it's also not possible to specify a 'binary' type either then?
16:18:50 <copumpkin> binary type?
16:18:56 <tombee> 1 or 0
16:19:04 <heltav> show me how to use some arros plz
16:19:08 <copumpkin> sure it is, but not as a "subtype" of Int
16:19:16 <copumpkin> you'd do data Binary = Zero | One
16:19:23 <copumpkin> or just use Bool to do it
16:20:01 <tombee> Yeah I was thinking of Bool, but it'd be nicer to have a binary type for this :)
16:20:13 <copumpkin> tombee: you could define a nonnegative integer type, but not as a restriction of Int/Integer
16:20:27 <tombee> Ah how would I go about doing that?
16:20:52 <BMeph> > let a = (***) (+) (*) in a (1,2)
16:20:53 <lambdabot>       Overlapping instances for Show (b' -> b')
16:20:53 <lambdabot>        arising from a use of ...
16:20:55 <copumpkin> newtype Nat = Nat Integer (and then you ensure it never goes negative in your functions on it)
16:21:03 <copumpkin> or use some sort of data Nat = Zero | Succ Nat
16:21:10 <BMeph> Boo... :\
16:22:29 <BMeph> > let a = (***) (2^) (^2) in a (3,3)
16:22:31 <lambdabot>   (8,9)
16:22:43 <BMeph> Yay!!! :)
16:22:47 <copumpkin> lol
16:24:15 <wli> > let a = join (***) (2^) in a (3,3)
16:24:17 <lambdabot>   (8,8)
16:24:27 <wli> woops
16:29:47 * edwardk waves hello.
16:29:54 * copumpkin looks away
16:30:17 <Saizan> hi
16:31:01 <saml> hey
16:31:05 <edwardk> back to playing with the fast monad stuff
16:31:26 * Saizan tries to build an intuition for the Future applicative in uu-parsinglib
16:32:10 <edwardk> saizan: did you see my cleaned up uu -- oh wait yeah you did =)
16:32:25 <Saizan> yeah :)
16:32:44 <Saizan> i've almost finished reading swiestra tutorial on it too
16:32:45 <edwardk> i've almost finished my shiny new parser combinator set
16:33:21 <Saizan> uuh, does it have error correction too?
16:33:34 <edwardk> some of the corner cases of zipping down to the leaves and retaining the distinct upward paths have turned out to be tricky
16:33:43 <edwardk> uhhh, it has parallel ;)
16:34:06 <copumpkin> edwardk: what's your "day job"?
16:34:35 <edwardk> copumpkin: i write software for dealing with earned value management data mostly
16:35:33 <copumpkin> ooh
16:35:56 <Saizan> i'm going to parse stuff of ~200 chars so i don't think parallelization can gain much
16:36:04 <edwardk> saizan: =)
16:36:08 <Saizan> (unless i go crazy with the non-determinism)
16:36:29 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/ is the stuff i've put up so far (but the parallel parsing bit isn't in the combinator set in that repo yet)
16:36:46 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html should give a feel for the structure of the lib though
16:36:58 <copumpkin> :o
16:37:10 <copumpkin> parallel parsing!
16:37:20 <copumpkin> it's gotta be context-free then, right?
16:37:29 <copumpkin> I guess you say so :P
16:37:32 * copumpkin fails
16:37:33 <edwardk> copumpkin: yeah this guy requires context free
16:38:00 <heltav> > let a = (***) (3*) (+2) in a (3,4)
16:38:00 <edwardk> copumpkin: i have ways to allow delimited non-context free parsing, but thats not going in here
16:38:01 <lambdabot>   (9,6)
16:38:08 <copumpkin> ah
16:38:18 <edwardk> basically that was the whole way i had planned to do parsing before
16:38:30 <edwardk> then i figured out a variation on bottom up parsing i could run in parallel
16:38:38 <edwardk> without tanking my asymptotics too badly
16:38:57 <heltav> > let a = (***) (++"!") (+) in a ("spj",0)
16:38:59 <lambdabot>       Overlapping instances for Show (b' -> b')
16:38:59 <lambdabot>        arising from a use of ...
16:39:01 <heltav> > let a = (***) (++"!") (+§) in a ("spj",0)
16:39:03 <lambdabot>   Not in scope: `+ï¿½'
16:39:06 <heltav> > let a = (***) (++"!") (+1) in a ("spj",0)
16:39:08 <lambdabot>   ("spj!",1)
16:39:28 <edwardk> its still 'earley' style though, so expect O(n^3) or so worst case unlike a more specialized LALR or LL parser
16:40:07 <heltav> > let hmm f g (a,b) = (f a, g b) in hmm (*4) (+5) (3,5)
16:40:09 <lambdabot>   (12,10)
16:40:15 <copumpkin> zomg n^3
16:40:24 <heltav> @type (>>>)
16:40:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:40:29 <heltav> @type (&&&)
16:40:29 <copumpkin> now I need quadratic CPUs to get reasonable performance
16:40:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:40:32 <heltav> @type (***)
16:40:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:40:41 <edwardk> copumpkin: worst case. thats what you get out of earley in general
16:40:49 <copumpkin> yeah, I know :) just kidding
16:40:50 <edwardk> for common grammars it looks like it'll be find
16:40:54 <edwardk> er fine
16:41:33 <heltav> > let a = (***) (++"!") (+1) in a ("spj",0)
16:41:34 <lambdabot>   ("spj!",1)
16:41:49 <QtPlaty[HireMe]> Does haskell have (or even need) a letrec?
16:42:00 <heltav> > (***) (++"!") (+1) ("spj",0)
16:42:02 <lambdabot>   ("spj!",1)
16:42:04 <edwardk> i've designed the guts so it can deal with a small number of open possible parses without going berserk. that should deal with 'perl style arbitrary long quotes'/nested comments, separate declaration and command language' style parsers like most langs
16:42:09 <edwardk> QtPlaty[HireMe]: every let is letrec =)
16:42:16 * wli thought every let was a letrec.
16:42:29 <heltav> whydoes the ytpe of (***) have 2 args and 1 return thwne it really takes 3 args and returns
16:42:46 <heltav> > (&&&) (++"!") (+1) ("spj",0)
16:42:47 <lambdabot>   Couldn't match expected type `([Char], t)'
16:42:57 <heltav> > (&&&) ("!"++) (+1) ("spj",0)
16:42:58 <lambdabot>   Couldn't match expected type `([Char], t)'
16:43:02 <edwardk> QtPlaty[HireMe]: one nice thing about laziness is you can get away with being a lot less specific about let vs let rec, fun vs val (you can do the former regardless though)
16:43:06 <heltav> > (&&&) ("!"++) (1+) ("spj",0)
16:43:07 <lambdabot>   Couldn't match expected type `([Char], t)'
16:43:14 <heltav> @type (&&&)
16:43:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:43:53 <copumpkin> heltav: the args are arrows, which are (among other things) functions in disguise
16:44:24 <Saizan> > (***) ("!"++) (1+) ("spj",0)
16:44:26 <lambdabot>   ("!spj",1)
16:45:00 <copumpkin> the haskell twibe is getting big
16:46:27 <copumpkin> the wefollow tag isn't as big
16:46:54 <BMeph> hellav: Because it *Really* has one arg... ;p
16:47:38 <virus> I'm trying to do something 'simple', but it totally freaks me out. How do I convert a list into a tuple? I tried to create a make_tuple function which is specialized for lists with 1, 2 and 3 elements, but it won't do as supposed.
16:48:13 <edwardk> virus: the short answer is you don't because each tuple type is a different type
16:48:46 <edwardk> so you can't make a generalized list to tuple function that does 'the right thing' without deep voodoo, and then thats not even what you'd expect
16:48:46 <copumpkin> you could make a big typeclass with an instance for every tuple size
16:48:56 <edwardk> hence why i said deep voodoo ;)
16:49:02 <copumpkin> but it could only convert one way anyway
16:49:10 * copumpkin pulls out his doll
16:49:26 <virus> mmmh, and if - for example - I want to create a tuple with 3 elements and if the list is not long enough pad it with something else? That should do the trick, shoulnd't it?
16:50:23 <edwardk> that you could do
16:50:45 <copumpkin> > let toTriple (x:y:z:_) = (x, y z); toTriple [x, y] = (x, y, undefined); toTriple [x] = (x, undefined, undefined); toTriple [] = (undefined, undefined, undefined) in toTriple [1,2,3]
16:50:46 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
16:50:47 <lambdabot>      Prob...
16:50:50 <copumpkin> lol
16:50:54 * copumpkin fails once more
16:50:59 <edwardk> foo (x:y:z:_) = (x,y,z); ... nevermind copumpkin is quick on the draw
16:51:09 <copumpkin> don't worry, I failed
16:51:18 <edwardk> > let toTriple (x:y:z:_) = (x, y, z); toTriple [x, y] = (x, y, undefined); toTriple [x] = (x, undefined, undefined); toTriple [] = (undefined, undefined, undefined) in toTriple [1,2,3]
16:51:19 <lambdabot>   (1,2,3)
16:51:20 <copumpkin> oh, I forgot a comma
16:51:23 <edwardk> ha!
16:51:33 <ksf> ebml could be such a cool format, were it sufficiently specified
16:51:39 <copumpkin> ebml?
16:51:59 <ksf> http://www.matroska.org/technical/specs/rfc/index.html
16:53:31 <virus> ah, now I also get that "curry" thing :)
16:54:36 <ksf> basically, it's xml without attributes, in binary, with many cool concepts making a generic parser really interesting, and utterly incorrect and feature-incomplete dtd's.
16:54:55 <copumpkin> ah :)
16:55:04 <copumpkin> you should write an implementation in haskell and fill in the gaps!
16:56:14 <ksf> one could, for example, layer a http-like protocol over some document tree, semantically correctly interleaving transport stream control and payload.
16:56:55 <ksf> encoding dtds in ebml and sending them alongside with the data is another idea.
17:00:28 <ksf> ...you can do fun stuff like serialising a list of records sparsely, non-saved records either defaulting to some value given in the dtd or the previously serialised element of the same id.
17:01:54 <edwardk> the term that scares me here is DTD ;)
17:02:23 <edwardk> i really would like an extensible markup where the 'DTD' format could be used recursively i.e. if you have docs of docs
17:02:33 <ksf> it's not as bad as it sounds. given an adt, it could be auto-generated, modulo advanced features.
17:02:55 <ksf> I was thinking of includes
17:03:10 <copumpkin> composable document formats? :o
17:03:26 <ksf> ebml kinda does it right now, importing the general ebml header, that could easily be generalised.
17:03:42 <edwardk> copumpkin: yes, start by making the empty document valid and removing the special start node so its a monoid ;)
17:03:58 <copumpkin> lol, I feel more stuff floating into your monoids package :P
17:04:28 <edwardk> thats why i'm consciously trying to keep the parsimony stuff as a separate package ;)
17:05:00 <ksf> `mpose` ...
17:05:36 <ksf> class MonadPose a where
17:06:01 <ksf> class MonadCoPose where
17:06:09 <ksf> wth is coposing?
17:06:37 <copumpkin> well, pumpkin is a poser, so I guess coposing is what I do
17:06:48 <mmorrow> edwardk: what do you think about (or your thoughts/whatnot) on this code that allows you to (in one way or another) create a C closure which looks like a C function pointer once it's "fully applied" http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2343#a2343 ?
17:07:11 <SamB> copumpkin: if you were compumkin, would you be a composer?
17:07:27 <copumpkin> probably
17:07:42 <zcvvc> 'cabal: cannot configure base-4.0.0.0. It requires ghc-prim -any and integer-any'. I've got ghc 6.8.2, is newer required?
17:07:55 <copumpkin> yup
17:08:01 <mmorrow> so i want to use a variation on that to allow closures in my interp to be viewed from C as function ptrs
17:08:07 <sjanssen> zcvvc: you should not attempt to upgrade base
17:08:26 <edwardk> mmorrow: ah i've built something like that before
17:08:27 <mmorrow> edwardk: (that's roughly following the description from an smlnj paper)
17:08:30 <copumpkin> we need some keyboard cats in the haskell world
17:08:35 <copumpkin> lolcats are so last year
17:08:53 <mmorrow> edwardk: is there anything immediately apparent that you'd do differently ?
17:08:58 <edwardk> oh this one accumulates its own args imperatively
17:09:00 <edwardk> neat
17:09:05 <mmorrow> yeah, exactly
17:09:37 <ksf> mmmmmmhhh... the hairy thing with composing ebml dtds is id overlap. "114d9b74" is matroska's tag for Seek information, and bytes are going to hit the fan if your dtd allows your version to be a child of the same id as matroska does.
17:09:44 <copumpkin> mmorrow: that's pretty neat :)
17:09:46 <mmorrow> well, some other code has to set them.. i want to make a variant that <i'm-not-sure-yet-what-exactly>
17:09:50 <edwardk> well, use it and abuse it and i'm sure you'll come upw ith something
17:09:53 <mmorrow> copumpkin: :)
17:09:58 <Cale> http://www.reuters.com/article/lifestyleMolt/idUSTRE5444XQ20090505 -- this seems like it should be an onion article, but it's not :)
17:10:08 <copumpkin> lol
17:10:09 <mmorrow> edwardk: cool
17:11:28 <ksf> otoh, something like 2^49 possible id's with identity possibly resolved by (optional) structure is still a hell a lot.
17:11:32 <edwardk> mmorrow: added StateT to monad-ran, just Cont, ContT, RWS and RWST to go
17:11:45 <edwardk> oh and i think WriterT
17:11:45 <mmorrow> edwardk: woot
17:11:59 <edwardk> oh and probably several hundred {-# INLINE #-} pragmasa
17:12:14 <mmorrow> @unmtl RWST r w s (Cont o) a
17:12:15 <lambdabot> r -> s -> (a -> s -> w -> o) -> o
17:12:21 <mmorrow> heh
17:12:25 <copumpkin> @src Reader
17:12:26 <lambdabot> Source not found. Are you on drugs?
17:12:58 <mmorrow> @unmtl RWST r w s (ContT o (StateT ss (Cont oo)) a
17:12:58 <lambdabot> err: Parse error
17:13:02 <mmorrow> @unmtl RWST r w s (ContT o (StateT ss (Cont oo))) a
17:13:02 <lambdabot> r -> s -> (a -> s -> w -> ss -> (o -> ss -> oo) -> oo) -> ss -> (o -> ss -> oo) -> oo
17:13:05 <mmorrow> hehe
17:13:15 <copumpkin> mmorrow: so how much space does each closure take up? and could you make it variable-length to allow for fewer/more args?
17:13:23 <edwardk> i have the instances defined for RWS, etc. just writing the liftRan, lowerRan, etc.
17:13:37 <copumpkin> mmorrow: what do you do about W^X and similar stuff?
17:14:12 <mmorrow> copumpkin: yeah, with that code you can just write (c_beg-c_end)-(6-numargs) to wherever
17:14:24 <copumpkin> ah, yeah
17:14:30 <mmorrow> copumpkin: what's W^X?
17:14:42 <edwardk> here's a question. if i generate a value of the form forall o. (Int# -> Int# -> o) -> o -- i wonder how could i trick the compiler to unbox those ints in the closure?
17:14:58 * SamB wonders why emacs doesn't issue more emacs-friendly parse errors
17:15:13 <copumpkin> mmorrow: preventing writable memory from being executable... you'd need lots of mprotects :)
17:15:13 <mmorrow> edwardk: which closure?
17:15:33 <mmorrow> copumpkin: ahhh, yeah i'm mmapping with PROT_EXEC
17:15:34 <edwardk> the closure for that function
17:15:37 <copumpkin> ah
17:19:37 <edwardk> data family Tree a ::* -> *; newtype Tree Int = TreeInt { runTree :: forall o. (Int# -> Int# -> a -> Tree Int -> Tree Int -> o) -> o -> o }
17:19:43 <edwardk> mmorrow: for instance
17:20:18 <edwardk> er
17:20:30 <edwardk> newtype Tree Int a = TreeInt { runTree :: forall o. (a -> Int# -> Int# -> Tree Int -> Tree Int -> o) -> o -> o }
17:20:51 <edwardk> er newtype instance Tree Int a = ...
17:21:41 <edwardk> the reason is, in this form i can indicate the 'unboxedness' the individual elements with separate newtype wrappers down that chain...
17:21:50 <edwardk> er of the
17:22:19 <mib_crazy> hi, good night... i need help, who i can separate numbers? example, 21, take numbers separated? 2 1 ?
17:22:20 * KeyboardCat starts playing for edwardk
17:23:02 <mmorrow> KeyboardCat: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2343#a2344
17:23:30 <mmorrow> edwardk: hmm
17:23:42 <edwardk> basically that type is a 'Data.Map' with unboxed key iif i can get it to be smart about how it builds the environment
17:24:06 <copumpkin> :)
17:24:33 <mmorrow> interesting, i don't think i've ever played around with data families before
17:24:51 <Cale> mib_crazy: div and mod will help :)
17:24:52 <edwardk> well, the fundamental approach works even without the family
17:24:57 <Cale> > 21 `mod` 10
17:24:59 <lambdabot>   1
17:25:03 <Cale> > 21 `div` 10
17:25:04 <lambdabot>   2
17:25:41 <edwardk> newtype Tree a = TreeInt { runTree :: forall o. (a -> Int# -> Int# -> Tree Int -> Tree Int -> o) -> o -> o }  -- i wonder if i built the function with the values i was going to feed into those Int#'s as unboxed integers in scope if it'd pick them up unboxed when it built the closure rather than randomly rebox them
17:25:52 <mib_crazy> Cale: thanks!
17:25:59 <edwardk> unfortunately vacuum can't show me closures ;)
17:26:23 <copumpkin> what's needed to make that happen?
17:26:31 <edwardk> copumpkin: deep magic
17:26:37 <copumpkin> black magic?
17:26:43 <mmorrow> yeah, that's too bad. i've found a hook into C with some StablePtr hackery though, so that might turn out nicely
17:27:01 <mmorrow> copumpkin: heh, very black magic :)
17:27:53 <mmorrow> well, the only thing i'm unsure about is just when the gc is going to pull the rug out from under me
17:27:56 <zcvvc> I'm attempting to install yi, have no experience with cabal. What to do with http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2345?
17:28:27 <mmorrow> so it's kindof sketchy
17:28:36 <zcvvc> I installed QuickCheck-1.1.0.0 and utility-ht-0.0.5, but the error stays
17:32:02 <Cale> zcvvc: hmm
17:32:35 <Cale> zcvvc: If you cabal-install utility-ht-0.0.5  separately, it doesn't help?
17:33:04 <zcvvc> Cale: it is already installed
17:33:52 <zcvvc> I installed newer QuickCheck too, but the error is still the same
17:34:56 <Cale> hmm, I wonder what it even needs QuickCheck or that utility-ht package for... it doesn't show up in the dep list on hackage...
17:35:46 <edwardk> inRan (RWST m) = Ran (Î»k â RWSTH (Î»r s w â getRan (m r s) (Î» ~(a, s', w') â getRWSTG (k a) s' (w `mappend` w')))) -- seems sadly easy once you figure it out
17:36:25 <Cale> zcvvc: I'll give installing yi a shot
17:38:29 <Cale> zcvvc: hmm, well, I got past where you got
17:39:00 <Cale> zcvvc: aha, it installed utility-ht-0.0.4
17:39:21 <Cale> hmm
17:39:37 <zcvvc> just installed utility-ht-0.0.4. But error is the same
17:40:00 <Cale> actually...
17:40:11 <Cale> It didn't install utility-ht at all, I already had it
17:41:26 <Cale> Out of interest, which ghc are you using?
17:41:45 <Cale> Not that the error message has anything to do with that...
17:41:51 <zcvvc> got it
17:42:00 <copumpkin> yi depends on utility-ht ? :o
17:42:02 <sw17ch> sweet! atom-0.0.3 is out.
17:42:26 <Cale> copumpkin: Not in any obvious way, but perhaps one of its dependencies does?
17:42:41 <zcvvc> I've got newest. I uninstalled utility-ht-0.0.5, installed utility-0.0.4 and it passed
17:42:44 <zcvvc> thanks Cale
17:42:50 <Cale> Interesting
17:43:13 <Cale> I'm really sick of these QuickCheck dependency issues.
17:44:01 <Cale> Packages unrelated to testing should not demand QuickCheck...
17:44:59 <tiglionabbit_> I can't cabal install nano-hmac because HMAC.hsc:57: error: âSHA224_DIGEST_LENGTHâ undeclared
17:45:13 <tiglionabbit_> can't find info about this.  What should I do?
17:45:39 <Cale> Sounds like you have a different version of the C library than the binding expected, perhaps?
17:45:57 <tiglionabbit_> maybe.  I'm on an intel mac (leopard)
17:48:41 <copumpkin> tiglionabbit: does it depend on openssl? I vaguely remember that the one bundled with mac os doesn't support the various SHA2 hashes
17:49:00 <Cale> Yes, it does
17:49:23 <c_wraith> yeah, if you build openssl from source on OS X you get a lot more than the version included by default.
17:49:26 <Cale> Look in /usr/include/openssl/sha.h (or wherever that file is on your system)
17:49:31 <copumpkin> yeah, that's what I ended up doing
17:49:43 <Cale> and see that it has
17:49:45 <Cale> #define SHA224_DIGEST_LENGTH	28
17:50:03 <copumpkin> hah, the only one in my system header is #define SHA_DIGEST_LENGTH 20
17:50:11 <copumpkin> no mention of any of the sha2 ones
17:50:16 <copumpkin> (I'm on mac os too)
17:53:54 <Cale> Hehe, distributions should learn from Debian's mistake and not make modifications to the OpenSSL library.
17:57:48 <tchakkazulu> Hey, is there a package somewhere to read, write, and modify .bmp files?
17:58:31 <tchakkazulu> I've tried the DevIL bindings, but when I read a file with it, and directly write it to another file, it only writes a black thing.
17:58:54 <tchakkazulu> At least, with the two test .bmps I used.
18:00:35 <mmorrow> tchakkazulu: i have some C code (for rgb 8x8x8 uncompressed bmp's only) that i got from elsewhere in here: http://moonpatio.com/repos/vacuum-gl/c/bmp.c  and bmp.h
18:00:47 <mmorrow> you can ffi to if fairly easily
18:00:59 <mmorrow> and it also shouldn't be too hard to rewrite in haskell
18:01:06 <mmorrow> (if you're so inclined)
18:01:27 <Cale> The SDL-image library is supposed to support BMPs.
18:01:32 <tchakkazulu> I'll look at it. Thanks, mmorrow.
18:01:44 <mmorrow> tchakkazulu: no prob
18:02:03 <tchakkazulu> Yeah, I looked at the SDL libs, and you can read files into some "Surface" datatype, but I couldn't find any functions to write an image back to file.
18:03:14 <Cale> ah, hmm
18:06:33 * ksf needs a many $ oneOf that succeeds exactly one or zero times for any parser, in any order.
18:07:17 <ksf> let's make that n to k times.
18:07:51 <tiglionabbit_> Cale: I did port install openssl, but I guess that version isn't good enough either?
18:08:01 <tiglionabbit_> what version should I get and how should I add it
18:08:12 <ksf> ...either it's involved enough to be worth more thinking, or I'm plain tired.
18:11:51 <ManateeLazyCat> I'm finding some functional purely GUI toolkit, and looks Fudgets is good, have any other FP GUI toolkit? Any suggestions? Thanks!
18:12:27 <ksf> there's conal's TV stuff, Phooey.
18:12:34 <ksf> It's all out of date, though.
18:12:43 <ksf> speaking of conal...
18:13:15 <ksf> ...nope, still no new version of reactive on hackage.
18:13:51 <tiglionabbit_> Cale: should I just put the definition in there or something?
18:14:27 <ksf> there's grapefruit, which i don't know anything about except that it's arrow-based.
18:15:13 <ksf> you might want to have a look at elerea, it seems to work quite well and could be usable for a decent reactive tk.
18:16:33 <thoughtpolice> i've been looking at elerea a lot and it's pretty neat
18:16:52 <thoughtpolice> very minimal - makes it easier to understand. :)
18:17:38 <ksf> that's what I thought, too. I can cope much better with some unsafePerformIO magic than with conal's abstract nonsense.
18:19:23 <ksf> heh. I can make another oneOf that discards the suceeding parser from the list and returns the other parsers alongside with the result, making it a monad of its own.
18:20:25 <ManateeLazyCat> Thanks all for suggestions
18:21:34 <tchakkazulu> ksf: optional p = Just <$> p <|> pure Nothing. Or perhaps use "try p" instead of "p".
18:21:52 * ksf goes off overdesigning what's right now "data Cardinality"
18:21:56 <tchakkazulu> That's parsing 1 or 0, wrapping it in a Maybe.
18:22:29 <ksf> I need at least any number, zero or one, one, and one or more.
18:22:51 <ksf> ...better even if I can just generalise that to upper and lower bounds.
18:23:20 <tchakkazulu> If you have 0-n, you can use "replicateM k" to lift it to k-(n+k).
18:23:33 <tchakkazulu> And for 0-n... perhaps explicit recursion would be easiest for that.
18:23:51 <tchakkazulu> But I must admit I don't know much about checking to see if a parser consumes input and such.
18:24:42 <ksf> that's not the problem, the problem is that I have to match many parsers with different cardinality, and matches can occur in any order.
18:25:12 <tchakkazulu> Ohh... like a permutation?
18:25:31 <ksf> that's more like it, yes.
18:26:30 <ksf> think of "a <html> element may contain exactly one <br> element, and one or more <table> elements, in arbitrary order"
18:26:54 <tchakkazulu> Ahh, okay.
18:28:05 <ksf> "...and if there isn't a <foo> element it's defined to be "234", and if there isn't a <bar> element it's defined to have the value it had in the previous <html> element"
18:28:46 <tchakkazulu> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Perm.html#t%3AStreamPermParser <- should be able to do permutations, haven't tried it myself.
18:28:49 <ksf> the last one implies haskell wins.
18:28:58 <tchakkazulu> But having one-or-more... yeah, I see your problem.
18:29:31 <ksf> sadly, parsec parsers can't be defined in terms of themselves.
18:30:03 <tchakkazulu> Heh. Left recursion :(
18:30:42 <ksf> polyparse can do it. as long as I don't code up cyclic dependencies i'm fine.
18:31:32 <ksf> well, coding them up isn't the problem, forcing them is.
18:32:55 <ksf> Is there some integral number type that has an element for infinity?
18:33:29 <badtruffle> not that I know of
18:33:38 <Twey> I believe not
18:33:43 <tchakkazulu> You could fake it with Maybe, but other than that... nope.
18:33:52 <Twey> Being as div is undefined for 0
18:33:59 <Twey> There's Float, of course
18:34:11 <dolio> > 5 < infinity
18:34:13 <lambdabot>   True
18:34:43 <cypher-> hmm.. my firefox uses 471 MB of memory and counting..
18:34:45 <ksf> I only need +/- , numbers > 0 and some comparisons.
18:34:57 <Twey> :t let a = 5 in a < infinity `seq` a
18:34:59 <lambdabot> forall t. (Num t) => t
18:35:04 <Twey> Hmph
18:35:13 <tchakkazulu> :t infinity
18:35:14 <lambdabot> Natural
18:35:17 <dolio> > 5 < infinity `div` 2
18:35:18 <Twey> > (5 :: Int) < infinity
18:35:18 <lambdabot>   True
18:35:19 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
18:35:25 * Twey ponders.
18:35:31 <tchakkazulu> So... this Natural thing would be it.
18:35:49 <Twey> Aha
18:35:51 <Twey> Yeah
18:35:53 <tchakkazulu> Not findable by hoogle, though.
18:36:06 <ksf> it's not in the ghc libs, either.
18:36:25 <tchakkazulu> http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-Natural.html
18:36:30 <tchakkazulu> There it is :)
18:37:19 <ksf> ouch, it's implemented in peano.
18:37:30 <copumpkin> mmmm efficiency
18:37:54 <ksf> ...and 0 - 1 would be zero, in my case.
18:38:05 <tchakkazulu> I occasionally use that to compare lengths of infinite lists, but yeah, that's too bad :(
18:38:08 <ksf> ...or, actually, I wouldn't mind if it's bottom.
18:38:38 <edwardk> hrmm it looks like the 'i don't need to shuffle stuff around invariants start to break on the ran transformers, maybe i can come up with a smarter layout of their arguments
18:38:52 <ray> what's so hard about writing your own instances that do exactly what you want? :)
18:39:23 <ksf> nothing, except #haskell. and the fact that i've been up coding for too long.
18:43:57 * ksf ponders about infinity - infinity
18:44:45 <dolio> > 0 - infinity
18:44:46 <lambdabot>   * Exception: Natural: (-)
18:45:00 <ksf> > infinity - infinity
18:45:03 <hatds> :t infinity
18:45:04 <ksf> ...
18:45:05 <lambdabot> Natural
18:45:08 <ksf> now that's bad.
18:45:15 <lambdabot>   thread killed
18:45:33 <hatds> infinity + infinity
18:45:49 <hatds> > infinity + infinity
18:45:52 <lambdabot>   * Exception: stack overflow
18:45:53 <tchakkazulu> Heh
18:45:58 <kpreid> > (infinity / infinity) > 3
18:46:00 <lambdabot>       No instance for (Fractional Natural)
18:46:00 <tchakkazulu> I think infinity = Suc infinity.
18:46:00 <lambdabot>        arising from a use of `/' a...
18:46:06 <hatds> > infinity >= 3
18:46:07 <kpreid> > (infinity `div` infinity) > 3
18:46:09 <lambdabot>   True
18:46:09 <ksf> tchakkazulu, exactly.
18:46:17 <tchakkazulu> So it cannot actually ever determine if a value is infinite <_<
18:46:22 <lambdabot>   thread killed
18:46:35 <kpreid> kinda like how you can't determine the sign of a real number
18:46:57 <tchakkazulu> So I guess a "data MyNat = Finite Int | Infinite deriving (Eq, Ord)" would do what you want.
18:47:23 <tchakkazulu> And then define the Num instance yourself, but that shouldn't be too hard.
18:47:55 <ksf> That's what I'm doing right now.
18:49:30 <ksf> wait... isn't infinity * infinity the point where those strange other infinities kick in?
18:49:53 <tchakkazulu> Not yet. That's with Infinity ^ Infinity.
18:49:58 <dolio> Which?
18:50:28 <hatds> ordinal numbers
18:50:32 <tchakkazulu> If "Infinity" is the normal, countable, infinity, then Infinity * Infinity is also the normal, countable, infinity.
18:50:59 <ksf> wth is signum?
18:51:10 <tchakkazulu> :t signum
18:51:12 <lambdabot> forall a. (Num a) => a -> a
18:51:17 <tchakkazulu> signum (negate 4)
18:51:20 <tchakkazulu> > signum (negate 4)
18:51:21 <lambdabot>   -1
18:51:33 <tchakkazulu> > (signum 0, signum 5)
18:51:35 <lambdabot>   (0,1)
18:51:37 <tchakkazulu> sign.
18:51:41 <Saizan> x = signum x * abs x
18:54:43 <tchakkazulu> ksf: about your permutations, would this work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4628#a4628
18:55:13 <tchakkazulu> where "pick" is your run-of-the-mill [a] -> [(a,[a])] function.
18:56:07 <tchakkazulu> May need to insert some "try" for the backtracking behaviour, though... if you want it.
18:56:44 <ksf> I'm using polyparse, it backtracks by default.
18:56:56 <tchakkazulu> Ah, polyparse. Okay :)
18:57:11 <tchakkazulu> (also, choice -> parseChoice)
19:02:07 <ksf> ...nope, applicative alone won't be powerful enough, I need way more control over the possibilities.
19:02:24 <ksf> ...I think.
19:03:33 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4630#a4630
19:03:42 <ksf> ...use at your own risk, it merely compiles.
19:04:28 <tchakkazulu> Yeah. I'd probably use error or something for the Infinity - Infinity case.
19:04:30 <ksf> uh, and it's two lines too long.
19:05:03 <tchakkazulu> Also, beware:  (Nat x) - (Nat y) = Nat $ x - y <- does not check if (x - y) >= 0.
19:05:21 <kbateman> ccw :: Point -> Point -> Point -> Bool;  ccw x y z = (> 0) . cross
19:05:22 <ksf> ouch, yes.
19:05:32 <kbateman> Is there a way to define ccw in a point free style?
19:05:51 <kbateman> oops.   ccw x y z = (> 0) $ cross x y z
19:05:56 <tchakkazulu> And the instances of Eq and Ord are the same as the ones that are derived.
19:06:32 <Saizan> ?pl  ccw x y z = (> 0) $ cross x y z
19:06:33 <lambdabot> ccw = (((> 0) .) .) . cross
19:06:33 <tchakkazulu> (though I'm kinda iffy about Infinity == Infinity... but I guess in this context it makes sense)
19:07:18 <ksf> I'm proud not to be a mathematician.
19:07:38 <kbateman> thanks, I guess. :)
19:08:43 <hatds> where would this typeclass be useful do you think?
19:09:15 <tchakkazulu> What I like is how any of the older parsing libraries have their own typeclass which is basically Applicative and some extras.
19:12:36 <ksf> Infinity - Infinity == 0 follows from n - n = 0, which follows from n = n
19:12:40 <dropdrive> I've got a string representation of a double in a ByteString, and I'm trying to convert it to an 8-byte ByteString representing the parsed double.  I got as far as wrapping strtod and getting a CDouble; how should I proceed from here?
19:12:55 <ksf> ...and even if that doesn't make sense to the mathematically enlightened, i'm sticking with it.
19:13:31 <copumpkin> o.O
19:14:09 <hatds> just don't fool yourself into thinking it is a semiring :)
19:14:50 <ksf> I won't. I don't even know how they're defined.
19:15:19 <hatds> ring without minus I think
19:15:31 <copumpkin> so if Infinity + 1 == Infinity, what is Infinity - Infinity + 1?
19:15:33 <ksf> I've got my own, very constructive perspective on numbers, which means that I can calculate everything by counting fingers, even if it takes me forever.
19:15:51 <tchakkazulu> Ghehehe :p
19:16:08 <ksf> uhmmm...
19:16:14 <Saizan> dropdrive: i'd use that: http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Internal.html#v%3Acreate
19:16:25 <Saizan> dropdrive: together with castPtr and poke
19:16:32 <ksf> Infinity - Infinity = EternalZero?
19:17:00 <ksf> that is, a zero that's so small that no matter how much you add to it, it stays zero.
19:17:14 <ksf> except maybe Infinity + EternalZero = 0.
19:17:25 <hatds> lol
19:17:28 <hatds> I like it
19:17:34 <copumpkin> EternalZero === Hell
19:17:41 <dolio> So Infinity + Infinity - Infinity = 0?
19:18:01 <hatds> depends on how you order those operations
19:18:06 <dolio> Right.
19:18:16 <ksf> what, I have to care about associativity?
19:18:29 <dolio> Maybe you should add DoubleInfinity.
19:18:39 <copumpkin> well, we're trying to show you that Infinity - Infinity == 0 is a bad idea :P
19:18:40 <copumpkin> or at least, I was
19:18:43 <hatds> + is associative I think, but there is no negate.. you can't think of -Infinity as adding negative infinity
19:19:13 <ksf> hatds, yeah, that's it.
19:20:33 <tiglionabbit_> man, I don't know how to fix this openssl thing.  I tried installing the standard openssl package, but I don't think cabal is using it
19:20:43 <tiglionabbit_> join ssl
19:20:45 <tiglionabbit_> oops
19:21:01 <ksf> but then, 1 - 3 should't clamp to 0, either.
19:21:32 <dropdrive> Saizan: Thanks for your help.  I guess the key is that CDouble is an instance of Storable?
19:21:51 <tchakkazulu> Yeah, all those nice properties for integers break when you leave out numbers smaller than 0.
19:21:58 <ksf> it's that darn "negative number of people in an elevator" problem. conservation of numbers, so to speak.
19:22:16 <hatds> should just make this a typeclass that has + and * but no minus
19:22:36 <hatds> made /
19:22:39 <hatds> *maybe
19:22:43 <Saizan> dropdrive: yup
19:23:02 <Saizan> Prelude Data.ByteString.Internal Foreign Foreign.C.Types> create 8 (\ptr -> poke (castPtr ptr) (-2/3 :: CDouble))
19:23:06 <Saizan> "UUUUUU\229\191"
19:23:21 <ksf> the right solution is to use peano-semantics and agda to safe you from runtime errors.
19:23:32 <hatds> agda?
19:23:48 <ksf> http://wiki.portal.chalmers.se/agda/
19:23:54 <ksf> @where agda
19:23:54 <lambdabot> http://tinyurl.com/yp6zsr
19:24:18 <ksf> @where+ agda http://wiki.portal.chalmers.se/agda/
19:24:18 <lambdabot> Nice!
19:24:30 <tchakkazulu> Yay agda!
19:24:40 <tchakkazulu> ... or wrap the result of - in a Maybe >_>
19:24:53 <ksf> ...we don't want to let people see that index._php_, now do we?
19:24:56 <deech_> Hi all, I am trying to read GHC's implementation of Software Transactional Memory. I am new to Haskell, when reading the code can I reason about unboxed values and tuples as though they were not unboxed?
19:25:15 <ksf> nearly.
19:25:16 <hatds> really, isn't the whole point of Nats to avoid maybes and such where negative numbers wouldn't make sense?
19:25:23 <ksf> in most of the cases, that is.
19:25:48 <ksf> you've got less _|_, and less space taken up.
19:26:03 <Saizan> deech_: well, you should at least consider that they are strict
19:26:24 <tchakkazulu> No, the point is to avoid negative numbers at all. However, when you add operations that make negative numbers possible, you should have an alternative (or live with non-total functions).
19:26:40 <deech_> Saizan : But aside from that I can ignore the #?
19:27:29 <hatds> I would have - return an error.  Force the user to convert if they want negative numbers
19:27:44 <Saizan> deech_: yes, in types
19:27:46 <ksf> it's about learning modesty. If there's two cakes, you can have both, even eat them, but you can't have three, and THOU SHALT NOT WANT THREE
19:28:12 <Saizan> deech_: in function names # means something like "primitive" or "internal", it's more a convention than anything
19:28:40 <hatds> hence the name C#
19:28:44 * ksf thinks of cake futures
19:29:28 <deech_> Saizan : Ok, cool. Does that include datatypes like Int# ?
19:29:29 <thoughtpolice> well, unboxed tuples are particularly magical
19:29:33 <thoughtpolice> because they put stuff in registers
19:31:01 <ksf> packed? like in 16-bytes-in-a-register?
19:33:31 <ksf> hmmm. I could code up a nat type in agda, compile it to haskell, then use it from haskell and pretend I'm using typesafe code.
19:34:27 <hatds> I never feel like dependent types are the right answer
19:34:58 <Saizan> deech_: Int# is the unboxed version of Int, yeah
19:35:00 <Saizan> ?src Int
19:35:00 <lambdabot> data Int = I# Int#
19:35:42 <hatds> wait.. what does # conventionally mean on a constructor then?
19:36:01 <lispy> hatds: magic ghc primitive, afaict
19:36:16 <lispy> (# isn't a primitive, but it marks them)
19:37:49 <hatds> so you can't define unlifted data declarations?  Makes sense I guess
19:39:16 <lispy> you can do the safer thing though, convince GHC that it should try to unbox things and let it decide how/when it's okay
19:41:35 * tchakkazulu is back to stay. Sorry for the connect/disconnect spam.
19:42:36 <lispy> hatds: but, what really is the difference between dependent types and dynamic types?
19:44:13 <hatds> I wouldn't be the one to ask
19:44:27 <hatds> > "dependent" \\ "dynamic"
19:44:29 <lambdabot>   "epedent"
19:44:37 <roconnor> lispy: what's the question?
19:44:58 <hatds> when are dependent types the best solution
19:45:07 <roconnor> always!
19:45:29 <roconnor> but that is just my opinion
19:46:02 <vixey> oh I am in time for dependent types
19:46:12 <roconnor> @oesis 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 24, 31, 100
19:46:13 <lambdabot>  16 in base 16-n.
19:46:13 <lambdabot>  [10,11,12,13,14,15,16,17,20,22,24,31,100,121,10000,1111111111111111]
19:46:39 <vixey> If you call 'dynamic' typed instead: untyped -- then the difference is much cleare
19:48:17 <ManateeLazyCat> Now have three packages that binding X11: "X11" "X11-extras" "X11-xft", them have *FULLY* binding X11 graphics library?
19:48:33 <lispy> vixey: but, it's not untyped
19:48:42 <dolio> It is.
19:48:45 <roconnor> "dynamic types" lets you write almost any code.  Depenent types finds hardly any code acceptable.
19:48:47 <dolio> It's tagged.
19:49:03 <lispy> roconnor: I was just thinking the other day how a dynamically typed program can have types that depend on values
19:49:22 <vixey> lispy, what's not untyped?
19:49:27 <roconnor> lispy: that's because dynamics typed program is not typed programming
19:49:33 <roconnor> bastards took the name.
19:49:35 <lispy> vixey: dynamic typing != untyped
19:49:36 <roconnor> illegally
19:49:54 <roconnor> vixey is right.  dynamically types programs are essentially untyped.
19:50:10 <lispy> take python for example
19:50:14 <roconnor> for what we all understand types as.
19:50:35 <lispy> You can still get type errors and you still have types, they are just done at run-time and associated with values not names of values
19:50:51 <roconnor> how is python different from scheme is this respect?
19:51:13 <lispy> I don't know scheme, but I assume it is very similar to python this way
19:51:17 <vixey> lispy, runtime "type" error is exactly a pattern match fall through
19:51:28 <roconnor> scheme is a typical example of an untyped language.
19:51:51 <lispy> roconnor: how so?  it has types
19:52:09 <vixey> lispy, (this is a very clinical view of the situation but from that position it makes the distinction much cleare)
19:52:12 <vixey> clearer*
19:52:46 <roconnor> Types are not a run-time phenomenon.  Typechecking occurs before execution.
19:52:50 <roconnor> for what we call types.
19:52:58 <lispy> in staticaly typed languages
19:53:01 <vixey> lispy, what I am doing is fixing *one* definition of type and using that to think about /both/ languages
19:53:26 <vixey> lispy, rather than using the haskell/type theory definition of type when I think about haskell and then the linguistic/dynamic definition of type when I think about python
19:53:41 <roconnor> right.  and "dynamically typed" languages have nothing to do with types from type theory.
19:53:43 <vixey> lispy, same principle about changing only one variable to make good conclusions
19:53:55 <roconnor> it is very confusing for them to use the name types
19:54:03 <roconnor> and leads to all sorts of silly arguments, such as this one.
19:54:10 <lispy> I don't understand how you can choose a definition that invalidates the other languages
19:54:11 <vixey> that's why 'untyped' is meaningful here - and not contradictory to 'dynamically typed'
19:54:28 <vixey> I am not making sense?
19:54:31 <ksf> dependent typing is just like dynamic typing, only at compile time.
19:54:34 <lispy> vixey: right
19:54:41 <lispy> vixey: (about not making sense)
19:54:54 <roconnor> lispy: calling python and scheme untyped is not a moral judgement on the languages.
19:55:04 <lispy> roconnor: but it is wrong because they have types
19:55:07 <ksf> assembly is typed, too.
19:55:28 <roconnor> lispy: if you don't get type errors during typechecking, your language is untyped.
19:55:31 <ksf> you just can't add float and integer registers.
19:55:57 <Saizan> roconnor, vixey: can you formulate the definition of type-theory types such that excluding runtime type-checking doesn't look arbitrary?
19:56:01 <vixey> roconnor: well the thing is they can have some type errors like if you do (DECLARE (INTEGER FOO)) .. and then use it as a string (in common lisp)
19:56:03 <ksf> see, it even enforces typing on combinator-level.
19:56:06 <lispy> roconnor: how do you figure?
19:56:07 <Saizan> that would help in clearing this out i guess
19:56:29 <vixey> roconnor: but I guess I'm throwing a spanner in the works here with thinking about advanced compilers
19:56:42 <roconnor> lispy: that is part of definition of types from type theory.
19:57:03 <lispy> roconnor: I don't believe you
19:57:08 <vixey> You could claim than scheme is typed though in a really trivial sense
19:57:19 <roconnor> lispy: it is simply semantics.
19:57:23 <vixey> something like  |- Y /\ |- X ==> |- (X Y)
19:57:30 <vixey> and take as an axiom that everything is well typed :p
19:57:33 <hatds> preservation and progress or something isn't it?
19:57:45 <vixey> yeah you would not have progress
19:58:02 <lispy> roconnor: Your semantics have a glaring flaw then, they left out dynamic types :)
19:58:10 <roconnor> Saizan: type checking necessarily occurs before execution.  It is a proof validation procedure that ensures certain properties hold about your program.
19:58:41 <roconnor> lispy: dynamic types is a confusing term because it has nothing to do with type checking.
19:58:52 <lispy> roconnor: and what if that type check happens "just in time" as in scheme?
19:58:54 <rieux_> vixey: indeed, r6rs is typed
19:59:11 <rieux_> vixey: but it only has one type, and all type errors are about terms being open :)
19:59:28 <roconnor> lispy: dynamic types dont prove any properties of your program before execution.
19:59:41 <luqui> is there a haskell98 compliant monad library?
19:59:45 <roconnor> rieux_: having one type is the definition of untyped.
19:59:52 <roconnor> or is a definition
20:00:00 <lispy> roconnor: How do you define type?
20:00:01 <Saizan> luqui: transformers should be
20:00:03 <rieux_> roconnor: it may be trivial, but there's a type system
20:00:05 <rieux_> and it's static
20:00:09 <luqui> Saizan, thanks
20:00:18 <rieux_> i can write it out for you in gentzen style
20:00:20 <lispy> roconnor: you seem to have a definition that assumes the results of static type analysis
20:00:22 <roconnor> rieux_: right.  It is call the untyped.
20:00:28 <vixey> lispy, please bear in mind we have multiple (vaugely related) definitions for words such as 'typed'
20:00:30 <ksf> unlambda and lazy k may be untyped, but scheme's have integer and float types.
20:00:44 <roconnor> lispy: static type analysis is type theory.
20:00:49 <rieux_> roconor: disagree.  it's not the same as you get in other untyped languages.  you couldn't write out the type system for python
20:00:52 <ksf> ...not to mention beasts like [#compiled-procedure]
20:00:53 <rieux_> but for scheme you can
20:01:17 <roconnor> rieux_: why not in python?
20:01:22 <lispy> roconnor: this discussion is really boring. You seem to be going in circles and I fundamentally disagree with your premise that dynamically typed languages lack types
20:01:28 <weilawei> is there a left-associate version of the dollar sign?
20:01:32 <weilawei> *associative
20:01:37 <roconnor> lispy: indeed it is boring.
20:01:39 <rieux_> roconnor: because python (perl, ruby, etc.) don't actually do what scheme does.  give me a second
20:01:40 <vixey> lispy, I think you just don't get what we are saying
20:01:42 <hatds> they lack static types, surely we can agree eh?
20:01:50 <vixey> lispy, seems to be some communication problem
20:01:59 <lispy> vixey: right, because you're talking non-sense :)
20:02:06 <vixey> k
20:02:10 <vixey> I'm gonna just not talk to you
20:02:14 <lispy> vixey: python and scheem (as examples) have types.  How can you claim otherwise?
20:02:39 <roconnor> they don't have type theory types.
20:02:47 <roconnor> they have some other beast that I would call tags
20:02:51 <roconnor> less confusing
20:02:52 <Saizan> well, it's a matter of accepting a definition or not, type theory only works with what others call static types
20:03:01 <weilawei> something like (<$) :: a -> (a -> a -> a) -> a ?
20:03:21 <weilawei> hoogle has nothing quite matching what I want
20:03:26 <hatds> aren't they considering making $ left associative in Haskell'  ?
20:03:32 <ksf> :t (<$)
20:03:33 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:03:35 <weilawei> hatds: i can see uses for both directions
20:03:36 <ksf> it's already taken.
20:03:40 <ksf> just define your own.
20:03:43 <roconnor> hatds: only hasCale is considering that
20:04:00 <rieux_> roconnor: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2346#a2346
20:04:20 <weilawei> haskell's type system and monads have only clicked like in the last couple days and im absolutely overjoyed how easy it is to find a function to do X.
20:04:30 <ksf> ...others are being downmodded on haskit for suggesting editor support to "fix" that "problem"
20:04:44 <roconnor> rieux_: and why can't you do something similar in python?  I mean you will have different sorts, commands and expressions, but still.
20:04:58 <rieux_> roconnor: you could, but it doesn't.  R6RS mandates that.
20:05:14 <roconnor> rieux_: if I could, that's good enough for me.
20:05:36 <rieux_> roconnor: i'm not saying you couldn't stick a trivial type system like that on other "dynamic languages (though eval makes it tricky).  i'm saying scheme actually had that type system now :
20:05:50 <rieux_> s/had/has/
20:06:33 <vixey> lispy: just because you don't understand something doesn't make it nonsense and what you said is pretty rude actually
20:06:34 <roconnor> rieux_: you are one of those people who believe a math result is true only after someone proves it, and that it wasn't true before the proof. :)
20:07:14 <roconnor> vixey: I took lispy's comment in the most light hearted way possible.
20:07:31 <rieux_> roconnor: ha!  (i don't think i am.)
20:07:45 <vixey> well I got the impression they are just trolling
20:08:05 <rieux_> even trolls have teachable moments
20:08:31 <lispy> No, I really would like to think about the differences between dependent and dynamic typing.  But, we hit an impasse at the definition of type.
20:08:44 <lispy> Not just a troll, but I actually want to compare the concepts.
20:08:57 <vixey> anyway ran out of patience with it
20:09:14 <lispy> That's why I'm so strongly having issues with the dismissal of dynamic types as a form of type.
20:09:20 <dolio> Dependent typing lets you do fancy proving. Dynamic typing lets you do no proving whatsoever.
20:09:26 <rieux_> perhaps if you want to understand the difference, you should just stipulate to the definition that people want to use.  you can continue to use your preferred definition the rest of the type.  but youll hardly make sense of dependent types otherwise.
20:09:45 <SamB> lispy: it is a form of type
20:09:55 <SamB> it's the form where you say "I don't want to prove anything"
20:10:14 <roconnor> SamB: right.  It is untyped.
20:10:16 <SamB> i.e. data Duck = ...
20:10:38 <vixey> lispy: Well you should have some respect for people who you want to talk to -- but then maybe you know I'm just some brainless idiot and would rather I didn't say any more on the topic
20:10:51 * SamB wishes Emacs would at least offer extensible dynamic tagging
20:11:15 <hatds> so do dynamically typed languages have any way to spot an error like "filter xs isEven" without executing that code branch?
20:11:25 <SamB> vixey: in the sense that variables don't have types ...
20:11:29 <ksf> http://www.reddit.com/r/programming/comments/8i3kt/the_c_is_efficient_language_fallacy/
20:12:00 <lispy> vixey: I never said you were brainless.  I said, that claiming python/scheme don't have types is non-sense.  I base this on the observation that the languages have 'types'.
20:12:12 <roconnor> > data Expr = Integer Integer | String String | ... -- The constructors Integer and String here are exactly what python calls types, but we'd never call them types in Haskell.
20:12:13 <lambdabot>   <no location info>: parse error on input `data'
20:12:36 <SamB> well, the types are a totally different sort of types than you have in Haskell
20:12:43 <vixey> roconnor: reminds me of this http://lambda-the-ultimate.org/node/3298
20:12:51 <SamB> the variables don't have types, that I can agree with myself on at least ;-)
20:13:40 <SamB> hmm.
20:13:54 * SamB tries to compare the typing of ASM with that of Python, and fails
20:14:00 <roconnor> vixey: heh.  The "types" X and Y.
20:15:07 <roconnor> python has what we would call "tags"
20:15:20 <roconnor> we aren't saying that python's tags don't exist
20:15:49 <vixey> roconnor: use Wadler and Guide puppets, Wadler says tags but Guide says types :p
20:15:58 <vixey> Guiio
20:16:01 <roconnor> lispy: so your question is, what is the difference between run-time tagging, and dependent types.
20:16:12 <lispy> vixey: Guido?  the python creator?
20:16:15 <SamB> or that it isn't proper to call them types when programming in python
20:16:20 <SamB> vixey: yeah, it is Guido
20:16:42 <vixey> I am trying to get across the same point I was before -- multiple meanings of a word from different perspectives
20:16:49 <SamB> he's the BDFL
20:16:58 <lispy> roconnor: Why do you consider them to only be tags?
20:17:08 <lispy> roconnor: what is the distinction you want to make?
20:17:29 <roconnor> lispy: the run-time pre-runtime distinction
20:17:29 <lispy> SamB: Benevolent or Bad? :)
20:17:35 <SamB> lispy: toe-may-toes, toe-mah-toes
20:17:48 <SamB> lispy: well, it's intended to be Benevolent
20:17:53 <roconnor> lispy: types are checked before running your program to ensure certain behaviours are impossible.
20:18:00 <SamB> but he's not afraid to make the wrong decision
20:18:04 <lispy> roconnor: So, aside from that you consider them to be more or less equivalent concepts?
20:18:43 <hatds> how often does dependently typed code need to be given a manual proof or whatever?
20:18:46 <roconnor> lispy: tags necessarily exist at run-time and halt erronnious programs before undefined behaviour kicks in
20:19:00 <SamB> hatds: code is proof
20:19:05 <tiglionabbit_> hey guys.  I am on a mac which has a nonstandard openssl library on it.  So I installed a standard one.  How do I make cabal use this one instead, when I install nano-hmac?
20:19:06 <SamB> that's kinda the point
20:19:07 <roconnor> lispy: I personally consider them totally different and independent concepts
20:19:11 <GoodBye> Hello DCC SEND "0101010101010101" 0 0 0
20:19:15 <roconnor> lispy: Haskell has tags and types
20:19:20 <SamB> hatds: though in Coq, you don't necessarily need to write it
20:19:46 <SamB> you could instead write a proof script that will end up writing the code for you ...
20:19:52 <lispy> roconnor: I've used tags in Haskell...well tagged types (or branded)
20:19:54 <vixey> hatds, For a start just managing to write your program in Coq already proves lots of thisg about it such as it is strongly normalizing
20:20:13 <roconnor> lispy: tags are constructors
20:20:15 <BMeph> lispy: I prefer "Bowed-down-to" ;p
20:20:23 <vixey> hatds, that can make writing some programs (ones with a complicated termination criteria) hard to write -- and require more proving
20:20:33 <lispy> BMeph: heh
20:20:36 <vixey> s/to write/ #  redundant
20:20:41 <luqui> and other programs impossible to write...
20:20:57 <SamB> luqui: well, yes
20:20:58 <luqui> (turns out not very many though... basically only those which actually dont terminate)
20:21:06 <SamB> luqui: a lot of those you don't want to write anyway
20:21:12 <lispy> roconnor: so here is the thing.  To match what a python program can express at run-time, you need a pretty powerful type system, let's say one with undecidable type checking.
20:21:20 <luqui> and those which always terminate, but in such a way as they try to find proofs of any proposition provable in coq itself
20:21:21 <roconnor> hatds: the distinction between programming and writing manual proofs can be quite blurry.
20:21:27 <lispy> roconnor: So, dependent types are in this category depending on the design choices
20:21:28 <luqui> =P
20:21:33 <weilawei> okay so.. i have my "left associative dollar sign" except that ($) :: (a -> b) -> a -> b and (<-$) :: a -> (a -> a) -> a...
20:21:35 <SamB> some of them are just because of problems with the guardedness condition for corecursion ...
20:21:36 <weilawei> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4632#a4632
20:21:52 <luqui> Ugh.  Corecursion is so gross in coq
20:21:54 <lispy> roconnor: So why not, do static analysis of *parts* of python programs using dependent types and then let the dynamic types sort it out at run-time
20:21:59 <vixey> weilawei: that doesn't seem like a good thing :(
20:22:02 <SamB> luqui: indeed!
20:22:10 <roconnor> lispy: I don't understand what it means to match what python program can express at runtime.
20:22:18 <weilawei> vixey: yeah i want it to work exactly like a dollar sign.. but left associative
20:22:24 <SamB> I was trying to implement differentiation with it, but it WOULD NOT WORK
20:22:24 <weilawei> can I just redefined it's associativity?
20:22:28 <vixey> luqui: have you seen these Agda guys doing mixed recursion/corecursion
20:22:29 <Cale> lispy: Well, actually, I don't think you need much, you just flatten everything into one type, and do all the checking at runtime.
20:22:42 <roconnor> lispy: I'm not passing a moral judgement on python.
20:22:42 <luqui> vixey, no. :-)
20:22:47 <vixey> s/untyped/onetyped/ and avoid all this fuss
20:22:48 <lispy> roconnor: Well, let's say you want to use dependent types to match the tags of a python program.  You want a correspondence between the dependent types and the run-time tags
20:22:51 <Cale> weilawei: Why didn't you define it the same way then?
20:22:57 <lispy> roconnor: oh, I am.  Python is terrible.
20:23:13 <weilawei> Cale: i did and then ghc complained at me so I changed the type signature. it works now, but it's not quite right. im still working on it
20:23:13 <Cale> weilawei: just replace the definition with (<-$) = ($), and leave the fixity declaration
20:23:16 <SamB> lispy: hmm.
20:23:20 <luqui> I think neither recursion no corecursion should be built into the core calculus.  they are complicated enough concepts that they should be proven.
20:23:21 <weilawei> Cale: oh nice thank you
20:23:29 <SamB> lispy: I dunno. it could use a spell checker, for sure, though!
20:23:36 <Cale> Or f <-$ x = f x
20:23:40 <lispy> SamB: yeah
20:24:04 <Cale> which will probably give you fewer problems with the monomorphism restriction if you leave the type signature out
20:24:08 <SamB> luqui: how are you going to prove those without some kind of loop ... ?
20:24:18 <Cale> The correct type is (a -> b) -> a -> b
20:24:20 <vixey> luqui: I know how to build up structural recursion from one-step structural recursion -- but without that one-step thing (the induction principles for date types) not sure what you can do
20:24:20 <luqui> SamB, seen set theory?
20:24:29 <roconnor> lispy: I don't know what it means for dependent types to match the tags of a python program.  any given variable in a python program could have different tags at run-time.  How is a static type system supposed to match that?
20:24:31 <luqui> not that that's an ideal example, but it is an example
20:24:36 <SamB> luqui: isn't that the PROBLEM?
20:24:42 <lispy> roconnor: I use python at work daily.  I dread refactoring and making the slightest changes.  Why?  Because python lacks static analysis and pylint is too conservative/weak.  I'm trying to read up on type theory and figure out how to do static analysis of *reasonable* python programs so that refactoring is safer -- approaching the safety of refactoring in Haskell.
20:24:50 <SamB> I think topology might be a better place to start ;-P
20:25:02 <luqui> SamB, ;-)
20:25:13 <SamB> lispy: how about adding a type system of some kind?
20:25:21 <lispy> roconnor: Well, let's be fair about typical python programs.  Usually once a variable has a value of a certain tag it continues to have that same tag.
20:25:29 <SamB> you know, not a great one, but a somewhat more static one...
20:25:36 <SamB> (in places, at least)
20:25:40 <lispy> SamB: yeah, that's kind of what I would adding, regions of static type checking
20:25:43 <weilawei> Cale: well i want the arguments swapped AND left-associative xD
20:25:49 <Cale> weilawei: ah
20:25:58 <roconnor> lispy: okay.  Those programs could be type-checked by some sort of typed-python language.
20:26:00 <Cale> weilawei: In that case, a -> (a -> b) -> b
20:26:02 <luqui> vixey, well, i'm hopeful for ixi's viability.  If it's consistent then it can do these things :-)
20:26:02 <lispy> SamB: given the flexibility of a dynamically typed language, dependent types seem reasonable to me
20:26:11 <vixey> luqui: that said -- If you can justify structural recursion in terms of the simpler type theory .. why not give a direct implementation?
20:26:16 * necroforest would like a typed python language
20:26:17 <SamB> lispy: yeah.
20:26:30 <Cale> weilawei: and  x <-$ f = f x
20:26:32 <luqui> vixey, touche, I suppose.
20:26:33 <roconnor> lispy: well, some of those programs.
20:26:37 <vixey> luqui: yeah that stuff is really cool
20:26:38 <rieux_> necroforest: have you seen typed scheme?: http://www.ccs.neu.edu/home/samth/typed-scheme/
20:26:41 <lispy> (and I have a paper in my hand that claims that depnedent type checking need not be complex to implement)
20:26:42 <SamB> lispy: the tricky bit (as always) is to keep the types terminating, I think ;-)
20:26:43 <roconnor> lispy: probably a lot of them that occur in practice.
20:27:01 <weilawei> Cale: works perfectly :) many thanks for pointing that out
20:27:13 <lispy> SamB: yeah, but the programs we write at work could be written in anything, they don't really exploit the dynamicness of python
20:27:19 <necroforest> I wouldn't consider scheme very python like
20:27:20 <rieux_> necroforest: a similar approach conceivably could work for python, but the intersection of people who care and people who could do it may be . . . small.
20:27:33 <jinjing> static python? checkout  http://code.google.com/p/shedskin/
20:27:40 <roconnor> lispy: trying to approach dependent types from a dynamic-tags perspective won't really work.  They have basically nothing in common.
20:27:42 <SamB> scheme and python are exactly the same -- except that Python has syntax and comes with some libraries
20:27:48 <SamB> (well, some is an understatement ;-)
20:28:08 <lispy> jinjing: thanks, I'll look at it.  In the past, I looked for a tool like this but nothing was powerful enough.
20:28:09 <SamB> (also, new versions of Python seem to come out a bit more often)
20:28:12 <Cale> necroforest: Actually, it's reasonably similar with regard to typing, I would think...
20:28:18 <rieux_> necroforest: they're both basically the type-free lambda calculus with some crap bolted on
20:28:19 <roconnor> lispy: it is better to understand dependent types from either a logic, or GADTs perspecive.
20:28:22 <Saizan> the relation is that you'd want a type system that it's sound wrt the tags
20:28:26 <SamB> oh, and scheme doesn't have OO built in
20:28:27 <necroforest> python has significantly less parenthesis
20:28:31 <SamB> but other than that
20:28:35 <Cale> necroforest: But that's just syntax :)
20:28:44 <SamB> I mean, they are both 1-lisps, so that's pretty similar to start with ;-)
20:28:52 <roconnor> lispy: dependent types is largely (but perhaps not entirely) static phenomenom.
20:29:02 <lispy> roconnor: I've made extensive use of GADTs.  But, what do you mean?  From the persective of implementing a GADT type checker?
20:29:28 <roconnor> lispy: here is the key thing that dependent types allows you to do ...
20:29:54 <roconnor> case b of { True -> blah; False -> blue }
20:29:56 <rieux_> hm.. i suppose some of the refinement types stuff is essentially dependent types with some dynamic checks
20:30:04 <roconnor> considere the above Haskell program.
20:30:05 <lispy> jinjing: I think shedskin goes the wrong way for me.  My deliverable is python source
20:30:06 <SamB> roconnor: I think trying to approach dependant typing from the perspective of the documentation attached to dynamicly typed code might not be too unreasonable
20:30:22 <jinjing> lispy: oh, i c
20:30:25 <roconnor> blah and blue must have the same type.
20:30:31 <roconnor> so we can switch them around
20:30:38 <roconnor> case b of { True -> blue; False -> blah }
20:30:48 <roconnor> and we still get a program that type checks.
20:31:10 <roconnor> This means Haskell's type system is totally incapable of catching error of this sort.
20:31:14 <roconnor> however
20:31:19 <roconnor> with GADTs
20:31:34 <roconnor> blah and blue might have different types
20:31:44 * lispy nods
20:31:45 <Pseudonym> A program is well-typed if and only if my favourite type checker accepts it.
20:31:48 <roconnor> (although b would have to be some GADT and not booleans)
20:31:51 <Cale> lispy: hmm, but you could still use shedskin to compile your code...
20:31:56 <lispy> roconnor: I made use of GADTs in a way just like this for my MS research
20:32:08 <Pseudonym> And it's type-incorrect if and only if my favourite type checker rejects it.
20:32:08 <Cale> lispy: (just to test if it typechecks)
20:32:12 <roconnor> and so swaping blue an blah could lead to a type error.
20:32:19 <rieux_> does shedskin of a soundness theorem?  (roconnor: maybe you're right about me+math)
20:32:29 <SamB> lispy: I didn't know you bought a branch of MSR
20:32:34 <SamB> where did you get the money?
20:33:01 <roconnor> This ability to potentially catch this new class of errors is one of the things dependent type theory allows you to do.
20:33:04 <edwardk> Pseudonym: well. after suitable unsafeCoercions anyways
20:33:06 <Cale> rieux_: What about you and math? :)
20:33:23 <lispy> SamB: sorry, I don't get the joke
20:33:25 <rieux_> Cale: called me a formalist, more or less
20:33:34 <SamB> lispy: it's really bad, sorry
20:33:41 <Cale> rieux_: ah, we're in good company then :)  I'm a formalist too.
20:33:41 <SamB> your MS Research
20:33:58 <lispy> SamB: well, not microsoft research :)
20:34:01 <rieux_> Cale: i don't think i am (i say as i head back to my proof)
20:34:10 <vixey> You can reflect computational aspects of your programs into the type system
20:34:32 <vixey> that is what dependent product & beta reduction is giving
20:34:38 <Cale> rieux_: These guys are all constructivists, so watch out ;)
20:34:50 <vixey> I am not constructivist :(
20:34:51 <roconnor> GADTs allow you to do a limited form of dependent type theory.
20:34:57 <SamB> Cale: well, there's a reason for that
20:35:01 <NEEDMOAR_> :-)
20:35:03 <SamB> we like our proofs computable ;-P
20:35:05 <Saizan> "you are one of those people who believe a math result is true only after someone proves it, and that it wasn't  true before the proof." <- i'm not sure if this has to do with being a formalist
20:35:23 <lispy> roconnor: I have experienced this aspect of GADTs...otherwise I would not have discovered and read about dependent types
20:35:34 <Pseudonym> Saizan: I can read that in two ways, one of which makes sense.
20:35:37 <rieux_> Saizon: well, it excludes being a Platonist
20:35:40 <roconnor> But true dependent type theory gives you full on dependent products and dependent functions.
20:35:41 <Pseudonym> It makes sense not to _believe_ a result before the proof.
20:35:52 <rieux_> it makes sense not to believe before
20:35:53 <Pseudonym> So the belief may not be true.
20:36:00 <rieux_> but afterward, would you still believe that it wasn't true before?
20:36:06 <roconnor> and allows you to check any property of your code that can be expressed in the language of mathematics.
20:36:24 <Saizan> yeah, but it's not like the theorem were not true before the proof
20:36:31 <SamB> roconnor: well, lets you try!
20:36:42 <roconnor> SamB: right
20:36:45 <Saizan> i.e. you couldn't find a counterexample
20:36:45 <ksf> truth is what stays even though you don't believe in it.
20:36:55 <Cale> Depends on what you mean by "true". I'm of the opinion that mathematics is an entirely human invention, but it's possible to metamathematically define a set of true statements of a theory via what follows from the axioms.
20:37:02 <SamB> Saizan: what do counterexamples have to do with it ?
20:37:25 <roconnor> and allows you to valid any provable property of your code that can be expressed in the language of mathematics.
20:37:30 <roconnor> validate
20:37:33 <edwardk> i figure the truth was there before, its just that we didn't recognize it. i believe there is enough truth out there that there can be quite a bit of room for how that underlying truth can be framed, though, so I figure mathematicians and philosophers have plenty of stuff I can take ownership of in terms of construction. How is that for diplomatic neutral ground?
20:37:39 <SamB> Saizan: well, I mean, besides that if you have both a counterexample and a proof, you've got a very big problem ;-P
20:37:52 * roconnor is an ultrafinitist
20:38:01 <Cale> So while theorems don't really exist before we write them down, there's a sense in which they belong to that set.
20:38:19 <SamB> Cale: AH! not SETS!
20:38:26 <rieux_> my model ain't no set!
20:38:29 * SamB runs around screaming
20:38:39 <Saizan> SamB: that was my point, more or less
20:38:40 * lispy throws lambdas at SamB 
20:38:55 * SamB licks them
20:38:56 <vixey> Cale but when you start to name sets like that everything goes wonky
20:38:59 <lispy> SamB: that was a continuation I just passed you...
20:39:06 <Pseudonym> I use "collection" if in doubt.
20:39:37 <roconnor> <rieux_> does shedskin of a soundness theorem?  -- I don't understand the word "shedskin"
20:39:48 <SamB> anything that can turn one sphere into to spheres can't be terribly safe!
20:39:48 <rieux_> whoa
20:39:52 <lispy> roconnor: it's the python to C++ translator
20:39:53 <Cale> vixey: I mean, you can take some theory, and formalise it *inside* of another theory, so that it becomes possible to talk about such sets of statements.
20:39:59 <SamB> s/to spheres/two spheres/
20:40:03 <tiglionabbit_> argh.  These options are in the help message for cabal, so why can't I use them?  http://www.friendpaste.com/4rtkmlE1CrMA5vVdqj66uG
20:40:05 <rieux_> s/of/have/
20:40:08 <Cale> vixey: You can't really do it for your outermost theory though.
20:40:43 <hatds> maybe you could define a theory whose axioms allow you to talk about the statements of itself
20:41:03 <Cale> In any case, sets are the right abstraction here, no matter what formalism you're using, and I'm not apologising for it ;)
20:41:08 <Saizan> tiglionabbit_: check the spelling of extra
20:41:08 <lispy> hatds: I bet it would either be inconsistent or incomplete :)
20:41:20 <SamB> lispy: that isn't much of a bet
20:41:38 <Cale> In some sense, any system suitable for mathematics can discuss itself.
20:41:40 <SamB> that's more-or-less proven
20:41:56 <hatds> it's not really pure though
20:42:14 <SamB> I mean, there may be a few systems that are all three: self-describing, complete, and consistant
20:42:18 <Cale> tiglionabbit_: exttra
20:42:23 <SamB> but they're pretty small
20:42:28 <Cale> tiglionabbit_: (you misspelled the option)
20:42:34 <roconnor> SamB: and undecidable
20:42:40 <SamB> and won't talk about any interesting systems ;-)
20:42:45 <hatds> everything in set theory is sets, you can't have a set of "first order logic sentences in at most 5 symbols", you can only create a set with N elements and interpret them that way.
20:42:51 <tiglionabbit_> oh gosh silly me
20:42:52 <Cale> ah, hehe, there's too many conversations getting interleaved here :)
20:43:08 <SamB> smaller than TNT, anyway
20:43:19 <roconnor> SamB: the true statements of PA form a complete and consistent system that is argubably self-describing.
20:43:20 <Cale> hatds: But you can do that, if you define 'first order logic sentences' in the right way :)
20:43:25 <Cale> hatds: (as a set)
20:43:26 <NEEDMOAR_> Cale: see? We need that channel!
20:43:41 <Cale> We have #haskell-in-depth...
20:43:44 <vixey> what channel
20:43:54 <SamB> roconnor: hmm. maybe a little more interesting than I thought
20:43:55 <NEEDMOAR_> Cale: nobody's talking over there!
20:43:58 <Cale> NEEDMOAR was asking me to make a #compsci
20:44:00 <roconnor> SamB: unless you require a "system" to be (semi-)decidable.
20:44:01 <vixey> ugh
20:44:09 <tiglionabbit_> Cale: thanks for that.  Unfortunately, it's still not using the libraries I want it to.  How can I make it compile with the right version of openssl?
20:44:14 <Cale> actually people do talk in #haskell-in-depth regularly enough
20:44:16 <vixey> every 'programmers' or computerology channel miserably fails
20:44:34 <SamB> roconnor: hmm. I don't think I do.
20:44:37 <Gracenotes> except those which turn into social channels
20:44:37 <Cale> tiglionabbit_: I'm not sure. Remove the other version of openssl? :)
20:44:43 <NEEDMOAR_> vixey: it was more theoretical comp. sci., logic, type theory, universal algebra, category theory, etc.
20:44:46 <tiglionabbit_> Cale: I'm pretty sure it's part of my OS
20:44:49 <Cale> tiglionabbit_: I'm not sure how it decides which to link in.
20:44:55 <SamB> roconnor: I don't remember TNT being!
20:45:07 <tiglionabbit_> I guess I could remove it temporarily, but that seems dangerous
20:45:12 <Gracenotes> ##programming is actually pretty successful
20:45:14 <vixey> ##algorithms is specific enough to not become tedious nonsense abotu godel
20:45:20 <edwardk> well, there is #oasis floating around here which is basically just a 'programming semantics' channel
20:45:28 <Gracenotes> except it's more of a social channel, and hard to start a real compsci discussion
20:45:36 <SamB> vixey: are you talking about me?
20:45:37 <Cale> tiglionabbit_: maybe dcoutts would know
20:45:38 <Gracenotes> vixey: yeah, but it's dead. :.
20:45:57 <vixey> SamB: no -- did you mention Godel?
20:46:06 <SamB> vixey: not by name
20:46:45 <SamB> also isn't there supposed to be, er, dots above that o?
20:46:57 * SamB can't seem to type them at the moment
20:47:03 <roconnor> Goedel
20:47:06 * SamB also needs to go to bed now...
20:47:10 <Gracenotes> girdle!
20:47:11 <roconnor> or with an umlut
20:47:14 <Cale> I already have enough channels that I miss people's PMs.
20:47:38 <lispy> Cale: you just made me think of a bad joke
20:47:50 <Gracenotes> tell it :,
20:48:12 <lispy> Gracenotes: not really #haskell appropriate
20:48:30 <rieux_> in #badjokes then
20:49:29 <vixey> edwardk: (it's too bad I'm mostly into syntatic approach to programming languages..)
20:49:36 <vixey> stuff like type systems etc
20:49:57 <hatds> types rule so you are in good company
20:50:10 * vixey lacks years of domain theory and topology to study semantics
20:50:26 <edwardk> vixey: i'm in the same boat alas
20:50:38 <edwardk> vixey: i mostly just go in there to talk syntax and piss them off =)
20:50:42 <lispy> vixey: hmm..you put types in a the syntatic category?  But, types are related to the evaluation right?  so does that mean types bridge syntax and semantics?
20:51:00 <koninkje> a good deal of semantics is actually syntactic (in the way types are)...
20:51:04 <rieux_> a type system is a denotational semantics...
20:51:15 <rieux_> the domain is just less scary than P_\omega
20:51:20 <vixey> edwardk: (I know they really just mean "don't go on about lisp vs XML" but I am being picky :p)
20:51:37 <edwardk> heh
20:52:08 <roconnor> I'm a quite hesitant to put types in the semantics category.
20:52:27 <rieux_> really?  it meets the definition
20:52:37 <rieux_> people also say "static semantics," so it's not far from actual usage
20:53:12 <koninkje> lispy: I'd say so. But then I'm a morphologist instead of a grammarian or semanticist
20:53:19 * Cale sets out to devise a semantics for Haskell which associates individual terms with Hausdorff topological spaces. ;)
20:53:25 <vixey> morphologist sounds really cool :p
20:53:33 <roconnor> the fact that types are preserved during reduction is usually a difficult theorem.
20:53:44 <edwardk> I've always hated semantics. I mean look at it! its a plural pretending to be singular. Its clearly just making this up as it goes along and no one calls it on its hypocrisy.
20:53:46 <roconnor> (and doesn't even hold in Coq ... grrrr)
20:53:54 <rieux_> roconnor: really?  maybe in denotational semantics it is
20:54:01 <vixey> lol
20:54:05 <lispy> roconnor: heh, really?  So Coq lacks that part of type safety?
20:54:06 <rieux_> but wright and felleisen made it easy
20:54:25 <vixey> lispy: convertability checking of infinite objects is undecidable
20:54:42 <vixey> so if you don't put any coinductive data into the type system you're ok
20:54:42 <Cale> roconnor: What makes it challenging?
20:54:44 <roconnor> I think denotational semantics is independent of type theory.
20:54:48 <koninkje> The semantics I've liked are all, on some level, just type theory or transformations of interesting grammars
20:54:57 <lispy> vixey: ah
20:55:12 <edwardk> koninkje: morphology is tough because you have to deal with all the crap that the phonology folks don't want to think about or that the syntax folks think should already be taken care of for them. ;)
20:55:17 <roconnor> Cale: I'm not entire sure.  I've never done a proof.  Heck, I've never even managed to follow an existing proof.
20:55:28 <lispy> vixey: I've read just enough of sigfpe's blog to grok that but no more
20:55:56 <mmorrow> , "[0..]" == "[0..]"
20:55:57 <lunabot>  True
20:55:58 <vixey> roconnor: You haven't read TAPL? they cover progress ever 5 pages!
20:56:23 <hatds> TAPL is a great book
20:56:31 <koninkje> edwardk: tis true. Both sides want to pretend it doesn't exist (or is the other side's problem, to the extent it does exist)
20:56:43 <Saizan> btw TAPL you just need subtyping to lose preservation of types
20:56:59 <ksf> denotional semantics, as opposed to operational semantics, is what you get when you suddenly realise that you can do stuff with the stuff that you made out of stuff.
20:57:19 <Twey> , [0..] == [0..]
20:57:26 <lunabot>  Killed.
20:57:42 <mmorrow> omg lunabot can't decide!
20:57:45 <Twey> @src [a] (==)
20:57:46 <lambdabot> Source not found. It can only be attributed to human error.
20:57:51 <Twey> @src [] (==)
20:57:51 <lambdabot> []     == []     = True
20:57:52 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
20:57:52 <lambdabot> _      == _        = False
20:58:14 <rieux_> roconnor: have you tried to read "A Syntactic Approach to Type Soundness": http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.5122 ?
20:58:22 <Saizan> (\x::{a:Int} -> x) {a = 1,b = 2} :: {a:Int} but that reduces to {a=1,b=2} :: {a:Int,b:Int}
20:58:23 <roconnor> rieux_: nope
20:58:26 <vixey> Saizan: but you can change the relation to like  is more specific  instead of equal  and it goes ok?
20:58:38 <rieux_> roconnor: no guarantees, but if you care, its designed to be comprehensible
20:58:42 <Saizan> vixey: yeah
20:59:00 <roconnor> rieux_: I take soundness on faith.
20:59:13 <rieux_> roconnor: don't use ocaml then :)
20:59:39 <roconnor> because type systems are proof systems, they could potentially be inconsistent.
21:00:08 <rieux_> what does it mean for a type system to be inconsistent?
21:00:29 <vixey> ocaml is not sound?
21:00:35 <rieux_> vixey: now and then
21:00:45 <vixey> I thought there was a problem with mutable references but it got fixed ?
21:00:45 <rieux_> neither is GHC haskell, of course
21:01:03 <vixey> oh yeah I ignore Obj.magic and unsafeCoerce
21:01:03 <roconnor> hmm, maybe inconsistent isn't the right word here
21:01:04 <rieux_> if you're referring to the value restriction in ML, yeah, that got fixed in the 90s
21:01:09 <roconnor> unsound is probably better.
21:01:44 <roconnor> So you could have unsound type systems, although people strive to avoid this.
21:02:00 <roconnor> But I'd still call an unsound type system a type system.
21:02:05 <roconnor> but it would be a bad type system
21:02:09 <rieux_> vixey: more like, ive several times encountered type system extensions in minor releases that they retract in the next release
21:02:11 <roconnor> even worse than an untyped system. :)
21:02:19 <rieux_> roconnor, sure it's a type system
21:02:29 <rieux_> but the theorems it proves aren't very interesting
21:02:39 <rieux_> possibly
21:02:49 <roconnor> this may illustrate the difference between denotational semantics (or any semantics) and type systems.
21:02:59 <rieux_> why is that?
21:03:27 <Cale> @quote inconsistent
21:03:27 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
21:03:30 <Cale> @quote inconsistent
21:03:30 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
21:03:35 <Cale> @quote intuitionist
21:03:36 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
21:03:44 <roconnor> because I can take an untyped langauge with semantics on it, and slap an unsound type system that has nothing to do with it's semantics on top.
21:03:59 <rieux_> sure, but no one cares if you do that
21:04:14 <rieux_> you can also slap a different semantics on it that's inadequate with respect to the first one
21:04:16 <roconnor> heh, I like that quote of mine.
21:04:46 <roconnor> rieux_: but if denotational semantics were related to the type system, then this would be impossible.
21:04:59 <Cale> roconnor: Seems lambdabot does too :)
21:05:06 <rieux_> well, the theorem you need to prove that makes anyone care about the type system is that the two are related
21:05:14 <roconnor> right
21:05:22 <roconnor> that is probably soundness and completeness
21:05:46 <rieux_> usually nothing very much like completeness.
21:05:48 <roconnor> so I perhaps I can agree that semantics and sound type systems are related.
21:06:21 <rieux_> well, i should take that back.  you might make two versions of your type system and prove that one is complete for the other.
21:06:28 <rieux_> that's pretty common, actually
21:06:40 <vixey> completeness is harder to prove than soundness?
21:06:56 <rieux_> vixey: for what?
21:07:11 <rieux_> or: i dont know what it means to say a type system is complete.
21:07:19 <rieux_> do you mean: "all programs that don't go wrong have a type?"
21:07:24 * Cale opens an orphanage for unsound and incomplete type systems who have nobody else to care for them.
21:07:24 <rieux_> that's usually not a theorem.
21:07:53 * Twey laughs.
21:08:20 <Twey> Cale's Home for Outdated Typesystems
21:08:38 * rieux_ is sorry for suggesting he doesn't care
21:09:01 <roconnor> vixey: I'm trying to understand the comments in your LtU thread.
21:09:14 <Saizan> well, you can't have an interesting type system that's both consistent and complete, so you've to make a choice
21:09:21 <roconnor> vixey: Some seem to think there is a difference between "dynamic types" and tags
21:09:27 <roconnor> but I don't really get it
21:09:35 <roconnor> ... although I suppose you don't either
21:10:10 <Cale> Saizan: Only if the system can discuss the truth of universally quantified statements about arithmetic...
21:10:56 <roconnor> @kind * -> * -> * + * -> *
21:10:57 <lambdabot> parse error on input `*'
21:11:12 <vixey> roconnor: I just think "confused people" and ignore it
21:11:31 <vixey> roconnor: but it was funny that someone really mixed up what was going on in that code
21:11:33 <Cale> which ltu thread?
21:11:45 <roconnor> http://lambda-the-ultimate.org/node/3298
21:12:32 <Saizan> Cale: it also has to do with the semantics of the underlying language i guess
21:12:48 <roconnor> > let f x = case x of { Left _ -> True } in f Right ()
21:12:49 <lambdabot>   Couldn't match expected type `Either t t1'
21:12:56 <rieux_> oy.  you have summoned sam and paul
21:12:57 <roconnor> > let f x = case x of { Left _ -> True } in f (Right ())
21:13:00 <lambdabot>   * Exception: /tmp/1780029698889346754:71:42-69: Non-exhaustive patterns in ...
21:13:08 <roconnor> look, a run-time type error!!
21:13:10 <roconnor> :D
21:13:25 <vixey> if null xs then head x ...
21:13:30 <vixey> if null xs then head xs* ...
21:13:33 <rieux_> > 1 `div` 0
21:13:34 <lambdabot>   * Exception: divide by zero
21:14:26 <lispy> > 1 `div` 0 :: Expr
21:14:27 <lambdabot>   1 `div` 0
21:14:36 <lispy> yay! I fixed divide by 0.
21:14:51 <roconnor> lispy: you should publish in a paper
21:14:56 <roconnor> such as the Guardian
21:15:04 <rieux_> @info Expr
21:15:04 <lambdabot> Expr
21:15:06 <lispy> roconnor: yeah, like that one guy
21:15:10 <rieux_> @source Expr
21:15:11 <lambdabot> Expr not available
21:15:13 <rieux_> grrr
21:15:42 <roconnor> > simplify (1 `div` 0)
21:15:43 <lambdabot>   Not in scope: `simplify'
21:15:48 <roconnor> > simpl (1 `div` 0)
21:15:49 <lambdabot>   Not in scope: `simpl'
21:15:58 <roconnor> @hoogle Expr -> Expr
21:15:59 <lambdabot> Warning: Unknown type Expr
21:15:59 <lambdabot> Prelude id :: a -> a
21:15:59 <lambdabot> Data.Function id :: a -> a
21:16:26 <hatds> someone stole all the expressions
21:16:35 <lispy> I forgot which guy, but the one that said he came up with a new number system by adding a symbol to represent divison by 0
21:17:00 <rieux_> Leibniz?
21:17:05 <lispy> nah, recent guy
21:17:06 <roconnor> > reduce (1 `div` 0)
21:17:07 <lambdabot>   * Exception: divide by zero
21:17:18 <hatds> :t reduce
21:17:19 <lambdabot> Expr -> Expr
21:17:20 <rieux_> Abraham Robinson?
21:17:32 <rieux_> hmm.  or IEEE?
21:17:34 <lispy> The nullity guy
21:17:36 <lispy> not IEEE
21:17:39 <rieux_> oh, that was lame
21:17:53 <rieux_> > 1 / 0
21:17:54 <lambdabot>   Infinity
21:17:56 <Cale> The media coverage of it was lamer than his actual paper.
21:18:07 <roconnor> http://en.wikinews.org/wiki/British_computer_scientist's_new_"nullity"_idea_provokes_reaction_from_mathematicians
21:18:18 <lispy> http://en.wikipedia.org/wiki/James_Anderson_(computer_scientist)#Transreal_arithmetic
21:18:44 <Cale> If you read what it was that he actually did, it was not still not all that exciting, but it seemed worthwhile that someone would go to the trouble of doing it.
21:19:34 <Cale> Basically, it's an IEEE-floating-point-like extension of the reals. He and a couple other guys set out to prove what they could about it.
21:19:34 <vixey> is it an different from R U {infinity} ?
21:19:34 <roconnor> hmmm
21:19:38 <roconnor> ``â NaN = NaN (i.e. applying unary negation to NaN yields NaN)
21:19:52 <Twey> Oh, he's the guy who came up with ânullityâ
21:19:53 <Cale> It has +Infinity, -Infinity and NaN
21:19:59 <rieux_> \Phi = \Phi  ==> True
21:20:00 <Cale> (or nullity)
21:20:04 <rieux_> makes me wonder if it's consistent
21:20:05 <vixey> oh right
21:20:08 <roconnor> let nan = read "NaN" in - nan == (nan :: Double)
21:20:10 <roconnor> > let nan = read "NaN" in - nan == (nan :: Double)
21:20:12 <lambdabot>   False
21:20:18 <rieux_> if he went with false like IEEE, then it's just bottom
21:20:28 <Cale> He wouldn't want to...
21:20:41 <rieux_> right.  so is it consistent?  still reading...
21:20:44 <Twey> "If anyone doubts me I can hit them over the head with a computer that does it."
21:20:45 <Cale> He's inheriting the usual notion of mathematical equality
21:20:47 <Twey> Hahaha
21:20:47 <roconnor> I guess that's why they have the comment.
21:20:51 <Cale> It's consistent, but it's not a ring.
21:20:57 <roconnor> god, IEEE makes a mess out of =
21:21:08 <rieux_> hm.  no more additive inverse.
21:21:11 <roconnor> > let nan = read "NaN" in nan + 1 == (nan :: Double)
21:21:12 <lambdabot>   False
21:21:16 <Cale> right
21:21:23 <roconnor> > let nan = read "NaN" in 0/0 == (nan :: Double)
21:21:24 <lambdabot>   False
21:21:54 <Twey> NaN != NaN
21:21:54 <lispy> "Anderson has been trying to market his ideas for transreal arithmetic and "Perspex machines" to investors. In this process, he has founded a British company called Transreal Computing Ltd. which is attempting to get funding to build a transreal computer capable of dividing by zero,[7][12] a capability already possessed by contemporary computers using the IEEE arithmetic model."
21:21:58 <ksf> If you ask me, division by zero has one or two results, either 0 or (+inf,-inf)
21:22:01 <rieux_> i was about to paste that same thing
21:22:14 <lispy> I love the conclusion.
21:22:14 <Cale> lispy: Yes, his other work is very very quackish.
21:22:24 <rieux_> so... if we wrote a Haskell module, think we could get investors too?
21:22:31 <Twey> Haha, I can't honestly believe he's serious
21:22:39 <Twey> It's got to be a stunt
21:22:41 <roconnor> oh god Transreal Computing Ltd.
21:22:43 <Cale> Actually, I wonder how that can work as a physical device.
21:22:46 <Pseudonym> ksf: Except that 0/0 is NaN.
21:22:55 <Cale> His addition isn't even a continuous map.
21:23:00 <hatds> I hate to say if, but if he really did quit his job to start a company around this idea, then maybe he is getting what he deserves
21:23:05 <hatds> *if=this
21:23:09 <Cale> Well...
21:23:09 <Twey> Haha
21:23:20 <lispy> Cale: well, you can think of the adder circuit in hardware as just one big lookup table
21:23:38 <lispy> Cale: so non-continuous shouldn't be an issue
21:23:40 <Pseudonym> IEEE floating point numbers are finite domains.
21:24:02 <Cale> lispy: But the idea in his case I think was to represent numeric quantities with physical quantities, like perhaps the angle at which a beam of light was travelling, or something.
21:24:39 <ksf> weren't analog computers abandoned for good?
21:24:40 <Pseudonym> Analogue computers, woo.
21:24:51 <Pseudonym> ksf: Yes and no.
21:25:01 <Pseudonym> Technically, they still exist.
21:25:01 <lispy> Cale: well it may pose an issue for libraries that do arbitrary precision reals, but I think for the hardware it's like Pseudonym points out, the domains are finite
21:25:04 <Twey> Analogue computers may be the future.  Some day.
21:25:08 <augustss> mmmm, dividing by 0
21:25:10 <Pseudonym> If you count certian types of music synthesizer, for example.
21:25:19 <Cale> lispy: The transreals are not finite.
21:25:30 <Cale> lispy: They're the reals adjoined with some extra elements.
21:25:38 <lispy> Cale: no, but the # of bit patterns that you can represent with a fixed set of bits is :)
21:25:44 <Cale> sure
21:25:51 <Twey> So what exactly *is* a Perspex Machine?
21:25:54 <Cale> But that's... I don't know where you're getting that.
21:26:01 <Adamant> Analog computers still exist.
21:26:02 <Cale> Twey: I don't really know.
21:26:02 <Pseudonym> Twey: Like a normal machine, only you can see through it.
21:26:08 <Cale> hehehe
21:26:08 * Twey laughs.
21:26:13 <Twey> That's exactly what I thought
21:26:13 <augustss> Twey: if you pay, perhaps you can find out :)
21:26:14 <Adamant> they are still used for a handful of problems.
21:26:18 <Twey> Haha
21:26:19 <ksf> anyway, all you get is great precision and fuzzyness, both for free, as physics is still discrete.
21:26:29 <Pseudonym> I still use a slide rule on occasion.
21:26:29 <lispy> Cale: well, I mean, you'd just implement IEEE with a few modifications and you could have perspex machine
21:26:41 * vixey divides augustss by 17
21:26:48 <Cale> Turns out that Anderson was really just wanted to come up with a cool case mod and get university funding to do it.
21:26:54 <Cale> -was
21:26:54 * Twey laughs.
21:26:57 <Pseudonym> Who can blame him?
21:26:58 <Adamant> the development of memresistors may set off a burst of new research into analog computing.
21:26:58 <lispy> Cale: hehe
21:27:28 <augustss> I remember doing a control theory lab on an analog computer.  It was really cool.
21:27:41 <Pseudonym> Adamant: I've thought for a while that, say, LDPC decoding might be better done in analogue hardware.
21:27:48 <Adamant> LDPC?
21:27:55 <Pseudonym> Low density parity check.
21:27:58 <Adamant> ah
21:28:07 <wli> Depletion of rare earth elements is probably going to throw most computing into the dustbin.
21:28:11 <Pseudonym> Or difference map-type optimisation.
21:28:15 <Pseudonym> Actually...
21:28:28 <Pseudonym> Woah.  You COULD do a difference map optimisation in analogue hardware.
21:28:35 <Pseudonym> Sudoku solver in analogue components.
21:28:40 <augustss> Pseudonym: but is it really analog, and not multilevel digital?
21:28:41 <ksf> well, i might trust an analogue adder with physics calculations, but it's going to be a hard sell if i'm supposed to do array indexing with it.
21:28:43 * Pseudonym rushes off to the patent office
21:29:50 <wli> I'm not entirely sure what all can survive it. I'm pretty sure not most recent VLSI.
21:30:13 <Pseudonym> They also used to use analogue computers for economical modelling.
21:30:19 <roconnor> wli: dude, the ocean is full of stuff!
21:30:30 <Adamant> we need our Mr. Fusion
21:30:55 <ksf> afaik, you can synthesise each and every single element.
21:31:09 * roconnor breaks out the carbon nano rod computing.
21:31:14 <wli> roconnor: I guess there are a large number of assumptions involved.
21:31:19 <scutigera> wli: there are also organic semiconductors which are improving rapidly
21:31:20 * Pseudonym breaks out the technetium-plutonium magnets
21:31:42 <Pseudonym> My boss invented a semiconductor made out of carbon, yes.
21:31:46 <Pseudonym> Former boss.
21:31:54 <roconnor> oh right that too
21:32:00 <roconnor> I was thinking of rod logic
21:32:25 <Pseudonym> Rod Logic: Private Investigator
21:32:35 <scutigera> Pseudonym: all you need is a switch
21:32:36 <ksf> hmm. What if our whole existence is just a quickcheck case to test the universe?
21:32:55 <wli> scutigera: Those could help, depending on a lot of factors.
21:32:56 <Pseudonym> ksf: Then I'm a failing test case.
21:33:14 <augustss> ksf: I think we're the real run
21:33:30 <ksf> well, the trick would be to find a bug without failing the test.
21:33:39 <Pseudonym> At the very least, we owe it to the Developer to test the system to breaking point.
21:33:51 <scutigera> wli: the energy required to make modern semi's is the real problem, not so much the materials, IMHO.
21:34:23 <wli> scutigera: It's a more immediate problem; however, the materials are also problematic.
21:34:24 <rieux_> hmm... i remember nick bostrom arguing that we ought to try to be interesting enough that our simulators won't want to shut us off.
21:34:47 <ksf> that's a healthy attitude.
21:34:52 <Cale> I wonder if our simulators have even noticed us.
21:35:03 <Cale> Supposing that they exist.
21:35:25 <rieux_> I kind of hope they do, because if they don't, we probably won't get a chance to try it either.
21:35:40 <roconnor> rieux_: good thing we have 4chan
21:35:55 <ksf> you can assume that if we're running in a metaverse, it's an unsanctioned side-project running on spare time on a mainframe allotted for finance calculations.
21:36:01 <Cale> Imagine running a massive universe-sized version of Conway's game of life with all sorts of random crap going on, and trying to find the most interesting parts of it.
21:36:12 <scutigera> Cale: please- this lunatic asylum called planet earth, who wouldn't be entertained and horrified all at once
21:36:16 <rieux_> you'd look at the edges
21:36:22 <vixey> Cale, just use grep :p
21:36:37 * sjanssen wonders if he's stumbled into #haskell-blah
21:37:32 <Pseudonym> Cale: More like Core War than Conway's Life, I suspect.
21:37:35 <wli> scutigera: Ore yields are rather dire across the board. Almost the only things not facing instant problems from energy/liquid fuel depletion are iron and aluminum.
21:38:01 <Pseudonym> Uhm... did anyone just smell a wumpus?  Or was it just me?
21:38:03 <Pseudonym> Spooky.
21:38:14 <Cale> Pseudonym: well, with core war, you at least know what programs are running...
21:38:33 <Cale> (or, where the execution pointers are anyway)
21:38:48 <Pseudonym> Yeah, you know how many programs are running.
21:38:52 <roconnor> wli: other than uranium, we generally don't use up matterial.  We just simply make it expensive to recover.
21:39:10 <ksf> hmmmmm... does the universe really run on multiple cores, or is the plank scale just small enough to squeeze every local update into a big update loop?
21:39:16 <Pseudonym> roconnor: There's no reason why you couldn't make uranium from waste plutonium.
21:39:24 <roconnor> :)
21:39:26 <wli> roconnor: s/expensive/infeasible/
21:39:31 <roconnor> or gold from lead
21:39:37 <scutigera> wli: don't think the problems is instant, but it's on the way, but I'm a doomer so don't listen to me :-)
21:39:48 <Pseudonym> roconnor: OK, we could run out of philosopher's stone.
21:39:51 <dons> mux: around?
21:39:52 <roconnor> scutigera: wli is a doomer
21:40:00 <Twey> Pseudonym: I smelt a Wonko the Sane
21:40:04 <ksf> duh, we can't run out of energy, as there's a fixed amount of it.
21:40:19 <hatds> that's a relief
21:40:23 <Twey> Phew
21:40:27 <Twey> Energy crisis over
21:40:29 <scutigera> Pseudonym: heard of Thorium cycle ?
21:40:31 <Twey> Let's all go back to bed
21:40:51 <hatds> good meeting everyone
21:40:52 <roconnor> Twey: we have a new Negentropy crisis.
21:40:56 <vixey> @remember <ksf> duh, we can't run out of energy, as there's a fixed amount of it.
21:40:57 <lambdabot> Done.
21:40:58 <Cale> That's a relief! I'm tired from all that worrying about running out of energy.
21:41:03 <Pseudonym> scutigera: Have now.
21:42:04 <wli> roconnor: More accurate, sure.
21:42:19 <scutigera> Pseudonym: interesting stuff.  Don't think there is a commercial demonstration, but I believe there are a couple of research reactors.  i think they are run using haskell...(just trying to stay on topic)
21:42:24 <vixey> :(
21:42:31 * vixey can't get away with not install cabal
21:42:47 <Cale> But as long as we have the sun, we could power the entire world with a handful of metropolis-sized solar collectors if things got really tough.
21:42:55 <ksf> cabal install fusion-reactor
21:42:57 <scutigera> Cale: truly
21:43:14 <scutigera> Cale: should, even if things don't get tough
21:43:18 <Cale> scutigera: yes
21:43:25 <ksf> we need that package.
21:43:30 <Cale> scutigera: Though it's probably easier to spread them out.
21:43:47 <scutigera> now where did I put that antimatter generator monad...it's around here somewhere
21:43:55 <Twey> Cale: I like the sound of that
21:44:03 <ksf> connect a magnet donut to your usb port and you're done.
21:44:08 <Twey> I think New York should be converted to a solar panel.
21:44:17 <Pseudonym> The thing that shocks me is that fusion reactors are shockingly easy to build.
21:44:21 <scutigera> Twey: how about DC ?
21:44:28 <Pseudonym> It's just that getting them to output more energy than you put in is hard.
21:44:32 <hatds> solveEnergyCrisis :: World -> World
21:44:32 <Twey> They have nice cherry trees
21:44:41 <Twey> Hahaha
21:44:49 <scutigera> solveEnergyCrisis :: Sun -> Joules
21:44:50 <Twey> Pseudonym: *nods*
21:45:03 <Cale> I think that guy from the Google talk may well have had a good point about recirculating spherical reactors.
21:45:06 <ksf> there's a lot of feasible fusion and fission technologies, the main problem is that most can't be used to build nukes, and thus aren't researched.
21:45:21 <Twey> Ha
21:45:34 <Pseudonym> Cale: There's some physical limit which fusion researchers mention which he hasn't mentioned in any of his talks.
21:45:37 <Pseudonym> I forget the name of it.
21:46:01 <copumpkin> the zomg limit
21:46:05 <Cale> Pseudonym: Well, he does mention the traditional reason that sort of reactor doesn't work.
21:46:06 <copumpkin> I think
21:48:13 <scutigera> Cale: electrostatic confinement?
21:48:17 <ksf> ...don't forget http://en.wikipedia.org/wiki/Cold_fusion
21:48:27 <Cale> scutigera: yeah, that's the idea
21:48:35 <Pseudonym> Oh, Robert Bussard died.
21:48:44 <Pseudonym> A couple of years ago.
21:48:47 <Cale> Pseudonym: he did, but his company still exists
21:48:58 <Cale> and I think they did get the research grant he wanted
21:49:16 <Cale> http://en.wikipedia.org/wiki/File:Breakdown_of_the_incoming_solar_energy.svg -- Average human consumption is only about 15 TW.
21:50:33 <scutigera> Cale: as I'm sure you know solar works.  It's a false cost issue because fossil fuels are subsidized.  There is a storage issue, but that's what electric cars are for :-)
21:50:47 <Cale> scutigera: yeah
21:51:15 <scutigera> Cale: US consuption is just under 1 TW ?
21:52:13 <Cale> "In 2005, total worldwide energy consumption was 500 Exajoules (= 5 x 10^20 J) with 80-90% derived from the combustion of fossil fuels.[1] This is equivalent to an average energy consumption rate of 16 TW (= 1.6 x 10^13 W)"
21:52:43 <Cale> Let's see...
21:52:55 <scutigera> US Electricity consumption is 1 TW-Hr per year.
21:53:16 <Cale> Yeah, this number includes apparently all energy usage.
21:53:21 <luqui> what a... difficult unit of power
21:53:21 <Cale> Not just electricity
21:53:32 <scutigera> I think I calculated about 25 mi x 25 mi of solar cells to power us for electric only
21:53:45 <Cale> luqui: that would be energy rather than power
21:53:52 <Cale> TW/Hr would be power :)
21:53:58 <luqui> no, that would be power per time
21:54:09 <Cale> uh, oh, right
21:54:16 <Cale> TW is power :)
21:54:20 <luqui> :-)
21:54:32 <Cale> I thought you were referring to TW hr
21:54:43 <scutigera> he-man has the power, or was that skeletor ?
21:55:06 <copumpkin> she-man?
21:55:20 <scutigera> well, really it's THE MAN
21:55:38 <mmorrow> this sight is pretty neat http://www.sq.ro/
21:55:41 <mmorrow> site
21:55:46 <Cale> TW hr/year is a strange unit of power
21:55:49 <mmorrow> well, freudian slip
21:56:06 <copumpkin> Cale: indeed!
21:56:06 <scutigera> Cale: I calculated US $1 trillion to install solar for US electrical capacity at $5/W
21:56:35 <roconnor> oh, so that is like a day in Iraq
21:56:52 <Cale> 1 ((terawatt hour) / year) = 0.000114079553 terawatts
21:57:17 <roconnor> @go 1 terawatt hour / year
21:57:18 <lambdabot> http://en.wikipedia.org/wiki/Watt-hour
21:57:18 <lambdabot> Title: Kilowatt hour - Wikipedia, the free encyclopedia
21:57:21 <scutigera> showEFloat
21:57:22 <luqui> Man, that car is going well over 15 kilometers squared per mile-second!
21:57:24 <roconnor> oh right, that doesn't work anymore
21:57:33 <copumpkin> lol
21:57:34 <Cale> @go 1 terawatt hour / year in terawatts
21:57:35 <lambdabot> http://en.wikipedia.org/wiki/Watt-hour
21:57:35 <lambdabot> Title: Kilowatt hour - Wikipedia, the free encyclopedia
21:57:38 <Cale> pff
21:57:38 <Cale> yeah
21:58:02 <Cale> Also, google calculator doesn't appear to know what TW is.
21:58:24 <Cale> You have to write terawatt apparently.
21:59:04 <Cale> luqui: haha
21:59:11 <hatds> or just ask for hours per year
21:59:26 <Cale> which also doesn't work...
21:59:28 <luqui> @go convert 1 terawatt hour / year to terawatts
21:59:30 <lambdabot> http://en.wikipedia.org/wiki/Watt-hour
21:59:30 <lambdabot> Title: Kilowatt hour - Wikipedia, the free encyclopedia
21:59:32 <luqui> oh lame
21:59:38 <hatds> "how many hours per year"
21:59:50 <scutigera> hey, isn't there a units/dimensions hackage ?
21:59:57 <luqui> it's 0.000114
22:00:01 <luqui> says google
22:00:15 <luqui> really, @go ought to extract that, no? :-)
22:00:24 <luqui> (yes yes, patches welcome, i know ;-)
22:00:25 <Cale> 15 km^2 / (mi s) is about 33554 km/h
22:00:30 <rieux_> > 1 / (24 * 365) :: Double
22:00:31 <lambdabot>   1.1415525114155251e-4
22:00:39 <luqui> well, that's why I was surprised!
22:00:47 <ksf> there's going to be wolfram alpha soon, no need to hack something up.
22:01:15 <luqui> yeah, lambda bot will have to get on that quick!
22:01:30 <copumpkin> @alpha male
22:01:30 <lambdabot> Unknown command, try @list
22:01:42 <Cale> But that's 3.10 * 10^-5 in the one true unit.
22:01:56 <Cale> Er, closer to 3.11 * 10^-5
22:02:21 <copumpkin> what's the "standard" second?
22:02:27 <vixey> 1
22:02:33 <luqui> Cale, what is that in scalar?
22:02:36 <copumpkin> :)
22:02:41 <luqui> (if I calculate correct)
22:02:49 <scutigera> 1 :+ 0
22:02:52 <roconnor> 1 pound pound per pound in U.S. Dollar meters per second squared
22:02:53 <copumpkin> what is 1 second defined as, I mean
22:03:07 <Cale> The second is the duration of 9 192 631 770 periods of the radiation corresponding to the transition between the two hyperfine levels of the ground state of the cesium 133 atom.
22:03:17 <scutigera> don't forget about furlongs per fortnight...
22:03:26 <copumpkin> Cale: wow, ok :)
22:03:30 <hatds> .002 cents in dollars
22:03:53 <Cale> This definition refers to a cesium atom at rest at a temperature of 0 K (absolute zero), and with appropriate corrections for gravitational time dilation. The ground state is defined at zero magnetic field.
22:03:54 <roconnor> ((1 pound force) divided by (1 pound)) times (1 British pound) = 14.7776409 m U.S. Dollars / s2
22:03:56 <rieux_> copumpkin: it used to be defined in terms of the speed of light and a particular (steel?) cube in paris
22:04:20 <luqui> Cale, which is the speed in sqrt(Joules/kilogram)  ;-)
22:04:21 <hatds> you mean the unit mass?
22:04:22 <copumpkin> how did that cube interact with the speed of light?
22:04:25 <Cale> rieux_: You're thinking of the kilogram?
22:04:29 <rieux_> no, the unit length
22:04:30 <scutigera> wasn't that a steel rod which was 1 meter
22:04:32 <luqui> er rather, i'm asking, I guess...
22:04:32 <copumpkin> ah :P
22:04:37 <rieux_> rod, orry
22:04:47 <quicksilver> but they turned it all around.
22:04:57 <scutigera> hey I'm installing brainf*ck, is that a good idea ?
22:05:00 <quicksilver> now a metre is defined to be the length light travels in (1/c) of a second.
22:05:01 <copumpkin> and did  the hokey pokey?
22:05:05 <quicksilver> and c is defined as a fixed constant.
22:05:10 <hatds> number of horns on a unicorn acre in tea spoons per light year
22:05:15 <hatds> google that :)
22:05:15 <luqui> scutigera, provided that you understand that the name is referring to a transition in brain state
22:05:26 <scutigera> a transition to...
22:05:28 <quicksilver> and the poor steel rod is out of a job.
22:05:32 <Cale> (metre) In 1983, it was redefined by the International Bureau of Weights and Measures (BIPM) as the distance travelled by light in free space in 1â299,792,458 of a second.
22:05:35 <ksf> it's made of http://en.wikipedia.org/wiki/Constantan
22:05:58 <quicksilver> won't somebody *please* think of the steel rods?
22:05:59 <rieux_> platinum!
22:06:02 <scutigera> no brainf*ck for me, readline-1.0.1.0 failed during the configure step.
22:06:17 <Twey> How on Earth does that work?
22:06:21 <Cale> and iridium :)
22:06:26 <roconnor> Cale: ya, someone was asking if the speed of light was uncomputable.  I said that it was not only computable, but rational.
22:06:34 <Twey> A teaspoon is a measurement of volume
22:06:38 <Cale> roconnor: hehe
22:06:42 <Twey> Light-years are a measurement of distance
22:06:49 <Twey> And acres are a measurement of area
22:06:55 <luqui> brainfsck: corrupted filesystem
22:06:55 <Cale> Of course, the number 1 is computable!
22:07:02 <roconnor> > 1
22:07:02 <Twey> 1, 2, and 3 dimensions
22:07:03 <lambdabot>   1
22:07:08 <roconnor> yep
22:07:14 <Twey> Haha
22:07:19 <Twey> It makes no sense
22:07:19 <luqui> Cale, that depends on your observation coalgebra
22:07:23 <edwardk> ok. all MTL types converted. http://comonad.com/haskell/monad-ran/dist/doc/html/monad-ran/Control-Monad-Ran.html
22:07:53 <david_> I have a predicate function which I'd like to run on a infinite long list of numbers (which of course will stop when the function returns true and thus keep running only when returning false)
22:08:22 <Twey> david_: (head .) . filter
22:08:39 <david_> hmmmm
22:08:39 <Twey> Laziness FTW
22:08:51 <david_> what are those dots?
22:08:52 <vixey> head . filter p
22:08:58 <Twey> Composition
22:08:59 <Twey> Yeah
22:09:02 <vixey> p is the predicate
22:09:03 <Cale> "only certain molten salts and halogens are corrosive to solid iridium" :)
22:09:05 <david_> ah okay
22:09:29 <luqui> > head . filter (> 1000) $ [1..]
22:09:30 <lambdabot>   1001
22:09:47 <Twey> ((head .) . filter) p l â¡ (head . filter p) l â¡ head $ filter p l
22:09:58 * luqui has started thinking that other languages are lazy, and writing way too many infinite loops
22:10:03 <vixey> > head . filter (liftA2 (&&) (> 1000) ((== 0) . (`mod` 7))) $ [1..]
22:10:05 <lambdabot>   1001
22:10:11 <vixey> :D
22:10:39 <vixey> > head . filter (liftA2 (&&) ((==)`ap`reverse) (liftA2 (&&) (> 1000) ((== 0) . (`mod` 7)))) $ [1..]
22:10:40 <lambdabot>       No instance for (Integral [a])
22:10:41 <lambdabot>        arising from a use of `mod' at <i...
22:10:50 <copumpkin> oh my
22:11:06 <luqui> > 7 * ceil(1000/7)
22:11:07 <lambdabot>   Not in scope: `ceil'
22:11:11 <luqui> > 7 * ceiling(1000/7)
22:11:12 <lambdabot>   1001
22:11:27 <copumpkin> zomg this is haskell!
22:11:40 <mmorrow> haha, i always do that with ceil(ing)
22:12:11 <david_> what is the '$'?
22:12:15 <copumpkin> @src $
22:12:15 <lambdabot> f $ x = f x
22:12:27 <luqui> it's just a low precedence form of function application
22:12:27 <Cale> david_: $ is function application but with very low precedence
22:12:35 <luqui> i win
22:12:45 <mmorrow> and one way to go insane in the code in C and Haskell in parallel where the Haskell is using sizeOf a lot
22:12:51 <mmorrow> s/in/is/ to
22:13:21 <Cale> f . g . h $ x y z  is the same as  (f . g . h) (x y z), which is the same as f (g (h (x y z)))
22:13:29 <ksf> >>= shouldn't bind tighter than $
22:13:33 <david_> oh ok
22:13:52 <luqui> and one way to go is tosane in the code in C and Haskell in parallel where the Haskell is using sizeOf a lot
22:13:55 <vixey> > 1001`div`7
22:13:56 <lambdabot>   143
22:14:01 <vixey> > 143*7
22:14:03 <lambdabot>   1001
22:14:04 <vixey> impossible
22:14:10 <Twey> ksf: Practically speaking, I find it useful
22:14:13 <Twey> Anyway, to bed
22:14:15 <Twey> 'night
22:14:27 * copumpkin doesn't like using >>=
22:14:36 <copumpkin> I much prefer =<< most of the time
22:14:44 <luqui> vixey, impossible?
22:14:49 <Cale> =<< works really well in do-blocks :)
22:15:03 * luqui never uses >>=
22:15:08 <ksf> I rather read my functions left to right
22:15:08 <luqui> it's either =<< or do notation
22:15:17 <scutigera> cabal readline install failed, can't seem to find install dir, anyone know where it should be hiding ?
22:15:23 <ksf> but, actually, we should have it switchable.
22:15:29 <copumpkin> I prefer reading my functions right to left, and as luqui does, I'll use a do block otherwise
22:15:43 <Cale> scutigera: somewhere under ~/.cabal ?
22:15:44 <luqui> data flows right to left and top to bottom
22:15:52 <luqui> =)
22:15:56 <copumpkin> damn right!
22:16:08 <scutigera> Cale: did a find looking for config.log and none shows up (??)
22:16:16 <sclv> but functions should be read like books -- left to right, and top to bottom.
22:16:20 <copumpkin> combining a fancy chain of composed functions with >>= means switching directiongs a lot
22:16:23 <luqui> yep :-)
22:16:30 <blackh> good advice - I was never sure about >>= and =<<
22:16:36 <copumpkin> how about we replace all uses of . with >>>
22:16:40 <copumpkin> and then we can use >>= too
22:16:43 <sclv> yech!!!
22:16:47 <copumpkin> :P
22:16:47 <ksf> usually, it's just one bind and one <$>.
22:16:51 <copumpkin> then we can read everything left to right
22:17:01 <luqui> well if the emphasis is on the data, then yeah
22:17:14 <ksf> I usually don't use more than one bind on a line.
22:17:19 <luqui> but usually it isn't, because haskell is a *function*al language :-)
22:17:41 <sclv> I don't mind more than one bind, as long as they're not inside a do block to begin with.
22:17:59 <copumpkin> > filter (> 1000) >>> head $ [1..]
22:18:01 <lambdabot>   1001
22:18:09 <copumpkin> that isn't so bad is it? :P
22:18:11 <luqui> i'm still enough of a perler that I like lots of syntactic choices, in order to convey my intent the most clearly
22:18:20 <luqui> ew
22:18:29 <Gracenotes> you means <<<
22:18:32 <Gracenotes> shirley
22:18:36 <copumpkin> :P
22:18:42 <luqui> > ($ [1..]) >>> filter (>1000) >>> head
22:18:42 * sclv really wants a $ that is of higher precedence than =<< but lower precedence than everything else.
22:18:43 <lambdabot>       Overlapping instances for Show (([t] -> [a]) -> a)
22:18:43 <lambdabot>        arising from ...
22:18:50 <copumpkin> well, if we want our functions to work from left to right
22:18:53 <copumpkin> we gotta use >>>
22:19:01 <luqui> oh whoops
22:19:13 <luqui> man, what's the best way to get the data on the left?
22:19:17 <copumpkin> hmm
22:19:30 <Gracenotes> eek
22:19:32 <quicksilver> a low precedence flipped ($) ?
22:19:33 <vixey> > (const 3 >> (*5))()
22:19:35 <lambdabot>       No instance for (Num ())
22:19:35 <vixey> > (const 3 >>> (*5))()
22:19:37 <lambdabot>        arising from the literal `5' at <intera...
22:19:39 <lambdabot>   15
22:19:43 <copumpkin> > ($ [1..]) $ filter (>1000) >>> head
22:19:45 <lambdabot>   1001
22:19:50 <Gracenotes> ewwwwwwwwwww
22:19:52 <copumpkin> how bout that ?
22:19:57 <luqui> oh that's what I meant
22:20:06 <luqui> composition confusion, what's your fusion?
22:20:09 <copumpkin> mmm beauty
22:20:21 <copumpkin> now let's start throwing Kleisli in thre
22:20:52 <copumpkin> we can send it straight to print
22:20:56 <Cale> :t (<=<)
22:20:57 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
22:21:51 <luqui> > ($ [1..5]) $ map (\x->[x,2*x]) >=> map (\x->[x,x+1])
22:21:53 <lambdabot>   [[1,2],[2,3],[2,3],[4,5],[3,4],[6,7],[4,5],[8,9],[5,6],[10,11]]
22:22:27 <sclv> foo . bar . baz =<< qux . garply $ zed -- i really heat that this doesn't work as it reads.
22:23:01 <sclv> s/heat/heat/
22:23:07 <luqui> sclv, huh?
22:23:07 <sclv> erm. s/heat/hate/ that is
22:23:20 <luqui> sclv, do you mean <=< instead?
22:23:40 <hatds> (foo . bar . baz =<< qux . garply) $ zed
22:23:46 <hatds> is that it?
22:23:54 <luqui> > ?foo . ?bar <=< ?baz . ?qux $ ?zed
22:23:55 <lambdabot>       Unbound implicit parameters (?foo::b -> m c,
22:23:56 <lambdabot>                           ...
22:23:58 <physique> haskell is too complicated
22:23:59 <luqui> :t ?foo . ?bar <=< ?baz . ?qux $ ?zed
22:24:00 <lambdabot> forall b b1 (m :: * -> *) c b2 a. (?zed::a, Monad m, ?qux::a -> b2, ?baz::b2 -> m b1, ?bar::b1 -> b, ?foo::b -> m c) => m c
22:24:10 <sclv> luqui: I just mean that it works as hatds describes, but I end up writing it when I mean: foo . bar . baz =<< (qux . garply $ zed )
22:24:25 <luqui> physique, i would totally recommend you not ever looking at another language then...
22:24:28 <luqui> (except maybe forth?)
22:24:41 <Cale> physique: hehe
22:25:10 <physique> don't take offense
22:25:13 <david_> is there a way of tracing/printing which number/item in the list I'm currently on?
22:25:13 <physique> i'd love to learn it
22:25:15 <sclv> and I write things like this quite a bit, so the extra parens bug me because the precedence of =<< is too high or $ is too low or a bit of both.
22:25:38 <physique> but i have a fear of it just by looking at that code
22:25:43 <Cale> physique: It's really not so bad, the people here are trying hard to make it confusing ;)
22:25:45 <rieux_> physique: it's not always as complicated as all this :)
22:27:06 <hatds> david_: a few choices:  1) make your function carry an extra parameter that gets updated with each recrusion, 2) use mapAccumL, 3) change the [x] argument to a [(int,x)] and call it as foo $ zip [1..] xs
22:27:48 <edwardk> ugh, well i now know a name for the class of grammars i was parsing with parsimony. they are tree adjoining grammars
22:28:00 <sclv> whyz that an ugh?
22:28:05 <luqui> Cale, that's not necessarily true... the recent code hasn't been that complicated; it's just definitely doesn't look like other languages
22:28:11 <edwardk> sterling clover the asymptotics =)
22:28:37 <luqui> except for vixey's pointfree stuff :-)
22:28:59 <sclv> i musta missed that discussion. they're bad?
22:29:17 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.1908 talks about it a bit
22:29:25 <Cale> luqui: Well, ($ x) $ <some function> is certainly not aiming for clarity...
22:29:39 <edwardk> i'm not yet entirely sure that i fall into the full parsing algorithm class they describe, but its close
22:29:41 <copumpkin> edwardk: omg you reinvented the wheel?
22:29:46 <luqui> Cale, okay fair enough :-)
22:29:48 <hohoho> is there good document about extention of haskell type system?
22:29:57 <edwardk> copumpkin: happens a lot
22:30:03 <copumpkin> eww, it's one of them blurry pdfs
22:30:19 <hatds> hohoho: ghc user manual?
22:30:21 <rieux_> hohoho: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
22:30:30 <edwardk> copumpkin: what i do is whenever i tackle a new discipline i use the age of the papers i'm reinventing as a benchmark of how far i have to go
22:30:40 <edwardk> copumpkin: so i'm now 15 years behind in NLP ;)
22:30:41 <sclv> if you reinvent a round one, that's a win.
22:30:44 <copumpkin> lol
22:30:52 <rieux_> hohoho: especially sections 8.4 - 8.8
22:31:25 <edwardk> copumpkin: i'm close to current on most haskelly things, and ~25-30 years behind in some areas of category theory.
22:31:30 <hohoho> thanks so much
22:31:52 <edwardk> copumpkin: the worst was as a computational geometer i wound up rederiving and appealing to a 120 year old coordinate system by eduard study
22:32:06 <edwardk> copumpkin: at least there i had something to contribute
22:32:09 <hohoho> its a only docmunt ? is ther any paper ?
22:32:16 <copumpkin> lol
22:32:22 <sclv> hohoho: many papers
22:32:25 <sclv> many many
22:32:31 <copumpkin> hohoho: are you santa claus?
22:32:55 <copumpkin> ãã»ã
22:33:08 <sclv> edwardk: that metric only works if you think the field is on the right track. :-)
22:33:22 <david_> Is it impossible to make a function do two things? Like "print this and return that"?
22:33:26 <luqui> edwardk, ummm....
22:33:31 <luqui> edwardk, now i'm depressed
22:33:32 <copumpkin> david_: you can sort of :P
22:33:37 <hohoho> hehe
22:33:39 <luqui> edwardk, ixi and combinator calculus is from the 60s
22:33:48 <copumpkin> a -> (IO (), b) or something :P
22:33:57 <edwardk> luqui: yeah but the IXi stuff you're doing is cool =)
22:34:09 <luqui> =)
22:34:14 <copumpkin> david_ but if you're just printing stuff, you're wasting the output of the IO computation anyway
22:34:16 <hatds> a -> IO b  sounds more like what you want
22:34:19 <copumpkin> so you might as well merge it into one
22:34:19 <edwardk> luqui: my last type system wasn't much more recent belnap's display logic was 70s-ish =)
22:34:40 <luqui> ooohh something ending in "logic" that i haven't heard of
22:34:49 <luqui> *googles ferociously*
22:34:56 <edwardk> Its hard to find on the internet
22:34:57 * copumpkin feels sorry for that logic
22:35:06 <edwardk> you can find some papers by greg restall
22:35:17 <edwardk> display logic and gaggle theory
22:35:50 <david_> copumpkin: yea, but how?
22:36:03 <edwardk> luqui: the gist of display logic is quite simple.
22:36:08 <copumpkin> david_: f a b = print a >> return b
22:36:21 <edwardk> luqui: most of the time when you roll your own logic you spend all your time proving the admissability of cut, no?
22:36:55 <edwardk> luqui: you wind up commuting everything over everything to show that you can show the cut down the tree and make it vanish
22:36:59 <luqui> edwardk, um, you mean the fact that you can prove lemmas?
22:37:13 <edwardk> luqui: as you add connectives the work becomes O(n^2) in the number of connectives in your logic
22:37:17 <edwardk> yeah
22:37:41 <sclv> edwardk: that paper seems to leave open that you can get really good average case bounds for certain subclasses and clever algorithms tho...
22:37:42 <luqui> hmm ok
22:37:48 <edwardk> display logic replaces that laborious process by providing a set of 7 local conditions for a connective to satisfy such that if they are all satisfied, then you can add ANY such connective to your logic
22:38:00 <luqui> oh neat
22:38:00 <edwardk> sclv: good. i hadn't made it that far =)
22:38:05 <sclv> which gives hope at the expense of more complex reasoning...
22:38:06 <copumpkin> time for bed, g'night :)
22:38:19 * sclv is a skimmer of all disciplines, master of none.
22:38:32 <edwardk> luqui: so what i asked was basically what happens when you take display logic as your basis for the curry howard correspondence
22:38:41 <edwardk> because it has a very nice framework for mixing various modal logics
22:38:55 <edwardk> since S4, etc. all provide connectives that satisfy the laws!
22:39:15 <luqui> oh sweet
22:39:56 <edwardk> but in essence the display property is that you can shove everything to either side of the turnstile, leaving one value 'on display' for cut to apply
22:41:55 <edwardk> anyways, since i generally hate semantics, what i love about display logic is the process of generating the display of a variable is basically just a syntactic operation of 'zipping' through your logical connectives
22:42:11 <edwardk> its a logical zipper
22:42:32 <edwardk> or rather it treats the turnstile as one
22:42:33 <luqui> oh yeah, i can see that.  cool!
22:43:02 <edwardk> you'll never hear it said by anyone else that way, but thats my personal take on display logic
22:43:02 * mofmog wrote a brainf*ck compiler
22:43:03 <luqui> and then the thing to the right is the focus
22:43:10 <edwardk> yep
22:43:55 <edwardk> so you a single element focus on the right, and a single element focus on the left by focusing on a root of a tree and you can graft
22:44:35 <edwardk> on paper you spend a ton of time farting around with polarity, etc. but in a computer its all fairly elegant
22:44:52 <edwardk> you just run out of symbols ;)
22:46:19 <luqui> um.  kind of lost me there
22:46:34 <luqui> you mean there aren't enough letters?
22:46:34 <edwardk> well, i mean physical ones to type with
22:46:36 <edwardk> =)
22:46:41 <edwardk> yeah
22:46:58 <edwardk> the type system that emerged wasn't something i'd wish on my worst enemy
22:47:05 <edwardk> well maybe if he wanted a break from DDC.
22:47:16 <luqui> lol
22:48:17 <edwardk> sclv: yeah i noticed that it said these were larger than cfgs, and fortunately my grammars should be the same size
22:48:41 <edwardk> sclv: i just use the bottom up parsing technique, so i'm hunting to find what they''ve figured out about my asymptotics
22:48:59 <edwardk> sclv: the nice thing is i seem to already be doing most of the optimizations they mention
22:50:10 <sclv> i guessed with a monoidal approach lots of those would come by construction...
22:51:01 <david_> copumpkin: I can't seem to get it working http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4634#a4634
22:51:17 <edwardk> sclv: yeah basically what it looks like is that i generate via 'concatenation and complemention' in their terminology, and then perform adjunction between separate parallel parses
22:51:50 <edwardk> concatenation and completion
22:52:05 <edwardk> actually all 4 steps fall into my process
22:52:22 <edwardk> its like someone wrote the paper in my head ;)
22:52:28 <edwardk> i love when that happens
22:52:56 <sclv> an elegant rendition of a known algorithm is always a win
22:52:56 <edwardk> i partition differently than they do though
22:53:16 <luqui> david_, wrapper is not a pure function; it does I/O
22:53:22 <luqui> david_, so you are not allowed to pass it to filter
22:53:24 <edwardk> i chunk on arbitrary terminals, not on some mythical local tree boundary
22:53:44 <david_> luqui: I see
22:54:01 <luqui> david_, if it's just for debugging, there's a hack you can do
22:54:12 <david_> mkay, and that is?
22:54:14 <luqui> david_, but, the right way to do this would be filterM I think
22:54:26 <luqui> i've never used filterM before
22:54:28 <luqui> :t filterM
22:54:29 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:54:32 <edwardk> sclv: i'm ok with stealing terminology and optimizations from known literature =)
22:54:41 <edwardk> right now its still a pretty cool applicative parser
22:54:57 <luqui> edwardk, yeah, replacing filter with filterM and changing main to monadic style should do the trick
22:55:19 <edwardk> i'll get right on that
22:55:26 <luqui> lol
22:55:33 <luqui> i'm sure david_ would appreciate it
22:55:39 * sclv idly wonders if memotables would do anything interesting.
22:55:53 <edwardk> luqui is a busy man. glad he figured out delegation =)
22:56:01 <edwardk> sclv: heh actually they DO!
22:56:08 <edwardk> that was why i wrote the LZ78 stuff!
22:56:13 <dons> The Haskell Platform is live: http://hackage.haskell.org/platform/
22:56:20 <luqui> w00t
22:56:21 <dons> go get haskell for your system (and report bugs!)
22:56:34 <dons> install it on your friends' windows machines
22:56:37 <edwardk> i can use it to improve any expensive monoid over a fairly redundant source
22:56:53 <luqui> ah man, no support for ubuntu
22:57:01 <edwardk> basically dictionary based data compression algorithms give rise to data structures for me
22:57:13 <edwardk> sclv: did you see the lz78 code?
22:57:23 <sclv> edwardk: this vaguely reminds me of an icfp challenge a few years back on simplifying the representation of structured text, is how the association came to mind.
22:57:24 <dons> luqui: its not too late to package it for ubuntu :)
22:57:28 <sclv> didn't see the code yet
22:57:31 <david_> how do I make the main "monadic style"?
22:57:32 <sclv> link ?
22:57:46 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Generator-Compressive-LZ78.html
22:58:17 <edwardk> basically i 'decompress' in the monoid instead of the original alphabet
22:58:29 <edwardk> it works a bit better with LZAP instead of LZ78
22:58:40 <luqui> david_, the easiest way is to put it in a do block, and use <- for everything that comes from a monad
22:58:41 <edwardk> and Bentley-McIlroy gets you sharing in the large
22:58:51 <dons> platform on reddit, mod up! http://www.reddit.com/r/programming/comments/8i7vq/the_haskell_platform_is_live_a_single_standard/
22:59:07 <luqui> david_, oh, i just realized something
22:59:31 <luqui> david_, this isn't going to work at all!  IO is not lazy enough
22:59:50 <luqui> :t dropWhileM
22:59:52 <lambdabot> Not in scope: `dropWhileM'
22:59:56 <luqui> :t takeWhileM
22:59:57 <lambdabot> Not in scope: `takeWhileM'
23:00:00 <luqui> hmmm
23:00:19 <edwardk> sclv: basically as long as adjunction isn't appreciably more expensive than concatenation the LZ(78|W|AP)/Bentley-McIlroy/RLE/etc, stuff can be a big win
23:00:21 <david_> Oh well.. I'm off for a while..
23:00:46 <sclv> dons: awesome!
23:00:49 <luqui> david_, oh that's too bad, because i just thought of a neat way to do it
23:01:33 <dons> the one click windows installer is a bit of a game changer (and the Mac OS X one is a day or so away)
23:01:37 <luqui> > splitAt (> 10) [1..20]
23:01:38 <lambdabot>       The section `(> 10)' takes one argument,
23:01:38 <lambdabot>      but its type `Int' has none
23:01:41 <luqui> er
23:01:46 <luqui> > split (> 10) [1..20]
23:01:47 <lambdabot>   Couldn't match expected type `[t1] -> t'
23:01:47 <dons> now the fun task of adding new libraries and making things work :)
23:01:50 <luqui> daft!
23:01:57 <sclv> edwardk: that's nice code! i had to look closely to even see where the compression was happening at all.
23:02:00 <ivanm> dons: why isn't gentoo listed under distros?
23:02:11 <tiglionabbit_> weird, I just did emerge cabal on gentoo and it didn't put a cabal command anywhere
23:02:15 <luqui> @hoogle (a -> Bool) -> [a] -> ([a],[a])
23:02:15 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
23:02:15 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
23:02:15 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
23:02:17 <dons> ivanm: url please!
23:02:24 <ivanm> http://code.haskell.org/gentoo/gentoo-haskell/dev-haskell/haskell-platform/haskell-platform-2009.0.0.ebuild
23:02:24 <dons> ivanm: if you've got a url pointing to the gentoo package
23:02:27 <dons> thanks
23:02:27 <edwardk> sclv: =)
23:02:34 <ivanm> In the Haskell overlay
23:02:36 <dons> is there a sexier page?
23:02:44 <ivanm> dons: I doubt it ;)
23:02:47 <dons> http://code.haskell.org/gentoo/gentoo-haskell/dev-haskell/haskell-platform/ ?
23:02:55 <ivanm> Or that
23:03:05 <ivanm> depends if you want the specific version or not
23:03:09 <QtPlaty[HireMe]> @hoogle [a] -> [(a,a)]
23:03:09 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
23:03:09 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
23:03:09 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
23:03:13 <dons> ok.
23:03:21 <tiglionabbit_> dons and ivanm: what am I supposed to do with this?
23:03:36 <edwardk> sclv: i like the fact that both the encoder and the decoder would fit on a coffee cup
23:03:45 <tiglionabbit_> oh I should use this ebuild instead?
23:03:56 <dons> ivanm: updated.
23:04:14 <ivanm> \o/
23:04:30 * ivanm joined IRC just to complain about that
23:04:38 <ivanm> since IIRC, kolmodin put that together at hac5
23:04:52 <dons> yes. he was quick off the block.
23:05:05 <ivanm> well, AFAIK all the ebuilds were already there ;-)
23:05:09 <dons> i asked him for a url earlier, but he wasn't around
23:05:13 <ivanm> just needed the meta one
23:05:15 <luqui> dons, HP is GHC only, right?
23:05:18 <ivanm> dons: *nod*
23:05:39 <ivanm> luqui: it will presumably work with any other full-featured haskell compiler
23:05:47 <luqui> ivanm, where full-featured means what?
23:05:52 <dons> luqui: it could ship with hugs, but that'd suck.
23:06:11 <dons> i could actually imagine shipping with hugs (but not putting all the libraries through hugs)
23:06:15 <luqui> i rather mean, if i want the platform libraries to work with *my* compiler, what do I need to support?
23:06:17 <ivanm> luqui: implements H98 fully for a start... which AFAIK removes the others from the list
23:06:21 <ivanm> dons: yeah
23:06:28 <Apocalisp> is there a utility to see how types line up?
23:06:41 <luqui> (this compiler of mine is hypothetical :-)
23:06:42 <ivanm> Apocalisp: hmmm?
23:06:48 <ivanm> luqui: heh
23:06:53 <sclv> nhc supports 98 too!
23:06:59 <sjanssen> ivanm: I don't think there are any compilers that implement Haskell '98 fully
23:07:17 <dons> luqui: http://trac.haskell.org/haskell-platform/ticket/2
23:07:20 <ivanm> sjanssen: well, close enough ;-)
23:07:39 <luqui> dons, okay, thanks :-)
23:07:41 <edwardk> sjanssen: you couldn't tell by listening to o'keefe on the cafe about n+k =)
23:07:47 <dons> the next (?) edition of the platform will list the accepted (so far) language extensions. it's possible packages will be ruled out from inclusion if they use something weird
23:07:48 <Apocalisp> ivanm: to trace the type inference. "a in f unified with b in g", etc.
23:07:48 <ivanm> but is there any specific ghc-isms in those packages (because I can't think of any...)?
23:07:52 <luqui> i have packaged a thunk
23:07:52 <ivanm> maybe some extensions?
23:08:07 <sjanssen> ivanm: hierarchical modules extension at least
23:08:18 <dons> there's a fair bit of Haskell Prime in the spec, i reckon.
23:08:18 <sjanssen> (everybody seems to forget that isn't in Haskell '98)
23:08:20 <edwardk> dons: have any benchmarks for monad transformers handy?
23:08:23 <ivanm> sjanssen: duh, I keep forgetting that's not standard...
23:08:25 <dons> edwardk: nope
23:08:28 <luqui> oh yeah, hierarchical modules are basically a given nowadays
23:08:41 <edwardk> dons: damn. i now have the ran library written, but nothing to really benchmark it =)
23:08:58 <luqui> edwardk, kan extensions?
23:09:09 <edwardk> luqui: yeah
23:09:25 <edwardk> luqui: was that asking what the library was, or what they are?
23:09:27 <dons> edwardk: that would be a good thiiing to have, given all the performance claims flying around :)
23:09:28 <luqui> hmmm... maybe i'll understand them.  oh wait, it's your code =p
23:09:36 <luqui> edwardk, about the library
23:10:00 * ivanm sometimes idly wishes for Java-style "foo.bar.*" imports... then he remembers that modules can re-export other modules, and just creates a meta-module instead
23:10:06 <luqui> reading your code is like reading a math textbook, and i was never any good at that either
23:10:09 <edwardk> dons: hah, the only claim i have is that it beat mmorrow on his own benchmark. and that dolio mentioned that my CPS'd ST s seemed to beat out ST s on his little microbenchmark
23:10:28 <ivanm> edwardk: which benchmakrs are these?
23:10:43 <luqui> ivanm, yeah, but qualified exports would be nice
23:10:50 <edwardk> luqui: basically you just use your existing monad transformers and wrap the whole ball with 'Ran' and forget that you did it
23:10:59 <Ziban|afk> http://change.menelgame.pl/change_please/2688554/
23:11:01 <edwardk> you might need to liftRan or lowerRan occasionally
23:11:08 <Apocalisp> @type \h -> (fmap.fmap.fmap) (uncurry h)
23:11:09 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b c. (Functor f2, Functor f1, Functor f) => (a -> b -> c) -> f (f1 (f2 (a, b))) -> f (f1 (f2 c))
23:11:16 <Apocalisp> @type \h -> (fmap.fmap.fmap) (uncurry h) zip
23:11:17 <lambdabot> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
23:11:26 <Apocalisp> What's f, f1, and f2?
23:11:30 <luqui> edwardk, ah.  is it basically like applying codensity stuff?
23:11:46 <edwardk> luqui: sort of but not directly
23:11:54 <edwardk> the result on IO isn't Codensity IO
23:12:13 <edwardk> its forall o. (a -> State# RealWorld -> o) -> State# RealWorld -> o
23:12:19 <luqui> oh. hm.  well the code will be interesting to ponder at least.
23:12:24 <edwardk> in otherwords, Codensity (State# RealWorld)
23:12:38 <luqui> oh huh.
23:12:43 <edwardk> er Codensity ((->) (State# RealWorld))
23:13:02 <edwardk> so basically it permutes all the monad transformers into the form
23:13:17 <edwardk> forall o. (a -> f o) -> g o
23:13:26 <edwardk> which is all i mean by 'right kan extension'
23:13:56 <luqui> and this is like myelin for monad transformers?
23:14:03 <ivanm> dons: are all platform libs BSD3?
23:14:05 <dons> 5 windows.exe downloads :)
23:14:21 <dons> ivanm: that's not been decided, but is the case so far.
23:14:33 <ivanm> *nod* that's what I meant ;-)
23:14:47 <edwardk> Identity: (a -> o) -> o, Writer: (a -> w -> o) -> o State: (a -> s -> o) -> s -> o
23:15:22 <ivanm> anyway, I only came in here to bitch about Gentoo's exclusion from the list...
23:15:26 * ivanm -> home
23:15:28 <luqui> so you're killing tuple allocations at least
23:15:38 <edwardk> Either: (a -> o) -> (b -> o) -> o, Maybe (a -> o) -> o -> o  RWS: (a -> w -> s -> o) -> r -> s -> o
23:15:43 <edwardk> luqui: exactly
23:15:58 <edwardk> and in general fmap never has to do anything more than partially apply the first arg of that function
23:16:16 <Saizan> edwardk: what about Control.Monad.State.Lazy beating your CPS'd unboxed State with a strict replicateM? :)
23:16:17 <edwardk> and return and bind have uniform definitions for all of the ones where f = g
23:16:39 <edwardk> saizan: i'm willing to get my pajnts handed to me ;)
23:17:17 <edwardk> saizan: i'm just saying there is something elegant there, and it seems to be fast on a lot of things and that monad transformers are decidedly not fast on a lot of things =)
23:17:34 <luqui> oh so you get fmap fusion at the very least
23:17:45 <edwardk> so someone had to do the brute force of thinking through all the liftRan, etc laws for these things so it could even be tested
23:18:15 <Saizan> yeah, i was just curious about the particular benchmark :) http://lhc-compiler.blogspot.com/2009/05/constructor-specialization-and-laziness.html
23:20:18 <edwardk> saizan: sure
23:22:07 <dolio> I didn't quite follow that post. Was that with their lhc work, or just with ghc?
23:22:15 <Saizan> just ghc
23:22:34 <edwardk> its just the replacing of replicateM with replicateM' there
23:23:01 <edwardk> basically he's showing that the benchmark was unfair to the polymorphic code
23:23:09 <edwardk> which i totally agree on
23:24:08 <Saizan> i don't get why it's so much faster though, it's not like some values are not computed, right?
23:24:11 <edwardk> otoh, i there is still a lot of room to play with on my side with the cps, inlining, etc.
23:25:09 <Saizan> mtl doesn't have inline annotations i think
23:25:38 <edwardk> nice of them to throw in the towel early ;)
23:26:13 <Saizan> heh
23:26:34 <dons> haha
23:27:28 <edwardk> i'm still trying to figure out why the Ran based version is a few percent slower than the directly implemented one
23:27:53 <dons> the core knows all
23:28:17 <edwardk> dons: i had a bizarre thought and i wanted to pick your brain
23:28:19 <vixey> does anyone know the ANSI/VT100/whatever escape/control code which works like  hSetBuffering stdin NoBuffering  ?
23:28:29 <vixey> or where I can find iT?
23:28:42 <dons> uh oh
23:28:51 <edwardk> what would be the best way to try to get unboxed integers to be captured in an environment as unboxed integers i.e.:
23:29:52 <edwardk> newtype Tree = Tree { getTree :: forall o. (Int# -> Int# -> Int# -> Tree -> Tree -> o) -> o }
23:29:56 <edwardk> er
23:30:06 <edwardk> newtype Tree = Tree { getTree :: forall o. (Int# -> Int# -> Int# -> Tree -> Tree -> o) -> o -> o }
23:30:42 <dons> mmm
23:30:43 <edwardk> i'd like to 'capture' the Tree with its environment preferrably unboxed so it'll pass them right into the function
23:30:49 <dons> yeah, i like that idea :)
23:30:58 <dons> but you could just use a regular structure too, i guess
23:31:02 <edwardk> if so, then i can work around the unpack problem
23:31:06 <dons> rather than implicitly via the unboxed parameters
23:31:12 <vixey> ghc -e 'putStr "\ESC#8"'
23:31:13 <edwardk> nono
23:31:17 <edwardk> there is magic here =)
23:31:23 <vixey> this program is ridiculous
23:31:38 <dons> its a cool idea. run with it.
23:31:41 <edwardk> (Int# -> Newtype (Int# -> Newtype (Int# -> ...    --- do you start to see a general framework for an unboxed rep?
23:32:35 <edwardk> unfortunately it puts the storage entirely in the hands of the compiler
23:32:42 <edwardk> so it'll probably wind up suboptimal
23:32:52 <edwardk> and less fortunately its almost completely opaque
23:33:36 <edwardk> so i was trying to figure out the way i could generate that value in the way that would do the most unboxing.
23:33:44 <dons> yes, you get to reuse the way arguments are unpacked into function closures. i wonder how that's represented.
23:34:18 <edwardk> i.e. if you define just: bin :: Int# -> Int# -> Int # -> Tree -> Tree -> Tree --
23:34:46 <edwardk> then the only environment that has to grab onto when its making the Tree is the set of Int#'s so do you think it'd be smart enough to keep them unboxed in the closure?
23:35:57 <dons> oh yes.
23:36:50 <dons> anyone want to speculate on whether more unix or windows downloads will be made in the next 12 hours?
23:37:33 <edwardk> bah, never bet against the dons when a community is involved. he'll just go stir up reddit
23:37:38 <luqui> I think it will be NixOS
23:39:19 <vixey> looks at this code:
23:39:25 <vixey> #define InsCharCost(count) \
23:39:26 <vixey> 		((parm_ich != 0) \
23:39:26 <vixey> 		? D->_ich_cost \
23:39:26 <vixey> 		: ((enter_insert_mode && exit_insert_mode) \
23:39:26 <vixey> 		  ? D->_smir_cost + D->_rmir_cost + (D->_ip_cost * count) \
23:39:30 <vixey> it just goes on like that
23:39:33 <luqui> oh of course
23:39:42 <mauke> looks like curses
23:39:45 <luqui> that makes sense
23:39:47 <vixey> These guys are doing functional programming
23:39:50 <vixey> mauke it is
23:45:40 * luqui wonders what cpp's rule is that stops nontermination
23:46:58 <opqdonut> luqui: limited stack depth
23:47:20 <luqui> oh but then it just writes out the name of macros, rather than dying?
23:47:24 <luqui> that's weird
23:48:01 <luqui> nope that's not it
23:52:03 <tiglionabbit_> if you were going to write simple AI for a board game to look a few moves in the future and find a set of possible moves that aren't stupid, what would be a cool way to represent that in haskell?  I've heard of doing it by creating a data structure that represents all possible games, and pruning it as players move..   Not sure if that's the best model for a game that's played transactionally with a database and web int
23:52:54 <Saizan> you got truncated
23:53:05 <tiglionabbit_> ..I've heard of doing it by creating a data structure that represents all possible games, and pruning it as players move..  Not sure if that's the best model for a game that's played transactionally with a database and web interface though
23:53:17 <luqui> tiglionabbit_, it could be
23:53:35 <luqui> oh i see what you mean, you'd have to recreate it every tie
23:53:40 <Saizan> you can keep your infinite tree of possible games lazy even if you have to interact with the external world
23:53:50 <luqui> but it won't be stateless
23:54:05 <luqui> you'd have to keep the data structure on your webserver between requests
23:54:21 <tiglionabbit_> is that okay to do?
23:54:39 <Saizan> yeah, you'd need an application server, or fastcgi, so that the process remains alive
23:56:37 <tiglionabbit_> is that a good idea, to keep every game in memory at once?
23:56:57 <opqdonut> tiglionabbit_: the structure is lazy, all the games aren't in memory
23:57:06 <tiglionabbit_> also, might you have multiple copies of the same game when two people are playing and requesting from the server at the same time?
23:57:06 <Saizan> depends on how much memory and on how many users :)
23:57:38 <tiglionabbit_> opqdonut: I mean every game that people are currently playing would have one of these structures, including more than one copy of a given game
23:57:43 <opqdonut> ah
