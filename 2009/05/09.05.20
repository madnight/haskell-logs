00:05:14 <Adamant> ghc is effectively the reference implementation. some other compilers have more aggressive designs that may eventually pass ghc in compiled code speed, but they're still effectively alpha, beta, or just plain "experimental". unless you're using Haskell for teaching purposes (where Hugs is good), just use ghc, everyone else does :P
00:07:01 <Cale> BONUS's twitter is bewildering
00:07:06 <pumpkin> sure is :)
00:07:09 <pumpkin> I love his background
00:07:46 <Cale> http://s3.amazonaws.com/twitter_production/profile_background_images/2932631/81ced870c37efd64bf957aff6cf91437ddb588c3.gif
00:08:04 <pumpkin> it's pretty epic
00:08:17 <Cale> I wonder if he made it himself or found it somewhere
00:08:53 <erikc`> reminds me of http://upload.wikimedia.org/wikipedia/en/1/17/Last_unicorn.jpg
00:09:02 <erikc`> that red bull scared me so much as a child
00:09:49 <Cale> "imagine a giant snail playing the imperial march on a tuba really slowly"  "the giant snail puts down its tuba and sings Pagliacci in a tenor voice. It's ok but you can't believe you payed $300 for this crap."
00:12:42 <pumpkin> @tell thoughtpolice I have a (very hacky) 64-bit ghc HEAD running on mac os!
00:12:42 <lambdabot> Consider it noted.
00:13:32 <Gracenotes> kip kip
00:13:46 <pumpkin> kip kip?
00:13:51 <magical_pony> mud
00:13:53 <Cale> mudkips?
00:14:25 <Gracenotes> kip
00:14:29 <magical_pony> mud
00:14:41 <Gracenotes> kip
00:14:44 <magical_pony> mud
00:14:47 <Gracenotes> kip
00:14:52 <magical_pony> mud
00:14:56 <Gracenotes> slooooooooowpoke
00:15:01 <magical_pony> D:
00:15:30 <dmwit> Did it suddenly get rather random in here, or is it just me?
00:15:42 <Cale> It just got /b/ in here.
00:15:52 <dmwit>  /b/ stands for random ;-)
00:15:54 <magical_pony> lol
00:16:24 <Raevel> wow
00:16:25 <Gracenotes> they are the favored pokemon of the internet, regardless of what thrust them into that light
00:16:50 <Raevel> i choose you Gracenotes
00:17:30 <p_l> magical_pony, Gracenotes: Low-endian mudkips?
00:17:32 <Cale> There needs to be a pokemon called C-C-C-COMBO BREAKER
00:17:46 <p_l> *Little-Endian
00:18:18 <magical_pony> i should hope so, i have no idea what a big-endian mudkip would look like
00:18:58 <p_l> normally, "mudkip". However, here I had seen "Gracenotes: kip" "magical_pony: mud" :P
00:19:18 <magical_pony> oh, i get your joke now.
00:19:20 <Raevel> is there any difference in how universal quantifiers are treated with or without glasgow-exts in ghc (except that you get the syntactical forall)?
00:19:29 <Gracenotes> although, perhaps if you let them hold a big-endian rock in battle..
00:20:06 <Cale> Raevel: without that syntax, the implicit foralls are always considered to be at the very start of the type signature
00:20:20 <dmwit> Raevel: I'm not sure exactly which extensions glasgow-exts includes, but there are, for example, rank-n types and scoped type variables.
00:20:28 <Cale> Raevel: So, I suppose, you get other sorts of polymorphism
00:20:58 <Cale> Oh, yeah, the scoped type variables thing is another big difference
00:21:20 <opqdonut> does glasgow-exts include scoped typevars? i'm sure it doesn't have rankN
00:21:42 <Cale> I don't know, I haven't used it in many versions
00:21:57 <Raevel> ah okay
00:22:06 <Cale> If you explicitly quantify your type variables with forall, then the variables scope over the function/value's definition
00:22:24 <Cale> and can be used to refer to the type which the function was applied at
00:23:18 <opqdonut> there doesn't seem to be a list of the extensions -fglasgow-exts enables anywhere
00:24:00 <dmwit> I'm sure it's solidly deprecated by now anyway.
00:24:12 <Raevel> i was also wondering why an expression like (f -> (f 1, f ())) id doesn't type check, why isn't forall assumed for f?
00:24:13 <Cale> I'm almost certain I've seen one in the GHC documentation...
00:24:28 <Cale> Raevel: kind error?
00:24:30 <Cale> er
00:24:37 <Cale> Wait... that's an expression?
00:24:43 <dmwit> Raevel: That's rank-2 polymorphism.
00:24:51 <dmwit> Cale: He meant (\f -> (f 1, f ())) id
00:24:53 <Cale> Oh, it's meant to be a lambda
00:24:54 <Cale> yeah
00:25:03 <Raevel> oh, right, sorry
00:25:14 <Cale> Yeah, that required the inferred type for f to be polymorphic
00:25:39 <Cale> GHC never infers polytypes for function parameters
00:25:54 <opqdonut> http://darcs.haskell.org/ghc/compiler/main/DynFlags.hs
00:25:57 <opqdonut> search for glasgow
00:26:12 <Raevel> neither does ML iirc, is there a reason for it?
00:26:29 <opqdonut> ah, glasgowexts has Opt_ExistentialQuantification
00:26:35 <ChilliX> pumpkin: Great!
00:26:35 <lambdabot> ChilliX: You have 1 new message. '/msg lambdabot @messages' to read it.
00:26:50 <pumpkin> ChilliX: it's still a mess though :)
00:26:52 <opqdonut> Raevel: those are generally non-inferrable AIUI
00:27:13 <Saizan> Raevel: yes, type inference is undecidable for arbitrary-rank polymorphism
00:27:25 <Cale> However, you can, with rank-2 polymorphism give that function an appropriate type, like:
00:27:30 <ChilliX> pumpkin: Why a mess?  Did you have to change much?
00:27:41 <opqdonut> rank-2 is a nice compromise between inferrability and power
00:28:01 <pumpkin> ChilliX: well, the way I did it, I forgot to tell the linker to link x86_64, so I had to link all the things by hand because I didn't want to wait for the whole thing to recompile
00:28:10 <pumpkin> ChilliX: mostly had to change things in the Driver
00:28:14 <Cale> foo :: forall a. (a -> a) -> (Integer, ())
00:28:15 <Cale> er
00:28:23 <Cale> foo :: (forall a. a -> a) -> (Integer, ())
00:28:34 <Cale> foo f = (f 1, f ())
00:29:22 <Raevel> ah, i hade the impression that it was restricted for some reason (no idea where i got that idea from)
00:30:09 <Cale> Raevel: oh, you mean artificially?
00:30:35 <jkff> Note to self: By taking a lambda term, translating it into a point-free form (to combinators, for example), writing down the free theorem of every (now closed) subterm and solving the resulting system of type equivalences, we can obtain a nice free theorem for the whole term that is stronger than simply the free theorem of its type.
00:30:54 <Raevel> i'm not sure what you mean by artificially"
00:30:56 <pumpkin> ChilliX: the difficult mostly comes from mac os defaulting to building i386 instead of x86_64 (and I don't know any easy way of temporarily changing the default)
00:31:17 <Cale> Raevel: Er, I suppose I don't know what you meant by 'restricted'.
00:31:22 <Raevel> oh, terrible lag
00:31:30 <Raevel> :-D
00:33:09 <hatds> god
00:33:14 <pumpkin> ?
00:33:29 <jkff> [I wonder whether someone has already written a paper or a blogpost about that. If not, I will :) /me tries it out on "foldr (insertWhere (<)) []"]
00:33:35 <hatds> ghc just gave me 50 error dialogs in a row with only "OK" to go through them
00:33:42 <Raevel> bah, i have to get off this trait now. thanks for the help everyone, i may pop in later and try to explain myself :-)
00:33:48 <Raevel> s/trait/train
00:33:57 <Raevel> bye!
00:34:13 <jkff> @pl \lt -> foldr (insert lt) []
00:34:13 <lambdabot> flip foldr [] . insert
00:34:16 <hatds> and it wasn't some horrible crash... the problem was I specified  -hc and -hb at the same time for profiling
00:34:16 <jkff> @free flip
00:34:17 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
00:34:21 <jkff> @free foldr
00:34:22 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
00:34:29 <jkff> Thank you precious lambdabot
00:34:40 <hatds> ghc was trying to display a page of helpful readme text 15 words at a time over 50 dialogs
00:34:44 <Saizan> jkff: you apply free theorems with typeclasses involved?
00:35:01 <jkff> Nope, dictionary passing suffices
00:35:08 <jkff> @free (a->a->Bool)->a->[a]->[a]
00:35:08 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
00:35:15 <Saizan> ah, i see
00:35:38 <jkff> Hm. Lambdabot FAIL. Will use voigtlaender's..
00:36:03 <dmwit> hatds: Eh, what?  GHC... dialogs?
00:36:13 <Saizan> @free (a -> a -> Bool) -> a -> [a] -> [a]
00:36:13 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
00:36:22 <pumpkin> microsoft's latest product, Visual GHC!
00:36:45 <hatds> dmwit: well it was default error messages put into windows my program by GHC :)
00:36:47 <pumpkin> one of the marketing people was promoted to head of microsoft research
00:37:00 <hatds> dmwit: caused by running it with by "main.exe +RTS -hb -hc"
00:37:30 <hatds> *windows my = my windows
00:38:04 <dmwit> Huh, that doesn't sound like the GHC I know.  I wonder why it doesn't just use stderr...?
00:38:19 <hatds> you don't have stderr when compiling a windows program
00:38:31 <opqdonut> @scheck \(x :: Double) -> not (x == x+1)
00:38:32 <lambdabot>   Parse error in pattern at "->" (column 16)
00:38:33 <dmwit> um
00:38:35 <dmwit> stdout, then ;-)
00:38:45 <hatds> I don't think you have their either
00:38:47 <opqdonut> @scheck \x -> not ((x :: Double) == x+1)
00:38:48 <lambdabot>   "OK, passed 500 tests."
00:38:57 <dmwit> hatds: You *definitely* have stdout.
00:38:57 <jkff> Holy cow, that will be one scary system for foldr insert []
00:39:46 <dmwit> It might not be called stdout.  But you can interact with a terminal.
00:40:00 <cnwdup> @kind (StateT s)
00:40:01 <lambdabot> Not in scope: type variable `s'
00:40:05 <cnwdup> @kind (StateT String)
00:40:06 <lambdabot> (* -> *) -> * -> *
00:40:45 <hatds> I'm trying to find where I read that
00:42:04 <cnwdup> @kind MonadTrans
00:42:05 <lambdabot> Class `MonadTrans' used as a type
00:42:07 <hatds> in any case converting a stream intended for stdout into a series of dialogs is a bad idea :)
00:42:51 <dmwit> agreed =)
00:42:53 <cnwdup> How would I make a newtype PL s = PL { runPL :: StateT s (StateT Foo (ReaderT Bar IO)) a } instance of MonadTrans? Is this even possible?
00:43:09 <cnwdup> I'd like to access the inner StateT monad using lift.
00:43:10 <dmwit> deriving MonadTrnas
00:43:13 <opqdonut> cnwdup: there's no monad argument
00:43:18 <dmwit> with GeneralizedNewtypeDeriving
00:43:21 <cnwdup> opqdonut, and that's the problem, right?
00:43:27 <opqdonut> ?info MonadTrans
00:43:27 <lambdabot> MonadTrans
00:43:33 <opqdonut> well, yeah
00:43:35 <dmwit> ?undo MonadTrans
00:43:35 <lambdabot> MonadTrans
00:43:42 <dmwit> ?info x >>= f
00:43:43 <lambdabot> x >>= f
00:43:50 <dmwit> ?info do { x <- f; g x }
00:43:50 <lambdabot> f >>= \ x -> g x
00:44:01 <opqdonut> class MonadTrans t where
00:44:09 <opqdonut>   lift :: Monad m => m a -> t m a
00:44:31 <opqdonut> t need to have kind (* -> *) -> * -> *
00:44:39 <dmwit> cnwdup: In any case, I guess you meant you want to make it an instance of MonadState (and MonadReader, etc.).
00:44:41 <opqdonut> your PL has kind * -> *
00:44:41 <cnwdup> I see.
00:44:56 <opqdonut> (and besides, where does the a come from)?
00:45:02 <opqdonut> so you probably meant PL s a
00:45:03 <dmwit> cnwdup: You're going to have trouble with that, because there are two StateT monad transformers in there.
00:45:12 <opqdonut> that too
00:45:13 <cnwdup> dmwit, I have. But for the outer state. And I can't make it an instance of MonadState twice or can I?
00:45:19 <dmwit> cnwdup: No, you can't.
00:45:28 <dmwit> cnwdup: There's a fundep on MonadState that prevents it.
00:45:34 <cnwdup> opqdonut, I meant that. Yes.
00:45:47 <dmwit> cnwdup: Hence the "trouble." =)
00:46:38 <cnwdup> Ah, but I can do: getFoo :: PL Foo, getFoo = PL $ lift get. (:
00:46:41 <cnwdup> That's enough for me.
00:47:36 <mux> damn, I didn't think of that - now that I disabled some code on some platforms with #ifdef's, the documentation of my package on hackage misses some stuff since the platform where hackage built it can't have those functions
00:48:03 <mux> I should wire those to error calls instead I guess
00:48:21 <opqdonut> or #ifdef deprecation pragmas or something
00:48:50 <opqdonut> errors are too runtime, compile-time is always better
00:49:02 <mux> it's not a matter of deprecation though
00:49:38 <opqdonut> well that's the best solution i came up with
00:50:24 <opqdonut> it's a shame there's no ERROR pragma like in C
00:51:30 <mux> I guess I'll have to go with error calls
00:52:31 <mux> otherwise if I don't define those functions I'm thinking of, I can't have some instances either, which I really want to be in the docs though
00:53:16 <PetRat> I'm only dimly aware of how to use monad transformers. Do you have to use some variant on "lift" to put a function into an "inner monad" (not sure if that's the right term). If you "stack" more than two monad transformers, do you have to write more than one "lift"? If this is all way off never mind.
00:53:33 <opqdonut> mux: can't you preprocess first and then run haddock?
00:53:49 <mux> opqdonut: well this is hackage that is handling all of this
00:54:08 <opqdonut> well a few cabal rules should do it
00:54:10 <opqdonut> http://www.haskell.org/haddock/haddock-html-0.8/invoking.html#cpp
00:54:48 <mux> oooh
00:54:52 <mux> I could use __HADDOCK__
00:55:26 <mux> ah, that's not standard but passed via cabal
00:55:40 <mux> that won't do it, I'm not even using CPP but actually this is a .hsc file
00:55:52 <mux> maybe it would too though
00:55:58 <mux> I'll hava to check
00:56:15 <PetRat> Control.Monad.Cont "the mother of all monads"
00:56:20 <dmwit> PetRat: You use "lift" to take actions in the inner monad into actions in the transformed monad.
00:56:48 <PetRat> dmwit: just wondering if you've stacked more than one monad if you have to write lift twice.
00:56:48 <dmwit> PetRat: "lift" is polymorphic in a way that means you (should) only have to use it once to lift even a deep action up out of several layers.
00:56:57 <PetRat> oh
00:57:12 <dmwit> PetRat: However, it doesn't hurt to write it twice. =)
00:57:19 <PetRat> why is there a special liftIO?
00:57:38 <dmwit> :t lift
00:57:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
00:57:41 <dmwit> :t liftIO
00:57:42 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:57:55 <dmwit> Oh, you're right.  I was thinking of liftIO.
00:57:55 <Saizan> lift only works for a single transformer layer.
00:58:02 <dmwit> You have to lift several times, but liftIO only once.
00:58:10 <hydo> "If I had to talk to mysql with haskell, I'd use ________"
00:58:27 <opqdonut> _______ = "bdb anyway"
00:58:28 <PetRat> Is liftIO there for convenience or some deeper reason.
00:58:38 <PetRat> ?
00:58:42 <Saizan> convenience
00:58:44 <hydo> opqdonut: heheh... ok, I'll take a look.
00:59:15 <hydo> opqdonut: problem is that I need to have the same data present on multiple machines.
00:59:37 <hydo> That is, assuming bdb is a gdbm, sleepycat-like thing.
00:59:42 <Ycros> hydo: HDBC?
00:59:49 <opqdonut> hydo: bdb is Berkeley database
01:00:03 <opqdonut> a simple and efficient key-value db with replication etc
01:00:08 <pumpkin> it is sleepycat :)
01:00:17 <opqdonut> but i was just being snide actually
01:00:29 <hydo> Ycros: ok, I'll check it out.  There's a lot of them so I figured one or two were the accepted "one to use".
01:00:34 <opqdonut> ah, yes, sleepycat
01:00:37 <hydo> Ycros: oh, and thanks!
01:02:39 <Ycros> anyone having trouble with the convertible package from hackage? I'm trying to build version 1.0.1 and it's complaining about duplicate instance declarations (clashing with stuff defined in time-1.1.3)
01:03:10 <hydo> ycros: hah... I *just* got that same error.  I'm assuming there's something not set as a dependency in the cabal file.
01:04:12 <Ycros> hydo: it was all good last week or so. I but in the meantime I upgraded from ghc 6.10.1 to 6.10.3
01:04:30 <Ycros> I'm thinking some stuff might have gotten rolled into the time package from convertible
01:04:34 <Ycros> dunno.
01:04:56 <cnwdup> I have the data type Plugin s = P { getS :: s }. Is there a way to store different Plugin s in one container (list, data map, something) and let ghc figure out what type getS is depending whether it is called on Plugin Int or Plugin String?
01:04:58 <Ycros> I have no idea where any sort of repo is for the convertible package
01:05:43 <Ycros> hydo: I basically have a binary of my program that uses HDBC, and I can't recompile it with some changes I've been making because I can't install HDBC :-/
01:06:06 <dmwit> cnwdup: You can use rank-2 polymorphism to store plugins that conform to a class specification, or you can use Data.Dynamic.
01:06:30 <cnwdup> dmwit, I'd rather not use Data.Dynamic. Where can I read up about rank-2 polymorphism? That term is new to me. (:
01:06:31 <hydo> ycros: fixing it... or at least trying to.
01:07:16 <dmwit> cnwdup: Whoops, I don't think I meant rank-2 polymorphism.
01:07:45 <dmwit> Possibly existential quantification, instead.
01:08:07 <cnwdup> I'm trying that right now. Hopefully I can get the example to work.
01:08:29 <cnwdup> Just hoped there were something "better." I always run into problems using existential types.
01:16:30 <hydo> Ycros: comment out lines 60 - 66 in Data/Convertible/Instances/Time.hs and it'll build.  No idea if it will blow up on you, but it builds!  I'm going to build the tests when I get up to, hopefully, make sure everything is ok.
01:17:34 <Ycros> hehe
01:18:02 <hydo> Ycros: ugh.. I don't think that was the solution.  Now HDBC pukes duplicate definition errors.
01:19:15 <hydo> Temptation to downgrade to 6.10.2 building...
01:19:16 <quicksilver> dmwit, cnwdup : there is no need to involve classes.
01:19:26 <quicksilver> certainly what you are describing is an existential type.
01:19:28 <Ycros> hydo: I was going to try that actually
01:19:35 <Ycros> (commenting stuff out)
01:20:08 <dmwit> quicksilver: Is there a practical difference between...
01:20:26 <quicksilver> cnwdup: of course, what you actually described doesn't sound like it makes sense, so far.
01:20:45 <dmwit> data Plugin = forall s. Plugin { doSomething :: s -> String -> String; updateSomething :: s -> Plugin s }
01:20:52 <dmwit> and...
01:20:54 <cnwdup> quicksilver, what doesn't make sense?
01:20:55 <quicksilver> cnwdup: let's suppose for a moment we could call 'getS' in a way which returned "either and Int or a String but I don't know which"
01:21:03 <quicksilver> cnwdup: how would it be useful?
01:21:15 <quicksilver> cnwdup: what operations can we perform on "either an Int or a String but I don't know which" ?
01:21:26 <dmwit> quicksilver: [Plugin] vs. [forall s. DoesSomethingAndUpdatesSomething s => s]?
01:21:45 <quicksilver> dmwit: the fact that the class-based version restricts you to one pair of functions per type 's'
01:21:55 <quicksilver> dmwit: and always selects then based on the type.
01:22:01 <cnwdup> I want to know what type getS returns. But it should vary depending on the first argument. If it's called on Plugin Int or Plugin String.
01:22:13 <quicksilver> dmwit: whereas the simple higher order function version allows more flexibility.
01:22:23 <dmwit> Well, okay.  That's fair.
01:22:26 <cnwdup> And I need a way to store Plugin s and Plugin s1 in a container where I can access them from.
01:22:32 <quicksilver> cnwdup: think about how this will make sense in a wider context
01:22:49 <quicksilver> cnwdup: suppose we have a list of plugins of unknown type - pp :: [SomePlugin]
01:23:05 <quicksilver> cnwdup: if you call "getS (head pp)", what type does it return?
01:23:09 <quicksilver> remember type checking is static.
01:23:14 <quicksilver> how will you write code which makes sense?
01:23:19 <cnwdup> quicksilver, I don't want the types to be unknown.
01:23:34 <quicksilver> [aside: I'm not tryign to suggest these problems are insoluble. I'm just asking the questions which provoke the answer you need ;) ]
01:23:54 <quicksilver> cnwdup: but what is the type of "head pp" ?
01:24:31 <cnwdup> quicksilver, so I cannot use a list. (:
01:24:42 <dmwit> Of course, if the list of possible types is known in advance, all of this is kind of silly, so maybe we should ask if that's the case first...
01:24:53 <cnwdup> quicksilver, And yes, I apprechiate your provocation.
01:25:35 <cnwdup> Suppose I have a data structure which maps the plugin name to the plugin state (s). I'd like to lookup the state using the plugin name and ghc should tell me the type.
01:25:57 <cnwdup> But I don't know how to associate the plugin name with the plugin state and which data structure to use as storage container.
01:26:30 <cnwdup> I would have used the plugin's name as a string and the storage container as Data.Map String (Plugin s). But then I'll run into the same problem quicksilver described with lists. ):
01:26:31 <quicksilver> well, you sort-of can't have a structure which maps names to types
01:26:36 <quicksilver> because types aren't values, per se.
01:26:45 <hydo> Ycros: ok, well it builds with 598 - 593 and 598 - 603 commented out in Database/HDBC/SqlValue.hs
01:26:53 <hydo> Ycros: no word on stability though :)
01:26:54 <quicksilver> however, what you can do is create some values, which reify particular types.
01:26:59 <Ycros> hydo: I'm trying to downgrade time to 1.1.2.4 for now
01:27:08 <quicksilver> data PluginType = PTInt | PTString | {- other possibilities -}
01:27:14 <cnwdup> quicksilver, yeah. But since the name is unique I know which name is associated with which kind of value. And I'd like ghc to know that, too.
01:27:32 <cnwdup> quicksilver, my plugin type should be extensible from the plugin side and not from the main application side.
01:27:39 <hydo> Ycros: probably smarter... if things don't work perfectly I'll do that tomorrow.
01:28:21 <cnwdup> Can I somehow have a structure mapping names to states and tell ghc: names are unique, so please infer the type of the state for me?
01:28:28 <quicksilver> If it's not extensible from the main application side, that means the main application doesn't know the total set of possible plugin types
01:28:46 <quicksilver> if the main application doesn't know the total set of plugin types, then it can never possibly operate on them directly
01:28:56 <quicksilver> so, it doesn't matter, and you can just use an existential.
01:29:12 <Ycros> hydo: just worked for me
01:29:24 <cnwdup> quicksilver, I only want the main application to provide the container. Operation is done in the plugin code. But I'd like the plugins to type check.
01:30:01 <cnwdup> With existentials I can store Plugin s in the main app, but I cannot unwrap them in the plugin code.
01:30:12 <quicksilver> data Plugin s = Plugin { pluginState :: s, initPlugin :: s -> IO (), handleStuff :: s -> IO s, ...}
01:30:12 <cnwdup> I could use dynamic but then I cannot benefit from type checking.
01:30:22 <quicksilver> cnwdup: wrong.
01:30:35 <quicksilver> cnwdup: if you store all the functions which operate on 's' inside the plugin data structure
01:30:49 <quicksilver> then the type checker can check all the 's's match.
01:31:58 <cnwdup> quicksilver, that might work. I'll see if I can get my code to work with that. Thanks.
01:32:10 <quicksilver> sure :)
01:32:18 <quicksilver> I've written code very like this to handle particle systems, for example
01:32:26 <quicksilver> where the particles can store different kinds of internal state
01:32:31 <quicksilver> and the main program doesn't need to know what.
01:32:32 <JoshTriplett> I need to keep a mutable table of structures.  These structures will consist of a few small numeric values.  I'd like as much efficiency as possible.  Do I want the uvector package, or something else?
01:33:02 <cnwdup> quicksilver, yeah. I've been trying to do this for ages (every now and then) and I never got it to work properly. Hopefully I can get it right now.
01:33:47 <hatds> whenever you do data Foo = forall a. Foo (a, a->Int->Int, a->Bool) you could just as well say Foo = forall a. Foo (Int->Int, Bool)
01:33:58 <hatds> er, no forall in the 2nd one
01:34:10 <quicksilver> hatds: yes, but that's not normally the pattern.
01:34:18 <quicksilver> hatds: normally at least one of them returns 'a'
01:34:25 <quicksilver> (the "new state" after some kind of processing)
01:34:30 <Ycros> hydo: so I did "cabal install time-1.1.2.4" and then "ghc-pkg unregister --force time-1.1.3", unregister will list a bunch of packages that will be broken, so then I did "cabal install --reinstall <list of packages>"
01:34:35 <Ycros> hydo: now it's workin
01:34:41 <hatds> that's a little different then
01:34:42 <quicksilver> forall s. Foo (s, s -> IO s)
01:34:45 <quicksilver> for example.
01:35:10 <hydo> Ycros: ok... I'll do that tomorrow.  sleepy time right now.  Thanks for the info!
01:35:11 <quicksilver> or possibly data AnyFoo = forall s. Foo (s, s -> IO AnyFoo)
01:35:19 <quicksilver> ...which actually allows the mutator to change the state type.
01:35:28 <quicksilver> or even data AnyFoo = forall s. Foo (s, s -> IO [AnyFoo])
01:35:33 <quicksilver> which allows the Foos to reproduce.
01:35:49 <quicksilver> my particles were in the latter category.
01:36:04 <quicksilver> fireworks can explode, producing new particles of a different type.
01:36:35 <joeally> what is the fractional exponential (power or index) fucntion
01:36:48 <quicksilver> > 10 ** -0.25
01:36:49 <lambdabot>       precedence parsing error
01:36:50 <lambdabot>          cannot mix `(**)' [infixr 8] and pref...
01:36:53 <quicksilver> > 10 ** (-0.25)
01:36:55 <lambdabot>   0.5623413251903491
01:36:55 <joeally> oh
01:36:56 <quicksilver> stupid minus signs.
01:37:09 <joeally> i thought that was the floating one
01:37:21 <quicksilver> there is also (^^)
01:37:24 <joeally> what is the difference between float and fraction
01:37:26 <joeally> o
01:37:30 <joeally> .
01:37:37 <joeally> > :t (^^)
01:37:38 <lambdabot>   <no location info>: parse error on input `:'
01:37:38 <quicksilver> floating supports transcendentals like sin, cos, exp
01:37:46 <joeally> okay
01:37:47 <quicksilver> fraction just supports times and divide
01:37:56 <quicksilver> you need exp for a totally generalised power rule
01:37:57 <joeally> i dont need trig functions
01:38:12 <joeally> i am doing proabability
01:38:24 <joeally> the binomial distribution
01:38:31 <joeally> if i use (**)
01:39:11 <joeally> i get weird answers with 'e' (assuming that is the number that differentiates to itself) in
01:39:34 <joeally> i get this 4.000000000000001e-2
01:40:08 <alexey23> It's just exponentional notation.
01:40:21 <joeally> oh
01:40:51 <joeally> how do i get just an normal floaring point or fractional notaion
01:40:53 <alexey23> <m>e<p> means <m>*10^<p>.
01:41:31 <joeally> i thought e was 2.71....
01:41:59 <JoshTriplett> joeally: The 'e' here has nothing to do with the numeric constant 'e'.
01:42:07 <joeally> oh
01:42:17 <JoshTriplett> joeally: Just a piece of notation.  Like the 'd' in d/dx for differentiation.
01:42:30 <JoshTriplett> > 1e2
01:42:31 <joeally> oh
01:42:31 <lambdabot>   100.0
01:42:35 <JoshTriplett> > 1e4
01:42:36 <lambdabot>   10000.0
01:42:40 <joeally> ahhhhh
01:42:45 <joeally> oh i see
01:42:51 <joeally> standard form
01:42:58 <joeally> is it standard form
01:43:28 <joeally> so 4e4 is 4 times to to to the power 4
01:43:47 <joeally> or 4 multiplied by 10 to the power 4
01:43:49 <alexey23> joeally, why don't you use rationals? I think they are enough for the binomial distribution.
01:43:53 <JoshTriplett> joeally: The latter.
01:43:57 <JoshTriplett> > 4e4
01:43:59 <lambdabot>   40000.0
01:44:01 <joeally> they are the same thing
01:44:25 <joeally> alexey23: i dont know how to
01:44:28 <cnwdup> quicksilver, can I use existential qualification in the PluginMap type or do I have to use it on the Plugin data structure?
01:44:30 <joeally> i'm new to haskell
01:44:40 <alexey23> Check Rational.
01:44:43 <JoshTriplett> > 1 / 3
01:44:44 <lambdabot>   0.3333333333333333
01:44:50 <athos> > 1 % 3
01:44:51 <lambdabot>   1%3
01:44:54 <athos> :-))))))
01:44:54 <JoshTriplett> > 1 / 3 :: Rational
01:44:55 <lambdabot>   1%3
01:45:02 <joeally> oh
01:45:04 <JoshTriplett> > 3 * (1/3)
01:45:05 <lambdabot>   1.0
01:45:12 <athos> > 3 * 1%3
01:45:13 <lambdabot>   1%1
01:45:33 <joeally> > 4^^0.2 :: Rational
01:45:34 <lambdabot>   Add a type signature
01:45:36 * JoshTriplett hoped Haskell would make the classic floating point error there. :)
01:45:39 <alexey23> http://www.haskell.org/onlinereport/ratio.html
01:45:47 <joeally> > 4 ^^ 0.2
01:45:48 <lambdabot>   Add a type signature
01:46:02 <JoshTriplett> > 4 ^^ (1/5) :: Rational
01:46:03 <joeally> thanks
01:46:03 <lambdabot>   Add a type signature
01:46:17 <JoshTriplett> @type (^^)
01:46:18 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
01:46:24 <earthy> whoa!
01:46:24 <earthy> n142233:thesparse arthurvl$ ghci +RTS -H1024M -k128M -RTS -isrc
01:46:25 <earthy> Segmentation fault
01:47:02 <earthy> 'that shouldn't happen'
01:47:15 <JoshTriplett> earthy: Awesome.  That gives me a somewhat more descriptive error...
01:47:21 <joeally> it shouldnt
01:47:22 <JoshTriplett> ghc: internal error: splitLargeBlock: not a multiple of a megablock
01:47:41 <earthy> n142233:thesparse arthurvl$ ghci -isrc +RTS -k128M
01:47:41 <earthy> Too late for parseStaticFlags: call it before newSession
01:47:55 <earthy> what the ?!
01:48:14 <JoshTriplett> I can reproduce the problem with just this: ghci +RTS -k128M -RTS
01:48:19 * earthy nods
01:48:26 <earthy> ofcourse, it kinda makes sense
01:48:35 <earthy> as 128M doesn't fit in 8M
01:48:36 <earthy> but still...
01:48:52 <earthy> 'segmentation fault' is not the answer I expected. :)
01:49:01 <JoshTriplett> earthy: Indeed.
01:49:55 <sjanssen> I can't reproduce this
01:50:11 <earthy> sjanssen: I'm on Mac OS X
01:50:27 <sjanssen> earthy: where does 8M come from?
01:50:35 <earthy> The Glorious Glasgow Haskell Compilation System, version 6.10.2
01:50:46 <JoshTriplett> earthy: Ditto here.
01:50:49 <earthy> sjanssen: the default max stack size
01:50:50 <JoshTriplett> Actually...
01:50:55 <JoshTriplett> I take that back.
01:50:56 <JoshTriplett> The Glorious Glasgow Haskell Compilation System, version 6.10.1
01:51:18 <earthy> sjanssen: -k sets the per-thread stack size, but the default max stack size according to the docs is 8M
01:51:19 <sjanssen> oh, lower case k
01:51:27 * earthy nods
01:51:29 <earthy> innocent type
01:51:30 <earthy> typo
01:51:44 <sjanssen> funny bug
01:51:51 * earthy nods
01:52:26 <sjanssen> 6.8.2 seems to be fine
01:52:51 <sjanssen> 6.10.1 crashes with "ghc: internal error: splitLargeBlock: not a multiple of a megablock"
01:53:12 <pumpkin> onoes, not a megablock!
01:53:22 <JoshTriplett> How many of those in a gigaquad? ;)
01:53:36 <quicksilver> cnwdup: I'm not sure I understand your question but I think you'll want to use it on the Plugin structure
01:53:58 <joeally> **sighs
01:57:47 <cnwdup> quicksilver, but then I cannot call functions of the Plugin structure from main and I want to call functions like pluginName. I do not want to call functions which operate on the state, though.
01:58:21 <cnwdup> Do I have to seperate the function call-able from main and the functions only call-able from the plugins then?
01:59:08 <quicksilver> cnwdup: can you paste some type signatures or some names or something? It's a little hard to explain without something concrete to talk about
01:59:49 <cnwdup> Ok. Sec
02:00:10 <mib_uk2x9xa6> > Just Nothing
02:00:10 <joeally> what does this mean "*** Exception: stack overflow"
02:00:11 <lambdabot>   Just Nothing
02:00:27 <ivanm> joeally: you used up too much memory
02:00:32 <PetRat> > join $ Just Nothing
02:00:33 <lambdabot>   Nothing
02:00:40 <joeally> oh
02:01:05 <PetRat> join $ Just Just Just Nothing
02:01:09 <joeally> oh i spotted the problem
02:01:13 <ivanm> heh
02:01:14 <koeien> PetRat: it removes one level
02:01:23 <joeally> i did unending reoccursion
02:01:24 <dibblego> > join $ Just $ Just Nothing
02:01:25 <PetRat> > join $ Just Just Just Nothing
02:01:25 <lambdabot>   Just Nothing
02:01:26 <lambdabot>   Couldn't match expected type `(a1 -> Maybe a1)
02:01:37 <athos> > join $ [[a]]
02:01:38 <ivanm> joeally: yeah, that's a common cause
02:01:38 <lambdabot>   [a]
02:01:40 <dibblego> > join $ join $ Just $ Just Nothing
02:01:41 <lambdabot>   Nothing
02:02:05 <PetRat> > join $ Just $ Just $ Just Nothing
02:02:06 <lambdabot>   Just (Just Nothing)
02:02:15 <joeally> oh so i'll no that will proably be the problem
02:03:13 <PetRat> Besides lists and Maybe, what other monads provide simple examples for join?
02:03:35 <koeien> identity monad :)
02:03:36 <ivanm> the identity monad?
02:03:38 <ivanm> heh
02:03:59 <koeien> PetRat: that is the reason that in haskell, monads are most often described using (>>=) and return.
02:04:11 <koeien> while in category theory, one uses return & join most of the time.
02:04:43 <PetRat> koeien: can you amplify? what is the reason?
02:05:09 <dibblego> ((->) t)
02:05:11 <ivanm> is "because" good enough? ;-)
02:05:23 <koeien> PetRat: ehm, (>>=) is more intuitive for more monads
02:05:23 <ivanm> dibblego: oh? what's join on ((->) t) ?
02:05:27 <ivanm> function composition?
02:05:30 <PetRat> koeien said "that is the reason"
02:05:35 <dibblego> @type join :: (t -> t -> a) -> t -> a
02:05:36 <lambdabot> forall t a. (t -> t -> a) -> t -> a
02:05:39 <PetRat> so probably some reason is in mind
02:05:41 <yitz> > join (*) 5
02:05:43 <lambdabot>   25
02:06:07 <cnwdup> quicksilver, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2451#a2451
02:06:12 <ivanm> dibblego: just uses the one value everywhere?
02:06:12 <yitz> > join (,) "foo"
02:06:17 <lambdabot>   ("foo","foo")
02:06:21 <koeien> PetRat: >>= is easier to reason about "action composition", whereas join might be easier to reason about mathematically
02:06:26 <dibblego> @djinn (t -> t -> a) -> t -> a
02:06:27 <lambdabot> f a b = a b b
02:06:45 <quicksilver> > runWriter . join $ Writer(Writer (100, ["hello"]),["world"])
02:06:46 <lambdabot>   (100,["world","hello"])
02:06:55 <quicksilver> PetRat: maybe that's also fairly simple?
02:07:01 <quicksilver> although the runWriter/Writer noise is noisy.
02:07:18 <PetRat> So join on a function that takes two arguments puts the value there twice. join (*) 5
02:07:31 <dibblego> PetRat, prexactly
02:07:34 <koeien> from the Haskell wiki, "↑ This is perhaps due to the fact that Haskell programmers like to think of monads as a way of sequencing computations with a common feature, whereas in category theory the container aspect of the various structures is emphasised. join pertains naturally to containers (squashing two layers of a container down into one), but (>>=) is the natural sequencing operation (do something, feeding its results into something else)"
02:08:21 <PetRat> So you are putting a Writer monad in a Writer monad?
02:08:32 <quicksilver> cnwdup: OK, so you also need something like data AnyPlugin = forall s . AnyPlugin (Plugin s)
02:08:38 <ivanm> please, no "dawg" meme references...
02:08:48 * pumpkin clears throat
02:08:52 <cnwdup> quicksilver, ok
02:08:58 <quicksilver> cnwdup: and you will need getPlugin to return AnyPlugin
02:09:29 <quicksilver> cnwdup: but, your code implies that pluginB "knows" that pluginA has state type Int
02:09:40 <ivanm> pumpkin: down, boy! ;-)
02:09:40 <PetRat> What is the exact type of that writer? Writer Int [String]?
02:09:40 <quicksilver> that's not going to work under this system.
02:09:57 <quicksilver> PetRat: Writer [String] Int, in fact.
02:10:12 <quicksilver> the "log" comes before the "contained value"
02:10:39 <quicksilver> cnwdup: because 'getPlugin' has already lost the information that pluginA has state type Int.
02:11:15 <PetRat> What properties of a monad mean you can put another one inside it? It would be a parameterized monad with the appropriate type properties on the parameter?
02:11:16 <pumpkin> :)
02:11:22 <cnwdup> quicksilver, could I have something like getPlugin :: Plugin s -> m (Plugin s) where I would call the plugin depending on the plugin's type? Then the plugin's type should be unique which should be doable.
02:11:34 <pumpkin> I think xzibit probably invented join
02:11:41 <pumpkin> actually
02:11:47 <quicksilver> cnwdup: you could even have simply getPlugin :: m (Plugin s)
02:11:52 <fasta> quicksilver: I tried to run it with the debugger and pressing C-c to stop the infinite loop, btw. The result was a segmentation fault ^^.
02:11:59 <cnwdup> quicksilver, how would that work?
02:12:03 <quicksilver> cnwdup: which would 'automatically' return the right plugin based on type inference.
02:12:13 <quicksilver> cnwdup: well, in practice you'd need a class for it
02:12:23 <quicksilver> getPlugin :: RegisteredType s => m (Plugin s)
02:12:38 <quicksilver> and the class would 'know' where to find the canonical plugins of each type.
02:12:42 <quicksilver> somehow.
02:12:43 <pumpkin> actually, xzibit probably did the opposite of join (duplicate) in Control.Comonad
02:12:50 <cnwdup> quicksilver, what kind of structure would I use to store the plugins? After all they have a mutable state.
02:12:50 <quicksilver> fasta: ops :)
02:13:08 <quicksilver> cnwdup: well maybe you need have IORef s instead of just s.
02:13:23 <quicksilver> cnwdup: or maybe you need the whole thing to be in an IORef, as in IORef (Plugin s)
02:13:33 <quicksilver> depends how much cna mutate.
02:14:14 <cnwdup> quicksilver, ok. I'll need some time to think about that, though.
02:14:55 <PetRat> Is "Either s" defined as a monad somewhere?
02:14:58 * pumpkin proposes that we rename duplicate :: w a -> w (w a) in Control.Comonad to yodawg
02:15:19 <idnar> PetRat: unfortunately not, but (Error s) => Either s is defined in Control.Monad.Instances
02:16:03 <PetRat> idnar: what does that notation mean? (Error s) => Either s
02:16:13 <quicksilver> cnwdup: agreed. It is all possible but it's not obvious what the right path is without a little more info.
02:16:14 <dibblego> s belongs to the type-class Error
02:17:51 <cnwdup> quicksilver, I'll try to find a solution myself. If I run into trouble then I should at least be able to provide more information.
02:18:26 <quicksilver> cnwdup: another possibility is simply to have pluginA provide a "global" to get itself.
02:18:34 <quicksilver> GetPluginA :: PL (Plugin Int)
02:18:50 <quicksilver> cnwdup: obviously the main program doesn't "know about" pluginA, so it would never call that.
02:19:09 <quicksilver> cnwdup: but if pluginB is specifically designed to know about pluginA, then it knows that symbol and can get it type-safelu.
02:19:16 <ahamay42> PetRat: You can also just do the declaration yourself (nice practice)
02:19:21 <cnwdup> But pluginB could call that, right? Then it would be okay to index plugins by plugin names (String)?
02:20:11 <quicksilver> cnwdup: you don't even need Strings, for this.
02:20:21 <quicksilver> cnwdup: GetPluginA is a standard haskell value
02:20:31 <quicksilver> cnwdup: it's just a question of module imports, then.
02:20:38 <quicksilver> PluginB does "import PluginA(GetPluginA)"
02:20:48 <quicksilver> so PluginB has a type-safe way of getting pluginA
02:21:08 <cnwdup> But how would it get the state? I have to ask the main application for that.
02:21:10 <quicksilver> whereas, if you use the generic version : getPlugin "PluginA"
02:21:43 <quicksilver> you get an AnyPlugin
02:21:50 <quicksilver> which is useful for some things, but not for others.
02:21:58 <quicksilver> I.e. you can't call handleStuff, because that needs exact type knowledge
02:22:04 <quicksilver> but you can call the other things where it doesn't matte.r
02:22:20 <cnwdup> But pluginB needs to call handleStuff on pluginA.
02:22:44 <quicksilver> yes.
02:22:49 <Smorg> How do you clean out all temporarily defined functions in ghci? (e.g. let foo = some func)
02:22:50 <quicksilver> which it can, because it has access to GetPluginA
02:22:56 <quicksilver> which returns the type-correct one.
02:23:04 <cnwdup> quicksilver, ah! Okay. Thanks. (:
02:23:06 <quicksilver> So effectively, you have two ways of getting PluginA
02:23:17 <quicksilver> getPlugin "PluginA" :: PL AnyPlugin
02:23:25 <quicksilver> getPluginA :: PL (Plugin Int)
02:23:26 <cnwdup> So I have one way to get the function and one way to get the value of the state.
02:23:40 <quicksilver> the first way works from any module, but you don't have access to the type info
02:23:50 <quicksilver> the second way only works from modules which import PluginA's interface
02:23:57 <quicksilver> i.e they have to "know about" pluginA.
02:24:35 <Ferdirand> 1
02:24:37 <Ferdirand> oops
02:27:48 <quicksilver> cnwdup: it still remains to answer the question of what a Plugin "is", where they are actually stored, and which part is mutable.
02:28:05 <quicksilver> but this questions too surely have answers :)
02:28:05 <cnwdup> I hope I can figure that out myself.
02:31:44 <dibblego> the unit for a Parser :: String -> (String, Maybe a) would be \a s -> (s, Just a) right?
02:33:39 <quicksilver> yes. That consumes nothing of the input and always successfully returns a
02:35:27 <joeally> I am doing a poisson distribution how do i get the mathematical constant 'e'
02:35:33 <quicksilver> > exp 1
02:35:34 <lambdabot>   2.718281828459045
02:35:39 <joeally> cheers
02:35:47 <joeally> > exp 2
02:35:48 <lambdabot>   7.38905609893065
02:35:51 <joeally> ohh
02:35:52 <quicksilver> that's e^2
02:35:55 <quicksilver> ;)
02:35:56 <joeally> oh
02:35:58 <joeally> i get it
02:36:00 <joeally> thanks
02:36:11 <DrSyzygy> > exp (log 3)
02:36:12 <lambdabot>   3.0000000000000004
02:36:17 <Zao> (derive . e) 1 :P
02:36:23 <DrSyzygy> > exp (log 3) :: CReal
02:36:24 <lambdabot>   3.0
02:52:57 <Smorg> > [y+1 | y <- x, y < 10]
02:52:58 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Expr'
02:53:17 <ivanm> Smorg: need to define what "x" is...
02:54:51 <paul424> what does it mean in haskell the sentence a::b for types ... that a is subtype of b right ?
02:55:00 <pumpkin> no
02:55:06 <pumpkin> identifier a is of type b
02:55:23 <ray> :t drunkard
02:55:25 <lambdabot> Not in scope: `drunkard'
02:55:34 <paul424> pumpkin: aha ok thanks
02:57:31 <ivanm> with ReadS, how does one denote a "failed" read?  Can you?
02:57:40 <Smorg> ivanm: interesting this bot catches an error. If I let x = 1 : [y+1 | y <- x] I get an unbounded infinite list. If x = 1 : [y+1 | y <- x, x<10] then it actually prints something but still seems to be unbounded: [2,3,4,5,6,7,8,9,10^CInterrupted.
02:57:48 <ivanm> or would you use "ReadS (Maybe a)" ?
02:58:04 <ivanm> Smorg: it does?  that's weird...
02:58:14 <pumpkin> > let x = 1 : [y+1 | y <- x] in x
02:58:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:58:28 <ivanm> oh, I didn't see the ":"
02:58:30 <Smorg> (in ghci)
02:58:54 <ivanm> Smorg: because it's a recursive definition for x
02:58:55 <pumpkin> Smorg: it's still going to keep looking
02:59:05 <PetRat> http://www.mibbit.com/pb/5msXLq  Is this the right definition of "Either s" as an instance of Monad?
02:59:15 <pumpkin> it isn't smart enough to tell that element 10000000000000000000 won't be < 10 again
02:59:17 <ivanm> the error is that you didn't have "let x = 1 :" in what you gave to lambdabot
02:59:33 <dmwit> ivanm: failure is (const []), no?
03:00:04 <ivanm> dmwit: hmmm.... I was hoping more for a "trial parsing", where it returned the String if it couldn't parse
03:00:25 <ivanm> *shrug* but "const []" works as well... just can't chuck the String away, that's all
03:00:40 <dmwit> PetRat: Looks good to me.
03:01:12 <Smorg> Yeah i've been working all day trying to figure out a smart way to test for equivilence for hilbert's hotel-ish problems since that seems to be a major reason for why you would want to have such an infinite construct.
03:01:15 <dmwit> PetRat: In actual Haskell, we have to add a "fail" function; this is why the Either instance usually comes with an Error constraint.
03:01:23 <Smorg> > [0,2..] ++ [1,3..] == [0..]
03:01:24 <lambdabot>   False
03:01:58 <PetRat> What does the fail look like?
03:02:03 <pumpkin> > merge [0,2..]  [1,3..] == [0..]
03:02:04 <lambdabot>   Not in scope: `merge'
03:03:13 <PetRat> Smorg: are you asking lambdabot to do something in the realm of proof?
03:03:25 <pumpkin> it's not even true
03:03:53 <Smorg> > (sort([0,2..] ++ [1,3..)) == [0..]
03:03:55 <lambdabot>   <no location info>: parse error on input `)'
03:04:10 <Smorg> yes basically proof
03:05:20 <dmwit> PetRat: Something like fail = Left . strMsg
03:05:21 <ivanm> Smorg: well, Haskell doesn't really work too well for automatic proofs like that
03:05:22 <Smorg> > (sort([0,2..] ++ [1,3..])) == [0..]
03:05:23 <dmwit> :t strMsg
03:05:24 <lambdabot> forall a. (Error a) => String -> a
03:05:25 <ivanm> see Coq, etc.
03:05:30 <ivanm> @instances Error
03:05:40 <ivanm> come on, lambdabot...
03:05:59 <lambdabot> Couldn't find class `Error'. Try @instances-importing
03:05:59 <pumpkin> @instances-importing Error
03:06:01 <lambdabot>   thread killed
03:06:01 <Ferdirand> Tho0uLe8ieHin7iequeilioth
03:06:06 <pumpkin> o.O
03:06:09 <Ferdirand> oops
03:06:13 <pumpkin> o.O
03:06:14 <ivanm> @hoogle Error
03:06:20 <dmwit> ?instances-importing Control.Monad.Error Error
03:06:22 <pumpkin> sounds like you need a new passphrase :P
03:06:30 <ivanm> hmmm... lambdabot sure is slow tonight...
03:06:32 <Smorg> with coq I need to learn more logic :(
03:06:47 <lambdabot> Couldn't find class `Error'. Try @instances-importing
03:06:56 <lambdabot> module Control.Monad.Error
03:07:01 <lambdabot> module Foreign.C.Error
03:07:05 <lambdabot> module Foreign.Marshal.Error
03:07:05 <pumpkin> Smorg: I don't think any system could tell you that without having lots of information already
03:07:07 <lambdabot> Plugin `instances' failed with: thread killed
03:07:24 <pumpkin> Smorg: ...not even WOLFRAM ALPHA ;)
03:07:27 <yitz>  > concat (zipWith (\x y -> [x,y]) [0,2..] [1,3..]) == [0..]
03:08:04 <dmwit> > concat (transpose [[0,2..], [1,3..]]) == [0..]
03:08:19 <lambdabot>   thread killed
03:08:33 <PetRat> http://www.mibbit.com/pb/SEPxIX Here is an example of using Either s as a Monad. A result of "Left .." short-circuits the computation. The case statement is awkward because it requires giving a result for the "Right" case that is discarded.
03:08:45 <yitz> oh, we shouldn't abuse \bot with these things if she's feeling out of sorts
03:08:53 <dmwit> But more seriously: no, the purpose of infinite data is not for doing infinite proofs.
03:09:26 <Smorg> I'm sure this runs into russel's paradox-esque problems mathematically.
03:09:43 <ivanm> @seen lambdabot
03:09:44 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
03:09:44 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-in-depth, #haskell-freebsd, #macosx, ##freebsd, #
03:09:44 <lambdabot> gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
03:10:14 * ivanm thinks lambdabot needs to cut down on how many IRC channels she idles in...
03:10:30 <lilac> the idea of #functionaljava scares me
03:10:30 <lambdabot> lilac: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:10:35 <ivanm> really, functionaljava?  I thought Java was the archenemy...
03:10:41 <ivanm> lilac: heh
03:11:13 <dmwit> PetRat: That's an example, I guess, though I wouldn't say it's a particularly compelling one.
03:11:21 <Lemmih> @leave jhc
03:11:35 <ivanm> maybe we need to split lambdabot into multiple instances... haskell channels, and non-haskell channels
03:11:51 <Lemmih> @leave #jhc
03:11:53 <PetRat> dmwit: I guess it's more common to use Error in these circumstances?
03:11:57 <pumpkin> Lemmih: I think it's @part
03:12:02 <pumpkin> unless @leave is working
03:12:11 <lilac> @tell roconnor gah, you and your non-commutative addition... ;-)
03:12:11 <lambdabot> Consider it noted.
03:12:11 <ivanm> Lemmih: apparently, that channel doesn't exist if I try and do /topic to it... >_>
03:12:41 <dmwit> PetRat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5069#a5069
03:13:17 <dmwit> PetRat: It's not a good example because it isn't replacing any nested cases. ;-)
03:13:32 <yitz> @seen lambdabot
03:13:32 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.
03:13:32 <lambdabot> hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-in-depth, #haskell-freebsd, #macosx, ##freebsd, #gentoo-uy, #
03:13:32 <lambdabot> gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
03:14:17 <PetRat> I see that this example is easier to do without the monad.
03:15:30 <yaxu> Hi all, I'm playing around with hint (Data.Haskell.Interpreter), and would like to interpret a string into a value of type Int -> [String]
03:15:47 <cnwdup> > data Foo a = (Num a) => Foo a
03:15:49 <lambdabot>   <no location info>: parse error on input `data'
03:16:04 <Smorg> > all (>=0) [0..]
03:16:10 <cnwdup> Can I have type constraints on data types?
03:16:13 <Smorg> yep definitely not going to work then
03:16:19 <lambdabot>   thread killed
03:16:21 <yaxu> however it won't let me do that, because Int -> [String] isn't an instance of class Typable
03:16:24 <quicksilver> cnwdup: Yes. Don't do it though.
03:16:28 <dmwit> cnwdup: Yes, but it's generally frowned upon.
03:16:40 <cnwdup> ok
03:16:45 <yaxu> is it possible to make it an instance, and if so how would I go about doing that?
03:16:59 <quicksilver> > typeOf (\a -> show (a :: Int))
03:17:02 <lambdabot>   Int -> [Char]
03:17:11 <PetRat> yaxu: can you say more about why you are doing this?
03:17:12 <quicksilver> yaxu: Int -> [String] is indeed an instance of Typeable.
03:17:19 <quicksilver> > typeOf (\a -> [show (a :: Int)])
03:17:21 <lambdabot>   Int -> [[Char]]
03:17:33 <quicksilver> (typeOf uses Typeable, so it must be)
03:18:27 <PetRat> :t typeOf
03:18:29 <lambdabot> forall a. (Typeable a) => a -> TypeRep
03:18:39 <fasta> What does a gigantic Foo.CAF mean in a heap profile?
03:18:41 <yaxu> PetRat: I'd like to make a music interface where dynamically interpreted haskell code is turned into musical patterns
03:19:02 <yaxu> quicksilver: hm, let me find the error message I'm getting then
03:19:28 <PetRat> Music! That's my ultimate interest in Haskell as well. Computer-assisted composition.
03:20:05 <dmwit> Man, I don't even remember what CAF stands for.
03:20:12 <pumpkin> constant applicative form doesn't it?
03:20:33 <yaxu> PetRat: nice, have you looked as hsc3?
03:20:42 <dmwit> Right, that's it.
03:20:58 <fasta> pumpkin: yes, but I already knew that part.
03:21:10 <yaxu> tsch, I was doing something stupid.  Sorry and thanks quicksilver
03:21:22 <pumpkin> fasta: it means you have a large constant taking up all your memory somewhere because it isn't getting GCed
03:21:25 <pumpkin> fasta: I'd assume
03:21:26 <fasta> pumpkin: you get the same when you do primes = <insert create all primes>
03:21:33 <pumpkin> yeah
03:22:04 <fasta> pumpkin: except, that I don't have something like that in my program, atleast probably it is lurking somewhere, but I have no idea where.
03:30:51 <lilac> @seen augustss
03:30:58 <pumpkin> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
03:31:02 <pumpkin> they killed lambdabot
03:31:05 <lilac> @seen augustss
03:31:11 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
03:31:20 <augustss> I'm here
03:31:28 <fasta> There should be a library somewhere having a function which races a list of IO computations and returns the one which finished the earliest. What's its name? Hoogle/Hayoo didn't work for [IO ()] -> IO()
03:31:28 <lilac> @yow! and WIPED LAMBDABOT'S MIND!
03:31:35 <lambdabot> YOW!!  What should the entire human race DO??  Consume a fifth of
03:31:44 <lambdabot> CHIVAS REGAL, ski NUDE down MT. EVEREST, and have a wild SEX WEEKEND!
03:32:03 <lilac> augustss: i've uploaded a new version of the 'numbers' package with a more correct Enum instance
03:32:09 <lilac> for Natural
03:32:11 <lambdabot> lilac: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:32:17 <p_l> Baughn: Please don't follow lambdabot's advice... please
03:32:26 <augustss> lilac: Oh, was Enum broken?
03:32:52 * p_l read that as "what would erase human race" ;D
03:32:53 <lilac> augustss: yep, it was using the defaults for everything, which really don't work for infinity :)
03:33:01 <augustss> Ah, yes.
03:33:09 <augustss> Thanks!
03:33:17 <lilac> np
03:33:59 <doserj> fasta: sth like http://code.haskell.org/unamb/src/Data/Unamb.hs ?
03:34:41 <ManateeLazyCat> If i use GADTs create "data PageBuffer a where ... ", how to i create instance of `PageBuffer`?
03:35:00 <quicksilver> ManateeLazyCat: using one of the constructors you defined in your GADT?
03:35:02 <pumpkin> instance?
03:35:44 <fasta> doserj: it's not exactly the same as the function I had written 2 years ago, but it will probably work.
03:36:22 <lilac> fasta: foldr race (newEmptyMVar >>= takeMVar) ?
03:36:44 <Baughn>  @index ClockTime
03:36:47 <Baughn> @index ClockTime
03:36:48 <lambdabot> System.Time
03:36:50 <lilac> that should probably be foldM :)
03:38:11 <ManateeLazyCat> quicksilver: I have exist module use `Dynamic` reference different TYPE object, so i don't know how to use GADTs instead `Dynamic`, I want keep *reference* those objects, but those objects are different type.
03:38:46 <ManateeLazyCat> quicksilver: I think i haven't understand how to use GADTs.
03:41:27 <eu-prleu-peupeu> hi
03:41:30 <eu-prleu-peupeu> now im coding in python
03:41:35 <eu-prleu-peupeu> in my job
03:41:40 <ManateeLazyCat> quicksilver: Any idea?
03:42:02 <eu-prleu-peupeu> i still haven't got used to the "return" in python :( i guess haskell makes more sense after you get used to it
03:45:54 <cnwdup> quicksilver, I am trying to use a plugin record which is the interface the main application uses for plugins. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2452#a2452 What's wrong with pluginRecUpdateState? ghc tells me type variables are escaping.
03:48:21 <quicksilver> ManateeLazyCat: your question doesn't make sense to me I'm afraid.
03:49:05 <quicksilver> cnwdup: there's nothing wrong with what you've written int hat paste.
03:49:17 <cnwdup> I cannot use :t pluginRecUpdateState in ghci.
03:49:29 <quicksilver> yes
03:49:30 <cnwdup> I think I cannot access the records fields containing s.
03:49:36 <quicksilver> record seletors don't work well with existentials
03:49:49 <quicksilver> it's best to make a two-stage process
03:49:55 <cnwdup> Ah, but pattern matching will work?
03:50:01 <quicksilver> should do, yes.
03:50:10 <eu-prleu-peupeu> pattern matching :)
03:50:37 <cnwdup> Oh my, I thought there's no way to use such functions because of existential types. O:
03:52:08 <quicksilver> cnwdup: I normally do the existential in a separate type - and only that, in that type.
03:52:20 <quicksilver> cnwdup: so I'd do data PluginRec s = { ... stuff with selectors .. }
03:52:37 <quicksilver> data AnyPluginRec = forall s . AnyPluginRec (PluginRec s)
03:53:00 <cnwdup> How would I access the plugin's state from the main application?
03:53:16 <cnwdup> s/access/change/
03:53:29 <cnwdup> Nope. Actually access and change.
03:54:08 <quicksilver> well, what could you possibly change it to? since you don't know what type it is ;)
03:54:32 <quicksilver> but for example, if your PluginRec structure had a field of type "s -> s" then you could apply that to the value
03:54:38 <quicksilver> and stuff the result back in the IORef.
03:55:46 <cnwdup> ok
04:01:05 <Baughn> :t threadDelay
04:01:06 <lambdabot> Not in scope: `threadDelay'
04:01:13 <Baughn> :t Control.Concurrent.threadDelay
04:01:15 <lambdabot> Int -> IO ()
04:04:23 <helmut> Hi. I'm trying to implement suffix trees in haskell and I generally hit stack space limits. could someone have a look for improvements? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5070
04:05:07 <Berengal> helmut: Make the structure stricter
04:06:25 <helmut> I know that it isn't strict enought, but how to improve?
04:07:06 <Berengal> You could make some of the fields in your data structure strict
04:07:23 <helmut> uhm. I don't understand that
04:08:09 <helmut> for instance Common should not permit an empty String.
04:15:37 <fasta> dcoutts: profileviewer: Prelude.(!!): index too large (the demo distributed with GTK2HS)
04:16:40 <dcoutts_> fasta: probably the parser is old and broken, it was designed for the ghc prof format from many years ago
04:17:26 <dcoutts_> fasta: it could do with some updates I'm sure, and to use the proper machine readable format rather than the human one
04:18:04 <fasta> dcoutts_: in fact, it appears to be working fine; I just inputted an invalid file and the parser is not robust.
04:18:05 <Reiv> You know, it vaugely startles me that this place can have a netsplit that fills my entire screen and still has 500+ members...
04:18:59 <dcoutts_> fasta: right, it was just a quick demo. If you're using it seriously you might want to spend a couple hours making it robust and possibly even replacing the parser
04:19:28 <dcoutts_> fasta: a decent version could be released as a separate package on hackage
04:23:56 <Smorg> Does the empty list in haskell not act like the empty list in set theory since (elem [] [[1],[]] == True) but (elem [] [[1]] == False) ?
04:24:32 <BONUS> nope
04:25:24 <Smorg> :)
04:28:16 <solidsnack> Smorg: The "empty list" in Set theory, or the "empty set"?
04:28:36 <Smorg> empty set
04:28:52 <Smorg> oops didn't notice I said empty list.
04:30:09 <solidsnack> So if I do unsafePerformIO to get an IORef and pass it around, how bad is that?
04:30:41 <Smorg> so with that exception nup any list is the same as the definition of a set
04:31:16 <solidsnack> Smorg: Lists can contain duplicates.
04:32:27 <ziman> Smorg, well, there's difference between \subseteq and \in, in set theory, {} ∉ {{1}} as well
04:32:41 <Smorg> s/nup/nub
04:32:57 <solidsnack> Smorg: Oh, I understand now.
04:34:03 <ziman> > [] `isInfixOf` "foo bar baz"
04:34:06 <lambdabot>   True
04:34:10 <ziman> > [] `elem` "foo bar baz"
04:34:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
04:34:24 <dcoutts_> solidsnack: using unsafePerformIO within your program is generally wrong
04:34:35 <solidsnack> dcoutts: Yes, I know.
04:35:21 <dcoutts_> solidsnack: the only excuses are for low level hacks hidden behind nice interfaces, not within the main body of your code
04:35:23 <Smorg> heh how do you get infix? I thought it was in the list module but it doesn't seem to exist for me. isPrefixOf and isSuffixOf work
04:35:32 <solidsnack> dcoutts: Yes.
04:35:50 <solidsnack> dcoutts: I'd like to have a kind of handle that knows whether it's been opened or not.
04:36:14 <solidsnack> So I presumably need to do the same hacks that allow a handle to know where it's seeked to.
04:36:28 <dcoutts_> solidsnack: that's fine, constructing the handle can be done in IO and can create an IORef, no need for unsafe perform
04:36:52 <dcoutts_> solidsnack: similarly, all action on the handle will also be in Io, so no need for unsafe perform
04:37:06 <solidsnack> Well, hmmm.
04:40:39 <solidsnack> dcoutts: You know, I did not explain myself very well.
04:41:26 <solidsnack> Hmm, okay.
04:41:32 <solidsnack> I will need to think this over a bit.
04:41:55 <solidsnack> There is a really significant difference between constructing a computation that always opens the file and one that may open the file.
04:42:00 <xenoblitz> Quick question: Is it ok for me to say: It is important to note that GADTs are still data types and so are first-class objects in Haskell which can be manipulated by the language. Type-classes are not however.
04:42:25 <solidsnack> xenoblitz: GADTs are first class objects?
04:43:02 <xenoblitz> solidsnack: as in they create items which you can directly manipulate like any data
04:43:25 <xenoblitz> solidsnack: I could be wrong I want to see what other people think :)
04:43:57 <quicksilver> xenoblitz: yes, a GADT is just another kind of data type.
04:44:09 <solidsnack> xenoblitz: I think it's quite reasonable to say they are a datatype.
04:44:26 <solidsnack> Whereas typeclasses are not.
04:44:35 <dcoutts_> xenoblitz: values are first class, values of a GADT data type are still values. I'm not sure we'd say strictly that types are first class.
04:45:24 <xenoblitz> dcoutts: maybe this is better: It is however important to note that GADTs are still data types and so the objects which are created using such types are first-class objects which can be manipulated by the language. Type-classes are not however.
04:45:58 <dcoutts_> xenoblitz: yep, though I might switch "object" for "value"
04:46:06 <dcoutts_> xenoblitz: object is a loaded term to many readers
04:46:29 <xenoblitz> dcoutts: thanks :)
04:57:10 <Baughn> @msg conal Congratulations. You've got me obsessively debugging your library just before exams. >_<
04:57:11 <lambdabot> Not enough privileges
04:57:19 <ivanm> lol
04:57:22 <Baughn> @tell conal Congratulations. You've got me obsessively debugging your library just before exams. >_<
04:57:23 <lambdabot> Consider it noted.
04:57:32 <ivanm> which library is this? reactive?
04:57:39 <Baughn> Yes
04:57:49 <Axman6> heh
04:58:33 * ivanm still doesn't get the point of FRP
04:59:45 <Baughn> ivanm: It lets you compose your programs by functionally specifying the timelines of whatever objects might be changing. That's rather nice.
04:59:55 <Baughn> As far as mutation goes. ;)
04:59:58 <ivanm> do you have a concrete example?
05:00:11 <Baughn> I wish I did, but no. I keep running into the bugs.
05:00:18 <ivanm> see, I get that that's what it does... how it's useful is a different story
05:00:22 <Baughn> Once I've fixed those to my satisfaction, I'll get you some. ;)
05:00:30 <ivanm> heh
05:00:59 <Baughn> ivanm: But basically, if your program requires mutation /anyway/, this is a nicer way to think about it
05:01:02 <Baughn> At least for me
05:01:15 <ivanm> *nod*
05:01:41 <ivanm> is it basically implicitly mapping and discarding an infinite stream of inputs?
05:03:16 <Baughn> ivanm: I don't want to answer that. I'm not sure I understand it well enough myself, and it could very easily lead to misunderstandings.
05:03:21 <ivanm> *nod*
05:03:33 <Baughn> Did you read the paper?
05:03:36 <ivanm> that's how I understanding the whole "let's update the evaluation" thing
05:03:37 <ivanm> no
05:03:39 <marcusb> hi!  what's the beginners way to implement a functor for a simple recursive type (arithmetic expressions, lots of operators but simple stuff) without all the boilerplate?
05:03:39 <ivanm> which one? :p
05:03:55 <ivanm> marcusb: the beginners way is not to do so I believe... ;-)
05:04:01 <marcusb> argh :)
05:04:05 <Baughn> ivanm: Conal's.
05:04:10 <marcusb> what's the advanced beginners way? :)
05:04:14 <ivanm> if by "beginners" you mean "beginning haskellers"
05:04:22 <ivanm> I've never implemented a functor
05:04:32 <ivanm> never really needed to AFAIK
05:05:10 <Baughn> marcusb: Thinking..
05:05:19 <Baughn> marcusb: (Well, compiling)
05:05:40 <mokus> "beginning haskeller" is a pretty wide stretch of time - I'd say I was a beginning haskeller for almost 2 years, and I'm not a slow learner by any stretch of interpretation
05:06:08 <Baughn> marcusb: It's very hard to implement functors automatically, since there are generally a hundred different possible functors for any moderately complex datatype
05:06:28 <Baughn> marcusb: Although your own mental model might make only one of them correct, the compiler doesn't know that
05:06:33 <marcusb> mokus: okok, what's the easiest way that does not involve me typing the same basic rule "f op a1 a2 = op (f a1) (f a2)" again and again
05:06:43 <ivanm> in the sense that I don't go around casually writing new monads all the time, and that I don't use/understand most of the advanced techniques or theory behind them, I am most definitely a beginner haskeller
05:06:59 <ivanm> hmmm.... a Haskell Cadet? :p
05:07:01 <marcusb> Baughn: well, sure.  but "Show" and "Eq" know how to do it
05:07:04 <marcusb> for my simple case
05:07:05 <solidsnack> marcusb: It's called sed.
05:07:11 <ivanm> with SPJ being Lord High Grand Master? :p
05:07:24 <Baughn> marcusb: Because those two are much easier to get right. Show and Eq just need to print/compare all the data, respectively.
05:07:46 <Baughn> marcusb: However, you might get some use from Scrapping Your Boilerplate.
05:09:07 <marcusb> well, maybe my question is really "What's the common idiom".  if most users don't use generics for this, but just write it down, maybe I should do that as well
05:09:25 <Baughn> marcusb: Speaking for myself, I've never written a Functor complex enough that I cared
05:09:49 <Baughn> (So that's one vote for "do it manually")
05:10:05 <Berengal> Functor instances are usually just a couple of lines of code anyway
05:10:54 <quicksilver> marcusb: uniplate can do that.
05:11:04 <quicksilver> marcusb: (automate your functor instance)
05:11:18 <quicksilver> Berengal: marcusb's isn't.
05:11:29 <quicksilver> Berengal: it's on like per op constructor, and I gather he has lots.
05:11:31 <doserj> ghc 6.12 can do it
05:11:52 <Berengal> quicksilver: Right... I haven't been paying attention, sorry
05:12:03 <doserj> http://hackage.haskell.org/trac/ghc/ticket/2953
05:12:19 <marcusb> quicksilver: realistically, typing it down will be faster than learning the generic modules, but the latter may be more rewarding
05:12:41 <ivanm> hmmm.... where people sometimes talk about Monads being containers, isn't it really _Functors_ that are the containers? (or is the container description pre-Functor?)
05:13:11 <ahamay42> monads are just special functors, so what's the problem?
05:13:20 <quicksilver> ivanm: Yes.
05:13:20 <Baughn> Probably that they aren't. ;)
05:13:29 <Baughn> ahamay42: They should be, yes
05:13:35 <quicksilver> ivanm: Functors are really the contains. Monads are containers in which you can collapse multiple layers.
05:13:42 <ivanm> *nod*
05:13:57 <ivanm> collapsible containers? for easy storage when you're not using them?
05:14:02 <dev31212> Hello, does it take an ungodly amount of time to build the "encoding" module on linux, or is something wrong?
05:14:11 <dev31212> it gets stuck on 43 of 47 and has been here for about 30 minutes
05:14:13 <ivanm> dev31212: it is long
05:14:17 <ivanm> due to too much TH IIRC
05:14:18 <Berengal> Of course, saying they're containers isn't the entire truth...
05:14:18 <Baughn> quicksilver: And if the monad tutorials explained this, there would be a lot less confusion to go around
05:14:26 <dev31212> ah ok ivan
05:14:28 <dev31212> thanks
05:14:36 <dev31212> so I will let it continue, I guess
05:14:43 <ivanm> highlighting-kate also takes forever
05:14:47 <dev31212> Also, anyone used Turbinado?
05:14:59 <dev31212> hmm highlighting-kate
05:15:25 <marcusb> scrap your boilerplate seems to describe my situation
05:16:17 <quicksilver> marcusb: Uniplate is something like a simplified SYB
05:16:22 <quicksilver> much easier to program with, IMO.
05:16:25 <quicksilver> less powerful though.
05:16:37 <quicksilver> Baughn: I imagine some of them do. I haven't read many monad tutorials.
05:16:56 <quicksilver> I strongly suspect new monad tutorials are being written faster than I can read anyway.
05:17:02 <Baughn> quicksilver: I've read a few, but I never saw anything like that before reading the tcopedia
05:17:42 <marcusb> I think I only need map's and folds
05:20:38 <cnwdup> I load a .hs as a plugin using make and load. If the plugin's module line is "module Name where" all is fine. If I name it "module Plugin.Name where" it fails with unknown symbol "base_GHCziBase_unpackCStringzh_closure." Why is that minor edit causing this?
05:21:04 <cnwdup> The Plugins are the following files ./Plugin/Name.hs. So I figured the latter module line was right.
05:21:17 <quicksilver> that's very peculiar, cnwdup
05:21:29 <quicksilver> I can't explain that error.
05:23:01 <Jedai> marcusb: Most usage of generic programming (SYB) could be written without it, but with much more boilerplate, it's up to you to decide if in your case the gain from generic programming would upset the cost of learning a generic library (and I warmly recommend Uniplate too, it's enough for most usage, faster than SYB and easier to learn and use)
05:25:00 <marcusb> Jedai: that's great.  it's sometimes a bit hard to find the right entry point to a problem solution among all the things that are haskell :)  The reason I am looking for this as a beginner is this: After reading the first haskell tutorials, you learn how easy it is to work over lists with map and fold.  and then, when you start defining your own types, you lose this elegance.  generic programming gives it back.
05:27:08 <dev31212> hmm generic programming.
05:27:15 <dev31212> Can you provide a link? :)
05:27:30 <dev31212> Your description is persuasive.
05:28:22 <Baughn> dev31212: Hackage://uniplate and/or scrab your boilerplate
05:28:29 <quicksilver> the uniplate paper is a readable place to start
05:28:30 <Jedai> dev31212: http://community.haskell.org/~ndm/uniplate/
05:28:32 <quicksilver> IMO.
05:28:36 <quicksilver> describes the problem + the solution
05:29:01 <dev31212> Thanks
05:32:43 <PeakerWork> Baughn: did you manage to debug Reactive a bit?
05:34:21 <Baughn> PeakerWork: Not yet. Well, I did manage to switch out TimeT for a fixed-point version, which will come in handy later.
05:34:29 <Baughn> PeakerWork: But I've got exams on tuesday, so.. yeah.
05:37:12 <tomh> does anyone have experience in using alex tokens with position information in happy?
05:37:42 <tomh> more specifically how can i add that position info in my final structure in an elegant way :)
05:41:41 <frankks> i'm trying to understand some code, and part of it uses 2 lambdas, does that mean something different? (\\)
05:42:00 <dev31212> encoding still hasnt built :(
05:42:28 <tomh> frankks: i think thats just divide or something
05:42:34 <tomh> @src (\\)
05:42:34 <lambdabot> (\\) = foldl (flip delete)
05:42:39 <tomh> oh lol
05:42:55 <vininim> @src delete
05:42:56 <lambdabot> delete = deleteBy (==)
05:43:26 <vininim> @src deleteBy
05:43:27 <lambdabot> deleteBy eq x []        = []
05:43:27 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
05:43:50 <vininim> > delete 5 [1..10]
05:43:52 <lambdabot>   [1,2,3,4,6,7,8,9,10]
05:44:08 <vininim> seeing is believing
05:44:48 <frankks> @src ($)
05:44:49 <lambdabot> f $ x = f x
05:46:07 <EvilTerran> > delete 2 [1,2,3,2,1]
05:46:08 <lambdabot>   [1,3,2,1]
05:46:36 <dev31212> > take 2 [1,3,4,6]
05:46:38 <lambdabot>   [1,3]
05:47:07 <dev31212> ( (delete 1).(take 2) ) [1,2,3,4,5,6,7]
05:47:21 <dev31212> >( (delete 1).(take 2) ) [1,2,3,4,5,6,7]
05:47:30 <dev31212> > ( (delete 1).(take 2) ) [1,2,3,4,5,6,7]
05:47:32 <lambdabot>   [2]
05:49:39 <Jedai> tomh: GHC does that
05:50:29 <tomh> mm you know any specific methods or you only are aware that ghc does that? :P
05:52:10 <dev31212> Generic seem promising.
05:52:29 <dev31212> Though, from a newbs point of view, doesnt this kind of go against the spirit of uber-strong typing?
05:52:46 <dev31212> hmm nevermind
05:52:50 <dev31212> I guess maybe it doesnt.
05:53:04 <dev31212> I think ill pick that back up after I master a few more basics.
05:53:39 <PeakerWork> Baughn: exams sound better than deadlines, I guess
05:53:53 <dev31212> Hell yes they do.
05:53:59 <dev31212> College kids have it easy.
05:54:23 <dev31212> As ap rofessional, not only do you have to study more and still have to "cram"
05:54:26 * EvilTerran has both D:
05:54:35 <dev31212> And instead of passing with a C, you get fired for a C
05:55:43 <dev31212> makes wish I was a career grade student living on grants
05:59:16 <bremner> dev31212: well, feel free to come over to the happy-fun-lazy side :-)
05:59:59 <dev31212> heh
06:09:27 <madhadron> So, I'm in the process of writing software to control automated microscopes with Haskell...
06:09:40 <madhadron> and I realized I was reinventing FRP
06:10:08 <madhadron> so does anyone have any wisdom on which of the FRP libraries to use today?
06:13:29 <Zao> Elerea seems to be under development at least, no idea of how it compares.
06:14:36 <madhadron> It's certainly the smallest and most immediately comprehensible
06:15:23 <madhadron> I kind of like reactive's partially push semantics, but probably the time resolution required for microscopy makes that completely irrelevant.
06:15:47 <quicksilver> intuitively I prefer reactive, but that may be partly because I understand it better.
06:16:13 <madhadron> quicksilver, In that case, can you point me to how to hook it up to IO?
06:16:21 <pozic> How can I make a global mutable variable? I can do myGlobal = newIORef 0, but I don't see how I can obtain the actual reference in some unrelated part of the program without reinitalizing the variable every single time. I just want to read it (writing is easy, once you have the ref).
06:16:25 <madhadron> I feel like a dunce, but I can't figure out how to generate sources and sinks
06:16:52 <madhadron> pozic, Have you looked at MVar?
06:16:57 <pozic> I want to use it in code which is not in the IO monad, so I will have to use some unsafePerformIOs in the process.
06:17:11 <pozic> madhadron: I don't care about synchronizing variables for this application.
06:17:46 <madhadron> pozic, <shrugs> They may be overkill, but they certainly make it easy.
06:18:14 <quicksilver> pozic: myGlobal = unsafePerformIO (new IORef 0)
06:18:26 <quicksilver> pozic: I won't help you use it though, because I do not understand it
06:18:36 <dev31212> Is it common for people to use mutable variables?
06:18:40 <pozic> quicksilver: oh, of course.
06:18:51 <quicksilver> you need {-# secret GHC pragmas #-} to make it do what you want
06:18:52 <dev31212> You gurus, I mean
06:19:07 <pozic> quicksilver: I already had that in my file, but forgot for a moment that it wasn't an action anymore at that point ;)
06:19:28 <quicksilver> madhadron: No :) I've never used conal's implementation. I have a partial implementation of my own which I know how to hook up to IO ;)
06:19:29 <pozic> quicksilver: yes, nobody knows what unsafePerformIO actually does.
06:19:45 <quicksilver> actually I know what it does. I just don't know how often GHC will execute it.
06:19:57 <madhadron> quicksilver, I see.  Ah well.
06:20:12 <quicksilver> and having thought about it for a while I am convinced it's the wrong solution, so I haven't spent the time learning the quirks of the optimiser.
06:22:10 <randomity> as far as I know, the hack of a module-scope unsafePerformIO'd IOVar is semi-supported, and generally works (although it's never not ugly)
06:22:37 <randomity> depending on what you're doing, implicit parameters might solve the problem better than mutable globals, have a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
06:22:48 <quicksilver> it's semi-supported insofar as the standard lib uses it.
06:23:01 <randomity> (although they might be completely unsuitable, it depends what you're planning with your global)
06:23:09 <quicksilver> on the other hand, chunks of the standard lib are written in compiler primitives, so I guess that's not inconsistent.
06:25:55 <pastorn> is there a monadic version of mapAccumL?
06:26:10 <pastorn> or do i need to write it myself?
06:26:11 <quicksilver> mapM in StateT over the monad you first thought of?
06:27:06 <pastorn> quicksilver: our monad is already an instance of MonadState, so that'd probably make things go south
06:27:30 <quicksilver> it wouldn't make things go south, no.
06:27:43 <quicksilver> it just means you'd need to be careful
06:31:10 <madhadron> Aha.  I found how to hook Conal's reactive to IO...
06:31:53 <quicksilver> yay :)
06:31:55 <madhadron> Hidden down in FRP.Reactive.LegacyAdapters, there's a makeEvent which hands back a sink and an event.
06:33:05 <madhadron> So you makeClock, then pass that to a bunch of makeEvents, which you then proceed to hook up as callbacks from whatever's coming in from outside.
06:33:28 <madhadron> What confused me is that the type shown in the Haddock docs looks mangled
06:33:40 <madhadron> makeEvent :: Clock TimeT -> a :+-> Event a
06:34:37 <quicksilver> a :+-> b is a type constructor meaning (a -> IO (), b), IIRC
06:34:48 <quicksilver> I.e. Sink a, b
06:34:55 <madhadron> Aha.  No wonder I was confused.
06:35:24 <madhadron> Is that defined in reactive, or off in the core somewhere?
06:36:28 <quicksilver> reactive somewhere
06:36:56 <madhadron> Thanks.
08:01:59 <fasta> Is there a parallel version of mapM?
08:03:41 <doserj> sequence . parMap strat f?
08:04:49 <fasta> doserj: I doubt that will work. That will only evaluate the actions in parallel, not execute them in parallel.
08:06:17 <doserj> yeah. but a parallel sequence isn't really possible, is it?
08:06:28 <Saizan> why not?
08:06:46 <Saizan> fasta: there's a lib on hackage iirc
08:07:59 <Saizan> i don't recall the name though..
08:08:14 <mmorrow> fasta: that reminds me of an old paste, not exactly what you're after, but related. maybe it'd be useful (note: i don't recall if i tested this) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=828
08:08:49 <gnuvince> Could anyone look at this and tell me if there's a nicer way to write the last parameter of loop? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2453#a2453
08:09:00 <quicksilver> there was something called nMergeIO or somethign, wasn't there?
08:09:05 <quicksilver> @hoogle nmergeio
08:09:05 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
08:09:06 <mmorrow> (it really should be called parSequence_ i guess. it ensures that only N threads are running at a time)
08:09:18 <quicksilver> hmm I'm not sure that's what I wanted though :)
08:09:38 <mmorrow> whoa, didn't know about nmergeIO
08:09:38 <fasta> mmorrow: yes, the worker threads thing. That's also something I wrote before. This time, however I don't want to have IO.
08:09:51 <mmorrow> fasta: ah, interesting. hmm
08:10:18 <fasta> Why does nmergeIO have IO in its return type?
08:11:36 <mmorrow> i guess it probably returns results as they finish
08:12:26 <mmorrow> (finish evaluating or something)
08:12:35 * mmorrow looks for the code of nmergeIO
08:15:22 <fasta> It's sort of the analog of + having the type Int -> Int -> IO Int
08:16:16 <mmorrow> i think though that the order of elems in the result list is nondeterministic
08:16:23 <mmorrow> ah, found the code
08:16:25 * mmorrow pastes
08:17:52 <mmorrow> fasta, quicksilver: nmergeIO: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5075#a5075
08:19:10 <Axman6> how cool, seems i'll be learning Ada next semester
08:20:28 <Raevel> there's a new ada course at my school, you write a simulator for a rally car driver in the western part of sweden
08:20:37 <Raevel> or so i've heard
08:20:41 <quicksilver> that's very specific.
08:20:51 <mmorrow> heh
08:20:58 <qaz> > let (->) a b = a+b in (->) 10 20
08:21:00 <lambdabot>   <no location info>: parse error on input `->'
08:21:00 <quicksilver> is a simulator for a rally car driver in northern spain, say, a very different thing?
08:21:10 <qaz> > let (_>) a b = a+b in (_>) 10 20
08:21:11 <lambdabot>   <no location info>: Parse error in pattern
08:21:22 <doserj> quicksilver: in winter, yes
08:21:31 <mmorrow> quicksilver: you probably have to simulate the soil composition differently or something :P
08:21:37 <quicksilver> ah yes
08:21:48 <quicksilver> I always forget to correctly account for soil composition, in my rally simulators
08:21:54 <Baughn> quicksilver: It's sweden, so you only need to draw trees on every side of the road
08:22:00 <quicksilver> the migration routes of birds often catches me out too.
08:22:00 <mmorrow> it's one of those "gotchas" for sure
08:22:09 <mmorrow> ooh, true
08:22:18 <Axman6> also, Ada needs to know what soil it will be simulating at compiloe time
08:22:25 <Axman6> or it will throw an error
08:23:06 <Axman6> type Soil is sandy loam;
08:23:09 <fasta> If there are no performance criteria, there is a very nice solution you can use.
08:23:17 <gnuvince> Could anyone look at this and tell me if there's a nicer way to write the last parameter of loop?  http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2453#a2453
08:24:07 <fasta> You can use a similar argument for every data structures course that has questions of the form given an outline of an algorithm which runs in O(f(n)) time (where they leave out that it must have a practical constant).
08:26:11 <fasta> give*
08:29:05 <qaz> > let (_) a b = a+b in (_) 10 20
08:29:07 <lambdabot>   <no location info>: Parse error in pattern
08:29:16 <qaz> > let f a b = a+b in f 10 20
08:29:18 <lambdabot>   30
08:29:33 <qaz> > let (*****) a b = a+b in (*****) 10 20
08:29:34 <lambdabot>   30
08:29:49 <qaz> > let (*+) a b = a+b in (*+) 10 20
08:29:50 <vininim> > let (._.) a b = a*b in 10 ._. 20
08:29:51 <lambdabot>   30
08:29:52 <lambdabot>   <no location info>: parse error on input `)'
08:29:57 <qaz> > let (*+) a b = a+b in (*+) 10 20
08:29:59 <lambdabot>   30
08:32:54 <Axman6> wow... Ada is confusing
08:34:47 <quicksilver> qaz: lambdabot responds to private messages.
08:38:20 <pe> Hi. Is there a way to declare IO things instances of Show ? i.e. instance Show IORef where ... ?
08:38:21 <roadwarrior> can one downgrade ghc to 6.8 after installing the latest haskellPlatform on windows?
08:38:31 <mmorrow> fasta: maybe something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5075#a5076
08:38:42 <Zao> roadwarrior: Nothing stops you from having more than one GHC on the system.
08:38:48 <quicksilver> pe: nothing stops you making IORef an instance of Show, but it may be quite hard to make it a useful instance.
08:39:07 <quicksilver> pe: instance Show (IORef a) where show r = "<IORef>"
08:39:10 <quicksilver> pe: for example...
08:39:11 <Zao> roadwarrior: Installed libraries are tied to the GHC version used though, so you'd get (sane) multiple installs when reinstalling a library.
08:39:23 <quicksilver> would be a valid, if not terribly useful, instance.
08:39:31 <mmorrow> fasta: (where the sort's useless unless one cares about deterministic results)
08:39:48 <pe> quicksilver : right, ok :-)
08:39:59 <roadwarrior> Zao: ok, thats what I wanted to know. So it binds to the correct version.
08:40:00 <roadwarrior> thanks
08:40:26 <quicksilver> pe: you could imagine an instance which at least showed some underlying unique ID (perhaps even a memory pointer) for the purposes of telling them apart.
08:40:40 <quicksilver> pe: but, you'd need access to the internals of the implementation to do that :(
08:41:18 <Zao> roadwarrior: Whichever one is found as "ghc" is the one first in the path.
08:41:19 <mmorrow> fasta: personally, i'd just skip the sort, since then it'd work on infinite lists (but not be deterministic of course)
08:41:27 <pe> quicksilver : I'm doing a C binding, I have a CString in a struct, and I'd just like to be able to print myStruct
08:41:38 <Zao> I believe you can invoke them as  ghc-6.8.3  if you want a particular one.
08:41:42 <quicksilver> @hoogle CString
08:41:42 <lambdabot> Foreign.C.String type CString = Ptr CChar
08:41:42 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
08:41:42 <lambdabot> Foreign.C.String newCString :: String -> IO CString
08:41:47 <Zao> Or just not put them in path and point them out when you need them.
08:42:05 <fasta> mmorrow: my problem was a parallel mapM where the order of the effects is not important, as long as they happen.
08:42:10 <quicksilver> pe: well the cleanest thing to is to have a haskell-version of the data structure which actually contains the string
08:42:14 <quicksilver> pe: not just a Ptr...
08:42:14 <fasta> mmorrow: but this is nice too.
08:42:19 <mmorrow> fasta: ah, right. hmm
08:42:26 <pe> quicksilver : ok, thanks
08:42:36 <mmorrow> fasta: yeah, /me adds nmerge to his library
08:43:06 <roadwarrior> Zao: Ok
08:44:02 <fasta> mmorrow: what's the point of the [[a]] in the type of nmergeIO btw?
08:44:12 <fasta> mmorrow: is every list for one core?
08:44:25 <fasta> mmorrow: or thread/whatever
08:44:55 <mmorrow> i'm not sure, i didn't look at the code that closely
08:44:57 * mmorrow looks
08:45:16 <mmorrow> ah
08:45:18 <mmorrow> -- The 'mergeIO' and 'nmergeIO' functions fork one thread for each
08:45:18 <mmorrow> -- input list that concurrently evaluates that list;
08:50:52 <fasta> mmorrow: yes, that's what I expected.
08:52:22 <quicksilver> pe: if you dont' much care, you could unsafePerformIO the Ptr read
08:52:55 <mmorrow> instance (Show a) => Show (IORef a) where show ref = unsafePerformIO (show `fmap` readIORef a)
08:53:01 <mmorrow> oop
08:53:02 <pe> that's an idea. In fact in a C binding ...
08:53:03 <mmorrow> oo
08:53:06 <mmorrow> instance (Show a) => Show (IORef a) where show ref = unsafePerformIO (show `fmap` readIORef ref)
08:53:10 <pumpkin> lol
08:53:15 <mmorrow> s/oo/s/
08:53:37 <mmorrow> , [|\x->x|]
08:53:41 <lunabot>  LamE [VarP x_0] (VarE x_0)
08:53:54 <mmorrow> instance Show ExpQ where show = unsafePerformIO . runQ
08:54:03 <mmorrow> instance Show ExpQ where show = show . unsafePerformIO . runQ
08:54:05 <mmorrow> i mean
08:55:18 <mmorrow> (which makes it essentially to hide (runIO :: IO a -> Q a) in teh bot)
08:57:05 <mmorrow> pumpkin: so you've got a booted ghc for osx x86_64?
08:57:15 <pumpkin> yeah, but it's not usable right now
08:57:26 <mmorrow> aww, what's the breakage?
08:57:28 <pumpkin> you have to link the .o files by hand
08:57:35 <pumpkin> I did it a few times but it's a pain
08:57:37 <mmorrow> ah
08:57:59 <pumpkin> it's a pretty easy fix from there though
08:58:08 <pumpkin> I just forgot to add some parameters to the driver
08:58:10 <mmorrow> pumpkin: iirc ghc calls ld from compiler/main/{DriverPipeline,SysTools}.lhs
08:58:16 <pumpkin> yup
08:58:30 <pumpkin> I added suitable parameters to the cc and as steps of DriverPipeline, but forgot ld :)
08:58:34 <mmorrow> heh
08:58:37 <mmorrow> "doh!"
08:58:45 <pumpkin> and was too lazy to wait for it again
08:58:46 <pumpkin> :P
08:59:20 <mmorrow> if you do edit that again, it might be nice if those mods didn't have hardcoded options for the various progs..
09:00:00 <mmorrow> or at least, just as the fallback if no over-ride flags are provided (somehow)
09:00:16 <pumpkin> well, they're represented as preprocessor conditionals on the target
09:00:30 <pumpkin> so they only add the flags in if you're compiling for mac os x and x6_64
09:00:33 <pumpkin> x86_64
09:00:39 <mmorrow> pumpkin: yeah, i mean keep those, but add the ability to override the defaults
09:00:46 <pumpkin> ah
09:01:07 <mmorrow> (you'd have to workout some way to specify overrides though..)
09:01:17 <pumpkin> yeah, makes sense
09:01:18 <mmorrow> which may or may not turn into an epic
09:02:38 <pumpkin> :)
09:02:46 <pumpkin> I need to shower and go out! I'll be back
09:08:00 <lilac> @hoogle pipe
09:08:00 <lambdabot> package Pipe
09:08:01 <lambdabot> package shell-pipe
09:11:09 <lysgaard> How do i make my own typeclass for the (^)
09:11:19 <lysgaard> \:t (^)
09:11:33 <quicksilver> well, the built-in (^) uses Num and Integral
09:11:36 <quicksilver> nothing you can do abotu that
09:11:48 <quicksilver> you can write your own function called (^) and make it do whaetver you want, of course
09:12:03 <pumpkin> you can also write an instance that can be a base, or an exponent of (^)
09:12:47 <lysgaard> Yeah, that's what i'm after. I have my own datatype and i want (^) te behave in a special way on it
09:13:16 <lilac> how can i call pipe(2) from Haskell? do i have to FFI it or is it already available somewhere?
09:13:34 <pumpkin> lysgaard: write a Num instance if you want your type to be the base, or an integral instance if you want it to be the exponent
09:14:10 <lysgaard> pumpkin: What if i want it to be in both?
09:14:23 <quicksilver> lilac: does anything in System.Process do what you want?
09:14:25 <pumpkin> integral is both, but in that case you probably don't want (^)
09:14:31 <pumpkin> :t (**)
09:14:33 <pumpkin> :t (^^)
09:14:34 <lambdabot> forall a. (Floating a) => a -> a -> a
09:14:35 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
09:14:49 <quicksilver> lilac: what do you want to do with the pipe once you've made it, in other words?
09:14:57 <quicksilver> pumpkin: well (^) isn't a method, it's a function.
09:15:02 <quicksilver> its semantics are fixed.
09:15:05 <pumpkin> I know
09:15:08 <quicksilver> it always works by repeated squaring.
09:15:18 <pumpkin> yeah
09:15:24 <quicksilver> so you can't make your type do anything other than repeated squaring.
09:15:39 <lysgaard> Hm, ok, but i just need a method i can make an instance of
09:15:45 <pumpkin> I never implied otherwise, did I? :o
09:15:58 <lilac> quicksilver: i'm trying to implement unsafeInterleaveIO in terms of lazy IO ;-)
09:16:15 <lysgaard> So (^) won't cut it. What are my options then?
09:17:04 <lysgaard> pumpkin: Can i use any of (**) (^^) ?
09:17:14 <pumpkin> @src Fractional
09:17:15 <lambdabot> class  (Num a) => Fractional a  where
09:17:15 <lambdabot>     (/)             :: a -> a -> a
09:17:15 <lambdabot>     recip           :: a -> a
09:17:15 <lambdabot>     fromRational    :: Rational -> a
09:17:18 <pumpkin> @src Floating
09:17:19 <lambdabot> class  (Fractional a) => Floating a  where
09:17:19 <lambdabot>     pi                                                      :: a
09:17:21 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
09:17:23 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
09:17:25 <lambdabot>     (**), logBase                                           :: a -> a -> a
09:17:31 <quicksilver> lysgaard: what are you actually trying to do?
09:17:43 <quicksilver> pumpkin: that's really spammy :P
09:17:52 <pumpkin> sorry :(
09:18:04 <dev31212> Say, if I know the name of a module...in this case "Config.Database" what is the easiest way to find out what package I need to install?
09:18:06 <quicksilver> lilac: lol.
09:18:23 <quicksilver> lilac: maybe it's FFIed already by somethign in System.Posix?
09:18:37 <quicksilver> @hoogle Config.Database
09:18:38 <lambdabot> No results found
09:18:46 <quicksilver> dev31212: try searching on hoogle or hayoo
09:18:53 <dev31212> oh thats what hayoo is
09:18:54 <dev31212> gotcha
09:18:58 <dev31212> thanks quicksilver
09:19:23 <quicksilver> hmm.
09:19:27 <quicksilver> neither of them finds it, though.
09:19:27 <lysgaard> pumpkin: I'm making a symbolic math type, and now i want to implement the raise to function: http://hpaste.org/fastcgi/hpaste.fcgi/save
09:19:43 <pumpkin> um
09:19:45 <quicksilver> lysgaard: I would just give it a new name.
09:20:00 <quicksilver> > a ^ 5
09:20:02 <lambdabot>   a * a * (a * a) * a
09:20:08 <quicksilver> is repeated squaring so bad? ;)
09:20:25 <pumpkin> it can't show sharing :/
09:20:33 <pumpkin> the simple-reflect
09:20:40 <lysgaard> Well, cant use it for  (a + 1)^(a - 4)
09:20:50 <quicksilver> lysgaard: ah, indeed you can't :)
09:21:10 <quicksilver> lysgaard: I think you're best of giving it a new name.
09:21:30 <lysgaard> So, should i just make a new function, that does my type of squaring
09:28:56 <leimy> dons: around?
09:30:12 <lilac> quicksilver: hooray, System.Posix.IO.createPipe :)
09:30:30 <leimy> @seen dons
09:30:30 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 1h 4m 55s ago.
09:30:40 <quicksilver> lilac: ;)
09:30:54 <leimy> found a bug in ByteString.CSV :-)
09:34:05 <dev31212> ahhh I found out what I did wrong :p
09:34:09 <dev31212> silly mistake...
09:34:22 <dev31212> evidently with Trubinado it is up to YOU to provide the Confid.Database...
09:34:48 <mmorrow> lilac: i've got some code that ffi imprts pipe (among other things) at the bottom of http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/MMGV.hs
09:34:53 <dev31212> turbinado*,Config.Database*
09:35:30 <quicksilver> dev31212: Aha! :)
09:36:06 <mmorrow> lilac: (and has a minimal wrapper for (c_pipe :: Ptr CInt -> IO ()) ==> (pipe :: IO (CInt, CInt)) that brackets (mallocArray 2) free
09:39:37 <mmorrow> lilac: actually, this code is better. it has the same pipe wrapper code/etc as the one i just linked to, but also ffi imports select (stolen (and de-underscored ;) from oleg's zfs code)  http://moonpatio.com/repos/lunabot/Dup.hs
09:39:57 <mmorrow> selectR :: [CInt] -> IO [CInt]
09:40:21 <mmorrow> oleg was also having the select call block, this one passes in a 0 timeout
09:40:39 <lament> conal: nice post on purity of c
09:40:40 <mmorrow> (i.e. don't block at all)
09:40:49 <lament> conal: i always felt this way but was unable to express it :)
09:41:03 <eu-prleu-peupeu> conal elliot last post is cool
09:41:09 <leimy> hehe yeah
09:41:15 <leimy> C++ is pure too
09:41:19 <leimy> if you just count templates :-)
09:42:31 <conal> lament: :)  thanks!
09:42:31 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:42:35 <leimy> But really, isn't everything doing a form of I/O to memory and registers?
09:42:38 <conal> eu-prleu-peupeu: thanks!
09:42:39 <leimy> even if really really pure?
09:42:44 <leimy> something is doing "I/O" at some point :-)
09:42:47 <conal> and two "t"s in Elliott, please!
09:42:48 <lament> leimy: then what does "really really pure" mean?
09:42:54 <leimy> exactly
09:42:58 <leimy> it boils down to "pure enough"
09:43:02 <leimy> followed by "who cares?"
09:43:11 <leimy> and lastly, if you want to be rude "now stfu!" :-)
09:44:06 * leimy is trying to figure out if he should attempt to fix dons's CSV parser.... or if he should just live with the limitations.
09:44:21 <conal> there.  i just posted a couple of replies at http://conal.net/blog/posts/the-c-language-is-purely-functional
09:44:29 <pumpkin> zomg heresy :)
09:44:45 <leimy> pumpkin: heresy?
09:44:52 <leimy> He's got TODO's in his code :-)
09:44:57 * Badger thinks asm is purely functional
09:45:01 <pumpkin> was taking about conal's heretical post :)
09:45:04 <leimy> oh
09:45:08 <mmorrow> conal: "When a C practitioner suddenly groks the purely functional monadic essence of their tool, the force of shock is so great that it may catapult him/her into enlightenment."
09:45:17 <mmorrow> conal: elegant statement
09:45:24 <conal> :)
09:45:55 <leimy> conal: are you a Seattlite?
09:46:01 <conal> leimy: yes, a functional language's run-time system is extremely stateful (I/O to registers etc).
09:46:15 <leimy> makes sense
09:46:24 <Saizan> conal: the monad analogy doesn't quite hold, since CPP macros can't create new C values at runtime
09:46:25 <conal> leimy: i lived in seattle for 13 years. moved to the woods in california two years ago.
09:46:26 <leimy> Some cool pics of lightning hitting the space needle last night
09:46:32 <leimy> conal: ah...
09:46:36 <conal> Saizan: yeah, you're right.
09:46:41 <pumpkin> conal: so you're 15?
09:46:42 <conal> Saizan: it's really a monoid
09:46:49 <leimy> http://www.komonews.com/news/local/45457632.html
09:47:06 <lilac> mmorrow: the wrapper in System.Posix.IO is plenty good enough for my purposes
09:47:14 <conal> pumpkin: no one said there'd be math.  :)
09:47:36 <conal> leimy: yow!
09:47:36 <lilac> quicksilver: i have 'deferIO :: IO () -> IO DeferredIO' and 'performDeferredIO :: DeferredIO -> ()' working ;-)
09:47:52 <lilac> am i supposed to be able to do that without unsafe*?
09:47:59 <leimy> conal: it was pretty impressive here yesterday :-)
09:47:59 <mmorrow> i'm constantly annoyed that CPP isn't more powerful.. i.e. it's just simple substitution rather than substituting the result of evaluating an expression
09:48:35 <conal> hm.  Firefox just garbage-collected
09:48:40 <conal> (i.e., crashed)
09:48:40 <mmorrow> , listE (repliclate 20 [|()|])
09:48:41 <lunabot>  luna: Not in scope: `repliclate'
09:48:45 <mmorrow> , listE (replicate 20 [|()|])
09:48:46 <lunabot>  ListE [ConE (),ConE (),ConE (),ConE (),ConE (),ConE (),ConE (),ConE (),Co...
09:48:53 <mmorrow> , ppDoc `fmap` listE (replicate 20 [|()|])
09:48:54 <lunabot>  [(),
09:48:54 <lunabot>   (),
09:48:54 <lunabot>   (),
09:49:00 <roconnor> I've been trying to find a way to explain/convey the difference between programming "inside a monad" and "outside a monad".
09:49:11 <pumpkin> yay, it's codolio
09:49:15 <mmorrow>  ppDoc `fmap` listE (replicate 2000 [|()|])
09:49:18 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5078#a5078
09:49:31 <roconnor> Because programming in the list monad is "non-deterministic", but, of course, haskell is deterministic.
09:49:42 <lilac> ^^ defer performing any IO computation until a pure value is forced
09:49:49 * lilac feels dirty
09:50:17 <mmorrow> lilac: why dirty?
09:50:25 <lilac> mmorrow: my pure code has side effects
09:50:32 <lilac> and i didn't use unsafe*
09:50:36 <mmorrow> so? :)
09:51:04 <conal> Saizan: i'll post the monad/monoid correction on my blog.
09:51:11 <roconnor> It's not just IO programing that is impure, but any monadic programming is typically impure.
09:51:39 <roconnor> I think is it that we are implicitly programming with Kleisli arrows when doing monadic programming.
09:52:07 <pumpkin> :o
09:52:10 <gnuvince> Is there a way to make this code less messy:                                      ((digits !! fromInteger (y `mod` radix)):acc)
09:52:12 <roconnor> anyhow, I'm still lacking the proper language to explain this difference well.
09:52:38 <conal> roconnor: in that we usually work with 'a -> m b', not just 'm b'?
09:52:47 <roconnor> @type Numeric.showIntAtBase
09:52:48 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:52:53 <roconnor> gnuvince: ^^
09:53:21 <roconnor> conal: not only work with, but think of it that way too.
09:53:37 <Twey> showIntAtBase radix (digits !!) y ""
09:54:05 <gnuvince> > showIntAtBase 2 ("0123"!!) 10 ""
09:54:07 <lambdabot>   "1010"
09:54:11 <gnuvince> nifty
09:54:24 <mmorrow> haha, void firefox_gc(void){abort();}
09:54:29 <ski> (roconnor : i agree ..)
09:55:12 <ski> roconnor : basically, we're thinking in the Kleisli category, when thinking "in the monad"
09:55:33 <ski> which is just what effectful programming is about
09:55:47 <roconnor> When I'm programming "in a monad" I'm thinking that I have state, and I'm not deterministic, but when I step back, I see that I'm doing backtracking search and composing state transformers.
09:55:51 <roconnor> @quote MonadState
09:55:52 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
09:56:00 <ski> (or at least one useful formalization of "effectful")
09:56:38 <roconnor> ski: trying to convey this in a talk is difficult.
09:57:19 <ski> roconnor : in that case, the difference is only in the frame of mind .. if haskell had syntax for monadic reflection, it would be a difference in syntax as well (i suppose this sounds trivial now when i state it)
09:58:02 <ski> the direct side-effectful syntax of typical (and not-so-typical) imperative languages is more or less a convenience, methinks
09:58:06 <roconnor> ski: particularly strange how you are working in this beautiful pure world, and it has this strange IO box.  But when you step into that box, and look back you see that you are in the real world, and that pure world isn't.  It is just a box in the real world with wires and stuff.
09:58:30 <EvilTerran> roconnor, how poetic
09:58:41 <dev31212> ok, here is what I learned
09:58:46 <dev31212> because this room is so helpful
09:59:03 <dev31212> If you try out turbinado, dont do the "git" as it says on the website...
09:59:09 <dev31212> do it like this : git clone git://github.com/alsonkemp/turbinado-website.git
09:59:36 <ski> roconnor : one could use this as a rationale for an operation that in the outside environment prints the n decimals that has been found for an internal pure computation of a computable real
09:59:48 <roconnor> I was about to suggest dev31212 put that up on the wiki, but I don't know how painful it is to get an account now.
09:59:52 <pumpkin> dev31212: might it not be better to warn the developer?
10:00:00 <dev31212> pumpkin, good idea
10:00:02 <dev31212> ill do that now
10:00:07 <pumpkin> :)
10:00:13 <lilac> conal: i can create (inside the IO monad, without using unsafe*) a pure value, which, when forced, has arbitrary side-effects. horrified?
10:00:17 <ski> roconnor : inside the pure computation, we can't depend on decimal representation .. but outside, we can set time limits and gather the decimals so far ..
10:00:52 <lilac> conal: also, i loved your 'C as a pure language' blog post :)
10:00:57 <roconnor> lilac: you can?
10:01:12 <conal> Saizan: i'm adding a blog comment quoting and responding to your not-a-monad remark.  would you rather i didn't refer to you by your real name (in addition to irc handle)?
10:01:20 <mmorrow> lilac: if that's what the situation calls for, then i see it as haskell not being expressive/whatever enough for the problem at hand, rather that a failure on your part.
10:01:28 <conal> lilac: :D
10:01:30 <SamB> lilac: how?
10:01:30 <ik> lilac: link?
10:01:46 <roconnor> lilac: lambdabot or it didn't happen. :P
10:01:56 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5078#a5078
10:02:00 <lilac> ^^ like that
10:02:15 <lament> is vim usable for haskell these days?
10:02:19 <ski> roconnor : btw, even though it's often better to avoid using effectful computations, i think effectful computations are sometimes warranted precisely because they can improve the modularity and robustness of code
10:02:29 <EvilTerran> lilac, ah, because hGetContents uses unsafeInterleaveIO internally
10:02:35 <lilac> EvilTerran: right :)
10:02:38 <magical_pony> vim's highly usable for haskell.
10:02:55 <pumpkin> > ((thrice . thrice) (+1)) 0
10:02:56 <lambdabot>   9
10:03:02 <pumpkin> > ((thrice thrice) (+1)) 0
10:03:03 <lambdabot>   27
10:03:05 <lilac> it's easy to extend it to allow the IO action to produce a string
10:03:05 <mux> I've always used vim for haskell coding
10:03:19 <lilac> but arbitrary return values are harder (perhaps impossible?)
10:03:23 <lament> does it handle indentation nicely?
10:03:23 <EvilTerran> > thrice thrice thrice (+1) 0
10:03:25 <lambdabot>   * Exception: stack overflow
10:03:34 <EvilTerran> uh
10:03:42 <Twey> emacs is even more usable for Haskell.
10:03:44 <lament> does it have something like the emacs thing where Tab cycles through possible indentations?
10:03:49 <magical_pony> i believe so.
10:03:53 <magical_pony> inb4 editor war
10:04:49 <mux> lament: vim can do this since vim 7, using the ^N key combination
10:05:18 <Twey> How do you get vim to show the type of an expression under the cursor?
10:05:42 <magical_pony> ...you look at it's type signature? :P
10:05:46 <mux> there is a vim script floating around for that
10:06:05 <roconnor> I don't get the hGetContents problem
10:06:33 <lament> Twey: i've seen that thing somewhere
10:06:49 <BONUS> roconnor: you mean why some consider it bad?
10:06:50 <conal> i just replied to Saizan's C-as-monad objection: http://conal.net/blog/posts/the-c-language-is-purely-functional
10:07:18 <mux> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
10:08:10 <roconnor> BONUS: I don't understand what property people claims it breaks.
10:08:55 <BONUS> purity. because you can have an expression whose value depends on when it's evaluated
10:09:11 <BONUS> if something is pure, it shouldn't matter if you evaluate it now or later
10:09:32 <BONUS> but when you do x <- hGetContents someHandle
10:09:48 <BONUS> when the file is read depends on when x is evaluated
10:09:54 <BONUS> even though x should be pure
10:10:00 <ski> afaiu it technically is pure .. up to `IO' being blamed for nondeterminism
10:10:18 <lilac> haha, i've got a pure value which, when forced, reads a string from the keyboard
10:10:27 <lilac> (and returns it)
10:11:27 <lilac> now all i need is an infinite list of these and i can implement unsafePerformIO
10:11:31 <mmorrow> (unsafePerformIO getLine) ?
10:11:35 <roconnor> BONUS: I'm not sure that the Haskell 98 report says that about hGetContents.  Checking now.
10:11:41 <lilac> mmorrow: no, no unsafe* used.
10:11:55 <mux> actually, there is a new page for the vim scripts there: http://projects.haskell.org/haskellmode-vim/
10:11:58 <lilac> mmorrow: just forkIO, hGetContents, hPutStr, hClose and createPipe
10:12:00 <mmorrow> lilac: what are you using
10:12:12 <mmorrow> oh, hGetContents
10:12:15 <lilac> yeah :)
10:12:22 <roconnor> BONUS: I ususally think of hGetContents as part of concurrent programming.
10:12:59 <mmorrow> lilac: err, i still don't see how you're doing it
10:12:59 <BONUS> i dont have anything against it, as long as it's used wisely
10:13:03 <roconnor> and that hGetContents is allowed to read the file whenever it feels like.
10:13:08 <lilac> mmorrow: did you see my hpaste?
10:13:11 <mmorrow> lilac: oh, no
10:13:43 <BONUS> if you have a good understanding of how your IO works, you can maintin purity throughout most of your program
10:13:53 <mmorrow> lilac: oh, well you still are in IO
10:14:10 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5078#a5079
10:14:16 <lilac> ^^ someOperation is /not/ still in IO
10:14:23 <lilac> and yet it performs IO.
10:14:28 <roconnor> ``Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is made semi-closed.
10:14:44 <roconnor> I see nothing about when this reading is done.
10:14:51 <mmorrow> i thought you mean you had a function (keybd :: String)  that read from the keybd without unsafePerformIO
10:14:57 <mmorrow> *meant
10:15:05 <lilac> mmorrow: not a function. it's a one-hit thing, sadly
10:15:10 <lilac> mmorrow: but i have a plan...
10:15:15 <mmorrow> lilac: just have it take a ()
10:15:22 <mmorrow> :: () -> String
10:16:11 <lilac> mmorrow: how would i implement that?
10:16:17 <mmorrow> and `seq` or direct cps can sequence what's forced
10:16:33 <ski> (mmorrow : why would that work, barring `unsafePerformIO' ?)
10:16:48 <mmorrow> ski: because you use unsafePerformIO of course
10:16:51 <mmorrow> :)
10:17:29 <lilac> mmorrow: i can only perform IO once for each time 'interleaveIO' is called
10:17:41 <lilac> mmorrow: however, it can call itself, so perhaps...
10:17:59 <mmorrow> oh, i was talking about if you were to just use unsafePerformIO
10:18:08 <ski> maybe one could do something with an oracle tree ..
10:18:14 <mmorrow> withLine k = let !x = unsafePerformIO getLine in k x
10:18:48 <mmorrow> IO doesn't have to be a monad..
10:19:01 <ski> ?
10:19:32 <mmorrow> ski: e.g. you can use cps
10:19:55 <lilac> mmorrow: but the point was to prove that lazy IO violates referential transparency, and not just to the extent of deferring file reads
10:20:06 <lilac> mmorrow: that is, it allows you to defer /all/ IO operations
10:20:15 <lilac> i think that's kinda scary
10:20:41 <gio123> hi
10:20:46 <mmorrow> withIO io k = let !x = unsafePerformIO io in k x
10:21:17 <mmorrow> withIO getLine $ \line -> withIO (putStrLn line) $ \() -> 42
10:21:49 <ski> (mmorrow : oh, you meant "I/O" as opposed to `IO')
10:21:59 <mmorrow> ski: ah, heh, yes
10:22:18 <kau> hello!
10:22:29 <roconnor> lazy IO doesn't violate referential transparency.  I thought we settled that.
10:22:51 <mmorrow> roconnor: what's the definition of lazy IO ?
10:23:03 <mmorrow> (not a rhetorical question)
10:23:05 <roconnor> hGetContents
10:23:10 <mmorrow> ah
10:23:16 <BONUS> i'd say any IO action that uses unsafeInterleavedIO
10:23:41 <BONUS> it is my understanding that it doesn't violate referential transparency, but it does violate purity in the sense that it matters when an expression is evaluated
10:24:15 <ski> only if we expect to be able to easily keep track / reason about, when effects in `IO' happens
10:24:28 <ski> (that's not a small "only", granted)
10:25:23 <mmorrow> withIO getLine $ \line -> withIO (putStrLn line) $ \() -> 42
10:25:24 <mmorrow> getLine >>= \line -> putStrLn line >>= \() -> return 42
10:25:39 <roconnor> IMHO, unsafeInterleavedIO should be thought of concurrent programming and treated as such.  ie, your code shouldn't depend on when terms are evaluated. and should work if hGetContents is strict or anywhere in between.
10:25:40 <mmorrow> (just thought that was worth explicitly pointing out)
10:25:43 <roconnor> but that is just me.
10:25:46 <roconnor> :)
10:26:33 <Saizan> that's not quite accurate either
10:27:04 <kau> I've came across something in the libraries documentation: about ArrowChoice, it says "This class underlies the if and case constructs in arrow notation." How does this come from??
10:27:24 <copumpkin> kau: have you played with arrow notation?
10:27:29 <kau> no
10:27:30 <mmorrow> kau: the compiler explicitly mapping that syntax to that class
10:27:32 <Saizan> it doesn't ever perform the effects on its own if you don't force the result, that's a very peculiar scheduler :)
10:27:33 <ski> kau : the arrow notation is desugared into operations from the various basic arrow classes
10:27:40 <kau> OK
10:27:40 <mmorrow> kau: just like "do" notation to monads
10:27:56 <kau> i wonder how to make an "if" in pointless notation
10:28:01 <ski> Saizan : true
10:28:28 <kau> like this: f a = if a then XXX else YYY but without the "a"
10:28:33 <mmorrow> if' a b c = if a b c
10:28:34 <ski> @let if_ f t b = if b then t else f
10:28:35 <lambdabot>  Defined.
10:28:40 <gio123> does somebody use beamer latex?
10:29:10 <magical_pony> ya
10:29:15 <kau> i thought ArrowChoice could help me
10:29:24 <ski> kau : for arrow notation you have to start with `proc <pat> -> <cmd>' iirc
10:29:33 <copumpkin> kau: without the a?
10:29:46 <copumpkin> kau: you mean you want a function that behaves like the if expression?
10:29:58 <ski> kau : maybe you want (angelic ?) nondeterminism ?
10:30:28 <kau> let me find back my exemple
10:31:40 <kau> here it is. I'm still working on the "cosmicomics" trick
10:32:04 <kau> i found that one-liner: uncurry (==) $ sort *** sort $ splitAt =<< (`div` 2) . length $ "cosmiccomics"
10:32:17 <copumpkin> lol
10:32:24 <copumpkin> that's pretty golfed
10:32:36 <kau> :)
10:32:46 <copumpkin> so want to check for the language ww? :P
10:33:05 <kau> just to get me use to the arrow etc...
10:33:36 <copumpkin> well, I mean, you want to check that the passed in is two identical strings placed adjacent to one another?
10:33:53 <copumpkin> I don't think ArrowChoice will help you there
10:34:36 <kau> yes, the goal is to find auto-anagrams, the rigth part is an anagram of the left part
10:34:37 <copumpkin> if you want to golf it more though, you can do join (***) sort, even though that's longer
10:34:48 <copumpkin> oh, I see
10:35:38 <kau> how would you write it?
10:35:42 <conal> sclv: i just replied to your comment: http://conal.net/blog/posts/the-c-language-is-purely-functional/#comment-21113
10:35:54 <copumpkin> something like that :)
10:36:22 <copumpkin> bbl :)
10:36:25 <kau> OK, but it doesn't work for string with odd lentgh
10:38:27 <kau> that's why i wanted an "if" pointfree
10:39:13 <mux> :wq
10:39:17 <mux> wwops, sorry
10:40:09 <persica> Heh, I type ":w" all the time in random windows.
10:40:54 <vininim> I keep trying to move the cursos in irssi with C-f and C-b.
10:41:00 <vininim> *cursor
10:41:19 <msch> hi, can someone elighten me what "Occurs check: cannot construct the infinite type" is all about? (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5080#a5080)
10:42:11 <ski> (msch : just guessing, you're confusing a list with a list element .. maybe by using `(:)' in place of `(++)' or vice versa)
10:42:16 * ski looks at paste
10:42:58 <ski> msch : it might help if you provide the errant code in question too .. e.g. annotate that paste with it
10:43:48 <msch> ski: I just did. Thanks for your help :) The code is based on chapter 17 of Haskell: The craft of functional programming
10:45:17 * ski remembers reading that chapter for the first time :)
10:46:06 <kau> where can i find infos about the if desugarisation??
10:46:14 <msch> it doesn't seem that hard at first, but then I got that error and I've been stuck with it since Tuesday
10:46:39 <lilac> > (\s->any(==sort s).map(sort.join (++))$tails s) "cosmiccomics"
10:46:41 <lambdabot>   True
10:46:43 <msch> http://www.complang.tuwien.ac.at/knoop/lehre/ss2009/ffp185210/ffp_lu06_090507.pdf That's the assignment. But please don't complete it for me, just help me solve my occurs check problem
10:46:43 <ski> msch : i think i see the problem
10:46:44 <lilac> kau ^^ that's how i'd do it
10:47:00 <msch> ski: neither do i :) But did you run the code?
10:47:11 * Twey protests for significant whitespace around operators
10:47:19 <ski> msch : i said i think i *do* see the problem :)
10:47:25 <kau> lilac: can't understand anything ^^
10:47:26 * mux seconds Twey 
10:47:29 <msch> ski: oh... sorry....
10:47:39 <ski> (and no, i'm just type-checking the code in my head)
10:47:46 <ski> msch : generally, in such cases, it helps to put type signatures on the definitions
10:47:49 <ski> anyway
10:47:52 <lilac> kau: it's an auto-anagram if any suffix, when doubled, is an anagram of the original
10:47:59 <ski>   c_aexpr = c_term `alt` (c_aexpr >*> c_aop >*> c_term)
10:47:59 <mmorrow> if TH is on, you need a space after '$'
10:47:59 <lilac> kau: so i test for that
10:48:01 <ski>   c_term = c_factor `alt` (c_term >*> c_mop >*> c_factor)
10:48:15 <ski> msch : you need to use `build' on the left argument to `alt' there
10:48:57 <msch> ski: that's it? could you maybe explain why?
10:49:13 <TomMD> I need a simple XML library with which to generate KML files - any suggestions?
10:49:14 <Fred320> @src foldr
10:49:14 <lambdabot> foldr f z []     = z
10:49:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:49:21 <TomMD> No, foldr won't help me.
10:49:23 <TomMD> ;-)
10:49:29 <Fred320> lol
10:49:29 <ski> msch : assume that `c_aexpr >*> c_aop >*> c_term' will parse values of form `(expression,(operator,term))'
10:49:43 <kau> lilac: "join" and "any" are strangers for me
10:49:53 <ski> msch : then the left argument to `alt', i.e. `c_term' will parse expressions of form `term'
10:50:08 <ski> msch : those two kinds of values are not compatible/mixable
10:50:11 <lilac> > (\s->any(on(==)sort$s).map(join(++))$tails s) "cosmiccomics"
10:50:13 <lambdabot>   True
10:50:18 <lilac> yay, shorter
10:50:31 <ski> msch : `alt' takes to parsers that returnes parsed values *of*the*same*type*
10:50:44 <Cale> kau: any is a handy function. any p xs checks if any element of xs is able to make the condition p true
10:50:51 <Cale> > any even [1,3,5,9]
10:50:53 <lambdabot>   False
10:50:56 <Cale> > any even [1,3,5,8,9]
10:50:58 <lambdabot>   True
10:51:00 <ski> msch : what you need to do is probably to build a proper Algebraic Data Type for C Expressions
10:51:06 <lilac> kau: join f = (\x -> f x x)
10:51:13 <Fred320> @pf 1
10:51:14 <lambdabot> Maybe you meant: bf pl
10:51:15 <lilac> kau: it's more general than that, but that's what i'm using
10:51:17 <MyCatVerbs> ski: don't we already have one in Language.C?
10:51:18 <Fred320> @pl 1
10:51:18 <lambdabot> 1
10:51:37 <msch> ski: Yeah, now when I look at alt's signature it's obvious :) Thank you very much!
10:51:37 <Fred320> @pl \x rest = map (x:) rest ++ rest
10:51:37 <lilac> kau: so join (++) = \xs -> xs ++ xs
10:51:38 <lambdabot> (line 1, column 9):
10:51:38 <lambdabot> unexpected "="
10:51:38 <lambdabot> expecting pattern or "->"
10:51:42 <Cale> 1 has no lambdas in it, so @pl is unlikely to do anything with it ;)
10:51:53 <lilac> @unpl 1
10:51:53 <lambdabot> 1
10:51:55 <lilac> :(
10:52:00 <Cale> @pl x rest -> map (x:) rest ++ rest
10:52:00 <lambdabot> (line 1, column 8):
10:52:00 <lambdabot> unexpected ">" or "-"
10:52:00 <lambdabot> expecting variable, "(", operator or end of input
10:52:02 <Cale> @pl \x rest -> map (x:) rest ++ rest
10:52:03 <lambdabot> join . ((++) .) . map . (:)
10:52:06 <Fred320> @pl \x rest -> map (x:) rest ++ rest
10:52:06 <lambdabot> join . ((++) .) . map . (:)
10:52:07 <ski> MyCatVerbs : msch is doing this as excercise with parsing monads (i presume)
10:52:08 <Fred320> ah
10:52:09 <monadic_kid> does it conform to C99?
10:52:15 <lilac> @pl (\s->any(on(==)sort$s).map(join(++))$tails s)
10:52:15 <lambdabot> ap ((. map (join (++))) . any . on (==) sort) tails
10:52:16 <TomMD> @pl map (\x -> x / 2)
10:52:17 <lambdabot> map (/ 2)
10:52:20 <monadic_kid> Langauge.C i mean
10:52:28 <ski> msch : btw, you use your `Token' type in an odd way
10:52:41 <Fred320> that pl term is completely unreadable :)
10:52:54 <lilac> wow, @pl made it shorter!
10:52:58 <TomMD> It is called pointless for a reason.
10:53:02 <Fred320> LOL
10:53:06 <lilac> > ap((.map(join(++))).any.on(==)sort)tails "cosmiccomics"
10:53:07 <lambdabot>   True
10:53:18 <ski> msch : usually one have parsers output some kind of Abstract Syntax Tree (represented as a Haskell Algebraic Data Type, here)
10:53:23 <msch> ski: what exactly do you mean? Token is provided by the lecturer so I'm not free to change it anyways.
10:53:35 <kau> lilac: and what is "on"?
10:53:41 <ski> msch : these parsers then either consume some kind of characters .. or they *consume* tokens
10:54:03 <ski> msch : your parsers that (attempt to) *produce* tokens when parsing
10:54:08 <lilac> kau: "on (==) sort" would usually be written as "(==) `on` sort"
10:54:23 <ski> msch : i suspect your lecturer meant you to *consume* tokens when parsing
10:54:26 <lilac> kau: (*) `on` f = \x y -> f x * f y
10:54:48 <monadic_kid> You know what would be cool is if we could start with referentially transparent subset of C, then add in a simple dependant type system with linear types, support for multi-stagging then you can replace all the stupidness of C++
10:54:50 <ski> (msch : and maybe have a preliminary lexing stage that translates a string to a list of tokens, to then be fed to the parsing proper)
10:55:01 <ski> s/that/there/
10:55:26 <Fred320> @src join
10:55:27 <lambdabot> join x =  x >>= id
10:55:32 <lilac> > (.map(join(++))).any.on(==)sort`ap`tails "moresomorose"
10:55:33 <lambdabot>       precedence parsing error
10:55:33 <lambdabot>          cannot mix `(.)' [infixr 9] and `ap' ...
10:56:26 <ski> msch : anyway, the key to solve the particular problem you're having is, i think, to first define an AST ADT, and then to use `build' on the parsers passed to `alt', to make sure the types match
10:56:41 <Cale> That expression has been overgolfed I think.
10:56:59 <monadic_kid> In the SAC programming language, the SAC team did a good job defining a grammar which represnets a referentially transparent subset of C. That might be a good place to start
10:57:22 <inimino> lilac: why are you using tails instead of cutting it in half first?
10:57:34 <kau> lilac: yes why??
10:58:37 <kau> inimino: how would you cut it in half?
10:59:05 <Cale> monadic_kid: It seems like an okay idea except that... wouldn't the result be a completely different programming language? It seems a bit funny to start with C at all.
10:59:08 <lilac> inimino: because it's shorter that way :)
10:59:14 <pejo> monadic_kid, are you using "simple dependent types" in the meaning that there are few typing rules for the language?
10:59:36 <lilac> inimino, kau: we were golfing, right?
10:59:46 <ski> msch : anyway, good luck (i'm off)
10:59:54 <msch> ski: well i was thinking i could follow you till that last message :) As far as I understand it this parser throws away the actual information (which Numeral, Identifier) and only outputs a list of Tokens. So I was thinking it'd be easy to just `build` the tokens "inline" and later pattern-match the resulting tupel to get a list. Are you telling me I should use build only after I have parsed the whole input?
11:00:08 <monadic_kid> Cale: I'm talking abut in the context of C++ replacement
11:00:08 <msch> ski: ok, thank you for your help! Have a nice remaining day!
11:00:09 <kau> lilac: what does golfing means (sorry i'm french)
11:00:46 <inimino> lilac: I guess I missed the beginning of that ;-)
11:01:04 <lilac> kau: implementing something in a minimal number of (key)strokes
11:01:11 <kau> OK
11:01:24 <inimino> kau: like the game of golf, the goal is to get the lowest score
11:01:52 <mux> kau: you should come in #haskell.fr - it's dramatically empty :-)
11:02:36 <Tristan1> Hello everyone
11:02:52 <kau> inimino: OK!
11:03:15 <Tristan1> I'd like to know if there is any implementation for Hidden Markov Models in Haskell ?
11:03:30 <kau> mux: yes this is sad haskell doesn't enthusiast french people
11:03:40 <mux> Tristan1: yes, I've seen a hmm module on hackage
11:03:48 <mux> kau: *nods*
11:04:04 <kau> i feel alone too!
11:04:04 <Tristan1> especially: is there allready a framework for human movement recognition ?
11:04:07 <monadic_kid> pejo: simple in the sense of to not the extent of something like Epigram and simple in the sense of syntatically.
11:04:23 <mux> Tristan1: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmm
11:04:55 <mux> Tristan1: I have no idea what it's worth though, I hardly know what an HMM is
11:05:00 <kau> mux: to change that, i'm into tutorials translations ;)
11:05:16 <mux> kau: cool, good luck with that!
11:11:23 <kau> is (->) an operator? ghci bugs me on :t (->)
11:11:56 <monochrom> It is not an operator.
11:12:11 <kau> what is it?
11:12:16 <mux> it would be a type operator
11:12:20 <mux> but it's necessarily builtin
11:12:31 <monochrom> It is used in types but not values.
11:12:40 <kau> mux: thats what i wanted to hear ;)
11:13:10 <mux> monochrom: because it's builtin and we have other syntactic forms (hopefully!) to introduce function values
11:13:32 <monochrom> > let 1->2 = 3 in 1->2
11:13:34 <lambdabot>   <no location info>: parse error on input `->'
11:13:41 <monochrom> Amazing.
11:14:32 <monochrom> I see, -> is a reserved word.
11:14:35 <mux> (->) is usually considered a type operator when defining calculus, and GHC also allows to use it as such in class instances
11:14:49 <kau> but (->) is an instance of Arrow (->)!
11:14:55 * mux nods
11:15:15 <kau> arent class instances tyoes? ;)
11:15:16 <MyCatVerbs> You can't ask :t (->) because (->) isn't a funciton.
11:15:20 <MyCatVerbs> *function, gah.
11:15:21 <mux> an arrow is the generalisation of the idea of a type that goes from some type to another
11:15:42 <MyCatVerbs> You can ask :k (->), because (->) is a type constructor.
11:15:43 <mux> kau: not necessarily, class instances can have higher kinds
11:15:45 <MyCatVerbs> @kind (->)
11:15:47 <lambdabot> ?? -> ? -> *
11:15:54 <mux> like * -> * which makes them not types but type operators
11:16:05 <kau> yeah, can't understand this.
11:16:24 <mux> this is very easy, kinds are like the types of types
11:16:24 <monochrom> Monad is an example. You say "Monad Maybe" not "Monad (Maybe a)".
11:16:31 <kau> OK
11:16:47 <mux> and monotype (ie Int, Char, [Bool]) has kind *
11:16:52 <mux> s/and/any/
11:17:02 <mux> Maybe has kind * -> *
11:17:13 <mux> because it's as if it takes another type as a parameter to produce a type
11:17:18 <mux> Maybe Int has kind *
11:17:26 <mux> Arrow has kind * -> * -> *, etc
11:17:26 <kau> the language of kinds is a real language (ie i can code with it)? or only documentary?
11:17:29 <gio123> http://pastebin.com/d4434692a
11:18:45 <mux> kau: it all boils down to what you call "code", but no you cannot write algorithms with it
11:19:22 <kau> mux: what the use of kinds
11:19:24 <kau> ?
11:19:42 <mux> kau: they are only useful to detect malformed type expressions
11:19:46 <mux> such as Int Int
11:20:13 <kau> so it's a language for compilers?
11:20:18 <mux> GHC has extended kinds too, (with ? characters), but I have no idea what they are used for
11:21:15 <mux> kau: it's a type system for type expressions, and thus permits to statically check type expressions
11:21:30 <mux> just as the type system permits to check expressions statically
11:21:38 <monochrom> Three cases: unboxed type, boxed type, don't-care
11:22:23 <monochrom> The kind of -> probably illustrates all three cases.
11:22:29 <kau> so there are types of types, are there types of types of types? lol
11:22:38 <mux> no :)
11:22:43 <monadic_kid> checkout the kernal grammar (firgure 1), it's a functional subset of C and it's quite small :) http://www.sac-home.org/publications/sac-overview-jfp-03.pdf
11:23:37 <mux> kau: types for types become useful when your types get more expressive, if I'm not mistaken System F has kinds
11:23:59 <mux> it's packaged with parametric polymorphism :-P
11:24:01 <kau> F#?
11:24:13 <mux> System F is the second order lambda calculus
11:24:33 <monadic_kid> lol
11:24:48 <monochrom> Coq supports countably many levels of "type of types".
11:24:55 <mux> heh
11:25:14 <mux> the whole Set Set1 thing?
11:25:34 * mux needs to improve his dependent typing skills
11:26:01 <kau> monochrom: what the use of these levels? i have to settle and thing about that...
11:27:52 <mathijs_> anyone tried to get hs-plugins installed recently?
11:28:11 <mathijs_> hackage says it won't build on ghc8.10
11:30:14 <TomMD> @hackage hs-plugins
11:30:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hs-plugins
11:31:20 <mathijs_> try without the hs- TomMD
11:31:30 <mathijs_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
11:31:32 <TomMD> mathijs: I can install it, but is there a simple test I can run?
11:31:42 <monochrom> The "set of all sets" paradox can be resolved in three ways. First is ignore it. Second is disallow it. Third is stratification, i.e., countably many levels, so "the set of all level-0 sets" is a level-1 set, in general "the set of all level-n set" is a level-(n+1) set.
11:31:44 <TomMD> GHC 6.10.3 btw.
11:32:12 <mathijs_> I'm not even thinking about running it
11:32:14 <mathijs_> yet
11:32:16 <mathijs_> tbh
11:32:34 <c_wraith> monochrom: which of those categories does constructionism fit into?
11:32:42 <mathijs_> It seems to depend on cabal 1.4.0
11:32:50 <mathijs_> erm 1.4.*
11:32:58 <monochrom> I think it depends on whose constructionism.
11:33:08 <mathijs_> ??
11:33:22 <monochrom> Coq is one constructionism. It uses stratification.
11:33:51 <monochrom> s/whose/who's/
11:34:14 <mathijs_> while ghc doesn't want cabal 1.4
11:34:35 <c_wraith> Hmm..  What's the one I was looking into?  Perceptualism, maybe?
11:34:57 <c_wraith> No, that's not the name of it.
11:35:03 <c_wraith> And I don't seem to have the paper anymore.  grr.
11:36:35 <mathijs_> hmm i can actually get the old cabal version that seems to work
11:39:38 <bos31337> i like it when people report easy-to-fix bugs.
11:40:03 <Cale> The disallowing and stratification approaches are actually quite closely related. Ignoring the problem is a strange approach, since being able to construct a contradiction is usually troublesome. (Though in Haskell, for instance, we're more concerned with which proofs are available for a type, and not whether a proof exists or not.)
11:41:07 <Cale> The sense in which disallowing a set of all sets is related to the stratification approach is that it's exactly what you get when you take the fragment of the stratified set theory which only discusses level 0 sets.
11:41:42 <roconnor> there are two types of stratification.  You allow subtyping or not allow subtyping in universes.
11:42:03 <kau> monochrom: the "set of all sets" paradox is from a famous mathematician, isn't it? I can't remember who?
11:42:14 <monochrom> Russell.
11:42:15 <Cale> Russell
11:42:16 <roconnor> AFAIK Agda has no subtyping, while Coq des.
11:42:19 <kau> yeah!
11:42:28 <roconnor> me!
11:42:35 <Cale> It's actually what you get when you allow a set of all sets, together with comprehension.
11:42:36 <monochrom> But he has so many paradoxes that "Russell Paradox" is ambiguous. Only second to Zeno.
11:43:16 <Cale> If you throw away comprehension, you could also avoid the problem, but that tends to completely destroy the sense that you have a set theory at all.
11:43:21 <roconnor> however type in type isn't really the same as set in set because there is no comprehension axiom.
11:43:27 <roconnor> It is more like Girard's paradox
11:43:39 <roconnor> or rather is Girard's paradox
11:44:20 <kau> what is Zeno?
11:44:57 <kau> ha, Zénon d'Élée?
11:44:58 <roconnor> And Girard's paradox is really the Burali-Forti paradox, as I understand it.
11:45:12 <monochrom> My Paradox.
11:46:02 <Cale> The set of all ordinal numbers one?
11:46:28 <roconnor> the ordinal of all ordinals, ya.
11:46:37 <monochrom> My Paradox: Is math contrived or inflicted?
11:47:06 <Cale> contrived ;)
11:48:23 <monochrom> The paradox is that most students find it both. Someone contrived math so as to inflict it on students. "Why can't I just have sin(x+y)=sin(x)+sin(y)? It's artificially made hard."
11:48:27 <roconnor> Russell's paradox was not the first paradox in naive set theory.  But, for some reason, it was the most damning.
11:48:42 <Cale> monochrom: hehehe
11:49:16 <Cale> roconnor: Hmm... what came before it historically?
11:49:29 <Cale> It was something found in Frege's system, yeah?
11:50:43 <roconnor> Cale: I understand that the problems of the largest ordinal and largest cardinal predate Russell's paradox
11:50:46 <roconnor> but I'm not sure.
11:51:00 <kau> can i have something like hoogle in ghci?
11:51:01 <Cale> Frege's system is the first attempt at actually formalising set theory that I know of, and Russell was the one who pointed out the problem with unrestricted set comprehension in it.
11:51:56 <Cale> kau: not really, though there's :browse
11:52:38 <kau> Cale: i have no internet at work but i would like to install something like hoogle...
11:52:42 <rfmge> kau: yup, there's a command line version of hoogle, in my .ghci file i have ':def hoogle \x -> return $ ":!hoogle --info --color " ++ x'
11:52:42 <roconnor> I feel that the paradox of largest ordinal and Russell's paradox are quite different, even if set theory solve the both problems in one fell swoop.
11:52:52 <Cale> rfmge: Oh, that's interesting :)
11:53:22 <byorgey> rfmge: neat =)
11:54:14 <Cale> roconnor: Yes, the way in which the contradiction arrives is quite different.
11:55:14 <copumpki> thoughtpolice: around?
11:56:57 <rfmge> kau: i also have the same thing but for 'pointfree', to mangle all my code into an unreadable mess
11:57:19 <Cale> hehe
11:58:46 <wy> hello
11:59:14 <mux> wow, parsec 3 has ParsecT and can handle strict & lazy bytestrings!
11:59:18 <EvilTerran> wy hello there :)
11:59:19 <mux> why did noone tell me? ;-)
11:59:21 * monochrom rewrites The Lord of The Rings. The evil Sauron invented (not discovered!) the Ring of All Rings but he sucked at logic. So did pretty much everyone else, that's why he was unchallenged for a long time. After 1000 pages of wars and hobbit adventures, Frodo arrived at Mount Doom and asked an innocent but logical question. Then all evilness disappeared in a puff of logic.
11:59:27 <wy> Hi EvilTerran
11:59:38 <wy> I finally got to return to haskell :)
12:00:01 <wy> after a year's "torture" by scheme .. hehe
12:00:34 <wy> It's great that the knowledge is coming back very quickly.
12:00:47 <Fred320> foldr (\x rest -> map (x:) rest ++ rest) [[]] "ABCDE"
12:00:51 <wy> Just have one question by now. Is newtype definition still useful?
12:00:54 <Fred320> > foldr (\x rest -> map (x:) rest ++ rest) [[]] "ABCDE"
12:00:55 <lambdabot>   ["ABCDE","ABCD","ABCE","ABC","ABDE","ABD","ABE","AB","ACDE","ACD","ACE","AC...
12:01:01 <Fred320> > foldr (\x rest -> map (x:) rest ++ rest) [[]] "ABCD"
12:01:03 <lambdabot>   ["ABCD","ABC","ABD","AB","ACD","AC","AD","A","BCD","BC","BD","B","CD","C","...
12:01:07 <Fred320> > foldr (\x rest -> map (x:) rest ++ rest) [[]] "ABC"
12:01:08 <lambdabot>   ["ABC","AB","AC","A","BC","B","C",""]
12:01:11 <tetha> monochrom: just make sure those 1000 pages are like 900 pages of walking around, 90 pages of preparing for battle, 9 pages of walking into the battle and a page of battle.
12:01:15 <monadic_kid> wy; of-course, why would that change?
12:01:16 <monochrom> mux: Parsec 3 was announced in the mailing lists a hundred years ago.
12:01:28 <copumpki> many moons ago
12:01:31 <wy> I just though we may not still need it?
12:01:48 <wy> The manual says that the only purpose of newtype is to reduce the overhead
12:02:23 <monochrom> newtype is still useful. It still reduces overhead.
12:02:36 <wy> So I think why don't we just translate every "data T1 = T1 T2" into "newtype T1 = T1 T2" ?
12:02:56 <roconnor> data is more lazy than newtype
12:02:57 <wjt> as with many things in Haskell, the answer is "bottoms".
12:03:06 <Fred320> @src reverse
12:03:07 <lambdabot> reverse = foldl (flip (:)) []
12:03:08 <Berengal> There's subtle semantic differences between data and newtype
12:03:11 <monochrom> I sometimes enjoy the extra bottom. I mean T1 _|_
12:03:27 <wy> monochrom: really?
12:03:32 <roconnor> but it is certainly true that 95% of the type that data could be newtype, it should be newtype.
12:03:40 <monochrom> Perhaps I am perverse.
12:03:46 <roconnor> s/type/time/
12:03:49 <wy> lol
12:04:00 <wy> I understand now. Thanks
12:04:01 <Fred320> @hoogle [t] -> [[t]]
12:04:02 <lambdabot> Data.List inits :: [a] -> [[a]]
12:04:02 <lambdabot> Data.List tails :: [a] -> [[a]]
12:04:02 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:04:25 * roconnor kinda wishes that newtype would give us unlifted tuples.
12:04:31 <wy> monochrom: maybe it will be instructive if you give an example
12:04:56 <wy> roconnor: Can't that be done with strictness analysis?
12:05:01 <Berengal> roconnor: As in, only one constructor but several fields?
12:05:09 <roconnor> Berengal: ya
12:05:17 <Berengal> Yeah, I could see how that'd be useful
12:05:25 <monochrom> I don't know how to give an example of why I enjoy something.
12:05:49 <roconnor> wy: It's true that strict fields in data types comes pretty close to what I want.
12:05:54 <wy> monochrom: You could try. I'm a weird person too ;)
12:07:04 <thoughtpolice> copumpki: yo
12:07:16 <copumpki> thoughtpolice: Igloo is racing us to the gold!
12:07:20 <copumpki> ;)
12:08:22 <Berengal> @type f x = f x
12:08:24 <lambdabot> parse error on input `='
12:08:31 <Berengal> @type let f x = f x in f
12:08:33 <lambdabot> forall t t1. t -> t1
12:08:58 <copumpki> that's a pretty exciting function
12:09:04 <monochrom> OK, here is an example. When I see T1 _|_, I feel peace and comfort.
12:09:16 <Berengal> copumpki: yeah, safe cast ;)
12:09:20 <copumpki> lol
12:09:31 <copumpki> as safe as the fix id "cast"
12:10:40 <monochrom> @type fix id
12:10:42 <lambdabot> forall a. a
12:10:49 <copumpki> :(
12:11:30 <monochrom> @type let x=x in x  {- same thing -}
12:11:32 <lambdabot> forall t. t
12:11:36 <copumpki> yup
12:11:38 <Berengal> @type let f x = f x in fix f
12:11:40 <lambdabot> forall a. a
12:12:11 <copumpki> :t let f x = (fix id) x
12:12:12 <lambdabot> <no location info>: not an expression: `let f x = (fix id) x'
12:12:16 <copumpki> :t let f x = (fix id) x in f
12:12:18 <lambdabot> forall t t1. t -> t1
12:13:11 <Berengal> @type forever
12:13:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:13:25 <Berengal> I thought forever was m a -> m b ...
12:13:41 <EvilTerran> ?hoogle exitWith
12:13:42 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
12:13:49 <wy> monochrom: I have some problem making an example about the extra indirection
12:14:00 <EvilTerran> Berengal, ^ that might've been the non-returning monadic function you were thinking of
12:14:05 <roconnor> ah, the eternal, "what is the type of forever" question.
12:14:06 <wy> my code looks like newtype Natural = Natural Integer
12:14:16 <wy> kk1 (Natural x) = 1
12:14:38 <wy> kk1 bot succeed with 1 instead of diverge
12:14:39 <Berengal> EvilTerran: No, I'm pretty sure it was forever. exitWith might be non-returning, but it's halting
12:15:01 <Berengal> EvilTerran: Besides, exitWith is in IO
12:15:13 <wy> gosh ... I see the problem...
12:15:26 <Berengal> ghci says: forever :: (Monad m) => m a -> m b
12:15:28 <roconnor> > forever (Left "done")
12:15:29 <lambdabot>   Left "done"
12:15:41 <monochrom> data Int = I# Int#  is not supposed to be optimized further. Then again that's just useful for compiler writers.
12:15:43 <EvilTerran> Berengal, true; i just figured they both produce monadic actions that don't have a result value
12:15:54 <roconnor> I think the type of forever may have changed at some point in time.
12:16:11 <EvilTerran> ...that's vaguely ironic
12:16:11 <Berengal> roconnor: Yeah, I think it was m () in 6.8 or something
12:16:26 <roconnor> > forever []
12:16:28 <lambdabot>   []
12:16:32 <roconnor> > forever Nothing
12:16:34 <lambdabot>   Nothing
12:16:47 <Fred320> @hoogle [t] -> [(t, t)]
12:16:47 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
12:16:47 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:16:47 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:17:02 <vininim> > forever error "error"
12:17:18 <lambdabot>   thread killed
12:17:31 <vininim> k
12:17:42 <roconnor> > forever (error "error")
12:17:43 <lambdabot>       No instance for (Show (m ()))
12:17:43 <lambdabot>        arising from a use of `show' at <i...
12:18:03 <roconnor> @type (forever error)
12:18:05 <lambdabot> [Char] -> ()
12:18:19 <roconnor> reader monad?
12:18:23 <dmwit> yes
12:18:44 <roconnor> this is the problem with too many instances.  type errors stop occuring. :)
12:19:06 <dmwit> Just wait until you take out the occurs check. ;-)
12:19:06 <Berengal> roconnor: Nah, it's always reader when you're confused
12:19:11 <roconnor> > foever (error "error") :: Identity ()
12:19:12 <leimy> :t forever
12:19:13 <lambdabot>   Not in scope: `foever'
12:19:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:19:19 <roconnor> > forever (error "error") :: Identity ()
12:19:21 <lambdabot>       No instance for (Show (Identity ()))
12:19:21 <lambdabot>        arising from a use of `show...
12:19:28 <roconnor> oh really?
12:19:32 <wy> lunch time. see you guys
12:19:34 <roconnor> > forever (error "error") :: Maybe ()
12:19:36 <lambdabot>   * Exception: error
12:19:52 <roconnor> > runIdentity $ forever (error "error")
12:19:53 <vininim> strange
12:20:08 <lambdabot>   thread killed
12:20:20 <roconnor> hmm
12:20:25 <roconnor> I guess Identity is too lazy
12:20:27 <EvilTerran> > flip runState (10,[]) $ runErrorT $ forever (do (x,xs) <- get; if x > 0 then put (x-1,x:xs) else mzero) :: (Either String (), (Int,[Int]))
12:20:29 <lambdabot>   (Left "",(0,[1,2,3,4,5,6,7,8,9,10]))
12:20:52 <dmwit> ?src Identity
12:20:53 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
12:21:09 <roconnor> ?src Identity (>>)
12:21:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:21:15 <EvilTerran> > fix Identity
12:21:16 <roconnor> ?src (>>) Identity
12:21:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:21:17 <lambdabot>       Occurs check: cannot construct the infinite type: a = Identity a
12:21:17 <lambdabot>       ...
12:21:58 <dmwit> (>>) = flip const
12:22:10 <dmwit> So, yeah, too lazy.
12:22:49 <dmwit> > foldl1' (flip const) (repeat (error "error"))
12:22:51 <lambdabot>   * Exception: error
12:23:00 <EvilTerran> i guess the problem is that the pattern (Identity x) will always match successfully
12:23:03 <dmwit> > foldl1 (flip const) (repeat (error "error"))
12:23:16 <dmwit> EvilTerran: Yep, that's a newtype for you.
12:23:22 <roconnor> the problem is that flip const is lazy in it's first argument
12:23:25 <roconnor> really really lazy
12:23:41 <EvilTerran> > case undefined of Identity _ -> "sooo laaazzzyyy..."
12:24:04 <dmwit> ?botsnack?
12:24:15 <roconnor> , let (Identity _) = undefined in "sooo laaazzzyyy..."
12:24:16 <ray> :)
12:24:16 <EvilTerran> dmwit, dammit, you broke the bot
12:24:16 <lunabot>  luna: Not in scope: data constructor `Identity'
12:24:32 <EvilTerran> roconnor, let bindings are non-strict anyway
12:24:35 <roconnor> :)
12:24:47 <EvilTerran> , let Just x = undefined in ()
12:24:49 <lunabot>  ()
12:24:56 <roconnor> yep
12:25:14 <roconnor> >,  case undefined of  _ -> "sooo laaazzzyyy..."
12:25:18 <roconnor> oops
12:25:21 <roconnor> ,  case undefined of  _ -> "sooo laaazzzyyy..."
12:25:22 <lunabot>  "sooo laaazzzyyy..."
12:25:51 <jonafan> i like haskell
12:25:54 <ray> is !_ possible?
12:26:21 <ziman> > case 3 of !_ -> "foo"
12:26:39 <ziman> , case 3 of !_ -> "foo"
12:26:40 <lunabot>  "foo"
12:26:52 <ray> i guess there's no reason for it not to be, but it looks so ugly
12:27:51 <copumpki> thoughtpolice: what if Igloo beats us????
12:29:17 <Fred320> @hoogle [t] -> [t]
12:29:28 <copumpki> tail?
12:29:32 <vininim> id
12:29:35 <copumpki> lol
12:29:46 * roconnor wants gold too
12:29:48 <copumpki> init
12:29:59 <ski> (roconnor : `Identity' is strict .. as EvilTerran's example demonstrates)
12:30:06 * copumpki shows roconnor the bottom of the rainbow
12:30:10 <monochrom> evil Identity
12:30:12 <roconnor> ski: I mean (>>) is lazy
12:30:13 <ray> id is the only one that works on []
12:30:16 <ray> so id wins
12:30:22 <mauke> drop 1
12:30:36 <copumpki> that's not a named function, sry
12:30:36 <roconnor> const []
12:30:37 <ski> aye
12:30:44 <vininim> @bot
12:30:44 <lunabot>  :)
12:30:45 <monochrom> The bottom of the rainbow is an infinite loop.
12:30:51 <ray> const [] is a -> [t]
12:30:53 <copumpki> roconnor: that's [t] -> [t1]
12:31:00 <copumpki> ah, yeah
12:31:03 <roconnor> hoggle will find it
12:31:06 <roconnor> hoogle
12:31:10 <vininim> lambda bot was dos'ed by Identity? omg
12:31:12 * copumpki hoggles
12:31:12 <ray> hoggle
12:31:31 <roconnor> @slap hoggle
12:31:31 <hoggle> it's like a cute little pig
12:31:37 * lambdabot slaps hoggle
12:31:47 <hoggle> @hoggle a -> b
12:31:53 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:31:59 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:31:59 <hoggle> yay levenshtein
12:32:03 <roconnor> undefined
12:32:09 <lambdabot> Plugin `hoogle' failed with: thread killed
12:32:21 <hoggle> wow, lambdabot is being slow
12:32:33 <vininim> someone is fiddling with it
12:32:33 <Cale> It looks like it just reconnected
12:32:37 <ski> presumably it is still joining a lot of channels
12:32:40 <Cale> So it's joining channels
12:32:42 <ray>   thread killed
12:32:48 <Cale> I wonder why it reconnected
12:32:58 <ray> someone was strict with it
12:33:02 <vininim> Cale: Identity killed it
12:33:10 <vininim> egodeath or something
12:33:26 <Cale> what?
12:33:37 <ray> very hofstadter
12:33:41 <monochrom> haha
12:34:30 <hoggle> I ddin't know erlang was made in factories
12:37:36 <gwern> hoggle: well, java is. why not erlang?
12:37:54 <hoggle> erlang-factory.com!
12:38:26 <gwern> but it goes to show that erlang is more primitive than java. when was the last time you saw a factory factory in erlang, eh?
12:38:38 <hoggle> true, erlang fails :(
12:38:40 <monochrom> You can make babies in factories too.
12:38:42 <hoggle> metafactory factory
12:39:32 <Berengal> Is a factory factory factory something like fmap fmap fmap?
12:39:41 <ray> vaguely
12:39:52 <skorpan> what's the relation?
12:39:56 <tetha> anything with more than 2 factories in it is something horrible
12:39:59 <tetha> imho
12:40:02 <ray> factories are probably a functor
12:40:12 <pumpkin_> anything with more than 0 factories is an abomination, imnsho
12:40:13 <lambdabot> pumpkin_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:40:16 <ray> so you can fmap fmap fmap into your factory factory factory
12:40:23 <inimino> it's more object-orientationy
12:40:24 <Berengal> tetha: I would've left out "more than 2"
12:40:33 <conal> inimino: :)
12:40:33 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
12:41:12 <Berengal> Well, a factory factory factory is like three layers of factories, but fmap fmap fmap is only two layers...
12:41:32 <inimino> see, factories save typing
12:41:44 <Berengal> There's also fmap . fmap
12:42:00 <roconnor> Berengal: you mean fmap fmap fmap
12:42:08 <ray> fmap `fmap` fmap
12:42:18 <roconnor> oops
12:42:18 <Berengal> roconnor: Those are the same, are they not?
12:42:21 <roconnor> I'm slow
12:43:13 <conal> i like the visual distinction of "fmap . fmap", because it emphasizes the generality of the fmap's
12:43:25 <conal> and that first, second, etc can be substituted.
12:43:33 <conal> semantic editor combinators in general.
12:43:45 <byorgey> conal: I think people only like "fmap fmap fmap" for its mind-bendingness =)
12:43:52 <byorgey> I hope no one would ever use it in real code...
12:44:11 <tetha> heh, so I guess the n-fmap-haskell programmer is like the n-star-c-programmer :)
12:44:27 <byorgey> conal: I like that about "fmap . fmap" too, though
12:44:29 <monochrom> I used 3 stars in C.
12:44:43 <conal> byorgey: :)
12:45:10 <ray> kleene stars
12:45:59 <mkaemmer> monochrom: you should use an infinite number of stars by expanding *p to *&*&*&*&*...p
12:46:01 <byorgey> @remember conal The C ADT is implemented simply as String (or char *, for you type theorists, using a notation from Kleene)
12:46:01 <lambdabot> I will never forget.
12:46:28 <byorgey> conal: hehe, that blog post was hilarious =)
12:46:38 <ray> i nearly choked to death laughing
12:46:39 <skorpan`> if i have [x, y, z] and w and i want (x + (y + (z * w))), how would i do that?
12:46:46 <monochrom> Haha conal
12:47:03 <conal> byorgey: thanks!  that post pretty much leapt out of me.
12:47:04 <ray> and i don't even read haskell blogs, i just happened to go to planet.haskell at random
12:47:30 <conal> i hadn't noticed the C/Kleene thing until a moment before I typed it.
12:48:08 <byorgey> I wonder if Kleene's notation inspired C syntax?  sounds far-fetched but... ?
12:49:00 <Botje> skorpan`: sum (init l ++ w * last l)
12:49:03 <byorgey> skorpan`: it's ALMOST a fold, but not quite...
12:49:10 <skorpan`> byorgey: exactly
12:49:21 <wy> I didn't know that Kleene invented another star :)
12:49:25 <skorpan`> Botje: but imagine that it's not really + and *, but completely different binary functions
12:49:29 <conal> byorgey: sounds far-fetched to me too, but then who knows.
12:49:29 <Botje> foldr (+) (w * last l) (init l)
12:49:35 <Botje> better?
12:49:42 <skorpan`> Botje: possibly, i can't test it atm
12:50:03 <Botje> > let l = [x,y,z] in foldr (+) (w * last l) (init l)
12:50:03 <conal> as my dad would say "all the stories i make up are true"
12:50:07 <lambdabot>   x + (y + w * z)
12:50:19 <byorgey> conal: hehe =)
12:50:20 <Botje> looks like it's what you want :)
12:50:25 <skorpan`> > let l = [a,b,c,d] in foldr (+) (w * last l) (init l)
12:50:26 <lambdabot>   a + (b + (c + w * d))
12:50:31 <skorpan`> yep, looks right
12:50:37 <pumpkin_> that isn't very purty though!
12:51:03 <byorgey> > foldr (\e -> ((e+) .)) (*w) [x,y,z]
12:51:05 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
12:51:05 <lambdabot>        arising from a use...
12:51:07 <Botje> that it isn't :)
12:51:20 <byorgey> > foldr (\e -> ((e+) .)) (*w) [x,y,z] [x,y,z]
12:51:22 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
12:51:25 <pumpkin_> that's nicer :)
12:51:28 <pumpkin_> when it works
12:51:40 <byorgey> @type foldr (\e -> ((e+) .)) (*w) [x,y,z]
12:51:41 <lambdabot> Expr -> Expr
12:51:47 <byorgey> @type foldr (\e -> ((e+) .)) (*w) [1,2,3]
12:51:48 <lambdabot> Expr -> Expr
12:51:54 <byorgey> argh
12:51:56 <skorpan`> is it really nicer?  to me it just seems less understandable
12:51:59 <byorgey> @type foldr (\e -> ((e+) .)) (*10) [1,2,3]
12:52:00 <lambdabot> forall a. (Num a) => a -> a
12:52:14 <pumpkin_> hmm, you need a final 0?
12:52:16 <byorgey> @type foldr (\e -> ((e+) .)) (*10) [1,2,3] $ 1
12:52:17 <lambdabot> forall a. (Num a) => a
12:52:30 <wy> monochrom: I still haven't found the key to show the difference between newtype and data
12:52:31 <pumpkin_> it's a 0 isn't it?
12:52:32 <pumpkin_> > foldr (\e -> ((e+) .)) (*10) [1,2,3] $ 1
12:52:34 <lambdabot>   16
12:53:09 <byorgey> hmm, well, I think we could make this work in theory, but I have just aptly demoonstrated how confusing it is =)
12:53:33 <mkaemmer> > foldl (\e -> ((e+) .)) (*10) [1,2,3] $ 0
12:53:34 <lambdabot>       Occurs check: cannot construct the infinite type: a = a1 -> a
12:53:34 <lambdabot>      Prob...
12:55:20 <riddochc> Got a question on laziness and data structures. The RWH book says that the 'lines' function returns a list of strings, one per line. Suppose I'm computing a mean of a list of numbers in a file, one per line, and I'm folding over the output of lines.  Is Haskell going to build a big list of the lines before processing any of them, or is it going to read the next line just before it'll get used?
12:55:36 <Botje> the second
12:55:51 <Botje> laziness means the compiler can interleave computations for you
12:56:13 <byorgey> riddochc: it depends how you implement the averaging operation.
12:56:14 <mauke> riddochc: depends on how you read the lines
12:56:40 <byorgey> riddochc: if the averaging operation needs two passes over the list, one for the sum, and one for the length, then it will have to keep the entire list around in memory.
12:56:42 <Fred320> @pl concat . map
12:56:42 <lambdabot> join . map
12:57:07 <Botje> ... shit
12:57:12 <byorgey> but if you keep a running sum and count as you do one pass over the list, and compute the average from that at the end, then laziness should kick in and the whole thing will take constant memory.
12:57:16 <Botje> i'm utterly baffles as to how i'm supposed to write a conclusion
12:57:25 <riddochc> byorgey: right, I'm assuming a running sum.
12:58:33 <qaz> > let decent_avg_function xs = foldl ((summa, len)  next -> (summa+next,len+1)) (0,0) xs in decent_avg_function [1,2,3]
12:58:34 <lambdabot>   <no location info>: parse error on input `->'
12:58:42 <qaz> > let decent_avg_function xs = foldl ((summa, len) next -> (summa+next,len+1)) (0,0) xs in decent_avg_function [1,2,3]
12:58:43 <lambdabot>   <no location info>: parse error on input `->'
12:58:47 <byorgey> riddochc: the main point is, this has nothing to do with 'lines' --- lines is perfectly lazy, so if you write a nice consumer for the list that lines produces, things will work fine.
12:59:23 <riddochc> So, is all I/O then delayed until its ready to be processed?  I'm coming from languages like, for example, ruby, where IO.readlines is different from IO.each_line - the first reads *all* lines, the second reads one line at a time and yields it to a block.
12:59:24 <byorgey> so the short answer to your question is "the second, but be careful how you average" =)
12:59:41 <qaz> > let decent_avg_function xs = foldl ((summa, len) next -> (summa+next,len+1)) (0,0) xs in decent_avg_function [1,2,3]
12:59:42 <lambdabot>   <no location info>: parse error on input `->'
13:00:05 <skorpan`> > let decent_avg_function xs = foldl (\(summa, len) next -> (summa+next,len+1)) (0,0) xs in decent_avg_function [1,2,3]
13:00:05 <byorgey> riddochc: there are a few I/O operations, such as getContents and readFile, which operate lazily.  Not all I/O is.
13:00:06 <lambdabot>   (6,3)
13:00:11 <byorgey> riddochc: they're kind of magical though.
13:00:30 <riddochc> Wow.  A bot that runs arbitrary code.  That seems... unwise. ;)
13:00:36 <Berengal> There's also unsafeInterleaveIO, which is the nub of the magic
13:00:43 <qaz> > let decent_avg_function xs = let (a,b) = foldl (\(summa, len) next -> (summa+next,len+1)) (0,0) xs in  a / b in decent_avg_function [1,2,3]
13:00:44 <lambdabot>   2.0
13:00:52 <byorgey> riddochc: it doesn't run IO operations.
13:00:57 <Berengal> > print "hello"
13:00:59 <byorgey> and is otherwise rather tightly bolted down. =)
13:00:59 <lambdabot>   <IO ()>
13:01:03 <wy> Any good examples to show the difference between newtype and data types?
13:01:20 <Berengal> wy: Appart from the restrictions on newtype?
13:01:57 <wy> Berengal: What do you mean by restrictions?
13:02:02 <byorgey> wy: the biggest difference---that there is no runtime overhead for newtypes---is hard to see directly with an example
13:02:03 <wy> I see...
13:02:04 <wy> yes
13:02:23 <mauke> newtype R = R R
13:02:25 <Berengal> wy: Well, newtypes can only have one constructor and one field
13:02:28 <mauke> how many values in this type?
13:02:52 <pumpkin_> two!
13:02:58 <Berengal> two?
13:02:59 <byorgey> one!
13:03:00 <mauke> which ones?
13:03:09 <Berengal> I'd say bottom is the only one... fix R
13:03:18 <pumpkin_> undefined and fix R
13:03:19 <hatds> is that even legal? o.o
13:03:31 <riddochc> Hmm.  I may be getting way ahead of myself here, but how does lazy I/O interact with things like network sockets or pipes, where the amount of data that can be worked on at any given point can change?
13:03:38 <Berengal> pumpkin_: By that logic R (fix R) is a third value
13:03:38 <byorgey> pumpkin_: fix R *is* undefined
13:03:39 <wy> mauke: That's a weird example
13:03:48 <Zao> riddochc: Blocking?
13:03:52 <mauke> wy: it's condensed
13:03:59 <pumpkin_> can't you distinguish between fix R and undefined?
13:04:06 <mauke> pumpkin_: try it!
13:04:25 * pumpkin_ tries it!
13:04:28 <wy> mauke: strange...
13:04:35 <byorgey> pumpkin_: this is the point: newtypes are unlifted, i.e. there's no tag stored at runtime
13:04:39 <pumpkin_> oh
13:04:43 <pumpkin_> ok :)
13:04:44 <wy> data R = R R is not valid but newtype R = R R is ...
13:04:45 * pumpkin_ doesn't try it
13:04:57 <mauke> wy: both are valid
13:05:14 <wy> oh my fault...
13:05:17 <byorgey> data R = R R is quite valid, and has omega many values
13:05:27 <hatds> pretty useless datatype though, since you can't build any values without a party crasher like undefined or error --right?
13:05:35 <riddochc> Where would I find out which I/O functions work lazily and which don't?
13:05:39 <Berengal> Hehe, show (fix R) and show (undefined :: R) both result in the same infinite string
13:05:45 <byorgey> hatds: you can build  r = R r !
13:05:52 <byorgey> no undefined or error there
13:05:57 <mauke> it's a type with no real values, similar to 'data X' (no constructors)
13:05:58 <hatds> ok
13:06:05 <mauke> except the 'data X' stuff is not H98
13:06:38 <pumpkin_> that's cool
13:06:41 <byorgey> hatds: wait, it depends which version of R you were talking about
13:06:41 <pumpkin_> undefined :: R
13:06:50 <wy> mauke: has newtype R = R R only one value?
13:06:54 <mauke> wy: yes
13:07:01 <pumpkin_> even undefined is that value!
13:07:03 * pumpkin_ is impressed
13:07:11 <hatds> byorgey: what other R?
13:07:17 <mauke> the 'data' version shall be called data S = S S
13:07:19 <byorgey> hatds: newtype R = R R, or data R = R R ?
13:07:23 <byorgey> ok =)
13:07:33 <Berengal> With newtype R = R R deriving Show, I can't tell the difference between fix R and undefined, but with data R = R R I can...
13:07:51 <byorgey> hatds: R is useless.  with S, you can do what I said: make  s = S s, which doesn't use undefined or error.
13:08:24 <wy> I still want an example to show an observable difference
13:08:44 <Berengal> wy: Try what I just did
13:08:49 <hatds> we've gone a bit on a tangent for this poor guy :)
13:09:11 <mauke> wy: R undefined `seq` ()
13:09:16 <Berengal> newtype R = R R, data S = S S, both deriving show. Now try show (undefined :: R) and show (undefined :: S)
13:09:18 <hatds> normally, a data constructor represents another layer of indirection.  Newtype constructors remove that
13:09:57 <monochrom> His question is why not always optimize "data D = C X" to newtype.
13:10:22 <mauke> because that changes the semantics
13:10:27 <mauke> so it's not an optimization
13:10:36 <Vulpyne> At my work, I frequently run into a situation where I want to pull large text files into Map. I usually have a problem with running out of memory and/or stack space, so I'm doing something horribly wrong. Here is an example: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5084
13:11:09 <Vulpyne> Anyone have an idea of what I can change? I've tried strict and lazy bytestrings, and I'm using foldl'.
13:12:10 <wy> @src seq
13:12:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:13:10 <Fred320> @pl \x y -> x ++ e:y
13:13:10 <lambdabot> (. (e :)) . (++)
13:13:45 <wy> Berengal: That's weird...
13:14:10 <Berengal> wy: It's also why they're different
13:14:47 <Berengal> wy: http://www.haskell.org/haskellwiki/Newtype
13:15:27 <jeff_s_> I thought the following was a valid type declaration: "data Equation = [Math]". Did I do something wrong?
13:15:37 <mauke> jeff_s_: missing constructor
13:15:39 <Berengal> jeff_s_: You need a constructor
13:15:40 <jeff_s_> "data Equation = Data.List Math" worked
13:15:49 <mauke> that surprises me
13:15:59 <Berengal> Wow, could that be legal?
13:16:06 <jeff_s_> well, it parses anyway
13:16:10 <Vulpyne> jeff_s_: You might mean: type Equation = [Math] ... That creates an alias not an actual type.
13:16:17 <Twey> o.@
13:17:05 <Berengal> I can't get anything like Data.List to parse as a constructor
13:17:11 <hatds> yea me neither
13:17:21 <jeff_s_> oh I see what's going on better. Sorry, it's my old ML habits getting in the way.
13:17:33 <Fred320> inits "ABC"
13:17:35 <Vulpyne> Does anyone have any ideas regarding my question?
13:17:36 <Fred320> > inits "ABC"
13:17:37 <lambdabot>   ["","A","AB","ABC"]
13:18:10 <jeff_s_> but ya "data Math = LP | RP | Plus | Sub | Mul | Div | Var Char
13:18:10 <jeff_s_> data Equation = Data.List Math" parses, dunno if it should or not
13:18:20 <mauke> doesn't parse for me
13:18:25 <mauke> try.hs:5:16: Qualified name in binding position: Data.List
13:18:34 <jeff_s_> dunno what to tell you :\\
13:19:01 <Berengal> Perhaps paste the whole code, in case there's something else interfering with the parsing?
13:19:03 <mauke> you should tell me that you're using hugs
13:19:11 <jeff_s_> ghc
13:19:57 <jeff_s_> I pasted all the code. If I put "main = print "hi"" after it, it compiles
13:20:07 <jeff_s_> er, sorry no, 1 sec
13:20:11 <Cale> Vulpyne: hmm... just a random shot in the dark here: what happens if you replace M.insert with M.insertWith' const ?
13:20:17 <wy> Berengal: Thanks very much. That's the example I wanted to make
13:20:32 <jeff_s_> ok now I get a type error, but it parses
13:20:42 <mreh> how does one import something from a module that has been imported into another module through the parent module?
13:20:51 <Cale> Vulpyne: If that doesn't help, then I'll actually think about it more carefully :)
13:21:02 <wy> It would take more thinking how these examples are related
13:21:04 <qaz> > let flipWithMe f a b = flip $ flip f a b in flipWithMe (-) 10 20
13:21:04 <Cale> Vulpyne: Also, just to check, you are compiling with -O2 yeah?
13:21:05 <lambdabot>       Overlapping instances for Show (b -> a -> c)
13:21:05 <lambdabot>        arising from a use ...
13:21:19 <Vulpyne> I wasn't, but I'll try that.
13:21:22 <byorgey> mreh: you can only do so if the second module re-exports the thing from the parent module.
13:21:23 <qaz> > let flipWithMe f a b = (flip . flip) f a b in flipWithMe (-) 10 20
13:21:24 <lambdabot>   -10
13:21:34 <mreh> byorgey: thanks
13:21:49 <Vulpyne> cale: Unfortunately, it doesn't seem to have made a difference.
13:21:51 <byorgey> in which case you just import it as normal.
13:21:58 <conal> Cale: thanks for the blog comment.  i just responded: http://conal.net/blog/posts/the-c-language-is-purely-functional/#comment-21125
13:22:11 <Cale> conal: Okay :)
13:22:26 <Fred320> behold my permutation function :)
13:22:29 <Fred320> > foldr (\x rest -> concat $ map (\list -> zipWith (\a z -> a ++ x:z) (inits list) (tails list)) rest) [[]] "ABC"
13:22:30 <lambdabot>   ["ABC","BAC","BCA","ACB","CAB","CBA"]
13:22:41 <mauke> needs more runStateT
13:22:58 <wy> Berengal: So for the example on the wikipage, because (Foo1 _) will be used to structurally match undefined, it goes into infinite loop
13:23:44 <wy> but (Foo3 _) is identical to _, so it is not looked at
13:24:21 <Berengal> wy: No, (Foo1 _) looks for the constructor Foo1, which it can't find in 'undefined', so bottoms out
13:24:36 <Berengal> Foo3 has no constructor, so basically that part is correct
13:25:00 <Vulpyne> Somehow I feel like I've fixed this before, but I can't remember. I haven't done haskell programming in a while.
13:25:08 <mreh> what's the most idiomatic way of updating a record?
13:25:18 <Berengal> wy: data Foo1 = Foo1 Int can either be _|_, Foo1 _|_ or Foo1 Int, where _|_ is bottom
13:25:24 <Vulpyne> rec { field = val }
13:25:35 <Berengal> wy: newtype Foo3 = Foo3 Int can either be _|_ or Foo3 Int
13:25:41 <Vulpyne> Doesn't update it though, returns a new one with the change.
13:26:08 <wy> Berengal: Maybe I can just think of Foo3 as Int?
13:26:12 <mreh> Vulpyne, of course
13:26:14 <mreh> thanks
13:26:31 * EvilTerran wishes for a syntax something like "foo { field <- fn }" to desugar to "foo { field = fn (field foo) }"
13:26:45 <wy> So there will be a tag in the object with Foo1?
13:26:48 <Berengal> wy: Yeah, it's certainly correct, appart from the class instances and the fact that it's a completely new type... otherwise, it behaves exactly the same
13:26:59 <mreh> EvilTerran: desugar?
13:27:15 <wy> Berengal: I see. So it exist only at compile time
13:27:21 <mreh> it's more of a smell
13:27:24 <Berengal> wy: Yes, exactly!
13:27:41 <seliopou> Ugh, this is meta-haskell related, but it should be said: somebody in #erlang just asked a question about postgres libraries, and the first response was http://lmgtfy.org/?q=erlang+postgresql . Never seen that happen in here, and hopefully I never will :(
13:28:46 <Fred320> @src inits
13:28:46 <lambdabot> inits []     =  [[]]
13:28:46 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
13:29:22 <Fred320> @src taisl
13:29:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:29:25 <Fred320> @src tails
13:29:25 <lambdabot> tails []         = [[]]
13:29:25 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
13:29:34 <EvilTerran> seliopou, i think the equivalent here would be "?go erlang postgresql" - possibly in /msg with lambdabot first to make sure it actually produced a useful url
13:29:44 <Jedai> seliopou: the irony is that the first result is an article with this startling sentence : "Like just about everything to do with Erlang, database driver support appears to be in total disarray"
13:29:46 <byorgey> seliopou: if it ever does, I will personally and publicly shame whoever posted such a link. =)
13:30:01 <wy> Berengal: For you example show (undefined::R), it is still a little strange. It prints (R (R (R ...
13:30:03 <Vulpyne> Maybe I need to try to rewrite this to use Map.insertWith' instead of Map.alter.
13:30:12 <Twey> seliopou: With the little traffic they get in #erlang, it's surprising they'd squander it so carelessly :-P
13:30:37 <Jedai> EvilTerran: Well I would argue that this hasn't the same RTFM smell since it's basically a way of giving him the URL directly
13:30:46 <seliopou> guys, I like the snark. It's measured and appropriate.
13:30:49 <seliopou> :P
13:31:41 <EvilTerran> wy, i see why you find that strange, but it's consistent with the way newtypes work in other places
13:31:46 <Jedai> EvilTerran: And there's no small animation with a "Was that so bad ?" at the end
13:32:04 <marcusb> I try to port uniplate's rewrite to SYB, but I'm stuck defining the type even.  Copying the type definition of "everywhere" from the Data.Generics.Schemes file gives an error: "myeverywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)" leads "parse error on input =>"
13:32:24 <EvilTerran> "newtype R = R R" has only one value, bottom, but the newtype semantics mean you can pattern-match out the R (R (R ... as far as you like
13:32:41 <byorgey> marcusb: you may need to enable some language extensions
13:32:48 <byorgey> marcusb: try Rank2Types for starters
13:33:11 <wy> EvilTerran: What caused the match to happen?
13:33:18 <yitz> conal: fun blog post :]
13:33:31 <EvilTerran> wy, the derived Show instance, if i'm understanding your question righ
13:33:34 <EvilTerran> t
13:33:36 <conal> yitz: :) !
13:33:51 <Berengal> wy: Try writing the show instance for R yourself, the same way the compiler does it, then walk through a couple of iterations
13:34:02 <byorgey> hmm, so  show (R (R undefined)) would print (R (R (R (R (R ..... ?
13:34:03 <glguy> *Main> case undefined of R _ -> 1
13:34:03 <glguy> 1
13:35:13 <byorgey> wow, it really does.  amazing!
13:35:29 <Berengal> show (R r) = "R (" ++ show r ++ ")"
13:35:38 <mauke> there is only one value in R so it has to print the same
13:35:44 <qaz> doesnt all erlang dudes write their own database?
13:36:00 <qaz> mnesia, couch db etc
13:36:29 <wy> Berengal: show
13:36:33 <wy> sorry...
13:36:43 <byorgey> mauke: right.  it makes sense, I had just never followed this particular rabbit hole so far before =)
13:36:45 <wy> showR (R x) = "R" ++ showR x
13:37:03 <seliopou> umm...
13:37:06 <seliopou> *Main> case undefined of R _ -> 1
13:37:06 <EvilTerran> > repeat 'R'
13:37:06 <seliopou> *** Exception: Prelude.undefined
13:37:07 <lambdabot>   "RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR...
13:37:19 <EvilTerran> @arr
13:37:19 <lambdabot> Smartly me lass
13:37:24 <glguy> seliopou, you have to do it as a newtype
13:37:30 <seliopou> ah, ok
13:37:32 <mauke> seliopou: what is your R?
13:37:49 * EvilTerran notes that "data R = R !R" would be different again
13:38:22 <EvilTerran> (i think that would have _|_ and (fix R) as distinct values, but no other values)
13:38:50 <byorgey> sounds reasonable
13:39:18 <marcusb> byorgey: that's it, thanks
13:39:35 <wy> I see... show (R r) will type r as R, so "show r" will try to match it again with (R r), ... and so on
13:39:43 <glguy> EvilTerran, wouldn't fix R be _|_ in that case?
13:39:46 <EvilTerran> while "data R = R R" would have distinct values for each element of (iterate R undefined), and (fix R)
13:39:51 <mauke> STOP CALLING THOSE R
13:39:58 <conal> gee.  the comments keep coming on that functional C post
13:40:11 <byorgey> conal: you've hit a nerve =)
13:40:15 <seliopou> looks like the case on the undefined is getting compiled away is getting compiled away
13:40:19 <mauke> it's called R because it's purely recursive
13:40:29 <mauke> data S = S S because it's only one step
13:40:31 <conal> byorgey: yeah :)
13:40:38 <EvilTerran> glguy, er... not sure. depends on the subtlties of !
13:40:45 <Berengal> conal: I see nothing controversial about it. After all, it's lambdas all the way down ;)
13:40:48 <EvilTerran> (which i'm not wholly familiar with)
13:40:51 <mauke> you need to find your own name for strict data
13:41:04 <wy> wow! Thanks so much guys. boss has come. time to work :)
13:41:07 <EvilTerran> mauke, i was just calling it R because other people seemed to be...
13:41:15 <mauke> they were Wrong™
13:41:22 <Berengal> mauke: I'll call it Caek if I want to :P
13:41:23 <EvilTerran> data S' = S' S' -- S' : S :: foldl' : foldl
13:41:38 <mauke> !
13:41:47 <byorgey> you mean data S' = S' !S' ?
13:41:56 <glguy> EvilTerran, I think you can do no more and no less with a fix S than an undefined
13:41:59 <EvilTerran> er, yes. of course. <.< >.>
13:42:15 <glguy> though GHC's black hole detection might not notice the fix version
13:43:02 <EvilTerran> glguy, wouldn't "case fix S' of S' _ -> ()" yield ()?
13:43:08 <dmwit> EvilTerran: no
13:43:10 <glguy> no
13:43:15 <Sgeo> :t Just Right
13:43:17 <lambdabot> forall b a. Maybe (b -> Either a b)
13:43:25 <Berengal> fix S' would never return
13:43:28 <EvilTerran> ah, yeah, i see.
13:43:35 <dmwit> EvilTerran: Pattern matching on strict data demands the strict arguments. ;-)
13:44:32 <EvilTerran> indeed. i got a little confused as to whether the circularity in (fix S') would be noticed by that "demand", but of course it wouldn't, that'd be implementation leaking into semantics
13:45:34 <glguy> *Main Control.Monad.Fix> let x = S x in case x of S _ -> 1
13:45:41 <glguy> and ghc uses my cpu :)
13:59:19 <agruman> is there some "easy" way to force the execution of a function to be strict?
13:59:45 <lament> well.
13:59:51 <lament> yes, seq
13:59:52 <Cale> agruman: Functions which pattern match against their parameters are strict, and you can use seq
13:59:58 <Cale> Or bang patterns.
14:00:09 <Cale> f !x = ...
14:00:54 <Cale> When the pattern !x is matched against, x is evaluated into WHNF before the pattern unconditionally succeeds in matching.
14:01:32 <monadic_kid> bang and the dirty is gone
14:01:33 <lament> that is so ugly
14:01:41 <Cale> hm?
14:02:18 <agruman> Cale: ok, thanks for the info
14:02:23 <Cale> I should say, functions which pattern match against *constructors* are strict
14:02:23 <Jedai> lament: I like bang patterns better than seq
14:02:35 <lament> Jedai: sure, but still ugly
14:02:41 <Cale> lament: How so?
14:02:52 <Cale> I don't think it could be any prettier.
14:03:06 <dmwit> agruman: Your question suggests you're new to strictness, so may I offer this word of warning: strictness is only strict to the *first constructor* in most cases.
14:03:17 <lament> Cale: ugly because the pattern now does two unrelated things
14:03:21 <dmwit> agruman: So, for example, using `seq` on a list is almost entirely useless.
14:03:26 <lament> Cale: match or not match, and evaluate
14:03:41 <Cale> lament: But pattern matching has always been what drives evaluation.
14:04:08 <lament> Cale: i suppose
14:04:08 <Cale> If you pick a specific type, say, Maybe t for example...
14:04:14 <lament> yeah
14:04:15 <Cale> f !x = foo
14:04:16 <lament> i understand
14:04:20 <Cale> could be replaced with
14:04:22 <Cale> f Nothing = foo
14:04:26 <Cale> f (Just x) = foo
14:04:40 <lament> i guess i find that ugly as well. Perhaps I just hate Haskell.
14:04:42 <agruman> dmwit: yes im somewhat new to it :), my problem is that i use map on the same list twice, and both calls have side effects, i just want to make sure that the first map is executed first
14:04:57 <stroan> Berengal recommended yesteday writing a simple interpretter to get to learn monads. Would that be using parsec, or without?
14:05:03 <Cale> agruman: side effects?
14:05:09 <lament> map has side effects?
14:05:17 <Cale> agruman: evaluation of map f xs can't have any side effects...
14:05:23 <Berengal> stroan: Without, write your own parser
14:05:32 <agruman> Cale: its running inside a monad, and the functions manipulates the environment
14:05:38 <agruman> Cale: ah mapM :)
14:05:49 <Cale> agruman: Oh, the evaluation order doesn't matter then
14:05:53 <dmwit> agruman: mapM ensures the correct order of side effects.
14:06:01 <dmwit> agruman: (Without resorting to being strict, in some cases.)
14:06:06 <Cale> agruman: What matters is the execution order, which is entirely separate.
14:06:11 <stroan> Berengal: ah, you're here :) Grando.
14:06:19 <agruman> ah ok, thats good :)
14:06:34 <agruman> then my problem is somewhere else ...
14:06:48 <marcusb> I wrote something that loops forever and I don't have a clue what's going on
14:07:27 <dmwit> ?hpaste
14:07:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:07:36 <dmwit> marcusb: Help us help you. =)
14:07:40 <marcusb> ok ;)
14:07:45 <marcusb> let me nail it down to a small example
14:07:54 <Cale> "Thankyou for helping us help you help us all."
14:09:33 <Berengal> stroan: If you want, I do have a litterate haskell file implementing a very simple parser monad, which I wrote some time back when I was learning monads myself. I won't claim it's good pedagogy, and it's basically the solution to a puzzle which could've given you insight into monads if you solved it yourself, but it's there if you want it
14:10:25 <stroan> Berengal: thanks for the offer. Mind if I take you up on it after I've implemented my own?
14:11:11 <lament> > "Thank you for helping " ++ (intercalate " help " $ cycle ["us", you"])
14:11:13 <lambdabot>   <no location info>:
14:11:13 <lambdabot>      lexical error in string/character literal at chara...
14:11:13 <dmwit> stroan: There's also sigfpe's tutorial, which guides you through writing three or four different monads, so you can see the similarities.
14:11:16 <Berengal> stroan: Not at all, just let me know :)
14:11:30 <dmwit> > "Thank you for helping " ++ (intercalate " help " $ cycle ["us", "you"])
14:11:31 <lambdabot>   "Thank you for helping us help you help us help you help us help you help u...
14:11:42 <stroan> dmwit: link?
14:11:49 <stroan> currently going through all about monads
14:11:54 <dmwit> ?go you could have invented monads and maybe you already have
14:11:55 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:11:56 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:12:08 <stroan> ah yes, I've read that
14:12:10 <marcusb> dmwit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5085#a5085
14:12:11 <lament> dmwit: what's the difference? :(
14:12:21 <dmwit> lament: double-quote on you
14:12:33 <lament> oops
14:13:03 <Berengal> At some point you need to stop reading tutorials and just implement a goddamn monad yourself...
14:13:21 <dmwit> I dunno.
14:13:40 <dmwit> I don't think I ever implemented a monad until I'd been using them for some time.
14:13:52 <stroan> Berengal: yup. Doing that atm :)
14:13:55 <dmwit> Although, maybe that's not true.
14:14:01 <Berengal> dmwit: Not even the state monad?=
14:14:07 <dmwit> Since sigfpe's guide was the one that did it for me, and it has you implement three. =)
14:14:09 <lament> "reinventing the monad"
14:14:15 <Berengal> Or the identity monad?
14:14:18 <stroan> the articles can't give the intuitive understanding
14:14:48 <dmwit> Berengal: Yeah, I take it back.  "You Could Have Invented Monads" has you do the list, state, and writer monads, I think.
14:14:50 <gnuvince_> @src withFile
14:14:51 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
14:15:19 <Berengal> Actually, the most zen moment I had with monads was after I had implemented the monad and was actually using it in a monadic context
14:15:54 <Berengal> In the lhs file I was talking about earlier, the last lines are basically me having multiple mental orgasms
14:16:10 <stroan> Berengal: I may *not* take you up on it...
14:16:11 <stroan> ;)
14:16:15 <Berengal> :P
14:17:36 <wh1t3> hmmmk, anybody with any experience with Vista combined with wxHaskell
14:17:54 <wh1t3> it spawns a Window, but as soon as i move the mouse over it, it crashes
14:18:10 <wh1t3> found people with similar problems on Google, but no solutions
14:18:53 <dmwit> Are you sure you're initializing everything correctly?
14:19:14 <dmwit> I had a similar thing with hOpenGL on *nix when I forgot to allocate an actual GL window object or something like that.
14:20:37 <wh1t3> dmwit, works fine on openSuse and XP
14:20:49 <wh1t3> so the source code is ok
14:20:54 <dmwit> Okay, so probably not that. =)
14:21:03 <wh1t3> might be some installation issue, but i doubt that
14:21:14 <wh1t3> as, like i said, many people seem to have this issue
14:21:39 <dmwit> Have you gotten any other language's bindings to work?
14:21:54 <wh1t3> what do you mean? :)
14:22:25 <wh1t3> as in another language that uses wxWidgets as well?
14:22:33 <dmwit> Well, it would be nice to know whether we should be looking for a wx problem or a problem with the Haskell bindings.
14:22:33 <wh1t3> if so, no, I dont use any :P
14:22:40 <dmwit> Yes, another language that uses wxWidgets.
14:23:05 <dmwit> Grab the "Hello, world!" program for wxWidgets in C or C++ or something and try running it. =)
14:23:16 <wh1t3> hmm, good suggestion, ill do that :)
14:23:33 <dmwit> Then if it works, see if transliterating it to Haskell also works. =)
14:25:08 <wh1t3> dmwit, ive downloaded the dialogs demo app (which is precompiled, dunno if that will actually test wxWidgets, i spose it does) and that runs fine
14:25:55 <wh1t3> cheers for the help btw dmwit :)
14:38:29 <marcusb> wrt to the infinite loop, can I somaybe trace all partial expansions of the expression?
14:38:38 <marcusb> maybe that gives me a hint
14:43:22 <dmwit> marcusb: What does "everywhere" do?
14:43:31 <eivuokko> Been away for a long while.  I see that ctrl+c is now async exception in ghc.  Is there a way to make it non-async?
14:44:00 <marcusb> dmwit: that's from Data.Generics.Schemes, it applies a function to all data in a type bottom-up
14:44:40 <marcusb> dmwit: I guess it's somehow a misinteraction between everywhere and the way I defined rewrite.  I copied rewrite from uniplate, and the transform function of uniplate is almost the same as everywhere, so I just tried it
14:45:11 <marcusb> dmwit: I don't actually have an expectation that this code works exactly as written, but it should be possible to fix it.  but I don't know how to debug haskell code.
14:45:27 <dmwit> Have you tried using :break? ;-)
14:45:29 <marcusb> I am not sure I can change the function so that I can put in print's, and I don't know how to trace
14:45:30 <FunctorSalad> everywhere f = f . gmapT (everywhere f)
14:45:32 <marcusb> yes
14:45:42 <marcusb> I tried :break rewrite
14:45:50 <marcusb> I get: _result :: a -> a = _
14:46:02 <marcusb> which I don't know what it imeans.
14:46:21 * FunctorSalad is somehow uncomfortable with the casting in syb...
14:46:22 <dmwit> It means you have to :step a little to do any interesting computation.
14:47:03 <marcusb> well, there was lots of gibberish like that
14:47:18 <marcusb> "Maybe a1 = _",  "x :: a1 = _", "a1 = _"
14:47:22 <marcusb> no idea what any of this means
14:48:36 <yaxu> I don't suppose there's a way to get ^Y working in ghci version 6.10.3?
14:49:24 <yaxu> I keep deleting things and finding I can't yank them back
14:49:40 <marcusb> dmwit: oh, there is a line number
14:50:26 <dmwit> marcusb: I'm pretty uncertain myself.  Part of that is because I've never used generics, so I'm not comfortable with everywhere and mkM.
14:50:44 <marcusb> dmwit: there are line and column numbers, that should help
14:50:44 <dmwit> You might want to stare at their definitions and make sure they're doing what you think they're doing.
14:50:46 <FunctorSalad> yaxu: isn't your terminal emulator responsible for that?
14:51:58 <FunctorSalad> yaxu: hmm never mind, you're right, ^Y is actually a separate clipboard it seems :)
14:52:25 <yaxu> yep I think it's a haskeline problem
14:53:35 <yaxu> ah there's an "add kill ring" haskeline ticket, ok
14:54:36 * yaxu uses rlwrap
15:00:58 <marcusb> dmwit: yeah, I'm totally new to generics, too
15:01:02 <marcusb> learned about them today
15:01:44 <Botje> marcusb: try Uniplate for a more gentle introduction to generics
15:02:04 <Botje> i found SYB to be pretty hard but uniplate is a lot more user friendly
15:02:23 <marcusb> botje: uniplate can't mix types, and I am kinda worried I am going there
15:02:39 <Botje> uniplate can't, but biplate can
15:02:53 <Botje> which means you have to use the *Bi versions of everything
15:02:59 <Botje> transformBi, universeBi, ...
15:03:04 <marcusb> that was the other thing I was worried about, that uniplate has this split personality :)
15:03:36 <marcusb> I'll have another look
15:03:52 <Botje> 's just a suggestion :)
15:04:27 <marcusb> it's a good one ;)
15:04:48 <marcusb> it's hard to pick the right tool if you're thrown in the water
15:05:11 <FunctorSalad> syb tends to become brain-asploding once you try to do zips with it ;)
15:05:34 <FunctorSalad> (parallely working on two Datas)
15:05:41 <FunctorSalad> but maybe it's just me
15:06:15 <kau> why isn't if' :: Bool -> a -> a -> a defined in prelude?
15:06:40 <Botje> the people who wrote the prelude were a bunch of pr(el)udes? :)
15:06:41 <FunctorSalad> (I don't mean "parallel" as in distributed there)
15:11:04 <dmwit> kau: Many of H98's decisions (such as letting "if" be a separate syntactic class, or the monomorphism restriction) now that people have used Haskell for a decade or so.
15:11:26 <dmwit> Haskell' is trying to deal with that, and if they live up to their release schedule, I'm optimistic.
15:11:49 <dmwit> err, add a "seem questionable" in there after the parenthetical.
15:12:46 <FunctorSalad> at least rename it ;)
15:13:17 <FunctorSalad> what is the release schedule dmwit?
15:13:56 <dmwit> To be honest, letting "if" be syntax or a function seems like a relatively unimportant design decision compared to the decision to use lazy semantics, or the decision to use HM-style typings, or the decision to base the language on firm theoretical ground. =)
15:13:56 <kau> i'm leaving, goodbye
15:14:04 <dmwit> FunctorSalad: Every six months, I think.
15:14:15 <Heffalump> every year I think
15:14:21 <Heffalump> but I haven't seen much sign that they'll manage even that
15:14:34 <dmwit> yeah =/
15:16:28 <jeff_s_> is it possible to use an "if ... then ... else ..." clause as an argument to a function without putting it in parens?
15:16:42 <Heffalump> I don't think so
15:16:48 <jeff_s_> aw, oh well.
15:17:09 <monochrom> > show if True then 0 else 0
15:17:10 <Heffalump> the most likely syntactic ambiguity it would cause is with whatever came after the else
15:17:10 <lambdabot>   <no location info>: parse error on input `if'
15:17:16 <Heffalump> > show $ if True then 0 else 1
15:17:16 <monochrom> oh well :)
15:17:17 <lambdabot>   "0"
15:17:26 <Heffalump> oh, so yes.
15:18:02 <jeff_s_> I was thinking that ghc would use the whitespace to remove ambiguity. Oh sorry, forgot to mention that it starts on a new line
15:19:17 <Jennii> wtf is this? python is so stupid a language. why dont you listen to Torvalds and all use C for everything?
15:19:35 <monochrom> Wrong channel.
15:19:43 <dmwit> Coool, a language troll who doesn't even know how to spell.
15:19:57 <jeff_s_> oh wow, that's not at all what I expected. I didn't think function arguments could appear on the same column as the function name, but I guess that makes sense cause there's no such thing as a second call in the sequence (eg ML, c)
15:20:13 <c_wraith> I don't understand anti-python trolling in #haskell.
15:20:19 <jeff_s_> ya that is strange :)
15:20:23 <c_wraith> Wouldn't anti-haskell trolling have a better chance?
15:20:26 <blackh> We like Python.
15:20:26 <Jennii> im sorry, was a dare ;)
15:20:27 <dmwit> jeff_s_: Sure, functions don't introduce blocks.
15:20:32 <Vulpyne> Maybe he's afraid of snakes.
15:20:32 <Jennii> i love python ;)
15:20:40 <Jennii> cya
15:20:45 <stroan> hah
15:20:47 <Baughn> ..yep, that was weird.
15:20:53 <stroan> well, a dare's a dare :P
15:20:58 <dmwit> So, I wonder whether she was actually Jenny or Becky.
15:21:08 <jeff_s_> Probably was Bob.
15:21:14 <dmwit> ...or Sarah (from /whowas).
15:21:54 <FunctorSalad> it's called "cross-trolling". all the cool kids are doing it now.
15:22:09 <blackh> I liked train surfing better.
15:22:34 <mreh> I hate Richard Dawkins
15:22:54 <SubStack> did he park in your space?
15:23:33 <mreh> I wish he did, then I would key his car
15:24:23 <mreh> s{ship= (ship s){hAcc= a}}
15:24:27 <mreh> what is this doing?
15:24:55 <FunctorSalad> jeff_s_: actually haskell-mode tries to force you to put args in the same column as the function name, I dislike that...
15:24:58 <dmwit> It's updating the hAcc field of the ship field of s to be a.
15:25:04 <deech> Hi all, is there broadcast function for GHC threads?
15:25:10 <blackh> mreh: Tell me why you don't like Richard Dawkins on #haskell-blah
15:25:16 <dmwit> deech: No, but you can use MChans to do that.
15:25:24 <SubStack> MChans are nice
15:25:25 <deech> dmwit: thanks!
15:25:27 <dmwit> deech: Check out the paper "Beautiful Concurrency" or something like that.
15:25:41 <dmwit> blackh: It was a joke.
15:25:48 <mreh> dmwit: is ship a function in that?
15:25:49 <dmwit> blackh: A followup to the "cross-trolling" joke.
15:26:01 <dmwit> mreh: It is a record selector.
15:26:02 <RyanT5000> hey blackh
15:26:05 <blackh> Good one. :)
15:26:11 <dmwit> mreh: So it is part function, part updator.
15:26:27 <mreh> dmwit: What?
15:26:36 <amckinley> hey, could someone help me figure this out? http://pastebin.com/m18d8dbe6
15:26:49 <blackh> RyanT5000: Morning! How's it going?
15:27:04 <amckinley> im trying to figure out how to use parsec's user state, and im getting type errors on lines 40 and 102
15:27:07 <dmwit> mreh: s { ship = {- here, ship is acting as an updater -} (ship s {- and here, as a selector (function) -}) { hAcc = a }}
15:27:40 <RyanT5000> blackh: pretty good; how have you been?
15:27:41 <dmwit> mreh: Have you seen record syntax before?
15:27:46 <mreh> dmwit: but there is only one ship in the record
15:27:50 <mreh> why do i need to select it
15:27:55 <mreh> dmwit: sort of
15:27:58 <mreh> it's sugar isnt it
15:28:33 <dmwit> mreh: The selector is telling to select from s.  You need a selector so you know which value (of that particular record type) to use the ship field from.
15:28:40 <dmwit> Dunno if I'm saying this in a good way.
15:28:54 <dmwit> Suppose you have
15:28:59 <dmwit> sink :: Ship -> Ship
15:29:14 <dmwit> And you have s :: Fleet.
15:29:23 <dmwit> (or whatever)
15:29:49 <dmwit> Then, to sink the ship in s, you have to first select s's ship, sink it, then update s with the newly update (sunk) ship.
15:29:58 <dmwit> So: create a sunken ship: (sink (ship s))
15:30:14 <dmwit> update s: (s { ship = sink (ship s) })
15:30:35 <dmwit> It might make more sense to write it as
15:30:48 <dmwit> (s { ship = newShip } where newShip = sink (ship s))
15:31:00 <dmwit> Now throw in another record update to hAcc and you're there. =)
15:32:03 <dmwit> And now I really must be going, but definitely keep asking questions here.
15:32:30 <mreh> ship is a function of State -> Ship aint it
15:32:50 <dmwit> That is one of the things it does, yes.
15:33:02 <mreh> so what i'm doing is making a new state based on the current one, getting the ship out of the old one, and putting it in the new one modified
15:33:08 <dmwit> ship actually lives in three separate syntactic classes.
15:33:15 <dmwit> mreh: Yes, exactly.
15:33:55 <mreh> I'm still thinking Java
15:35:10 <amckinley> anybody? im sure im just doing something stupid
15:35:20 <mreh> what three syntactic classes, dmwit?
15:35:22 <amckinley> ^^
15:35:57 <Cale> amckinley: I'll have a look
15:36:11 <amckinley> Cale: thanks a bunch
15:36:14 <monadic_kid> what you could do is have pure functions from Ship -> Ship and then localize a state monad in one place
15:36:19 <tibbe> anyone know what the windows equivalent of sendfile() is?
15:36:43 <Cale> amckinley: It's probably that Parser is a type synonym for a kind of parser with no user state.
15:36:49 <Cale> amckinley: But I will check
15:37:19 <Cale> amckinley: actually, what might be easier is if you comment out your explicit type signatures and see if it helps
15:37:35 <amckinley> Cale: trying that now...
15:38:13 <amckinley> nope, same error: Couldn't match expected type `()' against inferred type `Maybe a'
15:38:34 <Cale> Well, yeah, that's definitely the problem anyway, if that's the error you're getting.
15:38:46 <Cale> The type of a parser which has user state is different from one without.
15:38:59 <amckinley> oh, crazy
15:39:04 <amckinley> i *never* would have figured that out :)
15:39:05 <FunctorSalad> amckinley: the most general form is "ParsecT"
15:39:06 <Cale> Well, it needs to be.
15:39:26 <Cale> Also, you should note that you're using deprecated names for the parsec modules.
15:39:39 <FunctorSalad> IIRC it takes the stream type, the user state type and the token type as params
15:39:42 <amckinley> so change all my "Parser foo" type signatures to "ParsecT foo" or similar?
15:39:43 <Cale> They're shorter now:  Text.Parsec.*
15:39:47 <FunctorSalad> (and then the param in which it is a monad)
15:39:51 <Cale> type Parser = Parsec String ()
15:40:27 <FunctorSalad> er ParsecT also takes a base monad, use Parsec as Cale said if you don't need one
15:41:01 <amckinley> FunctorSalad: gotcha
15:41:13 <Cale> The () in that type alias definition is the user state type
15:41:22 <Cale> and the one which doesn't match with your Maybe t :)
15:43:05 <Cale> The parameter to TokenParser is also the user state type
15:43:11 <Cale> They will all have to agree.
15:44:01 <Cale> (because the user state is threaded along throughout the parse, and so the types have to match up in any intermediate parsers even if they don't explicitly touch the state)
15:44:14 <monochrom> Write "GenParser Char (Maybe String) blah" instead of "Parser blah"
15:44:40 <Cale> You can use  Parsec (Maybe String)  as well
15:45:29 <amckinley> hmmm, do i need to be using parsec 3 to take advantage of the new package layout?
15:45:52 <jeff_s_> I've written a function I needed that is the same as takeWhile but also gives what was left of the list. I'm wondering if I'm reinventing the wheel or if it's already in Prelude or Data.List (I didn't see it). http://pastebin.com/d4af2febb
15:46:17 <Cale> amckinley: yeah
15:46:26 <Cale> amckinley: I sort of assumed that you were
15:46:34 <monochrom> No, Parsec is more complicated. "Parsec stream_type (Maybe String) blah"
15:46:44 <Cale> wait, what?
15:46:54 <Cale> type Parser = Parsec String ()
15:46:54 <amckinley> Cale: i thought i was :) but i just checked:
15:46:55 <amckinley>  * parsec
15:46:55 <amckinley>       Latest version available: 3.0.0
15:46:55 <amckinley>       Latest version installed: 2.1.0.1
15:47:00 <monochrom> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html
15:47:13 <mreh> :t uncurry
15:47:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:47:32 <Cale> oh, right, yeah
15:47:50 <monochrom> And there is simply no "Parsec" in 2.1.x
15:47:56 <amckinley> so i need Parsec char (Maybe String) blah
15:48:34 <Cale> Parsec String (Maybe String) ...
15:48:36 <Berengal> jeff_s_: span
15:48:47 <Berengal> @type span
15:48:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:48:57 <Cale> (or ByteString if you're parsing ByteStrings)
15:49:05 <amckinley> cabal upgrade parsec isnt doing it for me
15:49:23 <monochrom> "Parsec String (Maybe String) blah" or "GenParser Char (Maybe String) blah". Don't do genetic-crossing-evolution on them.
15:49:39 <FunctorSalad> amckinley: cabal install parsec
15:49:53 <dcoutts> amckinley: you're after version 2 or 3? if 3 use 'parsec >= 3'
15:49:54 <FunctorSalad> "upgrade" is defunct I think
15:49:59 <amckinley> "all req'd packages are installed"
15:50:00 <dcoutts> since v2 is the default
15:50:13 <jeff_s_> Berengal - thanks
15:50:22 <amckinley> dcoutts: that did it
15:57:11 <amckinley> haHA!
15:57:14 <amckinley> got it :)
15:58:11 <amckinley> i also had to change the invocation from parse p  "" to runParser p Nothing ""
15:58:49 <amckinley> if anyone would like to sanity check me, or point out anything else dumb/wrong about the rest of the code, im all ears
15:58:50 <amckinley> http://pastebin.com/m412038dd
15:59:09 <gwern> I wonder if programmers would be better off if, before every session, we offered up some chants or prayers to the Buddhas of Wisdom & Compassion (replace $DEITIES as appropriate)
15:59:21 <hatds> hmm.. what is exported again when there is no export list? (not the empty export list)
15:59:39 <gwern> everything?
15:59:43 <eivuokko> Everything.
15:59:51 <hatds> including all imports made by that module?
15:59:55 <eivuokko> No.
16:00:03 <hatds> are you sure?
16:00:07 <eivuokko> Imports must be exported always explicitly.
16:00:08 <gwern> hatds: of course not. that'd really mess things up!
16:00:15 <hatds> k
16:00:21 <hatds> I wasn't sure what it did
16:00:27 <Berengal> gwern: I usually do a little 5-min meditation session before I start on a longer coding session
16:00:40 <gwern> Berengal: a commendable practice
16:01:20 <Berengal> gwern: Useful to get the types in order, that's for sure
16:01:38 <gwern> heh. there's a lot to remember in programming
16:02:01 <Wraithan> I turn on some metal and jump in... *shrug*
16:02:05 <monochrom> Let the computer remember for you.
16:02:23 <eivuokko> gwern, then you are usually doing something the hard way.
16:02:50 <monochrom> These days I even let the computer verify my proofs.
16:02:50 <gwern> eivuokko: even if you are exploiting tools to the max, there's still a lot of stuff one has to remember about programming
16:03:12 <Berengal> The trick is to empty your mind
16:03:19 <roconnor> @quote MonadState
16:03:20 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
16:03:39 <FunctorSalad> monochrom: actual real-world proofs?
16:03:41 <monochrom> Yeah. I empty my mind by setting up an empty virtual machine in my mind. That's how I learned Haskell.
16:03:47 <Berengal> Not to get all metaphysical on you guys, but I'm sure I'm not the only one who thinks coding is a mental state
16:04:15 <gwern> oh, I just learned haskell by memorizing the axioms of the polymorphic lambda calculus. all the rest is trivia, really
16:04:18 <monochrom> Yes actual real-world proofs. I found something wrong and how to workaround it in one proof I am writing up.
16:04:35 <Wraithan> Oh I think it is too, I just need music to block out the distractions, distraction-wise I am really sensitive to audio
16:04:43 <FunctorSalad> monochrom: intriguing, which system and library do you use?
16:04:48 <monochrom> PVS
16:04:50 <eivuokko> gwern, The trick is not so much to use tools, but to keep right abstractions and put everything in right scope.
16:04:52 <andyou> Isn't Haskell really the intuitive way to do stuff? I mean, it looks like mathematics!
16:05:07 <eivuokko> gwern, Oh that way, yeah if yo uare new to language, and idioms, it might seem a lot to remember.
16:05:12 <Wraithan> so if I can block out sound around me, then I can really focus
16:05:15 <Berengal> andyou: It certainly is more intuitive for me.
16:06:09 <gwern> andyou: the problem with haskell sometimes is that you can't really hack your way to a solution. in java or whatever, you can munge state and stuff and reach something that works; with haskell, you can only incrementally arrive at a solution if you start at the bottom
16:06:21 <FunctorSalad> (btw if it wasn't clear, with "real-world" I was including all non-theorem-proving mathematics ;))
16:06:21 <lament> if you start at the bottom you'll never get anywhere
16:06:32 <monadic_kid> eivuokko: hey aren't the guy behind the directx bindings that mokehehe is using?
16:06:39 <eivuokko> monadic_kid, What
16:06:42 <eivuokko> monadic_kid, ?
16:06:45 <eivuokko> monadic_kid, And who
16:06:54 <Berengal> You could use undefined. As long as it typechecks it'll be correct most of the time. If it isn't, at least the types are correct...
16:07:12 <eivuokko> monadic_kid, I've done direct 3d bindings, yeah.  I didn't know they are being used.
16:07:20 <andyou> gwern: Yes, but the purpose of Haskell is hardly to "get something to work as quick as possible"... we have Python for that.
16:07:39 <lament> the purpose of haskell is clearly to get something to work as slow as possible.
16:07:40 <monadic_kid> eivuokko: how complete are they? it would be really cool if they where in hackage
16:07:55 <eivuokko> monadic_kid, I have no idea...I've not touched them in ages...
16:07:58 <monadic_kid> eivuokko: http://mokehehe.blogspot.com/
16:07:59 <hatds> speaking of, this restaurant on the corner plays its music at absurdly high volumes *head asplodes*
16:08:17 <monochrom> The theorem I proved is about loops and recursions.
16:09:08 <eivuokko> monadic_kid, Thanks...this suprises me.
16:09:11 <monadic_kid> eivuokko: i've been trying to get mokehehe to put them into hackage since i couldn't find you
16:09:35 <gwern> it's really too bad about super nario bros
16:09:49 <monadic_kid> gwern: ?
16:09:57 <gwern> we can never put it on hackage
16:10:37 <jeff_s_> is there an easy equivalent in haskell to this pattern match in ML? "match x with One | Two | Three -> true | _ -> false"
16:11:08 <monochrom> Make a clone called "ultimate maria sisters" and put it on hackage.
16:11:33 <gwern> monochrom: no, it basically needs a rewrite of the level data; all the images are stolen from nintendo
16:11:55 <monochrom> Unforuntately haskell can't do match x with One | Two | Three -> ...
16:12:05 <jeff_s_> aw
16:12:09 <jeff_s_> thanks anyway
16:13:05 <Philonous> you could use guards and elem x [One, Two, Three ]
16:13:19 <jeff_s_> ah, that's a good idea
16:13:42 <FunctorSalad> if you have only nullary constructors you can derive Enum and do [One..Ten] ;)
16:13:52 <FunctorSalad> but then you rely on constructor order
16:14:10 <eivuokko> monadic_kid, I have not touched the directx binding for ages, and they are not complete.  The most useful part was shader assembler definitions imo.
16:14:28 <jeff_s_> One of them isn't nullary, but thanks for the tip. I'll look at Enums sometime.
16:14:33 <eivuokko> monadic_kid, If there is interest in directx bindings, we oculd look into doing it properly.
16:16:42 <eivuokko> monadic_kid, And in preference, I'd like to see input and sound binded as well.
16:16:58 <eivuokko> And doing it so that changing between 10 and 9 isn't such a big deal.
16:17:26 <eivuokko> I really need bindings for 10 if I wanna play around graphics in haskell. :-/
16:17:28 <webjunkie01> sup all
16:19:23 <monadic_kid> eivuokko: how did he even find your bindings in the first place lol
16:20:07 <Baughn> @pl take 3 . drop ring . cycle
16:20:08 <lambdabot> take 3 . drop ring . cycle
16:20:32 <eivuokko> monadic_kid, That's what I'd like to know as well :-P
16:20:41 <eivuokko> monadic_kid, He must've kept them around for ages or something.
16:21:23 <persica> So, I keep hearing more and more about Haskell, but that could just be because I'm reading more and more in the functional programming crowds.  Is it really being looked at as a serious language, or are people still only considering it a toy? (despite how great it may be)
16:21:57 <copumpkin> definitely not a toy
16:22:04 <copumpkin> :)
16:22:05 <_JFT_> I have questions about cabal-install is there an irc channel for it or should I throw them here? :)
16:22:07 <eivuokko> persica, I've written significant production code in haskell.  It has it's good sides, and bad sides.  It's not just a toy.
16:22:12 <RyanT5000> If anyone's interested in a job writing a game in Haskell, PM me or email me at ryant5000@gmail.com
16:22:17 <SubStack> why do people think any technologies are just toys?
16:22:18 <persica> I guess people seem to have trouble pointing to companies which are actually haskell-shops.
16:22:27 <SubStack> it's a bad dichotomy I say
16:22:41 <RyanT5000> persica: i just started one (see above)
16:22:55 <monadic_kid> persica: there is a list on the wiki
16:23:00 <persica> I guess I'm not saying it's a toy, but I'm wondering if that's how the production world thinks these days.  E.g. that it's only suited for academics.
16:23:06 <monadic_kid> persica: list of companies using it
16:23:07 <SubStack> especially since network effects play such a big role in language adoption
16:23:09 <persica> monadic_kid: Ah, I can google that.
16:23:17 <monadic_kid> persica: on haskell wiki
16:23:28 <gwern> _JFT_: as good a chan as any
16:23:46 <persica> I have to say, the community around Haskell seems better than some other languages, though still small.
16:23:56 <persica> monadic_kid: I still use google for searching the haskell wiki often. :)
16:23:57 <_JFT_> gwern: Thank you! Any idea how I can configure my .cabal so that haddock documentation is always built when I install a package^
16:23:58 <_JFT_> ?
16:23:59 <monadic_kid> persica: http://www.haskell.org/haskellwiki/Haskell_in_industry
16:24:49 <persica> monadic_kid: thanks.
16:25:14 <persica> I really enjoy haskell, and I'm sinking a lot of time into it and enjoying it, and I'm starting to wonder if it's a good career move. :D
16:25:46 <monadic_kid> persica: there is yearly commerical FP gathering, cant remember the name
16:25:55 <_JFT_> persica: not if you are forced to work in Java or C++ since after coming to the FP darkside there is not turning back :D
16:26:28 <persica> _JFT_: That's what I'm worried about!  Should I turn back now before it's too late?
16:26:31 <monadic_kid> it's called "Commercial Users of Functional Programming (CUFP)"
16:26:33 <eivuokko> persica, If you don't know FP before and like FP, haskell's almost certainly a good career move even if you never get to use it.
16:26:42 <FunctorSalad> _JFT_: put "documentation: True" into ~/.cabal/config
16:26:50 <_JFT_> persica: and miss all the fun and enlightment? Nah :P Suffer like us :P
16:26:56 <persica> Actually, I feel like the problem could be getting people to let me work with Haskell on what would traditionally be done in another language.
16:27:04 <FunctorSalad> _JFT_: it's probably there already but commented out (confusingly, the -- in the config are comments ;))
16:27:12 <eivuokko> persica, If nothing else, it will count nicely for applying jobs with F#, which at least seems to be going up.
16:27:21 <Philonous> persica: Learning a functional language makes you a better imperative/OO/<enter favourite buzzword here> programmer as well
16:27:32 <_JFT_> FunctorSalad: my .cabal is simple I don't see anything haddock related there :(
16:27:32 <monadic_kid> persica: you've seen hackage?
16:27:45 <persica> Yeah.
16:28:09 <persica> It's a set of haskell packages/libraries, yes?
16:28:11 <_JFT_> persica: btw I brought Haskell in my company by bullying the research group :P
16:28:16 <_JFT_> (limited usage but stil)
16:28:47 <Philonous> persica: Though that's actually only true for LISP. And they only said that to lure unsuspecting programmers into luring lisp.
16:28:47 <Cale> _JFT_: hehe, bullying?
16:28:50 <Philonous> learning*
16:28:57 <persica> _JFT_: Eh, as long as you get some respite from the other languages.
16:29:03 <monadic_kid> persica: yeah database of packages you can grab like with yum
16:29:10 <FunctorSalad> _JFT_: I understood you as wanting to configure cabal globally to always build haddocks
16:29:22 <Cale> Philonous: What's only true of lisp?
16:29:23 <_JFT_> FunctorSalad: yes
16:29:29 <FunctorSalad> _JFT_: for that you edit ~/.cabal/config :)
16:29:40 <_JFT_> FunctorSalad: yes but mine is only 3 lines :(
16:29:42 <Baughn> > (*2) <$> . <$> [[3,4],[5,6]]
16:29:44 <lambdabot>   <no location info>: parse error on input `.'
16:29:48 <Philonous> Cale: That it makes you a better (imperative) programmer
16:29:49 <Baughn> ..I didn't think so.
16:29:57 <FunctorSalad> _JFT_: just add a "documentation: True" line then
16:30:08 <Cale> Philonous: Ah, I think it's true of Haskell as well, but it does make you hate programming imperatively.
16:30:15 <Philonous> Cale: (j/k, though)
16:30:20 <marcusb> I figured out my problem with rewrite for SYB: I was using mkM, which defaults to id, leading to infinite loop because trans_ Op1 = Just Op1.  Using mkMp, (MonadPlus version of Maybe), which defaults to Nothing, it works: trans_ Op1 = Nothing terminates the recursion.
16:30:33 <SamB> Cale: well, not necessarily hate
16:30:42 <_JFT_> cale: when I got in the research group I said fine you want me to push the boundary but let me push them with new tech. They were afraid then i said: so that's your idea of research? Using 20 yo technology no thanks
16:30:50 <_JFT_> cale: so they accepted for some tools ;)
16:31:07 <marcusb> Yay, now I got a rewrite function for SYB :)
16:31:20 <Cale> _JFT_: :)
16:31:20 <SamB> Cale: it might just make you see that it's an option
16:31:50 <_JFT_> FunctorSalad: Thank you! Any idea how I could batch build haddock for all the package I have already installed? the cabal haddock doesn't seem to do me any good
16:31:59 <SamB> that you could realistically go either way on, almost regardless of the purpose of your program ...
16:32:33 <FunctorSalad> _JFT_: ghc-pkg list --simple-output --names-only
16:32:42 <FunctorSalad> then run a bash for loop or something :)
16:32:48 <marcusb> is there a snippet library or something where I can contribute this function so others can find it?
16:33:22 <_JFT_> FunctorSalad: that part was ok but "cabal haddock <pkg-name>" fails
16:33:40 <_JFT_> FunctorSalad: I get something like:cabal: No cabal file found.
16:33:40 <_JFT_> Please create a package description file <pkgname>.cabal
16:33:50 <FunctorSalad> _JFT_: that's just for building the haddock in the project in the current directory I think. try "cabal install --reinstall $packages"
16:33:57 <SamB> marcusb: well ... you could put it on the wiki
16:33:57 <_JFT_> FunctorSalad: my package are seems to be compressed
16:34:17 <_JFT_> FunctorSalad: won't that recompile everything too?
16:34:20 <SamB> marcusb: I think you need to contact Ashley Yates (modulo spelling) to get an account ...
16:34:24 <marcusb> yeah
16:34:26 <marcusb> that's annoying
16:34:39 <gwern> could try asking ashley to lift the restriction for a time
16:34:41 <FunctorSalad> _JFT_: yes, but seems like less work than getting it to build the haddocks specifically...
16:34:43 <gwern> maybe the spammers wnet away
16:34:47 <SamB> marcusb: a lot LESS annoying than having no idea who to ask!
16:34:57 <_JFT_> FunctorSalad: ah! Thank you very much :)
16:34:59 <marcusb> SamB: :)
16:35:02 <FunctorSalad> np
16:35:16 <gwern> marcusb: as for the wiki - I find haddocks are a good place to include this tips, smuggled in as examples of how to use functions
16:36:11 <Philonous> Cale: It doesn't make me hate programming imperatively so much as it makes me hate programming in C. There are a few things like algebraic data types and pattern matching that would be easily implementable (or at least so I believe) but that at the same time reduce a lot of boilerplate
16:38:00 <Philonous> Cale: fwiw I think o'caml is a pretty nifty object oriented, imperative language
16:38:07 <Cale> Much of my ability/tolerance to read code with unrestricted state changes in it has atrophied. I end up needing to translate it into a functional description of what's going on to understand it.
16:39:05 <_JFT_> Philonous: I liked Ocaml "until" I grokked Type Classes (which wasn't long) after that Ocaml just felt "incomplete" :(
16:39:27 <marcusb> ok, mail sent
16:39:41 <persica> OCaml is another one I hear a lot about.
16:39:43 <_JFT_> Cale: what you just said is so true, it's like I am regressing now in C++...
16:40:12 <_JFT_> persica: I recommend Ocaml as a stepping stone to Haskell but once you reach Haskell there is no turning back IMVHO
16:40:57 <persica> Well, I jumped head first into Haskell and am still learning how to swim efficiently.
16:41:08 <weilawei> _JFT_: i've been working in Haskell but then I've had to do a project in RoR and theres one coming up in obj-c xD i want to do them in haskell but  i cant
16:42:00 <_JFT_> welterde: I feel your pain. I am developing a generation tool. The DSL parser is done in Haskell (my part), the generator in C++ and the front-end in C#
16:42:25 <_JFT_> weilawei: every time I have to touch the generator I feel the pain :(
16:42:27 <weilawei> my mind, she boggles.
16:43:18 <Philonous> Cale: Undisciplined use of side effects isn't the problem of the language but of the programmer. Bad programmes produce bad, unreadable code, no matter what language they use.
16:44:09 <persica> I'm with Philonous that just having learned Haskell I now look at code in other languages and see where side-effects could be eliminated to make it easier to read and debug.
16:44:10 <_JFT_> Philonous: after a while in Haskell you let your defense down, you no longer have to "manually" track side-effects, the type system is there... That's what is happening to me anyway :P
16:44:39 <monadic_kid> Philonous: however you really need a language which fosters side-effect free code and immutable data-structures otherwise
16:44:46 <Cale> Philonous: Well, right, but by not providing functional idioms, or making functional idioms hard, languages end up making programmers write programs poorly.
16:44:47 <persica> Also, Haskell just feels so concise.  I feel like I have to put down far too many characters in C/C++.
16:45:25 <persica> I've tried to explain some of the features of Haskell to friends and colleagues and saying that the variables are immutable really boggles their mind.
16:45:32 <_JFT_> FunctorSalad: Thanks again for the cabal-install I finally have doc generating :P
16:45:51 <FunctorSalad> :)
16:46:10 <_JFT_> persica: that's the blob paradox,!
16:46:15 <_JFT_> @goo blob paradox
16:46:17 <lambdabot> No Result Found.
16:47:25 <Philonous> persica: Well, there are mutable variables in haskell. You can't write useful programs without side effects.
16:47:52 <Wraithan> persica: I told that to someone who was making a feature request in #xmonad and they kinda stopped in their tracks
16:47:58 <persica> Philonous: This is true, though most of that is hidden inside IO.
16:48:00 <_JFT_> @goo "blub paradox"
16:48:02 <lambdabot> http://www.paulgraham.com/avg.html
16:48:02 <lambdabot> Title: Beating the Averages
16:48:18 <Philonous> Cale: Not necessarily. There is beautiful C code out there. (or so is the lore). But I agree that C makes it easy to write mind-boggling code
16:48:20 <Wraithan> (he was providing perl like psuedo-code)
16:49:36 <persica> Wraithan: I didn't even know you *could* write code like this before learning Haskell.  Now when I read books and they write their psudo-code which basically looks like C I can't help but realized how close-minded we all were.
16:52:30 <romildo> Hi.
16:53:38 <romildo> It seems that there is no array type in the Haskell libraries that would be resizable?
16:53:48 <romildo> Is that true?
16:54:19 <Cale> romildo: The closest thing is Data.Sequence
16:54:40 <Cale> romildo: What's your goal?
16:55:42 <persica> Doesn't most of the benefit in arrays come from the fact that they are in pre-allocated memory with known locations, and thus are not resizable?
16:56:18 <persica> (that is, not resiable without losing that performance benefit)
16:57:35 <Wraithan> persica: I think he means more of a vector type data structure
16:58:06 <thoughtpolice> copumpkin: well it seems igloo beat us to it :p
16:58:09 <Wraithan> Which can be used like a variable length array
16:58:11 <romildo> Cale, I am writing a GUI with gtk2hs. There is list of items that can grow or shrink dinamically, depending on the user interaction. Each item in the list is identified by an integer number. This list is stored in a IORef variable. I thought in replacing it with a mutable array in the IO monad.
16:58:54 <persica> array is such a nebulous term.  I thas a very specific definition in C, but with other languages they took the numerically-indexed-data-structure and have done all sorts of things with it while still calling it an "array".
16:58:54 <Cale> How long is the list?
16:58:55 <copumpkin> thoughtpolice: yup! I've been running around all day so couldn't work on it :( but I'm so happy Igloo did it, too... I may not get the glory, but I get to have x86_64 on mac os which is much better!
16:59:32 <romildo> Wraithan, you are right. Something like a vector.
16:59:34 <Wraithan> persica: C has variable length arrays now, if you you have a compiler that will do the latest standard of it
16:59:59 <Cale> romildo: Data.Sequence is nice in that it's immutable but it has fast (log time) access to all elements, and it can split and concatenate in log time (and space) as well.
17:00:09 <persica> Wraithan: Huh, I was unaware.
17:00:24 <erikc> C99 variable length arrays are just sugar for alloca
17:00:38 <Cale> romildo: You might also use a Map or IntMap, if there is the possibility of gaps between elements.
17:00:54 <Wraithan> persica: yeah, C99 added it
17:01:06 <copumpkin> <3 alloca
17:01:39 <newsham> hahah.  conal's blog post rules.  I'm afraid conal has oved to IO (as he is having an affect on the world)
17:01:46 <newsham> s/oved/moved/
17:02:02 <_JFT_> newsham: lol
17:04:17 <romildo> Cale, there is no gap in between elements. A list is good for me. I just thought that a mutable array would be better. As a consequence of user interaction, any element in the list can be changed. So I thought that a mutable array would be apropriate. Remember that the imutable list is already stored in an IORef variable.
17:05:02 <Cale> romildo: Perhaps Data.Sequence would improve performance for you.
17:05:14 <romildo> Cale, with an imutable structure, every time the user changes an element, a new structure should be constructed.
17:05:20 <roconnor> > 49000000/14000000
17:05:21 <lambdabot>   3.5
17:05:35 <romildo> Cale, I will take a look at Data.Sequence.
17:05:39 <_JFT_> romildo: check zippers ;)
17:06:05 <romildo> _JFT_, what are zippers?
17:06:12 <roconnor> 49 `choose` 6
17:06:13 <Cale> romildo: Yes, but in Data.Sequence's case, only an amount of memory logarithmic in the size of the structure is needed to get a new structure that has all the elements in common except one.
17:06:16 <roconnor> > 49 `choose` 6
17:06:16 <lambdabot>   Couldn't match expected type `t1 -> t'
17:06:37 <_JFT_> romildo: http://www.haskell.org/haskellwiki/Zipper
17:06:40 <Cale> roconnor: It's because internally, the structure is a tree, and subtrees can be shared.
17:06:53 <roconnor> romildo
17:06:58 <_JFT_> romildo: something that alleviate the cost of changing part of an immutable structure
17:07:15 <Cale> Zippers are good when you need to make lots of modifications around one particular "cursor" in the structure.
17:07:25 <roconnor> > product [49-6+1..49] `div` product [1..6]
17:07:26 <lambdabot>   13983816
17:07:42 <Cale> But if you need random access, nothing is going to do better than some kind of tree.
17:10:41 <thoughtpolice> copumpkin: yeah for sure
17:10:57 <copumpkin> thoughtpolice: you addicted to killzone now? :)
17:10:58 <thoughtpolice> copumpkin: now that bootstrapping is in place again I'm trying to get HEAD working on linux ppc/ppc64
17:11:05 <copumpkin> oh
17:11:09 <thoughtpolice> copumpkin: well i bought fallout 3 too
17:11:13 <copumpkin> lol
17:11:19 <copumpkin> that's a fun game
17:12:16 <thoughtpolice> copumpkin: but yeah, I want to try optimized HEAD build + mac os x + 64bit + DPH and see how it goes :)
17:12:27 <copumpkin> mmm
17:12:39 <copumpkin> I need to get me more cores
17:12:42 <copumpkin> only got four
17:15:21 <roconnor> > 3.5*0.4
17:15:22 <lambdabot>   1.4000000000000001
17:16:19 <p_l> copumpkin: SiCortex? 72cores in single tower computer? :D
17:16:28 <copumpkin> p_l: sounds good
17:17:14 <p_l> copumpkin: it would require some work on GHC, though (for MIPS64)
17:17:32 <Badger> :t 3.5 *  0.4
17:17:33 <lambdabot> forall t. (Fractional t) => t
17:17:40 <Badger> curse thee fractional
17:17:44 <copumpkin> p_l: yeah
17:17:54 <erikc> gnumake -j72
17:18:20 <p_l> erikc: you'd max I/O before reaching 72 :)
17:18:31 <erikc> heh, yea
17:18:38 <p_l> (well, maybe with 10GBit RDMA NFS...)
17:19:11 <erikc> not if some of your build tasks are generating lightmaps :)
17:19:20 <p_l> well, true :)
17:20:10 <p_l> IMHO 36 cores per processor board is nice package :)
17:31:31 <amckinley> hey, could someone explain why this doesnt work? http://pastebin.com/m1e57c498
17:34:00 <amckinley> getting a type error:     No instance for (Stream s m Char)
17:34:00 <amckinley>       arising from a use of `satisfy' at ../tmp/wtf.hs:6:17-31
17:34:56 <kniu> amckinley, what's the type of isUpper?
17:35:08 <persica> amckinley: Sorry, I'm still learning Parsec myself.
17:35:26 <amckinley> :t isUpper
17:35:27 <lambdabot> Char -> Bool
17:35:41 <kniu> oh hey
17:35:43 <amckinley> :t satisfy
17:35:44 <lambdabot> Not in scope: `satisfy'
17:35:57 <kniu> strange.
17:36:04 <amckinley> :t Text.Parsec.Prim.Satisfy
17:36:05 <lambdabot> Couldn't find qualified module.
17:36:09 <amckinley> argh
17:36:18 <amckinley> :t Text.Parsec.Char.Satisfy
17:36:19 <lambdabot> Couldn't find qualified module.
17:36:55 <amckinley> satisfy :: (Stream s m Char) =>
17:36:56 <amckinley>            (Char -> Bool) -> ParsecT s u m Char
17:37:20 <kniu> my ghci > :t satisfy
17:37:20 <kniu> satisfy :: (Char -> Bool) -> CharParser st Char
17:37:35 <amckinley> kniu: you're using a 2.x version of parsec
17:37:48 <kniu> and what's yours?
17:37:58 <amckinley> 3.x
17:38:31 <amckinley> hey Cale
17:39:00 <amckinley> any idea why this doesnt work now that ive switched to parsec 3.x? http://pastebin.com/m1e57c498
17:39:02 <amckinley> :)
17:40:39 <copumpkin> uh, not without an error :P
17:40:57 <amckinley> No instance for (Stream s m Char)
17:40:57 <amckinley>       arising from a use of `satisfy'
17:41:29 <conal> sclv: thanks for your blog comment.  mind if i replace "lennary" with "lennart" (or "Lennart")?
17:43:13 <amckinley> copumpkin: i feel like i need a more explicit type signature
17:43:56 <copumpkin> probably
17:44:15 <Cale> amckinley: Sorry about that... where is your code now?
17:44:25 <Cale> amckinley: I'll see if I can help sort it out
17:44:32 <amckinley> Cale: np, wb :) http://pastebin.com/m1e57c498
17:45:39 * BMeph wants a T-shirt with (imagine the solidi mark new lines): "Haskell | PARENTAL ADVISORY | Explicit Type Signatures"
17:46:06 <copumpkin> lol
17:46:09 <amckinley> :)
17:47:46 <FunctorSalad> nice one
17:48:31 <Cale> amckinley: hmm
17:48:40 <Cale> amckinley: What trouble are you having with that?
17:48:52 <amckinley>     No instance for (Stream s m Char)
17:48:53 <amckinley>       arising from a use of `satisfy' at ../tmp/wtf.hs:6:17-31
17:49:39 <Cale> amckinley: I don't get that error...
17:50:10 <amckinley> amckinley:dns amckinley$ runghc ../tmp/wtf.hs
17:50:10 <amckinley> ../tmp/wtf.hs:6:17:
17:50:10 <amckinley>     No instance for (Stream s m Char)
17:50:10 <amckinley>       arising from a use of `satisfy' at ../tmp/wtf.hs:6:17-31
17:50:11 <amckinley>     Possible fix: add an instance declaration for (Stream s m Char)
17:50:11 <amckinley>     In the first argument of `skipMany1', namely `(satisfy isUpper)'
17:50:12 <amckinley>     In the expression: skipMany1 (satisfy isUpper)
17:50:14 <amckinley>     In the definition of `foo': foo = skipMany1 (satisfy isUpper)
17:50:31 <sclv> conal: please do replace the typo. thx!
17:50:59 <sclv> oh, and "the point about monads" should be "the point about monoids" oops.
17:51:05 <Cale> amckinley: I just copied and pasted that code into a new file and loaded it in ghci with no problems
17:51:14 <FunctorSalad> DMR?
17:51:21 * ray wants a t-shirt with one of those ghc error messages that tells you "possible fix: add an instance"
17:51:22 <Cale> oh!
17:51:27 <Cale> That might be it
17:51:40 <ray> i'm not sure what dumb joke to work into it, though
17:51:49 <kyevan> YES!
17:51:54 <kyevan> er.
17:51:57 <kyevan> Wrongchan
17:52:02 <Cale> amckinley: Try putting {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the file, and see if it helps
17:52:30 <amckinley> that fixed it
17:52:32 <amckinley> *awesome*
17:52:52 <amckinley> :P
17:53:16 <amckinley> since ive been screwing with this for an hour, i feel like i should at least know what that language pragma does
17:53:26 <copumpkin> are there any parser combinators that work on top of Data.Text?
17:53:27 * bremner orders whatever kyevan is having
17:55:00 <roconnor> the monomorphism restriction is a bit complicated and stupid.
17:55:11 <copumpkin> I agree :/
17:55:48 <ray> the monomorphism restriction is widely reviled
17:57:18 <amckinley> presumably because it results in noobies dealing with incomprehensible error messages, among other reasons? :)
17:58:45 <ray> it certainly does that
17:59:18 <Gracenotes> lifting the monomorphism restriction would make things that appear to be constant expressions actually be reevaluated every time
17:59:27 <Gracenotes> especially in the way it interacts with the Num typeclass
18:00:03 <Gracenotes> (of course, it's not guaranteed these things won't be reevaluated every time, but one can generally depend on it...)
18:00:19 <ray> the num typeclass isn't nearly reviled enough
18:00:22 <amckinley> the wiki article makes sense
18:00:30 <amckinley> thanks again Cale :)
18:01:23 <aavogt> that reevaluation issue would be better delt with by a warning, not an error IMHO
18:02:32 <Gracenotes> the great fault of the Num typeclass is that you generally expect to be dealing with a specific type when working with numbers: that is, you have a specific type in mind, like an Int or Double
18:02:52 <Gracenotes> imho anyway
18:03:01 <FunctorSalad> you just have to fix the type once though, it will propagate
18:03:10 <Gracenotes> well. Not if you have many top-level functions.
18:03:40 <FunctorSalad> (and isn't ghc good at eliminating dictionaries anyway?)
18:03:43 <Gracenotes> but annotation is known to improve performance.
18:03:54 <jeff_s_> I have to say: I love functional languages.
18:03:58 <Gracenotes> FunctorSalad: well. For whole-program compilation maybe :)
18:04:31 <eivuokko> ..or in local scope, ie after inlining.
18:04:38 <hatds> does ghc do whole program optimization?
18:05:34 <eivuokko> Not explicitly, but you may get inlining that looks a lot like it.
18:06:32 <jeff_s_> finally! Solved http://www.spoj.pl/problems/ONP/
18:07:20 <roconnor> solve O = NP?
18:07:35 <jeff_s_> in Haskell? Can't. give me a better language
18:08:03 <dons> hatds: 90% of it.
18:08:48 <dons> Gracenotes: but  the great benefit is that we get to use (+) for adding things
18:09:15 <dons> anyway, give type decls. it's good for you.
18:09:34 <Gracenotes> yes. But it is somewhat unintuitive, and would be worsened much more -- perfect storm, perhaps! -- with the monomorphism restriction
18:09:49 <BMeph> Gracenotes: IMWO, the faults of the Num typeclass are so varied and full, that picking just one to be "great" is almost as Worthless as this very opinion. :)
18:10:25 <Gracenotes> eh. I think it is the greatest: the concept of its existence and the Haskell numerical system :) others tend to be more nitpicky
18:10:47 <Gracenotes> but there are pros to the approach, amidst the cons
18:10:51 <Gracenotes> and the snocs
18:11:01 <Gracenotes> anyway. my opinion, 's all.
18:11:02 <FunctorSalad> + and * should be seperate really...
18:11:03 <dons> i bet ghc would surprise you if you looked at the core
18:11:16 <FunctorSalad> (for vectors, mostly)
18:11:42 <Gracenotes> eh. non-numerical Num instances, *suspicious*
18:11:48 <conal> sclv: i just fixed both typos.  thx. :)
18:12:06 <Gracenotes> dons: howso?
18:12:07 * BMeph would love to bitch-slap the genius that decided to toss Show into the Num class...
18:12:16 <gwern> (go peacefully among the cons and snocs of the world / lispers have their place, just as you do / and no doubt all is executing as it should)
18:12:16 <FunctorSalad> granted, it's not a big thing to use some other operator for adding vectors
18:12:41 <Gracenotes> BMeph: perhaps an argument for typeclass synonyms from the beginning
18:13:43 <Gracenotes> except, how would GHC know to merge (Show a, Num a) into a synonym automatically. It's all so ... hrmhrmeate9werayhwefa :/
18:13:50 <dons> gwern: upload the Quantum IO monad to hackage... http://www.cs.nott.ac.uk/~txa/publ/qio.pdf
18:14:13 <copumpkin> lots of big Qs in that paper
18:14:25 <gwern> dons: bleh, is still working on the math package! he wanted to cabalize it hisself
18:14:45 <gwern> (foolish, since I could do it so much faster)
18:15:11 <dons> he's sigfpe's friend
18:15:51 <Gracenotes> 0|copumpkin> + 1|pumpkin>
18:15:56 <gwern> no license info. figures.
18:16:15 <Gracenotes> a non-probabilistic pumpkin bit
18:16:17 <copumpkin> :o
18:17:15 <mux> dons: hey! bsd-sysctl 1.0.1 should work on openbsd with numeric oids, if you want to give it a try I'd be glad
18:18:10 <gwern> dons: who, this Alexander Green?
18:19:00 <FunctorSalad> isn't copumpkin more like a linear functional?
18:19:06 <mux> btw, does anyone know if the hackage build bot defines some specific macro when building haddock documentation, so that I can generate docs for the whole module even if it's built on an architecture where not all functions will be available?
18:19:14 <copumpkin> I feel pretty constant :/
18:19:38 <gwern> mux: specific macro?
18:19:48 <mux> as in cpp macro
18:21:50 <FunctorSalad> a workaround would be to upload the docs for the bsd version somewhere and link from the description page..
18:22:12 <gwern> dons: ok, I've sent'em an email asking about licensiong info for QIO
18:22:50 <mux> FunctorSalad: I'm ready to define all the functions as error calls if there are no other solutions
18:22:52 <gwern> dons: although in retrospect I should've asked about their QML as well...
18:23:12 <gwern> dons: 'A functional quantum programming language implemented in Haskell.' http://fop.cs.nott.ac.uk/qml/compiler/
18:24:29 <gwern> ack! qml's entire licensing info is '(c) Jonathan Grattage, 2008. jonathan.grattage@imag.fr'
18:24:36 <gwern> well gee. that's helpful
18:25:07 <MyCatVerbs> gwern: didn't even bother to write "all right reserved", huh? :/
18:25:37 <gwern> hey now, maybe it's really under the GPL but he was too fagged by the second line
18:26:06 <gwern> oh, and the haskell generated by happy? it's a managed file
18:26:11 <gwern> -_-
18:26:49 <dons> "a managed file"?
18:26:57 <gwern> dons: ie checked into darcs
18:26:59 <eivuokko> I guess version controlled.
18:27:17 <gwern> presumably if the happy grammar is ever changed, he'll rerun happy and commit those changes as well...
18:27:29 <SamB> gwern: one hopes!
18:27:37 <gwern> I daren't check
18:27:41 <SamB> sometimes people forget these things
18:28:14 <eivuokko> Happy didn't used to be self-evident, so maybe it was just easier for people playing with it.
18:28:18 <dons> ah, so the grammar file itself isn't included?
18:28:29 <gwern> no, the grammar file is
18:28:49 <gwern> it includes both the grammar file and the file happy generates from the grammar file. I just consider it to be something of a wtf
18:28:57 <dons> shrug
18:28:59 <gwern> one wouldn't manage the contents of dist/, for example
18:30:19 <MyCatVerbs> Yeah, I'm with gwern on this one.
18:31:24 <MyCatVerbs> No automatically generated file should be in your version control.
18:31:54 <MyCatVerbs> For one thing, you'll get spurious changes all over the place if people have differing versions of the generator installed.
18:32:18 <marcusb> haskell mode for emacs doesn't get do-if-then-else indentation right :-/
18:32:32 <gwern> marcusb: yi does, fwiw
18:32:49 <FunctorSalad> you need the generated file for ghci though
18:35:29 <FunctorSalad> (of course that's just a question of convenience. I mean that someone getting the repo will be able to develop with ghci right away)
18:35:50 <gwern> indeed. the pdf says to just load up in ghci
18:41:19 <jeff_s_> does anyone have a more awesome haskell-y way to write http://pastebin.com/d5c29dfc5 ?
18:49:08 <conal> hm.  the "our branding sucks" haskell reddit thread got deleted (http://www.reddit.com/r/haskell/comments/8m092/why_our_branding_sucks_monads_are_okay_after_a/).  anyone know why?  i wrote a comment and got "that comment has been deleted".
18:49:46 <copumpkin> :o
18:50:54 <jeff_s_> hey! Monads are easy. it's using them properly taht's hard imo
18:51:00 <jeff_s_> and/but I"m a newbie
18:51:28 <aavogt> jeff_s_: use $ instead of brackets
18:51:40 <jeff_s_> ok I will try taht
18:51:55 <Zao> jeff_s_: getContents >>= mapM_ (print <$> toRPN . read)
18:52:12 <Zao> What's a non-applicative variant of <$>, if any?
18:52:19 <aavogt> liftM
18:53:21 <copumpkin> Zao: `fmap`
18:53:46 <copumpkin> Zao: <$> is only in the Applicative module, it actualy only relies on Functor
18:53:55 <Zao> copumpkin: Using `fmap` in that context will make the compiler pissy about precedence parsing though.
18:54:02 <copumpkin> true
18:54:03 <monochrom> I think it was deleted because someone misread it as "why our branding sucks monads".
18:54:23 <copumpkin> Zao: define your own precedence for it :P
18:54:32 <Zao> Or just use <$>, as it makes sense :)
18:54:38 <copumpkin> yup
18:55:01 <dons> conal: i removed it only because i thought i was editorialising
18:55:24 <dons> conal: but it does express what I think is a problem: the outside world sees monads as a problem, not a solution
18:55:34 <dons> i.e. the branding sucks
18:55:38 <conal> dons: yeah.
18:55:52 <dons> the very thing that e.g. means their language is implementable simply as our library!
18:55:53 <monochrom> the branding sucks monads :)
18:56:04 <conal> dons: if you'll repost, i'll add my analysis & suggestion.
18:56:09 <dons> will do.
18:56:24 <Zao> Monads are like sucking.
18:56:25 <monochrom> Phil Wadler's branding of monads is still the best to date.
18:56:47 <conal> monochrom: what's is it?
18:56:54 <jeff_s_> Zao - for read ghc says: Expected type Char inferred type String
18:57:05 <dons> i want people to think: awesome! this thing i'm struggling with is a monad. now my life just got easier.
18:57:15 <Zao> jeff_s_: Oh right, the lines.
18:57:20 <Zao> jeff_s_: Had different test data :)
18:57:21 <conal> dons: amen!
18:57:26 <jeff_s_> I wondered where that was supposed to go
18:57:37 <monochrom> "monads for functional programming" http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
18:57:46 <dons> conal: http://www.reddit.com/r/haskell/comments/8m1gj/our_branding_sucks_monads_are_okay_after_a_bit/
18:58:07 <conal> dons: and similarly for other type classes.  i think giving monads special attention is part of the problem.
18:58:47 <conal> s/monad/Monad/
18:59:00 <conal> oops.  s/monads/Monad/
18:59:05 <dons> agreed.
18:59:09 <conal> dons: there.  i just posted my comment.
18:59:12 <dons> instead of presenting the wealth of abstraction power
18:59:26 <dons> instead we get lost in the quicksands of IO.
18:59:33 <dons> the stickiest ground to try to fight our battles on
18:59:57 <conal> yeah.  and we encourage people to muddle two independent powerful and relatively simple ideas.
19:00:03 <conal> into one mysterious wad.
19:00:43 <conal> i'd like us to be more careful with our language.  for instance, i'd replace the common phrase "understanding monads" with "understanding Monad".
19:01:00 <dons> oh, i really like this idea of talking about IO as a (data) type, like String
19:01:03 <Zao> jeff_s_: lines <$> getContents >>= ...
19:01:09 <conal> :) !
19:01:32 <edwardk> dons: i.e. as a free monad of its operations?
19:01:34 <conal> i think the goal of "understanding monads" is a confusion, since there are infinitely many, quite different monads.
19:01:43 <dons> asa type, with operations on it.
19:01:49 <MonadBaastad> conal: Or even "understanding the Monad class" - except, then you risk running into all of the baggage that goes along with the name "class"
19:02:09 <jeff_s_> say typeclass instead
19:02:12 <monochrom> To understand "+" you already run into typeclasses.
19:02:23 <Zao> jeff_s_: Writing Haskell code is mostly a matter of ensuring that signature impedance matches.
19:02:28 <monochrom> Hell, to understand "0"...
19:02:35 <Zao> jeff_s_: And being overly clever so your code is unreadable after a few days :P
19:02:38 <conal> yeah.  "understanding Monad" or "understanding the Monad typeclass" (for verbosity).
19:02:47 <dons> time for Conal's guide to monads, (and monoids, and functors, and applicatives)...
19:02:58 <conal> or byorgey's!
19:03:10 <dons> "The IO monad" considered harmful
19:03:14 <dons> there's your title
19:03:29 <conal> yes!  and the quotation marks are vital.
19:03:40 <MonadBaastad> dons: Better: The IO Monad - Mostly Harmless!
19:03:55 <conal> the title would draw people in with one expectation (forgetting to notice the quotes), and then surprise them.
19:04:09 <Zao> Monads all look the same to me.
19:04:16 <dons> hehe. bait and switch :)
19:04:53 <conal> edwardk: no, not the free monad.  the abstract IO type.
19:05:23 <marcusb> you want a beginners opinion?  I have extensive CS and math backgrounds and spent a week to learn the basics of haskell, monads, monad transformers and generic programming.
19:05:35 <edwardk> conal: example? or do you just mean treating it like an opaque type with just the knowledge you get from the operations allowed?
19:05:49 <edwardk> i.e. that it could be secretly implemented as data IO a = GetChar (Char -> IO a) | PutChar Char (IO a) | ...
19:06:13 <marcusb> I think one of the problems is that most documentation follows the historical development of the language and its focus on abstractions.
19:06:17 <conal> edwardk: right.  an opaque/abstract type.
19:06:35 <conal> edwardk: having the semantics of IO
19:06:37 <marcusb> it would have been easier if I had seen complete(!) simple examples illustrating the concepts
19:07:03 <edwardk> conal: fair enough, that fits with the way i've been teaching it to folks
19:07:13 <conal> edwardk: glad to hear.  :)
19:07:16 <marcusb> this was my issue: I understood the concept of monads early (the math is no problem for me), but I had trouble figuring out how to use the state monad
19:07:32 <marcusb> until after couple of hours of reading I found out that it is just a chain of functions
19:07:37 <marcusb> that was a major lightbulb
19:08:16 <conal> marcusb: i think your difficulty is another example of my recommendation to separate IO from Monad.
19:08:17 <marcusb> by that time I had read about 12 times that a monad has a unit and a bind interface
19:08:22 <edwardk> marcusb: yeah i think monads really clicked for me by reading one of wadlers early example papers where he just defined a whole bunch of them. (even if he did get a few 'wrong' by modern parlance, i.e. bag, set, strict, etc)
19:08:29 <conal> marcusb: the State *type* is simple.
19:08:51 <marcusb> conal: yes, although to be fair most tutorials I read don't start with IO, but with Maybe, List, and some others
19:08:53 <conal> marcusb: but trying to think about State and Monad simultaneously taxes the brain.
19:09:01 <roconnor> @type GetChar
19:09:02 <lambdabot> Not in scope: data constructor `GetChar'
19:09:04 <roconnor> @type getChar
19:09:06 <lambdabot> IO Char
19:09:08 <marcusb> "you could have invented monads" is really good
19:09:23 <conal> marcusb: glad to hear (Maybe, List, ...).
19:09:42 <marcusb> conal: I don't know.  maybe is too trivial to make the concepts clear
19:09:45 <marcusb> same for lists
19:10:00 <marcusb> by the time I read that, everything I did with Maybe and Lists would have worked even if they are not monads
19:10:00 <conal> similarly, i'd like IO tutorials to start with examples that do not involve Monad.
19:10:04 <marcusb> (at least superficially)
19:10:32 <conal> marcusb: similarly, lots of IO code can be written with simpler interfaces.
19:10:37 <marcusb> I still don't actually see Maybe and Lists as Monads when hacking
19:10:49 <marcusb> conal: I just use WriterT [String] :)
19:11:10 <conal> marcusb: did you know that list comprehensions used to be much more general?  they were *monad* comprehensions.
19:11:21 <marcusb> conal: no, that's new to me
19:11:29 <conal> marcusb: it was beautiful!!
19:11:47 <conal> part of the dumbing down of haskell.  i think from 1.3 to 1.4.  (or was it 1.4 to 98?)
19:12:02 <marcusb> haskell has this special flare, where the language is backed by a solid theoretical framework.  as a mathematician, I can appreciate that
19:12:09 <marcusb> but as a hacker, it's not the first thing I am interested in
19:12:13 <marcusb> not even the second
19:13:05 <Zao> conal: Aren't there extensions to manlify comprehensions?
19:13:11 <conal> marcusb: graphics researchers/programmers i know are that way also.  they like math and they like programming, but they don't think of them as the same thing.
19:13:18 <edwardk> 1.4 to 98
19:13:27 <marcusb> the first thing is how to solve basic problems in programming.  how to handle data in various formats (unicode, binary)?  how to get the same support for your own types as for built in types (generic programming)?  even when not yet understanding the theory behind that
19:13:33 <conal> Zao: do you mean beyond lists?
19:13:45 <Zao> Aye.
19:13:53 <conal> Zao: not that i know of.
19:14:11 <Zao> I'm having trouble bending my head around how one of those would look though.
19:14:41 <conal> anyone else know of anything like a {-# LANGUAGE MonadComprehensions #-} pragma?
19:14:45 <marcusb> conal: I like how I can do both in haskell with quite some elegance.  I love the do notation as much as a generic map+fold over my data types.
19:15:03 <conal> Zao: check out Wadler's "Comprehending Monads" (iirc)
19:15:51 <edwardk> zao: no, no one has gone back and hacked monad comprehensions back into ghc. marlow and company indicated they'd take a patch, but the sugar module where the comprehensions are parsed is particularly ugly because it has so many efficiency hacks that only work for list comprehensions, so its hard to figure out where to start.
19:16:13 <conal> ack. :p
19:16:16 <randomity> conal: monad comprehensions aren't really any cleaner than "do", they don't visually appear to have sequencing (which is perfect for [] but bad for many monads) and they don't support ghc's parallel list comprehensions (sort of a new syntax for zip)
19:16:39 <marcusb> conal: are there experiences/studies on teaching haskell to non-programmers, and maybe even non-scientists?
19:16:48 <marcusb> I wonder how that works out
19:17:03 <marcusb> I can see it go either way :)
19:17:38 <edwardk> randomity: you can extend monad comprehensions to cover zip comprehensions you just need a notion of Zippable functor (ala Control.Functor.Zip in category-extras)
19:17:48 <IntergalacticOwl> how do you know when you're a scientist?
19:18:05 <conal> marcusb: i don't know.  my personal conviction is that pure (no IO) functional programming is inherently suited to right-directed thinkers/creatives.  and that the textual packaging obscures that suitability.  elaborated on my google tech talk on tangible functional programming.
19:18:12 <marcusb> IntergalacticOwl: I was going to write non-mathematicians, and then wanted to include engineers, etc
19:18:15 <randomity> as far as I know, dublin IT teaches Haskell to first-years. Not sure how long they keep it up
19:18:20 <randomity> edwardk: cool! must look at.
19:18:30 <Zao> conal: I was misremembering, there was a discussion a few days ago with code that at first glance looked quite non-listy.
19:18:32 <IntergalacticOwl> I thought engineers didn't consider themselves scientists.
19:18:46 <marcusb> conal: being free of side effects is definitely easier than understanding cell-based programming, I would think
19:19:00 <monochrom> Some engineers consider themselves scientists. Some know they aren't.
19:19:07 <IntergalacticOwl> haha
19:19:09 <conal> some people carve up the world into engineers, scientists, etc.  some don't.
19:19:24 <edwardk> randomity: now, there is a lack of support for the later query comprehension improvements that SPJ and Wadler put together to respond to LINQ, that would be tricky to generalize to an arbitrary monad
19:20:05 <conal> edwardk: that's why i winced at that paper.  i hate seeing monad comprehensions slip further away.
19:20:05 <edwardk> i remember i took a quick stab at it when the paper first came out and put it down as too scary at the time. Might take a crack at it again some time.
19:20:35 <randomity> would some LINQ-style magic generalise nicely over Arrows?
19:20:51 <jimmyjazz14> why are there three exponent functions in haskell?
19:21:03 <monochrom> And some people compare apples with oranges.
19:21:27 <edwardk> randomity: i'd hoped to employ the arrow calculus at some point for something like that but there appear to be enough problems with the rederived arrow calculus that i put it down and backed away slowly ;)
19:21:32 <conal> jimmyjazz14: the answer is probably in their types.
19:21:38 <conal> @type (^)
19:21:39 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:21:43 <conal> @type (^^)
19:21:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:21:47 <conal> @type (**)
19:21:48 <lambdabot> forall a. (Floating a) => a -> a -> a
19:22:15 <conal> jimmyjazz14: make sense?
19:22:25 <jimmyjazz14> mmm yeah kinda
19:22:42 <edwardk> arrow calculus as in: http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf and http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
19:22:44 <jimmyjazz14> still learning the type system
19:22:55 <conal> jimmyjazz14: it's a fancy one.  there's a lot to learn.  :)
19:23:42 <conal> jimmyjazz14: iirc, (^) raises an error for negative exponents, since the base & result are integral.
19:24:04 <randomity> edwardk: yeah, the actual semantics of the arrow calculus seem giant and complicated and confusing. I've never looked at it formally properly, but the intuitive notion of "generalisation of a function" is pretty cool, and you can do some pretty cool stuff with it (signal-processing-style chains of functions or erlang-style communications)
19:24:11 <gwern> if only we had Nat!
19:24:38 <randomity> then (-) would break on many inputs. Is this better?
19:24:57 <jimmyjazz14> I find the number types to be more confusing
19:24:57 <gwern> nah, - just defaults to 0 with Nats
19:25:16 <gwern> better than _|_ lurking in half the basic numerical functions
19:25:19 <randomity> gwern: you're joking. Really?
19:25:36 <randomity> so (a - b) + b is something totally random?
19:25:48 <gwern> randomity: no, that's the usual proposal for Nats. 5-10=0
19:25:58 <conal> "monus"
19:26:07 <jimmyjazz14> conal: know of any good guides on easing one into the type system
19:26:17 <jimmyjazz14> specifically numeric types
19:26:30 <conal> jimmyjazz14: hm.  not offhand.  anyone else?
19:27:03 <randomity> gentle introduction to haskell has a decent type system section
19:27:05 <conal> jimmyjazz14 have you read "a gentle introduction to haskell" (hudak, peterson, fasel)?
19:27:08 <conal> :)
19:27:10 <randomity> :D
19:27:16 <jimmyjazz14> no I havn't
19:27:22 <jimmyjazz14> I will check it out
19:27:28 <edwardk> randomity: i was originally trying to see if i could define a simple enough base language that it could for the most part 'compile' to the arrow calculus, to see if i could make a nice language with 'programmable application', with the arrow apply rules its equivalent to a monadic language but without the separate syntax barrier we have.
19:27:34 <conal> it was my first exposure to haskell.  i loved it.  ymmv.
19:27:49 <jimmyjazz14> I'm currently reading Real World Haskell
19:27:55 <randomity> although when I was first learning haskell, I had to flick through that chapter initially and read the rest, then go back to it. It all makes wonderful sense eventually, and then you wonder what was so difficult at the start
19:28:31 <jimmyjazz14> I like it although I find it goes a little quick at points (or perhaps needs a few rereadings)
19:28:55 <randomity> edwardk: yeah, I was toying with that notion as well. I think a version of haskell where \ wasn't just lambda but was polymorphic over all arrow types would be kinda cool
19:29:16 <randomity> but learning it would be even less possible than learning haskell currently :D
19:29:40 <randomity> jimmyjazz14: yeah, it's great but the title's inaccurate.
19:30:30 <jeff_s_> Zao - just saw your message from 10 minutes ago, thanks
19:30:32 <edwardk> randomity: one thing to note: you need some extra magic for pattern matching constructors and case analysis, so getting a full haskell into it'd be a lot of work.
19:31:02 <randomity> I think that can be done if the arrow in question is an ArrowChoice
19:31:23 <conal> hm.  my C-is-functional post is now at 117 (216-99) on reddit.  i usually score *much* closer to 0.
19:31:39 <randomity> you'd have to have this weird operation of reducing datatypes down to pairs and Eithers (prod + sum), but I think it could be done
19:31:43 <copumpkin> sensational titles always work wonders on reddit
19:31:59 * copumpkin knows all about marketing!
19:32:02 <jimmyjazz14> I feel like there should be a shorter (simpler) version of Real World Haskell as a first step intro
19:32:16 <copumpkin> omg it's edwardk
19:32:41 <copumpkin> edwardk: do you have a working parallel CFL parser somewhere deep in your monoids?
19:33:03 <conal> copumpkin: rather a personal question, don't you think?
19:33:08 <copumpkin> lol
19:34:52 <randomity> conal: that looks awesome (the functional-c page)
19:35:18 <randomity> actually, I think the C++ template system is purely-functional and duck-typed
19:35:27 <edwardk> copumpkin: still working on it
19:35:38 <conal> randomity: thx :)
19:35:42 <edwardk> copumpkin: work picked up a bit for a week or so, hence why i've been scarce lately
19:36:01 <edwardk> but now things are slow again, so i'm free to resume working on parsimony =)
19:36:40 <edwardk> copumpkin: started adding some nice monoidal statistical accumulators though, i'll be pushing those up to hackage pretty soon.
19:36:57 <edwardk> i.e. for computing mean, stddev, variance, kurtosis, skewness, etc. in parallel
19:37:26 <copumpkin> edwardk: :o
19:37:29 <copumpkin> nice
19:37:39 <copumpkin> how about median ;)
19:38:19 <copumpkin> (just kidding)
19:38:22 <edwardk> i don't currently have a parallel median calculator =)
19:40:22 <edwardk> there should be some monoidal encoding of kth item selection though.
19:40:35 <edwardk> since there are decent parallel algorithms for it
19:43:02 <dmwit> jimmyjazz14: You might also like Learn You a Haskell.
19:43:04 <dmwit> ?where LYAH
19:43:04 <lambdabot> www.learnyouahaskell.com
19:43:12 <Cale> edwardk: What counts as a monoidal encoding here?
19:43:19 <edwardk> hrmm, anyone here familiar with "monoid comprehensions?" ala the monoid comphrension calculus
19:44:02 <edwardk> cale: well, what i'd be looking for is an efficient way to parse part of the string and another part of the string and join the intermediate results together.
19:46:01 <edwardk> cale: in the parlance of my 'monoids' library, an "a `Reducer` m" -- is a Monoid m, with unit :: a -> m -- i.e. Num a => a `Reducer` Sum a where unit = Sum
19:47:01 <edwardk> cale: you can in general encode any fold as a reducer like that but its not all that interesting unless you can shrink the size of the intermediate result to be smaller than a tree involving the entire input string
19:47:28 <edwardk> so some notion of progress is usually essential to encoding something as a useful Reducer.
19:50:32 <Cale> Curious, I just realised that the bittorrent tracker for the anime I'm downloading is apparently edwardk.info
19:50:34 <edwardk> in practice i let a Reducer also define an efficient 'cons' and 'snoc' for prepending a value or appending a value to an already reduced result, because that is often a lot more efficient than the general monoidal operation, and then let different containers use those as they see fit
19:50:46 <copumpkin> :o
19:51:03 <edwardk> haha, not me though.
19:51:55 <Chicao> anyone familiar with qtHaskell?
19:52:13 <Cale> I'm only familiar in the sense that I've heard of it.
19:53:29 <Chicao> Thanks Cale
19:53:37 <MonadBaastad> Wow... I read some of that Scala thread, and...the ignorance is scary.
19:53:41 <Cale> Chicao: What did you need to know about it?
19:53:51 <copumpkin> MonadBaastad: what thread is that?
19:54:08 <rovar> MonadBaastad: I'm happy as long as all of those java coders aren't coding in java anymore.
19:54:17 <Chicao> To tell you the truth
19:54:34 <Chicao> i'm trying to learn it right now
19:54:51 <MonadBaastad> copumpkin: http://www.reddit.com/r/programming/comments/8krbo/erlang_is_not_functional_response_to_scala_is_not/
19:54:59 <Chicao> but i cant install in my computer
19:55:03 <Chicao> got some errors
19:55:22 <MonadBaastad> Hmm, so I guess I should call it "that Eralng response to that Scala thread"... ;p
19:56:25 <rovar> how about we call them both imperative language so that all of those people afraid of functional languages will use them
19:56:29 <rovar> then eventually see the light
19:56:37 <rovar> to be honest. I came to Haskell by way of Erlang
19:56:58 <SamB> Erlang *is* an imperative language, isn't it?
19:57:02 <rovar> my preconception of functional programming was "it's cool, but not useful for real world stuff"
19:57:15 <SamB> it doesn't have an imperative abstraction like Haskell does ...
19:57:21 <rovar> erlang is an expression based language and supports tail recursion
19:57:24 <SamB> but then neither does any other imperative language I've ever used ;-P
19:57:43 <MonadBaastad> rovar: I think a better idea is to shoot 'em over to conal's blog post, so they can learn how "C programming" is really functional... 8D
19:57:48 <SamB> oh, but I call CL and Scheme and Emacs Lisp imperative too
19:57:49 <rovar> but you're right.. it's imperative.
19:58:02 <edwardk> erlang is functional, its strict and has some baked in message passing bits, bit i can't really bash its overall functionalness
19:58:13 <rovar> MonadBaastad: which is that?
19:58:18 <dmwit> Hoogle has no result for "sleep"!
19:58:28 <rovar> and it's dynamically typed,, which annoys the crap out of me
19:58:34 <rovar> one reason i switched to haskell
19:58:41 <MonadBaastad> rovar: http://conal.net/blog/posts/the-c-language-is-purely-functional/
19:59:17 <rovar> "Modulo some minor historical accidents."  hahaha
20:00:00 <MonadBaastad> conal++
20:00:08 <dmwit> Oh, it's called threadDelay.
20:00:11 <dmwit> hokay
20:00:13 <MonadBaastad> (If only for the lulz factor. ;)
20:00:17 <Gracenotes> I like the use of "modulo" in non-mathematical sense
20:00:18 <conal> MonadBaastad: :) thx.
20:00:40 <Gracenotes> it's certainly acquired a life of its own. the phrase. sort of.
20:01:10 <rovar> hahha
20:01:14 <rovar> that is brilliant
20:01:30 <edwardk> gracenotes: my coworkers sometimes look at me funny for using 'modulo', 'without loss of generality' and 'orthogonal' as just every day vocabulary.
20:01:34 <MonadBaastad> conal: Thank you! I always find your posts informative and entertaining - and it's surprising at times which one is more the one than the other. ;)
20:01:52 <Gracenotes> edwardk: hah! Surely all human beings speak like this???
20:02:38 <edwardk> Gracenotes: it has been called to my attention that not all humans understand these things. I have since endeavored to succeed in either enlightening them, or narrowing my social circle ;)
20:03:17 <Gracenotes> i am truley sorry for your lots
20:03:31 * copumpkin facepalms
20:03:58 <monochrom> Haskell is the finest imperative language on Earth. That's what SPJ says.
20:04:20 <rovar> edwardk: I use orthogonal quite a bit, I also use asymptote in a non mathematical sense, which really effs with people.
20:04:30 <monochrom> I propose to add it to whatever "about haskell" page or blurb on the haskell wiki.
20:04:38 <Gracenotes> yes, math has proved to be a fertile cornucopia of vocabulary words
20:04:47 <Gracenotes> if nothing else
20:04:58 <rovar> surely it has some other redeeming qualities
20:05:01 <copumpkin> without loss of generality, we can speak of non-mathematical concepts with mathematical terminology
20:05:12 <monochrom> "simple group" is the best math name of all. :)
20:05:33 <Gracenotes> it could also be used to describe people who don't understand math terminology
20:05:39 <rovar> hehe
20:05:45 <Gracenotes> </elitist>
20:05:49 <monochrom> You should also begin inflicting law words such as "hitherto" to your coworkers.
20:05:53 <randomity> or to make bad puns about a finite group of mathematicians standing in a ring
20:05:54 <dmwit> So, uh, how do laziness and MVars interact?
20:06:20 <randomity> simply enough, MVars are in the IO monad where laziness doesn't really exist
20:06:20 <rovar> randomity: if they're standing in a ring they would have to be a finite group, yes?
20:06:25 <dmwit> If I write a complicated computation into an MVar, and another thread takes that MVar, who's responsible for the expensive calculation and when did it happen?
20:06:27 <Gracenotes> an MVar is like holding a reference... reading it is an operation that can be sequenced in IO
20:06:39 <Gracenotes> oh, I see
20:06:55 <edwardk> rovar: that and 'carrying capacity of a population,' 'kth weighted central moment', 'right Kan extension', 'comonad,' 'zygohistomorphic prepromorphism' or any 'free' construction that doesn't involve free food or free beer seem to zip right past most of these strange people.
20:07:05 <monochrom> "without loss of generality, hitherto thereof we assume x>=0"
20:07:05 <randomity> oh, ok. AFAIK, it's stored as a thunk in the Mvar so the receiving thread evaluates it
20:07:20 <Gracenotes> I'd imagine you could put an infinite list in an MVar
20:07:30 <Gracenotes> or an undefined
20:07:36 <edwardk> Gracenotes: yeah
20:07:44 <dmwit> Doesn't this sort of negate the usefulness of multiple threads?
20:07:58 <dmwit> Maybe I should ask a different question.
20:07:59 <rovar> edwardk: how could you possibly use the lot of those nonmathematically?
20:08:09 <monochrom> No, the receiving thread may just give the thunk to someone else.
20:08:20 <dmwit> If I want a responsive UI thread and a complicated computation thread, how should I ensure that the complicated computation is not being done in the UI thread?
20:08:28 <edwardk> rovar: well, everything is a Kan extension ;)
20:08:30 <randomity> most of the cool stuff from mvars doesn't come from sharing cpu across threads, but from writing sequential-looking code which overlaps
20:08:42 <Saizan> dmwit: you can seq or rnf the value before you put it in the MVar
20:09:12 <dmwit> Okay, as long as that's considered best practice, I'm fine with doing that.
20:09:21 <Gracenotes> seq is a bit weaker than rnf
20:09:34 <edwardk> rovar: and i had a use for using weighted moments around the origin in a business capacity when writing an MDX query the other day ;)
20:09:35 <Saizan> well, it depends on the structure of the value
20:09:38 <randomity> haskell isn't widely enough used to have a considered best practice :P
20:09:39 <Gracenotes> but you do need a typeclass for rnf, which in most cases is simple to implement
20:09:56 <monochrom> Heh, I store a thunk into an MVar, then I seq it, what happens? :)
20:09:59 <dmwit> Yep, I understand the tradeoffs between rnf and seq.
20:10:17 <kniu> Guys, I just had a crazy idea.
20:10:27 <Saizan> monochrom: you get a pony
20:10:43 <edwardk> monochrom: it gets put in the mvar, then you start evaluating it, if someone else grabs it they may or may not see it before your blackhole marks it depending on how eager the blackholing is that day
20:10:51 <rovar> edwardk: must have been a hulluva query
20:10:54 <kniu> I was reading trough SICP again, and came upon the bit about the separation of implementation from interface.
20:10:54 <edwardk> so they may start evaluating it too
20:11:24 <kniu> It is common knowledge that many data structures can be implemented with function closures.
20:11:39 <edwardk> rovar: hah, well, 5 pages of proof to justify 3 lines of MDX ;) but its shiny and fast and it does the job
20:11:51 <monochrom> Interesting.
20:12:01 <kniu> Can you instance a function type with a class?
20:12:04 <Gracenotes> kniu: well... more difficult with static types. But definitely
20:12:04 <edwardk> kniu: s/many/any/ =)
20:12:20 <kniu> If so, then why have types at all, right?
20:12:35 <kniu> just create functions for every implementation, and have the classes represent types.
20:12:36 <rovar> edwardk: I've always looked for excuses to do multidimensional analysis on data, but my hatred for RDBMS's has kept me away
20:12:37 <edwardk> kniu: convenience
20:13:04 <randomity> rovar: the RDBMS model is actually really nice. SQL is hideous.
20:13:10 <kniu> So convenience is the only reason?
20:13:21 <Gracenotes> implementing data structures with closures isn't so important that it's worth a trade-off with your entire type system
20:13:35 <Gracenotes> imho anyway.
20:13:59 <rovar> i agree.
20:13:59 <Gracenotes> and quite tricky to optimize.
20:14:18 <rovar> i actually went too far in that direction and started coding in Timber
20:14:32 <kniu> hm
20:14:57 <edwardk> i dunno. i find newtype Tree a = Tree {  viewTree :: forall o. (Tree a -> a -> Tree a -> o) -> o -> o } -- to be an amusing encoding of a binary tree ;)
20:15:10 <jimmyjazz14> how similar is Haskell to Erlang?
20:15:44 * Saizan doesn't see why that's hard with static types
20:15:52 <edwardk> if only because if you swap the a and the first Tree a, that its in the style of.. you guessed it, a right Kan extension. ;)
20:15:54 <rovar> jimmyjazz14:  Haskell is a superset of erlang. Modulo the nasty bits such as dynamic typing
20:15:54 <Gracenotes> edwardk: cute... hm...
20:15:56 <Saizan> unless you hate the newtype constructor so much
20:16:09 <randomity> they're pretty different at first. With some of Haskell's newer libraries, you can get a lot of the erlang-style communication stuff
20:16:15 <Gracenotes> edwardk: what does the second parameter o represent?
20:16:21 <randomity> and erlang's recently got working functional programming
20:16:27 <rovar> and more importantly.. you can get sub-thread scheduling via forkIO
20:16:38 <MyCatVerbs> jimmyjazz14: they're both functional. Haskell is statically typed, Erlang dynamically. They have rather different concurrency models. Concurrent Haskell is designed for SMP machines, whereas Erlang's concurrency is all message passing.
20:16:50 <randomity> the main differences now are haskell having a truly awesome type system, and erlang having truly awesome clustering and failover abilities
20:17:02 <rovar> oh.. and RPC
20:17:20 <rovar> being the foundation of erlangs awesome clustering distributed blah blah
20:17:21 <edwardk> Gracenotes: (a -> Tree a -> Tree a -> o) -- is the result from handling a Bin node and the next argument 'o' -- is the result for handling a Tip.
20:17:28 <randomity> and erlang's live code updating (rewrite your app with no downtime) is amazing
20:17:39 <rovar> there was a haskell project for that
20:17:41 <Gracenotes> edwark: ah, so all Tips are handled the same way?
20:17:43 <edwardk> the forall encodes the fact that you can extract any result type from viewing it
20:17:45 <rovar> it appears to have been abandoned
20:17:49 <amz> hrm, easiest way to apply "f" to "x" n times?
20:17:52 <jimmyjazz14> so I am learning haskell but need to know erlang (for work and such) will learning Haskell a good path to  having to work with Erlang in the future?
20:17:54 <edwardk> no, thats why you need the universal quantification.
20:17:54 <Gracenotes> hm. I suppose this make sense if Tip doesn't carry anything
20:18:00 <edwardk> to 'case' off it you hand it two values.
20:18:06 <randomity> of course, haskellers have such a cool type system that their code is proven correct by the compiler, so they don't need live code updating as there are no bugs :P
20:18:08 <rovar> jimmyjazz14: yes
20:18:08 <dmwit> amz: foldr (.) id (replicate n f) x
20:18:08 <Gracenotes> hm...
20:18:19 <SamB> randomity: yeah right
20:18:21 <dmwit> amz: or maybe
20:18:23 <randomity> hehehe
20:18:24 <amz> dmwit: I mean as in f $ f $ f $ ... x
20:18:30 <dmwit> amz: So do I.
20:18:35 <amz> oh
20:18:36 <amz> oh, I see, .
20:18:41 <Gracenotes> edwardk: so how could you represent the typical Branch Tip 10 (Branch Tip 20 Tip) in your scheme?
20:18:46 <dmwit> :t foldr
20:18:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:18:50 <SamB> randomity: you're thinking of Agda, maybe, where your programs are proven *both* correct *and* incorrect by the compiler
20:18:50 <amz> I'm trying this with a recursive function and it's stack overflowing on me
20:18:52 <dmwit> :t ($)
20:18:53 <lambdabot> forall a b. (a -> b) -> a -> b
20:18:54 <randomity> jimmyjazz14: there are significant differences, but they're both a lot closer to each other than either is to, say, Java
20:18:59 <amz> doSteps ls 0 = ls
20:18:59 <amz> doSteps ls n = doSteps (map (\x -> step x 1.5) ls) (n-1)
20:19:01 <dmwit> :t foldl
20:19:02 <rovar> randomity: there is a lot of truth to that..  subtracting the huge potential for space leaks, I would trust haskell for a large project over any other language
20:19:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:19:30 <edwardk> lookup b t = getTree t (\a l r -> case compare a b of LT -> lookup b l; EQ -> Just a; GT ->  ...) Nothing
20:19:34 <dmwit> :t foldr ($)
20:19:35 <lambdabot> forall b. b -> [b -> b] -> b
20:19:40 <rovar> but we've had space leaks in c++ that caused our production system to crash after 2 months of running
20:19:41 <randomity> it's the first language I've used where I've felt the compiler was actually on my side (unlike, say, Python where the compiler doesn't seem to exist, or C++ where it's actively working against you)
20:19:59 <copumpkin> is it just me or has a really trollish user showed up on the haskell subreddit recently, called grauenwolf? :P
20:20:01 <dmwit> amz: foldr ($) x (replicate n f) -- could also work
20:20:06 <kniu> really?
20:20:07 <rovar> randomity: that's the fault of c++ idioms
20:20:10 <rovar> idioms of idiots
20:20:11 <kniu> Sometimes, I think GHC hates me.
20:20:16 <dmwit> copumpkin: He's been around a while.
20:20:18 <rovar> kniu: it's firm, but fair
20:20:19 <SamB> randomity: yeah, in C++ it seems like the point of the compiler is to insert lots of code that I didn't write, most of which exists mostly to cause unexpected segfaults ...
20:20:26 <randomity> nah, it's the fault of the C++ "type system".
20:20:30 <Gracenotes> edwardk: hm. So you do you get the tree in the first place? Seems a bit.. making-something-out-of-nothing-ish :)
20:20:33 <edwardk> Gracenotes: just define two combinators branch a l r = Tree (\k _ -> k a l r); tip = Tree (\_ t -> t)
20:20:40 <copumpkin> dmwit: ah, I guess I only just had the pleasure of reading his comments
20:20:48 <kniu> The error messages are so cryptic, it's like a chick playing hard-to-get.
20:20:56 <erikc`> it's the fault of c++ users secretly wanting a good language and trying to build language features out of popsicle sticks and glue
20:20:56 <MyCatVerbs> edwardk: is that a continuation-passing binary tree? :)
20:20:59 <edwardk> gracenotes and then use them as smart constructors
20:21:01 <Gracenotes> ah. continuation style....
20:21:02 <edwardk> mycatverbs: yeah
20:21:09 <rovar> the full c++ type system is pretty awesome.. if people would use it.. but people don't because it involves a crapload of <>'s and pure functional, type based programming
20:21:17 <jbhatta> hmmmmmmmmm, anybody know a good algorithm for finding the median of a list of Ords?
20:21:20 <SamB> kniu: which ones ?
20:21:34 <randomity> templates take type parameters which are typechecked by "whether or not they support this set of named operations", and pass them onto more templates, and so on until you get a giant backtrace of why substitution failed with one type error covering pages of useless output
20:21:50 <SamB> randomity: not even that, really
20:21:50 <edwardk> nicely you can make up new constructors for building 'flattened' trees, etc. and the api doesn't change ;)
20:21:52 <rovar> that output can be fixed
20:21:53 <kniu> since I'm not really working on anything right now, there are none that I can name off the top of my head.
20:22:06 <MyCatVerbs> edwardk: Why? Were you struck by a sudden urge to use Church-style data structures instead of the usual pattern matching on constructors malarkey?
20:22:13 <SamB> I wish I could declare even that much typing about template parameters ...
20:22:32 <edwardk> MyCatVerbs: someone above mentioned you can replace many data types with functions, and i replied s/many/any
20:22:40 <edwardk> and someone asked about trees or something like that
20:22:41 <monochrom> generic programming without theorem proving is really strange
20:22:42 <amz> dmwit: both are still giving me a stack overflow :(
20:22:43 <kniu> That's me.
20:22:45 <randomity> it's more the duck typing of the templates that annoys me. Even in java I can say that I don't just want a T, I want a "T extends SomeInterface". In C++ you can't specify what type you want, the compiler just keeps bashing until enough substs fail
20:22:45 <amz> even forcing strictness
20:22:59 <SamB> randomity: that's just what I mean
20:23:00 <monochrom> hell, aspect-oriented programming without theorem proving is strange too
20:23:05 <rovar> read chapter 3  c++ metaprogramming  it makes an incredibly powerful statement about the strength of the c++ type system
20:23:07 <dmwit> amz: There's also iterate f x !! n
20:23:10 <MyCatVerbs> edwardk: sooo... "because I can", then. Don't get me wrong, I personally believe that to be an excellent reason. :)
20:23:15 <dmwit> amz: Which is probably the first thing I should have thought of. =P
20:23:16 <randomity> monochrom: aspect-oriented programming is strange all by itself
20:23:37 <rovar> the problem is the strong type system that you produce takes a crapload of code to get there. whereas haskell's is there from the start
20:23:40 <dmwit> amz: If you're using sizes of 'n' big enough to give stack overflow, than may I suggest using something more sophisticated?
20:23:43 <randomity> rovar: is this turing completeness? that's doesn't make it powerful. Brainfuck is not powerful.
20:23:45 <Gracenotes> edwardk: and newtype List a = List (forall o. (a -> List a -> o) -> o -> o), sumList (List xs) = xs (\y ys -> y + sumList ys) 0
20:23:53 <amz> dmwit: I'm accepting suggestions :)
20:23:56 <dmwit> amz: Is f associative?  If so, something similar to repeated squaring might be nice.
20:23:57 <copumpkin> > (thrice thrice) (+1) $ 4
20:23:57 <edwardk> MyCatVerbs: i have other reasons that i've been exploring, mostly to do with fooling the unpacker
20:23:59 <lambdabot>   31
20:24:21 <rovar> randomity: no.. not at all.. it creates a system whereby you can annotate values with units to ensure that they can be operated on.. i.e.
20:24:23 <copumpkin> > iterate thrice (+1) $ 0
20:24:24 <edwardk> Gracenotes: yeah thats a list monad as a right kan extension.
20:24:24 <randomity> it's just soooo much work to define a parametrised type in C++. I need a separate template <typename T> on every single function!
20:24:25 <lambdabot>   Couldn't match expected type `a -> b'
20:24:29 <amz> dmwit: no, it's a map that applies a "step" function to a list of objects, that return their next "step" (think of a bunch of objects in a simulation advancing in time)
20:24:41 <rovar> you create  3.5 mass and  2 velocity.
20:24:43 <Gracenotes> edwardk: category theory! noooooo :P
20:24:49 <edwardk> Gracenotes: =)
20:24:52 <MyCatVerbs> edwardk: that sounds innnteresting. More a topic for #-in-depth than here though, perhaps?
20:24:56 <erikc`> rovar: f# has that and it doesnt suck in f# :)
20:24:56 <rovar> you can't add them because they're not compatible.. but you can multiply them
20:24:58 <randomity> rovar: oh, yeah, seen some of those. They're really nice, but they take sooooo much code to implement
20:25:02 <randomity> the interface is beautiful though
20:25:03 <SamB> rovar: but then it probably takes two pages of code to write what should take 1 line
20:25:08 <edwardk> mycatverbs: perhaps
20:25:14 <randomity> there were a couple proposed for Boost, not sure if any ever got in
20:25:14 <rovar> randomity, SamB: that's my point
20:25:31 <copumpkin> > iterate thrice (+1) <*> [0]
20:25:33 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,* Exception: stack overflow
20:25:44 <SamB> 99% of which is about types which you shouldn't even need to mention
20:25:53 <rovar> my point is that it is possible..  the c++ type system can be great, but man is it a harsh mistress.
20:25:53 <edwardk> hrmm
20:26:12 <erikc`> without gc and type inferencing, it's a chore
20:26:23 <rovar> and it's rather ironic that it order to utilize c
20:26:32 <rovar> ++ to its fullest, you need to know functional programming
20:26:40 <edwardk> actually those fail to be right kan extensions
20:26:45 <edwardk> just noticed that
20:26:45 <randomity> ok, granted. Using C++, you can make a gorgeous interface to your types. I consider implementation simplicity just as important as interface simplicity though (I realise others don't) and I find it's rarely worth the internal ugliness of a nice C++ interface
20:26:45 <rovar> hah
20:26:56 <dmwit> amz: And iterate is giving stack overflow?  If so, you're not doing enough forcing.
20:27:15 <amz> this is my code:
20:27:16 <amz> doSteps' x n = iterate f x !! n
20:27:16 <amz> 	where f x = map (\y -> step y 1.5) x
20:27:16 <MyCatVerbs> rovar: I found C++ template programming to be a great introduction to Haskell.
20:27:27 <amz> I removed the seqs now
20:27:31 <rovar> my friend describes c++ as coffee..   a lot of people drink coffee..it has a lot of redeeming qualities.. but the huge majority have to do crazy things to their coffee to make it halfway palletable
20:27:33 <SamB> except of course that Haskell has types other than int
20:27:35 <rovar> pallatable?
20:27:37 <SamB> right?
20:28:35 <randomity> rovar: I like black coffee :D
20:28:46 <amz> I think that the problem might be with my "step" function, since my definition is recursive and very bizarre
20:28:51 <amz> I couldn't figure out a better way to do it
20:29:11 <Saizan> @hpaste
20:29:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:29:14 <Saizan> amz ^^^
20:29:17 <MyCatVerbs> rovar: once you've managed to get some not-completely-trivial computation to run in the template instantiation, switching to Haskell (where, by Church, you suddenly have actual features to play with!) feels like an enormous relief, and not any harder at all. :)
20:29:26 <rovar> randomity: I take milk in mine, and I code in c++ for a living, and have maintained my sanity with the help of boost
20:29:43 <MyCatVerbs> SamB: yes, Haskell has types other than int. That's a bloody good start. :)
20:29:47 <amz> ok, hold on
20:30:15 <amz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5090#a5090
20:30:30 <randomity> boost is amazing. It really shouldn't exist. So many really smart people have wasted so much thought designing and implementing amazing code when they could have just been popularising a better language (where the amazing feats they wished to perform were trivial)
20:30:34 <amz> the idea is that I want a list of "entities", where each entity has a different behavior
20:30:39 <amz> so they have different implementations of "step"
20:30:44 <rovar> MyCatVerbs: I agree in general. I have been coding in c++ for 10 years and still can't get code to compile (much less run) on the 1st try.
20:30:44 <amz> that move themselves to the next step
20:30:59 <amz> they happen to both store a float, but that isn't really necessary, e.g. one could be storing a string
20:31:05 <amz> [in fact, I should have done something like that]
20:31:08 <rovar> in haskell.. it takes me some time to compile.. but once it does.. i don't even need to test it.. it just works
20:31:09 <randomity> but still, boost is really, really good
20:31:23 <amz> rovar: same here :)
20:31:25 <rovar> randomity: yea.. a lot of smart people wasted a lot of effort on that :)
20:31:32 <copumpkin> as good as possible given the shitty language it's implemented in
20:31:47 <MyCatVerbs> rovar: just wait until you discover the (fix) combinator. We'll soon cure you of that little old "if it compiles, it probably works" idea. ;)
20:31:54 <randomity> hehehe
20:32:02 <rovar> boost.spirit.phoenix is effing *awesome*  because it makes c++ functional :)
20:32:03 <erikc`> randomity: amen, and a whole lot of compiler developers could have focused on things other than their frontends being accidental virtual machines
20:32:10 <rovar> but boy is there a lot of crap in there
20:32:26 <randomity> if it compiles in haskell, it won't produce the wrong answer. Divergence is possible.
20:32:41 <SamB> randomity: unless it expresses the wrong question!
20:32:46 <MonadBaastad> randomity: So, Boost is like having a crutch with a built-in rocket pack? ;p
20:32:48 <copumpkin> > let addOne = (+1) in addOne 4
20:32:49 <rovar> MyCatVerbs:  so I just pass all of my functions in to "fix" and they're magically not broken+
20:32:50 <lambdabot>   5
20:32:54 <copumpkin> > let addOne = (+3) in addOne 4
20:32:56 <randomity> MonadBaastad: :D :D :D oh yes.
20:32:56 <lambdabot>   7
20:33:00 <MyCatVerbs> rovar: quite the opposite, actually. :)
20:33:17 <SamB> MonadBaastad: as in, you'll probably end up as a stain on the side of a cliff somewhere ?
20:33:23 <MyCatVerbs> randomity: erk! atan2 won't magically catch your mistake if you pass it x and y backwards, causing all your angles to be calculated wrong. For example.
20:33:58 <rovar> i worked on D for a while.. was very involved in working on the std libs.. again i put lots of effort into making the language into something it wasn't..  one day I gave up.. a month later I downloaded ghc
20:34:25 <randomity> yeah, true. I'm just comparing my <notHaskell> code to my Haskell code. It seems difficult to write valid incorrect haskell code by accident, at least compared to other languages
20:34:39 <SamB> randomity: well, yeah
20:34:46 <SamB> compared to other languages
20:34:48 <monochrom> Haha that's a great real story. "I was trying to design a sensible language... then I downloaded ghc."
20:35:06 <SamB> at least you *probably* don't have a type error if your Haskell code all compiled ...
20:35:13 <amz> Haskell looks so beautiful, I just can't figure how to do such simple stuff in it ;)
20:35:22 <gwern> @remember monochrom I was trying to design a sensible language... then I downloaded ghc.
20:35:22 <lambdabot> It is forever etched in my memory.
20:35:25 <gwern> @flush
20:35:29 <randomity> rovar: I never really got into D, it always seemed like it was suffering from the same disease C++ has. It seems to cherry-pick useful features from languages where they work well, without realising that usefullness does not combine additively
20:35:31 <amz> I wonder if I'm even doing this the right way
20:36:03 <jeffwheeler> amz: Haskell just takes practice and play
20:36:05 <gwern> if it isn't a one-liner involving folds, ur doing it rong
20:36:07 <SamB> randomity: in what sense does C++ do that ?
20:36:18 <rovar> randomity: there was a laundry list of beefs with c++ which were very valid (mostly made by the boost contributors)  D fixed those problems.. and made the syntax a little friendlier
20:37:22 <randomity> yeah, and C++ was made by a going through a laundry list of features to add to C. I think at some point you have to redesign.
20:37:22 <amz> haven't tried C#, but it looks pretty cool, except for the poor cross-platform support
20:37:22 <Cale> Does D have proper functions?
20:37:22 <gwern> amz: yeah, I think you're doing some of it wrong. like, I don't see the point of doDraw
20:37:22 <rovar> but yea.. haskell has this grasp on the most fundamental constructs which make coding in any paradigm seem natural
20:37:30 <amz> gwern: This is a design test... different objects could hypothetically have different "draws"
20:37:34 <gwern> amz: eg. I don't see why you couldn't derive Show
20:37:37 <amz> I should rewrite this a bit to make the purpose clearer
20:37:41 <amz> hold on
20:37:41 <rovar> amz:  D is basically a natively compiled c#
20:37:54 <gwern> amz: but isn't like, the perfect usecase for typeclasses?
20:38:14 <SamB> rovar: wouldn't it make more sense to ... just compile C# natively ?
20:38:20 <SamB> or better, just use C# ?
20:38:37 <amz> typeclasses wouldn't work here, I need multiple different behaviors in the same list
20:38:50 <rovar> Cale: D1 offers delegates, which keep their stack around so that they can be passed to other functions.. in D2, that stack is created on the heap, so that those delegates can be returned from functions
20:39:10 <jmcarthur> Cale: by proper do you mean pure?
20:39:15 <SamB> rovar: okay, that's a nice feature ;-)
20:39:18 <randomity> by the way, what time is it for you all? I'm in Ireland, and it's 4.30 am. I intend to get up tomorrow, I know I'll be cursing #haskell...
20:39:19 <Cale> jmcarthur: I mean first-class.
20:39:23 <jmcarthur> ah
20:39:23 <SamB> GNU C has the former but not the latter
20:39:26 <Cale> Pure would be even better.
20:39:46 <gwern> randomity: pushing midnight here
20:39:56 <jmcarthur> you *can* make first class functions, but they are really just sugar for objects
20:40:02 <Cale> rovar: Is the syntax for it nice, or something awkward?
20:40:18 <SamB> randomity: apparantly I live in the same place as gwern ...
20:40:18 <gwern> randomity: my fix for that sort of thing is to take a big dose of melatonin. it'll crush my mind into sleepiness so I can't help but go to bed
20:40:24 <jmcarthur> Cale: actually, D seems to encourage purity a lot more than other imperative languages do
20:40:34 <gwern> SamB: scary!
20:40:48 <SamB> well, I mean, time-zone-wise
20:40:51 <gwern> jmcarthur: indeed. doesn't it have keywords so you can tell the compiler when you are being pure?
20:41:04 <jmcarthur> Cale: the delegate syntax is not anywhere near as nice as a simple lambda
20:41:11 <SamB> gwern: another GNU C feature ...
20:41:11 <jmcarthur> gwern: among other things
20:41:20 <randomity> GNU C has an odd sort of first-class function. You can create nested functions, and you can pass them down and pass them up if they don't close over locals (basically, that which is trivial with stack frames)
20:41:25 <SamB> except GNU C doesn't actually have the keywords ...
20:41:47 <gwern> wonder what sort of C haskellers produce
20:41:47 <randomity> gwern: oh, I'll have no problem sleeping. I'm half dead at the moment. It's just the strain of stopping irc...
20:41:51 <jmcarthur> gwern: from what i've seen, it is typical to design data structures to be copy-on-write in D
20:42:07 <SamB> yeah, but GNU C's nested functions don't get much use, since you never know when you're going to need a real closure ...
20:42:07 * gwern wonders whether haskell data structures are COW
20:42:27 <rovar> actually... D's strings are immutable.. and are absolutely spot-on
20:42:30 <gwern> wait, we don't really 'write'... hm. I guess the analogue would be sharing structure
20:42:34 <randomity> well, there's no W, so COW doesn't make much sense
20:42:43 <rovar> not only safer, but much more efficient than c++ or c style strings
20:42:49 <jmcarthur> our "write" is "construct"
20:42:56 <randomity> and sharing structure is common and usually explicit (x:z and y:z share a tail)
20:42:56 <SamB> rovar: that's the same way Python does strings ;-)
20:43:04 <jmcarthur> rovar: yeah, D gets strings nearly perfectly right
20:43:32 <SamB> it's, like, one of 5 things python does totally right
20:43:38 <gwern> is there any writeup on how d strings are so awesome?
20:43:42 * SamB doesn't have a clue what the other 4 are
20:43:45 <rovar> if python were statically typed, i'd rather like it
20:43:52 <randomity> rovar: there's a nice feature like that in Lua. Strings are immutable, and have a precomputed hashcode. Since the main operation is looking up a string (e.g. variable name) in a hashtable (e.g. local variable symbol table), it makes it really fast
20:43:59 <SamB> rovar: that's a wierd thought
20:44:20 <Saizan> amz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5090#a5091
20:44:21 <rovar> with some hindley milner type inferencing.. it could be done
20:44:37 <rovar> and the syntax could remain unchanged
20:44:44 <gwern> I could swear I saw python type inference in haskell once...
20:44:44 <Cale> I don't understand why a language would bother to distinguish things in this funny way that D seems to have chosen with 'delegates' and 'functions'
20:44:45 <Associat0r> boo
20:44:49 <randomity> not really... loads of Python code relies on special names as interfaces
20:44:56 <Cale> Associat0r: hello
20:45:07 <jmcarthur> Cale: it is actually (frustratingly) common in OO languages
20:45:07 <Associat0r> I mean Boo Languge
20:45:13 <randomity> like "this function takes an object supporting these three names"
20:45:23 <SamB> seems like you'd eliminate the entire point of using Python by doing HM-style type inference ...
20:45:40 <rovar> boo is cool
20:45:46 <rovar> i wish it weren't .net
20:46:07 <Cale> How does Boo handle procedures/functions?
20:46:13 <amz> Saizan: thanks, I'll take a look
20:46:13 <jmcarthur> Cale: iirc, a "delegate" can be a closure, but a "function" cannot. somebody else will probably say i'm wrong though. it's been a while since i used such atrocious things
20:46:18 <Associat0r> there are some other non .net python like experiments
20:46:18 <randomity> hmmm, at night this channel grows fangs and turns into #anything-but-haskell. awesome.
20:46:53 <amz> says that foldl' is not on scope
20:47:07 <Ycros> rovar: also Cobra
20:47:14 <Associat0r> yeah Cobra
20:47:20 <rovar> jmcarthur: that's basically it... a delegate keeps a ptr to the stack on which it was created (e.g. a class instance) whereas a function ptr does not.. so you would make a delegate from a class method.. and a function ptr from a static method
20:47:25 <Associat0r> Cale : in what way?
20:47:27 <rovar> haven't looked at cobra
20:47:52 <Cale> Associat0r: Well, that's sort of what we've been discussing -- how various languages handle functions/procedures.
20:47:53 <Ycros> rovar: it's also inspired by Python, like boo, but supposedly better
20:47:58 <rovar> also a delegate would be an inner function
20:48:05 <Saizan> amz: see at the top, i've added import Data.List
20:48:10 <gwern> randomity: even the #haskeller who is pure and programs  aright / may chat off-topic when the conversation blossoms and the moon is bright
20:48:11 <amz> ah
20:48:14 <Ycros> rovar: personally I just can't wait for Python to get some nice speedups thanks to Google's unladen swallow project
20:48:37 <Ycros> has anyone played with the Pure language?
20:49:04 <Cale> jmcarthur: I'm not sure when you'd ever want a procedure definition *not* to close over the values of the variables that are in scope when it is defined. Is it that people think using a closure to store those values is too expensive?
20:49:28 <erikc`> Cale: yes, it is
20:49:38 <Cale> (We should show these people something like graph reduction ;)
20:50:00 <amz> Saizan: still stack overflows for me :(
20:50:16 <amz> let me paste an updated version, whose purpose should be clearer
20:50:19 <Cale> erikc`: In what way?
20:50:28 <randomity> gwern: *sheds a tear at the unrivalled beauty* :D
20:50:45 <amz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5090#a5092
20:50:50 <erikc`> they think it's too expensive
20:51:12 <Cale> It seems strange. Such a small price to pay for sanity.
20:51:39 <erikc`> of course, c/c++ programmers not aware of their machine abi dont realize they've already dedicated a machine register to a pointer to a table of CAFs :P
20:51:43 <erikc`> so all C functions are closures anyway
20:51:49 * gwern bows. gwern, inflicting humor on #haskell since 2007. I'll be here all week
20:51:54 <erikc`> now i sound like conal :)
20:53:09 <randomity> ok, now it is 5am. Goodnight #haskell, before I fall asleep on the keyboard
20:53:13 * MonadBaastad thinks that "unladen swallow" smacks faintly of pr0n...
20:53:13 <Cale> I wonder where the word 'delegate' comes from too..
20:53:15 <rovar> nite
20:53:25 <rovar> haha
20:53:28 <randomity> night
20:53:29 <Cale> That seems like an awfully strange word for 'procedure'
20:54:02 <dibblego> @where yaht
20:54:02 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:54:23 <erikc`> Cale: as far as i know microsoft introduced the term with .net
20:54:41 <gwern> MonadBaastad: could be worse. they've could've picked tits or boobies as their bird of choice
20:55:10 <MonadBaastad> gwern: Double-breasted chickadees? >;)
20:55:36 * gwern saw a fine tit the other day on wikipedia
20:55:44 <Cale> erikc`: heh, it sounds like something a business person would come up with... "I'm not going to need a procedure to do this, I'll just delegate it."
20:55:59 <dibblego> delegate is a C# keyword for emulating HOFs
20:56:14 <gwern> DELEGATE procedure GIVING VOID
20:56:19 <jmcarthur> Cale: i think it comes from OO speak. a delegate is basically an object that can be stored locally to determine how certain operations should be carried out. that is, it replaces local functionality with foreign functionality. kind of similar to a strategy
20:56:40 <dibblego> @where lyah
20:56:40 <lambdabot> www.learnyouahaskell.com
20:56:52 <Cale> dibblego: I'm wondering about the etymology of it.
20:56:54 <rovar> lyah++
20:56:54 <jmcarthur> i've been running into a lot of crap with OO programming at work this week and am tired of design patterns crap though, so i'm done beyond this point
20:57:35 <Cale> jmcarthur: Interesting... though I'm not sure exactly the way that sense relates to the fact that it captures the values of variables that are in scope where it's defined.
20:57:42 <jmcarthur> basically, it's a fancy word for a concept that shouldn't be so fancy
20:57:52 <Saizan> amz: updated with added strictness http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5090#a5093
20:58:11 <jmcarthur> Cale: in implementation, C#'s and D's delegates are just objects that represent the closure with a method which invokes the "function"
20:58:28 <MonadBaastad> Weird: http://en.wikipedia.org/wiki/Delegate_(.NET) looks like someone sat down and deliberately tried to make a clunky CPS system... :\
20:58:43 <jmcarthur> one could say it is an abstraction leak to call it a delegate like that
20:58:57 <Cale> Wait, what? Represent the closure?
20:59:09 <jmcarthur> well, it *is* the closure, really
20:59:10 <amz> Saizan: awesome, that works :)
20:59:14 <amz> if only I knew why... :)
20:59:17 <jmcarthur> it's hack
20:59:19 <jmcarthur> *a hack
20:59:33 <amz> but thanks a lot
20:59:35 <Cale> Yeah, a closure is an implementation mechanism for a procedure, as far as my definitions go :)
20:59:38 <jmcarthur> i'm not going to be able to explain it properly
20:59:39 <amz> I'll study this black magic
20:59:46 <Cale> But maybe I see what you mean
21:00:04 <Saizan> amz: well, the point is to not construct huge thunks of strict functions, but evaluate the application of each function step by step
21:00:20 <Cale> You have an object with a method for the code, and instance variables for the captured variables?
21:00:57 <Saizan> amz: it's the same concept of foldl (+) 0 vs. foldl' (+) 0
21:01:07 <Saizan> @wiki Stack Overflow
21:01:07 <lambdabot> http://www.haskell.org/haskellwiki/Stack_Overflow
21:01:30 <Saizan> http://www.haskell.org/haskellwiki/Stack_overflow <- actually
21:01:32 <amz> this is still way above my level, I can barely code anything in Haskell, but I'll try to decypher it
21:01:36 <Gracenotes> sans the capital o
21:01:43 <Gracenotes> wiki titles are case sensitive... yeah you got it :)
21:01:51 <Gracenotes> except for the first letter
21:02:13 <jmcarthur> Cale: "Delegates to non-static nested functions contain two pieces of data: the pointer to the stack frame of the lexically enclosing function (called the frame pointer) and the address of the function. This is analogous to struct/class non-static member function delegates consisting of a this pointer and the address of the member function. Both forms of delegates are interchangeable, and are actually the same type"
21:02:45 <Cale> okay
21:03:05 <Cale> That's pretty much a closure, yeah.
21:03:25 <jmcarthur> "A function pointer can point to a static nested function" ... "A delegate can be set to a non-static nested function"
21:05:21 <erikc`> and since a non-static function is just a function with a hidden this parameter...they are the same thing :P
21:05:41 <jmcarthur> D even has explicit lazy evaluation
21:06:18 <erikc`> yea
21:06:43 <erikc`> those features fall out naturally once you give in to garbage collection + heap allocation of stack frames :)
21:06:58 <jmcarthur> yeah, but most imperative languages ignore such obvious ideas
21:07:21 <jmcarthur> and D does not mandate garbage collection, either
21:07:28 <jmcarthur> it can be manual, if you wish
21:08:28 <erikc`> so you need to manually free your closures i guess
21:08:32 <mmorrow_> D heap-allocates stack frames? does it have real callcc?
21:10:14 <jmcarthur> you could probably do it with delegates, although i don't know whether it will optimize tail calls or just confuse the garbage collector or whatever
21:10:39 <mmorrow_> ah, hmm
21:11:22 <mmorrow_> so i guess you don't have access to the stack frames as if they were "just some closure" or something
21:12:09 <Associat0r> anyone seen http://delight.sourceforge.net/ ?
21:12:50 <jmcarthur> you can even get raw pointers to the stack frames if you want, i think
21:13:32 <jmcarthur> but even without that, i think the closures are true closures... just hackish because it's done in OO-speak
21:13:50 <mmorrow_> hmm, cool. i guess the only question then is whether stack frames are deallocated after a function returns unconditionally, or if they're gc'ed only if there're no live ptrs to them
21:13:57 <jmcarthur> right
21:14:53 <jmcarthur> i suspect it is the latter
21:15:00 <Associat0r> http://www.bitc-lang.org/ does closures on the stack too without GC
21:15:06 * mmorrow_ is reading http://www.digitalmars.com/d/2.0/memory.html
21:38:22 <travisbrady> how can i do patterns in a case statement with ByteStrings? ala 'case x of "A" -> print "hey" "B" -> print "no"'
21:42:05 <codebliss> @i getFile
21:42:05 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
21:42:19 <codebliss> @src getFile
21:42:20 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:42:32 <codebliss> @t getFile
21:42:33 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:42:47 <codebliss> How does lambdabot do :t? XD
21:43:32 <codebliss> Oh, it's readFile...
21:45:54 <jimmyjazz14> is there a !! counterpart that works with Integer types?
21:48:01 <Saizan> genericIndex
21:50:03 <jimmyjazz14> thanks
21:51:22 <dmwit> Yes!  I now have what is essentially a very, very complicated way to draw a line across the screen. =P
22:03:08 <amckinley> would anyone like to help me write a small chunk of the parser im working on? :)
22:18:20 <A1kmm> Hey, has anyone managed to get uvector working with trunk?
22:18:26 <A1kmm> (version of ghc)
22:20:23 <dmwit> amckinley: hpaste.org, maybe?
22:22:55 <amckinley> dmwit: actually ive got to run; hopefully ill be back later :) thanks though
22:29:24 <A1kmm> Does anyone know what the following error message (from the latest darcs version of ghc): Data/Array/Vector/Prim/BUArr.hs:89:0:
22:29:26 <A1kmm>     Failed to load interface for `GHC.Prim':
22:30:04 <A1kmm> Isn't GHC.Prim part of the wired-in ghc-prim package?
22:30:21 <thoughtpolice> A1kmm: in ./ghc/libraries/ghc-prim/ghc-prim.cabal, you can see GHC.Prim is hidden by default with a flag
22:30:49 <A1kmm> Ah... so packages need to explicitly enable it?
22:31:14 <thoughtpolice> not sure
22:31:27 <thoughtpolice> i would think there was a patch introduced which hides GHC.Prim by default
22:31:33 <thoughtpolice> which isn't in the 6.10 branch
22:33:34 <solrize_> @seen lemmih
22:33:35 <lambdabot> lemmih is in #haskell. I don't know when lemmih last spoke.
22:33:41 <solrize_> lemmih ?
22:34:13 <solrize_> @seen thoughtpolice
22:34:13 <lambdabot> thoughtpolice is in #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard thoughtpolice speak 2m 40s ago.
22:34:23 <solrize_> thoughtpolice ?
22:34:36 <dmwit> You are SOL tonight.
22:34:40 <solrize_> heh
22:34:44 <solrize_> i had a dumb question about lhc
22:34:52 <A1kmm> thoughpolice: flag include-ghc-prim {
22:34:54 <A1kmm>     Description: Include GHC.Prim in exposed-modules
22:34:55 <A1kmm>     default: False
22:34:57 <A1kmm> }
22:35:37 <Lemmih> solrize_: ?
22:36:44 <Lemmih> GHC.Prim doesn't exist. It's only generated for documentation purposes.
22:36:47 <solrize_> lemmih, yeah,  i was wondering if lhc uses the same dictionary avoiding typeclass scheme as lhc
22:36:58 <solrize_> i remember asking something about this before
22:37:06 <solrize_> oops "same as ... jhc"
22:37:23 <thoughtpolice> solrize_: ?
22:37:27 <Lemmih> solrize_: Yes and no.
22:37:31 <dmwit> Typeclasses without dictionaries, eh?
22:37:32 <solrize_> 'cause i remember that the jhc blurb explained that as why it used a fancy type system in its intermediate lang
22:37:35 <solrize_> dmwit, yeah
22:37:38 <A1kmm> Lemmih: uvector uses it, but it won't compile for trunk ghc.
22:37:51 <solrize_> and ghc core's type system doesn't have the high powered capabilities
22:38:00 <RyanT5000> is there a policy about advertising Haskell jobs in this chatroom?
22:38:03 <Lemmih> solrize_: We use normal dictionaries but we can optimize them away.
22:38:21 <Lemmih> solrize_: JHC takes a different approach and doesn't create the dictionaries in the first place.
22:38:26 <Lemmih> solrize_: The end result is the same.
22:38:29 <solrize_> hmm
22:38:31 <solrize_> cool
22:38:41 <dmwit> RyanT5000: It seems fine to me, though I'm not in any position of authority.  You'll almost certainly get better response from haskell-cafe, though.
22:39:24 <RyanT5000> dmwit: ah, that's a good point; i'll send something to that at some point
22:39:36 <Lemmih> solrize_: Our approach requires a bit more CPU time but it is easier to work with. We had lots of trouble getting the dictionaries to work correctly in JHC.
22:39:44 <RyanT5000> on the basis of that non-authoritative response, i'm going to go ahead and say it :P
22:39:51 <solrize_> ryant5000 i think it's ok, since there are so few.  putting it at -cafe will probably get it into HWN which is very visible
22:40:01 <solrize_> ryant5000 :)
22:40:04 <RyanT5000> solrize_: yeah, that's a good point
22:40:41 <RyanT5000> i'm starting a game studio writing in haskell; email me at ryant5000@gmail.com if you're interested
22:41:14 <solrize_> lemmih, interesting.  i never understood that angle of jhc.  but since  you have the whole program right there it seems natural that you can specialize every function
22:41:25 <dmwit> Whoa; have you got a game in mind already?
22:41:31 <solrize_> game studio?!!!  yow
22:41:31 <RyanT5000> dmwit: yeah
22:41:38 <dmwit> ?yow!
22:41:38 <lambdabot> You mean you don't want to watch WRESTLING from ATLANTA?
22:41:42 <RyanT5000> solrize_: yep :)
22:41:47 <solrize_> dmwit hee
22:41:52 <RyanT5000> it'll be tough
22:42:06 <RyanT5000> and i imagine we'll end up contributing to GHC quite a bit if we manage to survive
22:42:14 <solrize_> ryant5000 did you ever see tim sweeney's presentation about game dev. languages?
22:42:19 <RyanT5000> but i think it has a lot of potential - and Tim Sweeney backs me up
22:42:25 <solrize_> hehe jinx
22:42:25 <RyanT5000> solrize_: yup :)
22:42:28 <RyanT5000> lol
22:42:32 <Lemmih> A1kmm: Oh, sorry, I misunderstood. I don't know what the problem is.
22:42:41 <dmwit> So you're going for the high-end games, then?  (Not casual games.)
22:43:07 <solrize_> you gonna program GPU's with haskell ?
22:43:18 <solrize_> (the answer must be yes, haskell can do that)
22:43:23 <RyanT5000> we're looking into everything
22:43:32 <RyanT5000> porting to weird platforms or chips is a core part of our strategy
22:43:50 <RyanT5000> (another core part is this chatroom and all the untapped talent it represents)
22:44:14 <RyanT5000> (in my opinion, there's not enough demand for Haskell programmers)
22:44:21 <solrize_> i've felt like haskell needs an internal low level DSL for micro-optimizing cpu intensive functions
22:44:42 <dmwit> Harpy?
22:44:43 <twb> Does GHC 6.10.3 include haskeline?  That's what Debian seems to think.
22:44:51 <solrize_> harpy = assembler, not what i had in mind :)
22:44:54 <RyanT5000> twb: release notes say yes
22:45:02 <Ycros> RyanT5000: are you starting a real game dev studio, ie. a business, or just like an indie one
22:45:31 <RyanT5000> Ycros: it's a real game dev studio, although it won't be developing mainstream PC or big-box console titles (at least not in the short-term)
22:45:47 <twb> RyanT5000: thanks.
22:45:54 <RyanT5000> twb: np
22:46:06 <RyanT5000> Ycros: we haven't totally worked out financing yet - in particular because the availability of Haskell talent is more or less an unknown quantity right now
22:46:10 <solrize_> lemmih are you generating asm code or C?
22:46:51 <Ycros> RyanT5000: financing is the important part :P
22:47:03 <Ycros> RyanT5000: where are you located?
22:47:06 <RyanT5000> i have a feeling that Haskell programmers are self-selected in interesting and useful ways, and that Haskell itself has a lot of potential (again, in line with Tim Sweeney's presentation), but it's hard to go to VC or other financing with just a gut feeling
22:47:32 <RyanT5000> Ycros: you're right, financing is a huge deal; we have some - enough to possibly get one game out the door
22:47:38 <solrize_> ryant5000, an anecdote, skydeck (company writing some kind of telecom related software in ocaml) used to advertise for python(?) programmers because they didn't want to scare people by mentioning ocaml.  but once word got out they were actually using ocaml, the way i heard it, tons of fp nerds all wanted to work there.
22:47:43 <RyanT5000> Ycros: we're in Boston, Massachusetts
22:48:05 <RyanT5000> solrize_: huh, that's interesting
22:48:18 <Ycros> RyanT5000: ah well, way too far away for me anyway :P
22:48:23 <Lemmih> solrize_: Neither. Right now we're interpreting GRIN code. An LLVM backend will be added soonish.
22:48:55 <RyanT5000> Ycros: ah, that's too bad
22:49:09 <solrize_> hmm, i guess you've done CPS conversion already, so no issue with LVM not compiling tail recursion away
22:49:37 <RyanT5000> Ycros: you sound like you have some experience with startups; is that the case?
22:50:48 <Ycros> RyanT5000: Not really, but I hang around people who do the startup thing, I've also started a business some months ago and might be starting another soon :P
22:50:49 * solrize_ worked at a game startup but am not enough of a haskell expert to qualify for a haskell startup and anyway already has a job :)
22:50:58 <Lemmih> solrize_: We /will/ depend on llvm optimising tail recursive calls.
22:51:10 <RyanT5000> Ycros: sounds good
22:51:15 <solrize_> lemmih hmm they have fixed that (or will fix it)?
22:52:03 <solrize_> lemmih can you add a compiler flag that makes Int arithmetic check for overflow and raise an exception?
22:52:20 <RyanT5000> alright, well, i've got to head off, but if anyone's interested - or knows anyone who might be interested - in writing games in Haskell, my email is ryant5000@gmail.com
22:52:43 <solrize_> ryant5000 i'm sure you'll get takers.  there are already some haskell games including a FPS
22:52:43 <Lemmih> solrize_: I don't see why not.
22:53:02 <solrize_> lemmih cool, i think that would catch some bugs
22:53:27 <solrize_> are you going to be able to use the existing ghc runtime for stuff like gc?
22:54:10 <solrize_> is there much of a haskell->llvm interface currently?
22:54:51 <solrize_> oh haha, i'm looking at the llvm release notes and it says they now support int overflow traps
23:11:20 <halberd> what does it mean in type theory when they say "primitive non-canonical constant"? example: apply is the primitive non-canonical constant for the Pi-set
23:12:17 <lispy> halberd: I can honestly say, I'm not sure
23:12:33 <dmwit> helpful
23:25:41 <halberd> I guess the canonical constants for a set are the constructors, and primitive simply means defined, so a primitive non-canonical constant would just be a defined constant that is not a constructor
23:27:34 <halberd> and that operates on elements of the set
23:37:04 <cads> hey, how's bsd for haskell?
23:39:35 <MyCatVerbs> OpenBSD's fine. I haven't tried any of the others myself.
23:39:47 <MyCatVerbs> I think FreeBSD's good too, but I couldn't tell you for certain.
23:46:16 <cads> does openbsd come with a useable desktop configuration?
23:54:07 <MyCatVerbs> cads: blowed if I can remember, but it does have a Hell of a good FAQ.
23:57:26 <cads> MyCatVerbs: it seems very secure
23:57:48 <MyCatVerbs> Well, they're almost paranoid enough. ^_^
