00:00:16 <Cale> Reiv: What kind of loop do you want? Usually it's easiest to just recurse.
00:00:18 <Saizan_> jbjohns: you might need a mingw installation for some C bindings, but otherwise no
00:02:05 <jbjohns> Saizan_:  Thanks for the answer.  Is there any plan to do something so that mingw wouldn't be needed anymore?
00:02:53 <jbjohns> Like, for example, maybe instead of just   Thing.C, the files might be named:       Thing.Platform.C  so the right one can be selected depending on the build platform
00:03:45 <Saizan_> i don't see why that would help
00:03:47 <hatds> ghc on windows comes with its own gcc
00:04:19 <hatds> although you can pass options to change it to another one
00:04:47 <Saizan_> the problme is that, for example, to compile HOpenGL you need the opengl library installed with its headers and reachable by your compiler/linker
00:05:08 <jbjohns> Saizan_: Because if mingw is needed to supply C bindings that means whatever is using these C bindings (presumably a C program) was written in a platform dependent way.  If platform support is needed it should be provided for all platforms instead of just unix and make everyone else use emulation
00:05:33 <Saizan_> it's not emulation
00:05:53 <Saizan_> portable libraries still need to be compiled for each particular platform
00:06:25 <Saizan_> executables produced by GHC won't need anything special to run, if you're afraid of that
00:06:29 <jbjohns> ok, not exactly emulation but it's a platform layer
00:06:35 <Saizan_> nono
00:06:57 <Saizan_> with mingw you produce win32 executables, it's not like cygwin
00:07:26 <jbjohns> ah, it converts to the right calls at preprosses time, so what is compiled is for the platform it's build on?
00:08:26 <Saizan_> some of the lower level libraries have some CPP #ifdef's for that, yeah
00:08:57 <jbjohns> ok, I'll read about it
00:09:11 <Saizan_> or let the C lib do that, like in the case of gtk
00:11:23 <jbjohns> I'm just not a fan of cygwin.  I mean, it serves a purpose in the same way Wine does, but saying "oh our product runs just fine on linux, you just need Wine" is kind of dishonest imo
00:11:45 <jbjohns> same as saying "our product runs on windows, you just need cygwin".
00:11:58 <Saizan_> mingw is considerably different
00:13:08 <jbjohns> ok, reading about it now
00:13:39 <jbjohns> I came onto this when I noticed that, using the Haskell Platform, I don't seem to be able to cabal install any packages
00:13:54 <Saizan_> that shouldn't be the case
00:13:58 <Saizan_> what's your problem?
00:14:01 <jbjohns> I suppose if I look long enough I'll find one that works, but happs tutorial didn't work and hxt doesn't work
00:14:23 <jbjohns> hxt fails on curl.  it says:          sh: runGenProcess failed: does not exist
00:14:33 <jbjohns> I opened a ticket on it on the haskell platform bug site
00:15:07 <Saizan_> "happstack" should install on windows without problems
00:15:19 <Saizan_> and it has some demo project
00:15:55 <Saizan_> however yeah, for curl you'd need to install the C lib first, and have an sh to run the configure script
00:16:38 <jbjohns> that's a shame.  Haskell feels like a fundamentally platform independent language.
00:17:22 <jbjohns> I mean, I'm not a windows fan boy or anything, I plan to switch to a mac if I get a bonus next month, but until then my laptop is windows
00:18:33 <DOKKA> use linux
00:18:41 <hatds> the devil of all programming is linking
00:19:01 <jbjohns> DOKKA:  For my server I do. Otherwise, no
00:19:48 <DOKKA> aw, well, I understand. few people have the time to play around with it to make it work
00:20:23 <jbjohns> it's not that, I feel pretty comfortable in linux and at the moment I wouldn't consider anything else for my server
00:20:24 <Cale> Ubuntu is pretty easy to set up. :)
00:20:48 <^Someone^> ^ That's about it
00:20:59 <^Someone^> But, if you want to install other things, it's not always that easy
00:21:20 <jbjohns> but for my laptop I want something nice and easy.  Windows isn't that, but at least I can play all my games.  Mac is just liquid beauty and since it can do all my dev stuff I've decided to switch
00:21:23 <DOKKA> I think it's easy too, but then again, I run gentoo
00:22:05 <jbjohns> afk a min
00:22:38 <DOKKA> Macs are pretty though, I have to give'em that
00:22:54 <Cale> ^Someone^: I've found it pretty nice :)
00:23:05 * ^Someone^ uses Ubuntu too
00:23:19 <Cale> ^Someone^: Of course, the Haskell support is pretty lacking, but I just get the generic linux binary.
00:23:19 <^Someone^> That is to say, that's all I've been using for nearly a year
00:23:54 <DOKKA> try buuilding it from source, it's really not that hard
00:24:07 <walter_> what difference between [Char] and "String"
00:24:31 <Cale> walter_: nothing, String is a synonym for [Char]
00:24:46 <Cale> DOKKA: No need for that
00:25:11 <walter_> you mean in Haskell type String and [Char] can be regard as the same type?
00:25:19 <Cale> Building GHC from source is generally a waste of time unless: 1) There is no GHC binary for your platform, or 2) You are hacking on it.
00:25:20 <hatds> yes
00:25:35 <DOKKA> >['a','b','c']
00:25:36 <Cale> walter_: yeah, in the Prelude, there's a definition   type String = [Char]
00:26:08 <walter_> Thanks, clear.
00:26:59 <Cale> > ['a','b','c'] -- the space after > is not optional ;)
00:27:00 <lambdabot>   "abc"
00:27:11 <DOKKA> oh, whoops
00:28:11 <^Someone^> Well, it annoys me that so many simple things that are available in Windows aren't in Linux : s
00:28:50 <^Someone^> Like, an MSN client which supports features like webcam and voice chat? Okay at least offline messaging?
00:29:13 <^Someone^> Even eBuddy can handle offline messaging, why not IM clients for Linux?? : S
00:29:28 <DOKKA> I think ekiga might do that
00:29:42 <^Someone^> But that's not MSN : /
00:31:14 <DOKKA> yeah, it's not a complete substitute for windows
00:31:19 <Nafai> ^Someone^: The benefits of Linux far out weigh the disadvantages.  Especially compared to Windows or OS X.
00:31:20 <DOKKA> and it never will be
00:31:21 <^Someone^> Skype does it. Okay. I love Skype for Linux. But I have at least one stubborn friend who refuses to install Skype because it's going to be largely unused and all that
00:31:39 <^Someone^> Nafai: Certainly, that's why I still have only Linux on my laptop
00:31:54 <^Someone^> (Dunno about OS X, haven't used it)
00:32:09 <Nafai> I had to use OS X for about 6 months and I went running back to Linux.
00:32:30 <^Someone^> But it certainly does annoy me that eBuddy has offline messaging and Emesene or Pidgin or Kopete or any other MSN client I've seen in Linux have not : /
00:32:31 <Nafai> I'm annoyed at the state of sound and bluetooth on Linux.  Most everything else I love.
00:32:57 <Nafai> ^Someone^: That's the problem when you are replicating a proprietary protocol. :(
00:33:11 <^Someone^> Hm, but how can eBuddy do it?
00:33:20 <DOKKA> yeah, but with pulseaudio, things should be getting better
00:33:48 <Cale> ^Someone^: Does Pidgin not do offline messaging?
00:33:49 <Nafai> ^Someone^: I'm not saying it is impossible, I'm just saying that it's not easy and often open source (remember, often volunteer) applications have to prioritize
00:33:51 <^Someone^> Ubuntu 9.04 is a great deal of improvement on 8.04, I must say
00:33:59 <^Someone^> Cale: No, it can't send offline messages
00:34:13 <Cale> Interesting. I don't really use it much anyway though.
00:34:21 <Nafai> DOKKA: Supposedly, but I still have great problems with bluetooth audio in 9.04.  Problems as in I'm unable to get it to work
00:34:41 <Nafai> ^Someone^: Have you filed a bug or feature request with the pidgin developers?
00:35:07 <^Someone^> Nafai: No. I'll try that
00:35:56 <DOKKA> I realize it will always be second best, but the rediculous amount of customization,and control you have is why it will never disappear
00:36:28 <Nafai> Admittedly, it took a bit of effort to get bluetooth audio working on my wife's Windows laptop too :)
00:37:55 <Saizan> ^Someone^: i do send and receive offline messages with pidgin, fyi
00:38:09 <DOKKA> yeah, I have to agree about bluetooth, I had to compile an old version of bluez-tools to get mine to work
00:38:27 <Saizan> ^Someone^: on the msn protocol
00:38:46 <Saizan> however this whole conversation is quite off topic :)
00:39:05 <^Someone^> Saizan: Do you mean while the other user is `appearing` offline?
00:39:32 <^Someone^> (Receving always works, sure)
00:39:42 <Saizan> ^Someone^: yup
00:39:45 <Nafai> Anyway, haskell is awesome :)
00:40:05 <Nafai> (is that more on topic?)
00:40:13 <Saizan> ^Someone^: maybe the version on ubuntu is too old
00:40:42 <^Someone^> Saizan: No, I meant when the other user is actually offline. OR even when the other user is appearing offline but has been inactive for more than two-three minutes. Like when I want to tell them about how awesome Haskell is >.>
00:44:45 <Reiver> Cale: I'm after a recursive while loop, yes
00:45:02 <Reiver> (Sorry about the delay in answering, I was on the wrong nick and it wasn't triggering highlights. >_>)
00:45:41 <Twey> Cale, ^Someone^: It can do offline messages.  It works for me, too.
00:45:47 <Twey> On AIM, YIM, and MSN.
00:46:56 <Cale> Reiver: I suppose it's possible to ascribe a meaning to a while loop for parsers, but it seems unusual.
00:47:43 <Cale> Reiver: are you perhaps looking for one of these? http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html
00:48:00 <Reiver> Yeees, I probably am. Except I'm trying to do it by hand. :)
00:48:17 <Reiver> (Learing Haskell, best way to learn is to start small work your way up, etc)
00:48:21 <Saizan> well, you can just use the name of the parser you're defining to recurse
00:49:15 <Cale> Reiver: the source for those is provided and possibly enlightening
00:49:23 <Reiver> Hm. Okay, I'll have a look.
00:49:35 <Reiver> Does the code otherwise look okay? I've not been able to run it to test just yet.
00:49:45 <Reiver> (Given I've incomplete lines, etc... >_>)
00:49:51 <Saizan> i.e. list = (do x <- elem; symbol ":"; xs <- list; return (x:xs)) <|> (do symbol "[]"; return [])
00:50:19 <Saizan> Reiver: what's the type of your symbol function?
00:50:19 <ErhardtMundt> yo Saizan :)
00:50:28 <Saizan> hi :=
00:51:10 <Cale> Yeah, though I might go with >> instead of do-blocks for the little two-line things
00:51:24 <Reiver> > symbol                        :: String -> Parser String
00:51:24 <Reiver> > symbol xs                     =  token (string xs)
00:51:26 <lambdabot>   <no location info>: parse error on input `='
00:51:26 <lambdabot>   Not in scope: type constructor or class `Parser'Not in scope: `symbol'
00:51:40 <Reiver> ... oops, sorry Lambdabot
00:51:59 <Cale> You might define something like...
00:52:28 <Cale> xs ~> v = do symbol xs; return v
00:53:14 <jbjohns> Nafai:  You don't represent the average person (in your OS choice) and never will.
00:53:19 <^Someone^> (Got disconnected after that last thing I said to Saizan : / )
00:53:20 <jbjohns> and frankly I'm very glad of that. :)
00:54:12 <Twey> Yeah, everybody these days uses Arch.  Ubuntu is so last year.  :-P
00:55:07 <jbjohns> Linux+SElinux is probably the best right now for internet facing servers, but I can't imagine a volunteer system ever competing on user interface.  Apple and MS have invested so much to find out what people learn the easiest
00:55:31 <lars9> im using arch. it's good. but i'm stilling considering gentoo
00:56:02 <DOKKA> you should try gentoo
00:56:03 <jbjohns> I don't like Ubuntu, reboots more than my windows machines.  I went back to debian.  Gentoo is ok but if it's only going to add 8% or so the compile time isn't worth it to me
00:56:15 <DOKKA> ...for educational purposes only...
00:57:00 <lars9> maybe you should try Archlinux, it's much more agile than debian
00:57:09 <DOKKA> these days it dosen't even do that. if youhave a core 2 or something the performance gain is marginal
00:57:17 <hatds> can't you just turn off automatic updates to avoid reboots?
00:57:21 <jbjohns> for my internet facing servers I'm only concerned about stability
00:57:46 <DOKKA> I believe gentoo is a great learning tool
00:57:50 <jbjohns> hatds:  I shouldn't need to. Those same packages update on debian and don't need a reboot.  Ubuntu is just overly cautious with that stuff
00:58:01 <jbjohns> DOKKA:   Agree!  I learned a ton from Gentoo
00:58:43 <jbjohns> hatds:  Sorry, it's not rebooting my machine.  It's just making that annoying pop up every time I log on my ubuntu machine
00:59:20 <jbjohns> so what is the story on ghc on OS X?  Totally native right?  No issues installing libraries and so on?
00:59:39 <astrobunny> hmm does anyone use parsec on a kubuntu machine?
01:00:06 <astrobunny> ghc hello.hs -o hello -lparsec
01:00:09 <Twey> DOKKA: Agree too.  Gentoo is very interesting to play with.
01:00:13 <DOKKA> jbjohns: you shouldn't have any issues
01:00:17 <Saizan> astrobunny: use --make
01:00:17 <astrobunny> cannot find -lparsec
01:00:18 <Twey> astrobunny: Try --make
01:00:53 <astrobunny> ah
01:00:54 <astrobunny> thanks
01:01:11 <DOKKA> it's fun, but the only drawback is the time you have to devote to it
01:01:26 * Twey nods.
01:01:32 <jbjohns> personally I hope to get time to make my own linux distro
01:01:40 <DOKKA> wow
01:01:47 <Twey> Which is why the usual path is Gentoo -> Arch, not the other way around :-P
01:01:57 <Twey> Yeah, self-building distros sounds like fun
01:02:00 <jbjohns> out of the box it will use open ldap.  As little in config files as possible
01:02:08 <Twey> I would probably base it on GoboLinux
01:02:38 <jbjohns> and SELinux.  DACs is just a ridiculous security model.  Linux is lucky it is so niche or it would have a really bad rep for security
01:02:45 <DOKKA> cool, I would want to base one on tinycore linux
01:02:53 <hatds> what's DAC?
01:03:10 <jbjohns> the security model unix has.  Just user+group+everyone file permissions
01:03:23 <jbjohns> it's a really old, very obsolete way of doing security on a system
01:04:17 <DOKKA> what do yall think about opensolaris?
01:04:34 <jbjohns> now that Vista/Windows 7 no longer makes the user be admin they are finally more secure than default linux.  But luckily Redhat and Debian come with SELinux, which I think is more powerful than the windows security model
01:05:17 * Twey tends to distrust anything associated with the NSA on principle
01:05:52 <jbjohns> I don't know how much they have to do with what it is now.  But it is the best model I've seen for doing security
01:05:53 <joga> err, I thought that both vista and w7 still make the user have admin rights, maybe they just prompt to click ok...
01:06:18 <jbjohns> joga:  I'm not sure, maybe it's like root works in Ubuntu
01:06:39 <Twey> It is a good model, but it currently is a bit *too* good.  Many false positives.
01:06:47 <jbjohns> but that's better than what it was before: go to some web page and suddenly have a new kernel32.dll
01:07:08 <DOKKA> Twey: yeah, i know. but at least Sun is trying to play nice now
01:07:12 <Twey> joga, jbjohns: Yeah, it's just-click-OK, but the point is that until you click OK it's running with limited permissions
01:07:39 <Twey> DOKKA: Solaris' containers look interesting, but I hear it's horribly slow.
01:08:12 <DOKKA> it's a little slow and really, it's only good for servers so far
01:08:14 <jbjohns> I haven't looked much into other unix' since linux started getting really capable/stable
01:08:23 <jbjohns> I just wish they would fix their broken thread model
01:08:30 <DOKKA> their only advantages are xfs and RBAC
01:09:11 <Twey> Linux has both, nowadays
01:09:43 <jbjohns> Sun has a more advance thread model though afaik.  Not enough to give them a nod, but enough that I would be sad to see it go away
01:09:44 <DOKKA> true
01:12:03 <jbjohns> I've never heard of anyone planning to fix threading on linux either.  "It works how it is" strikes again. :)
01:14:14 <Twey> jbjohns: What's up with the threading model, exactly?
01:14:27 <jbjohns> threads should be like this:
01:14:41 <jbjohns> data Thread = Thread InstructionPointer Stack
01:14:51 <trofi> hi. I have a lambdabot question: can i send raw messages to server from my lambdabot instance w/o patching bot?
01:14:56 <jbjohns> data Process = Process UserInfo MemoryInfo [Thread]
01:15:03 <jbjohns> in linux they just go:
01:15:20 <jbjohns> data Process = Process UserInfo MemoryInfo InstructionPointer Stack
01:15:33 <jbjohns> and to make a thread they just copy one of those and set MemoryInfo to be the same in both things
01:15:35 * Twey tilts his head.
01:15:39 <Twey> Ew, yuck
01:15:46 <jbjohns> yes, very ew yuck
01:15:52 <jbjohns> but it was easy/quick to do
01:16:41 <Gracenotes> eesh.
01:16:47 <trofi> something like @rawmsg CODEPAGE UTF-8
01:25:43 <Reiver> Augh. My apologies; life is hectic at the moment - I keep getting distracted. :/
01:27:19 <Reiver> So... v = do symbol xs; return v
01:27:34 <Reiver> That would be recursing through, yes? How would I make it /find/ something?
01:28:33 <Saizan> just v
01:28:36 <Saizan> not return v
01:28:58 <Saizan> Reiver: well, you need a base case for your recursion
01:29:14 <Saizan> Reiver: and add that with +++ judging from the rest of your code
01:29:34 <inbuninbu> question for you fine people...
01:29:57 <Reiver> +++ is the "Or" command, if that follows
01:30:06 <Saizan> Reiver: yeah
01:30:07 <inbuninbu> i've created some custom get and put methods (Data.Binary.Put, etc)
01:30:25 <inbuninbu> not liking pattern matching, i'm happy with my get method
01:30:28 <inbuninbu> getData :: Get ()
01:30:29 <inbuninbu> getData = liftM2 Data get32 get64
01:31:04 <inbuninbu> however, i'm thinking there must be a way to simplify my put, for which i've got to copy out all arguments
01:31:06 <Saizan> Reiver: e.g. v = (do x <- symbol foo; xs <- v; return (x:xs)) +++ (do symbol base; return [])
01:31:13 <inbuninbu> putData :: Word32 -> Word64 -> Put ()
01:31:13 <inbuninbu> putData (Data a b) = put32 a >> put32 b
01:31:18 <Saizan> Reiver: that'll return the list of foo parsed
01:31:34 <inbuninbu> any suggestions on how to improve the put action?
01:32:01 * Reiver puts that into a document and starts indenting in an attempt to make sense of what that thing actually /does/
01:32:28 <jbjohns> thanks for the info about mingw etc.  Bye all
01:37:27 <Beelsebob> inbuninbu: other than the type not matching the function?
01:38:04 <Saizan> how was the definition of (~>)?
01:38:32 <Saizan> the one to write thing like (>>) $. put32 ~> put32 ~> id
01:38:35 <inbuninbu> Beelsebob: oh yeah, second should be 64; it's dummy code i put down for simplicity's sake
01:38:56 <Saizan> inbuninbu: no, the problem is (Data a b) vs. Word32 -> Word64 ->
01:40:37 <inbuninbu> Saizan: sorry, brainfart, type should be putData :: Data -> Put
01:41:10 <Beelsebob> then that seems fairly reasonable to me as a definition
01:41:55 <Taejo> is there a regex library that works on arbitrary lists instead of just Strings?
01:42:09 <inbuninbu> what i was wondering was if there's a nice trick that would let me map out the internals of the argument to a sequence, with less messy code
01:42:45 <Saizan> no
01:44:14 <inbuninbu> rats, i was afraid of that. thanks though!
01:46:36 <zeroflag> excuse me, I'm looking for a lunatic who calls himself mauke.
01:47:01 * zeroflag pokes mauke with a long stick
01:49:33 <Reiver> Hmmm.
01:50:45 <Reiver> Is:
01:50:45 <Reiver> >do symbol "("
01:50:45 <Reiver> >   do e <- expr
01:50:45 <Reiver> >   symbol ")"
01:50:45 <Reiver> >   return e
01:50:48 <lambdabot>   Not in scope: `symbol'
01:50:48 <lambdabot>   <no location info>:
01:50:48 <lambdabot>      The last statement in a 'do' construct must be an ...
01:50:48 <lambdabot>   No instance for (GHC.Show.Show (m SimpleReflect.Expr))
01:50:48 <lambdabot>    arising from a us...
01:50:59 <Reiver> (... okay, stop using > as a spacemarker)
01:51:04 <Reiver> Is that the right track?
01:51:22 <Lemmih> Reiver: There's a 'do' too many.
01:51:29 <Reiver> hm
01:51:41 <Reiver> So it just Does e <- expr then?
01:51:58 <Reiver> How does it know when to check for a ")"?
01:53:00 <Beelsebob> :( why not just use symbol "(" *> expr <* symbol ")"
01:53:08 <Saizan> what do you mean by "when"?
01:53:36 <Saizan> Beelsebob: he's a beginner starting to use some unknown (to me) parsing lib
01:53:43 <Cale> Beelsebob: Perhaps because the monadic notation is more straightforward :)
01:53:52 <Beelsebob> well, no, it's not
01:54:15 <Beelsebob> the monadic notation introduces silly ideas like sequences, rather than just writing down the grammar and having a parser magically work
01:54:45 <Cale> sequences?
01:54:56 <Beelsebob> do x, then y, then z, then ....
01:55:05 <Beelsebob> we're functional programmers, remember ;)
01:55:28 <Cale> Well, strings are sequences of characters, so it makes sense for parsers to concatenate...
01:55:48 <Beelsebob> parsers don't have to parse in sequence
01:55:51 <Saizan> Reiver: the parser  "expr = do symbol "("; e <- expr; symbol ")"; return e" will only parse infinitely nested parentheses, but if you add other cases with (+++) you can get the recursion to stop
01:55:54 <Beelsebob> it's overspecification
01:56:27 <Saizan> well, the conjuctive part of a grammar is sequential in semantics
01:56:42 <Saizan> regardless of how you parse it
01:56:44 <Cale> Huh? The concatenation of parsers is a sequence of parsers...
01:56:57 <Reiver> Oh, I could throw the parsing lib up if that would help.
01:57:08 <Reiver> Hadn't even occoured to me >_>
01:57:25 <Beelsebob> Cale: not necessarily - if I want to, I could write parsers that work from the end of the file backwards (don't ask why I might want to though)
01:57:39 <Beelsebob> the grammar has order, that doesn't mean we have to *do* it in that order
01:57:47 <Cale> Beelsebob: Sure.
01:57:53 <Cale> Beelsebob: What's your point there?
01:58:04 <Saizan> but what's wrong in expressing the order of the grammar with order?
01:58:04 <Beelsebob> that *do* x, then y then z is over specification
01:58:06 <Reiver> It's from Hutton's Introduction To Haskell book.
01:58:08 <Reiver> sec
01:58:18 <Beelsebob> and that the applicative version that merely writes the grammar down is simpler
01:58:23 <Cale> Beelsebob: *do* doesn't mean that it actually evaluates the parser in that order
01:58:26 <Reiver> Er, "Programming in Haskell", sorry.
01:58:30 <Reiver> Getting my books mixed up :P
01:58:36 <Beelsebob> Cale: no, but the coding style suggests it
01:58:45 <Saizan> Reiver: it's not strictly necessary, since the parsing lib all look quite similar :)
01:58:53 <Beelsebob> (yes, I realise I'm yet again arguing merely that do is a *really* shit word for that syntactic sugar)
01:59:03 <Cale> I don't think it's bad.
01:59:08 <Cale> It's just a word.
01:59:15 <Cale> and it's nice and short :)
01:59:34 <Reiver> Oh. Er. Here it is anyway? http://pastebin.com/dfd7bfa
02:00:00 <Beelsebob> Cale: it's a word that's been specifically constructed to make it seem like we're doing imperative programming
02:00:16 <Beelsebob> which is exactly what we don't want when specifying a grammar
02:00:24 <Cale> Beelsebob: But it's only an illusion anyway
02:00:34 <Saizan> Reiver: ok
02:00:34 <Cale> I don't see the problem with it :)
02:00:44 <Beelsebob> yeh sure... so lets use the nice style that doesn't create an illusion we don't want ;)
02:01:01 <hatds> we always write code however we think looks best, so just use >>= if you think it looks best
02:01:15 <Cale> I don't see why we don't want that illusion. Monadic code can be concise in its own way too.
02:01:31 <Reiver> Er. I admit this conversation is going a bit over my head, here...
02:01:37 <Saizan> Reiver: so, what i wrote so far made any sense?
02:01:40 <Beelsebob> Cale: well... what's the illusion we're creating... that it's imperative code, that happens in sequence
02:01:45 <Cale> Reiver: It's not really intended for you at this point :)
02:01:46 <Beelsebob> that's exactly what we don't want to express
02:01:49 <Beelsebob> because it's not happening
02:01:55 <Reiver> Saizan: Clear as mud, though I appreciate you're trying... ;)
02:01:59 <Cale> I don't see the illusion as being that strong.
02:02:12 <hatds> yea, no one ever said 'do' does sequencing
02:02:17 * Reiver suspects he needs a quick explanation of The Small Simple Stuff.
02:02:19 <Saizan> Reiver: maybe you should start experimenting with little parsers at the ghci prompt
02:02:21 <Beelsebob> the dictionary did hatds ;)
02:02:24 <Beelsebob> do as about actions
02:02:27 <Beelsebob> about verbs
02:02:30 <Reiver> (I'm using Hugs, actually, but okay)
02:02:39 <Cale> Also, the monadic notation gives you a clear name for results of subcomputations, which the applicative notation doesn't.
02:02:44 <Saizan> yeah, it's the same
02:02:45 <Reiver> I did get a parser to read math equations.
02:02:52 <Beelsebob> Cale: yeh, that's actually what I like about the applicative version
02:03:00 <Saizan> Reiver: but without recursion?
02:03:03 <Beelsebob> there isn't a need to name a computation I don't actually want to refer to except as the result
02:03:08 <Cale> With applicative, if you need to use the result of a computation in more than one place, it can be very awkward.
02:03:10 <Reiver> Saizan: I'd imagine so.
02:03:23 <Beelsebob> Cale: oh, sure - but he doesn't want to in this example
02:03:24 <Beelsebob> ...
02:03:32 <Reiver> I did have parethesis in the language, but even now I'm not entirely sure /how/ they ended up working...
02:03:38 <Cale> Beelsebob: right, but in general when writing a parser you may want to
02:03:51 <Cale> (and in fact it is pretty common)
02:03:58 <Beelsebob> Cale: so I guess that's a general argument about point free style then?
02:03:59 <Saizan> Reiver: hah, do you have that parser around?
02:04:01 <Beelsebob> we shouldn't use it
02:04:07 <Beelsebob> because we might want to use variables more than once
02:04:12 <Cale> Beelsebob: It's okay to use it when it's appropriate.
02:04:14 <Reiver> I do.
02:04:20 <Beelsebob> Cale: yeh... and it's appropriate here
02:04:35 <Saizan> Reiver: if you paste it we can have a look
02:04:35 <Cale> But for parsers, I think it's easiest to start with monadic notation, and maybe learn the applicative shorthands for things later.
02:04:41 <Reiver> do symbol "("; e <- expr; symbol ")"; return e
02:04:47 * Beelsebob really really doesn't get that
02:04:55 <Reiver> Same as I'm trying to use now, 'cept this time round I'm trying to /understand/ what it's doing.
02:04:56 <Beelsebob> for parsers it's easiest surely to just write down the grammar
02:04:58 <Beelsebob> and be finished
02:05:08 <Cale> Beelsebob: But you're not just writing a grammar.
02:05:17 <Saizan> Reiver: expr = do symbol "("; e <- expr; symbol ")"; return e ?
02:05:21 <Beelsebob> sure you are
02:05:32 <Reiver> Saizan: Replace ; with newlines in actual code.
02:05:36 <Cale> Beelsebob: Not many people write parsers that say "Yes, this is a member of this language." or "No, it isn't."
02:05:49 <Reiver> That's the parsing for parenthesis I had in the math parser
02:05:50 <mm_freak> as soon as the main thread exits, all threads are killed…  can i prevent this without having to introduce heavy inter-thread communication?
02:05:56 <Reiver> I just never quite understood how it actually /worked/
02:05:59 <Beelsebob> Cale: no, they tend to read it into some structure - which is easy to do with a liberal application of fmap and <*>
02:06:02 <Cale> Beelsebob: You're usually interested in extracting meaningful information from the parsing.
02:06:21 <Saizan> Reiver: yeah, but my question is if you've something else combined with (+++) in the expr parser
02:06:22 <Cale> Beelsebob: So long as that structure exactly reflects the structure of the grammar, it's okay.
02:06:32 <Reiver> Umm...
02:06:34 <Beelsebob> Cale: which it should do anyway
02:06:41 <Cale> Beelsebob: No, not necessarily.
02:06:46 <Saizan> Reiver: because that alone will only parse infinitely nested parentheses
02:06:48 <Reiver> +++ natural
02:06:56 <Reiver> Which then dealt with natural numbers.
02:06:57 <Beelsebob> Cale: if it doesn't, you've missed a step imho
02:07:05 <Beelsebob> that's not just parsing, it's processing as well
02:07:14 <Reiver> Saizan: You mean that the thing will do nothing but parse ((((((((... ?
02:07:30 <Reiver> Or ((())) ?
02:07:36 <Beelsebob> it won't parse ((()))
02:07:38 <Saizan> Reiver: it will try to parse (((...)))
02:07:42 <Beelsebob> because "" isn't a valid expr
02:08:02 <Reiver> Aha, okay
02:08:28 <Saizan> that's why adding a base case with +++ is important
02:08:35 <Reiver> Right.
02:08:43 <Reiver> So could I have an Idiots Guide To What The do Statement Is Doing?
02:09:05 <Reiver> I can see that it picks up the "(" symbol, then parses the code after it as if it were an expr - which can include another "(" symbol.
02:09:17 <Cale> Reiver: You see the definition of >>= in the parsing library?
02:09:20 <Saizan> Reiver: do you understand what the (>>=) method in the Monad Parser instance is doing?
02:09:23 <Reiver> But I'm not sure how it moves on from the expr bit to find the ")" in it.
02:09:33 <Cale> It translates a do-block into applications of that
02:09:34 <Beelsebob> Reiver: this may be an apropriate such guide... http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
02:09:35 <Reiver> Not really, no.
02:09:52 <Cale> Okay, so let's look at >>= first
02:09:56 <Reiver> Okay.
02:10:15 <Cale> Beelsebob: Stop it! :)
02:10:28 <Beelsebob> what... it even goes into monadic parser combinators!
02:10:35 <Beelsebob> and what do means
02:10:48 <Cale> Reiver: So let's first write down the type of >>= in this context
02:11:00 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
02:11:13 <Cale> So it takes a parser whose result is a value of type a
02:11:29 <Cale> and a function from values of type a to parsers whose result has type b
02:11:51 <Cale> and it combines those together somehow to get a new parser whose results have type b
02:12:30 <Cale> So here in the definition, p is a parser, and f is a function which is going to take the result of parsing with p and give another parser to continue parsing with
02:12:42 <Cale> That's kind of a mouthful, I know :)
02:12:54 <Cale> But does it at least make a bit of sense?
02:13:22 <Reiver> So: Takes type a, (outputs type a, which is fed to Parser b), outputs a type Parser b?
02:13:52 <Reiver> If I've got that right, the second part is fine, yes.
02:13:55 <Cale> Parsing with p produces a value v :: a
02:14:09 <Reiver> Okay
02:14:15 <Cale> and then f v :: Parser b, and it continues parsing with that, returning its result
02:14:33 <Cale> So, now we can look at how it does that
02:14:58 <Cale> It has to produce a parser, and since at this point in the library, we don't have many ways to make those yet, it starts off with the data constructor P
02:15:16 <Taejo> in Parsec, I'd use (p >> q) to run parser p, discard its result and then run parser q; is there a neat way to discard the result of the second parser and return the result of the first?
02:15:28 <Beelsebob> Taejo: <*
02:15:36 <Beelsebob> (and *> to do what you just said)
02:15:37 <Taejo> Beelsebob: thanks
02:15:54 <Beelsebob> so his example there is symbol "(" *> expr <* symbol ")"
02:16:08 <Reiver> Cale: Righto
02:16:10 <Cale> Reiver: Do you understand the Parser type?
02:16:19 <Cale> newtype Parser a              =  P (String -> [(a,String)])
02:16:51 <Cale> A parser for things is a function from strings to lists of pairs of things and strings.
02:17:10 <Reiver> Yep, I'm following what Parser does
02:17:16 <Cale> That is, it returns a list of possible parses
02:17:27 <Cale> along with the remainder of the string in each case
02:17:46 <Cale> Oh, this definition for >>= in your library is bad.
02:17:56 <Reiver> ... it is?
02:18:10 <Cale> Yeah, it doesn't handle the case when p produces more than one result
02:18:25 <Reiver> Er. Bad in a sense of "Will break the program", or "flawed in certain situations"?
02:18:53 <Cale> In a sense that it will randomly die if a parser returns more than 0 or 1 results.
02:19:09 <Taejo> argh, old parsec without applicative instance
02:19:16 <Cale> (that is, it's forcing parsers to be deterministic)
02:19:28 <Cale> but, okay
02:19:43 <Cale> Reiver: let's look at this incomplete version anyway
02:20:01 <Cale> Reiver: It gives the function which takes the input string, and parses it with p
02:20:06 <Cale> and if the result is []
02:20:14 <Cale> then that means parsing with p failed
02:20:19 <Cale> and so the whole parse fails
02:20:24 <Taejo> anyone know which GHC is in Ubuntu Jaunty?
02:20:26 <Cale> so in that case the result is []
02:20:43 <Reiver> (Ah, yes. I think later chapters deal with nondeterminism; it could be a deliberate flaw.)
02:20:46 <Reiver> Right.
02:20:48 <Cale> If, instead we get a list of length 1, [(v,out)]
02:21:13 <Cale> then that means p succeeded in parsing with one result v, and the remainder of the string, which it didn't eat is 'out'
02:21:31 <Cale> and so then it parses out using the parser (f v)
02:21:39 <Cale> Clearer now?
02:21:53 <Reiver> I think so, yes.
02:22:00 <Cale> While we're at it, we can look at what return does
02:22:05 <mm_freak> it's interesting to see how real world problems (threading, I/O, network) are almost entirely ignore here, while 'interesting' problems (types, algorithms (and how to elegantly notate them), monads, theory) usually cause endless discussion =)
02:22:32 <Cale> return v gives the parser which always succeeds, producing the result v and passing the entire input string to the output
02:22:57 <Taejo> mm_freak: Haskell is so awesome that we solve our real world problems in a tenth of the time, so we have plenty of time to talk about interesting things
02:23:10 <Cale> mm_freak: Oh, I missed your question. The answer is don't let the main thread die.
02:23:17 <Taejo> @faq Can Haskell solve real world problems in a tenth of the time?
02:23:17 <lambdabot> The answer is: Yes! Haskell can do that.
02:23:22 <mm_freak> hehe
02:23:47 <mm_freak> Cale: my questions are almost always missed, unless they're 'interesting' =)
02:23:59 <Reiver> Cale: Righto.
02:24:02 <Cale> mm_freak: So, if you have to, have the main thread wait on MVars from the threads that it creates, or something.
02:24:27 <mm_freak> Cale: yeah, that's what i'm doing currently, but i thought, maybe the RTS can just wait for all threads instead of only one
02:24:28 <Cale> Reiver: okay, so now that you understand >>=, you just need to understand how do-notation translates
02:24:51 <Cale> mm_freak: If you figure out a way that it can, I might be interested to hear it :)
02:25:06 <Cale> mm_freak: But as far as I know, the main thread is special in that way.
02:25:13 <Cale> Reiver: So...
02:25:26 <Reiver> >>= is parsing the output of Parser a; aka recursively parsing stuff?
02:25:28 <mm_freak> maybe i should make the main thread a pure thread manager, nothing else
02:25:39 <paper_cc> mm_freak: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Concurrent.html <-- see paragraph "Terminating the program"
02:26:17 <Cale> Reiver: x >>= f parses the input with the parser x, passing the result of that parsing to f to get another parser, which it uses to parse whatever is left of the input
02:26:27 <mm_freak> paper_cc: i've got there already and it's not satisfying =/
02:26:34 <mm_freak> well, i'll just use MVars
02:26:44 <Reiver> Okay, right.
02:26:47 <mm_freak> it's sucks though to have MVar ()
02:26:56 <Reiver> So then the do notation...
02:27:10 <Taejo> :t break
02:27:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:27:26 <Cale> do { x } = x
02:27:40 <paper_cc> mm_freak: at least it says that threads are always daemonic
02:27:42 <Cale> If a do-block has only one statement, then there was no point in using do :)
02:27:50 <paper_cc> mm_freak: (it == the documentation)
02:27:53 <Cale> but this makes a nice base-case for the recursive translation :)
02:28:12 <Cale> do { v <- x ; <stmts> }   =   x >>= (\v -> do { <stmts> })
02:28:29 <mm_freak> next thing is:  killThread kills threads immediately, even if they are in a 'block', is there anything i could do here?
02:29:18 <Cale> do { x ; <stmts> }   =   x >>= const (do { <stmts> }) -- so, this means ignore the result of x, and always parse the rest using the same parser
02:29:41 <Cale> and, just for completeness
02:29:57 <Cale> do { let <decls> ; <stmts> }   =   let <decls> in do { <stmts> }
02:30:56 <Reiver> decls?
02:31:00 <Cale> declarations
02:31:03 <Reiver> Oh, of course
02:31:23 <Reiver> Okay, so
02:31:27 <paper_cc> mm_freak: this means the behavior of 'block' is simply wrong
02:31:38 <Cale> For example, you see the parser 'ident'
02:32:08 <Cale> ident = do x  <- lower; xs <- many alphanum; return (x:xs)
02:32:36 <Cale> = lower >>= \x -> do { xs <- many alphanum; return (x:xs) }
02:32:39 <paper_cc> mm_freak: or your block has some "interruptible operations" (cf. docs) inside
02:32:50 <Cale> = lower >>= \x -> many alphanum >>= \xs -> do { return (x:xs) }
02:32:55 <Cale> = lower >>= \x -> many alphanum >>= \xs -> return (x:xs)
02:33:06 <Reiver> Cale: ... those two look awfully similar.
02:33:16 <Reiver> Or are those refactoring code?
02:33:26 <Cale> Those are all equal
02:33:32 <Reiver> Right! Okay.
02:33:34 <Cale> I'm expanding out the do-notation for you
02:33:40 <Cale> To show you how it works :)
02:33:45 <mm_freak> paper_cc: i've tested this with threadDelay…  it gets interrupted
02:33:54 <Reiver> Aha. Aye, it's making more sense.
02:34:06 <Reiver> So there's not much point to the do notation then?
02:34:22 <Cale> It just makes code a little nicer to read.
02:34:31 <Cale> Than having long chains of >>='s
02:34:36 <Cale> and lambdas :)
02:34:56 <Cale> But yeah, it's syntax sugar.
02:35:01 <mm_freak> do char '('; c <- anyChar; char ')'; return c
02:35:09 <outchanter> ah, the sweet, sweet taste of syntactic sugar
02:35:19 <mm_freak> instead of:  char '(' >> anyChar >>= \c -> char ')' >> return c
02:35:35 <Cale> I probably should also mention that  x >>= const y  has another name, which is x >> y
02:35:56 <Reiver> Okay.
02:36:04 <Cale> So if you ever want to ignore the first parser's result (but it still eats some initial part of the string), you can use >>
02:36:15 <Reiver> Right.
02:36:19 * Reiver hmns.
02:36:20 <Cale> and so another way to translate:
02:36:32 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
02:37:00 <paper_cc> mm_freak: don't know actually... what if you put something like (factorial 10000) instead of the delay?
02:37:06 <Reiver> OK.
02:37:17 <mm_freak> not to forget that do-notation can be layed out nicely in source code without the need for ';'
02:37:42 <Cale> Right, I'm only including the semicolons and braces for clarity when everything is smashed onto one line here :)
02:37:46 <mm_freak> paper_cc: let me test
02:38:05 * Reiver figured that much; 'tis appreciated. :)
02:39:46 <mm_freak> paper_cc: indeed, then it works
02:39:58 <mm_freak> now i tested with: return $! fix (\r n -> if n == 0 then () else r (n-1)) 10000000
02:40:48 <Reiver> Hmm.
02:41:07 <Reiver> I'm going to look at this again and think about it. Also shift my car. BBIAB.
02:41:09 <Cale> Reiver: So, in general, any sort of library where we have things that represent computations that have results, where we have a 'return v' which is a kind of computation that does nothing and results in v, and an operation like this >>=
02:41:16 <Cale> is called a monad.
02:41:48 <Cale> Well, more specifically, 'monad' refers to the type constructor, in this case, it's Parser which is the monad.
02:42:09 <Cale> and do-notation works in any monad that way :)
02:42:38 <mm_freak> paper_cc: what still doesn't work is:  'finally' doesn't react to the ThreadKilled exception
02:42:49 <mm_freak> so i have no means of doing cleanup before the thread exits
02:44:06 <Berengal> Cale: I like to think of monads as the triplet (Type constructor, return, >>=). Saying it's just the type constructor confused me some when I was starting out
02:45:38 <Berengal> Of course, the term "Monad" has be overloaded to mean quite a lot of things...
02:45:50 <Cale> Well, it's a type constructor which has definitions of those things, yes
02:46:07 <Cale> But if you say "Foo is a monad", then Foo had better be a type constructor.
02:46:29 <Cale> (or a functor on some category anyway)
02:50:31 <paper_cc> mm_freak: strange. and what if you throw something other than ThreadKilled?
02:52:06 <mm_freak> paper_cc: doesn't work either…  very strange
02:52:23 <mm_freak> wait, i'll paste the code
02:53:38 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5409
02:54:14 <mm_freak> "Done blocking" appears, but "Done" doesn't
02:58:45 <mm_freak> Reiver: side note, the 'do' notation is very useful in the IO monad, as you can see in the pasted code
02:59:08 <mm_freak> it would be tiring to have to write this in combinator style (>>, >>=, lambdas)
02:59:21 <mm_freak> IO is a monad, just like Parser
03:04:23 <Saizan> well, when the main thread exits the other are not killed with an exception but just stopped i guess
03:08:07 <paper_cc> mm_freak: your code does work if I remove the threadDelay in the finally handler. Look carefully at the output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5409#a5411
03:08:36 <paper_cc> mm_freak: looks like the exception arrives too late - into the threadDelay in the finally handler
03:08:37 <mm_freak> Saizan: that's why there is a 10 second threadDelay at the end of the main thread
03:08:51 <mm_freak> Saizan: it ensures that the subthread exits first in all cases
03:09:14 * paper_cc tries (putStrLn "Started finally" >> threadDelay 1000000 >> putStrLn "Done)
03:09:24 <mm_freak> paper_cc: looks like threadDelay simply re-raises the exception
03:09:37 <mm_freak> such that the putStrLn is never reached
03:09:59 <paper_cc> mm_freak: yes, because exceptions are not blocked inside threadDelay
03:10:14 <mm_freak> hmm, so threadDelay has an implicit unblock?
03:10:42 <paper_cc> mm_freak: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Exception.html#13
03:11:12 <paper_cc> it is not documented if threadDelay is interruptible, but it looks so
03:14:36 <paper_cc> mm_freak: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5409#a5412
03:18:03 <mm_freak> hmm
03:18:38 <mm_freak> that essentially says that there is no secure way to do cleanup, unless you implement some cleaner way of quitting threads
03:18:56 <mm_freak> like messaging and MVar
03:19:13 <paper_cc> mm_freak: no it doesn't... this simply says there's no secure way to do blocking operations during cleanup
03:19:13 <mm_freak> but there are a few things, for which this simply won't work, like an 'accept'ing server
03:19:48 <mm_freak> paper_cc: yeah, but most cleanup tasks would use some operations, for which you don't know whether they block
03:19:52 <mm_freak> like hClose
03:21:10 * paper_cc writes mapM_ print $ foldl1 (*) [1..100000] instead of threadDelay
03:22:49 * paper_cc fails at printing a list of factorials
03:23:01 <ivanm> @seen quicksilver
03:23:01 <lambdabot> quicksilver is in #macosxdev, #haskell-soc, #haskell-blah, #ghc, #haskell-overflow and #haskell. I last heard quicksilver speak 17h 9m 31s ago.
03:23:53 * paper_cc couldn't tell foldl from scanl
03:28:01 <paper_cc> mm_freak: hmm, print is interruptible
03:32:27 <paper_cc> mm_freak: ... that means the thread shouldn't receive the exit signal during important cleanup blocks
03:36:39 <Cale> http://www52.wolframalpha.com/input/?i=how+to+program -- lol
03:37:05 <Beelsebob> heh
03:37:14 <Beelsebob> seems to be about the only thing alpha is good at
03:37:28 <Beelsebob> coming up with stupid answers to questions you didn't really want to ask
03:37:40 <Heffalump> rotfl
03:38:01 <Cale> http://www32.wolframalpha.com/input/?i=the+light+of+1000+suns is also kind of funny :)
03:38:36 <Cale> (less funny if you know the sense of the word 'sun' that it seems to think you mean)
03:39:33 <Cale> http://chrishecker.com/images/f/fc/Wspector2-small.png
03:39:56 <ivanm> Cale: lol (for the image)
03:40:12 <^Someone^> Lol
03:40:12 <ivanm> but what "sun" is alpha referring two?
03:40:26 <ivanm> "sum"?
03:40:49 <ivanm> Cale: also, for the first one... shameless plug?
03:40:52 <paper_cc> is "sun" a unit of length?
03:41:01 <Cale> a unit of area
03:41:12 <ivanm> never heard of it before
03:41:27 <Cale> 寸 [すん] /(n) sun (approx. 3.03 cm)/
03:41:32 <Cale> er
03:41:35 <ivanm> http://en.wikipedia.org/wiki/Sun_unit
03:41:35 <ivanm> ?
03:41:38 <Cale> oh, no it is length
03:41:44 <Cale> Right
03:42:18 <Cale> (which is why when multiplied by the speed of light, you get area/time)
03:47:16 <mm_freak> paper_cc: i'll refrain from using exceptions for quitting threads
03:47:42 <Baughn> ..but it's so convenient!
03:47:57 <mm_freak> paper_cc: up to now i've just used MVars, which worked fine, but it seems like that can be solved more elegantly
03:52:01 <paper_cc> mm_freak: you can actually use QSemN
03:59:13 <Reiver> Well that took longer than planned...
03:59:20 * Reiver mutters at Murphy and his minions
04:00:32 <Cale> Man, 82 comments on reddit on a post about whether -2^2 should be interpreted as 4 or -4
04:01:41 <uzytkownik> Hello. I'm tring to learn Haskell and I'm tring to use Foreign.C. How should I map structs to haskell?
04:02:08 <Cale> By writing an instance of Storable which reads them
04:02:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
04:02:32 <Baughn> hsc2hs can help, as can c2hs
04:02:34 <zepard> hi  all
04:02:47 <Cale> Yeah, there are tools for automatically generating that code, if it's going to be complicated.
04:03:27 <Baughn> Well, hsc2hs doesn't really do it /automatically/, but its tools for calculating the alignment of struct members is pretty vital
04:03:39 <uzytkownik> Cale: Thanks
04:04:10 <Cale> uzytkownik: So you create a Haskell datatype which corresponds to the C structure, and then implement sizeOf, alignment, peek and poke (minimally)
04:04:33 <olsner> woah, why is this one using fixIO? peekElemOff addr idx = IOExts.fixIO $ \result -> [...]
04:05:23 <Cale> olsner: In order to refer to the sizeOf the result.
04:05:52 <mm_freak> paper_cc: then i'd need to control the number of threads spawed
04:05:53 <Cale> Er, it's kind of a silly usage
04:06:15 <Cale> olsner: it could also have used scoped type variables which might have been clearer :)
04:06:19 <paper_cc> mm_freak: yes
04:06:50 <mm_freak> paper_cc: i rather have a tree-like thread model, where each thread controls a number of sub-threads and where usually the order of killing is relevant
04:07:05 <Cale> peekElemOff :: forall a. Ptr a -> Int -> IO a; peekElemOff addr idx = peek (addr `plusPtr` (idx * sizeOf (undefined :: a)))
04:07:35 <eivuokko> Yeah, that's a bit funny fix. o.O
04:07:35 <mm_freak> currently i use this idea:  startSomething :: SomethingCfg -> IO (IO ())
04:07:47 <mm_freak> startSomething returns a function, which can be used to kill the thread safely
04:08:02 <mm_freak> that function internally uses an MVar
04:08:58 <paper_cc> mm_freak: I just made something for guarded finally blocks
04:08:59 <paper_cc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5409#a5413
04:10:09 <mm_freak> paper_cc: i go another approach…  all my threads take commands from other threads through an MVar anyway
04:10:16 <mm_freak> so i just added a Quit command
04:10:32 <Reiver> hrn.
04:10:36 <olsner> Cale: maybe you could also use a dummy variable, take the sizeOf that, then use asTypeOf or something to make the dummy have the same type as the result
04:10:42 <Twey> mm_freak: Try throwTo?
04:10:47 <olsner> (if you don't want to use type system extensions)
04:10:47 <Reiver> Cale: Okay, I think I've got the () syntax understood now.
04:10:53 <paper_cc> mm_freak: ah, you poll for commands... then it's good
04:10:56 <mm_freak> Twey: see above
04:11:00 <Reiver> I'm now looking at the prospect of trying to deal with Identifiers.
04:11:06 <mm_freak> Twey: long above that is =)
04:11:18 <Reiver> ... I have no idea where to even start; maybe I've gotten lax but I'm used to having a symbol avalable. ;)
04:11:58 <mm_freak> paper_cc: yeah, i take commands in a 'forever'…  upon Quit, the thread now does cleanup work and then kills itself
04:13:58 <paper_cc> mm_freak: also, there's (maybe) something interesting in http://www.haskell.org/haskellwiki/Concurrency_demos/Graceful_exit
04:14:11 <paper_cc> *interesting for you
04:15:09 * paper_cc DUZ WANT asyncronous signals in the GHC scheduler
04:16:22 <mm_freak> the STM method looks interesting, but this can be done without STM
04:16:43 <mm_freak> i think, i'll go this way for the accepting code
04:17:13 * paper_cc or unsafeYellFeatureRequest#ghc?..
04:17:49 <mm_freak> too impatient for that
04:18:42 <paper_cc> mm_freak: actually it's the third time I see a request for signals on #haskell =)
04:19:21 <Baughn> paper_cc: Hang on, what's wrong with throwTo?
04:20:41 <mm_freak> hmm
04:20:42 <paper_cc> Baughn: see above^W^W"interruptible operations": putStrLn/takeMVar/whatever CAN receive asyncronous exceptions even in scope of a 'block'. imagine receiving a kill signal inside a finally handler
04:20:51 <mm_freak> that was your request, not mine =)
04:21:17 <mm_freak> throwTo works fine to interrupt some blocking operation, but not fine to terminate a thread
04:22:15 <uzytkownik> I cannot find this option - how to remove a package in cabal?
04:22:41 <Baughn> paper_cc: Hmm. I wonder what the rationale for that is
04:22:55 <eivuokko> uzytkownik, you can't really.  Assuming ghc, you have to use ghc-pkg unregister and remove the files by hand.
04:22:59 <dcoutts> uzytkownik: you can unregister a package using ghc-pkg unregister $name [--user]
04:23:10 <paper_cc> uzytkownik: no wonder you can't find it... it doesn't exist. AFAIK the best you can do is ghc-pkg unregister <package>; rm <list-package-files-by-hand>
04:23:11 <dcoutts> uzytkownik: if you want to delete the files too then use rm
04:24:02 <Peaker> Baughn: just read your response on the mailing list and was about to say "a hopefully dead thread" is not a good idea, then I saw you already noticed the problem :)
04:24:27 <Baughn> Peaker: I noticed the problem, which turned out to be a non-problem
04:24:31 <mm_freak> paper_cc: rather than an entirely concept of 'signals' i'd rather like to see an 'abort current blocking operation' function
04:24:32 <paper_cc> Baughn: Control.Exception docs say something about a possibility of deadlock, but this doesn't explain why putStrLn should be interruptible (for me)
04:24:42 <Peaker> Baughn: why not?
04:25:20 <Baughn> Peaker: I'd misunderstood the semantics of unsafePerformIO. After the throwTo, it restarts by executing the /next/ action
04:25:39 <mm_freak> killThread always kills the thread before returning, right?
04:25:41 <Baughn> Peaker: So the exception only ever gets thrown once, which is what we want
04:25:53 <paper_cc> mm_freak: yes
04:26:04 <mm_freak> k, that's useful
04:26:05 <Peaker> Baughn: so throwTo is just to avoid the synchronous exception thing, as in the next reply?
04:26:14 <paper_cc> mm_freak: (so my example first prints 10^3 factorials and then "Killed")
04:26:14 <Baughn> Peaker: Yes
04:26:24 <Peaker> Baughn: ah
04:26:45 <Baughn> Peaker: That is to say, because if I used throw/throwIO the exception would be continually re-thrown
04:26:46 <uzytkownik> eivuokko, dcoutts, paper_cc: Thanks.
04:26:55 <paper_cc> @quote fugue
04:26:55 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
04:27:17 <Baughn> Peaker: Meanwhile, the original unamb implementation (apart from incorrectly placing that code in race instead of unamb, and a couple other issues) forgot to /unblock/ before calling throwTo
04:27:21 <Baughn> Making it deadlock
04:27:27 <Peaker> Baughn: yeah
04:27:38 <Peaker> Baughn: that's the original issue I had encountered
04:28:00 <cnwdup> How can I format a DiffTime? Converting it to Int would suffice for me. But I don't know how to do that, either.
04:28:14 <Peaker> @hoogle DiffTime -> Int
04:28:15 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
04:28:15 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
04:28:15 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
04:28:56 <Baughn> cnwdup: It's an instance of Num
04:29:02 <paper_cc> @ty toInteger
04:29:03 <Baughn> So, fromIntegral will do it
04:29:04 <lambdabot> forall a. (Integral a) => a -> Integer
04:29:10 <cnwdup> @ty divMod
04:29:12 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
04:29:19 <Baughn> Or fromFractional if you want better precision
04:29:33 <cnwdup> Baughn, thanks.
04:31:24 <dcoutts> uzytkownik: if you want to help implement cabal uninstall that would of course be great :-)
04:32:43 <uzytkownik> dcoutts: I know. However I have at least a few projects I'm already working on ;) (besides the fact I have a session of exams in a week)
04:33:03 <dcoutts> uzytkownik: good luck with the exams!
04:33:12 <uzytkownik> dcoutts: Thanks
04:33:13 <kynky> in gentoo, i just use hackport, that converts the cabals into ebuilds then just my distro package manager to handle it, thought was an easy way to make sure everything got removed
04:33:41 <dcoutts> kynky: yep, that's a reasonable way of integrating the two
04:34:02 <cnwdup> Baughn, fromIntegral does not have anything to do with the Num class, does it?
04:34:08 <cnwdup> @ty fromIntegral
04:34:09 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:34:24 <cnwdup> I could convert Int to DifffTime, yes. But I'd like to convert DiffTime to Int.
04:35:11 <paper_cc> cnwdup: DiffTime is an instance of Fractional
04:35:14 <paper_cc> @src Fractional
04:35:15 <lambdabot> class  (Num a) => Fractional a  where
04:35:15 <lambdabot>     (/)             :: a -> a -> a
04:35:15 <lambdabot>     recip           :: a -> a
04:35:15 <lambdabot>     fromRational    :: Rational -> a
04:35:29 <paper_cc> oh, sorry, that's not what I wanted :(
04:35:36 * paper_cc dislikes numeric classes
04:35:40 <paper_cc> @src Real
04:35:41 <lambdabot> class  (Num a, Ord a) => Real a  where
04:35:41 <lambdabot>     toRational      ::  a -> Rational
04:35:47 <paper_cc> cnwdup: ^^ that's it
04:36:08 <paper_cc> > toRational $ secondsToDiffTime 123
04:36:10 <lambdabot>   Not in scope: `secondsToDiffTime'
04:36:20 <paper_cc> , toRational $ secondsToDiffTime 123
04:36:22 <lunabot>  luna: Not in scope: `secondsToDiffTime'
04:36:25 <paper_cc> grr
04:36:30 <Baughn> cnwdup: True. Sorry about that.
04:36:30 <cnwdup> paper_cc, I want diffTimeToSeconds. Not the other way round.
04:36:44 <cnwdup> Baughn, np. (:
04:37:44 <hatds> fromEnum?
04:38:20 <cnwdup> hatds, that might work. Thank you. (:
04:38:30 <Peaker> @src Integral
04:38:30 <lambdabot> class  (Real a, Enum a) => Integral a  where
04:38:30 <lambdabot>     quot, rem, div, mod :: a -> a -> a
04:38:30 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
04:38:30 <lambdabot>     toInteger           :: a -> Integer
04:38:40 <Peaker> @src Real
04:38:40 <lambdabot> class  (Num a, Ord a) => Real a  where
04:38:40 <lambdabot>     toRational      ::  a -> Rational
04:39:17 <Peaker> Why is Integral a subclass of Real?
04:39:38 <ivanm> @src Real
04:39:39 <lambdabot> class  (Num a, Ord a) => Real a  where
04:39:39 <lambdabot>     toRational      ::  a -> Rational
04:39:39 <hatds> because things representing integers are things representing reals
04:39:43 <Peaker> Why is Real called Real and not Rational, and the Rational data-type replaced with an instance?
04:39:53 <FunctorSalad> wait, if DiffTime is fractional, I doubt fromEnum will work
04:39:55 <Berengal> Peaker: Real is non-complex
04:40:07 <FunctorSalad> floor . toRational or something?
04:40:18 <Peaker> hatds: wouldn't that make it a sub-type, rather than a sub-class?
04:41:01 <kpreid> Haskell doesn't have subtypes.
04:41:41 <hatds> take note that "Real" is a bit unusual in that instances aren't always capable of representing most real numbers (which is the case for most of the other type/typeclass relationships)
04:41:49 <FunctorSalad> > fromEnum (1%2)
04:41:50 <lambdabot>   0
04:41:56 <FunctorSalad> eh
04:42:23 <dancor_> > fromEnum (13%25)
04:42:24 <lambdabot>   0
04:43:18 <hatds> > fromEnum 100%9
04:43:20 <lambdabot>   100 % 9
04:43:26 <hatds> > fromEnum (100%9)
04:43:28 <lambdabot>   11
04:43:56 <FunctorSalad> Peaker: I guess a more correct sig for the method of Real a would be "Int -> a -> Rational" :)
04:44:04 <FunctorSalad> the frist arg specifying the precision
04:44:28 <Peaker> this class hierarchy sucks :-P
04:44:30 <hatds> well, floats are real but don't have arbitrarily precision
04:44:41 <hatds> *arbitrariy
04:44:50 <hatds> whatever
04:44:52 <hatds> :)
04:45:08 <Peaker> there should be no "Real" class, its impossible to represent Reals
04:45:14 <FunctorSalad> that's not a problem hatds
04:45:33 <hatds> Peaker: see subtle point above.  Ints disprove your claim :)
04:45:50 <FunctorSalad> I mean the semantic would be: "distance(x,toRational n x) < 1/n"
04:46:01 <FunctorSalad> for floats you could always make the distance 0
04:46:50 <hatds> I see what you mean
04:47:23 <hatds> there is a fixed point type/typeclass somewhere which seems like it would be useful
04:50:36 <hatds> showing fractional and floating results is the one big painful thing that sticks out with my experience
04:52:20 <FunctorSalad> printf?
04:52:34 <hatds> hmm?
04:52:55 <FunctorSalad> > printf "%.3f" (1/3)
04:52:56 <lambdabot>   Add a type signature
04:53:00 <FunctorSalad> > printf "%.3f" (1/3 :: Double)
04:53:01 <lambdabot>   Add a type signature
04:53:04 <FunctorSalad> > printf "%.3f" (1/3 :: Double) :: String
04:53:05 <lambdabot>   "0.333"
04:53:08 <FunctorSalad> :D
04:53:25 <hatds> I mean I always want to show fractional/floating results with a specified number of places -- and no trailing zeroes!
04:53:33 <hatds> you can't do that easily
04:53:56 <paper_cc> > printf "%.3f" (1/2 :: Double) :: String
04:53:58 <lambdabot>   "0.500"
04:54:06 <paper_cc> > printf "%3f" (1/2 :: Double) :: String
04:54:08 <lambdabot>   "0.5"
04:54:16 <paper_cc> > printf "%3f" (1/3 :: Double) :: String
04:54:17 <lambdabot>   "0.3333333333333333"
04:54:22 <paper_cc> grr
04:54:27 <paper_cc> > printf "%3.3f" (1/2 :: Double) :: String
04:54:29 <lambdabot>   "0.500"
04:54:58 <hatds> hey, neat
04:55:41 <FunctorSalad> there a dynamic version in Text.Printf and a TH one in Text.Printf.TH
04:56:59 <Twey> Ooooh!
04:57:02 <Twey> TH printf!
04:57:05 <Twey> Is it typesafe?
04:57:25 <FunctorSalad> yes
04:57:29 <Twey> :-D
05:04:39 <povman> Ideally there'd be a QQ printf
05:05:00 <Baughn> QQ? Ah, quasiquoting
05:05:03 <Baughn> Write one. :D
05:05:45 <ivanm> povman: what would a QQ printf look like?
05:06:04 <ivanm> and what advantage does a TH printf have?
05:07:10 <Berengal> ivanm: Type safety
05:08:41 <ivanm> how does QQ or TH ensure type safety?
05:08:51 <paper_cc> why is [$printf| foobar |] better than $(printf "foobar") ?
05:09:09 <ivanm> also, doesn't TH usage require you to basically run ghci on it?
05:09:11 <paper_cc> ivanm: the generated AST is passed through the normal typechecker
05:09:28 <ivanm> *nod*
05:10:21 <povman> paper_cc: I was thinking something like printf [$format | %3.3f |] etc - because then you can use your own formatting thingy
05:10:25 <povman> syntax
05:10:52 <paper_cc> ivanm: and the result for $(printf "number %d string %s") would have type Int -> String -> String
05:11:09 <ivanm> I take it $(..) is QQ?
05:11:25 <paper_cc> ivanm [$name| <quoted> |] is QQ
05:11:35 <paper_cc> ivanm: $(...) is a splice
05:11:58 <povman> I'm very impressed with the dynamic version actually
05:12:01 <ivanm> oh, I thought the [..] stuff was TH
05:12:05 <ivanm> paper_cc: what's a "splice"?
05:12:25 <povman> I think [| ... |] is TH
05:12:27 <Twey> It executes the given code and inserts its result into the code at that point
05:12:31 <paper_cc> ivanm: $(foo ...) means "call foo with arguments (...) and put the result here
05:12:33 <ivanm> povman: ahhh
05:13:08 <povman> Oh - what's [| |] then?
05:13:33 <povman> I think [| |]  is like [$haskell |  |]
05:13:47 <paper_cc> ivanm, povman: [| ... |] (or [d| ... |], or something else with one character) is the inverse of $( ... )
05:14:10 <paper_cc> povman: [$haskellExpr| ... |] rather, but yes.
05:14:13 <povman> put haskell code in, syntax tree comes out?
05:14:13 <Twey> It takes chunk of Haskell and returns an expression
05:14:17 * Twey nods.
05:14:38 <paper_cc> povman: [d| ... |] is [$haskellDef| ... |]
05:15:08 <FunctorSalad> , [|1+1|]
05:15:10 <lunabot>  InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (IntegerL 1)))
05:15:27 <FunctorSalad> nice, it actually runQ's automatically
05:15:40 <paper_cc> , [d| foo :: Int; foo = 1 |]
05:15:42 <lunabot>  SigD foo (ConT Int)
05:15:42 <lunabot>  ValD (VarP foo) (NormalB (LitE (IntegerL 1))) []
05:16:22 <paper_cc> , [p| x |]
05:16:24 <lunabot>  luna: Tempate Haskell pattern brackets are not supported yet
05:16:30 <paper_cc> s/yet/still/ :(
05:16:56 <FunctorSalad> , [t|gfoldl|]
05:16:57 <lunabot>  luna: Not in scope: type variable `gfoldl'
05:17:01 <FunctorSalad> ;)
05:17:56 <paper_cc> , [t| Integer |]
05:17:57 <lunabot>  ConT Integer
05:18:18 <FunctorSalad> oh, right
05:18:30 <FunctorSalad> it's not :type
05:18:31 <paper_cc> , [$ty| gfoldl |]
05:18:34 <lunabot>  forall a b . Data a => (forall c d . Data d => b (d -> c) ->
05:18:34 <lunabot>                                                 d -> b c) ->
05:18:34 <lunabot>                         (forall e . e -> b e) -> a -> b a
05:19:03 <FunctorSalad> , [t| [$ty|gfoldl|] |]
05:19:04 <lunabot>  luna: parse error on input `ldl|]'
05:19:17 * paper_cc closes his eyes and waits for the horrendous type to scroll up
05:19:25 <FunctorSalad> , [t| [$ty| gfoldl |] |]
05:19:26 <lunabot>  luna: parse error on input `dl |]'
05:19:32 <FunctorSalad> hmm? :(
05:20:16 <paper_cc> o_O
05:20:41 <Saizan> 8~, [t| [$ty| gfoldl \|\] |]
05:20:46 <Saizan> , [t| [$ty| gfoldl \|\] |]
05:20:47 <lunabot>  luna: parse error on input `\] |]'
05:20:51 <Saizan> , [t| [$ty| gfoldl \|] |]
05:20:53 <lunabot>  luna: parse error on input `|] |]'
05:21:15 <paper_cc> , [t| $([$ty| gfoldl |]) |]
05:21:17 <lunabot>  luna: parse error on input `$('
05:21:37 <paper_cc> , $([$ty| gfoldl |])
05:21:40 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
05:22:04 <povman> paper_cc: what would such an expansion do in this context?
05:22:26 <Wraithan> I didn't see it in the JSON module but I was wondering if anyone knew of a function that takes a JSON string, formatted in {"key" "value", "Key" "va;ue"} amd turned it into either a String list or a (String, String) list
05:22:30 <povman> i.e. what is lunabot to do with $( )
05:22:58 <Wraithan> some of the values are not " " else I would just parse it out myself
05:23:12 <paper_cc> povman: well, it was supposed to check if I could QQ inside a $(...)
05:24:01 <povman> Wraithan: You're using json library?
05:24:42 <Wraithan> povman: I have it installed, not sure if that is the library I want to use though, as I just want a simple function like I described
05:24:57 <Wraithan> povman: preferably that uses String pairs in a list
05:25:53 <povman> Wraithan: did you use fromJSObject?
05:25:54 <Wraithan> er, that returns string pairs in a list, it should take a string containing a JSON object as a argument
05:26:36 <povman> oh, you want to read from string and convert
05:26:49 <Wraithan> povman: That askes for a JSString, I am rather new to this, should I use read to convert my string to a JSString?
05:27:36 <povman> Wraithan: It looks like you should use readJSObject
05:28:20 <povman> Wraithan: Something like  runGetJSON readJSObject "{ blah: whatever }"
05:29:09 <povman> This will either return  Left  with some error message, or Right with your object
05:32:29 <Wraithan> Ok, getting closer,thank you
05:33:15 <povman> I suppose the object you get from that is more usefull than a list of (String, String)
05:35:05 <Wraithan> povman: kind of, it lists all the types, while would be useful for some, it isn't really useful to me, at least not at this time
05:35:50 <Wraithan> povman: I appreciate your help, this will get me a lot further
05:35:59 <povman> Yeah it depends what you're trying to do. JSValue is an instance of Show, so it should be pretty simple to convert it.
05:36:24 <povman> np, I've asked for help so many times on here and it's good to help others sometimes!
05:37:14 <Wraithan> povman: that is an option, going to play with this a bit, the type information might be useful later so I shouldn't write it off completely
05:49:31 * paper_cc reads sources for cabal-install
05:49:58 <paper_cc> ... what can (configConfigurationFlags configFlags') mean?..
05:54:04 <ivanm> anyone here use kuribas' indentation mode?
05:54:19 <ivanm> paper_cc: it could mean absolutely nothing... >_>
05:56:43 <ivanm> @tell quicksilver after playing with kuribas' indentation mode, I recall using it once and discarding it because I keep expecting tab to indent no matter where in the line I am (and backspace doesn't unindent the same amount as tab indents either) :s
05:56:47 <lambdabot> Consider it noted.
06:05:28 <olsner> btw, I hacked Data.Binary.Get into a monad transformer for a project of mine, but I'd like to know if using GetT Identity rather than Get affects performance (which is apparently a big thing about the binary package) ... how would I test that?
06:06:15 <olsner> or maybe I should just send a patch to whomever built it and let them worry about making it fast again :)
06:10:43 <paper_cc> @seen dcoutts
06:10:43 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 31m 55s ago.
06:10:56 <Igloo> ...but it doesn't help, because then I need to find out what depends on funsat
06:10:58 <Igloo> Oops
06:11:17 <ivanm> lol
06:21:08 <walter_> >
06:21:23 <walter_> > Just "a"
06:21:25 <lambdabot>   Just "a"
06:21:40 <walter_> >2
06:22:03 <walter_> what on earth doesn "Just" mean?
06:22:13 <leimy> Wow...
06:22:26 <leimy> I can immediately see how I'm going to want a Haskell Google Wave binding  :-)
06:23:27 <kpreid> walter_: Just one string...
06:23:36 <kpreid> @type Just
06:23:38 <lambdabot> forall a. a -> Maybe a
06:23:56 <kpreid> you can think of Maybe as being sort of like a list that has at most one element
06:24:09 <ivanm> a better question: what does "Just" mean _off_ Earth?
06:24:09 <kpreid> > listToMaybe []
06:24:10 <ivanm> :p
06:24:11 <lambdabot>   Nothing
06:24:14 <kpreid> > listToMaybe [1]
06:24:15 <lambdabot>   Just 1
06:24:24 <ivanm> @djinn [a] -> Maybe a
06:24:25 <lambdabot> Error: Undefined type []
06:24:33 <ivanm> dammit, that's right, @djinn doesn't know lists
06:24:40 <kpreid> ivanm: djinn doesn't do lists, because it doesn't do recursion
06:24:48 <ivanm> yeah, I know, I know, I know...
06:24:51 <leimy> , :t flip id
06:24:52 <lunabot>  luna: Couldn't match expected type `((a1 -> b -> c) -> b -> a1 -> c)
06:24:56 <leimy> hmmm?
06:25:01 <ivanm> @type flip id
06:25:02 <lambdabot> forall b c. b -> (b -> c) -> c
06:25:03 <leimy> :t flip id
06:25:05 <lambdabot> forall b c. b -> (b -> c) -> c
06:25:08 <AllNight^> hello all :)
06:25:23 * ivanm does a vague wave-like motion with his hand
06:25:31 <walter_> then why Prelude return Just "a" with Just a, but not a
06:25:38 <ivanm> walter_: hmmm?
06:25:51 <ivanm> the Prelude is a _library_, it doesn't return _anything_! ;-)
06:25:58 <ivanm> > Just "a"
06:26:00 <lambdabot>   Just "a"
06:26:02 <ivanm> @type Just "a"
06:26:04 <lambdabot> Maybe [Char]
06:26:08 <AllNight^> does anyone here know about calling lisp code from haskell / haskell code from lisp?
06:26:12 <ivanm> where [Char] == String
06:26:26 <ivanm> AllNight^: don't recall hearing anything like that
06:26:32 <ivanm> though there is liskell, etc.
06:26:33 <walter_> Why dont return 2 with Int 2
06:26:50 <ivanm> walter_: ummmm... return returns a Monad
06:26:53 <ivanm> Int isn't a Monad
06:26:58 <AllNight^> I've seen liskell ivanm - and a couple of 'write a lisp in Haskell' tutorials
06:27:00 <ivanm> Maybe is a Monad
06:27:08 <walter_> so Just is a Monad?
06:27:09 <Petrosian> H'okey
06:27:15 <ivanm> walter_: no, Maybe is a Monad
06:27:16 <AllNight^> I guess it could be done using the FFI
06:27:20 <ivanm> Just is a constructor for Maybe
06:27:22 <ivanm> @src Maybe
06:27:23 <lambdabot> data Maybe a = Nothing | Just a
06:27:25 <walter_> I see
06:27:27 <AllNight^> but I was hoping for something a little more elegant :)
06:27:36 <ivanm> @src Maybe return
06:27:37 <lambdabot> return              = Just
06:27:41 <ivanm> walter_: ^^
06:27:51 <ivanm> @src [a] return
06:27:51 <lambdabot> Source not found. Do you think like you type?
06:27:53 <walter_> ivanm, thank you
06:27:54 <ivanm> @src [] return
06:27:55 <lambdabot> return x    = [x]
06:27:57 <ivanm> walter_: no worries
06:31:00 <Gracenotes> :O
06:31:42 <ivanm> Gracenotes: what?
06:31:58 <Gracenotes> twist in a TV episode I'm watching
06:32:43 <ivanm> well, are you going to share the TV episode with us?
06:34:45 <Gracenotes> :. I think I'm fine.
07:36:39 * ManateeLazyCat pasted "my code" at http://paste2.org/get/232971
07:36:40 <ManateeLazyCat> In above code, have function `pageClone`, i need use `case ... of` with `PageType`: i need write "Type -> Fucntion (x :: Type)" for different Type, so have a better programming style to fix those problem, those code is ugly. Thanks
07:39:24 <ManateeLazyCat> I wonder have a better way to avoid use "case type of A -> F (x :: A); B -> F (x :: B); C -> F (x :: C)", it can apply Type automatically?
07:41:50 <aavogt> @type asTypeOf
07:41:52 <lambdabot> forall a. a -> a -> a
07:42:49 <aavogt> so maybe   f $ x `asTypeOf` type
07:43:11 <aavogt> ManateeLazyCat: applying the same function, right?
07:43:25 <aavogt> @src asTypeOf
07:43:25 <lambdabot> asTypeOf = const
07:43:26 <ManateeLazyCat> Now my problem is i use `Dynamic` contain `pageBuffer`, but i need transform `Dynamic` to practicality Type, and this programming style is troublesome
07:43:52 <ManateeLazyCat> aavogt: I try it, thanks.
07:44:43 <aavogt> I'm not too familiar with Dynamic, but it does have functions for (safely) coercing Dynamics
07:45:36 <ManateeLazyCat> aavogt: Some haskeller suggestion me use GADTs instead Dynamic, but i don't know how to write right code for my situation.
07:46:06 <ManateeLazyCat> aavogt: But i will try to use `asTypeOf` first...
07:50:53 <dcoutts> paper_cc: pong
07:53:36 <ManateeLazyCat> dcoutts: I have question about gtk2hs, if i have SourceView is a child widget of VPaned, i want VPaned get keyPress action when i type character in SourceView, how do it? Thanks!
07:53:41 <paper_cc> dcoutts: I was just wondering around cabal code and thought that implementing "cabal uninstall" would require cabal-install to store configured versions of packages. But now the whole idea seems a lot more problematic :(
07:53:57 <ManateeLazyCat> keyPress event
07:54:24 <dcoutts> ManateeLazyCat: I'm not sure you can if the SourceView has the focus
07:54:38 <dcoutts> ManateeLazyCat: except perhaps by preventing the SourceView from getting the focus
07:54:59 <ManateeLazyCat> dcoutts: Yep, SourceView has the focus
07:55:02 <dcoutts> ManateeLazyCat: or you could forward the event from the source view perhaps
07:55:56 <ManateeLazyCat> dcoutts: Have a way make Container can get keyPress event when i focus on it's child widget?
07:55:59 <dcoutts> paper_cc: what you'd need for starters is some way of storing the list of installed files
07:56:35 <dcoutts> paper_cc: then a way to get that list during install, and finally of course to use the list to uninstall
07:56:47 <paper_cc> dcoutts: the initial idea was that uninstall is analogous to install and copy
07:57:05 <dcoutts> paper_cc: from the ui pov you mean?
07:57:57 <dcoutts> ManateeLazyCat: I think only by getting the event in the child and then sending it somewhere else. I don't think there's any chain where parent widgets can intercept key press events
07:58:27 <dcoutts> paper_cc: to get the list, yes you'd copy to a temp dir, make the list and then copy to the final location. So it involves an extra copy.
07:58:42 <paper_cc> dcoutts: (about the POV) no. the three commands manipulate the installed files (install and copy against uninstall)
07:59:07 <dcoutts> paper_cc: I don't understand. we've already got copy and install commands
08:00:28 <ManateeLazyCat> dcoutts: If i use EventBox wrap VPand, EventBox still can't intercept key press event before child widget?
08:01:21 <dcoutts> ManateeLazyCat: check the docs for event box, but I'd guess not. The event box is for widgets that do not normally receive events, like labels etc. SourceView is not like that
08:01:37 <mathijs> Hi all, some time ago I got 2 nice practice-programming links from here, 1 was project euler but I forgot the other one. does anyone of other sites like these?
08:02:36 <paper_cc> dcoutts: maybe I am thinking a layer down: make Distribution.Simple implement uninstall analogously to install and copy. It already knows the list of files involved, so no extra copies
08:03:31 <dcoutts> paper_cc: you mean you'd need to be in the original source dir to be able to uninstall something?
08:03:46 <dcoutts> paper_cc: you're not thinking of storing a list of the files that were installed?
08:04:02 <dcoutts> paper_cc: like make uninstall?
08:04:07 <dcoutts> if so I think that's not a good design
08:04:18 <paper_cc> dcoutts: yes, I'm thinking of letting the original cabal script perform the uninstall
08:04:22 <ManateeLazyCat> dcoutts: `Window` is root window of my GUI application, it's TOP parent container, why it can intercept key press event when SourceView is child widget?
08:04:26 <dcoutts> paper_cc: it's harder to use and likely to be very fragile
08:04:47 <dcoutts> paper_cc: any change to the package will mean that the installed version is out of sync and then you cannot uninstall it correctly
08:05:14 <ManateeLazyCat> dcoutts: I use "window `onKeyPress` (\_ -> print $ show "test")", it can intercept key press event.
08:06:04 <dcoutts> ManateeLazyCat: but when you do the same for another container it doesn't?
08:06:23 <ManateeLazyCat> dcoutts: Yep.
08:06:44 <ManateeLazyCat> dcoutts: window `onKeyPress` can work, but panedExample `onKeyPress` can't work.
08:06:59 <paper_cc> dcoutts: is it guaranteed (for any builder) that runhaskell Setup install <=> mkdir temp; runhaskell Setup copy --destdir=temp; cp -R temp/* /; rm -R temp?
08:07:00 <dcoutts> ManateeLazyCat: did you try the event box?
08:07:01 <ManateeLazyCat> panedExample is child widget of `window`
08:07:19 <paper_cc> dccouts: (that is, that install can only create and register things)
08:07:46 <dcoutts> paper_cc: runhaskell Setup can do whatever it likes
08:08:04 <dcoutts> paper_cc: in general, it's a custom script written by the package author
08:08:11 <ManateeLazyCat> dcoutts: No.
08:08:13 <dcoutts> paper_cc: typically it calls into the Cabal lib of course
08:08:20 <ManateeLazyCat> dcoutts: I just test VPaned or HPaned.
08:08:34 <dcoutts> ManateeLazyCat: did you try the event box?
08:08:47 <ManateeLazyCat> dcoutts: No, i have try event box.
08:08:52 <ManateeLazyCat> haven't
08:09:03 <ManateeLazyCat> i haven't try event box
08:09:21 <dcoutts> ManateeLazyCat: because I don't think the panned widgets get events, I expect they're "windowless"
08:10:09 <paper_cc> dcoutts: but there should be some explanation of what 'runhaskell Setup copy' should do in a sensible package (that is, make a "patch" for the root filesystem)
08:10:28 <ManateeLazyCat> dcoutts: So use eventBox wrap Paned is a solution?
08:10:52 <dcoutts> ManateeLazyCat: does it work?
08:11:07 <dcoutts> paper_cc: in a sensible package copy will only copy, nothing else
08:11:28 <ManateeLazyCat> dcoutts: Thanks for your help, i try to use eventBox wrap Paned, then test again. :)
08:11:32 <dcoutts> paper_cc: install will typically copy and register, but sometimes also other post-install actions
08:11:52 <dcoutts> paper_cc: usually not because such post-install actions cannot be done for distro packages
08:12:18 <dcoutts> paper_cc: uninstall should be a feature of the cabal-install program, not the Cabal library
08:12:32 <dcoutts> the Cabal lib can help with collecting the list of things to be installed though
08:12:48 <dcoutts> which can avoid an extra copy in the case of a packages that use build-type: Simple
08:13:05 <paper_cc> dcoutts: post-install actions should be somehow reverted, and how can they be reverted if one knows nothing about them?
08:13:38 <paper_cc> dcoutts: (or just assume that install = copy + register and so uninstall = rm + unregister?)
08:14:06 <dcoutts> paper_cc: yep, we cannot know about other actions
08:14:43 <dcoutts> paper_cc: for custom Setup.hs we would use copy anyway, not install
08:15:05 <wy_> uhh... I forgot to log myself out on my office machine. Is there a command to kick that login out?
08:15:53 <Twey> wy_: /msg nickserv ghost <username> <password>
08:17:19 <wy> thanks a lot!
08:31:24 <Absolute0> Is there an elegant way of getting a number n closer to 0 by 1 unit without checking if its negative in an if else expression?
08:33:08 <Lemmih> max 0 (n-1)?
08:33:30 <Absolute0> 1 unit closer..
08:33:54 <Absolute0> max 0 (any negative) -> 0
08:34:20 <Absolute0> i guess guards will work..
08:34:35 <Shurique> n - signum n?
08:34:40 <jaredj> ^
08:34:52 <Twey> What do you want to happen if n = 0.5 and you subtract 1?
08:35:14 <Absolute0> Twey: no floating point numbers
08:35:35 <Twey> So the only case in which anything special would happen is where n = 0
08:36:07 <Twey> So you can just do foo n = 0 `max` n - 1
08:36:14 <Absolute0> I basically have 2 points and a distance and I want to iterate over all the points from point a to point b
08:36:24 <Absolute0> just to fucking lazy to write if else
08:36:30 <Absolute0> i am sort thinking about performance..
08:36:33 <byorgey> Absolute0: does Shurique's solution above work?
08:37:05 <byorgey> > 5 - signum 5
08:37:06 <lambdabot>   4
08:37:07 <Absolute0> yeah signum works..
08:37:12 <byorgey> > (-5) - signum (-5)
08:37:13 <lambdabot>   -4
08:38:07 <Absolute0> let subOne x = x - signum x
08:42:17 <roconnor> > subOne 0
08:42:18 <lambdabot>   Not in scope: `subOne'
08:42:25 <Absolute0> :-P
08:42:31 <roconnor> > (0) - signum (0)
08:42:32 <lambdabot>   0
08:42:49 <Absolute0> > x = 5
08:42:50 <lambdabot>   <no location info>: parse error on input `='
08:42:54 <Absolute0> > let x = 5
08:42:55 <lambdabot>   not an expression: `let x = 5'
08:43:01 <jaredj> data Foo = Foo { fields i like } what's that thing called again?
08:43:09 <Absolute0> record syntax
08:43:10 <roconnor> @let subOne x = x - signum x
08:43:11 <lambdabot>  Defined.
08:43:12 <jaredj> thx
08:43:18 <roconnor> > subOne 0
08:43:20 <lambdabot>   0
08:43:21 <Absolute0> @ let x = 5
08:43:29 <Absolute0> @let x = 5
08:43:30 <lambdabot>  Defined.
08:43:32 <Absolute0> > x
08:43:33 <lambdabot>   Ambiguous occurrence `x'
08:43:34 <lambdabot>  It could refer to either `L.x', defined at <local...
08:43:42 <Axman6> don't redefine x :(
08:43:57 <Absolute0> sweet lambdabot keeps sessions
08:44:20 <jaredj> good grief. "haskell record syntax" -> seven pages arguing about it, THEN lyah
08:44:30 <EvilTerran> not for very long
08:44:46 <EvilTerran> all @lets disappear if someone does an @undef
08:44:47 <Absolute0> jaredj: i read somewhere that it might be removed in future versions of haskell
08:44:50 <EvilTerran> jaredj, yeah, it's not very popular
08:45:20 <Absolute0> EvilTerran: are function definitions for each field the preferred method?
08:45:29 <Heffalump> improved rather than removed, I hope
08:45:38 <Heffalump> the two big flaws are the name clashes and the non-extensibility
08:45:46 <Heffalump> and perhaps the non-first-class-ness
08:46:01 <jaredj> but how will you parse things into data structures?
08:46:01 <Heffalump> Some kind of record syntax is essential.
08:46:10 <Absolute0> so i should define getters like in Java? :-P
08:46:19 <Heffalump> well, not essential as you can always use tuples, but very useful
08:46:37 <EvilTerran> Absolute0, seeing as the record syntax is part of the language, there's no point not using it where it's appropriate
08:46:50 <EvilTerran> Absolute0, it's just a lot of hot air is expended wrt making it better
08:47:01 <jaredj> yeh it's in haskell 98 right?
08:47:22 <Heffalump> yes, and there are no serious or active proposals to remove it
08:47:34 <jaredj> well - you can't remove it from haskell 98 if it's there
08:47:39 <jaredj> just haskell'
08:47:51 <Twey> The H98 record system is Just Fine®.
08:48:03 <Twey> Leave it alone and stop picking on the poor thing.
08:48:03 <Absolute0> do you need to have a phd to make proposals for haskell 98 improvements? :)
08:48:18 <EvilTerran> Just Fine :: Maybe CouldBeBetter
08:48:45 <Twey> I don't think it can, at least without damaging its beautiful simplicity.
08:49:15 <Twey> There have been all sorts of daft proposals to make it do automatic namespacing of getters and so on
08:49:37 <Twey> That's what we have modules for.  Try them.  They are eager to please.
08:49:54 <Heffalump> modules are a real pain because of the one module per file thing
08:49:55 <Twey> One thing I would like is the ability to have multiple modules in a single file.
08:49:58 <Twey> Yeah.
08:50:09 <Heffalump> I'd think it'd be quite easy to implement, too.
08:50:16 <Twey> With hierarchical records, yeah.
08:50:20 <Heffalump> Now that we have hierarchical modules, just allow defining Foo.Bar in Foo.hs
08:50:25 * Twey nods.
08:50:27 <Twey> Er, modules**
08:50:35 <Absolute0> Doesn't one module per file promote good coding style?
08:50:41 <Twey> Absolute0: No
08:50:49 <Absolute0> why not?
08:50:54 <Twey> I mean, it does in one sense
08:51:03 <Twey> Big modules should have a file to themselves
08:51:13 <Absolute0> people will end up having everything in the same file
08:51:19 <Absolute0> leading to 1000 line files
08:51:21 <Twey> But sometimes you want a collection of small namespaces
08:51:36 <Twey> Personally I would rather have the option
08:51:42 <Heffalump> or an Internal module and an exported API
08:51:46 <Twey> Bad code is bad code.  You can't stop people writing it.
08:51:59 <Twey> Heffalump: That's a nice idea
08:52:21 <Heffalump> it's the main reason I want it, so I can refactor modules without moving most of the contents into a new file
08:53:06 <Twey> Absolute0: Actually, no, it doesn't promote good coding style at all anyway.
08:53:16 <true\false> Absolute0: Proof of fact?
08:53:21 <Twey> There's nothing to stop people putting everything in one file.
08:53:25 <Twey> In one module, even.
08:53:40 <Absolute0> well it at least guides them not to do so :)
08:53:42 <true\false> C#, Java, oh so many languages allow multiple files per equiv of module, and they rarely lump all in one
08:53:43 <Absolute0> damn morons
08:54:04 <Twey> Morons are screwed anyway
08:54:17 <Twey> Give them guiderails if you like, but don't take away power from the rest of us to suit them
08:54:20 <true\false> So are Mormons.
08:54:32 <jaredj> not trusting your users will only get you so far
08:54:50 <Absolute0> jaredj: that what steve jobs does..
08:55:02 <jaredj> i don't buy his stuff
08:55:10 <Absolute0> neither do i
08:55:30 <Absolute0> but he does have a huge market share
08:55:42 <jaredj> i take your point, and my aphorism lives partly in the real world and partly in the world that should be
08:56:44 <Apocalisp> Mormonads
08:56:49 <Absolute0> =)
08:57:10 <Absolute0> for someone interested in haskell is ocaml worth learning?
08:57:44 <Twey> I don't think they have anything over us
08:57:45 <Absolute0> theres this place in nyc janestreet.com, they use ocaml
08:57:53 <Apocalisp> Absolute0: You'll find the syntax infuriating :)
08:58:05 <Philippa> Heffalump: a multiple-module-per-file thing without nesting ought to be trivial to define syntax for, too
08:58:08 <Absolute0> thinking i can't get a job in haskell
08:58:11 <Absolute0> maybe i can in ocaml
08:58:15 <Philippa> what I don't know is how much change to GHC would be required
08:58:17 <Twey> Just strictness and impurity
08:58:32 <Heffalump> the existing syntax is fine
08:58:44 <Heffalump> Absolute0: there's a couple of places in NYC that use Haskell
08:58:59 <shapr> whee
08:59:03 <Absolute0> Heffalump: which job boards do you look at?
08:59:04 <Heffalump> at least two, that is, though one of those definitely isn't hiring now and the other probably isn't
08:59:34 <Heffalump> Absolute0: I don't, since I'm happily employed. I know of them because I work for the first (in London) and have spoken to people at the second.
08:59:36 <Philippa> Heffalump: technically isn't there no syntax for multiple modules in one file? Or did I just not pay enough attention to the report?
09:00:13 <Heffalump> module Foo where ... is only a special kind of where in the sense that there is no indentation required for the ...
09:00:16 <Absolute0> Heffalump: care to give the names?
09:00:23 <Heffalump> Absolute0: Credit Suisse, Deutsche Bank
09:00:29 <Absolute0> thanks
09:00:39 <Heffalump> Philippa: so I don't see any bar to parsing module Foo where ... module Foo.Bar where ... correctly
09:00:43 <Philippa> sure, and that's a layout thing. But I didn't think there was a grammar construct for a sequence of module decls
09:00:50 <Heffalump> surely that's implicit?
09:00:56 <Heffalump> there's no grammar construct for a filesystem either
09:01:14 <jaredj> aagh, i can't easily name my record field id
09:01:18 <Philippa> it's not so much implicit as left for external definition
09:01:28 <Philippa> I mean yeah, we pretty much know what we want, sure
09:01:30 <jaredj> Heffalump: no indentation required??
09:01:32 <Heffalump> that's another way of looking at it :-)
09:01:37 <jaredj> doh
09:01:50 <Philippa> jaredj: yeah, you don't have to indent /everything inside a module/ thankfully
09:01:52 <Heffalump> IM no indentation required by dint of being a subclause of the module...
09:05:45 <jaredj> argh. Text.HTML.TagSoup.Parsec is full of parsers matching open tags and close tags
09:05:54 <jaredj> but how do you parse the TextTags in between?
09:06:36 <jaredj> can't find in docs, and the type system gets angry when i mix TagParsers and generic ones from Text.Parsec.Combinator
09:08:15 <Philippa> yeah, it's a Parsec implementation of TagSoup rather than TagSoup-for-Parsec, isn't it?
09:09:19 <jaredj> no, the latter
09:09:39 <jaredj> i.e. you take the output from parseTags and feed it into your TagSoup.Parsec parser as the tokens
09:10:18 <jaredj> as such, i expected to be able to use the Text.Parsec.Combinator parsers
09:10:33 <jaredj> maybe i haven't dug deep enough
09:13:46 <jaredj> expected ParsecT s u m t; inferred Text.ParserCombinators.Parsec.Prim.GenParser Tag () t
09:14:03 <jaredj> GenParser tok st = Parsec [tok] st
09:14:06 <EvilTerran> jaredj, ahh, ParsecT is parsec 3, GenParser is parsec 2
09:14:21 <jaredj> that explains things...
09:14:50 <jaredj> tagsoup-parsec Dependencies: base, parsec (<3), tagsoup
09:16:07 <jaredj> so if i import things from Text.ParserCombinators.Parsec.[...] instead of Text.Parsec
09:32:13 <azdtt> hi, is there any easy way to print a Floating number without using scientific notation, just with all the decimals or rounding/truncating the number?
09:32:59 <uzytkownik> I have a function returning const char *. How should I do marshalling to not free the result?
09:34:37 <sbahra> azdtt, you could use printf, see "f" specifier.
09:34:47 <sbahra> azdtt, Text.Printf
09:34:57 <sbahra> > printf "%f" 0.0001
09:34:58 <lambdabot>   Add a type signature
09:35:03 <sbahra> > printf "%f" 0.0001 :: String
09:35:05 <lambdabot>   "0.0001"
09:35:11 <sbahra> > show 0.0001
09:35:13 <lambdabot>   "1.0e-4"
09:35:37 <azdtt> ok thanks
09:40:43 <mux> azdtt: or use showFFloat
09:40:59 <sbahra> :t showFFloat
09:41:00 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
09:41:05 <mux> > showFFloat Nothing 0.12345
09:41:06 <lambdabot>   Overlapping instances for GHC.Show.Show
09:41:06 <lambdabot>                              (GHC.B...
09:41:16 <mux> > showFFloat Nothing 0.12345 ""
09:41:17 <lambdabot>   "0.12345"
09:41:24 <mux> > showFFloat (Just 2) 0.12345 ""
09:41:26 <lambdabot>   "0.12"
09:41:28 <sbahra> > show FFloat Nothing 0.1234 "crap"
09:41:30 <lambdabot>   Not in scope: data constructor `FFloat'
09:41:35 <sbahra> > showFFloat Nothing 0.1234 "crap"
09:41:37 <lambdabot>   "0.1234crap"
09:41:42 <azdtt> in which module is showFFloat?
09:41:49 <sbahra> @hoogle showFFloat
09:41:50 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
09:41:54 <sbahra> printf seems nicer.
09:41:58 <mux> @index showFFloat
09:41:58 <lambdabot> Numeric
09:42:05 <mux> printf is nicer but printf is unsafe
09:42:11 <Badger> @src signum
09:42:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:42:28 <sbahra> Fair enough. :-)
09:42:36 <mux> uzytkownik: usually with peekCString
09:43:36 <azdtt> is it possible to map printf to a list of Floating?
09:43:41 <uzytkownik> mux: Thanks. It's documentation did not stated anything about freeing.
09:44:02 <mux> uzytkownik: what do you mean exactly about that freeing stuff?
09:44:16 <mux> if the function returns a malloc()'ed string and you peekCString it, you still need to free it
09:44:38 <sbahra> azdtt, why not?
09:44:45 <sbahra> > map (printf "%f") [0.001, 0.002] :: [String]
09:44:46 <lambdabot>   ["0.001","0.002"]
09:45:22 <aavogt> @type printf
09:45:23 <lambdabot> forall r. (PrintfType r) => String -> r
09:45:25 <uzytkownik> mux: I mean that I cannot free it (unless I love core dumps). And documentation does not state if it dispose the argument or not.
09:45:40 <azdtt> thanks sbahra , without the signature it failed
09:45:58 <mux> uzytkownik: how would C code deal with that string?
09:46:13 <uzytkownik> mux: It does not deal. It returns it
09:46:18 <aavogt> > printf "%f" 1e10 :: IO ()
09:46:20 <lambdabot>   <IO ()>
09:46:39 <mux> uzytkownik: I'm asking you how would C code using that function would deal with it, so that I can give you advice on how to deal with it in haskell
09:49:49 <uzytkownik> mux: Sorry. I don't understend. I have a function in C - lets call it "const char *give_me_a_string(...)". In Haskell I want to use it importing it with type :: ... -> CString. I wanted to convert to String knowing that I cannot free it (it is used and managed by C code). As the documentation (at least ghc's) did not stated anything about freeing I prefered to ask then have segfaults (or worst undefined behaviours).
09:50:53 <mux> uzytkownik: ok, so the memory management of the string is dealt with by the C code and you don't need to do anything about it, so you can just peekCString it
09:51:06 <mux> but the type of your function will be ... -> IO String
09:53:23 <eivuokko> You can import functions as pure, as well.  Although in this case it hardly matters as peeking is in IO.
09:54:09 <eivuokko> In fact, I wouldn't be suprised if his function is as pure as you get, since it returns CString that doesn't need lifetime-control.
09:54:20 <SamB> eivuokko: which is why unsafePerformIO is in the FFI library ...
10:00:11 <mpwd> Hey haskell
10:00:36 <byorgey> hi mpwd
10:00:44 <mpwd> So in about a week, we're getting ready to teach a class on functional programming here in Hanoi
10:00:54 <mpwd> (as part of Thomas Hales flyspeck project)
10:01:12 <Heffalump> time for some programs with discs and towers, then?
10:01:20 <Heffalump> </obvious-joke>
10:01:25 <mpwd> And I was wondering if any of you have some good ideas for intro functional programming problems?
10:02:03 <mpwd> (we should probably do that one... I'd feel silly presenting it though)
10:07:41 <monochrom> The other day I was attending a talk, I got bored, and I took out three coins and played.
10:07:56 <defun> Just curious, how do FRP frameworks like Yampa, etc. keep track of time? Is it via I/O?
10:08:50 <davidL> how can I go from a list of functions [f,g,h] to f . g . h ?
10:08:52 <Cale> defun: At present, that's perhaps ultimately true, but they provide a more abstract interface to the current time.
10:08:58 <Cale> davidL: foldr (.) id
10:09:07 <defun> I see.
10:09:21 <davidL> hmm, foldr1 wasn't doing it
10:09:23 <davidL> thanks
10:09:33 * thoughtpolice attempts to build valgrind for Mac OS X
10:09:42 <Cale> davidL: If there's a possibility that the list is empty, you should never use foldr1
10:10:00 <davidL> right, thanks
10:11:44 <Cale> defun: They might also provide access to something like the current frame number, which would just be a counter, and not involve doing any actual I/O of course :)
10:14:02 <conal> defun: i could probably answer, but i'm unclear on what you mean by "keep track of time".
10:15:13 <conal> defun: semantically, frp keeps track of time in the same way any function keeps track of its argument.
10:16:39 <conal> defun: implementations usually do the same (time is a function argument)
10:18:16 <conal> since frp semantics is simple, precise & deterministic, it can't depend on IO
10:23:08 <saml> i can help your problem
10:23:53 <byorgey> saml: ?
10:24:25 <eivuokko> My problems don't need help, they are big enough already.
10:25:04 <saml> that was a random greeting
10:25:28 <aavogt> conal: so how is the internal use of System.IO.Unsafe stuff not leak out?
10:26:46 <conal> aavogt: not sure i understand what you're asking.  are you asking how i keep unsafePerformIO from compromising functional semantics?
10:32:41 <conal> defun: did i address your frp question?
10:34:03 <aavogt> conal: yeah, though it seems mostly used for racing threads where it doesn't matter which one wins
10:34:29 <aavogt> right?
10:34:46 <conal> aavogt: right.  oh.  i guess you're asking about unamb.
10:35:22 <conal> aavogt: that was a key aha! for me.  my puzzle was how to get deterministic semantics out of a nondeterministic thread scheduler.
10:35:59 <conal> i noodled over that problem for quite a while before the idea of unamb hit me, along with its use in reactive.
10:36:33 <conal> doodled, paced, and talked to myself for several days.
10:37:24 <thoughtpolice> conal: cool to see reactive development going smooth again!
10:37:36 * thoughtpolice needs to get lazysmallcheck working with GHC HEAD so he can install reactive-0.11
10:38:27 <conal> thoughtpolice: :)  "going smooth" might be an overstatement.  i'm still wondering what can be a sustainable model for getting reactive and some other libs into solid shape.
10:40:14 <cayennext> Currently I am trying to implement a functional language interpreter in Haskell. I have choosen Dialogs as IO implementing method. It's based on two lists - list of requests (read,write) and list of responses. Having list of requests I am trying to build the second list, but it involves IO, so type is IO (). How can I write a function that returns both IO and list?
10:41:56 <saml> IO [a] ?
10:41:59 <Twey> cayennext: Return an IO [Response]
10:42:21 <Absolute0> Is there a way to express a pattern where 2 parameters are equal? let foo x x = ... fails
10:42:34 <tromp> nope
10:42:39 <Twey> Absolute0: let foo x y | x == y = ...
10:42:42 <saml> let foo x y | x == y
10:42:43 <tromp> need guard or test
10:42:51 <cayennext> and how to get this argument from IO [Response]?
10:42:52 <Absolute0> quards are ugly
10:43:08 <saml> cayennext, arg <- command
10:43:09 <Absolute0> saml: shouldn't you be coding?
10:43:16 <conal> anyone know why these non-linear patterns tend not to be supported in functional languages?
10:43:28 <cayennext> thank you, I'll try it.
10:43:39 <saml> just finished one module Absolute0
10:43:58 <Cale> Well... it is possible to make a mistake where you accidentally reuse a variable name in a pattern
10:44:34 * Absolute0 dreams of a language with no condition checking
10:44:51 <Cale> and then it's possible that it's even the same type, and in Eq, and so the problem isn't caught until runtime when you get a pattern match failure because your cases are incomplete :)
10:45:00 <thoughtpolice> guards are useful IMO
10:45:04 <thoughtpolice> view patterns are nice as well
10:45:10 <Cale> But otherwise, it's quite doable.
10:45:10 <thoughtpolice> although it's really annoying GHC throws warnings for it
10:45:11 <Absolute0> but patterns rule
10:45:32 <Cale> Guards are part of patterns, more or less...
10:45:46 <Absolute0> i mean foo 0 1 =
10:45:48 <Cale> Every place where a pattern is allowed, guards are too.
10:46:08 <Cale> thoughtpolice: Yeah, also the syntax is broken.
10:46:23 <eivuokko> Except lambda and do notation?
10:46:28 <Absolute0> Cale: isn't that in only function headers?
10:46:35 <thoughtpolice> Cale: SPJ says it gives a shift/reduce in the parser for a change (or something,) but it shouldn't require really deep knowledge
10:46:47 <Absolute0> _ == _ is an illegal expression
10:46:59 <thoughtpolice> Cale: they're useful, though
10:47:00 <monochrom> > (\ x | x>0 -> x) 2
10:47:02 <lambdabot>   <no location info>: parse error on input `|'
10:47:09 <Cale> hmm, I suppose that's true.
10:47:13 <thoughtpolice> Cale: on that note, I like all the new record features (puns, disambiguation etc.)
10:47:41 <Absolute0> condition checking is error prone
10:47:43 <Cale> thoughtpolice: Yes, it was about time they brought record punning back.
10:47:49 <monochrom> > do { x | x>0 <- [2,0-1]; return x }
10:47:50 <thoughtpolice> 'back'?
10:47:51 <lambdabot>   <no location info>: parse error on input `|'
10:47:59 <Cale> thoughtpolice: Yeah, it went away at some point.
10:48:00 <monochrom> Interesting
10:48:22 <aavogt> should record puns really trigger warnings for shadowed names?
10:48:45 <Cale> aavogt: I would say no, but they do shadow names.
10:48:59 <Philippa> <conal> anyone know why these non-linear patterns tend not to be supported in functional languages? <- they're potentially misleading? Also, they're not available on as wide a range of types because they desugar into == guards
10:49:00 <Cale> (in particular, they shadow the field extractors)
10:49:21 <Cale> Compiling with -Wall is irritating. A lot of the warnings are stupid.
10:50:08 <aavogt> I guess those selectors could be fully qualified if you need the original ones when they are shadowed
10:51:07 <conal> Cale, Philippa: could be.  i wonder if there were other reasons.
10:51:12 <Baughn> Cale: It also leads to my using hungarian notation to avoid shadowing
10:51:12 <Cale> Philippa: Those are reasonable reasons, though we do have n-patterns which are fairly uncontroversial and similar in terms of requiring Num and Eq. The best reason I found when examining it in the past was that if you reuse a variable by accident it's harder to catch.
10:51:32 <Philippa> conal: well, the sugar's a pain in the arse to write :-)
10:51:34 <thoughtpolice> Cale: but yeah, the view pattern warnings are *really* annoying; there's a flag to turn it off, -fno-warn-overlapping-patterns iirc
10:51:35 <Baughn> ..though that /has/ caught several possible errors. SHadowing /is/ a bad idea
10:51:46 <Philippa> but you could always ask someone from the committee of old why that choice in Haskell?
10:53:04 <thoughtpolice> Cale: yeah, we compile lhc with -Wall and a lot of patterns are really annoying
10:53:14 <thoughtpolice> s/patterns/warnings/
10:53:49 <Absolute0> -Wall just helped me clean up my code :)
10:53:53 <thoughtpolice> most are fixable, except the functions generated by template haskell
10:54:02 <thoughtpolice> which warns about no type signatures
10:55:42 <monochrom> The most important utility of shadowing is in exams to trick students.
10:55:47 <aavogt> Cale: I'd expect that confusing the record selectors with the puns would be a type error
10:56:24 <Cale> aavogt: yes, typically.
10:59:00 <Baughn> @seen nominolo
10:59:01 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc, #haskell-in-depth and #haskell 5h 3m 55s ago, and .
10:59:26 <Baughn> @ask nominolo Is Scion going to make it to hackage?
10:59:26 <lambdabot> Consider it noted.
11:06:16 <eivuokko> Is it silly to stay in (near) Haskell 98-compatible nowdays?
11:08:56 <thoughtpolice> i use extensions somewhat liberally, myself
11:09:53 <thoughtpolice> not sure i would say staying haskell98 is silly, though
11:10:25 <thoughtpolice> eivuokko: also, invariably many packages on hackage use them, which is important to remember
11:10:25 <Baughn> eivuokko: Pretty much. You'd have to do without more or less every library on hackage.
11:10:42 <Baughn> It's not just the extensions; Haskell'98 lacks the base library too
11:11:20 <eivuokko> Yeah, meant on language level, choosing libraries depends how much the interface uses extensions.
11:20:35 <aavogt> @hoogle [a] -> Int -> a
11:20:36 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:20:36 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:20:36 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:20:41 <aavogt> @hoogle [a] -> Int -> Maybe a
11:20:41 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:20:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:20:41 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:21:25 <aavogt> @type \n -> listToMaybe . drop n
11:21:27 <lambdabot> forall a. Int -> [a] -> Maybe a
11:22:33 <aavogt> is there some alternative, or do I have to make a safe index like that?
11:37:24 <rubendv> > let b = sqrt
11:37:25 <lambdabot>   not an expression: `let b = sqrt'
11:37:40 <rubendv> hm well
11:37:50 <rubendv> if you type 'let b = sqrt' in ghci
11:37:56 <rubendv> and then :t b
11:38:01 <rubendv> you get Double -> Double
11:38:10 <rubendv> but sqrt is Floating a -> a -> a
11:38:13 <rubendv> why is that?
11:38:21 <aavogt> rubendv: ghci let bindings are like in do blocks
11:38:51 <rubendv> and why does it do that in do blocks?
11:38:54 <aavogt> and your second concern is that ghci defaults types
11:39:06 <aavogt> > show 4
11:39:07 <lambdabot>   "4"
11:39:25 <rubendv> I see
11:39:54 <aavogt> @type 4
11:39:55 <lambdabot> forall t. (Num t) => t
11:40:02 <aavogt> @type 4.5
11:40:04 <lambdabot> forall t. (Fractional t) => t
11:44:00 <BMeph> I still think that (!!)'s type is false advertising - if you say "as!!(-1)" it doesn't give you the last element in the list, it just gives an error message. Boo! I say, Boo!
11:45:16 <aavogt> BMeph: because "last as" is shorter?
11:46:32 <aavogt> > show (4::Rational)
11:46:34 <lambdabot>   "4 % 1"
11:50:29 <BMeph> aavogt: Okay, wiseacre, what's the "sorted" form for "as!!(-3)", huh? Huh?!? ;p
11:50:47 <BMeph> Err, *"shorter"
11:51:43 <dmwit> not shorter, but more honest: reverse as !! 3
11:51:52 <dmwit> ... or maybe reverse as !! 2
11:52:18 <Baughn> @src reverse
11:52:19 <lambdabot> reverse = foldl (flip (:)) []
11:52:30 <dmwit> After all, why should it be 0-indexed from the front, but 1-indexed from the back?  That seems stupid.
11:53:02 <ray> "because other languages do it"
11:53:15 <dmwit> heh
11:53:25 * aavogt is consistently inconsistent?
11:53:48 <ray> we need a natural number type anyway
11:54:04 <dmwit> Word8
11:54:11 <dmwit> > -1 :: Word
11:54:12 <lambdabot>   18446744073709551615
11:54:22 <dmwit> Not *quite* a natural number type, yes.
11:54:34 <dmwit> But it's as much a natural number type as Int is an integer type.
11:54:37 <dmwit> :t (!!)
11:54:38 <lambdabot> forall a. [a] -> Int -> a
11:54:56 <ray> Ints suck too
11:54:57 <dmwit> [a] -> Word -> a -- this would be more honest, I agree
11:55:03 <aavogt> > (4::Nat)
11:55:04 <lambdabot>   Not in scope: type constructor or class `Nat'
11:55:09 <aavogt> > (4::Natural)
11:55:10 <lambdabot>   4
11:55:33 <dmwit> > 4 < (fix succ :: Natural) -- the fact that this terminates guarantees inefficiency
11:55:34 <lambdabot>   True
11:55:55 <ray> Integers should be the "default", and Ints should be a freely-chosen concession to performance
11:56:09 <dmwit> The default for Integral a is, indeed, Integer.
11:56:17 <aavogt> > genericDrop (fix succ :: Natural) [1..]
11:56:23 <lambdabot>   mueval-core: Prelude.read: no parse
11:56:23 <lambdabot>  mueval: ExitFailure 1
11:56:27 <dmwit> However, it was deemed that Int was big enough for indexing, and therefore you might as well concede performance every time.
11:57:15 <aavogt> > maxBound :: Int -- if your lists are longer than this, you have other performance issues
11:57:17 <lambdabot>   9223372036854775807
11:57:22 <dmwit> exactly
11:57:24 <BMeph> What ray said is really my point - we need a Natural type comparable to Integer. And it needs to be if not the default, more of a default for stuff than Int. Int blows. :\
11:57:41 * dmwit nods
11:57:51 <aavogt> > 1 - 3 :: Natural -- what here?
11:57:52 <lambdabot>   * Exception: Natural: (-)
11:58:07 <dmwit> > -3 :: Natural
11:58:08 <lambdabot>   * Exception: Natural: (-)
11:58:27 <dmwit> It's the only reasonable thing to do with negative numbers, I guess.
11:59:03 <dmwit> other than have a constructor Infinity :: Natural, which doesn't seem very mathematical. =)
11:59:42 <sclv> there's also a case for a type where (1 - 3) = 0
11:59:48 <aavogt> efficiency?
11:59:55 <BMeph> What do we do when we ask for square roots of negative numbers? Even is what we do sucks to you, a similar thing should happen with subtracting Naturals. IMWO, anyway. :)
12:00:06 <sclv> or Maybe Natural...
12:00:17 <dmwit> > sqrt (-3)
12:00:18 <lambdabot>   NaN
12:00:23 <rubendv> aavogt: I get a similar thing in a file
12:00:27 <rubendv> b = sqrt
12:00:29 <BMeph> Er, Even *if
12:00:37 <dmwit> BMeph: eww, you want NaN in your Natural?  Really?
12:00:38 <rubendv> sqrt2f = b 2::Float
12:00:42 <rubendv> that loads fine
12:00:52 <ray> error is better than NaN
12:00:54 <BMeph> dmwit: Similar, not identical. ;p
12:00:58 <rubendv> but if you add: sqrt2d = b 2::Double
12:01:00 <dmwit> ?wiki monomorphism restriction
12:01:01 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
12:01:06 <dmwit> rubendv: Learn it, love it.
12:01:07 <rubendv> it gives another error
12:01:17 <ray> learn it, hate it
12:01:18 <dmwit> The dreaded MR.
12:01:32 <rubendv> ah so we meet at last :p
12:01:33 <ray> learn it, blog about how haskell should lose it
12:01:34 <sclv> > sqrt ((-4) :+ 0)
12:01:35 <lambdabot>   0.0 :+ 2.0
12:01:45 <fracture> if I have a function that takes a value with a given type constructor in its pattern match, is there any performance penalty to re-wrapping it with a data constructor to give the same value to call another function?
12:01:55 <fracture> like foo (Blah asd) = something (Blah asd)
12:02:06 <BMeph> dmwit: If anything, it might give incentive to change that NaN answer for negative sq. roots. :)
12:02:09 <fracture> as opposed to foo blah@(Blah asd) = something (Blah asd)
12:02:11 <dmwit> You can't have type constructors in pattern matches.
12:02:13 <fracture> err blah
12:02:21 <fracture> blah@(Blah asd) = something blah
12:02:21 <dmwit> However, the answer to your question is yes: there is a performance penalty.
12:02:33 <fracture> err sorry; guess that's also a data constructor
12:02:35 <dmwit> But only for "data", not for "newtype".
12:02:42 <fracture> so I should use the @ notation if I wanna avoid that?
12:02:48 <byorgey_> this is what really happens when we do sqrt on negative numbers:
12:02:55 <byorgey_> > sqrt ((-3) :: Int)
12:02:56 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
12:02:56 <lambdabot>    arising from a use of...
12:02:58 <fracture> (I just don't like having two names for the "same" variable there)
12:03:02 <sclv> ghc should really optimize that case...
12:03:05 <dmwit> fracture: And there *has* to be a performance penalty: the type for (Blah asd) may not be the same as the type for blah.
12:03:05 <byorgey_> the same thing should happen when you use (-) on Natural.
12:03:15 <byorgey_> that is, the Num class blows and we need a new one.
12:03:32 * dmwit sides with byorgey_, as always
12:03:39 <fracture> ok
12:03:47 <byorgey_> win 3
12:03:56 <byorgey_> that... was supposed to be prefixed with a / .
12:04:01 <bremner> lose 3
12:04:01 <aavogt> fracture: common subexpression elimination (CSE) should catch that one, as sclv suggested
12:04:22 * sclv doesn't feel like looking at core today, so take the "should" worth a grain of salt.
12:04:40 <dmwit> I promise you it hurts performance.
12:04:43 <dmwit> I've had to fix it myself.
12:04:54 <sclv> i never trust cse to do a damn thing for me in ghc.
12:05:25 <sclv> hackphi idea -- a usable replacement for Num that doesn't drag in all the complexities of the numeric prelude or the other big towers of abstractions?
12:05:35 <dmwit> Hey, there's an idea.
12:05:50 <dmwit> byorgey_: We should invite the Haskell' committee to Hac Phi. =)
12:05:54 <sclv> a simple useable subset of kmett's monoid library, maybe (emphasis on simple!)
12:06:17 <aavogt> what of the class alias proposal, or something similar?
12:06:21 <hatds> reworking Num is better than creating an incompatible typeclass
12:06:35 <sclv> reworking Num involves changing the standard.
12:06:42 <dmwit> Actually, Edison does something interesting for class aliasing.
12:07:05 <sclv> haskell', by the way, is for language changes and extensions. as i recall, the library process is a "step 2".
12:07:09 <dmwit> He does something along the lines of "class (Foo a, Bar a) => FooBar a where; instance (Foo a, Bar a) => FooBar a".
12:07:10 <ksf> reworking Num's is a good idea.
12:07:25 <sclv> speaking of which, whatever happened to the new haskell' proposal presented at last year's icfp?
12:07:46 <ksf> ...starting with means to combine different monoids to get something confusing.
12:07:51 <wli> Feh, can we get some Haskell 2 proposals?
12:08:08 <sclv> about making it a more community driven process or somesuch.
12:08:57 <aavogt> dmwit: what's the benefit of having to manually declare alias instances?
12:10:08 <dmwit> aavogt: hm?
12:11:19 <dmwit> aavogt: I don't understand; how would you do class aliases without class alias declarations?
12:11:58 <aavogt> dmwit: sorry, I misread what you originally wrote
12:12:53 <aavogt> I don't see any shorter way of accomplishing aliases for classes
12:25:02 <byorgey_> dmwit: good idea =)
12:25:22 <byorgey_> win 4
12:25:33 <byorgey_> ok, seriously, there must be something wrong with my / key
12:26:00 <thoughtpolice> hm
12:26:12 * thoughtpolice wonders about the status of class alias work at the last hackathon
12:38:55 <int-e> byorgey++ ("The key to understanding monads is that they are Like Burritos.", http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)
12:39:42 <ksf> @quote wadler
12:39:42 <lambdabot> wadler says: Curried food and curried functions are both acquired tastes
12:39:44 <ksf> @quote wadler
12:39:44 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
12:39:46 <ksf> @quote wadler
12:39:46 <lambdabot> wadler says: Curried food and curried functions are both acquired tastes
12:39:47 <ksf> @quote wadler
12:39:48 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
12:39:50 <ksf> hmmm.
12:41:47 <ksf> @remember wadler A monad is a monoid in the category of endofunctors, what's the problem?
12:41:47 <lambdabot> Nice!
12:48:21 <int-e> @quote fuzzy
12:48:21 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
12:50:15 <fracture> I have a [[Int]], and I want a function that returns [[Int]] containing any elements that contain at least one int that is in no other lists in the list
12:50:19 <fracture> (if that makes sense)
12:50:23 <fracture> anyone have any ideas on that?
12:50:34 <fracture> (it's seeming tough for me thus far)
12:51:29 <fracture> so like, theFunc [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]] would return [[1,2,3,4]]
12:52:21 <Heffalump> do something with zip (inits xs) (tails xs) I guess
12:52:38 <fracture> I just had an idea... maybe I can concat the list and count the occurances of each item
12:54:19 <Heffalump> oh, yes, nice
12:54:26 <Heffalump> assuming that the input lists don't have any duplicated elements themselves
12:54:49 <aavogt> @src nub
12:54:49 <lambdabot> nub = nubBy (==)
12:54:56 <aavogt> @src nubBy
12:54:56 <lambdabot> nubBy eq []             =  []
12:54:56 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:56:17 <fracture> Heffalump: yeah they won't
12:56:22 <fracture> (they're effectively sets)
12:57:03 <Heffalump> > map (head &&& length) . sort . concat $ [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
12:57:05 <lambdabot>   No instance for (GHC.Num.Num [a])
12:57:05 <lambdabot>    arising from the literal `1' at <inter...
12:57:14 <Heffalump> > map (head &&& length) . group . sort . concat $ [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
12:57:16 <lambdabot>   [(1,1),(2,3),(3,4),(4,4),(5,2)]
12:58:16 <fracture> what's &&& ?
12:58:31 <centrinia> :t (&&&)
12:58:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:58:57 <aavogt> > (+1) &&& (+2) $ 0
12:58:58 <lambdabot>   (1,2)
13:01:47 <aavogt> > nubBy (\x y -> null $ y \\ x) [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
13:01:48 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4,5]]
13:02:03 <aavogt> > nubBy (\x y -> null $ x \\ y) [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
13:02:04 <lambdabot>   [[1,2,3,4],[2,3,4,5]]
13:03:24 <centrinia> > nubBy (\x y -> null $ x \\ y) [[1,2,3,4], [2,3,4,5], [3,4,5],[2,3,4]]
13:03:25 <lambdabot>   [[1,2,3,4],[2,3,4,5]]
13:03:49 <aavogt> the nubBy doesn't accumulate the values already seen
13:05:19 <matt> I'm trying to apt-get ghc6, and i get version 6.8
13:05:26 <matt> instructions on haskell.org say otherwise
13:06:11 <aavogt> > foldr (\x xs -> if null $ x \\ concat xs then xs else x:xs) [] [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
13:06:12 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5]]
13:06:38 <aavogt> > foldr (\x xs -> if null $ x \\ concat xs then xs else x:xs) [] $ reverse [[1,2,3,4], [2,3,4], [2,3,4,5], [3,4,5]]
13:06:39 <lambdabot>   [[2,3,4,5],[1,2,3,4]]
13:06:43 <eivuokko> matt, maybe you are in old version of your disribution?
13:07:05 <matt> i'm using the latest stable version of debian, it is probably lagging behind though
13:07:21 <matt> I'll try to manually install 6.10 i think
13:13:29 <mreh> is "tar -xvvf" different from "tar -xvf"?
13:14:00 <mike-burns> On BSD it is.
13:14:17 <mike-burns> "Additional -v options will provide additional detail." - from the man page
13:14:48 <mike-burns> Is this a decent channel to ask about Gtk2hs issues?
13:15:24 <mreh> tar -xvvvf?
13:15:26 <mreh> hehe
13:15:52 <aavogt> mike-burns: ask away
13:16:44 <mike-burns> I'm trying to build a GUI app using Glade and Gtk2hs. I made a GnomeApp window, but when I run the program it tells me: GnomeUI-ERROR **: You must call gnome_program_init() before creating a GnomeApp
13:16:52 <mike-burns> How do I do that in Gtk2hs? Or am I doing it wrong?
13:17:39 <dcoutts> mike-burns: avoid using the gnome widgets in glade, stick to the gtk+ ones
13:18:08 <dcoutts> mike-burns: it's no great loss anyway, the gnome ones hardly add anything
13:18:47 <mike-burns> dcoutts: Good to know. I'll try again with a window and add the menu, etc, myself.
13:26:27 <mreh> hang on, I install 6.10, and I dont have cabal installed
13:26:43 <mreh> whut?
13:27:11 <dcoutts> mreh: perhaps you're thinking of the Haskell Platform which bundles ghc along with the cabal program and other tools and libs
13:27:19 <mreh> scunthorpe
13:27:24 <dcoutts> ghc on it's own is just the compiler (and some libs)
13:27:46 <mreh> ah, it's alright, i need 6.10 to get yi working anyway
13:27:46 <dcoutts> mreh: but you can install the cabal-install package, which provides the 'cabal' program. It's not hard.
13:27:56 <mreh> dcoutts: thanks
13:28:02 <ray> you should have cabal the library, but not cabal the binary from cabal-install
13:30:07 <mreh> do haskell binaries get installed using ghc?
13:30:23 <mreh> i'm not experienced enough to know how package managers work
13:31:43 <ksf> libraries register themselves with ghc-pkg.
13:31:53 <Peaker> Baughn: apparently even the unblock thing was not a bug. But man, this mailing list exchange better be summarized in those comments, heh
13:31:57 <ksf> ...aside from that, ghc doesn't care.
13:49:37 <mike-burns> More on Gtk2hs: I've created a window using Glade and put a menubar in there. I'm trying to connect File -> Quit to `mainQuit' but it's not totally clear how. I looked at the actionMenu example that comes with gtk2hs but that's not what Glade outputs. I think.
13:51:39 <dcoutts> mike-burns: you cannot set handlers from within glade
13:51:47 <dcoutts> that only works for C
13:52:09 <mike-burns> How can I set a handler from Haskell?
13:52:10 <dcoutts> mike-burns: take a look at the glade demo that comes with gtk2hs, or see the glade tutorial on the gtk2hs website
13:52:41 <dcoutts> mike-burns: actually the tutorial is probably best, it explains how to set handlers
13:53:46 <mike-burns> Is `onClicked' the function I need?
13:55:23 <int-e> Use onActivateLeaf for menu entries.
13:55:35 <mike-burns> int-e: Thank you.
14:25:48 <Baughn> Peaker: I wonder about that. I mean, /something/ caused it to malfunction in recursive unambs..
14:29:00 <Baughn> Peaker: I'm learning a lot from this, at least. Especially about physics..
14:49:27 <defun> conal: sorry, I fell asleep at my keyboard before I read your messages. You seem knowledgable on the subject of FRP. Perhaps you could recommend some papers/resources that would help me build some fundemental knowledge of how FRP works in general?
14:51:26 <conal> defun: there are various angles: conceptual paradigm (mind-space), semantics, examples, implementation.
14:51:52 <conal> defun: i could, e.g., point you to the orignal papers and later ones.
14:52:09 <aavogt> @src putStrLn
14:52:09 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
14:52:26 <conal> defun: or tell you about its history.
14:54:13 <conal> defun: btw, i invented frp.
15:02:04 <BMeph> Heh-heh, conal : FRP :: augustss : Haskell implementation
15:02:23 <enolan> Is there a way to launch ghci with options derived from a cabal file? Extensions are set the same as when building the package, the same packages are in scope, etc
15:03:21 <Saizan_> enolan: no automated way yet, but there's a ticket on cabal-install's trac about it, iirc
15:03:37 <Saizan_> enolan: it shouldn't be hard to implement
15:04:22 <mreh> manually compiling these binaries is taking forever, is linking a memory intensive operation?
15:05:32 <enolan> Alright. Too bad.
15:05:34 <mreh> my laptop only has 256mb of memories
15:05:41 <inimino> conal: I think I am reinventing FRP... what's a good early paper on the topic?
15:06:33 <conal> inimino: looking ...
15:07:19 <gwern> @remember defun [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
15:07:20 <lambdabot> I will never forget.
15:07:23 <gwern> @flush
15:07:46 <mreh> excellent
15:07:49 <conal> gwern: what's flush?
15:07:54 <conal> inimino: check out http://conal.net/papers .  start with TBAG, ActiveVRML, and functional reactive animation.
15:07:57 <gwern> conal: while you're looking if there's any paper titled 'FRP for people unconvinced of the value of FRP' I'd like that one :)
15:08:04 <gwern> conal: backs up to disk
15:08:12 <conal> inimino: then http://haskell.org/haskellwiki/FRP for more.
15:08:15 <conal> gwern: oh!
15:08:31 <gwern> (as in 'flush buffers/state [to disk]')
15:08:41 <inimino> conal: alright, thanks
15:08:57 <conal> also http://conal.net/fran/tutorial.htm
15:09:55 <inimino> alright
15:10:11 <conal> gwern: hm.  about "unconvinced", my guess is most people will either resonate with FRP right away and need no convincing, or will be quite resistant to the ideas.
15:10:34 <conal> gwern: do you have someone you want to convince?
15:10:37 <mreh> I'm undecided
15:10:59 <gwern> conal: myself, mostly. the ideal seems nice enough, but then when I read your blog posts, I keep thinking 'epicycles'
15:11:28 <conal> gwern: epicycles?
15:11:33 <aavogt> @wordnet epicycle
15:11:33 <lambdabot> Unknown command, try @list
15:11:37 <gwern> 'if this is the right thing, then why does it seem so hard'?
15:11:45 <conal> oh
15:11:48 <mreh> copernican model of the solar system
15:11:48 <defun> conal: thanks.
15:11:52 <mreh> had epicycles
15:12:04 <mreh> ptolmey changed that
15:12:05 <conal> defun: :)
15:12:08 <gwern> mreh: no :) other way around
15:12:15 <gwern> @wn epicycle
15:12:16 <lambdabot> *** "epicycle" wn "WordNet (r) 2.0"
15:12:16 <lambdabot> epicycle
15:12:16 <lambdabot>      n : a circle that rolls around (inside or outside) another
15:12:16 <lambdabot>          circle; generates an epicycloid or hypocycloid
15:12:31 <conal> gwern: a favorite test of mine also.
15:12:31 <mreh> copernican revolution is a phrase that springs to mind
15:12:36 <mreh> any kind of decentering
15:13:08 <gwern> well, copernican systems were more valuable because they were simpler; not because they worked better
15:13:12 <inimino> in 2001 or so I did a lot of thinking about how to build arbitrary 3d stuff with functions alone
15:13:17 <aavogt> hmm, reminded me more of gear arrangments (epicyclic or planetary gearing)
15:13:31 <conal> gwern: about 'so hard', do you meant correct & efficient implementation?  something else?
15:13:47 <inimino> I mean pure functions
15:13:59 <mreh> gwern: to astrologers, yes
15:14:20 <conal> inimino: that's what i've been doing as well.  did you get stuck?
15:14:24 <hatds> sounds tricky, inimino, did you find a answer?
15:14:40 <inimino> I think this is basically what I had in mind (though I don't really know yet)
15:15:01 <inimino> conal: no, I wrote a bunch of text files and then moved on to other stuff; I didn't get as far as getting stuck
15:15:19 <gwern> conal: it's not just the difficulty of getting something sufficient performant, but all the variant frp libraries is scary from not just a dev perspective; there are more ways to accomplish a wrong thing than a right thing
15:16:02 <aavogt> @wn spirograph
15:16:03 <lambdabot> *** "spirograph" wn "WordNet (r) 2.0"
15:16:03 <lambdabot> spirograph
15:16:03 <lambdabot>      n : a measuring instrument for recording the depth and rapidity
15:16:03 <lambdabot>          of breathing movements
15:16:11 <gwern> @more
15:16:30 <conal> gwern: i think iswym.  my personal perspective is that we still haven't found quite the right (graceful) frp formulation.
15:16:35 <mreh> respiration?
15:16:39 <conal> s/formulation/model/
15:17:05 <gwern> mreh: maybe the geometry tool is too recent a term for wordnet
15:17:25 <mreh> gwern: tool?
15:17:40 <aavogt> @go spirograph
15:17:41 <lambdabot> http://en.wikipedia.org/wiki/Spirograph
15:17:41 <lambdabot> Title: Spirograph - Wikipedia, the free encyclopedia
15:17:51 <hatds> what are the base examples where FRP is likely to be used in practice?
15:17:51 <mreh> useful for keeping children quiet
15:17:57 <gwern> conal: but what makes you so confident that there *is* a right formulation?
15:18:34 <conal> gwern: my faith in math / semantics / simplicity
15:18:54 <conal> gwern: i can smell it
15:19:00 <gwern> well, I suppose I can't really argue with faith...
15:19:23 <hatds> (ever heard of kill your darlings?) not that I'm suggesting that at this point
15:19:35 <conal> and i could have said "trust" in place of "faith"
15:21:17 <aavogt> @remember <hatds>: what are the base examples where FRP is likely to be used in practice? <mreh> useful for keeping children quiet
15:21:18 <lambdabot> Nice!
15:21:18 <mreh> is it completely unreasonable for cabal plus zlib and http to take hours to link and compile?
15:21:40 <inimino> this is also where I started
15:21:40 * aavogt is too out of context?
15:21:47 * hatds thinks so
15:21:51 * wli is faithless.
15:21:52 <gwern> mreh: yes, unless you are on a very old box
15:22:05 <gwern> mreh: did you specify split-objs or something odd?
15:22:24 <mreh> i only have 256mb of memories, it must be paging the whole time
15:22:28 <aavogt> @forget <hatds>: what are the base examples where FRP is likely to be used in practice? <mreh> useful for keeping children quiet
15:22:28 <lambdabot> Done.
15:22:33 <gwern> oh, that could do it
15:22:35 <gwern> aavogt: I liked it
15:23:11 <inimino> for example it seems very obvious that we can define things much more simply, but then it takes a lot of intelligence in the system to turn that into something that modern hardware can run fast
15:23:18 <aavogt> gwern: your choice
15:23:19 <hatds> is FRP hoping to be useful for GUIs?  I've been banging my head over gui abstractions lately
15:23:46 <conal> hatds: i've used frp for guis.
15:23:55 <mreh> gwern: my comment was directed @ spirographs
15:23:56 <conal> hatds: and another functional approach i like even better.
15:24:10 <gwern> aavogt: i'd lean to keeping it. it's an amusing putdown
15:24:25 <conal> hatds: http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
15:24:27 <hatds> conal: so GUIs are not your motivation examples for FRP?
15:24:45 <conal> hatds: not my only motivation.
15:24:48 <gwern> and funny since I was reading http://conal.net/fran/tutorial.htm 's intro mentioning kids when you said it
15:25:11 <gwern> hatds: oh, in theory frp seems to be very general. for example, cli utils using 'interact' can be see as FRP
15:25:18 <gwern> *be seen
15:25:31 <mreh> aavogt: stop quoting me out of context!
15:25:50 <gwern> mreh: all quotation is out of context
15:25:53 <defun> conal: Most FRP frameworks (eg: yampa) use the arrows abstraction. Is that strictly neccessary? I find arrows (the syntax) very annoying; but that's just me.
15:26:06 <conal> defun: no.  not strictly necessary.
15:26:34 <conal> defun: like Monad, Arrow is a convenient structuring tool, but has almost no semantic content.
15:26:50 <conal> defun: i think of FRP more in terms of Applicative and Comonad
15:27:11 <defun> conal: Cool. I was about ask you about Applicative.
15:27:31 <conal> defun: btw, have you read "Simply efficient functional reactivity" http://conal.net/papers/simply-reactive/ ?  it's partly about relating FRP to various type classes.
15:27:46 <defun> I see. Bookmarked!
15:28:06 <aavogt> mreh: its gone :(
15:28:17 <gwern> pansies
15:28:29 <conal> defun: i like Applicative.  ask away.
15:28:29 <mreh> it wasn't even funny
15:28:40 <aavogt> @quote funny
15:28:40 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'infinite' datastructures
15:28:53 <gwern> @quote even
15:28:53 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
15:29:40 <mreh> @quote university
15:29:40 <lambdabot> qwe1234 says: it all boils down to standard first-year university-level computational theory.
15:29:55 <aavogt> @quote mreh
15:29:55 <lambdabot> No quotes match. Just what do you think you're doing Dave?
15:30:05 <gwern> @quote aavogt
15:30:05 <lambdabot> No quotes match. There are some things that I just don't know.
15:30:09 <mreh> as it should be
15:30:43 <mreh> can you remember that quote from 1337_h4x0r or whatever his name was?
15:30:52 <mreh> @quote 1337_h4x0r
15:30:53 <lambdabot> No quotes match. I am sorry.
15:31:01 <aavogt> @quote 1337
15:31:01 <lambdabot> No quotes match.
15:31:05 <gwern> @quote 3
15:31:05 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
15:31:19 <gwern> (oh, that's a great quote -_-)
15:31:35 <gwern> does anyone know how to even turn that into a url?
15:31:42 <gwern> googling doesn't work
15:32:04 <mreh> what sending a message to lambdabot asa a url?
15:32:10 <RayNbow`> @quote byorgey zip
15:32:10 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
15:32:10 <lambdabot> like learn $ zip math haskell.
15:32:48 <mreh> genius
15:33:06 <gwern> we were discussing _the haskell road to mathematics_ at the time, iirc
15:33:32 <int-e> mreh: somewhere in here: http://int-e.home.tlink.de/tmp/l33t_h4x0r_on_%23haskell
15:34:03 <mreh> i better not open a browser, I need all the memory i can
15:34:07 <mreh> cheers though
15:34:24 <int-e> use wget and less :P
15:34:44 <mreh> lateral thinking
15:35:35 <gwern> @remember ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture?
15:35:35 <lambdabot> It is stored.
15:35:41 <gwern> @forget ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture?
15:35:41 <lambdabot> Done.
15:35:43 <gwern> ack
15:35:50 <gwern> @remember ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r (n=l33t_h4x@88-104-102-8.dynamic.dsl.as9105.com) has left #haskell
15:35:51 <lambdabot> Okay.
15:36:03 <gwern> even leet hackers don't want to work on ghc ports!
15:36:21 <gwern> hm. probably should remove the hostmask to make it more concise
15:36:24 <gwern> @forget ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r (n=l33t_h4x@88-104-102-8.dynamic.dsl.as9105.com) has left #haskell
15:36:25 <lambdabot> Done.
15:36:32 <gwern> @remember ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r has left #haskell
15:36:32 <lambdabot> Okay.
15:36:58 <mreh> int-e: was that a joke uri?
15:37:58 <int-e> mreh: no.
15:38:09 <mreh> int-e: mistyped ;)
15:38:50 <int-e> no problem.
15:39:46 <mreh> is 1337 someone's alter ego
15:39:49 <mreh> he's too good to be true
15:39:56 <defun> conal: Applicative has a very terse syntax in comparison to arrows/monads, and I've found myself using Applicative in place of Monads in my programs. I've rewritten a bunch of code in my previous programs with Applicative, because applicative simply composes better than Monads/Arrows. It seems to me that for combinators Applicative is well suited, and so naturally, I assumed that it might work well for FRP. I was going to ask you if you
15:40:30 <Cale> defun: your message was cut off at " I was going to ask you if yo"
15:40:41 <defun> 1 sec
15:40:52 <defun> I was going to ask you if you have considered using Applicative, but the answer to that is apparent. I have some more questions, but first I will read some of those papers, so that I don't waste anybody's time. Thanks for your help.
15:42:05 <conal> defun: i'm glad to hear you've gotten hooked on Applicative!  i think a lot of Monad use is just habit on top of historical accident.  Monad was discovered before the simpler & more general Applicative.
15:48:25 <jcazevedo> hi. I'm unable to compile the syslog example on real world haskell in windows, some functions are not in scope
15:48:27 <jcazevedo> any clues?
15:48:36 <sclv> which functions?
15:48:45 <Alpounet> did you look at previous chapters for these functions ?
15:48:59 <jcazevedo> getAddrInfo, defaultHints
15:49:01 <jcazevedo> ...
15:49:03 <jcazevedo> hmm
15:49:35 <jcazevedo> they're from the socket module, I guess
15:49:37 <Alpounet> @hoogle getAddrInfo
15:49:37 <lambdabot> No results found
15:50:26 <sclv> if you import Network.Socket it should work then? as I recall it is cross-platform.
15:51:25 <Alpounet> jcazevedo, do you compile with ghc --make (so that it guesses which modules you're using by itself) ?
15:52:21 <sclv> --make doesn't guess which modules you're using. you still have to declare imports. it just ensures linking happens correctly.
15:53:17 <jcazevedo> I'm declaring the imports, and compiling with ghc --make doesn't solve it
15:53:37 <jcazevedo> from what I've seen on the web, this seems to only happen on windows
15:53:37 <sclv> try :browse Network.Socket from ghci
15:56:39 <sclv> what version of the network package are you using?
15:57:04 <sclv> looking at the documentation on hackage, it looks like those functions were only added in v. 2.1
15:57:30 <jcazevedo> how can I check that? I've just installed ghc 6.10.3
15:57:44 <sclv> then it should be there. hmm.
15:58:49 <Saizan_> jcazevedo: ghc-pkg list network will tell you
15:59:12 <jcazevedo> 2.2.1
16:12:31 <McManiaC> is there something like map for tupels?
16:12:47 <McManiaC> (a -> b) -> (a,a) -> (b,b) ?
16:13:21 <idnar> @pl \f (a,b) -> (f a, f b)
16:13:21 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:13:25 <idnar> ugh
16:13:29 <idnar> @type (&&&)
16:13:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:13:39 <idnar> @type join (&&&)
16:13:40 <byorgey> @type \f -> f *** f
16:13:40 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
16:13:41 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
16:13:57 <idnar> oh, yes, ***
16:13:59 <byorgey> you could do something like that.  probably not worth it though.
16:14:07 <byorgey> McManiaC: the short answer is, 'no' =)
16:14:09 <idnar> heh
16:14:10 <McManiaC> ok
16:14:12 <McManiaC> ^^
16:16:34 <jaredj> jaredj@harpster:~/src-mine/ofx1$ cabal uninstall
16:16:34 <jaredj> unrecognised command: uninstall (try --help)
16:17:39 <byorgey> yeah, there's no such thing
16:17:45 <byorgey> you can unregister packages
16:18:03 <byorgey> ghc-pkg unregister foo
16:18:25 <byorgey> that doesn't actually delete them, but it's the next best thing.
16:18:40 <byorgey> or ghc-pkg unregister --user foo, if it's installed locally
16:19:15 <jaredj> cool.
16:20:11 <jaredj> AWESOME it worked.
16:20:23 <jaredj> no more parsec 3 to provisionally ruin my day
16:31:12 <hatds> why can't you uninstall a package?
16:32:01 <hatds> I mean, I don't really know what's going on under the hood with packages, but is there a simple obstruction?
16:36:39 <Saizan> hatds: cabal doesn't keep track of the files installed, yet
16:36:58 <Saizan> (until someone implements it)
16:37:09 <hatds> so it's a matter of getting around to it, not a design problem with packages
16:37:28 <ray> hehe
16:37:39 <ray> in a way, you can think of it as a design problem with filesystems
16:38:04 <hatds> I like that thinking
16:40:24 <ray> making ghc forget about it does everything but free the disk space
16:40:32 <ray> (if it's a library, anyway)
16:40:51 <ray> and who's in charge of freeing unused disk space? the filesystem
16:44:56 <McManiaC> @pl \f o -> o f
16:44:56 <lambdabot> flip id
16:44:59 <McManiaC> :)
16:50:38 <fracture> what's the most efficient way to determine if all members of a list are the same?
16:50:47 <fracture> (I can think of a lot of ways... just not sure what's idiomatic)
16:51:37 <skorpan> fracture: the easy way is probably something like "(==1) . length . nub"
16:52:03 <fracture> how efficient is nub?
16:52:21 <fracture> I was thinking maybe all (\x -> x == head a) a
16:52:26 <fracture> ... if a is not []
16:52:32 <skorpan> that's another way
16:52:37 <skorpan> but maybe it works even with a == []
16:52:41 <skorpan> @src all
16:52:41 <lambdabot> all p =  and . map p
16:52:46 <fracture> the head fails though, no?
16:52:50 <fracture> ohhhh it won't call the lambda
16:52:51 <fracture> got it
16:52:55 <skorpan> > let xs = [] in all (\x -> x == head xs) xs
16:52:56 <lambdabot>   True
16:52:58 <skorpan> yep
16:52:59 <fracture> ok I'll just do that
16:53:24 <InabaAtsuyoshi> perhaps foldr (==) (head theList) theList
16:53:48 <fracture> but foldr won't short circuit, no?
16:54:04 <skorpan> > let xs = [] in foldr (==) (head xs) xs
16:54:05 <lambdabot>   * Exception: Prelude.head: empty list
16:54:36 <InabaAtsuyoshi> mmm yeah it wont work on an empty list
16:55:08 <skorpan> i'm not sure there's anything to gain using foldr
16:55:17 <skorpan> apart from being slightly prettier
17:01:24 <mux> > let allEq xs = case group xs of (_:_:_) -> False; _ -> True
17:01:25 <lambdabot>   not an expression: `let allEq xs = case group xs of (_:_:_) -> False; _ -> ...
17:01:34 <mux> > let allEq xs = case group xs of (_:_:_) -> False; _ -> True in allEq [1,2]
17:01:36 <lambdabot>   False
17:01:41 <mux> > let allEq xs = case group xs of (_:_:_) -> False; _ -> True in allEq [1,1
17:01:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:01:45 <mux> > let allEq xs = case group xs of (_:_:_) -> False; _ -> True in allEq [1,1]
17:01:46 <lambdabot>   True
17:01:51 <mux> > let allEq xs = case group xs of (_:_:_) -> False; _ -> True in allEq []
17:01:53 <lambdabot>   True
17:08:46 <Gracenotes> :.
17:31:58 <MyCatVerbs> @pl (\x -> if x then '1' else '0')
17:31:58 <lambdabot> flip (flip if' '1') '0'
17:32:41 <MyCatVerbs> @pl (\x -> case x of { True -> '1'; False -> '0'; }
17:32:42 <lambdabot> (line 1, column 18):
17:32:42 <lambdabot> unexpected "{"
17:32:42 <lambdabot> expecting variable, "(", operator or ")"
17:34:35 <xian> @pl (\x -> case x of True -> '1'; False -> '0')
17:34:35 <lambdabot> (line 1, column 23):
17:34:35 <lambdabot> unexpected ">"
17:34:35 <lambdabot> expecting variable, "(", operator or ")"
17:34:58 <Tsion> Can someone join lambdabot to #botters, please? :)
17:48:21 <Qriva> Could someone explain why the function 'simple x y z = x * (y + z)' is typed:  simple :: Integer -> Integer -> Integer -> Integer ?
17:48:44 <Qriva> Is it because it takes 3 integer values and produces an integer result?
17:49:25 <EvilTerran> Qriva, er, yes
17:49:31 <IntergalacticOwl> you'd think so!
17:50:04 <Qriva> EvilTerran: is it more complicated than that? or should I quit reading into it?
17:50:06 <Qriva> :)
17:50:18 <EvilTerran> ?type let simple x y z = x * (y + z) in simple
17:50:19 <lambdabot> forall a. (Num a) => a -> a -> a -> a
17:50:33 <EvilTerran> it's a bit more complicated than that :)
17:50:44 <Qriva> can i do that in ghci EvilTerran ?  (the type let simple...)
17:50:50 <Qriva> EvilTerran: care to try to explain it to me?
17:51:05 <EvilTerran> Qriva, yes, ":type let simple ... in simple" would work
17:51:12 <EvilTerran> but i have to go to bed now, unfortunately
17:51:31 <EvilTerran> i'm sure there's other helpful people awake in here
17:51:33 <Qriva> no worries -- thanks
17:53:02 <Qriva> ?type [(2,3), (4,5)]
17:53:03 <lambdabot> forall t t1. (Num t, Num t1) => [(t, t1)]
17:54:25 <Qriva> ^-What's the proper type of that?  [(Integer)]?
17:54:36 <Qriva> ^-What's the proper type of that?  [(Integer), (Integer)]?
17:55:42 <Zao> Depends on context.
17:55:56 <Zao> Until now, it's just two possibly different types conforming to Num
17:56:21 <Qriva> In the HSoE book he asks that question in an exercise
17:56:29 <Qriva> early in the book
17:56:31 <Zao> The type to use could be inferred by context or by explicit signatures.
17:56:52 <Qriva> Zao: how about ['z', -42]?
17:56:59 <Qriva> [Char, Integer]?
17:57:01 <xian> No.
17:57:09 <xian> It's not an expression.
17:57:22 <Zao> Qriva: That would be broken.
17:57:28 <Qriva> I noticed -42 when you ask for it's type gives you an answer with an a, not a t
17:57:35 <idnar> @type ['z', -42]
17:57:36 <Qriva> ?type ['z', -42]
17:57:37 <lambdabot>     No instance for (Num Char)
17:57:37 <lambdabot>       arising from a use of syntactic negation at <interactive>:1:6-8
17:57:37 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
17:57:37 <lambdabot>     No instance for (Num Char)
17:57:38 <lambdabot>       arising from a use of syntactic negation at <interactive>:1:6-8
17:57:38 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
17:57:49 <Zao> A list needs all elements to be the same type.
17:58:12 <Qriva> how about:
17:58:21 <Qriva> ?type ('z', 42)
17:58:22 <lambdabot> forall t. (Num t) => (Char, t)
17:58:29 <Qriva> err -42
17:58:34 <Qriva> ?type ('z', -42)
17:58:35 <lambdabot> forall t. (Num t) => (Char, t)
17:59:10 <Qriva> what does the t represent?  am ambiguous type?
17:59:12 <Qriva> an*
17:59:26 <skorpan> just a type
17:59:45 <skorpan> it's a "type variable", meaning it could be any type
17:59:52 <skorpan> in this case, the type also has to instantiate Num
18:00:09 <Qriva> why does :type -42 and :type 42 give the result in 'a' and 't' respectively?
18:00:18 <skorpan> :t -42
18:00:20 <skorpan> :t 42
18:00:20 <lambdabot> forall a. (Num a) => a
18:00:21 <lambdabot> forall t. (Num t) => t
18:00:33 <skorpan> i'm not sure, but there's no difference really
18:00:59 <Qriva> hmm, okay, ill just move on and quit harding on it for now :)
18:01:01 <Zao> Literal vs. expression?
18:01:03 <Qriva> harping*
18:01:09 <idnar> @type +42
18:01:10 <lambdabot> parse error on input `+'
18:01:13 <idnar> aww
18:01:15 <idnar> @type 0+42
18:01:17 <lambdabot> forall t. (Num t) => t
18:01:27 <skorpan> +42 would have been valid javascript though :P
18:01:28 <Qriva> ?type --42
18:01:29 <lambdabot> on the commandline:
18:01:29 <idnar> @type 0-42
18:01:30 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
18:01:30 <lambdabot> <no location info>: not an expression: `'
18:01:30 <Zao> Bah, theory disproven.
18:01:31 <lambdabot> forall t. (Num t) => t
18:01:37 <Zao> Qriva: -- is a comment
18:01:41 <Qriva> lol so it is!
18:01:48 <Qriva> ?type -(-42)
18:01:49 <idnar> that was a bizarre error, though
18:01:50 <lambdabot> forall a. (Num a) => a
18:02:25 <Qriva> ?type -(42)
18:02:26 <skorpan> :t -(-(-42))
18:02:26 <lambdabot> forall a. (Num a) => a
18:02:27 <lambdabot> forall a. (Num a) => a
18:02:30 <Qriva> :)
18:02:56 <Qriva> how do you define a temporary binding on the bot?
18:03:02 <skorpan> "let"
18:03:08 <skorpan> > let x = 5 in x + 3
18:03:09 <lambdabot>   8
18:03:16 <skorpan> > let myList = [1,2,3]
18:03:17 <lambdabot>   not an expression: `let myList = [1,2,3]'
18:03:21 <skorpan> okay, so that doesn't work
18:03:23 <skorpan> @let myList [1,2,3]
18:03:24 <lambdabot>   Parse error
18:03:27 <xian> > let myList = [1,2,3] in myList
18:03:28 <skorpan> @let myList = [1,2,3]
18:03:30 <lambdabot>   [1,2,3]
18:03:30 <lambdabot>  Defined.
18:03:34 <skorpan> > head myList
18:03:35 <lambdabot>   1
18:03:38 <Qriva> cool, thank you
18:04:15 <Zao> Note that lambdabot also accepts private messages.
18:04:25 <Qriva> I have to say I was completely flabbergasted at learning Haskell -- seemed beyond my reach, but Cale gave me a good intro the other night and im really getting into it
18:04:31 <xian> By the way, how is lambdabot protected against evaluating infinite lists etc.?
18:04:32 <Qriva> this is fun stuff to think about
18:04:55 <skorpan> Qriva: beware though, programming anything else after having done some haskell will prove painful
18:05:50 <idnar> @sum [1..]
18:05:50 <lambdabot> Maybe you meant: bug run src
18:05:51 <idnar> err
18:05:53 <idnar> > sum [1..]
18:06:00 <lambdabot>   mueval-core: Prelude.read: no parse
18:06:00 <lambdabot>  mueval: ExitFailure 1
18:06:06 <skorpan> uhh
18:06:12 <skorpan> that's not what it usually does, is it?
18:06:15 <Qriva> @let x = x + 1
18:06:15 <idnar> well, that wasn't quite the message I was expecting
18:06:17 <lambdabot>  <local>:5:0:
18:06:17 <lambdabot>      Multiple declarations of `L.x'
18:06:17 <lambdabot>      Declared at: <local>:2...
18:06:23 <skorpan> > sum [1..]
18:06:29 <lambdabot>   mueval-core: Prelude.read: no parse
18:06:29 <lambdabot>  mueval: ExitFailure 1
18:06:31 <idnar> but those expressions get evaluated in a separate process, which is killed after a certain period of time
18:06:41 <skorpan> lambdabot is ill
18:06:45 * Qriva hugs lambdabot 
18:07:54 <Qriva> Is there a way to tell lambdabot something like:
18:07:58 <Qriva> x :: Float
18:08:48 <skorpan> what do you mean?
18:09:11 <cads> hey, is there any way to turn  f::(a, b, c, d ...) -> p into  f'::a->b->c->d->...->p ?
18:09:33 <skorpan> :t uncurry
18:09:35 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:09:38 <skorpan> :t curry
18:09:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:10:19 <skorpan> maybe something along the lines of `curry'
18:11:07 <skorpan> cads: seeing as tuples of different lengths have different types, you may have to write your own function for it
18:11:16 <eck> is there a way to get sprintf functionality out of Text.Printf?
18:11:47 <kpreid> eck: if you let the return type be a string then it is sprintf
18:11:53 <eck> ah, thanks
18:11:55 <kpreid> then printf is sprintf, I mean
18:12:13 <Qriva> skorpan: to be honest I don't really know what I mean -- many examples I'm looking at look like: totalArea :: Float  totalArea = pi * r1^2 + pi * r2^2 + pi * r3^2
18:12:21 <Qriva> Is that type 'declaration' necessary?
18:12:29 <skorpan> Qriva: rarely is it necessary
18:12:59 <skorpan> :t fromIntegral 1
18:13:00 <lambdabot> forall b. (Num b) => b
18:13:20 <skorpan> :t 1
18:13:21 <lambdabot> forall t. (Num t) => t
18:13:22 <Qriva> whoa now we've got a b!  a, b, and t
18:13:46 <cads> skorpan:  "currying is a very important theoretical device because it reduces multiple-argument functions to single-argument functions only (Schoenfinkel, 1924"
18:13:50 <Qriva> :t  0 - 1
18:13:51 <lambdabot> forall t. (Num t) => t
18:14:12 <skorpan> cads: what are you saying?
18:14:52 <cads> well, in haskell it seems like the analogue of multi-arg functions, since functions are all normally curried, is a function that takes a tuple of some rank
18:15:32 <cads> but how can we use the curry function to turn a function on a higher rank tuple into a curried form?
18:16:00 <skorpan> you can't, afaik, but then again, what do i know
18:17:24 <skorpan> afaik, in haskell, you can't have a function which takes a tuple of "any length", and therein lies the issue
18:18:46 <idnar> @type curry
18:18:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:18:53 <idnar> @type curry . curry
18:18:55 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
18:19:06 <idnar> @type curry . curry . curry
18:19:08 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
18:19:24 <skorpan> idnar: it's just too bad ((a, b), c) isn't the same as (a, b, c) :)
18:19:35 <idnar> skorpan: some people think only the first one of those should exist :P
18:19:48 <idnar> except I think they usually want (a, (b, (b1, (b2, ()))))
18:20:28 <skorpan> idnar: i can understand that, but that's almost the equivalent of heterogeneous lists
18:20:41 <idnar> except it's type-level
18:20:46 <skorpan> yes
18:22:02 <cads_> skorpan: I got disconnected so I missed any replie
18:22:19 <skorpan> <skorpan> you can't, afaik, but then again, what do i know
18:22:28 <cads_> :t curry . curry . curry
18:22:29 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
18:24:09 <cads_> skorpan: hehe, I am looking up shoenfinkel '24 to see what he means by that
18:34:56 <Qriva> So I'm reading the HSoE book and I'm trying to run the code he provides for a function but I can't get it to run
18:35:12 <Qriva> @let listSum [] = 0
18:35:13 <lambdabot>  Defined.
18:35:31 <Qriva> @let listSum (x:xs) = x + listSum xs
18:35:33 <lambdabot>  Defined.
18:35:43 <Qriva> > listSum [1,2,3]
18:35:45 <lambdabot>   6
18:35:52 <Qriva> why doesn't this work in my GHCI?
18:36:20 <Ralith> because your GHCI is overriding, not overloading, the previous definition.
18:36:50 <Qriva> how do I fix that or get around it?
18:36:55 <Ralith> > let listSum (x:xs) = x + listSum xs; listSum [] = 0
18:36:56 <lambdabot>   not an expression: `let listSum (x:xs) = x + listSum xs; listSum [] = 0'
18:37:01 <Ralith> > let listSum (x:xs) = x + listSum xs; listSum [] = 0 in listSum [1,2,3]
18:37:02 <xian> Put the definition in a file and then :load it into your ghci session.
18:37:02 <lambdabot>   6
18:37:11 <Ralith> or do what I just demonstrated
18:37:13 <Ralith> :P
18:37:38 <Ralith> (the '...in listSum [1,2,3]' bit isn't necessary if you're in GHC; the definition will stick.)
18:40:26 <Qriva> thanks Ralith, im still newbin it up
18:46:24 <Qriva> when im load a .hs file into ghci, does it matter the order the functions inside of it were written?
18:46:46 <harlekin> Qriva, no
18:49:50 <Ralith> Qriva: yes, it does, I'm pretty sure.
18:50:11 <Ralith> you want most specific pattern match first.
18:51:02 <Ralith> e.g. if you have foo x = x and foo (y:ys) = y then you'll want to put the latter first or else it'll never get hit (ghc should warn you about this)
18:51:47 <eck> i'm pretty impressed by Data.Binary
18:51:47 <xian> But harlekin is right that the order in which *functions* are defined is irrelevant.
18:51:53 * eck spent the better part of the day packing bits
18:52:37 <Ralith> xian: okay, fair, but that probably wasn't the question Qriva meant to ask.
19:25:57 <hackagebot> either-unwrap 1.0
19:29:11 <Qriva> Ralith: actually I did sort of mean what xian said
19:30:01 <Qriva> Ralith: although i am curious about the whole :load'ing process in general in ghci
19:32:13 <Axman6> @hackage either-unwrap
19:32:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/either-unwrap
19:37:04 <aavogt> so that library writer is aware of the function either?
19:37:47 <aavogt> does eitherM === either?
19:38:06 <aavogt> with slightly different parameter order
19:38:17 <Axman6> :t either
19:38:18 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:38:29 <Axman6> yeah, that's all eitherM is
19:39:50 <aavogt> hmm, and the type isn't that much more specific that it will reduce the number of required annotations
19:40:48 <jasondew> anyone feel like looking at some haskell code and pointing me in the right direction to speed it up?  i've done profiling, looking at core, etc, etc
19:41:08 <idnar> what's the type of eitherM?
19:41:19 <aavogt> eitherM               :: Monad m => Either a b -> (a -> m c) -> (b -> m c) -> m c
19:41:43 <idnar> huh
19:42:50 <aavogt> I like the parameter order on the regular either better
19:42:53 <idnar> yeah, that's just weird
19:43:03 <idnar> there's no particular point in the Monad annotation
19:43:15 <idnar> which in turn makes the naming convention weird
19:44:41 <aavogt> @type \x -> either ?f ?g =<< x
19:44:42 <lambdabot> forall a b (m :: * -> *) b1. (?f::a -> m b1, ?g::b -> m b1, Monad m) => m (Either a b) -> m b1
19:45:12 <aavogt> @type  either (?f =<<) (?g =<<)
19:45:14 <lambdabot> forall a (m :: * -> *) b a1. (?f::a -> m b, Monad m, ?g::a1 -> m b) => Either (m a) (m a1) -> m b
19:45:48 <aavogt> @type on either (=<<)
19:45:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> (a -> m b) -> Either (m a) (m a) -> m b
19:46:12 <Qriva> my 'friend' is telling me he thinks Haskell is 'kind of a toy'
19:46:16 <Qriva> what do you even say to something like that?
19:46:53 <Gracenotes> :>
19:47:06 <inimino> "that's nice"?
19:47:08 <inimino> nothing?
19:47:19 <idnar> Qriva: well, it's a toy that's used to write financial software for banks :P
19:47:40 * inimino would probably smile and move on ;-)
19:47:50 <Qriva> i feel bad for him -- he's so set on the idea that all he needs to do is go through a compsci program, learn Java and some C, and that's it
19:48:00 <Qriva> im trying to open him up to the idea that there's more out there
19:48:05 <inimino> Qriva: why is he studying CS?
19:48:09 <shapr> Yeah, really.
19:48:19 <p_l> Qriva: He probably will fail C with that kind of mindset
19:48:26 <Qriva> he's like a lot of CS majors -- no other clue what to do
19:48:31 <Qriva> and thinks it will make him money
19:48:38 <shapr> Can't argue with that.
19:48:40 <inimino> based on your description so far, it's probably for the money
19:48:42 <inimino> yeah
19:48:46 <inimino> no point in trying to help the guy then
19:48:54 <p_l> Qriva: Java isn't helping. I'm surprised Java people can write any C without failing... oh
19:49:05 <inimino> if we's in it for the money, let him learn Java and make what money he can
19:49:13 <inimino> s/we's/he's/
19:49:33 <Qriva> he has an interest in computers, but once i get onto ANY sort of theoretical discussion with him about i dont know, functional programming, persistence, blah blah
19:49:39 <p_l> inimino: if he wants money, he should learn COBOL
19:49:42 <Qriva> he just shrugs like he doesn't care
19:49:52 <inimino> in my opinion people who learn programming for that reason rarely get good at it, and then only by accident
19:50:27 <Qriva> he's just not passionate about it, which is really sad, i dont know
19:50:40 <inimino> my advice would be to treat him as you would any other professional in a field that is not your own
19:50:42 <Qriva> i cant save 'em all, but i thought id give it a try
19:51:07 <aavogt> @faq can Haskell save souls?
19:51:07 <lambdabot> The answer is: Yes! Haskell can do that.
19:51:11 <Qriva> lol
20:04:31 <Gracenotes> hallelujah
20:04:34 <Gracenotes> ..
20:05:33 <athos> hm
20:05:38 <athos> it's already 5am
20:14:04 <alexsuraci> In Control.Concurrent.Chan, what if I write to a channel before something tries to read from it? Does the value get lost?
20:14:34 <alexsuraci> I'm thinking no but it would explain the trouble I'm having
20:16:09 <hydo> slow day...
20:16:26 <hydo> sorry, alexsuraci, I don't know.
20:16:34 <luqui> alexsuraci, it gets queued up
20:16:35 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
20:16:57 <Gracenotes> alexsuraci: how soon before?
20:17:01 <alexsuraci> luqui: that's what I thought
20:17:07 <alexsuraci> Gracenotes: can't be certain
20:19:16 <alexsuraci> well, I'm getting a "thread blocked indefinitely" and it seems to be happening when it's reading from a channel, even after I write to it
20:19:33 <alexsuraci> maybe I'm writing to two different channels accidentally, hmm
20:20:37 <alexsuraci> it can't be that the channel's simply empty though, readChan would wait in that case
20:20:49 <alexsuraci> so something deeply sinister must be going on
20:23:51 <Gracenotes> D:
20:24:50 <Gracenotes> well, don't underestimate stdout. The source for Chan is simple-ish, so you could make your own module plus debugging... concurrency bugs are so annoying :/
20:25:12 <alexsuraci> yeah I've made extensive use of Debug.Trace :P
20:25:15 <bos> "thread blocked indefinitely" usually means a bug in your code.
20:25:31 <alexsuraci> yeah, figured that much, I'm just not sure what causes it specifically
20:28:37 <bos> alexsuraci: it means that your thread has the only reference to the Chan (or the MVars it's constructed with)
20:29:01 <bos> alexsuraci: since no other thread has a reference to it, when you try to read from the Chan, it's not possible for the thread ever to wake
20:31:20 <alexsuraci> ah, thanks
20:31:24 <Gracenotes> as I said a few days ago, Chan needs to borrow some functionality from the MVars used to implement it. tryTake and tryPut, would be useful :/
20:32:27 <Gracenotes> if that's possible
20:32:36 <alexsuraci> bos: to be clear, by "your thread" you mean the thread trying to read from it, right?
20:32:48 <bos> right
20:33:19 <alexsuraci> alright, thanks
20:34:35 <alexsuraci> in other news, if anyone's in the Fort Wayne, IN area help me find my cat :( https://post.craigslist.org/manage/1197573122/ysf8v
20:34:43 <alexsuraci> http://fortwayne.craigslist.org/laf/1197573122.html rather
20:37:04 <centrinia> Is there a way to set the channel's queue size?
20:38:52 <mmorrow> Gracenotes: this is the replacement for Chan i use now http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/Q.hs
20:39:06 <mmorrow> (ever since i was told that
20:39:09 <Gracenotes> I have seen :)
20:39:21 <mmorrow> forkIO (takeChan ch >> return ())
20:39:24 <mmorrow> isEmptyChan ch
20:39:26 <mmorrow> blocks
20:39:28 <Gracenotes> do you have Haddocks of it?
20:39:35 <mmorrow> Gracenotes: no, but i should
20:39:41 <Gracenotes> preferably fried?
20:39:47 <mmorrow> weee
20:41:46 <mmorrow> centrinia: by channel you mean Chan? (and if so, what would be the desired behavior when the queue is full and a thread tries to add an elem to the Chan? (to block i assume?))
20:42:16 <centrinia> Maybe the queue size can be set only once?
20:42:25 <alexsuraci> is there a more detailed spec sheet on the concurrency implementations I could read up on?
20:43:07 <Gracenotes> hm. I wish there was a built-in thing for return () :: Monad m => m (). No idea what it would be called though.
20:43:41 <kpreid> Gracenotes: void;
20:43:44 <kpreid> ?
20:43:44 <centrinia> Gracenotes, It would be called return () :p
20:43:46 <mmorrow> alexsuraci: i peeked at this the other day and it looks like a good intro http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
20:43:52 <Gracenotes> kpreid: oooh. I like.
20:43:58 <centrinia> :t return ()
20:43:59 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
20:44:10 <Gracenotes> centrinia: well. You know how it is with multiparameter functions and having to use parentheses.
20:44:17 <alexsuraci> mmorrow: thanks
20:44:19 <centrinia> @let void = return ()
20:44:20 <lambdabot>  Defined.
20:44:26 <centrinia> > void
20:44:27 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:44:27 <lambdabot>    arising from a use of `M728820821...
20:45:16 <bos> > void :: IO ()
20:45:17 <lambdabot>   <IO ()>
20:50:11 <mmorrow> alexsuraci: actually, looking at that paper it looks like there's only a brief section on MVars, and the rest on STM.. so the three different ways of doing concurrent stuff are basically (IORef+atomicModifyIORef, MVar, and STM) (in decreasing order of speed and increasing order of ease-of-implementation)
20:50:34 <centrinia> Oh, Chan has a queue size of 1.
20:50:52 <mmorrow> centrinia: what do you mean by queue size?
20:51:28 <centrinia> The number of elements that can be put in the FIFO.
20:51:41 <mmorrow> it's unbounded
20:51:45 <alexsuraci> mmorrow: ah, ok
20:52:10 <centrinia> Okay.
20:52:42 <mmorrow> alexsuraci: i liked this one: http://www.haskell.org/~simonmar/papers/concurrent-data.pdf
21:00:47 <alexsuraci> mmorrow: looks nice and brief with plently of code examples. I approve. ;) Thanks.
21:01:01 <mmorrow> alexsuraci: np :)
21:10:21 <halberd> as I understand it, in type theory an expression can have multiple types--correct? how come in Haskell then we talk about "the" type of an expression?
21:10:44 <Gracenotes> you're referring to polymorphism?
21:11:17 <codebliss> @src join
21:11:17 <lambdabot> join x =  x >>= id
21:11:19 <Gracenotes> a polymorphic type is still a type.
21:11:24 <codebliss> How does that work?  I still don't get it
21:11:51 <NEEDMOAR> In some type systems, every expression has only one type, halberd.
21:11:53 <alexsuraci> codebliss: >>= is equivalent to concatMap with lists
21:11:56 <codebliss> Since id :: a -> a, and that part of (>>=) is (a -> m b), that means a has to be m b, and it would be (m b -> m b)?
21:12:14 <Gracenotes> yes
21:12:16 <codebliss> alexsuraci: I never said anything about lists?
21:12:31 <alexsuraci> codebliss: sorry, assumed that's what you meant based on the context
21:12:33 <Gracenotes> codebliss: you're right..
21:12:35 <halberd> well Lambda ((x) x) has the type List A -> List A, and also the type Eq A -> Eq A, for example
21:12:40 <codebliss> alexsuraci: No problem =)
21:12:59 <Gracenotes> halberd: that's a union of types. which is one type.
21:13:07 <Gracenotes> er, I mean, intersection
21:13:10 <codebliss> OH
21:13:14 <halberd> they are 2 different types which can be derived for the expression
21:13:20 <halberd> using the rules of type theory
21:13:24 <codebliss> so it's m (m b) -> (m b -> m b) -> m b
21:13:26 <codebliss> OH
21:13:39 <codebliss> Lol sorry, I never looked back at that first a XD
21:13:44 <NEEDMOAR> hellige: in which type theory?
21:14:00 <halberd> the type of an expression can be interpreted as just a proposition that is true of that expression, so there shouldn't be any limit to the number or kind of types a dependently typed expression might have, should there?
21:14:44 <halberd> because any number of propositions might be true of a given expression
21:14:50 <Gracenotes> unions and intersections of types are formulated pretty solidly in type theory
21:15:14 <Gracenotes> halberd: you might be interested in http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
21:15:19 <NEEDMOAR> halberd: you do not state which type system are you using...
21:15:57 <halberd> martin lof's type theory, as presented in the introduction by nordstrom, petersson, and smith
21:16:31 <Gracenotes> ..could've said that..
21:16:33 <NEEDMOAR> halberd: well, intuicionistic type theory is not the same as Haskell's types.
21:16:44 <halberd> I know that
21:18:37 <Gracenotes> halberd: you've come asking here about Martin Lof's theory before, but.. I think LtU might know more? :) or maybe #haskell-in-depth
21:19:23 <NEEDMOAR> halberd: you can talk about the type of an expression in Haskell, because the type system (probably) assures that an expression has only one type.
21:19:53 <NEEDMOAR> Well, that's more or less.
21:19:57 <halberd> ah #haskell-in-depth... didn't realize it existed
21:20:00 <NEEDMOAR> You have the most generic type, etc.
21:21:25 <aavogt> I'm having difficulties with specifying endomorphisms that work within an existential type
21:22:25 <mmorrow> aavogt: unless you package the function within the same box that you put the data when you first box it up, the type system will refuse
21:22:48 <mmorrow> (if i'm understanding your situation correctly)
21:25:33 <mmorrow> (e.g. data A b = forall a. A (a -> b) a)
21:25:36 <halberd> Gracenotes: I'm in the habit of asking #haskell for any computer-science-related question, just because it is full of computer science people
21:25:39 <halberd> and math people
21:25:57 <halberd> unlike #c or #java or #python
21:26:32 <halberd> it's hit or miss though... I'll check out lambda the ultimate
21:26:42 <copumpkin> isn't #python really strict? or was that another one
21:27:12 <halberd> strict? well I never tried bending the rules in there
21:27:16 <halberd> so I don't know
21:27:21 <mmorrow> copumpkin: heh, what do you mean strict
21:27:22 <mmorrow> ?
21:27:24 <aavogt> mmorrow: sort of like that
21:27:35 <aavogt> I want to write something like:
21:27:43 <halberd> but the people who frequent #python tend not to be as theoretically minded as the #haskell people
21:27:54 <Gracenotes> halberd: sure... I understand
21:27:57 <aavogt> liftExistential f (Box a) = Box (f a)
21:28:02 <copumpkin> oh, I thought I heard someone that you get flamed/kicked for anything remotely off-topic and that it's full of the typical IRC-types who like to correct your question before answering it
21:28:08 <copumpkin> but I've never been there myself so I don't know :)
21:28:21 <mmorrow> so, (data Box = forall a. Box a) i take it?
21:28:22 <Gracenotes> don't mind me :P
21:28:43 <aavogt> this Box has some typeclass constraints too
21:28:58 <aavogt> but that's basically it
21:29:04 <mmorrow> aavogt: ah, ok. in that case you have at least something to work with
21:29:28 <mmorrow> aavogt: but in the general case, you'd have to ensure correctness yourself and then just unsafeCoerce
21:29:36 <mmorrow> @src fromDynamic
21:29:37 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
21:29:37 <lambdabot>     r | t == typeOf r -> Just r
21:29:37 <lambdabot>       | otherwise     -> Nothing
21:29:47 <mmorrow> @src Dynamic
21:29:47 <lambdabot> Source not found. Maybe you made a typo?
21:29:53 <mmorrow> @src Dyn
21:29:54 <lambdabot> Source not found. That's something I cannot allow to happen.
21:30:18 <aavogt> this seems close: liftLayout :: (LayoutClass l a, Read (l a), LayoutClass m a, Read (m a)) => (l a -> m a) -> Layout a -> Layout a
21:30:47 <mmorrow> what's the def of Layout?
21:31:21 <aavogt> but I can't get the (l a) to refer to the (l1 a) that's inside the (Layout a) argument
21:31:39 <Berengal> I just had the weirdest dream. I was collecting pokemon-ish creatures in Bowser's castle, fighting of Bernie the dinosaur (or whatever his name), looking for a red and a blue monoid I could mappend with my yellow one and save the universe from Princess Peach...
21:32:11 <aavogt> data Layout a where Layout :: forall a l. (LayoutClass l a, Read (l a)) => (l a) -> Layout a
21:32:29 <Gracenotes> :ox
21:33:19 <hydo> Berengal: Pr. Peach is the villain now adays or is this just in your dream?
21:33:54 <Berengal> hydo: She wasn't a villain. She was the villain's secret weapon (against her will)
21:34:12 <hydo> aww... poor pixelated thing.
21:34:30 <mmorrow> aavogt: hmm
21:38:14 <aavogt> I have a feeling that it is possible, but unsafeCoerce will prevent ghc from picking the correct class instances?
21:38:39 <mmorrow> aavogt: so you need to forall the `l' there http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5436#a5436
21:39:01 <sjanssen> aavogt: btw, I would prefer not to have unsafeCoerce# in xmonad's source code :)
21:39:03 <mmorrow> since you don't know that the `l' your function works on is the same `l' that's in the box
21:39:14 <sjanssen> aavogt: what if layout transformers were of type "Layout a -> Layout a"?
21:40:14 <mmorrow> aavogt: so in that case, unsafeCoerce would just result in segfault
21:40:42 <mmorrow> (but with the alternative liftLayout in that paste you don't need it)
21:44:01 <mmorrow> ooh, also this is an option too
21:44:04 <aavogt> sjanssen: yeah, I'm after layout transformers to be  Endo (Layout a)
21:44:40 <mmorrow> liftLayout :: (LayoutClass m a) => (forall l. LayoutClass l a. => l a -> m a) -> Layout a -> Layout a
21:45:52 <sjanssen> that seems easy to write, no?
21:47:08 <aavogt> mmorrow: any ideas as how to solve the:     Inferred type is less polymorphic than expected; Quantified type variable `l' escapes
21:47:30 <hackagebot> bindings-common 0.1
21:47:55 <aavogt> from say  (liftLayout Mirror)  where Mirror has the correct instances
21:52:16 <mmorrow> hmm
21:54:23 <mmorrow> aavogt: i'd have to see the specific code i think
21:55:02 <mmorrow> (like, what's the definition of LayoutClass, and of Mirror, and which version of liftLayout are you using?)
21:55:22 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5437#a5437
21:55:29 * mmorrow looks
21:57:16 <mmorrow> aavogt: what about Mirror?
21:57:23 <mmorrow> (are these all in XMonad?)
21:57:32 <hackagebot> bindings-sqlite3 0.0.1
21:57:48 <aavogt> mmorrow: http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-Layout.html#t%3AMirror
21:58:00 <mmorrow> ha, perfect
21:58:03 <mmorrow> s/ha/ah/
22:00:33 <hackagebot> bindings-libusb 0.0.1
22:04:49 <malouin> how does HDBC relate to hsql?
22:05:19 <Gracenotes> Haskell :D
22:06:21 <Apocalisp> @bot
22:06:22 <lunabot>  :)
22:06:31 <lambdabot> :)
22:07:25 <Elly> haskell relates to everything
22:07:30 <Elly> by force if necessary
22:08:40 <aavogt> thanks for helping with this mmorrow, I think the latest problem is the that resuling layout type (m) depends on the input (l). But it doesn't really escape afaict :(
22:09:02 <mmorrow> yeah, it's the `l' in Mirror that's causing the problem here
22:09:18 <mmorrow> you might be able to work around it by making something like:
22:09:24 <mmorrow> data ExistMirror a = forall l. (LayoutClass l a, Read (l a)) => ExistMirror (Mirror l a)
22:09:40 <mmorrow> and using that, but then you have to hand-define an instance of Read for that
22:10:21 <mmorrow> (which i was just trying but am getting errors about "(LayoutClass l a, Read (l a))" not being known, even though it's there in the ExistMirror def
22:10:25 <mmorrow> which is annoying
22:10:40 <mmorrow> maybe if ExistMirror was a GADT?
22:10:52 <mmorrow> anyways, yeah this looks semi-painful :)
22:11:34 <dmwit> > 6^6^6 * logBase 10 6 :: CReal
22:11:39 <lambdabot>   mueval-core: Prelude.read: no parse
22:11:39 <lambdabot>  mueval: ExitFailure 1
22:11:44 <dmwit> > 6 :: CReal
22:11:46 <lambdabot>   6.0
22:11:54 <dmwit> > 6^6^6 :: CReal
22:11:59 <lambdabot>   mueval-core: Prelude.read: no parse
22:11:59 <lambdabot>  mueval: ExitFailure 1
22:12:04 <dmwit> okay then
22:14:40 <aavogt> > 6^6^6
22:14:42 <lambdabot>   265911977215322677968248940438791859490534220026992430066043278949707355987...
22:14:51 <aavogt> > 6^6
22:14:52 <lambdabot>   46656
22:15:01 <aavogt> > 6^6 :: CReal
22:15:02 <lambdabot>   46656.0
22:15:19 <aavogt> > length $ show $ 6^6^6
22:15:20 <lambdabot>   36306
22:15:36 <hackagebot> bindings 0.1.1
22:19:21 <aavogt> mmorrow: the layout being modified shows up in the type of every modified layout, but perhaps the best thing to do would be to change them to start off as (Layout a -> Layout a)
22:19:57 <aavogt> since this liftLayout has not worked out
22:20:50 <mmorrow> possibly, i'm not sure all the moving pieces. what hard here is that you can't modify the types that already exist in xmonad..
22:21:31 <mmorrow> aavogt: but yeah, i'd probably try a different angle of attack
22:22:50 <mmorrow> (different from the original i mean, not different than (Layout a -> Layout a), that could work (not sure) :)
22:35:23 <aavogt> mmorrow: thanks again, and good night. Hopefully we'll find a better solution to this issue later.
22:38:41 <mmorrow> aavogt: good luck
22:49:02 <jimmyjazz14> I'm looking for an example of mapping a function over the lines in a file.
22:50:45 <mmorrow> main = putStr . unlines . fmap f . lines =<< getContents
22:51:23 <mmorrow> better would be
22:51:26 <mmorrow> main = putStr . unlines . f . lines =<< getContents
22:51:31 <mmorrow> then you could do e.g.
22:51:52 <mmorrow> f = zipWith (\n l -> n ++ ":" ++ l) [1..] -- number lines
22:51:54 <mmorrow> etc
22:52:19 <Gracenotes> :o
22:52:32 <mmorrow> f = fmap (show . length) -- number of char on each line
22:53:01 <mmorrow> err, show n
22:53:06 <mmorrow> f = zipWith (\n l -> show n ++ ":" ++ l) [1..] -- number lines
22:57:01 <rick_2047> hi everyone i was just starting out with haskell and was curious about its functional programming paradigim. i heard its very closely related to discrete mathematics. i am interested in maths so can anyone point me to a source which teaches me this language with a mathematical problem approach
22:57:04 <jimmyjazz14> ah thanks
22:59:14 <Twey> rick_2047: Perhaps ‘The Haskell Road to Logic, Maths, and Programming’
23:00:15 <rick_2047> Twey, sounds interesting lemme just read a review on amazon
23:01:03 <Twey> I'm not sure I'd describe Haskell as ‘closely related’ to any branch of mathematics
23:01:17 <Twey> It does use a lot of mathematical concepts, but at its heart it is a programming language
23:01:39 <Twey> Better to say it borrows from mathematics, perhaps
23:02:27 <rick_2047> Twey, dats exactly what i mean but you see haskell is used in a lots of maths project and a friend suggested that i use it in my math experiments
23:03:36 <Twey> Don't forget that Mathematic is the world's most powerful computational software.
23:03:39 <Twey> Mathematica**
23:15:16 <sayyestolife> what's up?
23:16:59 <dmwit> ?wn up
23:17:11 <dmwit> uh...
23:17:13 <dmwit> ?botsnack
23:17:27 <dmwit> Don't worry, I've got \bot's back!
23:17:47 <dmwit> up (adj): being or moving higher in position or greater in some value
23:19:03 <dmwit> sayyestolife: Doing any awesome Haskell hacks?
23:19:28 <lambdabot> *** "up" wn "WordNet (r) 2.0"
23:19:28 <lambdabot> up
23:19:28 <lambdabot>      adj 1: being or moving higher in position or greater in some value;
23:19:30 <lambdabot>             being above a former position or level; "the anchor is
23:19:32 <lambdabot>             up"; "the sun is up"; "he lay face up"; "he is up by a
23:19:33 <sayyestolife> dmwit, no, I'm actually trying to figure out if there is a way to get max integer size in Ada
23:19:34 <lambdabot> [28 @more lines]
23:19:36 <lambdabot> :)
23:19:40 <dmwit> laaaag
23:19:47 <ski> @uptime
23:19:48 <lambdabot> uptime: 5d 23h 25m 16s, longest uptime: 1m 10d 23h 44m 29s
23:20:13 * dmwit didn't know anybody used ada any more
23:20:26 <sayyestolife> heh, it's for university
23:25:27 <p_l> dmwit: it's still used in the same places as always :)
23:25:53 <dmwit> so... the military?
23:26:51 <stepnem> http://auroraux.blastwave.org/index.php/Main_Page
23:27:38 <p_l> dmwit: embedded and critical stuff
23:32:51 <hydo> Out of curiosity, does anyone here use netbsd?  I'm thinking of using it for an embedded experiment.
