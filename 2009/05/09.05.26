00:00:25 <vininim_> anyone played with attoparsec?
00:03:16 <Baughn> > fmap (+2) (+3) 5
00:03:18 <lambdabot>   10
00:03:38 <Baughn> > ((fmap.fmap) (+2) [(+3),(+6)]) 5
00:03:40 <lambdabot>   Couldn't match expected type `t -> f a'
00:03:58 <Baughn> :t (fmap.fmap) [(+3)]
00:04:00 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
00:04:00 <lambdabot>     In the first argument of `(fmap . fmap)', namely `[(+ 3)]'
00:04:00 <lambdabot>     In the expression: (fmap . fmap) [(+ 3)]
00:04:16 <pumpkin> :t (fmap.fmap) (+2)
00:04:17 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 a)
00:04:43 <Baughn> :t (fmap.fmap) (+2) [(+3)]
00:04:44 <lambdabot> forall a. (Num a) => [a -> a]
00:04:46 <pumpkin> > ((fmap.fmap) (+2) [(+3),(+6)]) <*> [5]
00:04:48 <lambdabot>   [10,13]
00:04:58 <Baughn> :t ((fmap.fmap) (+2) [(+3)]) <*> 6
00:04:59 <lambdabot> forall a. (Num a, Num [a]) => [a]
00:05:03 <Baughn> > ((fmap.fmap) (+2) [(+3)]) <*> 6
00:05:05 <lambdabot>   No instance for (GHC.Num.Num [a])
00:05:05 <lambdabot>    arising from the literal `6' at <inter...
00:05:48 <Baughn> Uguuu~
00:06:10 <pumpkin> ?
00:08:24 <pumpkin> @pl \x -> map ($x)
00:08:24 <lambdabot> map . flip id
00:08:29 <pumpkin> @pl \x -> fmap ($x)
00:08:30 <lambdabot> fmap . flip id
01:14:31 <pumpkin> @type unfoldr
01:14:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:18:01 <QtPlaty[HireMe]> Is it correct to say "Function application in haskell is left associative"
01:18:06 <QtPlaty[HireMe]> ?
01:21:03 <fasta> I am using some functional dependencies, but it appears that type Foo = Double and then depending on Foo gives a different result than directly depending on Double (which does work). Is there some extension which can cause this behaviour? If so, which one?
01:25:34 <Gracenotes> QtPlaty[HireMe]: I'd say that.
01:26:17 <Gracenotes> in all lambda calculi that I know of
01:26:36 <Gracenotes> ...er, and there aren't that many of them, really >_>
01:29:10 <Gracenotes> there aren't many other languages where you could say application is associative at all
01:29:36 <Gracenotes> hm.
01:33:00 <Cale> fasta: That is surprising...
01:33:14 <Bacta> @fag can Haskell cure me of my social awkwardness?
01:33:15 <lambdabot> The answer is: Yes! Haskell can do that.
01:33:21 <Bacta> Awesome!
01:36:10 <BrokenClockwork> hey, is there a n-root function in the prelude? :)
01:36:34 <ziman> > 27**(1/3)
01:36:35 <lambdabot>   3.0
01:36:53 <BrokenClockwork> thanls alot mate
01:36:57 <ziman> yw :)
01:42:16 <fasta> Cale: I think it was something else. It is solved now, anyway.
01:45:02 <dancor_> if i am tracking data length already somewhere else for some binary data, is it still more correct to use (fst <$> newCStringLen x) than (newCString x)
01:59:07 <fasta> dancor_: either it is correct or it is not, if you are talking about maintainability and how obviously correct it is, then storing the length and the string in one data structure seems better than to distribute it like you seem to be doing now.
02:05:12 <dancor_> fasta: takusen splits it up i guess because postgres accepts the parts in different arguments
02:05:27 <dancor_> the postgres c lib
02:05:44 <mjrosenb> does rwh cover talking with a database and/or ffi stuff at all?
02:06:18 <kynky> thought it did ,but would have to check
02:07:00 <fasta> dancor_: and postgres does it that way because the std c lib does it that way.
02:07:25 <dancor_> i'm going to go with (fst <$> newCStringLen x).  idk if (newCString x) would work.
02:08:04 <kynky> ch 7 deals with ffi
02:08:24 <kynky> ch21 deals with databases
02:08:45 <kynky> ch17 with ffi i mean
02:09:05 <fasta> mjrosenb: there are also quite some blog posts on using the FFI.
02:09:26 <fasta> mjrosenb: and of course the documentation, which is fairly good.
02:33:27 <Berengal> Say you've got a class (Show b) => Foo a b | a -> b, is it possible to constrain b using type families?
02:39:00 <pumpkin> Berengal: you mean to replace that fundep with type families?
02:39:53 <Peaker> what can type families do that fundeps can't?
02:40:04 <doserj> Berengal: in theory, you can do sth. like class (Show b, B a ~ b) => Foo a b where type B a
02:40:14 <yitz> Peaker: work well.
02:40:32 <Peaker> yitz: ?
02:40:53 <doserj> Berengal: but I seem to remember that ghc has some issues with these kind of equality constraints.
02:41:10 <yitz> Peaker: it's not clear how the compiler should handle fundeps to make their behavior "unsurprising" to users.
02:41:47 <Peaker> yitz: so are they equivalent in power? I thought type families added power
02:43:03 <yitz> Peaker: I like the idea of fundeps, but ghc often seems somewhat broken with them. It  doesn't seem to be the fault of the ghc team - they seem to be really hard to implement fully.
02:44:02 <Peaker> I wonder about the difference in power "in theory"
02:44:07 <yitz> Peaker: could be, I don't know, but I haven't run into anything else I need them for in practice. What I said is the reason I like type families.
02:44:44 <pumpkin> I've brought this up before, but has anyone thought about "existential typeclass quantification" if that makes sense?
02:44:55 <pumpkin> is there a more correct name for that?
02:46:10 <Peaker> pumpkin: what do you mean?
02:46:20 <pumpkin> well the typical example is generalizing the on function
02:46:26 <Peaker> @type on
02:46:27 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:46:49 <Peaker> @type flip on -- nicer
02:46:50 <lambdabot> forall b c a. (a -> b) -> (b -> b -> c) -> a -> a -> c
02:46:57 <pumpkin> I'm fine with the order :)
02:47:04 <Peaker> just as a btw :)
02:47:08 <pumpkin> but do you see what I mean?
02:47:12 <Peaker> its a double-arg CoFunctor :)
02:47:18 <Peaker> nope, not sure -- what is the more general type?
02:47:41 <Berengal> For me the main reason to use type families is at the moment readability
02:47:42 <pumpkin> well, I can't write it, but it's a typeclass that has a method Class a => a -> b
02:48:09 <Berengal> Instead of class Foo a b c d | a -> b c d you get class Foo a where type B a; type C a; type D a
02:48:17 <yitz> Peaker: the motivation for the order was things like compare `on` sqrt, which reads nicely in English. Why do you like the oposite order better?
02:48:18 <pumpkin> Peaker: so the last two a's in the type of on don't need to be the same... the only important thing is that you have some kind of mapping from each of them to b
02:49:06 <Peaker> I'd call it argument2 or bothArgs or something like that
02:49:07 <pumpkin> Peaker: and that mapping could be through a typeclass-constrained function
02:49:13 <Peaker> sqrt `bothArgs` compare
02:49:47 <pumpkin> Peaker: see what I'm saying?
02:50:05 <Peaker> pumpkin: ah, I see
02:50:43 <yitz> pumpkin: so you want some kind of "uncurried" ***?
02:51:45 <pumpkin> something like forallclass C. forall c d. C c, C d => (b -> b -> e) -> (C a => a -> b) -> c -> d -> e
02:51:57 <pumpkin> if that makes any sense whatsoever :P
02:52:34 <Peaker> pumpkin: trying to find a way to write the type myself, indeed a problem :)
02:53:05 <yitz> @type \f g g' x y -> f (g x) (g' y)
02:53:05 <pumpkin> it is pretty monstrous :P
02:53:07 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t4
02:53:21 <yitz> @pl \f g g' x y -> f (g x) (g' y)
02:53:22 <lambdabot> ((flip . ((.) .)) .) . (.)
02:53:32 <pumpkin> yeah, if you accept that you have two functions, then it's not a problem
02:53:55 <yitz> just a little messy
02:53:59 <pumpkin> yeah
02:54:49 <Peaker> (ia -> ia -> r) -> (? -> ia) -> (ib -> ic -> o)
02:55:19 <Peaker> (ia -> ia -> r) -> (forall i. Convertible i ia => i -> ia) -> (ib -> ic -> o) ?
02:55:38 <Peaker> class Convertible a b where apply :: a -> b  ?
02:55:46 <yitz> @type \f g g' -> curry $ uncurry f . (g *** g')
02:55:47 <lambdabot> forall a b a1 b1 c. (a1 -> b1 -> c) -> (a -> a1) -> (b -> b1) -> a -> b -> c
02:55:53 <Peaker> pumpkin: what about that type?
02:55:53 <mebbel> ia -> ia -> fhtagn
02:56:13 <pumpkin> Peaker: then you'd need to write a bunch of instances
02:56:21 <pumpkin> Peaker: wouldn't you?
02:56:35 <Berengal> Where would I find (~)?
02:56:59 <Peaker> pumpkin: isn't that inherent?
02:57:14 <Peaker> Berengal: I think ~ is a language extension of type families meaning type equality
02:57:19 <pumpkin> well, with the forallclass thing I was hoping to exploit existing classes and instances
02:57:41 <Peaker> pumpkin: call any random class method to convert?
02:57:42 <pumpkin> but I guess if more than one worked, you'd have to choose which one somehow
02:57:44 <pumpkin> :P
02:57:48 <pumpkin> which would be ugly
02:58:02 <mebbel> forget the type; how would you write the function body?
02:58:07 <pumpkin> hmm, maybe not such a good idea :)
02:58:09 <pumpkin> mebbel: not a clue :P
02:58:25 <Peaker> pumpkin: oh, I see what you mean now
02:58:46 <pumpkin> probably not a very good idea now that I've gone over it more :)
02:58:46 <Peaker> something like:  (ia -> ia -> r) -> (forall i. i -> ia) -> (ib -> ic -> o)     -- except you want i to just be as polymorphic as necessary and not fully polymorphic
02:59:24 <Peaker> so that there should be (forall i. all_restrictions_that_still_catch ib and ic ...)
02:59:31 <pumpkin> sort of, yeah :)
02:59:41 <Peaker> or maybe (Either ib ic -> ia)  :)
03:00:10 <Peaker> heh, in the case of wanting to catch just a finite set of types, I guess the best way is just to provide a finite set of functions
03:00:43 <Peaker> > (show *** show) (1, 2)
03:00:44 <lambdabot>   ("1","2")
03:00:49 <Peaker> > (show *** show) (1, 'c')
03:00:50 <lambdabot>   ("1","'c'")
03:01:02 <Peaker> @let both = join (***)
03:01:03 <lambdabot>  Defined.
03:01:08 <Peaker> > both show (1, 'c')
03:01:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
03:01:09 <lambdabot>    arising from the literal `1...
03:01:10 <pumpkin> yeah :/
03:01:23 <pumpkin> what's with lambdabot spitting out low-level types in its errors now?
03:01:36 <Peaker> so it may be a little weird to use (show *** show)  instead of join (***) show...  working around type system weakness
03:02:02 <Peaker> @type join (***)
03:02:03 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
03:02:51 <pumpkin> what would have to change to make join (***) as polymorphic as (f *** f) ? the whole monomorphic function application thing?
03:03:15 <pumpkin> because even \f -> (f *** f) would be equivalent to join (***) I think?
03:03:20 <Peaker> It is equivalent
03:03:42 <Peaker> now I understand what dolio (I think it was him) said about let binding and argument binding having different type restriction
03:03:58 <Peaker> let show = ... -- show is polymorphically typed whereas  \f -> (f *** f) -- f is singly-typed
03:04:06 <pumpkin> yup
03:04:22 <pumpkin> @let showBoth = (show *** show)
03:04:24 <lambdabot>  Defined.
03:04:26 <pumpkin> :t showBoth
03:04:27 <lambdabot> forall b b'. (Show b, Show b') => (b, b') -> (String, String)
03:04:36 <hackagebot> fclabels 0.1.2
03:05:31 <pumpkin> I guess that's a pretty fundamental aspect of the language
03:05:44 <pumpkin> and changing it would have all sorts of nasty effects
03:05:50 <Peaker> pumpkin: if arguments had been polymorphic, then they could not be unified with anything
03:05:53 <Peaker> I think
03:06:09 <Berengal> class (Show b, B a ~ b) => Foo a where type B a -- doesn't work :(
03:06:18 <Peaker> I mean, the type of \x -> (x,x)   would not have been  a -> (a, a)
03:06:25 <pumpkin> yeah :)
03:06:28 <pumpkin> it'd be a big mess
03:06:59 <doserj> Berengal: class (Show b, B a ~ b) => Foo a b where type B a
03:07:00 <pumpkin> I've often wanted that function by the way
03:07:07 <pumpkin> should be called duplicate or something
03:07:15 <pumpkin> in Control.Arrow, maybe, as an arrow
03:07:18 <doserj> Berengal: Foo needs both a and b as parameter
03:07:19 <pumpkin> along with both
03:07:29 <Berengal> doserj: Yes, but it shouldn't be neccessary to have b as a parameter
03:07:43 <doserj> Berengal: if you want to constrain it, it has to
03:07:53 <pumpkin> you want some sort of existential b?
03:08:10 <Peaker> pumpkin: call it both
03:08:17 <Peaker> pumpkin: in consistency with first and second
03:08:20 <Berengal> pumpkin: Yes
03:08:26 <pumpkin> PeakerWork: I'd want both to be first f >>> second f or something
03:08:47 <Peaker> @type \f -> first f >>> second f
03:08:48 <lambdabot> forall (cat :: * -> * -> *) b c. (Arrow cat) => cat b c -> cat (b, b) (c, c)
03:08:49 <pumpkin> as first and second apply functions to pairs
03:08:56 <Peaker> @type \f -> join (***)
03:08:57 <lambdabot> forall t (a :: * -> * -> *) b c. (Arrow a) => t -> a b c -> a (b, b) (c, c)
03:08:58 <yitz> pumpkin: it already exists. it's called join.
03:08:59 <Peaker> oops
03:09:02 <Peaker> @type join (***)
03:09:03 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
03:09:08 <pumpkin> yeah, I know :)
03:09:13 <pumpkin> I use that all the time, but I think it should be named
03:09:28 <Peaker> pumpkin: I mean   both = join (***) = first f >>> second f
03:09:34 <pumpkin> yeah, I know
03:09:37 <yitz> @type join (,)
03:09:38 <lambdabot> forall a. a -> (a, a)
03:10:00 <pumpkin> I was just going to define it in terms of first and second to be more explicit about the ordering (as the functions in Arrow tend to do)
03:10:05 <pumpkin> but yeah, that works too
03:10:09 <yitz> of course (,) is just sugar for curry id
03:10:39 <pumpkin> :t curry id
03:10:40 <lambdabot> forall a b. a -> b -> (a, b)
03:10:58 <pumpkin> I've never found myself using curry much
03:11:06 <pumpkin> I guess not many functions take pairs
03:11:33 <pumpkin> ick, the sun is coming up
03:11:40 <yitz> pumpkin: I guess you're not into indian cuisine
03:11:49 <pumpkin> I actually make curry a lot :)
03:11:57 <pumpkin> I love cooking
03:12:03 <Peaker> pumpkin: uncurry is useful though
03:12:10 <pumpkin> oh yeah, I use that all the time
03:12:25 <pumpkin> especially with the arrow functions
03:15:27 <pumpkin> alright, bedtime
03:27:44 <Fred320> @src nub
03:27:44 <lambdabot> nub = nubBy (==)
03:27:51 <Fred320> @src nubBy
03:27:51 <lambdabot> nubBy eq []             =  []
03:27:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:28:36 <Fred320> @pl \ y -> not (eq x y)
03:28:37 <lambdabot> not . eq x
03:28:37 <dev312> Hi, I have a question that may just indicate my lack of experience.
03:28:53 <dev312> If I have a return type of a function, that is wrapped in a monad, how can I get direct access to the data?
03:29:04 <dev312> or is that not possible, like private variables in a class in OO languages?
03:29:18 <mebbel> dev312: what data?
03:29:20 <yitz> hmm... the haskell platform contents page just links to the current hackage page for each package. how do you see at a glance exactly which version of each package is included in a specific HP version?
03:29:33 <QtPlaty[HireMe]> dev312: Something liike IO Foo?
03:29:36 <pumpkin> dev312: it's not always meaningful, as not all monads "contain" data
03:29:52 <dev312> It is of the CGI module... getVars..it returns (MonadCGI m)=> m ( [(String,String)] )
03:29:55 <Peaker> how hard would it be for ghci to allow data declarations?
03:29:59 <mebbel> and then you say "the x in M x" and then I say "that's just a type, not data"
03:30:07 <Zao> pumpkin: The Id monad? :)
03:30:13 <mebbel> and then I tell you how "<-" in a do block is a virtual unwrap
03:30:29 <Peaker> dev312: you can access the data directly in a monad, but only in a computation that is itself also in the monad..
03:30:40 <dev312> I see.
03:31:13 <dev312> So I would have to create my own monad, then can somehow release the data after combining with this monad?
03:31:18 <dev312> Or am I still on the wrong track?
03:31:21 <Peaker> dev312: if you have an   Monad m =>(m a)    which is an "a wrapped in a Monad m",   then you can use  >>= to access the "a" but your result will be an "m b"
03:31:24 <dev312> is the fact that I can  never just have a plain list?
03:31:34 <dev312> ahh ok
03:31:54 <Peaker> dev312: note that its all the same monad type, no mixing of different monads here, just different values of the same monad-type
03:32:06 <dev312> ok :(
03:32:07 <dev312> gotcha
03:32:09 <dev312> makes sense
03:32:55 <foobaer> i don't know the CGI monad, but often you start a monad computation with a runFoo function and this function also returns the result of the monad computation unwrapped
03:32:59 <yitz> pumpkin: go to sleep, otherwise you'll be sorry later
03:33:08 <Peaker> dev312: you can think of a monad as a description of some "special" computation -- you can only access the value, which is namely to "sequence another same-special computation on top of the existing one"
03:33:13 <pumpkin> yeah :(
03:33:27 <pumpkin> sleep feels like such a waste of time, even though I know it isn't
03:33:45 <dev312> PEaker, ok thanks..that makes sense
03:33:56 <dev312> I guess it is better for me not to be able to mess with the internals anyway
03:34:32 <Peaker> dev312: What do you mean by "mess with the internals"?
03:34:33 <dev312> That being said, if the writer of a Monad wanted to provied a convenience function to get data out of a monad, they could
03:34:34 <dev312> ?
03:34:44 <mebbel> depends on the monad
03:34:45 <Peaker> dev312: No, the whole point of the Monad is that there's no escaping it
03:34:55 <mebbel> Peaker: I strongly disagree
03:34:56 <dev312> Well, flatly, so it is understood what I am saying, I just want the list
03:35:04 <Peaker> well, not the whole point, one of the points :-)
03:35:07 <dev312> I want to discard the monad and just have the list that it contains
03:35:10 <mebbel> I still disagree
03:35:15 <yottis> but that's exactly what those run*, exec* and eval* functions do
03:35:22 <mebbel> dev312: >>=
03:35:40 <Peaker> dev312: First, you should understand that Monad is just a type-class, or a "common interface" that various types provide an implementation for.  Each type may provide any extra functions specific to that type in addition to the monad interface
03:35:45 <yottis> there's just not anything that works for all monads, but nothing prevents you from creating one for a particular instance
03:35:46 <foobaer> Peaker: what about the Maybe monad. there you can escape :)
03:35:50 <dev312> hmm ok mebbel
03:35:53 <dev312> let me check that out
03:35:53 <Peaker> dev312: so some types may provide the Monad interface AND a way to exit the monad, but the Monad interface itself provides no such way
03:35:58 <Peaker> foobaer: what if its Nothing?
03:36:09 <foobaer> Peaker, well you have to check it of couse
03:36:15 <doserj> dev312: I guess "<-" in a do-block is what you want
03:36:24 <pumpkin> some monads you can escape from reliably, like ST
03:36:28 <Peaker> dev312: If you want to write code that is *general* to all monads, you can't even assume that there's actually a list of values "in" it
03:36:37 <dcoutts> yitz: what was the HP question?
03:36:52 <mebbel> data W a = W; instance Monad W where return _ = W; W >>= _ = W
03:37:05 <dev312> Peaker, I understand
03:37:11 <dev312> I understand that not all monads are the same
03:37:16 <dev312> and not all monads are "containers"
03:37:17 <dev312> etc
03:37:20 <pumpkin> class EscapableMonad m where escape :: m a -> a
03:37:24 <dev312> Well I do now
03:37:25 <dev312> anyway
03:37:42 <pumpkin> Comonad
03:39:25 <Peaker> dev312: anyway - remember that Monad is just an "interface" that you can program with to get generality of your code -- generality always means you can assume less. In the case of Monads, you can only assume that you can "sequence computations". Once you use a specific type, you can assume much more
03:40:03 <Peaker> dev312: Its probably better to first understand Functor, then Applicative, then Monads, because they form natural extensions of each other, and Monads are the most complicated
03:40:23 <dev312> ok, well yeah functors I have an understanding of
03:40:29 <dev312> and even Monads, to a degree
03:40:36 <Peaker> dev312: Well, how do you "exit" a Functor?
03:40:42 <Peaker> dev312: how do you extract the value from a Functor?
03:40:44 <dev312> What I am probably doing is wrong is simply not being ablt to find the proper convenience functions in this library
03:40:57 <dev312> Right, being tested now.
03:41:03 <dev312> Ill pass, no pun intended.
03:42:43 <Peaker> dev312: I want to help you understand Monad by understanding the class hierarchy above it
03:55:32 <Berengal> Success!
03:55:44 <Berengal> class (Show (B b)) => Foo b where type B b :: *
03:57:17 <dev312> ok Peaker, I have decided to slow down and study Applicative functors.
03:57:37 <dev312> Not that this will solve my problem, but I do agree, in principle , it is best to understand fundamentals
04:07:51 <yitz> dcoutts: hmm... the haskell platform contents page just links to the current hackage page for each package. how do you see at a glance exactly which version of each package is included in a specific HP version?
04:07:59 <yitz> dcoutts: hmm... the haskell platform contents page just links to the current hackage page for each package. how do you see at a glance exactly which version of each package is included in a specific HP version?
04:09:24 <dcoutts> http://hackage.haskell.org/platform/2009.2.0/haskell-platform.cabal
04:09:45 <dcoutts> yitz: yeah the package list should say, but it's also in the .cabal file for the platform meta-package
04:10:04 <yitz> I see. thanks.
04:10:58 * araujo just released new himerge version1
04:11:03 <araujo> !
04:13:05 <yitz> araujo: link?
04:14:41 <araujo> @where himerge
04:14:41 <lambdabot> http://www.haskell.org/~luisfaraujo/himerge/
04:14:45 <araujo> err
04:14:51 <araujo> www.haskell.org/himerge
04:14:53 <araujo> that one
04:15:40 <yitz> araujo: nice!
04:16:02 <araujo> :D
04:16:07 <yitz> araujo: that page makes it look like himerge is only for haskell users
04:16:11 <mebbel> @where+ himerge http://www.haskell.org/himerge/
04:16:11 <lambdabot> It is forever etched in my memory.
04:16:29 <yitz> araujo: but in reality I'll bet it's userful for all gentoo users
04:16:32 <yitz> useful
04:16:34 <araujo> yitz, think so? ... why?
04:16:45 <araujo> yeah, I know many gentoo users in general using it
04:17:07 <araujo> I like when people who don't even know haskell use it :)
04:17:18 <araujo> we needm or of those types around
04:17:23 <araujo> more*
04:18:12 <yitz> araujo: maybe you should just write at the bottom that it is implemented in haskell/gtk2hs, where it says Himerge is Free Software...
04:18:39 <mebbel> "Himerge is a graphical user interface (GUI) for the Gentoo portage system written entirely on Haskell using the Gtk2Hs library."  <- looks fine to me
04:18:50 <yitz> araujo: so you won't scare away any haskephobics :)
04:19:05 <araujo> yeah, it is explained in the first paragraph ... it is indeed an important thing to miss
04:19:51 <araujo> yitz, my experience (luckily?) has been the opposite ... many of them seem curious about it and at least give it a try
04:19:57 <yitz> mebbel: if it were written in C using gtk+, you wouldn't mention that in the first paragraph. possibly not at all on the front page
04:20:05 <araujo> when they know what haskell is
04:20:23 <mebbel> yitz: yes, I would
04:20:53 <yitz> ok, i guess it's a matter of style
04:20:56 * araujo likes that kind of information at first if possible 
04:21:35 <araujo> yeah, i guess it is a matter of design and how the developer tries to reach the community
04:22:02 <araujo> in my case with himerge, I wanted to show Haskell can indeed be used for daily GUI apps
04:22:11 <araujo> so the language is written is very important
04:22:17 <yitz> araujo: yeah, that's really great!
04:22:29 <yitz> araujo: though I would like it to become unsurprising
04:22:44 <araujo> unsurprising?
04:23:00 <yitz> araujo: that you really can write a nice gui app easily in haskell
04:23:29 <Peaker> Haskell is a fine imperative language too :)
04:23:36 <araujo> yitz, yeah, you can!
04:23:48 <araujo> Himerge's main purpose is to show that actually
04:24:05 <yitz> Peaker: ok, ok, it will be even better once the reactive stuff becomes more mature
04:24:46 <yitz> I hope that will be soon
04:25:16 <Peaker> yitz: Baughn is helping with unamb now, and I think there aren't many bugs left in there
04:25:23 <yitz> great!
04:25:25 <Peaker> yitz: someone needs to debug why joinE doesn't work
04:25:27 <mebbel> heh
04:25:29 <Peaker> I wish I had some time
04:25:51 <mebbel> "I think there aren't many bugs left in there" <- famous last words
04:26:24 <yitz> mebbel: Fermat once said something along those lines.
04:26:48 <yitz> they did get it debugged eventually though.
04:26:56 <mebbel> haha
04:27:26 <mebbel> imagine writing a program that takes 400 years to debug
04:31:39 <Axman6> anyone know who Arnaud Payement is?
04:37:00 * myst is listening Lacrimosa - I lost my star in Krasnodar [Sehnsucht, 2009]
04:38:08 <Axman6> wow, never seen now playing spam in #haskell before
04:38:10 <cob_jonas> myst++ after that line the name Arnaud Payement doesn't look so strange
04:38:49 <myst> sorry guys it was a test
04:40:17 <Berengal> I like it when code just works. I like haskell
04:42:21 <araujo> :)
04:43:06 <Berengal> I was writing some java at work today, when suddenly a bug attacked. I was actually shocked, because the code compiled just fine
04:43:18 <HugoDaniel> hi
04:43:36 <Berengal> Hello
04:43:46 <kynky> run time error vs compile time error ?
04:43:49 <Baughn> yitz: NEar as I can tell,there are no bugs in my last version of unamb
04:44:01 <Baughn> yitz: I'm now working on performance, via RTS hacks
04:44:07 <Berengal> kynky: Not an "error" as such, just garbage execution
04:44:11 <cob_jonas> it's not like that's impossible in haskell either, only much rarer
04:44:20 <Baughn> p_l: while true; do mkdir a; cd a; done
04:44:22 <yitz> Well, here is Arnaud Payement's thesis (master's?) at Oxford: http://progtools.comlab.ox.ac.uk/projects/jungl/resources/arnaud_msc_thesis.pdf
04:45:03 <cob_jonas> Baughn: that's evil
04:45:11 <yitz> He acknowledges his advisor Oege de Moor, and Mathieu Verbaere.
04:45:22 <cob_jonas> Baughn: if you do it a tricky way you can even get an undeletable directory that way
04:45:32 <Baughn> cob_jonas: How's that?
04:45:45 <cob_jonas> Baughn: depends on what system you're on
04:45:50 <cob_jonas> on DOS it's definitely possible
04:45:52 <Baughn> Linux, so no directory hardlinks.
04:46:08 <Peaker> Berengal: :)
04:46:21 <cob_jonas> Baughn: you can have bind mounts or just plain remount an fs to a longer mount path
04:46:27 <Peaker> Berengal: I find that FP Haskell code "Just works" and that imperative Haskell code still has some bugs fly through
04:46:32 <yitz> Baughn: glad to hear about the progress.
04:46:45 <cob_jonas> I'm not sure if you can do this in linux though
04:47:03 <Baughn> yitz: Beyond that, the reactive Monad instance is badly broken, and unfortunately it's used all over the place.
04:47:04 <cob_jonas> maybe if you're tricky you could get one you can't delete because you don't have enough memory or something
04:47:06 <hackagebot> storable-record 0.0.1
04:47:08 <cob_jonas> but I doubt
04:47:20 <Baughn> yitz: That said, fixing unamb fixes quite a lot of its issues. :)
04:47:24 <yitz> Baughn: that's pretty fundamental
04:47:26 <Baughn> yitz: (Most notably the deadlocks)
04:47:30 <HugoDaniel> is there anything similar to assembly in haskell ?
04:47:34 <Berengal> Peaker: Yeah, that's my experience as well.
04:47:38 <cob_jonas> HugoDaniel: in what way?
04:47:42 <Baughn> HugoDaniel: C?
04:47:54 <yitz> the Monad instance is in some ways the most important contribution
04:48:02 <EvilTerran> HugoDaniel, there's core, being the intermediate language a compiler uses
04:48:10 <EvilTerran> HugoDaniel, (but that varies from compiler to compiler)
04:48:18 <Peaker> yitz: the Monad instance of what?
04:48:31 <yitz> reactive
04:48:41 <Berengal> Peaker: But that's still much better than languages where everything is imperative
04:48:43 <cob_jonas> also in dos you can have a directory in which you can only put files of short names
04:48:47 <cob_jonas> which is a bit funny
04:48:54 <Peaker> Berengal: and the imperative part is far more powerful
04:49:20 <Berengal> Peaker: The imperative part is like perl on crack
04:50:04 <HugoDaniel> hmm
04:50:05 <yitz> cob_jonas: ever mount an old dos partition on linux? it's also really weird.
04:50:10 <FunctorSalad> hmm... are you not supposed to use stream-fusion/Data.Stream manually?
04:50:13 <HugoDaniel> anyone up to coding an "Assembly Monad" in haskell ?
04:50:27 <Berengal> HugoDaniel: It's been done
04:50:28 <yitz> FunctorSalad: why not?
04:50:32 <mebbel> HugoDaniel: what, like harpy?
04:50:33 <HugoDaniel> Berengal: where ?
04:50:46 <cob_jonas> yitz: I have. I had to to set up the virtual machine with dos.
04:50:53 <FunctorSalad> yitz: I tried rewriting the meteor benchmark to use streams directly, and got ~30x slowdown :-(
04:50:57 <Berengal> HugoDaniel: http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
04:51:00 <cob_jonas> but it's not so bad as mounting them from dos
04:51:04 <FunctorSalad> yitz: with most of the time lost in concatMap
04:51:25 <yitz> FunctorSalad: does sound like you're losing your fusion.
04:51:35 <cob_jonas> where depending on what codepage you loaded with mode, you can use different characters in filenames (and the case mapping is different too) so you can have files you can't delete
04:51:39 <yitz> FunctorSalad: look over dons' blog about it
04:52:39 <yitz> cob_jonas: unmount; format should do the trick
04:53:00 <cob_jonas> yitz: sure, but it's easier to just rename them with norton utilities disk editor
04:53:11 <yitz> hehe
04:53:14 <HugoDaniel> allright, harpy seems like the right tool to use and abuse :D
04:53:18 <cob_jonas> or to mount in linux and rename from there
04:53:55 <FunctorSalad> yitz: there is a lot of commented out stuff about concatMap, I guess there's still some problem with it?
04:54:11 <cob_jonas> or there's some of those fsck utilities (there are like three for dos, each having a slightly different idea about what's valid on fat and what isn't)
04:54:37 <FunctorSalad> of course, maybe it's my fault and I blocked the fusion somehow
04:55:17 <yitz> cob_jonas: in short: what a mess
04:56:13 <yitz> FunctorSalad: don't know. but if you look at the core and experiment, you should be able to figure it out.
04:56:50 <FunctorSalad> is there some ghc flag you need to set apart from -O2?
04:57:54 <Berengal> @djinn (a -> (b -> c)) -> (a -> b) -> a -> c
04:57:54 <lambdabot> f a b c = a c (b c)
04:58:02 <Berengal> Hmmm, S
04:58:20 <Berengal> I should've gotten that from the type...
04:59:12 <joeally> Is anyone familiar to project euler
04:59:29 <mib_e7tcavos> hey
04:59:40 <mib_e7tcavos> wondering if anyone can help me
04:59:59 <joeally> I'll try but i am a noob myself
05:00:01 <mib_e7tcavos> gt a slight problem with some code
05:00:29 <joeally> okay..
05:00:47 <EvilTerran> mib_e7tcavos, don't ask to ask, just ask; we don't know if we can help you 'til you tell us what the problem is.
05:00:56 <mib_e7tcavos> kl
05:01:18 <mib_e7tcavos> gt an algebraic type i blieve
05:01:29 <mib_e7tcavos> data Film = Film Title Director Year [Fans]
05:02:13 <mib_e7tcavos> exampleFilms :: [Film]
05:02:30 <mib_e7tcavos> exampleFilms = [(Film "Blade Runner" "Ridley Scott" 1982 ["Garry", "Dave", "Zoe"])]
05:02:43 <mib_e7tcavos> so i have a list of films
05:03:02 <mib_e7tcavos> now im trying to add a film
05:03:13 <mib_e7tcavos> addFilm ::  Title -> Director -> Year -> [Film] -> [Film]
05:03:24 <mib_e7tcavos> addFilm ti di ye film = film ++ [(Film ti di ye [])]
05:03:33 <mib_e7tcavos> ive compiled
05:03:49 <mib_e7tcavos> and it tells me it doesnt have a show function
05:03:52 <mib_e7tcavos> any ideas?
05:04:05 <cob_jonas> what it says
05:04:09 <mebbel> yeah, data Film = Film Title Director Year [Fans] deriving (Show)
05:04:41 <mebbel> looks like your code is fine, it just doesn't know how to print the results
05:04:53 <mib_e7tcavos> oh so i just put deriving show when im declaring
05:04:56 <Neut> using a list comprehension, how would I define a function which does this,
05:05:02 <mebbel> yes
05:05:12 <Neut> matches 1 [1,2,4,2,1,2] ~~ [1,1]
05:05:14 <mib_e7tcavos> awesome
05:05:20 <mib_e7tcavos> thanks for the help
05:05:43 <mebbel> matches k xs = [x | x <- xs, x == k]
05:05:45 <Axman6> \y xs -> [ x | x <- xs, x == y]
05:05:54 <Berengal> Neut: matches n l = [e | e <- l, n == e]
05:06:28 <mebbel> spot the non-idiomatic haskeller :-)
05:06:59 <yitz> > let matches k xs = [x | x <- xs, x == k] in matches 1 [1,2,4,2,1,2]
05:07:00 <lambdabot>   [1,1]
05:07:02 <Neut> thanks
05:08:01 <cob_jonas> is that just  matches m = filter (m ==)
05:08:07 <Axman6> yah
05:08:13 <Berengal> @type filter <$> (==)
05:08:14 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
05:08:34 <Berengal> > let matches = filter <$> (==) in matches 1 [1,2,4,2,1,2]
05:08:34 <yitz> @type filter . (==)
05:08:35 <lambdabot>   [1,1]
05:08:36 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
05:09:14 <yitz> @pl matches k xs = [x | x <- xs, x == k]
05:09:14 <lambdabot> matches = flip ((:) . ((x | x) <-)) . return . (x ==)
05:09:19 <yitz> hehe
05:09:38 <Axman6> ha
05:09:59 <yitz> where do you file a bug against @pl ?
05:10:01 <cob_jonas> let's write it with guard
05:10:09 <Axman6> @undo matches k xs = [x | x <- xs, x == k]
05:10:10 <lambdabot> matches k xs = concatMap (\ x -> if x == k then [x] else []) xs
05:10:22 <Axman6> @. pl undo matches k xs = [x | x <- xs, x == k]
05:10:22 <zachk> joeally: yea im on euler, im up to problem 14, none of your haskell programs should reall go over like 60 lines
05:10:22 <lambdabot> matches = (=<<) . flip flip [] . (`ap` return) . (if' .) . (==)
05:10:38 <yitz> ah, much better
05:10:56 <zachk> joeally: though ive been at haskell for a year, ive seen people take 30 lines of my code and drop it down to one line of code, a year latter its one function in Data.List
05:12:23 * wli is having really bad luck with project euler.
05:12:49 <Neut> using comprehensions again,
05:12:55 <Neut> how would I define a function wihch
05:13:10 * yitz had fun for the first 100 or so, then it started getting tedious
05:13:21 <Neut> addPairwise [1,7] [8,4,2] ~~ [9,11]
05:13:33 * wli is just too dumb to solve many of them.
05:13:36 <yitz> Neut: try it yourself first
05:13:58 * Berengal would just zipWith (+)
05:14:04 <Neut> yeah I have, but I can't work it out which is why I have jumped on IRC
05:14:10 <mebbel> Neut: not possible in H98
05:14:15 <mebbel> that needs an extension
05:14:16 <Berengal> mebbel: Sure it is
05:14:19 <wli> The few I can solve often have unacceptably slow solutions.
05:14:27 <mebbel> Berengal: zip doesn't count
05:14:31 <Axman6> > zipWith (+) [1,7] [8,4,2]
05:14:32 <lambdabot>   [9,11]
05:14:35 <Berengal> mebbel: Sure it does
05:14:37 <yitz> Neut: what have you tried?
05:14:53 <burp> uh, how does zipWith work with unequal sized lists?
05:15:03 <yitz> burp: it just quits
05:15:10 <yitz> after one runs out
05:15:11 <Neut> [m + n | (m,n) <- zip list1 list2]
05:15:12 <wli> e.g. the fastest multiplication thing
05:15:12 <Axman6> @src zipWith
05:15:12 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:15:12 <lambdabot> zipWith _ _      _      = []
05:15:20 <burp> ah I see
05:15:25 <Berengal> > let addPairwise xs ys = [r | r <- zipWith (+) xs ys] in addPairwise [1,7] [8,4,2] -- :P
05:15:26 <lambdabot>   [9,11]
05:15:45 <yitz> Neut: that looks good. try it here with lambdabot
05:16:01 <Axman6> > [x + y | x <- [1,7] | y <- [8,4,2]]
05:16:02 <lambdabot>   [9,11]
05:16:05 <Axman6> whoot
05:16:12 <Neut> >let addPairwise' = [m + n | (m,n) <- zip list1 list2]
05:16:20 <yitz> Axman6: that's not H98 though.
05:16:24 <mebbel> Berengal: then so does [x | x <- zipWith (+) xs ys]
05:16:24 <Axman6> ah
05:16:35 <yitz> Neut: you need a space after the >
05:16:41 <Neut> kk thanks
05:16:45 <Neut> > let addPairwise' = [m + n | (m,n) <- zip list1 list2]
05:16:46 <Berengal> mebbel: Huh?
05:16:47 <lambdabot>   not an expression: `let addPairwise' = [m + n | (m,n) <- zip list1 list2]'
05:17:46 <yitz> Neut: put list1 and list2 as parameters after the function name. then put "in ..." at the end to try out your function with an example.
05:17:46 <cob_jonas> > let { addPairwise' = [m + n | (m,n) <- zip list1 list2] } in addPairwise' [1,7] [8,4,2]
05:17:47 <lambdabot>   Not in scope: `list1'Not in scope: `list2'
05:17:56 <Axman6> > let addPairwise' list1 list2 = [m + n | (m,n) <- zip list1 list2] in addPairwise' [1,7] [8,4,2]
05:17:57 <lambdabot>   [9,11]
05:18:06 <Neut> ooo works
05:18:08 <Neut> thanks
05:18:53 <Ferdirand> > let addPairwise = zipWith (+) in addPairwise [1,7] [8,4,2]
05:18:54 <lambdabot>   [9,11]
05:19:20 <Neut> yeah I know there are higher order functions for it,
05:19:26 <Berengal> > getZipList $ (+) <$> ZipList [1,7] <*> ZipList [8,4,2]
05:19:27 <lambdabot>   [9,11]
05:19:28 <Neut> just practising list comprehensions
05:21:00 <mebbel> Neut: for bonus points, rewrite your list comprehensions using do syntax
05:24:24 <urquell> Berengal: What's the <$> and <*> thingies?
05:24:42 <Axman6> :t (<$>)
05:24:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:24:44 <Axman6> :t (<*>)
05:24:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:25:44 <Axman6> > (,) <$> [1..5] <*> ['a'..'c']
05:25:45 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4...
05:25:50 <Axman6> > (,) <$> [1..3] <*> ['a'..'c']
05:25:51 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
05:26:14 <Axman6> :t (,) <$> [1..3]
05:26:15 <lambdabot> forall a b. (Num a, Enum a) => [b -> (a, b)]
05:26:49 <Philonous1> @type \x -> fmap ($ x)
05:26:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
05:27:28 <Neut> with the matches function, matches k xs = [x | x <- xs, x==k]
05:27:40 <Neut> how would I chnage it so that it only returns unique items from a list
05:27:57 <Philonous1> @type fmap.fmap
05:27:58 <Neut> ie [1,2,3,2,1,4,5] ~~ [3,4,5]
05:27:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:29:42 <cob_jonas> > M.fromList [(1,5)]
05:29:43 <lambdabot>   fromList [(1,5)]
05:31:38 <DrSyzygy> ?quickcheck (M.toList . M.fromList) xs == xs where _ = xs :: [(Int,Int)]
05:31:38 <lambdabot> Unknown command, try @list
05:31:42 <DrSyzygy> ?list
05:31:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:31:55 <DrSyzygy> Wasn't there some in-channel quickcheck interface?
05:32:10 <Axman6> @check True
05:32:11 <lambdabot>   "OK, passed 500 tests."
05:32:20 <DrSyzygy> ?check (M.toList . M.fromList) xs == xs where _ = xs :: [(Int,Int)]
05:32:20 <lambdabot>   Parse error at "where" (column 34)
05:32:41 <DrSyzygy> ?check \(xs :: [(Int,Int)] -> (M.toList . M.fromList) xs == xs
05:32:42 <lambdabot>  Unbalanced parentheses
05:32:49 <cob_jonas> > let { ie s = map fst (filter ((1 ==) . snd) (M.toList (M.fromListWith (+) (map (flip (,) 1) s)))); } in ie [1,2,3,2,1,4,5] {- M is Data.Map -}
05:32:50 <lambdabot>   [3,4,5]
05:32:50 <DrSyzygy> ?check \(xs :: [(Int,Int)] -> (M.toList . M.fromList) xs == xs)
05:32:50 <lambdabot>   Parse error at "M.toL..." (column 25)
05:32:57 <cob_jonas> => Neut
05:32:57 <DrSyzygy> Meh
05:33:12 <Neut> yes?
05:33:29 <RayNbow> @check \xs :: [(Int,Int)] -> (M.toList . M.fromList) xs == xs
05:33:29 <lambdabot>   Parse error at "::" (column 5)
05:33:31 <doserj> ?check \xs -> (M.toList . M.fromList) xs == (xs::[(Int,Int)])
05:33:33 <lambdabot>   "Falsifiable, after 3 tests:\n[(2,-3),(-1,0)]\n"
05:33:39 <cob_jonas> Neut: that's the function you wanted, didn't you?
05:33:49 <cob_jonas> it gave [3,4,5] from [1,2,3,2,1,4,5]
05:33:50 <DrSyzygy> doserj: Thanks.
05:33:56 <cob_jonas> or do you also want to keep the order?
05:34:00 <cob_jonas> because this one doesn't
05:34:16 <cob_jonas> > let { ie s = map fst (filter ((1 ==) . snd) (M.toList (M.fromListWith (+) (map (flip (,) 1) s)))); } in ie [1,5,2,3,2,1,4]
05:34:18 <lambdabot>   [3,4,5]
05:34:20 <Neut> is it possible to do with a simpler list comprehension?
05:34:21 <DrSyzygy> ?check \xs -> (sort . M.toList . M.fromList) xs == sort (xs::[(Int,Int)])
05:34:23 <lambdabot>   "Falsifiable, after 11 tests:\n[(0,3),(-3,0),(-6,-4),(3,0),(3,6)]\n"
05:34:47 <cob_jonas> Neut: it probably is
05:34:50 <cob_jonas> dunno
05:35:20 <doserj> DrSyzygy: toList.fromList removes duplicate keys
05:35:23 <cob_jonas> well this one has a map and filter which you can rewrite to a single list comprehension
05:35:47 <cob_jonas> try it if you want to
05:35:47 <DrSyzygy> doserj: I expected that but wanted to see QuickCheck confirm it. :-P
05:36:05 <Neut> thanks cob_jonas
05:37:14 <zachk> sweet, i wrote drop using foldr and zip
05:37:59 <cob_jonas> zip? you mean zip with iota?
05:38:19 <zachk> > mydrop2 5 [1..10] where mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd):y) [] $ zip [1..] list
05:38:21 <lambdabot>   <no location info>: parse error on input `where'
05:39:05 <zachk> > let  mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd):y) [] $ zip [1..] list in mydrop2 5 [1..10]
05:39:06 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, b) -> b)
05:39:06 <lambdabot>    arising from a use...
05:39:12 <cob_jonas> > let { mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd):y) [] $ zip [1..] list } in mydrop2 5 "policeman"
05:39:13 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, b) -> b)
05:39:13 <lambdabot>    arising from a use...
05:39:24 <zachk>  mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd x):y) [] $ zip [1..] list
05:39:38 <zachk> > mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd x):y) [] $ zip [1..] list
05:39:40 <lambdabot>   <no location info>: parse error on input `='
05:39:46 <zachk> i quit it works in ghci
05:39:51 <cob_jonas> @type let { mydrop2 n list = foldr (\x y-> if fst x<=n then y else (snd):y) [] $ zip [1..] list } in mydrop2 5 "policeman"
05:39:53 <lambdabot> forall a b. [(a, b) -> b]
05:40:17 <cob_jonas> maybe you copied it wrong?
05:41:45 <zachk> yea i typed it wrong
05:41:52 <zachk> did where stop working in lambdabot?
05:42:25 <cob_jonas> huh?
05:43:36 <byorgey> @where where
05:43:36 <lambdabot> ?where where
05:43:46 <byorgey> @where hcar
05:43:47 <lambdabot> http://www.haskell.org/communities/
05:43:53 <byorgey> looks ok to me
05:44:52 <zachk> > let  mydrop n list = foldr (\x y-> if fst x<=n then y else (snd x):y) [] $ zip [1..] list in mydrop 5 [1..10]
05:44:53 <lambdabot>   [6,7,8,9,10]
05:44:58 <zachk> there we go :-D
05:51:44 <Phyx-> Afternoon, I was wondering how do you check if a value is undefined?
05:51:53 <cob_jonas> > SimpleReflect.var$concatMap(["\"","\\",",","> SimpleReflect.var$concatMap([","]!!)[3,0,1,0,0,2,0,1,1,0,2,0,2,0,2,0,3,0,2,0,4,0,4]"]!!)[3,0,1,0,0,2,0,1,1,0,2,0,2,0,2,0,3,0,2,0,4,0,4]
05:51:55 <lambdabot>   > SimpleReflect.var$concatMap(["\"","\\",",","> SimpleReflect.var$concatMap...
05:51:58 <cob_jonas> Phyx-: you don't
05:52:26 <Phyx-> there must be someway
05:52:41 <Botje> Phyx-: nope.
05:52:54 <Botje> why do you need to know if something is undefined?
05:53:18 <yitz> Phyx-: you design your code so that it will never be undefined, guaranteed.
05:53:35 <cob_jonas> the whole point of bottom is that you don't check for it, right?
05:53:47 <Botje> you /can't/ check for it
05:53:51 <Botje> not without becoming bottom yourself
05:54:23 <doserj> @hoogle isBottom
05:54:24 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
05:55:07 <Phyx-> doserj: thanks :)
05:56:08 <Botje> O_O
05:56:17 <doserj> Phyx-: you should know what you are doing, though, before you use this function
05:56:20 <Botje> did the quickcheck guys solve the halting problem?
05:56:38 <cob_jonas> Botje: no, it's just an unsafePerformIO without unsafe in it's name
05:56:53 <Phyx-> Botje: no, you just evaluate it and catch the exception
05:57:04 <Phyx-> i was thinking that aswell, but asked first
05:57:53 <Phyx-> doserj: yes, i know what i'm doing :) The only other way i could solve what i'm doing is by using syb and make a generic producer, but using undefined to initialize is much easier
05:58:54 <yitz> > isBottom $ fix ("a" ++)
05:58:55 <lambdabot>   Not in scope: `isBottom'
05:59:22 <yitz> > Test.QuickCheck.Batch.isBottom $ fix ("a" ++)
05:59:24 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
05:59:31 <yitz> darn
06:00:00 <doserj> yitz: you didn't expect unsafePerformIO to be in scope in lambdabot, did you?
06:00:26 <Phyx-> hehehe
06:00:30 <yitz> doserj: I didn't expect isBottom to exist at all, if you want to know the truth
06:01:36 <doserj> yitz: it is cheating of course. it won't catch last [0..], for example.
06:01:58 <Phyx-> which i don't need anyway, i'm also cheating in a sense :)
06:02:10 <cob_jonas> will it catch out of memory? or sigint?
06:02:39 <cob_jonas> or killThread?
06:02:55 <Phyx-> it'll catch anything that throw an exception i beleive
06:02:56 <yitz> so it runs the function in a separate thread and looks for an exception?
06:03:15 <cob_jonas> yitz: why separate thread?
06:04:54 <doserj> yitz: it is basically unsafePerformIO . try . evaluate
06:05:27 <cob_jonas> isn't evaluate evil and does something completely different from its name?
06:05:35 <cob_jonas> or that doesn't matter at this point?
06:05:44 <yitz> ok got it.
06:07:28 <cob_jonas> @src Test.QuickCheck.Batch.isBottom
06:07:28 <lambdabot> Source not found. Sorry.
06:08:41 <doserj> cob_jonas: evaluate is a (almost) just return $! x in the IO Monad
06:10:35 <doserj> cob_jonas: 'evaluate x' is an IO action that, when executed, evaluates x
06:10:49 <amgarching> hi, why doesnt this work: 1 % 2 % 3 ??
06:11:14 <Peaker> @type (%)
06:11:15 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:11:35 <Peaker> @type (1%2)%3
06:11:36 <lambdabot> forall t. (Integral t, Integral (Ratio t)) => Ratio (Ratio t)
06:12:08 <kpreid> > 1 / 2 / 3 :: Ratio Integer
06:12:09 <lambdabot>   1 % 6
06:12:22 <Peaker> hmm -- (Ratio t) is not a type variable, why does @type allow it to be in a class constraint?
06:12:40 <amgarching> how do I type, say  i * j / k * l / m / n if I want it to be a Ratio?
06:12:40 <Peaker> > 1%2%3
06:12:41 <Berengal> Peaker: -XFlexibleContexts?
06:12:42 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
06:12:42 <lambdabot>    arising from a us...
06:12:43 <kpreid> amgarching: because % is the "ratio of integers" operation and 1 % 2 is not an  integer
06:12:48 <Peaker> Berengal: what does that do?
06:13:04 <kpreid> amgarching: use / instead
06:13:07 <Berengal> Peaker: Allow more than just variables in contexts
06:13:24 <DrSyzygy> > i * j / k * l / m / n :: Ratio Exp
06:13:25 <lambdabot>   Not in scope: type constructor or class `Exp'
06:13:36 <DrSyzygy> > 2 * 3 / 4 * 5 / 6 / 7 :: Ratio Int
06:13:37 <lambdabot>   5 % 28
06:13:50 <kpreid> > 1 :: Expr
06:13:51 <lambdabot>   1
06:14:00 <DrSyzygy> > i * j / k * l / m / n :: Ratio Expr
06:14:01 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio SimpleReflect.Expr'
06:14:05 <cob_jonas> amgarching: if they're all integers, then (i * j * l) % (k * m * n) or just put fromInteger before each and then use * and /
06:14:13 <kpreid> > i * j / k * l / m / n :: Expr
06:14:14 <lambdabot>   i * j / k * l / m / n
06:14:26 <cob_jonas> as in (fromIntegral i) * (fromIntegral j) / (fromIntegral k) * ...
06:15:29 <amgarching> ok, I got the idea, let me try. Thanks.
06:16:48 <yitz> > 2 * 3 % 4 * 5 / 6 / 7
06:16:49 <lambdabot>   5 % 28
06:17:44 <yitz> amgarching: use % for the first division, / for the rest
06:17:56 <cob_jonas> yitz: nope
06:18:08 <yitz> cob_jonas: counterexample?
06:18:13 <cob_jonas> yitz: that only works because number literals are both integers and rationals
06:18:21 <yitz> cob_jonas: right
06:18:51 <cob_jonas> well I'm not sure what type i and j etc really has in amgarching's question
06:19:12 <yitz> the first one makes the type of the expression a Ratio, the rest are division for that type with the literals typed as Ratios
06:19:13 <cob_jonas> but if they're all integers than that's not enough, if they're all ratios (including literals) then you don't need that one % neither
06:19:34 <amgarching> cob_jonas: i <- [0..n], j <- [0..i], etc
06:19:35 <yitz> cob_jonas: that's true, and then you *can't* use %.
06:20:03 <cob_jonas> amgarching: same thing, the [0..n] can be lists of ratios
06:20:11 <cob_jonas> amgarching: so then you can just use * and /
06:20:49 <cob_jonas> amgarching: do { i <- [1..3]; j <- [1..3]; return (i / j) }
06:20:52 <cob_jonas> > do { i <- [1..3]; j <- [1..3]; return (i / j) }
06:20:53 <lambdabot>   [1.0,0.5,0.3333333333333333,2.0,1.0,0.6666666666666666,3.0,1.5,1.0]
06:20:59 <doserj> % is just supposed to be used as a (smart) constructor
06:21:02 <cob_jonas> > do { i <- [1..3]; j <- [1..3]; return (i / j :: Ratio Integer) }
06:21:03 <lambdabot>   [1 % 1,1 % 2,1 % 3,2 % 1,1 % 1,2 % 3,3 % 1,3 % 2,1 % 1]
06:21:55 <yitz> > [r | r <- [0..3]] :: [Rational]
06:21:56 <lambdabot>   [0 % 1,1 % 1,2 % 1,3 % 1]
06:22:15 <FunctorSalad_> I don't think I get SCCs. I have: foo x = {-# SCC "foo_" #-} go ... where go = ...
06:22:38 <yitz> > [r | r <- [0%1..3]]
06:22:39 <lambdabot>   [0 % 1,1 % 1,2 % 1,3 % 1]
06:22:47 <FunctorSalad_> why is the automatic cost center for foo much more costly than my "foo_" ?
06:23:34 <amgarching> of what type is r here: [ fromIntegral r | r <- [0..3]] ??
06:23:42 <amgarching> > [ fromIntegral r | r <- [0..3]] ??
06:23:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:23:54 <FunctorSalad_> @type [ fromIntegral r | r <- [0..3]]
06:23:56 <lambdabot> forall b. (Num b) => [b]
06:25:55 <zachk> haskell is starting to feel like legos :-D
06:26:11 <xenoblitz> hi people can I ask a question regarding the following code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5276#a5276
06:26:18 <DrSyzygy> zachk: That's good! Then the character of functional programming is reaching you.
06:26:28 <xenoblitz> any one can shed some light why simulate latchC works but simulate latchC2 doesn't?
06:27:54 <zachk> i would need to draw a schematic :-/
06:28:06 <FunctorSalad_> meh. I covered all the branches of my function with SCCs but the auto top-level SCC of the function still has lots of own time
06:28:09 <Phyx-> lol, DrSyzygy untill someone tells you you're supposed to fit that round lego block in that square hole, then they show you how and you're left scratching your head :)
06:28:53 <zachk> just take a Round->Square and go from Thuare
06:29:08 <Phyx-> lol
06:29:28 <DrSyzygy> EXACTLY!
06:29:46 <amgarching> so if I have data Monom = Monom Integer Integer Integer, I cannot use (Monom i j k) if any of (i,j,k) is "inferred/promoted" to Rationals? I get some obscure errmsg.
06:30:06 <DrSyzygy> amgarching: Because you don't have integers any longer.
06:30:08 <doserj> xenoblitz: I would guess latchC2 has a loop?
06:30:20 <DrSyzygy> And there is no inherent way to convert a Rational to an Integer, with good reason.
06:30:21 <xenoblitz> doserj: both of them actually have a loop
06:30:33 <fasta> xenoblitz: post complete code next time
06:30:44 <xenoblitz> doserj: just that one has two High inputs while the other has a Low and High
06:30:50 <xenoblitz> fasta: it is complete code as far as i know
06:31:03 <doserj> xenoblitz: it is missing type Var = String
06:31:05 <fasta> xenoblitz: ire.hs:7:12: Not in scope: type constructor or class `Var'
06:31:17 <xenoblitz> fasta: ouch yeah sorry let me amend that
06:31:28 <cob_jonas> because of && one might have a loop but still terminate
06:32:02 <xenoblitz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5276#a5277
06:33:24 <yitz> lookUpWire = flip lookup
06:34:12 <doserj> ("c", And (Label "a") (Label "f") doesn't loop if a is Low
06:34:47 <xenoblitz> doserj: cause and false x is always false?
06:35:01 <doserj> yes
06:35:33 <xenoblitz> doserj: but how does it reach that conclusion? is this defined somewhere?
06:35:42 <doserj> @src &&
06:35:43 <lambdabot> True  && x = x
06:35:43 <lambdabot> False && _ = False
06:37:09 <xenoblitz> I don't know if I understand correctly... can I view that unknown part as a thunk so False && thunk
06:37:21 <xenoblitz> so False?
06:37:43 <cob_jonas> > False && undefined
06:37:45 <lambdabot>   False
06:37:48 <cob_jonas> > undefined && False
06:37:49 <lambdabot>   * Exception: Prelude.undefined
06:37:55 <Phyx-> http://en.wikipedia.org/wiki/Short-circuit_evaluation
06:38:29 <Gracenotes> similar to short-circuit evaluation, but the mechanisms are entirely different
06:39:18 <Gracenotes> not to mention, short-circuit evaluation is more like IO Bool -> IO Bool -> IO Bool. In Haskell, && is pure, Bool -> Bool -> Bool.
06:39:28 <Gracenotes> but that's petty
06:40:02 <Phyx-> the only difference is that in haskell becauze of lazy evaluation short defining && doesn't need any special operators
06:40:08 <Phyx-> but the article mentions that aswell
06:41:54 <xenoblitz> thanks guys I keep wondering how I come up against this problems :S
06:43:24 <jeff_s_> I think of OR like "elem True list" and AND like "not (elem False list)"
06:44:46 <xenoblitz> quickquestion related to what we were discussing:... when we write our own operators are they short-circuited or "normal"?
06:45:48 <cob_jonas> xenoblitz: depends on how you write them
06:46:02 <doserj> Haskell is lazy, so short-circuited is normal :) unless you explicitely pattern match, nothing is evaluated.
06:46:09 <Phyx-> exactly
06:46:30 <kpreid> xenoblitz: but the order of cases can determine which argument is examined first, which makes a difference in termination
06:46:42 <kpreid> in which argument has to be defined
06:46:48 <kpreid> > False && undefined
06:46:48 <jeff_s_> I imagine it's easy to rewrite && and || to not short-circuit.
06:46:49 <lambdabot>   False
06:46:52 <kpreid> > undefined && False
06:46:53 <lambdabot>   * Exception: Prelude.undefined
06:46:56 <cnwdup> How would I load (using System.Plugins) a data structure of type Foo s? Is this even possible? I thought I did this but now I have my code rewritten and I get errors about ambiguity of type s.
06:47:12 <Phyx-> jeff_s_: yes, just force evaluation before you compare
06:47:41 <xenoblitz> oh i c so its a question of pattern matching... if a case exists with a _ you can create short-circuited operators
06:48:02 <kpreid> xenoblitz: exactly. well, _ or ~
06:48:02 <zachk> dont use the _ wildcard
06:48:02 <zachk> otherwise you wont be able to evaluate it
06:48:12 <zachk> whats ~ match to
06:48:13 <kpreid> but also a plain variable
06:48:44 <yottis> is _ really special or just an idiom?
06:48:46 <xenoblitz> in the end its how you pattern match then that defines if an operator or function is short-circuited or not
06:48:53 <doserj> > let False && False = False; False && True = False ; True && False = False; True && True = True in False && undefined
06:48:54 <lambdabot>   * Exception: Prelude.undefined
06:48:54 <jeff_s_> I was just gonna ask the same thing. I don't remember seeing ~ in pattern matches yet.
06:48:57 <kpreid> if I write "foo False bar = ..." then it doesn't evaluate bar, but does evaluate the first arg and check it
06:49:02 <kpreid> yottis: it's special
06:49:08 <kpreid> > let foo _ _ = 1 in foo 1 2
06:49:09 <lambdabot>   1
06:49:14 <kpreid> > let foo x x = 1 in foo 1 2
06:49:15 <lambdabot>   Conflicting definitions for `x'
06:49:15 <lambdabot>  In the definition of `foo'
06:49:21 <kpreid> > let foo _x _y = 1 in foo 1 2
06:49:23 <lambdabot>   1
06:49:24 <yottis> so foo x y = x is different from foo x _ = x?
06:49:29 <kpreid> yottis: no
06:49:48 <kpreid> the specialness is just that it doesn't actually bind any variable and can be used many times
06:50:08 <doserj> _ is just an identifier that cannot be used on the right hand side
06:50:12 <kpreid> it makes no difference if you were to replace every _ in a program with distinct variable names
06:50:14 <yottis> is the difference that _ can't be referenced on the right-hand side?
06:50:18 <yottis> echo that
06:50:31 <kpreid> the other difference is that you can use it multiple times on the left
06:50:46 <xenoblitz> amazing stuff I hope i remember hehe
06:50:57 <jeff_s_> 4.4 Lazy patterns @ http://www.haskell.org/tutorial/patterns.html
06:51:44 <xenoblitz> thanks guys
07:09:33 <mib_e7tcavos> hey ive gt a problem
07:09:46 <mib_e7tcavos> say i have a list of users
07:09:55 <mib_e7tcavos> [user]
07:10:17 <mib_e7tcavos> and im trying to find if my user is in a list of users
07:10:30 <mib_e7tcavos> so technically
07:10:47 <mib_e7tcavos> user == [user] or is part of
07:10:57 <mib_e7tcavos> any ideas how to do that
07:11:03 <cnwdup> > lookup 2 [1..10]
07:11:05 <lambdabot>   No instance for (GHC.Enum.Enum (t, b))
07:11:05 <lambdabot>    arising from the arithmetic seque...
07:11:11 <mauke> > elem 2 [1..10]
07:11:12 <cnwdup> > lookup (2::Int) [1..10]
07:11:12 <lambdabot>   True
07:11:13 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Int, b))
07:11:13 <lambdabot>    arising from the arit...
07:11:21 <mauke> cnwdup: what
07:11:30 <doserj> cnwdup: lookup is for association lists
07:11:30 <cnwdup> Woups. That was just stupid. (:
07:11:44 <mib_e7tcavos> kl
07:13:00 <Botje> mib_e7tcavos: there is an "elem" function
07:13:06 <Botje> as mauke pointd out
07:13:21 <mib_e7tcavos> yeah "looking" it up now
07:13:33 <Phyx-> @hoogle elem
07:13:33 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
07:13:33 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
07:13:33 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
07:13:44 <Phyx-> @hoogle elem --info
07:13:45 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
07:13:45 <lambdabot>  
07:13:45 <lambdabot> elem is the list membership predicate, usually written in infix form, e.g., x `elem` xs.
07:16:40 <Peaker> @hoogle unsafePerformIO --info
07:16:40 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:16:41 <lambdabot>  
07:16:41 <lambdabot> This is the "back door" into the IO monad, allowing IO computation to be performed at any time. For this to be safe, the IO computation should be free of side effects and independent of its environmen
07:16:41 <lambdabot> t.
07:18:45 <Peaker> was --info always there? :P
07:19:03 <jeff_s_> @hoogle --help
07:19:03 <lambdabot> Go to the website for full help, http://haskell.org/hoogle/
07:19:04 <lambdabot>  
07:19:04 <lambdabot> Flag reference:
07:19:17 <ray> @hoggle safePerformIO
07:19:17 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:19:18 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:19:46 <Phyx-> heh, is that an alias?
07:20:08 <ray> no, lambdabot has spelling error tolerance
07:20:25 <Phyx-> to what extend?
07:20:32 <Phyx-> @haggle test
07:20:33 <lambdabot> Test.HUnit.Base test :: Testable t => t -> Test
07:20:33 <lambdabot> Test.HUnit.Base data Test
07:20:33 <lambdabot> Test.QuickCheck class Testable a
07:20:36 <Phyx-> hmm
07:20:37 <jeff_s_> someone had fun making hoogle
07:20:41 <Gracenotes> I think it's Levenshtein distance
07:20:47 <Gracenotes> er... lemme see.
07:21:17 <ray> but what specific levenshtein distance is the tolerance
07:21:27 <mauke> 2
07:21:34 <Phyx-> aha
07:21:41 <Gracenotes> :o so I see
07:21:59 <ray> so transposing 2 letters uses it up
07:22:14 <ray> except in the degenerate case where you transpose 2 letters that are the same
07:22:28 <Phyx-> doesn't Hayoo use this?
07:22:45 <Peaker> I don't understand the difference between Hoogle and Hayoo
07:22:49 <ray> lost my hayoo mail
07:22:54 <Peaker> Hayhoo is more comprehensive?
07:23:25 <ray> hayoo's newer and possibly fancier
07:23:28 <boegel> Hayoo included packages, Hoogle doesn't
07:23:36 <boegel> s/included/includes
07:23:46 <Phyx-> i find hoogle returns better results
07:23:51 <cob_jonas> but you can compile hoogle database for any package, can't you?
07:23:57 <cob_jonas> locally
07:24:01 <boegel> maybe, yeah
07:24:28 <Phyx-> and doesn't hayoo use Textual Type searching and Hoogle 4 Structural Edit distance to do searching?
07:25:17 <Gracenotes> mauke: hm. where is the matching in the lambdabot source?
07:25:23 <Phyx-> so hayoo alpha normalizes and strength reduced alpha normalizes, then does substring searching
07:25:33 <mauke> Gracenotes: dunno
07:25:43 <Peaker> Phyx-: What's "structural edit distance"?
07:26:18 <Phyx-> Peaker: difference in only structure between the search value and result value
07:26:42 <Peaker> as in - ignoring names?
07:27:04 <Gracenotes> aha.
07:27:47 <Phyx-> Peaker: for instance, if you search for "Maybe Int" the structure it tries to match against is "? ?"
07:27:50 <Gracenotes> the edit distance cut-off is < 3
07:27:57 <Phyx-> it's only usefull for the typeseaches i beleive
07:27:58 <Gracenotes> so <= 2, as mauke said...
07:28:04 <cob_jonas> @hoogle :: Maybe Int
07:28:04 <lambdabot> Prelude Nothing :: Maybe a
07:28:04 <lambdabot> Data.Maybe Nothing :: Maybe a
07:28:04 <lambdabot> Language.Haskell.TH maxPrecedence :: Int
07:28:27 <Peaker> Phyx-: I think it would make sense to lose only names of type variables, and not of everything else?
07:28:43 <Peaker> Though it could try and substitute everything for a super-class/subclass, etc
07:28:59 <cob_jonas> it does that too
07:29:16 <Phyx-> Peaker: you have to take into account things like aliases, missing instances, boxing etc
07:29:31 <cob_jonas> @hoogle (Monad f) => f (a -> b) -> f a -> f b
07:29:32 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:29:32 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
07:29:32 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:29:40 <cob_jonas> @hoogle (Functor f) => f (a -> b) -> f a -> f b
07:29:40 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:29:40 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:29:40 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
07:29:46 <Phyx-> so it uses the structure to quickly reduce the set of possibles i beleive and then tries to sort through the best matched ones
07:29:51 <cob_jonas> @hoogle (Applicative f) => f (a -> b) -> f a -> f b
07:29:51 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:29:51 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:29:51 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
07:31:25 <cnwdup> @src map
07:31:25 <lambdabot> map _ []     = []
07:31:26 <lambdabot> map f (x:xs) = f x : map f xs
07:31:29 <Gracenotes> this is rather strange. The "closests" function is used, but I can't find it anywhere
07:31:32 <Phyx-> Peaker: that way, for instance searching for Monad m => m a would also find Maybe a, which *might* be what you want,
07:31:32 <cnwdup> @type map
07:31:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:31:35 <Gracenotes> @hoogle closests
07:31:35 <lambdabot> No results found
07:31:38 <Gracenotes> :.
07:32:01 <mux> :t foldr ((:) . f) []
07:32:03 <lambdabot> forall b a. (Show a, SimpleReflect.FromExpr b) => [a] -> [b]
07:32:05 <Peaker> (<**>) = flip (<*>)?  or (<**>) = liftA2 (flip ($)) ?
07:32:10 <mux> : \f -> t foldr ((:) . f) []
07:32:14 <mux> :t \f -> t foldr ((:) . f) []
07:32:16 <lambdabot>     Couldn't match expected type `((a -> b -> b) -> b -> [a] -> b)
07:32:16 <lambdabot>                                   -> (a1 -> [b1] -> [b1])
07:32:16 <lambdabot>                                   -> [a2]
07:33:00 <Phyx-> Peaker: if you want to know more look at http://community.haskell.org/~ndm/hoogle/
07:34:13 <Peaker> > let (<**>) = liftA2 (flip id) in [10,20] <**> [(+1),(+2)]
07:34:14 <lambdabot>   [11,12,21,22]
07:34:19 <Peaker> > [10,20] <**> [(+1),(+2)]
07:34:20 <lambdabot>   [11,12,21,22]
07:34:31 <Peaker> > let (<**>) = flip (<*>) in [10,20] <**> [(+1),(+2)]
07:34:32 <lambdabot>   [11,21,12,22]
07:34:39 <Peaker> aha
07:34:55 <Gracenotes> okay!
07:35:28 <cob_jonas> @type <**>
07:35:30 <lambdabot> parse error on input `<**>'
07:35:32 <cob_jonas> @type (<**>)
07:35:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
07:35:57 <Peaker> @type flip (<*>)
07:35:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
07:36:07 <Peaker> the difference is in the way effects are sequenced
07:36:37 <cob_jonas> I see
07:36:39 <Peaker> flip (<*>) sequences right-to-left, and  liftA2 (flip id) sequences left-to-right
07:47:04 <mgee> hi, did somebody already worked with QIO? The quantum computer IO monad.
07:47:18 <mib_e7tcavos> hey
07:47:45 <mib_e7tcavos> anyone know if there is a function for a avergae of a list
07:48:01 <dmwit> mib_e7tcavos: No.
07:48:08 <mib_e7tcavos> list of int
07:48:13 <dmwit> It's easy to write, though. =)
07:48:14 <cob_jonas> but there's many ways to write it
07:48:14 <mib_e7tcavos> nope ok
07:48:22 <mib_e7tcavos> yeah ill give it ago
07:50:01 <jmcarthur_work> there is a fast way and a slow way. keep that in mind as you write it :)
07:50:35 <jmcarthur_work> (this particular case has been complained about before because the most naive solution isn't the fastest)
07:50:43 <dmwit> No, there's a space-efficient way and a space-inefficient way.  They're about equally fast. =)
07:50:49 <Pellwurst> is there a special symbol to match a whitespace as a regexp?
07:51:02 <dmwit> Pellwurst: In PCRE, \s
07:51:14 <mauke> [[:space:]] in posix
07:51:15 <jmcarthur_work> well, the naive solution can also easily overflow the stack if it's built without optimizations
07:51:22 * dmwit nods
07:51:28 <mib_e7tcavos> average :: [Int] -> Int
07:51:34 <Pellwurst> mauke: thx, that should do the job
07:51:41 <mib_e7tcavos> average I = sum I / length I
07:51:42 <mib_e7tcavos> ?
07:52:06 <dmwit> mib_e7tcavos: Seems close.  There's a few problems left.
07:52:31 <dmwit> mib_e7tcavos: First, variable names have to start with a lower-case letter, to distinguish them from constructor names.
07:52:40 <mib_e7tcavos> yeah
07:52:49 <mib_e7tcavos> small i lol
07:52:56 <dmwit> mib_e7tcavos: Also, length returns an Int, which you can't divide by, so you'll need to convert it:
07:53:00 <dmwit> :t fromIntegral
07:53:01 <lambdabot> forall a b. (Integral a, Num b) => a -> b
07:53:24 <mib_e7tcavos> ah ok
07:53:46 <doserj> mib_e7tcavos: what should the average of [1,2] be?
07:53:47 <dmwit> As a stylistic note, it's a common idiom in Haskell to call a list of things by a name ending in 's', so xs, ys, zs, is, as, numbers, etc.
07:53:59 <sammartin> mib_e7tscos: have you thought about returning a tuple of sum and length as an option?
07:54:05 <jeff_s_> average [1,2] = 1
07:54:22 <dmwit> jeff_s_: ewww
07:54:26 <jeff_s_> hehe
07:54:27 <Phyx-> lol
07:54:32 <dmwit> average [1,2] = 3 % 2
07:55:15 <cob_jonas> I thought yyou should fold with a tuple
07:55:30 <jeff_s_> I like integer math,  3/2 = 1 has its uses
07:55:34 <dmwit> cob_jonas: Yep, but for a beginner, the naive solution is probably fine.
07:55:46 <dmwit> Until we have long lists, readable is better than efficient. =)
07:55:47 <jeff_s_> actually, how do you do integer divsion in haskell anyway?
07:55:53 <dmwit> :t div
07:55:54 <lambdabot> forall a. (Integral a) => a -> a -> a
07:56:02 <jeff_s_> do you have to truncate the rational number?
07:56:14 <dmwit> ...no...
07:56:17 <mib_e7tcavos> thanks guys gt it now cheers
07:56:24 <Absolute0> Is 'type t = (Int k, Char v) => Data.Map.Map k v' valid?
07:56:28 <Absolute0> I am getting an error
07:56:29 <Ferdirand> btw, is it possible to automatically fuse two foldls over the same list with a single tuple foldl ?
07:56:32 <MyCatVerbs> > [5 `div` 2, 14 `div` 3]
07:56:33 <lambdabot>   [2,4]
07:56:41 <Botje> Absolute0: what is that supposed to do?
07:56:43 <dmwit> Absolute0: Int and Char aren't classes.
07:56:52 <Absolute0> type t = Data.Map.Map Int Char won't work either
07:56:53 <jeff_s_> Ferdirand - ya, start with ([],[]) instead of []
07:57:01 <dmwit> Absolute0: And type names must start with an uppercase letter.
07:57:07 <Botje> Absolute0: that's because type names start with an uppercase letter
07:57:10 <dmwit> type T = Map Int Char
07:57:12 <Absolute0> ah
07:58:30 <Absolute0> also importing libraries using the qualified keyword fails in ghci
07:58:38 <dmwit> yes
07:58:41 <Absolute0> is there any way to override that?
07:59:12 <dmwit> Do it in a file?
07:59:27 <Absolute0> nevermind.
07:59:47 <Absolute0> ghci should behave like a file!
08:00:38 <dmwit> I'm going to go ahead and claim that mutual recursion makes your claim false.
08:04:07 <byorgey> ghci could behave like a file if you embed it in a (TimeTravelT IO)  monad
08:04:50 <byorgey> not just mutual recursion, the fact that declarations don't have to be an any particular order in a file is good enough.
08:04:50 <dmwit> To be honest, though, I don't see how come it can't behave like a file, now that we have :{ :}
08:05:04 <byorgey> be *in any
08:05:22 <byorgey> dmwit: are you at school?
08:05:32 <dmwit> I'll be in in about an hour or so.
08:05:39 <Phyx-> what's :{ :} ?
08:05:47 <byorgey> ok, me too
08:05:54 <dmwit> Phyx-: :{ starts a multiline ghci command
08:05:59 <byorgey> sad devil, happy devil!
08:06:07 <dmwit> heh
08:06:11 <Phyx-> hmm ok
08:06:28 <dmwit> byorgey: I've got a long list of links talking about inter- and intra-city transportation for Hac \phi.
08:06:36 <byorgey> sweet!
08:07:05 <cob_jonas> let me try to write this average thing the way I wanted now because when mibbit asked I tried to but got an error and then I got called away
08:07:22 <dmwit> cob_jonas: Good idea!
08:07:30 <cob_jonas> I know I wrote it a few times of course
08:09:25 <Peaker> byorgey, dmwit: ghci could suspend disbelief and allow to use yet-inexistent names
08:09:30 * jeff_s_ scrolls up
08:09:36 <jeff_s_> thanks MyCatVerbs for the reminder about `div`
08:09:40 <dmwit> Peaker: I can't even imagine how many problems that would cause.
08:09:42 <Peaker> byorgey, dmwit: It could also re-evaluate dependent stuff when existing names are re-defined
08:09:58 <dmwit> Peaker: I make so many typos in ghci it's not even funny.
08:09:59 <Peaker> dmwit: or, it could have a special notation to enable that for some name
08:10:01 <byorgey> Peaker: maybe.  sounds horribly complicated and full of nasty surprises for the user.
08:10:10 <dmwit> exactlyl
08:10:13 <dmwit> ah
08:10:20 <dmwit> Perfect examplel. ;-)
08:10:21 <Peaker> dmwit: blah = @bleh bluh
08:10:31 <byorgey> dmwit: hehl
08:10:34 <Peaker> bluh -- undefined
08:10:39 <Peaker> bleh -- OK that it is undefined
08:10:40 <dino-> oo, I didn't know about that :{
08:11:00 <jeff_s_> @hoogle blah = bleh bluh
08:11:01 <lambdabot> Parse error:
08:11:01 <lambdabot>   --count=20 "blah = bleh bluh"
08:11:01 <lambdabot>                   ^
08:11:05 <Peaker> when blah is used - only then it will try to type/use it
08:11:27 <Phyx-> jeff_s_: ?
08:11:33 <jeff_s_> Just being silly.
08:11:39 <Phyx-> lol
08:11:49 <Peaker> byorgey, dmwit: What problems do you envision with it?
08:12:00 <Peaker> I see it *complicating* ghci, but worse isn't better is it? :)
08:13:02 <dmwit> Peaker: I propose that you implement it and prove us wrong. ;-)
08:13:11 <Peaker> dmwit: I don't know ghc :(
08:13:40 <cob_jonas> > let { ave :: [Float] -> Float; ave = snd . foldl' (\(k, a) x -> (k + 1, a + (x - a)/(k + 1))) (0, 0); } in ave [3,2,2] {- throw in a map fromIntegral if it has to work on a list of Ints -}
08:13:41 <lambdabot>   2.3333333
08:13:44 <byorgey> Peaker: I don't know of any specific things off the top of my head.  it was just a feeling.  you may be right.
08:13:46 <cob_jonas> there, that way
08:14:06 <Peaker> byorgey: CL does essentially that, doesn' tit?
08:14:19 <byorgey> Peaker: I've no idea, does it?
08:14:31 <cob_jonas> Peaker: so how would that undefined names thingy work?
08:14:33 <byorgey> cob_jonas: nice, only one traversal
08:14:38 <cob_jonas> what would an undefined name do?
08:15:17 <Peaker> cob_jonas: well, I think there could be a customizable configuration whether @ are necessary, and if they are, and you have @ on a name, then it only checks the syntax, and waits for that name to exist before evaluating the expression
08:15:25 <dmwit> cob_jonas: That looks like a lot of extra division to me.
08:15:31 <Phyx-> that seems overly complicated to me...
08:15:55 <Peaker> cob_jonas: unmarked @ names will behave as they do today
08:16:03 <dmwit> > let ave = uncurry (/) . foldl' (\(k, a) x -> (k + 1, a + x)) (0, 0) } in ave [3, 2, 2]
08:16:04 <lambdabot>   <no location info>: parse error on input `}'
08:16:09 <dmwit> > let ave = uncurry (/) . foldl' (\(k, a) x -> (k + 1, a + x)) (0, 0) in ave [3, 2, 2]
08:16:11 <lambdabot>   0.42857142857142855
08:16:19 <dmwit> Oh, right.
08:16:20 <cob_jonas> dmwit: but at least it's more precise in some cases (for arbitary float arguments) than just doing one division
08:16:32 <byorgey> dmwit: that's the reciprocal, I think
08:16:33 <cob_jonas> for [3,2,2] it doesn't matter of course
08:16:34 <dmwit> > let ave = uncurry (/) . foldl' (\(a, k) x -> (a+x, k+1)) (0, 0) in ave [3, 2, 2]
08:16:35 <lambdabot>   2.3333333333333335
08:16:44 <dmwit> cob_jonas: Right, that's possibly true.
08:17:17 * byorgey runs screaming from the dark art of accurate numerics
08:17:19 <cob_jonas> Peaker: but would those names be allowed in IO <- binding statements?
08:17:38 <cob_jonas> Peaker: I mean, if it's just plain assignments then right, you just print them late
08:18:12 <Peaker> cob_jonas: ghci does effect execution and ordinary let bindings.. The former can require entire expression to be well-defined, and the latter can wait
08:19:12 <Peaker> Type definitions could work the same - except perhaps if the type is re-defined then all the former uses of it in the shell should either be invalidated, re-evaluated, or remain using the old type, where the new type only shares a name with the old one
08:20:01 <dmwit> Peaker: You know, these days you don't have to know GHC to write your own Haskell interpreter.
08:20:13 <dmwit> Check out the hint package on Hackage, and wow us with your innovation. =)
08:20:36 <Peaker> at the very least I'll have to parse my own syntax?
08:20:43 <Peaker> (for the annotations)
08:20:46 <cob_jonas> Peaker: so would it work if you entered something like "let { x = @y }" and then "y <- f x" ?
08:21:00 <Peaker> cob_jonas: I think that should be fine
08:21:09 <dmwit> Yep, you might have to scan for annotations.
08:21:35 <dmwit> You could separate annotations from Haskell code in some clever way, though.
08:21:56 <cob_jonas> which one does it run first?
08:22:17 <dmwit> :t fixIO
08:22:18 <lambdabot> Not in scope: `fixIO'
08:22:27 <dmwit> ?instances MonadFix
08:22:28 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:22:28 <cob_jonas> yeah, I could never wrap my head around that fixIO thing
08:22:32 <cob_jonas> oh well
08:22:44 <cob_jonas> anyway, defining types in ghc is sort of easy
08:22:52 <cob_jonas> my plugin sort of works for that
08:22:53 <byorgey> cob_jonas: hm? what do you mean, which would it run first?
08:23:04 <mauke> @hoogle fixIO
08:23:04 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
08:23:13 <mauke> ah, mfix[IO]
08:25:16 <cob_jonas> http://erxz.com/pb/17809  allows you to define types inline in ghci
08:25:29 <Peaker> > mfix return
08:25:31 <lambdabot>   No instance for (GHC.Show.Show (m a))
08:25:31 <lambdabot>    arising from a use of `M7875774271...
08:25:46 <Peaker> > fix id
08:25:51 <lambdabot>   mueval-core: Prelude.read: no parse
08:25:51 <lambdabot>  mueval: ExitFailure 1
08:26:06 <MyCatVerbs> Ouch! That loses all current bindings. Not good. :/
08:26:25 <Peaker> @type both
08:26:26 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:26:34 <Peaker> MyCatVerbs: that's a binding from earlier?
08:27:50 <ray> fix id should be thread killed
08:27:57 <ray> why wouldn't it parse?
08:28:32 <mauke> I think the parse error refers to the result
08:28:53 <MyCatVerbs> Peaker: the inline type definition hack cob_jonas pointed out.
08:29:07 <ray> i guess that could be
08:29:15 <Peaker> oh
08:29:15 <MyCatVerbs> Win: it lets you define data, newtypes and types inline in GHCi.
08:29:34 <cob_jonas> MyCatVerbs: yes, but if you have plain let bindings (not IO bindings) you can do them with :decl and then they're reintroduced every time you add a new binding and not lost
08:29:38 <Peaker> one after the other, or only the last one survives?
08:29:43 <MyCatVerbs> Lose: the only way of implementing that was to build and load a module, which means you suddenly lose all your bindings.
08:30:26 <cob_jonas> Peaker: one after the other, if you try to add two of the same name you get an error so use the :undecl command to remove the previous one
08:30:57 <MyCatVerbs> cob_jonas: a large portion of the time in GHCi, I am working with IO bindings. Generally I like to put my data sets in files rather than type them into the REPL.
08:31:17 <Peaker> MyCatVerbs: put them in an .hs file
08:31:36 <alexsuraci> Is there such a thing as a tuple containing one value?
08:31:43 <dmwit> No.
08:31:43 <mauke> alexsuraci: no
08:31:50 <cob_jonas> MyCatVerbs: well, you could bind the IO commands to functions and run those functions as an IO binding, or just use readline to go back and rerun old statements
08:31:53 <alexsuraci> alright, thought so
08:31:55 <alexsuraci> thanks
08:31:58 <dmwit> alexsuraci: There's Identity.
08:32:02 <dmwit> > Identity 3
08:32:03 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity t))
08:32:03 <lambdabot>    aris...
08:32:11 <cob_jonas> dmwit: yes, but that's not Showable I think
08:32:15 <cob_jonas> > Identity 5
08:32:16 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity t))
08:32:16 <lambdabot>    aris...
08:32:39 <wjt> there's OneTuple on hackage :D
08:32:41 <alexsuraci> well, more from a language implementation standpoint than utility
08:32:44 <alexsuraci> haha
08:32:50 <dmwit> > runIdentity (Identity 3)
08:32:51 <lambdabot>   3
08:33:36 <Phyx-> @cabal info OneTuple
08:33:37 <lambdabot>   bzzt.
08:33:39 <Phyx-> lol
08:33:48 <dmwit> eh?
08:33:49 <dmwit> ?help cabal
08:33:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:34:01 <dmwit> Okay, so it's auto-correcting to something...
08:34:01 <ray> > let show Identity a = "Identity " ++ show a in Identity 3 -- or something
08:34:02 <lambdabot>   Constructor `Control.Monad.Identity.Identity' should have 1 argument, but h...
08:34:04 <Phyx-> @hackage info OneTuple
08:34:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/info OneTuple
08:34:11 <Phyx-> ...
08:34:19 <dmwit> ray: show (Identity a), and it needs to be in an instance block.
08:34:48 <ray> yes, (Identity a)
08:35:05 <bavardage> o/
08:35:20 * dmwit calls on bavardage
08:35:23 <dmwit> Yes, dear?
08:37:39 <cob_jonas> by the way, let me note that my ghci extension also lets you import modules qualified as
08:37:53 <cob_jonas> so you can finally write :import qualified Data.Map as M
08:38:00 <cob_jonas> some may find this the most important use
08:39:20 <cob_jonas> eg. http://erxz.com/pb/17810
08:41:59 <cnwdup> > let xs = [1::Int, 'c'::Char] :: forall a. Show a => [a] in map show xs
08:42:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:42:40 <cnwdup> How can I create such a list containing arbitrary values and restricting the usable functions to a few working on any types?
08:44:15 <mauke> you can't directly
08:44:21 <cnwdup> Ok.
08:44:27 <integral> > let xs = [1 :: Int, 'c' :: Char] :: [forall a. Show a => a] in map show xs
08:44:29 <lambdabot>   Cannot match a monotype with `forall a. (GHC.Show.Show a) => a'
08:44:40 <mauke> you can make an existential wrapper and wrap each element individually
08:45:43 <Gracenotes> data Showable = forall a. Show a => Showable a
08:46:03 <Gracenotes> .. possibly deriving Show. All you can do with it is show, after all...
08:46:14 <integral> heh :-)
08:46:58 <Ferdirand> jeff_s_: well, I know how to do it by hand. I was wondering if the compiler could do it for me, with a rule or so
08:47:17 <Ferdirand> or if there was some subtle hidden catch that would make it incorrect
08:47:53 <cob_jonas> or just use a normal algebraic type
08:49:16 <cob_jonas> > let { xs = [Left 1, Right 'c']; } in map (either show show) xs
08:49:17 <lambdabot>   ["1","'c'"]
08:51:10 <mauke> > let xs = [show 1, show 'c'] in xs
08:51:11 <lambdabot>   ["1","'c'"]
08:52:06 <arcatan> what would be my options if i wanted to generate png images with haskell?
08:54:46 <byorgey> arcatan: what sort of png images?
08:55:03 <mib_e7tcavos> hey another noob question here
08:55:16 <byorgey> mib_e7tcavos: ask away!
08:55:32 <Absolute0> Are list comprehensions lazy when passed as parameters to other functions?
08:55:37 <mib_e7tcavos> i need to return top ten films by fans
08:55:59 <mib_e7tcavos> all ive gt so far is
08:56:17 <mib_e7tcavos> topTenFilms :: [Film] -> [Title]
08:56:27 <Absolute0> I am wondering if it is better to insert each element into a map individually or create a list and call fromList function?
08:56:30 <mib_e7tcavos> topTenFilms films = [title | Film title director year fans <- films, length fans >= m ]
08:56:38 <mib_e7tcavos> im having brain freezer
08:56:54 <dmwit> arcatan: Cairo, diagrams, Gtk2Hs, HsMagick, ...
08:57:35 <tetha> mib_e7tcavos: couldn't you sort the films by fan-count and take the first 10?
08:57:39 <dmwit> Absolute0: Use fromList.
08:57:42 <mib_e7tcavos> anyone gt any ideas of what i shud look at
08:57:45 <byorgey> mib_e7tcavos: try sorting the films first by number of fans
08:57:49 <mib_e7tcavos> yes
08:57:54 <mib_e7tcavos> ah yeah
08:57:55 <Absolute0> dmwit: just as effecient?
08:57:58 <mib_e7tcavos> cheers guys
08:58:00 <byorgey> mib_e7tcavos: you can even use sortBy
08:58:14 <Absolute0> dmwit: if the list is large creating the list and then sorting it within Data.Map seems silly.
08:58:16 <dmwit> Absolute0: Just as, and may in the future be more efficient.
08:58:32 <dmwit> Absolute0: I don't understand; why would that be silly?
08:58:38 <Absolute0> dmwit: as apposed to individually inserting each one
08:58:50 <arcatan> byorgey: dynamically generated png images serverd over HTTP
08:58:54 <Absolute0> isn't inserting one quicker than sorting an entire list?
08:59:07 <dmwit> Absolute0: Maybe, but inserting them all is not.
08:59:16 <Absolute0> ah
08:59:22 <dmwit> Absolute0: Also, what is up with your thing against sorting?  Data.Map doesn't call sort anywhere.
08:59:42 <byorgey> arcatan: yes, but I mean, what will the images be like?  how simple/complex?  will it involve putting together other images, or just generating simple shapes, or...?
08:59:46 <Absolute0> dmwit: how does it achieve log n lookup?
08:59:51 <Absolute0> its sorts the map
09:00:09 <Absolute0> i think it says so in the docs
09:00:18 <dmwit> Absolute0: ...sort of, yes.
09:00:31 <byorgey> it uses a balanced tree.
09:00:33 <arcatan> byorgey: oh. i will generate the pixel data myself and want to encode it in a png
09:00:34 <dmwit> Absolute0: Insertion puts the element "in the right place," so to speak.
09:00:35 <tetha> isn't data.map a tree?
09:01:18 <byorgey> arcatan: ah.  In that case you probably want to use HsMagick, or perhaps Cairo
09:01:22 <dmwit> arcatan: Then I suggest Gtk2Hs or HsMagick.
09:01:23 <Beelsebob> depends on the implementation tetha
09:01:24 <SamB> tetha: sure!
09:01:29 <Beelsebob> but in most implementations... yes
09:01:33 <dmwit> arcatan: Cairo can be nice, but definitely not if you want pixel-level control.
09:01:42 <SamB> well, I mean, you could use some other kind of tree to implement it
09:01:45 <byorgey> ok, thanks dmwit, I didn't know that =)
09:01:56 <SamB> and if you were insane you could even use an alist
09:02:01 <arcatan> dmwit: i do
09:02:03 <cob_jonas> Absolute0: if the most efficent method is putting the elements in one by one, then that's what fromList will do, so I think fromList is always the most efficent if you can generate the list in a pure lazy way
09:02:15 <Absolute0> dmwit: Inserting a newly generated element into the map is slower than first generating the entire list and calling Map.fromList?
09:02:22 <SamB> but nobody would want to use the alist-based Data.Map, would they ?
09:02:27 <cob_jonas> the insertion by one might be needed if you can't generate the list lazily, eg. if you're reading the elements from a file one by one
09:02:28 <Absolute0> ah alright
09:02:55 <Absolute0> i guess i was forgetting that haskell is lazy.
09:02:56 <Absolute0> :)
09:03:02 <dmwit> Absolute0: It's hard to compare those two operations, because they don't start and end at the same place.
09:03:09 <tetha> Absolute0: well, you are venturing into the land of optimizing against a single standard library there
09:03:22 <dmwit> Absolute0: Yes, inserting one element is faster than generating a whole new Map, but those are rarely the two options you're comparing.
09:04:06 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2491#a2491 Could anyone tell me why this outputs "pluginA: state of wrong type, pluginB: state of wrong type" in ghci? Is this approach right to realize dynamically loaded plugins which can access the other plugin's states?
09:05:36 <dmwit> Alright, time to go in to work. yay! =)
09:06:24 <Absolute0> :)
09:07:07 <Absolute0> So are list comprehensions lazy when inputted to other functions?
09:07:47 <Absolute0> ie: map (+) 0 [x | x < [0..99999999999]]
09:08:13 <mapreduce> Absolute0: Yes.
09:08:16 <Absolute0> ie: fold (+) 0 [x | x < [0..99999999999]]
09:08:28 <burp> try it
09:08:31 <Absolute0> mapreduce: from #java? :)
09:08:41 <mapreduce> > foldl (+) 0 [1..]
09:08:47 <lambdabot>   mueval-core: Prelude.read: no parse
09:08:47 <lambdabot>  mueval: ExitFailure 1
09:08:54 <mapreduce> > head [1..]
09:08:57 <lambdabot>   1
09:09:24 <EvilTerran> Absolute0, list comprehensions de-sugar to uses of map and filter, so are as lazy as those functions
09:09:52 <EvilTerran> @undo [f x | f <- fs, x <- xs, p x]
09:09:52 <lambdabot> concatMap (\ f -> concatMap (\ x -> if p x then [f x] else []) xs) fs
09:09:59 <Absolute0> mapreduce: foldl (+) 0 [x | x <- [0..99999999999]]
09:10:00 <byorgey> and those functions are pretty lazy.  Just yesterday I asked map to take out the garbage and it said it 'might get around to it later'.
09:10:12 <mapreduce> Absolute0: I am from many programming language channels, not just ##java.
09:10:17 <EvilTerran> ok, concatMap and if/then/else. comes to the same thing.
09:10:28 <Absolute0> rickyclarkson..
09:10:42 <mapreduce> Yes?
09:13:08 <Absolute0> how's scala going?
09:14:12 <mapreduce> Not bad, but I'm not getting to use it as much as I was.  I follow its development closely.
09:15:07 <Absolute0> never got into it, haskell is way cooler :)
09:15:27 <mapreduce> Agreed.
09:17:47 <Absolute0> Is there any syntax to allow an infinite amount of arguments to a function without using lists?
09:18:18 <Absolute0> ie: foo :: a1 -> a2 .. aN-1 -> aN
09:18:27 <doserj> that's not infinite
09:18:30 <pepepto> hola
09:18:35 <Absolute0> i mean undefined
09:18:45 <jeff_s_> unbounded?
09:18:49 <Absolute0> or that :)
09:18:52 <cnwdup> Absolute0, you can use the type system for that like printf does.
09:19:05 <cnwdup> quicksilver, ping
09:19:10 <Absolute0> ah ok
09:19:12 <Absolute0> thanks
09:20:21 <cob_jonas> what's wrong with lists?
09:20:39 <cob_jonas> there's a reason why we've got an easy syntax for lists
09:20:55 <jeff_s_> Text.Printf.printf "%c"
09:21:06 <jeff_s_> > Text.Printf.printf "%c"
09:21:08 <lambdabot>   Add a type signature
09:21:22 <Absolute0> cob_jonas: extra bandwidth
09:21:23 <jeff_s_> er....
09:21:24 <doserj> there is no easy pattern matching syntax for lists, though
09:21:27 <cob_jonas> but printf sucks anyway, because it doesn't handle floating point formats properly
09:21:56 <cob_jonas> bandwidth?
09:22:13 <jeff_s_> @type Text.Printf.printf
09:22:16 <lambdabot> forall r. (PrintfType r) => String -> r
09:22:31 <Absolute0> '[' = 8 bytes!!!
09:22:33 <Absolute0> :)
09:22:51 <jeff_s_> > Text.Printf.printf "%c" "h"
09:22:53 <lambdabot>   Add a type signature
09:23:03 <jeff_s_> oh
09:23:03 <Peaker> Absolute0: I think just 4?
09:23:18 <Absolute0> Peaker: does haskell use unicode?
09:23:26 <Peaker> Absolute0: yeah, at least GHC does
09:23:29 <cob_jonas> oh no
09:23:32 <cob_jonas> I hate this question
09:23:44 <Absolute0> isn't unicode 8 bytes?
09:23:59 * Twey twitches.
09:24:01 <jeff_s_> unicode is like 5 different encoding standards or something like that
09:24:09 <Absolute0> utf-8
09:24:18 <Twey> Unicode is a mapping of code points to characters
09:24:24 <Twey> Different encodings are different sizes
09:24:26 <Peaker> Absolute0: Unicode is an abstract mapping of "code points" to linguistic symbols, and some rules about how to render/go over a sequence of code points
09:24:31 <Twey> UTF-8 is variable-size
09:24:32 <Peaker> Absolute0: a code point is a number within 32-bit range
09:24:45 <Twey> For ASCII characters, it's eight *bits*, hence its name
09:24:56 <Twey> For some other characters it can require more
09:24:59 <Peaker> Absolute0: but it can be encoded in various ways, one of which is UTF8 which takes 8 *bits* per code-point, if it is simple ASCII. When it isn't, it uses more bytes
09:25:14 <Twey> Peaker: :)
09:25:58 <Absolute0> see cob_jonas precious bandwidth down the drain just like that, pftt@
09:26:06 <Absolute0> =)
09:26:14 * Twey laughs.
09:26:17 <Phyx-> *twitches*
09:27:02 <Absolute0> especially in this economy
09:27:35 <Phyx-> hmm... i need to extend my state :P
09:28:13 <jeff_s_> I'm looking at the printf source, and I'm thinking that it's a library I don't ever want to use.
09:29:04 <jeff_s_> http://oreilly.com/catalog/9780596101213/ btw
09:29:04 <Phyx-> lol
09:29:34 <Phyx-> now it's time for a game of... Will it typecheck
09:30:07 <jeff_s_> lambdabot already convinced me that it won't
09:30:22 <Phyx-> lol, i'm talking about my own code :P
09:30:30 <Phyx-> i changed my type of my StateT
09:30:36 <Phyx-> so now i'm notifying everywhere
09:32:29 <EvilTerran> Phyx-, are you familiar with the idea of newtype-wrapping monad transformer stacks?
09:33:18 <Phyx-> EvilTerran: i'm changing the get /put calls, which now return a different value
09:33:26 <Phyx-> not the type or my functions :P
09:33:36 <cob_jonas> or you can try data with named elements and use bracket amend functions
09:33:50 <EvilTerran> Phyx-, ah, i see
09:33:53 <cob_jonas> then the type changes but your code text needn't
09:34:36 <Phyx-> cob_jonas: using records is one way to go, but i don't forsee another change needed
09:35:52 <Phyx-> though you never know, so it's not a bad idea...
09:36:00 <EvilTerran> Phyx-, what i meant was something like "newtype MyMonad a = MyMonad { unMyMonad :: StateT (Foo, Bar) IO a }; getFoo :: MyMonad Foo; getFoo = MyMonad $ gets fst; putFoo :: Foo -> MyMonad (); putFoo foo = MyMonad . put" ...
09:37:06 <EvilTerran> Phyx-, and then you could make it a StateT (Foo, Bar, Baz), and all you'd need to do to fix backwards compatibility would be to update the definitions of (get/put)(Foo/Bar)
09:37:39 <Phyx-> EvilTerran: i have something similiar, but i just use a Type synonym atm
09:38:15 <Phyx-> i ahve
09:38:16 <Phyx-> type ReadB a b c= State (Buchi (a,b),[c])
09:38:17 <Phyx-> type ENGINE a b c d= ReaderT (BuchiPair a b) (ReadB a b d) c
09:38:18 <cob_jonas> EvilTerran: of course that only works if you derive Monad and define a run by hand
09:38:35 <EvilTerran> cob_jonas, well, yeah, there's a little more boilerplate than i let on :P
09:41:14 <cob_jonas> of course that's more useful when you're not just having a state but multiple trickier monad transformers inside
09:42:20 <EvilTerran> cob_jonas, although even with just a State monad, the specialised get/set functions keep changes local if you change the state type
09:43:18 <cob_jonas> but you can get that if you just define custom indexers and amenders for your tuple type, or let haskell syntax do that for you
09:43:55 <Phyx-> ...
09:44:55 <EvilTerran> ???
09:57:18 <Phyx-> hrm.. sometimes i think i build too much infrastructure/framework before i actually start on the logic
10:06:57 <xoclipse> in my cabal file i have build-depends: haxml, but when i try to configure it tells me "Setup.hs: At least the following dependencies are missing:
10:06:57 <xoclipse> HaXml >=1.19.4", (HaXml is installed fine though)
10:07:40 <koeien> cabal is case-sensitive
10:08:05 <xoclipse> yeah i have it like this: Build-Depends:  base, haskell98,
10:08:05 <xoclipse>                   binary >= 0.5, bytestring >= 0.9.1.4,
10:08:05 <xoclipse>                   HaXml >= 1.19.4
10:08:25 <koeien> do you runghc Setup.hs configure ?
10:08:31 <koeien> or cabal configure ?
10:08:37 <koeien> in the first case, add --user if necessary
10:09:12 <dcoutts> or just use cabal
10:09:25 <dcoutts> there's really no need to mix use of 'cabal' with 'runghc Setup'
10:09:27 <koeien> it's shorter anyway :)
10:09:36 <xoclipse> runghc Setup.hs configure doesn't work
10:09:40 <xoclipse> i was doing "runhaskell"
10:09:49 <xoclipse> same thing w/ cabal configure
10:10:01 <xoclipse> if i ghc --make *.hs my source files (that import haxml), it works fine
10:10:09 <xoclipse> so i'm sure that HaXml is installed
10:10:14 <dcoutts> xoclipse: what does ghc-pkg list HaXml say?
10:14:39 <xoclipse> ghc-pkg dump | grep HaXml
10:14:49 <xoclipse> import-dirs: /Users/chris/.cabal/lib/HaXml-1.13.3/ghc-6.10.1
10:14:50 <xoclipse> library-dirs: /Users/chris/.cabal/lib/HaXml-1.13.3/ghc-6.10.1
10:14:50 <xoclipse> hs-libraries: HSHaXml-1.13.3
10:14:50 <xoclipse> haddock-interfaces: /Users/chris/.cabal/share/doc/HaXml-1.13.3/html/HaXml.haddock
10:14:50 <xoclipse> haddock-html: /Users/chris/.cabal/share/doc/HaXml-1.13.3/html
10:15:02 <xoclipse> i changed the cabal script to be HaXml, with no version
10:15:08 <xoclipse> but it still fails
10:15:19 <dcoutts> xoclipse: next time, it's simpler to use "ghc-pkg list HaXml"
10:15:26 <xoclipse> oh okay :)
10:15:50 <dcoutts> xoclipse: so you see why you got the error message now
10:16:05 <xoclipse> 1.13.3 < 1.19.4?
10:16:26 <xoclipse> that ghc-pkg command is helpul, thanks!
10:18:15 <amgarching> why is this illegal? instance (Num a) => Num (a, a) where, How would you do complex numbers with tuples?
10:18:41 <mauke> I wouldn't use tuples
10:19:17 <amgarching> isnt a tuple just another type constructor?
10:19:23 <mauke> yes
10:19:46 <Tigran> amgarching: But you're making an instance that is too specific
10:19:57 <Tigran> amgarching: (a,a) as opposed to (a,b)
10:20:14 <Tigran> By making your own data Complex a = Complex a a
10:20:20 <Tigran> You're only working with a single type variable
10:20:39 <Tigran> Which means you can do the perfectly valid `Num a => Num (Complex a)'
10:25:32 <shag> how do i get RTS options compiled into my program? i.e. when using the -N option for controlling the number of threads, i always want my program to use 4 threads
10:25:49 <shag> without needing to specify +RTS -N4 all the time
10:26:27 <monochrom> I don't think it can.
10:32:04 <cob_jonas> sure you can, with http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#ffi-library
10:32:29 <cob_jonas> or just make a simple wrapper program that execs the other program with +RTS -N as arguments
10:33:58 <cob_jonas> or you can set the GHCRTS environment variable but that would affect all haskell programs
10:34:17 <koeien> including ghc itself...
10:38:41 <deech_> Hi all, How do I use an operator like (+) or (-) if it is part of a module that I imported qualified?
10:38:49 <koeien> (Prelude.+)
10:39:12 <Beelsebob> surprising
10:39:20 <Beelsebob> I would have expected it to be Prelude.(+)
10:39:32 <mauke> I hate hpaste in a good way
10:39:33 <monochrom> IIRC a M.+ b works.
10:39:50 <deech_> That worked thanks!
10:40:11 <Beelsebob> hmm, I guess in that context (M.+) makes more sense
10:40:19 <Beelsebob> parenthesise anything infix and it becomes prefix
10:41:01 <mib_e7tcavos> hey can i ask what is wrong with this code
10:41:10 <mib_e7tcavos> topTenFilmsa :: [Film] -> [FilmB]
10:41:12 <Absolute0> Is it possible to get a range in descending order without calling reverse?
10:41:22 <mib_e7tcavos> topTenFilmsa films = [Film title director year sum length fans]
10:41:25 <mauke> Absolute0: [a, a-1 .. b]
10:41:50 <mib_e7tcavos> can i use sum and length with the statement
10:41:55 <Absolute0> thanks
10:42:27 <mauke> mib_e7tcavos: you're missing a few parentheses
10:42:31 <cnwdup> @ty sum
10:42:33 <lambdabot> forall a. (Num a) => [a] -> a
10:42:36 <cnwdup> @ty length
10:42:37 <lambdabot> forall a. [a] -> Int
10:42:54 <mauke> and some other things
10:43:02 <mib_e7tcavos> hmm
10:43:07 <cnwdup> mib_e7tcavos, you can use length on every list. But you can use sum only on lists which elements are an instances of the Num class.
10:43:21 <cnwdup> *instance
10:43:25 <monochrom> Haskell is not English.
10:44:34 <mib_e7tcavos> but surely length returns a [int]
10:44:44 <Peaker> mib_e7tcavos: why?
10:44:44 <monochrom> You can't just write "automatic banking machine user" and expect it to be parsible.
10:44:46 <mib_e7tcavos> i just used sum to unlist it
10:44:52 <cnwdup> mib_e7tcavos, it returns Int not [Int].
10:44:59 <mib_e7tcavos> ahhh
10:45:06 <monochrom> Haskell is not German either. You can't just write "automaticbankingmachineuser" and expect it to be parsible.
10:45:24 <skorpan> is haskell swedish?
10:45:29 <monochrom> I don't know.
10:45:48 <skorpan> @faq can haskell parse "automatic banking machine user"?
10:45:48 <lambdabot> The answer is: Yes! Haskell can do that.
10:45:49 <jeff_s_> Haskell is Esperanto.
10:45:51 <mib_e7tcavos> still saying fans paramerters arnt set
10:46:02 <mauke> mib_e7tcavos: no, it's not saying that
10:46:09 <cnwdup> mib_e7tcavos, then provide the actual code.
10:46:40 <mib_e7tcavos> sorry its saying:
10:46:41 <Philonous> monochrom: Try capitalising it. Then it might work.
10:46:50 <mib_e7tcavos> Undefined variable "fans"
10:46:58 <monochrom> Haha
10:47:20 <cnwdup> mib_e7tcavos, then you're using the variable fans which is not defined. (; Post the source code in a pastebin, then one can tell you what's wrong.
10:47:21 <monochrom> "Undefined variable" is pretty clear.
10:47:52 <mib_e7tcavos> ok
10:48:17 <monochrom> I don't understand why people don't understand error messages.
10:50:12 <tetha> people are lazy and dont want to read
10:50:13 <Philonous> No instance for (Read Error)
10:50:19 <monochrom> If it says "expected type Char, inferred type Int", then it means exactly that, you have something should be an Int and a Char, you have a self-contradiction. What more do you expect?
10:50:24 <cob_jonas> Philonous++ lol
10:50:38 <monochrom> Do you expect the computer to tell you how to fix it?
10:50:47 <koeien> monochrom: sometimes, yes, but some error messages are obscure
10:50:52 <mib_e7tcavos> http://pastebin.ca/1435211
10:50:57 <tetha> I would love to invent a system that tells you how to fix bugs
10:51:08 <tetha> I guess then I can just stop studying :)
10:51:08 <mib_e7tcavos> trying to return the list of fans as a amount
10:51:13 <monochrom> If so, you may as well die now. If the computer can fix it, why do we need you to write programs? What's your point of existence?
10:51:14 <cob_jonas> < buubot> cob_jonas: The paste 1435211 has been copied to http://erxz.com/pb/17824
10:51:15 <cnwdup> mib_e7tcavos, where are title director year length and fans defined?
10:51:16 <c_wraith> Hmm.  I'm getting conflicting instances between convertible-1.0.1 and time-1.1.3 :(
10:52:09 <cnwdup> mib_e7tcavos, there are several things wrong with your code as far as I can see.
10:52:23 <cnwdup> mib_e7tcavos, you cant to convert a list of Film to a list of FilmB, right?
10:52:37 <mauke> nice typo
10:52:49 <mib_e7tcavos> ok
10:52:50 <tetha> koeien: well, yes, and there are error messages which are misleading due to stacking bugs and arcane errors, but I'd say they are no daily error messages
10:53:51 <cnwdup> mib_e7tcavos, if you want to convert a list of Film to a list of FilmB you have to convert every element of the first list to FilmB. map is the function to use for that.
10:54:08 <mib_e7tcavos> ok
10:54:09 <cnwdup> mib_e7tcavos, map takes a function and a list and applies the function to every element of the list yielding a new list.
10:54:18 <mib_e7tcavos> kl
10:54:26 <cnwdup> mib_e7tcavos, you can write your function topTenFilmsa using topTenFilmsa films = map toFilmB films.
10:55:03 <cnwdup> mib_e7tcavos, toFilmB will look pretty miuch like topTenFilma but title, directory, etc. are used wrong. They are not defined.
10:55:41 <c_wraith> Ok...  problem solved...  explicit dependency on an older version of time. >_>
10:55:45 <cnwdup> mib_e7tcavos, However, you can define them as you want if you pattern match Film correctly: toFilmB :: Film -> FilmB, toFilmB (Film title directory year fans) = FilmB title directory year (length fans)
10:56:48 <mib_e7tcavos> ok i see what u mean
10:56:58 <cnwdup> mib_e7tcavos, another issue with your code: length fans has to be in parantheses since otherwise length and fans would be applied to the data constructor Film. But you want to result of (length fans) to be applied.
11:03:55 <Baughn> http://www.pps.jussieu.fr/~jch/software/XinC.html <-- Have a read, fellows
11:08:56 <ehird> :t (<*>)
11:08:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:08:58 <ehird> :t (<$>)
11:08:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:09:16 <ehird> hmm
11:09:37 <ehird> <$> is used to do things like (pureFunction <$> getLine), isn't it?
11:09:50 <ehird> what about (unpureFunction <??> getLine)?
11:09:58 <Twey> Is IO a functor?
11:10:11 <ehird> (and (unpureFunction <??> getLine <??> aPureThing <??> anotherUnpurething) etc)
11:10:12 <c_wraith> ehird:  is <*> what you want?
11:10:13 <Twey> ehird: >> or >>=
11:10:16 <cnwdup> ehird, what's wrong with <*> or ap for that?
11:10:33 <ehird> Twey: in (f <foo> x) style, I mean
11:10:40 <deech_> Hi all,
11:10:41 <Beelsebob> ehird: <*>
11:10:42 <ehird> cnwdup: (unpureFunction <*> getLine) :: IO (IO x)
11:10:48 <ehird> err, wait
11:10:51 <ehird> no
11:11:01 <ehird> Beelsebob: how, (a -> IO b) != IO (a -> b)
11:11:04 <ehird> 19:08 lambdabot: forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:11:23 <Beelsebob> ehird: well, IO (a -> b) is one form of impure function
11:11:24 <Twey> :t print <*> getLine
11:11:26 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `IO ()'
11:11:26 <lambdabot>     Probable cause: `print' is applied to too many arguments
11:11:26 <lambdabot>     In the first argument of `(<*>)', namely `print'
11:11:34 <Beelsebob> if you happen to have one of type a -> IO b then you want =<<
11:11:39 <ehird> ok
11:11:42 <deech_> I am trying to import a CSV file using Text.CSV.ByteString, but it fails if any of the fields have a comma, even if the string containing the comma is enclosed in quotes.
11:11:45 <Twey> :t print <$> getLine
11:11:46 <Beelsebob> :t print =<< getLine
11:11:46 <lambdabot> IO (IO ())
11:11:47 <ehird> what about multiple arguments?
11:11:47 <lambdabot> IO ()
11:11:55 <Twey> So that would be join
11:12:01 <ehird> say, (a -> b -> c -> IO d) and a and b are impure, but b is pure
11:12:05 <Absolute0> How do I extract the a from Just a?
11:12:22 <tromp> easiest by peatternmatch
11:12:24 <Twey> join (print <$> getLine)  print =<< getLine
11:12:27 <monochrom> Use the do-notation for more arguments.
11:12:34 <ehird> monochrom: bleargh
11:12:52 <Twey> Absolute0: Pattern match, or fromJust if you're sure it's a Just, or maybe/fromMaybe otherwise
11:12:55 <tromp> :t fromJust
11:12:56 <lambdabot> forall a. Maybe a -> a
11:13:00 <tromp> or that way
11:13:00 <Beelsebob> if you don't want to use do notation, use >>= and lambdas ehird
11:13:06 <Beelsebob> or...
11:13:13 <Beelsebob> stop programming with side effecting stuff ;)
11:13:25 <Absolute0> ah, I was trying to use guards direct matching seems like the way to do it..
11:13:29 <Twey> Note that fromJust is unsafe if it could possibly be a Nothing  it will throw an error.
11:13:55 <FalconNL> Does anyone know if there's a tutorial on how to work with the AST generated by Language.Haskell.Exts, e.g. getting a list of all top-level functions?
11:13:58 <Absolute0> |a == Nothing | a == Just a which is obviously wrong
11:14:06 <Twey> Very
11:14:09 <Absolute0> :)
11:14:28 <ehird> Beelsebob: welp
11:14:31 <ehird> main = do [input, output] <- getArgs; image <- loadPngFile input; processImage image; savePngFile output image
11:14:36 <ehird> it's just that that's pretty ugly.
11:14:47 <monochrom> If you have N arguments you are asking for 2^N combinators.
11:14:57 <Beelsebob> ehird: is the image a resource that is read only once?
11:15:13 <monochrom> do-notation is pretty pretty.
11:15:16 <ehird> Beelsebob: Clarification?
11:15:28 <Beelsebob> ehird: does your program ever load the same image file more than once?
11:15:41 <ehird> Beelsebob: No.
11:16:05 <Beelsebob> ehird: then you can treat loadPngFile as a pure function
11:16:10 <Beelsebob> by wrapping it in unsafePerformIO
11:16:12 <monochrom> ...
11:16:14 <ehird> Beelsebob: ...
11:16:15 <ray> !!!
11:16:23 * Twey twitches.
11:16:27 <ehird> (1) No. (2) NO GOD NO. (3) It's a GD function.
11:16:28 * Zao kicks Beelsebob in the monads.
11:16:38 <ray> what's wrong about image <- loadPngFile
11:16:43 <Beelsebob> can anyone give me an example where it behaves in a non pure way?
11:16:59 <ray> here's what's wrong about it: nothing
11:17:02 <Twey> Beelsebob: It does IO?
11:17:09 <Beelsebob> Twey: so does unamb
11:17:14 <Beelsebob> so do many pure functions
11:17:21 <Beelsebob> + for example
11:17:27 <Twey> And what do they do if the IO fails?
11:17:33 <ehird> ... + does IO?
11:17:35 <Beelsebob> return a Maybe
11:17:36 <ehird> LOL WAT
11:17:41 <Beelsebob> ehird: sure - it calls into the haskell runtime
11:17:45 <Zao> Blowing up far from the call site is something you usually need dynamically typed languages for.
11:17:46 <ehird> Oh please.
11:17:50 <Beelsebob> a great big impreative lump of code
11:17:57 <ehird> Implementation details are NOT the same as API details.
11:17:59 <Twey> Um.
11:18:04 <ehird> You're silly.
11:18:14 <Beelsebob> can you give an example where it behaves in an impure way?
11:18:19 <Twey> Every function is impure.  Let's go back to Clojure!
11:18:26 <Beelsebob> when will it return different values for different calls?
11:18:32 <mauke> Beelsebob: when the file changes
11:18:35 <Beelsebob> remembering that you guarenteed me that you only call it once
11:18:38 <Beelsebob> mauke: he only calls it once
11:18:44 <mauke> Beelsebob: irrelevant
11:18:45 <ehird> This is ridiculous. Utterly ridiculous.
11:18:52 <mauke> Beelsebob: we don't have strict evaluation
11:18:56 <Beelsebob> mauke: so?
11:19:09 <mauke> so the compiler can evaluate stuff as often as it wants
11:19:09 <ray> even if you could use unsafePerformIO safely in theory, why would you do it if you can avoid it
11:19:15 <mauke> particularly in the presence of inlining
11:19:30 <Beelsebob> mauke: which is why you follow the unsafePerformIO rules and mark it no inline ;)
11:19:34 <Baughn> Twey: If unamb fails, in particular, it retries the next time you invoke it
11:20:01 <Baughn> Twey: For unsafePerformIO in general, it stores the current state of the IO when it catches an exception, and restarts from there
11:20:34 <ray> ehird: i don't think that's ugly, incidentally
11:20:49 <Beelsebob> if you only load the file once, you can treat it like a resource - just like your program's code... It is to all intents and purposes a pure value
11:21:00 <ray> where's the ugly part?
11:21:27 <ehird> does anyone know an alternative to the gd package that doesn't stick everything in IO?
11:22:43 <deech_> Sorry, my last message was interrupted by a phone call, but I have a CSV file with some text quoted. There are commas within the quotes, but Text.CSV.ByteString parses them as a column break. Is there any way to tell Text.CSV to ignore commas within quotes?
11:23:06 <Phyx-> 20:17:22  * Twey twitches. <-- been doing that alot today, maybe you should see a doctor :P
11:23:30 <Twey> Haha :-P
11:23:47 <Baughn> deech_: The CSV standard has no "quotes". Or variable-sized fields, for that matter. :P
11:23:55 <Twey> Baughn: Reading a file is quite clearly IO, IMO.
11:23:56 <Baughn> deech_: I imagine you could propose a patch to do that
11:23:58 <Beelsebob> ehird: in the mean time, what I'd really do with that program is main = readWrite =<< getArgs where readWrite [in,out] = wrietFile out . processImage =<< readFile in
11:24:10 <Baughn> Twey: The question isn't whether it's IO, it's whether it's semantically pure
11:24:11 <Twey> CSV is a standard?
11:24:13 <Beelsebob> with a pure processImage function
11:24:22 <Twey> But it reads a file
11:24:27 <Twey> Of course it isn't semantically pure
11:24:29 <Baughn> Twey: Which it is, if only done once. Okay, I admit that's questionable, but there you go
11:24:30 <deech_> Baughn : I didn't know csv was a standard either.
11:24:34 <Baughn> Twey: "IO" is a misnomer
11:24:41 <Twey> It's not just an implementation detail  the goal of the function is to perform IO
11:24:56 <cob_jonas> wow, em dash
11:25:07 <cob_jonas> with spaces
11:25:08 <ehird> Beelsebob: I cannot have a pure processImage. All of the gd functions are in IO.
11:25:09 <Baughn> Twey: The IO monad doesn't exist to do IO, it exists to handle impure functions that do IO
11:25:21 <Twey> cob_jonas: Unspaced em dashes are the devil
11:25:30 <Baughn> deech_: Sort of
11:25:33 <eivuokko> Baughn, it's also short to type.
11:25:35 <Beelsebob> ehird: fix the library then - image processing is entirely pure
11:25:54 <Baughn> deech_: Anyway, there are too many possible ways to quote csv data. You could propose a patch adding support for one, but of course only if it's optional.
11:26:05 <Twey> Baughn: I would say that was pretty much the definition of impure
11:26:09 <cob_jonas> Twey: IMO em dashes are devil, one should use en dashes, but that's because I've grown up in Hungary where en dashes are standard (and in some fonts they look as wide as em dashes)
11:26:13 <ehird> Beelsebob: I cannot.
11:26:18 <Beelsebob> why not?
11:26:25 <Twey> cob_jonas: En dashes have a separate meaning in English
11:26:33 <Twey> Several separate meanings, actually
11:26:46 <Baughn> Twey: And I would disagree. IO can be pure, if it's idempotent and gives the same thing every time.
11:27:19 <Beelsebob> Twey: is a forgien function call to int jam (void) { return 5; } pure?
11:28:08 <Twey> Beelsebob: Yes  that function is intrinsically pure
11:28:13 <Beelsebob> but it's in IO
11:28:18 <Beelsebob> so it can't be, can it?
11:28:29 <Twey> Yes  *that's* a case of pure semantics
11:28:38 <Twey> And what I would use unsafePerformIO for
11:28:45 <Beelsebob> right then, so your argument that any IO function can't be pure is invalid
11:29:02 <cob_jonas> do you mean (return 5 :: IO Int)
11:29:07 <Philonous> Beelsebob: Bat readFile is neither side effect free nor even referentially transparent
11:29:10 <Beelsebob> similarly callMeOnlyOnceLoadResource :: FilePath -> Something can also be pure
11:29:20 <Beelsebob> as long as you meet the precondition
11:29:22 <Beelsebob> that you call it only once
11:29:37 <cob_jonas> lol
11:29:45 <Beelsebob> otherwise, no haskell program is pure - after all, the haskell program is a resource that's loaded from disk
11:30:10 <Beelsebob> we just have to guarentee that the OS only loads the program once
11:30:36 <xoclipse> hey guys, I made a simple AIM/OSCAR client in haskell, it was a cool little project, if anyone wants to check it out: http://chrismoos.com/2009/05/26/haskell-aim-client-a-cool-proof-of-concept/
11:30:44 <Philonous> Beelsebob: Of course the program is impure, that's why main is in IO
11:30:44 <Baughn> Beelsebob: You could use a global variable
11:30:57 <Baughn> Beelsebob: Start your onlyOnce function with "putMVar global ()"
11:31:04 <Beelsebob> Baughn: that would certainly guarentee the only once bit, yes
11:31:08 <Beelsebob> sounds like an execellent plan to me
11:32:37 <Peaker> xoclipse: haim is a Hebrew name of a guy
11:32:58 <Cale> xoclipse: cool
11:33:10 <Peaker> xoclipse: why do you use () around IO args?  IO (String) instead of IO String?
11:33:54 <Peaker> xoclipse: did you write your own Show instances because you don't like the derived ones?
11:33:57 <xoclipse> no particular reason
11:34:15 <xoclipse> peaker: i just wanted a little more customization
11:34:31 <xoclipse> (for the show instances)
11:34:37 <Peaker> xoclipse: why did you wrap a Get that you wrote with a runGet -- instead of just exporting Get values?
11:35:04 <xoclipse> which file peaker?
11:35:10 <Peaker> xoclipse: tlv.hs
11:35:10 <xoclipse> you've got a lot of questions :P
11:35:17 <xoclipse> btw i've only been using haskell for ~ month
11:35:27 * jeff_s_ senses someone overusing the Socratic method.
11:35:41 <Peaker> xoclipse: oh, awesome work ;)
11:35:44 <xoclipse> i used runget because i didn't want the function that cals tlv_get to have to run it
11:36:08 <xoclipse> i use runPut and runGet a lot
11:36:13 <xoclipse> great functions btw, bytestring is awesome
11:36:17 <Peaker> xoclipse: the function that calls tlv_get would have to unpack the tuple and do with the continuation byte-string, which is what Get makes more convenient (and possibly more efficient too)
11:36:58 <xoclipse> so tlv_get :: BS.ByteString -> Get (TLV, BS.ByteString) is better?
11:37:14 <Peaker> xoclipse: for example, if you look at tlv_extract_lblock -- it calls tlv_get and then uses fst/snd on its result, instead of being able to just use:  result <- tlv_get ; use rest of input stream here
11:37:23 <Peaker> xoclipse: tlv_get :: Get TLV
11:37:42 <Peaker> xoclipse: (Get a) already encapsulates the notion of having a bytestring input and extra bytestring output
11:37:52 <xoclipse> ohhh okay
11:37:57 <xoclipse> yeah that's my misunderstand of it
11:38:03 <xoclipse> great that makes my life easier :)
11:38:06 <Peaker> xoclipse: :-)
11:38:35 <xoclipse> you try out the client?
11:38:37 <Peaker> xoclipse: also, if you have:   let result = tlv_get stuff   and then you use  (fst result) and (snd result)  its nicer to use:   let (result, somethingElse) = tlv_get stuff ...
11:38:44 <Peaker> xoclipse: I don't have an AIM account..
11:38:47 <cob_jonas> so type Get = State BS.ByteString
11:38:52 <xoclipse> ah okay
11:38:59 <xoclipse> peaker: good points
11:39:07 <xoclipse> its a learning process :)
11:39:09 <xoclipse> that's why i write thigns like this
11:39:13 <xoclipse> each time it gets better
11:39:16 <Peaker> xoclipse: sure, its the best way to learn, good job :)
11:39:40 <Peaker> xoclipse: its already looking decent, and a lot more than decent if you consider that its just 1 month
11:39:55 <xoclipse> :)
11:39:58 <Twey> Beelsebob: I didn't have an argument that any IO function (one returning and IO a) was impure
11:40:03 <Twey> an**
11:40:12 <Peaker> cob_jonas: I guess it could be implemented that way, but its not a good semantic model, because you can only move forward/backward and not arbitrarily change the string
11:40:25 <xoclipse> i love the recusriveness of the tlv_extract* functions
11:40:27 <xoclipse> i had fun with that
11:40:37 <xoclipse> incidentally i really like the OSCAR protocol (SNAC, TLV, etc,.)
11:41:31 <Peaker> xoclipse: a nice rule of thumb to know is that prefix-calls are always higher-precedence than infix,  so you never need () around them.  e.g:  if (BS.length stuff) == 0 then ([], BS.empty) else do -- can be:  if BS.length stuff == 0 then ...
11:41:41 <Peaker> @hoogle ByteString -> Bool
11:41:42 <lambdabot> Data.ByteString null :: ByteString -> Bool
11:41:42 <lambdabot> Data.ByteString.Char8 null :: ByteString -> Bool
11:41:42 <lambdabot> Data.ByteString.Lazy null :: ByteString -> Bool
11:41:57 <Peaker> xoclipse: BS.null is basically a comparison of length to 0, except it can be more lazy
11:42:23 <xoclipse> okay cool
11:43:12 <xoclipse> right the parentheses can go
11:43:19 <xoclipse> that's my C/C++/Java background :p
11:43:23 <xoclipse> stupid parentheses
11:43:47 <Peaker> xoclipse: oh cool, I needed an HaXml example, and now I have one :)
11:43:55 <cnwdup> @pl (\f -> f `fmap` get)
11:43:56 <lambdabot> (`fmap` get)
11:43:59 <xoclipse> yeah, i had fun with that
11:44:03 <xoclipse> took me a while to grasp HaXml
11:44:17 <xoclipse> i probably stared at the screen for like 15 minutes and just thought
11:44:18 <xoclipse> haha
11:44:24 <Peaker> xoclipse: I think if you use   deriving (Show, Read, ..) you get a show that's just as good, and no need for the boilerplate
11:44:34 <xoclipse> great, good to know
11:44:47 <cob_jonas> I just decided the "xml" library looks better
11:45:08 <cnwdup> @pl (\f -> get >>= put . f)
11:45:08 <lambdabot> (get >>=) . (put .)
11:45:22 <Peaker> xoclipse: a pattern-match of  (host:(port:(cookie:xs)))  needs no () because : is already right-associative   host:port:cookie:xs
11:45:32 <cnwdup> @pl (\f -> put . f =<< get)
11:45:32 <lambdabot> (get >>=) . (put .)
11:45:37 <xoclipse> :)
11:46:35 <Peaker> xoclipse: its nicer to have f . g . h . i $ x   than: f $ g $ h $ i $ x, too
11:47:09 <Peaker> let sig = encode $ BS.unpack $ bytestringDigest $ hmacSha256  (BS.pack $ sessionKey info) (BS.pack hashData)  -->  let sig = encode . BS.unpack . bytestringDigest . hmacSha256 (BS.pack $ sessionKey info) . BS.pack $ hashData
11:47:34 <cob_jonas> I still think usually just parenthesis are better than $
11:47:56 <Peaker> does ByteString.Char8 do utf8 or just (`mod`256)?
11:48:13 <Peaker> cob_jonas: its really nice to be able to cut & paste  any subset of the "pipe-line" out to its own function
11:48:15 <jeff_s_> not utf8
11:48:31 <Peaker> how do you convert String -> ByteString with some unicode encoding?
11:48:51 <Zao> Peaker: Data.Text?
11:48:53 <cob_jonas> Peaker: the encoding module
11:49:07 <xoclipse> okay i'll use the f .g etc,.
11:49:41 <Peaker> xoclipse: also, underscore convention isn't very common - the entire library/etc are all in camelCase
11:50:09 <cob_jonas> yeah, but undescores are actually more readable
11:50:16 * cob_jonas ducks
11:50:52 <xoclipse> okay
11:51:48 <xoclipse> okay, i'm out for now
11:51:53 <xoclipse> thanks for the tips, Peaker
11:52:20 <Peaker> xoclipse: sure thing
11:52:44 <Peaker> cob_jonas: a mishmash is less readable than either convention uniform though, and names less guessable
11:53:17 <Baughn> So dromedarCase it is
11:53:21 <Baughn> And CamelCase for types
11:53:47 <cob_jonas> yeah
11:53:56 <cob_jonas> but that's only if you give verbose names like the libraries
11:54:34 <cob_jonas> if you use abbrevs like mk_wrd then camelCasing doesn't make it any more mish-mash or predictability
11:54:41 <cob_jonas> it's two conventions either way
11:56:13 <burp> @pl f x y z = x^2+y^3+z^4
11:56:13 <lambdabot> f = flip flip (^ 4) . (((.) . (+)) .) . (. (^ 3)) . (+) . (^ 2)
11:58:08 <cob_jonas> > let { f x y z = x^2+y^3+z^4 } in f x y z
11:58:10 <lambdabot>   x * x + y * y * y + z * z * (z * z)
12:03:10 <ehird> 19:54 cob_jonas: if you use abbrevs like mk_wrd then camelCasing doesn't make it any more mish-mash or predictability
12:03:11 <ehird> 19:54 cob_jonas: it's two conventions either way
12:03:13 <ehird> so don't do that
12:05:18 <zong_sharo> does pattern matching strict or lazy by default? (eg, w/o ! or ~)
12:05:54 <pumpkin> > let f (x, y) = 5 in f undefined
12:05:56 <lambdabot>   * Exception: Prelude.undefined
12:05:59 <pumpkin> :)
12:06:09 <pumpkin> > let f ~(x, y) = 5 in f undefined
12:06:10 <lambdabot>   5
12:07:03 <mmorrow> , let x = undefined in 20
12:07:05 <lunabot>  20
12:07:11 <mmorrow> , let (x,y) = undefined in 20
12:07:13 <lunabot>  20
12:08:01 <mmorrow> let matches are lazy and case matches are strict (patterns in the params of a function == case) (unless you use ~ like pumpkin)
12:08:29 <Peaker> mmorrow: is there a difference between let ~(x,y) =   and let (x,y) =  ?
12:08:42 <mmorrow> hmm
12:08:43 <Cale> zong_sharo: In function bindings, pattern matching forces evaluation when the function is applied. In pattern bindings, it's like there's an implicit ~ at the front of the pattern. The pattern is only matched if you use one of the variables it binds.
12:09:11 <Beelsebob> Peaker: yes
12:09:19 <Cale> Peaker: no
12:09:31 <pumpkin> Peaker: maybe (given the previous two answers)
12:09:35 <Peaker> heh
12:09:37 <Beelsebob> the first one will start evaluating the right hand side before the (_|_, _|_) is produced
12:10:10 <cob_jonas> but note that
12:10:13 <Beelsebob> > let f ~(x,y) = 5 in f undefined
12:10:15 <lambdabot>   5
12:10:18 <Beelsebob> > let f (x,y) = 5 in f undefined
12:10:19 <lambdabot>   * Exception: Prelude.undefined
12:10:22 <cob_jonas> > let { f (x, y) = (); } in seq (f undefined) ()
12:10:23 <lambdabot>   * Exception: Prelude.undefined
12:10:24 <Beelsebob> see... there's a difference
12:10:26 <cob_jonas> > let { f (x, y) _ = (); } in seq (f undefined) ()
12:10:28 <lambdabot>   ()
12:10:33 <Peaker> > let (x,y) = undefined in 5
12:10:35 <lambdabot>   5
12:10:38 <Peaker> > let ~(x,y) = undefined in 5
12:10:39 <lambdabot>   5
12:10:39 <Cale> 'A pattern binding binds variables to values. A simple pattern binding has form p = e. The pattern p is matched "lazily" as an irrefutable pattern, as if there were an implicit ~ in front of it.'
12:10:42 <Peaker> this behavior is weird
12:10:44 <zong_sharo> Cale: thx
12:10:52 <Cale> (From the Report)
12:10:58 <cob_jonas> Peaker: it is, but it's right
12:10:59 <Beelsebob> oh hang on, I read your pattern wrong
12:11:05 <mmorrow> Peaker: the let match is never attempted if it isn't needed
12:11:33 <Cale> However, ! has the power to turn let into case :)
12:11:41 <Cale> > let !(x,y) = undefined in 5
12:11:43 <lambdabot>   * Exception: Prelude.undefined
12:11:43 <Peaker> I see -- so argument pattern matches of functions defined by let are not irrefutable
12:11:48 <mmorrow> bang!
12:12:04 <Peaker> hmm.. I think let ~(x,y) ... should be a syntax error if its no different to  let (x,y) = ...
12:12:17 <cob_jonas> Peaker: why? that wouldn't be really consistent
12:12:32 <Cale> Of course you should be able to nest ~'s
12:12:39 <Peaker> cob_jonas: its already inconsistent -- let has different semantics, why should it have the same syntax?
12:12:44 <Cale> They're idempotent, but it doesn't hurt to allow it.
12:13:36 <Cale> Peaker: It's unnatural to have only one place in a pattern where ~ isn't allowed and only in the case of let
12:14:05 <Cale> Note that things like  let (~(x:xs),ys) = ...  can still be useful
12:14:09 <cob_jonas> Cale: well, let woulnd't be the only case
12:14:31 <cob_jonas> top-level bindings and postfix where and do-let statements has that too
12:14:39 <Cale> Well, sure.
12:14:50 <cob_jonas> but I think there's no point banning ~ there
12:14:56 <Cale> I suppose I mean "only pattern bindings"
12:16:06 <Cale> > let x + 1 = 0 in 5 + 1
12:16:08 <lambdabot>   0
12:16:13 <Cale> > let (x + 1) = 0 in 5 + 1
12:16:14 <lambdabot>   6
12:16:19 <Peaker> Cale: it can also be disallowed to use ! in case !foo ..
12:16:29 <Cale> > let (x + 1) = 0 in x
12:16:31 <lambdabot>   * Exception: <interactive>:1:145-155: Irrefutable pattern failed for patter...
12:16:38 <Cale> > let (x + 1) = 5 in x
12:16:40 <lambdabot>   4
12:16:56 * Lemmih grins.
12:16:57 <Cale> > let x + 1 = 5 in x
12:16:59 <lambdabot>   x
12:17:04 <Cale> :)
12:17:14 <Cale> lol, simplereflect
12:17:17 <cob_jonas> Peaker: oh no, ! is completely different I think
12:17:29 <Peaker> Cale: I see, I think my problem is that let is irrefutable by default on the outside, and not irrefutable anywhere else, that's weird
12:17:45 <Peaker> why isn't let strict like case? add ~ for irrefutable ones?
12:18:14 <Cale> Well, usually you don't want all your let-bound things evaluating before they're needed.
12:18:32 <arcatan> i want to use hGetBuf, but how can I create a buffer where it would write?
12:18:36 <Cale> (and I'm including the top-level and where clauses, etc. in that)
12:18:50 <hatds> lazy lets are useful, if you made it strict I'd demand a lazy replacement :)
12:18:52 <Cale> let is all about putting things on the heap, not evaluation.
12:18:55 <cob_jonas> Cale: that's not _all_ your let bound things, only the rarer case when you let bind to a constructor pattern (or numeric etc)
12:19:06 <cob_jonas> still I think the current haskell semantics is great
12:19:12 <Peaker> Cale: yeah, I see, I think the "right" thing is to just not allow lets to pattern-match, but that would be a little inconvenient given current syntax
12:19:21 <cob_jonas> it's easy to remember and is chosen right
12:19:24 <Cale> cob_jonas: Well, sure, function bindings are already in WHNF :)
12:19:39 <cob_jonas> Cale: also plain bindings to a variable
12:19:42 <Cale> Peaker: It's handy, and it does what you want. :)
12:20:02 <Peaker> it behaves weird, though
12:20:18 <Cale> Peaker: It just takes a little thinking to realise that this strange-seeming behaviour really is what you want most of the time :)
12:21:34 <Baughn> What was the difference between HNF and WHNF again, exactly?
12:21:42 <Cale> > let fibs@(x:fibs') = 0 : 1 : zipWith (+) fibs fibs' in fibs
12:21:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:21:59 <Cale> Baughn: I seem to recall something about evaluation under lambdas?
12:22:50 <Cale> right.
12:23:03 <Cale> \x -> ((\y -> y+x) 2)
12:23:08 <Cale> is in WHNF, but not HNF.
12:23:12 <Peaker> Baughn: http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form
12:23:18 <pumpkin> how does Clean's uniqueness typing deal with forking and concurrency?
12:23:39 <Cale> So the difference is that WHNF doesn't evaluate underneath a lambda
12:25:35 <Peaker> It could probably do the reduction inside inner lambda's, I don't see why it would have a rename problem - it doesn't actually need to use string names..
12:25:39 <Baughn> , tipe `fmap` getClosureData 42
12:25:41 <lunabot>  luna: Not in scope: `tipe'
12:26:05 <Phyx-> :type getClosureData
12:26:10 <Phyx-> @type getClosureData
12:26:11 <lambdabot> Not in scope: `getClosureData'
12:26:16 <Cale> Peaker: hm?
12:26:25 <Baughn> Peaker: Okay, so HNF is a subset of WHNF
12:26:26 <Baughn> That makes sense
12:26:28 <Cale> Peaker: HNF reduces inside lambdas, WHNF doesn't
12:27:44 * Baughn continues mutilating haskell's semantics
12:27:51 <pumpkin> Baughn: did you figure out if you could link to that table?
12:28:09 <Baughn> pumpkin: Not yet, had an exam today. I'm just starting on that now.
12:28:59 <pumpkin> Baughn: do you see what I mean by the U symbol though?
12:29:12 <Baughn> pumpkin: Yes, but it's mistaken
12:29:28 <Baughn> Each RTS .a defines /multiple/ closure_flags symbols
12:29:36 <Baughn> One D, the others U
12:29:50 <pumpkin> hmm
12:29:55 <pumpkin> I didn't see that in mine
12:29:57 <hackagebot> hack-middleware-gzip 0.0.0
12:30:27 <Baughn> pumpkin: for i in *a; do echo $i; nm $i |grep closure_flags; done
12:30:32 <Cale> Odd, despite the language spec being called "The Concurrent Clean Language Report", I'm having trouble finding any actual mention of concurrency in it at all.
12:30:34 <Baughn> In /usr/local/lib/ghc*/
12:30:59 <Cale> Is it just the report itself which is concurrent?
12:32:40 <pumpkin> Baughn: oh I see
12:33:41 <Baughn> pumpkin: So I'll get this working now, but the overhead from actually /linking/ that is so enormous, it'll have to wait for 6.12
12:33:45 <Baughn> And dynamic linking
12:33:55 <pumpkin> why?
12:33:59 <Cale> Oh, version 1.3.1 had process annotations which look like they're related to parallelism or concurrency, but they were apparently removed in 2.0
12:34:02 <Baughn> 22MB hello,world
12:34:24 <Cale> That's somewhat embarrassing if the most recent standard for Concurrent Clean doesn't support concurrency though.
12:34:46 <pumpkin> lol
12:34:49 <pumpkin> yeah
12:34:56 <pumpkin> how would uniqueness typing deal with that though?
12:34:59 <pumpkin> was it just too complicated?
12:35:11 <Peaker> Cale: was talking about what http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form  said
12:35:56 <deech_> Hi all, is there a Haskell library that will convert an HTML text with diacritics into a Haskell String?
12:36:30 <Cale> pumpkin: hmm, it doesn't say anything about the interation of parallelism with I/O
12:37:31 <Cale> pumpkin: Oh, hmm, it appears that I'm looking in the wrong place for stuff about concurrency. There's supposed to be a library...
12:39:42 <andouille> I saw that yesterday: http://en.wikibooks.org/wiki/Haskell/Solutions/List_processing and I didn't manage to understand little things like 'x == y' in the encode function
12:39:52 <andouille> Can you help me please, it's for coding a RLE
12:40:11 <Cale> okay
12:40:23 <Cale> deech_: I'm not sure. There are various HTML parsing libraries though
12:41:02 <Cale> andouille: The x == y is a guard
12:41:19 <Cale> andouille: Only if x == y gives True does that equation apply.
12:41:33 <Cale> andouille: Otherwise, the 'otherwise' case is used.
12:41:59 <Cale> That is, if x == y then the result of encode (x:y:xs) is succHead (encode (y:xs))
12:42:02 <Baughn> andouille: "otherwise" is just a global binding to True, by the way. It's not syntax.
12:42:24 <andouille> SO if 'x == y', what does it means concretly for the list ?
12:42:36 <cob_jonas> @type (==)
12:42:37 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:42:40 <Cale> andouille: That the first two elements are equal
12:42:45 <cob_jonas> > 3 == 5
12:42:46 <lambdabot>   False
12:42:48 <cob_jonas> > 3 == 3
12:42:49 <lambdabot>   True
12:42:50 <cob_jonas> > 3 == 2
12:42:51 <andouille> does it means that @type(==)
12:42:52 <lambdabot>   False
12:42:54 <Baughn> andouille: (x:y:xs), see
12:42:58 <andouille> omg sorry
12:43:09 <andouille> Ok thanks
12:43:10 <Phyx-> > otherwise && otherwise
12:43:12 <lambdabot>   True
12:43:14 <Phyx-> lol
12:43:17 <Cale> andouille: (x:y:xs) is the list whose first two elements are x and y respectively, and the rest is called xs
12:43:18 <Phyx-> now that's funny
12:43:53 <Peaker> > otherwise
12:43:55 <lambdabot>   True
12:44:03 <Cale> andouille: I think I should point out that this way uses way too much explicit recursion, and isn't really making the most of library functions :)
12:44:10 <andouille> Ok, I used to think that it was the first element that's x, the rest that's y and the last one that's xs.
12:44:12 <Baughn> andouille: Or, in a pattern-match context, it's a pattern-match that decomposes such a list into the originating x, y and xs :)
12:44:12 <andouille> Thanks
12:44:22 <Baughn> > 2:3:[4..7]
12:44:22 <Cale> > map (\xs -> (length xs, head xs)) . group $ "mississippi"
12:44:23 <lambdabot>   [2,3,4,5,6,7]
12:44:24 <lambdabot>   [(1,'m'),(1,'i'),(2,'s'),(1,'i'),(2,'s'),(1,'i'),(2,'p'),(1,'i')]
12:44:40 <Baughn> > 2:3:0:[4..7] -- andouille: See? Simple.
12:44:41 <lambdabot>   [2,3,0,4,5,6,7]
12:44:51 <Cale> > map (\xs -> (length xs, head xs)) . group $ "ruuuuunnnnnn   lllleeeennnnnngggttthh"
12:44:52 <lambdabot>   [(1,'r'),(5,'u'),(6,'n'),(3,' '),(4,'l'),(4,'e'),(6,'n'),(3,'g'),(3,'t'),(2...
12:44:55 <andouille> :D
12:45:19 <pumpkin> aw, no &&& ?
12:45:31 <pumpkin> Control.Arrow needs lovin too
12:45:34 <Baughn> > map (length &&& head) . group $ "ruuuun length"
12:45:35 <lambdabot>   [(1,'r'),(4,'u'),(1,'n'),(1,' '),(1,'l'),(1,'e'),(1,'n'),(1,'g'),(1,'t'),(1...
12:46:01 <hackagebot> hack-handler-kibro 2009.5.27
12:46:01 <hackagebot> bamboo 2009.5.27
12:46:22 <pumpkin> > concatMap (uncurry replicate) . map (length &&& head) . group $ "ruuuun length"
12:46:24 <lambdabot>   "ruuuun length"
12:46:26 <Cale> > concatMap (\(n,x) -> replicate n x) $ [(1,'r'),(5,'u'),(6,'n'),(3,' '),(4,'l'),(4,'e'),(6,'n'),(3,'g'),(3,'t'),(2,h)]
12:46:28 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Char)
12:46:28 <lambdabot>    arising from a u...
12:46:32 <andouille> How could I find a really good tutorial or a documentation for all the "operators" like '.' or '$' please
12:46:33 <Cale> oops
12:46:37 <Cale> > concatMap (\(n,x) -> replicate n x) $ [(1,'r'),(5,'u'),(6,'n'),(3,' '),(4,'l'),(4,'e'),(6,'n'),(3,'g'),(3,'t'),(2,'h')]
12:46:38 <lambdabot>   "ruuuuunnnnnn   lllleeeennnnnngggttthh"
12:47:03 <cob_jonas> ($) is just identity restricted to functions, (.) is function composition
12:47:06 <Cale> So basically, whoever wrote that code didn't know about... map, concatMap, group, replicate... :)
12:47:08 <Baughn> andouille: Well, . and $ are just function composition and application respectively
12:47:23 <pumpkin> > uncurry replicate =<< (map (length &&& head) . group $ "ruuuun length")
12:47:24 <lambdabot>   "ruuuun length"
12:47:25 <Cale> @src (.)
12:47:26 <lambdabot> (f . g) x = f (g x)
12:47:34 <hatds> I think what you are asking for is to be directed towards a list of prelude functions and their definitions
12:47:47 <andouille> ok, but where can I learn to use map, replicate or other things lique that (pre-built functions ?) ?
12:47:49 <Cale> andouille: (.) takes two functions f and g and makes a function which when applied to x gives f (g x)
12:48:03 <andouille> hatds, exactly ;)
12:48:12 <cob_jonas> dunno, some book?
12:48:12 <Cale> andouille: $ takes a function and a value to apply it to, and applies the function
12:48:17 <Cale> @src ($)
12:48:18 <lambdabot> f $ x = f x
12:48:18 <hatds> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:48:22 <Baughn> andouille: I don't recall ever reading such a tutorial; you learn by using them
12:48:34 <Baughn> andouille: Start by walking through all the prelude functions. :)
12:48:39 <Cale> This seems pointless, but the main purpose of it is that $ has really low precedence
12:48:54 <Baughn> > map ($ 3) [(+1),(*2)] -- Also this
12:48:56 <lambdabot>   [4,6]
12:49:04 <Cale> So it's as if you've wrapped both sides in parens
12:49:20 <andouille> ok
12:49:28 <andouille> thank you very much
12:49:37 <cob_jonas> (and then all functions of Data.List and Control.Monad and Data.Maybe, most importantly foldr and foldl')
12:51:59 <cob_jonas> but another method to learn all the funny function is to hang around here and listen and ask questions and sooner or later you'll meet the more useful functions
12:52:06 <cob_jonas> at least I found that works
12:52:10 <Cale> He quit for some reason
12:52:36 <cob_jonas> yeah, I see
12:52:39 <cob_jonas> still
12:53:49 <cob_jonas> I found that works
12:54:04 <cob_jonas> I mean how'd I guess which of the lots of functions to look at?
12:54:16 <cob_jonas> if I see them here in use I can pick the useful modules and functions
12:54:43 <cob_jonas> @type liftM2
12:54:45 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:54:46 <cob_jonas> @type liftA2
12:54:47 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:57:51 <kniu> Do full record types make positionally-accessed types obsolete?
12:59:00 <cob_jonas> kniu: what positionally accessed types?
12:59:03 <Twey> kniu: They should do, for flexibility
12:59:28 <Twey> A record type is usually a big type whose members are likely to change during the course of development
12:59:54 <Twey> Accessing it solely via record syntax and the provided getters allows that to be done without it becoming a problem
13:00:04 <Twey> Accessing it positionally would break that
13:00:14 <kniu> k
13:03:48 <Baughn> "isHNF :: a -> IO Bool" <-- Oh yeah, there we go.
13:04:27 <pumpkin> does it actually work right? Cale tried that code we found on the mailing list last night and it didn't look too correct
13:04:46 <Cale> What?
13:04:48 <Baughn> ..well, I'm about to find out.
13:05:04 <Cale> I found an isWHNF on the mailing list, but it was totally broken.
13:05:11 <pumpkin> yeah :)
13:05:44 <Cale> Also, it still had the problem that error "foo" has the same ClosureType as 5
13:06:28 <Baughn> Even after rwhnf'ing 5?
13:07:02 <pumpkin> does that do anything?
13:07:09 <Cale> yeah.
13:07:23 <pumpkin> what type does it give 5?
13:07:24 <Cale> Or making it monomorphic.
13:07:26 <Cale> AP
13:08:09 <Cale> oh...
13:08:32 <Cale> *Main Control.Parallel.Strategies> let x = 5 :: Integer in rwhnf x `seq` getClosureType x
13:08:32 <Cale> Indirection 28
13:08:46 <Cale> But the code which they had for handling indirections is broken.
13:09:53 <Baughn> So I'll have to fix that, I guess
13:11:07 <hackagebot> hack-middleware-jsonp 0.0.0
13:12:37 <Cale> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5284#a5284
13:14:23 <Baughn> Cale: An AP's a thunk type, though
13:14:42 <Baughn> Cale: It may have been rwhnf'd, but it.. isn't in HNF
13:15:07 <Cale> It's because x is polymorphic
13:15:26 <Cale> But somehow it doesn't show up as Fun like I'd expect.
13:18:04 <Cale> (It ought to be a function of the typeclass dictionary, shouldn't it?
13:18:06 <Cale> )
13:18:17 <Cale> Oh, I see.
13:18:31 <Cale> Those are two separate x's.
13:19:42 <Cale> So it's like  rwhnf (x instanceNumInteger) `seq` getClosureType (x instanceNumInteger)
13:19:46 <Cale> It doesn't help :)
13:19:56 <Cale> *Main Control.Parallel.Strategies> let x = 5; y = x :: Integer in rwhnf y `seq` getClosureType y
13:19:56 <Cale> Indirection 28
13:20:01 <Cale> That works though.
13:20:31 <Cale> *Main Control.Parallel.Strategies> let x = 5; y = x :: Integer in y `seq` getClosureType y
13:20:31 <Cale> Constr
13:20:33 <Cale> and that
13:21:14 <hackagebot> hack-middleware-cleanpath 0.0.0
13:21:21 <Cale> Now, if only we could see past the indirections...
13:22:06 <Cale> Baughn: oh, another strange and unexpected one:
13:22:08 <Cale> *Main Control.Parallel.Strategies> getClosureType "a"
13:22:08 <Cale> Constr
13:22:08 <Cale> *Main Control.Parallel.Strategies> getClosureType "ab"
13:22:08 <Cale> AP
13:22:24 <Cale> *Main Control.Parallel.Strategies> getClosureType ('a':'b':[])
13:22:24 <Cale> Constr
13:22:33 <pumpkin> why are those different?
13:23:04 <Cale> I have no idea. I thought it might have something to do with the polymorphic strings extension.
13:23:14 <Cale> But "a" is still in string syntax.
13:23:36 <Cale> So if it really was that extension, it should be AP too.
13:23:39 <pumpkin> yeah
13:23:50 <Cale> (because it'd be fromString "a" or whatever)
13:23:58 <pumpkin> you could try running it all under XOverloadedStrings ?
13:24:19 <Cale> same results
13:29:41 <Jedai> There is all this optimisation stuff with unpackCString and so on
13:30:13 <Jedai> It could be what's causing the difference between those case
13:30:25 <pumpkin> I thought that was only when you actually compile things
13:30:56 <Jedai> pumpkin: I must admit that I'm not too sure of wether that's the case or not
13:31:29 <Jedai> It was just an hypothesis to try and explain this weird result
13:34:18 <Baughn> ..oh dear, got to use an unsafeCoerce here
13:34:51 <Baughn> @index unsafeCoerce
13:34:52 <lambdabot> bzzt
13:35:01 <Botje> System.Unsafe, i guess?
13:35:07 <Baughn> Unsafe.Coerce, actually
13:35:13 <Botje> oh. boo :)
13:37:07 <pumpkin> nothing more fun than unsafeCoerce
13:37:10 <pumpkin> except unsafeCoerce#
13:37:39 <pumpkin> actually, probably a lot of things more fun than that :P
13:38:21 <pumpkin> bbl :)
13:38:56 <Peaker> @type System.Unsafe.Coerce.unsafeCoerce
13:38:57 <lambdabot> Couldn't find qualified module.
13:39:00 <Peaker> @type Unsafe.Coerce.unsafeCoerce
13:39:02 <lambdabot> forall a b. a -> b
13:39:13 <Peaker> System.Unsafe vs Unsafe?  Hmm
13:44:28 <Cale> Baughn: I tried using unsafeCoerce for following the indirections, but wasn't able to get anything but a segfault. However, I have no idea what I'm doing :)
13:46:07 <Baughn> Cale: Hm. Well, basically HValue is a wrapper for.. any lifted type
13:46:15 <Baughn> I got it working. :D
13:46:23 <Cale> Oh, interesting.
13:46:42 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5285#a5285
13:47:08 <duaneb> man
13:47:15 <duaneb> ocaml is so unfunctional
13:47:16 <duaneb> :P
13:47:22 <duaneb> it's kind of painful to read ocaml code
13:47:30 <duaneb> it's like a really ugly c
13:47:30 <Cale> Oh, heh, I see what I did wrong. :)
13:47:48 <Baughn> Cale: That would be?
13:48:19 <Cale> Getting the parameters in the wrong order and not being warned by the typechecker because one was unsafeCoerced and the other polymorphic :)
13:48:19 <arcatan> no, ocaml is like better C
13:48:27 <Baughn> Cale: Eheh. ^^;
13:48:33 <duaneb> arcatan: how so?
13:48:33 <lament> better, uglier C?
13:48:51 <duaneb> it seems like a less-f'd up C++
13:48:59 <duaneb> but with boxed types
13:49:22 <duaneb> and an option for tail recursion :P
13:50:10 <Cale> Baughn: Should there be any difference between unsafeCoerce and unsafeCoerce# here?
13:50:40 <Baughn> Cale: No, they're equal
13:51:15 <Cale> *Main Control.Parallel.Strategies> let x = 5 :: Integer in rwhnf x `seq` getClosureType x
13:51:15 <Cale> Indirection 28
13:51:15 <Cale> *Main Control.Parallel.Strategies> let x = 5 :: Integer in rwhnf x `seq` removingIndirections getClosureType x
13:51:15 <Cale> AP
13:51:21 <Cale> hmm
13:53:01 * Cale suddenly wishes that GHC preserved expressions somehow. :)
13:54:21 <Cale> Baughn: Shouldn't it still be isWHNF? You're actually not looking underneath functions...
13:54:46 <Baughn> Cale: Near as I can tell, HNF is a subset of WHNF, and this function is only complete for HNF
13:54:50 <Baughn> ..well, not even that, really
13:55:01 <Baughn> But I'm not very sure of the terminology. :/
13:55:12 <Cale> I get PAP for (\x -> x+1) which is in HNF
13:55:34 <Cale> and your function will produce False for that...
13:55:51 <Cale> (it's also in WHNF)
13:56:09 <Baughn> True. I'm not sure whether producing True for PAP is /safe/ or not, since I'm not sure what PAP really is.
13:56:23 <Baughn> In this case, bogus False is safe; bogus True isn't
13:56:26 <Cale> yeah, it would be good to figure that out... :)
13:56:48 <Cale> I wonder where all these types are really documented...
13:58:40 <Cale> "Entry Code for an AP (a PAP with arity zero)."
13:58:57 <Baughn> I see
13:59:10 <Baughn> So.. (\x -> error "foo") would be PAP too
13:59:18 <Baughn> Well, certainly can't return True for that. :)
13:59:23 <Baughn> Hm. Actually, I could
13:59:27 <Baughn> ..
13:59:27 <Cale> That should be in WHNF
13:59:40 <Baughn> Right, evaluating a function succeeds, even if /calling/ the function would fail
13:59:44 <Baughn> So PAP => True is safe
13:59:57 <Baughn> AP, not so much
14:00:05 <Cale> right
14:00:29 <mib_xxfkjqs6> hey
14:00:37 <mib_xxfkjqs6> wondering if anone can help me
14:00:39 <Baughn> I didn't bother with defining a case for Blackhole, but have you seen anything that produces it?
14:00:56 <mib_xxfkjqs6> im trying to sort some data in haskell
14:00:59 <mib_xxfkjqs6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5286
14:01:18 <mib_xxfkjqs6> by fans has anyone got any ideas
14:01:25 <Cale> Baughn: It probably ought to be treated as not in WHNF
14:01:39 <Baughn> Cale: Yes, but if it's at all useful I might add a third return value
14:01:49 <Baughn> WHNF, Undecided and Bottom
14:02:06 <Cale> mib_xxfkjqs6: By number of fans?
14:02:12 <mib_xxfkjqs6> yea
14:02:39 <Cale> fanCount (Film t d y fs) = length fs
14:02:43 <mib_xxfkjqs6> was going to length the fan list
14:02:52 <Cale> and then, sortBy (comparing fanCount) films
14:03:03 <mib_xxfkjqs6> ah awesome
14:03:05 <Cale> But that's not terribly efficient.
14:03:06 <mib_xxfkjqs6> thanks
14:03:28 <mib_xxfkjqs6> ok
14:03:41 <Cale> another way is to map (\x -> (fanCount x, x)) over the list and then sortBy (comparing fst)
14:03:44 <mib_xxfkjqs6> is there a better way that i could look into
14:03:53 <Baughn> @tell conal http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5289#a5290 <-- Here's the latest version of Unamb, with WHNF-detection. It appears to work, but YMMV.
14:03:54 <lambdabot> Consider it noted.
14:04:09 <Cale> map snd . sortBy (comparing fst) $ [(fancount x, x) | x <- films]
14:04:33 <Cale> That way, you only compute the number of fans once per film.
14:04:44 <Cale> Rather than every time two are compared.
14:05:59 <Baughn> Cale: Thanks for your help. This will either blow up spectacularily, or improve performance dramatically. :
14:06:02 <Baughn> :)
14:06:05 <Cale> hehe
14:06:32 <Cale> Baughn: I wonder if this is at all related to any of the bugs that I added to the reactive trac
14:06:46 <mib_xxfkjqs6> thanks cale
14:08:05 <Baughn> Cale: It probably is. The currently-on-hackage Unamb is fundamentally broken.
14:08:11 <Baughn> Cale: You should try mine, though perhaps without isHNF.
14:08:20 <Baughn> @tell conal Oh, and I updated the comments.
14:08:21 <lambdabot> Consider it noted.
14:11:17 <skorpan> how do you pronounce <*>?  "sequence?"
14:11:39 <Baughn> "ap"
14:11:44 <Peaker> @hoogle --info discriminate
14:11:45 <lambdabot> Parse error:
14:11:45 <lambdabot>   --count=20 "--info discriminate"
14:11:45 <lambdabot>              ^
14:11:51 <Peaker> @hoogle discriminate --info
14:11:51 <lambdabot> No results found
14:12:02 <Peaker> oh, silly me
14:12:03 <Baughn> @hoogle discriminate
14:12:03 <lambdabot> No results found
14:12:11 <Baughn> Peaker: ..but what are you checking that for?
14:12:16 <Peaker> @hoogle tipe --info
14:12:16 <lambdabot> No results found
14:12:20 <Peaker> Baughn: trying to read your paste
14:12:32 <Peaker> discriminate is right there, I missed it
14:13:30 <Peaker> Baughn: what about blocking in the do block of unsafePerformIO? What if you get an early exception?
14:14:01 <Baughn> Peaker: THen it'll simply get restarted automatically.
14:14:35 <Baughn> Peaker: You only need to worry about exceptions in unsafePerformIO if you do any exception handling. Otherwise it's totally transparent.
14:14:43 <Peaker> unsafePerformIO just loops around execution of the IO until it stops throwing exceptions?
14:15:04 <Baughn> Actually, it /pauses/ the execution if the thread throws an exception (or receives one)
14:15:09 <Baughn> Then it restarts it from where it stopped
14:15:27 <Baughn> I'm not sure I want to think too much about how that is implemented, but it's semantically correct.
14:15:44 <Baughn> I only need to worry about it because I use an exception handler to kill some threads if that happens, and I need to restart them.
14:15:58 <Peaker> Baughn: in what sense it is paused if it is then resumed immediately?
14:16:06 <Baughn> Peaker: It isn't resumed immediately
14:16:14 <Baughn> Peaker: let a = unsafePerformIO something
14:16:28 <Baughn> Peaker: If you evaluate a and, while that happens, throw/receive an exception, the evaluation is paused
14:16:39 <Peaker> until what?
14:16:39 <Baughn> But /your thread is killed/, or at least thrown back out to some higher level
14:16:53 <Baughn> It restarts once some thread - any thread - starts evaluating a again
14:17:03 <Peaker> the whole *thread* that happened to use the thunk with the unsafePerformIO is killed?
14:17:03 <Baughn> Well. Unpauses.
14:17:27 <Peaker> does unsafePerformIO start a new thread for the action?
14:17:35 <Baughn> Peaker: Whatever would normally happen for an exception happens. If there are no exception handlers, then sure.
14:17:38 <Baughn> And no.
14:17:40 <Cale> skorpan: yeah, <*> is equivalent to Control.Monad.ap, so that's how I'd normally pronounce it too
14:17:51 <skorpan> okay
14:17:52 <Cale> (apart from having a more general type)
14:18:09 <Baughn> Peaker: If you don't touch exceptions inside your unsafePerformIO code (except perhaps to throw one)..
14:18:12 <skorpan> can you use constructors infix?  e.g.  1 `Hello` 3, where Hello :: Int -> Int -> Hello
14:18:16 <Baughn> Peaker: ..then it works the same way as a throw from pure code.
14:18:17 <Cale> yes
14:18:25 <skorpan> thanks
14:18:33 <Baughn> Peaker: You *can't immediately resume the evaluation*, since an exception *handler* has to be in IO
14:18:36 <Peaker> Baughn: oh, so thread A uses unsafePerformIO on an action -- it raises, thread A gets a bottom, but Haskell remembers that internal action's state.  Another guy tries to use the thunk, it continues execution of that remembered action in the context of a new thread?
14:18:41 <Cale> Apart from pattern matching, constructors are normal functions and work exactly the same as them in every way.
14:18:46 <Baughn> Peaker: Yes
14:19:13 <Baughn> Peaker: One gotcha here is that if the exception is /from/ the unsafePerformIO (eg. throwIO (or throw)), then that continuation will just re-throw the exception. :P
14:19:14 <Cale> Well, I suppose there's record syntax too...
14:19:24 <Peaker> Baughn: so this is a pretty special thing, as IO actions can migrate between threads (the only place it ever happens?)
14:19:27 <Cale> (but that's unsurprising :)
14:19:32 <hackagebot> buster 2.2
14:19:43 <Baughn> Peaker: Yes
14:19:44 <Cale> hackagebot! You should give a link!
14:19:51 <Peaker> Baughn: what a weird implementation
14:20:03 <Baughn> Peaker: So in my code I need to throw an exception, but only /once/, to the thread that it's currently executing in
14:20:09 <Baughn> Peaker: Thus the throwTo myId
14:20:22 <Peaker> Baughn: why doesn't it just restart the whole action in that case?
14:20:35 <Baughn> Peaker: To avoid lost work
14:20:55 <Baughn> Peaker: Exceptions are defined to never destroy in-progress evaluation, only pause them
14:21:02 <Peaker> oh, there's the issue that unsafePerformIO tries to guarantee the action will run just once
14:21:36 <Baughn> Peaker: Anyway. Once another thread resumes the unamb, the throwTo will be re-executed; *however*, the thread ID it gets is now dead, so nothing happens and the code continues from where it left off
14:21:40 <Peaker> I see the logic of this choice.. the action is run for someone who needs the value.. doesn't need it anymore?  pause until someone does
14:21:48 <Baughn> Right
14:22:23 <Cale> I wonder if you can rig it so that two consecutive calls to myThreadId return different things :)
14:22:27 <Baughn> It got a bit hacky for me, but only because I want to throw an exception /only once/
14:22:45 <Peaker> Baughn: I think this could probably be abstracted away more nicely by an unsafePerformIO wrapper?
14:22:59 <Baughn> Peaker: That's basically what retry is
14:23:25 <Baughn> It allows actions to be restarted instead of resumed
14:23:29 <Peaker> Baughn: make it its own function - it may be very useful on its own then
14:23:45 <Baughn> Peaker: Considering how much trouble figuring it out was, yeah, I bet.
14:23:52 <Baughn> Peaker: But I won't until I'm sure I know it works right.
14:24:08 <Cale> I wonder if unamb might have an easier time were it to be implemented as a GHC primop.
14:24:19 <Peaker> Baughn: btw, if you re-call (retry act) you might want to memoize the result of (retry act), e.g:  retry act = result where result = ... code
14:24:28 <Baughn> Cale: Given isHNF..? Oh yeah.
14:24:59 <Baughn> Peaker: No point. If I got the result, there would be no exception.
14:25:04 <duaneb> I need new coding music.
14:25:33 <Peaker> Baughn: is it ok that race assumes that f b does not throwIO?
14:26:06 <Peaker> Baughn: "result" would not be the result you got, it would just be the memoized action instead of rebinding it each time
14:26:12 <Peaker> Baughn: similarly to:
14:26:14 <Peaker> @src forever
14:26:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:26:17 <Baughn> Peaker: I don't see how race assumes that
14:26:29 <nimred> hello #haskell
14:26:30 <Peaker> forever act = loop where loop = act >> loop
14:26:47 <Peaker> Baughn: instead of: forever act = act >> forever act
14:27:20 <Baughn> Peaker: Please keep in mind that the restart is inside an exception handler. No exception, no restart.
14:27:34 <Baughn> If exception, no return value
14:27:53 <Cale> nimred: hello!
14:27:55 <nimred> i am trying to build X11 binding using cabal. so i read i need to run autoreconf first, but can you please tell me wich way ?
14:28:16 <Cale> nimred: What? autoreconf?
14:28:19 <Baughn> nimred: "cabal install X11" always worked for me
14:28:23 <Peaker> Baughn: you'll recall "catch" multiple times if you handle multiple exceptions to build the catching action, instead of just re-using the previous "catch" result
14:28:48 <Cale> Yeah, cabal install ought to work fine...
14:28:59 <Baughn> Peaker: I still don't see what result you're talking about
14:29:19 <nimred> Cale http://darcs.haskell.org/X11/README
14:29:19 <Baughn> By the time there /is/ a result anywhere, my job is already done and it's returning to whatever called unamb
14:29:40 <Cale> nimred: Oh, you're installing the darcs version rather than the one on Hackage?
14:30:00 <Peaker> Baughn: just give a name to "retry act" so the *IO action* is memoized, not any runtime result
14:30:17 <Cale> nimred: It appears to have the same version number as the one on hackage anyway...
14:30:38 <Baughn> Peaker: ..what would this buy me?
14:30:42 <nimred> Cale i am trying to install xmonad from hand on OpenBSD
14:31:18 <Cale> nimred: I would start by making sure that cabal-install is installed, as it will make solving dependency problems much simpler.
14:31:18 <nimred> OpenBSD package system doesn't include xmonad-contrib
14:31:35 <nimred> cabal-install ?
14:31:40 <Peaker> Baughn: "throwTo myid e >> retry act" here will re-compute (retry act) - i.e recall "catch"/etc.  If you just give it a name it will save a bit of runtime and perhaps memory (in case of repeated exceptions, maybe its even significant),  just a convention that I find useful in general to memoize my function with the args if I recurse to it with the same args
14:31:52 <Cale> yes, it's a tool for downloading and installing Haskell programs and libraries
14:32:00 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html is the list of packages available
14:32:16 <Baughn> Peaker: I find it hard to believe that will make any difference whatsoever. Keep in mind, GHC doesn't do partial evaluation.
14:32:17 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmonad
14:32:32 <Cale> If you have cabal-install, you should be able to type  cabal install xmonad  and be done.
14:32:33 <nimred> isn't it included in http://www.haskell.org/cabal/release/cabal-1.6.0.2/Cabal-1.6.0.2.tar.gz that i installed ?
14:32:45 <Cale> No, that's the Cabal library.
14:32:45 <Baughn> Peaker: (Even if it did, the cost of code generation here would enormously dwarf the cost of not generating code; the number of retry calls will usually be very small)
14:32:54 <nimred> Cale ah
14:32:59 <Peaker> Baughn: why is   forever act = act >> forever act   worse than    forever act = result where result = act >> result  ?
14:33:14 <Cale> nimred: Also, you shouldn't need to get that manually.
14:33:15 <tibbe> How can we emulate something like this http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5292#a5292 in Haskell?
14:33:19 <Cale> nimred: It comes with GHC anyway.
14:33:31 <tibbe> the use case is a web app that gets fed data incrementally
14:33:36 <Baughn> Peaker: It isn't. It's the same exact thing.
14:34:01 <nimred> Cale let me see
14:34:08 <Peaker> Baughn: Why is   fix f = f (fix f)    worse than   fix f = result where result = f result   ?
14:34:08 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz -- you can get the source for cabal-install here. Inside you'll find a bootstrap.sh which, supposing you're not missing libraries that come with GHC, should get you started.
14:34:37 <Peaker> Baughn: its different - because ghc memoizes stuff that has a name, but not function applications
14:34:57 <Baughn> Peaker: In /that/ case it's different
14:35:21 <mwc_> What's the story on why Parsec 3.0 isn't widely used yet? Some sort of horrible bug?
14:35:24 <Cale> nimred: I think by default it installs to ~/.cabal/bin. Normally, I make that into a link to ~/bin pre-emptively, but you could also just add it to your path.
14:35:56 <mwc_> or is it just that parsec 2.1 is the version shipped with ghc?
14:36:03 <Peaker> Baughn: Are you sure the forever case doesn't make a difference? I'm pretty sure Control.Monad.forever uses the seemingly pointless "where" clause
14:36:04 <Cale> (it's where binaries for cabal packages end up getting installed when you install as user)
14:36:16 <Cale> mwc_: I bet the latter.
14:36:37 <Baughn> Peaker: I'm sure it makes no difference for IO. Other monads, again, are different; it makes no difference in this case because IO is strict.
14:37:58 <nimred> Cale : i have ghc installed on my system but no cabal-install binary
14:38:02 <Peaker> Baughn: Ok, I don't know enough about the implementation details of IO bind, maybe you're right
14:38:12 <Cale> nimred: Right.
14:38:22 <Cale> nimred: So, get that tarball I linked to
14:38:27 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
14:38:43 <Cale> and inside you'll find bootstrap.sh which you should try running
14:38:55 <Baughn> Peaker: For another monad, forever can build up an arbitrarily long chain of applications (even infinite.. doh, I guess), which if would've blown the stack when evaluated
14:39:27 <ray> stacks only get "blown" in haskell, i've noticed
14:39:37 <Baughn> Peaker: For IO, evaluation is strict; I /sort/ of build a retry thunk, but it doesn't get nested; thunk A is being evaluated (running retry) before B (the recursive call) even gets started, and by the time B is constructed A can be GC'd
14:39:57 <Baughn> ray: As opposed to?
14:39:57 <nimred> Cale --> http://pastebin.com/m6fe3006a :/
14:40:13 <ray> overflown or whatever
14:40:34 <Peaker> Baughn: the nested thunks is not the only reason you want not to build them - its also unnecessary extra work
14:40:44 <Baughn> Peaker: Which is unnoticable
14:40:51 <Cale> nimred: Okay, your ghc is missing packages...
14:40:58 <ray> i like blown, it comes with the mental image of a stack bursting through an invisible sheet of plastic wrap, causing disaster
14:41:06 <Cale> nimred: Which normally come with ghc.
14:41:10 <byorgey> nimred: are you using ghc 6.6.1 ?
14:41:11 <Baughn> Peaker: Trust me, you won't notice something like five instructions between the two forkIO calls, the MVar stuff and the RTS closure inspections.
14:41:12 <Peaker> Baughn: anyhow, great work on unamb there, I think your discoveries should probably be put into a library meant to make unsafePerformIO more usable
14:41:28 <Peaker> Baughn: Maybe abstracted a bit more for generality, though
14:41:32 <nimred> Cale :
14:41:33 <nimred> $ pkg_info | grep ghc
14:41:34 <nimred> ghc-6.6.1p2         compiler for the functional language Haskell
14:41:36 <Baughn> Peaker: Once I'm sure it works. :)
14:41:48 <Cale> nimred: Oh, haha, that's like a few years old.
14:42:03 <Cale> nimred: I'll be surprised if you can get xmonad to compile with it :)
14:42:11 <ray> ghc 6.6.1 is 2 minor major versions old
14:42:16 <Peaker> Baughn: why is loop trying twice?
14:42:21 <byorgey> yeah, I'm not sure if we still support 6.6
14:42:23 <nimred> Cale --> http://openports.se/lang/ghc
14:42:25 <byorgey> xmonad, that is
14:42:30 <Baughn> Peaker: Two threads.
14:42:37 <Baughn> Peaker: It counts the number of running threads, basically
14:42:55 <Cale> Version 6.6.1 (released 26 April 2007)
14:43:33 <Peaker> Baughn: oh, I see, because you changed it to put in the MVar even if it fails
14:43:49 <nimred> Cale : what version would i need ?
14:43:54 <arjanb> what is a practical way to debug a loop in a big knot tying piece of code?
14:44:16 <byorgey> nimred: 6.8 should be fine, but as long as you're upgrading might as well get the latest release, 6.10.3
14:44:17 <Baughn> arjanb: Hum. I think i could invent one.
14:44:18 <ray> does openbsd still hate haskell?
14:44:18 <Twey> Unravel it into nice simple code :-P
14:44:22 <Baughn> arjanb: It would be useful
14:44:27 <byorgey> nimred: you can get it here: http://haskell.org/ghc/
14:44:33 <byorgey> should be a binary package that will work
14:44:42 <Cale> byorgey: But he's on OpenBSD, will it really?
14:44:46 <nimred> Cale : ok but wich way to install ?
14:45:14 <byorgey> hmm, the ghc page says the OpenBSD package is maintained by dons.
14:45:26 <Baughn> arjanb: Anyway, vacuum. I don't know if it already does this, but it'd be possible to have it survive meeting bottom and show those as well
14:45:28 <Cale> dons!!
14:45:29 <Cale> hehe
14:45:40 <byorgey> nimred: check this page: http://haskell.org/ghc/distribution_packages.html#netbsd
14:45:55 <byorgey> it says 'GHC is in the OpenBSG ports tree as lang/ghc'
14:46:02 <byorgey> is that the same thing you had before?
14:46:22 * byorgey knows nothing about OpenBSD
14:46:40 <Baughn> , vacuum [2,3,undefined]
14:46:43 <ray> they appear to hate haskell
14:46:44 <lunabot>  luna: Prelude.undefined
14:46:54 <Baughn> arjanb: ..yep, will take a little work
14:46:58 <nimred> Cale : i know that see http://pkgsrc.se/search.php?so=ghc
14:47:04 <arjanb> Baughn: nice idea but will it survive the stackoverflow?
14:47:08 <Baughn> mmorrow: How do you feel about fixing up vacuum to show (some) bottoms?
14:47:08 <copumpkin> Baughn: is your isWHNF for vacuum?
14:47:11 <Botje> ray: they should, it makes their "secure C code" look pathetic :o)
14:47:19 <byorgey> nimred: ah, that looks better
14:47:20 <Baughn> copumpkin: No, unamb
14:47:21 <Cale> nimred: Did you really mean to address that to me?
14:47:22 <copumpkin> ah
14:47:41 <copumpkin> vacuum should never evaluate anything unless it's already been evaluated!
14:47:43 <Baughn> copumpkin: Vacuum doesn't need it. :)
14:47:56 <Baughn> copumpkin: ..ooh, good idea
14:48:08 <byorgey> nimred: the lang/ghc one (6.8.3) should be fine
14:48:21 <Baughn> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5289#a5290 <-- Oh, and here's some code you may find useful to make vacuum /not/ follow thunks. :D
14:48:23 <nimred> ok see you in a moment i switch to NetBSD
14:48:33 <Cale> nimred: ...
14:48:35 <copumpkin> who'da thunk it?
14:48:49 <Baughn> copumpkin: ..you die. Slowly, painfully, and with flowers.
14:49:21 <copumpkin> lol
14:49:25 <Cale> ah, it is netbsd
14:49:27 <Cale> hehe
14:49:35 <ray> i'm a lazy thunk, and nobody ever evaluates me
14:49:37 * copumpkin feels the love
14:50:32 <Cale> nimred: if we can get dons here, he'd probably know, though I think he's using ArchLinux these days.
14:51:08 <mmorrow> Baughn: i just removed the ghc pkg dep from vacuum, and improved a few other things. no 30MB binaries!! :)
14:51:22 <copumpkin> nice
14:51:36 <copumpkin> mmorrow: is what I said above possible?
14:51:37 <mmorrow> Baughn: (and its getClosureType is s.t. you can use it for your isWHNF now)
14:51:46 <mmorrow> um, /me looks
14:51:48 <Cale> http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html -- this hasn't been updated since 2005... ;
14:51:49 <copumpkin> to not evaluate anything unless it's already been evaluated
14:51:59 <copumpkin> zomg kana smiley
14:52:03 <Baughn> mmorrow: Well, if you can duplicate the indirection, that's nice. :)
14:52:06 <mmorrow> copumpkin: yes, i found out why things were segfaulting
14:52:12 <copumpkin> nice!
14:52:35 <mmorrow> i'm gonna add a vacuumNoForce (can you think of a better name?)
14:52:45 <Baughn> vacuumNoEvaluate?
14:52:46 <copumpkin> featherPaw
14:52:50 <mmorrow> the only thing with that though is that you'll always have to run it like:
14:52:53 <copumpkin> stealthyLikeACar
14:52:55 <copumpkin> *Cat
14:52:58 <mmorrow> a `seq` vacuumNoForce
14:52:59 <Baughn> gentleSucktion
14:53:04 <guenni> does anybody know where I can find the docs for parsec 3.0?
14:53:07 <mmorrow> or you'll always just get a single node AP
14:53:08 <arjanb> lazyVacuum
14:53:17 <Baughn> mmorrow: Well, can't you move that seq inside the vacuum?
14:53:25 <copumpkin> mmorrow: gentleVacuum?
14:53:27 <guenni> mmorrow:  hi
14:53:31 <mmorrow> Baughn: hmm, good point
14:53:36 <mmorrow> guenni: hi
14:54:20 <copumpkin> alright bbiab :)
14:54:39 <byorgey> guenni: on hackage?
14:54:45 <byorgey> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
14:54:57 <guenni> byorgey: whereever
14:55:36 <guenni> sry I should have said "user manual"
14:55:43 <Cale> Huh, there are a lot of people on various mailing lists reporting struggle in terms of getting recent releases of GHC on OpenBSD.
14:55:57 <mmorrow> Baughn: hmm, i'll have to think about doing what's in that paste by default. that's an interesting idea though
14:56:05 <byorgey> guenni: I don't think there is such a thing.  The Haddock documentation looks detailed, though.
14:56:32 <guenni> byorgey: thx
14:56:32 <Baughn> mmorrow: Well, by 6.12 the size shouldn't be a problem anymore
14:56:42 <mmorrow> Baughn: (i think indirs will only ever show up if things aren't being forced)
14:57:05 <Baughn> mmorrow: ..yes, but that's the general idea, so...
14:57:11 <mmorrow> cool :)
14:57:56 <mmorrow> Baughn: (in fact, that's basically exactly how vacuum works, it just keeps doing that to get all reachables)
14:58:18 <Baughn> Indirections show up a /lot/, due to the GC
14:59:52 <cads> hey, I've got a representation of a vector space, and I want to test it for consistency
15:00:33 <Cale> QuickCheck properties for the vector space axioms? :)
15:00:42 <nimred> Cale ah. to tell the truth i didn't search for on google :/
15:01:07 <cads> cale, that's essentially what I did
15:01:27 <cads> I run random vectors through the axiom properties :)
15:01:30 <Cale> nimred: I haven't found a solution, except that it might be possible to work your way up from 6.6.1 by building it from source...
15:01:45 <cads> it checks out perfectly for integers and rationals
15:01:47 <mmorrow> Baughn: yes, vacuum catches the exception thrown by `undefined', then vacuums that! :)
15:02:03 <Cale> nimred: Would probably be a good idea to contribute a binary package if you got it working.
15:02:24 <Baughn> , vacuum undefined
15:02:25 <mmorrow> Baughn: http://moonpatio.com/vacuum/gallery/undefined.png
15:02:26 <lunabot>  luna: Prelude.undefined
15:02:29 <mmorrow> not lunabot's
15:02:33 <Cale> cads: Right, for floating point, you'll probably find lots of problems :)
15:02:34 <Baughn> Ah
15:02:49 <nimred> let's me try first on NetBSD with 6.8.3...
15:02:53 <mmorrow> (lunabot's is from before the vacuum pkg actually, version -1)
15:03:08 <Cale> nimred: Ah, if that's a realistic option, then it might work out for you :)
15:03:31 <Cale> nimred: If you're switching operating systems altogether though, linux is much more convenient :P
15:03:32 <mmorrow> (that list of chars you see in the image is "Prelude: unde..."
15:03:51 <cads> Cale: you have an idea how I could write tests that would show that the floats are doing as well as they can in representing the vectors?
15:04:12 <guenni> btw: is parsec still *the* recommended parsing library?
15:04:49 <cads> I could use equality within a thresh-hold to show that the floats aren't off like crazy
15:05:11 <cads> in fact, I think I'll find out what the error really is, I bet it's tiny
15:05:24 <nimred> Cale well i will try on linux if i can't get it working on NetBSD neither...
15:05:26 <Botje> is the Data instance for Data.Set broken?
15:06:56 <mmorrow> Botje: it's crippled "to preserve abstraction" :(
15:07:38 <Botje> mmorrow: uh oh. is this documented somewhere?
15:07:51 <Cale> cads: I wonder... you could certainly write tests which said that the relative error was less than some bound or something.
15:08:01 <cads> cale, I think I need to look up a little numerical analysis, I bet it's still possible to write theorems about floats, just with a little extra detail
15:08:07 <mmorrow> Botje: in the comment above the instance decl in the Data.{[Int]Map,[Int]Set} src
15:08:14 <cads> maybe a lot of extra detail, heh
15:08:40 <Cale> cads: Yeah, I don't really know a lot about numerical analysis of that sort apart from the basic "Floating point arithmetic satisfies little other than commutativity"
15:08:49 <mmorrow> -- This instance preserves data abstraction at the cost of inefficiency.
15:08:50 <mmorrow> -- We omit reflection services for the sake of data abstraction
15:09:01 <cads> heh, it's commutative?
15:09:16 <Botje> well, it kind of breaks uniplate for Sets :)
15:09:33 <Cale> Yeah, not that it means much in the face of the fact that it's not associative.
15:09:54 <mmorrow> Botje: looks like you need to create a personal Data.Set fork :)
15:10:05 <Botje> i'll .. consider it :p
15:10:10 <Botje> thanks for the info!
15:10:13 <mmorrow> np
15:10:44 <cads> floating points are a little disturbing like that
15:11:36 <Cale> Also, equality testing for NaN is stupid :)
15:11:48 <Cale> > let x = 0/0 in x == x
15:11:50 <lambdabot>   False
15:12:29 <cads> my tests would have to be truncated to some digit threshold if I was using computable reals  :/
15:12:30 <mmorrow> what should it do?
15:12:37 <mmorrow> NaB(ool)?
15:12:57 <Cale> Well, you'd normally want == to at least be an equivalence relation
15:13:01 <cads> > let x = 1/0 in x == x
15:13:03 <lambdabot>   True
15:13:11 <Cale> x == x should be unconditionally true
15:13:12 <mmorrow> ohhhh
15:13:18 <cads> that's funky
15:13:21 <mmorrow> i just realized that's what you did
15:13:36 <mmorrow> yeah, that is annoying
15:14:09 <Cale> It's arguable that since NaN represents a failure anyway then all its comparisons should fail, but then we have:
15:14:12 <Cale> > let x = 0/0 in x /= x
15:14:14 <lambdabot>   True
15:14:43 <davidL> is there an algorithm to convert a turing machine to a pushdown automata?
15:14:49 <Cale> davidL: No.
15:14:53 <mmorrow> , let a .==. b = if (isNaN a && isNaN b) || a == b then True else False in let x = 0/0 in x .==. x
15:14:54 <lunabot>  True
15:15:03 <Cale> davidL: Because PDAs can only recognise context free languages.
15:15:09 <xian> Hi, I'm having a stupid question: I have a function f x y and I partially apply it by supplying a value for x. There's a let-binding z inside f depending only on x. I want z evaluated when g = f x is called so that it isn't evaluated every time I call g y.
15:15:21 <mmorrow> yeah, the NaN equality thing could be argued both ways i guess
15:15:24 <davidL> Cale: errr, rather, a TM that is known to be context-free
15:16:05 <cads> mmorrow: is nan also supposed to be a kind of "bottom" value as well?
15:16:10 <Cale> davidL: That's a more interesting question. I have no idea. I suspect you might be able to use the *proof* that it's context free to generate a PDA.
15:16:44 <Cale> xian: It probably ought to already
15:16:48 <mmorrow> you mean in the sense that it takes everything else with it?
15:16:55 <Cale> xian: But if not, then you can force the matter with something like...
15:16:57 <mmorrow> , (0/0) * 1
15:16:58 <lunabot>  NaN
15:17:02 <mmorrow> etc
15:17:02 <mmorrow> ?
15:17:04 <Cale> f x = let .... in \y -> ...
15:17:07 <davidL> Cale: how would you go about proving that the problem of deciding whether a turing machine is context-free is undecidable? (without appealing to rice's theorem)
15:17:26 <xian> Cale: Yes, that's what I did (and it works), but I find it somewhat inelegant.
15:17:49 <mmorrow> cads: i guess in a sense, but i'd hesitate to say in the same sense as `undefined'
15:17:51 <Cale> xian: I think probably compiling with optimisations will do something similar.
15:18:06 <cads> no, in the sense that it denotes a computation that's failed (which it does)
15:18:29 <cads> but it doesn't cover computations that just wouldn't terminate
15:18:55 <mmorrow> cads: if you can ever get NaN by over/underflow then i agree
15:19:07 <mmorrow> (i'm not sure off the top of my head)
15:19:25 <mmorrow> ie is (0/0) the only way to get NaN?
15:19:35 <mmorrow> (excluding using NaN in a computation of course)
15:19:42 * RayNbow finally found some use for his gmail account: receiving and sorting mailing list messages... ^_^
15:19:43 <cads> sqrt(-1) usually gives nan
15:19:52 <mmorrow> ah, true
15:19:55 <RayNbow> (but damn, Haskell-Cafe is way too active :p)
15:20:28 <mmorrow> cads: i guess i'd say s/error/you tried to map to a number not in R/
15:20:36 <mmorrow> (other than infinity)
15:20:51 <Cale> RayNbow: I'm starting to consider auto-archiving all of those...
15:21:05 <Cale> RayNbow: I've missed normal mail because my inbox fills too quickly.
15:21:15 <RayNbow> Cale: yeah
15:21:18 <Traveler8> WHATS UP
15:21:36 <RayNbow> I recently found a page that showed how to setup filters/labels for mailing lists
15:21:47 <Traveler8>  AWSOME
15:21:55 <Traveler8> WHERE
15:21:59 <nimred> Cale must bootstrp.sh be run as root ?
15:22:15 <Cale> nimred: I don't think so.
15:22:15 <Traveler8> FUCK U MAN U SHIT
15:22:23 --- mode: ChanServ set +o Cale
15:22:26 <mwc_> if you mean bootstrap.sh to set up cabal install, then no
15:22:33 --- mode: Cale set +b *!*@96.234.239.219
15:22:33 --- kick: Traveler8 was kicked by Cale (Cale)
15:22:35 <mwc_> and I would further advise you NOT to run it as root
15:22:37 --- mode: Cale set -o Cale
15:22:42 <RayNbow> Cale: and there's a greasemonkey script so you can have a tree view of your labels in gmail
15:23:23 <RayNbow> (called Folders4Gmail)
15:23:36 <nimred> mwc i get permission pb
15:24:32 <Cale> nimred: hmm, it should be trying to install everything as user, but which GHC do you have?
15:24:58 <nimred> Cale you ask me if i have GHC ?
15:25:22 <nimred> yes i have :
15:25:22 <nimred> vohfi% pkg_info | grep ghc
15:25:23 <nimred> ghc-6.8.3           Compiler for the functional language Haskell
15:26:04 <Cale> nimred: The bootstrap.sh script does explicitly request to install the packages as user. What permission issue are you getting?
15:26:42 <mmorrow> Baughn: removing indirections is going to be needed for vacuumLazy
15:26:44 <Cale> davidL: Hmm, I'm not sure.
15:27:00 <Baughn> mmorrow: Right. I think I've got the right code for that, so use mine
15:27:04 <mwc> Does 6.8.x's ghc-pkg honor --user? I can't remember
15:27:22 <mmorrow> Baughn: making sure you not to duplicate nodes is going to be more .. interesting too
15:27:26 <nimred> Cale while compiling zlib :
15:27:27 <Cale> davidL: It seems to me that there might be a way to use the halting problem...
15:27:43 <Baughn> mmorrow: Well.. block GCs, use reallyUnsafePointerEquality?
15:27:45 <Cale> mwc: I think so. It just wasn't the default then.
15:27:50 <nimred> Error during cabal-install bootstrap:
15:27:54 <nimred> Building the zlib package failed
15:28:02 <nimred> oups
15:28:18 <Cale> nimred: Do you have the headers etc. for the C zlib library installed?
15:28:22 <nimred> sorry
15:28:24 <RayNbow> Cale, http://xs539.xs.to/xs539/09222/gmail-mailinglists838.png :)
15:28:26 <mmorrow> Baughn: vacuum already does essentially that, so it'd just be a matter of not adding indirection nodes to the graph, and then following their children
15:28:35 <Cale> RayNbow: cool
15:28:41 <nimred> it in fact is : "ld: cannot find -lgmp"
15:28:47 <Cale> nimred: aha
15:28:49 <mmorrow> (and inserting the children as if they were the indirection node)
15:28:59 <Baughn> mmorrow: Hang on, it does that /now/?
15:29:11 <nimred> Cale :P
15:29:13 <Cale> nimred: That's a bit surprising, as it's a dependency for GHC too.
15:29:14 <Baughn> mmorrow: What happens if evaluating some structure takes lots of memoery?
15:29:15 <mmorrow> Baughn: no, now it adds nodes regardless of closure type
15:29:31 <xian> Cale: I can't seem to figure out what optimization flag might be responsible for the kind of optimization you mentioned above. Do you know which one I may have to turn on?
15:29:31 <Cale> nimred: But anyway, you should install libgmp and its development files.
15:29:45 <mmorrow> Baughn: it sucks up the entirety of the structure now
15:29:46 <Cale> xian: Does -O2 work?
15:29:52 <nimred> libgmp ?
15:29:58 <Cale> xian: If not, then I suppose there's no cure but to write it that way.
15:30:07 <Baughn> mmorrow: I mean, if you block GCs.. some evaluations end up with a small structure, but use lots of memory to construct it
15:30:10 <Cale> nimred: It's used for the Integer type.
15:30:22 <Cale> nimred: It's an arbitrary precision arithmetic library.
15:30:30 <Baughn> mmorrow: I'd think it'd be safer to first walk the tree with GC /on/, and then redo it to construct your graph, only then turning it off
15:30:31 <mmorrow> Baughn: (there was a mysterious segfault that'd occur if everything wasn't forced which i just found the reason behind last week or so)
15:30:50 <nimred> Cale ok thanks for your help
15:30:57 <nimred> i am compiling gmp
15:31:28 <nimred> looks like it will take some time...
15:31:47 <xian> Cale: Okay, I see. Then I'll have to resort to writing that function in an awkward way. Thanks for your assistance.
15:32:04 <mmorrow> Baughn: i think it's going to be interesting figuring out how to best walk the graph without forcing :)
15:32:19 <Baughn> Have fun. :P
15:33:55 <nimred> Cale : ach doesn't work neither
15:34:00 <nimred> still getting the same message
15:34:38 <mmorrow> Baughn: (the reason for the segfault was that the bytecode assembler creates info tables that are specialized, and the reference to those infotabs only exist until that constructor is forced for the first time (globally). so the "fix" is check whether the # of ptrs/lits the infotable (gotten from a Storable instance) says there are is a sane number (bytecode assembler-constructed itables happen to claim to have somehting like 11172634  p
15:34:38 <mmorrow> trs and lits when viewed through the regular infotab storable instance))
15:35:34 <mmorrow> (by "specialized" i mean have a different layout completely)
15:35:35 <Baughn> mmorrow: ..I salute the utter horror of that solution. It is truly worthy of RTS hackery.
15:35:39 <mmorrow> err, not completely
15:35:46 <mmorrow> Baughn: heh
15:37:25 <Peaker> What are "bags"? Data structures that are mentioned in "Taste of Haskell"?
15:37:51 <Baughn> Multi-sets?
15:38:12 <Peaker> ah, like maps to element counts or histograms?
15:38:40 <Baughn> More like maps to lists of elements
15:38:57 <Baughn> I've seen a few different definitions of "bag", though.
15:39:08 <Cale> xian: You might also choose to use 'where' which should work just as well
15:39:13 <Cale> xian: like...
15:39:36 <Cale> xian: f x = g where <other constants>; g y = ...
15:39:41 <Baughn> Peaker: Sort of Map k [k], assuming that Eq is sometimes "mistaken"
15:39:47 <Baughn> Peaker: Or, rather, Ord
15:40:01 <Cale> xian: maybe a little prettier :)
15:40:30 <Cale> nimred: That message means that libgmp isn't found in your library path.
15:40:32 <Peaker> Baughn: ah
15:40:40 <Cale> nimred: So I don't know what to tell you.
15:40:46 <Baughn> Peaker: Otherwise you could use Map k Int, sure
15:41:04 <Baughn> Map k Natural?
15:41:05 <wli> I use Map k Integer
15:41:10 <Cale> I usually think of Map k Natural or Map k Integer
15:41:15 * Baughn tends to assume 64-bit for some reason
15:41:25 <Baughn> I'd probably use Map k Word64
15:41:31 <Cale> I hate the Int type and wish it would go away.
15:41:32 <Cale> hehe
15:41:44 <Cale> Stupid premature optimisation :)
15:42:40 <Baughn> Cale: "Don't prematurely optimize" is one thing
15:42:46 <Cale> Well, mostly the problem is all the Prelude functions which produce or require Int
15:43:01 <Baughn> Cale: I also like to follow "Don't bother *not* optimizing if the optimized version is no more code, no more complex, and is staggeringly obvious"
15:43:08 <Cale> Which means I have to explicitly stick fromIntegral in there or use the generic* things from Data.List
15:43:11 <RayNbow> hmm, Data.MultiSet uses type Occur = Int...
15:43:16 <Peaker> my friend is learning Haskell and just complained that he has to sprinkle fromIntegral everywhere because of Ints in the Prelude
15:43:25 <Cale> Baughn: I usually need/want Integer
15:43:32 <Baughn> RayNbow: Well, that's just wrong. You can very easily overflow it on a 32-bit system
15:43:51 <RayNbow> Baughn: don't tell me, tell twanvl :p
15:44:15 <Baughn> twanvl: You can very easily overflow a 32-bit Int. Don't use it for multiset occurences. Geez.
15:44:26 <Cale> and all the occurrences of Int mean that I can't rely on the fact that Integer is the default numeric type
15:44:42 <RayNbow> (but 32 bits ought to be enough for everyone :p)
15:44:46 * RayNbow hides
15:44:59 <FalconNL> I don't suppose there's an easier implementation for the function getModuleSource :: String -> IO String than downloading it off Hackage?
15:45:17 <Baughn> FalconNL: Nope
15:45:29 <Cale> FalconNL: That's about all you can do apart from checking if it's in the cabal cache.
15:45:33 <Baughn> There's no reason to think your system even has a copy of the source
15:45:45 <Baughn> *Faster* implementations, sure. Easier, no. ;)
15:46:11 <Cale> Even if it is in the cabal cache, you'll still have to unpack it.
15:46:16 <FalconNL> Figured as much. Out of curiosity, what would the faster implementation be?
15:46:33 <Baughn> FalconNL: Checking the cache.
15:46:38 <Cale> FalconNL: Checking if it's already in ~/.cabal/packages/hackage.haskell.org
15:47:12 <Cale> But even if it does happen to be there, it'll still be in a .tar.gz
15:47:36 <Cale> Maybe Cabal has a way to manage the cache...
15:47:59 <FalconNL> I'll stick with downloading for now. Now to figure out how to download a file with Haskell...
15:48:00 <Baughn> A .tar.gz is what you'd get from Hackage too
15:48:13 <Peaker> can one implement co-routines on top of callCC (ala stackless Python tasklets/etc)?   I want to demonstrate the power of monad transformers
15:48:30 <Baughn> FalconNL: I'd go with "cabal fetch"; then you /know/ it'll be in the cache.
15:49:16 <FalconNL> heh. Gotta love hackage. Searching for "download" reveals the package named download. That should do nicely :)
15:49:43 <Baughn> ..cabal fetch...
15:50:04 <Cale> Yeah, I agree, cabal fetch followed by looking in the cabal cache is a better idea.
15:50:26 <Philonous> FalconNL: download depends on linux' c-lib if I remember correctly
15:50:50 <Cale> HTTP would be the normal package to use for that...
15:50:59 <FalconNL> Philonous: yeah, I noticed. I'll try cabal fetch instead.
15:54:51 <nimred> Cale well i have to go to bed. see you tomorrow. thanks for your help :)
15:55:22 <altmattr> I have hit what I think is essentially the expression problem
15:55:23 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2501#a2501
15:55:34 <FalconNL> Hm. "cabal fetch base" results in "cabal: internal error: impossible".
15:55:35 <altmattr> I have written up a little example specific to my problem
15:55:47 <altmattr> can I get any suggestions for the best way thru?
15:56:40 <altmattr> I am sure just about everyone here has had the same problem
15:56:41 <altmattr> :)
15:59:37 <FalconNL> Does anyone know why base would not be cabal-fetchable?
16:00:04 <altmattr> FalconNL: fraid not, it sounds like cabal doesn't know either
16:00:04 <pumpkin> is it on hackage?
16:00:23 <FalconNL> pumpkin: yeah, it's the package that contains the Prelude
16:00:34 <pumpkin> well, I know the package contains that
16:00:37 <pumpkin> but I didn't know it was on hackage
16:00:44 <pumpkin> I mean, rts is a package too
16:00:46 <pumpkin> as is ghc
16:00:54 <pumpkin> but they're not "real"
16:01:12 <sjanssen> FalconNL: 'cabal install base' is intentionally disabled
16:02:13 <sjanssen> FalconNL: perhaps fetch was also disabled by mistake or conservative programming
16:02:18 <MyCatVerbs> sjanssen: ahahaha, that would break in so many fun ways. :3
16:02:29 <FalconNL> sjanssen: Wonderful. Guess it's back to downloading off Hackage, since the Prelude is one of the more important modules I need the source from.
16:02:47 <pumpkin> @hackage base
16:02:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/base
16:02:56 <pumpkin> ah, cool
16:03:04 <pumpkin> @hackage rts
16:03:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rts
16:05:41 <altmattr> All-right, how about a rephrased version?
16:05:42 <altmattr> What is best practice for adding a new field to an existing constructor without rewriting every function over that constructor (or at least minimising the pain)?
16:06:06 <pumpkin> use {}
16:06:39 <pumpkin> if you had case x of Constructor _ _ _ -> ... use case x of Constructor{} -> ...
16:06:43 <Peaker> gtk2hs is not cabalized?
16:06:52 <pumpkin> naming the constructor fields helps if you actually need the values
16:07:04 <pumpkin> Peaker: I heard it was too complicated to build for cabal
16:07:09 <pumpkin> at least in its current state
16:07:38 <Phyx-> ahh, taking a step back and reading the code does help :)
16:07:57 <altmattr> pumpkin: you just made my jaw drop - I didn't even know you could do that!
16:08:05 <altmattr> how did I miss that?
16:08:57 <pumpkin> I only came across it recently, can't remember where
16:09:22 <altmattr> now I am off to rewrite every pattern matching function I ever wrote
16:09:25 <Peaker> pumpkin: cabal lets it have its own build executables?
16:10:45 <Phyx-> @type (*** id)
16:10:47 <lambdabot> forall b c b'. (b -> c) -> (b, b') -> (c, b')
16:11:13 <Phyx-> @type (*** id) (++"-")
16:11:14 <lambdabot> forall b'. ([Char], b') -> ([Char], b')
16:11:18 <goalieca2> is there no ubuntu 9.04 package for cabal? it is not in haskell-utils and it doesnt come up in a repo search
16:11:25 <pumpkin> Peaker: yeah, but I guess they decided it wasn't worth cabalizing if all the work was going to be done by configure and make? not sure
16:11:40 <Phyx-> @type (*** (++"-")) id
16:11:41 <lambdabot> forall c. (c, [Char]) -> (c, [Char])
16:11:44 <Phyx-> ah
16:11:47 <Phyx-> that's the one
16:11:56 <Peaker> pumpkin: at least get deps?
16:12:10 <pumpkin> Peaker: beats me :) that's just what I heard
16:12:17 <Phyx-> arrow is really handy
16:12:27 <Twey> Sometimes
16:12:33 <Twey> Not very often, though, alas
16:12:36 <Phyx-> hehe
16:12:46 <pumpkin> I find it useful pretty often!
16:12:50 <pumpkin> it got my par down to 3
16:12:57 <Phyx-> hmm this doesn't look so nice... a function with 8 class constraints
16:13:12 <pumpkin> Phyx-: http://blog.omega-prime.co.uk/
16:13:20 * Phyx- looks
16:13:41 <Phyx-> oh that's nice
16:13:45 <Phyx-> thanks :)
16:13:55 <Phyx-> i can clean up qute a bit with that
16:14:32 <Peaker> pumpkin: what's "context" ?
16:15:24 <Phyx-> hmm seems to be just a proposal at this point pumpkin ?
16:15:27 <Phyx-> too bad :(
16:16:19 <ray> peaker: context is what's behind that link
16:17:10 <Phyx-> I like the proposal though
16:17:40 <ray> i've decided instance (Lots, Of, Different, Classes, At, Once) Foo where ... would be cool
16:17:45 <Peaker> ray: I directly skimmed to code examples, without reading the top :)  It sounds like class aliases
16:18:10 <ray> the first bit is
16:18:48 <ray> (and of course, substituting a class alias for that thing in parentheses should work)
16:19:24 <Phyx-> union dataK dataB :: [Buchi (Integer, [Char]) [Char]] <-- atleast it type checks :)
16:20:13 <Phyx-> "[*** Exception: Prelude.undefined" <-- always hate these errors
16:20:16 <Phyx-> now where is it..
16:20:51 <Cale> Phyx-: are you explicitly using undefined somewhere?
16:21:00 <Twey> Phyx-: C-s undefined
16:21:12 <Twey> undefined is the new TODO
16:21:19 <Phyx-> Cale: i used them to get a stub working, but i should have removed them by now i think
16:21:25 <Cale> ah :)
16:21:39 <Twey> But perhaps we should stick with TODOs for a while, in case of explicit undefineds...
16:21:53 <Cale> error would be a little better
16:22:02 <Cale> since then at least you'd know which one :)
16:22:09 <Phyx-> found it, heehe
16:22:11 <Twey> foo = error "NIH"
16:22:12 <ray> TODO can be an empty data declaration
16:22:17 <Phyx-> i had a boilerplate let code
16:22:31 <Phyx-> quick question
16:22:35 <Twey> ray: How do you mean?
16:22:43 <ray> data TODO
16:22:51 <Phyx-> why didn't this spit out a "redifining variable 'e'" error?
16:22:52 <Phyx->     e@(e1,e2) <- ask
16:22:53 <Phyx->     let e = undefined
16:22:55 <ray> with a ghc extension enabled
16:22:57 <Twey> But how would we use it?
16:23:05 <Phyx-> i had the second by accident
16:23:11 <Twey> Phyx-: It will simply shadow it
16:23:12 <Cale> Phyx-: Because shadowing isn't normally something it warns about
16:23:17 <ray> then, you could write functions like [(a,b)] -> TODO
16:23:41 <Twey> It will only warn (or was it an error?) about redefining if you do it in the same let block, I think
16:23:53 <ray> where TODO is a Map-like data structure you haven't written yet
16:23:58 <Phyx-> i could swear i used an interpreter before that warned about shadowing
16:24:00 <Phyx-> hmm
16:24:02 <ray> your code won't compile, and you'll remember to implement it
16:24:03 <Twey> ray: But then the types would be different
16:24:14 <Cale> Phyx-: if you set -Wall I think it will warn
16:24:16 <ray> that's the idea
16:24:18 <Twey> The idea is to get the code to compile so we can make sure it type-checks
16:24:26 <Twey> Before implementing
16:24:38 <Cale> But -Wall is annoying :P
16:24:43 <Phyx-> Cale: ah, lol
16:24:48 <Phyx-> was it on at some version of ghci?
16:24:53 <Phyx-> by default i mean
16:24:55 <Cale> I don't know.
16:24:56 <ray> that's the idea of undefined
16:25:04 <ray> my idea is different
16:25:12 <ray> and forces you to remember to implement stuff
16:25:23 <ray> unless you use undefined in conjunction with it
16:26:03 <Cale> ray: I think the point is that he wanted to load the code in ghci, and so stubbed some stuff out with undefined.
16:26:21 <Cale> ray: If you want it not to compile, you can just fail to write it altogether :)
16:26:23 <ray> yeah, that's totally different from my crazy idea, it just happened to inspire it
16:26:25 <Twey> Wow, -Wall really is annoying.
16:26:36 <Phyx-> hm. why does foldl1 return an exception when the list is empty? i was expecting an empty list
16:26:45 <Twey> It warns about missing type signatures :(
16:26:54 <Cale> Phyx-: Because... that's the point of it
16:26:56 <ray> well, i want to write the function body and the type signature, but not define the return type :)
16:26:56 <Twey> Phyx-: Because it needs the first element
16:27:03 <Cale> :t foldl
16:27:05 <Cale> :t foldl1
16:27:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:27:05 <ray> you want foldl
16:27:06 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:27:09 <lament> why would fold return a list?
16:27:38 <Cale> You only use foldl1 when the function you're writing makes no sense for an empty list.
16:27:48 <Phyx-> aha
16:28:00 <Phyx-> lament: when you're folding over [[a]]
16:28:23 <Cale> Since it's polymorphic, it can't do anything different in the list case than in any other.
16:28:35 <Phyx-> hmm
16:29:08 <Phyx-> aha
16:29:09 <hackagebot> Hieroglyph 2.23
16:29:09 <Phyx-> works
16:29:17 <ray> lots of languages throw around the word "polymorphic", but only haskell throws around "monomorphic" too
16:29:40 <FalconNL> Well that's nice: the example in http://hackage.haskell.org/packages/archive/HTTP/4000.0.5/doc/html/Network-HTTP.html fails with "openFile: does not exist (No such file or directory)". Is the example wrong or am I missing something?
16:29:45 <Cale> That use of monomorphism is really confusing to me.
16:30:02 <Cale> Because it conflicts with the standard meaning in mathematics.
16:30:25 <Cale> Or it was, I'm pretty much used to it by now :)
16:30:55 <ray> yeah, it's monomorphism the adjective not monomorphism the noun
16:31:09 <ray> er
16:31:09 <kniu> Since haskell has Data.Map, couldn't record types be implemented with Template Haskell, since they're just maps of names to values and their types?
16:31:13 <ray> i think i'm right
16:31:21 <Cale> I think so too.
16:31:37 <mmorrow> Cale: heh, i thought the monomorphismrestriction had to do with some sort of injective mapping for the first while when i was learning haskell
16:31:55 <Cale> kniu: Not with the same syntax.
16:32:02 <Cale> mmorrow: me too
16:34:27 <Cale> kniu: You could perhaps approximate the record syntax by constructing a plain algebraic type along with such a mapping, and then do lots of quasiquoter manipulations...
16:35:15 <Cale> Seems like a troublesome thing to do, anyway.
16:35:39 <pumpkin> damn overloaded words
16:36:17 <kniu> Cale, I thought Template Haskell allowed you to do all sorts of crazy stuff with the syntax.
16:37:23 <Cale> Not really. splices always look like $( ... ) where what's inside the parens is some code which evaluates to a Haskell syntax tree.
16:37:27 <EvilTerran> kniu, template haskell is pretty noisy, it's not really changing the syntax
16:37:43 <kniu> huh.
16:37:53 <Cale> Though we now have a quasiquoter syntax which lets you do arbitrary parsing, but you still need a surrounding bracket.
16:38:10 <EvilTerran> [$qqName| ... |], at that
16:38:46 <FalconNL> Does anyone know any reasons why the first example in http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-HTTP.html could fail?
16:38:48 <Twey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2502#a2502  why is this considered non-exhaustive?
16:39:32 <Twey> I would have thought it exhaustively covered by the x (y : z) pattern
16:39:36 <Twey> (the ones it mentions)
16:39:46 <Twey> And the one about not matching _...
16:40:16 <Cale> Heh, I think the pattern match exhaustiveness checker is sort of broken
16:40:38 <Twey> Is it not covering that because I've specified guards?
16:40:39 <Cale> That, or it just doesn't like your crazy moon-language.
16:40:46 <Zao> What about fanva "h"?
16:40:48 <Twey> Haha
16:40:58 <Cale> oh, maybe it can't tell that the guards are exhaustive?
16:41:13 <Twey> Zao: Gets caught by (lerfu : loilErfu) | not $ isAlphaNum lerfu
16:41:26 <Zao> Twey: But it's alpha.
16:41:37 * Twey blinks.
16:41:38 <Twey> Point
16:41:56 * Twey nodnods.
16:42:16 <Cale> I don't know how it would figure that out though.
16:42:47 <Cale> It would either have to assume that the guards always fail or that one of them always succeeds... I don't think it's smart enough to really tell.
16:43:15 <Twey> I would suspect it considers them incomplete if there's no otherwise
16:43:25 <Cale> yeah, maybe that's it
16:43:36 <Twey> After adding one, it seems okay with it
16:43:53 <Twey> And I can feel elitist pride at getting -Wall to accept my measly code
16:46:41 <Cale> Twey: hopefully after the other case though...
16:46:51 <Twey> Other case?
16:47:02 <Cale>     fanva (zunsna : karsna : loilErfu) =
16:47:03 <Twey> Oh, yes
16:47:06 <Twey> I switched them :)
16:47:10 <Cale> ah
16:47:48 <Twey> The order of patterns and their matches can get quite delicate in complex use cases
16:48:43 <MyCatVerbs> What language of variable name are zunsna, karsna and liolErfu?
16:48:59 <Twey> loi**
16:49:00 <MyCatVerbs> AIEEEE
16:49:01 <Twey> Lojban
16:49:09 * Twey blinks.
16:49:11 <MyCatVerbs> Ah, oops. Thanks.
16:49:18 <Twey> Usually the screaming happens *after* I mention that it's Lojban.
16:49:27 <MyCatVerbs> Not that, pumpkin.
16:49:32 <Twey> Ohh.
16:49:35 <Twey> A Thwog.
16:49:44 <MyCatVerbs> The Thwog, apparently.
16:49:48 <MyCatVerbs> I'm scared that he might try to help us.
16:49:57 <Thwog> No.
16:50:14 <MyCatVerbs> Phew.
16:50:19 <Twey> Yes, I'm trying to work out a set of conventions that adhere to both Lojban and Haskell requirements
16:50:43 <Twey> Luckily, Lojban allows word-demarcation by stress, so no separators are required
16:50:54 <Twey> And Haskell allows ' in names, which is also very cool.
16:51:03 <Thwog> no it doesn't
16:51:15 <Twey> Thwog: Haskell disagrees.
16:51:23 <Thwog> yeah, but I'm incompetent
16:51:26 <Twey> > let ' = "foo" in '
16:51:27 <lambdabot>   <no location info>:
16:51:27 <lambdabot>      lexical error in string/character literal at chara...
16:51:27 <MyCatVerbs> > let let'ssee = "whether or not it does" in let'ssee
16:51:29 <lambdabot>   "whether or not it does"
16:51:30 <Twey> Aw.
16:51:34 <Twey> Not there, apparently.
16:51:42 <Thwog> http://thwog.kyth.org/Book_of_Thwog/book_of_thwog.html
16:51:58 <MyCatVerbs> > let 'avaunt = "I can't remember what this word means" in "bacon"
16:52:00 <lambdabot>   <no location info>:
16:52:00 <lambdabot>      lexical error in string/character literal at chara...
16:52:05 <MyCatVerbs> Not there, either. :3
16:52:40 <Twey> thou: Bahaha
16:52:48 <Twey> MyCatVerbs: It thinks it's a character literal
16:53:13 <MyCatVerbs> Twey: yes, I can read the error message. ;P
16:53:14 <Twey> Which is kind of silly  it should really be obvious that it isn't
16:53:21 <MyCatVerbs> Erk!
16:53:41 <Twey> A character literal will always be of the form '<char>' or '\<char>'
16:53:56 <Twey> I guess it requires backtracking, though.  Do we avoid that?
16:54:22 <MyCatVerbs> "It should be really obvious that..." <- no, please no. I like my parsers to be as simple as possible. The simpler the parser, the easier it is to understand why it is barfing on some given piece of text.
16:54:25 <Cale> > '\SOH'
16:54:27 <lambdabot>   '\SOH'
16:54:33 <MyCatVerbs> Yes, we avoid that as much as possible.
16:54:33 <Phyx-> hrm... my trace statements became impressively useless since ghc reordered them
16:54:34 <Phyx-> lol
16:54:40 <Twey> MyCatVerbs: Heh, okay.
16:54:41 <MyCatVerbs> Heehee. "avaunt - interjection - [archaic] begone! go away! (N.B. useful for telemarketers)"
16:54:58 <Cale> > "\SO" ++ "H"
16:54:59 <lambdabot>   "\SO\&H"
16:55:41 <Twey> What does \SO mean?
16:55:56 <MyCatVerbs> > chr '\SO'
16:55:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:56:02 <Twey> > "\S" ++ "OH"
16:56:03 <lambdabot>   <no location info>:
16:56:03 <lambdabot>      lexical error in string/character literal at chara...
16:56:05 <MyCatVerbs> > ord '\SO'
16:56:07 <lambdabot>   14
16:56:13 <pumpkin> Cale: do you know why lambdabot has been giving low-level type names in errors recently?
16:56:21 <Cale> Shift Out
16:56:24 <Twey> Is \& a no-op?
16:56:26 <pumpkin> a lot of GHC.Types.* instead of the more obvious ones
16:56:36 <MyCatVerbs> "Shift Out". Which means...?
16:56:46 <Cale> Twey: yeah, it's just there as a separator for that one special case :)
16:56:54 <Twey> Heh
16:56:54 <Peaker> I wonder if you can implement Python-like generators (yield) with ContT
16:57:00 <Twey> > length "\&"
16:57:01 <lambdabot>   0
16:57:04 <Cale> http://en.wikipedia.org/wiki/Shift_Out_and_Shift_In_characters
16:57:14 <MyCatVerbs> I sometimes wonder whether  anyone on the planet who can remember what most of the control characters in ASCII mean, anyway. :D
16:57:16 <Twey> Peaker: I believe you can, yes
16:57:29 <Twey> Why is there an exists in the middle of that sentence?
16:57:30 <MyCatVerbs> Peaker: spoiler, you can implement Python-like generators with lazy lists. :P
16:57:38 * Twey laughs.
16:57:41 <Peaker> MyCatVerbs: nope, Python generators do side effects
16:57:45 <Twey> Only for pure values
16:57:49 * Twey nods.
16:58:16 <MyCatVerbs> Peaker: unsafeInterleaveIO. ^^
16:58:22 <Peaker> hah
16:58:27 <Twey> >.<
16:58:31 <Peaker> Twey: I am new to ContT, it seems like a horrible thing to ever use, but I want to get to know it and use it to write coroutines/etc so I can impress people with Haskell's mojo :)
16:59:22 <Twey> Oh, it's not that horrible
16:59:36 <Twey> It *can* be a bit mind-bending, but that's your responsibility :-P
16:59:39 <RayNbow> btw Cale, what do you use to type Japanese? (as you did here http://www.reddit.com/r/programming/comments/8mmcu/i_tried_to_translate_the_ironpython_code_to/c09rkdu )
16:59:47 <Cale> RayNbow: SCIM
16:59:52 <Berengal> Continuations are not for the weak of mind
16:59:53 <Cale> +Anthy
16:59:58 <Peaker> Twey: it provides a "function" that never returns, and actually performs a goto/jump
17:00:14 <Cale> RayNbow: In Ubuntu, it's easy to install. You just tick a checkbox or two
17:00:29 <Cale> (and then restart your X session)
17:00:38 <Twey> Peaker: It does return, when you run the monad
17:00:44 <Twey> Peaker: It's just sugar for CPS
17:00:49 <MyCatVerbs> Er...
17:00:50 <RayNbow> Cale: I'm using Arch on my netbook, but I think I'll manage
17:00:50 <Twey> CPS isn't that scary
17:01:02 <Peaker> Twey: it does not return, in the sense of never binding the next actions (talking about ContT)
17:01:06 <MyCatVerbs> It's just sugar for delimited continuations. Not full continuations. :D
17:01:14 <Cale> RayNbow: There might be some environment variable munging to be done normally. :)
17:01:16 <RayNbow> (on my Windows machines I'm using Microsoft's IME)
17:01:26 <Twey> RayNbow: RayNbow http://wiki.archlinux.org/index.php/Scim
17:01:40 <Twey> Minus one RayNbow, if you like.
17:02:00 <Twey> Peaker: I'm not sure I follow
17:02:30 <Cale> I like how I got 10 points for that comment, probably just because it was in Japanese.
17:02:38 <Twey> Hahaha
17:03:05 <Twey> 
17:03:43 <pumpkin> zomg more japanese
17:03:44 <RayNbow> btw Cale, why didn't you use 
17:04:01 <Cale> RayNbow: I could have, I suppose :)
17:04:11 <skorpan> 
17:04:22 <Twey>  sounds better, to my non-native ear
17:04:23 <MyCatVerbs> AIEEE SNAKES
17:04:32 <MyCatVerbs> Oh wait, Alephs.
17:04:33 <Peaker> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5295#a5295 -- call that never returns
17:04:38 <Twey> Like in truth as opposed to just really
17:04:41 <pumpkin> the connotation is different
17:04:58 <Twey> ()  snakes in a basket
17:05:03 <ray> time to change my putty font again
17:05:09 * RayNbow can't judge which sounds better... my knowledge of the Japanese language is quite limited...
17:05:12 <Cale> Or Sims money.
17:05:28 <skorpan> 
17:05:31 <Peaker> Twey: see the example? "gotoAfter ()" looks like an ordinary action -- but its one that never ever returns
17:05:43 <skorpan> a snowflake on a pedestal!
17:06:40 <Peaker> Twey: I guess maybe you could say that other monad transformers also "never return" from some actions, but here its combined with a jump, rather than just terminating the computation
17:07:03 <Twey> Peaker: But that's not right
17:07:06 <Twey> It does get there
17:07:12 <Peaker> Twey: run it
17:07:30 <MyCatVerbs> Twey: #SSSSSSS# roomful of snakes.
17:07:52 <MyCatVerbs> Twey: not pictured: the fountain that you q'd from to make them all come after you, you stupid bloody adventurer.
17:07:52 <Peaker> Twey: created http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5295#a5296 -- which should actually compile
17:08:06 <lament> SSSSSS@SSSSSS
17:08:08 <Twey> Peaker: I did
17:08:20 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5295#a5297
17:08:30 <Twey> You only need to import Control.Monad.Cont
17:08:32 <MyCatVerbs> lament: meh. That's only threatening if I have no mana and no hitpoints. :)
17:08:34 <cads> I just got killed by a stunning slime mold and a kitten.
17:08:36 <Twey> The others are exported from it
17:08:58 <Peaker> Twey: "never gets here, haha!" was not printed
17:09:11 <Asztal> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2503#a2503 <- any ideas what's happening there?
17:09:23 <ray> i stopped playing nethack when i got killed by a purple worm on level 3 or so
17:09:29 <Twey> Peaker: No  but it does return, in the sense that control is handed back to the main function
17:09:35 <Twey> Oh, I see what you mean
17:09:45 <MyCatVerbs> ray: you're supposed to laugh when you get owned that atrociously by the RNG. :)
17:09:48 <Phyx-> bed time, thanks for all the help today guys, appreciate it
17:09:49 <Peaker> the function callCC gives to the action never returns
17:09:55 <Asztal> mkTree and NTree should be interchangable there :(
17:09:57 <Peaker> the action, that is
17:09:58 <MyCatVerbs> ray: what happened anyway, you ran into a shrieker? =D
17:10:00 <lament> ray: you must have done something stupid
17:10:04 <ray> yeah, shriekers
17:10:18 <lament> oh, ouch
17:10:19 <MyCatVerbs> Cool. Purple worms rule.
17:10:21 <lament> just failing to Elbereth, then
17:10:22 <ray> they called a purple worm
17:10:32 <ray> engulf, die
17:10:40 <ray> i didn't stop playing because of that
17:10:49 <MyCatVerbs> wwwwwww @ <- fucked adventurer.
17:10:59 <Twey> Asztal: To start with, you have an over-large function :-P
17:10:59 <ray> it was just a coincidence that i got owned so bad in the last game i played
17:11:03 <Twey> What is mkTree?
17:11:03 <lament> &@ - fucked adventurer.
17:11:27 <Peaker> Twey: anyway, that was the thing I found most confusing about continuations, I think I found the same confusion in Scheme's call-cc
17:11:45 <Peaker> Twey: everybody says the continuation is passed as a function -- but its passed as a goto'er, not a function
17:11:54 <Peaker> (talking about the transformer here)
17:12:04 <Cale> But it is a function...
17:12:12 <Twey> It is indeed
17:12:15 <Peaker> a function/action returns
17:12:24 <Cale> not just an action
17:12:29 <Cale> a function giving an action
17:12:55 <Asztal> Twey: mkTree's a method of the Tree class, which NTree is an instance of (http://hackage.haskell.org/packages/archive/hxt/8.3.0/doc/html/Data-Tree-Class.html)
17:13:13 <Cale> You can return a value along with that "goto"
17:13:33 <Peaker> Cale: yeah, I'm referring to the action. In Haskell, an action bind can do anything at all, so its less surprising. but I was baffled about the function callCC passes in Scheme -- if it returns, then everything will execute O(callCC count) times
17:13:58 <Berengal> > runCont (do x <- return 5; y <- return 7; return (x+y)) show
17:13:59 <lambdabot>   "12"
17:14:05 <Berengal> > runCont (do x <- return 5; y <- Cont (\cc -> "Hehehe"); return (x+y)) show
17:14:06 <lambdabot>   "Hehehe"
17:14:14 <Peaker> Cale: I was wondering how its avoided, it simply being a goto rather than an actual function is something nobody seems to even mention
17:14:31 <Twey> Asztal: Then what's NTree?
17:14:41 <Cale> Well, it's actually more general than goto
17:14:54 <Peaker> Cale: because labels are values?
17:14:59 <Cale> yeah
17:15:14 <Peaker> its pretty horrible, and yet an amazing testament to the power of transformers :)
17:15:18 <Asztal> Twey: data NTree = NTree a [NTree a]
17:15:26 <Asztal> with a more-or-less obvious instance of Tree
17:15:49 <Asztal> (mkTree = NTree)
17:15:53 <Twey> ITYM data NTree a = ...
17:16:02 <Asztal> yes, sorry
17:16:08 <Twey> Hmm
17:16:26 <Twey> Pass; sorry :-\  Maybe someone else
17:16:46 <Phyx-> heheheh i need to update my graph tracer to detect cycles :P
17:17:03 <Phyx-> i suppose i should keep a list of my current path
17:17:16 <Phyx-> never repeat nodes that appear on that path
17:17:55 <Phyx-> gn
17:18:48 <Peaker> how do you throw in ErrorT?
17:18:59 <Peaker> @src MonadError
17:18:59 <lambdabot> class (Monad m) => MonadError e m | m -> e where
17:19:00 <lambdabot>     throwError :: e -> m a
17:19:00 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
17:19:01 <Peaker> Using that?
17:19:08 <Peaker> @src ErrorT throwError
17:19:09 <lambdabot> Source not found. That's something I cannot allow to happen.
17:21:46 <RayNbow> @users
17:21:47 <lambdabot> Maximum users seen in #haskell: 658, currently: 562 (85.4%), active: 15 (2.7%)
17:24:44 <Peaker> Ok, I'm getting closer to coroutines http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5299#a5299
17:26:49 <jmcarthur> i implemented cooperative threads in haskell once, with decent performance. i am really upset that i lost that work
17:27:20 <aconbere> anyone know of a good description of how to employ the random monad in practice?
17:28:34 <jaredj> !seen jaredj
17:29:07 <jaredj> it's scary. every time i join nobody talks
17:29:31 <aconbere> sssshhhh
17:29:44 <jaredj> and i can't work the bot anymore :(
17:30:15 <jmcarthur> @seen jaredj
17:30:15 <lambdabot> jaredj is in #haskell. I last heard jaredj speak 31s ago.
17:30:53 <jmcarthur> aconbere: hard to speak of the random monad specifically without talking about monads generally, i think
17:31:32 <aconbere> jmcarthur: certainly, I just need some examples of using the monad
17:31:58 <aconbere> ah look, the code has an example include
17:31:58 <aconbere> d
17:32:03 <jmcarthur> aconbere: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
17:32:08 <jmcarthur> ... yeah :)
17:33:07 <jaredj> many .hs have import qualified Data.Map as M
17:33:13 <jaredj> can you do that with :m in ghci?
17:33:32 <jmcarthur> jaredj: not that i know of, but you do get tab completion in ghci at least :)
17:33:57 <jaredj> *nod* verranice
17:35:25 <Peaker> jmcarthur: doh :(
17:35:29 <Peaker> jmcarthur: github, next time :P
17:42:27 <jaredj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5300#a5300
17:42:47 <jaredj> parsec type error. help?
17:43:19 <amckinley> anyone around to answer some questions about stm + io?
17:44:45 <Philippa> jaredj: use the parsec 2 package? The modules are found under Text.ParserCombinators.Parsec
17:45:44 <jaredj> i could.. in the absence of other info isn't 3 better?
17:46:04 <amckinley> jaredj: whats the error?
17:46:07 <Philippa> no, 3's still rather experimental
17:46:43 <Philippa> tbh, 3's a good use case for custom error messages - that's something that's still in research though :-(
17:47:02 <jaredj> at the bottom of the paste. no instance for (Stream String Identity Char).
17:47:11 <jaredj> oic
17:47:31 <amckinley> jaredj: i think you hit the monomorphism restriction :)
17:47:47 <jaredj> the last bit should be [Char] not Char but i don't know how to get it that way
17:47:59 <amckinley> jaredj: try adding this pragma to the top of your file:
17:48:00 <amckinley> {-# LANGUAGE NoMonomorphismRestriction #-}
17:48:28 <jaredj> same
17:48:52 <amckinley> darn
17:48:59 <amckinley> i missed the paste; just joined
17:49:25 <Philippa> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5300#a5300
17:49:43 <Philippa> jaredj: I could swear you don't want the instance to be [Char] for the last parm
17:49:56 <Philippa> unless your basic tokens are [Char]/String
17:50:28 <jaredj> well you're right. but i'm using manyTill, so the one I think it's choking on shouldn't matter
17:50:32 <Philippa> hrmm. That instance or a related one really should be in one of the modules too - is it in Text.Parsec?
17:50:59 <jaredj> ...!
17:51:04 <jaredj> import Text.Parsec and it works
17:51:44 <jaredj> if i import Text.Parsec do i get Text.Parsec.Prim too (e.g.) or do i still have to import that if i want it
17:51:50 <jaredj> ?
17:51:56 <Philippa> best I can offer there is RTFM :-)
17:52:02 <jaredj> heh k
17:52:05 <jaredj> thanks
17:52:43 <Philippa> jaredj: could you email the package maintainer and tell him you ran into this? It's mildly non-obvious to a package designer that someone might not import Text.Parsec
17:52:54 <jaredj> ok
17:53:14 <Philippa> but some of the instances can be shifted to Text.Prim, or a big "import Text.Parsec or doom!" notice can be added to the docs
17:55:34 <vininim> also I had some success with attoparsec
17:55:59 <vininim> the incremental parser isn't stack friendly though
17:57:45 <alexsuraci> I
17:57:51 <alexsuraci> ...I hate you, enter key.
17:58:19 <alexsuraci> I'm building Pugs on Arch x64 from AUR, almost near the checkpoint when a "Missing header file: pcre" error hit me. Any ideas?
17:58:26 <Peaker> ok, I just wrote this code, and already I don't understand it :-)
17:58:29 <Peaker> but it seems to work! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5299#a5301
17:58:41 <Peaker> a pretty good approximation of Python generators -- can go further
17:59:04 <Peaker> you get two-way yields
17:59:46 <Peaker> I would like to have the yield passing implicit in the monad now...  This is going to be difficult..
18:09:28 <Peaker> Ok, I just made the official coroutine challenge!
18:09:30 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5299#a5302
18:10:03 <Peaker> I wrote an action the way it *should* look - I think its quite a challenge to implement GeneratorT (using ContT) so that it actually works
18:10:17 <Peaker> it was pretty difficult to get the previous paste working, and this is considerably more difficult
18:11:04 <Peaker> it could prove Python's advanced "generators" are just a library feature in Haskell too :)  It would also allow nested yield calls which aren't allowed in Python!
18:16:36 <tompledger> Are you totally determined to generalise it to monads other than IO?  That goes beyond Python!
18:16:45 <tompledger> @src MonadTrans
18:16:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:17:47 <tompledger> Isn't there a lift method in the monad transformer class?  Does it create extra traffic in and out of 'yield land.?
18:18:19 <tompledger> 'yield land'
18:19:38 <hackagebot> vacuum 0.0.94
18:22:25 <jaredj> i wrote a little parser. now i want to test it.
18:22:39 <mmorrow> Baughn: just uploaded a new vacuum, which has a closureType you can use + an initial version of vacuumLazy (** which doesn't work like one would want, and i have a small fear that there's the possibility that making it do so might be impossible given the hooks we currently have, but we'll see)
18:22:46 <jaredj> since it uses parsec, i can run it on a string and so it's pure and so i should use quick check - right?
18:23:11 <Cale> jaredj: sure
18:23:12 <mmorrow> jaredj: quickcheck is nice for parsers
18:23:19 <mmorrow> , randE()
18:23:22 <lunabot>  (x11 :: x3) (x11 (- 5)) (x3 x1 (x4 x14)) :: forall x14 x12 x7 x4 x3 x6 . x9
18:23:24 <mmorrow> , randE()
18:23:27 <lunabot>  [x3 x10, ["This is a string. "]]
18:23:44 <Cale> jaredj: If you have a pretty printer for the stuff you're parsing, you can create some really strong quickcheck tests.
18:24:21 <Cale> (like that if you take a syntax tree, pretty print it, and parse the result, you get back the same thing)
18:24:34 <jaredj> ok. so the little thing i have is (1) zero or more lines consisting of NAME:VALUE, and optional \r; (2) a blank line optionally with \r
18:25:00 <kpreid> \r?! Where'd this file come from?
18:25:06 <jaredj> right there i have two different Show instances i'll want to test, eh?
18:25:17 <jaredj> well - it's dos line endings, yknow
18:25:20 <jaredj> possibly
18:25:22 <jaredj> or not
18:25:39 <jaredj> i don't want to accidentally get \r's on the end of the values
18:25:41 <kpreid> you should probably write a rule which matches maybe-\r-then-\n
18:25:45 <kpreid> then use that
18:25:46 <jaredj> ah - that's a property
18:25:51 <jaredj> yes. yes i have that
18:25:54 <jaredj> in the parser.
18:26:00 <kpreid> rather than matching "\r after each of my rules"
18:26:08 <mmorrow> Peaker: what is the desired output of the main in that paste?
18:26:10 <kpreid> make it an integral part of the line separator
18:26:22 <jaredj> but how do i nicely turn a Map String String into (1) keys and values with \r on the end, and (2) without the \r?
18:26:24 <p_l> DOS/Windows/TOPS/internet is CRLF, Unix is LF ('\n'), Old Mac is CR "\r"
18:26:31 <jaredj> i would write instance Show blablabla but i need two instances
18:27:23 <jaredj> more importantly: where do i write the quickcheck tests?
18:27:52 <jaredj> my module will be Text.OFX1. do i make a Tests.hs alongside? put it in the toplevel of my project? what's the convention
18:28:03 <fracture> is there an easy way to produce an infinite list of repeated applications of a function to a value?
18:28:14 <kpreid> fracture: iterate
18:28:18 <fracture> so it'd be like [f x, f (f x), f (f (f x)), etc]
18:28:19 <kpreid> > iterate succ 0
18:28:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:28:21 <fracture> ah k thanks
18:28:23 <mmorrow> > let ppMap m = show (M.toList m) ++ "\r" in ppMap (M.fromList (zip [0..] ["a","b","zomg"]))
18:28:24 <lambdabot>   "[(0,\"a\"),(1,\"b\"),(2,\"zomg\")]\r"
18:28:35 <mmorrow> > let ppMap m = show (M.toList m) ++ "\r" in text $ ppMap (M.fromList (zip [0..] ["a","b","zomg"]))
18:28:36 <fracture> kpreid ... as in bancus?
18:28:37 <lambdabot>   [(0,"a"),(1,"b"),(2,"zomg")]
18:28:45 <kpreid> > iterate show "hi"
18:28:46 <lambdabot>   ["hi","\"hi\"","\"\\\"hi\\\"\"","\"\\\"\\\\\\\"hi\\\\\\\"\\\"\"","\"\\\"\\\...
18:28:55 <kpreid> fracture: hm? I'm not bancus
18:28:56 <skorpan> jesus
18:29:05 <fracture> ok
18:29:10 <jaredj> > iterate id 1
18:29:10 <mmorrow> > fix (("hi"++) .  show)
18:29:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:29:12 <lambdabot>   "hi\"hi\\\"hi\\\\\\\"hi\\\\\\\\\\\\\\\"hi\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"hi...
18:29:17 <fracture> (old lojban guy; saw you were in #lojban)
18:29:34 <mmorrow> > fix (1:)
18:29:36 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:29:43 <skorpan> > fix fix
18:29:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:29:47 <skorpan> aw man
18:29:48 <kpreid> fracture: yes...we're both in #lojhban
18:29:51 <jaredj> mmorrow: pointless...
18:29:59 <skorpan> > fix (fix:)
18:30:00 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
18:30:00 <lambdabot>    arising from a u...
18:30:10 <kpreid> skorpan; two fixes makes a broken
18:30:11 <skorpan> @type fix (fix:)
18:30:12 <lambdabot> forall a. [(a -> a) -> a]
18:30:19 <jaredj> ;)
18:30:38 <skorpan> @type fix
18:30:39 <lambdabot> forall a. (a -> a) -> a
18:30:50 <skorpan> fix is so magical
18:30:55 <skorpan> it's the Y combinator, right?
18:31:15 <mmorrow> > let iterate = fix (\k f a -> a : f a : (k . f . f) a) in iterate (*2) 2
18:31:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:31:44 <kpreid> skorpan: practically, no
18:31:48 <Berengal> mmorrow: Is there a reason why vacuum-cairo doesn't work properly when compiled?
18:31:51 <mmorrow> > let iterate = fix (\k f a -> a : f a : k f ((f . f) a)) in iterate (*2) 2
18:31:52 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
18:32:07 <skorpan> kpreid: are you saying that theoretically it is though?
18:32:10 <kpreid> skorpan: fix f = f (fix f)
18:32:26 <Alpounet> @src fix
18:32:26 <mmorrow> Berengal: i'm not sure since it's not my package, but it vacuum works fine compiled. what is the breakage?
18:32:26 <lambdabot> fix f = let x = f x in x
18:32:31 <kpreid> you'd get identical results, but I don't know whether they would be equivalently efficient
18:32:44 <skorpan> kpreid: how can lambda calculus be "efficient"?
18:32:52 <kpreid> in Haskell, I mean
18:32:52 <mmorrow> Berengal: something like "ARR WORDS ENTERED!!"?
18:32:56 <Berengal> mmorrow: I just get the default picture thingy, then the program crashes when it's done
18:33:04 <mmorrow> Berengal: oh, i'm not sure
18:33:15 <Berengal> s/when it's done/when I close the window/
18:33:18 <mmorrow> Berengal: what did you try to `view'?
18:33:20 <pejo> skorpan, you could count the number of reduction steps, for example.
18:33:29 <skorpan> pejo: yeah, i just realised that :P
18:33:29 <mmorrow> (ie does "view 42" work?)
18:33:52 <kpreid> in lambda calculus, the Haskell-style definition of fix cannot be written because it contains a self-reference
18:34:01 <skorpan> kpreid: indeed
18:34:01 <Berengal> mmorrow: Nope
18:34:14 <mmorrow> Berengal: if "view 42" doesn't work then it may be a problem with one or more of your cairo, gtk2hs, vacuum-cairo pkgs
18:34:33 <Berengal> mmorrow: The strange thing is it works in ghci...
18:34:43 <Berengal> Well, once, I have to restart ghci if I want to view something again
18:34:47 <Twey> kpreid: No self-references allowed?
18:34:49 <Twey> No recursion?
18:34:58 <skorpan> Twey: i think he's right
18:35:08 <SamB> Twey: that doesn't follow
18:35:08 <mmorrow> Berengal: oh, odd. hmm does the prog your calling it from look like?
18:35:16 <mmorrow> *what does the prog ...
18:35:17 <skorpan> you can still do recursion using e.g. the Y combinator
18:35:17 <SamB> well, in typed lambda calculus, I guess it does ...
18:35:23 <Twey> SamB: How do you recurse without referring to yourself?
18:35:27 <mmorrow> * .. you're ..
18:35:32 <Twey> Except via mutual recursion, I guess
18:35:36 <Twey> But I think that's cheating
18:35:47 <SamB> Twey: Y!
18:35:50 <mmorrow> , fix (\k m n -> m : k n (m+n)) 0 1
18:35:51 <Twey> Ohh.
18:35:52 <RyanT5000> Twey: try looking up the "fixed point combinator"
18:35:52 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:36:11 <Berengal> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5303#a5303
18:36:31 <mmorrow> y f = let z = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
18:36:58 <mmorrow> which is the same as fix, except it has the slightly more general type ((a -> b) -> b)
18:38:28 <mmorrow> Berengal: oh, you may have to get your program to sit on an MVar or something to delay main exiting
18:38:54 <Berengal> mmorrow: Ah, will try that
18:40:00 <mmorrow> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5303#a5304
18:40:02 <Alpounet> :t fix
18:40:03 <lambdabot> forall a. (a -> a) -> a
18:40:05 <mmorrow> does that work?
18:41:37 <Berengal> mmorrow: Nope, and it exits right away (thread blocked indefinitely)
18:41:40 <mmorrow> `y' is illegal on account of the infinite type
18:41:45 <mmorrow> oops, i botched y
18:41:49 <Berengal> Which also happened when I used infinite types...
18:41:50 <mmorrow> y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
18:42:13 <mmorrow> Berengal: ok, try
18:42:31 <Berengal> s/infinite types/threadDelay/ :/
18:42:38 <mmorrow> ohh, yeah since view returns immediately..
18:43:07 <mmorrow> try http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5303#a5305
18:43:20 <mmorrow> (just adds a getLine after view to the original paste)
18:43:23 <mmorrow> (hax)
18:44:01 <Berengal> mmorrow: Still same result... It seems to block until after I close the window, then "thread blocked indefinitely"
18:44:11 <Berengal> And still only the default picture
18:44:21 <mmorrow> hmm
18:44:29 * mmorrow tries running it
18:45:46 <mmorrow> Berengal: ah, you need -threaded
18:45:55 <Berengal> Ah, obviously...
18:46:04 <mmorrow> i guess it's making a foreign call which blocks without it..
18:49:01 <Berengal> Hmm, fmap still kills sharing, even at O2
18:50:07 <mmorrow> , vacuum (fmap (*2) (take 4 (repeat 1))
18:50:09 <lunabot>  luna: parse error (possibly incorrect indentation)
18:50:09 <mmorrow> , vacuum (fmap (*2) (take 4 (repeat 1)))
18:50:12 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[])]
18:50:18 <mmorrow> , vacuum ((take 4 (repeat 1)))
18:50:21 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[])]
18:50:36 <mmorrow> , vacuum ((take 4 (fix (1:)))
18:50:38 <lunabot>  luna: parse error (possibly incorrect indentation)
18:50:40 <mmorrow> , vacuum ((take 4 (fix (1:))
18:50:41 <lunabot>  luna: parse error (possibly incorrect indentation)
18:50:49 <mmorrow> , vacuum (take 4 (fix (1:)))
18:50:52 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[])]
18:51:05 <mmorrow> dang, so does take
18:51:13 <mmorrow> , vacuum (fix (1:))
18:51:15 <lunabot>  [(0,[1,0]),(1,[])]
18:52:00 <vininim> wat
18:52:17 <vininim> ,t vacuum
18:52:18 <lunabot>  luna: Couldn't match expected type `(a1
18:52:29 <vininim> :t vacuum
18:52:30 <lambdabot> Not in scope: `vacuum'
18:52:49 <mmorrow> , vacuum (fix (\xs -> let x = 0; go 0 = xs; go n = x : go (n-1) in go 4))
18:52:52 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,0])]
18:52:55 <Berengal> mkTree looks like a list, but fmap increases the number of nodes to 2^n :/
18:53:27 <mmorrow> oh, n/m that's just the ptrs for the list...
18:54:12 <mmorrow> yeah, fmap does kill all sharing (but you _are_ creating new nodes after all)
18:54:22 <mmorrow> , vacuum (fmap (*2) (take 4 (repeat 1)))
18:54:25 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[])]
18:54:26 <mmorrow> , vacuum (fmap id (take 4 (repeat 1)))
18:54:29 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[])]
18:54:43 <mmorrow> id preserves it thankfully
18:55:16 <mmorrow> , [$ty| vacuum |]
18:55:19 <lunabot>  forall a . a -> [] ((Int, [] Int))
18:55:48 <mmorrow> @where vacuum
18:55:48 <lambdabot> I know nothing about vacuum.
18:56:02 <mmorrow> @where+ vacuum http://moonpatio.com/vacuum/
18:56:02 <lambdabot> I will never forget.
18:58:15 <Alpounet> @where vacuum
18:58:15 <lambdabot> http://moonpatio.com/vacuum/
18:59:00 <akway> hey all
18:59:30 <byorgey> greetings, akway
19:00:13 <akway> so whats going on
19:03:20 <byorgey> you know, the usual... saving the world with Haskell programs, that sort of thing
19:04:09 <jaredj> ...i defined an instance Arbitrary Char, and newtype Value = Value String
19:04:16 <jaredj> how do i make an instance Arbitrary Value?
19:05:07 <byorgey> jaredj: the easiest way is to turn on GeneralizedNewtypeDeriving and put 'deriving Arbitrary' after the newtype declaration =)
19:05:08 <copumpkin> you just write arbitrary and coarbitrary or the type
19:05:15 <copumpkin> oh, that works? :o
19:05:41 <byorgey> assuming QuickCheck declares an  instance Arbitrary a => Arbitrary [a]
19:05:45 <byorgey> which I think it does
19:05:49 <jaredj> byorgey: yes
19:08:09 <fracture> is it possible to define a type to be an array with particular bounds?
19:08:21 <fracture> like type foo = Array (1,10) Int
19:08:22 <fracture> or something
19:08:36 <fracture> (or is array size inherently a runtime thing?)
19:08:50 <byorgey> fracture: sadly, no, not without some type gymnastics
19:08:56 <fracture> ok
19:09:31 <Berengal> byorgey: Could you remove runtime bounds checking using that?
19:10:22 <copumpkin> only with dependent types?
19:10:25 <dino-> Is this what dependent type means? Being able to do that?
19:10:36 <dino-> ah ^
19:10:50 <byorgey> it would be very easy in a system with dependent types, yes
19:12:15 <byorgey> you could do it in Haskell too, but you'd have to declare a bunch of types to represent whatever data you want to carry around at the type level, plus a bunch of type families or multi-parameter type classes to do the computation, etc. etc.
19:12:26 <copumpkin> hmm
19:12:37 <copumpkin> but for indexing into the array with values computed at runtime?
19:13:11 <byorgey> copumpkin: if you wanted it to be statically safe in Haskell, then you wouldn't be able to use normal Ints for the indices
19:13:17 <copumpkin> and guaranteeing that despite being computed at runtime, they'll never be above 10
19:13:19 <copumpkin> yeah
19:13:27 <copumpkin> I think I see
19:13:44 <byorgey> but you could do it with a special data type for representing the indices, which had some type information to connect it to the type level indices for the array
19:13:52 <copumpkin> yeah
19:13:53 <byorgey> using GADTs with a phantom type parameters most likely
19:15:15 <SamB> it's a bit easier in Coq or Agda ...
19:15:34 <byorgey> much easier.
19:15:59 <SamB> it's called understatement
19:16:12 <byorgey> heh, right =)
19:16:32 <mmorrow> hah
19:16:35 <jaredj> thanks all. good night for now
19:26:52 <gwern> @remember HalAbelson If I have not seen farther, it is because giants were standing on my shoulders.
19:26:52 <lambdabot> Done.
19:26:56 <gwern> @flush
19:29:32 <fracture> do most people dangle "then" on the same line as the if, or put it on the next line
19:29:41 <fracture> (or is it pretty evenly split?)
19:29:52 <hatds> I think more people put it on the next line
19:29:56 <SamB> next line, I think
19:30:12 <SamB> and then curse about having to indent it, if in a do
19:30:23 <fracture> ouch
19:30:28 <fracture> you have to indent it in a do?
19:30:39 <SamB> basically
19:30:43 <fracture> a
19:30:43 <fracture> h
19:30:54 <hatds> you always have to indent then/else at least one space farther than if
19:31:10 <hatds> well modulo {,} and place things on one line
19:31:34 <Cale> fracture: It should always look like this:
19:31:36 <jeff_s_> can you put the blocks in braces instead?
19:31:36 <Cale> if foo
19:31:38 <Cale>    then bar
19:31:41 <Cale>    else quux
19:31:57 <SamB> assuming the if is indented to do's statement-start column, i.e. not in a subexpression
19:32:01 <Cale> The important thing being that the 'then' and 'else' line up
19:32:03 <fracture> oh weird... I'd been doing the then on the same level as the if
19:32:10 <fracture> (seemed to be working...?  dunno)
19:32:16 <SamB> fracture: it might be an extension?
19:32:20 <fracture> dunno
19:32:21 <fracture> using ghc
19:32:25 <SamB> fracture: it's fine if not in a do, anyway
19:32:28 <Cale> Well, the actual rule is more general, but you'll have fewer problems like this
19:32:31 <fracture> ok
19:32:54 <fracture> well, here's a bummer... haskel-mode in emacs refuses to indent the "then" anywhere but the if's level
19:33:00 <Cale> Inside a do-block, if you indent something to the same as the rest of the block, you'll start a new line of the do-block
19:33:09 <fracture> so either ditch haskell-mode, dangle the then, or turn off it's auto indent
19:33:09 <Cale> Which means that your if-expression will be cut in two
19:33:11 <SamB> fracture: yeah, that's where the cursing comes in
19:33:44 <Cale> fracture: really? I don't remember it being that bad, but I mostly used the simple indenter
19:34:03 <SamB> fracture: I think you just don't hit <TAB> on that line, actually
19:34:19 <hatds> hmm.. normally if you aren't in a do you don't have to indent then/else?  I thought the special thing about do-layout only applied to the do block and the outer block containing 'do'
19:34:58 <SamB> hatds: well, it tries to insert a semicolon if you don't indent the then ...
19:35:21 <SamB> (or the else, but that is generally indented the same as the then ;-)
19:35:41 <hatds> ah right
19:36:13 <SamB> I'm not exactly sure how this could be fixed ...
19:36:17 <Cale> Wow, it is that bad...
19:36:21 <Cale> hmm
19:36:35 <SamB> I mean, allowing then at the same column as if
19:36:50 <hatds> hmm, neat.  I wonder if I will switch to lined up if/then/else when not in do if it would be too fragile
19:36:54 * Cale wonders if it is something possibly fixed in newer versions of haskell-mode
19:37:26 <fracture> haskell-mode seems *really* bad so far
19:37:29 <hatds> *wouldn't
19:37:31 <SamB> there are two places the fix would have to be done: the parsers, and the Report
19:37:47 <SamB> fracture: I think the indentation is just hard :-(
19:37:52 <fracture> another annoyance so far:  it doesn't seem to handle paragraph fill in non-multiline comments properly
19:38:08 <fracture> probably that too
19:38:17 <SamB> fracture: what does, for you?
19:38:28 <SamB> handle M-q for comments, I mean
19:38:33 <fracture> C++ mode
19:38:46 <SamB> how about conf-mode?
19:39:00 <fracture> dunno conf-mode
19:39:06 <SamB> or is that config-mode?
19:39:09 <Cale> hmm, apparently this version of haskell-mode is the newest...
19:39:09 * SamB doesn't remember
19:39:12 <fracture> generic-mode?
19:39:23 <SamB> fracture: well, it'd have to be something with comments!
19:39:23 <fracture> I dunno if that does
19:39:35 <Cale> fracture: anyway, there's another indenter available for Haskell...
19:39:41 <fracture> sh mode fails it
19:39:54 <Cale> fracture: I think it was obtained by replacing 'smart' with 'simple'
19:39:55 <fracture> I think a few modes do... probably most other than the c mode
19:40:01 <SamB> fracture: I think there's some add-on you can install that fixes it most everywhere
19:40:30 <fracture> Cale: yeah, I think I tried that one, and it seemed just like basic manual indentation
19:40:46 <fracture> which would be totally fine, except that I have hardly any clue about the rules for indenting haskell code still (heheh)
19:40:58 <Cale> fracture: Pretty much, except that it looks at the line above and tries to guess which spots you might want to line something up with
19:41:59 <SamB> fracture: you might try filladapt
19:42:03 <fracture> oh wait... I might actually be using the simple indenter
19:43:35 <Cale> If you're getting "Sole indentation" then you're not.
19:43:41 <fracture> ah ok
19:44:04 <fracture> anyway; I'll look into the mode more later... gonna stick to the problem at hand for now :)
19:44:09 <fracture> (thanks for the help though)
19:44:47 <Cale> tapping space a couple times also works, though it's annoying :P
19:45:01 <fracture> yeah ;)
19:46:57 <Cale> aha!
19:47:00 <SamB> fracture: what version of Emacs are you using, anyway?
19:47:01 <Cale> There's a setting for it
19:47:20 <fracture> gnu emacs 21.2.1
19:47:27 <fracture> cale: ah?
19:47:41 <SamB> fracture: does that have fill-paragraph-handle-comment ?
19:47:49 <fracture> btw, I was just thinking about it... is it not the same as let/in inside of a do block?
19:47:51 <SamB> it's a variable
19:47:57 <fracture> nope
19:47:59 <fracture> oh wait
19:48:04 <fracture> nope
19:48:17 <fracture> is it introduced by some mode I might not have on?
19:48:21 <fracture> (fill-mode maybe?)
19:48:41 <SamB> it's in fill.el
19:49:16 <fracture> d'oh only have elc's here for some reason
19:49:51 <fracture> err but anyway so like
19:49:53 <fracture> inside of a do
19:50:01 <fracture> if you put "in" on the next line at the same level as "let"
19:50:10 <fracture> it probably doesn't handle it as you'd mean, correct?
19:50:18 <fracture> but outside of do's people put the in on the same column, no?
19:50:53 <fracture> (at least, real world haskell does)
19:51:57 <Cale> Hmm, there is a setting for how much to indent after an if, but it seems to disregard it for the next line...
19:52:00 <murphy__> hi! question about compiling ... if i've run the runhaskell "configure" command, and then I run "build," why would I see a "run configure command first" error message?
19:52:15 <murphy__> I don't understand ... (total newbie, btw)
19:52:17 <fracture> cale: d'oh
19:52:40 <Cale> murphy__: What are you trying to compile?
19:53:38 <murphy__> I am trying to compile X11
19:53:44 <murphy__> to ultimately build xmonad
19:53:50 <jzhou> do we really need ghc to build itself?
19:53:58 <Cale> murphy__: Okay, the easiest thing to do is to get cabal-install first.
19:54:16 <Cale> murphy__: and then use that to install xmonad, which will install the other libraries you'll need
19:54:17 <hatds> fracture: you don't use 'in' inside a do
19:54:33 <murphy__> hrm. OK. Let me see if I can find that.
19:54:41 <Cale> murphy__: I'll get you a link
19:54:47 <bd_> jzhou: Yes. It lets us apply all of GHC's optimizations to itself, and also acts as a fairly tough regression test. Plus, what else will you build it with?
19:54:49 <fracture> hatds: I'm pretty sure you can if you put it on one line, eh?
19:54:50 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
19:55:07 <Cale> murphy__: ^^ inside that tarball you will find a bootstrap.sh which you should run
19:55:09 <fracture> (what if you indent the in?)
19:56:01 <Cale> It is so stupid that after all this time we still don't have a text editor which properly understands the offside rule.
19:56:04 <jzhou> bd_: thx, but is it "easy" and possible to build ghc using the official binaries for linux?
19:56:07 <hatds> fracture: yes, you can do that, but saying "let ... in ..." denotes an expression, so if you are inside a do there would still be a let without an 'in' somewhere outside it
19:56:30 <fracture> indenting works
19:56:31 <fracture> just tried
19:56:37 <bd_> jzhou: Sure, but it takes a while :)
19:56:39 <Cale> (however, if you're inside a do, there's not much reason to have a let *with* an in.
19:56:44 <fracture> main = do
19:56:44 <fracture>   let f = 2 :: Int
19:56:44 <fracture>     in putStrLn (show f)
19:56:44 <fracture>   putStrLn (show f)
19:56:48 <fracture> second use of f is out of scope
19:56:58 <fracture> Cale: to limit scope, no?
19:57:07 <jzhou> bd_: thanks for the confirmation, that encourages me to continue building :)
19:57:08 <murphy__> got it cale
19:57:08 <hatds> Cale: well, in so much as one would ever use a let inside a let
19:57:12 <murphy__> working on it now
19:57:12 <Cale> Well, yes, you might want that :)
19:57:20 <murphy__> looks like I have some more dependencies to add! hah
19:57:38 <Berengal> Limiting scope is the only reason I can think of, but in haskell expressions are usually small enough that you don't need that
19:57:41 <fracture> so anyway:  if your rationale about if/then is general, it seems we should indent the "in" further than a let also, right?
19:57:45 <fracture> (outside of do's)
19:58:10 <Cale> fracture: yeah, usually I just go with one space
19:58:17 <Cale> let foo = bar
19:58:20 <Cale>  in quux
19:58:33 <fracture> ah k, cool
19:59:10 <Cale> murphy__: Is the cabal-install bootstrap.sh not working?
19:59:30 <Cale> murphy__: It should just work, if not, it might be your ghc version.
20:00:21 <Cale> murphy__: also, Debian and Ubuntu separate a lot of the things which ghc normally comes with into separate packages, in case you're using one of those
20:01:31 <dino-> And I've seen missing deps for cabal-install with Gentoo
20:01:40 <dino-> Using an ebuild of ghc
20:02:32 <dino-> But my experience with that is low and from some months ago, so it may be out of data now. You see, they make me use Gentoo at work for the servers. Under duress.
20:03:31 <murphy__> yeah, exactly cale
20:03:40 <murphy__> I had to go into synaptic and get the http and zlib libraries
20:03:50 <murphy__> installing those now and then trying to bootstrap again
20:04:00 <Cale> okay
20:04:17 <murphy__> oh bugger
20:04:17 <dino-> murphy__: Is this Debian or Ubuntu? What GHC version are the up to?
20:04:23 <murphy__> ubuntu
20:04:25 <dino-> (Just curious)
20:04:32 <dino-> s/the/they/
20:04:32 <murphy__> getting a segfault when compiling http
20:04:45 <murphy__> 6.8.2 = version
20:05:54 <Cale> murphy__: err...
20:06:02 <Cale> @where hpaste
20:06:03 <lambdabot> http://hpaste.org/
20:06:09 <murphy__> haha, is the version too early?
20:06:11 <Cale> could you go there and paste the output?
20:06:16 <Cale> 6.8.2 is a little old
20:06:19 <Cale> But it should work
20:06:39 <murphy__> let me see if I can get a newer version
20:06:59 <dino-> murphy__: You can get the generic binary install of 6.10.3
20:07:08 <dino-> But this will be a configure ; make install thing
20:07:19 <dino-> Not all squeaky apt clean.
20:07:53 <dino-> But it's not hard to remove a GHC manually. I feel like newer GHC is worth it.
20:08:00 <murphy__> that's fine
20:08:13 <murphy__> I'd rather be up to speed than have to deal with old dependencies
20:08:17 <murphy__> and cruft
20:08:48 <dino-> Excellent. Here: http://haskell.org/ghc/download_ghc_6_10_3.html
20:08:52 <dino-> Binary Packages
20:09:14 <murphy__> got it. downloading.
20:09:48 <dino-> I don't know what the libtinfo.so.5 is about, but I got the one without "ghc-6.10.3-i386-unknown-linux-n.tar.bz2" for Debian lenny
20:10:33 <murphy__> I downloaded the same.
20:14:37 <murphy__> great! it's installing. Bootstrap is working awesome, too.
20:14:50 <murphy__> Nothing like a new build to get things running smoothly.
20:14:59 <dino-> murphy__: Cool. I was just investigating other things you may have needed like libgmp
20:15:10 <dino-> But probably your prior apt-get adventures got that.
20:15:20 <murphy__> indeed.
20:15:52 <doctormach> Is it possible to write the ((->) e) Functor instance in a pointful manner?
20:17:24 <aconbere> I'm looking at doing some profiling on a haskell application, this is my first forray into this, and I'm not sure the meaning of -auto and -auto-all
20:17:27 <murphy__> this is fantastic. Thanks for your help, dino.
20:18:02 <hatds> doctormach: you mean fmap f g e = (f . g) e ?
20:18:03 <dino-> murphy__: If you ever need to remove it (say installing a newer one), this Haskell-cafe post details directories: http://www.haskell.org/pipermail/haskell-cafe/2007-November/034362.html
20:18:46 <doctormach> hatds: Yes, thanks
20:19:08 <hatds> ghc doesn't come with an uninstall?
20:19:24 <dino-> hatds: Boy am I going to feel stupid if it does.
20:54:00 <malouin> Ok, I'm in Part II of All About Monads.
20:54:06 <malouin> Identity... check, Maybe... check, Error...
20:54:34 <malouin> I think I can't understand this because somehow Error is parameterized by another monad, and I don't see how bind and return are implemented.
20:54:42 <malouin> any ideas what I am missing?
20:54:55 <roconnor> Error is parameterized by another monad?
20:55:00 <roconnor> link?
20:55:21 <myname> quit
20:55:28 <myname> 
20:55:38 <myname> \quit
20:55:39 <malouin> http://www.haskell.org/all_about_monads/html/errormonad.html
20:55:59 <Cale> malouin: Perhaps you mean that Error is parametrised by the type of error?
20:56:15 <Cale> (Well, Either is)
20:56:21 <malouin> err, I mean MonadError needs another monad.
20:56:24 <Cale> For each type e,  Either e  is a monad.
20:56:32 <malouin> as in class (Monad m) => MonadError e m | m -> e
20:56:42 <Cale> The MonadError class only has one monad type at a time
20:56:46 <Cale> e means the type of error
20:57:13 <roconnor> ``The MonadError class is parameterized over the type of error information
20:57:28 <roconnor> oh
20:57:36 <roconnor> the class constrain isn't a parameterisation
20:57:53 <roconnor> it just means you have to make it a Monad before you can go on further and make it a MonadError
20:57:56 <dmwit> Holy!
20:58:11 <dmwit> I hit ":e Main.hs" in ghci by accident and it worked!
20:58:41 <roconnor> malouin: it is the same as how a type has to be an Ord before it can be a Num
20:58:51 <dmwit> ghci++
20:58:51 <roconnor> er
20:58:56 <roconnor> malouin: it is the same as how a type has to be an Eq before it can be a Num
20:58:59 <roconnor> @src Num
20:59:00 <lambdabot> class  (Eq a, Show a) => Num a  where
20:59:00 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:59:00 <lambdabot>     negate, abs, signum     :: a -> a
20:59:00 <lambdabot>     fromInteger             :: Integer -> a
20:59:10 <malouin> ok.
20:59:32 <roconnor> MonadError adds more methods
20:59:48 <roconnor> specifically throwError and catchError
20:59:51 <NEEDMOAR> @src (-)
20:59:51 <lambdabot> x - y = x + negate y
21:00:09 <NEEDMOAR> @src abs
21:00:10 <lambdabot> Source not found.
21:01:33 <malouin> hmm...
21:01:57 <malouin> So what is an instance of Monad?
21:02:06 <dmwit> ?instances Monad
21:02:07 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:02:37 <dmwit> ...or was that a more metaphysical question?
21:03:19 <roconnor> malouin: specific data type (constructors) are instances of Monads
21:03:29 <malouin> so I would make a data MyError... instance Monad MyError ... instance MonadError MyError...?
21:03:44 <roconnor> malouin: Identity, Maybe, or (Either String), etc.
21:03:55 <roconnor> malouin: ya
21:04:18 <roconnor> instance MonadError SomeErrorType MyError
21:04:54 <malouin> so it seems like Identity and Maybe have an associated type, but Error doesn't.
21:05:43 <Cale> malouin: hm? It's the other way around.
21:06:05 <Cale> malouin: Error has an extra associated type which Identity and Maybe don't have
21:06:30 <malouin> I am trying to refer to 'data Maybe a = Nothing | Just a
21:06:33 <roconnor> malouin: I'm not sure what you mean by associated type.  A type parameter?
21:06:41 <malouin> as the "type" associated with Maybe
21:06:49 <malouin> and by associated I mean instance Monad Maybe
21:06:55 <Cale> malouin: vs.  data Either a b = Left a | Right b ?
21:07:04 <Cale> and instance Monad (Either e) ?
21:07:06 <malouin> Cale: good point.
21:07:18 <Aleran> if I have a function that accepts three arguments and a list with three elements, how can I pass the contents of that list as the arguments for the function?
21:07:41 <Cale> Aleran: I suppose you can pattern match the list...
21:08:24 <Cale> Aleran: case myList of [x,y,z] -> f x y z; _ -> ... what if the list has a different number of elements ...
21:08:25 <roconnor> Aleran: let [a,b,c] = param in foo a b c -- however using a list is like this is somewhat indicates a poor design.
21:11:45 <Aleran> thanks. I'll try to figure this out. Or rework my design.
21:12:49 <dmwit> It doesn't necessarily indicate bad design.  I've had a few cases where I've wanted such a thing, especially using the list monad.
21:13:02 <dmwit> replicateM 3 -- guaranteed to return lists of length 3, but no way to see that from the type
21:13:16 <roconnor> dmwit is right.  It isn't always bad
21:13:19 <malouin> Is there a datatype in the standard library that is an instance of Error, MonadError?
21:13:29 <dmwit> roconnor is also right.  It is a code smell.
21:13:36 <dmwit> <3
21:13:44 <roconnor> malouin: String is an instance of Error
21:13:55 <roconnor> malouin: and (Either String) is an instance of MonadError
21:14:34 <malouin> is there some code that I could look at that defines Either String as an instane of MonadError?
21:16:12 <malouin> well, actually nm, that is staring right at me here.
21:17:04 <malouin> Either e is a Monad...
21:17:45 <ksf> ...and every m Error is a MonadError
21:17:52 <ksf> that's the instance you'll have to look for.
21:17:57 <roconnor> malouin: only when e is an instance of Error
21:18:16 <roconnor> (according the the mtl (monad transformer library))
21:18:16 <ksf> Monad m => m Error , that is.
21:18:35 <roconnor> ksf: that's not quite right
21:18:44 <roconnor> Error is a class, not a type.
21:18:51 <ksf> yeah, I figure I looked into the wrong crystal ball.
21:19:06 <malouin> Error a => Either a is a Monad?
21:20:39 <roconnor> malouin: yes
21:21:16 <roconnor> malouin: (according to the mtl)
21:24:00 <dmwit> ?src MonadError
21:24:00 <lambdabot> class (Monad m) => MonadError e m | m -> e where
21:24:00 <lambdabot>     throwError :: e -> m a
21:24:00 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
21:24:11 <malouin> aha, I found what I am looking for in the Control.Monad.Error source
21:24:29 <malouin> instance (Error e) => Monad (Either e) where
21:24:37 <malouin> instance (Error e) => MonadError e (Either e) where ...
21:24:38 <dmwit> Use the source, Luke!
21:24:47 <malouin> :)
21:25:33 <dmwit> I had a colleague once who said he liked C because even the most basic functions are implemented as a library.
21:25:53 <dmwit> I didn't think of it at the time, but I should have told him I like Haskell because even the most basic functions are implemented as a readable library.
21:27:13 <Cale> dmwit: A *readable* library
21:27:31 <dmwit> Right. =)
21:27:41 <dmwit> That emphasis is important.
21:28:34 <Cale> Though some of the most basic functions in Haskell are primops...
21:28:47 <Cale> But not too many.
21:28:58 <dmwit> Yeah, the analogy doesn't quite play over.
21:29:09 <dmwit> If you want to use a different allocator, for example, that's a lot harder in Haskell than in C.
21:30:16 <bruce`> I have a question -- should I just go ahead and shoot?
21:30:26 <dmwit> Yes.
21:30:31 <QtPlaty[HireMe]> bruce`: Yes
21:30:42 <dmwit> If it involves more than a line or two of code, paste it on the web somewher.
21:30:46 <dmwit> ?hpaste is a good one
21:30:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:31:49 <dmwit> Cale: Of course, the things that are primops in Haskell aren't exactly library functions in C, either. Int+# or whatever, for example.
21:31:57 <Cale> yeah
21:32:30 <malouin> ok, this is starting to make sense.
21:32:50 <dmwit> malouin: Oh no! Quick, tackle something harder!
21:32:54 <bruce`> So, I'm generating a really long combinatorial list.  I want to do statistics on it -- basically, a kind of histogram, but with multiple counters, arrays, etc.  I want to go through the combinatorial list once, and generate all the statistics.
21:32:58 <dmwit> Monad transformers, or arrows, maybe.
21:32:58 <malouin> thanks roconnor,Cale,dmwit ksf
21:33:14 <malouin> dmwit: well, I'm trying to work my way towards understanding monad transformers.
21:33:27 <malouin> because I need some IO + state.
21:33:29 <dmwit> malouin: No problem.  Once you get monads, monad transformers are very nearly trivial.
21:33:52 <Cale> malouin: Are you sure that you need State?
21:34:05 <dmwit> bruce`: Sounds like fun!
21:34:05 <Cale> malouin: IO already has a lot of state mechanisms built into it.
21:34:20 <dmwit> bruce`: What have you tried so far?
21:34:53 <Cale> bruce`: Sounds for a job for foldl' and a record datatype with strict fields for each of the statistics.
21:34:58 <Cale> sounds like*
21:35:09 <bruce`> I think the way to do this properly is with mutable arrays, and this would be simple if there were only one accumulator array -- use STUArray or whatever.  But I'm not sure how to make it work if you want a structure-of-arrays: an arbitrary conglomerate of arrays, individual counters, and so forth...
21:35:10 <bruce`> .
21:35:30 <malouin> Cale: basically, I am working from dons's "roll your own" IRC bot, and I want my bot to remember things.
21:35:52 <dmwit> bruce`: Mutable arrays?  ...in the accumulator?
21:35:56 <dmwit> That sounds a bit odd.
21:36:31 <Cale> malouin: It's already a Reader, yeah?
21:36:33 <dmwit> I'm with Cale on this one: an own data type seems like the way to go.
21:36:55 <Cale> malouin: You can just add IORefs to the Bot datatype that store the state.
21:36:55 <malouin> Cale: yes
21:37:28 <malouin> ah, hmm... sounds like ocaml style.
21:38:00 <Cale> malouin: Well, given that the machinery is already there, you might as well use it :)
21:38:15 <dmwit> There are pointers in every language, if you know where to look. ;-)
21:38:28 <malouin> Wah, ok, awesome.
21:39:02 <Cale> malouin: Another option to consider is just to pass the state around by hand in the parameters.
21:39:05 <bruce`> I'm doing a histogram -- basically, each element of the combinatorial list is scored, in multiple ways, and the appropriate member of the histogram needs to be incremented.  The problem is, if you use a list, you'll need to go through the entire list to increment one element.  If you use a Map, you'll need to go through log N elements.  But if you use an updateable array, you get the famous O(1) performance... but if you have multiple
21:39:06 <bruce`> arrays, I'm not really sure how to do that in Haskell.  Or, *if* you can do that in Haskell...
21:39:16 <malouin> Cale: yes, I tried that... briefly ;)
21:39:33 <Cale> malouin: If you have a small loop for the bot, that's usually not too bad, but for complicated things, it gets annoying.
21:39:45 <dmwit> bruce`: You're right, a mutable array does sound just right for a histogram.
21:39:58 <dmwit> bruce`: You should learn about the ST monad; it's perfect for this kind of thing.
21:40:12 <Cale> How many entries will the histogram have?
21:40:33 <Berengal1> How about a diffarray?
21:40:34 <dmwit> Cale: n-tuple? =)
21:41:13 <Cale> dmwit: No, I was going to say that if you can quantify that, the accesses on Data.Map become O(1) magically :)
21:41:26 <bruce`> There are (currently) two scores (each with their own histogram), and two individual counters (one of which is a total counter).
21:41:30 <dmwit> =)
21:41:58 <Cale> I would seriously consider using Data.Map to accumulate the histogram, and only replace it after determining that it was really too slow.
21:42:01 <dmwit> Cale: I like my n-tuple idea better, for its qualities as a joke-suggestion. =)
21:42:24 <Cale> Having a nice pure immutable datatype is so much nicer to work with than anything mutable.
21:42:42 <Cale> and it really can be quite efficient up to reasonably large sizes
21:44:12 <bruce`> I've been looking at the ST monad, which does seem to be the right thing to use.  What I don't understand is the connection to mutable arrays.  Each mutable array is a monad in its own right, as I understand it; what I sort of doubt is that just making an ST monad out of a datastructure with mutable arrays in it will cause everything to Just Work...
21:44:30 <Cale> No... the mutable arrays themselves are not monads :)
21:44:35 <dmwit> Mutable arrays are not monads.
21:44:47 <Cale> (nor are they even monadic computations, but there are monadic computations which produce them)
21:44:53 <dmwit> Not even mutable, one-element arrays, even though they seem just like Identity.
21:45:26 <bruce`> OK, so how would it work, then?  How does the ST monad know about/deal with mutable arrays?
21:45:30 <Cale> So for STArray, you'd use the MArray interface
21:45:45 <mauke> ST provides mutable variables, including arrays
21:46:00 <dmwit> bruce`: ST provides its own mutable array type with read and write operations that yield ST actions.
21:46:02 <Berengal1> Note that mutable boxed arrays are slow
21:46:21 <dmwit> Berengal1: I didn't find them so when I was using them.
21:46:39 <Cale> and you'd use newArray or newListArray to create a new array, and then start filling/modifying it with readArray and writeArray
21:47:37 <Cale> newArray takes a pair of indices (the smallest and largest), an initial element to fill the array with, and gives an ST computation which when executed produces a new array with those bounds and initialised as required.
21:47:53 <bruce`> OK, so I'd put *references* to the mutable arrays in the datastructure, then make the ST monad with the datastructure as the state?
21:48:03 <Berengal1> dmwit: The GC has to scan the entire array if it has been mutated inbetween runs
21:48:40 <Cale> bruce`: Well, if you're doing it this way, you might as well just create the arrays inside the ST computation, and freeze them into plain Arrays at the end
21:48:43 <mauke> bruce`: ST has no hidden state
21:49:00 <bruce`> Yeah, if I'm interested in the mutable arrays at all I should use the unboxed ones in this case.
21:49:03 <Cale> You shouldn't need an additional datastructure I would think...
21:49:10 <Cale> I'll make an example...
21:49:24 <dmwit> Cale: He'll probably want an additional datastructure if he's going to have two arrays and some counters.
21:49:38 <Cale> dmwit: Well, you can just make them parameters if there are so few.
21:49:48 <Cale> (to your loop)
21:49:49 * dmwit shrugs
21:49:54 <dmwit> design choice, I guess
21:50:15 <dmwit> Data structures are easier to extend in the future than parameter lists.
21:51:44 <bruce`> Really, this is more of an exercise than anything else -- I'm mainly interested in knowing *how* to do this kind of thing in cases where the performance really is critical 8^)
21:52:10 <Cale> or, in fact, not even parameters
21:52:20 <Cale> but define the loop directly in the do-block inside a let
21:53:06 <dmwit> Yeah, that seems more like it.
21:53:22 <Cale> or, perhaps forM
21:53:34 <Cale> all the stuff will be in scope
21:56:03 <dmwit> Cale++ MonadRandom is awesome
21:56:14 <dmwit> I keep finding places where it's exactly what I wanted.
21:57:12 * dmwit checks to see if it's on Hackage yet
22:01:05 <Cale> bruce`: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5307#a5307
22:01:58 <Cale> bruce`: That's a silly program, but it should illustrate the idea.
22:02:15 <bruce`> OK, thanks -- let me look at it...
22:02:32 <Cale> bruce`: But to be honest, I would use a Data.Map and a foldl' :)
22:02:42 <pumpkin> but the speed!
22:02:57 <Cale> Let's see...
22:03:09 <pumpkin> I don't actually think it'll be noticeably different :P
22:03:48 <bruce`> I'll try it out on my own application in all three ways and see if it actually is noticabley different 8^)
22:04:01 <bruce`> Might take a while, though.
22:05:00 <Cale> haha
22:05:16 <Cale> My Data.Map version just beat the STUArray one
22:05:28 <pumpkin> nice :)
22:05:31 <Cale> But, let me get a better string
22:05:33 <pumpkin> -O2 ?
22:05:37 <Cale> No, in ghci
22:05:42 <pumpkin> ah
22:05:45 <Cale> Perhaps I should actually compile it
22:06:14 <pumpkin> would probably be even faster as an IntMap, assuming ghc isn't slow at doing ord
22:06:15 <aconbere> I'm trying to take a look at some profiling info for my app. I've compiled it with -prof -auto-all and run it with +RTS -p
22:06:19 <aconbere> and I get a .prof file
22:06:22 <rzezeski> Can someone please tell me how I could implement the following in Haskell...
22:06:22 <aconbere> but it's empty
22:06:25 <rzezeski> user=> (map #(filter odd? %) [[3,5,6] [6 8 9] [1 2 10]])
22:06:25 <rzezeski> ((3 5) (9) (1))
22:06:34 <rzezeski> the above is Clojure
22:06:43 <Cale> map (filter odd)
22:06:48 <pumpkin> > map (filter odd) [[3,5,6] [6 8 9] [1 2 10]]
22:06:49 <rzezeski> I tried that
22:06:49 <lambdabot>   Couldn't match expected type `t -> t1 -> [a]'
22:06:51 <dmwit> Cale: I bet accumArray beats both of them...
22:07:01 <Cale> > map (filter odd) [[3,5,6] [6,8,9] [1,2,10]]
22:07:02 <lambdabot>   Couldn't match expected type `t -> t1 -> [a]'
22:07:11 <Cale> > map (filter odd) [[3,5,6],[6,8,9],[1,2,10]]
22:07:13 <lambdabot>   [[3,5],[9],[1]]
22:07:14 <Cale> damn spaces :)
22:07:17 <Cale> hehe
22:07:20 <pumpkin> lol
22:07:25 <pumpkin> had my scratching my head, sadly
22:07:36 <pumpkin> rzezeski: that's valid clojure?
22:07:48 <pumpkin> with that inconsistent space/comma thing?
22:08:04 <dmwit> I sometimes wish Haskell would ignore commas in more places.
22:08:12 <dmwit> Like at the end of record declarations and stuff.
22:08:19 <rzezeski> bah, I did the same thing and that's why it didn't work, since I'm a newb in Haskell I thought it was the type system killing me
22:08:20 <dmwit> or allow things like [3, 4, 5,]
22:08:25 <mauke> dmwit: just use perl :-)
22:08:31 <rzezeski> pumpkin: yes, commas are optional
22:08:37 <pumpkin> ack :P
22:08:54 <mauke> [3, 4,, 5,,,]
22:09:07 <dmwit> eww
22:09:08 <Cale> Okay, once compiled, the STUArray version is marginally faster
22:09:12 <dmwit> I don't want *that*.
22:09:15 <rzezeski> I was mixing Haskell and Clojure syntax, excuse me :)
22:09:20 <Cale> 0m1.056s vs. 0m1.412s
22:09:24 <pumpkin> ah
22:09:32 <aconbere> anybody profile info?
22:09:49 * Cale makes a bigger example
22:10:16 <jeffz``> aconbere: is your program exiting normally?
22:10:53 <Cale> 0m8.349s vs. 0m9.593s
22:11:06 <Cale> So it appears to be mostly in the constant term!
22:11:11 <aconbere> jeffz`: you know what... I thought it was, but now that I think about it perhaps the way I'm exiting is invalid
22:11:14 <Cale> That's surprising.
22:11:55 <pumpkin> Cale: I'd imagine if you exponentially increased the size of your alphabet, you'd notice more of a difference, and a much bigger memory footprint :P
22:11:55 <Cale> bruce`: Anyway, that should give some idea of the difference between STUArray and Data.Map.
22:12:05 <Cale> pumpkin: Well, perhaps, yes.
22:12:17 <Cale> pumpkin: but not *that* much.
22:12:23 <pumpkin> nope :)
22:12:27 <jeffz`> aconbere, I think I've noticed in the past that exiting prematurely or just at the wrong moment leaves an empty .prof
22:12:44 <Cale> Well, as the size of the alphabet increases exponentially, you'll get a linear slowdown in the map.
22:12:50 <pumpkin> exactly
22:13:00 <pumpkin> and you'll get an exponential increase in memory for the array
22:13:04 <pumpkin> which is awesome
22:14:25 <Cale> Well, to be fair, there will be a similar increase in memory for the Map assuming that the whole alphabet gets used
22:14:52 <pumpkin> yeah :)
22:15:14 <Cale> But if there's a possibility that the data is sparse, the Map will kill it :)
22:15:45 <pumpkin> IntMap should allow things like Chars to be inserted into it
22:15:52 <pumpkin> anything trivially mappable to an Int
22:15:52 <bruce`> Actually, if the histogram is too big, I'd expect serious cache-coherence problems -- in that case, a Map might well be more efficient.  (though for my current application this is not the case)
22:16:17 <Cale> bruce`: How many entries in the histogram?
22:16:29 <pumpkin> class Intable a where intate :: a -> Int
22:16:35 <Cale> by the way, the pure version is:  countLetters' = foldl' (\m x -> M.insertWith' (+) x 1 m) M.empty . filter isAlpha . map toLower
22:16:36 <pumpkin> ;)
22:16:46 <Cale> pumpkin: haha
22:17:19 <pumpkin> or fromListWith' (+) . flip zip (repeat 1)
22:17:24 <pumpkin> I think that should work
22:17:33 <bruce`> However many you want -- but I've been using maybe 100 or so.  Also, the distribution should be skewed -- which might concievably make a list more efficient than either 8^\
22:17:34 <Cale> yeah, it should
22:17:36 <pumpkin> obviously with the isAlpha and toLower
22:18:08 <Cale> bruce`: I suspect Data.Map will be close enough in performance, and has a much nicer interface than any of the other options.
22:18:25 <smithll> Hi, I am playing with quickcheck2 and I am trying to get a non empty list of positive integers...
22:18:28 <smithll> prop_test_pos :: (Integral a) => [Positive a] -> Bool
22:18:31 <smithll> prop_test_pos xs = all (>0) xs
22:18:34 <smithll> positve seems to work...
22:18:43 <smithll> prop_test_list :: (Num a) => NonEmptyList [a] -> Bool
22:18:43 <smithll> prop_test_list xs = not $ null xs
22:18:47 <smithll> but this doesn't
22:18:49 <Cale> It's sort of my default associative data structure. :) It's only when it doesn't work that I'll consider switching to something else.
22:19:04 <pumpkin> whatever you do, don't use HashTable
22:19:58 <Cale> Well, along with functions ;)
22:20:39 <Cale> Functions tend to be really bad finite map structures if you're doing lots of inserts though :)
22:21:13 <Cale> Basically as bad as association lists.
22:21:14 <pumpkin> I'd actually really like to see ghc not get painfully slow for functions with a lot of patterns
22:21:17 <Aleran> is this the best way to do call a function on every element on a list and then sum the results?
22:21:26 <bruce`> Ungh, I don't thing I'm going to get this done tonight.  Thanks for the tips, everyone;  I'll try and log in tomorrow and let you know how it goes.
22:21:30 <Aleran> sum (map numAsWord [1..100])
22:21:40 <pumpkin> alright, bbiab
22:21:40 <Cale> Aleran: yep :)
22:22:02 <inimino> numAsWord?
22:22:12 <inimino> @ty numAsWord
22:22:14 <lambdabot> Not in scope: `numAsWord'
22:22:27 <Aleran> numAsWord is my own function sorry
22:22:28 <inimino> ...?
22:22:30 <inimino> oh
22:22:30 <Cale> inimino: I suspect it's something he wrote himself
22:22:36 <smithll> not $ null []
22:23:13 <Cale> newtype NonEmptyList a = NonEmpty [a]
22:23:16 <Cale> this is the problem
22:23:18 <inimino> oh, I missed the part where he said "call a function on every element"
22:23:21 <dmwit> smithll: I suspect the problem is that NonEmptyList [a] is not the same type as [b] for any b.
22:23:29 <Cale> prop_test_list (NonEmpty xs) = not $ null xs
22:23:35 <Cale> ^^ smithll
22:23:39 <dmwit> smithll: (Without specifically seeing your code, it's hard to say more than that.)
22:23:58 <smithll> I wll give that a try
22:23:59 <Cale> Prelude Test.QuickCheck> quickCheck (\(NonEmpty xs) -> not (null xs))
22:23:59 <Cale> +++ OK, passed 100 tests.
22:24:34 <Cale> The newtypes are rather convenient even with lambdas, because of the explicit tag :)
22:24:35 <hackagebot> windowslive 0.2
22:24:56 <dmwit> Oh, NonEmptyList is a type defined by quickcheck. ^_^
22:25:19 <Cale> Right, it just tweaks the random generator :)
22:25:44 <Cale> Prelude Test.QuickCheck Data.List> quickCheck (\(Ordered xs) -> sort xs == xs)
22:25:44 <Cale> +++ OK, passed 100 tests.
22:26:54 * Cale wonders
22:27:07 <Cale> @check \(Ordered xs) -> sort xs == xs
22:27:08 <lambdabot>   Not in scope: data constructor `Ordered'
22:27:29 <mmorrow> Peaker: coroutines: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5308
22:27:31 <Cale> I suppose I'll have to upgrade the QuickCheck at some point
22:30:14 <Cale> Oh, right, the new one is installed, but for whatever stupid reason, it seems that global packages have priority over user ones
22:30:54 <Cale> Hmm...
22:34:14 <aconbere> jeffz`: thanks that got me going :)
22:35:39 <smithll> So putting it all together a non empty list of postive would look something like this...
22:35:46 <smithll> prop_test_pos :: (Integral a) => [Positive a] -> Bool
22:35:46 <smithll> prop_test_pos xs = all (>0) xs
22:35:46 <smithll> prop_test_list :: (Num a) => NonEmptyList [a] -> Bool
22:35:46 <smithll> prop_test_list (NonEmpty xs) = not $ null xs
22:35:46 <smithll> prop_test_pos_not_null :: (Integral a) => NonEmptyList [Positive a] -> Bool
22:35:48 <smithll> prop_test_pos_not_null (NonEmpty xs) = all (>0) xs && (not $ null xs)
22:36:11 <smithll> but that gives...
22:36:17 <smithll>     Could not deduce (Num [Positive a]) from the context (Integral a)
22:36:17 <smithll>       arising from the literal `0' at Commodity.hs:114:45
22:36:17 <smithll>     Possible fix:
22:36:17 <smithll>       add (Num [Positive a]) to the context of
22:36:17 <smithll>         the type signature for `prop_test_pos_not_null'
22:36:19 <smithll>       or add an instance declaration for (Num [Positive a])
22:36:21 <smithll>     In the second argument of `(>)', namely `0'
22:36:24 <smithll>     In the first argument of `all', namely `(> 0)'
22:36:26 <smithll>     In the first argument of `(&&)', namely `all (> 0) xs'
22:36:42 <povman> Is there any point in converting a FunPtr to a StablePtr?
22:38:00 <sjanssen> smithll: please don't paste so much in the channel
22:38:05 <smithll> sorry
22:38:40 <mmorrow> @paste
22:38:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:39:01 <copumpkin> moo
22:39:10 <copumpkin> http://world.cs.brown.edu/ would approve
22:39:11 <mmorrow> omnomnom
22:39:14 <dmwit> smithll: You probably want NonEmptyList (Positive a).
22:39:44 <Lemmih> povman: I'd say no.
22:40:07 <Cale> yep, that's the problem :)
22:40:19 <povman> Lemmih: Leet. I'll have that patch for you soon...
22:40:20 <smithll> dmwit: yes, that seems to work. Thanks
22:40:31 <copumpkin> dammit, someone outdid us on pidigits again
22:40:51 <Lemmih> povman: Refresh my memory, what patch?
22:41:39 <dmwit> copumpkin: Well, if we can parallelize it... =)
22:41:40 <povman> Lemmih: Apologies - I mean the one that lets Sdl start in haskell rather than C
22:41:50 <sjanssen> copumpkin: that's what you get for publicizing it
22:41:55 <copumpkin> I know :(
22:43:05 <Lemmih> povman: Oh, you're Luke Worth.
22:48:12 <copumpkin> seems like the fastest pidigits entry avoided a division
22:56:03 <Gracenotes> copumpkin: indeed, it seems we are no longer #1!
22:56:18 <copumpkin> there's an optimization to be had in ours at least
22:56:31 <copumpkin> their entry is only performing one division per iteration
22:56:35 <copumpkin> ours is doing two
22:56:45 <copumpkin> but they've shuffled things around a bit so I'm not sure how to do that too
22:59:36 <Gracenotes> WE ARE AT WAR
22:59:42 <Gracenotes> o_O
23:03:43 <cnwdup> Is it possible to load a data Plugin s using System.Plugins or does s has to be known at compile time?
23:06:44 <hackagebot> linear-maps 0.5
23:06:49 <Lemmih> cnwdup: It has to be known at compile time.
23:07:15 <cnwdup> Lemmih, why?
23:07:16 <Lemmih> cnwdup: You could probably hide it and use Data.Typeable, though.
23:08:03 <Lemmih> cnwdup: Because 'Plugin s' doesn't exist. Only concrete data exists.
23:08:23 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2504#a2504 So this won't be possible?
23:08:46 <cnwdup> toAnyPlugin maps Plugin s to AnyPlugin. Tell me if you need the code for that.
23:09:03 <cnwdup> (Relevant are the first 4 lines of main and loadPlugin.
23:09:05 <cnwdup> )
23:10:43 <Lemmih> Should all the plugins have the same type?
23:11:00 <cnwdup> Plugin s is a plugin with the state s. In fact every plugin should have a different s.
23:11:15 <cnwdup> But I try not to operate on s from the main application so I thought it'd be fine.
23:11:33 <cnwdup> s/try not to/do not/
23:11:34 <Lemmih> cnwdup: Why not hide the type parameter?
23:11:42 <cnwdup> Lemmih, how?
23:12:00 <cnwdup> I thought I was doing this with toAnyPlugin.
23:12:11 <Lemmih> cnwdup: data Plugin = forall s. Plugin { getState :: IO s, setState :: s -> IO () }
23:13:00 <cnwdup> Let me try that.
23:13:01 <Lemmih> cnwdup: You definitely have to change 'loadPlugin'.
23:13:54 <Lemmih> cnwdup: 'mapM loadPlugins fns' gives you 'forall s. [Plugins s]'. You're interesting in '[forall s. Plugin s]'.
23:15:17 <cnwdup> I cannot hide s because I'd like to query the plugin's state from within another plugin. And I want static type checking for that.
23:15:23 <cnwdup> Lemmih, how would that change look like?
23:15:35 <Lemmih> cnwdup: Use Data.Typeable for that.
23:15:52 <cnwdup> What's the difference between forall s. [Plugin s] and [forall s. Plugin s]?
23:16:11 <Lemmih> cnwdup: getState :: IO Dynamic.
23:17:07 <cnwdup> Lemmih, then the compiler cannot tell me if I am doing something wrong.
23:17:08 <Lemmih> cnwdup: The first one is a list of plugins with the same 's' parameter. The second is a list of plugins with their own 's' parameter.
23:17:40 <cnwdup> Lemmih, how can I achieve the second one?
23:17:52 <Lemmih> cnwdup: That's right. It's impossible to statically check that.
23:18:15 <Lemmih> cnwdup: data Plugin = forall s. Plugins { ...
23:19:22 <cnwdup> Okay. Thank you.
23:20:30 <cnwdup> But it should be possible to statically check it in the plugin's code. And I'd like to maintain this kind of safety.
23:20:59 <cnwdup> Say Plugin Int includes the module of Plugin String and wants to query the Int. It knows the state and knows how to operate on that.
23:21:24 <cnwdup> In the main application I do wrap the states using Dynamics. But I do not want that the be at Plugin level because I loose static type safety.
23:21:41 <cnwdup> *lose
23:21:42 <Lemmih> cnwdup: But what if it is wrong? What if it thinks it's a 'Plugin Int' but it really is a 'Plugin Char'.
23:22:50 <cnwdup> Then the plugin cannot and should not be compiled. But since Plugin Char includes Plugin Int it knows if there's something wrong with the plugin code.
23:22:53 <Lemmih> cnwdup: You cannot get compile-time guarantees of code you'll load at run-time.
23:23:08 <cnwdup> If something goes wrong in the main application where I use Dynamics I cannot do something about that.
23:23:16 <cnwdup> But in the plugin code I feel like I can.
23:23:57 <Lemmih> Maybe I don't understand what you're trying to do.
23:24:10 <cnwdup> Would you mind if I post the plugin's code?
23:24:44 <Lemmih> What you're trying to do seems impossible if you subscribe to a linear understanding of time,
23:25:29 <cnwdup> I think it is possible but I might explain it inadequate.
23:25:32 <Lemmih> It's a free internet. You can paste anything you want.
23:26:42 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2506#a2506 those are my plugins. In PluginB i know the type of PluginA and I just want to ensure that PluginB operates on the correct state (an Int) and not confuses it with something different.
23:27:15 <cnwdup> In the main application I load the plugin and wrap everything in Dynamics. But at plugin level I do not see why I can't guarantee type safety.
23:27:44 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2505#a2505 here's the plugin code. line 31-34 and 69-77 are relevant only.
23:29:09 <cnwdup> I think I could put the toAnyPlugin call in the Plugin code. But I feel it doesn't belong in there.
23:31:30 <Lemmih> cnwdup: Ah, you need to convert the plugins to AnyPlugins immediately after you load them.
23:31:42 <cnwdup> I try that in main. But it doesn't work.
23:31:55 <Lemmih> cnwdup: loadPlugin :: FilePath -> IO AnyPlugin
23:32:29 <cnwdup> would it be the same to write mapM (toAnyPlugin inChan <$> loadPlugin) fns?
23:33:24 <cnwdup> Eh,   plugins <- mapM (\fn -> loadPlugin fn >>= toAnyPlugin inChan) fns
23:34:03 <copumpkin> do I need anything but MagicHash to use strict pairs?
23:34:07 <copumpkin> unlifted pairs?
23:34:12 <copumpkin> the (# #) things
23:34:17 <Lemmih> copumpkin: Unboxed tuples.
23:34:23 <copumpkin> that's what I meant :P
23:34:38 <Lemmih> copumpkin: -XUnboxedTuples
23:34:43 <copumpkin> oh I see :)
23:34:45 <copumpkin> thanks
23:34:58 <Lemmih> cnwdup: It may work.
23:35:37 <kniu> I'm trying to write something impressive so that my mom won't think learning Haskell is a waste of time.
23:35:46 <Lemmih> cnwdup: I'd create a new type 'data NoType;' and then change loadPlugin to 'FilePath -> IO (Plugin NoType)'.
23:35:51 <kniu> Is there an easy-to-use graphics library so that I can whip up some games?
23:35:53 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2507#a2507 (changed loadPlugin), now I get Ambiguous type variable s in the constraint Typeable s arising from the use of toAnyPlugin (line 82).
23:36:20 <Lemmih> cnwdup: Yes, hence NoType. Using '()' would also cut it.
23:37:10 <rob__> Hi! I have a question about HaXml, maybe somebody could point me in the right direction
23:37:13 <cnwdup> Lemmih, can you explain that? I don't see why this error is being reported and how your solution would help.
23:37:36 <rob__> I have used DtdToHaskell to generate my Haskell types from my DTD file
23:38:03 <rob__> and now I'd like to read an actual XML file that references this DTD
23:38:20 <rob__> I'm using fReadXml for that
23:38:26 <Lemmih> cnwdup: Loading a value of type 'a' doesn't make sense. Similarly it is imposible to load a 'Plugin s'. You must give it a concrete type.
23:38:44 <rob__> like this: contents <- fReadXml xmlFile
23:39:04 <cnwdup> Lemmih, with "loading" do you mean the result of loadPlugin or the result of load_?
23:39:08 <Lemmih> cnwdup: () and NoType should work since you're not using the type at all.
23:39:27 <rob__> the error I'm getting is:    Ambiguous type variable `a' in the constraint:
23:39:27 <rob__>       `XmlContent a'
23:39:27 <rob__>         arising from a use of `fReadXml' at processxml.hs:29:26-41
23:39:27 <rob__>     Probable fix: add a type signature that fixes these type variable(s)
23:39:41 <Lemmih> cnwdup: The result of load_.
23:40:10 <cnwdup> Lemmih, so I have to change the type of toAnyPlugin for that, don't I?
23:40:11 <dmwit> rob__: In the future, please post long code and errors to hpaste.
23:40:23 <dmwit> rob__: Now that you've transgressed, though... have you tried following GHC's advice?
23:40:32 <dmwit> (i.e. adding an explicit type signature?)
23:40:39 <rob__> I frankly don't understand it unfortunately
23:40:50 <Berengal> > read "123"
23:40:52 <lambdabot>   * Exception: Prelude.read: no parse
23:41:03 <dmwit> rob__: fReadXml is polymorphic in its return type.
23:41:12 <rob__> ok
23:41:15 <dmwit> rob__: That kind of polymorphism is a little bit tricky to do inference on, right?
23:41:25 <rob__> sure
23:41:27 <Lemmih> cnwdup: Probably.
23:41:28 <dmwit> Because how do you know what type it should return?
23:41:37 <dmwit> So, you sometimes have to tell it what type it should return.
23:41:43 <dmwit> This is one such case.
23:41:53 <rob__> ok
23:42:08 <cnwdup> Lemmih, if I change it from Plugin s to Plugin () (or something hiding the type) I cannot do the wrapping/un-wrapping using Dynamics.
23:42:15 <Lemmih> cnwdup: It's important to realise why it conceptually makes no sense to load a 'Plugin s' value.
23:42:19 <dmwit> As Berengal demonstrated above, this is commond for things with "read" in their name. =)
23:42:36 <dmwit> > (read "123" :: Int, read "123" :: Rational, read "()" :: ())
23:42:37 <lambdabot>   (123,* Exception: Prelude.read: no parse
23:42:44 <dmwit> > (read "123" :: Int, read "123 % 3" :: Rational, read "()" :: ())
23:42:46 <lambdabot>   (123,41 % 1,())
23:42:56 <cnwdup> Lemmih, yeah. I do not see that. I want ghc to load Plugin s of a given s but any s. Shouldn't that be possible? I do not operate on s.
23:43:12 <Lemmih> cnwdup: I'd move the AnyPlugin code into the plugin code and then never load a 'Plugin s'.
23:43:23 <cnwdup> Lemmih, that'd be best I guess.
23:43:27 <Lemmih> cnwdup: It is if you hide the 's'.
23:43:29 <rob__> so something like: fReadXml xmlFile :: IO XML ?
23:43:44 <dmwit> Seems reasonable to me.
23:44:39 <bnijk> what's the name of that haskell OS?
23:44:45 <Berengal> bnijk: House?
23:45:01 <bnijk> maybe
23:45:20 <cnwdup> Are there libraries to modify Haskell sources using haskell? Like parsing a function and rewriting it?
23:45:43 <Berengal> cnwdup: Like template haskell?
23:45:51 <Lemmih> cnwdup: Haskell-src-exts is fairly good.
23:45:52 <rob__> hm that's not working, I'd have to define a class XML then, right?
23:46:04 <cnwdup> Berengal, Lemmih, thanks. I'll take a look at both.
23:46:06 <Berengal> rob__: Not a class, a type
23:46:48 <Berengal> rob__: But you said you had already generated these, did you not?
23:48:15 <rob__> yeah that's the thing
23:48:44 <rob__> I was using this tool DtdToHaskell from the HaXml package to automatically convert the DTD to Haskell types
23:49:03 <dmwit> rob__: How about you comment out the error-filled part of the code, then use :i to find out what instances of XmlContent are available to you?
23:49:11 <rob__> what I want to do now is reading the values from an actual xml document
23:50:50 <rob__> oh I did not know about this option, thank you very much
23:59:49 <rob__> dmwit, thanks a bunch, this brings me a little further
