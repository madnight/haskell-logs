00:01:14 <bombshelter13_> Most of the info on the 'interfacing other languages' page on the wiki is about accessing other languages from a haskell program... where can I learn about the reverse?
00:01:53 <sjanssen> bombshelter13_: the FFI addendum?
00:02:02 * bombshelter13_ seeks that out.
00:03:23 <Pingray> This? http://www.haskell.org/haskellwiki/FFI
00:07:25 <Gracenotes> hm. how would on go about adding support for another language?
00:07:33 <Gracenotes> hypothetically
00:07:38 <Gracenotes> what needs to be done at a basic level?
00:09:04 <povman> Gracenotes: What do you mean by another language?
00:09:19 <sjanssen> the most practical thing would be to give that language an interface to C, and use the C FFI
00:09:42 <wli> e.g. Mercury <-> C <-> Haskell
00:09:51 <Gracenotes> essentially -- would it be possible to link into another language in the same way one could link into C?
00:10:16 * Gracenotes is aware of the blah-to-C-to-Haskell approach
00:10:26 <Hunner> What is the difference between Int and Integer?
00:10:30 <wli> No, you end up being stuck with C as an intermediate step to link, at least in Haskell. It's clearly possible in principle.
00:10:32 <Gracenotes> like Smalltalk. or (for masochists) C++
00:10:43 <povman> Hunner: Integer is unbounded
00:10:50 <Gracenotes> we can link to assembly, right?
00:10:53 <cinimod> Is there a cabal irc channel?
00:10:55 <povman> Hunner: Int is a system integer
00:11:17 <zakwilson> After manually upgrading GHC, how do I tell cabal to recompile the libraries I had installed on the previous version?
00:11:17 <sjanssen> Gracenotes: given a C-like calling convention, sure
00:11:32 <sjanssen> that's really the important issue
00:12:31 <Gracenotes> hm. C is particularly convenient in this respect?
00:13:14 <zakwilson> C is particularly common, therefore most FFIs are C FFIs.
00:13:23 <sjanssen> it's the lingua franca
00:14:14 <wli> If you're implementing the FFI yourself you can obviosly make a direct interface to other languages.
00:16:29 <PetRat> http://www.mibbit.com/pb/OL3RJQ  I'm getting this error in running example code from chapter 15 of RWH. Can someone tell me what GHC.Prim.Any refers to?
00:17:31 <sjanssen> PetRat: can you paste the code?
00:19:05 <mmorrow> mauke: ping
00:19:11 <PetRat> http://www.mibbit.com/pb/HwFXX6 Okay pasted.
00:20:46 <sjanssen> PetRat: do you get an error with "runSupply next [1 :: Int,2,3]"?
00:21:09 <bombshelter13_> Hahah. Nice work PetRat, our devious plan is now complete! Now we can sick the copyright police on him for reproducing part of copyrighted work. Eeexcellent...
00:22:22 <Gracenotes> -k
00:22:39 <bombshelter13_> true
00:22:56 <bombshelter13_> and i should have congratulated sjanssen for luring him into the trap.
00:23:10 <bombshelter13_> it's late though, and i'm half asleep.
00:25:09 * PetRat should probably not expect a detailed answer at this time.
00:27:03 <PetRat> sjannssen: here is similar error with that line: http://www.mibbit.com/pb/ywHVOG
00:28:37 <sjanssen> hmm
00:29:26 <sjanssen> PetRat: what does ghci tell you the types of next and runSupply are?
00:29:29 <PetRat> In the online RWH, the comments for this section include someone having the same error. Maybe we are using a different version of ghc than the book's?
00:30:19 <PetRat> sjanssen: http://www.mibbit.com/pb/tGsTpv
00:30:19 <sjanssen> possibly, I'll try running it
00:31:38 <sjanssen> I get wrong results for both GHC 6.8.2 and GHC 6.10.1
00:32:44 <PetRat> I pasted info about GHC.Prim.Any from the docs: http://www.mibbit.com/pb/8Rih1F
00:32:55 <sjanssen> PetRat: give next an explicit type signature: next :: Supply a (Maybe a)
00:33:02 <PetRat> I think I'm running GHC 6.8.2
00:33:15 <sjanssen> PetRat: yeah, it's a GHC internal that shouldn't be popping up here.  Some sort of funky GHC bug presumably
00:34:01 <PetRat> Giving type signature for next fixed it. Thanks!
00:34:54 <PetRat> By the way, don't know if you are familiar with this chapter of RWH (chapter 15) but I am having a hard time understanding. It seems to introduce confusing code with very little explanation. I know the book is already large, but this topic needs more said about it for beginners, I think.
00:35:46 <sjanssen> PetRat: what's the topic?
00:35:56 <acieroid> hi
00:37:01 <acieroid> I can't understand the state monad, and I don't find many documentation about it
00:37:12 <PetRat> Chapter 15 "Programming with Monads". Here is an outline of chapter 15: http://www.mibbit.com/pb/6OuZZP
00:37:41 <PetRat> http://www.mibbit.com/pb/CxIzgR
00:38:49 <Twey> PetRat: The chapter is designed to be compiled
00:39:09 <Twey> If you don't want to compile it, you'll have to provide an explicit type signature to prevent GHCi from defaulting
00:40:01 <PetRat> Sorry the format in the paste bin is screwed up. Anyway, chapter 15 introduces a few examples of programming with monads, including:  using the Maybe monad to short-circuit a computation or provide default answer, MonadPlus, a monad that supplies random numbers, "adventures in hiding the plumbing" (encapsulation)
00:40:27 <PetRat> Twey: I think my brain has to be a compiler to understand it.
00:42:35 <sjanssen> ooh, it works when compiled
00:42:39 <sjanssen> mysteries abound!
00:43:26 <Twey> sjanssen: It's because GHCi defaults a to GHC.Prim.Any
00:44:01 <sjanssen> Twey: not in general
00:44:09 <sjanssen> and actually, it doesn't seem to be a ghci thing
00:44:17 <voker57_> how to get size of a file?
00:44:36 <MyCatVerbs> acieroid: hit up All About Monads.
00:45:01 <Twey> voker57_: hFileSize
00:45:10 <sjanssen> when "main = print . runSupply next $ [1, 2, 3]" is present in the file the type of next is correct, when that decl is not in the file a type involving Any is inferred
00:45:17 <MyCatVerbs> acieroid: http://www.haskell.org/all_about_monads/html/statemonad.html <- fairly terse explanation of State.
00:45:39 <solrize> it's worth trying to figure out how to write the state monad on your own
00:45:46 <solrize> it really helped my understanding of monads when i did that
00:45:59 <sjanssen> oh, the type isn't correct, it's filled in with Integer
00:46:11 <sjanssen> I get it now, not a GHC bug
00:48:15 <Saizan> it's the MR restriction
00:48:30 <Saizan> s/restriction//
00:49:06 <sjanssen> Saizan: I don't think it is, there are no class contraints
00:49:19 <Saizan> MonadState
00:49:48 <Saizan> though the instance is polymorphic in 's' so you don't get an "ambiguous type variable" error
00:49:55 <sjanssen> then why does Any come in?
00:50:27 <Saizan> because 's' is not generalized, but there's nothing constraining it, so it "defaults" to Any
00:50:37 <acieroid> thanks MyCatVerbs
00:50:51 <sjanssen> hmm, what would Haskell '98 do with this?
00:50:54 <Saizan> s/constraining/unified with/
00:50:58 <acieroid> I'm beginning to understand the thing
00:51:48 <Saizan> good question
00:53:39 <voker57_> @type hFileSize
00:53:40 <lambdabot> Not in scope: `hFileSize'
00:55:35 <wli> @type System.IO.hFileSize
00:55:36 <lambdabot> GHC.IOBase.Handle -> IO Integer
00:58:33 <voker57_> @type System.IO.fileSize
00:58:33 <lambdabot> Not in scope: `System.IO.fileSize'
01:23:00 <blueonyx> http://downforeveryoneorjustme.com/haskell.org :(
01:30:45 <mm_freak> with the ByteString parser of parsec i'm often doing something like 'fmap B.pack . many1 $ satisfy …'
01:31:04 <mm_freak> is there a special case many1, which returns a ByteString right away?
01:33:05 <Twey> :t satisfy
01:33:05 <lambdabot> Not in scope: `satisfy'
01:33:31 <Twey> mm_freak: bs = (fmap B.pack .)?
01:33:37 <mm_freak> satisfy takes a predicate and succeeds with a character, if it fulfills that predicate
01:33:53 <mm_freak> hmm, good idea
01:34:45 <mm_freak> but conciseness in notation is not my main concern
01:34:48 <mm_freak> it's performance
01:35:39 <neoswish> if i have some overlapping instances and more polymorphic type to return, is there some hack to define what instance to use by default, e.i. without explicit type signature? =)
01:35:45 <Twey> Does Parsec return a string there?
01:36:04 <mm_freak> in that case, yeah
01:36:13 <Twey> Weird
01:36:21 <mm_freak> nope, totally reasonable
01:36:48 <Twey> Well you'd think it would return a generic Stream Char
01:36:57 <mm_freak> 'satisfy' returns a Char (with ByteString.Char8) and many1 applies a parser at least once, as often as it succeeds
01:37:13 <mm_freak> it returns a list of all those results, i.e. a String
01:37:27 <Twey> So it should be a Stream Char8
01:37:40 <mm_freak> uhm, wait
01:37:59 <mm_freak> nope
01:38:00 <Saizan> i don't think Stream has methods for construction
01:38:01 <mm_freak> many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
01:38:07 <mm_freak> it doesn't
01:38:10 <Saizan> attoparsec has this: takeWhile :: (Word8 -> Bool) -> Parser ByteString
01:38:20 <mm_freak> Stream has only an uncons operation
01:38:44 <mm_freak> Saizan: would you recommend attoparsec over parsec?
01:38:45 <Saizan> consing for ByteString won't be efficient anyway
01:39:05 <Twey> You're right, it seems to be monomorphic Char/[]
01:39:17 <Saizan> mm_freak: if you want performance, then yes
01:39:20 <Twey> Hmn
01:39:43 <mm_freak> Saizan: yeah, i want just that
01:39:45 <mm_freak> thanks =)
01:40:07 <mm_freak> hmm
01:40:13 <mm_freak> no haddock docs
01:40:21 <mm_freak> no homepage
01:40:40 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/attoparsec-0.5.1 <- there are for this version
01:41:05 <Saizan> but it's best to build the latest locally
01:41:31 <mm_freak> i wonder why nobody makes a decent arrow-based parser library
01:42:20 <Saizan> "decent" is a bit vague :)
01:42:44 <mm_freak> something that is useful in practical code and maintained
01:42:50 <ivanm> mm_freak: because those who want it can't be bothered, the rest of us either don't want it or have NFI what an "arrow-based parser" is/looks like or why it would be useful
01:44:12 <mm_freak> ivanm: i don't know how exactly arrows improve it, but as far as i know it improves performance in that it allows parsers to fail much earlier using less backtracking
01:44:26 <ivanm> *nod*
01:44:31 <mm_freak> so far i've used arrows only for fancy function encoding
01:44:37 <ivanm> so you mean using arrows under the hood, rather than an arrows based interface?
01:44:38 <ivanm> or both?
01:44:49 <Saizan> interface
01:44:51 <mm_freak> dunno
01:45:24 <ivanm> since I've only ever used Arrows to apply functions to pairs... ;-)
01:45:33 <mm_freak> the PArrows library uses arrows as interface
01:45:49 <mm_freak> ditto
01:45:51 <Saizan> the idea is basically to calculate the set of first characters each parser expects
01:45:54 <Gracenotes> ⋘_⋘
01:45:55 <Gracenotes> ⋙_⋙
01:46:21 <Saizan> which can actually be done with monads too, with some difficulty
01:46:46 <mm_freak> well, so far i haven't found a case, where that would improve anything, because i wouldn't ever match against multiple words in a parser
01:47:30 <Saizan> no disjunction?
01:47:48 <mm_freak> there are disjunctions, but they fail early
01:48:30 <mm_freak> consider IRC…  most disjunctions deal with leading ':'
01:48:39 <mm_freak> like:  if there is a leading ':', then…
01:49:32 <Saizan> so you don't actually need it :)
01:50:08 <mm_freak> i like the idea of explicit input types =)
01:51:25 <mm_freak> though PArrows doesn't seem to expose a lot of this to the user
01:51:43 <blueonyx> hi, does anyone know how to use Target from the GHC API like this "A target may be supplied with the actual text of the module."? i provide the text but GHC still searches for a file :/
01:53:08 <mm_freak> it looks like PArrows doesn't use the input type at all
01:53:17 <mm_freak> it just uses the arrow interface
01:54:02 <Saizan> uh?
01:54:17 <Saizan> it's the user that's supposed to use the input type
01:54:47 <mm_freak> nope, the user uses 'runParser', where the input type is fully polymorphic
01:54:57 <mm_freak> the user passes a String to runParser
01:55:28 <Saizan> i meant in building its expressions
01:55:44 <mm_freak> ditto…  the input type is fully polymorphic everywhere
01:55:56 <Saizan> yeah, but you need to use it to combine the arrows
01:56:00 <Saizan> and build your result
01:56:23 <mm_freak> but what would you pass as input?
01:56:42 <mm_freak> the actual 'input' comes with runParser as a String already
01:57:37 <Saizan> i mean, like in "digit &&& digit >>> arr (uncurry (*))"
01:58:24 <Saizan> you wont' pass anything to digit, true, but you need to instantiate the input type for "arr (uncurry (*))"
01:59:27 <mm_freak> oh, indeed
01:59:28 <Saizan> it'll feel very much like using an Applicative in most cases
01:59:39 <Saizan> but you've a little more expressivity
02:01:03 <Saizan> uhm, actually
02:03:10 <Saizan> maybe if no combinator makes use of the input type you could just stick to applicative and not lose anything
02:05:35 <mm_freak> yeah
02:06:06 <mm_freak> i just forgot custom parsers
02:06:14 <mm_freak> like your arr (uncurry (*))
02:07:02 <Saizan> yeah, but those built with arr can just be converted in equivalent fmap
02:07:28 <acieroid> is there a specific way to remove a value from an alist ?
02:07:36 <acieroid> or do I have to write it ?
02:08:22 <Saizan> maybe filter applies?
02:09:36 <acieroid> oh right
02:11:57 <mm_freak> if not filter, there is delete
02:12:03 <mm_freak> but usually filter is better
02:13:04 <Saizan> oh, i always forget about delete
02:14:04 <Twey> delete = filter . not?
02:14:08 <Twey> @src delete
02:14:08 <lambdabot> delete = deleteBy (==)
02:14:12 <Twey> @src deleteBy
02:14:12 <lambdabot> deleteBy eq x []        = []
02:14:12 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
02:14:42 <Gracenotes> delete is delete-once
02:14:43 <Twey> Why isn't delete = filter $ not (==)?
02:14:50 <Twey> Oh, right
02:14:52 <Gracenotes> not delete-every-single-instance
02:14:52 <Twey> It only takes one
02:15:21 <Gracenotes> at least this way, though, it won't make a bottom cons cell unless one already exists in the list
02:15:32 <raptornv25> hi guys how to get "hello world" in haskell?
02:15:47 <kaol> main = putStrLn "hello world"
02:18:36 <njbartlett> Can anybody tell me where haddock docs end up after doing "cabal haddock" then "cabal install"
02:20:23 <mm_freak> njbartlett: look in 'dist'
02:20:31 <mm_freak> oh, after installing
02:21:15 <njbartlett> mm_freak: Yeah, after installing. Looks like neither "cabal install" nor "runhaskell Setup.hs install" actually install the docs anywhere
02:21:27 <njbartlett> So they can't be found when generating docs for dependent packages
02:21:28 <mm_freak> seems like they end up in /usr/share/doc/ or similar
02:21:33 <mm_freak> just like every other documentation
02:23:19 <njbartlett> mm_freak: Well you get a directory under /usr/local/share, but it just contains licence.txt
02:23:31 <Saizan> is there a way to exclude a certain value and/or type from heap profiling?
02:24:21 <mm_freak> njbartlett: well, specify it:  cabal configure --haddockdir=/foo/bar
02:24:26 <Saizan> njbartlett: ghc-pkg field $pkg haddock-html
02:24:41 <mm_freak> or --htmldir
02:27:16 <njbartlett> Saizan: returns nothing
02:28:14 <Saizan> njbartlett: even when using the name of your package in place of $pkg?
02:28:36 <njbartlett> Saizan: Yes
02:29:13 <Saizan> weird, i get a directory even for packages that don't have the haddocks installed
02:29:24 <Saizan> which version of Cabal/ghc are you using?
02:29:49 <njbartlett> Cabal 1.6.01, ghc 6.10.3
02:35:49 <njbartlett_> Saizan: Sorry, I'm on an unreliable internet connection... will ask again later if I still can't sort it out
02:38:46 <Saizan> njbartlett_: k, i've no idea what's wrong anyway
02:46:12 <romildo> Hello.
02:46:43 <romildo> I am going to implement a Tiger compiler in Haskell.
02:47:37 <mm_freak> isn't there some nicer syntax for qualified importing?
02:48:43 <mm_freak> i usually have some nicely sorted imports, but as soon as a qualified import gets in, it either makes everything ugly or i have to place it, e.g. at the top/bottom of the list
02:48:55 <QtPlaty[HireMe]> romildo: Tiger?
02:50:37 <ivanm> mm_freak: nicer? in what way?
02:50:54 <ivanm> QtPlaty[HireMe]: if you make a mistake, it eats you
02:50:55 <ivanm> ;-)
02:52:27 <trofi> [:
02:52:36 <romildo> What would be a good representation of symbols? Appel, in his "Modern Compiler Implementation in SML" uses an imperative hash table to map strings to symbols, where a symbol is something like an "interned" string. It resembles the symbols from Lisp and Scheme. Appel represents them as a pair (name,key)::(String,Int), where key is a unique integer that can be used to quickly determine if two symbols are the same.
02:52:49 <mm_freak> ivanm: it would suffice to be able to write 'qualified' _after_ the module name
02:53:14 <ivanm> mm_freak: oh, you mean "as" implies "qualified"?
02:53:20 <ivanm> that would make sense to me as well...
02:53:30 <mm_freak> no, not really
02:53:30 <ivanm> how many times do you import as an alias but don't qualify it?
02:53:35 <ivanm> hmmm...
02:53:38 <romildo> QtPlaty[HireMe], Tiger is a didatic programming language used in the series "Modern Compiler Implenation in [ML,Java,C]" by Andrew Appel.
02:53:43 <mm_freak> just that i could write something like:  import Control.Category qualified as C
02:54:07 <mm_freak> sometimes i don't qualify
02:54:08 <trofi> very high qualification
02:54:39 <mm_freak> well, apparently there is no alternative =/
02:55:06 <Saizan> romildo: i'd use a Map String Int
02:55:28 <Saizan> or IntMap String, depending on which indexing you want..
02:57:24 <Saizan> or maybe not, since this things will be runtime values for the generated programs, right?
02:57:39 <Saizan> so, what are you compiling into?
02:57:44 <roderyk> MissingPy has a (FromPyObject CDouble) ... how do I go about casting a haskell CDouble to Double?
02:58:02 <Saizan> roderyk: fromIntegral
02:58:23 <romildo> Saizan, the key should be the symbol name. When a symbol name is retrieved from the input program, it is looked in the map. If it is not found, a new symbol is created (with a new integer id) and inserted into the map. Otherwise the symbol found in the table is used.
02:58:44 <roderyk> Saizan: hmm, ok.. thanks. I kind of assumed that was for Int, Integer...
03:01:17 <romildo> Saizan, I am concentrating into the analisys phases now. I am not sure what will be the target. Most of the time there is not enough classes to cover the whole compiler, just the lexical, syntatic and semantic analisers.
03:01:37 <romildo> Saizan, but I am thinking about using llvm as the backend.
03:03:05 <joeally> hello
03:04:13 <joeally> I am just learning haskell and thought trying to program the bubble sort algorithm
03:04:19 <roderyk> Saizan: no instance (Integral CDouble)
03:04:31 <joeally> but haskell being different i am stuck
03:04:41 <Saizan> roderyk: oh, sorry, braino, realToFrac
03:04:51 <Saizan> Double is not an Integral type
03:04:52 <roderyk> Saizan: ok, that makes more sense :)
03:04:59 <roderyk> Saizan: yea...  ;)
03:05:04 <roderyk> thanks :)
03:05:15 <joeally> the best that i could come up with was "bubble (x:y:ys)  = min x y:bubble (max x y:ys)"
03:05:29 <joeally> but this only does the first pass of bubble sort
03:05:37 <romildo> The Data.HashTable.HashTable type is implemented in the IO monad. Is there any non-monadiic implementation of hash tables in the Haskell standard library that would be more efficient than using a Data.Map.Map ?
03:05:44 <joeally> is there anyway to apply a function to itself
03:06:33 <joeally> anyone know how to apply a function to itself a specific amount of times
03:06:34 <Lemmih> romildo: Data.Map is very fast.
03:06:35 <Saizan> joeally: there's iterate
03:06:40 <joeally> okay
03:06:53 <joeally> i'll search it on google thankyou very much
03:07:07 <Saizan> > iterate (*2) 0 !! 4
03:07:08 <lambdabot>   0
03:07:11 <Saizan> > iterate (*2) 1 !! 4
03:07:12 <lambdabot>   16
03:07:20 <romildo> So I think I will go with Data.Map to store the known symbols of my compiler.
03:07:37 <monadic_kid> joeally: what you should try to do is break down you're specific cases and the most general one, then you can write this out as an equation in haskell with pattern matching function arguments
03:08:00 <monadic_kid> joeally: like one of you're specific cases which is the empty list
03:08:00 <joeally> i have tried
03:08:24 <joeally> this is what i got
03:08:27 <joeally> "bubbleI [] = []
03:08:27 <joeally> bubbleI [x] = [x]
03:08:27 <joeally> bubbleI (x:y:ys)  = min x y:bubble (max x y:ys)"
03:08:38 <joeally> but this is only one pas
03:09:10 <joeally> i need to repeat this x times depending on length of list
03:09:28 <joeally> thanks sazian
03:09:50 <monadic_kid> joeally: make a recursive call to bubbleI, is bubble a different function from bubbleI?
03:09:50 <joeally> Sazian: thnaks
03:11:39 <joeally> yes
03:11:50 <joeally> monadic_kid:
03:11:54 <joeally> monadic_kid:yes
03:12:05 <joeally> but i dont know what to put bubble as
03:15:45 <mm_freak> i'm trying to implement a state arrow, but i'm running into a major problem:  first a >>> second b wouldn't be equal to second b >>> first a
03:15:49 <mm_freak> is this a problem?
03:16:00 <Saizan> no, that's expected
03:16:10 <mm_freak> ok, thanks
03:17:32 <mm_freak> is a state arrow useful actually?
03:17:54 <opqdonut> you mean the kleisli arrow of State?
03:18:06 <mm_freak> dunno
03:18:24 <mm_freak> i mean this:  data AState s a b = AState { runState :: a -> s -> (b, s) }
03:18:40 <opqdonut> ?src Kleisli
03:18:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:18:55 <mm_freak> i have no experience with kleisli arrows
03:19:06 <mm_freak> i've read about them once, but never found a use for them
03:19:17 <opqdonut> newtype Kleisli m a b = Kleisli (a -> m b)
03:19:19 <opqdonut> basically
03:19:35 <opqdonut> that's an arrow for any monad m
03:20:09 <mm_freak> in fact, Kleisli (State s) a b seems equivalent to my AState
03:20:14 <opqdonut> indeed.
03:20:38 <mm_freak> well, is such an arrow useful?
03:21:04 <opqdonut> well it's as useful as State
03:21:28 <mm_freak> sure, i guess it could improve notation sometimes using proc/do
03:21:45 <mm_freak> but i'm failing to find a concrete example
03:25:11 <mm_freak> hmm
03:25:18 <mm_freak> i guess it may be useful sometimes
03:25:48 <mm_freak> like applying stateful computations to tuples
03:26:01 <mm_freak> but notation is very tiring
03:26:10 <mm_freak> > flip runState 3 . flip runKleisli (10,20) . first $ Kleisli (\x -> modify (+x))
03:26:11 <lambdabot>   (((),20),13)
03:26:52 <Saizan> the wrapping/unwrapping is quite bad, yeah
03:27:17 <mm_freak> yep…  i guess, proc/do may improve it
03:28:59 <Saizan> i never liked proc
03:31:47 <mm_freak> i've never used it
03:31:55 <mux> anyone running openbsd or netbsd and willing to provide me with a shell account so that I can have a haskell module work there?
03:33:09 <cnwdup> Is it possible to create a function which takes a string and produces an n-ary result depending on the string?  For instance foo "%%" should yield a binaryary function, foo "%a" should yield an unary function, and so on. Or does this violate Haskell's type system?
03:33:33 <mm_freak> cnwdup: you need some magic for that
03:33:36 <mm_freak> see Text.Printf
03:34:08 <mm_freak> it's a type-safe haskell equivalent of the C printf function
03:34:22 <mux> it's not type-safe
03:34:34 <mm_freak> no?  not statically i guess
03:34:35 <cnwdup> And it's unflexible.
03:34:39 <mux> it should be called unsafePrintf
03:35:11 <mm_freak> cnwdup: it implements the idea nevertheless
03:36:07 <cnwdup> Does it? It seems to be different to me. printf kind of creates the arity from the number of arguments and I'd like to create it from the first argument only.
03:36:21 <mm_freak> it does
03:36:23 <cnwdup> Where printf uses the type system to create a function I'd like to create a function whilst not violating the type system.
03:36:28 <mm_freak> > printf "%i" 3
03:36:29 <lambdabot>   Add a type signature
03:36:34 <mm_freak> > printf "%i-" 3 :: String
03:36:35 <lambdabot>   "3-"
03:36:40 <mm_freak> > printf "%i-%i" 3 4 :: String
03:36:41 <lambdabot>   "3-4"
03:37:16 <opqdonut> cnwdup: a type-safe printf is easy if the format is read from some sort of ADT and not a string
03:37:26 <mux> yeah
03:37:28 <mm_freak> yeah
03:37:36 <Cale> Where the ADT is probably a GADT.
03:37:51 <Cale> (but possibly not...)
03:37:53 <mux> the "fun with type functions" implements it this way
03:37:53 <cnwdup> Yeah, printf "fmt" creates a function of type PrintfType and then it matches printf type against the arguments. As 3 follows, PrintfType is PrintfArg -> PrintfType. As 4 follows, the resulting function is PrintfArg -> PrintfArg -> PrintfType. Then no argument follows and the type system infers PrintfArg -> PrintfArg -> String since String is an instance of PrintfType.
03:38:00 <mux> *paper
03:38:35 <cnwdup> I'd rather have this way: myPrint "fmt" should create a function of variable arity depending on the format argument no matter what the remaining arguments passed to the functions are.
03:39:27 <cnwdup> (myPrint "fmt") and ((((myPrint "fmt") 1) 2) 3) should evaluate to the same function when evaluating only (myPrint "fmt").
03:40:08 <Saizan> cnwdup: you can't if you use a String
03:40:10 <cnwdup> opqdonut, I thought so, too. But I do not quite know how to realize that.
03:40:32 <cnwdup> Saizan, what can I use?
03:40:33 <monadic_kid> the way cnwdup is describing is exactly how format type works in ocaml and F#
03:41:27 <joeally> Is this an efficient bubble sort algorithm:
03:41:30 <joeally> bubbleI [] = []
03:41:30 <joeally> bubbleI [x] = [x]
03:41:30 <joeally> bubbleI (x:y:ys)  = (min x y:bubbleI (max x y:ys))
03:41:30 <joeally> bubble x = iterate bubbleI x !!(length x-1)
03:42:06 <Saizan> cnwdup: a gadt, and there's an example in the paper here: http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
03:42:17 <Saizan> it's also possibile with delimited continuations
03:42:18 <monadic_kid> in F# and Ocaml there is a special type constructor called format/Format where one of the type parameters is substituted by the compiler from the format string at compile-time
03:42:27 <cnwdup> Saizan, thank you. (:
03:42:56 <Saizan> as described here (and the linked code) http://www.mail-archive.com/haskell@haskell.org/msg20758.html
03:43:29 <Saizan> monadic_kid: ah, yeah, i guess we'd do that with TH here
03:43:55 <Saizan> to generate the gadt from the string
03:44:03 <Tristan1> hello everyone
03:44:09 <joeally> hello
03:44:40 <Saizan> joeally: as efficient as bubblesort is :)
03:44:47 <joeally> yaya
03:44:52 <monadic_kid> as long as you can analyze strings at compile-time then it's all cool
03:44:58 <Tristan1> if someone has a litte time, i need some help installing the base-4.1.0.0 package
03:45:02 <joeally> thanks for pointing me to iterate
03:45:10 <Saizan> joeally: though a common optimization is to stop if the last pass didn't swap any elements
03:45:32 <joeally> okay thanks i may try and add that
03:45:54 <Saizan> Tristan1: you can't upgrade the base package
03:45:58 <joeally> I think implementing algorithms is the best way to learn a language
03:46:10 <Saizan> Tristan1: if you need base-4.1 you must upgrade ghc
03:46:16 <Tristan1> i did this
03:46:40 <Tristan1> now cabal says: config.status: error: cannot find input file: include/HsBaseConfig.h.in
03:46:53 <monadic_kid> this "fun with type funs" paper sounds awfully familiar (hint boost mpl)
03:46:54 <Tristan1> and i don't know where to get this file
03:47:06 <Tristan1> my ghc version is 6.10.1
03:47:48 <Tristan1> (installed as user, $PATH is set correctly - ghc --version says 6.10.1)
03:48:04 <Saizan> Tristan1: ghc-6.10.1 comes with base-4, you need at least ghc-6.10.2 if you want base-4.1
03:48:11 <Tristan1> ok
03:48:18 <Tristan1> this explains a lot
03:48:38 <Tristan1> then i'm going to install 6.10.2
03:48:40 <Tristan1> thx
03:48:48 <mux> or 6.10.3 maybe?
03:48:56 <mux> while you're at it :-)
03:49:06 <Tristan1> what is the latest version ?
03:49:10 <koeien> 6.10.3 is
03:49:14 <Tristan1> ok
03:49:22 <Tristan1> thx again
03:49:28 <koeien> although i haven't installed it yet, the difference appears to be minor
03:49:34 <twb> How do I sort (then group) a list of tuples by the snd of each element?
03:49:43 <koeien> :t sortBy
03:49:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:49:45 <monadic_kid> omg it's boost mpl all over again
03:49:46 <twb> sortBy wants me to define the comparator, which sucks
03:49:52 <koeien> :t on
03:49:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:49:56 <twb> Ah.
03:50:00 <twb> I knew there was a trick to it
03:50:02 <mux> 6.10.3 just makes line editing work out of the box all the time because it doesn't depend on libedit/libreadline anymore
03:50:55 <twb>  ((<) `on` snd) ?
03:51:03 <Saizan> compare on snd
03:51:06 <koeien> > sortBy (compare `on` snd) [(0,1),(1,0)]
03:51:07 <lambdabot>   [(1,0),(0,1)]
03:51:09 <mux> comparing snd
03:51:19 <twb> mux: aha!
03:52:28 <joeally> What is quicker the function min or checking using "<"
03:52:32 <monadic_kid> fun with types funs is very similliar to type computations with C++ templates and mixing it up with other techniques like expression templates
03:52:41 <koeien> joeally: min probably uses <
03:52:46 <joeally> okay
03:52:49 <joeally> so no difference
03:53:01 <twb> Is there a better way to say: group $ sort xs ?
03:53:02 <koeien> not a difference you'd notice
03:53:08 <mux> joeally: except that your code calls min and max one time each
03:53:17 <joeally> yes
03:53:35 <joeally> so im thinking of checking if its smaller before calling min
03:53:37 <joeally> or max
03:53:49 <koeien> twb: not 100% sure, but i don't think so
03:54:31 <monadic_kid> can you apply a type function to an unbounded sequence of types?
03:55:18 <Saizan> you can represent sequences of types with tuples, like in HList
03:55:48 <Saizan> (A,(B,(C,()))) <- cons cells at the type level
03:55:50 <monadic_kid> okay so i guess you can define a fold type function then
03:56:25 <Saizan> can you pass a type function as parameter to another?
03:57:38 <monadic_kid> Saizan: you can with templates, boost mpl defines a how framework for STL style type functions, they have method of lazy template instantion and parital application and sort of lambda functions
03:59:40 <monadic_kid> boost::is_pod<> , is_pod is a type traits or you can view this as a type function predicate, with boost mpl if you do boost::is_pod<_1> becomes lambda function that takes one arg, you can pass this to higher-order type functions
04:00:45 <monadic_kid> fold< type_seq, add<_1,_2>, size_t<0> >
04:00:54 <roderyk> in gtk2hs, Model.TreeView: I can set a model via (treeViewSetModel view (treeStoreNew forest))  where forest is Data.Tree; but I need to later update this tree. When I call treeViewGetModel, I cannot get the old (treeStore Data.Tree) back. Instead, it wants to return the generic TreeModelClass
04:01:15 <roderyk> TreeStore is an instance of TreeModelClass, but I can't seem to get it to cast back... any suggestions/ideas?
04:01:35 <roderyk> (the gtk interface for TreeModel seems really over-engineered)
04:02:01 <twb> @pl ((==) `on` snd)
04:02:01 <lambdabot> (==) `on` snd
04:02:57 <monadic_kid> i guess you would be able to do this with depedant types in haskell and type-classes fun deps, fold< list_c<1,2,3,4,5> , add<_1,_2>, size_t<0> >
04:03:50 <joeally> is this bubbleI (x:y:ys)
04:03:50 <joeally> 	| x <= y = x:bubbleI (y:ys)
04:03:50 <joeally> 	| x > y = y:bubbleI (x:ys)
04:04:24 <joeally> quicker than this : bubbleI (x:y:ys)  = min x y:bubbleI (max x y:ys)
04:05:30 <mux> joeally: you want this:
04:05:37 <mux> bubbleI (x:y:ys)
04:05:48 <mux>   | x <= x = x:bubbleI (y:ys)
04:05:58 <mux>   | otherwise = y:bubbleI (x:ys)
04:06:03 <joeally> okay
04:06:06 <mux> this way you really do only one comparison
04:06:14 <mux> otherwise is just an alias for True
04:06:17 <joeally> fair enough
04:06:27 <joeally> so that is the quickest way
04:06:45 <mux> x <= x should x <= y of course, that was a typo
04:06:54 <mux> joeally: well it is a way that only does one comparison :-)
04:07:11 <joeally> thank you mux
04:07:17 <mux> you're welcome
04:07:28 <joeally> i have just learned something new
04:08:24 <Twey> mux: Apparently otherwise has optimisation magic in GHC
04:08:43 <joeally> ooh
04:08:44 <koeien> i hope that 'True' has the same optimization magic
04:08:49 <joeally> that makes it even bugger
04:08:51 <mux> I really hope that too.
04:08:58 <joeally> beter*
04:09:01 <mux> if GHC ends up comparing True with True, that would suck :-)
04:09:15 <koeien> GHC may do that compiletime :)
04:09:24 <koeien> but runtime that should be optimized away
04:09:44 <joeally> Fast bubble sort in 6 lines...better than python
04:10:10 <joeally> i get the feeling haskell is better than python for mathmatical things
04:10:33 <koeien> joeally: i confess that i use haskell mostly for math things, but i think it is also better for larger projects
04:10:41 <koeien> because of static typing
04:10:50 <joeally> yeah I suppose
04:11:14 <joeally> Its just that python and ruby seem easier for things like web services and gui
04:11:16 <koeien> but i also use haskell for scripting stuff ;)
04:12:17 <joeally> saying that bubble sort in python is also 6 lines
04:12:36 <joeally> but it is slower
04:12:42 <koeien> python is slower
04:13:02 <koeien> if you really need performance, it's not the best choice
04:13:25 <joeally> yeah its syntax is really easy though
04:13:35 <koeien> true.
04:13:35 <joeally> and its very good for when your in linux
04:13:42 <joeally> but i like haskell also
04:13:48 <twb> What am I doing wrong here?
04:13:50 <twb> > foldl1 ((+) `on` fst) $ zip [1..3] ['a'..'c']
04:13:50 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, b)
04:13:51 <lambdabot>        Exp...
04:13:54 <joeally> its syntax seems more efficient
04:13:59 <Berengal> > let bubble (x:y:ys) = if x <= y then x:bubble(y:ys) else y:bubble(x:ys); bubble l = l in bubble [1,5,3,4,6,8,3,4]
04:14:00 <lambdabot>   [1,3,4,5,6,3,4,8]
04:14:10 <Berengal> > let bubble (x:y:ys) = if x <= y then x:bubble (bubble(y:ys)) else y:bubble (bubble(x:ys)); bubble l = l in bubble [1,5,3,4,6,8,3,4]
04:14:11 <lambdabot>   [1,3,3,4,4,5,6,8]
04:15:01 <joeally> thanks berengal but i prefer pattern matching to control expressions in this case
04:15:02 <koeien> :t ((+) `on` fst)
04:15:02 <lambdabot> forall a b. (Num a) => (a, b) -> (a, b) -> a
04:15:06 <koeien> :t foldl1
04:15:07 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
04:15:15 <Berengal> joeally: I was just checking to see if it worked
04:15:19 <joeally> oh
04:15:21 <koeien> twb: you see that this is not a valid argument to foldl1
04:15:48 <twb> koeien: I don't understand why.
04:16:04 <koeien> the first argument should be of type   c -> c -> c
04:16:08 <twb> Is this just one of those annoying foibles of HM inference?
04:16:17 <twb> Ah
04:16:24 <koeien> while    (a, b) -> (a, b) -> a   cannot be unified with that
04:16:34 <koeien> it complains that c = a = (a,b) cannot be unified
04:16:45 <Jedai> twb: No, it's a genuine type error
04:17:52 <twb> Is there a straightforward way to express what I want?
04:17:58 <Jedai> twb: You want something like "foldl1 (+) . map fst"
04:18:02 <mux> > foldl (\x y -> x + fst y) 0 $ zip [1..3] ['a'..'c']
04:18:03 <lambdabot>   6
04:18:06 <koeien> twb: foldl1 (+) $ map fst [...]
04:18:08 <twb> Jedai: ew, since I'm using &&&
04:18:10 <mux> if you really want a fold
04:18:19 <mux> but sum . map fst is shorted :)
04:18:23 <mux> shorter, rather
04:19:04 <Jedai> twb: ??
04:19:10 <twb> I have a list [(Int,a)] and I want to return a tuple (sum of ints, first a).
04:19:44 <Berengal> (sum &&& head) . unzip?
04:19:52 <koeien> > ((sum . map fst) &&& head) [(0,"Hello"), (1,"Why")]
04:19:53 <twb> Hmm, unzip...
04:19:54 <lambdabot>   (1,(0,"Hello"))
04:19:59 <Berengal> @type unzip
04:20:00 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
04:20:11 <mux> twb: if the function you pass to foldl1 takes two pairs and returns an integer, what does foldl1 do after having fed your function with the first two pairs in your list?
04:20:18 <koeien> unzip, far better
04:20:32 <twb> (sum &&& head) . unzip, I think
04:20:45 <mux> twb: it ends up with the rest of the list, and the sum of the integers of the two first pairs, and there's nothing it can do to go on
04:20:56 <mux> twb: this is why your code can't possibly type check
04:21:34 <Berengal> Sorry, should be sum *** head
04:21:49 <koeien> i always mix those up.
04:21:57 <Berengal> Yeah, me too...
04:22:09 <koeien> although i should use them more
04:22:20 <koeien> better than writing anon function for them
04:23:04 <mux> >  foldl1 (\(x,c) (y,_) -> (x+y,c)) $ zip [1..3] ['a'..'c']
04:23:05 <lambdabot>   (6,'a')
04:23:07 <twb> Berengal: hlint can tell you when you should use them :-)
04:23:14 <twb> Whee, it compiles again
04:23:19 <mux> twb: see?
04:23:52 <koeien> hlint! nice suggestion
04:24:06 <mux> twb: this works because I still return a pair in the function passed to foldl1
04:25:17 <mux> @pl \(x,c) (y,_) -> (x+y,c)
04:25:18 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip . ((,) .) . (+))
04:25:23 <mux> heh.
04:26:47 <koeien> i love lambdabot's pointless feature
04:28:54 <Twey> It's terrifying
04:29:37 <koeien> there should be a program that converts a haskell source code text, to a pointless one
04:30:01 <Twey> Please gods no
04:30:05 <ziman> @pl \a b c d -> a (b (c d))
04:30:05 <lambdabot> (. (.)) . (.) . (.)
04:30:14 <beelsebob> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> (a b a c z) (k q (r z) i (j 2 x) (p x q ((r z) (e x y)) z e f))
04:30:17 <lambdabot> ((const .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .)
04:30:17 <lambdabot>  .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .)
04:30:17 <lambdabot> . ((((((((((const .) .) .) .) .) .) .) .) .) .) . flip flip ((flip (flip . (flip .) . (((.) .) .) . ((ap .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . (((((ap .) .) .) .) .)
04:30:17 <lambdabot>  . (. ($ 2)) . flip . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((.) .))) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
04:30:20 <lambdabot> flip .) .) .) .) . (((((flip .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip
04:30:21 <beelsebob> >.>
04:30:23 <lambdabot> .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . ((.) .) . (ap .) . (((.) .) .) . (((.) .) .) . flip) . flip ((.) . (.) . flip)) id) id) . (flip .) . (((.) .) .) . (((.) .) .)
04:30:26 <lambdabot> . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . ((ap .) .) . ap flip id
04:30:29 <lambdabot> optimization suspended, use @pl-resume to continue.
04:30:30 <Twey> Hoooly crap
04:30:34 <Twey> Lambda-spam
04:30:40 <Twey> Someone fix that?
04:31:20 <Twey> You see?
04:31:23 <Twey> Terrifying.
04:33:42 <Japsu> Yeah, you scared the whole channel to STFU.
04:36:39 <beelsebob> lol
04:38:42 <trofi> looks like lisp
04:43:18 <voker57_> @pl-resume
04:43:24 <lambdabot> ((const .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .)
04:43:24 <lambdabot>  .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .)
04:43:24 <lambdabot> . ((((((((((const .) .) .) .) .) .) .) .) .) .) . flip flip ((flip (flip . (flip .) . (((.) .) .) . ((ap .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . (((((ap .) .) .) .) .)
04:43:24 <lambdabot>  . (. ($ 2)) . flip . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((.) .))) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
04:43:26 <lambdabot> flip .) .) .) .) . (((((flip .) .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((
04:43:29 <lambdabot> flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . ((.) .) . (ap .) . (((.) .) .) . (((.) .) .) . flip) . flip ((.) . (.) . flip))) . (flip .) . (((.) .) .) . (((.) .) .) .
04:43:32 <lambdabot> (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . ((ap .) .) . ap flip id
04:43:35 <lambdabot> optimization suspended, use @pl-resume to continue.
04:43:38 <voker57_> cool
04:49:03 <EvilTerran> voker57_, if you want to do that sort of thing, you can talk to lambdabot via private message
04:52:14 <voker57_> EvilTerran: ok
04:52:22 <burp_> lol
05:05:13 <Stim_Jim> be my pupil. http://invaderjim.mybrute.com its a fun litle flash game.
05:06:47 --- mode: ChanServ set +o Saizan
05:06:55 --- mode: Saizan set +b *!*=Stim_Jim@*.vic.bigpond.net.au
05:06:55 --- kick: Stim_Jim was kicked by Saizan (spam)
05:07:06 --- mode: Saizan set -o Saizan
05:07:44 <Botje> hmm
05:07:52 <Botje> i wonder if there is an abuse@mybrute.com
05:12:19 <Natashaaaa> Enter text here...
05:12:46 <Natashaaaa> hiii
05:12:49 <Natashaaaa> :)
05:35:49 <brian6> ghci in 6.10.3 is acting weird for me. like :t seq<enter> doesn't actually put a newline before the signature it prints.
05:36:28 <brian6> so it ends up looking like :t seqseq :: ...
05:37:40 <Botje> are you sure that's not a problem with your libeditline?
05:37:44 <Raevel> i installed parsec 3, now everything is broken :-(
05:39:19 <Botje> what kind of errors are you getting?
05:39:26 <brian6> Botje: dunno for sure, but i got rid of my .editrc.
05:45:37 <stulli> > foldl (\a b -> if b==',' then (a ++ [[]]) else (init a) ++ [(last a) ++ [b]]) [[]] "foo,bar,baz"
05:45:38 <lambdabot>   ["foo","bar","baz"]
05:45:47 <stulli> is there a standard funcion for this?
05:46:46 <juhp_> 6.10.3 should be using haskline, no?
05:47:00 <ivanm> juhp_: it does
05:47:02 * juhp_ wonders if yhc would not benefit from cabal
05:47:04 <stulli> like pythons split function
05:47:13 <ivanm> stulli: see Data.Split IIRC
05:47:21 <ivanm> juhp_: I think it does...
05:47:30 <ivanm> cabal is meant to be compiler-agnostic IIRC
05:47:33 <juhp_> oh?
05:47:43 <juhp_> ivanm: I mean rather than scons :)
05:48:13 <ivanm> juhp_: never heard of scons (except for appending an element on to the end of a "list")
05:48:16 <ivanm> wait, that's snoc
05:48:24 <juhp_> ivanm: :)
05:48:34 <ivanm> @where scons
05:48:34 <lambdabot> I know nothing about scons.
05:48:37 <byorgey> stulli: see the 'split' package on Hackage, which provides Data.List.Split
05:48:42 <juhp_> scons is a buildsystem (written in python)
05:48:42 <ivanm> *shrug* mustn't be important then ;-)
05:48:50 <ivanm> byorgey: ahhh, Data.List.Split, not Data.Split
05:48:54 <juhp_> ivanm: nod
05:48:58 <byorgey> yeah =)
05:49:00 <juhp_> try google :)
05:49:11 <ivanm> juhp_: you mean yhc using cabal to build yhc?
05:49:15 <ivanm> that would probably be bad...
05:49:19 <juhp_> ivanm: indeed
05:49:25 <ivanm> you have bootstrapping issues then
05:49:36 <juhp_> hmm maybe yeah
05:49:41 <ivanm> with needing cabal installed to install the compiler to build cabal
05:49:45 <stulli> byorgey: thanks, thats exactly what i was looking for
05:49:46 <juhp_> on the other hand ghc uses cabal too
05:49:47 <ivanm> even worse then ghc requiring ghc
05:49:52 <ivanm> juhp_: does it?
05:49:56 <juhp_> yes
05:50:03 <juhp_> for most of it
05:50:04 <ivanm> it _comes_ with cabal, but does it actually use cabal to build?
05:50:14 <juhp_> not all of course
05:50:15 <ivanm> *shrug* didn't know that, thought it was all Make-based
05:50:21 <juhp_> it is
05:50:28 <guinea> newb question: how do I get cabal to install base-4. Apparently my installed version is base-3
05:50:40 <ivanm> guinea: you need ghc-6.10.*
05:50:49 <ivanm> so cabal-install can't install it for you ;-)
05:51:06 <juhp_> which comes with base-4
05:51:07 <ivanm> which lib/app do you want that needs base-4?
05:51:21 <guinea> ivanm: aha! Is there a ubuntu package for that, or do I install it from a tgz?
05:51:26 <guinea> ivanm: yi
05:51:30 <ivanm> guinea: no idea
05:51:37 <ivanm> check ubuntu ;-)
05:51:42 <Berengal> guinea: No ubuntu package yet I'm afraid
05:51:47 <juhp_> yeah I think yi require ghc-6.10.x
05:51:52 <ivanm> Berengal: really? what's taking so long?
05:51:56 <ivanm> even fedora has it! :p
05:52:01 <juhp_> hehe
05:52:06 <Berengal> ivanm: I know, right!
05:52:12 <koeien> debian sid has it, i believe
05:52:12 <juhp_> what's that supposed to mean ;P
05:52:15 * ivanm uses fedora at work, though no official haskell stuff is involved...
05:52:19 <koeien> so ubuntu will probably have it in the next release
05:52:53 <Berengal> By the next releast 6.12 will have/soon have come out anyway
05:52:54 <guinea> Is there an apt-source I can add to my ubuntu?
05:53:14 <koeien> Berengal: ETA for 6.12 ?
05:53:17 <Berengal> guinea: No, you'll have to download the binaries from haskell.org and install it yourself
05:53:21 <ivanm> Berengal: august, isn't it?
05:53:27 <koeien> guinea: i would not recommend adding debian sid's repos
05:53:31 <ivanm> koeien: august IIRC
05:53:33 <koeien> ok
05:53:37 <Berengal> koeien: Sometime after summer
05:53:38 <koeien> ivanm: can't wait =)
05:53:43 <ivanm> heh
05:53:52 <ivanm> Berengal: but that's not until next year then! :(
05:53:53 <Berengal> koeien: That's too bad, because you'll have to :P
05:54:01 <koeien> guinea: download the binaries and installing it is easy.
05:54:02 <ivanm> (hint: southern hemisphere)
05:54:03 <juhp_> anyways yhc is not linking for me :-/
05:54:11 <koeien> Berengal: :( :P
05:54:14 <Berengal> ivanm: I didn't say which summer, did I?
05:54:19 <ivanm> Berengal: heh
05:54:21 <Berengal> Could be last year's...
05:54:30 <ivanm> @slap Berengal
05:54:31 * lambdabot clobbers Berengal with an untyped language
05:55:16 <juhp_> is there a schedule for 6.12?
05:55:48 <juhp_> src/compiler/Front.o: In function `s1Vl_info':
05:55:48 <juhp_> (.text+0x1ed4): undefined reference to `cpphszm1zi6_LanguageziPreprocessorziUnlit_unlit_closure'
05:55:49 <juhp_> ....
05:55:53 <pejo> juhp, they roughly release major releases around ICFP
05:56:25 <juhp_> aha
05:56:37 <Berengal> pejo: Any reason why?
05:57:38 <pejo> Berengal, don't know, but it's past submission deadlines for both ICFP and POPL.
05:57:52 <ivanm> Berengal: why not?
05:58:29 <Berengal> ivanm: That's not a reason why. That just means it's completely unreasonable ;)
05:58:46 <ivanm> Berengal: as in, they have to have an annual date to base releases around
05:58:55 <ivanm> so why not ICFP, which is at least remotely relevant/related
05:59:34 <Berengal> ivanm: Yeah, but choosing an arbitrary date doesn't give that date a reason
05:59:40 <Berengal> for being chosen, that is
05:59:53 <Berengal> Or it wouldn't be arbitrary
05:59:58 <ivanm> Berengal: I think pejo has hit it
06:00:11 <ivanm> they can't do it before, because they're busy writing papers/talks/etc. for ICFP
06:01:14 <Berengal> ivanm: Yeah, I was just arguing semantics with you. Sorry :
06:01:32 <ivanm> heh
06:02:00 <Berengal> ivanm: To be fair, "why not" was an open invitation to do so :P
06:02:28 <ivanm> true
06:02:30 <ivanm> ;-)
06:02:56 <kacper_> can yout tell me what is the diference by proving for example map( f.g ) = map f . map g for infinite and finite lists?
06:03:19 <Berengal> kacper_: There is no difference
06:03:26 <Berengal> Least not semantically
06:03:42 <ivanm> kacper_: my guess is that you can "fully" prove it for finite lists
06:03:49 * juhp_ wonders if anyone has had any luck building yhc recently
06:03:50 <ivanm> whereas infinite lists require induction or something...
06:04:02 <ivanm> juhp_: any particular reason for wanting to use yhc?
06:04:04 <ivanm> @seen ndm
06:04:04 <lambdabot> I haven't seen ndm.
06:04:13 <QtPlaty[HireMe]> IIRC deforestation in part depends on your ability to do that.
06:04:20 <ivanm> @uptime
06:04:20 <lambdabot> uptime: 8h 21m 1s, longest uptime: 1m 10d 23h 44m 29s
06:04:24 <juhp_> ivanm: well I was interested in playing the the js stuff
06:04:28 <juhp_> with
06:04:40 <ivanm> which probably hasn't been touched since it came out? :p
06:04:46 <guinea> I was about to upgrade ubuntu, but I'm wondering if I should switch to another distro? I use xmonad anyway.
06:04:47 <juhp_> hmm
06:04:48 <pejo> QtPlaty, do what?
06:05:03 <Berengal> guinea: If you feel up to it, try arch.
06:05:07 <juhp_> guinea: fedora has xmonad now :)
06:05:07 <EvilTerran> as i learnt it, in order to prove it for finite lists, you'd consider "map (f.g) [] =? (map f . map g) []" and "map (f.g) (x:xs) =? (map f . map g) (x:xs)"
06:05:16 <ivanm> guinea: fedora seems to have fairly decent haskell support, if you want a hand-holdy distro
06:05:22 <EvilTerran> and, for infinite lists, you'd consider "map (f.g) _|_ =? (map f . map g) _|_" as well
06:05:23 <ivanm> or else there's gentoo and arch
06:05:40 <dsouza> is xmod worthwhile? I'm currently a [happy] openbox user
06:05:47 <kacper_> I have a exercise to provo some facts for infinite lists and prove that some of them are correct only for finite lists
06:05:47 <dsouza> xmonad
06:05:49 <koeien> debian/ubuntu is not the best for haskell support i guess. but otherwise i like debian better than other distros
06:05:54 <Berengal> EvilTerran: finite lists can't be _|_?
06:06:08 <RayNbow> hmm, is it possible to use cabal to install packages for all users on a system?
06:06:10 <EvilTerran> because you can consider the infinite list [x0,x1 ..] to be the least upper bound of _|_, x0:_|_, x0:x1:_|_, ...
06:06:13 <koeien> RayNbow: yes.
06:06:16 <koeien> RayNbow: --global
06:06:26 <RayNbow> ah, thx
06:06:35 <koeien> (you must be root, of course)
06:06:41 <pejo> kacper_, to prove that something is incorrect for infinite lists you can probably just look at the case for the infinite list.
06:06:54 <juhp_> oh I see last yhc checkin is about a year ago... hmm
06:07:12 <EvilTerran> Berengal, IIRC, considering _|_ covered the fact that you can't fully evaluate the tail of an infinite list
06:07:28 <RayNbow> koeien: is it also possible to move packages installed for the root user only to the global configuration?
06:07:41 <RayNbow> (or should I just take the delete/reinstall approach)
06:07:52 <kacper_> yes I know that reverse( reverse xs ) is only correct for finite lists, but can I prove it from definition of reverse?
06:07:54 <guinea> ivanm: I like hand holdy distros, because by default I'm lazy, and only want cutting edge for the things I care about, e.g. haskell, emacs, R, which I can install myself, and which have their own package managers
06:08:10 <ivanm> emacs has its own package manager? :o
06:08:38 <dv_> emacs is an OS
06:08:42 <dv_> everybody knows this
06:08:55 <koeien> RayNbow: not sure. the only reliable thing i know of is reinstalling
06:08:58 <ivanm> dv_: not quite, it doesn't have a kernel yet
06:09:03 <ivanm> I'm sure they're working on it though...
06:09:12 <ivanm> (and no, I don't think it's Hurd)
06:09:13 <dv_> I heard they are gonna call it "hurd"
06:09:13 <koeien> it lacks a decent text editor...
06:09:14 <dv_> :P
06:09:15 * koeien runs
06:09:25 <guinea> ivanm: not quite, because they're not really packages
06:09:31 <EvilTerran> kacper_, well, if you take "reverse = go [] where go xs (y:ys) = go (y:xs) ys; go xs [] = xs", for instance
06:10:22 <ivanm> guinea: there are unofficial pkg managers though
06:10:32 <EvilTerran> kacper_, then reverse [1..] = go [] [1..]; because [1..] is infinite, this will always go down the recursive branch of the definition of "go"
06:13:54 <guinea> ivanm: yeah, and apparently it's in xemacs. I knew I remember seeing it. I didn't notice that gnuemacs lacked it until now, since I've been on ubuntu for a while and relied on apt for a lot of things.
06:14:25 <kacper_> what is definition of go?
06:14:40 <ivanm> guinea: I was referring to things like ELPA (if that's the right name)
06:14:46 <Twey> 14:09:31 < EvilTerran> kacper_, well, if you take "reverse = go [] where go xs (y:ys) = go (y:xs) ys; go xs [] = xs", for  instance
06:15:02 <ivanm> but yes, for small one-or-two-file .el things, I just do it by hand
06:16:59 <juhp_> aha maybe I should play with HJScript instead
06:17:33 <michael_> Hello. When I try this program with hugs > mydivide x y = div x y > mymult z = z + 3 and I type the command mydivide((mymult (3)), (mymult (4))) I get an "Cannot infer instance" error. Why is this?
06:17:36 <guinea> ivanm: heh, I didn't even know about elpa, but somehow it doesn't surprise me.
06:17:43 <ivanm> heh
06:17:54 <kacper_> ok, I get it, just one question more, if I prove something for finite list by normal structural induction, what shoul I do to prove it for infinite lists
06:18:12 <Twey> michael_: mydivide(x, y) means mydivide (x, y)
06:18:18 <Twey> (x, y) is a tuple
06:18:25 <Twey> div cannot be used on tuples
06:18:38 <EvilTerran> michael_, "mydivide (mymult 3) (mymult 4)"
06:18:56 <EvilTerran> michael_, although i'm not sure why you're calling "mymult" that
06:19:22 <michael_> EvilTerran, yeh that was silly
06:19:33 <michael_> Thanks Evil. That got it
06:20:01 <EvilTerran> kacper_, take "map f . map g = map (f.g)", for instance; you can prove that holds regardless of whether the parameter is [], (x:xs), or _|_
06:20:34 <EvilTerran> kacper_, because of the _|_ case and the (:) case, you know it works for x0:_|_, x0:x1:_|_, x0:x1:x2:_|_, ...
06:20:51 <EvilTerran> kacper_, and hence it works for the limit of that series, the infinite list [x0, x1, x2, ...]
06:21:35 <blueonyx> hi, how to use a GHC API Target "supplied with the actual text of the module."? i put the text into the targetContents but GHC panics because he cant find the module or file
06:22:40 <kacper_> so what is denotation of map f _|_ ? is it _|_ ?
06:23:34 <EvilTerran> kacper_, well, from looking at the definition of map
06:23:34 <EvilTerran> ?src map
06:23:34 <lambdabot> map _ []     = []
06:23:34 <lambdabot> map f (x:xs) = f x : map f xs
06:24:48 <EvilTerran> kacper_, you can see it pattern-matches its second parameter, so, if that parameter is _|_, the whole expression's _|_
06:24:50 <EvilTerran> ie, yes.
06:27:16 <kacper_> x:xs pattern-matches _|_ ? so map f _|_ = f _|_ : map f _|_ or what?
06:27:26 <yakov> hey
06:28:13 <EvilTerran> kacper_, in order to see if the pattern "x:xs" matches an expression, the runtime has to evaluate the expression far enough to see what its outermost constructor is ([] or (:))
06:28:50 <EvilTerran> kacper_, so, if the expression never evaluates that far (from either nontermination or throwing an error), the pattern never matches
06:29:22 <EvilTerran> kacper_, so map f _|_ = _|_ directly
06:30:05 <kacper_> and what with reverse [1..] ?
06:30:21 <michael_> Why doesn't > mydivide :: (Double, Double) -> Double  for function  mydivide x y = x/y give a "Type error in explicitly typed binding"?
06:30:59 <FunctorSalad> meh. I have multirec generating some enormous functor, and ghc eats my ram (4gb) and dies. How could I find the problem?
06:31:15 <EvilTerran> kacper_, what property are you trying to prove or disprove about reverse?
06:31:17 <michael_> * why does...
06:31:38 <EvilTerran> michael_, because that should be "mydivide :: Double -> Double -> Double"
06:31:44 <yakov> how can one put package on hackage if .cabal file is generated by configure script?
06:31:59 <FunctorSalad> (btw multirec is pretty neat. it generates the functor describing your initial algebra, but it does this for a family of mutually recursive types...)
06:32:12 <EvilTerran> michael_, "(Double, Double) -> Double" means "takes a tuple of two doubles and returns a double"
06:32:15 <kacper_> i must show when inductions prove of reverse( reverse "infinite list" ) fails
06:32:21 <FunctorSalad> *the functor for which your types are initial algebras
06:32:27 <michael_> EvilTerran, but isn't that type for the curryfied version of mydivide?
06:32:37 <EvilTerran> michael_, no, that's the uncurried version's type
06:32:45 <EvilTerran> ?type let f (x,y) = x/y in f
06:32:46 <lambdabot> forall t. (Fractional t) => (t, t) -> t
06:32:50 <EvilTerran> ?type let f x y = x/y in f
06:32:50 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:33:11 <EvilTerran> kacper_, so you're trying to disprove "reverse . reverse = id", then?
06:34:12 <kacper_> induction base of [] is correct
06:34:39 <EvilTerran> kacper_, that'd be easiest to do by counterexample; (reverse . reverse) (0 : _|_) = _|_
06:34:48 <EvilTerran> (you can work that through to prove it)
06:35:24 <EvilTerran> (and, of course, id (0 : _|_) = (0 : _|_) /= _|_)
06:35:59 <kacper_> so the diference by prooving for finite and infinite is the _|_ ?
06:36:28 <EvilTerran> reasoning about _|_ is one way of getting results for infinite lists, yes
06:36:40 <FunctorSalad> (I guess I might be running into some high-complexity algorithm that doesn't matter for usual programs but does matter for the multirec-generated monster?)
06:37:26 <EvilTerran> kacper_, Richard Bird's writings on equational reasoning in haskell may be relevant to you
06:37:49 <kacper_> have you link for it?
06:39:15 <FunctorSalad> hmm I turned -v4 on with ghc and now it doesn't run out of memory :) (but still working)
06:39:36 <lars9> what kind of projects do you use haskell for?
06:39:59 <koeien> FunctorSalad: all the messages will probably take some time :)
06:40:25 <pejo> lars9, compilers!
06:40:27 <EvilTerran> kacper_, well, there's a list of his work on http://www.comlab.ox.ac.uk/people/publications/date/Richard.Bird.html , although it doesn't seem to have (many, if any) actual papers
06:40:40 <pejo> lars9, and pretty much everything else.
06:41:17 <FunctorSalad> koeien: fortunately konsole deals well with huge outputs...
06:41:44 <koeien> FunctorSalad: my money is on running out of memory eventually :)
06:41:45 <FunctorSalad> (I don't think it acts on every putStrLn call)
06:41:50 <EvilTerran> kacper_, you may be able to google up some of them; "The Algebra of Programming", "Mathematics of Program Construction", etc seem likely to go into this sort of thing in more detail
06:41:53 <michael_> Isn't a text editor written in Haskell?
06:41:57 <koeien> michael_: yi is
06:42:17 <FunctorSalad> koeien: hmm I thought that the verbosity forces flushing of sume buffers that previously grew too fast ;)
06:42:23 <michael_> lars9, then GUI projects!
06:42:28 <FunctorSalad> (wild speculation)
06:42:34 <koeien> FunctorSalad: can be ;) we'll see
06:42:38 <kacper_> thanks a lot ;)
06:42:49 <lars9> GUI projects?
06:43:03 <michael_> lars9, look GUI up
06:43:09 <michael_> lars9, look GUI up
06:43:30 <michael_> lars9, and wxWidgets which i think has bindings for Haskell
06:43:47 <koeien> wxWidgets has, yes, although Gtk2Hs is more popular i believe
06:43:50 <FunctorSalad> koeien: well, stack overflow. previously it was "out of memory, requested x bytes"
06:43:54 <lars9> oh, i'm using Xmonad which is in haskell
06:43:57 <EvilTerran> we've got wxWidgets and GTK bindings
06:44:13 <EvilTerran> (and cairo and opengl, for other graphicy stuff)
06:44:15 <olsner> FunctorSalad: hmm, I don't think the line buffering is done by the rts though
06:44:39 <FunctorSalad> olsner: I'm pretty sure konsole does this
06:44:42 <koeien> FunctorSalad: you could try to increase stack space
06:44:46 <koeien> +RTS ...
06:45:37 <FunctorSalad> yeah, but somehow I doubt it will ever finish...
06:45:56 <olsner> FunctorSalad: what are you doing btw?
06:46:20 <olsner> and are you sure it actually terminates? :P
06:46:24 <FunctorSalad> olsner: trying to run multirec on the types of haskell-src-exts o_O
06:47:34 <FunctorSalad> thought it would be neat to navigate haskell source with a zipper :)
06:51:47 <FunctorSalad> ok, now it did something...
06:53:47 <olsner> now reading "Generic programming with fixed points for mutually recursive datatypes" :)
06:54:16 <olsner> I should write a haskell paper title generator some day
06:56:19 <cypher-> olsner: there is a whole paper generator somewhere on the web
06:56:28 <cypher-> it even generates stuff that sounds vaguely sensible
06:56:36 <cypher-> (at first sight)
06:58:16 <kyevan> I had a weird dream.
06:58:33 <kyevan> Dr. Seuss wrote haskell handbooks.
06:58:45 <kyevan> Also, lots of cakes were involved >_:>
06:59:47 <olsner> @faq can haskell make you dream of cake?
06:59:47 <lambdabot> The answer is: Yes! Haskell can do that.
07:00:14 <EvilTerran> return :: Monad hat => cat -> hat cat
07:03:34 <olsner> this is cool, fixed points for types... reminds me of that other paper that involved the derivatives of types - it used something similar for describing recursive types
07:04:09 <EvilTerran> newtype Mu f = In { out :: f (Mu f) } kinda thing?
07:04:25 <olsner> exactly
07:04:44 * EvilTerran is occasionally amused by Mu Endo
07:05:03 <cypher-> why is it mu?
07:05:45 <kyevan> I read that as occasionally aroused.
07:06:00 <kyevan> I need to get some coffee or something >_<
07:06:09 <cypher-> ah, as in u-recursive?
07:06:13 <thomastc> kyevan: some *hot* coffee? :)
07:06:20 <kyevan> *groan*
07:06:20 <olsner> kyevan: unless amused is just a euphemism :P
07:06:43 * cypher- was indoctrinated to call functions partial recursive rather than mu-recursive
07:06:58 <olsner> in which case that would've been a freudian co-slip
07:07:52 <thomastc> it's 16:07 in the morning here, I need some coffee too
07:09:38 <DRMacIver> Stupid cabal question. I'm trying to use bang patterns in Slicer.hs, but am getting "illegal bang pattern, use -XBangPattern", but as far as I can tell my Cabal file is set up to use bang patterns.
07:09:42 <DRMacIver> Cabal file is here: http://github.com/DRMacIver/slicer/blob/8fa061184c11c867cde603a4c7432236181a1903/slicer.cabal
07:10:23 <Saizan> DRMacIver: you need it in the executable stanza too
07:10:33 <EvilTerran> cypher-, as in the convention in a few situations of writing "mu x. f x" to mean "fixed point of f"; i guess that's related
07:10:46 <DRMacIver> Ah, of course. Thanks
07:10:56 <Saizan> mu = least fixed point, in many notations
07:11:31 * EvilTerran forgot the "least" bit, there <.< >.>
07:14:36 <DRMacIver> Next stupid question: What's the best way to debug stack space overflows.
07:15:10 <cypher-> can someone recommend some good crash course on prolog?
07:15:22 <olsner> run in debugger, break on error, look at the stack trace?
07:15:50 <Twey> cypher-: http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/contents.html
07:16:09 <cypher-> Twey: thanks
07:16:17 <DRMacIver> Hm. I've never actually used the Haskell debugger. Is there really not a simpler way to get a trace from a stack overflow?
07:16:47 <Saizan> DRMacIver: compile with profiling support and run with -hc -xc
07:16:56 <dsouza> \set
07:17:00 <DRMacIver> Saizan: Thanks
07:17:17 <dsouza> whoops, sorry
07:21:38 * EvilTerran hunts for an algorithm for syntactic unification of terms with quantifiers
07:24:20 <EvilTerran> seeing as i can't quite even work out what the result of such a unification would be, i'm kinda stuck =/
07:24:55 <EvilTerran> a most general unifier would be the obvious choice, but i'm not sure what happens with the bound variables
07:28:59 <mmorrow> EvilTerran: look up the W algorithm
07:29:21 * EvilTerran does so
07:30:52 <EvilTerran> mmorrow, ... am i right in thinking it's related to hindley-milner in some way?
07:30:55 <mmorrow> ("milner's W algorithm" mi
07:30:56 <mmorrow> yes
07:31:08 <mmorrow> ..ght be a better search phrase)
07:32:09 <Saizan> HM and W don't really unify terms with quantifies in them
07:32:23 <mmorrow> W does sigma types
07:32:33 <mmorrow> forall a1...an. t
07:32:52 <Saizan> yes, but you don't apply unification to such a thing, afaik
07:33:02 <mmorrow> oh, /unification/
07:33:17 <mmorrow> well, W computes the mgt
07:33:36 <cypher-> me used to do unification on FOL but first skolemized the formulas
07:33:52 <Saizan> right, but generalization and instantation gets dealt with externally
07:33:52 <cypher-> I'm not sure if that helps though
07:33:59 <mmorrow> this looks like a nice quicky run-through http://www.google.com/url?sa=t&source=web&ct=res&cd=9&url=http%3A%2F%2Fuser.cs.tu-berlin.de%2F~magr%2Fpub%2FAlgorithmW.pdf&ei=jh8QSoTEC5GMNZG_4VI&rct=j&q=milner%27s+W+algorithm&usg=AFQjCNHtj1ObrsQnUTE5mHc3vuZ1hsbVDg
07:34:03 <mmorrow> oops gah
07:34:22 <mmorrow> user.cs.tu-berlin.de/~magr/pub/AlgorithmW.pdf
07:34:26 <Saizan> you can see forall a. t as Forall (\a -> t), but then you've to deal with higher order unification
07:34:39 <mmorrow> yeah, W is the vanilla of the vanilla
07:36:08 <mmorrow> err, sorry i mean W compute the most general unifier
07:36:21 <mmorrow> of type defined as:
07:36:24 <EvilTerran> Saizan, well, if you stick to syntactic unification, you wouldn't have to worry about the equational properties of Forall, so it wouldn't be higher-order, surely?
07:36:43 <mmorrow> data T = Prim | Var Int | Forall [Int] T
07:36:45 <EvilTerran> pretend Forall is just another constant
07:36:50 <Philippa> yeah, you basically don't need that at all for H-M
07:37:01 <vixey> Int ?
07:37:02 <Philippa> polytypes are just there to tell you whether it's been instantiated or not
07:37:15 <mmorrow> vixey: "Name", "String", "Walrus", ...
07:37:16 <mmorrow> :)
07:37:31 <EvilTerran> so, for the purposes of unification, you'd only need to think about a single binding syntactic construct
07:38:14 <Philippa> what's the actual problem?
07:38:39 <mmorrow> the punchline of W (that i took away) was that you only deal with closed (w.r.t no free tyvars) types
07:38:59 <mmorrow> close t = let vs = fvs t in Forall vs t
07:39:28 <EvilTerran> Philippa, well, the problem i'm currently trying to solve is syntactic unification of terms in lambda-calculus + constants
07:40:00 <EvilTerran> think "data Expr = VarE Var | ConstE Const | AppE Expr Expr | LambdaE Var Expr"
07:40:03 <vixey> what's "forall" got to do with that?
07:40:08 <Philippa> *nod*. No free tyvars, only free metavars which if you wrote out the constraint system explicitly would be existentially quantified
07:40:28 <Philippa> EvilTerran: requires higher-order unification, can't quite be done
07:40:32 <mmorrow> Philippa: exactly
07:40:43 <Philippa> it's known to be undecidable
07:40:48 <EvilTerran> vixey, nothing at all; hence, in this context, anything called Forall would be "just another constant"
07:40:53 <EvilTerran> blah
07:41:02 <thomastc> anyone here ever experienced lockups with darcs? mine hangs even after "darcs help" eating 100% cpu
07:41:03 <vixey> Girard Heut encodes post problem in HOU
07:41:13 <thomastc> I asked in #darcs but it's pretty quiet there
07:41:22 <EvilTerran> even just syntactic unification's undecidable? that's unexpected =/
07:41:32 <augustss> Gerard Huet?
07:42:08 * EvilTerran expected unification modulo the \-calc equational theory to be undecidable, but not syntactic unification
07:42:11 <Philippa> EvilTerran: syntactic has to respect bindings still
07:42:11 <augustss> s/?/!/
07:42:26 <Philippa> so you have some of the theory tagging along for the ride
07:42:28 <vixey> EvilTerran: wrt. beta reduction or not ?
07:42:57 <mmorrow> EvilTerran: all it is is zipping two trees
07:43:07 <Philippa> if you don't mind breaking bindings then it's just another algebraic type and it's decidable of course
07:43:25 <EvilTerran> vixey, ignoring reduction and suchlike equivalences completely. lambdas just introduce a variable.
07:43:47 <Philippa> EvilTerran: yep, without beta equivalence
07:43:59 <Philippa> oh, wait... no, fair enough, that's a different problem
07:43:59 <EvilTerran> as in, i'd want to be able to unify (\x.x) with (\y.y), but not with (\x.(\y.y)x) or (\x.x)(\y.y)
07:44:09 <vixey> that's fine then, you can represent it in Prolog like \x -> x x  as  lam(X,app(X,X))
07:44:29 <vixey> if you throw beta reduction in the mix this lam(X,...) rep. screws up though
07:44:38 <Philippa> EvilTerran: just up to variable renaming?
07:44:57 <Philippa> if so, name each variable uniquely and then just do dumb unification
07:45:03 <vixey> lam(X,X) = lam(Y,Y) ~~> X = Y
07:45:40 * EvilTerran realises he doesn't really know what he's trying to do
07:46:01 <vixey> yeah like Philippa says, \x -> x (\x -> x) should be  lam(X,app(X,lam(Y,Y)))
07:46:52 <augustss> So then it's not really higher order unification
07:47:02 <EvilTerran> thanks for the insight, guys. now to think for a bit longer about what i actually want. :S
07:47:11 <vixey> what is the application of this ?
07:47:37 <EvilTerran> well, in theory, it was to be for use in a proof assistant
07:47:51 <vixey> some kind of a type theory based on?
07:47:55 <vixey> one*
07:48:14 <vixey> btw I think HOU isn't undecidable
07:49:02 <EvilTerran> i figured, given variable binding, application, and constants, you could define arbitrary theories to reason in by adding appropriate constants and refinement rules
07:49:27 <Philippa> vixey: it is. HTH HAND. Same problem as inference for System F. Adding annotations makes it different
07:49:27 <vixey> it sounds like you're iventing LF :p
07:49:42 <vixey> Philippa: pretty sure there's a semi-decision algorithm actually
07:49:47 <EvilTerran> LF?
07:49:48 <vixey> always suceeds if there is a unifier
07:49:49 <Philippa> which isn't decision
07:50:12 <vixey> logical framwork, like Twelf and stuff
07:50:29 <Philippa> I mean, if you can check is-unifier, then there's a semi-decision algorithm: enumerate all terms...
07:50:41 <vixey> in practice semi-decidable is a lot different to undecidable
07:51:09 <DRMacIver> Hm. No, I can't figure out how to get useful information about stack overflows from either of the debugger orC[C[C[C[C +RTS -xc. The only noticable difference with -xc is that I get a pretty <><><> before the stack space overflow error.
07:52:03 <EvilTerran> vixey, it looks like that might be closely related to what i was trying to do. ah well.
07:52:53 <EvilTerran> i'm an undergrad, it's going to be at least a couple of years before i'm well-enough read in the field to come up with things that haven't already been invented
07:53:33 <DRMacIver> And the debugger output is http://pastebin.com/m5ddf183b which I can't seem to make sense of
07:57:11 <Saizan> DRMacIver: you should run the expression under :trace
07:57:16 <Saizan> to get any history
07:57:18 <DRMacIver> Oh, right.
07:57:19 <DRMacIver> Thanks
07:57:46 <Saizan> and, when compiling for profiling you should add -auto-all -caf-all
08:18:22 <DRMacIver> I don't suppose anyone wants to take pity on me and help me find this error? :) I'm drawing a total blank here, probably mostly through unfamiliarity with the tools (it's been a while since I've written Haskell, and most of my debugging attempts previously were fortunately quite easy to pin point)
08:18:52 <DRMacIver> Code is at http://github.com/DRMacIver/slicer/tree/master . It stack overflows on either feeding it a large input file or calling "slice defaults [1..1000000]"
08:19:00 <DRMacIver> I can't figure out where the stack overflow is coming from though
08:20:55 <olsner> > minimum [1..1000000]
08:20:57 <lambdabot>   * Exception: stack overflow
08:21:41 <DRMacIver> the list I'm calling minimum on should only have four elements
08:22:03 <DRMacIver> Oh. But the list I'm calling sum on isn't.
08:22:21 <MyCatVerbs> sum is defined as foldl (+) for some insane reason.
08:22:38 <MyCatVerbs> You want to import Data.List, and use foldl' (+).
08:23:52 <DRMacIver> Yeah. I knew that, it just failed to occur to me when I wrote that and I hadn't spotted it in the code.
08:24:03 <Saizan> for Int/Integer there are rules to rewrite it to foldl'
08:24:18 <Axman6> > minimum [minBound .. maxBound] :: Int32
08:24:34 <DRMacIver> Saizan: Oh. Hm. Then I guess that isn't it.
08:24:44 <DRMacIver> And indeed specialising it manually didn't fix the problem
08:24:45 <MyCatVerbs> Also, (sum x) / (length x) is not a fantastic way to calculate a mean.mmm
08:24:55 <byorgey_> DRMacIver: are you compiling with -O2?
08:25:07 <DRMacIver> byorgey_: At the moment, no, but the problem doesn't go away when I do.
08:25:10 <lambdabot>   thread killed
08:25:54 <DRMacIver> MyCatVerbs: Not fantastic in which way? Numeric stability or GCing the head of the list issues?
08:25:54 <Axman6> > minimum [minBound .. maxBound] :: Int16
08:25:58 <lambdabot>   -32768
08:26:51 <pejo> MyCatVerbs, what you see in @src is not what GHC necessarily uses.
08:26:53 <DRMacIver> For the latter it needs the whole list in memory anyway, for the former... well, consider me lazy. I didn't think it was that big a deal and there wasn't a correct implementation readily to hand. :)
08:27:14 <MyCatVerbs> DRMacIver: the latter. Maybe the former too if the elements are floating point numbers but it's really difficult to observe that. ;p
08:27:54 <DRMacIver> MyCatVerbs: That's not such a big deal here. I basically have to hold the whole list in memory anyway (this isn't technically true, but I have to hold equivalently large things in memory)
08:28:57 <DRMacIver> ok. So this doesn't seem to be minimum or sum. I replaced sum with a strict tail recursive version and it blows up in exactly the same way, and the minimum is definitely only being called on a list of 4 elements
08:31:11 <MyCatVerbs> DRMacIver: sample input data?
08:33:10 <DRMacIver> MyCatVerbs: Almost any big line separated list of integers will work. Hold on though, I'll commit the data I'm running on.
08:33:33 * EvilTerran 's brain shorts out and shuts down
08:35:29 <DRMacIver> Hm. I won't commit it actually, as it's 5M and I don't really want it in source. Will upload it to my webserver. One second
08:35:48 <DRMacIver> (And it doesn't seem to stack overflow on anything much smaller than that)
08:36:16 <MyCatVerbs> DRMacIver: er, hang on, I can do it with a big old randomR output anyway, no?
08:36:22 <DRMacIver> MyCatVerbs: Yeah
08:36:37 <DRMacIver> MyCatVerbs: http://www.drmaciver.com/sampledata for what it's worth, but random data should work just as well
08:37:44 <olsner> slice defaults [1..10000000] also reproduces the stack overflow pretty quickly
08:37:49 <DRMacIver> Yeah
08:38:18 <duaneb> @src defauls
08:38:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:38:19 <duaneb> @src defaults
08:38:19 <lambdabot> Source not found.
08:38:54 <duaneb> @src slice
08:38:54 <lambdabot> Source not found. You speak an infinite deal of nothing
08:38:55 <duaneb>  :/
08:39:12 <DRMacIver> duaneb: defaults and slice are from the code I posted. :)
08:39:31 <DRMacIver> I don't think lambdabot indexes github
08:40:10 * EvilTerran thinks it'd be cool if hpastes generated modules visible to lambdabot
08:40:37 <duaneb> ahh
08:40:38 <duaneb> heh
08:40:41 <duaneb> it should, I think
08:41:18 <EvilTerran> "?type HPaste4920.done" kinda thing
08:41:54 <Berengal> That would be nifty...
08:43:19 <EvilTerran> that way, you could hpaste a relatively long function definition, and then demo it realtime via lambdabot
08:43:22 <MyCatVerbs> DRMacIver: I just ran it over ~8k random integers and got an answer in four seconds' CPU time. :|
08:43:39 <olsner> DRMacIver: I got a stack overflow in sum', but changing that to foldl' seems to move the stack overflow somewhere else
08:45:31 <DRMacIver> olsner: Oh, hm. Embarrassing that I screwed up sum'.
08:46:26 <DRMacIver> olsner: sum' was added in in the course of debugging, so assuming ghc does the right thing for sums of lists of ints (someone mentioned it did) it's not surprising there are still stack overflows
08:46:35 * EvilTerran ponders some way of structuring a recursive function so the strictness could be specified after the fact
08:47:17 <DRMacIver> Out of curiousity, why is the sum' I wrote not tail recursive?
08:48:22 <DRMacIver> Oh, interesting. genericLength isn't tail recursive either
08:49:34 <EvilTerran> "sumS :: Num n => (forall a b. a -> b -> b) -> [n] -> n; sumS strictness = go 0 where go t [] = t; go t (x:xs) = t `strictness` go (t+x) xs" kinda thing
08:50:47 <EvilTerran> with "strictly = seq; lazily = flip const", say, so you'd get "sumS strictly" and "sumS lazily"
08:51:38 <Berengal> EvilTerran: With foldl and foldl' we dont' have too big a need for that I think
08:51:55 <DRMacIver> Huzzah. Problem goes away if I manually write a strict length and use that instead of genericLength
08:51:59 <DRMacIver> Thanks everyone
08:52:30 <EvilTerran> Berengal, eh, true; i might keep thinking about it, though, see if i can think of some novel trick like that that's potentially nicer than using foldl vs foldl'
08:53:06 <DRMacIver> It doesn't even take too long to run on this data
08:53:06 <neoswish> is it a good idea to use general class for all binary operators a -> b -> c ? then it will be possible to use them anywhere you like =)
08:53:54 <DRMacIver> It doesn't even take too long to run on this data (longer than I'd like, but well within the bounds of "well that's just a matter of optimisation")
08:54:23 <jlaire> I have very long lists of Int64s and need to remove duplicates; what's a good way to do this? to IntSet and back eats too much memory
08:54:30 <EvilTerran> the bounds of "i need more research grant so i can buy a faster computer, honest" :P
08:55:11 <MyCatVerbs> jlaire: sort them and then scan the list dropping adjacent identical elements.
08:55:38 <jlaire> MyCatVerbs: ok thanks, I'll try that
08:57:02 <DRMacIver> EvilTerran: I don't believe in throwing hardware at problems. :)
08:57:57 <MyCatVerbs> DRMacIver: throwing problems at hardware is much more fun. :3
08:58:02 <EvilTerran> DRMacIver, feel free to throw it at me instead, if you'd rather. i could use some new hardware. :P
08:59:30 <DRMacIver> Not throwing hardware at problems isn't the same as not cheerfully making use of the best hardware I can get my hands on. ;)
09:00:51 <DRMacIver> I wonder if it's worth putting this on hackage. It's really special purpose, so probably not.
09:05:05 <qaz> OO took a mathematical discipline and turned it into biology. it is time we make it mathematics again. yay for functional programming!
09:05:40 * Badger silences qaz before he can spread his propaganda further
09:06:26 <MyCatVerbs> DRMacIver: eh, if it's stable and useful to at least somebody... :)
09:06:49 <MyCatVerbs> I mean, the more libraries there are on Hackage, the better it compares with CPAN for our propaganda efforts. ;3
09:09:01 <olsner> hmm, why would nub . sort be more efficient than fromSet . toSet?
09:09:03 <cypher-> yeah, but if Hackage gets cluttered with marginally useful libraries it will hurt the propaganda more than help it
09:09:40 <pao> is it all about monads tutorial still relevant? is it worthwhile to send the author notice about typos?
09:09:51 <pao> s/it/the/
09:10:02 <jlaire> sorting is even less space efficient, I'll try switching to arrays
09:10:30 <MyCatVerbs> jlaire: if you're having trouble with space consumption, be sure to use unboxed arrays rather than boxed ones.
09:10:39 <jlaire> MyCatVerbs: sure I will
09:10:52 <MyCatVerbs> pao: well, it's still accurate, and it's a good explanation of how most of the standard ones work, so sure.
09:11:12 <pao> MyCatVerbs: thanks
09:11:32 <byorgey> qaz =)
09:12:04 <byorgey> olsner: it isn't.  not asymptotically, at least.
09:12:26 <byorgey> although I could believe that it's more efficient for small lists.
09:12:52 <byorgey> and if you're using nub anyway there's no reason to be using sort.
09:13:36 <MyCatVerbs> pao: I'm thinking, nnnno, thank *you*. ;)
09:13:44 <trofi> > nub [1,2,3,1,2,3]
09:13:45 <lambdabot>   [1,2,3]
09:13:45 <DRMacIver> MyCatVerbs: Well, I'm not yet entirely sure it's either of those. But we'll see. :)
09:13:52 <duaneb> @src nub
09:13:52 <lambdabot> nub = nubBy (==)
09:13:57 <duaneb> @src nubBy
09:13:57 <lambdabot> nubBy eq []             =  []
09:13:57 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:14:18 <trofi> @src eq
09:14:18 <lambdabot> Source not found. Do you think like you type?
09:14:27 <pao> MyCatVerbs: :-)
09:15:05 <duaneb> ok
09:15:07 <duaneb> wish me luck
09:15:13 <duaneb> I'm going to the dark side: OCaml
09:16:02 <byorgey> good luck duaneb!
09:16:28 <byorgey> that's not the dark side, that's like the insufficiently light side
09:16:30 <duaneb> thanks :)
09:16:33 <duaneb> heh
09:16:36 <byorgey> PHP is the dark side
09:17:09 <Taejo> BrainFuck is the magenta side
09:18:37 <duaneb> malbolge is the dark side.
09:19:59 <Smorg> Does lambdabot require a particular implementation of brainfuck?
09:20:15 <Smorg> I'm trying to get it going on gentoo - there seems to be quite a few dependencies missing
09:20:33 <qaz> > eq 1 2
09:20:34 <lambdabot>   Not in scope: `eq'
09:20:47 <qaz> > Data.Eq.eq 1 2
09:20:47 <lambdabot>   Not in scope: `Data.Eq.eq'
09:20:52 <qaz> > Data.Bool.eq 1 2
09:20:53 <lambdabot>   Not in scope: `Data.Bool.eq'
09:25:04 <hatds> are there any types in the standard libraries that come with their own pretty printers?
09:25:52 <malouin> Does ghc make the linker work hard in general?  I am seeing ld processes that are using >500 MB of ram.
09:28:14 <duaneb> malouin: There's usually some magnitude greater code (and symbols to link) generated by ghc
09:29:08 <malouin> duaneb: ok, that makes sense.
09:29:32 <wli> It does so far more often than e.g. C/C++ compilers. In general, not horrendously so.
09:31:28 <ehird> "Haskell monads are like blog analogies about Haskell monads" —http://www.reddit.com/r/programming/comments/8kpgj/i_have_decided_to_learn_haskell_what_books/c09lood
09:33:47 <malouin> is there a way to get ghc to invoke ld with --no-keep-memory?
09:34:22 <hatds> you can pass flags to linkers by passing a flag to ghc
09:34:26 <Igloo> -optl--no-keep-memory
09:34:43 <hatds> that :)
09:35:36 <malouin> thanks
09:41:32 <burp_> how can I create such a http://hackage.haskell.org/packages/archive/numeric-prelude/0.1/doc/html/MathObj-Matrix.html matrix?
09:42:10 <skorpan> burp_: probably using fromList
09:42:24 <burp_> uh right
09:42:32 <burp_> I just overlooked that
09:43:05 <burp_> thanks :)
09:43:07 <skorpan> np!
09:43:32 <skorpan> anyone good with alex here?  i'm trying to write a regular expression using alex's regexp syntax to match multiline comments, C style, i.e. /* .. */
09:46:05 <duaneb> there needs to be an article "ocaml for haskell users"
09:47:04 <jnaimard> the worst is the syntax
09:49:53 <monadic_kid> duaneb: i dont see the point when you just look at the language spec
09:50:21 <duaneb> monadic_kid: I need to use it for work
09:50:39 <monadic_kid> duaneb: how does that change anything?
09:50:45 <duaneb> monadic_kid: oh, I see
09:50:48 <duaneb> the point of the article?
09:51:03 <duaneb> because I don't want to read a spec
09:51:12 <monadic_kid> duaneb: you don't have to read it all
09:52:20 <monadic_kid> duaneb: i'm sure you can find a cheetsheet somewhere anyways
09:58:02 <malouin> so is there any way to specify something like -optl to ghc that would always have affect?  My other option seems to be to figure out how to get cabal to always tell ghc to pass these linker options.
09:58:39 <Raevel> the latter: put GHC-Options: -optl under the library section of your .cabal
09:58:58 <malouin> Raevel: ok, that seems good.
10:02:10 <Philonous> If I had an IO action that yields a result and I wanted to execute this action once and for all subsequent calls to it return the memoized result, how would I do that?
10:03:59 <Philonous> Or rather: I generate those actions on the fly.
10:04:26 <malouin> Raevel: is that a cabal thing, or a cabal-install thing?
10:04:33 <Heffalump> Philonous: are you generating it in IO?
10:04:43 <Philonous> Yes
10:04:47 <Heffalump> if so, construct an IORef (Maybe result) at the same time and store the result in that
10:04:49 <malouin> Raevel: whoops nevermind, I found it.
10:05:33 <Heffalump> so you can make something like IO (IO result), where the outer IO constructs the IORef, and the inner IO does the actual caching using the IORef.
10:06:23 <Philonous> fair enough
10:15:44 <ehird> Cale: your efforts were for naught; it seems that grauenwolf is just repeating his same example
10:15:54 <Philonous> Is it sensible to put an IO function (a -> IO b) in unsaferPerfomIO and then use memocombinators on it? (that action would of course be referentially transparent)
10:18:36 <hatds> if it is referentially transparent couldn't you use ST?
10:19:08 <MoxJet> Is there a function that takes a Double and returns its IEEE representation?
10:19:49 <Philonous> It reads data from files (that should not change during program execution, if they do I get all sorts of different problems)
10:20:15 <ehird> Philonous: Shouldn't, but you cannot guarantee that.
10:25:17 <Heffalump> MoxJet: there's no trivial and portable one
10:25:32 <Heffalump> there's an unportable thing you can do with GHC involving unsafeCoerce on the unboxed representation
10:26:09 <Heffalump> or you can write the portable one by hand using decodeFloat
10:26:36 <codolio> You'd probably need a couple other functions, too.
10:26:45 <dolio> Like isNaN.
10:27:12 <dolio> Unless you want to figure out what decodeFloat turns NaN into, and check for that specifically.
10:27:19 <dolio> > decodeFloat (0/0)
10:27:20 <lambdabot>   (-6755399441055744,972)
10:27:28 <dolio> > decodeFloat (0/0 :: Double)
10:27:29 <lambdabot>   (-6755399441055744,972)
10:27:37 <dolio> Huh, I thought it was worse than that.
10:27:44 <duaneb> anyone else use haskell on TextMate?
10:27:44 <dolio> > decodeFloat (1/0 :: Double)
10:27:45 <lambdabot>   (4503599627370496,972)
10:27:52 <duaneb> the haskell support is pretty horrendous :P
10:28:45 <hatds> how do you use the pretty printer library to pretty print a tree-like structure?
10:29:04 <MoxJet> Heffalump: thanks :)
10:29:25 <hatds> "nest" doesn't seem to move things to the next line
10:30:36 <hatds> ah wait
10:31:06 <hatds> how do you get ghci to show a string and convert newlines instead of printing "\n"?
10:31:35 <dolio> > decodeFloat 1e-100
10:31:36 <lambdabot>   (7880401239278896,-385)
10:31:58 <MoxJet> hatds: use putStr
10:32:39 <hatds> MoxJet: thanks
10:32:40 <qaz> hmm playing around with Erlang. Haskell really is a lot more complex and seems neater event hough it has a much higher learning curve
10:32:47 <qaz> but Erlang has a nice platform in OTP
10:35:26 <tetha> erlang certainly is interesting
10:40:35 <cayennext> Hi! I am in the middle of my excercise from college, and I am trying to generate a sequence and having some troubles with it. Could you help? I am writing generator which takes a number and a list of lists of numbers and returns a list with so many different numbers as a number in param says and number on i'th position should be one of numbers from param list on i'th place.
10:40:46 <cayennext> generate :: Int -> [[Int]] -> [[Int]]
10:40:46 <cayennext> generate _ [] = [[]]
10:40:46 <cayennext> generate diff (x:xs) = [ choosen:generate diff xs | choosen <- x]
10:41:02 <cayennext> I come up with this, but it doesn't work, type error
10:42:39 <duaneb> > let birthday d n = 1 - (foldr (\x a -> a * (1 - ((fromIntegral x) / d))) 1.0 [1..(n-1)]) in map (birthday 365) [1..35]
10:42:40 <lambdabot>   [0.0,2.739726027397249e-3,8.204165884781345e-3,1.6355912466550215e-2,2.7135...
10:42:42 <dolio> x :: [Int], so choosen :: Int, but generate diff xs :: [[Int]].
10:42:54 <dolio> And trying to prepend an Int onto an [[Int]] is a type error.
10:43:37 <duaneb> > let birthday d n = 1 - (foldr (\x a -> a * (1 - ((fromIntegral x) / d))) 1.0 [1..(n-1)]) in map (birthday 365) [20..30]
10:43:39 <lambdabot>   [0.41143838358058005,0.44368833516520567,0.47569530766254997,0.507297234323...
10:43:42 <dolio> Also note that you're always choosing elements from the first list in your list of lists. I don't know if that's what you want or not.
10:43:49 <MoxJet> duaneb: nice :)
10:45:45 <cayennext> I tried to map with (:): generate diff (x:xs) = [ map (\rest -> choosen:rest) $ generate diff xs | choosen <- x]
10:46:01 <duaneb> MoxJet: thanks :)
10:46:03 <cayennext> but it also has type errors
10:49:21 <mightybyte> Is there a function ismilar to bind where the monad is different?  i.e. :: m1 a -> (a -> m2 b) -> m2 b
10:50:04 <vixey> mightbyte: no
10:50:13 <Valodim> how would that work, not all monads are interchangable..
10:50:49 <mightybyte> The specific case I'm looking at is where m1 is Maybe.
10:51:08 <roconnor> @type maybe (fail "Nothing") return
10:51:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
10:51:14 <mightybyte> ...and I'm operating in another monad and would like to avoid the case.
10:51:37 <mightybyte> roconnor: I was hoping to avoid fail
10:51:40 <vixey> you 'avoid the case' by using something equivalent
10:52:37 <vixey> mightbyte: why don't you just write your own function
10:52:42 <mightybyte> Right, and Maybe's Monad instance is designed to do this, but I'm wondering if there is an idiomatic way to do this in this case.
10:53:08 <vixey> show your code and I'll say if it's idiomatic
10:53:24 <cayennext> Now it works, thanks for help :) | generate diff (x:xs) = [ choosen:rest | choosen <- x, rest <- generate diff xs]
10:59:14 <mightybyte> vixey: Well, the obvious way was: do maybea <- ...; case maybea of (Just a -> f a) (Nothing -> g)
11:00:40 <mightybyte> But I was hoping to take advantage of Haskell's machinery to avoid the boilerplate case of.
11:00:43 <vixey> ok now write a function that does it
11:00:50 <vixey> stop babbling about boilerplate and low hanging fruit
11:00:56 <gio123> does haskel uses context variables?
11:02:00 <mightybyte> Writing the function is easy.  But if I just did that every time I came upon issues like this, I'd never learn about all the generic machinery that Haskell has available.
11:02:17 <mightybyte> I look, but what I'm looking for isn't always easy to find.
11:02:35 <vixey> write the function now
11:04:53 <mightybyte> liftMaybe f g Nothing = g
11:05:01 <mightybyte> liftMaybe f g (Just x) = f x
11:05:47 <vixey> mightybyte: that already exists called 'maybe'
11:05:58 <hatds> hmm.. why isn't there a pretty printing typeclass?   Language.Haskell.Pretty defines one but it exports it as an abstract class
11:06:04 <mightybyte> Ahhh
11:06:29 <mightybyte> For some dumb reason, I was thinking that wouldn't work in my monadic context.
11:07:34 <augustss> hatds: there's a pretty printing class on hackage
11:07:47 <dancor_> is there a good way to return an autoincrement column as i insert a row in HDBC-postgresql
11:08:03 <augustss> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/prettyclass
11:08:09 <hatds> augustss: yea, but I might as well roll my own in that case
11:08:17 <augustss> hatds: why?
11:08:50 <augustss> hatds: it's better to reuse, that's why we have hackage
11:09:19 <hatds> augustss: no, I just want a typeclass with one fucntion "pretty : a -> Doc"
11:09:19 * dancor_ seconds reuse  :)
11:09:33 <matthew-_> hmm, how would people recommend I test for substring?
11:09:44 <matthew-_> i.e. "bc" is a substring of "abcd"
11:09:46 <dancor_> matthew-_: isInfixOf?
11:09:58 <Colours_> hi! is this the place to ask for help regarding non-working cabal packages?
11:10:10 <matthew-_> @where isInfixOf
11:10:11 <lambdabot> I know nothing about isinfixof.
11:10:18 <dancor_> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:isInfixOf
11:10:25 <dancor_> @hoogle isInfixOf
11:10:26 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
11:10:26 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
11:10:26 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
11:11:02 <hatds> augustss: there is such a typeclass in the standard libraries, but they won't let you declare instances
11:11:04 <hatds> :(
11:11:25 <matthew-_> dancor_: excellent, many thanks
11:11:57 <dancor_> hatds: you only have to define pPrint in Pretty, right?
11:12:15 <hatds> dancor_:  pPrint?
11:12:31 <dancor_> i don't understand how prettyclass is harder than what you want
11:14:12 <hatds> what is prettyclass? all I see is  Language.Haskell.Pretty.Pretty
11:14:21 <dancor_> http://hackage.haskell.org/packages/archive/prettyclass/1.0.0.0/doc/html/Text-PrettyPrint-HughesPJClass.html
11:15:48 <hatds> I see
11:16:01 <hatds> what I meant before is that I'm too lazy to download a file
11:16:05 <dancor_> oh
11:16:13 <mm_freak> say i have a manager and a lot of workers with a lot of threads and there is a lot of communication…  are TVars fast?
11:16:40 <hatds> but I guess I don't have the luxury of a built in class :)
11:16:43 <dancor_> cabal install will do that for you!  :)
11:16:44 <mm_freak> because with MVars i'm running into the problem that i can't want on multiple MVars at the same time
11:17:40 <thou> hi, would someone be willing to help with sorting out a strictness problem (I think): using hGetContents + $! + parsec:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4960#a4960
11:17:48 <zakwilson> I have lists of 32-bit integers on which I'm calling elem millions of times. This is slow. Can someone recommend a faster data structure to use? Storable Vector looks like the Right Thing, but I thought I'd check.
11:18:09 <Cale> zakwilson: Set
11:18:15 <thou> my program is working OK, except that it prints out info only at the very end, and uses gobs of memory during the process
11:18:25 <Cale> zakwilson: Or even IntSet
11:18:27 <thou> do i need DeepSeq or similar?
11:19:09 <hatds> try to understand your strictness problems using `seq` and $! first
11:19:11 <zakwilson> Cale: I'll try that. I should note that order does not matter for any other purpose, though it seems that you already guessed that.
11:19:36 <Cale> zakwilson: Well, even if it did matter, you could collect them all into a Set anyway.
11:20:10 <mm_freak> are TVars much slower than MVars?
11:20:22 <thou> hatds: thanks, i'm not sure how to break this down more: parseContents h = hGetContents h >>= \s -> return $! parse Rfc822.message "" s
11:20:35 <gio123> does haskel uses context variables?
11:20:46 <Cale> thou: Are you sure it's a strictness problem at all?
11:20:57 <Cale> gio123: What's a context variable?
11:21:19 <gio123> variable which can be instatiated by context
11:21:37 <Cale> gio123: I'm not sure what that means.
11:21:38 <thou> Cale: no, i just can't think what else it would be -- if I parse 1000 messages, nothing gets printed until the very end of the program, and it's used up 1G of RAM at that point
11:21:45 <gio123> context is a term with single occurence of hole, for instance f(a,hole)
11:22:05 <Cale> thou: If is has anything to do with strictness, that means it is already too strict.
11:22:37 <thou> Cale: if i change $! to $, then it blazes through it and returns (Message [] "") for every file
11:22:43 <Cale> gio123: People construct special purpose datastructures for representing things of that sort, I suppose. It sounds like a zipper.
11:22:43 <mm_freak> hmm…  do TVars resemble MVars at all?  i'm not sure
11:23:14 <mm_freak> oh lol
11:23:19 <Cale> thou: Of course $! won't change the end result vs $, only performance aspects.
11:23:20 <mm_freak> there are TMVars for that
11:23:26 <Cale> thou: So does that help?
11:24:17 <Cale> thou: It sounds like either your parser is failing or you need to filter the output.
11:24:21 <Cale> (or both)
11:24:24 <thou> Cale: i'm sorry, does what help?
11:24:29 <koeien> the -cafe is down?
11:24:38 <Cale> thou: Well, it sounds like $ is performing better than $!
11:24:52 <thou> yes, much - but it isn't actually reading any of the input :-/
11:25:01 <Cale> Are you sure?
11:25:08 <Cale> oh!
11:25:10 <Cale> I see
11:25:21 <Cale> You're calling hClose on an hGetContents'd handle
11:25:25 <Cale> You should never ever do that.
11:25:28 <thou> yes
11:25:47 <Cale> If you run hGetContents on a handle, consider it as being essentially closed.
11:25:50 <thou> i was trying to use something like this solution: http://www.mail-archive.com/haskell-cafe@haskell.org/msg31557.html
11:25:51 <Cale> (it's half-closed)
11:26:52 <thou> >readFile' f = do s <- readFile f
11:26:52 <thou> >                 return $! (length s `seq` s)
11:26:53 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
11:27:06 <thou> I tried this readFile' solution, too, but it had the same symptom
11:27:09 <Cale> If you really *need* to close the file-handles (operating systems can be picky about resources), then what you can do is use the Data.ByteString.Char8 version of hGetContents
11:27:21 <Cale> (or readFile)
11:27:43 <Cale> (not the lazy bytestring version)
11:27:53 <thou> right, i forgot to mention the reason i started this whole thing, was that i'm running out of file handled
11:28:02 <Cale> The difference is that version will slurp the whole file into a buffer at once.
11:28:33 <thou> ok, so "use (strict) bytestring module" is the best solution
11:28:43 <Cale> The normal hGetContents isn't good when you need to open a lot of files, because once you apply it, you're essentially handing control of that filehandle over to the garbage collector.
11:28:48 <Cale> yeah, I think so
11:28:55 <Cale> Also, it'll probably help performance anyway
11:29:12 <thou> Cale: thanks a ton, i'll give that a shot.  btw, you're a saint - i see you in here all the time answering crazy questions from people like me, it's amazing
11:29:39 <Cale> My powers of procrastination know no bounds ;)
11:29:43 <thou> hahaha
11:30:27 <thou> well, you still have somethign to procrastinate on, so you must be succeeding somehow :-)
11:31:30 <Cale> :)
11:35:23 <mercury^> Cale: IRC is a community effort of procrastination. We help each other out with it here.
11:35:40 <Cale> mercury^: Yeah :)
11:38:23 <mercury^> A friend of mine once linked me this and then disappeared from IRC: http://lifelongactivist.com/file_download/35/ . Naturally, I haven't touched it yet.
11:38:42 <qaz> the problem with haskell is it takes to long to really learn and appreciate its greatness
11:39:23 <Cale> qaz: I wonder if that's actually a problem ;)
11:39:41 <qaz> not if you want it as your secret weapon perhaps
11:41:03 <vixey> > map ord "А Б В Г Д Е З И К Л М Н О П Р С Т У Ф Ц Ч Э Я"
11:41:04 <lambdabot>   [1040,32,1041,32,1042,32,1043,32,1044,32,1045,32,1047,32,1048,32,1050,32,10...
11:41:14 <vixey> > map chr [1040..]
11:41:15 <lambdabot>   "\1040\1041\1042\1043\1044\1045\1046\1047\1048\1049\1050\1051\1052\1053\105...
11:41:18 <vixey> :///
11:41:27 <vixey> > var $ map chr [1040..] :: Expr
11:41:28 <lambdabot>       Ambiguous occurrence `var'
11:41:28 <lambdabot>      It could refer to either `Data.Number.S...
11:41:38 <vixey> why does't it just do unicode by default ??
11:41:44 <deech> Hi all,
11:42:34 <deech> Is there some way of using HaXml to turn an XML document into a Data.Map where the key is a the tag and the value is its contents?
11:45:30 <Cale> deech: I'm sure it can be done. I doubt there's a library function for it.
11:46:04 <gio123> Cale: pm please
11:47:32 <dancor_> vixey: what should it do?
11:47:58 <vixey> work properly
11:48:16 <dancor_> why doesn't haskell print unicode by default?
11:48:31 <vixey> I don't because it sucks?
11:48:39 <vixey> @faq can haskell suck when it comes to unicode
11:48:39 <lambdabot> The answer is: Yes! Haskell can do that.
11:48:40 <duaneb> ok, I'm rewriting the damn TextMate haskell bundle
11:49:05 <dancor_> vixey: you keep confusing me by leaving out words and letters.
11:49:09 <cypher-> hmm.. lack of good unicode support is a real issue
11:49:20 <dancor_> ironically.  anyway, ya it is a real issue
11:49:34 <Athas> GHC doesn't use Unicode by default?
11:50:17 <dancor_> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg21451.html
11:51:38 <Athas> Oh, that's good to know.  Unicode is something I care a lot about on an ideological plane.
11:52:01 <dancor_> extended ideological plane
11:55:26 <dancor_> s/extended/supplementary/   no more poorly-researched unicode humor
11:55:37 <burp_> anyone know how I can access specific matrix entries in a matrix from numeric-prelude?
11:55:46 <burp_> ( this one http://hackage.haskell.org/packages/archive/numeric-prelude/0.1/doc/html/MathObj-Matrix.html)
11:57:34 <burp_> hm, guess that has to be done with rows and columns
11:59:43 <Taejo> :t unfoldr
11:59:43 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:06:54 <Gracenotes> :.:
12:07:10 <Gracenotes> .:: ::.
12:07:29 <mm_freak> the namespace of record fields should be somehow attached to the type name
12:08:18 <kacper_> i have a question, does "map f ( xs ++  ys ) = map f xs ++ map f ys" is correct for infinite lists?
12:08:19 <mm_freak> like Type.fieldName
12:08:38 <mm_freak> kacper_: yes
12:08:40 <blackh> In QuickCheck's Gen monad, 'rand' returns the StdGen - but how can I push it back into the monad after I've used it?  Or otherwise make sure that the random numbers aren't duplicated?
12:10:23 <vixey> kacper_: it is true but I can't prove it
12:11:00 <kacper_> for finite list it's easy way to prove but for infinite not ;)
12:12:32 <mm_freak> kacper_: well, it's not straightforward to prove
12:12:40 <qaz> is there no function to split a list in half?
12:12:42 <mm_freak> you may find the wikibooks article about denotational semantics interesting
12:12:51 <vixey> How do we prove an equation between infinite lists?
12:12:53 <bombshelter13_> Hi... I'm trying to follow the tutorial on http://blog.haskell.cz/pivnik/building-a-shared-library-in-haskell/ to build a shared library written in Haskell that's accessible from C. Right now, Right now I'm trying to compile the code in the third 'code box' on the page using the ghc syntax shown in the fourth 'code box', as he instructs... however, it's resulting in an error about an undefined symbol, so i'm wondering if something is
12:12:58 <mm_freak> qaz: see splitAt, length and div ;)
12:13:24 <mm_freak> kacper_: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
12:13:52 <mm_freak> does GHC support shared libs now?
12:14:23 <mm_freak> on x86, that is
12:15:15 <Cale> bombshelter13_: Your message was cut off at "something i"
12:15:35 <bombshelter13_> ... is wrong with my setup. The error it's generating is here, any ideas would be appreciated: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4961#a4961
12:15:52 <bombshelter13_> there's the rest ;)
12:17:20 <Cale> bombshelter13_: Well, I can try doing what you're doing and see...
12:17:44 <bombshelter13_> yeah, i'm trying to get sshed into another system to try it there as well, curious to see what your results wil lbe
12:17:56 <Cale> worksforme
12:18:10 <Cale> What version of ghc are you using?
12:18:19 <Cale> This seems like something possibly newish.
12:18:26 <Cale> I didn't even know ghc could make .so files.
12:18:59 <bombshelter13_> Heh, on the second system I've tried it on, I got a completely different error. Let me check my version
12:19:03 <Cale> cale@zaphod:~$ ghc --version
12:19:03 <Cale> The Glorious Glasgow Haskell Compilation System, version 6.10.3
12:19:11 <bombshelter13_> 6.10.1
12:19:14 <Cale> hmm
12:19:34 <bombshelter13_> does it work for you?
12:20:16 <Cale> yes
12:20:28 <Cale> cale@zaphod:~$ ghc -O2 --make -no-hs-main -optl '-shared' -o Test.so Test.hs
12:20:28 <Cale> [1 of 1] Compiling Test             ( Test.hs, Test.o )
12:20:28 <Cale> Linking Test.so ...
12:20:28 <Cale> cale@zaphod:~$
12:20:42 <bombshelter13_> Hm, I'm gonna try to get 6.10.3 and see if that makes a difference.
12:20:57 <vininim> is 6.10.3 going to hit Leonidas?
12:21:10 <Cale> What is Leonidas?
12:21:13 <vininim> fedora 11
12:21:35 <Cale> ah
12:21:53 <bombshelter13_> Hm, ports only seems to have 6.10.1, anyonw know the easiest route to get 6.10.3 on os x?
12:22:09 <Cale> I'm using Ubuntu, but its support for Haskell is always way behind so I just get the binaries from GHC's website.
12:22:28 <Cale> http://www.haskell.org/ghc/download_ghc_6_10_3.html
12:23:11 <Cale> bombshelter13_: Get the installer pkg, probably
12:23:24 <bombshelter13_> hm, must have not seen that. trying to recall why i'd have installed a ports version in the first place if there was an official binary, heh.
12:23:53 <duaneb> I just build from source
12:23:56 <duaneb> it works best that way
12:24:09 * mjrosenb installs from portage
12:24:10 <Cale> I wouldn't recommend building from source.
12:24:11 <Berengal> Building from source takes forever
12:24:24 <duaneb> it works :)
12:24:25 <Cale> It takes forever, and requires you to have a binary already.
12:24:31 <Athas> Is compiling GHC really that slow?
12:24:32 <duaneb> yea, well
12:24:32 <duaneb> it works
12:24:43 <duaneb> It only takes an hour or so for me
12:24:45 <Cale> It works, but so must the binary you already have.
12:25:19 <duaneb> well, yea
12:25:22 <duaneb> but the upgrade!
12:25:22 <voker57__> can one build ghc without ghc?
12:25:30 * Cale holds duaneb personally responsible for the heat death of the universe.
12:25:36 <duaneb> voker57__: not from haskell source, but one can compile haskell to c
12:25:43 <Cale> voker57__: Only with a lot of effort.
12:25:55 <duaneb> which can then be compiled with gcc IF the c source files were generated for that platform
12:26:03 <duaneb> so: not easily :)
12:26:04 <Cale> duaneb: Er, ghc doesn't really do that though, does it?
12:26:07 <qaz> > ((1:) *** (2:)) $ [1,2,3]
12:26:08 <lambdabot>   Couldn't match expected type `([t], [t1])'
12:26:09 <Berengal> Don't you need to bootstrap 6.2 or something like that to get a ghc from just source?
12:26:16 <duaneb> Cale: it does for bootstrap
12:26:20 <qaz> > (1:) *** (2:) $ [1,2,3]
12:26:21 <lambdabot>   Couldn't match expected type `([t], [t1])'
12:26:25 <Cale> Perhaps they have that working again.
12:26:32 <qaz> > (1:) *** (2:) $ 1
12:26:33 <lambdabot>       No instance for (Num ([t], [t1]))
12:26:33 <lambdabot>        arising from the literal `1' a...
12:26:36 <qaz> > (1:) *** (2:) $ [[1]]
12:26:37 <lambdabot>   Couldn't match expected type `([t], [t1])'
12:26:38 <voker57__> Cale: involving tracing back to ghc written not in haskell?
12:27:03 <qaz> > (1+) *** (2+) $ [1,2,3]
12:27:04 <lambdabot>   Couldn't match expected type `(t, t1)' against inferred type `[a]'
12:27:07 <qaz> > (1+) *** (2+) $ 1
12:27:08 <lambdabot>       No instance for (Num (t, t1))
12:27:08 <lambdabot>        arising from the literal `1' at <i...
12:27:11 <Cale> voker57__: There's a shorter path...
12:27:23 * Cale finds the instructions
12:27:23 <qaz> > (1+) *** (2+) $ [[1]]
12:27:24 <lambdabot>   Couldn't match expected type `(t, t1)' against inferred type `[a]'
12:27:27 <qaz> > (1+) *** (2+) $ [1]
12:27:27 <lambdabot>   Couldn't match expected type `(t, t1)' against inferred type `[a]'
12:27:37 <duaneb> Cale: I was under the impression that ghc had to cross-compile its own haskell files to C files for a foreign platform
12:27:43 <Athas> Is GHC the only Haskell implementation that can compile GHC?
12:28:19 <Cale> duaneb: But the normal method of compilation via C doesn't produce executable C.
12:28:19 <centrinia> Athas, not for all versions of GHC. ;)
12:28:31 <duaneb> Cale: that's right
12:28:35 <duaneb> there's some wonky thing...
12:28:41 <Athas> centrinia: well, current versions then.
12:28:50 <Cale> duaneb: It produces C code which gcc is meant to compile, and then the assembly output is mangled into something valid.
12:28:59 <duaneb> ahah, we are both correct
12:28:59 <duaneb> Bootstrapping GHC on a system without GHC already installed is achieved by taking the intermediate C files (known as HC files) from another GHC compilation, compiling them using gcc to get a working GHC.
12:29:02 <bombshelter13_> Ahh, that's why I probably installed the ports version instead of the binary -- requires xcode to be installed, and i'd installed ghc way before i started using xcode...
12:29:08 <duaneb> NOTE: Versions supported: between 6.0.1 and 6.6.2. We are working on getting bootstrapping working again in the 6.8 series, see #1346.
12:29:21 <Cale> duaneb: hehe, yeah, that's pretty far back
12:29:22 <kacper_> ?src drop
12:29:22 <lambdabot> drop n xs     | n <= 0 =  xs
12:29:22 <lambdabot> drop _ []              =  []
12:29:22 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
12:29:41 <Athas> That sounds hilariously complicated.
12:29:57 <mm_freak> is there an easy way to have multiple records with the same field name without needing multiple modules?  like qualified record field names?
12:30:04 <Cale> 6.0.1 is close to the time I started programming in Haskell. I think I used one version from the 5.x series.
12:30:27 <augustss> mm_freak: no
12:30:46 <mm_freak> is there a way to write multiple modules in a single source file?
12:30:55 <Cale> mm_freak: Theoretically, but no.
12:31:09 <mm_freak> that's annoying
12:31:23 <Cale> mm_freak: I just name my record field names disjointly.
12:31:36 <Gracenotes> mm_freak: you can try a function that pattern matches on various constructors and returns the appropriate attribute
12:31:41 <Cale> Usually by adding a little prefix or suffix.
12:31:52 <Gracenotes> in each case
12:31:53 <centrinia> Does the Prelude contain a function f :: Int -> (a -> a) -> (a -> a); f 0 _ = id; f n g = f (n-1) g . g ?
12:32:05 <Cale> centrinia: The closest thing is iterate
12:32:07 <Gracenotes> centrinia: no
12:32:09 <mm_freak> hmm yeah, seems to be the only solution
12:32:17 <Cale> > iterate (+1) 0 !! 20
12:32:18 <lambdabot>   20
12:32:27 <mm_freak> Gracenotes: i have a record, which is only a single constructor
12:33:04 <augustss> mm_freak: There's an extension that might do what you need
12:33:34 <Gracenotes> centrinia: there's also this
12:33:37 <Gracenotes> > foldr (.) id (replicate 10 (+1)) 0
12:33:39 <lambdabot>   10
12:33:50 <Gracenotes> > foldr (.) id (replicate 10 (*2)) 1
12:33:51 <lambdabot>   1024
12:34:06 <augustss> mm_freak: -XDisambiguateRecordFields
12:34:12 <Cale> mm_freak: It's important to notice that the record field names are not just record field names, but also automatically the names of functions which need to be well-typed.
12:34:13 <centrinia> :t \n g -> foldr (.) id (replicate n g)
12:34:14 <lambdabot> forall a. Int -> (a -> a) -> a -> a
12:34:26 <obk> I have a tree structure (data Node = ...) and a mapTree :: (Node -> Node) -> Node -> Node that applies a function to all the nodes (bottom up). I now need mapTreeM :: (Node -> M Node) -> Node -> M Node. Is there a way to avoid duplicating the original (long!) mapTree implementation with "M" everywhere?
12:34:49 <centrinia> :t \n g -> (!!n) . iterate g
12:34:50 <lambdabot> forall a. Int -> (a -> a) -> a -> a
12:34:57 <kacper_> so my question after write http://en.wikibooks.org/wiki/Haskell/Denotational_semantics is take 3 [1..] works and drop 3 [1..] doesn't work because after 3 times pattern-matching it evalueate to drop 0 _|_ and from def. it gives _|_ ?
12:34:58 <Cale> obk: No, because mapTreeM actually has more information in it than mapTree
12:35:15 <Cale> obk: (it contains information about execution order which the pure version can't)
12:35:19 <vixey> > drop 0 undefined
12:35:20 <lambdabot>   * Exception: Prelude.undefined
12:35:23 <augustss> obk: write just mapTreeM and use that to implement mapTree (with the identity monad)
12:35:35 <shachaf> @src mapM
12:35:35 <lambdabot> mapM f as = sequence (map f as)
12:35:37 <Cale> Right, what augustss said :)
12:35:45 <centrinia> > (\n g -> (!!n) . iterate g) 10 [0..]
12:35:45 <shachaf> You could use an equivalent of sequence for your tree, perhaps?
12:35:45 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
12:35:53 <centrinia> > (\n g -> (!!n) . iterate g) 10 tail [0..]
12:35:54 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
12:35:56 <obk> augustss, Cale: That's what I figured by shachaf said it is a horrible practice :-)
12:36:08 <mm_freak> augustss: i'll have a look at it, thanks
12:36:18 * shachaf didn't say that!
12:36:19 <Athas> What's the state/future of dynamic libraries in GHC?
12:36:27 <mm_freak> Cale: yeah, sure…  but that's a piece of OOP i'm missing in haskell
12:36:51 <obk> I expect using mapTreeM with the identity monad would not hurt performance _too_ much...
12:37:03 <Cale> kacper_: hmm?
12:37:21 <centrinia> Is (take 2) a catamorphism?
12:37:24 <augustss> obk: don't worry about performance until you have to
12:37:34 <Heffalump> centrinia: no
12:37:40 <Cale> obk: But you might hang on to your current version just in case.
12:37:56 <Gracenotes> grep -R 'optimized away' haskell_logs | wc -l
12:37:58 <Gracenotes> >_>
12:37:59 <obk> augustss: Actually the reason I am doing this is performance; the monadic version will be used to memoize the computations
12:38:04 <centrinia> But (drop 2) is a catamorphism.
12:38:09 <Gracenotes> I expect lots of results
12:38:12 <obk> But I see your point. It should be better this way.
12:38:14 <vixey> drop 2 isn't a catamorphism
12:38:26 <Cale> kacper_: take 3 [1..] and drop 3 [1..] are both completely defined values
12:38:35 <Cale> > drop 3 [1..]
12:38:36 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
12:38:42 <Cale> > take 3 [1..]
12:38:43 <lambdabot>   [1,2,3]
12:39:08 <Heffalump> centrinia: how?
12:39:12 <Heffalump> I don't think it is
12:39:36 <centrinia> drop 2 = foldr (.) id (replicate 2 tail)
12:39:55 <mm_freak> the documentation says that the STM function 'orElse' is GHC only?!
12:39:58 <Athas> Actually, about performance... are there any papers, articles or tutorials about how to optimise Haskell?  I have a pretty good intuitive understanding of how to achieve fast code in Lisp, but I'm under the impression that GHC does much more intensive rewriting and requires less intuitive considerations.
12:40:02 <Gracenotes> centrinia: eh. That would mean lots of stack space for large values...
12:40:12 <mm_freak> is that true?  is there another way to compose STM actions?  Applicative?
12:40:13 <Gracenotes> it'd work at least
12:40:25 <Cale> mm_freak: STM is GHC-only.
12:40:30 <mm_freak> oh, ok
12:40:48 * centrinia compiles ghc-6.10.3
12:41:01 <Cale> (at least there are no other current implementations of Haskell with it)
12:41:09 <mm_freak> hmm, STM is not an Alternative instance anyway (for whatever reason)
12:41:33 <Cale> Athas: There was a guide on the wiki which looked like it might be good, but which I haven't actually read...
12:41:52 <Gracenotes> lots of things that can be alternatives aren't :/
12:41:53 <centrinia> Hmm, is there a special name for the composition of an anamorphism with a catamorphism?
12:41:56 <Cale> http://www.haskell.org/haskellwiki/Performance
12:42:10 <Gracenotes> hm. surely all MonadPlus instances are also Alternatives?
12:42:18 <Athas> Cale: thanks.
12:42:19 <dolio> hylomorphism
12:42:33 <kacper_> ?src take
12:42:33 <lambdabot> take n _      | n <= 0 =  []
12:42:33 <lambdabot> take _ []              =  []
12:42:33 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:42:42 <dolio> Or metamorphism, I think, depending on what order you compose them in.
12:42:44 <centrinia> dolio, a hylomorphism is the composition of a catamorphism with an anamorphism.
12:42:55 <Gracenotes> > take 0 undefined
12:42:56 <lambdabot>   []
12:42:58 <centrinia> Thanks. Metamorphism should be what I'm looking for. :)
12:43:19 <centrinia> > take 0 $ take 0 undefined
12:43:20 <lambdabot>   []
12:43:28 <centrinia> > take 1 $ take 0 undefined
12:43:29 <lambdabot>   []
12:43:33 <Cale> It starts to get silly naming such things, I think. The nomenclature somehow isn't very compositional.
12:43:39 <Gracenotes> >:[]
12:43:56 <Berengal> Cale: Sort of ironic, isn't it?
12:44:17 <Gracenotes> ISN'T IT IRONIC
12:44:17 <centrinia> So there's no special name for the composition of a catamorphism with a metamorphism?
12:44:23 <Gracenotes> don't make me sing it
12:44:50 <Cale> We should start the convention of just concatenating the prefixes in the appropriate order.
12:44:57 <Berengal> @quote prepromorphism
12:44:57 <lambdabot> EvilTerran says: [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
12:45:21 <Gracenotes> catametamorphism
12:45:35 <Cale> I suppose 'ana' tends to be problematic...
12:45:42 <Cale> 'cataanamorphism'
12:45:53 <Berengal> katana morphism?
12:45:57 <malouin> So when trying to compile things in low memory situations where swap access is slow, this might help?
12:46:01 <malouin> cabal install --ghc-options='-optl-Xlinker -optl--no-keep-memory'
12:46:15 <malouin> but it also might not.
12:46:15 <Cale> "Santa Ana morphism"?
12:47:49 <kacper_> can i prove by structural induction for e.g "map f ( xs ++ ys ) = map f xs ++ map f ys" but for infinite lists?
12:47:51 <Gracenotes> catametahylohypometametahypoanamorphism
12:48:27 <centrinia> Uh, what is a hypomorphism?
12:48:31 <obk> Is there "fromM :: (Monad m) => m a => a" ? A generalization of fromJust ?
12:49:01 <Cale> obk: That sort of type pains me ;)
12:49:09 <Gracenotes> doesn't exist
12:49:16 <Cale> obk: (I really dislike the use of Monad to express failure)
12:49:25 <centrinia> obk, Yes.
12:49:33 <Cale> oh, wait...
12:49:36 <obk> Really? What is it called?
12:49:37 <Gracenotes> obk: eek. fromJust is pretty unsafe to begin with
12:49:38 <Cale> err...
12:49:53 <Cale> actually, that's not even what I thought it was
12:49:56 <centrinia> :t unsafePerformIO . unsafeCoerce
12:49:57 <lambdabot> Not in scope: `unsafePerformIO'
12:49:57 <lambdabot> Not in scope: `unsafeCoerce'
12:49:57 <bombshelter13_> Huh, interestingly, I've completed updating to 6.10.3 and am experiencing the same error.
12:49:58 * Cale should read more carefully
12:50:00 <Gracenotes> fromM goes against the point of monads -- to sequence things in composition
12:50:01 <obk> It makes sense in my case.. and it would cut down the rw-write effort by 90% :-)
12:50:04 <Cale> That simply does not exist.
12:50:15 <Cale> There is no polymorphic function (Monad m) => m a -> a
12:50:21 <Gracenotes> and there shouldn't be!
12:50:22 <Cale> (which isn't everywhere undefined)
12:50:26 <Gracenotes> >_>
12:50:39 <hatds> fromJust is not that bad though :)
12:50:41 <dolio> Why not just tell him: undefined :: m a -> a? At least that won't cause flagrant segfaulting.
12:50:44 <Jedai> kacper_: Yes the fact that the lists can be infinite shouldn't have any import on the proof
12:50:59 <Cale> dolio: But it will get you the next best thing ;)
12:51:13 <kacper_> ?src map
12:51:13 <lambdabot> map _ []     = []
12:51:13 <lambdabot> map f (x:xs) = f x : map f xs
12:51:18 <obk> So if I have : mapNode f (Foo a b) = f $ Foo (mapNode f a) (mapNode f b), then mapNodeM _must_ use do notation. Oh well...
12:51:23 <dolio> Yeah. It's still better than unsafePerformIO . unsafeCoerce.
12:52:27 <hatds> but you only write your mapM's and what not once for each data structure
12:53:39 <Jedai> obk: Look at traversable for a generalisation of mapM
12:54:05 <kacper_> can i prove by structural induction for e.g "map f ( xs ++ ys ) = map f xs ++ map f ys" but for infinite lists?
12:54:07 <Jedai> obk: You'll get instance for many of the usual types, and you should write an instance yourself
12:54:21 <obk> Jedai: Will look. Thanks!
12:54:37 <centrinia> obk, There is a coreturn :: (Comonad m) => m a -> a
12:54:38 <Jedai> kacper_: I already answered that... Yes, and the proof isn't different from the usual
12:55:30 <roconnor> @hoogle point
12:55:30 <lambdabot> package pointfree
12:55:30 <lambdabot> package fixpoint
12:56:14 <kacper_> but In my exercise is written prove it for infinite lists or mark when it's correct only for finite lists
12:56:40 <Jedai> kacper_: And ?
12:56:48 <kacper_> for e.g reverse $ reverse [1..] fails
12:57:03 <kacper_> for infinite but for finite is good
12:57:21 <obk> Jedai: Traversable seems exactly what I need. Thanks!
12:57:58 <kacper_> should i prove that reverse $ reverse = id ?
12:58:23 <Jedai> kacper_:  That would be "reverse . reverse", not "reverse $ reverse"
12:59:08 <kacper_> reverse . reverse [1..10] fails
12:59:20 <NEEDMOAR> reverse . reverse $ [1..10]
12:59:27 <roconnor> (reverse . reverse) [1..10]
12:59:33 <Jedai> kacper_: And since reverse doesn't start producing a result before it gets to the end of the list, it's obvious that "reverse . reverse" == "id" is only true for finite lists...
12:59:46 <wabash> Hey, ppl. Exciting, the haskell channel has more and more peopel everytime I come back!
12:59:46 <NEEDMOAR> @type reverse $ reverse
12:59:47 <lambdabot>     Couldn't match expected type `[a]'
12:59:47 <lambdabot>            against inferred type `[a1] -> [a1]'
12:59:47 <lambdabot>     In the second argument of `($)', namely `reverse'
12:59:53 <NEEDMOAR> @type reverse . reverse
12:59:54 <lambdabot> forall a. [a] -> [a]
12:59:58 <wabash> I have some general questions....
13:00:09 <wabash> What happens in Haskell if you have overflow of float math?
13:00:12 <wabash> or underflow?
13:00:46 <Jedai> kacper_:  whereas map is good producer
13:01:13 <roconnor> > 10**(10**10) :: Double
13:01:14 <lambdabot>   Infinity
13:01:19 <Gracenotes> wabash: Float and Double follow IEEE
13:01:27 <roconnor> > 10**(-(10**10)) :: Double
13:01:28 <lambdabot>   0.0
13:01:36 <wabash> Gracenotes: THanks.
13:01:36 <roconnor> > isIEEE $ 10**(-(10**10)) :: Double
13:01:37 <lambdabot>   Couldn't match expected type `Double' against inferred type `Bool'
13:01:43 <roconnor> > isIEEE (10**(-(10**10)) :: Double)
13:01:44 <lambdabot>   True
13:01:50 <wabash> But I'm confused. When there is over/under flow, how will you know?
13:02:08 <Gracenotes> > isNaN (0/0)
13:02:09 <lambdabot>   True
13:02:15 <Gracenotes> > isInfinite (1/0)
13:02:16 <lambdabot>   True
13:03:57 <mm_freak> any problems with mixing normal primitives like MVar with STM in concurrent code?
13:04:44 <wabash> Gracenotes: Is there an exception of some sort that is raised?
13:05:03 <Gracenotes> it's IEEE floating point. no exceptions are raised.
13:05:10 <Gracenotes> as in any other proper implementation
13:05:26 <Gracenotes> > 1 `div` 0 -- although, this, but those are integers
13:05:26 <jbjohns> hi
13:05:27 <lambdabot>   * Exception: divide by zero
13:05:39 <jbjohns> intersect :: Ord a => [(a,a)] -> [(a,a)] -> [(a,a)]
13:05:41 <jbjohns> intersect [] _ = []
13:05:42 <jbjohns> intersect _ [] = []
13:05:44 <jbjohns> intersect x'@((a,b):x) y'@((c,d):y)
13:05:45 <jbjohns>   | b < c  = intersect x  y'
13:05:47 <jbjohns>   | d < a  = intersect x' y
13:05:48 <jbjohns>   | otherwise = case b `compare` d of
13:05:50 <jbjohns>     LT -> (max a c, b) : intersect x  y'
13:05:51 <jbjohns>     GT -> (max a c, d) : intersect x' y
13:05:53 <jbjohns>     EQ -> (max a c, b) : intersect x  y
13:05:54 <jbjohns> oops
13:05:56 <jbjohns> can anyone make that better? :)
13:07:02 <wabash> Gracenotes: Ok, so how does one write a robust program that catches errors?
13:07:27 <Gracenotes> uh, know where the errors occur?
13:08:54 <Gracenotes> and if you're using an exception-causing function, check the preconditions first or (if you absolutely must) use a Control.Exception function. However, these are I/O, and condition-checking is the best defense really
13:09:31 <wabash> Ok, so you have input, right? And it's a series of numbers. Some of them may be very small ,some very large. Say matrix computations and multiplications. You have no predetermined restrictions on inputs. So if I have two ints, that are both 2^30 in size, and I multiply them, I need to know that they overflowed.
13:10:04 <copumpkin> cast them to a larger type, multiply them there
13:10:17 <copumpkin> and check if it's greater than the max of the smaller one
13:10:17 <Gracenotes> hm. might not be good for performance though >_>
13:10:59 <copumpkin> on x86, multiplying two 32-bit ints automatically gives you a 64-bit int anyway
13:11:00 <Cale> jbjohns: hmm, the (a,a) pairs are like intervals?
13:11:12 <DBAlex> hey
13:11:14 <jbjohns> dates actually
13:11:20 <Cale> wabash: Use Integer.
13:11:32 <Cale> > 2^30 * 2^30
13:11:33 <lambdabot>   1152921504606846976
13:11:40 <wabash> Cale: Is there a huge penalty for using this type?
13:11:47 <Cale> wabash: Not really.
13:11:49 <jbjohns> they start out being some period apart, e.g. a year and the above algo finds the overlap
13:11:51 <wabash> I see.
13:11:59 <wabash> Cale, that answers my question.
13:12:02 <Cale> wabash: Well, it's as small as can be expected anyway
13:12:08 <DBAlex> I just found a sort of haskell anamoly, I know last [1..999999999999999] is slow because it has to construct the last due to running last first but it would be a nice optimization to just use the last value after the .. and not evaluate anything before it
13:12:38 <DBAlex> right?
13:12:47 <dolio> There's the checked library on hackage, too.
13:12:49 <wabash> Now, in native C and C++, there is no way to do it with ints or doubles or floats. But processors have detection flags, and the processor itself finds out in hardware. So how is it done in C++ or C?
13:13:11 <DBAlex> > last [1..99999999999999999999]
13:13:26 <lambdabot>   thread killed
13:13:33 <DBAlex> heh :)
13:14:04 <DBAlex> *construct the list
13:14:21 <Cale> DBAlex: You could add a rewrite rule to GHC, but generally the way that lists work, it's not possible to get the last element quickly.
13:14:43 <DBAlex> Cale: ok, but do you see my point
13:14:47 <BMeph> wabash: The traditional C detection mechanism is: "Segmentation fault (core dumped)." ;p
13:14:56 <qaz> hmm, the only reason to use Erlang over Haskell seems to be OTP, if you have problem that have to do with lagre-scale distirbuted stuff. otherwise use Haskell.
13:15:00 <DBAlex> I suppose it can't have a special case for last
13:15:05 <dolio> The rewrite rule would be pointless, because no one ever writes "last [1..9999999999999999999]" in their code.
13:15:11 <DBAlex> its just a silly optimization :)
13:15:12 <Cale> DBAlex: If you need fast access to the end of a list, you shouldn't be using lists.
13:15:16 <qaz> but Haskell could be used easily for dsitributed stuff too?
13:15:22 <qaz> how is the actor package on Hackage?
13:15:28 <DBAlex> dolio: heh, true :D
13:15:35 <Cale> DBAlex: It can actually, you can add one with a pragma.
13:15:48 <DBAlex> ok
13:16:53 <Cale> DBAlex: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#rules
13:17:03 <Cale> er, no
13:17:03 <DBAlex> ok
13:17:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
13:17:05 <DBAlex> cheers
13:17:06 <DBAlex> brb :D
13:17:09 <jbjohns> qaz: Erlang has some other interesting features like.... ugh, what's that prolog term where the variables are all tried until they fit the pattern?  unification?
13:18:06 <jbjohns> it's not as thorough as Prolog's of course, but it can do some interesting things, including once a variable is set it can then be used as a pattern as though it were a constant or whatever
13:18:22 <Cale> {-# RULES "last/enumFromTo" forall x y. last (enumFromTo x y) = y #-}
13:18:43 <jbjohns> last [1..9999999999999999999999999999]
13:18:55 <jbjohns> hrm, I guess it didn't take effect
13:19:04 <Cale> oh, it doesn't apply to the bot
13:19:10 <Cale> and not without optimisations anyway
13:19:17 <jbjohns> ah and I didn't send it to the bot anyway *bonk self*
13:20:24 <Cale> It works in a compiled program I just wrote
13:20:33 <Cale> {-# RULES "last/enumFromTo" forall x y. last (enumFromTo x y) = y #-}
13:20:33 <Cale> main = print (last [1..9999999999999999999])
13:25:13 <obk> Turns out Traversable will not work for me because it only works for things like "Tree a" and mine is just a simple "Tree" :-(
13:26:28 <copumpkin> is that always true?
13:26:35 <copumpkin> > [0.5 .. 1.5]
13:26:37 <lambdabot>   [0.5,1.5]
13:26:42 <copumpkin> > [0.5 .. 1.4]
13:26:44 <lambdabot>   [0.5,1.5]
13:28:14 <dolio> Yes, well, the floating point Enum instances are evil.
13:30:16 <Cale> copumpkin: Right, it's not always true.
13:31:24 <BMeph> It just *ought* to be. :)
13:33:18 <skorpan> @src intercalate
13:33:19 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:50:39 <Cale> BMeph: I can imagine that failing that property is okay. I just don't think that [x..y] should ever contain elements strictly larger than y
13:50:56 <Cale> (or less than x)
13:51:15 <duaneb> anyone here on OS X?
13:51:56 * obk just pasted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4966#a4966 to demonstrate the problem.
13:52:10 <copumpkin> duaneb: I am
13:52:17 <duaneb> what editor do you use?
13:52:30 <duaneb> I WAS using textmate, but its haskell support is limited
13:52:31 <copumpkin> textmate usually
13:52:36 <duaneb> heh
13:52:50 <copumpkin> what do you need it to do?
13:54:16 <duaneb> umm
13:54:22 <duaneb> highlight the syntax regularly? :P
13:54:59 <duaneb> for example, paste this into TM: (.+.) :: v -> v -> v -- component add
13:55:08 <copumpkin> fix the bundle then :P I don't care that much about it
13:55:09 <BMeph> Cale: Oh, you mean how [0.5..2] can have 2.5 in it? :P
13:55:18 <BMeph> > [0.5]..2]
13:55:18 <lambdabot>   <no location info>: parse error on input `..'
13:55:22 <BMeph> > [0.5..2]
13:55:23 <lambdabot>   [0.5,1.5,2.5]
13:55:35 <Cale> BMeph: right
13:55:44 <Cale> BMeph: In my opinion, it should stop at 1.5
13:56:03 <Raevel> wierd!
13:56:28 <skorpan> wired!
13:56:50 <Gracenotes> well, floor 2.5 is still 2. eh.
13:57:01 <BMeph> > [0.5..2.2]
13:57:02 <lambdabot>   [0.5,1.5,2.5]
13:57:15 <BMeph> 'nuff said.
13:57:37 <Gracenotes> well. floor 2.2 is still floor 2.5.. ... . .. . ......
13:57:49 <glguy> > map floor [0.5,1.5..]
13:57:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:58:02 <glguy> > map round [0.5,1.5..]
13:58:03 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28...
13:58:12 <Gracenotes> what the hell? 15 minutes of credits?
13:59:29 <hatds> the heck, why are Floats in Enum?
13:59:43 <shachaf> Would it be possible to make obk's example work with Data.Tree? Select and Max look like they might be troublesome...
13:59:45 <roconnor> hatds: it's stupid!!
13:59:55 <hatds> roconnor: yea
14:00:12 <roconnor> I at some point thought that Enum should be broken into two classes.
14:01:02 <inimino> IEEE floats are enumerable
14:01:14 <roconnor> but enum doesn't enumerate them.
14:01:37 <hatds> yea, you should be able to reach any Enum value by starting at an arbitrary value and using succ or pred
14:01:55 <copumpkin> I made something that did that a while ago
14:01:57 <dolio> > (last [2^31 - 2 .. 2^31] :: Int, 2^31)
14:01:58 <lambdabot>   (2147483648,2147483648)
14:02:02 <inimino> what does it do with them?
14:02:08 <inimino> you should be able to do that with floats
14:02:11 <hatds> it adds 1!
14:02:19 <inimino> oh.
14:02:22 <dolio> > (last [2^63 - 2 .. 2^63] :: Int, 2^63)
14:02:23 <lambdabot>   (* Exception: Prelude.last: empty list
14:02:29 <roconnor> enumeration Float is dumb anyways
14:02:32 <roconnor> enumerating
14:03:06 <opqdonut> i'd like to see a proper Enum instance
14:03:10 <hatds> I only sorta makes sense if you think of Floats as a finite set, by the instance doesn't even reflect that
14:03:13 <opqdonut> that gives the next float
14:03:14 <hatds> *I=it
14:03:32 <vixey> @src Enum
14:03:32 <lambdabot> class  Enum a   where
14:03:32 <lambdabot>     succ                     :: a -> a
14:03:32 <lambdabot>     pred                     :: a -> a
14:03:32 <lambdabot>     toEnum                   :: Int -> a
14:03:32 <lambdabot>     fromEnum                 :: a -> Int
14:03:34 <lambdabot> [3 @more lines]
14:03:38 <vixey> I don't see a problem
14:03:44 <copumpkin> the Int is a pain
14:03:50 <copumpkin> and the instance for Float/Double is a pain
14:04:13 <hatds> I think of Enum as being a witness for being finite or countable
14:05:24 <hatds> (cause they're called, you know, *Enum*)
14:05:39 <copumpkin> infinite things can be enumerable
14:05:55 <hatds> by countable I mean coutably infinite
14:06:04 <copumpkin> see, but the Int prevents that
14:06:09 <hatds> but it's finite
14:06:16 <hatds> "finite or countable" ish
14:06:59 <Phyx-> Hi, quick question what option do i need to enable to allow the syntax "data Test :: * -> *  where" ? i have GADTs enabled but ghc still complaints
14:07:15 <vixey> try KindSignatures
14:07:48 <Phyx-> that seems to work, thanks vixey
14:08:22 <Phyx-> i was reading http://en.wikibooks.org/wiki/Haskell/GADT, it shows the syntax just not what to use to enable it. or i missed it
14:09:02 <opqdonut> {-# LANGUAGE GADTs #-}
14:09:06 <opqdonut> in the source file
14:09:18 <MyCatVerbs> Above the module line.
14:09:34 <opqdonut> you might need an other extension for the kind signature
14:09:44 <Phyx-> opqdonut: i already had that, but without KindSignature it wouldn't take it
14:09:47 <duaneb> is there a list of all the pragmas somewhere? :P
14:10:05 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
14:10:14 <thoughtpolice> duaneb: ghc --supported-languages
14:10:21 <thoughtpolice> hi copumpkin!
14:10:29 <copumpkin> ohai2u
14:10:46 <copumpkin> :P
14:12:05 * Phyx- wonders why he always ends up having so many language extensions enabled
14:12:16 <skorpan> because haskell sucks
14:12:19 <copumpkin> because we need a new standard that enables them by default
14:12:28 <SubStack> skorpan: it's true
14:12:39 <hatds> I don't think it is much of a hassle
14:12:46 * copumpkin coughs: http://haskell.org/haskellwiki/?title=UnnamedStandard
14:13:01 <Phyx-> lol
14:13:03 <SubStack> it however sucks less than the alternatives
14:13:14 <skorpan> indeed
14:13:27 <sjanssen> copumpkin: that page doesn't seem useful
14:14:01 <hatds> needs to be a named instances proposal in there
14:14:02 <Phyx-> "concat means the same thing as join. We propose we don't use concat at all" <-- while i agree... doing so would require you to immediately teach someone monads no?
14:14:05 <sjanssen> I don't think Haskell '98 has any monoid classes?
14:14:09 <copumpkin> sjanssen: it wasn't meant to be, it was meant as a first step to give people somewhere to put down ideas (because I've seen people complain about h98 hundreds of times in the few months since I've been here)
14:14:27 * sjanssen loves Haskell '98
14:14:34 * sjanssen also thinks a few bits of it are dumb
14:14:40 <MyCatVerbs> Phyx-: not quite, mostly it just means you need to immediately teach someone type constructors.
14:15:03 <hatds> there's nothing wrong with having both concat and join, imho
14:15:06 <roconnor> sjanssen: ya, like gcd 0 0
14:15:11 * roconnor still isn't over it.
14:15:15 <copumpkin> there are just lots of small silly things
14:15:20 <Phyx-> hatds: agreed
14:15:24 <copumpkin> that could be fixed easily
14:15:47 <copumpkin>  but you'd need to get enough people interested first
14:15:54 <sjanssen> this page (and hatds and roconnor) illustrates the problem with just making a wiki page: it becomes a place to whine about your favorite issues
14:15:56 <qaz> vixey: what's your interest in Erlang?
14:16:01 <sjanssen> roconnor: nobody cares about gcd 0 0
14:16:20 <hatds> I do :)
14:16:26 <vixey> roconnor cares about gcd 0 0 and he convinced me it should be 0
14:16:26 <sjanssen> nobody really cares about MonadPlus v. Monoid
14:16:38 * roconnor is a nobody
14:16:39 <Phyx-> MyCatVerbs: but that would be something i could see that you'd want to postpone
14:16:46 <copumpkin> sjanssen: no, my point was to create the page so the whining could go to a certain place, so we could stop getting it every few days on IRC and keep track of what really bothers people
14:16:53 <copumpkin> I guess I'm a nobody too
14:17:04 <hatds> I'm kinda ambivalent about using Monoid everywhere for every binary op
14:17:07 <roconnor> sjanssen: actually I think the monadplus v monoid is moderately serious.
14:17:36 <copumpkin> I guess monoid isn't in the report itself
14:17:41 <copumpkin> but still
14:17:42 <sjanssen> I think the different uses for each are very clear
14:18:05 <copumpkin> but is there a good reason to keep them separate, other than the fact that it's always been that way?
14:18:06 <duaneb> what's a monoid?
14:18:19 <glguy> what isn't :P)
14:18:23 <sjanssen> copumpkin: look at the Maybe instances for each class
14:18:29 <copumpkin> I mean, we also have alternatives
14:18:33 <copumpkin> Alternative, that is
14:18:36 <sjanssen> copumpkin: they're both useful, and should both be named
14:18:39 <hatds> duneb: just a binary operation with identity
14:18:53 <sjanssen> copumpkin: Alternative/MonadPlus is the real redundancy
14:19:01 <copumpkin> sjanssen: so we do what we did with Sum and Product?
14:19:24 <rickasauruss> Im curious about this idea of arrows as opposed to monad.
14:19:31 <copumpkin> I don't see why the entire class should be duplicated because more than one possible instance exists
14:19:42 <copumpkin> oh, and ArrowPlus :P
14:19:44 <sjanssen> copumpkin: they have different kinds
14:19:53 <sjanssen> this is fundamental
14:19:58 <rickasauruss> so what is an arrow?
14:20:01 <copumpkin> true
14:20:14 <copumpkin> it still feels rather dirty to me though
14:20:21 <sjanssen> MonadPlus doesn't care about the what's contained, it should be a "shallow" combination of two values
14:20:22 <copumpkin> Monoid, Monoid1 :P
14:20:42 <sjanssen> Monoid can care about what is contained, it should be a "deep" combination of values
14:20:48 <sjanssen> Maybe is a great example of this
14:21:18 <hatds> but what about alternative vs plus?
14:21:22 <mm_freak> is there some kind of a RS monad?  i.e. RWS without W?
14:21:36 <glguy> sure, stack statet on readert
14:21:41 <sjanssen> hatds: there's a redundancy there, one of them should go away
14:21:49 <mm_freak> hmm, that's ugly
14:22:00 <glguy> mm_freak, RWS is an abomination
14:22:03 <sjanssen> no, RWS is ugly
14:22:08 <tomh> mm is there a way to catch an exception thrown by "read" ?
14:22:23 <mm_freak> hmm
14:22:28 <glguy> tomh, yeah, but it is a bad idea, if you want it to throw IO exceptions, use readIO
14:22:33 <sjanssen> tomh: the better thing to do is to inspect the value of 'reads' instead
14:22:35 <glguy> if you want to catch it purely, use reads
14:22:35 <copumpkin> sjanssen: anyway, the monoids thing was one example, but there is a fair amount of redundancy in the current stdlib, as well as extraneous methods in many classes that make reasonable instances painful, and most people seem to agree on that...
14:22:40 <mm_freak> ok, thanks
14:22:56 <sjanssen> tomh: case reads foo of [(x, "")] -> success!; _ -> o noes!
14:23:07 <tomh> mm
14:23:13 <tomh> @src reads
14:23:13 <lambdabot> reads = readsPrec minPrec
14:23:14 <glguy> async exceptions are a last resort hack
14:23:20 <copumpkin> also, ArrowPlus/ArrowZero seem to be pretty similar to MonadPlus/Alternative, too
14:23:22 <tomh> :type reads
14:23:22 <hatds> copumpkin: which instances for example?
14:23:30 <tomh> :t reads
14:23:31 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:23:35 <hatds> copumpkin: about being burdensome to create
14:23:58 <copumpkin> hatds: the obvious examples are Num
14:24:09 <sjanssen> copumpkin: I'm ignorant of Arrow, but again I think it's about the kinds
14:24:14 <hatds> @src Num
14:24:14 <lambdabot> class  (Eq a, Show a) => Num a  where
14:24:14 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:24:14 <lambdabot>     negate, abs, signum     :: a -> a
14:24:14 <lambdabot>     fromInteger             :: Integer -> a
14:24:18 <hatds> heh
14:24:57 <copumpkin> :k ArrowPlus
14:24:58 <lambdabot> Class `ArrowPlus' used as a type
14:24:59 <sjanssen> copumpkin: also, Haskell doesn't have type language for the constraint "Monad m, Monoid (forall a. m a)"
14:25:13 <copumpkin> yeah, I know
14:25:19 <hatds> do any of the standard classes that have Num as a superclass actually *use* signum or abs?
14:25:44 <copumpkin> I'll agree that we'd need at least two or three different Monoids for different kind "arities"
14:25:53 <copumpkin> in that case I still think they should be named consistently though
14:26:27 <sjanssen> copumpkin: anyway, I'm not too hopeful of radical changes like this, since even the conservative Haskell' process doesn't seem to do anything
14:27:00 <copumpkin> well, I'd really just like to see the other prelude moved in as a replacement
14:27:03 <hatds> it's tempting to try to figure out how it should be even if nothing will happen :/
14:27:11 <copumpkin> the numerical typeclasses are what bugs me the most
14:27:19 <vixey> sjanssen: shouldn't that be  forall a. Monoid (m a)?
14:27:19 <vixey> a
14:27:42 <copumpkin> that one is possible to write isn't it?
14:27:43 <roconnor> we need a set of darcs patches, not a wiki.
14:27:51 <hatds> the type family paper gives an example of having implicit conversion for things like (+)
14:28:41 <copumpkin> roconnor: well, I guess I'm not arrogant enough after a few months of haskelling to start writing my own standard library, but I have picked up that people find there are shortcomings, and wanted there to be a place to discuss it
14:28:44 <zachk> i sort of enjoy the pain of mixing different "?members?" of the Num class
14:28:54 <sjanssen> vixey: in English, "given Monad m, (m a) is a Monoid for all a"
14:28:55 <roconnor> copumpkin: few months?
14:29:02 <roconnor> copumpkin: haven't you been here for years?
14:29:06 <copumpkin> lol
14:29:11 <copumpkin> should I take that as a compliment?
14:29:22 <vixey> sjanssen: so forall a. Monoid (m a)
14:29:32 <opqdonut> you might take it as a complement
14:29:38 <opqdonut> being copumpkin and all
14:29:41 <sjanssen> vixey: where is m bound?
14:29:42 <copumpkin> har har :)
14:30:26 <sjanssen> vixey: anyway, Haskell can't express this
14:30:58 <copumpkin> roconnor: I started learning last december, after glancing over my girlfriend's shoulder for a month or two before that (she was taking a course in it)
14:30:59 <hatds> instance Monad m => Monoid (m a)?
14:31:00 <vixey> I'm just saying shouldn't the forall be outside 'Monoid' not inside it
14:31:17 <glguy> most of these Prelude problems don't show up in big programs
14:31:17 <sjanssen> hatds: that outlaws any sort of useful instance
14:31:22 <copumpkin> hatds: not sure we'd want that in general
14:31:24 <glguy> its the small examples that suffer for them
14:31:34 <sjanssen> vixey: yeah, that probably does make more sense
14:31:51 <hatds> sjanssen: I'm confused as to what you were saying is different
14:32:03 <sjanssen> Monad m, forall a. Monoid (m a) -- more clear
14:32:21 <hatds> ah, only particular monads?
14:32:34 <sjanssen> hatds: we want to write separate tailor-made instances for particular Monads
14:32:51 <duaneb> what is wrong with cabal!?
14:32:58 <copumpkin> duaneb: you tell us!
14:32:59 <duaneb> it ignores my config
14:33:07 <duaneb> and after I install something
14:33:08 <copumpkin> duaneb: the config lines are commented out by default
14:33:17 <hatds> where would a simple "Monoid (m a) =>" context not be sufficient?
14:33:20 <duaneb> it says that it's not installed
14:33:20 <copumpkin> duaneb: did you remember to uncomment the line you changed?
14:33:24 <copumpkin> oh
14:33:49 <sjanssen> hatds: that context means (m a) is a Monoid, but doesn't say anything about (m b), (m c) or (m String)
14:33:53 <dcoutts> duaneb: are you mixing up "runghc Setup" with "cabal"
14:33:59 <duaneb> no, cabal
14:34:21 <dcoutts> duaneb: ok, does ghc-pkg list say the thing is installed? or are we talking about a program?
14:34:26 <duaneb> i.e. 'cabal install happy && cabal list happy' says 'Latest version installed: [ Not installed ]'
14:34:40 <dcoutts> duaneb: ah, it should say [ unknown ]
14:34:52 <dcoutts> it does not track programs, only libs
14:35:03 <dcoutts> because only the latter are registered with ghc
14:35:32 <sjanssen> hatds: whereas with "MonadPlus m =>" we can use mplus on any type applied to m
14:35:40 <duaneb> hmm
14:35:41 <duaneb> ok...
14:35:46 <hatds> I see
14:36:13 <duaneb> ahh
14:36:14 <duaneb> well
14:36:19 <duaneb> it also ignores my config
14:36:36 <dcoutts> duaneb: how so?
14:36:48 <duaneb> I have gmp installed in /opt/local/lib
14:36:57 <duaneb> and I have that set in my .cabal/config
14:37:01 <duaneb> and it STILL won't look there
14:37:34 <duaneb> extra-include-dirs: "/opt/local/include"
14:37:38 <duaneb> extra-lib-dirs: "/opt/local/lib"
14:38:02 <dcoutts> duaneb: is it a package with a ./configure script that fails? perhaps you should use hpaste.org to show us the log
14:38:25 <hatds> sjanssen: so they'd have to allow for passing instances, not just passing dictionaries
14:38:32 <duaneb> no, it's definitely cabal :P
14:38:37 <copumpkin> duaneb: so you uncommented the lines?
14:38:41 <duaneb> I mean, it's `cabal install happy`
14:38:42 <hatds> sjannsen: er, instance decls
14:38:45 <duaneb> copumpkin: yes :P
14:38:52 * glguy imagines a "really-a-flag" kind of cabal flag
14:39:02 <glguy> to compliment the "feel free to ignore this flag" kind
14:39:06 <glguy> to get both benefits
14:39:13 <copumpkin> :)
14:41:30 <roconnor> Heh, SPJ et. all's Type level GCD functions says that the GCD of Zero and Zero is Zero.
14:42:26 <copumpkin> good for them :P
14:42:44 <copumpkin> is it possible to write non-total type-level functions?
14:42:49 <copumpkin> partial, I guess
14:43:00 <roconnor> all type level functions are open?
14:43:23 <roconnor> so that means it would be  impossible to write a total type-level function, if I understand correctly
14:43:27 <thoughtpolice> yeah, type families are open
14:43:27 <vixey> I don't think. therefore I'm not.
14:43:35 <thoughtpolice> so it's possible to have nonsensical instances
14:43:37 <copumpkin> ah, that makes sense
14:43:55 <hatds> well, excluding type constructors ^_^
14:44:03 <vixey> I think that type familes are not 'partial' but they can get stuck
14:44:18 <roconnor> oh god, this type level equality has frightening power.
14:44:39 <vixey> roconnor: found something neat?
14:45:11 <roconnor> just reading the locking/unlocking example in SPJ et al.'s paper
14:45:18 <roconnor> well, skimming
14:45:21 <thoughtpolice> so, if you have something like 'Flip Even = Odd' and 'Flip Odd = Even', someone can come along and say 'Flip Char = Even', although that would break the invariant 'Flip (Flip x) = x' which is what you need
14:45:40 <roconnor> acquire :: (Get n p ~ Unlocked) =>
14:45:42 <roconnor> Lock n -> LockM p (Set n Locked p) ()
14:45:52 <copumpkin> thoughtpolice: so you'd need KindClasses? :P
14:45:59 <vixey> oh cool
14:46:08 <copumpkin> or I guess typeclass constraints, only
14:46:15 * duaneb has bang patterns all over the place
14:46:17 <vixey> I've not played with ~ actually only used it implicitly from GADT
14:46:24 <monadic_kid> if you're reading fun with fun types, check out boost mpl
14:46:29 <thoughtpolice> schrijvers, monnier, etc. describe type invariants, which as far as I can tell essentially give you a form of proofs for type functions
14:46:34 <roconnor> mpl?
14:46:42 <thoughtpolice> metaprogramming library
14:47:36 <thoughtpolice> also, type equality in superclass constraints is also useful from what I've seen, but AFAIK it's still not implemented in HEAD
14:47:47 <glguy> are type families still good for writing a->b type coersion functions in 6.10.3?
14:48:07 <thoughtpolice> compared to like 6.10.1? probably
14:48:30 <thoughtpolice> i don't remember seeing any patches that affect type families significantly going into the 6.10 branch
14:49:43 <monadic_kid> roconnor: it's even mentioned in the paper that it's very similar to type computations with templates
14:49:55 <thoughtpolice> roconnor: you'd probably like this - http://tomschrijvers.blogspot.com/2008/11/type-invariants-for-haskell.html
14:50:57 <burp_> how does cabal check for external c library existance? I'm especially interested in gsl check
14:51:14 <glguy> it checks for extenal library existance?
14:51:16 <dcoutts> burp_: it makes a c program and compiles it
14:51:50 <glguy> is that different than when it fails to find the include files at build time?
14:52:05 <dcoutts> glguy: it checks includes and libs at configure time
14:52:24 <burp_> it it possible to keep the file it creates to check the existance?
14:52:28 <glguy> cool, what version is that in
14:52:39 <monadic_kid> typedef find_if< vector<size_t, foo, bar>, is_pod<_1> >::type result_type;
14:52:45 <glguy> I always run into the problem when I have the library but not the -devel package
14:52:53 <dcoutts> burp_: sadly not, it's on our TODO, since especially the include checks are not fully accurate
14:52:54 <glguy> so ghc just fails at compile time
14:53:00 <burp_> dcoutts, thats my problem
14:53:22 <burp_> gsl check doesn't seem to work here for me
14:53:45 <dcoutts> burp_: so if you're sure the header files exist, then it's almost certainly due to the headers not being able to be included on their own, eg requiring other stuff included first.
14:54:12 <dcoutts> burp_: see the "includes:" lines in the .cabal file, make a trivial .c file that #includes them in that order, compile it with gcc and see how it fails
14:54:30 <burp_> good point, I'll try
14:54:31 <thoughtpolice> @seen ndm
14:54:31 <lambdabot> I haven't seen ndm.
14:54:36 <thoughtpolice> @seen ndmitchell
14:54:36 <lambdabot> I haven't seen ndmitchell.
14:54:37 <vininim> hilarity: changing from sparse to dense matrix in my octave program got ride of ``out of memory'' error.
14:55:10 <thoughtpolice> man i love types
14:55:43 <dcoutts> glguy: the check was added in Cabal-1.6.0.2 (which came with ghc-6.10.2)
14:56:32 <thoughtpolice> i needed derive to work on lhc, which doesn't work GHC head template haskell changes. after 30 minutes, x changes later, when it compiles, it works.
14:56:43 * thoughtpolice loves that feeling
14:56:54 <burp_> what would it include for gsl?
14:57:03 <ajdhs> Is anyone here familiar with QuickCheck?
14:57:06 <burp_> kind of #include "gsl.h".. ?
14:57:06 <glguy> dcoutts, is there a cabal upgrade --ignore-system-level-packages ?
14:57:37 <dcoutts> glguy: you mean, "stick with these versions of these core packages" ?
14:57:53 <glguy> dcoutts, yeah, since they seem to break otherwise
14:58:04 <dcoutts> glguy: you can use --constraint=
14:58:27 <dcoutts> and I think that can go in the cabal config file
14:59:07 <ajdhs> so I'm using quickcheck to test some properties on a rather complicated data structure
14:59:09 <dcoutts> glguy: I'd appreciate input on the best way to manage that, what the UI should be.
14:59:19 <ajdhs> specifically, it's a Data.Map.Map with lots of strings inside
14:59:24 <ajdhs> and lots of different values
14:59:32 <ajdhs> and long identifiers that can't be entered by hand
14:59:45 <dcoutts> glguy: once we've got the data, putting extra constraints into the solver is fairly straightforward
14:59:55 <ajdhs> so I'm wondering if there is a way to tell QuickCheck, when it encounters a failure, to give me the actual values that it failed on
15:00:00 <ajdhs> as opposed to just printing them out
15:04:15 <burp_> damn, I need that file to be kept
15:06:27 <burp_> at least it could show why compilation failed
15:06:43 <ajdhs> hm
15:06:45 <copumpkin> you can ask it to
15:06:50 <copumpkin> which file needs keeping?
15:06:56 <ajdhs> well, I see that QuickCheck gives me back a StdGen if a test fails
15:07:10 <ajdhs> but is there a way to turn the StdGen back into the values that QuickCheck tested?
15:07:39 <burp_> the temporary testfile which cabal created to test if the external c library works
15:08:00 <duaneb> ok, so I try to run this:
15:08:01 <duaneb> http://hpaste.org/save
15:08:04 <duaneb> whoops
15:08:04 <burp_> I'm trying to get hmatrix working with nix build system
15:08:09 <duaneb> this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4967#a4967
15:08:25 <duaneb> and it spits out this: Object.hs:26:32: Not in scope: `a'
15:08:26 <dcoutts> burp_: I don't follow, so the cabal configure succeeds?
15:08:31 <burp_> nope
15:08:46 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4967#a4969
15:09:07 <duaneb> is that where not included in the let?
15:10:02 <gnuvince_> How does one sort a list by multiple predicates?  For example, sorting strings from shortest to longest and in alphabetical order.
15:10:39 <vixey> gnuvince_: mappend
15:10:47 <Cale> gnuvince_: The monoid instances for Ordering and functions are useful
15:11:10 <gnuvince_> @index mappend
15:11:10 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
15:11:17 <Cale> > sortBy (comparing length `mappend` compare) (words "Here is a list of words to sort first by length and then alphabetically.")
15:11:18 <lambdabot>   ["a","by","is","of","to","and","Here","list","sort","then","first","words",...
15:11:44 <Zao> Where by alphabetically considers uppercase before lowercase?
15:11:49 <Cale> yeah
15:11:53 <Cale> It's just the usual order.
15:12:02 <gnuvince_> asciibetically if you will
15:12:03 <Cale> > sortBy (comparing length `mappend` comparing (map toLower)) (words "Here is a list of words to sort first by length and then alphabetically.")
15:12:04 <lambdabot>   ["a","by","is","of","to","and","Here","list","sort","then","first","words",...
15:12:17 <Cale> That would be more proper
15:12:22 <mrd> > 1+1
15:12:24 <lambdabot>   2
15:12:33 <duaneb> is there a reason why my let's variables would not extend to the later where?
15:12:36 <Cale> > sortBy (comparing length `mappend` comparing (map toLower)) (words "A b C d")
15:12:37 <lambdabot>   ["A","b","C","d"]
15:12:48 <roconnor> duaneb: yes
15:13:31 <duaneb> roconnor: care to expand? :P
15:13:32 <Cale> duaneb: 'where' scopes over the entire guard block
15:13:41 <gnuvince_> @index comparing
15:13:41 <lambdabot> bzzt
15:13:41 <roconnor> {function param = { expession }} where {where block}
15:13:45 <Cale> duaneb: So the 'where' is technically outside the 'let'
15:13:49 <copumpkin> Data.Ord iirc
15:13:54 <MyCatVerbs> duaneb: let bindings only extend as far as the "in" expression.
15:13:56 <duaneb> ahh
15:13:59 <roconnor> {function param |guard1 = { expession1 }  | guard 2 = {expression2}} where {where block}
15:14:12 <duaneb> well, I actually need a 'local' where
15:14:19 <roconnor> duaneb: in particular the where block covers all guard conditions.
15:14:21 <duaneb> how can I force it into a smaller scope?
15:14:24 <Cale> Just put it inside the let
15:14:35 <roconnor> > let x = y where y = 3 in x
15:14:36 <lambdabot>   3
15:14:36 <Cale> I mean, move the definitions into the let
15:14:39 <duaneb> just open a guard and have a True function in there?
15:14:46 <Cale> hm?
15:15:03 <duaneb> Cale: I separated them so that I wouldn't have to calculate them in the case that I returned "Miss"
15:15:09 <duaneb> and I plan on stricting them later :P
15:15:20 <Cale> duaneb: Things which are defined by let aren't necessarily computed
15:15:45 <roconnor> duaneb: there is no way of having the let expression extend to the where clause without putting the where clause into the let expression.
15:15:48 <Cale> duaneb: It only makes declarations, it doesn't force them to evaluate
15:16:02 <roconnor> > let {x = 7; z = y where y = x} in z
15:16:03 <lambdabot>   7
15:17:08 <Cale> duaneb: There's no difference between let and where except the scope.
15:17:36 <Cale> (in fact, the compiler turns where into let)
15:18:16 <duaneb> achh
15:18:25 <duaneb> I was using strictness as a way to unbox prettily
15:19:13 <roconnor> Cale: we can write where !z = some stupid strict thing ?
15:19:44 <burp_> don't say http://code.haskell.org/hmatrix just wen down?
15:19:55 <Cale> roconnor: Ah, bang patterns turn into case expressions in that strange corner case, yeah.
15:20:01 <burp_> just when I try to work with it
15:22:13 <roconnor> burp_: http://code.haskell.org/hmatrix just wen down just when you try to work with it.
15:22:37 <burp_> I guess so :(
15:23:51 <Phyx-> damnabit... i though this "type family RF (a::*->*)" is correct syntax..
15:24:02 <korpios> Anyone here successfully use haskell-tyrant?  I keep getting an error when trying to run the example code.
15:24:40 <vixey> Phyx-: doesn't kind inference get it?
15:25:06 <Phyx-> vixey: it's giving a parse error, "parse error on input `)'"
15:25:17 <vixey> if you use  type family RF a ...
15:25:25 <vixey> doesn't kind inference figure it out it is * -> *?
15:25:28 <Saizan> Phyx-: have you enabled KindOperators ?
15:25:55 <Saizan> vixey: in the type family declaration you're never going to use 'a' so i'd be surprised if it does
15:26:05 <Phyx-> Saizan: it's saying "unsupported extension: KindOperators"
15:26:18 <Saizan> Phyx-: sorry, KindSignatures
15:26:27 <Phyx-> Saizan: yes i have that
15:27:05 <Phyx-> vixey: using only a it does typecheck, but since i haven't declared any instances yet, i don't know if it'll get the right kind or give me an error later
15:27:22 <Saizan> Phyx-: you've to use spaces
15:27:32 <Saizan> Phyx-: (a :: * -> *)
15:27:34 <vixey> why doesn't type  family use
15:27:40 <vixey> ?
15:28:05 <Phyx-> Saizan: wow.. that's annoying
15:28:06 <Phyx-> lol
15:28:07 <Phyx-> thanks
15:28:57 <Saizan> it's actually prettier, imho :)
15:29:40 <marcusb> hi again.  say I have "data Foo = Bar Int Int | Baz Int Int", shouldn't I be able to map "Bar" and "Baz" (the constructors) to something with say "func :: (Int -> Int -> Foo) -> Bool" "func Bar = True" "func Baz = False" ?  But I get a "Couln't match expected type Int -> Int -> Foo against inferred type Foo" error.
15:29:53 <Phyx-> Saizan: yeah, but i never expected spaces to give errors. but ok,I know now
15:30:56 <roconnor> func :: (Int -> Int -> Foo) -> Bool has to work on every function Int -> Int -> Foo, not just the constructors.
15:31:19 <roconnor> You could write func :: (Foo) -> Bool
15:31:21 <vixey> Baz isn't a pattern
15:31:28 <vixey> (Baz x y) is a pattern
15:31:31 <roconnor> func (Bar _ _) = True
15:31:32 <vixey> you have to fully apply
15:31:37 <roconnor> func (Baz _ _) = Falze
15:31:40 <roconnor> False
15:31:50 <Phyx-> can someone actually explain in "(f:: (* -> *)-> * -> *)::(* -> *)-> * -> *" the meaning of :: in this case to me?
15:31:56 <Phyx-> since it doesn't seem to make sense at all atm
15:32:26 <vixey> Phyx- where did you find it
15:32:58 <Saizan> it means: f, which has kind (* -> *)-> * -> *, has kind (* -> *)-> * -> *
15:33:01 <roconnor> :: means kind of
15:33:09 <roconnor> er "has kind"
15:33:10 <Phyx-> vixey: course outline
15:33:12 <roconnor> @kind Maybe
15:33:13 <lambdabot> * -> *
15:33:33 <Phyx-> vixey: isn't that saying things double?
15:33:34 <MyCatVerbs> roconnor: cheap strawberries :: yummy.
15:33:47 <marcusb> vixey: so type constructors are not first class functions?
15:34:02 <vixey> marcusb: what???? lol
15:34:07 <marcusb> or mh
15:34:16 <marcusb> or is the problem just that I can't match them?
15:34:18 <roconnor> marcusb: they are first class functions, however you cannot pattern match on functions.
15:34:22 <marcusb> I see.
15:34:25 <dsouza> maybe a silly question, but I can't figure why ghc complains when trying to compile this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4971#a4971
15:34:35 <Phyx-> vixey: for instance, if i ommit the last ::<etc> shouldn't that say the same thing?
15:34:51 <qaz> when doing naive 2D-graphics I often find the painting very slow. I don't see how ti could possibly scale to 3d graphics with loads of things ahppening at the screen.
15:34:59 <monadic_kid> marcusb: you mean data constructor, not type constructor
15:35:01 <qaz> what is the best way of redrawing a screen?
15:35:07 <marcusb> monadic_kid: ok, thanks
15:35:12 <Saizan> Phyx-: are you sure that's not part of something larger?
15:35:13 <roconnor> marcusb: you can only pattern match on data types, (and you can fake pattern match on  Integers and such)
15:35:15 <qaz> like just moving an aeroplane on a 2D view and it just goes so slow
15:35:25 <qaz> but jumping 5 pixels at the time is not a good solution
15:35:34 <marcusb> ok
15:35:40 <copumpkin> roconnor: why is it fake?
15:35:45 <marcusb> I'll just have to pass through the whole value then
15:35:52 <roconnor> copumpkin: because it is really using Eq
15:36:08 <vixey> qaz GPU
15:36:09 <monadic_kid> marcusb: and data constructor can be treated as normal functions so they can be treated as first-class functions as well
15:36:10 <copumpkin> hmm
15:36:26 <marcusb> monadic_kid: yes, my confusion was that I tried to pattern match them
15:36:40 <marcusb> because I can pattern match the data I was confused
15:37:02 <Phyx-> Saizan: larger as in? only thing i didn't paste was the type family name, It's just the first time i've seen :: after a ::, lol. Though i haven't used type families alot
15:37:03 <marcusb> it makes sense that I can't pattern match on function names
15:37:04 <roconnor> copumpkin: for example you could "pattern match" with 7 on a function if the function type was an instance of Num  (I believe).
15:37:12 <copumpkin> interesting
15:37:29 <roconnor> but it would use the Eq instance of the function.
15:37:41 <qaz> vixey: not using normal processor but graphics processor instead? and how do I do that? doesnt ti happen automatically with openGL?
15:37:42 <roconnor> whatever that would do.
15:37:51 <monadic_kid> marcusb: "func :: Foo -> Bool" func Bar _ _ = True func Baz _ _ = False
15:37:55 <vixey> yes
15:37:57 <MyCatVerbs> roconnor: you can't define Num on functions because Num requires Eq, though.
15:38:04 <Saizan> Phyx-: type family Foo (f :: ( * -> *) -> * -> *) :: (* -> *) -> * -> * means something else.
15:38:30 <roconnor> MyCatVerbs: you can make an Eq instance for functions whose domain is compact.
15:38:32 <Saizan> Phyx-: it means that Foo takes an index of kind (* -> *) -> * -> * and returns a type of the same kind
15:38:44 <Phyx-> Saizan: do you have a paper or a link that i can read more about it?
15:39:03 <marcusb> what I wanted to do is to convert  data Exp = Mul Int Int | Add Int Int   to "a * b" and "a + b" with "op val1 val2 = (show val1) ++ op_to_string (op) ++ (show val2)  where op_to_string maps Mul to "*" and Add to "+"
15:39:10 <Saizan> Phyx-: search for type families in the haskell wiki
15:39:16 <roconnor> MyCatVerbs: Making Bool -> Int and instance of Num wouldn't be totally insane.  Just a little insane.
15:39:24 <Phyx-> Saizan: ok, cool, thanks
15:40:29 <monadic_kid> marcusb: you mean you want' t define + and * as data constructors?
15:40:40 <marcusb> monadic_kid: no just for pretty printing
15:41:05 <roconnor> marcusb: you can write op_to_string(op val1 val2)
15:41:23 <Axman6> marcusb: take a look at real world haskell, they do just that
15:41:27 <roconnor> marcusb: well, not quite like that
15:41:38 <MyCatVerbs> roconnor: ah, yes, I suppose. What does the term "compact" mean when applied to a set?
15:42:04 <roconnor> MyCatVerbs: um, good question.
15:42:14 <marcusb> roconnor: yes, I realize that now.  it would be nice somehow to ask a function what it thinks it is and get some kind of differentiating response
15:42:30 <marcusb> but it doesn't work in general of course
15:42:55 <roconnor> marcusb: what you are doing is fairly common, but you are sort of doing it the wrong way here.
15:43:16 <marcusb> roconnor: what's the right way? :)
15:43:44 <roconnor> show (Mul a b) = showInfix "*" a b
15:43:57 <roconnor> show (Add a b) = showInfix "+" a b
15:43:59 <roconnor> ...
15:44:37 <roconnor> others may suggest slight variations on this.
15:45:08 <marcusb> yeah.  well, two problems here.  I don't want to change the default view, but apart from that, I just tried to generalize/refactor binary operators and operator names
15:45:20 <marcusb> it seemed dull to repeat the same rule over and over again
15:46:19 <marcusb> but yeah, I think I was overdoing it
15:47:49 <roconnor> marcusb: there is no way out unless you are willing to guarentee that every constructor for Exp has exactly two Int parameters
15:47:56 <marcusb> yeah
15:48:01 <marcusb> roconnor: thanks for the light
15:48:01 <roconnor> and even then you still have to write the same amount of code, if not more.
15:48:12 <roconnor> and it will be less general
15:48:17 <marcusb> showInfix is a nice touch, that actually removes most of the boilerplate I was worried about
15:48:19 <roconnor> and more dangerous
15:48:29 <roconnor> marcusb: that's good.
15:48:49 <marcusb> is showInfix a standard function?
15:48:54 <roconnor> no
15:48:57 <marcusb> ok
15:50:05 <dsouza> could someone give some pointers why can't compile this code on ghc? -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4971#a4971
15:51:01 <qaz> @type showInfix
15:51:02 <lambdabot> Not in scope: `showInfix'
15:51:03 <dsouza> I could't undestand the reason this fails
15:51:17 <qaz> > ((+1) *** (+3)) $ 3
15:51:18 <lambdabot>       No instance for (Num (b, b'))
15:51:18 <lambdabot>        arising from the literal `3' at <i...
15:51:20 <qaz> > ((+1) *** (+3)) $ (3,4)
15:51:21 <lambdabot>   (4,7)
15:51:26 <qaz> > ((+1) &&& (+3)) $ 3
15:51:27 <lambdabot>   (4,6)
15:51:38 <qaz> > ((+1) &&& (+3)) <$> [1,2,3]
15:51:39 <lambdabot>   [(2,4),(3,5),(4,6)]
15:52:20 <augustss> dsouza: because magnitude has type a->b
15:52:22 <dsouza> s/could't/couldn't/
15:52:35 <roconnor> dsouza: as it stands your magnitude function has to return any type of floating type.
15:52:46 <roconnor> dsouza: but your instance only returns one type of floating instance.
15:53:00 <augustss> dsouza: Looking at the instance I'd say it has type Vector a -> a
15:53:02 <roconnor> dsouza: you need to use type families :)
15:53:09 <augustss> VectorT a -> a
15:53:13 <roconnor> er
15:53:14 <roconnor> ya
15:53:16 <roconnor> sorry
15:53:22 <roconnor> dsouza: listen to augustss
15:53:32 <roconnor> I have too much type family on my brain.
15:53:49 <dsouza> I have the empty set in mine :-)
15:54:14 <roconnor> hmm
15:54:21 <augustss_> dsouza: Perhaps yoo want: class Vector v where magnitude :: v a -> a
15:54:50 <duaneb> so how can I get the haskell equivalent of DBL_MAX
15:55:11 <augustss_> dsouza: And then: instance Vector VectorT where ...
15:55:16 <roconnor> > maxBound :: Double
15:55:17 <lambdabot>       No instance for (Bounded Double)
15:55:17 <lambdabot>        arising from a use of `maxBound...
15:55:20 <duaneb> maxBound
15:55:48 <augustss_> duaneb: It's a bit fiddle, you need to extract the maximum exponent and construct the maximum mantissa
15:55:51 <duaneb> damn.
15:55:52 <augustss_> fiddly
15:55:53 <dsouza> augustss_: but in this case, if for any reason I created an VectorT Int,
15:56:05 <duaneb> augustss: yea, but shouldn't it be defined somewhere
15:56:07 <dsouza> that magnitute would fail because of sqrt. is it right?
15:56:32 <augustss_> dsouza: I meant:  instance (Floating a) => Vector VectorT where ...
15:56:40 <duaneb> I happen to know that the max is 1.7976931348623157e+308 on my machine
15:56:45 <augustss_> duaneb: It should, but I don't know that it is
15:57:12 <augustss_> duaneb: It would be a good thing to write generically and put on hackage
15:57:23 <dsouza> augustss_: is there any to rewrite this in a way that I would be able to also create instances of VectorT Integer (or any instance of Integral)?
15:57:37 <dsouza> not only Floating vectors?
15:57:48 <roconnor> > snd ( floatRange (undefined::Doble))
15:57:49 <lambdabot>   Not in scope: type constructor or class `Doble'
15:57:53 <roconnor> > snd ( floatRange (undefined::Double))
15:57:55 <lambdabot>   1024
15:58:21 <roconnor> > floatDigits (undefined::Double)
15:58:22 <lambdabot>   53
15:58:28 <augustss_> dsouza: You could use a multiparameter type class (or a type family) to define the return type.
15:58:29 <roconnor> > floatRadix (undefined::Double)
15:58:30 <lambdabot>   2
15:58:44 <Axman6> > undefined
15:58:45 <lambdabot>   * Exception: Prelude.undefined
15:58:55 <Axman6> o.O
15:59:04 <augustss_> dsouza: but what type would magnitude return for VectorT Integer?
15:59:05 <roconnor> > fromRational ((2^53-1)*2^1024) :: Double
15:59:06 <lambdabot>   Infinity
15:59:16 <roconnor> > fromRational ((2^53-1)*2^1023) :: Double
15:59:17 <lambdabot>   Infinity
15:59:47 <dsouza> augustss_: I'd expect it to be an instance of Floating
15:59:57 <roconnor> > fromRational ((2^53-1)*2^1024-53) :: Double
15:59:58 <lambdabot>   Infinity
16:00:02 <roconnor> > fromRational ((2^53-1)*2^1024-53-1) :: Double
16:00:03 <lambdabot>   Infinity
16:00:13 * roconnor fails his floating point test
16:00:30 <adamvo> > Infinity -1
16:00:31 <lambdabot>   Not in scope: data constructor `Infinity'
16:00:37 <adamvo> > inf-1
16:00:38 <lambdabot>   Not in scope: `inf'
16:00:44 <augustss_> dsouza: But, e.g., a Float, might not be able to express the value (because of the limited range).
16:00:48 <vixey> @let inf = 1/0
16:00:49 <lambdabot>  Defined.
16:01:03 <adamvo> > recip inf
16:01:04 <lambdabot>   0.0
16:01:26 <adamvo> > predinf
16:01:27 <lambdabot>   Not in scope: `predinf'
16:01:29 <adamvo> > pred inf
16:01:30 <lambdabot>   Infinity
16:01:43 <augustss_> dsouza: But if that's what you want, you can use realToFrac to convert the numbers
16:01:45 <adamvo> > iterate pred inf
16:01:46 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
16:02:18 <dsouza> augustss_: at this point I'm more interesting in being able to represent this in haskell code. I'm just studying ... not doing anything serious/useful. the purpose is just learn, so the range of values Float/Double can express is not relevant
16:02:21 <augustss_> fromRational ((2^53-1)*2^(1024-53-1)) :: Double
16:02:36 <augustss_> > fromRational ((2^53-1)*2^(1024-53-1)) :: Double
16:02:37 <lambdabot>   8.988465674311579e307
16:02:50 <augustss_>  fromRational ((2^53-1)*2^(1024-53)) :: Double
16:03:05 <augustss_> > fromRational ((2^53-1)*2^(1024-53)) :: Double
16:03:06 <lambdabot>   1.7976931348623157e308
16:03:34 <duaneb> augustss there ya go :P
16:03:34 <dsouza> augustss_: thx anyway. I'll start looking on type families (it seems to be a long road). any papers/link or just searching on haskell wiki?
16:03:57 <duaneb> ok
16:04:00 <duaneb> haskell people may wince
16:04:16 <duaneb> but is there anyway to give haskell a hexadecimal version of a float?
16:04:19 <augustss_> There's a new paper by Simon PJ and Oleg
16:04:32 <augustss_> duaneb: I wish, but no
16:04:40 <duaneb> why not?
16:05:44 <dsouza> ok. thx
16:06:00 * duaneb feels as if there should be a bit-wide specified floating type similar to Word*
16:06:05 <dino-> I started going through this http://en.wikibooks.org/wiki/Haskell/Solutions/Applicative_Functors
16:06:17 <dino-> And doing the exercises for functors at the beginning..
16:06:48 <dino-> The third exercise was Define an instance of Functor for the function type ((->) t)
16:07:16 <monadic_kid> dino: just replace the types and you'll see it
16:07:31 <monadic_kid> :t fmap
16:07:31 <dino-> After much deliberation I came up with the same ansewr that's in the answers but it doesn't compile!
16:07:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:07:34 <dino-> :o
16:07:53 <dino-> instance Functor ((->) t) where fmap f g = g . f
16:08:03 <Saizan> what's the error?
16:08:06 <roconnor> > fix $ fromIntegral . ap ((*) . subtract 1 . liftM2 (^) floatRadix floatDigits) (liftM2 (^) floatRadix (ap ((-) . snd . floatRange) floatDigits))
16:08:06 <augustss_> > let maxFloat a = encodeFloat (floatRadix a ^ floatDigits a - 1) (snd (floatRange a) - floatDigits a) `asTypeOf` a in maxFloat 1.0
16:08:07 <lambdabot>   1.7976931348623157e308
16:08:08 <lambdabot>   1.7976931348623157e308
16:08:18 <dino-> Couldn't match expected type `t' against inferred type `b'
16:08:19 <dino->       `t' is a rigid type variable bound by
16:08:19 <dino->           the instance declaration at appfunc.hs:59:23
16:08:19 <dino->       `b' is a rigid type variable bound by
16:08:19 <dino->           the type signature for `fmap' at <no location info>
16:08:21 <dino->     In the second argument of `(.)', namely `f'
16:08:23 <dino->     In the expression: g . f
16:08:35 <Saizan> use hpaste in the future :)
16:08:50 <dino->  In the definition of `fmap': fmap f g = g . f
16:09:06 <dino-> Saizan: I was fearing that was too big, yeah
16:09:12 <roconnor> augustss_: yours is better
16:09:26 <Saizan> ?type let fmap f g = f . g in fmap
16:09:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:09:37 <augustss_> roconnor: yours has fewer variables
16:09:39 <Saizan> dino-: well, the solution is wrong
16:10:01 <Saizan> dino-: it's f . g not g . f
16:10:27 <dino-> Me and the solution both.
16:10:58 <roconnor> > let maxFloat a = encodeFloat (floatRadix a ^ floatDigits a - 1) (snd (floatRange a) - floatDigits a) `asTypeOf` a in fix maxFloat
16:10:59 <lambdabot>   1.7976931348623157e308
16:11:00 <dino-> I was thinking that, since the function is (t -> a), you want the fmapped function, f, to operate on the a. But no.
16:11:15 <Saizan> you do want to operate on the a
16:11:23 <Saizan> but the 'a' is the result of g
16:11:26 <copumpki> what program generates the index.html when you ask cabal to generate documentation? it comes from the .cabal file, so I assume it's cabal?
16:11:32 <copumpki> (and not haddock)
16:11:42 <Saizan> remember that f . g = \x -> f (g x)
16:11:44 <roconnor> augustss_: I think you don't need a parameter for maxFloat
16:12:04 <augustss_> roconnor: You don't.  I did it for simplicity.
16:12:13 <roconnor> > let maxFloat = encodeFloat (floatRadix maxFloat ^ floatDigits maxFloat - 1) (snd (floatRange maxFloat) - floatDigits maxFloat)  in maxFloat
16:12:14 <lambdabot>   1.7976931348623157e308
16:12:19 <roconnor> > let maxFloat = encodeFloat (floatRadix maxFloat ^ floatDigits maxFloat - 1) (snd (floatRange maxFloat) - floatDigits maxFloat)  in maxFloat :: Float
16:12:20 <lambdabot>   3.4028235e38
16:12:42 <Saizan> copumpki: it's still generated by haddock, the text is given by cabal to it as what haddock calls the "prologue"
16:13:04 <roconnor> @type let maxFloat = encodeFloat (floatRadix maxFloat ^ floatDigits maxFloat - 1) (snd (floatRange maxFloat) - floatDigits maxFloat)  in maxFloat
16:13:05 <lambdabot> forall a. (RealFloat a) => a
16:13:57 <dino-> Saizan: Thank you. I have to think about it more.
16:14:05 <roconnor> duaneb: there is your maxFloat function
16:14:25 <roconnor> or rather maxFloat polymorphic value
16:14:30 <dino-> Let me ask this, what does this type represent: ((-> t) ?
16:15:00 <Saizan> dino-: have you ever used the reader monad?
16:15:02 <roconnor> dino-: I don't think type sections are allowed in GHC.
16:15:20 <roconnor> of do you mean ((->) t)?
16:15:26 <dino-> Saizan: Yes, but as a consumer only
16:15:28 <copumpki> Saizan: hmm, it seems to be ignoring my haddock markup in the .cabal file though
16:15:28 <dino-> roconnor: yes, sorry
16:15:32 <monadic_kid> dino-: you know if you subsitute the types you'll see it
16:15:52 <monadic_kid> dino-: replace all  occurances of f a with (-> t)
16:16:02 <dino-> monadic_kid: I saw you say that earlier, ok, I'll try that
16:16:04 <Saizan> dino-: well, it's the same thing, but without the Reader newtype
16:16:20 <___vvss___> why is erlang so ugly and haskell so beautiful when both use patternmatching?
16:16:29 <dino-> Saizan: This is now reminding me of _Monads as computations_ that I was unable to understand a long time ago as well.
16:16:37 <BMeph> dino-: Rather, replace all  occurances of f a with (t -> a)
16:16:40 <dino-> What you're saying about Reader and (->)
16:16:51 <monadic_kid> BMeph: thats what i meant
16:16:54 <Saizan> ?src Reader
16:16:54 <lambdabot> Source not found. You untyped fool!
16:17:06 <BMeph> monadic_kid: Yes, but it wasn't what you said. ;)
16:17:28 <dino-> After this, I'm going right back there to read it again.
16:18:50 <Saizan> dino-: well, the Reader monad represents computations that have access to a single constant of type 't', so, instead of storing it in a global or something else, we just pass that 't' as an argument to them
16:19:12 <zakwilson> I'm trying to track down a problem where I'm running out of file handles. Is there an easy way to profile that?
16:19:38 <Saizan> zakwilson: are you using readFile on a list of files?
16:20:06 <zakwilson> I'm using decodeFile, so yes.
16:20:21 <zakwilson> I wasn't having this problem until I made a change that resulted in larger files.
16:21:14 <zakwilson> And to be accurate, I'm mapping an operation that uses decodeFile internally over a list of files.
16:21:47 <Saizan> the problem is that readFile delays the reading, so keeps the file open, but opens the file immediately
16:22:03 <Saizan> so mapM readFile list, opens all the files and doesn't read anything
16:22:24 <Saizan> but mapM (unsafeInterleaveIO . readFile) list doesn't open the files either
16:22:34 <zakwilson> I figured it was something like that.
16:22:45 <Trowalts> has this channel grown allot in the last 3-4months?
16:22:50 <zakwilson> Now, what if I want to do it in parallel?
16:22:57 <dino-> Eh, I'm still not getting something. Trying to replace that f a with (t -> a) in fmap :: (a -> b) -> f a -> f b
16:23:00 <Saizan> so if you process them in sequence the first ones should get gc'ed before you access the later ones
16:23:23 <duaneb> so why does ghc recompile gmp?
16:23:27 <duaneb> when it builds?
16:23:34 <monadic_kid> dino-: and replace f b with (t -> b)
16:23:52 <zakwilson> Changed to mapM and still get the error: openBinaryFile: resource exhausted (Too many open files)
16:23:59 <dino-> Ah, replace f with ((->) t)
16:23:59 <Saizan> zakwilson: uhm, in that case it seems you do want them all open concurrently?
16:24:04 <dino-> That's what I didn't get
16:24:09 <Saizan> zakwilson: did you add unsafeInterleaveIO ?
16:25:47 <monadic_kid> :k ((->) t)
16:25:48 <lambdabot> Not in scope: type variable `t'
16:25:53 <dino-> Ok, and there is it, (a -> b) -> (t -> a) -> (t -> b)  looking just like (.)
16:26:12 <zakwilson> Saizan: That seems to have done it.
16:26:36 <zakwilson> I don't want them all open at once. I want one per core.
16:26:46 <Saizan> zakwilson: ah, i see
16:27:22 <monadic_kid> dino-: types give a lot of insight don't they ;)
16:27:32 <dino-> You know, there was a hint in that exercise in the wikibook: "In this case, f a will be (t -> a)"  A big, big hint.
16:28:02 <dino-> Absolutely. Thank you very much.
16:28:11 <dino-> Now, what Saizan was saying about Reader.
16:28:30 <zakwilson> And, because I do not understand it, and it says "unsafe" on it, I'm slightly afraid of unsafeInterleaveIO.
16:28:57 <Saizan> zakwilson: you kind of should :)
16:29:32 <Saizan> zakwilson: however it's not that scary, it's delaying performing the IO until you actually require the result
16:30:18 <Saizan> zakwilson: semantically is a bit like spawning a thread to perform it, and having a pure way to read the result
16:30:56 <copumpki> so what kind of context is the description field in the .cabal file being evaluated by haddock? it's ignoring my attempts to put markup in there
16:31:01 <rzezeski> Is BookInfo = BookInfo Int String [String] an Algebraic Data Type?  I don't think it is, b/c there is only ONE value ctor, but the quote on pg. 50 of RWH has me confused :(
16:31:20 <Saizan> dino-: newtype Reader r a = Reader (r -> a), runReader (Reader f) = f
16:31:45 <Saizan> rzezeski: it is one
16:31:52 <zakwilson> Saizan: That makes sense. Now, is there a trivial way to do it in parallel, or do I have to significantly redesign the system to get something I can use a parallel version of map with?
16:31:53 <uzytkownik> Hello. How to declare for function more then one typeclass restriction for parameter. One is specified by "function_name :: Ord a => [a] -> [a]"?
16:32:04 * BMeph wonders what does one do when "http://www.downforeveryoneorjustme.com" is unreachable...
16:32:25 <Saizan> zakwilson: the file processing requires IO or is it pure?
16:32:37 <vixey> http://www.downforeveryoneorjustme.com/http://www.downforeveryoneorjustme.com/
16:33:05 <zakwilson> Saizan: the CPU-intensive part is pure.
16:33:44 <monadic_kid> uzytkownkik: in () seperated by  ,
16:33:45 <zakwilson> But loading all the contents in to memory at once is not practical.
16:33:52 <Saizan> zakwilson: then you can apply Control.Parallel.* directly, there's parMap etc..
16:34:31 <monadic_kid> uzytkownkik: foo :: (Ord a, Bar a) => [a] -> [a]
16:34:33 <Saizan> zakwilson: and even if it's in IO it's easy to write a parallel mapM, there's a package on hackage too
16:34:45 <rzezeski> Saizan: thx, I think I misread the quote "An algebraic data type can have more than one value constructor" (pg 44) to mean is *has* to have more than one.  So I guess I'm still not 100% sure what exactly an algebraic data type is.  I know what it looks like I guess, but I lack a formal definition.
16:34:50 <SamB> vixey: that's funny!
16:34:57 <dino-> Oh, I was mistaken, it's part of http://www.haskell.org/haskellwiki/Monads_as_containers that talks about Reader
16:35:03 <uzytkownik> monadic_kid: Ok. Thanks. I've tried it but at a wrong line ;)
16:35:30 <zakwilson> Saizan: Thanks. I'll look for it.
16:35:50 <Saizan> rzezeski: well, an algebraic datatypes is everyone that you define using the keyword "data"
16:36:18 <Saizan> rzezeski: the term "algebraic" comes from the fact that they are defined as products and sums of other types
16:36:26 <rzezeski> yea, I got that from the quote on pg 50, but I guess I'm asking why is it called an algebraic data type?
16:36:55 <monadic_kid> there was a good blog explaining alegbraic data types and differential types
16:36:58 <Saizan> where product is cartesian product, and sum is disjoint union
16:37:10 <rzezeski> Saizan: ah, OK, that's what I was after, thank you!
16:37:38 <rzezeski> monadic_kid: You have the link?
16:37:50 <Saizan> so data Foo = C1 A B | C2 C D can be seen as (A*B)+(C*D), or Either (A,B) (C,D)
16:38:46 <monadic_kid> rzezeski: http://blog.lab49.com/archives/3011
16:38:54 <rzezeski> Saizan: I don't mean to be obtuse, but I don't quite follow your example
16:39:30 <rzezeski> monadic_kid: thx
16:40:03 <monadic_kid> thats probably the best explaintion i've ever seen on the topic
16:40:27 <sclv> ?ty local
16:40:28 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
16:40:47 <rzezeski> Saizan, I think I get the Either (A,B) (C,D) part...you're saying that it could be a tuple of types (A,B) or (C,D)?  But I didn't follow the first part
16:41:07 <Saizan> ?src Either
16:41:07 <lambdabot> Source not found. That's something I cannot allow to happen.
16:41:21 <dino-> I must go cook dinner. Thank you for the help. I will go study Reader after.
16:41:27 <Saizan> data Either a b = Left a | Right b
16:41:38 <Saizan> so it can be one or the other type
16:42:08 <monadic_kid> hence the name either ;D
16:42:10 <copumpki> @djinn (a -> a) -> a -> Bool
16:42:10 <lambdabot> f _ _ = False
16:42:52 <Saizan> the type constructors Either and (,) behave much like (+) and (*) do on integers
16:43:01 <duaneb> ok, stupid question: what's the easiest way to traverse a 2d list?
16:43:05 <Saizan> so often the latter notation is chosen
16:43:14 <vixey> 2d list doesn't exist
16:43:15 <Saizan> but it's not legal haskell
16:43:16 <rzezeski> Saizan, yes, I think I'm starting to make that connection
16:43:40 <QtPlaty[HireMe]> duaneb: A list of lists?
16:44:34 <Saizan> rzezeski: for example the () type is like 1, in fact ((),a) ~~ (a,()) ~~ a, like 1*a = a*1 = a
16:44:35 <rzezeski> ah snap!  I think it just clicked, but I can't explain it :)
16:44:46 <QtPlaty[HireMe]> map (\l -> map f l) l2 -- ?
16:44:55 <Saizan> and data Void; with no constructors, is 0
16:46:04 <duaneb> QtPlaty[HireMe]: yea, I thought there might be a builtin one that mapped to a 2d array
16:46:17 <Saizan> so in the end they form a ring, if you know the term from abstract algebra
16:46:34 <QtPlaty[HireMe]> duaneb: Arrays and lists are diffrent in Haskell.
16:48:22 <Saizan> (lazyness breaks this a little, but we usually don't care much about that in this settings)
16:48:27 <rzezeski> Saizan, so if A was the range of numbers 1 to 10, and B was the letters of the English alphabet, then C1 A B would be (10*26) to make 260 different combinations?  Does that make any sense?
16:49:54 <Cale> (\l -> map f l) = map f
16:49:54 <roconnor> @hoogle IdentityT
16:49:54 <lambdabot> No results found
16:50:20 <Cale> > map (map (+1)) [[1,2,3],[4,5],[6,7,8]]
16:50:21 <lambdabot>   [[2,3,4],[5,6],[7,8,9]]
16:51:51 <neoswish> > return.map (+1) =<< [[1,2,3],[4,5,6]]
16:51:53 <lambdabot>   [[2,3,4],[5,6,7]]
16:51:56 <neoswish> =)
16:52:04 <Saizan> rzezeski: yes, the C1 A B type would contain that much elements
16:52:08 <Saizan> *many
16:52:43 <Saizan> well, C1 A B is not a type, but (A,B) is
16:53:59 <rzezeski> Saizan: Thx for your help!  I'm going to read that blog post monadic_kid linked just to make sure I'm understanding all this.
16:59:31 <duaneb> oh, that's confusing
16:59:47 <duaneb> my program calls "Writing file" before it figures out what to write
16:59:48 <Saizan> what?
16:59:55 <duaneb> I just love laziness.
17:00:02 <Saizan> ah :)
17:01:07 <QtPlaty[HireMe]> duaneb: Shouldn't the IO monad prevent that?
17:01:40 <QtPlaty[HireMe]> Oh figurering out is pure?
17:01:47 <duaneb> QtPlaty[HireMe]: yes :P
17:02:12 <neoswish> is default keyword only for Num class?
17:02:14 <duaneb> oh great
17:02:27 <duaneb> haskell doesn't throw an exception on divide by zero!?
17:02:40 <roconnor> > 1 `div` 0
17:02:41 <lambdabot>   * Exception: divide by zero
17:03:11 <duaneb> yea, but  > 1 / 0
17:03:13 <copumpki> what do messages along the lines of "Warning: Data.Array.Vector: unsafeFreezeMU is exported separately but will be documented under UA. Consider exporting it together with its parent(s) for code clarity." mean?
17:03:14 <duaneb> > 1 / 0
17:03:15 <lambdabot>   Infinity
17:03:26 <vixey> have you noticed the people that like TCO call it TCO and the people against it call it TRE?
17:03:27 <duaneb> plus, div is probably integral
17:03:32 <duaneb> @type div
17:03:32 <lambdabot> forall a. (Integral a) => a -> a -> a
17:03:36 <duaneb> see?
17:03:38 <duaneb> great.
17:03:42 <roconnor> vixey: I have
17:03:58 <roconnor> duaneb: what do you get when you do 1.0 / 0.0 in C?
17:03:59 <duaneb> anyway, 1 / 0 should be NaN, not Infinity
17:04:05 <duaneb> roconnor: I'll check
17:04:11 <roconnor> duaneb: tell that to the IEEE
17:04:20 <augustss_> duaneb: IEEE says it's infinity
17:04:34 <augustss_> Which may or may not raise an exception.
17:04:54 <dolio> vixey: Don't the people who like it call it 'proper tail recursion'? :)
17:04:57 <duaneb> IEEE needs to take algebra again.
17:05:07 <dolio> Or is that just Scheme bigwigs?
17:05:20 <augustss_> IEEE floating point fails on most algebraic properties
17:05:35 <augustss_> Like associativity
17:05:39 <duaneb> dolio: no, those are the people who don't understand what TCO *is*
17:05:40 <copumpki> dons: would it be bad to define andU/orU/allU/anyU in UArr in terms of foldr, so it can short-circuit and match List behavior more?
17:05:40 <Gracenotes> it is a very extremely useful tool though
17:05:42 <roconnor> dolio: I wonder if proper tail recursion is something different, something about how the "function call" is handled rather than about stack allocation?
17:05:52 <Gracenotes> well. very. maybe not very extremely.
17:05:55 <MyCatVerbs> duaneb: no, the IEEE 754 committee knew exactly that they were doing. It's designed for numerical simulation of physical processes, not algebra.
17:06:10 <dolio> duaneb: The scheme standard calls it "proper tail recursion".
17:06:28 <Gracenotes> IEEE has the most precision for lower numbers, where people are more apt to use it
17:06:38 <copumpki> duaneb: there are a lot more painful things in IEEE than just that :) but it's still very useful for practical applications
17:07:12 <Gracenotes> if you want something like computable reals, go ahead, but also be prepared to pay the price in performance... >_>
17:07:16 <Gracenotes> *the IEEE mafia strikes again*
17:07:20 <dolio> roconnor: Well, I read some newsgroup discussion where a guy was claiming that "proper tail recursion" is a stronger property than what you get with "tail call optimization", but I haven't gotten to his paper yet.
17:07:29 <copumpki> :o
17:07:54 <roconnor> dolio: I would guess that, but I'm only inferring that from the name and a bit of context.
17:07:57 <dolio> roconnor: Something about proper tail recursion preventing you from doing stack allocation of variables at all, in some cases, or something.
17:08:09 <copumpki> lol
17:08:45 <roconnor> dolio: I could believe that.  No need to free a stack and allocate it again, just reuse it.
17:09:14 <Gracenotes> how I love cocoa with my pumpkin pie!
17:09:17 * Gracenotes bakes cocopumpkin
17:09:19 <copumpki> :o
17:09:44 <cocopumpkin>  :O
17:10:20 <cocopumpkin> A coCoconut  is just a conut.
17:10:30 <copumpki> I have quickcheck 2.1 installed in my user cabal dir, and 1.2 in the system
17:10:42 <duaneb> @type or
17:10:42 <Saizan> and a coconut is just a nut?
17:10:43 <lambdabot> [Bool] -> Bool
17:10:44 <kacper_> I write structural induction proof for reverse( reverse xs ) = xs and its good for finite list. I know that for infinite it should fail but i considering a case reverse( reverse _|_ ) => reverse( _|_ ) => _|_ and its look like good, who knows where induction for infinite lists fails?
17:10:45 <copumpki> and it's complaining that 1.2 doesn't have what I need, when I want it to use 2.1
17:10:48 <duaneb> wtf?
17:10:49 <duaneb> ok
17:10:51 <dolio> roconnor: I'm not exactly sure how doing tail call optimization would fail to get you proper tail recursion though. Perhaps you can construct pathological examples where you get linear stack growth by referring to the contents of old stacks while using CPS or something.
17:10:52 <cocopumpkin> Saizan, yes. :O
17:10:59 <dons> copumpki: hmm. you want to short circuit the non-fused version?
17:11:00 <dons> -- |/O(n)/. 'andU' yields the conjunction of a boolean array.
17:11:00 <dons> andU :: UArr Bool -> Bool
17:11:00 <dons> {-# INLINE andU #-}
17:11:00 <dons> andU = foldU (&&) True
17:11:10 <Saizan> copumpki: --user ?
17:11:18 <copumpki> dons: well, I added a foldrU
17:11:22 <dolio> roconnor: So even if you popped off stack frames, and allocated new ones, they'd be storing linearly increasing ammounts of variables or something.
17:11:36 <copumpki> dons: that builds on a stream foldr
17:11:45 <kacper_> I write structural induction proof for reverse( reverse xs ) = xs and its good for finite list. I know that for infinite it should fail but i considering a case reverse( reverse _|_ ) => reverse( _|_ ) => _|_ and its look like good, who knows where induction for infinite lists fails?
17:11:59 <dolio> Which isn't allowed under proper tail recursion, which has to have bounded stack use for the particular case.
17:12:04 <roconnor> dolio: I'm not claiming any change in space usage by proper tail recursion over TCO.
17:12:05 <dolio> Constant bounded, that is.
17:12:16 <copumpki> Saizan: I'm not using cabal for the compilation in this case :/
17:12:18 <vixey> kacper_: do you have proof rules for infinite structures?
17:12:20 <copumpki> it's a plain makefile
17:12:20 <roconnor> dolio: just a minor opitmization
17:12:29 <roconnor> dolio: again, I'm sort of making all this up. I have no idea really
17:12:49 <kacper_> vixey: no
17:12:49 <ajdhs> does anyone know how to use QuickCheck to get ahold of the value that caused a failure (I asked this earlier, but no answer.)
17:12:51 <Saizan> copumpki: are you running it as the same user?
17:13:02 <copumpki> Saizan: yup, only got one user on this computer
17:13:15 <copumpki> it seems to be looking at my system quickcheck
17:13:33 <MyCatVerbs> dolio: IIRC one of the Schemes that does Cheney on the MTA just lets frames get allocated when you tail-call.
17:13:35 <dolio> roconnor: He was claiming that TCO doesn't satisfy the space behavior of proper tail recursion, though.
17:13:49 <vixey> kacper_: lets find some
17:13:56 <augustss_> kacper_: Your particular case works, but what about, e.g., reverse (reverse (1:_|_))?
17:14:13 <vixey> kacper_: for finite things you can do least fixed point induction, so on infinte things you get to do greatest fixed point induction
17:14:24 <roconnor> dolio: okay, that's just crazy
17:14:29 <copumpki> dons: I can leave it alone though, it isn't that important :)
17:14:29 <MyCatVerbs> dolio: the allocated frames become garbage immediately on the next call, so that even though O(n) frames get allocated, only a constant number are ever live for the GC.
17:14:46 <rzezeski> monadic_kid: You weren't lying, that's a great explanation of algebraic data types!  It melted my mind a little though, I'm going to have to come back to it at a later date :)
17:14:59 <copumpki> dons: I'm just cleaning up code in preparation to give you something for 0.2
17:15:14 <kacper_> vixey: could You give me any advice?
17:15:14 <MyCatVerbs> dolio: the author justifies this implementation by pointing out that the Scheme standard only requires *amortised* O(1) space usage for tail recursive functions, not hard O(1) space usage. :3
17:15:32 <dolio> Anyhow, the paper is "Proper Tail Recursion and Space Efficiency" by Will Clinger.
17:15:39 <dolio> I'm not sure if it goes into all that or not.
17:17:32 <kacper_> augustss_: reverse( reverse (1:_|_) ) => _|_ /= (1:_|_) right?
17:18:16 <vixey> kacper_: So the question is "what is induction for infinite objects"
17:18:20 <adamvo> > reverse (reverse (1:undefined))
17:18:21 <lambdabot>   * Exception: Prelude.undefined
17:19:00 <kacper_> adamvo: so it fails because /= 1:undefine ?
17:19:14 <dons> copumpki: i think the code as it is is fine.
17:19:25 <adamvo> > reverse (reverse (1:undefined:[]))
17:19:26 <lambdabot>   [1,* Exception: Prelude.undefined
17:19:30 <dons> happy to get e.g. IO /bytestring patches
17:19:37 <defun> hey, how does polyparse compare to parsec?
17:19:53 <copumpki> dons: okay, I'll just add a note in the documentation that points out the difference in behavior from list, maybe?
17:20:08 <Spreadsheet> I'm new to Haskell. how do you print a number in haskell?
17:20:34 <copumpki> Spreadsheet: print 1
17:20:36 <kacper_> vixey: i headr about coinduction, it is it?
17:20:41 <Spreadsheet> copumpki: thanks
17:20:44 <kacper_> *heard
17:20:50 <defun> nobody?
17:21:04 <blackh> Spreadsheet: 'putStrLn (show x)' is equivalent to 'print x'
17:21:11 <roconnor> @src print
17:21:11 <lambdabot> print x = putStrLn (show x)
17:22:06 <Spreadsheet> thanks again
17:22:23 <augustss_> kacper_: I think you can prove what you need by just fixpoint induction
17:22:27 <vixey> kacper_: How do weapply coinduction to this example?
17:22:30 <dons> copumpki: hmm. yes, it relies on fusion
17:22:36 <augustss_> kacper_: but fixpoint induction is no fun
17:22:42 <dons> copumpki: which is a bit weird
17:22:48 <copumpki> hmm, how do you mean?
17:23:37 <kacper_> vixey: I only heard that coinduction is for infinite structures
17:23:58 <ajdhs> defun: I think polyparse is newer
17:25:08 <dolio> Coinduction is for coinductively defined structures.
17:25:15 <dolio> They aren't necessarily infinite.
17:25:35 <defun> ajdhs: so, it is not neccessarily better or worse (than parsec). I assume that no one has tried using for a "real" project. Is there anything that would motivate me to use polyparse over parsec or vice versa?
17:25:48 <augustss_> kacper_: http://www.utdallas.edu/~hamlen/cs6371fa08/lecture9.pdf
17:27:11 <augustss_> kacper_: but that note doesn't mention the tedious part of showing that the predicate is admissable
17:27:56 <kacper_> augustss_: it looks too hard for this exercice ;)
17:28:00 <sooth> Is something wrong with code.haskell.org?
17:28:50 <augustss_> kacper_: well, it's easy to show that reverse . reverse /= id since you can find a counter example. :)
17:28:53 <ajdhs> defun: I believe it's used in HaXml
17:28:54 <jeffz`> sooth: seems to be, I can't access trac
17:29:17 <ajdhs> defun: Parsec is in the Haskell Platform and is probably more widespread
17:29:54 <copumpki> bah
17:30:06 <kacper_> yeah, as you wrote it is (1:undefine) but in my excercise i must show where induction's proof fails
17:30:15 <ajdhs> defun: so it may be better supported
17:30:27 <ajdhs> defun: I've never actually used PolyParse, so I can't give you a lot more detail than that.
17:31:22 <augustss_> kacper_: but you can't use structural induction to prove things when _|_ is involved.
17:31:33 <defun> thanks, mate.
17:32:14 <augustss_> HaXml uses polyparse and can parse quite large files fast.
17:32:22 <kacper_> so fixed-point induction ?
17:33:23 <jeffz`> hm, I've installed the haskell platform, tried to use ghci with Hipmunk but ghci tries to load a nonexistent libm.dll
17:33:50 * copumpki screams at cabal
17:33:55 <augustss_> kacper_: you can probably find where the induction fails pretty easily with fixed point induction
17:34:16 <augustss_> copumpki: it can't hear you
17:35:11 <kw317> hi
17:35:29 <copumpki> :/
17:38:22 <copumpki> Properties/Utils.hs:15:7:
17:38:22 <copumpki>     Could not find module `Test.QuickCheck.Batch':
17:38:22 <copumpki>       it is a member of the hidden package `QuickCheck-1.2.0.0'
17:38:53 <SamB> copumpki: what quickcheck is cabal using?
17:38:53 <SamB> any ?
17:39:00 <copumpki> this is from a makefile
17:39:01 <SamB> if not, add it to the .cabal file ...
17:39:06 <SamB> oh
17:39:07 <copumpki> just a regular ghc build
17:39:25 <copumpki> how can I express constraints on the command line?
17:39:27 <SamB> ask in #ghc ?
17:39:40 <dons> --constraint='base<43'
17:45:19 <coCoconut> pumpkin_: "In Cabal-space, no one can hear you scream." ;p
17:47:21 <Rambling> In Python, I can use tuples and lists interchangeably with function like sum: sum((1,2)) and sum([1,2]) both work. How can I sum the elements of a tuple in Haskell?
17:47:41 <vixey> Rambling: sumTuple (x,y) = x + y
17:47:44 <pumpkin_> you can't work with tuples of arbitrary sizes
17:47:45 <lambdabot> pumpkin_: You have 1 new message. '/msg lambdabot @messages' to read it.
17:47:47 <pumpkin_> uncurry (+)
17:47:47 <vixey> Rambling: sumTuple = uncurry (+)
17:48:17 <vixey> Rambling: if you wanted to write a function that works on tuples as well as lists you could use typeclasses - it's not normal haskell though
17:49:01 <Rambling> What about summing a 3-tuple?
17:49:04 <Cale> Rambling: It's just very uncommon to use tuples for something you're going to want to sum. The elements of a tuple may be of various different types anyway.
17:49:22 <Cale> Also, 3-tuples are uncommon and 4-tuples and higher are usually to be avoided.
17:49:43 <Cale> When you start getting larger numbers of components, defining your own datatype is usually best.
17:50:02 <MyCatVerbs> Cale: ...I have learned that last bit the hard way. :)
17:50:04 <Cale> But, you can say (\(x,y,z) -> x+y+z)
17:50:05 <Rambling> Okay.  I'm actually working on Project Euler Problem #9.
17:50:37 <Rambling> So I was working with lists of 3 tuples to represent possible Pythagorean Triplets.
17:50:50 <jeffz`> hm, ok, I thought this might have worked earlier, but windows ghci 6.8.2 also tries to load libm
17:51:24 <Cale> So in that case, you actually probably want to write a function like (\(x,y,z) -> x^2 + y^2 == z^2)
17:51:45 <Cale> (depending on how you choose to solve the problem)
17:52:28 * EvilTerran found a cleverly-written list comprehension to be the clearest way of doing that one, iirc
17:53:15 <Rambling> Cale: I made a list of triplets of numbers whose sum was 1000 and filtered it using a function identical to that.
17:53:22 <Cale> I haven't bothered to look at what the problem actually is, but yeah, a list comprehension is a nice way to generate Pythagorean triples if speed doesn't matter too much.
17:53:51 <pumpkin_> Rambling: that sounds inefficient :P
17:54:11 <dolio> Filtering by isPythagoreanTriple (x,y,z) is probably unadvisable, too.
17:54:25 <Cale> But that's really not so many triples to check.
17:54:46 <dolio> Rather than generating x and y and testing if x^2 + y^2 is square.
17:54:55 <solrize> > do {x<-[1..999];y<-[x..999];let z=1000-x-y; guard $ x^2+y^2==z^2; return z}
17:54:56 <lambdabot>   <no location info>: parse error on input `;'
17:55:00 <cocopumpkin> > [(2*m*n,m^2-n^2,1000-(2*m*n)-(m^2-n^2)) | m <- [2..], n <- [1..m], 2*m*n<m^2-n^2,2*m*n+(m^2-n^2)+(m^2+n^2)==1000]
17:55:00 <vixey> obv. you should implement CHR then CLP/FD in terms of CHR and write the program using that
17:55:11 <solrize> > do {x<-[1..999];y <-[x..999]; let z=1000-x-y; guard $ x^2+y^2==z^2; return z}
17:55:12 <lambdabot>   <no location info>: parse error on input `;'
17:55:15 <lambdabot>   thread killed
17:55:19 <cocopumpkin> > head [(2*m*n,m^2-n^2,1000-(2*m*n)-(m^2-n^2)) | m <- [2..], n <- [1..m], 2*m*n<m^2-n^2,2*m*n+(m^2-n^2)+(m^2+n^2)==1000]
17:55:20 <lambdabot>   (200,375,425)
17:55:21 <solrize> hmm
17:55:42 <cocopumpkin> I guess lambdabot likes to spit out random numbers. ;)
17:55:57 <Cale> Write a function to construct rationals, and then do a stereographic projection onto rational points on the unit circle ;)
17:56:22 <Rambling> cocopumpkin: I had forgotten that you could do filtering inside of the list comprehension rather than using filter.
17:57:14 <roconnor> > let rats = 1:concat [[x+1, 1/(x+1)]|x<-rats] in rats
17:57:16 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
17:57:20 <pumpkin_> do I need to do something to export instances from a module?
17:57:29 <roconnor> > let rats = 1:concat [[x+1, 1/(x+1)]|x<-rats] in rats :: [Rational]
17:57:30 <lambdabot>   [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%...
17:58:11 <cocopumpkin> > let rats = 1:concat [[x+1,1/(x+1)]|x<-rats] in scanr (*) 1 rats
17:58:14 <lambdabot>   [* Exception: stack overflow
17:58:32 <cocopumpkin> > let rats = 1:concat [[x+1,1/(x+1)]|x<-rats] in scanl (*) 1 rats
17:58:34 <lambdabot>   [1.0,1.0,2.0,1.0,3.0,1.0,1.5,1.0,4.0,1.0,1.3333333333333333,1.0,2.5,1.0,1.6...
17:59:33 <cocopumpkin> > let rats = 1:concat [[x+1,1/(x+1)]|x<-rats] in elemIndices 1 $ scanl (*) 1 rats
17:59:36 <lambdabot>   [0,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51...
17:59:43 <cocopumpkin> Odd.
17:59:54 <f1shb0t> > let rats = 1:concat [[x+1,1/(x+1)]|x<-rats] in scanl (*) 1 rats
17:59:56 <lambdabot>   [1.0,1.0,2.0,1.0,3.0,1.0,1.5,1.0,4.0,1.0,1.3333333333333333,1.0,2.5,1.0,1.6...
18:00:10 <solrize> [(x,y,z) | x<-[1..999], y<-[x..999], et z=1000-x-y, x^2+y^2==z^2]
18:00:15 <solrize> > [(x,y,z) | x<-[1..999], y<-[x..999], et z=1000-x-y, x^2+y^2==z^2]
18:00:17 <lambdabot>   <no location info>: parse error on input `='
18:00:24 <f1shb0t> bonhoffer: It hooks directly to the kernel, bypassing anything else that might be messed up.  The wiki link should explain it better though.
18:00:24 <solrize> > [(x,y,z) | x<-[1..999], y<-[x..999], let z=1000-x-y, x^2+y^2==z^2]
18:00:30 <lambdabot>   [(200,375,425)]
18:00:54 <cocopumpkin> lambdabot still likes to spit out random meaningless numbers. ;)
18:00:55 <dons> Cale, roconnor seen mathlink (haskell lib)?
18:00:55 <f1shb0t> > let rats = 1:concat [[x+1,1/(x+1)]|x<-rats] in scanl (*) 1 rats
18:00:57 <lambdabot>   [1.0,1.0,2.0,1.0,3.0,1.0,1.5,1.0,4.0,1.0,1.3333333333333333,1.0,2.5,1.0,1.6...
18:01:24 <f1shb0t> hoohah: and after e.g. install gnome-desktop you can remove that specific package and run 'apt-get autoremove' so it removed all automatically installed packages related to an non-longer-installed package.
18:01:25 <ajdhs> pumpkin_: no
18:02:24 <f1shb0t> I get the following error when installing debian: Device /dev/hdc has multiple (0) logical sectors per physical sector.  Any advice, info?  I have no idea what this means.
18:03:11 <MyCatVerbs> f1shb0t: it means you really, really need to be in #debian rather than #haskell.
18:05:26 <roconnor> http://www.reddit.com/r/programming/comments/8kf9n/reply_to_randal_schwartz_on_dynamic_type_systems/c09n1qt
18:05:51 <roconnor> Henry-Milner, why have you forsaken me?
18:06:02 <MyCatVerbs> roconnor: Hindley.
18:06:10 <roconnor> Hindley-Milner, why have you forsaken me?
18:07:05 <MyCatVerbs> Because polymorphic recursion is actually a complete cow.
18:07:16 <roconnor> cow?
18:07:28 <MyCatVerbs> Pain in the neck. SML does not support it at all for very good reasons.
18:07:28 <monochrom> Those who have learned from type system debates are bound to watch it repeat itself.
18:07:40 <roconnor> very good reasons?
18:08:07 <Cale> dons: I do remember hearing something about it. It looks neat, but I haven't tried it.
18:09:11 <augustss_> Polymorphic recursion is a bit of a pain, but necessary for operating on the more interesting types.
18:10:18 <dolio> Does SML allow nested types?
18:10:36 <roconnor> dolio: I don't think so, but I'm not sure.
18:10:42 <Raevel> what's a nested type?
18:11:09 <dolio> Raevel: like 'data Foo a = Foo1 | Foo2 a (Foo (a,a))'
18:11:26 <augustss_> dolio: yes, SML allows them
18:11:28 <Raevel> you can do that in sml
18:11:34 <roconnor> you can?
18:11:47 <dolio> Wouldn't they be kind of a pain without polymorphic recursion?
18:11:56 <augustss_> Very much so.
18:12:03 <MyCatVerbs> dolio: why have Foo1 in there at all? Infinite doubling tuple streams!
18:12:16 <dolio> :)
18:12:29 <Raevel> datatype aexp = Add of aexp * aexp;
18:13:01 <PetRat> Remind me what the record update syntax is? something like newRecord = oldRecord { field = newValue, field2 = newValue2 }
18:13:15 <MyCatVerbs> PetRat: you have it exactly.
18:13:18 <solrize> ; instead of ,   ?
18:13:35 <PetRat> Great.
18:13:37 <MyCatVerbs> I should check, but IIRC it's commas.
18:13:44 <solrize> k
18:13:59 <kacper_> > reverse( reverse undefined )
18:14:01 <lambdabot>   * Exception: Prelude.undefined
18:14:29 <kacper_> > reverse( reverse (1:2:undefined) )
18:14:31 <lambdabot>   * Exception: Prelude.undefined
18:14:47 <kacper_> > id (1:2:undefined)
18:14:48 <lambdabot>   [1,2* Exception: Prelude.undefined
18:15:06 <MyCatVerbs> Yep, it's commas.
18:16:16 <PetRat> Record syntax for definitions is also commas. Imagine that! Consistency!
18:17:32 <Cale> but with do/let/case...of/where, it's semicolons
18:17:58 <PetRat> do-notation is semicolons. I read the section in RWH where they say that some people call monads "programmable semicolons". I.e. in C or Java, a semicolon is a break between actions but does nothing itself. In Haskell, semicolons can be sophisticated.
18:18:26 <Baughn> That's.. one way of putting it
18:18:43 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
18:18:44 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:18:46 <MyCatVerbs> I think that makes sense, really.
18:18:47 <PetRat> Baughn: not a good way?
18:18:52 <Baughn> I'd /prefer/ saying that Monads are join, but that requires understanding functor and applicative first. ;)
18:19:17 <Cale> don't forget poor return!
18:19:21 <MyCatVerbs> If record syntax were semicolons instead of commas, you'd be able to confuse yourself by accidentally doing stupid things to them with line breaks.
18:19:23 <Baughn> PetRat: Well, it works for a provisional understanding for the simpler kinds of monads. Or as a soundbite of great evil.
18:19:25 <PetRat> I shouldn't have said monads ARE ..., but USING monads IS LIKE
18:19:29 <Baughn> Cale: pure!
18:19:43 <Cale> Oh, a monad is an applicative functor with join? :)
18:19:51 <PetRat> I'm encountering a lot of evil soundbites then.
18:19:53 <Baughn> Right. :)
18:20:39 <Baughn> PetRat: Functor has fmap (<$>). Applicative has ap (<*>) and pure/return. Monad subclasses both of those, and adds join
18:20:41 <Cale> I kind of like the return/(<=<) definition too
18:20:59 <MyCatVerbs> :t (<=<)
18:21:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:21:04 <Baughn> PetRat: ..um, I'd suggest reading the typeclassopedia if you want to /understand/ that sentence
18:21:14 <Cale> A monad is a functor m with return and (<=<) such that:
18:21:20 <Cale> 1) return <=< f = f
18:21:26 <Cale> 1) f <=< return = f
18:21:30 <Baughn> The monad laws, sure..
18:21:37 <Cale> 1) (f <=< g) <=< h = f <=< (g <=< h)
18:21:38 <vixey> :S
18:21:43 <Cale> er, 1,2,3 ;)
18:21:44 <Baughn> But those are just what's needed to make the syntax come out halfway sane
18:21:49 <MyCatVerbs> Cale: I like your number Scheme.
18:21:50 * Cale was editing lines ;)
18:21:54 <vixey> lol
18:21:54 <PetRat> Yes, typeclassopedia is on my reading list. At the moment I'm trying to get through chapter 15 of RWH but it's tough to understand. I think it needs about twice as much explanatory text. Ratio of code to explanation is too high.
18:21:55 <Baughn> They're not something you need to explicitly think about. ;)
18:22:16 <Baughn> PetRat: Right, skip over to typeclassopedia, rejoin RWH later. :)
18:22:50 <PetRat> Baughn: okey-dokey.
18:23:12 <amz> ok, functional design question... say that I want to have a list of objects (say, stuff to draw on screen). I assume that the correct way to have this is to have each "object" (sorry for the OO lingo) contain a function that details how it's drawn... but how to have each contain its own set of data, which might be completely different? Should I pass that along to each's function?
18:23:52 <Cale> amz: If all you're going to do is to draw them, then they *are* the actions to draw themselves on screen.
18:24:11 <PetRat> The ultimate goal is to UNDERSTAND, and then flexible USAGE of the language comes from that. However, one can start USING the language by imitating examples, and understanding can develop over time. Or, one can try to UNDERSTAND before writing any of one's own code. Or both simultaneously.
18:24:26 <augustss_> amz: If you have a fixed set of object that can be drawn then use a data type to define them.
18:24:34 <solrize> amz, we'd tend to use separate types for the different object classes (beware, haskell uses "class" to mean what java would call an interface)
18:24:42 <Baughn> amz: If you want something more transparent, then random data statements with a class Drawable  and instances might be good enough
18:24:44 <amz> well, no, I was thinking more along the lines of a game... so you'd have a list of entities that can be drawn (they'll return a drawing action once invoked), but they can also update themselves to the next step
18:25:07 <solrize> i.e. we'd have a function like   draw :: (Drawable t) => t -> IO ()
18:25:07 <augustss_> amz: I'd start with a data type
18:25:07 <amz> but their updating routines are completely different
18:25:14 <amz> and each has to keep its own different data
18:25:39 <amz> and I don't want to have a different list for each different type of thing
18:25:42 <augustss_> amz: You can also do it the OO way with existential types
18:25:46 <Baughn> amz: Doesn't matter how different the implementation of draw is for each type, so long as its /interface/ (draw :: Drawable a => a -> IO ()) is the same
18:26:17 <MyCatVerbs> amz: define a data type for them. You can use a sum data type that has an entry for every type of entity, or you can use existentials to imitate the OO way.
18:26:37 <Baughn> ..or you could use plain old typeclasses
18:27:18 <solrize> baughn, i see the problem, amz wants to have a list of drawables which might not all be the same type
18:27:20 <MyCatVerbs> Baughn: not if you want to pass around a [forall a. (Drawable a) => a]
18:27:39 <Baughn> Oh, but I'd probably end up defining some svg-like primitive drawing language and have "draw" convert to /that/ structure, which could then be manipulated more universally
18:28:02 <Baughn> solrize: Ah. Then existentials.. or see my last sentence
18:28:24 <solrize> baughn, right, are you saying there's a way to do it with just typeclasses and no existentials?
18:28:32 <amz> well, see, I want to be able to do something like... nextworld = map (dostep) currentworld, and later drawaction = map (draw) nextworld
18:28:34 <Baughn> draw :: Drawable a => a -> [DrawCommands]
18:28:38 <amz> ok
18:28:38 <MyCatVerbs> amz: take Breakout. You'd have something like: data Thing = Brick Brickdata | Ball Balldata | Paddle Paddledata, where Brickdata, Balldata and Paddledata are three different data structures defined elsewhere for the components.
18:28:43 <amz> I'll look into that existentials thing
18:28:50 <Baughn> scale :: DrawCommand -> Double -> DrawCommand, etc. Whatever.
18:29:01 <amz> MyCatVerbs: I'm not sure if I like having to declare all of them together
18:29:19 <Baughn> solrize: Sure, by reworking your design to not need multiple /different/ types in one list
18:29:22 <Cale> You can also do the existential thing by hand
18:29:25 <Baughn> solrize: Eg. by doing what I just suggested
18:29:26 <MyCatVerbs> amz: the only real downside of doing it that way is that it's not extensible.
18:29:34 <Cale> In this case, it's not hard to come up with an appropriate type...
18:29:37 <amz> yes, that's my worry
18:29:38 <Cale> Specifically...
18:29:48 <MyCatVerbs> i.e. you can't add extra things without altering the definition of Thing.
18:29:52 <Baughn> solrize: If you do use existentials, and the only thing you can do with them is to draw them, it seems pointless to not just have a list of whatever draw returns instead
18:30:02 <Baughn> Of course, Drawable might have more functions, but still..
18:30:07 <MyCatVerbs> You could, on the other hand, come up with something more like:
18:31:00 <Cale> (sorry, had to let cat out)
18:31:02 <amz> I think drawing was a bad example... the "update" part is what I really worry about. For example, using Breakout... I have a list of Things containing the Paddle, the Ball, and a bunch of bricks
18:31:06 <MyCatVerbs> class Entity e where { drawme :: e -> Shape, tickFunc :: e -> e, ... }
18:31:09 <amz> then I map the "update" function over that list to get the next step
18:31:14 <solrize> baughn, i don't get it, you've got a bunch of different stuff on the screen, why isn't it natural to put all that stuff in a list?
18:31:17 <MyCatVerbs> And then data Paddle = ..., instance Entity Paddle where...
18:31:37 <MyCatVerbs> Cale: I'm still here, :D
18:31:39 <amz> but how will "update" access e.g. the velocity data that only the ball has?
18:31:46 <solrize> and if you use an existential, how does the "draw" function know what it's drawing?
18:31:46 <amz> (ok, paddle does too, but bricks don't)
18:31:51 <Cale> data GameObject = GObj { next :: Stuff -> GameObject; draw :: IO () }
18:32:12 <Baughn> solrize: Because most of the time, you want a /tree/ of drawables, not a list
18:32:12 <Cale> Where Stuff is whatever appropriate parameters you want, maybe the World
18:32:26 <Baughn> solrize: A window containing widgets containing..
18:32:27 <Cale> actually, you probably need a little more than this
18:32:42 <Cale> Because the game objects have to be able to interact with each other
18:32:44 <Baughn> solrize: Okay, you probably want open implementation for the widgets, in which case existentials do make sense
18:32:50 <solrize> baughn, same issue, the drawables in the tree can be of different types
18:32:52 <solrize> yeah
18:33:03 <Baughn> solrize: However, if your class Drawable has only one method, then there's no point in using them. So obviously it has to have more
18:33:06 <amz> interaction could be handled by having them return a list of messages on update
18:33:08 <solrize> but, once something is existentially quantified, the type system loses track of what it is, right?
18:33:13 <Baughn> But the only thing amz has suggested wanting to do is draw them
18:33:13 <amz> which would be fed to the proper objects on the next step
18:33:16 <Baughn> solrize: Yes
18:33:26 <MyCatVerbs> amz: the typeclass way to do it is to have update be a typeclass member. The Paddle has its own definition of update, the Ball has another, the Blocks have another again...
18:33:34 <Cale> amz: But does that recursive thing make sense?
18:33:36 <Baughn> solrize: ..well, you could always use Dynamic or some such..
18:33:48 <solrize> ugh!!!  :)
18:33:53 <Cale> amz: Basically, the key is that records can contain functions which produce other records of the same type.
18:33:56 <amz> MyCatVerbs: right, but then I couldn't map update over a list of those different types, right?
18:34:27 <Cale> amz: Functions are extremely flexible in the data which they can involve in their definitions.
18:34:44 <MyCatVerbs> amz: you could if you used an existential.
18:35:02 <amz> something tells me that I'll really have to look into what are existentials :)
18:35:02 <solrize> mycatverbs how does that work??  i think i am missing something
18:35:14 <Cale> You don't necessarily need an existential
18:35:20 <solrize> amz, existentials are a special case of gadt's so you may as well read about those instead
18:35:29 <Cale> I think it's easier to grasp the normal functional programming solution.
18:35:43 <solrize> i think the traditional way would be to use a sum type
18:35:51 <Cale> Recursive types!
18:35:53 <solrize> which means you have to declare all the sub-cases in one place
18:36:01 <Cale> No, you shouldn't have to.
18:36:12 <amz> well, Cale, for example... if I have a typeclass that defines "update :: a -> a", then I have a list of [myPaddle, myBall, brick1, brick2] :: [Things], and I "map (update) myList", I can't see how would update work
18:36:44 <Cale> amz: Each game object consists of its own update function.
18:36:44 <MyCatVerbs> solrize: map (update :: forall a. (Updateable a) => a -> a) $ (list :: [forall a. (Updateable a) => a] -- AFAIK actually works? ;P
18:36:51 <Cale> amz: (along with whatever else you need)
18:37:41 <Cale> amz: So to do the update, you just take each object, get out the update function and call it with whatever parameters are needed for it to generally do its work.
18:37:42 <solrize> right, but the idea is you want a different update method for each type!!!   you need something like generics
18:38:02 <Cale> solrize: Yeah, but you can have functions which produce objects of a given type this way, just fine.
18:38:24 <Cale> As far as the type system is concerned, it's all the same type.
18:38:29 <amz> Cale: well, one of the "parameters" is the object in its true type... so each object's update function would have to have a (curried?) parameter pointing at itself so it knows what to work with?
18:38:33 <Cale> The differences are in how the update function is written.
18:38:34 <Baughn> solrize: The function that does the updates would have to have separate code for each type, then
18:38:44 <Baughn> solrize: In which case you might as well use an ADT
18:38:55 <amz> Baughn: well, that's fine, as long as I can declare them independent of each other
18:39:01 <amz> *independently
18:39:07 <Cale> amz: Actually, could you elaborate on what sort of game this is?
18:39:18 <solrize> baughn, i mean the (update:: forall a. ...) scheme wouldn't be able to do something differently depending on a
18:39:24 <Cale> amz: Just so I can be a little more concrete and complete about this.
18:39:28 <Baughn> solrize: Exactly
18:39:41 <amz> Cale: eh, it's not any game in particular (actually, I was thinking of doing a space invaders or something as a proof of concept)... I've been writing games in C++ for many years, trying to get my brain to work in Haskell now
18:39:44 <Cale> There's no need for fancy type system features like existentials here, I think.
18:39:48 <solrize> and if you use an ADT, then you have to have a single definition for it that enumerates all the cases
18:40:08 <solrize> and if you do what cale says, it's sort of like writing in lisp :)
18:40:21 <Baughn> Sure, but if you have a single update function for every type, then that function has to have a mention of each type anyway
18:40:22 <Cale> Okay, let's try space invaders then. Each object needs: A way to draw it, a way to update it physically, and a way to determine if it intersects a given region of space.
18:40:34 <amz> forget the collision stuff
18:40:37 <amz> I'd rather handle that outside it
18:40:48 <amz> let's just focus on individual objects with no concept of each other
18:40:48 <Cale> Well, I'll leave it in for now, but very abstractly.
18:40:56 <Cale> I'm not going to write the collision code ;)
18:41:01 <amz> right ;)
18:41:07 <Cale> So...
18:41:24 <amz> so, what I WANTED to do is have a function that takes all objects in the world and returns a tuple of two lists
18:41:31 <amz> the first list is what the world looks after the update
18:41:40 <amz> and the second tuple is a list of messages that objects are sending to each other
18:41:45 <amz> that will be processed before the next update
18:41:48 <Cale> data Object = Obj { draw :: IO (); update :: Object; intersects :: Region -> Bool }
18:41:58 <Cale> How does that look to you?
18:42:22 <amz> sure, that looks right, if it works ;)
18:42:26 <Cale> Possibly, we will want the update to take a list of the other objects.
18:42:54 <Cale> So, let's write one of these...
18:43:01 <solrize> interesects doesn't care where the object is?
18:43:02 <amz> possibly, yes, but most of the need for that is for collision handling (at least, on this sort of game)
18:43:08 <amz> which I'd handle outside the main update
18:43:14 <amz> and send appropriate messages
18:44:22 <Cale> rocket pos vel acc = Obj { draw = do ... ; update = rocket (pos + vel) (vel + acc) acc; intersects = \region -> ... }
18:45:19 <Cale> that should probably be ^+^ ;)
18:45:22 <amz> hrmm
18:45:23 <amz> I see
18:45:27 <Cale> (vector addition)
18:45:36 <Cale> and inside draw and intersects, we have access to pos
18:45:53 <Cale> (and vel, if we want)
18:45:55 <amz> I didn't even know that syntax existed
18:45:58 <korpios> (new to haskell here) If anyone is familiar with Network.Socket, why would I be getting an error "setSocketOption: invalid argument (Invalid argument)" from "setSocketOption someSocket NoDelay 1"?
18:46:14 <Cale> amz: it's just the usual record syntax
18:46:31 <Cale> amz: It's like normal algebraic datatypes, but with named fields
18:46:34 <amz> I mean, I didn't know that functions declared inside the record could form a closure with the object's constructor's parameters
18:46:38 <amz> [am I even using the right terms?]
18:46:50 <Lemonator> is there an equivalent to mapM_ for Data.Map ?
18:46:57 <Cale> Well, functions always capture the values of variables in the place that they're defined
18:47:00 <amz> years of OOP have hardened my brain
18:47:08 <Baughn> korpios: What OS would that be on?
18:47:14 <Baughn> korpios: And a TCP or UDP socket?
18:47:15 <korpios> Baughn: OS X
18:47:18 <Cale> (as do all sorts of other data)
18:47:20 <sooth> Anyone familiar with Language.C?
18:47:21 <solrize> (mapM_ . Data.toList) ?
18:47:33 <Cale> (like the IO action here, and other datastructures)
18:47:47 <solrize> lemonator, (mapM_ . Data.Map.toList) i mean?
18:47:56 <Baughn> korpios: TCP, UDP, what?
18:48:01 <Lemonator> well, I'm using that right now,
18:48:05 <Lemonator> but it seems inefficient.
18:48:35 <solrize> inefficient?  you have to traverse the map no matter what you do...
18:48:39 <korpios> Baughn: I think it's TCP; trying to debug this: http://hackage.haskell.org/packages/archive/haskell-tyrant/0.2/doc/html/src/Database-TokyoTyrant.html#openConnection
18:49:00 <Lemonator> but with that, I'm traversing it twice.
18:49:10 <Lemonator> once to construct the list, and then again to map the function
18:49:27 <korpios> tracked it down to that function, but not making much headway past that
18:49:54 <Cale> Existentials would do a very similar thing here, but they extend to somewhat more complicated situations perhaps a bit more smoothly, and give you a more concrete way to represent the extra bunch of data which the methods are using. I can show you how that would look if you want. I don't think it's really much better than this way for any of the situations which would occur in a game.
18:49:58 <amz> would this work? makerocket pos = let a = Obj { draw = drawrocket a; update = updaterocket a; } in a
18:50:28 <vixey> amz:  makeRocket,  drawRocket etc
18:50:28 <Cale> let a = x in a  is always the same as x
18:50:43 <amz> I thought Haskell didn't use camel case? o_o
18:50:53 <Cale> It does, by convention
18:50:55 <amz> Cale: yes, but I'm passing that same "a" to the functions
18:50:56 <Cale> :t putStrLn
18:50:57 <lambdabot> String -> IO ()
18:50:59 <amz> is that valid?
18:51:00 <Cale> amz: oh, right.
18:51:00 <amz> oh
18:51:00 <amz> right
18:51:01 <amz> duh
18:51:04 <Cale> amz: Yes, it works.
18:51:04 <vixey> amz: anyway that can't work because you didn't use pos
18:51:26 <amz> er, yes, hrm
18:51:32 <Cale> amz: But yeah, you need to pass the initial parameters in :)
18:51:38 <Baughn> korpios: Well, try sticking a trace on it. The only way that should fail like that is if it's actually asking for a non-tcp socket.
18:51:47 <Cale> amz: Basically, you can separate the working bits into a where clause nicely.
18:52:02 <Baughn> korpios: Or, given that it's in IO already, just print the family, etc.
18:52:15 <korpios> Baughn: I should've just pasted exactly what I'm trying: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4975
18:52:30 <Cale> rocket pos vel acc = Obj { draw = drawRocket; update = updateRocket }
18:52:37 <Cale>   where drawRocket = do ...
18:52:51 <Cale>         updateRocket = ...
18:53:14 <Cale> That way, you'll have access to the parameters which rocket was called with, so you can make the recursive call easily.
18:53:23 <amz> hrm
18:53:25 <amz> I see, that makes sense
18:53:50 <Cale> But for testing, it possibly makes sense to add parameters to those things, and separate them from the where.
18:54:03 <Cale> I'm not sure which I'd like better :)
18:54:35 <Baughn> korpios: Nope, can't say I get it. strace'd probably be useful, but..
18:54:39 * Baughn goes to sleep
18:54:44 <amz> well
18:54:46 <amz> thanks everyone
18:54:49 <amz> I'll give this a try later
18:54:53 <Cale> great :)
18:54:58 <Cale> Let us know how it goes
18:55:30 <amz> If I can't get my brain around how to make a game in Haskell elegantly, I'll grow up to be a depressed old man
18:55:37 <amz> because after tasting Haskell, C++ looks so... ugly
18:55:42 <amz> and so does Java
18:55:47 <Cale> The nice thing about this way is you get basically all the usual convenience of objects, as long as you can decide what your interface looks like.
18:56:52 <Cale> However, it does make adding new operations into a chore, because you have to update each of these object-creating functions.
18:57:01 <Cale> (but that's the same as in OO)
18:58:29 <solrize> well, in OO you'd make subclasses
18:59:10 <solrize> amz someone wrote a first person shooter in haskell...
18:59:21 <Saizan> yeah, but if you have a bunch of subclasses and you add a method to the main class you need to modify all of them to add it
18:59:48 <Saizan> in constrast, if you have an ADT and you want to add a function you just write it
18:59:54 <amz> solrize: yes, I've heard, but I haven't looked at the source to see if it was done in a sane way :)
19:00:04 <amz> no point in using Haskell if it were to make the job harder
19:00:36 <solrize> saizan, you only have to modify the subclasses when they can't inherit
19:03:04 <Cale> Oh, another suggestion, for a 2D game, complex numbers are the way to go for coordinates.
19:04:00 <Cale> You get the vector operations trivially (addition, scalar multiply), and then by multiplying by exp(0:+theta), you get rotation for free as well.
19:04:46 <Cale> > exp (0:+pi/4)
19:04:47 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
19:04:51 <monochrom> "expression problem"
19:05:01 <Cale> > exp (0:+pi/4) * (3 :+ 4)
19:05:01 <solrize> for 3D you can use quaternions the same way
19:05:02 <lambdabot>   (-0.707106781186547) :+ 4.949747468305833
19:05:27 <Cale> solrize: yeah :)
19:05:49 <Cale> (more or less -- it's not quite as beautiful, but nearly so)
19:08:10 <amz> Cale: in my experience, you almost never need real rotation in 2D games, anyway
19:08:31 <amz> what I usually do is just rotate a normalized vector, and scale that by the force I'm applying
19:08:40 <amz> and, from that point on, no more rotations are involved
19:08:51 <amz> [except graphically, which is handled by gl/d3d]
19:10:14 <Cale> amz: Yeah, but the exp function is so convenient :)
19:11:12 <Cale> amz: For an asteroids-style game I'd expect it's pretty important to rotate things easily too...
19:11:47 <amz> well, if the asteroids are represented as actual polygons, logics-wise, yes
19:11:48 <Cale> (if left/right keys turn the player's ship, and you have lots of spinning asteroid objects :)
19:12:04 <amz> but the player's ship falls under the case I mentioned
19:12:10 <amz> you just thrust in the direction you're facing
19:12:17 <amz> after that, you don't need to worry about rotations anymore
19:12:20 <Cale> What about the geometry for the player's ship though?
19:12:29 <amz> I'd represent it as a circle ;)
19:12:33 <Cale> ah, hehe
19:12:56 <amz> one thing that I learned from japanese "maniac shooters" is that having a small collision area on player's "ship" is a good idea
19:13:06 <amz> it's usually a small circle on its center
19:13:25 <amz> it lets you have more bullets on the screen without making the game impossibly hard
19:14:00 <amz> extreme example: http://upload.wikimedia.org/wikipedia/en/2/24/PCByukari140.jpg
19:14:16 <Cale> But if the controls are such that you have keys to turn and then a thruster, like the original asteroids, you'd definitely want to draw something which isn't rotationally symmetric
19:14:27 <mauke> not nearly enough objects :-)
19:14:51 <amz> Cale: ah, yes, but I'd just draw it facing right and use glRotate() to take care of the rest ;)
19:15:55 <Cale> I suppose that is quite doable.
19:17:04 <amz> heh, funny... now that I linked to that pic, I was looking the attack pattern on youtube, and noticed that several of the other attack patterns would be constructed with quite a lot of rotation
19:17:06 <amz> so I stand corrected
19:18:38 <Cale> rRootage is a good free game of that sort :)
19:19:14 <amz> what sort?
19:23:33 <Cale> Japanese style shooter
19:23:42 <Cale> With lots of objects :)
19:23:46 <amz> :D
19:23:48 * amz looks into it
19:24:39 <amz> hah, they invented a language to describe the bullet patterns
19:25:10 <ajdhs> is there a way to generate the tested values based on the failure value of a QuickCheck test?
19:25:27 <ajdhs> (besides copying and pasting the printed value?)
19:26:14 <roconnor> @check \x -> x == 0
19:26:15 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
19:26:34 <roconnor> 1
19:26:52 <Asztal> @check \x y -> x == y
19:26:52 * roconnor cut and paste
19:26:53 <lambdabot>   "OK, passed 500 tests."
19:27:00 <ajdhs> yeah
19:27:10 <Cale> amz: And a genetic programming tool for creating patterns
19:27:33 <ajdhs> but suppose it was a more complicated expression
19:27:52 <ajdhs> and it was infeasible to cut and past it
19:27:56 <Saizan> ajdhs: use QuickCheck-2
19:28:00 <ajdhs> I have that
19:28:21 <ajdhs> but I can't figure out how to get the failed values out of it
19:29:13 <ajdhs> for example
19:29:15 <ajdhs> if I have
19:29:37 <ajdhs> @check \x y -> sum x > 100000
19:29:38 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n()\n"
19:29:45 <ajdhs> @check \x y -> sum x < 100000
19:29:46 <lambdabot>   "OK, passed 500 tests."
19:29:51 <ajdhs> @check \x y -> sum x < 100
19:29:52 <lambdabot>   "Falsifiable, after 76 tests:\n[-22,6,6,34,17,18,16,26,25,10,10,-16,14,-29,...
19:29:55 <ajdhs> @check \x y -> sum x < 1000
19:29:56 <lambdabot>   "Falsifiable, after 298 tests:\n[124,27,-27,-27,100,-128,-97,72,-115,92,-45...
19:30:04 <ajdhs> then that's a really long list to copy back in
19:30:11 <ajdhs> also, in my case, it's really a Data.Map.Map
19:30:18 <ajdhs> with lots of quotation marks and stuff
19:30:23 <ajdhs> so it's a pain to copy and paste...
19:31:46 <Saizan> you can put it in a file and use read
19:33:17 <ajdhs> hm
19:33:18 <ajdhs> yeah
19:33:24 <ajdhs> I guess that's what I'll have to do
19:34:46 <Gracenotes> hm. I have a monad that's like the state monad, but is actually a ReaderT IO that use an MVar for get and put. Is there a good way to start a thread that needs the MVar immediately, but also somehow put its ID into the MVar?
19:35:04 <Gracenotes> using a (Maybe ThreadId) would take care of this, but it seems a bit hacky
19:35:26 <Gracenotes> hm... mdo perhaps would be a good way. Seems a bit much though.
19:35:41 <hydo> What is the general method for uninstalling a cabal package?  I can't believe that everyone deletes ~/.ghc and ~/.cabal when things get really borked up.
19:35:55 <bd_> Gracenotes: You could just put the threadid in the mvar after it starts. If it tries to take the mvar it'll just block.
19:36:32 <roconnor> mdo is always a good way. :)
19:36:35 <mauke> hydo: unregister it, then rm the library files
19:36:50 <hydo> unregister with ghc-pkg, correct?
19:36:54 <Gracenotes> oh, hm, that's right. The issue is that the MVar access is not direct, but through get and put.
19:37:25 <Gracenotes> (get using readMVar)
19:38:16 <Saizan> Gracenotes: forkR action = do var <- ask; id <- forkIO (runReaderT action var); put id
19:38:39 <Gracenotes> Saizan: I already have a function that does that
19:39:03 <Saizan> what's the problem with it?
19:39:06 <Gracenotes> in fact, it's a typeclass, MonadFork, with fork :: m () -> m ThreadId
19:39:37 <Saizan> then, \m -> id <- fork m; put id
19:39:47 <Gracenotes> the issue is not starting the new thread, but rather putting the ThreadId into the MVar, when the ThreadId is not the only member of the MVar
19:40:12 <Gracenotes> and other members of the MVar are needed immediately by the new threade
19:40:13 <Gracenotes> -e
19:40:29 <Saizan> oh, that's different
19:40:43 <Saizan> i'd use a tuple of MVars probably
19:40:47 <Gracenotes> I suppose I could have a half-second pause in the new thread. A bit suspect, though.
19:41:29 <Gracenotes> hm. Or, having an MVar in the MVar
19:42:00 <Gracenotes> or, as I said, a Maybe ThreadId.
19:42:58 <Saizan> or mdo and pass the id as an argument
19:43:08 <Gracenotes> argh. When you design something to be extensible, the lack of extensibility reveals itself to you the quickest
19:43:57 <Saizan> heh, maybe you want to use something like lenses
19:43:57 <roconnor> mfix (\id -> newMVar id >>= \var -> forkIO (runReaderT action var))
19:44:47 <Gracenotes> roconnor: I'd use mdo. In fact I've already written something up using mdo. But there should be a better way...
19:44:57 <roconnor> why should there be a better way?
19:45:38 <Gracenotes> well, it's an IRC framework I've been working on-and-off about. If the user needs mdo to make it work... well... that's not a good start.
19:46:51 <Gracenotes> then again it is also a general problem, of having all the data related to a game include the thread id, which is necessary for externally shutting it down
19:47:02 <roconnor> Gracenotes: mfix plays a central roll in Oleg's object oriented framework
19:47:12 <roconnor> you shouldn't fear it
19:48:29 <Elly> hm, oleg has an OO framework?
19:48:42 <Gracenotes> then... there's central role vs. hack to get around flaws in design. I'll play around with it a bit more.
19:48:51 <roconnor> forkIO (myThreadId >>= newMVar >>= (runReaderT action)
19:48:56 <roconnor> )
19:51:38 <Gracenotes> in Java, it would be possible for the game to extend the Thread object. here it exists as a separate data object. Things couple differently in different languages, of course :)
19:52:57 <roconnor> Gracenotes: what's wrong with using myTreadId to get the ThreadId at the beginning when the MVar is initiated?
19:55:49 <Gracenotes> the thread id is not the only thing in the MVar. But, myThreadId would at least work, and I don't think any race conditions would result (although certainly possible). Keeping in mind that this isn't in IO, but a MonadIO, so just lifting would be needed.
19:56:15 <Gracenotes> at least the race condition wouldn't happen in the game thread
19:57:47 <roconnor> hmm, I guess I don't understand what you are doing.
19:59:34 <Gracenotes> monad transformer stacks can do that to people
20:01:46 <Gracenotes> the idea of the startGame function is, given some information available to configure a game, do the configuration (reading from files and sucih), store that in the Game data object (which includes score-keeping maps and game data) and start the thread that does the game
20:02:27 <Gracenotes> the issue is that the function calling startGame will need access to the thread id, in order to kill it if requested (i.e. !stop)
20:03:28 <Gracenotes> hm... I suppose I don't have to store the thread ID in the Game object... but keeping track of it is its own issue
20:04:07 <Elly> is oleg just like... a professional bad person?
20:04:20 <Gracenotes> >_>
20:05:24 <monochrom> oleg is a professional good person
20:06:20 <SamB> Elly: http://arcanux.org/lambdacats_3.html#entry4 <- you mean this oleg ?
20:06:45 <Elly> monochrom: Oleg is the mirror that shows a normal person that they are stupid :P
20:06:53 <Elly> SamB: probably :P
20:07:06 <Gracenotes> ooh. there is a third lambdacats page?
20:07:30 <SamB> Gracenotes: the new cats will be on the first one
20:07:36 <Gracenotes> yes
20:07:58 <Gracenotes> oh, and there are yet older ones
20:08:25 <SamB> I do wish that site had permalinks, though :-(
20:11:43 <jinjing> @seen snoyman
20:11:43 <lambdabot> I haven't seen snoyman.
20:14:28 <Elly> hmm
20:14:37 <Elly> I need a big project to do this summer in either haskell or scheme
20:14:42 <Elly> I don't know either of those languages well enough
20:15:17 <SamB> Elly: why do you need a big project ?
20:15:25 <hatds> (obvious comment about the "write yourself a scheme implementation" haskell tutorial)
20:15:38 <Elly> SamB: I don't have time for them during the school year
20:15:57 * SamB wonders how Elly manages not to get tons of chores in the summer
20:16:09 <Elly> I have a job :P
20:16:31 <Elly> I don't live with my parents, so there's nobody to hand me chores
20:17:33 <hydo> Ugh, I know I've read about it probably 10 times, but I can't remember and I'm not finding much on google.... what does the ! signify in "data DeliciousState = DeliciousState ![D.Post] !UTCTime"
20:18:13 <monochrom> http://www.vex.net/~trebla/haskell/strict-field.xhtml
20:18:36 <hydo> monochrom: awesome, thank you!
20:18:50 <hydo> bookmarked for the next time my brain takes a vacation on me. ;)
20:21:52 <Elly> hm
20:21:58 <Elly> I could do the write-yourself-a-scheme one
20:22:01 <Elly> that might be fun :)
20:23:42 <monochrom> write yourself a résumé that says you know haskell and you are done with all the profitable languages and tools and paradigms and agile whatever.
20:24:56 <Elly> the only language I feel comfortable saying I understand deeply is C :\
20:25:38 <monochrom> You mean you know how to evalute 2["heya"] ?
20:28:14 <Elly> I do, in fact, know what that does
20:28:19 <Elly> it's 'y'
20:28:33 <SamB> or that it's okay to say sizeof (struct { int foo; int bar; }) ?
20:28:50 <Elly> I know that sizeof does not necessarily evaluate any part of its argument, yes
20:29:03 <Elly> I also know about sizeof(*(int*)NULL)
20:29:12 * SamB tried to look it up when someone asked that in ##c the other day ...
20:29:38 <Elly> that sizeof you gave has to work, since 'struct { ... }' is a valid type specifier
20:30:08 <Elly> in any case
20:30:16 <Elly> C is the only language I feel like I understand to that extent
20:30:21 <Elly> I want to understand a better language that well :P
20:30:33 <hatds> learn Haskell
20:30:46 <Elly> that's why I was asking for something big to do in haskell before
20:30:55 <monochrom> Whatever method you used to know C so well, use the same method on the better language.
20:31:12 <Elly> the method I used to learn C was having to write a lot of stuff in C for classes and for work
20:32:27 <monochrom> Hmm how did you know 2["heya"]? I imagine not from any project you did. Few people write it, and you wouldn't conceive it yourself --- I mean very unlikely.
20:32:43 <Elly> oh, that I think I know from K&R
20:32:48 <Elly> which I basically inhaled at one point
20:32:54 <solrize> i think it is well known and obvious from the definition of []
20:33:04 <Elly> it's straightforward when you know that a[b] is a + b
20:33:31 <hatds> you should be inhaling everything out there about haskell
20:33:44 <hatds> that's what I did 24/7 for like a month in the fall
20:33:45 <monochrom> OK, then that means to duplicate the same level of knowing Haskell, you should inhale the Haskell98 Report too.
20:33:48 <Elly> hm
20:34:12 * rzezeski is slowly nibbling on RWH, taking copious amounts of notes
20:34:31 <hatds> the haskell report is a breeze compared to C gotchas imho
20:34:44 <monochrom> Indeed I inhaled some part of it, and so I can tell you with 100% certainty what "newtype" means and what it doesn't mean.
20:34:57 <hatds> but you can't just learn the gotchas for haskell to really be feel like you understand it
20:36:08 <monochrom> I also inhaled some of Bird's "introduction to functional programming using haskell, 2ed" and so I know the foldl vs foldl' business.
20:36:31 <Elly> hm
20:36:36 <Elly> so Haskell 98, it seems
20:36:46 <hatds> there so many papers to read too if you are into type system stuff
20:36:48 <monochrom> (P.S. If you what to know, kfish's 東京 means Tokyo.)
20:36:59 <Elly> I am, in fact, into type system stuff :)
20:37:13 <Elly> I learned intuitionistic logic a little while ago and I rather like it
20:37:56 <hatds> how much do you feel you know about haskell?
20:38:23 <Elly> not a lot
20:38:29 <Elly> I know SML far better than I know Haskell
20:39:47 <hatds> are you past the tutorial stage or not yet?
20:40:18 <Elly> well
20:40:40 <Elly> I understand recursion and things like fold quite well, I think
20:40:50 <Elly> I have never seriously tried to grasp monads
20:41:08 <hatds> do you grasp IO?
20:41:37 <Elly> I understand monads as sequencers for explicit effects
20:41:50 <Elly> (we had that presented as an application of lax modalities in intuitionistic logic)
20:42:15 <solrize> do you understand how the State monad works?
20:42:19 <hatds> can you write a simple haskell program asking for input in the form of text and numbers and outputing back some strings?
20:42:39 <Elly> I could if I looked at the reference manual, I think
20:42:51 <hatds> you need to do it I think
20:43:00 <Elly> solrize: I understand the concept of passing a "heap" object and of the monad concealing that from you
20:43:09 <Elly> solrize: but that is the extent of my understanding of State
20:43:27 <pao> what's the preferred way to provide Word8 literals?
20:43:46 <dolio> > 15 :: Word8
20:43:47 <lambdabot>   15
20:44:04 <pao> > fromEnum '\n' :: Word8
20:44:05 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Int'
20:44:15 <solrize> elly the idea of State is that the actions in it are just a bunch of nested function calls
20:44:29 <Elly> yeah; I think I understand the monads-as-CPS-transformers concept
20:44:30 <pao> dolio: what if I wanted to "convert" a Char?
20:44:50 <monochrom> > fromIntegral (fromEnum '\n') :: Word8
20:44:52 <lambdabot>   10
20:45:00 <hatds> well my opinion is this:  you need to do basic "write this" tutorials that get you down and dirty with the syntax and type system.
20:45:01 <pao> monochrom: thanks
20:45:05 <Elly> hatds: alright
20:45:10 <monochrom> fromIntegral is your all-purpose number converter.
20:45:20 * Elly goes off to write a program to take a string and print its length
20:45:25 <solrize> > fromEnum '\n'
20:45:26 <lambdabot>   10
20:45:35 <solrize> > :t fromEnum '\n'
20:45:36 <lambdabot>   <no location info>: parse error on input `:'
20:45:40 <monochrom> fromEnum gives you Int
20:45:58 <pao> monochrom: ... and with realToFract the toolbox is ready ... :-)
20:46:04 <mauke> main = interact (unlines . map (show . length) . lines)
20:49:27 <soiamso> Char in ghc is a unicode char? Word8 safe?
20:49:44 <monochrom> unicode. 8 bits are not enough.
20:52:06 <Gracenotes> however, Word8 does equal C's unsigned char, at least on my machine >_>
20:52:15 <Gracenotes> (32-bit)
20:53:13 <mauke> you have 32-bit chars?
20:54:04 <Gracenotes> I mean, 32-bit x86
20:54:07 <monochrom> No, he means he has 8-bit chars. The "(32-bit)" is about the computer not C.
20:54:39 <SamB> x86_32, I think they call it these days ...
20:54:55 <SamB> (in Linux sources, if nowhere else!)
20:55:33 <Gracenotes> perhaps only to distinguish between it and x86-64, I guess
20:56:08 <SamB> well, they used to call it i386, I think
20:56:20 <Saizan> Word8 is a pointer to a closure, anyhow
20:56:23 <SamB> but then they merged it with the x86_64 code into one x86/ tree
20:57:06 <Elly> that was surprisingly difficult to get right
20:57:11 <Elly> and it is not as short as it ought to be
20:57:20 <SamB> I know this because I'm in the process of documenting vm86(2)
20:57:29 <Elly> SamB: my sympathies
20:57:47 <Elly> that syscall and modify_ldt(2) both worry me deeply :P
20:57:48 <SamB> you know something about vm86(2) ?
20:58:27 <Elly> not in particular, but you're documenting a part of the linux kernel that touches something x86-specific
20:58:44 <SamB> modify_ldt seems to be documented in much closer to the appropriate depth, as far as I can see
20:58:54 <SamB> I mean, it's a much simpler call
20:59:06 <Elly> they document two of the four legal values for func, at least :)
21:00:12 <SamB> modify_ldt can work on x86_64 without crazy hacks, too, right?
21:00:51 <Elly> um... I don't think it's necessary on x86_64, since most of the segments no longer exist
21:00:56 <Elly> maybe it still is though
21:01:16 <Elly> I know what modify_ldt does, but not the reason why it does it :P
21:02:55 <jesmon> I'm trying to build package containers-0.2.0.1 (which is a dependency of yi-0.6) and it's failing because it can't find the module Data.Data
21:03:07 <jesmon> but that module does seem to be on my system
21:03:33 <Elly> is there a shorter way to write the following:
21:03:34 <Saizan> jesmon: you need a more recent ghc
21:03:43 <Elly> main = do x <- getLine; y <- return $ length x; putStrLn $ show y
21:04:01 <jesmon> more recent than 6.10.1?
21:04:45 <monochrom> main = do x<-getLine; let {y=length x}; putStrLn (show y)
21:04:51 <monochrom> err
21:04:56 <monochrom> main = do x<-getLine; let {y=length x}; print y
21:05:07 <Elly> what's the let { ... } syntax?
21:05:09 <Saizan> jesmon: ah, no
21:05:21 <monochrom> If you use indentation, you will not need { }
21:05:23 <Saizan> jesmon: then you've to pass --constraint="base >= 4"
21:05:36 * Saizan sighs
21:05:42 <Elly> monochrom: why does the let make the return unnecessary?
21:05:43 <jesmon> Saizan: I'll give it a try
21:05:54 <Saizan> the core packages are the ones with more buggy .cabal files out there
21:06:14 <SamB> Elly: last I got was: <Elly> maybe it still is though
21:06:43 <SamB> then my mobo zonked out or something and the computer was rebooting ...
21:06:50 * SamB really needs to get that fixed :-(
21:07:02 <Elly> SamB: I just said "I know what modify_ldt does but not why it exists"
21:07:02 <hatds> Elly: you've heard of the explanation that IO (a)  behaves like World -> (World,a)  ?
21:07:15 <monochrom> The do-notation supports "let".
21:07:15 <Elly> hatds: yes, I am familiar with that idea
21:07:19 <jesmon> Saizan: I got the same error, which is:
21:07:42 <SamB> Elly: oh, DOSEMU uses it to emulate protected mode, and WINE to run 16-bit programs
21:07:46 <jesmon> "Could not find module `Data.Data': it is a member of package base, which is hidden"
21:07:49 <hatds> Elly: then the answer you want is essentially how do notation desugars into >>= and return
21:07:51 <SamB> (also in protected mode)
21:08:05 <Elly> hatds: sure, that would be good to know :)
21:08:28 <SamB> Elly: well, truly it doesn't emulate protected mode, but just implements DPMI in a somewhat-unfriendly environment
21:08:48 <Elly> x86 is by definition an unfriendly environment :)
21:09:04 <SamB> I meant that it doesn't get to *touch* the IDT
21:09:16 * Elly nods
21:09:23 <Saizan> jesmon: ok, unpack the package with cabal unpack, edit the .cabal file putting "base >= 4" in build-depends, and then run "cabal install" from there
21:09:29 <hatds> Elly: http://www.haskell.org/tutorial/index.html  under monads explains the desugar
21:10:41 <SamB> Elly: and I think they can both do that on an x86_64 kernel just as well as on an x86_32 kernel -- not sure about either of them in a 64-bit userspace ...
21:11:14 <Elly> thanks, hatds
21:13:31 <jesmon> thanks, Saizan, the build succeeded :)
21:16:09 <Saizan> jesmon: the reason is that cabal defaults to base-3 because many packages don't have an upper bound
21:16:23 <Saizan> on base, in their build-depends
21:16:43 <Saizan> but that works only if packages requiring base-4 have a lower bound
21:16:56 * Saizan badly wants a typechecker for packages
21:17:24 <jesmon> hmm.. I'm having another problem, this time with building unix-2.3.2.0
21:17:42 <Saizan> unix-2.3.2 requires base-4.1 iirc
21:17:47 <Saizan> and that comes with 6.10.2
21:18:10 <jesmon> looks like I need to upgrade then
21:18:25 <jesmon> the error is: Module `GHC.Conc' does not export `Signal'
21:18:31 <Saizan> yup
21:18:53 <Saizan> yi explicitly depends on 2.3.2?
21:19:16 <jesmon> looks like it to me...
21:19:47 <Saizan> the cabal file doesn't specify a version
21:20:15 <Saizan> btw, unix usually comes with ghc
21:20:52 <Saizan> it doesn't have a version for containers either
21:20:57 <Saizan> how are you isntalling yi?
21:21:04 <jesmon> with cabal
21:21:19 <Saizan> "cabal install yi"?
21:21:43 <jesmon> cabal upgrade yi (from 0.5.2)
21:22:19 <Saizan> ah! that's your problem
21:22:24 <Saizan> use install
21:22:42 <Saizan> upgrade tries to install the latest version of all the dependencies too
21:23:03 <Saizan> which would work in a perfect world.. (discarding the ones you can't install on your system)
21:23:16 <Saizan> but not in this one yet :)
21:24:32 <Asztal> upgrade :: PerfectWorld -> (a, PerfectWorld)?
21:24:54 <SamB_XP> Asztal: well, it would also sometimes work in imperfect worlds
21:25:51 <deech> Hi all, I am trying to install the latest version of Haxml using cabal. cabal list the latest version as 1.19.7, but when I do a cabal install it downloads 1.13.3. I unregistered the HaXml package and deleted the cached package with the same results.
21:26:32 <tennin> anyone familiar with staged type inference?
21:26:58 <SamB_XP> tennin: do they use that in that meta-ML thingy ?
21:27:09 <tennin> I think so
21:27:35 <tennin> I'm trying to read the paper "dynamic typing as staged type inference" from 1999, but I can't seem to get a PS viewer installed on this windows computer
21:28:08 <SamB_XP> tennin: try running ps2pdf over it ?
21:30:07 <jesmon> Saizan: Bingo! "cabal install yi" successfully built and installed it. but I have this strange thing in ~/.yi/yi-x86_64-linux which is getting executed and which is still 0.5.2
21:30:12 <monochrom> install a virtual machine such as vmware or virtualbox. install linux inside it. install a PS viewer inside that.
21:30:29 <tennin> =)
21:30:33 <jeffz`> I've never had a problem with gs + gsview on Windows
21:30:43 <jesmon> yi --version
21:30:43 <jesmon> Launching custom yi: "/home/jesse/.yi/yi-x86_64-linux"
21:30:43 <jesmon> yi 0.5.2
21:30:43 <jesmon>  
21:30:54 <jesmon> pardon
21:33:14 <Saizan> jesmon: touch yi.hs , it should recompile yi-x86_64-linux on restart that way
21:33:23 <jesmon> ok, just moving removing the "custom yi" worked
21:33:53 <tennin> anyway, what I'm looking for is a better solution to the problem where I am dealing with some data that is a type that is only known at runtime, but is a definite type that will remain fixed after it's determined in some preliminary stage of processing
21:33:53 <jesmon> yi --version then said "Recompiling custom yi" and reported the correct version
21:34:14 <tennin> e.g. database schema, or even CSV header
21:34:59 <Saizan> deech: 1.13.3 is the preferred version, if you want 1.19.x you've to ask for "HaXml >= 1.19"
21:35:03 <jesmon> anyhoo, cabal is quite confusing to me so far :|
21:35:14 <tennin> it seems to me that rather than foregoing all type safety because I don't know the type at compile-time, I should be able to use the typechecking machinery at runtime
21:35:18 <jesmon> Saizan: thanks for all your help
21:35:24 <Saizan> jesmon: np
21:35:30 <Saizan> jesmon: there's a Cabal faq
21:36:13 <tennin> thanks for the ps2pdf recommendation
21:36:14 <Saizan> http://www.haskell.org/cabal/FAQ.html <- needs more entries, probably
21:37:17 <Saizan> tennin: uhm, you can use gadts and/or existentials for that
21:46:27 <solrize> ghc 6.10 introduces memory leaks into programs that didn't leak under 6.8.3??!
21:48:28 <jackdempsey> hey guys, pretty basic q but feel like i'm missing something key
21:48:34 <tennin> hmm, ok
21:48:35 <jackdempsey> was looking at the definition of read
21:48:46 <jackdempsey> and didn't get why 'a' was ambiguous
21:48:50 <jackdempsey> then saw some other examples like
21:48:53 <jackdempsey> rInt :: String -> Int
21:48:53 <jackdempsey> rInt = read
21:49:04 <jackdempsey> and i see whats going on, but maybe not why....
21:49:20 <jackdempsey> i mean, it looks like you're basically saying, read, i need back an int, go do your thing
21:49:50 <tennin> Saizan: yeah, I think I can see the GADT approach
21:50:02 <jackdempsey> so if you have a function foo :: String -> a
21:50:16 <jackdempsey> you can then do things like bFoo :: String -> Bool
21:50:21 <jackdempsey> bFoo = foo
21:50:46 <Jebdm> jackdempsey: you can also use an inline type annotation
21:50:49 <jackdempsey> not even sure how to google on this, hence me asking here :-)
21:50:56 <jackdempsey> ok
21:51:16 <Jebdm> ex. (read something :: Int)
21:51:31 <jackdempsey> i see
21:51:32 <mauke> the read thing works because we have return-type-based overloading
21:51:37 <jackdempsey> ahh
21:51:45 <jackdempsey> i think thats what i'm trying to grasp at
21:52:09 <jackdempsey> i also didn't see how i was supposed to know from read :: String -> a that to call it i needed read "12"::Int
21:52:17 <jackdempsey> but maybe thats not really important
21:52:29 <jackdempsey> return-type-based overloading.....definitely haven't heard of that before
21:52:32 <Saizan> it's read :: Read a => String -> a
21:52:34 <jackdempsey> is that common in functional languages?
21:52:40 <mauke> not really
21:53:00 <mauke> I think most languages don't have typeclasses
21:53:03 <jackdempsey> Saizan: yes definitely, thx for clarification. that should be enough to tell me about the ::Int part?
21:53:06 <hatds> I love SPJ's spiel on return type overloading
21:53:16 <jackdempsey> interesting
21:53:52 <Saizan> jackdempsey: well, when a type variable has a typeclass constraint on it you need to choose a concrete type for it somehow
21:54:07 <Saizan> jackdempsey: often just using the result in the rest of the code is enough
21:54:15 <jackdempsey> ok
21:56:57 <jackdempsey> k, possibly foot -> mouth here....but why is "Read a" in that definition capitalized?
21:57:14 <jackdempsey> i'm used to some things capped because they're monads
21:57:19 <mauke> heh
21:57:24 <jackdempsey> modules
21:57:24 <jackdempsey> hehe
21:57:32 <mauke> in general, variables are lowercase and constants are uppercase
21:57:44 <mauke> Int is a concrete type, a is a type variable
21:58:01 <mauke> Read is the name of a class. I don't think we have class variables
21:58:04 <jackdempsey> k, my terminology is sorely lacking, but i think i'm getting the ideas a little more each time i approach it
21:58:07 <hatds> er not "constants" in the sense of values though
21:58:09 <jackdempsey> ahh ok
21:58:40 <Gracenotes> mmm. hot chocolate. ... in the summer. :\
21:58:51 <jackdempsey> mmm, bourbon :-D
21:58:53 <Gracenotes> yum though
21:59:00 <mauke> > let true = False in true
21:59:02 <lambdabot>   False
22:09:47 <deech> Hi all, using Haxml, once a string is parsed into Haskell's XML representation, is there a way to lookup the attributes and content by tag
22:41:11 <Gracenotes> mm. now it is time to see whether these wasabi peas are too hot for me or not. I suspect not.
23:03:22 <halberd> has anybody tried to draw a link between types and statistical inference?
23:04:50 <halberd> e.g., you give the line of best fit a type that says "this is the line of best fit for the data set D"
23:05:25 <halberd> and how would that play out when your fit is only approximate, not exactly the best
23:22:15 <Lemonator> I got a huge function,
23:22:30 <Lemonator> but no segment of code inside is used twice.
23:22:37 <Lemonator> Is it still worth it to break it up?
23:25:20 <cads> hey, can reversible computing be implemented with conventional electronics?
23:26:03 <QtPlaty[HireMe]> I've seen reversible computing implemented mechanitcally.
23:27:05 <cads> what did it do?
23:27:36 <Saizan_> Lemonator: yes, there are many reasons 1) you can test the subparts separately 2) with good names the overall logic becomes easier to read 3) you never know if/when you'd reuse something in the future
23:28:17 <Lemonator> It seems like a pain in the ass to do, though.
23:28:22 <Lemonator> behold:
23:28:29 <Saizan_> don't paste here!
23:28:33 <copumpkin> lol
23:28:33 <Saizan_> @hpaste
23:28:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:29:24 <Lemonator> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4978#a4978
23:29:29 <Lemonator> what?
23:31:50 <copumpkin> how would you test a function like that?
23:31:52 <Saizan_> Lemonator: that looks like it could be written with less code, actually
23:32:40 <Lemonator> oh?
23:33:20 <copumpkin> a 5-tuple :o
23:33:41 <Saizan_> instead of calling parse multiple times you could define a datatype like data Result = Ping .. | NewTopic .. | Message ..
23:33:45 <Twey> Ew, a pentuple
23:34:08 <copumpkin> using a record-based type instead of those n-tuples might make updating specific parts of them easier
23:34:56 <Lemonator> what kind of record-based type?
23:35:05 <copumpkin> respond (s, n, i, r, t)
23:35:09 <Saizan_> then result = Ping `fmap` ping <|> NewTopic `fmap` newTopic <|> Message `fmap` message
23:35:18 <copumpkin> it looks like your parse function returns a pentuple
23:35:25 <Lemonator> yeah
23:35:34 <copumpkin> which could probably be a nice type with record accessors
23:35:42 <Saizan_> and case parse result of Right r -> case r of Ping .. -> ..; NewTopic .. -> ..; ..
23:35:54 <Saizan_> parse result s, i meant
23:36:36 <Saizan_> yeah, you could stick those in the Message constructor
23:36:48 <copumpkin> it seems like you're using Right/Left as a kind of Maybe
23:37:02 <copumpkin> you always ignore the Left
23:37:05 <copumpkin> value
23:37:15 <copumpkin> oh, I guess it's an error value?
23:37:20 <Lemonator> well, parse returns an error value with Left,
23:37:25 <Lemonator> and I really don't need it.
23:37:48 <copumpkin> but yeah, doing it as Saizan said would get rid of a lot of that stuff
23:37:54 <Lemonator> hm
23:38:00 <copumpkin> since it's parser logic you're writing out by hand
23:38:26 <Saizan_> if you're using parsec you might need to add "try" there
23:41:41 <SubStack> blarg, updating a tree with multiple entrypoints into that tree is especially tricky
23:42:36 <SubStack> since regular zippers are all about singlular active nodes
23:42:43 <SubStack> from what I can tell
23:42:54 <copumpkin> you could easily give it a constant number more
23:43:45 <SubStack> and have the updates and insertions reflected in all of them?
23:44:04 <copumpkin> oh, no
23:44:08 <copumpkin> how do you mean?
23:45:31 <Saizan_> oleg has "concurrent" zippers implemented with delimited continuations on its site
23:46:33 <SubStack> I've come accross that page but I'll read it again
23:47:51 <SubStack> hmmm I missed the push/pull idea before
23:49:42 <SubStack> especially since the cursors will only sometimes actually need the updates
