00:00:24 <dabbler> @quote F#
00:00:25 <lambdabot> Raynes says: F# isn't a cousin [of Haskell], it's the retarded son in law.
00:01:06 <dabbler> @quote mutable
00:01:06 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
00:02:02 <dabbler> @quote functor
00:02:03 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
00:03:03 <johnw> @quote random
00:03:04 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
00:03:04 <lambdabot> thing is.
00:04:16 <ivanm> how does hlint classify what's an error and what's just a warning?
00:07:36 <dabbler> @quote polymorphic
00:07:36 <lambdabot> ghc says: Illegal polymorphic type signature in pattern
00:08:40 <Gracenotes> rawr
00:11:47 <Cale> haskellnoob: You're sure this is supposed to sort the list?
00:12:03 <dabbler> @quote snoc
00:12:03 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
00:12:07 <Cale> (perhaps I'm misinterpreting something...)
00:14:32 <Cale> Ah, I did, nevermind :)
00:23:35 <kadaver> so how do I install a package for a specific compiler?
00:25:02 <kadaver> i need system.random.shuffle for 6.10.1
00:25:08 <kadaver> but it seems impossible to use
00:25:16 <kadaver> maybe i should remove 6.10.2 completely?
00:31:38 <ivanm> kadaver: why not just use 6.10.2?
00:31:39 <haskellnoob> Cale: A few rounds of this, forward and backward, is supposed to sort the list.
00:31:49 <ivanm> otherwise, you could play around with symlinks, etc....
00:32:03 <Cale> haskellnoob: ah
00:32:45 <kadaver> because it doesnt work with gtk?
00:34:26 <kadaver> how did I do ghc-pkg again?
00:34:44 <kadaver> C:\ghc\ghc-6.10.2\progs\Mp3Player>ghc-pkg latest gtk
00:34:44 <kadaver> gtk-0.10.0
00:34:54 <kadaver> 6.10.1
00:34:59 <kadaver> f0or 6.10.2 i get nothing
00:35:12 <Cale> haskellnoob: Well, I think I've implemented it correctly such that it produces a list of steps in the state, and the final result at the end.
00:35:16 <kadaver> so i need to reinsta 6.10.2 and then reinstall gth2hs?
00:36:03 <Cale> haskellnoob: It's the sort of thing which doesn't really admit a very nice functional description, though it's not obvious to me at all what it *really* does to the list, so that's unsurprising.
00:36:30 <Cale> (Maybe if I knew better what it was accomplishing, I could find a clearer implementation.)
00:36:44 <dabbler> @quote macros
00:36:45 <lambdabot> twb says: I liked _On Lisp_, but it should have been called _Dirty Things I Did With Macros_
00:37:04 <dabbler> @quote macros
00:37:05 <lambdabot> DuncanCoutts says: I’m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
00:37:31 <dabbler> @quote Hackathon
00:37:32 <lambdabot> DuncanCoutts says: I’m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
00:37:55 <MyCatVerbs> @quote goat
00:37:55 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
00:38:03 <MyCatVerbs> Heehee.
00:38:06 <dabbler> lol
00:38:19 <dabbler> @quote tying
00:38:20 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
00:39:17 <dabbler> @quote closure
00:39:17 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
00:39:33 <ivanm> dabbler: have you got nothing better to do thatn randomly try and find quotes?
00:40:04 <dabbler> ivanm: cant sleep
00:40:16 * MyCatVerbs glances at wli.
00:40:39 <MyCatVerbs> @quote kitchen
00:40:40 <lambdabot> wli says: brb kitchen fire
00:40:48 <MyCatVerbs> Bad, bad wli.
00:41:28 <dabbler> @quote combinator
00:41:28 <lambdabot> bitwize says: The combinator known as compose, Makes me extremely morose; The full stop is better, than writing it in letters, Which makes it uselessly verbose.
00:41:28 <Cale> haskellnoob: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2320#a2323
00:41:58 <Cale> haskellnoob: That's a brutal step-by-step translation of your imperative program into a functional one.
00:42:32 <Cale> er, oops
00:43:01 <Cale> replace popWhile with spanS :)
00:43:43 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2320#a2324
00:44:50 <Cale> If you want something which just gives a result rather than a trace, just delete the "Left foo :" from each result, and replace the Right foo : []  with  foo  in weird3
00:45:17 <kadaver> gah
00:45:17 <kadaver> if i have 6.10.2 and 6.10.1 instlale,d how do i isntall a apckage for 6.10.1
00:45:17 <kadaver> ?
00:45:32 <Cale> kadaver: Why do you have both?
00:45:48 <Cale> (Is it necessary?)
00:46:10 <Cale> I think there may be options you can use to specify which package.conf is used
00:46:19 <Cale> But I've never attempted such a thing
00:48:03 <ivanm> kadaver: only suggestion I can think of is to keep changing symlinks
00:48:17 <ivanm> Cale: testing version regressions? *shrug*
00:48:33 <Cale> hmm, yeah, it seems like maybe the ghc devs might know
00:49:18 <kadaver> symlinks?
00:49:33 <kadaver> how do I deregister a package?
00:49:45 <Zao> ghc-pkg unregister
00:49:50 <kadaver> and how does cabal choose compier to register the package for?
00:50:17 <Zao> The one that currently holds the ghc-pkg/ghc/whatnot symlinks?
00:50:43 <Cale> yes
00:51:06 <Cale> Or whichever ones are first in the path, I would guess.
00:51:10 <ivanm> what do people here recommend in terms of latex packages to typeset lambda calculus?
00:51:26 <Cale> Does that need special support?
00:51:47 <ivanm> Cale: probably not, but how would one typeset it?
00:51:51 <Cale> $$\lambda f. \lambda x. f (x x)$$
00:51:52 <ivanm> in some math environment?
00:52:07 <ivanm> yeah, that's what I was thinking of
00:52:27 <Cale> (or with single $'s for inline)
00:53:10 <kadaver> 6.10.1 is firts in the path but it still doesnt isntallf or that
00:53:17 <Cale> It might be tedious to keep typing \lambda, so you might want to make a new command \l or something
00:53:24 <kadaver> anyone have gtk working with 6.10.2 on windows?
00:53:43 <Cale> ghc-pkg --version
00:54:46 <sebas_> hello guys, I'm currently playing with/working on a restricted IO monad that jails all actions inside a specific directory on the filesystem. Does anyone know whether such a thing already exists?
00:55:09 <sebas_> couldn't find anything like this on Hackage
00:56:38 <Cale> Like, something which makes calls to chroot?
00:58:44 <sebas_> Cale: no, I am restricting things with pure Haskell
00:59:18 <Cale> sebas_: Are you providing a small subset of the IO calls?
00:59:19 <sebas_> some my JailIO becomes opaque and controls all the possible calls
00:59:48 <sebas_> Cale: more or less everything, but wrapped inside safe wrappers
00:59:57 <Cale> yeah, that could be done
01:00:07 <Cale> There's various work on restricting the IO monad in various ways, but I don't think that particular one.
01:00:34 <sebas_> good to know I am not reinventing the wheel, again
01:01:31 <Cale> One option perhaps would be to control things at the level of Handles...
01:02:52 <sebas_> I'm also doing that, all FilePaths that come in the jailed IO monad are checked, all Handles must be the result from one an openFile from that jail session
01:03:03 <sebas_> so no sneaking in of other existing Handles
01:03:42 <Cale> Have  newtype Safe a = Safe a (don't export the constructor), and then  openFileJail :: FilePath -> IOMode -> JailIO (Safe Handle), and then  liftJail :: (Handle -> IO a) -> Safe Handle -> JailIO a
01:04:11 <Cale> Oh, if you want it to be from that session, you can use the polymorphic type parameter trick.
01:04:14 <Cale> (like ST)
01:06:18 <Cale> So that would become...  newtype Safe e a = Safe a,  openFileJail :: FilePath -> IOMode -> JailIO e (Safe e Handle),  liftJail :: (Handle -> IO a) -> Safe e Handle -> JailIO e a,  runJailIO :: FilePath -> (forall e. JailIO e a) -> IO a
01:07:22 <sebas_> Cale: that is more or less what I have now
01:07:44 <sebas_> but I do not use a Safe Handle type
01:08:00 <sebas_> because that way you could as well sneak in other safe Handles from other jails
01:08:10 <sebas_> so all Handles are checked before usage
01:08:26 <Cale> My second method prevents using a safe handle from outside that jail.
01:09:43 <Cale> (It uses the same trick as the ST monad to ensure that only files opened inside that jail are considered safe for that jail)
01:11:59 <sebas_> but the liftJail cannot be public, you can still perform arbitrary IO actions
01:16:28 <sebas_> so all lifting should stay limited to the JailIO module itself
01:17:54 <Cale> sebas_: oh, right.
01:19:45 <yakov> hey
01:21:48 <kadaver> is there a raytracer that actually works?
01:23:15 <kadaver> GHC package manager version 6.10.1
01:23:32 <kadaver> but when i cabal install then later the module isnt importable
01:23:36 <kadaver> but it is when i use 6.10.2
01:33:34 <haskellnoob> Cale: Thanks for the help. I was away and saw your comments just now. Let me try to figure out the code.
01:39:54 <ziman> @quote theomorphisms
01:39:55 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
01:39:55 <lambdabot> object in the category of religions and theomorphisms.
01:40:41 <Boney> nice.
01:43:24 <Maranor> Bored? Try this game: http://maranor.mybrute.com
01:50:52 <Cale> haskellnoob: Is it possible to follow?
01:52:47 <Cale> oh, he left
01:53:11 <kadaver> oh he's back
01:53:14 <kadaver> i found it
01:53:19 <kadaver> but it takes PixBuf
01:53:20 * edwardk is starting to feel a little dirty mucking around in the internals of things: http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/src/Text-Parsimony-Grammar-Monad.html
01:53:31 <kadaver> sigh in C it just takes a Path
01:53:38 <kadaver> why obfuscate?
01:53:42 <edwardk> otoh, it makes it very obvious that i can incorporate IO directly into my right-kan extension monad transformer scheme
01:57:10 <edwardk> this also makes me really want to play with a newtype FastIO a = FastIO { getFastIO :: forall o. FastIO (a -> State# RealWorld -> o) -> State# RealWorld -> o }
01:58:32 <ziman> what's `Fast' abou FastIO?
01:58:56 <edwardk> ziman: fmap, return and bind never touch the State# RealWorld down lower on the stack unless the action uses it
01:59:23 <edwardk> ziman: the same transformation makes 'State' about 3x faster
01:59:36 <Axman6> edwardk: go for it, and let us know how it turns out ;)
02:00:15 <edwardk> i basically already did all the hard work in the monad i linked to above
02:00:15 <ziman> isn't IO low-level compiler magic that gets already compiled out?
02:00:26 <edwardk> ziman: mostly =)
02:00:40 <edwardk> IO is built on the State# RealWorld stuff i mentioned above
02:01:22 <Axman6> edwardk: coudl what you've done been used to make the current IO stuff any better?
02:01:35 <Axman6> could*
02:02:50 <edwardk> axman: i'll benchmark it, i should _hope_ not
02:03:03 <Axman6> heh, indeed
02:03:27 <edwardk> worst case it should just be a dozen line change to GHC.IOBase and a few million lines of GHC ;)
02:03:33 <kadaver_> not in scope toPixBuf but i have imported Graphics.UI.Gtk.Gdk.Pixbuf where the function lives...
02:06:37 <zoheb> This is not a haskell question, but whatever!! How do you get colorized html code for haskell, for posting it to blogs? Is there a good blogger client that lets you paste colorized code, from say hpaste.org ?
02:07:01 <Axman6> So, for my engineering systems analysis course, we were doing a report on the probabilities of craps. It was supposed to be done in MATLAB, but it's a massive pain to do the sort of stuff we were doing. Decided to do the bulk of the work in haskell, and took 15 mins to get the basic code working, and a further hour to get all the bugs out
02:07:20 <Axman6> so, haskell > MATLAB (except for graphing afaik)
02:11:47 <kadaver> Axman6: exactly what do you study?
02:11:55 <Axman6> engineering/IT
02:12:12 <Axman6> zoheb: HsColour
02:14:09 <Zao> Leksah was ... nice.
02:14:24 <Zao> Crashed on the very advanced action of pressing space in the editor :)
02:14:53 <Zao> leksah: error: a C finalizer called back into Haskell.  use Foreign.Concurrent.newForeignPtr for Haskell finalizers.
02:15:05 <Zao> Isn't that a rather recent change?
02:15:52 <Axman6> think so
02:16:00 <Zao> Oh no it didn't!
02:16:05 <Zao> The bastard ate my .hs file.
02:16:10 <Axman6> :O
02:16:13 <Zao> Time to kill.
02:19:17 <kadaver> emacs tw
02:19:18 <kadaver> emacs ftw
02:19:35 <Zao> I find it quite amazing that it managed to eat my source file as I wasn't even remotely trying to save anything.
02:19:50 <Zao> kadaver: I just spent five minutes in the Emacs tutorial, trying to find out how to close it.
02:20:05 <Zao> One'd think they'd put that early in the welcome text.
02:20:39 <wunki> Zao C-x C-c
02:21:06 <monadic_kid> http://www.reddit.com/r/programming/comments/8hmmr/functional_reactive_programming_in_f_part_4/
02:21:52 <kadaver> Zao: press the X in top right corner?
02:22:06 <Zao> kadaver: Terminal one and I didn't want to lose my SSH leash.
02:22:07 <kadaver> or you meant to sya leksah tutorial?
02:22:10 <kadaver> aha
02:22:25 <Zao> wunki: I could of course have googled it, but I wanted to see if the tutorial was any decent.
02:22:41 <Zao> Had to test if the binary I installed for an user worked :)
02:22:51 <Zao> kadaver: Leksah is now purged from my machine.
02:22:55 <monadic_kid> have you tried using eclipsefp?
02:24:28 <monadic_kid> I can't Leksah built on my setup at the moment because of older external depedancies, i don't fancy bending over backwards to get Leksah working now so until then I'll use eclipsefp
02:35:36 <fasta> What matrix libraries are you using? I think I tried all of them already (except the GPL versions), but none of them seems to be used by anyone, since basic things like setting the column of a matrix are not implemented or appear not to be possible to implement efficiently (i.e., without changing the library internally).
02:38:41 <intx> what's a haskell?
02:40:44 <smtms> intx, Google knows the answer
02:40:54 <monadic_kid> intx: it's purely functional programming language
02:41:18 <Zao> EclipseFP looks quite huggable.
02:42:36 <monadic_kid> Zao: yeah it seems decent, i haven't tried the 2.x branch though so maybe it has some even more nice stuff
02:43:25 <monadic_kid> Zao: I'm using it under fedora where it has special native build for it
02:43:43 <monadic_kid> but that is under VM anyways lol
02:44:04 <monadic_kid> i gave up being a lonely haskeller on winxp and feeling the pain
02:44:44 <monadic_kid> When Fedora 11 comes out i want to make a cross-compiling enviroment
02:45:07 <monadic_kid> so i can use gch in in the vm but still generate executables for windows
02:45:12 <monadic_kid> hopefully
02:45:17 <monadic_kid> *ghc in the vm
02:46:39 <Jedai> fasta: hmatrix allows you to do that efficiently
02:46:56 <fasta> Jedai: but it is GPL, so I cannot use it.
02:49:34 <Jedai> fasta: It uses GSL anyway so it has no choice...
02:50:37 <fasta> Jedai: one can design a library such that it can use different backends. One being GPL tot start with.
02:50:41 <fasta> to*
02:54:39 <Jedai> fasta: You could contact Alberto Ruiz and ask him if you could use the non-GSL part of hmatrix under another license (BSD)
02:55:42 <ivanm> fasta: why is GPL a problem?
02:56:20 <ivanm> note that even if you can split the GSL and non-GSL components, you have to worry about the license of whichever LAPACK and BLAS implementation you use
02:56:31 <ivanm> also, have you considered maybe using the plain blas bindings?
02:56:32 <fasta> ivanm: because it is a closed-source application, I cannot help that.
02:56:40 <ivanm> fasta: *nod*
02:56:45 <mxc> :seen ndm
02:56:50 <mxc> ?seen ndm
02:56:50 <lambdabot> ndm is in #haskell. I don't know when ndm last spoke.
02:56:56 <fasta> ivanm: it is for low-dimensional linear algebra.
02:57:11 <ivanm> so blas might work then on its own
02:57:27 <fasta> ivanm: does blas have for example a decompose operation?
02:57:40 <ivanm> not sure
02:57:44 <fasta> ivanm: (from cgkit, which I believe does a polar matrix decomposition)
02:57:44 <ivanm> have never used it myself
02:59:15 * applicative_kid forces himself to be applicative functor
02:59:16 <fasta> ivanm: the documentation for blas seems to be nothing more than a worthless quickref pdf.\
02:59:29 <ivanm> :(
02:59:49 <kadaver_> how do I do if i need to go from IO and ass it to a function.
02:59:53 <kadaver_> but in one step
02:59:55 <kadaver_> instead of
02:59:59 <ivanm> fasta: well, email Alberto as Jedai suggested, to see if he can split the library up
03:00:07 <kadaver_> a <- b; blah a;
03:00:18 <kadaver_> blah b
03:00:25 <kadaver_> blah (<- b)
03:00:38 <kadaver_> =<<?
03:00:39 <fasta> ivanm: I think that takes more time than writing the functionality I care about myself. Thanks, anyway.
03:00:53 <doserj> blah =<< b, or b >>= blah
03:00:56 <ivanm> fasta: heh
03:01:12 <ivanm> kadaver_: what is the type of the function?
03:01:22 <ivanm> if the function is pure, use liftM
03:02:39 <applicative_kid> you could use fmap as well
03:02:50 * applicative_kid tries to think aplicatively
03:03:00 <yowgi> i've always wondered which one to use?
03:03:28 <yowgi> for example in lowerLine <- liftM (map toLower) getLine
03:03:43 <yowgi> fmap would work as well... how do i pick?
03:03:48 <applicative_kid> kadaer_: fmap ur_func your_monad
03:03:48 <ivanm> yowgi: fmap is more general
03:03:57 <ivanm> liftM is only for monads, fmap is for functors
03:04:01 <yowgi> yes
03:04:06 <applicative_kid> monad is a functor
03:04:09 <ivanm> all monads are functors (though this isn't enforced AFAIK...)
03:04:15 <yowgi> so in this case, liftM might be more descriptive?
03:04:27 <ivanm> yup
03:04:32 <yowgi> thanks!
03:04:54 <applicative_kid> yowgi: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux
03:04:57 * yowgi needs to read LYAH's chapter on functors
03:05:00 <yowgi> haha
03:05:03 <yowgi> exactly
03:05:35 <igor_t> is there any good library that would enable me to, given a font size and type return the size of the string
03:05:51 <ivanm> igor_t: define "size of the string"
03:06:08 <ivanm> if you mean length when printed/displayed in that font, then it's specific to that font as well AFAIK
03:06:13 <ivanm> due to width of chars
03:06:21 <igor_t> so I give it for example "String" 30 Arial and it return the width and height
03:06:23 <yowgi> igor_t, there is such a function in GD
03:06:43 <igor_t> i tried several GUI libraries but didnt have luck so far
03:07:05 <igor_t> i am currently trying wxWidgets but its way overcomplicating
03:07:16 <igor_t> GD?
03:07:31 <yowgi> igor_t, measureString http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html#15
03:08:30 <igor_t> thanks
03:08:35 <fasta> igor_t: to program a GUI library from a high-level language you either need a high-level complete library (there aren't any) or you need to use some binding, but for that you have to read the typically C documentation of the library.
03:08:56 <fasta> igor_t: GTK2HS has ported Haskell tutorials.
03:09:11 <fasta> igor_t: that should give you at least a feel for how it works.
03:09:12 <igor_t> i know i tried both GTK2HS and WxWidgets
03:09:19 <igor_t> but what I want is very very simple
03:09:33 <igor_t> and using them is way way too complicated for something as simple as this
03:09:37 <fasta> It always is.
03:09:50 <igor_t> so this function seems to do what I need
03:09:52 <igor_t> thanks again
03:10:16 <yowgi> although if i may add, linking to GD just to do this seems a bit overkill. it can measure a string, but you usually don't need to do that in GUI libraries.
03:10:38 <igor_t> i want to do manual word positioning
03:11:00 <igor_t> basically i am writing a simple browser
03:11:11 <igor_t> in order to do that I need to know how big the words are
03:11:19 <igor_t> for a given style
03:14:58 <mxc> hi
03:15:18 <mxc> looks like I missed ndm, anyone know off hand if Derive or DRiFT are still being maintained?
03:15:26 <ivanm> mxc: IIRC, no
03:15:41 <ivanm> and I don't recall ndm being here for a while...
03:15:49 <mxc> ?seen ndm
03:15:49 <lambdabot> I saw ndm leaving #haskell 11m 33s ago, and .
03:16:01 <ivanm> :o
03:16:16 <horms> ?kfish
03:16:17 <lambdabot> Unknown command, try @list
03:16:17 <ivanm> every other time I've looked for him, lambdabot didn't recall seeing him... >_>
03:16:22 <ivanm> preflex: seen ndm
03:16:23 <preflex>  ndm was last seen on #haskell 38 days, 23 hours, 59 minutes and 22 seconds ago, saying: demo: _make/_journal: hClose: illegal operation (handle is finalized) - any idea what that means?
03:16:23 <horms> ?seen kfish
03:16:24 <mxc> maybe he pops in in the morning before heading off to stanchart
03:16:24 <lambdabot> kfish is in #haskell.jp and #haskell. I don't know when kfish last spoke.
03:17:23 <mxc> ivanm - know if there are any other options for serialization?
03:17:35 <ivanm> nope
03:17:44 <ivanm> except for using Data.Binary somehow...
03:18:25 <kadaver_> is there some easy way to get better looking buttons in gtk2hs? because they look like they come from 1985
03:18:28 <mxc> well, i was using derive to derive instances for binary
03:18:58 <mxc> one thing i have to give to ocaml - good marshalling libraries
03:19:47 <dcoutts> kadaver_: use a different theme
03:20:04 <dcoutts> kadaver_: are you using linux or windows or osx?
03:26:21 <ivanm> kadaver_: s/theme/gtk engine/
03:28:38 <hamishmack> Zao:  Sorry to here you had hassles with Leksah.  Can I ask what version of GHC and gtk2hs you were using?
03:29:08 <solidsnack> What's the difference between the separated product and the coalesced product?
03:29:20 <solidsnack> How do they relate to the disjoint union?
03:30:19 <ScriptDevil> Does someone know a lexer written in alex. I want to learn by example
03:31:07 <hamishmack> Zao: also what OS was it on?
03:34:50 <blackh> hamishmack: Leksah is working very nicely for me now.
03:35:13 <Janni> Hello.
03:35:27 <blackh> hamishmack: It was crashing a bit.  I'll do some debugging if it does it again.
03:35:41 <blackh> Janni: Hello!
03:36:10 <Janni> Anybody here, who is involved with YHC? I have a problem...
03:36:59 <Janni> I am currently working on a new execution model for functional languages and my implementation (at the moment, but not restricted to) YHC (due to its nice --linkcore feature)
03:37:27 <hamishmack> blackh: Hi, if you feel lucky you could try out the leksah-head branch.  We have added regex search and grep.
03:38:00 <hamishmack> blackh: Not much new on the debugger yet though.
03:38:32 <fasta> dons: "Numerics libraries have long been a missing link for Haskell, and in the past few months we've seen several emerge, in particular haskell-blas, a binding to BLAS and LAPACK." Where are these LAPACK bindings you speak of? :P
03:38:41 <Janni> But the execution fails ATM, I suspect due to a problem in the libraries. I put the --linkcore output (in human-readable form) to http://pastebin.ca/1412000 alongside a normal order reduction of the program (performed by hand) here: http://pastebin.ca/1412001
03:39:32 <blackh> hamishmack: Actually searching all files in the project would be my biggest missing feature. One thing that was *really* bugging me was the fact that the highlighting of the search text in the editor didn't want to go away so I hacked my copy to make it turn it off when you close the search bar at the bottom.
03:39:46 <ivanm> fasta: hmatrix
03:39:53 <Janni> In the last line of the reduction there are _E is applied to 3 arguments, while the constructor _E does only take one. Is this a bug in the YHC std libraries?
03:40:29 <fasta> ivanm: ok, from that sentence it appeared that he meant haskell-blas.
03:40:41 <ivanm> *shrug* maybe he got confused
03:49:11 <kadaver>  a DLL can be written in C++ and interfaced from C and thus haskell?
03:49:35 <beelsebob> adding a question mark to the end of a statement makes it a question?
03:49:47 <beelsebob> (but in answer to your statement, yes)
03:50:14 <Janni> beelsebob: You are (were?) a YHC developer. Talk to me, talk to me!
03:50:29 <beelsebob> Janni: barely, you want to poke ndm_
03:50:56 <ndm_> Janni, i was one of the main Yhc developers
03:50:57 <ivanm> beelsebob: you really are an obliging fellow, aren't you... Janni demands you talk to him, and you do! :p
03:51:09 <Janni> beelsebob: ok. thx
03:51:11 <ivanm> ndm_: why does hlint report \ x -> x to be an error?
03:51:20 <Janni> ndm_: Hi. I have a little problem with the YHC libraries.
03:51:22 <ndm_> ivanm: why not use id ?
03:51:28 <ivanm> whereas everything else seems to be a warning?
03:51:48 <ndm_> Janni: there are lots of known problems with Yhc libraries, sadly - and I don't think anyone is going to have time to fix them
03:51:53 <ivanm> ndm_: in this instance, because I'm doing a Church Numerals implementation to use as explanation to non-Haskell people ;-)
03:52:05 <Janni> ndm_: Hmm.
03:52:15 <ivanm> but what makes \ x -> x an error, whereas everything else seems to be a warning?
03:52:20 <ndm_> ivanm: things that look like they are always wrong are marked error, i can downgrade that to a warning if you think it's correct - or you can selectively ignore it on a case by case basis
03:52:28 <ivanm> IMHO, a warning indicates something won't compile... >_>
03:52:35 <Janni> IMHO Haskell's standard library implementation is really mesed up (not YHC-specific)
03:52:42 <ivanm> ndm_: *nod*, just wandering what your justification was
03:52:49 <ndm_> Yhc doesn't use the standard libs, which is part of the problem
03:53:15 <ndm_> ivanm: its a judgement call, things that everyone should want to fix are errors, things that have a degree of personal preference are warnings
03:53:34 <ivanm> *nod*
03:53:44 <Janni> OK, so there might be problems, but would you mind having a little look at mine? See: http://pastebin.ca/1412000 and http://pastebin.ca/1412001
03:53:53 <Janni> I'd just like to know, if I'm missing s.th.
03:54:02 <ivanm> though the most annoying one I find are bracketing warnings... I tend to over-bracket to emphasise eval order, etc. in my code
03:54:14 <ndm> I've just been working on HLint actually, with +RTS -N4 it now goes twice as fast on my machine
03:54:14 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:54:19 <ndm> @messages
03:54:19 <lambdabot> gwern asked 25d 13h 21m 38s ago: so I was reading your supero paper and you mentioned ghc's isSpace function had a performance bug. was that ever fixed?
03:54:37 <ndm> @tell gwern no, isSpace is still buggy - the supero paper has the bug id in it
03:54:37 <lambdabot> Consider it noted.
03:54:42 <Janni> As I said earlier: the second file contains a normal order reduction (only a few lines) of the program in the first file
03:55:05 <Janni> And in the last line the _E constructor is strangely oversaturated. Is this a bug?
03:55:21 <ndm> I believe _E was a newtype, which gets removed somewhere
03:56:10 <ivanm> ndm: it takes four cores for a two times speedup? :s
03:56:36 <ndm> ivanm: yeah, i'm not convinced either - but its a simple fix and a good start
03:57:09 <Janni> Is there any other compiler which at the moment provides the standard libraries in an intermediate representation? I've tried to compile them with ghc to GHC-Core, but failed...
03:58:22 <ivanm> Janni: did you have a look at UHC?  I don't know what kind of intermediate representation it uses...
03:58:25 <Janni> Something similiar to YHC's --linkcore, which links in all required library functions into one file along with the program sources.
03:58:29 <ivanm> and IIRC, NHC uses bytecode...
03:58:48 <Janni> NHC's bytecode is too low-level (for my needs)
03:58:52 <ndm> ivanm: actually, -N2 gives nearly a 2x speed up, so -N4 obviously isn't getting the paralleism it wants
03:58:52 <ivanm> Janni: someone once wrote an app IIRC that converts a multi-module app into one big module
03:59:00 <ivanm> but I dont' think it brought in other libraries...
03:59:05 <ivanm> ndm: *nod8
03:59:18 <ndm> ivanm: a long time ago, HsAllInOne, I believe people are working to revive it
03:59:43 <ivanm> gah, I was going to do a talk at the math journal club in a couple of weeks on church numerals, but everything I find is too CS-y :s
03:59:43 <ndm> Janni: I don't believe so, Yhc is unmaintained, but nothing else gives you whole program Core
04:02:15 <Janni> ndm: OK. Checked again: nhc and uhc are useless (for that matter)
04:02:46 <ScriptDevil> Does someone have a decent sized alex file? Or is some other lexer recommended?
04:03:05 <ivanm> Janni: I take it jhc/lhc are as well?
04:03:11 <ndm> ivanm: have you tried using the config files for HLint, you can selectively ignore certain hints, or turn errors->warning, warnings->errors
04:03:21 <ndm> ivanm: lhc is now a GHC front end, so no luck there
04:03:30 <ivanm> ndm: well, I meant the old lhc
04:04:06 <ivanm> ndm: I only knew about three config files: default, dollar and deneralise
04:04:32 <ivanm> or is there a way of having a "global" hint file rather than per-project?
04:05:18 <ndm> ivanm: you can just edit default if you want
04:05:48 <ivanm> yeah, but that makes it hard to have a global install through the package manager ;-)
04:05:54 <ivanm> ndm: also, there's a type in your help file:
04:06:14 <ivanm> "The line can be read as replace concat (map f x) with concat (map f x). " <-- the latter should be "concatMap f x"
04:06:18 <ivanm> *typo
04:06:40 <ndm> yeah, it should really read hint files out of user data or something - i don't use the functionality, but am happy to accept a patch if someone can recommend a good alternative
04:07:02 <ivanm> heh
04:07:25 <ivanm> ndm: I take it though that you've carefully used hlint on hlint itself? :p
04:07:35 <Janni> ivanm: Hmm. jhc might be useful. thx for the hint
04:07:53 <ndm> ivanm: i do regularly
04:07:54 <ivanm> Janni: good, because I was running out of haskell implementations :p
04:08:19 <ivanm> so people can't accuse you of ignoring your own suggestions? ;-)
04:08:34 <ndm> I mean i don't use custom data files, i use HLint but the defaults perfectly match what I want (coincidence?)
04:08:52 <ivanm> lol
04:09:12 <ivanm> QtPlaty[2ireMe]: you're _really_ desperate for a job, aren't you! :p
04:09:22 <ivanm> ndm: did you see the message about the typo in your help file?
04:09:34 <ndm> ivanm: yep, just pushed a fix, now fixed on the web version
04:09:43 <ivanm> good-o
04:09:47 <ndm> thanks for spotting that
04:10:07 <ivanm> ndm: hmmm... the web version still has the old version :s
04:10:17 <ivanm> http://www.cs.york.ac.uk/fp/darcs/hlint/hlint.htm <-- this is the one I"m looking at :s
04:10:51 <ndm> http://community.haskell.org/~ndm/hlint/ links to the new one, where did you get that link from?
04:11:04 <ivanm> google
04:11:05 <ivanm> ;-)
04:11:08 <ndm> York cancelled my account and removed my web space without warning, so all the links are stale
04:11:15 <ndm> and I have no possible way of updating them...
04:11:22 <ivanm> so if they removed your web space, why is that still there? :s
04:11:43 <ndm> i put that in the departmental web space, but without my account i can't access their machines
04:12:02 <ivanm> ndm: ahhh
04:12:07 <applicative_kid> how does hs-dotnet compare to Salsa project?
04:13:10 <malcolmw> ndm: do you want me to do some cleanup of old repos there?
04:13:12 <ivanm> applicative_kid: well, I haven't heard anything about salsa for a while...
04:13:45 <applicative_kid> hs-dotnet looks a lot more polished
04:13:59 <ndm> malcolmw: yeah, i've got to figure out what wants doing first though - i really want a redirect on the repos but not sure if that's possible
04:14:30 <ndm> i've got it on my todo list to figure out what wants doing, then ask you or matt :-)
04:14:33 <malcolmw> ndm: at the least, I could put a motd saying where the current version lives
04:14:37 <kadaver> man, looking at the source of big C++ libs I find them completely unreadable. it is veyr hard to build intuition on how the program works, they seem to be ful of hacks, header files which I thought wre supposed to be just documentation are full of code too, there's funky macros all over the place. just ooks like generally sucky code.
04:14:39 <kadaver> just me?
04:15:01 <ndm> malcolmw: i guess that's worth doing, i'll email you a list of which repos have moved over
04:15:08 <ScriptDevil> dons: Are you here?
04:15:09 <Jedai> kadaver: Just C++ I think ;)
04:15:29 <malcolmw> @localtime dons
04:15:30 <lambdabot> Local time for dons is Mon May  4 04:14:12 2009
04:15:38 <ivanm> ndm: I take it cleaning up your current website is also on the TODO list, to remove the york-isms present there? :p
04:15:47 <ivanm> ScriptDevil: highly unlikely ;-)
04:15:55 <ndm> malcolmw: actually, the list is on this page - under darcs repos: http://community.haskell.org/~ndm/downloads/
04:15:57 <ScriptDevil> ivanm: : YEah right :)
04:16:10 <ndm> ivanm: no, i thought i had done that, can you point out the ones left?
04:16:20 <ivanm> ndm: "Dept Notes"
04:16:23 <ivanm> ;-)
04:16:44 <ivanm> and Teaching might not be that relevant anymore
04:16:48 <ErhardtMundt> how could i override a module in the path with a module in the current directory?
04:16:59 <ScriptDevil> ivanm: Does there exist a decent-sized lexer written in alex? I am having trouble learning it. I need more examples than the plain docs it provides
04:17:02 <ivanm> ErhardtMundt: ummm.... you don't override module
04:17:04 <ivanm> *modules
04:17:09 <ivanm> but you can have one with the same name
04:17:14 <ndm> ivanm: i deliberately left that, they're useful to people at york, even if that isn't me. and teaching is more to keep a checklist of what should go on my CV if I ever write them - no students ever looked at that
04:17:15 <ivanm> ScriptDevil: no idea ;-)
04:17:22 <ivanm> ndm: *nod*
04:17:30 <ErhardtMundt> ivanm: how?
04:17:43 <ivanm> ErhardtMundt: just create the same module
04:17:53 <ivanm> X.Y -> X/Y.[l]hs
04:18:03 <ivanm> ErhardtMundt: but it's good practice not to do so
04:18:09 <ivanm> especially for large/popular libs
04:18:20 <ErhardtMundt> ivanm: i need to shadow DynamicLog module
04:18:26 <ivanm> ndm: is that the York logo in the top left?
04:18:35 <ivanm> ErhardtMundt: for xmonad? you can't have seperate modules anyway
04:18:44 <ivanm> just define whatever you need in your ~/.xmonad/xmonad.hs
04:19:11 <malcolmw> ndm: oh hmm, your repos are still owned by you, so I can't change them
04:19:12 <ErhardtMundt> the function xmobarStrip is not provided in the canonical DynamicLog
04:19:30 <ErhardtMundt> and i need it for urgent hooks
04:19:44 <ivanm> ErhardtMundt: then just define it in your xmonad.hs
04:20:04 <QtPlaty[HireMe]> ivanm: Apperently I'm not that desprate.
04:20:07 <ErhardtMundt> ivanm: where's defined isPrefixOf?
04:20:11 <ivanm> ErhardtMundt: and it is exported...
04:20:15 <ivanm> @hoogle isPrefixOf
04:20:15 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
04:20:15 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:20:15 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
04:20:19 <ivanm> QtPlaty[HireMe]: heh
04:20:23 <kadaver> show me how you can compute something interesting with only types
04:20:24 <ivanm> ErhardtMundt: ^^ Data.List
04:20:34 <ndm> ivanm: yep, that is the York logo, guess I should probably change that, will raise a bug for it
04:20:39 <ivanm> but for me (using darcs xmonad contrib), xmobarStrip _is_ exported
04:20:48 <ErhardtMundt> ivanm: thank you!
04:20:49 <ivanm> ndm: you have bugs for yourself? :s
04:20:51 <ndm> malcolmw: hmm, anything i can do to unown them?
04:20:54 <ivanm> ErhardtMundt: no worries
04:21:55 <ndm> ivanm: of course - http://code.google.com/p/ndmitchell/issues/detail?id=173
04:22:15 <ndm> I have 92 open bugs for myself :-)
04:22:18 <ivanm> so you are your own project? :p
04:22:30 <ndm> yep
04:22:34 <ivanm> ndm: what's MinHugs?
04:22:48 <ivanm> a typo for WinHugs? or using MinGw instead of cygwin?
04:22:59 <ndm> ivanm: WinHugs, with fewer libraries, so much smaller - i.e. no OpenGL
04:23:02 <ndm> but most of teh useful ones
04:23:06 <ivanm> *nod*
04:42:08 <boegel> hiya gang!
04:42:19 * byorgey waves at boegel 
04:42:32 <boegel> anyone here ever used the Microbench package to figure out how fast/slow various versions of a function are?
04:43:20 <boegel> I'm wondering why there are instances of Microbenchable for 'Int -> a', 'Int -> IO()' and 'IO()', but not simply 'a'
04:43:33 <Botje> lazinss?
04:43:44 <wli> I've tried. The results aren't what I needed.
04:43:59 <boegel> i.e. to allow benchmarking of a function for which it's not possible to make it depend on a parameter n
04:44:22 <boegel> the implementation for 'IO()' is something like
04:44:36 <boegel> instance Microbenchable (IO ()) where
04:44:36 <boegel>   run f n = mapM_ (const f) [1..n]
04:44:45 <wli> boegel: evaluate or some such
04:44:53 <boegel> wli?
04:45:18 <wli> Control.Exception.evaluate
04:45:35 <boegel> wli: hmm
04:46:16 <boegel> wli: just noticed that's what's being used for the 'Int -> a' instance
04:46:17 <boegel> instance Microbenchable (Int -> a) where
04:46:17 <boegel>   run f n = do x <- evaluate (f n); return ()
04:47:31 <boegel> would 'mapM_ (const $ evaluate (f n)) [1..n]; return ()' work as instance for 'a' ?
04:47:35 <boegel> I guess it would...
04:48:48 <boegel> well, not exactly
04:49:07 <boegel> instance Microbenchable (a) where
04:49:13 <boegel>    run f n = mapM_ (const $ evaluate f) [1..n]
04:49:19 <boegel> this would though, I think
04:50:03 <EvilTerran> boegel, but it'd overlap the other instances
04:50:18 <boegel> EvilTerran: oh, right...
04:50:22 <boegel> EvilTerran: hmm
04:50:26 <EvilTerran> and have different semantics to them, so not be a safe overlap either
04:50:46 <boegel> EvilTerran: would there be a way to make that particular instance a 'last resort' instance?
04:51:30 <boegel> GHC doesn't seem to be complaining when I build Microbench with the instance added to it...
04:51:45 <EvilTerran> well, that's what it would be, with -XOverlappingInstances
04:51:54 <boegel> probably because {-# OverlappingInstances #-} is being set
04:52:05 <boegel> yah, same thing
04:52:08 <EvilTerran> but it'd be better style to say, eg, "newtype Evaluate a = Evaluate a; instance Microbenchable (Evaluate a) where ...."
04:52:17 <boegel> EvilTerran: ah, k
04:52:48 <EvilTerran> and then, if people want to use that instance, they'd wrap the value in Evaluate before passing it to Microbench
04:52:50 <boegel> EvilTerran: but then that would cause additional overhead, wouldn't it?
04:53:04 <Peaker> newtype entails no runtime overhead, afaik
04:53:13 <EvilTerran> nyet, newtypes have no runtime overhead
04:53:16 <boegel> Peaker: oh, I see
04:53:22 <boegel> EvilTerran: k
04:53:50 <EvilTerran> (well, unless you do so much funkiness with existentials, polymorphic recursion etc that ghc has to resort to explicit dictionary passing)
04:55:12 <boegel> EvilTerran: hmm, I just removed the OverlappingInstances pragma (or whatever you call it), and GHC still isn't complaining
04:55:21 <boegel> EvilTerran: without the newtype thing, that is
04:56:19 <boegel> seems like there's no overlap between 'Int -> IO()', 'Int -> a', 'IO()' and 'a', which is rather strange imho
04:56:59 <byorgey> of course there's overlap.
04:57:04 <byorgey> 'a' overlaps everything.
04:57:45 <boegel> ah, yeah, but the overlap error messages are only there when I compile something that uses the new Microbench package
04:57:51 <boegel> that's why I wasn't seeing it :)
05:06:20 <kadaver_> anyoen kow how to make a DLL in C++?
05:06:39 <p_l> kadaver_: please don't? :P
05:07:25 <liyang> Mmmm... Futurama projections: http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
05:07:26 <p_l> kadaver_: anyway, for GCC, there's -shared or something like that
05:07:30 <boegel> kadaver_: this is #haskell, not #making-dlls-with-c++
05:07:54 <p_l> kadaver_: just please don't complain on problems if you make the interface in C++ :P
05:18:05 <Athas> What are the differences between functional dependencies and type families, apart from matters of style?
05:18:11 <boegel> liyang: damned, you got me there... it FutAmUra, not FutUrAma :)
05:20:22 <liyang> boegel: this is my meta-reply http://twitter.com/sigfpe/statuses/1688746821
05:22:32 <Botje> boegel: yes. you confused me hugely
05:24:37 <boegel> Botje: _I_ confused you? howso?
05:27:45 <edwardk> athas: type families make it easier to make data types that don't need a million parameters they shouldn't care about, fundeps make it easier to deal with bidirectional type inference issues a c -> b d, b c -> a d, etc.
05:28:48 <edwardk> athas: in general i prefer type and data families where possible, and only use MPTCs when forced by the type system. (there are still some places where you can't cleanly go from a type family to a MPTC
05:30:59 <Botje> oh, it was liyang who said that first. sorry
05:31:12 <pozic> Is there an option in ghci such that the derived type of a function is Foo instead of Bar String whenever type Foo = Bar String is defined?
05:31:27 <Botje> no
05:31:34 <Botje> type synonyms get compiled away as the first step
05:31:43 <liyang> pozic: you may want to use newtype
05:31:49 <Botje> you can define instances for them, but you're probably better off using newtype
05:31:49 <pozic> Botje: what has compilation to do with it?
05:31:51 <edwardk> i.e. class ParserTraits traits where type Token traits :: *; data Parser traits e = ...; class (ParserTraits traits, Token traits ~ Char) => CharParserTraits traits where ... -- still isn't legal, so you need to add a parameter to your parser.
05:32:01 <Botje> ghci compiles code you give it before executing it :]
05:32:08 <pozic> Botje: by that I mean, that compilation actually has nothing to do with it.
05:32:16 <Botje> well, okay
05:32:18 <liyang> pozic: newtypes are compiled away, though you will have to deal with the extra syntactic fluff.
05:32:21 <Botje> it's a part of the typechecking process
05:32:25 <pozic> Botje: it is part of the type-inference.
05:32:29 <Botje> but i see that as part of "compilation" :)
05:32:38 <Athas> I must admit that I'm partial to MPTCs and functional dependencies myself, they feel like a more natural way to express it to me.
05:33:28 <Athas> But perhaps I am biased by the fact that I actually had great utility out of having two type variables in the signature of the class.
05:33:30 <edwardk> athas: my problem is when you build a data type that uses a class then you wind up with a ton of miscellaneous parameters 'leaking' into the class.
05:34:27 <edwardk> i.e. if I need a 'reference type' it'd be nice to just say Hash IO a or Hash STM a -- instead of needing to know that I need Hash IO IORef a -- and Hash STM TVar a
05:36:18 <Athas> Hmm, can both be mixed in the same class?
05:36:35 <edwardk> yeah
05:48:41 <edwardk> @seen dons
05:48:41 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6h 24m 21s ago.
05:49:30 <edwardk> @tell dons the right kan extension stuff can rip IO in half too, since IO is basically just a state monad: http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/src/Text-Parsimony-Grammar-Monad.html
05:49:30 <lambdabot> Consider it noted.
05:55:24 <boegel> microbenching stuff is harder than I thought: pfft
05:55:30 <boegel> s/:/,/
05:55:35 <mattam> TY
05:55:43 <jad4> is there some standard mathematical representation for currying?
05:55:59 <jad4> or usual...
05:57:25 <saml> @pl (\p -> p >>= return)
05:57:25 <lambdabot> id
05:57:26 <ivanm> http://jekor.com/article/is-haskell-a-good-choice-for-web-applications <-- I thought the various DB libs were either mature enough or used something better than just string manipulation :s
05:57:50 <liyang> jad4: the logical tautology (a & b -> c) -> a -> b -> c
05:58:08 <liyang> jad4: (not quite sure I understand what you're asking about.)
05:58:27 <Vq^> ivanm: thats just silly, of course Haskell looks good if you compare it with PHP
05:58:40 <ivanm> heh
05:59:46 <earthy> ivanm: HaskellDB at least does. ;)
06:00:00 <ivanm> earthy: but is it as immature as the blog poster thinks it is?
06:00:04 <EvilTerran> writing machine code by hand on tape with a magnetised needle looks good compared to PHP :P
06:00:17 <earthy> it may be slightly bitrotted....
06:00:19 <boegel> EvilTerran: :)
06:00:31 <boegel> @remember EvilTerran writing machine code by hand on tape with a magnetised needle looks good compared to PHP :P
06:00:31 <lambdabot> Okay.
06:01:24 <Alpounet> @quote EvilTerran
06:01:24 <lambdabot> EvilTerran says: i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
06:01:25 <fasta> It would be nice to have some statistics on actual use of libraries.
06:01:31 <Peaker> I wish the web would die
06:01:53 <fasta> Peaker: you want just applications + sockets?
06:02:15 <Peaker> fasta: nah, I just think that without the web, something much better would spring up.. I think the web is a horrible architecture
06:02:23 <EvilTerran> fasta, doesn't hackage collect stats about downloads? that'd give ballpark figures
06:02:33 <Peaker> fasta: Local applications + sockets might actually be a better foundation
06:03:11 <boegel> ok guys, I'm at loss here, maybe someone can help me out
06:03:12 <boegel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4561#a4561
06:03:35 <fasta> EvilTerran: the amount of downloads might say something, but it would be better if actual use was represented. For example, I have xmonad installed, but I don't actually use it.
06:03:39 <boegel> I'm trying to benchmark two different implementations of a function which calculates the Euclidean distance
06:04:19 <boegel> I _know_ that the one using UArr is a lot more efficient, because I've been using it in a real app where I was previously using the straightforward, but slow, version using lists
06:04:22 <fasta> Peaker: it is obviously better from an efficiency point of view which disregards economics.
06:04:29 <boegel> however, that's not what Microbench is telling me...
06:04:44 <boegel> it's telling me both are equally fast, which is plain rubbish, because they're not
06:04:52 <boegel> does anyone have any idea what's going on here?
06:05:03 <fasta> Peaker: web-applications is the ultimate in "protecting" whatever probably is not worth "protecting".
06:05:15 <Peaker> fasta: what do you mean?
06:05:51 <fasta> Peaker: I mean that if we didn't live in a capitalistic system, there would be no web, but there would be applications + sockets.
06:06:13 <earthy> boegel: ghc being lazy enough to not perform the work for the 'slow' version, nor for the fast one?
06:06:47 <fasta> boegel: from my experience Microbench didn't actually work.
06:06:55 <Peaker> fasta: its too big an "if" for me to imagine through :)
06:07:28 <saml> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4562#a4562  help me with parsec.
06:07:56 <saml> i want to parse "2apple    2   apple" as "2apple", 2, "apple"
06:08:11 <saml> but it parses as 2,apple,2,apple
06:08:41 <boegel> earthy: I think I'm enforcing strictness though...
06:08:43 <boegel> fasta: howso?
06:09:01 <Peaker> saml: what is the type of the result that you want? [String] ?
06:09:14 <saml> Peaker, [AST]
06:09:26 <Peaker> saml: ah, looking at the paste now
06:09:29 <fasta> boegel: because I tried it a few months ago and it didn't do what it was supposed to do. I don't remember details. If at some point in time I have determined that something is not worth my time I delete it from my brain automatically.
06:09:42 <Peaker> @pl int >>= (return . Int)
06:09:43 <lambdabot> Int `fmap` int
06:10:04 <saml> Int <+> int
06:10:15 <boegel> fasta: :)
06:10:17 <saml> maybe it was <$>
06:10:28 <EvilTerran> ?src (<$>)
06:10:28 <lambdabot> f <$> a = fmap f a
06:10:28 <boegel> fasta: well, I'm trying to get it to do what it's supposed to do, but it's not... :(
06:10:49 <boegel> fasta: I like the idea, a package to allow the user to easily benchmark different implementations of the same function
06:11:19 <fasta> boegel: as with most things in Haskell, you have to roll your own. I really don't like this reinventing the wheel all the time, but well, someone has to do it.
06:11:22 <boegel> earthy: any suggestions to avoid GHC being lazy?
06:11:24 <Alpounet> @src <+>
06:11:24 <lambdabot> Source not found. I am sorry.
06:11:42 <ivanm> boegel: in what sense?
06:12:05 <boegel> ivanm: well, the benchmarking is telling me that both functions are equally fast, which they're not
06:12:16 <ivanm> boegel: print the results out?
06:12:19 <boegel> ivanm: so, earthy's suggestion of GHC being lazy seems plausible
06:12:22 <ivanm> reduce to rnf?
06:12:28 <boegel> ivanm: hmm, good suggestion
06:12:40 <ivanm> boegel: if you don't actually need the answer, ghc won't generate it
06:12:42 <boegel> ivanm: whnf should be enough, with the result being a Double
06:12:47 <ivanm> yeah
06:12:50 <ivanm> so just seq it
06:13:10 <boegel> ivanm: well, 'evaluate' should be enforcing the evaluation
06:13:16 <Peaker> @hoogle (<+>)
06:13:17 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
06:13:17 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
06:13:17 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
06:13:19 <ivanm> @hoogle evaluate
06:13:19 <lambdabot> Control.Exception evaluate :: a -> IO a
06:13:19 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
06:13:27 <ivanm> boegel: ^^ which one? ;-)
06:13:30 <boegel> ivanm: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#8
06:14:34 <boegel> but maybe GHC is optimizing away the evaluate part of the IO() functions...
06:14:42 * ivanm doesn't see how evaluate /= return $!
06:14:58 <boegel> ivanm: neither do I :-/
06:15:16 <ivanm> boegel: maybe try printing the value or something just to confirm
06:15:20 <boegel> ivanm: seems to me that 'return $! x >>= return' is identical to "return $! x"
06:15:27 <ivanm> or else your inputs are too small so that there's not much for it to do...
06:15:39 <ivanm> boegel: must be the execution order is different or something
06:15:43 <ivanm> though the result is the same
06:15:57 <boegel> ivanm: well, microbench is enforcing the IO() functions 2^20 orso times, so printing might not be such a great idea :P
06:16:04 <boegel> ivanm: yeah
06:16:09 <ivanm> boegel: also, are you sure that you haven't gotten ghc to compile the result in the executable? :p
06:16:15 <boegel> ivanm: that's the whole point of _microbench_
06:16:18 <boegel> err
06:16:21 <ivanm> heh, printing is probably not good, no
06:16:22 <boegel> _micro_bench
06:16:30 <saml> @pl (\p q -> do { x <- p; q; return x }
06:16:30 <lambdabot> (line 1, column 13):
06:16:30 <lambdabot> unexpected "{"
06:16:30 <lambdabot> expecting variable, "(", operator or ")"
06:16:46 <boegel> ivanm: it can't, because the result depends on the input
06:16:51 <boegel> ivanm: or... hmm, wait
06:17:48 <boegel> ivanm: actually, no matter which parameter I give it for d, the distance will always be 0.0, because p1 and p2 are identical
06:18:04 <boegel> ivanm: so if GHC is smart enough to figure that out, then it knows it'll always be 0.0
06:18:19 <ivanm> heh
06:21:41 * boegel tries to outsmart GHC
06:27:23 <boegel> ivanm: now GHC can't compile in the result, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4561#a4563
06:27:41 <boegel> ivanm: still same observation though, roughly equal times
06:27:47 <ivanm> heh
06:27:51 * ivanm -> land of nod
06:28:17 <boegel> ivanm: now, I'm still not 100% forcing evaluation, because I'm not printing the results of each distance calc.
06:28:19 <boegel> ivanm: night!
06:35:52 <wli> rnf may be needed
06:38:44 <boegel> wli: I added a dependency on the distance calculated in the IO() functions
06:38:47 <boegel> wli: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4561#a4564
06:39:32 <boegel> wli: although this is still not what I want (I want to benchmark the distance calculation, not the overhead the dependency causes), this still leads to roughly identical timings
06:39:53 <boegel> and the 'fast' version is like over 2-3x faster than the slow one...
06:40:24 <boegel> I'm mostly interested in distance calculatins in the 100D-space, because that comes closest to what I'll be using it for
06:41:57 <saml> yay fixed my parsec problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4562#a4565
06:51:31 <fasta> Is there any kind of extension which makes it possible to store type-level numbers in a list and then apply some function to it? I think a combination of rank-2 types + HList would to the trick, but I didn't really think a lot about it.
06:52:59 <vixey> fasta: I think the closest thing to type level functions is associated types
06:53:25 <vixey> not sure if you could write  map  with then, but you could do the recursion manually
06:57:27 <Peaker> I think the HList paper does type-level functions via fundeps?
06:57:48 <Peaker> fasta: what are you trying to do there?
06:59:13 <fasta> Peaker: I wanted to remove some boiler-plate in some code which uses type-level numbers.
07:01:19 <Peaker> fasta: can you describe what it does?  I'm wondering about where type-level numbers are useful
07:01:41 <fasta> Peaker: they are used in the Vec package, which I currently use.
07:03:38 <vixey> @hackage Vec
07:03:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
07:03:52 <vixey> Vectors are represented by lists with type-encoded lengths
07:04:09 <Gracenotes> without hacks?
07:04:38 <fasta> Yes, only the author seems to have forgotten to include operations to set specific indices to specific values.
07:04:59 <Gracenotes> no, looks a bit hacky :o
07:05:08 <vixey> why Gracenotes?
07:07:01 <Gracenotes> well. quite a few fundeps, that's all
07:07:47 <Gracenotes> and somewhat limited functionality? can't tell :x
07:07:48 <fasta> I think fundeps still hold the record for most complicated features in the type-system in Haskell.
07:07:58 <ScriptDevil> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4568#a4568 I thought same level of indentation meant a new statement in the same block. But Tackling the Awkward Squad's example, seems to defy this...
07:08:24 <Gracenotes> oh, no, multiple recursive class instances allow for functionality
07:11:59 <SamB> fasta: why'd you need functions for that?
07:12:13 <scriptdevil> Did anyone answer my question, I think I lost my connection for a second
07:12:15 <SamB> (setting specific components to specific values)
07:12:39 <doserj> scriptdevil: there is no block there, so indentation rules do not apply
07:12:41 <Axman6> scriptdevil: no. i'm not sure what the question is anyway
07:13:05 <fasta> SamB: cgkit has setRow and setColumn functions. So, it appears that someone at least thinks it is useful. I agree with the author of cgkit.
07:13:19 <SamB> hmm.
07:13:44 <scriptdevil> doserj: Well, I did not mean a do block... I mean, is it ok to do http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4568#a4569
07:14:33 <doserj> scriptdevil: sure, that's ok
07:14:39 * EvilTerran 's brain melts at zippers
07:15:25 <scriptdevil> doserj: Thats strange...
07:16:23 <scriptdevil> When do the rules apply?
07:16:30 <doserj> scriptdevil: indentation only applies to where-, let-, do-, and case-of-blocks
07:16:43 <Axman6> that's not totlly true
07:17:19 <Axman6> anything at the top level will be read a a top level function i think, so you can't say f x =\ng x x
07:17:31 <Gracenotes> scriptdevil: compiles here
07:17:43 <Peaker> scriptdevil: try it?
07:17:53 <Gracenotes> you might have issues with buffering (probably on Windows), but it should be fine
07:18:01 <Gracenotes> fixable
07:18:06 <doserj> Axman6: the top-level is in a where block, usually (module X where ...)
07:18:15 <scriptdevil> Gracenotes: Oh well, Debian/Archlinux
07:18:20 <Axman6> i see
07:18:34 <Gracenotes> *nod*
07:19:20 <scriptdevil> doserj: I got it... I should tell myself that what I wrote was infact a single statement. Indentation hurts only for multiple statements
07:20:33 <jelly12gen> hi i am trying to read an int IO
07:21:21 <jelly12gen> i just use import IO; getInt :: IO Int; getInt = do  line <- getLine; return (read line :: Int)
07:23:42 <Athas> Is Yi still under active development?
07:24:18 <EvilTerran> ?hoogle readLn
07:24:19 <lambdabot> Prelude readLn :: Read a => IO a
07:24:19 <lambdabot> System.IO readLn :: Read a => IO a
07:24:46 <EvilTerran> jelly12gen, readLn would do the same job
07:24:52 <jelly12gen> aha
07:25:48 <jelly12gen> EvilTerran: but i want to read ints
07:26:19 <tombee> I don't mean to 'troll' here, I am studying a bit about lambda calculus and functional programming and decided to use 'haskell' as my functional programming weapon of choice to practise this study.
07:26:38 <jelly12gen> tombee: yeah . but ..
07:26:41 <tombee> But is haskell really practical for the majority of programs?
07:26:49 <tombee> Or does it have a select set of uses?
07:27:04 <Axman6> it's well and truly useful
07:27:15 <EvilTerran> jelly12gen, readLn works for any type that's an instance of Read
07:27:18 <EvilTerran> ?instances Read
07:27:19 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:27:21 <tombee> Like I said I'm not criticising the language at all, I'm merely trying to understand it Axman6 :)
07:27:43 <EvilTerran> tombee, people have written compilers, window managers, and 3d games in haskell
07:27:43 <SamB> the truth is, we don't know if it's practical for the majority of programs ;-)
07:27:48 <QtPlaty[HireMe]> tombee: Ther is a whole book on using haskell in the real world
07:27:50 <Axman6> i'm writing a post right now about how i used it to write something that I and a friend spent over an hour trying to figure out in MATLAB and getting nowhere, and only taking 15 mins to get it done in haskell
07:27:50 <jelly12gen> EvilTerran: i just want too read two int's and multiple them
07:28:01 <tombee> Do you think there's a function to decide whether it's practical SamB? ;)
07:28:05 <Athas> One of the most useful facets of Haskell (or GHC) is that it integrates well with a typical OS.  No big runtimes or magical bytecode formats.
07:28:08 <tombee> Or is that not computable :P
07:28:12 <SamB> hehehe
07:28:14 <QtPlaty[HireMe]> SamB: s/programs/programmers/
07:28:27 <EvilTerran> jelly12gen, well, "do x <- readLn; y <- readLn; return (x*y :: Int)" would do that
07:28:37 <Athas> So you can mostly treat Haskell as a really clever variant of C, as far as the system is concerned.
07:28:49 <tombee> Ah, I'm a fan of C :)
07:28:54 <SamB> Athas: what do you mean, no big runtimes?
07:28:56 <EvilTerran> jelly12gen, replace the "return" with "print" if you just want to output the result to the terminal
07:29:01 <SamB> it's just linked in the executable ;-P
07:29:03 <Athas> SamB: yes, no big runtimes or weird formats.
07:29:09 <Athas> Indeed!  But they are still somewhat small.
07:29:27 <eu-prleu-peupeu> tombee: im also a fan of C :)
07:29:54 <tombee> I'm studying a bit about computation theory at the moment and algorithm efficiency.  I think for this area functional programming and haskell are probably useful.
07:30:00 <Athas> I come from Lisp, where you sort of insulate yourself and pretend that the entire world is a Lisp image.  And a great world that is!  Alas, but not very large.  Haskell (or again, really GHC) is more pragmatic.
07:30:45 <tombee> I'm watching a video on haskell at the moment by Simon Peyton-Jones, talking about xmonad.
07:30:58 <tombee> But everything seems so 'overly' complex to get something done.
07:31:04 <Axman6> ...
07:31:09 <Axman6> you're kidding right?
07:31:09 <eu-prleu-peupeu> ...
07:31:10 <blackh> tombee: Haskell is very general. There are some areas where library support is not as good as other languages (since it's early days at the moment). That would be the only weakness I can think of. I've used the language for quite a few different things and without exception the experience has been excellent.
07:31:23 <EvilTerran> tombee, consider how much more work xmonad would've been if it were written in C
07:31:42 <Axman6> haskell is by far the most efficient language i've ever used, in terms of getting things done in the shortest amount of time
07:31:48 <eu-prleu-peupeu> tombee: you are clearly at the begining of the video :)
07:31:55 <SamB> Athas: it can add up if you have a lot of GHC-compiled programs ;-)
07:31:59 <tombee> That's right, im about 1/4 the way in eu-prleu-peupeu :)
07:32:22 * earthy grins
07:32:37 <Athas> SamB: actually, is there a way to dynamically link Haskell programs?
07:32:38 <SamB> tombee: oh, I loved that video
07:32:44 <SamB> he's so animated
07:32:54 <tombee> SamB: Do you know if his slides are on the net somewhere?
07:32:55 <Athas> Hm, they are .a files, are they not?
07:32:58 <earthy> haskell really does take the cake where it comes to powerful easily modified code.
07:33:02 <tombee> Because it's a shame, I can't see his examples of code
07:33:02 <jelly12gen> Axman6: but haskell isnt the most readable langauge
07:33:04 <blackh> tombee: Haskell is not complex.  It's just very, very different.  It's probably about average as far as complexity of the language is concerned, e.g. considerably simpler than C++
07:33:12 <SamB> xmonad's actually really damn simple -- those properties are really nice to have, you know
07:33:13 <Axman6> jelly12gen: sure it is
07:33:15 <McManiaC> hey, im trying to install sth with cabal, but i got the error "postmaster-0.1 depends on hsdns-1.4 which failed to install." - what is hsdns and how can install it?? im using debian on this machine
07:33:17 <eu-prleu-peupeu> tombee: you will appreciate haskell when youll have to handle > 50.000 lines of bad C code :)
07:33:33 <koeien_> why compare Haskell to C ?
07:33:36 <SamB> tombee: yes, they are!
07:33:41 <koeien_> and not some other language, like D ?
07:33:41 <SamB> I know exactly why you want them
07:33:43 <koeien_> fairer imo
07:33:50 <Axman6> jelly12gen: compare it to C if you've never programmed before, and i'd bet you most non programmers would say haskell is far easier to understand
07:33:53 <dcoutts> McManiaC: if you look back further in the build log you'll see where cabal tried and failed to install hsdns-1.4
07:33:56 <QtPlaty[HireMe]> haskell typically has shorter code.
07:33:59 <tombee> SamB: the camera doesn't focus on the slides :(
07:34:05 <jelly12gen> Axman6: but if you compare it with java :P
07:34:07 <EvilTerran> eu-prleu-peupeu, and when you find yourself thinking "i could do this in 500 lines of haskell"? :)
07:34:13 <SamB> should be listed on http://www.haskell.org/haskellwiki/Video_presentations iirc
07:34:24 <SamB> yes, they are
07:34:35 <dcoutts> McManiaC: if it's scrolled off the screen then try directly cabal install hsdns-1.4 and see why it fails
07:34:40 <endojelly> jelly12gen, it's also far more readable than java
07:34:42 <EvilTerran> jelly12gen, java's barely better than C
07:34:42 <Axman6> jelly12gen: same thing. Java is quite hard to understand in many ways
07:34:45 <endojelly> jelly12gen, there are a lot more abstractions
07:34:45 <McManiaC> dcoutts: hsdns-1.4 failed during the configure step. The exception was:
07:34:49 <McManiaC> exit: ExitFailure 1
07:34:50 <tombee> I'm sorry if I've started some sort of war in here over haskell ;)
07:34:52 <SamB> tombee: http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
07:34:57 <jelly12gen> ok ok
07:35:01 <dcoutts> McManiaC: again, the real reason will be a little further up
07:35:05 <jelly12gen> l:P
07:35:07 <SamB> hopefully those are still there
07:35:15 * earthy has just now reimplemented a bit of icky convoluted C spanning some 120 lines in about 45 lines of Haskell
07:35:15 <tombee> Got it.. great :)
07:35:31 <n0nsense> McManiaC: \o/ xD
07:35:34 <koeien_> focus on loc count is overrated imo
07:35:35 <earthy> oh, and the Haskell does more
07:36:31 <koeien_> i'd focus more on correctness & time to write a program
07:36:32 <SamB> earthy: I can think of one thing the C code probably did that the Haskell won't
07:36:37 <SamB> segfault ;-)
07:36:57 <earthy> SamB: how did you guess?! :P
07:36:57 <n0nsense> n0nsense@segfault:~$
07:37:10 <McManiaC> dcoutts:  If the library is
07:37:11 <McManiaC> already installed but in a non-standard location then you can use the flags
07:37:16 <McManiaC> ah sorry
07:37:19 <Axman6> i've made haskell segfault... but it was hard work usually (and doing funky stuff)
07:37:22 <McManiaC> dcoutts: http://pastie.org/467666
07:37:22 <earthy> ofcourse, it only segfaults on Mac OS X, not on Linux... :P
07:37:31 <McManiaC> theres no hsdns packet for debian?
07:37:34 <EvilTerran> koeien_, i'd focus on "number of distinct concepts" over "number of lines of code"
07:37:39 <jelly12gen> lol
07:37:42 <koeien_> EvilTerran: yes. better.
07:37:54 <koeien_> EvilTerran: separation of concerns
07:38:02 <n0nsense> McManiaC: looks like you're missing the C-headers or something
07:38:14 <dcoutts> McManiaC: does that error message make any sense to you now?
07:38:16 <SamB> Axman6: well, yeah, you can make it segfault but you either have to get index calculations to overflow, or use pointers, basically ;-)
07:38:16 <koeien_> i couldn't care less if i have to write long identifiers in Java, because i have eclipse and eclipse is magic
07:38:23 <earthy> hm. right. still running after 22 minutes.
07:38:40 <n0nsense> McManiaC: apt-get install libadns1 libadns1-dev or something
07:38:45 <jelly12gen> koeien_: but java is still slow
07:38:53 <dcoutts> McManiaC: is there any way that we could improve it so that it is clearer to you what is wrong and what the solution is?
07:38:54 <koeien_> jelly12gen: it's not
07:39:01 <SamB> koeien_: does it make the identifiers take up less lines on the screen ?
07:39:03 <jelly12gen> koeien_: well the gui is
07:39:08 <koeien_> jelly12gen: ok. agreed on that
07:39:16 <McManiaC> hmkay
07:39:24 <McManiaC> seems to be building
07:39:27 <koeien_> SamB: no. i don't say it's a good/bad thing, just that the focus on it is overrated
07:40:00 <SamB> it's nice to be able to see more of your code at once
07:40:07 <koeien_> sure
07:40:18 <koeien_> but it's also nice to see faster what some function/variable means sometimes
07:40:25 <koeien_> instead of reading obscure abbreviations =)
07:40:28 <SamB> or as it says in Documentation/CodingStyle, it leaves you more room for comments ;-)
07:40:36 <SamB> well, I mean, you don't want to use overly short names
07:40:45 <SamB> but some of those names can get to be a bit much
07:40:46 <koeien_> yes, sometimes java is really overboard
07:41:02 <Axman6> tombee: so, got any questions about haskell?
07:41:10 <EvilTerran> i've noticed that many haskellers have a tendency towards using near-arbitrary letters for local variable names
07:41:17 <EvilTerran> more so than programmers in other languages
07:41:32 <SamB> EvilTerran: if the function is short enough, does it matter?
07:41:34 <earthy> EvilTerran: there's a good reason for that
07:41:37 <EvilTerran> but then, these variables' purposes can often be inferred from their type, so you don't need a descriptive name
07:41:39 <koeien_> EvilTerran: yes. in generic functions like 'length' that is no problem (in fact, useful)
07:42:06 <earthy> in many cases the variable can refer to such a generic thingamabob that there really is no good name
07:42:19 <SamB> yeah, "item:list" isn't really more descriptive than x:xs ;-)
07:42:43 <koeien_> yep
07:42:51 <EvilTerran> (i never said this was a bad thing, merely that it's more common in haskell than other languages)
07:42:59 <SamB> though of course that doesn't save you lines on the screen ;-)
07:44:22 <tombee> ahah SamB, his presentation makes so much more sense with the slides.
07:44:52 <tombee> Axman6: Heh sorry, I was deep in thought watching that video, erm.. I suppose Im wondering if there's a good resource to learn haskell you can recommend?
07:45:08 <Axman6> lyah
07:45:11 <Axman6> @where lyah
07:45:11 <lambdabot> www.learnyouahaskell.com
07:45:14 <Axman6> ^^
07:45:16 <SamB> tombee: yes, yes it does!
07:45:20 <koeien_> tombee: there is 'learn you a haskell' and Real WOrld Haskell (although the latter is more advanced)
07:45:35 <tombee> Ah, I've seen this website before :p
07:45:38 <Peaker> I dislike single-letter variable names, even type variable names. I prefer  data Accessor whole part = ...   over data Accessor w p = ...
07:45:39 <Peaker> earthy: write a glossary in the documentation and use newly invented terms
07:46:22 <tombee> Real World Haskell is a book then I take it?
07:46:41 <SamB> tombee: yeah, available online with all kinds of comments from the peanut gallery though
07:46:41 <koeien_> yes. free to read on-line but i have the dead-tree version
07:46:52 <SamB> you can even leave comments yourself ;-)
07:47:15 <SamB> (thankfully the comments are collapsable, and start out collapsed)
07:47:37 <SamB> strangely one of the authors also wrote a book about mercurial ...
07:48:00 <Axman6> @where rwh
07:48:00 <lambdabot> is http://www.realworldhaskell.org/blog/
07:48:00 <koeien_> why is that strange?
07:48:13 * SamB doesn't like mercurial ;-)
07:48:18 <koeien_> i like darcs but not *because* it's written in Haskell
07:48:31 * SamB likes bzr, though
07:48:44 <SamB> (so I'm not being languagist!)
07:48:47 <koeien_> mercurial was a bit unstable for me
07:48:59 * cypher- likes perforce
07:49:03 <SamB> bzr is unstable in the Debian sense
07:49:03 <cypher-> but perforce costs $$$
07:49:09 <SamB> meaning it changes a lot
07:49:20 <SamB> but usually it works mostly okay
07:49:20 <cypher-> they should have free unlimited version for students, MSDNA-style
07:49:22 <koeien_> but git seems to have more followers these days, it seemed horribly complex when i looked at it
07:49:34 <SamB> git has a really simple core
07:49:39 <SamB> I mean, conceptual core
07:49:48 <koeien_> hmm.
07:49:49 <SamB> but a huge mess of code
07:49:53 <SamB> and UI
07:49:56 <SamB> and so forth
07:50:23 <SamB> I really wish that darcs/git hybrid thing hadn't died
07:50:33 <SamB> (it was just darcs patched to handle git repositories)
07:50:54 <SamB> er, or would be revived
07:51:45 <SamB> it would be really cool if darcs patches could be shipped around and turned into git commits eventually ;-)
07:51:57 <Nafai> Yeah, git does have a simple core.  The ui isn't so bad these days, I don't mind it
07:52:12 <SamB> Nafai: well, it's still a bit ... big!
07:52:43 <Nafai> True, but I don't use most of it most of the time, just a simple sub-set for my workflow, so it doesn't bother me
07:52:52 <int-e> SamB: but darcs patches are pretty useless without access to the patches in their context. (transitively)
07:53:34 <fasta> Is there an overview article containing the differences between the various version control systems which lists which problem they exactly solve? Something including for example how Smalltalk systems solve the problem too, would even be better.
07:54:06 <SamB> int-e: hmm?
07:54:30 <SamB> int-e: I don't understand why you have a "but" at the beginning of that statement
07:54:45 <int-e> SamB: you wanted to send around darcs patches
07:55:05 <SamB> Nafai: I just wish it were easier to find that part :-(
07:55:40 <SamB> (and that searching the entire Linux kernel history wasn't so slow ;-)
07:55:51 <Nafai> Heh
07:55:55 <Nafai> I agree though
07:56:09 <int-e> SamB: for that to be useful you'll have to know how to apply them. and you can't apply a hunk without having the complete context it originated from. (in principle this is the same with context diffs, but darcs tends to drop the context, making it much harder.)
07:56:15 <Nafai> But just like Haskell has taken some time for me to learn, I think it will pay off
07:56:49 <fasta> SamB: slow?
07:57:37 <fasta> SamB: gitk seems pretty fast to me.
07:57:48 <n0nsense> hi there
07:57:55 <n0nsense> has anyone here tried postmaster?
07:57:59 <n0nsense> http://postmaster.cryp.to/
08:00:35 <Twey> Based purely on the terrible site design and colour scheme, I scorn it.
08:01:42 <byorgey> n0nsense: looks like a neat concept.
08:01:50 <byorgey> it's like the xmonad of MTAs.
08:03:08 <tombee> "Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird."
08:03:54 <Twey> Sounds like LYAH.
08:04:08 <tombee> It's this Simon Peyton-Jones video :)
08:04:46 <Twey> Oho :-P
08:04:48 <byorgey> @quote slipped
08:04:48 <lambdabot> No quotes match. My brain just exploded
08:05:07 <byorgey> @remember SPJ Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
08:05:07 <lambdabot> Nice!
08:06:06 <tombee> I hope lambdabot is written in Haskell?
08:06:07 <tombee> :P
08:06:16 <Twey> Well duh
08:06:16 <byorgey> tombee: no, PHP
08:06:25 * Twey chuckles.
08:06:56 <byorgey> tombee: also, welcome! =)
08:07:32 * byorgey presents tombee with a shiny lambda made of 100% pure function
08:07:56 <tombee> Thank you byorgey :)
08:08:08 <tombee> Simon Peyton-Jones is very amusing.
08:08:21 <tombee> 37:30 into that video made me lol :)
08:08:45 <Twey> byorgey: You mean funktion.
08:09:12 <byorgey> oh, I do? whoops
08:09:19 <byorgey> I hate it when I say what I didn't know I didn't mean
08:09:28 <tombee> (++) :: [a] -> [a] -> [a]
08:09:34 <Twey> I know, it's terrible.
08:09:40 <n0nsense> byorgey: yes, the concept looks nice
08:09:44 <tombee> Funny :)
08:09:48 <byorgey> > [1,2,3] ++ [4,5]
08:09:49 <lambdabot>   [1,2,3,4,5]
08:09:50 <n0nsense> but we don't get it installed :D
08:10:07 <n0nsense> so we're looking for someone who is more experienced xD
08:10:25 <byorgey> n0nsense: well, good luck with that!
08:12:06 <tombee> so how does [a] -> ([a] -> [a]) 'concatenate' two lists together
08:12:36 <Axman6> well, that's a type
08:12:40 <Axman6> so, it doesn't really
08:12:42 <tombee> Ah that's what I was thinking :)
08:12:56 <byorgey> @src (++)
08:12:56 <lambdabot> []     ++ ys = ys
08:12:56 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:12:56 <lambdabot> -- OR
08:12:56 <lambdabot> xs ++ ys = foldr (:) ys xs
08:12:59 <tombee> Was thinking this is fine for defining the type of the operation, but I can't see how it actually does it :p
08:13:08 <byorgey> tombee: right. =)  the definition is above.
08:13:10 <vixey> tombee: it means ((++) x) y :: [a] with x :: [a] and y :: [a]
08:13:17 <Axman6> what it's saying is that that function takes a list of as, and returns a function that takes a list of as, and returns a list of as
08:14:15 <tombee> awesome thanks :)
08:15:11 <tombee> [16:12:52] <lambdabot> []     ++ ys = ys
08:15:11 <tombee> [16:12:52] <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:15:16 <tombee> Very elegant
08:16:25 <Axman6> crap, movable type just lost 2/3 of the post i was writing!
08:16:43 <fasta> Append () v v
08:16:44 <fasta> Append (a' :. v1) v2 v3 => Append (a :. (a' :. v1)) v2 (a :. v3)
08:16:44 <fasta> Append (a :. ()) v (a :. v)
08:17:00 <fasta> tombee: concatenate in the type system ;)
08:18:10 <fasta> It is kind of weird that type-level programming is considered to be something special, as essentially it is just another formal system.
08:21:58 <Gracenotes> fasta: it' like prolog
08:22:00 <Gracenotes> *it's
08:22:11 <Gracenotes> in spirit anyway :)
08:22:22 <NEEDMOAR> fasta: sure, but I don't think that types were intented to do type-level programming, that's why it's fun to program on it.
08:22:27 <fasta> Gracenotes: yes, I know. Someone should just write a compiler from prolog to this to get better debugging.
08:22:45 <NEEDMOAR> It's like programming with C++'s templates.
08:27:49 <McManiaC> is anyone here using postmaster??
08:31:21 <EvilTerran> fasta, Gracenotes, NEEDMOAR: have you guys seen dependent type systems>
08:31:22 <EvilTerran> ?
08:33:00 <fasta> EvilTerran: Yes, but I never actually applied them to something useful.
08:33:53 <alongnick> hi, i've been searching around for information about the haskell bindings for dbus
08:34:09 * EvilTerran notes the standard "vector type parameterised by its length" example
08:34:15 <alongnick> does anyone know where i can find example code about how to use those bindings?
08:34:24 <fasta> EvilTerran: For example in Coq, there is a fairly large amount of stuff one needs to learn to effectively use the system. There are tactics with an associated language and of course there is a standard library which one needs to learn and it is not like there are as much resources on Coq as on other languages.
08:35:02 <EvilTerran> fasta, yeah, Coq strikes me as befuddlingly different to even haskell
08:35:16 <fasta> EvilTerran: the reference contains some typing rules, but the typing rule which should state that Type(i) is contained in Type(j) seemed a bit undefined.
08:35:29 <EvilTerran> Agda looks more straightforward to me; have you tried that?
08:36:01 <tombee> (.) :: (b->c) -> (a->b) -> (a->c)
08:36:01 <tombee> (f. g) x = f(g x)
08:36:05 <fasta> EvilTerran: A long time ago, but I believe at that time it didn't compile. Things are better now, AFAIK.,
08:36:14 <tombee> what is he actually 'getting at' with this definition?
08:36:18 * SamB wonders how all these question marks got in this description in aptitude:
08:36:24 <SamB> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4570#a4570
08:36:29 <fasta> EvilTerran: still, Coq is much more mature.
08:36:34 <tombee> @src (.)
08:36:34 <lambdabot> (f . g) x = f (g x)
08:37:00 <EvilTerran> tombee, that definition is the actual haskell definition of the function composition operator, (.)
08:37:25 <tombee> so is f . g x different to f g x ?
08:37:36 <Cale> tombee: yes
08:37:40 <EvilTerran> well, yes
08:37:52 <Cale> tombee: (f . g x) y = f (g x y)
08:37:55 <EvilTerran> they're both different to (f . g) x, and to f (g x), too
08:38:06 <Cale> (f g x) y = f g x y
08:38:07 <EvilTerran> but (f . g) x = f (g x)
08:38:38 <mm_freak> @pl \(x,y) -> (y,x)
08:38:38 <lambdabot> uncurry (flip (,))
08:39:03 <EvilTerran> tombee, note that function application (the " " in "f x", as it were) binds tighter than any operator
08:39:28 <EvilTerran> and is left-associative, so, eg, f x y = (f x) y
08:41:03 <mm_freak> isn't there a nice way to express this in terms of arr, (>>>), first and second?
08:41:09 <skorpan> is there any way to make happy print the unused terminals it found?  it finds an unused terminal, but i don't know which one.
08:41:21 <EvilTerran> tombee, anyway, the point of (.) is that, if you have f = g . h, then f x = (g . h) x = g (h x)
08:41:32 <EvilTerran> mm_freak, well, there's (snd &&& fst)
08:41:52 <EvilTerran> ?type snd &&& fst
08:41:53 <lambdabot> forall a b. (a, b) -> (b, a)
08:42:35 <mm_freak> hmm…  given that (&&&) doesn't exist…  i guess, i can define it in terms of the above
08:42:41 <Deewiant> ?ty arr (\b -> (b,b)) >>> first snd >>> second fst
08:42:43 <lambdabot> forall a b. (a, b) -> (b, a)
08:42:44 <EvilTerran> ?hoogle &&&
08:42:44 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
08:42:53 <EvilTerran> mm_freak, what do you mean &&& doesn't exist?
08:43:04 <Deewiant> > (arr (\b -> (b,b)) >>> first snd >>> second fst) (1,2)
08:43:05 <lambdabot>   (2,1)
08:43:10 <tombee> I THINK i get it :P
08:43:11 <Apocalisp> @check \x -> uncurry (flip (,)) x == (fst &&& snd) x
08:43:12 <lambdabot>   "OK, passed 500 tests."
08:43:28 <Apocalisp> @type (.)
08:43:28 <mm_freak> EvilTerran: i'm trying to implement snd &&& fst with only arr, (>>>), first and second…  it's an exercise
08:43:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:43:35 <EvilTerran> i see
08:43:37 <SamB> EvilTerran: Agda does seem a much simpler system in many ways than Coq, yes
08:44:05 <Cale> > filter (not . null) ["Here", "is", "a", "", "list", "of", "", "words", "", "and", "some", "empties", "", "", ""]
08:44:06 <lambdabot>   ["Here","is","a","list","of","words","and","some","empties"]
08:44:07 <SamB> but Coq is indeed far more mature (though not stagnant!)
08:44:24 <Cale> tombee: ^^ there's a good simple example
08:44:24 <Deewiant> mm_freak: Look at ?src (&&&) if you want to cheat
08:44:49 <mm_freak> Deewiant: (&&&) is easy to implement, but i thought, there may be a nice alternative
08:45:04 <Cale> tombee: null :: [a] -> Bool, and not :: Bool -> Bool, so (not . null) :: [a] -> Bool as well, and we can pass it as a parameter to filter
08:45:12 <Apocalisp> tombee: Notice that in the type for (.), the first argument modifies the return type of the second argument.
08:45:14 <SamB> Agda has a similar style of interaction to that of Epigram
08:45:45 <Deewiant> mm_freak: I don't think it can be much reduced from what I gave above (which just inlines &&& and ***), but feel free to try :-)
08:47:01 <mm_freak> Deewiant: i see
08:47:51 <tombee> @src not
08:47:51 <lambdabot> not True   =  False
08:47:51 <lambdabot> not False  =  True
08:47:54 <tombee> @src null
08:47:54 <lambdabot> null []     = True
08:47:54 <lambdabot> null (_:_)  = False
08:48:16 <skorpan> wouldn't null _ = False suffice in that one?
08:48:46 <Deewiant> Yes, just as not _ = True in the other one
08:48:48 <Peaker> heh cool, dons posted a link to my mlist on the Haskell subreddit... Unfortunately, I haven't documented it yet, and apparently its really needed for mlist
08:48:52 <EvilTerran> skorpan, yeah, but some people prefer to keep patterns non-overlapping when possible. it's a matter of personal style, really
08:49:05 <skorpan> EvilTerran: so it's just as fast?
08:49:17 <Deewiant> It should be.
08:49:28 <EvilTerran> the difference would be negigable if existant
08:49:38 <fasta> It seems Agda2 and Coq are based on about the same type-system?
08:49:50 <EvilTerran> if one's "fast enough", the other will be. that's all the worrying about speed necessary here.
08:49:57 * wli likes to keep patterns both non-overlapping and exhaustive.
08:50:03 <tombee> filter (not null) ["Here", "is", "a", "", "list", "of", "", "words", "", "and", "some", "empties", "", "", ""]
08:50:15 <EvilTerran> ?type not null
08:50:15 <skorpan> :t exclude
08:50:16 <tombee> > filter (not null) ["Here", "is", "a", "", "list", "of", "", "words", "", "and", "some", "empties", "", "", ""]
08:50:17 <lambdabot>     Couldn't match expected type `Bool'
08:50:17 <lambdabot>            against inferred type `[a] -> Bool'
08:50:17 <lambdabot>     In the first argument of `not', namely `null'
08:50:18 <lambdabot> Not in scope: `exclude'
08:50:18 <lambdabot>   Couldn't match expected type `Bool'
08:50:25 <skorpan> @pl not . filter
08:50:26 <lambdabot> not . filter
08:50:29 <EvilTerran> ?type not . null
08:50:30 <lambdabot> forall a. [a] -> Bool
08:50:38 <EvilTerran> tombee, "not null" is a type error
08:50:46 <skorpan> uhm what
08:50:48 <tombee> yeh was just seeing what it did
08:50:50 <skorpan> not . filter?
08:50:58 <EvilTerran> tombee, because "not" expects something of type Bool instead of [a] -> Bool
08:51:02 <skorpan> @pl \x -> filter (not . x)
08:51:03 <lambdabot> filter . (not .)
08:51:18 <skorpan> okay so i'll just ask... is there any function which does the opposite of filter?
08:51:34 <EvilTerran> skorpan, filter . (not.)?
08:51:45 <skorpan> EvilTerran: but i meant something in prelude
08:52:15 <skorpan> `exclude' would be a perfect name for it anyways
08:52:36 <augustss> skorpan: snd . partition p
08:52:38 <byorgey> skorpan: no, there isn't.
08:52:44 <Twey> exclude = filter .: not
08:52:45 <Twey> :-P
08:53:07 <skorpan> > let exclude = filter .: not in exclude (>1) [1,2,3]
08:53:08 <lambdabot>   Not in scope: `.:'
08:53:08 <EvilTerran> Twey, wouldn't that be (filter .) . not, and hence differnet?
08:54:06 * Twey ponders.
08:54:31 * EvilTerran stibbons.
08:54:35 <Twey> Haha
08:54:43 <EvilTerran> :D
08:55:06 * Twey considers the problem, then breaks with a PLEASE REINSERT UNIVERSE AND REBOOT
08:55:26 <Twey> Head-hurting :-P
08:55:36 <Twey> @let (.:) = (.) . (.)
08:55:37 <Asztal> ((filter .) . not) f xs = filter . (not f xs)
08:55:37 <lambdabot>  Defined.
08:55:48 <Twey> > filter .: not (>5) [1..5]
08:55:49 <lambdabot>       The section `(> 5)' takes one argument,
08:55:50 <lambdabot>      but its type `Bool' has none
08:55:51 <Asztal> err, no . on the right
08:55:54 <Twey> > (filter .: not) (>5) [1..5]
08:55:56 <lambdabot>   Couldn't match expected type `a1 -> a -> Bool'
08:55:59 <Twey> Yeah, seems so :(
08:56:13 <EvilTerran> ?type filter .: not
08:56:14 <lambdabot>     Couldn't match expected type `a1 -> a -> Bool'
08:56:14 <lambdabot>            against inferred type `Bool'
08:56:14 <lambdabot>     Probable cause: `not' is applied to too many arguments
08:56:46 <Asztal> :type length .: filter
08:57:01 <Asztal> ?type length .: filter
08:57:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
08:59:08 <doserj> > let (.::) = (. (.)) . (.) in (filter .:: not) (>5) [1..10]
08:59:09 <lambdabot>   [1,2,3,4,5]
09:01:50 <kadaver> to make a database you have some sort of treestructure that you serialize and that is basically it seen from a very, very high level?
09:03:04 <fasta> kadaver: from a very high level it is a function of type {0,1}*->{0,1}* ;)
09:04:10 <kadaver> a function from and to itself?
09:04:33 <Twey> But that database is read-only.
09:04:40 <fasta> kadaver: no, I was just pointing out that there is no such thing as a "database" per se.
09:04:47 <kadaver> i guess not
09:04:49 <fasta> Twey: why would it be?
09:04:52 <kadaver> loads of different ones
09:05:11 <Twey> A function is pure
09:05:24 <tombee> If you can understand haskell, does it make lambda calculus easier to understand? :p
09:05:29 <fasta> Twey: yes, and your memory hardware also implements a pure function.
09:05:31 <Twey> Yes
09:05:44 <Twey> fasta: Huh?
09:05:52 <Twey> fasta: Memory is writeable.
09:06:01 <Twey> That means that a read function is not referentially transparent.
09:06:15 <Twey> Reading a given address will not always produce the same result.
09:06:37 <fasta> Twey: Just think about it for some time and if you still haven't figured it out by tomorrow, ask again.
09:06:58 <mmorrow> will looking up '1' in an IntMap always produce the same result?
09:07:06 <Twey> ... uhm...
09:07:12 <Twey> mmorrow: In a given IntMap, yes
09:07:22 <mmorrow> any IntMap
09:07:29 <Twey> Of course not
09:07:44 <Twey> Er, wait
09:07:48 <Twey> Any given IntMap, yes
09:07:53 <Alpounet> is there a library for reading RSS feeds and extracting some informations ?
09:09:00 <byorgey> Alpounet: sure.  just go to http://hackage.haskell.org/packages/archive/pkg-list.html  and search for 'RSS'
09:09:18 <Twey> If you're trying to say that writing memory creates a whole new memory, then you've no point still: it's not *returned*, as it's accessed the same way, as if it were the old memory
09:09:37 <Twey> (quite apart from the physical realities of the situation, but I guess that's something we needn't concern ourselves with too much)
09:09:55 <byorgey> kadaver_: generally, databases admit more general structures than just trees
09:10:43 <byorgey> kadaver_: for example, if you want to think about 'traditional' relational databases with tables containing rows and so on, you can have rows in different tables both referring to one another
09:10:58 <Alpounet> byorgey, right, thanks !
09:11:54 <tombee> how can I define a function in GHCi
09:12:26 <Berengal> tombee: "let <declaration>"
09:12:34 <fasta> Twey: where did I say it was "returned"?
09:12:44 <tombee> ah cool thanks
09:12:46 <Philonous> @hoogle (a->b) -> (b->c) -> (a->c)
09:12:46 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
09:12:46 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
09:12:46 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
09:14:28 <Alpounet> byorgey, I would appreciate a tutorial but ... :-p
09:15:05 <byorgey> Alpounet: I sympathize.
09:15:20 <Alpounet> byorgey, thanks.
09:20:35 <Apocalisp> kadaver_: From a relational perspective, a database is a tuple of predicates, along with the extensions of each of those predicates consisting of tuple values such that a given predicate holds for each value in its extension.
09:29:25 <dcoutts> g'morning dons
09:29:59 <dcoutts> dons: HP release today! will you have any time to help out today?
09:31:21 <Lemmih> @seen edwardk
09:31:22 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 3h 41m 51s ago.
09:33:54 <wli> It looks like I can use any prime p with p `mod` 8 == 1 || p `mod` 8 == 7 to reduce the search space by eliminating square roots of 2's inverse mod p for each p.
09:36:02 <bogner> dcoutts: HP release, you say? that
09:36:05 <bogner> 's exciting
09:36:20 <tombee> HP? :S
09:36:26 <dcoutts> bogner: aye
09:36:31 <bogner> tombee: haskell platform
09:36:33 <dcoutts> http://haskell.org/haskellwiki/Haskell_Platform
09:37:00 <tombee> Oh nice
09:38:10 <dcoutts> I'll ask you to try a pre-release tarball in a sec.
09:38:47 <kadaver> is haskell fast enough to do realtime mp3 decoding?
09:39:36 <dcoutts> kadaver: probably, if you use appropriate data representation
09:40:09 <mxc> kadaver - if you can parallelize the algorithm, its a great platform
09:47:30 <billls> Hello. I'm trying to define a function which checks to see if the last char in a string is a '?' and if not, adds one. I'm currently just checking to see if it's '.' '?' or '!' as that was a function I was required to define earlier. Can't work out how to add the '?' if it doesn't exist. Code is here if anyone wouldn't mind looking http://foxyurl.com/1kz
09:47:34 <billls> thanks in advance!
09:48:52 <Cale> billls: xs ++ "?" ?
09:49:08 <billls> ahh of course
09:49:16 <billls> always forget strings are lists :/
09:49:18 <billls> thanks
09:49:22 <Cale> no problem :)
09:49:51 <billls> does that mean i need to change it's definition to a list also?
09:49:56 <billls> [string] and (x:xs) ?
09:50:51 <Cale> Er...
09:50:52 <lament> :t "Hello"
09:50:53 <lambdabot> [Char]
09:51:06 <lament> billls: a string is a list of characters, [Char]
09:51:13 <billls> maybeAddQuesMark :: String -> String
09:51:13 <billls> maybeAddQUesMark x = if notPunct (last x) then xs ++ "?"
09:51:14 <Cale> I don't see why you would need to change the type.
09:51:17 <lament> but String is a synonym
09:51:28 <billls> is that i currently have, it's telling me I have an "unexpected ')'"
09:51:28 <Cale> billls: You forgot the else
09:51:42 <byorgey> billls: you need an 'else' clause
09:51:47 <Cale> Every 'if' needs both a 'then' and an 'else'
09:52:31 * nlogax calls the guards
09:53:08 <billls> how do I say else.. do nothing? :P
09:53:20 <lament> billls: your function is supposed to return something
09:53:32 <lament> billls: how would you use it otherwise?
09:53:33 <Cale> billls: It still have to produce a result -- what result?
09:53:37 <Cale> has*
09:53:56 <billls> It's just meant to return the original string either with a '?' added, or as it was if one already existed
09:54:18 <lament> so what should the else clause return?
09:54:38 <billls> x ?
09:54:48 <Cale> billls: yeah, try it :)
09:55:11 <lament> > last []
09:55:12 <lambdabot>   * Exception: Prelude.last: empty list
09:55:42 <lament> billls: your function would still die when passed an empty list
09:55:47 <lament> *empty string
09:56:37 <billls> maybeAddQuesMark x [] = [] ja ?
09:58:18 <tombee> When typing into GHCi, you cant do like 'let mylast :: [a] -> a'
09:58:25 <tombee> It tells me that it lacks an accompanying binding
09:59:06 <Saizan> tombee: let mylast :: [a] -> a; mylast = ...
09:59:50 <tombee> Ah ok
10:01:44 <billls> It's giving me a missing binding variable for 'maybeAddQuesMark'. Code -> http://foxyurl.com/1kL
10:02:14 <Saizan> billls: x vs. xs
10:03:15 <billls> I don't understand sorry
10:03:39 <Saizan> in the then branch you use a variable named xs
10:03:53 <Saizan> but there's no xs in scope there
10:04:02 <Saizan> the argument is called x
10:04:40 <byorgey> tombee: with that said, it's usually much easier to type stuff into a file, and load it into ghci with :load
10:04:52 <byorgey> tombee: then when you change something in the file you can just type :r in GHCi to reload it
10:05:12 <tombee> Ah good ok.
10:05:31 <billls> ah yeah, thanks. Even with it switched to x it's still giving me a missing binding error in the type sig
10:05:38 <billls> sorry for these majorly basic questions.
10:05:58 <Saizan> billls: can you paste the whole error?
10:06:17 <billls> ERROR file:.\coursework.hs:10 - Missing binding for variable "maybeAddQuesMark" in type signature
10:06:19 <Saizan> billls: oh, wait
10:06:33 <byorgey> billls: check the capitalization of 'u'
10:06:34 <Saizan> burp_: it's a matter of Ques vs. QUes
10:06:44 <billls> gah.
10:06:50 <billls> stupid font.
10:06:52 <billls> thank you :)
10:07:17 <byorgey> billls: no need to apologize for basic questions, BTW. =)
10:07:25 <tombee> here's one for you byorgey, if I have a type mylast :: [a] -> a
10:07:28 <byorgey> everyone asked them at some point.
10:07:29 <tombee> and I pass in []
10:07:39 <tombee> what would you expect as a?
10:07:47 <byorgey> tombee: I wouldn't.
10:07:52 <tombee> can a be [] ?
10:07:54 <byorgey> tombee: there's nowhere to get an a from.
10:08:05 <tombee> so how do you defend against that
10:08:27 <Saizan> you can only use error there
10:08:27 <byorgey> tombee: another way to say it is,  any function with type  [a] -> a  cannot be a total function.
10:08:36 <Saizan> or change the type
10:08:40 <byorgey> it will necessarily not be able to produce any output for [] as input.
10:08:57 <byorgey> tombee: what I would do is change the type to  mylast :: [a] -> Maybe a
10:09:04 <tombee> 'Maybe' ?
10:09:05 <byorgey> tombee: do you know about Maybe?
10:09:10 <byorgey> ok, I see not =)
10:09:12 <byorgey> @src Maybe
10:09:19 <byorgey> er...
10:09:19 <lambdabot> data Maybe a = Nothing | Just a
10:09:24 <tombee> :p
10:09:26 <byorgey> there we go =)
10:09:46 <byorgey> tombee: a value of type 'Maybe a' is either  Nothing, or  Just x  where x has type  a
10:09:56 <tombee> Ok, so does that allow me to write some sort of function definition for [] now ?
10:10:05 <byorgey> tombee: right.
10:10:09 <tombee> 'Nothing'
10:10:12 <byorgey> exactly.
10:10:35 <byorgey> you will also have to change the definition of another case slightly.
10:10:44 <vixey> mylast x = unsafePerformIO (catch (last x) Nothing Just) -- something like that yeah?
10:10:57 <byorgey> tombee: because now instead of returning an 'a' you have to return a 'Maybe a'
10:11:08 <byorgey> so if you have an 'a' you have to wrap it up using 'Just'
10:11:21 <byorgey> > 3 :: Int
10:11:22 * vixey saw someone actually doing that on haskell mailing list..
10:11:22 <lambdabot>   3
10:11:26 <byorgey> > Just 3
10:11:28 <lambdabot>   Just 3
10:11:33 <byorgey> @type (Just 3)
10:11:34 <lambdabot> forall t. (Num t) => Maybe t
10:11:57 <byorgey> vixey: that's... wow.  that's horrible.
10:12:27 <byorgey> tombee: is this making sense?  probably now you should just go off and try to make it work. =)
10:12:40 <Cale> vixey: hahaha
10:13:37 <tombee> Yeah I'm trying atm byorgey :)
10:13:46 <tombee> I'm practising those 99 problems.
10:14:42 <tombee> trying to return the last item of a list
10:16:40 <byorgey> cool
10:21:18 <tombee> byorgey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2338#a2338
10:21:27 <tombee> Hmm :p
10:21:36 <byorgey> tombee: very nice!
10:21:42 <tombee> It does't work
10:21:47 <byorgey> uh, except the type =)
10:21:59 <tombee> Where am I going wrong :<
10:22:07 <byorgey> it should just be [x] -> Maybe x
10:22:21 <vixey> If you don't write the type annotation it works
10:22:30 <byorgey> adding an 's' to a type doesn't mean anything special
10:23:22 <tombee> Ah, I don't really understand why that works.
10:23:28 <byorgey> tombee: why what works?
10:23:44 <tombee> To me it makes more sense with the [xs]
10:24:19 <tombee> ah sorry
10:24:19 <Berengal> Try to read [x] as "list of several <x>es"
10:24:25 <tombee> yeah i just clicked then
10:24:39 <tombee> ive got a list of xs, and to return an x it would be a different type
10:24:40 <Berengal> Then [xs] would become "list of several <xs>es"
10:24:48 <tombee> got it :)
10:29:12 <Lemmih> Productivity 100.0% of total user, 110.5% of total elapsed
10:30:00 <Lemmih> Yay, the mutator runs 1.1seconds per second. (:
10:31:35 <tombee> @src (!!)
10:31:35 <lambdabot> xs     !! n | n < 0 = undefined
10:31:35 <lambdabot> []     !! _         = undefined
10:31:35 <lambdabot> (x:_)  !! 0         = x
10:31:35 <lambdabot> (_:xs) !! n         = xs !! (n-1)
10:33:14 <kadaver> would anyone be interested nin a datastructure with O(1) lookup,insert,delete and O(N) sort?
10:33:47 <kadaver> is there  a way to have dependent types in haskell?
10:33:48 <kadaver> {-# LANGUAGE DependentTypes #-}
10:33:51 <Berengal> kadaver: This should be interesting...
10:33:52 <kadaver> something like that
10:34:54 <vixey> what would you use it for?
10:35:11 <rieux_> kadaver: http://scholar.google.com/scholar?q=mcbride+faking
10:35:36 <Peaker> kadaver: such a structure is impossible (unless you have lenient definitions of O() there), isn't it?
10:35:36 <mauke> I'm pretty sure you can't have O(1) lookup/insert/delete in the general case
10:36:06 <eu-prleu-peupeu> hmm
10:36:16 <mauke> otherwise, a trie
10:36:24 <eu-prleu-peupeu> i ran the haskell version of the occlusion test on my computer, it finished in 12minutes!!
10:36:31 <eu-prleu-peupeu> the c version finished in 5 secs
10:36:51 <eu-prleu-peupeu> then i changed the vector to !Double !Double !Double, and it finished in 4 minutes
10:37:04 <eu-prleu-peupeu> still a long way to go till it reaches C performance
10:37:27 <mux> mmm, where is the new locale package? I can only see the old one
10:37:32 <Alpounet> byorgey, my program is finished... :-) feed is powerful !
10:37:35 <Peaker> C makes operational semantics clear, Haskell makes denotational semantics clear..
10:38:02 <skorpan> @pl \x -> putStrLn $ ("II " ++ x)
10:38:02 <lambdabot> putStrLn . ("II " ++)
10:38:54 <byorgey> Alpounet: oh, good!
10:39:55 <Alpounet> byorgey, it was for a weekly news-like program
10:41:33 <tombee> eu-prleu-peupeu: So if haskell is _THAT_ slow whats the point in us using it? :)
10:42:14 <eu-prleu-peupeu> hmm
10:42:26 <eu-prleu-peupeu> the haskell code there is not very well thought
10:42:29 <Guest8461> suppose I have two infinite lists X, Y
10:43:24 <Guest8461> i can cross them with a list comprehension:   z = [(a,b) | a <- x, b <-y]
10:44:03 <vixey> kadaver
10:44:25 <billls> I'm trying to write a function to pick a response from a list of lists of words, given an integer and a list.. looks something like this, but wont work :x any suggestions?
10:44:26 <billls> pickResponse :: Int -> [Phrase] -> Phrase
10:44:26 <billls> pickResponse n ps = ps !! n mod (length ps)
10:44:40 <mauke> `mod`, not mod
10:44:43 <Guest8461> but no matter how many elements I  'take' from z, I will only see pairs (a,b) with   a   being the first element of  list x
10:44:48 <mauke> also the precedence may be wrong
10:44:56 <vixey> swap n and mod
10:45:09 <mauke> pickResponse n ps = cycle ps !! n
10:45:51 <leimy> > cycle [1]
10:45:51 <leimy> @users
10:45:51 <lambdabot> Maximum users seen in #haskell: 658, currently: 632 (96.0%), active: 13 (2.1%)
10:45:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:46:20 <Athas> Growth!
10:46:44 <Athas> Are there any statistics for the increasing/decreasing popularity of Haskell over the years?
10:46:52 <Athas> > cycle []
10:46:53 <lambdabot>   * Exception: Prelude.cycle: empty list
10:47:41 <vixey> how do you measure popularity
10:48:11 <gnuvince> There was a graph of trac and mailing list activity IIRC that showed an increase
10:48:23 <gnuvince> As well as the number of hackage contributions per year
10:49:23 <Athas> That's a good enough metric for me.
10:50:02 <Twey> I've solved it!  The reason Haskell isn't popular is because it's not crappy enough!
10:50:22 <Berengal> Twey: The solution to what?
10:50:30 <Trafalgard> It's more difficult to understand than perl
10:50:31 <Twey> More bugs = more reports = more activity = more popularity!
10:50:42 <Trafalgard> I mean, for god's sake...
10:50:44 <Twey> Trafalgard: Clearly, you have never tried to read someone else's Perl
10:50:46 <Trafalgard> PROGRAMMABLE SEMICOLONS
10:50:58 <mauke> Twey: I have!
10:51:03 <Gracenotes> no. the real problem is that Haskell isn't Enterprise enough
10:51:05 <lament> ;; ;;;; ; ;;; ;;; ;; ;;;
10:51:12 <Trafalgard> Oh the hunamity!
10:51:14 <eu-prleu-peupeu> ahah
10:51:26 <Trafalgard> We have no idea what that could mean!
10:51:48 <eu-prleu-peupeu> "programmable semicolons" is for programming what "programmable pixels" is for computer graphics
10:51:57 <Berengal> > let ;; ;;;; ;; ;;;; ;; ;; ;; in 5
10:51:58 <lambdabot>   5
10:51:59 <Trafalgard> I think it needs a real GUI
10:52:06 <vixey> lol
10:52:08 <true\false> A real GUI?
10:52:14 <true\false> I'm assuming you mean IDE.
10:52:19 <Trafalgard> er, typo.
10:52:21 <Trafalgard> yeah.
10:52:21 <vixey> > let ;; ;;;; ;; ;;;; ;; ;; ;; in () where
10:52:23 <lambdabot>   ()
10:52:32 <Gracenotes> > let __  =[] in do { "so"  ;__;  "sad" }
10:52:34 <lambdabot>   ""
10:52:35 <heavensrevenge> hey
10:52:55 <Athas> I don't care much for traditional IDEs, but most Haskell environments do appear to be quite primitive.
10:52:56 <Trafalgard> I've been typotastic the past few days
10:52:59 <Gracenotes> alo
10:53:02 <Gracenotes> heavensrevenge:
10:53:02 <Trafalgard> except they aren't really typos
10:53:02 <billls> my pickResponse function chucks up loads of errors, i'm guessing it's because i've used map and words incorrectly. Code here if anyone would be kind enough to take a look http://foxyurl.com/1lm
10:53:05 <Trafalgard> they're just the wrong word
10:53:05 <Gracenotes> er, alo.
10:53:18 <Twey> Athas: The primary Haskell environment is emacs.  What's wrong with that?
10:53:23 <Trafalgard> I never seem to make REAL typos...
10:53:27 <mauke> Twey: it's not vim.
10:53:29 <Athas> I'm really interested in development environments, so I hope I can make one for Haskell too.  It seems like you should be able to infer pretty much all relevant information from a Haskell program.
10:53:39 <Twey> That is an advantage.  I like my hands the shape they are.  :-P
10:53:42 <heavensrevenge> hows it goin
10:53:47 <Athas> Twey: Maybe I'm just missing the super-package.  Is there something better than haskell-mode?
10:53:49 <vixey> Athas you should hook up with the people in this channel that keep pretending they want to write an IDE
10:53:51 <Berengal> leksah seems nice, except it crashes whenever I type two characters
10:53:56 * edwardk returns to hacking on his parser
10:54:06 <Trafalgard> There *was* one in visual studio, which was apparently the most advanced, but it was for an older version of it and it isn't supported anymore
10:54:08 <vixey> maybe if there's enough motivated people SOMEONE will write a program
10:54:13 <Twey> Trafalgard: And yet, somehow I manage to read packages off Hackage easily, but packages off CPAN not at all
10:54:20 <Trafalgard> and of course that's windows-only
10:54:24 <Twey> There are hundreds
10:54:44 <Twey> There's Leksah, a KDevelop plugin, haskell-mode, vim, emacs, Yi...
10:54:52 <Twey> What more could you realistically want?
10:55:04 <Trafalgard> I know abuot some of those, but none of them really parse it properly
10:55:10 <Berengal> Twey: I count six, not hundreds... ;)
10:55:11 <Trafalgard> I'm using eclipse, which doesn't either
10:55:12 <Twey> They don't really need to
10:55:18 <Trafalgard> they don't need to?
10:55:19 <Twey> Berengal: Note the dots :-P
10:55:20 <Trafalgard> I disagree
10:55:26 <Athas> Leksah looks interesting, but I'd prefer something integrated with Haskell.
10:55:33 <Athas> Integrated with Emacs, sorry.
10:55:35 <Twey> The prime qualification for requiring a good IDE is being a crappy language
10:55:40 <Athas> Something like SLIME would be awesome.
10:55:56 <Berengal> Athas: haskell-mode for emacs has support for ghci
10:55:58 <Trafalgard> Having used visual studio with c#, using the existing IDEs for haskell feels like being handicapped
10:56:00 <Philippa_> Twey: I've yet to use a language that wouldn't benefit somehow from a sufficiently good IDE
10:56:03 <leimy> Athas: I want a pre-built Leksah for Mac OS X... it's a bit of a pain to build
10:56:09 <leimy> needing the head bits of repos
10:56:17 <Athas> Berengal: that's not really enough.
10:56:23 <Twey> Philippa_: FORTH
10:56:35 <leimy> Visual Studio is surprisingly good
10:56:50 <edwardk> i'm actually a big fan of the idea of a good haskell IDE. i use vim all day for it, but I liked the visual studio integration
10:56:54 <leimy> Berengal: I've never tried the ghci integration in the Emacs mode for haskell
10:57:06 <Trafalgard> ghci seems to use a ton of RAM
10:57:09 <Philippa_> Twey: eh. You wouldn't rather have a reasonable editor built into your FORTH image where there's room?
10:57:22 <p_l> Trafalgard: does it go to 512G range? ;P
10:57:35 <Berengal> I'm looking forward to when leksah actually works properly on my machine. From what I've seen it really is an awesome IDE
10:57:45 <Trafalgard> probably doesn't free up resources because it has no way to know you're done with stuff :P
10:57:53 <Twey> Philippa_: What possible features could a FORTH editor have or need other than standard text-editing?  :-P
10:58:13 <Philippa_> Twey: displaying the definition of a word on request?
10:59:09 <skorpan> if i want to completely reset my haskell installation with all packages etc, what do i do?
10:59:15 <Trafalgard> In visual studio I could get information on function parameters and return type of a function I was looking at or was starting to type, go straight to a function I was looking at without having to do a find-in-files/project search, and fifty million other things I'm forgetting
10:59:28 <Trafalgard> but those are the two main things I miss in eclipse
10:59:40 <Twey> Philippa_: That's not really an editor feature
10:59:59 <Trafalgard> eclipse is more or less acting as a dumb text highlighter and compiler
11:00:02 <edwardk> twey: we're talking about IDEs not editors =)
11:00:43 <Trafalgard> it tries to have some information on types, but it's semi-broken, apparently
11:00:46 <Twey> Touché
11:01:02 <Athas> Being able to see the type of any expression at any time would be pretty useful.
11:01:05 <Philippa_> anyway, to the extent FORTH wouldn't benefit, it's not really due to good properties of the language
11:01:16 <Philippa_> or at least, not directly
11:01:20 <Gracenotes> Twey: what the hell, man? was that an accent? :o
11:01:23 * Trafalgard leaves now
11:03:28 <Twey> Gracenotes: o.@
11:03:57 <Twey> Gracenotes: I understand not the you funnylanguage
11:04:08 <eu-prleu-peupeu> hmm
11:04:15 * mauke idly wonders if http://cpansearch.perl.org/src/MAUKE/Data-PrioQ-SkewBinomial-0.03/lib/Data/PrioQ/SkewBinomial.pm can be understood by other people
11:04:48 <Gracenotes> Twey: that's because the but in the explanation through which funny though.
11:04:53 <Athas> It's only important whether a program can be understood by an experienced program.
11:04:56 <Athas> It's only important whether a program can be understood by an experienced programmer.
11:05:05 <kadaver> vixey?
11:06:24 <voker57_> @hoogle Int -> Float
11:06:24 <lambdabot> Prelude toEnum :: Enum a => Int -> a
11:06:24 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
11:06:25 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
11:06:38 <mauke> voker57_: fromIntegral
11:08:06 <voker57_> thanks
11:09:57 <vixey> kadaver, if you had that option what would you do with it
11:11:26 <dons> dcoutts: yes
11:11:27 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:12:06 <dcoutts> dons: ok, lemme push my patches, there's a couple things left to do with the generic installer. I've also got a draft web page. I could do with help with either.
11:12:19 <Gracenotes> looks like I'll need some specular lighting
11:12:58 <Gracenotes> dons: oh, by the way, uvector's been segfaulting on me :\ built from cabal
11:13:22 <dons> grab the darcs version
11:13:39 <Gracenotes> my problem was mainly with hPutU
11:13:41 <dons> oh, and build with -fsafe
11:13:50 <Alpounet> damned
11:13:51 <Gracenotes> dons: mm, I did. via cabal anyway
11:14:04 <dons> darcs?
11:14:05 <Gracenotes> so, *tries darcs*
11:14:06 <dons> cabal?
11:14:06 <Alpounet> the parsec package on debian seems to be bugged
11:14:26 <Gracenotes> dons: er, I built with cabal install and -fsafe
11:14:51 <Gracenotes> but, lemme see.
11:15:12 <edwardk> hrmm, ghc doesn't expose the Any1 type from GHC.Prim does it? something about it not being possible to put it in interface files?
11:15:30 <kadaver_> a
11:16:34 <edwardk> er Any2 i'd guess
11:16:44 <Gracenotes> hm. is it possible to use cabal to install a .tar.gz?
11:17:04 <Gracenotes> er, or however it's stored in Darcs.
11:17:07 <Berengal> I'm pondering reversible computations...
11:17:41 <mahogny> reversible computations are rather limited
11:18:02 <Berengal> It's useful to say that for all reversible computations, if the result of the computation is reversed you get the initial value back
11:18:24 <dcoutts> Gracenotes: for an unpacked package you can just cd into the dir and cabal install
11:18:40 <Berengal> But is it also useful to say that if the result of any computation run in reverse is also run forwards you get the initial value back?
11:18:46 <Gracenotes> cool :) I'll try that
11:19:06 <Berengal> mahogny: I know, but they could be useful for isomorphic translations
11:19:15 * edwardk cracks open ST and STM to see if he can do the same thing as with IO
11:20:21 <edwardk> ok, ST and IO are basically the same beast, so the internals of ST fit the ran transformer format
11:20:21 <mahogny> Berengal, it takes a whole new way of thinking to be useful. something like deleting an element from a set is common and non-reversible
11:20:57 <Berengal> mahogny: You could always just put it back...
11:21:16 <mauke> reversible f x = (x, f x)
11:21:28 <mahogny> Berengal, you can think of a delete as the opposite of : , but at some point you might want to stop waste memory
11:21:32 <mahogny> Berengal, reversibleness+outside world is even more problematic
11:21:37 <kadaver_> which *BSDs have ghc?
11:21:49 <Berengal> mahogny: It's a good thing we live in a pure world then, isn't it?
11:21:54 <edwardk> hrmm and so is STM: STM (State# RealWorld -> (# State# RealWorld, a #)) -- so its all a matter of branding
11:22:00 * mux thinks he should really start using Data.Accessor
11:22:05 <vixey> kadaver: why do you refuse to answer my question to you
11:22:15 <kadaver_> which one?
11:22:17 <Gracenotes> uh... is there a way to specify which inventory file to use for darcs? http://code.haskell.org/~dons/code/uvector/_darcs/ it seems to be under hashed_inventory here
11:23:03 <Berengal> mahogny: Anyway "deleting an element from a set" isn't reversible, but "deleting this element from a set" is
11:24:43 <Gracenotes> in particular "darcs failed:  Failed to download URL http://code.haskell.org/~dons/code/uvector/_darcs/inventory : HTTP error (404?)"
11:25:30 <Gracenotes> is this a known issue/ :x
11:27:57 <Gracenotes> hm. I'll just use recursive wget
11:28:08 <ivan-kanis> when you use do in a function does it mean the return value is always IO something?
11:28:21 <vixey> ne
11:28:23 <vixey> no*
11:28:24 <Twey> No
11:28:31 <Berengal> ivan-kanis: It means it's always a monad
11:28:38 <Gracenotes> it's always something something, at least
11:28:39 <Twey> The return value of *that block* will be a monad of some kind
11:28:41 * mux downloads data-accessor and data-accessor-template
11:28:47 <Gracenotes> and the first something will be a monad. IO is a common monad
11:28:54 <Twey> But the monad may be run before returning
11:29:01 <mux> the newest extensions in GHC 6.10, record punning and record wildcards, are great but still not enough
11:29:08 <Twey> So the containing function need not have a monadic return value
11:29:09 <vixey> > do 4
11:29:11 <lambdabot>       No instance for (Num (t t1))
11:29:11 <lambdabot>        arising from the literal `4' at <in...
11:30:04 <ivan-kanis> can i define multiple expression in a function without 'do'? Does it evaluate the last expression as the return value? sorry for being such a noob...
11:30:05 <Berengal> > runIdentity (do x <- return (1+2); return x)
11:30:06 <lambdabot>   3
11:30:32 <Berengal> ivan-kanis: A function is always a single expression
11:30:42 <Berengal> (Which may in turn contain other expressions)
11:31:59 <vixey> > (\x -> (\x -> runIdentity (do return x)) runIdentity (do return x)) ()
11:32:00 <tombee> Are applications in Haskell left associative?
11:32:01 <lambdabot>   ()
11:32:23 <Berengal> tombee: Yes
11:32:30 <tombee> Ok thanks :)
11:32:38 <Berengal> tombee: Assuming you meant function applications
11:32:52 <tombee> yes i do :)
11:33:02 <kadaver> vixey: which question?
11:33:30 <eu-prleu-peupeu> there goes linux: http://svpow.files.wordpress.com/2009/03/leopard-seal-pulling-the-head-right-off-a-penguin.jpeg
11:33:57 <rieux_> ivan-kanis: what are you trying to do exactly?  supposing you could "sequence" multiple expressions in the body of a function, what would it do?
11:36:10 <Medved> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:36:18 <Medved> probably old
11:38:05 <mib_80kdpq> hey guys
11:38:45 <Twey> Medved: Very :-P
11:38:45 <ivan-kanis> rieux_: where do I paste
11:39:03 <rieux_> @paste
11:39:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:39:07 <mib_80kdpq> accumulate [5,4,3,2,1]  -> [,1510,6,3,1]
11:39:37 <mib_80kdpq> how do i write that using foldr
11:40:08 <mib_80kdpq> how do i write accumulate [5,4,3,2,1]  -> [,1510,6,3,1] using a foldr
11:41:01 <rieux_> mib_80kdpq: take a look at scanr1
11:41:34 <kadaver> dons: why do you like Arch linux so much?
11:41:49 <kadaver> > scanl [1..5]
11:41:50 <lambdabot>   Couldn't match expected type `a -> b -> a'
11:41:51 <billls> can I still use last to find the last char of a sentence if my sentence is built of a list of strings?
11:41:53 <ivan-kanis> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4574
11:41:54 <kadaver> > scanl (*) [1..5]
11:41:55 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
11:41:55 <lambdabot>        arising from a u...
11:41:59 <kadaver> > scanl (*) 1 [1..5]
11:42:00 <lambdabot>   [1,1,2,6,24,120]
11:42:04 <kadaver> > scanl1 (+) [1..5]
11:42:05 <lambdabot>   [1,3,6,10,15]
11:42:14 <Berengal> > foldr (\a b -> if null b then [a] else (a + head b):b) [] [5,4,3,2,1]
11:42:15 <lambdabot>   [15,10,6,3,1]
11:42:17 <kadaver> > scanr1 (+) [1..5]
11:42:18 <lambdabot>   [15,14,12,9,5]
11:42:33 <ivan-kanis> rieux_: I am trying to make a program that scans directory, and helps removing the most voluminous data
11:43:23 <Berengal> billls: Yes. Strings are simply [Char]s
11:43:28 <ivan-kanis> I am struggling with getRecursiveContent, I want to make it recursive
11:44:13 <rieux_> i see... so you have the type: getRecursiveContents :: FilePath -> IO ()
11:44:35 <ivan-kanis> yes, i think i want to turn it FilePath -> Int
11:44:37 <rieux_> do you know what type (map getRecursiveContents dir) has, then?
11:45:06 <ivan-kanis> [IO ()]
11:45:13 <rieux_> yeah...
11:45:13 <ivan-kanis> I think
11:45:17 <Olathe> > scanl1 (*) [1..5]
11:45:19 <lambdabot>   [1,2,6,24,120]
11:45:29 <rieux_> assuming that dir :: [FilePath]
11:45:54 <rieux_> so you have there a list of IO computations returning ().  are you trying to run those computations?
11:46:05 <billls> so, endsInPunct x = isPunct (last x), where x is a list of strings will work Berengal ? (isPunct returns true if the char is a punctuation symbol)
11:46:12 <Olathe> > scanr1 (+) [5,4..1]
11:46:14 <lambdabot>   [15,10,6,3,1]
11:46:20 <rieux_> or are you saying you want getRecursiveContents to *return* some result, rather than just display it?
11:46:46 <Gracenotes> ugh. uvector IO is excruciatingly slow
11:47:08 <Berengal> > let endsInPunct x = last x == '.' in endsInPunct "hello." -- Assuming the string isn't empty, this'll work
11:47:08 <ivan-kanis> rieux_: eventually it would recurse in a separate thread
11:47:09 <lambdabot>   True
11:47:25 <Gracenotes> at least, compared to Binary
11:47:41 <ivan-kanis> rieux_: i would like it to return a DataTree
11:47:49 <Gracenotes> there doesn't seem to be any monad support ;_;
11:48:13 <billls> yeah, the thing the function takes is a list of strings though, so i'm thinking i need to pick the last string, then check the last char of it. sound likely?
11:48:58 <billls> it takes a Phrase. Phrase = [word], word = string
11:49:00 <Berengal> billls: If you only want to check the last string, then yes
11:49:16 <Berengal> Then that makes sense
11:49:21 <mib_80kdpq> can't it be done using a foldr?
11:49:28 <rieux_> ivan-kanis: hmmm.  do you mean Data.Tree.Tree, or something else?
11:49:36 <Berengal> mib_80kdpq: Sure it can
11:49:45 <Berengal> > foldr (\a b -> if null b then [a] else (a + head b):b) [] [5,4,3,2,1]
11:49:46 <lambdabot>   [15,10,6,3,1]
11:49:52 <ivan-kanis> rieux_: the one I defined on top
11:49:54 <ivan-kanis> data DirTree = DirTree {
11:49:54 <ivan-kanis>       files :: [(String, Int)],
11:49:54 <ivan-kanis>       dirs :: [(DirTree, Int)]}
11:49:54 <ivan-kanis>  
11:50:15 <rieux_> oh, i see.  you said DataTree, and I couldn't find that.  DirTree.  good, good
11:50:23 <ivan-kanis> whoopsy
11:50:42 <ivan-kanis> yes a list of dir with their size and a list of files with their size
11:50:45 <Gracenotes> or... is it just because I didn't compile it?
11:50:57 <rieux_> do you want the names of the dirs in there?
11:51:27 <rieux_> anyway: do you understand at this point why the type of getRecursiveContents will probably be FilePath -> IO DirTree, not FilePath -> DirTree?
11:51:54 <Olathe> > let f (x:xs) = scanl (-) (div (x*(x + 1)) 2) (x:xs) in f [5,4..1]
11:51:56 <lambdabot>   [15,10,6,3,1,0]
11:52:40 <ivan-kanis> rieux_: yes i need the name of the dir somewhere
11:53:04 <ivan-kanis> rieux_: is it because i am running some real world function in getRecursiveContents ?
11:53:54 <rieux_> yeah.  getRecursiveContents does IO.
11:54:35 <rieux_> so, do you know how to construct the result that you want?  you could start by just constructing the non-recursive portion of the result and returning that (and changing the type).
11:56:11 <mib_80kdpq> the answer
11:57:19 <ivan-kanis> rieux_: I think I know, I use return at the end of the function...
11:57:37 <rieux_> yeah.  so instead of returning (), you can return a DirTree, yes?
11:57:55 <ivan-kanis> rieux_: yes, thanx i'll work on it
11:57:56 <rieux_> then you'll have to figure out how to deal with the recursion, but I don't think that will be too difficult
12:03:25 <kadaver> are SPJs kids into Functional programming too?
12:03:51 <Berengal> Why don't you ask them?
12:05:35 <Gracenotes> -.-
12:05:58 <augustss_> ?
12:06:29 <Gracenotes> so, implementing 'sequence' for uvector -- should I use consU?
12:06:37 <Gracenotes> @src sequence
12:06:37 <lambdabot> sequence []     = return []
12:06:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:06:37 <lambdabot> --OR
12:06:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:06:44 <burp_> > cosh(10^^(-8)) :: CReal
12:06:45 <lambdabot>   1.0000000000000000500000000000000004166667
12:06:47 <Gracenotes> the main thing i that consU isn't a constructor
12:06:51 <Gracenotes> *is
12:06:58 <burp_> is CReal limited to a fixed precision?
12:07:13 <Gracenotes> the term is 'arbitrary precision'
12:07:34 <Gracenotes> > showCReal 1000 (cosh(10^^(-8)))
12:07:36 <lambdabot>   "1.000000000000000050000000000000000416666666666666668055555555555555558035...
12:07:37 <burp_> do you know how to change precision?
12:07:37 <ziman> you choose precision when printing the number
12:07:41 <burp_> ok.. thanks
12:07:56 <ziman> it's lazy, if i understand correctly
12:07:59 <Gracenotes> and you can print a number with a precision of, say, 100 one time, and 1000 the next
12:08:21 <Gracenotes> it goes as far as you need it to go. as opposed to some big-decimal libraries, which require you to specify at the outset
12:08:38 <burp_> thats great
12:08:48 <Gracenotes> it is lazy... a CReal itself is internally a function that, given the previous number, gives one with greater precision
12:08:59 <augustss_> But it gets slower and slower
12:09:20 <Gracenotes> mm :.
12:09:34 <burp_> sadly CReal has no cabal package
12:09:45 <Gracenotes> @hackage numeric
12:09:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric
12:09:56 <burp_> it's in there? :D
12:10:03 <Gracenotes> argh. always forget the name...
12:10:11 <augustss_> yes
12:10:16 <Gracenotes> @hackage numbers
12:10:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
12:11:16 <dcoutts> testing feedback please: http://haskell.org/~duncan/haskell-platform-2009.0.0.tar.gz
12:11:26 <burp_> thanks
12:14:45 <Athas> I don't have need of it at the moment, but how do you normally handle POSIX signals in Haskell?
12:15:09 <Athas> Say you want to implement the HUP signal by rereading the configuration file (as is normal Unix behavior).  How would you structure your program?
12:15:48 <kadaver> can gtk2hs buttons be made better looking in an easy way?
12:15:48 <kadaver> im thinking about writing a desktop environment in haskell
12:15:59 <kadaver> just for myself
12:16:52 <dcoutts> kadaver: yes, that's what the gtk+ theme does
12:17:16 <dcoutts> kadaver: see for example in gnome, the theme switching applet, it's actually adjusting the gtk+ theme
12:22:31 <billls> any insight on how to make my endsInPunct function work properly (it's meant to return true if the input phrase ends in a punctuation symbol. code here http://foxyurl.com/1mv
12:24:30 <Gracenotes> hm. is there any way to speed up .. do { q <- replicateM swrite (generateRandomPair chainwalker 16 g); hPutU handle (toU q) }? in the IO monad
12:24:43 <Gracenotes> I'm not that familiar with the internals of uvector, so have no idea ...
12:25:01 <Gracenotes> there's no replicateMU... or a sequenceU, for that matter
12:25:14 <Alpounet> billls, endsInPunct = isPunct . last
12:26:18 <billls> ERROR file:.\coursework.hs:32 - Type error in explicitly typed binding
12:26:19 <billls> *** Term           : endsInPunct
12:26:19 <billls> *** Type           : Phrase -> [Char] -> Bool
12:26:19 <billls> *** Does not match : Phrase -> Bool
12:27:52 <augustss_> dcoutts: it builds on macos
12:28:14 <Alpounet> billls, what's line 32 ?
12:28:28 <dcoutts> augustss_: oh, nice, thanks
12:28:50 <billls> Alpounet: endsInPunct ps = isPunct . last
12:28:52 <dcoutts> augustss_: actually that's just as well since we'll not have the osx installer ready for a couple weeks yet probably
12:29:37 <augustss_> dcoutts: that's not a problem if it
12:29:44 <augustss_> it's easy to build
12:29:55 <billls> is it because Phrase is a list of strings, and the way endsInPunct is written at the moment isn't taking that into account
12:30:25 <Xeones> anybody know why xmonad in jaunty jackalope might work (although the windows are a little all over the place) in gnome, but if i do a pure xmonad session from login, it is just a black screen and mod-shift-enter does nothing?
12:30:41 <augustss_> dcoutts: who/what decides what goes into the platform?
12:30:53 <Alpounet> billls, that's not what Iv' written
12:30:56 <dcoutts> augustss_: from now on it'll be decided by the libraries mailing list
12:30:58 <Alpounet> I've*
12:31:19 <dcoutts> augustss_: with a steering committee to make sure that things do get discussed properly and decided.
12:31:26 <Alpounet> billls, endsInPunct = isPunct . last OR if you want : endsInPunct ps = isPunct (last ps)
12:31:35 <Alpounet> if it's clearer for you
12:31:47 <dcoutts> augustss_: want to volunteer for the steering committee?
12:31:50 <billls> ah I see, sorry, didn't spot you'd removed the ps
12:32:05 <augustss_> dcoutts: perhaps
12:32:33 <burp_> how can I convert float/double to creal?
12:32:38 <dcoutts> augustss_: we'll send out something about it to the libs list once we've got the release out.
12:33:00 <Alpounet> billls, the former tells what endsInPunct is with respect to other functions, without any variables
12:33:01 <dcoutts> augustss_: the main point is that decision making authority remains with the community via the libs mailing list.
12:33:10 <Alpounet> this style is said to be "pointfree"
12:33:23 <Alpounet> point designing "variables" here
12:33:32 <augustss_> dcoutts: that seems mostly ok
12:33:38 <Alpounet> . is just the function composition operator
12:33:40 <Alpounet> @src (.)
12:33:41 <lambdabot> (f . g) x = f (g x)
12:33:41 <Saizan> however with Phrase = [String], then you want isPunct (last (last ps)), i guess
12:33:46 <billls> ok
12:34:00 <burp_> @hoogle Double -> CReal
12:34:00 <lambdabot> Warning: Unknown type CReal
12:34:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:34:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:34:06 <Alpounet> Saizan, oh, right.
12:34:13 <Jem11> billls: endsinPunct = isPunct . last . last
12:34:40 <Alpounet> Thought Phrase was String, sorry.
12:34:47 <billls> yeah sorry, my bad
12:34:48 <augustss_> > realToFrac 1.1 :: CReal
12:34:49 <lambdabot>   1.1000000000000000888178419700125232338905
12:34:57 <billls> i'm getting lost in all the string, list stuff myself
12:35:07 <billls> thanks Jem11
12:35:09 <burp_> good :>
12:35:15 <burp_> :t realToFrac
12:35:16 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:35:39 <zoheb> @src (last)
12:35:39 <lambdabot> Source not found. My brain just exploded
12:35:48 <augustss_> > realToFrac 1.1 :: Rational
12:35:49 <lambdabot>   2476979795053773%2251799813685248
12:37:07 <zoheb> @src last
12:37:07 <lambdabot> last [x]    = x
12:37:07 <lambdabot> last (_:xs) = last xs
12:37:07 <lambdabot> last []     = undefined
12:39:24 <zoheb> billls, You might find this helpful http://www.haskell.org/pipermail/reactive/2008-November/000054.html
12:41:36 <billls> thanks, will have a read
12:42:08 <cypher-> @src undefined
12:42:09 <lambdabot> undefined =  error "Prelude.undefined"
12:43:32 <kadaver_> "Relying on complex tools to manage and build your system is going to hurt the end users. [...] "If you try to hide the complexity of the system, you'll end up with a more complex system". Layers of abstraction that serve to hide internals are never a good thing. Instead, the internals should be designed in a way such that they NEED no hiding."
12:43:37 <kadaver_> http://en.wikipedia.org/wiki/Arch_linux
12:43:48 <kadaver_> wow so true about how I feel about programming
12:43:49 <roconnor> huh?
12:45:56 <Athas> I think that's a far too simplistic and general view.
12:46:06 <Athas> There's nothing wrong with abstraction.
12:46:50 <rieux_> that sounds like a problem with badly-designed abstraction.  well-designed abstraction is the most powerful thing we've got.
12:47:34 * roconnor tosses out Haskell, and writes machine code
12:47:40 <Jebdm> I do think that it makes a bit of sense in this case (Arch Linux), provided you're willing to learn how the system works.
12:47:44 <zoheb> I was wondering how often is GHC downloaded every year? Just trying to figure out how popular haskell is
12:48:11 <Jebdm> But that's mainly because operating systems are a bit of a mess.
12:48:12 <Athas> That's impossible to say, as many no doubt download GHC from 3rd party sites.
12:48:40 <Twey> Yeah, like distro packages.
12:48:56 <Twey> In fact, I'd be very surprised if distro packages didn't make up the majority of GHC downloads.
12:49:07 <zoheb> some are packaged with distros, but for real work you need to keep up with the latest GHC
12:49:19 <zoheb> distros are usually quite behind
12:49:26 <Berengal> zoheb: Or run arch
12:49:29 <Jebdm> (When you throw a bunch of abstractions on, I mean.  For instance, take Ubuntu's (and Debian's?) default behavior of modifying GRUB settings by itself, but doing it in text.)
12:49:29 <Twey> zoheb: No
12:49:38 <Athas> Is that really necessary?
12:49:57 <Twey> 1) For ‘real work’ you want a stable version 2) Most distros are reasonably up-to-date
12:50:00 <Athas> I'm working on some software where I need GHC 6.10, so I can't use Debian-GHC, despite the fact that I would prefer to do so.
12:50:19 <kadaver_> not wrong with abstraction,l on the contrary, abstraction is key. but a lot of software claim to be abstraction when in reality it is obfuscation
12:50:47 <Athas> I dislike abstraction that significantly reduces the power of the underlying strata.
12:51:07 <Athas> Or reduces it for no particular reason.
12:51:19 <Twey> That would be a poorly-designed abstraction.
12:51:29 <Athas> Indeed, but they are common.
12:51:30 <zoheb> I was trying to use Happs and it did not play well with my Ubuntu GHC install
12:51:39 <Athas> Power is all too often sacrificed in the name of simplicity.
12:51:39 <zoheb> had to upgrade GHC
12:51:44 <Berengal> Athas: map significantly reduces the power of recursion
12:51:52 <Twey> zoheb: Ubuntu sucks; film at eleven.
12:52:16 <Athas> Berengal: well, that's not really the kind of abstraction we are talking about here.
12:52:22 <Twey> Athas: A well-designed abstraction should provide for controlled access to the underlying stratum where necessary
12:52:23 <Athas> Berengal: map is not meant to replace recursion.
12:52:33 <Twey> folds and unfolds are :-P
12:53:02 <Berengal> Athas: Well, an abstraction that is meant to replace something is a bad abstraction
12:53:38 <Jebdm> Berengal: What about 'structured programming' replacing gotos?
12:53:41 <Athas> Berengal: how so?  It seems naturally to build a layer of higher abstraction on top of something else.
12:53:41 <Berengal> You need more than one abstraction to properly replace something, like the map-filter-fold-unfold family replacing recursion
12:54:11 <Twey> Some abstractions completely replace things
12:54:16 <Twey> Some don't
12:54:39 <Twey> E.G. a kernel completely replaces direct hardware access
12:55:12 <Twey> But a GUI does not completely replace the console
12:55:15 <Twey> (yet)
12:55:15 <Athas> And a well-designed kernel only loses unimportant (or undesirable) features in the process.
12:55:19 <Twey> Right
12:55:33 <rieux_> (:), head, tail, [], and null completely replace malloc and pointer dereference
12:55:38 <Twey> It should provide access to all the important features of the original, just in a different and presumably better manner
12:55:51 <Twey> iratsu: Heh
12:55:52 <Athas> Same goes with almost any programming language compared to machine code... most lose the ability to write self-modifying code.
12:56:06 * Jebdm enjoys manual memory management.
12:56:10 <Athas> They provide an abstract virtual machine that you program instead, but I believe we can all agree that they are way easier to work with most of the time.
12:56:19 <Jebdm> Are there any popular languages with the ability to write self-modifying code?
12:56:22 <kadaver_> how many LOC could a haskell kernel be?
12:56:23 <Twey> Lisps
12:56:26 <Athas> Common Lisp technically can.
12:56:32 <Twey> FORTH
12:56:35 <rieux_> TCL
12:56:36 <Twey> Well, anything technically can
12:56:37 <Berengal> Twey: The "important features" is the key here. 'map' provides access to one important feature of recursion (mapping over values) provided you only care about mapping over values
12:56:39 <Athas> Ruby and Python can too.
12:56:49 <Twey> The main thing is that the manner in which they provide it
12:56:52 <zoheb> so whats a good distro to use for haskell development? arch linux? I plan on installing it on VirtualPC
12:56:55 <Athas> Well, Lisp can do it portably and without exploiting undefined behavior.
12:56:59 <Twey> You can rewrite your own executable in anything
12:57:03 <Jebdm> Right, right, but I mean in a not-magic way like Python (etc.)
12:57:04 <Twey> But it's not the same language
12:57:14 <edwardk> jebdm: malbolge =)
12:57:17 <Twey> zoheb: Arch is one of the best at the moment, yeah.
12:57:21 <Berengal> And while most users may only care about mapping values, over in a corner somewhere there's a grumpy bearded recursion-hacker writing pure recursions in ed.
12:57:36 <edwardk> jebdm: if only because all code is self modifying under malbolge
12:57:40 <Athas> In Lisp, you can just construct a function definition, 'eval' it and rebind some symbol to it.
12:57:46 <Athas> Perfectly within the defined semantics.
12:57:56 <Athas> In C, you have to go beyond the standard AFAIK.
12:58:08 <Athas> In Ruby... well, it's defined by the implementation anyway.
12:58:11 <Jebdm> Hmm.. I guess you can do that in Python et al pretty easily as well.
12:58:23 <kadaver_> how big is House in LOC?
12:58:25 <Athas> Right, I believe you can do it in most dynamic languages.
12:58:39 <Jebdm> But it doesn't have quite the same quality to it as self-modifying assembly.
12:58:44 <Twey> Athas: Don't need to use eval()
12:58:51 <zoheb> How long does an arch install survive before I have to upgrade th OS?
12:58:55 <Twey> Python has closures and everything is first-class
12:59:00 <zoheb> Ubuntu gives me 18 months
12:59:06 <Twey> zoheb: Arch is rolling-release
12:59:10 <rieux_> yeah.  you're talking about dynamically generating code, but dynamically *modifiying* it might be a bit more involved.
12:59:15 <Twey> You never have to do a full reinstall
12:59:15 <Jebdm> Hmm, that's the difference--in assembly, the code itself is mutable, whereas in dynamic languages it's immutable.
12:59:24 <Twey> Just update regularly
12:59:26 <Jebdm> But you can rebind names, which gives the same effect.
12:59:30 <rieux_> e.g., i give you a function pointer, and you futz with the internals of the function.
12:59:33 <edwardk> jebdm: bah, just go dig up a commodore 64 and start writing efficient 6502/6510 assembly. you'll be self-modifying your code in no time, if only because there is no efficient way to blit, etc without doing so
12:59:42 <Twey> Jebdm: But not in Lisps
12:59:47 <zoheb> that sounds good
12:59:57 <Jebdm> Twey: Example?
13:00:03 <Twey> Jebdm: No
13:00:17 <Athas> In a slightly contrived example, you could just use the standard Lisp function 'disassemble', but the output of that is pretty obviously not standardised.
13:00:29 <Twey> Lisps give you access to existing Lisp code in the form of lists
13:00:32 <Athas> I think maybe some Lisps store the source of the function?
13:00:39 <Athas> Not all Lisps.
13:00:39 <Twey> Yeah
13:00:42 <Jebdm> Yeah, that's the only way I could think of.
13:00:42 <zoheb> ghc seems to be on 6.10.2 or arch, looks promising
13:00:48 <edwardk> Jebdm: also, most linkers introduce a form of self-modifying code in terms of the dispatch thunks, they replace themselves with jumps after they link themselves
13:00:52 <zoheb> Do we upgrade with apt-get?
13:00:57 <Twey> Athas: If necessary, it's possible to recompile them
13:01:09 <Jebdm> But if the Lisp is compiling, or JITing, then you're basically just modifying source and then recompiling, which ends up being the same thing as with the dynamic languages.
13:01:47 <p_l> Jebdm: s/recompiling/compiling/
13:02:00 <Athas> Anyway, I have an actual thorny Haskell question...
13:02:02 <edwardk> jebdm: the problem with directly self-modifying code these days is the instruction cache pipeline has gotten longer and longer, so the boundary between when you make the modification and when it is seen is blurrier and blurrier
13:02:05 <Jebdm> Ja, si.
13:02:07 <Athas> I don't have need of it at the moment, but how do you normally handle POSIX signals in Haskell?  Say you want to implement the HUP signal by rereading the configuration file (as is normal Unix behavior).  How would you structure your program?
13:02:26 <Twey> Athas: With System.Posix.Signal
13:02:32 <Athas> I wonder if instruction caches are invalidated when you use self-modifying code...
13:02:46 <p_l> Athas: That's what cache control instructions are for
13:02:50 <Twey> Er, System.Posix.Signals, sorry.
13:02:50 <rieux_> in my experience, you may need to tell them.
13:02:53 <Twey> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html
13:02:55 <edwardk> athas: its not that smart. you need to tell it
13:03:00 <Athas> Twey: but the handlers just seem to return IO (), how would I make them do such a thing?
13:03:06 <p_l> Athas: and you need them even for non-self modifying code
13:03:33 <Alpounet> @hoogle Right
13:03:33 <lambdabot> Prelude Right :: b -> Either a b
13:03:33 <lambdabot> Data.Either Right :: b -> Either a b
13:03:33 <lambdabot> Control.Arrow right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
13:03:38 <edwardk> athas: one of the ways used to distinguish old chips in the 386/486 era was to just modify at different distances from the instruction and count how many steps it took before your change was seen ;)
13:03:50 <Athas> edwardk: ouch.
13:04:29 <edwardk> athas: it worked but it got more convoluted as time went on, hence CPUID, etc.
13:04:53 <Twey> Say you  want to implement the HUP signal by rereading the configuration file (as is normal Unix behavior). — installHandler SigHUP (Catch reloadConfig) Nothing
13:05:15 <Twey> Where reloadConfig is an IO action that... reloads the config
13:05:31 <Twey> Oh, I'm sorry
13:05:35 <Twey> It's sigHUP, not SigHUP
13:05:40 <Twey> Apparently it's a CInt
13:05:41 <p_l> Athas: Cache control instructions might useful for other things (like informing cpu that it would be nice to preload some data...)
13:05:56 <Athas> How would I define reloadConfig such that the behavior would be seen by the program at large?
13:06:12 <rieux_> Athas: without doing anything unseemly, I think you'd need an IORef
13:06:33 <rieux_> and you'd only observe the changes when you actually re-read the IORef
13:06:48 <Athas> Ohh, I've seen that type around, but never actually looked into it.
13:06:51 <Twey> I'd prefer an MVar for concurrency's sake, but yeah
13:06:59 <rieux_> Twey: good point
13:07:08 <Athas> That looks interesting.
13:07:18 <Athas> I will keep them in mind for when I embark on my project.
13:10:03 <Athas> Alright, next question, are there any non-trivial Literate Haskell programs around?
13:10:48 <Jebdm> isn't GHC literate?
13:12:10 <edwardk> jebdm: large portions of it anyways
13:12:37 * vixey still didn't understand what 'literate' means beyond having lot of comments
13:12:39 <jleedev> it depends if you mean "ends in .lhs, has lots of comments" or "literate enough for knuth"
13:13:22 <edwardk> jebdm: its written using .lhs, but they don't seem to be all that fond of actually putting comments in there ;)
13:13:31 <rieux_> i think literate implies that the comments are intended for consumption along with the source, not along with an API reference a la haddock
13:13:33 <Berengal> Literate enough for Knuth = run it through tex and get a paper?
13:13:47 <Jebdm> What is literate programming? To quote Dr. Knuth:   "The main idea is to regard a program as a communication to human beings rather than as a set of instructions to a computer."
13:13:50 <Athas> I just want to be able to compile my next project as an article as well as a program.
13:14:19 <rieux_> are you familiar with lhs2TeX?
13:14:22 * bremner likes latex style .lhs sometimes for explaining calculations/algorithms, not necessarily for publication
13:14:24 <edwardk> athas: i find haddock to be a better fit for me than .lhs, more people know how to read it
13:14:35 <Athas> No, I'm completely new to Literate Haskell.
13:14:47 <edwardk> and a paper is less useful than having hyperlinked documentation to me
13:15:05 <rieux_> depends on what you want it for.
13:15:07 <edwardk> otoh, maybe if i reversed that mindset i might get around to publishing stuff
13:15:15 <Athas> It's not for reference documentation.
13:15:23 <rieux_> athas: i can send you the source for an article in literate haskell, if you like, as an example
13:15:43 <Athas> rieux_: is it a multi-file source?
13:15:45 <rieux_> yeah
13:15:56 <Athas> Oh, then I would like to see it.
13:18:31 <Nafai> Athas: The source linked from this article is literate haskell, it's a 75 page pdf, http://jekor.com/article/is-haskell-a-good-choice-for-web-applications
13:20:32 <Athas> Nafai: that looks exactly like what I'm going to make myself!  Thanks!
13:21:03 <Nafai> np
13:28:03 <vixey>     The debugger tale illustrates that a little purpose-built language can evolve essentially at random, have no clear design, no consistent grammar or parser, and no name, and yet endure and grow in shipping operating systems for more than 40 years. In the same time period, many mainstream languages came and went into the great beyond... For purpose-built languages, a deep connection to a task and the user community for that task is often worth more than
13:28:03 <vixey> clever design or elegant syntax.
13:28:37 <Elly> vixey: what're they referring to?
13:28:39 <Jebdm> What's that from?
13:28:56 <Elly> oh, LTU
13:29:01 <Elly> http://lambda-the-ultimate.org/node/3299
13:29:22 <Jebdm> Elly: Thanks
13:29:28 <billls> i'm meant to be defining two types using the functions words and map, i'm not sure how to incorporate them. any help would be really really appreciated. code: http://foxyurl.com/1nm
13:30:28 <defun> Hi, I am interested in compiler development. Just wanted to know if there was a technical reason the GHC RTS is written in C/Cmm and not Haskell itself?
13:30:29 * vixey what is the point in tinyurly.
13:31:09 <Jebdm> bills: map words swearStrings should do it, methinks
13:31:26 <Jebdm> Do you understand what map and words do?
13:31:52 <billls> yeah, the thing is, the spec is telling me to define swears and repeats using them
13:32:00 <billls> rather than swearStrings and repeatStrings
13:32:07 <billls> is that wrong?
13:32:23 <defun> umm, anyone?
13:32:34 <billls> swears = map words [["how","rude"], ["no","need","to","swear"], ["thats","not","very","nice"]]
13:32:36 <billls> etc
13:32:47 <Jebdm> unwords I think would do that
13:33:15 <Saizan> defun: well, for example in the RTS you've to implement the management of memory
13:33:47 <defun> Saizan, so memory related tasks of a compiler should be done in C, rather than haskell?
13:33:50 <Saizan> defun: and doing that in haskell, where a GC is nearly assumed, would be problematic
13:34:07 <defun> I see.
13:34:26 <defun> Does anyone here know of any literature on language/compiler development.
13:34:34 <Berengal> To write a managed environment you need to do it in an unmanaged one. Otherwise it would be an exercise in pointlessness
13:34:50 <defun> Berengal: got it.
13:34:54 <defun> Makes sense.
13:34:54 <c_wraith> defun, at what level?  introductory?
13:35:01 <defun> yes.
13:35:07 <vixey> Calculating Compiler - Erik Meijer
13:35:14 <c_wraith> Appel's book wasn't bad.
13:35:16 <Saizan> well, there's a good book from SPJ on implementing lazy functional languages available online
13:35:33 <c_wraith> Modern Compiler Implementation was the name of it.
13:35:33 <vixey> Appel has at least 4 books on this subject
13:35:47 <vixey> my favorite is Compiling with Continuations
13:36:06 <rieux_> my favorite for beginners is the tiger book
13:36:35 <c_wraith> I guess I should have said, "the one I used for my compilers course" :)
13:36:50 <defun> thanks.
13:37:04 <defun> greatly appreciated.
13:41:35 <cypher-> defun: dragon book
13:43:11 * cypher- wanted to read compiling with continuations, but hasn't got the tiem
13:43:13 <cypher-> *time
13:44:31 <rieux_> the rabbit paper (http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.pdf) is always worthwhile
13:47:21 <Apocalisp> @type mapM
13:47:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:47:28 <Apocalisp> @type Data.Traversable.traverse
13:47:29 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
13:47:59 <Apocalisp> is mapM a specialised traverse?
13:48:41 <c_wraith> Well, all monads should be Applicative, so yes.
13:48:57 <c_wraith> Oh, wait.  There's a difference
13:49:00 <c_wraith> Nevermind. :)
13:49:15 <rieux_> what's the difference?  let t = []
13:49:22 <c_wraith> yeah, I suppose that's true.
13:49:24 <c_wraith> Yeah.
13:49:52 <Berengal> This juxtaposition of functions has enlightened me somewhat
13:50:10 <rieux_> @quote enlighten
13:50:10 <lambdabot> ksf says: Confusion is the first step to enlightenment
13:57:58 <Gracenotes> oh, darn binary incompatibility issues..!
13:58:25 <Gracenotes> and the weird errors that result
14:00:00 <Gracenotes> "*** Exception: readChunkBU: can't read"
14:00:07 <Gracenotes> wat is this :3
14:00:26 <vixey> lol
14:00:37 <Gracenotes> oddly enough, using hGetU on the same file encoded with hPutU
14:00:48 <skorpan> analphabetism has reached fp
14:04:12 <dolio> Gracenotes: Yeah, I tried hGet/PutU myself, and it didn't work. I asked dons and he said it was only in there for playing around, and he knows it doesn't work.
14:04:28 <dolio> And pumpkin is working on a byte string thing or something.
14:04:45 <Gracenotes> aw. I guess I'll have to use binary then?
14:04:51 <Gracenotes> Data.Binary.
14:05:04 <Gracenotes> incidentally, the reason I'm using uvector is because of your introsort algorithm :)
14:05:48 <dolio> Merge sort is currently faster by a bit (by a lot on pathological cases).
14:06:08 <dolio> Although if you're close to hitting memory limits, that might not be a good idea.
14:06:46 <Gracenotes> dolio: still, might be a pain to go back and forth. As it stands it's very elegant: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4581
14:06:57 <Gracenotes> the second function. Yet... fails.
14:07:29 <dolio> Radix sort is faster, too, for really, really large arrays if you get the version in darcs. But it uses even more overhead than merge sort.
14:08:45 <Gracenotes> mm. well, I am dealing with a large amount of data
14:09:15 <dolio> All the sorting should have an identical interface, except radix sort, which is naturally a bit different.
14:09:19 <Gracenotes> and sorting a (Word64 :*: Word64), only by the second
14:09:29 <dolio> You just replace "Intro" with "Merge". :)
14:09:32 <Gracenotes> yeah.. would have to make an instance of sorts...
14:10:42 <Gracenotes> but, regardless, still need to get it into a UArr (Word64 :*: Word64)
14:10:58 <Gracenotes> I wonder if Data.Binary and hPutU are compatible
14:11:02 <dolio> In darcs, there's now a radix sortBy, too. So you could use "sortBy (passes (undefined :: Word64)) (size (undefined :: Word64)) (\k (_ :*: e) -> radix k e)".
14:12:53 <Gracenotes> there are no monad functions in uvector...
14:13:40 <dolio> I don't know. If you're unlucky, the hPutU for pair arrays does "hPutU (PairA a b) = hPutU a >> hPutU b".
14:13:49 <Berengal> Speaking of sorts, what's a good way to sort extremely large amounts of data?
14:13:57 * osfameron kicks his blogtroll
14:15:22 <Gracenotes> hm.... *** Exception: Arr.BUArr.writeMBU[Word64]: Out of bounds (size = 2000000; index = 2000000) :o
14:15:30 <Gracenotes> reading Just Word64s, instead of pairs
14:15:59 <Gracenotes> looks like *someone* is allocating as much memory as possible!
14:16:07 <dolio> Gracenotes: In fact, that's exactly what it does "hPutU h (UAProd xs ys) = do hPutU h xs ; hPutU h ys"
14:16:20 <idnar> Gracenotes: it wasn't me!
14:16:29 <dolio> And then "hGetU h = do xs <- hGetU h ; ys <- hGetU h ; return (UAProd xs ys)".
14:16:34 <dolio> Which obviously won't work.
14:17:05 <Gracenotes> you need some kind of uvector monad functions, at least. Like replicateMU
14:17:14 <Gracenotes> sequenceU might be a good start too
14:17:17 <MartyIX> May I ask a newbie question about Haskell or am I at wrong place?
14:17:28 <dolio> You can't store monadic actions in an unboxed array, though.
14:17:29 <Berengal> MartyIX: No, this is the right place
14:17:29 <vixey> that is fine MartyIX
14:17:46 <dolio> Writing things like sequenceU is tough.
14:17:46 <Gracenotes> dolio: no, but you could have [m e] -> m (UArr e)
14:18:00 <Gracenotes> presumably with a length argument for the list
14:19:37 <MartyIX> Berengal, vixey: Could you please tell me some real-world application where is appropriate to use Haskell or a classic problem for Haskell? Something like "this is perfect example of problem for Haskell"
14:20:12 <Gracenotes> dolio: you could have mapMU though :)
14:20:15 <cypher-> MartyIX: writing a lambda calculus compiler
14:20:21 <tromp> or interpreter
14:20:26 <cypher-> MartyIX: from parser to compiler / interpreter
14:20:27 <Berengal> A parser
14:20:28 <dolio> Gracenotes: Yeah.
14:20:49 <vixey> MartyIX: Factorial
14:21:10 <mgsloan> I've found it to be awesome for job interviews
14:21:16 <MartyIX> cypher- : it sounds good
14:21:27 <korpios> I'm new to Haskell myself, but I'd feel amiss to not point out http://book.realworldhaskell.org/ ^_^
14:21:37 <mgsloan> an apple interviewer asked me what mappend was ;)
14:21:54 <MartyIX> tromp: interpreter? I don't know much about it but you can use knowledge of automata for this, can't you?
14:21:54 <Berengal> Haskell is good at many things...
14:21:56 <tromp> :t mappend
14:21:57 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:22:16 <Berengal> > Nothing `mappend` Just 5
14:22:17 <lambdabot>   Add a type signature
14:22:26 <vixey> > Nothing `mappend` Just [5]
14:22:27 <lambdabot>   Just [5]
14:22:38 <tromp> MartyIX, i meant lambda calculus interpreter
14:22:45 <Gracenotes> well, at least hPutU works
14:22:57 <mgsloan> tromp: the important thing about mappend is that it's an associative operations
14:23:12 <mgsloan> which is what's important about monoids in general it seems
14:23:16 <cypher-> MartyIX: syntax-tree interpreter of LC is trivial in haskell, but together with a monadic parser forms a nice programming exercise
14:23:38 <dolio> Gracenotes: I think the problem is that hGet/PutU were written back when primitive arrays wrote their size to the file.
14:23:41 <vixey> not really trivial
14:23:46 <MartyIX> tromp: ah, ok, thank you; I will have some class about lambda calculus next semester..
14:23:47 <vixey> in any sense
14:24:21 <dolio> Gracenotes: Now they just dump the array, and use file size to figure out how much to read back in. So reading in one uses the whole file.
14:24:53 <mgsloan> But really, I've had it happen before where they ask you to write a solution to a problem in the language of your choice.  30 seconds later one line of haskell is on the board :)
14:24:55 <dolio> Which doesn't work right for hGetU anymore.
14:24:56 <Gracenotes> oh, jeez, it's that bad :o
14:25:42 <Gracenotes> hm. the thing is, I am hPutU'ing in chunks
14:26:02 <Alpounet> is it possible to modify Haskell's syntax like we can do with OCaml's camlp4 ?
14:26:08 <Gracenotes> so I suppose the final result would end up being striped, if a UAProd is an unzipped list
14:26:17 <vixey> no you can do quasiquoters though
14:27:00 <Gracenotes> dolio: is that how it works ...? do pairs alternate like a b a b a b, or is it aaaaaabbbbbb?
14:27:15 <dolio> Gracenotes: The latter.
14:27:22 <rieux_> mgsloan: really?  what were you interviewing for?
14:27:28 <Gracenotes> oh. so chunks is a naughty way of doing it :\
14:28:00 <mgsloan> rieux_: that's happened with both microsoft and amazon
14:28:10 <rieux_> nice
14:28:17 <Gracenotes> so I shall use my function BSL.ByteString -> IO (IOArray Int (Index, Index)) with Data.Binary, then... :o
14:28:42 <mgsloan> and then the interviewer is usually like "Really? That's cool.. :O  Lets do a language I know though"
14:29:02 <blackh> Alpounet: You could be talking about Template Haskell, but I don't know what camlp4 does.
14:29:22 <rieux_> yeah, i misunderstood.  i imagined the interviewer asking you, "Do you know what monoid is?"  and i didnt see that happening at apple.
14:29:30 <Gracenotes> mgsloan: :D heh
14:29:38 <mgsloan> rieux - actually, that did happen
14:29:41 <mgsloan> in a phone interview
14:29:44 <mgsloan> took me off guard lol
14:29:47 <Gracenotes> mgsloan: what sort of problems did you solve as a one-liner, though?
14:29:51 <mgsloan> (I put haskell on my resume)
14:29:57 <rieux_> (of course)
14:29:58 <dolio> Gracenotes: dons said pumpkin is working on some bytestring loading interface to uvector. I don't know how far along it is.
14:30:06 <rieux_> Alpounet: not really, no.  template haskell won't do a lot of what camlp4 will do
14:30:10 <Gracenotes> dolio: neat
14:30:34 <mgsloan> Gracenotes - things like finding the missing number in a list from [1..1000] missing one number
14:30:40 <Gracenotes> it seems Data.Binary is a bit slower than hPutU, based on informal benchmarks... but functionality is pretty important
14:30:47 <rieux_> Alpounet: what are you trying to do?  or are you just curious.
14:30:50 <billls> got another question.. functions requirements are just under the code http://foxyurl.com/1o0
14:30:50 <mgsloan> or defining reverse for lists
14:30:52 <mgsloan> things like that
14:31:19 <Gracenotes> mgsloan: hm. you could possibly do a filter/zipWith... or something. sounds like a neat interview :)
14:32:10 <dolio> > [1..1000] \\ ([1..50] ++ [52..1000])
14:32:11 <lambdabot>   [51]
14:32:46 <mm_freak> compared to explicit parallelism using concurrency, parMap's performance is extremely bad
14:33:08 <Gracenotes> another way, although I am suspicious of \\ performance ( ﾟ -ﾟ)
14:33:30 <Gracenotes> SML seems to be a much more popular language at my school
14:33:55 <vixey> ( ﾟдﾟ)
14:34:07 <grul> HALP!
14:34:10 <solidsnack> ( O.o )
14:34:12 <Alpounet> blackh, rieux_, I'm just looking for pointers of "equivalent" tools for Haskell. Nothing concrete for the moment, but, e.g, how is it possible to write syntax extensions for Haskell, or take and modify a program AST, etc.
14:34:24 <mgsloan> probably the best solution is (foldl' Data.Bits.xor)
14:34:47 <billls> i've got pronouns stored in tuples e.g. ("your","my") i need the function to take a word in, and look up it's opposite in the table and return the row http://foxyurl.com/1o0 can't make it work :(
14:34:52 <rieux_> Alpounet: Template Haskell will let you do some of that, though it's never going to look like "built-in" syntax, and it make defining new binding forms very tricky
14:35:04 <Gracenotes> mgsloan: what did you do, if I may ask?
14:35:21 <rieux_> Alpounet: i put a package on hackage that purports to let you extend haskell's syntax, if you want to try it.  it's a dirty hack, but it works.
14:35:26 <rieux_> @hackage preprocessor-tools
14:35:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/preprocessor-tools
14:36:46 <Alpounet> rieux_, I'm taking a look at your package.
14:37:01 <olsner> grul: "HALP" säger du, vad verkar vara problemet?
14:37:03 <mgsloan> I think it was probably something like:
14:37:03 <mgsloan> head $ filter (\s -> not $ x `elem` (sort xs)) [1..1000]
14:37:24 <mgsloan> err \x I mean
14:37:28 <grul> olsner, det var en läskig smiley (I just said he had a giant car up his sleeve)
14:37:48 <mgsloan> not the best answer ever but impressive to give an answer in less than 30 sec :P
14:38:05 <olsner> grul: (:[ {- HALP! -} ]) *chomp*
14:38:19 <Gracenotes> mgsloan: just tell them it's magic :)
14:38:43 <Alpounet> rieux_, that looks nice. I'll have a deeper look when needed, but cheers man.
14:38:44 <dons> who wants to test a beta of the haskell platform generic installer?
14:38:49 <dons> download: http://haskell.org/~duncan/haskell-platform-2009.1.0.tar.gz
14:38:56 <dons> untar. ./configure ;make ; make install
14:38:56 <leimy> dons: cool!  and "phear"
14:39:10 <dons> and you should have a working sync against the current platform spec.
14:39:12 <Gracenotes> > (:[{-OM-}]) (:[{-NOM-}]) (:[{-NOM-}]) (:[{-NOM-}]) (:[{-NOM-}])                             0.0 --  . . o o O O (halp!)
14:39:13 <dons> please report any errors
14:39:14 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
14:39:14 <leimy> If I wasn't doing production Haskell stuff right now... I'd give it ago :-)
14:39:21 <leimy> s/ago/a go/
14:39:35 <Gracenotes> > (:[{-OM-}]) . (:[{-NOM-}]) . (:[{-NOM-}]) . (:[{-NOM-}]) . (:[{-NOM-}])                             $0.0 --  . . o o O O (help, again!)
14:39:37 <lambdabot>   [[[[[0.0]]]]]
14:39:37 * leimy would also like to mention that he still loves "interact"
14:39:57 <dons> Lemmih: want to give it a test?
14:40:04 <dons> mac osx users also please
14:40:08 <leimy> dang...
14:40:20 * leimy tries it anyway
14:40:24 <leimy> as I'm on Mac OS X
14:40:36 <dons> go go!
14:40:36 <canvon> billls: perhaps something like this? getAllProMatches w = filter (\row -> fst row == w) proTable
14:41:10 <billls> what does the \row part do?
14:41:34 <canvon> \ defines an anonymous function. (lambda)
14:41:42 <canvon> perhaps you should have a look at some haskell tutorial...
14:41:44 <olsner> isn't there a snazzier name for the "haskell platform" than "haskell platform"?
14:41:52 * leimy tries "--enable-user-install"
14:42:59 <Berengal> dons: Didn't work without sudo. With sudo worked fine
14:43:01 <leimy> olsner: you could call it "Sir Quigley Topper Middle Bottom's Fantabulastic Contrapulaption"
14:43:06 <leimy> but it'd still be Haskell Platform.
14:43:10 <dons> Berengal: that's expected, unless you do a user install.
14:43:11 <dons> thanks.
14:43:15 <dons> Berengal: what platform?
14:43:20 <Berengal> (Appart from a few warnings. Ubuntu 9.04 x86_64)
14:43:26 <dons> thanks!
14:43:41 <rieux_> dons: *   If you wish to change these settings then
14:43:41 <rieux_> *   use --preifx= and/or --enable-user-install
14:43:46 <DrSyzygyBE> dons: Was my fix satisfactory? Also, do you build all hackage packages by default, or were you genuinely interested in it?
14:43:47 <canvon> billls: http://www.haskell.org/tutorial/functions.html#sect3.1
14:43:55 <rieux_> dons: s/--preifx/--prefix/
14:44:02 <dons> rieux_: ? typo?
14:44:05 <dons> thanks.
14:44:23 <Berengal> dons: Is this going on hackage by the way?
14:44:51 <dons> eventually. but binary installers are the primary focus
14:44:58 <dons> after all, it's just a spec of a bunch of hackage things
14:44:59 <leimy> dons: got an error
14:45:03 <tombee> is beta-reduction in lambda calculus just the process of substituting a 'value' in to an argument in a lambda expression?
14:45:08 <rieux_> dons: is there a list of dependencies somewhere?  i needed to install GLUT headers.  (this is on debian 4.0 (stable))
14:45:13 <dons> DrSyzygyBE: i package hackage for Arch.
14:45:16 <dons> DrSyzygyBE: yes, seemes to be ok now.
14:45:18 <DrSyzygyBE> Ahhh.
14:45:18 <vixey> tombee no
14:45:20 <DrSyzygyBE> Aight.
14:45:20 <leimy> dons: should I do "user-install"
14:45:24 <dons> leimy: details please. (privmsg?)
14:45:50 <dons> rieux_: currently, no. they'll be found via the configure script. but they are OpenGL, and some others.
14:46:32 <Berengal> HP is neat :)
14:47:01 <dons> leimy: yes, so --user-install doesn't set --prefix=$HOME, but setting --prefix=$HOME sets --enable-user-install
14:47:35 <olsner> oh, looks like I'll have to upgrade ghc... which (official) ghc release will be getting the new build system btw?
14:47:47 <dons> rieux_: http://trac.haskell.org/haskell-platform/ticket/1
14:47:58 <tombee> So what is beta-reduction in lambda calculus? :)
14:48:03 <dons> ok, any other HP builds succeed?
14:48:11 <leimy> tombee: wikipedia has the answer
14:48:13 <Alpounet> olsner, same for me
14:48:24 <dons> tombee: (\x -> x + n) 7  -->  7 + n
14:48:35 <vixey> leimy: wiki article on beta reduction just points at #haskell
14:48:38 <tombee> So is that not the process of substituting a value in?
14:48:46 <vixey> tombee: It doesn't have to be a value it can be any term
14:48:48 <leimy> vixey: it must :-)
14:49:07 <mux> substituting any free occurence of the ariable
14:49:12 <vixey> tombee: it's not just any substitution though, you have to be very careful about it
14:49:23 <dons> it involves subsitution, yes.
14:50:11 <Alpounet> is the haskell debian maintainer team still active ?
14:50:23 <Berengal> Heh, I like the HP logo
14:50:23 <rieux_> dons: seems to work on ghc-6.10.1, linux 2.6.28, debian 4.0
14:50:31 <dons> rieux_: thanks.
14:50:35 <dons> Alpounet: very!
14:50:42 <Alpounet> I'm on Debian Unstable but don't have the necessary ghc version
14:51:01 <Alpounet> (with updates done, of course)
14:51:03 <rieux_> dons: oh, except: -rwxrwx--- 1 root root 1249252 2009-05-04 17:48 /usr/local/bin/happy
14:51:13 <rieux_> but i guess that's a known bug
14:51:23 <dons> hmm
14:51:46 <Alpounet> dons, I'll fix that and get back for a feedback about the beta platform release :-)
14:51:54 <dons> rieux_: what arch, btw?
14:52:03 <dons> rieux_: and rwx--- is maybe a bug!
14:52:35 <rieux_> says: i686 GNU/Linux.  i think it's actually IA64, but with a i686 kernel.
14:52:42 <dons> ia64??
14:52:43 <Zao> Itanic?
14:52:47 <dons> x86_64 surely
14:53:06 <dons> we'll put it down as x86/linux/debian
14:53:07 <dons> :)
14:53:09 <rieux_> sorry, yes.  i don't bother with this things
14:54:39 <leimy> dons: the only other machine I have is Arch and I'm sure you've tested that :-)
14:55:36 * mgsloan is going to install Arch soon
14:56:17 <dons> yes, i've tested arch/x86_64
14:56:27 <dons> and windows needs the win.exe installer to test
14:56:34 <dons> bsd is the missing piece.
14:56:40 <dons> any freebsd userrs?
14:56:44 <leimy> dons: I've freebsd at home
14:56:51 <leimy> do you want the latest release?  I've not updated yet.
14:56:54 <mux> dons: what's the deal?
14:56:56 <dons> i think there's some known sh/bash-isms about to be fixed.
14:56:59 <dons> ok. hang on.
14:57:29 <dons> waiting for some bash-isms to disappear, then you can test on freebsd.
14:57:36 <leimy> ah right
14:57:41 <leimy> they use a real sh
14:57:45 <leimy> not a bash sh :-)
14:57:46 <rieux_> i'll test on solaris once those are gone.  solaris has a real REAL sh
14:57:56 <dons> duncan's testing on solaris right now.
14:57:58 <leimy> yes solaris does have real real sh :-)
14:57:58 <mux> solaris sh lacks POSIX features though
14:57:59 <rieux_> nm then
14:58:08 <mux> or at least the last time I checked :)
14:59:10 <tombee> So is beta reduction just a simple case of substitution, or am I missing the point somewhere
14:59:19 <tombee> ((\ n. n*2) 7)  ->  7*2.
14:59:34 <mux> tombee: it is "just" substitution, but it is more subtle than it looks
14:59:43 <Alpounet> it involves substitution, but isn't reduced to "just" substitution.
15:00:02 <tombee> It says it captures the idea of function application
15:00:09 <tombee> But I'm not really sure what that means
15:00:17 <mux> tombee: you have to avoid capturing variables or substituting variables that you shouldn't
15:00:41 <mux> but this is arises only when you consider named variables
15:00:52 <mux> it doesn't happen with de bruijn indices
15:00:58 <rieux_> tombee: it's not that deep.  if you have a function and apply it, then you need to replace references to the arguments that appear in the body with the actual argument values.
15:01:09 <mux> tombee: wikipedia has all the specifics
15:01:20 <tombee> rieux_: that's all I can 'see' from it
15:01:33 <mux> tombee, rieux_: that doesn't account for variable capturing
15:01:38 <tombee> you have a lambda expression, and you just want to substitute 'things' in to make it work?
15:01:41 <mux> for instance
15:01:44 <dibblego> is there any type-class on 'm' that allows (a -> m b) -> m (a -> b) ?
15:01:49 <tombee> things being other functions
15:01:59 <rieux_> mux: sure, but that's a detail, right?  assume evasive relettering, or cbv, or what have you
15:02:11 <rieux_> if you're doing lazy beta, that's a bit more involved
15:02:28 <mux> this is to support the case of this substitution being more subtle than it first seems to
15:03:09 <rieux_> tombee: do you understand what capture is?
15:03:22 <tombee> not in a lambda calculus sense
15:03:25 <rieux_> okay
15:03:26 <Alpounet> dons, still 6.10.1 on Sid, I'd need to compile ghc by hand heh.
15:03:29 <rieux_> so suppose we have a lambda term:
15:03:51 <rieux_> \x.((\y.\x.y x) x)
15:04:08 <DBAlex> hey
15:04:19 <rieux_> in that case, there are two lambdas that bind x.  the left-most lambda binds the right-most x, and the inner lambda bind the inner x
15:04:28 <rieux_> what happens if you beta reduce?
15:04:40 <mm_freak> hmm
15:04:54 <pfc> hi all, I'm new to haskell (coming from python)  and just starting the tutorials, shortly I will be looking at using opengl preferably with SDL.  Any recommendations as to what packages I should look into?
15:04:58 <mm_freak> 'and . map p' is slightly faster than 'all p'
15:05:11 <rieux_> mm_freak: lame
15:05:14 <dons> any windows users?
15:05:26 <dons>   this is the win32 installer for the platform: http://code.haskell.org/~refold/HaskellPlatform-2009.2.0-rc1-setup.exe
15:05:33 <dons> feedback highly welcome
15:05:34 <tombee> not sure rieux_
15:05:48 <DBAlex> ha
15:05:51 <Alpounet> feedback under Ubuntu needed ?
15:06:03 <rieux_> tombee: there's one beta redex (that is, thing that can be reduced by beta) in there: (\y.\x.y x) x
15:06:16 <DBAlex> that was a cryptic error, using a do with lots of putStr's... the error was because I was identing incorrectly with notepad++...
15:06:16 <dons> Alpounet: the more the better.
15:06:20 <mm_freak> dons: what is that platform?
15:06:28 <dons> http://haskell.org/haskellwiki/Haskell_Platform
15:06:33 <DBAlex> (the layout looked fine in n++, but it wasn't)
15:06:38 <rieux_> using the beta rule, (\y.M) N --> M[n/y], you can reduce that
15:06:47 <rieux_> stop me if i'm using unfamiliar notation
15:07:04 <tombee> Hmm well this doesn't look familiar to me atm
15:07:16 <mm_freak> ah, thanks
15:07:18 <Alpounet> dons, Yeah, I see. Brb, so.
15:07:49 <pfc> Any recommendations as to what packages I should look into if I want to use opengl(with SDL) in haskell?
15:08:14 <dons> the Haskell OpenGL, GLUT and SDL packages?
15:08:16 <rieux_> hmmm.  i'm trying to think of another way at this.
15:08:21 <dons> pfc: hackage.haskell.org
15:08:32 <pfc> where do I go to get info on those packages?
15:08:33 <rieux_> or: what notation are you using, tombee?
15:08:34 <mm_freak> you won't need GLUT with SDL
15:08:38 <pfc> thx
15:08:40 <dons> pfc: on hackage.
15:08:41 <pfc> yea
15:10:05 <Alpounet> back
15:10:46 <Zao> Aaw, HaskellFP doesn't work on Windows :(
15:10:51 <Zao> I thought I'd finally found a sane IDE.
15:11:05 <Zao> Err, EclipseFP, that is.
15:11:07 <Twey> What is HaskellFP?
15:11:08 <Twey> Oh
15:11:09 <Twey> Haha
15:11:58 <mm_freak> emacs works well on windows
15:12:14 <Twey> Indeed
15:12:16 <Zao> Emacs may be many things, but it sure isn't an IDE nor an editor.
15:12:28 <rieux_> an OS?
15:12:34 <dons> i thought eclispe worked on windows...
15:12:36 <dons> wasn't that the point?
15:12:45 <dons> http://sdasrath.blogspot.com/2009/05/20090402-haskell-and-eclipse-part-2.html
15:12:47 <rieux_> i've had the displeasure of using eclipse on windows, yeah
15:12:51 <Zao> dons: Eclipse does. The EclipseFP plugin doesn't.
15:13:10 <dons> visual haskell is your friend (or leksah)
15:13:26 <Zao> EFP Doesn't find my .hs file when building, and cannot launch an GHCi console.
15:13:35 <mstr> use notepad. that's an editor
15:13:37 <Zao> Visual Haskell? Isn't that ancient?
15:13:45 <rieux_> @type \x -> \y -> y (y x)
15:13:46 <lambdabot> forall t. t -> (t -> t) -> t
15:14:12 <dons> http://stackoverflow.com/questions/734309/haskell-ide-for-windows/734768#734768
15:14:20 <Zao> Targets VS2005 and bundles a GHC installation? Sounds delicious :P
15:14:27 <Alpounet> gonna test the Windows Installer of Haskell Platform
15:14:51 <mauke> :t ap id . ap id . const
15:14:52 <lambdabot> forall b. b -> (b -> b) -> b
15:14:54 <c_wraith> can you disable optimizations from cabal's per-executable configuration section?
15:15:15 <DrSyzygyBE>    
15:15:20 <mauke> @pl \x -> \y -> y (y x)
15:15:20 <lambdabot> ap id . flip id
15:15:26 <Zao> dons: Leksah ate my code on Linux today, and last I looked at it it looked daunting to build. Especially as there's no gtk2hs for 6.10.2 yet.
15:16:05 <dons> better report that to the author
15:16:12 <dons> Alpounet: thanks!
15:16:19 <mauke> what, no gtk2hs?
15:16:31 <dons> rieux_: can you drop by #ghc
15:16:34 <mauke> then what have I built and installed yesterday?
15:16:39 <dcoutts> c_wraith: what do want to do exactly? If you just want a dev build with -O0 then cabal configure -O0
15:16:58 <Zao> mauke: No binary build for Wintendo.
15:17:05 <dcoutts> rieux_: ping
15:17:07 <Alpounet> dons, you're welcome.
15:17:26 <c_wraith> dcoutts: optimizations break the test executable, because they mask some error conditions the tests look for.  I want to disable them just for that executable
15:17:29 <rieux_> dcoutts: yeah?
15:17:42 <rieux_> sorry, was with tombee
15:17:56 <Zao> Also, >>> leksah: error: a C finalizer called back into Haskell.  use Foreign.Concurrent.newForeignPtr for Haskell finalizers. <<<
15:18:03 <Zao> This seems to indicate some kind of fundamental flaw.
15:18:05 <dcoutts> rieux_: oh, sorry, will ask you in a min, gotta do something quickly
15:18:10 <rieux_> no prob
15:18:18 <rieux_> i'll turn my sound up!
15:18:19 <c_wraith> Zao: That's a change in 6.10.2 that broke several programs
15:18:56 <Zao> c_wraith: Aye, I think I've seen talk about it somewhere being the reason a new build of gtk2hs isn't out.
15:19:11 <dons> ok. more feedback peoples. this is the user site for downloading the platform: http://www.galois.com/~dons/packages/index.html   does it make it clear what you're getting, and why?
15:22:00 <tomh> dons: I miss buttons with rounded corners which say Download now :)
15:22:10 <Alpounet> well, dons, the installation completed without problem, ghci works, I'm installing some package with cabal in cmd, there isn't any bug to fix for me, sorry :-) [Windows XP, 32 bits]
15:22:58 <dons> tomh: that's for the second release.
15:23:12 <dons> there's a fancier site for the 2nd release :)
15:23:12 <Berengal> dons: I'd like to easily be able to see just what the platform contains somewhere
15:23:19 <dons> Alpounet: woo!
15:23:31 <dons> great idea Berengal
15:23:35 <dons> http://code.haskell.org/haskell-platform/haskell-platform.cabal
15:23:35 <Alpounet> yeah, quite surprizing but I won't complain, heh.
15:23:38 <dons> but that should be on the list.
15:23:49 <tomh> dons: is the installer for windows actually done?
15:23:57 <Alpounet> tomh, yep
15:24:03 <Zao> dons: "Windows Installed" typo :)
15:24:05 <tomh> nice, where can i get it
15:24:10 <Zao> (on the wiki page)
15:24:22 <Alpounet> http://code.haskell.org/~refold/HaskellPlatform-2009.2.0-rc1-setup.exe
15:24:23 <dons>   this is the win32 installer for the platform: http://code.haskell.org/~refold/HaskellPlatform-2009.2.0-rc1-setup.exe
15:24:42 <Berengal> dons: Yes, I know about the .cabal file but it really belongs on a website as well. Perhaps not on the main page, but it should be prominently linked to
15:25:19 <tomh> ok cool gonna test it out
15:25:25 <dons> Berengal: yes.
15:26:36 <tomh> why not quickcheck 2?
15:27:38 <Zao> Heh, must've been some stale settings for EclipseFP. Works after whacking apply everywhere :)
15:28:09 <Alpounet> for feedback under Debian/Ubuntu, better waiting ghc 6.10.2 rolled in distrib packages
15:32:41 <Zao> dons: The platform includes cabal-install? You're now my favourite platform maintainer :)
15:34:09 <Alpounet> I'll try to give some help to debian-haskell team
15:34:18 <Alpounet> anyone here part of this team ?
15:35:10 <Zao> Isn't Igloo related to it in some way?
15:35:50 <edwardk> I finally got: Ran g >>= f = Ran (λk → Endo (λz → appEndo (g (λa → Identity (appEndo (getRan (f a) k) z))) z)) -- to compile
15:35:50 <edwardk>  
15:37:03 <edwardk> (probably the most painfully encoded Maybe monad ever)
15:37:42 <edwardk> now to get its mplus instance right
15:38:26 <edwardk> and to transcode the 'lessons learned' down to MaybeT/Error/ErrorT
15:41:22 <cypher-> edwardk: what is the advantage of this encoding?
15:41:46 <vixey> Ran (λk → Endo (λz → appEndo (g (λa → Identity (appEndo (getRan (f a) k) z))) z))
15:41:57 <dons> mux: should work on *BSD http://haskell.org/~duncan/haskell-platform-2009.1.1.tar.gz
15:42:00 <dons> and solaris.
15:42:01 <dons> testing wanted
15:42:11 <vixey> edwardk, Is this not one instance of something general?
15:45:05 <leimy> > (λk -> 9) 100
15:45:06 <lambdabot>   <no location info>: parse error on input `->'
15:45:11 <leimy> doh
15:45:29 <QP> > sum [1..10]
15:45:31 <lambdabot>   55
15:46:02 <QP> > map (\x -> sum [1..x]) [1..10]
15:46:04 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
15:46:23 <QP> leimy: how do you get the lambda symbol?
15:46:44 <QP> or does my \ look like that to you?
15:47:13 <Zao> Leksah converts many glyphs to shinier unicode ones.
15:47:24 <Zao> $ becomes a diamond, . a ball, \ a lambda.
15:47:59 <Zao> I'm sure Emacs has a fancypants mode too :)
15:48:35 <QP> oh well
15:48:57 <Elly> \ becoming a lambda is pretty cool
15:48:58 <QP> i'm a vim man myself
15:49:04 <rieux_> Leksah?  is that the stage before the Pahsah?
15:49:14 <QP> it only happened when leimy did it
15:49:19 * Elly installs leksah-darks
15:49:24 <Elly> I'm a vim user as well
15:49:28 <Elly> er, leksah-darcs :P
15:49:34 <leimy> Zao: yi does that too
15:49:36 * cypher- normally uses vim or textmate
15:49:46 <Zao> Beware of gtk2hs gremlins :)
15:49:48 <leimy> λ
15:50:04 <leimy> yi can do that in vty mode
15:50:15 <QP> \lambda
15:50:18 <QP> nope
15:52:46 <leimy> Is there a really easy way to get leksah on Mac OS X with little manual dependency chasing?
15:56:42 <Sadache> I implemented a function that first looked for me like a liftM2 and then discovered that it is not, and I am wondering if it is familiar for you guys, f g= \f1 f2 -> a -> g (f1 a) (f2 a)
15:57:29 <Botje> it looks like `on` but weirder
15:57:49 <codebliss> What's liftM2 under again?
15:57:58 <Sadache> kind of combining functions not in serial but in leafs or something
15:57:59 <Botje> control.monad
15:58:06 <codebliss> Thanks.
15:58:10 <mauke> why is it not liftM2?
15:58:28 <Sadache> because liftM2 takes a and b
15:58:38 <Sadache> and it connects functions in serial
15:58:42 <mauke> :t liftM2
15:58:43 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:58:45 <DrSyzygyBE> :t on
15:58:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:59:04 <mauke> what?
15:59:14 <mauke> > liftM2 f g h a :: Expr
15:59:15 <DrSyzygyBE> Oh, Botje already pointed that out.
15:59:15 <lambdabot>   Add a type signature
15:59:34 <mauke> > liftM2 (f :: Expr -> Expr -> Expr) g h a
15:59:35 <lambdabot>   f (g a) (h a)
15:59:35 <Botje> @pl f g = \f1 f2 a -> g (f1 a) (f2 a)
15:59:35 <lambdabot> f = liftM2
15:59:49 <Botje> Sadache: looks like your function is exactly liftM2 :)
16:00:01 <Sadache> a special case of it
16:01:24 <edwardk> cypher-, vixey: thats my Ran encoded Maybe monad, why its useful is once Maybe is in that format i can encode 'ran transformers' for StateT, etc.
16:01:35 <Sadache> I thought liftM2 g= \f1 f2 -> \a -> \b -> g (f1 a) (f1 b)
16:01:42 <codebliss> Can someone give a simple, useful situation for liftM2?  I'm trying to figure why I'd need this
16:01:54 <edwardk> and so Ran (StateT MyState Maybe) a -- will yield a monad that is more efficient than StateT MyState Maybe
16:02:03 <Botje> @pl \x -> show x == (reverse $ show x) -- codebliss
16:02:04 <lambdabot> liftM2 (==) show (reverse . show)
16:02:42 <Botje> or when you're using parsec to parse stuff in pairs: liftM2 Definition parseName parseValue
16:02:47 <edwardk> because in that case it'll look like forall o. (a -> s -> o) -> s -> o -> o -- with a bunch of newtype noise
16:03:02 <codebliss> I think I'm too new to haskell to get the usefulness XD
16:03:22 <Elly> w00t
16:03:26 <Botje> Sadache: what, ignore the fé?
16:03:27 <codebliss> I know what parsec is but haven't touched it.
16:03:31 <Elly> now 'lam' entered in vim inserts a unicode lambda :)
16:03:32 <edwardk> fmapping will never look down at the stuff further down the stack it'll just partially apply that first argument
16:04:45 <Botje> Elly: shiny :)
16:04:52 <Botje> codebliss: try it, ti's fun :)
16:04:54 <edwardk> elly: in mine a \ turns into a lambda and then corrects itself next time i save it out to the file to only occur in places where you want a lambda
16:04:59 * Elly changes it to ^J-l
16:05:08 <Elly> edwardk: I use vim to edit things like LaTeX where it might not be able to tell
16:05:18 <Elly> (or at least, I don't care to make it able to tell)
16:05:21 <Sadache> so can I write (f1 `liftM2 (+)` f2) "1"
16:05:23 <edwardk> elly: its tied to the haskell mode
16:05:25 <Elly> oh
16:05:27 <Elly> mine is global :)
16:05:31 <codebliss> Botje: Meh, it's not in my realm, maybe in a couple months  =P.  I'm thinking of working on some resume'ish programs.
16:05:48 <Botje> codebliss: simple evaluators are a great way of getting to know haskell
16:05:50 <Sadache> having f1 f2 extracting some Integer for a string
16:06:01 <Botje> stick a parser in front of an evaluator and you get a repl!
16:06:01 <edwardk> elly: in my case i extend it to a bunch of haskell syntax: data Ran m a = Ran { getRan :: ∀b. (a → G m b) → H m b } -- etc.
16:06:10 <codebliss> Botje: I get haskell pretty well.  I'm just new to monad/functor/applicative etc
16:06:25 <Botje> stick some code generation behind the interpreter and you get a compiler!
16:07:59 <Sadache> ok I have the impression that liftM2 passes the state around from the result of the first to an input to the second, my function passes the same input to all the functions equally
16:08:39 <edwardk> vixey: http://comonad.com/haskell/monad-ran/Control/Monad/Ran.hs -- now includes Maybe, IO, ST s, and STM
16:08:58 <edwardk> i need to get a lot of the instances done still, so its mostly a process of thinking through the molasses of the newtypes
16:09:46 <edwardk> but in general everything gets to compile down to fast partial applications once the newtypes are gone
16:09:57 <edwardk> unlike with a normal monad transformer
16:33:39 <Sadache> ok, do i need to make a monad instance to be able to use liftM2 with pure functions?
16:33:52 <Sadache> if i have first function f1 :: String -> Int and a second function f2::String -> Int and I want to sum the results once a string passed to them equally, can I do  ((liftM2 (+)) f1 f2 ) "1" ?
16:35:00 <Berengal> Sadache: functions are already monads
16:36:16 <Saizan_> Sadache: import Control.Monad.Instances
16:37:09 <robogeoff> is there a library for graphs?
16:37:13 <robogeoff> directed graphs?
16:37:53 <Saizan_> robogeoff: look at fgl
16:38:28 <Gracenotes> goodness. I got a stack overflow doing a homemade quicksort on an IOArray >_>
16:38:43 <Gracenotes> > logBase 2 1000000
16:38:45 <lambdabot>   19.931568569324174
16:38:56 <Gracenotes> .. not a very deep stack, I don't think...
16:39:00 <Gracenotes> wide, but not deep...
16:39:03 <robogeoff> hmm, ok thanks Saizan_
16:39:09 <rieux_> Gracenotes: do you have an accumulator that's a bit too lazy?
16:39:37 <Gracenotes> don't think so. It's IOArray Int (Index, Index) -> Int -> Int -> IO ()
16:40:04 <dabbler> > let newList n x = [x | i <- [1..n]]
16:40:05 <lambdabot>   <no location info>: parse error on input `;'
16:40:11 <Sadache> @Saizan_ that what I should be missing then
16:40:11 <lambdabot> Unknown command, try @list
16:40:25 <dabbler> > newList n x = [x | i <- [1..n]]
16:40:26 <lambdabot>   <no location info>: parse error on input `='
16:40:29 <Gracenotes> although... hm... I do have a partition function that might be lazy. I'm pretty sure not
16:40:30 <Cale> Gracenotes: The stack doesn't mean what it means in a strict programming language.
16:40:47 <Gracenotes> the last line is "swap i (j-1) >> loop i (j-1)"
16:40:53 <Gracenotes> where 'loop' is the name
16:41:08 <Cale> Gracenotes: The stack is used when searching through an expression for a reducible subexpression. So if you get a stack overflow, it means that a large expression has built up.
16:41:13 <dabbler> > let newList n x = [x | i <- [1..n]]
16:41:14 <lambdabot>   <no location info>: parse error on input `;'
16:41:23 <rieux_> hmm.  is it possible taht loop is building up a bunch of thunks like ((((j - 1) - 1) - 1) ... )?
16:41:29 <Alpounet> > newList n = [x | <- [1..n] ]
16:41:30 <lambdabot>   <no location info>: parse error on input `='
16:41:31 <rieux_> when that gets forced, it blows the stack
16:41:35 <Cale> Gracenotes: Probably it's that i or j-1 not being evaluated until too late
16:41:39 <Alpounet> > newList n = [x | x <- [1..n] ]
16:41:40 <lambdabot>   <no location info>: parse error on input `='
16:41:41 <Cale> yeah
16:41:45 * Tsion spent last night getting confused at the new LYAH section on applicative functors and functors in general
16:42:05 <dabbler> i thought i just copy and pasted that from my working ghci code
16:42:05 <Gracenotes> Cale: hm. so I suppose I'll have to bind j-1 to a name, seq, and send it along?
16:42:13 <Alpounet> dabbler, [1..n] is what you need right ?
16:42:18 <Gracenotes> the other case is loop (i+1) j, as well
16:42:19 <dabbler> yeah
16:42:21 <Cale> Gracenotes: you could give that a shot...
16:42:26 <Cale> Gracenotes: however...
16:42:36 <Cale> Gracenotes: I suppose it could also be the swap.
16:42:44 <Cale> Gracenotes: what does swap look like?
16:42:46 <Gracenotes> it is IO :\
16:42:58 <Cale> Actually, it seems more likely that it's the swap.
16:43:04 <Gracenotes> swap i j = do { temp <- readArray arr j; readArray arr i >>= writeArray arr j; writeArray arr i temp }
16:43:05 <dabbler> Alpounet: my code works fine on my ghci but it seemed unaesthetic and I wondered if prelude already has something like that
16:43:14 <Cale> Gracenotes: hmm
16:43:17 <Gracenotes> not a good idea?
16:43:23 <Alpounet> :t enumTo
16:43:24 <lambdabot> Not in scope: `enumTo'
16:43:29 <Alpounet> :t enum
16:43:30 <lambdabot> Not in scope: `enum'
16:43:37 <Gracenotes> enumFrom, enumFromTo, enumFromToThen
16:43:38 <Alpounet> :t enumFromTo
16:43:38 <lambdabot> forall a. (Enum a) => a -> a -> [a]
16:43:50 <Alpounet> yeah, thanks.
16:44:05 <Alpounet> > enumFromTo 1 10
16:44:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:44:25 <Cale> Gracenotes: If I could have the complete source for it and a moment to fiddle about, I could probably find it. Executing readArray arr i will certainly evaluate i.
16:44:38 <Alpounet> gn guys
16:45:00 <dabbler> Alpounet: actually, i wanted a func n x => [x, x, ... x]
16:45:19 <dabbler> Alpounet: with n x's
16:45:19 <Alpounet> replicate ?
16:45:25 <Alpounet> :t replicate
16:45:26 <lambdabot> forall a. Int -> a -> [a]
16:45:27 <rieux_> > replicate 6 True
16:45:28 <lambdabot>   [True,True,True,True,True,True]
16:45:31 <Gracenotes> Cale: hm. Well, hpaste...http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2341#a2341
16:45:39 <Gracenotes> very imperative-ish
16:45:40 <dabbler> ah thanks, I knew there must be one already
16:45:46 <Alpounet> bye
16:45:51 <Cale> Gracenotes: thanks, one minute :)
16:45:58 <Gracenotes> Cale: sorting an array with 1000000 elems
16:46:17 <dabbler> is there any way to inspect the implementation of a function like replicate from the interpreter?
16:48:21 <Cale> Gracenotes: wait, what is g?
16:48:43 <Gracenotes> g = unsafePerformIO $ Mersenne.newMTGen Nothing
16:48:52 <Cale> oh, that's evil :)
16:49:02 <Gracenotes> don't like the unsafePerformIO, but the library requires that there be only one *per process*
16:49:08 <Gracenotes> FFO
16:49:10 <Gracenotes> *I
16:49:26 <Cale> Your code is already in IO, you can use Mersenne.getStdGen
16:49:33 <tiglionabbit> http://www.friendpaste.com/7AduvFMmcsyd1AkIaFVHOK  trying to cabal install openid but nano-hmac is failing to compile
16:49:35 <Cale> Which is ineptly named, but...
16:49:41 <Gracenotes> if you like you can use sw <- randomRIO (start, end-1)
16:50:08 <Cale>    g <- Mersenne.getStdGen
16:50:09 <Cale>     sw <- fmap ((+start) . (`mod` (end-start))) (Mersenne.random g)
16:50:14 <Cale> er, missed a space :P
16:50:26 <Gracenotes> yeah. *still waiting for it to overflow though*
16:50:39 <Gracenotes> ah, okay
16:50:55 <blackh> tiglionabbit: What happens if you type 'cabal install nano-hamc-0.2.0' ?
16:50:57 <Saizan_> tiglionabbit: try "cabal install nano-hmac" or look in the scrollback for a more informative error
16:51:05 <Gracenotes> hm? where's getStdGen? http://hackage.haskell.org/packages/archive/mersenne-random/0.1/doc/html/System-Random-Mersenne.html >_>
16:51:47 <Cale> Oh, you're using version 0.1 instead of 1.0?
16:52:20 <Gracenotes> actually ... I'm just referencing the version at the top of the google. I think I have 1.0, yes.
16:53:02 <tiglionabbit> http://www.friendpaste.com/5Kua8Ww3lxmpH7LAhQN85J  also I updated the last one with more context
16:53:53 <Gracenotes> yes, so it overflowed again
16:53:59 <Gracenotes> (after a longish wait)
16:54:59 <tiglionabbit> I'm compiling this on an intel mac (leopard) with ghci 6.10.2
16:55:00 <dbueno> is there a way to delete a file on exit of ghc?
16:56:33 <jwash> http://www.Marie-gets-Deflowered.com/?id=43a43334
16:56:40 <blackh> tiglionabbit: I am guessing that you have an ancient version of OpenSSL development packages installed on your system and you need some way to upgrade it.  I don't know how to do that on a Mac.
16:57:06 <cypher-> tiglionabbit: my advice is to build prefix portage and then use it to build ghc
16:57:29 <dabbler> if i do data Color = Black | White | Gray, is there a way to iterate through the possible values for Color or should i just create a duplicate in list form in e.g. variable colors?
16:57:47 <dbueno> dabbler: deriving Enum?
16:57:56 <Elly> wow, leksah needs to spend a lot of time loading and thinking
16:58:03 <dabbler> :t Enum
16:58:04 <lambdabot> Not in scope: data constructor `Enum'
16:58:12 <dbueno> then [Black .. Gray] will be a list, assuming Black is the first and Gray is the last constructor
16:58:16 <tiglionabbit> blackh: port install openssl  (gets me devel/openssl  0.9.8g)
16:58:17 <dbueno> dabbler: it's a type class
16:58:33 <tiglionabbit> cypher-: why do I want to rebuild ghc?
16:58:43 <dabbler> > Enum Char
16:58:45 <lambdabot>   Not in scope: data constructor `Enum'Not in scope: data constructor `Char'
16:58:46 <dbueno> @src Enum
16:58:46 <lambdabot> class  Enum a   where
16:58:46 <lambdabot>     succ                     :: a -> a
16:58:46 <lambdabot>     pred                     :: a -> a
16:58:46 <lambdabot>     toEnum                   :: Int -> a
16:58:46 <lambdabot>     fromEnum                 :: a -> Int
16:58:49 <lambdabot> [3 @more lines]
16:58:58 <cypher-> tiglionabbit: sorry, misread you
16:59:00 <dbueno> > ['a' .. 'e']
16:59:01 <lambdabot>   "abcde"
16:59:03 <dabbler> > @more
16:59:04 <lambdabot>   <no location info>: parse error on input `@'
16:59:12 <dbueno> > succ 'a'
16:59:13 <lambdabot>   'b'
16:59:25 <dbueno> > toEnum 100 :: Char
16:59:27 <lambdabot>   'd'
16:59:31 <tiglionabbit> hm, I already have openssl 0.9.8
17:00:09 <dabbler> ah cool, i got it now
17:00:37 <dabbler> thanks
17:01:09 <Cale> Gracenotes: I'm just trying it on an array of 1000000 elements myself. It's taking a long time, but it hasn't crashed yet.
17:01:29 <Gracenotes> mm. I'm reading mine from a 160 MB file.
17:01:41 <tiglionabbit> it seems pretty clear it's missing a constant
17:01:42 <Gracenotes> takes a couple of seconds
17:01:46 <Cale> I'm generating 1000000 random elements
17:01:52 <Gracenotes> Cale: forgot to mention, Index is Word64
17:01:56 <Gracenotes> not like it should it matter too much
17:02:00 <Cale> I just went with Int
17:02:23 <Cale> Hmm, it worked.
17:02:37 <Gracenotes> sorted completely?
17:02:47 <dbueno> dabbler: np
17:03:10 <Cale> Well, it finished running.
17:03:37 <tiglionabbit> what's the proper way to report difficulty with a package?  Email the maintainer?
17:03:39 <Cale> It... doesn't appear sorted.
17:04:37 <SamB> tiglionabbit: sure!
17:04:40 <Gracenotes> o_o
17:05:06 <Gracenotes> that is odd.
17:05:20 <Cale> cale@zaphod:~$ ghc -O2 --make quick.hs
17:05:20 <Cale> [1 of 1] Compiling Main             ( quick.hs, quick.o )
17:05:20 <Cale> Linking quick ...
17:05:20 <Cale> cale@zaphod:~$ ./quick
17:05:20 <Cale> [(-1250407192,-899908888),(-1883636055,1647226862),(280104506,1082807653),(746852069,271515569),(-1775141269,66796508),(-1598886148,-759419038)...
17:05:44 <Cale> compiling with -O2 makes it a good deal faster than in ghci, btw ;)
17:05:52 <Gracenotes> oh, right.
17:06:00 <Gracenotes> *always forgets*
17:06:25 <Cale> All that I changed was that thing about g
17:06:29 <Cale> and I added a main
17:06:33 <Cale> main = do a <- bigRandomArray
17:06:33 <Cale>           quicksort a 1 big
17:06:33 <Cale>           print =<< getElems a
17:06:40 <Cale> big = 1000000
17:06:40 <Cale> bigRandomArray :: IO (IOArray Int (Index, Index))
17:06:40 <Cale> bigRandomArray = newListArray (1,big) =<< replicateM big (liftM2 (,) Mersenne.randomIO Mersenne.randomIO)
17:07:39 <Cale> (and I re-indented your code, but that's not a big deal :P)
17:08:04 <Gracenotes> that is odd. I must have screwed some bounds up... it sorts [1..10] as [10,1,2,9,7,4,6,3,5,8]
17:08:08 <dons> mux: did you get a chance to try the new .tar.gz on FreeBSD?
17:08:13 <Gracenotes> still, the stack overflow is odd
17:08:26 <Cale> Gracenotes: The wonders of imperative-style programming ;)
17:08:28 <dolio> @seen pumpkin
17:08:28 <lambdabot> pumpkin is in #haskell-blah, #haskell-in-depth, #darcs, #ghc and #haskell. I don't know when pumpkin last spoke.
17:08:34 <dolio> @seen copumpkin
17:08:34 <lambdabot> I saw copumpkin leaving #ghc, #darcs, #haskell-blah, #haskell-in-depth and #haskell 17h 3m 31s ago, and .
17:08:37 <Cale> Yeah, I'm not seeing the stack overflow myself.
17:08:44 <Gracenotes> this time, sorted as [8,7,5,6,2,1,3,9,4,10] :)
17:08:48 <Cale> Which means that it's probably not the sort which is causing it?
17:08:49 <Gracenotes> thank you, mersenne
17:09:11 <Cale> Here, I'll paste my whole file, and you can try it.
17:09:17 <Elly> it seems fitting that every channel containing pumpkin does not contain copumpkin
17:09:26 <Gracenotes> Cale: I'm pretty sure it is. .. or maybe it's the fact that I read it from Data.Binary?
17:09:52 <Cale> Gracenotes: It might have something to do with the way you're reading the file, I suppose.
17:09:59 <Gracenotes> justReadIt u = do { let y = flip runGet u $ replicateM (numChains u) get  in  newListArray (0, numChains u) y } where numChains bstr = fromIntegral $ BSL.length bstr `div` 16
17:10:03 <Gracenotes> justReadIt :: BSL.ByteString -> IO (IOArray Int (Index, Index))
17:10:04 <dons> the platform comes with: http://www.galois.com/~dons/packages/contents.html
17:10:07 <dons> what do people think of that page?
17:10:26 <Cale> Gracenotes: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2341#a2342
17:11:07 <dolio> Quicksort is using random numbers?
17:11:19 <Cale> dons: I like it, myself.
17:11:28 <dolio> You should do median-of-three, man.
17:11:46 <billls> if i want to use 'map words' in this definition where should I enter it
17:11:47 <billls> swearStrings :: [String]
17:11:48 <billls> swearStrings = ["how rude", "theres no need to swear", "thats not very nice"]
17:11:58 <billls> right after the = ?
17:12:07 <Cale> billls: map (map words) [...]
17:12:14 <billls> thank you
17:12:19 <Gracenotes> dolio: why stop there? medium of medium of three!
17:12:27 <Cale> billls: Will break each of the strings into words
17:12:35 <Gracenotes> Cale: I get a stack space overflow this time
17:12:42 <Cale> Gracenotes: with my code?
17:12:45 <Gracenotes> not a vanilla "stack overflow"
17:12:47 <Gracenotes> yes
17:12:57 <Cale> Very interesting, which GHC?
17:13:06 <Gracenotes> 6.8
17:13:09 <Cale> hmmmm
17:13:14 <Cale> I'm using 6.10.1
17:13:14 <dolio> I don't remember why you should stop at three. But I seem to recall it being the magic number.
17:13:24 <billls> cale: it responds with an error
17:13:25 <billls> *** Type           : [[Char]] -> [[String]]
17:13:25 <billls> *** Does not match : [Char] -> [[String]]
17:13:41 <Cale> oh, duh
17:13:46 <Cale> yeah, just map words will do
17:13:53 <billls> cool, nice one
17:13:58 <Cale> > map words ["how rude", "theres no need to swear", "thats not very nice"]
17:13:59 <lambdabot>   [["how","rude"],["theres","no","need","to","swear"],["thats","not","very","...
17:14:38 <Cale> 失礼なぁぁぁ
17:14:49 <Gracenotes> commie! :o
17:15:13 <Cale> commie?
17:15:13 <billls> now the error *** Type           : [[String]]
17:15:13 <billls> *** Does not match : [String]
17:15:14 <billls> D:
17:15:19 <Gracenotes> so, yes, the incorrectness of this quicksort is odd
17:15:35 <Cale> billls: your type declaration is incorrect now
17:15:36 <Gracenotes> and the overflowing
17:16:05 <Cale> Gracenotes: If it's not too much trouble, you might want to try the newer GHC and see if that makes a difference.
17:16:41 <Gracenotes> oh. last time I tried that I spend 2 hours and gained nothing but a half-broken apt-get dependency tree :)
17:16:45 <Gracenotes> t
17:16:49 <Cale> whaaaat
17:17:09 <Cale> The generic linux binaries available on the GHC website work for me.
17:17:51 <Cale> I prefer 6.10.1 over 6.10.2. You could also wait a couple days and 6.10.3 is going to come out to fix the stupid brokenness of 6.10.2.
17:18:40 <Gracenotes> removing 6.8 failed for some reason. then, trying to make all the apps see 6.10 but not 6.8 didn't turn out well
17:18:58 <Cale> ah :P
17:19:06 <Cale> Weird.
17:22:02 <billls> Cale: i'm trying to achieve the opposite now, using map unwords on a list of lists of strings -> swears :: [Phrase]
17:22:02 <billls> swears =  [["how","rude"], ["no","need","to","swear"], ["thats","not","very","nice"]]
17:22:14 <billls> i've tried both map unwords, and map (map unwords) throws an error with both
17:22:16 <billls> any idea why?
17:22:38 <Gracenotes> 'map unwords' should work.....................
17:22:39 <Ralith> > unwords ["foo","bar"]
17:22:40 <lambdabot>   "foo bar"
17:22:44 <Guest588> > map unwords [["how","rude"], ["no","need","to","swear"], ["thats","not","very","nice"]]
17:22:45 <lambdabot>   ["how rude","no need to swear","thats not very nice"]
17:22:57 <yurinotigor> forgive my basic/stupid question, but now that I have cabal and ghci installed how can I make ghci "see" the modules that I install using cabal? I did cabal install HDBC, saw the module being successfully installed in ~/.cabal/lib, but :l HDBC doesnt work in ghci.
17:22:58 <Cale> billls: Delete your explicit type signature.
17:23:22 <Cale> yurinotigor: It'll be :m + ModuleName
17:23:51 <Cale> yurinotigor: You shouldn't have to specify the package itself
17:24:04 <Cale> in this case...
17:24:09 <Cale> :m + Database.HDBC
17:24:13 <Cale> ought to work
17:24:45 <billls> does not using an explicity type sig mean I now can't do anything I could with one?
17:24:48 <billls> -y
17:25:10 <Cale> billls: You can always add in a correct type signature after, but I suspect your current one is wrong
17:25:21 <billls> i've just deleted it totally at the moment
17:25:22 <Cale> billls: However, I don't know how the type Phrase is defined.
17:25:22 <yurinotigor> Cale: jeezz, it works like a charm... now I am feeling even more stupid than I did 2 mins before. does that mean that .cabal is automatically in the "path" of ghci?
17:25:30 <billls> type Word = String
17:25:30 <billls> type Phrase = [Word]
17:25:44 <Cale> yurinotigor: All the packages which ghc-pkg knows about are
17:26:01 <Cale> yurinotigor: Supposing that they are 'exposed'
17:26:18 <Cale> ghc-pkg list
17:26:27 <yurinotigor> Cale: I see. thanks a million
17:26:49 <Cale> will report the packages and which package.conf they're registered in on your system -- there's usually a global one and a per-user one
17:27:25 <Cale> Packages which appear in parens are hidden, and so their modules won't be available by default from ghci
17:27:27 <cypher-> not really a haskell question, but I thought you guys might know: is the polynomial time reduction relation symmetric?
17:27:42 <yurinotigor> Cale: so cabal uses internally ghc-pkg which keeps track of everything that was installed?
17:27:46 * cypher- is trying to finish his complexity homework..
17:27:51 <Cale> yurinotigor: yeah
17:27:57 <yurinotigor> Cale: grazie
17:28:44 <Cale> cypher-: I don't think so, no.
17:29:06 <cypher-> Cale: how would I go about proving this?
17:29:24 <Cale> cypher-: For example, I can, in polynomial time, reduce the trivial problem to, oh, graph isomorphism. But I can't do the reverse at all.
17:30:21 <Cale> (where the trivial problem is the one where the answer is always True, say)
17:30:42 <billls> @src (\)
17:30:42 <lambdabot> Source not found. Where did you learn to type?
17:30:48 <billls> @src \
17:30:48 <lambdabot> Source not found. My mind is going. I can feel it.
17:30:50 <billls> ;(
17:30:57 <Cale> billls: That's a lambda :)
17:31:01 <Cale> > (\x -> x^2) 6
17:31:03 <lambdabot>   36
17:31:14 <Cale> It's a way to construct functions without giving them names
17:31:25 <billls> ah! thanks
17:31:36 <Cale> The stuff after \ but before -> are the parameters of the function
17:31:45 <Cale> and after the -> is the result
17:32:18 <Cale> > map (\x -> x^2 + x + 1) [1..10]
17:32:19 <lambdabot>   [3,7,13,21,31,43,57,73,91,111]
17:32:54 <billls> so it's doing it for x = everything from 1 - 10, yeah?
17:32:58 <Cale> yeah
17:33:18 <Cale> > map (\x -> (x, x^2 + x + 1)) [1..10]
17:33:20 <lambdabot>   [(1,3),(2,7),(3,13),(4,21),(5,31),(6,43),(7,57),(8,73),(9,91),(10,111)]
17:33:24 <bombshelter13_> Does anyone have any good articles/posts/pages/whatever that might give some good examples of how a language like Haskell can eliminate entire classes of bugs common in imperative languages? Trying to make the case for Haskell to an OOP-drugged coworker
17:34:12 <Cale> bombshelter13_: Hmm, good question, usually I just do that explanation myself rather than referring to a website...
17:34:47 <bombshelter13_> Yeah, I'm just not as eloquent as I could be and know I've read some good explanations in the past, just can't find any of em atm
17:34:55 <Cale> hmm
17:35:39 <MyCatVerbs> bombshelter13_: http://www.alpheccar.org/en/posts/show/73 is a decent example of the sorts of proofs that you can embed in Haskell's type system without much grief.
17:36:01 <Cale> But there's so many bugs which go away even short of proofs.
17:36:27 <newsham> bomb: type safety prevents bugs like buffer overflows (also the case in other type safe langauges).  the use of Maybe separates out error condition that are often reported via NULL pointers which lead to many mistakes.  equational reasoning can make it easier to prove certain properties of your code.
17:36:38 <Cale> All the sorts of things which have to do with failure to understand the state which the system is in.
17:37:11 <Cale> Purity makes testing easier because you no longer can have the sort of bug where the function works in isolation and then breaks in actual usage.
17:37:59 <bombshelter13_> Yeah, a lot of it does seem to resolve around the lack of state, it's just tricky to explain to someone whose so ingrained in the mindset that programming is basically about mutating variables in place. :/
17:38:05 <tombee> So is haskell defined as entirely state free?
17:38:09 <tombee> :s
17:38:29 <newsham> the testing can be made easier by purity and type system, too.  you can specify properties you expect your code to have and have test cases autogenerated to verify those properties
17:38:33 <MyCatVerbs> tombee: Hell no. But in practice almost always, yes.
17:38:39 <Cale> tombee: It has a well-defined completely state-free subset which is enforced at the type system level.
17:38:40 <newsham> and then if you want higher assurance you can use equational reasoning on those same properties
17:38:45 <newsham> to make more formal proofs
17:39:20 <Cale> tombee: In particular, if I have a function of type A -> B, all that it can do is take an A, and produce a value of type B.
17:39:29 <newsham> you can easily program haskell in an imperative mindset with lots of state... its really up to the programmer ot use the tools to his advantage and minimize state (if thats his desire)
17:39:32 <Cale> It can't go to the network or disk
17:39:34 <MyCatVerbs> bombshelter13_: easy and convenient tuples, Either and Maybe make it easy to write and use functions that return multiple results, results of different types, and optional results. Pattern matching makes this stuff particularly easy to get right.
17:39:34 <tombee> But how is that state free? :)
17:39:47 <billls> is there a way of making: found :: Eq a => [a] -> [a] -> Int -> Bool, work so that found "na" "bananas" 2, returns true ?
17:39:54 <Cale> tombee: and it can't examine anything except constants which are in scope, and the value A.
17:40:13 <Berengal> billls: isInfix
17:40:14 <Cale> tombee: That is, the resulting value of type B depends *only* on the value of type A we give it.
17:40:40 <MyCatVerbs> billls: looks like, found pattern text index = isPrefixOf pattern (drop index text)
17:40:50 <Cale> If we give it some value x, it must give the same result y every time we do so.
17:40:50 <tombee> See, I'm not trying to troll here, I merely am confused, as my idea of state is a turing machine with a 0 length tape.
17:41:10 <newsham> > let found p w n = p `isPrefixOf` drop n w in found "na" "bananas" 2
17:41:11 <lambdabot>   True
17:41:12 <tombee> So without state nothing can be computed? :s
17:41:27 <Berengal> tombee: Lambda calculus doesn't have state, and is turing complete
17:41:31 <dolio> Gracenotes: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4585#a4585
17:41:58 <bombshelter13_> i suppose you could say that state is required to actually compute, but not to describe the computation.
17:42:12 <Cale> tombee: In our informal usage, state is, I suppose, all that data which the result of a computation can depend upon which it doesn't explicitly get as a function parameter.
17:42:27 <Cale> (and which is not constant)
17:42:41 <Gracenotes> dolio: oh, nice :) although, I suppose I will end up need MUArr, since introsort requires it too
17:42:44 <tombee> Hmm ok.
17:42:49 <Berengal> bombshelter13_: You could also say that the computation is equal to the answer so there's no need to compute ;)
17:42:58 <Gracenotes> ing
17:43:12 <Cale> tombee: State is usually thought of as something which can be updated from some other part of the program and affect the result of one computation when carried out multiple times.
17:43:25 <Gracenotes> so the last line of getU can be chopped off. I'll experiment with this!
17:43:31 <dolio> Gracenotes: That eats all my memory for output for a really large array, but it's a first pass. :)
17:43:42 <dolio> I don't know about getting.
17:43:45 <bombshelter13_> Berengal: only works if you already have the answer
17:44:07 <Cale> tombee: So for instance, in OO programming, the state is usually held in the member variables of various objects.
17:44:08 <Gracenotes> ah. Well, so long as it's no more memory than the information itself, 1000000 16-byte elements
17:44:29 <tombee> Ah ok Cale, so we are talking about a high level of abstraction state :)
17:44:51 <Berengal> bombshelter13_: But you do, except it isn't reduced.
17:45:40 <bombshelter13_> heh, touche
17:45:42 <dolio> Gracenotes: Well, I suspect it builds lots of thunks.
17:45:51 <dolio> It's definitely using more memory than the array itself would.
17:45:58 <Cale> Failure to account for potential changes in that state can cause a program which works in testing to suddenly fail in real usage, which is what makes testing imperative programs hard.
17:46:43 <Cale> OO can be thought of as an attempt to limit the effects of state on other components of the program, but it doesn't do it in a way which is absolute.
17:47:22 <Cale> (and you can still have local state - variables which are updated as a loop executes, and so on)
17:47:26 <dolio> But, it actually gets the right array back when you read it in. :)
17:49:54 <newsham> cale: eh?  OO wraps up lots of state into various objects in a way that still affects the rest of the program.
17:50:09 <newsham> ie car.move(10,20) <- car's state is visible and mutable externally
17:50:35 <Cale> newsham: It does, but perhaps offers a way to limit the possible ways that the state of an object can affect the rest of the program.
17:51:14 <Cale> (because you can, say, only allow access to that state via particular methods)
17:51:55 <bombshelter13_> objects are basically just chunks of state :/ you have the same amount of state, just in larger pieces
17:52:15 <Cale> With perhaps smaller than the full read/write interface.
17:53:05 <Cale> From outside an object, you might only be able to access the state it represents through a very particular sort of interface which prevents things from going *too* wrong.
17:53:15 <dolio> Gracenotes: Okay, I've got a version of putU that doesn't leak space. It's merely slow. :)
17:55:50 <Gracenotes> ah, good
17:56:19 <Cale> (So it's better than a completely unrestricted memory model)
17:56:58 <Cale> But it's still stateful programming, and the same sorts of bugs can occur.
17:57:43 <edwardk> hrmm, is there a deep reason why the monadfix instance is missing from STM?
17:59:38 <Lemmih> edwardk: I'm not sure if your benchmark accurately accounts for commen State usage.
18:00:13 <Lemmih> edwardk: Most of the time is spent creating the huge call graph.
18:00:49 <rieux_> speaking of monadfix, is it definable for Cont?
18:00:51 <edwardk> Lemmih: fair enough, i just took the one mmorrow had lying around
18:01:01 <Lemmih> edwardk: The lazy (and polymorphic) version is ~10 faster than the fastest unpacked cpr version.
18:01:38 <johnnowak> does anyone know where i can find information about pause times with ghc's gc? i'd like to use it for soft real-time applications but am concerned about performance
18:01:39 <lambdabot> johnnowak: You have 1 new message. '/msg lambdabot @messages' to read it.
18:01:47 <edwardk> Lemmih: i'll take better benchmarks =)
18:02:48 <Lemmih> (I of course meant ~10x faster)
18:03:02 <edwardk> lemmih: i have a whole host of monads to test, so any benchmarks is good http://comonad.com/haskell/monad-ran/Control/Monad/Ran.hs
18:03:03 <edwardk> yeah
18:03:14 <edwardk> er are good
18:03:33 <dolio> Gracenotes: Well, for some reason, my output code is O(n^2), it seems.
18:03:40 <dolio> Input is O(n), though.
18:04:15 <Lemmih> edwardk: I keep all my good benchmarks next to my unicorns and honest politicians.
18:04:25 <edwardk> hah
18:04:33 <edwardk> i wondered who was hogging all of those
18:05:52 <MyCatVerbs> @quote Lemmih I keep all my good benchmarks next to my unicorns and honest politicians.
18:05:53 <lambdabot> No quotes match.
18:06:03 <MyCatVerbs> Er, wrong one.
18:06:29 <Lemmih> ?quote lemmih
18:06:29 <lambdabot> Lemmih says: <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
18:09:33 <defun> So haskell has a runtime system to manage memory. Would it be correct to assume that all languages that operate on a higher level than binary/asm/C have runtime systems as well?
18:10:15 <johnnowak> defun: no, some languages like ML have implementations that use region inference
18:10:16 <Twey> C has a runtime system
18:10:20 <Lemmih> defun: C also has such a runtime system.
18:10:27 <Berengal> defun: Define higher-level and runtime system
18:12:48 <Lemmih> defun: Most high-level languages use automatic memory management. The implementation details vary greatly.
18:13:00 <defun> I see.
18:14:00 <defun> So no programs (other than bin/asm) can run without a 'runtime system'.
18:14:27 <defun> Meant to put '?' not '.'.
18:15:32 <defun> ?
18:15:34 <Lemmih> defun: That depends on what you mean by a runtime system. Some compilers blend in the rts with the normal user code.
18:15:36 <rieux_> it depends on how you define run-time system
18:15:50 <defun> I think I see what you mean.
18:16:16 <rieux_> even C defines both a "hosted" mode, where you have an RTS (the C library) and a "standalone" mode, where you pretty much don't.
18:16:54 <defun> Sorry for pestering you with these questions, however it will be nearly a week b4 I get some compiler/language design books. Thanks.
18:21:41 <gwern> I don't understand proggit sometime
18:21:41 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
18:22:04 <gwern> here's a poem in the new yorker, made almost entirely of entries from the hacker jargon file and it gets downvoted! http://www.reddit.com/r/programming/comments/8hs5c/hackers_can_sidejack_cookiees/
18:22:11 <gwern> 3 times!
18:22:30 <dons> gwern: don't try to understand reddit.
18:22:31 <jmcarthur> perhaps they don't know what the jargon file is
18:22:35 <gwern> that is awesome on so many levels, yet...
18:22:37 <dons> the mob can not be reasoned with
18:22:56 <jmcarthur> the jargon file is rather old school knowledge
18:22:58 <gwern> jmcarthur: you think so? I don't want to live in a world where proggiters don't know the jargon file!
18:23:26 <jmcarthur> and yet i know what it is... perhaps i am mistaken
18:23:49 <gwern> dons: then what does one do with the mob? dress it up in cute spats?
18:24:37 <gwern> @messages
18:24:37 <lambdabot> ndm said 14h 30m 1s ago: no, isSpace is still buggy - the supero paper has the bug id in it
18:24:49 <gwern> bleh. how hard could it be to fix...
18:25:55 <gwern> ah, http://hackage.haskell.org/trac/ghc/ticket/1473 and I'm already subscribed. mind like a steel trap, memory like a steel sieve...
18:31:40 <mmorrow> hahah
18:31:44 <mmorrow> "...and wetware lives in meatspace."
18:32:38 <sclv_> learning duffs device from the jargon file was one of my first wao programming moments.
18:32:43 <gwern> see? it's not a bad poem! considering the source matieral, anyway
18:33:00 * gwern was rooting for 'fandango on the core', but at least there *was* a the core
18:33:02 <edwardk> duff's device was downright handy
18:36:00 <p_l> gwern: there's a new variant of core memory available :)
18:36:28 <gwern> madness. next you'll be telling me about interpreters for virtual machines
18:36:38 <p_l> hahaha
18:37:03 <p_l> core memory can make a comeback because of low power usage (no refreshing! no standby current!)
18:38:15 <younder> Or we could just go back to using gears. No powerusage at all..
18:38:54 <p_l> younder: We are, but the machinery to make them small is not yet available :D
18:39:26 <mmorrow> gears made out of molecules!
18:40:01 <p_l> and 1TiB/s I/O bandwidth on equivalent of SD card... :P
18:43:09 <younder> Kind of reminds me of "When computers were human"
18:43:23 <younder> http://books.google.com/books?id=_J7C23dn_3cC&dq=when+computers+were+humans&printsec=frontcover&source=bn&hl=en&ei=bJn_Sc-rLJeLsAbxseGjBg&sa=X&oi=book_result&ct=result&resnum=6
18:44:44 <younder> In particular "many ingeneers end up marrying the computers.."
18:44:57 <p_l> lol
18:45:03 <younder> I sometimes wonder if that still isn't true.. ;)
18:48:39 <dolio> Gracenotes: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4585#a4586
18:49:37 <dolio> Gracenotes: Writes 1 million (Word64 :*: Word64)s in 4s, reads them in 4s here.
18:51:37 <dolio> Gracenotes: My bad, had it reading back in to the wrong type. Reading is around 8 seconds.
19:03:27 <dabbler> can someone make me a two dimensional array filled with zeroes
19:04:37 <brian6> poof. you're a two dimensional array filled with zeroes.
19:04:54 <dolio> @yow!
19:04:54 <lambdabot> We are now enjoying total mutual interaction in an imaginary hot tub ...
19:05:01 <saml> dabbler, sec. let me read the doc and give it to you
19:05:17 <dabbler> saml: ooh that'd be awesome
19:05:18 <saml> > listArray "hello"
19:05:19 <lambdabot>   Couldn't match expected type `(i, i)'
19:06:52 <saml> > listArray (0,1) [[0,0], [0,0]]
19:06:53 <lambdabot>   array (0,1) [(0,[0,0]),(1,[0,0])]
19:07:08 <saml> 2 by 2 array there
19:08:14 <dabbler> saml: cool, can i get values by index then?
19:08:18 <saml> > let arr = listArray (0,1) [[0,0], [0,0]] in arr ! 0 ! 0
19:08:19 <lambdabot>   Couldn't match expected type `Array i e'
19:08:28 <saml> > let arr = listArray (0,1) [[0,0], [0,0]] in arr ! 0 !! 0
19:08:30 <lambdabot>   0
19:08:42 <dabbler> > arr ! 1 !! 1
19:08:43 <lambdabot>   Couldn't match expected type `Array i e'
19:09:18 <dabbler> > let arr = listArray (0,1) [[0,0], [0,0]] in arr ! 1 !! 1
19:09:19 <lambdabot>   0
19:09:27 <dabbler> saml: awesome, thx
19:09:29 <saml> > let arr = listArray (0,1) [[0,0], [0,0]]; at arr (x,y) = arr ! x !! y in at arr (1,1)
19:09:31 <lambdabot>   0
19:09:57 <saml> dabbler, but i don't know. i just used array for the first time. there might be a better way to do multidimensional array
19:10:02 <dabbler> saml: ooh even better
19:10:05 <saml> my 2 by 2 array isn't erally array
19:10:14 <saml> it's a 1D array of haskell lists
19:10:55 <dabbler> oh, so it wont scale performance?
19:11:28 <saml> > let arr = listArray ((0,1), (0,1)) [[0,0], [0,0]]; at arr (x,y) = arr ! x ! y in at arr (1,1)
19:11:29 <lambdabot>   Couldn't match expected type `Array i e'
19:11:50 <saml> > let arr = listArray ((0,1), (0,1)) [[0,0], [0,0]] in arr ! (1,1)
19:11:52 <lambdabot>   * Exception: Error in array index
19:13:07 <dabbler> array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) | i <- [1..3]]
19:13:11 <dabbler> > array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) | i <- [1..3]]
19:13:12 <lambdabot>   <no location info>: parse error on input `|'
19:14:09 <dabbler> array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) ) | i <- [1..3]]
19:14:17 <dabbler> > array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) ) | i <- [1..3]]
19:14:19 <lambdabot>   array (1,3) [(1,array (1,3) [(1,0),(2,0),(3,0)]),(2,array (1,3) [(1,0),(2,0...
19:14:45 <dabbler> > let a = array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) ) | i <- [1..3]]
19:14:47 <lambdabot>   <no location info>: parse error on input `;'
19:14:55 <hotaru2k3> > listArray (0,1) [listArray (0,1) [0,0], listArray (0,1) [0,0]]
19:14:56 <lambdabot>   array (0,1) [(0,array (0,1) [(0,0),(1,0)]),(1,array (0,1) [(0,0),(1,0)])]
19:15:07 <dons> hey, does anyone remember a site recently about "10 requirements for open source project sites" or something similar?
19:15:19 <dons> it was a list of things every open source project should be able to answer on their front page
19:15:42 <dabbler> > let myArray = array (1,3) [(i, (array (1,3) [(j, 0) | j <- [1..3] ] ) ) | i <- [1..3]]
19:15:44 <lambdabot>   <no location info>: parse error on input `;'
19:16:57 <dolio> dons: How do you typically do foldr type stuff with UArrs? I tried writing a manual loop with nullU, headU and tailU, but that ended up being spectacularly bad.
19:17:13 <dons> hmm. use foldl?
19:17:35 <dons> foldr should be fine though (?).
19:17:38 <dolio> I suspect because tailU was building up a bunch of stuff with its False :*: e substitute.
19:17:54 <dons> mm
19:18:06 <saml> dons, http://www.kalzumeus.com/2009/03/07/how-to-successfully-compete-with-open-source-software/  ?
19:18:08 <dolio> foldl wasn't an option, because of unavoidable thunk buildage. And foldrU doesn't exist?
19:18:27 <saml> sorry it's not 10
19:18:34 <dons> no, i don't think that's it saml. iirc it cited coucdb as its example, if that helps
19:18:38 <dons> couchdb
19:18:56 <dolio> I ended up doing fromU and then foldr on the list, which worked fine, but it's kind of a cop-out.
19:19:02 <dons> hmm
19:22:57 <Cale> It's a little surprising there wouldn't just be a Foldable instance.
19:23:52 <dolio> dons: Specifically, I think 'tailU . tailU . tailU . ... . tailU $ s' constructs a stream such that headU is O(n), where n is the number of tailUs.
19:24:11 <dons> hmm.
19:24:16 <dons> that's interesting!
19:27:48 <dolio> dons: Evidence: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4587#a4587
19:29:48 <mmorrow> dolio: that example isn't clear enough for me.
19:30:43 <dolio> mmorrow: It demonstrates that using headU, tailU and nullU to turn a UArr e into an [e] of the same length is O(n^2).
19:31:07 * mmorrow needs to add more ";)"s ;)
19:31:13 <dolio> Ah. :)
19:31:17 <mmorrow> heh
19:31:42 <mmorrow> that looks like it's from a textbook
19:32:42 <mmorrow> that reminds me, i was going to graph something related to timing some prog for diff inputs that was going to be really nice..
19:32:48 <mmorrow> now to remember what it was
19:34:14 <edwardk> heya mmorrow
19:34:41 <mmorrow> hiya
19:41:02 <dolio> Cale: You can't have a Foldable instance, because the elements are constrained.
19:41:15 <Cale> dolio: ah, right.
19:42:28 <tombee> In the OSCON video #2, did anyone else sit there thinking 'huh?' at the quickcheck stuff? :p
19:50:35 <tombee> @src quickcheck
19:50:35 <lambdabot> Source not found. Take a stress pill and think things over.
19:56:38 <adamvo> tombee: read the papers for quickcheck?
20:00:07 <gnuvince_> Does anyone have the problem with Emacs that when they use C-c C-l in haskell-mode (load-file), newlines in the ghci listener are replaced with literal ^J characters?
20:02:51 <Squeezer> Hello guys
20:09:34 <dabbler> what does a => in a functions type mean?
20:09:50 <true\false> Constraint
20:10:06 <centrinia> dabbler, It separates the class constraints from the type.
20:11:08 <dabbler> is there somewhere that explains it?
20:12:09 <centrinia> Yes, the Haskell 98 specification. :p
20:12:30 <dabbler> oh man
20:13:20 <adamvo> I think that most tutorials get to typeclasses
20:13:58 <adamvo> in case you're looking for a less formal description
20:14:41 <dabbler> so it just forces everything to be within the class before the => ?
20:16:39 <Lemmih> dabbler: What?
20:17:11 <dabbler> Lemmih: i dunno
20:18:11 <centrinia> dabbler, You can have multiple class constraints before the =>
20:20:46 <shachaf> dabbler: "(Num t) => t -> t" means a function from t to t, for any particular t that is in the class Num.
20:20:50 <edwardk> i wonder if tweaking Data.Binary's Get to use newtype Get a = Get { unGet :: forall o. (a -> ForeignPtr Word8 -> Int# -> Int# -> L.ByteString -> Int64# -> o) -> ForeignPtr Word8 -> Int# -> Int# -> L.ByteString -> Int64# -> o } -- is going too far.
20:21:40 <dabbler> shachaf: ah that's what i thought
20:21:44 <dabbler> thanks
20:22:55 <dabbler> so you could also do (Num a, Char b) => a -> b -> a  ?
20:23:36 <shachaf> Yes.
20:23:45 <rieux_> if Char were a type class, you could
20:23:50 <shachaf> Er, whoops.
20:23:55 <shachaf> I misread that.
20:24:00 <shachaf> No, Char isn't a type class, it's a type.
20:24:24 <shachaf> You'd just say (Num a) => a -> Char -> a
20:24:49 <dabbler> oh, yeah that was tricky, heh
20:34:41 <dabbler> I just made a function with type (Num t, Enum t, Ix t) => t -> e -> Array t e. Or at least that's what ghci inferred. What does that mean about the type of t?
20:35:06 <augustss> Exactly what it says
20:35:20 <c_wraith> It supports the operations defined in each of those classes.
20:35:24 <augustss> That it has to be in classes Num, Enum, and Ix
20:35:38 <c_wraith> Which means that you used operations defined in all of those classes
20:35:56 <dabbler> oh, okay, so it's read as an AND rather than an OR
20:36:03 <augustss> yes
20:36:10 <dabbler> cool, thx
20:36:13 <augustss> There's no OR
20:36:38 <dabbler> in english?
20:36:41 <dabbler> :P
20:37:04 <c_wraith> correct.  we use careful constructions involving nand to convey the concept
20:42:09 <scutigera> opinions on a graphics library for simple 2D graphics ?  HGL and Hieroglyph look promising.
20:43:31 <ksf> "foo = ask >>= \(x,y,z) -> lift $ do" looks ugly.
20:45:18 <ksf> there's gotta be a way to do monad transforming that isn't bound to end up in knots and lift orgies.
20:45:42 <ksf> like, extending typeclasses or something.
20:46:14 <ksf> or, even better, invent typeclass transformers.
20:46:40 <Cale> scutigera: HGL isn't bad for very simple things... I really like Reactive/FieldTrip, but there are still practical issues with it.
20:47:33 <Cale> scutigera: If you install Gtk2Hs, doing graphics with Cairo is fairly nice. I think Hieroglyph is built on top of that... I haven't had a chance to try it though.
20:48:47 <scutigera> Cale: I just need very simple graphics.  I'm trying some hgl code now.  I'll look at reactive/fieldtrip and gtk2hs. thanks.
20:50:05 <Cale> Reactive takes a little bit of getting used to, but I think it will be just the right thing for writing games in the future :)
20:50:27 <scutigera> cabal: ffihugs is required but it could not be found.  I'm running mac os x, and I looked around to see if there was a fink package with ffihugs, but can't find it.  any ideas ?
20:50:33 <Cale> hmm
20:50:42 <Cale> Normally I would recommend GHC/GHCi
20:51:39 <scutigera> Running that too... for some reason I keep typing hugs, not exactly sure why since its development seems to have stopped.
20:52:39 <scutigera> Loading package X11-1.4.5 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 9): image not found) #!$@$%!!!!!  I just new that was going to happen.
20:59:46 <sw17ch> if any one is curious, i just finished part two of my Atom posts: http://www.reddit.com/r/haskell/comments/8hw5v/atom_arduino_first_program_pt_2/
21:00:26 <mmorrow> sw17ch: ooh, interesting
21:00:38 <sw17ch> :)
21:01:08 <sw17ch> mmorrow, i'm holding off on a video of a blinking red LED... some how i'd hate to say "and after all that work, we have this blinking light!"
21:01:22 <mmorrow> haha
21:01:44 <sw17ch> my next post will kinda go through the generated C code, and then hopefully talk about how to build/flash/etc the Arduino board
21:01:47 <sw17ch> but now, i'm tired
21:01:49 <sw17ch> gnight all
21:01:52 <mmorrow> night
21:02:00 <scutigera> sw17ch: oh no you don't, das blinken light is always the first thing you see after spending bucketfulls of money on a hardware project.
21:02:30 <sw17ch> scutigera, hah. true. but some how my glee over the blinking light made my wife concerned...
21:02:36 <mmorrow> heh "das blinken light"
21:02:48 <sw17ch> "Honey, it's just a blinking light." "WHAT DO YOU MEAN __JUST__!?!?"
21:03:43 <scutigera> sw17ch: exactly !
21:07:07 <sw17ch> well, bed for real now
21:07:09 <sw17ch> good night
21:07:10 <dolio> dons: That head/tail thing is kind of fundamental. There's no way to write a non-recursive tail without merely tagging the seed so as to insert a skip, assuming skips can exist in the first place. And head has to walk past all the skips every time it's called.
21:08:14 <dolio> Newly converted lispers beware. :)
21:08:25 <ksf> sure enough, every time you do a pointer deref, the ram has to wind to the right position on the infinite tape it represents.
21:08:57 <dons> dolio: what does the code look like after fusion?
21:10:32 <MOOO> http://www.marie-gets-deflowered.com/?id=43bd20c2
21:16:32 <maurer1> Is there anything like MArray for Map ?
21:17:13 <dolio> dons: Looking at the ghc-core output from the stream-fusion unfoldr example I did more recently, it looks like it should be O(n), but that's not how it acts. Maybe I'm missing something.
21:17:32 <Cale> maurer1: What would that be? A mutable version of Map?
21:18:00 <Cale> maurer1: Map already has rather fast immutable updates, but I suppose it's doable.
21:19:04 <Cale> I'm not sure anyone has done it though.
21:19:26 <maurer1> Cale: I'm trying to implement a specific type of concurrency object, and need some local storage for it to keep track of what each thread interacting with it has done.  I was going to use MArray, but ThreadIDs don't have any nice bounding ranges.
21:19:55 <Cale> Is Map not doable?
21:20:12 <twb> What version of Cabal shipped with GHC 6.8?
21:20:19 <Cale> Or, if you need mutation, something like IORef (Map a b), or MVar (Map a b)
21:20:21 <maurer1> Cale: I suppose just wrapping Map in an MVar would work.
21:20:32 <dolio> dons: Oh, never mind, I figured it out.
21:22:54 <dolio> dons: It gets turned into something like "length acc [] = acc ; length acc (x:xs) = length (1+acc) (slowIdentity xs) ; slowIdentity [] = [] ; slowIdentity (x:xs) = x : slowIdentity xs"
21:24:16 <dons> mmm
21:24:19 <dons> can you send me a test case?
21:24:35 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4587#a4588
21:24:38 <dolio> Two there.
21:25:46 <dons> mm. yes. interesting. thanks. i'll save them into the test cases.
21:26:23 <dolio> The uvector one is a lot harder to read the output of.
21:33:41 <dolio> The uvector one is doing something involving State#s.
21:36:40 <koobs_nical> So, as a present to myself, I've decided to buy me a book on haskell.  Any suggestions, anyone?
21:38:11 <scutigera> I have all of them, I think :-) What's your goal ?
21:38:48 <koobs_nical> A nice, somewhat intellectually straining read.
21:39:13 <scutigera> so more on the programming theory side ?
21:39:14 <koobs_nical> Maybe toward the pratical side of things.
21:39:22 <koobs_nical> Either way.
21:39:33 <koobs_nical> Theory is good, so is practice.
21:39:46 <koobs_nical> No intro stuff, though.
21:40:22 <araujo> practical, RealWorldHaskell, theoretical , Introduction to Functional Programming
21:40:28 <scutigera> practical ? I'll suggest Real World Haskell.  Everything else I have is more intro, since haskell is usually used to introduce functional.
21:40:43 <scutigera> ..programming.
21:41:37 <koobs_nical> How about 'Haskell School of Expression'? Is it good?
21:42:06 <dolio> dons: I changed the uvector one to use (), and foldr turns into a loop like: "foldr f z 0 = z ; foldr f z n = f () (foldr f z (runSTRep (loop 0 1))) where loop i j s = if j == n then (# s, i #) else loop (i+1) (j+1) s" :)
21:42:08 <scutigera> I've got that too, but I haven't spent too much time with it.  I like what I've read so far.
21:42:16 <brian6> koobs_nical: i didn't like it.
21:43:02 <koobs_nical> Why not, brian6?
21:43:07 <dolio> So it computes n-1 at each iteration by adding up 1s to two different variables, one starting at 0 and one starting at 1. :)
21:44:02 <brian6> koobs_nical: at the time, it seemed super abstract and irrelevant to what i was doing.
21:44:15 <brian6> koobs_nical: rwh suited me a lot better.
21:44:34 <koobs_nical> Wow, RealWorldHaskell is brand new.
21:44:54 <koobs_nical> Good reviews, too.
21:45:29 <scutigera> rwh is definitely nice.  quite dense, there is a lot in there. plus you get a nice heavy book for your $ :-)
21:52:55 <koobs_nical> Well that settles it.  Real World Haskell it is!
21:53:25 <koobs_nical> Thanks all, for the suggestions.
22:17:57 <mmorrow> dolio: here's a plot of real/user/sys for your (first) uvector example: http://moonpatio.com/vacuum/gallery/dolio_uvec.png
22:18:05 <mmorrow> (put in that dir for lack of a better place)
22:20:54 <mmorrow> dolio: (this one: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4587#a4587)
22:21:13 <dolio> Cute.
22:21:26 <mmorrow> R++
22:21:48 <mmorrow> (also, imagemagick's
22:21:51 <mmorrow> montage++
22:21:51 <mmorrow> )
22:27:52 <tiglionabbit> can you get a list of types out of an algebraic data type?  Like data Colors = Red | Green | Blue -> [Red,Green,Blue]
22:28:05 <dibblego> you mean data constructors
22:28:16 <tiglionabbit> sure, yes
22:29:31 <tiglionabbit> I'm considering using them like symbols in ruby, but I don't want to repeat myself (declare the enumeration, then declare a list containing it...)
22:33:22 <tiglionabbit> is it possible to retrieve such a list?
22:33:36 <rieux_> tiglionabbit: that's what they're for, sure.
22:33:59 <rieux_> but if you want the list of all of them, i guess you either need to say so, or do something like:
22:34:07 <rieux_> data Colors = Red | Green | Blue
22:34:07 <rieux_>   deriving Enum
22:34:07 <rieux_> allColors = [ Red .. Blue ]
22:34:41 <tiglionabbit> oh, that works
22:35:05 <rieux_> deriving Enum means it should make Colors an instance  of the Enum type class
22:35:27 <rieux_> which has functions such as
22:35:36 <rieux_> @type enumFromTo
22:35:36 <tiglionabbit> would have expected Ord
22:35:37 <lambdabot> forall a. (Enum a) => a -> a -> [a]
22:35:40 <rieux_> ah
22:35:57 <rieux_> Ord lets you compare, but it doesn't necessarily have an idea of "next" or "previous
22:36:03 <rieux_> Enum as next:
22:36:06 <rieux_> @type succ
22:36:07 <lambdabot> forall a. (Enum a) => a -> a
22:36:13 <tiglionabbit> aha
22:36:27 <rieux_> [ Red .. Blue ] is just sugar for enumFromTo Red Blue
22:36:41 <rieux_> the order of the enumeration is the order that you give in your definition
22:37:02 <rieux_> so if you had more colors, you could always do a range from the first to the last of them
22:37:56 <rieux_> (is there a lambdabot equivalent of :i in ghci?)
22:38:19 <davidL> @info Enum
22:38:20 <lambdabot> Enum
22:38:40 <rieux_> ha.  that's not much :)
22:38:43 <davidL> @src Enum
22:38:43 <lambdabot> class  Enum a   where
22:38:43 <lambdabot>     succ                     :: a -> a
22:38:43 <lambdabot>     pred                     :: a -> a
22:38:43 <lambdabot>     toEnum                   :: Int -> a
22:38:43 <lambdabot>     fromEnum                 :: a -> Int
22:38:45 <lambdabot> [3 @more lines]
22:39:11 <maurer1> Is there any way to wait for a thread to terminate?
22:39:39 <tiglionabbit> heh, darn, can't derive enum if I give them arguments
22:39:55 <maurer1> nvm, manual says to use an MVar trigger
22:40:13 <sjanssen> maurer1: not directly, but you can use an MVar to synchronize
22:40:28 <rieux_> tiglionabbit: yeah, that's Enum
22:40:49 <rieux_> you could make your own Enum instance, if you know what you want it to do
22:41:10 <rieux_> but that might be the wrong direction
22:41:10 <tiglionabbit> I'm not sure how it works
22:41:19 <rieux_> well, what do you want it to do?
22:41:44 <tiglionabbit> oh it's a class -- I haven't even read about those yet~  *keeps reading*
22:42:29 <rieux_> yeah, that's why i thought it might be the wrong direction
22:43:32 <rieux_> the other thing is that Enum only makes sense if you can map between your type and natural numbers from 0 to some n ... once your constructors are not nullary ("have arguments", as you said), that can be difficult to do
22:54:18 <tiglionabbit> hm.  Is accumulator passing style recommended in haskell?  I am surprised the guides I've read don't mention it.  Or is that what "strict" implementations do?
22:55:17 <rieux_> you're right that strictness has some bearing on it.
22:57:16 <rieux_> if you were writing, say, sum in SML, and you wanted it to run in constant space, you'd write something like:
22:57:55 <tiglionabbit> yeah that's what I was gonna say.  I see examples of sum as sum' (x:xs) = x + sum xs, and I think, that's not tail recursive
22:57:56 <rieux_> fun sum xs =
22:57:57 <rieux_>   let fun sumacc [] acc = acc
22:57:57 <rieux_>            | sumacc (x::xs) acc = sumacc xs (x + acc)
22:57:57 <rieux_>    in sumacc xs 0
22:57:58 <rieux_> end
22:58:11 <tiglionabbit> end?
22:58:19 <rieux_> yeah, end
22:58:27 <rieux_> let ... in ... end
22:58:33 <rieux_> in SML, anyway
22:58:35 <rieux_> anyway
22:58:47 <tiglionabbit> oh is that another language?
22:59:02 <rieux_> yeah, sorry.  it was Standard ML, since you'd actually write it that way in SML
22:59:10 <rieux_> in Haskell, that's
22:59:15 * tiglionabbit nods
22:59:35 <rieux_> sum xs =
22:59:35 <rieux_>   let sumacc [] acc = acc
22:59:36 <rieux_>        sumacc (x:xs) acc = sumacc xs (x + acc)
22:59:36 <rieux_>    in sumacc xs 0
22:59:52 * sjanssen 's stack overflows
22:59:58 <rieux_> but if you aren't careful, then all those additions that happened right away in a strict language like ML or Scheme will turn into a pile of thunks in Haskell
23:00:07 * sjanssen turns on -O2, everything fixed
23:00:16 <rieux_> and then when you actually do something strict with the result, you get what sjanssen is talking about.
23:00:52 <tiglionabbit> why would that happen?
23:01:19 <rieux_> it's being lazy about the addition (without -O2, anyway)
23:01:29 <rieux_> so when it sees x + acc, it doesn't do that addition and pass the result on
23:02:01 <tiglionabbit> oh, so you can't be explicitly non-lazy if you tried...
23:02:02 <rieux_> it lazily says, well, let's just remember what addition was wanted, and we'll do it when we have to
23:02:08 <rieux_> you can, and people do
23:02:30 <rieux_> or you can hope that turning on optimization causes the compiler to figure out that strictness is what you want.
23:02:44 <rieux_> and if you want to understand that, you'll have to ask someone else :)
23:02:55 <tiglionabbit> yeah, it kinda worries me
23:03:13 <rieux_> it bites now and again.
23:03:25 <sjanssen> tiglionabbit: you can be explicitly non-lazy
23:03:56 <tiglionabbit> sjanssen: how?
23:04:07 <sjanssen> we can change one line there: sumacc (x:xs) acc = sumacc xs $! x + acc -- change one line
23:04:27 <sjanssen> tiglionabbit: with case, seq or a bang pattern
23:04:39 <sjanssen> ($!), for example, uses seq
23:04:41 <rieux_> sumacc (x:xs) acc = acc `seq` sumacc xs (x + acc)
23:04:43 <rieux_> will also do it
23:04:55 <rieux_> not fully strictly, but strictly enough.
23:05:16 <tiglionabbit> what's fully strict?
23:05:17 <sjanssen> sumacc (x:xs) !acc = sumacc xs (x + acc) -- or we can use the bang pattern extension
23:06:20 <rieux_> well, in sjanssen's example, acc gets forced when you enter that case of sumacc, not when you call sumacc
23:06:41 <rieux_> so if you don't add a ! pattern to the other case, the last addition won't be forced
23:07:00 <sjanssen> rieux_: that's not quite accurate
23:07:03 <rieux_> no?
23:07:13 <augustss> no
23:07:21 <sjanssen> 'acc' is the result of 'sumacc'
23:07:38 <sjanssen> when the result of 'sumacc' is forced, so is the final 'acc'
23:07:49 <rieux_> right.  but not before.
23:08:09 <augustss> but the only reason sumacc was callid in the first place was to force the value
23:08:14 <sjanssen> no evaluation happens before the result of 'sumacc' is forced
23:08:24 <rieux_> ah, okay.
23:09:15 <augustss> also, the strictness analyzer does the right thing for sumacc without any anotations
23:10:01 <augustss> assuming + is strict, of course
23:10:16 <augustss> but if + isn't strict it would be wrong to use seq or !
23:12:08 <rieux_> i'm afraid we haven't answered tiglionabbit's original question that well, then.
23:13:27 <augustss> looks like an adequate answer to me :)
23:17:01 <tiglionabbit> my question was, is it generally good to use accumulator passing style?
23:17:38 <Cale> tiglionabbit: I usually like to avoid explicit recursion as much as possible.
23:17:40 <tiglionabbit> I'm assuming the compiler can't give you tail recursion where it is not.  But you brought up another point of... thunk recursion.  Uh..
23:17:48 <sjanssen> tiglionabbit: that question is even mor complicated
23:18:55 <rieux_> maybe a good answer is, if you're using it for premature "optimization," don't.
23:19:02 <Cale> Tail recursion doesn't mean the same thing with regard to programming in lazily evaluated languages that it means to programming in strict ones.
23:19:10 <augustss> tiglionabbit: not generally good.  it depends
23:19:12 <tiglionabbit> so I should wait til I stack overflow and then fix it?
23:20:07 <solidsnack> Wow, if you could fix that site, it'd be great.
23:20:08 <Cale> Well, it's possible to come to an understanding of the way evaluation works, and learn to see where it's likely to be a problem.
23:20:21 <Cale> site?
23:20:31 <solidsnack> Oh, dear.
23:20:38 <tiglionabbit> site?
23:20:45 <solidsnack> Not the tech site, sorry.
23:23:31 <solidsnack> My apologies, really -- I just came off of Reddit and I suppose I've retained a certain inanity. I fear I've completely interrupted.
23:26:56 <adityam> @pl f a = or [g a, h a, l a]
23:26:56 <lambdabot> f = or . liftM2 (:) g (liftM2 (:) h (return . l))
23:27:44 <sjanssen> adityam: or . sequence [g, h, l]
23:29:04 <adityam> thanks sjanssen
23:31:37 <edwardk> woot, figured out the ran transformers for ErrorT and ReaderT
23:31:51 <edwardk> http://comonad.com/haskell/monad-ran/Control/Monad/Ran.hs
23:32:14 <edwardk> that file is growing to be a bit of a beast though
23:33:52 * sjanssen boggles
23:34:11 <tiglionabbit> aw, you can't have two record types with the same accessor functions.  I thought it would be clever and build them with patterns, like accessor (Type1 a b) = a; accessor (Type2 a b c) = b
23:34:47 <edwardk> sjanssen: basically its a bunch of cps transformed monads all in the form forall o. (a -> f o) -> g o -- for some functor f and g.
23:35:47 <edwardk> the biggest problem is the sea of newtypes
23:36:01 <edwardk> they kind of make it hard to see whats happening. Ran f <*> Ran g = Ran (\k -> Reader (\r -> runIdentity (k (runReader (f Identity) r (runReader (g Identity) r))))) -- gets pretty old fast
23:37:35 <edwardk> sjanssen: in the end all that machinery is there so you can just say Ran (ReaderT r (ErrorT e IO)) a -- (that being one that should actually work!)
23:37:42 <edwardk> and it just does the right thing and makes it fast
23:39:13 <quicksilver> tiglionabbit: your excample is slightly nonsense.
23:39:40 <quicksilver> tiglionabbit: patterns are like accessor (Constructor1 a b) or accessor (Constructor2 a b c)
23:39:55 <edwardk> i.e. that one gets turned into something equivalent to forall o. (a -> State# RealWorld -> o) -> r -> (b -> State# RealWorld -> o) -> State# RealWorld -> o
23:40:07 <quicksilver> tiglionabbit: patterns match on constructors, not types - and they must necessarily be constructors of the same type.
23:40:25 <quicksilver> tiglionabbit: indeed, haskell does let you share accessors between constructors of the same type, in this way.
23:40:41 <quicksilver> tiglionabbit: GHC has an extension which permits fields of the same name in different types, but don't use it.
23:41:17 <rieux_> quicksilver: what extension is that?
23:41:43 <edwardk> rieux_: its limited only to data types imported from separate modules
23:42:14 <rieux_> edwardk: qualified?
23:42:17 <adityam> I have a class C with many functions. I want to define instance (N a, N b) => Either a b where f (Left a) = f a; f (Right b) = f b and so on. Is there some way to define such an instance so that I do not have list the definition of all functions?
23:43:51 <edwardk> rieux_: nah, i don't remember what extension it was but the gist of it is if you import data types with accessors with the same name but from different modules even unqualified it can disambiguate
23:44:00 <mgsloan> adityam - you probably don't want a class with many functions
23:44:36 <adityam> mgsloan: Why?
23:45:13 <rieux_> edwardk: thanks.
23:46:20 <mgsloan> adityam: it's just a general design thing - you'll want the most essential functions inside a class, and then have functions defined in terms of those functions external
23:46:30 <dolio> edwardk: Any numbers on Ran (ST s)?
23:46:49 <edwardk> dolio: not yet, i just added in there a few hours ago
23:47:38 <edwardk> dolio: its been a bit of an uphill struggle to get the types right let along test any of it =)
23:47:39 <dolio> I've wondered if it might optimize better, but simply lifting existing ST operations into it probably won't reveal anything.
23:48:03 <edwardk> well, i've been pleasantly surprised by the effects on state
23:48:09 <dolio> And even some primops don't really have the right type.
23:48:12 <edwardk> and its just really a state monad with the world as its argument
23:48:35 <adityam> mgsloan: hmm.... I'll think if I can redesign my functions
23:48:35 <edwardk> note that liftIO, etc don't suffer all that much for calling existing st operations
23:48:55 <edwardk> er st/io
23:49:38 <dolio> The one thing that ST/IO is kind of bad at is optimizing returns of stuff like "IO Int".
23:50:00 <edwardk> i think those would do fairly well in here
23:50:02 <dolio> Since that turns into (# State# s, Int #), and then the Int doesn't get unboxed properly.
23:50:20 <dolio> But I haven't tested if GHC unboxes right with CPS.
23:50:23 <mgsloan> adityam: yeah, probably a good idea.  I've been away from haskell for a while, so I'm not sure if there is actually a good way to do that...  my initial thought was something like fmap, but there's no map equivalent for either because the types are differnet
23:50:41 <edwardk> dolio: actually one sign that its 'the right answer' is that you never need a type like STret
23:51:01 <edwardk> except when you want to unCPS the whole mess
23:51:03 <Axman6> what;s the Ocaml version of Maybe? (came up in conversation today and i couldn't remember)
23:51:08 <dolio> Right.
23:51:20 <edwardk> some
23:51:34 <dolio> Isn't it option?
23:51:38 <dolio> some is Just?
23:51:43 <rieux_> Axman6: type 'a option = None | Some of 'a
23:51:46 <edwardk> er yeah
23:52:14 <adityam> mgsloan: I am currently doing things like f = either f f which is not too bad
23:52:45 <dolio> I should reconstruct my ST CPR benchmark with continuation passing ST and see if it turns out well...
23:58:55 <edwardk> dolio: well, there is a nice package there all bundled up for you to use with the ST stuff in it ;)
