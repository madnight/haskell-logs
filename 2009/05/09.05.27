00:06:38 <ski> Do push-ups
00:06:40 <ski> Then a sauce
00:06:41 <ski> Evade
00:08:15 <Eridius> @pl \a b -> uncurry f =<< liftM2 (,) a b
00:08:16 <lambdabot> ((uncurry f =<<) .) . liftM2 (,)
00:08:18 <Eridius> heh
00:08:36 <dmwit> Because \a b -> uncurry f =<< liftM2 (,) a b is TOO READABLE
00:09:04 <dmwit> :t \a b -> uncurry f =<< liftM2 (,) a b
00:09:05 <lambdabot> forall a b (m :: * -> *) b1. (Show a, Show b, SimpleReflect.FromExpr (m b1), Monad m) => m a -> m b -> m b1
00:09:11 <dmwit> bah
00:09:12 * Eridius feels like there's some alternative to uncurry f =<< liftM2 (,) a b that doesn't involve wrapping and unwrapping with the tuple, but he's missing it
00:09:14 <dmwit> :t \f a b -> uncurry f =<< liftM2 (,) a b
00:09:15 <lambdabot> forall a b (m :: * -> *) b1. (Monad m) => (a -> b -> m b1) -> m a -> m b -> m b1
00:09:32 <dmwit> uh
00:10:01 <Eridius> and I don't mean join (f <$> a <*> b)
00:10:15 <dmwit> ?pl \ma mb -> ma >>= \a -> mb >>= f a
00:10:15 <lambdabot> (. ((. f) . (>>=))) . (>>=)
00:10:18 <dmwit> yuck
00:10:43 <dmwit> :t liftM2
00:10:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:11:04 <dmwit> :t \f a b -> join (liftM2 f a b)
00:11:04 <ski> @type \f a b -> join (liftM2 f a b)
00:11:06 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
00:11:06 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
00:11:10 <ski> (:
00:11:59 <dmwit> or just do { a <- ma; b <- mb; f a b } -- this is not really so heinous, you know
00:12:00 * Eridius is trying to avoid the join
00:12:05 <ski> maybe it would be nice to call this `extendM2' or something ..
00:12:08 <Eridius> bah!
00:12:34 <dmwit> Eridius: Well, you can't avoid the join, that's for sure.
00:12:41 <dmwit> Why do you want to?
00:12:54 * Eridius doesn't want to type join
00:13:07 <Eridius> I'm perfectly happy if something does the join for me
00:13:07 <dmwit> ...
00:13:18 <Eridius> :P
00:13:19 <dmwit> Seriously?
00:13:29 * Eridius is just being silly, he knows
00:13:32 * dmwit hits Eridius over the head with a Get Things Done stick
00:13:36 <Eridius> ouch
00:13:39 * Eridius isn't trying to get things done
00:13:52 * dmwit then hits dmwit over the head with a Get Things Done stick
00:13:55 <dmwit> yoink!
00:13:58 * Eridius chuckles
00:14:30 <ski> @let mamb `jap` ma = join (mamb `ap` ma)
00:14:32 <lambdabot>  Defined.
00:14:35 <ski> @type \f a b c d -> f `liftM` a `ap` b `ap` c `jap` d
00:14:37 <lambdabot> forall a1 a a11 a2 (m :: * -> *) a12. (Monad m) => (a1 -> a -> a11 -> a2 -> m a12) -> m a1 -> m a -> m a11 -> m a2 -> m a12
00:17:45 <dmwit> :t ap
00:17:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:18:09 <dmwit> :t \f a b -> return f `ap` a `ap` b
00:18:10 <lambdabot> forall a a1 b (m :: * -> *). (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
00:18:18 <dmwit> oh, right
00:18:45 <dmwit> :t \f a b -> return f `ap` a `ap` b >>= id -- ;-)
00:18:46 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
00:19:02 <Yoric[DT]> Hi everyone, I have a question regarding beginners.
00:19:02 <dmwit> Eridius: How do you feel about expanding the definition of join? ;-)
00:19:25 <Yoric[DT]> (that is, I'm currently working on the design of a new language and I'd be interested in a few elements of feedback wrt teaching Haskell)
00:19:26 <cnwdup> @pl (\st -> writeIORef stateRef (toDyn st) *> return True)
00:19:26 <lambdabot> (*> return True) . writeIORef stateRef . toDyn
00:19:33 <dmwit> :t \f a b -> liftM2 f a b >>= id -- ;-)
00:19:34 <lambdabot> forall a1 a2 (m :: * -> *) b. (Monad m) => (a1 -> a2 -> m b) -> m a1 -> m a2 -> m b
00:19:55 <Yoric[DT]> Does the syntax of parametric polymorphism in Haskell appear clear to newbies who have no experience in FP?
00:20:35 <dmwit> Yoric[DT]: It's familiar enough to be confusing. =)  (At least, I found it so at first.  But not for very long, so I wouldn't worry about this as a sticking point too much.)
00:20:56 <Yoric[DT]> :)
00:21:01 <dmwit> It's not such a big step for people from "template <typename T> List<T>" to "List a".
00:21:08 * ski wonders what the syntax of parametric polymorphism is
00:21:26 <opqdonut> ski: i thought he referred to lower-case types being variables etc
00:21:30 <ski> the `forall foo. ..foo..' ?
00:21:36 <dmwit> ski: Presumably, he's talking about type variables and type-constructor application.
00:21:38 <Yoric[DT]> Just the lower-case types being variables.
00:21:40 <Eridius> dmwit: expanding the definition? I'm not sure I understand what you mean
00:21:44 <Yoric[DT]> forall is yet another issue
00:21:45 <Eridius> that said, I need to go to bed anyway
00:21:47 <Eridius> dmwit: thanks for trying
00:21:55 <dmwit> Eridius: "liftM2 f a b >>= id" has the right type.
00:22:03 <Eridius> ah haha
00:22:07 <dmwit> Eridius: But it's just the one-step expansion of "join (liftM2 f a b)". =)
00:22:10 <Eridius> of course liftM2 just uses join internally
00:22:10 <dmwit> ?src join
00:22:11 <lambdabot> join x =  x >>= id
00:22:21 <Eridius> or its equivalent
00:22:23 <dmwit> Eridius: Yes, but that's not relevant to the joke here. =)
00:22:24 <Eridius> in any case, sleep time
00:22:26 <ski> Eridius : as does :  f `liftM` a `jap` b
00:22:39 <Eridius> jap?
00:22:46 <Yoric[DT]> dmwit: thanks for the element of feedback
00:22:48 <ski> <ski> @let mamb `jap` ma = join (mamb `ap` ma)
00:22:54 <Eridius> ah
00:23:24 <ski> (you said you'd be perfectly happy if something did the `join' for you)
00:23:30 <Yoric[DT]> dmwit: in a new language, would you want the new user to always quantify type variables (as in forall / template) or would you have quantification be implicit (as in, well, no forall)
00:23:32 <Eridius> haha
00:23:38 <Eridius> ok, sleeps for real
00:24:29 <nimred> wich cabal-install version would i be able to build with GHC 6.8.3 ?
00:24:34 <RayNbow> g'morning #haskell! :)
00:24:50 <dmwit> Taking away quantification really limits your extensibility.
00:25:14 <dmwit> Haskell has run into this more and more as GHC adds rank-2 types, rank-n types, existential quantification, scoped type variables, ...
00:25:23 <ski> Yoric[DT] : are you talking about the concrete syntax of type variables ? or regarding type variables and parameterized types ?
00:25:40 <Yoric[DT]> dmwit: sure, the question is mostly about having implicit quantification by default.
00:25:54 <Yoric[DT]> ski: I'm talking about concrete syntax. However, I
00:26:12 <Yoric[DT]> ski: I'm talking about concrete syntax. However, I'm not sure exactly where you draw the line between the two possibilities you offer me :)
00:27:02 <cnwdup> I have a program which seg faults. I this my fault or ghc's? (E.g. should I file a bug report?)
00:27:23 <ski> RayNbow : Goede morgen
00:27:57 <ski> Yoric[DT] : the first is the concrete syntax, the second is the concept
00:28:08 <Yoric[DT]> ski: I'm talking concrete syntax.
00:29:03 <Yoric[DT]> (although implicit quantification is borderline between both)
00:29:23 <dmwit> cnwdup: The most common cause is rebuilding a library, but not the things using that library.
00:29:25 <ski> (.. anyway, how to handle quantification is ortogonal to having type variables (and probably parameterized types))
00:30:14 <cnwdup> dmwit, ah. Okay. Then I guess it's my fault.
00:30:21 <ski> (i wouldn't say implicit quantification is borderline .. implicit quantification still turns up (or rather, doesn't turn up) in the AST)
00:31:01 <RayNbow> ski: god morgon! (had to look this up :p)
00:31:15 * ski smiles
00:31:29 <nimred> any idea ?
00:31:55 <RayNbow> nimred: the latest cabal-install on hackage doesn't build?
00:32:32 <nimred> RayNbow no it doesn't because of 'ld: cannot find -lgmp'
00:32:56 <ski> Yoric[DT] : for concrete syntax of type variables, e.g. the ML's start type variables with an "'", and Mercury starts with upper case letter (or `_', iirc)
00:33:11 <ski> (s/ML's/MLs/)
00:33:27 <Yoric[DT]> Ok, I wasn't aware of the Mercury convention.
00:33:36 <Yoric[DT]> s/convention/concrete syntax/
00:34:34 <ski> (this is borrowed from using upper case (or `_') to start ordinary variables in both Mercury and Edinburgh syntax of Prolog)
00:35:00 <RayNbow> nimred: do you have libgmp on your system?
00:35:02 <Yoric[DT]> My first impression is that _a is not quite nice, though.
00:35:11 <Yoric[DT]> I prefer 'a .
00:35:30 <nimred> RayNbow :
00:35:32 <nimred> [~/tmp/APPLICATIONS/xmonad/cabal-install-0.6.0]->> pkg_info | grep gmp                                                                                            09:31
00:35:35 <nimred> gmp-4.2.4nb1        Library for arbitrary precision arithmetic
00:38:36 <dmwit> nimred: Is it in your LD_LIBRARY_PATH?
00:39:24 <RayNbow> dmwit, http://jan.varwig.org/archive/getting-cabal-to-run-on-mac-os-x-leopard <-- someone in the comments is getting the same link error
00:39:27 <RayNbow> erm
00:39:33 <RayNbow> * nimred
00:42:35 <cnwdup> When dynamically loading a plugin whats the cause of "unknown symbol `base_GHCziBase_id_closure'" being reported?
00:44:20 <nimred> dmwit :
00:44:21 <nimred> [~/tmp/APPLICATIONS/xmonad/cabal-install-0.6.2]->> echo $LD_LIBRARY_PATH                                                                                          09:41
00:44:24 <nimred> /usr/X11R7/lib:/usr/local/lib:/usr/pkg/lib
00:44:50 <nimred> and :
00:44:52 <nimred> [~/tmp/APPLICATIONS/xmonad/cabal-install-0.6.2]->> ls /usr/pkg/lib/libgmp                                                                                         09:42
00:44:56 <nimred> files:
00:44:58 <nimred> libgmp.a   libgmp.la*   libgmp.so@   libgmp.so.3@   libgmp.so.3.4.4*   libgmpxx.a   libgmpxx.la*   libgmpxx.so@   libgmpxx.so.4@   libgmpxx.so.4.0.4*
00:45:03 <nimred> shouldn't it work ?
00:50:26 <dmwit> nimred: It does seem like it should.
00:51:03 <nimred> dmwit a moment, i paste you error output on a pastbin web site
00:51:37 <dmwit> Aw, man.  This is why you don't code late at night.
00:51:47 <dmwit> I just rm *.hs instead of *.hi... =/
00:52:35 <raimo_> dmwit: that's why you use vcs
00:53:11 <RayNbow> or try recovering it using some undelete tool
00:53:55 <Gracenotes> dmwit: reverse engineer the object code!
00:54:45 <nimred> dmwit --> http://pastebin.ca/1435979
00:57:17 <dmwit> raimo_: Yes indeedy.
00:57:37 <dmwit> But man is it weird to go "ghc --make Main" and have it barf. =P
00:58:32 <dmwit> nimred: Can you find a way to verify that ld can see lgmp in some other way?
00:58:41 <dmwit> (And try to narrow down what the problem could be?)
01:21:00 <povman> Whoa! Linker weirdness!
01:25:15 <Alpounet> hi
01:25:46 <Alpounet> has anyone encountered such an error : "internal error: task 0x968f678: main thread 1 has been GC'd" when launching a program ?
01:25:48 <povman> I have made a cabal library which links to SDL which defines main(). I make another package which uses that library but has its own haskell main. For some reason when my program builds it uses the SDL main!!!!!
01:27:22 <xenoblitz> http://www.wisdomandwonder.com/link/3022/why-church-chose-lambda
01:29:22 <povman> I never considered that there might be a meaning behind lambda, but reading that means I never have to.
01:29:59 <cnwdup> I am trying to dynamically load plugins. Now and then I get it working but after make clean && make I get errors I don't know where they are originating from. I guess something is wrong during linking, but I do not know what is. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2508#a2510 Help would be appreciated.
01:30:47 <cnwdup> Maybe I have to specify a certain directory in the call of load_?
01:33:38 <quicksilver> cnwdup: pong
01:34:30 <bnijk_> povman: what are you doing in haskell/sdl?
01:34:36 <cnwdup> quicksilver, hehe. Thanks to Lemmih I was able to solve my problem now. But I cannot get loading of plugins to work. If you could take a look at the link I posted above that'd be great.
01:35:07 <quicksilver> cnwdup: the .o file and the .hi file are normally supposed to be in the same dir
01:35:16 <quicksilver> looks like something is running in the wrong directory to me
01:35:57 <cnwdup> quicksilver, I am running ./bot pluginA from ./. Is this wrong?
01:35:57 <quicksilver> don't understand how/why though.
01:36:03 <quicksilver> seems sensible to me.
01:36:12 <quicksilver> looks like a HiNT problem (was it hint you were using?)
01:36:14 <mgee> hi, please look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2511#a2511
01:36:23 <mgee> I get this warning: Warning: Defaulting the following constraint(s) to type `Integer' `Integral t' arising from a use of `^'
01:36:29 <cnwdup> quicksilver, I do not know what HiNT is. (:
01:36:39 <quicksilver> cnwdup: OK. What are you using to load the plugins then?
01:36:40 <mgee> But I don't know how to fix it...
01:36:59 <cnwdup> quicksilver, I use make and load_ form hs-plugins.
01:37:03 <Gracenotes> hm. I'm thinking I should make a special MVar wrapper for my special monad. It's a MonadIO, so there is a lot of repetitive lifting dealing with MVars... o.o
01:37:09 <mebbel> (2^p :: Int)
01:37:21 <cnwdup> quicksilver, oh, sorry. The name is just plugins. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
01:37:27 <Gracenotes> on the other hand it's not very flexible dealing with other code that uses mvars
01:37:30 <Gracenotes> nvm then
01:38:05 <mgee> mebbel: thanks, that worked!
01:38:07 <quicksilver> cnwdup: it's some detail about the way plugins invokes ghc and where files go. I'm afraid I've never used it. You could try to ping dons
01:38:25 <cnwdup> quicksilver, okay. Thank you.
01:38:35 <cnwdup> dons, ping
01:38:53 <cnwdup> The weird thing is I now and then get it to work. But after re-compiling some modules its not working anymore.
01:39:03 <cnwdup> Unfortunately I cannot reproduce it.
01:40:03 <LeCamarade> ?tick ^GOOG
01:40:03 <lambdabot> ^GOOG: 0.00 @ N/A N/A
01:40:12 <LeCamarade> ?tick ^goog
01:40:12 <lambdabot> ^GOOG: 0.00 @ N/A N/A
01:40:13 <quicksilver> cnwdup: probably if you compile all the .hs files by hand with ghc
01:40:22 <LeCamarade> Who sinned?
01:40:25 <quicksilver> cnwdup: then the files wil go in the right place and it will work
01:40:27 <quicksilver> (i would guess)
01:40:30 <LeCamarade> Who put stock quotes into lambdabot?
01:40:36 <LeCamarade> ?tick ^msft
01:40:36 <lambdabot> ^MSFT: 0.00 @ N/A N/A
01:40:43 <LeCamarade> ?tick ^dji
01:40:43 <lambdabot> ^DJI: 8473.49 +196.17 (+2.37%) @ 5/26/2009 4:01pm
01:40:47 <quicksilver> whereas if you let plugins compile them it's doing something wrong
01:41:39 <cnwdup> quicksilver, how should I compile them? All .hi and .o files should go in the same directory their .hs files are in?
01:42:28 <nimred> dmwit : i just add to export good LIBRARY_PATH to get it working :) sorry for noising :/
01:43:19 <quicksilver> cnwdup: that's what ghc normally does, yes.
01:43:30 <quicksilver> so PluginA.{hs,o,hi} would all be in Plugin/
01:43:45 <cnwdup> quicksilver, ok. I'll try that.
01:44:12 <Gracenotes> @botsnack
01:44:12 <lunabot>  :)
01:44:12 <lambdabot> :)
01:53:17 <Alpounet> (&&&) is defined in Control.Arrow right ?
01:53:30 <opqdonut> yeh
01:53:41 <Alpounet> hmm
01:54:04 <Alpounet> I import Control.Arrow, use &&& but I get "Not in scope: `&&&'"
01:54:31 <Alpounet> weird, huh ?
01:54:34 <cnwdup> Are you importing it qualified?
01:54:39 <WorkyBob> Alpounet: show us the import line
01:55:10 <Alpounet> import Control.Arrow
01:55:17 <Alpounet> rather simple :-p
01:55:20 <WorkyBob> pastebin the file
01:55:22 <Alpounet> yep
01:58:52 <Alpounet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5310#a5310
02:06:29 <WorkyBob> worksforme
02:06:48 <WorkyBob> a few not in scopes because of not having some of your libraries - but notably, not &&&
02:07:28 <Cale> I'm installing the libraries just to be sure
02:07:54 <Cale> I get:
02:08:00 <Cale> atom.hs:10:65:
02:08:00 <Cale>     Couldn't match expected type `([Char], [Char])'
02:08:00 <Cale>            against inferred type `Attr -> String'
02:08:41 <Peaker> mmorrow: I was asleep, seems awesome, will check out in more detail in a bit :)
02:08:44 <WorkyBob> Alpounet: what version of ghc?
02:09:09 <Alpounet> 6.8.2
02:09:20 <Alpounet> Control.Arrow isn't compatible ?
02:09:25 <Alpounet> it would explain the problem, rather fully.
02:09:28 <WorkyBob> it should be, but bump up all the same
02:09:55 <doserj> Control.Arrow.&&& works fine in ghc-6.8.2
02:10:11 <doserj> Alpounet: can you do ghci -v <File.hs>?
02:10:45 <Peaker> mmorrow: why do you need the explicit k arg in testGen? Why not have Coro also be in a reader monad and have yield/done ask for k?
02:11:09 <Alpounet> doserj, of course.
02:18:37 <doserj> Alpounet: well, what does it say?
02:19:32 <Alpounet> doserj, it looks like arrows isn't installed here, because of compatibility issues w.r.t base
02:20:37 <doserj> Alpounet: Control.Arrow is in base
02:20:48 <hatds> > [10..1]
02:20:50 <lambdabot>   []
02:21:09 <opqdonut> > [10,9..1]
02:21:10 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
02:21:34 <hatds> makes sense, but I find it a bit disconcerting when using literals :)
02:22:58 <RayNbow> > let desc from to = enumFromThenTo from (pred from) to  in   desc 10 1
02:22:59 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
02:23:04 <nimred> any idea when running 'cabal install xmonad' --> http://pastebin.ca/1436005 ?
02:24:52 <doserj> nimred: error: gmp.h: No such file or directory --> did you install the libgmp dev package?
02:25:33 <nimred> doserj yes i did and gmp.h is in /usr/pkg/include/
02:26:20 <doserj> well, apparently ghc doesn't find it
02:26:30 <nimred> wich can i make compiler find it ? is there any environment variable i have tot set to >
02:26:46 <nimred> wich way can i make compiler find it ? is there any environment variable i have tot set to ?
02:27:08 <RayNbow> http://www.network-theory.co.uk/docs/gccintro/gccintro_23.html
02:27:24 <sjanssen> nimred: how did you install GHC?
02:27:49 <nimred> sjanssen from my package system = pkgsrc
02:27:53 <nimred> on NetBSD
02:28:21 <sjanssen> nimred: I would guess from this situation that NetBSD's GHC package is broken in some subtle way
02:28:39 <nimred> http://pkgsrc.se/lang/ghc
02:28:56 <nimred> sjanssen Sure ?
02:29:37 <sjanssen> nimred: you could try adding /usr/pkg/include/ to CPPFLAGS
02:30:38 <mgee> sjanssen: perhabs: CPPFLAGS="-I /usr/pkg/include/ $CPPFLAGS" cabal install xmonad
02:30:56 <mgee> as single command in your bash
02:31:33 <nimred> mgee didn't find neither
02:32:18 <mgee> :-/
02:38:36 <nimred> ok 'export C_INCLUDE_PATH=/usr/pkg/include' worked
02:38:46 <nimred> RayNbow thx
02:39:38 <mmorrow> Peaker: i was thinking about a Reader monad, but what made me decide against it was that you might want multiple generators, and a Reader would force you into just one
02:39:55 <mmorrow> Peaker: (and also, you can have generators of generators, etc)
02:39:57 <nimred> RayNbow wich way can i tell C_INCLUDE_PATH to be more than one path ?
02:42:46 <RayNbow> nimred: I'm not sure, but probably separating them with :
02:42:47 <mmorrow> Peaker: (but if there's only one generator of interest (at any one time) for a particular app, then you could always throw a Reader around it)
02:42:54 <RayNbow> so for example...
02:43:01 * sohum stabs type errors
02:43:04 <nimred> RayNbow the same as for $PATH ?
02:43:10 * RayNbow nodes
02:43:11 <RayNbow> *nods
02:44:53 <sohum> what should the type of this be? prop_ndivk n k = (n/k) == n `shiftR` (truncate (logBase 2 k))
02:45:09 <mebbel> none
02:45:18 <mebbel> that doesn't look valid to me
02:45:22 <mmorrow> Peaker: i like how that turned out, i'm definitely going to see if i can't find some real use for this stuff
02:45:52 <sohum> hmm, possibly it's not. the compiler infers a type dandily
02:46:11 <nimred> RayNbow can you give me an example ?
02:46:26 <sohum> > let prop_ndivk n k = (n/k) == n `shiftR` (truncate (logBase 2 k))
02:46:28 <lambdabot>   not an expression: `let prop_ndivk n k = (n/k) == n `shiftR` (truncate (log...
02:46:36 <sohum> > import Data.Bits
02:46:37 <lambdabot>   <no location info>: parse error on input `import'
02:46:59 <mebbel> :t let prop_ndivk n k = (n/k) == n `shiftR` (truncate (logBase 2 k)) in prop_ndivk
02:47:01 <lambdabot> forall a. (Floating a, Bits a, RealFrac a) => a -> a -> Bool
02:47:16 <mebbel> yeah, you'd have to find a type that's both RealFrac and Bits
02:47:22 <mebbel> kind of unlikely
02:47:49 <sohum> ok, so what's my problem here?
02:47:59 <sohum> what'm I doing wrong?
02:48:14 <te> Hmmm I need some help
02:48:22 <te> this particular thing im trying to run relies on hsc3 and hosc
02:48:29 <te> http://doc.gold.ac.uk/~ma503am/software/vocable/
02:48:37 <nimred> RayNbow ok found it http://www.network-theory.co.uk/docs/gccintro/gccintro_24.html
02:48:44 <te> in Util.lhs it says "import Safe", but Safe is not ofund
02:48:46 <te> found
02:48:48 <te> any ideas?
02:48:54 <dmwit> ?remember jessenoller [On Python:] The closest we get to "type safety" is function annotations, which make me feel funny in sensitive places.
02:48:54 <lambdabot> Good to know.
02:48:56 <mebbel> sohum: n/k means n and k can't be integers
02:49:27 <sohum> mebbel: it does?
02:49:32 <sohum> :t (/)
02:49:34 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:49:42 <sohum> aren't Ints Fractional?
02:49:45 <dmwit> sohum: You bet it does.
02:49:45 <dmwit> no
02:49:59 <mebbel> Ints are Integral, not Fractional
02:49:59 <EvilTerran> sohum, Ints are Integral
02:50:10 <sohum> so what magic's ghci doing when I type 8/4 in it?
02:50:12 <mmorrow> > 2 % 3
02:50:13 <mebbel> (that's latin for "whole" and "broken")
02:50:13 <lambdabot>   2 % 3
02:50:21 <EvilTerran> ?type 8/4
02:50:22 <te> oops needed the Safe library
02:50:22 <lambdabot> forall t. (Fractional t) => t
02:50:23 <doserj> > let prop_ndivk n k = (n `div` k) == n `shiftR` (truncate (logBase 2 (fromIntegral k))) in prop_ndivk 10 3
02:50:23 <EvilTerran> ?type 8
02:50:24 <opqdonut> sohum: interpreting them as floats
02:50:25 <lambdabot>   False
02:50:25 <lambdabot> forall t. (Num t) => t
02:50:27 <te> here's the error i get now:     Couldn't match expected type `UGen' against inferred type `[a]'
02:50:31 <opqdonut> gah, or rather Fractionals
02:50:34 <opqdonut> :t 4
02:50:35 <lambdabot> forall t. (Num t) => t
02:50:40 <opqdonut> see, number literals are overloaded
02:50:41 <mmorrow> @type 5 / 8 :: Double
02:50:42 <lambdabot> Double
02:50:46 <mmorrow> @type 5 / 8 :: Float
02:50:47 <lambdabot> Float
02:50:49 <sohum> hmmmm.
02:50:49 <dmwit> :t fromInteger
02:50:51 <lambdabot> forall a. (Num a) => Integer -> a
02:50:51 <EvilTerran> sohum, 8, 4 :: Num t => t
02:51:01 <mmorrow> @type 5 / 8 :: Rational
02:51:02 <lambdabot> Rational
02:51:07 <mmorrow> > 5 / 8 :: Rational
02:51:09 <lambdabot>   5 % 8
02:51:11 <EvilTerran> sohum, so 8 and 4 can be Int, or Float, or any of a variety of other things
02:51:14 <dmwit> sohum: Any number literal without a . or an e in it actually stands for an application of fromInteger.
02:51:24 <sohum>  Isee
02:51:38 <mmorrow> > toRational pi
02:51:39 <lambdabot>   884279719003555 % 281474976710656
02:51:44 <dmwit> And even some literals that do have an e in them. =)
02:51:44 <mmorrow> i knew it!
02:51:50 <dmwit> > 0x3e / 0x4e
02:51:51 <lambdabot>   0.7948717948717948
02:51:52 <Baughn> @tell conal One gotcha is that isHNF registers fully-evaluated Integers as Thunks. I'm looking into it, but it's safe as such and every other type I've tried works fine - in particular, all the ones reactive uses.
02:51:52 <lambdabot> Consider it noted.
02:52:03 <EvilTerran> > (8 :: Int, 8 :: Float, 8 :: Complex Int, 8 :: Rational)
02:52:04 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
02:52:04 <lambdabot>    arising from the lit...
02:52:10 <EvilTerran> > (8 :: Int, 8 :: Float, 8 :: Complex Float, 8 :: Rational) -- bah
02:52:11 <lambdabot>   (8,8.0,8.0 :+ 0.0,8 % 1)
02:52:31 <ivanm> heh
02:53:13 <dmwit> sohum: Similarly, all number literals that have a . or an exponent part stand for applications of fromRational.
02:53:16 <dmwit> :t fromRational
02:53:17 <lambdabot> forall a. (Fractional a) => Rational -> a
02:53:28 <mmorrow> Baughn: i just saw a paste by Cale using Strategies with closure stuff, and realized that if vacuumLazy can work at all, it'll be by using varies Strategies combinators (if this doesn't work, then i think we're screwed)
02:53:36 <mmorrow> *various
02:53:59 <dmwit> > (0.123456789123456789123456789123456789 :: Float {- this one truncates -}, 0.123456789123456789123456789123456789123456789 :: Rational {- this one doesn't -})
02:54:00 <lambdabot>   (0.12345679,123456789123456789123456789123456789123456789 % 100000000000000...
02:54:19 <sohum> hmmmm.
02:54:30 <sohum> so what's the difference between Int and Integer?
02:54:36 <dmwit> > maxBound :: Int
02:54:37 <lambdabot>   9223372036854775807
02:54:38 <EvilTerran> > let x :: Fractional a => a; x = 2/3 in (x :: Float, x :: Double, x :: Rational, x :: Complex Float, x :: CReal)
02:54:39 <lambdabot>   (0.6666667,0.6666666666666666,2 % 3,0.6666667 :+ 0.0,0.66666666666666666666...
02:54:40 <dmwit> > maxBound :: Integer
02:54:41 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
02:54:41 <lambdabot>    arising...
02:54:43 <mebbel> Int is bounded
02:54:49 <sohum> right
02:54:53 <dmwit> > 9223372036854775807 + 1 :: Integer
02:54:54 <lambdabot>   9223372036854775808
02:54:56 <dmwit> > 9223372036854775807 + 1 :: Int
02:54:58 <lambdabot>   -9223372036854775808
02:55:14 <dmwit> That reminds me.
02:55:16 <EvilTerran> > 10^100 :: Integer
02:55:17 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
02:55:21 <sohum> hahahaha
02:55:24 <mmorrow> > let x = 0.123456789123456789123456789123456789 :: Double in (0.123456789123456789123456789123456789 :: Rational) == toRational x
02:55:25 <sohum> that's pretty awesome
02:55:26 <lambdabot>   False
02:55:35 <mmorrow> > let x = 0.123456789123456789123456789123456789 :: Double in (0.123456789123456789123456789123456789 :: Rational) - toRational x
02:55:37 <lambdabot>   2792815433231892750881857 % 524288000000000000000000000000000000000000
02:55:39 <dmwit> > let x = -9223372036854775808 in negate x == x
02:55:40 <lambdabot>   False
02:55:43 <mebbel> > abs minBound
02:55:45 <lambdabot>   Add a type signature
02:55:49 <mebbel> > abs minBound :: Int
02:55:49 <mmorrow> > let x = 0.123456789123456789123456789123456789 :: Double in fromRational ((0.123456789123456789123456789123456789 :: Rational) - toRational x) :: Double
02:55:51 <lambdabot>   -9223372036854775808
02:55:51 <lambdabot>   5.3268726982725e-18
02:56:01 <EvilTerran> mebbel, uh-oh <.< >.>
02:56:21 <dmwit> > let x = -9223372036854775808 in negate x == (x :: Int)
02:56:22 <lambdabot>   True
02:56:28 <dmwit> There we go. =P
02:56:28 <Baughn> mmorrow: ..GHC is getting too smart with its strictness analyzer
02:56:31 <mmorrow> > let x = 0.1234567891234567891234567891234598798476875987987498787985709884309834565435436789 :: Double in fromRational ((0.1234567891234567891234567891234598798476875987987498787985709884309834565435436789 :: Rational) - toRational x) :: Double
02:56:32 <lambdabot>   5.326872698272503e-18
02:56:45 <EvilTerran> > let x = -9223372036854775808 in abs x == (x :: Int) -- dmwit, this is even more jarring, imo
02:56:46 <lambdabot>   True
02:57:14 <mmorrow> no way! i never knew that it'll read floating-formatted nums as rationals
02:57:17 <EvilTerran> well, "abs x < 0" is the bit that throws me
02:57:27 <Gracenotes> EvilTerran: most signed int implementations have abs like that
02:57:30 <mmorrow> Baughn: heh
02:57:32 <Gracenotes> in all the languages I know of
02:57:42 <dmwit> Gracenotes: Oh, yeah, no argument there.
02:57:45 <EvilTerran> Gracenotes, it's still semantically dubious
02:58:06 <sohum> :t let f x y = (fromInteger x)/(fromInteger y) in f
02:58:08 <lambdabot> forall a. (Fractional a) => Integer -> Integer -> a
02:58:12 <te> Could someone please take a look at http://pastie.org/491153 and tell me how to fix the debug message i included in there?
02:58:12 <dmwit> Anyway, if we're going to complain about numbers, we really ought to complain about Float and Double.
02:58:24 <dmwit> I mean, addition isn't even associative!
02:58:33 <quicksilver> mmorrow: there is nothing "floating formatted" about "1.23456"
02:58:38 <Axman6> sohum: fromIntegral would be a bit more polymorphic
02:58:44 <quicksilver> mmorrow: "1.23456" is decimal notation for a rational number :)
02:58:47 <Gracenotes> dmwit: is it commutative for Floats and Doubles?
02:58:52 <quicksilver> mmorrow: it would be surprising if that didn't work for Rational.
02:58:59 <Gracenotes> I've heard corner cases exist
02:58:59 <dmwit> Gracenotes: No, that's my point.
02:59:02 <opqdonut> dmwit: well, the faults of Floats and Doubles aren't the language designer's fault
02:59:03 <Gracenotes> I'm not sure how sharp they are though
02:59:08 <dmwit> Gracenotes: Oh, commutative.
02:59:08 <mmorrow> > let x = 0.123456789123456789123456789123459879847687598798749878798570988430983456543543678988888888888888833333333333333333333333333333333333339999999999999999999999999222222222222222222222222222 :: Rational; y = numerator x; z = denominator x in (length (show y), length (show z))
02:59:10 <lambdabot>   (185,186)
02:59:12 <mmorrow> heh
02:59:15 <te> Anyone?
02:59:16 <opqdonut> they're best viewed as a numerics "library"
02:59:22 <mmorrow> quicksilver: i mean "with a decimal pt"
02:59:27 <dmwit> I don't know.  I thought they were, but I would be totally unsurprised to find out they weren't.
02:59:31 <mmorrow> (however you say that :)
02:59:42 <mmorrow> ah, yeah decimal
02:59:58 <mmorrow> quicksilver: i'm pleasantly surprised
02:59:59 <dmwit> te: Give us a chance, it's a long paste.
03:00:34 <opqdonut> te: where's MRG defined?
03:00:46 <te> is it not in that file?
03:01:03 <quicksilver> mmorrow: well, yes, I know what you meant. I was just challenging your choice of words :)
03:01:19 <opqdonut> te: it's in Sound.SC3 it seems
03:01:25 <opqdonut> te: you probably meant a lowercase mrg
03:01:29 <opqdonut> Sound.SC3.UGen.UGen.   mrg  :: [ UGen ] -> UGen
03:01:32 <opqdonut> that takes a list
03:01:33 <mmorrow> i hesitated to use "decimal" since it seems like that's used to mean either "3847563" (base 10) or "123432.432123" (with a pt) in different places and i don't know what it even means anymore
03:01:38 <Gracenotes> dmwit: apparently it is commutative, at least according to some website.
03:01:41 <te> opqdonut: let me try that, one second
03:01:46 <quicksilver> mmorrow: and try ing to point a finger at the fact that there's nothing very floating about "1.23"
03:01:46 <mmorrow> quicksilver: keeping me on my toes
03:02:15 <Axman6> > 355 / 112
03:02:16 <Gracenotes> but of course not associative due to precision
03:02:16 <lambdabot>   3.169642857142857
03:02:19 <Axman6> > 355 / 113
03:02:21 <lambdabot>   3.1415929203539825
03:02:32 <Gracenotes> hrm
03:02:33 <mmorrow> what does "floating pt" even refer to (very in particular) anyways?
03:02:57 <Gracenotes> I guess IEEE
03:03:08 <quicksilver> mmorrow: it's a representation with separate mantissa and exponent
03:03:11 <opqdonut> yeah
03:03:12 <mmorrow> but i mean, how is the "pt" "floating"
03:03:24 <quicksilver> mmorrow: storing the exponent separately means that the point is not always in the same place in the mantissa
03:03:28 <opqdonut> the point floats as in the precision isn't fixed
03:03:31 <mmorrow> hmm
03:03:33 <quicksilver> but it 'floats' around as dictated by the exponent.
03:03:40 <opqdonut> or what quicksilver said
03:03:47 <Axman6> :t approxRational
03:03:49 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
03:03:52 <dmwit> opqdonut: No, it's okay for precision to be fixed.
03:03:57 <mmorrow> but what confuses me is that the mantissa and the exponent are of fixed sizes
03:04:00 <Gracenotes> http://portal.acm.org/citation.cfm?id=156301.156303 .. damn you, ACM!
03:04:03 <Axman6> > approxRational pi 0.00000001
03:04:04 <lambdabot>   100798 % 32085
03:04:04 <mebbel> mmorrow: 1.234 = 0.1234 * 10^1;  12.34 = 0.1234 * 10^2
03:04:07 <Axman6> > approxRational pi 0.00000000001
03:04:08 <lambdabot>   833719 % 265381
03:04:12 <Axman6> > approxRational pi 0.0000000000000001
03:04:13 <lambdabot>   884279719003555 % 281474976710656
03:04:17 <mebbel> mebbel: by incrementing or decrementing the exponent you can move the point around
03:04:18 <Axman6> > approxRational pi 0.00000000000000000000001
03:04:19 <lambdabot>   884279719003555 % 281474976710656
03:04:20 <mebbel> er
03:04:26 <Axman6> :(
03:04:37 <mmorrow> mebbel: that's a good way to say it
03:04:47 <Axman6> > 355/113 - pi
03:04:48 <lambdabot>   2.667641894049666e-7
03:04:51 <mmorrow> put that way it seems very logical
03:05:21 <Gracenotes> and yielding the property that precision seems greater at lower values
03:06:14 <Gracenotes> ... seemingly ...
03:06:51 <opqdonut> or rather, relative precision staying constant
03:07:03 <opqdonut> or almost constant
03:09:58 <mxc> is there any advantage to using the functiosn in GHC.Conc over Control.Concurrent?
03:10:27 <ivanm> less portability?
03:10:35 <mebbel> no, Control.Concurrent is the standard interface
03:10:36 <Baughn> It'll ensure your program only works with GHC
03:10:44 <quicksilver> yes. the "advantage" that you are using internal APIs which can change without warning, aren't documented, could break at any moment, and aren't portable :)
03:11:13 <sohum> is there an equivalent to the unsigned int?
03:11:28 <Baughn> sohum: Data.Word
03:11:38 <wjt> There's no unsigned Integer :(
03:11:53 <Baughn> (Unless you make one)
03:12:01 <wjt> insert the word "standard"
03:12:05 <sohum> cools, thankee
03:12:12 <PeakerWork> mmorrow: hey, you there?
03:12:20 <mmorrow> PeakerWork: yes
03:12:50 * Baughn blesses whoever wrote the GHC Commentary
03:12:55 <quicksilver> wjt: I'm not sure "standard" is very interesting. There's no "standard" XML library and no "standard" parser.
03:12:56 <Baughn> ghc++
03:12:59 <PeakerWork> mmorrow: well, I would like to try to see that Haskell can emulate almost 1-for-1 the Python generators
03:13:16 <PeakerWork> mmorrow: Even giving up a bit of power to do so
03:13:18 <Baughn> quicksilver: The one in the Haskell Platform doesn't count?
03:13:19 <mmorrow> PeakerWork: i've never used python..
03:13:21 <quicksilver> wjt: Data.Word is a portable and widely distributed lib - isn't that the important thing?
03:13:36 <PeakerWork> mmorrow: its a demonstration of power, like augustss implementation of C/BASIC :)
03:13:40 <mmorrow> Peaker: (would throwing that in a Reader monad be emulating enough?)
03:13:40 <wjt> quicksilver: data.word ships with ghc (doesn't it), so is standard in my eyes :)
03:13:58 <quicksilver> wjt: so why did you say there is no standard unsigned integer then?
03:13:59 <Baughn> wjt: I believe he was referring to the lack of Natural
03:14:03 <wjt> quicksilver: capital I
03:14:04 <Baughn> s/wjt/quicksilver/
03:14:09 <sohum> huh, I have to write my own Arbitrary Word instance
03:14:24 <quicksilver> oh, I see.
03:14:26 <quicksilver> *nod*
03:14:58 <PeakerWork> mmorrow: its an assymetrical relationship in Python, between a generator and its caller -- the caller creates the generator like you do, but then he uses "next" on it, and the generator uses "yield" to send a value out and get back in
03:15:02 <Baughn> wjt: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat <-- See this
03:15:17 <wjt> Baughn: yeah, i know there are libraries doing it
03:16:01 <mmorrow> PeakerWork: (i initially started out trying to emulate next/yield like you had it, but then i started to see that each side might as well be the same..)
03:16:19 <mmorrow> PeakerWork: but if you wanted to simulate next/yield, you could just do:
03:16:24 <mmorrow> next = yield
03:16:25 <mmorrow> ;)
03:16:26 <opqdonut> yeah, coprocesses rather than generators
03:16:44 <mmorrow> each side is a generator for the other
03:16:54 <PeakerWork> mmorrow: well, in Python, the caller may have multiple generators, but the generator only yields to one place -- so what you call yield is Python's next (taking both a coroutine and a value), and a reader+yield (that is hard-coded for the received coroutine) is Python's yield
03:16:55 <mmorrow> entangled particles!
03:17:03 <mmorrow> (electrons?)
03:18:06 <PeakerWork> mmorrow: so if you rename "yield" to "next" or "feed", and then make a version of Coro that is already tangled with a ReaderT and have   yield = feed . ask   or so
03:18:56 <mmorrow> PeakerWork: totally. i think it'll be pretty easy to dress that up to emulate python (from my limited understanding of what we're trying to emulate)
03:20:47 <mmorrow> interesting, this looks like it'll give a good view of exactly what python generators are and aren't http://www.python.org/dev/peps/pep-0342/
03:26:19 <PeakerWork> mmorrow: throwing exceptions into generators is probably possible if you have a Coro that's in EitherT and a throwTo that's like feed but feeds a Left value
03:26:51 <mmorrow> PeakerWork: you can just implem exceptions with callCC
03:27:44 <sohum> > logBase 2 18446744073709551614
03:27:45 <lambdabot>   64.0
03:27:48 <sohum> > logBase 2 18446744073709551615
03:27:49 <lambdabot>   64.0
03:27:53 <sohum> fun!
03:27:57 <xci> lol
03:28:10 <mmorrow> (you can even choose whether or not to keep the changes to the state (`s') or rollback to the last checkpoint
03:28:12 <mmorrow> )
03:28:17 <sohum> any way to get a more accurate response there?
03:28:18 <Baughn> sohum: Well, what did you expect?
03:28:28 <Baughn> sohum: ..repeated `div` 2s
03:28:40 <sohum> heh. heh. wait, you're not kidding?
03:28:46 <Baughn> Mm
03:28:49 <Gracenotes> sohum: of course. they're exactly equal :)
03:28:51 <Baughn> Actually, that's /less/ accurate
03:29:03 <Gracenotes> > 18446744073709551614 == (18446744073709551615 :: Double)
03:29:04 <lambdabot>   True
03:29:05 <mmorrow> (and choose that at the time you actually throw the exception)
03:29:07 <Baughn> sohum: Using `div` 2 would give you 65 when the logarithm is actually just barely above 64
03:29:09 <Gracenotes> at least in Double precision
03:29:15 <Baughn> sohum: ..but it sounds like you don't actually want the logarithm
03:29:30 <sohum> I want to check if it's an exact log
03:29:43 <Baughn> There is no such thing as an exact log
03:30:01 <sohum> that is, if there exists an integer x such that 2^x = y
03:30:13 <Gracenotes> oh, and exact log of 2
03:30:16 <Gracenotes> *an
03:30:17 <Baughn> ..well, okay, but that almost never happens
03:30:23 <sohum> I know
03:30:47 <sohum> > 18446744073709551614 == (18446744073709551615 :: Data.Word)
03:30:47 <mmorrow> PeakerWork: (and also, if you're only dealing with a single Gen at once, then the Ref isn't even needed, since you could just use the `s' for current-cont)
03:30:48 <lambdabot>   Not in scope: type constructor or class `Data.Word'
03:30:51 <Gracenotes> sohum: well, there are only a few of them. Maybe have tables?
03:31:35 <mmorrow> PeakerWork: (but if you had, say 100 Gens, some of which are forked copies of others at some point in the past, using the state to hold that would be less than ideal)
03:31:38 <Gracenotes> and for higher values, just keep on dividing by two while even until you reach something in the table (or miss it)
03:32:01 <mmorrow> (and if you're passing Gens to Gens, etc that might get ugly)
03:32:08 <mebbel> > (\n -> '1' `notElem` tail (showIntAtBase 2 intToDigit n "")) 18446744073709551614
03:32:10 <lambdabot>   False
03:32:23 <sohum> > let power2s = 2 : [2*x | x <- power2s]
03:32:25 <lambdabot>   not an expression: `let power2s = 2 : [2*x | x <- power2s]'
03:32:26 <mebbel> > (\n -> '1' `notElem` tail (showIntAtBase 2 intToDigit n "")) 2
03:32:28 <lambdabot>   True
03:32:29 <sohum> ah well
03:32:33 <sohum> it'll work
03:32:50 * sohum [0,3) infinite lists
03:33:10 <Gracenotes> mebbel: cute :)
03:37:15 <mmorrow> @unpl ReaderT r (StateT s (Cont o)) a
03:37:16 <lambdabot> ReaderT r (StateT s (Cont o)) a
03:37:19 <mmorrow> @unmtl ReaderT r (StateT s (Cont o)) a
03:37:20 <lambdabot> r -> s -> (a -> s -> o) -> o
03:38:02 <mmorrow> @unmtl ReaderT r (StateT s (WriterT w (Cont o))) a
03:38:03 <lambdabot> r -> s -> (a -> s -> w -> o) -> o
03:38:20 <mmorrow> @unmtl ReaderT r (WriterT w (StateT s (Cont o))) a
03:38:20 <lambdabot> r -> s -> (a -> w -> s -> o) -> o
03:39:10 <thoughtpolice> mmorrow: what does vacuum 0.0.94 add? (hopefully the ability to easily render graphs to a .svg file or something... :))
03:41:30 <sohum> you know one thing I'd love haskell to do? to load as much of the file as it can on a type error
03:41:43 <osfameron> yeah
03:41:48 <osfameron> for use in ghci you mean?
03:41:52 <sohum> so I can immediately check the types of certain possibly offending things
03:41:53 <sohum> yeah
03:42:11 <osfameron> I've wanted that lots
03:42:21 <thoughtpolice> an incremental typechecker would be useful, but it'd be painful; similar to the problem of e.g. some IDE features for haskell
03:42:34 <thoughtpolice> the main issue is that partial programs are completely worthless to the typechecker
03:43:12 <thoughtpolice> and i'm not sure (nor am I aware of anyone who is) how you would fix that in the context of Haskell's current type system, especially with the extensions we now have
03:43:41 <thoughtpolice> the easiest way is to just to write down type signatures you think work to model your program, and just put 'undefined' as the definition
03:43:51 <sohum> why can't it ignore the construct that is causing the error and treat the rest of the file as an input file?
03:45:20 <quicksilver> it could.
03:45:27 <quicksilver> thoughtpolice is answering a slightly different question, I think.
03:45:47 <mebbel> a = length "what"; b = a + c; c = sqrt 3
03:46:02 <quicksilver> simply ignoring all the mutually recursive lumps which don't typecheck is trivial
03:46:06 <quicksilver> and it's annoying GHC can't do it :)
03:46:41 <mmorrow> thoughtpolice: heh, no. i haven't merged in the stuff from vacuum-gl yet. (that reminds me though. /me makes a note to do so)
03:48:00 <thoughtpolice> mmorrow: i might send you a patch for it right fast - something that just calls out to dot
03:48:16 <PeakerWork> mmorrow: "forking copies" of coroutines is not usually possible outside of Haskell :)
03:49:02 <mmorrow> you could just compute the SCCs of the functions in a module, then run the typechecker over each separately, then finally merge the ones that passed typechecking, et voila the largest subset of the module that typechecks..
03:49:15 <Gracenotes> mebbel: noes! you set my internal type-checker off!
03:49:19 <mmorrow> PeakerWork: :)
03:50:01 <mmorrow> thoughtpolice: oh, cool. i have a few functions like that as well... that'd be handy to have in-package for sure
03:50:04 <PeakerWork> mmorrow: need to resist the temptation to turn this into something more powerful -- but more dissimilar too :)
03:50:28 <PeakerWork> mmorrow: I don't understand how you meant you could implement throwTo via callCC -- you're abstracting callCC here, aren't you?
03:51:07 <quicksilver> mmorrow: I would have thought it would simpler to proceed greedily from the first function and backtrack on typeerror.
03:51:15 <quicksilver> mmorrow: avoids calculating the SCCs explicitly.
03:51:20 <quicksilver> but maybe GHC calculates them anyway.
03:51:24 <thoughtpolice> mmorrow: grr, can't build anything really depending on template-haskell with GHC HEAD
03:51:37 <mmorrow> Peaker: have a runCCWithTheAbilityToThrowAnException m = runCC (callCC (\k -> .. trickery .. >> m >> .. maybe more trickery)) ..
03:51:44 <thoughtpolice> (there were API-breaking changes in order to accomodate type families)
03:51:52 <thoughtpolice> speaking of
03:52:02 * thoughtpolice should probably go back to his registered x86_64 build
03:52:27 <mmorrow> thoughtpolice: ah yeah, that also reminds me. i've been meaning to start updating all my TH code to handle the switchover
03:53:08 <thoughtpolice> yeah, i've got a patch sitting around to fix derive partially with HEAD
03:53:13 <thoughtpolice> since it's needed for lhc hacking
03:58:06 <mmorrow> thoughtpolice: (looking at the HEAD TH haddocks) not too bad actually. looks like the only things that need changing to get existing code to work are: (1) Name->TyVarBndr in the places where the names were binding tyvars, (2) (Cxt=[Type])->(Cxt=[Pred])==>(Type->Pred)
03:58:32 <mmorrow> (+ adding cases for the new cons to *every single function that pattern matches on constructors :((((
03:59:29 <mmorrow> quicksilver: hmm, /me thinks what that means for a second
04:00:58 <stepnem> please, what does the '~' mean, e.g. in the definition of unzip?
04:01:02 <stepnem> @src unzip
04:01:02 <mmorrow> quicksilver: if you kept track of functions that failed, then bailed upon seeing a previously failed function mentioned in the current function, i think that'd be not too bad
04:01:03 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
04:01:35 <mmorrow> quicksilver: (although from what i understand you need to compute SCCs in order to get the most general type for functions in a mutually rec group)
04:01:56 <quicksilver> mmorrow: OK, if the calculat is happening anyway you might as well use it.
04:02:40 <stepnem> any pointers much appreciated, may I humbly ask -- just an URL or a single word...
04:02:55 <mebbel> stepnem: lazy binding
04:03:01 <stepnem> mebbel: thank you
04:05:15 <mmorrow> quicksilver: hmmm, actually you also have functions dependent on other functions, but not mutually recursive with them, so i guess you'd just have to topsort the SCCs, then start checking each one until the first failure, at which point you're done
04:05:56 <mmorrow> err, well no i guess the graph of SCCs is a dag, not a list
04:06:29 <sohum> is there a simpler way to write (truncate ((fromIntegral n)/(fromIntegral k))) ? as is, it hurtses my eyeses ;}
04:06:55 <mebbel> what's wrong with div?
04:07:02 <mmorrow> sohum: whenever i have to use fromIntegral a lot, i write "fi :: ..type of fromIntegral..; fi = fromIntegral"
04:07:20 <mmorrow> truncate (fi n / fi k)
04:07:26 <sohum> ... mebbel: nothing, except that I didn't know it existed
04:07:39 <mmorrow> oh heh, or div..
04:07:47 <sohum> thankee!
04:08:17 <doserj> @check \n k -> k == 0 || truncate ((fromIntegral n)/(fromIntegral k)) == n `div` k
04:08:18 <lambdabot>   "Falsifiable, after 6 tests:\n5\n-2\n"
04:08:21 <doserj> @check \n k -> k == 0 || truncate ((fromIntegral n)/(fromIntegral k)) == n `quot` k
04:08:23 <lambdabot>   "OK, passed 500 tests."
04:09:53 <sohum> @check \n k -> k > 0 && n > 0 ==> truncate ((fromIntegral n)/(fromIntegral k)) == n `div` k
04:09:54 <lambdabot>   Not in scope: `==>'Precedence parsing error
04:09:54 <lambdabot>      cannot mix `GHC.Classes.>'...
04:10:07 <sohum> ...huh.
04:10:17 <sohum> @check \n k -> k > 0 || n > 0 || truncate ((fromIntegral n)/(fromIntegral k)) == n `div` k
04:10:18 <lambdabot>   "* Exception: divide by zero
04:10:26 <sohum> .. or, right
04:10:33 <sohum> @check \n k -> k <= 0 || n <= 0 || truncate ((fromIntegral n)/(fromIntegral k)) == n `div` k
04:10:35 <lambdabot>   "OK, passed 500 tests."
04:10:40 <sohum> cools
04:11:38 <Gracenotes> might not be so for higher values
04:13:42 <doserj> > truncate (fromIntegral 10^26)
04:13:43 <lambdabot>   100000000000000004764729344
04:20:53 <Fred320> @pl (\x akk -> fun x : akk)
04:20:53 <lambdabot> (:) . fun
04:23:57 <McManiaC> @src putStrLn
04:23:58 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
04:24:04 <McManiaC> @src putStr
04:24:04 <lambdabot> putStr s  = hPutStr stdout s
04:24:12 <McManiaC> @src hPutStr
04:24:13 <lambdabot> Source not found. That's something I cannot allow to happen.
04:24:21 <Fred320> @src map
04:24:21 <lambdabot> map _ []     = []
04:24:21 <lambdabot> map f (x:xs) = f x : map f xs
04:30:01 <Fred320> @src filter
04:30:01 <lambdabot> filter _ []     = []
04:30:01 <lambdabot> filter p (x:xs)
04:30:01 <lambdabot>     | p x       = x : filter p xs
04:30:01 <lambdabot>     | otherwise = filter p xs
04:31:37 <Fred320> @pl \fun -> foldr ((:) . fun) []
04:31:37 <lambdabot> flip foldr [] . ((:) .)
04:42:42 <povman> I think I've found a bug in cabal: I have a Library which compiles a .c file with a main(). When I include that library in an Executable which has its own main, the .c main() is called when I run the program
04:45:40 <Fred320> @pl \x akk -> map (x:) akk ++ akk
04:45:40 <lambdabot> join . ((++) .) . map . (:)
04:47:04 <Fred320> :t join
04:47:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:48:39 <madhadron> Does anyone have any idea how to make a newtype wrapping a constructor around CInt storable again?
04:48:52 <jabbarz0> no Idea
04:49:09 <jabbarz0> Helooo anyone knows how to programme in Prolog
04:49:27 <madhadron> A very little
04:49:28 <whoppix> jabbarz0, what has that to do with haskell?
04:49:32 <whoppix> jabbarz0, try /j #prolog
04:50:40 <jabbarz0> well Haskell is similar to Prolog
04:50:58 <madhadron> jabbarz0, Not really
04:51:09 <whoppix> um.. no.
04:51:10 <madhadron> They don't even share an underlying logic
04:51:26 <whoppix> however, erlang is somewhat similar to prolog :)
04:52:13 <jabbarz0> where is he
04:52:44 <burp> prolog.. haskell? o0
04:53:07 <jabbarz0> helloooo
04:53:12 <jabbarz0> Prolog Programmer
04:53:27 <whoppix> jabbarz0, /j #prolog
04:53:31 <jabbarz0> I need to implement Euler's Sieve in Prolog
04:53:38 <whoppix> jabbarz0, wrong channel
04:53:41 <jabbarz0> no one there to help
04:53:48 <jabbarz0> I know this is Haskell
04:53:49 <Zao> Too bad.
04:54:00 <burp> and they have nothing in common -.-
04:54:14 <whoppix> jabbarz0, there are people in #prolog that probably can help you.
04:54:36 <madhadron> burp, Well, that's a little strong.  They both do both have underlying logics, as opposed to weird mutilations of Turing machines
04:54:41 <Zao> "Hello, I'm having this terrible problem with my Fiat." "Now why do you come to my Ferrari dealership to ask?"
04:55:00 <Zao> jabbarz0: It may be that you didn't ask the right way.
04:55:02 <burp> madhadron, ok
04:55:19 <Zao> Those prolog people sure like well-formed propositions :P
04:55:54 <whoppix> Zao, he isn't even in that channel, so I assume he didn't even try asking there.
04:56:23 <madhadron> Y'know, there's something quite satisfying about shoving a C library's interface inside a nice, functional wrapper.
05:13:44 <Fred320> @pl \x rest -> concat (map (place x) rest)
05:13:44 <lambdabot> (join .) . map . place
05:14:35 <Fred320> @pl concat . map
05:14:35 <lambdabot> join . map
05:14:41 <Fred320> :t concat
05:14:42 <lambdabot> forall a. [[a]] -> [a]
05:14:43 <Fred320> :t join
05:14:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:15:49 <McManiaC> @src (!!)
05:15:49 <lambdabot> xs     !! n | n < 0 = undefined
05:15:49 <lambdabot> []     !! _         = undefined
05:15:49 <lambdabot> (x:_)  !! 0         = x
05:15:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:17:21 <ivanm> > [] !! 0
05:17:22 <lambdabot>   * Exception: Prelude.(!!): index too large
05:17:30 <ivanm> the @src is wrong! :o
05:17:34 <ivanm> > [] !! -1
05:17:35 <lambdabot>   Precedence parsing error
05:17:35 <lambdabot>      cannot mix `GHC.List.!!' [infixl 9] and prefi...
05:17:45 <ivanm> > [] !! (-1)
05:17:46 <lambdabot>   * Exception: Prelude.(!!): negative index
05:22:30 <LeCamarade> How do I get as to generate static binaries?
05:25:08 <mmorrow> madhadron: that is nice
05:25:56 <ivanm> LeCamarade: ummmm.... ghc produces binaries that are static on their haskell dependencies
05:26:33 <ivanm> the only dynamic links (at least on *nix) are for GMP, and probably zlib if you use the haskell zlib library (and other such haskell bindings0
05:27:13 <McManiaC> @pl \i -> w (f i) >> s i
05:27:14 <lambdabot> ap ((>>) . w . f) s
05:27:46 <McManiaC> @src ap
05:27:46 <lambdabot> ap = liftM2 id
05:27:58 <LeCamarade> ivanm, No, I'm not using GHC. :o( I'm writing some assembly, and I realised I don't know how to get them static, yet it is what I need.
05:28:10 <ivanm> oh...
05:28:32 <ivanm> no idea for assembler... probably depends on which compiler you're using (or whatever it is that assembler uses)
05:28:36 <madhadron> I just had a horrible thought...are Ptr's allocated with Foreign.Marshal.Alloc.malloc garbage collected?
05:28:42 <cnwdup> Is there a way to minimise the memory using during linking? I want to link a binary on a 256 MB RAM system and when linking ld uses over 250 MB.
05:29:01 <madhadron> LeCamarade, The Linux documentation project has a nice guide on such things on Linux
05:29:22 <madhadron> called the Program Library HOWTO, I think
05:32:00 <whoppix> cnwdup, can't you just temporarily set up a swap file/partition?
05:32:53 <Fred320> @src append
05:32:54 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:32:58 <Fred320> @src (++)
05:32:58 <lambdabot> []     ++ ys = ys
05:32:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:32:58 <lambdabot> -- OR
05:32:58 <lambdabot> xs ++ ys = foldr (:) ys xs
05:32:59 <cnwdup> whoppix, I have one but it's taking damn long. I hoped there were ways to reduce the time necessary for that.
05:33:43 <madhadron> cnwdup, Well, the classical way is to put pieces of the project in shared libraries...
05:33:50 <madhadron> but that's probably not what you want to here.
05:33:51 <madhadron> hear
05:37:04 <cnwdup> madhadron, my project isn't big. I just seem to use expensive modules (System.Plugins?). I thought ghc couldn't link dynamically.
05:59:01 <mornfall> Stupid question (but, weird things are going on)...
05:59:05 <mornfall> How is:
05:59:24 <mornfall> "foo <- a `catch` b" interpreted?
06:00:03 <mornfall> For some weird reason, it seems that it works like (foo <- a) `catch` b, which I don't like the slightest... : - )
06:00:19 <quicksilver> no, it doesn't.
06:00:27 <quicksilver> it works like foo <- (a `catch` b)
06:00:31 <Deewiant> (foo <- a) `catch` b isn't even legal Haskell
06:00:43 <mornfall> Okey, then something else must be going on.
06:00:52 <quicksilver> (foo <- a) isn't an expression
06:01:14 <mornfall> Deewiant: I have thought so much, but adding parentheses apparently altered behaviour of the program.
06:01:34 <mornfall> Okey, let's experiment some more.
06:02:17 <mornfall> (My problem is that the exception from 'a' gets thrown when "foo" is used and does not get caught...)
06:03:36 <quicksilver> that's probably because exceptions in pure code are more evil than satan himself
06:03:36 <int-e> sounds like unsafeInterleaveIO (perhaps hidden in a readFile or hGetContents)
06:03:39 <mauke> are you sure 'a' throws an exception?
06:03:40 <quicksilver> and you shouldn't use them.
06:04:00 <mauke> int-e: but readFile swallows exceptions, I thought
06:04:03 <mornfall> How is 'a' pure?
06:04:17 <quicksilver> I don't know what monad you're working in, or anything :)_
06:04:19 <int-e> mauke: could be
06:04:30 <quicksilver> but the exception you're expecting to catch might be itself hidden in a pure value
06:04:33 <quicksilver> I'm only guessing here.
06:04:34 <mornfall> Yes, there's unsafeInterleaveIO involved. I played around with !patterns and $! and got it to a working order. But I don't know *why*, so I'm backtracking to figure which is the crucial bit.
06:04:41 <mauke> oh, ouch
06:05:18 <mornfall> (This is darcs code, and I'll eventually rip those -ing interleaves out, but that'll have to wait a little, since it's not quite... trivial.)
06:05:26 <McManiaC> @hoogle [(a -> b)] -> b
06:05:26 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:05:27 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:05:27 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
06:05:34 <mornfall> Ok, so you are right that () have no effect.
06:07:12 <mornfall> quicksilver: Aye. It's in IO, and the catch comes from Control.Exception.
06:07:27 <mornfall> Interestingly, !foo <- a `catch` b in itself doesn't have any effect on the outcome.
06:07:45 <int-e> mornfall: sure, because that forces the result of the `catch`.
06:07:50 <mornfall> Ah.
06:09:42 <mornfall> Ok, so adding $! to 'a' fixes the situation.
06:11:02 <mornfall> int-e: (Although. How come that the result of the catch doesn't need to force the result of its left side?)
06:14:52 <int-e> mornfall: because the result is just passed through. in a `catch` b, a context is set up for catching the exception, then a is forced, then a is executed. then the context is cleared up and the result of a is returned. If an exception happens, b is executed instead (after cleaning up the context)
06:15:00 <int-e> mornfall: but the result of executing a is never touched.
06:15:23 <Baughn> mmorrow: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects <-- Did you read this?
06:16:13 <mornfall> int-e: I semi-get it. Thanks (I'll have to study that a little bit more ... later.)
06:16:15 <int-e> mornfall: in particular,  return x `catch` foo === return x, because return can not cause any exceptions.
06:16:28 <int-e> @index evaluate
06:16:29 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
06:16:43 <int-e> :t  Control.Exception.evaluate
06:16:44 <lambdabot> forall a. a -> IO a
06:20:11 <Axman6> ivanm: you around?
06:21:02 <quicksilver> mornfall: (in reference to int-e's last comment, but there can be an exception hidden inside the value 'x' which will only be encountered when that part of the value gets forced)
06:21:49 <Baughn> mmorrow: Apparently indirections are only created when a thunk is evaluated, so if I get an indirection I don't need to chase it - I already know the value is evaluated. Anyway, that link is incredibly helpful.
06:24:36 <alar> greetings
06:24:52 <alar> is there a way to negate GHC-flag in cabal?
06:25:24 <mornfall> quicksilver: Yes, I have sort of figured it out by now -- unsafeInterleaveIO creates a "pure" value which then gets evaluated, forces the IO and trips the exception. Icky. (And thank to you, too.)
06:26:03 <quicksilver> yes.
06:26:36 <quicksilver> icky is a kind way of putting it ;)
06:27:07 <jabbarz5> Hellloooooooooooo
06:27:10 <jabbarz5> Anyone
06:27:14 <jabbarz5> PROLOG PROGRAMMER
06:27:16 <Axman6> ...
06:27:17 <jabbarz5> ]Prolog
06:27:19 <lunabot>  luna: Not in scope: data constructor `Prolog'
06:27:20 <jabbarz5> anyone
06:27:26 <Axman6> o.O
06:27:28 <quicksilver> jabbarz5: No. This channel is about haskell.
06:27:41 <ivanm> Axman6: yup
06:27:42 <quicksilver> jabbarz5: which is another programming language, almost but not entirely unrelated to prolog.
06:27:42 <jabbarz5> Prolog is similar to Haskell
06:27:47 <quicksilver> not very.
06:27:57 <Axman6> ivanm: you have anything to do with uzbl?
06:28:02 <ulfdoz> lol
06:28:13 <ivanm> wtf?
06:28:24 <jabbarz5> 555 Haskell Users in this Room
06:28:26 <Axman6> jabbarz5: haskell's a functional programming language, prolog is a logic programming language... slightly different thing
06:28:30 <jabbarz5> one of them should know prolog
06:28:39 <Axman6> jabbarz5: anything wrog with $prolog?
06:28:45 <ivanm> Axman6: what's uzbl?
06:28:50 <jabbarz5> do u know prolog
06:28:53 <jabbarz5> Axman
06:28:57 <quicksilver> jabbarz5: I imagine some of us do, but we wont' talk about it in this channel.
06:28:58 <Axman6> a webkit based web browser
06:29:02 <alar> I see that one can add extra flags in .cabal file
06:29:03 <quicksilver> jabbarz5: this channel is for discussion of haskell.
06:29:18 <alar> but how can I negate flags that cabal adds by itself?
06:29:28 <whoppix> jabbarz5, yes, there *are* several people here that know prolog (I know some prolog as well), but none of them will answer your prolog questions here, because this channel is about haskell :)
06:29:40 <jabbarz5> nest(N, L) that only succeeds if L is equal to [0, [1, [2, ... [N] ... ]]].
06:29:41 <Axman6> ivanm: http://www.uzbl.org/wiki/_media/uzbl_webinspector.png?cache= i saw ivanm on that screenshot of it
06:29:46 <jabbarz5> I want to define this RULE
06:29:47 <dcoutts> alar: you cannot, what is the problem?
06:29:50 <ivanm> Axman6: ahhh, yeah, I asked rob| about that
06:29:50 <jabbarz5> pleaaaaaaaseeeeeeeeeeeee
06:29:51 --- mode: ChanServ set +o quicksilver
06:29:59 --- kick: jabbarz5 was kicked by quicksilver (good bye)
06:30:00 <ivanm> I must have been pinging him about something on #xmonad
06:30:09 <Axman6> ahhhh, i see
06:30:09 <alar> dcoutts: it does not build DLL under windows
06:30:32 <alar> dcoutts: it adds             ghcSharedLinkArgs =
06:30:32 <alar>                 [ "-no-auto-link-packages",
06:30:32 <alar>                   "-shared",
06:30:32 <alar>                   "-dynamic",
06:30:44 <Axman6> wow, that guy was a total idiot
06:30:46 <alar> only -shared is necessary
06:30:54 <Axman6> wonder how he even heard of prolog
06:30:55 * ivanm missed all that
06:31:05 <alar> and -no-auto-link-packages breaks everything
06:31:08 <quicksilver> Axman6: he had to complete some coursework for a class in an hour or so.
06:31:27 <alar> my GHC doesn't know such flag :)
06:31:29 <dcoutts> alar: really? why? cabal will specify -package base etc
06:31:32 <ivanm> quicksilver: lol
06:31:42 <Axman6> yeah, sounded like that to me too
06:31:45 <alar> dcoutts: -package and others are okay
06:32:08 <dcoutts> alar: oh, I see, it's just the wrong flag name :-)
06:32:09 <jabbarz5> Hellloooo
06:32:14 <Axman6> urgh
06:32:21 <jabbarz5> I will ask a Haskell question
06:32:24 <alar> but -dynamic is unnecessary and -no-auto-link-packages doesn't work
06:32:35 <Axman6> jabbarz5: either you're quite stupid, or a really bad troll. either way, you should quit it
06:33:06 <jabbarz5> I want to define a Haskell List
06:33:11 <jabbarz5> substitute(X, L, Y, M) that only succeeds if M is constructed from the elements of L
06:33:15 <alar> dcoutts: and it'll be rather hard to fix with userHooks :)) userHooks interface is very far from GHC.build :)
06:33:17 <Axman6> @pl \n l = l <= n && n > 0
06:33:17 <lambdabot> (line 1, column 6):
06:33:17 <lambdabot> unexpected "="
06:33:17 <lambdabot> expecting pattern or "->"
06:33:19 <dcoutts> alar: ok. I don't think that's the only problem at the moment though.
06:33:21 --- mode: quicksilver set +b *!*n=jabbarz@80.79.157.*
06:33:21 --- kick: jabbarz5 was kicked by quicksilver (quicksilver)
06:33:27 <Axman6> @pl \n l -> l <= n && n > 0
06:33:27 <lambdabot> ap (flip . ((&&) .) . flip (<=)) (> 0)
06:34:13 <ivanm> quicksilver: looks like he doesn't get the  hint...
06:34:22 <quicksilver> apparently not.
06:34:33 <dcoutts> alar: see --enable-shared is about building a Haskell package as a dll, linking against other packages as dlls, and that doesn't work on windows yet. What you're trying to do is build a dll exporting a C api and to statically link in all the haskell packages.
06:34:49 <quicksilver> Axman6: liftM2 (&&) (l <=) (> 0)
06:34:50 <alar> yes
06:35:00 <quicksilver> Axman6: I don't think it looks all that nice.
06:35:04 <Axman6> yeah
06:35:06 <alar> actually I'm building DLL callable from other languages
06:35:11 <dcoutts> alar: right
06:35:16 <Axman6> i was just curious how it'd come out mainly
06:35:22 <quicksilver> perhaps (l <=) <^(&&)^> (> 0)
06:35:24 <alar> not every-module-is-separate-DLL program
06:35:27 <quicksilver> with InfixApplicative.
06:36:35 <dcoutts> alar: right, and those two things are quite different intentions. Cabal only has partial support at the moment for the non-working case :-) (it does actually work on Linux) We do not yet have support for making libs that can be called from other languages in Cabal. There's an open ticket on it.
06:37:43 <alar> dcoutts: then what build tool do you recommend for callable-from-FFI stuff? makefiles?
06:37:47 <opqdonut> hmm, http://hackage.haskell.org/packages/archive/InfixApplicative/1.0.1/doc/html/Control-Applicative-Infix.html is broken
06:37:51 --- mode: quicksilver set -o quicksilver
06:37:53 <opqdonut> some < and > signs are missing
06:38:26 <dcoutts> alar: at the moment, yes. See http://hackage.haskell.org/trac/hackage/ticket/148
06:38:32 <quicksilver> is <blah> haddock syntax for a link, perhaps?
06:38:45 <alar> @karma+ dcoutts
06:38:45 <lambdabot> dcoutts's karma raised to 7.
06:38:50 <opqdonut> quicksilver: might be
06:39:03 <alar> this was my first attempt to make cabal package :(
06:39:09 <doserj> and . sequence [(l<=),(>0)]
06:39:11 <quicksilver> only 7? we lost LB database again?
06:39:26 <Axman6> @karma
06:39:26 <lambdabot> You have a karma of 6
06:39:32 <Axman6> doesn't look like it
06:39:48 <dcoutts> alar: you could simplify your makefile by using cabal to build and then you do the link step with a script
06:40:50 <alar> dcoutts: thanks! and it will be partially portable, because cabal handles some issues
06:42:33 * alar found very outdated Setup.hs that builds DLL, but it has some hardcoded stuff which cabal normally autodetects
06:49:14 <Baughn> @tell conal I moved isHNF (now isEvaluated) into a separate package that should be appearing on hackage right about now, since it seemed useful outside unamb. The interface is the same. Please note, the isHNF code you got earlier is in error; it's chases indirections, which is unnecessary and leads to false negatives.
06:49:15 <lambdabot> Consider it noted.
06:49:46 <hackagebot> isevaluated 0.1
06:49:47 <pastorn> @paste
06:49:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:02:48 <hackagebot> isevaluated 0.2
07:04:16 <mauke> heh
07:06:15 <Baughn> mauke: ..no heh-ing, please. It's a genuine change, not just a bugfix. :P
07:21:53 <hackagebot> control-monad-exception 0.2
07:30:45 <byorgey> it seems hackagebot has returned.
07:31:04 * byorgey bakes lambda-honey-wheat bread
07:35:48 <yowgi> @faq can Haskell be used as a lethal poison if its lambdas are mixed with honey and wheat?
07:35:48 <lambdabot> The answer is: Yes! Haskell can do that.
07:43:38 <Taejo> @undo do {c <- cond; if c then yes else no}
07:43:39 <lambdabot> cond >>= \ c -> if c then yes else no
07:44:10 <Taejo> @pl cond >>= \ c -> if c then yes else no
07:44:10 <lambdabot> flip (flip if' yes) no =<< cond
07:44:52 <McManiaC> http://sprunge.us/IIgH?hs - i get the following message:
07:45:03 <McManiaC>     Couldn't match expected type `m a' against inferred type `Int'
07:45:03 <McManiaC>     In the expression: jump' newField (nr + 1) (x + dx, y + dy)
07:45:03 <McManiaC>     In the third argument of `foldl'', namely
07:45:39 <McManiaC> jump' should take one int and return IO Int
07:46:13 <doserj> McManiaC: your type signature is wrong. IO Int instead of IO int
07:46:26 <McManiaC> oh
07:46:44 <McManiaC> still gets the same msg
07:46:56 <byorgey> McManiaC: also, I think perhaps you want  foldr (>=>) return  instead of foldl' (>>=) return
07:47:17 <byorgey> or maybe foldl' (>=>) return, not sure which is better
07:47:21 <codebliss> @t fmap
07:47:21 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:47:23 <byorgey> the point is it needs to be >=> instead of >>=
07:47:30 <byorgey> @type (>=>)
07:47:31 <codebliss> > :t fmap
07:47:31 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:47:32 <lambdabot>   <no location info>: parse error on input `:'
07:47:34 <codebliss> > :t liftM
07:47:35 <lambdabot>   <no location info>: parse error on input `:'
07:47:49 <byorgey> codebliss: use @type
07:47:51 <codebliss> What's the real difference?  I see once reqs a functor and the other a monad
07:48:05 <codebliss> Okie day.  I know the types, was just showing up before I talk about them =|
07:48:06 <byorgey> codebliss: no difference in practice.
07:48:11 <codebliss> Alright.
07:48:15 <codebliss> fmap preferred?
07:48:37 <codebliss> I just noticed they were the same type sig except different reqs *facepalm*
07:48:38 <byorgey> codebliss: every Monad ought to be a Functor, with fmap = liftM
07:48:47 <byorgey> it's just an historical accident that this is not required
07:48:48 <codebliss> Mkay.
07:49:08 <codebliss> Are all monads functors, or all functors monads?
07:49:12 <codebliss> The latter?
07:49:16 <SamB_XP> yeah, if you ever find a Monad that isn't a Functor, report a bug against the package that defines the Monad instance
07:49:20 <byorgey> no, the former.
07:49:28 <codebliss> Oh.
07:49:29 <byorgey> functor is much more general than monad.
07:49:43 <codebliss> Gotcha.
07:49:45 <codebliss> Like arrows?
07:49:46 <jn_> does anyone know what the status of ghc and the lgpl is due to gmp? i'm curious what the implications of using ghc for commercial development are
07:50:28 <doserj> http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
07:50:29 <byorgey> codebliss: well... arrows don't fit quite as nicely into the hierarchy, but I suppose you could say they are more general than monads.
07:50:29 <SamB_XP> jn_: the implications are that you shouldn't statically link GMP in
07:50:46 <byorgey> codebliss: the exact relationship between monad + arrow is not that simple =)
07:50:48 <codebliss> byorgey: Understood, bad example =P
07:50:54 <byorgey> no problem =)
07:51:00 <SamB_XP> jn_: unless you want to provide the rest of the .o/.a files to allow users to link with modified versions of GMP
07:51:04 <thoughtpolice> jn_: currently GHC statically links gmp etc. into binaries since ghc doesn't support dynamic linking (yet)
07:51:17 <jn_> ugh
07:51:22 <thoughtpolice> jn_: if you distribute a binary version of your app you must also under the lgpl distribute object files so people can link with different versions of gmp
07:51:39 <thoughtpolice> jn_: but do not worry, both a) shared libraries and b) the removal of GMP from ghc are very much being worked on
07:51:44 <byorgey> codebliss: you might be interested in reading the Typeclassopedia: http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
07:51:51 <jn_> thoughtpolice: is there an ETA on that?
07:51:52 <SamB_XP> jn_: if you don't statically link GMP, you're fine, as long as you are willing to provide a copy of the GMP sources for any GMP binaries you give out
07:52:07 <jn_> SamB_XP: good to know
07:52:10 <jmcarthur_work> thoughtpolice, what is going to replace GMP? pure haskell code or some other library?
07:52:20 <codebliss> byorgey: Oh ya, thank you!  I had looked at this earlier, but I was much less experienced with monads
07:52:21 <thoughtpolice> jn_: no. well-typed is working on it (sponsored by the IHG)
07:52:21 <SamB_XP> thoughtpolice: I thought it already linked GMP in as a .so ?
07:52:28 <codebliss> byorgey: I should get it now.
07:52:34 <jn_> ah alright. thanks all.
07:52:37 <thoughtpolice> jn_: you should go to #ghc and talk to Igloo
07:52:45 <thoughtpolice> jn_: if you can help i'm sure they would appreciate it
07:52:54 <thoughtpolice> hopefully we can see GMP removed before 6.12 is out
07:53:01 <byorgey> codebliss: yeah, based on the kinds of questions you are asking I think you are at the perfect place to read it
07:53:16 <thoughtpolice> SamB_XP: hm, i might be wrong on that note but i'm not 100% sure
07:53:16 <codebliss> byorgey: tyvm =]
07:53:40 <thoughtpolice> jmcarthur_work: the plans are first to remove GMP and then have the Integer backends 'swappable' from what I understand
07:54:03 <thoughtpolice> jmcarthur_work: e.g. you can use either GMP or openssl's bignum (which has a better license and is of comparable speed)
07:54:18 <jmcarthur_work> ah, openssl
07:54:23 <thoughtpolice> jmcarthur_work: or you can use just a pure haskell version, for example
07:54:39 <jmcarthur_work> oh, i see what you mean
07:54:52 <jmcarthur_work> but does this mean no "official" Integer implementation?
07:55:24 <thoughtpolice> jmcarthur_work: Igloo has already written a version of Integer in haskell if you're interested in it - http://darcs.haskell.org/packages/integer-simple/
07:55:37 <thoughtpolice> although currently I don't think it's possible to put that in there in place of GMP very easily
07:55:41 <jmcarthur_work> thoughtpolice, quite! thank you
07:55:47 <jn_> who uses integers anyway
07:55:49 <codebliss> Is map a derivation of functors for the list monad?
07:56:03 <codebliss> theoretically lol
07:56:10 <jmcarthur_work> jn_, a lot of us!
07:56:19 <thoughtpolice> jmcarthur_work: in the old version of lhc we also used Isaac Dupree's 'HIntegerByInt' code as a stress tess
07:56:41 <Botje> codebliss: map is a specialisation of fmap for lists
07:57:07 <codebliss> Botje: Since functors allow you traverse a function to each element of a collection, and list is a collection?
07:57:08 <thoughtpolice> jmcarthur_work: which is a version of Integer implemented in pretty much haskell98
07:57:13 <thoughtpolice> that also has decent performance
07:57:16 <thoughtpolice> jmcarthur_work: http://isaac.cedarswampstudios.org/2007/HIntegerByInt/
07:57:55 <SamB> thoughtpolice: I thought you were still using that test ?
07:58:14 <thoughtpolice> SamB: oh yeah, we're still keeping all the old tests
07:58:16 * thoughtpolice facepalm
07:58:25 <SamB> it's apparantly a really good stress test, since it finds bugs in most Haskell compilers it's tested with
07:58:28 <thoughtpolice> SamB: but it works now!
07:58:31 <thoughtpolice> :)
08:00:01 <McManiaC> byorgey: my problem was simple: foldl' (>>=) (return count) instead of foldl' (>>=) return  :)
08:06:21 <Botje> codebliss: yep
08:22:47 <codebliss> Anyone here read through the monads part of typeclassopedia?
08:22:57 <Xenox> Hi everybody. I'm reading through WxHaskell and in the source code I found "evtHandlerOnEventConnect :: EvtHandler a -> Id -> Id -> EventId -> state -> OnEvent".
08:23:09 <Xenox> Now the state type is nowhere defined, how is this possible
08:23:30 <byorgey> McManiaC: ah, yup, that works too
08:23:31 <fasta> Xenox: it is a variable
08:23:32 <codebliss> Did you check the imports?
08:23:33 <eivuokko> It's a type variable
08:24:30 <byorgey> types beginning with lowercase letters are variables, uppercase are type constructors.
08:24:47 <byorgey> codebliss: do you have a question about it?
08:24:49 <Xenox> so the type is a variable defined @ runtime?
08:25:02 <fasta> Xenox: no
08:25:25 <fasta> Xenox: you can have a user-defined type there, but all types are known at compile-time.
08:25:33 <codebliss> byorgey: I did the example wrong, I'll post again in a minute =P
08:25:36 <Xenox> This is the function where it all starts with: evtHandlerOnEvent :: EvtHandler a -> Id -> Id -> EventId -> handler -> OnEvent
08:25:38 <byorgey> Xenox: it means that evtHandlerOnEventConnect is polymorphic in the state type.  it works no matter what type 'state' actually is.
08:26:00 <fasta> Xenox: if you never use the state, you can even put undefined there.
08:26:14 <Xenox> ahh ok, so actually state can also be type 'a' for example?
08:26:33 <fasta> Xenox: a unifies with state, so yes.
08:26:46 <byorgey> sure, or Int, or whatever
08:27:07 <byorgey> a variable unifies with anything.
08:27:42 <monochrom> "f :: int -> [int]" would be a cool prank :)
08:28:40 <Xenox> And if i want to store this 'state' in a data type Such as Closure = Closure state (Bool -> Int), how do i need to define state then?
08:28:59 <fasta> monochrom: it would be fun to release all Haskell compilers on April First with a Prelude that had type signatures like that.
08:31:33 <codebliss> byorgey: defining (>>=) in terms of join and fmap is kinda tough, couple more minutes =P
08:32:10 <byorgey> codebliss: you can do it! =)  pay attention to the types.
08:32:21 <byorgey> if you can write down something with the right type it will probably be correct.
08:32:52 <codebliss> byorgey: I got the idea.  Since I have join and not pure, I need to lift them all up to multiple levels of monad then simplify them down.  Just got a little bit of a headache taking it all in =P
08:32:55 <fracture> if I call length on the same list multiple times in an expression (or whatever similar sort of thing), is it safe to assume GHC -O can figure out to only do it once?
08:33:00 <codebliss> Used to thinking with pure, not join =P
08:33:19 <Baughn> fracture: No
08:33:26 <fracture> ah
08:33:45 <fracture> is there a description of what of that sort of optimization it can make somewhere online?
08:33:45 <Baughn> fracture: Which is not to say that it won't, but there are severe issues in the general case. To say..
08:33:54 <fracture> ah
08:34:15 <byorgey> codebliss: yup.
08:34:26 <Baughn> fracture: If you have "let a = makeLargeThing x; b = makeLargeThing x", then obviously a and b are equal, and /could/ be shared without trouble
08:35:42 <eivuokko> fracture, Exactly what kind of information you are after with "sort of optimization"?
08:35:52 <Baughn> fracture: However, if GHC actually combined them, then.. say a/b are a list, say - a function that goes on to walk a would leak memory, since a would get lazily constructed and you'd /expect/ it to get GCd along the way, but b is holding on to the head of the list so it can't be GC'd
08:36:05 <Baughn> fracture: (That's assuming nothing else is holding on to a, of course)
08:36:11 <Baughn> fracture: Um. Did that make sense?
08:36:33 <fracture> ah yes
08:36:37 <eivuokko> fracture, If you are interested to learn in general how to see what ghc does, it's good to learn to read "core."
08:36:37 <codebliss> a >>= g = join . ((fmap g) a)
08:36:40 <Baughn> fracture: I'm pretty sure GHC will combine them in some cases, but only when it can prove that to be safe, which is less often than /you/ can.
08:36:51 <codebliss> byorgey: Does that satisfy it?  =P
08:36:52 <fracture> but if you had two copies of the result of makeLargeThing, it's just as bad as not being able to GC the one copy, no?
08:37:03 <fracture> eivuokko: what's that?
08:37:03 <Baughn> Not if they're created lazily
08:37:08 <fracture> ohhhhh
08:37:10 <fracture> ok now I grok you
08:37:13 <byorgey> codebliss: does it typecheck?
08:37:21 <codebliss> I'll check, good idea
08:37:21 <fracture> for example, makeLargeThing x = [x..]
08:37:24 <fracture> no?
08:37:30 <Baughn> Right, that's a good example
08:38:00 <fracture> eivuokko:  by "that type of optimization" I guess I was just thinking something like common subexpression elimination in an imperative language
08:38:05 <codebliss> Can you define just type sigs in ghci?
08:38:09 <codebliss> Or does join exist somewhere
08:38:17 <byorgey> codebliss: join is in Control.Monad
08:38:23 <codebliss> Thanks
08:38:23 <byorgey> codebliss: you can also use lambdabot
08:38:33 <codebliss> Touche.
08:38:44 <codebliss> > let foo a g = join . (fmap g) a
08:38:45 <lambdabot>   not an expression: `let foo a g = join . (fmap g) a'
08:39:14 <byorgey> @type \a g -> join . ((fmap g) a)
08:39:16 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a2 -> a1) -> (a1 -> m (m a)) -> a2 -> m a
08:39:20 <fracture> Baughn: that actually answered another thing I was wondering about the other day too (whether lazily created stuff can be GC'd as it is being used)
08:39:27 <byorgey> codebliss: that's not quite right, but you are very close
08:39:27 <Baughn> fracture: As you can see, laziness complicates CSE quite a bit. :)
08:39:30 <fracture> pretty nifty, that is
08:39:30 <codebliss> Oh...
08:39:33 <fracture> *nod*
08:39:42 <jn_> has anything usable come out of the "Static Contract checking for Haskell" paper yet?
08:39:57 <Baughn> fracture: Oh, and in "let a = [x..] in doSomethingWith a", a can be GC'd while it's doing Something
08:40:00 <jn_> or is there anything similar?
08:40:04 <eivuokko> fracture, Ah ok.  I thought you wanted to learn some comprehensive way to know what's "fast" in haskell/ghc.
08:40:23 <Baughn> fracture: GHC bases GCing on the program's continuation, not what's in lexical scope
08:40:39 <Baughn> fracture: (Since a isn't in fact ever referenced again, it can be GC'd)
08:41:11 <codebliss> @type \a g -> join ((fmap g) a)
08:41:12 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
08:41:13 <fracture> got ya; makes sense
08:41:20 <Baughn> fracture: (Well, it compiles to something a bit more traditional, but in general you can assume ghc -O2 is a sufficiently smart compiler)
08:41:22 <codebliss> I did (.) instead of ($) again =X
08:41:30 <byorgey> codebliss: hehe
08:41:37 <byorgey> codebliss: that's it!
08:41:46 <byorgey> well done
08:41:51 <fracture> eivuokko: that seems a bit more general than what I was curious about (although I suppose it's useful to know more anyway) ... but anyway, what's "core"?
08:41:54 <codebliss> PS:  The engineer's given/prove system is awesome lol
08:42:03 <codebliss> Chemistry teacher taught me it once last year.
08:42:18 <byorgey> codebliss: what's that?
08:42:38 <Baughn> fracture: Core is what GHC compiles Haskell to
08:42:45 <codebliss> Make two columns,  Given and Prove.  On given write what you can use, and on prove do your work with the answer being the last line
08:42:49 <fracture> ahh, a sort of intermediate language?
08:42:51 <Baughn> fracture: Core is then compiled further, but it's the lowest reasonably readable layer
08:43:00 <byorgey> codebliss: ah, right, got it
08:43:02 <eivuokko> fracture, It's a representation of you source that ghc can output.  It's human readable.  It's a sort of functional language, so you can see CSE and such optimisations on it.
08:43:04 <Baughn> fracture: More to the point, most optimizations are Core -> Core
08:43:09 <fracture> is it the lowest arch-independent layer?
08:43:24 <quicksilver> no, there is Cmm below it
08:43:28 <eivuokko> In some sense, but no.
08:43:31 <fracture> ah k
08:43:36 <Baughn> Whether Cmm is arch-independent is.. debatable
08:43:39 <eivuokko> Cmm isn't really arch independent, but yeah.
08:43:40 <codebliss> @type \a g -> join $ fmap g $ a
08:43:41 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
08:43:44 <fracture> is Core part of the haskell language standard, or a GHC-invention?
08:43:49 <Baughn> GHC
08:43:54 <fracture> ok cool
08:44:23 <Baughn> fracture: Anyway, if you want to know what your program is /really/ doing - post-optimization - read the core. It takes some practice, but it's very doable.
08:44:36 <Baughn> fracture: Also of use is the --show-iface option to ghc; takes a .hi file
08:44:44 <byorgey> @type (join .) . flip fmap
08:44:46 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
08:44:47 <eivuokko> It's actuall very easy compared to how to learn *what* compiler does compared to most other compilers/languages.
08:44:51 <McManiaC> http://www.haskell.org/haskellwiki/Performance - "Profile, profile, profile - understand who is hanging on to the memory (+RTS -hc) and how it's being used (+RTS -hb)."
08:44:56 <McManiaC> what is +RTS -hb ???
08:45:19 <Baughn> McManiaC: Read the GHC User Guide
08:45:24 <eivuokko> McManiaC, +RTS foo passes information foo to runtime system that comes with ghc, and each program compiler with ghc.
08:45:32 <fracture> cool; thanks guys
08:45:36 <vininim> damn t, where is my scratch pad?
08:45:49 * vininim hates to have to reinit gnome for xmonad reload
08:45:50 <Baughn> McManiaC: (Profiling section)
08:45:58 <Baughn> vininim: M-q doesn't work?
08:46:19 <Baughn> vininim: I've got a wholly gnomeless setup, if you want. Works nicely.
08:46:23 <vininim> Baughn: no, seems to be a known problem in fedora 10
08:47:10 <vininim> mine too, except I forgot thescratch pad xD
08:47:30 <Baughn> vininim: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5320#a5321 <-- Have one anyway. You might get ideas. ;)
08:48:11 <codebliss> @src join
08:48:11 <lambdabot> join x =  x >>= id
08:49:23 <codebliss> That's...sweet.
08:49:34 <codebliss> I would have never thought of that lol
08:49:39 <Baughn> @src (>>=)
08:49:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:50:02 <codebliss> Lambdabot is just too awesome lol
08:50:07 <Baughn> a >>= f = join (fmap f a)
08:50:24 <Baughn> Or liftM. Whatever.
08:50:36 <codebliss> I figured that out earlier =)
08:50:41 <codebliss> I'm doing the second exercise
08:50:47 <codebliss> join in terms of (>>=)
08:50:47 <Baughn> Ah, typeclassopedia?
08:50:52 <codebliss> Yep =)
08:51:01 <codebliss> But I didn't know I was allowed to use id, lol dumb me
08:51:04 <Baughn> Have fun when you get to the transformers. :P
08:51:09 <codebliss> XD
08:53:09 <codebliss> This join definition is awesome.  I'm still trying to get around the simplicity XD
08:53:40 <conal> Baughn: hi.  just saw your @tell comments in the #haskell log.
08:53:40 <lambdabot> conal: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:54:08 <Baughn> conal: Mm. I'd say it works fine now.
08:54:21 <Baughn> conal: I've been trying to break unamb/isEvaluated for an hour, to no avail
08:54:42 <conal> Baughn: great news!
08:55:12 <Baughn> conal: ..but hang on, how did you see the comments when you were offline?
08:55:13 <conal> Baughn: are you playing with it stand-alone and in the context of reactive?
08:55:32 <Baughn> conal: Both. I've yet to break reactive, too, except for anything that involves join/Monad.
08:55:55 <conal> Baughn: http://tunes.org/~nef/logs/haskell/09.05.27
08:56:07 <Baughn> Ah
08:56:21 <Baughn> ..you sneak
08:56:37 <conal> :)  i have an emacs command that pops up the current day's #haskell archive
08:56:48 * conal <3 s emacs
08:56:59 <skorpan> emacs YEAHHHHH
08:58:27 <codebliss> byorgey: Baughn: Would it be a good idea to write mapM, sequence, when, etc using bind and return?
08:58:28 <Baughn> conal: Anyway - isEvaluated works with int, integer, tuples, strict and unstrict data, mvars (no idea what the dedicated mvar closure tipe is for, then - internal?), etc. etc.
08:58:41 <Baughn> @src sequence
08:58:41 <lambdabot> sequence []     = return []
08:58:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:58:41 <lambdabot> --OR
08:58:41 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:58:45 <codebliss> Shhhhh
08:58:48 <codebliss> I mean on my own
08:58:50 <codebliss> ugh lol
08:58:58 * Baughn snorts
08:59:06 <EvilTerran> codebliss, even more cunning: join = (>>= id)
08:59:48 <codebliss> Ya, less readable imo though =P.  I used to love points-free but lately I've been liking \_->
09:00:07 <conal> Baughn: something funny going on with isHNF and Integer?
09:00:37 <Baughn> conal: That was down to my chasing indirections, which is just a bad idea
09:00:56 <conal> Baughn: oh yeah.  what's the deal with indirections?
09:01:02 <Baughn> conal: As it turns out, the RTS only writes indirections when evaluating a closure, so if I see one I can just assume it's fine
09:01:27 <rampa_nick> Newbie question here. How do I create a list of length n populate it with a constant float, say a, except for the first and last values that should be b. For example [b, a, a, a, a, a, b]  where n = 7.
09:01:34 <conal> Baughn: oh!  it might not be in whnf yet but will be soon?
09:01:48 <quicksilver> rampa_nick: [b] ++ replicate 7 a ++ [b]
09:01:51 <Baughn> conal: No, it writes them /after/ evaluating. :)
09:02:15 <conal> Baughn: oh.  got it.  good thing.
09:02:26 <Baughn> conal: Basically, it goes "read thunk closure, start evaluation, write new closure with evaluation result, overwrite thunk with indirection"
09:02:42 <rampa_nick> Thanks quicksilver.
09:02:43 <Baughn> conal: I think the GC also uses them. Hopefully not in a bad way; I'm working on testing that.
09:03:10 <mreh> mmmm smooth linux fonts on xchat
09:03:21 <Baughn> @index performGC
09:03:21 <lambdabot> System.Mem
09:04:38 <Baughn> conal: ..nah, it's fine.
09:05:24 <mreh> can I apt-get yi?
09:05:40 <lilac> mreh: you can cabal install it iirc
09:06:07 <codebliss> @src id
09:06:07 <lambdabot> id x = x
09:06:07 <mreh> cool
09:06:17 <codebliss> Tough definition!
09:07:13 <lilac> eta reduces to: id =
09:07:39 <lilac> which sadly is not legal haskell :-(
09:07:50 <osfameron> hehe
09:11:39 <LeCamarade> Does the thread behaviour change between running through runhaskell and running a compiled?
09:12:00 <LeCamarade> There is this deadlock that only seems to show up when I run a compiled thingy.
09:13:06 <Baughn> LeCamarade: It shouldn't, but it does change between -threaded and not-threaded
09:13:22 <Baughn> LeCamarade: (If you're having issues, try adding -threaded first)
09:13:36 <lilac> this GHC CAS thingy... it seems to me that thunk evaluation could be changed to (1) overwrite the thunk with a 'do something else and check back later' thunk, (2) execute the thunk, (3) overwrite the thunk with a 'here's the result' one.
09:13:54 <cadabra> Can I subRegex with Text.Regex.PCRE?
09:14:06 <lilac> it wouldn't eliminate the race but should reduce the rate at which it happens, and it'd allow detecting forcing-X-forces-X hangs
09:14:11 <conal> Baughn: do you have a sense for whether the isEvaluated optimization of unamb is worth the overhead?
09:14:27 <Baughn> conal: I lack a working reactive program to test it on
09:15:31 <conal> Baughn: yeah.  sry about that.  interested in helping sort out the remaining problems with reactive?
09:16:35 <Baughn> conal: Definitely, once I'm done with exams. ;)
09:16:48 <codebliss> @src (>=>)
09:16:49 <lambdabot> Source not found.
09:17:20 <conal> Baughn: sweet.  good luck on those exams.  what school?
09:17:37 <Baughn> conal: University of Troms
09:18:09 <thoughtpolice> lilac: well, the CAS experiment was just aimed at seeing how high an overhead we get by having the guarantee that 1 thunk isn't evaluated by two processors
09:18:12 <Baughn> conal: You've probably never heard of it. It specializes mostly in distributed systems.
09:18:36 <thoughtpolice> lilac: and in this case the cost of CAS seems fairly dramatic for parallel programs, especially on i386 machines
09:19:07 <lilac> thoughtpolice: right, but what i'm suggesting doesn't require any locked instructions, and /should/ reduce the risk with only one extra memory copy
09:20:07 <thoughtpolice> lilac: simon seems to already have done something similar I think in GHC HEAD - eager blackholing
09:20:11 <thoughtpolice> http://www.mail-archive.com/cvs-ghc@haskell.org/msg12210.html
09:21:08 <lilac> thoughtpolice: i should have known better than to think i'd thought of something which the GHC devs hadn't ;-)
09:21:41 <thoughtpolice> lilac: :)
09:21:48 <conal> i guess i'll have to decide what to do with the Event "monad", which (a) doesn't satisfy monad laws in some (perhaps edge) cases, and (b) doesn't yet have a compelling & sufficiently lazy implementation.
09:21:55 <thoughtpolice> lilac: it might actually be exactly what you are describing from what I see
09:23:00 <lilac> thoughtpolice: looks a lot like it, but the patch means very little to me
09:23:03 <thoughtpolice> lilac: it would be an interesting benchmark to compare GHC HEAD code with/without -feager-blackholing
09:23:36 <thoughtpolice> to see how much of a gain we get/see how much we lose to a thunk being evaluated twice
09:23:56 <LeCamarade> Baughn, I have some code that doesn't seem like it should have race conditions. And they only seem to show up when I run it as compiled binary. Am I right when I infer a serious difference in thread behaviour under the two environments?
09:24:04 <eivuokko> Does anyone remember details about strictness in continuation monad?  I recall there was difference in using case vs. let in (>>=), but I can't see it myself now.
09:24:10 <conal> Baughn: i like the conceptual simplicity of Reactive's data-driven, and yet purely functional, implementation style.  but some of the laziness/termination issues have been pretty difficult for me to sort out.
09:24:59 <lilac> thoughtpolice: i guess in practice it depends quite a lot on (1) how much it happens, and (2) how often the black-hole write makes it to the other CPU before the thunk is evaluated for the second time
09:25:46 <Baughn> LeCamarade: Yes. However, if race conditions show up only in one form, chances are they /exist/ in both. :)
09:26:30 <LeCamarade> Okay. I hate how so hard this bug seems to debug. I don't even know where to start, since my program has a million threads at any one time! :o)
09:26:33 <conal> PeakerWork: ping
09:26:38 <LeCamarade> And it's production.
09:26:59 <conal> PeakerWork: any thoughts on checkers and QuickCheck 2?
09:27:18 <Baughn> LeCamarade: To begin with, your fundamental threading model may be a bad idea
09:27:29 <lilac> LeCamarade: how do your threads communicate?
09:27:38 <Baughn> LeCamarade: If you're doing mutable-memory style threading.. well, how do you do it?
09:28:32 <LeCamarade> I only use Chans and MVars.
09:28:45 <codebliss> Baughn: Screw transformers XD
09:28:52 <LeCamarade> I only really use the threads to have asynchrony, not to speed things up.
09:28:59 <thoughtpolice> lilac: yeah, it'd be very much per-benchmark, but trying it over a few different benchmarks might give an idea
09:29:05 <Baughn> LeCamarade: MVars as unit-capacity channels, or as mutable variables?
09:29:09 <thoughtpolice> (e.g. all of the parallel shootout code or something)
09:29:14 <LeCamarade> I only use Chan, MVar, and SampleVar.
09:29:29 <LeCamarade> Baughn, As mutable variables. :-p
09:29:59 <Baughn> LeCamarade: Right. If you're touching multiple MVars at once, try using STM instead
09:31:13 <gwern> hm. no gitit in the hcar
09:31:22 <gwern> and no happstack
09:33:09 <LeCamarade> Baughn, Why would touching multiple MVars cause a deadlock hazard? In other words, I'm rather ignorant about the difference therein.
09:33:35 <Baughn> LeCamarade: If thread 1 locks mvar a and then b, while thread 2 locks b and then a..
09:33:50 <ksf> hmmmm... what magic words do I need to google for to find a program that automagically generates bindings for glib-based libraries? webkit-gtk, to be precise.
09:33:52 <Baughn> LeCamarade: You have to make sure to always lock them in the same order, regardless of thread. It's annoying.
09:33:59 <Baughn> LeCamarade: STM takes care of that much more nicely.
09:34:44 <McManiaC> ghc -O2 -threaded --make springer.hs
09:34:46 <McManiaC> ./springer 5 5 +RTS -N2 -s
09:34:51 <McManiaC> why doesnt he use 2 threads?
09:34:52 <McManiaC> :o
09:35:12 <thoughtpolice> McManiaC: ?
09:35:30 <McManiaC> http://haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
09:36:01 <mreh> when are they packaging cabal with haskell?
09:36:10 <Baughn> mreh: They already have
09:36:15 <Baughn> See the haskell platform
09:36:25 <mreh> Baughn, with ghc6.10?
09:36:28 <Baughn> Yes
09:36:32 <mreh> ooo
09:36:39 <LeCamarade> Okay, I'll go and turn all cases of MVar into STM. Is that intelligent? I'm going to have to brush up, also. (I wrote this application in 6.4 days, and I just ported it to 6.10 last month.)
09:37:02 <dcoutts> mreh: the haskell platform version 2009.2.0 includes ghc 6.10.2, cabal-install and a bunch of other libs and tools
09:37:08 <Baughn> LeCamarade: ..well, it might work, but it's a bit of a brute-force solution
09:37:19 <Baughn> LeCamarade: Still. Go ahead.
09:37:34 <Baughn> LeCamarade: Also, compile with -threaded; that adds deadlock detection
09:38:10 <mreh> is there a debian package source for 6.10 yet?
09:38:36 <McManiaC> ghc -O2 -parallel --make springer.hs
09:38:39 <McManiaC> <command line>: unknown package: concurrent
09:38:40 <McManiaC> ?
09:38:43 <Baughn> mreh: -threaded
09:38:56 <McManiaC> -threaded has no effect =(
09:39:04 <LeCamarade> Baughn, I think I have deadlock detection (dynamic). It throws a deadlock exception, but I don't know where to find the deadlock.
09:39:06 <Baughn> What effect do you expect it to have?
09:39:19 <McManiaC> make use of my dual core?
09:39:22 <LeCamarade> It seemed easy to reproduce, until I started using runhaskell, and it stopped showing up.
09:39:25 <Baughn> LeCamarade: You can add onError handlers or whatever to figure that out
09:39:35 <LeCamarade> Heisenbugs will rule the Earth,
09:41:24 <dcoutts> McManiaC: -threaded links your program with the threaded rts, you can tell your program to run on multiple cores using ./prog +RTS -N2
09:41:46 <dcoutts> McManiaC: though obviously you need to have written your program to take advantage of multiple cores, eg using par
09:42:00 <mreh> I would rather not learn how to install GHC from source, but I can't find a debian package source for either of those
09:42:13 <mreh> ghc6.10 or the haskell platform
09:42:15 <McManiaC> dcoutts: is there a wiki about par?
09:42:30 <mreh> par!!
09:43:47 <doserj> mreh: you probably can install the generic linux binary ghc-6.10 package
09:44:13 <mreh> doserj: with the C compiler?
09:44:22 <mreh> oh binary
09:44:44 <dcoutts> McManiaC: there's not a lot on the wiki on how to use par that I can see. The haddock docs are probably a good place to start.
09:45:06 <McManiaC> ok
09:45:09 <dcoutts> McManiaC: though see http://haskell.org/haskellwiki/Blog_articles/Parallel
09:45:56 <dcoutts> McManiaC: and there's a paper http://www.haskell.org/~simonmar/bib/multicore-ghc-09_abstract.html
09:46:07 <McManiaC> :) thx!
09:47:29 <hackagebot> pointedlist 0.3.5
10:19:26 <McManiaC> @src (/)
10:19:27 <lambdabot> Source not found. There are some things that I just don't know.
10:19:35 <McManiaC> @src (+)
10:19:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:19:39 <McManiaC> meh
10:19:54 <glguy> (/) and (+) are class methods
10:19:57 <EvilTerran> McManiaC, it depends of which instance of Num you're using
10:19:57 <EvilTerran> ?src Num
10:19:57 <lambdabot> class  (Eq a, Show a) => Num a  where
10:19:57 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:19:57 <lambdabot>     negate, abs, signum     :: a -> a
10:19:57 <lambdabot>     fromInteger             :: Integer -> a
10:19:58 <glguy> the have no source code in general
10:20:05 <EvilTerran> (or Fractional in the case of /)
10:20:15 <glguy> unless ther is a default implementation, which seems unlikely
10:21:23 <lilac> glguy: a / b = a * recip b?
10:21:44 <McManiaC> hm so i need a class
10:21:44 <McManiaC> okay
10:23:09 <lilac> McManiaC: what are you trying to do?
10:24:18 <McManiaC> hmmm
10:24:43 <McManiaC> im trieing to represent polynoms as some kind of non-sortable list
10:24:47 <McManiaC> trying
10:25:05 <EvilTerran> non-sortable?
10:25:08 <lilac> McManiaC: you want to define your own (/)?
10:26:17 <lilac> might i suggest defining div and mod instead of (/) for polynomials (since they form an integral domain but not a field)?
10:28:04 <McManiaC> data Polynoms = Num a => Poly a Polynoms
10:28:09 <McManiaC> where is that Num a supposed to be?
10:28:09 <McManiaC> ^^
10:29:03 <lilac> McManiaC: looks like an existential, and probably not what you wanted...
10:30:53 <roconnor> @wiki Data_declaration_with_constraint
10:30:53 <lambdabot> http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
10:30:58 <roconnor> McManiaC: ^^
10:44:10 <Philonous> You can use smart constructors to enforce type constraints on data types. i.e. for a data type data Foo a = Foo a you write a function foo :: (MyClass a) => a -> Foo a ; foo = Foo, and only export the function, but not the constructor
10:47:16 <Philonous> But I don't know if this is really useful. Why constrain the data type in the first place? Put it in the functions. e.g. bar :: (MyClass a) => Foo a -> Baz
10:47:51 <Baughn> I certainly wouldn't call /that/ useful
10:48:19 <Baughn> You can stick a constraint on the data statement itself, in which case you don't need to put one on the functions to let you use the classes.. but that's confusing
10:48:40 <Baughn> Anyway, a lot of the time you end up writing some functions that need the classes and some that don't
10:58:03 <ray> i've had enough of debian ghc packages
10:59:04 <jiyunatori> hi. some time ago, I started a program with complex datatypes. to easily modify these datatypes, I had to write something called "functional references". I ended writing a lot of boilerplate code, as I'm not familiar with TH and stuff. Is it still necessary to write functional refs now ?
11:00:19 <copumpkin> type families are an alternative that people like more
11:01:33 <fracture> ugh...
11:01:44 <fracture> pressing uncomment on a block in haskell-mode leaves an extra space in front of everything
11:02:03 <fracture> has anyone really used this mode for actual programming... it's got so many little warts :(
11:02:10 <jmcarthur_work> yeah i've run into that too. i just don't use haskell-mode's commenting/uncommenting stuff
11:02:19 <fracture> (maybe if I stick with haskell I'll work on improving it at some point)
11:02:26 <ray> i used it for a bit, but i like manually laying out haskell more
11:02:37 <jmcarthur_work> i mostly like haskell-mode
11:02:43 <jmcarthur_work> there are definitely warts though
11:02:45 <Baughn> I use it a lot, but I haven't noticed comments doing that
11:02:47 <ray> plus, i'm not really an emacs user
11:02:58 <ray> and when i am, it's xemacs
11:03:16 <jmcarthur_work> afaik, most emacs users are xemacs users
11:03:16 <fracture> Baughn: mark a block, hit C-c C-c then C-u C-c C-c, and it still has a space in front of it
11:03:33 <ray> i meet a lot more gnu emacs users
11:03:36 <fracture> I've pretty much always used GNU emacs
11:03:37 <Baughn> fracture: C-c C-c is undefined for me
11:03:42 <fracture> oh ;)
11:03:43 <Baughn> fracture: I use M-;, which is comment-dwim
11:04:02 <jmcarthur_work> ray, oh, actually, i got confused. n/m :)
11:04:18 <fracture> Baughn: how do you comment out a whole block?  kb macro?
11:04:21 <ray> oh, did you mean "x11 emacs"?
11:04:24 <jmcarthur_work> yeah
11:04:29 <ray> yeah, that's common
11:04:35 <ray> but both of them have that
11:04:38 <Baughn> fracture: Mark, move, M-;
11:04:53 <fracture> hmm.. that just puts a -- at the eol for me
11:04:54 <jmcarthur_work> right, i simply forgot that xemacs was a different thing
11:05:30 <Baughn> fracture: Which version of haskell-mode are you using? The last release was /ages/ ago, but the cvs is somewhat more up to date
11:05:39 <jn_> is there a better way to convert a character literal to Word8 than using w2c?
11:05:43 <jn_> er.. c2w?
11:05:53 <fracture> 2.4
11:06:01 <fracture> probably not cvs version
11:06:13 <Baughn> jn_: Character literals are Unicode. Use ord.
11:06:29 <Baughn> jn_: Then convert it however you feel like. There are utf-8 libraries around.
11:06:45 <Zao> jn_: Feed it through utf8-string or Data.Text
11:06:59 <Baughn> ..well, utf8-string is apparently part of GHC in 6.10.3
11:07:02 <Zao> I prefer the Data.Text way, as I can keep strings around in the Text type.
11:09:39 <glguy> Baughn, it is?
11:09:45 <ray> that was much easier than the debian packages
11:10:05 <jn_> is there a way to get the newline string used for the current platform?
11:10:12 <Baughn> glguy: Apparently, at least in the full distribution
11:11:24 <copumpkin> @seen RyanT5000
11:11:25 <lambdabot> I saw RyanT5000 leaving #haskell-in-depth and #haskell 3h 49m 2s ago, and .
11:17:28 <jn_> alternatively, can anyone tell me is Data.ByteString.lines will work properly on windows? the source indicates it's just using elemIndex '\n' as the search function
11:17:36 <ray> huh. why did that ghc tarball install every .hi file as mode 600
11:17:36 <jn_> *if
11:17:39 <ray> that's no good
11:17:42 <ray> who do i complain to?
11:18:53 <fracture> is there a set-style difference function for lists?
11:19:12 <copumpkin> \\ ?
11:19:23 <byorgey> > [1,2,3,4,5] \\ [3,5]
11:19:25 <lambdabot>   [1,2,4]
11:19:29 <byorgey> but note:
11:19:37 <byorgey> > [1,1,1,1] \\ [1,1]
11:19:38 <lambdabot>   [1,1]
11:19:39 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:\\
11:19:58 <fracture> ah, thanks
11:20:00 <Zao> It's only setlike if your list is setlike.
11:24:54 <mib_bgbyadx7> hi
11:30:28 <McManiaC> @src signum :: Int
11:30:29 <lambdabot> Source not found.
11:30:42 <McManiaC> what is signum?
11:30:58 <kpreid> @help src
11:30:58 <Baughn> > signum 3
11:30:58 <lambdabot> src <id>. Display the implementation of a standard function
11:30:59 <lambdabot>   1
11:31:03 <Baughn> > signum (-3)
11:31:04 <lambdabot>   -1
11:31:05 <kpreid> @src signum Int
11:31:06 <lambdabot> Source not found. Take a stress pill and think things over.
11:31:09 <kpreid> @src Int signum
11:31:09 <lambdabot> Source not found. Do you think like you type?
11:31:10 <Baughn> > signum 0
11:31:10 <McManiaC> ah okay
11:31:11 <lambdabot>   0
11:31:14 <kpreid> I thought there was a way to do it...
11:31:18 <copumpkin> @src signum
11:31:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:31:21 <Baughn> @src Num Int
11:31:22 <lambdabot> Source not found. You type like i drive.
11:31:23 <copumpkin> I guess it doesn't have it :)
11:31:28 <kpreid> McManiaC: http://en.wikipedia.org/wiki/Sign_function
11:31:29 <Baughn> There is, and that's the way. Except..
11:31:30 <Cale> It's often written  sgn  in mathematics.
11:31:55 <davidL> > map signum [-5,-4..5]
11:31:56 <lambdabot>   [-1,-1,-1,-1,-1,0,1,1,1,1,1]
11:32:46 <kpreid> hmm
11:32:49 <kpreid> > ""
11:32:50 <lambdabot>   "\8226"
11:32:59 <kpreid> @. read run ""
11:33:01 <lambdabot>  "
11:33:13 <kpreid> is there a way to get lambdabot to emit unicode?
11:33:28 <skorpan> > 
11:33:29 <lambdabot>   Not in scope: `'
11:33:37 <skorpan> > let x =  in x
11:33:37 <kpreid> I mean, as computed by a program
11:33:38 <lambdabot>   Not in scope: `'
11:33:45 <skorpan> > let x =  :: Expr in x
11:33:47 <lambdabot>   Not in scope: `'
11:33:51 <skorpan> dunno
11:34:03 <skorpan> > let x = "" :: Expr in x
11:34:03 <kpreid> @. read run "test"
11:34:04 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
11:34:05 <lambdabot>  test
11:34:06 <skorpan> > let x = "" in x
11:34:07 <lambdabot>   "\8501"
11:34:14 <kpreid> @. read run "tst"
11:34:15 <lambdabot>  tst
11:34:20 <kpreid> ew, latin1
11:35:59 <cayennext> How to put \ (ASCII lambda) into string? I am trying to write a parser for a language with lambdas and having \ symbol would be nice.
11:36:08 <kpreid> "\\"
11:36:21 <cayennext> it's just "\\", not "\"
11:36:38 <kpreid> no, that's how you escape the backslash
11:36:41 <kpreid> > length "\\"
11:36:43 <lambdabot>   1
11:36:57 <cayennext> and not only in repl, also while parsing "\\" doesn't work
11:37:05 <kpreid> then you're doing something else wrong
11:37:50 <ray> > '\\'
11:37:51 <lambdabot>   '\\'
11:37:56 <ray> see, it's a single character
11:38:26 <cayennext> okay, so I have something else scewd up
11:40:28 <cayennext> fixed. I tested parser in repl too: "\ x -> x + x", I should have used: "\\ x -> x + x"
11:53:43 <Phyx-> Good evening, Quick question, if i have a class class La m a where make :: m a
11:53:44 <Phyx-> "
11:53:59 <Phyx-> how would one go about making an implementation for say Int
11:54:16 <copumpkin> Int and what?
11:54:26 <EvilTerran> Phyx-, er, that class has two parameters, you can't make an instance for just Int
11:54:48 <Phyx-> i thought the same
11:54:52 <Phyx-> but
11:55:00 <Phyx-> hm
11:55:19 <Phyx-> Oic
11:55:27 <Phyx-> stupid question
11:55:34 <Phyx-> pardon my lack of caffeine
11:59:02 <hackagebot> random-fu 0.0.2.0
12:01:27 <ksf> can anyone provide me with links about turing-completeness wrt. frp?
12:02:17 <Baughn> ksf: FRP? Reactive programming?
12:02:37 <ksf> yeah
12:02:43 <pejo> ksf, can't you make a singal function that is a loop to itself, thereby giving non-termination?
12:03:14 <Baughn> ksf: I suppose you should ask conal, but.. turing-completeness? Seriously?
12:03:28 <Baughn> pejo: That's not turing-completeness, though. ^^;
12:03:28 <Zao> Aren't there latching and whatnot to avoid looping circuits?
12:04:17 <Baughn> ksf: Considering accumE and whatnot, it wouldn't be very hard at all
12:05:10 <ksf> well, ooh you want feedback loops as they make sense, otoh, turing completeness sucks if you're serving content to people who don't trust you, or choose not to.
12:06:27 <pejo> ksf, there's a paper by Sculthorpe and Nilsson for ICFP this year about using Agda for some safety properties.
12:06:38 <ksf> "non-terminating xml' makes me shudder.
12:07:30 <te> so do your quotes
12:09:05 <Cale> ksf: Who you don't trust, rather.
12:09:35 <Cale> Or, you mean your viewers will be unhappy if one of your programs runs forever?
12:10:12 <ksf> I've spend the day looking into web technologies, thinking about guis, but the only reasonable thing that i found is laszlo, and even they don't use their frp stuff for most of the coding.
12:10:32 <ksf> Cale, I don't trust myself, by default, so it's fine.
12:12:25 <ksf> running forever isn't the problem, user input is codata.
12:13:41 <Cale> ksf: There's an interesting FRP language designed to be compiled to Javascript called Flapjax.
12:14:59 <Cale> ksf: I'm not sure exactly how practical it is, or if anyone is actually using it, but it seems to work.
12:16:06 <ksf> Nah, I just mentioned web 'cos most of the stuff there is declerative, not because I'm particularly focused on web or want to run stuff inside a browser. It's more like guaranteeing well-behavedness of your desktop.
12:16:28 <ksf> ...as experience goes, firefox can make focus switches loop endlessly.
12:19:47 <hatds> http://www.haskell.org/haskellwiki/Data_declaration_with_constraint is mistaken?
12:20:06 <hatds> data Foo a = Class a => Foo a will bake the class constraint into the type
12:20:25 <mauke> is that even valid?
12:20:30 <copumpkin> I didn't think so
12:20:39 <hatds> yes, it is valid
12:20:44 <hatds> at least on my ghc :)
12:20:50 <mauke> not in H98
12:21:24 <Ferdirand> but it will propagate the type constraint everywhere you use it, not make it implicit, iirc
12:21:25 <copumpkin> it seems odd, that would imply only having the constraint on one constructor (if you had more than one)?
12:21:37 <Saizan_> in ghc it's similar to an existential type, since the typeclass dictionary will be stored in the constructor
12:21:53 <hatds> Ferdirand: no, it will only propagate the constraint to constructors, not functions involving Foo
12:21:54 <mauke> copumpkin: that's what it does
12:21:54 <Saizan_> Ferdirand: it'll be implicit with that form
12:22:07 <Ferdirand> oh ? nice
12:22:29 <hatds> yes, I think you have to enable existentials, but note that 'a' is visibile, not existentially qualified
12:22:31 <Cale> You can put class constraints on data declarations in H98, but they don't do much. They only restrict the data constructor's type. The typing rule for case/pattern matching doesn't change.
12:22:37 <ksf> pejo, thanks, that's exactly the kind of stuff I was looking for
12:22:53 <Saizan_> i.e. "data Foo a = Show a => Foo a; foo :: Foo a -> String; foo (Foo a) = show a" will typecheck.
12:22:55 <Cale> So there's essentially no point in doing so.
12:23:01 <hatds> Cale: It is different than Class a => data Foo a = Foo a
12:23:12 <Baughn> @tell conal You should rename makeClock to getClock, or otherwise make it clear that you get the same clock every time
12:23:13 <lambdabot> Consider it noted.
12:23:26 <Cale> What?
12:23:36 <Cale> hatds: That isn't valid syntax...
12:23:47 <hatds> Cale: it is on my ghc
12:23:51 <mauke> hatds: no
12:23:55 <Cale> uhhh...
12:23:58 <Saizan_> "data Class a => Foo a = Foo a"
12:24:02 <hatds> no
12:24:03 <Saizan_> you mean, right?
12:24:03 <pejo> ksf, I think the code is available on some webpage.
12:24:08 <hatds> "Class a => data Foo a = Foo a"
12:24:14 <hatds> that's the H98 way
12:24:18 <mauke> hatds: no
12:24:19 <Cale> no, it isn't.
12:24:26 <te> cant wait to get the haskell school of expression
12:24:31 <hatds> the other way is: "data Foo a = Class a => Foo a"
12:24:37 <mauke> hatds: HELLO
12:24:41 <Cale> That is also invalid.
12:24:52 <te> Anyone else here read the Haskell School of Expression?
12:24:54 <Cale> Have you tried either of those?
12:24:58 <hatds> lemme check my source file where I did this
12:25:29 <roconnor> data (Class a) => Foo = Foo a -- This is legal, but doesn't do what you wish it to.
12:25:38 <mauke> hatds: you could just look at the wiki page
12:25:47 <roconnor> data (Class a) => Foo a = Foo a -- This is legal, but doesn't do what you wish it to.
12:25:57 <hatds> roconnor: that's not what I said :)
12:26:02 <hatds> one sec, found it
12:26:14 <Cale> In recent versions of GHC, you can use the GADT syntax to restrict the data constructor's type, and when you do that it really does change the typing rule for pattern matching
12:26:21 <Cale> data Foo a where
12:26:31 <Cale>   Foo :: (Class a) => a -> Foo a
12:27:05 <Saizan_> and data Foo a = Class a => Foo a is the same without gadt syntax
12:27:10 <Cale> This will indeed store a class dictionary for Class along with every Foo value.
12:27:19 <Saizan_> i've never seen the form with Class a => at the start, though
12:27:27 <hatds> @where hpaste
12:27:27 <lambdabot> http://hpaste.org/
12:27:41 <povman> If I'm writing a C library, I can declare a symbol as external and get the library user to implement it - is there a haskell version of external?
12:27:51 <Cale> Saizan_: errr... are you sure that's valid?
12:28:00 <Cale> Saizan_: If it is, I'm pretty sure it needs extensions
12:28:15 <mmorrow> Baughn: woo isEvaluated :)
12:28:40 <hatds> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5322#a5322
12:28:40 <Cale> Yeah, it works with ExistentialQuantification or GADTs turned on
12:28:50 <mauke> povman: AFAIK no
12:28:54 <Saizan_> Cale: it's an extension to h98, not sure if it needs a flag, we opened a ticket for it some time ago
12:28:57 <hatds> yea, GADTs is turned on
12:29:21 <Cale> hatds: I don't see any of the syntax you were proposing though...
12:29:46 <hatds> lines 30 vs 31
12:29:47 <Saizan_> hatds: right, you have "data Class a => Type a = .." not "Class a => data Type a = .."
12:29:53 <povman> mauke: :'( thanks, sob
12:30:06 <mle> povman: there may be a better approach, depending on what you are trying to do?
12:30:12 <Baughn> mmorrow: Now, if only hello, world wasn't 26MB. :)
12:30:30 <povman> mle: I'm trying to write a nice wrapper around libsdl's stupidity
12:30:31 <mmorrow> Baughn: if you're into it you might find it interesting to mess around with vacuumLazy. currently (i've only tested in ghci so far) THUNKs don't seem to ever be updated (although this might be ghci reverting CAFs??), and if you follow any of the ptrs in a THUNK a swift segfault awaits :/
12:30:42 <mmorrow> Baughn: :o
12:30:52 <Saizan_> hatds: i.e. in no place you've the class right at the start like you said some lines ago
12:30:52 <byorgey> povman: you could make a type class with no instances.
12:31:06 <mmorrow> Baughn: i did a test of a (trivial helloWorld) and it was around 7MB (unstripped)
12:31:07 <byorgey> and then write functions polymorphic over that type class.
12:31:12 <hatds> Saizan:  does that work?  If you have   __ data Foo a = ___ Foo a  I've only tried putting the class constraint in the underscores (the latter requiring GADTs it seems)
12:31:19 <nopsledX> Newbie problem: Getting "Non type-variable argument in the constraint: Data () (Use -XFlexibleContexts to permit this) ... when loading a program with ghci
12:31:28 <mle> povman: well, what sort of thing would you normally be referencing with extern?
12:31:39 <Cale> hatds: data always has to come at the start of a declaration
12:31:48 <Cale> hatds: You can never put something before it.
12:31:54 <hatds> I hpasted and it works on my ghc :/
12:31:55 <Baughn> mmorrow: Yes.. hmm, mine shrank too. I wond.. ah, it's because I didn't rebuild reactive earlier. It was still pulling in ghc.
12:32:10 <byorgey> nopsledX: can you paste the code somewhere (e.g. hpaste.org)?
12:32:16 <Cale> hatds: There's nothing in your file which looks like (Class a) => data ...
12:32:36 <povman> mle: I want to define main in the library, and make users of the library define sdlMain which is called by that
12:32:36 <mmorrow> Baughn: phew, you scared me for a second there
12:32:40 <Saizan_> hatds: (1) data (2) Foo a = (3) Foo a, in your paste you have the class constraint in (2) and (3) and indeed both are valid syntax with extensions, but in no place you've the constraint on (1) and in fact it doesn't parse
12:32:43 <hatds> Cale: ah right
12:32:53 <povman> byorgey: Hello, what did you mean by that?
12:33:03 <hatds> Cale: sorry, I was misrecalling the "useless" way
12:33:17 <mle> povman: OpenGL has a different example of that, I think... and even networking on windows has initialization details
12:33:21 <Saizan_> you weren't reading what we were writing :P
12:33:24 <roconnor> @bab en nl France
12:33:25 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
12:33:37 <povman> mle: but libSDL on mac and windows defines its own main()
12:33:38 <Cale> But even so, the data Foo a = Class a => Foo a  syntax is strange. If you're going to do that, use the GADT syntax.
12:33:43 <mle> povman: why not just make a withSDL :: IO () -> IO () ... oh
12:33:47 <mle> povman: madness!
12:33:57 <byorgey> povman: actually, on second thought, maybe that wouldn't work
12:33:58 <povman> it's ridiculous
12:34:08 <Cale> (In fact, I prefer the GADT syntax for all existentials)
12:34:10 <mle> povman: fork and patch!
12:34:14 <povman> I want to cry and then yell at the libsdl maintainers
12:34:25 <hatds> Cale: It only bakes in the class constraint without hiding 'a', so yes it doesn't buy you much
12:34:32 <byorgey> a library which defines main() is pretty whack
12:34:39 <Cale> hatds: No, that one works.
12:34:52 <hatds> Cale: what one?
12:34:54 <Cale> data Foo a = Class a => Foo a
12:35:05 <hatds> yes
12:35:12 <hatds> that's the one I was referring to
12:35:12 <povman> byorgey: Out of curiosity... what did you mean by the typeclass thing?
12:35:36 <Cale> That one will store a dictionary for Class along with each value, which will be unpacked and used when pattern matching.
12:35:43 <byorgey> povman: I meant, you could make a typeclass with (say) a single method, representing the function you wanted users of the library to implement
12:35:46 <hatds> that's what I've been saying
12:35:48 <hatds> :(
12:36:07 <Cale> it's the  data Class a => Foo a = Foo a  one which is Haskell 98, and it's useless.
12:36:17 <mmorrow> byorgey: like class Main a where main :: IO a -- ???
12:36:18 <hatds> yes, as I've been saying
12:36:23 <mmorrow> ::)
12:36:25 <Cale> (sort of)
12:36:27 <hatds> I just misrecalled the syntax for the useless/H98 one
12:36:32 <byorgey> something like that
12:36:47 <byorgey> I no longer think this would actually help, but that's what I meant =)
12:37:04 <Cale> But I would never write  data Foo a = Class a => Foo a  anyway. If you're going to use GADTs, you might as well use the GADT syntax :)
12:37:12 <mmorrow> i wonder if ghc would disapprove of a Main class...
12:37:27 <Cale> data Foo a where Foo :: Class a => a -> Foo a
12:38:18 <hatds> that's the same thing
12:38:23 <hatds> ?
12:38:43 <Cale> yeah
12:39:09 <Muzzleflash> Is there a way to run a :cd command on ghci startup? It's getting pretty tiresome to do it on every start.
12:39:25 <Muzzleflash> I've tried looking for the .ghci file, however I can't find it
12:39:26 <Cale> Muzzleflash: add it to your .ghci
12:39:29 <mauke> put it in ~/.ghci
12:39:32 <Cale> Create one then.
12:40:02 <Muzzleflash> In ghc-x.xx.x folder right? or bin?
12:40:10 <mmorrow> touch ~/.ghci
12:40:14 <Cale> In your home directory.
12:40:24 <Cale> Uh, on windows, I'm not sure what that is.
12:40:30 <Muzzleflash> Vista 64 bit
12:40:42 * Cale has not used windows since Win 98.
12:41:03 <te> i have, to play left for dead and use a keygen
12:41:08 <te> other than that, no
12:41:40 <Peaker> Windows homedir I think is (Documents And Settings/<user name>) or perhaps another /Application Data   sometimes
12:41:53 <Cale> Hmm...
12:41:58 <p_l> Homedir on windows depends on the user
12:42:07 <te> "Documents and Settings"
12:42:10 * Cale looks in the GHC User's Guide
12:42:12 <te> how terrible is that description
12:42:36 <p_l> default on NT5.x is <systemdisk>:\Documents and Settings\<username>
12:42:36 <Cale> #
12:42:36 <Cale> appdata/ghc/ghci.conf, where appdata depends on your system, but is usually something like C:/Documents and Settings/user/Application Data
12:43:24 <p_l> on NT <5 the default is <systemdisk>:\<systemdir>\profiles\<username>
12:43:35 <Muzzleflash> I've checked there, just assumed ghc made a folder thre
12:43:40 <p_l> On NT6.x it's <Systemdisk>:\Users\<username>
12:43:40 <Saizan_> you can use the system variable %AppData% to tell.
12:44:24 <Saizan_> 6 is vista?
12:45:15 <Muzzleflash> Okay. It works using: %AppData%\ghc\ghci.conf
12:45:21 <Muzzleflash> The folder had to be created
12:45:47 <Muzzleflash> On Vista %appdata% is: C:\Users\THE_USERNAME\AppData\Roaming
12:46:01 <Muzzleflash> thanks for the help
12:47:13 * Baughn strives to create the longest import list known to man
12:50:11 <Peaker> Baughn: how's the unamb stuff going?
12:51:09 <Botje> Baughn: we totally need a "KitchenSink" meta-pacakge
12:51:17 <Botje> that just includes every library on hackage
12:51:38 <mmorrow> hehe
12:51:40 <mmorrow> ghci> closureType CONSTR_NOCAF_STATIC
12:51:40 <mmorrow> CONSTR_NOCAF_STATIC
12:52:24 <RayNbow> hmm, SPJ has posted something on a new TH feature
12:52:31 <RayNbow> *on -> about
12:52:40 <mmorrow> ooh
12:52:44 <Saizan_> link?
12:52:57 <RayNbow>  http://www.haskell.org/pipermail/haskell-cafe/2009-May/061989.html
12:53:34 <GrayShade> did anyone recently fix a bug in ghci on windows 7 and, maybe, vista?
12:54:05 <GrayShade> nevermind, I'll download a snapshot
12:54:28 <Botje> SPJ should create a twitter account
12:54:39 <mmorrow> holy crap, type splices!
12:54:40 <Botje> "woke up today. had breakfast. revolutionarized functional programming"
12:55:14 <pejo> Botje, the big names are really much more down to earth than that.
12:57:28 <Baughn> Peaker: Okay, that's /one/ reactive bug down. Just needed a finalizer..
12:57:50 <Peaker> Baughn: so you submitted it all to conal's cabalization? :)
12:57:57 <Cale> Sometimes I've thought it would be cool if SPJ was on IRC, but it's probably for the best that he isn't. :)
12:58:16 <patogen> Where do I find info on how to use matrices in haskell?
12:58:36 <Peaker> I wonder if SPJ will mind if I use his slides "Taste of Haskell"
12:58:41 <Cale> patogen: There are some matrix libraries like hmatrix which are reasonably well-documented.
12:59:00 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
12:59:33 <patogen> Cale: thank you
12:59:48 <Baughn> Peaker: I'll make sure it works first. :)
13:00:01 <RayNbow> Botje: go convince SPJ... right now! :p
13:00:24 <Peaker> Baughn: don't make sure it works forever :)
13:01:14 <Baughn> Peaker: Heh. Actually, my current headache is Never.
13:01:41 <Peaker> Baughn: I mean -- your current version is already better than existing unamb -- just release it, and if you improve it further, release again
13:01:52 <Baughn> Peaker: Oh, I've handed Conal the code for unamb
13:02:06 <Baughn> And released isEvaluated as a separate package
13:02:17 <Baughn> I'm not about to release an update of Unamb, though. :P
13:02:52 <Baughn> @index finalizer
13:02:52 <lambdabot> bzzt
13:02:57 <Baughn> @hoogle finalizer
13:02:57 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
13:02:57 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
13:02:57 <lambdabot> Foreign.ForeignPtr type FinalizerPtr a = FunPtr (Ptr a -> IO ())
13:03:16 <Cale> What would be really funny is if we found out that BONUS was SPJ's alter-ego.
13:03:42 <RayNbow> :D
13:04:03 <Baughn> "addFinalizer :: key -> IO () -> IO ()" <-- Yay!
13:04:21 <RayNbow> @check SPJ == BONUS
13:04:22 <lambdabot>   Not in scope: data constructor `SPJ'Not in scope: data constructor `BONUS'
13:04:27 <RayNbow> aww...
13:04:29 <malosh> Hi. I'm confused about how the FFI was intended to be used, especially with marshalling : if I want to marshal a record to a C struct back and forth, do I really have to realloc my C struct each time I want to call a C function on my record type ?
13:04:53 <mauke> what do you mean by "realloc"?
13:05:09 <wunki> i'm getting this error when trying to install GHC in freebsd: http://haskell.pastebin.com/m4a7103d . Can someone point me in some direction?
13:05:10 <malosh> alloca (\ptr->poke etc.)
13:05:38 <mauke> well, you can also not use alloca and store the pointer somewhere
13:06:03 <malosh> Anything else I've tried seem to make the garbage collector an enemy
13:06:08 <Zooix> Hi all
13:06:20 <eivuokko> malosh, Huh?  What did you try?
13:06:28 <malosh> my question was more about what good c binders usually do
13:06:50 <malosh> eivuokko : putting a foreignptr as a field
13:06:52 <mauke> I'd allocate a new pointer each time
13:06:53 <malosh> for instance
13:06:57 <eivuokko> malosh, alloca is fine pretty often, caching serialised structures isn't that much of a win usually.
13:06:59 <Coko|Raptor> Can someone help me work out what I am doing wrong. I am trying to take a tree that either has a value, or a value with two trees. Then I need a function to find the minimum value in the tree
13:07:03 <Coko|Raptor> i did the following
13:07:05 <Coko|Raptor> data Tree = Node Int (Tree) (Tree) | Leaf Int
13:07:05 <Coko|Raptor> minimum :: Tree -> Int
13:07:05 <Coko|Raptor> minimum Node x left right = min x min (minimum (left) minimum (right))
13:07:05 <Coko|Raptor> minimum Leaf x = x
13:07:16 <eivuokko> malosh, What do you mean "a field"?
13:07:18 <Zooix> I've a problem on this code : http://pastebin.com/d75fc95f4
13:07:22 <malosh> of the record
13:07:25 <Coko|Raptor> it moans at me though :s
13:07:26 <eivuokko> malosh, Ah.
13:07:28 <kpreid> Coko|Raptor: your problem is "min x min", this isn't Logo :)
13:07:32 <mauke> Coko|Raptor: missing parens
13:07:35 <kpreid> Coko|Raptor: min x (min ...)
13:07:35 <Coko|Raptor> ok
13:07:43 <Botje> Zooix: what error are you getting?
13:07:53 <malosh> cause I like the syntax defaultRecord {field=value, otherOne=otherValue}
13:08:00 <Zooix> No sorry wait a second
13:08:06 <Zooix> I think it's an indentation error
13:08:22 <malosh> mauke, eivuokko : thanks
13:08:47 <eivuokko> malosh, Hmm.  Well, it's hard to give generic advice what do with c structures that refer to other c structures via pointers.  It varies a lot.
13:08:47 <Botje> Zooix: a possibility. Try to avoid mixing tabs and spaces in haskell code or even avoid tabs outright
13:09:03 <Zooix> yes I know, I don't use them ;) but thnaks
13:09:05 <Coko|Raptor> kpreid: changed to min x (min minimum(left) minimum(right)) but it is still complaining :S
13:09:15 <kpreid> you can't use parens like that
13:09:26 <Coko|Raptor> ok
13:09:30 <kpreid> that's applying min to minimum, eft, minimum, right
13:09:35 <Coko|Raptor> oh ok
13:09:42 <kpreid> min x (min (minimum left) (minimum right))
13:10:41 <Zooix> On this code, I've a parse error at line 10
13:10:41 <Zooix> http://pastebin.com/d41b6987d
13:11:19 <mauke> Zooix: needs more indentation
13:11:31 <Botje> at least past the case
13:11:34 <kpreid> It does?
13:11:35 <Zooix> Sorry I'm bad in English
13:11:38 <Coko|Raptor> kpreid: Equation gives different arities for "minimum"
13:11:38 <Coko|Raptor> :s
13:11:44 <Zooix> does it means that I've to add more spaces ?
13:11:48 <Cale> yeah
13:11:50 <Botje> yes
13:11:53 <Zooix> ok thanks
13:11:58 <Botje> the '+' has to come past the case
13:11:58 <kpreid> Coko|Raptor: Oh. minimum (Node x left right) = ... and so on
13:12:03 <Cale> The problem is that the '+' lines up with the other lines in the 'where', so it's a new line in the 'where' clause
13:12:17 <kpreid> Coko|Raptor: it's the same rule: to apply something inside of an arg you have to put parens around it
13:12:17 <Botje> Zooix: also, you can put the parse input (op a b : stack) on a new line
13:12:18 <mauke> Botje: no
13:12:26 <Botje> that way you don't need outrageous amounts of indentation :)
13:12:37 <mauke> Botje: the '+' just has to be more indented than 'op'
13:12:46 <Botje> ah.
13:12:53 <Zooix> Thanks it works
13:12:53 <kpreid> Coko|Raptor: In Haskell, a b c = (a b) c, not a (b c)
13:13:00 <Zooix> I've just another problem
13:13:01 <mauke> which is easily done by moving the 'where' all the way left
13:13:03 <Cale> The 'where' is part of the 'parseOp' and not the expression 'parse input ...', so it doesn't need to be indented so much
13:13:07 <Zooix> CHar.ord is not in scope
13:13:09 <Coko|Raptor> oh ok
13:13:26 <mauke> Zooix: import Data.Char (and remove the "Char." part)
13:13:59 <Zooix> Omg, I've forgotten it :s
13:14:11 <Baughn> In a weak-reference finalizer, can I use the key of the reference? How about the value?
13:14:41 <Coko|Raptor> kpreid: another problem :S Ambiguous variable occurrence "minimum"
13:15:12 <Zooix> Still a proble with "convertToInt x = ord x - ord "0" "
13:15:16 <mauke> Coko|Raptor: yeah, we already have a function called "minimum"
13:15:23 <Coko|Raptor> mauke: ah! :)
13:15:29 <mauke> Zooix: you want '0', not "0"
13:15:35 <kpreid> @src minimum
13:15:35 <lambdabot> minimum [] = undefined
13:15:35 <lambdabot> minimum xs = foldl1 min xs
13:15:37 <kpreid> @where minimum
13:15:38 <lambdabot> I know nothing about minimum.
13:15:46 <Twey> > minimum []
13:15:46 <mauke> actually, we have that function too
13:15:47 <lambdabot>   * Exception: Prelude.minimum: empty list
13:15:52 <Twey> Lies
13:15:57 <mauke> > digitToInt '0'
13:15:58 <lambdabot>   0
13:16:02 <mauke> > digitToInt '9'
13:16:03 <lambdabot>   9
13:16:48 <Zooix> thank tou very much guys
13:16:59 <Zooix> you*
13:17:01 <Zooix> bye
13:17:35 <mauke> parseNumber input stack = case reads input of [(n, xs)] -> parse xs (n : stack); _ -> parse input stack
13:17:42 <mauke> enjoy your infinite loops
13:32:25 <Peaker> Hmm.. We have Data.Binary.Get for nice binary deserialization of byte strings -- what do we have around reads/et al?
13:32:31 <Peaker> only parsec?
13:33:04 <Peaker> reads is ambiguous - so I guess an undeterministic parser like parsec is needed :(
13:34:18 <kniu> What, exactly, are functors?
13:34:35 <kniu> I hear them mentioned all over the place, and yet I still have no clue.
13:34:36 <seliopou> BOOM loaded question
13:34:43 <seliopou> in the context of Haskell?
13:34:47 <kniu> sure
13:34:57 <seliopou> Do you know what a type class is?
13:35:05 <kniu> yeah
13:35:37 <kpreid> @src Functor
13:35:37 <lambdabot> class  Functor f  where
13:35:37 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:35:43 <seliopou> Functor's just a type class for type constructors that you can "map" over
13:36:01 <kpreid> that's every functor
13:36:06 <kpreid> > fmap (+1) [1,2,3]
13:36:07 <lambdabot>   [2,3,4]
13:36:09 <seliopou> so for instance "List" ([]) is a Functor, and fmap = map
13:36:10 <kpreid> > fmap (+1) (Just 99)
13:36:11 <lambdabot>   Just 100
13:36:43 <kniu> huh
13:36:47 <seliopou> get it?
13:36:48 <kniu> I get it now.
13:37:25 <marcot> Hello, is there a getArgs function that returns ByteString?
13:37:42 <byorgey> @seen dmwit
13:37:43 <lambdabot> dmwit is in #xmonad, #haskell-in-depth and #haskell. I last heard dmwit speak 9m 55s ago.
13:37:51 <Jedai> marcot: fmap (map pack) getArgs
13:37:55 <Twey> marcot: If your args are big enough to require it, they shouldn't be args
13:38:16 <Jedai> marcot: given the average size of args, you don't need ByteString for them
13:38:21 <marcot> Ok, the problem is not about performance, is just about importing both ByteString and String functions.
13:38:28 <marcot> I'd prefer to import Prelude hiding (...)
13:38:47 <marcot> But this was a good answer to my question.
13:38:59 <Twey> You can, as Jedai said, just use pack
13:39:10 <Peaker> conal: no idea about the QuickCheck stuff -- I guess it just needs to be researched what happened to that QC functionality more carefully
13:39:25 <conal> Peaker: ok.  thx.
13:39:25 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:39:31 <Twey> import qualified Prelude; import Prelude hiding (getArgs); getArgs = fmap (fmap pack) Prelude.getArgs
13:40:28 <Jedai> Twey: getArgs is not in the Prelude
13:40:48 <Twey> So it isn't
13:40:53 <Twey> System, then
13:41:03 <conal> Baughn: is your tweaked Unamb all in one place now?  i can play with it and push a new version.
13:41:13 <conal> (to hackage)
13:42:01 <Baughn> conal: Hm? Yes, the last version I gave you should be fine
13:42:10 <Baughn> conal: Eh, I'll paste a new just to be sure.
13:42:30 <conal> Baughn: thx.
13:42:33 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5323#a5323
13:42:36 <conal> :)
13:43:04 <Baughn> conal: I've commented out isEvaluated. It'd probably be safe to leave those in, but I'm leery of doing so without thorough testing - it's another thing that can go wrong.
13:43:16 <conal> Baughn: sure.
13:43:35 <Baughn> conal: So the plan is to fix reactive (working on makeEvent at the moment), get some neat programs written, and /then/ turn it on for the performance boost and testing
13:43:38 <vininim> we can't lift here, this is ap country.
13:43:54 <Baughn> vininim: Ah, but applicative is a subclass of functor
13:43:59 <conal> Baughn: sounds great to me
13:44:54 <vininim> Baughn: fear and loathing in las vegas reference. =P
13:45:55 <Baughn> conal: Considering that event sources may /end/, I can't use listSink. Will any other function work to lazily create events? atTimes, perhaps?
13:46:15 <mmorrow> vininim: :)
13:46:42 <Baughn> conal: (I'm sticking a finalizer on the sink, and additionally intend to add an explicit makeEvent-killing function people can use
13:47:42 <conal> Baughn: can't use listSink?
13:47:56 <conal> Baughn: glad to hear that you're thinking about finalizers.
13:48:17 <siki> Hi! Quick question from a noob: if I have a function that is in the IO monad, e.g. foo :: IO (Int) and a type, e.g. type Blah = Blah Int how do I make this work? foo >>= Blah
13:48:18 <siki> ?
13:52:32 --- mode: irc.freenode.net set +o ChanServ
13:54:42 <siki> jmcarthur_work: yes it does....I'm just diggesting it :)
13:55:06 <siki> jmcarthur_work: thanks for the help btw
13:55:18 <chr1s> conal: ping
13:55:34 <conal> chr1s: hi
13:56:16 <chr1s> conal: so what kind of things do you want to generate for the iPhone?
13:56:33 <hackagebot> explicit-sharing 0.3.1.1
13:56:34 <chr1s> graphical stuff? that should be easy, coregraphics is all low-level c-code.
13:56:43 <conal> chr1s: graphics toys, via glsl
13:57:09 <chr1s> right
13:57:10 <conal> chr1s: i understand glsl will be available on iphone 3.0, though not before
13:57:24 <conal> chr1s: i hope i'm right about that bit.
13:57:50 <dancor_> trifling style question: http://dzl.no-ip.org/lol/if.hs
13:57:53 <chr1s> conal: I don't know too much about that, but I do know OpenGL is available, that's a start.
13:58:37 <conal> chr1s: yeah.  apparently, iphone 2.x has opengl-es *without* programmable shaders, but iphone 3.0 has with.
13:58:46 <chr1s> conal: you should also take a look at sebastiaan visser's FRP-DSL for javascript.
13:58:49 <sjanssen> dancor_: I prefer the second
13:58:52 <Beelsebob> dancor: the latter
13:58:52 <dancor_> ok
13:59:04 <chr1s> conal: shouldn't be too hard to use something similar for objective-c
13:59:17 <glguy> dancor, I'd prefer guards in that case over if then else
13:59:17 <chr1s> err, c.
13:59:39 <dancor_> mm
13:59:54 <conal> chr1s: i think so also, though the graphics stuff will be very different, as it's glsl.  i already have that piece working, though the CSE is too slow as is.
14:00:06 <chr1s> conal: ah, nice!
14:00:16 <conal> hence the discussion about CSE and "deep" DSELs on haskell-cafe.
14:00:57 <conal> chr1s: yeah.  the generated code for 2D & 3D graphics is insanely fast on my 2+ year-old laptop.
14:01:37 <conal> chr1s: and a genuinely functional interface (no IOish stuff), including continuous space & time.
14:01:49 * sjanssen prefers print . (:"ay") . ("ny" !!) . fromEnum
14:01:55 <chr1s> conal: nice.
14:02:09 <chr1s> conal: when will we see a demo? :)
14:02:10 <conal> and per-pixel automatically generated exact surface normals.
14:03:02 <chr1s> conal: so what kind of interface do you have? is it monadic? arrow-like?
14:03:05 <conal> chr1s: i'm puzzling over how to release it.  i think it'll be my core technology for some commercial efforts.
14:03:31 <conal> chr1s: images and 3D surfaces are functions of continuous infinite 2D space.
14:03:47 <conal> chr1s: exactly as in Pan and Vertigo
14:03:48 <dancor_> dual license
14:04:08 <chr1s> conal: I haven't looked too much into that, I'll do that later.
14:04:29 <conal> does anyone know of a non-commercial software license to emulate?
14:04:39 <chr1s> conal: also, you should use it commercially. we need more (commercial) visibility for Haskell.
14:04:54 <conal> chr1s: thx! :)
14:05:03 <inimino> non-commercial license?
14:05:21 * sjanssen thinks non-commercial open source licenses are lame
14:05:32 * conal too
14:05:45 <conal> and other licenses also
14:05:50 <sjanssen> you're free to add value to the product, but not free to make money from it
14:05:53 <Cale> Why not just BSD everything?
14:06:10 <inimino> yes, BSD or MIT licenses are good
14:06:30 <conal> BSD & MIT are good for whom/what?  and bad for whom/what?
14:06:36 <hackagebot> explicit-sharing 0.3.1.2
14:06:46 <smtms> good for everybody; bad for Stallman :-P
14:06:58 <Cale> They're basically the same as putting the thing into the public domain, except with a disclaimer.
14:07:03 <inimino> they are actually open-source, free software licenses
14:07:05 <inimino> good for everybody including Stallman
14:07:07 <Cale> More or less.
14:07:16 <sjanssen> conal: BSD means anyone can modify and use, but they aren't forced to share their modifications
14:07:28 <sjanssen> ie. no "copyleft" as in the GPL
14:07:31 <p_l> Cale: And the old one requiring acknowledgement
14:07:38 <Cale> GPL doesn't force people to share their modifications either though.
14:07:53 <Cale> It's only if you distribute binaries that you have to share the source along with it.
14:07:54 <smtms> it does, in the normal sense
14:07:54 <p_l> Cale: It does if they ever release it to anyone else
14:08:03 <inimino> a licence that forbids commercial use is not free/open-source either
14:08:15 <Cale> You're free to change and use your changes without contributing them.
14:08:15 <dancor_> it seems to me that any scenario should be fine with either: bsd3 or gpl+commercial-dual
14:08:15 <conal> sjanssen: yep.  bsd is what i've been doing so far.  i got soured on it.
14:08:23 <inimino> which isn't good for anybody
14:08:24 <Cale> conal: What's wrong with it?
14:08:29 <p_l> as long as you are doing in house, you can do whatever you want (unless license explicitly forbids it, which might be invalid in some countries)
14:08:39 <gwern> any gitit fans around? I'm working on a HCAR.tex
14:09:45 <Cale> p_l: right, there are some closed source licenses which prohibit reverse engineering even, though it's not clear the extent to which that's valid.
14:09:46 <dancor_> what's wrong is that conal can't survive on opensource dreams alone ;)
14:09:55 <conal> dancor_: :)
14:10:38 <FunctorSalad> does anyone understand what this package has to do with message passing style? :-( http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mps-2009.5.13
14:10:42 <gwern> @seen thoughtpolice  Lemmih
14:10:42 <lambdabot> thoughtpolice is in #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard thoughtpolice speak 2h 21m 12s ago.
14:10:50 <gwern> @seen  Lemmih
14:10:50 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 14h 24m 58s ago.
14:10:50 <FunctorSalad> (at the risk of looking stupid)
14:10:54 <conal> my goal is to be able to keep doing the functional stuff i like without having to get a conventional job.
14:11:22 <gwern> how do you make a small fortune using functional programming? (start with a large one)
14:11:30 <conal> gwern: hah!
14:11:37 <Peaker> conal: what about an academic framework?
14:11:44 <conal> Peaker: hm?
14:11:47 <gwern> conal: it's an old joke, but I felt it's appropriate for you :)
14:12:10 <conal> gwern: maybe so.  the market plunge helped also.
14:12:22 <FunctorSalad> rob something armed with a large lambda?
14:12:26 <Peaker> conal: you can get paid to research stuff as you will in many universities, no?
14:12:33 <Twey> FunctorSalad: *shakes head*
14:12:36 <Twey> I'm baffled
14:12:50 <Cale> "This guy helped me to become a millionaire. Of course, when I met him, I was a billionaire."
14:12:58 <FunctorSalad> Twey: I wasn't serious :-(
14:13:00 <conal> Peaker: do you mean chase grants?
14:13:32 <conal> all licenses are off the mark for what i'm looking for.  which is to enable & encourage people to play and pitch in.  and to reward everyone according to how their contribution is valued.
14:13:35 <Peaker> conal: not sure what's it called, it can be a professor's job title, sometimes you have to lecture students and stuff, sometimes you don't
14:13:59 <gwern> so how does one write a normal http link in TeX? I mean something along the lines of [foo](http://bar); all the HCAR examples I have seem to use bare links
14:14:18 <conal> gwern: hyperref package
14:14:20 <gwern> that is, they're all \url{} stuff
14:14:53 <jotik_> Hello! How do I fork n threads and wait for all of them to finish?
14:15:20 <FunctorSalad> Twey: or did you refer to my question about the mps package?
14:15:38 <Baughn> jotik_: forkIO . putMVar fin (); replicateM n takeMVar fin
14:15:41 <sjanssen> jotik_: the usual way is to create an MVar, have each thread write to it as they finish, then read that MVar as many times as there are threads
14:16:16 <jotik_> Baughn: care to explain that a bit?
14:16:26 <FunctorSalad> jotik_: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11
14:16:33 <FunctorSalad> (the "terminating the program" section)
14:16:37 <Baughn> jotik_: sjanssen just did. :)
14:16:57 <jotik_> FunctorSalad: I read that, but thats a lot of code.
14:17:06 <Baughn> conal: If the sink is GC'd, I cap the event; that's no issue. But if the program stops processing incoming events, I have to stop adding occurences to the Event somehow, or I have a memory leak.
14:17:07 <Twey> FunctorSalad: The MPS package
14:17:17 <Twey> It seems completely unrelated to MPS
14:17:24 <Twey> It even has a reimplementation of Data.Function.on
14:17:39 <FunctorSalad> ugh. the "better method" is the unsafePerformIO hack? =)
14:17:44 <conal> Baughn: yeah.  tricky.
14:17:48 <FunctorSalad> (in that haddock, still)
14:18:05 <conal> Baughn: if there are no more references to the event, then we can stop feeding it.
14:18:10 <Baughn> No
14:18:15 <conal> Baughn: since we know that no one will notice.
14:18:20 <Baughn> Hang on
14:18:23 <FunctorSalad> Twey: that's whay I thought too
14:18:26 <FunctorSalad> *what
14:18:26 <Baughn> conal: I can't add a finalizer to the Event, since the program can be working on it while its head is GC'd. The solution I'm currently leaning towards is to write to a bounded channel in the sink, and construct the Event using unsafeInterleaveIO to read from the channel
14:18:50 <conal> Baughn: i was working on that optimization a while back.  i forget what shape it's in.  the Channel abstraction was  a problem.
14:18:58 <Baughn> conal: Then adding parameters to makeEvent for the size of the channel, as well as whether it should block or discard events
14:19:00 <FunctorSalad> Twey: maybe they forgot to expose a module? :)
14:19:10 <conal> Baughn: yeah.  not to the event.  to the channel.
14:19:19 <FunctorSalad> or maybe that's what is meant by the "helpers" qualification in the synopsis.
14:19:30 <conal> Baughn: which i tried, but it's actually trickier, because the channel evaporates at the start, leaving its two representation halves.
14:19:57 <Baughn> conal: Well.. okay, that works
14:20:14 <Baughn> conal: I can use unsafeInterleaveIO again and explicitly touch the channel; then it won't evaporate
14:20:37 <conal> Baughn: the channel abstraction is kind of broken.  i was working on another.  then would pitch changing ghc's.
14:20:46 <FunctorSalad> related question, *is* there some message-passing-style support package? ;)
14:20:56 <Baughn> conal: Still. Hm, let me get this working first; it might be useful.
14:21:07 <conal> Baughn: might work.  i kept trying and failing.  finalization is fragile!
14:21:26 <Cale> FunctorSalad: There are a number of them...
14:21:28 <Baughn> conal: Fortunately, implementing isEvaluated taught me a lot about how GHC evaluates things. :P
14:21:31 <FunctorSalad> (I tried to write a directed graph of threads In The Type System, but it's a bit hard)
14:21:35 <conal> Baughn: ! :)
14:21:55 <Twey> FunctorSalad: Hum
14:22:01 <FunctorSalad> each with custom state type, of course ;)
14:22:20 <conal> Baughn: i don't think i'd be happy with having a fairly channel size.  arbitrary & hard to predict, especially as it interacts with laziness
14:22:26 <Cale> FunctorSalad: I'm guessing that Chan is much simpler than what you're looking for?
14:22:55 <Baughn> conal: I'll be using Maybe Int for its size; unbounded is an option
14:23:32 <conal> Baughn: still problematic.  if unbounded were really okay, we'd use it all the time.
14:23:50 <Baughn> conal: No, a combination. :)
14:23:51 <jmcarthur_work> Baughn, isEvaluated ?!
14:24:00 <Baughn> conal: Unbounded/bounded, plus a finalizer on the channel
14:24:12 <Baughn> jmcarthur_work: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/isevaluated
14:24:19 <Twey> FunctorSalad: *shakes head* There's nothing else in there
14:24:34 <conal> Baughn: i don't know how to choose a bound.
14:24:41 <Baughn> conal: Plus a way to explicitly cap an event sink
14:24:56 <Baughn> conal: That's application-specific. The default would be unbounded.
14:25:03 <FunctorSalad> Cale: I thought it might be possible to factor out the boilerplate and just supply the state type for each thread, and a "MsgType -> CanSendMessagesT (StateT S IO) ()" for each message type :)
14:25:19 <conal> Baughn: i don't know how one would make an application-specific choice.
14:25:26 <Baughn> conal: However, if the events are something like incoming network connections, you don't want to let them pile up too much
14:25:37 <FunctorSalad> but you end up with type-level lists, this is probably unneccesarily contrived
14:25:44 <Cale> FunctorSalad: There's also the cml and actor libraries
14:25:53 <Baughn> conal: Well, obviously, you need to have written the application in question.
14:25:53 <conal> Baughn: that's why i'd like a semantically correct GC-based solution.
14:26:06 <jmcarthur_work> Baughn, oh you're using vacuum? i guess this means vacuum is capable of showing unevaluated thunks now? i haven't check up in a while
14:26:19 <Baughn> conal: You get the semantically correct one if you pick makeEvent. You get finer control if you pick makeEvent'. makeEvent calls makeEvent'.
14:26:21 <Cale> Though to be honest, I find the actor library confusing.
14:26:24 <conal> Baughn: i really mean i'm skeptical that there would often be decent choices, even if i wrote the app.
14:26:44 <jmcarthur_work> vacuumLazy?
14:26:52 <conal> Baughn: so my best guess right now is that makeEvent' is sweeping an important problem under the table.  hiding, not addressing.
14:26:55 <Baughn> jmcarthur_work: vaccumLazy is a work in progress. mmorrow mentioned it isn't working quite right yet.
14:27:04 <Baughn> conal: It isn't
14:27:18 <Baughn> conal: Look, give me half an hour and you can read the code. I just need to write it first.
14:27:24 <conal> Baughn: k
14:27:30 <jmcarthur_work> ah
14:29:36 <FunctorSalad> Cale: yeah, it seems very advanced. apparently it is a sort of internal pattern matching on messages
14:29:50 <FunctorSalad> ("internal" as opposed to case statement pattern matching)
14:30:08 <Philippa> confusing: a bunch of haskell mails, with a mail in the middle with the subject line "Church cursed Madonna"
14:30:11 <Philippa> (it's spam)
14:30:37 <idnar> hahaha
14:31:56 <Cale> cml looks interesting, but I'd have to see some programs written to use it. I don't think I really "get" what the various primitives provided are for.
14:32:19 <Baughn> conal: Say. If the event is GC'd, should the sink just ignore calls, or throw an exception? (I vote for the latter)
14:32:55 <gwern> Philippa: too bad no haskellers are great classical painters
14:33:15 <Cale> But the funny thing is that the cml implementation in terms of MVars on Hackage is apparently something like 30% faster than O'Caml's native implementation.
14:33:18 <gwern> we could've had masterpieces like 'Church wept', depicting Alonzo Church despairing before the shadow of a turing machine
14:33:20 <conal> Baughn: you prefer the latter because you see the sink call as erroneous?
14:33:32 <conal> Baughn: and indication of a client logic error?
14:34:20 <Baughn> conal: Yes
14:34:30 <Baughn> conal: And if it really isn't, catching the exception is easy enough
14:34:44 <FunctorSalad> gwern: or an apalled lolcat "What do you mean it evaluates to itself? :o"
14:35:04 <conal> Baughn: what suggests to you that a write is erroneous if no one is reading?
14:35:06 <Cale> The paper which describes it claims that CML is 'higher order concurrent programming', but I don't really understand the sense in which it's any higher order than IO + MVars...
14:35:41 <Heffalump> usually higher-order concurrency refers to being able to send channels etc across channels
14:35:44 <gwern> FunctorSalad: yo cat i heard you lieked fixpoints so i put a fixpoint in yo fixpoint so you can eval a fixpoint while you eval
14:36:06 <Baughn> conal: Such a program is inherently buggy, since it leaks memory. Yes, we can paper over that with a finalizer, but those aren't guaranteed to be run in a timely manner
14:36:12 <Cale> Heffalump: But of course we can have a Chan (Chan a)...
14:36:17 <conal> Baughn: consider an analogous situation: a non-empty list runs out of consumers.
14:36:27 <Heffalump> Cale: right
14:36:35 <Baughn> conal: More to the point, it is more likely to be an indication of a bug than a desired feature
14:36:36 <conal> Baughn: i agree there's a bug.  but i'd say in the GC, not the app.
14:36:47 <mauke> preflex actually uses that in its restart logic (channel over channel) :-)
14:36:48 <Baughn> conal: And we currently have no way of informing the caller of a sink that nobody is listening
14:37:05 <conal> Baughn: yeah.
14:37:12 <Baughn> conal: If possible, I'd prefer to alter the Sink type to return a Bool - whether the occurence was delivered or not
14:37:23 <Baughn> s/delivered/queued/
14:38:02 <conal> Baughn: i think the problem here is that GC has a strong bias toward demand-driven architectures.
14:38:13 <conal> GC works backward for data-driven architectures.
14:38:19 <conal> so i'd fix GC
14:38:30 <Baughn> conal: Not an option. Realistic suggestions? :)
14:38:38 <conal> Baughn: yes.
14:38:46 <Baughn> conal: (a) Throw exception, (b) Return False, (c) Do nothing
14:38:58 <conal> Baughn: d
14:39:00 <mauke> retry, abort, cancel?
14:39:15 <Baughn> conal: Describe d
14:39:35 <conal> Baughn: i'm inviting you to explore other possibilities with me.
14:39:51 <conal> Baughn: so d starts with that exploration and then continues from there.
14:40:05 <Baughn> conal: I suppose there's no need to be over-eager. I'll sleep on it, then.
14:40:08 <Cale> I should maybe extend the CML library with all the obvious instances which it's missing...
14:41:00 * RayNbow blinks...
14:41:02 <Cale> Events form a monad in an obvious way.
14:41:10 <RayNbow> Guido... recommending... TAOCP?
14:41:14 * RayNbow blinks again...
14:42:22 <gwern> RayNbow: what do you expect him to recommend, SICP?
14:42:53 <RayNbow> gwern: I wasn't :p
14:42:53 <thoughtpolice> gwern: you rang?
14:43:04 <FunctorSalad> *still looking at the cml package*
14:43:04 <byorgey> TAOCP is quite imperative, you know.
14:43:04 <gwern> thoughtpolice: I was wondering why there was nothing in HCAR about LHC
14:43:19 <thoughtpolice> gwern: didn't think about writing it, unfortunately
14:43:23 <RayNbow> byorgey: TAOCP is quite math heavy... (the books are too)
14:43:32 <thoughtpolice> gwern: i wasn't even aware of when the submission deadline was
14:43:36 <byorgey> is Guido against math too?
14:43:44 <gwern> RayNbow: the reason why is left as an exercise for the reader. (easy)
14:44:02 <gwern> thoughtpolice: will you guys have an entry for next time?
14:44:17 <thoughtpolice> gwern: hopefully. and hopefully it will be more mentionable by then too :)
14:44:34 <thoughtpolice> but hey, at least it evaluates stuff and the code is really clean/pretty :)
14:44:37 <thoughtpolice> Lemmih++
14:44:37 * gwern wonders whether to volunteer to write it
14:44:42 <RayNbow> byorgey: don't know :p
14:45:19 <byorgey> Wikipedia says he got a masters in mathematics and computer science in 1982...
14:45:25 * RayNbow has read only a tiny bit of TAOCP... (I wonder if I will ever succeed at reading it all)
14:45:32 <RayNbow> ah
14:45:44 <McManiaC> @src while
14:45:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:45:56 <byorgey> TAOCP is fantastic.  Now if only the pseudocode was functional...
14:46:02 <McManiaC> @src unless
14:46:03 <lambdabot> unless p s = if p then return () else s
14:46:21 <RayNbow> byorgey: have you read it all?
14:46:28 <byorgey> RayNbow: no
14:46:31 <byorgey> just parts
14:48:03 <thoughtpolice> gwern: i'll be sure to write something down whenever janis announces the next hcar :)
14:48:22 <gwern> thoughtpolice: that's a rather verbose way of saying 'I can't be arsed' :)
14:48:55 <pumpkin> :o
14:49:26 <mux> the "types are calling convention" is really interesting
14:49:31 <mux> +paper
14:50:08 <pumpkin> I didn't quite get why a standard tuple couldn't represent that a function didn't ever get called with curried arguments though
14:50:36 <thoughtpolice> gwern: heh, like I said, I wasn't even aware of when the HCAR deadlines were. i was fairly busy the last month with studying - I just made my first commit to LHC in a few months just the other day!
14:50:51 <pumpkin> large hadron collider!
14:50:55 <pumpkin> the end of the universe!
14:51:12 <idnar> Large Haskell Collider
14:51:16 <thoughtpolice> and the code is *so* much better now. Lemmih++ Lemmih++ :)
14:51:30 <pumpkin> I agree, I was glancing over the source and it was quite pretty
14:51:53 <thoughtpolice> lemmih has been very keen on keeping the compilation pipeline pure
14:52:34 <Cale> Hmm... anyone have a good name for  class Foo f where foo :: (a -> b) -> (b -> a) -> (f a -> f b) ?
14:52:46 <thoughtpolice> mainly because we were getting bitten by all sort of asinine problems when trying to deal with the old code base
14:53:01 <Botje> Cale: what's the use of the b -> a function ?
14:53:05 <thoughtpolice> we would fix up a transformation pass with a 1 line change, and boom, the compiler fails approximately 15 miles away from that spot :)
14:53:17 <thoughtpolice> with a totally unrelated error
14:53:36 <FunctorSalad> Botje: take "data EndoFoo a = EndoFoo (a -> a)"
14:53:43 * Botje *boom*
14:53:47 <FunctorSalad> you need both ways to transform such a thing
14:53:52 <thoughtpolice> pumpkin: also, using GHC as a frontend cuts down on the LOC considerably
14:54:05 <FunctorSalad> Cale: "Functor*", but sadly that's illegal ;)
14:54:08 <thoughtpolice> pumpkin: and basically makes us the 2nd most featureful haskell compiler by default
14:54:08 <pumpkin> yeah, and you wouldn't have been changing any of that behavior anyway
14:54:12 <pumpkin> the type checking is all solved
14:54:29 <pumpkin> I mean, it's a separate direction
14:55:01 <FunctorSalad> Cale: "IsoSupportedFunctor"?
14:55:33 <Cale> It's almost like a difunctor, except it only has one parameter.
14:55:42 <Cale> and you have to do both sides at once
14:56:04 <thoughtpolice> pumpkin: yeah, plus jhc's typechecker/parser had some strangeness in it too. using GHC as a frontend and producing external core is much better :)
14:56:27 <thoughtpolice> pumpkin: current loc =~ 3200
14:56:31 <Cale> In fact, perhaps it *ought* to be a Difunctor in this case anyway.
14:58:10 <pumpkin> :D
15:17:48 * Cale is astounded by the extent to which ML programmers writing Haskell can make Haskell look like ML code. ;)
15:18:59 <Berengal> Cale: In my experience, they're superficially very similar until ALL OF A SUDDEN THE STACK BLOWS UP OMG!
15:19:50 <Cale> Well, this guy seems to really like braces and semicolons...
15:20:20 <Berengal> So does half the world's programming population...
15:20:21 <gwern> thoughtpolice: 2nd most featureful compiler... so you mean you inherit all of ghc's problems and only some of its benefits?
15:21:13 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/src/Control-Concurrent-CML.html#atsync
15:21:34 <Berengal> Oh dear gods
15:21:50 <periodic> Bah! my stack exploded.
15:21:57 <Cale> MY EYES! THE GOGGLES, THEY DO NOTHING!
15:22:10 <periodic> Why would this function be causing a stack overflow?  I thought I had TRO.
15:22:13 <Berengal> SUDDENLY! BRACES EVERYWHERE
15:22:29 <periodic> runSim st = if (simTime st) > 0 then runSim (performAction st) else st
15:22:45 <gwern> bam! stacks everywhere!
15:22:52 <Berengal> periodic: Tail calls do not always do what you think they do in Haskell
15:23:00 <periodic> where runsim :: SimState -> Simstate and performAction :: SimState -> SimState (nonrecursive)
15:23:06 <kpreid> Cale: The syntax highlighting distinctly does not help.
15:23:08 <periodic> Berengal: Hrm... any tips or rules for that?
15:23:30 <Berengal> periodic: Well, lazy evaluation is at fault
15:23:34 <Berengal> Two exaples: foldl and map
15:23:36 <Berengal> @src foldl
15:23:37 <lambdabot> foldl f z []     = z
15:23:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:23:38 <Berengal> @src map
15:23:39 <lambdabot> map _ []     = []
15:23:39 <lambdabot> map f (x:xs) = f x : map f xs
15:23:43 <periodic> ah... of course...
15:24:01 <Berengal> foldl frequently causes stack blowups, map doesn't
15:24:06 <periodic> I
15:24:16 <periodic> 've read about foldl vs foldr.
15:24:40 <periodic> But I should probably read that again.
15:25:28 <Berengal> Hmmm, it does look like your function is strict though...
15:25:34 <Cale> periodic: If you'd like I can explain how Haskell evaluation works. The stack does not mean what you probably think it means.
15:25:50 <periodic> Cale: Unlearning FTW!
15:25:53 <Cale> periodic: (it's used for something entirely different from what it normally is and builds up in a different way)
15:26:18 <periodic> Cale: thunks?  bigger and bigger thunks?
15:26:21 <Cale> As opposed to strict evaluation, which is done innermost-first, Haskell evaluation is outermost first.
15:26:53 <Cale> The stack is used when a function or case needs to pattern match on an expression and that expression does not immediately match.
15:27:16 <Cale> In that case, it has to be evaluated, and you get a stack entry for the waiting case.
15:27:55 <Cale> For example...
15:28:00 <Cale> @src foldl
15:28:00 <lambdabot> foldl f z []     = z
15:28:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:28:16 <Cale> Let's evaluate foldl (+) 0 (1:2:3:[])
15:28:27 <Cale> --> foldl (+) (0+1) (2:3:[])
15:28:32 <Cale> --> foldl (+) ((0+1)+2) (3:[])
15:28:39 <Cale> --> foldl (+) (((0+1)+2)+3) []
15:28:45 <Cale> --> ((0+1)+2)+3
15:28:54 <Cale> Up to this point, the stack has gone unused.
15:29:13 <Cale> But now, the outermost (+) is (...) + 3
15:29:32 <Cale> unless we know what (...) is, it can't evaluate (you can think of it as pattern matching on the integer)
15:29:46 <Cale> So (...) + 3 goes on the stack
15:29:58 <Cale> and then we have something which looks like (...) + 2
15:30:06 <Cale> and that goes on the stack for the same reason
15:30:17 <Cale> and then (0 + 1), which can evaluate, finally
15:30:30 <Gracenotes> I also find it helpful to substitute f, sometimes
15:30:59 <Cale> So it's this searching for a subexpression which will reduce that the stack is used for.
15:31:07 <Gracenotes> foldlSum z [] = z
15:31:09 <Gracenotes> foldlSum z (x:xs) = foldlSum (z+x) xs
15:31:45 <Cale> You can think of the stack depth as representing the depth from the expression you're trying to evaluate to the outermost-leftmost reducible subexpression.
15:31:49 <Gracenotes> (so it keeps on passing the accumulator, and when there's nothing left in the list that's the final result)
15:31:52 <periodic> Cale: Alright, I'm with you.  Now that seems to make sense.
15:32:06 <Berengal> Cale: I've been wondering, have you stored these lectures as macros or something?
15:32:17 <Cale> Berengal: no, I just keep them in my head
15:32:17 <periodic> Berengal: I was wondering the same thing
15:32:24 <periodic> Good typing practice.
15:33:14 <Axman6> Cale: you realy need  to blog that schpiel, it's far too valuable to be repeated all the time ;)
15:33:24 <periodic> yeah, I was totally expecting a link.
15:33:29 <Cale> If only I wasn't so opposed to the notion of a blog.
15:33:35 <Cale> hehe
15:33:35 <Gracenotes> hm. vs, foldrSum z (x:xs) = x + foldrSum z xs
15:33:37 <Axman6> the folding explanatatron
15:33:45 <Baughn> @type unsafeInterleaveIO
15:33:46 <lambdabot> Not in scope: `unsafeInterleaveIO'
15:33:47 <Axman6> well wiki it :P
15:33:50 <Cale> hehe
15:34:03 <Gracenotes> :ox
15:34:07 <Berengal> Cale: Also needs reduction of map
15:34:52 <Cale> So it's common for tail recursive functions which don't pattern match on their parameters to build up large expressions in those parameters which require lots of stack when they finally evaluate.
15:34:52 <Axman6> > map f [a,b,c,d]
15:34:54 <lambdabot>   Add a type signature
15:35:02 <Axman6> > map f [a,b,c,d] :: [Expr]
15:35:03 <lambdabot>   [f a,f b,f c,f d]
15:35:25 <Cale> In your case, we have... runSim st = if (simTime st) > 0 then runSim (performAction st) else st
15:35:36 <Cale> Let's examine what simTime does.
15:36:08 <periodic> simTime :: SimState -> Float (It's just an accessor function on the SimState data structure)
15:36:48 <Berengal> And performAction?
15:37:09 <periodic> performAction :: SimState -> SimState (non-recustive, just changes the state somehow)
15:37:15 <conal> continuing the license discussion (if there's interest): my problem with BSD and LGPL is that they don't ask for so little in return from a commercial user; and my problem with GPL is that it makes a specific demand that aren't what I'm after.
15:37:44 <conal> nothing i've seen in the way of licenses seems to get to the heart of what i'm after.
15:37:51 <pejo> conal, what are you after?
15:37:53 <Berengal> periodic: Ah, so performAction could build up thunks in fields other than simTime
15:38:02 <periodic> performAction picks an action to perform based on the state and returns a different state.
15:38:06 <Axman6> conal: in need of a Commercial Responsibility BSD licence?
15:38:14 <periodic> Berengal: Indeed, i believe it would.
15:38:26 <conal> pejo: :)  i want to enable & encourage people to play and pitch in.  and to reward everyone according to how their contribution is valued.
15:38:33 <dons> conal: btw, sent you email.
15:38:36 <conal> Axman6: something like that.
15:38:38 <conal> dons: looking.
15:38:50 <kig> is there any use for the expanding version of foldl, apart from blowing up the stack?
15:38:50 <Berengal> periodic: Does it look at all the fields of the SimState, or does it modify one without looking at it?
15:39:07 <inimino> conal: how is that different from the GPL?
15:39:25 <periodic> Berengal: it basically just reduces time by 1 and increases another integer in SimState by 1.
15:39:43 <periodic> Berengal: And I suppose there-in lies my problem?
15:40:04 <kig> (also is there some relation between creating full call-graph before lazily evaluating and lazily building call-graph while strictly evaluating?)
15:40:10 <Berengal> periodic: Possibly. It's a bit hard to tell without seeing the entire code. Anyway, by marking the fields strict you could possibly solve the problem
15:40:34 <periodic> Berengal: Is there a more general way to approach a problem like this to make it perform more reasonably?
15:40:55 <periodic> Essentially I want to iteratively apply a transformation on a state until I reach a termination condition.
15:41:19 <Cale> periodic: One way to help it is to make the fields of the datastructure strict.
15:41:27 <conal> inimino: i have no reason to force someone to open-source something that uses my libs.
15:41:42 <Berengal> periodic: Well, any time you modify a part of a datastructure without looking at it you build up thunks
15:41:49 <Cale> periodic: Which will ensure that when you pattern match on any part of the structure, all the fields are evaluated.
15:41:52 <Berengal> Unless you make it strict
15:41:57 <conal> inimino: i mean, i might appreciate them doing so, in some situations, but not in general.  and probably not even often.
15:42:26 <periodic> Hrm... time to look up that strict stuff...
15:43:09 <conal> that's what i meant about GPL: "it makes a specific demand that aren't what I'm after."
15:43:21 <conal> (hm.  s/aren't/isn't/)
15:44:09 <jmcarthur_work> conal, what do you want from commercial users?
15:44:15 <hatds> maybe you should start by deciding under what conditions, if any, people should pay money.  If you can get that big question out of the way you'll be able to find or draft a license to your liking
15:44:17 <inimino> conal: well, maybe you want something like the LGPL then?
15:44:28 <conal> inimino: about the same as bsd in this respect.
15:44:37 <pejo> conal, I see your problem, and I believe you're right about GPL. I also see the problem with a BSD license, if you're trying to make a living off your code. Have you considered a dual license?
15:45:07 <inimino> conal: but BSD is more permissive
15:45:33 <conal> inimino: agreed.  lpgl is less permissive, but hardly more helpfully so in this respect.
15:45:58 <conal> jmcarthur_work: i'd like commercial users to pass on some income to people who've contributed to their success.  depending on income and value of contributions.
15:46:31 <hatds> who decides how the income is distributed though?
15:46:38 <Axman6> or how much
15:46:42 <conal> yes!
15:46:56 <conal> i've been noodling over those questions since last fall.
15:47:03 <conal> i have some ideas, but not a complete story.
15:47:06 <Axman6> also, can they contribute with code and not money?
15:47:19 <conal> Axman6: sure.
15:47:46 <conal> Axman6: if the receiver values the contributed code
15:47:49 <Axman6> so, basically a GPL licence you can pay your way out of?
15:47:52 <periodic> Cale & Berengal: Well, making the data-structure strict worked.  It feels like a hack though and makes me think I might have been approaching this wrong.
15:48:18 <conal> Axman6: something like that, if you describe it as a GPL diff.
15:48:31 <Axman6> GPL diff>?
15:48:48 <conal> Axman6: if you describe it as how it's different from GPL.
15:49:11 <pejo> conal, also: Poul-Henning Kamp has done fundraising for his development work on FreeBSD (licensed under a BSD license). Would that model be useful to you?
15:49:28 <McManiaC> @src putStr
15:49:29 <Cale> periodic: well, you generally will need strictness when you're collapsing a large number of separately evaluable bits into a structure with not many separately evaluable bits.
15:49:29 <lambdabot> putStr s  = hPutStr stdout s
15:49:31 <hatds> can a commericial user just contribute code representing extensions to your library or do they have to make their whole program open source?
15:49:35 <conal> pejo: i don't know anything about it.
15:49:36 <Axman6> could always have a name and shame licence
15:49:40 <pejo> Axman6, isn't that how dual licensing is usually done?
15:49:41 <jmcarthur_work> conal, i know "viral" has a negative connotation, but for lack of a better word... is that essentially what you would like this license to be?
15:49:44 <Cale> periodic: That is, by summary, not by searching.
15:49:52 <jmcarthur_work> in the open source world, that is
15:49:54 <conal> hatds: i wouldn't start with the algorithm.  i'd start with the specification.
15:49:59 <Axman6> "if you don't contribute back, we'll bad mouth you all over the place"
15:50:02 <Cale> periodic: This is actually a really good heuristic for where you will need strictness.
15:50:08 <Axman6> pejo: i wouldn't know
15:50:09 <conal> jmcarthur_work: viral in what sense?
15:50:19 <Cale> Going from "large" structures to "small" ones by summarisation.
15:50:44 <periodic> Cale: Now that I'm thinking about it makes sense to do strict evaluation in this case.
15:51:02 <conal> jmcarthur_work: in the sense that there are strings attached -- whatever the strings be?
15:51:17 <jmcarthur_work> conal, for example, GPL is "viral" because derivative, open source works can't loosen the constraints
15:51:24 <conal> jmcarthur_work: yep.
15:51:26 <jmcarthur_work> okay
15:51:50 <jmcarthur_work> so the commercial side of things should somehow remain in open source derivatives?
15:52:28 <conal> jmcarthur_work: yeah.  if i give to you with strings, you don't get to give someone else without my strings.
15:52:34 <conal> jmcarthur_work: is that what you mean by viral?
15:52:38 <jmcarthur_work> basically
15:52:42 <Cale> periodic: If you're going from large structures to large structures, often there will be a way to 'stream' things, if you're going from small structures to large ones, again, lazy evaluation is your friend, and if you're going from small structures to small ones, usually it doesn't make a difference.
15:52:57 <conal> jmcarthur_work: then yeah.  i want something viral in this case.  just not the standard GPL viral.
15:53:12 <Axman6> conal: so what about something where you're required to contribute back in code, unless the code is deemed to be someting that needs to be kept private, so then contributions of money can be used
15:53:15 <SamB> conal: AGPL ?
15:53:28 <Cale> periodic: And searching through a large structure lazily is good too. It's only this sort of collapse where strictness is important, which is why foldl' is so effective at what it does :)
15:53:46 <conal> Axman6: well, you might be happy to give me your code, and i might not be interested.
15:54:03 <Axman6> does that then mean i have to pay?
15:54:09 <Axman6> because... that sucks if it does
15:54:12 <conal> SamB: does AGPL give me something over others that might help me?
15:54:24 <conal> Axman6: if you don't get income, then i don't want any from you.
15:54:34 <SamB> conal: well, probably not
15:54:40 --- mode: ChanServ set +o mauke
15:54:40 --- mode: mauke set +b *!*@pool-71-182-146-161.pitbpa.fios.verizon.net
15:54:44 <jmcarthur_work> conal, sounds to me like you want GPL and just sell licenses to proprietary vendors who wish to use it
15:54:47 <SamB> conal: why didn't you want the GPL ?
15:54:49 <conal> SamB: okay.  i haven't read AGPL yet.
15:54:53 <jmcarthur_work> sell *some other license* that is
15:54:59 <Axman6> mauke: ?
15:55:10 <conal> hm.  i don't know why people aren't getting how GPL doesn't fit for me.
15:55:17 <jmcarthur_work> except for one thing
15:55:19 <conal> does *anybody* here get it?
15:55:23 <mauke> Axman6: cross-channel anti-spam ban propagation!
15:55:26 <conal> (get what doesn't work for me about GPL)
15:55:31 <Axman6> :)
15:55:36 <periodic> Cale: I'll have to digest all that.  For now, back to coding.
15:55:40 --- mode: mauke set -o mauke
15:55:42 <SamB> conal: you can offer commercial users another license ...
15:56:00 <hatds> for one, GPL means you can't dual icense your entire code base... only the parts you "own"
15:56:04 <conal> SamB: right.  another, in addition to what?
15:56:08 <jmcarthur_work> conal, you don't want to stifle those who just want to play and research?
15:56:16 <conal> hatds: yeah -- that bit is messy.
15:56:35 <hatds> maybe you want a GPL-type license where all contributions are owned by you
15:56:36 <conal> jmcarthur_work: yes.  ditto for humanitarian ues.
15:56:39 <Axman6> conal: what about having a commercial licence, where users need to pay a fee, but if they contribute back code you like, the fee can be waved?
15:56:43 <SamB> well, you'd need to get some kind of assignment I guess ?
15:56:56 <conal> Axman6: yeah.  something like that.
15:57:07 <SamB> the FSF always requires copyright assignments -- for entirely different reasons, though
15:57:19 <conal> and noncommercial can be a degenerate case of a general one, rather than the separate license it usually is.
15:58:28 <SamB> conal: so do you want a non-DFSG license, or a DFSG license?
15:58:30 <jmcarthur_work> a "free for personal use" type of license
15:58:42 <conal> SamB: DFSG??
15:58:51 <SamB> Debian Free Software Guidelines
15:59:00 <conal> SamB: oh.  what's it like?
15:59:46 <SamB> conal: http://www.debian.org/social_contract#guidelines
16:00:03 <conal> SamB: will check it out.  thx.  :)
16:00:16 <conal> noncommercial would buy me some time and let people play before i know how to spec the general case.
16:00:20 <SamB> it's basically the same thing as the Open Source Definition, except Debian is more careful in interpreting it
16:00:35 <jmcarthur_work> conal, earlier you were talking about fair compensation for contributors. i think until that is formalized a license isn't really possible to come up with
16:00:38 <conal> SamB: do you think it addresses my concerns?
16:00:43 <SamB> conal: no!
16:01:03 <SamB> I'm just trying to find out if you are looking for a non-DFSG-free license or not
16:01:18 <conal> oh....  a "non"
16:01:42 <SamB> what software are you making anyway, that you want this license for?
16:01:55 <conal> jmcarthur_work: yeah.  that's the predicament i've been in since last fall, when my funding vanished.
16:02:13 <jmcarthur_work> conal, have you defined a "contributor" yet?
16:02:30 <SamB> conal: and what were you trying to prevent people from doing ?
16:03:59 <conal> jmcarthur_work: informally.
16:04:07 <hatds> maybe your compensation scheme could be paying bounties for important features (the bounty money being derived from the payment of commercial users)
16:04:24 <conal> hatds: hm.  interesting!
16:04:34 <conal> that's the kind of creative input i'm looking for.
16:04:43 <SamB> conal: is this for the reactive stuff, or?
16:04:45 <conal> i'm pretty sure all existing licenses are off the mark.
16:05:15 <SamB> also, you really better require copyright assignment
16:05:41 <conal> SamB: if i answered these questions, i'd be more motivated to get reactive solid.  also, i'm doing a functional->gpu compiler that i'd love to blog about and share.  *and* have as my core technology.
16:06:03 <SamB> mostly because you might want to move to a simpler license later
16:06:17 <jmcarthur_work> conal, related to hatds' suggestion... what about giving commercial users the ability to attach monetary values to bug fixes and feature requests, somehow?
16:07:06 <conal> jmcarthur_work: i guess i could do so.  in the extreme, i'd just describe the result and say that the bug is there's no implementation.
16:07:28 <conal> i doubt i'd get much enthusiasm.
16:07:51 <conal> jmcarthur_work: i like the idea though.
16:07:58 <conal> more such suggestions, please!
16:08:04 <SamB> conal: personally, I find it extremely hard to be enthusiastic about non-free software :-(
16:08:12 <conal> SamB: me too :(
16:08:44 <SamB> conal: so what kind of usage are you envisioning people making of the software if you do release under a free license, that you don't want?
16:08:54 <conal> SamB: are there conditions in which you'd be enthusiastic about supporting developers?
16:09:38 <jmcarthur_work> could follow the typical technical support and customized code model that lot of businesses have which rely on open source products
16:09:44 <SamB> conal: in a monetary way? if I had money, maybe ...
16:10:08 <jmcarthur_work> my friend mark spencer has been quite successful doing that, and with GPL software even ;)
16:10:19 <conal> SamB: so one condition is that you had money.  for instance, that you used my lib to make money.
16:10:51 <SamB> conal: hmm ... can you tell me a STORY about one of the usages you don't want to see ?
16:11:05 <conal> example of my concern: i have nifty, elegant, optimizing functional->gpu compiler, and i'd like to make iphone toys with it, and charge a small price for them (50 cents, or whatever).  however, i don't know how to make iphone apps.  so someone who does know can easily take my code and wrap an iphone app generator around it.  they'd have a product and i wouldn't.
16:11:15 <conal> SamB: oh!  there's the story.
16:11:37 <conal> sans character names, etc
16:12:20 <SamB> conal: well, you could use a restrictive license on the "RTS", maybe?
16:12:54 <conal> jmcarthur_work: about the tech support route, i think it depends on crappiness (bugs and/or complexity) of software.
16:13:08 <conal> SamB: hm?
16:13:14 <hatds> yea, the best software doesn't need support :(
16:13:19 <jmcarthur_work> conal, yeah, just introducing it to the conversation to see if anybody had thoughts on it
16:13:31 <conal> hatds: exactly. that's why i don't like the tech support model.  yuck.
16:13:37 <conal> jmcarthur_work: thx.
16:13:45 <conal> all: i really appreciate the brainstorming
16:13:45 <SamB> hatds: all of the best software ?
16:14:01 <hatds> SamB: well, generalizing a bit maybe
16:14:21 <conal> the tech support business model builds in an incentive for bugginess and complexity.
16:14:23 <SamB> conal: whatever you do, make sure you can change it to an open source license when you lose interest in the project, if not before
16:14:40 --- mode: ChanServ set +o mauke
16:14:40 --- mode: mauke set -b *!*@pool-71-182-146-161.pitbpa.fios.verizon.net
16:14:47 <Ralith> conal: if you have a corporate audience, they'll always want a support contract, and if it's complex enough software it'll deserve it even if it's perfect.
16:14:57 <Ralith> conal: non-contract tech support isn't what keeps companies like redhat afloat.
16:15:13 <conal> SamB: good idea!  any pointers on what might thwart changing to open source later?
16:15:21 <SamB> yeah, you can get some tech-support for free from red hat's engineers
16:15:33 <SamB> conal: not having the copyright on all of the code, basically
16:15:35 <MyCatVerbs> Ralith: I'm intrigued by the notion of a support contract on mathematically correct software. :)
16:15:40 <conal> Ralith: what kind of support does perfect (correct & simple) software need?
16:15:40 --- mode: mauke set -o mauke
16:15:48 <Ralith> MyCatVerbs: mathematically correct doesn't mean usable.
16:15:54 <SamB> so make sure everyone who contributes signs that over to you such that you can change the license later
16:15:56 <Ralith> conal: "how do I do x"
16:15:59 <conal> SamB: oh.  i have to keep the copyright fully in my name?
16:16:00 <jmcarthur_work> conal, one example would be accepting code that has conditions on it (that it have no derivatives besides your own project, for example)
16:16:08 <Ralith> conal: "how do I import data from source y"
16:16:11 <Ralith> conal: etc.
16:16:11 <ksf> It'd be cool to have a CT Prelude that takes CT seriously, like allowing 'toUpper . "foo"', as .lhs, titled "Category theory for Haskellers"
16:16:25 <conal> Ralith: got it.  thx.
16:16:40 <conal> Ralith: don't free user forums handle this need?
16:16:48 <SamB> conal: I'm not quite sure how it has to work ... Twisted (see #twisted) have some kind of non-exclusive shared copyright deal ...
16:16:57 <Ralith> conal: not as reliably as a support contract.
16:17:10 <glguy> ksf, composition is an fmap operation in a specific category
16:17:15 <glguy> it isn't the fmap operation in all of them
16:17:23 <Ralith> conal: it'd be kind of like offering to have your nephew build Sun a high-availability cluster, because he's "good with computers"
16:17:29 <pejo> conal, for larger corporations they are looking for someone to blame, and a contract is a nice way to do that.
16:17:41 <Ralith> conal: It *might* work, but everyone would be much happier just buying a system from Dell.
16:17:41 <SamB> conal: that is, both the contributor and Twisted Matrix Labs (or whatever they go by) can do whatever they want with contributed code, including change the license
16:17:46 <conal> pejo: yow! :P
16:18:03 <conal> pejo: i don't know how i could put my heart into a model like that.  thx tho
16:18:42 <Muzzleflash> I've been reading about foldl in RWR. It says because haskell's lazy a thunk is made instead of evaluating the expression. The thunk occupies linear storage right.
16:18:43 <Ralith> conal: besides, even with a theoreticaly perfectly and totally intuitive piece of software (which I doubt is possible), there will be people who just don't want to bother working it out on their own, and there will be execs that just won't be comfortable unless there's a support contract there to back it up.
16:18:56 <Ralith> the vast majority of users and corporations tend to be that way, in fact.
16:19:07 <inimino> conal: I would like to see software funding move to a donation model
16:19:10 <conal> Ralith: sure.  a teacher/guru .  i could do that one okay.
16:19:11 <Ralith> those that aren't end up somewhere like here ^^
16:19:16 <pumpkin> Ralith: screw them!
16:19:17 <pumpkin> :P
16:19:18 <conal> inimino: me too!  i'm glad you mentioned it.
16:19:19 <Muzzleflash> The how come I'm able to keep the thunk in storage, and it only fails when I evaluate it, if the the thunk is causing the memory usage
16:19:26 <Ralith> pumpkin: not if you want to make money you don't.
16:19:30 <Ralith> stupid is where the money is.
16:19:33 <pumpkin> depends how you want to make money
16:19:36 <pumpkin> screwing people can make lots of money
16:19:38 <inimino> conal: so you can release your code without worrying much about the license, and have a fund drive to cover costs of development
16:19:41 <Ralith> well, sure
16:19:48 <conal> inimino: which raises another whole line of exploration.  like how to inspire folks, honestly, rather than coerce them.
16:19:52 <Ralith> but again it comes down to stupid that's letting you screw them
16:19:53 <pumpkin> not sure it's legal though, except in nevada
16:19:55 <pejo> conal, not trying to push you into a business model you're not comfortable with, just giving a (possible) corporate pov.
16:20:10 <inimino> conal: like the way Wikipedia works (though it's not for software)
16:20:12 <inimino> conal: yes, exactly
16:20:20 <SamB> pumpkin: conal doesn't want to work as a hooker
16:20:25 <pumpkin> dang
16:20:26 <jmcarthur_work> if only we lived in a gift economy!
16:20:27 <conal> hacker hooker
16:20:35 <pumpkin> guess that's that idea out of the window
16:20:43 * pumpkin goes back to the drawing board
16:21:12 <amckinley> could anyone help me with part of my parsec parser for dns zone records? :)
16:21:13 <SamB> I saw an email offering a donation to Dosemu in my inbox today
16:21:16 <inimino> conal: I've been thinking about this kind of funding for a while and I believe it can work if the project is something people are interested in
16:21:18 <SamB> addressed to the dosemu list
16:21:23 <jmcarthur_work> i'm afraid i must leave. a shame, because this conversation is very interesting :\
16:21:43 <conal> inimino: glad to hear.   i'm very interested in that model.
16:21:54 <SamB> apparantly just because it really helped this guy's company out with a migration
16:22:09 <inimino> SamB: yes, there are lots of offers to donate to open source projects, even ones that don't ask for them (which is most of them)
16:22:37 <conal> maybe the voluntary model can work better if people get to have richer connections with each other -- to see how their voluntary contributions impact the receiver.
16:22:37 <jmcarthur_work> conal, another thing to consider is to take on "sponsors." businesses love to look humanitarian
16:22:54 <jmcarthur_work> (and sometimes they actually *are* humanitarian!)
16:23:08 <inimino> conal: I think a key feature is openness and transparency of funding, so that people can see what the expenses are and what is necessary to meet them, rather than just throwing money into a black hole
16:23:28 <conal> inimino: i'm right with you there.  have been thinking exactly the same thing.
16:23:31 <Jedai> Muzzleflash: Because the thunk is stocked in the heap
16:23:44 <conal> inimino: so that giving is intrinsically enjoyable.
16:23:56 <Muzzleflash> Jedai: "stocked"?
16:24:03 <jmcarthur_work> more incentive is that donations are deductible, and lots of businesses prefer to make less profit by spending more money on deductible things like that
16:24:05 <Jedai> Muzzleflash: it is in the heap
16:24:07 <inimino> a lot of projects will have a "donate" button, but that's it... and that doesn't exactly create that feeling of connection
16:24:20 <jmcarthur_work> because more profit is more taxes
16:24:23 <conal> inimino: yeah.
16:24:33 <conal> jmcarthur_work: iswym
16:24:39 <Muzzleflash> Jedai: Does the thunk not take up as much space in the heap, as when needed when the result is evaluated?
16:24:57 <jmcarthur_work> you would have to be a nonprofit or something for that to work though, i think
16:25:02 <bos> @seen dons
16:25:02 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 46m 29s ago.
16:25:10 <Jedai> Muzzleflash: when you start evaluating it, if the function is strict in its first argument, then the call accumulate in the stack and create the overflow
16:25:22 <Muzzleflash> Jedai: From: http://en.wikibooks.org/wiki/Haskell/List_processing
16:25:29 <Muzzleflash> Haskell is a lazy language, and so the calls to f will by default be left unevaluated, building up an expression in memory whose size is linear in the length of the list,
16:25:31 <Jedai> Muzzleflash: the thunk is never in the stack
16:25:34 <jmcarthur_work> anyway, i really must go now. i will try to check back in the logs later i guess
16:25:41 <Muzzleflash> How come my heap is able to store a 4GB list?
16:25:59 <Jedai> Muzzleflash : it isn't
16:26:45 <Jedai> Muzzleflash: if you had this illusion it was due to some lazyness trick that the list was never really present whole in memory
16:26:56 <ksf> glguy, the point of it is that fmap is composition in Functor (->a)
16:27:13 <ksf> ...and (.) a cool operator for map.
16:27:24 <Muzzleflash> Jedai: In a file I have: test = foldl (+) 0 [1..1000000000]. I assume this is made into a thunk on the heap? How come the file loads?
16:27:28 * bos ginned up a new pidgits entry for the shootout
16:27:42 <ksf> you could directly compose two functors, too.
16:27:45 <MyCatVerbs> Muzzleflash: ah, that will blow up, yes. But not until you try to evaluate it.
16:27:48 <Gracenotes> ksf: still. people associate . with composition of functions :)
16:27:50 <conal> bos: "ginned up"?  got it drunk?
16:27:56 <pumpkin> bos: nice! faster than the current gcc one?
16:27:56 <dons> yo os
16:27:57 <Jedai> Muzzleflash: [a..b] is syntactic sugar for enumFromTo a b
16:27:58 <dons> bos
16:28:07 <dons> bos: added some parallelism?
16:28:14 <conal> jmcarthur: thx for the input!
16:28:14 <bos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5325#a5325
16:28:16 <MyCatVerbs> Muzzleflash: if you try to print it by typing "test" in GHCi, you'll get a stack overflow right away.
16:28:21 <bos> dons: no, just made it faster and smaller
16:28:28 <Muzzleflash> MyCatVerbs: Yes
16:28:36 <dons> bos: faster still eh?
16:28:38 <dons> rocking.
16:28:49 <pumpkin> did you see someone one-upped Arnaud's entry
16:28:51 <conal> any erc (emacs irc client) users here?
16:29:01 <bos> it's still 24% slower than the fastest C version
16:29:03 <Muzzleflash> Jedai: If I wrote the numbers by themselves 1,2,3,4 and so the file wouldn't load?
16:29:12 <MyCatVerbs> Muzzleflash: but you can have infinitely large structures in Haskell just fine if you never actually try to evaluate them. You can even have undefined things, that throw an exception if you try to evaluate them, provided you never touch the undefined bits.
16:29:15 <Muzzleflash> Although the actua
16:29:21 <ksf> conal, if you write your own license, please give a rigorous, formal, denotational semantic. The thought of legions of lawyers despairing is just too nice.
16:29:22 <bos> pumpkin: i saw that, tried to match it in speed but couldn't easily do so
16:29:34 <pumpkin> bos: I noticed that the c versions have been using only one division per iteration
16:29:43 <pumpkin> whereas arnaud's one (I haven't looked at yours yet) is doing two
16:29:47 <Jedai> Muzzleflash: You probably would have a problem at the compilation stage
16:29:55 <pumpkin> unless I've misunderstood it somehow
16:30:11 <bos> pumpkin: mine does just one
16:30:15 <pumpkin> ah cool
16:30:24 <eu-prleu-peupeu> hello haskellers
16:30:31 <conal> ksf: :)
16:30:32 <pumpkin> he's back!
16:30:33 <Muzzleflash> Jedai: Yes, due to the file size? However, ignoring any other influences, the thunk would be too big?
16:31:07 <eu-prleu-peupeu> i follow all you important guys on twitter, so if you are important and im not following you, please say so :)
16:31:18 <Jedai> Muzzleflash: due to the time it would take for GHC to compile such a file
16:31:26 * ksf is too important to be on twitter.
16:31:27 <pumpkin> eu-prleu-peupeu: it's hard to tell :P
16:31:39 <Jedai> Muzzleflash: but do you really get a stack overflow with this test ?
16:31:41 <eu-prleu-peupeu> im following you pumpking
16:31:54 * pumpkin feels important
16:32:05 <Jedai> Muzzleflash: You must have a load of RAM
16:32:12 <eu-prleu-peupeu> :)
16:32:26 <eu-prleu-peupeu> i particularly like the twitter of this guy called bonus
16:32:32 <bos> the new haskell pidgits code is 35% the size of the C code, but 75% the speed
16:32:34 <pumpkin> BONUS is in here too
16:32:39 <bos> not too bad
16:32:43 <pumpkin> bos: pretty impressive :)
16:33:03 <Muzzleflash> Jedai: Yes I do: foldl (+) 0 [1..1000000]
16:33:11 <Jedai> Muzzleflash: the constructed thunk is effectively linear in the size of the list, which means that with this list, the construction of the thunk itself must already takes too much time
16:33:27 <ksf> Muzzleflash, unevaluated thunks are as big as the code they represent plus a boolean, and evaluated thunks as big as the data the code generated plus a boolean... unless the thunk got garbage collected, of course, in which case it is smaller.
16:33:34 <dons> bos: you using >= 6.10.2 ?
16:33:36 <Jedai> Muzzleflash: ok, with _this_ list the stack overflow is understandable
16:33:58 <bos> dons: nope, 6.10.1
16:33:58 <hatds> Muzzleflash: you should think of the execution model as rewriting strings.  If a = [1,2,...] then 'a' is an infinite list but as a string 'a' is very small.  If you do computations on this list then the execution model says you have to rewrite 'a' as  1 : [2,3...], which is now two strings
16:34:09 <pumpkin> bos: did you encounter the massive memory usage bug?
16:34:17 <bos> pumpkin: yep
16:34:26 <pumpkin> so it might be even faster without it?
16:34:35 <bos> pumpkin: let me upgrade and see
16:34:47 <Jedai> Muzzleflash: What happens is that the thunk is constructed in memory (if you check the occupied memory you'll realize that it takes a lot...) in the heap and until that stage there is no problem
16:34:57 <pumpkin> I'll try it against arnaud's one on my 6.10.3
16:35:04 <dons> the massive memory bug hurts performance, I think.
16:35:08 <dons> as such bugs are want to do
16:35:23 <ksf> http://shootout.alioth.debian.org/u32q/benchmark.php?test=pidigits&lang=all
16:35:24 <Jedai> Muzzleflash: but then you have to evaluate the thunk which is (((.....) + 999999) + 1000000)
16:35:38 <ksf> heh. the c guys made two new revisions.
16:35:39 <Muzzleflash> I see. I still don't understand why the thunk, when evaluating a left fold, doesn't evalute strictly
16:36:28 <Jedai> Muzzleflash: and (+) is strict in both argument for Int or Integer, which means that you'll have to stack 999999 call to (+) in the stack before you can return....
16:36:48 <ksf> Muzzleflash, because function application, in contrast to (+), isn't strict.
16:37:18 <pumpkin> bos: nice, 11.2s for arnaud's on my shitty macbook air, and 9.5 for your code
16:37:47 <Jedai> Muzzleflash: a "thunk" can't evaluate strictly or not, this don't really makes sense, I think you're asking why we're constructing the thunk in the first place instead of applying strictly (+) as we go ?
16:37:55 <hatds> Muzzleflash: basically, Haskell tends to be lazy by default for everything
16:38:18 <bos> pumpkin: that sounds about right
16:38:19 <pumpkin> if you don't like it, ask haskell nicely and it may stop being so lazy
16:38:31 <Muzzleflash> Let's say there is this thunk (((((1 + 2) + 3) + 4) + 5)
16:39:00 <Muzzleflash> How come evaluating takes more space than storing the thunk?
16:39:06 <Jedai> Muzzleflash: it don't
16:39:27 <Muzzleflash> How come Haskell won't work with 400MB test = foldl (+) 0 [1..1000000]
16:39:32 <Muzzleflash> then
16:39:45 <pumpkin> it can garbage collect the stuff it's done with
16:39:51 <Jedai> Muzzleflash: the stack is limited in space (you can change the limit by the way), the heap isn't (well it's limited by physical memory + swap)
16:39:55 <Berengal> Muzzleflash: Evaluation in haskell is outermost first, so it has to push all the outer expressions on the stack before it gets to 1+2
16:40:34 * ksf emphasises what Berengal said
16:40:40 <Muzzleflash> Berengal: Outermost? Why? Let me guess something to do with lazy?
16:40:45 <pumpkin> non-strict
16:40:48 <Berengal> Muzzleflash: Yes
16:41:17 <ksf> Muzzleflash, not really. Haskell "doesn't evaluate under lambdas", as we say.
16:41:30 <hatds> let's not confuse the boy
16:41:34 <Jedai> Muzzleflash: the outermost stuff isn't important here, (+) is strict, it would work exactly the same way in any languagbe
16:42:15 <Muzzleflash> Jedai: A left fold would work different in a non-lazy language. At least that's how I understand it
16:42:16 <Gracenotes> uh, speaking of lazy
16:42:24 <Jedai> Muzzleflash: except it wouldn't build the thunk in the first place but if it really had to evaluate this it would blow the stack anywher
16:42:24 <ksf> that is, haskell is not maximally lazy, just not eager.
16:42:30 <Muzzleflash> That's why it's recommended not to use foldl?
16:43:02 <Berengal> Muzzleflash: There's very little difference between foldl and foldl' appart from foldl' being strict in the accumulator
16:43:35 <Gracenotes> a fact to note: foldl doesn't work for infinite lists. foldr can.
16:43:38 <Jedai> Muzzleflash: right, you can find some cases where it could be useful (if for instance the function argument wasn't strict in its first argument) but mostly you'll want to use foldl' instead
16:43:43 <pumpkin> and foldl being basically useless in most cases
16:44:04 <Jedai> Muzzleflash: or foldr if possible
16:44:29 <Berengal> foldr doesn't do much better when it comes to the stack though, does it?
16:44:38 <Berengal> > foldr (+) 0 [1..1000000]
16:44:40 <lambdabot>   * Exception: stack overflow
16:44:46 <Jedai> Berengal: in this case no
16:45:01 <pumpkin> :t fold
16:45:03 <lambdabot> Not in scope: `fold'
16:45:19 <Gracenotes> foldl' is better when there's a strict accumulator, imho. (so long as the function works)
16:45:20 <Muzzleflash> The only real difference between foldl and foldr is when using non-commutative function or infinite list. And if your list is larger than your floppy disk you should use foldl'?
16:45:23 <Berengal> The advantage of foldr is that it can drop out of the computation early
16:45:25 <bos> oh wow, with 6.10.3, GHC is just 6% slower than the fastest C entry. neat!
16:45:26 <Jedai> Berengal: but basically what I was saying is that if you want a fold you either want foldl' or foldr, almost never foldl
16:45:27 <Baughn> @pl \x -> do foo <- bar; foo x
16:45:27 <lambdabot> (line 1, column 20):
16:45:28 <lambdabot> unexpected ";"
16:45:28 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
16:45:32 <Gracenotes> if there's a lazy accumulator, you *need* foldr basically to get the most out of it
16:45:32 <Baughn> @. pl undo \x -> do foo <- bar; foo x
16:45:32 <lambdabot> (bar >>=) . flip id
16:45:36 <Berengal> Jedai: Yes, that's true
16:45:39 <Gracenotes> aaaaahhh lambdabotspam
16:46:00 <pumpkin> bos: nice! have you looked at what they did to make the second to last gcc entry to make it even faster?
16:46:06 <Gracenotes> @type (<*>)
16:46:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:46:09 <Jedai> Muzzleflash: it depends
16:46:12 <pumpkin> the code looks mostly identical, I'm trying to figure out what changed
16:46:32 <Muzzleflash> Jedai: Depends on what?
16:46:35 <bos> pumpkin: this one? http://shootout.alioth.debian.org/u32q/benchmark.php?test=pidigits&lang=gcc&id=4
16:46:47 <Gracenotes> pumpkin: we must spy on their camp and learn their methods
16:46:58 <Gracenotes> o_O
16:47:00 <Jedai> Muzzleflash: basically you want to use foldr if the function argument isn't strict in its second argument, you want to use foldl' in other cases
16:47:40 <bos> pumpkin: my code is very similar to the C code, it's just haskelly. uses an infinite list and pure functions instead of static global crapology.
16:47:53 <pumpkin_> bos: yeah, &id=3 vs. &id=4
16:47:57 <pumpkin_> id=3 was the first "response" to arnaud's entry, and then someone sped that one up even more
16:47:58 <Jedai> Muzzleflash: for instance (||) isn't strict in its second argument and "or = foldr (||) False" is the correct definition
16:48:08 <Muzzleflash> Jedai: If the accumulator isn't strict?
16:48:14 <pumpkin_> bos: is it already using whatever made id=4 faster than id=3?
16:48:30 <pumpkin_> they changed   mpz_mul_2exp(tmp1, numer, 1);
16:48:42 <Gracenotes> hm
16:48:46 <Jedai> Muzzleflash: this or() can short circuit (stop reading the list at the first True)
16:49:02 <bos> pumpkin_: right
16:49:08 <Muzzleflash> Jedai: Okay, I understand. Then every math operator is not strict?
16:49:20 <Jedai> Muzzleflash: math operator ?
16:49:24 <hatds> Where can I find some good FRP examples?  Something at the level of blog post tutorials is fine, but I'd like to be able to actually run the program in response to, say, stdin
16:49:31 <Muzzleflash> Jedai: + - / * and so on
16:49:34 <aavogt> > 0 * undefined
16:49:36 <lambdabot>   * Exception: Prelude.undefined
16:49:48 <Jedai> Muzzleflash: most operation on the classic Num types are strict which is why you want to use foldl' with them
16:49:57 <Jedai> Muzzleflash: (+) is strict for instance
16:50:03 <Gracenotes> Muzzleflash: arithmetic operators from Num and Floating and Fractional for Int, Integer, Float and Double, I'm pretty sure are strict
16:50:10 <_JFT_> Hey, I have a cabal question (cabal-install actually) say that I have installed a package from hackage with it but I would like to modify it locally. How should I proceed with cabal so that the end result is my "modified version" registered? Thanks
16:50:33 <pumpkin_> wow, that mul_2exp was literally the only thing they changed other than some minor stuff
16:50:44 <_JFT_> (for the curious I want to add a "user-agent" opt to access delicious)
16:50:53 <pumpkin_> I don't think we have an interface to that function though
16:50:55 <Jedai> Muzzleflash: though you could imagine some types of Num for which (+) wouldn't be strict (like Natural, the peano naturals) but that's another subject, sometimes useful though
16:50:58 <dcoutts> _JFT_: cabal unpack foobar; cd foobar-x.y; vi; cabal install
16:51:06 <bos> pumpkin_: right
16:51:18 <_JFT_> dcoutts: do I have to do this in the .cabal subdirectlry?
16:51:24 <_JFT_> subdirectory
16:51:25 <Muzzleflash> When It HAS to apply the function then the function is strict. When It doesn't always need to it's not?
16:51:34 <_JFT_> dcoutts: or any subdirectory will do?
16:51:44 <dcoutts> _JFT_: nope, anywhere. cabal unpack makes a subdir
16:51:58 <_JFT_> Thank you
16:52:13 <dcoutts> _JFT_: where the sources go is unrelated to where the binaries are installed
16:52:15 <Jedai> Muzzleflash: basically a function f is strict if "f undefined == undefined"
16:52:45 <Muzzleflash> Jedai: I see.
16:52:51 <ksf> ... so (\_ -> ()) is strict?
16:52:54 <_JFT_> dcoutts: ok so it will still install the library in the .cabal subdir?
16:52:59 <ksf> argh crap.
16:53:01 <Jedai> Muzzleflash: for instance for (+) on Int "undefined + x = undefined" and "x + undefined == undefined" so it's strict in both argument
16:53:05 <Berengal> > (\_ -> ()) undefined
16:53:06 <ksf> (\_ -> undefined)
16:53:06 <lambdabot>   ()
16:53:08 <dcoutts> _JFT_: yep
16:53:37 <bos> pumpkin_: that accounts for most of the difference between the haskell and C code
16:53:40 <_JFT_> dcoutts: excellent  :) and say I want to send back to the author the improvment is there a generic way to do it through hackage?
16:53:43 <Jedai> Muzzleflash: but "True || undefined == True" so (||) isn't strict in its second argument
16:53:59 <bos> pumpkin_: alas, GHC's Bits instance for Integer doesn't expose a useful implementation of bit shifting
16:54:21 <Muzzleflash> Jedai: Thanks, was just about to write me coming to that conclusion.
16:54:25 <dcoutts> _JFT_: not really, the package can link to a darcs repo, but not many actually do that yet
16:54:32 <pumpkin_> bos: that's impressive then :) I added a few more primops for gmp operations recently to GHC but they're getting rid of GMP primops altogether so it won't help much
16:54:44 <_JFT_> dcoutts: good old email then :P Ok thank you very much :)
16:54:45 <dcoutts> _JFT_: so usually you have to go to the package homepage to find the darcs/git repo
16:55:06 <Muzzleflash> Thank you all for giving me some new insight to haskell :). It's getting late 2 in the night goodnight.
16:55:34 <Jedai> Good night :)
16:56:47 <Muzzleflash> Jedai: The haskell mentality, I'll rather do everything in order not to do anything seems to help me understand foldl and strict and non-strict evaluation. Again, goodnight :)
16:57:00 <Muzzleflash> and thunkiong
16:58:18 <aavogt> dcoutts: how new is that cabal feature?
16:58:38 <dcoutts> aavogt: you mean unpack or the ability to specify source repos?
16:58:46 <aavogt> source repos
16:58:51 <dcoutts> aapole: since Cabal-1.6
16:59:00 <dcoutts> oops
16:59:09 <dcoutts> aavogt: since Cabal-1.6, which came with ghc-6.10.x
17:02:32 <Gracenotes> > let leng xxs = let (x:xs) = xxs in 1+leng xs in leng [1,2,3]  -- from the mailing list... why? >_>
17:02:34 <lambdabot>   * Exception: stack overflow
17:03:42 <Gracenotes> on the other hand, something like 'let (x:xs) = xxs in x+mysum xs' fails predictably
17:04:31 <Jedai> Gracenotes: what's the question ?
17:04:52 <Gracenotes> 'why? >_>' does it stack overflow
17:04:57 <Jedai> Gracenotes: pattern matching in let is always lazy/irrefutable
17:05:18 <Gracenotes> yes, I'm aware -- but this seems counterintuitive. What's overflowing?
17:05:32 <Jedai> Gracenotes: because it put an infinite number of (+) on the stack
17:06:07 <Jedai> Gracenotes: it never evaluates x or xs (not really) so it never stops putting (+) on the stack ==> stack overflow
17:06:22 <Gracenotes> right, so it recurses too much; so it never breaks down on the constructor?
17:06:32 <Jedai> Gracenotes: the sum version though evaluates x so it stops as soon as it goes over the end of the list
17:06:34 <Gracenotes> too much laziness. I see, I think.
17:06:52 <pumpkin_> you could fix that in that case with using head and tail explicitly I think
17:06:54 <aavogt> ok, so it will be a while before cabal will regularly be used for finding source repos
17:06:55 <Gracenotes> that's interesting... it recurses beyond what it can pattern match
17:06:58 <Jedai> pumpkin_: no
17:07:17 <Gracenotes> oh, mak sanse
17:07:32 <Jedai> > let leng xxs = 1+leng (tail xxs) in leng [1,2,3]
17:07:34 <lambdabot>   * Exception: stack overflow
17:07:54 <Berengal> Gracenotes: Try 'leng undefined' in your head, see what happens
17:08:02 <Gracenotes> Berengal: yes. I did that
17:08:11 <Jedai> pumpkin_: as you see it doesn't fix anything (which is logical since the irrefutable pattern is more or less equivalent to use head or tail directly)
17:08:16 <Gracenotes> the ultimate laziness test! :o
17:08:21 <pumpkin_> hmm, interesting
17:08:29 <aavogt> > fix (1+) -- same?
17:08:34 <lambdabot>   mueval-core: Prelude.read: no parse
17:08:34 <lambdabot>  mueval: ExitFailure 1
17:08:51 <Jedai> aavogt: exactly, leng _ == fix (1+)
17:09:08 <aavogt> hmm, but different failure
17:09:13 <aavogt> in this case
17:09:13 <amckinley> hey, could somebody help me out with a small piece of a parsec parser that im working on?
17:09:20 <Jedai> > fix (1+)
17:09:25 <lambdabot>   mueval-core: Prelude.read: no parse
17:09:26 <lambdabot>  mueval: ExitFailure 1
17:09:36 <Gracenotes> Jedai: not to mention, it might not be overflowing on the (+), but rather on the "tail" in your version
17:09:47 <Gracenotes> or both at the same time
17:11:32 <Jedai> Gracenotes: no, I don't think so
17:11:41 <Jedai> Gracenotes: the tail is in a thunk in the heap
17:11:56 <Gracenotes> oic
17:12:04 <Jedai> Gracenotes: it's _never_ called on the stack (which is precisely the problem)
17:12:51 <Jedai> Gracenotes: but on the other hand I don't really understand why fix (1+) don't fail with the same error...
17:14:36 <Gracenotes> fixPlusOne = let x = 1+x in x...
17:14:57 <Gracenotes> hm
17:15:19 <Gracenotes> oh, I see
17:15:53 <Gracenotes> fix (1+) is a stack overflow on my ghci
17:15:58 <Gracenotes> fix (+1) hangs forever
17:16:20 <Gracenotes> ...and I might possibly be more confused than before
17:16:26 <Jedai> Gracenotes: it's like instead of putting a new (+) call on the stack it use the circularity of the graph to reuse the same call (and presumably keep a count of the number of time it was reused I guess)
17:17:59 <aavogt> Gracenotes: ghci 6.10.3 hangs forever with 0 cpu (seems to catch that the expression is _|_) on both variations here
17:18:15 <Jedai> aavogt: 6.10.2 too
17:18:58 <Gracenotes> 6.8 here
17:19:04 <Jedai> aavogt: but normally when GHC detects this kind of thing it create an exception "blackhole" or whatever
17:19:10 <Gracenotes> graph reduction is an interesting thing
17:20:02 <kpreid> <joke about "graph oxidation">
17:24:09 <johnnnowa> hello all. Data.Time.Calendar.Day claims it has a read instance but I seem to be unable to actually use it (read "1984-09-08" :: Data.Time.Calendar.Day). am I doing something silly?
17:25:00 <kpreid> johnnnowa: try seeing what syntax its show instance produced
17:25:10 <dancor> graph + h = graphh
17:26:04 <johnnnowa> kpreid: the same format i'm using. in either case, it's claiming no instance for (Read Day)
17:26:29 <kpreid> Point out the evidence that it has a read instance?
17:26:42 <johnnnowa> http://hackage.haskell.org/packages/archive/time/1.1.2.1/doc/html/Data-Time-Calendar.html#t%3ADay
17:27:15 <kpreid> Is that documenting the same version you're working with?
17:27:17 <Gracenotes> hm.
17:27:39 <johnnnowa> kpreid: don't know. how can I check?
17:29:02 <kpreid> I don't know.
17:29:16 <enolan> johnnnowa, ghc-pkg describe time
17:29:23 <enolan> will tell you the version
17:29:34 <Gracenotes> johnnnowa: try importing Data.Time.Format
17:29:43 <johnnnowa> the documentation is for 1.1.2.1, i'm using 1.1.2.2
17:29:45 <Gracenotes> that in turns imports the private module Data.Time.Format.Parse
17:29:49 <Gracenotes> which has an instance for Read Day
17:29:54 <johnnnowa> egh
17:30:05 <johnnnowa> yeah, that works
17:30:13 <johnnnowa> how can i tell that from the documentation?
17:30:20 <Gracenotes> I think the documentation may be lacking :/
17:30:32 <kpreid> hm...you can't, and I think that's haddock's fault
17:30:47 <Gracenotes> I just grepped the source for "instance Read Day" and then for "import Data.Time.Format.Parse"
17:32:01 <aavogt> Jedai: yeah, I've come across some mention of blackholes either in the ghc docs or maybe in a quick look over the IFL book
17:34:01 <Jedai> johnnnowa: I would suggest avoiding this Read instance to be honest and using directly the facility in Data.Time.Format
17:34:21 <johnnnowa> Jedai: aye, was just trying to get some script to work quickly
17:34:59 <Jedai> johnnnowa: that would let you specify exactly the format of your date and document it and with a standard date format description
17:35:15 <Jedai> johnnnowa: In this case of course ^^
17:42:29 <bos> faster pidgits writeup: http://bit.ly/nLyYB
17:47:28 <dons> that's a title for the intertubes
17:49:04 <bos> it sure is
17:53:05 * wli peeks.
17:54:10 <wli> bos: Tried shiftL for multiplying by powers of 2?
17:55:25 <fracture> if I used mplus with Maybe, and the lhs is not nothing, will it evaluate the rhs?
17:56:02 <glguy> > Just 1 `mplus` undefined
17:56:04 <lambdabot>   Just 1
17:56:06 <glguy> no
17:56:21 <fracture> ah thanks
17:57:31 <Gracenotes> there's Last and First for that
17:57:41 <glguy> wli, judging by http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/src/Data-Bits.html#Bits , Integer's Bits instance just uses: x * 2^i
17:57:50 <Gracenotes> > undefined `mappend` Last (Just 1) `mappend` Last Nothing
17:57:51 <lambdabot>   Last {getLast = Just 1}
17:57:59 <wli> glguy: ugh
17:58:02 <Gracenotes> > undefined `mappend` First (Just 1) `mappend` First Nothing
17:58:04 <lambdabot>   First {getFirst = * Exception: Prelude.undefined
17:59:05 <bos> wli: the shiftL implementation for Integer sucks :-(
18:07:05 <dancor> is there any existing template haskell that makes a Traversable instance
18:08:07 <Jedai> dancor: there's derive
18:08:13 <wli> You might be better off writing your own arbitrary-precision integer arithmetic at that rate.
18:08:30 <Jedai> it has all sort of Template Haskell to derive most common class
18:08:42 <dancor> oh nice
18:09:02 <Jedai> dancor: also in 6.12 GHC will know how to derive Functor, Foldable and Traversable
18:09:21 <Jedai> dancor: the HEAD already contains the patch
18:40:41 <dancor> i am a template haskell noob.  how do i go from Language.Haskell.TH.Data.DataDef
18:40:46 <dancor> to Language.Haskell.TH.Syntax.Name
18:40:58 <dancor> is there a good TH tutorial
18:41:33 <gwern> no
18:41:55 <gwern> but the congealed tears and wails of your suffering as you figure it out - that might be a good tutorial
18:42:46 <SamB> @hoogle DataDef -> Name
18:42:47 <lambdabot> Warning: Unknown type DataDef
18:42:47 <lambdabot> Distribution.Simple.Command optionName :: OptionField a -> Name
18:42:47 <lambdabot> Distribution.Text display :: Text a => a -> String
18:43:01 <SamB> @hoogle Data -> Name
18:43:01 <lambdabot> Did you mean: Data a -> Name /count=20
18:43:01 <lambdabot> Distribution.Simple.Command optionName :: OptionField a -> Name
18:43:01 <lambdabot> Distribution.Text display :: Text a => a -> String
18:43:08 <SamB> @hoogle a -> Name
18:43:09 <lambdabot> Distribution.Simple.Command optionName :: OptionField a -> Name
18:43:09 <lambdabot> Prelude repeat :: a -> [a]
18:43:09 <lambdabot> Data.List repeat :: a -> [a]
18:43:18 <dancor> well ''Lol seems to create a Syntax.Name.
18:43:21 <SamB> hmm :-(
18:45:19 <dancor> i think DataDef is the whole data statement, not just a constructor
19:00:04 <bos> what would people think about merging the network-bytestring and network packages? http://trac.haskell.org/network/ticket/15
19:01:41 <amckinley> hey, is there any way to consecutively apply a list of arguments to a partially-applied function?
19:01:43 <centrinia> I would rather have a merge-network package.
19:01:52 <c2racer> I'm new to IRC. Is this the place to come to for discussions on haskell ?
19:01:59 <dibblego> amckinley, f a b c
19:02:00 <centrinia> c2racer: Yes.
19:02:32 <amckinley> dibblego: right, im asking if its possible to achieve that effect if i have [a,b,c]
19:02:45 <centrinia> amckinley: Do you want to compute f (head $ x) (head . tail $ x) (head . tain $ x) Z
19:02:48 <gwern> dibblego: but b c isn't a list!
19:03:00 <c2racer> OK - looking for some guidance on a program design for a domain-specific language in haskell
19:03:01 <dibblego> oh an actual list
19:03:12 <dibblego> amckinley, map or mapM perhaps?
19:03:25 <centrinia> @pl f (head $ x) (head . tail $ x) (head . tail . tail $ x)
19:03:26 <lambdabot> f (head x) (head (tail x)) (head (tail (tail x)))
19:03:42 <centrinia> @pl \x -> f (head $ x) (head . tail $ x) (head . tail . tail $ x)
19:03:42 <lambdabot> ap (liftM2 f head (head . tail)) (head . tail . tail)
19:03:51 <amckinley> dibblego: i was thinking fold, but the problem is that the type of the partially applied function would change after every application
19:04:01 <centrinia> @pl \f x -> f (head $ x) (head . tail $ x) (head . tail . tail $ x) (head . tail . tail . tail $ x)
19:04:02 <lambdabot> (`ap` (head . tail . tail . tail)) . (`ap` (head . tail . tail)) . (`ap` (head . tail)) . (. head)
19:04:02 <dibblego> amckinley, how could it? it's a list
19:04:25 <hatds> amckinley: you cannot go from [a,b,c] to f a b c except by pattern matching on the first list and writing out "f a b c"
19:04:32 <TomMD> bos: Its a good idea.
19:04:45 <Haudrex> Sounds like amckinley wants to fold composition over an hlist.
19:05:01 <amckinley> hatds: bummer
19:05:09 <amckinley> Haudrex: tell me more :)
19:05:17 <TomMD> bos: Also, the network API should be reworked entirely.  There is value of having a direct FFI, but it shouldn't be the main API for most Haskell applications.  In other words - I think we can do better.
19:05:39 <Haudrex> @go haskell heterogeneous list
19:05:40 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
19:05:41 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ...
19:05:43 <centrinia> amckinley: You could have extrapolated the output that lambdabot gave somehow.
19:05:55 <TomMD> A trivial example is "inet_ntoa :: String -> IO HostAddress"
19:06:07 <hatds> amckinley: I think hlist will only lead you astray, personally
19:06:25 <hatds> amckinley: what you are asking for could be a sign that you need to rethink your program design
19:06:55 <Haudrex> http://okmij.org/ftp/Haskell/types.html#HList
19:06:58 <^Someone^> Tada
19:07:21 <djahandarie> ^Someone^, oh hey there. :P
19:07:28 <^Someone^> Hello ^^
19:07:36 <amckinley> hatds: you're probably right
19:08:27 <tompledger> Re using the first few elements of a list as function arguments: http://www.mail-archive.com/haskell-cafe@haskell.org/msg00142.html
19:08:53 <amckinley> tompledger: thanks!
19:09:02 <amckinley> hatds: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5326#a5326
19:09:17 <amckinley> im writing a parsec parser for dns zone files
19:09:38 <amckinley> this is my first project in haskell, so you may want to shield your eyes :)
19:10:07 <Twey> You probably shouldn't be using list elements as arguments, though.
19:10:11 <Twey> You can always pattern-match.
19:10:50 <centrinia> amckinley: Where is the argument list-using function?
19:10:53 <amckinley> anyways, im trying to deal with this corner case in the syntax: at any point in a record declaration, you can use parens to circumvent the normal line-based record processing
19:11:18 <amckinley> heres an example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5327#a5327
19:11:18 <Twey> > foldr id (+) [1, 2]
19:11:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
19:11:20 <lambdabot>    arising from a use...
19:11:38 <centrinia> :t foldr id (+) [1,2]
19:11:39 <lambdabot> forall a. (Num a, Num ((a -> a -> a) -> a -> a -> a)) => a -> a -> a
19:11:40 <Twey> Hm, that's not right...
19:11:49 <amckinley> centrinia: the constructors for the various record types
19:11:50 <Twey> What happened there?
19:11:57 <bos> TomMD: yes, the network API is a bit hopeless
19:12:07 <amckinley> in pr :: Parsec String (Maybe String) DnsRecord
19:13:29 <amckinley> i was in the middle of thinking about how to rewrite that part
19:14:28 <JusticeFries> Hi! I'm trying to figure out advantages between picking up Erlang and Haskell...being both functional languages, is there much of a difference?
19:14:53 <centrinia> amckinley: Instead of having a single parseRdata, try having functions parseARecord, parsePTRRecord, etc.
19:15:24 <bos> JusticeFries: see http://www.erlang-factory.com/conference/SFBayAreaErlangFactory2009/speakers/BryanOSullivan
19:15:27 <Cale> JusticeFries: Lots of differences
19:16:08 <centrinia> JusticeFries: Try both of them and find the differences yourself.
19:16:10 <JusticeFries> ah, thanks!
19:16:12 <Cale> JusticeFries: Haskell *might* be more challenging a change in mindset.
19:16:37 <amckinley> centrinia: i still end up needing a generic way to parse the record data
19:16:43 <Cale> Because it's more insistent on purity, perhaps
19:16:50 <centrinia> amckinley: Why must it be generic?
19:16:51 <JusticeFries> I'd like to try both, but then I'm sure I'd get deeply interested in both, and of course I have general time constraints.
19:17:06 <bos> Haskell's definitely more challenging than Erlang.
19:17:23 <bos> Erlang is a bit of a pig's ear of a language, saved by its runtime system.
19:17:32 <inimino> indeed
19:17:37 <amckinley> centrinia: because the hard part (at least as im seeing it) is the handling of this paren case, which means i cant blindly use lexeme parsers
19:17:50 <gwern> it's an odd bastardization of prolog, I got the impression from the erlang retrospective
19:18:10 <Cale> I think Haskell is also probably more fun than Erlang in the end, but I shouldn't really say that, given that I've only played around with Erlang a tiny bit.
19:18:54 <JusticeFries> From what I got, either one works great for parallel servers.
19:18:55 <sjanssen> JusticeFries: Haskell will have more new and interesting concepts than Erlang.  Erlang has concurrency, Haskell has purity, parametric polymorphism, type classes, laziness, monads, etc.
19:19:14 <JusticeFries> Hmm. Okay.
19:19:16 <Cale> (and concurrency :)
19:19:22 <JusticeFries> well.
19:19:29 <JusticeFries> concurrency you can easily get in haskell from what I briefly read - par.
19:19:30 <sjanssen> (and multiple interesting approaches to concurrency)
19:19:36 <amckinley> centrinia: its just becoming very miserable to deal with a grammar that requires me to handle whitespace in complicated ways
19:19:38 <Cale> JusticeFries: That's parallelism.
19:19:47 <JusticeFries> ooh.
19:19:50 <Cale> JusticeFries: We also have concurrency, and lots of fun libraries related to that.
19:20:30 <Cale> Parallelism is computing a result faster because you have more processors to compute it on, concurrency is doing lots of things at once (regardless of the number of processors)
19:20:34 <aavogt> haskell doesn't have widely used ways to replace code at runtime though?
19:20:47 <gwern> JusticeFries: well, what erlang really gets is parallelism over multiple computers - this is not something haskell does well
19:20:56 <Cale> That is, lots of different things, which may interact nondeterministically.
19:20:59 <TomMD> bos: You might be interested in my hopes of building what I'd call a 'network2' package.  Currently I've uploaded 'network-data' which inplements what should have been part of network: IPv4 header, pretty printing, binary instances, IPv6/UDP/TCP headers, checksums (untested).
19:21:03 <JusticeFries> i see.
19:21:07 <sjanssen> aavogt: that's true
19:21:14 <centrinia> amckinley: In the cases where typ is either "MX" or "SOA", the presence of the read function should indicate that you should write a specific parser function.
19:21:17 <TomMD> bos: Eventually I intend to design/build/release network-api
19:21:24 <gwern> JusticeFries: but if your program is on just computer, then haskell is as good as erlang
19:21:30 <bos> TomMD: Binary instances? hm.
19:21:38 <JusticeFries> well
19:21:41 <JusticeFries> i guess i'll just check out both.
19:21:41 <bos> TomMD: i don't like the binary API much
19:21:50 <JusticeFries> and make my foray into functional programming :3
19:21:53 <TomMD> bos: yes, for the headers - incase you build sockets and specify the header is included.
19:21:54 <amckinley> centrinia: how about a polymorphic return type in parseRdata?
19:21:57 <centrinia> amckinley: How do you handle parse failures?
19:22:02 <pumpkin_> RyanT5000: know anything about GHC on ARM? :o
19:22:03 <Cale> JusticeFries: Yeah, I'd even go so far as to say that as long as you're not doing distributed computation, Haskell currently beats Erlang at concurrency :)
19:22:03 <TomMD> bos: But you need not care about the binary instances for most cases.
19:22:25 <amckinley> id like to say parseData :: (Int, String, Int, Whatever) and get back a tuple that looks like that
19:22:40 <amckinley> centrinia: im not :P
19:22:41 <bos> TomMD: the problem is that binary doesn't let a parse fail
19:23:01 <Cale> But we have very little answer for how to do distributed stuff.
19:23:01 <RyanT5000> pumpkin_: i might know a bit sometime soon
19:23:15 <pumpkin_> :o
19:23:17 <TomMD> bos: This is true (and annoyed the heck out of me in past projects).  Still, it is useful to have a representation of headers that you can send/recv over a wire.
19:23:33 <amckinley> centrinia: if you're wondering, parseRdata takes an Int because i was rewriting it so i could restrict the amount of parsing it attempts
19:23:41 <TomMD> bos: A 'fail-safe' serialization of headers would be welcome instances in the network-data package
19:24:03 <amckinley> so i could say parseRdata 5 and get back a list with 5 elements, or a parse failure
19:24:13 <JusticeFries> well
19:24:19 <JusticeFries> between erlang, haskell, and scala, it should be a fun summer.
19:24:20 <TomMD> bos: Aside from 'bytestring-strict' do you know of such a class for serialization?
19:24:39 <centrinia> amckinley: Try removing rdata <- parseRdata2; also try to modify the cases so that they look like: "MX"    | length rdata == 2     -> parseMXrecord
19:25:26 <bos> TomMD: what's bytestring-strict?
19:25:26 <amckinley> centrinia: yes, i could rewrite it like that, but im still stuck on needing this generic parser for handling the record data
19:25:56 <bos> TomMD: i have a binary derivative that i picked up from, um, adam langley, which can do failed and partial parses
19:26:04 <TomMD> bos: I ment binary-strict
19:26:12 <amckinley> centrinia: unless you can show me a really easy way to handle the paren case
19:26:18 <TomMD> @hackage binary-strict  -- I think
19:26:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-strict  -- I think
19:26:25 <bos> TomMD: my library is a continuation of binary-strict
19:26:33 <TomMD> ok
19:26:49 <bos> TomMD: but i don't recall whether i published it
19:29:02 <centrinia> amckinley: It looks like that the parentheses are extraneous and you can ignore them while parsing.
19:29:42 <amckinley> centrinia: no, i cant. otherwise i cant determine the end of the record data
19:30:13 <centrinia> You already determined them. For the MX records, it is 2, for the SOA records, it is 7.
19:30:17 <amckinley> well actually...
19:30:23 <amckinley> yes, you're right
19:30:41 <amckinley> let me try that
19:30:52 <centrinia> Okay.
19:31:18 <iop> haskell is more challenging and more rewarding and imho a beter language. erlang is probabl easier to pick up though and if you have to deal specifically with distributed or concurrent stuff then it has a aholw platform for it
19:32:29 <amckinley> centrinia: id like to avoid repeating myself in the individual record parsers, since they only differ in the data they're expecting
19:32:59 <centrinia> That's the price you pay. :(
19:33:10 <centrinia> The benefit is that you can have better error messages.
19:33:32 <amckinley> centrinia: i guess i could pass the stuff thats already been parsed as arguments to the individual record parsers
19:33:40 <centrinia> The entire program will not abort if, say, a SOA record has 6 parts.
19:33:49 <Kali_> hey, has anyone here worked with declarative representations of 3D scenes?
19:34:27 <centrinia> amckinley: Try creating a DNS zone file with a MX record with one part. :)
19:35:45 <amckinley> centrinia: the real issue is that by using all these lexeme parsers, its easy to roll past the end of the newline that officially marks the end of the record and consume the next hostname, say, as the final element of a previous record
19:36:00 <adu> Kali_: I've dealt with X3D and PovRay
19:38:04 <amckinley> centrinia: which would then cause the parser to fail because the fields dont line up, but the error message wouldnt be very intuitive and it doesnt really reflect what actually happened
19:39:51 <adu> Kali_?
19:40:32 <Kali_> how do you think those would translate to haskell?
19:40:35 <hatds> Concurrency question: I have two IO actions A and B and I want to perform action B repeatedly until at least n seconds elapses, then perform A once and start over. I don't, however, want to pre-empt a B action still in progress when I decide to switch to A.  What's the most elegant way to do this?
19:43:01 <adu> Kali_: ooo good question
19:44:01 <amckinley> centrinia: the grammar is fundamentally line-oriented, so i feel like my parser should be as well
19:48:00 <hackagebot> hs-twitter 0.2.8
19:49:04 <adu> Kali_: I would imagine there would be at least two schools .... functionalization of X3D, and verbatim Haskellization of X3D (via OOHaskell perhaps)
19:49:28 <amckinley> centrinia: ive got to run; thanks for your help
19:50:21 <adu> Kali_: the first school of tought would likely start with the FieldTrip project, and make extensions to it maybe
19:50:52 <Kali_> adu: cool thanks, the first one is what I'd be more interested in so I'll look into that :)
19:50:57 <pumpkin_> people should really check the code they send out on haskell-cafe
19:51:32 <hatds> hehe
19:51:44 <hatds> or else you'll get a torrent of corrections?
19:52:31 <pumpkin_> just that it makes no sense
19:52:51 <pumpkin_> the whole f :: (Int a) => a -> [b]
19:53:21 <centrinia> Maybe someone is hiding Prelude and defined a class Int.
19:53:41 <pumpkin_> even so, the type doesn't make sense :)
19:54:05 <hatds> f a = take (fromIntegral a) $ repeat undefined
19:54:23 <pumpkin_> replicate a undefined ? :P
19:54:30 <pumpkin_> still not what I consider a sensical funciton
19:54:33 <pumpkin_> function
19:54:40 <hatds> yep
19:54:48 <centrinia> pumpkin_, f = const []
19:54:53 <hatds> the only useful result of the function is you can count it's length
19:54:54 <travisbrady> anyone have any recommended reading for someone looking to understand type systems and what can be done with types? and maybe a little of "what's the big deal about types?"
19:54:59 <centrinia> :t const []
19:55:00 <pumpkin_> centrinia: again, not what I consider a sensical function :P
19:55:00 <lambdabot> forall a b. b -> [a]
19:55:14 <pumpkin_> travisbrady: TAPL?
19:55:18 <pumpkin_> @where tapl
19:55:18 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:56:27 <hatds> seconding TAPL
19:57:00 <travisbrady> pumpkin_, hatds: thank you
20:09:13 <Cale> http://xkcd.com/589/ hahaha
20:09:20 <dancor> reify means to make concrete but in TH it means to make into an abstract syntax tree?
20:10:29 <Gracenotes> or, to expose the concrete implementation of something
20:12:33 <Cale> You give it a name and it gives you information about that name
20:13:04 <monochrom> Is 589 today's?
20:13:25 <Cale> seems to be the newest
20:14:01 <monochrom> OK I like its finishing touch i.e. "goat" and "wolf" can't be in the same car. :)
20:15:06 <hackagebot> delicious 0.3.3
20:18:08 <Cale> monochrom: yeah, that's the part I liked too :)
20:18:09 <vininim> @tell marcot yes, basicaly parsec with bytestrings
20:18:09 <lambdabot> Consider it noted.
20:18:33 <vininim> except it's not cute like parsec :/
20:21:50 <jimmyjazz14> question about pattern matching with the record syntax, shouldn't ' let a (MyType { a = n }) = n+1 ' work
20:23:04 <Berengal> jimmyjazz14: I don't think so, but even if it does it looks highly questionable
20:29:59 <bos> jimmyjazz14: depends on what you want it to do.
20:30:48 <hatds> hmm.. I don't use records but it looks legals. http://www.haskell.org/onlinereport/exps.html   Semantics of Case Expressions n) and m).  Might just be easier to test it out
20:30:52 <hatds> *lega
20:30:57 <hatds> ahem,  *legal
20:30:59 <bos> it's legal.
20:31:02 <bos> but it's weird.
20:31:26 <hatds> makes sense, but records are weird to begin with
20:33:45 <monochrom> You can haz "case x of Maybe{} -> ..." it's the same as "case x of Maybe _ -> ..."
20:34:19 <monochrom> oops. s/Maybe/Just/
20:34:34 <monochrom> "case x of Just{} -> ..." it's the same as "case x of Just _ -> ..."
20:34:37 <bos> monochrom: but the rules are really weird: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5331#a5331
20:35:00 <bos> monochrom: i can't explain why the types of those definitions are different, for instance :-(
20:35:27 <hatds> x is not a value of type Int, it is a globally visibile function of type Foo -> Int
20:35:52 <monochrom> x :: Foo -> Int  is what hatds says. Available because of the record declaration.
20:36:19 <monochrom> b is equivalent to: b _ = x
20:36:26 <bos> yeah, but it's really lexically confusing.
20:36:51 <monochrom> But now you can explain it.
20:37:05 <monochrom> It's all science and math, no magic.
20:37:16 <hatds> imho, don't try to look for structs in haskell, there don't exist (at least not elegantly)
20:37:23 <hatds> there=they
20:37:43 <monochrom> Name clashes are of course always evil, as usual.
20:38:04 <monochrom> f :: (Monad int) => io -> int io   ha ha ha
20:39:39 <monochrom> In fact, is this allowed?  data Monad a = ... whatever you want here...; instance Monad Monad where ....
20:40:13 <hatds> if Monad isn't imported unqualified you could say "data Monad.."
20:40:43 <hatds> but not in general
20:40:46 <dancor> i can't figure out DeriveTraversal: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2513#a2513
20:42:29 <monochrom> "data Monad a = Monad a" alone is allowed. Only ambiguity is when you start using it.
20:42:54 <monochrom> (For example when you say "instance Monad Monad where")
20:43:08 <Twey> Then you have a Monad class, a Monad type, and a Monad constructor
20:43:20 <Twey> Perfectly unambiguous to Haskell, but maddening to everyone else
20:43:33 <monochrom> (Or when you say "f :: Monad a -> Monad ()")
20:44:00 <Twey> What's wrong with that?
20:44:09 <hatds> yea, isn't it clear it has to be the type?
20:44:10 <Twey> Oh, you mean the -> might be mistaken for a =>?
20:44:21 <monochrom> No.
20:44:58 <Twey> Why not?  It couldn't be anything else there
20:45:26 <hatds> It is hard enough to distinguish between typeclasses and types at times, we don't need to make it harder ;)
20:45:33 <monochrom> Ambiguous occurrence `Monad' / It could refer to either `Main.Monad' ... or `Prelude.Monad'
20:46:01 <djahandarie> Twey, yet again you confuse me by being in different channels that I'm in.
20:46:03 <djahandarie> monochrom, you too
20:46:04 <monochrom> The name resolver doesn't care "it's a type name" vs "it's a class name" at this point.
20:46:24 <Twey> Oh, right, that ambiguity.
20:46:33 <jimmyjazz14> is there a way to have multiple types using the record syntax that use the same name, like ' data Mt = Mt {name :: String } ; data Ml = Ml {name :: String}
20:46:34 <Twey> Wait
20:46:38 <Twey> That's an ambiguity?
20:46:52 <monochrom> I don't know. It is a reproducible experiment.
20:47:06 <Twey> How odd
20:47:14 <Twey> jimmyjazz14: Yes  put them in separate modules
20:47:31 <hatds> jimmjazz14: not without using module scoping to hide them, but you can do this data Mt = Con1 {name :: String, age :: Int} | Con2 {name :: String, height :: Int}
20:47:41 <monochrom> I am too lazy to check into the Haskell98 report on this issue now. :)
20:47:44 <hatds> jimmjazz14: but records are ugly, I wouldn't recommend it
20:48:14 <hatds> records with alternation seem like they would be especially confusing
20:48:42 <jimmyjazz14> I see
20:48:44 <Twey> Modules are for namespacing, and in modules we should trust
20:49:25 <hatds> I think using modules for interfaces is a little grungy, if that is what you mean
20:49:33 <Twey> Why?
20:49:44 <hatds> I'm not sure actually
20:49:44 <Twey> That's their purpose
20:49:56 <hatds> well, I'm talking about just this specifically:
20:49:58 <Twey> In fact it's the entirety of their purpose
20:50:15 <hatds> Data.Applicative.length or somesuch
20:50:36 <Twey> And that's why we have qualified imports
20:50:42 <Twey> A.length is so much nicer :)
20:50:54 <hatds> yea, that's what I would do too
20:51:06 <jimmyjazz14> any good alternative to record sytax that will keep my large type declarations readable?
20:51:19 <Twey> jimmyjazz14: Um, that's what record syntax is for
20:51:32 <Twey> What's your issue with it?
20:51:41 <hatds> but I don't think it is a good idea to design your module to conform to an existing interface.  i.e. if you are going to use 'length' as your identifier do so because it is a good name, not because you want to be compatible with Data.List interface
20:52:08 <dancor> so is there no simple way to generate Dec, given that [d|...|] makes [Dec]?
20:52:22 <hatds> there really ought to be a typeclass if you want a universal interface
20:52:35 <Twey> hatds: Well, in one sense, that's so
20:52:52 <Twey> I guess
20:52:54 <hatds> that's so what?
20:53:07 <jimmyjazz14> actually creating modules makes sense now that I think about it
20:53:08 <Twey> MultiContainer or something
20:54:11 <hatds> jimmyjazz14: you can use type synonyms, like this    type A1 = .., type A2 = .., ...  then finally say  data Foo = Foo (A1 A2 A3 ..)  You should also think about breaking up your big data type into smaller ones, if possible
20:55:26 <hatds> I think most people use records specifically to handle large datatypes though, I just haven't ever been compelled enough
20:58:04 * Cale tries to sort out exactly what the cml library code is doing and make it easier to read.
20:59:33 <bos> cml?
21:00:10 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/Control-Concurrent-CML.html
21:00:58 <Cale> It's an interesting library, but the code style is unfortunate.
21:01:59 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/src/Control-Concurrent-CML.html#atsync
21:02:15 <bos> oh, trippy.
21:02:28 <hatds> oh dear
21:03:52 <Cale> Also it's strange that they didn't notice that Event seems to have easy Functor, Applicative and Monad instances.
21:04:06 <bos> if it had one coding style, that would be something. but it looks like it was written by several people who didn't like to talk to each other.
21:04:29 <bos> probably not very longstanding haskell hackers.
21:04:54 <hatds> look at 'atchan'
21:05:02 <hatds> si, ei, ko
21:05:55 <hatds> this is a good reminder that you should indicate somewhere why your short identifiers are named what they are
21:05:56 <Cale> Looking at the paper, at least those names could be elaborated
21:06:39 <Cale> Though, it's funny that it doesn't exactly follow the paper's code...
21:07:17 <hatds> (atpointO r t o y x) (\s -> do ...
21:07:21 <hatds> hmm ;)
21:07:32 <bos> i don't mind short local variable names.
21:07:54 <Cale> yeah, it doesn't matter if their meaning is clear
21:08:10 <hatds> yea, but is it?
21:08:15 <wahjava> hi everyone
21:08:20 <Cale> hi
21:08:26 <hatds> I guess I shouldn't comment since I'm not seriously trying to follow the code
21:09:02 <te> Alex McLean is my hero
21:09:24 <te> That Haskell hack video he made is friggen cool
21:09:36 <Cale> I've at least managed to reindent it all.
21:10:03 <te> For those who don't know: http://yaxu.org/haskell-hack/
21:10:29 <centrinia> Who is coa?
21:10:58 <coCocoa> centrinia: The dual of 'a', of course. ;p
21:12:46 <centrinia> When did this dual meme start?
21:13:43 <Adamant> it's all copumpkin's fault
21:13:45 <Adamant> :P
21:13:54 <monochrom> Ever since we studied category theory and dualized everything.
21:15:15 * Pseudonym writes more de
21:16:44 <clug> Evertime I try to code i can't get it to work because of "syntax errors", is there a language that doesn't have syntax errors?
21:17:01 <monochrom> hahahahaha are you trolling?
21:17:05 <centrinia> clug: Yes!
21:17:08 <hatds> machine code?
21:17:10 <Pseudonym> A/PL?
21:17:17 <Pseudonym> TECO!
21:17:18 <centrinia> Halt.
21:17:23 <monochrom> Gdel numbering has no syntax error.
21:17:35 <centrinia> It just ignores everything you write. :)
21:17:49 <centrinia> It is the simplest language actually.
21:17:49 <Pseudonym> monochrom: I don't think that's true.  Gdel numberig has no requirement to be surjective.
21:18:31 <monochrom> I know. We hack it by mapping the unused numbers to a default.
21:18:41 <Pseudonym> Well, strange you should mention that.
21:18:57 <Pseudonym> You can construct a bijection if the source language is Turing-hard.
21:19:22 <Pseudonym> The proof of the Cantor-Bernstein-Schroeder theorem is constructive,.
21:19:28 <hatds> remember that Halloween episode of the Simpsons where every test answer Bart gave became correct by default?  Now imagine the same thing with syntax of your favorite language
21:20:10 <centrinia> Ping pong proof. :)
21:20:17 <Pseudonym> Yeah, exactly.
21:20:44 <Pseudonym> If you can ensure that the sequence isn't doubly infinite (which is usually easy to guarantee if you're picking it), then it's even computable.
21:21:03 <monochrom> If a bijection can be constructed, so that we don't have to use the defaulting hack, all the better.
21:21:32 <Pseudonym> Implementing a marshalling/demarshalling framework based on the Cantor-Bernstein-Schroeder theorem is left as an exercise.
21:21:49 <monochrom> I want to drive home the point that a language without syntax/type/semantics/logic errors is harder to use, not easier to use. Maximum surprise, etc.
21:22:31 <monochrom> The easiest-to-use language is one that makes you write full specifications and prove all implementations correct. Principle of least surprise.
21:22:41 <Pseudonym> @let f x = (x :: Integer, y :: Integer)
21:22:43 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Expr'
21:22:49 <Pseudonym> @let f x = (x :: Integer, x :: Integer)
21:22:51 <lambdabot>  Defined.
21:23:07 <Pseudonym> @let f_inv (x,y) = if x == y then Just x else Nothing
21:23:08 <lambdabot>  Defined.
21:23:19 <Pseudonym> @let g (x,y) = 2^x * 3^y :: Integer
21:23:21 <lambdabot>  Defined.
21:24:23 <semicoln> People awake in here?
21:25:15 <monochrom> No, we sleep here.
21:25:37 <Pseudonym> @let g_inv n = let g' n (f2,f3) = case (n `divMod` 2,n `divMod` 3) of { ((0,r),_) -> g' r (f2+1,f3); (_,(0,r)) -> g' r (f2,f3+1}; _ -> if n == 1 then Just (f2,f3) else Nothing }
21:25:38 <lambdabot>   Parse error
21:25:40 <monochrom> It's like "people awake in ICU?" The point of ICU is people are in coma.
21:25:43 <Pseudonym> @let g_inv n = let g' n (f2,f3) = case (n `divMod` 2,n `divMod` 3) of { ((0,r),_) -> g' r (f2+1,f3); (_,(0,r)) -> g' r (f2,f3+1}; _ -> if n == 1 then Just (f2,f3) else Nothing } in g' n (0,0)
21:25:44 <lambdabot>   Parse error
21:25:52 <Pseudonym> @let g_inv n = let g' n (f2,f3) = case (n `divMod` 2,n `divMod` 3) of { ((0,r),_) -> g' r (f2+1,f3); (_,(0,r)) -> g' r (f2,f3+1); _ -> if n == 1 then Just (f2,f3) else Nothing } in g' n (0,0)
21:25:54 <lambdabot>  Defined.
21:26:05 <Pseudonym> So far, so good.
21:26:10 <monochrom> Hehehe this channel is the ICU for programmers!
21:26:18 <semicoln> Lol monochrom
21:26:24 <Pseudonym> :-)
21:27:11 <ray> so whenever i build a package with ghc 6.10, ld uses absolutely enormous amounts of memory
21:27:15 <ray> is this normal?
21:27:42 <Cale> ray: maybe, if there are a lot of dependencies
21:28:18 <semicoln> ray: what platform?
21:28:42 <ray> lunix (debian lenny)
21:28:45 * wahjava has pasted httpd.hs at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5332#a5332
21:28:58 <ray> i was using OS packages before, but i stopped
21:29:02 <wahjava> i'm having an issue with a network server program in haskell.
21:29:25 <wahjava> i think it is not cleaning up properly, but i'm unable to figure out what I'm missing.
21:29:42 <wahjava> hi sbahra
21:30:38 <Pseudonym> @check \x -> Just x == f_inv (f x)
21:30:39 <lambdabot>   Not in scope: `f_inv'
21:30:47 <Pseudonym> @check \x -> Just x == L.f_inv (L.f x)
21:30:48 <lambdabot>   Not in scope: `L.f_inv'Not in scope: `L.f'
21:30:52 <Pseudonym> Damn.
21:30:56 <wahjava> any ideas anyone ?
21:31:59 <bos> wahjava: that's extremely non-descriptive.
21:32:17 <wahjava> bos, sorry about that, i've pasted the output in the footer of that paste.
21:32:21 <bos> wahjava: sh.
21:32:43 <dmead> ?seen dons
21:32:44 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 45m 15s ago.
21:32:48 <bos> wahjava: oh, that's normal.
21:33:20 <bos> wahjava: you want to specify ReuseAddr
21:33:24 <wahjava> bos, normal with all network servers or just the servers written in Haskell ?
21:33:35 <bos> wahjava: in all network servers.
21:33:58 <wahjava> bos, but I don't think I ever specified that in any of the server code I written in C.
21:35:23 <bos> wahjava: nevertheless, it's needed.
21:35:27 <bos> even in C.
21:35:30 <wahjava> I'm not sure, but I think lazy evaluation of haskell is responsible somewhere.
21:36:13 <semicoln> not lazy socket programmer?
21:37:01 <bos> wahjava: you are mistaken.
21:37:30 <wahjava> okay. let me verify it.
21:39:22 <bos> wahjava: google for SO_REUSEADDR
21:39:36 <wahjava> bos, I know about that socket option.
21:39:55 <wahjava> but it is just that I never felt the need to use it in my tiny server programs.
21:51:44 <wahjava> bos, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5333#a5333 -- srv.c, the c program which does something *similar* but isn't behaving same as haskell code.
21:54:18 <bos> wahjava: afaict, you connected to your haskell server before you killed it.
21:54:25 <bos> wahjava: did you do the same with your C program?
21:55:18 <bos> wahjava: from the netstat output that you showed in your first paste, you had a connected socket in TIME_WAIT state
21:55:19 <wahjava> bos, well, i executed 'srv' in one xterm and in another xterm, i did: curl http://localhost:8080/ , which connected to my server and server exited after echoing.
21:55:45 <wahjava> bos, yes, it seems 'hClose h' at line 89 of haskell code is not effective.
21:56:34 <wahjava> preventing socket shutdown process from completion
21:57:23 <bos> are you sure that line was actually executed?
21:59:02 <wahjava> bos, well it should get executed as nothing in the program is preventing it from executing.
21:59:16 <wahjava> bos, but i'm not sure if it executing or not.
22:01:09 <bos> wahjava: that probably doesn't matter anyway. it's normal for a connection to go into TIME_WAIT state when you close it.
22:01:49 <bos> so you need SO_REUSEADDR to ensure that the kernel will allow the server port to be reused if there's a connection in TIME_WAIT state.
22:03:06 * bos <*> bed
22:04:31 <wahjava> bos,  I got it
22:04:36 <wahjava> bos, :-)
22:05:47 <wahjava> bos, when I used curl with 'srv' (the c code), curl after seeing that the first line is not valid HTTP response, initated the close.
22:07:03 <wahjava> bos, but when I used telnet to connect to srv, srv is the one to initiate close, and as srv quits, it reaches into the TIME_WAIT state and I get the same behavior :).
22:07:05 <wahjava> thanks bos.
22:11:04 <Gilly> I'm doing a software with GUI and DB but I'm ending up with most of the code running in IO and there's not really much separation between DB and GUI management. Any ideas how to design this?
22:13:37 <cads> hey, what's a good introductory paper on HM's type system as implemented in haskell? something that'll actually talk a little theory and proof, but not over the top?
22:14:42 <cads> really I just want to learn more about the inference algorithm and type representation
22:15:11 <Gilly> In my program data is pretty much flowing from GUI to DB and back, but this way I won't have a lot of pure code :P
22:15:31 <cads> aren't there functional db wrappers?
22:21:07 <inimino> cads: the Wikipedia page on H-M explains the inference algorithm, with references
22:24:19 <cads> I really need to give that wiki thing more credit
22:26:41 <cads> one day they'll have cool, data carrying holographic tatoos. Then, I can get wikipedia or trillions of pi digits tatooed.
22:28:20 <Adamant> cads: just plug it into your datajack like normal people
22:28:27 <Adamant> :P
22:37:33 <cads> Adamant: I hate how that's been one generation away for two generations now
22:38:06 <Adamant> cads: count on it not happening until we understand the human brain
22:38:12 <cads> I want a fucking brain chip, even if it's only 1.44 mb in all its glory
22:38:40 <Adamant> cads: it could be worse, practical fusion power was invisaged in the 1920's :P
22:38:59 <cads> I'm gonna pine for fusion till I die :(
22:39:22 <cads> of famine.
22:39:24 <Ralith> I'm sure we'll have fusion within 40 years.
22:40:49 <TomMD> @remember Ralith I'm sure we'll have fusion within 40 years.
22:40:49 <lambdabot> I will never forget.
22:40:54 <TomMD> @flush
22:40:55 <lambdabot> Not enough privileges
22:40:58 <TomMD> @damn
22:40:59 <lambdabot> Unknown command, try @list
22:41:47 <Ralith> TomMD: it's a reference :P
22:46:09 <Berengal> We don't need computers that can interface with brains, we need brains that can interface with computers
23:12:21 <mxc> ?seen byogey
23:12:21 <lambdabot> I haven't seen byogey.
23:12:27 <mxc> ?seen byorgey
23:12:27 <lambdabot> byorgey is in #haskell-overflow, #haskell-in-depth, #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 8h 25m 56s ago.
23:35:38 <cads> I hate how asking "what's a good code generator for C" in the actual C channel gets a bunch of huffy responses and no informative answers
23:36:32 <cads> if I ask what's a good code generator for haskell here, I learn about someone's experience with template haskell or some other very cool thing
23:37:14 <trofi^w> @where harpy
23:37:15 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
23:37:54 <cads> requirements: template haskell :D
23:38:32 <cads> see, there's all sorts of that kind of stuff in lots of languages except apparently in C
23:40:05 <trofi^w> @google libvex
23:40:06 <lambdabot> No Result Found.
23:40:13 <trofi^w> @google VEX
23:40:14 <lambdabot> http://www.vexrobotics.com/
23:40:14 <lambdabot> Title: VEX Robotics Design System
23:40:20 <trofi^w> cache miss
23:41:06 <Twey> @hoogle (a -> Bool) -> [a] -> [[a]]
23:41:07 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
23:41:07 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
23:41:07 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
23:41:52 <trofi^w> @where split
23:41:53 <lambdabot> I know nothing about split.
23:42:13 <Twey> Split does only one instance
23:42:14 <Twey> :t split
23:42:15 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
23:42:16 <Twey> :t break
23:42:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:42:23 <Twey> Wrong split *frowns*
23:42:28 <Twey> :t Data.List.splitAt
23:42:29 <lambdabot> forall a. Int -> [a] -> ([a], [a])
23:42:31 <Twey> :t Data.List.split
23:42:32 <lambdabot> Not in scope: `Data.List.split'
23:42:38 <Twey> Hm, maybe it doesn't exist.
23:47:11 <elbar> :t Data.List.Split
23:47:12 <lambdabot> Not in scope: data constructor `Data.List.Split'
23:47:56 <elbar> :t shouldnt work too good on modules i guess ;)
23:47:58 <lambdabot> parse error on input `;'
23:48:58 <elbar> split :: Splitter a -> [a] -> [[a]]
23:49:06 <elbar> looking for something like this?
23:49:48 <TomMD> My view of the XML libraries is that they aren't very integrated with the rest of Hackage.  For example, I don't see any XML package that has Binary instances.
23:50:39 <TomMD> Does anyone have a bandaid solution or am I doomed to writing Binary instances and sending it to a maintainer? (I'd probably go with the 'xml' package on Hackage)
23:53:58 <Twey> You could make them separate packages
23:54:19 * Twey wants instance scoping
23:54:25 <TomMD> Twey: Sure, but I'd rather not do anything at all if there already exists a solution.  I just don't think there is one.
23:55:15 <Twey> I don't think there is one, either.
23:55:40 <Twey> I don't think Data.Binary can automatically derive instances, and I don't think it would help much if it could.
23:56:04 <TomMD> Twey: It can, but it wouldn't help seeing as I need a particular (XML) format.
23:56:20 <Twey> Hm
23:57:08 <TomMD> Oh well - I hacked a simple KML -> ByteString method into my current code so I'll use that for the forseeable future.
23:58:09 <TomMD> The hope was that I'd have a painless path to do a Coordinates -> KML -> ByteString for some useful intermediate representation of KML.  Currently its actually just KML = [Coordinate]
23:59:34 * TomMD falls asleep 
