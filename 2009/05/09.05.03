00:07:27 <dons> openoffice
00:08:00 <ivanm> dons: :o
00:08:16 <ivanm> I always thought Impress' slides looked rather tacky until now... >_>
00:08:25 * ivanm will probably stick to beamer though
00:09:19 <ivanm> that reminds me: I'm doing a talk in a couple of weeks at uni, and was thinking about doing it based on Ralph Hinze's Church numerals theoretical pearl...
00:09:20 <dons> i just find it much faster to compose them. ideally though, i'd like to use inkscape
00:09:35 <dons> that'd be cool. the pearl is very very good
00:09:39 <dons> should be on hackage.
00:09:43 <ivanm> is there an easy-to-understand haskell impl of church numerals (oleg's is a bit too advanced...)
00:09:50 <ivanm> dons: you want a paper on hackage? :s
00:09:56 <dons> i have ralph's code.
00:10:04 <dons> let me find it ...
00:10:45 <ivanm> ta
00:11:36 <dons> http://www.galois.com/~dons/hinze/
00:12:16 <ivanm> are all three of them from that paper?
00:12:25 <ivanm> I don't recall it mentioning memoization... >_>
00:12:44 <mmorrow> <kadaver_> well do you know what i should do?
00:12:53 <mmorrow> kadaver_: not use Data.AVL?
00:13:04 <kadaver_> but i want to
00:13:09 <dons> ivanm: that's what he sent me when i asked for the code from the paper
00:13:16 <mmorrow> kadaver_: why?
00:13:30 <ivanm> dons: none of it looks like anything to do with church numerals... >_>
00:14:00 <dons> Stream
00:14:01 <dons> > instance (Num a) => Num (Stream a) where
00:14:01 <dons> >   (+)          =  zip (+)
00:14:01 <dons> >   (-)          =  zip (-)
00:14:01 <dons> >   (*)          =  zip (*)
00:14:03 <lambdabot>   <no location info>: parse error on input `='
00:14:03 <lambdabot>   <no location info>: parse error on input `instance'
00:14:04 <lambdabot>   <no location info>: parse error on input `='
00:14:04 <lambdabot>   <no location info>: parse error on input `='
00:14:06 <dons> all from the 2008 pearl.
00:14:16 <kadaver_> because im stubborn like a bird locked in a windowhouse
00:14:24 <dons> unless i'm thinking of a different pearl.
00:14:29 <ivanm> dons: yup ;-)
00:14:39 <dons> this is what he presented at ICFP a few months ago
00:14:45 <dons> it was spectacularly well presented
00:14:46 <mmorrow> kadaver_: i would think such a bird wouldn't last long
00:14:54 <ivanm> I'm talking about the one where he re-implements church numerals twice, once from peano arithmetic and the second from the definitions
00:15:13 <dons> ah, right. so a much (?) older one.
00:15:36 <ivanm> hmmm.... I can't find a date on the paper itself
00:15:51 <ivanm> @go "church numerals, twice!"
00:15:54 <lambdabot> http://www.comlab.ox.ac.uk/people/ralf.hinze/publications/Church.pdf
00:15:54 <lambdabot> Title: THEORETICAL PEARL Church numerals, twice!
00:15:59 <ivanm> dons: ^^
00:16:27 <ivanm> dons: so 2005
00:16:55 <ivanm> interesting that papers from 2006 have a blinking "new" image attached... >_>
00:17:29 <mmorrow> kadaver_: looking at the haddocks, that module looks epic to say the least
00:17:54 <kadaver_> :)
00:19:07 <kadaver_> the COrdering thing fax with my head bigtime
00:19:10 <kadaver_> i just dont get it
00:19:29 <Yrogirg> Hello! How do I turn IO ByteString to ByteString?
00:19:53 <mmorrow> @faq How do I turn IO ByteString to ByteString?
00:19:54 <lambdabot> The answer is: Yes! Haskell can do that.
00:20:17 <mmorrow> Yrogirg: you don't :)
00:20:20 <kadaver_> > a <- IO (ByteString x)
00:20:22 <lambdabot>   <no location info>: parse error on input `<-'
00:21:37 <mmorrow> foo :: (ByteString -> a) -> IO ByteString -> IO a; foo f s = do a <- s; return (f s)
00:22:00 <ivanm> mmorrow: well, not safely you don't...
00:22:00 <mmorrow> oops
00:22:04 <mmorrow> foo :: (ByteString -> a) -> IO ByteString -> IO a; foo f s = do a <- s; return (f a)
00:22:19 <ivanm> heh
00:25:45 <mmorrow> dons: did you know that Chan.isEmptyChan blocks if there's already a thread blocked on a readChan on it? (glguy pointed this out to me)
00:27:00 <mmorrow> this seems like a bug to me
00:27:53 <sjanssen> mmorrow: did you find a fix?
00:28:19 <kadaver_> ok  i should jsut pass OC.Eq
00:28:24 <kadaver_> but it doesnt work
00:28:34 <kadaver_> seems liekl a huge blaoted lib that is hard to use
00:28:35 <mmorrow> sjanssen: i have a version where this doesn't happen, and i'm 95% sure there aren't any races, but haven't tested/analyzed it extensively yet.
00:28:39 * mmorrow find the link
00:28:54 <ivanm> mmorrow: a version of your code, or a version of ghc?
00:29:07 <mmorrow> sjanssen: http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/Q.hs
00:29:20 <mmorrow> ivanm: my code
00:29:34 <mmorrow> just s/Q/Chan/ in your head :)
00:30:32 <ivanm> heh
00:32:27 <mmorrow> so the reason that isEmptyChan blocks in the current implem, is that readChan takes the read MVar, and so does isEmptyChan
00:32:41 <mmorrow> clearly this doesn't work
00:33:23 <mmorrow> so in my version, the Chan is empty if and only if the read MVar is
00:34:48 <mmorrow> (and also i'm using IORefs for the inner stuff where Chan uses MVars, because the inner MVars aren't necessary given my implem (?))
00:38:10 <mmorrow> sjanssen: but there isn't much too the code, so it shouldn't be very hard to verify the implem is correct wrt what it's supposed to do
00:38:14 <mmorrow> *to
00:38:25 <kadaver_> man the AVL tree makes no sense
00:38:43 <mmorrow> s/\*to//
00:40:12 <ski> Yrogirg : you can "locally" extract the `ByteString' from `IO ByteString', using e.g. a `do'-block .. but your function still needs `IO Something' in the return type
00:42:58 <Yrogirg> ski: ok thnx I have to thought it over
00:43:41 <ski> Yrogirg : if you have some code that you have trouble with, you could paste it for use to have a look
00:43:44 <ski> @paste
00:43:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:44:03 <ski> s/use/us/
00:44:14 <zoheb> I tried this in GHCi Prelude> sum [1..1000000]
00:44:30 <zoheb> I get *** Exception: stack overflow
00:44:41 <zoheb> Isn't this supposed to work?
00:45:21 <mmorrow> let sum' = foldl' (+) 0
00:45:45 <zoheb> we have to use sum' ?
00:45:51 <mmorrow> the def of sum in the Prelude relies on the compiler's strictness analysis to work
00:46:19 <zoheb> WTH
00:46:32 <zoheb> havent tested with GHC
00:46:34 <Saizan> actually, it works because of RULES
00:46:34 <kadaver_> > foldl' (+) 0 [1..1000000]
00:46:36 <lambdabot>   500000500000
00:46:36 <mmorrow> zoheb: in ghci, the bytecode that's compiled isn't optimized like the machine code is
00:46:40 <kadaver_> > foldl' (+) 0 [1..10000000]
00:46:41 <lambdabot>   50000005000000
00:46:51 <zoheb> hopefully this should work in GHC
00:46:52 <kadaver_> > length 1000000
00:46:54 <lambdabot>       No instance for (Num [a])
00:46:54 <lambdabot>        arising from the literal `1000000' at ...
00:47:02 <zoheb> or do I need -O2 or smthng
00:47:06 <kadaver_> > length [0..1000000]
00:47:06 <mmorrow> zoheb: if you use -O2 it will
00:47:07 <lambdabot>   1000001
00:47:18 <Saizan> -O might be enough
00:47:20 <mmorrow> zoheb: (maybe with -O it also will
00:47:35 <mmorrow> yeah, but i don't see the point in not using -O2 always myself :)
00:47:36 <zoheb> IMHO, sum really should work by default
00:47:47 <mmorrow> zoheb: IMHO too :)
00:47:57 <zoheb> can't the prelude defn be fixed, is it so hard?
00:48:09 <Saizan> well, the prelude is part of the standard..
00:48:43 <zoheb> but I see (replace by faster HBC code) all over the place
00:48:53 <zoheb> one would think
00:48:57 <Saizan> faster code that doesn't change the semantic
00:49:18 <mmorrow> (the semantics being "overflow the stack unless the compiler saves us" ;)
00:49:26 <zoheb> ;)
00:49:26 <Saizan> while switching to foldl' will give different results for some Num instances
00:49:39 <zoheb> floats?!
00:49:52 <Renderwahn> is there a difference between foldl' and foldl?
00:50:00 <mmorrow> @src foldl
00:50:00 <Saizan> ?src foldl
00:50:00 <lambdabot> foldl f z []     = z
00:50:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:50:00 <lambdabot> foldl f z []     = z
00:50:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:50:03 <mmorrow> @src foldl'
00:50:03 <lambdabot> foldl' f a []     = a
00:50:03 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:50:18 <mmorrow> or equivalently
00:50:26 <Saizan> Renderwahn: with foldl' the accumulator gets reduced to WHNF at each step
00:50:39 <Saizan> Renderwahn: rather than building a big thunk
00:50:40 <mmorrow> foldl' f !a (x:xs) = foldl' f (f a x) xs
00:51:05 <sjanssen> Saizan: foldl' will give different results from foldl?
00:51:37 <zoheb> how can we get diff results?
00:51:40 <mmorrow> sjanssen: if you can construct a pathological enough Num instance, it's theoretically possible
00:51:48 <Saizan> sjanssen: i guess it's pretty easy to conjure a Num instance that does that
00:51:57 <mmorrow> sjanssen: but i argue why cater to those by default?
00:52:03 <sjanssen> mmorrow, Saizan: uh, no I don't think that is right
00:52:12 <sjanssen> unless unsafePerformIO and the like are allowed
00:52:18 <mmorrow> sjanssen: ooh, if it isn't that' seven better!
00:52:32 <mmorrow> then there's no valid argument for not changing the Prelude def
00:52:33 <sjanssen> oh, lazy functions, nevermind
00:52:47 <Saizan> i don't agree to cater to those, but you need to go and change the standard, which takes some effert
00:52:49 <sjanssen> eg. if (+) is lazy in an argument
00:52:51 <Saizan> *effort
00:52:58 <sjanssen> but who cares about those
00:55:29 <monadic_kid> is there away to force cabal install to use newer packages for dependencies that want older ones?
00:55:52 <Saizan> no
00:56:07 <Saizan> you've to unpack the package and modify the .cabal file to try that
01:06:31 <JoshTriplett> Do any Haskell bindings exist for WebKit or Gecko?
01:06:37 <JoshTriplett> I can't seem to find any.
01:06:56 <inimino> haven't heard of any
01:09:31 <mmorrow> JoshTriplett: if you're thinking of writing such a binding, that would be pretty cool :)
01:09:53 <JoshTriplett> inimino, mmorrow: I had a feeling this would end with me writing a binding, yeah. :/
01:09:58 <sjanssen> JoshTriplett: I think gtk2hs has mozembed bindings
01:10:11 <mmorrow> JoshTriplett: heh
01:10:13 <JoshTriplett> sjanssen: Oh, good.  Looking...
01:10:21 <mmorrow> oh yeah, there's mozembed
01:10:47 <mmorrow> (although i haven't managed to build that since 6.6 (not that it's broken, just that i have no idea howtf to get it to build))
01:12:00 <mmorrow> i can't seem to manage to figure out what libs it needs (from what i've read it seems like i need to manually build (parts of) firefox?? (that can't be right?))
01:12:29 <JoshTriplett> mmorrow: Normally such things should build against xulrunner.
01:13:00 <mmorrow> JoshTriplett: hmm, interesting.
01:13:28 <mmorrow> JoshTriplett: woot, yum has that -devel pkg available...
01:14:14 <mmorrow> oh crap, i already have that installed..
01:14:28 <mmorrow> (which means that it didn't work when i tried to build mozembed)
01:14:29 <ivanm> didn't someone implement church numerals in the type system a few years ago? in a TMR article or something?
01:15:04 <JoshTriplett> ivanm: ISTR seeing several such implementations.
01:15:27 <JoshTriplett> mmorrow: Yeah, a look through the Debian changelog for gtk2hs turned up this entry:
01:15:28 <JoshTriplett>   * Removed package libghc6-mozembed-dev, since this version of Gtk2hs is
01:15:28 <JoshTriplett>     not compatible with xulrunner-dev in sid. Thanks to Mike Hommey and
01:15:28 <JoshTriplett>     Duncan Coutts. (Closes: #480805)
01:15:31 <ivanm> JoshTriplett: in the _type system_?
01:15:50 <mmorrow> JoshTriplett: hmm
01:16:21 <mmorrow> (i was trying to build from source, but maybe this is fixed in a newer version of gtk2hs or something)
01:16:26 <JoshTriplett> ivanm: Hmmm.  Perhaps not Church numerals.  I recall seeing the classic implementation of numbers in the type system using Zero and Succ; not the same thing.
01:16:28 * mmorrow tries
01:17:12 <ivanm> JoshTriplett: I recall one implementation (not sure if it was actually church numerals of peano arithmetic), but not "several" :s
01:17:38 <sjanssen> ivanm: peano numbers with type classes is a beginner's exercise
01:17:53 <JoshTriplett> ivanm: Seems like every other type-level programming code I've seen includes numbers...yeah, what sjanssen said. :)
01:18:03 <ivanm> is it? oh, I"ve never seen such an exercise before... >_>
01:18:16 <JoshTriplett> sjanssen: FSVO "beginner". ;)
01:18:21 <sjanssen> JoshTriplett: naturally
01:18:39 <sjanssen> ivanm: where beginner = type system programming beginner
01:19:18 <ivanm> ahhh
01:21:35 <PeakerWork> BONUS: the new sections in your tutorial are very cool. very very cute pictures :-)
01:26:06 <ivanm> PeakerWork: you're at work on a _sunday_? :s
01:29:25 <Aquamarine> Ý.
01:29:25 <Aquamarine> Ý.
01:29:25 <Aquamarine> Ý.
01:29:26 <Aquamarine> Ý.
01:29:26 <Aquamarine> Ý.
01:29:26 <Aquamarine> Ý.
01:29:58 <monadic_kid> whats the font used on LYAH? is it consola?
01:30:06 <monadic_kid> i mean for the code snippets
01:30:07 <p_l> ivanm: inb4 "I'm a priest"
01:30:09 <Adamant-gay> Adamant Hello.
01:30:18 <ivanm> p_l: hmmm?
01:31:08 <p_l> ivanm: It reminds me of an exchange on IRC "Ok, time to sleep, have to go to fucking work at 6:00 am tommorrow" "Who the hell works on sunday!?" "I'm a priest"
01:31:13 <Adamant-gay> "/dh,blfdjklhfg
01:31:13 <Adamant-gay> fgj
01:31:13 <Adamant-gay> nfg
01:31:13 <Adamant-gay> jm
01:31:13 <Adamant-gay> ghkm
01:31:14 <Adamant-gay> gh
01:31:16 <Adamant-gay> l,hg
01:31:18 <Adamant-gay> j
01:31:20 <Adamant-gay> l,hj
01:31:22 <Adamant-gay> m,
01:31:24 <Adamant-gay> gn
01:31:26 <Adamant-gay> f
01:31:27 <ivanm> wtf?
01:31:28 <Adamant-gay> nm g
01:31:30 <Adamant-gay> fh
01:31:32 <Adamant-gay> n
01:31:34 <Adamant-gay> fn
01:31:36 <Adamant-gay> f
01:31:36 <ivanm> Adamant-gay: you right there?
01:31:39 <Lemmih> ?where ops
01:31:39 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
01:31:39 <lambdabot> mauke
01:31:40 <Adamant-gay> f
01:31:40 <monadic_kid> no one with admin rights?
01:31:41 <ivanm> p_l: heh
01:31:42 <Adamant-gay> g
01:31:44 <Adamant-gay> ng
01:31:44 <Adamant> annoying.
01:31:46 <Adamant-gay> h,
01:31:48 <Adamant-gay> fgh
01:31:50 <Adamant-gay> ,
01:31:50 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
01:31:52 <Adamant-gay> hg,
01:31:54 <Adamant-gay> h,
01:31:56 <Adamant-gay> gh,
01:31:58 <Adamant-gay> g
01:32:01 <Adamant-gay> hm
01:32:02 <Adamant-gay> gh
01:32:04 <Adamant-gay> mgh
01:32:06 <Adamant-gay> n
01:32:10 <Adamant-gay> d
01:32:12 <Adamant-gay> n
01:32:14 <Adamant-gay> dg
01:32:17 <Adamant-gay> hngf
01:32:17 <p_l> looks like vicious trashing on keyboard... he might have an attack of sorts ;-)
01:32:18 <Adamant-gay> hm
01:32:19 --- mode: ChanServ set +o dibblego
01:32:20 <Adamant-gay> g
01:32:22 <Adamant-gay> hmk
01:32:23 --- mode: dibblego set +b *!*i=irc@*.kraslan.ru
01:32:23 --- mode: ChanServ set +o sjanssen
01:32:24 <Adamant> nn, give it up.
01:32:25 <ivanm> dibblego: \o/
01:32:30 --- kick: Adamant-gay was kicked by dibblego (dibblego)
01:32:41 --- mode: ChanServ set -o sjanssen
01:32:45 <kadaver_> how can you set background in gtk2hs?
01:32:47 <p_l> \o/
01:32:53 <sjanssen> Lemmih: you don't have ops?
01:33:00 <Adamant> I think it's a dude in #guns who's pissed off I was talking down on white power types.
01:33:06 <ivanm> Adamant: heh
01:33:21 <monadic_kid> so yeah
01:33:22 <ivanm> Adamant: so of course he comes in here to piss everyone else off?
01:33:39 <monadic_kid> LYAH code snippets the font is it consola?
01:33:43 <Adamant> ivanm: second time he's done this, last time was trying to flood me with DCC's
01:33:50 <Lemmih> sjanssen: Nope, I'm a lowly foot soldier.
01:33:51 <p_l> ivanm: insecurity knows no bounds
01:34:01 <sjanssen> Lemmih: let's see what we can do about that :)
01:34:08 <kadaver_> adamant: you are just soooo gay
01:34:13 --- mode: dibblego set -o dibblego
01:34:29 <Adamant> kadaver_: apparently, who knew
01:34:38 <Adamant> :P
01:35:15 <araujo> haskell.org down?
01:35:20 <kadaver_> you doing shooting sports or you are just from texas?
01:35:55 <Adamant> kadaver_: I like guns, shoot me. :P
01:36:13 <ehamberg> monadic_kid: check the css...
01:36:26 <ehamberg> font-family: "Consolas", monospace;
01:36:37 <Adamant> kadaver_: he's not representative of #guns thankfully.
01:38:22 <kadaver_> how did you shuffle a list again?
01:46:10 <PeakerWork> ivanm: I'm in Israel
01:46:18 <PeakerWork> ivanm: Friday/Saturday are our days off
01:47:13 -ChanServ(ChanServ@services.)- Saizan set flags +votriA on Lemmih.
01:53:08 <PeakerWork> Adamant: You hang out in channels that *have* "white power types"? :)
01:53:29 * JoshTriplett tries hacking the current Debian gtk2hs package to build with xulrunner-dev.
01:53:33 <Adamant> PeakerWork: he tried to keep it under wraps
01:54:01 <p_l> I'm not sure if you can really avoid bumping into one except in obscure places..
01:54:36 <PeakerWork> p_l: Usually if you're in channels that correlate well with intelligence most are filtered, I'd guess
01:55:44 <p_l> PeakerWork: then one will follow someone else to said channel...
02:03:29 <monadic_kid> i can't believe out of all the things added to C++0x the standards committee didn't learn from our previous/current experinice that operator overloading is limied, we should be able to define arity, associativity, precedence, arity not abuse expression templates to try and emulate those
02:03:35 <thoughtpolice> fun: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4510#a4510
02:03:44 <thoughtpolice> it would be really cool to hook that into the cmonad package or something...
02:04:29 * JoshTriplett watches the build process of gtk2hs chug along.
02:05:43 <JoshTriplett> mmorrow: Seems to have configured and c2hs'd correctly.  Waiting to see if the resulting .hs builds.
02:06:06 <JoshTriplett> mmorrow: (It also ought to use mozilla-gtkmozembed-embedded rather than mozilla-gtkmozembed, but let's see if it works at all first.)
02:15:11 <ivanm> PeakerWork: ahhh, fair enough
02:16:17 <ivanm> PeakerWork: what's #enough about?
02:27:09 <mmorrow> JoshTriplett: very cool
02:27:12 * mmorrow waits
02:27:41 <JoshTriplett> mmorrow: It actually linked just fine, but then I got this: haddock: internal Haddock or GHC error: /usr/lib/ghc-6.10.1/haddock/array/array.haddock: openBinaryFile: does not exist (No such file or directory)
02:28:18 <JoshTriplett> mmorrow: Sigh.
02:28:36 <mmorrow> grr. did that make your build error out though?
02:29:11 <Saizan> JoshTriplett: i think there's a configure option to avoid building documentation
02:29:21 <JoshTriplett> mmorrow: Yup.
02:29:28 <mmorrow> JoshTriplett: grrrrrr
02:29:37 <JoshTriplett> Saizan: Yeah, but that doesn't help me build the Debian package...
02:29:43 <JoshTriplett> mmorrow: My reaction exactly.
02:29:56 <Saizan> JoshTriplett: install libghc6-array-doc ?
02:30:18 <JoshTriplett> Saizan: No such package.  That should live in ghc6-doc.
02:30:39 <Saizan> fun
02:30:58 <JoshTriplett> Joy.  Apparently it should have looked in /usr/share/doc/ghc6-doc/libraries/array/array.haddock .
02:31:05 <JoshTriplett> Rather than /usr/lib/ghc-6.10.1/haddock/array/array.haddock .
02:31:09 <JoshTriplett> No clue how to tell it that.
02:31:28 <mmorrow> imo it's a bug if cabal calls the build a failure if the docs fail to build
02:31:47 <Saizan> mmorrow: gtk2hs is not built with cabal
02:31:58 <JoshTriplett> Well, parts of it use cabal, AFAICT.
02:32:15 <mmorrow> Saizan: ahh. ok, then a bug if whatever build system it uses does that.. :)
02:32:38 <Saizan> JoshTriplett: what ghc-pkg describe array says about haddock-interface ?
02:33:02 <PeakerWork> ivanm: a project to rewrite the software world :)
02:33:04 <JoshTriplett> haddock-interfaces: /usr/lib/ghc-6.10.1/haddock/array/array.haddock
02:33:09 <PeakerWork> ivanm: with too little time to do it
02:33:23 <JoshTriplett> Saizan: Apparently ghc-pkg is full of lies. :)
02:33:36 <mmorrow> heh, liar!
02:34:34 <Saizan> JoshTriplett: you can ghc-pkg describe array > file, $editor file, ghc-pkg update file, to correct that
02:35:05 <JoshTriplett> Saizan: Or I can "reportbug ghc6" and call it a night. ;)
02:35:20 <Saizan> assuming the docs under /usr/share refer to the 6.10.1 ghc
02:35:47 <JoshTriplett> Saizan: ghc-pkg *does* say: haddock-html: /usr/share/doc/ghc6-doc/libraries/array
02:36:45 <JoshTriplett> Oh, looks like a bug report already exists.
02:36:56 <JoshTriplett> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=517514
02:38:01 <kadaver_> how do I compile Gtk? i forgot
02:39:29 <JoshTriplett> Saizan, mmorrow: And sure enough, purging and reinstalling ghc6 fixes the haddock paths.  Rebuilding gtk2hs now...
02:39:55 <mmorrow> nice
02:42:06 <kadaver_> and how do you call System.Random.Shuffle?
02:43:19 <JoshTriplett> kadaver_: http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/System-Random-Shuffle.html
02:44:47 * JoshTriplett wonders if anyone has written a ccache-equivalent for Haskell...
02:45:05 <kadaver_> yeah
02:45:16 <kadaver_> but doesnt specify hw to calllit
02:45:41 <JoshTriplett> kadaver_: The types seem pretty obvious, but hit the "source" link for comments (apparently not formatted well for Haddock).
02:47:37 * JoshTriplett wonders about the #haskell-in-depth mentioned in /topic.
02:48:39 <JoshTriplett> The /topic of said channel doesn't quite make it clear: channel for in-depth discussion of introductory topics to de-newbie #haskell, or channel for in-depth discussion of advanced topics to de-expert #haskell? ;)
02:49:15 <kadaver_> the link is dead
02:49:27 <kadaver_> and it doesnt make it clear what dimensions the second lsit should have
02:49:35 <kadaver_> or what those indices should be
02:50:47 <Saizan> JoshTriplett: the latter, since it can become pretty hard to have slow discussions here
02:52:01 <JoshTriplett> Saizan: Right.  They tend to get sidetracked with lambdabot-fueled "101 ways to implement such-and-such one-liner function" exercises. ;)
02:54:19 <Asztal> kadaver_: look at the source, the comments explain it
02:54:49 <Asztal> it doesn't use haddock-style comments
03:02:52 <Athas> Is there a way to give a field in a record a default value, or otherwise supress the warnings about uninitialisation of the field?
03:04:03 <JoshTriplett> Athas: No.  Yes, but you wouldn't want to.
03:04:12 <Athas> How come?
03:04:36 <JoshTriplett> Athas: Because you generally want to initialize all fields in a record, so those warnings usually mean you did something wrong.
03:05:12 <Athas> Agreed, but in this case the record is only meaningful when passed to another function, which will then fill in the blanks, so to speak.
03:05:40 <JoshTriplett> Athas: If you usually use the same values for various fields in a record, consider defining a defaultFoo value with the defaults, and basing your structures on that.
03:06:05 <Athas> Yeah, I'm just wrapping it in a function now.
03:06:06 <JoshTriplett> Athas: defaultFoo { someField = specialValue }
03:06:55 <JoshTriplett> Athas: Can you give more specific details, or paste your code on hpaste?
03:07:31 <yitz> Athas: if there really is no meaningful default value, you can say someField=undefined, but that can cause your program to crash if you aren't careful.
03:07:39 <monadic_kid> you could do something like this foo myRectod = myRecord { someMember = <-some-value> }
03:07:58 <Athas> Well, it's for an extensible library.  The user of the library would define a class method that returned a record value, but one of the fields could technically be assigned a value by the surrounding machinery without explicitly being mentioned.
03:08:17 <Athas> As a solution, I have now defined a simple function that the user can use instead of explicit record syntax.
03:09:03 <JoshTriplett> Athas: Why not just let the user use record syntax?  Seems easier.
03:09:38 <Athas> Because they'd either have to define the value for a field that could easily be inferred by code, or get a big and ugly "undefined field"-warning.
03:09:43 <Athas> It's sort of an UI issue.
03:10:55 <JoshTriplett> Athas: No, I mean why not let the user use record update syntax on some existing record with that field filled in?
03:11:16 <JoshTriplett> Athas: Can you clarify what you mean by "assigned a value by the surrounding machinery?
03:11:18 <JoshTriplett> "
03:11:50 <Athas> Sure.  The value of the field is the value of the expression 'reify (undefined :: t)', where 't' is a statically bound type variable.
03:12:01 <Athas> That type variable is bound by the instance declaration.
03:12:30 <Saizan> that variable won't appear in the type of the record?
03:12:32 <Athas> Indeed, using update syntax on an existing record should work too.
03:12:50 <Athas> No.
03:13:43 <JoshTriplett> Athas: I take it that you don't mean the "reify" from Template Haskell?
03:13:54 <yitz> Lately computer grinds nearly to a halt whenever ghc links. Seems to work OK otherwise. Any ideas?
03:14:23 <Saizan> yitz: try gold
03:14:30 <Athas> Right, it's a function that constructs a representation of a Haskell type in an lower language.
03:14:54 <JoshTriplett> Athas: Sounds fun. :)
03:15:03 <yitz> gold?
03:16:05 <Athas> JoshTriplett: it certainly is!  Though I can't take credit for the structure of the system itself, it's a tool called Flask (written by Geoffrey Mainland) for writing reactive functional programs.
03:16:19 <Athas> I must admit that jumping straight into this as a mostly Haskell newbie has been very enlightening.
03:16:35 <Athas> I never thought about exploiting the type system like that before.
03:16:46 <blackh> yitz: How much RAM does your machine have?
03:16:49 <JoshTriplett> Athas: OK, I think I get it now, mostly.  So, you have class Foo ... t ..., and instance declarations for Foo need to return a value of record type, one of the fields of which could get filled in by the caller of the typeclass function using reify?
03:17:02 <Athas> JoshTriplett: right, exactly.
03:17:20 <monadic_kid> Athas: you don't sound like a haskell newbie to me ;)
03:17:21 <JoshTriplett> Athas: And you want to find some way that the instance declarations could fill in all but that field of the record, without getting a warning.
03:17:45 <yitz> blackh: not enough. I think 768M.
03:17:46 <Saizan> yitz: the new linker in binutils
03:17:48 <Athas> monadic_kid: I have some SML and a lot of Lisp experience, so I'm used to things hurting the mind to begin with!
03:17:48 <JoshTriplett> Athas: What type does the record have?
03:18:13 <yitz> Saizan: how do I get ghc to use that instead?
03:18:16 <Athas> JoshTriplett: I already came up with a solution to this problem, but thanks anyway.
03:18:35 <JoshTriplett> Athas: OK.
03:18:51 <kadaver_> i can make shuffle' work but i really dont get shuffle
03:18:58 <monadic_kid> Well my first functional language was SML, then i did abit of common lisp and scheme
03:19:14 <JoshTriplett> kadaver_: shuffle takes a list and an equal-length list of numbers which specify how to shuffle the first list.
03:19:14 <Athas> This is what I eventually ended up with: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4512#a4512
03:19:22 <blackh> yitz: For comparison, I've got space on a virtual server with 384MB and when it links it pretty much grinds to a halt. I can't even build HXT at all. I'm pretty sure you need more.
03:19:25 <Athas> I think that's fairly elegant as a user interface.
03:19:27 <Saizan> yitz: well, in my experience if you enable gold while building binutils it'll replace the standard "ld" so ghc will just pick it
03:20:19 <kadaver_> yeah i tried that and several variations, nothing works
03:20:24 <wli> SML was my first FP language, too.
03:20:33 <blackh> Saizan: Brillaint! Thanks for the tip about gold!
03:20:42 <monadic_kid> i still like SML
03:21:08 <Athas> Me too.  I think SML is a very good introduction to functional programming.
03:21:18 <Athas> And beyond that, functors are really really cool.
03:21:54 <Saizan> @quote functor
03:21:54 <lambdabot> Anonymous says: A monad is a functor from a category to itself. Honestly, I don't know how I could make this any simpler.
03:21:56 <JoshTriplett> Athas: Looks pretty reasonable, other than the possible confusion between the two values of type Maybe H.Var.
03:22:35 <JoshTriplett> Athas: The record syntax seems like a win for avoiding that kind of confusion.
03:22:44 * JoshTriplett thinks about whether some way exists to do what you want without a warning.
03:22:53 <Athas> I agree.  That is somewhat undesirable.
03:23:02 <monadic_kid> i still like scheme as well
03:23:46 <Athas> I like Lisp for its extreme expressivity, but I think it's easier to make Haskell more powerful, than to make Lisp more statically safe.
03:23:58 * yitz looks for gold in debian
03:24:07 <monadic_kid> parentheses doesn't bother me at all
03:24:51 <Athas> I prefer s-expressions over traditional syntax as well.
03:25:13 <Athas> But I expect I would not be popular if I wrote Haskell with the Liskell syntax.
03:25:48 <kadaver_> do you like clojure? a wrote an mp3plsayer in clojure, fairly heavy java interop, didnt like the results s much. most of all the code is really ugly:(
03:25:57 <JoshTriplett> @remember Athas I like Lisp for its extreme expressivity, but I think it's easier to make Haskell more powerful, than to make Lisp more statically safe.
03:25:57 <lambdabot> Done.
03:26:23 <Saizan> http://www.willamette.edu/~fruehr/haskell/evolution.html <- second stage
03:26:38 <JoshTriplett> Athas: I take it that the class Event has a fundep e -> t ?
03:27:11 <JoshTriplett> Athas: Since it appears that having the type e lets you use t without having anything that constrains t.
03:27:45 <JoshTriplett> Athas: If so, I have a suggestion which might work more cleanly.
03:28:31 <Athas> JoshTriplett: yes, it does.
03:28:54 <yitz> hmm. yeah it's binutils-gold. but...
03:29:13 <yitz> it "currently fails to link some applications and libraries".
03:29:24 <yitz> gold 2.19.1
03:29:39 <yitz> (in debian testing)
03:30:05 <kadaver_> seriously shuffle must be wrong
03:30:18 <JoshTriplett> kadaver_: Pastebin?
03:30:39 <yitz> but it may be a choice between that and wasting money on more SDRAM for my old box.
03:30:45 <yitz> @paste
03:30:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:31:30 <JoshTriplett> Athas: OK.  Then I think you could define a function which just returns an ERep FladuinoM with the e_type field filled in.  The instance declarations could then do this: setupEvent e = return $ event { e_value = val, e_predicate = pred, e_id = show e }
03:31:38 <yitz> kadaver_: shuffle is really easy to write, most people have been using their own since long before there was ever that library.
03:32:19 <JoshTriplett> Athas: Does that make sense?
03:33:22 <Athas> It does, yes.
03:33:27 <JoshTriplett> Athas: You can avoid the warnings in the definition of "event" by using undefined.
03:33:35 <JoshTriplett> Athas: For the fields you don't fill in, I mean.
03:34:05 <Athas> But ideally I also want to hide the 'show e' stuff, since I like to pretend that I'm going to come up with a better way for unique identification.
03:34:32 <JoshTriplett> Athas: Ah.  In that case, you can do this:
03:35:00 <JoshTriplett> event e = ERep { e_value = undefined, e_predicate = undefined, e_id = show e, e_type = reify (undefined :: t) }
03:35:29 <JoshTriplett>     setupEvent e = return $ (event e) { e_value = val, e_predicate = pred }
03:35:55 <Athas> Hah, I like that one.
03:36:41 <kadaver_> yitz: so ? a shuffle might be easy to write. a perfect is a different story
03:37:05 <JoshTriplett> If you want extra bulletproofing, you could replace the usage of undefined with error "event used without filling in e_value and e_predicate".
03:37:22 <JoshTriplett> Or rather, e_value in one case and e_predicate in the other case.
03:37:59 <yitz> kadaver_: how perfect do you want it to be? I'm not sure there's anything special about the one on hackage.
03:38:09 <kadaver_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4513#a4513
03:41:00 <JoshTriplett> mmorrow: Looks like gtk2hs built just fine.
03:41:04 <JoshTriplett> mmorrow: Testing...
03:41:44 <yitz> kadaver_: bleh. you shouldn't get an error like that. but you're probably using it wrong - don't you need to pass it a random generator?
03:41:58 * yitz looks for the package docs
03:43:30 <JoshTriplett> mmorrow: Fail.
03:43:36 <JoshTriplett> mmorrow: ./testembedmoz: error while loading shared libraries: libxul.so: cannot open shared object file: No such file or directory
03:43:42 <yitz> oh, I see.
03:44:09 <yitz> so it looks like there may be a bug there.
03:44:33 <yitz> kadaver_: you would normally use shuffle' anyway, right?
03:44:36 <kadaver_> shuffle :: [a] -> [Int] -> [a]
03:46:43 <kadaver_> how do I get the global random nbrgen?
03:49:32 <kadaver_> well i remember some issue like this before
03:49:44 <kadaver_> but it wasnt a bug it should be used in some other way
03:49:58 <kadaver_> anyway what should I pass to ghc when i compile gtk?
03:54:12 <JoshTriplett> kadaver_: http://hackage.haskell.org/packages/archive/random/1.0.0.1/doc/html/System-Random.html#v:RandomGen
03:54:59 <JoshTriplett> kadaver_: getStdGen.
03:55:23 <JoshTriplett> kadaver_: But System.Random.Shuffle looks broken in that regard.
03:55:33 <JoshTriplett> kadaver_: It doesn't give you the modified generator back.
03:55:43 <yitz> @type newStdGen
03:55:44 <lambdabot> IO StdGen
03:55:51 <yitz> kadaver_: ^^
03:56:20 <JoshTriplett> yitz: Yeah, that would work; it just seems annoying to have to split the standard generator just to shuffle a list.
03:56:30 <yitz> kadaver_: get that in the IO monad, then pass it to your pure function that needs it.
03:57:39 <Athas> Huh, why has root taken ownership of my GHC package.conf?
03:58:22 <Athas> 'cabal install'ing a library (as non-root) does it.
03:58:27 <Athas> The package.conf in my homedir, mind you.
03:58:28 <kadaver_> anyone compiled a haskell progrm using gtk on windows?
03:59:34 <yitz> JoshTriplett: yeah. I'd say forget it, just write it, it's only a few lines.
03:59:50 <JoshTriplett> yitz: Yeah.
04:02:27 <kadaver_> anyone compiled a haskell progrm using gtk on windows?
04:02:37 <kadaver_> i have to pass what to ghc?
04:02:48 <kadaver_> $ ghc --make -O2 Main.hs
04:02:48 <kadaver_> Main.hs:4:7:
04:02:48 <kadaver_>     Could not find module `Graphics.UI.Gtk':
04:02:48 <kadaver_>       Use -v to see a list of the files searched for.
04:03:01 <EvilTerran> kadaver_, do you have gtk2hs installed?
04:03:10 <Athas> How is cabal even able to create a file owned by root?  I have it installed locally, so the cabal binary is owned by me..
04:03:45 <QtPlaty[HireMe]> Athas: it can't if installed locally
04:04:09 <kadaver_> yes
04:04:19 <Saizan> Athas: the global package.conf is owned by root by default
04:04:20 <kadaver_> i used it before
04:04:25 <kadaver_> i had to compile it
04:04:32 <kadaver_> dont remember how
04:04:45 <Athas> Well, when I do 'cabal install' on this library, it turns over ownership of ~/.ghc/x86_64-linux-6.10.1/package.conf to root:root.  It's never done that before.
04:05:30 <Athas> Yet I can still use 'cabal install' (as non-root) to modify the file again!
04:05:32 <EvilTerran> kadaver_, try following the advice in the error, and see where it looks for that module
04:05:33 <Athas> This is very odd.
04:06:29 <JoshTriplett> Athas: Does "./Setup.hs install" or similar have the same problem?
04:07:12 <Athas> JoshTriplett: yes.
04:07:40 <JoshTriplett> Athas: Wow.  I don't see how "./Setup.hs install" could make a file owned by root without running as root. ;)
04:07:55 <Athas> Yeah, I don't get this either.
04:07:56 <JoshTriplett> Athas: Something setuid somewhere.
04:08:05 <Athas> I shall perform an exorcism!
04:08:47 <Saizan> does it have custom code in Setup.hs?
04:13:32 <yitz> kadaver_: paste what you get when you type the command "ghc-pkg list" and also "ghc-pkg --user list"
04:16:40 <kadaver_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4515#a4515
04:17:05 <kadaver_> $ ghc-pkg --user list
04:17:05 <kadaver_> C:\Users\saftarn\AppData\Roaming\ghc\i386-mingw32-6.10.2\package.conf:
04:17:18 <kadaver_> nothing more
04:17:30 <kadaver_> the link paste is ghv-pkg list
04:18:01 <Saizan> you've to reinstall gtk2hs then
04:18:19 <Saizan> it should be a matter of ./configure && make && sudo make install
04:18:20 <kadaver_> bah why i dont remember how
04:18:27 <kadaver_> windows
04:18:45 <Saizan> ah, then there's an installer .exe
04:26:45 <kadaver_> doesnt work with 6.10.2?
04:28:10 <Saizan> probably not yet
04:30:27 <kadaver_> does installing 6.10.1 over 6.10.2 do soemthing?
04:30:35 <kadaver_> how do I choose which to compile with?
04:32:22 <Saizan> kadaver_: they are installed in different directories, so you can choose by using the full path
04:37:31 <ErhardtMundt> hi
04:43:33 <ttmrichter> Are there any up-to-date instructions (i.e. post 6.6.2) for bootstrapping GHC onto a new platform?
04:44:08 <ttmrichter> The instructions at haskell.org have a note that they apply only to 6.0.1 to 6.6.2.
04:53:48 <Muzzleflash> Hi.. Is there default/standard function that does the following: occurrencs needle haystack = length (filter (\x -> x==needle) haystack) ?
04:55:49 <byorgey> Muzzleflash: nope
04:56:16 <olsner> @ty count
04:56:17 <lambdabot> Not in scope: `count'
04:56:25 <byorgey> hi ErhardtMundt
04:56:48 <Muzzleflash> I really thought there was a word like this.
04:56:56 <Muzzleflash> Since most languages have one
04:58:04 <Berengal> You can get by easily with count = (length.).filter.(==)
04:58:29 <byorgey> argh, pointless style is pointless here.
04:58:39 <luqui> oh how i loathe dot sections
04:58:49 <luqui> count x = length . filter (== x)
05:00:46 <Berengal> How about something like map (head *** length) . group . sort, to get the count of all different elements?
05:03:35 <luqui> dot sections and flip are where I draw the line, typically
05:03:37 <olsner> that would probably be less efficient if you actually only want the count of one element
05:03:40 <luqui> that looks pretty to me :-)
05:05:00 <olsner> count f = length . filter f seems more logical to me
05:05:01 <Berengal> olsner: Very likely, but it's also likely that you don't need the count of just one element
05:05:14 <luqui> i think the only case where it would be equal is when there is only one occurrence, and that element is the least one
05:05:28 <Muzzleflash> I do need to count more than one element
05:05:43 <Muzzleflash> Just thougt making a function that count one first made sense
05:06:29 <luqui> > Map.fromListWith (+) . map (\x -> (x,1)) $ [3,1,4,1,5,9,2,6,5,3,5]
05:06:30 <lambdabot>   fromList [(1,2),(2,1),(3,2),(4,1),(5,3),(6,1),(9,1)]
05:06:52 <luqui> with the advantage that it's in a Data.Map already, which is where I would want it :-)
05:07:11 <Berengal> That also works
05:08:38 <olsner> at least if the data type has an Ord instance
05:09:40 <luqui> here's a somewhat related question that i've been pondering:  is there a type which has a total Eq, but no Ord (implementable, as opposed to implemented)?
05:10:38 <Berengal> I was going to suggest (), but it does actually have a Ord instance...
05:10:57 <olsner> I think every possible representation (sum and product types + unit) does have at least one Ord instance
05:11:29 <Berengal> Functions don't have neither Eq nor Ord
05:11:54 <luqui> neither do infinite streams...
05:11:58 <Berengal> How about a syntax tree?
05:12:25 <luqui> uh... the deriving (Ord) would be fine...
05:12:38 <Berengal> Yeah, but it would be nonsensical
05:12:51 <luqui> not really
05:12:54 <luqui> lexicographic ordering
05:12:56 <olsner> luqui: aren't lists infinite streams? lists have Ord instances
05:13:05 <luqui> olsner, yeah, but the functions aren't total
05:13:10 <luqui> > [1..] < [1..]
05:13:25 <lambdabot>   thread killed
05:13:27 <Berengal> Infinite lists can't be ordered, but finite ones can
05:13:27 <olsner> right, Eq isn't total for lists
05:13:39 <olsner> > [1..] < [2..]
05:13:40 <lambdabot>   True
05:13:56 <luqui> actually all unequal infinite lists can be compared
05:14:09 <luqui> i.e. equality is "closed" on infinite lists
05:14:34 <Berengal> Uh, yeah, I meant "ordered reliably", as in it isn't a total function...
05:14:37 <luqui> this is getting closer to my question :-)
05:14:50 <Muzzleflash> ooops just wrote [1..] in GHCi
05:14:58 <Muzzleflash> It ain't got writer's block
05:15:09 <luqui> heh
05:15:11 <ski> hm .. istr one can do something like `instance (Compact a,Eq b) => Eq (a -> b)' ..
05:15:34 <ski> (maybe needs `Overt a', too .. or something somewhat stronger than `Compact a')
05:16:44 <olsner> I kind of hate it when a normal discussion eventually spins off into a discussion of either how many bottoms a type has or the behaviour of different functions on bottoms
05:16:47 <ski> (luqui : you mean apartness is semi-computable / observable)
05:17:17 <luqui> f == g  =  forall x in A, forall y in A, f x == g x
05:17:37 <luqui> Compact a, Eq b (= Discrete b) looks fine
05:17:55 <olsner> where does Compact come from?
05:17:57 <luqui> olsner, i think you need to redefine "normal" for yourself :-)
05:18:06 <luqui> olsner, i don't think anybody has implemented this yet
05:18:08 <ski> f == g = forevery $ \a -> f a == g a
05:18:18 <luqui> I was working on topology-extras, which had this kind of stuff
05:18:24 <luqui> but blocked on a stable unamb...
05:18:55 <luqui> er yeah, superfluous y
05:19:07 <ski> Martin Escardó <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> Seemingly impossible functional programs, <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> A Haskell monad for infinite search in finite time
05:19:31 <luqui> and more generally, all the Abstract Stone Duality stuff
05:19:45 <ski> *nod*
05:20:55 <ski> (i'm not sure whether `Compact' should be a decidable or a semi-decidable universal quantification .. possibly the latter)
05:21:06 <luqui> ski, semidecidable
05:21:10 <ski> ok, ty
05:21:14 <luqui> overt is semidecidable existential
05:21:23 <ski> *nod*
05:22:23 <ski> so, if we want decidable equality (`Eq'), we need more than just `Compact' on the domain
05:22:24 <luqui> oh, yeah, then for a total Eq you would need compact and overt, so that it could return False.
05:22:29 <ski> is it enough to also have `Overt' ?
05:22:51 <ski> right, ok
05:23:56 <luqui> I really love the separation ASD makes between these concepts.
05:24:06 <luqui> eg.  Eq => Discrete, Hausdorff
05:24:26 <luqui> lots of times (when considering fun stuff at least) you only need one...
05:25:19 <luqui> so you get:  Compact a, Discrete b => Discrete (a -> b),  and Overt a, Hausdorff b => Hausdorff (a -> b)
05:25:22 <luqui> very pretty :-)
05:25:23 <ski> (for the semi-decidable versions, it would be better to use sierpinski, rather than `Bool')
05:25:35 <luqui> agreed
05:26:36 <ski> discrete is semi-decidable equality, right ?
05:27:37 <luqui> aye, and hausdorff disequality
05:27:53 <ski> yes, apartness .. that i recall
05:27:53 <olsner> "However, common wisdom is not always correct, and, in fact, some other function types do have decidable equality" - sweet :)
05:28:16 <luqui> olsner, see infinite-search on hackage for implementation :-)
05:29:26 <luqui> beautifully, all lazy algebraic types (sum, product, mu) have decidable equality
05:29:38 <luqui> er, searchability
05:29:40 <luqui> not sure about equality
05:30:07 <luqui> yeah, not equality.
05:30:36 <olsner> isn't it the same as the infinite streams example there, since normal algebraic types can be infinite?
05:30:58 <luqui> olsner, yeah, that's why they don't have equality.  searchability is an interesting result though :-)
05:31:21 <olsner> what does "searchability" mean here?
05:31:35 <luqui> search :: (a -> Bool) -> Maybe a
05:31:44 <luqui> find an element which satisfies the predicate, or say there is none
05:32:08 <luqui> if the predicate is total, then so is search
05:32:50 <olsner> what about (const False) on an infinite data structure?
05:32:56 <luqui> it would say Nothing
05:34:00 <olsner> hmm, not that I understand how it works, but by a similar trick to the find_i definition from Seemingly impossible functional programs?
05:34:04 <ryanakca> Could someone with RWH please explain what the authors meant by the problem p.70 # 10? Am I supposed to also store the points a, b and c? Or am I just supposed to make a data type that takes ``left'', ``right'' or ``straight'' ? I can paste the question too....
05:34:10 <luqui> olsner, yeah exactly
05:34:24 <luqui> olsner, or rather, find_n for some n...  not sure which one :-)
05:37:21 <olsner> heh, "Iâ€™ll explain all this in another posting."
05:40:08 <ski> olsner : a few more links
05:40:16 <ski> <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> topology in Haskell, <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf> Synthetic topology of data types and classical spaces
05:41:04 <ski> <http://www.paultaylor.eu/ASD/> Abstract Stone Duality, several interesting papers here
05:41:08 <ski> and <http://www.mta.ca/~cat-dist/archive/2007/07-8> Subject: categories: The Dedekind Reals in Abstract Stone Duality, <http://www.mta.ca/~cat-dist/archive/2008/08-4> Subject: categories: Dedekind cuts
05:42:15 <ski> (the first of those posts to mailing list (e.g.) explaining Paul Taylors position with ASD wrt Martin Escardó)
05:44:12 <olsner> ski: cool, thanks
05:46:12 <PeakerWork> ryanakca: paste the Q too
05:49:33 <ryanakca> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4516#a4516 ...
05:50:44 <PeakerWork> ryanakca: I think you're supposed to do the latter
05:51:20 <ryanakca> PeakerWork: Lovely, thanks.
05:51:36 <skorpan> what would you guys call a program which takes a javascript source code and checks for functions declared more than once, consistent "return" behavior, etc?
05:51:42 <ryanakca> And what would be the inverse function of cosine, in haskell (cos^-1)
05:51:52 <olsner> jslint?
05:52:08 <skorpan> olsner: what would you call jslint? :)
05:52:21 <skorpan> verifier?
05:52:24 <EvilTerran> ryanakca, that'd be asin
05:52:41 <ryanakca> EvilTerran: Thanks
05:53:10 <olsner> skorpan: yeah, actually jslint calls itself a verifier (http://www.jslint.com/)
05:53:23 <ivanm> EvilTerran: acos, surely...
05:53:35 <EvilTerran> ivanm, yeah, of course :P
05:53:43 <EvilTerran> asin, acos, atan
05:54:15 <ivanm> acot, asec, acsc...
06:00:54 <PeakerWork> @hoogle atan2
06:00:54 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
06:00:59 <PeakerWork> atan2 usually more useful than atan
06:01:09 <PeakerWork> for converting a vector to an angle
06:01:29 <ivanm> what's the second input for?
06:01:37 <PeakerWork> ivanm: x and y, I think
06:01:51 <ivanm> ahhh
06:02:28 <PeakerWork> basically (atan2 x y) is sort of atan (x/y) with the special case for y==0 and negating the result angle properly if (x>=0)/=(y>=0)
06:02:34 <ivanm> *nod*
06:03:05 <PeakerWork> > atan2 5 0 * 180 / pi
06:03:07 <lambdabot>   90.0
06:03:14 <ivanm> PeakerWork: in what way are you trying to re-write the software world with enough?
06:03:15 <PeakerWork> > atan2 0 5 * 180 / pi
06:03:17 <lambdabot>   0.0
06:03:43 <PeakerWork> ivanm: Can you come to #haskell-blah ?
06:03:54 <ivanm> *sigh* fine then
06:03:55 <ivanm> ;-)
06:04:03 <PeakerWork> I don't want to flood #haskell with my ramblings :)
06:15:06 <skorpan> can template haskell generate traversable instances for me?
06:15:59 <luqui> skorpan, Data.Derive.Traversable
06:20:27 <twb> A.hs-boot:1:0: Bindings in hs-boot files are not allowed <two = 2>
06:20:39 <twb> Does hs-boot only allow me to avoid cyclic imports for *type* definitions?
06:21:48 <skorpan> does anyone have an example of how to use makeTraversable?
06:21:49 <twb> I wanted to avoid the kludge in Darcs.Commands.Help, which has (paraphrasing) help_cmd = ... and commands = help_cmd : TheCommands.commands
06:21:54 <skorpan> $(derive makeTraversable ''Statement) gives me an error
06:22:09 <skorpan> do i need Functor etc. for it to work?
06:23:20 <skorpan> "maketraversable" on google gives me like eight results :P
06:23:49 <EvilRanter> skorpan, what error do you get?
06:24:20 <ivan-kan`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4517#a4517 in function fileSize how do I convert IO Int into Int ?
06:24:21 <skorpan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4518#a4518
06:24:32 <skorpan> no, actually
06:24:39 <skorpan> $(makeTraversable ''Statement) gives me that error
06:24:50 <skorpan> not $(derive makeTraversable ''Statement)... 'derive' is not in scope apparently.
06:24:56 <skorpan> so i guess i just haven't imported it...
06:25:08 <skorpan> works now
06:25:10 <skorpan> silly me
06:25:13 <Zao> ivan-kan`: <- in a do block, or >>=
06:25:13 <RayNbow> hmm, is there a way to generalize [[a,b,c,d] | a <- [0..9], b <- [a..9], c <- [b..9], d <- [c..9]] for a varying number of digits?
06:25:20 <Zao> (I reckon, still waiting for firefox to load)
06:25:44 <skorpan> RayNbow: another list comprehension maybe? :)
06:26:10 <EvilTerran> > replicateM 2 [0..9] -- RayNbow
06:26:11 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[1,0],[1,1],[1...
06:26:22 <Zao> ivan-kan`: In order to extract something out of an IO t, you need to be in the IO monad.
06:26:23 <RayNbow> EvilTerran: that's not quite the same
06:26:30 <EvilTerran> oh, right
06:26:40 <EvilTerran> explicit recursion may be necessary
06:27:14 <Zao> ivan-kan`: (x, getSize topdir x) is of type IO Int, which is an unrun IO action.
06:27:30 <Zao> Err, (FilePath, IO Int), that is.
06:27:39 <skorpan> so given a traversable data type, i want to have a list of all elements in that data type structure which satisfy a predicate.  how do i do that?  is traversable even what i'm looking for?
06:28:16 <skorpan> (the elements are all leaves in this particular case)
06:29:21 <Zao> ivan-kan`: I'd change fileSize to be :: FilePath -> [FilePath] -> [(FilePath, IO Int)] and mapM through the list.
06:29:32 <skorpan> eg. "A 4 [A 8 []] [B 3, B 1]" and i want all elements which satisf "\(B x) -> x < 2"
06:29:41 <Zao> Or change fileSize to :: IO [(FilePath, Int)] and do the mapM there.
06:29:54 <ivan-kan`> Zao: thanks for all the pointers
06:31:39 <zention> Real World Haskell is quite a good book, I am quite impressed
06:32:00 <ivan-kan`> zention: yeah I ordered my copy
06:32:25 <zention> ivan-kan`: I have a couple of other haskell books but this one gets to the meat of it
06:32:31 <anon119> have you guys used this language outside of a university setting?
06:32:41 <Zao> I use it for hobby code.
06:33:09 <anon119> yeah, same here
06:33:10 <zention> we used gofer at uni, did rather put one off functional
06:33:13 <EvilTerran> > let combs 0 xs = [[]]; combs n [] = []; combs n (x:xs) = ((x:) <$> combs (n-1) xs) ++ combs n xs in combs 3 "12345" -- RayNbow, well, here's explicit recursion version
06:33:15 <lambdabot>   ["123","124","125","134","135","145","234","235","245","345"]
06:33:15 <anon119> just wanted to see
06:33:30 <anon119> ever try erlang or scheme
06:33:44 <zention> well erlang is pretty commercial
06:33:48 <anon119> makes my headaches go away since im far away from c
06:34:13 <zention> haskell is used in risk analysis in some investment banks
06:34:47 <anon119> cool, good to know. sounds like they'll be needing those people pretty soon
06:35:01 <zention> well Lisp has been there for quite sometime
06:36:17 <anon119> yeah, i've messed around with erlang, i can see how they able to use it in a commercial setting; it has crazy concurrent potential
06:36:25 <zention> and stability
06:36:41 <anon119> yeah because it isn't imperative
06:37:06 <zention> well it has built in checkers doesn't it - so processes check if others are alive
06:37:38 <zention> you can update in place as well I think
06:37:46 <anon119> yup but it is stateless like all other functional programming languages
06:38:05 <ivan-kan`> Zao: could I make getSize return an Int ?
06:38:12 <zention> anon119: stateless?
06:38:33 <Zao> ivan-kan`: Not if you intend to execute IO inside it.
06:38:35 <zention> anon119: yes I see what you mean
06:38:45 <Zao> ivan-kan`: (unless you use unsafePerformIO, but no, really, no)
06:39:31 <anon119> i doubt it'll ever become big though
06:39:37 * EvilTerran notes that what he pasted there isn't quite the same as RayNbow's version either
06:39:42 <ivan-kan`> Zao: with mapm can I turn [(Filepath, IO Int)] into [(Filepath, Int)]?
06:40:02 <anon119> which is a shame
06:40:43 <EvilTerran> > let foo 0 xs = [[]]; foo n [] = []; foo n (x:xs) = ((x:) <$> foo (n-1) (x:xs)) ++ foo n xs in foo 3 "12345" -- there we go
06:40:44 <lambdabot>   ["111","112","113","114","115","122","123","124","125","133","134","135","1...
06:41:46 <EvilTerran> > let foo 0 xs = [[]]; foo n [] = []; foo n (x:xs) = ((x:) <$> foo (n-1) (x:xs)) ++ foo n xs in foo 3 "12345" == [[a,b,c] | a <- ['1'..'5'], b <- [a..'5'], c <- [b..'5']]
06:41:47 <lambdabot>   True
06:42:08 <Berengal> Success!!
06:42:18 <Berengal> Well, partial anyway
06:42:54 <Zao> @type mapM
06:42:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:50:11 <Zao> ivan-kan`: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4519#a4519
06:51:34 <Martijn> \q
06:52:09 <Zao> I'm sure there's more elegant solutions :P
06:52:13 <ivan-kan`> Zao : thanks
06:52:30 <ivan-kan`> Zao: to hell with elegance, I want the darn thing to work!
06:53:50 <Zao> ivan-kan`: mapM runs an IO action on all the elements of a list, returning a list of the results.
06:53:58 <Zao> mapM_ does the same but throws away the results.
06:54:12 <Zao> @src mapM
06:54:12 <lambdabot> mapM f as = sequence (map f as)
06:58:33 <skorpan> > let xs = [True, False] in all (==(head xs)) xs
06:58:35 <lambdabot>   False
06:58:38 <skorpan> > let xs = [True, True] in all (==(head xs)) xs
06:58:39 <lambdabot>   True
06:58:55 <skorpan> > let xs = [True, True] in if null xs then True else all (==(head xs)) xs
06:58:56 <lambdabot>   True
06:58:59 <skorpan> > let xs = [] in if null xs then True else all (==(head xs)) xs
06:59:01 <lambdabot>   True
06:59:09 <skorpan> is there any better way of doing that?
06:59:17 <skorpan> i.e. checking that all elements in a list are equal?
06:59:36 <skorpan> i know this has been up lots of times before, but i always forget
07:00:20 <benwad> hey - i've got a function where it needs to print out a list of tuples, with each (a,b) value being printed as a string like: a++" = "++b, but this code seems to be returning errors in hugs. is there a better way? http://pastebin.com/m6297d717
07:00:59 <skorpan> benwad: maybe you could use mapM_
07:01:21 <benwad> skorpan: thanks ill look into it
07:01:22 <skorpan> mapM_ (\(x, y) -> putStrLn $ (show x) ++ "=" ++ show y)
07:01:30 <benwad> ah ok
07:01:31 <benwad> cheers
07:01:35 <PeakerWork> > let allEqual xs = and (map (==head xs)) xs ; examples = [[],[True,True],[True, False]] in map allEqual examples
07:01:36 <lambdabot>   Couldn't match expected type `[Bool]'
07:01:50 <dcoutts_> @seen refold
07:01:50 <lambdabot> I haven't seen refold.
07:01:56 <PeakerWork> > let allEqual xs = and $ map (==head xs) xs ; examples = [[],[True,True],[True, False]] in map allEqual examples
07:01:57 <lambdabot>   [True,True,False]
07:02:22 <PeakerWork> skorpan: maybe you could use that -- and use the fact that head xs won't be used in the case of an empty list
07:02:37 <skorpan> PeakerWork: is there any gain in that compared to my version?
07:03:02 <skorpan> e.g. laziness, etc?
07:03:17 <PeakerWork> skorpan: oh, silly me, I looked at your last example rather than the first one
07:03:22 <PeakerWork> skorpan: nope, yours was nicer :)
07:03:29 <skorpan> cool :)
07:03:43 <PeakerWork> > let xs = [] in all (==head xs) xs
07:03:44 <lambdabot>   True
07:03:48 <skorpan> uh what
07:03:54 <PeakerWork> skorpan: you don't need the "if"
07:04:02 <skorpan> let me think about that
07:04:03 <skorpan> @src all
07:04:03 <lambdabot> all p =  and . map p
07:04:08 <PeakerWork> skorpan: the (== head xs) never is called so head xs is never used
07:04:51 <PeakerWork> @pl mapM_ (\(x, y) -> putStrLn $ (show x) ++ "=" ++ show y)
07:04:51 <lambdabot> mapM_ (uncurry ((putStrLn .) . (. (('=' :) . show)) . (++) . show))
07:05:13 <skorpan> PeakerWork: but *why* isn't (== head xs) executed?
07:05:16 <PeakerWork> @let both = join (***)
07:05:17 <lambdabot>  Defined.
07:05:27 <PeakerWork> skorpan: its only evaluated as far as needed
07:06:03 <skorpan> oh right, map won't do anything really
07:06:03 <PeakerWork> > const 5 (error "nobody forces this, its allowed to be bottom!")
07:06:05 <lambdabot>   5
07:06:16 <skorpan> @src map
07:06:16 <lambdabot> map _ []     = []
07:06:16 <lambdabot> map f (x:xs) = f x : map f xs
07:06:19 <skorpan> there it is!
07:06:22 <skorpan> thanks PeakerWork :)
07:06:30 <PeakerWork> np
07:07:01 <PeakerWork> map f = foldr ((:) . f) []
07:07:13 <PeakerWork> > let map f = foldr ((:) . f) [] in map (*2) [1..5]
07:07:14 <lambdabot>   [2,4,6,8,10]
07:07:35 <monadic_kid> what the dilio, directx bindings for haskell but not in hackage :/
07:08:45 <yitz> @type flip foldr [] . (.) (:)
07:08:47 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:09:51 <skorpan> @pl \xs -> all (== head xs) xs
07:09:51 <lambdabot> all =<< (==) . head
07:10:48 <skorpan> @src Data.List.>>=
07:10:48 <lambdabot> Source not found.
07:11:43 <monadic_kid> @src Monad [a]
07:11:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:11:59 <monadic_kid> @src instance Monad [a]
07:11:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:12:02 <skorpan> @pl \xs -> all (\x -> snd x == (fst (head xs))) xs
07:12:02 <lambdabot> all =<< (. snd) . (==) . fst . head
07:12:49 <skorpan> > let xs = map fst [(1, True), (5, True)] in all (==head xs) xs
07:12:51 <lambdabot>   False
07:12:55 <skorpan> > let xs = map fst [(1, True), (5, False)] in all (==head xs) xs
07:12:56 <lambdabot>   False
07:13:04 <skorpan> > let xs = map snd [(1, True), (5, False)] in all (==head xs) xs
07:13:06 <lambdabot>   False
07:13:07 <skorpan> > let xs = map snd [(1, True), (5, True)] in all (==head xs) xs
07:13:09 <lambdabot>   True
07:13:15 <skorpan> is this lazy?
07:13:31 <skorpan> maybe i should use comparing or something
07:13:47 <skorpan> but is Bool Ord?
07:13:52 <skorpan> it is
07:18:57 <luqui> skorpan, yeah, that's lazy
07:19:23 <PeakerWork> @src [] (>>=)
07:19:23 <lambdabot> xs >>= f     = concatMap f xs
07:19:30 <PeakerWork> @src [] return
07:19:30 <lambdabot> return x    = [x]
07:19:36 <PeakerWork> monadic_kid: that's what you were looking for?
07:19:49 <monadic_kid> ?
07:19:49 <luqui> > let xs = map snd ((0, False) : repeat (1,True)) in all (==head xs) xs
07:19:50 <lambdabot>   False
07:20:27 <monadic_kid> PeakerWork: ?
07:20:43 <PeakerWork> monadic_kid: the source of the list monad instance
07:21:03 <monadic_kid> PeakerWork: oh I yeah i wasn't looking for it myself
07:21:23 <skorpan> @src unzip
07:21:24 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
07:22:26 <monadic_kid> so does anyone know about these direct3d bindings then?
07:22:40 <skorpan> @src zip
07:22:40 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:22:40 <lambdabot> zip _      _      = []
07:25:51 <kadaver_> if i install 6.10.1 over 6.10.2 what happens?
07:28:52 <RayNbow> EvilTerran: it would be nice if I could fold with (>=>) while collecting the intermediate results
07:32:50 <wunki> does anyone know how to fix emacs from showing ^J while in GHCI?
07:33:31 <conal> wunki: (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
07:33:56 <wunki> conal: thank you
07:34:01 <conal> :)
07:34:14 <pk> hey
07:34:22 <conal> wunki: if that doesn't work for you, i have another way.
07:35:20 <pk> I have some class instance which does depends on some parameters. However the parameter never change at runtime
07:35:26 <conal> wunki: there's some explanation at http://sites.google.com/site/haskell/notes/ghci610emacsmadness
07:35:39 <pk> the problem is, Those parameters are gonna be changed often
07:36:04 <pk> so it's ugly to just change them in the source code each time
07:38:29 <wunki> conal: it's working, thanks again.
07:38:48 <conal> wunki: great!  that problem drove me mad until i got help.
07:39:40 <monadic_kid> i can't those bindings anywhere! http://mokehehe.blogspot.com/2009/04/using-directx-from-haskell.html
07:39:44 <wunki> conal: same here, but my help came quickly :)
07:39:46 <monadic_kid> * i can't find those
07:39:49 <conal> :)
07:42:34 <monadic_kid> i see this is the guy behind super nario bros http://mokehehe.blogspot.com/
07:43:04 <roderyk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4520     Can someone take a quick look at this? First look at parsec and struggling with escapable strings...
07:44:10 <monadic_kid> he's changed the name to super monao bros, monao is monadic man in japanese! lol
07:47:19 <mmorrow> > let xs = [] in all undefined xs
07:47:21 <lambdabot>   True
07:49:27 <mmorrow> > case let in () of _ -> () where
07:49:29 <lambdabot>   ()
07:51:05 <byorgey> mmorrow: whoa, I would not have guessed that that would parse =)
07:51:13 <mmorrow> byorgey: hehe
07:51:41 <byorgey> roderyk: what's the problem, exactly?
07:52:51 <roderyk> byorgey: readExpr "\"foo\""  doesn
07:53:12 <roderyk> doesn't work (due to the extra ")
07:54:33 <roderyk> byorgey: eg ("fo\"bar")  parses up to "fo"
07:54:44 <Berengal> Huh, this parser is strangely relevant
07:54:51 <byorgey> roderyk: I think I see the problem.  instead of having validStringChar call itself, use a combinator like 'many'
07:55:37 <byorgey> roderyk: the way you have written it, there is no way for validStringChar to stop
07:56:22 <byorgey> i.e. write validStringChar to have type Parser Char
07:56:29 <byorgey> and then use 'many validStringChar'
07:57:14 <roderyk> byorgey: hmmm.. but then how would I wrap it? The reason I return a String instead of a Char is b/c if it's escapable I need to return 2 characters...
07:57:24 <byorgey> roderyk: no, you don't
07:57:37 <byorgey> a newline character (for example) is just one character
07:57:45 <byorgey> it just happens to be represented as '\n'
07:58:01 <byorgey> '\n'  and ['\\', 'n'] are not the same thing
07:58:32 <roconnor> > length "\n"
07:58:33 <lambdabot>   1
07:58:33 <byorgey> roderyk: you need to have some way to map sequences [backslash, escapeablechar] to the correct char
07:58:43 <roconnor> > length "\\\n"
07:58:45 <lambdabot>   2
07:58:53 <roderyk> byorgey: ah, I see your point.  (I'm working through the scheme haskell tutorial)
07:58:59 <byorgey> yup, I figured =)
07:59:10 <roderyk> I understand the length of \n issue
07:59:25 <roderyk> I just didn't realize I should store it internally correctly as the escapable code ;P
07:59:33 <byorgey> roderyk: so instead of  return ('\\' : [c])  you should have something like   case c of  'n' -> '\n' ...
07:59:53 <roderyk> byorgey: thanks, that was silly on my part :)
07:59:58 <byorgey> sure, no problem =)
08:01:08 <ivan-kan`> is it normal that getFileStatus bombs on symbolic link ?
08:02:51 <Berengal> roderyk: Perhaps this can help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4521#a4521
08:03:27 <monadic_kid> http://www.reddit.com/r/programming/comments/8hhal/mokehehes_english_blog_the_guy_behind_super_nario/
08:04:00 <Berengal> "japanese lol" is a language?
08:04:15 <Twey> ã¯ã„w
08:04:31 <Twey> If I have a Chan that I want to be read by multiple recipients
08:05:06 <Twey> Is it preferred to use a TChan and read/store/unread atomically, or to use a Chan and duplicate it?
08:05:30 <monadic_kid> Berengal: i'm just laughing at the meaning of Monao!
08:06:24 <Berengal> monadic_kid: And I'm just laughing at the use of "lol". Relax, just kidding ;)
08:06:43 <Twey> Hehe
08:07:38 <monadic_kid> check out the work:  http://github.com/mokehehe
08:11:23 <snk_kid> +e mode?
08:13:25 <Berengal> In the last seven days, at least five people have come up to me and said "I'm learning Haskell now because of you"
08:13:50 <Berengal> (The last one just called me, but close enough)
08:14:34 <snk_kid> was that in the negative sense "I'm learning haskell because of you, now die!" :D
08:14:48 <janos> data A = A (A -> Bool) -- how interesting can an A be?
08:15:40 <ski>   foo :: A -> a
08:15:53 <ski> er
08:15:56 <ski>   foo :: A -> Bool
08:15:57 <ski>   foo a@(A f) = f a
08:16:07 <ski>   bar :: A
08:16:12 <ski>   bar = A foo
08:16:21 <Berengal> snk_kid: Rather, they seemed to range from enthusiastic (had played with it for a couple of days before telling me) to mildly curious (hadn't started yet and wanted pointers)
08:16:36 <snk_kid> just kidding
08:16:40 <Tobsan> is it something in particular one needs to think about when using lazy ST
08:17:00 <Berengal> I know, but I still wanted to say it
08:17:52 <ski> janos : that interesting enough, for you ?
08:17:53 <janos> the only things I can think of are A (const True), A (const False), A foo, and A (not.foo), and some simple things one can make from them
08:17:56 <snk_kid> pfff i swear some reddits are just pathological downraters
08:18:02 <snk_kid> *redditors
08:18:39 <janos> using unary operators o :: A -> A and obar :: A -> A
08:19:20 <janos> o a = A (\(A f) -> f a)
08:19:33 <janos> and obar a = (A (\(A f) -> not$f a)
08:20:06 <roderyk> Berengal: thanks for the link (I was afk)
08:20:23 <janos> and one can also build conditionals: cond (A f) (A g) (A h) = A (\a -> if f a then g a else h a)
08:20:44 <vixey> yuck
08:20:47 <vixey>  what the hell is A
08:20:55 <janos> but I'm wondering whether this can in any sort of way be made Turing-complete-ish
08:21:00 <ski> it's the "santa" type on `Bool'
08:21:11 <vixey> that's a silly type
08:21:19 <janos> what's the santa type?
08:21:23 <ski> loeb's theorem is based on a similar type
08:21:28 <ski> (but not quite same)
08:21:41 <ski>   newtype Santa a = S (Santa a -> a)
08:22:13 <skorpan> what was the flag to pass to GHC to make it output the TH generated instances?
08:22:19 <skorpan> something with dump splines or something?
08:22:28 <skorpan> splices!
08:22:29 <skorpan> thanks
08:22:50 <Berengal> Values defined in terms of themselves always seem to trip people up.
08:23:23 <edwardk> loeb's paradox is fun
08:23:23 <kadaver_> how do i get ghc version?
08:23:35 <Berengal> ghc --version
08:24:22 <SamB> not always just people ;-)
08:24:24 <RayNbow> @go loeb's paradox
08:24:25 <lambdabot> No Result Found.
08:24:26 <SamB> > let x = x in x
08:24:33 <RayNbow> @go lÃ¶b's paradox
08:24:33 <lambdabot> http://en.wikipedia.org/wiki/Curry's_paradox
08:24:39 <SamB> o/~ let x = x in x
08:24:41 <lambdabot>   thread killed
08:24:50 <SamB> o/` let x = x in x
08:24:57 <SamB> , let x = x in x
08:25:00 <lunabot>  luna: out of memory (requested 2097152 bytes)
08:25:13 <SamB> hmm. those aren't the results I was expecting.
08:25:20 <roconnor> wow, luna bot is the dumb
08:25:29 * SamB also maintains that ascii-art music notes ought to work
08:25:31 <ski> janos : see
08:25:36 <ski> Curry's paradox <http://en.wikipedia.org/wiki/Curry%27s_paradox>
08:25:37 <ski> Löb's theorem <http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem>
08:25:52 <janos> am reading
08:27:08 * SamB could have sworn that was supposed to give <<Loop>> or whatever
08:27:47 <SamB> it's not working in GHCi either
08:28:12 <Berengal> You might have to compile
08:28:29 <janos> nice
08:29:02 <ski> also <http://en.wikipedia.org/wiki/Provability_logic> and "Modest reasoner" in <http://en.wikipedia.org/wiki/Doxastic_logic> is a bit related
08:29:06 <Berengal> There's also the nice loeb function
08:29:08 <janos> though I'm not sure what the implications are for A in the Haskell universe
08:29:24 <Berengal> @type let loeb x = fmap (\a -> a (loeb x)) x in loeb
08:29:26 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
08:29:50 <ski> (also stuff like "A reasoner is peculiar if there is some proposition p such that they believe p and also believe they don't believe p." sounds fun :)
08:30:44 <ski> (Berengal : yes .. but i wonder how related that actually is to the Löb's theorem proper)
08:31:20 <Berengal> ski: I couldn't say. 's still nice though...
08:31:24 <ski> (Löb's theorem appears to be more directly related to quines)
08:32:17 <ski> (one proof of it basically looks like a standard quine in Scheme, if you convert the informal proof into a proof-term)
08:33:02 <Berengal> Well, if you squint a bit they all "produce something from nothing" in a manner ;)
08:33:28 <ski> (using the above `loeb', one can easily construct a value at any type. Löb's theorem is as consistent as peano arithmetic(i think) is, though)
08:35:10 <Berengal> I'm content with the fact that the loeb above's type ((Functor f) => f (f b -> b) -> f b) looks almost the same as LÃ¶b's theorem on wikipedia ((LooksLikeABox f) => f (f b -> b) -> f b)
08:35:35 <Berengal> I'm afraid my knowledge of logic is rather basic at the moment...
08:35:40 <edwardk> re the loeb's theorem stuff: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html is pretty handy, if you like the loeb as function interpretation
08:36:05 <Berengal> edwardk: I read that. It's why I know how loeb works :)
08:36:11 <skorpan> if this is the only output from -ddump-splices and $(derive makeFoldable ''Statement), can i draw the conclusion that no instance was generated at all? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4522#a4522
08:36:21 <edwardk> similarly russel's paradox as a data type: http://blog.sigfpe.com/2008/01/type-that-should-not-be.html is also worth thinking about =)
08:36:35 <ski> @type let loeb ffaa = fix $ \fa -> ($ fa) `fmap` ffaa in runIdentity (loeb (Identity runIdentity))
08:36:36 <lambdabot> forall a. a
08:37:36 <pastorn> I need a wee bit of help
08:37:50 <pastorn> i have a small haskell program and want it to be a C file
08:38:00 <skorpan> pastorn: Asketh away, Sire!!
08:38:09 <edwardk> pastorn: you're in for a world of hurt ;)
08:38:30 <pastorn> so i know i should use ghc -fviac, but i don't want the backend to generate a binary
08:38:45 <edwardk> pastorn: you can generate a c file from ghc, but its nothing like what you'd expect and it needs to be compiled and have its symbols all shuffled around, etc.
08:38:47 <skorpan> there's some flag to pass to GHC for that, i can't remember what it wass
08:39:04 <tibbe> @seen dons
08:39:04 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 8h 23m 50s ago.
08:39:04 <skorpan> -C maybe?
08:39:11 <skorpan>  -C          stop after generating C (.hc output)
08:39:13 <Berengal> ski: I assume that bottom in execution would be equal to False or something in the logic?
08:39:26 <edwardk> pastorn: so its not like you can take the output of that and use it in another c program easily
08:39:43 <ski> Berengal : it would be equal to the logic being inconsistent
08:39:49 <gwern> man, how are people installing silkworm... it has all these deps to manually discover!
08:39:53 <pastorn> edwardk: no, this is just a small standalone program
08:40:01 <Berengal> ski: So that means it's either True or inconsistent?
08:40:08 <ski> `it' being ?
08:40:12 <edwardk> pastorn: iirc doesn't jhc generate small c files as output?
08:40:15 <pastorn> we have a submission that has to be in java or c, but i donÂ§t want to
08:40:26 <skorpan> pastorn: the generated C isn't readable... at all.
08:40:32 <skorpan> pastorn: you're wasting your time.
08:40:47 <pastorn> skorpan: the haskell file will be provided as well..
08:40:55 <skorpan> and they said it was okay?
08:40:55 <Berengal> ski: Eh.. good question. The logic escapes me :/
08:41:02 <ski> Berengal : i meant, if you could do what i did with the `Functor'-loeb above in the logic, then the logic would definitely be inconsistent
08:41:06 <edwardk> pastorn: the problem is you need to link it with the haskell library, etc.
08:41:29 <gwern> also, who the heck creates a game called 'silkwork' and names the executable *haq*???
08:41:33 <edwardk> pastorn: and all of the symbols have to be mangled after its compiled to put the info tables right before the code
08:41:38 <ski> Berengal : still, being able to prove Löb's theorem doesn't by itself make the logic inconsistent
08:42:11 <Berengal> ski: Does this mean something like turing-completeness implies inconsistent logic?
08:42:19 <Berengal> I'm afraid I'm on somewhat deep water here...
08:42:46 <edwardk> pastorn: you might look at one of the smaller haskell compilers like jhc
08:42:48 <Berengal> But turing-complete machines can certainly have bottom
08:43:10 <ski> yes .. so they're inconsistent, when regarded as logics
08:43:30 <gwern> pretty cool game
08:43:33 <byorgey> gwern: hehe, I think they copy-pasted the example Cabal file from the wiki page on how to cabalise your project
08:43:39 <gwern> though I'm not sure what it's supposed to be
08:43:44 <byorgey> gwern: the dummy example project is called 'Haq'
08:43:51 <edwardk> byorgey: lol
08:43:51 <gwern> byorgey: sure looks like it. clearly no one ever built it with cabal...
08:43:57 <byorgey> indeed.
08:44:09 <gwern> (also, why can my silkworm fly briefly?)
08:44:21 <byorgey> my silkworm can fly forever
08:44:31 <byorgey> (once it reaches the end of the level)
08:44:42 * gwern just found that ou
08:45:12 <byorgey> yeah, I wasn't entirely clear on how the physics worked
08:45:15 <Berengal> ski: I'm sure there's something profound in that fact somewhere. I'm really looking forward to studying this more...
08:45:18 <byorgey> but it was still fun =)
08:46:15 <gwern> indeed. nice looking too
08:48:41 <monadic_kid> http://www.reddit.com/r/programming/comments/8hhal/mokehehes_english_blog_the_guy_behind_super_nario/
08:50:35 <gwern> ah, has moke done anything new?
08:50:44 <gwern> we couldn't upload supernariobros because of copyright
08:51:05 <monadic_kid> gwern: he's moved the source to git repo, and name change
08:51:11 <gwern> so?
08:52:08 <monadic_kid> well i i have no answer to that, hopefully this direct3d  binding can be found
08:53:35 <monadic_kid> gwern: if you check his git account you'll see some of the things he's done, htetris is up there as well
08:54:04 <gwern> yeah. meant to upload that one; iirc I got stuck on his custom sdl bindings
08:54:42 <skorpan> if this is the only output from -ddump-splices and $(derive makeFoldable ''Statement), can i draw the conclusion that no instance was generated at all? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4522#a4522
08:54:55 <Tobsan> http://www.lazys-tranch.com/
08:54:56 <Tobsan> lol
08:55:44 <byorgey> Tobsan: I don't get it.
08:56:43 <Tobsan> Lazy ST
08:56:53 <Tobsan> try googling Lazy ST
08:57:04 <byorgey> oh, hehe
09:12:06 <Philonous> @src lookup
09:12:06 <lambdabot> lookup _key []          =  Nothing
09:12:06 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
09:12:06 <lambdabot>                         | otherwise = lookup key xys
09:14:10 <yitz> lookup key = fmap snd . listToMaybe . filter ((== key) . fst)
09:14:20 <conal> profiling question: does anyone know how i can get hp2ps to give me longer cost center names? they get truncated to 20ish characters even when i use -M (multi-page)
09:14:48 <Philonous> Is there a generalized form of lookup that maybe takes a predicate and returns that first element that satisfies it?
09:15:12 <adamvo> ?type find
09:15:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:15:32 <Philonous> Thanks, hoogle didn't spit this one out.
09:15:48 <adamvo> @hoogle (a -> Bool) -> [a] -> Maybe a
09:15:48 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:15:48 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
09:15:48 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:16:04 <adamvo> @hoogle (a -> Bool) -> [a] -> a
09:16:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:16:04 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:16:04 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
09:16:22 <adamvo> @hoogle [a] -> (a -> Bool) -> a
09:16:22 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:16:22 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:16:22 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
09:16:54 <Philonous> Strange, the web interface doesn't show it
09:17:11 <adamvo> Philonous: you tried one of those types?
09:17:30 <Philonous> (a -> Boolean) -> [a] -> Maybe a
09:17:33 <Philonous> And the other way around
09:17:50 <adamvo> Boolean or Bool ?
09:17:59 <Berengal> My GUI app is only crashing about half the time now. I consider this progress
09:18:05 <adamvo> the former is not built in =)
09:18:22 <Philonous> Snap, my bad. I typed Boolean.
09:18:38 <ski> @type (listToMaybe .) . filter
09:18:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:18:56 <ski> @src find
09:18:56 <lambdabot> find p          = listToMaybe . filter p
09:18:59 <ski> ah
09:23:00 <cypher-> anyone knows of any project using qthaskell?
09:23:01 <Tobsan> what does it mean when my program suddenly prints "<<loop>>" when switching from ST.Strict to ST.Lazy
09:23:38 <yitz> ski: many people feel that things like (f .) . are beyond the point of pointfree pointlessness.
09:23:58 <Sentinel19> if I have "let array1 = [1,2,3,4]"
09:24:07 <Sentinel19> is there anyway I can easily get the 3rd element of that array1?
09:24:12 <ski> yitz : i would have used `(.:)', except that then i'd have to define that in a `let'
09:24:17 <skorpan> Sentinel19: array1 !! 2
09:24:22 <Sentinel19> oh yeah
09:24:27 <skorpan> > let array1 = [1,2,3,4] in array1 !! 2
09:24:28 <lambdabot>   3
09:24:31 <ski> @type let (.:) = (.) . (.) in listToMaybe .: filter
09:24:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:24:32 <Sentinel19> thanks
09:24:34 <skorpan> np
09:25:10 <ski> Sentinel19 : a list is not an array
09:25:39 <yitz> @type let owlEyes = (.) . (.) in listToMaybe `owlEyes` filter
09:25:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:25:59 <skorpan> owl eyes, tits, it's all the same
09:26:10 <ski> > listArray (-3,2) [1,4,2,8,5,7]
09:26:11 <lambdabot>   array (-3,2) [(-3,1),(-2,4),(-1,2),(0,8),(1,5),(2,7)]
09:26:13 <ski> > listArray (-3,2) [1,4,2,8,5,7] ! (-2)
09:26:14 <lambdabot>   4
09:26:21 <ski> that's an array, with array indexing
09:26:27 <ski> @type listArray
09:26:28 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
09:26:29 <ski> @type array
09:26:30 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
09:26:32 <ski> @type (!)
09:26:33 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:29:39 <zsol> what does a ! mean in a type specification?
09:30:01 <zsol> like :: !G.Window
09:30:09 <Zao> Strict.
09:30:16 <zsol> ohyeah, thx
09:33:45 <monadic_kid> i call it the cliti bang operator
09:33:58 <monadic_kid> *cilit
09:47:09 <b7j0c> hey, i am trying to build ghc-6.10.3 prerelease and i keep getting errors that it cannot find haskeline, which i have installed via cabal for --user and --global...any ideas?
09:50:38 <Sentinel19> if statements work like this right? if (tempColNumber == 0) then (return 7) else (return tempColNumber)
09:50:55 <gwern> Sentinel19: don't think you need all the parens, but looks basically right
09:51:06 <ski> (`if' *expressions*, not statements !)
09:51:22 <ski> Sentinel19 : also, you need none of the brackets, there
09:51:25 <Sentinel19> I'm getting a 79:1: parse error on input `if'
09:51:40 <cypher-> Sentinel19: paste the line
09:51:43 <ski> probably you have some indentation trouble
09:51:51 <Sentinel19> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4527
09:52:06 <ski> (btw, that line can also be written as `return (if tempColNumber == 0 then 7 else tempColNumber)')
09:52:12 <monadic_kid> Sentienel19: remove the return
09:52:32 <Sentinel19> ohh
09:52:38 <cypher-> don't you need in after let .. ?
09:52:38 <monadic_kid> Sentienel19: if-then-else is an expression in haskell not statement
09:52:39 <ski> gwern : also you forgot an `in' after the first line
09:52:56 <adamvo> it could work if you added a do after the  = too (but using in is better)
09:53:15 <monadic_kid> Sentienel19: return is a function of a typeclass Monad
09:53:19 <adamvo> since we don't like using monads excessively
09:53:33 <ski> Sentinel19 : the only places a `let' is possible without an `in' is in `do'-notation and list comprehensions (and in the GHCi interactor)
09:54:24 <Sentinel19> so if (0 in tempColNumber)?
09:54:44 <monadic_kid> Sentienel19: if <expr> then <expr> else <expr>
09:54:57 <ski> also
09:55:04 <Sentinel19> but in terms of using let and in
09:55:12 <ski>   let <variable> = <expression> in <expression>
09:55:33 <Sentinel19> oh
09:55:40 <tew88> Is there a function in the standard library to check if a list contains a certain element?
09:55:45 <ski> (you can of course put the second expression on the next line .. and the `in' too if you like)
09:55:59 <monadic_kid> :t exists
09:55:59 <lambdabot> Not in scope: `exists'
09:56:01 <ski> @type elem
09:56:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:56:05 <ski> @type any
09:56:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:56:12 <Sentinel19> tew88: `elem` [1..42]
09:56:23 <tew88> Thanks! :)
09:56:26 <ski> > 17 `elem` [1..42]
09:56:27 <lambdabot>   True
09:56:28 <Sentinel19> is how I do it at least
09:56:32 <ski> > any odd [1..42]
09:56:33 <lambdabot>   True
09:56:34 <Sentinel19> not sure if thats good syntax
09:56:50 <ski> Sentinel19 : it's fine
09:57:33 <tew88> Excellent, cheers
09:57:51 <monadic_kid> Sentienel: you mean good coding conventions?
09:58:09 <monadic_kid> saying good "syntax means" something else to me
09:58:18 <Sentinel19> yeah, thats what I meant
09:58:29 <Sentinel19> because I'm searching a list every time I ask input
09:58:33 <Sentinel19> of 42 elements
09:59:38 <edwardk> hrmm what would you think would be the easiest way to get a Data.Set containing each of the members of Char that satisfy isSpace?
10:00:39 <adamvo> edwardk: Set.filter isSpace allChars
10:00:52 <edwardk> adamvo: ugh
10:00:56 <adamvo> I don't know where allChars would come from however
10:01:16 <edwardk> > Set.filter isSpace [minBound .. maxBound]
10:01:17 <lambdabot>   Couldn't match expected type `S.Set Char'
10:01:18 <TomMD> > let allChars = map toEnum [0..255] :: [Char]
10:01:19 <lambdabot>   <no location info>: parse error on input `;'
10:01:24 <edwardk> -- kinda horrid =)
10:01:28 <TomMD> > allChars
10:01:29 <lambdabot>   Not in scope: `allChars'
10:01:32 <edwardk> nah, i permit unicode thats the problem
10:01:36 <TomMD> > let allChars = map toEnum [0..255] :: [Char] in allChars
10:01:37 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
10:01:48 <TomMD> ok
10:02:03 <edwardk> > Set.filter isSpace (Set.fromList [minBound .. maxBound])
10:02:06 <lambdabot>   fromList "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199...
10:02:33 <byorgey> Sentinel19: sure, searching a list of length 42 with `elem` is fine =)
10:02:34 <edwardk> > length (Set.toList (Set.filter isSpace (Set.fromList [minBound .. maxBound])))
10:02:37 <lambdabot>   24
10:02:40 <ski> is there a point to not filtering on the list side ?
10:02:45 <byorgey> the only way to do it faster is to use a different data structure.
10:02:48 <edwardk> ski: not really =)
10:03:10 <ski> (since i imagine `fromTo' and `filter' might fuse)
10:03:30 <edwardk> > Set.fromList [x | x <- [minBound .. maxBound], isSpace]
10:03:31 <lambdabot>   Couldn't match expected type `Bool'
10:03:37 <ski> x
10:03:39 <edwardk> > Set.fromList [x | x <- [minBound .. maxBound], isSpace x]
10:03:40 <lambdabot>   fromList "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199...
10:03:59 <edwardk> > length [x | x <- [minBound .. maxBound], isAlpha]
10:04:00 <lambdabot>   Couldn't match expected type `Bool'
10:04:07 <edwardk> > length [x | x <- [minBound .. maxBound], isAlpha x]
10:04:09 <lambdabot>   90547
10:04:15 <edwardk> that might be a heftier set
10:04:38 <edwardk> but objectively there are only 21 bits to deal with, so it might be worth just doing
10:04:52 <edwardk> and if its captured in a caf somewhere, so be it
10:04:54 <ski> > length [x | x <- [minBound .. maxBound], isSpace x]
10:04:55 <lambdabot>   24
10:05:17 <vixey> > length [x | x <- [minBound .. maxBound], not x]
10:05:18 <lambdabot>   1
10:05:35 <edwardk> i have a series of 'recognizers' that i'm using in my parsers and one of them is Set based, so i was trying to figure out the right way to implement 'space' etc. for that one basically
10:07:44 <edwardk> hrmm this may be a pretty expensive scheme for me to compile with though, since i may have to use that on any predicate on chars, hopefully they will be small =)
10:07:54 <TomMD> byorgey: Hows the research going?   Still building a compiler?
10:10:22 <byorgey> TomMD: it's going well, thanks!  But it has never involved building a compiler. =)
10:14:24 <demolithion> > logBase 10 1000
10:14:25 <lambdabot>   2.9999999999999996
10:15:11 <TomMD> byorgey: Damned, I thought that was your part in this new language - what was it called again?
10:15:24 <TomMD> > logBase 2 1024
10:15:25 <lambdabot>   10.0
10:15:33 <TomMD> > log 1024 / log 2
10:15:34 <lambdabot>   10.0
10:16:09 <edwardk> i've decided that i love Applicative, its like Monoid, but sexier
10:16:39 * edwardk breaks up with Monoid and moves in with his new love.
10:28:17 <RayNbow> @hoogle [a -> m a] -> (a -> m [a])
10:28:17 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:28:17 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:28:17 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
10:28:48 <Alaisa> omfg  awesome http://tinyurl.com/lolmaopwnd lol
10:30:36 <Renderwahn> oh noooo, I'm so tempted to look at the link....
10:30:52 <cypher-> don't do it!
10:31:06 * RayNbow prepends preview. to the domain
10:31:17 <RayNbow> ah
10:31:23 <RayNbow> yup, don't click on it
10:31:34 <Renderwahn> I could fire up virtual box and see if something funky happens :)
10:31:40 <vixey> was it spam?? wow I didn't expect /that/
10:36:15 <uberhanz> hello haskellers :)
10:42:01 <thorn`> l
10:42:21 <thorn`> hello all
10:43:06 <thorn`> im interested learning haskell. im experienced in imperative languages.. what tutorial book would be good for me?
10:44:24 <adamvo> @where tutorials
10:44:24 <lambdabot> I know nothing about tutorials.
10:44:43 <Philonous> @go real world haskell
10:44:44 <lambdabot> http://www.realworldhaskell.org/
10:44:44 <lambdabot> Title: Real World Haskell
10:44:54 <adamvo> @where yaht
10:44:54 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:44:55 <Philonous> @go learn yoursel a haskell
10:44:56 <lambdabot> http://learnyouahaskell.com/faq
10:44:56 <lambdabot> Title: Learn You a Haskell for Great Good! - FAQ
10:44:57 <monadic_kid> thorn: http://learnyouahaskell.com/ is nice
10:45:18 <monadic_kid> thorn: and the wikibook as well
10:45:25 <edwardk> augustss: your tracing hack was really useful for me the other day =)
10:45:39 <tibbe> @seen dons
10:45:39 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10h 30m 25s ago.
10:45:40 <thorn`> thanks you guys :)
10:45:56 <augustss> edwardk: glad to hear
10:46:17 <adamvo> Debug.Trace, or something else?
10:46:41 <edwardk> augustss: basically i'm using it to extract the parser states from a context-free grammar expressed as an applicative so i can run it 'bottom up' but for that i needed to spot sharing of the same applicatives
10:47:15 <augustss> ah, sneaky
10:47:26 <edwardk> its a little less safe in my case, no typeable, etc. but its working like a charm
10:47:50 <tibbe> there was a post on reddit on using CPS for the state monad, could someone explain why GHC optimizes a CPS definition better?
10:47:50 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
10:48:32 <edwardk> augustss: basically i've got a 'two finger' version of an earley parser i can run in parallel using my monoid lib
10:49:09 <augustss> edwardk: well, I don't know what the two finger version does.
10:49:17 <augustss> adamvo: Debug.Traced
10:49:20 <edwardk> augustss: thats because i made it up ;)
10:50:00 <edwardk> augustss: more or less i need to be able to parse monoidally, so i want to be able to start parsing at an arbitrary character and extend the parse left or right, and merge two partial parses
10:50:20 <edwardk> augustss: that way i can take a file, chunk it into say 64k chunks, parse each in parallel and merge the partial parses.
10:50:35 <monadic_kid> thorn`: oh yeah google haskell cheetsheet as well
10:50:47 <augustss> edwardk: If you can do that with early, it's really cool
10:50:51 <ski> edwardk : that sounds very cool .. where is the code for this ?
10:51:02 <edwardk> augustss: its not quite an earley parser, but its heavily inspired by it
10:51:11 <augustss> edwardk: So does the merging turn O(n^3) in the worst case?
10:51:14 <edwardk> ski: its going to wind up int he monoids library as sort of the punchline
10:52:23 <edwardk> augustss: i'm still working out the asymptotics, but the merging of two partial parses looks to be at least O(n^2)
10:52:54 <augustss> edwardk: Since Earley is O(n^3) worst case I'd be surprised if you can do it O(n^2)
10:52:55 <cypher-> thorn`: I recommend the book "Introduction to Functional Programming with Haskell" by Richard Bird, or the combo of Hutton's book on Haskell, which is a nice one-evening read and Real World Haskell
10:53:07 <edwardk> augustss: remember you need O(n) merges =)
10:53:26 <augustss> edwardk: Ah, yes.  Not enough coffee this morning
10:53:29 <kerlo> > maxBound :: Int
10:53:30 <lambdabot>   9223372036854775807
10:53:37 <thorn`> ok, also im reading dragon book, so the question is. does haskell is good for compilers or grammar parsers? i mean using haskell for writing grammar parsers, etc...
10:53:42 <kerlo> I want a maxBound like that.
10:53:54 <cypher-> thorn`: it's excellent for parsers
10:54:07 <kerlo> I guess I got the 32-bit version.
10:54:15 <cypher-> thorn`: you can implement very nicely recursive-descent parsers using monads
10:54:36 <cypher-> thorn`: again, see Hutton's or Bird's book, or Hutton's paper on monadic parsing
10:54:56 <ski> edwardk : so that parsing truly happens bottom-up ?
10:55:16 <edwardk> augustss: i'm also trying to special case the left and right most edges so when you merge a partial parse with one that knows it starts from the root case you can recover more of the Earley style asymptotics
10:55:17 <ski> (and not just bottom-up from the chunks)
10:55:39 <kerlo> Are there 64-bit binaries for Windows, or will I have to build one myself?
10:56:37 <edwardk> ski: basically what i do is take an applicative style parser expressed as a GADT and reify it into the type level so i know each monoidal reduction is for the same GADT, then i work with either fox-style derivatives top down or i work bottom up in earley style. i'm trying both out to see which performs better
10:57:16 <ski> is this reification done manually ?
10:57:32 <edwardk> ski: i use Data.Reflection, so its cheap
10:58:14 * ski is not sure what "fox-style derivatives" is nor what "earley style" is exactly
10:58:45 <edwardk> ski: sok, i can make those more precise =)
10:59:34 <ski> (augustss : `Debug.Trace' or `Debug.Traced' ?)
10:59:36 <edwardk> ski: basically what i need is a strange form of zipper, where the 'hole grows'
10:59:47 <ski> example ?
10:59:50 <edwardk> ski; Traced, its a nice library for spotting shared computation.
11:00:12 <thorn`> also question. does haskell is only for educational purposes? i mean where can i see some open source haskell product which is eh.. successfull? :)
11:00:20 <edwardk> well, take a list with a gap in the middle that isn't one element wide, its one or more elements wide.
11:00:57 <edwardk> take a tree with a contiguous run of leaves replaced
11:01:07 <edwardk> thorn`: darcs has been pretty successful
11:02:46 <ski> hm
11:02:54 <ski> replaces by what ?
11:03:07 <ski> not a sub-tree removed, then ?
11:03:14 <edwardk> take a parser that recognizes "ABC" -- when you see a B you know you're in the state "A*B*C" -- if another partial parse sees a C its in state "AB*C*" -- if you merge those parses you get the parse "A*BC*"
11:03:29 <edwardk> (if you merge them in the right order that is) =)
11:04:02 <edwardk> it gets trickier when you allow recursion in the rules
11:04:17 <ski> ok
11:04:36 <edwardk> the goal is to get to "*ABC*" or fail
11:04:39 <ski> so it's basically about monoid types, in the simplest form, then ?
11:05:02 <edwardk> well, the parser itself is defined as an applicative, the 'parses' are monoidal.
11:05:39 <ski> (i mean because you were talking about an (associative) sequence of elements/leafs)
11:05:48 <edwardk> in the end you can just use the parser as a 'reducer' in my terminology for monoids, and it'll automatically chunk up lazy bytestrings, share partial parses if you run it over a lempel-ziv compressed container, etc)
11:06:24 <edwardk> ski: yeah the idea is composition of 'partial parses' in this framework is monoidal
11:07:02 <juturnas> If I want to play around with raytracing, what is the easiest to setup/quickest way to get results on screen?  Using a gui like wx or gtk, or is there something geared to be a simple frame buffer?
11:07:04 <edwardk> and it basically pays something comparable to earley parsing O(N^3) worst case to recognize any context-free grammar
11:07:07 <ski> i've been wanting to do "bi-directional parsing" for a while .. but not knowing how to proceed
11:07:25 <vixey> ski what do you mean by that
11:07:50 <edwardk> ski: this gives efficient optimized versions for left-to-right and right-to-left and a way to handle the pathological chunk to chunk case.
11:07:52 <ski> vixey : i just mean being able to start at any end of the input, and possibly even start anywhere inside the input
11:08:09 <ski> (think of a deductive database parsing the input bottom-up)
11:09:16 <ski> (i suppose i have to look up earley parsing, now ..)
11:09:25 <vixey> what's the point in that?
11:09:44 <edwardk> chunk merges can be expensive because you can be in k different states simultaneously and it takes O(k^2) or so to merge them
11:09:48 <thorn`> well, i went with http://learnyouahaskell.com . so far so good :)
11:09:59 <ski> e.g. hopefully not needing to left-recursion-eliminate manually
11:10:06 <edwardk> ski: heh, well, what i do is basically inspired by it, but it none of the earley style stuff does quite what i do
11:10:12 <vixey> can't you write a program that eliminates left recursion
11:10:21 <ski> yes
11:10:33 <edwardk> ski: earley parsing parses any context-free grammar, even ones without left-recursion elimination, its just expensive
11:10:46 <ski> but it is hard to do that if the parser recursion is expressed by haskell recursion
11:11:00 <ski> (but maybe that's what edwardk does with detecting sharing ..)
11:12:02 <edwardk> ski: thats why i am cheating and using the fact that if i 'ignore the types' carried by the applicative, i can use lennarts tracing trick and the fact that applicatives never use anything like (a -> Parser t a) -> Parser t a in the definition of the parser -- to 'know all of the parsers' involved in the parse
11:12:41 <ski> it sounds slightly evil
11:12:56 <ski> how do you know `(a -> Parser t a) -> Parser t a' won't be added ?
11:13:03 <ski> because it's an applicative parser ?
11:13:18 <ski> (or maybe i misunderstood what you meant)
11:13:20 <edwardk> lookup k m = do x â† IntMap.lookup (hashStableName k) m; unsafeCoerce $ Prelude.lookup (unsafeCoerce k) x -- hell yes its evil!
11:13:21 <edwardk> yeah
11:13:59 <edwardk> its a style of parser that can't be extended to be a monad
11:14:06 <ski> ok
11:14:34 <edwardk> i think it may be able to handle monoidally-attributed grammars
11:14:43 <edwardk> at least for synthesis though, so you can prune some branches
11:14:56 <edwardk> er rather i know it can
11:15:26 <ski> this all sounds interesting
11:15:42 <edwardk> its been my obsession for the last 48 hours or so ;)
11:16:02 <vixey> what is that edwardk
11:16:10 <vixey> with all the unsafeCoerce
11:16:22 <vixey> :t hashStableName
11:16:23 <lambdabot> Not in scope: `hashStableName'
11:16:24 <edwardk> vixey: lookup :: StableName a â†’ StableMap f â†’ Maybe (f a)
11:16:37 <ski> vixey : for storing differently typed parsers all in the same `IntMap'
11:16:41 <byorgey> thorn`: great, feel free to ask if you have questions!
11:17:05 <edwardk> and there is a similar: insert :: StableName a â†’ f a â†’ StableMap f â†’ StableMap f
11:17:52 <edwardk> where a stablemap is basically IntMap [(StableName Magic, f Magic)]
11:18:08 <edwardk> and Magic is a typing dodge
11:18:31 * ski seems to recall seeing an `Obj' with `toObj :: a -> Obj' and `fromObj :: Obj -> a' being used for this, somewhere
11:18:35 <vixey> we should just have {-# LANGUAGE DontTypecheck #-}
11:18:58 <vixey> then we could stop worrying about these stupid types
11:19:02 <edwardk> anyways with the typing dodge to convert between different StableName types it works pretty well
11:19:04 <skorpan> if i have a data type of kind *, is there any way to instantiate Foldable for it?
11:19:05 <vixey> all they do is cause errors
11:19:09 <ski> {-# LANGUAGE SoftTyping #-}
11:19:34 <FunctorSalad> f $ x = unsafeCoerce (f (unsafeCoerce x))
11:19:50 <edwardk> sexy
11:20:01 <FunctorSalad> more scary :o
11:20:29 <vixey> , unsafeCoerce
11:20:31 <lunabot>  luna: Not in scope: `unsafeCoerce'
11:20:36 <vixey> we're not allowed to use it in here
11:20:41 <ski> (edwardk : i presume you'll eventually write a post on this, too ?)
11:20:50 <edwardk> ski: yeah, this one is definitely going up =)
11:21:26 <ski> (lunabot,lambdabot ought to say something about "potty mouth" when those unsafe things are named ;)
11:22:10 <edwardk> ski: as it is i'm mostly bogged down in getting parts of it written out
11:22:13 <thorn`> OT: what is the best haskell mode for emacs? :)
11:22:33 * ski wonders why that is is OT ..
11:22:35 <vixey> apparently 'haskell-mode' is the best which you get from fptools
11:22:47 <edwardk> i also abuse unsafeCoerce in a couple of other places to improve sharing
11:22:56 <vixey> you got to figure out how to download it from CVS though
11:23:13 <thorn`> ok i got it now :) thanks
11:23:26 <vixey> edwardk, would you be able to write these programs with dependent types instead?
11:24:04 <edwardk> for instance my parsers are parameterized on a 'traits' class that indicates how they handle pure and sym, what the token type is, and a GiST-like 'consistent' key monoid that answers whether or not a parser might match a given symbol
11:24:20 <edwardk> vixey: probably
11:24:45 <edwardk> vixey: for one i wouldn't have to work so hard to spot infinite recursion =)
11:25:55 <edwardk> unfortunately the need for sharing makes me redefine a few things from parsec a little more pedantically:
11:25:56 <edwardk> many p = ps where ps = (:) <$> p <*> ps <|> pure []
11:26:13 <monadic_kid> many smileys
11:27:10 <edwardk> since the many p = (:) <$> p <*> many p <|> pure [] -- will build an infinitely large grammar -- since its not smart enough
11:27:18 <ski> i wonder what would be a better solution to this sharing business ..
11:27:43 <skorpan> anyone?  i have "data A = A Int (Maybe A) | B", is it possible to instantiate Foldable for it?
11:27:46 <wli> GLR is usually more nicely behaved than Earley.
11:27:52 <edwardk> ski: well in a total language i could just make a fixP
11:28:14 <edwardk> wli: sure, but i get nothing out of the LR since i could be parsing right to left, left to right, or in random tree like passes.
11:28:56 <edwardk> wli: and in fact Earley's parser is also basically useless for me, except for the fact that the idea of predict/scan/complete works well when adding incremental information to a partial parse in my framework
11:30:20 <edwardk> one reason i like the 'derivative' based version of this is that it handles the many p = ... many p -- case more gracefully
11:30:31 <edwardk> but then it relies heavily on laziness for correctness
11:32:33 <ski> edwardk : yes .. but it's ugly to have to write `many p = fixP $ \ps -> (:) <$> p <*> ps <|> pure []'
11:32:49 <edwardk> ski: sure, but in coq, etc you'd have no choice =)
11:33:24 <vixey> yeah although it's actually like
11:33:35 <vixey> fixP (\many input -> ...)
11:33:43 <vixey> sorry
11:33:47 <ski> the question was whether there would be any nice solution that allowed the nice syntax, but gave you explicit sharing checking, without ugly hacks
11:33:59 <vixey> fixP (\many input -> (...) (input, <proof that input equals itsself>))
11:34:13 <ski> (obviously such a nice solution should be based on some appropriate theory ..)
11:34:48 <vixey> Other times alternative fixed points occur were taking the least fixed point in the computation monad
11:35:04 <roconnor> ski: you can write fixP $ \ps -> iI (:) p ps Ii <|> pure []
11:35:13 <ski> .. maybe some way of having built-in graph types to the language would help
11:35:17 <conal> anyone here experienced with hp2ps (for viz'ing heap use)?  i want to know how to get non-truncated cost center names.  i'm only seeing about 20 chars, which often doesn't even cover the module name.
11:35:59 <ski> (with some kind of graph induction/whatever, that ensures each subgraph is only handled once .. or at least as few times as possible, for dataflow algorithms on the graph)
11:38:02 <gigamonk`> Is it the definition of >>= for the IO monad that ensures that IO actions happen in the correct order?
11:38:25 <vixey> gigamonk`, what definition of >>= for IO?
11:38:28 <edwardk> basically what you wind up with here is that compiling the parser into a monoid requires the parser to have a finite representation as a context-free-grammar -- otherwise resharing will fail to find all the parents
11:38:43 <vixey> I meant.. are you talking about a concrete implementation or any valid implementation?
11:38:51 <edwardk> gigamonkey: Basically, yes. thats what it does
11:39:01 <gigamonkey> vixey: uh, the actual one. I assume it's part of the implementation of the runtime.
11:39:06 <vixey> what one?
11:39:14 <gigamonkey> GHC, say.
11:39:18 <vixey> @src >>= IO
11:39:19 <lambdabot> Source not found.
11:39:23 <ski> the Bristol Haskell System, of course !
11:39:23 <vixey> @src (>>=) IO
11:39:24 <lambdabot> Source not found. You speak an infinite deal of nothing
11:39:26 <vixey> @src >>= IO
11:39:26 <lambdabot> Source not found. Where did you learn to type?
11:39:30 <vixey> @src (>>=) IO
11:39:30 <lambdabot> Source not found. You speak an infinite deal of nothing
11:39:35 <vixey> @src IO >>=
11:39:35 <lambdabot> Source not found. Sorry.
11:39:38 <vixey> @src IO (>>=)
11:39:38 <lambdabot> m >>= k     = bindIO m k
11:39:43 <edwardk> gigamonkey: basically the IO monad has to 'do the first action' to get the value that it passes to the right hand side of the >>=, rinse, wash, repeat
11:40:34 <gigamonkey> edwardk: though there are some degenerate case (those returning IO (), for instance) where it doesn't really have to.
11:41:07 * ski . o O ( "This directory contains `brisk', the Bristol Haskell System, version 0.0." )
11:41:47 <gigamonkey> So I'm assuming that >>= does something like 'actually do IO action; take the resulting value; pass it on.'
11:42:23 <gigamonkey> But the value that is passed on is still lazily evaluated, right.
11:42:25 <vixey> (You are talking about any valid implementation, not one specific concerete implementation)
11:42:33 <gigamonkey> vixey: yes.
11:42:56 <gigamonkey> Or maybe, any realistic, usable implementation.
11:43:10 <vixey> In that case I can show you a way it can be concieved
11:43:35 <vixey> data IO a where Return :: a -> IO a ; (:>>=:) :: IO a -> (a -> IO b) -> IO b ; ...
11:43:43 <vixey> you have a data type with various bits..
11:43:55 <vixey> and then instance IO where return = Return ; (>>=) = (:>>=:)
11:44:14 <vixey> so now an IO program would build up something like    Print 'h' :>>=: \_ -> Print 'e' ...
11:44:26 * ski wonders if gigamonkey's seen GADTs yet
11:44:38 <vixey> so the implementation (maybe it's written in C or something capable of doing IO directly), could pick apart that data (in the right order) and execute it
11:45:22 <gigamonkey> ski, if you mean data declarations, yes.
11:45:39 <ski> i meant vixey's
11:45:43 <ski>   data IO :: * -> *
11:45:44 <ski>     where
11:45:47 <ski>     Return :: a -> IO a
11:45:51 <ski>     (:>>=:) :: IO a -> (a -> IO b) -> IO b
11:45:53 <ski>     ...
11:45:55 <vixey> that's not what I wrote
11:46:01 <monadic_kid> friggin smileys
11:46:11 <ski> instead of a `data IO a = Return a | ...' style definition
11:46:15 <vixey> that is a bet tedious
11:46:20 <vixey> a bit tedious
11:46:29 <ski> vixey : a little history revision, only :)
11:46:33 <vixey> ski, not you
11:47:07 <ski> ?
11:47:10 <vixey> ski the guy that only says "smileys" in a loop
11:47:50 * ski didn't really notice it until you mentioned it ..
11:48:12 <vixey> now you can suffer with me :p
11:49:56 * ski wonders where to get the nine-tailed cat
11:50:00 <gigamonkey> vixey: so when you say the implementation "picks apart that data", what data are you talking about?
11:50:50 <vixey> gigamonkey, With my IO instance above, an IO program would evaluate into these constructors 'Return' ':>>=:' and any others that were in there (like 'Print' and 'Read' would be good ones to have)
11:51:03 <byorgey> TomMD: well, that's the thing, 'this new language' exists only in theory. Stephanie Weirich has some funding for a project to develop a new dependently-typed language, but no actual work has been done on it.
11:51:17 <byorgey> TomMD: I guess what I'm doing now could possibly be relevant to it later
11:51:17 <vixey> byorgey is it object oriented?
11:51:26 * byorgey shudders
11:51:29 <gigamonkey> vixey: ah, I see. Sort of. Let me ponder that a bit.
11:51:29 <byorgey> why would it be?
11:51:37 <vixey> well she has done reseached into dependently typed OO..
11:51:48 <byorgey> oh, she has?
11:51:52 <byorgey> I didn't actually know that
11:51:56 * vixey :p
11:52:08 <byorgey> well, she's not really thinking about that at the moment
11:52:20 <vixey> Now you know what you have to do
11:52:26 <byorgey> haha
11:52:32 <vixey> www.seas.upenn.edu/~sweirich/papers/tfp07.pdf
11:53:07 <byorgey> vixey: right, that's the project
11:53:34 <byorgey> 'work-in-progress' actually means something more like 'here are our ideas' =)
11:54:47 * vixey thinks they should work on not calling it 'PIE'
11:55:41 * ski . o O ( plum pudding )
11:56:14 <vixey> byorgey oh no I was  getting mixed up
11:56:25 <wli> Position Independent Executables?
11:56:32 <vixey> actually I was thinking about 'Concord' which is the object oriented thing -- nothing to do wieth her
11:56:36 <byorgey> oh, ok
11:57:11 <byorgey> wli: I'm not sure what it stands for
11:57:22 <byorgey> actually I don't think it stands for anything
11:58:06 <gigamonkey> So are GADTs part of Haskell-98?
11:58:10 <vixey> no
11:58:15 <gigamonkey> But in GHC?
11:58:17 <vixey> yes
11:58:31 <vixey> you can do {-# LANGUAGE GADTs #-} at the start of the .hs file
11:58:42 <skorpan> uhm, i need that?
11:58:50 <skorpan> that might explain the compiler error i got...
11:59:07 <ski> ,KindSignatures
11:59:08 <lunabot>  luna: Not in scope: data constructor `KindSignatures'
11:59:29 <ski> if you want to be able to say like `data IO :: * -> * where ...' above
12:00:04 * ski thinks `data Foo a where ...' is mostly useless
12:01:53 --- mode: irc.freenode.net set +o ChanServ
12:02:28 <Cale> gigamonkey: So, as the imaginary runtime system which vixey is talking about pattern matches against the IO values, it causes them to be evaluated, and when it carries out the instructions they represent, it's what we'd normally call execution. Running a Haskell program is sort of the interleaving of these two processes: evaluation of expressions into values for pattern matching, and execution of IO actions to make th
12:02:28 <Cale> ings actually happen.
12:03:34 <Cale> It's important (at least I think so) to understand that evaluating an IO action doesn't actually cause it to occur, only execution does that.
12:05:01 <gigamonkey> Cale: I got the last bit.
12:05:42 <skorpan> is there any general thing to look for when you get this kind of error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4528#a4528
12:05:43 <gigamonkey> I guess I'm trying to wrap my head around the relationship between the eventual evaluation of lazy values and whatever it is that causes IO actions to be executed.
12:05:49 <Cale> For example, there's a primitive seq which has the property that evaluating (seq x y) causes x to be evaluated before the result of evaluating y is returned. You can write things like  (seq (print 5) 12), and you will get the result 12, but nothing will be printed, because it just evaluated *which action* that print 5 was, without carrying it out.
12:06:17 <ski> so what `(>>=)' for `IO' does is only to combine into an action from an action and a function mapping the former's result to a new action
12:06:45 <roconnor> the run-time enviroment executes the main :: IO () action, which is presumably composed of many little primitive IO actions
12:06:47 <ski> execution is only started by `main' being evaluated, and then executed
12:07:01 <gigamonkey> I see. So it's up to the implementation to build up some representation of composite actions that allows it to later execute the sub-actions in the right order.
12:07:42 <roconnor> @wiki IO_Sematics
12:07:42 <lambdabot> http://www.haskell.org/haskellwiki/IO_Sematics
12:08:02 <dolio> Helpful page.
12:08:02 <gigamonkey> roconnor: "There is currently no text in this page"
12:08:09 <roconnor> @wiki IO_Semantics
12:08:10 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
12:08:10 <gigamonkey> Is that a subtle comment
12:08:30 <roconnor> that gives one idea how one could implement IO
12:10:51 <gigamonkey> roconnor: thanks.
12:24:49 <vixey> ski: data Foo a does kind inference
12:24:49 <Renderwahn> is there a built in factorial function?
12:25:13 <wli> factorial n = product [1 .. n]
12:27:06 <Renderwahn> I take that for a no
12:27:24 <beelsebob> tbh, typing product [1..n] is barely worse than factorial n
12:28:22 <dons> Renderwahn: it's trivial to define, as above.
12:28:22 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:28:24 <wli> > let factorial n = product [1 .. n] in sum [recip . fromIntegral $ factorial n | n <- [0 .. 25]] :: Rational
12:28:26 <lambdabot>   85351903640077042215979%31399210614030336000000
12:28:28 <Renderwahn> writing n! would be nice
12:28:37 <wli> > let factorial n = product [1 .. n] in sum [recip . fromIntegral $ factorial n | n <- [0 .. 25]]
12:28:39 <lambdabot>   2.7182818284590455
12:28:47 <Cale> > let (!) n = product [1..n] in (5!)
12:28:48 <lambdabot>   120
12:28:53 <dons> :)
12:29:06 <Renderwahn> ah, forgot the ()
12:29:17 <Cale> (the parens are required in that case -- it's a bit of an abuse)
12:29:30 <Cale> I wonder...
12:29:35 <Cale> > let (n!) = product [1..n] in (5!)
12:29:35 <lambdabot>   <no location info>: Parse error in pattern
12:29:38 <Cale> nope
12:29:49 <burp_> > let (!) n = product [1..n] in 5!
12:29:50 <lambdabot>   <no location info>: parse error on input `;'
12:30:06 <wli> Sorry, postfix operators aren't very well-supported.
12:30:07 <edwardk> @hpaste
12:30:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:38:10 <edwardk> ugh. the lack of ~ constraints in class definitions leads me to have to make some seriously ugly definitions for my parsers
12:41:20 <dschoepe> Is divMod more efficient than calling mod at one time and div later or is it just implemented as divMod x n = (x `div` n, x ` mod` n)?
12:41:37 <dolio> Depends on the type, probably.
12:41:37 <edwardk> dschoepe: assume it can be more efficient
12:41:39 <dschoepe> (For Int)
12:41:54 <dolio> For Int, it's the latter definition, I believe.
12:42:08 <dropdrive> I'm using Data.Binary to encode a Double, but the resulting ByteString has length 25.  I was expecting a length of 8.  Does anyone know what I'm doing wrong?
12:42:09 <edwardk> @src Int divMod
12:42:09 <lambdabot> Source not found. My pet ferret can type better than you!
12:43:03 <edwardk> dropdrive: the encoding unfortunately isn't a bitwise ieee double
12:43:11 <ski> vixey : ok
12:43:48 <ski> i suppose one could imagine `data Foo :: _ where ...' or `data where ...'
12:44:08 <vixey> one thing I don't like about :: * -> * is because the last '*' is _always_ *.. basically redundant
12:44:08 <edwardk> @type decodeFloat
12:44:09 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
12:44:10 <dropdrive> edwardk: Ah, thanks.  The format is something specific to Data.Binary?  Anyway, how suggestions on how  I can get those 8 bytes?
12:44:20 <vixey> you can do  Foo :: * -> (* -> *)
12:44:21 <edwardk> dropdrive: they use 'decodeFloat' and then encode that
12:44:23 <vixey> for example
12:44:32 <dolio> There's a quotRemInteger#, but only a quotInt# and a remInt#.
12:44:37 <vixey> well.. that is * -> * -> * .. but you know what I meant
12:44:38 <edwardk> dropdrive: this means that they don't handle NaN's properly, etc.
12:44:59 <edwardk> dropDrive: its hard to handle floats portably.
12:45:07 <ski> vixey : well, what is one could declare unboxed types, `data Foo :: * -> # where ...' ?
12:45:17 <ski> s/is/if/
12:46:02 <edwardk> dropDrive: since you'd have to handle nans, underflowed doubles, - and +0, etc.
12:46:39 <edwardk> dropDrive: the easiest way is to use all the Foreign.* nonsense, make a CDouble and peek at its bytes or whatever
12:47:13 <dropdrive> edwardk: Ah, that's what I was about to say.  I did use Foreign to wrap strtod, but then I sucked it in as a CDouble and not as a CString.
12:48:03 <dschoepe> dolio, edwardk: Thanks
12:55:09 <kerlo> I don't suppose 32-bit GHC will magically take advantage of 64-bit registers.
12:55:20 <thoughtpolice> hehe, no :(
12:55:38 * roconnor wants 128-bit computers
12:58:46 <skorpan> is there anything like break but offset by one? so that the first element in xs is put in the first part of the tuple?
12:58:53 <skorpan> > break (>3) [1..10]
12:58:54 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
12:59:03 <skorpan> i'd like that to be ([1,2,3,4],[5,6,7,8,9,10])
12:59:23 <roconnor> > span (not . (>3)) [1..10]
12:59:25 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
12:59:29 <roconnor> :/
12:59:32 <skorpan> @src break
12:59:33 <lambdabot> break p =  span (not . p)
12:59:34 <skorpan> :)
12:59:36 <roconnor> :)
12:59:57 <roconnor> I'm out of ideas
13:00:02 <cypher-> > 7.5 / 4.5
13:00:03 <lambdabot>   1.6666666666666667
13:00:36 <roconnor> skorpan: your function is strange, because the first list has the property that none of the elements statify p except maybe the last one!?
13:00:45 <roconnor> skorpan: sounds difficult to reason about
13:00:59 <roconnor> skorpan: I suggest rethinking your problem. :)
13:01:19 <skorpan> no, i'm completely sure this is what i want
13:01:26 <skorpan> but hm... no, not really.
13:01:32 <skorpan> what i really want is just the second list of what i said
13:01:43 <skorpan> so maybe i could use a variation of dropWhile?
13:02:04 <adamvo> > ((\(x,y) -> (x ++ take 1 y,drop 1 y)) $ break (>3) [1..10]
13:02:05 <lambdabot>   <no location info>: parse error on input `;'
13:02:19 <adamvo> > (\(x,y) -> (x ++ take 1 y,drop 1 y)) $ break (>3) [1..10]
13:02:20 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
13:02:25 <RayNbow> @hoogle Arrow a => [a b c] -> a b [c]
13:02:25 <lambdabot> No results found
13:02:41 <adamvo> is that really that ugly/inefficent?
13:02:51 <roconnor> skorpan: if you just want the second list, don't you just take the tail of the second list?
13:03:07 <roconnor> adamvo: it is somewhat ugly/inefficent
13:03:07 <skorpan> dropWhile' p xs = let res = dropWhile p xs in if null res then [] else drop 1 res
13:03:18 <skorpan> roconnor: i guess that's better than what i came up with
13:03:23 <skorpan> dropWhile' p xs = let res = dropWhile p xs in tail res
13:03:30 <skorpan> awesome, thanks :)
13:03:33 <roconnor> skorpan: or rather take the drop 1 of the second list
13:03:44 <roconnor> > tail []
13:03:46 <lambdabot>   * Exception: Prelude.tail: empty list
13:03:49 <roconnor> > drop 1 []
13:03:51 <lambdabot>   []
13:03:51 <skorpan> snap.
13:04:27 <skorpan> i'll just use the first version then
13:04:34 <juturnas> How do you write the type signature for infix operators?
13:04:45 <skorpan> juturnas: just as if they were normal functions
13:04:48 <skorpan> :t (+)
13:04:49 <lambdabot> forall a. (Num a) => a -> a -> a
13:05:01 <juturnas> do you put the parens around the operator in the sig?
13:05:04 <skorpan> yes
13:05:12 <skorpan> (+) :: forall a. ...
13:06:12 <skorpan> :t after
13:06:14 <lambdabot> Not in scope: `after'
13:06:29 <juturnas> Ok I guess I'm just not getting something... I have a Vector type, and I want to define 'dot' as an infix operator to calculate the dot product
13:06:34 <juturnas> so does it look like..
13:06:48 <skorpan> oh
13:06:49 <juturnas> (dot) (Vector a b c) (Vector x y z) = a*x b*y c*z
13:06:53 <skorpan> no, just dot
13:07:04 <skorpan> dot (Vector..) (Vector..) = ..
13:07:07 <juturnas> then how does it know that its infix, from the type?
13:07:10 <skorpan> then you can use it as v1 `dot` v2
13:07:16 <skorpan> you can't make only "dot" infix
13:07:23 <juturnas> oh ok
13:07:31 <skorpan> you can use (Â·) though :)
13:07:44 <skorpan> > let (Â·) = (*) in 5 * 3
13:07:45 <juturnas> oh so haskell actually restricts it to symbols instead of chars?
13:07:46 <lambdabot>   15
13:07:52 <skorpan> juturnas: not all symbols, but yes
13:08:00 <skorpan> a subset of all symbols
13:08:06 <juturnas> ok, thanks, I'm gonna go look that up
13:09:40 <skorpan> :t mappend
13:09:42 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:10:17 <ehird> runghc doesn't seem to use the newest version of a given pkg :(
13:10:49 <beelsebob> ehird: runghc only looks in your global package database
13:11:02 <ehird> beelsebob: so not ~/.cabal?
13:11:02 <beelsebob> yet another case of cabal's odd install behavior biting someone...
13:11:04 <beelsebob> nope
13:11:09 <ehird> graaaaaaa!
13:11:12 <beelsebob> yep
13:11:12 <ehird> how do I fix that :-)
13:11:21 <beelsebob> you make cabal install globally
13:11:23 <Renderwahn> what was the name of the function that i.e. adds everything from [a] to [b]
13:11:26 <beelsebob> at least... that's how *I* fix it
13:11:38 <Renderwahn> ??? (+) [a] [b] is what I want to do
13:11:42 <beelsebob> Renderwahn: zipwith?
13:11:47 <Renderwahn> beelsebob: right
13:12:06 <Renderwahn> forgot the name and didn't find it :/
13:12:16 <beelsebob> Renderwahn: haskell.org/hoogle
13:12:43 <Renderwahn> looks helpfull
13:13:01 <beelsebob> try searching for (a -> b -> c) -> [a] -> [b] -> [c]
13:18:23 <Arpika> hi
13:19:28 <Cale> hello
13:20:59 <ehird> so, uh, any other solution?
13:21:36 <Arpika> anybody ! Do you see, what I'm typing?
13:21:43 <ehird> Nope
13:21:46 <ehird> :-)
13:22:02 <Arpika> great! :) I'm on IRC for the first time
13:22:18 <TomMD> Arpika: Do you have any questions wrt Haskell?
13:22:34 <Arpika> Yes, thats why I'm here
13:22:44 <skorpan> some people come here for java help
13:22:55 <roconnor> skorpan: hush
13:22:58 <Arpika> I have to write a simple program for tomorrow
13:23:04 <TomMD> Which class?
13:23:13 <skorpan> just unsafePerformIO
13:23:23 <Arpika> and i don't know how. But, who knows haskell it's very easy
13:23:25 <roconnor> skorpan: you are not helping
13:23:30 <skorpan> roconnor: sorry
13:23:41 <TomMD> Arpika: What class is this?
13:23:46 <Mortomes> Arpika: Are you going to ask us to do your homework?
13:23:59 <Arpika> yes, may I? please :)
13:24:09 <skorpan> heh
13:24:13 <TomMD> Arpika: No one here will do your homework for you.
13:24:16 <Arpika> my programs name is VAVEVI
13:24:22 <Arpika> have you herad it?
13:24:31 <DrSyzygyBE> dons: Fixed the cabal script. It still needs an arbitrary instance, but that'll have to come later.
13:24:37 <skorpan> i think Tobsan will do your homework
13:24:57 <Arpika> my english is a little poor, but i will try to tell, the output
13:25:00 <TomMD> skorpan: Is that a prof?
13:25:01 <trez> he's grrreat!
13:25:09 <skorpan> TomMD: doesn't matter, he's a haskell wizard
13:25:24 <TomMD> Arpika: Please don't - we really don't care what your homework assignment is and won't do it for you.
13:25:58 <roconnor> Arpika could be simply asking for help on his homework.  It is a bit unclear since English isn't Arpika's first language.
13:26:14 <Arpika> ok, so program gets the strings from in.txt, and writes the output into out.txt
13:26:58 <roconnor> Arpika: BTW, what is your native language?  I ask because there are some also a few language specific haskell channels.
13:27:11 <Arpika> my native is hungary
13:28:03 <skorpan> it copies a file basically?
13:28:05 <juturnas> I've always seen cross product written as x, is there a unicode symbol for it or is it just a plain alpha x?
13:28:20 <skorpan> Arpika: you could use readFile, that's a start!
13:28:22 <skorpan> :t readFile
13:28:23 <lambdabot> FilePath -> IO String
13:28:31 <roconnor> ah, no one in #haskell.hu.
13:28:36 <roconnor> :(
13:28:37 <skorpan> and then of course writeFile
13:28:49 <skorpan> so your task is basically to figure out how to use those two in a haskell program to what you want
13:29:15 <Arpika> the program have to write the same strings into out.txt, but every vocal character have to be like this: character-v-character
13:29:31 <skorpan> aha
13:29:43 <skorpan> so AOE would be VAVVOVVEV?
13:29:51 <skorpan> or VAVOVEV?
13:29:52 <roconnor> heh
13:29:53 <skorpan> uh, no
13:30:02 <skorpan> AVVOVVE or AVOVE?
13:30:09 <skorpan> uh......
13:30:10 <roconnor> AVAOVOEOE ?
13:30:11 <skorpan> never mind
13:30:17 <skorpan> i think roconnor got it right :)
13:30:17 <roconnor> er
13:30:21 <roconnor> AVAOVOEVE ?
13:30:21 <Arpika> no, AOE have to be like this: AVAOVOEVE
13:30:29 <roconnor> w00t!
13:30:29 <skorpan> okay
13:30:39 <skorpan> that would actually make an interesting function
13:30:48 <roconnor> sounds like a job for concatMap!
13:30:48 <demolithion> what would GTFO be?
13:31:08 <skorpan> GTFOVO demolithion =)
13:31:13 <Renderwahn> if a function should take a list of float tuples the signature would be [(Float,Float)] -> a  right?
13:31:19 <Arpika> GTFO will be: GTFOVO
13:31:23 <skorpan> Renderwahn: yes
13:31:36 <Cale> Renderwahn: yes, with 'a' probably replaced with something more suitable
13:31:53 <Renderwahn> doh, I messed up the return value, not the parameter
13:32:13 <Renderwahn> those compiler errors are rather cryptic sometimes :)
13:32:24 <Cale> Eventually you learn to make sense of them
13:32:25 <Arpika> so only vocal character have to change like: character-v-character
13:32:38 <Cale> Arpika: vowels
13:32:47 <Arpika> yes vowels
13:33:01 <skorpan> Arpika: so this is due tomorrow and you know no haskell?
13:33:28 <Cale> It still should only be a couple of lines when it's done.
13:33:33 <Arpika> yes, I have lots of homework, and this is for tomorrow
13:33:44 <Arpika> yes, only a few lines
13:33:59 <Arpika> i already done it in C langage,
13:34:02 <Arpika> and it works
13:34:08 <vixey> Arpika, and you intend to write it?
13:34:18 <Arpika> but for haskell I don't know
13:34:39 <Arpika> what means intend? a sec. i look after it
13:35:04 <Cale> There are basically two approaches you can take with Haskell here. You can either use the function concatMap, or you can write something which is recursive.
13:35:14 <Arpika> okay, I came here for help, I dont have time to learn haskell
13:35:27 <vixey> Arpika, that means no, you don't intend to write it?
13:35:35 <Cale> The recursive way might be easier to manage if you're a beginner.
13:36:16 <Arpika> My opinion was that you or somebody else help me, and you write the code for me
13:36:17 <roconnor> Arpika: http://learnyouahaskell.com/ will only take a few minutes
13:36:23 <Cale> Every string is either empty, or it is a string which has one character followed by another string.
13:36:24 <monadic_kid> If you not even going to attempt to try and do any of it don't expect anyone to help you, i find it quite offensive. Asking for help is one thing, asking for someone to do it all for you is another
13:36:33 <vixey> Arpika, you sort of avoid my question -- Are you going to write this yourself or not?
13:36:58 <Valodim> vixey: he's not. he's looking for someone to write it for him.. doesn't make it any better, I suppose
13:37:02 <Arpika> Now I not
13:37:10 <Arpika> I'm looking for someone
13:37:15 <vixey> Arpika: ok, bye then
13:37:38 <Cale> Arpika: I don't think anyone here will outright do your homework for you, but we will help answer questions you might have about the language.
13:37:43 <monadic_kid> Why don't even try it and ask when you get stuck
13:38:01 <Arpika> Okay, than please help me.
13:38:04 <Renderwahn> hey, anyone interested in writing my tests and my diploma for me? :)
13:38:26 <Renderwahn> oh, and my phd thesis too please
13:38:33 <Arpika> How can I send you the code I already wrote, and you will see what's wrong
13:38:40 <Cale> @paste
13:38:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:38:51 <inimino> my job is hard, anyone want to do my work for me?
13:38:52 <Cale> ^^ go there and paste it, then give us the link :)
13:39:16 <Cale> http://www.youtube.com/watch?v=rYaZ57Bn4pQ
13:39:25 <vixey> spending time talking to someone that isn't interested in haskell -- boring
13:39:46 <roconnor> I'm unemployed; can someone find a job do the work and give me their money?
13:39:52 <Renderwahn> inimino: depending on the unemployment rates where you live this is a dangerous statement :)
13:40:06 <Arpika> so first I have to upload the file somewhere?
13:40:52 <inimino> roconnor: you win :)
13:41:09 <roconnor> inimino: I'll take your salary, thank you very much.
13:41:22 <roconnor> inimino: oh, can you pay the taxes on that.  Thanks again
13:41:28 <monadic_kid> Arpika: copy and paste code here: http://hpaste.org/new
13:41:45 <conal> andyjgill: i'm learning to use hpc and having some difficulty.  i've compiled a library (shady) with -fhpc and run it, generating a bunch of .mix files in a .hpc/ directory.  my test module's file name is *not* called "Main.hs", and 'hpc report' is saying "hpc: can not find Main in ["./.hpc"]", although there is a ./hpc/Main.mix .
13:42:03 <roconnor> @what hpc
13:42:04 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
13:42:05 * wli is still going on Project Euler #216.
13:42:12 <andyjgill> Oh.
13:42:25 <roconnor> wli:  how may days
13:42:27 <roconnor> many
13:42:27 <conal> andyjgill: i'd like to use a file name other than "Main.hs" so I can have more than one test program.  doable?
13:42:48 <andyjgill> Yes, it was. (paging context back in)
13:42:51 <wli> roconnor: No idea. With as low as my IQ has sunk I may never solve it.
13:43:26 <andyjgill> What version of the compiler are you using?
13:43:55 <conal> andyjgill: 6.11.20090115 (head)
13:43:56 <wli> I at least got the space footprint down a bit.
13:44:01 <roconnor> wli: I tried suming up a list of length 2^308 once
13:44:08 <roconnor> wli: that didn't work so good.
13:44:26 <andyjgill> It works on 6.10, I'll try get a new ghc.
13:44:49 <wli> I'm just using the deterministic Rabin-Miller primality test and sieving quadratic residues.
13:44:57 <conal> andyjgill: hpc'ing with a Main not called Main.hs works for you on 6.10?
13:45:13 <wli> It's apparently not quite enough to speed it up usefully.
13:45:25 <Berengal> > (5*10^7)^2
13:45:25 <lambdabot>   2500000000000000
13:45:41 <cypher-> is anyone planning to attend the summer school in applied functional programming at utrecht? do you think it's a good way to boost your fp-fu?
13:45:55 <andyjgill> It works, and works on 6.11.
13:46:05 <Berengal> What was the upper bound for the number of primes below a given number again?
13:46:23 <wli> It may be that I should try to populate a wheel/queue/etc.
13:46:24 <roconnor> Berengal: n
13:46:37 <wli> Berengal: Bertrand's postulate?
13:46:40 <tromp> (1+o(1)) n / ln(n)
13:46:45 <conal> andyjgill: i'm building and hpc'ing a whole library (shady).  i wonder if single-module vs multiple has anything to do with my difficulty.
13:46:56 <andyjgill> Ahh. but the Foo.hs (the Main) generates a file called Main.mix.
13:47:11 <conal> andyjgill: yeah.
13:47:12 <Berengal> wli: Possibly. I'm trying to figure out how many primes you possibly have to work with
13:47:28 <conal> andyjgill: that's what i see also.
13:47:37 <andyjgill> Okay.
13:47:47 <conal> andyjgill: does 'hpc markup Foo' work for you ?
13:48:13 <Cale> http://en.wikipedia.org/wiki/Prime_counting_function
13:48:46 <gwern> @quote Futamura
13:48:46 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
13:49:07 <Arpi> okay, so here is the link: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=4531
13:49:12 <andyjgill> Ahh. What do you type (exactly) on the hpc report line?
13:49:14 <Arpi> please help. thx
13:49:48 <wli> Berengal: x/ln(x)
13:50:07 <conal> andyjgill: "hpc markup TestSurface".  where "TestSurface" is the name of the executable, which cabal put in my ~/.cabal/bin
13:50:21 <wli> Berengal: But it's substantially less than that but over a larger range.
13:50:22 <conal> andyjgill: and i get back "hpc: can not find Main in ["./.hpc"]"
13:50:31 <andyjgill> try hpc report TestSurface.tix
13:50:44 <wli> Berengal: The primes need to be of the form 8*k+1 or 8*k+7.
13:50:49 <andyjgill> also ls *tix, an see what there is.
13:50:50 <Berengal> wli: I was basically thinking just read in an array of primes and lookup...
13:51:01 <Berengal> wli: Though you've probably thought of that
13:51:30 <wli> Berengal: Trying to iterate over primes is a loser because it's much larger than the original search space.
13:51:34 <conal> "ls *.tix" gives "TestSurface.tix".  "hpc markup TestSurface.tix" gives: hpc: can not find Main in ["./.hpc"]
13:51:41 <Arpi> can somebody help me?
13:52:01 <TomMD> Arpi: Whats the issue?  I saw your code, but didn't see any statement of problems.
13:52:02 <conal> andyjgill: and "ls ./hpc" shows a Main.mix plus my library modules
13:52:10 <conal> andyjgill: (as .mix files)
13:52:18 <skorpan> Arpi: just a note, ['a'] is the exact same thing as "a"
13:52:19 <Berengal> wli: Yes, but you need to just confirm it it's a prime or not, no? I was thinking along the lines of a heuristic binary search over the array
13:52:25 <Berengal> if it's*
13:52:32 <wli> Berengal: p `mod` 8 == 1 || p `mod` 8 == 7 is automatic for p = 2*n*n-1
13:52:33 <andyjgill> Does hpc report TestSurface work?
13:52:53 <conal> andyjgill: same error message
13:52:54 <skorpan> Arpi: you want a function which takes one character and outputs a string... not String -> String.
13:53:02 <conal> andyjgill: oops -- retrying
13:53:02 <andyjgill> sigh.
13:53:06 <skorpan> Arpi: i.e. you want alakit :: Char -> String
13:53:22 <wli> Berengal: Once you have 2*n*n = 1 `mod` p you can eliminate everything congruent to n or p - n mod p greater than n.
13:53:37 <conal> andyjgill: correction.  "hpc report TestSurface" says "hpc: can not find Data.Proof.EQ in ["./.hpc"]"
13:53:55 <conal> andyjgill: there is an .hpc/Data.Proof.EQ.mix
13:53:59 <andyjgill> (switching channel)
13:54:09 <conal> thx
13:54:14 <Berengal> wli: Yeah, I can see that... I haven't really thought about this though...
13:54:16 <Arpi> <TomMD>: the problem is, that, the program gets a string, from be.txt. What i wrote is that how it have to write out the vowels. But id dont work for a long string, beacuse the program dosent know the other characters
13:54:33 <Arpi> try it for long strings in be.txt. it dont worl
13:54:35 <Arpi> worl
13:54:36 <Arpi> work
13:55:13 <wli> Berengal: You can basically do something vaguely like Eratosthenes to sieve for the n where 2*n*n-1 is prime.
13:55:40 <Zao> Arpi: You seem to be lacking a base case for unknown codepoints.
13:56:12 <TomMD> Arpi: As skorpan said - you probably want the function 'vavevi' to be defined as :: Char -> String then run vavevi to each character of the input.
13:56:17 <Zao> I'd model alakit :: Char -> String, personally.
13:56:19 <TomMD> s/to/on
13:56:38 <gwern> there's a *fourth* futamura projection??
13:56:41 * gwern 's head asplodes
13:56:47 <Berengal> wli: Ah, I see, sort of. Just curious, but have you found the answer and are just looking to decrease your time, or haven't you found the answer yet?
13:56:55 <wli> Berengal: I've tried fully factoring things to get more primes where 2 is a quadratic residue.
13:57:32 <wli> Berengal: My "solution" is so slow that it's yet to find an answer after running for 2 or 3 days.
13:57:52 <vixey> > 10^10^3 - 1
13:57:54 <lambdabot>   999999999999999999999999999999999999999999999999999999999999999999999999999...
13:58:11 <Arpi> <TomMD>: yes, yes, exactly EACH CHARACTER of the input, and if the character is a vowel than write out vowel-v-vowel, else the charachter
13:58:46 <wli> Berengal: So it needs to be very substantially speeded up to make any progress at all.
13:59:48 <TomMD> Arpi: So modify the program to do that - work on each character - not strings that happen to be one character long.
14:00:45 <Berengal> wli: Ah, yes, that's a bit longer than I would've done as well. Longest I've left one running was a few hours while I was at work (I hadn't provided a base-case so it never finished even after finding the answer. Lazyness ftw)
14:01:50 <Zao> Arpi: If you apply a Char -> String function to each Char of a String, you get a [String].
14:02:07 <Zao> Now, there are functions to glue lists (and thus strings) together.
14:02:12 <Arpi> <TomMD>:like this?: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=4532   But now it says type error, and  i dont know why
14:03:16 <Zao> Arpi: Because your types do not match.
14:03:27 <Arpi> I'm doing the compile and run with winHugs
14:03:38 <Zao> @type map
14:03:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:03:45 <Berengal> @type concatMap
14:03:46 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:04:05 <TomMD> Arpi: The type of 's' is a String, but vavevi expects a Char.
14:04:10 <Zao> Berengal: Just using concatMap opaquely without knowing what it does doesn't help much though.
14:04:28 <TomMD> Arpi: So you need to apply vavevi to each Character in the String 's'.
14:04:39 <Cale> Arpi: You definitely want your vavevi function to be String -> String
14:04:39 <Berengal> Zao: Yeah, point taken
14:04:47 <TomMD> Arpi: Then glue those resulting strings together to form one long string.
14:05:01 <Cale> Arpi: this alakit function is a good start though
14:05:01 <Zao> > map (:[]) "omg"
14:05:02 <lambdabot>   ["o","m","g"]
14:06:11 <TomMD> Arpi: And Cale has it right - you probably want these changes to be in vavevi, so vavevi would be :: String -> String.  I kept saying vavevi when I ment alakit, so sorry for the switch up.
14:06:45 <Zao> Metasyntactic variables with odd names always trips me up.
14:06:57 <Zao> I suppose they have meaning in whatever locale they're from.
14:08:36 <vixey> what metasyntactic
14:09:43 <TomMD> Arpi: I understand what you are trying to do, no need for C code.  Lets keep the conversation in #haskell - I'm doing my own work too and am likely to disappear at any minute.
14:10:49 <TomMD> Arpi: You are very close to a good final solution - just need to redefine vavevi a little bit.
14:12:00 * wli ponders how to speed it up.
14:12:49 <Fairweather> hey guys
14:12:53 <Fairweather> and gals
14:12:59 <Taejo> hi Fairweather
14:13:16 <Fairweather> ^_^
14:18:37 <skorpan> @src (.)
14:18:37 <lambdabot> (f . g) x = f (g x)
14:18:41 <skorpan> @src ($)
14:18:42 <lambdabot> f $ x = f x
14:22:15 <Cale> > map head . group . sort $ "I wonder what characters this string uses?"
14:22:16 <lambdabot>   " ?Iacdeghinorstuw"
14:22:55 <Fairweather> hmm
14:23:06 <wli> > Set.toList $ Set.fromList "I wonder what characters this string uses?"
14:23:07 <lambdabot>   " ?Iacdeghinorstuw"
14:23:24 <vixey> > id "I wonder what characters this string uses?"
14:23:25 <lambdabot>   "I wonder what characters this string uses?"
14:23:43 <mauke> Â¿sÇsn ÆƒuÄ±É¹Ê‡s sÄ±É¥Ê‡ sÉ¹ÇÊ‡É”ÉÉ¹ÉÉ¥É” Ê‡ÉÉ¥Ê É¹ÇpuoÊ Ä±
14:24:09 <Cale> > map (head &&& length) . group . sort $ "I wonder what characters this string uses?"
14:24:10 <lambdabot>   [(' ',6),('?',1),('I',1),('a',3),('c',2),('d',1),('e',3),('g',1),('h',3),('...
14:24:26 <yowgi> > nub "I wonder what characters this string uses?"
14:24:27 <lambdabot>   "I wonderhatcsigu?"
14:25:15 <wli> > Map.toList . Map.fromListWith (+) $ map (\c -> (c, 1)) "I wonder what characters this string uses?"
14:25:17 <lambdabot>   [(' ',6),('?',1),('I',1),('a',3),('c',2),('d',1),('e',3),('g',1),('h',3),('...
14:30:08 <juturnas> So if I want to use * / + - etc with my Vector type, I have to instance Num right?
14:30:39 <Saizan> juturnas: yes
14:30:55 <Saizan> juturnas: unless you want to hide the Prelude definition of those operators
14:31:13 <juturnas> It gives me warnings because I don't implement fromInteger and a few other operators that don't make sense to me
14:31:42 <juturnas> Is there a way to hide the warnings, or should I be implementing them for some reason?
14:32:20 <Athas> I would implement them with the value "undefined".
14:32:30 <Saizan> juturnas: you can use error "it makes no sense" as implementation
14:33:16 <juturnas> What is undefined?  I mean, as far as the compiler knows
14:33:19 <dons> use 'error'
14:33:20 <mauke> @src undefined
14:33:21 <lambdabot> undefined =  error "Prelude.undefined"
14:33:21 <vixey> @src undefined
14:33:22 <lambdabot> undefined =  error "Prelude.undefined"
14:33:27 <juturnas> ah ok
14:33:36 <mauke> error "Vector.fromInteger: not implemented"
14:33:44 <juturnas> so would that be a runtime error or compile time?
14:33:47 <mauke> runtime
14:34:08 <juturnas> ok, thanks guys
14:34:14 <Berengal> Couldn't it sometimes make sense to use fromInteger? Like 3 -> (3,0)?
14:34:20 <Berengal> Maybe not...
14:34:22 <Cale> Or else (3,3)
14:34:34 <juturnas> Yeah I guess it could actually
14:35:02 <juturnas> I think that would be confusing for someone else using my code, but no one else will be using it so I may as well
14:35:03 <Cale> (that guarantees that multiplication by 1 will result in the same thing)
14:35:23 <Cale> (provided that you implement multiplication componentwise)
14:35:52 <roconnor> Cale: you have not basis for that
14:36:04 * roconnor enjoys his little pun
14:36:05 <Cale> What?
14:36:08 <Cale> hehe
14:36:14 <roconnor> for (3,3)
14:36:56 <Berengal> juturnas: If you were going to use undefined anyway, you could simply not use vector literals to make it non-confusing
14:37:04 <Cale> Componentwise operations give you a ring, but not a very nice ring.
14:37:42 <juturnas> hm
14:38:13 <Cale> If your vectors are 2D, you should consider using Complex numbers, which there's already a library for :)
14:38:28 <juturnas> they are 3d
14:38:49 <Cale> I probably wouldn't bother with Num for 3D vectors.
14:39:12 <juturnas> why not? just wondering
14:39:51 <Cale> Because they don't give a very nice ring. What you really want are the vector space operations, and it makes sense to give them different names anyway
14:40:15 <juturnas> What do you mean by 'ring'?
14:40:40 <Cale> Oh, right, it's a mathematical term characterising the properties we usually expect of numbers
14:40:56 <Cale> Different rings correspond to different types of numbers
14:40:58 <juturnas> oh..
14:41:22 <Cale> (more or less -- 'ring' is a technical term, but 'number' is more vague)
14:41:30 <juturnas> k, gotcha
14:41:52 <vixey> ring means you have + and * 0 and 1, 0 <> 1 and... some more stuf..
14:41:56 <Cale> Usually I go with something like *^ for scalar multiplication and ^+^ for vector addition, where the ^'s indicate on which side the vectors go.
14:42:10 * Berengal wonders what haskell's numeric system would look like if it was designed by "real" mathematicians
14:42:24 <vixey> Berengal: don't think typeclass dispatch is 'powerful' enough though
14:42:26 <juturnas> wow, I already used *^ for that, odd
14:42:44 <Cale> Berengal: I actually think that there's not *too* much wrong with it. Num should be pared down a bit.
14:43:05 <juturnas> Cale: Thanks, I think I'll just do operators as you suggest
14:43:07 <Berengal> Yeah, Num has a few functions too many
14:43:08 <Cale> Berengal: possibly split up into additive and multiplicative classes.
14:43:23 <Cale> Berengal: But there are some features missing to make that really convenient.
14:43:25 <mauke> Num should drop Eq and Show
14:43:34 <Cale> Oh, and yes, it should do that.
14:43:48 <Berengal> Numbers that arent' Eq?
14:43:54 <Cale> Berengal: Like functions.
14:44:07 <Berengal> Functions are numbers now?
14:44:14 <mauke> yes
14:44:15 <dolio> Why not?
14:44:17 <Cale> Functions whose codomain is a type of number form a ring.
14:44:19 <mauke> all applicatives are
14:44:31 <Cale> Indeed.
14:45:03 <Cale> (Applicative f, Num a) => Num (f a)
14:45:08 <juturnas> Ok so it doesn't matter to me now, but I'll ask anyway, why doesn't it let you implement division (/) when you instance Num?
14:45:24 <Cale> juturnas: Because not all kinds of numbers support true division.
14:45:41 <Cale> juturnas: Integers for example only have div and mod, which are in the Integral class
14:45:47 <dons> Berengal: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude ?
14:46:09 <Berengal> Wow...
14:46:09 <juturnas> ah ok... is there another way to do it so you can use / ?
14:46:17 * Berengal wishes he had taken more math courses
14:46:18 <Cale> juturnas: instance Fractional
14:46:20 <dons> and if it was designed by an egineer: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional
14:46:28 <juturnas> ah ok
14:46:29 <dolio> I'm not sure mathematicians would write numeric-prelude. :)
14:47:33 <Berengal> I sense a lengthy wikipedia session coming on...
14:47:37 <Cale> Ugh, Henning Thielemann has no taste when it comes to code style :)
14:47:51 <Cale> Every single one of his classes is called C
14:48:17 <Cale> and all of his types are called T
14:48:30 <dons> good news everyone: Ralf Hinze's instance Num,Fractional,Real for infinite streams is available: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hinze-streams-1.0
14:48:34 <Cale> It's absolutely ridiculous trying to read the documentation.
14:48:36 <monadic_kid> which reminds me did you read the interview with the guy behiind J?
14:48:42 <Cale> div :: (C a, C a) => T a -> T a -> T a
14:48:46 <dolio> When asked him about that, he says something like, "this is good style in ML", but he's not writing ML.
14:48:56 <Cale> *cough*
14:49:01 <dons> henning's a hacker
14:49:04 <Lemmih> Cale: Sounds like he used to write ML.
14:49:22 <Cale> But ML doesn't even *have* typeclasses.
14:49:24 <dons> Ralf's package also notably uses n+k
14:49:30 <dons> on infinite streams as numeric literals
14:49:46 <mahogny> "s1349.c  s1386.c  s1515.c"  <--- a few of the files included in this library. give me C/T any day
14:49:48 <Berengal> O_o
14:50:02 <Cale> class C a => C a where
14:50:03 <Cale> ahahaha
14:50:07 <Athas> Maybe they are protocol names or something?
14:50:23 <Athas> A man can dream, at least.
14:50:37 <Cale> You have to click each of the links to figure out where each C points to.
14:50:45 <newsham> i'd like to imagine they are inode numbers :)
14:50:54 <Deewiant> class (C a, C a v) => C a v where
14:51:32 <mmorrow> Cale: heh, i didn't think you actually meant that they're all *literally* called 'C'
14:51:39 <Cale> mmorrow: They are!
14:51:44 <Deewiant> Four instances in a row all saying "C a => C (T a)" is fun, too
14:51:44 <mmorrow> hah
14:51:50 <vixey> umm
14:51:57 <vixey> They aren't written this way in source code though
14:52:01 <Cale> He just puts them all in separate modules
14:52:12 <Deewiant> Well yeah, he uses qualified imports
14:52:19 <vixey> it's not C it's Foo.C
14:52:27 <Cale> But it makes the Haddock impossible to read
14:52:30 <Deewiant> But why not just call the class Foo
14:52:36 <vixey> Oleg is the one that only uses one typeclass called C
14:52:38 <newsham> cale: sounds like a problem with haddock
14:52:53 <Cale> Well, qualified imports are the work of the devil anyway
14:52:56 <Lemmih> Deewiant: Then you get the Map.Map problem.
14:53:12 <dolio> It's Map.T, obviously. :)
14:53:18 <Deewiant> Lemmih: Not necessarily, unless they all conflict with each other
14:53:29 <Deewiant> And it's not much of a problem IMO :-P
14:53:38 <juturnas> Its really weird having ^-^ in my code...
14:54:09 * Cale liked it when people still wrote modules that named their identifiers such that unqualified imports wouldn't create overlapping names.
14:54:29 <Cale> juturnas: :)
14:54:32 <Deewiant> When you have over 1000 libraries that gets difficult.
14:54:43 <Cale> Deewiant: true, but they could still try
14:54:51 <Cale> Instead of reusing names from the Prelude.
14:55:17 <dons> 1251.
14:55:26 <Cale> I tend to see qualified imports as a means of last resort.
14:55:35 <newsham> cale: colliding import names would be more useful if modules were first class.
14:56:23 <dons> i hate  the ACM.
14:56:35 <Cale> Interesting pause there.
14:56:47 <dons> they're  the record companies of our industry. controlling the distribution system, providing nothing.
14:56:48 <dabbler> hi
14:57:08 <Cale> dons: Yes, academic publishing companies need to die.
14:57:10 <dons> but they're holding back science, instead of art.
14:57:28 <Cale> dons: They're leeches and provide essentially nothing.
14:57:34 <dons> yep. hosting is cheap now.
14:57:41 <dons> and that's all they're doing.
14:57:49 <dabbler> yeah, seems like academic publishing just gets by on legacy and prestige
14:57:57 <newsham> seems there's a movement in several academic camps to move towards open publication of academic lit
14:58:00 <newsham> esp govt funded.
14:58:06 <dons> there's some signs of rebellion: http://lists.seas.upenn.edu/pipermail/types-announce/2009/001436.html
14:58:11 <newsham> i have my fingers crossed
14:58:11 <dabbler> i think the biologists even went on strike
14:58:13 <dons> for CT/ types conferences
14:58:27 <dolio> So, who are the Backstreet Boys of computer science research, then?
14:58:35 <Cale> lol
14:58:37 <dons> i like the idea of new haskell stuff disassociating itself from ACM, based on lack of open access.
14:58:45 <newsham> dolio: lots of phd five boy bands
14:58:53 <newsham> and assoc profs
14:59:04 <dons> we have to tell them that lack of open access is fundamentally opposed to how science works. they can't lock down the .pdfs
14:59:05 <Cale> The Klein Four Group needs another member?
14:59:20 <wli> dons: Amen
14:59:37 <Cale> dons: We just need to stop talking to them entirely.
14:59:42 <dons> then they need to scale back the huge ACM operation to being just a "we can hook you up with paper copies if you want them" company.
14:59:45 <dons> instead of trying to own the .pdf
14:59:58 <dabbler> when do they release the pdf?
14:59:58 <newsham> this "dimensional" package looks really cool
15:00:09 <dons> newsham: do you know bjorn?
15:00:14 <dons> he works for intelsat.
15:00:21 <dons> so kinda into getting units of measurement right
15:00:45 <dons> its very cool. i think we're way ahead of the competition (e.g. F# is considering language extensions to try to do this!)
15:00:48 <newsham> no, I dont.
15:00:50 * mmorrow finally gave in and bought an acm membership to get access to the papers
15:00:52 <Cale> Everyone can hook themselves up with a paper copy of anything if they have access to a printer. Universities tend to have nice laser printers and printing services which will even bind the things into books, and independent people can buy their own printer if they really care that much.
15:01:02 <mmorrow> the magazine they send you every month is decent at least
15:01:14 <Cale> We don't need some stupid publishing company to do that for us.
15:01:18 <dons> yeah, but then they're a magazine company
15:01:21 <newsham> "ohm = volt / ampere" <- actual code.  sweet
15:01:33 <dons> instead of just finding a way to spend all that cash
15:01:34 <mmorrow> dons: heh. i resisted as long as i could.
15:01:43 <dolio> dabbler: Do they?
15:01:45 <Medved> how to make easily a list: a0 = 1, a1 = 2, a2 = 3, an = a(n-1) + a(n-2) + a(n-3)?
15:01:48 <Cale> mmorrow: I just use my friend's library account :)
15:01:54 <dabbler> dolio: oh maybe not
15:02:11 <wli> Medved: Ah
15:02:14 <dons> i wonder who we talk to about making it an unconditional requirement for open access for ICFP et al.
15:02:24 <vixey> Medved: don't use numbers in names when possible, write it like  a 0 = 1 ; a 1 = 2 ; ... instead
15:02:30 <dons> The Union of Concerned Haskellists demands freedom!
15:02:42 <Medved> a 0 = [1]
15:02:49 <vixey> no need for []
15:02:49 <Medved> a 1 = [1,2]
15:02:50 <newsham> a = 1 : 2 : 3 : zipWith3 (\a b c -> a + b + c) a (drop 1 a) (drop 2 a) ?
15:02:50 <wli> > let xs = 1 : 2 : 3 : zipWith3 (\x y z -> x + y + z) xs (tail xs) (drop 2 xs) in xs
15:02:52 <Cale> > let xs = 1 : 2 : 3 : zipWith (+) xs (zipWith (+) (tail xs) (tail (tail xs)))
15:02:52 <lambdabot>   [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,...
15:02:53 <lambdabot>   <no location info>: parse error on input `;'
15:02:59 <Medved> a 2 = [1,2,3]
15:03:10 <vixey> Medved: just write it like you did before except with spaces
15:03:14 <mauke> > let xs@(_ : xs'@(_ : xs'')) = 1 : 2 : 3 : map sum (transpose [xs, xs', xs'']) in xs
15:03:15 <Cale> > let xs = 1 : 2 : 3 : zipWith (+) xs (zipWith (+) (tail xs) (tail (tail xs))) in xs
15:03:16 <lambdabot>   [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,...
15:03:16 <lambdabot>   [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,...
15:03:36 <monadic_kid> dons: if you meant untis of measure, it's been in f# for a while
15:03:42 <monadic_kid> *units
15:03:43 <Medved> nice, thanks
15:04:01 <dons> how is it in F#? just a library? (they've no type classes, so I'm guessing baked in primitives?)
15:04:25 <Cale> dons: Another thing people should stop agreeing to is doing the publishing companies' peer review job for them.
15:04:28 <dolio> > unfoldr (\(x,y,z) -> Just (z,(x+y+z,x,y))) (1,2,3)
15:04:30 <lambdabot>   [3,2,1,6,9,16,31,56,103,190,349,642,1181,2172,3995,7348,13515,24858,45721,8...
15:04:37 <dolio> > unfoldr (\(x,y,z) -> Just (z,(x+y+z,x,y))) (3,2,1)
15:04:38 <lambdabot>   [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,...
15:05:27 <Cale> dons: Peer review isn't something we need them for, but it's one of the only arguments that makes any sense at all for why they still exist.
15:05:53 <Medved> dolio i was firt trying to find a way to generate it [x | x<-...]
15:06:36 <Cale> > let xs = 1 : 2 : 3 : [x + y + z | x <- xs | y <- tail xs | z <- tail (tail xs)] in xs
15:06:38 <lambdabot>   [1,2,3,6,11,20,37,68,125,230,423,778,1431,2632,4841,8904,16377,30122,55403,...
15:06:51 <Cale> You can do it as a parallel list comprehension like that
15:07:22 <pejo> dons, I think Baetz (?) has a lot of information on his homepage, but my net access seems flaky right now. I don't think it's in their interest to stop getting money.
15:07:37 <pejo> dons, F# has it in the type system. It's fairly orthogonal to other things I think.
15:07:38 <vixey> Medved: like this:  a 0 = 1 ; a 1 = 2 ; a 2 = 3 ; a n = a (n-1) + a (n-2) + a (n-3)
15:08:35 <monadic_kid> dons: i'm not sure, I haven't look into it much. F# doesnt have type classes at the moment but Don has been looking into it, i think he doesn't want full blown typeclasses, just a mechnism for type inferred ad-hoc polymorphism. As of current you can overload methods (because of .NET) and you can also define inline functions which act like C++ templates
15:08:49 <dabbler> Cale: Nice, I didnt know what was going on until I read your code
15:09:46 <pejo> dons, http://math.ucr.edu/home/baez/journals.html
15:10:12 <mahogny> Cale, dons, NIH used to require open access for funding but then publishing companies lobbied politicians into forbidding this policy >:| (NIH funds *a lot* of the bio/medical research)
15:10:44 <vixey> "#  Don't publish in overpriced journals." -- I already do that :p
15:13:41 <Renderwahn> @paste
15:13:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:13:51 <tromp> @toothpaste
15:13:52 <lambdabot> Unknown command, try @list
15:14:03 <vixey> @pajamas
15:14:03 <lambdabot> Unknown command, try @list
15:14:33 <tromp> @floss
15:14:33 <lambdabot> Not enough privileges
15:14:38 <Renderwahn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4537#a4537 can someone help me with the last pattern? if the list contains only one element [] is returnt instead of [x]
15:14:50 <mmorrow> @bedsores
15:14:50 <lambdabot> Unknown command, try @list
15:15:11 <vixey> Renderwahn: add in the middle shrink [x] = []
15:16:02 <Renderwahn> vixey: that didn't change anything
15:16:33 <Renderwahn> for shrink (+) [1] it should return [1]
15:16:50 <vixey> ok but you said:  if the list contains only one element [] is returnt instead of [x]
15:17:21 <Renderwahn> vixey: yes, the list contains x and [] is returned instead of [x]
15:17:39 * mmorrow is running plan 9 in qemu to learn how to use it. it's neat
15:17:44 <mmorrow> qemu -boot d -cdrom plan9.iso -smp 2 &
15:18:02 <dons> pejo: thanks for the ref to baez's work
15:18:11 <davidL> shrink f (x:y:ys) = (f x y) : (shrink f (y:ys))
15:18:26 <davidL> > let shrink f (x:y:ys) = (f x y) : (shrink f (y:ys)); shrink f x = x in shrink (+) [1]
15:18:28 <lambdabot>   [1]
15:18:44 <dons> i think the ACM lockup of ICFP / HW et al is fundamentally at odds with the open Haskell philosophy. and it holds back access to key libraries and ideas.
15:20:19 <Renderwahn> now I'm totaly confused
15:27:08 <pejo> dons, do you have any ideas for how to solve this?
15:27:18 <Apocalisp> What's the difference between $ and $! ?
15:27:32 <Axman6> $! is strict
15:27:36 <Axman6> @srw ($)
15:27:36 <lambdabot> f $ x = f x
15:27:38 <Axman6> @srw ($!)
15:27:38 <lambdabot> f $! x = x `seq` f x
15:27:44 <Baughn> Well, weak-head-normal-form kind of strict at least
15:28:00 <monadic_kid> ah googd old cilit bang
15:28:28 <Apocalisp> Ah, so f $! x evaluates x before f.
15:28:35 <Baughn> "foo $! bar `using` rnf" <-- Also, make a note never to type this.
15:29:17 <Apocalisp> @type rnf
15:29:18 <lambdabot> forall a. (NFData a) => a -> Done
15:29:58 <Apocalisp> > sqrt $ 2
15:29:59 <lambdabot>   1.4142135623730951
15:30:12 <Baughn> Apocalisp: Um. That line will evaluate bar /fully/ before calling foo
15:30:17 <Baughn> Basically giving you strict semantics
15:30:28 <Baughn> At the cost of walking the entire structure of bar at call-time
15:30:28 <Apocalisp> > sqrt $! (4/2) `using` r0
15:30:29 <lambdabot>       precedence parsing error
15:30:29 <lambdabot>          cannot mix `($!)' [infixr 0] and `usi...
15:30:43 <Apocalisp> heh
15:32:23 <Apocalisp> > let x = 4/2 in x `seq` sqrt x
15:32:25 <lambdabot>   1.4142135623730951
15:32:33 <Apocalisp> > let x = 4/2 in x `seq` sqrt x `using` r0
15:32:34 <lambdabot>       precedence parsing error
15:32:34 <lambdabot>          cannot mix `seq' [infixr 0] and `usin...
15:33:01 <Baughn> @src r0
15:33:01 <lambdabot> Source not found. Do you think like you type?
15:34:01 <Apocalisp> > let x = 4/2 in x `seq` sqrt x `using` r0
15:34:02 <lambdabot>       precedence parsing error
15:34:02 <lambdabot>          cannot mix `seq' [infixr 0] and `usin...
15:34:10 <Baughn> Add parantheses, geez
15:34:17 <Apocalisp> yea, accident
15:34:30 * Apocalisp curses lappy
15:34:49 <Baughn> Anyway, it'd be
15:35:06 <Baughn> > let x = 4/2 in (x `using` r0) `seq` sqrt x
15:35:07 <lambdabot>   1.4142135623730951
15:35:24 <Baughn> Or, as a matter of fact..
15:35:31 <Baughn> > let x = 4/2 in (r0 x) `seq` sqrt x
15:35:32 <lambdabot>   1.4142135623730951
15:36:00 <Baughn> @src using
15:36:01 <lambdabot> Source not found. Just try something else.
15:36:18 <Baughn> x `using` s = s x `seq` x
15:38:50 <dons> pejo: we'd have to talk to the ICFP organizers.
15:39:17 <dons> superficially, programming language people get freedom and open source more than most scientific groups, as well as the trivialities of online hosting.
15:42:41 <juturnas> Is there a mathematical term for squaring the x y and z components of a vector and taking their sum?
15:42:56 <Zao> dot product of self?
15:43:05 <Baughn> Sounds right
15:43:14 <juturnas> k, thanks
15:43:15 <monadic_kid> or the mag sqr
15:43:23 <Baughn> juturnas: Mind you, the correct channel is #math
15:44:02 <pejo> dons, well, Andrew Tolmach is probably really busy right now, but perhaps you should mention it to him the next time you bump into him?
15:44:09 <juturnas> Sorry, thanks for answering anyway, will connect to #math now :)
15:44:18 <monadic_kid> err not sqr i meant sq
15:45:06 <dons> pejo: i'm thinking more about approaching the entire steering committee
15:45:14 <dons> should have done it when they were in town last week :/
15:45:19 <Zao> @type sum $ zipWith (*) ?a ?b
15:45:20 <lambdabot> forall a. (?b::[a], ?a::[a], Num a) => a
15:45:47 <adamvo> @type sum . join (zipWith (*))
15:45:47 <lambdabot> forall a. (Num a) => [a] -> a
15:46:25 <adamvo> > sum . map (join (*)) $ [1..3]
15:46:26 <lambdabot>   14
15:46:51 <BMeph> dons: I haven't found the ACM issue to be more than a nuisance, but since I've been in and out of uni for over 25 years, now (and _still_ w/o a degree, dammit!) my viewpoint is certainly atypical. The papers that are published by SIAM drive me batty, though. :\
15:49:03 <BMeph> Even when I can find a way to get an SIAM paper, having to find a way to get it bugs me more than ACM or IEEE ones do, if only because so many of the latter are available on the authors' site in some form or another.
15:49:22 * mmorrow remember nostalgically when he had a student siam membership
15:49:28 <dons> things that bug me: galois organizers, reviews, publishes, speaks and sponsors CUFP. ACM wants to charge $15k  for corporate access to the material... for what?
15:50:34 <BMeph> dons: Obviously, for the blue diamond! Do you know how expensive blue diamonds are? ;p
15:51:19 <mmorrow> ooh, ooh, i want a blue diamond too!
15:51:46 <dons> oh, yes, well the monthly ACM blue diamond
15:51:48 <dons> that's nice.
15:54:00 <BMeph> Oh, on a totally different note: has anyone read the latest of the TCO articles - http://www.reddit.com/r/programming/comments/8hi8o/abstract_heresies_you_knew_id_say_something_part/
15:54:15 <vixey>  not more people talkirg about TCO :(
15:54:18 <Arpika> logout
15:55:26 <dons> oh, is that still going on.
15:55:31 <BMeph> vixey: Yeah - I flinch every time I hear the phrase "stack frame" - and this blog helped me burn off about 150 calories. I guess it's not a total loss, from that perspective. ;p
15:55:35 <dons> these "debates" are really boring.
15:55:37 <vixey> hahaha
15:56:12 <pejo> dons, does ACM sponsor CUFP in some way?
15:57:47 <dons> it's the "ACM SIGPLAN workshop on Commercial users of functional programming "
16:01:17 <pejo> dons, I meant financially.
16:08:48 <BMeph> At least I found out that Scheme's claims of "lexical scoping" fail for functions. It almost makes you wonder how they get lambdas to work at all... :\
16:09:05 <vixey> BMeph: it is lexical scoping
16:09:06 <SamB> BMeph: hmm?
16:09:15 <SamB> it just has mutable variables, is all
16:09:35 <vixey> BMeph: SET! means changing the actual content of that name
16:09:44 <vixey> not modifying the content
16:09:52 <SamB> I think it's slightly less confusing than the same issue in Python ...
16:09:59 <vixey> so.. like changing what the name points at -- not what is pointed at
16:10:05 * vixey feels to be ..not making sense
16:10:23 <SamB> (probably more due to the behaviour of the control structures than the scoping per-se)
16:11:50 <dons> pejo: i don't think so.
16:12:54 <redline6561> quick possibly dumb question, i've cabal installed hscurses. when i try to runhaskell Setup.hs it's example program it claims I'm missing the hscurses dependency. how can I fix this?
16:13:10 <dons> might be missing --user
16:13:27 <dcoutts> redline6561: just use cabal configure rather than runhaskell Setup configure
16:13:34 <redline6561> dons: thanks
16:13:41 <redline6561> dcoutts: i'll give that a shot
16:13:50 <dcoutts> redline6561: the cabal program completely replaces the runhaskell Setup command line interface, there's no need to use both.
16:14:09 <dons> and it makes local builds consistent with cabal install remote builds
16:14:44 <redline6561> dons: that flag did the trick
16:15:04 <redline6561> dcoutts: good to know. i'll just stick to cabal from now on. it is very nice. thanks. :)
16:15:18 <monadic_kid> redline: you want get yourself cabal install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
16:15:43 <monadic_kid> redline: takes care of depedancies like package managers under linux
16:16:19 <redline6561> monadic_kid: i have cabal install but i have it install everything locally (to home) so it wasn't seeing hscurses
16:17:01 <dcoutts> redline6561: the reason is that the old runhaskell Setup system uses --global by default but the cabal program uses --user by default and global packages cannot depend on user ones.
16:17:09 <ilseman2> @pl     dP n s x = plus (return x) $ d n s
16:17:09 <lambdabot> dP = (flip (plus . return) .) . d
16:17:35 <redline6561> dcoutts: awesome. thanks.
16:28:06 <Lemmih> Yay, my cps'd state is 10 times faster than the ridiculously fast unboxed cps'd state (:
16:28:55 <Lemmih> And LHC should in theory be able to do all the needed optimizations automatically.
16:29:09 <Saizan> what did you change?
16:30:43 <Lemmih> I did inlining, constructor specialization and loop unrolling.
16:31:47 <Lemmih> mtl version: 1.35s, cps version 0.45s, fastest version: 0.05s.
16:34:38 <Lemmih> All the transformations I used are on the TODO list for LHC. I should write a blog post about it.
16:38:19 <ehird> (unsafePerformIO . newIORef) is so common; why isn't it in a library? e.g. as globalIORef
16:39:04 <byorgey> Lemmih: yes, you should =)
16:39:12 <Lemmih> ehird: I don't think that would work.
16:39:16 <ehird> Lemmih: er, why not?
16:39:20 <ehird> it's a common idiom
16:39:27 <Saizan> you need a pragma on the binding
16:39:31 <ehird> right
16:39:47 <ehird> Saizan: which one? inline or noinline, but my ghc-internals-brain can't figure out which
16:39:57 <Saizan> NOINLINE
16:40:02 <Lemmih> ehird: If 'globalIORef' doesn't get inlined right then your program will crash.
16:40:09 <ehird> right
16:40:12 <ehird> thus noinline
16:40:25 <glguy> the global ioref isn't really something to be encouraged via a standard library
16:40:26 <Saizan> i mean, you need noinline on the variable you make
16:40:31 <Saizan> not on globalIORef
16:40:36 <ehird> Saizan: ah, hm
16:40:38 <Lemmih> ehird: NOINLINE when you "copy" globalIORef. INLINE when you define it.
16:40:39 <Saizan> that's why defining it won't help
16:40:57 <ehird> glguy: there's nothing inherently wrong with it IMO
16:41:14 <glguy> itâ€™s a basic anti-pattern
16:41:28 <Lemmih> ehird: You'd be a hair's width away from segfaulting.
16:41:28 <ehird> disagreed
16:41:42 <ehird> Lemmih: yeah, I'll do some experimentation to find a safe version of it
16:41:47 <ehird> â€¦which is the whole point of it being in a library
16:42:13 <Saizan> i don't think you can make a safe function for it, can you?
16:42:19 <ehird> we'll see
16:42:40 <Lemmih> ehird: Hm, it might not work with all Haskell compilers.
16:43:06 <ehird> Lemmih: I can do CPP conditionals on them if needs be; certainly it's ugly, but it beats writing it in every program using the idiom
16:43:13 <wli> antipattern?
16:43:20 <Saizan> does ghc ever decides to inline a CAF?
16:43:26 <Saizan> wli: global mutable state
16:43:44 <glguy> wli: "In software engineering, an anti-pattern (or antipattern) is a design pattern that appears obvious but is ineffective or far from optimal in practice." --wikipedia
16:44:58 <Lemmih> I am horrified that we're using such a nasty trick for common things like stdout.
16:45:14 <ehird> Lemmih: yeah, the basic idiom needs specifying somehow
16:45:18 <ehird> I don't think it's inherently bad though
16:45:20 <ehird> I think it's modular
16:45:27 <ehird> more modular than a big glob of a State monad
16:45:46 <Saizan> it's not modular because i can't decide to have two instances of your "module"
16:46:04 <Saizan> or rather, i'll have them depending on how linking works
16:46:35 <Berengal> I now have a file containing over 80 lines of only IO...
16:46:42 <ehird> i mean modularizing the state of your program into components
16:46:43 <skorpan> http://www.youtube.com/watch?v=hkDD03yeLnU
16:46:51 <Lemmih> Right, I would live with global mutable state. It's the dependence on certain optimizations for correctness that urks me.
16:47:02 <ehird> Agreed.
16:47:15 <ehird> Thus why, if it can be abstracted to a library, that's great.
16:47:16 <Saizan> you can modularize it fine without global mutable state
16:47:42 <Lemmih> ehird: But it by definition cannot.
16:48:19 <SamB> Lemmih: what definition?
16:50:47 <Lemmih> Maybe that's the wrong word.
16:51:41 <thoughtpolice> Lemmih: you should write a post about it on the blog. i've been meaning to, but these are my last two weeks of class
16:51:57 <ehird> Seems like my preliminary tests are working fine with highly aggressive optimization, both via C and not via C
16:52:34 <Lemmih> What I mean is, no amount of make-up will change the nature of the problem.
16:54:13 <thoughtpolice> Lemmih: yes, jhc's code base was a good indication of that. :)
16:54:19 <ehird> Is there a way to get ghc -fvia-C's C code?
16:54:33 <Lemmih> ehird: -keep-tmp-files I think.
16:54:42 <Lemmih> It's not pretty, though.
16:54:51 <Saizan> also, the MonomorphismRestriction becomes a matter of soundness, right?
16:54:56 <dons> the C's not really useful
16:55:01 <dons> the core, and the asm inner loops, are useful
16:55:19 <ehird> Lemmih: nope
16:55:39 <ehird> dons: just trying to make sure that the generated code is safe :)
16:58:06 <dev31212> What is the best Haskell Templating system?
16:58:10 <dev31212> HStirngTemplate?
16:58:16 <dons> hmm. that's certainly popular.
16:58:22 <dons> i don't think there's a winner yet.
16:58:32 <dev31212> ahh ok...still in the early days I guess
16:58:35 <dons> you might want to do some comparative experiments.
16:58:47 <dev31212> dons, can you throw out some other names for me to google?
16:58:57 <mauke> printf :-)
16:59:05 <dev31212> lol
16:59:18 <dev31212> Well I am starting to make web apps with haskell
16:59:28 <dev31212> I wanna start with something that isnt to buggy..easy to use
16:59:28 <dev31212> etc
17:00:17 <dev31212> I am a man with no country
17:00:26 <dev31212> Most people think I am nuts to use Haskell at all
17:00:33 <dev31212> I say because I want safer, shorter, less buggy code
17:00:40 <ehird> login name php_love ey?
17:00:41 <dev31212> and haskell users think I am crazy to make web apps with it
17:00:41 <ehird> ;-)
17:00:57 <dev31212> lol
17:01:21 <sclv> i'm a bit biased, but hstringtemplate is, i think, the only real haskell templating lib at this point. hsp isn't a template library, but is for php/jsp type programming with the code embedded in the output, and the html libraries are for programmatic generation of html. all are valid approaches, but only hstringtemplate is "templating" in the proper sense.
17:01:35 <sclv> there are a few other template libraries as well, but they're fairly minimal.
17:01:41 <ehird> sclv: does hvac still have that mass of symbols?
17:01:48 <sclv> hvac is dead.
17:02:04 <ehird> :-(
17:02:05 <ehird> why?!
17:02:13 <dev31212> ok slvc, thanks :)
17:02:14 <sclv> you can get that mass of symbols from urldisp, but it also has a nicer interface.
17:02:22 <sclv> (for some definitions of nicer)
17:02:24 <ehird> what's hvac's replacement
17:03:44 <dons> Interpolation, chunks, HStringTemplate, template seem to be the candidates. hstringtemplate's the  oldest and largest
17:03:48 <sclv> ehird: partly its dead for time reasons, partly its dead because stm was too buggy to do precisely what i wanted (i think it isn't too buggy anymore though..), partly its dead because the model it was promoting for transactionality was too painful for lots of people.
17:04:00 <ehird> aw
17:04:13 <ehird> i have some ideas for web app state myself
17:04:28 <ehird> mainly based on functional transformations of state that get optimized out to mutating a store :-)
17:04:30 <ehird> just like haskell!
17:04:34 <sclv> it could also be implemented as a library over lots of other things, fairly easily.
17:04:54 <sclv> i've got a version of the basic dispatch stuff over happstack that i could release with a little patching up.
17:05:09 <ehird> Saizan: it seems that no matter if i INLINE or NOINLINE it, it works splendidly
17:05:12 <ehird> no segfaults in sight
17:05:53 <sclv> dons: actually hstringtemplate isn't the oldest, but its certainly the largest, and its got a userbase.
17:06:29 <Saizan> ehird: a test can't really give any guarantee, btw, i was more worried about duplicated references rather than segfaults
17:06:49 <ehird> Saizan: true enough -- if you've got some code that might trigger that I'd be happy to test it w/ my lib
17:07:01 <Saizan> ehird: however i can easily make you segfault reliably  (or give random results) if you give me that function :)
17:07:06 <Lemmih> ehird: How are you testing it?
17:07:21 <ehird> Lemmih: it was a very boring IORef read/write test; I was going to do more evil stuff after
17:07:32 <ehird> Saizan: The full function, in another module from the tester, is:
17:07:34 <ehird> {-# INLINE globalIORef #-}
17:07:34 <ehird> globalIORef :: a -> IORef a
17:07:36 <ehird> globalIORef v = unsafePerformIO (newIORef v)
17:07:42 <dons> sclv: does happs use it?
17:08:39 <sclv> dons: yeah. happs has hsp and hstringtemplate support by default. i've been meaning to help them out and improve their interface (there's some cute toys they're not using that could make it a bit neater) but too busy :-(
17:09:03 <sclv> interpolation looks cool though -- quasiquoting! i bet i could knock out a quasiquote library for hstringtemplate too.
17:09:13 <araujo> http://www.haskell.org/~luisfaraujo/haskell_browser_rev.png
17:09:33 <Lemmih> ehird: Ok, that should be reasonable safe.
17:09:34 <Saizan> ehird: foo :: Read a => IORef a; foo = globalIORef (read "1") -- i leave the rest to your imagination
17:09:49 <ehird> Saizan:
17:09:51 <ehird> [[    This is /only/ safe in a top-level definition, on its own.
17:09:51 <ehird>     Please do not try any fancy stuff.]]
17:09:58 <ehird> Yeah, that's probably cheating :P
17:10:02 <ehird> I'll give your thang a try though
17:10:10 <Saizan> it is a toplevel definition on its own :)
17:10:30 <ehird> But you're pretty much meant to have a top-level definition with just a globalIORef of a constant that's of the type (IORef TotallyConcreteType)
17:10:47 <dev31212> thanks for the info guys
17:11:15 <Saizan> yeah, except there's no way to enforce that
17:11:30 <ehird> Saizan: and modules can use System.IO.Unsafe at will too
17:11:37 <ehird> point is, if you use it only in that manner, it should be totally safe
17:11:41 <ehird> and any usage of it will be
17:12:46 <ehird> Saizan: also, yours doesn't segfault; it just splits into multiple IORefs when you give it a different type
17:12:52 <ehird> but again, it's against the rules ;-)
17:12:59 <Saizan> you might want to look for the thread on AIO on -cafe to see why it's not considered safe, more pragmatically (otherwise i don't see why they'd want AIO)
17:13:13 <amz> :sigh:
17:13:21 <amz> I finally got Leksah to build on Windows, but now it won't start :(
17:13:26 <amz> complains about not being able to find icons
17:13:47 <Saizan> ehird: are you sure it's multiple refs? it might be just one with multiple types
17:13:59 <dev31212> you got leksah to build on windows!!!!
17:14:08 <dev31212> I gave up on haskell on windows
17:14:11 <dev31212> too much a pain
17:14:14 <amz> I just followed this http://haskell.org/haskellwiki/Leksah#Installation_on_Windows_from_scratch
17:14:18 <ehird> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4538
17:14:23 <dev31212> oh
17:14:43 <amz> but now it won't run and I'm completely clueless as to why
17:14:47 <erikc`> yea, i gave up on non-.net development on windows, it's a total mess
17:15:06 <amz> $ leksah
17:15:06 <amz> start gui called
17:15:06 <amz> Can't load icons from C:\Program Files (x86)\Haskell\leksah-0.4.4
17:15:06 <amz> ide: internal IDE error: exception :: IDE.Exception.IDEException
17:15:09 <amz> all it gives me :(
17:15:35 <amz> (and given folder does exist, and contains a "data" folder with the icons)
17:15:41 <dev31212> maybe you need to manually copy the icon directory?
17:15:48 <dev31212> oh
17:16:10 <amz> I tried copying contents of "data" to that folder (the parent), no good
17:17:05 <ehird> Saizan: looks like a split to me
17:21:33 <amz> oooh
17:21:34 <amz> it ran :D
17:26:15 <dons> i wonder what bamboo/kibro/hack are using.
17:26:26 <dons> sclv: have you seen all the code going into hack/bamboo?
17:31:33 <adamvo> is it just me, or is the haskellwiki very slow now?
17:42:14 <hohoho> hi
17:43:53 <hohoho> anyone there?
17:44:08 <skorpan> @users
17:44:08 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 15 (2.6%)
17:44:47 <hohoho> anyone know about HappStack?
17:58:07 <romildo> Hi.
17:58:35 <Berengal> Hello
17:58:51 <dabbler> > foo
17:58:52 <lambdabot>   Not in scope: `foo'
17:59:23 <romildo> I have used ghc on Linux and I have been using the OS package manager to install the libraries I need.
17:59:38 <romildo> Now I want to compile my application on Windows.
17:59:52 <romildo> I have already installed ghc and gtk2hs.
18:00:11 <romildo> Now i need regex-pcre. How should I install it on Windows?
18:00:47 <Cale> romildo: Do you have cabal-install?
18:01:17 <romildo> I do not know yet. I have just installed ghc and gtk2hs. Is it a separate package, or does it come with ghc?
18:01:22 <Berengal> http://www.haskell.org/cabal/download.html
18:01:55 <Cale> It's separate, but worthwhile to install, because it makes getting dependencies like that easy.
18:02:16 <Cale> Once you have it, you can just  cabal install regex-pcre
18:02:26 <Cale> and it should download and build it
18:14:27 <romildo> regex-pcre needs libpcre. Is there a recommended way of installing its latest version in Windows?
18:14:46 <Cale> romildo: Oh, right, good question. I don't know since I don't use windows.
18:25:15 <brian6> with time(1), getCPUTime, getSystemTime, etc, can user/system time exceed real?
18:25:22 <romildo> What is the name of the package that provides the module System.IO.Utf8
18:26:34 <brian6> romildo: maybe utf8-string. but it's System.IO.UTF8.
18:26:45 <romildo> yes, just figured it out. thanks.
18:28:12 <kadaver> haskell makes lisp look like a complete hack
18:28:33 <romildo> Ok. I have managed to install cabal, libpcre (with the help of MinGW), and then regex-pcre and utf8-string on my Windows system. Ten I could compile my application successfully. Thanks for the tips.
18:32:08 <true\false> LYAH and RWH.. Good intro to usable Haskell?
18:32:25 <brian6> they're both really good.
18:32:37 <true\false> LYAH really is yes
18:33:18 <true\false> But I'm wondering if going through both will get me up to a level to be able to use Haskell effectively in my coursework
18:33:54 <kadaver> true/false: haskell takes time to learn
18:34:34 <Cale> true\false: If you take in their content, there's more than enough there for that.
18:35:03 <true\false> kadaver: I noticed when I picked up the very basics..
18:36:07 <randomity> brian6: it's a bit offtopic for here, but user/system time can exceed real, usually due to timer granularity being different on the user/sys and real clocks
18:36:36 <brian6> randomity: ok. smp, too.
18:36:51 <true\false> The end goal really is to combine C/C++ with Haskell for my final year project..
18:36:59 <true\false> Of course, I do also need to learn those other two.
18:39:21 <kadaver> final year of what? uni? wht year are you now?
18:39:38 <true\false> Uni, 1st year, of a 3 year course
18:40:35 <true\false> Though it is CS, it is of course more of SE than that.
18:40:39 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4541#a4541 <- anyone have some sort oc fancy Applicative or Arrow hack for that?
18:40:40 <kadaver> true\false: ok and why did you just deicde that you want to use these langs for a project so far away?
18:40:53 <true\false> kadaver: Academic curiosity.
18:41:22 <kadaver> ok
18:41:42 <kadaver> well what do you know? Java? Python?
18:41:48 <true\false> Primarily C#
18:42:20 <edwardk> ok, simplified the parsimony stuff, but now i need to get the actual bottom up parser working again
18:42:41 <adamvo> > Data.Maybe.listToMaybe . last . init $ [1..10] -- this ain't that fancy kadaver
18:42:42 <lambdabot>       No instance for (Enum [a])
18:42:42 <lambdabot>        arising from the arithmetic sequence ...
18:42:50 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/ has the API
18:42:54 <edwardk> very much like parsec
18:43:09 <adamvo> > Data.Maybe.listToMaybe . take 1 . reverse $ [1..10]
18:43:10 <lambdabot>   Just 10
18:43:19 <adamvo> > Data.Maybe.listToMaybe . drop 1 . reverse $ [1..10]
18:43:20 <lambdabot>   Just 9
18:43:26 <adamvo> heh
18:43:52 <true\false> Done a bit of PHP etc.. But I'd not say I know anything else but C#.
18:44:48 <dabbler> > Just 10
18:44:50 <lambdabot>   Just 10
18:45:27 <adamvo> > "C#" > "PHP"
18:45:28 <lambdabot>   False
18:47:11 <true\false> adamvo: Bah
18:47:12 <dabbler> > "lambdabot" > "itself"
18:47:13 <lambdabot>   True
18:47:20 <adamvo> @check \x y -> x > y && x > 0 && y > 0 ==> replicate x () > replicate y ()
18:47:21 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:47:21 <lambdabot>           ...
18:47:39 <adamvo> @check \x y -> x > (y && x > 0 && y > 0) || replicate x () > replicate y ()
18:47:40 <lambdabot>   Couldn't match expected type `Int' against inferred type `Bool'
18:47:53 <adamvo> @check \x y -> (x > y && x > 0 && y > 0) || replicate x () > replicate y ()
18:47:54 <lambdabot>   "Falsifiable, after 0 tests:\n2\n3\n"
18:49:12 <adamvo> I am quite confused about the Ord instance for [a]
18:49:27 <adamvo> @check \x y -> (x > y && x > 0 && y > 0) || replicate x () < replicate y ()
18:49:28 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-1\n"
18:49:40 <adamvo> @check \x y -> not (x > y && x > 0 && y > 0) || replicate x () > replicate y ()
18:49:41 <lambdabot>   "OK, passed 500 tests."
18:50:10 <adamvo> ah, I only messed up the test
18:50:50 <edwardk> :1
18:50:56 <edwardk> woops
18:51:10 <Gracenotes> I reckon quick check should have a nice "check parameters" function
18:51:21 <Gracenotes> or at least have some wrapping of it :l
18:51:30 <Gracenotes> instead of having to make an Arbitrary instance or the like
18:52:01 <adamvo> Gracenotes: how do you mean "check parameters"?
18:52:35 <adamvo> ?type ==>
18:52:36 <lambdabot> parse error on input `==>'
18:52:41 <adamvo> ?type (==>)
18:52:42 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
18:52:57 <Gracenotes> one that makes sure parameters are "correct" and not some degenerate case (negative, zero, empty)
18:53:40 <Gracenotes> hm... ._.
18:54:29 <adamvo> quickCheck is quite annoying with its short lists by default sometimes
18:55:04 <adamvo> @check \x y -> not (x > y && x > 0 && y > 0) || replicate x 'z' > replicate y 'a'
18:55:05 <lambdabot>   "OK, passed 500 tests."
18:57:11 <adamvo> @check \x y -> let fromW z = fromIntegral (z `asTypeOf` (undefined :: Word32)); in not (x > y) || replicate (fromW x)  'z' > replicate (fromW y) 'a'
18:57:11 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
18:57:11 <lambdabot>          ...
18:57:25 <adamvo> @check \x y -> let fromW z = fromIntegral (z `asTypeOf` (undefined :: Int)); in not (x > y) || replicate (fromW x)  'z' > replicate (fromW y) 'a'
18:57:26 <lambdabot>   "Falsifiable, after 8 tests:\n0\n-1\n"
18:57:51 <adamvo> need moar quickcheck instances
19:05:27 <adamvo> Gracenotes: I think that the closest you can get to what you described means writing an instance with such properties for a newtype
19:05:44 <Gracenotes> yes, with Arbitrary
19:07:31 <Gracenotes> although.. maybe you could make a checkWithConstraints :: Testable a => a -> a -> IO ()
19:07:52 <Gracenotes> after all, you would feed both the same number of arguments
19:14:38 <adamvo> Gracenotes: I don't see how checkWithConstraints :: Testable a => a -> a -> IO () would work. Could you clarify?
19:15:44 <Gracenotes> I'm not quite sure either, not knowing the internals of quickcheck and how it handles multi-arg functions.
19:16:17 <Gracenotes> but for single-arg: cwc f g = quickCheck (\x -> not (f x) || g x)
19:16:31 <Gracenotes> or two-arg, cwc f g = quickCheck (\x -y > not (f x y) || g x y)
19:19:26 <Gracenotes> for instance, cwc ((&&) `on` (/= 0)) (\x y -> x / y == recip (y / x))
19:20:22 <adamvo> ok, I see what you mean, but it doesn't prevent you from running out of the fixed amount of randomness reserved for each test
19:20:49 <Gracenotes> yeah. a real implementation would be more.. internal
19:21:06 <adamvo> @check (100>) . length . (`asTypeOf` [()])
19:21:07 <lambdabot>   "Falsifiable, after 242 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
19:21:17 <adamvo> @check (1000>) . length . (`asTypeOf` [()])
19:21:18 <lambdabot>   "OK, passed 500 tests."
19:22:16 <adamvo> @check \x -> not ((1000>) . length . (`asTypeOf` [()]) $ x) || length x > 500
19:22:17 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n"
19:22:37 <adamvo> @check \x -> not ((1000>) . length . (`asTypeOf` [()]) $ x)
19:22:38 <lambdabot>   "Falsifiable, after 0 tests:\n[(),()]\n"
19:22:55 <kadaver> is reactive=event-based?
19:25:17 <adamvo> Gracenotes: I suspect that predicting the behavior of the predicate may be running into restrictions of being undecidable or too slow (if it only applies random guesses that pass)
19:26:13 <Gracenotes> yes. well. quickCheck itself is undecidable in concept, so it has hard limits on the number of tests :)
19:36:21 <kadaver> how do i make lambdabot remember a quote?
19:36:24 <kadaver> @quote kadaver
19:36:25 <lambdabot> No quotes match. :(
19:37:22 <ivanm> @help remember
19:37:23 <lambdabot> quote <nick>
19:37:23 <lambdabot> remember <nick> <quote>
19:37:23 <lambdabot> Quote somebody, a random person, or save a memorable quote
19:37:34 <ivanm> kadaver: ^^ though you shouldn't be remembering your own quote...
19:40:11 <kadaver> @remember
19:40:11 <lambdabot> Incorrect arguments to quote
19:40:28 <kadaver> @remember OO is to programming what astrology is to astronomy
19:40:29 <lambdabot> It is stored.
19:40:36 <kadaver> @quote OO
19:40:36 <lambdabot> OO says: is to programming what astrology is to astronomy
19:40:48 <kerlo> @help forget
19:40:48 <lambdabot> forget nick quote.  Delete a quote
19:40:49 <kadaver> @remember kadaver OO is to programming what astrology is to astronomy
19:40:50 <lambdabot> I will remember.
19:40:53 <kadaver> @quote OO
19:40:53 <lambdabot> OO says: is to programming what astrology is to astronomy
19:40:56 <kadaver> @quote kadaver
19:40:56 <lambdabot> kadaver says: OO is to programming what astrology is to astronomy
19:41:10 <kadaver> can you quote a subjec tinstead?
19:41:10 <kerlo> @forget OO is to programming what astrology is to astronomy
19:41:10 <lambdabot> Done.
19:41:32 <adamvo> somebody forgot to @flush
19:41:33 <BMeph> @quote astrology
19:41:33 <lambdabot> kadaver says: OO is to programming what astrology is to astronomy
19:41:39 <kbateman> @help
19:41:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:41:57 <dabbler> @list
19:41:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:42:25 <ivanm> kadaver: you shouldn't be @remember'ing yourself...
19:42:32 <kadaver> lol
19:42:53 <kadaver> @forget kadaver OO is to programming what astrology is to astronomy
19:42:53 <lambdabot> Done.
19:43:02 <kadaver> can you quote a subjec tinstead?
19:43:09 <kadaver> @quote kadaver
19:43:09 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
19:43:29 <adamvo> @quote remember
19:43:29 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
19:43:48 <dabbler> @quote lambdabot
19:43:49 <lambdabot> lambdabot says: I know nothing about wadler.
19:43:54 <adamvo> @quote quote
19:43:54 <lambdabot> psykotic says: monochrom, I'm reminded me of that Alan Kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
19:44:17 <adamvo> @quote quote
19:44:17 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
19:44:37 <dabbler> @quote adamvo
19:44:37 <lambdabot> No quotes match. I've seen penguins that can type better than that.
19:44:48 <Gracenotes> @quote ;_;
19:44:48 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
19:45:01 <kbateman> @yow
19:45:02 <lambdabot> Let me do my TRIBUTE to FISHNET STOCKINGS ...
19:45:03 <dabbler> @quote rails
19:45:03 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
19:45:17 <dabbler> @quote ubuntu
19:45:17 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
19:45:22 <kbateman> @yow
19:45:23 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474, San Francisco, CA
19:45:23 <lambdabot> 94140, USA
19:45:43 <adamvo> @arr
19:45:43 <lambdabot> Aye Aye Cap'n
19:45:55 <dabbler> @quote ocaml
19:45:55 <lambdabot> erg0t says: ayer soÃ±e k el lambdabot tenia interprete de OCaml
19:46:24 <dabbler> @quote ocaml
19:46:24 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
19:46:35 <kerlo> Is there a function that calculates a z-score from a probability and vice versa?
19:46:45 <dabbler> @quote z-score
19:46:45 <lambdabot> No quotes match. Do you think like you type?
19:46:48 <adamvo> @karma
19:46:48 <lambdabot> You have a karma of 1
19:46:50 <ivanm> kerlo: depends... what's a z-score?
19:46:56 <adamvo> :(
19:47:07 <kerlo> ivanm: it's a value from the standard normal distribution.
19:47:09 <dabbler> @search z-score
19:47:09 <lambdabot> Unknown command, try @list
19:47:25 <ivanm> @go z-score
19:47:25 <kerlo> Or (value - mean) / standard deviation.
19:47:26 <lambdabot> http://en.wikipedia.org/wiki/Standard_score
19:47:26 <lambdabot> Title: Standard score - Wikipedia, the free encyclopedia
19:48:27 <ivanm> kerlo: so you calculate the mean + sd, then apply map (\ s -> (s - mean) / sd) ?
19:48:49 <kerlo> ivanm: I guess so.
19:48:52 <ivanm> heh, didn't see your reply
19:48:55 <adamvo> @quote spongebob
19:48:55 <lambdabot> No quotes match. Do you think like you type?
19:48:56 <ivanm> *shrug*
19:49:07 <kbateman> @yow
19:49:08 <lambdabot> I love ROCK 'N ROLL!  I memorized the all WORDS to "WIPE-OUT" in
19:49:08 <lambdabot> 1965!!
19:49:09 <ivanm> I can give you my code for calculating mean + std dev if you want
19:49:18 <ivanm> @. elite yow
19:49:18 <lambdabot> OH My g0D -- +HE SUn Just f3Ll InTO yanxEe s+4dIuM!!
19:49:22 <kerlo> I'm looking for the standard normal distribution, though, not means and standard deviations.
19:49:47 <ivanm> kerlo: you mean a gaussian distribution?
19:50:00 <kerlo> Yeah, same thing.
19:50:06 <Adamant> @. elite arr
19:50:06 <lambdabot> 5HiV3R m3 7iMBeRs!
19:50:11 <ivanm> Z looks like the partition function in stat mech... >_>
19:50:17 <dabbler> @go gaussian
19:50:18 <lambdabot> http://www.gaussian.com/
19:50:18 <lambdabot> Title: Gaussian.Com
19:50:22 <kerlo> Though I've never seen the term "standard Gaussian distribution".
19:50:24 <ivanm> kerlo: as in you just want the equation for a gaussian?
19:50:59 <kerlo> Well, there isn't an equation for the function I'm after, though the equation for a Gaussian is its derivative.
19:50:59 <Pseudonym> Does "standard" here mean the same thing as in "standard temperature and pressure"?
19:51:01 <ivanm> http://en.wikipedia.org/wiki/Standard_normal_distribution
19:51:08 <Pseudonym> i.e. mean = 0, variance = 1
19:51:18 <kerlo> Pseudonym: it does mean mean = 0, variance = 1.
19:51:19 <ivanm> Pseudonym: according to wiki, yes
19:51:22 <Pseudonym> Right.
19:51:28 <Pseudonym> Makes sense./
19:51:37 <ivanm> p(x) = 1/sqrt(2 pi) * exp(-x^2/2)
19:51:46 <ivanm> ^^ that's the standard normal distribution
19:51:53 <kerlo> The strange thing is I seem to be incapable of making any Internet connections at the moment.
19:52:02 <Pseudonym> kerlo: Tunnel them through IRC.
19:52:08 <ivanm> Pseudonym: heh
19:52:18 <ivanm> I've tried fixing X by tunneling commands through IRC
19:52:21 <ivanm> it failed :(
19:58:30 <ivanm> what's wrong with this? type ChurchNumeral = (a -> a) -> a -> a
19:58:41 <ivanm> ghci keeps complaining about the type variable a not being in scope :s
19:59:52 <ivanm> duh, I need "type Church a = " :s
20:00:40 <pizzapappy> hey is bonus/miran here
20:00:49 <ivanm> @seen BONUS
20:00:49 <lambdabot> BONUS is in #haskell. I don't know when BONUS last spoke.
20:00:56 <ivanm> @seen miran
20:00:56 <lambdabot> I haven't seen miran.
20:01:03 <pizzapappy> well well
20:23:57 * edwardk is getting somewhat sick of typing 'unsafeCoerce' all day ;)
20:23:58 <kbateman> echo!
20:24:21 <zakwilson> I'm considering making a simple non-production-quality app for Mac using gtk2hs. Has anyone done this? Is the Mac-native GTK done enough at this point?
20:25:44 <kbateman> I don't think there are very many actual people watching this channel right now.
20:26:00 * dancor_ is real
20:26:27 <kbateman> dancor_ just claims he is real.  He could still be a bot. :)
20:26:27 <edwardk> i'm half here trying to figure out a parser in another window
20:26:45 <kbateman> I'm trying to get my euler 156 program to run at a decent speed.
20:26:47 <dancor_> @vixen vixen just claims she is real.  She could still be a bot. :)
20:26:47 <lambdabot> i can't stand bots
20:27:04 * zakwilson is unreal.
20:27:58 <kbateman> @yow
20:27:58 <lambdabot> I'm shaving!!  I'M SHAVING!!
20:31:54 <kerlo> Pseudonym: hey, funny thing. Right after you suggested that I tunnel them through IRC, my connection to IRC dropped.
20:32:21 <kerlo> ivanm: alternatively, try type ChurchNumeral = forall a. (a -> a) -> a -> a
20:32:51 <kerlo> But now, under Linux, I guess everything is okay.
20:39:15 * BMeph prefers to be called "Complex," rather than not real...
20:40:25 <edwardk> BMeph: bah, we both know you're imaginary
20:43:27 <ivanm> @vixen does BMeph really exist?
20:43:27 <lambdabot> really!
20:45:54 <QtPlaty[HireMe]> Is there a general functional language/language design channal?
20:46:43 <ivanm> QtPlaty[HireMe]: there's a general FP newsgroup IIRC...
20:46:50 <ivanm> but I don't know about IRC channels
20:47:04 * QtPlaty[HireMe] nods "I'm a subscriber to the FP newsgroup"
20:47:40 <kadaver> ow talking in #fp
20:47:40 <kadaver> * zelazny.freenode.net sets mode: +ns
20:47:40 <kadaver> * ChanServ changes topic to 'i still believe in paradise...
20:48:12 <ivanm> kadaver: "/topic #fp" says that that channel doesn't exist...
20:48:42 <kadaver> is there a forum or something where you can post code for review?
20:49:25 <Tsion> Since Haskell treats - as unary, is there a better way to do (-3) as a function than (flip (-) 3) ?
20:49:58 <ivanm> Tsion: subtract
20:50:07 <ivanm> > map (subtract 3) [1..10]
20:50:08 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
20:50:09 <Tsion> oh
20:50:10 <Tsion> thanks
20:50:11 <dibblego> @pl \x -> x - 3
20:50:11 <lambdabot> subtract 3
20:50:13 <ivanm> no worries
20:50:28 <BMeph> edwardk: ;p
20:50:55 <hohoho> i want to make web application on haskell. Is there any good framework for it ?
20:51:13 <ivanm> hohoho: I don't know about "good", but there's a few of them
20:51:18 <ivanm> happstack, etc.
20:51:39 <hohoho> turbinado and happstack i know. i interested in happstack
20:54:33 <hohoho> happstack is active project now?
20:55:36 <ivanm> hohoho: yes
20:55:43 <ivanm> happstack is a revival of happs
20:55:58 <ivanm> so happstack has been an active project for as long as it has existed ;-)
21:08:58 <hohoho> thanks
21:13:52 <Apocalisp> @type (t::Tree (Tree String)) >>= id
21:13:53 <lambdabot>     Ambiguous occurrence `t'
21:13:53 <lambdabot>     It could refer to either `L.t', defined at <local>:10:0
21:13:53 <lambdabot>                           or `SimpleReflect.t', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
21:14:13 <Apocalisp> @type tre >>= id
21:14:14 <lambdabot> forall b. (Num (Tree b), Ord (Tree b)) => Tree b
21:14:59 <Apocalisp> Where's instance Monad Tree declared in the libraries?
21:18:46 <ivanm> Apocalisp: for Data.Tree?
21:18:49 <Apocalisp> yes
21:19:05 <adamvo> Apocalisp: containers-0.2.0.1 has it with Data.Tree
21:19:06 <ivanm> in Data.Tree ;-)
21:19:19 <ivanm> @src return Tree
21:19:19 <lambdabot> Source not found. Just try something else.
21:19:23 <ivanm> @src Tree return
21:19:23 <lambdabot> Source not found. You speak an infinite deal of nothing
21:19:31 <ivanm> Apocalisp: return x = Node x []
21:19:51 <ivanm> Node x ts >>= f = Node x' (ts' ++ map (>>= f) ts) where Node x' ts' = f x
21:20:10 <Apocalisp> ah, 2.0.1
21:20:26 <Apocalisp> I see it now, thanks. It's not in 2.0.0
21:20:36 <ivanm> Apocalisp: it isn't? weird :s
21:20:49 <Apocalisp> Oh hell, yes it is.
21:20:59 <Apocalisp> Must have been looking at something even older.
21:21:42 <Apocalisp> thanks! :)
21:21:56 <ivanm> silly Apocalisp...
21:37:31 <ivanm> _roconnor: you do realise that this isn't Python, and that prefixing your nick with a "_" won't hide you? :p
21:37:49 <dancor_> only friends
21:37:50 <dev31212> lol
21:38:27 <ivanm> heh
21:38:35 <roconnor> > inits []
21:38:36 <lambdabot>   [[]]
21:38:45 <roconnor> > inits [1,2,3]
21:38:47 <lambdabot>   [[],[1],[1,2],[1,2,3]]
21:38:58 <roconnor> > init [1,2,3]
21:38:59 <lambdabot>   [1,2]
21:40:42 <dolio> Woo, quickcheck found me a bug.
21:41:41 <ivanm> dolio: so are you happy that there's a bug, or that it was found?
21:41:50 <dolio> That it was found.
21:42:30 <dolio> It was a bit tricky, though.
21:42:36 <kadaver> i thought REAL haskell programmers proved their programs, not test them
21:43:05 <roconnor> dolio is a wannabe haskell programmer
21:43:10 <dolio> Clearly.
21:43:47 <ivanm> kadaver: no, real haskell programmers write their code in such a way that the calculations are done in the type system...
21:45:54 <Cale> ivanm: Actually, that's a bit risky, since our type system doesn't have a type system.
21:45:58 <Cale> (apart from kinds)
21:46:05 <ivanm> aren't they good enough?
21:46:12 <Cale> The kind system is really weak
21:46:14 <ivanm> or don't kinds provide statically-typed static types? ;-)
21:46:16 <ivanm> oh :(
21:46:28 * ivanm at least feels better for not hacking in the type system now
21:46:50 <Cale> You can't create new kinds, and all normal types are of kind *
21:46:51 <roconnor> Data families seem pretty powerful
21:46:59 <Cale> Type constructors are of kind * -> *
21:47:09 <Cale> (simple type constructors)
21:47:27 <Cale> There are a few kinds for unboxed types
21:47:34 <ivanm> so it's as if the only type you have is () and have to program everything that way?
21:47:37 <bd_> strictly speaking, isn't a 0-ary type constructor of kind * ?
21:47:39 <Cale> But you can't do something like define a kind for type-level naturals.
21:47:53 <Cale> bd_: Yes, that's what I mean by 'normal type'
21:48:40 <Cale> Well, that, and things which are built up in more complicated ways
21:48:56 <Cale> Like [Integer] isn't just a 0-ary type constructor, but it's of kind *
21:49:26 <Cale> Or  Double -> String
21:49:35 <bd_> Sure, I didn't say anything about the converse :)
21:50:26 <Cale> Right, I'm just trying to make it clear :)
21:56:09 * ManateeLazyCat pasted "my code" at http://paste2.org/get/197436
21:56:10 <ManateeLazyCat> How to make above code more simpler? Thanks!
21:58:43 <roconnor> @check if x then true else false == x
21:58:43 <Cale> ManateeLazyCat: The if is unnecessary
21:58:44 <lambdabot>   Not in scope: `true'Not in scope: `false'
21:58:50 <roconnor> @check if x then True else False == x
21:58:51 <lambdabot>   Couldn't match expected type `Bool' against inferred type `Expr'
21:58:57 <roconnor> @check \x -> if x then True else False == x
21:58:58 <lambdabot>   "OK, passed 500 tests."
21:59:03 <Cale> ManateeLazyCat: return (<the boolean expression>)
21:59:52 <ManateeLazyCat> Cale: yep,
22:00:32 <ManateeLazyCat> Cale: But i want make boolean expression (in parentheses) more simpler
22:00:43 <roconnor> windowIsSameDirection dir1 dir2 = return (f dir1 == f dir2)  where f x = x `elem` [DTop,DBottom]
22:00:48 <Cale> ManateeLazyCat: You could make a function to capture the repeated part
22:01:07 <roconnor> (assuming DTop,DBottom,DLeft,DRight are all the constructors)
22:02:12 <roconnor> Actually I'd personally be inclined to write a 4 line definition of f covering all the constructors
22:02:21 <kadaver> ivanm: is that possible to some small extent(calculations are done in the type system.)?
22:02:31 <roconnor> f DTop = True; f DBottom = True; f DLeft = False; etc.
22:03:17 <roconnor> that way if a new constructor is added, things don't break in unexpected ways
22:03:27 <kadaver> mante skip the ifs
22:03:42 <ManateeLazyCat> kadaver: Yep, i have skip it.
22:05:22 <alexsuraci> can anyone think of anything that would cause Parsec to expect a digit after a line of empty indentation? (vague, but after several hours of debugging I can't figure this out)
22:05:59 <Cale> alexsuraci: That *really* depends on your parser
22:06:18 <Cale> alexsuraci: Do you have a parser which expects a digit?
22:06:20 <alexsuraci> yeah, I realize that, but it's explicitly saying "digit", not a list of every expression in the parser like usual
22:06:43 <ManateeLazyCat> roconnor: Your first version is i want. Thanks!
22:06:44 <Cale> alexsuraci: You might try adding <?> annotations to name some bits of the parser...
22:06:53 <roconnor> ;-(
22:06:55 <alexsuraci> Cale: I have.
22:07:04 <roconnor> please consider my second version. :)
22:07:37 <alexsuraci> doubt I'll get much help here, since it's obviously such a varying thing, but thanks
22:10:18 <kbateman> It probably shouldn't be in the IO monad either.
22:11:07 <Cale> kbateman: Good point, it really shouldn't :)
22:11:29 <alexsuraci> HAH
22:11:30 <alexsuraci> got it
22:11:58 <ManateeLazyCat> roconnor: First version is more simpler.
22:12:04 <alexsuraci> still don't know why it was expecting a digit, but I changed "skipMany (whiteSpace' >> newline)" to "skipMany (try $ whiteSpace' >> newline)" and now it works.
22:12:27 <ManateeLazyCat> roconnor: I just have four constructors.
22:12:36 <ManateeLazyCat> brb, coming soon
22:13:42 <roconnor> ManateeLazyCat: okay.  I guess you will probably be safe.
22:13:49 <roconnor> as long as no one adds diagonals
22:16:22 <Zao> Oh dear... I misread the channel badly last night.
22:16:43 <Zao> I was wondering what the heck the "third futurama projection" was.
22:17:12 <kbateman> I read it that exact same way on reddit
22:18:14 <Cale> Zao: huh?
22:18:42 <kbateman> http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
22:18:59 <Cale> ManateeLazyCat: By the way, 'simpler' already implies 'more simple', you don't need to say 'more' before it.
22:19:14 <kbateman> Yes, that way is more better.
22:19:22 <Cale> grr, hehe :)
22:20:10 <ManateeLazyCat> Cale: Heh
22:20:26 <ManateeLazyCat> Cale: Suck English. :)
22:20:38 <ManateeLazyCat> Thanks, all.
22:20:39 <ManateeLazyCat> brb
22:20:51 * kbateman will refrain
22:23:15 <kbateman> Has anybody done Euler problem 156?
22:24:44 <ivanm> kbateman: from which song? :p
22:25:14 * kbateman refrained from making a joke about "Suck English"
22:25:47 <ivanm> yes, I realised that was your point
22:26:30 * kbateman is disappointed that he explained a joke that was actually understood.
22:26:37 <dancor_> so maybe "complicated"
22:50:04 <kadaver> i cant compile gtk with 6.10.1 either
22:50:13 <kadaver> what should i pass to ghc?
22:50:19 <haskellnoob> Is there a mutable list implementation available in Haskell? I want to be able to traverse a list, and delete and/or insert elements based on the value of the current element being scanned.
22:50:29 <kadaver> it needs some info on where gtk2hs is right?
22:51:28 <kadaver> ghc --make -O2 Main.hs
22:51:30 <kadaver> is not enough
22:51:36 <kadaver> how do you people compile your gtk apps?
22:51:53 <zsol> with cabal usually
22:51:56 <ManateeLazyCat> kadaver: ghc --make *.hs
22:52:28 <dibblego> haskellnoob, use filter -- you don't want to mutate a list
22:53:02 <kadaver> you compile with cabal?
22:53:29 <zsol> yeah I usually do a cabal build on my gtk project and it compiles
22:53:43 <kadaver> ok i see
22:53:51 <kadaver> ManateeLazyCat: that doesnt work it is the same
22:54:06 <kadaver> in ghci ti fails to import import Graphics.UI.Gtk
22:54:22 <zsol> are you trying to compile gtk2hs itself?
22:54:22 <kadaver> > filter (> 10) [1..20]
22:54:23 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
22:54:41 <ManateeLazyCat> kadaver: You need compile gtk2hs after GHC
22:55:03 <ManateeLazyCat> kadaver: Then GHC will find where the Graphic.UI.Gtk
22:55:22 <ManateeLazyCat> kadaver: http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.10.0.tar.gz)
22:55:44 <ManateeLazyCat> kadaver: I use GHC-6.10.2 with gtk2hs-0.10.0
22:56:10 <Axman6> haskellnoob: you don't need a mutable list to be able to do that
22:56:37 <ManateeLazyCat> kadaver: And you perhaps need install depend libraries before you compile gtk2hs.
22:56:55 * haskellnoob is trying hard to figure out how to do what he wants without mutating a list...
22:57:03 <ManateeLazyCat> kadaver: My depend libraries for Debian system: "sudo aptitude install automake libglade2-dev libgtksourceview-dev libgtksourceview2.0-dev libgconf2-dev librsvg2-dev libgstreamer-plugins-base0.10-dev libgstreamer0.10-dev libgtkglext1-dev libgnomevfs2-dev xulrunner-dev -y"
22:57:06 <kadaver> > filter (> 10) [1..20]
22:57:08 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
22:57:09 <kadaver> ^^ haskellnoob
22:57:20 <kadaver> show what you want then it is easier for us to tell
22:57:28 <kadaver> i had gtk working before
22:57:33 <ivanm> haskellnoob: or else a tree or some other structure might be a better fit
22:57:37 <kadaver> but i had to do soemhting when i compiled
22:57:47 <dancor_> is there an opensource opening-explorer (i.e. indexes game tree given a bunch of pgns).  i don't really want to write one
22:57:51 <dancor_> for chess
22:57:51 <kadaver> now it works
22:57:53 <ivanm> kadaver: does ghc recognise gtk2hs being installed?
22:58:01 <kadaver> i think it was because i installed gtk+ for C
22:58:08 <ivanm> dancor_: no idea what you're talking about tbh
22:58:44 <zsol> kadaver: try this: ghc-pkg latest gtk
22:58:52 <Axman6> > let update p x [] = []; update p x (y:ys) = if p y then x:ys else y : update p x ys in update (==4) 7 [1..10]
22:58:53 <lambdabot>   [1,2,3,7,5,6,7,8,9,10]
22:58:57 <zsol> does this show you gtk-0.10.0 ?
22:59:07 <Axman6> haskellnoob: ^^ how's that? no need to mutate things
22:59:24 <ivanm> and thus you avoid getting mutants!
22:59:25 <ivanm> ;-)
22:59:30 <dancor_> ivanm: reads a bunch of games, then in any position tells you the number times each move was made from that position
22:59:31 <Axman6> hoorah!
22:59:41 <haskellnoob> Axman6: let me figure out what you did there!
23:00:07 <Axman6> haskellnoob: copy and paste the update function, and put a new ling instead of ;
23:00:12 <ManateeLazyCat> Looks IORef is unavoidable when i programming with gtk2hs, since GTK bindings use IO for their callbacks. Guys, you use IORef with gtk2hs? Or other way?
23:00:13 <Axman6> line*
23:00:19 <kadaver> bah it doesnt work with 6.10.2
23:00:27 <kadaver> ManateeLazyCat: I do
23:00:39 <haskellnoob> Axman6: let me play with that for a while and see.
23:00:46 <ManateeLazyCat> kadaver: Use IORef?
23:01:06 <zsol> kadaver: sure does work for me
23:01:23 <ManateeLazyCat> kadaver: Yesterday, i failed to compile when i use my "custom moand" with function `onKeyPress`.
23:01:28 * Axman6 doesn't like IORefs, they make him feel unsafe
23:02:27 <ManateeLazyCat> Axman6: But GTK bindings IO with their callbacks (such as `onKeyPress`). I use some moand state, but failed with `onKeyPress`.
23:03:39 <ManateeLazyCat> Axman6: Except IORef, i don't know how to write code make it works. Even i don't like IORef too.
23:06:08 <kadaver> what package from hackage do you need for gtk2hs? nothing?
23:06:12 <kadaver> onyl gtk2hs itsloef?
23:06:18 <zsol> yes
23:06:50 <ManateeLazyCat> kadaver: I think haddock and regex-tdfa
23:07:13 <ManateeLazyCat> kadaver: You need haddock if you use "--enable-docs" option to compile gtk2hs.
23:07:25 <ivanm> ManateeLazyCat: you don't need regex-tdfa...
23:07:46 <ivanm> at least, I didn't...
23:07:53 <kadaver> do i need to install packages for each version of ghc?
23:07:55 <ManateeLazyCat> ivanm: Oh, yes, I use it in myself code.
23:07:57 <ivanm> kadaver: gtk2hs docs won't build if you have latest mtl and transformers installed
23:07:59 <ivanm> ManateeLazyCat: heh
23:08:08 <ivanm> kadaver: yes
23:08:16 <ivanm> but why do you have multiple ghcs installed? testing?
23:08:24 <dabbler> @quote jobs
23:08:25 <lambdabot> No quotes match. Where did you learn to type?
23:08:46 <kadaver> because gtk2hs doesnt work with 6.10.2
23:09:01 <ManateeLazyCat> kadaver: Why?
23:09:17 <dabbler> @quote ruby
23:09:17 <lambdabot> byorgey says: TDD replaces a type checker in Ruby in the same way that a strong drink replaces sorrows.
23:09:18 <ManateeLazyCat> kadaver: I use gtk2hs-0.10.0 with ghc 6.10.2
23:09:48 <ManateeLazyCat> kadaver: And works fine.
23:10:08 <haskellnoob> I /think/ I can modify Axman6 's example to suit my need, thanks!
23:10:13 <dabbler> @quote meta
23:10:14 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
23:11:22 <dabbler> @quote template
23:11:22 <lambdabot> ghc says: Cannot desugar this Template Haskell declaration
23:11:49 <dabbler> @quote monoid
23:11:50 <lambdabot> ddarius says: In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
23:11:56 <haskellnoob> Now is there a way to traverse a list in the reverse order, last to first, while doing insertions and deletions (in the non-mutating sense)?
23:12:30 <ManateeLazyCat> :t reverse
23:12:31 <lambdabot> forall a. [a] -> [a]
23:12:47 <ManateeLazyCat> haskellnoob: See above
23:13:24 <dabbler> > reverse [1,2,3,4,5]
23:13:26 <lambdabot>   [5,4,3,2,1]
23:13:46 <haskellnoob> ManateeLazyCat: will reversing a huge list and then traversing it be more expensive, time and memory-wise, than traversing the list without reversing it?
23:14:08 <haskellnoob> Will reverse take O(n) time?
23:15:01 <zcvvc> reverse takes O(n). but if you traverse the whole list in both cases, then it'll be O(n) anyway
23:16:01 <haskellnoob> zcvvc: but if the list is huge, then that additive O(n) will make a big difference..
23:16:34 <dancor_> O(n) + O(n) = O(n)
23:16:53 <dancor_> if the list is huge then an + bn = (a + b)n could make a big difference
23:17:01 <haskellnoob> dancor_: 5n + 5n = 10n :)
23:17:05 <zcvvc> I'm not sure about the constant factor implied
23:17:21 * dancor_ just being pedantic about "O(n)"
23:17:38 <dibblego> haskellnoob> Now is there a way to traverse a list in the reverse order, last to first, while doing insertions and deletions (in the non-mutating sense)?
23:17:41 <dibblego> @type foldr
23:17:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:17:48 <Cale> The other thing which reversing a list does is to make it impossible to operate on infinite lists, but often that's unavoidable anyway.
23:18:12 <haskellnoob> ok.. let me try things out, and see if reverse will suffice. Cale: I have only finite lists to worry about, so that is ok.
23:18:12 <Cale> foldr is from first to last, as I see it
23:18:17 <Cale> foldl is the backward one
23:18:27 <Cale> > foldr (:) [] [1..5]
23:18:28 <lambdabot>   [1,2,3,4,5]
23:18:33 <Cale> > foldl (flip (:)) [] [1..5]
23:18:34 <lambdabot>   [5,4,3,2,1]
23:19:01 <dabbler> :t flip
23:19:03 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:19:09 <dibblego> Cale, you will surely agree that 5:[] occurs before 4:5:[] -- I don't necessarily have a point of view, but I know how imperative programmers learn
23:19:09 <Cale> haskellnoob: What computation are you doing?
23:19:25 <Cale> dibblego: do I?
23:19:26 <dancor_> does building profiling support into a library make the library slower?  or is it only slower when i compile some executable (that depends on the library) with profiling support
23:19:44 <haskellnoob> Cale: I am trying to solve a programming puzzle.
23:19:56 <haskellnoob> as part of an ongoing competition.
23:20:02 <Cale> dibblego: in 4:(5:[]), 4 is consed onto something, and then that thing happens to be 5 consed onto []
23:20:15 <Cale> The 4: happens first :)
23:20:41 <dibblego> Cale, agreed -- imperative programmers think in terms of snoc, not cons
23:20:52 <Cale> Well, they use strict evaluation
23:20:57 <zcvvc> snoc = flip cons?
23:21:22 <Cale> snoc is adding things to the end, rather than the beginning of a list
23:21:27 <zcvvc> thanks
23:21:40 <Cale> snoc xs x = xs ++ [x], more or less
23:21:52 <Gracenotes> although snoc has a connotation of being O(1)
23:21:56 <Cale> yeah
23:22:06 <dabbler> > let snoc xs x = xs ++ [x]
23:22:07 <lambdabot>   <no location info>: parse error on input `;'
23:22:10 <Cale> (but lists don't have O(1) snoc)
23:22:30 <Gracenotes> at least, one's that aren't circular doubly-linked
23:22:33 <Gracenotes> *ones
23:22:39 <dibblego> Cale, I'm just guessing that haskellnoob "really wants" foldr -- you can see the difficulty in a detailed answer
23:22:40 <zcvvc> is it possible to make doubly-linked lists with O(1) snoc and merge?
23:22:49 <Cale> dibblego: yeah...
23:22:50 <Gracenotes> for which you need mutation generally
23:23:22 <Cale> doubly linked lists are not very useful as immutable structures
23:23:45 <Cale> All the update operations become O(n)
23:23:56 <dons> zcvvc: O(1) merge? append ?
23:24:06 <dancor_> i recently used a list for a log of things and it was like [thing1, thing2, ..] and then i had to use foldl to reconstruct the log in order.  am i doing everything backwards?
23:24:07 <rieux_> hmm.  finger trees will get you O(1) cons, snoc, head, tail, last, init
23:24:08 <rieux_> but not append
23:24:15 <zcvvc> dons: yes
23:24:20 <dons> what was the complexity of the ops in oleg's IntMap/zipper based dlist?
23:24:31 <Cale> rieux_: Right, but append is logarithmic in the size of the shorter piece
23:24:43 <Cale> (so it's still very fast for that)
23:24:51 <rieux_> i assume that zcvvc's "merge" is append
23:25:05 <zcvvc> I meant ++
23:25:11 <rieux_> yeah
23:26:07 <Cale> zcvvc: If you want something of that sort in Haskell, Data.Sequence is good. It doesn't have constant time append or split, but it can do those in log time, and working at both ends is constant time.
23:26:35 <zcvvc> thanks
23:26:52 <Cale> dons: I suppose it depends on whether you consider the IntMap operations to be constant or logarithmic...
23:27:18 <Cale> But everything at least costs what those do.
23:28:00 <edwardk> dons: basically oleg just pretends an intmap is constant time, which it is, but only because Ints are bounded. which strikes me as a terrible terrible copout
23:28:33 <Cale> But to his credit it is a copout we use all the time
23:28:47 <edwardk> by that token almost any algorithm can be made constant time -- just by limiting the size of the inputs =)
23:28:54 <Cale> Like in considering pointer dereferencing to be constant time.
23:29:06 <osfameron> co-pout? ;)
23:29:11 <Cale> haha
23:29:25 <dabbler> @quote pointer
23:29:25 <lambdabot> musasabi says: reallyUnsafePointerEq# seems unsafe.
23:29:51 <edwardk> bah, i'm passing out unsafeCoerce's in my current project like party favors ;)
23:30:01 <Cale> oy
23:30:14 <dibblego> @check \x -> (unwords . words) x == x -- ?
23:30:15 <lambdabot>   "OK, passed 500 tests."
23:30:20 <Cale> edwardk: What did the type system ever do to you?
23:30:27 <copumpkin> dibblego: that's odd
23:30:37 <Gracenotes> reallyUnsafePointerEq# doesn't seem all that interesting either :o
23:30:37 <copumpkin> dibblego: I guess it never generates enough spaces in a row?
23:30:49 <dibblego> copumpkin, I suppose
23:30:53 <Gracenotes> although, I'd imagine you could use it to make something like vaccuum
23:30:55 <Gracenotes> *vacuum
23:31:08 <Cale> It's not that odd
23:31:14 <Cale> 500 tests is not so many
23:31:25 <edwardk> cale: mostly prevented me from sharing parsers when i represent them as applicatives but know i'm not using the type. i.e. i'm dumping it down to a monoid, so i need the increased sharing to reduce the number of (non)terminals in the resulting grammar
23:31:27 <copumpkin> can you ask @check to try more?
23:31:32 <kadaver> haskellnoob: show what you want to put in and what you want out, then it is easier to say how you would do it
23:32:11 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/src/Text-Parsimony-Prim.html the definition for Mode Recognizing is one of the worst culprits
23:32:13 <Cale> edwardk: hmm
23:32:52 <haskellnoob> kadaver: the description of what i want done is slightly long, so i will paste it and tell the link.
23:33:59 <edwardk> Mode m => Parser m token a -- is a textbook Applicative, but Parser Recognizing token a permits some pretty unsafe optimizations. in particular it never looks the field in the 'Pure' constructor or the 'Satisfy' constructor that is used to generate the 'a' part of the parser. its really a monoid
23:34:23 <Cale> edwardk: It isn't really apparent to me why those unsafeCoerces will be okay...
23:34:26 <edwardk> consequently fmapping over it should just unsafe coerce, applying a pure value can just elide the epsilon in the grammar
23:34:54 <Cale> hmm
23:35:43 <edwardk> cale: each of them has a different justification, but the gist of it is, when you're Recognizing, your Applicative is secretly a Monoid that can never use its parameter
23:35:44 <Cale> Ah, so even though it's not really the same type, it's similar enough as far as GHC's representation is concerned, since you don't care about the type parameter?
23:36:17 <rieux_> edwardk: that's scary.  can you construct a witness to that fact?
23:36:23 <edwardk> cale: in a nutshell
23:36:59 <edwardk> rieux_: the process is actually pretty straightforward. you can do it by inspection on each of those based on the definition for the GADT that is Parser
23:38:27 <edwardk> when you are working in a Parser Recognizing Char a -- Pure Recognizing a == TrivialApplicative, which is a stub that ignores its type argument, so the Pure constructor of the parser gadt can never try to use its type argument.
23:38:29 <rieux_> edwardk: it would be nice if you could convince the type checker.
23:39:04 <edwardk> rieux_: unfortunately thats not really an option. in particular with the case of how i implement the grammar extraction. the insertion and extraction from the data types happens way too far apart
23:39:37 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/src/Text-Parsimony-StableMap.html -- is also a sea of unsafeCoerce
23:40:27 <Cale> edwardk: How much of an actual performance difference does it make in code compiled with optimisations?
23:40:39 <edwardk> cale: well, its asymptotic
23:41:15 <Cale> But it's the sort of thing which you might be able to expect an optimiser to find.
23:41:43 <Cale> Maybe my expectations are too high :)
23:41:50 <haskellnoob> Please see my description at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2320#a2320
23:42:14 <edwardk> not really. it has to figure out that it can magically replace Pure f <*> g -- with g -- using types that won't unify
23:42:37 <Cale> haskellnoob: What does that algorithm compute?
23:43:11 <haskellnoob> Cale: It is a kind of sorting (as I have put it, this algorithm will just sort, but I have simplified the description a bit).
23:43:12 <edwardk> this is actually probably the most dangerous dance i've ever attempted with the type system
23:44:37 <Cale> haskellnoob: That seems like an algorithm which will be *extremely* inefficient on lists, but using Data.Sequence might not be so bad.
23:45:02 <Cale> Er, hmm
23:45:21 <edwardk> oh, cale, you may find it amusing that i'm basically using a strongly typed zipper to walk through that applicative (without all the unsafeCoerces) -- basically changing the types in 'reverse' as i walk down the GADT
23:45:33 <edwardk> i need to put that code up in the repository still
23:45:37 <Cale> I don't have the right sort of brain to understand an algorithm like this anymore :P
23:45:42 <haskellnoob> Cale: OK. Since you mentioned Data.Sequence some time back, I went and looked at the GHC docs, I also saw different kinds of mutable arrays. Will some of them help even more?
23:45:56 <edwardk> @hpaste
23:45:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:46:01 <Cale> haskellnoob: Well, Data.Sequence makes an acceptable queue.
23:46:30 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4555#a4555
23:46:36 <Cale> haskellnoob: but possibly you could use mutable arrays, though deleting elements from them is not really an option
23:47:22 <haskellnoob> Cale: But there is also the "input" list itself, which is horribly mangled by the algorithm... would the default list be ok enough for this?
23:47:35 <edwardk> basically i have a 'Path' to the root of the applicative, so at the root r = a, and we've got a Path of type Path m t r r, as you go down into the left or right of a (<*>) your type changes
23:48:00 <Cale> haskellnoob: Well, you obviously aren't really going to mangle the input list, you're going to successively construct new lists from it,
23:48:02 <rieux_> haskellnoob: in your situation, i would represent L[] as sort of an ad-hoc zipper: a pair of lists, where one represents L[] at indices before the current index in reverse, and the other represents L[] after the current position
23:48:30 <edwardk> because what i need to be able to do is know all of the 'leaves' in the parser, basically i need all of the nodes that use the 'Satisfy' constructor, and the possible paths down to them.
23:48:51 <Cale> but hmm, rieux_ has a point, you only 'modify' the list around a single point where you are operating at any given time
23:48:59 <haskellnoob> true
23:49:14 * haskellnoob is trying to figure out what rieux_ has said
23:49:18 <Cale> So you could use that trick and then reverse at the end
23:49:35 <Cale> (since your resulting output would be in reverse order in the first part)
23:49:46 <Jebdm> haskellnoob: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2322#a2322
23:49:46 <edwardk> and then i feed them all the first character and have them start to 'climb' up the path to the root or extend themselves downward as i add characters to either side
23:49:58 <rieux_> haskellnoob: i can try to make an example, if you like
23:50:28 <Jebdm> I was playing with that a few days ago, so I had a ready-made example for you.
23:51:07 <Jebdm> It may be a bit..bad, though, I was just playing around with Turing machines.
23:51:31 <haskellnoob> rieux_: Thank you. Could you show me a simple example of this trick?
23:51:48 <rieux_> haskellnoob: take a look at jebdm's link.  it looks reasonable to me.
23:52:04 <haskellnoob> rieux_: OK.
23:52:16 <haskellnoob> Jebdm: Thanks.
23:52:37 <rieux_> if the list you're working with is, say, [a,b,c,d], and your current position is at the beginning, then in jebdm's datatype, you'd represent that as: Zipper 0 [] a [b,c,d]
23:53:05 <rieux_> and then you could move to the right, and you'd have Zipper 1 [a] b [c,d].  if you move to the right again, you're at Zipper 2 [b,a] c [d]
23:53:33 <rieux_> i don't think your algorithm needs the position field, though.
23:53:38 <Jebdm> If you have any Theory of Computation background, it's basically what you use if you want do build a Turing machine with a pair of stacks.
23:53:48 <haskellnoob> Thank you. Let me spend some time on this!
23:54:18 <haskellnoob> Jebdm: I do have some TOC background, but I never wanted to build a Turing machine with a pair of stacks. Is something wrong with me? :(
23:54:24 <haskellnoob> ;0
23:54:27 <rieux_> no :)
23:54:40 <Jebdm> Hehe--nah, it's just a fairly common exercise.
23:54:58 <rieux_> yeah. exercise: encode a TM as a pair of PDAs.
23:55:03 <haskellnoob> OK, a pair of stacks instead of the tape, i guess?
23:55:20 <rieux_> or, rather, a PDA with two stacks
23:55:24 <edwardk> rieux_: a pair of PDAs? or a two-stack pushdown automaton?
23:55:24 <edwardk> hah
23:55:26 <edwardk> ok =)
23:55:42 <Jebdm> Exactly.  You use the top of one of the stacks to represent where the head is pointed, and pop from one to the other to simulate moving left and right.
23:56:35 <Jebdm> I just separated the "head" from the stacks by putting it in it's own "current" field.
23:56:53 <Jebdm> And added a position, which I wanted for what I was doing.
23:57:06 <dabbler> hey do you guys use haskell at your job?
23:57:07 <haskellnoob> Jebdm: Now that you said it, I have done this before, and the analogy has made the rieux_ 's idea clearer to me (I think!). Let me have a go at this, at the least it will expand my head! Thanks to all.
23:57:14 <rieux_> dabbler: yes
23:57:27 <Jebdm> No problem, good luck.
23:57:53 <dabbler> rieux_: cool, mind if i ask what sort of company you work for?
23:57:59 * Jebdm is a student, but uses Haskell on a regular basis.
23:59:30 <rieux_> dabbler: possibly not what you meant.  i currently use haskell for building prototypes of semantics.  not the commercial sort.
23:59:54 <dabbler> rieux_: oh, gotcha
