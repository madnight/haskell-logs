00:00:33 <Jedai> vegai: Probzbly a side effect of defaulting and the monomorphism restriction
00:00:45 <mae_> perhaps the answer lies in the implementation of addTimeOut
00:01:11 <Jedai> vegai: I would probably use (maxBound :: Int) myself
00:01:48 <edwardk> vegai: maxBound has a polymorphic type, if you bind maxI locally it gets its type pegged from the monomorphism restriction as Jedai said
00:02:38 <vegai> right
00:02:58 <sjanssen> mae_: is it possible the executed process is exiting immediately?
00:03:28 <sjanssen> mae_: if the process is always doing that, a new build will never be started
00:03:36 <mae_> sjanssen: like a race condition? it exits before the buildKillLoop detects it as "active"?
00:03:44 <sjanssen> mae_: right
00:03:48 <mae_> this is possible
00:03:54 <mae_> but no, the process doesn't exit immediately
00:04:21 <mae_> i think it more likely that the process handle is seen as inactive (before process initializes?)
00:04:59 <mae_> sjanssen: so yeah, i guess i should avoid using the process handle as my semaphore :)
00:05:24 <sjanssen> I think when runCmd exits the ProcessHandle is active and the process exists
00:05:38 <sjanssen> (or has been active and has existed)
00:05:51 <mae_> hm
00:06:04 <sjanssen> but I think my paste is the better way to go
00:06:13 <mae_> i'll print the value if isActive
00:06:16 <mae_> sjanssen: k
00:06:24 <mae_> sjanssen: the function names remind me of erlang :)
00:06:26 <mae_> supervisor
00:07:03 <sjanssen> have one thread restart the process each time it exits, and have a builder loop poke the run process when it is stale
00:08:18 <mae_> sjanssen: how does said builder process necessarily know the ph of the currently running process
00:08:31 <sjanssen> mae_: they communicate via a shared MVar
00:08:47 <mae_> yeesh
00:08:52 <mae_> shared memory makes me cringe
00:08:59 <mae_> i like closures better :)
00:09:11 <mae_> i do tip my hat to your pragmatism, however.
00:09:22 <sjanssen> hammers make me cringe, I like screwdrivers better
00:10:00 <mae_> hmm
00:10:02 <sjanssen> I think the problems with shared state have been exaggerated since most other languages do it wrong
00:10:23 <Pseudonym> I disagree in part.
00:10:25 <Baughn_> They communicate via an MVar; fine. But is it used as shm or as message-box?
00:10:42 <Pseudonym> Is is true that the main problem with shared state is poor encapsulation and no memory semantics.
00:11:03 <ray> depends on what the meaning of is is
00:11:08 <mae_> yay, i sparked a debate (no pun intended)
00:11:24 <Pseudonym> But I think that CPU speed has gotten to the point where old-school synchronisation is expensive compared to lock-free code..
00:11:33 <sjanssen> Pseudonym: I'm not saying the problems are non-existent
00:11:35 <Pseudonym> And lock-free code is hard to write.
00:11:56 <Pseudonym> OO is, in a sense, one answer to the problem.
00:12:05 <Pseudonym> Instead of global mutable state, have lots of local mutable state.
00:12:15 <mae_> in theory, not in practice
00:12:26 <mae_> its a veritable mine field of danger
00:12:31 <Pseudonym> In practice, too.
00:12:34 <opqdonut> well OO is message passing
00:12:38 <opqdonut> in theory :)
00:12:39 <Pseudonym> Yes, true OO is.
00:12:51 <mae_> ok case in point
00:12:54 <mae_> C++, Java
00:12:54 <Pseudonym> Even when OO isn't message passing, I think the problem is that locks don't compose.
00:12:59 <mae_> both tout encapsulation
00:13:19 <Pseudonym> And that's a problem with locking abstractions, not necessarily the idea of distributed mutable state.
00:13:21 <mae_> but there is hidden surprises in classes -- and you end up having to look up at the internals in many cases anyways
00:13:23 <mgee> hi, I have a List. how can i convert it to a list of lists? eg. each element in the input list, is an list on its own in the resulting list...
00:13:30 <Pseudonym> Case in point: Erlang.
00:13:45 <mgee> writing it on my own is not the problem, but i am sure haskell has a function for this...
00:13:49 <Pseudonym> Erlang is an example of OO as it's supposed to be.
00:13:55 <Pseudonym> More or less.
00:13:59 <sjanssen> mgee: map return
00:14:03 <opqdonut> mgee: map return
00:14:09 <sjanssen> > map return [1, 2, 3] :: [[Int]]
00:14:10 <lambdabot>   [[1],[2],[3]]
00:14:17 <mgee> nice! thanks
00:14:23 <Pseudonym> Or use the robot ninja monkey operator.
00:14:29 <Pseudonym> > map (:[]) [1,2,3]
00:14:30 <lambdabot>   [[1],[2],[3]]
00:14:37 <mgee> cool :D
00:14:40 <opqdonut> or even
00:14:53 <opqdonut> > map (\x->[x]) [1,2,3]
00:14:54 <lambdabot>   [[1],[2],[3]]
00:15:10 <Pseudonym> Yeah, but you don't get to say "robot ninja monkey operator" often.
00:15:18 <opqdonut> :)
00:15:20 <mgee> ;)
00:15:35 <jthing> Pseudonym: ?
00:15:47 <Pseudonym> jthing: (:[])
00:16:04 <opqdonut> > sortBy (comparing length) ["return","(:[])","(\\x->[x])"]
00:16:06 <lambdabot>   ["(:[])","return","(\\x->[x])"]
00:16:23 <jthing> Yes, I got that, but I am unfamilliar with your name ;)
00:16:33 <Pseudonym> Well, it's not my real name.
00:16:41 <jthing> lol
00:16:48 <opqdonut> "obviously"
00:17:17 <johnw> hha
00:17:35 <jthing> Let's rephrase: Yes, I got that, but I am unfamilliar with your function name
00:18:01 <Pseudonym> Ah, I see.
00:18:02 <johnw> Pseudonym: you do know that your name _means_ that it's not your real name?
00:18:08 * Twey headdesks.
00:18:14 <Twey> â€˜no duhâ€™
00:18:28 <johnw> yeah, but I just had to ask
00:18:37 <Pseudonym> johnw: Would it help to know that I was reading "Goedel Escher Bach" at the time I picked it?
00:18:37 <johnw> sometimes people just get things from books
00:18:44 <Pseudonym> (Roughly 20 years ago.)
00:18:50 <Twey> Ohhh, the robot ninja monkey operator.  Woot.
00:19:12 <johnw> i never got into GEB
00:19:20 <johnw> too cutesy
00:19:29 <Pseudonym> I needed a nick and thought "how about something self-referential?"
00:19:50 <opqdonut> i should've read GEB a couple of years younger than I did
00:19:51 * johnw Tautology
00:20:16 <opqdonut> i had already been on a math course that proved gödel's incompleteness theorem etc
00:20:18 <johnw> well, a recursive nick is quite appropriate here...
00:21:23 <Pseudonym> I have a project sitting on my hard drive that I've been hacking on for a while that I called "kinara".
00:21:31 <Pseudonym> "Kinara is not a recursive acronym"
00:21:41 <Pseudonym> I think that's the first self-contradictory example.
00:23:44 <QtPlaty[HireMe]> Is there a TeX libary that can be included to supply \begin{code} \end{code} to LaTeX
00:24:36 <opqdonut> QtPlaty[HireMe]: you can use lhs2tex
00:24:43 <opqdonut> it does all sorts of nice formatting
00:25:00 <Gracenotes> Pseudonym: how'd you choose the k?
00:25:09 * jthing notes (:[]) = robot ninja monkey operator
00:25:33 <Twey> Gracenotes: <<loop>>
00:25:56 <Gracenotes> > throw NonTermination
00:25:57 <lambdabot>   Not in scope: `throw'Not in scope: data constructor `NonTermination'
00:25:59 <Gracenotes> aw.
00:26:15 <jthing> There are loops in Haskell? I though it was all done by tail recursion?
00:26:42 <Gracenotes> it means an infinite IO loop
00:26:55 <jthing> ok, sorry
00:26:57 <Gracenotes> to do with the implementation of fixIO.
00:27:13 <Gracenotes> which has very interesting semantics
00:27:40 <jthing> Gracenotes: do you have a URL?
00:27:48 <Twey> > let x = x in x -- jthing
00:28:04 <lambdabot>   thread killed
00:28:09 <Twey> Aw, I don't get a <<loop>>?
00:28:18 <Gracenotes> http://leventerkok.googlepages.com/fics.pdf
00:28:25 <jthing> thanks
00:29:13 <Gracenotes> <<loop>> is an error specific to fixIO, in this case, NonTermination
00:29:28 <Gracenotes> fixIO k = do { ref <- newIORef (throw NonTermination); ans <- unsafeInterleaveIO (readIORef ref); result <- k ans; writeIORef ref result; return result }
00:29:28 <Twey> Oh truly?
00:29:31 <Twey> Hmn
00:29:56 <Gracenotes> for instance, try "mfix print"
00:30:02 <Twey> What's the point of the IORef there?
00:32:39 <jthing> I see
00:32:55 <Gracenotes> Twey: MyCatVerbs had given an example of fixIO a while ago. mdo { tid1 <- forkIO (do { result <- somethingExpensive1; killThread tid2; writeMVar mv result; }); tid2 <- forkIO (do { result <- somethingExpensive2; killThread tid1; writeMVar mv result; })
00:33:21 <Cale> <<loop>> isn't specific to fixIO...
00:33:23 <Gracenotes> (probably not safe due to possibly race conditions/lack of guarantees in thread starting, but anyway)
00:33:45 <Cale> However, GHC's gotten a lot worse at throwing it than it used to be
00:33:57 <Cale> It used to be that Twey's code did actually result in <<loop>>
00:34:08 <Gracenotes> or. interesting.
00:34:10 <Gracenotes> *oh
00:34:34 <Gracenotes> as far as I can tell, fixIO is the only place in the GHC codebase where NonTermination is thrown
00:34:36 <Gracenotes> atm
00:34:39 <jthing> Cale: It still does, it's just smarter at recovering from a infinate loop
00:34:48 <Cale> It would throw it whenever a closure was entered while it was already being evaluated.
00:35:14 <Baughn_> Gracenotes: Well, this?
00:35:17 <Baughn_> > let x = x in x
00:35:32 <Cale> jthing: But it's worse.
00:35:32 <lambdabot>   thread killed
00:35:39 <Baughn_> ..okay, that was /supposed/ to throw NonTermination
00:35:55 <Gracenotes> it's now the nonterminating bottom
00:36:05 <Cale> Note that let x = x in x doesn't use 100% CPU though.
00:36:15 <Baughn_> It might
00:36:18 <Cale> It just blocks.
00:36:26 <Baughn_> That depends entirely on the evaluation strategy
00:36:31 <mmorrow> you don't get <<loop>> with bytecode
00:36:34 <Berengal> I just tried main = let x = x in print x, it prints <<loop>>
00:36:38 <Berengal> ghc -O2
00:36:41 <edwardk> blackholing seems to have gotten a lot more lax
00:36:53 <Cale> I think it has to do with concurrency.
00:36:55 <Baughn_> Oh yeah, I forgot
00:37:13 <Baughn_> \bot has stopped producing <<loop>> because there are signal handlers installed, so it might theoretically get broken..
00:37:23 <edwardk> or it just doesn't cause the allocations that it used to, which would eventually kick in the gc and cause it to see the blackhole
00:37:32 <Cale> Berengal: can you try with -threaded ?
00:37:39 * Baughn_ wonders who would try evaluationg a nonterminating bottom to block until a signal arrives
00:37:53 <Saizan> Baughn_: it has stopped because it now interprets like in ghci, rather than compiling
00:38:10 <Berengal> Cale: Still <<loop>>
00:38:11 <Baughn_> Saizan: That's "kept on not working", then
00:38:17 <Berengal> With with and without -N2
00:38:24 <mmorrow> Baughn_: i have, and until 6.10.2 "let x = x in x" was unrecoverable in bytecode
00:38:28 <jthing> Cale: It is the curse of lazy evaluation that you kill the halting problem
00:38:44 <Cale> Berengal: interesting, okay, that's not bad.
00:38:45 <jthing> s/kill/kiss/
00:38:59 <mmorrow> Baughn_: ah yeah, right. lambdabot used to compile to machine code with plugs..
00:39:17 <Baughn_> mmorrow: What's wrong with good old "forever $ threadDelay 10000"?
00:39:35 <jthing> aeverything?
00:39:39 <Gracenotes> *IO*cough*
00:39:43 <Gracenotes> Cale: what's this about re-entering a closure, though? Does that have any false positives?
00:39:50 <Baughn_> Gracenotes: You're waiting for a /signal/
00:40:20 <Baughn_> jthing: ..and yeah, but it's pretty much on par for this sort of code. Firefox uses select with a freakin' zero timeout..
00:40:51 <Cale> Gracenotes: no, if you try to evaluate a value, and it turns out you need to evaluate that value before you get to the point of producing a constructor, then you're certainly hosed.
00:41:20 <Gracenotes> how much overhead does it take to determine that?
00:41:25 <Cale> None at all.
00:41:32 <Gracenotes> ..at compile-time?
00:41:48 <Gracenotes> or run-time >_>
00:41:49 <Cale> Well, actually, maybe it's one write.
00:42:02 <Berengal> There has to be some overhead. Doesn't have to be much...
00:42:04 <Cale> When you enter a closure, you overwrite its address.
00:42:34 <Cale> and then when it finishes evaluating it overwrites that with a pointer to code that returns the value immediately anyway
00:42:47 <mmorrow> all a blackhole is is the same concept as you would use if you were walking a graph and marking each node you've seen (or keeping a seen set) so you don't loop. and with concurrency, blackholes snag any thread that tries to enter them until its been updated
00:43:16 <Cale> So between the point where it's first entered, and where it produces a constructor, if it tries to enter itself again, then you know you're in a loop and can stop,
00:43:35 <Cale> and yeah, it's important for threaded execution.
00:43:47 <jthing> Cale: In general, no
00:44:01 <Cale> jthing: huh?
00:44:03 <jthing> Cale: See turings halting problem
00:44:09 <Gracenotes> it wouldn't affect something like: foldl (flip (:)) [] [1..], I take it? No constructor is produced here, but it's not the same address?
00:44:13 <Cale> jthing: What are you talking about?
00:44:24 <Cale> jthing: It doesn't solve the halting problem.
00:44:37 <Cale> jthing: It just detects the most obvious kind of infinite loops.
00:45:01 <Cale> Ones where in order to evaluate a value, you need to know that value.
00:45:04 <jthing> Cale: no, it is a consequence of 'the halting problem'
00:45:10 <Cale> What is?
00:45:23 <Gracenotes> is it possible to determine whether or not some computations halt
00:45:30 <Baughn_> The second time, the closure function is replaced by const. But what does it use the first time?
00:45:30 <jthing> nonterminating loops
00:45:32 <Gracenotes> just not all of them
00:45:35 <Cale> jthing: ...
00:45:36 <mmorrow> jthing: have you ever written a reachable function on a graph?
00:46:07 <Cale> jthing: Sorry, I don't know how what you're saying relates at all to what I was saying about how GHC evaluates Haskell code.
00:46:09 <Berengal> Baughn_: I'd expect something like 'throw InfiniteLoop'
00:46:14 <mmorrow> if the graph is finite, it'll terminate. you just have to keep track of nodes you've seen
00:46:19 <jthing> I used the RETE algorithm the last time (but that was written in Comon Lisp)
00:46:25 <Baughn_> Berengal: Can't do that; another thread might enter it in the meantime
00:46:43 <Baughn_> Berengal: I suppose code that checks /which/ thread is doing it..
00:46:51 <Cale> jthing: Anyway, the point is that there are some infinite loops you can detect for almost-free.
00:47:02 <mmorrow> jthing: blackholes are a thread of executions way of keeping track of seen node
00:47:05 <jthing> true
00:47:09 <Berengal> Baughn_: Something to that effect. The specifics are up to the implementers as far as I care :)
00:47:17 <Cale> and that's what GHC is doing when it reports <<loop>>
00:47:44 <Cale> <<loop>> means that you're trying to evaluate something which is already evaluating, so you should just give up now.
00:47:59 <Gracenotes> Cale: can this be explicitly turned on in GHC nowadays?
00:48:20 <Cale> Gracenotes: It's always on... it just doesn't seem to work in ghci/bytecode apparently.
00:48:22 <mae_> sjanssen: thanks for your help!
00:48:34 <Gracenotes> I see. another compilin thing..
00:48:40 <mjrosenb> is there any way to get a temporary fifo?
00:48:40 <Berengal> Cale: Even -O0?
00:48:52 <Cale> Berengal: I would expect even in -O0, but you can try it.
00:48:53 * Berengal tests
00:48:59 <Cale> It's a fundamental part of the evaluation model
00:49:11 <Cale> and it's necessary for threaded evaluation too
00:49:13 <Berengal> Yeah, -O0 <<loops>>
00:49:16 <jthing> gotcha
00:49:38 <Gracenotes> mjrosenb: yes. It's mentioned in RWH...
00:49:42 <Cale> Because if one thread is evaluating something and another thread tries to evaluate that same thing, you don't want them to both start working on it normally.
00:49:57 <Gracenotes> http://book.realworldhaskell.org/read/io.html#io.example
00:49:58 <Cale> So that second thread will hit the blackhole and block.
00:50:11 <Cale> (until the first thread writes its result)
00:50:29 <mjrosenb> Gracenotes: is there a library function, or do i have to write a bunch of code?
00:50:41 <mjrosenb> Gracenotes: i'm on a system without a web browser right now
00:50:46 <Gracenotes> see the example. it imports and uses a base module...
00:50:47 <Cale> I suppose the blackhole must contain a check to see which thread is executing.
00:51:14 <Gracenotes> oh. Well, you might need documentation for System.IO and System.Directory. but the functionality's there
00:51:32 <edbond> how can I do 'cabal upgrade' ?
00:51:48 <Cale> Though, there actually is a one-instruction gap or so where two threads can start evaluating the same value, but it's statistically insignificant.
00:52:01 <mjrosenb> Gracenotes: is it basically, creating a temp directory, then making a fifo in that?
00:52:16 <Cale> (and I think there are some other ways that it tries to prevent that from going on very long)
00:52:30 <Cale> edbond: Usually it's not very safe to do that.
00:52:42 <Cale> edbond: I recommend upgrading only individual packages.
00:53:04 <Berengal> Doesn't cabal upgrade simply state which packages have newer versions available?
00:53:21 <Cale> Oh, does it?
00:53:21 <Gracenotes> mjrosenb: hm. It seems that the functionality provided is mainly being able to get the temporary directory.
00:53:44 <mjrosenb> Gracenotes: gotcha.
00:53:51 <Berengal> Cale: Yes, cabal upgrade tells you it's a bad idea to cabal upgrade, then lists the out-of-date packages
00:53:58 <Cale> oh, that's new then
00:54:00 <Cale> :)
00:54:02 <Gracenotes> and, of course, the guarantees provided by the "finally" function.
00:54:14 <Berengal> Apparantly, though I've used it for some time...
00:54:24 <Gracenotes> mjrosenb: it is functional programming :) so RWH makes a function to alleviate the repetitiveness of the task.
00:54:42 <Cale> Normally, that'd be  cabal upgrade --dry-run
00:55:27 <Berengal> I'm sure you could sed out the packages and cabal install them in a script :P
00:55:36 <mjrosenb> Gracenotes: yeah.
00:56:08 <mjrosenb> functional programming is awesome
00:56:19 <mjrosenb> but library functions are more awesome
00:57:09 <Gracenotes> withTempFile pattern func = do { tempdir <- catch (getTemporaryDirectory) (\_ -> return "."); (tempfile, temph) <- openTempFile tempdir pattern; finally (func tempfile temph) (do hClose temph removeFile tempfile); }
00:57:27 <Gracenotes> withTempFile :: String -> (FilePath -> Handle -> IO a) -> IO a
00:58:26 <Berengal> Isn't there some pipe stuff in System.Posix?
00:59:18 <Gracenotes> mm.mkstemp :: String -> IO (String, Handle)
00:59:22 <Gracenotes> -mm.
00:59:44 <mjrosenb> Gracenotes: mkstemp doesn't make a fifo though
01:01:21 <mjrosenb> Gracenotes: withTempFile, is that the function described in RWH?
01:01:45 <Gracenotes> yes.
01:02:06 <Berengal> System.Posix.IO.createPipe :: IO (Fd, Fd)
01:02:29 <sepeth> and also createNamedPipe
01:02:56 <mjrosenb> sepeth: yes, but it does not create a temporary named pipe
01:04:20 <Axman6> dons: you around?
01:12:52 <edbond> What is the problem with different versions of packages? Look at rubygems and store all versions of package. Cabal.package 'C', '>=1.0.1.0' before 'import C'.
01:13:11 <Axman6> bleh, why is #haskell always so quiet when i'm here to follow it :(
01:13:20 <hatds> @src Ratio
01:13:20 <lambdabot> data (Integral a) => Ratio a = !a :% !a
01:14:01 <hatds> :t %
01:14:02 <lambdabot> parse error on input `%'
01:14:05 <hatds> :t (%)
01:14:07 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
01:24:07 * Saizan wonders what edbond meant
01:27:19 <tibbe> Saizan: I think ruby gems has you specify the package version in the source code
01:32:38 <voker57_> @hoogle a -> ()
01:32:38 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
01:32:38 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
01:32:38 <lambdabot> Prelude id :: a -> a
01:33:10 <voker57_> @hoogle IO a -> IO ()
01:33:10 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
01:33:10 <lambdabot> Control.Exception block :: IO a -> IO a
01:33:10 <lambdabot> Control.Concurrent runInBoundThread :: IO a -> IO a
01:36:09 <jbhatta> ok, so i just used readFile to get the contents of a file, but now am i seriously stuck dragging around this whole IO monad?
01:36:26 <Botje> yup
01:36:45 <Botje> although you're free to use free code
01:37:06 <Botje> do { contents <- readFile ...; let newContents = pure contents; putStrLn newContents }
01:37:16 <Botje> where "pure" is a pure function :)
01:37:33 <Twey> readFile ... >>= putStrLn . pure
01:37:42 <jbhatta> ok, but what if i want to use a function that doesn't return a monadic value?
01:37:51 <jbhatta> do i just need to write a monadic version that piggybacks on the old one?
01:37:53 <Twey> jbhatta: See above
01:38:04 <Twey> You can call pure functions from IO functions
01:38:04 <Botje> you can't turn an IO a into an a, no
01:38:07 <Twey> Just not vice versa
01:38:25 <jbhatta> yeah, that's sorta what i was wondering.  drat
01:38:33 <jbhatta> ok, maybe there's more specific advice for this case:
01:38:48 <jbhatta> i want to be able to update a database file
01:39:24 <Twey> So, you need to read it in, modify it, and spit it out again â€” right?
01:39:31 <jbhatta> what i am currently doing is computing the addenda to the file, reading in the file, and i'd LIKE to append the two
01:39:37 <jbhatta> yep
01:39:44 <Twey> The reading and the writing are impure
01:39:47 <Botje> oh, you're just appending stuff?
01:40:02 <jbhatta> the stuff i'm appending depends on the contents i already have in the file
01:40:02 <Twey> You basically do exactly what Botje said
01:40:03 <Botje> you can open a file for appending
01:40:04 <jbhatta> but yes
01:40:17 <Botje> << shower
01:40:30 <Twey> The function that works out how to modify it based on what the current contents is is pure
01:40:37 <Twey> You just have to pass in the current contents
01:40:57 <jbhatta> that's my problem: i can't shake off the IO part of the contents of the file
01:41:09 <jbhatta> right?  so that function has to take a monadic argument...?
01:41:20 <jbhatta> or rather it has to produce monadic output
01:41:29 <Twey> No
01:41:51 <Twey> The result of readFile is monadic, but the value you're working with in modify doesn't have to be
01:42:08 <jbhatta> how do i pass the result to the modify?
01:42:13 <jbhatta> with bind?
01:42:39 <Twey> In do notation, you could write: do { foo <- readFile fn; writeFile fn $ modify foo }
01:43:19 <jbhatta> the "modify foo" part is what i'm confused about
01:43:27 <jbhatta> doesn't foo have type IO String?
01:43:31 <Twey> No
01:43:39 <Twey> readFile fn has type IO String
01:43:47 <Twey> But the function you bind to it takes a pure value
01:43:59 <Twey> That's expressed in do notation using the <- operator
01:44:01 <jbhatta> ohhhhhhhhhh right!
01:44:09 <jbhatta> ah, ok, thanks!
01:44:18 <Twey> You can think of <- as â€˜pulling a value out of the monadâ€™ although of course in reality no such thing happens
01:44:28 <Twey> No problem :)
01:45:01 <Twey> Remember the type of (>>=) :: m a -> (a -> m b) -> m b
01:45:04 <Berengal> Twey: What does happen in reality?
01:45:25 <jbhatta> ah, yes twey, i think you just helped my synthesize ;)
01:45:29 <Twey> Berengal: The rest of the code from that point forwards is inserted into the monad
01:45:30 <jbhatta> *me
01:46:41 <Berengal> Twey: I had a point, but I forgot :(
01:46:54 <Twey> Heh
01:47:51 <Berengal> (State sm) >>= f = State \s -> let (a, s') = sm s in f a s'
01:48:03 <Berengal> It had something to do with that
01:49:44 <mib_52m54gi3> for what stands the $ sign?
01:49:57 <Berengal> @src ($)
01:49:57 <lambdabot> f $ x = f x
01:50:04 <Berengal> It's an operator
01:50:27 <Twey> It has very low precedence
01:50:33 <mib_52m54gi3> and what does the operator in:
01:50:34 <mib_52m54gi3> do { foo <- readFile fn; writeFile fn $ modify foo }
01:51:09 <canvon> mib_52m54gi3: "writeFile fn $ modify foo" is the same as "(writeFile fn) (modify foo)"
01:51:17 <Twey> â€˜a b $ c dâ€™ generally means â€˜(a b) (c d)â€™
01:51:39 <Berengal> Which again means 'a b (c d)
01:51:53 <mib_52m54gi3> ahh yes
01:52:04 <mib_52m54gi3> thanks
01:52:13 <Berengal> It's just a way to avoid parenthesis
01:57:21 <osfameron> and to increase composability
01:58:14 <Saizan> composability how?
01:58:56 <osfameron> that may be the wrong word then...
01:59:21 <osfameron> erm... breaking things up into:  pipeline . of . commands : argument     makes it easier to extend that pipeline, and to refactor it into pointless style etc.
01:59:35 <osfameron> s/:/$ as appropriate
02:00:02 <Saizan> ah, with also (.) then i agree
02:00:25 <Cale> The associativity of (.) means that expressions written with it effectively have more subexpressions than they'd otherwise have.
02:04:27 <Cale> For example, f (g (h x)) has f, g, h, h x, g (h x), and f (g (h x)), which is 6 subexpressions, while f . g . h $ x has f, g, h, f . g, g . h, f . g . h, h $ x, g . h $ x, and f . g . h $ x, which is 9.
02:06:14 <Cale> (as the chain grows longer, this effect becomes more pronounced)
02:06:40 <zachk> whats the actual effect of it
02:06:50 <zachk> just more subexpressions?
02:07:20 <Cale> Well, the more subexpressions you have, the easier it is to refactor, and it lets you think about each part separately more easily.
02:07:57 <FunctorSalad> has someone tried doing syb-like generics with TH?
02:08:07 <Cale> All those "subexpressions" I gave are well-typed values on their own, and are meaningful.
02:08:27 <FunctorSalad> the advantage being that it would avoid all the casting mess
02:09:22 <FunctorSalad> (and any runtime performance penalty)
02:10:36 <boegel> is there a clean way to uninstall packages from the GHC codebase?
02:11:39 <FunctorSalad> ghc-package unregister? unless by 'clean' you mean deleting the files
02:11:51 <FunctorSalad> *ghc-pkg
02:12:18 <boegel> FunctorSalad: yeah, I mean deleting the actual files
02:12:35 <boegel> FunctorSalad: I'm using GHC on our supercomputer, and I only have a quota of 3G of $HOME
02:12:46 <boegel> s/3G of/3G for/
02:12:47 <FunctorSalad> hehehe 'only 3G'
02:13:37 <boegel> FunctorSalad: turns out the lib part of GHC 6.10.2 is already 1.1G
02:13:50 <FunctorSalad> boegel: I was just thinking of double-digit MB student account quotas ;)
02:14:46 <boegel> FunctorSalad: :)
02:18:42 <FunctorSalad_> hmm is it possible to obtain the type of a Q Exp passed to a TH function?
02:19:15 <FunctorSalad_> (AFAIK the quasiquoted Exp is typechecked anyway)
02:19:53 <FunctorSalad_> (I mean, without complex stuff like running your own ghci inside the TH function ;))
02:24:51 <cakoose> Anybody know what I have to import to get a Monad Either instance?
02:25:19 <cakoose> I wrote my own instance, but apparently it conflicts with Control.Monad.Error.Class.Error's instance.
02:25:21 <dibblego> Control.Monad.Instances
02:26:56 <Cale> cakoose: Doesn't that mean that the module you've already imported must contain an instance?
02:27:15 <Cale> cakoose: The instance in mtl is a bit stupid.
02:27:33 <Cale> It's  instance (Error e) => Monad (Either e)
02:27:59 <Cale> So you have to write an instance of Error for your left type.
02:28:12 <cakoose> Cale: is that so there's something there for 'fail'?
02:28:15 <Cale> yeah
02:28:22 <jbhatta> am i allowed to do hGetContents on stdin?
02:28:39 <Cale> jbhatta: yes, but getContents already does that
02:28:40 <cakoose> Is there any way to define a limited scope for an instance?
02:28:52 <jbhatta> cale: oh!  ok, thanks
02:29:12 <Cale> cakoose: basically no, because instances are unnamed. As soon as you import a module, you get all the instances in it.
02:29:44 <cakoose> Cale: So there's no generic "instance Monad (Either a)" anywhere in the standard libraries?
02:30:48 <Cale> Right, which is unfortunate. mtl is becoming perhaps a little less standard though. There are other options now. Let me check what monadLib has
02:31:45 <Cale> (I'm not sure it does anything with Either)
02:31:50 <cakoose> Cale: Maybe I should get rid of my reliance on Either being a Monad and do everything explicitly?
02:32:11 <Cale> cakoose: Or just write an instance of Error for your appropriate type?
02:32:11 <cakoose> Cale: It would be annoying for me, but at least users of my library wouldn't have conflicts.
02:32:14 <Cale> ah
02:32:21 <Cale> I see
02:32:29 <Cale> yeah
02:33:17 <cakoose> Cale: Hmm... my error type is just a tuple.  Should I create a newtype to avoid potential multiple Error instances for it?
02:34:16 <Cale> Mm... possibly. It's interesting how these issues are potentially much more troublesome for libraries than they are for other programs.
02:34:41 <Cale> But yeah, it might be a good idea anyway, to document what the components of the tuple are as well.
02:35:24 <cakoose> Right now, the only user of my "library" is copying my source code into his source tree.  If I made a "proper" library (using cabal?), could I avoid this issue?
02:35:57 <tombee> If I wish to reverse a list, for me it makes sense to just say:
02:35:59 <tombee> myReverse = foldl (:) []
02:36:11 <Cale> tombee: foldl (flip (:)) []
02:36:26 <tombee> I've seen that yeah, but I didn't understand why we require flip?
02:36:31 <Cale> cakoose: The trouble is there's no way to localise instances.
02:37:07 <Cale> tombee: because of the order in which the elements of the list are combined is still left-to-right in the same order as the list
02:37:35 <Cale> (even if it's associated to the left)
02:37:39 <Cale> also...
02:37:50 <jbhatta> argh!  ok, so i do an hPutStr to stdout and it works perfectly.  when i try and output to a different file handle it compiles but doesn't actually write anything
02:37:53 <tombee> Ah, so even so, how come it doesn't compile/run? :)
02:38:03 <jbhatta> i opened the handle with: h <- openfile "./file" WriteMode
02:38:04 <Cale> ((([] : 1) : 2) : 3) is a type error
02:38:16 <Cale> for the same reason that foldl (:) [] [1,2,3] is
02:38:31 <Saizan> jbhatta: do you also hClose and/or hFlush it?
02:38:41 <Cale> jbhatta: Check the buffering
02:38:42 <jbhatta> nope.  just two lines in the do
02:38:55 <jbhatta> do i need to hflush?
02:39:03 <Cale> jbhatta: jbhatta That will probably help.
02:39:07 <Cale> whoops :)
02:39:15 <jbhatta> hehe.  ok, trying
02:39:33 <Cale> You could also do something like  hSetBuffering h NoBuffering
02:40:02 <Cale> (Which might be convenient, but it will possibly also harm performance if that matters to you)
02:40:07 <jbhatta> ah, i'll try that
02:40:14 <jbhatta> nah, i don't care about performance atm
02:40:42 <cakoose> Cale: Oh... I see what you mean by 'mtl' now...  It's a non-default library...
02:40:45 <Berengal> NoBuffering isn't recommended when it comes to files
02:40:52 <Cale> cakoose: yeah
02:40:58 <Cale> cakoose: Though it's widely used
02:41:02 <jbhatta> ah, well it DID work when i turned off buffering
02:41:06 <jbhatta> what the HECK
02:41:14 <cakoose> Cale; ok, maybe I'll just define an instance for "Monad (Either MySpecificErrorType)"
02:41:56 <Cale> jbhatta: Writes to files are stored up in a buffer and only written when that buffer fills, or when you close or flush the handle.
02:42:27 <jbhatta> oh, it doesn't get flushed when the application terminates?
02:42:28 <Cale> jbhatta: This means less disk access, but also means that if your program dies in the middle, maybe not everything will have been written.
02:42:31 <jbhatta> *blushes*
02:43:32 <Saizan> no, it gets flushed only when you use hClose
02:44:31 <jbhatta> ah, this is working fine now
02:44:34 <Cale> This seems a common enough problem that it seems it might be worthwhile to add something to the RTS which would ensure all filehandles get closed and buffers properly flushed when a Haskell program stops.
02:44:58 <sjanssen> jbhatta: it is good programming practice to make sure that every open is followed by a close
02:45:03 <sjanssen> this applies to all sorts of resources
02:45:07 <jbhatta> it's arguably just sloppiness on my (and all those other people's) fault
02:45:11 <jbhatta> yeah
02:45:15 <jbhatta> fair enough
02:45:33 <Cale> You might consider using withFile :)
02:45:55 <Cale> :t withFile
02:45:57 <lambdabot> Not in scope: `withFile'
02:46:01 <Cale> :t System.IO.withFile
02:46:02 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
02:46:52 <jbhatta> ah, ok
02:46:58 <jbhatta> nice
02:47:10 <jbhatta> well i've got it this time, but next time i think i WILL use withFile
02:47:10 <jbhatta> hehe
02:48:03 <Saizan> or simply writeFile
02:48:21 <jbhatta> didn't want to do writefile because i read the file right beforehand
02:48:32 <jbhatta> and was scared of locking issues
02:49:09 <Saizan> i guess the locking issues won't change much
02:49:19 <Saizan> ?src writeFile
02:49:20 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
02:49:58 <jbhatta> *shrug*
03:00:37 <Workybob> Peter V and I have been playing about trying to do generalised sections - generalised enough that you can forget to supply the functions even
03:00:45 <Workybob> but we lost type inference in the process
03:00:46 <Workybob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4871#a4871
03:01:01 <Workybob> v2 there gives that nasty type error at the bottom
03:01:19 <Twey> o.@
03:01:27 <Twey> How does that work?
03:01:33 <Twey> filter () xs?
03:01:37 <Workybob> if you make it v2 = apply (A (negate :: Int -> Int) :& A (1 :: Int) :& Nil) then it type checks and runs
03:01:47 <Workybob> Twey: that returns \f -> filter f xs
03:01:56 <Twey> Oh right
03:02:08 <Twey> Cool
03:02:14 <Workybob> better yet, () () xs returns \f g -> f g xs
03:02:25 <Twey> But how does that interact with unit?
03:02:33 <Workybob> well, we don't use () as the syntax
03:02:44 <Twey> Ah
03:03:08 <Workybob> unfortunately, you would have to say apply (A filter :& B :& A xs :& Nil) for the first
03:03:17 <Workybob> and apply (B :& B :& A xs :& Nill) for the second
03:03:29 <Twey> Somewhat less friendly
03:03:31 <Workybob> yeh
03:03:42 <Twey> (even than \f -> filter f xs :-P)
03:03:47 <photonen> what is a good name for a function that takes a pair oflists and returns the combos that satisfies a condition?
03:03:53 <Workybob> yeh, that's not a problem for our use of this
03:03:55 <photonen> satisfy :: [a] -> [a] -> (a -> a -> Bool) -> [(a, a)]
03:03:59 <photonen> satisfy is nit good
03:03:59 <Workybob> but the type inference disapearing is
03:04:00 <Workybob> :/
03:04:29 <Workybob> photonen: filter . zip -- almost
03:06:17 <photonen> filter . zip?
03:06:17 <photonen> im asking for the name
03:06:17 <photonen> i have the implementation
03:06:38 <ziman> :t filter . zip
03:06:38 <Workybob> pairFilter?
03:06:39 <lambdabot>     Couldn't match expected type `Bool'
03:06:39 <lambdabot>            against inferred type `[(a, b)]'
03:06:39 <lambdabot>       Expected type: [a] -> [b] -> Bool
03:06:51 <Workybob> also, I was suggesting that you might not want to name it
03:07:26 <palmje> Does anyone know how to execute a shell command and capture the output?
03:07:37 <Workybob> Twey: so no idea where our type inference has gone?
03:08:18 <Asztal> palmje: hmm, it's done in RWH, I think
03:08:41 <palmje> Asztal: RWH?
03:09:08 <Berengal> palmje: Take a look in System.Process. I believe that's a good place to start at least. Can't really help you more
03:09:21 <photonen> can head not be compsoed?
03:09:21 <photonen> satisfy :: [a] -> [a] -> (a -> a -> Bool) -> [(a, a)]
03:09:21 <photonen> satisfyOne :: [a] -> [a] -> (a -> a -> Bool) -> (a, a)
03:09:21 <photonen> satisfyOne = head . satisfy
03:09:21 <photonen> fail
03:09:27 <igel> does "stability" in a cabal file refer to how much the interface will change or to how bug-free (stable) the software is?
03:09:52 <Asztal> palmje: http://book.realworldhaskell.org/read/systems-programming-in-haskell.html
03:09:59 <dcoutts> igel: interface
03:10:16 <dcoutts> igel: oh, the stabiltiy field, oh, don't use it, it's useless
03:10:21 <Berengal> photonen: head takes a '[a]', but satisfy returns a [a] -> (a->a->Bool)->[(a,a)]
03:10:33 <dcoutts> igel: follow the PVP instead, it means something
03:10:41 <palmje> Berengal: I've looked there already and I can run a shell command, but all I get back is an IO ExitCode and I can't figure out how to get the output of the command
03:10:43 <igel> pvp?
03:10:51 <igel> player vs player? :)
03:12:00 <doserj> photonen: satisfyOne = ((head .) .) satisfy
03:12:10 <igel> dcoutts: ?
03:12:11 <Berengal> palmje: runInteractiveProcess seems to be what you're looking for
03:12:41 <dcoutts> @where PVP
03:12:42 <lambdabot> I know nothing about pvp.
03:12:45 <dcoutts> bah
03:12:52 <doserj> erm satisfyOne = ((head .) .) . satisfy
03:13:12 <dcoutts> @where+ PVP http://haskell.org/haskellwiki/Package_versioning_policy
03:13:12 <lambdabot> It is forever etched in my memory.
03:13:17 <dcoutts> igel: ^^
03:13:33 <igel> ah of course
03:14:06 <Berengal> palmje: Or you could look at System.Process.Pipe. Sorry, I haven't really used this myself...
03:15:20 <Saizan> Workybob: rewrite the instance head as instance (Apply (A b :& rest), a ~ c) => Apply (A (a->b) :& A c :& rest) where
03:15:33 <Saizan> Workybob: then your only problem will be the MonomorphismRestriction
03:16:27 <Workybob> Saizan: so, what does the ~ do there?  it says a must be unified with c?
03:16:39 <palmje> Berengal: ok. Thanks
03:16:42 <Saizan> Workybob: yes, essentially
03:16:51 <Workybob> neat
03:17:10 <Saizan> Workybob: with your instance the two variables must be _already_ unified for the head to match
03:17:19 <Workybob> ah, okay
03:17:28 <Workybob> yep, that makes sense
03:17:43 <Saizan> i'm not that positive on it making sense :)
03:18:27 <Axman6> hmm, anyone know if the papers and such from http://www.galois.com/blog/research-catalog/ are accessable anywhere?
03:18:51 <Workybob> Saizan: you're a genius, thanks a lot
03:19:05 <Workybob> had to modify the definitions of Result as well to match the head
03:19:09 <Workybob> but yeh, shiny :D
03:19:48 <Axman6> actually, doesn't look there are any on the topic i wanted anyway
03:20:12 <Saizan> before ~ we had to use a TypeEq class :)
03:21:43 <Saizan> Axman6: i'd look for the author's pages
03:24:36 <ivanm> Axman6: you're at ANU, right?
03:24:44 <Axman6> yep
03:24:58 <ivanm> I might be applying for PhD there for next year
03:25:06 <Axman6> nice
03:25:25 <ivanm> how is it there?
03:25:36 <ivanm> are you actually from Canberra, or just go there for uni?
03:26:12 <Axman6> it's really nice. the campus is awesome
03:26:22 <Axman6> and yeah, i'm a canberran born and raised ;)
03:27:06 <ivanm> well, my brother is down there atm at ADFA
03:27:19 <ivanm> and he's telling me I shouldn't go there because the weather is bad, etc.
03:27:40 <Axman6> well, if he's from queensland, he would think that (it's pretty damn cold at the moment)
03:27:50 <Wraithan> Any recommended forums for Haskell? I am coming close to being done with my first application using Haskell and figured I'd post it on a forum to have experts rittle it full of bullet holes and tell me all the stuff I did wrong lol
03:28:23 <Saizan> there's haskell-cafe@haskell.org
03:28:33 <Axman6> there's also #haskell
03:34:24 <ivanm> Axman6: he said it was worse than Melbourne's :s
03:34:34 <Axman6> it is
03:34:51 <ivanm> :o
03:35:02 <ivanm> how can it be? you can _predict_ Canberra's weather, can you not?
03:35:08 <Axman6> canberra has probably the biggest extremes in temperatures of any of the capital cities
03:35:13 <Axman6> heh, yeah
03:35:28 <photonen_> is Australia the greatest place to live?
03:35:53 <Axman6> but our minimums are often below -5 and maxes above 40
03:35:55 <ivanm> photonen_: of course!
03:35:57 <Axman6> photonen_: by far ;)
03:36:04 <ivanm> Axman6 lives down here!
03:36:12 <ivanm> ergo, Australia is the best place to live! :p
03:36:27 <ivanm> his choice of cities leaves a lot to be desired, however... :p
03:36:51 <Axman6> hmm, is there an easy way to get a row or column from an Array?
03:37:14 <Axman6> i love canberra. beats the crap out of places like sydney
03:37:39 <ivanm> Axman6: to get a row/col, I've mapped ! over a list of elements I've generated
03:37:48 <ivanm> s/elements/indices/
03:37:53 <Axman6> yeah, sounds like the best way to do it :\
03:37:55 <ivanm> Axman6: I agree with you there though
03:38:29 <ivanm> Axman6: look, dons had to leave the country to get away from Sydney! :p
03:38:37 <Axman6> exactly!
03:38:37 <photonen_> sydney
03:38:48 <photonen_> or Perth?
03:38:49 <photonen_> for surginh+uni
03:38:53 <Axman6> but yeah, i hate sydney, so loud, expensive, dirty... i could go on
03:38:57 <photonen_> surfing
03:39:01 <photonen_> dirty?
03:39:53 <ivanm> photonen_: Perth is in the middle of nowhere
03:40:01 <ivanm> as for surfing... Gold Coast!
03:40:05 <Axman6> yeah
03:42:01 <Wraithan> I haven't implemented the time left part but was wondering if someone wouldn't mind looking at http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2416#a2416 and giving me some feedback on what (which may be working) but was done wrong
03:42:40 <QtPlaty[HireMe]> It seems like I'm the only person who likes sydney.
03:42:49 <photonen_> ivanm: sure but 1.5million people, pretty big right?
03:42:53 <ivanm> QtPlaty[HireMe]: yes, you are
03:43:09 <blackh> Wraithan: I like it!
03:43:13 <ivanm> photonen_: you mean Sydney?  it's the biggest city Down Under...
03:43:17 <Wraithan> This is my first haskell app, I plan on setting it up to replace the Battery Monitor in xmobar eventually, because that one blows
03:43:22 <photonen_> no Perth
03:43:25 <photonen_> 1.5mill
03:43:30 <photonen_> but it is int he middle of nowehre
03:43:35 <photonen_> great windsrufing though
03:44:17 <ivanm> oh, the actual city is pretty small
03:44:23 <blackh> Wraithan: What you want to do is take monads out wherever you can. You could take it out of parseACPILine, for instance.
03:44:23 <ivanm> but its suburbs are huge, IIRC
03:45:27 <Wraithan> blackh: I am not sure how it ended up being a monad to be honest, that is what :info in ghci told me it was, when I was trying to define the type of each function I couldn't get that one to work
03:46:04 <Wraithan> The other ones I could figure out by looking at them and write their types out, but I don't get the monad part of parseACPILine
03:46:06 <blackh> Wraithan: Take the 'do' and the 'return' bits out and change 'let ...' to 'let ... in'.
03:47:05 <blackh> I can't quite see how 'parseAPCIFile (x:xs) = parseACPILine ++ ..' could typecheck.  Maybe it thinks it's the list monad.
03:47:42 <Philippa> Wraithan: parseACPIFile looks like a use case for concatMap from here
03:48:00 <Wraithan> I haven't learned maps yet heh
03:48:03 <doserj> Wraithan: replace the "do let ... return ..." with "let ... in ..." in parseACPILine
03:48:04 <Philippa> and yes, it's forcing it into the list monad
03:48:11 <Philippa> map is just "foreach"
03:48:34 <Philippa> > map (+1) [1,2,3]
03:48:35 <lambdabot>   [2,3,4]
03:48:56 <Philippa> > map toUpper "hello"
03:48:57 <lambdabot>   "HELLO"
03:49:23 <Asztal> or just "case findIndex (':'==) x of ..." since whereToSplit isn't used afterwards
03:49:28 <photonen> OK what about doing games in the browser with Haskell
03:49:29 <photonen> ?
03:49:33 <blackh> Wraithan: parseACPIFile wants to be something like: parseACPIFile = map parseACPILine
03:50:07 <photonen> ivanm: is Perth the city small? it is just a bunch of people spread out over a large area?
03:50:07 <Wraithan> aaaah, this is why I like forums, slower so I can look things up and try things lol
03:50:11 <photonen> not a great city?
03:50:32 <ivanm> photonen: I was there about 5 years ago... there is one smallish street of relatively small skyscrapers
03:50:34 <ivanm> that was the city
03:50:39 <blackh> Wraithan: You're using explicit recursion in parseACPILine which would normally be your last resort after you've considered map, foldX, scanX, mapAccumX, etc
03:50:50 <Wraithan> I'll be back in a couple mins when I try some of those ideas
03:51:27 <Wraithan> blackh: I come from imperative languages, the recursion was the first thought, since I dont have my for/while loops
03:51:54 <photonen> ivanm: lol ok, i thought since it is 1.5million people it would be pretty hip and big
03:51:56 <Wraithan> let me look up maps and read about them a bit and try it out, I will be back in a couple mins
03:52:11 <blackh> Wraithan: (Same here.) Haskell code tends to shrink before your eyes. :)
03:52:12 <doserj> parseACPIValue = filter (not.(`elem`[':',' ']))
03:52:40 <blackh> doserj: Blimey - that's almost disappeared completely!
03:52:41 <Wraithan> doserj: I knew there had to be a function like that
03:53:03 <Asztal> (\\ ": ")
03:53:05 <Wraithan> I just didn't know it so I just iterated over the whole list <.<
03:53:07 <Asztal> :)
03:54:04 <doserj> Asztal: not quite, unfortunately
03:54:14 <doserj> > ":::"\\": "
03:54:15 <lambdabot>   "::"
03:54:18 <Asztal> ah, bleh. is it deleteFirstsBy?
03:57:03 <canvon> > filter (`notElem` ": ") ":::"
03:57:04 <lambdabot>   ""
03:57:46 <Twey> doserj: filter $ not . (`elem` ": ")
03:57:59 <Twey> There's a notElem?
03:58:02 <Twey> :t notElem
03:58:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:58:04 <Twey> My
03:58:23 <Twey> filter(`notElem` ": ")
03:58:42 <canvon> was surprised, too, when I found it ^^'
04:00:01 <canvon> elem              = any . (==)
04:00:01 <canvon> notElem           = all . (/=)
04:00:06 <canvon> perhaps for performance reasons?
04:00:36 <mib_52m54gi3> hi pro's, i am a beginner. how would you say in english, speaking, the following...   forall a. (Eq a) => a -> [a] -> Bool
04:01:46 <canvon> mib_52m54gi3: "a -> [a] -> Bool" says it's a function that takes an argument of an arbitrary type, then a list of that same type, then returns True/False
04:02:16 <canvon> mib_52m54gi3: "(Eq a) =>" says this type must instantiate the Eq class, i.e., support "=="
04:03:13 <palmje> Berengal: I've got it working using runInteractiveProcess & hGetContents.  Thanks!!
04:03:14 <canvon> (I'm not a pro, though :)
04:03:28 <mib_52m54gi3> cavon, that helps me understand, thank you
04:03:43 <canvon> mib_52m54gi3: you're welcome
04:04:59 <mib_52m54gi3> @type forall
04:05:00 <lambdabot> Not in scope: `forall'
04:05:01 <yowgi> is there anything that prevents creating an instance of Eq in which a == b and a /= b?
04:05:42 <Twey> yowgi: Apart from common sense, no
04:06:05 <yowgi> yes :-). thanks.
04:06:24 <doserj> yowgi: a simple way: only define either (==) or (/=)
04:06:44 <Axman6> @src (==)
04:06:44 <lambdabot> x == y = not (x /= y)
04:06:46 <Axman6> @src (/=)
04:06:47 <lambdabot> x /= y = not (x == y)
04:06:52 * Axman6 loves that
04:07:30 <canvon> mib_52m54gi3: AFAIK, explicit forall in a type signature is beyond the Haskell 98 standard (but, oh well, what isn't). in this case, you can just omit it.
04:07:59 <Philippa> you can always omit outermost foralls
04:09:34 <mib_52m54gi3> canvon: fine
04:10:53 <Wraithan> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2416#a2417
04:11:23 <Wraithan> Ok, cleaned it up with your advice (had to look up the let .. in part but I think I get it)
04:11:35 <Wraithan> And had to look up how filter works, which I also think I get
04:11:43 <doserj> parseACPILine x = let (key,ys) = break (==':') x in if ys=="" then ("","") else (key,parseACPIValue ys)
04:13:06 <Wraithan> So break is like splitAt but takes the element value I want to split at instead of the index?
04:13:15 <doserj> @type break
04:13:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:13:17 <Wraithan> Would have been nice to find that function sooner
04:13:40 <doserj> it takes a predicate to decide where to break
04:13:56 <Wraithan> Alrighty, cool
04:14:39 <Wraithan> I don't get the variable naming of ys what does that mean?
04:14:53 <doserj> names mean nothing
04:15:10 <Wraithan> I see it in other examples, I meant what does 'ys' itself mean
04:15:18 <osfameron> Wraithan: plural of "y"
04:15:24 <doserj> ys is a list of y's
04:15:27 <Wraithan> Ah
04:15:35 <Wraithan> like x xs, I understand now
04:15:46 <Wraithan> ( I didn't get xs before either lol )
04:17:05 <ivanm> my brother has heard that bruker (http://en.wikipedia.org/wiki/Bruker) uses Haskell for the NMR, etc. equipment... anyone know if this is true?
04:17:10 <ivanm> haskell.org has no mention of them
04:17:20 <ivanm> and googling fails due to people using Haskell as a name
04:18:06 <Wraithan> Is their a significance in why doserj put ==':' instead of ':'== like I put (and I found in a different example) or is it just a matter of style?
04:18:37 <canvon> @type ==
04:18:38 <lambdabot> parse error on input `=='
04:18:41 <canvon> @type (==)
04:18:42 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:19:00 <canvon> Wraithan: as (==) is symmetrical, it's just a matter of style (I guess)
04:19:07 <doserj> it reads more naturally to me (sth is-equal-to ':' vs. ':' is-equal-to sth)
04:19:43 <Wraithan> doserj: makes sense, thank you for the help
04:19:55 <photonen> so Perth is no go unless you really love windsurfing?
04:20:02 <photonen> how much does it rain in sydney?
04:20:20 <ivanm> photonen: *shrug* check bom.org.au
04:21:38 <blackh> Wraithan: That's looking really nice and Haskell-like now. You can drop 'value' from parseACPIValue in two places - which is just a style thing. Also one other thing...
04:22:31 <blackh> Wraithan: putStr changeStatus ; putStr " "... could be written as: putStr $ chargeStatus ++ " " ++ timeLeft
04:23:12 <photonen> ivanm: heh
04:23:19 <vegai> anyone familiar with hslogger?
04:23:25 <blackh> Wraithan: The reason for this is not so much because it's shorter, but because more of the code is pure (i.e. not using the IO monad).  This becomes important if the list of stuff you're outputting gets longer.
04:23:31 <ivanm> vegai: the author presumably would be... ;-)
04:23:34 <vegai> how do I configure it so that the rootLogger catches only those messages that don't have handlers already?
04:23:43 <vegai> Goerzen! :)
04:23:51 <Wraithan> blackh: makes sense, I kinda added them as I thought of them lol
04:24:14 <blackh> Wraithan: Even better would be to take all the putStrs out and make the whole thing pure, then put the putStr into the caller.
04:24:22 <ivanm> vegai: you mean CosmicRay?
04:24:35 <Wraithan> output is mainly just for me, as most of this code will be moved over into a xmobar plugin
04:24:43 <Wraithan> since xmobar's bat state blows.
04:25:01 <vegai> ivanm: oh, that's him? I didn't realize
04:25:08 <ivanm> I think it is...
04:25:19 <blackh> Wraithan: I am really just making a point about "the Haskell way", because Haskell really excels when you do as little in the IO monad as possible.
04:25:36 <blackh> Wraithan: Here's an example:
04:25:45 <Wraithan> I will have to add in all the code for doing the style and what not but I figure I could write this stand alone to learn
04:26:17 <Wraithan> so would I change main to just return?
04:26:23 <Wraithan> or change main to a let in?
04:26:38 <Wraithan> if I were turning it into a pure function
04:27:35 <photonen> OK what about doing games in the browser with Haskell
04:27:38 <photonen> ?
04:28:10 <blackh> Wraithan: Someone asked for suggestions for a game engine, and I said... This program takes events in one end and spits output out the other end. You could make your whole program a lazy mapAccumL, with inputs in one side, state being looped, and output coming out the other end.
04:28:57 <lenni_-_> is tail recursion and accumulative recursion the same thing?
04:29:13 <ivanm> photonen: I don't think so
04:29:23 <ivanm> unless you were to take that partial javascript backend for yhc or something
04:29:48 <Wraithan> Should I avoid using returns and try to make my functions all let .. in?
04:29:49 <blackh> Wraithan: To turn 'output' into a pure function, make it :: Bool -> String -> String -> String
04:30:09 <blackh> Wraithan: Yes - exactly so.
04:30:21 <Wraithan> I was going to turn main into the pure fuction and remove output
04:30:38 <blackh> Wraithan: main is the only one that can't be pure
04:30:42 <Wraithan> as output was just so I wasn't poluting main with formating stuff
04:31:40 <blackh> You can think of your program like this:  >-   two files in one and and some output out the other end. The middle bit can all be pure.
04:32:58 <blackh> There's nothing at all wrong with the way you've done it - I'm just trying to point you in a certain direction in your thinking.
04:33:57 <Wraithan> I appreciate it, truly I would like be a proficient developer using haskell, I find it engauging in a whole different way than my imperative background
04:35:11 <blackh> I am saying that you could think about detaching the file reading part from the parsing part.  You could use types to make it so you can't get it wrong.  This could be over-designing, though.  It's just a thought experiment, but it's a good way to hink of it.
04:36:08 <Wraithan> Plus it seems the haskell developed applications are ones I would enjoy contributing to, I have been a Xmonad user for a while and am discovering more and more software that I would like to play with is written in haskell
04:36:17 <blackh> I came from an imperative background too and I find Haskell absolutely pleasant.
04:37:29 <blackh> I read something recently that I thought explained the 'functional way' really well. It's about PacMan - I'll find it for you.
04:38:44 <Wraithan> I am going to go back to doing the last part of this standalone app, the calculation of battery time left (be it charging or discharging) so if you find it please PM it so I don't just lose it in the channel logs
04:39:30 <Wraithan> The lesson so far is much appreciated, I am glad I came and asked how I could improve this
04:39:38 <blackh> Wraithan: http://prog21.dadgum.com/23.html
04:39:55 <Axman6> well that was fun, just took an assignment i helped someone with from a course i'm not doing, and replaced the yuck [[x]] stuff with Arrays
04:40:27 <Axman6> though it's broken atm, so need to figure that out
04:40:57 <ivanm> Axman6: so you just did s/[[x]]/Arrays/g ? :p
04:41:11 <Axman6> :P
04:41:20 <Axman6> nah, needed a lot of work to get it going
04:42:05 <blackh> Wraithan: I keep thinking about writing some stuff about Haskell style, since there does seem to be a bit of a gap in that area on the wiki.  I am still learning myself, of course.
04:42:08 <Axman6> it's a game of life thing
04:48:25 * Saizan wants a game of life image filter
04:50:15 <mjrosenb> non-cacheing game of life in a functional language is hilariously slow
04:51:12 <Axman6> mjrosenb: this one was hilariously slow, but after getting it to use Arrays it's really fast
04:52:21 <Twey> STArrays?!
04:52:56 <Axman6> nope, just plain arrays
04:53:10 <Axman6> just did 1500+ iterations in 30 seconds
04:53:10 <mjrosenb> Axman6: without cacheing, it'll be even slower
04:53:30 <Twey> Axman6: Immutable?  O.O
04:53:34 <Axman6> yep
04:53:40 <Axman6> Data.Array arrays
04:53:43 <Twey> Wow
04:53:46 <mjrosenb> particularly the fact that the nth step takes 8^n calls
04:53:56 <Axman6> though i think it's using IORefs
04:54:17 <Saizan> you may trigger array fusion
04:54:45 <Saizan> mjrosenb: ah, you mean without using a datastructure for each step at all?
04:54:54 <mjrosenb> Saizan: ja
04:54:59 <mjrosenb> no cacheing
04:55:27 <Saizan> i've never considered that as a  plausible implementation
04:56:11 <mjrosenb> it really isn't
04:56:27 <mjrosenb> it's easy to write
05:00:35 <Axman6> hm, is there a way to find out where an error is being invoked? (in this case, an invalid index in an array error)
05:00:57 <ivanm> Axman6: trace all ! calls?
05:01:41 <Axman6> i'm not even using ! in my program :(
05:03:00 <ivanm> how are you getting the array index then?
05:03:16 <Axman6> no idea, that's the problem
05:03:27 <ivanm> heh
05:03:36 <blackh> Axman6: There is a way, but I haven't tried it. There's a ghc option that will output cost centres. You have to enable profiling.
05:03:37 <ivanm> well, you have to be getting the array values out _somehow_
05:04:14 <Saizan> compile with -prof -auto-all -caf-all and run with -hc -xc
05:04:25 <Axman6> hmm, maybe i am using !
05:04:49 <Axman6> cheers Saizan
05:05:33 <Axman6> Saizan: and then what do i do, the error i'm getting is just <GHC.Arr.CAF>
05:05:49 <Axman6> uh, well, that's not before the error
05:06:43 <Saizan> it should give something similar to a stack trace, only made of cost centers instead
05:07:00 <Axman6> in the .hp file?
05:07:09 <Saizan> no .prof
05:07:35 <Axman6> there is no .prof file
05:07:49 * Axman6 orgot -p
05:07:55 <ivanm> forgot even? :p
05:08:05 * Axman6 forgot the f
05:08:18 <ivanm> Axman6 accidentally the f
05:09:57 * Axman6 does some unsafePerformIO debugging
05:10:16 <ivanm> Axman6: or just use trace...
05:10:27 <Axman6> probably a better idea
05:10:32 <Axman6> @hoogle trace
05:10:32 <lambdabot> Debug.Trace trace :: String -> a -> a
05:10:32 <ivanm> no, really? :p
05:10:33 <lambdabot> module Debug.Trace
05:10:33 <lambdabot> package traced
05:10:37 <ivanm> @src trace
05:10:37 <lambdabot> trace string expr = unsafePerformIO $ do
05:10:37 <lambdabot>     hPutStrLn stderr string
05:10:37 <lambdabot>     return expr
05:10:42 <ivanm> thought so
05:27:24 <ManateeLazyCat> I have a string and it's value is "StringBuffer", and i have type named `StringBuffer`, have a tips that can read string and return type signature? Thanks!
05:27:41 <photonen> yhc?
05:28:53 <ManateeLazyCat> I find some way transform String to Type for operator `::`.
05:28:54 <ivanm> photonen: York Haskell Compiler
05:28:54 <mjrosenb> ManateeLazyCat: what would the type of this function be?
05:28:55 <ivanm> @where yhc
05:28:56 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
05:29:06 <mjrosenb> ManateeLazyCat: moreover, how would you use this?
05:31:39 <ManateeLazyCat> mjrosenb: I use Data.Dynamic do a interface in my modules, i have function "dynTypeString :: Dynamic -> String" can get name of Dynamic. And when i use function `fromDyn` i need Type signature to indicate which type actual use. So i wonder have a way transform `String` to `Type`, then i use `fromDyn ... :: Type`.
05:37:48 <Saizan> ManateeLazyCat: no, it won't work like that
05:38:05 <Saizan> ManateeLazyCat: the type must be known at compile time
05:38:35 <byorgey> ManateeLazyCat: note that you have to pass  fromDyn two arguments, the second is a 'default value' but it also determines the type for the conversion.
05:39:24 <ManateeLazyCat> byorgey: I pass second argument with a error. :)
05:39:31 <ManateeLazyCat> an error
05:40:23 <dmwit> ...which you then dutifully catch, right?
05:40:30 <dmwit> ;-)
05:41:24 <byorgey> ah, I see.
05:44:32 * Axman6 is not happy, he's getting a segmentation fault in his program now :(
05:45:11 <blackh> Axman6: You're not using one of my libraries, are you? :)
05:45:25 <Axman6> did you write the OpenGL bindings?
05:45:41 <blackh> Thankfully, no!
05:45:48 <Axman6> then no :P
05:46:29 <blackh> Does gdb tell you anything useful?
05:46:44 <ManateeLazyCat> I see. Thanks all.
05:47:34 <Axman6> i don't know how to use gdb :\
05:47:41 <photonen> whoever wrote the OpenGL bindings and gtk2hs should have a huge pat on the back for awesome work still
05:48:24 <blackh> Axman6: If it's easy to reproduce, do this: "gdb ./my-program" then (on the next line) "run" put any args after run
05:48:32 <blackh> when it dies, type 'where'
05:49:09 <Axman6> i know where the problem is now anyway
05:50:43 <dcoutts> photonen: hmm, according to the sources it was me :-)
05:50:53 <dcoutts> circa 2005
05:57:06 <photonen> > let manyPats name = zip (repeat 10 "pat") (repeat 10 name) in manyPats "dcoutts"
05:57:07 <lambdabot>   Couldn't match expected type `[Char] -> [a]'
05:57:26 <dcoutts> :-)
05:58:12 <ivanm> > (cycle "pat ") ++ "dcoutts"
05:58:13 <lambdabot>   "pat pat pat pat pat pat pat pat pat pat pat pat pat pat pat pat pat pat pa...
05:58:14 <Workybob> holy shit, the paper SPJ posted about on the mailing list today is made of awesome and win
05:58:25 <ivanm> ;-)
05:58:34 <ivanm> Workybob: which ml?
05:58:44 <ivanm> ghc, or general haskell{,-cafe}?
05:58:50 <Workybob> cafe, Fun with Type Functions
05:58:52 <dmwit> > let manyPats name = zip (replicate 10 "pat") (replicate 10 name) in manyPats  "dcoutts"
05:58:54 <lambdabot>   [("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("...
05:59:02 <ivanm> mustn't have gotten into the digest yet
05:59:09 <dmwit> > let manyPats name = replicate 10 ("pat", name) in manyPats  "dcoutts"
05:59:10 <lambdabot>   [("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("...
05:59:11 <ivanm> photonen: I think you wanted replicate
05:59:12 <blackh> (+1) `fmap` dcoutts
05:59:12 <Workybob> ivanm: http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
05:59:13 <ivanm> not repeat
05:59:19 <photonen> > let manyPats name = zip (repeat 10 "pat") (repeat 10 name) in manyPats "dcoutts"
05:59:19 <photonen> > repeat 1 5
05:59:19 <photonen> > zip (repeat 1 5) (repeat 2 5)
05:59:22 <lambdabot>   Couldn't match expected type `t -> [a]'
05:59:22 <lambdabot>   Couldn't match expected type `[Char] -> [a]'
05:59:22 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
05:59:24 <dmwit> ivanm: One step ahead of you. =)
05:59:26 <ivanm> @type repeat
05:59:27 <lambdabot> forall a. a -> [a]
05:59:30 <ivanm> dmwit: yeah, I noticed
05:59:32 <ivanm> @type replicate
05:59:34 <lambdabot> forall a. Int -> a -> [a]
06:00:43 <photonen> @type repeat
06:00:45 <lambdabot> forall a. a -> [a]
06:01:12 <photonen> > let manyPats name = zip (take 10 $ repeat "pat") (repeat name) in manyPats "dcoutts"
06:01:13 <lambdabot>   [("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("pat","dcoutts"),("...
06:01:26 <ivanm> photonen: take n . repeat == replicate n
06:01:53 <dcoutts> enough pats! I've already got plenty :-)
06:02:43 <photonen> @slap dcoutts
06:02:43 * lambdabot would never hurt dcoutts!
06:02:58 <dcoutts> ;-)
06:03:00 <dmwit> > let manyPats name = unwords . concat . replicate 10 $ ["pat", name] in manyPats "dmwit"
06:03:02 <lambdabot>   "pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat ...
06:03:59 <dmwit> > let manyPats name = unwords . replicate 10 $ "pat " ++ name in manyPats "dmwit"
06:04:01 <lambdabot>   "pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat dmwit pat ...
06:22:33 <chimpmf> hey, anyone know how i can make a function that makes a unique string each time it is called?  I've been told i need to use list comprehensions but it always just returns the first item in the list.  Cheers.
06:24:06 <Workybob> chimpmf: you can't
06:24:10 <Workybob> if you do, it's not a function
06:24:35 <Workybob> what you *can* do is make a function that returns a monadic action which returns a unique string each time it's run
06:25:06 <chimpmf> hrrrm, i had a lot of problems with monadic stuffs
06:25:32 <And[y]> or you try using an accumulator, that saves the elements, your function allready returned ... but then your function would need to be recursive the whole time :D
06:25:33 <chimpmf> can i actual get the raw string out of monadic actions without using it all boxed up in IO and the likes
06:25:44 <Workybob> depends on the monad
06:25:54 <Workybob> you can't get values out of IO (safely)
06:25:59 <Workybob> but you can get values out of ST
06:26:02 <Workybob> which is enough for this
06:26:18 <chimpmf> st = State?
06:26:21 <Workybob> yep
06:26:51 <Workybob> note though, you just can not write a function that returns different values depending on the time you call it
06:26:53 <Axman6> State Transformer
06:26:59 <Axman6> i believe
06:27:07 <Workybob> that's the exact thing that functional programming bans
06:27:08 <Workybob> :D
06:27:15 <chimpmf> what i need it to do is everytime it is called return tX where x is just incremented each time
06:27:17 <chimpmf> aaah
06:27:21 <Axman6> Workybob: well, pure functional programming at least
06:27:22 <chimpmf> that means i cant do that
06:27:39 <Workybob> chimpmf: yep, this is why monads are used to do it in a safe way
06:27:44 <Workybob> however....
06:28:01 <Axman6> chimpmf: in haskell, every time a function is called with a certain input X, it will always return the same output Y
06:28:01 <Workybob> it's more than likely there's a purely functional way to do what you want to do, without involving unique strings
06:28:14 <Workybob> what is it you want unique strings for?
06:28:17 <Axman6> if it has no inputs, then you'll always get the same Y
06:29:16 <chimpmf> i'm making a typer for lambda calculus, so i need a tX for each occurence of a variable and a tX1 -> tX2 for every occurence of a funciton application
06:29:30 <Workybob> ah yep
06:29:36 <Workybob> couple of ways to do that...
06:30:00 <chimpmf> so everytime i meet a new variable it needs to make a new type for it and unify it with the others
06:30:01 <Workybob> 1) pass a supply of unique type names into your function, and around with you at all time
06:30:14 <Workybob> note though, this makes you responsible for making sure you don't use the same state in more than one plac
06:30:15 <Workybob> e
06:30:29 <Workybob> 2) wrap the function in the state monad, and let it handle passing around the unique supply for you
06:31:37 <chimpmf> if i do the first way, if i recurse down two separate ways will it not use the same list down each branch of the tree and then not produce unique integers?
06:31:42 <chimpmf> if i phrased that well enough :s
06:32:30 <Workybob> if you manage the state yourself badly, yes
06:32:36 <Workybob> if you maage the state correctly yourself, no
06:32:38 <Workybob> manage*
06:32:52 <Workybob> you need to return along with your result a new source of unique keys
06:32:57 <Workybob> so you recurse one way with your unique supply
06:32:59 <Workybob> get back a result
06:33:03 <Workybob> paired with a unique supply
06:33:09 <chimpmf> i see
06:33:10 <Workybob> pass the new unique supply into the other function
06:33:21 <Workybob> but... this is *exactly* what the state monad manages for you
06:34:03 <chimpmf> is it easier to wrap a function in a monad with no prior monad experience than it is to do it the first way? or is it better i get the monad experience would you say? :P
06:34:31 <Workybob> it's often an experience to do it the time consuming error prone way first
06:34:39 <Workybob> then you see the pattern that the monad hides
06:34:40 * Axman6 doesn't like the State monad, so would recommend the first...
06:34:51 <Workybob> and can try to write it
06:35:12 <Workybob> I don't like the state monad, when there's a better alternative...
06:35:22 <Axman6> which is?
06:35:28 <Workybob> however... when the alternative is duplicating the code in the state monad lots of times, it's not such a great plan
06:35:37 <Workybob> and that's exactly what option 1) is
06:35:45 <chimpmf> i'll try the first and if all else fails i'll try the state monad i think then
06:35:56 <Workybob> chimpmf: what I would do is first try it passing it around
06:35:59 <Workybob> and then try to reflect
06:36:05 <Workybob> on where all the code duplication is
06:36:10 <chimpmf> righto
06:37:27 <chimpmf> one last question, is it better to pass an infinite list around and keep taking the head or just pass a single integer around and keep adding one to it?
06:37:35 <Workybob> yes
06:37:43 <Axman6> heh
06:37:48 <chimpmf> righto
06:37:51 <Workybob> i.e. with lazyness, they both amount to the same thing
06:37:57 <Axman6> totally depends on what you're doing
06:38:05 <chimpmf> i see
06:38:07 <Workybob> the infinite list thing stores 1 extra cons cell
06:38:15 <Workybob> so you could argue that it's *margionally* less efficient
06:38:17 <Axman6> and a thunk
06:38:23 <Workybob> yep
06:38:40 <Workybob> it is however nice to think of it as an infinite list
06:38:47 <Workybob> so it may be that you prefer the code you get from doing that
06:38:58 <chimpmf> yeah
06:39:03 <chimpmf> well, cheers for the help
06:39:32 <Axman6> using the infinite list will probably save you a little bit of coding, and reduce errors
06:39:33 <chimpmf> hopefully my coding is as good as the explanations i received! :P
06:39:50 <Axman6> since you have less chance of forgetting to do a (n+1)
06:39:53 <chimpmf> yeah, probs why it was recommended to me
06:40:09 <chimpmf> i just didnt see how he wanted me to use i
06:40:10 <chimpmf> t
06:40:15 <Workybob> Axman6: not sure
06:40:28 <Workybob> every n+1 must be replaced with a (tail n)
06:40:30 <Workybob> so *shrug*
06:40:40 <Workybob> well, that or a pattern match
06:41:00 <Axman6> well, you if you patern match, you're less likely to accidently do a (x:xs) on the recursive call
06:41:09 <Workybob> true
06:41:57 <Axman6> me wishes that windows would settle down. his VM has just sucked up 20% of his battery in 10 mins
06:42:06 <Axman6> and... it's settled down
06:42:08 <Workybob> heh
06:43:12 <doserj> ls
06:43:15 <doserj> ups
06:43:24 <Axman6> . ..
06:45:10 <Axman6> wtf? adobe give you the option of installing the google toolbar when you go to the download page with IE (only using IE because steam opened it up)
06:52:23 <roconnor> yay for NaN % loaded
06:52:37 <Axman6> heh
06:52:44 <Axman6> @seen benl23
06:52:45 <lambdabot> benl23 is in #ghc. I last heard benl23 speak 1d 7h 29m 25s ago.
07:06:41 <ManateeLazyCat> I have three type `A`, `B`, `C`, I use "data PageType = TypeA | TypeB | TypeC" for page type. In expression "case pageType of TypeA -> expr :: A; TypeB -> expr :: B; TypeC -> expr :: C', I need do a transform. So have a way make me just write like this "expr :: pageType"?
07:06:55 <gwern> @tell dons as I said the last time you asked me about wash, I found it a bit of a challenge and passed over it
07:06:56 <lambdabot> Consider it noted.
07:08:38 <gwern> what a remarkable amount of spam on the mls today
07:11:58 <byorgey> ManateeLazyCat: how is that case even well-typed?
07:12:39 <byorgey> even if it was, you can't use a value as a type
07:14:05 <Alpounet> @src init
07:14:05 <lambdabot> init [x]    = []
07:14:05 <lambdabot> init (x:xs) = x : init xs
07:14:05 <lambdabot> init []     = undefined
07:14:08 <ManateeLazyCat> byorgey: Yep, i wonder have a way that use a value contain *type*,
07:14:46 <ManateeLazyCat> byorgey: Otherwise i need use value do a `case` or `map`.
07:15:18 <byorgey> ManateeLazyCat: but that case expression you showed above will not even typecheck.
07:15:33 <byorgey> ManateeLazyCat: there is probably a way to do what you want to do, but it's probably very different than what you are doing now.
07:15:41 <byorgey> but without more information it's hard to know how to help.
07:15:55 <byorgey> what is it specifically you are trying to do?
07:17:45 <xDie> hi all
07:17:52 <byorgey> hi there xDie
07:17:58 <xDie> :)
07:18:11 <xDie> any can helpme to join lambdabot to #culturalibredigital
07:19:02 * ManateeLazyCat pasted "data Page" at http://paste2.org/get/209488
07:19:03 <ManateeLazyCat> byorgey: Okay, above link have my `data Page`. I use pageType contain "Page type", i use pageBuffer with Dynamic type. if i do `fromDyn` with pageBuffer, then i need type signature to indicate which type actual used. So i do `case` for pageType, if `pageType` is `TStringBuffer`, then i do "expr :: StringBuffer".
07:20:01 <byorgey> ManateeLazyCat: that won't work to put them in a case statement though.  Why do you need Dynamic?
07:20:40 <byorgey> do you know in advance what page types you will have?
07:20:51 <xDie> lambdabot, @join #culturalibredigital
07:20:51 <lambdabot> Not enough privileges
07:20:55 <ManateeLazyCat> byorgey: Because i Page is interface, i want developer can customize widget that contain in Page.
07:21:40 <byorgey> ManateeLazyCat: that sounds like a job for type classes, not Dynamic.
07:21:57 <ManateeLazyCat> byorgey: Yep, i will add class in Page soon.
07:24:43 <xDie> lambdabot: @join #culturalibredigital
07:24:44 <lambdabot> Not enough privileges
07:26:34 <ManateeLazyCat> byorgey: I need think a bit, which one suit to me (Class vs Dynamic).
07:27:17 <wahjava> hi all
07:27:44 <byorgey> hi wahjava
07:28:34 <wahjava> hi byorgey
07:28:45 <Twey> hi wahjava
07:28:57 <wahjava> i'm having a problem with my haskell program. hi Twey :)
07:30:23 <Twey> One would be given to suspect you might be
07:33:49 <jmcarthur> wahjava, always feel free to just come in and ask a question :)
07:34:52 <wahjava> Thanks jmcarthur . Here is my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4877#a4877
07:35:14 <wahjava> I'll be back in a minute
07:36:21 <Alpounet> @src undefined
07:36:22 <lambdabot> undefined =  error "Prelude.undefined"
07:36:43 <wahjava> any ideas what is wrong with my code.
07:36:49 <jmcarthur> wahjava, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4877#a4878
07:37:02 <jmcarthur> i suspect that should fix the problem at hand
07:37:41 <jmcarthur> wahjava, when you use if/else and intend to continue using a monad with do notation inside it, you must say "do" again
07:37:49 <wahjava> jmcarthur: awesome, thanks :)
07:38:30 * wahjava is just trying to understand state monads :)
07:39:32 <roconnor> @quote MonadState
07:39:33 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
07:40:49 <kyevan> What are ya', some kinda anarchist? :P
07:41:25 <jmcarthur> heh
07:41:34 <jmcarthur> MonadGovernment
07:41:43 <Twey> Hahaha
07:42:32 <Twey> instance Monad Government where return _ = fail "Governments do not return!"
07:42:59 <Botje> but then it violates the monad laws! :P
07:45:20 <kyevan> That sounds like a government all right!
07:45:26 <ManateeLazyCat> byorgey: Branches of `case` statement is `return ()`, "expression :: StringBuffer" just statement in branch.
07:47:20 <ManateeLazyCat> byorgey: I need use `Dynamic` to contain interface object, `type class` just free on *function*. I still need Dynamic to handle my problem.
07:48:02 <byorgey> ManateeLazyCat: well, I don't think I understand the problem you are trying to solve, then.  I would have to see some actual code.
07:48:44 <xDie> Distribution/Simple/Utils.hs:155:43:
07:48:44 <xDie>     Module `System.IO.Error' does not export `ioeSetLocation'
07:48:54 <xDie> whats this error?
07:49:03 <xDie> i try install cabal
07:50:17 <ManateeLazyCat> byorgey: Code running in my head. :)
07:51:32 <byorgey> xDie: what version of ghc do you have installed?
07:51:43 <xDie> 6.6
07:51:59 <xDie> The Glorious Glasgow Haskell Compilation System, version 6.6
07:52:09 <doserj> that explains it
07:52:09 <xDie> is to run lambdabot
07:52:15 <byorgey> hmm, I wonder if that is why.  6.6 is sort of old at this point.
07:52:29 <byorgey> sounds like you have an out-of-date version of System.IO.Error.
07:52:58 <byorgey> xDie: I would recommend upgrading ghc to at least 6.8.3.
07:53:29 <byorgey> xDie: how did you install version 6.6?
07:53:59 <ManateeLazyCat> byorgey: Simple, i have some objects that with different TYPE, and i need Dynamic object to keep *reference* with those objects.
07:54:07 <roconnor> sounds like xDie's cabal package being installed has the wrong dependency information :/
07:54:09 <ManateeLazyCat> byorgey: That's why i need Dynamic.
07:54:31 <roconnor> ManateeLazyCat: or GADTs
07:54:39 <xDie> i try install 6.10.3
07:54:43 <ManateeLazyCat> roconnor: GADTs?
07:54:47 <xDie> is correctly?
07:54:50 <roconnor> @what GADT
07:54:51 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
07:54:56 <ManateeLazyCat> roconnor: MOre details?
07:55:10 <byorgey> ManateeLazyCat: I still don't think you really want Dynamic.  perhaps some existential quantification is what you need.
07:55:39 <byorgey> you can use an existential wrapper to hold a value that belongs to some type class, without knowing its actual type.
07:55:46 <ManateeLazyCat> roconnor:  404 error
07:55:47 <byorgey> then you can still use the methods of the type class on it.
07:56:09 <byorgey> Dynamic is almost never the solution.
07:57:03 <photonen> haskell runs on mac right?
07:57:37 <roconnor> @wiki GADT
07:57:37 <lambdabot> http://www.haskell.org/haskellwiki/GADT
07:57:41 <pejo> photonen, yes.
07:58:27 * ManateeLazyCat Reading GADT 
07:59:27 <roconnor> @where+ GADT http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
07:59:28 <lambdabot> Done.
07:59:32 <roconnor> @where GADT
07:59:32 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
07:59:37 <byorgey> ManateeLazyCat: for example,  data SomeNum = forall a. Num a => SomeNum a  will allow you to store any number without knowing what type it is.
08:00:04 <opqdonut> is that forall necessary there?
08:00:04 <gigamonkey> Anyone here work on GHC?
08:00:11 <jonathanturner> does anyone know of any automatic source tools that can find things like "foldl (+) 0" and suggest you use "sum" instead?
08:00:27 <roconnor> still, usually you don't need to go as far as GADTs.  Either works well in many situations
08:00:32 <opqdonut> jonathanturner: or "foldl' (+) 0" ;)
08:00:36 <pejo> gigamonkey, they're in #ghc.
08:00:42 <gigamonkey> pejo: thanks
08:02:06 <jonathanturner> opqdonut: Yes, or that :)  Some kind of code detection and reduction tool
08:02:16 <ManateeLazyCat> roconnor: byorgey : Are you say same thing?
08:02:57 <byorgey> well, GADTs allow existential quantification, which I presume is why roconnor suggested them
08:03:21 <byorgey> so in a way, yes.
08:04:32 <ManateeLazyCat> byorgey: Thanks, i will look-into GADTs. Maybe i need change my design if GADTs is a better solution.
08:04:35 <roconnor> ya, but GADTs also allow potentially more refined control than simply existential quantification.
08:04:46 <roconnor> still, I'd try Either first.
08:04:57 <byorgey> agreed.
08:05:00 <byorgey> opqdonut: yes, the forall is necessary, otherwise it will complain that 'a' is not in scope
08:06:00 <byorgey> opqdonut: it's not necessary in a GADT declaration though
08:06:53 <ManateeLazyCat> Thanks all. :)
08:08:40 <kyevan> I had a haskell-related dream last night. Sorta.
08:09:02 <kyevan> I was beaten up by some kids because I tried to go somewhere my type didn't match, apparently.
08:09:05 <kyevan> >_<
08:09:18 <photonen> so
08:09:44 <photonen> is there a video of Wadler saying "monads are monoids in the category of endofunctors"
08:11:35 <byorgey> kyevan: hahaha
08:11:47 <opqdonut> byorgey: oks
08:12:13 <byorgey> @remember kyevan I had a haskell-related dream last night. Sorta. I was beaten up by some kids because I tried to go somewhere my type didn't match, apparently.
08:12:13 <lambdabot> Done.
08:12:54 <photonen> lol
08:17:23 <opqdonut> @quote dream
08:17:23 <lambdabot> dons says: i had a dream about it last night, where i was running kde and gnome together, and had no room on my screen for xterms
08:17:27 <gwern> @quote endofunctor
08:17:28 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
08:17:29 <Baughn_> kyevan: There are worse variants. I once dreamt that the universe ran on lazy evaluation, and what happened on the insides of black holes was simply undefined.. which we found out when we tried to open one
08:17:37 <gwern> @quote endofunctor
08:17:38 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
08:17:40 <Baughn_> kyevan: Never mind the /other/ implications of lazy evaluation
08:17:52 <gwern> Baughn_: solipsism for one
08:18:04 <Baughn_> gwern: How do you get that?
08:18:14 <kyevan> Heh.
08:18:18 <gwern> it only is calculated/exists when we look?
08:18:22 <gwern> also, we could then run DOS attacks on the substrate
08:18:29 <Baughn_> gwern: Yeah, but at the quantum-mechanical level
08:18:44 <gwern> don't think we could do timing or side-channel attacks if everything is referentially transparent though...
08:18:56 <Baughn_> gwern: In practice, it depends on practically everything within our past light cone, which keeps at least everyone on earth pretty well synchronized
08:19:13 <Baughn_> Might cause issues for interstellar colonies, though
08:19:35 <gwern> we could send off von neumann probes at fractional c
08:19:52 <Baughn_> We could
08:19:55 <gwern> then the simulators couldn't cheat by simulating or approximating only part of our light cone
08:19:58 <Baughn_> The thing is, of course, we'd never notice any difference
08:20:10 * gwern realizes that such probes technically wouldn't expand our light cone
08:20:19 <Baughn_> If the Observer ever stopped depending on my state, I'd simply.. stop
08:20:33 <Baughn_> If he ever started depending on it again, I'd never notice the difference
08:21:14 <Baughn_> gwern: No, lazy evaluation is weird, but so long as the laws of physics are otherwise calculated /exactly/ it makes little difference
08:21:24 <Baughn_> Now, if they're actually fudged.. well, then we have problems
08:22:18 <gwern> well, as far as I can see, by sending off probes, we force the evaluation of ever larger regions of space; even if past states are being GCed immediately, we can continue to push up memory usage
08:22:30 <gwern> which gives us information about the computing constraints of the substrate
08:22:40 <Baughn_> Umh
08:22:53 <Baughn_> I'm not sure if "forces the universe to crash" is a good way to gain information about it
08:23:05 <Baughn_> Or did you have something else in mind?
08:23:11 <gwern> (old idea of mine. anthropic probing of the simulator - as long as we're still 'alive', we know the substrate has more computing power than we've used up)
08:23:25 <Baughn_> ...right. Don't sign me up.
08:23:37 <Twey> gwern: But how do we know that the simulation hasn't been temporarily halted while they add more memory?
08:23:52 <gwern> Twey: I speak of their unvierse
08:24:00 <gwern> how would they add more ram to their universe?
08:24:19 <Baughn_> gwern: I consider it likely that, if we're simulated, the simulators run on different laws of physics that support arbitrarily high speeds and memory use
08:24:41 <gwern> obviously if the simulators are nice enough to let some of us out, we don't need such dangerous approachs; but this would work regardless of what the simulators do
08:24:57 <Baughn_> How would it "work"? What would it /do/?
08:25:01 <Baughn_> Other than kill us all
08:25:11 <gwern> Baughn_: why would you think that? the laws of this universe permit extremely large computations
08:25:12 <Apocalisp> You people need girlfriends.
08:25:18 <gwern> certainly sufficient to simulate us
08:25:33 <jmcarthur> speeds don't matter. we wouldn't notice
08:25:52 <Gilly> I'm trying to use Takusen to connect to the mysql server running on localhost but I'm not sure what to put to the connection string. Anyone?
08:25:53 <Twey> Chap has a point
08:25:56 <jmcarthur> our simulating machine could be running at like 1 Hz (if such terminology were to apply at all)
08:25:57 <inimino> "how would they add more ram to their universe?" by submitting a support ticket to the next higher level of simulation, of course
08:26:06 * Twey grins.
08:26:07 <Baughn_> gwern: Because I consider it probably that some universes do have such laws, and such universes could support many more simulations than the more finite ones
08:26:27 <gwern> Baughn_: as I said, it sets lower bounds on the space-time resources available to our simulator. if their actual resources are infinite, well, the lower bound is still respected!
08:26:36 <Botje> fun?
08:26:39 <Botje> oops
08:26:45 <Botje> pesky keyboards
08:26:55 <gwern> jmcarthur: space-time tradeoff. they'd still need lots of space to store us
08:26:58 <Baughn_> Botje: Yes, we enjoy talking about the imminent end of everything, as arranged by gwern
08:27:09 <jmcarthur> gwern, yes, but the speed thing does relax the constraints a bit
08:27:20 <gwern> Baughn_: give me props - I'll bet you've never heard such an original apocalypse!
08:27:30 <Botje> didn't mean to say anything -- finger slipped
08:27:36 <Botje> carry on, gentlemen
08:27:36 <Baughn_> gwern: Sorry, it's a pretty common case. :P
08:27:43 <Baughn_> gwern: Only normally you don't do it /deliberately/
08:27:56 <gwern> wait what. who's suggested this apocalypse before?
08:28:07 <Baughn_> jmcarthur: The computation needs to finish during the length the outer universe exists. Of course, it might be infinite in time, in which case your point is fine
08:28:09 <jmcarthur> of course, "space" is a constraint from our universe. what if there is no notion of "space" in our implementation details?
08:28:14 <Twey> It's an Apocalisp
08:28:18 <Twey> Ended with a close-paren, &c.
08:28:18 <Baughn_> gwern: The original paper on the simulation argument, for one
08:28:31 <gwern> bostrom really suggested that?
08:28:36 <Baughn_> Yep
08:28:49 <jmcarthur> time could be made up as well. there could be no such thing as simulation "speed" either
08:28:54 * gwern goes to check
08:28:58 <Baughn_> gwern: Well, to be specific he suggested that, as our civilization grows, it might eventually become impossible to simulate
08:29:16 <Baughn_> gwern: I don't recall if that was in the original paper - there were a few such scenarios there - or something he said later
08:29:23 <jmcarthur> if we could reason effectively about our simulation, does that violate godel?
08:29:29 <Baughn_> jmcarthur: No
08:29:42 <jmcarthur> i admit i do not yet fully understand it
08:29:55 <Baughn_> jmcarthur: Goedel only states that you can't gain /full/ knowledge of any mathematical system from inside it
08:29:59 <inimino> gwern: it actually seems to come up pretty early in most simulated-universe discussions, along with jokes about BSOD, etc
08:30:06 <Baughn_> jmcarthur: Limited knowledge is fine
08:30:08 <jmcarthur> Baughn_, ah, i misworded my question
08:30:13 <jmcarthur> i meant full knowledge
08:30:15 <roconnor> BMeph: apperently therning has some comments now.
08:30:22 <Baughn_> jmcarthur: Anyway, goedel's theorem applies equally to a real universe and a simulation
08:30:31 <jmcarthur> right
08:30:39 <roconnor> BMeph: nice point about how darcs uses the type system.
08:30:56 <jmcarthur> but we will never be able to 100% accurately simulate a universe identical to our own, for example
08:30:57 <gwern> inimino: jokes maybe, but I haven't seen anyone else take it seriously
08:31:01 <jmcarthur> ?
08:31:18 <roconnor> BMeph: although they dynamicists will aways simply say "more tests" solves everything
08:31:28 <Baughn_> gwern: http://pixelscapes.com/unrealestate/ <-- Halfway unrelated, but here's a story that, if not literally set in a simulated universe, might as well be
08:31:38 <gwern> jmcarthur: also, no one has shown that our universe actually is consistent and incomplete (whatever that would mean); could be inconsistent!
08:31:40 <Baughn_> gwern: Simulated universes for living in, as maintained by Microsoft.
08:32:18 <jmcarthur> roconnor, i'd love to see their tests find a case which fails for input that is exactly pi rounded to 10^100000 digits
08:32:19 <Baughn_> jmcarthur: There are reasons to think we might eventually hit on the exact laws of physics our universe runs on
08:32:33 <Baughn_> jmcarthur: Assuming those laws are in fact finite, anyway, which seems probable right now
08:32:53 <Baughn_> jmcarthur: You could never be /sure/ they're right, of course, but that goes for everything
08:33:01 <gwern> Baughn_: bostrom seems to consider it only in the context of the doomsday argument
08:33:04 <gwern> '                     (One consideration that counts against the multi-level hypothesis is
08:33:07 <gwern> that the computational cost for the basement-level simulators would be very great.
08:33:12 <gwern> Simulating even a single posthuman civilization might be prohibitively expensive. If so,
08:33:14 <gwern>                                                                                         9
08:33:18 <gwern> then we should expect our simulation to be terminated when we are about to become
08:33:21 <gwern> posthuman.)
08:33:23 <gwern> which makes sense; he's been working on the doomsday argument since he was a grad student
08:33:35 <roconnor> jmcarthur: what do you mean?
08:33:48 * mmorrow mutters about mine-shaft gaps
08:33:49 <Baughn_> gwern: That's what I was remembering, then. Well, at least he did write about it. ;)
08:34:08 * Baughn_ wonders if Unreal Estate will ever actually be finished
08:34:21 <jmcarthur> roconnor, "more tests solves everything" -- my response: "if you can find exactly the right tests", essentially
08:35:00 <jmcarthur> the implication being that the only way to find exactly the right tests is to come up with proofs anyway, whether they are only done mentally or not
08:35:37 <jmcarthur> and of course, types are proofs!
08:36:09 <gwern> reminds me of quine - popper's falsified predictions don't disprove theories, as they could result from a lack of data
08:36:43 <mmorrow> , ap(++)show"ap(++)show"
08:36:46 <lunabot>  "ap(++)show\"ap(++)show\""
08:37:16 <mmorrow> (nice phrasing of this pattern by ddarius)
08:37:33 <jmcarthur> , (++)<*>show"(++)<*>show"
08:37:34 <lunabot>  luna: Couldn't match expected type `[a] -> [a]'
08:37:53 <mmorrow> (\x -> apply x (quote x)) (quote (\x -> apply x (quote x)))
08:38:03 <jmcarthur> oh
08:38:20 <jmcarthur> i parsed it wrong, mentally
08:38:29 <mmorrow> what exactly "apply" and "quote" mean vary depending on the types
08:38:43 <mmorrow> the one with strings is slightly odd
08:38:46 <jmcarthur> hmm
08:39:11 <jmcarthur> @pl (\x -> apply x (quote x)) (quote (\x -> apply x (quote x)))
08:39:11 <lambdabot> ap apply quote (quote (ap apply quote))
08:39:14 <mmorrow> (apply:=function app)(quote:=show)
08:39:36 <mmorrow> http://moonpatio.com/repos/MISC/q.hs
08:39:44 <mmorrow> has a TH and a Dynamic one
08:39:54 <jmcarthur> nice
08:40:31 <jmcarthur> would be cool if the quoted part was an AST
08:40:46 <mmorrow> ooh, it is :)
08:40:47 <jmcarthur> i would then be tempted to try to write a self-reproducing, evolving program
08:41:12 <mmorrow> , [|\x->x|]
08:41:15 <lunabot>  LamE [VarP x_0] (VarE x_0)
08:41:21 <jmcarthur> oh, TH, i missed that
08:41:40 <mmorrow> arg, that TH one is ugly, i have a cleaner phrasing somewhere
08:41:44 * mmorrow finds it
08:44:01 <mmorrow> (just found the js version, still looking for the cleaner TH)
08:44:04 <mmorrow>  a = (function(x){return("eval("+x+")("+x+")")})(function(x){return("eval("+x+")("+x+")")}); a == eval(a)
08:44:09 <mmorrow> true
08:45:38 * mmorrow gives up, tries to reproduce it
08:46:23 <Taggnostr> what are you doing?
08:56:08 <photonen> wow, how does eclipse use 120MB ram?
08:56:08 <photonen> how much doesleksah use?
08:57:24 <Nafai> photonen: 120MB of RAM isn't much for Eclipse usage.
08:57:49 <photonen> you mean it often uses MORE?
08:57:54 <Nafai> Oh yeah
08:58:03 <photonen> its a goddamn abortion of software
08:58:28 <p_l> photonen: >1G is common for Eclipse
09:00:18 <photonen> wtf lol, 1GB? like omg srsly
09:00:31 <photonen> it is a goddamn IDE, not FARCRY 5
09:01:22 <pozic> photonen: if you have enough memory, who cares?
09:01:35 <Baughn_> pozic: And if you /don't/?
09:01:43 <Baughn_> I've only got 4GB, and I need every bit for ICC
09:02:06 <pozic> Baughn_: 4GB to compile some source files?
09:02:23 <gwern> don't laugh. it takes that much to compile gitit
09:02:23 <Baughn_> pozic: Firefox, with -ipo. And.. no, actually, it's up to 13GB now
09:02:29 <gwern> and that's just a wiki
09:02:36 <photonen> ihave 1 GB of ram
09:02:38 <Baughn_> ICC is a bit of a pig
09:02:47 <photonen> firefox+eclipse+android emulator eats up half of that
09:02:54 <photonen> terrible
09:02:56 <pozic> Baughn_: Ok, I have "only" 4GB. ;)
09:03:01 <photonen> is that what we are heading towards?
09:03:07 <photonen> just waste memory?
09:03:16 <gwern> cheaper than programmers
09:03:34 <Baughn_> pozic: Mm. I had to go buy more memory.. well, at least I've got a good reason to have my server kitted out with 32GB now
09:03:36 <pettter> photonen: cheaper than cycles, at times also
09:04:01 <photonen> whats sandard memory these days on a laptop?
09:04:12 <pozic> Baughn_: what is with -ipo? Some profiling option?
09:04:19 <gwern> >1g, last I looked
09:04:27 <gwern> >=, I should say
09:04:28 <Baughn_> pozic: Inter-file optimizations, some of the same stuff GHC does
09:04:35 <Baughn_> pozic: Well, but more so
09:04:48 <Baughn_> It basically needs to compile everything at the same time
09:05:05 <Baughn_> Considering that FF is pretty big.. yeah.
09:05:19 <pozic> It is a market. When there is a program doing the same with less memory, people will switch.
09:05:35 <pozic> It's pointless to argue about it.
09:05:41 <Baughn_> photonen: Eh. 1GB for firefox, another for misc. other programs (like X, xmonad, emacs, etc.), two more for disk cache
09:05:56 <Baughn_> photonen: ..you really, really want as much memory as will fit in your laptop; the HD is slow. Unless it's SSD.
09:07:11 <gwern> pozic: yeah, but in a sense there aren't replacements. how many browsers do the same things as firefox?
09:07:32 <gwern> (even if they are comparable in raw features, they're still not substitutable for each other)
09:07:53 <Baughn_> For FF, they're /working on it/. They've been working on it for years, but memory use has been getting better, not worse
09:07:54 <gwern> not a very free market
09:08:25 <Jedai> photonen: I would say that standard memory on a normal laptop is >= 2Go, you can still find 1Go on mini-laptop
09:08:27 <wraithan1> I made the switch to chrome on my main computer and love it
09:08:54 <pozic> gwern: about 5/6?
09:09:18 <pozic> gwern: it depends on how you count of course.
09:09:24 <gwern> pozic: really? chrome will run my favorite firefox plugins/has just as good plugins
09:09:26 <Baughn_> wraithan: I don't think I could live without adblock+, though
09:09:27 <gwern> that is what I mean
09:09:37 <Jedai> pozic: I think the problem is the plugins
09:09:39 <Wraithan> Baughn_: Depends on the sites you use
09:09:50 <Baughn_> Wraithan: All of them?
09:09:58 <Wraithan> Most of my internet usage is seen through Google Reader
09:10:19 <Baughn_> I keep browsing random sites. I really, /really/ need adblock+ or I'd go insane
09:10:41 <Baughn_> ..my other personality insists on saying "insaner", but he's crazy
09:10:58 * p_l is forced to keep track of stuff on some "social" networks. AdBlock+NoScript is a big relief...
09:11:00 <Wraithan> Granted I do keep FF Beta with AB+ installed, for some sites where chrome doesn't cut it
09:11:11 <Wraithan> p_l: use an agregator :D
09:11:22 <p_l> Wraithan: Aggregators don't work on "social" networks
09:11:25 <Wraithan> There is a couple for the social networking sites I have read about on LifeHacker
09:11:42 <pozic> gwern: I agree that plugins are important; I don't switch away from Firefox because of them, but that doesn't mean that whenever some competitor provides the same in an easy way, I won't switch.
09:11:43 <Baughn_> Wraithan: I will say one thing. Firefox gets quite snappy if you compile it with PGO. ;)
09:11:49 <Wraithan> I wouldn't know personally, I don
09:11:53 <Wraithan> 't use them.
09:11:54 <p_l> Wraithan: I'm pretty sure the ones I need AdBlock for forbid such stuff :P
09:12:21 <Wraithan> facebook/myspace/twitter are the major players and those are the ones that have been agregator
09:12:26 <Wraithan> agregated*
09:12:48 <Wraithan> Let me search my reader for the article I am thinking of
09:15:05 <Jedai> Baughn_: PGO ?
09:15:09 <Wraithan> http://lifehacker.com/5234590/how-to-filter-and-manage-your-online-social-life
09:15:16 <Wraithan> p_l: ^^
09:15:28 <Baughn_> Jedai: Profile-guided optimization
09:15:29 <dolio> > exp 4
09:15:31 <lambdabot>   54.598150033144236
09:15:36 <p_l> Wraithan: I'm pretty sure LifeHacker doesn't have anything on the ones that I have to deal :D
09:16:31 <Wraithan> Baughn_: If I used firefox more often it would be worth compiling it, but since I don't and I am not setup to crosscompile it for my laptop (my laptop has a wussy processor/ram setup) chrome is the way to go for me
09:17:04 * p_l deleted chrome yesterday for being slower&buggier than Firefox (which is something)
09:17:22 <Baughn_> Wraithan: I should also mention, chrome isn't really an option for me since I'm on linux
09:17:31 <Wraithan> p_l: were you running beta or live of chrome and firefox?
09:18:10 <p_l> 64bit FF 3.1b3-pgo, 32bit CxChromium
09:18:33 <Baughn_> p_l: YOu probably shouldn't complain that a beta is buggy or slow
09:18:38 <p_l> :P
09:19:04 <p_l> CxChromium is Chrome compiled with winelibs... not good idea
09:21:00 <mmorrow> jmcarthur: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2421#a2421
09:21:58 <mmorrow> (\x -> [|$x (return $(lift =<< x))|]) [|(\x -> x |$<| (lift =<< x))|]
09:22:03 <p_l> well, 3.1b3 with pgo and JIT JavaScript is quite fast
09:22:41 <Baughn_> But crashy?
09:22:58 <p_l> Not really
09:23:06 <Baughn_> Please define
09:23:17 <p_l> Crashes only when I close it or invoke :restart
09:23:29 <p_l> and then not always (something about saving state)
09:24:10 <Baughn_> And hang on, 3.1 or 3.5 beta?
09:24:22 <Baughn_> The one I found seems to be 3.5b4
09:24:25 <p_l> 3.1b3 - just before renaming to 3.5
09:24:52 <p_l> Baughn_: Did you manage to do a PGO build of FF3.5 with JIT JS?
09:25:33 <Baughn_> p_l: I haven't tried. Yet. Will, now.
09:25:43 <Baughn_> p_l: Just as soon as I figure out where to download it
09:25:49 <mmorrow> jmcarthur: silly me, this is better:
09:25:52 <mmorrow> let q = (\x -> x |$<| (lift =<< x)) [|(\x -> x |$<| (lift =<< x))|]
09:25:59 <p_l> I always got segfaults the instant I try run profiling code during build
09:26:08 <mmorrow> which follows the pattern "to a t"
09:26:11 <Baughn_> Building with gcc?
09:26:20 <Wraithan> how long you think it would take to build firefox on a 1.4ghz processor with 512mb ram heh
09:26:22 <p_l> Baughn_: GCC4.4 (4.3 was mentioned not to work)
09:26:33 <Baughn_> p_l: The gcc PGO code is apparently iffy. ICC's has seen a lot more testing, and FF does build with ICC
09:26:51 <Baughn_> p_l: ..well, with a few small patches
09:26:58 <p_l> hmmm.... maybe I should get ICC then
09:27:12 <p_l> I do have an intel cpu now
09:27:26 <Baughn_> p_l: http://brage.info/~svein/mozilla-icc.tgz here's a patch and build script for FF 3.0.10
09:27:42 <Baughn_> p_l: Later versions should only make it easier; some of the patch was backported from HEAD
09:28:20 <photonen> is there any time you really need inheritance? i think sometimes i need inheritance then i realize inheritance is the dumb ay of doing it even though at first i had a hard time pcitruing doing it without it.
09:28:48 <Baughn_> photonen: It's very convenient for, mostly, UI code
09:29:07 <Baughn_> But I may be saying that simply because all the UI toolkits I've seen are written with OO in mind
09:32:39 <Baughn_> photonen: You may want to look closely at the inheritance model in CLOS now, which, IMO, gets it right.
09:36:35 <photonen> Baughn: yeah all GUIs and UIs use inheritance, and I find a lot of them awkward
09:36:59 <photonen> but then on the other side they are all written by people with lots of more experience than me
09:37:07 <p_l> Borlands GUI toolkit was quite good, IMHO
09:37:44 <Nafai> p_l: OWL?
09:38:00 <p_l> Nafai: later one, Vsomething
09:38:10 <p_l> the one that shipped with Delphi
09:38:22 <Nafai> Oh yeah
09:38:24 <p_l> I recall it having a different name
09:38:29 <Nafai> VCL
09:38:35 <jmcarthur> mmorrow, very nice
09:38:38 <Nafai> Visual Component Library, IIRC
09:38:46 <Nafai> I've used both, the first GUI stuff I ever dealt with
09:39:06 <p_l> yeah, me too
09:39:21 <p_l> When I have to deal with Swing I long for the days spent with VCL
09:40:38 <Nafai> Yeah. :(
09:40:47 <Nafai> I used to do Swing custom component development full time
09:55:41 <photonen> anyone know RGB of brown and dark green?
09:57:09 <kpreid> photonen: brown is dark yellow
09:57:16 <kpreid> or perhaps with more red
09:57:24 <kpreid> you can work it out
09:57:28 <Twey> Brown is twice as much red as green
09:57:39 <Twey> Dark green is... well, green, but not much of it
09:57:43 <Gracenotes> photonen: you might find these useful. http://en.wikipedia.org/wiki/Template:Shades_of_brown and http://en.wikipedia.org/wiki/Template:Shades_of_green
09:57:58 <Twey> Maybe #603000 and #003000 respectively
09:58:35 <Twey> Vary them for different shades, of course.
09:58:56 <Gracenotes> photonen: or just http://en.wikipedia.org/wiki/Web_colors#X11_color_names
09:59:45 <Twey> â€˜Brownâ€™ is pink
09:59:55 <Twey> Rose if you're feeling generous
10:00:22 <Gracenotes> always :D
10:00:26 <Gracenotes> o wat.
10:02:05 <jmcarthur> i wish darcs could store patches you do not currently want applied but may wish to apply later
10:02:30 <jmcarthur> it would be very convenient
10:02:39 <Baughn_> You're supposed to use branching for that
10:02:55 <jmcarthur> branching only makes sense if you want snapshotting
10:03:00 <jmcarthur> that isn't what darcs is about
10:03:45 <equanimity> Cale, glguy: Thanks for the heads up on the DCC SEND exploit. Can I ask how you came to that conclusion? FWIW I'm not behind a consumer router
10:03:53 <jmcarthur> my idea is that adding that feature would make a very handy gui possible. a representation of a DAG of all the patches, connected by dependencies. each one can be toggled off or on to represent which ones should be applied
10:04:25 <jmcarthur> and toggling one with dependencies toggles its dependencies appropriately, of course
10:05:36 <glguy> equanimity, there are a number of flaws including consumer routers, anti-virus, and more that enable users to knock you off IRC with DCC messages
10:05:53 <glguy> equanimity, even some IRC clients simply mishandle the messages
10:07:05 <lament> so i'm trying to profile my program, and it turns out the slowest/most allocating function is this one:
10:07:10 <lament> myPoints (bplus, bminus) = filter (\n -> bplus `unsafeAt` n > 0) [0..23]
10:07:22 <lament> where bplus is an unboxed array of ints
10:09:13 <jmcarthur> so it gets the indices of all values greater than 0?
10:09:32 <glguy> lament, what are you doing with the result?
10:10:55 <lament> check if playing that point is a legal move
10:11:27 <equanimity> glguy: Okay. It could well be something our uni is doing then. I should have gotten a little further up to speed before questioning
10:11:50 <lament> jmcarthur: yes
10:12:24 <glguy> equanimity, this is the best link I know of https://help.ubuntu.com/community/FixDCCExploit
10:13:26 <lament> heh
10:14:01 <lament> i removed an INLINE pragma from myPoints and now it's faster and smaller
10:14:07 <cypher-> hmm.. what are your thoughts about this summer school in appled fp at utrecht that haskell.org links to? Are such events worth attending?
10:14:45 * EvilTerran waves to equanimity
10:15:43 <lament> (but it's still unacceptably slow... i will need to cache this somehow instead)
10:15:57 <equanimity> Hi EvilTerran :-) There's a message waiting for you in #cs-cabal
10:19:11 <bos31337> @seen dons
10:19:11 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10h 24m 56s ago.
10:19:32 <bos> @seen dcoutts_
10:19:32 <lambdabot> dcoutts_ is in #gentoo-haskell, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
10:19:41 <bos> @seen dcoutts
10:19:41 <lambdabot> dcoutts is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 29m 38s ago.
10:19:48 <dcoutts> hia bos
10:20:05 <bos> dcoutts: hi there. what do you guys do to track bugs and issues in bytestring?
10:20:11 <bos> do you have a trac instance for it?
10:20:28 <dcoutts> bos: I don't think we have one, no, just email.
10:20:32 <dcoutts> bos: what is it?
10:20:33 <bos> no bugs :-)
10:20:38 <dcoutts> well quite :-)
10:20:50 <bos> dcoutts: if you had a trac instance, i was going to ask who you'd asked to set it up
10:21:05 <bos> but i'll ask ross.
10:21:11 <dcoutts> bos: you mean you want one?
10:21:18 <dcoutts> bos: we offer them on the community server
10:21:19 <bos> i want one for text.
10:21:42 <bos> since i now have two outstanding bugs against it, and will within the next month or so have time to actually do something about them.
10:22:12 <dcoutts> bos: you can do it yourself! http://community.haskell.org/admin/using_project.html
10:22:21 <Igloo> There ought to be a bytestring one too
10:22:31 <bos> ooh!
10:23:24 <bos> automated administration ftw!
10:23:29 <bos> thanks, dcoutts!
10:24:56 <dcoutts> bos: btw, on the HP issue you raised about trying to flesh out the functionality, yes that's a goal, but it's not something we need to make policy about now, which is why we didn't raise it
10:25:11 <bos> dcoutts: fair enough
10:25:17 <dcoutts> bos: though it's not something we can mandate either :-) "go forth and make better XML libs"
10:25:17 <iago> someone experiments strange things with history in ghci?
10:25:38 <iago> I press UP and start to see entries that I never type ;P
10:25:44 <dcoutts> bos: we can certainly identify missing pieces
10:26:05 <dcoutts> bos: the tricky issue is how quickly we try to add new stuff, what quality bar we hold up
10:26:19 <iago> well ok, nothing :P
10:26:24 <bos> dcoutts: i wouldn't be in a big rush except when there are obvious candidates
10:27:09 <dcoutts> bos: me too, rather than saying "but 30 packages us it! it must go in!"
10:27:12 <dcoutts> us/use
10:27:23 <dcoutts> we should ask if it's good quality
10:27:29 <bos> because any "sorta kinda good enough" library that gets into the platform is going to act as an obstacle to the development of potentially much better alternatives
10:27:34 <dcoutts> right
10:27:35 <bos> yes, good quality is key
10:27:39 <dcoutts> eg utf8-string
10:27:49 <dcoutts> it's a fine band-aid
10:27:57 <bos> right.
10:28:20 <dcoutts> but we know the solution looks more like fixing/extending H98 IO and using Text
10:28:27 <bos> right.
10:30:10 <mmorrow> what's that construction with switch+goto called? something like <someone's-name>-<machine/?>..
10:30:27 * bos has the lazy chunked text code mostly written, but packing a stream into a chunked text representation is painfully unfun.
10:31:01 <dcoutts> bos: heh, yes, it was hard for lazy bytestring and the encoding will not make it easier :-)
10:31:25 <bos> mmorrow: you're thinking of duff's device?
10:31:46 <bos> i've had it in the back of my mind to write a duff's device implementation in haskell for a while.
10:32:13 <mmorrow> bos: nice, that's it exactly, thanks
10:32:18 <bos> a friend was telling me that tom duff was reading RWH recently :-)
10:32:21 <cypher-> duff's device in haskell? can't quite imagine it
10:32:34 <mmorrow> bos: heh, sweet
10:33:04 <edwardk> bos: doesn't he work with dan piponi?
10:33:33 <bos> edwardk: no. he's at pixar; sigfpe is at ILM.
10:33:36 <edwardk> i wound up using an inverted duff's device for my javascript compiler
10:34:05 <edwardk> bos: ah, must have been another one of my former graphics scene buddys that mentioned working with him
10:34:46 <c_wraith> Does duff's device even yield a significant speedup on modern compilers/processors?
10:34:54 <edwardk> basically duff's device only works if you have c's horribly program switch statement, but if you turn it inside out it gives you 'goto' in any language with switch and while =)
10:35:03 <procyon112> Muhahaha... I am 5 feet from Tony Hoare at the moment!
10:35:45 <wli> I believe Duff's device was something else.
10:35:53 <mmorrow> c_wraith: i'm looking for it to remind myself what it does, since i'm generating C switch statements and related
10:35:55 <edwardk> c_wraith: for javascript the inverted version is useful as a control flow optimization. i.e. if you want to replace all of the control structures with one while loop and a case dealing with state
10:36:15 <edwardk> wli: hence why i said turning it inside out, not a switch around a while with cases spread throughout, but a while around a switch
10:36:22 <c_wraith> Oh, I'm not questioning the usefulness of the inverted version, edwardk.  That does sound like a useful control-flow technique.
10:36:38 <edwardk> the latter is implementable in basically any language with case and iteration/recursion
10:37:06 <SamB> I think duff's ordinary device can probably help sometimes too ...
10:37:16 <edwardk> c_wraith: the main use in javascript is that lexical closures tend to have access costs proportional to the distance between your closure and the definition site.
10:37:18 <c_wraith> mmorrow: I'm pretty sure it's just syntactically clever loop unrolling.
10:37:23 <SamB> though maybe better if you use a seperate copy of the body for each case ...
10:37:33 <edwardk> duff's device is hard to get a speed win out of nowadays because it breaks so many compiler flow analyses
10:38:05 <SamB> edwardk: yeah
10:38:35 <edwardk> its like how you can use computed gotos for threaded interpreters, but not much else, duff's device is still only competitive if you lack an aggressive unroller in your compiler.
10:40:15 <mmorrow> c_wraith: yeah, i just realized it's not what i thought it was. in particluar, i'm looking to embed labels into a (massive in length and nesting) generated switch statement so, and then stick gotos at the leaves to build static lookup (for char*) and possibly decoding (bytecode)
10:40:22 <inimino> you can also get goto in JavaScript with labelled blocks and breaks
10:40:27 <c_wraith> edwardk: Would you say that the inverted version you mentioned is essentially just converting the entire program into an explicit state machine?
10:41:12 <edwardk> c_wraith: basically, its just an implementation of the fact that you can convert any program with nested loops into a program with a single loop with more cases.
10:41:33 <edwardk> i do call the starting point a 'state' though so, in essence yeah =)
10:42:13 <edwardk> the main use for me is that if you CPS with those instead of just doing a pure CPS transform on your code you can get some huge wins in javascript in terms of asymptotics
10:42:26 <mmorrow> on that topic, does anyone know a nice _concise_ explanation of how exactly lex/yacc work? ie a super-brief-but-complete overview of NFA/(N?)DFA stuff
10:43:01 <edwardk> CPS transforming javascript breaks your asymptotics because the distance to the variable through lexical scope chains matters, but if you cps transform and transform each functon body into an inverted duff's device separately  you use 3 function calls instead of 2 per continuation in exchange for a fixed
10:43:13 <edwardk> distance to the environment, which fixes your asymptotics
10:43:36 <mmorrow> ooh, yeah computed gotos in C rule
10:44:19 <edwardk> mmorrow: one sec. lemme pull up something on thompson style nfas work. that will describe lex at least, yacc is a different beast though
10:44:30 <mmorrow> great, thanks
10:44:55 * mmorrow searches for this parsing book he has somewhere in the meantime
10:45:19 <edwardk> mmorrow: start here http://swtch.com/~rsc/regexp/regexp1.html that will get you through the way an efficient non-backtracking regex  engine can work
10:45:21 <c_wraith> yacc is an LALR(1) parser, as I recall.  Those are possibly the strangest to describe.
10:45:45 <mmorrow> edwardk: perfect
10:45:54 <edwardk> and i can feed you tidbits on LALR via the parsimony source ;)
10:46:12 <mmorrow> ooh, cool
10:46:17 <c_wraith> I much prefer working with LL parsers, especially if they're nondeterministic. :)
10:46:43 <edwardk> note most perl style regex engines actually use the backtracking approach not the thompson NFA approach, because its faster for most practical regexes
10:46:57 <edwardk> and its more readily extensible, but it has worse worst-cases.
10:47:33 <c_wraith> Unfortunately, the Antlr family of LL(k) parsers just aren't as easy for me to work with as I think they should be.
10:47:37 <wahjava> i've written a network server in haskell and i noticed it is not closing server socket properly.
10:47:42 <wahjava> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4881#a4881
10:47:42 <mmorrow> c_wraith: hmm. do those lend themselves to the same type of "generate a gob of state machine code"/whatever that LALR parsers do?
10:47:46 <edwardk> LL parsers are easy and define nicely as recursive descent and provide you nice context for errors without requiring error productions, but LALR provides so many more opportunities for optimization
10:48:09 <edwardk> mmorrow: think parsec (LL-ish) vs. happy/frown (LALR-ish)
10:48:38 <wahjava> tcp        0      0 ::1:8080                ::1:46488               TIME_WAIT   -
10:48:41 <mmorrow> hmm. i thought LL was "on-line"
10:48:44 <wahjava> ^^^ socket reaches above state.
10:48:45 <edwardk> there is a bottom-up LL algorithm, but no one uses it because recursive descent is so convenient
10:48:53 <mmorrow> ah, hmm
10:49:02 <c_wraith> It's true that LALR is much easier to optimize..  But I sometimes dislike the convolutions my grammars have to go through to use it.
10:49:13 <c_wraith> Also, I think Antlr and the like do use the bottom-up version.
10:49:25 <c_wraith> Maybe I'm wrong. >_>
10:50:21 <edwardk> c_wraith: i've been obsessing about various ways to run Earley/LALR/GLR/PEG/LL(k)/TAG/TIG/etc. grammars in parallel, so they all sort of recently came into focus for me as distinct entities with distinct optimization opportunities
10:50:33 <edwardk> before that I always looked up the distinctions every time I needed one ;)
10:50:45 <mintsoup> when trying to build a package i get lots of errors like this: undefined reference to `unixzm2zi3zi2zi0_SystemziPosixziFiles_a52_info'--how do i figure out what package provides that?
10:50:50 <edwardk> c_wraith: yeah iirc thats how they get efficient LL(k)
10:51:01 <edwardk> mintsoup: you probably forgot to use ghc --make
10:51:17 <mintsoup> edwardk, ghc --make is what's returning the errors
10:51:20 <c_wraith> I remember a story from my compiler's class.  The professor said that 20 years ago or so, he had a grad student want to do research on LL parsing.  He replied that parsing was solved, and the student should find something else to do.  The student responded by finding a different advisor, then going on to do the work that eventually led to Antlr
10:51:28 <c_wraith> err.  *compilers*
10:51:44 <edwardk> hah
10:51:55 <c_wraith> The professor then followed that up with: "So don't think professors know it all, either."
10:52:33 <wli> LALR(1) is kind of crappy; I'd do LR(1) with core compaction where no ambiguities arise.
10:52:48 <edwardk> right now i'm having fun with a nice variation on peg parsing... you can 'spark' the evaluation of all of your rules in parallel without worsening your worst case asymptotics ;)
10:53:31 <wli> GLR would be ideal but it's really nasty.
10:53:38 <edwardk> wli: i've been looking at LALR because of some nice parallelism possibilities that arise by pretending your LALR grammar is GLR within all chunks except for the first.
10:54:28 <tibbe> I need a nice and short name for a stream processing monad (where the stream is a ByteString)
10:54:29 <edwardk> and then fixing up by 'canonicalizing' the later partial parses as it folds into the initial LALR parsed chunk on the left
10:54:38 <edwardk> tibbe: Parsec =)
10:55:31 <edwardk> tibbe: you could cheap out and go with ByteStream
10:55:44 <photonen> I want Haskell on cellphones!
10:56:09 <photonen> image haskell platform to develop on the iphone
10:56:10 <akafubu> what's the best haskell content management system?
10:56:10 <photonen> image->imagine
10:56:14 <edwardk> photonen: compile with jhc, iirc its been done. i think shapr has some code running on his BUG that way =)
10:56:55 <tibbe> edwardk: I would use that name for a data type I think
10:57:08 <tibbe> edwardk: but I guess it could work
10:57:08 <photonen> jhc? =yhc?
10:57:30 <edwardk> jhc == john meacham's now slightly long in the tooth haskell compiler
10:57:49 <Lemmih> long in the tooth?
10:57:53 <edwardk> http://repetae.net/computer/jhc/
10:58:00 <edwardk> Lemmih: well, since you abandoned it ;)
10:58:38 <c_wraith> Theoretically, there's a layer in android at which you can run any code you can compile for ARM..  But that's not a level you can distribute apps at.
10:59:30 <edwardk> Lemmih: btw- good move on switching to a ghc backend, but post more! =)
11:00:41 <edwardk> Lemmih: did you see bolingbroke's article on strict core/types as calling conventions?
11:00:43 <Lemmih> edwardk: I will. Been busy trying to get it ready for a new release.
11:01:17 <Lemmih> edwardk: Yeah, quite an interesting paper.
11:01:18 <akafubu> i have found the Hope CMS, but it's the only one and it seems to not have been updated in a long time
11:01:29 <edwardk> i thought there was a lot of neat stuff in there that fit well with the sort of general grin mindset
11:03:15 <akafubu> seems haskell is missing a cms
11:03:15 <edwardk> tibbe: "Streamed"?
11:03:24 <edwardk> akafubu: write one! =)
11:03:51 <edwardk> hope was used for a while, but i haven't seen anyone use it lately
11:03:59 <edwardk> we've er... lost hope.
11:04:28 * akafubu slaps edwardk with a large trout.
11:04:31 <akafubu> no puns allowed ;)
11:04:33 <lament> bah, on ghc 6.8.2 my program runs a bit faster and allocates almost twice less space than on 6.10.1
11:05:24 <photonen> im makign a simple 2d shooter on Android right now.
11:05:44 * edwardk notices the er.. somewhat bitter lament.
11:06:30 <lament> i'm not bitter, just curious
11:09:24 * Baughn_ runs out of cake
11:09:56 <vegai> lament: 6.10.2 had quite a lot of bugfixes iirc
11:10:22 <lament> i'll try it
11:10:40 <lament> not that this is a big deal
11:10:42 <Baughn_> We're up to 10.3 now
11:10:50 <lament> \o/
11:11:11 <Baughn_> Ah.. almost no bugfixes, even
11:11:36 <c_wraith> ooh.  I bet 10.3 has the bugfix for what I reported in it.  ctrl-c might work again!
11:11:46 <c_wraith> (in interpreted mode)
11:11:49 <Baughn_> Indeed
11:13:00 * photonen parades akafubu slap with a huge salmon then proceeds by inserting a live hamster in a dark place
11:21:54 <akafubu> :P
11:22:07 <akafubu> gitit isn't listed on http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming#Haskell_web_applications
11:22:17 <akafubu> minus the #*
11:23:10 <dons> akafubu: add it!
11:23:10 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:23:26 <dons> very little is documented on the wiki that way,as it predates hackage
11:23:29 <akafubu> dons, but i'm so good at complaining
11:23:31 <roconnor> How do I use my scanner in Kubuntu 8.10?
11:24:23 <jmcarthur> photonen, markov chain?
11:24:23 <akafubu> roconnor: #kubuntu
11:24:30 <roconnor> akafubu: I tried that
11:24:33 <akafubu> oh
11:24:37 <akafubu> let me look...
11:25:00 <purplefistmixer> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:27:35 <akafubu> roconnor: http://www.elijahlofgren.com/ubuntu/#scx-4100
11:28:10 <akafubu> seems downloading the driver for your scanner of course
11:28:16 <akafubu> -seems
11:28:33 <roconnor> that was last updated before 8.10 :(
11:28:40 <roconnor> in 8.04 I just used kooka
11:28:45 <roconnor> but now it is gone
11:28:45 <akafubu> oh
11:28:51 <akafubu> apt-get install kooka
11:28:53 <akafubu> ?
11:29:03 <roconnor> replaced by who know what.
11:29:10 <roconnor> kooka isn't installable
11:29:19 <roconnor> dependencies are not available anymore
11:29:49 <akafubu> skanlite
11:29:54 <mmorrow> edwardk: ah, ok. so the thompson NFA algo is just s/depth/breadth/-first search, analogous to s/Parsec/ReadP/
11:29:55 <akafubu> that's what it has been replaced by
11:31:29 <akafubu> roconnor ^ just making sure you see
11:31:34 <roconnor> thanks
11:31:40 <roconnor> I have no idea how you figured that out
11:31:44 <akafubu> google
11:31:50 <roconnor> heh
11:31:53 <roconnor> I tried
11:31:58 <roconnor> all I got was kooka
11:32:01 <roconnor> :P
11:32:08 <roconnor> I knew #haskell would be more helpful
11:32:12 <roconnor> sorry everyone
11:32:18 <akafubu> think i googled 'kooka replaced by'
11:32:22 <edwardk> mmorrow: yeah, and then you optimize it by gradually compiling into a DFA as you go
11:32:25 <roconnor> ah
11:32:29 <akafubu> nope
11:32:35 <akafubu> just 'kooka replaced' :P
11:32:43 <photonen_> a jesusfreak?
11:33:01 <mmorrow> , readP_to_S (choice . fmap (\(i,s) -> string s >> return i) $ zip [0..] ["cdsa","aaba","aba","bab","aab"]) "aaba"
11:33:02 <lunabot>  [(4,"a"),(1,"")]
11:33:08 * akafubu releases the hamster from his trousers
11:33:11 <akafubu> forgot it was in there
11:33:13 <roconnor> akafubu++
11:33:15 <mmorrow> edwardk: interesting
11:33:19 * mmorrow continues reading
11:33:51 <akafubu> photonen, I will have my revenge! ;)
11:38:58 <akafubu> roconnor: i'm in #kubuntu as well using another nick, but like i said last night, i'm also in 100+ other channels and can only focus on ~2-3 each day, and usually in small spurts
11:39:09 <roconnor> :)
11:40:02 <byorgey> 100+!  o.O
11:41:36 <roconnor> akafubu: this was actually easier than trying to get that scanner to work on my mom's mac
11:49:59 <akafubu> yeah, i find a lot of things easier to do on linux than the pop OSs
11:50:50 <roconnor> akafubu: the Mac is really plug and pray
11:51:06 <roconnor> acutally I installed sane, and got the scanner to work
11:51:11 <roconnor> but you cannot preview
11:51:27 <roconnor> you just have to give the dimensions of what part you want to scan using sliders. :P
11:51:41 <roconnor> It is the GuiTV of scanning programs.
11:53:29 <kyevan> data Sex = Male | Female | Yes
11:53:42 <p_l> lol
11:55:02 <p_l> last survey where I had to fill "sexual orientation" had "heterosexual, bisexual, gay/lesbian, *other*, prefer not to answer"
11:55:31 <MyCatVerbs> data Hanging = Left | Right | Yes
11:55:46 <Baughn_> p_l: So I've written an ICC wrapper that transparently falls back to GCC if ICC fails to compile a file. On a scale from one to ten, how hacky is this?
11:56:05 <p_l> 3?
11:56:12 <Baughn_> Ah, good
11:56:21 <MyCatVerbs> Baughn_: depends. Can you freely intermingle modules compiled with icc and gcc like that?
11:56:26 <gnuvince> p_l: what's a gay divided by a lesbien?
11:56:27 <Baughn_> MyCatVerbs: Yes
11:56:29 <MyCatVerbs> If so, only a three. Otherwise, eleven.
11:56:38 <fabjan> p_l: asexual could fit in other
11:56:50 <Baughn_> MyCatVerbs: At least, I think so
11:56:52 <visof> hello
11:56:59 <p_l> fabjan: I know, but the whole thing left me laughing for long :D
11:57:01 <roconnor> hi
11:57:01 <MyCatVerbs> Baughn_: personally, I would prefer to just cat all the source files together and build with -fwhole-program  =)
11:57:12 <p_l> MyCatVerbs: -fwhole-program failed ;-)
11:57:15 <Baughn_> MyCatVerbs: I tried that.
11:57:20 <kyevan> Arguably, you could insert non-monogamous in there.
11:57:21 <Baughn_> ..more or less
11:57:31 <xDie> lambdabot, @join #culturalibredigital
11:57:32 <lambdabot> Not enough privileges
11:57:51 <Twey> p_l: You could be attracted only to hermaphrodites
11:57:59 <Twey> Or transexuals
11:58:06 <MyCatVerbs> It netted me an extra couple percentage points on the last program I tried it with. Not much compared to just -O3, provided your module boundaries are set sensibly anyway.
11:58:12 <MyCatVerbs> You could be a slug.
11:58:18 <Twey> You could indeed be a slug.
11:58:28 <kyevan> True hermaphrodite?
11:58:33 <visof> i want to make simple database to store some information and make interface "GUI" to do some actions on stored data
11:58:34 <MyCatVerbs> Yes.
11:58:38 <Athas> Assuming otherwise would be specieism.
11:58:44 <visof> what should i read about that ?
11:59:06 * p_l just connected "other" with "a cat is fine too". BRB, brain bleach
11:59:20 <Twey> visof: Try Takusen + Gtk2Hs/Glade
11:59:49 * roconnor recommends GuiTV for simple guis
12:00:03 <MyCatVerbs> p_l: nonono, that's a seperate issue again. Species preference is orthogonal to gender preference, except where mono-gendered species are concerned. :3
12:00:11 <kyevan> Heh.
12:00:18 <kyevan> I prefer catgirls.
12:00:23 <kyevan> And catbois.
12:00:24 <MyCatVerbs> p_l: actually I'm concerned that there's no "Neuter" option there.
12:00:40 <Twey> Ah, but the question was one of sexual orientation, not gender preference
12:00:52 <MyCatVerbs> Or "Asexual" or whatever term you want to use, 'cuz that happens too.
12:00:52 <Twey> â€˜Only catsâ€™ is a perfectly valid response
12:00:56 <kyevan> Oh, and...
12:01:04 <kyevan> I'm /tri/sexual
12:01:14 * mmorrow 's generated words.c containing a switch trie for /usr/share/dict/words is 110M :)
12:01:25 <mmorrow> i wonder how gcc will handle this..
12:01:49 <p_l> badly? :)
12:01:50 <Twey> I imagine quite well
12:01:58 <mmorrow> haha, we'll find out!
12:02:06 <p_l> I guess it depends on amount of total memory
12:02:14 <MyCatVerbs> mmorrow: maybe it'll blow up? I've put together ~1MB of arithmetic statements and had about 200-300MB of working set used during compilation.
12:02:17 <Twey> One suspects that 110M is not an unusual size for a C program to, for example, output â€˜hello worldâ€™
12:02:17 <Athas> I predict subpar cache behavior for that program.
12:02:42 <mmorrow> $ time gcc -O3 words.c -o words.c
12:02:49 <mmorrow> ram usage at 3GB so far
12:02:53 <MyCatVerbs> mmorrow: I think you'll probably hit all the poorly-optimized bits of gcc, too.
12:02:55 <mmorrow> ooh, it just levelled off
12:03:53 <MyCatVerbs> Seeing as control flow optimization will have had a lot less work put into making it fast than things like register and arithmetic optimization.
12:04:01 <jmcarthur> wow
12:04:08 <mmorrow>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
12:04:08 <mmorrow>  3933 m         20   0 2059m 1.9g 3284 R 100.0 50.4   1:42.60 cc1
12:04:15 <p_l> and it certainly doesn't look like SPECint ;-)
12:04:43 <mmorrow> pfft, my little graph just made me estimate 3GB.. only 1.9 ;)
12:04:47 <wli> Twey: Was there a question about me?
12:05:32 <Twey> wli: Are you a slug?
12:06:22 <mmorrow> MyCatVerbs: gcc generates pretty killer code for switches (relative to what, i have no idea, but the asm looks nice :)
12:06:43 <Twey> How many lives has it claimed so far?
12:06:58 <MyCatVerbs> mmorrow: oh, I'm not saying the control flow optimizer doesn't generate good code.
12:07:19 <wli> Twey: You mentioned certain preferences.
12:07:19 <MyCatVerbs> mmorrow: I'm saying that I don't think the control flow optimizer has itself been worked on to run fast, itself.
12:07:32 <mmorrow> MyCatVerbs: ahh
12:07:45 <jmcarthur> mmorrow, what exactly do you mean by "switch trie"? i know tries and C switch statements, but i'm not sure how they combine
12:07:58 <jmcarthur> mmorrow, control flow = data structure?
12:08:25 <jmcarthur> i think i just inferred what you are doing, actually
12:08:33 <Twey> wli: Well, I don't think the question was specifically about you, but if you consider yourself felisexual then feel free to write them a complaint.
12:08:41 <jmcarthur> and my mind makes it look scary
12:08:56 <Twey> (although, to be honest, statistically speaking I think you're well covered by â€˜otherâ€™)
12:09:37 <mmorrow> jmcarthur: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2423#a2423
12:09:44 <mmorrow> hehe
12:09:46 <wli> Twey: That wasn't the one.
12:11:00 <jmcarthur> mmorrow, it is as i feared!
12:11:04 <mmorrow> heh
12:11:21 <Twey> wli: *Or any other category mentioned above*, though I can't guarantee you'll receive a response.
12:11:26 <jmcarthur> you must report on how performant it is once it compiles
12:13:49 <mmorrow> i've got gcc running through `time'
12:13:59 <Twey> Will that slow it down significantly?
12:14:19 <wli> Twey: Write a complaint to whom?
12:14:26 <mmorrow> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
12:14:26 <mmorrow>  3933 m         20   0 2719m 2.5g 3432 R 99.8 67.5  11:54.05 cc1
12:14:29 <mmorrow> so far..
12:14:33 <Twey> To the originators of the questionnaire, of course.
12:15:11 <mmorrow> Twey: i don't think so
12:16:02 <mmorrow> jmcarthur: ohh, "once it compiles"
12:16:08 <mmorrow> yes
12:17:01 <mmorrow> O(max(length english-word)) ! :)
12:17:26 <roconnor> @type liftM return
12:17:28 <wli> Twey: What questionnaire? And who are they?
12:17:28 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 a1 -> m1 (m a1)
12:17:42 <roconnor> @type return liftM
12:17:43 <lambdabot> forall a1 r (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 ((a1 -> r) -> m a1 -> m r)
12:17:45 <Twey> wli: I'm not entirely sure.  You should probably ask p_l for further details.
12:17:49 <roconnor> @type return . liftM
12:17:50 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1 -> m1 r)
12:17:54 <roconnor> hmm
12:18:15 <xDie> lambdabot, @join #culturalibredigital
12:18:15 <lambdabot> Not enough privileges
12:18:29 <roconnor> xDie: it's still not going to work
12:18:34 <jmcarthur> mmorrow, well, this is certainly something you never want to run `make clean` on
12:18:37 <wli> p_l: Details please?
12:18:44 <mmorrow> jmcarthur: heh
12:20:42 <p_l> wli: It was a questionaire from some recruitment agency, IIRC
12:22:47 <roconnor> @hoogle coalgebra
12:22:47 <lambdabot> No results found
12:22:50 <roconnor> @hoogle coAlgebra
12:22:50 <lambdabot> No results found
12:22:53 <roconnor> @hoogle CoAlgebra
12:22:53 <lambdabot> No results found
12:23:04 <roconnor> @hoogle Coalgebra
12:23:04 <lambdabot> No results found
12:30:27 <DrSyzygyIE> o.O
12:30:32 <DrSyzygyIE> @hoogle liftm
12:30:33 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:30:33 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:30:33 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:30:45 <DrSyzygyIE> I didn't think it'd be case sensitive....
12:30:53 <roconnor> ah
12:30:55 <roconnor> good to konw
12:31:00 <RayNbow> hmm
12:31:19 <RayNbow> can anyone reach http://research.microsoft.com/~simonpj/papers/assoc-types/typefun.pdf ?
12:32:17 <roconnor> RayNbow: yes
12:32:33 <RayNbow> odd
12:32:39 <roconnor> it is 301 moved permenently
12:32:42 <RayNbow> it doesn't load here
12:32:44 <RayNbow> hmm
12:32:51 * RayNbow is going to try a different browser...
12:32:51 <roconnor> moved to /en-us/um/people/simonpj/papers/assoc-types/typefun.pdf
12:33:35 <Berengal> I've been thinking some about monads and fail
12:33:51 <Berengal> Putting fail in monad seems like a bad idea to most, does it not?
12:33:57 <roconnor> to most
12:34:11 <vixey> Berengal: trying to think of alternative ways to deal with pattern match failure inside do notation
12:34:12 <Berengal> Right, so the alternative is something like MonadZero or MonadFail
12:34:14 <Twey> Everyone knows it's a bad idea
12:34:27 <Berengal> vixey: Exactly what I was thinking about
12:34:34 <roconnor> Berengal: that is the usual given alternative
12:34:35 <RayNbow> roconnor: to what address does research.microsoft.com resolve for you?
12:34:37 <Twey> But nobody's yet come up with a better one
12:34:38 <vixey> Do you want (x,y) <- foo ; ..., to _require_ MonadPlus?
12:34:41 <Apocalisp> Berengal: If you add fail, then you need to add an equal amount of win.
12:35:03 <Berengal> Apocalisp: Adding fail adds a win ;)
12:35:06 <vixey> ( (,) has only one constructor )
12:35:08 <Berengal> vixey: That's an option
12:35:10 <roconnor> vixey: yes, but maybe not ~(x,y) <- foo
12:35:15 <wli> Break out MonadPlus from MonadZero
12:35:17 <Apocalisp> Berengal: Monads are already made of win.
12:35:21 <vixey> ohh roconnor I think that pretty much solves it
12:36:07 <Berengal> Okay, so anything that desugars to 'case foo of ... _ -> fail' has to be in MonadFail (or whatever)
12:36:27 <Berengal> But ~ says it doesn't
12:36:29 <roconnor> RayNbow: what's the easiest way for me to ask my system that question?
12:36:33 <Berengal> I could live with that
12:36:48 <RayNbow> roconnor: ping research.microsoft.com
12:37:02 <roconnor> 131.107.65.14
12:37:06 <jmcarthur> that's one way to solve it, but what if you don't _want_ a lazy pattern match?
12:37:29 <jmcarthur> but don't want fail, either
12:37:36 <RayNbow> roconnor: hmm... same address that I get here... maybe research.microsoft.com is blocking non-US visitors?
12:37:44 <roconnor> jmcarthur: I think that would be asking too much
12:37:54 <Berengal> jmcarthur: Well, it can't fail, so why force it?
12:38:02 <jmcarthur> in my opinion, it doesn't even make much sense to have do notation treat pattern match failure differently than a pure function
12:38:28 <Berengal> jmcarthur: It does when you do lots of pattern matching, e.g. deconstructing a list in the Maybe monad
12:38:28 <mauke> RayNbow: very unlikely
12:38:30 <kyevan> A mother is 21 years older than her child. The mother's age in six years will be exactly five times the child's age in six years. Where is the father? <- Failing for thinking conception-to-birth is exactly 3/4 a year.
12:38:56 <jmcarthur> a pattern match that fails is normally just bottom. why not just have bottom in monads, too?
12:39:08 <roconnor> RayNbow: time to log in to another computer.
12:39:14 <jmcarthur> there are functions for [] -> Maybe
12:39:23 <jmcarthur> fail is just sugar
12:39:26 <Twey> :t listToMaybe
12:39:27 <lambdabot> forall a. [a] -> Maybe a
12:39:35 <RayNbow> hmm
12:39:43 <Berengal> jmcarthur: The reason for using the Maybe monad is exactly so you don't have to write 'else Nothing' all the time
12:39:45 <Twey> I wouldn't really call it sugar
12:39:47 <Twey> It's a handler
12:39:51 <Berengal> or _ -> Nothing
12:39:56 <RayNbow> I can reach the site fine when I tunnel my http traffic through TUDelft.nl
12:40:05 <Alex_Norton> www.YouFastPorn.com - Free,Fast,Safe & NO ADV..NO-PROFIT !!!
12:40:05 <marcusb> what's the easy way to split a list into a list of equal length sublists?
12:40:07 <jmcarthur> Berengal, this doesn't make the maybe monad useless at all
12:40:17 --- mode: ChanServ set +o dibblego
12:40:23 --- kick: Alex_Norton was kicked by dibblego (dibblego)
12:40:39 --- mode: dibblego set -o dibblego
12:40:47 <Berengal> jmcarthur: Yes it does
12:40:59 <dibblego> marcusb, there are functions for that in Data.List.Split
12:41:06 <Berengal> The Maybe monad is only useful because it doesn't bottom out when it fails
12:41:08 <DrSyzygyIE> "Starting in Java 5, the Java type system is a sort of dented, bolted-on version of the type systems that eventually evolved into the Haskell type system."
12:41:15 <jmcarthur> if i have a function of type (a -> Maybe b), it's a great candidate for the maybe monad already
12:41:36 <dibblego> looks like a candidate for a Kleisli value to me
12:41:55 <roconnor> vixey, Berengal: can we make every do an mdo while we are at it?
12:42:45 <roconnor> So you get a MonadFix contraint if you use a variable before it is created.
12:42:56 <jmcarthur> roconnor, i cannot foresee a problem with that, myself
12:43:00 <roconnor> and you can never use a variable name twice.
12:43:02 <Berengal> roconnor: Could be possible
12:43:15 <Berengal> It would complicate do somewhat though. Both these things do
12:43:16 <jmcarthur> oh, off, that second constraint hurts more
12:43:28 <jmcarthur> s/off/oof/
12:43:42 <roconnor> ya, the second constraint is the biggest issue.  I think it is worthwhile.
12:44:08 <Berengal> roconnor: It would only apply on MonadFixes, right?
12:44:26 <roconnor> Berengal: it would apply to all I think.
12:44:42 <marcusb> dibblego: that would be "chunk", thanks
12:45:00 <roconnor> Berengal: there might be a way to have it only apply to MonadFix, but I'd want a proof first.
12:45:04 <jmcarthur> Berengal, the proposal is that using a variable before it's created introduces the mandatory type constraint, but doesn't otherwise
12:45:09 <roconnor> Berengal: I also don't think it is worthwhile.
12:45:30 <Berengal> roconnor: Eh, I'm happy with reusing variables over again in do notation. I don't really want to change that
12:45:33 <jmcarthur> i don't like not being able to reuse variable names
12:45:39 <Berengal> Unless it's neccessary
12:45:48 <roconnor> heh
12:45:52 <roconnor> you guys are crazy
12:46:36 <roconnor> If you guys want to reuse variable names, then we ought to put a non-recursive let into the standard while we are at it then
12:46:53 <vixey> let rec
12:47:49 <jmcarthur> > let x = 5 in let x = 6 in x
12:47:50 <lambdabot>   6
12:47:54 <mmorrow> , let ?x = 99 in let ?x = (42, ?x) in ?x
12:47:55 <lunabot>  (42,99)
12:47:58 <jmcarthur> i guess that is different though
12:48:14 <roconnor> > let x = 5; x = 6 in x
12:48:14 <lambdabot>       Conflicting definitions for `x'
12:48:15 <lambdabot>      In the binding group for: x, x
12:48:19 <mmorrow> implicit params aren't recursive
12:48:20 <Gracenotes> x.x
12:48:33 <mmorrow> , let ?x = 5; ?x = 6 in ?x
12:48:34 <roconnor> jmcarthur: ya, if you want to nest my do blocks, I have no problem with that I think.
12:48:34 <lunabot>  5
12:49:00 <centrinia> Odd.
12:49:07 <Berengal> Anyway, going back to fail, we want some monads to fail implicitly, but we still want to be able to pattern match in unfailing monads
12:49:10 <Gracenotes> @type let ?x = 5 in let ?x = (429, ?x) in []
12:49:11 <lambdabot> forall a. [a]
12:49:14 <mmorrow> centrinia: very
12:49:15 <roconnor> centrinia: mmorrow defined a function ? that pattern matches on Exprs
12:49:16 <Gracenotes> @type let ?x = 5 in let ?x = (429, ?x) in ?x
12:49:17 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
12:49:29 * vixey is getting mad trying to define a type quote in agda
12:49:31 <mmorrow> , ?x
12:49:32 <lunabot>  luna: Unbound implicit parameter (?x::a)
12:49:33 <Gracenotes> hm.
12:49:34 <roconnor> or I'm totally wrong
12:49:38 <roconnor> sorry
12:49:39 <mmorrow> implcit params
12:49:42 <roconnor> ignore me
12:49:48 <mmorrow> :)
12:50:00 <Gracenotes> @type negate ?x
12:50:01 <lambdabot> forall a. (Num a, ?x::a) => a
12:50:07 <roconnor> vixey: isn't that the holy grail of dependently typed programming?
12:50:17 <roconnor> oh maybe not quite
12:50:20 <vixey> hehe I don't know
12:50:20 <mmorrow> @type fix (\x -> ?f x)
12:50:21 <lambdabot> forall a. (?f::a -> a) => a
12:50:29 <mmorrow> @type fix (\x -> ?f x ?f)
12:50:30 <lambdabot> Top level:
12:50:30 <lambdabot>     Occurs check: cannot construct the infinite type: t = a -> t -> a
12:50:30 <lambdabot>       Expected type: a -> t -> a
12:50:32 <roconnor> the holy grail is implementing the language entirely in itself.
12:50:34 <vixey> if I got a quoter I'd be able to do (closed) typeclass
12:50:36 <mmorrow> @type fix (\x -> ?f x (x ?f))
12:50:37 <lambdabot> Top level:
12:50:37 <lambdabot>     Occurs check: cannot construct the infinite type:
12:50:37 <lambdabot>       t = (t -> t1) -> t1 -> t -> t1
12:50:42 <vixey> dispatch
12:50:47 <vixey> but I can't do quoting :(
12:51:10 <vixey> roconnor: but it got me thinking -- there's a lot of scope for clever type/term inference algorithms
12:51:16 <hatds> how often do you need to use 'fail' in the maybe monad where usage of >>= and mplus aren't elegant enough?
12:51:19 <jmcarthur> i still do not see the point of fail, really. it's convenient if you don't have helper functions defined, but i find it confusing if a pattern match fail isn't just bottom
12:51:35 <hatds> I agree
12:51:47 <vixey> jmcarthur: it's very useful thoug...
12:51:50 <edwardk> fail mostly exists to make code in category-etras uglier ;)
12:51:57 <edwardk> er extras
12:52:07 <Berengal> > Just [] >>= (\(x:xs) -> Just x)
12:52:08 <lambdabot>   * Exception: /tmp/2362185542939914451:71:45-61: Non-exhaustive patterns in ...
12:52:08 <vixey> > let like = [Just 2, Nothing, Just 4, Nothing] in do Just x <- like ; return x
12:52:10 <lambdabot>   [2,4]
12:52:10 <vixey> like that
12:52:10 <edwardk> and to remove the symmetry between apomorphism and paramorphism =)
12:52:32 <Gracenotes> like wha
12:52:33 <Berengal> > do (x:xs) <- Just []; return x
12:52:35 <lambdabot>   Nothing
12:52:35 <jmcarthur> > let like = [Just 2, Nothing, Just 4, Nothing] in do x <- like ; return $ fromJust x
12:52:36 <lambdabot>   [2,* Exception: Maybe.fromJust: Nothing
12:52:43 <photonen_>  > (+1) &&& (subtract 1) $ 5
12:52:43 <photonen_>  > (+1) &&& (subtract 1) $ (5,5)
12:52:44 <jmcarthur> i would expect that to behave the same
12:52:45 <roconnor> cofail :: m a -> String
12:52:48 <vixey> I wouldn''t....
12:52:48 <jmcarthur> but it does not
12:52:50 <roconnor> for comonads
12:52:51 <Gracenotes> roconnor: hehe
12:52:57 <edwardk> > [ x | x <- [Just 2, Nothing, Just 4, Nothing], isJust ]
12:52:59 <lambdabot>   Couldn't match expected type `Bool'
12:53:08 <edwardk> > [ x | x <- [Just 2, Nothing, Just 4, Nothing], isJust x ]
12:53:09 <lambdabot>   [Just 2,Just 4]
12:53:18 <roconnor> @let cofail = const "I'm still alive"
12:53:20 <lambdabot>  Defined.
12:53:20 <edwardk> > [ fromJust x | x <- [Just 2, Nothing, Just 4, Nothing], isJust x ]
12:53:22 <lambdabot>   [2,4]
12:53:26 <stroan> anyone used Agda?
12:53:32 <vixey> stroan yeah
12:53:35 <edwardk> stroan: yeah
12:53:37 <vixey> and about to stop
12:53:40 <stroan> trying to get my head around dependant types
12:53:42 <vixey> I'm getting bored/annoyed
12:53:46 <photonen_> > (+1) &&& (subtract 1) $ (5,5)
12:53:47 <lambdabot>       No instance for (Num (t, t1))
12:53:47 <lambdabot>        arising from the literal `1' at <i...
12:53:49 <jmcarthur> vixey, rather, if i had the latter code and changed it to the former, i would rather the semantics remain the same
12:53:52 <stroan> just not "getting it"
12:53:53 <roconnor> edwardk: bleck
12:54:07 <hatds> > let like = [Just 2, Nothing, Just 4, Nothing] in map fromJust $ catMaybes like
12:54:08 <lambdabot>       No instance for (Num (Maybe a))
12:54:08 <lambdabot>        arising from the literal `4' at ...
12:54:13 <vixey> > [ x | Just x <- [Just 2, Nothing, Just 4, Nothing] ]
12:54:14 <lambdabot>   [2,4]
12:54:15 <lambdabot2>  Terminated
12:54:15 <roconnor> stroan: that's understandable.
12:54:21 <lambdabot2>  Terminated
12:54:40 <roconnor> @src catMaybes
12:54:41 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:54:41 <lambdabot2> catMaybes ls = [x | Just x <- ls]
12:54:50 <roconnor> so many lambdabots
12:54:53 * vixey sort of wants to code up these ideas about term inference
12:55:09 <jmcarthur> > [ x | x <- fromJust [Just 2, Nothing, Just 4, Nothing] ]
12:55:09 <lambdabot2>  Terminated
12:55:10 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[a1]'
12:55:16 <vixey> a decent way to do open data types would be good too thoug.h.
12:55:28 <jmcarthur> > [ x | x <- fromJust <$> [Just 2, Nothing, Just 4, Nothing] ]
12:55:29 <lambdabot2>  Terminated
12:55:29 <lambdabot>   [2,* Exception: Maybe.fromJust: Nothing
12:55:37 <edwardk> > [ x | (fromJust -> x) <- [Just 2, Nothing, Just 4, Nothing] ]
12:55:37 <lambdabot2>  Terminated
12:55:38 <lambdabot>   <no location info>: parse error on input `->'
12:55:44 <Gracenotes> sssshhhhhhh
12:55:45 <vixey> hah
12:55:46 <photonen_> > (+1) &&& (subtract 1) $ 5
12:55:46 <lambdabot2>  Terminated
12:55:47 <jmcarthur> > [ fromJust x | x <- [Just 2, Nothing, Just 4, Nothing] ]
12:55:48 <lambdabot2>  Terminated
12:55:48 <lambdabot>   (6,4)
12:55:48 <edwardk> , [ x | (fromJust -> x) <- [Just 2, Nothing, Just 4, Nothing] ]
12:55:49 <lambdabot>   [2,* Exception: Maybe.fromJust: Nothing
12:55:49 <lunabot>  luna: Maybe.fromJust: Nothing
12:55:55 <photonen_> > (+1) &&& (subtract 1) $ 5
12:55:55 <lambdabot2>  Terminated
12:55:56 <lambdabot>   (6,4)
12:56:04 <Gracenotes> /kick lambdabot2
12:56:06 <photonen_> > (+1) *** (subtract 1) $ (5,5)
12:56:07 <lambdabot2>  Terminated
12:56:07 <lambdabot>   (6,4)
12:56:42 --- mode: ChanServ set +o roconnor
12:56:49 --- kick: lambdabot2 was kicked by roconnor (User terminated!)
12:56:55 <Berengal> Okay, so I've got a type Foo a = Elem a | List [Foo a], the classical hierarchical structure we know and love from lisp
12:56:56 --- mode: roconnor set -o roconnor
12:57:01 <Gracenotes> @type let (=>>) :: w a -> (w a -> b) -> w b; (=>>) = undefined in \x y -> x =>> \_ -> y
12:57:02 <lambdabot> forall (w :: * -> *) a b. w a -> b -> w b
12:57:23 <Gracenotes> hm
12:57:28 <Berengal> I want to take a value of type Foo a and turn it into something else, like a [a] or Tree a
12:57:44 <Gracenotes> so that's the comonad >>
12:58:01 <Berengal> This requries the Foo a value to have a spesific structure, so I have to deconstruct it to find out
12:58:16 <Berengal> Doing this in the Maybe monad is easy because of the implicit fails
12:58:23 <edwardk> gracenotes: yeah, 'take the wrapper and put it around something else'
12:58:39 <edwardk> or basically 'uniformly redecorate with a constant
12:58:44 * vixey thinks about lisp more like  S = Atom | Cons S S
12:58:53 <Berengal> I don't see any way of making it elegant if pattern matching bottoms out
12:59:15 <dons>  
13:00:06 <jmcarthur> Berengal, hpaste what you would do and i'll add a version for what i would do in the absence of fail
13:00:19 <jmcarthur> Berengal, you should do it first though so i know i'm doing the same thing as you
13:00:41 <Berengal> jmcarthur: Yeah, I don't really have anything right now, but I could probably hack something up in a couple of minutes...
13:00:49 <jmcarthur> k
13:01:16 <jmcarthur> i'm working in another desktop now, but i will check back in frequently
13:01:28 <edwardk> berengal: Data.Dynamic?
13:02:24 <Berengal> edwardk: What?
13:02:25 <hatds> haven't checked this but what about    f (Elem a) = [a], f (List []) = [], f (List (x:xs)) = f x ++ f (List xs)
13:12:54 <Berengal> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4885#a4885
13:18:47 <Berengal> It suddenly got real quiet here...
13:18:51 <stepcut> how come there is not an Arbitrary instance for Char?
13:21:08 <edwardk> berengal: what what? =)
13:21:16 <monadic_kid> stepcut: what do you mean by arbitrary
13:21:24 <edwardk> oh the wrapped up type stuff
13:21:41 <Berengal> edwardk: You were asking me about Data.Dynamic or something
13:22:01 <edwardk> "Berengal I want to take a value of type Foo a and turn it into something else, like a [a] or Tree a " -- i just threw out Data.Dynamic as an option
13:22:11 <Berengal> Ah
13:22:21 <edwardk> wasn't quite sure where you were going with it
13:22:24 <Berengal> Well I was talking in terms of converter functions
13:22:24 <stepcut> monadic_kid: Test.QuickCheck.Arbitrary
13:22:42 <Berengal> Such as the sexpr2xml in my above paste
13:22:47 <edwardk> stepcut: there isn't?
13:23:02 <stepcut> edwardk: nope
13:23:37 <stepcut> edwardk: seems like such an obvious thing that I figured there must be some good reason there isn't one ;)
13:23:58 <wh1t3> http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck-Arbitrary.html#t%3AArbitrary
13:24:00 <wh1t3> listed there :/
13:24:30 <tomh-> why would this regex give a parse error in 'alex' $intconstant  = [\+\-]?[0-9]+
13:24:33 <stepcut> ah, I only imported Test.QuickCheck, which gives me some, but not all apparently ;)
13:24:34 <jmcarthur> Berengal, could you give me an example of input that doesn't return Nothing? i'm not a big sexp/xml person
13:25:02 <stepcut> wh1t3: oh.. one moment
13:25:21 <Berengal> jmcarthur: (person ((name bob) (height 180)) (shirt ((type hawaian))))
13:25:53 <Berengal> jmcarthur: Hang on a sec, and I'll translate that to haskell
13:26:02 <stepcut> I am still on quickcheck 1.x. Apparently the Arbitrary Char was added in 2.x
13:26:02 <jmcarthur> that's enough i think
13:26:04 <jmcarthur> thanks
13:26:12 <jmcarthur> lemme make sure i understand how it should translate though...
13:26:17 <Berengal> List [Atom "person",List [List [Atom "name",Atom "bob"],List [Atom "height",Atom "180"]],List [Atom "shirt",List [List [Atom "type",Atom "hawaian"]]]]
13:26:38 <wh1t3> stepcut, then i would advise you upgrade :)
13:26:49 <wh1t3> no idea why it wasnt in there in 1.x though...
13:27:12 <jmcarthur> <person name="bob" height="180"><shirt type="hawaian"/></person> ?
13:27:13 <kpreid> Berengal: That representation does not permit improper lists
13:27:21 <Berengal> Basically, an Element can be represented as a Sexpr as: A list, with a single name first, then a single list of pairs of names followed by any number of <<recurse>>
13:27:31 <stepcut> wh1t3: I would like to, I can't remember what is holding things up.
13:27:31 <jmcarthur> okay i follow
13:27:41 <Berengal> kpreid: That representation was hacked up in 30 seconds to prove a point :P
13:28:24 <Berengal> jmcarthur: Pair of course being a list of two elements
13:39:45 <PetRat> I'm experimenting with partial application together with >>=. http://www.mibbit.com/pb/8EbZ4i  Is there an equivalent do-notation that uses partial application in this way?
13:40:09 <vixey> what :(
13:40:26 <gwern> @do getLine >>= testPrefix "prefix"
13:40:26 <lambdabot> getLine >>= testPrefix "prefix" not available
13:40:36 <gwern> @help do
13:40:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:40:42 <gwern> @help undo
13:40:42 <lambdabot> undo <expr>
13:40:42 <lambdabot> Translate do notation to Monad operators.
13:40:47 <vixey> @redo
13:40:47 <lambdabot> ()
13:40:48 <gwern> huh.
13:40:56 <gwern> @help redo
13:40:56 <lambdabot> redo <expr>
13:40:56 <lambdabot> Translate Monad operators to do notation.
13:41:06 <gwern> that's a stupid name
13:41:11 <gwern> @redo getLine >>= testPrefix "prefix"
13:41:12 <lambdabot> do { a <- getLine; testPrefix "prefix" a}
13:41:31 <PetRat> So it doesn't look like you can really use partial application in the do notation?
13:41:59 <gwern> well, you can do lambdas with do blocks
13:42:00 <PetRat> @redo foo >>= bar
13:42:00 <lambdabot> do { a <- foo; bar a}
13:42:22 <PetRat> @redo foo >>= \s -> bar
13:42:22 <gwern> any objections to changing 'redo' to 'do'?
13:42:22 <lambdabot> do { s <- foo; bar}
13:42:37 <PetRat> @redo foo >>= \s -> bar [s]
13:42:37 <lambdabot> do { s <- foo; bar [s]}
13:42:49 <FunctorSalad> unundo?
13:42:55 <trofi> @overdo stuff
13:42:55 <lambdabot> Unknown command, try @list
13:43:00 <gwern> FunctorSalad: now you're just being silly
13:43:05 <FunctorSalad> sorry :(
13:43:56 <tombom_> being silly: a horrible crime
13:44:09 <FunctorSalad> anando?
13:44:23 <trofi> !!do
13:44:46 <FunctorSalad> hmm I guess this isn't #free-associating
13:45:41 <gwern> this is sparta!
13:47:26 <tombom_> yeah saying that is a horrible crime
13:47:49 <vixey> It's not as bad as taping music off the radio
13:48:06 <gwern> tombom_: I thought the unexpectedness would make up for it
13:49:10 <Berengal> There comes a point when everybody expects the spanish inquisition...
13:50:53 <byorgey> PetRat: of course you can use partial application in do blocks, in general.  But in a do-block, you have to explicitly give a name to the intermediate value(s) that flow through >>=.
13:51:19 <byorgey> so in your example, with >>= that value was implicit; hence the partial application (since >>= takes a function as its right-hand argument).
13:51:59 <jmcarthur> Berengal, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4885#a4886 , and i will brb in about 15 minutes
13:53:17 <FunctorSalad> Berengal: many people expect spanish inquisition jokes nowadays, but I would argue that still very few people expect the spanish inquisition
13:53:43 <hatds> hpaste'd mine as well
13:55:08 <Berengal> jmcarthur: Yours still use pattern matching. It can fail if e.g. the first element of the list isn't an Atom
13:56:18 <hatds> whoops, mines a mess which doesn't compile :)
13:56:27 <Berengal> hatds: I was just about to mention that :P
13:56:34 <Berengal> At least yours doesn't use implicit fail
13:56:55 <hatds> I'm not sure if I like using implicit fail or not
13:57:46 <tomh-> anyone here alex expert?
13:58:19 <Lemmih> tomh-: Sorry, haven't heard of the guy.
13:58:35 <tomh-> haskell.org/alex :(
14:01:37 <kau> Hello!
14:01:44 <hatds> well it compiles now, but nothing's really changed with the structure
14:02:41 <tomh-> what is stuff like {-# LINE 1 "templates/wrappers.hs" #-} do in haskell?
14:02:44 <jmcarthur> Berengal, ah, woops, indeed you are correct
14:03:02 <jmcarthur> Berengal, of course, in the absence of fail, there would be compiler warning for that :P
14:03:15 <kau> how would you code a function that says whether a string is a auto-anagram? like "cosmicomics", the first half must be an anagram of the second?
14:04:06 <Berengal> jmcarthur: @undo also reveals this
14:04:15 <gwern> tomh-: the ghc manual covers the pragmas, I believe
14:04:18 <Berengal> @undo do   Atom name : List as : es <- sexprList s ;  attrs <- forM as $ (\a -> do [Atom name, Atom val] <- sexprList a ;  return $ Attr name val) ; elems <- mapM sexpr2xml2 es  ; return $ Elem name attrs elems
14:04:18 <lambdabot> sexprList s >>= \ b -> case b of { Atom name : List as : es -> forM as $ (\ a -> sexprList a >>= \ b -> case b of { [Atom name, Atom val] -> return $ Attr name val; _ -> fail ""}) >>= \ attrs ->
14:04:18 <lambdabot> mapM sexpr2xml2 es >>= \ elems -> return $ Elem name attrs elems; _ -> fail ""}
14:04:57 <FunctorSalad> tomh-: AFAIK it's just for having error messages point to the unpreprocessed source
14:05:16 <bogner> tomh-: that just makes the compile give better error messages (it will say the error is in the file templates/wrappers.hs instead of the file it's actually in, if an error occurs after that)
14:06:03 <bogner> tomh-: such things are common in generated source code, kind of useless otherwise
14:06:24 <kau> nobody an idea?
14:06:44 <byorgey> kau: split the string into halves.  sort the halves.  see if they are equal.
14:06:52 <tomh-> mm yeah
14:07:05 <tomh-> but in this case its bad because i have no idea where that file is :P
14:07:20 <tomh-> apperently alex has an indention error there
14:07:22 <FunctorSalad> tomh-: try "cabal unpack alex"
14:07:22 <byorgey> kau: isn't this from a recent blog post?
14:07:29 <tomh-> ok
14:07:33 <kau> byorgey: yes but i was wondering how to do it one line pointfree...
14:07:35 <FunctorSalad> (it will unpack the alex sources to the current dir)
14:07:50 <kau> yes it is
14:08:10 <byorgey> kau: it's slightly more complicated since I think the last letter of the first half and the first letter of the second half are supposed to overlap
14:08:18 <trofi> @pl \(p, n) -> mexp p n
14:08:18 <lambdabot> uncurry mexp
14:09:10 <Gracenotes> @pl \(p, n) -> mexp p
14:09:10 <lambdabot> mexp . fst
14:09:25 <mm_freak> at work i'm implementing functors and monads in C# (they force me to use it)â€¦  i found that they are much easier to implement with 'join' instead of (>>=)
14:09:53 <Twey> I think you get them for free with LInQ
14:09:59 <tomh-> FunctorSalad: thanks, but apperently there is no line 340 there which the error sais :p
14:10:13 <byorgey> > let isAutoAnagram s = sort (take (n+1) s) == sort (drop n s) where n = length s `div` 2   in  isAutoAnagram "cosmicomics"
14:10:14 <lambdabot>   True
14:10:23 <byorgey> kau: how about that?
14:10:25 <mm_freak> Twey: LINQ isn't anywhere near monadsâ€¦  i was missing Maybe, so i implement it
14:10:29 <bogner> tomh-: how many lines are there?
14:10:43 <tomh-> 328
14:10:55 <mm_freak> instead of try/catch i use:  somethingThatMightFail().bind(x => â€¦);
14:11:21 <kau> with a pointfree notation, how to use an argument twice? say you want to get the first half of a string, how to write it with splitAt?
14:11:51 <bogner> tomh-: i would guess the error is 340 lines past the LINE pragma in the generated file, and alex forgot to say what file that part is from
14:11:52 <Twey> mm_freak: http://devhawk.net/2008/07/30/Monadic+Philosophy+Part+2+The+LINQ+Monad.aspx
14:12:12 <Cale> kau: mostly, the (->) e monad operations are useful for that
14:12:21 <tomh-> bogner, so i have to guess where the error is then? :(
14:12:43 <bogner> tomh-: yes, and possibly file a bug on alex d:
14:13:12 <tomh-> ill just install haskell platform, that has a newer version of alex
14:13:23 <kau> Cale: indeed, thats what i thought: monads are too tricky for me!
14:13:42 <cads> hehehe
14:13:44 <Cale> Well, you don't really need to know about monads in general.
14:13:50 <mm_freak> Twey: i don't think that you can prove LINQ to be a monad, and even if it is, it's just one particular monad
14:13:54 <mauke> kau: functions form a monad, so you can't use functions anymore. sorry.
14:13:59 <Cale> You just need to know what the operations do for that one monad :)
14:14:01 <Twey> mm_freak: No â€” its behaviour is custom-defined
14:14:15 <monadic_kid> mm_freak: try to find the paper query comphrensions, thats what LINQ is based on and the connection with monads
14:14:16 <Cale> Let's start with...
14:14:17 <Cale> > (do x <- (`div` 2) . length; splitAt x) "hello"
14:14:17 <jmcarthur> :t join :: (a -> a -> b) -> (a -> b)
14:14:18 <Twey> You can implement any monad you like using it
14:14:19 <lambdabot> forall a b. (a -> a -> b) -> a -> b
14:14:19 <lambdabot>   ("he","llo")
14:14:23 <kau> thats the Arrow things?
14:14:50 <mm_freak> Twey, monadic_kid:  ok, so how do i use LINQ to express CPS?
14:14:50 <Twey> > ((`div` 2) . length >>= splitAt) "hello"
14:14:52 <lambdabot>   ("he","llo")
14:14:52 <Cale> Well, the Arrow operations can be useful for points-free stuff too...
14:14:58 <Twey> mm_freak: I have no idea
14:15:03 <Twey> I don't actually speak C#
14:15:06 <Twey> I just know it's possible
14:15:07 <mm_freak> Twey: me neitherâ€¦  LINQ is a query language for me
14:15:18 <kau> i will look at Arrow tutorials then...
14:15:21 <Cale> Or even...
14:15:23 <Twey> I don't think C# has tail-calls, though
14:15:24 <dmwit> Are there any good priority queue structures in Haskell?
14:15:36 <mm_freak> Twey: it doesn't
14:15:39 <Cale> > splitAt =<< (`div` 2) . length $ "hello"
14:15:41 <lambdabot>   ("he","llo")
14:15:47 <Twey> So it could get kind of costly
14:15:48 <dmwit> I'm also in the market for an edge-labeled graph structure...
14:15:50 <mm_freak> i don't like C# a lot, but i'm forced to use it
14:15:52 <Twey> For big monads
14:16:08 <kau> Twey: great
14:16:10 <monadic_kid> mm_freak: i never said they are monads, i'm saying it's based on the paper query comphrensions which is ment to be a generalization of monad comphrensions
14:16:16 <Cale> kau: To figure out what each monadic operation means, we can look at its type, and replace each m with (e ->)
14:16:37 <Cale> (=<<) :: (a -> m b) -> m a -> m b
14:16:42 <mm_freak> monadic_kid: yes, but that's not very helpful in practice =)
14:16:43 <Cale> well...
14:16:48 <Cale> (=<<) :: (Monad m) => (a -> m b) -> m a -> m b
14:16:55 <Cale> So...
14:16:57 <jmcarthur> found a cool use for Control.Functor.Categorical... (cmap = Kleisli . Data.Traversable.mapM . runKleisli). cmap is generic enough to represent both fmap and Data.Traversable.mapM! unfortunate that you have to wrap in Kleisli to write the instance though
14:17:13 <Cale> (=<<) :: (a -> (e -> b)) -> (e -> a) -> (e -> b)
14:17:26 <mm_freak> however, my main point is:  i found all monads to be easier to implement with pure and join instead of pure and (>>=)
14:17:43 <Twey> mm_freak: Many people have said that
14:17:46 <kau> thanks Cale
14:17:47 <jmcarthur> mm_freak, yes, monads typically are easier for me to implement using join as well
14:18:04 <Cale> kau: and if you think hard about that type, you can work out what (=<<) must be doing in this case
14:18:56 <mm_freak> then why does haskell have (>>=)?
14:19:00 <Cale> kau: Over time, you'll come to just regard the (e ->) monad as "running" computations by simply supplying the argument which the whole function is applied to.
14:19:03 <Twey> :t (>>=)
14:19:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:19:04 <kau> what does that e stands for?
14:19:07 <jmcarthur> because it looks imperative
14:19:16 <jmcarthur> mm_freak, i prefer (=<<) anyway
14:19:17 <Cale> kau: any type... in this case it was a String
14:19:22 <mm_freak> hmm
14:19:33 <mm_freak> i've never used (=<<) yet
14:19:41 <Twey> I use it sometimes
14:19:46 <Twey> Mostly in combination with <-
14:19:53 <Cale> kau: If you pick any type e, then functions from the type e form a monad
14:19:55 <Twey> foo <- bar =<< baz looks pretty
14:20:04 <mm_freak> i generally use a mixture of do, fmap, join and (>>=)
14:20:04 <dmwit> (=<<) makes more sense just looking at types.
14:20:06 <jmcarthur> i like to think of it as returning a function rather than applying a function in a special way: (=<<) :: (Monad m) => (a -> m b) -> (m a -> m b)
14:20:09 <dmwit> (a -> m b) -> (m a -> m b)
14:20:10 <Cale> kau: and you get lots of useful operations on functions from the stuff in Control.Monad and the Prelude.
14:20:11 <hatds> Twey beat me to what I was going to say :)
14:20:20 <mm_freak> dmwit: good point
14:20:42 <ray> instance Monad ((->) e) where -- is how it's written
14:20:44 <mm_freak> Twey: also good point
14:20:57 <ray> i find it clearer like that, ymmv
14:21:10 <dmwit> Anyway, the main complaint is usually that (.) and (>>=) represent data flowing in different directions.
14:21:11 <jmcarthur> it also mirrors things like <*> and <$> a bit nicer in terms of argument order
14:21:27 <Twey> Yeah
14:21:30 <Twey> But that's a flaw of .
14:21:34 <dmwit> =)
14:21:37 <Cale> ray: You mean (->) e rather than (e ->) ?
14:21:38 <Twey> It's backwards
14:21:40 <jmcarthur> Twey, i think it's a flaw in . :P
14:21:42 <ray> yeah
14:21:43 <jmcarthur> err
14:21:43 <Twey> Which is why >>> is nicer
14:21:46 <cads> I've created a somewhat nonsensical set operator with one specific use, but in the general case I don't know what it's good for :)
14:21:46 <ray> i prefer (->) e
14:21:47 <jmcarthur> >>=
14:21:52 <Cale> The (e ->) syntax isn't allowed in Haskell, but I think it's clearer what it means.
14:21:58 <cads> I call it 'flapzap'
14:22:04 <Twey> I thought there was an extension for it, Cale?
14:22:10 <Twey> cads: Hahaha
14:22:14 <dmwit> Anyway, (>>=)/(>>>) or (=<<)/(.) seem like nice combinations.
14:22:14 <Cale> If there is, it's new.
14:22:15 <ray> and i think (->) e is clearer, but (e ->) should probably be allowed
14:22:17 <byorgey> cads: what does it do?
14:22:40 <kau> Cale: i'll have to play around with it to understand better ;)
14:22:48 <ray> good idea
14:22:49 <jmcarthur> Twey, if you don't like the order of . then you might want to change the order of $ as well ;)
14:22:57 <Cale> ray: The slightly confusing thing about "(->) e" is that the e is on the wrong side of the arrow :)
14:23:06 <jmcarthur> and normal function application too, of course
14:23:07 <dmwit> jmcarthur: Definitely, but be sure to keep the associativity in that case. ;-)
14:23:17 <hatds> smiley parade?
14:23:22 <ray> i find it easier to replace an m a with a (->) e a, basically
14:23:28 <Twey> Cale: Oh, maybe not
14:23:34 <Twey> jmcarthur: Well, that doesn't really follow
14:23:45 <Cale> Of course, when it gets applied to another parameter, it becomes (->) e a, and that's the same as (e -> a), but we don't usually write (->) e a in types willingly :)
14:24:01 <ray> neither do i, except when it's a monad
14:24:06 <jmcarthur> Twey, the notation f . g derives directly from the notation f(g(x))
14:24:09 <Cale> It's just unusual to use (->) in prefix form
14:24:18 <jmcarthur> reverse one should reverse the other
14:24:24 <Twey> The problem is that (f . g) x = f (g x) looks all very fine and logical when you're reading it on its own
14:24:27 <Twey> Yeah
14:24:30 <cads> byorgey, from two sets A and B, creates a set of two element sets S_k, where each S_k contains an element from A and one from B.  flapzap A B = {{x, y} | x in A, y in B, x!=y}
14:24:32 <Twey> It *looks* like that makes sense
14:24:32 <ray> i guess what works for me *probably* doesn't work for your average newbie
14:24:37 <tomh-> @src print
14:24:37 <lambdabot> print x = putStrLn (show x)
14:24:55 <ray> twey: i think . should be flipped about half the time
14:25:10 <Twey> But in practice, that means that you get things like foo (bar . baz . quux) (blah blob)
14:25:18 <byorgey> cads: that's not so crazy =)
14:25:27 <jmcarthur> Twey, i see no problem with that ;)
14:25:30 <ray> after all, you have to read long chains from right to left..
14:25:32 <Cale> cads: If it weren't for the condition that x and y are not equal, that would be a normal Cartesian product.
14:25:38 <Twey> Where the function application is mainly proceeding left-to-right, but when you encounter the section with the dots you have to go backwards and start reading from the end
14:25:39 <Taejo> mostly I don't mind the order of (.), but I REALLY mind it when I have an arrow diagram and an equation
14:25:40 <byorgey> cads: it's quite similar to cartesian product
14:25:44 <Cale> er, actually, those are unordered pairs, eh?
14:25:56 <byorgey> Cale: except for the fact that it generates a set of sets, not ordered pairs
14:25:58 <Cale> yeah
14:25:59 <FunctorSalad> Taejo: totally
14:26:02 <ray> maybe there should be a flipped (.), but what would you call it
14:26:06 <Twey> It's backwards with respect to normal function application â€” reversing both would have exactly the same problem, just the other way around
14:26:08 <jmcarthur> ;
14:26:10 <cads> if A and B are disjoint it has the same number of elements as the cartesian product
14:26:12 <c_wraith> ray: >>>
14:26:12 <FunctorSalad> Taejo: you could use Control.Category.(>>>) though
14:26:20 <byorgey> right
14:26:25 <jmcarthur> Twey, i don't see what's backwards there
14:26:26 <Twey> FunctorSalad: If you meant me, I already mentioned that :)
14:26:27 <dmwit> cads: I don't think that's right.
14:26:36 <dmwit> cads: It has only half as many as the Cartesian product.
14:26:37 <Taejo> FunctorSalad: my topology lecturer doesn't like Control.Category.(>>>) appearing in equations
14:26:38 <jmcarthur> i'm conditioned
14:26:41 <Twey> Oh, you didn't
14:26:46 <Cale> I think when combined with lazy evaluation, the usual order of function application actually makes a lot of sense.
14:26:48 <Twey> And you weren't even talking about my >>>
14:26:49 <Twey> How confusing
14:26:56 <cads> dmwit: you're right!
14:27:00 <FunctorSalad> Taejo: computational topology?
14:27:00 <jmcarthur> Cale, good point
14:27:01 <Cale> In f . g . h $ x, which function is applied first?
14:27:06 <Cale> It's f, right?
14:27:17 <mauke> ($)
14:27:18 <Cale> (ignoring (.) and ($) applications)
14:27:18 <Twey> No, it's h
14:27:23 <ray> yeah, lazily it doesn't go right to left, it goes left to right making thunks
14:27:30 <Cale> No, it's f, which is applied to (g (h x))
14:27:31 <FunctorSalad> Taejo: oh wait, apparently you're talking about math in general
14:27:42 <FunctorSalad> thought you were actually doing topology in haskell :)
14:27:53 <Twey> Okay, fair point
14:27:54 <Cale> Lazy evaluation is outermost-first :)
14:28:42 <Taejo> FunctorSalad: yes, I am. the last time I came up against this was in a Topology I tutorial. But I'm doing my computability homework now it's turning out to be mostly topology
14:28:51 <mmorrow> , (\xs ys -> let zs = (xs `union` ys) in [(x,y) | x <- xs, y <- ys] \\ (fmap (join (,)) zs)) [0..9] [4,1,7,8,9]
14:28:52 * Twey ponders.
14:28:53 <lunabot>  [(0,4),(0,1),(0,7),(0,8),(0,9),(1,4),(1,7),(1,8),(1,9),(2,4),(2,1),(2,7),...
14:29:18 <Twey> It makes sense to view it that way when talking about f (g (h x)), but not f . g . h $ x, to me, for some reason
14:29:28 <ray> anyway, (.) as she is wrote is fmap
14:29:35 <Twey> Hehe
14:29:51 <Cale> As who wrote?
14:30:12 <ray> joke
14:30:20 <ray> @go english as she is wrote
14:30:25 <lambdabot> http://www.gutenberg.org/etext/25933
14:30:25 <lambdabot> Title: English as She is Wrote by Anonymous - Project Gutenberg
14:30:29 <FunctorSalad> Twey: postfix application...
14:30:40 <mauke> http://en.wikipedia.org/wiki/English_As_She_Is_Spoke
14:30:50 <ray> yeah, that would be the original
14:30:55 * ray smacks self
14:30:55 <dmwit> > let xs = [0..9]; ys = [4,1,7,8,9] in do { x <- xs; y <- ys; guard (x < y); return [x, y] }
14:30:57 <lambdabot>   [[0,4],[0,1],[0,7],[0,8],[0,9],[1,4],[1,7],[1,8],[1,9],[2,4],[2,7],[2,8],[2...
14:30:57 <FunctorSalad> maybe it's a cultural thing and people don't want to seem "pretentious" by using the obviously better syntax? ;))
14:31:17 <cads> dmwit: I'm sorry, wait that's wrong.... if intersection A  B = {},  cart-prod A B has |A| * |B| elements in form of (a_j, b_k), a_j in A, b_k in B... but flapzap  also has those same number of elements in the form of {a_j, b_k}, where a_j can't equal b_k for any choice of j, k, because A and B are disjoint.
14:31:47 <dmwit> cads: Ah, quite right.
14:32:02 <tomalak> http://codepad.org/0cziSIFZ <--- I am not looking for help debugging functions f and g (I want to do that myself), but I've never done a main function before in Haskell and would like to know what's wrong with my approach in that regard
14:32:20 <dmwit> tomalak: indentation
14:32:25 <ray> well, i see lets with no ins
14:32:27 <dmwit> tomalak: Don't use literal tabs.
14:32:46 <ray> i think you want to be using <- there
14:32:58 <tomalak> it has to line up exactly with the putStrLn? ok
14:33:01 <Cale> FunctorSalad: It is a cultural thing, but it's not just about pretentiousness. People are *used to* the function being on the left of its parameter. If you change that convention without a very good reason to do it, people will have a harder time picking up your book and understanding what you've written.
14:33:01 <dmwit> tomalak: Also, function application associates left.
14:33:02 <mauke> tomalak: the first token after 'do' sets the base indentation level
14:33:03 <jmcarthur> tomalak, or if you do use literal tabs, make them 8 spaces in your editor, because that's what haskell assumes
14:33:24 <ray> or don't use literal tabs
14:33:32 <tomalak> input isn't much good on codepad
14:33:42 <Twey> Postfix application is the logical choice
14:33:43 <dmwit> tomalak: So (putStrLn formatOutput fresult) parses as ((putStrLn formatOutput) fresult), not (putStrLn (formatOutput fresult)) as you probably intended.
14:33:44 <ray> i use tab characters in C, but not in haskell
14:33:45 <Twey> I agree
14:33:46 <Cale> Don't even just make them 8 spaces, just don't use them at all. ;)
14:33:47 <jmcarthur> i agree that you just shouldn't use literal tabs. far easier than fussing with editors
14:33:58 <hatds> Is this an existing typeclass?       func :: (a -> b) -> m a -> b
14:33:58 <Twey> Especially in functional programming
14:34:04 <dmwit> hatds: comonad
14:34:08 <Berengal> I thought tabs were one space in haskell...
14:34:11 <dmwit> hatds: err... kind of
14:34:13 <Berengal> Not that I ever use them
14:34:15 <Cale> hatds: What's m?
14:34:20 <jmcarthur> Berengal, 8
14:34:22 <hatds> Cale: m has kind *->*
14:34:26 <dmwit> ?src Comonad
14:34:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:34:39 <tomalak> dmwit: aha
14:34:41 <jmcarthur> category-extras ftw
14:34:42 <Cale> hatds: Oh, you mean that would be a method of a typeclass?
14:34:48 <hatds> yes
14:35:02 <Cale> hatds: It does look like something you could write if m is a comonad.
14:35:06 <kau> Twey: splitAt =<< (`div` 2) . length $ "hello"  looks very beautiful to me, i pasted it in ghci that says me "No instance for (Monad ((->) [Char]))"!!
14:35:20 <Twey> It's probably in Control.Monad
14:35:21 <FunctorSalad> Cale: agreed... I guess in math that doesn't heavily use composition, the change is not worth the price
14:35:22 <dmwit> kau: import Control.Monad.Reader
14:35:28 <Cale> Really, all you need is Copointed and Functor.
14:35:44 <Twey> dmwit: .Reader?  Why?
14:35:45 <kau> super
14:35:50 <Cale> kau: Or Control.Monad.Instances
14:35:54 <kau> it works
14:35:55 <dmwit> Twey: Or .Instances is fine, too.
14:36:00 <Cale> Twey: (->) e is isomorphic to Reader e
14:36:11 <mauke> (->) e is the naked Reader
14:36:14 <jmcarthur> all you really need is Copointed, not even Functor, right?
14:36:23 <Cale> No, you need Functor
14:36:24 <Twey> Oh right
14:36:27 <cads> dmwit, it's neat, given A, B, and S = intersection A B, we have  |flapzap A B| = |A|*|B| - |S|*(|S|+1)/2, |flapzap A A| = |A|*(|A| -1)/2
14:36:36 <kau> what are copointed and functors! how god.
14:36:42 <hatds> comonad would be (w a -> b) -> w a -> w b   ??
14:36:51 <jmcarthur> hatds, yes
14:36:58 <Cale> kau: Functors are things which support a map-like operation
14:37:04 <kau> yes
14:37:08 <Cale> kau: You know what map is on lists, yeah?
14:37:12 <Cale> :t map
14:37:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:37:17 <Cale> :t fmap
14:37:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:37:27 <kau> functors are generalisations of map, isnt it?
14:37:28 <hatds> (a -> b) -> m a -> b doesn't make a comonad then
14:37:30 <hatds> ?
14:37:38 <Cale> hatds: Not quite
14:37:43 <jmcarthur> func f = f . extract
14:37:45 <Cale> kau: Basically.
14:37:47 <Cale> kau: They
14:37:51 <jmcarthur> no Functor necessary there...
14:37:57 <tomalak> thanks guys
14:37:58 <tomalak> it's running now
14:38:05 <gio123> Cale: hi
14:38:07 <Cale> kau: They're type functions, that is, things which send types to other types, like [] does
14:38:22 <Cale> kau: together with an implementation of fmap which agrees with some laws
14:38:32 <gio123> Cale: hi
14:38:46 <Cale> Specifically, we should have:  fmap id = id  and  fmap (f . g) = (fmap f) . (fmap g)
14:38:48 <Cale> gio123: hi
14:38:58 <gio123> Cale: can u see pm for a minute
14:39:02 <kau> ok
14:39:18 <Vq^> we got a Cale greeter-bot?
14:40:03 <hatds> class Administrator m where admin :: (a -> b) -> m a -> b   --better name suggestions?
14:40:38 <Cale> Copointed is the class of functors f for which there is a function: coreturn :: f a -> a
14:41:18 <Cale> That is, for any value of type f a, there's a specific value of type a which is special that we can extract from it.
14:41:40 <Cale> Normal lists don't have this, because they might be empty
14:41:49 <hatds> admin f is not f . coreturn for this instance
14:41:52 <Cale> But nonempty lists do, because we can take the first element.
14:42:00 <kau> ok
14:42:25 <Cale> kau: Basically, these are fancy names for very simple things :)
14:43:26 <tomalak> ok, now .... http://codepad.org/FC2MEVLx how can I make the list comprehension iterate both xs and ys at the same time, rather than taking all combinations of their elements?
14:43:36 <Cale> hatds: What does it do?
14:43:38 <dmwit> tomalak: zip?
14:43:47 <dmwit> tomalak: Or even better, zipWith. ;-)
14:43:51 <kau> i see them as generalizations of simple things, with more rigor
14:45:48 <Twey> map -> zipWith -> zipWith3 -> zipWith4...
14:45:50 <hatds> Cale: good question...  it won't be polymorphic in a and b.  It would inspect the argument and result and possibly apply a transformation
14:45:53 <Twey> Anybody seeing a pattern here?
14:46:03 <hatds> hatds: both a pretransformation and a post
14:46:05 <hatds> er Cale
14:46:21 <dmwit> Twey: Yep, the pattern is you should be using ZipLists.
14:46:27 <Cale> hatds: ah, well... you can't define the class that way then can you?
14:46:34 * Twey laughs.
14:46:37 <hatds> yep doesn't look like I can :)
14:46:44 <mauke> zipN == transpose
14:46:55 <Twey> What is a ZipList?
14:46:58 <Twey> :t transpose
14:46:59 <lambdabot> forall a. [[a]] -> [[a]]
14:47:06 <Twey> Er
14:47:12 <tomalak> dmwit: played :)
14:47:15 <Twey> @src transpose
14:47:15 <lambdabot> transpose []             = []
14:47:16 <lambdabot> transpose ([]   : xss)   = transpose xss
14:47:16 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:47:22 <Cale> Twey: It's a newtype wrapper around lists which chooses the zipping instance for applicative
14:47:30 <kau> i have to go. Great thanks for all the explanations! i'll come back later with other weird newbie questions.
14:47:53 <dmwit> > (+) <$> ZipList [1, 2, 3, 4] <*> ZipList [5, 6, 7, 8]
14:47:54 <lambdabot>       No instance for (Show (ZipList a))
14:47:54 <lambdabot>        arising from a use of `show' ...
14:48:01 <dmwit> Oh, that's really stupid.
14:48:07 <mauke> it is
14:48:07 <dmwit> > getZipList $ (+) <$> ZipList [1, 2, 3, 4] <*> ZipList [5, 6, 7, 8]
14:48:09 <lambdabot>   [6,8,10,12]
14:48:10 <jmcarthur> yeah
14:48:35 <Cale> They've seemingly tried to ensure that the syntax is as impractical as possible ;)
14:48:44 <tomalak> for anyone who cares: http://codepad.org/Qq8EsCPP
14:48:45 <dmwit> indeed =P
14:49:14 <dmwit> tomalak: Nice!  On g and h you can get rid of the two base cases.
14:49:14 <Twey> Heh
14:49:22 <Twey> Well, it's not something one would need all that often.
14:49:45 <dmwit> tomalak: You might also like to use pattern matching in your list comprehension for h:
14:49:46 <Cale> Yeah, when your function is not recursive it's uncommon to need base cases :)
14:49:54 <dmwit> h xs ys = [x * y | (x, y) <- zip xs ys]
14:50:09 <mauke> > map sum $ transpose [[1, 2, 3, 4], [5, 6, 7, 8]]
14:50:10 <lambdabot>   [6,8,10,12]
14:50:22 <ray> > [id,(+1),(+2),(+3)] <*> [0,1,2,3]
14:50:23 <lambdabot>   [0,1,2,3,1,2,3,4,2,3,4,5,3,4,5,6]
14:50:33 <ray> the question is, would you need ziplists more than that
14:50:50 <Cale> I think the monad version is more important.
14:50:57 <hatds> ah .. (a->b)->m a -> b is almost Foldable...
14:50:58 <ray> so do i, actually
14:51:01 <ray> it makes more sense
14:51:10 <dolio> Clearly we should be using records, so we could write: (<*>) ZipList ((<$>) ZipList (+) [1,2,3,4]) [5,6,7,8]
14:51:21 <Cale> haha
14:51:30 <ray> even more sense if you think of <*> as a product, which the operator name sorta conveys
14:51:38 <Cale> Explicit dictionary passing. :)
14:51:44 <jmcarthur> > [x+y | x <- [1..5] | y <- [6..10]]
14:51:45 <lambdabot>   [7,9,11,13,15]
14:52:12 <dmwit> jmcarthur: ewww, I didn't know anybody actually *used* that extension... ;-)
14:52:41 <jmcarthur> what's ugly about it?
14:52:47 <Cale> It's a good extension when you need it.
14:52:54 <jmcarthur> not that i've had much occasion for it
14:53:19 <dmwit> > [(x, y, z) | x <- [1, 2], y <- [1, 2] | z <- [1, 2]]
14:53:21 <lambdabot>   [(1,1,1),(1,2,2)]
14:53:35 <dmwit> Would you have predicted that output?
14:53:38 <dmwit> I can't say I would have.
14:53:52 <Cale> I would
14:53:55 <jmcarthur> okay, so mixing , and | is bad
14:54:01 <jmcarthur> can be, anyway
14:54:05 <Cale> Each of the |'d branches is zipped together
14:54:20 <byorgey> I wouldn't have.
14:54:32 <Cale> So you get the first two elements of the cartesian product of [1,2] and [1,2] zipped with [1,2]
14:54:35 <jmcarthur> the | is heavier than the , in most fonts though. the associativity "looks" wrong
14:54:55 <jmcarthur> especially since the first | is a divider
14:55:02 <Cale> huh?
14:55:03 <dmwit> > [(x, y, z) | x <- [1, 2], y <- [1, 2] | z <- [1, 2, 3]]
14:55:05 <lambdabot>   [(1,1,1),(1,2,2),(2,1,3)]
14:55:10 <Cale> That *is* what it is
14:55:18 <jmcarthur> > [x | x <- [1..3]
14:55:19 <lambdabot>   <no location info>: parse error on input `;'
14:55:22 <jmcarthur> > [x | x <- [1..3]]
14:55:24 <lambdabot>   [1,2,3]
14:55:40 <Cale> the generators are separated into groups by | first
14:55:43 <Cale> and then by ,
14:55:48 <jmcarthur> oh
14:55:56 <jmcarthur> my mental parsing is backward backward!
14:55:58 <ray> looks ok to me
14:56:17 <jmcarthur> okay, looks okay then
14:57:17 <dmwit> > [(x, y, z) | x <- [1, 2], (y <- [1, 2] | z <- [1, 2, 3])] -- can you force the associativity to go the other way?
14:57:18 <lambdabot>   <no location info>: parse error on input `<-'
14:57:29 <dolio> > [ (x, y, z) | x <- [1,2] | y <- [1, 2] , z <- [1, 2] ]
14:57:31 <lambdabot>   [(1,1,1),(2,1,2)]
14:57:33 <jmcarthur> [(x, y, z) | x <- [1, 2] | y <- [1, 2] | z <- [1, 2, 3]] sure beats getZipList $ (,,) <$> ZipList [1, 2] <*> ZipList [1, 2] <*> ZipList [1, 2, 3], though
14:58:09 <dmwit> dolio: That's not the same.
14:58:32 <dmwit> ...as if the associativity had been different in the above.
14:58:55 <Cale> Hmm, if monad comprehensions are brought back, we should perhaps generalise the translation of this syntax as well
14:59:11 <Gracenotes> what.. extension is that/
14:59:18 <vixey> @undo [(x, y, z) | x <- [1, 2] | y <- [1, 2] | z <- [1, 2, 3]]
14:59:18 <lambdabot>  Parse error at "|" (column 26)
14:59:18 <Cale> Parallel list comprehensions
14:59:20 <Gracenotes> oh, parallel list comprehensions?
14:59:25 <Gracenotes> right. *remembers8
14:59:31 <jmcarthur> Cale, do you have a meaning in mind for monads?
14:59:36 <Gracenotes> is it parallel in a concurrent sense?
14:59:41 <Cale> Gracenotes: no
14:59:48 <dmwit> > [(x, y, z) | x <- [1, 2], (y, z) <- [(y, z) | y <- [1, 2] | z <- [1, 2, 3]]] -- yikes
14:59:50 <lambdabot>   [(1,1,1),(1,2,2),(2,1,1),(2,2,2)]
14:59:51 <Cale> It could be, but is not.
14:59:52 <jmcarthur> Gracenotes, on parallel arrays it is, but not on lists
14:59:58 <Gracenotes> we could probably also have applicative comprehensions too :)
15:00:23 <Cale> Well, that would just be a fancy version of applicative syntax... you couldn't do generators.
15:00:24 <jmcarthur> dmwit, yeah, it breaks down there
15:00:28 <ray> might be hard to get functor comprehensions
15:00:42 <dmwit> That's not a good argument against it, though.
15:00:46 <Gracenotes> Cale: or like the notation in the paper. I think we talked about this...
15:00:47 <dmwit> So I guess I'll give it a pass this time.
15:00:49 <Cale> yeah
15:00:57 <Gracenotes> do-for-applicatives
15:01:00 <jmcarthur> dmwit, would be nice if the extension supported parens like you tried to use, though
15:01:01 <mib_hrbxkwnz> hi all I am a beginner programmer studying haskell because I have to. However I just cant understand certain aspects of it.
15:01:15 <Cale> mib_hrbxkwnz: You've come to the right place, I think :)
15:01:26 <jmcarthur> although that might get weird with the commas... would look like tuples
15:01:29 <Cale> mib_hrbxkwnz: ask away :)
15:01:37 <jmcarthur> might be too ambiguous to parse
15:01:40 <dmwit> jmcarthur: Yeah, I don't know what the right syntax would be.
15:01:55 <jmcarthur> not using commas would be a start, methinks
15:02:00 <jmcarthur> some other symbol
15:02:07 <mib_hrbxkwnz> for example why does [x|x <-[1,2,3], y <- [1..x]] evaluate to [1,2,2,3,3,3]. The way i see it, i expected it to be 1,1,1,2,2,3
15:02:32 <mauke> > [y|x <-[1,2,3], y <- [1..x]]
15:02:33 <lambdabot>   [1,1,2,1,2,3]
15:02:35 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4892#a4892
15:02:39 <mm_freak> what's wrong with this?
15:02:39 <Cale> First, x takes 1, and then y takes every value in [1..1]
15:02:44 <Cale> which is just 1
15:02:44 <mm_freak> it goes into an endless loop
15:03:04 <jmcarthur> > [1] ++ [1,2] ++ [1,2,3]
15:03:05 <lambdabot>   [1,1,2,1,2,3]
15:03:07 <Cale> mib_hrbxkwnz: Perhaps it would help to see what it is when you replace x with (x,y)
15:03:16 <Cale> mib_hrbxkwnz: So that you can see both choices :)
15:03:39 <Cale> > [(x,y) | x <-[1,2,3], y <- [1..x]]
15:03:40 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
15:03:56 <dmwit> mm_freak: It has to calculate the whole list to calculate arr ! x.
15:04:04 <Cale> So you see, y takes each value from 1 up to x, and so each x will occur in the list x times.
15:04:09 <dmwit> mm_freak: The whole list depends on the value of arr ! x, so...
15:04:16 <Cale> mib_hrbxkwnz: Does that make sense now?
15:04:26 <mm_freak> dmwit: ok, i understand, thanks
15:04:36 <mib_hrbxkwnz> Cale: Im trying to figure it out, :D
15:04:59 <Cale> mib_hrbxkwnz: (because there are x elements in [1..x])
15:05:17 <mm_freak> dmwit: then i'd conclude it's very difficult to write the SoE declaratively, or is there just something i've overlooked?
15:05:47 <dmwit> mm_freak: Yes, it's very difficult.  I believe there are papers that try to do it and get it wrong.
15:05:51 <dmwit> mm_freak: So don't feel bad.
15:05:56 <BMeph> mib_hrbxkwnz: I like being contrary - why did you think it should be [1,1,1,2,2,3]? :)
15:05:59 <mm_freak> ok =)
15:06:00 <mib_hrbxkwnz> Cale: cheers i think im gonna try some tests. I have some idea cheers
15:06:46 <roconnor> Q: Is static typing a syntactic check or a semantic check?  Go!
15:06:55 <dmwit> Oh, give it a rest.
15:06:58 <roconnor> I'm going with technically synatictic.
15:07:00 <skorpan> semantic
15:07:08 <dmwit> So he used the wrong word; can't you critique his actual point instead?
15:07:19 <dmwit> His point was good: typing is used to rule out a large class of bug-ridden code.
15:07:20 <dolio> roconnor: You already know my answer, right?
15:07:32 <vixey> it's syntactic roconnor, but the meaning of 'syntax' is waay to subtle for these people
15:07:32 <roconnor> I have no idea what people's answers are.
15:07:47 <roconnor> vixey: that I can certainly agree with.
15:07:49 <dmwit> He just warped that into a bad thing by claiming that there is some correct code that nevertheless doesn't type (which is also true).
15:07:50 <vixey> they still think syntax means whether you write {}'s or use tabs
15:08:03 <dolio> roconnor: Are you sure? You weren't reading a blog where I explained it?
15:08:10 <dolio> In the comments.
15:08:28 <roconnor> dolio: possibly.  I don't do a very good job of linking haskell nicks to other places.
15:08:40 <Adamant> typing can't cover all correct code. this is true, so what's the big deal in arguing it?
15:08:55 <roconnor> dependent typing can cover all correct code.
15:09:10 <dolio> roconnor: Is dependent typing a syntactic check?
15:09:11 <dmwit> Dependent typing is also a real pain in the ass for anything sizable.
15:09:20 <roconnor> dolio: that's what I think.
15:09:22 <Adamant> roconnor: but dependent typing is effectively a proof method
15:09:24 <dolio> I can't decide on that one.
15:09:31 <roconnor> Adamant: yes.
15:09:59 <Adamant> roconnor: proofs are still hard, so we go shopping with more limited type systems instead typically
15:10:19 <roconnor> dolio: dependent types solve the semantic checking problem by transforming every semantic problem into a syntactic one, and then checking the synatax.
15:10:33 <roconnor> Adamant: yes.
15:10:53 <Saizan> typechecking is a syntactic process that gives informations about the semantic of expressions, if this makes it a "syntactic check" or "semantic check" depends on their definition
15:10:56 <dolio> roconnor: Hmm...
15:11:15 <roconnor> dolio: or that's how I see it.  I'm willing to hear arguments against.
15:11:58 <roconnor> the translation from semantics to syntax happens when the user writes syntaxs to describe their semantic desire.
15:13:19 <dolio> roconnor: Well, I don't really have arguments against it. It just seems that since it requires evaluating terms, that's more toward the semantic end of things. But I suppose such evaluation could be seen as deciding non-trivial equivalences of syntactic terms, in which case it's still syntactic.
15:13:33 <roconnor> dolio: hmm
15:13:49 <roconnor> dolio: interesting point
15:14:52 <mib_hrbxkwnz> [x|x<-[1,2,3],y<-[1..x]] <---- in this what does the "|" do?
15:15:13 <Cale> mib_hrbxkwnz: It separates the generic element of the list from the generators
15:15:15 <dmwit> It just separates the term being evaluated from the bounds it's being evaluated in.
15:15:17 <ray> separates the pattern and the comprehensy part
15:15:25 <Cale> mib_hrbxkwnz: It's just a piece of punctuation
15:15:49 <dolio> roconnor: I haven't thought about it very thoroughly, though. Is the normal form of an expression a syntactic object or semantic object, for instance?
15:15:50 <dmwit> In Haskell, it can sometimes be hard to tell what's syntax and what's a function. =)
15:16:07 <Cale> > [(x,y,x+y) | x <- [1,2,3], y <- [4,5]]
15:16:08 <dmwit> Here, | is just syntax. =)
15:16:09 <lambdabot>   [(1,4,5),(1,5,6),(2,4,6),(2,5,7),(3,4,7),(3,5,8)]
15:16:12 <mib_hrbxkwnz> im pretty good at programming (or so i thought) but haskell is just not making any sense *feel like crying*
15:16:14 <roconnor> dolio: I'd still say syntax
15:16:26 <Cale> mib_hrbxkwnz: What languages have you used?
15:16:33 <roconnor> dolio: but I fear I might I think there is no semantics :)
15:16:35 <ray> we could probably make if then else into a function by defining constants then and else
15:16:39 <dolio> Heh.
15:16:39 <roconnor> just synatx
15:16:45 <Cale> mib_hrbxkwnz: For the most part, programming in Haskell can be like learning to program all over again.
15:16:49 <mib_hrbxkwnz> Cale: Java, Pascal PHP and others
15:16:59 <mauke> nothing with first class functions?
15:17:05 <Cale> mib_hrbxkwnz: Yeah, those will mostly get in the way. ;)
15:17:06 <dmwit> ray: Not quite... we'd always need more parentheses.
15:17:09 <vixey> semantics is mostly a buzzword these days
15:17:16 <dmwit> ray: (then and else act as expression separators.)
15:17:27 <ray> stupid if then else
15:17:49 <Cale> mib_hrbxkwnz: However, if it helps, you can imagine that each of the generators (the things which look like x <- list) is a for-each loop, and the thing before the | is what goes inside
15:17:51 <roconnor> vixey: semantics seems kinda useful when you want to make/talk about abstract data types.
15:18:03 <mib_hrbxkwnz> Cale: I kind of understand the concept of haskell and I also get how its meant to be implemented but I dont get how the compiler is working, how its evaluating things and such.
15:18:14 <roconnor> vixey: but maybe with dependent types you don't need to make abstract data types.  You just make the damn type.
15:18:14 <dmwit> > let if' p _ t _ f = if p then t else f; then' = (); else' = () in if' True then' 3 else' 4
15:18:16 <lambdabot>   3
15:18:35 <Cale> mib_hrbxkwnz: So [x | x <- [1,2,3], y <- [1..x]] is a little bit like  for each x in [1,2,3] { for each y in [1..x] { add x to the list } }
15:18:57 <Cale> But that's... not very close to how it actually *works*
15:19:08 <gio123> Cale: can u see pm for a minute
15:19:12 <Cale> gio123: okay
15:19:34 <mib_hrbxkwnz> Cale: once again ill take a minute to soak that in, thanks alot.
15:20:29 <hatds> mib_hrbxkwnz: this is what it what did the trick when I was learning comprhensions http://www.haskell.org/tutorial/monads.html
15:20:42 <hatds> ctrl+f for the example that starts with "different syntax for the same thing"
15:21:14 <mib_hrbxkwnz> hatds: thanks I appreciate the help.
15:21:52 <sm> morning all
15:23:31 <sm> "The utf8-string package provides operations for encoding UTF8 strings to Word8 lists and back" - in other words, it decodes UTF8 strings to unicode represented as [Word8] and vice versa ?
15:23:54 <Botje> yes
15:24:07 <Botje> err
15:24:11 <Botje> wait :)
15:24:12 <gio123> Cale: ok, pm :)
15:24:23 <Botje> I think they mean unicode strings to word8 lists and back
15:24:48 <Botje> also, it has UTF8-enabled versions of putStrLn and firends
15:25:04 <ray> a utf8 string is a word8 list, just not every word8 is necessarily a whole character
15:25:16 <Cale> hatds: Most people learn about list comprehensions before do notations and >>= though
15:25:49 <Cale> So I'm not sure how useful it will be for mib_hrbxkwnz
15:26:03 <hatds> oh
15:26:14 <dmwit> sm: I think it decodes UTF8 strings to unicode represented as String and vice versa.
15:26:18 <Botje> i think not learning list comprehensions until after the list monad is introduced makes sense
15:26:30 <Botje> list comprehensions are pretty confusion compared to map & filter
15:26:47 <Botje> *confusing
15:27:18 <ray> i think list comprehensions are pretty simple - not even any passing around of functions like with map
15:27:21 <hatds> I think so too, list comprehensions are special syntax over something "simpler"
15:27:33 <hatds> er, agreeing with Botje :)
15:28:04 <mib_hrbxkwnz> Cale: With the example you gave me, that would produce 1,1,1,2,2,3, not 1,2,2,3,3,3. ill assume im still not understanding something though :(
15:28:13 <Cale> mib_hrbxkwnz: No it wouldn't.
15:28:23 <vixey> > join replicate =<< [1..]
15:28:25 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
15:28:26 <Cale> mib_hrbxkwnz: perhaps you're confused about what [1..x] means?
15:28:32 <Cale> > [1..1]
15:28:34 <lambdabot>   [1]
15:28:36 <Cale> > [1..2]
15:28:38 <lambdabot>   [1,2]
15:28:40 <Cale> > [1..5]
15:28:42 <lambdabot>   [1,2,3,4,5]
15:29:05 <mib_hrbxkwnz> Cale: I know what [1..3] means but its when "x" xomes into play i get confused.
15:29:13 <mib_hrbxkwnz> comes*
15:29:14 <dmwit> > map (\x -> [1..x]) [x | x <- [1..3]]
15:29:16 <lambdabot>   [[1],[1,2],[1,2,3]]
15:29:17 <mauke> > let x = 1 in [1..x]
15:29:19 <lambdabot>   [1]
15:29:19 <Cale> mib_hrbxkwnz: So [1..3] has 3 elements, yeah?
15:29:30 <mib_hrbxkwnz> Cale: yes.
15:29:32 <Cale> mib_hrbxkwnz: and [1..5] has 5
15:29:36 <mib_hrbxkwnz> Cale: 1,2,3
15:29:40 <mib_hrbxkwnz> Cale: yes.
15:29:41 <Cale> So in general, [1..x] will have x elements
15:29:54 <Cale> (except stupid cases like x being negative ;)
15:29:54 <mib_hrbxkwnz> Cale: Yes
15:30:08 <Cale> So the number of values which y will take will be x
15:30:16 <mib_hrbxkwnz> Cale: but what exactly IS x?
15:30:22 <mauke> a local variable
15:30:25 <Cale> It's the first thing we choose
15:30:48 <mauke> foreach x in [1..3] { foreach y in [1..x] { yield x } }
15:30:52 <Cale> In [x | x <- [1,2,3], y <- [1..x]], we pick x from [1,2,3] in each possible way
15:31:02 <mib_hrbxkwnz> Cale: yeah but from what im understanding the expression i keep trying should be 1,1,1,2,2,3 not 1,2,2,3,3,3
15:31:06 <Cale> and then we pick y from [1..x] in each possible way
15:31:21 <mauke> mib_hrbxkwnz: how do you get 1,1,1,2,2,3?
15:31:21 <Cale> Why do you think there should be three 1's?
15:31:58 <mib_hrbxkwnz> because if its doing what x is then it will first do 1 then 1,2 then 1,2,3 therefore 1,1,1,2,2,3,
15:32:07 <Cale> So, first, we pick x = 1, and then we need to pick y from [1..1]
15:32:12 <Cale> and there's only one way to do that
15:32:14 <mib_hrbxkwnz> ill take it im still missing the point though :(
15:32:15 <Cale> y = 1
15:32:20 <mauke> mib_hrbxkwnz: that's right, but we're not returning y
15:32:29 <mauke> which I think is what's confusing you
15:32:41 <Cale> and so x = 1 becomes the first element of the list, and there are no more choices for y, so we pick the next possibility for x
15:32:47 <Cale> which is x = 2
15:32:57 <Cale> and then y is selected from [1..2]
15:33:11 <Cale> and there are two possibilities for y, so x goes into the list twice
15:33:37 <Cale> That is, 2 goes into the list twice
15:33:41 <Cale> yeah?
15:33:43 <mauke> > [y | x <- [1..3], y <- [1..x]]  -- does this make sense to you?
15:33:44 <lambdabot>   [1,1,2,1,2,3]
15:33:58 <mib_hrbxkwnz> Cale: I think i get it now
15:34:03 <dmwit> mib_hrbxkwnz: The y's will be drawn from [1], [1,2], and [1,2,3], exactly as you said, but then we throw away y and return x each time!  So, since x is constant during each of these, they turn into [1], [2,2], and [3,3,3].
15:34:14 <dmwit> mib_hrbxkwnz: Together, this gives us the [1,2,2,3,3,3] result.
15:34:18 <mib_hrbxkwnz> Cale: y isnt 1,2,3 it is 3
15:34:48 <mauke> ?
15:34:52 <Cale> mib_hrbxkwnz: hm?
15:34:53 <mib_hrbxkwnz> and it will loop around 2 times for it to contain 2 values and 3 times when it contains 3 values
15:35:23 <Cale> mib_hrbxkwnz: Well, when x = 3, we'll have y being 1, then 2, then 3
15:35:34 <Cale> Let's look at the choices for x and y at the same time...
15:35:45 <Cale> > [(x,y) | x <- [1..3], y <- [1..x]]
15:35:47 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
15:35:57 <mib_hrbxkwnz> so this is whats happening 1..1 = 1 -- 1..2 = 2 (done twice) -- 1..3 = 3 (done 3 times) ?
15:36:15 <Cale> Well... it's putting the *x* values into the list
15:36:22 <Cale> and discarding the y values
15:36:32 <mauke> > [x | x <- [1..3], y <- [0, 0]]
15:36:32 <mib_hrbxkwnz> i see
15:36:34 <lambdabot>   [1,1,2,2,3,3]
15:36:44 <dmwit> Err... [1..1] = [1] (a list with one element), [1..2] = [1,2] (a list with two elements), [1..3] = [1,2,3] (a list with three elements)
15:36:46 <Cale> so while y is changing, it doesn't matter what it's changing to, really, just how many values it's taking on
15:36:48 <mauke> > [x | y <- [0,0], x <- [1..3]]
15:36:49 <lambdabot>   [1,2,3,1,2,3]
15:36:50 <mib_hrbxkwnz> So what I thought isnt correct although it is similiar to whats actually happening
15:37:11 <mib_hrbxkwnz> I think i understand now
15:37:32 <mib_hrbxkwnz> Gonna go do some tests to make sure im not still missing the point
15:37:55 <mib_hrbxkwnz> btw you bunch are the best, never had such helpful guys on an irc channel.
15:38:15 <mauke> (satisfied customer)++
15:38:17 <Cale> :)
15:38:27 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
15:38:29 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
15:38:34 <Cale> ^^ that might also help
15:38:54 <Cale> It's just a little bit simpler.
15:39:12 <dmwit> > [(x, y) | x <- [1,2,3], y <- [False, True]]
15:39:14 <lambdabot>   [(1,False),(1,True),(2,False),(2,True),(3,False),(3,True)]
15:39:25 <mauke> > [[x,y] | x <- "abc", y <- "XY"]
15:39:26 <lambdabot>   ["aX","aY","bX","bY","cX","cY"]
15:39:34 <mib_hrbxkwnz> Yeah I understand. I cant express how happy i am now that i got that out of the way.
15:39:56 <mauke> > [[x,c,y] | x <- "abc", c <- "*", y <- "XY"]
15:39:57 <lambdabot>   ["a*X","a*Y","b*X","b*Y","c*X","c*Y"]
15:40:28 <dmwit> :t intercalate
15:40:30 <lambdabot> forall a. [a] -> [[a]] -> [a]
15:40:57 <dmwit> > intercalate "+" . zipWith (:) "abc" $ ["x^2", "x", ""]
15:40:59 <lambdabot>   "ax^2+bx+c"
15:41:32 * dmwit decided not to confuse the issue by using the zip comprehension
15:41:43 <mauke> > a*x^2 + b*x + c
15:41:44 <lambdabot>   a * (x * x) + b * x + c
15:41:55 <Manyfold> :t zipWith
15:41:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:42:17 <Botje> i keep forgetting it exists
15:42:22 <Botje> do you often use it?
15:42:28 <Botje> (zip comprehension, that is)
15:42:32 <dmwit> Nope.
15:42:53 <dmwit> Today was the first time, and that was just here in #haskell. =P
15:42:57 <Botje> :)
15:43:04 <Botje> another successful feature!
15:44:37 <FunctorSalad> wtf, how can adding a type signature to a subexpression change the inferred type of a function to something that doesn't even unify with the inferred type before the annotation
15:45:01 <Cale> FunctorSalad: Is the MR on or off?
15:45:11 <Manyfold> FunctorSalad: you are still alive?
15:45:24 <Cale> FunctorSalad: and how many fancy type system features are you using?
15:45:46 <FunctorSalad> Cale: sorry nevermind, one of the types was a bogus emacs haskell-mode cache entry
15:45:59 <Botje> aww
15:46:09 <FunctorSalad> thought I was losing it.
15:46:13 <dmwit> I've had times where it couldn't infer a type, but would accept a type annotation.
15:46:18 <dmwit> I sure thought I was losing it then.
15:46:22 <Cale> I can imagine that there are cases where that happens though
15:46:36 <FunctorSalad> (haskell mode caches the types obtained by hotkey)
15:46:46 <Saizan> dmwit: that's not so surprising
15:47:25 <mauke> your task, should you choose to accept it, is to write concatMap using a list comprehension
15:47:29 <Saizan> e.g. it's the norm with polymorphic recursion
15:47:36 <FunctorSalad> Cale: really? I thought it's impossible even with extensions
15:47:42 <dmwit> Saizan: It surprised me.  The whole point of Hindley-Milner is that it gives a principal type to every typable term.
15:48:17 <Cale> dmwit: But Haskell's type system isn't plain HM
15:48:23 <Saizan> dmwit: except for polymorphic recursion, and haskell is more complex than HM anyway
15:48:26 <dmwit> No indeed.
15:48:30 <Cale> And almost any extension of HM breaks that property
15:48:34 <dmwit> Haskell's type system isn't Hindley-Milner.
15:48:37 <FunctorSalad> dmwit: local universals break it I think
15:48:41 <FunctorSalad> (one of the most common ones)
15:48:52 <Apocalisp> @undo [ (x, y) | x <- xs | y <- ys ]
15:48:52 <lambdabot>  Parse error at "|" (column 20)
15:48:55 <Apocalisp> meh
15:49:08 <tomalak> dmwit: thanks again
15:49:09 <Cale> Apocalisp: That's unfortunate
15:49:17 <Apocalisp> @undo [ (x, y) | x <- xs ; y <- ys ]
15:49:18 <lambdabot>  Parse error at ";" (column 20)
15:49:25 <Cale> @undo [ (x, y) | x <- xs , y <- ys ]
15:49:25 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) ys) xs
15:49:31 <Apocalisp> comma!
15:49:43 <Cale> I get that wrong reasonably often too...
15:49:53 <Apocalisp> <-- every time
15:49:54 <FunctorSalad> elimAnyNum k (AnyNum x) = k x
15:49:58 <FunctorSalad> IIRC that doesn't infer?
15:50:02 <Axman6> > [(x,y) | x <- [1..3] | y <- [6..8]]
15:50:03 <lambdabot>   [(1,6),(2,7),(3,8)]
15:50:08 <Cale> I think it was ; in Miranda or early versions of Haskell or something
15:50:11 <Axman6> i.e: zip
15:50:13 <dmwit> mauke: concatMap f xs = [p | x <- xs, p <- f x] -- ?
15:50:16 <FunctorSalad> (data AnyNum = forall t. Num t => AnyNum t)
15:50:59 <mauke> dmwit: you win!
15:55:48 <mib_hrbxkwnz> anyone got a link which explains in layman terms what polymorphic, higher-order, overloaded and curried functions are?
15:56:15 <mauke> polymorphic = doesn't care about the exact types
15:56:37 <mauke> e.g. length gives you the number of elements in a list, no matter if they're numbers or strings or whatever
15:56:56 <mib_hrbxkwnz> oh cheers
15:57:31 <mauke> higher-order = taking or returning other functions
15:57:40 <Axman6> and lists are polymorphic becayse they don't care what they have inside them, as lon g a they're all the same type
15:57:49 <Axman6> u*
15:58:38 <mauke> map is a polymorphic higher-order function
15:58:41 <jeffwheeler> > intercalate "abc" ["d", "e"]
15:58:42 <lambdabot>   "dabce"
15:58:51 <Axman6> does haskell really have overloading?
15:58:58 <mauke> yes, with classes
15:59:33 <mauke> > map (+1) [1,2,3]
15:59:34 <lambdabot>   [2,3,4]
15:59:42 * Axman6 doesn't really feel that is overloading
15:59:42 <mauke> > map (*3) [1,2,3]
15:59:43 <lambdabot>   [3,6,9]
15:59:54 <ray> then what is overloading?
16:00:26 <Axman6> i take the term to mean things like using + to join strings etc. (+) does the same thing for all Num instances
16:00:52 <ray> so you think only stupid overloading is overloading?
16:01:06 <Axman6> yes :P
16:01:11 <jeffwheeler> You could do (+) with strings.
16:01:19 <ray> well, C++ can make one think that
16:01:21 <hatds> you could define + to concatenate, but (+) is a part of the Num class so you'd have to have sensible definitions of the other arithmetic operations
16:01:31 <ray> you could probably contort an instance Num [Char]
16:01:40 <ray> but..
16:01:44 <mauke> *> "foo" + "bar"
16:01:44 <mauke> "\200\199\216\209\208\225\209\208\225"
16:01:49 <hatds> so Num is a way of allowing overloading in a restricted context -- just for arithmetic like things
16:02:02 <mib_hrbxkwnz> if a function returns a list does that make it polymorphic then? e,g take n [a] ?
16:02:10 <ray> perversions aren't idiomatic in Haskell, but they are in C++
16:02:11 <ray> i guess
16:02:16 <Gracenotes> eh. I am suspicious of non-numerical Nums
16:02:23 <Axman6> me too
16:02:27 <mauke> mib_hrbxkwnz: not per se, but take is polymorphic
16:02:35 <Gracenotes> even things like numerical vectors, or matrices
16:02:38 <ray> :t take
16:02:39 <lambdabot> forall a. Int -> [a] -> [a]
16:02:49 <Axman6> Num [Char] sounds like class overloading
16:02:54 <mib_hrbxkwnz> mauke: How can I distinguish a function is or isnt polymorphic then?
16:03:07 <mauke> mib_hrbxkwnz: if its type contains lowercase names
16:03:29 <monadic_kid> mib_hrbxkwnz: id is polymorphic function
16:03:31 <monadic_kid> :t id
16:03:32 <lambdabot> forall a. a -> a
16:04:00 <mib_hrbxkwnz> thanks
16:04:07 <mauke> :t isUpper
16:04:08 <lambdabot> Char -> Bool
16:04:11 <mauke> monomorphic
16:04:20 <hatds> :t (+)
16:04:21 <lambdabot> forall a. (Num a) => a -> a -> a
16:04:23 <hatds> overloaded
16:04:41 <Gracenotes> er. not quite an overloaded function
16:04:55 <hatds> what would you call it
16:04:56 <Gracenotes> overloaded functions in languages like C++ and Java are really just hacks
16:05:15 <Gracenotes> the bytecode or object code has different generated names for each of the signatures
16:05:15 <ray> we shouldn't give up the word "overloaded" just because c++ sucks
16:05:30 <Baughn_> Gracenotes: Oh, sure. Have you ever run nm on a GHC object file?
16:05:42 <hatds> bounded polymorphic
16:05:44 <hatds> ?
16:05:54 <mauke> the report says (+) is overloaded
16:06:01 <Baughn_> Gracenotes: It's not /that/ hacky. C++ polymorphism has a lot in common with haskell's, except it's.. well, yes, very ad-hoc
16:06:42 <mib_hrbxkwnz> + is considered a function in haskell?
16:06:42 <Gracenotes> well, the internal implementation of typeclasses is rather nice
16:06:48 <monadic_kid> you need to distingush between type inferred ad-polymorphism to non type-inferred
16:07:02 <ray> yes, it's a function
16:07:05 <mauke> mib_hrbxkwnz: it is
16:07:13 <mib_hrbxkwnz> i see
16:07:17 <hatds> monadic_kid: meaning the functions defined in a typeclass and those that just use them?
16:07:26 <mib_hrbxkwnz> i guess what they say is true, its all functional.
16:07:26 <monadic_kid> and the former is non-trivial hence the existance of type classess
16:07:27 <FunctorSalad> Axman6: return and (>>=) don't do "almost the same thing" for different types, do they? ;)
16:07:27 <Gracenotes> overloading in C++ is just a way to have several functions with the same name that do entirely different things... you could rename them throughout and it would still work
16:07:39 <Baughn_> mib_hrbxkwnz: Not just a function, (+) is a typeclass member method
16:07:44 <Gracenotes> typeclasses actually do dynamic dispatch (except in cases the instance can be inferred)
16:07:47 <Baughn_> @src Num
16:07:47 <lambdabot> class  (Eq a, Show a) => Num a  where
16:07:48 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:07:48 <lambdabot>     negate, abs, signum     :: a -> a
16:07:48 <lambdabot>     fromInteger             :: Integer -> a
16:07:56 <hatds> yea, the mapping between other languages isn't good
16:08:26 <hatds> overloading in haskell (as I see the term often used for typeclass) is more like virtual functions/dynamic dispatch
16:08:28 <Baughn_> FunctorSalad: Eh, return does pretty much the same thing either way. >>=, now, I'll admit there's little structure there.
16:08:38 <ray> you *can* make pathological instances in haskell though
16:08:56 <mib_hrbxkwnz> the parser return 1 +++ return 2 what will it do?
16:09:03 <Saizan> even if there are dictionaries around i wouldn't call it dynamic dispatch either :)
16:09:12 <mib_hrbxkwnz> im trying to put it into hugs for a test keeps giving an erro,
16:09:14 <mib_hrbxkwnz> error*
16:09:18 <FunctorSalad> Baughn_: type inference for (>>=) regularly outsmarts me ;) (exaggerating)
16:09:22 <monadic_kid> Gracenotes: you realize that C++0x will have bounded quantification of parametic polymorphism as well, quite simiilar to type class mechnisim
16:09:30 <Gracenotes> yes, I've read about that.
16:09:52 <FunctorSalad> (I mean like in, you write (fmap.fmap.fmap.fmap) f x and it magically does what you want)
16:10:11 <sm> using ghci 6.10.2 in apple terminal, I can't paste a utf-8 string. Is this normal ?
16:10:19 <hatds> FunctorSalad: magically doing what you want is part of haskell, not typeclass :)
16:10:22 <hatds> *typeclasses
16:10:27 <ray> that's inference
16:10:28 <Saizan> mib_hrbxkwnz: you've to pass that to a parse or run function, depending on the library, to see what it'll do
16:10:30 <monadic_kid> Gracenotes: but this isn't to deal with original issue type inferred ad-hoc polymorphism which is what type classes where originally meant to solve
16:10:32 <sm> it works fine when not at the ghci prompt
16:10:33 <Gracenotes> monadic_kid: although don't templates currently have that? They'll compile by themselves in any case, but only for specific instances if the functions are valid
16:10:39 <ray> :t fmap.fmap.fmap.fmap
16:10:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
16:11:01 <Gracenotes> albeit, based on where objects of the type are allowed to be used, not on the type itself
16:11:07 <mib_hrbxkwnz> Saizan: ok thanks.
16:11:12 <monadic_kid> Gracenotes: thats not really bounding the range of types
16:11:27 <ray> you still have to infer the types of f..f3 before typeclass magic can occur
16:12:00 <ray> but when it does occur, it occurs with great force
16:12:10 <Gracenotes> monadic_kid: yes, true. It is similar at least. So this extension will use inheritance for parametric bounds? sort of like how Java does it?
16:12:25 <ray> C++0F
16:12:41 <FunctorSalad> don't get me wrong, I understand the involved instances in principle, but I mean the instance choice can build quite non-trivial programs somehow
16:12:48 <hatds> before they were talking about "concepts" in C++ as being different from inheritance I thought
16:13:11 <Gracenotes> I had seen a monad implementation..
16:13:15 <FunctorSalad> (I'm afraid that could be bad for readability sometimes...)
16:13:18 <ray> C++ is hard
16:13:34 <FunctorSalad> s/somehow/sometimes
16:13:50 <monadic_kid> Gracenotes: no its a lot more like type classes, it's completely compile-time bound, you don't implement interfaces you make a type a model of a *Concept* which is like type class and type class instances
16:13:52 <ray> C++ is hard sometimes, to paraphrase you and dick cheney
16:14:11 <Gracenotes> here we go: http://www.reddit.com/r/programming/comments/8bx33/a_comparison_of_c_concepts_and_haskell_type/
16:14:27 <ray> concept is a bad name, but i guess class was already taken
16:14:28 <Gracenotes> and the PDF, http://sms.cs.chalmers.se/publications/papers/2008-WGP.pdf, A comparison of C++ concepts and Haskell typeclasses
16:14:57 <Gracenotes> weird syntax
16:14:57 <ray> they could call it a classclass
16:15:18 <Gracenotes> I just took the final exam for my C++ class
16:16:11 <mib_hrbxkwnz> I have an exam for haskell coming up, and I didnt learn a single thing cos I thought it was gonna be like every other programming language >:(
16:16:14 <andyou> Exams tomorrow *shrugs* :(
16:16:16 <mib_hrbxkwnz> > : (
16:16:17 <Gracenotes> monadic_kid: well, it is somewhat of a bound. inheritance is an open form of polymorphism, but a bound nonetheless
16:16:17 <lambdabot>   <no location info>: parse error on input `:'
16:16:23 <hatds> before Haskell I *liked* C++... but now sheesh
16:16:24 <Gracenotes> so are typeclasses open
16:16:28 <ray> yes
16:16:56 * ahf is a big fan of both C++ and Haskell.
16:17:04 <Gracenotes> inheritance on the type level, not really the class level
16:17:09 <ray> before haskell i liked lisp :( :( :(
16:17:25 <monadic_kid> Gracenotes: but Concepts are more like type classses than dotnets method of bounded quantification
16:17:26 <Gracenotes> )))
16:17:32 <andyou> Lisp is nice.
16:17:34 <monadic_kid> Gracenotes: logically
16:17:37 <Twey> Lisps are nice.
16:17:57 <Gracenotes> hmm. Well, I haven't gotten into the C++0x feature list that much other than browsing the Wikipedia article :)
16:18:01 <FunctorSalad> is "concept" an actual C++ keyword?
16:18:13 <monadic_kid> FunctorSalad: not now in C++0x
16:18:26 <Gracenotes> which it should be noted is only a temporary name
16:18:31 <Gracenotes> C++0x, that is.
16:18:33 <Gracenotes> god it's ugly.
16:18:34 <FunctorSalad> monadic_kid: ah
16:18:41 <ray> concept had better be a temporary name too
16:18:48 <ray> actually, i don't care about c++, never mind
16:18:58 <hatds> soon to be C++1x or are things actually in motion?
16:19:13 <stroan> Were one to implement mandlebrot in Haskell, is there any particularly straightforward way of doing the image generation and displaying?
16:19:14 <monadic_kid> no C1x takes that name not C++
16:19:18 <ray> the joke is that they can go up to C++0F
16:19:37 <ray> stroan: there's some graphics stuff on hackage, not too familiar with any of it myself
16:19:54 <monadic_kid> stroan: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
16:20:36 <ray> i *should* be familiar with it but i'm putting it off
16:20:43 <stroan> thanks :) I was doing with SDL bindings, but plotting pixels wasn't particularly nice.
16:21:02 <monadic_kid> isn't there SDL_gfx for primitives?
16:21:23 <FunctorSalad> I thought there was no more efficient way for mandelbrot than drawing single pixels, stroan
16:21:29 <monadic_kid> stroan: not just SDL there anyways, have a look you might find something
16:21:44 <FunctorSalad> hmm nvm maybe you can make estimates for the circular regions
16:21:55 <ray> i never did mandelbrot, but my understanding is that it's just a set of points on the complex plane
16:22:19 <FunctorSalad> yes
16:22:35 <kpreid> the common depictions have more info than just the points, though
16:22:38 <monadic_kid> so anyways the next standard revision for C is called C1x
16:22:40 <stroan> FunctorSalad: oh I know there is no more efficient way, without exploiting occassional symmetries. Just the implementation details
16:22:41 <kpreid> they include the 'escape speed'
16:22:42 <hatds> can't really avoid pixels, but you don't have to draw pixels one at a time
16:22:51 <ray> kpreid: that's what the colors are, right?
16:22:56 <idnar> by the time C++0x becomes a real thing, nobody will be using C++ anymore :P
16:22:59 <kpreid> ray: yes
16:23:09 <kpreid> it's how many iterations it took to determine the point is *not* in the set
16:23:11 <monadic_kid> idnar: not quite
16:23:17 <stroan> kpreid: distance estimation is the other way of doin git
16:23:20 <kpreid> (I don't know how they do the smoothing)
16:23:22 <kpreid> oh?
16:23:36 * kpreid is curious but ignorant
16:23:37 <stroan> yeah, you can estimate the distance from a point on the place to the set
16:23:38 <idnar> monadic_kid: we're already down to like 50 surviving C++ programmers
16:24:01 <ray> what if the swine flu hits them?
16:24:04 <stroan> there are general results for julia fractals, in quaternion space as well
16:24:21 <monadic_kid> idnar: in the industry i work in it's going to be C++ for a very long time
16:24:21 <idnar> mmmmmm fractals
16:24:34 <hatds> I always hear C++ is still dominant in video games
16:24:42 <monadic_kid> yes it is
16:24:44 <mib_hrbxkwnz> monadic_kid: what industry do you work in?
16:24:55 <idnar> hatds: I'm pretty sure that's no longer true
16:25:04 <monadic_kid> ...
16:25:19 <idnar> well, it's probably true in one sense
16:25:23 <mib_hrbxkwnz> i though C was also just as dominant in video game development
16:25:29 <ray> haskell should be dominant in game development
16:25:36 <monadic_kid> idnar: i'll tell you for a fact it is
16:25:41 <idnar> but there's so much gaming happening on platforms that don't even have C++
16:25:52 <ray> hm?
16:25:57 <stroan> ?
16:25:58 <ray> i don't get that last sentence at all
16:26:19 <idnar> for example, J2ME on cellphones, or flash in web browsers
16:26:40 <ray> those are pretty small niches
16:27:05 <idnar> ray: they're shallow niches, but they're very wide
16:27:12 <idnar> so it really depends on what metrics you want to focus on
16:28:07 <ray> could be. i'll confess that flash games are way off my radar
16:28:14 <ray> mobile phone games not quite, but still
16:28:33 <idnar> you're not going to find many people playing flash games for 12 hours a day
16:28:54 <stroan> >_>
16:28:57 * FunctorSalad waits for someone to protest
16:29:05 <ray> i protest
16:29:08 <idnar> but there are a lot more people playing a silly little flash game during their lunch hour than there are, say, WoW players
16:29:15 <persica> Random question: What do people tend to use for their indent width with Haskell? 2? 4? 8?
16:29:18 <dmwit> Nope, but I bet there's still a buttload of hours logged in Flash games.
16:29:31 <dmwit> persica: I like four.
16:29:37 <ray> i like whatever lines up
16:29:44 <persica> dmwit: I was using 2, I seem to be using 4 now, as it looks better.
16:29:50 <lament> persica: the usual convention is to line things up, i think
16:30:03 <persica> ray: This is in general, such as when you put a newline after a "do"
16:30:24 <FunctorSalad> I like whatever still yields legal layout without forcing me to reindent two pages ;)
16:30:26 <persica> I line up lists and such.
16:30:27 <hatds> tim sweeny of epic games has these slides about game progamming that covers why they need:  data parallelism, STM, dependent types, ST monad
16:30:48 <ray> tim sweeney wrote ZZT, so i respect him
16:30:53 <ray> i don't put newlines after a do
16:30:54 <ray> :/
16:31:15 <hatds> I use literal tabs :)
16:31:26 <hatds> forces you to be tab insenstive
16:31:35 <pejo> hatds, I think PL people should more look at his problems, rather than solutions.
16:31:56 * persica googles tim sweeny
16:32:11 <ray> the problem with tabs is that the traditional meaning is "advance until the column is a multiple of 8" which is pretty sdoahgodishag
16:32:38 <ray> ok for writing crontab files
16:32:45 <FunctorSalad> hehe
16:32:47 <persica> ray: I agree.  I was just looking at how terrible it was.  I'd like my lines to line up with the first character after an = for a function, and then further indentation be 4 further in from that.
16:33:02 <persica> e.g. in a where.
16:33:13 <monadic_kid> hatds: unforunately that won't help much when it comes to console dev unless the compiler targets C/C++, it's in the license requirements that you must use the offical dev kit compilers to generate binaries for sale. Also I think Tim was more interested in something to replace UnrealScript because a new language just wouldn't work for there cross-platform engines
16:33:14 <persica> But of course I hit <tab> and I never know how far in it will go.
16:33:15 <hatds> the slides can be found on google: tim sweeney next mainstream
16:33:50 <ray> one of these days i'll get my act together and write that library i want to write
16:33:53 <pejo> monadic_kid, there are fp-compilers that target C-compilers though.
16:34:10 <hatds> like.. ghc?
16:34:12 <persica> monadic_kid is right.  The licenses for console development are insanely tight.
16:34:38 <pejo> hatds, well, kind of. My impression is that you want the evil mangler in that case.
16:34:46 <dmwit> I think Haskell would be a great scripting language.
16:34:46 <ray> i was wishing there was a haskell .net so it would be concievable to develop for xbox 360 in haskell
16:34:49 <ray> just the other day
16:35:01 <FunctorSalad> does that license mean you can compile haskell to c and then go with their "dev kit"?
16:35:08 <stroan> persica: Wii, and XBox dev have opened up a fair bit
16:35:15 <dmwit> ray: Well, there's a .Net interop stuff on the wiki, have you tried it?
16:35:30 <dmwit> ray: There's at least two libraries for it, dunno whether either of them is really usable, though.
16:35:33 <ray> well, i'm not actually in a position to develop for xbox 360 at the moment
16:35:34 <monadic_kid> FunctorSalad: technically but there is probably a requirement that even that isn't allowed
16:35:40 <persica> FunctorSalad: Their hardware APIs are often very closed so you might have trouble writing a good wrapper.
16:35:42 <ray> i saw one thing that was totally abandoned and useless
16:35:49 <FunctorSalad> hmm
16:36:27 <persica> At my wife's company they had to abandon a wii project because the wiimote technically had the hardware to do it, but Nintendo's API at the time didn't let them get that data.
16:36:40 <monadic_kid> I had this discussion the other day with my lead at work, talking about ATS since it targets C
16:36:42 <kpreid> persica: are you allowed to be more specific?
16:37:07 <kpreid> do you mean the camera blob tracking (vs where-on-screen coordinates)?
16:37:37 <persica> kpreid: I can't remember all the details (this was about a year ago), and it had something to do with the accelerometers.
16:37:49 <kpreid> huh, I would have thought that data was raw
16:38:37 <bd_> I haven't seen the nintendo API, but maybe it only gives cooked impulse+orientation?
16:38:39 <persica> The programmers at that company bitched that Nintendo didn't release some parts of their API until some in-house developed games used those functions in production.  They thought it was an unfair advantage.  Granted, I don't know the specifics, so it's just hear-say
16:39:54 <persica> But anyway... someone would need to write a high-performance game in Haskell before it is taken seriously.
16:40:28 <hatds> if I could move to a cave I probably would
16:40:36 <hatds> no time to do everything I want
16:40:59 <FunctorSalad> I guess the problem is that for games you need someone with money to take it seriously first
16:41:04 <persica> hatds: never enough time to explore all problem spaces.
16:41:14 <bd_> There's always the homebrew scene :)
16:41:24 <persica> FunctorSalad: I'm not sure that's true.  A demo could bring in the money.
16:41:25 <ray> i just need to move to a new apartment to be able to work
16:41:30 <ray> my requirements are much cheaper
16:41:59 <persica> OMG! These can't be the Tim Sweeney slides.
16:42:07 <persica> They're in comic sans with some crayon theme.
16:42:19 <hatds> SPJ has done that before IIRC
16:42:37 * FunctorSalad just wrote [|(:)|] in actual code
16:42:46 <ray> you deserve a medal
16:43:00 <persica> Er, what does that actually do?
16:43:11 <ray> a medal shaped like [|(:)|]
16:43:19 <persica> Looks like list comprehension with cons?
16:43:20 <FunctorSalad> persica: quotes (:)
16:43:26 <FunctorSalad> ray: :p
16:43:35 <monadic_kid> not only that you would need to convince the companies behind the consoles as well as make game the solid millions before it gets taken seriously. Apple is doing it with the iphone in some sense, seems to be a lot of buzz around Objective-C lately
16:43:35 <FunctorSalad> persica: (for template haskell)
16:43:41 <persica> Oh...
16:43:48 <persica> templates... haven't run into that yet.
16:44:02 <ray> objective c has been bouncing around apple since steve jobs returned though
16:44:12 <mib_hrbxkwnz> I cant believe I have haskell book, which has no answers for its excercises :(
16:44:13 <hatds> eh, I'm fine if the world doesn't recognize haskell's greatness
16:44:21 <ray> avoid popularity &c
16:44:28 <persica> mib_hrbxkwnz: Which book?
16:44:32 <ray> but game development in it would be nice
16:44:39 <ray> er, console game development
16:44:52 <persica> hatds: I like my languages to be popular enough that a job exists that uses that language ina  field I'm interested in.
16:44:52 <mib_hrbxkwnz> persica: programming in haskell by graham hutton
16:45:03 <ray> it might just be my ancient PC, but i think console gaming is where it's at
16:45:33 <mib_hrbxkwnz> i would love to be a console game dev, but i know im too stupid for that to happen : |
16:45:36 <persica> ray: If I recall, consoles are where the sales are, PC is where the technology is.
16:45:43 <ray> come to think of it, i play arcade ports..
16:45:51 <persica> mib_hrbxkwnz: You should meet some of the people my wife used to work with. :P
16:46:13 <mib_hrbxkwnz> persica: as much I know that isnt going to happen, i wish it I could :)
16:46:18 <ray> plenty of console game developers are stupid, they just don't develop anything noteworthy
16:46:35 <ray> plenty of * are stupid, they just don't do anything noteworthy
16:46:43 <mib_hrbxkwnz> but i bet every kid wants to be a game dev so its gonna have the brightest guys applying for jobs
16:47:05 <ray> some people want to be game developers until they figure out what it involves
16:47:10 <hatds> no one wants to be a dev, they want to be a game designer
16:47:12 <hatds> yea
16:47:15 <persica> Actually, the game industry typically underpays and overworks its employees.
16:47:27 <mib_hrbxkwnz> oh my i still dream of being a game director hehe
16:47:36 <mib_hrbxkwnz> that would be such a gravy train job
16:47:39 <persica> And there are lots of people trying to be game programmers with no knowledge of programming.
16:47:57 <persica> it's really not all that glamorous.
16:48:07 <persica> Particularly during crunch weeks... which turn into cruch months.
16:48:29 <hatds> not many professions don't have some sort of "overworked/underpaid" problems, but yea everyone says video games are pretty bad
16:48:44 <mib_hrbxkwnz> yeh I read some articles and it doesnt sound too pleasant but I dont want to waste all my time having played games to not make it something of my life
16:49:03 <stroan> I got into CS out of a desire to end up there. I had programmed games before college, so I knew what I was getting myself in for, but there are much more interesting areas.
16:49:14 <stroan> As I'm slowly finding out
16:49:29 <mib_hrbxkwnz> stroan: thats exactly where I am. I am first year comp sci student
16:49:34 <stroan> 3rd year here
16:49:47 <Botje> << masters student
16:49:52 <mib_hrbxkwnz> yeah I cant wait till im in 3rd year looking forward to freedom
16:50:02 <stroan> 3 year course?
16:50:15 <Botje> :/
16:50:17 <lament> not sure how work is anything like freedom
16:50:19 * Botje is on his fifth year :)
16:50:19 <mib_hrbxkwnz> yeah in the uk all Bs is 3 years
16:50:25 <ray> i'm a carefree drunkard
16:50:28 * TomMD is on his first quarter
16:50:36 <monadic_kid> i'd rather be doing that than in any other related industry that pays more, at the end of the day it's down to the invidiual and what they are interested in
16:51:03 <stroan> 4 years here. Next year though is mostly a research project. Which so far looks like category theory / UTP / other stuffs. No idea yet what in particular I want to do
16:51:04 <hatds> doing what?
16:51:52 <persica> Botje: I'm currently on track to complete my CS masters over 5 years, unless I cut back on work.
16:52:27 <Botje> :)
16:52:40 <Botje> anyway
16:52:41 <monadic_kid> i work in industry of which you speak
16:52:44 <Botje> sleepytime
16:53:27 <hatds> tightening up graphics on level 2?
16:53:30 <hatds> ;)
17:02:03 <monadic_kid> it's funny how C++0x has all these new features and/or changes but the standard committee didn't bother improving operators, i  doubt you will be able to pass them directly to HOF functions still without using a lambda. It's quite clearly that people want to write EDSLs in C++ so you'd think they would sort that as well
17:03:37 <mib_hrbxkwnz> when someone says "define" the function does that basically mean implement the function?
17:03:37 <gwern> monadic_kid: nothing is funny about c++ topics
17:03:50 <gwern> unless you have a real liking for gallows humor
17:04:07 <gwern> mib_hrbxkwnz: not necessarily. you could define a function using undefined and write the type sig
17:04:38 <gwern> mib_hrbxkwnz: some people write their entire program that way - just a bunch of undefineds and type sigs, and when it's finished and compiling, they write the actual function bodies one by one
17:04:46 <hatds> but probably "yes" -- write the function
17:05:39 <mib_hrbxkwnz> i see thanks, The book that i have says "another way to define the last function" so i got confused if its talking about the declaration thingy or writing it myself
17:06:01 <mib_hrbxkwnz> such a lame book, cant even know when im thinking the right thing as it doesnt have the answers.
17:06:29 <pejo> mib_, it's an awful lot of work to write a book, even without answers.
17:06:41 <hatds> what declaration thingy are you thinking of?
17:06:45 <hatds> type signature?
17:07:08 <mib_hrbxkwnz> pejo: not questioning the difficulty of that but as a learner I need the answers otherwise i will just never know if im right or wrong.
17:07:14 <gwern> pejo: all the more reason to do it well
17:07:37 <mib_hrbxkwnz> hatds: I was thinking of when you write ... f :: int -> int
17:07:48 <hatds> right, that's the type signature
17:07:53 <mib_hrbxkwnz> i dont even know what thats all about yet but i think its declaration for type of a function
17:08:17 <hatds> it's a lot like C/C++ prototypes
17:08:49 <pejo> gwern, not advocating to write bad books, but I think there are other things that decide whether it's a good book or not.
17:08:57 <mib_hrbxkwnz> btw now that im at it, can someone please explain what => is and -> is in a type sinature?
17:09:03 <mib_hrbxkwnz> signature*
17:09:32 <hatds> Int -> Int -> b means it is a function of 2 Ints that returns a b
17:09:35 <QtPlaty[HireMe]> mib_hrbxkwnz: -> is a function
17:09:54 <gwern> QtPlaty[HireMe]: you must hate mib_hrbxkwnz to give him an explanation like that
17:10:31 <mib_hrbxkwnz> hatds: and => means?
17:10:35 <hatds> I say this to everyone who is just learning haskell but it would be good to watch "A Taste of Haskell" to get a nice first pass on all of Haskell's unique features
17:10:36 <QtPlaty[HireMe]> mib_hrbxkwnz: => Constrains a type variable to being within a typeclass.
17:10:43 <hatds> => means typeclasses are involved
17:11:04 <Twey> I don't know if I'd recommend it to *learners* exactly
17:11:10 <hatds> sort :: (Ord a) => [a] -> [a] is a function from lists to lists -- but only lists whose elements are instances of Ord
17:11:12 <persica> mib_hrbxkwnz: I've been enjoying Real World Haskell.  It is well written and the internet version has comments to clear things up.  http://book.realworldhaskell.org/read
17:11:32 <Twey> It gives a lot of info on what the language can do, but doesn't go into depth
17:11:34 <gwern> mib_hrbxkwnz: know java interfaces? think of type classes as haskell's analogue, and you won't be far wrong
17:11:39 <persica> mib_hrbxkwnz: Until you learn about classes you can ignore the =>
17:11:47 <Twey> I'd recommend it more to those who are interested in learning Haskell but not sure what to expect
17:12:11 <hatds> Taste of Haskell video:  http://www.haskell.org/haskellwiki/Video_presentations,  you need to open the slides too to follow along
17:12:31 <mib_hrbxkwnz> take :: int -> [int] > [a]
17:12:33 <hatds> (I just love that video :P)
17:12:36 <mib_hrbxkwnz> is that correct?
17:12:39 <vixey> No
17:12:45 <vixey> Not correct
17:12:56 <persica> mib_hrbxkwnz: what types can be in your list?  only Ints?
17:13:03 <hatds> :t take
17:13:04 <lambdabot> forall a. Int -> [a] -> [a]
17:13:23 <gwern> mib_hrbxkwnz: take's type sig is a -> [a] -> [a] - you can use it on an Int and a [Int], but then obviously the result must be [Int] as well
17:13:32 <vixey> take :: int -> [int] > [a] -- 'int' is a variable, you should use Int though,  [int] should be [a],  > should be ->
17:14:00 <mib_hrbxkwnz> thanks everyone
17:14:04 <gwern> mib_hrbxkwnz: since [a] implies that it could be a list of anything whatsoever - and how could the function 'know' about anything whatsoever? it only knows Ints
17:14:28 <Gracenotes> blah num numlist = []
17:14:28 <bd_> right. the only function satisfying that without producing the bottom would be take _ _ = []
17:14:42 <gwern> Gracenotes: hush you
17:15:04 <mib_hrbxkwnz> head :: [a] -> [a] correct?
17:15:11 <hatds> no
17:15:13 <hatds> not quite
17:15:14 <mib_hrbxkwnz> :(
17:15:24 <gwern> Gracenotes: that's no more helpful than telling me that monads are just an endofunctor over the category of monoids :)
17:15:27 <Gracenotes> it is a correct type signature. but it's not what the function does
17:15:28 <hatds> try it on some lists like [1,2,3]
17:15:31 <persica> mib_hrbxkwnz: does "head" return a list?
17:15:31 <QtPlaty[HireMe]> :t head
17:15:32 <lambdabot> forall a. [a] -> a
17:15:56 <persica> Bah, QtPlaty[HireMe], we're trying to help him learn, not just give him answers. :P
17:15:57 <mib_hrbxkwnz> ahh i feel really dumb
17:16:08 <vixey> me too
17:16:14 <gwern> mib_hrbxkwnz: nah, easy mistake. did the same thing when I was starting out
17:16:16 <persica> mib_hrbxkwnz: a month ago I was where you are.
17:16:18 <QtPlaty[HireMe]> persica: I was showing him the tool that would answer his question.
17:16:22 <mib_hrbxkwnz> that was an obvious mistake, sorry everyone. I been trying to learn haskell and its 1AM so sorry.
17:16:31 <hatds> nah, messing up the distinction between a single element list and just that element is common
17:16:38 <persica> QtPlaty[HireMe]: just knowing the answer doesn't really tell you _why_.
17:17:11 <persica> mib_hrbxkwnz: maybe you should sleep and dream of monads.
17:17:17 <Gracenotes> mib_hrbxkwnz: LYAH is a nice introduction, moves reasonably fast, is easy to read. Overall informed experimentation with ghci (or hugs) is best
17:17:19 <Gracenotes> @where lyah
17:17:19 <lambdabot> www.learnyouahaskell.com
17:17:33 <hatds> dream of applicatives.. we want to raise this kid right!
17:18:04 <mib_hrbxkwnz> why does haskell have so many keywords.
17:18:12 <mib_hrbxkwnz> ?*
17:18:12 <lambdabot> Maybe you meant: . ? @ v
17:18:39 <hatds> it has lots of operators... but I've never felt it had lots of keywords
17:18:43 <hatds> ?
17:19:05 <persica> I think it's just that the vocabulary of Haskell doesn't overlap as much with other languages as most people expect.
17:19:11 <persica> Let's hope he figures out "return" early.
17:19:24 <stroan> return took a bit of getting
17:19:27 <QtPlaty[HireMe]> mib_hrbxkwnz: It doesn't have meany keywords, just alot of standard functions.
17:19:33 <stroan> I still don't get monads properly
17:19:33 <hatds> reason #1239018 that you should watch "A Taste of Haskell"
17:19:56 <wli> unit would've been better.
17:20:00 <mmorrow> module,let,in,where,do,default,deriving,instance,class
17:20:04 <mmorrow> i think are them all
17:20:05 <mib_hrbxkwnz> is a tase of haskell the video where its an english guy giving a presentation of a window management softwarE?
17:20:08 <hatds> wli:   trying saying unit ()
17:20:15 <Gracenotes> @go haskellwiki keywords
17:20:17 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
17:20:17 <lambdabot> Title: Keywords - HaskellWiki
17:20:25 <hatds> yes
17:20:33 <hatds> mib_hrbxkwnz: yes
17:20:33 <mmorrow> arg, forgot about hiding and import
17:20:41 <Gracenotes> a few on the list are obscure/extension-related
17:20:43 <mmorrow> , let forall = 42 in (forall, forall)
17:20:46 <lunabot>  (42,42)
17:20:49 <Gracenotes> but, really, that's it
17:21:02 <vixey> , let lol = 101 in lol
17:21:03 <lunabot>  101
17:21:13 <mib_hrbxkwnz> hatds: watched it earlier today. Tried so hard to follow it but just couldnt. He was aiming it for guys who knew how to programm.
17:21:22 <mmorrow> forall's kinda a half-keyword, in that it's context-dependent whether it is or not
17:21:36 <mmorrow> arg case,of
17:21:40 <Twey> I think it's a type keyword, but not a value keyword?
17:21:43 <mmorrow> (arg:arghh)
17:21:51 <hatds> mib_hrbxkwnz:  I couldn't follow it either at first.  I paused constantly to parse the slides carefully, each sub expression and so on
17:22:02 <mmorrow> Twey: you could say it that way too
17:22:07 <dolio> It's only a type keyword with extensions, too.
17:22:15 <Twey> It's not alone in that
17:22:24 <Twey> Lots of things have different meanings in type vs. value contexts
17:22:29 <Twey> Like ()
17:22:41 * millz http://img34.imageshack.us/img34/3194/img47ea454c0f236.jpg
17:22:57 <Twey> They are, basically, two separate scopes, or even two separate languages
17:23:00 <mmorrow> (although () is a "keyword" in both contexts)
17:23:18 <mmorrow> Twey: which is unfortunate
17:23:35 <Twey> Aye
17:23:41 <Twey> They should be better-integrated
17:23:48 <mmorrow> it'd be great if you could let your values cross the barrier
17:23:49 * millz http://img193.imageshack.us/img193/6848/2cid63b.gif
17:24:06 <mmorrow> and not have to just duplicate your logic verbatim
17:25:38 <dolio> Eh?
17:25:50 <vixey> -_-
17:26:04 <mmorrow> data Nat where Z :: (); N :: N a -> N (N a)
17:26:06 <mmorrow> woo
17:26:10 <mmorrow> , 1 + 3
17:26:11 <lunabot>  4
17:26:28 <mib_hrbxkwnz> to who ever pointed out http://learnyouahaskell.com/, it is a brilliant website!
17:27:24 <ray> _-_
17:27:32 <dmwit> mmorrow: I'm cutting you off, you've had enough!
17:27:44 <mmorrow> dmwit: :)
17:27:46 <dmwit> Do you have a friend to drive you home, or do I have to call a cab?
17:27:55 <dmwit> =)
17:27:58 <ray> it's closing time anyway
17:28:16 <mib_hrbxkwnz> the channel is closing?
17:28:32 <ray> well, we're not serving any more alcohol at least
17:28:42 <mib_hrbxkwnz> ...i see
17:28:46 <persica> ray: We were serving alcohol earlier?  I missed it.
17:28:57 <stroan> you don't have to go home, but you can't stay here
17:29:04 <persica> It's time for me to stop goofing off and learning Haskell at work and instead go home.
17:29:08 <ray> you know, the cops don't have to pull people over right outside my windoe
17:29:18 <ray> and i thought the loud noises were bad
17:29:20 <ray> i hate this place
17:29:26 <ray> but, haskell!
17:30:08 <persica> I need to go back over the monad chaining stuff.  Trying to figure out how to short-circuit out of a chain of actions performed in the IO monad.
17:30:29 <dmwit> Exceptions are one way.
17:30:57 <persica> What's another?  fail for IO is just an exception, right?
17:31:13 <vixey> :k ContT IO
17:31:14 <lambdabot>     `IO' is not applied to enough type arguments
17:31:14 <lambdabot>     Expected kind `*', but `IO' has kind `* -> *'
17:31:16 <ray> it's an IOError or something (i don't know this stuff)
17:31:18 <vixey> :k ContT
17:31:19 <dmwit> Yep.  The other is just to do the usual thing: only execute the rest of the IO action if your test succeeds.
17:31:19 <lambdabot> * -> (* -> *) -> * -> *
17:31:32 <Cale> persica: It's usually cleaner just to structure things so that it becomes an if or case
17:31:56 <persica> Cale: Bah, I was hoping >>= would make my code nice and concise.
17:32:14 <Cale> persica: what does your computation look like?
17:33:00 <persica> basically doesDirectoryExist dir >>= makeFreshDirAndDoStuffInIT
17:33:08 <dolio> mmorrow: Not even a dependent type theory would let you do something like that.
17:33:52 <persica> Or something.  I can just do an "if" and get it done.
17:34:02 <vixey> then persica, you should use if
17:34:13 <Cale> persica: So...  do b <- doesDirectoryExist dir; if b then (failure...) else makeFreshDirAndDoStuffInIT
17:34:41 <persica> Cale: yeah, just if the function had a bunch of possible failures I didn't want staircasing.
17:35:01 <dolio> In fact, with dependent types, you couldn't really use () as both a value and a type, because then there'd be confusion about what you mean in certain places. Is 'f ()' applying f to the () value or () type.
17:35:02 <persica> I thought it would be elegant if it could short-circuit the evaluation without a bunch of ifs
17:35:13 <Cale> persica: That's true. There are other ways of managing things.
17:35:26 <persica> Thanks for the suggestions.  Going to go head home anyway.  I'll play with it tonight/tomorrow.
17:35:28 <dolio> But if you chose () as a value, there wouldn't also be values with type () (the value).
17:35:36 <Cale> One thing you could do is wrap that pattern up into a function
17:35:52 <Cale> Though it doesn't currently have a proper name in the libraries, it seems as though it ought to.
17:36:08 <Gracenotes> @type let if' :: Bool -> a -> a -> a; if' = undefined in liftM3 if'
17:36:09 <lambdabot> forall a (m :: * -> *). (Monad m) => m Bool -> m a -> m a -> m a
17:36:11 <Cale> We do have 'when' and 'unless', but they're not quite what you want
17:36:34 <Cale> yeah, this liftM3 if' is pretty much it :)
17:37:03 <Cale> Though if' = undefined is a little funny ;)
17:37:10 <ray> :t if'
17:37:11 <lambdabot> Not in scope: `if''
17:37:16 <Gracenotes> well. It's the type I'm interested in :)
17:37:20 <Cale> @type let if' b t e = if b then t else e in liftM3 if'
17:37:21 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
17:37:30 <Cale> It's less typing just to define it ;)
17:37:40 <persica> Hehe.
17:37:40 <ray> i thought lambdabot would remember if' by now
17:37:42 <Saizan> using liftM3 you'll execute both actions and discard one result though
17:37:43 <persica> Cool ideas.
17:37:44 <vixey> @let bool True true false = true ; bool False true false = false
17:37:45 <lambdabot>  Defined.
17:37:47 <mib_hrbxkwnz> doubleMe (x:xs) = (x * 2) ++ (doubleMe [xs]) <-- whats wrong with that line? type signature is doubleMe :: [Int] -> [Int]
17:37:55 <Cale> Yeah, liftM3 isn't quite right
17:38:03 <persica> okay, leaving.
17:38:05 <Gracenotes> true.
17:38:14 <mauke> mib_hrbxkwnz: you can't ++ an Int
17:38:21 <Cale> ifM b t e = do r <- b; if r then t else e
17:38:35 <mauke> mib_hrbxkwnz: [xs] is not an [Int]
17:38:41 <mib_hrbxkwnz> mauke: ahh i see, thanks
17:38:56 <mib_hrbxkwnz> mauke: why isnt it an [int] ?
17:39:09 <mauke> because xs :: [Int], so [xs] :: [[Int]]
17:39:15 <Gracenotes> I've had to define that function a few times
17:39:22 <vixey> which one Gracenotes
17:39:49 <ray> if' ?
17:40:28 <mib_hrbxkwnz> mauke: but when i try it without the square brackets it treats it as a normal int, not a list of an int.
17:40:38 <mauke> what?
17:40:43 <mib_hrbxkwnz> mauke: but the error is cos of the ++ right
17:40:50 <vixey> because*
17:40:53 <mauke> there are two errors
17:40:56 <Gracenotes> if' for monads... and also let andM a b c d = if a then do {b' <- b; if b' then c else d} else d
17:41:02 <vixey> big elephants can add up sums easily
17:41:04 <Gracenotes> short-circuit and
17:41:37 <mib_hrbxkwnz> mauke: but in the book i have it shows [1,2,3] ++ [4,5] as valid?
17:41:42 <mauke> yes
17:41:46 <vixey> oh the short circuit one is tricy
17:42:02 <mib_hrbxkwnz> mauke: how is what I am doing different?
17:42:09 <vixey> > [1,2,3] ++ [4,5]
17:42:11 <lambdabot>   [1,2,3,4,5]
17:42:12 <vixey> > 3 ++ [4,5]
17:42:13 <lambdabot>       No instance for (Num [a])
17:42:13 <lambdabot>        arising from the literal `3' at <inter...
17:42:16 <mauke> mib_hrbxkwnz: you're doing 2 ++ [4,5]
17:42:40 <mauke> mib_hrbxkwnz: and doubleMe [[4,5]]
17:42:47 <mib_hrbxkwnz> so would this be valid [x *2] ++ [~~~~]
17:42:56 <mauke> yes
17:43:03 <mib_hrbxkwnz> i see, thanks.
17:43:58 <mib_hrbxkwnz> yay! I wrote my first ever haskell script!
17:44:15 <mib_hrbxkwnz> and it works too XD
17:44:34 * mauke rewrites it as a single line that uses no variables
17:44:56 <Gracenotes> no! you can't make everything pointfree! you must resist!
17:49:45 <ray> we should have a Â¢ operator for left associative function application
17:49:49 <ray> where the c stands for cale
17:50:17 <Cale> We should just change $ to be the right way.
17:50:42 <dolio> Â¢ is harder to type.
17:51:01 <Cale> Yeah, I need to hit 3 keys separately to type Â¢
17:51:07 <dolio> I'd have to write my haskell programs using agda mode.
17:51:25 <dmwit> I hereby nominate # to maximally confuse people familiar with comments from other popular scripting languages.
17:51:27 <Cale> and most people probably don't have their keyboard set up to type it at all
17:51:47 <ray> how about /*
17:52:23 <dolio> I'd be able to type it if I could get scim to work. I tried letting it run again the other day, but it kept freezing the input to things when I was alt-tabbing between windows.
17:52:39 <Cale> I nominate # for an operator a -> String -> a which if the evaluation of its first parameter throws an exception, adds its second parameter to the message.
17:52:43 <dolio> I guess that's a step above making them segfault.
17:52:45 <dmwit> > let (/*) = (*); (*/) = (/); not = id; three = 4 in 3 /* not three */ 5
17:52:47 <lambdabot>   2.4
17:52:51 <mmorrow> dolio: i mean how you have to completely duplicate your code at the type level, when you've already written it once at the value-level. like for instance in the type family Nest and the function `nest' in  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166
17:52:57 <Cale> That way, they will even look like comments.
17:53:20 <mmorrow> i could just do (fmap toLower) on the type code and be all good
17:54:16 <dolio> Nest is two functions in Agda, too, although that may be an artifact of no universe polymorphism.
17:54:33 <mmorrow> hmm
17:54:43 <mmorrow> are there langs with universe polymorphism?
17:54:48 <dolio> Coq.
17:55:00 <mmorrow> i've been meaning to learn that
17:55:02 <dolio> You could see if you can write it there.
17:55:06 <ray> are there any whose names you can say in polite company?
17:55:10 <dolio> Or get vixey to do it.
17:55:22 <mmorrow> vixey: ping
17:55:26 <mmorrow> ;)
17:56:08 <hatds> @src foldl'
17:56:08 <lambdabot> foldl' f a []     = a
17:56:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:56:15 <hatds> @src Foldable.foldl'
17:56:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:56:30 <hatds> @src Data.Foldable.foldl'
17:56:30 <lambdabot> Source not found. My mind is going. I can feel it.
17:58:14 <dolio> mmorrow: Technically you could use --type-in-type in agda to simulate the effect.
17:58:46 <mmorrow> dolio: ah, interesting. that flag wants me to play with agda
17:58:58 <mmorrow> heh, *make me want to ...
17:59:02 <mmorrow> makes
18:00:00 <dolio> Not interested in those boring type theories that correspond to consistent logics? :)
18:00:29 <mmorrow> oh those?
18:00:35 <mmorrow> :)
18:02:12 <QtPlaty[HireMe]> Is there a function that gives a list after a smaller sublist? eg (foo "cd" "abcdef") ===> "ef"
18:07:01 <mmorrow> , let foo xs = tail . flip (foldl (\xs c -> snd (break (==c) xs))) xs in foo "cd" "abcdef"
18:07:03 <lunabot>  "ef"
18:08:25 <dolio> mmorrow: Still not possible in Agda because it makes use of nest (in the type) before it's been defined.
18:08:50 <mmorrow> dolio: ah, interesting. hmm
18:09:32 <dmwit> , let foo xs = tail . flip (foldl (\xs c -> snd (break (==c) xs))) xs in foo "cd" "abcedf"
18:09:34 <lunabot>  "f"
18:09:42 <mmorrow> crap
18:10:38 <mmorrow> dolio: can you do something like:
18:10:50 <dmwit> > let foo xs zs = dropWhile (\ys -> not (xs `isPrefixOf` ys)) (tails zs) in foo "cd" "abcdef"
18:10:52 <lambdabot>   ["cdef","def","ef","f",""]
18:11:20 <mmorrow> letrec nest1 : ... nest2 n; nest 1 = ...; nest2 : ... nest1 n; nest 2 = ... in ...
18:11:20 <mmorrow> ?
18:11:41 <mmorrow> or is there no letrec allowed
18:11:49 <dmwit> or maybe
18:12:15 <dmwit> > let foo xs ys = filter (xs `isPrefixOf`) (tails ys) in foo "cd" "abcdefcedfcdef"
18:12:16 <lambdabot>   ["cdefcedfcdef","cdef"]
18:13:05 <mmorrow> we need a zipAndGiveMeTheRamainder function
18:13:20 <mmorrow> *Remainder
18:13:53 <dolio> mmorrow: Also, I tried defining a Nest with the type of nest using a Nest' with the more basic type, but then Nest doesn't work in the type of nest.
18:14:00 <dolio> Which I'm not terribly surprised by.
18:14:22 <mmorrow> dolio: hmm
18:14:59 <mmorrow> is that letrec mutually-recursive nest1/nest2 thing allowed?
18:15:08 <dino-> Say you want to write something like a data Weekday. Is the only way to make succ/pred roll around the end to write all the toEnum, fromEnum, pred and succ functions by hand?
18:15:10 * mmorrow thinks probably not
18:15:31 <dino-> I tried with deriving (Eq, Ord, Enum) and no dice.
18:15:45 <dolio> I don't know. It doesn't matter if nest doesn't work in its own type.
18:16:05 <mmorrow> dino-: Data.Derive has a deriver for circular Enum
18:16:18 <mmorrow> that's the only automated way i can think of
18:16:41 <dino-> mmorrow: I see. So I'm not doing it wrong.
18:16:45 <dmwit> It wouldn't be a hard instance to write, especially if you don't care about speed.
18:16:51 <mmorrow> dolio: i don't understand. what do you mean by that?
18:17:13 <dmwit> \x -> head . dropWhile (/= x) . cycle $ [S, M, T, W, R, F, A]
18:17:15 <mmorrow> dino-: not wrong, just that ghc only derives it one way
18:17:26 <dmwit> err
18:17:31 <dino-> mmorrow: Ok. Thank you.
18:17:34 <dmwit> add a drop 1 in there between head and dropWhile. =P
18:17:35 <mmorrow> so you have to write it by hand or have something other than ghc generate it
18:17:36 <dolio> mmorrow: The problem is that I defined a function identical to nest, and then tried to use it in the type of nest, but that didn't work.
18:17:59 <dolio> mmorrow: So if I can't get that to work, then whether I get get nest's type to refer to itself is academic.
18:18:17 <mmorrow> ah, i see.
18:19:10 <dolio> mmorrow: The problem seems to be that f : Set -> Set, which does not fit the schema (forall a. a -> f a), obviously.
18:20:54 <dolio> mmorrow: Of course, this is all kind of silly if you define natural induction, I imagine.
18:22:43 <BMeph> dino-: You'd have to tell your function when to stop wrapping around, so why not do so directly? :)
18:23:35 <dino-> BMeph: I'm actually working on directions inside a hex and want to be able to say change direction cw or ccw
18:26:07 <BMeph> dino-: I'd probably just use to/fromEnum and mod, myself. Zero-indexed lists seem suited to that sort of thing. :)
18:26:57 <dmwit> I'm with dino-, I'd prefer a data type and Data.Derive over Int.
18:27:34 <dmwit> But then, for most of the stuff I do, I'm liberated from petty concerns for efficiency. ;-)
18:27:46 <BMeph> dmwit: So, make a class that does mod over Enums? :)
18:28:18 <dino-> I may actually need mod here too
18:28:19 <dmwit> BMeph: You mean, like, say... Enum?
18:28:38 <dmwit> > succ maxBound :: Int
18:28:39 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
18:28:43 <dmwit> heh
18:30:58 <BMeph> Hm, that's kind of...hideous. :\
18:31:00 * edwardk1 waves hello.
18:33:10 <unmarshal> hi, i have a problem where i'm using a list comprehension to search a space and want to define a terminating condition... there a nice way of doing that? i was doing this
18:33:16 <unmarshal>  [ (x,y) | x <- [sx..sx+1500], y <- [sy..sy+1500], canAntMove(fromIntegral x, fromIntegral y) == True ]
18:33:25 <unmarshal> i need the list to terminate
18:33:28 <unmarshal> when cantAntMove is false
18:33:31 <BMeph> mod (along with div, quot and rem) are all defined in Integral, which takes Enum and Real as members. However Real just needs a toRational function (which begs to ask, then why is it Real? ;p), which any Enum can give you, since to/fromEnum give you isoms to (non-neg) Int.
18:33:37 <unmarshal> instead of iterating through all the numbers
18:34:20 <BMeph> unmarshal: Thank you!
18:34:26 <unmarshal> what's up?
18:34:41 <BMeph> unmarshal: You let me use my Favorite meme: UR DOIN IT RONG!
18:34:45 <unmarshal> hehe
18:34:46 <unmarshal> cool
18:34:47 <unmarshal> correct me!
18:34:57 <unmarshal> bzzt..wrong!
18:35:45 <unmarshal> can a list comprehension terminate with a guard?
18:35:57 <unmarshal> or am i going to have to manually recurse through
18:36:23 <BMeph> Well, first off, that "==True" part is completely repetetively redundent - and it's tautological, to boot. ;p
18:36:56 <unmarshal> okay that's fine
18:36:58 <unmarshal> i had it without that before
18:37:00 <unmarshal> but was getitng wrong answer
18:37:02 <unmarshal> just playing with stuff
18:37:08 <BMeph> unmarshal: It's like saying "if (myGuardCondition == True) ..."
18:37:12 <unmarshal> right i understand that
18:37:13 <unmarshal> that's fine
18:37:20 <unmarshal> bt what about terminating a list comprehension
18:37:41 <unmarshal> can i even do this with a list comprehension easily
18:37:57 <dolio> mmorrow: http://moonpatio.com:80/fastcgi/hpaste.fcgi/view?id=2166#a2429
18:38:45 <dolio> mmorrow: Not sure why I have to eta expand f in the definition of induction, but I do.
18:38:56 <augustss> unmarshal: no, you can't terminate a list comprehension easily.  Use takeWhile
18:39:13 <unmarshal> okay
18:39:15 <unmarshal> thanks augustss
18:40:56 <unmarshal> takeWhile (==True) $ [ canAntMove(fromIntegral x, fromIntegral y) | x <- [sx..sx+2000], y <- [sy..sy+2000] ]
18:40:59 <unmarshal> thanks man
18:41:40 <augustss> Umm, that's probably not what you want
18:41:51 <unmarshal> yeah after running probably not
18:41:54 <unmarshal> it's smaller than i expected
18:42:16 <unmarshal> i need to do it for both dimensions
18:42:19 <augustss> takeWhile canAntMove [ (x, y) | x <- ..., y <- ... ]
18:42:22 <BMeph> unmarshal: "takeWhile id" is more "Haskell-y". ;p
18:44:36 <mib_hrbxkwnz> if im writing a function which takes in a list but i dont care what the type of the list is how can i do this?
18:44:50 <kpreid> just don't mention it
18:44:53 <mib_hrbxkwnz> I am trying myTake :: Int -> [a] -> [a]
18:44:54 * BMeph understands that whole "I do not think that word means what you think it means" line from PB
18:45:02 <kpreid> yes...
18:45:11 <kpreid> if you have an error, it's probably in the definition
18:45:39 <mib_hrbxkwnz> definition being the actual code for the function?
18:45:44 <kpreid> yes
18:45:49 <kpreid> the part that has "=" in it
18:45:52 <BMeph> mib_hrbxkwnz: Haskell is a "dynamic language" - the types are on the values, not the variables.
18:46:02 * kpreid eyes BMeph
18:46:23 <kpreid> stop confusing the newbies
18:46:49 <mib_hrbxkwnz> oh turns out the type and everything was correct
18:46:50 * BMeph has wanted to make that wild-eyed claim ever since hearing Randall Schwartz make it up...
18:47:08 <mib_hrbxkwnz> I was trying to do x ++ blah bla instead of [x] ++ blah blah
18:47:23 <kpreid> mib_hrbxkwnz: [x] ++ blah  =  x : blah
18:47:47 <mib_hrbxkwnz> yeah :P
18:47:49 <augustss> BMeph: I've gotta remember that one
18:48:15 <monochrom> There is no value.
18:48:30 <BMeph> augustss: Yeah, I think I'm gonna call it "using the Schwartz" now... ;p
18:48:39 <kpreid> "whaddaya mean, variables? they don't vary!"
18:49:06 <augustss> They are not variables, they are constables.
18:49:08 <monochrom> semantics is defined by syntax.
18:49:31 * BMeph never really understood the whole mathy thing of "assigning values to variables" - if they're variables, why don't they vary? ;p
18:49:57 <mib_hrbxkwnz> going from OO prgraming to haskell is like being in the matrix DX
18:50:18 <Gracenotes> BMeph: in math? Well I suppose they can vary a lot, but only one value will make your equation correct :)
18:50:35 <unmarshal> thanks for help guys
18:50:39 <kpreid> I think the problem comes from the fact that programmers work with hugely larger things than the typical math formula (that the programmers ever hear of)
18:50:41 <unmarshal> haven't quite figured it out but it was a problem with my logic
18:50:42 <unmarshal> bbl
18:50:49 <kpreid> it's easier to think about the variability being 'just reevaluate it with x = your new value' when there's only one line to reevaluate
18:50:59 <BMeph> Gracenotes: Well, then it isn't a "variable", it's an "unknown". ;p
18:51:02 <monochrom> "vary" is a physics idea. "assign" is an imperative idea. Neither is from math per se.
18:51:45 <BMeph> augustss: I'm putting that "constables" line in my fortune file - thanks! ;)
18:52:52 <augustss> :)
18:54:04 <BMeph> mib_hrbxkwnz: What else would you expect? The whole paradigm's named after a mistake! ;p
18:54:06 <hatds> "vary" makes lots of sense in math with functions or sequences
18:54:18 <mib_hrbxkwnz> what does "functionName :: Ord a => [a] -> [a]" mean?
18:54:41 <hatds> it means the function requires that 'a' be a type that can be ordered
18:54:41 <mib_hrbxkwnz> more specifically what is Ord a => mean
18:55:07 <mib_hrbxkwnz> but how can it just specify that, i mean is Ord some kind of key word?
18:55:16 <hatds> Ord is the name of a typeclass
18:55:18 <mib_hrbxkwnz> that checks if its an "order-able" list?
18:56:14 <hatds> to call that function at a type 'Foo', there has to be the following instance declaration in your program or in the Prelude:    instance Ord A where ...
18:56:32 <hatds> er, instance Ord Foo where ...
18:57:15 <BMeph> mib_hrbxkwnz: Right. "Ord" is a class (a club for types, where the definition of particular functions "allows your type into the club"). :)
18:57:32 <mmorrow> dolio: oh cool.
18:58:07 <mmorrow> dolio: hmm. so in this then, `induction' essentially takes the place of the type family, right?
18:58:10 <mib_hrbxkwnz> i see, so would i be correct in saying if I gave a list as an input which couldnt be ordered the compiler will throw an error?
18:58:34 <hatds> yep, for instance a list of functions cannot be ordered
18:58:49 <mmorrow> dolio: ie, there's doesn't seem to be a way to have nest be in it's own type (?)
18:59:18 <mmorrow> dolio: ohh, wait. i just realized what's going on
18:59:19 <mib_hrbxkwnz> i see, so would i also be correct in saying the => means its a "check" or a validation on the value in a type signature?
18:59:21 <hatds> but you *can* reverse a list of functions.  'reverse' really does work for any type a
18:59:55 <monochrom> => is just punctuation to separate the typeclass from the rest of the type.
19:00:07 <mmorrow> dolio: cool, that's definitely it (modulo having to have the `induction' helper, but whatever)
19:00:28 <mib_hrbxkwnz> i.e Ord => a would translate into check a for being "Ord"
19:00:58 <hatds> Ord a => a
19:01:20 <hatds> means a must be a member of the "Ord" typeclass and that the expression in question has type a
19:01:27 <Gracenotes> @type \x -> x > 2
19:01:28 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
19:01:46 <mmorrow> dolio: now, why can't we just do:    nest :: (n:Int) -> (a -> f a) -> nest n f a; nest n _ a | n < 1 = a; nest n f a = f (nest (n-1) f a);
19:01:59 <mib_hrbxkwnz> hatds: cheers, I think I understand the => now.
19:02:08 <mmorrow> dolio: i think *that* would be swell
19:03:22 <dolio> mmorrow: induction is the general elimination rule for natural numbers. Like foldr is for lists.
19:04:19 <dolio> And you can't do that because the specific instantiations of induction used in the type and body of nest aren't reconcilable.
19:04:28 <mmorrow> why not?
19:04:54 <mmorrow> there's no reason why they shouldn't be. a compiler can map N (Z ()) to 1, right?
19:05:37 <mmorrow> and it can just use machine ints, instead of using the massive (relatively) structure needed to represent N (N (N (Z ())))))
19:05:54 <mmorrow> (this was what i was after earlier)
19:06:26 <mib_hrbxkwnz> can anyone tell me if the following return a finite or infinte list (I dont want to put it in the complier of fear of crashing it) a) take 10 [1..] b) iterate (+1) 0 c) filter even [1..] d) takeWhile (>0) [1..] e) dropWhile (<10) [1..]?
19:06:28 <dolio> Because f : Set -> Set is not a valid argument when the function expects (forall {a} -> a -> g a) for some g.
19:06:43 <mmorrow> dolio: ah, ok. i see what you're saying.
19:07:18 <mmorrow> dolio: i guess then i need something other than the logic that agda uses
19:07:20 <roconnor> mib_hrbxkwnz: are you in the middle of taking a test?
19:07:33 <dolio> What's wrong with using induction like I did?
19:07:36 <mib_hrbxkwnz> roconnor: preparing for one :P
19:08:11 <monochrom> Nothing wrong with crashing the compiler.
19:08:16 <mmorrow> dolio: oh, nothing. i just feel like this should be possible:
19:08:22 <mmorrow> nest :: (n:Int) -> (a -> f a) -> nest n f a; nest n _ a | n < 1 = a; nest n f a = f (nest (n-1) f a);
19:08:30 <mib_hrbxkwnz> monochrom: will it not make me restart the computer?
19:08:31 <mmorrow> since that is exactly what we're doing
19:08:36 <monochrom> No.
19:08:39 <Gracenotes> if you think it may be a long list, just "take 100" from the whole expression
19:08:39 <mmorrow> but circling a few times
19:08:41 <mmorrow> first
19:08:49 <mmorrow> (?)
19:08:54 <Gracenotes> and you can probably Ctrl+C
19:09:13 <monochrom> Set up VMWare or VirtualBox and take a snapshot if you are really concerned.
19:09:15 <mib_hrbxkwnz> ok then ill try it, I know the answer just wanted to be sure
19:09:28 <mib_hrbxkwnz> out of the question a) is finite the rest are infinite
19:09:37 <mmorrow> dolio: (and that type sig is just the approximation i gave, not meant to be judged w/in agda or haskell)
19:10:27 <roconnor> mib_hrbxkwnz: I think that is right.
19:10:32 <mmorrow> dolio: isn't that just what you get when you identify the type family def + instance and the `nest' function def in the haskell?
19:10:38 <dolio> mmorrow: Well, if you could pass some specific (a -> f a), then it would work, becuase you could make a = Set, and f Set = Set. However, that's the wrong type for nest, because you need that parameter to work for all a, including f a, f (f a), etc.
19:10:41 <roconnor> mib_hrbxkwnz: the only tricky one is d)
19:10:57 <roconnor> well, c) is kinda tricky, but there isn't an option for neither finite nor infinite.
19:11:25 <mib_hrbxkwnz> roconnor: well if im understanding correctly c) means it will make a set of all even values from 1 ... to infinity
19:11:26 <mmorrow> dolio: hmm, this is an interesting case.. i'm gonna think about it
19:11:40 <mib_hrbxkwnz> roconnor: and d) will take all values above 0
19:11:55 <roconnor> mib_hrbxkwnz: take always produces a finite list
19:12:09 <roconnor> mib_hrbxkwnz: iterate always produces an infinite list
19:12:42 <roconnor> mib_hrbxkwnz: Hmm, I was going to say dropWhile always returns an infinite list given an infinite list, but that isn't entirely true.
19:12:47 <mib_hrbxkwnz> roconnor: really? thanks I didnt know that about iterate. But yeah im testing each one by encapsulating them in a take 100's
19:13:14 <roconnor> @src iterate
19:13:15 <lambdabot> iterate f x =  x : iterate f (f x)
19:13:27 <roconnor> There is no [] in the source code of iterate
19:13:31 <mib_hrbxkwnz> ah
19:13:35 <roconnor> so it cannot produce a finite list
19:13:41 <augustss> mib_hrbxkwnz: A tricky one would have been  take (< 10) [1..]
19:13:41 <mib_hrbxkwnz> i see why that may be an infinite list then XD
19:13:53 <roconnor> However, you have to prove it is productive to show it produces an infinite list.
19:14:07 <mib_hrbxkwnz> augustss: thats also finite right? taking in values below 10?
19:14:09 <mauke> can't match Int with (Num a) => a -> Bool
19:14:14 <roconnor> It is the case that iterate is productive, but that is slightly less obvious that the no [] thing.
19:14:54 <augustss> mib_hrbxkwnz: It's not finite, because it never reaches the end, nor is it infinite
19:15:09 <mib_hrbxkwnz> i dont quite get it.
19:15:24 <roconnor> > take (< 10) [1..]
19:15:25 <lambdabot>       The section `(< 10)' takes one argument,
19:15:25 <lambdabot>      but its type `Int' has none
19:15:31 <mauke> told you so
19:15:33 <augustss> mib_hrbxkwnz: sorry, I meant   filter (< 10) [1..]
19:15:36 <roconnor> > takeWhile (< 10) [1..]
19:15:37 <lambdabot>   [1,2,3,4,5,6,7,8,9]
19:15:53 <roconnor> > filter (< 10) [1..]
19:16:02 <mauke> 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : <<loop>>
19:16:08 <lambdabot>   thread killed
19:16:11 <roconnor> mauke-snack
19:16:34 <MyCatVerbs> roconnor: of course it's productive. It tail calls to (:) without examining any of its arguments. :)
19:16:55 <roconnor> MyCatVerbs: yes yes, but that requires you to know the definition of productive.
19:17:02 <roconnor> not even
19:17:20 <roconnor> it requires you to know the common syntactic property that implies productivity.
19:17:30 <MyCatVerbs> roconnor: what is the definition of "productive", anyway? Isn't it something like that you'll always be able to get another element in finite time?
19:17:39 <roconnor> something like that.
19:17:58 <roconnor> using the word "time" fills me with ick
19:18:16 <roconnor> but to get a formal definition would require me to go to a bookshelf.
19:18:41 <monochrom> There is a lattice-theory definition that doesn't use time. It just uses compactness.
19:18:43 <roconnor> maybe "time" isn't so bad.
19:19:09 <roconnor> monochrom: that sounds like a definition I would like.
19:19:35 <roconnor> but mib_hrbxkwnz might not like it so much.
19:20:22 <mib_hrbxkwnz> roconnor: I like it, just dont understand it : (
19:20:33 <dolio> mmorrow: Incidentally, I doubt you'll get nest to refer to itself in its type in any dependently typed language.
19:20:50 <MyCatVerbs> How about, a list l is defined as infinite iff for any natural n, (l !! n) does not diverge?
19:21:04 <roconnor> dolio: what nest?
19:21:15 <dolio> mmorrow: Because you have to type check a function before evaluating it, but you might have to evaluate terms to type check.
19:21:30 <dolio> So to type check the function, you might have to evaluate it, which would require type checking it first.
19:21:44 <roconnor> dolio: sounds like induction-recursion.
19:21:49 <mauke> just use lazy typing
19:22:19 <MyCatVerbs> mauke: I would give you a medal if you succeeded in explaining that to any undergrad on Earth.
19:22:42 <monochrom> It is very easy to replace "time". Recall how you can use the sequence [f_|_, ff_|_, fff_|_, ...] to converge to the fixed point of f. You can say: to get another cons cell, I just need to look finitely many steps forward in the sequence.
19:22:50 <mauke> sorry, too lazy to type
19:23:32 <MyCatVerbs> monochrom: the fixed point of what, graph reduction?
19:23:47 <monochrom> The fixed point of f.
19:24:11 <monochrom> f is some continuous function.
19:24:45 <dolio> roconnor: I think you can do induction-recursion in agda with a mutual block, but it still wouldn't let me use a function in its own type.
19:26:34 <solrize_> @seen igloo
19:26:34 <lambdabot> igloo is in #darcs, #haskell and #ghc. I last heard igloo speak 9h 4m 12s ago.
19:26:40 <mib_hrbxkwnz> thanks to everyone who helped me, I have learnt so much for one night. good night
19:32:50 <hatds> :t (.) map (+)
19:32:52 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
19:32:55 <hatds> ^cute
19:34:01 <roconnor> @pl \x -> map (x+)
19:34:02 <lambdabot> map . (+)
19:34:12 <hatds> :)
19:35:50 <gwern> huh. this thesis on efficient dependent type compilation mentions an OLEG
19:36:04 <gwern> some sort of advanced theorem prover. as if we needed to be told that!
19:37:01 <BMeph> WOOT! Magnus posted his screed response! http://therning.org/magnus/archives/629
19:37:24 <monochrom> advanced theorem prover is here and now
19:37:43 <gwern> BMeph: that's been on reddit for days man
19:38:46 <BMeph> gwern: So I prefer Planet Haskell to Reddit. Sue me. ;p
19:38:48 <monochrom> Yesterday I was wondering how to tell the computer to prove "j-h>=2 implies h<floor((j+h)/2)<j". I entered it into PVS and tried "(grind)", and it's done.
19:39:04 <gwern> BMeph: I would, if I could figure out the appropriate tort
19:39:47 <BMeph> gwern: I'd prefer chocolate raspberry. ;p
19:40:32 <gwern> (the queen of hearts, she baked some torts, all on a summer day; the bmeph of hearts, he stole the torts, and took them quite away)
19:41:50 <BMeph> gwern: Ah, so 13 hours == "days", in Reddit-speak? Thanks, but I'll stick with my own medication. ;p
19:42:04 <gwern> that's internet time for ya
19:44:30 <dolio> Heh, haskell bigot.
19:45:21 <solrize_> "I've been saying for a while that up through version 1.4, Java was a throwback to the languages of the 1970s, but that with the introduction of generics in Java 5, it took a giant step forward into the 1980s." (mjd)
19:45:58 <QtPlaty[HireMe]> 13 hours ~~ 0.5 days
19:53:50 <BMeph> Does anyone else find it ironic that the defining function for the Real class, is that you value be "convertible" ("isomorphic"? yadda-yadda modulo, ...) to a Rational? :P
19:54:01 <BMeph> s/you/youR/
19:54:20 <dolio> @src Real
19:54:20 <lambdabot> class  (Num a, Ord a) => Real a  where
19:54:20 <lambdabot>     toRational      ::  a -> Rational
19:55:36 <BMeph> Doesn't that kind-of defeat the whole purpose of being a Real? :p
19:56:41 <dolio> What should it be? toCReal?
19:56:43 <BMeph> Not that Rational numbers aren't Reals, but... you smell what I'm stepping in, don't you? ;p
19:56:45 <MyCatVerbs> BMeph: no, it's only an isomorphism if you can convert *back*, and (toRational . fromRational) is always replacable by id.
19:57:04 <hydo> Wow, you guys were right about Arch... it's really nice.
19:57:07 <MyCatVerbs> As should (fromRational . toRational).
19:57:36 <dolio> Rational is the closest the standard library has to arbitrary approximations of reals.
19:58:07 <BMeph> MyCatVerbs: Seriously, I'd accept fromRational over toRational, except it kind of doesn't fit for class purposes.
19:59:24 <Gracenotes> @type fromRational . toRational
19:59:25 <lambdabot> forall a a1. (Real a1, Fractional a) => a1 -> a
20:03:31 <roconnor> @src realToFrac
20:03:31 <lambdabot> realToFrac = fromRational . toRational
20:05:23 <roconnor> Cale: in our new haskell, will (.) mean fmap or arrow composition?
20:05:46 <Cale> roconnor: It's a good question. I'm leaning toward fmap myself.
20:05:53 <roconnor> hmm
20:05:59 <Cale> Control.Category goes the other way
20:06:08 <roconnor> I'd be include for it to be arrow composition
20:06:16 <Cale> But I haven't seen enough really convincing instances of Control.Category
20:06:32 <Cale> Whereas there are a ton of Functor instances everywhere
20:06:53 <roconnor> I'd prefer something like <$>  for fmap
20:06:57 <Cale> and (.) is really probably the best operator notation aside from whitespace available
20:07:00 <roconnor> except probably not <$>
20:07:05 <roconnor> although I'd be okay with <$>
20:07:06 <Cale> So you want to use it for something you're going to use a lot
20:07:48 <roconnor> Cale: that's a fair argument
20:08:12 <dolio> f . (g . h) = (f . g) . h is a pretty sexy functor law, too.
20:09:07 <Gracenotes> ..just functors?
20:09:09 <MyCatVerbs> f `fmap` (g `fmap` h) = (f `fmap` g) `fmap` h -- is sexy?
20:09:24 <Gracenotes> oh, I see
20:09:57 <MyCatVerbs> fmap for the the ((->) a) monad is (.)
20:10:27 <roconnor> I don't suppose that ((~>) a) is always a monad.
20:10:33 <Gracenotes> <$> is pretty nice too
20:11:54 <MyCatVerbs> fmap :: (Functor f) => (b -> c) -> f b -> f c; Given that ((->) a) is a Functor, we have (fmap :: (b -> c) -> (a -> b) -> (a -> c)) by replacing (f) with (a ->).
20:11:55 <Cale> fmap (f . g) = fmap f . fmap g is the usual law, and then applying it to x we get  fmap (f . g) x = fmap f (fmap g x), but then replacing fmap with (.) gives (f . g) . x = f . (g . x)
20:12:32 <MyCatVerbs> Which is why Caleskell defines (.) as fmap instead of (.) f g x = f (g x). ^^
20:12:56 <Elly> where is the Caleskell spec?
20:13:14 <Cale> I don't understand why people use the term Caleskell ;)
20:13:39 <m3ga> i'm getting the error "Class `Exception' used as a type" in code which does "data LogEvent = .. | CuaghtException Exception | ..". has something changed about Exception between ghc-6.8 and 6.10.1?
20:13:48 <Gracenotes> yeah
20:13:50 <roconnor> it's HaskCale
20:13:55 <MyCatVerbs> It has a better ring to it than "HassCale".
20:13:56 <roconnor> er
20:13:59 <roconnor> it's HasCale
20:14:33 <Cale> I suppose it started when I replaced some of the Prelude definitions in lambdabot, but I don't know, it's still Haskell even if you replace the Prelude, in my mind.
20:14:42 <Gracenotes> m3ga: compatibility module is here:
20:14:44 <Gracenotes> http://www.haskell.org/ghc/staging/docs/latest/html/libraries/base/Control-OldException.html
20:14:55 <Gracenotes> or if you want you can convert all the code to use the newer version
20:15:16 <Elly> aw, the haskwll wiki doesn't know what caleskell is
20:15:20 <Elly> haskell wiki, rather
20:15:39 <m3ga> Gracenotes: thanks. is there a quick howto on the conversion?
20:16:24 <sjanssen> Cale: you'll have to break compatibility if you want to fix the important stuff (like Monad/fail)
20:16:31 <Elly> Monad/fail?
20:16:36 <Cale> sjanssen: That is true.
20:16:58 <Cale> sjanssen: and at that point, I would consider it a properly new standard :)
20:17:08 <Gracenotes> m3ga: hmm... well, you can refer to an Exception as a datatype with SomeException
20:17:23 <Gracenotes> see http://www.haskell.org/ghc/staging/docs/latest/html/libraries/base/Control-Exception.html, the newer version of the module
20:17:24 <sjanssen> Cale: we oughta find an advocate for that on Haskell'
20:17:30 <sjanssen> (is Haskell' dead again?)
20:17:37 <Gracenotes> there should be a guide... might be one
20:17:43 <dolio> Was it alive again?
20:17:46 <Cale> I don't think Haskell' is really the right place for it even so.
20:17:57 <Cale> The right place is GHC.
20:18:05 <Cale> Change first, ask questions later ;)
20:18:23 <sjanssen> Elly: the Monad class has a method 'fail' that doesn't belong there, as many instances don't have a useful concept of failure
20:18:33 <Gracenotes> the old exception module may be removed eventually
20:18:36 <Elly> it does? what does it do?
20:18:41 <Cale> Standards should follow implementations, and implementations should feel a bit more free to do what they want.
20:18:48 <Gracenotes> by default, fail throws an exception
20:19:00 <sjanssen> Cale: yeah, but then they'd have to change the name to gshc: Glasgow (or Glorious) Sorta Haskell Compiler
20:19:01 <Elly> I mean, in a category-theory sense, what does it mean for a monad to fail?
20:19:07 <Gracenotes> leaky abstraction, we would call it
20:19:24 <Cale> sjanssen: Well, it already doesn't *exactly* follow the standard.
20:19:29 <dolio> fail is unrelated to category theory.
20:19:33 <Elly> oh
20:19:42 <Cale> and it's not like it would be too onerous to provide a compatibility mode, I bet.
20:19:42 <Elly> why does it exist?
20:19:52 <sjanssen> Elly: some Monads have a concept of "zero", like Nothing for Maybe, or [] for lists
20:20:02 <Elly> *nod*
20:20:10 <MyCatVerbs> Cale: tenatively, we already have a compatibility mode, commonly known as "not passing -XAnything".
20:20:12 <Cale> Elly: It exists because of a mistake which happened when monad comprehensions were removed.
20:20:22 <dolio> It exists because back in 1.4, you could do pattern matches like "do (a,b,c) <- m ; ..." with just a Monad constraint...
20:20:32 <Cale> MyCatVerbs: Even that isn't full Haskell 98 compatibility
20:20:45 <sjanssen> Cale: in a very few pedantic places.  Gobs of previously valid Haskell code would become illegal, which is a much different matter
20:20:47 <dolio> But in 98, they removed the capability for such patterns, but didn't want to lose the just Monad constraint.
20:21:07 <sshc> is haskell case insensitive with types (Int)?
20:21:16 <dolio> So they decided to introduce fail for all monadic pattern matching as a compromise.
20:21:19 <sjanssen> sshc: Haskell is always case sensitive
20:21:24 <Cale> dolio: That's also not the whole story... it also had to do with MonadZero getting merged into MonadPlus (which was a mistake in itself)
20:22:10 <Cale> sshc: Moreover there are restrictions as to what case the first letter of things must be
20:22:26 <QtPlaty[HireMe]> Why do we have a stripPrefix but no stripSuffix?
20:22:44 <Cale> sshc: In particular, if a name at the type level starts with a lowercase letter, it's a type variable, and if it starts with an uppercase letter, it's a type constructor.
20:23:02 <sjanssen> QtPlaty[HireMe]: reverse . stripPrefix . reverse?
20:23:05 <MyCatVerbs> Cale: even more tenatively, we do not *perfectly* adhere to the standard so long as we have any bugs whatsoever any. But GHC is close enough that it very, very rarely fails to accept anything that H98 says is fine, with or without -fglasgow-exts.
20:23:32 <Cale> sshc: At the value level, if a name starts with a lowercase letter it is a variable, and if it starts with an uppercase letter it is a data constructor.
20:23:37 <QtPlaty[HireMe]> sjanssen: Yuck
20:23:42 <Cale> (which is important for pattern matching)
20:25:25 <QtPlaty[HireMe]> Cale: Why is it important?
20:26:06 <ray> f (Just a) = ...
20:26:09 <ray> f (just a) = ...
20:26:12 <Cale> QtPlaty[HireMe]: because without it, you can't tell if something in a pattern is a new variable to be brought into scope for matching, or if it's supposed to be a data constructor.
20:26:19 <Cale> More importantly...
20:26:22 <Cale> f Nothing = ...
20:26:24 <Cale> vs.
20:26:27 <Cale> f nothing = ...
20:26:30 <ray> yeah, that's simpler
20:26:58 <QtPlaty[HireMe]> Cale: But the compiler knows if that is bound or not.
20:27:36 <hatds> that's not a good solution
20:27:52 <hatds> because it has to default to "value" if it doesn't see "Nothing" in scope
20:27:59 <ray> > let nothing = Nothing in let f nothing = nothing * 2 in f 2
20:28:01 <lambdabot>   4
20:28:30 <sjanssen> QtPlaty[HireMe]: changing behavior depending on which names are bound can lead to nasty surprises
20:28:30 <hatds> so if you import Data.Maybe later then your f Nothing = ...  has a changed meaning
20:28:32 <MoonPatrol> What's a good resource for learning lambda calculus?
20:28:59 <QtPlaty[HireMe]> sjanssen: Such as?
20:29:20 <sjanssen> QtPlaty[HireMe]: id x = x
20:29:24 <ray> lambda calculus is short, you can get it from wikipedia
20:29:42 <sjanssen> QtPlaty[HireMe]: then somebody comes along and adds "data x = x" in the next line, or in a module you import
20:29:45 <hatds> Pierce's Theory and Programming Languages
20:29:57 <sjanssen> QtPlaty[HireMe]: the type of id changes
20:30:07 <hatds> goes into lambda calculus and then simply typed lambda calculus in first couple chapters
20:30:17 <hatds> *sorry Types and Programming Languages
20:30:39 <MoonPatrol> thanks hatds, i'll keep an eye out for it
20:31:01 <hatds> ray's right though -- for just lambda calculus itself start with wikipedia
20:31:33 <Gracenotes> there are some nice PDF manuals out there too
20:31:51 <Gracenotes> lots of resources to look through.
20:32:09 <Gracenotes> it does make a bit more sense when you've been doing Haskell for a bit, it seemed to me
20:32:38 <BMeph> Ah, Wikipedia and online PDFs - an inexhaustible global resource! ;p
20:32:49 <hatds> Gracenotes: vice versa too
20:33:25 <roconnor> is GCD well defined on Z ?
20:33:37 <roconnor> maybe I should just say coprime
20:33:40 <wli> Yes.
20:33:41 <hatds> on ZxZ ?
20:34:05 <roconnor> hatds: ya
20:34:16 <hatds> well up to sign I guess :)
20:35:01 <roconnor> ya
20:35:09 <roconnor> the sign is tricky
20:35:13 <hatds> one day I'm going to be doing math and write my functions as Z->Z->Z instead of ZxZ->Z and confuse the hell out of whoever I'm with
20:35:16 <roconnor> > gcd (-1) 1
20:35:17 <lambdabot>   1
20:35:47 <hatds> especially if it is category theory
20:35:53 <Gracenotes> well, negative numbers and the like can be coprime to each other
20:35:57 <MyCatVerbs> hatds: just show them the proof in data type algebra that the two are equivalent, no?
20:36:13 <roconnor> @check ((0<=) .) . gcd
20:36:14 <lambdabot>   "* Exception: Prelude.gcd: gcd 0 0 is undefined
20:36:35 <roconnor> huh
20:36:37 <hatds> MyCatVerbs: :)
20:36:41 <roconnor> is that really true
20:36:46 <roconnor> I thought it would be 0
20:36:47 <Gracenotes> some people say it's 0
20:37:07 <hatds> as ideals there is no problem
20:37:09 <hatds> :)
20:37:21 <roconnor> what's wrong with Haskell?
20:37:31 <roconnor> Cale: in our new Haskell can we have gcd 0 0 = 0 ?
20:38:19 <Cale> But it's supposed to be the greatest number which divides both yeah?
20:38:26 <MyCatVerbs> hatds: oh, right, cat theory. Not all categories have the arrows themselves as objects within the categories, right?
20:38:27 <Cale> But every integer divides 0
20:38:33 <Cale> and there's no greatest one
20:38:54 <hatds> gcd(a,b) * Z  = a * Z + b * Z
20:39:34 <hatds> where a * Z = set of all a*n, where n is in Z
20:39:49 <Gracenotes> if that's an invariant, then forall z in Z, gcd(0, 0) * z = 0
20:40:01 <Gracenotes> (follows, of course...)
20:40:54 <Gracenotes> @check \a b c -> a == b || gcd a b * c = a*c + b*c
20:40:55 <lambdabot>   Parse error at "=" (column 33)
20:41:00 <Gracenotes> @check \a b c -> a == b || gcd a b * c == a*c + b*c
20:41:01 <lambdabot>   "Falsifiable, after 0 tests:\n0\n-2\n-2\n"
20:41:17 <Gracenotes> hm... negatives again
20:42:02 <hatds> wait..what?
20:42:04 <MoonPatrol> so, someone asked me the other day, another programmer actually, he said "Why the hell do you want to learn Haskell? No one uses it."
20:42:23 <roconnor> Cale: 0 is the greatest integer in the lattice of dividability
20:42:24 <hatds> did someone just call me a nobody? :(
20:42:45 <MoonPatrol> I believe he did...
20:42:46 <roconnor> is there a mathematical symbol for coprime?
20:42:55 <hatds> (a,b) = 1
20:43:17 <MoonPatrol> I still want to learn it, having no other driving reason than.. just wanting to
20:43:38 <Gracenotes> functional programming has some nice ideas that other languages like C# are adapting
20:43:43 <hatds> MoonPatrol: you'll definitely make it with that attitude
20:43:44 <Cale> MoonPatrol: This channel is pretty full for being empty.
20:43:44 <roconnor> Some people think greatest means in <-order, but it really means greatest in |-order.
20:44:07 <roconnor> and why is coprime not the dual of prime?
20:44:18 <hatds> co as in companion in this case
20:44:45 <hatds> well I guess categorical co is companionish too
20:45:30 <MoonPatrol> hatds: I certainly hope I will... or I'll go crazy trying
20:45:49 <Cale> MoonPatrol: Well, you should hang around here
20:45:54 <Cale> MoonPatrol: ask questions :)
20:45:57 <Gracenotes> on day, the things and the cothings will approach each other, and they will have a crazy dual [sic]. It shall be the coapocalypse!
20:46:07 <Gracenotes> copocalypse if you will
20:46:07 <MoonPatrol> :-) Oh its guaranteed I'll have questions
20:46:20 <roconnor> oh âŠ¥ is sometimes used for coprime.
20:46:36 <roconnor> ... that would be very confusing to use in my thesis.
20:46:37 <Cale> roconnor: I actually like that
20:47:17 <roconnor> hmm
20:47:31 <roconnor> It would be hard to get away with using any other symbol though...
20:48:08 <hatds> (p,q) = 1 no good?
20:48:13 <Gracenotes> define your own notation? :\  :/  o,o
20:48:20 <roconnor> hatds: it is very tempting
20:48:34 <roconnor> but it feels wrong to take the gcd of integers.
20:48:53 <hatds> why?
20:49:02 <roconnor> because of sign issues
20:49:15 <Gracenotes> factors(a) U factors(b) = 1? >_>
20:49:27 <hatds> in algebra everything is often up to units
20:49:39 <Gracenotes> er, make that a âˆ©
20:49:54 <Gracenotes> â‹‚
20:49:57 <hatds> +1/-1 in Z,   or +1/-1/ i / -i in Z[i]
20:50:15 <Cale> I'm not sure I care for that pair notation. at least write gcd(p,q) = 1
20:50:33 <roconnor> Cale: how about p /\ q = 1 :)
20:50:43 <hatds> (p,q) = (1)
20:50:46 <Cale> Could work.
20:50:47 <Gracenotes> er, actually, that wouldn't be accurate
20:50:50 <hatds> or (p,q) = Z
20:50:58 <roconnor> then we can try to figure out if /\ means min, gcd, or something else :P
20:50:59 <Cale> <p,q> = Z ?
20:51:06 <Gracenotes> or maybe it would...
20:51:21 <Cale> (well, \langle p,q\rangle)
20:51:28 <hatds> Cale: if p and q are coprime then any element of Z can be written as a sum ap+bq
20:51:47 <roconnor> I already stole the \langle \rangle notation for something else
20:51:47 <Cale> hatds: yeah, I was questioning the choice of notation more than anything :)
20:51:51 <hatds> (er maybe you were just suggesting different brackets :))
20:51:53 <hatds> :)
20:52:35 <Gracenotes> (:[])â‹™(:[])
20:52:38 <Cale> I don't generally like reusing round brackets for things very much. Open intervals are an exception.
20:52:51 <hatds> "p ~ q" for p and q coprime    "p /~ q" otherwise?
20:52:55 <Cale> But normally they make me think of ordered tuples
20:53:33 <roconnor> I don't even use them for open intervals
20:53:37 <roconnor> I use ]a, b[
20:54:10 <sshc> what's a good refence to learning haskell?
20:54:18 <Gracenotes> ~, â‰
20:54:18 <roconnor> @where lyah
20:54:18 <lambdabot> www.learnyouahaskell.com
20:54:48 <MoonPatrol> greatest. site. ever.
20:55:49 <Cale> roconnor: Somehow my desire to make bracket pairs match up overcomes my desire not to reuse the ordered pair notation there.
20:56:28 <roconnor> Cale: for me it is the opposite.
20:56:38 <hatds> http://www.haskell.org/haskellwiki/Learning_Haskell  <- best way is to keep devouring any sort explanatory material on haskell
20:57:16 <sshc> thanks
21:04:01 <roconnor> I can't believe that gcds are so expensive
21:04:08 <roconnor> they have such good complexity.
21:04:54 <MyCatVerbs> roconnor: integer division is expensive, and gcd does linearly many of them in.
21:05:15 <roconnor> oh?
21:05:25 <roconnor> I thought it did log many
21:05:38 <roconnor> maybe gcd is slower than I thought.
21:05:50 <wli> Worst case for gcd's is two Fibonacci numbers, or so I thought.
21:07:24 <roconnor> wli: right.
21:07:46 <MyCatVerbs> roconnor: logarithmic in the values, linear in the lengths, no?
21:07:53 <roconnor> and the number of divisions is their index in the seequence.
21:07:57 <roconnor> MyCatVerbs: Ahhh
21:08:04 <roconnor> right
21:08:08 <roconnor> god I'm dumb.
21:08:24 <roconnor> okay, let me think about this.
21:08:29 <roconnor> right
21:08:32 <MyCatVerbs> Nah, it's not at all intuitive at first.
21:08:45 <MyCatVerbs> Nothing involving naturals in coml
21:08:47 <roconnor> so I'm always measuring complexity in terms of the values, not the length.
21:08:55 <MyCatVerbs> complexity theory ever is.
21:08:57 <roconnor> so it is logarithmic.
21:08:59 <roconnor> whew
21:09:29 <roconnor> But I can understand why you said linear.  That is totally reasonable.
21:09:35 <hatds> what's the norm interpretation if someone says an algorithm on integers is O(n)?
21:09:58 <MyCatVerbs> hatds: in formal complexity theory, the number of bits in the integer's representation.
21:10:04 <hansfbaier> roconnor: lyah is awesome
21:10:12 <hansfbaier> thanks!
21:10:16 <roconnor> hansfbaier: I've never really read it.
21:10:40 <MyCatVerbs> hatds: unless otherwise specifically specified. Even then you'd just call it O(k^n) for some k > 1, to avoid misleading anyone who is skimming your paper.
21:11:14 <hansfbaier> roconnor: I just looked at it now. Since I write courseware as a job, I am pretty impressed.
21:11:39 <necroforest> Can you write a recursive lambda function?
21:11:45 <roconnor> Is Bonus looking for a job :)
21:11:58 <hatds> :t fix
21:11:59 <lambdabot> forall a. (a -> a) -> a
21:12:02 <roconnor> necroforest: I can
21:12:04 <MyCatVerbs> necroforest: almost. You have to use fix.
21:12:23 <roconnor> MyCatVerbs: you don't haaaaaaaaave to use fix.  You can use Mu instead.
21:12:37 <MyCatVerbs> > fix (\r n -> if n == 0 then 1 else n * (r (n-1))) 10
21:12:38 <lambdabot>   3628800
21:12:56 <MyCatVerbs> > let fac n = if n == 0 then 1 else n * (fac (n-1)) in fac 10
21:12:57 <lambdabot>   3628800
21:13:12 <MyCatVerbs> roconnor: Mu is just type-speak for fix. :P
21:13:26 <Berengal> How does Mu even work?
21:13:38 <roconnor> @src Mu
21:13:39 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
21:14:05 <MyCatVerbs> -- you do the Okie Pokie and you turn around, that's what it's all about
21:14:11 <necroforest> oh, so fix basically sets the lambda functions first argument to itself?
21:14:16 <BMeph> The whole "GCD is finding the last element in a continued fraction" makes that all easy as cake to see. :)
21:14:32 <MyCatVerbs> necroforest: yes, it's Haskell's version of the Y combinator.
21:14:51 <MyCatVerbs> (In case you've heard of that elsewhere.)
21:14:55 <necroforest> nope :-P
21:15:16 <MyCatVerbs> Oh. Well, fix f = f (f (f (f (f (f (f (f (f (f (f... until your keyboard wears out. :)
21:15:38 <roconnor> BMeph: it also means GCD 0 0 = 0, right?
21:15:40 <Berengal> MyCatVerbs: Your keyboard would wear out long before you got to the end of that...
21:15:43 <MyCatVerbs> Or, there's no "basically" about it at all, you got it in one. fix feeds its argument to itself.
21:16:06 <roconnor> @src fix
21:16:06 <lambdabot> fix f = let x = f x in x
21:17:13 <Gracenotes> also if f is a function that takes more than one argument, you can do f (f (f (f ...... ))) arg1 arg2 arg3 etc.
21:17:18 <Gracenotes> > fix const 3
21:17:19 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
21:17:19 <lambdabot>      Proba...
21:17:26 <Gracenotes> :\
21:17:34 <roconnor> > fix (const 3)
21:17:35 <lambdabot>   3
21:17:37 <Gracenotes> oh, right
21:17:48 <Berengal> > fix (flip const) 3
21:17:50 <lambdabot>   3
21:17:52 <roconnor> > fix bitSize
21:17:53 <lambdabot>   64
21:18:09 <roconnor> , fix bitSize
21:18:11 <lunabot>  32
21:18:12 <Berengal> > fix error
21:18:14 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:18:24 <roconnor> Berengal: I love that code
21:18:27 <Gracenotes> > fix (\f a -> if a == 0 then 1 else a * f (a-1)) 10
21:18:29 <lambdabot>   3628800
21:19:02 <Berengal> roconnor: So do I. The best part 'error's least fixed point not being bottom
21:19:14 <Berengal> best part is*
21:19:24 <Gracenotes> it also is a terrible thing to discover by accident in a debugging rage
21:19:30 <Berengal> Well, it is, but only in one sense
21:19:48 <Gracenotes> you tell ghci to fix your error... but then you are only flooded with exceptions ;_;
21:19:56 <hatds> haha
21:19:59 <necroforest> > fix fix
21:20:00 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
21:20:00 <lambdabot>      Proba...
21:20:06 <necroforest> dammitr
21:20:07 <necroforest> lol
21:20:09 <Berengal> Gracenotes: That won't respond to ^C
21:20:22 <roconnor> Berengal: really?
21:20:23 * roconnor tries
21:20:25 <Gracenotes> fix error? does for me
21:20:32 <Berengal> At least it didn't in 6.10.2
21:20:35 <necroforest> > fix (\f -> fix f)
21:20:36 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
21:20:37 <lambdabot>      Proba...
21:21:03 <hatds> let id' = fix id
21:21:09 <hatds> there, made a nice id function for ya
21:21:12 <Berengal> It does work in 6.10.3
21:21:16 <Gracenotes> > fix (\f -> fix) (const 3)
21:21:16 <Berengal> > fix id 3
21:21:18 <lambdabot>   3
21:21:18 <lambdabot>   * Exception: stack overflow
21:21:37 <hatds> it's such a lazy identity function it never returns
21:22:15 <Berengal> > let id' = fix id in id' 42
21:22:17 <necroforest> > fix (\f -> fix) (fix (\f -> fix)) (const 3)
21:22:17 <lambdabot>   * Exception: stack overflow
21:22:18 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
21:22:18 <lambdabot>        Exp...
21:22:26 <mle> > fix error
21:22:28 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:22:53 <Gracenotes> > fix id 95 40 329 39 203  "oh no" 'h' 'a' [] [] 49302 4 42 Nothing [1, 4, 10, 3] id negate 30291930 error foldl foldr scanl scanr
21:22:55 <lambdabot>   * Exception: stack overflow
21:25:15 <hatds> what?
21:25:53 <hatds> gah :)
21:26:35 <roconnor> fix (ap (ap . (par .) . (. (2 *))) (. ((1 +) . (2 *)))) 1 is fun too
21:26:57 <Gracenotes> I sense @pl mutilation
21:27:38 <necroforest> > fix (ap (ap . (par .) . (. (2 *))) (. ((1 +) . (2 *)))) 1
21:27:59 <necroforest> well that didn't work
21:28:35 <Saizan> "fun" as in fork-bomb i guess
21:28:51 <Saizan> @bot
21:28:51 <lunabot>  :)
21:28:58 <roconnor> oh
21:29:06 <roconnor> i figured that lambdabot was patched
21:29:12 <roconnor> ...
21:29:14 <ivanm> to do what?
21:29:14 <ray> thunkbomb
21:29:33 <roconnor> ivanm: to limit threads...
21:29:35 <roconnor> hmm
21:29:42 * Saizan wonders what version of mueval lambdabot is using
21:30:04 <Saizan> there should be another process killing off the one evaluating
21:30:06 <necroforest> Can you do pattern matching in lambdas?
21:30:15 <roconnor> necroforest: yes
21:30:50 <lambdabot>   thread killed
21:30:51 <lambdabot> :)
21:30:56 <necroforest> lol
21:31:09 <MyCatVerbs> Caveat is, you only get *one* pattern.
21:31:23 <MyCatVerbs> But you can put a case statement pretty much anywhere.
21:31:45 <Gracenotes> oh come on, you can't just post a forkbomb in a large channel and not add a disclaimer
21:31:59 <Gracenotes> fuck you :(
21:32:03 <roconnor> :(
21:32:08 <roconnor> sorry it was dumb of me
21:32:20 <MyCatVerbs> Surely the "par" in there set off warning bells.
21:32:37 <MyCatVerbs> @unpl (ap (ap . (par .) . (. (2 *))) (. ((1 +) . (2 *))))
21:32:38 <lambdabot> ((\ o t -> (\ ad -> par (o (2 * ad))) >>= \ q -> t >>= \ p -> return (q p)) >>= \ h -> (\ f aj -> f (1 + (2 * aj))) >>= \ g -> return (h g))
21:32:47 <MyCatVerbs> ...thanks, lambdabot.
21:34:38 <Gracenotes> ap f g a = f a (g a)
21:35:21 <ray>   thread killed
21:37:20 <m3ga> does Peter Simons (hsemail, hsdns etc) ever hang out here?
21:39:40 <dons> hmm. not in a long time, iirc
21:41:19 <m3ga> any way to contact him. i tried email, nothing but silence, but i noticed he updated one of his packages in cabal about a week ago
21:49:22 <harovali1> has haskell been tried as an alternative to javascritp in http clients ?
21:49:51 <MyCatVerbs> Nope.
21:50:03 <MyCatVerbs> I wish all questions were this easy.
21:50:43 <harovali1> MyCatVerbs: thanks
21:58:57 <roconnor> MyCatVerbs, harovali1: not so fast.  YHC has an experimental, highly broken javascript backend.
22:06:20 <Neut> Does anyone know of a good haskell tutorial on records/trees?
22:07:41 <BMeph> Neut: Nope. Next question? ;p
22:08:04 <Neut> Ok, Im trying to build a Tree using two different data types with both contain records
22:08:36 <hatds> sounds like a questionable solution
22:08:41 <QtPlaty[HireMe]> Neut: Why should it matter what your datatypes are?  Shouldn't the values be abstracted out?
22:09:13 <roconnor> hatds: do yo go by some other username?
22:09:26 <hatds> roconnor: no
22:09:27 <QtPlaty[HireMe]> Tree x = Node x (Tree x) (Tree x) | Leaf x
22:09:52 <QtPlaty[HireMe]> Or am I missing something?
22:10:15 <Neut> QtPlaty[HireMe]: I'm sure you aren't, I on the other hand am
22:10:34 <hatds> can you explain the problem you are trying to solve?
22:10:36 <Neut> I understand basic trees like that
22:11:14 <roconnor> Tree a b = Node a (Tree a b) (Tree a b) | Leaf b
22:11:17 <roconnor> :)
22:13:01 <Neut> ;)
22:14:47 <ray> why stop there? Tree a b c d = Node a b (Tree a b c d) (Tree a b c d) | Leaf c d
22:15:13 <Neut> :ray thats a mother of a tree
22:15:32 <hatds> data AB a b = TypeA a | TypeB b ?
22:15:43 <hatds> or Either even :)
22:15:46 <roconnor> ray: because that is simply Tree (a,b) (c,d) given my definition
22:15:51 <ray> it's actually useless, because if i have roconnor's tree i can just ptu tuples in it
22:15:54 <ray> put
22:16:03 <bwr> Is there a function available to capture a portion of the screen?
22:16:19 <bwr> I would assume it would be in a package like gtk2hs but I am not seeing it
22:16:26 <roconnor> and by simply, I mean, really complicated due to laziness making them different.
22:16:35 <roconnor> :/
22:16:43 <roconnor> stupid partial values
22:16:59 <roconnor> where is Miranda when you need it.
22:28:39 <wli> Dead and gone.
22:29:26 <roconnor> Eiffel's covarient argument subtyping is so bizarre.
22:31:30 <Saizan> discovered anything else in the meantime?
22:31:53 <roconnor> there is a comment here: http://lambda-the-ultimate.org/node/2593
22:32:06 <roconnor> ``Unfortunately, Eiffel doesn't do the sensible thing in this case and runtime-check the arguments, throwing an exception if a type error occurs. Early versions of the language simply crashed when covariant argument types were used incorrectly; later versions of the language employed a rather bizarre hack to prevent undefined behavior--but which had the unpleasant that the introduction of a new subclass into the system could break
22:32:08 <roconnor> existing code.
22:34:33 <roconnor> I thought covarient subtyping would have some interesting theory behind it, instead it just appears to be totally broken.
22:35:41 <photonen> to do inhertiance, ie inherit 30 functions and override 5, how would you? typeclasses? ot would you just imort hiding an rewrite those?
22:36:32 <roconnor> you could use modules to do that.
22:37:04 <Gracenotes> there are proposed typeclass extensions that do that
22:37:52 <Gracenotes> inheritance isn't /so/ much needed, though
22:39:59 <inimino> you're better off without it IMHO
22:41:49 <photonen> i dont get the difference between partial application and currying
22:42:27 <photonen> > let pa a b c = a+b+c in map (pa 3 4) [1..10]
22:42:31 <lambdabot>   [8,9,10,11,12,13,14,15,16,17]
22:42:34 <photonen> partial application?
22:43:00 <inimino> photonen: both terms are pretty often used loosely
22:43:02 <inimino> photonen: yes
22:43:13 <roconnor> > show (read "7")
22:43:14 <lambdabot>   "* Exception: Prelude.read: no parse
22:43:42 <roconnor> damn defaulting
22:43:45 <roconnor> > show (read "()")
22:43:46 <lambdabot>   "()"
22:44:48 <roconnor> @type curry
22:44:50 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:45:15 <roconnor> currying is when you take a function that takes a tuple for arguments and turn it into a function that returns a function.
22:45:20 <Gracenotes> same thing as ((a, b) -> c) -> (a -> b -> c)
22:45:48 <roconnor> currying makes partial application much easier, because when a "binary" function f is in curried form, partial application is simply (f 0)
22:46:07 <roconnor> however, even uncurried functions can be partially applied.
22:46:38 <roconnor> if g is a binary uncurried function (g: (a,b) -> c),  then partial application can be written as (\y -> g (0,y))
22:46:54 <roconnor> or g . (0,) if you like point free code.
22:47:53 <Saizan> when curried you can also manage to do something with the first argument before waiting for the second
22:47:59 <Saizan> but that's an optimization
22:48:00 <inimino> hm
22:48:32 <inimino> I guess my working definition of "partial application" is pretty informal but I don't think that fits it
22:48:59 <roconnor> Saizan: I'd say that is partial application.  You can manage to do something with (\y -> g (0,y)) too.
22:50:18 <Saizan> roconnor: true, but not with GHC
22:51:41 <Saizan> ime, at least
23:12:06 <Neut> If I have a tree and want to recurse threw it x times, until x = 0 how would I go about it?
23:12:15 <Neut> with a base case for x=0
23:14:00 <BMeph> Neut: First tell us what does it mean to recurse threw (sic) it once. :)
23:14:34 <Neut> Eh sorry I mis typed my question, I mean I want it to recurse threw and BUILD it x times, not just recurse threw it
23:16:41 <mjrosenb> Neut: itym through
23:17:01 <mjrosenb> Neut: unless you are building it by throwing exceptions in the past
23:28:51 <BMeph> Neut: Do you mean make x copies, make a tree with x levels, one with x branches, or what? What does it mean to have a tree, and build it? Your response made what you are asking more confusing. :\
23:31:48 <ski> roconnor : see "binary methods problem" and how it is handled in O'Caml
23:57:20 <ski> (roconnor : for the latter, see Objects in Caml. 3.16 Binary methods <http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc33>)
