00:29:40 <Twey> Is there an easy way to print a float to the minimum possible precision?
00:30:01 <Twey> E.G. 12.0 -> "12", 12.1 -> "12.1", 12.12 -> "12.12"
00:30:59 <lament> show does all but the first example
00:32:32 <Axman6> Twey: splitting on the '.' would be a good start, and then checking if the denominator was all zeros...
00:35:05 <ray> just show, remove trailing zeros, and then remove trailing .s
00:36:14 <Axman6> > reverse . dropWhile (not . (== '.')) . dropWhile (== '0') . reverse . show $ 12.3
00:36:14 <Twey> It's obviously fairly easy to roll-your-own... I was wondering if there was a standard option :)  OK, thanks.
00:36:15 <lambdabot>   "12."
00:36:22 <Axman6> > reverse . dropWhile ((== '.')) . dropWhile (== '0') . reverse . show $ 12.3
00:36:23 <lambdabot>   "12.3"
00:36:26 <Axman6> > reverse . dropWhile ((== '.')) . dropWhile (== '0') . reverse . show $ 12. 3
00:36:27 <lambdabot>       Overlapping instances for Show (a -> c)
00:36:27 <lambdabot>        arising from a use of `s...
00:36:29 <Axman6> > reverse . dropWhile ((== '.')) . dropWhile (== '0') . reverse . show $ 12.03
00:36:30 <lambdabot>   "12.03"
00:36:36 <Axman6> > reverse . dropWhile ((== '.')) . dropWhile (== '0') . reverse . show $ 12.0
00:36:37 <lambdabot>   "12"
00:37:06 <Twey> Hehe, ((== '.')) looks like one of those bunny emoticons
00:37:07 <ray> totally pointless
00:37:16 <Axman6> heh, yeah
00:37:25 <Twey> ray: *laughs*
00:38:38 <Twey> > (??)
00:38:39 <lambdabot>   Not in scope: `??'
00:38:54 <Twey> @let (y ?? n) p = if p then y else n
00:38:56 <lambdabot>  Defined.
00:39:18 <vegai> has anyone used hsdaemonize with a program that has threads?
00:39:22 <ray> (??) for prelude!
00:39:27 <Twey> Hear hear!
00:39:29 <ray> or at least data.bool
00:39:41 <vegai> my program freezes forever at "threadDelay 500000" when it's run under daemonize
00:41:14 <Twey> > let minshow x = (round . show ?? show) (x == (fromIntegral $ round x)) x in minshow "12.5"
00:41:15 <lambdabot>       precedence parsing error
00:41:15 <lambdabot>          cannot mix `(.)' [infixr 9] and `(??)...
00:41:24 <Twey> > let minshow x = ((round . show) ?? show) (x == (fromIntegral $ round x)) x in minshow "12.5"
00:41:25 <lambdabot>       No instance for (Integral String)
00:41:26 <lambdabot>        arising from a use of `round' ...
00:41:41 <Twey> > let minshow x = ((show . round) ?? show) (x == (fromIntegral $ round x)) x in minshow 12.5
00:41:43 <lambdabot>   "12.5"
00:41:46 <Twey> > let minshow x = ((show . round) ?? show) (x == (fromIntegral $ round x)) x in minshow 12.0
00:41:47 <lambdabot>   "12"
00:41:49 <Twey> Duh
00:41:51 <Twey> There we go
00:41:54 <vegai> oh, and I cannot forkProcess (which daemonize uses apparently) when +RTS -nk where k>1 :-(
00:42:03 <Twey> I don't suppose @let will let me specify a precedence?
00:43:17 <vegai> so, is it possible to make a daemon process at all when using multiple threads?
00:45:19 <mcnster> q: if i make "x <- foo", how can i be sure foo is computed non-lazily?
00:45:41 <vegai> aww: http://hackage.haskell.org/trac/ghc/ticket/1185
00:45:43 <mauke> are you in IO?
00:45:50 <mcnster> mauke, yes
00:45:55 <mauke> :t evaluate
00:45:57 <lambdabot> Not in scope: `evaluate'
00:46:02 <mauke> @hoogle evaluate
00:46:02 <lambdabot> Control.Exception evaluate :: a -> IO a
00:46:02 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
00:46:08 <mauke> there we go. evaluate x
00:46:22 <Axman6> hmm, is there any way to have cyclic imports working?
00:46:35 <mauke> Axman6: yes
00:46:44 <mcnster> mauke, ty :)
00:46:45 <Axman6> language extension?
00:47:32 <mauke> on the contrary
00:48:32 <Axman6> well ghci is complaining when i import Foo in Bar and Bar in Foo
00:49:29 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
00:50:42 <Axman6> thanks mauke, looks perfectr
00:50:44 <Axman6> -r
00:52:34 <Axman6> ok, there must be a way to avoid this. fix the proble, not the symptoms
00:52:38 <Axman6> m*
00:56:18 <thomastc> well, if you have two modules that depend on each other, why are they separate modules in the first place?
00:57:41 <Lemmih> There are legitimate uses for recursive modules.
00:58:11 <Axman6> because they're logically seperate modules (a CPU and Memory for a CPU emulator/simulator
00:58:28 <Axman6> s/CPU/computer
00:58:50 <mauke> thomastc: bot plugins, each in their own module; a top-level module with a list of all plugins
00:59:06 <mauke> thomastc: one of the plugins is 'list' and needs to know which plugins are loaded
01:00:09 <thomastc> ah, I see, thanks
01:07:26 <vegai> damn, cannot even do myprogram & eexit
01:07:32 <vegai> s/eexit/exit/
01:07:39 <vegai> threadDelay will freeze again
01:08:57 <vegai> no, not freeze. It'll abort the program...
01:09:10 <vegai> weird
01:16:18 <wjt> dcoutts: hmm, so I just use the buildHook to generate it, and the instHook to copy it to the right place
01:18:15 <vegai> no, it crashes at an atomically $ ... block
01:18:58 <wjt> dcoutts: thanks for the pointer
01:20:05 <vegai> is writing to TVar a bad  thing to do in a signal handler?
01:20:18 <vegai> or should it not matter?
01:21:24 <RogerTaylor> Hello everyone
01:21:37 <RogerTaylor> Does anyone know how to get GHCi to find Cabal-built objects?
01:21:58 <RogerTaylor> I've tried "ghci -idist/build Blah.hs"
01:22:03 <RogerTaylor> and ghci doesn't find them
01:22:13 <liyang> cabal install said packages?
01:22:17 <RogerTaylor> not installed
01:22:19 <RogerTaylor> in the source dir
01:22:35 <RogerTaylor> i want GHCi to use the objects if they're built, or interpret the source otherwise
01:22:49 <RogerTaylor> it works if I say "ghc --make Blah.hs"
01:22:53 <RogerTaylor> then ghci Blah.hs
01:22:56 <liyang> er... I'll leave that to someone else.
01:23:04 <RogerTaylor> where Blah is hierarchical
01:23:21 <RogerTaylor> hey! that's my gambit! :-)
01:23:25 <liyang> (Blah is heretical.)
01:26:27 * RogerTaylor I note the manual doesn't promise different behaviour
01:26:29 <RogerTaylor> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
01:26:48 <RogerTaylor> 4.6.3 the search path
01:27:14 <RogerTaylor> GHCi will search for source, but not objects, it seems
01:38:11 <Neut> Hello
01:38:29 <ordnungswidrig> hi
01:38:43 <Neut> I was wondering if I could get some help with haskell trees?
01:39:52 <andun> Neut: feel free to ask your questions. use hpaste2 to paste code
01:39:55 <andun> @where hpaste2
01:39:55 <lambdabot> http://hpaste.org/
01:39:57 <Neut> I've been told this is a good chan for haskell assistance
01:40:16 <Saizan> yes, better to come with a somewhat specific question though
01:40:26 <wunki> Neut: ask your question, than wait... :)
01:40:33 <Neut> Ok,
01:40:57 <Neut> My question is about my understanding of a tree 'word' namely anotation
01:41:02 <ordnungswidrig> How can I calc a sha sum of a n-tuple, say,  (Int, String, String). sha1 is ByteString -> Digest
01:41:03 <Neut> what exactly does this mean in relation to trees?
01:41:25 <ordnungswidrig> is there anything llike Int -> ByteString?
01:41:45 <mauke> probably in binary
01:41:49 <Saizan> ordnungswidrig: there are binary or bytestring-show on hackage
01:42:51 <ordnungswidrig> Saizan: hoogle did not find anything about Int -> ByteString
01:43:16 <ziman> :t pack . show :: Int -> ByteString
01:43:17 <lambdabot> Not in scope: `pack'
01:43:17 <lambdabot>     Not in scope: type constructor or class `ByteString'
01:43:36 <Saizan> Neut: annotation? that's not a very technical term, it may refer to any data attached to a tree node
01:43:46 <ordnungswidrig> ziman: I see
01:44:09 <ziman> ordnungswidrig, but that's decimal
01:44:23 <_dls> arg... so I'm trying to play with a 17x8617 matrix in haskell, and for starters just dumped the thing into a .hs file as a list of lists... this turns out to be very bad and makes the haskell compiler very slow and require 500 megs of *stack*... any thoughts on a better way to get that kind of data into my program?
01:44:44 <Saizan> with Data.Binary you can use encode to get a lazy bytestring out of an Int
01:44:48 <_dls> (500 megs of stack to compile)
01:45:56 <ziman> _dls, does reading the matrix from a file consume as much memory? I mean `matrix <- read `fmap` readFile "matrix.txt"'
01:46:37 <Saizan> you could have it in an array in a .c file and use the FFI to access it
01:47:05 <_dls> ziman: I doubt it, fair enough... it just seems odd that an inline array would make the compiler sweat much. will try
01:47:09 * thoughtpolice is happy to see ghc's dynamic library support being fixed
01:47:41 <_dls> Saizan: good call, will experiment with that as well :)
01:48:33 <ordnungswidrig> ok, Int -> Digest works fine. How do I concat sha digest's i a correct way? sha(concat("abc","def")) must not be equal to sha(conact("ab","cdef")) so sha1 (first ++ second) will not do
01:50:09 <Saizan> _dls: see Data.Array.Storable
01:50:23 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2392#a2392
01:51:51 <Saizan> ?type \f xs -> minimum (map f xs)
01:51:52 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a1
01:53:01 <Saizan> using minKeys for f
01:53:53 <Saizan> > minimum (map (+1) [1..5])
01:53:55 <lambdabot>   2
01:57:26 <Neut> got it
02:09:10 <QtPlaty[HireMe]> If I have a guarded expression that doesn't match will it fall though to the next pattern (which isn't a part of that guard)
02:11:26 <mauke> > let foo _ | False = "fail"; foo x = x in foo "success"
02:11:27 <lambdabot>   "success"
02:11:40 <QtPlaty[HireMe]> Thanks mauke
02:21:32 <n00b2000> Hi, I'm a complete newbie to Haskell, and I'm trying to install wxHaskell. I get 'Failed to load interface for Data.Time' when attempting to run 'make'. Any ideas or pointers?
02:23:41 <Neut> Does anyone here have experience with game trees?
02:26:08 <Botje> Neut: it's best to pose your question directly and see if anyone replies
02:26:31 <Botje> in the worst case you have a well thought-out question you can ask to the right people :)
02:26:51 <Neut> Ok good point,
02:27:24 <Neut> It's a strange question in the sense I don't want the answer just a nudge in the right direction,
02:27:27 <cjs> So, when using the standard Haskell I/O libraries under windows, ghc won't let me read from a file that another ghc-compiled app is writing. Anybody have any thoughts on how to get around this, and get posix-like behaviour?
02:27:29 <Neut> anyway here it is:
02:29:17 <n00b2000> Ok, can anyone explain how to install Data.Time on my system?
02:30:45 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2393#a2393
02:31:03 <Neut> Some pointers would be appreciated.
02:34:58 <doserj> n00b2000: Data.Time is in package time. so install that.
02:35:16 <Neut> ^^ if my question doesn't make sense, please let me know and I will ellaborate.
02:39:28 <lotyrin> So, I'm trying to build a package, and it depends on 'Control.Monad.Trans', and fails to build because I have both mtl and transformers on my system.
02:40:32 <lotyrin> Can I specify one or the other somehow?
02:44:45 <lotyrin> aha, ghc-pkg
02:51:11 <ordnungswidrig> is there something  like map (\x -> if (cond x) then f x else x) xs ?  A conditional map of type (a -> Bool) -> (a -> b) -> [a] -> [b]?
02:52:01 <osfameron> that'd have to be (a -> Bool) -> (a -> a) -> [a] -> [a], no?
02:52:51 * Botje ponders a cruel use of Either a a
02:53:19 <ordnungswidrig> in my case a single type would be ok but I think ... -> [a] -> [b] would be fine anyways
02:54:03 <Botje> zipWith ($) (map (\x -> if cond x then f else id) xs) xs ?
02:54:27 <Botje> if you replace the iffy if with an if' it gets a bit shorter
02:54:47 <ordnungswidrig> botje: I though there would by a mapIf in hackage
02:54:47 <sebas_> ordnungswidrig: you can use the whenA function from the bool extras package to make this
02:54:58 <ordnungswidrig> mapIf (>5) (+1) [1,2,3,4,5,6]
02:55:45 <sebas_> mapIf c f = map (f `whenA` c)
02:56:05 <ordnungswidrig> @hoogle whenA
02:56:05 <lambdabot> No results found
02:56:19 * Saizan wonders why "A"
02:56:23 <sebas_> uploaded just today to hackage
02:56:30 <sebas_> A for arrow
02:56:56 <Twey> I thought A was usually used for applicative
02:57:26 <Botje> B is for bytestring, and C for comonad
02:58:03 <sebas_> the A might be confusing indeed
02:58:24 <sebas_> whenC for categories works as well, might as well be confusing
02:58:29 <Botje> now i know my haskell ABC's, won't you come and fmap with me?
02:58:34 <Botje> it could work :)
02:58:54 <sebas_> you never know :)
02:59:08 <sebas_> but returnA is also for arrows
03:02:48 <Gracenotes> whew... coding 14 hours straight... and I have a final today. hrrrrrrm :\
03:03:04 <wunki> *uh oh*
03:03:08 * Botje pries Gracenotes away from haskell with a broom
03:03:21 <Gracenotes> oh :x it's not Haskell actually.
03:03:25 <Botje> even worse
03:03:27 <sebas_> Gracenotes: final on what?
03:03:28 <Gracenotes> not all of it anyway
03:03:31 * Botje grabs the reinforced broom :)
03:03:33 <Gracenotes> sebas_: C++
03:03:46 <Botje> hmmm
03:03:47 <Gracenotes> I'm not /too/ worried though
03:03:47 <sebas_> hmm.
03:03:51 <vegai> hmm.
03:03:54 <Gracenotes> hmm.
03:03:55 <Botje> wussy C++ or manly C++ with templates and stuff?
03:04:15 <Gracenotes> Botje: some templates, but largely basic features.
03:04:29 <Botje> if you can't get the template expander to infinite loop because of a typo, you're not really writing C++ ;)
03:04:32 <Gracenotes> at least, that's my impression. I think I'm reasonably well versed on C++, although not the corner cases
03:04:48 <fasta> What's the point of this behaviour in the debugger? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4830#a4830
03:05:09 <Botje> anyway, i should also be working on my thesis :(
03:05:14 <Neut> whats a cleaner way to do this, return (Just (snd(fromJust random))), without changing types
03:05:22 <Botje> fasta: so you don't evaluate something by accident
03:05:34 <Botje> fasta: you can just print it (without the ':') to force it
03:05:38 <Botje> or you can use :force iirc
03:05:59 <fasta> Botje: Use :print or :force to determine these types
03:06:06 <sebas_> Neut: fmap snd over random?
03:06:15 <Botje> oh, the types?
03:06:20 <Botje> yeah, that's weird :)
03:06:56 <fasta> Botje: the debugger is just an unfinished research project, unfortunately.
03:07:16 <fasta> I also tried ghood btw, which is far less advanced than I thought it would be.
03:07:18 <Botje> i've only used it once and it wasn't a big help
03:07:32 <Jedai> Neut: "return . fmap snd $ random"
03:08:02 <quicksilver> the debugger is an unfinished project. 'research' used in that context is just a meaningless perjorative :P
03:09:18 <Neut> never used fmap before, thanks.
03:10:34 <Botje> there's a slight semantic difference though.
03:10:44 <Botje> Jedai's code will return Nothing if random ever returns Nothing
03:10:50 <Botje> whereas your original code will throw an error
03:10:55 <fasta> quicksilver: Common misspelling of pejorative. ;)
03:11:07 <quicksilver> thanks.
03:11:16 <Botje> so using fmap makes your code a bit more robust ( assuming you catch the Nothing case somewhere)
03:11:21 <Neut> fmap :: (a -> b) -> f a -> f b
03:11:27 <Neut> love it, thanks
03:11:33 <sebas_> Neut: fmap lifts a function to work inside of container (more or less), in this case the value inside a Maybe
03:11:33 <Botje> have fun :0
03:11:42 <fasta> quicksilver: and yes, you have a point.
03:11:55 <Botje> right
03:12:04 * Botje closes irssi and starts vim
03:13:19 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2393#a2393  <- Can I get a nudge in the right direction with this problem, not an answer please. Just some assistance. Thanks.
03:28:28 <Workybob> Neut: you want to look at the sortBy function
03:28:46 <Workybob> also, your type looks wrong, don't you want [Choose Int] -> Choose Int
03:32:55 <Gracenotes> hm, that must be a record for me. about 14-15 hours of coding. Although, I'm pretty sure there was a time I went longer
03:33:09 <Gracenotes> okay. *sleps*
03:34:57 <cjs> Ok, this, in particular the first case of the if statement, makes me rather unhappy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4831#a4831
03:35:24 <cjs> Any thoughts on how I open up a file that I can write that others can also read in Windows?
03:35:51 <Neut> * sorry timed out
03:35:56 <cjs> And still get back a Handle I can use with all of my favourite functions in the IO monad?
03:38:35 <Peaker> Neut: is "skipMove" a data constructor?
03:39:28 <cjs> Peaker: not if it starts with a lower-case letter.
03:39:57 <Alpounet> @hoogle skipMove
03:39:57 <lambdabot> No results found
03:40:02 <Neut> its the next node in the tree
03:42:56 <Neut> im trying osmething like this
03:43:00 <Neut> bestChoose (skipMove x Move)         = x
03:43:04 <Neut> bestChoose (skipMove x xs)           = bestChoose xs
03:44:34 <taggadtyp> bestChoice?
03:44:48 <taggadtyp> anyway can you tell with words what you pass in and want to get out?
03:45:19 <taggadtyp> x and xs are generally used for lists in the form (x:xs)
03:45:28 <Twey> Neut: skipMove cannot be a data constructor, because it has no initial capital.
03:45:55 <Twey> Therefore, you cannot pattern-match upon it.
03:46:25 <Neut> kk thanks for the heads up
03:46:32 <xian> Is there a Haskell function like map except that it concatenates resulting lists on the fly? To provide a simple example: map tail [[1,2,3],[4,5,6]] yields [[2,3],[5,6]], but I would like to get [2,3,5,6]. I know I could just do foldl (++) [] list on the resulting list, but I'm looking for a standard way to do that.
03:46:39 <Peaker> cjs: I know -- I meant if he meant for it to be
03:46:42 <Peaker> cjs: because of that
03:47:27 <Peaker> xian: its better to foldr (++) than foldl (++).
03:47:29 <Peaker> @src concat
03:47:30 <lambdabot> concat = foldr (++) []
03:47:34 <ivanm> xian: concatMap ?
03:47:42 <ivanm> and concat concatenates ;-)
03:47:51 <Peaker> I dislike concatMap, I prefer  concat . map f
03:47:52 <ivanm> @hoogle (a -> [b]) -> [a] -> [b]
03:47:52 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
03:47:52 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
03:47:52 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
03:47:55 <ivanm> Peaker: why?
03:48:22 <ziman> > concatMap tail [[1,2,3],[4,5,6]]
03:48:23 <lambdabot>   [2,3,5,6]
03:48:34 <Peaker> > (concat . map tail) [[1,2,3],[4,5,6]]
03:48:34 <xian> Yes, thanks, that's what I was looking for.
03:48:35 <ivanm> due to fusion, won't they be the same anyway?
03:48:36 <lambdabot>   [2,3,5,6]
03:48:40 <ziman> > [[1,2,3],[4,5,6]] >>= tail
03:48:41 <lambdabot>   [2,3,5,6]
03:48:44 <Peaker> ivanm: because concatMap is an extra thing to learn/remember, and concat/map I know anyway :)
03:48:51 <ivanm> heh
03:48:54 <ivanm> so you're lazy :p
03:49:06 <Peaker> ivanm: if the name repeats both components in the composition, its not really abstracting anything
03:49:46 <taggadtyp> > concatMap (+1) [[1,2,3]]
03:49:47 <ivanm> Peaker: I think that -- without fusion -- concatMap is slightly more efficient than concat . map, as it has one less constructor or something...
03:49:47 <lambdabot>       No instance for (Num [b])
03:49:48 <lambdabot>        arising from the literal `1' at <inter...
03:49:57 <ivanm> taggadtyp: the function has to return a list
03:50:03 <taggadtyp> > concatMap (1:) [[1,2,3]]
03:50:05 <lambdabot>   [1,1,2,3]
03:50:06 <ivanm> > concatMap (return . succ) [1..3]
03:50:08 <lambdabot>   [2,3,4]
03:50:08 <taggadtyp> > concatMap (0:) [[1,2,3]]
03:50:09 <lambdabot>   [0,1,2,3]
03:50:17 <Peaker> @src concatMap
03:50:18 <lambdabot> concatMap f = foldr ((++) . f) []
03:50:23 <Neut> let x = "test"
03:50:25 <Neut> x
03:50:26 <taggadtyp> > concatMap (0:) [[1,2,3],[4,5,6]]
03:50:27 <lambdabot>   [0,1,2,3,0,4,5,6]
03:50:58 <Peaker> ivanm: I saw some post somewhere about concat . map f being slightly more efficient in practice than concatMap
03:51:05 <ivanm> :o
03:51:16 <Peaker> (at least with ghc)
03:51:25 <Twey> o:
03:52:09 <Peaker> Neut: you have to prefix with "> "
03:52:09 <ivanm> Peaker: I thought they were the same due to fusion...
03:52:17 <Peaker> Neut: and if you want a remembering let, you have to use @let
03:52:24 <ivanm> Peaker: don't tell him that!
03:52:38 <ivanm> IMHO, too many people @let useless stuff and then don't clean up after themselves...
03:52:54 <Peaker> @undef
03:52:55 <Neut> I was just testing out that bot is all
03:53:12 <Peaker> ivanm: since the only clean command cleans up everything anyway...
03:53:19 <ivanm> Peaker: yes, but AFAICT most don't...
03:53:23 <fasta> Why would you need to clean up?
03:53:31 <Peaker> fasta: namespace pollution?
03:53:33 <ivanm> fasta: to avoid having useless things everywhere?
03:53:43 <ivanm> it interferes with > stuff as well
03:54:06 <fasta> Then maybe the name resolving should work differently in a bot.
03:55:22 <Alpounet> @hoogle iterateWhile
03:55:22 <lambdabot> No results found
03:55:49 <ivanm> @hoogle iterate
03:55:49 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
03:55:50 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
03:55:50 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
03:55:58 <ivanm> @type until
03:55:59 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
03:56:06 <ivanm> Alpounet: ^^ are you wanting something like this?
03:56:41 <Alpounet> nop
03:56:51 <fasta> Is there a package which exports parseDouble for use with parsec? I think I wrote that one 3 times already at different times and locations.
03:56:51 <Alpounet> rather like this : (Monad m,Monad n) => (a -> Bool) -> m (n a) -> m (n a)
03:57:18 <ivanm> ummm... what is that meant to do? possibly call fail?
03:57:32 <ivanm> @hoogle (Monad m,Monad n) => (a -> Bool) -> m (n a) -> m (n a)
03:57:32 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
03:57:32 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
03:57:32 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:57:49 <Alpounet> just like iterateWhile (http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html#v%3AiterateWhile) but with an additional monadic level
03:58:42 <ivanm> oh, it keep executing it
03:58:47 * ivanm forgot about side-effects :s
03:58:52 <quicksilver> Monad m, Monad n => m (n a) is a strange type.
03:58:57 <quicksilver> monads don't compose, in general.
03:59:01 <quicksilver> that's why transformers exist.
03:59:11 <ivanm> quicksilver: because they're more than meets the eye? :p
03:59:17 <quicksilver> quite.
03:59:38 <Neut> can you have a where in a then statement?
03:59:38 <fasta> Something like http://lucille.atso-net.jp/blog/?p=389 only then complete.
03:59:58 <ivanm> Neut: hmmm?
04:00:19 <ivanm> you want to define a function locally just to the then?
04:00:22 * wjt has needed « maybeM :: Monad m => (a -> m (Maybe b)) -> Maybe a -> m (Maybe b) » several times
04:00:26 <Neut> yes
04:00:27 <ivanm> why not have it for the calling function, rather than just for the then?
04:00:40 <ivanm> if it has to be local, either make the then call another function, or use let
04:00:46 <Neut> or would it be better just to make a new function?
04:00:57 <ivanm> if it's complicated, yes IMHO
04:00:58 <Neut> yeah ok thats what I was going to do, just wanted to be sure it wasnt possivle
04:01:40 <Neut> possible even*
04:04:03 <quicksilver> it is possible.
04:04:15 <quicksilver> > if True then let x = 4 in x + 1 else 0
04:04:16 <lambdabot>   5
04:04:48 <Neut> yeah another function is probably cleaner then
04:06:23 <Alpounet> is something like this correct ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4834#a4834
04:08:48 <fasta> Alpounet: something like it probably, but this isn't ;)
04:08:57 <Alpounet> ok :p
04:09:05 <fasta> Alpounet: the syntax of the class context is incorrect to begin with
04:09:14 <Alpounet> yep.
04:09:24 <Peaker> does it make sense to implement   elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys      and not with a foldr?
04:10:41 <fasta> Peaker: it would do something else for an infinite list, but what makes sense?
04:10:52 <fasta> Peaker: I wouldn't do it.
04:11:03 <Peaker> fasta: foldl always recurses on the entire list, iiuc
04:11:07 <Peaker> @src foldl
04:11:07 <lambdabot> foldl f z []     = z
04:11:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:11:28 <fasta> Peaker: right, so it diverges on an infinite list.
04:11:35 <fasta> Peaker: which is what I said
04:11:40 <Peaker> fasta: so this implementation of elem() is O(N) whereas a foldr one is O(non-equal elements before first equal one)
04:11:56 <fasta> Peaker: yes, which is why I wouldn't do it :)
04:12:17 <Peaker> fasta: Ah, ok, this example makes people think foldl makes sense in that case
04:12:23 <Peaker> just got a question from a friend about it
04:12:56 <fasta> Peaker: if you know that you are going to inspect every element anyway, then you can just call last and inspect that one :)
04:13:18 <fasta> Peaker: much faster ^^
04:14:16 <Peaker> @src foldr
04:14:16 <lambdabot> foldr f z []     = z
04:14:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:16:33 <trez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4835 , why does runPPU' result in <<loop>>?
04:17:52 <taggadtyp> > foldr (\a b -> : b a) [] [4,3,2,1]
04:17:53 <lambdabot>   <no location info>: parse error on input `:'
04:17:59 <taggadtyp> > foldr (\a b -> b : a) [] [4,3,2,1]
04:18:00 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
04:18:00 <lambdabot>        Expect...
04:18:12 <taggadtyp> > foldr (\a b -> a : b) [] [4,3,2,1]
04:18:14 <lambdabot>   [4,3,2,1]
04:18:15 <ivanm> trez: good question...
04:18:28 <taggadtyp> > foldr (flip (:)) [] [4,3,2,1]
04:18:29 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
04:18:29 <lambdabot>        Expect...
04:18:31 * ivanm is baffled
04:18:33 <taggadtyp> > foldl (flip (:)) [] [4,3,2,1]
04:18:34 <lambdabot>   [1,2,3,4]
04:18:46 <taggadtyp> > foldl (:) [] [4,3,2,1]
04:18:47 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
04:18:48 <lambdabot>        Expect...
04:18:53 <taggadtyp> > foldr (:) [] [4,3,2,1]
04:18:54 <ivanm> trez: the only difference is how you do the recursive call, whether you pattern match or split it with a let?
04:18:54 <lambdabot>   [4,3,2,1]
04:19:02 <doserj> let pattern matches lazily
04:19:06 <roadwarrior> ivanm: welcome to the baffled club ;)
04:19:07 <ivanm> trez: do you have a base case for the empty list?
04:19:24 <Saizan_> trez: i bet with "~    (pss, as) <- loopPPU' xs
04:19:26 <ivanm> doserj: yeah, that was the only thing I could think of, but to cause a <<loop>> ?
04:19:38 <ivanm> Saizan_: but why should that make a difference?
04:19:42 <Saizan_> .. "~(pss, as) <- loopPPU' xs" it works?
04:19:56 <Saizan_> ivanm: depends on how the list is generated
04:20:07 <trez> Already hate ST.Lazy so more lazy annotations will drive me crazy
04:20:28 <ivanm> Saizan_: because the list is lazily generated?
04:20:55 <Saizan_> ivanm: i guess there's some tying the knot going on in the rest of the code
04:21:01 <ivanm> *nod*
04:27:33 <Koper`> Hi.. Not in scope: `autoconfUserHooks'.. Does this error mean that i am missing a module? Or something else?
04:27:49 <ivanm> Koper`: most probably
04:28:07 <Koper`> kk tnx
04:28:34 <ivanm> @hoogle autoconfUserHooks
04:28:34 <lambdabot> Distribution.Simple autoconfUserHooks :: UserHooks
04:28:39 <ivanm> Koper`: ^^
04:29:07 <Koper`> Distribution.Simple would be the name of the module?
04:29:15 <Saizan_> yes
04:29:34 <Koper`> hm.. Based only on its name, i guess that if i don't have it i don't have any :(
04:30:22 <quicksilver> import Distribution.Simple probbably
04:30:25 <quicksilver> that's cabal stuff
04:30:29 <quicksilver> what are you trying to do?
04:30:50 <Koper`> I'm just trying to compile someone's else software :P
04:31:00 <Koper`> They are probably not installed (the modules)
04:31:11 <Koper`> I'm trying to figure how to install them but i guess it's off topic here
04:31:45 <quicksilver> Koper`: you can't have GHC without having cabal
04:31:58 <quicksilver> Koper`: it has been part of GHC since just after the magna carta was signed.
04:32:01 <ivanm> quicksilver: unless it's a _really_ old GHC? ;-)
04:32:06 <ivanm> quicksilver: :o
04:32:07 <quicksilver> Koper`: also, that's not the error you get for 'modules not installed'
04:32:12 * ivanm dind't realise SPJ was that old...
04:32:17 <Koper`> I have ghc 6.8.2
04:32:18 <quicksilver> Koper`: the error you showed is the error for 'missing import statement'
04:32:27 <Koper`> And it's installed without cabal installed, so I guess it's possible
04:32:30 <Peaker> ivanm: how old? he looks 45?
04:32:34 <quicksilver> Koper`: no, it's not.
04:32:37 <Peaker> maybe 50?
04:32:39 <Koper`> Anyway i'm installing cabal now
04:32:42 <quicksilver> Koper`: cabal comes with every copy of GHC 6.8
04:32:47 <ivanm> Peaker: <quicksilver> Koper`: it has been part of GHC since just after the magna carta was signed.
04:32:51 <quicksilver> Koper`: every single copy.
04:32:56 <Peaker> ivanm: ah
04:32:58 <ivanm> AFAIK, the magna carta was signed a few centuries ago...
04:33:03 <quicksilver> Koper`: and 6.6 and 6.4
04:33:12 <Koper`> quicksilver: well, my distro says that cabal is not intsalled while GHC is, it might be a glitch though
04:33:21 <quicksilver> Koper`: and THAT ERROR MESSAGE IS NOT THE ERROR MESSAGE YOU GET WHEN A MODULE IS NOT INSTALLED
04:33:22 <ivanm> Koper`: it is bundled with ghc
04:33:35 <quicksilver> Koper`: your distro may be telling you that cabal-install is not instaleld.
04:33:36 <Koper`> ok then, i'll try to add an import
04:33:37 <ivanm> Koper`: "ghc-pkg list Cabal"
04:33:37 <quicksilver> that's different.
04:33:49 <quicksilver> cabal-install is a program which is not installed by default.
04:33:49 <Koper`> ivanm: yeah it says it's installed
04:33:51 <ivanm> quicksilver: or that he doesn't have an updated cabal library installed?
04:33:56 <quicksilver> cabal is a library which absolutely is instealled.
04:33:58 <quicksilver> ivanm: No.
04:34:02 <quicksilver> erm.
04:34:06 <quicksilver> perhaps :)
04:34:29 <quicksilver> not the right version, possibly, one way or the other.
04:35:16 <ivanm> quicksilver: e.g. here in gentoo we have a seperate cabal ebuild... it might be a dummy depending on which ghc is installed, but packages that use cabal depend on it
04:35:28 <Koper`> ivanm: yeah i am using gentoo
04:35:31 * quicksilver nods
04:35:35 <Saizan_> Distribution.Simple has been there for quite some time
04:36:04 <ivanm> Koper`: well, Cabal will still be installed
04:36:13 <ivanm> for other packages though, they'll dep on dev-haskell/cabal
04:36:13 <Koper`> Well, anyway how can i fix that error if it's not a missing package? The code is: import Distribution.Simple [[new line]] main = defaultMainWithHooks autoconfUserHooks
04:36:17 <Koper`> Yeah I realized that now ivanm
04:36:27 <ivanm> Koper`: that should work now then
04:36:48 <ivanm> Koper`: the possibility is that in new cabal library versions, the location has changed
04:36:58 <Koper`> http://codepad.org/7ClSRuLv
04:37:02 <ivanm> as dcoutts has been moving stuff around and splitting up modules
04:37:33 <Koper`> hmmm
04:38:03 <Saizan_> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple.html#v%3AautoconfUserHooks <- it's there
04:38:17 <dcoutts> Koper`: you're using Cabal-1.2 I expect
04:38:22 <ivanm> OK, it hasn't moved
04:38:26 <dcoutts> rather than 1.4+
04:38:28 <ivanm> dcoutts: 6.8 had 1.4, didn't it?
04:38:34 <dcoutts> ivanm: no
04:38:50 <Koper`> dcoutts: Cabal-1.2.3.0
04:38:51 <Neut> map death [assignment..]
04:38:57 <ivanm> dcoutts: oh... thought it did...
04:39:25 <taggadtyp> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmm
04:39:29 <dcoutts> nope, Koper` is right, he's using ghc-6.8.2 which came with Cabal-1.2.3.0
04:39:29 <taggadtyp> max rabkin here?
04:39:34 <taggadtyp> I get error, couldnt load dll
04:39:45 <taggadtyp> why? it doesnt say anything about an external download...
04:39:50 <Koper`> hm.. Sorry but i am not following
04:40:02 <Koper`> So has the location changed or not?
04:40:06 <Saizan_> Koper`: you need a newer Cabal version
04:40:10 <ivanm> dcoutts: so did 1.2 have autoconfUserHooks?
04:40:15 <dcoutts> Koper`: no, but it did not previously exist
04:40:30 <Koper`> hmm.. ok
04:40:53 <Saizan_> ?hackage Cabal
04:40:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
04:40:57 <Koper`> I'll try getting gentoo's "beta" GHC and see what cabal version it has
04:41:06 <ivanm> Koper`: it isn't beta
04:41:20 <dcoutts> Koper`: previously there was just defaultUserHooks and simpleUserHooks
04:41:23 <Koper`> That's why i put the quotes :P
04:41:24 <Saizan_> you can get the tarball from there and install it, too ^^^
04:41:27 <ivanm> it's marked unstable because it hasn't had the mandatory 30-days without bugs
04:41:33 <Koper`> Beta according to gentoo, ie anything that has not been stable for the last 5 centuries
04:41:38 <ivanm> Koper`: or else just install a newer cabal
04:41:43 <dcoutts> Koper`: the defaultUserHooks had some autoconf features, ie what got renamed to autoconfUserHooks.
04:41:45 <ivanm> Koper`: no, 30 days is for stable
04:41:52 <Koper`> (I was being sarcastic :P)
04:41:54 <dcoutts> strangely, defaultUserHooks was never the default
04:42:00 <dcoutts> hence why I deprecated it
04:42:17 <ivanm> a non-default default? :o
04:42:27 <dcoutts> and split it into simpleUserHooks and autoconfUserHooks
04:42:49 <QtPlaty[HireMe]> You can run unlib on anything?
04:42:56 <ivanm> dcoutts: by "deprecated", I take it you just put that in a comment, then deleted it a couple of versions later?
04:43:17 <dcoutts> ivanm: no, using the DEPRECATED pragma, so everyone gets warnings
04:43:51 * ivanm didn't know Haskell had such a pragma...
04:44:04 <Koper`> Well it looks like gentoo's latest GHC is what I have.. Probably it would be easier to just change it to one of the old ones, such as defaultUserHooks, instead of downloading the newst version without a gentoo package?
04:44:36 <ivanm> Koper`: the latest is 6.10.3
04:44:49 <Saizan_> Cabal can be upgraded without upgrading ghc
04:45:00 <Saizan_> and it installs like any other Cabal package
04:45:15 <Koper`> oh, great
04:45:18 <Koper`> I am installing dev-haskell/cabal-1.6.0.3
04:45:21 <ivanm> Koper`: "emerge dev-haskell/cabal"
04:45:21 <Koper`> That should fix it, right?
04:45:23 <quicksilver> new cabals work fine with (older) ghcs
04:45:26 <ivanm> we've already said that ;-)
04:45:39 <Koper`> kk, hopefully i won't have any more problems
04:45:42 <Koper`> Thanks for your help :)
04:51:40 <taggadtyp> > (Just (+6)) <*> (Just 5)
04:51:41 <lambdabot>   Just 11
04:51:51 <taggadtyp> > (Just (+6)) <$> (Just 5)
04:51:52 <lambdabot>   Couldn't match expected type `a -> b'
04:51:55 <taggadtyp> > (+6) <$> (Just 5)
04:51:56 <lambdabot>   Just 11
04:52:13 <taggadtyp> does things in boxes have a corresponding mathematical meaning?
04:52:21 <taggadtyp> does "things in boxes" have a corresponding mathematical meaning?
04:52:24 <taggadtyp> > pure 1
04:52:25 <lambdabot>       Ambiguous occurrence `pure'
04:52:25 <lambdabot>      It could refer to either `Control.Appl...
04:52:27 <Twey> ‘Things in boxes’?
04:52:28 <Twey> Heh
04:52:30 <Twey> Functors?
04:52:34 <taggadtyp> dont know?
04:52:39 <taggadtyp> i mean i dont know
04:52:57 <taggadtyp> > Control.Applicative.pure 1
04:52:58 <lambdabot>       No instance for (Show (f t))
04:52:58 <lambdabot>        arising from a use of `show' at <in...
04:53:15 <taggadtyp> > Control.Monad.pure 1
04:53:16 <lambdabot>   Not in scope: `Control.Monad.pure'
04:53:37 <PetRat> What's a better way to check that everything in list xs is also in list ys? I've got and $ map (`elem` ys) xs
04:53:54 <Twey> PetRat: all (elem xs) ys
04:54:02 <Twey> Er
04:54:06 <Twey> all (`elem` xs) ys
04:54:11 <PetRat> Ah...
04:54:24 <Twey> Or, possibly more efficiently, sort xs == sort ys
04:54:33 <PetRat> Except as stated, it would be all (`elem` ys) xs
04:54:43 <Twey> Yes, sorry
04:54:54 <PetRat> But thanks for the idea.
04:55:07 <EvilTerran> Set.fromList xs `Set.isSubsetOf` Set.fromList ys
04:55:10 <Twey> And in that case, sort xs `isPrefixOf` sort ys
04:55:22 <PetRat> It's actually checking that xs is a subset of ys
04:55:32 <Twey> Or, er, vice versa
04:55:41 <Twey> Oh, I guess that doesn't work with duplicates
04:55:42 <Twey> Never mind me
04:55:44 * Twey aches
04:55:59 <PetRat> EvilTerran: yes I was wondering about using Sets.
04:56:08 <EvilTerran> Twey, or (xs = [2,3], ys = [1,2,3]), say
04:56:17 <Twey> Yeah
04:56:20 <Twey> Stupid idea, really
04:56:31 <Twey> The Set would be it
04:56:33 <EvilTerran> you'd need to make an ordered merge on the lists
04:56:46 <Twey> Or nub them as well as sort
04:56:47 <EvilTerran> in order to check subsets that way
04:56:53 <Twey> i.e. make it into a very inefficient set
04:57:24 <EvilTerran> Twey, even after nub'ing, you'd need to do an ordered merge to avoid O(n^2)
04:58:34 <EvilTerran> ... wait, nub's O(n^2). i mean (map head . group . sort), that's O(n log n)
04:59:14 <EvilTerran> PetRat, going via Sets (if not using them throughout in place of lists) would probably be the simplest
04:59:29 <ivanm> EvilTerran: is that lazy though?
04:59:36 <taggadtyp> is nub O(n^2)?
04:59:38 <EvilTerran> ivanm, which?
04:59:40 <taggadtyp> @src nub
04:59:40 <lambdabot> nub = nubBy (==)
04:59:45 <taggadtyp> @src nubBy
04:59:45 <lambdabot> nubBy eq []             =  []
04:59:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:59:49 <ivanm> EvilTerran: using sets
05:00:08 <EvilTerran> ivanm, it'd be no worse than sorting the lists before you begin
05:00:12 <EvilTerran> cf strictness
05:00:12 <Twey> Are sets lazy?  Can sets be lazy?
05:00:16 <Twey> I think so
05:00:23 <ivanm> > take 3 . Set.toList . Set.fromList $ [1..3] ++ [undefined]
05:00:24 <Twey> But they may be stricter than one might expect
05:00:25 <lambdabot>   * Exception: Prelude.undefined
05:00:37 <EvilTerran> the internal structure of a set depends on the values of its elements
05:00:41 <ivanm> > take 3 . nub $ [1..3] ++ [undefined]
05:00:42 <lambdabot>   [1,2,3]
05:00:45 <EvilTerran> similarly for a Map and its keys
05:02:44 <taggadtyp> allIn :: Ord a => [a] -> [a] -> Bool
05:02:44 <taggadtyp> allIn xs ys = S.isSubsetOf (S.fromList xs) (S.fromList ys)
05:02:49 <taggadtyp> seems to work correctly
05:02:59 <taggadtyp> even for duplicates
05:03:08 <Koper`> ok i am having another error while trying to compile the syb module.. It says: Could not find module `Data.Data'
05:03:17 <Koper`> I looked here, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/, but i couldn't find any module named just 'Data'
05:03:25 <Koper`> How can i find the exact name of the module i am missing?
05:06:22 <ivanm> Koper`: Data.Data comes with ghc
05:06:28 <ivanm> IIRC
05:06:33 <ivanm> might only be newer ones though...
05:06:38 <ivanm> @hoogle Data.Data
05:06:38 <lambdabot> Data.Generics.Basics class Typeable a => Data a
05:06:38 <lambdabot> keyword data
05:06:38 <lambdabot> package data-accessor
05:06:39 <Koper`> grrrr :(
05:06:49 <ivanm> Koper`: did you USE=doc for ghc?
05:06:56 <doserj> Data.Data is ghc-6.10.x
05:07:02 <Koper`> ivanm: no, should I?
05:07:06 <ivanm> doserj: yeah, thought so
05:07:14 <ivanm> Koper`: *shrug* your choice if you want documentation
05:07:24 <ivanm> but as doserj said, Data.Data is for 6.10.* only
05:07:40 <Koper`> hm, i'll try with syb-1.0.0.0 instead of *.1, maybe it doesn't need Data.Data
05:08:40 <doserj> won't work.
05:09:06 <Koper`> Then i guess i'll have to download the newest GHC and compile it :(
05:09:07 * Koper` cries
05:09:15 <ivanm> Koper`: USE=binary
05:09:24 <ivanm> it installs the pre-built gentoo binary for ghc
05:09:34 <Koper`> Yeah, the problem is that i am using the latest gentoo's GHC
05:09:49 <Koper`> Which is 6.8.2
05:10:38 <Koper`> oh nevermind i am dumb, there are more
05:11:00 <ivanm> Koper`: we also have an overlay available via layman if you want more fun haskell packages ;-)
05:11:07 <ivanm> and an IRC channel :p
05:11:21 <Koper`> Yeah I know I'm in it :P
05:12:08 <dmwit> He means #haskell-gentoo or #gentoo-haskell or whatever, I'm sure.
05:12:23 <Koper`> oh
05:14:08 <taggadtyp> how do I define the type quickCheck should generate for the test?
05:16:27 <Koper`> lol now that i upgraded i have to reinstall all the packages i have installed so far :((
05:16:28 <Koper`> Oh well
05:17:42 <doserj> Koper`: for what it is worth syb was part of base in ghc-6.8.2, so if you don't really need the newest version of the syb package, ghc.6.8.2 is ok
05:17:58 <Koper`> (oh i was wrong, i simply had to run 'ghc-updater')
05:18:14 <PetRat> If I have a list [Maybe String], what's a way to check if any element is Nothing? any (==Nothing) xs?
05:18:31 <Koper`> doserj: i had 6.8.2 before the update and yet i got: Setup.hs: At least the following dependencies are missing: syb -any && -any && -any
05:18:35 <ivanm> Koper`: ghc-updater
05:18:38 <Koper`> Anyway it doesn't matter, i updated
05:20:05 <thoughtpolice> taggadtyp: you can just give explicit types to your incoming parameters if necessary
05:20:15 <thoughtpolice> taggadtyp: for the most part type inference should take over
05:23:46 <EvilTerran> PetRat, it'd be better to use Data.Maybe.isNothing than (==Nothing)
05:23:49 <EvilTerran> ?type any isNothing
05:23:51 <lambdabot> forall a. [Maybe a] -> Bool
05:23:53 <EvilTerran> ?type any (==Nothing)
05:23:54 <lambdabot> forall a. (Eq a) => [Maybe a] -> Bool
05:24:11 <EvilTerran> ?src isNothing
05:24:11 <lambdabot> isNothing Nothing = True
05:24:11 <lambdabot> isNothing _       = False
05:29:24 <PetRat> How do you zip together lists of string (representing lines) with some spaces between left and right part of each line? Something like zipWith (\a,b -> a ++" "++b) xs ys
05:29:50 <Peaker> PetRat: what's wrong with your code?
05:30:14 <PetRat> I get suspicious when I use lambdas. So often there is an existing way to do the saem thing.
05:30:18 <PetRat> But maybe it's fine.
05:30:24 <Peaker> > zipWith (\a b -> a ++" "++b) ["hello", "world"] ["blah", "bleh"]
05:30:25 <lambdabot>   ["hello blah","world bleh"]
05:30:31 <Peaker> @pl (\a b -> a ++" "++b)
05:30:31 <lambdabot> (. (' ' :)) . (++)
05:30:57 <burp_> omg
05:31:14 <Peaker> @type intercalate
05:31:15 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:31:24 <Peaker> > intercalate " " [["hello", "world"]]
05:31:25 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
05:31:33 <Peaker> > intercalate " " ["hello", "world"]
05:31:34 <lambdabot>   "hello world"
05:32:07 <PetRat> so, zipWith (intercalate " ") xs ys
05:32:16 <Peaker> not exactly, as intercalate takes a list, not 2 args
05:32:21 <Peaker> > transpose [["hello", "world"], ["blah", "bleh"]]
05:32:23 <lambdabot>   [["hello","blah"],["world","bleh"]]
05:32:34 <doserj> > map (intercalate " ") $ transpose [ ["hello", "world"], ["blah", "bleh"]]
05:32:36 <lambdabot>   ["hello blah","world bleh"]
05:32:36 <Peaker> > map (intercalate " ") . transpose $ [["hello", "world"], ["blah", "bleh"]]
05:32:37 <lambdabot>   ["hello blah","world bleh"]
05:32:39 <Peaker> heh
05:32:43 <doserj> :P
05:33:03 <doserj> but nor really simpler than the zipWith
05:33:06 <Peaker> PetRat: map (intercalate " ") . transpose -- will work on any-length lists :)
05:33:11 <Peaker> doserj: more general though
05:33:25 <PetRat> Hmm.. I just realized that transpose and zip are related conceptually.
05:33:38 <burp_> ?src transpose
05:33:38 <lambdabot> transpose []             = []
05:33:38 <lambdabot> transpose ([]   : xss)   = transpose xss
05:33:38 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:34:03 <Peaker> transpose is more general
05:34:19 <Peaker> @check (\x -> transpose . transpose $ x == x)
05:34:20 <lambdabot>   Couldn't match expected type `[[a]]' against inferred type `Bool'
05:34:34 <Peaker> @check (\x -> (transpose . transpose $ x == x))
05:34:35 <lambdabot>   Couldn't match expected type `[[a]]' against inferred type `Bool'
05:34:41 <PetRat> It's nice to have another intuitive way to picture transpose.
05:34:43 <Peaker> @check (\x -> (transpose . transpose) x == x)
05:34:44 <lambdabot>   "Falsifiable, after 1 tests:\n[[]]\n"
05:34:49 <mmorrow> http://moonpatio.com/vacuum/gallery/transpose.html
05:35:17 <mmorrow> i was amazed when i first saw that
05:35:34 <byorgey> > transpose [[]]
05:35:35 <lambdabot>   []
05:35:48 <byorgey> !?
05:35:49 <doserj> @check \xs ys -> length xs /= length ys || map (\(x,y) -> [x,y]) (zip xs ys) == transpose [xs,ys]
05:35:50 <lambdabot>   "OK, passed 500 tests."
05:36:11 <mmorrow> , transpose [[42],[],[0..4]]
05:36:15 <lunabot>  [[42,0],[1],[2],[3],[4]]
05:36:24 <Peaker> @check \xs ys -> length xs /= length ys || map (\(x,y) -> [x,y]) (zip xs ys) == transpose [xs::Int,ys]
05:36:24 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
05:36:29 <Peaker> @check \xs ys -> length xs /= length ys || map (\(x,y) -> [x,y]) (zip xs ys) == transpose [xs::[Int],ys]
05:36:30 <lambdabot>   "OK, passed 500 tests."
05:36:42 <byorgey> mmorrow: yeah, it makes sense to me that transpose does weird things when you give it ragged arrays
05:36:50 <byorgey> but how does transpose [[]] == []  make sense ?
05:37:12 <Koper`> I finally managed to compile and install my software, yay :P But I ran into another problem.. hopefully my last T_T: src/EvalCxx.hsc:236:34-58: Irrefutable pattern failed for pattern (k, _ : v)
05:37:17 <Koper`> What could it be caused by?
05:37:18 <mmorrow> , transpose [[],[],[[[]]]]
05:37:19 <lunabot>  [[[[]]]]
05:37:30 <mmorrow> , transpose [[],[],[[]]]
05:37:31 <lunabot>  [[[]]]
05:37:43 <mmorrow> , transpose [[],[[[]]],[[]]]
05:37:44 <lunabot>  [[[[]],[]]]
05:37:51 <byorgey> Koper`: what is this you're trying to install?
05:38:05 <Koper`> byorgey: geordi, http://www.xs4all.nl/~weegen/eelis/geordi/
05:38:25 <byorgey> I see
05:38:37 <Koper`> I tried googling for the error but i didn't find anything useful :(
05:38:40 <byorgey> well, that error looks like it was caused by... an irrefutable pattern match failure.
05:38:50 <quicksilver> that's a runtime error, not a compile time one
05:38:51 <byorgey> the problem is that it's an excellent error message.
05:39:03 <quicksilver> it means you did somethign the author didn't expect
05:39:07 <Koper`> quicksilver: yeah, i compiled it just fine
05:39:20 <byorgey> that is, there isn't something simple that causes that inscrutable message, it means what it says.
05:39:39 <byorgey> to know why you'd have to look at the source code and see what is going on.
05:39:45 <Koper`> Well i just ran it following the instructions to the letter.. But i can try with another version, if it's not my fault (ie, it can't be caused by me fucking up the installation of modules/other)
05:40:14 <mmorrow> byorgey: i'm not sure how the say why transpose [[]] == [] makes sense in a sentence, but i vaguely feel like there's a good way to say that it does (?)
05:40:17 <Koper`> hmm I see byorgey
05:40:26 <byorgey> Koper`: yeah, I don't think you could cause that by messing up the installation
05:40:35 <mmorrow> oh nice, i didn't know geordi was written in haskell
05:41:38 * byorgey makes a mental note that mmorrow vaguely feels like  transpose [[]] == []  makes sense ;)
05:41:46 <mmorrow> heh
05:41:58 <kyevan> My hands hurt...
05:41:59 <quicksilver> if you tranpose n lists of length m, you get m lists of length n
05:42:07 <quicksilver> if you transpose 1 list of length 0
05:42:10 <quicksilver> you get 0 lists of length 1!
05:42:16 <mmorrow> haha
05:42:18 <byorgey> aha!
05:42:19 <mmorrow> there it is
05:42:24 <byorgey> quicksilver++
05:42:27 <quicksilver> it wasn't supposed to be a joke :P
05:42:46 <mmorrow> most jokes are funny because they're true ;)
05:51:43 <dolio> What about that one about the Bavarian cream pie?
05:52:28 <ziman> > transpose []
05:52:29 <lambdabot>   []
05:52:52 <ziman> hm, this [] was 0 lists of length 5 :\
05:53:04 <ziman> > transpose [[],[],[],[],[]]
05:53:05 <lambdabot>   []
05:53:27 <ziman> so transpose . transpose /= id
05:53:48 <wjt> but it's idempotent!
05:53:51 <dolio> That's not the only example.
05:54:00 <EvilTerran> > transpose . transpose $ [[1],[2,3]]
05:54:01 <lambdabot>   [[1,3],[2]]
05:54:07 <wjt> hmm. is there a word for f such that f . f . f == id . f ?
05:54:11 <dolio> Although it's the only example with 'square' matricies that I've seen.
05:54:27 <wjt> that is, f is only self-inverse after you apply it once
05:54:59 <EvilTerran> wjt, reminds me of the semantics of "not" in constructive logic
05:57:48 <mmorrow> wjt: indempotent
05:58:16 <mmorrow> err, hmm
05:58:53 <wjt> mmorrow: i don't require f . f = id . f
05:59:05 <mmorrow> maybe i'd say that it's self inverse only on "properly formed" input
05:59:59 <mmorrow> so in this case, [[],[]] is === [] wrt the domain of transpose
06:00:43 <mmorrow> err, that's not quite what i want to say, but close enough
06:01:23 <taggadtyp> so how do Imake quickCheck generate a list?
06:02:31 <byorgey> wjt: tridempotent
06:02:36 <wjt> :)
06:02:39 <byorgey> =)
06:02:44 <mmorrow> ok, better ==> transpose operates on equivalence classes of lists
06:03:14 <mmorrow> xs === ys = filter (not . null) xs == filter (not . null) ys
06:03:36 <mmorrow> then, [[]] == [] in the first place
06:03:45 <mmorrow> before you even apply transpose
06:03:57 <mmorrow> err, i meant [[]] === [] in the first place
06:04:52 <mmorrow> so (transpose . transpose) == id on these equivalence classes
06:05:14 <taggadtyp> > i 5
06:05:15 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `Expr'
06:05:15 <taggadtyp> > id 5
06:05:16 <lambdabot>   5
06:05:33 <taggadtyp> i dont see when you actually need id?
06:05:36 <Peaker> can a total language compare functions?
06:05:47 <taggadtyp> if you need to return jsut the input...then do that
06:05:51 <mmorrow> , foldl (+) 0 [1..4]
06:05:52 <lunabot>  10
06:06:00 <Jedai> taggadtyp: id is useful in higher-order function sometimes
06:06:02 <mmorrow> , foldr (:) [] [1..4]
06:06:03 <lunabot>  [1,2,3,4]
06:06:25 <mmorrow> , foldr (.) id (replicate 4 (*)) 4
06:06:26 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = a -> a
06:06:32 <mmorrow> , foldr (.) id (replicate 4 (*2)) 4
06:06:33 <lunabot>  64
06:06:39 <taggadtyp> > foldl (\acc next -> if next > 5 then 1 else id) 0 [1,2,3]
06:06:40 <lambdabot>       No instance for (Num (a -> a))
06:06:41 <lambdabot>        arising from the literal `1' at <...
06:06:55 <taggadtyp> > foldl (\acc next -> if next > 5 then acc+1 else acc+id) 0 [1,2,3]
06:06:56 <lambdabot>       No instance for (Num (a -> a))
06:06:56 <lambdabot>        arising from the literal `1' at <...
06:06:59 <mmorrow> ((.),id),((+),0),((*),1),((++),[]),...
06:07:01 <taggadtyp> > foldl (\acc next -> if next > 5 then acc+1 else acc + id x) 0 [1,2,3]
06:07:03 <lambdabot>   0 + x + x + x
06:07:08 <taggadtyp> > foldl (\acc next -> if next > 5 then acc+1 else acc + x) 0 [1,2,3]
06:07:09 <lambdabot>   0 + x + x + x
06:07:15 <taggadtyp> > foldl (\acc next -> if next > 5 then acc+1 else acc + next) 0 [1,2,3]
06:07:16 <lambdabot>   6
06:07:19 <taggadtyp> > foldl (\acc next -> if next > 5 then acc+1 else acc + id next) 0 [1,2,3]
06:07:21 <lambdabot>   6
06:07:21 <mmorrow> you need id for the same reason you need 0,1,[]
06:07:21 <EvilTerran> mmorrow, Endo!
06:07:26 <mmorrow> :)
06:07:31 <Jedai> taggadtyp: to generate list with quickcheck there is nothing to do, as long as there is an instance of arbitrary for the content you're good
06:08:37 <taggadtyp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4837#a4837
06:09:05 <taggadtyp> ^^ maybe there isnt then
06:09:14 <mmorrow> taggadtyp: you need to tell it *what* type you want to generate
06:09:24 <mmorrow> , return 42 :: [Int]
06:09:26 <lunabot>  [42]
06:09:28 <mmorrow> , return 42 :: Maybe Double
06:09:29 <lunabot>  Just 42.0
06:09:33 <mmorrow> , return 42 :: IO Integer
06:09:34 <lunabot>  luna: No instance for (GHC.Show.Show
06:09:48 <taggadtyp> how?
06:09:51 <taggadtyp> quickCheck (\s -> allIn s (head s : s))
06:09:55 <mmorrow> by giving a type sig
06:10:01 <Peaker> @type lift
06:10:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
06:10:05 <taggadtyp> quickCheck (\s :: [Int] -> allIn s (head s : s))
06:10:08 <taggadtyp> want allowed
06:10:22 <taggadtyp> Result signatures are no longer supported in pattern matches
06:10:25 <Peaker> Almost always, lift is implemented as (wrapInSomeNewtype . fmap return), isn't it?
06:10:26 <mmorrow> put it on the second occurrence of 's'
06:10:27 <quicksilver> (\s -> allIn (s :: [Int]) (head s : s))
06:10:51 <taggadtyp> ah
06:10:52 <Peaker> @hoogle maybet
06:10:52 <lambdabot> package MaybeT
06:10:52 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:12:18 <EvilTerran> taggadtyp, btw, isSubsetOf is, i think, meant to be written infix
06:12:39 <EvilTerran> "allIn xs ys = S.fromList xs `S.isSubsetOf` S.fromList ys"
06:12:52 <mmorrow> this is where unicode is nice
06:12:53 <taggadtyp> matters?
06:13:07 <EvilTerran> taggadtyp, it's of no functional importance, just a matter of style
06:13:18 <EvilTerran> makes it read as "xs is subset of ys"
06:13:19 <taggadtyp> i rarely use infix
06:13:36 <taggadtyp> but yes here it is bette
06:13:37 <taggadtyp> r
06:13:44 <taggadtyp> dont like infixing fmap though
06:14:02 <EvilTerran> you could even write "xs `allIn` ys = ...", if you wanted to go crazy with the infix :P
06:14:26 <mmorrow> , "⊆⊂"
06:14:27 <lunabot>  "\8838\8834"
06:14:35 <taggadtyp> C
06:14:57 <mmorrow> , "∈∊"
06:14:59 <lunabot>  "\8712\8714"
06:15:51 <mmorrow> , let (∈) = elem in 4 ∈ [0..9]
06:15:52 <lunabot>  True
06:16:14 <ski> wjt : there is a word for `f' and `g' such that `f . g . f = g' as well as `g . f . g = f' : `f' and `g' are pseudo-inverses
06:16:16 <ivanm> in his "Church Numerals, Twice!" paper, hinze uses something that looks like a truncated ceiling brackets to denote integers... any one know for sure what they are so I can typeset them myself?
06:16:35 <wjt> ski: so where f = g, f is pseudo-self-inverse
06:16:36 <ski> wjt : so i guess your `f' would be self-pseudo-inverse (pseudo-self-inverse ?)
06:16:56 <ski> *nod*
06:17:59 <quicksilver> ski: isn't that an adjoint?
06:18:27 <quicksilver> FGF ~ G and GFG ~ F means F is left adjoint to G
06:19:34 <ski> (`transpose []' otoh is supposed to give a list of `n' zero-length lists, for the "appropriate `n'" :)
06:19:40 <mmorrow> ski: in group theory, you'd call that an inner automorphism (in this case, the group is the automorphism group itself)
06:19:52 <ski> quicksilver : no, that is equivalence (of categories)
06:21:11 <quicksilver> oh
06:21:23 <ski> quicksilver : no, actually, equivalence is `f . g ~ 1' and `1 ~ g . f'
06:21:46 <ski> (though maybe one can make an alternative formulation .. hm)
06:21:53 <mmorrow> err, well inner auto is  foo g = f . g . f^(-1)
06:22:17 <mmorrow> * foo_f(g) = f . g . f^(-1)
06:22:24 <ski> in an adjunction, we have `epsilon : f . g >-> 1' and `eta : 1 >-> g . f', together with a few laws relating those
06:23:25 <quicksilver> one way of stating the unit/counit laws is in terms of the compositions G -> GFG -> G
06:23:31 <quicksilver> I think that's what was confusing me.
06:23:40 <taggadtyp> Loading package logfloat-0.12.0.1 ... can't load .so/.DLL for: m (addDLL: could not load DLL)
06:23:41 <quicksilver> or, that's what my addled memory was remembering
06:23:47 <taggadtyp> when I try to run HMM
06:23:56 <taggadtyp> is logfloat an external package?
06:24:10 <EvilTerran> ivanm, hm, i've seen that in some of my lecture slides
06:24:45 <ivanm> atm, I'm using bold numerals ala wikipedia... it just looks weird, that's all :s
06:25:13 <mmorrow> quicksilver: that is very relevant to this though, since it's just considering the automorphism group of the group of endomorphisms (which are functors in this case) of the category G
06:25:29 * quicksilver nods
06:25:39 <EvilTerran> ivanm, well, unicode has ⌜⌝
06:26:02 <ivanm> *nod*
06:26:11 <EvilTerran> (U+231C Top Left Corner; U+231D Top Right Corner)
06:26:17 <mmorrow> err, i added one too many levels of "automorphism"
06:26:22 <mmorrow> End(G)
06:26:26 <mmorrow> == Fct(G,G)
06:26:35 <mmorrow> hmm, no i didn't
06:26:43 <mmorrow> gah! now i'm confusedd
06:26:46 <ski> quicksilver : so, WP reminds me that if we assume data `eta',`epsilon', then the laws those should satisfy has the form that `f >-> f . g . f >-> f' and `g >-> g . f . g >-> g' (formed out of `eta',`epsilon') are both identity .. maybe that's what you were thinking of
06:27:48 <quicksilver> ski: yes, it was.
06:27:53 <taggadtyp> is logfloat an external package?
06:27:55 <quicksilver> ski: I just said that didn't I? :)
06:28:11 <quicksilver> ski: senile memory remembers incomplete patterns not facts.
06:28:13 <ski> yes, you did .. i hadn't read that by the time i wrote the above, though :)
06:28:49 <taggadtyp> should haskell ever produce DLLs form pure haskell-code?
06:29:03 <taggadtyp> or is that then probably a C-lib?
06:29:46 <EvilTerran> ivanm, from what i can tell looking at my lecturer's latex macro file, he's using \newcommand{\church}[1]{\raisebox{0.1ex}{\makebox[0.4em][l]{$\ulcorner$}}#1\raisebox{0.1ex}{\makebox[0.4em][r]{$\urcorner$}}}
06:30:00 <ivanm> *shudder*
06:30:18 <ivanm> EvilTerran: so he's typesetting this in text mode rather than math mode?
06:30:38 * ivanm is finding using math mode rather fiddly with spaces :s
06:30:42 <EvilTerran> i dunno, i don't speak tex. that was an educated guess based on the words i saw. :P
06:31:00 <ivanm> EvilTerran: heh
06:31:11 <ivanm> is the tex file online somewhere?
06:31:41 <EvilTerran> afraid it's password-protected for members of the uni comlab only; i've probably been a bit naughty by pasting any of it out <.<  >.>
06:31:50 <ivanm> >_>
06:31:57 <ivanm> EvilTerran: comlab == oxford comlab?
06:32:14 <EvilTerran> yeah
06:32:31 <ivanm> so this is ralph hinze's tex file then?
06:32:54 <EvilTerran> ... this one's Andrew Ker's, for his lambda calculus & types course this year
06:32:56 <quicksilver> taggadtyp: C lib.
06:33:10 <ivanm> ahhhh
06:33:30 * ivanm might stick with bold numbers
06:33:45 <EvilTerran> i could see if hinze has posted tex source on the site, but i suspect that they may be sharing a macro file anyway
06:33:54 <ivanm> *nod*
06:38:17 <roadwarrior> how can I add --includedir and --libdir options when trying to install package with runhaskell config ?
06:39:46 <vixey> @w80 usury
06:39:51 <lambdabot> *** "usury" wn "WordNet (r) 2.0"
06:39:51 <lambdabot> usury
06:39:51 <lambdabot>      n 1: an exorbitant or unlawful rate of interest [syn: {vigorish}]
06:39:51 <lambdabot>      2: the act of lending money at an exorbitant rate of interest
06:40:02 <vixey> @w80 exorbitant
06:40:03 <lambdabot> *** "exorbitant" wn "WordNet (r) 2.0"
06:40:03 <lambdabot> exorbitant
06:40:03 <lambdabot>      adj : greatly exceeding bounds of reason or moderation;
06:40:03 <lambdabot>            "exorbitant rent"; "extortionate prices"; "spends an
06:40:03 <lambdabot>            outrageous amount on entertainment"; "usorious interest
06:40:05 <lambdabot>            rate"; "unconscionable spending" [syn: {extortionate},
06:40:07 <lambdabot>            {outrageous}, {steep}, {unconscionable}, {usurious}]
06:40:21 <Saizan> roadwarrior: --extra-include-dirs --extra-lib-dirs iirc, it's in the --help however
06:40:26 <NEEDMOAR> vixey: aren't you a native English speaker?
06:41:16 * EvilTerran (a native english speaker) wasn't confident about the meaning of "usury" 'til just now :P
06:41:25 <roadwarrior> Saizan: --help said --libdir and --includedir for me
06:41:31 <roadwarrior> running 6.8.1 tho
06:41:51 <Asztal> I'd have guessed something to do with bears (though I had heard this word)
06:42:28 <Asztal> like an aviary
06:43:27 <poucet> that'd be an ursury
06:43:31 <poucet> not usury
06:43:33 <Asztal> yeah :(
06:44:06 <quicksilver> I used to have an ursury, but the bears were scared off by the eels in my hovercraft.
06:44:25 <Twey> Um.
06:44:29 <poucet> an ursury, a nursury.... what a very small change in pause can make.
06:44:53 <vixey> lol
06:44:58 <Twey> I just had randomRIO (0, 100) :: IO Int yield 102
06:45:13 <poucet> Twey: hey, don't complain, it's random
06:45:15 <Twey> This... shouldn't happen, right?
06:45:17 <Twey> But but but
06:45:18 <Twey> x.x
06:46:11 <poucet> Twey: you sure ?
06:46:29 <Twey> Pretty sure:
06:46:41 <EvilTerran> Twey, was this in ghci?
06:47:09 <Twey> EvilTerran: No
06:47:29 <EvilTerran> uh, that makes it even weirder
06:47:47 * EvilTerran was going to suggest a breakage involving terminals and backspace keys, of a sort he's had a few times
06:48:02 <EvilTerran> (the screen disagrees with the program wrt what they think i typed in)
06:48:06 <Twey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2396#a2396 — I make that 102 circles, and the program agrees, and it's mostly been right so far
06:48:26 <Twey> Yeah, I have my own gripes with Haskeline, but that's not one of 'em
06:48:55 <quicksilver> Twey: I just ran randomRIO(0,100) :: IO Int 400000 times, and the highest I got was 100.
06:49:21 <Twey> Hum.
06:49:32 <EvilTerran> Twey, i make that 91 'o's in the "o o o ..." part
06:49:43 <Twey> Really?  Wow, I fail at counting
06:49:46 <quicksilver> are you sure you don't have a consant "o" at the beginning and "o" at the end?
06:49:47 <taggadtyp> quicksilver: and it needs to be ownloaded separately? maybe people should mention that in that case
06:49:53 <quicksilver> taggadtyp: no.
06:50:06 <quicksilver> taggadtyp: it should have installed along with whatever library uses it.
06:50:10 <quicksilver> taggadtyp: something is broken.
06:50:10 <Twey> I used concat (replicate n "o ")
06:50:18 <doserj> Twey: wc -w gives me 91, too
06:50:24 <Twey> > length "o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o" / 2
06:50:25 <lambdabot>       No instance for (Fractional Int)
06:50:25 <lambdabot>        arising from a use of `/' at <i...
06:50:30 <Twey> > length "o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o " `div` 2
06:50:32 <lambdabot>   91
06:50:35 <Twey> Huh.
06:50:39 <Twey> Okay
06:50:42 <Twey> Bug somewhere else
06:50:42 <EvilTerran> fnord!
06:50:45 <Twey> (as well as in my brain)
06:55:27 <taggadtyp> Loading package logfloat-0.12.0.1 ... can't load .so/.DLL for: m (addDLL: could not load DLL)
06:56:12 <quicksilver> yup.
06:56:17 <quicksilver> I've never used logfloat.
06:56:19 <quicksilver> what is it?
06:56:43 <roadwarrior> can I give LDFLAGS and CPPFLAGS to runhaskell or should I just export them?
06:58:02 <taggadtyp> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logfloat-0.12.0.1
06:58:15 <taggadtyp> hor the hidden markov model package
06:58:17 <taggadtyp> for
07:04:39 <mdmkolbe> Can anyone explain why one of these functions is so much slower than the other?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4841
07:10:22 <quicksilver> mdmkolbe: I think that's quite odd.
07:11:48 <quicksilver> mdmkolbe: incidentally you're not really using 'Data', just 'Typeable'
07:12:10 <quicksilver> mdmkolbe: I think you should post that to the -cafe
07:12:49 <EvilTerran> mdmkolbe, in fact, it looks like your "data Any" is much the same as Data.Dynamic
07:12:56 <mdmkolbe> quicksilver: you mean the mailing list?
07:13:01 <quicksilver> mdmkolbe: I do.
07:13:06 <quicksilver> EvilTerran: it is.
07:13:12 <quicksilver> EvilTerran: I don't understand the quadratic slowdown though.
07:13:26 * mdmkolbe checks to see if same bug appears with Data.Dynamic
07:13:52 <quicksilver> I agree it's quadratic. Eerily precise, actually.
07:14:03 <quicksilver> If I increase the parameter by *10, I get a runtime increase of precisely *100
07:14:42 <mdmkolbe> The cause seems to be the difference between * types (e.g. Int) and (* -> *) * types (e.g. [Int])
07:17:27 <taggadtyp> eval the function before yous tart timing?
07:17:27 <taggadtyp> i eman the preparation
07:17:27 <taggadtyp> w and v are not the same obv
07:17:40 <mmorrow> mdmkolbe: wow, that looks like a bug in generics
07:18:28 <mmorrow> ah, yeah right Typeable i guess
07:18:30 <mmorrow> or something
07:18:35 <mdmkolbe> mmorrow: yeah, and it's killing my code's performance
07:19:20 <mmorrow> i wonder if doing the same thing, but with Data.Dynamic, has the same behavior
07:19:35 <mdmkolbe> mmorrow: working on that question right now
07:22:16 <mmorrow> wow, it does
07:22:28 <mmorrow> and the dynamic version of gsum2 is twice as slow
07:22:34 <roderyk> In ghci I'm getting errors related to GHC.Prim.Any not having a type of Int... I vaguely understand this has something to do with phantom types (forall a type), but how can I cast it to test something in ghci?
07:23:50 <gwern> @remember PhilipWadler I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
07:23:51 <lambdabot> I will remember.
07:23:54 <gwern> @flush
07:23:57 <mdmkolbe> mmorrow: odd, only the first call to a Dynamic version of gsum2 is slow for me.  (I'm suspecting that means using Dynamic has shifted the cost from cast to toDyn)
07:24:02 <mmorrow> mdmkolbe: my guess is that cast/fromDynamic has to force the entirety of the structure, so gsum1 just forces an Int while gsum2 forces the whole list
07:24:28 <dolio> The lists are single-element, though.
07:24:38 <mmorrow> dolio: oh, hmm true
07:24:43 <mmorrow> weird
07:25:29 <mdmkolbe> For what it's worth, I *highly* suspect the cost is in the call to "typeOf" that is used by the cast.  Using an unsafeCoerce directly doesn't slow down like this.
07:26:03 <quicksilver> and in any case that should be a constant factor
07:26:15 <quicksilver> typeOf is free.
07:26:25 <quicksilver> it's just referencing a constant bundled in the dictionary
07:26:34 <quicksilver> erm by 'free' I mean constant time.
07:26:59 <mdmkolbe> quicksilver: even in the case where it calls appKeys?  http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Typeable.html
07:27:25 <quicksilver> well that's a cost
07:27:31 <mdmkolbe> (or rather when the call to appKeys is given a non-empty list)
07:27:36 <quicksilver> but it should be independent of the size of the lists involved, surely?
07:27:50 <quicksilver> the TyCon which represents [] is applied to a list which has one element
07:27:53 <quicksilver> the TyRep for Int
07:28:03 <quicksilver> the length of your list "w" should not be involved.
07:29:16 <mdmkolbe> quicksilver: you're right that it doesn't exactly make sense.  I'm grasping at straws and my best guess right now is that the cache is getting poluted some how that causes it to grow and make cache lookup more expensive
07:29:33 <edwardk> mdmkolbe: whats the problem in question?
07:29:44 <edwardk> slow casts?
07:29:57 <mmorrow> edwardk: a scary looking bug with Typeable
07:30:09 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4841
07:30:23 <Peaker> mdmkolbe: bad cache behavior should make the performance deteriorate pretty sharply by some constant after a certain size, but not change it from O(N) to O(N^2)
07:30:41 <edwardk> interesting
07:31:41 <quicksilver> you could guess that the extra level of stuff is defeating an inlining and making a constant dictionary lookup into a real runtime lookup
07:31:42 <rui_> hi, there is some web framework for haskell ?
07:31:48 <quicksilver> but I still don't see how that gets quadratic.
07:31:52 <quicksilver> rui_: only four or five
07:32:13 <rui_> quicksilver, any site where i can read about them ? i m pretty new to haskell and functional programming.
07:32:42 <pastorn> @faq Is it possible to travel to the moon?
07:32:42 <lambdabot> The answer is: Yes! Haskell can do that.
07:32:45 <mdmkolbe> If I write my own version of cast that uses unsafeCoerce, this performance bug gets triggered only if I do the "typeOf" check on either the input type or the result type (I can't remember which)
07:32:46 <dolio> Oh man. Typeable uses Data.HashTable.
07:32:55 <mmorrow> dolio: yay!
07:32:56 <quicksilver> happstack, turbinado, salvia, wash, shwf,
07:32:59 <mdmkolbe> dolio: is that bad?
07:33:03 <edwardk> dolio: yeah
07:33:05 <quicksilver> I've not used any of them.
07:33:11 <edwardk> mdmkolbe: data.hashtable is a pig
07:33:24 <pastorn> @faq Can i program with dependent types?
07:33:24 <dolio> I bet that's the problem.
07:33:24 <lambdabot> The answer is: Yes! Haskell can do that.
07:33:31 <mmorrow> liar!
07:33:53 <edwardk> mdmkolbe: it can cost you progressively more and more in garbage collection time as it gets bigger
07:34:05 <quicksilver> but why would it get big?
07:34:09 <edwardk> because any mutation of an array requires it to be rescanned completely
07:34:18 <edwardk> by the gc next time around
07:34:21 <quicksilver> there are only two TypeReps used in the program?
07:34:24 <quicksilver> Int and [Int]
07:34:31 <quicksilver> surely Typeable just needs a hashtable with two entries?
07:34:34 <quicksilver> tht's not very big.
07:34:50 <edwardk> well, i suppose the real question is whether or not the cache is working properly or if its baloooning
07:35:15 <mdmkolbe> edward: running with "+RTS -s" shows the gc isn't the main cost.  Also increasing the heap size (so only one gc happens) doesn't make the problem go away
07:35:37 <edwardk> mdmkolbe: well, thats a positive sign at least
07:36:06 <mmorrow> edwardk: i hacked together the start of a "haddock for C", and ran it on ghc's rts code http://www.moonpatio.com/flounder/ (this just reminded me about how you were asking about StableName internals and how i was just looking at http://www.moonpatio.com/flounder/ghc_rts-flounders/includes/Stable.h.html 30 minutes ago)
07:36:36 <mdmkolbe> edwardk: ?
07:36:59 <mdmkolbe> edwardk: increasing the heap size does not help
07:37:22 <edwardk> mdmkolbe: i'm mostly rooting about for common causes at this point =)
07:37:26 <mm_freak_> hey people…  i've found that the identity functor is in fact impossible to implement in haskell, or am i missing something?
07:37:52 <edwardk> mm_freak_: a 'true' identity functor is, but you can get one modulo newtype noise
07:38:00 <mmorrow> mm_freak_: type families cannot be made instances of classes unfortunately
07:38:24 <mm_freak_> wouldn't that be something to consider in the next haskell standard?
07:38:35 <taggadtyp> what does the identity functor do?
07:38:41 <edwardk> mm_freak_: if you ignore the existence of newtypes then the Control.Monad.Identity is a valid 'identity' functor.
07:38:43 <mmorrow> type family I a; type instance I a = a; instance Functor I where fmap f = f
07:38:45 <mm_freak_> taggadtyp: it maps a type to itself
07:38:53 <edwardk> taggadtyp: type Id a = a
07:39:06 <dolio> There are serious issues with having an identity alias.
07:39:06 <mmorrow> yeah true, or just s/type family/type/
07:39:18 <edwardk> mm_freak_: its not an option with the existence of type classes
07:39:28 <mm_freak_> i understand
07:39:54 <edwardk> mm_freak_: type classes 'dispatch' on the type in question, an identity functor needs basically a named module describing how it operates ala ML, not ala a haskell typeclass
07:40:09 <taggadtyp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4842#a4842
07:40:19 <taggadtyp> ^^ constraint solver but is it really backtracking?
07:40:32 <dolio> Or, not just an alias, but one that would be partially appliable.
07:40:33 <vixey> yes
07:40:48 <mmorrow> http://www.moonpatio.com/flounder/ghc_rts-flounders/includes/Regs.h.html
07:41:28 <mmorrow> work-stealing queues for the gc http://www.moonpatio.com/flounder/ghc_rts-flounders/parallel/WSDeque.h.html
07:42:01 <mm_freak_> also another question:  given a category, where for all distinct objects A and B there is at most one morphism A → B and no morphism B → A, then that category is a partial order, right?
07:42:22 <edwardk> mm_freak_: btw- that was one of the questions that dragged me into the #haskell channel in the first place. i wanted to know why Functor had such a restricted signature and spent days before i brought myself to realize how much more useful the Functor definition haskell has was than the one i had in mind
07:42:31 * pumpkin stretches and yawns
07:43:34 <thoughtpolice> mmorrow: there's some fun stuff in the RTS code, and some scary stuff :)
07:43:36 <mm_freak_> edwardk: i just sat in a pub having a coke, when that came to me…  it somehow appeared inconsistent, but i wasn't able to resolve it
07:43:41 <dolio> mm_freak_: I think the answer is yes, except the way you've specified it doesn't precisely make sense.
07:43:53 <edwardk> mm_freak_: yes, you have an antisymmetric thin category, drop antisymmetry and you get preorders
07:44:03 <dolio> Since you can swap A and B and conclude that no objects have any morphisms between them. :)
07:44:11 <edwardk> dolio: heh
07:44:16 <mm_freak_> dolio: indeed =)
07:44:24 <mdmkolbe> Have all the Haskell Wiki accounts gone away?  I'm having trouble finding my account.  (It's been a while.)
07:44:51 <edwardk> mm_freak: if given any two objects there is at most one arrow between them, you have a 'thin category' which models a preorder, add the antisymmetry condition and you get a partial order.
07:45:21 <mm_freak_> one last question…  i'm able to define categories, functors, monads etc., but somehow i haven't found any use for that
07:45:41 <edwardk> mm_freak: hah welcome to my life ;)
07:45:52 <mm_freak_> the only real use i found was with duals
07:46:11 <edwardk> mm_freak_: seriously, being able to spot them is useful because it gives you a larger set of laws you can apply when you recognize one
07:46:22 <mmorrow> thoughtpolice: i'm finding these "flounder" docs nice to get an overview of everything
07:46:23 <mm_freak_> such that i can establish some trivial statements like:  the "smallest" element in a preorder is the largest in the opposite preorder =)
07:46:26 <mdmkolbe> s/Wiki/Trac/
07:46:52 <EvilTerran> mm_freak_, i find being able to see the patterns everywhere to have a certain joy in its own right
07:47:00 <edwardk> mm_freak_: duality was what made me love projective geometry, and its one of the properties that keeps me playing with category theory
07:47:29 <mmorrow> thoughtpolice: next step: link struct/union/enum/typedef names to their definition size, and maybe add a javascript search like haddock has
07:47:29 <mm_freak_> true, but aren't there any general proofs?  such as in group theory, as soon as i recognize something to be a group, a lot of proofs apply automatically
07:47:53 * EvilTerran re-reads his last statement, and decides to put down the special kool-aid
07:47:58 <edwardk> mm_freak_: there are tons of general proofs, lots of them involve kan extensions =)
07:48:14 <zmyrgel> could somebody help me out. I can't install convertible library as it fails to build
07:48:14 <mmorrow> thoughtpolice: ah yeah, i saw your paste about DynamicLinker/C-codegen. cool
07:48:22 <zmyrgel> here's the output: http://rafb.net/p/13f1lI99.html
07:48:30 <mm_freak_> edwardk: where do i find those? =)
07:48:47 <edwardk> mm_freak: near the end of categories for the working mathematician, or in my blog
07:48:51 <edwardk> or in category-extras
07:49:09 <edwardk> or in monad-ran
07:49:17 <mm_freak_> category-extras might be an interesting place to look…  up to now i haven't found any use for it =)
07:50:02 <edwardk> Control.Functor.KanExtension covers left and right kan extensions, Control.Monad.Codensity, Control.Functor.Density, Control.Functor.Limit, and Control.Functor.Yoneda are all special cases
07:51:10 <mm_freak_> are there some tutorials i could read first?
07:51:36 <edwardk> mm_freak_: yeah i wrote a 3 part series on kan extensions on comonad.com
07:51:48 <EvilTerran> edwardk, this yoneda thing i've heard about is a case of something even more general? eek O.o
07:52:03 <mm_freak_> edwardk: thanks
07:52:13 <edwardk> EvilTerran: yeah the yoneda lemma can be seen as a right kan extension along the identity functor
07:53:07 <edwardk> http://comonad.com/reader/2008/kan-extensions/ http://comonad.com/reader/2008/kan-extensions-ii/ http://comonad.com/reader/2008/kan-extension-iii/
07:53:43 <mm_freak_> edwardk: great, thanks
07:54:31 * EvilTerran starts reading about this kinda stuff, and is immediately reminded that haskell's Functor class is endofunctors on hask, so he'll have to keep track of the more general, correct, use of the  term
07:54:53 <edwardk> basically a right kan extension of g along f where f and g are endofunctors on Hask is just: newtype Ran f g a = Ran (forall o. (a -> f o) -> g o)
07:55:51 <edwardk> the third article there defines it in terms of categorical ends and coends, and dan piponi did an alternative writeup on the derivation of coends in haskell, which does things the hard way, where i just cheat and use the definition and parametricity
07:56:40 * EvilTerran randomly ponders if more interesting things could be done with "newtype Endo f a = Endo (f a a)" than with the existing Endo definition
07:57:07 <Peaker> EvilTerran: I juts got a little CT lecture recently and realized that for the first time a few days ago
07:57:09 <edwardk> evilterran: Data.Monoid.Categorical.GEndo in monoids ;)
07:57:18 <EvilTerran> (at least "instance Arrow arr => Monoid (Endo arr a)"...)
07:57:41 <edwardk> evilterran: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Categorical.html
07:58:04 <edwardk> you don't eve nneed Arrow arr, just Category
07:58:05 <ivanm> anyone feel like checking the slides for my talk on lambda calculus and church encoding to make sure I know wtf I'm talking about? :p
07:58:14 <EvilTerran> edwardk++ for mastery of arcane lore
07:58:23 <edwardk> woot
07:58:25 <EvilTerran> :D
07:58:28 <edwardk> @karma edwardk
07:58:28 <lambdabot> You have a karma of 4
07:58:37 <EvilTerran> preflex: karma edwardk
07:58:37 <preflex>  edwardk: 3
07:58:42 <edwardk> @karma dons
07:58:42 <lambdabot> dons has a karma of 8
07:58:48 <edwardk> half-way there!
07:59:03 <byorgey_> ivanm: I'll take a look.  I don't know everything but at least I'll be able to catch egregiously silly things =)
07:59:05 <edwardk> @karma lambdabot
07:59:05 <lambdabot> lambdabot has a karma of -1
07:59:06 <mmorrow> @karma editline
07:59:06 <lambdabot> editline has a karma of -3
07:59:09 <ivanm> byorgey_: \o/
07:59:11 <mmorrow> editline--
07:59:16 <edwardk> whoa, karma was obviously reset lately
07:59:36 <byorgey> karma gets reset almost daily.
07:59:51 <byorgey> and no one uses it anymore since it gets reset so often.
07:59:56 <edwardk> i just remember when lambdabot and dons were in the hundreds =)
07:59:59 * EvilTerran could get lost in the docs for category-extras and suchlike for hours
08:00:08 <ivanm> I was going to go through the entirety of Ralph Hinze's paper on Church Encoding, then realised that I dind't understand the second half and the audience probably wouldn't either
08:00:09 * byorgey has in fact done so
08:00:15 <ivanm> byorgey: http://omploader.org/vMW80NQ
08:00:39 <EvilTerran> ... and that's not even counting the papers i'd end up reading as well in the hope of understanding any of it
08:00:39 <edwardk> i really need to go clean up a couple of the uglier definitions in category extras and provide a few more 'non-obfuscated' versions of things like Free/Cofree/etc
08:01:03 <byorgey> ivam++ for the first slide =)
08:01:10 <ivanm> byorgey: what, the picture?
08:01:13 <ivanm> or the title?
08:01:13 <byorgey> yeah =)
08:01:17 <byorgey> well, both
08:01:21 <ivanm> took me a few hours to do that :s
08:01:23 <ivanm> gimp--
08:01:37 <edwardk> every time I go to deobfuscate Free/Cofree though, someone comes along with a need to use bicata on it, or something, in which case i Need the existing elaborate PCofree definition
08:01:41 * ivanm is considering sending that pic to lambdacatz
08:02:03 * dolio doesn't believe that.
08:02:39 <edwardk> dolio: the need for the pcofree definition?
08:02:41 <edwardk> @hpaste
08:02:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:02:59 <dolio> edward: That people "come along" with a need for bicata. :)
08:03:16 <dolio> Unless "people" is you. :)
08:03:28 <mmorrow> hehe
08:03:28 <edwardk> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4843#a4843 was from an email i sent just last week to someone
08:03:30 <byorgey> ivanm: slide 13, missing a space before 'is'
08:03:40 <edwardk> in response to them asking if a certain combinator was already in category-extras
08:03:52 <ivanm> whoops, thanks!
08:04:05 <ivanm> byorgey: oh, and I was going to go through some demos of church numerals + peano arithmetic in haskell as well
08:04:13 * pumpkin needs to go to rehab from dependent type addiction, to start haskell again
08:04:13 <byorgey> yeah, cool
08:04:18 <edwardk> basically he had an annotated functor which was just a cofree comonad and wanted that combinator and was looking for it in category-extras
08:04:49 <thoughtpolice> mmorrow: yeah I was thinking of hooking up the dynamiclinker+c-codgen stuff into a DSL or something, so you can generate C code, load it back in and call it
08:04:54 <byorgey> ivanm: on slide 14 you say 'functions are ... recursive' but that isn't at all obvious from the definitions.  i.e. you have to show how to make the Y combinator.
08:05:01 <pumpkin> thoughtpolice: I was playing with agda :P
08:05:07 <edwardk> needless to say i was very pleasantly surprised when the abstruse PCofree definition I wrote proved to be useful ;)
08:05:10 <dolio> Ooo, pattern guards.
08:05:18 <thoughtpolice> mmorrow: something like that might also be cool to hook into the cmonad package :)
08:05:22 <thoughtpolice> pumpkin: ah
08:05:25 <byorgey> ivanm: it's not necessarily a problem, just thought I would point it out, since the other things seemed to be just clarifications/obvious from the definition.
08:05:38 <dolio> Yeah, that is a nice looking definition.
08:05:44 <ivanm> byorgey: I was going to go through it on the board, since it would have been a PITA to type it all up :s
08:05:46 <edwardk> dolio: heh, i also pasted a viewpatterned version that avoided naming the temporary 'p'
08:05:56 <dolio> Heh.
08:06:26 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4843#a4844
08:06:56 <edwardk> and which avoided the cost of the redundant fmap or painfully explicit separate case
08:07:35 <Alpounet> ivanm, nice slides :)
08:07:41 <ivanm> Alpounet: thanks!
08:07:51 <edwardk> basically he wanted a nice little combinator for 'folding with an error' where when the error occurs, it extracts the current annotation and passes that along as well
08:08:48 <yowgi> ivanm, I wrote a small blog post on SKI calculus with Haskell about a year ago, I hope that could be of some help to you: http://journal.batard.info/post/2008/02/17/ski-calculus-in-a-haskell-shell -- and... nice presentation!
08:09:30 <ivanm> yowgi: yeah, SKI calc would probably be a bit too technical, as this is more maths rather than CS people
08:09:32 <ivanm> but thanks!
08:11:37 <dolio> ivanm: Your factorial example looks a little weird to me.
08:11:52 <ivanm> yeah, byorgey is /msg'ing me about that as well
08:11:52 <Peaker> ivanm: what's that presentation for/about?
08:12:30 <ivanm> Peaker: the UQ Maths PhD Journal club, which is no longer just about maths, by/for PhD students or just journal articles ;-)
08:12:39 <Peaker> ivanm: I think it'd be better to show boolean encodings before natural numbers? Much simpler
08:13:04 <ivanm> Peaker: the main point of my talk was to be church numerals, using Ralph Hinze's paper
08:13:07 <yowgi> ivanm, on slide 43 I think fact is wrong
08:13:08 <ivanm> which is why I use them first
08:13:19 <ivanm> yowgi: everyone is saying that ;-)
08:13:20 <dolio> Matlab has anonymous functions? I totally missed that.
08:13:29 <taggadtyp> im writing a simple prolog environment
08:13:29 <pumpkin> :o
08:13:31 <taggadtyp> facts are easy
08:13:35 <dolio> That would have made things less of a pain back when I was using it.
08:13:37 <taggadtyp> query :: Fact -> Env -> Bool
08:13:43 <taggadtyp> data Fact = Fact String String String deriving(Eq,Show)
08:13:43 <pumpkin> dolio: where? I know you can have "higher-order" functions
08:13:44 <Peaker> I don't see why anonymous(undocumented) functions are such a big deal :)
08:13:58 <Peaker> If Haskell didn't have \ notation, I'm not sure it'd be that bad :)
08:14:01 <taggadtyp> but what should the type of Rule be?
08:14:02 <pumpkin> Peaker: because it's such a friggin pain to make functions in matlab
08:14:08 <ivanm> dolio: @(x)(x+1)
08:14:11 <pumpkin> Peaker: only one exported function per file
08:14:18 <pumpkin> ivanm: <#
08:14:20 <pumpkin> <3, even
08:14:22 <dolio> Huh. If only I'd known.
08:14:24 <ivanm> heh
08:14:27 <Peaker> pumpkin: Ah, I don't know matlab, I keep hearing bad things about it
08:14:28 <taggadtyp> Rule :: Fact a b c -> Fact a c b
08:14:32 <taggadtyp> incorrect but
08:14:39 <ivanm> dolio: yeah, I did a lot of cool things with them (passing functions around, partial application, etc.)
08:14:46 <yowgi> > (fix (\g n -> if n == 0 then 1 else n * g (n-1))) 5
08:14:47 <lambdabot>   120
08:14:56 <pumpkin> yeah, I knew about @ for passing functions around, but that syntax is cool
08:15:04 <taggadtyp> if I have a bunch if alternatives I want to try in order
08:15:09 <pumpkin> matlab++ (now it's just at -1500 for me)
08:15:30 <taggadtyp> lets say 3 boolean functions, how can I easily compose them like try 1 if true end else try 2nd if true...
08:15:31 <dolio> ivanm: I just remember defining files with stuff like "f1(x) = x^2 + x + 1 ..." in them in a numerical methods class.
08:15:39 <taggadtyp> how can I compose that in an elegant way+
08:15:45 <dolio> Which seemed like an incredible pain.
08:16:19 <Peaker> ghc-6.10.2 changed language extension semantics from 6.10.1?
08:16:32 <Ferdirand> @type any
08:16:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:16:43 <ivanm> dolio: yeah
08:16:54 <Peaker> taggadtyp: you can alias (.) and flip (.) to result and argument, and then use them as semantic-editor-combinators
08:16:55 <taggadtyp> or
08:17:02 <Peaker> @go semantic editor combinators
08:17:05 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
08:17:06 <lambdabot> Title: Conal Elliott » Semantic editor combinators
08:17:34 <quicksilver> Peaker: I don't think so. What do you mean?
08:18:02 <Peaker> quicksilver: fieldtrip compilation used to succeed on 6.10.1 but fails with compilation errors (which I think were about type families) in 6.10.2
08:18:21 <edwardk> mdmkolbe: still around?
08:18:40 <doserj> "The TypeFamilies extension now implies the RelaxedPolyRec extension." is the only thing in the release notes
08:19:24 <quicksilver> Peaker: maybe they were buggy and depended on a bug in type families?
08:19:31 <quicksilver> I vaguely remember some things might have been fixed.
08:20:40 <edwardk> i still tend to just use fmap and (>>>) rather than result and argument but maybe i'm just not hip
08:21:05 <Peaker> edwardk: using fmap as a semantic-editor-combinator on function results is less readable, IMO
08:21:26 <edwardk> peaker: depends on how much you know and love the anonymous reader ;)
08:21:28 <Peaker> edwardk: I do like:  result = (<<<) ; argument = (>>>) ; (f ~> g) x = f >>> x >>> g  though
08:22:20 <Peaker> edwardk: reader lets you manipulate the result only,  "result" and "argument" let you manipulate both -- also if you're specific to functions anyway -- why write code that is abstract/general to all monads, and not one that specifically names what's happening with result/argument?
08:23:28 <dolio> ivanm: FYI: some optimizers (like Neil Mitchell's super-O; I think it uses Church encoding) Church encode data types and then do for optimization, since then you only have to do a good job optimizing functions.
08:23:49 <dolio> Whoops, that sentence was a little messed up.
08:23:52 <Peaker> quicksilver: oh wait, with 6.10.3 I get an occurs check (cannot construct the infinite type: s = s -> t) rather than type family errors
08:24:28 <edwardk> peaker: mostly? because i tend to use these only really when defining fmap for a functor anyways =)
08:24:52 <ivanm> dolio: heh
08:24:57 <Peaker> edwardk: I find myself using SEC's everywhere in Haskell code :)
08:25:02 <ivanm> that's right, I remember that...
08:25:10 <Peaker> edwardk: including result, argument, first, second, and SEC's that I wrote for every data-type that I create
08:26:02 <ivanm> dolio: my main reason I had that there was because I did a research project on what the supervisor called "Totally Functional PRogramming", the aim of which is to replace all data types with fold-based equivalents :s
08:26:22 <ivanm> interesting stuff, but the entire time I was doing it I was thinking how impractical it was
08:26:25 <quicksilver> Peaker: sounds worth an email to g-h-u
08:26:29 <dolio> ivanm: Also, for instance, the Logic monad is essentially a Church encoded list, which has some better asymptotics and probably gets optimized better than using [a] for that particular application.
08:26:48 <ivanm> *nod*
08:26:49 <quicksilver> Peaker: it's likely the original behaviour was wrong, and the new error is correct, but it's probably easy to fix. And it might be a GHC bug.
08:26:59 <edwardk> peaker: heh, bah, (`fmap` fmap) `fmap` fmap `fmap` (>>>)  -- is infinitely clearer than (f ~> g) x = f >>> x >>> g ;)
08:27:21 <Peaker> edwardk: :-)
08:27:51 <edwardk> @type (`fmap` fmap) `fmap` fmap `fmap` (>>>)
08:27:52 <lambdabot> forall a b (a1 :: * -> * -> *) b1 c. (Arrow a1, Functor (a1 c)) => a1 b1 c -> (a -> b) -> a1 c a -> a1 b1 b
08:28:17 <ivanm> dolio: OK, I'm adding this on to the end of that slide: OK, I lied: some optimizers, etc. internally use Church Encodings \ldots but you should really know what you're doing!
08:28:28 <dolio> :)
08:28:30 <edwardk> @type flip fmap fmap `fmap` fmap `fmap` flip fmap
08:28:31 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => f a1 -> (a -> b) -> (a1 -> a) -> f b
08:28:43 <ivanm> edwardk: please keep that type of behaviour in private!
08:28:48 <edwardk> hah
08:28:51 <ivanm> there might be young impressionable children present!
08:28:52 <ivanm> ;-)
08:29:16 <ivanm> @time
08:29:17 <lambdabot> Local time for ivanm is Thu May 14 01:29:16
08:29:35 <ivanm> OK, I'm giving that talk in 9.5 hrs... I should get some shut-eye!
08:29:36 <ivanm> g'night all!
08:29:43 <dolio> Good luck.
08:30:00 <edwardk> @type (<**>) fmap `fmap` fmap `fmap` (<**>)
08:30:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a -> f a1
08:30:01 <lambdabot>       Expected type: (a1 -> b1) -> (a -> a1) -> (f a -> f a1) -> b
08:30:01 <lambdabot>       Inferred type: (a1 -> b1) -> (a -> a1) -> a -> b1
08:30:02 <ivanm> thanks!
08:30:05 <edwardk> aww
08:30:08 <Alpounet> Good luck.
08:31:03 <edwardk> ah woops <**> isn't flip (<$>) its flip (<*>)
08:31:22 <dolio> @type (<$$>)
08:31:23 <lambdabot> Not in scope: `<$$>'
08:31:41 <edwardk> @let (<$$>) = flip (<$>)
08:31:42 <lambdabot>  Defined.
08:31:56 <edwardk> @type (<$$>) fmap `fmap` fmap `fmap` (<$$>)
08:31:57 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => f a1 -> (a -> b) -> (a1 -> a) -> f b
08:32:11 <edwardk> its er.. decorative at least
08:32:54 <ziman> > ((<$$>) fmap `fmap` fmap `fmap` (<$$>)) [1, 2, 3] (chr . (+ ord '0')) (*2)
08:32:55 <lambdabot>   "246"
08:32:58 <edwardk> @type (<$$>) fmap <$> fmap <$> (<$$>)
08:32:59 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => f a1 -> (a -> b) -> (a1 -> a) -> f b
08:33:14 <Peaker> starting to look like a Perl camel (http://www.perlmonks.org/index.pl?node_id=45213)
08:33:31 <luite> too much fmapping here
08:33:52 <jmcarthur_work> kinky
08:34:38 <jmcarthur_work> @type flip fmap fmap <$> fmap <$> flip fmap
08:34:39 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => f a1 -> (a -> b) -> (a1 -> a) -> f b
08:34:41 <edwardk> fmap is a disturbingly useful combinator
08:35:27 <jmcarthur_work> "disturbingly useful' is like "uncomfortably parallel"
08:35:57 <dolio> That's why it should be named (.). :)
08:36:01 <taggadtyp> or like "discustingly beautiful"
08:36:19 <taggadtyp> or "alarmingly perfect"
08:36:19 <Peaker> edwardk: did you read the Conal's SEC post?
08:36:37 <jmcarthur_work> i think (.) is appropriate for Category, though
08:36:56 <jmcarthur_work> perhaps moreso than for Functor, i have decided
08:38:14 <Peaker> Something bothers me about the "duplication" between Functor and Category
08:38:24 <Peaker> as if one should be defined in terms of the other
08:38:44 <jmcarthur_work> it's a lot like the relationship between Monad and Arrow, i think
08:39:02 <jmcarthur_work> except you can actually get an Arrow from a Monad
08:39:04 <edwardk> peaker: i remember it, but i was already basically doing the same thing with fmap, etc. all along, so it was more a matter of codifying existing practice for me
08:39:24 <edwardk> peaker: unfortunately not every Category is a Haskell Functor.
08:39:31 <Peaker> edwardk: the "new" thing about it for me was stuff like (first . second . fmap . blah ...) traversing a "path"
08:39:38 <Peaker> edwardk: why not?
08:40:06 <mmorrow> thoughtpolice: too bad the "tiny C compiler" can't output x86_64 (only x86 iirc)
08:40:15 <edwardk> peaker: why does my category have to admit mapping by a function (a -> b) in Hask? what about a category of isomorphisms.
08:40:22 <edwardk> i.e. any groupoid
08:40:22 <mmorrow> thoughtpolice: it'd be cool to have a haskell x86_64 assembler
08:40:32 <mmorrow> edwardk: hint hint ;) :)
08:40:44 <edwardk> what about a discrete category that only has identity arrows?
08:40:59 <edwardk> mmorrow: haha
08:41:04 <mmorrow> thoughtpolice: then everything could be done in-process
08:41:05 <mmorrow> heh
08:41:20 <edwardk> mmorrow: we have harpy and llvm ;)
08:41:26 <Peaker> edwardk: yeah, fmap seems more expressive because it can apply arbitrary functions, what about:
08:41:26 <mmorrow> :(
08:41:48 <Peaker> class Category c => Functor f where fmap :: c a b -> c (f a) (f b)
08:41:53 * mmorrow will eventually write an x86_64 assembler if no one does it first
08:42:19 <vixey> mmorrow: what ? there's gcc already
08:42:19 <edwardk> peaker: look in category-extras, there is COntrol.Functor.Categorical
08:42:21 <edwardk> gotta run
08:42:32 <mmorrow> vixey: is that a part of my address space?
08:42:48 <mmorrow> can gcc compile + assemble directly to a memory buffer?
08:42:49 <jmcarthur_work> Peaker, i have wanted exactly that in practical code before, iirc
08:42:53 <mmorrow> vixey: :)
08:43:07 <jmcarthur_work> well, not exactly, but that would have satisfied it
08:43:29 <vixey> I don't know can't imagine that being much work though
08:43:32 <dolio> That only works for endofunctors. You want 'class (Category c, Category d) => Functor f c d where map :: c a b -> d (f a) (f b)'.
08:43:52 <mmorrow> vixey: yeah totally, i think it could be done with (relatively) not that much pain
08:43:53 <jmcarthur_work> hmm, getting complex
08:44:21 <mmorrow> vixey: just a matter of actually doing it (and collecting all the data you need to encode instructions)
08:44:51 <jmcarthur_work> ah, yeah, class (Category r, Category s) => CFunctor f r s | f r -> s, f s -> r where
08:45:06 <mxc> apparently, sun is trying to invent haskell: http://research.sun.com/minds/2005-0302/
08:45:21 <mxc> a bit old, but kind of funny to read
08:45:23 <quicksilver> you mean oracle.
08:45:32 <mxc> touche
08:45:44 <mmorrow> Oracle(R) Java(R)
08:46:08 <mmorrow> (TM)(TM)
08:46:55 <jmcarthur_work> i wish more libraries would represent Categorys and Arrows with (~>) or something instead of letters. i find it more readable. i guess using letters might help to make it more abstract though, discourage getting stuck on Hask...
08:47:37 <taggadtyp> what is a user of Haskell called? haskellian, haskeller, haskler, haskeltor, weirdo?
08:47:54 <roconnor> haskeller
08:47:59 <mxc> taggadtyp: productive
08:48:01 <vixey> "taking on an enormous challenge -- create a programming language better than Java"
08:48:03 <vixey> smirk
08:48:07 <mxc> hehe
08:48:09 <mxc> i loved that
08:48:43 <EvilTerran> jmcarthur_work, i think the main deterrent may be that infix types require an extension
08:48:47 <vixey> "Designing technically competent programming languages is not that difficult," he says.
08:49:15 <vixey> the author of this article used to write The Sun
08:49:22 <mxc> well, if java is your baseline..
08:49:43 <vixey> (cheesy tabloid newspaper)
08:50:17 <quicksilver> EvilTerran: but so do MPTCs :P
08:50:31 <mxc> anyway, would love to sit here and rag on a language that, to be fair, is used by probably 10,000 times more people htan my language of choice, but its bedtime in asia
08:50:56 <quicksilver> oh, Arrow isn't multi-param, though. It's single param but higher kinded.
08:51:04 * quicksilver got his levels tangled.
08:51:11 <mmorrow> oh noes!
08:51:29 <vixey> Claim to Fame: Co-wrote the specification of the Java programming language.
08:51:37 <vixey> that is not how I remember Guy Steele..
08:51:50 <taggadtyp> show would you do Facts in Prolog style?
08:52:04 <taggadtyp> I have now Fact String String String
08:52:10 <taggadtyp> Fact <name> x y
08:52:22 <vixey> I think his work on the revised revised revised revised revised algorithmic language scheme is much more notable
08:52:22 <taggadtyp> Fact "father" "SPJ" "haskell"
08:52:35 <taggadtyp> but for just : Fact "haskeller" "dons"
08:52:38 <taggadtyp> that doesnt work
08:52:50 <vixey> taggadtyp: Have you implemented unification?
08:52:56 <taggadtyp> what is that?
08:53:00 <vixey> :S
08:53:15 <vixey> maybe you should learn Prolog first :p
08:53:40 <yowgi> No.
08:54:08 <EvilTerran> taggadtyp, Fact "..." "..." wouldn't work, you've only provided two of the three parameters to Fact
08:54:15 <vixey> yowgi: that was no to what I said?
08:54:30 <yowgi> that's prolog's “no” :)
08:55:12 <taggadtyp> but prolog is something like Fact <name> x true
08:55:16 <taggadtyp> autamtically true then
08:55:20 <taggadtyp> for one name
08:55:21 <taggadtyp> ah
08:55:23 <Peaker> coCocoa: you there?
08:55:26 <mmorrow> taggadtyp: all unification is is (all (==) . toList $ zipTree tree1 tree2)
08:55:32 <mmorrow> taggadtyp: simple
08:56:03 <mib_52m54gi3> is there a prolog library for haskell
08:56:17 <vixey> taggadtyp: I'm just saying if you don't know prolog implementing it isn't going to work really well
08:56:40 <mmorrow> (all (uncurry (==)) . toList $ zipTree tree1 tree2) ;)
08:56:41 <vixey> You really have to know a language inside out to implement it properly
08:56:57 <mib_52m54gi3> yowgi ment "No." in prolog: there are no more solutions :-)
08:57:00 <roconnor> bah, monads-fd gets callCC for StateT-Cont wrong too.
08:57:02 <taggadtyp> vixey: im just gonna do querying
08:57:21 <vixey> taggadtyp: that doesn't change anything
08:58:10 <Peaker> roconnor: monads-fd?
08:58:16 <quicksilver> taggadtyp: Please try to stick to a consistent nick. I makes it easier for others to relate to you.
08:58:21 <taggadtyp> (all (==) . toList $ zipTree tree1 tree2)
08:58:27 <taggadtyp> what does zipTree do?
08:58:27 <mmorrow> @let zipT (Node x xs) (Node y ys) = Node (x,y) (zipWith zipT xs ys)
08:58:28 <lambdabot>  Defined.
08:58:37 <vixey> :t Node
08:58:38 <lambdabot> forall a. a -> Forest a -> Tree a
08:58:52 <mmorrow> @let unify = (flatten .) . zipT
08:58:53 <lambdabot>  Defined.
08:59:12 <roconnor> Peaker, the "new" mtl, which has been broken into transformers and then your choice of monads-fd or monads-tf
08:59:22 <glguy> monadlib is the new mtl
08:59:26 <roconnor> Peaker: depending on if you like fun-deps or type-families
08:59:37 <glguy> why do we need yet another?
08:59:57 <quicksilver> monadlib isn't source compatible with mtl, I think?
09:00:08 <Peaker> roconnor: ah. So lots of duplication?
09:00:16 <roconnor> glguy: monadLib is a completely different (and better) monad library that doesn't even pretend to be compatible with the mtl
09:00:18 <mmorrow> > unify (Node 3 [Node 4 [], Node 7 []]) (Node 3 [Node 4 [], Node 8 []])
09:00:20 <lambdabot>   [(3,3),(4,4),(7,8)]
09:00:34 <glguy> to be compatible, you'd have to make the same mistakes
09:00:45 <vixey> > unify (Node 3 [Node 4 []]) (Node 3 [Node 4 [], Node 8 []])
09:00:46 <lambdabot>   [(3,3),(4,4)]
09:00:54 <glguy> so it makes sense that the state/cont stacking is wrong
09:00:54 <roconnor> Peaker: not really.  The transformer package has all the concrete stuff, and the other two packages have the class stuff in the two different forms.
09:00:59 <vixey> I don't know what this has got to do with unification
09:01:06 <mmorrow> vixey: yeah, you'd need to do "zip" right
09:01:14 <quicksilver> well the point of the monads-fd monad-tf split is to make those mistakes using type families instead of fundeps :)
09:01:14 <taggadtyp> is there a way to allow compilation when typedeclarations ahev no matching bodies?
09:01:27 <mmorrow> vixey: it's the first part
09:01:33 <glguy> thingididn'tdefine=undefined
09:01:33 <vixey> taggadtyp just write  f :: <sig> ; f = f
09:01:35 <roconnor> glguy: ya, transformers/monad-fd is a very little change over the mtl
09:01:47 <mmorrow> vixey: the second is taking the list and doing whatever your particular unification operation is
09:01:50 <roconnor> glguy: mostly as migration towards type-families I think
09:01:51 <Peaker> roconnor: ah
09:02:25 <glguy> type-families :(
09:02:34 <quicksilver> heresy!
09:02:39 <quicksilver> type families are the cure for all ills.
09:02:41 <glguy> meet the new wheel
09:02:43 <glguy> same as the old
09:02:45 <jmcarthur_work> i like type families
09:02:47 <taggadtyp> hmm shouldnt that give missing pmatches or soemthing?
09:02:55 <mmorrow> > unify (Node "->" [Node "a" [], Node "b" []]) (Node "->" [Node "c" [], Node "Int" []])
09:02:55 <glguy> REINVENTED!
09:02:56 <lambdabot>   [("->","->"),("a","c"),("b","Int")]
09:02:56 <glguy> woot
09:03:03 <jmcarthur_work> i haven't yet made a mental model of how dependencies map to families though
09:03:36 <mmorrow> > let xs = filter (\(a,b) -> all (all isAlpha) [a,b]) [("->","->"),("a","c"),("b","Int")] in xs
09:03:37 <lambdabot>   [("a","c"),("b","Int")]
09:04:01 <quicksilver> glguy: ?
09:04:14 <quicksilver> glguy: type families certainly aren't the same as functional dependencies.
09:04:18 <glguy> quicksilver, they give no additional power over what we had with fundeps
09:04:21 * quicksilver senses negativity from glguy today.
09:04:28 <mmorrow> > let xs = filter (\(a,b) -> all (all isAlpha) [a,b]) [("->","->"),("a","c"),("b","Int")]; us = nub $ concatMap (\(a,b)->[a,b]) xs; in us
09:04:29 <glguy> they are a reformulation
09:04:29 <lambdabot>   ["a","c","b","Int"]
09:04:35 <quicksilver> haskell gives no additional power over awk
09:04:40 <quicksilver> that doesn't mean they're the same.
09:04:44 <roconnor> glguy: I was told that type families work with GADTs and fun-deps, not somuch
09:04:52 <quicksilver> they're really quite different.
09:04:52 <mmorrow> > let xs = filter (\(a,b) -> all (all isAlpha) [a,b]) [("->","->"),("a","c"),("b","Int")]; us = nub $ concatMap (\(a,b)->[a,b]) xs; m = M.fromList (zip [0..] us) in m
09:04:53 <lambdabot>   /tmp/3058673465913252985:70:170: Not in scope: `M.fromList'
09:04:57 <mmorrow> > let xs = filter (\(a,b) -> all (all isAlpha) [a,b]) [("->","->"),("a","c"),("b","Int")]; us = nub $ concatMap (\(a,b)->[a,b]) xs; m = Map.fromList (zip [0..] us) in m
09:04:59 <lambdabot>   fromList [(0,"a"),(1,"c"),(2,"b"),(3,"Int")]
09:05:16 <vixey> mmorrow: I always preferred imperative formulations of the unify algorithm
09:05:34 <mmorrow> > let xs = filter (\(a,b) -> all (all isAlpha) [a,b]) [("->","->"),("a","c"),("b","Int")]; us = nub $ concatMap (\(a,b)->[a,b]) xs; m = Map.fromList (zip [0..] us) in fmap (\(a,b) -> ((a,m Map.! a),(b,m Map.! b))) xs
09:05:35 <lambdabot>       No instance for (Enum [Char])
09:05:35 <lambdabot>        arising from the arithmetic sequen...
09:05:41 <taggadtyp> query :: Fact -> Env -> Bool
09:05:41 <taggadtyp> satisfiesRule xs = filter (== Fact "father" _ _) xs
09:05:43 <taggadtyp> should be possible ^^
09:05:52 <mmorrow> crap, i took a wrong turn, but you get the idea :)
09:05:59 <vixey> taggadtyp: You can do that sort of thing in Prolog but not Haskell
09:06:08 <vixey> taggadtyp: (maybe you know this already)
09:06:31 <mmorrow> vixey: ah yeah, you jsut reminded me of you ST unify implem you pasted a ways back. /me finds it
09:06:55 <mmorrow> vixey: i've never implemented it imperatively, but to each their own
09:08:14 <vixey> @brain
09:08:14 <lambdabot> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
09:08:17 <vixey> @brain
09:08:18 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
09:09:01 <mmorrow> heh
09:11:12 <taggadtyp> anyone know what taggadtyp means?
09:11:17 <vixey> I don't :(
09:11:34 <taggadtyp> what does vixey mean?
09:11:47 <vixey> its a cartoon character
09:11:59 <taggadtyp> in which cartoon?
09:13:48 <mm_freak_> i'm reading a tutorial that says:  given an object X, if for every other object Y there exists exactly one morphism Y → X, then X is a terminal object…  it shows singleton sets in the category of sets as examples of such objects
09:13:51 <mm_freak_> isn't that wrong?
09:14:04 <mm_freak_> there can be multiple functions from a set to a singleton set
09:14:39 <quicksilver> how?
09:14:53 <quicksilver> what choices are there for functions from {1,2,3,4,5}  to {z} ?
09:14:58 <quicksilver> (e.g.)
09:15:44 <mm_freak_> oh, partial functions aren't morphisms in Set
09:15:49 <quicksilver> indeed not.
09:16:02 <vixey> mm_freak_: if it's not defined for some input that input isn't part of its range
09:16:05 <mm_freak_> ok, my error =)
09:16:06 <doserj> mm_freak_: s/every other object/every object/ is the usual definition, but I guess that's only a techicality
09:16:25 <mm_freak_> doserj: i guess so, seems to be equivalent to me
09:16:39 <mm_freak_> oh, actually it isn't
09:16:48 <mmorrow> id
09:17:07 <mm_freak_> there can be other morphisms besides id
09:17:07 <quicksilver> depends how you connote 'Other'
09:17:26 <mmorrow> mm_freak_: not from the terminal obj to the terminal obj
09:17:27 <Peaker> how are functions of multiple arguments usually encoded as morphisms in CT?
09:17:30 <quicksilver> I would read 'other' in that sentence to mean that Y is a distinct name, but not necessarily a distinct object.
09:17:41 <quicksilver> the otherness is about the naming, not the quantification.
09:17:48 <mmorrow> mm_freak_: because the terminal object's id is the unique map from the terminal obj to the terminal obj
09:17:53 <doserj> quicksilver: then why call it "other" at all?
09:18:14 <quicksilver> doserj: it's a signpost pointing at the fresh name 'Y'
09:18:15 * quicksilver shrugs
09:18:22 <quicksilver> it's just one of the many ambiguities in english.
09:18:27 <doserj> yeah
09:18:47 <mmorrow> mm_freak_: and if the terminal obj had any endo other than id that would violate its definition :)
09:19:10 * doserj is reminded of "let p,q be two points" vs. "let p be a point, and q be a point" :)
09:19:17 <mm_freak_> Peaker: a function with multiple arguments is a function with one argument from a cartesian product
09:19:23 <vixey> hah!
09:19:29 <vixey> p, q : Point
09:19:40 <MyCatVerbs> doserj: whaaat is the difference? Does the former necessarily require p and q to be distinct?
09:19:55 <Peaker> mm_freak_: basically uncurrying the functions?
09:19:55 * vixey thinks  void* x, y;
09:20:00 <doserj> MyCatVerbs: if they are not distinct, they are not two points, but one :)
09:20:13 <mm_freak_> mmorrow: sure, but with my definition above ("other" means "different from") a terminal object T could have multiple morphisms T → T
09:20:25 <Peaker> vixey: working to perpetuate misleading C syntax? :)
09:20:25 <glguy> vixey, void *x, *y;?
09:20:31 <mmorrow> mm_freak_: not up to isomorphism
09:20:43 <MyCatVerbs> doserj: so "let p,q be two points" *does* imply distinctness?
09:20:49 <doserj> MyCatVerbs: but I guess no mathematician would read it like that
09:21:05 <vixey> yeah it's a barrel of laughs
09:21:13 <MyCatVerbs> I dunno. I read it as "let p and q be two names indicating points".
09:21:19 <MyCatVerbs> Which doesn't preclude p and q aliasing one anotehr.
09:21:22 <MyCatVerbs> *another.
09:21:27 <mmorrow> mm_freak_: because by definition of terminal object, every object has a single (up to iso) morphism to the terminal object, itself included
09:21:39 <mm_freak_> Peaker: that's how i've seen it so far
09:21:43 <quicksilver> mmorrow: you misunderstand.
09:21:46 <Peaker> mm_freak_: thanks
09:21:50 <quicksilver> mmorrow: he is talking about a different defintion.
09:21:57 <mmorrow> oh
09:21:58 <quicksilver> mmorrow: a literal reading of his definition.
09:21:59 <NEEDMOAR> "let {p,q} a set of points of cardinallity two"
09:22:07 <quicksilver> we're just being pedantic about english :)
09:22:10 <MyCatVerbs> doserj: but I would burn down the house of anybody who wrote a proof relying on "let p,q be two points" implying that p and q must be distinct, without actually stating it.
09:22:17 <mm_freak_> Peaker: i don't know if there is another mathematical equivalent to currying outside of lambda calculus
09:22:19 <MyCatVerbs> Explicitly, I mean.
09:22:21 <jmcarthur_work> so would i
09:22:27 <mmorrow> quicksilver: ohh, i see what you mean
09:22:39 <MyCatVerbs> If they were homeless, I would jump up and down on their cardboard box.
09:22:49 <mm_freak_> mmorrow: that's my point:  in my definition that "itself included" is not present =)
09:22:56 <MyCatVerbs> If they were boxless... uh, I don't think boxless people write many papers. Good thing, because I'm not sure what to do in that situation.
09:23:16 <jmcarthur_work> stand in their personal space
09:23:17 <mmorrow> mm_freak_: ahh, ok i see. then i change what i'm saying to "it should be" :)
09:23:36 <vixey> \p : Point, \q : Point,
09:23:45 <Peaker> mm_freak_: you can probably create a morphism to an object that contains morphisms?
09:23:52 <Peaker> mm_freak_: or maybe not, I'm a CT newbie
09:23:53 <mmorrow> because if that's not part of the def then that's not the def for terminal object
09:24:00 <gwern> Peaker: yo dawg...
09:25:26 <mm_freak_> Peaker: can there be a set of all functions?
09:25:55 <mmorrow> mm_freak_: (hmm, although maybe it's possible to prove that ==> if there exists (up to iso) and object such that every other object (excluding itself (and every object iso to it)) has a unique morphism to it, then that implies it has a unique morphism to itself)
09:26:27 <mmorrow> mm_freak_: sure
09:26:41 <mmorrow> {f | f : R -> R} (e.g.)
09:27:00 <doserj> mmorrow: that trivially doesn't hold
09:27:13 <mmorrow> doserj: yeah, i suspected as much
09:27:17 <quicksilver> just create a category with two objects
09:27:22 <quicksilver> and make it do what you want.
09:27:23 <doserj> or with one :)
09:27:33 <quicksilver> there is precious little you can say about categories in full generality.
09:28:13 <doserj> but I don't think something really bad happens with this definition of terminal
09:28:14 <Peaker> mm_freak_: I don't know
09:29:15 <mm_freak_> Peaker: mmorrow says yes, so you can use that to express currying categorically, but it's not as useful as in lambda calculus
09:29:39 <mm_freak_> consider that the result of such a partial application is not an object
09:30:38 <quicksilver> if f :: a -> b -> c
09:30:49 <quicksilver> then f "is a morphism" from the object 1 to the object A -> B -> C
09:30:58 <quicksilver> f x :: b -> c
09:31:16 <quicksilver> f x "is a morphism" from the object 1 to the object B -> C
09:31:56 <quicksilver> which factors along morphisms x from 1 to A and across an adjunction which corresponds f with a morphism from A to B -> C
09:32:06 <quicksilver> writing out the meanings of stuff in CCC is longwinded :)
09:33:04 <mmorrow> mm_freak_: whether a category has currying or not is equivalent to whether that category is cartesian-closed
09:34:19 <mm_freak_> mmorrow: i don't know what that is yet =)
09:34:45 <mmorrow> "has currying" := Hom(A><B,C) === Hom(A,Hom(B,C)))
09:34:56 <quicksilver> not just that.
09:35:03 <quicksilver> also that (B -> C) "exists"
09:35:19 <quicksilver> i.e. that we can choose an object B -> C which 'corresponds to' Hom(B,C) and makes that all work.
09:35:38 <quicksilver> actually it doesn't have to correspons to Hom(B,C) a priori
09:35:42 <quicksilver> it just does in practice.
09:35:43 <mmorrow> sure, that Hom(B,C) /= /O
09:35:55 <quicksilver> no, it's more than that.
09:36:01 <quicksilver> Hom(B,C) is a set, not an object.
09:36:01 <mmorrow> so the above iso isn't true vacuously
09:36:11 <quicksilver> the key point is that an *object* exists.
09:36:18 <mmorrow> depends what category we're in :)
09:36:23 <quicksilver> which we call B -> C or C ^ B
09:36:34 <quicksilver> which is adjoint to *
09:36:52 <quicksilver> the fact it is in some sense corresponding to the Hom-set is further fact.
09:36:56 <grahamhutton> mmorrow: currying can also make sense in more general contexts, such as monodial closed categories.  I don't think it's correct to say that "has currying is equivalent to being cartesian closed".
09:37:04 <mmorrow> A><- if adjoint to Hom(-,C)
09:37:05 <quicksilver> (Which can be deduced if * is the cartesian product)
09:37:12 <mmorrow> s/if/is/\
09:37:13 <doserj> quicksilver: that's included in "cartesian closed", isn't it?
09:37:24 <quicksilver> doserj: yes. We're trying to *define* cartesian closed here.
09:37:27 <mmorrow> quicksilver: which it is if the category has a terminal object
09:37:33 <quicksilver> and the point is that closure exists without cartesian.
09:37:51 <quicksilver> you can have closures on other operators than cartesian product.
09:37:58 <doserj> ahh
09:38:05 <quicksilver> (and only in the cartesian case do you get something which looks like it's related to the hom-set)
09:38:38 <mmorrow> grahamhutton: interesting, how so?
09:38:56 <quicksilver> just take a monoid product * which isn't product
09:39:04 <grahamhutton> e.g. see http://en.wikipedia.org/wiki/Closed_monoidal_category
09:39:07 <quicksilver> and take the closure, which is conventionally called -*
09:39:15 <quicksilver> you still get the currying isomorphims
09:39:25 <quicksilver> between A * B -* C and A -* B -* C
09:39:35 <quicksilver> my thesis, as grahamhutton probably remembers, was on bunched logic
09:39:38 <thoughtpolice> woot
09:39:42 <quicksilver> which has two sets of currying isomorphisms :)
09:39:45 <thoughtpolice> dph works with head again (hopefully)
09:39:58 <grahamhutton> indeed Jules!
09:39:59 * thoughtpolice compiles to see how much improvement has been made since 6.10.1 when he last tried it
09:41:40 <mmorrow> grahamhutton: ah, so i ammend my statement to be "only makes sense if A><- is adjoint to Hom(-,C)" and drop the requirement for terminal object, since (product is cartesian <==> cat has a temrinal object)
09:42:15 <mmorrow> (i think that is equivalent to the page you linked to)
09:45:17 <quicksilver> in a sense, it is from these observations that the notion of enrichment comes
09:45:29 <quicksilver> and that's where we get the idea that Hom(B,C) might be something more than a set
09:45:37 <quicksilver> and a CCC has a canonical enrichment over itself.
09:45:53 <quicksilver> so, the point of my pedantry is only about getting the logical progression of ideas in the right order.
09:46:23 <quicksilver> so "having an enrichment over itself" is actually a cool way of saying "functions as first class objects"
09:48:58 <mmorrow> Hom(B,C) necessarily becomes a group
09:49:28 <mmorrow> (i think. at least it becomes a monoid)
09:49:34 <doserj> huh?
09:49:37 <quicksilver> Hom (A,A) is always a monoid.
09:49:44 <quicksilver> Hom(B,C) isn't even self-composable
09:49:47 <quicksilver> the ends don't match.
09:49:52 <mmorrow> not under composition
09:49:52 <quicksilver> unless B =
09:50:11 <quicksilver> oh, under what then?
09:50:39 <mmorrow> i'm trying to remember
09:51:35 <mmorrow> the relevant concept is one of {additive, abelian} category
09:51:38 <mmorrow> http://en.wikipedia.org/wiki/Additive_category
09:51:58 <mmorrow> (e.g.) modules over a ring R
09:52:38 <mmorrow> i guess you need an initial object
09:52:40 <eu-prleu-peupeu> hi
09:53:09 <mmorrow> oh wait, no
09:53:11 <mmorrow> terminal
09:53:29 <mmorrow> ok, so because  1><A === A
09:54:14 <mmorrow> and B --(A><-)--> Hom(B,C) is a monoid homomorphism
09:54:31 <mmorrow> i just can't remember what the (*) is on Hom(B,C) dangit
09:54:38 <mmorrow> (+) i should say
09:55:00 <mmorrow> (i might very well be wrong here too :)
09:55:10 <mmorrow> (and thinking of something else that's related)
09:56:24 <mmorrow> hmm, the category might have to have zero objects actually i think
09:58:13 <mmorrow> i think for this to work the object in the category have to themselves be groups (or monoids at least)
09:58:47 <mmorrow> then (+) on Hom(B,C) is the (+) induced by the (+) for the group (resp. monoid)
09:59:05 <mmorrow> (f + g)(a) = f(a) + g(a)
10:01:05 <taggadtyp> vixey: what cartoon?
10:01:24 <taggadtyp> the fox and the hound?
10:01:53 <taggadtyp> Lady & Lufsen in swedish
10:02:15 <skorpan> lady and the tramp?
10:02:21 <taggadtyp> nah
10:02:30 <lament> the lady or the tramp?
10:02:46 <taggadtyp> oh yeah actually
10:03:08 <taggadtyp> the other is micke and molle right?
10:03:12 <taggadtyp> http://en.wikipedia.org/wiki/The_Fox_and_the_Hound
10:03:19 <skorpan> yes
10:05:43 <vixey> @farmer
10:05:43 <lambdabot> He's doing a great job in spades.
10:05:45 <vixey> @farmer
10:05:46 <lambdabot> He's a real slime-burger.
10:05:59 <mmorrow> @nixon
10:05:59 <lambdabot> Don't try to take on a new personality; it doesn't work.
10:06:34 <taggadtyp> @vixey
10:06:35 <lambdabot> I Think you're fake
10:06:37 <taggadtyp> @vixey
10:06:38 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
10:06:43 <taggadtyp> @dons
10:06:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:06:59 <taggadtyp> @Cale
10:06:59 <lambdabot> Unknown command, try @list
10:07:04 <taggadtyp> @OO
10:07:04 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
10:07:18 <mmorrow> , [$bf|.+[.+]|] ""
10:07:20 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
10:07:31 <vixey> lol
10:07:35 <vixey> @dons
10:07:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:08:14 <vixey> , [$bf|+[,>]<[.<]|] "aeouaoeircg"
10:08:16 <lunabot>  "a"
10:08:26 <vixey> , [$bf|+[>,]<[.<]|] "aeouaoeircg"
10:08:27 <lunabot>  "*** Exception: bf blocked on input"
10:08:40 <vixey> , [$bf|+[>,]<[+.<-]|] "aeouaoeircg"
10:08:42 <lunabot>  "*** Exception: bf blocked on input"
10:09:06 <mmorrow> , [$bf|+[>,]<[+.<-]|] ("aeouaoeircg" ++ ['a'..])
10:09:08 <lunabot>  "*** Exception: bf blocked on input"
10:09:13 <mmorrow> um
10:09:27 <mmorrow> , length ['a'..]
10:09:28 <lunabot>  1114015
10:09:39 <mmorrow> , [$bf|+[>,]<[+.<-]|] ("aeouaoeircg" ++ cycle "a")
10:09:42 <lunabot>  luna: out of memory (requested 1048576 bytes)
10:10:57 <taggadtyp> > length [1..10]
10:10:58 <lambdabot>   10
10:11:09 <taggadtyp> > length ["a","c".."z"]
10:11:10 <lambdabot>       No instance for (Enum [Char])
10:11:10 <lambdabot>        arising from the arithmetic sequen...
10:11:25 <taggadtyp> > length ['a','c'..'z']
10:11:26 <lambdabot>   13
10:11:34 <taggadtyp> > ['a','c'..'z']
10:11:36 <lambdabot>   "acegikmoqsuwy"
10:12:24 <mmorrow> , [$bf|+[>,]<[+.<-]|] "aeouaoeircg\0"
10:12:26 <lunabot>  "hcrieoauoea"
10:12:42 <eu-prleu-peupeu> what does the MUT value mean (when i run a haskell program with teh +RTS option) ?
10:12:56 * mmorrow just bothered to decipher what that was supposed to do
10:13:27 <mmorrow> vixey: nice on
10:13:28 <mmorrow> e
10:14:39 <mmorrow> , [$bf|[>,]<[.<]|] "aeouaoeircg\0"
10:14:40 <lunabot>  ""
10:17:31 <mmorrow> , [$bf|,[>,]<[.<]|] "aeouaoeircg\0"
10:17:32 <lunabot>  "gcrieoauoea"
10:17:54 <vixey> ,[>,]< --funroll-loops
10:17:55 <lunabot>  luna: parse error on input `,'
10:19:14 <mmorrow> , [$bf|,[>,]<[.<].|] "aeouaoeircg\0"
10:19:15 <lunabot>  "gcrieoauoea\NUL"
10:19:24 <mmorrow> , [$bf|,[>,].<[.<]|] "aeouaoeircg\0"
10:19:27 <lunabot>  "\NULgcrieoauoea"
10:19:58 <mmorrow> , [$bf2|,[>,]<[.<]|] "aeouaoeircg\0"
10:19:59 <lunabot>  ("gcrieoauoea",(-1,Mem (fromList [(0,97),(1,101),(2,111),(3,117),(4,97),(...
10:22:35 <edwardk> , [ succ -> x | succ -> y <- [1..4] ]
10:22:35 <mmorrow> , [$bf2|+++[>,+>+<<-]>,|] "a"
10:22:36 <lunabot>  luna: parse error on input `->'
10:22:36 <lunabot>  ("*** Exception: bf blocked on input",(-1,Mem (fromList [])))
10:22:50 <mmorrow> , [$bf|+++[>,+>+<<-]>,|] "a\0"
10:22:51 <lunabot>  "*** Exception: bf blocked on input"
10:23:40 <edwardk> , [ succ x | succ -> y <- [1..4] ]
10:23:41 <lunabot>  luna: parse error on input `->'
10:23:47 <mmorrow> , [$bf|+++[->,+>+<<]>,|] "a\0"
10:23:49 <lunabot>  "*** Exception: bf blocked on input"
10:24:18 <mmorrow> , [ succ y | (succ -> y) <- [1..4] ]
10:24:20 <lunabot>  [3,4,5,6]
10:24:28 <edwardk> oh of course
10:24:31 <mmorrow> :)
10:25:06 <edwardk> i had hoped for more symmetry there
10:25:26 <edwardk> , do (succ -> y) <- [1..4] | return (succ y)
10:25:28 <lunabot>  luna: The last statement in a 'do' construct must be an expression
10:25:38 <edwardk> , do (succ -> y) <- [1..4]; return (succ y)
10:25:40 <lunabot>  [3,4,5,6]
10:25:54 <mmorrow> , [$bf|+++>,<[->+>+<<]>.|] "a"
10:25:55 <lunabot>  "d"
10:26:41 <edwardk> i wonder what could be done to the precedence or what not to eliminate the need for the explicit parens around the view pattern there
10:26:46 <Gracenotes> moooo
10:27:52 <burp_> brainfuck?
10:28:13 <burp_> just looks like this
10:28:33 <mmorrow> , [$bf|+[>,[<+++[->+>+<<]>.>[-]<<]|] "abc\0"
10:28:34 <lunabot>  "e"
10:28:39 <mmorrow> burp_: oh yesh :)
10:29:42 <mmorrow> gah, brainfuck needs gotto
10:29:42 <taggadtyp> > (fmap . fmap) (+1) [Just 5,Just 7,Nothing]
10:29:44 <lambdabot>   [Just 6,Just 8,Nothing]
10:29:49 <taggadtyp> > (fmap . <$>) (+1) [Just 5,Just 7,Nothing]
10:29:50 <lambdabot>   <no location info>: parse error on input `<$>'
10:29:52 <mmorrow> it's just too hard to do anything useful
10:30:00 <mmorrow> *goto
10:30:02 <taggadtyp> > ((<$>) fmap) (+1) [Just 5,Just 7,Nothing]
10:30:03 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:30:14 <taggadtyp> > (+1) <$> Just 7
10:30:16 <lambdabot>   Just 8
10:30:24 <taggadtyp> so how can I compose <$>?
10:31:03 <mux> > ((+1) <$>) <$> [Just 5,Just 7,Nothing]
10:31:04 <lambdabot>   [Just 6,Just 8,Nothing]
10:31:09 <mux> like this
10:31:48 <edwardk> > fmap (+1) [Just 5, Just 7, Nothing] -- is probably clearer
10:31:49 <lambdabot>       No instance for (Num (Maybe t))
10:31:49 <lambdabot>        arising from the literal `1' at ...
10:31:56 <edwardk> er
10:31:58 <mux> edwardk: if it worked :-)
10:32:02 <mux> it'd be fmap . fmap
10:32:07 <edwardk> > fmap (+1) <$> [Just 5, Just 7, Nothing] -- is probably clearer
10:32:08 <mux> as taggadtyp wrote it earlier
10:32:08 <lambdabot>   [Just 6,Just 8,Nothing]
10:32:11 <edwardk> is what i meant =)
10:32:14 <mux> oooh.
10:32:48 <mux> I'm not satisfied until all fmap's hae been replaced by <$> :-)
10:33:27 <EvilTerran> mux, would you replace and (.), likewise? :P
10:33:34 <EvilTerran> er, map and (.)
10:33:42 <mux> EvilTerran: no, I leave that to Cale
10:34:14 <taggadtyp> > ((+1) <$>) <$> [Just 5,Nothing]
10:34:16 <lambdabot>   [Just 6,Nothing]
10:34:36 <edwardk> > fmap fmap fmap (+1)  [Just 5, Just 7, Nothing] -- go the other way, all <$>s should be fmaps
10:34:37 <lambdabot>   [Just 6,Just 8,Nothing]
10:34:44 <edwardk> no evil infix operators =)
10:36:41 <edwardk> Kmett's law: there is no problem in Haskell that can't be solved with another application of fmap.
10:37:12 <EvilTerran> fmap is a one-point basis for a turing-complete subset of haskell? :P
10:37:41 <taggadtyp>  > fmap fmap fmap (+1)  [Just 5, Just 7, Nothing]
10:37:50 <taggadtyp> > fmap fmap fmap (+1)  [Just 5, Just 7, Nothing]
10:37:51 <lambdabot>   [Just 6,Just 8,Nothing]
10:37:59 <taggadtyp> @src fmap
10:38:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:38:05 <wjt> @src Maybe fmap
10:38:05 <lambdabot> fmap _ Nothing       = Nothing
10:38:05 <lambdabot> fmap f (Just a)      = Just (f a)
10:38:09 <wjt> @src [] fmap
10:38:09 <lambdabot> fmap = map
10:38:52 <EvilTerran> ?src (->) fmap
10:38:52 <lambdabot> fmap = (.)
10:38:57 <EvilTerran> and that one :)
10:39:02 <taggadtyp> ah
10:40:43 <tromp> no idea what is smallest turing complete subset of haskell, but fmap itself doesnt cut it
10:41:06 <edwardk> > fmap (fmap fmap fmap) fmap (+1)  [Just (Left "Hello"), Just (Right 7), Nothing]
10:41:07 <lambdabot>   [Just (Left "Hello"),Just (Right 8),Nothing]
10:41:10 <taggadtyp> @srce fix
10:41:10 <lambdabot> fix f = let x = f x in x
10:41:17 <taggadtyp> fmap _ = fmap
10:41:21 <taggadtyp> @turing
10:41:21 <lambdabot> Unknown command, try @list
10:41:23 <tromp> and s and k don't work either
10:41:29 <taggadtyp> gmap fmap in fmap g fmap
10:41:42 <EvilTerran> tromp, s, k, and fix would do it, i suspect
10:42:11 <taggadtyp> why diesnt that give eror on "hello"+1?
10:42:13 <edwardk> bah, just need iota ;)
10:42:25 <edwardk> taggedtyp: fmap over Either only changes Rights
10:42:26 <taggadtyp> iota=?
10:42:32 <edwardk> @src (Either a) fmap
10:42:32 <lambdabot> Source not found. :(
10:42:48 <EvilTerran> ?src Either fmap
10:42:49 <lambdabot> fmap _ (Left x) = Left x
10:42:49 <lambdabot> fmap f (Right y) = Right (f y)
10:43:09 <tromp> @let f x y = x y x
10:43:10 <lambdabot>  <local>:4:8:
10:43:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = t2 -...
10:43:19 <edwardk> taggedtyp: a single combinator that can replace S and K. used in iota and jot
10:43:41 <taggadtyp> > let taggedtype = x in map taggedtype [1..10]
10:43:42 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
10:43:54 <taggadtyp> > let taggedtype = \_ -> +1 in map taggedtype [1..10]
10:43:55 <lambdabot>   <no location info>: parse error on input `+'
10:43:59 <taggadtyp> > let taggedtype = \_ -> 1 in map taggedtype [1..10]
10:44:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
10:44:45 <mmorrow> , $(fmaps 3) (+1) [Just (Left "Hello"), Just (Right 7), Nothing]
10:44:49 <lunabot>  [Just (Left "Hello"),Just (Right 8),Nothing]
10:45:07 <mmorrow> , ppDoc `fmap` fmaps 8
10:45:09 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
10:45:54 <edwardk> mmorrow: bah, clearly fmaps 8 should be written: fmap fmap (fmap fmap (fmap fmap ...
10:46:41 <mmorrow> i have mixed feelings about fmap for (.)
10:47:06 <edwardk> or more concisely: fmap fmap fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap
10:47:13 <mmorrow> heh
10:48:14 <edwardk> @type fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
10:48:15 <mmorrow> @type [(.),fmap] {- this looks more like composition than fmap to me -}
10:48:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) a b (f7 :: * -> *). (Functor f7, Functor f6, Functor f5, Functor f4, Functor f3,
10:48:16 <lambdabot> Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 a))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 b)))))))
10:48:16 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
10:48:23 <edwardk> @type fmap fmap fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap `fmap` fmap
10:48:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) a b (f7 :: * -> *). (Functor f7, Functor f6, Functor f5, Functor f4, Functor f3,
10:48:24 <lambdabot> Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 a))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 b)))))))
10:48:24 <mmorrow> heh
10:48:37 <mmorrow> , ppDoc `fmap` fmaps 20
10:48:39 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (f...
10:48:47 <edwardk> i leave that one as an exercise for the reader
10:48:47 <mmorrow> ah, too long to copy/paste
10:48:50 <Peaker> @type fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . id))))))
10:48:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) a b (f6 :: * -> *). (Functor f6, Functor f5, Functor f4, Functor f3, Functor f2, Functor f1, Functor f)
10:48:52 <lambdabot>  => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
10:49:41 <mmorrow> @djinn (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
10:49:41 <lambdabot> -- f cannot be realized.
10:50:10 <mmorrow> @djinn add data F a = F a
10:50:11 <lambdabot> Cannot parse command
10:50:12 <edwardk> it needs the functoriality of f..f6
10:50:15 <mmorrow> @djinn-add data F a = F a
10:50:25 <lpjhjdh> so I wrote a parser in ReadP that's expressive and concise, I want to add position tracking so I figured I'd just use StateT and it seems like a lot of grunt work
10:50:30 <lpjhjdh> should I just use something else?
10:50:48 <mmorrow> @djinn (a -> b) -> F (F (F (F (F (F (F a)))))) -> F (F (F (F (F (F (F b))))))
10:50:49 <lambdabot> f a b =
10:50:49 <lambdabot>     case b of
10:50:49 <lambdabot>     F c -> case c of
10:50:49 <lambdabot>            F d -> case d of
10:50:49 <lambdabot>                   F e -> case e of
10:50:51 <lambdabot>                          F f -> case f of
10:50:53 <lambdabot>                                 F g -> case g of
10:50:55 <lambdabot>                                        F h -> case h of
10:50:57 <lambdabot>                                               F i -> F (F (F (F (F (F (F (a i)))))))
10:51:22 <mmorrow> djinn would be really handy as a semi-automatic code generator
10:51:27 <jmcarthur_work> has anybody ever experimented with porting the GHC RTS to run in Linux kernel space or anything like that?
10:51:30 <ziman> would @pl optimize that? :)
10:51:33 <mmorrow> it gets callCC/shift/reset right..
10:51:48 <mmorrow> i don't think @pl does case
10:51:57 <mmorrow> @pl \x -> case x of x -> x
10:51:58 <lambdabot> (line 1, column 19):
10:51:58 <lambdabot> unexpected ">" or "-"
10:51:58 <lambdabot> expecting variable, "(", operator or end of input
10:52:01 <edwardk> jmcarthur: talk to the galois folks. i'm given to understand that they did something with it on bare metal but i know none of the details
10:52:27 <mmorrow> jmcarthur: there's an os "house" that ported the rts to run on the metal
10:52:55 <mmorrow> iirc they've got ghc-6.8.? ported at this point
10:53:04 <jmcarthur_work> right
10:53:16 <jmcarthur_work> i was just wondering if there were any efforts specifically toward the linux kernel
10:53:26 <mmorrow> like as a kernel module you mean?
10:53:31 <jmcarthur_work> yeah, something like that
10:53:42 <jmcarthur_work> i think it would be really cool
10:53:48 <mmorrow> that'd be interesting. what would be the benefits
10:53:49 <mmorrow> ?
10:53:58 <decaf> why? jmcarthur_work ?
10:54:06 <jmcarthur_work> so you can use haskell to write kernel modules!
10:54:11 <decaf> it would be "cool", nothing else
10:54:13 <Peaker> jmcarthur_work: kernel modules with potentially surprising space requirements? :)
10:54:47 <jmcarthur_work> just because, honestly
10:55:38 <mmorrow> jmcarthur: would there be any actual porting involved? couldn't you just write a C entry point that conforms to whatever, that then in turn calls your haskell main?
10:56:10 <jmcarthur_work> i'm thinking things like memory allocation and stuff would need to be ported
10:56:37 <mmorrow> ah true, although ghc (on unix) mmaps /dev/zero iirc
10:56:46 <mmorrow> (would this be ok for a kernel module?)
10:57:01 <jmcarthur_work> basically anything that relies on a system call would have to ported
10:57:09 <mmorrow> ah, i see
11:08:52 * QtPlaty[HireMe] ponders "Isn't having syntax of if a bit redundent.  Couldn't you have a function Bool -> a -> a -> a that multiplexed the way you expected?
11:09:05 <QtPlaty[HireMe]> /of/for/
11:09:13 <ErhardtMundt> Twey: hello there :)
11:09:43 <Botje> QtPlaty[HireMe]: like "if'" ?
11:10:39 <QtPlaty[HireMe]> Botje: Every question I ask just illistrates the depth of my ignorence.  This is trilling and educational.
11:10:44 <Botje> ;)
11:10:47 <Botje> happy to oblige
11:10:58 <Botje> is if' in base et?
11:12:32 <Botje> *yet
11:16:14 <MyCatVerbs> ls
11:16:18 <MyCatVerbs> ...wrong window.
11:16:24 <decaf> vey wrong
11:17:08 <MyCatVerbs> With a nick like "decaf", you should already understand the downsides of tiredness. :P
11:17:34 <decaf> I have to drink decaf as my doctor says, but I can't
11:18:11 <lilac> MyCatVerbs: i just assumed you were testing to see if any of us had extreme vulnerabilities in our IRC clients
11:18:32 <decaf> I did that twice. both was "ls" like yours. I'm waiting someone will give root pass to us
11:19:03 <MyCatVerbs> decaf: heh. Type "$ su" followed by "Password: "
11:19:21 <lilac> sudo send-money all lilac
11:19:25 <decaf> MyCatVerbs: yes, but mysql pass maybe
11:19:33 <MyCatVerbs> And hope that somebody is tired and drunk enough to think that they themselves just typed that into a terminal, and hence answer it.
11:19:56 <taggadtyp> vixey: what uni do you go to?
11:23:19 <Baughn_> MyCatVerbs: svein@eris ~ $
11:24:37 <taggadtyp> why is it not possible to use ? as prefix
11:24:40 <taggadtyp> have to use (?)
11:25:03 <taggadtyp> > let (?) a b = lookup a b in (?) 3 [1..10]
11:25:04 <lambdabot>       No instance for (Enum (t, b))
11:25:04 <lambdabot>        arising from the arithmetic sequen...
11:25:05 <sjanssen> taggadtyp: Haskell doesn't support prefix operators
11:26:44 <taggadtyp> > let (?) a b = lookup a b in (?) 3 [(1,2),(3,4)]
11:26:46 <lambdabot>   Just 4
11:26:46 <taggadtyp> > let (?) a b = lookup a b in 3 `?` [(1,2),(3,4)]
11:26:47 <lambdabot>   <no location info>: parse error on input `?'
11:26:57 <taggadtyp> > let (?) a b = lookup a b in 3 `(?)` [(1,2),(3,4)]
11:26:58 <lambdabot>   <no location info>: parse error on input `('
11:27:02 <taggadtyp> why cant i infix that?
11:27:04 <Peaker> taggadtyp: In Haskell, names beginning with letters are always prefix. Names wrapped in backquotes are always infix.  Names consisting of symbols (operators) are always infix
11:27:08 <taggadtyp> > let (?) a b = lookup a b in 3 ? [(1,2),(3,4)]
11:27:09 <lambdabot>   Just 4
11:27:12 <taggadtyp> ah
11:27:14 <Peaker> taggadtyp: Infix operators wrapped in () become prefix
11:27:17 <sjanssen> taggadtyp: only qnames may be in backquotes
11:30:43 <crutex> what is you guy's opinion of Cthulhon
11:32:20 <Baughn_> crutex: ..cthulhon? Cthulhu's girlfriend?
11:32:25 <decaf> he likes hitchhiker series, as his whois output says
11:32:55 <Baughn_> His name is Zaphod Beeblebrox. Huh, poor guy
11:33:10 <crutex> so you look down on him?
11:33:11 <vixey> why vote for a lesser evil
11:33:27 <Baughn_> crutex: Can't. Too busy gibbering in fear.
11:33:35 <crutex> !define gibbering
11:34:07 <crutex> does haskell have a way of using sockets
11:34:18 <vixey> crutex yes
11:34:19 <abbe> crutex: Network.Socket :-)
11:34:31 <crutex> can someone help me then, i'm trying to open a socket to ur mom
11:34:34 <mm_freak_> or Network, if you don't need all that low-level stuff
11:35:00 <crutex> she's open on port 80
11:35:04 <vixey> crutex how dare you!
11:35:17 <mm_freak_> handle <- connectTo "www.haskell.org" (PortNumber 80)
11:35:19 <mm_freak_> =)
11:35:21 <decaf> Baughn_: what's wrong with zaphod? having two heads isn't  a good thing?
11:35:24 <Peaker> Can TH be used to change the way stuff is generally parsed, or only to create macros you can access with that weird [blah| ..] syntax?
11:35:27 <pastorn> @faq can haskell make me a sammich?
11:35:27 <lambdabot> The answer is: Yes! Haskell can do that.
11:35:45 <crutex> @faq can haskell create matter from nothing?
11:35:45 <lambdabot> The answer is: Yes! Haskell can do that.
11:35:46 <Peaker> mm_freak_: I dislike "Network" for not documenting what protocol they even use
11:35:53 <mm_freak_> @faq can haskell open a socket to my mom?
11:35:54 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:01 <crutex> hey, haskell seems pretty useful
11:36:16 <crutex> @faq is there anything haskell can't do?
11:36:16 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:33 <mm_freak_> Peaker: as far as i see, they do
11:36:35 <Baughn_> decaf: I'm not worried about the two heads, so much as the tentacles, the telepathic madness broadcast, and the squamous skin
11:36:49 <Peaker> mm_freak_: I couldn't find any mention of TCP or AF_INET or such in the docs
11:36:59 <mm_freak_> "Calling connectTo creates a client side socket which is connected to the given host and port. The Protocol and socket type is derived from the given port identifier. If a port number is given then the result is always an internet family Stream socket."
11:37:09 <mm_freak_> internet family Stream socket = TCP
11:37:22 <Baughn_> decaf: Then there's the fact that if he ever wakes, we'll lose 1d6 haskellers per round
11:37:25 <mm_freak_> although there may be other types of stream protocols over IP
11:37:35 <edwardk> jmcarthur: haskell is a pretty poor choice for kernel development because it allocates memory freely for normal operation, in a space where you typically operate with 8k stacks and can't block to get more memory when something goes wrong, haskell is particularly poorly suited.
11:37:42 <mm_freak_> so yes, it's a bit imprecise
11:38:11 <mm_freak_> edwardk: i wonder how useful BitC is
11:38:18 <crutex> bitcomet sucks
11:38:24 <Baughn_> jmcarthur_work: However, it might work much better in a microkernel environment
11:38:29 <edwardk> mm_freak_: its largely irrelevant now that shapiro left the project for microsoft
11:38:33 <mm_freak_> BitC is a functional language specifically for low-level stuff
11:38:36 <Baughn_> jmcarthur_work: mNobody says you /have/ to do it that way
11:38:43 <mm_freak_> edwardk: hmm, ok
11:39:01 <crutex> /o/
11:39:02 <crutex> \o\
11:39:09 <edwardk> mm_freak_: as if folks didn't see that coming after his abandonment of EROS back in the day.
11:39:15 <Peaker> edwardk: I'm wondering about designing a strict language with (perhaps optional) manual memory management, but that has a lot of the goodies from Haskell (type-classes, even purity, etc)
11:39:32 <Peaker> mm_freak_: BitC is pretty imperative isn't it?
11:39:39 <edwardk> peaker: its so hard for me to give up partial application though
11:39:40 <Peaker> mm_freak_: and has a C-style type system?
11:39:56 <crutex> i never knew there was actually an entire channel of hundreds of Cthulhon s
11:39:56 <Peaker> edwardk: I think you don't have to give them up.. consider C++'s bind<> template
11:39:58 <mm_freak_> Peaker: nope, it is (was) supposed to be very similar to haskell
11:40:05 <Peaker> edwardk: binds can be done with static allocations
11:40:21 <Peaker> mm_freak_: I thought Shapiro didn't even know Haskell, I'll relook
11:40:35 <mm_freak_> hmm…  i've written a functor/monad library in C# at work, because the normal way of doing things in C# is pretty ugly
11:40:39 <edwardk> peaker: and a lot of type class machinery is usually defined in terms of dictionary construction, so to do that without allocation you'd have to build them on the stack and store references back to the stack or something
11:40:48 <taggadtyp> so bitC isnt developed anymore?
11:40:58 <jmcarthur_work> edwardk, does haskell kill the stack much? i thought it mostly used heap memory
11:41:01 <mm_freak_> Peaker: i may be wrong, of course
11:41:11 <jmcarthur_work> well, ghc, that is
11:41:20 <Peaker> edwardk: the dictionary construction is per-type and thus static isn't it?
11:41:27 <edwardk> jmcarthur_work: the problem we're talking about is what can you do 'haskell-like' while retaining explicit memory management for systems code
11:41:46 <edwardk> Peaker: i wish. polymorphic recursion blows that out of the water
11:41:50 <dolio> You may have to construct arbitrarily many dictionaries.
11:41:54 <Peaker> edwardk: example?
11:42:08 <jmcarthur_work> edwardk, well, i would probably say that porting the garbage collector as well wouldn't be such a bad idea, no?
11:42:10 <dolio> Dict a -> Dict b -> Dict (a,b)
11:42:26 <Peaker> dolio: I see why you'd have to build one for each instance, but that's a compile-time thing?
11:42:36 <dolio> Lets you construct Dict (a,b), Dict (a,(a,b)), ...
11:42:55 <jmcarthur_work> you could still do FFI-ish things for explicit memory management, where necessary
11:43:00 <edwardk> jmcarthur_work: some environments just don't let you require unbounded memory allocation to operate
11:43:20 <Peaker> dolio: are you talking about type-classes?
11:43:45 <jmcarthur_work> edwardk, true, but i don't mean to imply that this should work on, say, embedded systems or anything like that
11:44:03 <edwardk> jmcarthur_work: thats basically the platform that bitC targeted
11:44:05 <dolio> > let shown :: Show x => Int -> x -> String ; shown 0 x = show x ; shown n x = shown (n-1) (x,x) in (shown 5 'c', shown 6 'c')
11:44:07 <lambdabot>   ("((((('c','c'),('c','c')),(('c','c'),('c','c'))),((('c','c'),('c','c')),((...
11:44:31 <dolio> Obviously n can be read in at runtime.
11:44:48 <dolio> So you need to be able to construct an arbitrary dictionary at runtime.
11:45:06 <edwardk> peaker: nice thing about having dolio around is my examples construct themselves ;)
11:47:15 <Cale> Ah, polymorphic recursion :)
11:48:09 <edwardk> peaker: in any event, you can get by by constructing said dictionaries on the stack... right up until you need an existential container for one.
11:48:31 <edwardk> so typeclasses and polymorphic recursion are probably mutually exclusive in this environment
11:48:33 <Peaker> edwardk: Hmm.. I'm still digesting that one :)
11:49:16 <edwardk> you can probably work with modules and explicit module construction though
11:49:31 <mm_freak_> any easy way of format-printing an Int to a ByteString?
11:49:39 <mm_freak_> without printf, that is
11:50:08 <edwardk> pack . show ?
11:50:14 <mm_freak_> formatted printing
11:50:20 <mm_freak_> like printf "%03i"
11:50:40 <dolio> I should add more integral formatting stuff to bytestring-show.
11:50:54 <mm_freak_> yeah, that would be useful
11:51:03 <dolio> What does %03i do?
11:51:06 <mm_freak_> ByteStrings should be better supported in general
11:51:15 <mm_freak_> 3 → "003"
11:51:19 <mm_freak_> 50 → "050"
11:51:19 <dolio> Ah.
11:53:12 <trofi> 5000 -> 5000 :]
11:53:17 <edwardk> i admit i'd stick to pack . printf "%03i" ;)
11:53:54 <trofi> @hoogle sprintf
11:53:54 <lambdabot> No results found
11:54:06 <roconnor> @hoogle printf
11:54:06 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
11:54:06 <lambdabot> module Text.Printf
11:54:06 <lambdabot> package printf-mauke
11:54:13 <MyCatVerbs> trofi: there's printf, in Text.Printf.
11:54:20 <edwardk> oh, bytestring-show is cute
11:54:26 <trofi> yes i know, thanks
11:54:45 <edwardk> is there a bytestring-read? =)
11:55:04 <MyCatVerbs> And there are PrintfType instances for both String and IO (), so no need to have sprintf seperately.
11:55:12 <edwardk> and text-show ? =)
11:55:34 <trofi> > B.pack "123"
11:55:35 <lambdabot>       Failed to load interface for `B':
11:55:35 <lambdabot>        Use -v to see a list of the fi...
11:55:54 <trofi> > ByteString.pack "123"
11:55:55 <lambdabot>       Failed to load interface for `ByteString':
11:55:55 <lambdabot>        Use -v to see a list ...
11:56:02 <dolio> dons has a bytestring-lex or something, although that's not very fleshed out.
11:56:33 <dolio> Just does doubles or something.
11:56:44 <edwardk> i am somewhat curious if Get used in Data.Bytestring would be more efficient CPS'd ala monad-ran
11:56:50 <edwardk> er Data.Binary i mean
11:57:11 <Peaker> edwardk: another note: Allocations of a static size can be allocated/freed from a memory pool in O(1), not necessarily the stack
11:57:25 <Peaker> edwardk: why is an existential container a problem?
11:59:34 <Peaker> edwardk, dolio: type-class-free polymorphic recursion (just a one-to-one translation of dolio's example): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4845#a4845
12:00:23 <Peaker> edwardk: the tuple building is already happening on the stack -- why is it a problem that the vtable is also built on the stack?
12:01:15 <dolio> That's pretty much what happens internally.
12:01:22 <dolio> Your translation, that is.
12:02:02 <Peaker> well, I don't see why its a problem when bolting type-classes to a language with no GC though -- the allocation of the new tuple requires space, so you've already solved the problem of the required space (and it has the same life time)
12:02:19 <edwardk> well, tuple building is an effect that you need to control here as well, constructing a value of type Show' a boxes up an arbitrary environment implicitly in the function, so you need memory allocation
12:03:19 <edwardk> peaker: and the problem bitc tries to address is that they need the ability to have large chunks of code that execute in strictly bounded space in a systems programming setting
12:03:38 <edwardk> which is hard with implicit dictionary construction and partial application allocating memory behind your back
12:03:52 <edwardk> i don't like shap's conclusion, but i can't really argue against it ;)
12:04:28 <Peaker> edwardk: well, its relatively easy to make stack allocations bound
12:05:05 <edwardk> you can work entirely on the stack if you go call-by-name, and ditch call-by-need but thats a rather ugly systems language
12:05:34 <edwardk> (or you can go call-by-value like everyone else)
12:05:35 <Peaker> edwardk: If dictionary construction only happens along with value construction - just associate them together.  Its silly to give up type-classes and not give up arbitrary value construction on the stack
12:06:20 <edwardk> i may need a dictionary in response to a value that i have, not to one i'm constructing. you may need the dictionary to interpret a value, not while constructing it
12:07:14 <Peaker> edwardk: I think for a systems language you want strict evaluation
12:07:17 <edwardk> and the need for an arbitrarily complicated dictionary can accumulate through merely calling a function polymorphically
12:07:28 <edwardk> most people would agree =)
12:07:36 <Peaker> edwardk: you can always get the dict from whoever gave you the value
12:07:47 <edwardk> i still think its funny that i've been able to show you can run wait-free algorithms lazily though =)
12:08:18 <edwardk> so if you work with wait-free or lock-free queues, etc. in the system you _could_ run the core system functions lazily =)
12:09:00 <edwardk> peaker: there is an expression problem there, because now you need to know about every instance that can be constructed for a value. you don't have type classes. you have classes.
12:09:30 <edwardk> now multiple dispatch, MPTCs, etc. are out
12:09:48 <Peaker> edwardk: why? if my type has Show a => .. the guy who calls me with an a is responsible to build the vtable for me?
12:09:57 <taggadtyp> so no way to do postfix?
12:09:57 <taggadtyp> 5 ! -> 120
12:09:57 <taggadtyp> ?
12:10:22 <edwardk> peaker: what about a more complicated typeclass class Foo a b
12:10:23 <jmcarthur_work> i thought there was an extension for that
12:10:23 <dolio> There's a GHC extension, but it's not great.
12:10:29 <dolio> You'd have to write (5!)
12:10:33 <Gracenotes> > let (!) n = product [1..n] in (5!)
12:10:35 <lambdabot>   120
12:10:44 <Peaker> edwardk: what about it?
12:10:54 <Gracenotes> > let (!) n = product [1..n] in (id 5!)
12:10:55 <lambdabot>   120
12:10:55 <jmcarthur_work> > let (n!) = product [1..n] in (5!)
12:10:56 <lambdabot>   <no location info>: Parse error in pattern
12:11:00 <jmcarthur_work> aw
12:11:06 <Gracenotes> > let (!) n = product [1..n] in (3+5!)
12:11:07 <lambdabot>       The operator `!' [infixl 9] of a section
12:11:07 <lambdabot>          must have lower prece...
12:11:26 <edwardk> peaker: if it has a recursive construction on both a and b i would have to construct an infinite number of such dictionaries to pass it to you along with my a or to pass it to you along with my b!
12:11:37 <Gracenotes> so you do need parens around the whole thing: (x!). And you may need addition parens like ((x)!) if x is a complicated expression
12:11:58 <Peaker> edwardk: ah, you mean if I use polymorphic calls?
12:12:26 <Peaker> edwardk: Can you write the example? I'm not sure I understand
12:12:42 <Peaker> edwardk: I don't see why multi-param type-classes are different here
12:13:01 <taggadtyp> (5!) doesnt work in ghci
12:13:24 <jmcarthur_work> requires an extension
12:14:34 <edwardk> i mean that if you have a dictionary that has a value for instance Reducer Foo Bar -- and instance Reducer d c => Reducer d (Maybe c)  -- and you call me with a Foo you need to pass me a dictionary that can handle Maybe (Maybe (.... Bar))
12:14:44 <edwardk> peaker: no 'one value' determines the shape of the dictionary
12:14:51 <edwardk> i need recursion on both parameters
12:16:04 <edwardk> if you try to make it so that you pass me the dictionary with the maybe tower, what happens when the other parameter varies?
12:17:46 <edwardk> taggadtyp: compile with -XPostfixOperators
12:19:21 <jthing> Does anyone here have any experience with 'litterate Haskell'?
12:19:34 <Gracenotes> or -fglasgow-exts
12:19:45 <jthing> alla Donald Knuth.
12:19:59 <vixey> that Knuth guys a looney
12:20:02 <taggadtyp> unrecoged pragma
12:20:33 <edwardk> yeah, i mean have you ever tried to read MMIX code? =)
12:20:44 <kyevan> Knuth's insane, sure.
12:20:54 <kyevan> But he's also brilliant.
12:20:55 <jthing> yes, I like Knuth
12:21:02 <kyevan> Kinda like a mad scientist :P
12:21:47 <jthing> Kinda into reating TAoCP
12:22:18 <loop> reating?
12:22:21 <Gracenotes> taggadtyp: -XBlah as a compile option; plain Blah as a pragma, comma-separated
12:22:29 <jthing> Nice to see programming from a mathematicians perspective
12:23:48 <jthing> s/reating/reading/
12:32:07 <skorpan> is there any list of extensions related to typeclasses that i can take a look at?
12:36:35 <edwardk> skorpan: http://haskell.cs.yale.edu/ghc/docs/6.10-latest/html/libraries/Cabal/Language-Haskell-Extension.html -- most of them deal with typeclasses anyways ;)
12:37:15 <skorpan> that's very nice but i have no idea what each of them does :)
12:37:19 <skorpan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4846#a4846 <- this is my problem
12:37:23 <mm_freak_> one thing i like about String is pattern matching…  is there an elegant way of doing this with ByteString?
12:37:30 <skorpan> i'd like to know if there's any extension which allows what i'm trying to do there
12:37:36 <mm_freak_> pseudo-code:  blah (pack "x") = X
12:37:56 <skorpan> uh, i realize the question is about unclear
12:37:56 <edwardk> mm_freak: view patterns
12:38:07 <skorpan>  Couldn't match expected type `t' against inferred type `Token' `t' is a rigid type variable bound by the type signature for `hasFailed'
12:38:09 <edwardk> blah (unpack -> "x") = X
12:38:21 <skorpan> that's the problem i'm trying to solve with an extension
12:39:10 <mm_freak_> edwardk: interesting…  unfortunately the haskellwiki doesn't seem to work
12:39:14 <mm_freak_> ah, now it works =)
12:39:39 <edwardk> erm Tok Token has kind *, Failable expects an argument of kind * -> *.
12:40:24 <skorpan> edwardk: i understand that, but i only want to instantiate Failable for Tok Token
12:40:39 <edwardk> skorpan: then you need to change the definition of Failable =)
12:40:54 <edwardk> i.e. you could change the signature to an MPTC instead
12:41:11 <skorpan> mptc?
12:41:14 <edwardk> class Failable f t | f -> t where stupid :: t -> f; hasFailed :: f -> Bool
12:41:23 <skorpan> oh
12:41:35 <mm_freak_> well, unfortunately view patterns completely destroy the performance of ByteString, so i'll go with guards =)
12:41:39 <edwardk> and then define instance Failable (Tok Token) Token -- and instance Failable (Block t) t
12:41:47 <edwardk> multi-parameter typeclass
12:41:52 <edwardk> mm_freak_: heh
12:42:26 <skorpan> edwardk: interesting
12:42:46 <skorpan> seems to work actually, thanks a lot!
12:43:22 <edwardk> your problem is that you can't meet your definition of Failable with your old signature for Tok Token -- stupid/hasFailed have to work regardless of the type 't' involved
12:43:40 <edwardk> and your definition for HasFailed required t = Token for the Failable case you cared about
12:43:50 <mm_freak_> there should be a class for string-like types
12:43:57 <mm_freak_> and a fromString function in it
12:44:03 <edwardk> mm_freak_: IsString?
12:44:12 <mm_freak_> huh?
12:44:21 <edwardk> look at Data.String and use -XOverloadedStrings
12:44:47 <mm_freak_> great!
12:44:50 <mm_freak_> thanks =)
12:44:52 <edwardk> it lets you use "" sugar for constructing non-strings.
12:45:19 <mm_freak_> can i expect to find it in haskell'?
12:45:53 <edwardk> mm_freak: probably not
12:45:57 <edwardk> haskell' is pretty conservative
12:46:04 <cocopumpkin> :(
12:46:09 <cocopumpkin> I wish it were adventurous
12:46:09 <mm_freak_> yeah, i figured
12:46:15 <cocopumpkin> how does one start a new standard? :P
12:46:25 <mm_freak_> cocopumpkin: make Succ Haskell =)
12:46:38 <mm_freak_> well, Succ (Succ Haskell) that is
12:46:40 <edwardk> cococopumpkin: implement it
12:47:02 <cocopumpkin> edwardk: it'd amount to writing a new stdlib, with a rationale document, and a set of extensions that I think should be standard?
12:47:06 <edwardk> i actually want features from pred (Haskell 98) -- i.e. monad comprehensions, no fail...
12:47:15 <mm_freak_> data HaskellStandard = ExtremelyConservative | Succ HaskellStandard
12:47:34 <cocopumpkin> my main beef is with the various basic typeclasses, and I'd like a few extensions to be standard
12:47:41 <mm_freak_> edwardk: i like fail
12:47:44 <cocopumpkin> I could stop bitching and start implementing
12:47:50 <mm_freak_> i'm using it quite often
12:47:54 <jmcarthur_work> fail should be in a separate type class
12:47:57 <jmcarthur_work> not in monad
12:47:57 <edwardk> mm_freak: if you 'fix the Succ' i'd be willing to work in that language =)
12:48:03 <cocopumpkin> mm_freak_: I'm fine with fail, but in its own typeclass
12:48:11 <Cale> I never ever ever use fail
12:48:14 <edwardk> mm_freak_: i'm ok with you using it, just get it out of my Monad =)
12:48:15 <jmcarthur_work> nor do i
12:48:16 <cocopumpkin> like MonadZero, or MonadFail
12:48:19 <cocopumpkin> or EpicFail
12:48:21 <hatds> fail sucks
12:48:22 <Cale> I pretend that it doesn't exist.
12:48:23 <hatds> :)
12:48:29 <jmcarthur_work> EpicFail
12:48:30 <mm_freak_> why?  i use it precisely for pattern matching failures in do-notation
12:48:34 <jthing> EpicFail? lol
12:48:41 <mm_freak_> and that's strictly monadic =)
12:48:50 <cocopumpkin> mm_freak_: you'd just describe do notation as requiring a (EpicFail m, Monad m) => m x
12:48:52 <edwardk> mm_freak_: because it is infectious. for instance Either would be a perfectly good Monad without the !*@)(#*)! Error constraint.
12:48:53 <cocopumpkin> instead of just Monad
12:48:54 <Cale> mm_freak_: But not every monad properly supports failure.
12:49:09 <Cale> mm_freak_: It was a mistake to include it in the monad class.
12:49:11 <edwardk> except they made the Error constraint in order to satisfy fail.
12:49:13 <mm_freak_> cocopumpkin: then you'd have all Monads also be Fails
12:49:30 <jmcarthur_work> mm_freak_, only those for which it makes sense to use do notation anyway
12:49:37 <mm_freak_> Cale: i'm fine with exceptions as the default behaviour
12:49:46 <Cale> I think it's bad.
12:49:56 <mm_freak_> well, i use it mostly with Maybe and []
12:49:57 <cocopumpkin> mm_freak_: not all
12:49:58 <mauke> mm_freak_: I don't think error is proper exceptions
12:50:03 <edwardk> i'm with cale on this one. even if he's a little crazy about fmap as (.) ;)
12:50:16 <Cale> I liked the Haskell 1.4 way.
12:50:25 <Cale> I don't see why they changed that.
12:50:28 <mm_freak_> actually i'd like (.) = fmap, too
12:50:38 <dolio> Bring back the unfailable patterns.
12:50:46 <cocopumpkin> we should actually see if we can pull together enough people to make a new standard?
12:50:53 <roconnor> ooh
12:50:54 <cocopumpkin> beyond haskell'
12:50:54 <mm_freak_> well…  even more:  i'd like to get rid of 'map' and rename 'fmap' to 'map'
12:50:58 <mm_freak_> and then (.) = map
12:50:59 <roconnor> are we making a new standard?
12:50:59 <mm_freak_> =)
12:51:07 <Cale> Right, the translation of do-notation depended on whether the pattern could fail to match
12:51:12 <vixey> yes
12:51:16 <Cale> and it influenced the type of the do-block
12:51:18 <cocopumpkin> roconnor: well, as it stands, I think we're mostly GHC programmers more than haskell (as in h98) programmers
12:51:21 <edwardk> mm_freak_: and mplus to (++) etc. the monomorphization of 98 was evil
12:51:24 <cocopumpkin> or do people make an effort to stick to h98
12:51:27 <vixey> we can call it Haskell#
12:51:32 <Cale> I think we should fix this in GHC.
12:51:36 <edwardk> vixey: hahaha
12:51:44 <Taejo> roconnor: yes, we're making a new language... gotta avoid success
12:51:45 <edwardk> or just #haskell =)
12:51:46 <mm_freak_> edwardk: yeah
12:52:02 <cocopumpkin> I think do should have Monad and Fail constraints
12:52:03 <Cale> edwardk: Though, I think I would prefer to steal ++ for monoids now :)
12:52:11 <cocopumpkin> Cale: damn right!
12:52:14 <Taejo> Haskell#, pronounced Haskell Unboxed
12:52:15 <roconnor> there is already "the other prelude"
12:52:17 <edwardk> cale: bah, that should clearly just be (+) =)
12:52:20 <hatds> do doesn't require fail though
12:52:20 <vixey> the first thing is fix typeclasses
12:52:24 <cocopumpkin> roconnor: yeah, but that's not as broad
12:52:24 <Cale> But we should have an infix notation for mplus
12:52:26 <cocopumpkin> vixey: agreed
12:52:29 <vixey> we'd need a CHR guru or something
12:52:33 <Cale> No, (+) is too numeric
12:52:36 <mm_freak_> edwardk: that wouldn't work, unfortunately
12:52:52 <taggad_typ_> > (+1) &&& (^3) $ (1,2)
12:52:53 <roconnor> can we make the labels in record fields be accessor functions rather than projection functions?
12:52:57 <jmcarthur_work> how is it too numeric?
12:52:57 <edwardk> mm_freak: the (+) for monoids? i use it all the time
12:52:58 <lambdabot>       No instance for (Num (t, t1))
12:52:59 <taggad_typ_> > (+1) &&& (^3) $ (3
12:52:59 <lambdabot>        arising from the literal `1' at <i...
12:53:00 <lambdabot>   <no location info>: parse error on input `;'
12:53:06 <mm_freak_> but we could get rid of (+) and rename mappend to (+)
12:53:07 * jthing takes a beer. Too racy for me
12:53:09 <jmcarthur_work> + is perfect for monoids
12:53:10 <taggad_typ_> > (+1) *** (^3) $ (3
12:53:11 <lambdabot>   <no location info>: parse error on input `;'
12:53:14 <taggad_typ_> > (+1) &&& (^3) $ (3
12:53:15 <lambdabot>   <no location info>: parse error on input `;'
12:53:15 <hatds> gah records.. remove them for Haskell# I say :)
12:53:19 <Cale> Well, I tend to expect something called (+) to be commutative, for one.
12:53:28 <Cale> Which most monoids are not...
12:53:30 <mm_freak_> edwardk: ah ok, you were talking about monoids anyway =)
12:53:36 <mm_freak_> i was still at mplus
12:53:41 <edwardk> import Data.Monoid.Sugar  =)
12:53:48 <ray> (+) could be in the AbelianGroup class
12:53:59 <ray> i liked that idea
12:53:59 <dolio> Plus is commutative, but double plus isn't? :)
12:54:02 <jthing> ah, good point
12:54:05 <Cale> dolio: right.
12:54:11 <jthing> Ablian groups
12:54:12 <ray> (++) already isn't commutative
12:54:15 <edwardk> cale: unfortunately i work in enough semirings, etc. that the commutativity of (+) is pretty far down its list of traits for me
12:54:16 <mm_freak_> CommutativeMonoid rather than AbelianGroup
12:54:21 <taggad_typ_> > (+1) &&& (^3) $ (3)
12:54:21 <taggad_typ_> > (+1) &&& (^3) $ 3
12:54:21 <cocopumpkin> I dunno, maybe we should start a wiki page for people to put their names on, expressing interest in starting a new standard?
12:54:23 <lambdabot>   (4,27)
12:54:24 <lambdabot>   (4,27)
12:54:25 <mm_freak_> i don't want to require all numeric types to have inverses ;)
12:54:35 <jthing> Like in axiom fully toplogical type qualifiers
12:54:40 <jmcarthur_work> i'm up for it
12:54:45 <ray> yeah, details like that can be hashed out
12:54:58 <Cale> edwardk: (+) is commutative in a semiring...
12:55:09 <jmcarthur_work> an idealized standard rather than a practical one ;)
12:55:12 <edwardk> cale: and since a right seminearring is basically the Monoidal equivalent of Alternative there is something to be said for * and + to go with <*> and <|>  (or <+>)
12:55:13 <mm_freak_> get (*) out of Num, too
12:55:17 <cocopumpkin> jmcarthur_work: that's fine
12:55:20 <cocopumpkin> mm_freak_: hear, hear
12:55:35 <mm_freak_> class Group g => Ring g where …
12:55:36 <jmcarthur_work> Num should only be for fromIntegral, nothing else
12:55:38 <cocopumpkin> idealized is good :P then we can maybe cut back to make it work
12:55:41 <mm_freak_> uhm
12:55:49 <mm_freak_> class (Monoid m, Group g) => Ring m g where …
12:55:50 <Cale> We need class aliases
12:55:59 <Taejo> regarding do notation, why don't we just make it desugar to (>>=), (>>) and fail without requiring those to have any particular type?
12:55:59 <jmcarthur_work> other arithmetic can be done with rings, fields, etc.
12:56:00 <Cale> If we're going to have such a fine hierarchy.
12:56:01 <edwardk> er seminearring
12:56:07 <roconnor> sounds like 90% of this is covered by the other prelude
12:56:18 <mm_freak_> however, that discussion doesn't help =/
12:56:20 <cocopumpkin> roconnor: the numeric one?
12:56:21 <dolio> What's the other prelude?
12:56:30 <roconnor> cocopumpkin: no, the other one
12:56:34 <Cale> It's annoying how everyone wants changes like this, but nothing is being done.
12:56:35 <jmcarthur_work> the numeric prelude i think is crippled due to the way haskell works right now, though. it could be much nicer
12:56:37 <cocopumpkin> hm
12:56:43 <edwardk> numeric prelude has been thieleman'd
12:56:43 <mm_freak_> Cale: indeed
12:56:48 <roconnor> http://www.haskell.org/haskellwiki/The_Other_Prelude
12:56:49 <cocopumpkin> Cale: I'd be willing to actually put some pressure and work into it :P
12:56:59 <jmcarthur_work> oh _other_... which i haven't looked at much
12:57:03 <cocopumpkin> but it would definitely take a lot more people than me
12:57:10 <hatds> I don't think rewriting the numeric typeclasses in terms of group and monoid is a good idea
12:57:22 <jmcarthur_work> hatds, why not?
12:57:30 <mm_freak_> i think it would be best to fork off some sister project from haskell
12:57:32 <jmcarthur_work> hatds, it's not like we are looking for success ;)
12:57:32 <cocopumpkin> I think it is
12:57:37 <hatds> isn't a ring a monoid in two different ways?
12:57:46 <jmcarthur_work> newtype
12:57:58 <jthing> hatds: no
12:58:06 <Cale> Actually, I think that calling it Additive and Multiplicative is perhaps a little more accurate
12:58:11 <edwardk> cale: i tend to operate under the model that (+,0) is a monoid, where i might want to build (*) over it with a cancellative 0.
12:58:12 <hatds> jthing: + and *, no?
12:58:19 <cocopumpkin> roconnor: it could be built on top of the other prelude, with the goal of making a new standard rather than just a library
12:58:36 <jthing> hatds: It is not onto
12:58:38 <mm_freak_> hatds: a ring is a group with an additional monoidic operation and an additional distributive law
12:58:42 <taggad_typ_> wow fortress looks terrible at a superficial look
12:58:45 <Cale> The problem with terms like Ring is that they don't apply to many sorts of numbers we actually might want to use, like floating point.
12:58:49 <edwardk> cale: yeah, i wouldn't mind replacing Monoid with 'Additive' -- i already use Multiplicative for the multiplicative form of them
12:58:54 <mm_freak_> (ℤ,+) is a group, (ℤ,+,*) is a ring
12:59:00 <Cale> If you're going to use the terms, you should use them correctly :)
12:59:08 <hatds> mm_freak: and a group is a monoid with inverses
12:59:12 <edwardk> yeah you need PseudoRing/PseudoField, etc.
12:59:13 <Cale> Which means that the laws should hold :)
12:59:14 <cocopumpkin> Cale: IEEERingOfFail
12:59:24 <ray> RingOfDeath
12:59:30 <Cale> ApproximateRing ;)
12:59:32 <jmcarthur_work> i agree. that's why i wouldn't prefer not to have floating point be an instance of things for which it would break laws
12:59:39 <jthing> hatds: Unless you accept the subset of the modular group
12:59:40 <jmcarthur_work> *would prefer not
12:59:45 <edwardk> in kata i call ones where you know the laws hold 'optimized foo' as opposed to a 'foo' =)
12:59:52 <mm_freak_> hatds: yes, but monoids are too general
12:59:57 <taggad_typ_> someone mention n ineresting mathematical concept that i should implement
12:59:58 <roconnor> mm_freak_: is (ℤ,+,-,0,*,1) a ring or is it ((ℤ,+,-,0),*,1) that is a ring?
13:00:00 <Cale> jmcarthur_work: Which is why having a Group class is sort of a bad idea.
13:00:01 <mm_freak_> you _need_ a group
13:00:04 <taggad_typ_> maybe something in topology
13:00:19 <Cale> But "Additive" and "Multiplicative" don't mean anything except that a particular notation is used
13:00:19 <mm_freak_> roconnor: what's the difference?
13:00:24 <Cale> Which is why I'd prefer them.
13:00:25 <edwardk> an optimized functor knows its category, a functor does not which lets me define an unindexed category of categories with functors as arrows, but doesn't let me optimize using the functor laws without being more explicit
13:00:32 <roconnor> or is it (((ℤ,+),-,0),*,1) that is a ring?
13:00:49 <Cale> Actually, if it was me, I would do a far less radical reform of the numeric hierarchy.
13:00:56 <roconnor> mm_freak_: the structures are superficially different
13:01:05 <Cale> I think I would still have a Num with (+) and (*) and fromInteger
13:01:08 <mm_freak_> ((((ℤ),+),0),*,1)
13:01:09 <jmcarthur_work> class LawlessGroup g => Group g where
13:01:10 <jmcarthur_work> :P
13:01:13 <Cale> and negate
13:01:21 <edwardk> then you can add Ringoid r, for (Additive r, Multiplicative r) -- perhaps implying cancellative 0, and then build left and right seminnearrings off of that
13:01:27 <mm_freak_> set → semigroup → group → ring
13:01:28 <mm_freak_> =)
13:01:44 <Cale> Fine class hierarchies are too annoying at present.
13:01:46 <roconnor> you left out monoid
13:01:47 <ray> i'd make floats second class citizens, which is why you shouldn't let me write your numeric classes
13:01:51 <mm_freak_> ok…
13:01:53 <thoughtpolice> hm...
13:01:59 <jmcarthur_work> i would be with ray
13:02:00 <mm_freak_> (((((ℤ),+),0),-),*,1)
13:02:07 <mm_freak_> set → semigroup → monoid → group → ring ;)
13:02:13 <thoughtpolice> so, I built the latest GHC head+dph and re-ran the version of binarytrees I converted to DPH
13:02:17 <ziman> monoid /= semigroup ?
13:02:23 <Cale> I don't think the mathematical abstractions are useful here.
13:02:33 <jthing> mm_freak_: that's right
13:02:42 <hatds> Cale: I agree
13:02:42 <jmcarthur_work> i also think Int should be given a good treatment
13:02:45 <Cale> There are too many practical aspects of computing with numbers that *must* be dealt with.
13:02:48 <mm_freak_> actually not entirely
13:02:51 <mm_freak_> that's already a field
13:02:54 <roconnor> can we give Haskell# formal semantics?
13:03:00 <mm_freak_> ((((((ℤ),+),0),-),*),/,1)
13:03:02 <thoughtpolice> turns out that compared to 6.10.1 there is a nice drop in GC time (11.9% -> 3.4%) but runtime doesn't decrease any, although system usage stays about 180% which is nice
13:03:08 <mm_freak_> set → semigroup → monoid → group → ring → field
13:03:14 <thoughtpolice> then again I build HEAD with different build settings...
13:03:18 <jmcarthur_work> Haskell# makes me think of everything being unboxed
13:03:25 <mm_freak_> but of course ℤ is not a field =)
13:03:26 <roconnor> :D
13:03:30 <ray> just haskell is unboxed
13:03:32 <mm_freak_> ((((((ℚ),+),0),-),*),/,1)
13:03:36 <ziman> ah, semigroup doesn't have unit
13:03:47 <jthing> mm_freak_: That's wrong a filed is a subset of a group
13:03:49 <roconnor> I can see the poster: Haskell ... unboxed
13:03:53 <roconnor> live
13:03:54 <edwardk> mm_freak: the problem is there are some cases where you also want the multiplicative branch without the additive monoid. a good example is that you can make any applicative wrapped around a monoid into a seminearring
13:03:57 <jthing> field
13:04:01 <Cale> jmcarthur_work: That reminds me of the language I was going to create for the .NET runtime called MutVar#
13:04:08 <ray> and a picture of a cardboard box with light streaming out of it
13:04:22 <mm_freak_> edwardk: class MultiplicativeSubgroup
13:04:24 <Cale> It would be a big hit, don't you think?
13:04:34 <jthing> mm_freak_: See noedlers theorem
13:04:36 <roconnor> ray: maybe will a star on the side of the box
13:04:43 <mm_freak_> jthing: huh?
13:04:43 <roconnor> will/with
13:04:45 <hatds> Is there really any reason we need numeric typeclasses to do double duty with applicative functors or whatever?
13:04:57 <Tobsan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4847#a4847 is this the best way to get input as a lazy list?
13:05:01 <jmcarthur_work> double duty?
13:05:09 <jthing> mm_freak_: That's wrong a field is a subset of a group
13:05:10 <edwardk> you might also choose to lift the monoid into the applicative ala the applicative instances module that conal wrote, which works slightly differently. in some cases you'll have multiplication without addition if Alternative/MonadPlus isn't present
13:05:16 <Tobsan> feels extremely unneccesary with all these unsafeInterleaveIO calls
13:05:28 <hatds> jmcarthur_work: if you restructure the numeric classes around monoid and group
13:05:29 <edwardk> hatds: the kind system =)
13:05:31 <Cale> Tobsan: hmm?
13:05:37 <jthing> mm_freak_: See noedlers theorem
13:05:43 <Peaker> edwardk: but why do I need to pass you the maybe tower? if you're constructing the maybe wrappers -- you can construct the vtables too
13:05:45 * cocopumpkin coughs: http://www.haskell.org/haskellwiki/UnnamedStandard
13:05:49 <Tobsan> Cale: I need to have the input handling passed to me as a lazy list
13:05:56 <Cale> Tobsan: ah, I see
13:06:00 <cocopumpkin> let's see if we can get anyone interested
13:06:06 <mm_freak_> jthing: AFAIK a field is a ring, where * without 0 makes a group
13:06:07 <Tobsan> so when there is an event, i want it to be reported, otherwise not
13:06:13 <Cale> Tobsan: I was going to ask whether you know about getContents, but now that I see your paste...
13:06:25 <edwardk> peaker: ok, but now what happens when i recurse on the _other_ side? you can't have it both ways =)
13:06:31 <Cale> Tobsan: you do certainly need unsafeInterleaveIO to accomplish that.
13:06:47 <roconnor> the problem with group -> ring is that general groups  are not commutitive and use *, while the group in rings is commutative and use +.  But you cannot change function names like that in Haskell typeclasses
13:07:05 <Tobsan> Cale: yes, but at every recursive call? I tried replacing the do block with a recursive function, and then it didnt work
13:07:05 <jthing> mm_freak_: A group is a more general structure than a ring
13:07:05 <Cale> Tobsan: Is there a particular reason that you're sticking all those Nothings in the list?
13:07:27 <Peaker> edwardk: no no -- the guy who is changing the type is certainly changing the value too -- so he's allocating new values, why can't he allocate the new vtables too?
13:07:29 <Tobsan> Cale: yes, the list is part of a simulation, where at each step one element in the list is consumed
13:07:30 <mm_freak_> jthing: in that sense a ring is a group, yes
13:07:42 <cocopumpkin> whee, jmcarthur_work has joined!
13:07:54 <edwardk> instance Foo Bar Baz; instance Foo a b => Foo [a] (Maybe b); instance Foo a b => Foo (Maybe a) (Maybe b); instance Foo a b => Foo [a] [b]; instance Foo (Maybe a) [b]
13:08:04 <mm_freak_> and a field is a group, too, of course with a multiplicative subgroup
13:08:24 <Tobsan> Cale: so unless a key is pressed, the simulation continues as normal
13:08:32 <edwardk> i give you an arbitrary tower of lists and maybes and another arbitrary tower of lists and maybes neither one is sufficient to handle all of your allocation needs a priori
13:08:42 <Cale> Peaker: What is a vtable?
13:08:45 <Tobsan> but if there is a key, it will affect the simulation in some ways, depending on what key it is
13:08:55 <jthing> mm_freak_: So any Ablian GROUP isalso a FEILD, not just rings
13:08:55 <edwardk> er pretend that last one was instance Foo a b => Foo (Maybe a) [b]
13:09:10 <Peaker> Cale: a dictionary/record of functions, implementing a type-class
13:09:13 <cocopumpkin> anyone else wanna put their name down, or any suggestions? I just wanted to stop bitching about the current standard and put a solid page down somewhere as a start of "doing something about it"
13:09:20 <cocopumpkin> (http://www.haskell.org/haskellwiki/UnnamedStandard)
13:09:21 <Cale> Peaker: Oh, normally that's called a dictionary.
13:09:26 <jmcarthur_work> we need to fix type classes first before we even bother discussing the type class hierarchy, perhaps
13:09:31 <jthing> mm_freak_: See noedlers theorem, again
13:09:43 <Peaker> Cale: vtable is shorter :)  also, outside the Haskell community, its more commonly known as a vtable, though
13:09:50 <ray> class aliases?
13:09:51 <edwardk> cocopumpkin: i'm pretty much acceptive of the fact that there are sound enough arguments against changing that folks can rationalize maintaining the status quo
13:09:59 <Peaker> jmcarthur_work: what's the problem that needs fixing?
13:10:09 <edwardk> peaker: vtable has other connotations that don't apply to haskell dictionaries though
13:10:15 <mm_freak_> jthing: i'm unable to find it anywhere
13:10:31 <Peaker> edwardk: what are they?
13:10:33 <cocopumpkin> edwardk: there are always arguments for not changing :P doesn't stop us from pushing for change
13:10:52 <Cale> Hey, actually, I wonder...
13:10:54 <hatds> problem is that we won't even come close to a consensus
13:11:00 <edwardk> peaker: it implies that you store the pointer to the vtable IN the object in question, and that it only varies on a single 'axis' with respect to one parameter. a multiparameter type class violates both of these assumptions
13:11:09 <cocopumpkin> hatds: doesn't stop us from trying :P
13:11:09 <edwardk> especially when its defined for Int, etc. =)
13:11:27 <Cale> If we had class aliases, is it possible that we could write a good prelude with finer classes and then a compatibility prelude on top of it?
13:11:37 <mm_freak_> jthing: however, what was wrong about my statement?  any field is a ring is a group
13:11:38 <Cale> (assuming that we didn't want to reuse the class names)
13:11:39 <Peaker> Haskell 1.4 used to have Monad separately from MonadFail - and "do" used Monad until non-exhaustive pattern-matches were used, and then it used MonadFail?
13:11:50 <Cale> Peaker: MonadZero actually
13:11:55 <ray> cale: that makes lots of sense
13:11:56 <cocopumpkin> anyway, I have to leave
13:12:05 <edwardk> cale: you need class aliases, superclass method overriding, and some mechanism for prioritizing such overrides.
13:12:06 <cocopumpkin> if you have arguments against the creation of a new standard, you might as well put those on the page too
13:12:12 <Peaker> Cale: so why did they mess the class hierarchy up? That doesn't sound like a newbie-unfriendly thing
13:12:41 <Peaker> edwardk: Nah, vtable doesn't have to be of an object at all
13:12:49 <edwardk> peaker: it was a newbie unfriendly thing, because adding a new constructor to a class could make formerly unfailing patterns fail
13:12:52 <Cale> Peaker: It was an avalanche of failure starting with the removal of monad comprehensions.
13:13:04 <jmcarthur_work> could we come up with a reasonable way to eliminate orphan instances and the globality of type classes? would be nice to be able to define an instance to a type class that is only local to a particular module, for example
13:13:11 <jthing> mm_freak_: neiher can I actually
13:13:15 <edwardk> and that could then cascade through the program requiring MonadFail annotations
13:13:33 <edwardk> because of destructuring assignment used inside of your monad sugar
13:13:35 <jthing> mm_freak_: That's wierd, let me look further
13:13:35 <Peaker> edwardk: I think that's a really strong argument in favor of separating type sums from type products
13:13:39 <skorpan> is there any well-known way to simulate heterogeneous lists in haskell?
13:13:44 <Peaker> edwardk: in which case, there's no need for "newtype" too
13:13:49 <thoughtpolice> skorpan: existentials
13:13:56 <Cale> When monad comprehensions (the monadic generalisation of list comprehensions) were removed, someone noticed "Hey, all we needed MonadZero for was to handle guards in monad comprehensions, and all our current instances of MonadZero are also instances of MonadPlus, so let's merge those!"
13:14:05 <edwardk> peaker: without newtype typeclasses are basically done for, anbd you're back to a module system
13:14:08 <ray> jmcarthur_work: hiding instances like you can hide other stuff
13:14:24 <jmcarthur_work> ray, yes
13:14:26 <hatds> you can hide instances... just don't import that module
13:14:39 <Peaker> edwardk: You misunderstood me -- if Haskell had separate type sums and type products, rather than ADT's, then type products could replace newtypes, as they'd not add bottoms
13:14:46 <Cale> and then someone else noticed that "Hey, now do-blocks will require MonadPlus if they pattern match against something which might fail, so that's not right. Let's change the way do-notation is translated, and add a mechanism for failure."
13:14:55 <sjanssen> hatds: or use a module that uses that module, etc.
13:14:56 <jthing> mm_freak_: What's wron is that a ring is a special case of a group, and that there are grops that have fields that are not rings
13:15:07 <jthing> wrong
13:15:13 <jmcarthur_work> hatds, C has an instance you don't want, B uses it, you use B in A, crap
13:15:13 <Peaker> Cale: :-(
13:15:17 <skorpan> thoughtpolice: that looks pretty easy, is it? :P
13:15:18 <Peaker> Cale: that's just wrong
13:15:18 <edwardk> jmcarthur_work: that would be downright handy, but its a pretty invasive change
13:15:32 <jmcarthur_work> edwardk, invasive is the name of the game ;)
13:15:35 <mm_freak_> jthing: then my maths book is wrong
13:15:36 <thoughtpolice> jmcarthur_work: what about having local instances for classes like UHC?
13:15:51 <sjanssen> jmcarthur_work: there are also concerns about safety, with Typeable, Storable, IArray, etc.
13:15:52 <taggad_typ_> why doesn't vim mode for haskell highlight function names?
13:15:54 <Cale> Haskell 98 is the Windows ME of Haskell standards.
13:15:57 <jmcarthur_work> haven't seen how UHC does it
13:16:00 <edwardk> jmcarthur: I asked dcoutts the same question the other day trying to figure out what the right solution would be to avoid such orphan problems for kata
13:16:05 <thoughtpolice> jmcarthur_work: http://www.cs.uu.nl/wiki/bin/view/Ehc/EhcUserDocumentation#3_6_Local_instances
13:16:18 <hatds> jmcarthur_work: there's a problem with the module structure of your program if that happens... if you import B then you can see functions overloaded on that new typeclass
13:16:22 <jmcarthur_work> brb
13:16:24 <thoughtpolice> skorpan: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
13:16:32 <Cale> Except that we got stuck with it for years.
13:16:34 <thoughtpolice> anyway, bbl
13:16:37 <edwardk> mainly  because given the way i use multiple inheritance based modules rather than typeclasses 'orphans' are terrifying to me in ways they aren't to haskell
13:16:45 <sgcummin> jthing: mm_freak_ every field is a ring
13:17:04 <edwardk> Haskell 98 is the Windows 98 of standards ;)
13:17:17 <ray> yeah, people still use it
13:17:22 <Cale> I suppose that works
13:17:23 <jthing> mm_freak_: perhaps
13:17:53 <gnuvince> edwardk: well, that's definitely going to be in the "quotes of the week" of the next Haskell Weekly News
13:18:00 <edwardk> hahaha
13:18:17 <roconnor> @remember edwardk Haskell 98 is the Windows 98 of standards ;)
13:18:17 <lambdabot> Nice!
13:18:20 <dolio> Peaker: Making products unlifted isn't a simple decision.
13:18:25 <bremner> edwardk: logically, whatever comes next is the Windows ME
13:18:26 <ray> hmm, having instance declarations in the middle of a let is cool but maybe too much
13:18:33 <roconnor> Haskell ME
13:18:34 <jthing> sgcummin: You obviously haven't studied general relativity..
13:18:40 <Peaker> dolio: why?
13:18:47 <ray> ideally, you want to come up with haskell NT
13:19:03 <solrize_> haskell a Vista baby
13:19:14 <gnuvince> If Haskell' is Windows ME, I'm walking out.
13:19:24 <sgcummin> jthing: my pardon, we're talking about the mathematical construct?
13:19:28 <Cale> Personally, I think the next unambitious standard should be called Haskell 1.6 and the next ambitious one should be Haskell 2
13:19:36 <jthing> sgcummin: Yes
13:19:42 <mm_freak_> jthing: it states:  given a ring R = (S,+,*,0,1), if (S\{0},*,1} is a submonoid, then R is a division ring, and further if that submonoid is a group, then R is a field
13:19:42 <ziman> maybe windows prime is yet about to come :)
13:19:47 <Cale> (obviously, Haskell 98 is really Haskell 1.5)
13:19:49 <ray> conservative version numbers
13:19:55 <ray> none of that marketing madness
13:20:13 <sgcummin> jthing: the axioms of a field are a super-set of those of a ring?
13:20:14 <wli> How is general relativity supposed to come into any of this?
13:20:16 <dolio> Peaker: It has consequences for how you're required to evaluate them, and such. Let me find a discussion with augustss takling about it, since I'm sure he's better at pointing out the subtleties than I'd be.
13:20:17 <hatds> Haskell 1.6 and 2.0 sounds part of the same chain though
13:20:24 <jthing> sgcummin: Yes
13:20:26 <Cale> They would be...
13:20:33 <mm_freak_> jthing: wikipedia confirms that, too
13:20:36 <edwardk> hrmm, i apparently never uploaded the version of monoids that included Data.Ring.Combinators.fromNatural
13:20:48 <ray> cale just means "use major and minor version numbers for what they're supposed to be used for"
13:20:49 <Cale> I'm thinking of Haskell 1.6 as sort of "What we're already using"
13:21:07 <Cale> Because nobody actually programs in Haskell 98
13:21:24 <mm_freak_> so every field is a group, but not every group is a field…  groups have only one operation anyway
13:21:28 <Peaker> dolio: I remember I read he wrote once that its a problem in case you introduce another data constructor -- but I think a type sum should be a separate primitive to a type product
13:21:30 <sgcummin> jthing: then, the aphysical construct that sometimes maps onto physical things, that we call a field, is a super set of the aphysical things we call rings
13:21:42 <edwardk> I think I may have written one program longer than 20 lines, ever, that would compile in Haskell 98 mode ;)
13:21:50 <sgcummin> unless I'm misunderstanding you
13:21:55 <jthing> sgcummin: groups..
13:22:04 <edwardk> mostly its {-# LANGUAGE oh no, not again #-}
13:22:09 <dolio> Peaker: For one, consider what bottom would be for products.
13:22:10 * wli just takes the variation of the Ricci scalar.
13:22:13 <Cale> Toward Haskell 2.0, we should fork the base library and start a new incompatible version of the universe.
13:22:16 <jthing> sgcummin: symetries that are someties rings
13:22:22 <jthing> sometimes
13:22:31 <mm_freak_> edwardk: my code is mostly h98
13:22:31 <jthing> lol
13:22:55 <mm_freak_> Cale: IO2?
13:22:57 <edwardk> cale: i think the problem is the lack of a coherent answer to the base class override/class alias issue
13:22:59 * wli wants monad comprehensions back for Haskell 2.
13:23:15 <mm_freak_> i don't like comprehensions much
13:23:20 <dolio> _|_ = (_|_, _|_), but (5, _|_) /= _|_ and (_|_, 5) /= _|_. So to decide whether you're allowed to hang or not, you need to be able to evaluate both pieces of a pair to find out if either is non-bottom.
13:23:20 <Cale> edwardk: But we have the class aliases proposal. Someone just needs to implement it and see how it works.
13:23:23 <mm_freak_> i prefer do-notation
13:23:33 <hatds> what's the difference between class alias and newtype?
13:23:57 <edwardk> i mean you can 'class alias' pretty easily in a limited sense. class (Return m, Bind m) => Monad m ; instance (Return m, Bind m) => Monad m -- but the need to override definitions from superclasses is the hard part
13:24:13 <Cale> mm_freak_: I like them sometimes. I think that comprehensions and do-notation should be almost equivalent -- except for the detail about guards
13:24:19 <edwardk> cale: iirc it didn't address a lot of the subtleties
13:24:20 <Peaker> dolio: why is it important that they have a bottom?
13:24:24 <ray> i've never seen a monad comprehension, i'm not old enough to haskell
13:24:36 <mm_freak_> ray: you see them all over
13:24:44 <mm_freak_> list comprehensions are a special case
13:24:45 <edwardk> going back to look at it to see what my laundry list of issues were
13:25:21 <wli> Please. Stop confusing him. Monad comprehensions were using what's now exclusively list comprehension syntax.
13:25:57 <Cale> Another thing which I think we really ought to do for Haskell 2 is adopt a system of extensible records and variants. I propose that it work like Daan's system but have a lensish syntax.
13:26:02 <mm_freak_> list comprehension:  [ a+1 | a <- [1..5], even a ] = [3,5];  monad comprehension:  [ a+1 | a <- Just 2, even a ] = Just 3
13:26:04 <wli> It used to be that that syntax was generalized to more general monads.
13:26:17 <hatds> I'm against extensible records, and I don't much like vanilla records
13:26:27 <ray> sounds useful enough
13:26:28 <edwardk> as i recall, MPTCs and class aliases interact in non-trivial ways. class (Foo a, Foo b)  => Bar a b -- if you class 'alias' there, which version of foo's foo method are you defining?
13:26:33 <mm_freak_> Cale: extensible?  for OOP?
13:26:33 <Cale> hatds: Why?
13:26:34 <wli> Cale: Extensible variants would help me a lot. Extensible records probably work for someone.
13:26:44 <vixey> hatds: what's bad about extensible records?
13:26:50 <Cale> mm_freak_: Not necessarily for OOP
13:27:01 <edwardk> er of Foo's foo method
13:27:10 <hatds> I can't find convincing examples of what extensible records are for
13:27:45 <Cale> There are a lot of practical applications where our best answer to how to solve them non-awkwardly in Haskell is effectively dynamic typing.
13:27:48 <edwardk> and it does not address the notion of a 'retroactive superclass', except by the library's maintainer.
13:27:59 <Cale> i.e. implement your own miniature dynamic type system
13:28:13 <skorpan> could someone help me understand this error message?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4848#a4848
13:28:21 <Cale> Usually, by using Data.Maps from keys to some big enough value type
13:28:41 <mauke> skorpan: line 1: 'a' is not a type
13:28:50 <edwardk> cale: i'm rather fond of extensible records/variants ala Blume's MLPolyR but i'm somewhat scared how well his unification scheme would merge with all the crazy wobbly type/type family stuff
13:28:52 <Peaker> dolio: Is it a bad idea to just not have: _|_ :: (a, b) ?
13:28:53 <mux> @pl f a b c d = g x (\e -> h e b c d)
13:28:53 <lambdabot> f = const ((((g x .) . flip) .) . flip . flip h)
13:29:05 <mauke> skorpan: it's a type constructor, so you're missing an argument (AnyFailable (a Int)?)
13:29:05 <hatds> Cale: can you link me to such examples?
13:29:06 <skorpan> mauke: what?
13:29:09 <Cale> Of course, in most of these situations we could use algebraic datatypes/records
13:29:50 <Cale> But typically the number of separate product types, the need to label fields distinctly, and the need to provide explicit liftings becomes tedious.
13:29:58 <Cale> I have seen people do it with TH though.
13:30:03 <mm_freak_> Peaker: every type has ⊥
13:30:10 <mm_freak_> there is nothing you could do about it
13:30:14 <edwardk> peaker: that bottom makes htem fail to be categorical products, it also means the pattern match might fail. the absence of said bottom means that evaluating tuples is tricky business
13:30:26 <ray> hm, i used to be able to display down-tack, now i can't
13:30:27 <Peaker> mm_freak_: I could have type products have no bottom
13:30:34 <mm_freak_> Peaker: no
13:30:35 <edwardk> peaker: so you're pretty much damned either way =)
13:30:40 <Cale> hatds: Someone once came here with a really great example from a game, and my best answer was to use a Data.Map
13:30:49 <dolio> Peaker: http://noordering.wordpress.com/2009/04/19/bottoms/
13:31:10 <Cale> hatds: Basically, keeping track of all these hundreds of little properties of game objects which might or might not be there.
13:31:20 <mm_freak_> Peaker: trivial counterexample:  foo :: (a,b);  foo = foo
13:31:35 <hatds> do people think that an improved record system should make it sensible to have "x" and "y" as field selectors? (normally you wouldn't pick such names given the current situation)
13:31:49 <dolio> Peaker: Products will still have a bottom even if you don't have a distinct _|_ that is not of the form (a, b). (_|_, _|_) will still be less defined than any other value.
13:32:19 <Cale> hatds: Well, yes, but I think that field labels should be in a separate namespace from functions and other values.
13:32:29 <Peaker> dolio: right
13:32:43 <edwardk> hatds: my notation in kata treats field selectors as a special syntax. so you can refer to slots with foo.x notation or make (.x) sections, but then thats another overloading of (.) and probably makes Cale cry ;)
13:32:44 <Peaker> mm_freak_: you could still succeed in pattern-matching it against (_,_)
13:32:44 <Cale> And that we should have a handful of functions which project those field labels onto operations on those fields.
13:32:56 <Cale> I really hate the foo.x notation.
13:32:59 <mm_freak_> Peaker: no
13:33:05 <Cale> I would prefer  get 'x foo
13:33:14 <mm_freak_> you can pattern-match (⊥, ⊥) against (x, y), but not ⊥ itself
13:33:17 <Cale> Where get 'x would then be a first class function.
13:33:20 <mm_freak_> it would pattern-match forever =)
13:33:26 <edwardk> i went with foo.x because i also use it as my namespacing scheme
13:33:40 <Peaker> mm_freak_: I'm not talking about Haskell, but about Haskell2 :)
13:34:02 <dolio> If products were unlifted, then pattern matching could succeed without evaluating anything.
13:34:05 <mm_freak_> Peaker: that's not a haskell-specific problem
13:34:07 <Cale> I somewhat think that labels need to be in a kind of their own though.
13:34:07 <vixey> Haskell 2.0 is mostly implemented in javascript
13:34:13 <mm_freak_> Peaker: it's the halting problem
13:34:15 <dolio> Similar to newtypes.
13:34:17 <hatds> foo.x (or some other system to change the scoping of field labels) feels like we are reinventing pattern matching
13:34:21 <Peaker> mm_freak_: <dolio> If products were unlifted, then pattern matching could succeed without evaluating anything.
13:34:43 <mm_freak_> hmm, true, but why would you want that?
13:34:53 <Peaker> mm_freak_: it would make fmap=second, for example
13:35:20 <mm_freak_> hmm
13:35:21 <Cale> hatds: In fact, I think the most elegant system allows one record to have more than one field with the same label.
13:35:24 <Peaker> dolio: I'm in agreement with that blog post, and think its consistent with separating type products from type sums, and not lifting the products
13:35:37 <mm_freak_> i really like generalization, but i wouldn't like fmap = second
13:35:48 <dolio> Peaker: Read the comments by augustss. He explains why it's not a simple decision.
13:35:53 <Cale> This seems strange at first, but it avoids the need to have a type-system mechanism for saying that some record lacks a given field.
13:36:29 <Cale> You should always be able to extend any record with a new field with any name at any type.
13:36:58 <Cale> and when deconstructing that record again, the fields with the same name and type should act like a stack
13:37:18 <Peaker> dolio: I am not sure why maintaining that (seq _|_ a) = _|_ is important..
13:37:23 <hatds> Cale: I just don't see why we have to make a special namespace to put "x" into.  The solution already exists in haskell using pattern matching:    let Foo x y z = foo in...
13:37:41 <Cale> hatds: The problem is one of extensibility.
13:37:51 <mm_freak_> Peaker: because seq is defined like that
13:38:11 <dolio> It's the definition of seq.
13:38:21 <Cale> If you use pattern matching like that, what happens when you extend Foo with a new field, say, at the beginning?
13:38:28 <ray> seq wouldn't be seq if seq _|_ a weren't _|_, it'd be flip const
13:38:31 <dolio> I wouldn't mind getting rid of it, of course.
13:38:33 <Cale> You need to go and modify all the functions which use it.
13:38:34 <edwardk> cale: i rather liked that version of row types when i first saw it (the one that allowed field name 'hiding')
13:38:44 <ray> or rather, it'd be seq'
13:38:47 <Cale> Even if those functions don't care at all about the existence of your new field.
13:38:52 <Peaker> mm_freak_: So change how seq is defined
13:38:55 <Cale> The record syntax is a way to avoid this problem somewhat.
13:38:58 <Peaker> mm_freak_: I mean, why is it a desirable property?
13:38:58 <roconnor> ooh, can we have the Seq class back in our new standard?
13:39:19 <roconnor> the reasons for removing Seq seem dumb.
13:39:29 <mm_freak_> Peaker: you can't, because seq's purpose is to ensure that 'seq b a = a', but b is completely evaluated before a
13:39:41 <edwardk> isn't there intrinsically a problem with the strictness of pattern matching as well, even beyond Seq?
13:39:47 <hatds> Cale: I think typeclasses solve that problem
13:39:52 <Peaker> mm_freak_: and if "b" is a tuple, then it either is disallowed (if a class) or does nothing
13:39:59 <Cale> hatds: Not elegantly.
13:40:08 <edwardk> i.e. the fact that crossing = is sort of irrevocable
13:40:20 <mm_freak_> Peaker: seq evaluates to normal form, not to WHNF
13:40:39 <edwardk> mm_freak_: ?
13:40:40 <hatds> Cale: yea, don't make a typeclass with "x" as an overloaded selector function.  That's inelegant
13:40:43 <Peaker> edwardk: you said "the pattern-match might fail" -- why? it can be like a newtype pattern match?
13:40:45 <mm_freak_> oh
13:40:51 <mm_freak_> i may be wrong about this
13:40:54 <mm_freak_> > seq (undefined, undefined) 0
13:40:54 <mm_freak_> 0
13:40:55 <lambdabot>   0
13:40:56 <Cale> hatds: You can rig up various horrifying for labels that take maybe only half an oleg of typeclass swindling, but it's not a decent replacement for a proper record system.
13:41:03 <Cale> horrifying systems*
13:41:14 <mm_freak_> ok, seq evaluates to WHNF =)
13:41:16 <edwardk> > rnf (undefined, undefined)
13:41:17 <lambdabot>   Add a type signature
13:41:29 <edwardk> > rnf (undefined :: Int)
13:41:31 <lambdabot>   * Exception: Prelude.undefined
13:41:47 <mm_freak_> > [0,undefined] `using` rnf
13:41:47 <mm_freak_> *** Exception: Prelude.undefined
13:41:48 <lambdabot>   * Exception: Prelude.undefined
13:41:56 <roconnor> hatds: I'd make field labels construct accessor functions rather than projection functions.
13:42:00 <Peaker> I think tuples can have (_|_, _|_) == _|_ and have it be indistinguishable because seq on tuples would be either disallowed or do nothing
13:42:17 <Peaker> @type using
13:42:18 <lambdabot> forall a. a -> Strategy a -> a
13:42:21 <roconnor> hatds: then suitable infix notation makes record access look nice.
13:42:26 <Cale> hatds: Basically, you're struggling to implement a proper record system in the type system with typeclasses, which can be done, given enough extensions, but it can't be made to look at all nice, as far as I know.
13:42:30 <hatds> Cale: I suspect I haven't see first hand examples to where there isn't a good design without using records
13:42:57 <edwardk> peaker: the issue is that you need to evaluate both branches in parallel as i understand it to properly deal with unlifted tuples as the same kind as everything else. thats why (# x,y #) is in a different kind (#)
13:42:59 <Cale> hatds: Algebraic datatypes excel in cases where the products are all tiny and unlikely to change.
13:43:07 <mm_freak_> Peaker: i really don't see how that's useful?
13:43:14 <mm_freak_> haskell's current semantics are clear and simple
13:43:31 <Peaker> mm_freak_: I disagree, they're nuanced and not well understood by many... how many people understand how fmap /= second?
13:43:38 <hatds> Cale: size of the data constructor and how often it is changed are separate
13:43:41 <Peaker> mm_freak_: not to mention they require "fail" in "do notation"
13:43:54 <Cale> hatds: This is really more of a concern over the way that programs are maintained over time than it is a fundamental limitation of what you can do.
13:43:57 <Peaker> edwardk: you need to do that in order for what?
13:43:59 <dolio> They don't require fail in do notation.
13:44:02 <mm_freak_> Peaker: but you're introducing special cases
13:44:11 <mm_freak_> and special cases are almost always a bad idea
13:44:16 <Peaker> mm_freak_: not necessarily - I separate type products from type sums
13:44:16 <hatds> Cale: I assume you mean by "change" where I change the data declaration
13:44:22 <wli> Pattern match failure should just introduce a constraint of MonadZero
13:44:22 <Cale> hatds: yes
13:44:30 <edwardk> peaker: i refer you to dolio's earlier link
13:44:37 <roconnor> foo^.bar^.baz
13:44:44 <Cale> hatds: Changing data declarations is always a big deal.
13:44:51 <Cale> hatds: (with algebraic datatypes)
13:44:54 <hatds> Cale: in a certain sense, if your type is not abstract then changing the data declartion should be a big deal
13:45:03 <mm_freak_> Peaker: Pair a b is also a type "product", but would behave differently from (,)
13:45:10 <Cale> hatds: Right, with algebraic datatypes, that's absolutely true.
13:45:13 <Peaker> edwardk: I read it and augustss's comment - I think the solution to his problem is one of: A) seq disallowed on tuples (Seq class) B) seq allowed on tuples and type products, but does nothing on them
13:45:25 <Peaker> mm_freak_: not in my suggestion
13:45:46 <yitz> wli: failure is at runtime, it can't introduce a type constraint
13:46:03 <Cale> hatds: What a proper record system would give you is a new kind of abstract datatype where we can impose restrictions that it must have certain fields, but beyond that, we don't care what's there.
13:46:05 <Peaker> mm_freak_: product Pair a b = Pair a b -- only one constructor allowed, no lifting.   sum Either a b = Left a | Right b -- lifted
13:46:10 <edwardk> Seq in a class opens up a lot of options for fragmenting the kind system in weird and wonderful ways ;)
13:46:16 <jmcarthur_work> would be nice if we could simply name the functions from type classes locally with some sort of nice syntax. then we wouldn't necessarily have to fuss over whether Monoid exclusively deserves (+) or not: fold {Monoid empty (+)} = foldr (+) empty
13:46:30 <jmcarthur_work> or something like that
13:46:31 <Peaker> edwardk: why?
13:46:38 <mm_freak_> Peaker: currently you can have Pair ⊥ ⊥ ≠ ⊥…  if you wanted Pair ⊥ ⊥ = ⊥, you'd need to change semantics a lot
13:46:44 <edwardk> peaker: i'm not saying this is necessarily bad
13:47:00 <mm_freak_> Peaker: that's how newtype works, AFAIS
13:47:07 <Peaker> edwardk: I don't see why there's be more kinds?  Can't lifted/unlifted types be the same kind?
13:47:23 <Cale> hatds: Dually, extensible variants would allow us to know that certain cases are possible, but otherwise we don't care about various other possibilities. (That is, we're always willing to write a fall-through case)
13:47:25 <PetRat> test
13:47:38 <mm_freak_> you just want more constructor arguments
13:47:41 <Peaker> mm_freak_: I'd have no new bottom for Pair, so Pair _|_ _|_ == _|_ -- why would it change semantics?  Just disallow "seq" on Pair or have it do nothing
13:47:43 <jmcarthur_work> mm_freak_, well, newtype only makes a type from an existing type, so newtype Pair a b = Pair (a, b) would still have the same semantics as just (a, b)
13:47:53 <mm_freak_> well
13:48:05 <mm_freak_> data StrictPair a b = Pair !a !b
13:48:06 <Cale> hatds: That is, it would give us open products and sums, as opposed to the closed ones of algebraic datatypes.
13:48:38 <Cale> (and a decent notation for working with them)
13:48:39 <hatds> Cale: but having a field called "x :: Int" does not really express a very good static guarantee.  Unrelated types with "x::Int" and "y::Int" labels shouldn't be able to use the same function that operates on those labels
13:49:09 <Cale> hatds: When you call the function, its type specifies that it's going to act on those specific named labels.
13:49:29 <Cale> hatds: So you know for sure what they ought to mean.
13:49:50 <edwardk> hatds: which calls for namespacing of field labels
13:49:53 <Cale> and yes, they should, that's the whole point :)
13:49:57 <PetRat> http://www.mibbit.com/pb/f5olxg I'm trying to make code that expresses an algorithm that involves sequential steps and has many points where it can terminate early. In RHW I saw a way to do this with Maybe as a monad. However, in my case I can't figure out what to do, because this all involves io.
13:50:00 <mm_freak_> i don't really think we need 'product'…  we have data with strict fields
13:50:11 <edwardk> gotta run
13:50:16 <mm_freak_> and i wouldn't want (,) to behave differently from how it does now
13:50:24 <Peaker> mm_freak_: product doesn't make it strict -- product means its unlifted and cannot do sums
13:50:27 <Cale> The whole point is that the same function which acts on records with those particular name/type labels should be able to act on different sorts of records.
13:50:29 <mm_freak_> also i don't see what's wrong with fmap ≠ second
13:50:38 <Peaker> mm_freak_: its nuanced and confusing
13:50:39 <hatds> edwardk: you mean so one can differentiate "x::Int" from unrelated types that happen to both have that field label?
13:50:52 <Cale> hatds: The point is not to differentiate between them.
13:50:53 <Peaker> mm_freak_: it also means programs can diverge when they're really not computing anything
13:50:59 <Peaker> mm_freak_: (such as the value of a type ())
13:51:31 <mm_freak_> Peaker: not to practical haskell programmers…  and even if, it follows clearly from haskell's evaluation semantics that fmap ≠ second
13:51:35 <Cale> hatds: That's exactly the kind of polymorphism that I want to be able to express.
13:51:47 <mm_freak_> there is no reason for fmap to be the same as second
13:51:57 <mm_freak_> 1 is not the same as 1.000001 either
13:52:12 <Cale> hatds: A function should be able to say... "I want some kind of record, and it's got such and such fields and I don't care what else."
13:52:45 <PetRat> (bump) http://www.mibbit.com/pb/f5olxg I'm trying to make code that expresses an algorithm that involves sequential steps and has many points where it can terminate early. In RHW I saw a way to do this with Maybe as a monad. However, in my case I can't figure out what to do, because this all involves io.
13:52:54 <jmcarthur_work> actually, speaking of tuples, we should think about (,,, ...) = (,(,(, ...)))
13:52:56 <Cale> Or "I produce some kind of record, and it's got all the fields that these records you're going to give me have, plus one which is called x and is of type Integer"
13:53:25 <hatds> Cale: a function that requires it's argument to have two labels: x::Int and  y::Int is a misguided design.  Why don't we just call it a function Int -> Int -> whatever
13:53:28 <jmcarthur_work> actually nevermind, it's been beaten to death
13:53:56 <Peaker> mm_freak_: I disagree -- I think fmap/=second means we have a fragmented library instead of a unified one - which results in unnecessary code duplication.  Functions expressed with second on tuples would have to be duplicated to be expressed with fmap as well, depending on the bottom semantics desired
13:53:56 <Cale> hatds: Because maybe we want to carry the *rest* of that information through into the result polymorphically.
13:54:04 <jmcarthur_work> hatds, what do you think a type class is? ;)
13:54:35 <hatds> jmcarthur_work: if I ever overload the single character name "x" as a selector function please shoot me :)
13:55:30 <roconnor> @type x
13:55:31 <lambdabot> Expr
13:55:54 <mm_freak_> Peaker: is this relevant in practice?  i've never seen a case, where this is really problematic or annoying
13:55:57 <vixey> @type \x -> x
13:55:59 <lambdabot> forall t. t -> t
13:56:02 <Athas> I have a really weird problem with Data.List.Intersperse.  It causes my program to terminate with the output "<<loop>>".
13:56:04 <vixey> hatds ^ it doesn't cause a problem
13:56:09 <hatds> Cale: do you really lose anything by only having (Int,Int) -> (Int,Int) instead of (Int,Int) -> a?
13:56:16 <jmcarthur_work> hatds, well, if it was namespaced, i wouldn't hesitate to use x, y, and z in a Vector3 record or something
13:56:37 <jmcarthur_work> but that's besides the point
13:56:38 <Cale> hatds: (Int,Int) -> ... doesn't express the polymorphism I want.
13:56:47 <Peaker> mm_freak_: I haven't encountered a lot of bottom-related issues in general - but I've had to read a lot more about how things behave in order to understand them than if we had separate products and sums
13:56:52 <yitz> ////////////////////////////////////
13:57:00 <yitz> oops sry
13:57:03 <hatds> Cale: I mean (requires x::Int, y::Int) -> a
13:57:06 <PetRat> (bump) http://www.mibbit.com/pb/f5olxg I'm trying to make code that expresses an algorithm that involves sequential steps and has many points where it can terminate early. In RHW I saw a way to do this with Maybe as a monad. However, in my case I can't figure out what to do, because this all involves io.
13:57:20 <mm_freak_> Peaker: honestly would you ever want to rename 'second' to 'fmap' or the other way around?  if no, then this is a non-issue
13:57:21 <Cale> hatds: Okay, consider a game in which you have many objects, creatures, monsters what have you.
13:57:27 <roconnor> Athas: that error means your program went into an infinite loop
13:57:35 <Cale> hatds: And you also have lots of different types of weapons.
13:57:41 <mm_freak_> i'd never ever use 'fmap' to manipulate the snd of a duple
13:57:48 <roconnor> Athas: yes, GHC is *that* awesome
13:58:05 <Peaker> mm_freak_: the current way also means that people bring up the "If people add another constructor it would.." and that's a non-issue with separate type-sums
13:58:08 <Athas> Oh, that is pretty clever.
13:58:27 <hatds> Cale: alright
13:58:38 <Cale> hatds: A weapon is going to be able to damage any object with a hitpoints field.
13:58:40 <Athas> But I am very certain that the list I pass to intersperse is finite.
13:58:41 <Peaker> mm_freak_: and more importantly, the current way requires: both data, newtype, whereas product/sum don't require it
13:59:01 <dolio> Peaker: Note that the explanation in the reply to augustss' last comment explains how to implement 'let p = p in case p of (x, y) -> [x, y]' by rewriting the definition of p to be 'let x' = x' ; y' = y' ; p = (x', y') in ...'. This means that you have to generate different code for each product type, unlike the current scheme where, as far as I'm aware, 'p = p' is the same for every type.
13:59:03 <Cale> hatds: But it's not going to affect the rest of the fields.
13:59:07 <Cale> (say)
13:59:26 <mm_freak_> Peaker: i guess, this is really a matter of taste
13:59:26 <bos> PetRat: take a look further into the book for MaybeT
13:59:27 <jmcarthur_work> Cale, surely you are not advocating that this unification be performed based on choice of field identifiers, are you?
13:59:35 <mm_freak_> i like the simple semantics of the current haskell
13:59:39 <hatds> Cale: so you want, using records, something like    (a requires hp::Int) => Weapon -> a -> a
13:59:43 <hatds> Cale: is that right?
13:59:47 <jmcarthur_work> Cale, that sounds like something from C++ templates, if so
13:59:47 <Cale> hatds: yes, essentially
13:59:48 <mm_freak_> you like more complicated semantics to unify fmap and second…
13:59:51 <bos> PetRat: you can also jump out of a computation early with ContT, but that's a bit more advanced
14:00:00 <PetRat> Thanks bos. Is MaybeT some kind of "transformer" (I don't understand transformers yet)
14:00:01 <mm_freak_> well…  i wouldn't want to unify them at all
14:00:03 <Cale> hatds: So 'a' here is a row-variable
14:00:07 <bos> PetRat: sure is.
14:00:14 <hatds> Cale: row variable?
14:00:25 <Athas> How does GHC detect this <<loop>>-condition?
14:00:41 <mm_freak_> second is simply something different, even though in a certain border case you can (but shouldn't) use fmap for the same purpose
14:00:41 <Cale> hatds: It represents an abstract product of a bunch of labelled fields, and all we know about it is that it has some in particular.
14:00:43 <PetRat> Okay I'll study up, try to figure it out myself.
14:01:02 <mm_freak_> you can't unify them in any sensible manner
14:01:16 <Peaker> dolio: why is it a problem?
14:01:40 <Cale> hatds: Without a system like this, it's probably too awkward to represent this information statically at all.
14:02:01 <jmcarthur_work> Cale, why can't type classes be used for this?
14:02:16 <dolio> Well, for one, you potentially get significantly increased code size.
14:02:20 <Cale> jmcarthur_work: They could, but they're very awkward when you have 80 different kinds of fields.
14:02:36 <hatds> Cale: does the hp always decrease the same amount for a given weapon?
14:02:39 <jmcarthur_work> Cale, this is sounding like a job for template haskell
14:02:40 <Cale> (and so 80 different typeclasses you might have to write instances for, for each object type)
14:02:49 <Cale> Template Haskell is a mess.
14:03:02 <jmcarthur_work> could be cleaned up
14:03:05 <Cale> I've seen people try to do this sort of thing with TH, and it does sort of work, but it's not idea.
14:03:06 <Cale> ideal*
14:03:26 <Cale> hatds: Actually, it's probably more complicated :)
14:04:03 <roconnor> Athas: it happens when it tries to evaluate a thunk that it happens to be in the middle of trying to evaluate.
14:04:20 <mdmkolbe> @seen edwardk
14:04:21 <lambdabot> I saw edwardk leaving #haskell and #haskell-in-depth 13m 59s ago, and .
14:04:23 <hatds> Cale: if the damage depends on both Weapon and the object, then it depends on whether the effects can be combined separately or if there are N*M caes
14:04:36 <dolio> It's the same issue as with people wanting unpacking of polymorphic values. To do so, you need to generate separate code for every type you use.
14:04:50 <mdmkolbe> edwardk: I wasn't still around but I am now
14:05:18 <Peaker> dolio: hmm.. on second thought - I am not sure why it'd have to split the code, p could be a single infinitely-recursive thunk, the pattern match could just do nothing, and the thunks in the list would try to evaluate the recursive thunk and would each be bottom?
14:05:54 <Cale> hatds: But I've seen this problem come up enough times, especially in real-world situations where you have complicated protocols with lots of fields, where algebraic datatypes become sort of a clumsy tool.
14:05:57 <dolio> With that particular implementation of unlifted products, you need to generate new code for every product type (or at least, every type of a given size).
14:06:21 <dolio> Peaker: The point of that implementation was to generate code that performs decently.
14:06:42 <Cale> hatds: I think it's something which certainly *can* be avoided if you have enough freedom of design, but in interacting with other programs and systems it's hard to avoid.
14:07:12 <hatds> Cale: if this weapon/object problem has N*M cases then there is no good extensible solution. Algebraic data types are no worse for wear because you would have to change a lot of code to add another weapon or object
14:07:36 <jmcarthur_work> Cale, is your proposal based on the field identifiers, or on something less ad hoc?
14:07:37 <Peaker> dolio: why doesn't fst (bottom), snd (bottom) perform decently?
14:07:37 <Cale> hatds: Well, it might be that there are some additional fields to look at, like armour, for instance.
14:07:51 <hatds> Cale: Ok -- an armor system would remove the N*M problem
14:07:55 <Cale> jmcarthur_work: Field identifiers which are reflected in the types.
14:08:24 <jmcarthur_work> okay, but if i change the name of a field identifier, i'm likely to break a lot of code?
14:08:29 <hatds> Cale: so you want (a requires hp::Int, armor::Int) :: Weapon -> a -> a?
14:08:29 <Cale> jmcarthur_work: So we can statically express that such and such named field is present.
14:08:49 <dolio> Peaker: As I read the comments, one of augustss' points was that a case on a pair can no longer evaluate the pair and (assuming it isn't bottom) simply point the variables at the contents at the pair.
14:08:51 <Cale> jmcarthur_work: Well, yes. It will change the type of the value you create.
14:09:27 <Cale> jmcarthur_work: So you'll probably get a compile error if that field actually matters.
14:09:33 <dolio> Because a 'p = p' unlifted pair that's represented the same way as lifted types has no places to point to, and can't evaluate anything.
14:09:55 <Cale> jmcarthur_work: Various functions you might apply to that data will demand that it has a field with a given name and type.
14:09:56 <dolio> So instead you create thunks.
14:10:55 <Peaker> dolio: so its more lazy
14:10:57 <jmcarthur_work> what happens if i say foo :: (a requires fhwsnfudioa::Int) => a -> a, even if there is not and never will be a field with that name? no compiler error (until I try to unify something with it that fails, of course)?
14:11:37 <Botje> if that function is never used there's no need to compile it, right?
14:11:42 <Cale> jmcarthur_work: Right. You just couldn't use the function.
14:11:55 <hatds> Cale: is the hp/armor function signature above the problem you were posing?
14:12:08 <Cale> hatds: Well, it's one example.
14:12:11 <Peaker> dolio: or is that what he means? more lazy=worse performance?
14:12:22 <hatds> Cale: ok, I'll probably have to noodle around with it a bit
14:12:25 <dolio> In this case.
14:12:46 <jmcarthur_work> i still see this as a sort of sugar for type classes, i think
14:12:53 <jmcarthur_work> although i can definitely see why it would be convenient
14:13:05 <Cale> Everyone should have a look at Daan's paper...
14:13:17 * Cale finds it...
14:14:23 <Cale> http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
14:14:30 <Cale> I believe that was the one that I liked.
14:14:41 <Cale> Though I hate the syntax used in the paper, it's just syntax.
14:14:46 <skorpan> @unpl <*> (. getElem)
14:14:46 <lambdabot> (\ b -> b <*> \ a e -> a (getElem e))
14:14:51 <skorpan> @unpl (<*> (. getElem))
14:14:52 <lambdabot> (\ b -> b <*> \ a e -> a (getElem e))
14:14:54 <Botje> hmm
14:15:03 <Botje> i thought for a second MS hired him
14:15:07 <Cale> (actually, I do like the extension of case expressions)
14:15:12 <skorpan> @pl \a e -> a (getElem e)
14:15:12 <lambdabot> (. getElem)
14:15:20 <jmcarthur_work> one thing i know i don't like about this idea is that i could use functions i'm not supposed to be able to use just by naming a field or two the right way, even by accident
14:15:27 <Cale> Botje: that would be because they did?
14:15:33 <hatds> the thing I don't like about "x::Int" as a sensible field label is that it is like saying data types are related until proven otherwise
14:15:38 <Botje> hmm
14:15:43 <jmcarthur_work> hatds, yes!
14:15:47 <Botje> but then why does the pdf say "daan@cs.uu.nl" ? ;)
14:15:58 <dolio> Replacing all your 'case p of (x, y) -> ...' with 'let x = fst p ; y = snd p in ...' isn't a recipe for high performance I'd imagine.
14:16:01 <Cale> Botje: because the paper is old :)
14:16:09 <Botje> 2005 isn't old!
14:16:16 <Botje> i'm from 1986 and i'm /hardly/ old ;)
14:16:42 <Cale> In any case, it seems he's working for MSR now :)
14:17:15 <hatds> Botje: were you a piece of paper back in 1986?
14:17:17 <hatds> :)
14:17:36 <jmcarthur_work> my birth certificate from 1985 is all brown and crappy
14:17:39 <Peaker> dolio: Its not too scary
14:17:41 <Cale> hatds: If you'd prefer, we could add a new type of declaration for labels, and have them be module-scoped.
14:18:01 <Botje> hatds: I caused a lot of those pieces of paper to suddenly be stabbed and stained with ink, does that count? :)
14:18:03 <dolio> Have you written a compiler that does this? :)
14:18:21 <Peaker> dolio: case p of (x, y) -> ... essentially executes fst p and snd p in the pattern-match itself..?
14:18:33 <Peaker> dolio: so the problem is that the work induced by fst/snd is delayed and not forced?
14:19:13 <Cale> More thought could be put into the connection between modules and records though.
14:20:08 <Cale> It would be nice if the module system could be unified with the record system.
14:20:21 <Cale> and then we could have first class functions on modules
14:20:27 <jmcarthur_work> agreed, definitely
14:20:37 <Peaker> dolio: and the splitting of the code for each type product doesn't sound so bad either (also its probably just split code per product-size, and not necessarily per-product?)
14:20:45 <hatds> so a module becomes a dictionary of the values it exports?
14:20:57 <Cale> yes, and types
14:20:58 <jmcarthur_work> yes
14:21:02 <Cale> The types are the interesting bit there.
14:21:24 <Cale> (and typeclasses?!)
14:21:27 <jmcarthur_work> i am less certain about parameterized modules though, unless we also address how it relates to type classes
14:22:01 <Cale> It seems there's a lot of overlap between what typeclasses accomplish and what module functions accomplish.
14:22:10 <hatds> I agree
14:22:15 <jmcarthur_work> i am sure a lot of thinking has been put into type classes and parameterized modules
14:22:28 <jmcarthur_work> i don't know what results have come from that research though, if any
14:23:03 <hatds> but I don't think we should tie two separate ideas: namescoping and interfaces, into one idea
14:23:39 <Peaker> I see namespaces as a syntactic thing..
14:23:40 <jmcarthur_work> i don't think the two ideas are so different
14:25:15 <hatds> yea, namespaces are syntactic the way I'm using the term
14:26:05 <Cale> Hmm... it seems to me that with first class modules, you could define instances of typeclasses by simply providing a module value of the appropriate type.
14:26:23 <Cale> So you could start by connecting the two systems together in that way.
14:27:00 <Cale> The real benefit which typeclasses provide is that they allow you to set a default implementation of some operations at a given type.
14:28:05 <hatds> can you import a typeclass qualified only?
14:28:29 <duaneb> ok
14:28:35 <Cale> You can import it qualified, but the instant you import a module, all the instances come along with it.
14:28:42 <duaneb> so I have a maybeDat::Maybe ByteString
14:28:45 <duaneb> how can I print it?
14:28:47 <Cale> (and cannot be qualified, since they aren't named)
14:28:53 <hatds> I see
14:29:04 <Cale> print maybeDat
14:29:07 <duaneb> I think I want to do something like liftM (ByteString.writeFile "foo.dat") maybeDat
14:29:18 <duaneb> err, write the data itself to a file
14:29:27 <Cale> duaneb: and if it's Nothing?
14:29:33 <duaneb> Cale: then it... fails?
14:29:42 <Cale> case maybeDat of
14:29:55 <Cale>   Nothing -> (code to handle the error goes here)
14:29:55 <Peaker> Instances can be thought of as inherent or "inside" the types, and thus resolve the dilemma of how to get just some subset of the instances :)
14:30:07 <Cale>   Just x -> B.writeFile "foo.dat" x
14:30:48 <dolio> Peaker: In a hopelessly bad microbenchmark I just did, 'foo n = foldl (\p _ -> let x = fst p ; y = snd p in (x, y)) (0,0) [1..n]' for n = 100 million, compiled at -O, that takes 20 seconds.
14:31:01 <duaneb> oke, that worked
14:31:13 <dolio> 'bar n = foldl (\(x, y) _ -> (x, y)) (0, 0) [1..n]' takes 5 seconds.
14:31:14 <duaneb> I need to figure out how to handle monadic type errors :/
14:31:42 <Cale> Well, this isn't particularly monadic. Maybe happens to be a monad, but we don't care about that here.
14:31:46 <Peaker> dolio: that might trivially optimize it to const?
14:31:52 <dolio> -O2 eliminates the difference, but it probably figures out that 'let x = fst p ; y = snd p in (x, y)' is the identity.
14:31:58 <jmcarthur_work> @type Data.Traversable.sequence $ Data.ByteString.writeFile "foo.dat" <$> (undefined :: Maybe Data.ByteString.ByteString)
14:32:00 <lambdabot> IO (Maybe ())
14:32:02 <Cale> and IO happens to be a monad, but we also don't particularly care about that here :)
14:32:10 <dolio> At least, for (0, 0).
14:32:14 <duaneb> fine, I need to figure out how to parse type errors in general
14:32:16 <Peaker> dolio: -O doesn't recognize that -- \(x, y) _ -> (x, y)  == const?
14:32:18 <duaneb> but thanks!
14:32:19 <jmcarthur_work> @hoogle Maybe () -> Bool
14:32:19 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
14:32:20 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
14:32:20 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
14:32:47 <Gracenotes> ..really
14:32:51 <hatds> would \(x, y) a -> a`seq` (x, y) make a difference?
14:32:51 <Cale> duaneb: I suppose that the error you got might have had something to do with a monad though.
14:33:20 <Gracenotes> heh... isBottom. Odd function
14:33:21 <jmcarthur_work> @type fmap isJust . Data.Traversable.sequence $ Data.ByteString.writeFile "foo.dat" <$> (undefined :: Maybe Data.ByteString.ByteString)
14:33:22 <lambdabot> IO Bool
14:33:25 <Peaker> > concatMap (\p _ -> let x = fst p ; y = snd p in [x,y]) [] [(1,1)..(10,10)]
14:33:27 <lambdabot>       The lambda expression `\ p _ -> ...' has two arguments,
14:33:27 <lambdabot>      but its ty...
14:33:29 <Cale> duaneb: If you just tried to  x <- maybeDat  in the middle of an IO do-block, then that would create a type error, because it's the wrong monad.
14:33:39 <Peaker> > concatMap (\p -> let x = fst p ; y = snd p in [x,y]) [] [(1,1)..(10,10)]
14:33:40 <lambdabot>   Couldn't match expected type `[(t1, t2)] -> t'
14:33:42 <Gracenotes> and incidentally isBottom fails for non-terminating bottoms like (let a = a in a)
14:33:58 <Gracenotes> which aren't really formalized in the language... unlike exceptions
14:34:20 <Peaker> > concatMap (\p -> let x = fst p ; y = snd p in [x,y]) $ zip [1..10] [1..10]
14:34:22 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
14:34:42 <Gracenotes> wait... never mind... it is recognizing it after all. weird.
14:34:45 <Peaker> dolio: maybe benchmark something like this?
14:34:56 <pejo> Gracenotes, are you talking about GHC internals?
14:35:10 <jmcarthur_work> pejo, Test.QuickCheck.Batch isBottom :: a -> Bool
14:35:29 <mux> is it possible to export only a typeclass name and its instances without its definition? a closed class, somehow
14:35:46 <Gracenotes> isBottom undefined = True; isBottom (print undefined) = False; isBottom (let a = a in a) ... waiting
14:35:47 <mux> or do I have to hide it through an existential type or something else?
14:38:34 <roconnor> mux: I wish.
14:39:43 <dolio> Peaker: let x = fst p ; y = snd p is slower, although I think a lot of the runtime is list overhead.
14:40:18 <Peaker> dolio: with -O2 too?
14:40:24 <dolio> Testing...
14:41:15 <dolio> Yes.
14:41:21 <monadic_kid> :t if_
14:41:22 <lambdabot> Not in scope: `if_'
14:41:25 <monadic_kid> :t ifM
14:41:26 <lambdabot> Not in scope: `ifM'
14:41:42 <skorpan> @src (>)
14:41:42 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
14:41:57 <skorpan> (>) is Ord right?
14:42:08 <Peaker> mux: I think if you just export the class name without (..) around it it doesn't export any of the methods
14:42:10 <jmcarthur_work> :t (>)
14:42:11 <lambdabot> forall a. (Ord a) => a -> a -> Bool
14:42:12 <Peaker> mux: is that what you want?
14:42:40 <mux> Peaker: I think that'll be good enough
14:42:46 <monadic_kid> :t if' <$>
14:42:47 <lambdabot> parse error (possibly incorrect indentation)
14:42:53 <monadic_kid> :t (if' <$>)
14:42:54 <lambdabot> Not in scope: `if''
14:43:25 <jmcarthur_work> :t let if' = (undefined :: Bool -> a -> a -> a) in (if' <$>)
14:43:26 <lambdabot> forall a (f :: * -> *). (Functor f) => f Bool -> f (a -> a -> a)
14:43:33 <mux> bah, using FlexibleInstances and an instance MyClass [Int], it seems GHC's type inference algorithm isn't very good
14:43:48 <mux> if I pass a list of integer literals, it doesn't find the instance
14:43:59 <mux> if I annotate with :: [Int] it works
14:44:01 <mux> is this expected?
14:44:26 <snoobino> are you sure your int list isn't polymorphics
14:44:28 <jmcarthur_work> :t 5 -- mux
14:44:29 <lambdabot> forall t. (Num t) => t
14:44:37 <jmcarthur_work> ^^ is not an Int
14:44:54 <mux> jmcarthur_work: which doesn't prevent you from usign the literal 5 with functions that take Int's
14:45:00 <Peaker> dolio: I guess the automatic product duplication augustss suggested might be for good reason
14:45:10 <Peaker> dolio: But I don't know enough about ghc internals
14:45:18 <jmcarthur_work> mux, right, but your type class doesn't restrict your type to Int
14:45:34 <mux> jmcarthur_work: it does
14:45:48 <jmcarthur_work> mux, for example, you could also have defined instance MyClass [Float]
14:45:51 <Peaker> mux: there are not "integer literals" -- they are polymorphic/numeric literals
14:45:52 <jmcarthur_work> mux, it wouldn't know what to do
14:45:57 <mux> jmcarthur_work: but I didn't :-)
14:46:04 <mauke> mux: doesn't matter
14:46:05 <mux> I guess that's why I wanted really closed classes.
14:46:23 <jmcarthur_work> mux, if you want the type to be restricted, you don't want a type class
14:46:24 <Peaker> mux: The compiler assumes an "open world" w.r.t to instances existing -- it assumes that more instances may exist even if he's not seen them
14:46:38 <mux> I don't want an ADT either, this would just ruin convenience
14:46:39 <Peaker> mux: why not use a closed type sum in that case?
14:46:52 <jmcarthur_work> mux, what's inconvenient about the ADT solution?
14:47:04 <Cale> also, there's numeric defaulting, but it only applies to type variables constrained solely by Prelude classes
14:47:14 <mux> jmcarthur_work: it would force calles to introduce their type with my type constructor
14:47:17 <mux> callers
14:47:43 <mux> maybe I should still consider it
14:47:47 <Peaker> mux: instead of your class?
14:47:52 <mux> this is some kind of a query interface
14:47:53 <mux> maybe
14:48:03 <jmcarthur_work> good type class etiquette would do the same thing (in which case you wouldn't be defining MyClass [Int])
14:48:16 <mux> sysctlGetInt (ByName "kern.foo") and sysctlGetLong (ByOid [1,2]) isn't so bad
14:48:22 <mux> but the typeclass solution still is more convenient
14:48:41 <mux> syntactically speaking
14:49:35 <skorpan> is there no datatype named Point?
14:49:43 <skorpan> i think (Int, Int)?
14:50:23 <mux> jmcarthur_work: I can agree with that, but don't you think the typeclass way has some nice syntactic feeling to it? :-)
14:50:55 <jmcarthur_work> oftentimes you lose that by having to wrap things with newtypes to choose among multiple instances
14:51:06 <jmcarthur_work> for what would otherwise be the same type, i mean
14:53:19 <skorpan> @hoogle (Ord a) => a -> a -> a -> Bool
14:53:19 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:53:19 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
14:53:19 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
14:53:35 <mux> anyways, in that case it was really possibpe for GHC to determine that the only valid instance was [Int]
14:53:36 <skorpan> anything such as \x y z -> x => y && x <= z?
14:53:53 <skorpan> i.e. a "between" function?
14:54:08 <mux> :t inRange
14:54:09 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
14:54:21 <skorpan> Ix?  isn't that for arrays?
14:54:36 <mux> > 2 `inRange` (1,10)
14:54:37 <lambdabot>       No instance for (Num ((t, t1), (t, t1)))
14:54:37 <lambdabot>        arising from the litera...
14:54:51 <mux> blah, the same problem as we were talking about here heh
14:54:56 <skorpan> > (1, 10) `inRange` 2
14:54:56 <mux> except that in that case it's legit
14:54:57 <lambdabot>   True
14:55:02 <Cale> > inRange (1,10) 2
14:55:03 <lambdabot>   True
14:55:25 <mux> doh, *smacks self*
14:55:25 <skorpan> hm, since Int is Ix, this might actually work
14:55:40 <jmcarthur_work> :P
14:55:41 <Cale> But it's not really ideal to use inRange if what you really want is the Ord thing.
14:55:53 <mux> yup
14:55:56 <skorpan> why not?
14:56:04 <skorpan> it seems to me like it's exactly what i want?
14:56:12 <Cale> Well, if you're writing something polymorphic it matters
14:56:12 <mux> Ix needs Bounded too
14:56:25 <skorpan> oh, i don't have Bounded...  should i just write my own function?
14:56:27 <mux> you could want inRange for "Ord-only" datatypes
14:56:29 <Cale> But given that you're just using Int, it should be fine.
14:56:29 <mux> ie Integer
14:56:32 <jmcarthur_work> @hoogle range
14:56:32 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
14:56:32 <lambdabot> Language.Haskell.TH data Range
14:56:32 <lambdabot> Language.Haskell.TH.Syntax data Range
14:56:39 <jmcarthur_work> @hoogle inrange
14:56:40 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
14:56:40 <lambdabot> Distribution.Version withinRange :: Version -> VersionRange -> Bool
14:56:48 <jmcarthur_work> hmm
14:56:52 <SamB> inRange is basically for use with ranges that you're already using with Ord ...
14:59:03 * mux still pondering wether to use a sum type or not
14:59:55 <duaneb> you know what really sucks?
15:00:02 <duaneb> conversion between integral and floating
15:00:03 <cocopumpkin> probably
15:00:22 <hatds> realToFrac?
15:00:36 <dolio> Be careful lobbing those soft balls.
15:00:44 <cocopumpkin> soft balls?
15:00:50 <mux> what sucks even more is the incredible numer of possible truncation/overflow errors that happen with language that do implicit numeric coercions
15:00:57 <dolio> Softball?
15:01:11 <duaneb> mux: only if you're not careful :P
15:01:26 <SamB> duaneb: well, it's harder to be careful when you can't see where the conversion happens ...
15:01:33 <mux> duaneb: Haskell is about forcing people into carefulness :)
15:01:41 <duaneb> mux: yea, I know
15:01:51 <duaneb> I just feel stupid doing things like: fround = fromIntegral . round
15:01:58 <mux> heh
15:02:13 <mux> putting the fromIntegral calls in the good place is quite a gymnastic
15:02:19 <SamB> duaneb: I usually define fI = fromIntegral if I have to use it more then once in the same screenful of code
15:02:27 <duaneb> SamB: good tip
15:02:31 <seydar> what's the haskell equivalent to packing and unpacking strings?
15:02:40 <SamB> makes it much more tolerable
15:02:45 <cocopumpkin> omg it's seydar
15:03:00 <mauke> seydar: what's the non-haskell equivalent?
15:03:11 <SamB> yeah, we thought that WAS a Haskell thing
15:03:17 <cocopumpkin> you want to extract binary int/float/other crap?
15:03:20 * wli usually gets it on repeated subexpression and does CSE by hand.
15:03:20 <cocopumpkin> like pack/unpack in ruby?
15:03:23 <mux> mmm, maybe FlexibleContexts would have helped
15:03:24 <dolio> cocopumpkin: Are you done proving your Cholesky decomposition correct?
15:03:26 <seydar> cocopumpkin: yea!
15:03:37 <seydar> cocopumpkin: wtf is up with your nick
15:03:40 <SamB> seydar: oh! like "struct" in python
15:03:50 <mauke> oh, like pack in perl
15:03:51 <seydar> SamB: yea!
15:03:53 <cocopumpkin> dolio: not yet! ;) I still need to write the basic matrix operations and prove those correct... ask me again in a month maybe :)
15:04:00 * mux wonders if seydar will make it to the HWN quotes
15:04:00 <cocopumpkin> seydar: Data.Binary.Get
15:04:01 <dolio> Heh.
15:04:02 <SamB> seydar: well, you could do something with Binary
15:04:10 <zloog> anyone know why my if inside a do block is causing a parse error in pattern error? the if line is the line # in question http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4850#a4850
15:04:14 <SamB> but not with the class, just the monads
15:04:15 <cocopumpkin> seydar: none of those ugly pack/unpack format strings though
15:04:29 <cocopumpkin> I can't get a damn bulleted list on the haskell wiki
15:04:34 <mauke> zloog: missing do in else
15:04:35 <roconnor> It kinda annoys me that GHC doesn't do CSE by itself.
15:04:36 <cocopumpkin> the asterisks aren't doing their job
15:04:50 <seydar> mux: what did i say that's HWNworthy?
15:04:52 <roconnor> I understand why it doesn't, but I'm annoyed.
15:05:02 <zloog> mauke: Ah ha, thanks
15:05:05 <SamB> roconnor: when ?
15:05:07 <cocopumpkin> we need an interactive compiler that asks us whether we want to do CSE at individual steps
15:05:16 <mux> seydar: this may be just me being very tired, but I somehow really enjoyed your remark on cocopumpkin's nickname
15:05:43 <roconnor> SamB: when what?
15:05:58 <cocopumpkin> seydar: I have several computers that tend to be connected to IRC at a time, so my first nick is pumpkin, my second is copumpkin, and my third is cocopumpkin
15:05:59 <SamB> doesn't it do CSE sometimes ?
15:06:43 <SamB> copumpkin: but isn't cocopumpkin == pumpkin ?
15:06:53 <Adamant> as long as one isn't "carvedpumpkin"
15:06:55 <copumpkin> SamB: shh, freenode doesn't know that
15:06:56 <dolio> It does sometimes, but it doesn't ask.
15:07:06 <roconnor> SamB: almost never
15:07:24 <hatds> it does CSE when doing so won't hold onto memory longer than you expect or something
15:07:30 <SamB> roconnor: well, the thing is it doesn't want to make a space leak
15:07:30 <dolio> It only does CSE when you have something like "let x = e in ... e ...".
15:07:32 <Gracenotes> I enjoy cocoa pumpkin as well
15:07:34 <Adamant> what is CSE?
15:07:44 <SamB> Adamant: Common Subexpression Elimination
15:07:47 <Adamant> ah
15:07:47 <mauke> but what about coconuts?
15:07:51 <mux> everytime I hear coworkers talking about marvellous and/or complicated regexps are, I feel like telling them that parsing combinators are infinitely more elegant and readable
15:07:57 <SamB> mauke: just nuts!
15:08:29 <copumpkin> coconuts = edwardk with his cofree comonads etc.
15:08:53 <copumpkin> cozygohistocomorphic prepromorphisms
15:08:53 <SamB> mux: aren't they just lousy non-recursive parser combinators without the parsing part ?
15:09:01 <copumpkin> gotta be careful to avoid copromorphisms though
15:09:08 <Botje> mux: are you going to clean up their branes when they actually read about parser combinators? :)
15:10:04 <ray> regular expressions are like... never mind
15:10:25 <Gracenotes> I have now recursived wget'd your soul
15:10:28 <monadic_kid> megalomanicism
15:10:52 <duaneb> what does mod1 do?
15:10:53 <ray> i was going to say regular bowel movements, but that's slightly disgusting and doesn't even make sense
15:11:16 <ray> JUST LIKE REGULAR EXPRESSIONS
15:11:24 <Gracenotes> regular expressions are nice on a theoretical level
15:11:30 <mauke> http://mauke.ath.cx/stuff/perl/fibcheck.pl (◔ ◡ ◔)
15:11:46 <Gracenotes> the problem is when people take things that aren't easily regular and fit them into regex by using obscure and difficult-to-understand features
15:11:52 * seydar fades
15:12:00 <mauke> sample input: x x xx xxx xxxxx
15:12:02 <Gracenotes> when just writing out the CFG would be easier and possibly more performant
15:12:09 <Gracenotes> and more understandable
15:12:43 <Taejo> any icfp contest organisers around? anybody know if there's going to be a team-size limit this year?
15:12:45 <ray> it would, but does perl have nifty context-free support?
15:12:46 <mux> some even comment their own multi-line regexps! how ironic is that
15:13:09 <duaneb> seriously
15:13:17 <duaneb> I can't even find mod1 on the googles
15:13:30 <Gracenotes> ray: alas, such is a problem. Most CFG parsers are very cumbersome, too general sometimes
15:15:19 <Gracenotes> hm. I wonder if I should take play analysis next semester
15:15:49 <c_wraith> as in pretending-to-be-math, or analyzing theater works?
15:16:21 <Peaker> mauke: what does the <> expression do in Perl?
15:16:50 <duaneb> peaker: it's equivalent to !=
15:16:58 <duaneb> OH WAIT
15:16:58 <duaneb> no
15:17:03 <duaneb> it reads a line from stdin
15:17:06 <duaneb> :|
15:17:14 <Peaker> duaneb: how does the same operator do these 2 different things? ahh!
15:17:15 <duaneb> print while (<>)
15:17:22 <mauke> Peaker: <> is the readline operator. if the operand is omitted, it reads from ARGV, which is a magic filehandle
15:17:41 <Gracenotes> c_wraith: analyzing theatrical works from various eras
15:17:44 <duaneb> cat() {perl -pe "print while(<>)"}
15:17:49 <Gracenotes> lot of reading, of course
15:17:56 <mauke> ARGV refers to all files specified on the command line (or STDIN if no args)
15:18:13 <c_wraith> Gracenotes: I'd take it.  Sounds like some fun.
15:18:16 <Peaker> mauke: does it logically concat the files?
15:18:21 <mauke> Peaker: yes
15:18:30 <mauke> duaneb: perl "-peprint<>"
15:18:30 <ziman> interesting :)
15:18:40 <Peaker> mauke: why is so much magic logic hidden in such a short name that happens to be the same name as the non-equal operator?
15:18:41 <mauke> duaneb: er, wtf
15:18:43 <mauke> duaneb: perl -p0
15:18:58 <mauke> Peaker: the non-equal operator is !=
15:18:59 <duaneb> mauke: that's cheating
15:19:03 <Gracenotes> cat = interact id
15:19:05 <Gracenotes> ... >_>
15:19:18 <Peaker> Gracenotes: cat concats multiple files, that's why its called cat
15:19:43 <mauke> Peaker: the name is so short because the functionality is very common in unix utilities
15:19:43 <Gracenotes> oh, yes, true. args are more cumbersome in Haskell... import module... rawr etc.
15:20:00 <copumpkin> meow
15:20:26 <Peaker> mauke: how does that syntax even add up?  <> is a valid name of a side-effecting function?
15:20:27 <Gracenotes> food denied
15:20:37 <mauke> Peaker: it's a circumfix operator
15:20:54 <Peaker> mauke: what's a "circumfix"?
15:21:02 <hatds> <like this>    ..?
15:21:03 <mauke> my $line = <$handle>;
15:21:21 <Peaker> so it both evaluates to a value and puts it inside $_ ?
15:21:26 <mauke> no
15:21:31 <mauke> it just evaluates to a value
15:21:52 <Peaker> so who puts it in the "global context variable" ($_ was its name right?)
15:21:56 <Peaker> (in the while (<>) .. case)
15:22:24 <mauke> there's a special rule in the compiler: if the condition of a while loop is a readline op, insert an assignment to $_
15:22:37 <Peaker> mauke: really??
15:22:43 <mauke> yes
15:22:44 <Peaker> mauke: those guys have no style, no style at all
15:23:12 <mauke> there's another rule: if the condition of a while loop is an assignment from a readline to a variable, wrap it in defined()
15:23:13 <seydar> copumpkin: so how would i use Data.Binary.Get to do: `"hello".unpack("C")`
15:23:27 <mauke> so this is actually: while (defined($_ = readline ARGV))
15:23:35 <Peaker> mauke: that sounds so ad-hoc that if I had to use Perl I'd cry
15:23:55 <mauke> Peaker: perl is full of ad-hoc but it can be damn useful
15:24:26 <Gracenotes> hm... looks like I might end up having 5 classes on Monday with this schedule
15:24:44 <Peaker> mauke: since its ad-hoc its also difficult to remember, and probably has many other negative consequences
15:25:00 <mauke> I don't find it hard to remember :-)
15:25:19 <mauke> I think it's possible to write in the sane subset of Perl
15:26:54 <cads> hey, do you guys know anything about code highlighters?
15:27:17 <Peaker> mauke: These <> thingies don't make a very sane impression
15:27:47 <mauke> Peaker: good thing I didn't tell you about the other meaning of <> then
15:27:59 <Botje> :)
15:28:00 <cads> hmm, there must be many free code highlighters, I'll look em up
15:28:16 <Botje> .. or the way it can be abused to have xml literals
15:28:20 <mauke> hehe
15:28:33 <mauke> Peaker: at least <> is syntactically unambiguous
15:29:20 <Botje> http://search.cpan.org/~audreyt/XML-Literal-0.02/lib/XML/Literal.pm # yay syntax!
15:30:26 * vixey has that in lisp too
15:30:35 <mauke> for bonus points, explain what <$ foo> does and how it differs from <$foo>
15:32:32 <seydar> pumpkin: you're killing me here
15:35:19 <mmorrow> what does "hello".unpack("C") mean?
15:35:43 * Baughn_ does a double take
15:35:44 <Botje> map ord "hello"
15:35:59 <Botje> iirc
15:36:04 <mmorrow> um, what is the "C" and what is being unpacked
15:36:05 <mmorrow> ?
15:36:16 <Botje> oh. is it like that in the source?
15:36:26 <mauke> perl says unpack "C", "hello" is 104
15:36:29 <mmorrow> seydar asked how to do that with Data.Binary
15:36:30 <Botje> then it concatenates "hello" to the result of unpacking $_ according to C
15:36:31 <Baughn_> mmorrow: unpack is basically Binary.decode, only returning a list of values
15:36:46 <mmorrow> what is the significance of "C"!!?! :)
15:36:55 <Botje> "ascii characters"
15:36:57 <Baughn_> It's the return type
15:37:03 <mmorrow> :o
15:37:07 <mmorrow> :)
15:37:14 <Botje> C   An unsigned char (octet) value.
15:37:21 <Botje> it's like a format string for scanf
15:37:23 <Botje> except much cooler :p
15:37:30 <Baughn_> ..more horrid, you mean
15:37:35 <mmorrow> encode . pack . fmap c2w
15:37:56 <seydar> mmorrow: is that the haskell for doing it?
15:37:58 <Baughn_> I have seen things you people wouldn't believe.. perl scripts on fire off the shoulder ofRMS...
15:38:04 <mmorrow> will chop Chars to 8 bits, pack that into a ByteString, and "encode" it (id in this case)
15:38:09 <mmorrow> seydar: yes
15:38:19 <mauke> mmorrow: http://perldoc.perl.org/functions/pack.html if you're interested :-)
15:38:23 <seydar> mmorrow: what library does that make use of?
15:38:28 <mmorrow> Data.Binary
15:38:29 <Botje> << sleep!
15:38:39 <mmorrow> (c2w = fromIntegral . ord)
15:38:50 <mmorrow> mauke: ohhh, that was perl
15:39:02 <mauke> mmorrow: no, but I think everyone else stole it from perl
15:39:06 <mmorrow> heh
15:39:34 <mmorrow> ah, ok i understand the "C" now..
15:40:22 <seydar> mmorrow: where does the pack function live?
15:40:29 <mmorrow> seydar: (well, pack is from Data.ByteString(.Lazy))
15:40:30 <neoswish> is there better way to this in TH: conP (mkName ":") ?
15:40:33 <mmorrow> heh
15:40:38 <mmorrow> , ':
15:40:44 <mmorrow> , conP ':
15:40:44 <lunabot>  luna: parse error on input `:'
15:40:45 <lunabot>  luna: parse error on input `:'
15:40:48 <mmorrow> , conP '(:)
15:40:49 <lunabot>  luna: No instance for (GHC.Show.Show
15:41:21 <Gracenotes> okay, I suppose I'll take the Moral Reasoning course
15:41:39 <mmorrow> , do [x,y] <- replicateM 2 (newName "x"); lamE [infixP (varP x) (conP '(:)) (varP y)] (varE x)
15:41:40 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
15:41:41 <Gracenotes> I often find myself wanting to refer to morality and ethics in debates and find myself a bit short on the history
15:41:53 <Gracenotes> although having a basic conceptual understanding
15:41:57 <mmorrow> , src ''InfixP
15:41:58 <lunabot>  luna: Not in scope: type constructor or class `InfixP'
15:41:59 <mmorrow> , src 'InfixP
15:42:08 <lunabot>  data Pat = ... | InfixP Pat Name Pat | ...
15:42:08 <lunabot>  infixl 9
15:42:12 <seydar> , putStrLn "hello"
15:42:14 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
15:42:16 <mmorrow> , do [x,y] <- replicateM 2 (newName "x"); lamE [infixP (varP x) '(:) (varP y)] (varE x)
15:42:18 <lunabot>  LamE [InfixP (VarP x_0) : (VarP x_1)] (VarE x_0)
15:42:20 <seydar> , "hello"
15:42:21 <lunabot>  "hello"
15:42:35 <mmorrow> , $(do [x,y] <- replicateM 2 (newName "x"); lamE [infixP (varP x) '(:) (varP y)] (varE x)) [42,99]
15:42:37 <lunabot>  42
15:42:47 <seydar> , encode . pack . fmap (fromIntegral . ord) $ "hello"
15:42:48 <lunabot>  luna: Not in scope: `encode'
15:42:52 <mmorrow> , ppDoc `fmap` do [x,y] <- replicateM 2 (newName "x"); lamE [infixP (varP x) '(:) (varP y)] (varE x)
15:42:54 <lunabot>  \(x_0 : x_1) -> x_0
15:43:04 <mmorrow> no Data.Binary of ByteString i'm afraid
15:43:15 <mmorrow> although there's no inherent reason why those are missing
15:43:29 <seydar> , pack . fmap (fromIntegral . ord) $ "hello"
15:43:30 <lunabot>  luna: Not in scope: `pack'
15:43:33 <mmorrow> , fmap (fromIntegral . ord) "hello" :: [Word8]
15:43:34 <lunabot>  [104,101,108,108,111]
15:43:34 <seydar> , fmap (fromIntegral . ord) $ "hello"
15:43:36 <lunabot>  [104,101,108,108,111]
15:44:01 <neoswish> mmorrow, thanks!
15:44:12 <mmorrow> neoswish: no problem
15:44:59 <mmorrow> , '()
15:45:00 <lunabot>  GHC.Unit.()
15:45:02 <mmorrow> , ''()
15:45:03 <lunabot>  GHC.Unit.()
15:45:07 <mmorrow> , ''Maybe
15:45:09 <lunabot>  Data.Maybe.Maybe
15:45:11 <mmorrow> , 'Maybe
15:45:12 <lunabot>  luna: Not in scope: data constructor `Maybe'
15:45:16 <seydar> mmorrow: my ghc is building atm, can you run the `encode . pack . fmap (fromIntegral . ord) $ "hello"` business for me?
15:45:17 <mmorrow> , 'Just
15:45:19 <lunabot>  Data.Maybe.Just
15:45:20 <mmorrow> , ''Just
15:45:21 <lunabot>  luna: Not in scope: type constructor or class `Just'
15:45:42 <mmorrow> seydar: to what end?
15:45:54 <seydar> mmorrow: i want to see what I get
15:45:55 <mmorrow> , fmap (fromIntegral . ord) "hello" :: [Word8]
15:45:56 <lunabot>  [104,101,108,108,111]
15:46:02 <mmorrow> is literally what you'll get
15:46:10 <mmorrow> (albeit in a bytestring)
15:46:22 <seydar> ooh, encode and pack are opposites
15:46:33 <mmorrow> pack and unpack are inverses
15:46:40 <mmorrow> encode and decode too
15:46:52 <seydar> but what about using pack and encode together?
15:46:57 <mmorrow> pack :: [Word8] -> ByteString
15:47:05 <mmorrow> unpack :: ByteString -> [Word8]
15:47:16 <seydar> gablork
15:47:18 <mmorrow> seydar: encode on a ByteString is id
15:47:28 <mmorrow> because it doesn't have to do anything
15:47:45 <Baughn_> That's not quite true, is it?
15:47:47 <mmorrow> (encode can work on *any* type that's an instance of Binary)
15:47:52 <Baughn_> It has to store the length of the bytestring
15:47:55 <mmorrow> Baughn_: yes
15:47:55 <seydar> so how do i encode it in a certain format (ideally specified by the whole letting system)?
15:48:06 <Baughn_> Oh, wait..
15:48:12 <Baughn_> Never mind. Doh. Of course it doesn't
15:48:15 <mmorrow> Baughn_: (it does store the length)
15:48:31 <mmorrow> (which i found out the hard way the other day :)
15:48:45 <Baughn_> Mm. I shouldn't try to think at 1am
15:48:52 <Baughn_> But that makes it not-id, then
15:49:00 <mmorrow> yeah
15:49:21 <copumpkin> iterate encode (pack . map (fromIntegral . ord) $ "moo")
15:50:05 <seydar> is there any way to pack a list into a binary string based on the format that ruby, python, perl use?
15:50:22 <mmorrow> seydar: sure, just find out what that format is then do it :)
15:50:52 <seydar> mmorrow: what do you mean "then do it"?
15:51:14 <dons> seydar: via a Binary instance
15:51:24 <dons> you'd write the serialisation code (easy, in the Get / Put monads)
15:51:37 <dons> then you'd have a data sync between haskell <=> ruby/python
15:51:51 <mmorrow> , let toCString = (++"\0") . fmap (chr . min 255 . ord) in toCString "omg∀"
15:51:52 <lunabot>  "omg\255\NUL"
15:52:00 <copumpkin> seydar: there are issues with that in haskell though
15:52:00 <copumpkin> seydar: the contents (the value) of the string constrains the type of the parameters
15:52:16 <copumpkin> seydar: the ruby/python/perl technique is fugly anyway, I always hated it
15:52:25 <seydar> i gotta bounce
15:52:29 <copumpkin> those format strings are terrible :P
15:52:37 <seydar> but rest assured i will return and keep asking you guys what's up
15:52:45 <seydar> maybe when i get back GHC will be built!
15:52:50 <seydar> i hope
15:55:06 <Cale> Wait, why is seydar building GHC?
15:55:34 <Cale> Oh well.
15:57:12 <duaneb> what are haskell's order of operations?
15:57:39 <Cale> Which order of operations do you mean?
15:57:49 <Cale> Like, how operators get grouped?
15:57:59 <Cale> Or what order expressions are evaluated in?
15:58:17 <copumpkin> Cale: I think he's installing from macports
15:58:30 <copumpkin> which loves to waste cycles making everyone recompile everything from scratch
15:58:38 <Cale> Silly.
15:58:49 <Cale> I would never accept that situation.
15:59:07 <Cale> There's a mac binary isn't there?
15:59:23 <copumpkin> yup
15:59:27 <copumpkin> not sure why he wasn't using it
15:59:43 <Cale> Maybe he doesn't have 10.5
16:00:06 <Cale> There are so many incompatibilities between point versions of OS X.
16:10:10 <jonafan> i've begun to learn a haskell
16:10:21 <copumpkin> did bonus learn it you?
16:10:39 <jonafan> yes
16:11:01 <jonafan> coming from ocaml, typeclasses seem like a pretty good idea
16:12:51 <vixey> and being able to declare fixities of operators :/
16:13:37 <jonafan> that is nonsense to me
16:13:54 <vixey> what is?
16:14:00 <jonafan> fixities of operators?
16:14:24 <vixey> you know operators like + and so on
16:14:33 <vixey> in ocaml you can't set the fixities which is annoying
16:14:36 <Apocalisp> Has somebody written a bidirectional dictionary datastructure?
16:15:00 <jonafan> oh you mean so you don't need +. and +/ and whatever else
16:15:11 <vixey> no typeclasses is what lets you not need +.
16:16:48 <mauke> jonafan: operator precedence and associativity
16:17:19 <jonafan> oh...
16:21:39 <Peaker> Apocalisp: ya, I have
16:22:38 <Peaker> Apocalisp: (Ord k1, Ord k2) => MapManyToOne k1 k2
16:24:33 <Apocalisp> Peaker: How's it structured? Two Sets of pairs with the Ord comapped fst and snd respectively?
16:25:23 <Peaker> Apocalisp: MapManyToOne { forward :: Map.Map k1 k2,
16:25:24 <Peaker>                                                                backward :: Map.Map k2 (Set.Set k1) }
16:25:38 <Apocalisp> ah, two maps
16:26:53 <Peaker> Apocalisp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4851#a4851
16:27:26 <Apocalisp> Peaker: Looks win.
16:27:56 <Peaker> Apocalisp: its a bit old -- I see that I've learned many things since :)
16:29:03 <Apocalisp> I'd like to write two structures, one "ManyToMany" (in your terms), and another where both keys are unique.
16:30:03 <nomeata> Hi. Is there a quick workaroung http://hackage.haskell.org/trac/ghc/ticket/2847 ? I’d like to compile yhc with ghc-6.10.1.
16:30:53 <Peaker> Apocalisp: I think its perhaps wrong that I throw pure exceptions there
16:31:12 <Peaker> Apocalisp: as deletions from sets/maps of inexistent keys work, but my function might cause a pure exception
16:31:40 <Apocalisp> minor detail
16:31:58 <Peaker> Apocalisp: but yeah ManyToMany and OneToOne sound useful too
16:32:19 <wli> General relations need hairy indexing.
16:32:35 <pejo> nomeata, just sed all the sources and replace the unknown pragmas with something known that you don't care about?
16:32:44 <Apocalisp> wli: I suspect so.
16:33:10 <nomeata> pejo: won’t that break drift? or is drift not needed for yhc?
16:33:28 <Peaker> ManyToMany just means both maps' values are sets, and OneToOne means overwriting stuff in both maps
16:33:33 <Peaker> (when adding)
16:33:42 <nomeata> I mean, the pragmas (OPTIONS_DRIFT in this case) are there for a reason, I presume.
16:33:43 <pejo> nomeata, ah, bummer. Sorry, no idea then.
16:34:24 <edmccaffrey> Cabal install is using all my memory on an attempt to install anything.  My searches only came up with specific version conflicts--but I am not using those versions.  I'm using 6.8.2 of ghc  and 0.5.2 of cabal-install.
16:34:27 <Peaker> Apocalisp: maybe I ought to fix that library to nicer form, add OneToOne and ManyToMany and cabalize it under Data.Maps...
16:34:27 <Apocalisp> Peaker: I would probably implement OneToOne as two sets rather than two maps.
16:34:54 <dcoutts> edmccaffrey: are you quite sure you're not using ghc-6.10 ?
16:34:56 <Peaker> Apocalisp: Sets have indices in them?
16:35:16 <edmccaffrey> Yes, I just did ghc --version
16:35:28 <dcoutts> edmccaffrey: I'd point you at this FAQ entry, but it only applies to ghc 6.10
16:35:29 <dcoutts> http://haskell.org/cabal/FAQ.html#cabal-goes-into-an-infinite-loop--runs-out-of-memory
16:35:49 <dcoutts> edmccaffrey: have you ever installed 6.10 ?
16:35:50 <Apocalisp> Peaker: Each set having its own Ord (k1, k2) that ignores one or the other half of the pair.
16:35:51 <Peaker> Apocalisp: How do you use 2 sets to map corresponding elements?
16:35:57 <dcoutts> edmccaffrey: when did cabal start doing this?
16:36:08 <edmccaffrey> Yeah, that's what I read, but the versions don't match mine.
16:36:30 <Apocalisp> Peaker: So two sets of the same pairs.
16:36:34 <Peaker> Apocalisp: isn't a Set of (k,v) equivalent to a Map k v -- only possibly less convenient?
16:36:38 <edmccaffrey> Just today--but I have only used cabal-install a while ago
16:37:08 <dcoutts> edmccaffrey: if you run it with -v3, where does it get stuck? perhaps you can post a log at hpaste.org
16:39:13 <jmcarthur> Peaker: not equivalent, i think. Set (k, v) might be equivalent to Map k [v], though
16:39:50 <Peaker> jmcarthur: I should have repeated what Apocalisp said about Ord ignoring half of the tuple
16:39:58 <jmcarthur> oh
16:40:04 <jmcarthur> i didn't read up
16:40:06 <jmcarthur> just got home
16:40:23 <edmccaffrey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4852#a4852   -- Earlier it was still resolving dependencies after 30 mins.
16:40:25 <Peaker> Apocalisp: why do you prefer the set of pairs over map?
16:40:48 <Apocalisp> Peaker: Right you are. I guess I was making presumptions about space and performance.
16:40:55 <Apocalisp> probably unwarranted
16:43:10 <Peaker> Apocalisp: if you do fix up my pasted code there, please send me back the fixed up one and maybe I can cabalize it
16:44:08 <Peaker> there's a bimap cabal package already (Data.Bimap) that's a OneToOneMap
16:44:30 <Peaker> and there's ManyToOne (if that code is cleaned) so only missing is ManyToMany
16:44:35 <dcoutts> edmccaffrey: hmm, well I can't explain it. Try the latest version of cabal-install anyway.
16:45:06 <dcoutts> edmccaffrey: since your current cabal isn't working I guess you'll have to bootstrap it, but there's a script to do that in the tarball
16:45:30 <edmccaffrey> Yeah, I'll do that.  Thanks.
16:56:47 <PetRat> I'm trying to understand lists as monads, and desugaring do-blocks. http://www.mibbit.com/pb/OhklhZ  Why do test3 and test4 not give the same result?
16:57:54 <adamvo> PetRat: notice the return absent from test3?
16:57:58 <bos> PetRat: you have a return in one, but not the other
16:58:56 <adamvo> > [1,2,3] >>= \i -> [i:[4,5,6]]
16:58:58 <lambdabot>   [[1,4,5,6],[2,4,5,6],[3,4,5,6]]
16:59:38 <Axman6> > concatMap (\i -> i : [4..6]) [1..3]
16:59:39 <lambdabot>   [1,4,5,6,2,4,5,6,3,4,5,6]
16:59:45 <dolio> > (:[4,5,6]) <$> [1,2,3]
16:59:46 <lambdabot>   [[1,4,5,6],[2,4,5,6],[3,4,5,6]]
16:59:51 <Axman6> > concatMap (\i -> [i : [4..6]]) [1..3]
16:59:52 <lambdabot>   [[1,4,5,6],[2,4,5,6],[3,4,5,6]]
17:00:06 <PetRat> is "return" sugar? I guess not.
17:00:16 <PetRat> how to implement test3 in do-notation?
17:00:31 <Axman6> PetRat: just remove the return
17:00:43 <Axman6> PetRat: using concatMap is a good way to uderstand the list monad, since >>= = concatMap
17:01:33 <Axman6> > let test4 x y = do { i <- x; i : y} in test4 [1,2,3] [4,5,6]
17:01:34 <lambdabot>   [1,4,5,6,2,4,5,6,3,4,5,6]
17:01:41 <PetRat> okay I get it.
17:02:03 <PetRat> I'm also still working chap 14 in RWH, and I think it explains the list monad pretty well.
17:02:16 <Axman6> the result of a do block is what's returned by the last expression ( i think, i'm no expert)
17:02:29 <adamvo> Axman6: flip concatMap?
17:02:41 <Axman6> well yeah
17:03:01 <Axman6> but, i was just talking about what it does, not its definition
17:03:32 <PetRat> I was under the impression that return is necessary to inject a value into the monad---but I just realized what's special about my example. The last expression, i:y is already a monad (i.e. already a list).
17:04:02 <Axman6> yep
17:04:04 <adamvo> yeah, that was a pointless nitpick on my part
17:04:08 <PetRat> "return" is not necessary, I guess, if the last expression in a do block is of monadic type.
17:04:13 <mauke> x >>= \i -> (i : y) >>= \t -> return t
17:04:30 <Axman6> and that's the reason why you can say do print x; print y, ewithout needing a return
17:04:32 <Cale> It's inappropriate to say that any value is a monad, since monads are type constructors ;)
17:05:07 <Cale> (but your reasoning is correct)
17:05:17 <Axman6> Cale: depends on who your company is at the time :P
17:05:20 <PetRat> "a valud of monadic type"
17:05:24 <PetRat> ?
17:05:34 <Cale> yeah, or computation or action
17:06:03 <mauke> my brain says 'join' is related. I'm not sure if I want to believe it
17:06:07 <dons> so what's hot in haskell land today?
17:06:11 <dons> have we won yet?
17:06:20 <roconnor> dons: we are making a new haskell
17:06:23 <dons> ooh
17:06:23 <dibblego> yes, we're just notifying everyone now
17:06:34 <dons> dibblego: phew! glad i just got here in time.
17:06:50 <vixey> roconnor: You're actually going trhough with it
17:06:50 <roconnor> @quote Windows
17:06:50 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
17:06:54 <Axman6> dons: i'm planning on rewriting ANU's second year VM/computer simulator thing in haskell to imrove maintainability :)
17:06:57 <roconnor> @quote Windows.98
17:06:57 <lambdabot> edwardk says: Haskell 98 is the Windows 98 of standards ;)
17:07:03 <dons> Axman6: sweet.
17:07:09 <vixey> can it be called unsafePerformHaskell#
17:07:14 <roconnor> :)
17:07:32 <Cale> It is annoying that there are all these little changes which almost everyone would like to see, but very little real motion toward implementing them in GHC where they could be used.
17:07:42 <Axman6> our lecturer said that a few years ago, he went around the department with a $10,000 wad of cash, hoping the PhD students would sniff it, and fix the Tcl/Tk/Tix/C implementation
17:08:04 <dons> Cale: did you notice the trend for bugs fixed, and libs proposed, now the platform is in place?
17:08:17 <dons> means there's a 'user' demanding lib / hackage / feature changes
17:08:23 <Axman6> there were a few interested people, but they all thought it was too hard
17:08:49 <Axman6> before i'd heard this, i'd already thought how nice it would be to rewrite it in haskell...
17:08:50 <Cale> dons: Well yeah, in that setting things have been going well.
17:09:04 <Axman6> so, moral of the story is, Axman6 > ANU PhD students
17:09:18 <Cale> But for the stuff which Haskell 98 specifies, there's been almost no motion.
17:09:20 <Axman6> (though he'd like to be one of those one day)
17:09:25 <gwern> anyone here familiar with pagers? how can one trace a pager back to its owner?
17:09:42 <Adamant> gwern: two way or one way?
17:09:42 <SamB> gwern: what ? less has an owner ?
17:09:54 <Axman6> bah, need to get going
17:09:56 <gwern> Adamant: there's no keyboard or anything, so one way
17:10:07 <vixey> what the hell is a Tcl/Tk/Tix/C
17:10:14 <gwern> certainly would make it easier if I could reply to the 4 useless messages saying 'did you find my pager marwan'
17:10:26 <gwern> SamB: why, GNU of course
17:10:38 <Adamant> gwern: talk to the pager company?
17:10:45 <dons> Axman6: but we roll machine simulators all day in haskell
17:10:50 * dons isn't sure what's hard there.
17:10:53 <Adamant> gwern: there's no easy way to do it otherwise AFAIK
17:10:54 <gwern> Adamant: I don't even know who that is. how would I find out?
17:10:58 <Cale> vixey: Tcl is a programming language, and if I'm not mistaken, Tk is a GUI library for it. As for Tix, I'm not sure.
17:11:09 <Adamant> gwern: look at who provided paging services in your local area
17:11:13 <Cale> vixey: I'm sure you know what C is :)
17:11:27 <gwern> Adamant: each area has only one paging company?
17:11:39 <Adamant> gwern: not one, but not a lot of them in general
17:11:46 <Adamant> shouldn't take too many calls
17:11:55 <Adamant> check your local Yellow Pages/phonebook
17:11:56 <gwern> auggh. so basically call them up and ask them 'do you control this number?'
17:12:07 <Adamant> yeah unfortunately
17:12:08 <dons> Axman6: fwiw, cycle-accurate machine simulators in haskell is one of galois' core products (so yeah, you can do this)
17:12:09 <Adamant> sorry man
17:12:11 <gwern> (thankfully, the owner wrote the pager's number. on the pager. but not his own)
17:12:27 <Cale> ah, apparently Tix is an interface extension which adds some extra widgets to Tk
17:12:41 <gwern> dons: really? I thought galois mostly did compilers and dsls; didn't know you guys did emulation too
17:12:50 <dons> oh, most definitely.
17:13:02 <dons> gwern: for modelling and simulation, in order to identify faults
17:13:29 <gwern> hm. maybe I'm just biased by what you've released and the pr with cryptol
17:13:32 <dons> actually, simulators make a big part of the recent publications, http://www.galois.com/blog/research-catalog/
17:13:34 <Adamant> gwern: pagers receive one-way from radio towers if they're a one way pager, so there's no interactivity
17:13:47 <gwern> figured as much :(
17:13:49 <dons> cryptol's just really hot at the moment, due to the new SHA candidates
17:14:40 * dons wants to find a copy of launchbury's first paper, "    * Guy Argo, John Hughes, Philip W. Trinder, Jon Fairbairn, John Launchbury: Implementing Functional Databases. DBPL 1987: 165-176
17:14:41 <Peaker> Adamant: so if you're where there's no reception your pager will never deliver the message?
17:14:44 <dons> "
17:14:55 <Adamant> Peaker: they repeat it for a bit, I think
17:15:36 <gwern> I think the pagers must forget pretty quickly. this one has 4 messages, but they're numbered 92-96
17:16:15 <gwern> dons: DBPL?
17:16:16 <Adamant> Peaker: all I know about pagers comes from a "Hacker's Challenge" book though, this isn't exactly my area of expertise
17:16:30 <Adamant> gwern: you could try asking on ##electronics
17:16:37 <gwern> not a bad idea
17:16:42 <Adamant> maybe they know something I don't
17:16:48 <kyevan> Hmm... Haskell doesn't like dumb text editors, does it?
17:17:02 <dons> kyevan: how dumb?
17:17:05 <dons> vi-dumb?
17:17:17 <gwern> (but dinner first)
17:17:22 <kyevan> notepad-dumb.
17:17:35 <kyevan> (Well, slightly smarter than that, but close enough)
17:18:43 <kyevan> The main problem is that it uses indentation for meaning >_<
17:19:09 <ray> correct layout's really not that hard
17:19:16 <dons> but editors are rarely aware of that, anyway
17:19:22 <ray> correct layout's really not that hard for a human*
17:19:26 <c_wraith> it doesn't have to.  You can always use { ; } explicitly
17:19:29 <dons> there's only 2 (?) layout-aware editors for haskell, and they're not widely used
17:19:31 <mauke> layout is optional
17:19:36 <dons> its cool, but not a killer feature to ahve
17:19:50 <roconnor> dons: is one of them Yi?
17:19:55 <dons> yeah
17:20:01 <dons> the other is leksah
17:20:04 <roconnor> I should start using Yi
17:20:13 <roconnor> or maybe leksah
17:20:20 <kyevan> dons: Layout-aware isn't what I mean, though.
17:20:31 <dons> oh, you just want monospace fonts?
17:20:42 <kyevan> inserting 'n' spaces when I push tab, on the other hand...
17:20:57 <dons> right.
17:20:59 <dons> you don't want tabs
17:21:17 <bremner> dons: emacs isn't layout aware (enough?)
17:21:37 <dons> probably enough for most people, yes. its very popular
17:21:45 <kyevan> dons: So Haskell doesn't like dumb editors.
17:21:51 <kyevan> And, ugh emacs >_<
17:21:59 <mauke> meh
17:22:28 <mauke> just write in the whitespace-free subset of haskell
17:22:41 <SamB> some people do that for papers anyway ;-)
17:23:08 <dons> kyevan: tab-unaware is dumb, so yeah, i guess
17:23:14 <dons> it'd be annoying
17:23:26 <kyevan_> Also: Wifi + thunder storm = not fun :P
17:23:55 <mauke> main::IO();main=putStr"Hello,\x20World!\n"
17:24:14 <c_wraith> The emacs mode likes to suggest indentations that won't compile as the only indentation in certain cases.
17:24:24 <c_wraith> Clearly, it's not *that* aware
17:25:03 <kerlo> Hi, kyevan.
17:25:05 <ray> nobody wants the headache of writing a layout-aware emacs mode
17:25:15 <vixey> nobody wants to write emacs mode ... :/
17:25:20 <ray> at least i don't, i already have chronic sinus problems
17:25:26 <mauke> is it possible to write a 'module' declaration without whitespace?
17:25:30 <ray> a few emacs fanatics like writing emacs modes, probably
17:25:40 <kyevan__> And, yeah...
17:25:45 <ray> does module Module where; not work?
17:25:50 <mauke> contains whitespace
17:26:08 <kyevan__> The problem seems to be that there's no sane text editor >_<
17:26:08 <ray> oh, no whitespace at all
17:26:22 <kyevan__> Everything is either too stupid or too big.
17:26:32 <ray> i don't think semicolons would work there
17:26:33 <skorpan> kyevan__: i happen to know that yi will have *the* haskell mode soon enough
17:26:45 <kyevan__> yi?
17:26:52 <mauke> bah, even class declarations don't work
17:27:11 <skorpan> an editor which acts like emacs or vi, depending on what you want, and is written in haskell
17:27:16 <ray> i guess haskell is too whitespace sensitive
17:27:27 <kerlo> So, layout. Can someone just quickly specify it to me? :-)
17:27:37 <mauke> C is clearly superior
17:27:42 <ray> indent things that are part of some higher-level thing more
17:27:52 <ray> indent things that are part of the same thing the same
17:27:57 <ray> i think that covers most of it
17:28:10 <kerlo> That's not really a specification.
17:28:12 <c_wraith> If only it was actually that simple. >_>
17:28:22 <c_wraith> kerlo, that's just about how python is specified
17:28:42 <kerlo> kyevan___: are you by any chance missing half the conversation?
17:28:52 <Kyevan> Probably.
17:29:16 <c_wraith> Haskell has some oddities.  like you can't put if, then, and else at the same column in a do block, but you can if you're not in a do block.  wtf?
17:29:54 <ray> if if were if' you wouldn't have then and else to worry about
17:30:04 <vixey> if sucks
17:30:08 <mauke> c_wraith: if you're not in a do block, whitespace doesn't matter
17:30:16 <Kyevan> Anyway, what is yi?
17:30:17 <vixey> if' sucks too
17:30:26 <skorpan> Kyevan: i told you
17:30:32 <ray> (??) is the best
17:30:37 <skorpan> [02:27] <skorpan> an editor which acts like emacs or vi, depending on what you want, and is written in haskell
17:30:39 <Kyevan> skorpan: Not that I saw.
17:30:45 <kerlo> Since you can't really just-quickly-specify layout (apparently), how is layout specified? Some sort of addition to BNF?
17:30:54 <Kyevan> I'm having unstable network because of wifi + thunderstorm
17:31:00 <Kyevan> Seems to be settling down now.
17:31:05 <c_wraith> Mauke, whitespace still matters outside of do blocks.  In things like let decls, for instance.
17:31:12 <Kyevan> And, anyway... so another editor on the too big side of things.
17:31:27 <skorpan> Kyevan: too big?
17:31:44 <mauke> c_wraith: ok, whitespace doesn't matter outside of "layout aware" stuff. this includes do, let, where, of; but only if you don't use explicit braces
17:31:48 <inimino> Kyevan: it's explained in about 10 sentences in the Haskell 98 Report
17:31:50 <inimino> erm, s/Kyevan/kerlo
17:31:56 <kerlo> Let me take a moment to tout the advantages of bouncers. This concludes this moment; you may continue.
17:32:13 <ray> i don't think the report formally specifies layout
17:32:16 <mauke> kerlo: some keywords trigger layout if they're not followed by '{'
17:32:22 <inimino> ray: it does.
17:32:49 <kerlo> inimino: since I actually shuddered at that statement, I'm going to be quiet now.
17:32:58 <ray> which section
17:33:04 <inimino> I don't remember
17:33:15 <ray> let me peruse it
17:33:30 <mauke> kerlo: the next token specifies the "base indentation" for the following block. if a line starts at the base indentation level, the parser generates a virtual ';'. if a line starts before that, the parser inserts a '}' and ends that block
17:33:31 <Kyevan> It's "too big" if the functionality necessitates non-trivial UI
17:33:54 <Kyevan> EG, emacs or vi's insane commands to save and quit,
17:34:12 <inimino> ray: 2.7 and 9.3
17:34:19 <ray> ah, there it is, 9.3
17:34:24 <Kyevan> Also it's pretty worthless docs :P
17:34:32 <Kyevan> "    * How do I install Yi?
17:34:32 <Kyevan>     get it from Hackage. Configure, compile and install Yi as you would do for any other Cabal package. "
17:34:48 <inimino> "insane"?
17:34:49 <skorpan> Kyevan: there's "notepad" (CUA) bindings for yi as well :P
17:34:51 <Kyevan> That is about as informative as <fill in later>
17:34:57 <mauke> Kyevan: how so?
17:35:10 <mauke> that tells me exactly what to do
17:35:37 <Kyevan> mauke: Well, how many goats do I need to sacrifice, etc?
17:35:45 <mauke> none
17:35:48 <inimino> only to someone who doesn't know what Cabal is and is incapable of using Google to find out
17:36:11 <bremner> Kyevan: I don't think Yi is developed to the stage that someone who thinks those instructions are mysterious will be happy with it.
17:36:27 <Kyevan> >_<
17:36:30 <Kyevan> So, basicallyh
17:36:39 <Kyevan> Haskell is designed to be unusable?
17:36:51 <mauke> what
17:36:51 <vixey> yes
17:36:52 <bremner> my, aren't we testy :-)
17:37:01 <bremner> avoid success at all costs
17:37:11 <Kyevan> Because: you need a crazy editor or one that's designed such that only haskell-culture-gods can use it, for it to be usable?
17:37:29 <skorpan> Kyevan: go program something else then, you don't seem to want help anyways
17:37:32 <mauke> Kyevan: how did you arrive at that conclusion?
17:37:43 <vixey> skorpan shush
17:37:46 <Kyevan> Well.
17:37:50 <inimino> Haskell is probably unusable to a large subset of people who think vi and emacs are "insane"
17:38:10 <Kyevan> Basically, you've all been saying "vi, emacs, or yi which is unusable until you get into the culture"
17:38:14 <inimino> (but then so are other programming languages)
17:38:16 <vixey> text editing???
17:38:18 <Kyevan> inimino: >_<
17:38:20 <mauke> I've written Haskell in notepad before
17:38:26 <mauke> what's the problem?
17:38:28 <kerlo> I always write Haskell in Notepad.
17:38:37 <mauke> kerlo: you're insane
17:38:39 <skorpan> i heard koen claessen uses gedit...
17:38:46 <Kyevan> mauke: I like my tab button, is the problem. >_>
17:38:47 <kerlo> Or, what's it called, gedit?
17:38:53 <mauke> Kyevan: yes, and?
17:38:59 <mauke> Kyevan: how is that a problem?
17:39:09 <pejo> Kyevan, TextMate has a Haskell mode. I think a colleague runs "Smultron". He used to use jEdit, I think. Just select any editor you like.
17:39:28 <Kyevan> TextMate is also a good hundred dollars per user >_>
17:39:48 <inimino> Kyevan: sounds like Notepad is what you want
17:39:50 <Kyevan> mutBut yeah...
17:39:53 <Kyevan> Basically.
17:39:53 <Asztal> Haskell treats tabs exactly as notepad does, how handy
17:40:02 <skorpan> Kyevan: so let me get this straight... you want notepad-dump, but with no magical indentation? give gedit a serious try.
17:40:03 <Kyevan> I'm complaining about the layout rules.
17:40:15 <skorpan> s/dump/dumb/
17:40:16 <mauke> Kyevan: what is your complaint?
17:40:24 <Kyevan> IT USES WHITESPACE.
17:40:29 <mauke> Kyevan: no, you do
17:40:37 <Kyevan> 'That becomes inherently ambiguous.
17:40:42 <mauke> the whitespace sensitive part is optional
17:40:47 <skorpan> can't you write lhs?
17:41:08 <Kyevan> London Health Society?
17:41:09 <kerlo> Was that "that" a continuation of the previous sentence or a pronoun?
17:41:31 <Kyevan> Ligiment Housing System?
17:41:39 <kerlo> Literate Haskell, I believe.
17:42:15 <Kyevan> Anyway... I should provbably leave for a while...
17:42:31 <Kyevan> External issues are making me really agitated, and I've just realized I'm being a dick again >_<
17:42:37 <Kyevan> Sorry...
17:42:51 <bremner> apology accepted
17:42:54 <mauke> it's not ambiguous, no one forces you to use it, how is that a problem in any non-malicious editor, etc
17:47:56 <mauke> http://rafb.net/p/L7od2H16.html
17:49:37 * sjanssen vomits
17:50:10 <mauke> just to show that if you want ugly indentation in haskell, you can have it
17:55:01 <roconnor> FRP Web Framework?
17:55:06 <roconnor> does that even make sense?
17:55:34 <skorpan> what about it is contradictory?
17:55:38 <ray> how can web stuff be reactive?
17:55:55 <roconnor> hmm
17:56:05 <roconnor> maybe the javascript part can be reactive.
17:56:55 <skorpan> i don't see the problem, please explain :P
17:57:30 <bogner> skorpan: the web is stateless, so all of the functions would be at time 0, as far as I can imagine
17:59:28 <skorpan> depends on what you mean by web, doesn't it?
18:00:21 <pejo> bogner, in reality things aren't stateless. You have a shopping cart, or a login to the system, etc.
18:16:18 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:16:18 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
18:16:54 <sgwizdak> So, I'm doing a runhaskell Setup configure on a package -- fails with "Setup: At least the following dependencies are missing: SDL -any, SDL-mixer -any" however, ghc-pkg list shows both SDL-0.5.5 and SDL-mixer-0.5.5 as both living in my .ghc directory
18:18:29 <Lemmih> sgwizdak: --user?
18:19:28 <sgwizdak> Lemmih, I'm a newbie with this, but I'm executing everything as the same user, do I have to be explicit?'
18:19:53 <Nafai> sgwizdak: --user is a argument to runhaskell Setup for both configure and install
18:20:00 <roconnor> How do I do class Foo a b | a -> b, b -> a  with type families?
18:21:24 <sgwizdak> Nafai, ah, ok. So that merely tells runhaskell that it should look at the user's local directory for packages?
18:22:13 <sgwizdak> Lemmih, Nafai: thanks, that worked
18:22:52 <roconnor> hmm, maybe I use equality constraints somehow
18:24:05 <dolio> class (b ~ T1 a, a ~ T2 b) => Foo a b where T1 a :: * ; T2 b :: * ; ...
18:24:10 <dolio> Or something of that sort.
18:24:22 <roconnor> right
18:24:37 <dolio> Except, you can't do that yet, because equality requirements like that don't currently work or something.
18:25:57 <dolio> That's a case where you'd want a fundep notation even if you're using solely type families machinery, I think.
18:26:30 <roconnor> oh
18:26:38 <roconnor> is fundeps becoming notation?
18:28:27 <dolio> Well, not in the immediate future, but it's conceivable.
18:29:18 <roconnor> oh wow, I didn't realize that type families are not the same as associated types
18:29:31 <byorgey> sgwizdak: not only that it should look there, but that it should configure the package to be installed there
18:29:44 <dolio> Maintaining two separate systems that mostly do the same thing, but have various inconsistencies can't be making GHC more clean. :)
18:30:07 <byorgey> sgwizdak: you can also install packages globally (as root) but then you can only use other packages which are also installed globally.
18:30:38 <byorgey> roconnor: associated types are implemented in terms of type families, IIUC
18:32:57 <roconnor> what's the difference between data family and type family?
18:33:42 <dolio> data families are like data, type families are like type.
18:36:15 <roconnor> so data instances can have sums?
18:36:30 <dolio> Yeah.
18:37:14 <dolio> I suppose they have technical differences that are of importance, too. Like data families are injective.
18:37:25 <dolio> And the type checker knows that.
18:37:30 <roconnor> so you could (almost) remove data family declairations and just make data types and use them as the results of type family instances?
18:37:53 <dolio> Yes, except for the injectivity thing.
18:38:10 <roconnor> Okay.  I don't get your injectivity remark then.
18:38:36 <dolio> If Foo is a dat a family, and you know Foo a ~ Foo b, then you can deduce a ~ b.
18:38:53 <dolio> But if Foo is a type family, then you can't.
18:38:54 <roconnor> a right
18:39:13 <roconnor> so each data family instance must be branded
18:39:54 <seydar> god dammit it's still compiling for me
18:40:00 <seydar> ghc 6.10 has taken over 3 hours
18:41:28 <roconnor> I'd expect type families to be more popular that data families
18:41:44 <roconnor> but probably because I'm corrupted by fundeps
18:42:24 <dolio> Well, data families fit pretty well with, say, generalized tries.
18:42:41 <roconnor> I don't know what a generalized trie is.
18:43:03 <dolio> But type families are what you replace MTL fundeps with and such.
18:44:00 <shapr> whee!
18:44:10 <roconnor> @get-shapr
18:44:10 <lambdabot> shapr!!
18:44:15 <shapr> Hiya!
18:44:19 <roconnor> hi
18:44:41 <dolio> Generalized tries are where you use algebraic laws for A^B to encode tries with keys of type B.
18:45:17 <roconnor> and why are data families better than type families here?
18:46:10 <dolio> Because otherwise you'd end up defining various types like "ListTrie" and using a fundep/associated type to point at it.
18:46:20 <dolio> Might as well just put the constructors directly in an associated data.
18:46:24 <roconnor> ok
18:46:35 <duaneb> How can I declare a a typeclass argument in an object?
18:46:42 <roconnor> I figured types for these things would already be out there
18:49:20 <PetRat> How come the Haddock docs for Data.Map.lookup give its type as [ lookup :: Ord k => k -> Map k a -> Maybe a] while checking it at the ghci prompt gives (Ord k,Monad m) => k -> Map k a -> m a? It implies that somehow the return type is really more general than Maybe, tho I don't know what use to make of that.
18:49:59 <duaneb> Can I do this?
18:50:03 <Saizan__> PetRat: you've an older version
18:50:15 <duaneb> data NumTree (Num a) = NumTree a -> whatever?
18:50:17 <PetRat> of which? ghci or Haddock?
18:50:28 <Saizan__> duaneb: what do you mean by "a typeclass argument in an object"?
18:50:35 <PetRat> I'm looking at the docs linked from haskell.org
18:50:50 <duaneb> Saizan__: I mean that instead of a pure polymorphic type, I want a member of a typeclass
18:50:56 <Saizan__> PetRat: of the containers library that contains Data.Map
18:51:10 <JoshTriplett> Under what circumstances does pattern matching require an instance of Eq?
18:51:10 <lambdabot> JoshTriplett: You have 1 new message. '/msg lambdabot @messages' to read it.
18:51:16 <duaneb> i.e. instead of Tree a = Leaf a | Branch a (Tree a) (Tree a)
18:51:17 <Saizan__> PetRat: the type has been restricted in a later version
18:51:27 <duaneb> I would have Tree (Num a) = Lead a etc
18:51:33 <PetRat> Saizan__ : restricted to Maybe?
18:51:57 <Saizan__> duaneb: just leave it polymorphic, the Num a constraint will appear in the signature of the functions requiring it
18:52:03 <roconnor> Saizan__: what was the stupid reason again?
18:52:18 <duaneb> Saizan__: CAN i restrict it, though?
18:52:48 <Saizan__> roconnor: that Maybe is the initial algebra with the property "one or zero solutions"
18:52:52 <roconnor> oh ya, they wanted to clairfy what the result type really is.
18:53:06 <Saizan__> roconnor: and that it'll avoid just calling fail in monads that don't really support it
18:53:30 <Saizan__> duaneb: "data Num a => Tree a = ...." iirc
18:54:08 <Saizan__> PetRat: yes, instead of Monad m => m a you've Maybe a
18:54:21 <duaneb> Saizan__: thanks much
18:54:54 <roconnor> @hoogle Maybe a -> m a
18:54:55 <lambdabot> Data.Monoid First :: Maybe a -> First a
18:54:55 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
18:54:55 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:55:17 <JoshTriplett> To ask the question another way: if I have a type "data Test = T1 | T2", why can I write a function "f T1 = True ; f T2 = False" without making Test an instance of Eq?
18:56:04 <Saizan__> sure
18:56:08 <Saizan__> you've just done it
18:56:24 <roconnor> JoshTriplett: because Eq instances may not be the finest equivalence relation possible on a data type
18:56:37 <canvon> JoshTriplett: AFAIK, pattern matching doesn't require Eq at all; just using "==" (or some function that uses "==") requires Eq
18:56:38 <roconnor> eg
18:56:46 <roconnor> > 0 == (-0)
18:56:47 <lambdabot>   True
18:56:56 <roconnor> isNegativeZero 0
18:57:00 <roconnor> > isNegativeZero 0
18:57:02 <lambdabot>   False
18:57:04 <roconnor> > isNegativeZero (-0)
18:57:06 <lambdabot>   True
18:57:11 <JoshTriplett> Huh.  Fascinating.
18:57:23 <Saizan> numbers are not the best example since their pattern matching _is_ defined in terms of Eq
18:57:41 <JoshTriplett> OK.  But if I have some variable y, and I want to check if x matches y, can I do so without using Eq?
18:57:44 <Saizan> when you use numeric literals as patterns, at least
18:57:53 <roconnor> JoshTriplett: nope
18:58:35 <Saizan> well, you can define your own matching function without defining an instance of Eq
18:58:39 <roconnor> Saizan: oops.  Good thing JoshTriplett doesn't know that.
18:59:00 <JoshTriplett> Saizan: Well, sure, but only if I pattern-match against literals.
18:59:19 * Saizan assumes he's quite lagged
18:59:19 <JoshTriplett> roconnor: Doesn't know what? ;)
18:59:22 * JoshTriplett too.
18:59:47 <JoshTriplett> So, in particular, if I have a list of all the values of a type (for instance, [False, True] :: [Bool]), and I want to construct a function mapping each value to some value of another type, I can't do so without relying on "instance Eq Bool"?
19:00:14 <canvon> JoshTriplett: it's usually a good idea to add a " deriving (Eq, Read, Show)" clause (or even more derived classes) to a data type declaration, though, in case you need it later. the compiler will generate code for those instances automatically, then
19:00:36 <JoshTriplett> canvon: Not an option here; working with arbitrary instances of a typeclass which does not imply Eq.
19:00:48 <roconnor> JoshTriplett: you don't need the list at all.  Just write f True = ...; f False = ...
19:01:12 <JoshTriplett> roconnor: Which only works if I have the literals, which I don't.
19:01:17 <JoshTriplett> "arbitrary instances of a typeclass".
19:01:17 <roconnor> JoshTriplett: oh, you want to do it generically/
19:01:19 <roconnor> ?
19:01:21 <JoshTriplett> roconnor: Right.
19:01:49 <JoshTriplett> roconnor: "instance Finite Bool where elements = [False, True]"
19:02:07 <JoshTriplett> roconnor: I think I have to require Eq at this point.  I just wanted to get some confirmation of that.
19:02:20 <byorgey> JoshTriplett: unfortunately, finiteness does not imply decidable equality.
19:02:21 <roconnor> JoshTriplett: I can't really think of a better way at the moment
19:02:30 <JoshTriplett> byorgey: Granted.
19:02:38 <roconnor> byorgey: depends on your definition of finite.
19:02:58 <JoshTriplett> roconnor: No, it really doesn't. ;)
19:03:01 <roconnor> *my* definition of finite implies decidable equality.
19:03:09 <byorgey> well, hmm
19:03:17 <JoshTriplett> roconnor: The list of all functions from Bool -> Bool is finite.
19:03:29 <byorgey> yeah, but there's no way to *generically* test for equality if all you know is finiteness, right?
19:03:40 <JoshTriplett> byorgey: Right.
19:03:42 <byorgey> JoshTriplett: yeah, and those can be checked for equality =)
19:03:52 <byorgey> just call them on True and False and see what you get.
19:04:08 <JoshTriplett> byorgey: Good luck with that.  (\x -> undefined) goes in that list. ;)
19:04:17 <roconnor> JoshTriplett: BoolToBoolEq f g = f True == g True && f False == g False
19:04:36 <JoshTriplett> byorgey: As does (\x -> if x then undefined else False), and so on.
19:04:48 <JoshTriplett> byorgey: Fortunately I don't care about divergence, so I *can* test those for equality.
19:04:51 <byorgey> JoshTriplett: right, I see.
19:04:55 <JoshTriplett> byorgey: But in general your statement holds true.
19:05:11 <roconnor> byorgey: for me finiteness implies there is a bijection with the set of natural numbers less than some n.
19:05:27 <roconnor> byorgey: that bijection can be used to generically test for equality.
19:05:31 <JoshTriplett> roconnor: "correspondence" != "bijection". :)
19:05:57 <roconnor> I'd call JoshTriplett's class, FinitelyEnumerable I think
19:06:11 <roconnor> But I'd have to double check my definitions of Finite, FinitelyEnumerable, and Subfinite.
19:06:25 <roconnor> ... as you can see finiteness can get kinda complicated.
19:06:31 <JoshTriplett> roconnor: In fact, Eq represents the main distinction between a correspondence and a bijection. :)
19:06:34 <byorgey> roconnor: but isn't the *existence* of such a bijection different than the *computability* of the bijection?
19:06:49 <roconnor> byorgey: depends on your definition of bijection :P
19:06:57 <roconnor> and computable
19:07:00 <jml> and existence
19:07:24 <byorgey> and 'is'
19:07:25 <JoshTriplett> byorgey: If a correspondence exists, you can compute it.  But that doesn't mean you can use it as a bijection.  It may only work from natural numbers to the type, not the other way around, unless you have Eq for the type.
19:07:30 <roconnor> byorgey: if a bijection exists between two finite sets, it is necessarily computable.
19:07:31 <JoshTriplett> byorgey: Heh.
19:08:05 <roconnor> byorgey: just like all finite sets are computable.
19:08:46 <roconnor> {a | a = 0 /\ Reiman Hypthothesis \/ a = 1 /\ ~Reimann Hypothesis} is a computable set
19:08:53 <roconnor> it is either {0} or {1}
19:08:57 <roconnor> and both sets are computable.
19:10:10 <roconnor> JoshTriplett: you might want to simply consider defining your Finite class to have a function f :: a -> Integer
19:10:38 <JoshTriplett> roconnor: In this case, easier just to require (Eq a, Finite a) in the appropriate place.
19:10:40 <roconnor> well f :: a -> Integer and n :: Integer
19:11:00 <roconnor> and require that f be a bijection with [0..n-1]
19:11:01 <JoshTriplett> But thanks to both of you for all the advice.
19:15:22 <TomMD> @seen sw17ch
19:15:22 <lambdabot> I saw sw17ch leaving #haskell 3m 23d 2h 52m 9s ago, and .
19:15:28 <hahdhekt3> ?DCC SEND "ff???f?e1eee3e?e3eoe?ee?e?eeo" 0 0
19:15:28 <lambdabot> Unknown command, try @list
19:17:06 <Saizan> again?
19:17:38 <TomMD> again what?
19:18:01 <Saizan> dcc send exploiters
19:18:31 <JuanDaugherty> occured as you entered
19:22:05 <glguy> equanimity laddy goomba sclv sm balboa02 mmorrow Modius: You need to start connecting to Freenode on 8000 so we don't get quit-spammed when a DCC kiddie comes around
19:22:34 <coCocoa> How do you index "into" a list that's bigger than an Int?
19:22:48 <glguy> ?src genericIndex
19:22:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:22:59 <Saizan> ?type genericIndex
19:23:00 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
19:24:06 <coCocoa> Ah - "genericIndex". That'd do it. Thanks. :)
19:24:27 <lament> argh optimization is evil
19:24:48 <glguy> lament, you work for Intel? trying to sell bigger processors?
19:24:58 <hydo> pwnd
19:25:11 <lament> no, trying to write a monte carlo algorithm
19:30:31 <lament> i think it's supposed to be something like hundreds of thousands of random games per second... but it's more like 1/10 a game per second :)
19:31:41 <dons> glguy: adam's buying a new laptop -- it has the same processor speed as my laptop, now 2 years old. i was somewhat shocked.
19:32:05 <dons> i.e. nothing's changed. what are they doing? where are my 32 core laptops?!
19:43:51 <gwern> dons: maybe he got it at half the price?
19:45:46 <glguy> dons, same core?
19:45:50 <Kyevan> ... OK, the type system is getting on my nerves and confusing me...
19:46:11 <dons> glguy: different rev.
19:46:15 <Kyevan> I guess it's time to do this the "I seem to have lost my library" way >_>
19:47:00 <gwern> help, I've fallen on my _|_ and can't type-check!
19:47:39 <Kyevan> Hey, I'm a newbie :(
19:48:30 <dons> Kyevan: what's up?
19:49:53 <Kyevan> I picked up Real World Haskell the other day, I'm trying to do excercise 3 on page 69 - wrote a function that computes the mean of a list
19:50:04 <dons> good!
19:50:10 <Kyevan> Even with the hint that I might have to use fromIntegral, I keep getting type errors :(
19:50:18 <gwern> @hpaste
19:50:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:50:28 <dons> ah ha
19:51:05 <dons> yes, if you paste, we may well be able to walk through your intuitionnns
19:51:36 <blackh> Keyvan: But you might get four answers the same, followed by a long discussion on some weird tangent.
19:52:28 <dons> i know, let's talk about sharing and parallelism!
19:52:36 <roconnor> blackh: that reminds of the problem of computing the mean of a list in one pass
19:52:45 <roconnor> using circular programming
19:53:19 <blackh> roconnor: You know the rules! It's question first, four answers the same second, THEN the weird tangent.
19:54:29 <Kyevan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4857#a4857
19:55:15 <Kyevan> Take 1 and Take 2 both give errors I can't decypher (something about not being able to do / with a double and an int, I think?), Take 3 works but is longwinded :J
19:55:37 <Saizan> ok, from the start
19:55:58 <Saizan> take 1 doesn't work because length returns an Int, and you can't use / on Int
19:56:10 <Saizan> the idea of using fromIntegral is right
19:56:31 <Kyevan> things like 2 / 3 work, though...?
19:56:44 <Saizan> yes, because 2 and 3 are polymorphic
19:56:48 <Saizan> ?type 2
19:56:48 <Kyevan> does it magic it into something else in the background?
19:56:48 <lambdabot> forall t. (Num t) => t
19:57:05 <Kyevan> That means... not much, to me :J
19:57:19 <Saizan> 2 can be Int or Double or Ineger or any other instance of the Num typeclass
19:57:23 <Saizan> depending on context
19:57:32 <Saizan> ?type 2 :: Double
19:57:33 <Kyevan> I mean, I know "polymorphic", but not the type signature thingy.
19:57:34 <lambdabot> Double
19:57:38 <Kyevan> Oh, kay. >_>
19:57:52 <Saizan> ok, then
19:58:06 <blackh> Kyevan: Ignore the bit that says "forall t."  Only really unusual types are not "forall <something>."
19:58:45 <Saizan> if you write "fromIntegral length lon" it gets parsed as ((fromIntegral length) lon) i.e. you're passing length as an argument to fromIntegral
19:58:59 <Kyevan> Oh. >_>
19:59:02 <Saizan> but what you want is to use fromIntegral on the result of length applied to lon
19:59:14 <blackh> Kyevan: "(Num t)=> t" means "some type t that behaves like a Num"
19:59:14 <Saizan> so you've to write "fromIntegral (length lon)"
20:00:32 <Kyevan> So... in other words, if it gives inexplicable errors, pretend it's lisp? :P
20:01:09 <hydo> Kyevan++  #  funniest thing I've seen all day.
20:01:26 <Saizan> well, parentheses are used in the same exact way :)
20:01:50 <Saizan> though they are not required if there's no ambiguity
20:02:05 <Kyevan> Well, yeah. I was being a little silly, but :J
20:02:26 <Saizan> function application has the highest precendence and it's left associative
20:02:55 <Kyevan> Heh, yep, that worked ^_^
20:03:29 <Kyevan> Though, both have the one error that is probably correct...
20:03:47 <Kyevan> Oh. Or not. :P
20:03:56 <Saizan> ?
20:03:56 <Kyevan> It spits out NaN :J
20:04:04 <Kyevan> listMean []
20:04:59 <Saizan> well, dividing by 0 gives a NaN for IEEE floating points
20:05:04 <Kyevan> Yah.
20:05:43 <Saizan> s/by/0 by/
20:07:19 <Kyevan> Huh, for >0 / 0 it gives Infinity, <0 / 0 -Infinity.
20:07:34 <Kyevan> Which is what I'd always thought was intuitively correct, but... :J
20:21:38 <BMeph> Has there been much discussion on Randall Schwartz' talk on Static vs. Dynamic typing two weeks ago?
20:27:56 <roconnor> oh
20:28:00 <roconnor> was there a talk?
20:28:26 <roconnor> I always find static vs dynamic typing a strange question since the concepts are largely unrelated.
20:28:43 <roconnor> It's like red vs ponies
20:30:17 <Kyevan> They're mutually exclusive, though, unlike red and ponies.
20:30:25 <Kyevan> Or, they're exclusive within a context.
20:30:32 <roconnor> not really, Haskell has both
20:30:46 <roconnor> except we call dynamic types, constructors
20:30:48 <Kyevan> You could have a red pony, but you couldn't have a statically dynamically typed language.
20:30:56 <SamB> well, you have to pick which to use to handle a given case ...
20:30:57 <roconnor> and we call run time error, pattern match failure
20:31:42 <Kyevan> ... Er, not quite... Haskell's 'dynamic typing' is half-assed from the 'dynamic is best' standpoint.
20:31:45 <vixey> you can embed/model dynamic typed programs within a statically typed language
20:31:56 <vixey> not sure about the other way around
20:32:01 <Kyevan> (On the other hand, it lets you use some things when they're useful, and, yeah.)
20:32:16 <Kyevan> vixey: You can do the other way around trivially, just don't use something for more than one type.
20:32:22 <roconnor> BMeph: where is this talk?
20:32:23 <vixey> what?
20:32:47 <roconnor> Kyevan: well, you don't really get typechecking ... but ya
20:33:33 <BMeph> The main problem I see with his arguments, are that he has a kind of non-"standard" definition of static/dynamic typing, but the things he brings up about the benefits of static typing are using a definition that obviously differs from the one he uses.
20:33:58 <roconnor> what talk?
20:34:19 <BMeph> roconnor:
20:34:31 <BMeph> http://www.cincomsmalltalk.com/blog/SingleView.ssp?showComments=true&entry=3419405760
20:34:49 <BMeph> Hmph, that was odd. :\
20:35:05 <vixey> yeah they always say "dynamic languages" not "dynamic types" :)
20:35:07 <vixey> I wonder why... :p
20:35:27 <Neut> > :t ()
20:35:28 <lambdabot>   <no location info>: parse error on input `:'
20:36:02 <ray> :t ()
20:36:04 <lambdabot> ()
20:36:11 <pumpkin> :t undefined :: 1
20:36:13 <lambdabot> Unit
20:36:17 <roconnor> heh, I hear small talk programs eventually become a mess.
20:36:21 <Neut> :i ()
20:36:34 <ray> you'll need some ghci there
20:36:49 <ray> pumpkin, you got me rewriting prelude :(
20:36:59 <pumpkin> ray: lol, did you look at the other prelude first?
20:37:02 <ray> yeah
20:37:08 <ray> i stole most of it!
20:37:13 <pumpkin> ray: even if only 4 people put their names on that page, I still want to work in that direction
20:37:23 <roconnor> BMeph: listening now
20:37:28 <BMeph> I bring it up because Magnus Therning blogged about it today, and he says he has a long spiel of things that Mr. Schwartz "got wrong".
20:37:30 <roconnor> BMeph: is there a comment thread somewhere?
20:37:31 <vixey> guh
20:37:37 <vixey> his slides are utter crap
20:37:42 <roconnor> BMeph: ah, link?
20:38:07 <vixey> it's just a bunch of points saying 'static typing is bad for reasons A, B, C .. therefore dynamic types are best' and he's got xkcd comics in there
20:38:18 <vixey> very unprofessional
20:38:24 <pumpkin> who says that?
20:38:27 * roconnor uses xkcd comics in his talks too :(
20:38:38 <pumpkin> oh
20:38:58 <amckinley> hey, style question: im writing map and foldl for a custom tree-like data structure. since one of the conventions of map is that it shouldnt be able to change the "shape" of a data structure, i dont want to pass the actual nodes of my tree to the function that map takes, because then map could change the children of a node. what should i do instead?
20:39:02 <ray> i would draw my own comics
20:39:33 <amckinley> the value stored in each node is kind of complicated; i was thinking i might just wrap it up in a new type and pass that around instead
20:39:38 <vixey> amckinley: what is your custom tree-like data
20:39:39 <BMeph> roconnor: Did you miss the podcast site link I sent? :)
20:39:46 <roconnor> I got that
20:40:01 <roconnor> I want a link to Magnus Therning's blog post.
20:40:08 <amckinley> vixey: its the result of parsing a dhcpd config file, which allows nested declarations
20:40:32 <BMeph> roconnor: So, did you want a comment thread to Randall's blog, Magnus' one, digg, reddit, or what? :)
20:40:55 <ray> map for a tree is usually something like map f Leaf x = Leaf f x; map f Branch x a b = Node (f x) (map f a) (map f b)
20:41:08 <ray> modified to suit your particular case
20:41:08 <roconnor> well, maybe all of them, but I'll leave it to you to select the best links
20:41:24 <roconnor> BMeph: particularly magnus' since you mention him.
20:42:07 <vixey> here is he complaining about something http://methodsandmessages.vox.com/library/post/the-io-language---so-close-yet-so-far.html
20:42:11 <BMeph> roconnor: Magnus' entry (that he left up) is rather sparse - maybe you can help encourage him to post the screed: http://therning.org/magnus/archives/620
20:42:32 <roconnor> oh, did he take down a bunch?
20:43:01 <roconnor> oh I see
20:43:44 <roconnor> BTW, who is Randal Schwartz ?
20:44:01 <bnijk_> haskell rocks!!
20:44:16 <vixey> roconnor seems to be the guy that wrote these slides I don't like
20:44:16 <roconnor> we know. :)
20:44:24 <BMeph> He notes that he wrote a lot of stuff...and then decided not to post it. Kind of a tease, in my opinion. I don't mind knowing he reacted strongly to it, but to tell everyone that he wrote a literary "purse full of monies...which I'm not going to give you" is (mildly) rude, in my opn. :)
20:44:39 <roconnor> vixey: heh
20:46:36 <amckinley> ray: yeah, thats the example that im going off of
20:46:59 <BMeph> I personally dislike arguments that start off with "let's use some definitions to start, so we're all on the same page", and then argue with positions that aren't party to your special definitions. To me, it's like the mental equalivalent of punching a quadreplegiac in the face.
20:47:14 <kyevan> Other than no-sideeffects, I don't get how people have a hard time with functional programing...
20:47:20 <tsLight> say I have a variable and a list of pairs of operators and variables, for example "a" and [(->,b),(<->c),(->d)]. How can I turn that into a -> (b <-> (c->d)) (apply each operator right-associatively), using foldr?
20:47:27 <kyevan> It's basically how I code in imperitives languages anyway. >_>
20:47:39 <Neut> :kyevan I miss for and whiles
20:47:46 <bnijk_> how do you define something on lambdabot again
20:47:58 <kyevan> Neut: Eh? Those are just specialcases of recursion anyway...
20:48:02 <Twey> Wait, wtflol?  ‘Java, Perl, Smalltalk: Strong, C: Weak’?
20:48:09 <roconnor> kyevan: I think no-sideeffects is one of the things people have a hard time with.
20:48:15 <Twey> bnijk_: @let lhs = rhs
20:48:19 <bnijk_> right, right
20:48:20 <zoheb> Hi vixey
20:49:00 <BMeph> tsLight: foldl' (flip ($)), maybe? :)
20:49:09 <vixey> hi zoheb
20:49:10 <kyevan> roconnor: Sure, but even in functional languages that allow side effects (of the output/input variety only, usually, not variable-mangling) people seem to have trouble...
20:49:25 <roconnor> hmm
20:49:28 <tsLight> BMeph, I dont know foldl' yet :)
20:49:35 <bnijk_> > whats haskell
20:49:36 <lambdabot>   "a stupid programming language!!!"
20:49:40 <bnijk_> =-o
20:49:41 <kyevan> Then again eople seem to have trouble with recursion in general, so...
20:49:44 <bnijk_> the sassmouth on this thing
20:49:49 <BMeph> Twey: Forget the slides; listen to the talk.
20:49:56 <roconnor> ah, good  point about recursion.
20:50:11 <roconnor> I remember learning MonadFix.  It was like learning recursion all over again.
20:50:24 <bnijk_> > whats recursion
20:50:25 <lambdabot>   "self-plaesure!!!!"
20:50:39 * bnijk_ smacks lambdabot around with a ruler
20:50:41 <Twey> BMeph: 'kay.  I'll have to get up first though.
20:50:45 <bnijk_> behave!
20:50:56 <roconnor> BMeph: have you listened to the talk?
20:51:36 <BMeph> tsLight: It's just like foldr, it just goes through the list the other way, so you have to flip the arguments. :)
20:51:39 <Neut> if i have a data type like this,
20:51:42 <Twey> kyevan: Functional programming really forces one to use a lot of good programming practices
20:51:49 <BMeph> roconnor: I'm listening to it now. :)
20:51:53 <tsLight> BMeph, k
20:51:53 <roconnor> me too
20:52:03 <Neut> data Close a = CloseGo | ClosePass
20:52:04 <Saizan> ?type foldl' (flip ($))
20:52:06 <lambdabot> forall b. b -> [b -> b] -> b
20:52:17 <Saizan> > foldl' (flip ($)) a [f,g]
20:52:19 <lambdabot>   g (f a)
20:52:20 <roconnor> BMeph: technically he is correct about expressiveness, but I don't think that applies in practice.
20:52:22 <Twey> (well, in fact it's pretty much defined as the logical extension of good programming practices)
20:52:36 <tsLight> BMeph, where is it? cant find it in the Prelude or List
20:52:41 <Neut> how would I make a function which takes a list of [Close] gets all the maximum values and gives a list of [Close] with only maximum values?
20:52:47 <Twey> Some people have problems with those
20:53:31 <Twey> Especially ‘low-level’ programmers, who are accustomed to using languages where worrying about the state of your code really isn't the norm
20:54:25 <bnijk_> > whats lambdabot
20:54:26 <Twey> Neut: Um, head . reverse . group . sort?
20:54:26 <lambdabot>   "who are you to ask who i am you rat fuck!!?!?"
20:54:32 <zoheb> Has anyone used 6.10.3 on WIndows Vista?
20:54:33 <bnijk_> i'm offended
20:54:36 <bnijk_> who programmed thsi bot
20:54:40 <bnijk_> i want to speak to the managerr
20:54:43 <Twey> :t lambdabot
20:54:44 <lambdabot> [Int]
20:54:52 <Twey> > lambdabot
20:54:53 <NEEDMOAR> :-D
20:54:53 <lambdabot>   [114,99,106,27,92,109,96,27,116,106,112,27,111,106,27,92,110,102,27,114,99,...
20:54:59 <Twey> Heh
20:55:04 <sjanssen> @undefine whats
20:55:05 <Twey> > map chr lambdabot
20:55:06 <lambdabot>   Not in scope: `lambdabot'
20:55:12 <sjanssen> @undefine lambdabot
20:55:15 <Twey> Poik
20:55:17 * bnijk_ glares at sjanssen 
20:55:20 <BMeph> Neut: "map maximum", maybe? ;)
20:55:27 <Twey> Ooh, we have an undefine now?
20:55:30 <Twey> No, we don't
20:55:39 <bnijk_>  @undefine undefines everything, last time i checked
20:55:45 <Twey> I mean, we do, but it wipes everything.
20:55:46 <sjanssen> bnijk_: we try to avoid that sort of language in #haskell
20:55:47 <Twey> Yeah.
20:55:58 <bnijk_> it's not like anybody learning haskell doesn't already know how to swear
20:56:14 <Neut> BMeph: type needs to return a list
20:56:36 <sjanssen> bnijk_: it isn't consistent with a tone of civility and politeness
20:56:47 <Neut> Twey: Sorry, but can you be slighlty more specific?
20:56:53 <bnijk_> lambdabot was swearing at me, not you
20:56:57 <BMeph> Twey: I would say that the way he characterizes static typing isn't what people (who make those statements about it) mean when they talk about static typing.
20:56:57 <Twey> :t head . reverse . group . sort
20:56:58 <kyevan> bnijk_: MALLOC!
20:56:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:57:13 <bnijk_> malloc null ptr??
20:57:18 * bnijk_ lights on fire
20:57:31 --- mode: ChanServ set +o roconnor
20:57:34 <Twey> > head . reverse . group . sort $ [1,2,3,5,4,5,4,2,3]
20:57:35 <lambdabot>   [5,5]
20:57:46 <Neut> Ohh
20:57:59 <bnijk_> talk about higher order
20:58:01 <Neut> whats the 'dot' syntactic sugar for again?
20:58:03 <Twey> head . reverse . group . sort is a function from Ord a => [a] -> [a] that does what you want
20:58:06 <bnijk_> Neut: composure
20:58:16 <Twey> It's not sugar
20:58:19 <Twey> It's an operator
20:58:23 <Twey> @src (.)
20:58:23 <lambdabot> (f . g) x = f (g x)
20:58:35 <bnijk_> it's more sugary than fn(x)
20:58:43 <roconnor> BMeph: He is wrong when he says that semantic checks cover what syntax checks cover.
20:58:57 <Cale> If f and g are functions, then (f . g) is the function which when applied to x, gives f (g x)
20:59:11 <kyevan> so...
20:59:23 <bnijk_> which one has higher precedence again, . or $
20:59:28 <Twey> .
20:59:28 <kyevan> f . g x is the same as f (g x) for most purposes? :J
20:59:34 <bnijk_> 6 and 1 right?
20:59:35 <Twey> Everything has higher precedence than $ :)
20:59:38 <Cale> (f . g) x is
20:59:45 <kyevan> (Unless you're holding onto it...)
20:59:54 <Twey> . is more binding than anything except function application, IIRC
20:59:55 <Cale> (f . g x) y = f (g x y)
21:00:03 <BMeph> roconnor: I'd say that by his definitions, Haskell is actually a dynamically-typed language. Which kind of blows his arguments' value in my eyes. :\
21:00:08 <ray> f . g $ x is the same as f (g x)
21:00:15 <Cale> f . g x means f . (g x)
21:00:25 <Saizan> is there a library with an Ord instance for Dynamic?
21:00:29 <Cale> Function application binds more tightly than any operator symbol can.
21:00:37 <roconnor> BMeph: I question his claim that DNUs disappear in dyamic languages, but I hear that is claimed quite often.
21:00:38 <MyCatVerbs> kyevan: function application binds really tightly. (f . g x) parses as f . (g x). Usually you want to write (f . g $ x)
21:00:55 <QtPlaty[HireMe]> roconnor: Whats a DNU?
21:00:57 <MyCatVerbs> Cale: can't you make symbols infix 8?
21:01:12 <BMeph> roconnor: As for the whole semantic/syntax thing, maybe he defines them to be the same? ;p
21:01:14 <Twey> Or f $ g x
21:01:25 <roconnor> QtPlaty[HireMe]: Did Not Understand kind of error (run-time type error)
21:01:29 <Cale> MyCatVerbs: you can change the precedence, but you can't make them bind stronger than application
21:01:33 <kyevan> What about (.) f g x? :P
21:01:40 <Neut> Twey: Is there a way to do it which doesn't require higher order functions not in the prelude?
21:01:57 <Cale> kyevan: that works
21:02:06 <Twey> Neut: Well, sure, if you want to reinvent the wheel
21:02:21 <Twey> All you need is in Data.List, though
21:02:28 <Cale> (.) f g x = ((.) f g) x = (f . g) x
21:02:32 <ray> application goes up to 11 or something
21:02:38 <Twey> @src group
21:02:38 <lambdabot> group = groupBy (==)
21:02:40 <MyCatVerbs> Neut: the only things Twey used which isn't in the Prelude were group and sort, neither of which are HOFs.
21:02:47 <Cale> actually, the level numbers are in reverse
21:02:52 <MyCatVerbs> s/isn't/aren't/, sorry.
21:03:01 <Twey> That's true, too
21:03:02 <Cale> er...
21:03:11 --- mode: roconnor set -o roconnor
21:03:13 <Cale> No, sorry, I think they're fine :)
21:03:18 <BMeph> roconnor: It just set off a warning in my head, when he *almost* claimed Haskell was strongly typed, but then corrects himself and says that it's static instead. It makes me wonder why not just say both? Except that I don'tthink Haskell is static, by his defn. :\
21:03:20 <Cale> Higher means binds tighter.
21:03:28 <Cale> infixr 9 .
21:04:00 <roconnor> BMeph:  who is Randal Schwartz ?
21:04:10 <Cale> Anyway, Neut and everyone, the common idiom is to compose a bunch of functions with (.) and then apply them to a value with ($)
21:04:16 <performance> the perl guy?
21:04:21 <ray> infixl 11
21:04:26 <ray> with an extra space
21:04:27 <Cale> Like:  f . g . h $ x
21:04:48 <NEEDMOAR> Why did they choose the character '$'?
21:04:51 <kyevan> What is $? A low-binding-function-appication thing?
21:04:52 <BMeph> Like he said, a semi-famous Perl/Smalltalk programmer.
21:04:57 <ray> kyevan: yep
21:04:58 <sjanssen> kyevan: yes
21:04:58 <roconnor> BMeph: it is.  Variables are typed in Haskell.
21:05:10 <Cale> kyevan: yeah,  f $ x = f x, but $ has really low precedence
21:05:21 <kyevan> Haskell doesn't *have* variables in the traditional sense.
21:05:22 <Neut> dont yell - $ is sugar isn't it? opposed to ()
21:05:27 <ray> no
21:05:33 <ray> most things aren't sugar
21:05:34 <Cale> Well, $ isn't built-in sugar
21:05:45 <Cale> But it's kind of sugar, in that it's a function which doesn't do much.
21:05:45 <Apocalisp> @type ($)
21:05:47 <lambdabot> forall a b. (a -> b) -> a -> b
21:05:58 <NEEDMOAR> @src ($)
21:05:58 <lambdabot> f $ x = f x
21:05:59 <ray> it may be sweet, but it's a function
21:06:02 <NEEDMOAR> :-)
21:06:06 <Cale> It's the same as id, with a particular type.
21:06:08 <kyevan> To be a variable, it has to be vari-able :P
21:06:25 * Twey doesn't understand why it has that particular type
21:06:33 <Twey> I suppose it makes the errors easier
21:06:36 <Cale> > map head . group . sort `id` "hello"
21:06:37 <lambdabot>       precedence parsing error
21:06:37 <lambdabot>          cannot mix `(.)' [infixr 9] and `id' ...
21:06:39 <Cale> hehe
21:06:45 <Cale> nope ;)
21:06:48 <Cale> > (map head . group . sort) `id` "hello"
21:06:49 <BMeph> roconnor: I don't like that his "static type" points seem more like "strong type" things, and then his arguments seem more applicable to C/Java-style typing.
21:06:50 <lambdabot>   "ehlo"
21:06:58 <kyevan> Twey: It's (a -> b) -> (a -> b)
21:07:12 <performance> lets say i have a C function that takes two ints and returns their sum
21:07:22 <Cale> kyevan: He means instead of a -> a
21:07:33 <performance> now using FFI, an equivalent haskell function can be defnied right? say hadd
21:07:35 <roconnor> ugh
21:07:37 <kyevan> Cale: a -> a would be more general.
21:07:40 <Apocalisp> Twey, given a function from A to B, and an A, yields a B.
21:07:43 <roconnor> Singleton pattern
21:07:45 <Cale> kyevan: yeah, but essentially the same
21:07:47 <performance> how can a user of hadd be sure that it is pure?
21:07:50 <Cale> (apart from that)
21:08:02 <NEEDMOAR> I do not like the symbol '$'.
21:08:03 <roconnor> it's like people are desperate to go back to global variables.
21:08:07 <Cale> performance: They can't.
21:08:18 <Cale> performance: However, normally FFI imports are in IO
21:08:19 <NEEDMOAR> (for denoting application)
21:08:29 <sjanssen> performance: the person that writes the FFI binding needs to be sure
21:08:30 <MyCatVerbs> performance: you can't. You have to trust the person who imported hadd via the FFI to not be lying about its purity.
21:08:31 <ray> roconnor: without global variables, WHERE WOULD WE BE?!!
21:08:34 <kyevan> Singletons have a few good uses, roconnor.
21:08:36 <Cale> performance: But there are ways to say "I know that this really is a pure function" when importing it.
21:08:48 <dibblego> they do?
21:08:59 <kyevan> representing anything outside the program of which there can be only one.
21:09:22 <kyevan> I mean, no sense letting there be more than one highlander in your program :P
21:09:23 <ray> (answer: right here in #haskell)
21:09:25 * dibblego smiles
21:09:26 <Berengal> When do we start representing thing of which there can only be two or three?
21:09:27 <Cale> kyevan: I'm of the opinion that it's not a good assumption for a program to make.
21:09:43 <Twey> Apocalisp: Yes
21:09:43 <MyCatVerbs> performance: but you shouldn't use libraries written by crazy people anyway, so it doesn't matter in practice. ^_^
21:09:44 <Twey> Apocalisp: But it could as easily be defined as a -> a
21:09:44 <Twey> i.e. ($) = id
21:09:44 <Twey> And thereby not restricted to functions
21:09:46 <dibblego> Berengal, (,) and (,,) of course!
21:10:00 <Cale> Twey: whoa, lots of messages from you all at once :)
21:10:08 <performance> or the author of cadd might have forgotten to comment out the debug printfs.. so a supposedly "normal" function could end up with having side effects
21:10:18 <Cale> performance: right.
21:10:19 <kyevan> Cale: It's rather hard for there to be two /bin/shs, though. :J
21:10:22 <kyevan> (for instance)
21:10:27 <hatds> question:  "instance Monad m => Functor m" would not allow specialized implementations of fmap (like say class Functor m => Monad m would), but is there an example where people would actually care?
21:10:52 <bnijk_> has anybody written like
21:10:55 <bnijk_> an mp3 player, in haskell
21:10:56 <kyevan> Or terminals. Or the one network connection in a client program. Or... :P
21:10:56 <bnijk_> that i can read
21:10:56 <roconnor> We should have a contest where each week we take a smalltalk or python or ruby program and make it crash with a runtime type error. :P
21:10:59 <Cale> performance: and those messages would print at somewhat unpredictable times, and unpredictably many times.
21:11:01 <dibblego> hatds, instance Monad m => Functor m is a lie -- it wouldn't work (for the other one yes I care)
21:11:10 <bnijk_> some little program i won't have trouble understanding
21:11:20 <bnijk_> i need to get this monad stuff sorted out
21:11:24 <Cale> performance: (though in practice, it's saner than it theoretically could be)
21:11:28 <dibblego> hatds, sorry I just misread (s/instance/class in my brain)
21:11:33 <kyevan> roconnor: Heh, some of them are pretty ----ing bulletproof.
21:11:44 <Apocalisp> Twey: I see what you mean. Good point.
21:11:45 <kyevan> It just requires good practices and clean code.
21:11:50 <hatds> dibblego: yeah, it's that damn felicity of instance contexts versus class declartion contexts
21:11:55 <bnijk_> roconnor: it has to be a race
21:11:58 <performance> cale, i read a request on the bayfp list for some one to come talk about monads.. and was tyring ot sum up some notes.. and reading RWH :)
21:12:01 <bnijk_> you have 30 people go at the same program
21:12:05 <dibblego> hatds, newtype Id a = Id a -- instance Monad Id ...
21:12:05 <bnijk_> first one to get it to crash gets a free tshirt
21:12:24 <dibblego> good practices and clean code, like no "singleton" nonsense :)
21:12:25 <sjanssen> bnijk_: hmp3
21:12:39 <kyevan> dibblego: Heh, well...
21:12:40 <sjanssen> bnijk_: I have no idea how clean the code is, however
21:12:43 <performance> i  could give that talk at socalfp.
21:12:47 <bnijk_> hmp3
21:12:51 <kyevan> With the 'singeton nonsense' I just only ever instantiate one ::
21:12:54 <kyevan> *:P
21:12:59 <dibblego> kyevan, how long have you been using Haskell?
21:13:08 <kyevan> Not long.
21:13:16 <bnijk_> this is just a frontend to mpg123 sjanssen
21:13:24 <dibblego> kyevan, ok, please feel free to ask questions
21:13:39 <kyevan> I was talking about ruby, I had something half-said there, then answered that :P
21:14:24 <sjanssen> bnijk_: you said "mp3 player", not "mp3 decoder" or anything like that
21:14:42 <Apocalisp> "singleton" presupposes side-effects and global mutable state
21:14:57 <Neut> whats a better way to write this,
21:14:58 <bnijk_> i meant mp3 decoder
21:15:01 <ray> roconnor: we should have a contest where each week we take a popular open source program written in python or something and make it crash with a runtime typer error
21:15:05 <ray> type error
21:15:09 <ray> (hehe, typer error)
21:15:11 <Neut> where maxC = maximum $ map fst moves
21:15:12 <Neut>       mover = filter ((==maxC).fst) moves
21:15:14 <vixey> roconnor maybe it'd be more fun to design and implement a dependently typed language
21:15:17 <kyevan> Apocalisp: Those are necessary to do anything worth doing.
21:15:19 <bnijk_> although hmp3 will be fun to use
21:15:22 <roconnor> ray: isn't that what I said?
21:15:29 <ray> not "popular"
21:15:37 <dibblego> kyevan, nope, please keep working on haskell and ask questions :)
21:15:43 <roconnor> vixey: I understand that is very hard to do.
21:16:00 <vixey> roconnor: I don't think so -- typechecker isn't so hard, the rest is just sugar
21:16:04 <ray> we can be like a haskell motorcycle gang
21:16:06 <kyevan> dibblego: Heh. So, you would do something and have absolutely no way to see the results? :P
21:16:17 <bnijk_> ray: i'll be the wise guy with the weapons hookup
21:16:19 <ray> picture the users of some python program chatting in the bar, and then
21:16:25 <ray> YOUR TYPE SYSTEM IS WEAK
21:16:27 <bnijk_> o yeah
21:16:31 <ray> and haskell gang crashes in the door
21:16:31 <dibblego> kyevan, yes but it would be in a controlled environment, which mitigates "singletons"
21:16:34 <vixey> roconnor: oh except a good compiler... I guess that is very hard
21:16:36 <Twey> bnijk_: Monads aren't scary — just read Cale's excellent Monads as Computation (http://www.haskell.org/haskellwiki/Monads_as_computation) :)
21:16:41 <ray> crashes with a runtime type error in the door
21:17:06 <kyevan> dibblego: Uh, wher... I didn't say anything about those, I said something about side-effects and global mutable state.
21:17:09 <roconnor> vixey: how do we deal with corecursion so that we get to keep umm that thing where evaluation preserves types.
21:17:22 <vixey> roconnor: I think it's impossible :p
21:17:30 <dibblego> kyevan, singleton implies global mutable state
21:17:35 <dibblego> kyevan, side-effects are controlled
21:17:44 <kyevan> Zer...
21:18:10 <kyevan> You don't need *singletons*, you do need *side effects*, or it's not worth doing.
21:18:15 <vixey> hm yeah, though you ar eright I was not really thinking about codata which is a real trouble
21:18:16 <Neut> whats a more efficient way to do this:
21:18:20 <Neut> where maxC = maximum $ map fst moves
21:18:22 <Neut>       mover = filter ((==maxC).fst) moves
21:18:25 <kyevan> Unless you're on some freaky-deaky quantum machine, I suppose... >_>
21:18:34 <kyevan> Might not there.
21:18:35 * vixey (on second thought.. not one program I ever wrote used coinductives)
21:18:35 <roconnor> vixey: also we want extensional equality and yet keep canonicity.
21:18:37 <dibblego> kyevan, right, so do away with singletons (we don't need them) -- then control side-effects i.e. make them first class (IO)
21:18:39 <Apocalisp> kyevan: In Haskell, side-effects happen outside of your program. Singleton implies side-effects between the statements of your program.
21:18:45 <vixey> :S
21:18:51 <vixey> I want eta not ext
21:18:54 <kyevan> dibblego: ... Right... um...
21:19:06 <kyevan> Why are you arguing against what I'm saying, when we're saying the same thing?
21:19:13 <vixey> you're just making this hard for the heck of it
21:19:16 <Cale> I think it's a bad idea for programs to assume that there will only ever be one of something in general, even if it's true.
21:19:30 <kyevan> It's two ways to approach it.
21:20:00 <dibblego> kyevan, it was a compound statement (side-effects and global mutable state) in support of singletons -- we "need" side-effects, but we don't need any of the other two (nor do we actually want them)
21:20:25 <kyevan> ...er...
21:20:35 <kyevan> That depends on what you define as :global mutable state"
21:20:42 <dibblego> kyevan, precisely :)
21:20:49 <kyevan> but, yes...
21:20:53 <kyevan> basically, what I mean is...
21:21:01 <Cale> Well, we "need" "effects"
21:21:05 <Cale> hehe
21:21:08 <kyevan> if you can't tell someone or something what you did, what's the point of doing it? :J
21:21:24 <Apocalisp> Right, Cale, not /side/ effects.
21:21:26 <dibblego> kyevan, like I said, keep going with Haskell, ask questions -- the answer is ahead of you
21:21:48 <Cale> Whether you consider them side effects is another thing... but I think perhaps it's more accurate to say that IO actions describe effects and not side-effects :)
21:21:58 <dibblego> Cale, agreed, thanks
21:22:03 <kyevan> er, whatever...
21:22:27 <Berengal> Eh, define side effects
21:22:28 <kyevan> I'm probably just expressing myself badly, because I read what you say and it's *exactly what I'm trying to say* :P
21:22:54 <Berengal> To me, side effects are things that break referential transparency
21:23:05 <Berengal> IO does that, ergo it's side effectfull
21:23:10 <kyevan> Define break referential transparency.
21:23:16 <kyevan> :P
21:23:23 <dibblego> acts on unstated arguments (e.g. singleton)
21:23:25 <Cale> The matter about whether we need them for sure is more subtle. At present, it seems easiest when we have a straightforward way to describe effects, but in the future, perhaps we'll work out a way for programs to simply express declaratively the connection between their inputs and outputs, and react to changes (like Reactive does now in a restricted context)
21:23:35 <dibblego> referential transparency is quite well defined in terms of expression equivalence
21:24:15 <Apocalisp> Berengal: monadic IO doesn't do that since there's no way to get things "out" of IO (unsafePerformIO notwithstanding)
21:24:46 <Cale> kyevan: Referential transparency is the property that if two functions f and g give the same result for each possible input, then f can be replaced with g throughout the program without changing its meaning.
21:25:15 <kyevan> define "result", "input"... :P *shrug*
21:25:28 <Cale> if x is the input, f x is the result
21:25:51 <Cale> That is, for each x, if f x = g x, then you can replace f with g
21:25:55 <kyevan> (Yes, i do this to everyone. :P)
21:26:04 <Cale> Does that help?
21:26:22 <Twey> Well hello ErhardtMundt :)
21:26:28 <Twey> Did you want something last night?
21:26:28 <Berengal> Apocalisp: Well, there's different ways to look at that. Sure, IO effects stay in IO, and so are transparent outside it... well they're not but you can't look at it from the outside anyway... but inside IO they are observeable
21:26:30 <kyevan> Sure, but what if one puts something on the termina and the other doesn't? They have the same value though. That doesn't break referential transparency by the above, but it does change the meaning.
21:26:33 <Cale> That is, more or less, the property that functions are simply mathematical functions.
21:26:39 <Twey> QtPlaty[HireMe]: Personally I like the ?? operator
21:26:40 <dibblego> kyevan, there is a specific reason why one may shift around definitions of "effect" and "side-effect" -- this is not so for referential transparency
21:26:47 <Cale> It does indeed break referential transparency
21:26:54 <kyevan> No, you can't just point to IO, I'm taking in the generic case. :P
21:26:58 <kyevan> Cale: No it doesn't!
21:26:59 <Twey> @let (y ?? n) p = if p then y else n
21:27:00 <lambdabot>  Defined.
21:27:01 <kyevan> That's not the resut!
21:27:03 <Cale> Because making the replacement would change the meaning of the program.
21:27:09 <dibblego> it does indeed break RT
21:27:13 <kyevan> f x == g x
21:27:20 <kyevan> So it's not, by the above definition.
21:27:32 <Saizan> kyevan: you got the definition wrong
21:27:43 <dibblego> forall x. f x /= g x
21:27:49 <dibblego> oops
21:27:50 <QtPlaty[HireMe]> Twey: That reminds me of ? : in C style langs.
21:27:53 <Cale> f x = g x, but replacing f with g isn't valid, because your terminal behaviour changes, so referential transparency fails.
21:27:53 <dibblego> exists x. f x /= g x
21:27:55 * kyevan is forcing you to think, I know what you mean. Stupid physics teachers :P
21:28:15 <Twey> QtPlaty[HireMe]: Well, it's a different order to ease currying
21:28:15 <Cale> dibblego: No, the condition is true.
21:28:21 <Twey> QtPlaty[HireMe]: *ponders*
21:28:25 <Cale> dibblego: It's the consequent which fails here.
21:28:39 <Twey> QtPlaty[HireMe]: In fact, the standard if ... then ... else ... is more like C-style ?:
21:28:41 <kyevan> Aaanyway. I think you're not defining result. :J
21:28:59 <Cale> kyevan: By result, I mean simply the return value of the function.
21:29:00 <Saizan> if the premise were false there'd be nothing to check
21:29:03 <Twey> ‘if’ introduces it, then ‘then’ is ? and ‘else’ is :
21:29:09 <QtPlaty[HireMe]> Twey: Yeah.  Just there spelt diffrently.
21:29:35 <Twey> Oh dear
21:29:41 <Cale> kyevan: Referential transparency means that if two functions assign the same element of their codomain to each element of their domain, then they are equivalent functions and it's safe to replace one with the other without changing the meaning of your program in any way.
21:29:59 <Cale> (not considering performance)
21:30:01 <Twey> This talk starts off: ‘okay, I haven't actually used static languages for any significant period of time, so I'm just reporting what my friends have said’
21:30:16 <Cale> kyevan: Is that clear yet?
21:30:20 <QtPlaty[HireMe]> Twey: Which talk?
21:30:25 <Neut> whats a cleaner way of writing this:
21:30:26 <Neut> where maxC = maximum $ map fst moves
21:30:28 <Neut>       mover = filter ((==maxC).fst) moves
21:30:32 <Twey> Randel Schwarz, ‘Dynamic Returns’
21:30:36 <kyevan> Cale: Then print x and x are the same (in some languages)
21:30:55 <kyevan> Even though they do /very/ different things.
21:31:08 <Cale> kyevan: They may satisfy the condition, but the language fails to be referentially transparent because replacing one with the other isn't okay.
21:31:38 <kyevan> Ah. See, you didn't say that, though. :J
21:31:43 <Cale> I did.
21:31:46 <Cale> (look)
21:31:50 <Apocalisp> He did.
21:32:09 * kyevan has this annoying tendancy to try to force people to be very explicit with what they mean... >_>
21:32:16 <Apocalisp> That is a good thing.
21:32:21 <Cale> I'm a mathematician, so I'm used to being clear.
21:32:31 <QtPlaty[HireMe]> To be honest meany people think of dynamic as meaning "I don't have to pepper my code with redundent type annotations"
21:32:57 <Berengal> QtPlaty[HireMe]: I've encountered that sentiment as well
21:33:40 <Berengal> Anyway, these days most languages are dynamic...
21:33:40 <Saizan> ah, the joy of type inference
21:33:45 <Cale> Many people have never used a language with a decent type system.
21:33:53 <thoughtpolice> woot
21:33:55 <QtPlaty[HireMe]> And unfortunitly commidity lanagues with full type inference are few and far between
21:33:57 <Apocalisp> QtPlaty[HireMe]: It's interesting that many of them have used SQL, a statically typed interpreted language that has no type annotations.
21:33:59 <Nafai> Unfortunately, the likes of Java and C# give that impression that's what static typing is and people don't want to bother with it
21:34:13 * thoughtpolice is happy to see that an optimized build of HEAD+dph results in pretty nice, not-gc intensive code that is competetive with strategies
21:34:20 <Nafai> Apocalisp: I've never thought of it that way!  Great example.
21:34:22 <QtPlaty[HireMe]> Apocalisp: It depends on the dialect.
21:34:31 <Berengal> Java and C# are what I'd call dynamic languages now
21:34:33 <Cale> Apocalisp: But most of them wouldn't think of SQL as a programming language.
21:34:45 <Berengal> They're just as bad at being dynamic as they are at being static though
21:35:06 <QtPlaty[HireMe]> Berengal: Can you explain why?
21:35:07 <vixey> I hear that Haskell can be dynamic
21:35:15 <Twey> Haskell can be dynamic
21:35:20 <Nafai> Berengal: C# sort of; Java...not so much.
21:35:21 <Apocalisp> For some reason, I thought "dynamic" meant "has lots of paretheses" :p
21:35:22 <vixey> if you do some horrid compilicated typeclass stuff
21:35:34 <vixey> like the compiler can't resolve them at compile time
21:35:40 <Cale> vixey: There's Data.Dynamic...
21:35:47 <vixey> no I don't mean that
21:35:52 <Berengal> QtPlaty[HireMe]: You can get functions from a string. That alone is enough to make something dynamic for me
21:36:13 <Cale> "Dynamic typing" is easy, you just make a big enough type and then use that for everything, and define your operations on it to fail when things don't line up how you want ;)
21:36:17 <Berengal> Not _good_ dynamic, mind you
21:36:27 <QtPlaty[HireMe]> Berengal: java has an eval?
21:36:29 * wli barfs
21:36:32 <Twey> vixey: Data.Dynamic is dynamic typing
21:36:35 <vixey> no
21:36:45 <vixey> I mean runtime class dispatch
21:36:49 <Cale> DO NOT WANT
21:36:50 <Nafai> QtPlaty[HireMe]: Reflection
21:36:56 <NEEDMOAR> I think she means like when the compiler can not state by using static typing, it uses some kind of dynamic typing.
21:37:10 <Berengal> QtPlaty[HireMe]: Well, I believe it does have that too, but I'm just talking about reflection, and the ability to add stuff to an object at runtime
21:37:10 <NEEDMOAR> But probably she will say she didn't mean it.
21:37:12 <Cale> vixey: That sounds like a very different thing from dynamic typing....
21:37:29 <vixey> Berengal says java is dynamic
21:37:52 <vixey> the only dynamic thing is class dispatch, which Haskell can do at runtime too (in very awkward corner cases)
21:38:22 <Cale> Can you clarify what class dispatch means here, so that I can be sure I know what you're talking about?
21:38:23 <Berengal> vixey: It's dynamic enough to not be static. It's nothing compared to the other dynamic languages out there though
21:38:25 <Neut> What is a cleaner way to write this code?
21:38:27 <Neut> where maxC = maximum $ map fst moves
21:38:28 <NEEDMOAR> Btw, does anyone know about a work on the denotational semantics of Javascript?
21:38:28 <lament> Berengal: and haskell has unsafePerformIO, but neither is exactly the "core language"
21:38:29 <Neut>       mover = filter ((==maxC).fst) moves
21:38:33 <vixey> Cale choosing which instance
21:38:55 <Cale> Neut: That's not bad...
21:39:00 <Berengal> lament: Reflection is part of the core language
21:39:10 <lament> Berengal: i suppose this is a matter of taste.
21:39:25 <Neut> Cale: ok, just seemed long winded
21:39:32 <vixey> denotational semantics of Javascript *laugh*
21:39:41 <QtPlaty[HireMe]> I suspect it is more a question of how one uses the language rather then what is permitted.
21:39:49 <lament> indeed
21:39:52 <Cale> (\(x,y) -> x == maxC) might be clearer?
21:40:40 <QtPlaty[HireMe]> I mean data.dynamic and unsafe* allow you to right superdirect imperative code/dyamic code but its in within the spirit of haskell.
21:43:05 <NEEDMOAR> vixey: :-)
21:44:32 <Neut> Twey: best m = head . reverse . group . sort $ m
21:44:45 <vixey> better = head . reverse . group . sort
21:44:53 <Neut> No instance for (Ord Int)
21:44:54 <vixey> head . reverse = last
21:45:10 <vixey> use a flipped comparison and take the head without reversing
21:45:10 <Neut> without changing type, what could be a solution?
21:45:35 <dmwit> Neut: How about [(x, y) | (x, y) <- moves, x == maximumBy fst moves]?
21:45:48 <dmwit> :t maximumBy
21:45:50 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
21:45:52 <dmwit> err
21:45:59 <dmwit> :t maximumBy (comparing fst)
21:46:01 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
21:46:02 <Twey> Neut: Um
21:46:05 <dmwit> like that
21:46:18 <Twey> What do you mean, ‘no instance for (Ord Int)’?
21:46:27 <Twey> Ints are quintessentially ordered
21:46:33 <hatds> wondering that myself :)
21:46:35 <dmwit> Neut: Also, yeah, you better give us the exact error message.
21:46:37 <Twey> And there is most certainly an Ord instance for every Num
21:49:53 <Neut> Exact error,
21:50:30 <Neut> No instance for (Ord (Hills Int)) arising from use of 'sort'
21:50:35 <Neut> where Hills is a data type
21:50:59 <Twey> Yes, well
21:51:07 <Twey> How can you have a maximum if your data type isn't ordered?
21:51:18 <hatds> Foo Int doesn't automatically inherit Int's instances
21:51:24 <Twey> Probably, adding ‘deriving Ord’ to the end of your data declaration will do what you want
21:51:53 <Twey> Additionally, that final argument is redundant
21:51:59 <Twey> best = head . reverse . group . sort
21:52:28 <Neut> last . group . sort
21:52:39 <Neut> wouldnt your way cause additional computation on the list?
21:52:59 <Twey> No
21:53:03 <Twey> @src last
21:53:03 <lambdabot> last [x]    = x
21:53:03 <lambdabot> last (_:xs) = last xs
21:53:03 <lambdabot> last []     = undefined
21:53:17 <Twey> last is O(n) anyway
21:53:24 <Twey> It is nicer, though, I'll admit
21:53:45 <Neut> Wouldnt head revrese both be O linear as well?
21:54:34 <Neut> @src head
21:54:35 <lambdabot> head (x:_) = x
21:54:35 <lambdabot> head []    = undefined
21:54:47 <Neut> @src reverse
21:54:48 <lambdabot> reverse = foldl (flip (:)) []
21:55:01 <clug> How do you put more than one function at the beginning of a list comprehension?
21:55:08 <akafubu> i am looking for examples where prolog is used in primarily the business market
21:55:18 <akafubu> s/prolog/haskell
21:55:20 <BMeph> Why isn';t reverse defined as a worker-wrapper? :)
21:55:20 <Neut> :Twey wouldnt that make them the same O(n)?
21:55:36 <Twey> Yes
21:55:45 <dmwit> clug: I'm not sure what you mean.
21:55:50 <Twey> Use last, though :)
21:55:57 <dons> akafubu: http://haskell.org/haskellwiki/Haskell_in_industry
21:56:17 <Neut> :Twey , why do you prefer head . reverse over sort if they are the same time?
21:56:23 <akafubu> ttp://www.haskell.org/haskellwiki/Haskell_in_industry
21:56:26 <clug> like [function1 x, function2 x| x<-[0..20]]
21:56:27 <akafubu> ah, dons
21:56:30 <Twey> Neut: I don't
21:56:32 <clug> but , doesn't work
21:56:37 <Twey> I'm telling you to use last x.x
21:56:38 <akafubu> thanks
21:56:47 <Neut> ok, just wondered if there was a reason is all.
21:56:55 <dmwit> clug: How about [(function1 x, function2 x) | x <- [0..20]]?
21:57:10 <dmwit> clug: Or, better, map (function1 &&& function2) [0..20]
22:01:48 <Neut> @src group
22:01:48 <lambdabot> group = groupBy (==)
22:03:59 <Neut> hmm
22:04:04 <Neut> whats wrong with this
22:04:18 * vixey starts to have nightmares that modus ponens isn't true
22:04:26 <Neut> test m = last ((==sort).group) $ m
22:04:39 <dmwit> You can't compare functions.
22:04:42 <vixey> test'better = last ((==sort).group)
22:04:47 <dmwit> (==sort) -- wrong
22:05:22 <Neut> Why?
22:05:31 <Saizan> you mean (\x -> x == sort x) i guess?
22:06:07 <Saizan> however last there doesn't make sense
22:06:15 <Saizan> Neut: what are trying to do?
22:06:30 <akafubu> i see similarities in the languages that i would like to study.
22:06:41 <akafubu> english | python
22:06:44 <akafubu> spanish/portuguese | c/c++
22:06:48 <Neut> with a list of a data tree of Ints, i want to extract the largest Ints
22:06:48 <akafubu> russian | haskell
22:06:55 <akafubu> mandarin | java
22:07:00 <Neut> as a list
22:07:04 <akafubu> english, most everyone can speak it
22:07:09 <Neut> :@Saizan
22:07:10 <akafubu> mandarin, don't want to learn it but seems like i may need to know it
22:07:14 <Twey> Spanish and C++?
22:07:18 <Twey> Mandarin and Java?
22:07:23 <dibblego> Neut, sort will give you back a sorted list
22:07:24 <Twey> o.@
22:07:26 <akafubu> spanish would be helpful to know on a more regular basis for me than russian, but russian is definitely a unique language with more logic built-in than english
22:07:38 <Neut> I can't change to Ord or Eq
22:08:20 <dmwit> Neut: I think you've managed to confuse yourself somewhere along the way, but I can't put my finger on exactly where.
22:08:42 <dmwit> Let's start with Ord and Eq; you know that they are not types, right?
22:08:46 <Saizan> Neut: well, do you have a way to extract the largest Int out of a single tree?
22:08:49 <dmwit> (This is an easy mistake to make.)
22:08:52 <Neut> Yes I do
22:09:03 <Neut> they allow the types to be compared or ordered though corect?
22:09:14 <Neut> when you are defining your own types
22:09:16 <dmwit> They allow values to be compared and ordered, yes.
22:09:32 <dancor_> haskell is probably more like esperanto
22:09:37 <dmwit> lojban
22:09:38 <dancor_> who has to be lojban?
22:09:42 <Neut> :Saizan no that is waht I am currently working on
22:09:46 <dmwit> dancor_: prolog, maybe
22:09:56 <kyevan> Lojban is probably Lisp
22:09:56 <Saizan> Neut: ok, so you can first apply that to all the trees in the list with map, and then you'll have a list of Int's which you can sort and take the last element, or use maximum
22:10:43 <Saizan> Neut: ah, ok, so first write that one separately, and then worry about the list
22:10:52 <kyevan> English is Objective-C++ :P
22:11:04 <dancor_> pidgin english is apple script
22:11:34 <akafubu> heh
22:11:35 <dancor_> ipa is assembler
22:11:44 <Neut> Saizan: So step 1 function to get __
22:11:54 <ray> haskell is latin or some good language!
22:11:54 <akafubu> also of note, there is work to make a lojban compiler
22:11:56 <dmwit> ipa is binary: it can be used to represent any language
22:11:58 <Neut> Not following 100%
22:12:02 <akafubu> so lojban = lojban
22:12:22 <Saizan> Neut: a function to extract the largest Int from your tree
22:12:24 <kyevan> Ray: Fsck latin.
22:12:26 <dancor_> lojban is funny for making language parsing easy for computers, as if that is the hard part of computer cognition..
22:12:45 <kyevan> Latin is why people think constructs like "to boldly go" are invalid
22:12:57 <ray> someone doesn't know latin
22:13:09 <ray> don't be bitter, learn it!
22:13:12 <edwardk> That is the sort of nonsense up with which we will not put.
22:13:18 <dancor_> rtfd ;)
22:13:23 <Neut> :Saizan ok, I've done that. But it gives an 'a', next maximum $ map larInt m
22:13:27 <Neut> try something like that?
22:13:29 <kyevan> ray: I don't, but I *do* know that's where the split-infinitve rule comes from
22:13:40 <ray> infinitives are one word in latin @_@
22:13:47 <kyevan> In latin it was one word, so it couldn't be split. Right.
22:13:54 <kyevan> That's NOT true in English.,
22:13:55 <dancor_> how do you say 'ownage' in latin
22:14:04 <ray> i couldn't care less if you paid me
22:14:18 <dmwit> dancor_: I believe it's ovnage.
22:14:19 <ray> it'd have to be a loanword!
22:14:25 <dancor_> dmwit: omlol
22:14:26 <kyevan> Yet "academics" and such say you 'can't' do split infinitives in English because you can't in Latin.
22:14:39 <kyevan> ray: Eh, just emphasize "own"
22:14:50 <ray> no, some people say it now and then, and the origins were people who wanted english to be latin
22:15:10 <kyevan> Right...
22:15:12 <kyevan> Anyway.
22:15:14 <ray> in summary, learn latin
22:15:26 <edwardk> That and the market for prescriptivist grammar texts back in the 20s when everyone flipped out about proper grammar.
22:15:27 <TomMD> Has anyone in here used the Atom library?
22:15:32 <kyevan> Why, though?
22:15:40 <ray> because it's a great language
22:15:40 <kyevan> No one really uses it.
22:15:42 <dmwit> In summary, Latin is dead and the language with the most speakers is Mandarin.
22:15:48 <ray> as a roman catholic, i must disagree
22:15:49 <kyevan> I'd rather spend my time learning something I can actually /use/
22:16:06 <TomMD> kyevan: Like Atom?
22:16:08 <kyevan> ray: Roman Catholics aren't people. I'm only interested in talking to people.
22:16:10 <ray> you probably like applied math, too
22:16:16 <kyevan> :P
22:16:18 <Neut> :Saizan that worked, fine but now I have a type issue... GARGHHHHHHHHHHHHH
22:16:50 <dmwit> Neut: Great!  That means the compiler caught a bug for you before it became serious. =)
22:16:55 <Neut> map (rage*1000) neut
22:16:57 <kyevan> (Also, even in the RCC, they're moving towards using the local language for most everything, so :P)
22:17:32 <ray> not only do you not know latin, you seem not to be catholic! :P
22:17:34 <dmwit> TomMD: Well, you might as well ask, anyway.
22:17:40 <Neut> :dmwit it's great depending on your perspective :)
22:17:46 <ray> but that is orthogonal to the fact that latin is a great language
22:18:05 <kyevan> Why is it a great language?
22:18:08 <TomMD> dmwit: I don't have much to ask - I was just wondering how well Atom lends itself to equational reasoning
22:18:09 * dmwit points ray and kyevan at #haskell-blah now that there are actually Haskell questions being asked
22:18:29 * ray vanishes in a puff of haskell
22:18:45 <edwardk> bah, go back in time and you find that the romans used to hate vulgar latin and praised greek. i'm sure the greeks looked back on earlier dialects fondly as well. ;)
22:18:54 <TomMD> I've been considering developing a firmware for an ARM based system and if I do then Atom will be the first tool I consider.
22:19:14 <Saizan> Neut: maybe paste some code with the error?
22:19:49 <TomMD> But if I'm unclear as to where Atoms benefits lay - reasoning?  programmer efficiency?  correctness?
22:20:24 <edwardk> tommd: as i understand it, its a pain in the butt to write the microstep machines that atom builds when you want to build one by hand,
22:21:02 <Saizan> keeping a big structure in memory that's supposed to stay alive for all the life of the program can increase GC time a lot?
22:22:00 <edwardk> the principal benefit seems to be that you can reason about separate concerns in different rules in isolation and let it thread them together.
22:23:52 <Neut> I have to go
22:23:54 <Neut> thanks for the help,
22:23:56 <akafubu> how is work for turbinado coming along?
22:23:58 <Neut> I will most likely be back
22:29:10 <kyevan> > (\x -> x+1) 1
22:29:12 <lambdabot>   2
22:29:22 <kyevan> Oh, hey, that /does/ work, yay :j
22:29:49 <dons> of course (?)
22:29:53 <akafubu> interesting post: http://haskell-web.blogspot.com/2006/11/transactional-cache-for-haskell.html "But Haskell still has many holes for rapid application development, something that is vital for escalating Haskell from naive, fun driven web projects to industrial acceptance. It lacks a MVC (Model View Controller) framework. Haskell has not something like Rails for Rubi or Hibernate for Java. "
22:29:57 <kyevan> There's no reason it shouldn't, but I'm wary of believing things wil >_<
22:30:09 <dons> akafubu: 2006/11
22:30:11 <akafubu> i realize http://hackage.haskell.org/platform/ is underway, progress update?
22:30:24 <dons> check hackage.haskell.org
22:30:27 <akafubu> dons: please update where you see outdated material
22:30:45 <dons> well, since 2006, hackage.haskell.org was launched. there's now more than 1250 libraries available for haskell
22:31:14 <dons> in addition, the platform was launched last week, meaning a standard distribution for all systems.
22:31:26 <dons> the equivalent of rails, is happstack, which also didn't exist in 2006.
22:31:44 <vegai> happs is a bit more radical, though. Perhaps turbinado?
22:31:51 <dons> yeah, that's fair.
22:32:40 <kyevan> Ugh, rails >_<
22:33:11 <kyevan> I /like/ Ruby and I think Rails is worth less than the drive it's stored on >_<
22:33:28 <akafubu> thanks for the update dons
22:33:59 <akafubu> rails isn't terrible for n00bs such as myself
22:34:09 <akafubu> same for django
22:34:40 <akafubu> sure there are lightweight alts
22:35:48 <kyevan> nnnn I need a usable text editor that runs in a terminal >_<
22:36:06 <mauke> vim
22:36:08 <hydo> emacs
22:36:12 <hydo> ;)
22:36:17 <sjanssen> ed
22:36:48 <mauke> emacs doesn't run in a terminal
22:36:59 <mauke> you need something like DISPLAY= emacs or the command line option I always forget
22:37:01 <hydo> yes it does
22:37:03 <dons> mauke doesn't run in a terminal
22:37:05 <hydo> no, incorrect
22:37:11 <kyevan> yes it does, but it's icky and not fun >_>
22:37:16 <kyevan> Same with vi. and ed. >_>
22:37:17 <hydo> WRONG, I SAY!
22:37:18 <hydo> hehe
22:37:36 <mauke> hydo: I just tried 'emacs' and it opened a new window
22:37:44 <dons> xemacs?
22:37:50 <kyevan> I tried it and it ran in a terminal.
22:38:00 <hydo> mauke: I just tried 'emacs' and it opened another beatifully functional editor for me in a new xterm.
22:38:02 <mauke> ... and it's frozen
22:38:09 <kyevan> (then I had to look up how to quit >_>)
22:38:10 <hydo> it's all... bee-yoo-tee-fuhl
22:38:15 <dons> mg is a good emacs for the mini fun people
22:38:22 <mauke> ... a new xterm? how did you configure that?
22:38:26 <hydo> (and then I quit and went back to carbon emacs) :cough*
22:39:14 <kyevan> Heh, I normally use textwranger if I fee like using the mouse, though...
22:39:46 <hydo> mauke: direct your shock and amazement here: http://img.skitch.com/20090514-kyjxnm889msdywned2breap1aq.jpg
22:39:59 <dons> omg
22:40:05 <dons> its emacs
22:40:10 <dons> and ... its in a terminal!!
22:40:19 <hydo> *flex*
22:40:29 <sjanssen> ewww, OS X
22:40:32 <kyevan> also...
22:40:35 <vegai> photoshopped!
22:40:39 <hydo> haha
22:40:48 <hydo> skitchified!
22:40:53 <kyevan> why does terminal.app insist it's not color-capable? >_>
22:41:25 <hydo> kyevan: it can be... that's plain old xterm and not terminal.all
22:41:28 <hydo> app, too
22:41:41 <kyevan> heh.
22:41:52 <kyevan> x11 is a big heavy slow evil monster though
22:42:06 <hydo> kyevan: direct further shock and amazement this-a-way: http://img.skitch.com/20090514-pwtgw6m3qtfeymapwwjec1ewwt.jpg
22:42:10 <hydo> (I love skitch)
22:42:24 <kyevan> Yeah, I know it *is*
22:42:30 <sjanssen> kyevan: prove it (I bet you can't)
22:42:36 <hydo> oooo
22:42:40 <kyevan> But by default it sets the terminal up to tell apps it isn't. :J
22:43:05 <sjanssen> oh, X11.app might suck on OS X, I'll buy that.
22:43:12 <hydo> kyevan: yea, it's an underachiever like that.  A little configuration though can turn it into a Little Lebowski Urban Achiever though.
22:43:12 <kyevan> sjanssen: It's personal experience and opinion, of course I can't.
22:43:17 * sjanssen is just tired of X11 haters
22:43:23 <vegai> hydo: rails logs... on a Haskell channel? Are you mad?!
22:43:27 <kyevan> Well.
22:43:42 * vegai should work...
22:43:47 <kyevan> On GNU/Linux it just likes to fail mysteriously now and then <_<
22:43:47 <akafubu> I wrote Turbinado (http://www.turbinado.org), an MVC Haskell framework in the vein of Ruby On Rails. I've been busy and haven't had too much time to work on it recently, but I'm a big fan of using Haskell for web apps. The biggest problem I've had has been the relative lack of maturity in Haskell libraries (mine included).
22:43:48 <akafubu> As a fan, Haskell! For productivity, Rails...
22:43:50 <hydo> vegai: there's what I *do* and my j.o.b.  Someday, maybe, the two shall meet.  Until then.
22:43:59 <akafubu> http://jekor.com/article/is-haskell-a-good-choice-for-web-applications
22:44:40 <roconnor> > iterate ('a':) []
22:44:41 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
22:44:47 <akafubu> i will say haskell has dons and twey which i see all over the place and dons helped me with xmonad awhile back :)
22:44:58 <roconnor> > iterate ("abc":) []
22:44:59 <lambdabot>   [[],["abc"],["abc","abc"],["abc","abc","abc"],["abc","abc","abc","abc"],["a...
22:45:05 <roconnor> > iterate ("abc":) [[]]
22:45:07 <lambdabot>   [[""],["abc",""],["abc","abc",""],["abc","abc","abc",""],["abc","abc","abc"...
22:45:18 <roconnor> > iterate (liftM2 (:) "abc") [[]]
22:45:19 <lambdabot>   [[""],["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","...
22:45:58 * roconnor 's head boggles a bit
22:46:11 <roconnor> ok
22:46:19 <roconnor> slowly making sense
22:46:19 <centrinia> > map ($0) (iterate (. (+1)) id)
22:46:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:46:24 <roconnor> > iterate (liftM2 (:) "abc") []
22:46:25 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
22:47:19 <centrinia> > iterate (liftM2 (:) [0,1]) [[]]
22:47:21 <lambdabot>   [[[]],[[0],[1]],[[0,0],[0,1],[1,0],[1,1]],[[0,0,0],[0,0,1],[0,1,0],[0,1,1],...
22:48:01 <dons> akafubu: you looking to do MVC apps?
22:48:08 <centrinia> They look like lists of sequences of fixed length.
22:48:32 <dons> i mean, clearly, we don't have a rail, you're expected to be motivated, and help build things still.
22:48:38 <dons> have a "rails"
22:49:12 <centrinia> What would Haskell on Rails be useful for?
22:49:25 <dons> you mean, a rich haskell web framework?
22:49:28 <hydo> I'm going to assume that that's a joke.
22:50:18 <centrinia> I don't quite understand what putting a language On Rails would imply.
22:51:20 <hydo> oh, just a nice framework for writing web applications.  But it being haskell would make it, among other things, very very elegant.  Rails isn't a big success because of Ruby, I don't think... it's the general idea.
22:51:31 <hydo> but that sounds like I know what I'm talking about and that would be false.
22:51:55 <johnw> also, a web framework which is "convention over configuration"
22:52:10 <hydo> Time for more tea and less blabbermouth.
22:52:12 <akafubu> dons: yes sir
22:52:25 <hydo> <-- the blabbermouth, in case anyone took that wrong.
22:52:37 <akafubu> :P
22:52:38 <Twey> akafubu: Erm
22:52:43 <Twey> akafubu: dons is all over the place
22:52:46 <Twey> akafubu: I'm just a noob :)
22:52:57 <akafubu> Twey: you're in #japanese right?
22:53:01 <Twey> Yeah
22:53:06 <akafubu> then there ya go :)
22:53:16 <Twey> Oh, I thought you meant to do with Haskell :-P
22:53:21 <dons> it gets tiring being all over  the place
22:53:21 <Twey> Cale's there, too.
22:53:24 <akafubu> not sure what it has to do with haskell just yet.. :)
22:53:31 <akafubu> yup
22:53:33 <Twey> Hehe
22:53:50 <akafubu> i have over 100 channels open and can never pay attention but to ~2-5/day
22:53:55 <vegai> well, everyone who works with web should at least take a look at happstack
22:54:15 <vegai> it's a bit different
22:54:19 <akafubu> yeah, reading the comments on that last linked website.. someone said happstack scales well
22:54:34 <vegai> does it? I'm not so sure
22:55:45 <vegai> it should have vastly better single instance performance than rails, though
22:55:51 <akafubu> i really like gitit!
22:56:24 <akafubu> wanting to have a git clone of my entire site
22:57:10 <akafubu> what does haskell.org use?
22:57:35 <hydo> gitit++
22:59:22 <hydo> happstack is awesome.  My problem is that I don't know enough haskell yet to put it to use.  Otherwise i'd be writing my current project in it.
22:59:34 <kyevan> Gah why are there no OS X terminal emulators that don't suck?
22:59:58 <hydo> I hesitate to say... iterm?  iterm was kinda slow the last time I used it though.
23:00:28 <kyevan> iterm is great if you're a hunt-and-pecker >_>
23:00:43 <hydo> I'm many things, but a pecker, I am not.
23:00:56 <hydo> and as you can see I like commas.
23:03:01 <kyevan> iterm seems to not handle color at all >_>
23:04:14 <kyevan> huh.
23:04:28 <kyevan> It sets 'xterm' not 'xterm-color'? weird.
23:04:58 <vegai> unix terminals are such an evolutionary deadend anyway
23:04:58 <jthing> strange setup..
23:05:49 <jthing> should be a vt220
23:05:59 <dons> vegai: they do seem to have stopped evolving.
23:06:16 <jthing> and yes it is in a sense a dead end.
23:06:25 <Apocalisp> PowerShell is interesting.
23:06:39 <jthing> ah windows vista
23:06:46 <Apocalisp> used to be called "Monad"
23:06:54 <dons> shells are still pretty poor as far as languages go, but you should use them as programming languages anyway.
23:06:59 <dons> just as job control DSLs
23:07:01 <jthing> yes, I use that some times
23:07:27 <Apocalisp> PowerShell 2.0 seems a massive improvement, by the way.
23:07:43 <hydo> Apocalisp: so they didn't decide to call it "Warm, Fuzzy Shell" either eh?
23:08:11 <Apocalisp> I guess they figured out that Monad was already reserved by the implementors.
23:08:24 <jthing> javascript is closer than fuzzy
23:09:22 <hydo> I wonder how bad an idea it would be to wipe my macbook and put ubuntu on it at this late hour.  Xmonad is calling my name... "Clint... you know how productive you are with me... come, relax in my warm embrace..."
23:09:27 <jthing> Monads are a good design pattern, which reduces side effects
23:10:05 <hydo> Monads are still partially witchcraft to me... but I'm getting there.
23:10:13 <jthing> me too
23:10:29 <Apocalisp> In PowerShell, the | pipe is kleisli composition.
23:11:50 <kyevan> I haven't met anything better than unix shells, though.
23:12:16 <kyevan> hydo: You can probably get xmonad running on x11 on OS X :J
23:12:25 <kyevan> In fact, one of my friends has done it
23:12:34 <hydo> wow... all of the rednecks in my area must be off getting drunk or beating their wives.  I'm pulling the ubuntu cd image at 2+mbps over plain ol' comcast cable.
23:12:40 <kyevan> Heh.
23:12:43 <kyevan> Or asleep
23:12:56 <kyevan> Or fscking, if you know what I mean :J
23:13:03 <hydo> naw, too much meth
23:13:07 <hydo> they never sleep
23:13:11 <jthing> lol
23:13:29 <hydo> they're all toothless running around trying to find someone to start an apple for them.
23:13:37 * jthing get's another cup of tea
23:14:04 <hydo> hah... I just woke my wife up laughing at the apple thing.
23:14:10 <mae_> question, Control.TimeOut(addTimeout) -- produces implicit thread? if i use something that blocks will it prevent the timeout from ocurring?
23:14:11 <hydo> I KILL ME
23:14:21 <jthing> hydo: I though that was Steve's Job ;)
23:14:39 <hydo> jthing: *rimshot*
23:14:56 <sjanssen> mae_: I believe the implementation does use threads, yes
23:15:14 <mae_> ok second question, what all does waitForProcess block? everything?
23:15:19 <mae_> its own thread?
23:15:30 <sjanssen> mae_: are you using -threaded or not?
23:15:37 <mae_> -threaded
23:15:54 <sjanssen> with -threaded, only its own thread
23:16:01 <mae_> hmm
23:16:19 <sjanssen> I believe waitForProcess makes an FFI call, which are uninterruptible
23:17:08 <mae_> sjanssen: ok so here, http://patch-tag.com/r/happstack/snapshot/current/content/pretty/happstack-util/src/Happstack/Util/AutoBuild.hs
23:17:32 <mae_> line 49-53, line 74,75
23:17:56 <mae_> buildKillLoop is supposed to respawn itself every 5 seconds
23:18:06 <mae_> but it ends up only doing it once
23:18:19 <mae_> could waitForProcess be blocking the timeout action from ocurring?
23:18:56 <kyevan> Oh, um...
23:19:15 <kyevan> Has anyone used Dr. Scheme, by any chance? Is there an environment kinda like that for Haskell?
23:19:26 <kyevan> It's really nice for testery :J
23:20:25 <hydo> hrm.  Is arch linux all that?  I keep hearing about it here.  I gather it has the best haskell system packages?
23:20:36 <kyevan> I mean, that can switch between the interactive and the source file without doing save-quit-open the other program-load-work-save-quit-open the other program -work... :J
23:20:45 <dons> kyevan: not as nice as Dr.Scheme. leksah is pretty close to an IDE though
23:20:48 <dons> leksah.org
23:21:09 <centrinia> > reverse "leksah.org"
23:21:10 <lambdabot>   "gro.haskel"
23:21:23 <dons> hydo: it has a /lot/ of haskell system packages (and competes with gentoo for early adoption of major tools)
23:21:30 <sjanssen> mae_: recovering from a runaway process, one moment
23:21:41 <hydo> dons: awright... I'll try it instead of ubuntu.
23:21:59 <kyevan> centrinia: Heheh.
23:22:00 <TomMD> hydo: At the same time, a functional cabal installation is all I've needed - and I've been on arch for about a year now.
23:22:09 * sjanssen hears you have to do lots of tinkering in Arch
23:22:13 <dons> yeah, pacman -S cabal-install
23:22:20 <TomMD> hydo: Not trying to discourage you from trying Arch - its' certainly nice, clean, and stable.
23:22:25 <dons> sjanssen: definitely. it's more like openbsd than any linux i've used
23:22:27 <dons> very minimal
23:22:29 <kyevan> > reverse [reverse, map]
23:22:30 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> b'
23:22:35 <kyevan> Oh wait... yeah >_>
23:22:41 * kyevan shrugs
23:22:53 <mae_> dons: hola, how goes oregano
23:22:57 <mae_> wait i meant oregon
23:23:05 <kyevan> > reverse [(+), (-), (*), (/)]
23:23:06 <lambdabot>       Overlapping instances for Show (a -> a -> a)
23:23:06 <lambdabot>        arising from a use ...
23:23:12 <kyevan> Blah :J
23:23:21 <kyevan> It totally worked, it just can't show it :P
23:23:27 <hydo> TomMD: I have a feeling I'm going to like it.  I used to be a pretty die-hard slackware user.
23:23:49 <TomMD> Then yes - I suspect you will be right at home.
23:24:00 <mae_> sjanssen: ok
23:26:17 <hydo> 30meg install image.  Thatswhatimtalkinbout!
23:26:29 <sjanssen> mae_: this seems overly complex
23:26:42 <akafubu> unlike russian, i will probably learn haskell
23:26:44 <akafubu> http://eng.expert.ru/printissues/countries/2006/09/russkiy_yazyk_v_blizhayshem_zarubezhe/209953
23:26:52 <sjanssen> mae_: why not just threadDelay in buildKillLoop?
23:26:58 <akafubu> unscientific to base my opinion on one article though
23:27:40 <sjanssen> mae_: note that addTimeout returns immediately
23:29:32 <vegai> why did they have to make threadDelay take an Int?!
23:30:18 <vegai> 2100 seconds is enough for everybody
23:30:55 <mae_> sjanssen: right, but it should start
23:31:06 <dons> 31 minutes or some such on 32 bit
23:31:10 <dons> bit longer on 64 bit.
23:31:14 <kyevan> > 60*60*24
23:31:15 <lambdabot>   86400
23:31:16 <dons> vegai: but i think it's the underlying C api.
23:31:24 <sjanssen> mae_: Control.Timeout also uses only one thread to do anything
23:31:27 <dons> still, yeah, it's a bit weird.
23:31:28 <kyevan> That's no where near enough for one day, vegai.
23:31:49 <mae_> sjanssen: hmm ok, still doesn't explain why its not starting, but i will look into threadDelay
23:32:09 <vegai> kyevan: I know
23:32:20 <mae_> sjanssen: thanks!
23:32:44 <vegai> dons: yeah, that would explain it. Would've been nice if they had wrapped around it and have threadDelay :: Integer -> IO ()
23:33:11 <vegai> also, I guess the compiler doesn't warn about this
23:33:13 <dons> so you can only threadDelay at most 9223372036854 seconds
23:33:21 <dons> (i.e. you'd have to wake up, check the time, then go back to sleep)
23:33:32 <vegai> dons: much less on 32bit
23:33:39 <dons> yeah, 2147 s
23:34:05 <kyevan> (Incidentally, why was it 525,600 minutes, not 31,536,000 seconds? And really, isn't it closer to 525,960 minutes anyway, in the long run?)
23:34:06 <vegai> I had at some point defined a threadDelay of more than that
23:34:11 <vegai> worked fine on my 64bit
23:34:19 <vegai> then I deployed to a 32bit machine ..
23:34:24 <hydo> kaboom?
23:34:30 <dons> would be cool to upload an Integer-based threadDelay built out of the actual one
23:34:47 <kyevan> ... OK, when I start talking about Rent, it's time to sleep. Good night!
23:34:51 <vegai> hydo: a bit
23:36:42 <vegai> dons: should be a oneliner... even if a slightly wide one
23:37:05 <vegai> where's that MAX_INT
23:37:11 <vegai> @hoogle MAX
23:37:11 <lambdabot> Prelude max :: Ord a => a -> a -> a
23:37:12 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
23:37:12 <lambdabot> Prelude maxBound :: Bounded a => a
23:37:27 <vegai> ah
23:37:41 <Gracenotes> a typeclass, no less!
23:37:48 <vegai> yeah, pretty cool
23:37:58 <Gracenotes> of course, different on different machines
23:38:22 <Gracenotes> potentially
23:41:56 <sjanssen> mae_: I think the problem is that the building thread has a stale process handle to the running thread
23:43:24 <vegai> ah, I don't remember the typeclass hierarchies again. How to do Int -> Integer?
23:43:36 <sjanssen> vegai: fromIntegral
23:43:50 <vegai> thanks
23:46:26 <mae_> sjanssen: define stale handle? it should be getting the new one every time.
23:47:09 <sjanssen> mae_: well, there will be a pending buildKillLoop timeout with a ph that might have already finished
23:48:02 <mae_> sjanssen: right, but the semantics of buildKillLoop are such that if this is the case, it will return ()
23:48:21 <jthing> return from certain death :)
23:48:23 <mae_> the docs for getPRocessExitCode say that if it returns Nothing then this means that it has not exited yet (hence has not died)
23:48:52 <vegai> @pase
23:48:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:49:05 <vegai> lambdabot: thanks for not whining about my stupid typo
23:49:29 <jthing> that's AI for you
23:49:42 <vegai> so, a first stupid implementation: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4864#a4864
23:50:57 <jthing> vegai: maxBound vs maxI
23:52:26 <vegai> hmm, sorry?
23:53:06 <jthing> You assign it a type rather than a value
23:54:07 <vegai> maxI :: Int = maxBound -- you mean?
23:54:14 <dons> gwern: did you ever look at putting wash on hackage?
23:54:39 <jthing> vegai: that one
23:55:01 <vegai> oh, in fact... the compiler apparently can figure that out too
23:55:06 <vegai> I somehow thought it might not
23:55:31 <vegai> huh, it doesn't
23:55:39 <vegai> that's a bit odd
23:55:50 <vegai> I can have
23:55:54 <vegai> where maxI = maxBound
23:56:00 <sjanssen> mae_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4865#a4865 is some pseudocode that should work
23:56:16 <vegai> but if I remove that and replace maxI with maxBound, I get "Ambiguous type variable"
23:56:20 <sjanssen> mae_: note this approach requires -threaded
23:56:43 * vegai shrugs
23:57:40 <mae_> sjanssen: was trying to avoid the use of semaphores :)
23:58:33 <mae_> sjanssen: i will definitely look into this approach, but i still don't see how the handle being stale would cause the timeout to not occur, if the handle is stale then the buildKillLoop just returns
23:58:47 <mae_> (stale means exited or closed right?)
23:59:51 <sjanssen> yeah
23:59:56 <sjanssen> I might be off in that
