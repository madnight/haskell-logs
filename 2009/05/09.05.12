00:00:55 <dmwit> copumpkin: still not what you're looking for
00:01:05 <copumpkin> oh :(
00:01:05 <dmwit> copumpkin: Where are you going to get that first a from? ;-)
00:01:16 <copumpkin> good point :P
00:01:23 <dmwit> Monad m => (a -> Bool) -> (a -> m a) -> (a -> m a)
00:01:40 <copumpkin> aha
00:02:01 <copumpkin> @hoogle Monad m => (a -> Bool) -> (a -> m a) -> (a -> m a)
00:02:02 <lambdabot> No results found
00:04:58 <copumpkin> :t let while p f a = do x <- f a; if p x then return a else while p f x in while
00:04:59 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> Bool) -> (t -> t1 t) -> t -> t1 t
00:06:30 <copumpkin> not particularly exciting in that form
00:09:31 * coCocoa is surprised by how useful "const succ" is...
00:10:09 * dmwit overdoses on co
00:10:24 <pjolk> @type const
00:10:25 <lambdabot> forall a b. a -> b -> a
00:10:30 <pjolk> @src const
00:10:31 <lambdabot> const x _ = x
00:10:40 <pjolk> > const succ 3
00:10:41 <lambdabot>       Overlapping instances for Show (a -> a)
00:10:41 <lambdabot>        arising from a use of `s...
00:10:48 <pjolk> > const succ (3,4)
00:10:49 <lambdabot>       Overlapping instances for Show (a -> a)
00:10:50 <lambdabot>        arising from a use of `s...
00:10:56 <pjolk> @src succ
00:10:56 <lambdabot> Source not found. I am sorry.
00:11:00 <pjolk> @type succ
00:11:02 <lambdabot> forall a. (Enum a) => a -> a
00:11:03 <pjolk> ?
00:11:13 <pjolk> how can you use const succ?
00:11:17 <otto_s> >const succ undefined 5
00:11:30 <pjolk> > const succ undefined 5
00:11:31 <lambdabot>   6
00:11:43 <pjolk> > const succ 5 undefined
00:11:44 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
00:11:53 <pjolk> > const succ 5 6
00:11:55 <lambdabot>   7
00:12:09 <jfredett_> > const succ 3 3
00:12:10 <pjolk> huh
00:12:11 <lambdabot>   4
00:12:12 <copumpkin> I guess my while above should really be called whilenot
00:12:13 <pjolk> > succ 5 6
00:12:14 <lambdabot>       No instance for (Enum (t -> a))
00:12:14 <lambdabot>        arising from a use of `succ' at ...
00:12:29 <pjolk> const transforms the succ function?
00:12:34 <pjolk> what really happens there?
00:12:41 <jfredett_> const ignores it's second argument
00:12:43 <otto_s> @src const
00:12:43 <lambdabot> const x _ = x
00:12:44 <jfredett_> and returns it's first
00:12:53 <jfredett_> so const foo x = foo
00:13:02 <pjolk> wouldnt it just take the function then?
00:13:11 <pjolk> > const 5 6
00:13:12 <lambdabot>   5
00:13:13 <pjolk> > const 5 6 7
00:13:14 <jfredett_> so const succ x = succ, so const succ x y = succ y
00:13:14 <lambdabot>       No instance for (Num (t -> a))
00:13:15 <lambdabot>        arising from the literal `5' at <...
00:13:19 <copumpkin> it gobbles up the second argument but does nothing with it
00:13:33 <pjolk> > const (+3) 6 7
00:13:34 <lambdabot>   10
00:13:41 <jfredett_> it's useful when you need to turn a unary argument to a binary one
00:13:42 <pjolk> > const $ flip (+3) 6 7
00:13:43 <lambdabot>       Overlapping instances for Show (b1 -> c)
00:13:43 <lambdabot>        arising from a use of `...
00:13:47 <pjolk> > const flip (+3) 6 7
00:13:48 <coCocoa> foldr (const succ) 0 [0..11]
00:13:48 <lambdabot>       Overlapping instances for Show (a -> c)
00:13:48 <lambdabot>        arising from a use of `s...
00:13:52 <coCocoa> > foldr (const succ) 0 [0..11]
00:13:53 <lambdabot>   12
00:13:57 <pjolk> > const 10 20
00:13:58 <lambdabot>   10
00:14:22 <jfredett_> :t const
00:14:23 <lambdabot> forall a b. a -> b -> a
00:14:28 <jfredett_> :t map
00:14:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:14:38 <jfredett_> :t map const
00:14:39 <lambdabot> forall a b. [a] -> [b -> a]
00:15:08 * copumpkin makes Bool into a Monad
00:15:18 <jfredett_> :t map (\f -> f 1) (map const [1..10])
00:15:20 <lambdabot> forall a. (Enum a, Num a) => [a]
00:15:24 <jfredett_> map (\f -> f 1) (map const [1..10])
00:15:32 <jfredett_> > map (\f -> f 1) (map const [1..10])
00:15:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:15:39 <jfredett_> hehe, it
00:15:44 <jfredett_> it's obfuscated!
00:16:02 <jfredett_> > map (\f -> f 1) (map (flip const) [1..10])
00:16:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
00:16:25 <jfredett_> > map (\f -> f 1) (map (flip const) [1..10]) == replicate [1] 10
00:16:26 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
00:16:30 <jfredett_> > map (\f -> f 1) (map (flip const) [1..10]) == replicate 10 [1]
00:16:31 <lambdabot>       No instance for (Num [t])
00:16:31 <lambdabot>        arising from the literal `1' at <inter...
00:16:34 <jfredett_> :t replicate
00:16:36 <lambdabot> forall a. Int -> a -> [a]
00:16:40 <jfredett_> > map (\f -> f 1) (map (flip const) [1..10]) == replicate 10 1
00:16:41 <lambdabot>   True
00:16:47 <jfredett_> nifty...
00:16:55 <jfredett_> thats mildly evil. :)
00:17:15 <jfredett_> > map ($ 1) (map (flip const) [1..10]) == replicate 10 1
00:17:17 <lambdabot>   True
00:17:37 <jfredett_> excellent. now if we swap a few arguments around so they're non idiomatic...
00:18:01 <jfredett_> > ($ 1) `map` ((flip const) `map` [1..10]) == replicate 10 1
00:18:02 <lambdabot>   True
00:18:51 <jfredett_> > ($ 1) `map` ([1..10] `(flip map)` (flip const)) == replicate 10 1
00:18:52 <lambdabot>   <no location info>: parse error on input `('
00:18:59 <jfredett_> > ($ 1) `map` ([1..10] `flip map` (flip const)) == replicate 10 1
00:19:00 <lambdabot>   <no location info>: parse error on input `map'
00:19:08 <copumpkin> using `id` is more obscure I think
00:19:10 <jfredett_> damn, you can't do `flip foo` ?
00:19:11 <copumpkin> > (`id` 1) `map` ((flip const) `map` [1..10]) == replicate 10 1
00:19:12 <lambdabot>   True
00:19:14 <copumpkin> nope
00:19:44 <jfredett_> > let fmap = flip map in (id 1) `map` ([1..10] `fmap` (flip const)) == replicate 10 1
00:19:45 <lambdabot>       No instance for (Num ((a -> a) -> b))
00:19:45 <lambdabot>        arising from the literal `...
00:19:49 <copumpkin> lol
00:19:58 <jfredett_> that would have been _very_ evil
00:20:02 <jfredett_> if it had worked.
00:20:10 <jfredett_> > let fmap = flip map in (`id` 1) `map` ([1..10] `fmap` (flip const)) == replicate 10 1
00:20:11 <lambdabot>   True
00:20:16 <jfredett_> ooh- sweet...
00:20:45 <jfredett_> > let fmap = flip map in (`id` error "Muahahah") `map` ([1..10] `fmap` (flip const)) == replicate 10 1
00:20:47 <lambdabot>   * Exception: Muahahah
00:20:49 <jfredett_> hmm
00:20:56 <jfredett_> oh- that actually makes sense
00:21:20 <jfredett_> > let fmap = flip map in (`id` ) `map` ([1..10] `fmap` (flip . flip $ const)) == replicate 10 1
00:21:21 <lambdabot>   <no location info>: parse error on input `)'
00:21:38 <jfredett_> > let fmap = flip map in (`id` error "Muahaha") `map` ([1..10] `fmap` (flip . flip $ const)) == replicate 10 1
00:21:39 <lambdabot>   False
00:21:44 <jfredett_> > let fmap = flip map in (`id` error "Muahaha") `map` ([1..10] `fmap` (flip . flip $ const))
00:21:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:21:50 <jfredett_> there we go...
00:22:11 <jfredett_> :t enumFromTo
00:22:12 <lambdabot> forall a. (Enum a) => a -> a -> [a]
00:22:21 <jfredett_> > let fmap = flip map in (`id` error "Muahaha") `map` (enumFromTo 1 10 `fmap` (flip . flip $ const))
00:22:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:22:30 <rwmjones> what's happened to 'haskell-cafe'?
00:22:37 <jfredett_> the mailing list?
00:22:42 <rwmjones> yes, the ML
00:22:50 <copumpkin> the disk filled up
00:22:53 <jfredett_> it went quiet for most of today- I don't think I recieved anything from it...
00:22:55 <jfredett_> lol
00:22:56 <copumpkin> and the list is catching up now that they fixed it
00:24:14 <jfredett_> okay, enough obfuscation fun for one night.
00:24:18 <jfredett_> gnite people.
00:25:05 <rwmjones> so is anyone getting mail from that list?  I've not seen anything for a couple of days
00:25:23 <copumpkin> I guess it'll be up and running again soon
00:25:28 <copumpkin> but I doubt anyone's getting mail from it
00:28:24 * coCocoa watches the Crashin' Thrashin' IRC client... :(
00:30:40 <pjolk> so is lambdavm a serious project?
00:30:54 <pjolk> hey dons, did you get ghc running on iphone?
00:48:09 <PetRat> I'm working with HDBC.. still learning basic stuff about Haskell, so what I'm trying to wrap my mind around is stuff like--- you can access the database with quickQuery' which has a return type of IO [[SqlValue]].
00:48:33 <Saizan_> right
00:48:38 <PetRat> Does that mean that any function I write using quickQuery' has to have a return type of IO a?
00:49:23 <PetRat> In other words, I can only call that function in do-notation (or the equivalent) inside a function which is "inside the IO monad" (if that's the right term)
00:49:38 <dmwit> ridht
00:49:50 <dmwit> You're a quick learner. =)
00:50:17 <PetRat> Thanks uh, dimwit? dmwit?
00:50:22 <PetRat> The font is small.
00:50:46 <PetRat> :)
00:51:44 <voker57> @hoogle Just a -> a
00:51:44 <lambdabot> Did you mean: Maybe a -> a /count=20
00:51:44 <lambdabot> Prelude id :: a -> a
00:51:44 <lambdabot> Data.Function id :: a -> a
00:51:53 <voker57> @hoogle (Just a) -> a
00:51:53 <lambdabot> Did you mean: Maybe a -> a /count=20
00:51:53 <lambdabot> Prelude id :: a -> a
00:51:53 <lambdabot> Data.Function id :: a -> a
00:52:45 <PetRat> And the theoretical reason for this is probably because interacting with a database is IO---that is, it's interacting with the state of the world so we need a way to prevent violating referential transparency (or something like that---not sure if those are the right words for it).
00:53:43 <PetRat> From a functional perspective, the world is a thing from which we can construct a new thing.
00:54:30 <mmorrow> PetRat: ghci is killer for querying sql dbs
00:55:01 <PetRat> mmorrow: why is that?
00:55:42 <PetRat> I mean, I'm having fun with it so I'm not surprised. It's the first language I've used to access DBS.
00:55:56 <weilawei> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4818#a4818 <- can someone explain to me how the types in renderedOutput change? i got it working but this whole monads inside monads and lifting thing has me confused
00:56:04 <mmorrow> you can use haskell to both the SQL, and then the walk over the tree of Maps of Tries of SQL you've just built running the code at each node (e.g.)
00:56:16 <mmorrow> *..both build the SQL ...
00:56:34 <PetRat> Is this using
00:56:39 <PetRat> Database.HDBC?
00:57:12 <halberd> I want to simulate some ants... anybody know where I might find a highly simplified model of an ant's next move, based purely local information (including the pheremones surrounding it)?
00:57:14 <mmorrow> i use (a hacked version + my own misc code) for sql db stuff, but it's pretty much the same idea regardless the lib
00:57:22 <mmorrow> *of hsql that is
01:05:28 * Twey doesn't understand why showIntAtBase can't take a function (Int -> b) and return [b]
01:05:38 <dmwit> It does seem rather silly.
01:05:54 <Twey> It does
01:08:13 <PetRat> I mentioned this yesterday but worth revisitng. In S. Thompson's book, he asks us to define 'init' in terms of foldr.
01:08:44 <PetRat> It seems like some of gimmicky solution is necessary... I can't figure out if there is a "natural" way to do it.
01:09:10 <vixey> how did you do it?
01:09:15 <Twey> > init [1, 2, 3]
01:09:17 <lambdabot>   [1,2]
01:09:21 <Twey> Hm
01:09:37 <PetRat> http://www.mibbit.com/pb/3DbsZR
01:09:38 <lewellyn> hi. is this a good place to ask about features in lambdabot?
01:10:01 <Twey> Oh, that's pretty neat, PetRat
01:10:22 <PetRat> In folding, you somehow have to recognize the rightmost expression as special, while stick with [a] as the folding type.
01:10:41 <vixey> well it's not valid code
01:11:08 <Twey> It's just missing an =
01:11:15 <Twey> The idea is the point :-P
01:11:25 <PetRat> I did test it yesterday. May have mistyped something now.
01:11:57 <vixey> @let f xs a b = if length b == length xs then [] else a : b
01:11:58 <lambdabot>  Defined.
01:12:13 <vixey> > let xs = [1,2,3] in foldr (f xs) xs xs
01:12:14 <lambdabot>       Ambiguous occurrence `f'
01:12:15 <lambdabot>      It could refer to either `L.f', defined a...
01:12:20 <vixey> @let fffff xs a b = if length b == length xs then [] else a : b
01:12:21 <lambdabot>  Defined.
01:12:25 <vixey> > let xs = [1,2,3] in foldr (fffff xs) xs xs
01:12:27 <lambdabot>   [1,2]
01:14:17 <vixey> PetRat do you know about  Maybe  ?
01:14:21 <mmorrow> PetRat: getting familiar with Data.(Int)Map is really handy for db stuff
01:14:48 <vixey> (have a go with maybe if you want to find the natural implementation)
01:15:08 <PetRat> vixey: I've used some Maybes. Of course it's not introduced yet in Thompson's book at this point. :(
01:15:09 <lewellyn> does anyone have a better place i can ask questions about lambdabot, specifically?
01:15:43 <PetRat> One would like to assume an author expects you to solve the problems with material introduced previously.
01:16:03 <vixey> alright just forget it then
01:20:11 <PetRat> http://www.mibbit.com/pb/LMr7Io  <- Is this solution something like using Maybe? (not checked or debugged)
01:20:26 <vixey> type error
01:21:55 * ManateeLazyCat pasted "my code" at http://paste2.org/get/206632
01:21:56 <ManateeLazyCat> I want *instane Ord* type `Page` with function `pageGetName :: Page -> IO String`, how to write this instance. I write like above code, but failed. Any help?
01:22:15 <ManateeLazyCat> "instance Ord"
01:22:34 <Saizan_> ManateeLazyCat: you can't use IO in an Ord instance
01:23:47 <ManateeLazyCat> Saizan_: So how to fix? Add another function with type signature "Page -> Page -> Bool"?
01:24:14 <Saizan_> it'll be Page -> Page -> IO Bool
01:24:31 <PetRat> vixey: one syntax error (needed -> not = [old imperative habits die hard]) and one pair of parenthesis.
01:24:33 <Zao> Fetch the name beforehand and shove it into Page?
01:24:50 <quicksilver> ManateeLazyCat: the reason you can't use IO in an Ord instance is that an IO function might return different values each time it is called.
01:25:02 <quicksilver> ManateeLazyCat: if you know that, in fact, pageGetName always returns the same value (For a given page)
01:25:08 <quicksilver> then it may be safe to unsafePerformIO it.
01:27:19 <JaffaCake> I think the mailing lists are working again
01:27:26 <JaffaCake> it'll take a while for the queues to drain though
01:30:56 <Saizan_> ?bug
01:30:56 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
01:31:50 * ManateeLazyCat pasted "my code" at http://paste2.org/get/206639
01:31:50 <ManateeLazyCat> Above is my code snippets about type `Page`. So i can't write Ord instance?
01:32:16 <Saizan_> i always get GHC.Any instead of type variables in inferred "~" constraints, is this a known bug?
01:32:57 <quicksilver> ManateeLazyCat: I believe I have answered your question rather completely.
01:33:06 <quicksilver> ManateeLazyCat: which part of the answer would you like me to explain in more detail?
01:33:09 <PetRat> In a practical sense, how does "wrapping" IO functions make them more safe? I know that conceptually, the IO monad is a way of saying, "The world is a big place which transforms itself after every IO operation.."
01:33:13 <quicksilver> there's not much point me jsut repeating it.
01:33:57 <Saizan_> PetRat: the point is that you can identify the large part of your code that it's referentially transparent
01:34:13 <PetRat> Instead of the world being nodeterministic, we actually pretend it has a state and that it regenerates its state after every operation.
01:34:36 <Saizan_> no, we don't pretend it has a state
01:34:41 <PetRat> Saizan_ not quite parsing your statement there. Identify the part that's NOT referentially transparent?
01:35:05 <Saizan_> well, yeah, you divide one from the other :)(
01:35:34 <Saizan_> the advantage is that reasoning on the ref. transparent part (the pure code) is way easier
01:35:52 <PetRat> But it seems to have a philosophical connotation to me. Maybe that's useless thinking.
01:37:39 <ManateeLazyCat> quicksilver: I think i have understand which the problem, IO might will return different value, then Ord instance is insignificant if i use IO to compare.
01:39:41 <quicksilver> ManateeLazyCat: Yes. But if you know, in fact, that the tyhing will always return the same value
01:39:48 <quicksilver> then you have the option of wrapping it in unsafePerformIO.
01:40:01 <ManateeLazyCat> quicksilver: In fact, it's not.
01:40:12 <ManateeLazyCat> quicksilver: I will change it's value at runtime
01:40:53 <ManateeLazyCat> quicksilver: I write Ord instance for Data.Set, i think i should change data structure since pageName will change at runtime.
01:44:24 <ManateeLazyCat> Thanks all for help. :)
01:44:55 <tombee> Say you were wanting to get the 'last element' from a list, would you use a fold for this?
01:45:07 <tombee> or would it  be better just to pattern match?
01:45:21 <ManateeLazyCat> :t last
01:45:23 <lambdabot> forall a. [a] -> a
01:45:34 <tombee> @src last
01:45:35 <lambdabot> last [x]    = x
01:45:35 <lambdabot> last (_:xs) = last xs
01:45:35 <lambdabot> last []     = undefined
01:45:45 <tombee> hm that's the day I've done it anyway.
01:45:51 <tombee> way*
01:46:14 <ManateeLazyCat> :t undefined
01:46:15 <lambdabot> forall a. a
01:46:18 <tombee> When would you use a fold? :s
01:47:54 <Saizan_> anytime you find you'll write something of the form: foo [] = z; foo (x:xs) = ... foo xs ..
01:48:16 <Saizan_> (roughly)
01:48:29 <Saizan_> that's for foldr
01:49:35 <tombee> And foldr is 'better' in some way than doing the above? :)
01:49:45 <tombee> (sorry if these questions are dumb) :p
01:50:52 <dmwit> foldr is more idiomatic
01:51:01 <osfameron> also aromatic
01:51:08 <dmwit> It helps the experienced readers by exposing your recursion strategy.
01:51:56 <Saizan_> yeah, the point is that explicit recursion is less structured, so it needs more attention to realize what it's doing
01:52:06 <tombee> Ah ok, so its purely a readability thing?
01:52:21 <dmwit> yep
01:52:26 <tombee> Does it compile into something 'more' efficient if you use foldr?
01:52:29 <Saizan_> it's also a matter of efficiency, because of the way list fusion works
01:52:31 <tombee> is kinda what I'm asking I suppose
01:52:32 <Berengal> When it comes to last, I don't think there's much of a different
01:52:35 <Berengal> difference*
01:52:38 <dmwit> tombee: Nah, the optimizing compiler is pretty smart.
01:52:52 <Berengal> I mean, foldr1 (flip const)?
01:53:00 <Saizan_> list fusion doesn't kick in for explicitly recursive functions
01:53:11 <Berengal> It'd say it takes about as much mental effort to parse that as the explicit recursive one
01:53:36 <Saizan_> Berengal: yeah, for simple cases the tradeoff is more blurry
01:54:46 <Saizan_> foldr is often used inline, without giving a name to the function, also
01:58:15 <tombee> Just having such a hard time learning haskell, as I can't visualise how I can apply it to something 'useful'
01:58:33 <tombee> But that's down to my lack of understanding :/
02:02:14 <Saizan_> well, start with what you think it's useful and write it in haskell :)
02:02:20 <ManateeLazyCat> tombee: Haskell is very useful, and not just a toy. Example i use gtk2hs (GTK binding with Haskell) to develop GUI program. And very nice.
02:02:55 <tombee> Saizan_: that's the problem, i can't find something small enough to write that's useful :P
02:03:11 <nipuL> just write stuff, even if it
02:03:16 <ManateeLazyCat> tombee: Other programming language save your time, Haskell save your soul.
02:03:17 <nipuL> 's not useful
02:03:49 <tombee> Heh I've come to that conclusion nipuL, but can't think of any good exercises :)
02:03:52 <vixey> tombee: Just pick something useful and implement it in haskell -- you're ready now
02:03:52 <vixey> You're not going to learn this any other way
02:03:59 <tombee> I'm just doing those 99 Problems
02:04:16 <osfameron> Project Euler is good for starter exercises
02:05:07 <tombee> Hmm ok :)
02:06:26 <Hunner> how about a jabber<=>irc bot in haskell? That would be useful
02:06:34 <Zao> osfameron: If you like abstract math, sure.
02:06:38 <vixey> no it wouldn't
02:07:10 <Zao> Hunner: Use bitlbee?
02:07:27 <Hunner> bitlbee isn't written in haskell :)
02:07:37 <wjt> I feel like implementing an XMPP server in Haskell might be fun
02:07:57 <vegai> wjt: it still has xml, though.
02:08:24 <habb> damn, no software interest me anymore. stuff that i would like to program becuase it interest is already done, music (spotify,last.fm) and so is photography(flickr). computer games dont interest me anymore.
02:08:37 <habb> wtf i love programming but dont have anything to program anymor.
02:08:46 <tombee> spotify and last.fm suck :)
02:08:54 <habb> why?
02:08:54 <tombee> Well, spotify half sucks now. :/
02:09:06 <habb> if you pay it is great
02:09:13 <habb> great way to find new music
02:09:13 <LeCamarade> habb, Solve an unsolvable problem.
02:09:27 <habb> tombee: how would a musicservice that workslook?
02:09:42 <tombee> It works, just its content is poor :)
02:11:12 <habb> well content is not a problem i can solve really
02:11:27 <Saizan_> habb: start writing interpreters/compilers
02:11:32 <habb> genetic music with haskore
02:11:57 <habb> Saizan_: nah, why? ghc is already great, id need to get a PhD to do something better.
02:12:07 <habb> i want to create endproducts
02:12:31 <vixey> I don't think they just give you PhDs for doing the excercises in Dragon book
02:12:49 <habb> who said they do?
02:13:40 <tombee> @src length
02:13:40 <lambdabot> Source not found. Sorry.
02:13:49 <dmwit> habb: Your problem is you've stopped being interesting in rewriting things that have already been done. ;-)
02:14:13 <dmwit> :t foldl'
02:14:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:14:42 <dmwit> :t foldl' (const succ) 0
02:14:43 <lambdabot> forall a. (Num a, Enum a) => [a] -> a
02:14:54 <dmwit> whoops
02:15:09 <dmwit> :t foldl' (\x _ -> succ x) 0
02:15:10 <lambdabot> forall a b. (Num a, Enum a) => [b] -> a
02:15:31 <dmwit> ?pl \x _ -> succ x
02:15:31 <lambdabot> const . succ
02:28:32 <tombee> How would you write a foldr which incremented from 0 for each item in the list
02:28:36 <tombee> i.e. length
02:28:50 <zloog> @src length
02:28:50 <lambdabot> Source not found. Do you think like you type?
02:29:10 <vixey> foldr (\x ys -> 1 + ys) 0
02:29:37 <vixey> that turns  a : b : c : []  into  1 + (1 + (1 + 0))
02:29:40 <tombee> Ok, but I don't understand why the list argument is missing? :s
02:30:00 <vixey> > foldr (\x ys -> 1 + ys) 0 "abc"
02:30:01 <lambdabot>   3
02:30:10 <vixey> > let length = foldr (\x ys -> 1 + ys) 0 in length "xyz"
02:30:11 <lambdabot>   3
02:30:35 * Zao partially applies functions to tombee 
02:30:37 <zloog> tombee: Partial function application
02:30:59 <Zao> @type zip
02:31:00 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
02:31:02 <Zao> @type zip [0..]
02:31:03 <lambdabot> forall t b. (Enum t, Num t) => [b] -> [(t, b)]
02:31:10 <pjolk> is length what you wanted=
02:31:20 <doserj> > foldr (const (+1)) 0 "abc"
02:31:21 <lambdabot>   3
02:31:50 <pjolk> > let average = foldr (\next (summa, len) -> (summa+next, len+1)) (0,0) in average [1..5]
02:31:51 <lambdabot>   (15,5)
02:31:54 <Zao> By feeding a list to zip, we magically get a function that takes the remaining arguments.
02:32:04 <doserj> no matter what the element is (-> const) add one to the result (-> (+1))
02:32:08 <pjolk> > let average = foldr (\next (summa, len) -> (summa+next, len+1)) (0,0) in average [1..5]
02:32:09 <lambdabot>   (15,5)
02:32:22 <pjolk> hmm can you do something neat with applicable or arrow to compute average?
02:32:29 <pjolk> (15,5) -> 15 / 5
02:32:49 <pjolk> > (/) <*> (15,5)
02:32:50 <lambdabot>   Couldn't match expected type `a -> a'
02:32:56 <Deewiant> > uncurry (/) (15,5)
02:32:58 <lambdabot>   3.0
02:33:08 <pjolk> > let average = uncurry (/) $ foldr (\next (summa, len) -> (summa+next, len+1)) (0,0) in average [1..5]
02:33:09 <lambdabot>   Couldn't match expected type `(a, a)'
02:33:31 <pjolk> > let average xs = uncurry (/) $ foldr (\next (summa, len) -> (summa+next, len+1)) (0,0) xs in average [1..5]
02:33:33 <lambdabot>   3.0
02:33:41 <pjolk> why do i need to add xs ?
02:35:27 <quicksilver> because you're using $
02:35:28 <tombee> Heh sorry, was just reading about partial function application :)
02:35:40 <tombee> Yes length is what I wanted, but it's one of the exercises to write it for yourself. :)
02:35:43 <pjolk> > let average = uncurry (/) . foldr (\next (summa, len) -> (summa+next, len+1)) (0,0)  in average [1..5]
02:35:45 <lambdabot>   3.0
02:36:10 <quicksilver> @pl \xs -> f $ g xs
02:36:11 <lambdabot> f . g
02:36:33 <pjolk> > let average = uncurry (/) . foldr (\next (summa, len) -> (summa+next, len+1)) (0,0)  in average <$> [[1..5],[6..10]]
02:36:34 <lambdabot>   [3.0,8.0]
02:36:59 <pjolk> > let average = uncurry (/) . foldr (\next (summa, len) -> (summa+next, len+1)) (0,0)  in average <$> [[1..5],[6..10],[]]
02:37:01 <lambdabot>   [3.0,8.0,NaN]
02:37:02 <pjolk> > let average = uncurry (/) . foldr (\next (summa, len) -> (summa+next, len+1)) (0,0)  in average <$> [[1..5],[6..10],[8]]
02:37:04 <lambdabot>   [3.0,8.0,8.0]
02:37:55 <zloog> I'm working in gtk2hs and when trying to use  treeModelGetRow with a particular set of args on a sort model, I'm getting an uncaught exception. I wrapped it in an exception handler but the program still crashed so I think the error is occurring in c. is there any reasonable way to get the scenario loaded into gdb?
02:37:57 <pjolk> category has scary names
02:38:17 <doserj> > foldr (\x -> (+x) *** (+1)) (0,0) [1..10]
02:38:19 <lambdabot>   (55,10)
02:38:40 <pjolk> > let average = uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,0) [1..10] (0,0)  in average <$> [[1..5],[6..10],[8]]
02:38:41 <lambdabot>   Couldn't match expected type `(t, t1) -> a -> (a1, a1)'
02:38:52 <pjolk> > let average = uncurry (/) . foldr (\x -> (+x) *** (+1)) (0,0) in average <$> [[1..5],[6..10],[8]]
02:38:53 <lambdabot>   [3.0,8.0,8.0]
02:39:51 <pjolk> it is funny how many things I thought about Haskell and OO turned out to be so wrong.
02:40:35 <pjolk> Like a person living in 200 before christ and making up his own theories for things and then wakes up in 2000 after christ and sees he didnt have a single thing right
02:41:20 <pjolk> I think it is unfortunate that people only TRY Haskell, then they will probably walk away with "yeah, nice in theory". If they actually learn it then they will go on strike of forced to use anything else.
02:42:48 <earthy> pjolk: not true
02:43:00 <earthy> I've voluntarily written VB.net after having learned Haskell
02:43:07 <zsol> @tell pumpkin_ There's not much to show yet, not really exciting. Stay tuned for the next release @ end of May, should be more interesting by then.
02:43:07 <lambdabot> Consider it noted.
02:43:16 <earthy> language advocacy has little place in the Real World
02:43:56 <pjolk> earthy: what is not true?
02:44:09 <pjolk> obv they waont strike, i was making a point
02:44:19 <earthy> noted
02:44:26 <earthy> it's not a really valid one though
02:44:32 <pjolk> why not?
02:44:51 <pjolk> zsol: what are you working on?
02:45:07 <earthy> people that actually learn haskell, at least currently, tend to be people interested in programming per se
02:45:16 <earthy> haskell is a nice formalism to program in
02:45:23 <earthy> however, there are other nice formalisms as well
02:45:29 <earthy> and other not-so-nice formalisms
02:45:40 <earthy> in the end however it is still all programming
02:45:45 <earthy> and that is what matters
02:47:00 <zloog> Anyone know what a pp file is?
02:47:05 <zloog> as in chs.pp ?
02:47:15 <Twey> Something to do with preprocessing?
02:47:33 <Twey> For me, it's not the safety I miss so much as the flexibility
02:47:56 <pjolk> planned parenthood
02:47:56 <Twey> I can easily code in Javascript after Haskell because it provides as much flexibility (or more, even), but Java hurts
02:48:03 <Twey> Haha
02:48:05 <zloog> oh nos@
02:48:40 <Twey> http://filext.com/file-extension/pp
02:49:06 <Twey> I think it's probably the Perl Data Language PreProcessor File
02:49:17 <Twey> But it could also be the Free Pascal Source Code File
02:49:22 <Twey> Does it look like Pascal?
02:49:49 <zloog> Nah, but I'm reading some old blogs about how they were doing this with perl scripts before
02:49:56 <zloog> so thats probably it
02:50:00 <Twey> Paste some of it, maybe
02:50:33 <zloog> Looks a lot like regular haskell files
02:50:52 <Twey> Hm
02:51:04 <Twey> PDL::PP doesn't look much like Haskell at all.
02:51:09 <zloog> something to do with c binding
02:51:34 <Twey> Probably a file for one of the FFI preprocessors, then
02:51:37 <Twey> Something like GreenCard?
02:53:23 <zloog> something like
02:53:44 <Twey> You could grep to see where it's called
02:54:32 <pjolk> so who did Data.Monoid again?
02:54:47 <pjolk> and would it be good to build a mapreduce framework on top of it?
02:54:55 <pjolk> is that what is was created for?
02:55:09 <quicksilver> Data.Monoid is a standard library
02:55:17 <quicksilver> but you're probably thinking of edwardk's monoid stuff
02:56:37 <pjolk> oh
02:56:39 <pjolk> which is that?
02:57:17 <quicksilver> http://comonad.com/haskell/monoids/dist/doc/html/monoids/
02:57:21 <quicksilver> but the server seems to be down?
02:57:24 <pjolk> yes
02:57:53 <quicksilver> http://downforeveryoneorjustme.com/comonad.com
03:01:33 <zloog> http://downforeveryoneorjustme.com/downforeveryoneorjustme.com
03:14:57 <pjolk> what is the fast way to append strings?
03:15:13 <pjolk> foldl (++) "" strings is bad right?
03:16:35 <pjolk> (:) and reverse?
03:17:08 <pjolk> > let append = reverse . foldl (++) "" in append ["hello","there"]
03:17:09 <lambdabot>   "erehtolleh"
03:17:20 <pjolk> > let append = reverse . foldl (:) "" in append ["hello","there"]
03:17:21 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
03:17:21 <lambdabot>        Expect...
03:17:25 <pjolk> > let append = reverse . foldr (:) "" in append ["hello","there"]
03:17:27 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
03:17:48 <pjolk> > let append = reverse . foldl (:) "" in append $ concat ["hello","there"]
03:17:49 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
03:17:49 <lambdabot>        Expect...
03:17:58 <pjolk> > concat ["hello","there"]
03:17:59 <lambdabot>   "hellothere"
03:18:10 <pjolk> @src conca
03:18:10 <lambdabot> Source not found. My mind is going. I can feel it.
03:18:11 <pjolk> @src concat
03:18:12 <lambdabot> concat = foldr (++) []
03:18:23 <pjolk> wait foldr (++) is goodie goodie right?
03:18:32 <quicksilver> foldr (++) is fine.
03:18:48 <quicksilver> but if you have a tree-shaped structure, it's best to use functions like (String -> String)
03:19:03 <quicksilver> and compose them all with (.) before finally applying to ""
03:19:13 <quicksilver> there is a DList newtype around for that purpose
03:19:15 <quicksilver> @hoogle DList
03:19:16 <lambdabot> package dlist
03:19:16 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
03:19:16 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
03:19:50 <povman> I just noticed the new haskell logo is a lambda on a bind. Are monads really that significant?
03:20:18 <quicksilver> povman: No.
03:20:26 <quicksilver> povman: that is why I voted against the new logo.
03:20:33 <quicksilver> well that, and I think it's a bit ugly and looks like a train company.
03:20:40 <quicksilver> But, it has its plus poitns I guess.
03:20:51 <povman> It's kinda clever.
03:21:15 <pjolk> its kinda giggidi giggidi
03:21:24 <pjolk> the hellask oen was awesome¨
03:21:27 <pjolk> who did that?
03:21:52 <quicksilver> I like cale's lambda-mountain
03:21:56 <quicksilver> but there you go.
03:22:02 <quicksilver> The flaw in democracy is that not everyone agrees with me.
03:22:19 <povman> hah
03:22:52 <pjolk> anyone have an example of a good looking gtk gui?
03:22:55 <Japsu> The flaw in democracy is that not everyone has a clue.
03:23:05 <wjt> pjolk: written with gtk2hs, you mean?
03:23:07 <pjolk> the standard one is so friggin ugly compared to Swing or Qt
03:23:11 <pjolk> yes gtk2hs
03:23:20 <pjolk> the buttons etc looks like a 1992 gui
03:23:33 * wjt likes his slightly-hacked-up clearlooks gtk theme
03:23:37 <povman> pjolk: You can apply themes...
03:24:00 <idnar> the appearance is solely determined by the theme engine
03:24:03 <Japsu> pjolk, http://gnome-look.org/
03:24:13 <idnar> which is a system configuration setting, not an application thing
03:24:47 <pjolk> I use windows
03:26:35 <Japsu> tough luck.
03:26:47 <halberd> Japsu: the flaw in anarchy is that not everyone has a club
03:27:00 <Japsu> halberd, :D
03:27:07 <Philonous1> look in "c:\program files\common files\GTK" there should be a theme selector exe somewhere around
03:27:29 <idnar> halberd: that's why anarchocapitalism is great, you can buy a club from somebody else
03:28:26 <pjolk> randroids?
03:28:42 <younder> what on earth is anarhocapitalism? :)
03:29:08 <younder> web commerce?
03:29:32 <pjolk> http://en.wikipedia.org/wiki/Anarchocapitalism
03:29:59 <jml> also http://www.theonion.com/content/news/nevada_to_phase_out_laws
03:32:19 <povman> Wow. I actually hate most of the other logo entries.
03:33:07 <wjt> Haskell! YEAAAAAAAAH
03:33:20 <povman> this one here is like 1000 pixels high
03:37:58 <pjolk> how do I declare instance TypeClass String where?
03:38:04 <pjolk> because String isn'tallowed
03:38:24 <younder> You don't..
03:38:54 <paper_cc> why isn't it allowed?
03:39:06 * paper_cc looks at Data.Data, Data.Typeable etc
03:39:12 <quicksilver> it's a dull restriction in haskell98
03:39:13 <younder> A String is a List of Char-arcters
03:39:14 <paper_cc> (for String, that is)
03:39:18 <quicksilver> -XFlexibleInstances
03:39:19 <paper_cc> oh
03:39:19 <younder> and already defined
03:39:20 <quicksilver> to permit it.
03:39:20 <pjolk> llegal instance declaration for `MapReducable String'
03:39:20 <pjolk>         (All instance types must be of the form (T t1 ... tn)
03:39:20 <pjolk>          where T is not a synonym.
03:39:24 <pjolk> -XTypeSynonymInstances if
03:39:32 <quicksilver> yeah, that too.
03:39:47 <quicksilver> you'll need -XTypeSynonymInstances and -XFlexibleInstances
03:41:33 <paper_cc> Data.Unique provides one with runtime unique values. But what should I do if I want compile-time ones?
03:42:08 <younder> Seriously redefining types is usually a source of confusion, why do you wnat to do this?
03:42:15 <younder> want
03:42:44 <pjolk> cuz im flippin crazy
03:42:58 <paper_cc> (that is, I want to write something like keyOne :: ObjectKey; keyTwo :: ObjectKey; and have keyOne != keyTwo)
03:43:45 <Axman6> just make up randon values :\
03:43:54 <quicksilver> paper_cc: there are no values at compile time.
03:43:56 <povman> paper_cc: That sounds like something you could achieve with TH
03:44:03 <quicksilver> paper_cc: so I'm not quite sure what you mean by 'compile-time unique values'
03:44:19 <paper_cc> Axman6: I want the compiler to generate them =)
03:44:20 <quicksilver> sounds like Data.Unique is what you want?
03:44:58 <paper_cc> quicksilver: more like (unsafePerformIO newUnique), but that won't work
03:45:20 <quicksilver> ah, so it's not a compiletime runtime thing
03:45:24 <quicksilver> you just don't want them in IO :P
03:46:10 <paper_cc> quicksilver: all possible values are known at compile time (they are defined in the source)
03:47:12 <paper_cc> quicksilver: more like an enumeration type with possible values spread in the source files
03:47:49 <quicksilver> I think that's probably solvable with TH.
03:47:54 <quicksilver> TH lets you do IO at compile time.
03:48:04 <quicksilver> I woudln't know how, though ;)
03:48:19 <quicksilver> I'd look for mmorrow or edwardk, it sounds like their level of evilness.
03:48:22 <povman> You could probably get it to generate your values too
03:48:58 <paper_cc> unique MyKey; key1 :: MyKey; key2 :: MyKey <=> data MyKey = Foo1 | Foo2; key1 = Foo1; key2 = Foo2
03:49:04 * paper_cc goes to learn TH :(
03:50:15 <povman> paper_cc: Can you paste your code?
03:50:41 <povman> paper_cc: Why do you need key1/2?
03:53:18 <paper_cc> povman: a caching facility, where the cache is indexed by values of type MyKey and key1 identifies a cacheable entity
03:54:11 <povman> paper_cc: Why don't you just use Foo1 and Foo2? You know they're unique...
03:55:02 <quicksilver> presumably he wants to add other files later
03:55:08 <quicksilver> without having to keep renumbering and stuff.
03:55:13 <paper_cc> povman: because key1 is in one.hs and key2 is in two.hs
03:55:18 <quicksilver> it's a version of the open data type problem.
03:55:20 <povman> Oh right.
03:55:34 <quicksilver> you should consider how separate compilation works.
03:55:46 <quicksilver> that gives you a kind of 'upper bound' on what is possible.
03:56:00 <quicksilver> one.hs and two.hs could be compiled separately, in any order
03:56:08 <quicksilver> how is the uniqueness to be 'communicated' between them?
03:56:28 <quicksilver> I can imagine a solution where TH writes to a temporary file in a known location, for example.
03:56:34 <quicksilver> obviously that's hacky, in a sense.
03:57:30 <povman> Or could the different files include one Master File with All The Answers?
03:58:24 * paper_cc feels more like generating the Master File
03:59:04 <quicksilver> yes, compiling all the minor files could generate some master data dump
03:59:13 <quicksilver> which you then compile afterwards to build the data type.
03:59:19 <quicksilver> I imagine TH could be used for that.
03:59:29 <quicksilver> you'd need to compile in the right order, though, e.g. with a makefile.
03:59:44 <paper_cc> that's getting like LaTeX TOCs :(
04:00:40 <povman> For your software to necessitate uniqueness, it must surely reference all the values somewhere? Can't you put a bit of TH in the point of use?
04:04:09 <quicksilver> paper_cc: very much like it, yes. :)
04:14:52 <pjolk> anyone tried HRay?
04:15:02 <pjolk> what am i supposed to pass ont he commandline?
04:20:17 <HugoDaniel> hello
04:21:14 <Cale> pjolk: An input scene filename and an output image filename (ppm)
04:21:25 <Cale> Hello
04:22:53 <pjolk> Cale: but what is the file supposed to contain? what kind of fileromat?
04:22:56 <pjolk> is it data?
04:23:18 <Cale> pjolk: It comes with a directory full of example scene files.
04:23:27 <Cale> It's a custom text file format.
04:24:21 <zachk> > foldr (+) 0 [1..10]
04:24:22 <lambdabot>   55
04:24:40 <byorgey> hello HugoDaniel
04:24:41 <zachk> how do i define the "reverse" of that using unfoldr
04:25:09 <byorgey> @type unfoldr
04:25:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:25:26 <quicksilver> you want to convert 55 back to a list of sums?
04:25:31 <quicksilver> how do you know where to start?
04:26:22 <byorgey> yeah, that is somewhat unpossible
04:26:35 <byorgey> unless you use a tuple of (remaining sum, current index) as the seed
04:27:23 <povman> Is QuickCheck meant as an alternative to HUnit?
04:27:33 <Cale> It's possible in many many ways
04:28:23 <byorgey> > unfoldr (\(s,i) -> if (s > 0) then Just ( min s i, (s-i,i+1)) else Nothing) (55,1)
04:28:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:28:26 <zachk> cale: could you show me a possible way
04:28:27 <zachk> yay
04:28:41 <Cale> If you want to write a function to compute partitions of an integer, I would recommend starting with a function that computes partitions of an integer n into parts of size at most k
04:29:18 <byorgey> povman: no, they are quite different
04:29:46 <zachk> byorgey: why do you need the min there
04:29:48 <byorgey> > unfoldr (\(s,i) -> if (s > 0) then Just ( min s i, (s-i,i+1)) else Nothing) (57,1)
04:29:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2]
04:29:53 <byorgey> that's why
04:30:01 <byorgey> so it puts '2' at the end and not 11
04:30:15 <byorgey> although obviously you could make many different choices depending on how you want it to work
04:30:34 <zachk> so its not really as simple "reversal" then
04:30:54 <povman> byorgey: Can I not replace my hunit tests with QuickCheck functions that provide the same information?
04:31:01 <byorgey> well, no.  But I'm not sure what a "simple reversal" would be in this case.
04:31:21 <byorgey> povman: not necessarily.  It depends on your hunit tests.
04:32:12 <byorgey> povman: HUnit tests test very specific things.  QuickCheck tests are probabilistic, i.e. they test properties that should hold universally by running them on random test data.
04:32:36 <pjolk> @type unfoldr
04:32:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:32:39 <byorgey> so if you had, e.g. an HUnit test that tested some very specific corner case, you probably wouldn't be able to make that into a QuickCheck test.
04:33:16 <luap> does anyone know how to get from a [ShowS] to a ShowS ??
04:33:26 <Axman6> head
04:33:34 <luap> lol
04:33:46 <Axman6> :\
04:33:52 <Cale> > let partitions n k | k > n = partitions n n; partitions 0 k = [[]]; partitions n 0 = []; partitions n k = [v : vs | v <- [k,k-1..1], vs <- partitions (n-v) v] in partitions 55 55
04:33:53 <lambdabot>   [[55],[54,1],[53,2],[53,1,1],[52,3],[52,2,1],[52,1,1,1],[51,4],[51,3,1],[51...
04:33:56 <kpreid> @src ShowS
04:33:56 <lambdabot> type ShowS = String -> String
04:34:09 <Cale> zachk: ^^
04:34:13 <tombom> @src unfoldr
04:34:13 <lambdabot> unfoldr f b  = case f b of
04:34:13 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:34:13 <lambdabot>    Nothing        -> []
04:34:14 <kpreid> how about foldr id (.)?
04:34:14 <povman> byorgey: Ok. So maybe you can use QuickCheck _inside_ HUnit
04:34:26 <Cale> zachk: That computes all the ways to decompose 55 into a sum of positive integers :)
04:34:38 <byorgey> povman: possibly, I've never tried.  what are you trying to do?
04:34:40 <kpreid> > foldr id (.) $ map shows "abc"
04:34:41 <lambdabot>   Couldn't match expected type `(b -> c) -> (a -> b) -> a -> c'
04:34:47 <kpreid> > foldr (.) id $ map shows "abc"
04:34:48 <lambdabot>       Overlapping instances for Show (String -> String)
04:34:48 <lambdabot>        arising from a...
04:34:56 <povman> byorgey: Nothing in particular, just learning about unit testing since I've never really done it before
04:34:59 <Cale> As for using unfoldr to do it...
04:35:03 <kpreid> > ($ foldr (.) id $ map shows "abc") ""
04:35:04 <lambdabot>   Couldn't match expected type `(String -> String) -> b'
04:35:10 <byorgey> povman: there are also some packages for using HUnit and QuickCheck tests together
04:35:18 <kpreid> > (foldr (.) id $ map shows "abc") ""
04:35:19 <lambdabot>   "'a''b''c'"
04:35:22 <byorgey> like http://hackage.haskell.org/cgi-bin/hackage-scripts/package/test%2Dframework
04:35:33 <Cale> Yeah, I'm not sure. It's likely possible, but not very natural.
04:35:34 <kpreid> no idea whether foldr or foldl is the right thing here
04:36:00 <byorgey> kpreid: definitely foldr
04:36:13 <kpreid> hm...ah.
04:36:16 <byorgey> > (foldl (.) id $ map shows "abc") ""
04:36:18 <lambdabot>   "'a''b''c'"
04:36:22 <byorgey> hmm
04:36:32 <byorgey> > (foldl (.) id $ map shows "abc") "foo"
04:36:33 <lambdabot>   "'a''b''c'foo"
04:36:37 <zachk> cale: thank you for broadening my horizons, though i was just hoping to meditate on unfold :-D
04:36:45 <byorgey> interesting, maybe it doesn't matter
04:36:50 <kpreid> the whole point of ShowS being to ++ from the left, so we want the left first, so we want foldr because foldr does (a . (b . c))
04:36:55 <pjolk> Cale: any idea how that custom textfile looks? I can't find on the wikipage or the homepage of HRay. pretty weir
04:37:02 <byorgey> right
04:37:08 <kpreid> byorgey: it makes no visible difference because (.) is associative
04:37:18 <yowgi> @check (\a b -> shows a b == (show a) ++ b)
04:37:19 <lambdabot>   "OK, passed 500 tests."
04:37:22 <Cale> pjolk: Look in the scenes subdirectory
04:37:23 <byorgey> ah, right.
04:37:31 <Cale> pjolk: In the HRay package
04:37:43 <luap> foldr id (.) [showString "a", showString "a"] ??
04:37:46 <kpreid> well, because (.) is associative AND id is id
04:37:58 <byorgey> hehe, indeed
04:38:00 <kpreid> > (foldr (.) ("foo"++) $ map shows "abc") ""
04:38:01 <lambdabot>   "'a''b''c'foo"
04:38:07 <kpreid> > (foldl (.) ("foo"++) $ map shows "abc") ""
04:38:08 <lambdabot>   "foo'a''b''c'"
04:38:38 <luap> yeah but i need it on a LIST of ShowS
04:38:42 <kpreid> . and id form a monoid
04:38:46 <zsol> pjolk: graph rewriting library called visual-graphrewrite
04:38:49 <kpreid> luap: that's what the right part is generating
04:38:56 <kpreid> foldr (.) id myListOfShowS
04:39:46 <luap> well it doesnt work for me:   foldr id (.) [showString "a", showString "a"]
04:40:01 <luap> ah order
04:40:10 <kpreid> :t showString
04:40:11 <lambdabot> String -> String -> String
04:40:23 <kpreid> > showString "a" "x"
04:40:24 <lambdabot>   "ax"
04:40:31 <kpreid> > foldr id (.) [showString "a", showString "b"]
04:40:33 <lambdabot>   Couldn't match expected type `(b -> c) -> (a -> b) -> a -> c'
04:40:35 <luap> the order was wrong
04:40:36 <kpreid> > foldr id (.) [showString "a", showString "b"] ""
04:40:37 <lambdabot>   Couldn't match expected type `(b -> c) -> (a -> b) -> a -> c'
04:40:57 <kpreid> > (foldr id (.) [showString "a", showString "b"]) ""
04:40:58 <lambdabot>   Couldn't match expected type `(b -> c) -> (a -> b) -> a -> c'
04:41:08 <kpreid> ...okay, what am I confused about now?
04:41:21 <pjolk> > unfoldr (\a -> Just (a,a)) 10 [1..5]
04:41:22 <lambdabot>   Couldn't match expected type `[t1] -> t'
04:41:33 <Berengal> > (foldr (.) id [showString "a", showString "b"]) ""
04:41:35 <lambdabot>   "ab"
04:41:45 <kpreid> oh right, wrong example. rf.
04:42:55 <luap> but it works now thanks. crazy type ShowS
04:43:44 <LeCamarade> #sml is touchingly quiet. She didn't know she was having a daughter, Haskell, who would lead to her death.
04:44:10 <LeCamarade> Children are such ungrateful little twerps. :o)
04:44:11 <bremner> we prefrer "retirement" as a metaphor :-)
04:44:22 <bremner> prefer even
04:44:32 <LeCamarade> :o)
04:44:40 <xian> Haskell's mom is still sort of cool though.
04:44:49 <LeCamarade> I must be the only one writing fresh code in SML.
04:45:01 <LeCamarade> xian, Beauty is genetic, yes. ;o)
04:45:58 <pjolk> and how do I view ppm files?
04:46:05 <vegai> SML seems to me like it might be a nicer language than Haskell
04:46:21 <vegai> it has a more severe library / centralization problem though
04:46:23 <povman> @slap vegai
04:46:23 * lambdabot beats up vegai
04:46:44 <Cale> vegai: Apart from the syntax and lack of laziness, and typeclasses... :)
04:46:52 <Saizan> and non-purity
04:47:00 <Cale> yes, and non purity :)
04:47:20 <Cale> But we should steal their module system :)
04:47:48 <mlesniak> I'm experimenting with haskellmode for vim. What does the _ stand for in the documentation of the shortcuts, e.g. what is "_si" ?
04:47:59 <ivanm> Cale: how does their module system differ from haskell's?
04:47:59 <LeCamarade> SML has "an austere beauty, like a sculpture."
04:48:48 <vegai> well, you know... features are not always good
04:49:02 <LeCamarade> ivanm, It's functor-based.
04:49:18 <Cale> Though, it's dangerous to use the word 'functor' there
04:49:18 <ivanm> LeCamarade: as in everything is a functor? :s
04:49:39 <Phil_M> hey all. I'm using this (http://pastebin.com/d1779a8f4) code to read in a value that has to be an integer. The problem is though, if the user enters a non-int value, ie string, the program will exit with a read no parse error. How can I check to see if the read y as Int worked, and if it didn't, recall the function that it's in so the user has to try again?
04:49:42 <Cale> In ML's usage, a functor is a module function
04:50:07 <Cale> That is, modules can be parametrised on other modules essentially.
04:50:24 <LeCamarade> Well, as in everything has a type, and everything can be part of a module (structure), and a module can be applied to a functor. It's executable categroy theory in a way Haskell quite isn't.
04:50:31 <ivanm> Cale: they have functions on modules? :s
04:50:41 <LeCamarade> ?where readInt
04:50:41 <lambdabot> I know nothing about readint.
04:50:47 <Saizan> Phil_M: use maybeRead s = case reads s of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing
04:50:48 <Cale> LeCamarade: I don't see how it relates to the category theoretic notion of module at all.
04:50:48 <LeCamarade> ?hoogle readInt
04:50:49 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
04:50:49 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:50:49 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:50:50 <Cale> er
04:50:57 <Cale> LeCamarade: I don't see how it relates to the category theoretic notion of *functor* at all.
04:51:07 <McManiaC> is there a plattform independend way to wait for termination of my programm?
04:51:31 <zachk> exitWith ExitSuccess ?
04:51:34 <povman> McManiaC: Isn't that basically, wait there until it finishes?
04:51:35 <LeCamarade> Cale, if you take the structure to be the "underlying set and its morphism", then the functors are equivalent in SML and in category theory.
04:51:40 <Saizan> zachk: wait for
04:51:55 <Saizan> McManiaC: waitForProcess
04:52:08 <LeCamarade> Phil_M, use readInt,.
04:52:10 <Cale> LeCamarade: hmm...
04:52:13 <zachk> or just end up doing a return () in a quit function
04:52:16 <Phil_M> Saizan: Thanks, is it possible you could explain what that code means in plain english please, I'm pretty new at haskell and I don't understand much of that
04:52:16 <Saizan> well, it depends on what you really need
04:52:31 <zachk> saizan: exitWith is platform dependent? ??
04:52:45 <Phil_M> LeCamarade: Thanks, I didn't know there was a built in function for it. Is there any documentation with example usage of it?
04:53:09 <Cale> LeCamarade: Okay, I perhaps see the sense in which it might be considered a functor.
04:53:19 <LeCamarade> ?hoogle readInt
04:53:19 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
04:53:19 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:53:19 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:53:29 <Saizan> Phil_M: well, reads is like read but it returns a list of (result,rest of string), so if it returns a singleton list with nothing except space after it then you've successful parse
04:53:32 <Cale> The details are a little bit hazy though.
04:53:34 <zachk> is a functor on categories like a function on sets?
04:53:45 <Cale> zachk: Sort of :)
04:53:47 <Saizan> LeCamarade: why does readInt helps here?
04:53:50 <LeCamarade> Phil_M, Import Data.ByteString.Lazy ... as you see up there, then use its readInt. As you use read.
04:54:05 <Cale> zachk: A functor between categories is required to preserve composition and identities though.
04:54:17 <LeCamarade> Saizan, I thought he didn't want to bottom on 'read'ing a non-int.
04:54:24 <LeCamarade> Which is where readInt helps.
04:54:34 <zachk> is the only thing between categories functors?
04:54:44 <Saizan> well, switching to bytestring for that looks like a big leap
04:55:23 <Cale> zachk: If C and D are categories, and A,B are objects in C, then a function F: C -> D sends A and B to objects FA and FB of D, and it sends each arrow f: A -> B in C to an arrow Ff: FA -> FB in D.
04:55:33 <Phil_M> Maybe I didn't explain properly? What I need to do is get an integer value from the user. If it's an integer, call a function with that integer. If it's anything but an integer, call the function the code's in so the user has to try again. What would be better suited for this, Saizan 's code or readInt?
04:56:08 <Cale> and is required to satisfy F(id_A) = id_(FA) for all A, and F(f.g) = (Ff) . (Fg) for all arrows f, g in C which compose.
04:56:27 <Saizan> Phil_M: readInt works only for Int and you need to read the string as a ByteString
04:56:49 <Cale> I suppose you can ask for less than a functor or for more.
04:57:02 <Saizan> Phil_M: except for that they are both good
04:57:44 <Cale> You can have things like isomorphisms of categories, or equivalences of categories, and there are special properties that functors can have, like full, faithful, continuous, cocontinuous, etc.
04:57:46 <Phil_M> Saizan LeCamarade Thanks for all you're help, I'll have a play with both and see what I come up with (:
04:58:16 <pjolk> @slap vegai
04:58:16 <lambdabot> I won't; I want to go get some cookies instead.
04:58:23 <Cale> Or you can just talk about functions between categories which don't preserve composition, but I don't think anyone's very interested in those.
04:58:27 <pjolk> @cookie
04:58:27 <lambdabot> Unknown command, try @list
04:58:34 <pjolk> @botsnack
04:58:34 <lunabot>  :)
04:58:35 <lambdabot> :)
04:58:37 <pjolk> @botsnack
04:58:37 <lunabot>  :)
04:58:37 <lambdabot> :)
04:58:40 <pjolk> @slap vegai
04:58:41 * lambdabot loves vegai, so no slapping
04:58:45 <pjolk> @slap vegai
04:58:45 * lambdabot would never hurt vegai!
04:58:47 <pjolk> @slap vegai
04:58:47 <lambdabot> stop telling me what to do
04:58:49 <Tobsan> Haha
04:59:12 <pjolk> @slap Tobsan
04:59:12 * lambdabot hits Tobsan with an assortment of kitchen utensils
04:59:16 <Tobsan> :(
05:01:12 <marcot> Good morning.
05:01:28 <marcot> What would you suggest to work with XML?  There seem to be a lot of options in hackage.
05:03:04 <Cale> marcot: I suppose it depends somewhat on the task.
05:03:24 <marcot> Cale: is there a place I could read a comparision between the main options?
05:03:46 <Cale> I'm not sure...
05:04:03 <Cale> HaXml and hxt are the big options for serious tasks
05:04:16 <marcot> HXT seems to be newer, right?
05:04:16 <Asztal> marcot: HXT seems nice
05:04:42 <Cale> yeah, HXT is a bit newer and partly based on HaXml
05:04:59 <marcot> Cale: so is there any advantage for HaXML?
05:05:01 <Asztal> it does a lot, though :)
05:05:19 <Cale> It's also possibly a bit larger and more complicated.
05:05:36 <Cale> But even so, you can usually ignore most of it
05:06:06 <Asztal> there's also Text.XML.Light, although that parses invalid XML silently, which may or may not be to your liking
05:06:44 <marcot> Asztal: no, this is not what I want...
05:06:48 <Cale> and then things like tagsoup, for dealing with possibly completely ill-formed documents
05:07:57 <Cale> Personally, I think that anything which comes into contact with XML inevitably becomes a horribly disfigured monstrosity.
05:08:16 <Cale> (Regardless of the language)
05:08:36 <Twey> Why's that?  XML is pretty generic.
05:08:51 <Cale> XML is overly complicated for its goal.
05:08:54 <Twey> I don't think it's really specific enough to corrupt anything.
05:09:00 <Twey> How so?
05:09:26 <Twey> You've got <tag attr="value"*><child />*</tag>*
05:09:29 <Twey> And that's about it
05:09:30 <Cale> Well, XML is really just a way of representing trees which contain text and other data.
05:09:45 <Twey> With annotations, sure
05:09:48 <Cale> the attributes in particular I think are totally unnecessary
05:09:59 <Cale> Since you could always just have subnodes.
05:10:01 <Twey> Why's that?
05:10:03 <Twey> You could
05:10:15 <Twey> The idea behind attributes is to separate content and meta-information
05:10:42 <Twey> The actual content goes *in* the tags; the attributes define meta-information like what colour to render it
05:10:55 <Twey> Or what language it's in
05:10:56 <Cale> But even so, like you said, that's the basic idea in one line, but somehow they manage to turn this into a hideously complicated standard.
05:10:57 <Maddas> Is this about XML in general?
05:11:09 <Maddas> (Sorry for butting in :))
05:11:10 <Cale> Yeah, in general.
05:11:50 <Twey> I suppose you could have a <content> element for every element
05:12:03 <Twey> But personally I prefer the attributes
05:12:03 <Asztal> I think attributes are unnecessary for storing data, for actual text markup they serve a purpose
05:12:17 <Cale> http://www.w3.org/TR/2006/REC-xml11-20060816/
05:13:13 <Cale> That is insanely complicated for something which effectively is a glorified syntax for trees.
05:13:26 <Twey> True
05:13:28 <Cale> Compare it with S-expressions.
05:14:05 <Twey> I do think XML is much easier on the eye than S-exprs, though.
05:14:13 * Maddas would disagree with that ;-)
05:14:14 <Cale> I don't, personally.
05:14:16 <dolio> Really?
05:14:26 <Cale> The repetition is noisy and distracting.
05:14:28 <kpreid> a lot of the complexity of XML really is relevant for text-markup, but junk when you want to do data trees
05:14:29 <dolio> It has twice as many parentheses. And they're pointy.
05:14:37 <Cale> and there are tons of angle brackets
05:14:41 <Cale> yeah
05:15:04 <Twey> But the angle brackets don't enclose the actual data
05:15:06 <Maddas> Is the origin of this discussion relevant? (Was there any particular question to be answered?)
05:15:13 <Twey> I think it was answered
05:15:16 <Maddas> Fair enough.
05:15:27 <Cale> Twey: they do if that data is encoded as attributes...
05:15:29 <Asztal> the question was about which Haskell libraries to use for XML
05:15:33 <Maddas> Ah, I see.
05:15:48 <Twey> If the large part of the data is encoded in attributes then your schema needs rethinking
05:15:56 <Cale> Well, particularly why the libraries look like a mess :)
05:16:25 <Maddas> Any library handling real-world data formats in a useful way tends to end up looking like a mess ;-)
05:16:33 <Cale> But it's not just the XML standard on its own which is the problem. There are a whole bunch of overcomplicated related specs.
05:16:36 <Twey> The part inside the brackets *should* be small â the brackets aren't meant to be taken separately, but just as part of the syntax for a more important delimiter
05:16:47 <Twey> The related specs get a bit weird, I agree.
05:18:11 <Cale> They're designed by committee rather than simply being formalised by committee, and it shows.
05:18:20 <Twey> Truly
05:19:07 <Twey> There's a strong feel of everything's-a-nail about them, too
05:19:18 <Twey> Heck, at least one of them actually evolved to Turing-completeness
05:19:53 <Maddas> And now it's too late to stop it!
05:19:56 <ALGOLrevived> so what's the future of messaging?
05:20:01 <ALGOLrevived> will SMS be free?
05:20:10 <Twey> It's not Skynet we need to worry about â it's XSLT!
05:20:14 <Maddas> Oh, messaging, not massaging.
05:20:18 <Twey> ALGOLrevived: Er, hi
05:20:22 <Twey> Yeah, I made that error too
05:20:30 <ALGOLrevived> hi?
05:20:34 <ALGOLrevived> hi!
05:20:35 <Twey> ALGOLrevived: I don't know, but... why here?
05:20:38 <Maddas> Twey: What did *you* think Skynet was written in?
05:20:44 <Twey> Maddas: COBOL.
05:20:47 <Tobsan> lol
05:20:48 <vegai> I used hxt. It's pretty good, but in such a high level that debugging my code wasn't fun
05:20:51 <ALGOLrevived> Twey: the future is to be written in Haskell?
05:21:05 <vegai> XML.Light would've been a better option probably, but there's hardly any examples for that
05:21:05 <Twey> Heh
05:21:21 <Twey> vegai: If it's light enough, you could just read the code :-P
05:21:35 <horms> sms will die once people realise they can use other messaging services - e.g. email - on their phone. but it will take a while - e.g. people still watch tv.
05:21:45 <Twey> Okay, I'm going to go and pass out from blood loss now
05:21:48 <Twey> Please excuse me
05:22:47 <ALGOLrevived> but email means using internet means costing money
05:22:59 <horms> not if it doesn't
05:23:48 <horms> anywhere i've had sms its been rediculously overpriced
05:23:53 <horms> perhaps you are luckier
05:24:06 <marcot> vegai: why it's a better option?
05:28:45 <vegai> marcot: it's more simple and thus I'd imagine more easy to figure out its logic if things are going wrong
05:29:00 <vegai> then again, writing the parser in hxt was quite simple
05:29:19 <vegai> it's not a simple choice
05:29:44 <marcot> vegai: ok, thanks.
05:38:13 <Phil_M> Saizan: Hey again. I've been tinkering with the code you gave me, but I can't figure out how to use it properly. I've made this (http://pastebin.com/d76e05399) function but I'm getting a type error because of isNothing. It's expecting a "Maybe a" but is given [Char]. Can you see what I've done wrong?
05:39:06 <mauke> yeah, maybeRead is unused
05:39:23 <mauke> did you mean: if isNothing (maybeRead s)?
05:39:41 <Phil_M> probably :P I'll give it a go. Thanks
05:40:39 <mauke> or: case maybeRead s :: Maybe Int of Nothing -> putStrLn "nothing"; _ -> putStrLn "that's better"
05:40:56 <mauke> type annotation because otherwise it doesn't know what type of value you want to read
05:42:43 <Phil_M> ok, with that code I'm getting "Last generator in do {...} must be an expression :\
05:43:41 <mauke> yay
05:43:57 <mauke> broken indentation, most likely
05:44:47 <Phil_M> ok. As far as syntax goes, is (http://pastebin.com/d5a24659) right?
05:46:17 <mauke> http://pastebin.com/d64557f36
05:46:43 <Phil_M> ah, ok
05:46:58 <Phil_M> I didn't realise it was to be combined with the existing code
05:47:28 <Phil_M> thanks a lot for your help
05:50:35 <pozic> Is there a library function to convert a Maybe t into a MaybeT m t?
05:51:55 <dolio> Looks like no.
05:52:45 <doserj> pozic: MaybeT . return?
05:53:04 <dolio> Yeah, that case isn't as bad as some others.
05:54:14 <pozic> doserj: oh, I wasn't aware the constructor was exported.
05:54:20 <zachk> i am getting a type error on d here in the instance declaration http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4820#a4820 could a type kind soul take a look :-/
05:56:58 <kyevan> GHC takes /forever/ to build >_>
05:57:07 <earthy> zachk: change it to    instance Eq d =>Â Eq (Cyc d)
05:57:26 <earthy> zachk: for == to work on lists of type a, you need == on values of type a
05:57:39 <ivanm> kyevan: no it doesn't
05:57:57 <kyevan> ivanm: Yes, yes it does. >_>
05:58:04 <ivanm> only about 40 minutes
05:58:06 <earthy> your instance declaration does not require that Eq on d, but you do us it indirectly through your use of aList a == (f $ aList b)
05:58:10 <ivanm> that's _nothing_...
05:58:19 <ivanm> OO takes about 4.5 hrs :s
05:58:30 <kyevan> Uh, this has been going for a couple hours...
05:58:41 <earthy> zachk: the possible fix ghc mentions is actually the exact right thing to do
05:58:43 <kyevan> And that's ignoring prereqs macports built first
05:58:45 <ivanm> what specs do you have?
05:58:47 <zachk> earthy: thank you. Yay it compiles now :-D
05:58:52 <ivanm> and which version of ghc?
05:58:59 <earthy> zachk: do you understand why? :)
05:59:49 <kyevan> 1.33 GHz PowerPC G4, 512 MB ram, OS X 4.11, GHC 6.10.1
06:00:06 <zachk> well my variable d was just sort of floating in space.  and it needs to be of a type that its own Eq reference, and if the type has an Eq d, then by Eq [d] is also defined.
06:00:26 <kyevan> (It's the version in macports, and the binaries off the ghc website are OS X 5 on Intel only :J)
06:00:37 <earthy> more or less, yes.
06:01:12 <zachk> ive been puttering with haskell for about a year now. I really havent dove into the type system that much. => is sort of new to me
06:03:38 <ivanm> kyevan: hmmm... I'd have expected it to take no more than an hour or so
06:03:40 <quicksilver> kyevan: yes, it will take a while on a G4.
06:03:42 <ivanm> maybe two
06:03:48 <quicksilver> took me 8 hours on my 800Mhz G4
06:03:52 <ivanm> quicksilver: oh? are they noticeably slower than intel-based chips?
06:03:55 <ivanm> :o
06:04:10 <earthy> zachk: learn it. learn it well. learn it now. you'll be a happier haskell hacker for it
06:04:13 <quicksilver> they're quite an old chip generation- small caches and so on.
06:05:11 <ivanm> *nod8
06:07:12 <zachk> earthy: is there any good books for beginners on the type system
06:07:25 <zachk> or resources, just google around?
06:08:21 <ivanm> zachk: as in how to understand/use the haskell type system?
06:08:29 <ivanm> I would think most tutorials, etc. would cover it...
06:09:10 <kyevan> Ah well.
06:09:12 <doserj> if a tutorial doesn't explain the type system, it doesn't explain haskell...
06:09:21 <kyevan> I'll distract myself with Spore on the PC :J
06:09:25 <leadnose> how I learned haskell's type system: 1) write some code that I think makes sense 2) try to load it on ghc and get a error 3) read error 4) fix the error/use extension 5) ??? 6) profit
06:09:58 <zachk> alot of people i show haskell too, seem to think it is weakly typed and just looks like a scripting language (from my lack of type signatures)
06:10:02 <ivanm> leadnose: you missed the whole "add lots of extra packages that might possibly be of use to someone in the future on hackage" step
06:10:05 <ivanm> ;-)
06:10:10 <zachk> leadnose: howmuch $$$$$ have you made
06:10:22 <leadnose> not much :(
06:10:30 <kyevan> Heh, not all profit is monitary!
06:10:35 <leadnose> yeah
06:10:57 <demolithion> yay theres also imaginary profit :)
06:11:16 <kyevan> And chicks. Don't forget chicks.
06:11:25 <kyevan> (:P)
06:11:37 <ivanm> demolithion: I prefer real profit
06:11:49 <ivanm> most banks don't want to have to square the money before they can use it ...
06:11:53 <kyevan> Most of my profit is irrational...
06:12:17 <demolithion> my profit is stuck in a monad :/
06:12:31 <ALGOL_> > (+1) <$> [1,2,3]
06:12:32 <lambdabot>   [2,3,4]
06:12:32 <ivanm> The Bank Monad?
06:12:40 <ALGOL_> > (1+) <$> [1,2,3]
06:12:41 <lambdabot>   [2,3,4]
06:12:52 <Workybob> ivanm: isn't that a MonadFail?
06:12:52 <ALGOL_> does fold has an applicable?
06:12:57 <ivanm> they only accept functions that increase the value stored in the monad?
06:12:58 <zachk> i acted quite irrational for about a year, but if you were in my head with the data set of reality i had i was actually acting quite logical for what i was being given
06:13:04 <ivanm> Workybob: not all banks have failed...
06:13:16 <ivanm> Australia's haven't... they've just increased fees due to lower home loan rates :@
06:13:25 <ALGOL_> > (++[1,2,3]) <$> [[1],[3]]
06:13:27 <lambdabot>   [[1,1,2,3],[3,1,2,3]]
06:13:37 <ALGOL_> > ([1,2,3]++) <$> [[1],[3]]
06:13:39 <lambdabot>   [[1,2,3,1],[1,2,3,3]]
06:18:25 <ALGOL_> > (+1) &&& (+3) $ (3,4)
06:18:26 <lambdabot>       No instance for (Num (t, t1))
06:18:26 <lambdabot>        arising from the literal `1' at <i...
06:18:31 <ALGOL_> > (+1) *** (+3) $ (3,4)
06:18:32 <lambdabot>   (4,7)
06:18:41 <ALGOL_> > (+1) &&& (+3) $ 6
06:18:43 <lambdabot>   (7,9)
06:18:44 <Berengal> Anyone tried to build hdbc on ghc 6.10.3?
06:19:17 <ALGOL_> > (+1) `map` [1,2,3]
06:19:18 <lambdabot>   [2,3,4]
06:19:22 <ALGOL_> > (+1) `fmap` [1,2,3]
06:19:23 <lambdabot>   [2,3,4]
06:19:46 <ALGOL_> > fmap (+1) (Just 5)
06:19:47 <lambdabot>   Just 6
06:19:51 <ALGOL_> > map (+1) (Just 5)
06:19:53 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe t'
06:20:08 <ALGOL_> > fmap (+1)[Nothing,Just 5]
06:20:10 <lambdabot>       No instance for (Num (Maybe a))
06:20:10 <lambdabot>        arising from the literal `1' at ...
06:20:12 <ALGOL_> > fmap (+1) [Nothing,Just 5]
06:20:13 <lambdabot>       No instance for (Num (Maybe a))
06:20:13 <lambdabot>        arising from the literal `1' at ...
06:20:21 <ALGOL_> > (fmap . fmap) (+1) [Nothing,Just 5]
06:20:22 <lambdabot>   [Nothing,Just 6]
06:20:49 <ALGOL_> > (fmap (+1)) <$> [Just 5, Nothing]
06:20:50 <lambdabot>   [Just 6,Nothing]
06:21:10 <ALGOL_> > (mmap . fmap) (+1) [Nothing,Just 5]
06:21:11 <lambdabot>   Not in scope: `mmap'
06:21:15 <ALGOL_> > (map . fmap) (+1) [Nothing,Just 5]
06:21:16 <lambdabot>   [Nothing,Just 6]
06:21:20 <ALGOL_> > (fmap . map) (+1) [Nothing,Just 5]
06:21:22 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe a1'
06:28:30 <Workybob> > fmap fmap fmap (+1) [Nothing, Just 5]
06:28:32 <lambdabot>   [Nothing,Just 6]
06:33:18 <smorg> heh thats awesome. lambdabot just evaluates anything whatsoever?
06:33:45 <burp_> everything except IO
06:34:00 <chessguy_work> if you want IO, you can use codepad
06:34:21 <chessguy_work> ( http://codepad.org/ )
06:35:42 <quicksilver> it evaluates everything including IO.
06:35:49 <quicksilver> it doesn't *execute* the IO
06:35:53 <quicksilver> but that's different
06:36:09 <smorg> that must be one hardcore sandboxed system
06:36:19 <quicksilver> > putStrLn "hello"
06:36:21 <lambdabot>   <IO ()>
06:36:26 <quicksilver> ^^ evaluated but not executed.
06:36:47 * smorg looks for hax
06:36:53 <byorgey> smorg: it is indeed.
06:36:55 <quicksilver> codepad is pretty clever.
06:36:58 <quicksilver> You can read about it somewhere.
06:38:10 <kpreid> smorg: the thing is, it is *NOT* a complicated sandbox
06:38:16 * edwardk waves hello.
06:38:25 <chessguy_work> hiya edwardk
06:38:51 <kpreid> smorg: evaluation is always effect-less (except for the rare unsafe operation -- so lambdabot has a whitelist, but it's mostly 'include this entire module', so simple)
06:39:12 <kpreid> smorg: IO is something completely separate from evaluation so there is no way it's going to happen in some subtle way
06:39:13 <idnar> kpreid: maybe he meant codepad
06:39:23 <quicksilver> http://codepad.org/about
06:39:32 <quicksilver> codepad uses ptrace to limit system calls, basically
06:39:37 <kpreid> oh. duh.
06:39:38 <quicksilver> although there's a bit more to it than that.
06:39:53 <quicksilver> part of it is written in haskell, too :)
06:40:09 <quicksilver> although as far as I know the author is not aroung here.
06:40:20 <smorg> [(x,y)|x <- [0..3], y <- [x..4]]
06:40:35 <smorg> hm guess not big comprehensions
06:40:48 <kpreid> you forgot your >
06:41:55 <smorg> > [(x,y)|x <- [0..2], y <- [x..4]
06:41:56 <lambdabot>   <no location info>: parse error on input `;'
06:42:04 <smorg> > [(x,y)|x <- [0..2], y <- [x..4]]
06:42:05 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4)]
06:43:08 <edwardk> i wound up having to do something similar recently, ptracing system calls is slow =/
06:43:32 <edwardk> i ultimately sacrificed correctness for the app in question for practicality ;)
06:44:11 <skorpan> :t Just
06:44:14 <lambdabot> forall a. a -> Maybe a
06:44:20 <edwardk> (i needed to know whenever the memory mappings of the process changed for constant folding purposes, etc.)
06:45:19 <quicksilver> edwardk: that sounds absurdly clever.
06:45:29 <quicksilver> edwardk: btw, comonad.com is down.
06:45:47 <edwardk> quicksilver: yeah, and the guy who can bring it up is overseas for the week =(
06:46:54 <quicksilver> edwardk: that's not good enough. Send the flying monkeys!
06:46:57 <edwardk> quicksilver: unfortunately using information about your current memor mappings for constant folding is a bit of a hack because your process may map a page read only that can be written to by another process. for instance there is a vsyscall page that gets written to by the kernel all the time to avoid round tripping
06:47:40 <edwardk> i'd point you to the code, but.. its on comonad.com and hence down ;)
06:47:53 <quicksilver> nod
06:48:22 <kyevan> I'm still confused about how Haskell can do anything.... >_>
06:48:29 <edwardk> kyevan: ?
06:48:36 <mreh> @src concatMap
06:48:36 <lambdabot> concatMap f = foldr ((++) . f) []
06:48:45 <kyevan> Like, + works with numbers, not IOs, so... >_>
06:48:47 <edwardk> kyevan: you mean if its so lazy how does it ever get anything done?
06:48:52 <kyevan> I'll figure it out eventually. *shrug*
06:49:11 <quicksilver> kyevan: it gets done because you print out the result
06:49:16 <kyevan> edwardk: Nah, with that it's "something outside the system wants something, so."
06:49:20 <smorg> Its just like python. It has bindings for everything. Everything else it evaluates and prints results.
06:49:21 <quicksilver> kyevan: or write it to a file, or draw it in a window, or...
06:49:22 <tomh> why would you want to apply + to IO?
06:49:24 <kyevan> but... >_>
06:49:51 <kpreid> kyevan: you mean, if everything is pure how do we eventually execute the imperative stuff implementing those operations?
06:50:09 <kyevan> tomh: For instance, a simple "get two numbers from the user and print the result" tool
06:50:24 <smorg> I just discovered haskell due to python being not as cool as I hoped... trying to put a whole evaluation into memory at once.
06:50:24 <tomh> thats like super easy? :/
06:50:30 <kyevan> (which is much more interesting than hello world and I think should replace it... but I digress)
06:50:35 <tomh> you can still use a + there..
06:50:41 <kyevan> But it... >_> nevermind...
06:50:53 <kyevan> I'm talking mostly to myself, anyway.
06:51:04 <kpreid> liftM2 (+) readLn readLn >>= print    -- :)
06:51:35 <kpreid> kyevan: I think you may have an interesting question, but I can't tell what it is yet
06:52:26 <edwardk> kpreid: because that is the least scary thing you can show someone getting started ;)
06:52:39 <kpreid> edwardk: heh heh
06:53:09 <kpreid> I was aiming for 'transform a function into IO'
06:53:54 <edwardk> some days i wish haskell had chosen a less scary operator than >>= as the glue for most everything you do in haskell ;)
06:53:59 <kyevan> I'm pro'lly just missing a few concepts and will get them when I sit down and step through things more formally :J
06:54:09 <quicksilver> or less formally.
06:54:18 <quicksilver> sometimes it helps to just see examples and trust it works.
06:54:36 <quicksilver> main = do x <- readLn; y <- readLn; print ("The answer is " ++ show (x+y))
06:54:37 <kyevan> quicksilver: I'm quite litterally letting a book fall open to random pages and reading for a bit :P
06:54:51 <kpreid> kyevan: is the question 'given that stuff is pure, how do we ever define IO operations?'
06:55:03 <kyevan> Nah. I don't know what the question is
06:55:06 <quicksilver> any particularly book? Because although Alice Through the Looking Glass is a great book, Lewis Carroll was a bit sketchy on haskell.
06:55:11 <kyevan> I was just thinking out loud :J
06:55:54 <kyevan> Also, >>= looks like some sort of evil clown for some reason.
06:56:11 <quicksilver> it's technically called 'the Pennywise operator'
06:57:28 <osfameron> is it also pound foolish?
06:57:56 <Workybob> main = print . ("The answer is" ++) . show =<< (readLn <^(+)^> readLn)
06:57:59 <Workybob> >.>
06:58:05 <osfameron> quicksilver: who is it that says Alice is the finest book on programming for the layman ever written
06:58:08 <osfameron> ?
06:58:18 <osfameron> ah, Alan J Perlis
06:58:29 <osfameron> 48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
06:59:08 <skorpan> i have a rather lengthy, but simple, question, so if anyone can be bothered helping me out, that would be great: http://pastebin.com/d5d93aa56
06:59:57 <quicksilver> skorpan: the answer is "yes".
07:00:29 <quicksilver> class Baddable f where makeBad :: t -> f t
07:00:35 <quicksilver> if I correctly understand your code
07:00:44 <quicksilver> (you used instance once before where you meant class, I believe)
07:00:52 <skorpan> ah, yes
07:00:57 <skorpan> i'm sure there are a few more errors in there
07:01:03 <mreh> > [ x | x <- [1..5], y <- [1..x] ]
07:01:04 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
07:01:15 <quicksilver> instance Baddable Bike where makeBad = Bad
07:01:20 <mreh> > [ y | x <- [1..5], y <- [1..x] ]
07:01:22 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
07:01:23 <quicksilver> instance Baddable Car where makeBad = Horrible
07:01:27 <mreh> there we go
07:01:29 <quicksilver> I believe that woulod type-check.
07:02:06 <skorpan> quicksilver: but doesn't it pose a problem that the constructors have different numbers of arguments?
07:02:25 <quicksilver> they don't
07:02:29 <quicksilver> they both have one.
07:02:43 <quicksilver> but it doesn't have to be a problem - depends how you design it.
07:02:47 <quicksilver> could bae
07:03:09 <quicksilver> instance Baddable Car where makeBad x = Horrible x (x,x) 4 10
07:03:10 <mreh> > [ y | x <- [1..5], y = [1..x] ]
07:03:12 <lambdabot>   <no location info>: parse error on input `='
07:03:19 <kyevan> *STILL* building GHC >_>
07:03:25 <mreh> how can i make the list of lists of numbers from [1..5]?
07:03:33 <SamB> kyevan: didn't they tell you it takes a while?
07:03:38 <mreh> [[1],[1,2],[1,2,3]..]
07:03:53 <quicksilver> > [ [1..n] | n <- [1..5] ]
07:03:55 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
07:03:55 <kyevan> Yeah. I'm just talking to myself.
07:04:04 <mreh> mmmm
07:04:18 <quicksilver> > [ y | x <- [1..5], let y = [1..x] ]
07:04:19 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
07:04:24 <quicksilver> mreh: that's how to fix your version
07:04:24 <mmorrow> > fmap (join replicate) [1..5]
07:04:26 <lambdabot>   [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5]]
07:04:26 <mreh> ooooooo
07:04:29 <quicksilver> you were only one let away.
07:04:30 <mmorrow> oops
07:04:43 <mmorrow> > transpose $ fmap (join replicate) [1..5]
07:04:44 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
07:04:49 <mreh> aaaaaaah
07:04:51 <mreh> haha
07:04:56 <mreh> opps!
07:04:56 <mmorrow> almost :)
07:06:47 <mreh> what's the exponential operator?
07:07:03 <mreh> exponent*
07:07:05 <opqdonut> ^, ^^ and **
07:07:09 <opqdonut> they have different types
07:07:14 <mreh> :t ^
07:07:16 <lambdabot> parse error on input `^'
07:07:19 <mreh> :t (^)
07:07:21 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:07:22 <opqdonut> :t (^) -- for integral exponentiation
07:07:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:07:28 <opqdonut> :t (^^) -- for fractional exponents
07:07:30 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:07:34 <opqdonut> :t (**) -- for floats
07:07:35 <lambdabot> forall a. (Floating a) => a -> a -> a
07:07:56 <Berengal> This is weird...
07:08:08 <mreh> so i use ** for raising numbers to the half say...
07:08:15 <Berengal> For some reason cabal can't find parsec when building...
07:08:23 <opqdonut> mreh: or (^^) if you want exact results
07:08:32 <opqdonut> gah, no
07:08:34 <opqdonut> **, yes
07:08:49 <opqdonut> ** is the only one that takes non-ingegral exponents
07:09:32 <quicksilver> ^^ permits fractional bases.
07:09:47 <opqdonut> yeh
07:09:50 <quicksilver> the point being that ^ preserves all the classes
07:09:59 <quicksilver> -- it takes integers to integers in particular
07:10:06 <mreh> generating all the words from an alphabet... would i use list comprehensions for that?
07:10:14 <mreh> all n-length words
07:10:25 <quicksilver> > replicateM 3 "abc"
07:10:26 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
07:10:34 <mreh> @replicateM
07:10:34 <lambdabot> Unknown command, try @list
07:10:40 <mreh> @src replicateM
07:10:40 <lambdabot> replicateM n x = sequence (replicate n x)
07:10:55 <mreh> @src sequence
07:10:55 <lambdabot> sequence []     = return []
07:10:55 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:10:55 <lambdabot> --OR
07:10:55 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:11:02 <Ferdirand> that was cute.
07:11:28 <Gracenotes> > sequence ["abc", "123"]
07:11:29 <lambdabot>   ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
07:11:57 <Gracenotes> like selecting a character from each string in the list, in order
07:12:32 <mreh> i think of mathematical sequences when i see that
07:12:37 <mreh> word
07:12:45 <Xen0x> can anyone explain the need for # in; data StablePtr a = StablePtr (StablePtr# a)
07:12:47 <Gracenotes> list comprehensions would do the same thing, but with the monad utility functions you can make the length variable instead of compiled in
07:13:03 <mreh> monad, because he has the do
07:13:30 <Berengal> list comprehension is simple sugar for list do anyway...
07:13:31 <mreh> s/he/it/
07:13:39 <mreh> no they arent
07:13:45 <smorg> Is there a powerset or cartesian product - that'd do it too
07:13:56 <Berengal> mreh: No?
07:14:02 <mreh> you're right
07:14:16 <mreh> you need to use a do
07:14:30 <Gracenotes> smorg: well. this *is* a 3-fold cartesian product
07:14:38 * mreh brane asplode
07:14:47 <Berengal> [foo | x <- xs, y <- ys, bar] => do x <- xs; y <- ys; True <- bar; return foo
07:15:21 <mreh> but the <- doesn't mean the same thing in either context
07:15:23 <Berengal> sorry, True <- return bar
07:15:36 <Berengal> They do in the list monad
07:15:54 * mreh is scared of monads
07:16:17 <mmorrow> > (\n -> foldr (\xs ys -> [x : y | x <- xs, y <- ys]) [[]] . replicate n) 2 "abc"
07:16:18 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
07:16:18 <Gracenotes> or just "bar;"
07:16:23 <mauke> have some zygohistomorphic prepromorphisms instead
07:16:28 <Berengal> There was even such a thing as monad comprehension, which was like list comprehension except it could be any monad
07:16:37 <mreh> i'll keep plugging away at my lectures until i get to monads formally
07:17:03 <mmorrow> > (\n -> foldr (\xs ys -> do x <- xs; y <- ys; return (x : y)) [[]] . replicate n) 2 "abc"
07:17:04 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
07:19:21 <mreh> my god recursion is so powerful
07:19:38 <endofjelly> edwardk, can you give me a link to that master thesis again?
07:22:19 <Berengal> Why is cabal doing this to me :(
07:22:37 <mreh> > [x|x<5, x<-[1..10]]
07:22:38 <lambdabot>   []
07:22:45 <mreh> thought as much
07:22:55 <mreh> interesting it still compiles
07:23:18 <ALGOL_> > foldl (\(acc,pos) next -> (acc ++ next !! pos, pos+1)) ("",0) ["hello","there","sir"]
07:23:19 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:23:33 <ALGOL_> > foldl (\(acc,pos) next -> (acc ++ (next !! pos), pos+1)) ("",0) ["hello","there","sir"]
07:23:34 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:23:57 <ALGOL_> > foldl (\(acc,pos) next -> (acc ++ [next !! pos], pos+1)) ("",0) ["hello","there","sir"]
07:23:59 <lambdabot>   ("hhr",3)
07:24:14 <ALGOL_> > fst $ foldl (\(acc,pos) next -> (acc ++ [next !! pos], pos+1)) ("",0) ["hello","there","sir"]
07:24:16 <lambdabot>   "hhr"
07:24:39 <doserj> > [x|x>5, x<-[1..10]]
07:24:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:24:51 <mreh> heh
07:24:55 <doserj> :)
07:25:08 <mreh> x must be intiatilised
07:25:08 <doserj> > (x < 5, x > 5)
07:25:09 <lambdabot>   (False,True)
07:25:16 <skorpan> is there anything such as "go to definition of function if it's in the current module" in haskell-mode?
07:25:17 <ALGOL_> foldl (\(acc,pos) next -> (acc ++ [next !! pos], pos+1)) ("",0) ["hello","there","sir"]; some cuter way to do that?
07:25:27 <DrSyzygyIE> We really need to make monad incomprehension part of the language. :-P
07:25:30 <doserj> mreh: all single letter variables are, in lambdabot
07:25:36 <skorpan> M-. with tags gets so cumbersome since you have to regenerate the tags file all the time
07:25:49 <ALGOL_> > foldl (\(acc,pos) next -> (acc ++ [next !! pos], pos+1)) ("",0) ["hello","there","sir"]
07:25:50 <lambdabot>   ("hhr",3)
07:25:55 <mreh> > (hello < 5, hello > 5)
07:25:56 <lambdabot>   Not in scope: `hello'Not in scope: `hello'
07:26:01 <ALGOL_> > foldl (\(acc,pos) next -> (acc ++ [next !! pos], pos+1)) ("",0) ["hello","there","sir"]
07:26:02 <lambdabot>   ("hhr",3)
07:27:11 <rfmge> hmmm is there a way to set the print precision for doubles in ghci?
07:27:12 <rfmge> it's getting kinda annoying seeing something like 4.123987134123 all the time
07:27:21 <DrSyzygyIE> > foldl (\(acc,pos) next -> (acc++[next!!pos],pos+1)) ("",0) (words "hello there sah!")
07:27:22 <lambdabot>   ("hhh",3)
07:28:01 <quicksilver> rfmge: showEFloat showFFloat showGFloat
07:28:58 <edwardk> endofjelly: sure, one sec
07:29:01 <ALGOL_> > concat $ map (!! 1) ["hello","there"]
07:29:03 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
07:29:09 <ALGOL_> > map (!! 1) ["hello","there"]
07:29:10 <lambdabot>   "eh"
07:29:22 <edwardk> endofjelly: http://people.cs.uu.nl/johanj/MSc/jwroorda/
07:29:31 <ALGOL_> > map (!! 0) ["hello","there"]
07:29:33 <lambdabot>   "ht"
07:29:58 <ALGOL_> > zipWith (\x y -> x !! y) ["hello","there"] [1..]
07:30:00 <lambdabot>   "ee"
07:30:06 <ALGOL_> > zipWith (\x y -> x !! y) ["hello","there"] [0..]
07:30:08 <lambdabot>   "hh"
07:30:16 <ALGOL_> > zipWith (\x y -> x !! y) ["hello","there","sir"] [0..]
07:30:17 <lambdabot>   "hhr"
07:31:25 <rfmge> quicksilver: thanks, a setting would be nice so i don't have to keep calling that when i want to display things, but those work
07:32:06 <endofjelly> edwardk, thx
07:32:09 <DrSyzygyIE> > zipWith (!!) (words "hello there sah!") [0..]
07:32:10 <lambdabot>   "hhh"
07:32:45 <edwardk> endofjelly: another paper that i found really useful was on the idea of a PTS with subtyping that was done by the guy who wrote yarrow. looking for it
07:33:05 <endofjelly> edwardk, cool
07:33:50 <edwardk> endofjelly: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.4700
07:33:53 <mreh> is <- associative?
07:34:01 <mreh> :t (<-)
07:34:02 <lambdabot> parse error on input `<-'
07:34:03 <endofjelly> edwardk, thx
07:34:07 <opqdonut> mreh: it's not an operatori
07:34:08 <byorgey> mreh: <- is syntax.
07:34:10 <opqdonut> it's special syntax
07:34:13 <edwardk> endofjelly: i liked it because it was a pretty straightforward write up of the PTS rules without much baggage, and it extended them in a non-trivial way
07:34:15 <DrSyzygyIE> mreh: IIRC, it's syntax and cannot be chained.
07:34:30 <mreh> D:
07:34:55 <dolio> Have you told him that it's syntax yet?
07:34:55 <byorgey> mreh: why do you ask?
07:35:17 <edwardk> endofjelly: if you want to continue exploring the space, domain-free PTSs have some nice properties in terms of reducing the need for annotation, and there are some other variations on the theme as well.
07:35:45 <mreh> [(x,y,z) | x <- y <- z <- [0,1]]
07:36:09 <endofjelly> edwardk, reducing the need for annotation? that sounds interesting?
07:36:23 <mreh> but, yes, you're right, it is syntax
07:36:25 <byorgey> mreh: I see.  unfortunately you can't do that.
07:36:28 <mreh> how else would you parse it
07:36:52 <byorgey> > replicateM 3 [0,1]
07:36:53 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
07:37:03 <byorgey> but you can do THAT =)
07:37:22 <mreh> i suppose
07:37:36 <edwardk> endofjelly: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.2733 is Barthe and Sorenson's paper on Domain-Free PTSs
07:37:46 <jmcarthur> :t replicateM
07:37:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:38:00 <quicksilver> rfmge: show is a pure function. it's behaviour can't very well change :)
07:38:05 <byorgey> replicateM n = sequence . replicate n
07:38:09 <mreh> [5..4]
07:38:11 <mreh> > [5..4]
07:38:13 <lambdabot>   []
07:38:20 <quicksilver> rfmge: show isn't really intended for user-friendly formatting, it's a simple consistent machine readable output.
07:38:22 <edwardk> endofjelly: other than that there are papers by Henk Berendregt on the topic and the paper by Meijer and Peyton-Jones on how you might use a pure type system as a core language for Haskell
07:38:31 <edwardk> endofjelly: and now i'll stop 'over-helping' =)
07:39:05 <mreh> > [(x,y) | x <- [1..3], y <- [x..2]]
07:39:06 <lambdabot>   [(1,1),(1,2),(2,2)]
07:40:00 <msch> hi, I'm working through my haskell-course homework and I'm looking for a copy of Combinators for Logic Programming. Does anyone know if a copy is available online?
07:40:02 <edwardk> endofjelly: i did a lot of work on substructural pure type systems before i moved on to other things, mostly looking at them for, like you mentioned, use as intermediate or back end languages.
07:43:42 <mreh> msch: Google Books?
07:43:53 <mreh> sorry i can't help in any other way
08:13:00 <jeffersonheard> question...  do I need the "try" combinator if I'm using the <|> operator in parsec and the LHS consumes some of the same characters as the RHS?
08:13:15 <jeffersonheard> e.g. string "foo" <|> string "foo z"
08:13:44 <Berengal> Yes, I believe so
08:14:05 <quicksilver> yeah, that my main gripe with parsec.
08:14:07 * wli just uses choice . map try at every opportunity.
08:14:22 * quicksilver uses anything but parsec at every opportunity.
08:14:33 * skorpan uses the yi incremental parser! ;P
08:14:38 * Berengal can't get cabal to find parsec anymore :(
08:14:54 <wjt> do { string "f"; fmap ('f':) (string "oo" <|> string "ee") } makes me sad
08:15:30 <quicksilver> that's why you should use polyparse. or readp.
08:16:35 <dolio> He should use parsimony.
08:17:34 <quicksilver> doesn't exist today.
08:17:39 <quicksilver> comonad.com is down.
08:18:07 <quicksilver> I hope to try it myself next time I have need of a parser though
08:18:46 <dolio> Ah, right.
08:19:38 <jeffersonheard> I have to use Parsec, because it's the same name as my favorite, sadly lost, TI-99/4A cartridge game
08:20:41 <quicksilver> best game ever was "Space" for the Logica VTS 2200
08:20:52 <quicksilver> sadly there is no trace of it on the intertubes. Life sucks.
08:21:12 <jeffersonheard> yep
08:21:42 <jeffersonheard> well. I have a tiny module to parse WKT for geometry, if anyone other than me is interested in it
08:22:02 <jeffersonheard> will probably break it and WKT for spatial reference out into a separate lib when I'm done with TBB
08:23:14 <edwardk> jeffersonheard: yes you do
08:23:29 <edwardk> dolio: its getting there =)
08:23:53 <jeffersonheard> yeah, I got it working, thanks edwardk
08:24:13 * dolio disappears.
08:24:28 <edwardk> i admit i keep rolling more and more into parsimony's central grammar GADT for efficiency though
08:27:41 <ski> edwardk : edwardk : is <http://comonad.com/kata/Katalog.hs> and <http://comonad.com/reader/wiki;mode=category&item=pattern> still available somewhere ?
08:27:47 <edwardk> i keep trying to figure out how i could use something like a burkhard keller tree to deal with an error correcting parser that deals with transposition errors, etc. more gracefully than say uu-parsinglib's simple 'insert/delete' model
08:28:42 <edwardk> ski: the blog'll be back up as soon as my buddy Shane gets back from Europe or I can find someone else who has access to the rack where the machine is hosted to reboot it ;)
08:29:03 <ski> and `Katalog' ?
08:29:41 <edwardk> My cheesy little datalog stuff is sitting on a drive at home, but I hpasted it before and I don't think that version changed since then appreciably
08:31:05 <edwardk> There should be two datalogs that i've hpasted one that has a prolog like syntax and one that uses GADT stuff, I don't think i hpasted the more efficient ordered fact version based on trees though
08:31:08 <ski> (seems to be : Keeps resetting state? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1956>, example output <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1959> , ty)
08:31:50 <ski> (unless you've also pasted on `hpaste2' or `moonpatio' or other site ..)
08:32:18 <Berengal> I might have kicked cabal into submission...
08:32:31 <edwardk> thats the simple prolog/parser based one, there is an ADT based one that i also pasted somewhere
08:33:07 <edwardk> what were you looking for it for if I might ask?
08:34:53 <ski> s/what/why/ ?
08:35:50 <gwern> @quote haskell-spider
08:35:50 <lambdabot> jfredett says: My haskell-spider senses were tingling, I just overshot RT and went for the Halting Problem.
08:36:01 <gwern> @quote text.*editor
08:36:01 <lambdabot> NeilBrown says: I heard that if you chant "I don't think this can be done in Haskell" three times in front of a text editor, Don Stewart appears and implements it in one line...
08:36:13 <gwern> @quote last.*couple
08:36:13 <lambdabot> bos says: The last couple of times I've wanted a book like that, I wrote the book myself. It's a very effective way to get the book you want, compared to wishing.
08:36:27 <gwern> @quote features.*tax
08:36:27 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
08:36:42 <gwern> @quote into.*your.*brain
08:36:42 <lambdabot> No quotes match. I've seen penguins that can type better than that.
08:36:51 <gwern> @quote your.*brain
08:36:52 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
08:36:54 <gwern> @quote your.*brain
08:36:54 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
08:37:05 <gwern> @remember SPJ Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
08:37:05 <lambdabot> Nice!
08:37:19 <gwern> @quote magnetised.*needle
08:37:19 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
08:37:33 <gwern> @quote needle
08:37:33 <lambdabot> No quotes match. My pet ferret can type better than you!
08:37:37 <gwern> @remember EvilTerran writing machine code by hand on tape with a magnetised needle looks good compared to PHP :P
08:37:37 <lambdabot> Done.
08:37:49 <gwern> @quote Lisp.*safe
08:37:49 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
08:37:57 <gwern> @remember Athas I like Lisp for its extreme expressivity, but I think it's easier to make Haskell more powerful, than to make Lisp more statically safe.
08:37:57 <lambdabot> Nice!
08:38:05 <ski> edwardk : if so, then merely that i was cleaning up amongst old tabs in $BROWSER ..
08:38:06 <gwern> @quote Density
08:38:06 <lambdabot> No quotes match. Maybe you made a typo?
08:38:17 <gwern> @remember roconnor I can't wait for the Density Comonad chapter of "learn you a haskell"
08:38:18 <lambdabot> It is forever etched in my memory.
08:38:21 <Asztal> odd, I thought those quotes were taken *from* lambdabot. Guess not.
08:38:24 <gwern> @flush
08:38:28 <gwern> Asztal: they were
08:39:22 <ski> @help flush
08:39:22 <lambdabot> flush. flush state to disk
08:41:59 <Berengal> Leksah is actually pretty good once it doesn't crash immediately when you try to type something
08:42:36 <Berengal> Still not quite the text editor I'd like, but possibly the best haskell IDE currently out there
08:43:03 <Botje> does it have a "send my code to haskell-cafe" button?
08:43:07 <gwern> better than yi? that makes me sad
08:43:11 <edwardk> ski: ah
08:43:33 <Berengal> yi currently goes into an infinite loop whenever I try to start it...
08:43:44 <quicksilver> the problem is I want a small number of clever IDE features without having to give up on 20 years of editor evolution.
08:44:04 <quicksilver> I'm somehow doubtful that anyone will write an editor as capable as emacs quickly
08:45:12 <joga> well, vi goes back over 30 years :)
08:45:45 <Berengal> I'd be all for yi if it had some better documentation
08:46:00 <gwern> problem is, the docs get outdated so quickly
08:46:06 <gwern> I try to occasionally add haddocks
08:46:53 <Berengal> Yeah, I can see how that could be a problem. It doesn't make it easier for me though
08:47:42 <Berengal> I spent most of the day yesterday trying to figure Yi out. I gave up when it entered an infinite loop after I tried adding my first keymap (and didn't return to normal after I removed it)
08:48:16 <gwern> how would it return to normal if you borked the custom binary?
08:48:39 <Berengal> Well, it did recompile...
08:48:51 <edwardk> joga: i've been using vi for 25 of those years. Every time I switch to emacs, I wind up coming back. Its sad, really. You'd think by now there would be a significantly better/different replacement
08:49:16 <osfameron> the core vi keyboard navigation is so *well designed* though
08:49:27 <osfameron> the scripting language and everything else is a morass of piled-together hacks
08:49:39 <Berengal> edwardk: There's always the modern day IDEs. They've got nothing on vi/emacs when it comes to editing text though
08:49:44 <osfameron> but I'd hate to lose the yummy vi mappings
08:50:26 <edwardk> Berengal: i had a brief fling with turbo pascal's editor in dos, and occasionally visual studio romances me a bit with shiny integrated goodness, but I always come back ;)
08:51:41 <Berengal> edwardk: I know perfectly well what it's like. I use emacs most of the time myself
08:52:06 <edwardk> Berengal: my pinky thanks me for not using emacs any more. ;)
08:53:37 <joga> pinky thanks also if you turn your capslock into a control... ;)
08:53:42 <Berengal> edwardk: I've found I can use my palms for the modkeys without much problem
08:54:31 <Berengal> I believe emacs could've been made better if someone put a proper GUI on it for extensions to use if they wanted
08:54:51 <edwardk> joga: tried that, even thought about going crazy like shapr and switching to a kinesis keyboard and using something like his 'i am not a koala' keymappings, but ultimately its probably easier for me to continue living with my 'my left hand can't sit anywhere near the home row' typing style that i picked up from vi over the years ;)
08:55:29 <edwardk> in exchange i get to use half as many keystrokes to actually do editing, which after all is the purpose of an editor ;)
08:55:49 <joga> edwardk, which kinesis keyboard, the one with the 'two-bowl' design?
08:55:57 <mgsloan1> kinesis++
08:55:59 <Neophyte> I am curious, what are the boolean expressions for XOR,NOR in haskell? I know && is and and || is OR
08:56:13 <PeakerWork> Neophyte: to XOR you can use /=
08:56:15 <SamB> edwardk: and here I thought the point was to help you find what you wanted to edit
08:56:18 <mgsloan1> I have the freestyle, and it's awesome.  the two bowl is pretty cool too but ehh
08:56:24 <edwardk> joga: yeah
08:56:29 <Neophyte> /= OR PeakerWork?
08:56:37 <Neophyte> or Not OR*
08:56:41 <PeakerWork> Neophyte: a /= b    is    a XOR b
08:56:48 <joga> edwardk, is it good? I considered getting one but it's pretty expensive :)
08:57:00 <PeakerWork> Neophyte: for NOR you can just use    not (a || b) ?
08:57:11 <joga> mgsloan, you use it vertically? ;)
08:57:22 <PeakerWork> or: nor = (not.) . (||)
08:57:40 <mgsloan> nah, but I do have them at pretty high tilts, maybe 30 degrees, and usually quite spread apart
08:57:47 <Neophyte> what is the .?
08:57:49 <Berengal> Meh, I inline nor: not$ a || b
08:58:26 <sioraiocht> is there a way to do some sort of select on two more or channels in control.concurrent.chan?
08:58:31 <jmcarthur> @check \x y -> (x /= y) == not (x || y)
08:58:33 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\nFalse\n"
08:58:34 <Berengal> or simply not a && not b
08:58:37 <Neophyte> PeakerWork can I set up a truth table like: (a->b) \/ (b->~a) and determine whether or not it is a contradiction, tautology, or a mixture?
08:58:42 <jmcarthur> oops
08:58:42 <edwardk> joga: he swears by it. personally the lack of finger motion would drive me nuts
08:58:54 <jmcarthur> XOR /= NOR ;)
08:59:21 <sioraiocht> @check \x y -> (x /= y) == not (x && y)
08:59:22 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\nFalse\n"
08:59:25 <sioraiocht> damn
08:59:26 <sioraiocht> =p
08:59:39 <mgsloan> joga - my main problem was one wrist was always quite bent, to compensate for the tinyness of most keyboards.  even ergo keyboards don't have enough seperation
08:59:46 <jmcarthur> XOR /= NAND :P
08:59:50 <sioraiocht> heheh
08:59:52 <sioraiocht> true true
08:59:53 <Berengal> sioraiocht: You can use orElse to read from another channel if reading the first causes a retry
09:00:14 <sioraiocht> Berengal: hmm, that doesn't guarantee fairness, though, does it?
09:00:16 <quicksilver> using TChan not Chan, Berengal :P
09:00:21 <Neophyte> Also, can I set up a predicate calculus formula using 'For All', 'There Exist' and check to see if it is a logically valid formula, or check a proof?
09:00:44 <Berengal> quicksilver: True :/
09:01:23 <joga> mgsloan, I randomly acquired such a device http://www.fingerworks.com/ST_product.html , but it's not really good for touch typing, just cool otherwise ;) I've been looking for a adjustable keyboard, the freestyle might be worth a try if I can find it somewhere
09:01:27 <dmwit> sioraiocht: How about merging the two threads?
09:01:33 <dmwit> sioraiocht: s/threads/channels/
09:01:33 <PeakerWork> Neophyte: I think you can, but I'm not sure what exactly you mean
09:01:34 <joga> *an
09:01:40 <Berengal> sioraiocht: No, the first channel listed would always be the first one to be read
09:01:55 <Neophyte> PeakerWork basically asking how you can use haskell to verify a proof in first order logic
09:01:55 <mreh> GHC is missing a library called IOExts
09:01:57 <sioraiocht> dmwit: I would prefer to keep their message types different, but I may have no choice
09:02:00 <dmwit> sioraiocht: Spawn off two threads; each reads from one of the channels and writes the message to a third (shared) chaannel.
09:02:00 <quicksilver> sioraiocht: define 'fair', in this context.
09:02:05 <dmwit> sioraiocht: Either ;-)
09:02:08 <mgsloan> joga - ahh cool.  Well, the freestyle has worked out well for me
09:02:22 <dmwit> sioraiocht: Sum types are easy in Haskell. ;-)
09:02:32 <Berengal> Either = + :)
09:02:36 <mgsloan> it's a pretty well made keyboard, very physically clicky
09:02:41 <sioraiocht> dmwit: thanks
09:03:14 <sioraiocht> is it bad to use my own sum type instead of Either?
09:03:18 <mreh> isn't it true the freestyle doesn't have any letters
09:03:22 <sioraiocht> because Left and Right aren't very clear, in this case?
09:03:26 <sioraiocht> does this upset people? =p
09:03:37 <quicksilver> sioraiocht: sounds pointless to me.
09:03:41 <dmwit> No, use whatever's clearest.
09:03:43 <quicksilver> you probably wouldn't expose this anyway
09:03:48 <quicksilver> it's just an internal detail
09:03:54 <sioraiocht> quicksilver: no I wouldn't, it's more for my own sanity purposes
09:04:10 <quicksilver> well it's probably a very localised detail, only needed by a small fragment of code
09:04:14 <quicksilver> so IMO it's not worth a new type.
09:04:19 <quicksilver> feel free, though, if you prefer it :)
09:04:22 <quicksilver> there's certainly no harm in it.
09:04:33 <Berengal> sioraiocht: I use Either for quick throw-away types that aren't really important in some way. If the type spans more than three functions I usually give it a proper name
09:04:48 <quicksilver> one advantage is if there are general combinators you can use, though.
09:04:53 <quicksilver> like map (either foo bar) ...
09:05:14 <quicksilver> Reactive has : sumE :: Event a -> Event b -> Event (Either a b)
09:05:20 <quicksilver> which is very much like what you're talking about
09:05:24 <quicksilver> Events are quite a lot like Chans
09:05:27 <sioraiocht> quicksilver: ah, thanks, that makes sense
09:05:29 <quicksilver> except the datums are time-tagged.
09:05:35 <quicksilver> data.
09:05:39 <quicksilver> stupid abberant plural.
09:05:48 <sioraiocht> quicksilver: welcome to English? =p
09:06:24 <quicksilver> right :)
09:06:37 <quicksilver> the time tagging makes it automatically fair.
09:06:39 * sioraiocht is glad his FIRST language was english, the others seem more fun to learn
09:06:49 <quicksilver> sumE knows to merge in strictly time-order.
09:07:14 <sioraiocht> quicksilver: that's cool, it's not part of the core libraries, though, right?
09:07:20 <quicksilver> no.
09:07:26 <sioraiocht> i'll check it out
09:07:30 <quicksilver> So, for Chan you need some idea of what 'fair' is supposed to mean :)
09:07:40 <quicksilver> likely just forking two threads is close enough.
09:08:00 <sioraiocht> quicksilver: right, I'm okay with guaranteed service, not a guaranteed order or guaranteed time limit, in this case
09:08:02 <quicksilver> GHC's rts has some weak progress guarantee I think.
09:08:13 <quicksilver> I think it's the case that if a thread can run, it will eventually run
09:08:17 <quicksilver> you never get complete starvation.
09:08:25 <quicksilver> I don't think the guarantee gets stronger than that though.
09:08:57 <sioraiocht> also, using forkIO, ghc will schedule it's lightweight threads in multiple OS threads on a multicore processor, won't it?
09:09:06 <quicksilver> yes.
09:09:12 <sioraiocht> sweet
09:09:13 <quicksilver> although only if you use -RTS -N4
09:09:19 <quicksilver> (for some value of 4)
09:09:22 <sioraiocht> okay
09:09:37 <sioraiocht> good to know
09:09:38 <quicksilver> threads which just read from Chans spent most of their life blocked so it may not matter.
09:09:41 <mreh> i'm trying to us a library IOExts, but the code using it makes reference to IOExts, and the library i have is hugs.IOExts
09:10:14 <tombom> use ghc
09:10:15 <Berengal> Hmm, it would be possible to keep several STM () values in a list and rotate the list inbetween each tried read...
09:10:27 <Berengal> That way each chan would get their turn being first
09:10:35 <roderyk> I don't see gtk.Assistant in gtk2hs 0.10.1  .. does anyone know if it's in darcs already or if I'm out of luck?
09:10:40 <Berengal> Doubt it'd be a very good solution though, but it's a simple one
09:10:40 <mreh> tombom: i am
09:10:51 <jmcarthur> sounds like a good solution to me
09:10:55 <mreh> i d/l the library
09:11:10 <quicksilver> mreh: where from?
09:11:23 <jmcarthur> just make the list with the cycle function and then pull off the head one at a time
09:11:37 <quicksilver> I think IOExts is ancient history.
09:12:21 <mreh> quicksilver: i can't remember
09:12:33 <mreh> does ghc use the classpath?
09:12:55 <mreh> maybe its not pointing to the right library
09:13:07 <dmwit> Classpath?  As in Java?
09:13:12 <dmwit> No, I don't think so.
09:13:13 <quicksilver> mreh: I do not think you want to use IOExts.
09:13:24 <quicksilver> it is an extremely old, obsolete collection of functions
09:13:31 <quicksilver> which have either been replaced or put elsewhere.
09:13:39 <quicksilver> it was distributed with GHC 4.0 !
09:13:48 <mreh> quicksilver: i'm not using it, i'm trying to compile some old code
09:13:50 <mreh> GHC 4.0, okay
09:14:27 <quicksilver> http://www.haskell.org/ghc/docs/4.06/hslibs/sec-ioexts.html
09:14:35 <quicksilver> ^^ these things are all in the core libs, in one form or another
09:15:01 <quicksilver> System.IO.Unsafe, Data.IORef, Data.Array.IOArray, Debug.Trace
09:25:15 <osfameron> can you use tortoise-and-hare method for detecting cycles in streams in haskell?
09:25:29 <opqdonut> yes
09:25:34 <osfameron> it would seem you'd need to be able to test reference-equality, not just value equality
09:25:42 <dmwit> right
09:25:51 <opqdonut> yes, you need to have a guarantee that elements are unique
09:25:56 <quicksilver> there is no semantic difference in haskell between a cyclic list and an infinite list.
09:26:08 <quicksilver> cycle [1] *is* the infinite list of 1s
09:26:13 <osfameron> ok, so it'd work for the situation I was thinking of, but not in general case
09:26:15 <quicksilver> it just happens to be represented in an efficient way.
09:26:26 <SamB> quicksilver: so running out of RAM isn't semantic, eh?
09:26:36 <dmwit> SamB: Right.
09:26:43 <dmwit> On the other hand, now that we have vacuum...
09:26:45 <quicksilver> of course, if you cheat and use implementation primitives you can
09:26:47 <opqdonut> SamB: well some infinite lists allow for O(1) traversal
09:26:48 <quicksilver> hence vacuum.
09:26:54 <quicksilver> SamB: indeed not.
09:26:55 <vixey> if you want to observe the sharing, data List s a = Nil | Cons a (STRef s (List s a))?
09:26:55 <osfameron> quicksilver: yes, but if you wanted to detect that, you still can't ?
09:26:58 <opqdonut> O(1) memory that is
09:27:11 <quicksilver> SamB: the semantics of haskell is in terms of a machine with infinite memory.
09:27:16 <dmwit> vixey: What, can you compare STRefs?
09:27:18 <osfameron> unless, is that what unsafePointerEquality does?
09:27:22 <SamB> opqdonut: oh, sure, if you don't keep the beginning
09:27:33 <opqdonut> that was kinda my point :)
09:27:33 <jmcarthur> @instances Eq
09:27:34 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:27:53 <SamB> quicksilver: I still don't understand how that would work -- what does it use for addresses ?
09:27:58 <quicksilver> SamB: if it wasn't, then just about every value would include {OutOfMemoryError}
09:28:00 <dmwit> ?instances-importing Data.STRef
09:28:01 <lambdabot> Couldn't find class `Data.STRef'. Try @instances-importing
09:28:09 <dmwit> whoops
09:28:10 <jmcarthur> eh, i think you can compare IORefs, so it would make sense to be able to do the same with STRefs if that's true
09:28:10 <dmwit> ?instances-importing Data.STRef Eq
09:28:11 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, STRef s a, Sum a, [a]
09:28:12 <quicksilver> because any calculation, in principle, can run out of memory
09:28:26 <dmwit> Well, apparently you can! =)
09:29:01 <quicksilver> SamB: the natural numbers, say? although the semantics of haskell doesn't really need addresses, per se.
09:29:25 <SamB> quicksilver: so how do you store *those*?
09:29:57 <quicksilver> you don't need to store anything.
09:30:01 <jmcarthur> SamB, the point is that that is hidden
09:30:02 <quicksilver> we're talking about semantics.
09:30:06 <quicksilver> semantics just *is*.
09:30:24 <quicksilver> for example, a toy calculator language might have a semantics in Z or Z -> Z or something.
09:31:37 <osfameron> hmmm, tortoise/hare in haskell would consider the list [1,2,3,4,5,3] to be cyclical
09:32:12 <SamB> yeah, well, I like to think of machines that are actually plausible
09:32:25 <quicksilver> what has semantics got to do with machines?
09:32:29 <SamB> machines with infinitely-wide registers, I don't find terribly plausible :-(
09:32:33 <quicksilver> smenatics is about *meaning*
09:32:35 <quicksilver> not implementation.
09:32:47 <quicksilver> once you're happy that the meaning is something sensible, then you move on to make an implementation.
09:32:53 <quicksilver> which involves compromises due to the real world, of course
09:32:56 <quicksilver> but you do the best you can.
09:33:12 * SamB grumbles
09:33:28 <jmcarthur> one could simply consider the shortcomings of hardware to be a bug in the implementation of the desired semantics
09:35:25 <quicksilver> it's not that I don't think hardware is important.
09:35:33 <quicksilver> and it's not that I don't believe in realistic machines.
09:35:46 <quicksilver> I jsut don't think that's where you start when giving the semantics of a language
09:35:56 <quicksilver> you want the semantics of a language to be implementation independent
09:36:03 <quicksilver> ...whilst still permitting efficient implementation.
09:36:44 <tromp> haskeel seems to have no problem storing unbounded Integers
09:37:13 <quicksilver> well they're bounded by memory size, of course.
09:37:15 <tromp> as long as they fit in memory:)
09:37:22 <quicksilver> possibly even virtual memory size.
09:38:26 <endofjelly> probably max(virtual address space size, virtual memory size), I suppose, but again that's implementation size
09:38:35 <endofjelly> that's implementation dependent, I mean
09:38:57 <tromp> > bit 100
09:38:58 <lambdabot>   Add a type signature
09:39:06 <tromp> > bit 100 :: Integer
09:39:08 <lambdabot>   1267650600228229401496703205376
09:39:23 <tromp> > bit 1000 :: Integer
09:39:24 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
09:39:27 <tombom> > bit 1000000000000000 : integer
09:39:28 <lambdabot>   Couldn't match expected type `[a]'
09:39:37 <tombom> > bit 1000000000000000 : Integer
09:39:38 <lambdabot>   Not in scope: data constructor `Integer'
09:39:44 <tombom> > bit 1000000000000000 :: Integer
09:40:00 <lambdabot>   thread killed
09:40:20 <jmcarthur> > 2**1000000000000000 :: CReal
09:40:35 <lambdabot>   thread killed
09:40:45 <copumpkin> I remember reading recently that mutability is just another form of manual memory management... does anyone remember where that is from?
09:40:50 <tromp> > iterate bit 0 :: [Integer]
09:40:51 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
09:41:00 <endofjelly> it would of course be possible to write an implementation which allows integers to be bounded by virtual memory size instead of virtual address space size. but that's quite complicated, possibly inefficient and, franky, practically useless on 32bit machines already. on 64bit machines it's inconceivably senseless
09:41:09 <jmcarthur> copumpkin, i have said similar things here before
09:41:17 <jmcarthur> but if you mean a paper or article, i have no idea
09:41:31 <tromp> > iterate bit 0 :: [Int]
09:41:33 <lambdabot>   [0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,4,16,65536,0,1,2,...
09:41:38 <Gracenotes> @type bit
09:41:40 <lambdabot> forall a. (Bits a) => Int -> a
09:42:01 <Gracenotes> > 2^100
09:42:02 <lambdabot>   1267650600228229401496703205376
09:42:06 <jmcarthur> > map bit [0..] :: [Integer]
09:42:08 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:42:21 <Gracenotes> > bit 100 :: Integer
09:42:23 <lambdabot>   1267650600228229401496703205376
09:42:26 <copumpkin> jmcarthur: I wanted to evangelize some more on twitter but didn't want to imply the quote was mine, so wanted something to cite/retweet :P have you ever tweeted such a thought? ;)
09:43:04 <jmcarthur> i'll see if i can track it down
09:43:34 <Gracenotes> >:/
09:45:31 <copumpkin> jmcarthur: I can't find it in your past tweets :(
09:47:45 <jmcarthur> copumpkin, no, it was in irc
09:47:49 <copumpkin> ah
09:47:57 <jmcarthur> i dont know if it was save in quotes, but let's see
09:48:01 <jmcarthur> @quote geezusfreeek
09:48:01 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
09:48:04 <jmcarthur> @quote geezusfreeek
09:48:04 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
09:48:14 <jmcarthur> @quote jmcarthur
09:48:14 <lambdabot> No quotes match.
09:48:20 <jmcarthur> guess not
09:50:06 <jmcarthur> copumpkin, i can't find it at all, sorry
09:50:31 <copumpkin> ah well, thanks for looking :)
09:51:08 <vixey> @quote mutation
09:51:08 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
09:51:19 <vixey> @quote mutation
09:51:20 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
09:51:29 <vixey> that doesn't even have the word in it
09:52:16 <PeakerWork> commutation
09:52:36 <jmcarthur> copumpkin, but i do see parallels in GC vs. memory management, Haskell vs. state management, and FRP vs. IO action sequencing
09:52:59 <jmcarthur> i believe the quote i was thinking of was more about FRP than Haskell, is why i mention FRP here
09:53:34 <copumpkin> ah :)
09:53:46 <lament> @quote FRP
09:53:46 <lambdabot> No quotes match. Are you on drugs?
09:54:49 <dmwit> heh, I like SPJ's quote on this week's HWN. =)
09:54:58 <jmcarthur> @quote frp
09:54:58 <lambdabot> No quotes match. Maybe you made a typo?
09:55:52 <copumpkin> @quote codivorced
09:55:52 <lambdabot> pumpkin says: when did you get codivorced?
09:58:57 <Gracenotes> :_:
09:59:30 <kyevan> Hour 6 of GHC building... I decide to get showered >_>
10:00:18 <endofjelly> why does building ghc take so long?
10:01:11 * roconnor is beginning to think that operational semantics destroys people ability to think.
10:01:25 <taggadtyp> operational semantics=?
10:01:44 <byorgey> roconnor: care to elaborate?
10:01:56 <taggadtyp> > (***) (+1) (subtract 5) $ (3,4)
10:01:56 <Gracenotes> endofjelly: does GHC have Buddha nature or not?
10:01:57 <lambdabot>   (4,-1)
10:02:09 <taggadtyp> > (+1) *** (subtract 5) $ (3,4)
10:02:11 <lambdabot>   (4,-1)
10:02:33 <taggadtyp> > (1:) *** (5:) $ ([3],[4])
10:02:33 <roconnor> byorgey: I read a comment about my "dynamic dispatch is bad" essay. (which was supposed to be an "encapsulation is good essay")
10:02:34 <lambdabot>   ([1,3],[5,4])
10:02:39 <endofjelly> Gracenotes, I.. don't know %)
10:03:00 <roconnor> byorgey: I said that dynamic dispatch is scary because you have no idea what might happen when you call a virtual function
10:03:11 <byorgey> right, I remember reading your essay
10:03:15 <taggadtyp> > (1:) &&& (5:) $ 3
10:03:16 <lambdabot>       No instance for (Num [t])
10:03:16 <lambdabot>        arising from the literal `3' at <inter...
10:03:19 <taggadtyp> > (1:) &&& (5:) $ [3]
10:03:20 <lambdabot>   ([1,3],[5,3])
10:03:35 <roconnor> byorgey: the comment was that dynamic dispatch is not scary because how virtual function tables work is semantically well defined and easy to reason about.
10:03:49 <byorgey> hehe, I see
10:04:06 <roconnor> I don't know where to begin
10:04:16 <roconnor> these people see software in a totally different way than I do
10:04:26 <vixey> which peopel?
10:04:44 <roconnor> I can't believe we work in the same jobs.
10:04:48 <taggadtyp> those people over there -> C++
10:04:54 <Gracenotes> mm. in Haskell, you implicitly pass a dictionary to every function that uses typeclass...
10:05:06 <roconnor> vixey: check out the last 3 min  between byorgey and me
10:05:20 <dons> ?users
10:05:20 <lambdabot> Maximum users seen in #haskell: 658, currently: 615 (93.5%), active: 18 (2.9%)
10:05:23 <Gracenotes> at least
10:05:42 <roconnor> Gracenotes: ya,  I had a footnote in my essay that Haskell has dynamic dispatch, and it was less scary in practice for a few reasons.
10:06:08 <taggadtyp> > (Just 6) >>= \v -> return $ v * v
10:06:10 <lambdabot>   Just 36
10:06:13 <byorgey> roconnor: by that reasoning I suppose Rube Goldberg machines are also semantically well defined and easy to reason about =)
10:06:17 <roconnor> Gracenotes: another person thinks that haskell type classes are not dynamic dispatch.
10:06:24 <vixey> oh yeah
10:06:29 <taggadtyp> > (^2) <$> Just 5
10:06:30 <lambdabot>   Just 25
10:06:36 <vixey> if anyone says "it's easier to reason about" that means absolutely nothing
10:06:37 <roconnor> byorgey: they follow the laws of physics!  What's the problem
10:06:41 <taggadtyp> > fmap (^2) (Just 5)
10:06:42 <Gracenotes> it's quite nice. It's like you have, for instance, an EqDict (a -> a -> Bool) (a -> a -> Bool), then whenever you use an arbitrary Eq you have to pass and EqDict along with it
10:06:42 <lambdabot>   Just 25
10:06:43 <byorgey> exactly!
10:06:48 <roconnor> byorgey: that's a tempting reply to make
10:06:49 <taggadtyp> @type lookup
10:06:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:07:00 <taggadtyp> @type Map.lookup
10:07:01 <lambdabot> Couldn't find qualified module.
10:07:12 <Gracenotes> how it works is reasonably transparent. like vtables. and the type safety helps a bit too.
10:07:20 <taggadtyp> > Map.lookup 1 $ Map.fromList [(1,3)]
10:07:21 <lambdabot>       No instance for (Show (m a))
10:07:21 <lambdabot>        arising from a use of `show' at <in...
10:07:25 <roconnor> Gracenotes: that's an implementation detail, btw.  Not all compilers do that.
10:07:32 <jmcarthur> hmm... for some reason this didn't occur to me until now, but i suppose a Reader could be used to implement the type class dictionary passing. i wonder if there are any advantages at all to that approach compared to the completely implicit way
10:07:35 <taggadtyp> > fromMaybe 0 $ Map.lookup 1 $ Map.fromList [(1,3)]
10:07:36 <lambdabot>   3
10:07:37 <Gracenotes> roconnor: at least GHC :) But the idea is the same.
10:07:41 <taggadtyp> > fromMaybe 0 $ Map.lookup 12 $ Map.fromList [(1,3)]
10:07:42 <lambdabot>   0
10:07:58 <Gracenotes> although, I should probably get around to reading Haskell 98 one of these days...
10:08:09 <Berengal> There's also the cases when the type can be determined at compile time, in which case swapping the class function for the instance function directly works
10:08:15 <byorgey> jmcarthur: well, type class inference is nice
10:08:19 <PeakerWork> taggadtyp: you can use $ before the [(1,3)] and dot (.) everywhere else
10:08:29 <roconnor> Gracenotes: I noted in one of my comment replies that a compiler doing whole program analysis can probably resolve all instances at compile time
10:08:36 <Gracenotes> yeah.
10:08:37 <roconnor> ... At least for Haskell '98
10:08:37 <taggadtyp> > fmap ((1+) *** (3+)) [(1,2),(3,4)]
10:08:39 <lambdabot>   [(2,5),(4,7)]
10:08:42 <jmcarthur> byorgey, both ways have the advantages of type inference though
10:08:45 <roconnor> ... maybe
10:08:47 <taggadtyp> > map ((1+) *** (3+)) [(1,2),(3,4)]
10:08:48 <lambdabot>   [(2,5),(4,7)]
10:08:56 <Berengal> roconnor: Doesn't work for existential types at least
10:09:04 <Gracenotes> roconnor: and by whole program analysis, you mean the library won't be used anywhere else either
10:09:06 <taggadtyp> > map ((1+) &&& (3+)) [1..10]
10:09:06 <roconnor> Berengal: which isn't Haskell '98 :)
10:09:07 <lambdabot>   [(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10),(9,11),(10,12),(11,13)]
10:09:10 <jmcarthur> the annotation is just a type constructor rather than a constraint "on the side"
10:09:14 <edwardk> jmcarthur: its a fairly common pattern to pass along utility functions via reader, at least i've used it when i wasn't sure what they should all be
10:09:31 <Gracenotes> Berengal: you're sort of in a different mindset when you're writing a function for a general typeclass, vs. a specific type that happens to use a function you want in the typeclass
10:09:44 <taggadtyp> > map (\x -> (1+x, 3+x)) [1..10]
10:09:45 <lambdabot>   [(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10),(9,11),(10,12),(11,13)]
10:09:46 <jmcarthur> edwardk, as have i. i'm really just curious about a direct comparison between that technique and type classes
10:09:50 <Berengal> roconnor: I know, just wondering if it's possible to emulate it well enough to get the undecidability at compile time in h98
10:09:53 <Gracenotes> Berengal: that's why the Num typeclass is somewhat tricky. You think of a numerical function as processing a specific type, but it really is a typeclas.
10:10:08 <roconnor> Gracenotes: well, I did point out was that the operational behaviour isn't what I'm interested in.  I don't care about run-time vs compile time.  I care about software-development-time.
10:10:11 <taggadtyp> do you really think arrows and applicatives make code clearer?
10:10:12 <Gracenotes> and why the Num b => Num (a -> b) instance would be a bad idea to include by default
10:10:29 <taggadtyp> slightly more succinct but more cryptic is my impression
10:10:29 <Berengal> Gracenotes: Yeah, that class takes some getting used to...
10:10:47 <roconnor> Gracenotes: so I really want to use a semantic notion of "dynamic-dispatch" but I don't know of such a word, and if there is I'm not sure my readers will get it.
10:11:28 <taggadtyp> what does arrows and applicatives do? I mean it is a bunch of different operators but what makes them belong together?
10:11:30 <hatds> doesn't the monoid library declare a Monoid a => Monoid (b->a)?
10:11:42 <jmcarthur> @instances Monoid
10:11:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:11:43 <Gracenotes> well GHC does sort of define semantics for dynamic dispatch. But... it's an implementation
10:11:46 <Gracenotes> hatds: yeah
10:12:04 <beelsebob> taggadtyp: applicatives apply things
10:12:06 <Gracenotes> but Monoid is more abstract than Num
10:12:06 <beelsebob> as the name suggests
10:12:31 <beelsebob> functors apply pure functions to arguments in boxes, applicatives apply functions in boxes to arguments in boxes
10:13:00 <beelsebob> > (Just (+5)) <*> (Just 6) -- like this
10:13:01 <lambdabot>   Just 11
10:13:06 <taggadtyp> function in box?
10:13:11 <jmcarthur> Gracenotes, would be better if Num was really a field or ring or something
10:13:21 <beelsebob> > [(+5), (*2)] <*> [1,2,3]
10:13:22 <lambdabot>   [6,7,8,2,4,6]
10:13:29 <jmcarthur> and nothing else, i mean
10:13:29 <taggadtyp> and arrows?
10:13:36 <hatds> @instances Functor
10:13:37 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:13:43 <taggadtyp> > [(+5), (*2)] <*> [1,2,3]
10:13:45 <lambdabot>   [6,7,8,2,4,6]
10:13:50 <beelsebob> taggadtyp: arrows do wierd things on tuples, I'm not certain I can explain them well (perhaps I don't understand them well)
10:14:00 <Gracenotes> jmcarthur: heh. That's been proposed. But maybe we should leave it to more theoretical languages even
10:14:02 <jmcarthur> arrows generalize functions, basically
10:14:03 <beelsebob> I don't really have an intuitive explanation for what an arrow is
10:14:03 <taggadtyp> > [(+1), (*3)] <*> [1..5]
10:14:04 <lambdabot>   [2,3,4,5,6,3,6,9,12,15]
10:14:35 <taggadtyp> > [(x,y) | x <- [1..3], y <- [1..3]]
10:14:35 <jmcarthur> Gracenotes, the only weird thing about that proposal is that the name will not be immediately obvious to programmers without much math background
10:14:36 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:14:40 <beelsebob> > (Left "error: you forgot to provide a function") <*> (Right 5)
10:14:41 <lambdabot>       No instance for (Applicative (Either [Char]))
10:14:41 <lambdabot>        arising from a use...
10:14:45 <beelsebob> aww :(
10:14:47 <Gracenotes> taggadtyp: Applicative seems a bit useless at first. Putting a function in a box just to take it out? But it's quite nice when you have multi-argument applicatives
10:15:01 <beelsebob> Gracenotes: indeed
10:15:04 <taggadtyp> can you use applicatives to do this: [(x,y) | x <- [1..3], y <- [1..3]] ?
10:15:14 <Gracenotes> yeah
10:15:22 <Gracenotes> > (,) <$> [1..3] <*> [1..3]
10:15:24 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:15:29 <beelsebob> > [(,)] <*> [1..3] <*> [1..3]
10:15:30 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:15:35 <Gracenotes> it's Applicative because no variables are used at all
10:15:36 <taggadtyp> ok
10:15:37 <beelsebob> (my one not using functor there, but being the same thing)
10:15:38 <taggadtyp> not clearer though
10:15:41 <Gracenotes> it's just application
10:16:04 <Gracenotes> there is no need to name anything. It's just passed.
10:16:16 <Gracenotes> @where applicativeparsec
10:16:16 <lambdabot> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ and http://book.realworldhaskell.org/read/using-parsec.html#id652399
10:16:18 <beelsebob> taggadtyp: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/ <-- blowing my own trumpet a bit
10:16:37 <Gracenotes> taggadtyp: the parsec links show how Applicatives can be used to write elegant parsers.
10:16:58 <beelsebob> so does the blog entry :)
10:17:06 <vixey> and monads
10:17:28 <Gracenotes> like Monads, Applicatives sequence things. This is useful for parsing where all you're concerned about is sequencing parses and combining some results
10:17:31 <taggadtyp> tje forst link fails
10:17:52 <beelsebob> importantly though, the syntax for applicatives lends itself better to parsing
10:18:06 <vixey> not really
10:18:08 <beelsebob> you only appear to write what order tokens should come in
10:18:09 <gwern> huh. jane street is funding lambda cube
10:18:12 <vixey> you can't use intermediate results
10:18:15 <Berengal> Parsing very seldom requires computing parsers based on previous parsers
10:18:15 <gwern> * 3d
10:18:18 <gwern> http://ocaml.janestreet.com/?q=node/63
10:18:21 <beelsebob> rather than with the monad version writing what order you want to parse things in
10:18:25 <travisbrady> i have a silly question, is there anyway ".. && >>=" could be legal Haskell?
10:18:50 <jmcarthur> don't think so
10:18:50 <Gracenotes> probably not... unless it's a string ^_^
10:18:56 <jmcarthur> heh
10:18:56 <beelsebob> travisbrady: I don't think so, no
10:18:57 <byorgey> travisbrady: no.
10:18:58 <mux> I don't think you'll be able to make it legal because of the ..
10:19:02 <jmcarthur> > ".. && >>="
10:19:03 <lambdabot>   ".. && >>="
10:19:04 <taggadtyp> > let tupleFromWith f g xs = f &&& g $ xs in tupleFromWith (+1) (+3) [1..3]
10:19:04 <mux> it could probably be legal perl though ;-)
10:19:05 <lambdabot>       No instance for (Num [t])
10:19:05 <lambdabot>        arising from the literal `1' at <inter...
10:19:13 <taggadtyp> > let tupleFromWith f g xs = f *** g $ xs in tupleFromWith (+1) (+3) [1..3]
10:19:14 <lambdabot>   Couldn't match expected type `(b, b')' against inferred type `[a]'
10:19:17 <vininim> :t (..)
10:19:18 <lambdabot> parse error on input `..'
10:19:24 <taggadtyp> > let tupleFromWith f g xs = f *** g $ xs in tupleFromWith (+1) (+3) 1
10:19:26 <lambdabot>       No instance for (Num (b, b'))
10:19:26 <lambdabot>        arising from the literal `1' at <i...
10:19:32 <taggadtyp> > let tupleFromWith f g xs = f &&& g $ xs in tupleFromWith (+1) (+3) 1
10:19:33 <lambdabot>   (2,4)
10:19:54 <jmcarthur> :t (...)
10:19:55 <lambdabot> Not in scope: `...'
10:20:08 <jmcarthur> huh, valid. i guess (..) is reserved for ranges?
10:20:10 <travisbrady> byorgey, beelsebob: dang, wanted to show folks at work some weird unreadable stuff for fun
10:20:15 <taggadtyp> so any typeclasses inspired by catgeory theory that isn't implemented yet?
10:20:20 <dmwit> "There is no graphics library available for Haskell that would be suitable as a basis for a complex graphical program." .... wut
10:20:22 <Gracenotes> "." is a function. ".." is a token. "..." and on can be used for other function names
10:20:27 <Philippa> travisbrady: SKI is your friend :-)
10:20:28 <beelsebob> dmwit: o.O
10:20:33 <beelsebob> uhhh... what happened to OpenGL?
10:20:38 <taggadtyp> @type (.)
10:20:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:20:39 <dmwit> That's what I was wondering.
10:20:40 <taggadtyp> @type (..)
10:20:42 <lambdabot> parse error on input `..'
10:20:42 <taggadtyp> @type (...)
10:20:44 <lambdabot> Not in scope: `...'
10:20:50 <dmwit> travisbrady: Well, (&&) >>= could be part of some legal Haskell.
10:21:00 <jmcarthur> ah okay, explains why it sees that as a parse error rather than explaining that it's reserved
10:21:01 <taggadtyp> @type (&&)
10:21:02 <lambdabot> Bool -> Bool -> Bool
10:21:15 <Gracenotes> yes, it could...
10:21:22 <travisbrady> hmm, never heard of SKI have to check that out
10:21:35 <taggadtyp> > let tupleFromWith f g xs = fmap $ f *** g $ xs in tupleFromWith (+1) (+3) [1,2,3]
10:21:36 <lambdabot>   Couldn't match expected type `a -> b'
10:21:40 <jmcarthur> Applicative = generalized SK calculus :)
10:21:41 <Gracenotes> dmwit: well, I don't know of many complex graphical programs in Haskell, other than maybe Frag..
10:21:48 <taggadtyp> > let tupleFromWith f g xs = fmap (f *** g) xs in tupleFromWith (+1) (+3) [1,2,3]
10:21:50 <lambdabot>       No instance for (Num (b, b'))
10:21:50 <lambdabot>        arising from the literal `1' at <i...
10:21:51 <vixey> i do't really see why writing a *> b is a >> b is lke 'more elegant' and whatever
10:21:51 <Philippa> travisbrady: it's a combinator basis. I is id, K is const, S is self-application
10:22:10 <taggadtyp> > let tupleFromWith f g xs = fmap (f &&& g) xs in tupleFromWith (+1) (+3) [1,2,3]
10:22:11 <lambdabot>   [(2,4),(3,5),(4,6)]
10:22:14 <Gracenotes> yes. The Applicative paper by Ross and Conor covers this. http://www.soi.city.ac.uk/~ross/papers/Applicative.html
10:22:29 <Gracenotes> it's a nice read once you're somewhat familiar with applicatives. At least the first few sections.
10:22:36 <mux> vixey: but a <* b clearly is more convenient than a >>= \x -> b >> return x
10:22:48 <vixey> looks the same to me..
10:22:54 <beelsebob> vixey: then you're blind
10:23:02 <dmwit> mux: Sure, but (<*) is easily definable (exactly as you wrote it) for Monad.
10:23:03 <vixey> shut it
10:23:06 <jmcarthur> also has looser type requirements ;)
10:23:12 <mux> dmwit: agreed
10:23:40 <Berengal> ZipList isn't a monad, but it's a pretty convenient applicative...
10:23:41 <beelsebob> dmwit: yep, no one's arguing that monads aren't powerful
10:23:41 * Philippa still wants a do-like notation for Applicatives
10:23:54 <beelsebob> merely that the applicative notation is nice in some cases
10:24:00 <mux> dmwit: however, X is easily definable just how you wrote it is somehow a tautology for referentially transparent languages :)
10:24:08 * beelsebob still wants a good do notation for monads that doesn't suggest there's a sequence of actions going on
10:24:33 <vixey> I'm not blind and please don't try that
10:24:37 <Philippa> beelsebob: perhaps your problem there is your tendency to see "sequence of actions"
10:24:38 <dmwit> mux: Not necessarily.  As Berengal points out, a Monad instance for ZipList isn't easily definable.
10:24:54 <beelsebob> Philippa: no, my problem is that the verb "do" implies that exact thing
10:24:59 <Philippa> I mean really, how else would you do it? There's not an awful lot you can do beyond renaming a few tokens - ultimately, there is a sequence of sorts
10:25:06 <beelsebob> Philippa: what I want is "be" notation
10:25:08 <beelsebob> not "do" notation
10:25:12 <vixey> beelsebob; for someone who cares so much about 'semantics' you have a lot of strong opiniosn aboun syntax anyway..
10:25:20 <Philippa> *shrug*. Honestly, that's just not worth screaming about
10:25:25 <mux> dmwit: yes, because I can't write it; I only meant to say that if you can write it, you can define a function for it, but that was a bad joke I guess
10:25:31 <quicksilver> what about sinatra-programming?
10:25:35 <beelsebob> Philippa: I didn't say it would be the same as do notation ;)
10:25:36 <quicksilver> "do be do be do" notation.
10:25:36 <dmwit> oh, right
10:25:41 <Philippa> yeah, it's a wart in places. It has advantages elsewhere...
10:25:42 <beelsebob> quicksilver: :D
10:25:46 <Gracenotes> ZipList is not just not-so-easily definable, it would be impossible to write one for which liftM2 id == <*>
10:25:49 <beelsebob> Philippa: agree
10:25:53 <Philippa> beelsebob: yeah, but what else would you really change?
10:26:02 <beelsebob> I don't know where we'd be without do notation for IO
10:26:14 <beelsebob> suggesting a sequence of actions is *exactly* what we want there
10:26:24 * quicksilver thinks do notation is no more sequential than division
10:26:29 <hatds> you'd just end every line with >>= \pat ->
10:26:31 <beelsebob> Philippa: I'm not entirely certain, I need to think about it lots at some point
10:26:33 <quicksilver> 5 / 2 is different from 2 / 5
10:26:35 <Philippa> the wart's minor, IMO. The problem is as much when people keep hearing "sequence of actions" from people complaininng about monads
10:26:40 <jmcarthur> my personal policy is to not use do notation unless i'm using a monad that is meant to convey something imperative
10:26:48 <beelsebob> hatds: that wouldn't be an alterative syntactic sugar
10:26:49 <mux> this makes me remember there's a scheduled talk at ICFP'09 on an n-ary ZipWith function in haskell, without dependent types, and without Applicative
10:26:52 <Philippa> beelsebob: I'm pretty sure it's essentially that or minor tweaks such as monad comprehensions
10:26:52 <beelsebob> that would be *no* syntactic sugar
10:27:04 <taggadtyp> so i have some understanding of monads, monoids, typeclasses, functors, ADTs, newtype. have written a few bigger programs. have used parsec,quickCheck,Coq. is there something about haskell i havent learned?
10:27:09 <Berengal> I find it's sometimes useful to think of monads as monoids...
10:27:16 <beelsebob> Philippa: I have a suspicion that be notation would actually be very similar to do notation, but backwards
10:27:17 <jmcarthur> taggadtyp, always
10:27:18 <hatds> beelsebob: yea, it wouldn't be as nice but it wouldn't be horrible
10:27:20 <beelsebob> i.e. in the same order as (.)
10:27:23 * mux waves goodbye and leaves
10:27:46 <beelsebob> (yes, this would be horrible for IO, but probably quite nice for other monads)
10:27:53 <Philippa> beelsebob: yeah, I sort of don't object to that per se on grounds of taste, but... mostly, I don't have grounds to care. If order's irrelevant, it's irrelevant
10:27:59 <Berengal> beelsebob: Well, there's always arrows...
10:28:12 <Gracenotes> :o
10:28:12 <jmcarthur> beelsebob, there's (=<<)
10:28:14 <hatds> taggadtyp: concurrency?
10:28:21 <Philippa> I dunno. I probably do have occasional uses for it still
10:28:22 <beelsebob> jmcarthur: yeh, I tend to write a *lot* of my monadic code like that
10:28:25 <vininim> if you can't write point-free monad composition, you can go back to Java! Just saying...
10:28:29 <Philippa> but they're not anything I'd want to complain about
10:28:33 <Philippa> and yeah, =<< is nice
10:28:36 <beelsebob> but it would be nice to have a syntactic sugar for that pattern
10:28:56 <taggadtyp> jmcarthur: sure but something bigger
10:28:56 <taggadtyp> obv i have loads to improve but is there soem corner of haskell i haven't explored?
10:29:05 <Philippa> vininim: that doesn't make it a good idea to use it in a given circumstance, though
10:29:09 <beelsebob> taggadtyp: almost certainly, yes
10:29:17 <mauke> print x <- x/ =<< getLine
10:29:31 <jmcarthur> taggadtyp, how about strictness and non-strictness? played with it much?
10:29:32 <beelsebob> mauke: print =<< getLine you mean?
10:29:36 <vininim> Philippa: don't feed me =D
10:29:41 <Philippa> if you're too obsessed with form to convey the right intuition, you can go write in SKI. Just sayin'
10:29:51 <mauke> yes, but with an explicit adbmal
10:30:02 <kyevan>  /opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_lang_ghc/work/ghc-6.10.1/ghc/stage1-inplace/libexec/ghc <bunch-of-flags-removed> -c main/GHC.hs -o dist-stage2/build/GHC.p_o -ohi dist-stage2/build/GHC.p_hi
10:30:10 <kyevan> I think that means it's getting close to done...
10:30:16 <kyevan> Or, at least, I *hope* so :P
10:31:09 <beelsebob> Philippa: I think there's a lot to be gained by being obsessed with form â programming after all is not only about expressing a correct solution, but also about making one someone else can understand
10:31:33 <Philippa> beelsebob: "to convey the right intuition"
10:31:34 <beelsebob> one of the main advantages of FP is that it lets you hide details like what order you do stuff in
10:31:50 <beelsebob> (or don't do stuff in, as is the case with many monads)
10:32:07 <beelsebob> Philippa: yeh, which is why applicative works so well for parsers
10:32:19 <beelsebob> it conveys a good intuition, because it's essentially just typing out the BNF
10:32:25 <Philippa> *nod*. I'd still like an applicative do for occasions where it doesn't
10:32:32 <beelsebob> yep
10:32:48 <Philippa> of course, that goes back partly to the argument we had years ago about building an explicit CST first
10:32:52 <beelsebob> ditto monadic be for occasions where do is totally not appropriate
10:33:06 <beelsebob> not sure I remember
10:33:11 <Philippa> honestly? I don't run into many of those, so long as you understand what do actually is
10:33:11 <Gracenotes> ditto wha :o
10:33:12 <Berengal> Philippa: What would an applicative do look like?
10:33:26 <Gracenotes> an applicative do would probably be as notated in the paper
10:33:27 <jmcarthur> applicative do? what would that be?
10:33:38 <Gracenotes> [[ (func) (arg1) (arg2) (arg3) ]]
10:33:43 <beelsebob> Philippa: that's the problem though â "do x y z" is in *no* way a conveying a "good intuition"
10:33:45 <Philippa> Berengal: exactly like the current one, except it desugars into <*> and *> (or other direction) and <$> for the last line
10:33:46 <Berengal> Ah
10:33:49 <Gracenotes> liftAn
10:34:00 <beelsebob> the intuition of "do x y z" is that it would "do" exactly what the verb says
10:34:04 <beelsebob> do x, then y, then z
10:34:12 <vixey> , [$i| (,) "abc" "xyz" |]
10:34:17 <lunabot>  [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('...
10:34:25 <Gracenotes> ah!
10:34:30 <Philippa> beelsebob: *sigh*. Yes, if you're incapable of understanding that occasionally english words are being used in unusual ways. Like, say, 'map
10:34:33 <Philippa> '
10:34:34 <Gracenotes> except you also need to provide for *>
10:34:39 <Philippa> or fold, zip, ...
10:34:55 <jmcarthur> , [$i| (,) (Just 5) (Just "hey) |]
10:34:57 <lunabot>  luna: applicateQ fails.
10:34:58 <Gracenotes> perhaps there is someway to make it non-explicit. Perhaps,,, subgroups? After all, applicatives can be composed nicely.
10:35:10 <beelsebob> Philippa: yeh, but those 3 are used in cases where the obvious intuition doesn't hold, and there *is* another intuition available once you understand it
10:35:11 <jmcarthur> oh, it's for zipping
10:35:17 <Philippa> as soon as you can get past that, the notation is appropriate for a good many cases
10:35:20 <kyevan> Oooh, ooh, ld is running, ld is running! :P
10:35:25 <beelsebob> do on the other hand is in a place where there is an incorrect intuition available
10:35:26 <vixey> , [$i| (,) (Just 5) (Just "hey") |]
10:35:28 <lunabot>  Just (5,"hey")
10:35:29 <hatds> speaking of which, is there a composed applicative type defined anywhere?
10:35:29 <beelsebob> and there's no correct one
10:35:42 <beelsebob> hatds: TypeCompose I think
10:35:43 <Gracenotes> hatds: in the paper
10:35:43 <Philippa> 'do' at least offers an intuition that extends into that
10:35:46 <jmcarthur> wait, what did i do wrong?
10:35:55 <beelsebob> Philippa: is it?
10:36:01 <beelsebob> does it rather
10:36:10 <beelsebob> what intuition?
10:36:33 <beelsebob> it doesn't even work particularly well for the IO monad
10:36:37 <hatds> Gracenotes: is it defined in the standard libraries though?
10:36:41 <beelsebob> it makes people think that the things you write will be executed in order
10:36:52 <beelsebob> and then people get bitten by file handles being open for ages
10:36:59 <Philippa> which they will. Things like readFile use explicit magic
10:37:10 <beelsebob> Philippa: no they don't â they are lazy
10:37:12 <beelsebob> like the rest of haskell
10:37:14 <Philippa> it's the operations in the IO monad that're strange and magic
10:37:23 <Philippa> beelsebob: unsafeInterleaveIO
10:37:28 <Berengal> beelsebob: IO is strict, unlike the rest of haskell
10:37:32 <Philippa> that's /exactly/ how they work
10:37:37 <tombom> , [$i| (,) (Just 5) (Just "hey") |]
10:37:39 <lunabot>  Just (5,"hey")
10:37:45 <Berengal> Which is why unsafeInterleaveIO is unsafe
10:37:48 <tombom> you missed a " off hey
10:37:51 <beelsebob> Berengal: which is why people get bitten by file handles being open for ages ;)
10:38:01 <Gracenotes> hatds: the instance would be for a newtype Comp f g a = Comp (f (g a))
10:38:06 <vininim> , [$i| (+) (Just 5) (Just 4)|]
10:38:08 <lunabot>  Just 9
10:38:08 <Gracenotes> not defined anywhere in the libraries, I think
10:38:15 <Philippa> the IO operations themselves happen /exactly/ in order. The operations you mention explicitly say "let me be a lying bastard and do impure stuff to generate this 'pure' value"
10:38:15 <Gracenotes> the requirement is that f and g are applicatives too
10:38:20 <beelsebob> so maybe what I'm saying is do works precicely for strict monads where you actually want to see sequencing
10:38:24 <beelsebob> and no where else
10:38:25 <vininim> , [$i| (+) (Just 5) Nothing |]
10:38:27 <lunabot>  Nothing
10:38:27 <arkim>  how many ways can you pair up 2 natural numbers at a time so that final sum is N ? after pairing up replace the pair by the sum of pair
10:38:58 <Berengal> beelsebob: Naw, I've found do notation useful when doing nondeterministic computations in the list monad as well
10:39:05 <Philippa> except that you still get the exact sequencing that the 'language' of the monad supports
10:39:06 <Berengal> Makes it look like prolog
10:39:09 <beelsebob> Berengal: got a good example?
10:39:15 <beelsebob> I'd be interested to see
10:39:17 <Philippa> *nod* - similar for deterministic logic programming here
10:39:18 <vininim> , [$i| (+) (,) (Just 5) (Just 4) |] -- heh
10:39:19 <lunabot>  luna: parse error (possibly incorrect indentation)
10:39:27 <beelsebob> Philippa: yes, but it's often not a sequence you want to see
10:39:38 <beelsebob> parsers again â you want to describe the language
10:39:41 <beelsebob> not the order you read it in
10:39:42 <vininim> wat
10:39:48 <Philippa> that depends on what you're parsing
10:39:50 <vininim> , [$i| (+) (,) (Just 5) (Just 4) |]
10:39:52 <lunabot>  luna: Couldn't match expected type `a1 -> a -> (a1, a)'
10:40:00 <Gracenotes> , [$i| (,,,,) (Just 1) (Just 2) (Just 3) (Just 4) (Just 5) |]
10:40:02 <lunabot>  Just (1,2,3,4,5)
10:40:04 <Berengal> beelsebob: http://echochamber.me/viewtopic.php?f=11&t=35369
10:40:05 <vixey> lol
10:40:06 <Philippa> for the class of languages that need a monadic parser, you do want to
10:40:15 <beelsebob> Philippa: sure
10:40:17 <Berengal> Just scroll down until you start seeing haskell
10:40:20 <beelsebob> but that class of language is rare
10:40:25 <Gracenotes> , [$i| (+) (+1) (+2) |] 1000
10:40:28 <lunabot>  luna: A section must be enclosed in parentheses thus: (+ 1)
10:40:36 <beelsebob> CF languages are by far the most common
10:40:36 <Gracenotes> wha
10:40:41 <Gracenotes> , [$i| (+) (+ 1) (+ 2) |] 1000
10:40:41 <vixey> Berengal you can see my unification code if you like
10:40:43 <lunabot>  luna: A section must be enclosed in parentheses thus: (+ 1)
10:40:49 <Gracenotes> but but... :_:
10:40:52 <copumpkin> is there any type system that could allow the omega combinator?
10:40:53 <kyevan> Mmm, quick off-topic question: Does anyone know a way to do something like ps, but only listing child processes of some other process?
10:40:59 <Berengal> vixey: Sure, unification is nice
10:41:17 <Philippa> beelsebob: sure. And if you have a CF language, you'd like to express it as such rather than overcommit. Hence my wanting applicative do
10:41:23 <vixey> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=62
10:41:24 <vininim> kyevan: htop can do process tree-view
10:41:26 <vixey> some examples in there too
10:42:03 <beelsebob> Berengal: that is indeed neat â except for the verb do stuck on it
10:42:09 <Philippa> that's a case where really you don't want to be using a monad (as a monad) at all. Especially as the magic to undo the damage is pretty challenging
10:42:11 <Berengal> vixey: Awesome
10:42:30 <Berengal> beelsebob: Well, prolog is strict, and like all strict languages that means everything has a do stuck on it
10:42:52 <Gracenotes> wha
10:42:53 <beelsebob> Berengal: that doesn't mean you want to know about it â note that prolog's syntax doesn't tell you about it
10:43:14 <vixey> "I'll let you draw your own conclusions. Mine is that Prolog and Haskell are awesome, but Haskell needs unification (Erlang has this, I know, and is actually very close to Prolog in several respects, but it lacks backtracking)." -- Check out Silvija Seres work if you like, she's done some very cool stuff in that area
10:43:16 <beelsebob> it's an unimportant detail
10:43:28 <Philippa> er, it's potentially pretty damn important in prolog unfortunately
10:43:39 <beelsebob> that's true actually
10:43:40 <beelsebob> hmm
10:43:43 <Gracenotes> Berengal: strict and do? hm?
10:43:45 <Philippa> and again, honestly? The token is not so big a problem. You just learn what it means in Haskell
10:43:47 <beelsebob> damn, defeated by cut
10:43:59 <Berengal> beelsebob: I'm not sure what's confusing about "do" in this case though. It describes a sequence of computations, done in sequence. The fact that it's not strictly in sequence is a detail left in the monad.
10:44:06 <Gracenotes> I CUT YOU .. in prolog
10:44:10 <Berengal> Okay, that was somewhat badly worded...
10:44:12 <Philippa> it can mean "feed this sequence into an abstract machine that'll munge it in a non-sequence-dependent manner"
10:44:28 <Berengal> What Philippa said
10:44:32 <beelsebob> Berengal: it's a detail that I don't care about when reading your program â instead I want to know "what are the facts that you are defining as happening"
10:44:39 <Gracenotes> you don't need a monad to define seq. although it's not guaranteed to work all the time
10:44:47 * YanLiz_GoKHaN slm
10:44:48 <beelsebob> Philippa: I agree that it's a silly problem â but it's such an easily fixed one too
10:44:51 <Gracenotes> that's just an implementation detail
10:44:57 <Philippa> beelsebob: it is. In a new language.
10:45:03 <beelsebob> Yay, Haskell'
10:45:10 <Philippa> honestly? It's not one I care to fix in a new language either
10:45:22 <Philippa> Haskell' certainly shouldn't rename it. It can add a name if it really wants to
10:45:33 <beelsebob> yep, I would 100% support that
10:45:39 <Philippa> but really? Find me a better name. I don't think 'be' is better, it removes a useful intuition
10:45:41 <copumpkin> Philippa: what's your new language?
10:45:49 <taggadtyp> unification?
10:45:50 <Philippa> copumpkin: unreleased :-)
10:45:54 <taggadtyp> how do you mean?
10:46:04 <Gracenotes> Philippa: sekrit?
10:46:04 <copumpkin> Philippa: now _there_'s something that needs fixing ;)
10:46:11 <beelsebob> Philippa: it removes an intuition that is often not true â so given the choice of the two, you can give the intuition exactly when it's the right one
10:46:12 <Gracenotes> :o
10:46:25 * YanLiz_GoKHaN selam millet :d
10:46:33 <Philippa> copumpkin: I built an untyped strict haskell, because I wanted to do some stuff that was getting to be a PITA
10:46:42 <Philippa> mostly because I had too many related types floating about
10:46:49 <beelsebob> it's completely the wrong intuition for a CF parser â you want to convey that it can happen in any order the parser combinator decides is efficient
10:46:59 <copumpkin> :o
10:47:02 <Philippa> for a CF parser, you *do not want to use a monad*. End of story.,
10:47:08 <beelsebob> indeed
10:47:12 <copumpkin> yup!
10:47:24 <vixey> why Philippa?
10:47:27 <Philippa> sadly, atm you do because the sugar's lacking elsewhere
10:47:30 <Philippa> vixey: it overspecifies
10:47:35 <vixey> I don't see that
10:47:51 <copumpkin> it adds order where there is none?
10:47:52 <Philippa> vixey: Basically, it's join that does it
10:47:53 <beelsebob> vixey: if I specify a CF language in a monad, it constrains be to parsing it forwards
10:47:55 <Berengal> Eh, applicative serves my CF needs perfectly fine
10:48:02 <beelsebob> Berengal: exactly
10:48:05 <Gracenotes> if you want to "translate" EBNF into Haskell, all you need is applicative
10:48:13 <copumpkin> without the ordering, you could have parallel parsing
10:48:23 <beelsebob> also, you can have errors combined
10:48:29 <Gracenotes> and some data structure that corresponds to the structure of a certain rule
10:48:32 <beelsebob> the Either String applicative is *really* nice compared to the monad
10:48:33 <Berengal> I don't think applicative syntax is too bad either...
10:48:39 <beelsebob> because you get to combine error messages
10:48:44 <copumpkin> monads are the devil! they get hyped up so much that once people get them, they use them everywhere :P
10:48:48 <Philippa> vixey: monads allow the computation to be the result of a previous computation. With a CF grammar, this will never happen. Recovering that fact is difficult-to-impossible, and disallows many implementation strategies
10:48:53 <beelsebob> copumpkin: indeed
10:49:07 <Gracenotes> copumpkin: you should write a tutorial how not to understand monads
10:49:10 <copumpkin> lol
10:49:13 <copumpkin> with unicorns? ;)
10:49:16 <beelsebob> Gracenotes: I already did that!
10:49:17 <beelsebob> :P
10:49:24 <vixey> Philippa: monad has well studies theory and works very smoothly with hoare triples -- you're writing the same program in each case though
10:49:26 * copumpkin pets his unicorn analogy
10:49:28 <Philippa> beelsebob: if there isn't a good error applicative/applicativeT yet, are you up to writing one? I agree that it's nice
10:49:35 <Berengal> copumpkin: Unicorns couldn't hurt. neither would burritos I guess ;)
10:49:40 <beelsebob> Philippa: possibly at some point
10:49:40 <Gracenotes> copumpkin: you just need a disturbing illustration now
10:49:45 <SamB> what's the point of a tutorial on how not to understand monads ?
10:49:53 <Philippa> vixey: CF grammars also have well studied theory. You do not want to spec their parsers as monads.
10:49:54 <SamB> does it come with amnesia tips ?
10:49:59 <copumpkin> Gracenotes: I can't draw, but if you can, I'd gladly accept contributions ;)
10:50:00 <beelsebob> SamB: it's about how to understand all the other useful abstraction mechanisms in Haskell
10:50:10 <beelsebob> and realise that monads are not to be used for *everything*
10:50:18 <beelsebob> (even if they are damn useful)
10:50:21 <vixey> Philippa: why don't I? I did this in Coq the proofs work it is fine -- Applicative isn't easier
10:50:29 <copumpkin> just because every layperson who's heard of haskell thinks haskell is all about monads, doesn't mean it is :P
10:50:30 <vixey> there's nothing better about it ..
10:50:38 <Philippa> vixey: hell, the point is that you don't want to actually write 'a program' - you want to write a grammar with data results and plug in a parser as an instance
10:50:51 <SamB> beelsebob: shouldn't that be "How to get over Monads"?
10:50:55 <Philippa> vixey: except the freedom of implementation strategy. All you did was write the obvious applicative
10:51:11 <vixey> "you want to write a grammar with data results" -- like Yacc? No
10:51:14 <beelsebob> SamB: maybe, I wrote mine from the point of view of a beginner setting out on the big scary path of learning monads
10:51:22 <beelsebob> and how they should really learn several other things first
10:51:25 <vixey> I don't implement or verify yacc, I use combinator parsers
10:51:27 <copumpkin> could a non-monadic parser allow the enumeration of strings int the language?
10:51:35 <copumpkin> s/int/in/
10:51:37 <SamB> beelsebob: what about those who already DO undestand monads?
10:51:41 <Philippa> vixey: I don't want to write it 'like yacc', I want to write it like parser combinators. But that's all I want those combinators to specify
10:51:49 <beelsebob> SamB: good question â maybe someone needs to write that tutorial
10:52:01 <wli> X-SAIGA?
10:52:08 <copumpkin> it'd be pretty cool to write applicative parser combinators that allow the generation of all strings in the language
10:52:24 <beelsebob> copumpkin: interesting idea
10:52:31 <Philippa> sadly, in practice you're at least mildly stuck because some idiot went and wrote a once-and-for-all many when it's something some applicatives want to rewrite. But hey
10:53:13 <Philippa> beelsebob: one thing that is true about monads though is that they have an 'architectural' role in a way that other structures don't
10:53:23 <vixey> I still don't know what you lot are saying applicative is better than monad for
10:53:25 <beelsebob> Philippa: I'm not sure I get you
10:53:36 <beelsebob> vixey: (a) not overspecifying (b) writing clearer code
10:53:43 <vixey> neither of those is true
10:53:44 <Philippa> vixey: take the free applicative (perhaps with an added 'many')
10:53:46 <taggadtyp> what should I call it if I implement backtracking in Haskell? it wont be comlete prolog, just facts, rules and backtracking to satisfy queries
10:54:00 <Philippa> vixey: overspecifying is 100% true if you're trying to write for an entire class of parsers
10:54:02 <copumpkin> vixey: it's better at not specifying ordering where there is no inherent ordering
10:54:07 <Berengal> taggadtyp: The list monad :P
10:54:21 <beelsebob> vixey: you're saying that do x <- manyOne digit; return $ read digit is as clear as read <$> manyOne digit?
10:54:26 <taggadtyp> Berengal: huh?
10:54:26 <vixey> say you have this Parsec monad and this Parsec applicative
10:54:47 <vixey> do a <- parseA ; ... ; return (F a ...) = F <$> parseA <*> ...
10:54:49 <Berengal> taggadtyp: The list monad already has backtracking
10:54:54 <Philippa> vixey: well duh. But I also have this homebrew Parser applicative that does things Parsec can't
10:54:55 <vixey> they both order the same way
10:54:55 <SamB> well, there's no advantage to using a Parsec applicative
10:55:08 <copumpkin> except conceptually
10:55:10 <beelsebob> vixey: yes â but one of them constrains the implementation
10:55:11 <taggadtyp> Berengal: oh cool, didn't know
10:55:13 <SamB> unless you use it by just coding for a generic ApplicativeParser interface
10:55:14 <vixey> Philippa: ok that seems substantial, what extra do you do?
10:55:15 <taggadtyp> where is the listmonad?
10:55:23 <Berengal> taggadtyp: It's in the prelude
10:55:51 <Philippa> vixey: you know the whole self-analysing parser combinator schtick? Which you can't do per se with monads?
10:55:58 <vixey> no
10:56:26 <Philippa> vixey: the structure of an Applicative computation is fixed. You can implement it as a coalgebra, with one of the methods being a self-analysis
10:56:34 <Philippa> possibly even just a grammar tree or something
10:56:59 <Philippa> then another method can be 'buildShinyFastParser', which can /use/ that analysis
10:57:31 <copumpkin> is haskell's grammar (minus the indentation) context-free?
10:57:35 <Philippa> (that's also why you don't want the standard definition of Maybe)
10:57:45 <copumpkin> most programming languages I know of aren't
10:57:45 <vixey> I'd put compiling the parser into compile time like yacc style
10:57:59 <NEEDMOAR> :-S
10:58:00 <taggadtyp> > join (*) [(1,2)]
10:58:01 <lambdabot>       No instance for (Num [(t, t1)])
10:58:01 <lambdabot>        arising from a use of `*' at <in...
10:58:02 <Berengal> Philippa: Is this something like 'string "fooa" <|> string "foob"' => (++) <$> string "foo" <*> (char 'a' <|> char 'b') ?
10:58:04 <Philippa> copumpkin: strictly speaking, no - at least, not in one pass.
10:58:06 <taggadtyp> > join (*) [(,2]
10:58:07 <lambdabot>   <no location info>: parse error on input `2'
10:58:09 <taggadtyp> > join (*) [1,2]
10:58:10 <taggadtyp> ?
10:58:10 <lambdabot>       No instance for (Num [t])
10:58:10 <lambdabot>        arising from a use of `*' at <interact...
10:58:18 <copumpkin> > join (*) 6
10:58:18 <vixey> anyway I think people are doing self-analysing parser less than they do parsers which dependent on previous input
10:58:19 <lambdabot>   36
10:58:21 <Philippa> Berengal: you'd be able to do that, yes
10:58:30 <Berengal> Nifty
10:58:42 <Philippa> vixey: if you can do it, you /want/ the self-analysing parser. It parses faster.
10:58:51 * YanLiz_GoKHaN selam millet :)
10:58:59 <Philippa> you might not want the analysis yourself, but you want the faster implementation
10:58:59 <beelsebob> vixey: really?
10:59:06 <beelsebob> you honestly think that people write CS parsers lots?
10:59:13 <taggadtyp> > join [[1,2],[3,4]]
10:59:14 <copumpkin> people do
10:59:15 <lambdabot>   [1,2,3,4]
10:59:20 <Berengal> Philippa: I meant it could do that itself, in case that was unclear
10:59:22 <beelsebob> do you know of *any* computer language or data format that's context sensitive vixey?
10:59:29 <copumpkin> most computer languages are mildly context sensitive
10:59:32 <taggadtyp> kewl
10:59:34 <Philippa> Berengal: that's what I assumed you meant
10:59:42 <taggadtyp> but I dont udnerstand join (*) 6 really
10:59:45 <Berengal> Awesome :)
10:59:45 <beelsebob> copumpkin: really?
10:59:50 <copumpkin> beelsebob: take c for example
10:59:50 <Philippa> beelsebob: IIRC, Haskell's operator setup is if you don't do it in a separate pass
10:59:58 <beelsebob> oh, that's true
11:00:01 <beelsebob> and it's offside rull
11:00:02 <copumpkin> taggadtyp: it applies the same argument twice to the function, in this case... but it does different things
11:00:02 <beelsebob> rule
11:00:15 <beelsebob> but they're both things that are easily done in seperate passes, and neater done that way too
11:00:15 <copumpkin> most computer languages are mostly context free though
11:00:18 <Philippa> and yeah, C has some and C++ has much worse
11:00:21 <copumpkin> yeah, true
11:00:22 <jmcarthur> :t join :: (a -> a -> b) -> a -> b
11:00:23 <lambdabot> forall a b. (a -> a -> b) -> a -> b
11:00:30 <Philippa> beelsebob: agreed, and that's how I did it in practice
11:00:43 <Philippa> though I ended up having to nest monads to avoid building an AST variant datatype
11:00:48 <dolio> copumpkin: I doubt Haskell is context free.
11:00:54 <Philippa> (the latter's a maintenance problem, the former's mostly just a little fugly)
11:00:55 <beelsebob> dolio: it's very close
11:01:01 <copumpkin> if we had applicative parser combinators, it could be parsed by a packrat parser couldn't it?
11:01:12 <Philippa> beelsebob: that said, you can self-analyse large classes of context-sensitivity too
11:01:19 <Philippa> copumpkin: yep
11:01:22 * beelsebob nods
11:01:37 <copumpkin> which is I guess what you mean by not caring about the underlying implementation :P
11:01:51 <beelsebob> copumpkin: yep
11:02:03 <Philippa> exactly. You want to write to an interface, and Applicative admits more instances
11:02:04 <taggadtyp> is guard ~ assert?
11:02:11 <copumpkin> lol
11:02:13 <vixey> no
11:02:16 <beelsebob> with applicative, the programmer doesn't get to see what order you parse in â if I decide it's efficient in this case, I can do it backwards for all the programmer cares
11:02:19 <copumpkin> taggadtyp: no
11:02:20 <copumpkin> :t guard
11:02:22 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:02:29 <copumpkin> @src guard
11:02:29 <lambdabot> guard True  =  return ()
11:02:29 <lambdabot> guard False =  mzero
11:02:44 <Philippa> beelsebob: got time for the architectural thing now?
11:02:51 <taggadtyp> http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
11:02:51 <beelsebob> Philippa: sure
11:02:54 <taggadtyp> ^^ cool article
11:02:56 <taggadtyp> > join [[1,2],[3,4],[5,6]]
11:02:58 <lambdabot>   [1,2,3,4,5,6]
11:02:59 <taggadtyp> is guard ~ assert?
11:03:11 <copumpkin> taggadtyp: that's what my "no" was to :P
11:03:12 <taggadtyp> > join [[[3,4]],[[5,6]]]
11:03:13 <lambdabot>   [[3,4],[5,6]]
11:03:15 <Philippa> okay. Monads are almost completely unrestricted in terms of shape-of-computation (MonadFix is also your friend).
11:03:20 <taggadtyp> > join $ join [[[3,4]],[[5,6]]]
11:03:21 <lambdabot>   [3,4,5,6]
11:03:22 <copumpkin> taggadtyp: but you might sort of see it that way in some contexts
11:03:31 <dolio> > let qualified = 5 in qualified
11:03:33 <lambdabot>   5
11:03:40 <EvilTerran> taggadtyp, in, say, the Maybe monad, it acts in a way similar to assert
11:03:48 <beelsebob> Philippa: yep, except that they don't let you pass around the same "state" to multiple places
11:03:53 <Philippa> that's problematic when you want flexibility of monad implementation, but useful if you want flexibility in terms of what's written through it
11:03:55 <taggadtyp> > let dolio = False in quard dolio
11:03:56 <lambdabot>   Not in scope: `quard'
11:03:59 <Philippa> beelsebob: even that can be built
11:04:00 <taggadtyp> > let dolio = False in guard dolio
11:04:01 <lambdabot>       No instance for (Show (m ()))
11:04:01 <lambdabot>        arising from a use of `show' at <i...
11:04:17 <beelsebob> Philippa: really? I thought that was exactly what arrows gave you that monads didnt
11:04:25 <tromp> > do { x<-"Hi"; guard (isUpper x); return x }
11:04:26 <lambdabot>   "H"
11:04:29 <Philippa> obviously it adds to the signature, but it doesn't change the monadicity
11:04:39 <tromp> not like assert
11:04:41 <beelsebob> true
11:04:44 <Philippa> beelsebob: what arrows give you is a lack of ArrowApply, essentially
11:04:50 <jmcarthur> :t join . join . join . join . join . join . join . join . join . join . join . join
11:04:51 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m (m (m (m (m (m (m (m (m (m a)))))))))))) -> m a
11:05:02 <Philippa> monads need an additional control structure to pump the same internal state somewhere else, but they can still do it
11:05:13 <beelsebob> yeh, okay
11:05:16 <copumpkin> Baby_angeL_man: um
11:05:38 <copumpkin> jmcarthur: that's pretty joined
11:05:48 <Philippa> the essential thing with arrows is that without ArrowApply, the self-analyses have half a hope in hell of ever terminating and can be run without being fed an input they don't need
11:06:28 <Philippa> anyway. That flexibility makes monads suitable for general 'effect-pumping' duty
11:06:37 <beelsebob> true
11:07:11 <Philippa> you use the monad to carry effect range where it's needed, and you know you'll be able to do it. You also know you can still put an ApplicativeT on top if you need it locally - it's just that once you've done it, that layer's lost monadicity
11:07:18 <taggadtyp> so how do I backtrack in the list monad?
11:07:27 <beelsebob> taggadtyp: the list monad does that already
11:07:32 <Philippa> taggadtyp: look at the next item in the list
11:07:33 <vininim> :t join . return
11:07:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
11:07:36 <beelsebob> it returns *all* combinations
11:07:50 <copumpkin> taggadtyp: you may have to rethink what you mean by backtrack :)
11:07:50 <beelsebob> if you want to discard one and backtrack to the next, get rid of it
11:08:26 <Philippa> beelsebob: the existance of monad transformers helps a lot there, as you get a lexically-scoped effect discipline out of it :-)
11:08:42 <Philippa> anyway, does that make sense re architectural role?
11:08:45 <taggadtyp> ah i see
11:08:51 <beelsebob> Philippa: I think that's why I don't see them as the big architectural thing then...
11:08:56 <taggadtyp> that is so cool actually
11:09:03 <beelsebob> I don't see functional programs as things that get effects carried around in them
11:09:04 <taggadtyp> so I did learn something new and cool :P
11:09:10 <copumpkin> :)
11:09:12 <beelsebob> that's dangerously close to global state for me
11:09:27 <Philippa> yeah, you're highly effect-avoidant whereas I like to use monads, amongst other things, to carry ambient info that's going to go largely unchanged
11:09:40 <Philippa> heck, I can even locally place it in a read-only layer
11:10:02 <taggadtyp> how can I stop the backtracking as soon as the condition is met?
11:10:12 <copumpkin> just don't ask for any more of the list
11:10:12 <Philippa> but because you've got transformers, you can drop that everywhere and let only stuff that cares know about it (everything else can just parameterise over that detail)
11:10:21 <Berengal> taggadtyp: By taking the head of the resulting list
11:10:23 <beelsebob> taggadtyp: wrap a head round your peice of logic code
11:11:03 <glguy> taggadtyp, the logict library has support for that
11:11:04 <taggadtyp> Berengal: is it lazy?
11:11:05 <taggadtyp> I mean I want to stop computing as soon as a condition is met, not compoute alla nd then get one
11:11:10 <beelsebob> taggadtyp: of course it is
11:11:11 <beelsebob> it's a list
11:11:12 <Philippa> I'm not saying I don't also end up with large chunks of pure code. But I also write a lot of interpreters and typecheckers, for example. And sometimes I want the interpreter running on top of IO, and sometimes I don't. And sometimes that interpreter interprets user commands. And...
11:11:17 <beelsebob> and it's in haskell
11:11:35 <copumpkin> taggadtyp: most things are lazy unless you explicitly ask them not to be
11:11:42 <Berengal> Things are often way more lazy than they seem at first
11:11:53 <Berengal> At least until you get used to full lazyness
11:12:14 <Philippa> FRP may well teach me to prefer something else in the long run, but this is here now and it works and it's solid and makes a lot of imperativeish tasks nicer
11:12:37 <beelsebob> Philippa: yeh, it's a shame that FRP is anything but "functional" (in the actually works sense)
11:12:48 <beelsebob> it's such a lovely panacea to look forward to
11:13:36 <Philippa> *nod*. In the meantime, Haskell really is the best imperative language in the world
11:13:59 <Philippa> and I never lose the option of pure code - runPure is just return :-)
11:14:00 <Berengal> If only imperative code wasn't usually a drag to write
11:14:34 <Philippa> (or let-in-do, which I'm learning to use more often)
11:14:43 <wli> Rumor has it the other solutions to Project Euler #216 did much the same as I did apart from having faster primality tests in some instances.
11:15:13 <taggadtyp> logic lib?
11:15:15 <Berengal> wli: Did you get your answer?
11:15:22 <wli> Maybe they used probabilistic Rabin-Miller instead of deterministic.
11:15:30 <taggadtyp> beelsebob: are Monads as lazy as anything else?
11:15:41 <wli> Berengal: I wouldn't be able to read the commentary on others' solutions if not.
11:16:02 <Philippa> beelsebob: btw, my typecheckers look a lot like (constraint) logic programs embedded in haskell. In practice, they end up in monads because it becomes the sanest way to bundle everything together
11:16:06 <beelsebob> taggadtyp: yep - don't let the sneeky "do" word decieve you into thinking they're strict
11:16:08 <Berengal> wli: Anyone got it in under a minute?
11:16:28 <Berengal> taggadtyp: Only strict monads are strict
11:16:40 <wli> Berengal: Yes. For whatever reason theirs didn't take 10 days even though using similar (or the same) methods.
11:16:50 <beelsebob> Philippa: seeeeee, told you that do word made people think monads enforced more order than they do :P
11:16:50 <Philippa> but I want eg error logging coming back out of those too. You can see how the architecture starts to fit? It's great for instrumentation
11:16:52 <copumpkin> lazy monad is lazy
11:17:05 <taggadtyp> is there a logic module in the std lib?
11:17:15 <Philippa> beelsebob: oh, I know it does. But not half as much as not having thought enough about laziness enough to realise >>= doesn't
11:17:17 <wli> Berengal: They probably used probabilistic Rabin-Miller and bitmaps instead of queues and so on.
11:17:40 <Berengal> wli: I might have to take a look at it myself. Haven't done PE in a while...
11:17:40 * Philippa accepts a prize from the department of redundancy department
11:17:55 <beelsebob> Philippa: yeh, true, but =<< wins for that
11:18:04 <Philippa> taggadtyp: monads aren't magic
11:18:05 <beelsebob> =<< looks like a normal function transformer
11:18:21 <Philippa> beelsebob: yeah, except you probably learned what it means as ">>=, backwards"
11:18:22 <beelsebob> join wins for that too
11:18:31 <beelsebob> Philippa: yeh, which is such a shame :(
11:18:34 <SubStack> Philippa: they are however indistinguishable from magic
11:18:35 <copumpkin> I much prefer =<< to >>=
11:18:45 <Philippa> SubStack: sadly not true here
11:18:49 <Berengal> I like my <=<
11:18:54 <beelsebob> Berengal: yep
11:18:58 <wli> Berengal: Basically the laziness affairs etc. did not work in my favor.
11:19:02 <taggadtyp> man
11:19:06 <beelsebob> it took a *long* time before I discovered <=<
11:19:10 <beelsebob> and it's beautiful
11:19:11 <taggadtyp> that was awesome
11:19:20 <copumpkin> Berengal: can you give me a real use of <=< and >=> ? I can write functions that use them, but they're contrived
11:19:31 * Philippa contemplates rewriting some of her logic code using <*>
11:19:33 <beelsebob> copumpkin: the exact same use of (.)
11:19:48 <beelsebob> <=< is monadic (.), =<< is monadic ($)
11:19:50 <copumpkin> it looks just like a compose, with monads tacked on
11:19:51 <copumpkin> yeah
11:19:52 <wli> Berengal: I think there may have been some theorem that if 2*n^2-1 is composite that at least one prime congruent to +/-1 mod 8 divides it.
11:20:06 <copumpkin> but I couldn't think of a case where I've needed to compose monadic functions
11:20:09 <copumpkin> but maybe I should think harder
11:20:22 <mauke> random question: can you write a Haskell library with a C interface and then use the FFI to call that from a Haskell program?
11:20:25 <beelsebob> copumpkin: how about every single piece of do notation that looks like this...
11:20:35 <Philippa> copumpkin: there're always cases where you could usefully do so
11:20:48 <beelsebob> do b <- f a; c <- g b; d <- h c....
11:20:53 <Philippa> beelsebob: a lot of it I'd prefer to use >=>, but hey
11:20:58 <copumpkin> oh
11:21:01 <beelsebob> aka h <=< g <=< f =<< a
11:21:07 <copumpkin> nice
11:21:12 <copumpkin> okay, I'm a convert
11:21:33 <Philippa> beelsebob: nearly. =<< doesn't belong
11:21:39 <beelsebob> oh, neither it dos
11:21:40 <beelsebob> does*
11:21:41 <beelsebob> fail
11:21:44 <jmcarthur> :t (<=<)
11:21:46 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
11:21:47 <copumpkin> I got the idea :)
11:21:49 <beelsebob> type checker ftw!
11:22:00 <Philippa> yeah, definitely
11:22:08 <Berengal> :t (<<<)
11:22:09 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
11:22:24 <copumpkin> you can do it with that too, but you need to wrap it in Kleisli
11:22:30 <Berengal> Yeah
11:22:36 <copumpkin> I propose renaming Kleisli to K
11:22:44 <copumpkin> :P
11:22:47 <beelsebob> I thought K* was a common name for it
11:22:50 <Philippa> beelsebob: FWIW, I see use of Reader as a good idea where it fits and I don't know if you do?
11:23:06 <Philippa> beelsebob: K* is two tokens
11:23:11 <beelsebob> hehe
11:23:21 <beelsebob> Philippa: I don't know readers well it's one of many many things on my Haskell to do list
11:23:23 <hatds> mauke: I believe so.  I've never done it, but haskell provides a way to initialize and close the haskell run time system from C
11:23:32 <Berengal> I also propose renaming runKleisli to rK or something like that
11:23:50 <Philippa> beelsebob: they're basically the 'lexical environment monad' - a subset of what state monads do
11:23:59 <beelsebob> oh, neat
11:24:03 * Baby_angeL_man uyusunda buyusun nenniiii eeee sizee eee eee eee :)
11:24:08 <copumpkin> Berengal: yeah, then they might even be fun to use!
11:24:10 <taggadtyp> but is there some way to do querying easily? like: fact mother philippa copumpkin; rule mother a b -> child b a; child? copumpkin philippa -> True
11:24:10 <beelsebob> and yeh, then I can definately see how <=< works well there
11:24:15 * Baby_angeL_man uyumayÄ±n beaaaaaaaaaaaaaa ::P
11:24:20 <copumpkin> can someone get rid of Baby_angeL_man?
11:24:23 <Berengal> copumpkin: I might have to learn what arrows are all about!
11:24:38 <wli> I think if 2*n^2-1 is divisible by a prime p then that implies 2 is a quadratic residue mod p and so p is congruent to +/-1 mod 8, but I seem to have hit counterexamples to this.
11:24:47 <copumpkin> taggadtyp?
11:24:48 <Philippa> yeah. So if you have a program that at top level is systolic and then pumps a per-pump-constant config through a pile of pure code, it makes sense for most of that pure code to be in a reader
11:24:56 <copumpkin> taggadtyp: oh, you want a prolog in haskell? it's been done
11:25:03 <taggadtyp> hes playign with arrows
11:25:05 <taggadtyp> eee
11:25:27 --- mode: ChanServ set +o mauke
11:25:28 --- mode: mauke set +b *!*@85.109.175.28
11:25:28 <taggadtyp> > let eee = (***) in (+3) eee (+4) $ 5
11:25:29 <lambdabot>       Overlapping instances for Show ((b, b') -> (b, c'))
11:25:30 <lambdabot>        arising from...
11:25:35 <taggadtyp> > let eee = (&&&) in (+3) eee (+4) $ 5
11:25:36 <lambdabot>       Overlapping instances for Show (b -> (b, c'))
11:25:36 <lambdabot>        arising from a use...
11:25:41 <Philippa> once you've done that, adding local reader layers comes naturally, no? :-)
11:25:44 <Berengal> beelsebob: Reader is the function monad
11:25:56 <EvilTerran> > let eee = (&&&) in (+3) `eee` (+4) $ 5
11:25:58 <lambdabot>   (8,9)
11:26:03 <Philippa> right, reader = implicit parm
11:26:09 <taggadtyp> > let eee = (***) in (+3) eee (+4) $ 5
11:26:09 <taggadtyp> > let eee = (***) in (+3) `eee` (+4) $ 5
11:26:11 <lambdabot>       Overlapping instances for Show ((b, b') -> (b, c'))
11:26:11 <lambdabot>        arising from...
11:26:11 <Berengal> Every monadic value is a function, and every value sequenced get the same argument as everything else
11:26:11 <lambdabot>       No instance for (Num (b, b'))
11:26:11 <lambdabot>        arising from the literal `5' at <i...
11:26:16 <taggadtyp> > let eee = (&&&) in (+3) `eee` (+4) $ 5
11:26:18 <lambdabot>   (8,9)
11:26:25 <vixey> monadic value is a function -- ??
11:26:28 --- mode: mauke set -o mauke
11:26:35 <Philippa> beelsebob: most of the side-effects I "pass" are similarly tame - error logging, maybe backtracking
11:26:36 <vixey> oh you're talking about reader specifically
11:27:15 <mholub> Hi.. Can anyone show me non-monadic (old) "hello, world" in haskell? For example, what was "hello, world" haskell program in haskell 1.0?
11:27:51 <copumpkin> wow, I'm really enjoying <=< now that I'm playing with it more
11:28:09 <hatds> is this when "all haskell programs had type String->String" ? (I don't know anything about old haskell)
11:28:19 <Philippa> mholub: hello world's not a good choice of examples for a number of reasons - getChar >>= putChar would be better to ask for. And I'm afraid I never used versions that early
11:29:07 <Philippa> hatds: it was more powerful than that, thankfully. But IIRC it was more or less a CPSed [InputEvents] -> [OutputEvents]
11:29:09 <Asztal> I seem to remember reading that there was a main :: [Request] -> [Response], but I can't remember where
11:29:11 <Berengal> Purely guessing, but I think it was something like 'main _ = [Print "Hello world"]'
11:29:14 <dolio> It would be something like "main resps = [PutStrLn "Hello, world."]"
11:29:16 <taggadtyp> hy doesnt join Just 5 return 5?
11:29:16 <taggadtyp> @type (<=<)
11:29:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
11:29:28 <dolio> Unless you used the continuation-based combinators, in which case it'd look a lot like monads.
11:29:35 <Philippa> taggadtyp: because join isn't runMaybe
11:29:45 <Philippa> it only works when there's two or more layers
11:30:06 <Philippa> @type join
11:30:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:30:32 <copumpkin> is there an (m (), m ()) -> m () that works like sequence?
11:30:43 <vixey> taggedtyp: type error
11:30:44 <EvilTerran> ?type uncurry (>>)
11:30:44 <Berengal> uncurry (>>) ?
11:30:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a, m b) -> m b
11:30:52 <copumpkin> or maybe more generally (m a, m b) -> m (a, b)
11:31:06 <EvilTerran> ?type liftM2 (,)
11:31:07 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:31:12 <copumpkin> EvilTerran: nice :)
11:31:45 <Berengal> Or applicative style: (,) <$> ma <*> mb
11:32:02 * EvilTerran wishes ,s could be used in operator names, so he could call that <,>
11:32:20 <Berengal> Would be nice...
11:32:22 <EvilTerran> i guess <&> works
11:35:28 * wli has yet to find a counterexample.
11:36:21 <endofjelly> @hoogle [Maybe (m a)] -> m [Maybe b]
11:36:22 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:36:22 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
11:37:22 <taggadtyp> main :: SPJ -> Binary
11:37:38 <taggadtyp> main :: Slap -> Binary
11:38:22 <EvilTerran> endofjelly, i suspect that would need at least two standard functions
11:39:18 <endofjelly> EvilTerran, yeah... I built it together with forM, a case expression and return, but...
11:39:29 <endofjelly> it's verbose
11:39:31 <EvilTerran> ?type sequence . catMaybes
11:39:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [Maybe (m a)] -> m [a]
11:39:45 <endofjelly> EvilTerran, no, the problem is, I don't want to discard Nothing
11:39:46 <Asztal> > let (<&>) = liftM2 (,); a <&&> b = a >>= \x -> (,,) (fst x) (snd x) <$> b in [1,2] <&> [3,4] <&&> [5,6]
11:39:47 <lambdabot>   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
11:39:50 <EvilTerran> ah
11:40:25 <endofjelly> EvilTerran, doesn't matter, I'll leave it like that
11:40:35 <seliopou> endofjelly, did you mean for the return type involve an 'a' instead of a 'b'
11:40:36 <seliopou> ?
11:40:49 <endofjelly> seliopou, nope
11:41:03 <endofjelly> wait
11:41:04 <endofjelly> yes 8)
11:41:08 <endofjelly> @hoogle [Maybe (m a)] -> m [Maybe a]
11:41:09 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:41:09 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
11:41:18 <endofjelly> still doesn't help
11:41:26 <seliopou> endofjelly, you just totally messed with my world view :P
11:41:31 <endofjelly> seliopou, heheh
11:41:36 <endofjelly> sorry
11:42:18 <EvilTerran> endofjelly, so you'd want [Nothing, Just m] -> do x <- m; return [Nothing, x] ?
11:42:19 <seliopou> :t sequence . (fmap sequence)
11:42:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
11:42:26 <seliopou> eh, not quote
11:42:28 <seliopou> quite
11:42:41 <seliopou> :t fmap sequence
11:42:42 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m) => f [m a] -> f (m [a])
11:43:18 <endofjelly> not quite, also :(
11:43:39 <seliopou> Oh wait, wrong sequence
11:43:48 <seliopou> :t fmap Data.Traversable.sequence
11:43:50 <lambdabot> forall (t :: * -> *) (m :: * -> *) a (f :: * -> *). (Functor f, Monad m, Data.Traversable.Traversable t) => f (t (m a)) -> f (m (t a))
11:44:06 <seliopou> :t Data.Traversable.sequence . (fmap Data.Traversable.sequence)
11:44:06 <copumpkin> @type sequence <=< sequence :: [[[a]]] -> [[a]]
11:44:07 <copumpkin> :P
11:44:08 <lambdabot> forall (t :: * -> *) (m :: * -> *) a (f :: * -> *). (Data.Traversable.Traversable t, Monad m, Data.Traversable.Traversable f) => f (t (m a)) -> m (f (t a))
11:44:08 <lambdabot> forall a. [[[a]]] -> [[a]]
11:44:16 <seliopou> right?
11:44:19 <EvilTerran> ?type let go [] = return []; go (Nothing:ms) = (Nothing:) <$> go ms; go (Just m:ms) = ((:).Just) <$> m <*> go ms in go -- endofjelly, does this have the semantics you want?
11:44:20 <lambdabot> forall (m :: * -> *) a. (Applicative m, Monad m) => [Maybe (m a)] -> m [Maybe a]
11:44:44 <endofjelly> EvilTerran, looks good
11:45:03 <endofjelly> but, in fact, so does seliopou's
11:45:16 <jmcarthur> :t Data.Traversable.sequence <=< Data.Traversable.sequence
11:45:17 <lambdabot> forall a (t :: * -> *) (m :: * -> *). (Monad m, Data.Traversable.Traversable t) => t (m (m a)) -> m (t a)
11:45:20 <endofjelly> or does it?
11:45:28 --- mode: ChanServ set +o mauke
11:45:28 --- mode: mauke set -b *!*@85.109.175.28
11:45:33 <endofjelly> yeah I think it does
11:45:34 <seliopou> I think it does...
11:45:48 <endofjelly> seliopou, not bad. thanks
11:45:50 <seliopou> f = [], t = Maybe, m = m
11:45:54 <seliopou> np :)
11:45:55 <endofjelly> sequence . (fmap sequence)
11:45:56 <endofjelly> wow %)
11:46:00 <jmcarthur> :t Data.Traversable.sequence . fmap join
11:46:01 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Data.Traversable.Traversable f) => f (m (m a)) -> m (f a)
11:46:13 <endofjelly> :t Data.Traversable.sequence
11:46:13 <seliopou> (Just remember to use Data.Traversable :)
11:46:14 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
11:46:17 <EvilTerran> endofjelly, i was just checking i had the right semantics before i tried to do away with the explicit recursion
11:46:24 <endofjelly> I didn't know that sequence
11:46:25 <copumpkin> @type join <=< sequence
11:46:26 <lambdabot> forall a. [[[a]]] -> [a]
11:46:28 --- mode: mauke set -o mauke
11:47:09 <endofjelly> thanks a lot. I'm going home now
11:47:12 <endofjelly> bye
11:49:07 <PeakerWork> @type (>=>)
11:49:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:49:14 <EvilTerran> ?type mapM (maybe (return Nothing) (Just <$>)) -- endofjelly
11:49:15 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [Maybe (f a)] -> f [Maybe a]
11:49:44 <PeakerWork> >=> seems like (>>>) for the Kleisli arrow?
11:50:04 <jmcarthur> i believe so
11:50:15 <BONUS> its exactly that yeah
11:50:17 <EvilTerran> > Data.Traversable.sequence `asTypeOf` maybe (return Nothing) (Just <$>) -- this bit's a Maybe-only version of Traversable.sequence
11:50:18 <lambdabot>       Overlapping instances for Show (Maybe (f a) -> f (Maybe a))
11:50:19 <lambdabot>        aris...
11:50:34 <PeakerWork> ?type mapM (maybe (return Nothing) (liftM Just))
11:50:35 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [Maybe (m a1)] -> m [Maybe a1]
11:50:57 <sinelaw> PeakerWork, Kleisli arrow! you mathematician bastard... :P
11:51:10 <PeakerWork> sinelaw: heh -- its not maths, its a simple arrowization of monads :)
11:51:23 <copumpkin> of course, you then need to runKleisli it too
11:52:08 <PeakerWork> copumpkin: well, its not inside a Kleisli constructor?
11:52:23 <copumpkin> I mean the >>> on Kleisli
11:52:57 <BONUS> > runKleisli (Kleisli (Just . (+3)) >>> Kleisli (Just . (+10))) 3
11:52:59 <lambdabot>   Just 16
11:53:19 <BONUS> (Just . (+3)) >=> (Just . (+10)) $ 3
11:53:24 <BONUS> > (Just . (+3)) >=> (Just . (+10)) $ 3
11:53:25 <lambdabot>   Just 16
11:53:26 <BONUS> w00t
11:53:32 <copumpkin> :)
11:53:36 <PeakerWork> :-)
11:57:03 <roconnor> PeakerWork: GOTO has well defined semantics and can be reasoned about.  It is *programs* that use GOTO that are often hard to reason about.
11:57:05 <mmorrow_> > flip (foldM (flip foldl)) [(+),(*)] 1 [1..4]
11:57:07 <lambdabot>   264
11:57:11 <mmorrow_> > flip (foldM (flip foldl)) [(*),(+)] 1 [1..4]
11:57:12 <lambdabot>   34
11:57:24 <roconnor> PeakerWork: I am making a similar claim about virtual methods
11:57:46 <roconnor> (of course virtual methods are not even close to as terrible as GOTOs)
11:57:48 <mmorrow_> > foldM (flip foldl) 1 [(*),(+),(*),div] [1..4]
11:57:50 <lambdabot>   34
11:57:55 <mmorrow_> > foldM (flip foldl) 1 [(*),(+),(*)] [1..4]
11:57:56 <lambdabot>   816
11:58:02 <mmorrow_> heh
11:58:08 <mmorrow_> > foldM (flip foldl) 1 [div,(*)] [1..4]
11:58:09 <lambdabot>   0
11:58:14 <mmorrow_> > foldM (flip foldl) 1 [(*),div] [1..4]
11:58:15 <lambdabot>   1
11:58:23 <copumpkin> hah
11:58:45 <mmorrow_> > foldM (flip foldl) 1 [(*),div,(+)] [1..4] == foldM (flip foldl) 1 [(+)] [1..4]
11:58:46 <lambdabot>   True
11:58:55 <PeakerWork> roconnor: No, I mean that the entries inside the vtables can have well-defined semantics, just like concrete code. The extra level of indirection does not necessarily reduce the ability to reason about it.
11:59:42 <copumpkin> it makes it a nightmare to reverse engineer though :P
11:59:45 <PeakerWork> roconnor: Indeed it would be nice to remove the ability to create vtables with too "open" semantics -- without removing those that have well-defined semantics, but I think that can only be done with dependent types
12:00:13 <roconnor> PeakerWork: sure, they all implementions of your virtual methods *might* have the same semantics (and ought to).
12:00:54 <roconnor> PeakerWork: but I'm claiming that in the 1990's, this did not generally happen in average C++ code.
12:00:57 <PeakerWork> roconnor: only with dependent types you can enforce that, I think -- so proper use that enforces it by convention is a good idea -- and both type-classes and "good OO" do that.
12:01:30 <PeakerWork> roconnor: Well, "average code" is generally pretty horrible, sure.. But I wouldn't blame the vtables which are a good idea
12:01:37 <Philippa> "good OO" in 90s C++?...
12:02:04 <PeakerWork> roconnor: Without vtables, it'd probably just use uglier conditionals all over the place which are just as hard to reason about, except uglier and less extensible/more error-prone
12:02:28 <Philippa> what's bad is stuff like encoding sum types in objects
12:02:33 <roconnor> PeakerWork: sure, but if average use of virtual methods is pretty horrible, then virtual methods cannot be the source of an alledged improvement in programmer productivity in the 1990's
12:02:42 <p_l> good OO and C++? xD
12:02:56 <Philippa> roconnor: they can if good libraries used them
12:03:22 <PeakerWork> roconnor: was just about to say what Philippa did.. Good libraries may get horrible average coders to use them appropriately and get the boost in productivity
12:03:38 <roconnor> Philippa: that is a fair point.  However I don't think there was good use of virtual methods in popular libraries at that time period
12:03:52 <Philippa> FCVO "good", callbacks?
12:04:01 <roconnor> FCVO?
12:04:07 <Philippa> For Certain Values Of
12:04:09 <PeakerWork> roconnor: I think that even if the semantics weren't completely well-specified and easy to reason about, they were pretty close in most decent libraries
12:04:28 <PeakerWork> roconnor: much better than the uglier conditionals that'd typically be used before
12:04:47 <PeakerWork> roconnor: Also, who says "ease of reasoning about ..." is the only, or even main factor in programmer productivity
12:05:20 <roconnor> I think "ease of reasoning about" is a key factor in maintainability, which is a key factor in developing large systems
12:05:24 <Philippa> it's definitely less scary and easier to work with than the same thing hand-encoded with function pointers
12:05:42 <roconnor> (again I'm specifically thinking about productivity for large software systems in the 1990s)
12:06:21 <Philippa> roconnor: there, they made a big difference in terms of what interfaces could/couldn't do without forcing the coder to use pointers
12:06:22 <endofjelly> EvilTerran, that one's nice
12:06:27 <endofjelly> EvilTerran, concise and readable
12:06:32 <endofjelly> :t (<$>)
12:06:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:06:54 <Philippa> think of them as making 'first class modules' more readily accessible
12:07:17 <roconnor> like what copumpkin said about reverse engineering (which is what maintainers have to do)
12:08:06 <jpcooper> hello
12:08:10 <jpcooper> is there any kind of data type for bags?
12:08:22 <jpcooper> that is, like Maps, but allowing multiple items with the same key
12:08:27 <jpcooper> maybe I don't mean bags at all
12:08:38 <mmorrow_> Map k (Set v)
12:08:51 <jpcooper> mmorrow_, I've been doing this until now
12:09:01 <copumpkin> multiset?
12:09:07 <jpcooper> I was wondering whether there was something that did this for me and would thus make things easier
12:09:10 <copumpkin> or multimap?
12:09:17 <jpcooper> copumpkin, I definitely don't want bags, having looked up the definition
12:09:23 <mmorrow_> M.insertWith, unionWith, intersectionWith for all the containers lib types makes this pretty nice
12:09:49 <PeakerWork> roconnor: I think vtables and nice syntax to create them and restrict them for fairly decent uses adds a lot to productivity while not affecting much the ability to reason about programs in some cases, or improving it in others (by replacing other uglier mechanisms, and/or using proper semantics for vtable methods)
12:10:34 <PeakerWork> roconnor: While vtables were always available and could have been used for ages, OO raised people's awareness of their appropriateness in many situations, which IMO gave a significant productivity boost
12:10:52 <PeakerWork> roconnor: I think OO also raised the average programmer's awareness of the importance of data hiding and preventing abstraction leaks, etc
12:11:00 <roconnor> PeakerWork: I think *proper* use of virtual methods and add a little programmer productivity, but not enough to explain the alledged programmer productivity boom in the 1990s
12:11:11 <PeakerWork> I agree none of these things were *new* in OO, but raising awareness is important
12:11:18 <roconnor> PeakerWork: Encapsulation is the huge benefit
12:11:22 <Philippa> PeakerWork:  yeah. With vtables as the central feature of that form of OO
12:11:26 <roconnor> which was the point of my post
12:11:35 <Philippa> roconnor: yeah, vtables are a necessary counterpart to it though
12:11:43 <roconnor> Philippa: you think?
12:11:50 <mmorrow_> @type M.unionWith Data.Set.intersection
12:11:51 <lambdabot> forall a k. (Ord k, Ord a) => M.Map k (S.Set a) -> M.Map k (S.Set a) -> M.Map k (S.Set a)
12:11:52 <roconnor> I don't know if I believe that.
12:11:58 <mmorrow_> @type M.unionsWith Data.Set.intersection
12:11:59 <lambdabot> forall a k. (Ord k, Ord a) => [M.Map k (S.Set a)] -> M.Map k (S.Set a)
12:12:31 <Philippa> roconnor: do you buy that other encodings available to mainstream programmers at the time were much worse, at least?
12:12:49 <PeakerWork> roconnor: I do think (but am not sure) that encapsulation without vtables forces you to leak abstractions
12:13:15 <roconnor> Philippa: hmm, probably.  I'm not certain though.
12:13:16 <Philippa> PeakerWork: any time you want to separate interface from implementation at runtime
12:13:27 <roconnor> PeakerWork: intrestesting claim.
12:13:35 <PeakerWork> roconnor: I can agree that encapsulation is more important than vtables -- but I think claiming vtables harm the ability to reason about programs is wrong or even silly
12:14:29 <roconnor> PeakerWork: I think virtual methods were a fairly large source of confusing when I was working as a software developer.
12:14:39 <PeakerWork> roconnor: especially when you consider that the dynamic behavior is going to be there anyway, and the question is how that dynamism is achieved.. vtables are probably easier to reason about than ad-hoc conditionals everywhere that break through abstraction boundaries
12:15:18 <Philippa> roconnor: I can well believe it. The question is, how much of that confusing would've been there in another form without them?
12:15:53 <roconnor> Philippa: possibly worse, but probably not much worse.
12:15:55 <duckinator> hi
12:15:59 <Philippa> (and tbh, I consider vtables a shite implementation of first classish functions, but hey)
12:16:26 <PeakerWork> Philippa: I see type-classes as an advanced language mechanism around vtables :)
12:16:27 <Philippa> roconnor: even if the answer's just "the same", vtables at least aren't to blame for it. Next question is: how much did they eliminate?
12:16:46 <PeakerWork> Philippa: and single-dispatch class-based vtables as a sucky language mechanism around vtables
12:16:49 <Philippa> PeakerWork: which are in turn internally encoded as a use of first class functions
12:16:54 <roconnor> Philippa: not enough.
12:17:18 <roconnor> Not enough to explain the alledged increase in programmer productivity for large systems in the 1990s
12:17:31 <Philippa> roconnor: well, they made callbacks viable...
12:17:40 <PeakerWork> roconnor: What is the alleged boost?
12:17:44 <Philippa> instead of something only a systems programmer touched
12:18:35 <roconnor> PeakerWork: Well, it is alleged.  At the moment all I can too is point to the 1990s (or more specifically when "OOP" became a popular development method)
12:18:50 <Philippa> and they allowed two encapsulated things to have different implementations (without screwing with function pointers), which is a massive change in engineering potential even if what you saw on the front lines was often still crap
12:18:54 <roconnor> PeakerWork: if you say there was no boost, I don't think I'll contest you.
12:19:18 <Philippa> also: if we're including Java in our discussed langs, that changes the game rather
12:19:37 <Philippa> it does, I'll grant, put a lot of the boost in the late 90s...
12:19:38 <PeakerWork> roconnor: Are there any alleged numbers or anything?  I have no idea if there was a boost, but I am willing to believe OO boosted average productivity
12:20:26 <roconnor> PeakerWork: the claim was made by someone in a sort of off-the-cuff way
12:20:26 <p_l> PeakerWork: What about RAD? it cerainly boosted productivity of many bespoke developments, no matter what their final quality is... and it really kicked off with OOP
12:20:29 <Philippa> *nod*. Amongst other things, OO gave you a way of thinking about 'things that could have different implementations and you didn't know what'
12:20:31 <PeakerWork> roconnor: I am working with code of someone who slept through the OO thing, and writes real old-style code, encapsulation-free..  He could use a bit of OO knowledge to get a boost :)
12:20:49 <Philippa> p_l: VB wasn't really properly OO for a very long time
12:21:04 <p_l> Philippa: I was thinking of Delphi and Object Pascal
12:21:04 <roconnor> PeakerWork: Oh?  Are there a fair amount of global variables?
12:21:16 <Philippa> p_l: yeah. But they were the also-ran
12:21:29 <Philippa> much better product, sure
12:21:29 <p_l> ?
12:21:37 <PeakerWork> roconnor: yeah, and basically most lines of code know all others.. there are no real boundaries.. the division into modules is really arbitrary.. :(
12:21:41 <Philippa> but VB ran the market
12:22:10 <p_l> Well, I kept away from VB and still try not to touch it (haven't really come into contact with it before .NET)
12:22:13 <roconnor> PeakerWork: Ya see, if he only got encapsulation, but didn't get vtables, I think that code would be 100x better.
12:22:21 <PeakerWork> I think OO's main contribution was just raising awareness of various techniques -- and its time for it to die in peace and for classes to be replaced by type-classes, and later go to FP
12:22:45 <Philippa> PeakerWork: honestly, OO still has some things to teach us about building instances
12:23:00 <PeakerWork> Philippa: can you elaborate?
12:23:13 <PeakerWork> roconnor: I agree
12:23:15 <roconnor> PeakerWork: If you give him vtables, then maybe it would get another 100% better (although I still think it would get 20% worse)
12:23:17 <Philippa> single inheritance is evil, sure...
12:23:18 <Gracenotes> in particular there are some interesting things about how hierarchies of typeclasses should work...
12:24:02 <roconnor> PeakerWork: 20% worse if you give it to *him*
12:24:07 <Philippa> PeakerWork: building instances out of existing instances is a PITA at best. Especially if you want to "do everything the same except..."
12:24:48 <PeakerWork> Philippa: I think implementation inheritance is always bad..   I think you might want to have something like generalized-new-type-deriving that can derive instances that forward to any element of a type product, and not just a single one in a newtype
12:25:13 <Philippa> PeakerWork: in other words, "please inherit"
12:25:38 <PeakerWork> roconnor: I understand - but I think he's a smart guy (his code works, and to get really horrible code to work, you have to be pretty smart), and if had it taught to him properly..
12:25:40 <Philippa> what's bad is always-on inheritance
12:26:08 <Philippa> also, newtype deriving isn't enough if you've got some sodding big signature and you only want to've changed a couple of functions
12:26:28 <PeakerWork> Philippa: by big signature, you mean a big type-class?
12:26:48 <Philippa> PeakerWork: as in lots of methods, yes
12:27:09 <seliopou> invariably, somebody slips ML modules into the conversation
12:27:10 <PeakerWork> Philippa: well, I am not convinced it should ever really happen -- most type-classes are pretty tiny in practice
12:27:12 <seliopou> freudian
12:27:28 <PeakerWork> Philippa: and if you do have a large type-class, why would it make sense to only override part of it, if the whole is conceptually "one"?
12:28:01 <Philippa> PeakerWork: because that's the change being made?
12:28:35 <Philippa> (also, it's not much better if you're having to list 50 different derivations instead)
12:28:56 <Gracenotes> the issue also is being able to treat a sub-typeclass in the place of its parent
12:29:09 <Gracenotes> wwhether this should be allowed or not, and the mechanism.
12:29:12 <PeakerWork> Philippa: I agree it typically happens with OO code, but I don't think it typically happens with type-class/Haskell code
12:29:33 <PeakerWork> Gracenotes: Just explicitly "up-cast" by selecting the member
12:29:37 <PeakerWork> Gracenotes: is that what you mean?
12:29:40 <Philippa> PeakerWork: I've had occasions. Granted, they've tended to be when encoding first-class modules and other such activities, but I've had them
12:30:16 <Philippa> it's also the sort of thing that can readily come up if you're doing something like game programming and you've just got a domain that's Like That
12:30:19 <Gracenotes> PeakerWork: well. I mean, all instances of the subclass are automatically instances of the parent class
12:30:26 <PeakerWork> Philippa: When encoding a first-class method, why use a type-class and not a record of functions? (I'm really asking, I haven't done much of that)
12:30:51 <PeakerWork> Philippa: maybe its an indication that you've not properly divided your domain into sub-domains that can be overridden independently?
12:31:01 <PeakerWork> s/you/forall you. you
12:31:09 <Philippa> PeakerWork: because you may want to 'be quiet about it' any time the use isn't inherently first-class
12:31:30 <dolio> http://hackage.haskell.org/packages/archive/gmap/0.1/doc/html/Data-GMap.html
12:31:37 <PeakerWork> Philippa: you mean, let the compiler auto-select the instance?
12:31:41 <Philippa> I rather believe I'm saying "fuck the subdivision". It's just as painful if you have 100 different records
12:31:45 <Gracenotes> PeakerWork: an the issue particularly is that, since records cannot inherit from each other, the dictionaries can't be considered compatibly without splicing like you have in C++
12:31:46 * mmorrow_ was just amused by realizing that ==> id = (unsafeCoerce unsafeCoerce) :: a -> a
12:31:47 <Philippa> PeakerWork: and pipe it around, and...
12:31:54 <Gracenotes> ugh. typos.
12:32:24 <Philippa> PeakerWork: there's an awful lot of lambdas and applications generated in the core from typeclass use
12:32:29 <PeakerWork> Philippa: all the piping around is in code that's generic about it anyway, so specifying Blah a => ...  or BlahFuncs a -> ...  shouldn't be that different?
12:33:05 <Philippa> PeakerWork: the latter needs an accompanying lambda and accompanying passing
12:33:37 <Philippa> remember, your functions are generally supposed to call other functions. They may well need these funcs too
12:33:39 <PeakerWork> Philippa: just an extra arg?
12:34:02 <vixey> unsafeCoerce = unsafeCoerce unsafeCoerce = ...
12:34:04 <Philippa> PeakerWork: a lot more than that if you've got subclasses etc involved
12:34:25 <mmorrow_> unsafeCoerce /= (unsafeCoerce unsafeCoerce :: a -> a)
12:34:36 <mmorrow_> unsafeCoerce :: a -> b
12:34:46 <vixey> huh?
12:34:51 <vixey> > unsafeCoerce 4 :: Integer
12:34:52 <vixey> 4
12:34:53 <lambdabot>   Not in scope: `unsafeCoerce'
12:35:04 <mmorrow_> i mean in the sense that `id' isn't unsafeCoerce
12:35:11 <dolio> id = unsafeCoerce :: a -> a
12:35:14 <Philippa> PeakerWork: it's quite possible to end up with code with more dictionary-passing boilerplate than real code
12:35:23 <mmorrow_> dolio: ahah, i'm retahded
12:35:29 <Gracenotes> it seems so
12:36:04 <Gracenotes> actually, I wonder if that'll work for any two sufficiently unified types... or am I speaking nonsense
12:36:20 <Philippa> remember, haskell doesn't have (pleasant) extensible records
12:36:40 <Gracenotes> let u :: Num a => a -> Int; u = unsafeCoerce in u 2910
12:36:47 <Gracenotes> yields 2910
12:37:10 <mauke> @src Int
12:37:11 <lambdabot> data Int = I# Int#
12:37:13 <mauke> @src Integer
12:37:13 <lambdabot> data Integer = S# Int#
12:37:13 <lambdabot>              | J# Int# ByteArray#
12:37:14 <Gracenotes> the other way around too
12:37:33 <Gracenotes> oh... right. it forces it
12:37:37 <Botje>  is that Small and Jumbo?
12:37:42 <Gracenotes> that tricky ghci and its defaults!
12:37:44 <Botje> why no Medium Integers? :D
12:37:59 <Gracenotes> but anyway, the type signature where something is unified seems to work
12:38:30 <Gracenotes> oops. segfault.
12:38:39 <mauke> Botje: Simon and Jones. the | is pronounced "Peyton"
12:39:09 <Philippa> PeakerWork: another form of inheritance it's very easy to want, btw, is inheritance through some flavour of lifting function...
12:39:18 <Gracenotes> mauke: ...serious?
12:39:26 <Botje> mauke: oh, of course :)
12:42:56 <Gracenotes> "S# | J#"... it could be a Haskell fan shirt. Right along with zygohistomorphic prepromorphisms
12:42:59 <Gracenotes> :/
12:44:13 <gwern> we need to write a paper on zygohistomorphic prepromorphisms
12:44:16 <gwern> make them real
12:44:19 <mauke> Peyton `Simon` Jones
12:44:30 <Zao> Surely you mean `simon` ?
12:44:34 <gwern> @quote Peyton.*Simon.*Jones
12:44:34 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
12:44:34 <mauke> no
12:44:40 <Zao> Or can you `` ctors?
12:44:44 <mauke> yes!
12:44:44 <Philippa> Zao: yep
12:44:49 <Zao> Eew :)
12:44:51 <Gracenotes> at least non-: ones
12:44:55 <gwern> I think I *have* seen constructors used in `` before
12:45:03 <copumpkin> yeah
12:45:08 <mauke> (the original form of that joke was Peyote `Simon` Joints, AFAIK)
12:45:12 <Gracenotes> some people define Cons to be infix sometimes
12:45:15 <Philippa> it's actually quite nice for eg Val 1 `Plus` Val 2
12:45:17 <Asztal> I've seen `O`
12:45:23 <Gracenotes> I've seen :OOO
12:45:39 <Gracenotes> okay, I can't vouch for that one.
12:46:11 <zeta-> Anyone know if it is possible to target a GPU with haskell, like a stream processing language eg. CUDA does?
12:46:13 <zeta-> via C output?
12:46:25 <copumpkin> zeta-: there's gpugen coming out soon
12:46:36 <copumpkin> zeta-: that doesn't produce intermediate c though, as far as I know
12:46:51 <copumpkin> I'm hoping it'll eventually be merged in as a back-end for DPH
12:47:59 <zeta-> copumpkin: is that a completely separate compiler then?
12:48:11 <copumpkin> zeta-: it's a library for haskell
12:48:15 <monadic_kid> zeta: there is one project, obsidian
12:48:17 <copumpkin> zeta-: not sure how it works behind the scenes
12:48:51 <zeta-> 8-) I'll look it up -- thanks
12:50:17 <monadic_kid> zeta: http://www.cse.chalmers.se/edu/course/TDA956/Slides/may-15-2008-Obsidian-shortp2.pdf
12:50:40 <monadic_kid> zeta: I doubt you'll be able to play with it though, no idea if it's been released
12:54:16 <monadic_kid> copumpkin: you're talking about obsidian
12:54:24 <copumpkin> I'm talking about gpugen
12:54:31 <monadic_kid> thats what it does
12:54:45 <monadic_kid> generates cuda from haskell
12:56:49 <cypher-> what is the current status of gpugen?
12:57:19 <monadic_kid> obsidian is the library that generates cuda which is gpugen
12:58:36 <copumpkin> monadic_kid: I'm pretty sure gpugen doesn't use obsidian
12:59:22 <cypher-> hmm.. it seems that you can't really get hold of any of them
12:59:41 <copumpkin> gpugen will probably get an initial release soon
12:59:54 <copumpkin> or at least ChilliX (one of the authors) said so last time I asked him
13:00:23 <copumpkin> but it'd be nice to see obsidian on hackage
13:00:27 <cypher-> copumpkin: how soon?
13:00:38 * cypher- is looking for some final year project
13:00:43 <cypher-> and it would come in handy ;-)
13:00:50 <copumpkin> cypher-: I asked him a month or so ago and I think he said may or june, but I don't remember exactly
13:01:03 <cypher-> cool
13:01:08 <cypher-> there's a good chance then
13:01:10 <copumpkin> cypher-: ask him when he comes back, he's on here quite often... also, check out the haskell_proposals subreddit if you're looking for stuff to do
13:02:24 <cypher-> copumpkin: cool, I'll check it out
13:02:43 <copumpkin> huh? http://www.reddit.com/r/haskell_proposals/ seems to be empty
13:02:45 <copumpkin> or is it just me?
13:03:48 <cypher-> I can't see anything either
13:03:53 <roconnor> copumpkin: my haskell page was empty
13:03:54 <copumpkin> I think reddit is acting up
13:03:56 <cypher-> but if you search, there is stuff linking to it
13:04:04 <roconnor> was/is empty?
13:04:15 <copumpkin> both haskell and haskell_proposals are empty for me too
13:04:55 <roconnor> haskell has been banned from reddit
13:04:55 <persica> Yup, borked.
13:05:02 <copumpkin> hah
13:05:07 <persica> it's a Python conspiracy!
13:05:09 <roconnor> too much competition for python :P
13:05:14 <copumpkin> it's just the haskell-related ones that are down, too
13:05:16 <roconnor> persica: you know it!
13:05:32 <copumpkin> maybe one of the common moderators went rogue ;)
13:05:35 <copumpkin> and deleted everything
13:05:45 <roconnor> it's a special language feature that Guido added to the compiler.
13:06:15 <roconnor> if your program is reddit then you must delete the haskell pages.
13:06:18 <copumpkin> bbiab
13:06:18 <copumpkin> lol
13:06:30 <persica> if string contains "Haskell" then string = ""
13:06:55 <persica> Which then caused the database server to reject all the haskell posts because their subreddit was invalid.
13:07:07 <p_l> it's even funnier when you recall the old history of I think ritchie modifying compiler on some machine so that if it compiled /bin/login it added a backdoor
13:07:20 <mm_freak> say i want to handle a lazy ByteString byte by byte without random indexingâ¦  is using unpack and normal list processing a good approach here?
13:07:45 <persica> You can walk the list as Word8s.  I think there's a ByteString.head
13:07:52 <zeta-> copumpkin: I guess that means I'll need an nvidia card in my next pc
13:07:54 <zeta-> (hardware planning was the reason for my question)
13:08:14 <twanvl> there is also Data.ByteString.foldr/l
13:08:15 <mm_freak> persica: that's not as convenient as list processing
13:08:21 <mm_freak> twanvl: good point
13:08:30 <persica> and Data.ByteString.mapp
13:08:33 <persica> *map
13:08:46 <mm_freak> however, that doesn't answer my question
13:09:17 <mm_freak> will unpacking a lazy ByteString have a noticable performance impact?  will fusion eliminate the list?
13:09:26 <persica> I think unpack will be worse because it will force it into a regular list which causes you to lose all the advantages of ByteString over String.
13:10:06 <persica> Then again, unpack might be lazy anwyay.
13:10:09 <persica> I don't know. :(
13:10:36 <mm_freak> AFAIK a lazy ByteString is in fact just a list of fixed size ByteStrings
13:11:04 <mm_freak> so i wonder whether i'll get fixed-size strict list chunks or fusion will eliminate those entirely
13:17:18 <endofjelly> @hoogle (a -> b) -> (a,c) -> (b,c)
13:17:18 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
13:17:18 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
13:17:18 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
13:18:09 <copumpkin> endofjelly: that looks like loop
13:18:19 <copumpkin> :t loop
13:18:21 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
13:18:28 <copumpkin> but backwards :P
13:18:32 <endofjelly> heh
13:18:49 <copumpkin> how would it work?
13:19:55 <endofjelly> @hoogle a -> [a]
13:19:56 <lambdabot> Prelude repeat :: a -> [a]
13:19:56 <lambdabot> Data.List repeat :: a -> [a]
13:19:56 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
13:20:07 <endofjelly> @hoogle singleton
13:20:07 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
13:20:07 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
13:20:07 <lambdabot> Data.IntSet singleton :: Int -> IntSet
13:20:24 <edwardk> endofjelly: first?
13:20:30 <edwardk> @type first
13:20:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:20:40 <endofjelly> edwardk, (>>^ ...) will do the trick I think
13:20:54 <edwardk> endofjelly: what were you looking for?
13:21:05 <endofjelly> edwardk, applying a function on the first element of a tuple
13:21:15 <edwardk> thats first =)
13:21:26 <edwardk> read 'a' as ->
13:21:34 <edwardk> > first (+1) (2,"Hello"
13:21:35 <lambdabot>   <no location info>: parse error on input `;'
13:21:41 <edwardk> > first (+1) (2,"Hello")
13:21:43 <lambdabot>   (3,"Hello")
13:22:07 <edwardk> > second (++" World) (2, "Hello")
13:22:08 <lambdabot>   <no location info>:
13:22:08 <lambdabot>      lexical error in string/character literal at chara...
13:22:19 <edwardk> > second (++" World") (2, "Hello")
13:22:20 <lambdabot>   (2,"Hello World")
13:22:26 <endofjelly> edwardk, oh, ok! 8) thx
13:22:43 <edwardk> they are in Control.Arrow
13:23:03 <edwardk> there is a variation on the theme in Control.Functor in category-extras as well, which is somewhat more general
13:23:10 <endofjelly> nice
13:23:25 <endofjelly> but, yeah, in that particular case, I think I'll switch to list comprehensions...
13:23:38 <edwardk> fair nuff
13:23:59 <endofjelly> [([b],e) | (b,e) <- branches]
13:24:23 <copumpkin> edwardk: have you thought about an applicative parser combinator that supports enumeration of the strings in the language?
13:24:28 <endofjelly> that's better than the combination of map, first and, horrifying, (: []) that I had
13:27:00 <joaopizani> Hello everybody, I'm getting an error trying to instance the Read typeclass, can someone help me?
13:27:09 <edwardk> copumpkin: yes, actually =) tricky with big languages though
13:27:41 <joaopizani> Here's the error message: "`read' is not a (visible) method of class `Read'"
13:27:43 <edwardk> copumpkin: technically you can do that with my current combinator set, since my leaf level recognizers all take sets
13:27:56 <joaopizani> Does someone know what it usually means?
13:28:00 <copumpkin> edwardk: it obviously isn't meant to be practical, but it seems like a fun exercise
13:28:05 <joaopizani> I already have googled it and found nothing
13:28:52 <edwardk> copumpkin: its easy enough to code up a variation on a parser that works out the valid parse trie
13:29:58 <copumpkin> :)
13:30:17 <Gracenotes> "Together we can succeed everything!" ah, subtitles for foreign movies. *hugs*
13:30:28 <copumpkin> coding up a parser for a language and being able to pull out an infinite list of all strings in that language would be fun
13:30:34 <Gracenotes> this one translated from Japanese
13:30:37 <copumpkin> maybe I'll try it
13:30:41 <edwardk> Arbitrary eat your heart out ;)
13:30:59 <jpcooper> I have a CS question: Say I have a set of keys. I also have an AVL tree. If I want to delete all of the keys in the set from the AVL tree, is it better to delete them in order of the keys, and if so, in which order, otherwise is random deletion better?
13:31:12 <edwardk> well, in parsimony you just have to walk the GADT for the grammar, the only trickiness is making sure to only apply the first alt that matches
13:31:14 <copumpkin> edwardk: not sure how I'd feel about an arbitrary instance...
13:31:22 <Gracenotes> copumpkin: I thought about about making "depths" for various rules
13:31:26 <Gracenotes> in order to do that
13:31:39 <Gracenotes> like, you don't want to get stuck on a rule that leads you down all similar derivations
13:31:49 <Gracenotes> so give terminal symbols a depth of 0
13:32:01 <copumpkin> yeah, but there are known techniques to enumerate all strings specified by a CFG
13:32:02 <edwardk> Gracenotes: well, in my case i know my terminals so i work bottom up
13:32:02 <Gracenotes> and all those that call it a depth of 1. Or just go to Chomsky normal form or something
13:32:27 <Gracenotes> copumpkin: I haven't studied any of these techniques... hmm. Yeah, I was just doing thinking on mah own.
13:32:54 <Gracenotes> sounds interesting. But, yeah, exhaust all combinations with a sum of, say, 2. then 3. then 4. etc.
13:32:55 <copumpkin> quite a few sipser exercises required using an "enumerator"
13:33:03 <edwardk> its also pretty trivial in an LL grammar, since you have no infinite paths on the left hand side leading to a terminal
13:33:33 <Gracenotes> and for Chomsky normal form it's simple enough too: just branch whenever there are duplicate rules
13:33:45 <Gracenotes> branches will be simple enough to keep track of.
13:33:50 <edwardk> but if you want to do it for an arbitrary CFG you can always generate all finite parses by 'diagonalizing' your traversal of the grammar, which lets you deal with codata grammars, even if you get the answers all out of order.
13:34:26 <Gracenotes> any CFG can be put in normal form. And to consume a branch, take all inputs and go to all possible next values, since all generating rules are of the form A -> BC
13:35:07 <edwardk> sure, my parsers are basically a slightly bastardized normal form. (i permit epsilons)
13:35:21 <copumpkin> is that BaNF?
13:35:22 <copumpkin> :P
13:35:30 <edwardk> copumpkin: =)
13:35:46 <Gracenotes> edwardk: well. epsilons can be factored out :)
13:36:03 <Gracenotes> for CFGs anyway. But, yeah, I'm sure there's more than one way to do it
13:36:04 <edwardk> Gracenotes: yes, but not for my purposes, as i want the epsilons for 'pure' calculation nodes
13:36:18 <edwardk> Gracenotes: my parsers are just an applicative reified as a GADT
13:36:41 <edwardk> you _can_ factor the fmaps into all of the nodes by yoneda encoding them, but then you reduce sharing in the grammar, which worsens my asymptotics
13:36:44 <Gracenotes> last but not least is testing every possible string in the language in graduated steps. more of a recognition approach than a generation one..
13:37:16 <Gracenotes> anyway. Maybe I'm getting a bit antsy about my theory of computation final exam, lol.
13:37:43 <edwardk> Gracenotes: what texts are you using, the sipser one?
13:38:02 <Gracenotes> yes. But we're only going up to mapping reducibility with decidability
13:38:21 <Gracenotes> complexity classes aren't touched in the course. Although, I plan on looking over them when I have the time.
13:38:27 <copumpkin> I like the sipser book
13:38:49 <edwardk> ah, i did an independent study back in college that covered the rest of the book and some related material on quantum computation, but never really did anything with complexity classes afterwards
13:47:22 <edwardk> i think the only thing i really got out of that in retrospect is a healthy respect for monte carlo and las vegas algorithms, and a chapter in my thesis. ;)
13:48:15 <edwardk> oh and a glib reference to the fact that the equality of streams is Pi_2^0 complete in a blog post about the lack of costrength in haskell functors
13:49:21 <edwardk> afk a bit
14:08:06 <mauke> preflex: remember <meltingwax> my new major is computational dance
14:12:25 <mreh> > [(a,b) | a <- [1..3], a > 1, b <- [1..3]]
14:12:26 <lambdabot>   [(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:12:52 <mreh> i dont know what i'm trying to do
14:14:06 <vixey> me neither
14:17:59 <midnight> Hmm...
14:23:41 <povman> Hello. Does anyone know what Queue is being considered for the haskell platform?
14:26:45 <benkio> hello, I need help
14:27:03 <mauke> speak friend and enter
14:27:18 <benkio> I'm used Control.Exception and my code is:
14:27:46 <benkio> import Control.Exception (catch, throwIO)
14:27:46 <benkio> onError :: IO a -> IO b -> IO a
14:27:46 <benkio> onError a h = a `Control.Exception.catch` (\e -> h >> throwIO e)
14:27:54 <mauke> are your types ambiguous
14:28:16 <benkio> yes
14:28:34 <benkio> Ambiguous type variable `e' in the constraint:
14:28:37 <benkio>       `GHC.Exception.Exception e'
14:28:38 <benkio>         arising from a use of `throwIO' at test.hs:5:54-62
14:28:39 <benkio>     Probable fix: add a type signature that fixes these type variable(s)
14:28:41 <benkio> Failed, modules loaded: none.
14:28:42 <mauke> anything wrong with onException?
14:29:42 <benkio> yes, I think
14:29:49 <kitkat> Fr33 your mind
14:29:54 <kitkat> is Haskell like C?
14:30:01 <mauke> kitkat: not really
14:30:04 <kitkat> hm..
14:30:04 <povman> hahaha
14:30:17 <mreh> > let infinity = infinity + 1 in infinity
14:30:18 <kitkat> my dad said haskell is superior compared to C
14:30:19 <mauke> benkio: what's the problem with onException?
14:30:28 <kitkat> is haskell free?
14:30:30 <MyCatVerbs> kitkat: you can *use* it like C, but it's more fun if you don't.
14:30:32 <lambdabot>   thread killed
14:30:35 <jmcarthur> kitkat, your dad sounds awesome
14:30:37 <mauke> kitkat: you sound a lot like gavino
14:30:39 <povman> kitkat: www.haskell.org
14:30:40 <benkio> the ambiguous problem
14:30:41 <kitkat> MyCatVerbs, can I cheat?
14:30:47 <kitkat> mauke i am
14:30:51 <mauke> benkio: huh?
14:31:00 <mauke> kitkat: then why are you still coming here?
14:31:09 <mauke> you've been here years ago
14:31:09 <kitkat> povman, says "IF YOU'RE NOT 18+ LEAVE"
14:31:24 <povman> what...the...
14:31:26 <povman> hell
14:31:30 <kitkat> and a lot of naked men are there
14:31:37 <mreh> I wish
14:31:42 <MyCatVerbs> That's because Haskell only ever gets taught to undergrads.
14:31:44 <kitkat> is there a FC library?
14:31:52 <MyCatVerbs> Sexy, sexy undergrads.
14:31:57 <kitkat> for Haskell?
14:32:12 <kitkat> :3
14:32:33 <osfameron> @faq does haskell have a library for sexy, sexy undergrads?
14:32:33 <lambdabot> The answer is: Yes! Haskell can do that.
14:32:36 <osfameron> yay!
14:32:37 <mreh> that smiley always looks like handlebar moustache
14:32:51 <MyCatVerbs> Or a flight yoke.
14:32:55 <Apocalisp> or a bunny in hiding
14:33:10 <kitkat> does Haskell support Winamp?
14:33:14 <kitkat> Clutex
14:33:20 <crutex> :}
14:33:23 <mreh> @faq Can Haskell support winamp?
14:33:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:24 --- mode: ChanServ set +o mauke
14:33:25 --- mode: mauke set +b *!*@dyndsl-085-016-039-037.ewe-ip-backbone.de
14:33:36 <MyCatVerbs> Apocalisp: like a Sander Cohen-themed Kilroy.
14:34:25 --- mode: mauke set -o mauke
14:34:34 <povman> Am I missing something?
14:34:50 <mauke> @protontorpedo
14:34:50 <lambdabot> so haskells better than smalltalk and clsip?
14:34:59 <mauke> @protontorpedo
14:34:59 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
14:35:04 <mauke> @protontorpedo
14:35:04 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
14:35:23 <Cale> povman: btw, if you need a Queue, Data.Sequence does a good job
14:37:17 <povman> Cale: Thanks, I didn't notice it had O(1) insertion at both ends!
14:37:19 <mreh> note how haskellers aren't threatened by people trashing haskell
14:38:10 <jmcarthur> because haskellers know that people who trash haskell don't know haskell
14:38:41 <mreh> and aspostates are stoned to death
14:40:07 <povman> what's with kitkat?
14:40:21 <mreh> i'll give him a break
14:40:39 <MyCatVerbs> povman: I have reason to suspect that you too were once thirteen.
14:40:56 <SamB> MyCatVerbs: what if he was born on leap day ?
14:41:11 <mreh> he's thirteen and he's talking about C programming
14:41:21 <mreh> he should go outside like a normal 13 year old
14:41:41 <mreh> whatever it is, he deserves it
14:41:44 <MyCatVerbs> mreh: on behalf of me as of eight years ago, go stick a pencil up your nose. :P
14:41:44 <povman> and stop eating all our steak
14:42:16 <MyCatVerbs> SamB: that doesn't prevent him from reaching thirteen years of age. It just makes it take a while for his thirteenth birthday to come up.
14:42:31 <Cale> mreh: I was programming in C when I was 13.
14:42:32 <p_l> hmm... 13yo... that was good age...
14:42:47 <SamB> MyCatVerbs: what, you mean that doesn't make you only reach ages that are n*4 ?
14:42:56 <mreh> Cale: do you still program in C?
14:42:59 <vixey> Cale what sorts of programs
14:43:00 <vixey> ?
14:43:09 <Cale> mreh: Not if I can help it.
14:43:11 <MyCatVerbs> SamB: no, why would it?
14:43:14 <mauke> > 0x13
14:43:15 <lambdabot>   19
14:43:16 <mreh> all that time wasted
14:43:20 <SamB> MyCatVerbs: dunno.
14:43:41 <povman> >work
14:43:43 <MyCatVerbs> mreh: to be fair, though, if I had access to a working time machine, first thing I'd do is go back and smack my thirteen-year-old self upside the head.
14:43:43 <SamB> if you only got older when you had a birthday, I guess?
14:43:53 <SamB> MyCatVerbs: for learning C?
14:43:55 <kyevan> MyCatVerbs: Why?
14:44:11 <MyCatVerbs> kyevan, SamB: because at age thirteen I was a complete dick.
14:44:15 <mreh> yeah, i'd be like, stop playing on that damn computer
14:44:18 <Apocalisp> In a world where aging is quantised...
14:44:19 <kyevan> Heh :J
14:44:24 <Cale> mreh: Well, I suppose it was still educational. It's hard to understand why good programming languages are good without knowing what came before.
14:44:43 <Cale> vixey: Hmm... nothing too important. :)
14:44:55 <davidL> Cale: how old are you now? :)
14:45:00 <Cale> davidL: 26
14:45:55 <mreh> ASL?
14:46:06 <mreh> heh, the old days
14:46:27 <jmcarthur> i was doing C at 13
14:46:40 <mauke> not entirely unrelated: http://legorobotcomics.com/?id=33
14:46:41 <Apocalisp> Pascal here
14:46:46 <mreh> I was making black powder and reading comics
14:47:11 <Cale> Yeah, we used Delphi/Object Pascal in highschool.
14:47:24 <mreh> Cale: in which country?
14:47:29 <Apocalisp> Turbo Pascal, baby
14:47:32 <Apocalisp> best IDE evar
14:47:46 <Cale> mreh: Canada, Ontario
14:47:49 <davidL> most highschools use java now
14:48:10 <Cale> Yeah, that's painful to think about.
14:48:13 <cocopumpkin> haskell_proposals subreddit is still dead :(
14:48:20 <mreh> i was convinced they only used Pascal/Delphi  in my school
14:48:23 <SubStack> if they cover actual computing at all
14:48:30 <SubStack> pesky AP choosing java like that
14:48:42 <mreh> i did do some prolog
14:48:50 <revertTS> it's not too bad if they focus on actualy teaching CS topics
14:48:54 <cocopumpkin> COBOL is the way to go
14:48:56 <revertTS> but the AP test means it's basically a tour of Java :/
14:49:00 <cocopumpkin> it's much better than BOL
14:49:11 <mreh> or BASIC
14:49:12 <davidL> and AP is dropping the AB portion of the exam...the part covering things like big-oh
14:49:29 <mreh> Associated Press?
14:49:35 <revertTS> they're doing away with it entirely, not integrating it with the A test?
14:49:38 <mreh> African Bum Cleaner?
14:49:43 <davidL> collegeboard Advanced Placement exams
14:49:45 * edwardk waves hello,
14:49:51 <vixey> hi edwardk
14:49:58 <c_wraith> I have this urge to teach a high-school intro to real computer science.  Computational theory and complexity theory.
14:50:02 <Cale> Schools are way too standardised.
14:50:05 <edwardk> vixey: the great refactoring project from the other day didn't pan out
14:50:11 <c_wraith> See if having non-retarded high school CS actually helps anyone.
14:50:31 <davidL> revertTS: not sure on the details, but it can't be good
14:50:31 <SubStack> with haskell >:D
14:50:34 <MyCatVerbs> c_wraith: wouldn't complexity theory be way, waaaaay too abstract?
14:50:34 <edwardk> vixey: made some nice cafs polymorphic and lost sharing
14:50:46 <c_wraith> not basic complexity theory
14:50:56 <mreh> not when you're 18-19, you can handle most concepts at degree level
14:50:59 <c_wraith> Stuff like big O notation is very practical.
14:51:01 <SubStack> complexity theory is easy enough to grok
14:51:03 <revertTS> c_wraith: I doubt it would help anyone
14:51:05 <SamB> c_wraith: this would be after the programming-language-of-the-month class ?
14:51:15 <edwardk> MyCatVerbs: complexity theory is pretty handy, i've used it to prove that i can stop looking for a better answer in some areas
14:51:15 <revertTS> my experience is that there are people who are motivated and do it on their own, and those that don't
14:51:17 <c_wraith> No, this would be instead of a "programming" class
14:51:30 <cocopumpkin> I wish I had been introduced to "real CS" earlier
14:51:32 <SamB> c_wraith: oh, I don't think that'd help
14:51:41 <SubStack> of course, I knew about 5 languages pretty well by the time I graduated high school
14:51:45 <mreh> "programming" is completely different to CS
14:51:50 <MyCatVerbs> edwardk: I'm not denying that it's handy! I'm questioning the assumption that you can get kids to care about it from anything more than the most informal point of view.
14:51:57 <SamB> I don't think they'll understand CS without some programming to apply it to
14:51:59 <c_wraith> Computer science.  Not programming.  Math that's more interesting than calculus, and shows that there's a lot of variety out there.
14:52:11 <edwardk> MyCatVerbs: i'd argue that its hard to get kids to care about anything ;)
14:52:25 <Nir> How do I concatenate lists?
14:52:31 <c_wraith> Nir: ++
14:52:36 <SubStack> see also concat
14:52:47 <Nir> I thought [2]++[3] would yield [2,3], but in WinHugs, it doesn't. It throws an error. Warum?
14:52:58 <vixey> what's Warum
14:52:58 <SubStack> hugs sucks?
14:53:05 <edwardk> haha you know you've been on this channel too long when you wonder why Nir was getting a karma boost for asking a list question.
14:53:05 <c_wraith> Sounds like a bug in winhugs. *shrug*
14:53:16 <Zao> Nir: "an error"/
14:53:24 --- mode: ChanServ set +o mauke
14:53:24 <Cale> Nir: If that produces an error, then there's probably something wrong with your copy of WinHugs.
14:53:25 --- mode: mauke set -b *!*@dyndsl-085-016-039-037.ewe-ip-backbone.de
14:53:27 <cocopumpkin> probably can't decide on the type of 2 and 3?
14:53:27 <Nir> ERROR file:.\x.hs:14 - Type error in application
14:53:27 <Nir> *** Expression     : xs : x
14:53:27 <Nir> *** Term           : xs
14:53:27 <Nir> *** Type           : [[a]]
14:53:27 <Nir> *** Does not match : a
14:53:27 <edwardk> > [2]++[3]
14:53:28 <Nir> *** Because        : unification would give infinite type
14:53:29 <mauke> "Warum" = "why"
14:53:29 <lambdabot>   [2,3]
14:53:29 <loop> vixey: why in germany
14:53:33 <Lemmih> Hugs> [1]++[2]
14:53:33 <Lemmih> [1,2]
14:53:35 <vixey> ah
14:53:47 <mauke> Nir: that's xs : x, not [2]++[3]
14:53:48 <cocopumpkin> how would [2] ++ [3] give an infinite type?
14:53:53 <cocopumpkin> ah
14:54:14 <Cale> Nir: you can't add elements to the right end of a list with :
14:54:16 <Nir> OOPS
14:54:18 <Nir> Never mind.
14:54:25 --- mode: mauke set -o mauke
14:54:29 <SubStack> it'd be nice if there were a right-side :
14:54:39 <Cale> Well, there's ++ [x]
14:54:39 <MyCatVerbs> edwardk: My issue is that the moment you whip out the formal definition of big-O in terms of $\exists n_{0},c, \forall n > n_{0}, f(n) > c*g(n)$, the kids are going to go 'zzzzzzz'.
14:54:45 <edwardk> nir: i'm going to guess that you have a pattern backwards and said (xs:x) instead of (x:xs)
14:54:52 <SubStack> yeah, but that doesn't lend itself to pointfree as nicely
14:55:05 <MyCatVerbs> SubStack: appending to a purely-functional list is slow, and we don't really want to encourage people to do it too much.
14:55:13 <Cale> MyCatVerbs: Maybe not if they've actually been taught logic properly by then!
14:55:17 <SubStack> well that makes sense anyways
14:55:54 <MyCatVerbs> Also, (++[x]) isn't *that* much longer than (x:). Only three more characters! ^^
14:56:05 * SubStack is also a perl golfer, so
14:56:18 <Cale> In fact, I think imparting a good sense of logic is more important than anything else which highschool mathematics courses could possibly do, and it's a total shame that they completely fail to do so.
14:56:27 <mreh> @hoogle primes
14:56:27 <lambdabot> No results found
14:56:45 <mreh> is there an infinite list of primes predefined?
14:56:46 <SubStack> high schools should offer courses in discrete mathematics
14:56:48 <MyCatVerbs> Cale: this is why, to my way of thinking, a good hard dose of discrete maths might be more fun. A break from all the calculus.
14:56:53 <SubStack> more useful than calculus
14:56:58 <mauke> mreh: no
14:57:03 <mauke> we sort of make them up as we go
14:57:08 <vixey> Cale -- It's pretty horrific watching epsilon-delta being taught to _university students_ :/
14:57:35 <vixey> kind of like teaching monkeys to have a tea party
14:57:35 <Cale> Instead, students are taught that mathematics is an illogical mash of arbitrary rules which must be followed precisely.
14:57:47 <SamB> yeah, probably you don't want to cover the \exists definition of O(n) in a HS class ;-)
14:57:53 <c_wraith> Really, that's my viewpoint too.  Calculus is a poor direction to take math in after geometry.  Discrete would be a lot better, just in terms of introducing people to basic logic.
14:58:05 <Cale> vixey: Well, it's because this is usually the first time quantifiers are even mentioned.
14:58:08 <Elly> dicrete math is prettier :)
14:58:25 <osfameron> quantifiers?
14:58:33 <mauke> â, â
14:58:35 <Cale> osfameron: for all and there exists
14:58:41 <c_wraith> The things tattooed on my arm...  :P
14:58:43 <wli> Generating functions and analytic affairs on them are big in discrete mathematics.
14:58:46 <SubStack> geometry covers a few proofs anyhow
14:58:48 <SamB> darn it, mauke beat me because I didn't have the IM preselected :-(
14:58:51 <SubStack> so it'd be a nice continuation
14:58:52 <edwardk> i always thought calculus was taught too early. you never get a chance to reason logically, and then its all 'For every epsilon > 0, there exists a y in X such that |y-x| < epsilon' -- and they've never built up the mental toolbox to deal with that.
14:58:52 <osfameron> ah
14:58:56 * c_wraith might have a bit of formal logic tattooed on his arm
14:59:00 <mauke> SamB: owned by compose key :-)
14:59:20 <MyCatVerbs> mauke: what's the compose sequence for those?
14:59:24 * wli never seemed to have an issue with delta-epsilon proofs.
14:59:33 <MyCatVerbs> Or have you gone and altered your own locale for it?
14:59:33 <edwardk> i.e. i'd much rather have had discrete math and real analysis before i got to differential equations.
14:59:41 <edwardk> but perhaps i'm a bit of a formalist
14:59:44 * osfameron looks at the wolfram page on delta-epsilon, runs to the hills screaming
14:59:46 <mauke> MyCatVerbs: for me it's <compose> A A
14:59:55 * SamB 's issues with delta-epsilon proofs were mostly how to DO them, not what they mean
15:00:18 <MyCatVerbs> mauke: hrmn. Default with the UK layout here is Ã/Ã¥.
15:00:27 <Cale> Another problem is that even though it's quite obvious the instant it is mentioned, the best interpretation for |y-x| is "the distance between x and y", and *not* "the absolute value of x minus y"
15:00:32 <SamB> it gets a lot easier once you have the basic limit theorems available ...
15:00:41 <loop> edwardk: i didn't really have any calculus before uni and there the first contact was with delta-epsilon -definitions etc
15:00:48 <Cale> And for some reason, they often neglect to point that out.
15:00:52 <SamB> then you only have to break out epsilon/delta when it's the easiest way you see to prove something
15:00:55 <Apocalisp> http://www.youtube.com/view_play_list?p=5A714C94D40392AB
15:00:59 <kfranke> I have a data structure that can be sorted in two ways.. How can I make one set sorted one way and a second set sorted the other way?
15:01:00 <Apocalisp> Seen that?
15:01:02 <vixey> hm..,,, so very few people taught them self calculus ?
15:01:02 <Apocalisp> neat stuff
15:01:05 <vixey> here
15:01:07 <MyCatVerbs> â â½ â¿ â¾
15:01:08 <Cale> vixey: I did.
15:01:19 <mauke> MyCatVerbs: I have 127 lines of customized compose sequences
15:01:36 <SamB> Cale: you mean that wasn't a single "distance between" symbol ?
15:01:42 <davidL> mauke: where are those defined?
15:01:50 <mauke> davidL: ~/.XCompose
15:02:03 <edwardk> loop: i was mostly saved by the fact that i learned a lot of math informally to do 3d graphics, visibility, nurbs, radiosity, etc. so i had strong faculties for visualizing everything when i finally got around to taking things formally.
15:02:03 <Cale> SamB: It's easy to make this mistake when you see these sorts of definitions for the first time.
15:02:38 <Cale> SamB: But yeah, I find it helps a lot to even go so far as to treat |x| as |x - 0| and read it as a distance as well.
15:02:57 <Cale> Or just switch to metric space notation: d(x,y)
15:03:07 <SamB> yeah, that's basically how I think about || nowadays
15:03:22 <SamB> ever since I learned complex numbers in Fractal Creations, maybe ...
15:03:30 <edwardk> i guess my biggest problem is calculus isn't math the way its taught, its a system you take on faith, until you get to real analysis and then they explain the whys and wherefores at a level that let you rederive all of the stuff that heretofore was just pattern recognition.
15:03:40 <Cale> There are a few special algebraic properties which the absolute value has (it's a norm, not just a distance), but you rarely actually use them.
15:04:14 <SamB> Cale: hey, I pretend to live in a euclidean world
15:04:16 <vixey> I do get the impression that the curriculum in schools is harmful but can't really back that up except my own wishy-washy feelings about it
15:04:21 <hatds> "isn't math the way its taught" -- don't you mean 'is'?
15:04:29 <vixey> I mean in early education (adding up coins and all that crap)
15:05:03 <Cale> hatds: He means that the way Calculus is taught turns it into something which is not mathematics.
15:05:11 <edwardk> hatds: i should have said that my biggest problem is that calculus is not mathematics, at least the way it is taught.
15:05:20 <hatds> gotcha
15:05:26 <Cale> All of my university courses were good though.
15:05:54 <Cale> (Including my calculus courses, which were really real analysis courses)
15:06:03 <c_wraith> Also..  math courses that require memorizing things...  That's not the point of math.  They make me mad.
15:06:06 <edwardk> cale: you lucked out in that ;)
15:06:26 <Cale> I know :)
15:07:04 <Cale> http://www.maa.org/devlin/LockhartsLament.pdf -- this summarises my feelings about the educational system with regard to mathematics nicely.
15:07:39 <vixey> one really really bizarre thing (for me anyway) is this breed of people that 'hate math' but love programming
15:07:42 <edwardk> c_waith: heh, speaking of memorization, i never actually took a course on trigonometry. to this day i still have to work backwards from linear algebra and the notion of a dot product to remember sine vs. cosine, or to work out the various trig identities, etc.
15:08:00 <loop> Cale: that's a pretty good article
15:08:03 <vixey> or maybe they don't hate it but they just 'can't do it' or whatever
15:08:04 <Cale> Well, most people have never so much as been exposed to mathematics.
15:08:12 <Cale> At least, what *I* would call mathematics.
15:08:15 <SamB> edwardk: I can never REMEMBER what I learned in trig
15:08:26 <SamB> at least, not from then
15:08:40 <vixey> I'm talking about people that type in a couple pages of matrix math from a tutorial online and then write a 3D game with it
15:08:51 <vixey> they've got no clue what they're doing and want to keep it that way
15:09:06 <SamB> I can't understand people like that
15:09:06 <Cale> Highschool "math" is, if you're lucky, "how to be a calculator", and if not "calculator ownership" (or should that be the other way around?)
15:09:45 <SamB> Cale: or for the poorer students, "calculator borrowing"?
15:09:50 <lament> i took calculator ownership, so now i own all those people who learned how to be a calculator
15:09:56 <hatds> generalizing a bit I think
15:09:56 <Cale> SamB: Something like that, yeah
15:09:58 <mdmkolbe> When profiling code code to see if an optimization is worth it, what GHC compile and RTS flags should I use?
15:10:11 <Cale> lament: Calculator pwnership.
15:10:31 <edwardk> highschool algebra was the best week of highschool i had.
15:10:44 <Cale> mdmkolbe: You mean just to do time profiling?
15:10:57 <Cale> mdmkolbe: -prof -auto-all and then run with +RTS -p
15:11:08 <p_l> highschool math == "WHAT!? They removed differentiation from exams!? And the equation tables will be without them!? FUUUCK"
15:11:18 <Cale> mdmkolbe: But there are more complicated things you can do if you're interested in space usage.
15:11:20 <mdmkolbe> Cale: yes (I'm timing my whole program with one way of solving the problem and then the other way)
15:12:10 <mdmkolbe> I don't need detailed profiles, I just need the code built in an optimized fasion (so I'm timing actuall differences rather than something stupid like heap resizes, etc)
15:12:31 <loop> edwardk: what's in highschool algebra?
15:13:08 * vixey remembers teaching my teacher about the plane equation :p
15:13:10 <vixey> in high school
15:13:23 <pejo> mdmkolbe, there's a timeIt package on hackage that might be useful to you, but that isn't profiling in the sense you mean.
15:14:03 * p_l remembers giving up when trying to write an essay on Lambda Calculus in 2nd year of HS
15:14:36 <pejo> mdmkolbe, or http://www.haskell.org/haskellwiki/Timing_computation_in_cycles
15:15:13 <edwardk> loop: linear equations, functions, graphing inequalities, quadratic equations, polynomials, rational equations, and a little geometry, that sort of thing. i got lucky and my highschool algebra teacher let anyone in the class who wanted to work ahead of the class work ahead.
15:15:59 <wjt> hmm. i want bustle to ship with a .desktop file, so i need cabal to generate it, substituting $(bindir)/bustle into a template. anyone know of a known-good cabalized project which already has the necessary custom magic in Setup.lhs?
15:16:11 <edwardk> I got really bored that weekend and turned in everything and played on the computers in the back of the room for the rest of the year.
15:16:46 <roconnor> @where mmt
15:16:46 <lambdabot> http://www.cs.nott.ac.uk/~mjj/pubs/mmt/mmt.pdf
15:17:11 <edwardk> Sometimes OCD works in your favor ;)
15:18:24 <kyevan> I find having to do things like multiplication and division by hand tedious and boring. I can do it, but it drives me nuts.
15:18:31 <kyevan> I'd much rather actually be thinking :P
15:20:16 <mdmkolbe> @hoogle Int -> Double
15:20:16 <lambdabot> Prelude toEnum :: Enum a => Int -> a
15:20:16 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
15:20:16 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
15:23:03 <edwardk> i have always held a place in my heart for Fermi problems, even though I can't stand boring 'here, calculate this' type problems. Estimation is a skill largely lacking in our society. It went out with the slide rule.
15:23:34 <vixey> it's very good to be able to run thing like the long division algorithm by hand though
15:24:57 <younder> it is?
15:27:25 <mdmkolbe> younder: yes, b/c it introduces you to the concept of algorithms :-).  And if you go into numerical computing you will see variations on the long devision algorithm
15:33:05 * byorgey bakes lambdaberry scones
15:34:05 <SubStack> what manner of berry is a lambdaberry?
15:34:18 <lament> it's the ultimate
15:34:24 <SubStack> oh right
15:36:04 <byorgey> edwardk: you around?
15:36:25 <edwardk> byorgey: yeah
15:37:00 <byorgey> edwardk: say I want something like   newtype Const a b = Const a
15:37:07 <byorgey> edwardk: is there something like that in category-extras?
15:37:14 <Cale> mdmkolbe: Oh, then you should add -O2
15:37:15 <byorgey> I know it exists in Control.Applicative
15:37:21 <edwardk> import Control.Applicative =)
15:37:23 <byorgey> but I want all the category-extra instances
15:37:32 <Cale> mdmkolbe: (sorry, I went away to dinner after that comment)
15:37:54 <byorgey> and, what I *actually* want is  Const' a b = Const' b  =)
15:37:58 <Cale> mdmkolbe: Compiling for profiling is good to understand the performance of individual parts of your program though.
15:38:03 <edwardk> that said there is a type that translates to that, one sec.
15:38:20 <byorgey> see, that's why I asked =)
15:40:36 <edwardk> the Const a b = Const a should just be PCofree Void modulo some newtypes
15:41:21 <edwardk> Const a b = Const b -- would be Biff (,) Void Identity -- not the most elegant of identifiers ;)
15:42:14 <byorgey> heh, ok, thanks =)
15:42:24 <edwardk> PCofree Void = PAp (,) Void = Biff (,) Identity Void ~ (Identity a, Void a) -- so there is technically an extra bottom in there
15:43:00 <edwardk> in a comment in Control.Functor.Combinators there is a reference to Joker and Clown type Joker = Biff (,) VoidF; type Clown f = Biff (,) f VoidF -- which are the two types you want
15:43:15 <edwardk> named after the joker and clown from the paper clowns on the left of me, jokers to the right
15:43:58 <edwardk> i went a little crazy with the functor/bifunctor combinators
15:44:43 <roconnor> edwardk: what's the difference between Ran and Codensity ?
15:44:46 <edwardk> a few versions back each of those had their own types
15:45:03 <edwardk> roconnor: Codensity f = Ran f f -- Ran has a more general signature where you can let the two functors vary independently
15:45:43 <edwardk> Ran g h a ~ forall b. (a -> g b) -> h b -- so every codensity monad is a right kan extension but there are more right kan extensions that aren't codensity monads
15:45:57 <edwardk> roconnor: did you look at monad-ran?
15:46:03 <roconnor> only the documentation
15:46:27 <PeakerWork> Philippa: sorry, was away.. Subclasses are really just function records that contain other function records within them?  I don't see why they add boilerplate..
15:46:33 <edwardk> in there is a bunch of monads that can be expressed as right kan extensions, only about half are actually expressable as a codensity monad
15:46:44 <PeakerWork> Philippa: what do you mean by "inheritance through a lifting function"?
15:47:31 <roconnor> edwardk: Ran doesn't seem to have the kind signature you suggest.
15:47:43 <roconnor> data Ran m a = Ran {
15:47:44 <roconnor> getRan :: forall b. (a -> G m b) -> H m b
15:47:46 <roconnor> }
15:47:56 <edwardk> roconnor: Ran in that lib is more specialized than the general notion of Ran from category-extras
15:48:02 <roconnor> sure
15:48:07 <Philippa> PeakerWork: taking the records out of each other is boilerplate. As for 'through a lifting function', consider the situation with monad transformers?
15:48:11 <edwardk> look in Control.Functor.KanExtension
15:48:12 <roconnor> so what's the difference bewteen that Ran and Codensity?
15:48:13 <edwardk> for the def i gave above
15:48:41 <roconnor> edwardk, basically why should I use Ran instead of Codensity?
15:48:50 <Philippa> You've got some bunch of intentionally named functions sitting in some layer, and with a typeclass around them. Each time you add a transformer to the stack, you want a new instance, that just lifts to the previous instance for each call
15:48:58 <edwardk> the Ran in Control.Monad.Ran is 'a transformer for monads that can be expressed as right kan extensions' by breaking m into 'two halves 'G m' and 'H m'
15:49:11 <edwardk> roconnor: the Ran in monad-ran?
15:49:20 <roconnor> yes
15:49:36 <Saizan> edwardk: so for a free monad m (i.e. some labelled tree), building it with Ran can give something asymptotically more efficient than just Codensity m ?
15:49:40 <edwardk> roconnor: because that Ran can handle things that the codensity monad can't =)
15:49:49 <roconnor> edwardk: cool, like what?
15:50:03 <edwardk> roconnor: well, the reader monad for one, has the wrong form =)
15:50:12 <roconnor> huh?
15:50:33 <edwardk> forall o. (a -> o) -> r -> o -- is a CPS'd reader, thats not in the form of a codensity monad
15:50:47 <roconnor> both Ran m and Codensity m are isomorphic to m.
15:50:49 <PeakerWork> Philippa: well, if you pass the record by an extra arg,  passing (superClass theRecord) sounds like a very minimal addition of boilerplate...
15:51:04 <roconnor> @unmtl ContT o (Reader r m) a
15:51:04 <lambdabot> err: `r -> m' is not a type function.
15:51:10 <PeakerWork> Philippa: I'm not sure how monad transformers relate to inheritance, though?
15:51:15 <roconnor> @unmtl ContT (Reader r m)  o a
15:51:15 <lambdabot> (a -> o (r -> m)) -> o (r -> m)
15:51:21 <roconnor> :/
15:51:35 <Saizan> @unmtl ContT o (Reader r) a
15:51:35 <lambdabot> (a -> r -> o) -> r -> o
15:51:37 <roconnor> @unmtl ContT o (Reader r) a
15:51:38 <lambdabot> (a -> r -> o) -> r -> o
15:52:00 <edwardk> roconnor: but look at that signature, Codensity Reader admits State operations! =)
15:52:12 <roconnor> hmm
15:52:16 <glguy> interesting... haddock produces invalid HTML anchors for operators
15:52:36 <Philippa> PeakerWork: because you're basically trying to inherit what the previous layer doess
15:53:15 <Philippa> you're just lifting through something other than super, IYSWIM
15:53:39 <PeakerWork> Philippa: well, I have to do a lot of acrobatics in my head to view it that way :)
15:54:18 <edwardk> in fact if you dig through monad-ran you'll note that the definition i give for Ran (State s) a -- is exactly that of Codensity Reader -- and it recycles the machinery for bind, return, ap, etc. from the generic Codensity definitions
15:54:27 <edwardk> it only has special definitions for get and set.
15:55:12 <Philippa> PeakerWork: do it, and spend a while 'til it makes sense :-)
15:55:43 <Philippa> to go back a step, by the time I've declared all these damn record types I want the advantages that a typeclass brings...
15:55:49 <PeakerWork> Philippa: so you believe Monad Transformers could be made nicer by taking ideas from OO? What other areas?
15:56:22 <PeakerWork> Philippa: IME (very limited, admittedly) using type-classes or function records is not that different, and there was not that much boilerplate involved
15:57:09 <chessguy> hey dons ?
15:57:20 <edwardk> (for that matter the Ran based IO is also a Codensity Reader (since IO is really a form of State) where the environment is State# RealWorld
15:57:46 <Philippa> PeakerWork: I may well be more allergic to the record approach than you. Or proposing to have a lot more running around - it's not unknown for me to write functions with types I'd hate to write out
15:58:26 <PeakerWork> Philippa: I usually write the type first..
15:59:15 <edwardk> roconnor: still here?
15:59:36 <roconnor> sort of
16:00:26 <Philippa> PeakerWork: if you're knee-deep in extensible stuff, the types get to be more of a PITA than you want to keep track of yourself. Too much structure, not enough names to hide it behind
16:00:35 <jaj> hi, I was wondering, is there any syntax that would make lambdabot show me the fmap implementation for Data.Tree for instance?
16:01:03 <edwardk> roconnor: there are lots of other right kan extensions than just the codensity monad, i.e. the yoneda lemma, or you can also represent any adjoint as a kan extension of the other side of the adjunction.
16:01:06 <dcoutts> wjt: you want to look at the API for Distribution.Simple.InstallDirs
16:01:45 <PeakerWork> Philippa: I've been sad about my monad transformer types before -- but I associate MT-code with imperative-style
16:01:47 <roconnor> edwardk:  I don't think of codensity as a right kan extension.  I think of it as "make my code go faster" extension.
16:02:03 <PeakerWork> Philippa: I don't find it very common to use MT's in very functional-style code
16:02:06 <pejo> dcoutts, is the compiler obligations written down anywhere for cabal?
16:02:39 <Philippa> PeakerWork: see my earlier conversation with beelsebob about monads making a good 'architectural' structure
16:02:46 <jaj> "@src Functor Maybe" used to work, didn't it?
16:03:02 <PeakerWork> Philippa: Also, EvilTerran taught me a nice boilerplate to use with MT's so that all the boilerplate is really simple and condensed in one place -- and then its really easy to use the MT. The boilerplate sucks, but there's relatively little of it and its easy enough :)
16:03:06 <mdmkolbe> Is there some known performance problem with gcast (but not cast)?  My program is exhibiting strange (e.g. exponential time on a linear algorithm) performance behavior that seems to to be centered around the use of gcast.
16:03:21 <edwardk> roconnor: sure, the Ran transformer i put in there does the same basic thing though, it 'makes code go faster' i just am a bit choosier about how i transform the code than just applying its codensity monad. i.e. IO is already a state monad, its better to just CPS transform it and spot that _that_ is already a codensity monad than to take its codensity again
16:03:43 <mdmkolbe> s/exponential/superlinear/  <-- I'm not sure it's exponential, but I'm sure it's worse than linear
16:03:44 <Philippa> PeakerWork: I wrap stacks with boilerplate where there's one I'm going to use a lot, but it's no help if you want one or two for local use
16:03:47 <pejo> mdmkolbe, is gcast some cast with generic programming?
16:03:54 <mdmkolbe> pejo: yes
16:04:30 <mdmkolbe> pejo: oddly both cast and other generic programing tricks I'm using perform well, it's just when I need to use gcast that things go bad
16:05:00 <edwardk> Codensity (State s) a ~ forall o. (a -> s -> (o, s)) -> s -> (o, s) -- vs. Ran (State s) a ~ forall o. (a -> s -> o) -> s -> o ~ Codensity (Reader s) a
16:05:03 <PeakerWork> Philippa: Yep. How often do you write MT stacks?
16:05:26 * hatds pretty much avoids monad transformers because of the inherit ugliness
16:05:36 <glguy> ugliness??
16:05:38 <Philippa> PeakerWork: one or two, all the damn time
16:05:43 <glguy> you write it once and hide it under a newtype somewhere
16:05:50 <roconnor> sounds like Ran is even better than Codensity.
16:06:03 <pejo> mdmkolbe, generic programming in general might give a performance hit, but I'm not aware of asymptotic complexity changes (but it could well be).
16:06:06 <Philippa> "oh look, I've some local config info and there might be some errors"
16:06:07 <hatds> you still gotta mess with lift and such
16:06:18 <edwardk> the Ran in monad-ran is basically intelligently applied Codensity, Yoneda or just plain ripping the existing monad in half.
16:06:27 <Philippa> hatds: you do that once in the newtype
16:06:30 <glguy> hatds, no, you just define what functions you want to operate in your newtyped transformed and lift them once
16:06:31 <edwardk> i really need to just rename it to CPS or something =)
16:06:44 <roconnor> :)
16:06:58 <edwardk> CPS (State s) a -- is something that doesn't make someone run screaming
16:07:35 <edwardk> or maybe WarmFuzzy (State s) a
16:07:43 <hatds> I'll have to try newtyping MTs, but so far I've gotten by using the strategy of breaking functions down further
16:08:12 <glguy> hatds, working with raw stacks of transformers and manually lifting is doing it wrong
16:08:14 <Philippa> PeakerWork: in general, I think inheritance is a lot like "imagine I had an applicative, only with no pure..."
16:08:19 <edwardk> hatds: you only need lift if you need more than one state, env or writer.
16:08:30 <Saizan> how is Ran pronounced? you could name it RunFaster :)
16:08:35 <Philippa> where the applicative's job is just to lift
16:08:35 <edwardk> or to liftIO to use io operations in wrapped IO
16:08:50 <edwardk> heh, clearly i should just name it 'Run' =)
16:09:19 <Philippa> edwardk: aside from liftIO, you don't even need it then. FFS, just name the layers and give them proper accessors already
16:09:20 <PeakerWork> Philippa: class Lift f where f (a -> b) -> f a -> f b ?
16:09:46 <PeakerWork> Yeah, I hate the various "liftX"ers (except liftIO maybe)
16:09:59 <edwardk> Philippa: thats what get/put/tell/ask/etc are for =)
16:10:00 <PeakerWork> liftState $ ...  is less meaningful than  liftGUIState .... anyway
16:10:16 <PeakerWork> liftGUIState . modify $ ...
16:10:38 <edwardk> i tend to just make my state more complicated rather than make multiple state layers
16:11:04 <hatds> class Wraps a b where unwrap :: b->a   --wonders if this is ever used to flatten nested types
16:11:11 <roman> hello there
16:11:33 <roman> quick question, is there a way to list all the functions of a module on ghci?
16:11:44 <roman> like looking around modules info
16:11:45 <mdmkolbe> @hoogle mkTyConAp
16:11:45 <lambdabot> Data.Typeable mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
16:11:53 <roman> ?
16:12:58 <edwardk> Saizan, roconnor: hrmm shall i just rename it CPS and call it done?
16:13:00 <Asztal> roman: :browse
16:13:18 <edwardk> since the notation is slightly wrong to call it Ran anyways
16:13:23 <Asztal> e.g. :browse Data.List
16:13:37 <edwardk> i was going to call it RanT, but the gratuitous T in there drove me nuts
16:13:43 <roman> Asztal: ohh... just what I needed, thanks man :-)
16:13:45 <PeakerWork> edwardk: I think its nicer to have multiple state layers (allows you to separately decide to make some of that state read-only, or whatever)
16:13:55 <PeakerWork> edwardk: even if you just one state -- its still nicer to name it
16:14:04 <roman> Asztal: do you know where I can find a summary of all the ":" options of the ghci prompt?
16:14:26 <Asztal> roman: I think most of it is in :help
16:14:45 <hatds> roman: is :help what you want?
16:14:49 <Asztal> but http://www.haskell.org/ghc/docs/latest/html/users_guide/ will have most info
16:15:11 <roman> yeap... that's all I will probably need
16:15:12 <Saizan> do you know if there's an easy way to tell if the Int closuers in my heap profile are thunks or evaluated?
16:15:13 <roconnor> edwardk: sounds like it is more CPS and less Ran.  Ran is simply a tool for achieving CPS.
16:15:15 <roman> thanks both of you
16:16:11 <dcoutts> pejo: what do you mean by compiler obligations? there's some mention in the Cabal spec the things the compilers should do
16:16:52 <edwardk> roconnor: most importantly for me i think is that 'Ran' in monad-ran is all about maintaining that (a -> ... -> o) -> ... -> o -- form than anything else -- there are right kan extensions that don't have that form, i.e. the implementation for Cont/ContT, etc. that is in there but they break the ability to use the transformer stack on the stuff 'below them'
16:17:46 <roconnor> edwardk I don't even know what a right kan extension is
16:18:38 <edwardk> i'm thinking it might be nice to carry a type level witness in RanFunctor that indicates if G m ~ H m -- and hence that the generic codensity definitions can be used instead of the more painful specific ones i need for most monad transformers
16:18:53 <edwardk> that would let StateT, WriterT, and a few other transformers run faster than they do currently
16:19:36 <edwardk> as long as they are wrapping a kan extension which is in 'codensity form'
16:19:52 <pejo> dcoutts, not sure myself, but I think I'd like to borrow the infrastructure with cabal tools that you've built. Pondering whether a compiler needs modifications for leveraging cabal.
16:20:14 <edwardk> roconnor: just look at the type forall o. (a -> f o) -> g o -- for a second what do you get 'for free'?
16:20:27 <dcoutts> pejo: sadly it usually does, though often you can copy an existing compiler module
16:20:31 <edwardk> roconnor: you get the fact that you can define a Functor for it regardless of the definitions of 'f' and 'g'
16:20:43 <roconnor> oh man
16:20:43 <edwardk> roconnor: but otherwise you're more crippled than with Codensity f.
16:20:49 <roconnor> It's Yoneda on steroids
16:20:54 <dcoutts> pejo: oh, wait, other way around. You need to modify Cabal to have it grok your new Haskell compiler.
16:21:12 <edwardk> yeah: Yoneda is Ran Identity
16:21:36 <dcoutts> pejo: there should not be much change needed in the compiler to have Cabal use it (though more change in one might mean less required in the other)
16:21:45 <roconnor> edwardk I'd like to see some examples where f and g are totally different
16:22:03 <edwardk> http://comonad.com/reader/2008/kan-extensions-ii/
16:22:31 <pejo> dcoutts, any idea how big cabal modifications necessary? (1 day, 1 week, 1 month of effort?
16:22:58 <dcoutts> pejo: somewhere between a day and a week
16:23:05 <edwardk> roconnor: you can use the trivial void functor to take a categorical limit as a right kan extension as well
16:23:45 <dcoutts> pejo: and asking me is a good place to start, but not now! I'm off to bed :-) g'night
16:24:02 <pejo> dcoutts, cheers!
16:25:00 <edwardk> roconnor: i.e. given data Trivial a -- with no constructors. Ran Trivial f a ~ forall o. (a -> Trivial o) -> f o -- but since you get no information from (a -> Trivial o) since all the function can do is return bottom, thats equivalent to Ran Trivial f o ~ forall o. f o
16:25:06 <edwardk> a categorical limit of f.
16:25:16 <sshc> t
16:26:20 <edwardk> so given type Limit = Ran Trivial -- you can see that Limit [] -- can only contain [], Limit Maybe contains Nothing, etc. (without counting the 'cheating' bottom members infesting each type)
16:28:12 <roconnor> edwardk: yep
16:28:35 <edwardk> Given the adjunction f -| g, you can show that f ~ Ran g Identity and Lan f Identity ~ g
16:29:39 <edwardk> which means you can then compose a monad since f -| g gives rise to the monad g `O` f, which is isomorphic to g `O` Ran g Identity
16:31:55 <Saizan> so with g = s -> - and f = (s,-) you get CPS'ed State?
16:32:00 <roconnor> edwardk: still all your examples are of the form where f and g are the same, or one is Identity or one is Void
16:32:25 <roconnor> edwardk: what if I make f = [] and g = State s
16:32:36 <roconnor> what is Ran [] (State s) ?
16:33:04 <byorgey> edwardk: you said Biff (,) Void Identity before, but  Void :: *
16:33:04 <edwardk> so if we take that adjunction to be the prod/hom adjunction: (,)e -| (->)e then we can find that State e a ~ ((->)e `O` Ran ((->)e) Identity) a ~ forall o. e -> (a -> e -> o) -> o
16:33:11 <edwardk> byorgey: VoidF
16:33:17 <byorgey> ah, VoidF, thanks =)
16:33:46 <edwardk> roconnor: i have no idea what that is =)
16:34:03 <byorgey> edwardk: where is VoidF defined?
16:34:16 <roconnor> edwardk:  :)
16:34:21 <edwardk> roconnor: there are other examples, lets look at some spin on ErrorT in monad-ran
16:34:40 <edwardk> i.e. Ran (ErrorT e IO) a
16:34:59 <roconnor> edwardk: kind error
16:35:21 <roconnor> er
16:35:27 <roconnor> which Ran are we talking about now
16:35:45 <edwardk> roconnor: the monad-ran Ran aka CPS =)
16:36:02 <roconnor> oh, i wanted to talk about the real Ran now.
16:36:08 <roconnor> but go on
16:36:39 <edwardk> that should look like forall o. (a -> State# RealWorld -> o) -> (e -> State# RealWorld -> o) -> State# RealWorld -> o
16:36:50 <edwardk> note that the two functors are different now
16:37:02 <roconnor> oh
16:37:02 <edwardk> and neither is Identity
16:37:08 <roconnor> nice
16:37:36 <roconnor> except I don't buy that IO is State# RealWorld.
16:37:38 <roconnor> :P
16:38:18 <edwardk> roconnor: State# RealWorld -> (# a, State# RealWorld #) cps transformed ala State.
16:38:52 <roconnor> stupid real world
16:39:11 <edwardk> Ran (ReaderT r (ErrorT e (State s))) a ~ forall o. (a -> s -> o) -> (e -> s -> o) -> r -> s -> o -- then =)
16:39:47 <roconnor> \o/
16:40:12 <roconnor> @unmtl ContT o (ReaterT r (ErrorT e (State s))) a
16:40:12 <lambdabot> (a -> ReaterT r (ErrorT e (State s)) o) -> ReaterT r (ErrorT e (State s)) o
16:40:27 <roconnor> @unmtl ContT (ReaterT (ErrorT (State s) e) r) o a
16:40:27 <lambdabot> (a -> o (ReaterT (ErrorT (State s) e) r)) -> o (ReaterT (ErrorT (State s) e) r)
16:41:06 <roconnor> @kind ContT
16:41:07 <lambdabot> * -> (* -> *) -> * -> *
16:41:20 <roconnor> @kind ReaderT
16:41:22 <lambdabot> * -> (* -> *) -> * -> *
16:41:29 <byorgey> roconnor: do you mean 'ReaderT'?
16:41:35 <edwardk> the ContT form looks like (a -> r -> s -> Either e (a,s)) -> r -> s -> Either e (a,s)
16:41:37 <roconnor> @unmtl ContT (ReaderT (ErrorT (State s) e) r) o a
16:41:37 <lambdabot> (a -> o (ReaderT (ErrorT (State s) e) r)) -> o (ReaderT (ErrorT (State s) e) r)
16:41:45 <roconnor> oops
16:41:49 <roconnor> @unmtl ContT o (ReaderT r (ErrorT e (State s))) a
16:41:50 <lambdabot> (a -> r -> s -> (Either e o, s)) -> r -> s -> (Either e o, s)
16:42:03 <roconnor> whoa
16:42:16 <edwardk> notice the unsavory Either (which is broken apart into two separate continuations in the Ran form
16:42:17 <roconnor> Codensity totally failed on Either.
16:42:39 <roconnor> that's pretty damn compelling
16:42:43 <edwardk> similarly i break apart Maybe in CPS Maybe a ~ Ran Identity Endo a
16:43:11 <edwardk> which is a right kan extension of a non-Hask functor.
16:43:30 <edwardk> Maybe a ~ forall o. (a -> o) -> o -> o
16:44:33 <roconnor> yep
16:45:22 <edwardk> i had fun going through the mental gymnastics to get everything into that form
16:45:29 <edwardk> i was greatly amused when the entire MTL fell into line
16:47:00 <edwardk> and then IO, STM, and ST s followed suit and i was positively giddy
16:47:26 <roconnor> @src IO
16:47:26 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:47:33 <roconnor> so you break that  appart?
16:47:51 <Saizan> did you find some monad that doesn't translate?
16:47:57 <edwardk> yeah into (a -> State# RealWorld -> o) -> State# RealWorld -> o
16:48:07 <roconnor> Sound dangerous
16:48:23 <edwardk> roconnor: nah, its just a cps transform of the IO state monad
16:48:29 <roconnor> Are you sure that (# a,b #) is similar enough to (a,b) to do this?
16:49:01 <roconnor> edwardk what does Cont c become?
16:49:03 <roconnor> :)
16:49:05 <edwardk> roconnor: yeah its just a box
16:49:11 <roconnor> @unmtl ContT o (Cont c) a
16:49:11 <lambdabot> (a -> (o -> c) -> c) -> (o -> c) -> c
16:49:22 <edwardk> Codensity (Const r)
16:49:39 <roconnor> Const or Cont?
16:49:41 <edwardk> Saizan: none so far, but they can exist
16:49:43 <edwardk> Const
16:49:54 <roconnor> @unmtl ContT o (Const c) a
16:49:54 <lambdabot> (a -> Const c o) -> Const c o
16:50:05 <edwardk> forall o. (a -> Const r o) -> Const r o ~ (a -> r) -> r
16:50:42 <roconnor> that's just Cont r again
16:50:48 <roconnor> oh
16:50:49 <roconnor> wait
16:50:49 <edwardk> yep, no magic
16:50:53 <roconnor> ya
16:50:57 <roconnor> so it does nothing
16:51:02 <roconnor> which is what I figured
16:51:27 <edwardk> sure, i don't bother doing anything other than re newtyping a Codensity when i run it into the CPS transformer, the goal of that is to 'just make sure we cps transform once'
16:51:42 <roconnor> I think we are going to need lambda expressions the type type level soon.  All this combinator programming is getting out of hand.
16:51:59 <dino-> I'm getting a "Failed to load interface.." error from building something that's using tagsoup. I'm not sure what to do about it yet.
16:52:08 <vixey> they should just allow partially applied type synonyms
16:52:14 <dino-> What is it trying to tell me, given that I do have tagsoup-0.7 installed
16:52:14 <dino-> ?
16:52:23 <vixey> it'll be ones own fault if typechecking never ends
16:52:40 <glguy> typechecking never ends \o/
16:52:52 <glguy> won't someone think of the children?
16:53:14 <edwardk> one thing i liked was cps transforming writer let me express it more efficiently as cps'd state than writer because in cps'd form i can plumb the 'mempty down through the state and only mappend when needed and leave it unmolested partially applied further down the stack
16:53:32 <edwardk> when its not in use, so writer-as-state can be more efficient than writer
16:54:13 <edwardk> forall o. (a -> w -> o) -> o -- would be a 'faithful' translation of writer, forall o. (a -> w -> o) -> w -> o -- is the way i implemented it though
16:54:28 <edwardk> since it avoids a ton of 'mappend mempty' nonsense
16:54:56 <dolio> You could do the same thing without cps.
16:55:07 <edwardk> yeah
16:55:17 <edwardk> but it seems to be a win with the cps and not without
16:55:18 <dmwit> edwardk: That needs more '.'s.
16:55:27 <dolio> You'd still be constructing and destructing tuples of course.
16:55:53 <edwardk> of course its all a matter of how expensive mappend mempty is for your monoid
16:57:13 <persica> Hrm, what flat-file format would you recommend for storing data in haskell?  I'm trying to associate a few tits of data with URIs.
16:57:36 <persica> There aren't any parsers in the standard libraries it appears.
16:57:40 <dons> read/show
16:57:46 <dons> parsec/ readp
16:57:51 <dons> Data.Binary.get/put
16:58:00 <dons> on hackage there are many others (e.g. json, ConfigFile)
16:58:04 <dons> xml..
16:58:13 <dons> read / show is the simplest.
16:58:21 <persica> read-show is viable...  Woudl have to write a reader for URIs.
16:58:39 <persica> I haven't leared about parsec yet, though I've heard it mentioned a few times.
16:59:51 <dolio> Yay, my agda install no longer things all functions are injective.
17:00:10 <Elly> injective functions are better anyway :)
17:01:12 <dmwit> persica: Why not just use String for the URI bit?
17:01:32 <dmwit> persica: Oh, is URI an actual data type, and not just a String?
17:01:34 <dmwit> ignore me
17:03:11 <dino-> hm, I get a totally different problem when I remove the tagsoup-0.6, leaving only the 0.7 in the ghc. Is that what this means, some sort of collision of versions of installed libs?
17:03:36 <dino-> The Failed to load interface
17:04:02 <Saizan> is the file there?
17:04:18 <persica> dmwit: Yeah, passing Network.URI.URI to Network.HTTP functions.
17:09:06 <tsLight> I am trying to convert a logic formula into CNF, after I eliminated implications and moved NOT's inwards, when I have "(p & q) | r" I change it to "(p | r) & (q | r)". But what should I do with the case "p | (q & r)"?
17:09:43 <dmwit> persica: Oh, it's stupid that Network.URI.URI doesn't have a Read instance.  All of its members are just String, except for uriAuthority, which is also a record with just String inside.
17:11:05 <dmwit> persica: Ah, I see, its Show instance isn't a real Show instance, it's a pretty-printer.
17:11:08 <dmwit> bummer
17:11:18 <kyevan> Wait...
17:11:30 <kyevan> What prevents you from doing something IO a -> a?
17:11:30 <persica> Yeah, shouldn't be hard to write one though
17:11:52 <dmwit> kyevan: There just aren't any axioms with that type.
17:12:12 <dmwit> tsLight: Same thing, I guess.  Logical or is commutative, no?
17:12:48 <kyevan> dmwit: foo IO x = x
17:12:49 <kyevan> ?
17:13:01 <dmwit> kyevan: Nope, IO is a type constructor, not a value constructor.
17:13:03 <tsLight> dmwit, p | (q & r) = (p | r) & (q | r) doesnt work
17:13:26 <kyevan> Oh.
17:13:28 <dmwit> tsLight: Why not?
17:13:40 <Saizan> tsLight: because it becomes (p | q) & (p | r)
17:14:13 <kyevan> You could just repeat that for every value constructor, couldn't you?
17:14:16 <Saizan> tsLight: the variable take different roles in the two examples
17:14:17 <tsLight> ah
17:14:21 <tsLight> you are right
17:14:24 <dmwit> kyevan: There are no value constructors for IO.
17:14:33 <dmwit> kyevan: They're kept hidden in the implementation.
17:15:41 <kyevan> Oh. So it breaks the rules is why you can't, basically?
17:16:12 <Saizan> kyevan: something of type (IO r) doesn't contain an 'r' inside it either
17:16:32 <Saizan> kyevan: it's an action that when executed by the runtime will produce an r
17:16:44 <kyevan> ... So, again, it's breaking the 'rules' of types?
17:16:49 <kyevan> You could just say that >_<
17:17:01 <dmwit> I'm not clear on which rules you're talking about.
17:17:05 <Saizan> yeah
17:17:27 <kyevan> Well, maybe not /rules/, per se, but... expectations.
17:17:29 <dmwit> Here's the thing:
17:17:32 <Saizan> even with no rules you couldn't extract an 'r' from there
17:17:54 <dmwit> "IO a" is a type; it is a different type from "a"; and it need not have any special relationship to the type "a", even though it mentions "a"'s name.
17:17:59 <Saizan> (except for IO actions that constructed with only return)
17:18:24 <dmwit> Expecting that you can write a conversion function between two types that need not really have any special relationship is, well... expecting too much. =)
17:18:25 <kyevan> And, doesn't that make it rather useless?
17:18:31 <kyevan> I mean...
17:18:55 * roconnor has written data Channel i a = Channel a
17:18:56 <kyevan> + doesn't work on IO Int, it works on Int
17:19:00 <roconnor> mmm phantom types
17:19:11 <dmwit> kyevan: It's useful because...
17:19:17 <cocopumpkin> you should make a Num instance for arbitrary Monad instances, if their contents is a Num
17:19:18 <cocopumpkin> ;)
17:19:30 <dmwit> Although you can't extract an "a" value from an "IO a" value, you can lift an "a" value into an "IO a" value.
17:19:37 <Saizan> kyevan: you use do-notation or (>>=) to get access to the future Int from an IO Int
17:19:44 <dmwit> In particular, you can lift an "a -> b" function into an "m a -> m b" function.
17:19:45 <kyevan> Oh, yay. You can put numbers out.
17:19:46 <cocopumpkin> yeah, (+) = liftM2 (+) maybe
17:19:52 <kyevan> Without input, it's still useless.
17:19:55 <kyevan> Oh.
17:20:08 <roconnor> cocopumpkin: for arbitrary applicative functors
17:20:17 <dmwit> So you can still have your functions act on values in the monad by putting them in. =)
17:20:23 <Saizan> ?type \ma mb -> do a <- ma; b <- mb; return (a+b)
17:20:25 <lambdabot> forall (t :: * -> *) t1. (Monad t, Num t1) => t t1 -> t t1 -> t t1
17:20:39 <Saizan> ?type \ma mb -> do a <- ma; b <- mb; return (a+b) :: IO Int -> IO Int -> IO Int
17:20:40 <cocopumpkin> roconnor: yup
17:20:40 <lambdabot>     No instance for (Num (IO Int -> IO Int))
17:20:40 <lambdabot>       arising from a use of `+' at <interactive>:1:39-41
17:20:40 <lambdabot>     Possible fix:
17:20:44 <kyevan> ... this is all very confusing >_>
17:21:04 <Saizan> ?type (\ma mb -> do a <- ma; b <- mb; return (a+b)) :: IO Int -> IO Int -> IO Int
17:21:06 <lambdabot> IO Int -> IO Int -> IO Int
17:21:07 <dmwit> Actually, I guess my explanation was a little bit wrong.  But!
17:21:11 <Philippa> kyevan: the idea is to never let you directly "take the Int out"
17:21:33 <Philippa> that way, anything that came from IO can't masquerade as a pure function
17:21:40 <dmwit> kyevan: I strongly recommend sigfpe's article on monads.
17:22:17 <Saizan> or Monads as computations on the wiki
17:23:23 <dmwit> One thing that took me a while to understand was that there are actually three classes of things here: monads in general, specific monads (like IO), and specific functions that behave a specific way in a specific monad (like getLine).
17:24:09 <Peaker> I don't think you really have to understand the general idea of monads to just understand IO values and their binding together
17:24:29 <dmwit> Nope.
17:24:33 <Peaker> I have had great success explaining the IO monad as a sticky note with a TODO list on it and a result value type written on its corner :)
17:25:10 <Peaker> and >> as just putting two sticky notes together, and >>= as two sticky notes with an arrow from the corner of the first, representing a function between them
17:26:08 <Saizan> IO (IO a) a TODO list to make a TODO list
17:26:19 <Peaker> yeah :-)
17:27:26 <Peaker> kyevan: did you follow that explanation?
17:27:50 * dmwit bets on no
17:28:09 <dmwit> There were a lot of important missing details there. =P
17:29:13 <Peaker> dmwit: about "return"?
17:29:26 <kyevan> Eehhh...
17:29:35 <Peaker> dmwit: I think its a good first-order approximation
17:29:45 <Peaker> kyevan: Can you envision a sticky note with a TODO list on it? :)
17:29:53 <kyevan> Yeah. :P
17:29:58 <dmwit> Peaker: I agree, it just needs fleshed out a bit more. =)
17:30:09 <kyevan> I'm just trying to figure out how 'traditional' methods get involved here...
17:30:48 <kyevan> Is it like Maybe where you have to write wrappers for everything? Except you can't get at it, so you can't even do that... >_>
17:31:46 <Saizan> have ever used Maybe as a monad?
17:31:51 <Saizan> *you
17:32:05 <Peaker> kyevan: Unlike Maybe, IO only allows you to "get the value out" into a pure computation if you end up re-wrapping the result in IO
17:32:06 <kyevan> uh... wha?
17:32:33 <Saizan> kyevan: Maybe is a Monad too
17:33:09 <Saizan> kyevan: and probably the wrappers you're talking about fall in the Monad interface
17:33:15 <Peaker> kyevan: the basic thing is that pure computations can be done anywhere, even inside side-effecting actions, but the vice-versa is false - pure computations cannot perform actions
17:33:17 <Saizan> kyevan: do you have an example?
17:33:47 <adamvo> kyevan: if you could get at constructors for IO, you could mess things up in terms of things happening out of order or not at all (cf. unsafePerformIO)
17:34:03 <Peaker> kyevan: To enforce this restriction -- action results have a different type that only allows you to use them in a restricted way - inside other actions, but not inside pure computations
17:34:08 <kyevan> I just, do things like maybeplus Just a Just b = Just a + b; maybeplus Nothing _ = Nothingl; maybeplus _ Nothing = Nothing;
17:34:41 <Peaker> kyevan: maybeplus (Just a) (Just b) = Just (a+b) ; maybeplus Nothing = Nothing -- right?
17:34:43 <kyevan> Only without typos :P
17:35:00 <Peaker> kyevan: Now, why only support plus? Why not subtract, or any other function?
17:35:21 <kyevan> Peaker: Uh... I usually do those too.
17:35:24 <adamvo> > liftM2 (?op) (Just 3) (Just 2)
17:35:26 <lambdabot>       Unbound implicit parameter (?op::a1 -> a2 -> r)
17:35:26 <lambdabot>        arising from a u...
17:35:33 <Saizan> kyevan: exactly, since Maybe is a Monad (like IO) you can write that as: maybeplus ma mb = do a <- ma; b <- mb; return (a+b)
17:35:34 <Peaker> kyevan: maybemap f (Just a) (Just b) = Just (f a b) ; maybemap f Nothing = Nothing
17:35:37 <adamvo> ?type liftM2 (?op) (Just 3) (Just 2)
17:35:38 <lambdabot> forall a1 a2 r. (Num a2, Num a1, ?op::a1 -> a2 -> r) => Maybe r
17:35:40 <kyevan> Copy and paste and edit, yo. :J
17:35:52 * Peaker was trying to develop liftM2 slowly, from the less general form
17:35:55 <Peaker> but I guess, NM
17:36:13 <kyevan> whuu....?
17:36:16 <adamvo> save the copy and paste
17:36:17 * kyevan is totally confused...
17:36:30 <Peaker> kyevan: The idea of applying a function inside a Maybe is not unique to maybes, you might want to do it in various other "container" types,  so its generalized
17:36:45 <Peaker> kyevan: Do you know type classes?
17:36:58 <kyevan> Uh... don't think so...
17:36:59 * adamvo is probably not helping here
17:37:09 <kyevan> Meh.
17:37:23 <kyevan> I'm probably just trying to piece together too much too fast. :P
17:37:28 * kyevan takes a couple steps back
17:37:31 <Peaker> kyevan: well, maybe you should read about type-classes before carrying on
17:37:38 <kyevan> And goes back to reading :J
17:38:35 <Peaker> kyevan: basically, they are a (neat!) mechanism to generalize functions so they can implement the same ideas (semantics) on different types.  Ideas like "apply this function 'inside' the type, on the type parameter"
17:39:23 <Peaker> kyevan: so you get a function that works on many types, and is not specific to (Maybe Int) or (Maybe a)
17:40:06 <kyevan> But you still have to be able to get the value out somehow, even if only temporarily... ?
17:40:31 <adamvo> ?type (=<<)
17:40:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:40:34 <Peaker> kyevan: well, the specific implementation of the operation worries about that
17:40:48 <Peaker> kyevan: type-classes allow people to write different implementation code for each type
17:41:03 <Peaker> @src Maybe (>>=)
17:41:03 <lambdabot> (Just x) >>= k      = k x
17:41:03 <lambdabot> Nothing  >>= _      = Nothing
17:41:36 <Peaker> kyevan: so (>>=) indeed gets the value "out" of the Maybe "temporarily". But other implementations for other types might work differently
17:42:16 <kyevan> Ungh... it seems to me that this is all just a hell of a lot more complicated than it needs to be >_<
17:42:19 <dino-> I'm looking at upgrading to 6.10.3. What is the libtinfo.so.5 for? I'm wondering if I should try to install that or use the -n ghc.
17:42:49 <Peaker> kyevan: its not complicated - its abstract.  Generalizations tend to make things more abstract
17:43:13 <sshc> .
17:43:22 <Peaker> kyevan: Its not supposed to be understood in 5 minutes, definitely not without reading about type-classes :)
17:43:28 <kyevan> Yeah, but why does "print 4" need to be abstract, really? >_>
17:43:32 * kyevan shrugs
17:43:41 <Peaker> kyevan: print 4 is not very abstract
17:44:04 <Peaker> kyevan: but if you use abstract operations instead of very concrete ones to build your program, you need less operations in your mental namespace to work with
17:44:25 <kyevan> Peaker: Well, yes, but then you get to things like, well, "read two numbers, sum them, and output the sum"
17:44:35 <Peaker> kyevan: The idea of "sequencing computations" together is more general and powerful than the idea of sequencing Maybe computations together, sequencing IO computations together, etc
17:44:45 <Saizan> kyevan: if you'd like a more concrete exposition you can read this: http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
17:45:08 <Peaker> kyevan: You can use the very concrete:  main = do { x <- readLn ; y <- readLn ; print (x+y) }
17:45:12 <kyevan> It seems to me that that's nearly-imposible in haskell, where as it's nearly trivial in, well, anything else. Including most other functional languages, unless my memory is really broken. >_>
17:45:30 <Peaker> kyevan: but if you grok the more abstract ideas, then: main = liftM2 readLn readLn >>= print  -- makes a lot of sense
17:45:42 <dino-> eh, nm. I can't find any mention of libtinfo.so.5 in any version of Debian from stable to sid. So apparently it's not for me.
17:46:44 <Saizan> kyevan: it's trivial in haskell too, read that blog post
17:47:46 <cocopumpkin> could I write a Bool instance of Monad that basically was const True or const False for all operations?
17:47:47 <Peaker> that was: main = liftM2 (+) readLn readLn >>= print      btw (it basically means: Use pure (+) on two readLn computations to get a sum computation, sequence that computation with printing
17:47:59 <Peaker> cocopumpkin: Bool is not a class? You mean Eq?
17:48:09 <Peaker> oh, whoops
17:48:15 <Peaker> copumpkin: you meant other way around :)
17:48:18 <cocopumpkin> sorry, my language was kind of backwards :)
17:48:18 <cocopumpkin> yeah
17:48:30 <Peaker> copumpkin: Bool has the wrong kind to be a monad
17:48:34 <kyevan> yeah... but then I know that there's more to it and it bugs me not getting that to the point that I can't use do without getting angry :P
17:48:38 <cocopumpkin> how about a Bool wrapper with a phantom type
17:48:39 <Peaker> copumpkin: Bool::*,  Monad instances are *->*
17:48:40 <cocopumpkin> :P
17:48:58 <cocopumpkin> or something isomorphic to bool, with a phantom type
17:49:01 <Peaker> copumpkin: I think any habitable type forms a null/void/trivial monad that way
17:49:05 <adamvo> cocopumpkin: instance Monad ((->) Bool) ?
17:49:05 <cocopumpkin> data Boolish a = Yes | No
17:49:07 <cocopumpkin> ok
17:49:24 * cocopumpkin is good at trivial stuff
17:49:26 <Peaker> copumpkin: its not a very interesting monad instance, though
17:49:37 <cocopumpkin> I wasn't expecting it to be :P
17:50:52 <cocopumpkin> maybe I should wear cochanel
17:50:59 <cocopumpkin> cochanel#5?
17:52:59 * cocopumpkin wants dependent haskell
17:54:06 <cocopumpkin> with a pragma that says "yo, if you can't prove the dependent type on this expression, don't feel too bad about it!"
17:54:15 <cocopumpkin> :P
17:55:55 <ray> haskell is hard, let's go write php
17:56:35 <kyevan> php is hard, let's go write brainfuck
17:59:07 <skorpan> a couple of days ago i pushed a whitespace mode for yi
17:59:10 <skorpan> let's write whitespace
18:00:12 <kyevan> Whitespace is great. You can print it and ship it in the mail and no one will ever suspect it contains TOP SECRET code!
18:00:47 <mokus> kyevan: plus, you can scale any amount of code to just one page, without loss of readability!
18:01:05 <kyevan> Yeah!
18:04:51 <kyevan> Also...
18:05:29 <kyevan> I'm correct in thinking that Haskell lacks variables, having only constants (and arguments, which are constant per application of the function), right?
18:06:12 <skorpan> i like to think that everything's a value
18:06:36 <kyevan> heh, or maybe everything's a macro...
18:06:47 <true\false> Haskell is Harb..
18:06:53 <true\false> Shame I can't learn it.
18:07:32 <kyevan> You could theoretically create one monstrous expression the size of Uranus. :P
18:08:10 <MyCatVerbs> kyevan: you could. You can. You can even create infinitely long expressions if you feel like it, but you won't be able to hold the whole thing in memory at once if you do.
18:08:29 <kyevan> MyCatVerbs: Much less type the entire thing.
18:08:39 <MyCatVerbs> Heh.
18:09:51 <MyCatVerbs> kyevan: FWIW, for situations where you really do need global state, there are things like IORef in the standard library.
18:10:53 <kyevan> MyCatVerbs: Nono, I was more thinking that in the sense of "Is my guess correct" than "this is annoying" :P
18:11:24 <Cale> But even IORefs aren't really global state, they're state which you explicitly pass references to :)
18:11:49 <kyevan> It lets you do things like sticking something you use three or for times in a name, to remind the computer to eval it once and hold on to it for the next time it's needed, though, that's good :J
18:12:02 <MyCatVerbs> Oh yes, my bad. s/global/mutable/, lack of good support for global state is one of Haskell pitfalls, IMO. ;P
18:12:22 <MyCatVerbs> *Haskell's, even.
18:12:45 <kyevan> That's what something like 90% of variables in other languages anyway. Well that and iteration variables, but I usually rewrite to recursion in my head anyway :J
18:13:49 <Cale> s/pitfalls/features/
18:13:49 <dmwit> Yes, it's correct, there are only constants.
18:14:06 <Cale> global state is bad :)
18:14:19 <kyevan> Aanyway, haskell strikes me as something that's very good at some problems and very bad at others. As opposed to mediocre at most everything, like some other options.
18:14:28 <kyevan> But I might just not 'get it' yet.
18:14:46 <dmwit> Be careful with the "only evaluated once" thing, though, it can be more complicated than that when you add in functions and polymorphism.
18:15:11 <kyevan> Heh, it hints at it, anyway :J
18:15:46 <kyevan> A bad cooompiler can make any code break, but even a good one needs hints now and then.
18:20:33 <MyCatVerbs> Cale: No it isn't. In practice, "global" is actually "process local". If I want to branch off two different versions of my C programs' global state, the solution is only a fork(2) away.
18:21:13 <Cale> Huh? It doesn't make global state a good thing.
18:23:08 <Cale> Global state (or even process local state), makes the functioning of a program harder to understand than it needs to be.
18:24:55 <MyCatVerbs> Depending on your problem domain, not in the least. Quite the opposite, even.
18:25:00 <Cale> Even with IORefs, if some function wants to access an IORef, then it will need to take that as a parameter, making the piece of state on which it depends explicitly documented by its type, which I consider a good thing.
18:26:48 <Cale> There are problems like that the entire filesystem is accessible through the IO monad and can act as a way to pass state around, but that's easier to avoid abusing.
18:27:18 <Cale> (though it would be nice to have a refinement of IO)
18:28:27 <Peaker> Cale: or a refinement of ambient authority in OS's in general!
18:28:29 <MyCatVerbs> Cale: okay, concrete example. I have a videogame in which robots wander around and shoot at each other. If I encapsulate all of the state nicely, then I have the issue that every time I want to add an interesting feature, I have to either chip away some of the encapsulation and introduce a cycle in the communication graph or refactor the program to elimiante it.
18:29:01 <Peaker> MyCatVerbs: what about Reactive-style FRP?
18:29:54 <necroforest> clearColor :: StateVar (Color4 GLclampf)
18:29:58 <necroforest> what's a StateVar?
18:30:01 <MyCatVerbs> Peaker: bit experimental for the moment.
18:30:05 <Peaker> @hoogle StateVar
18:30:06 <lambdabot> No results found
18:30:22 <Cale> necroforest: It's an abstraction which the OpenGL library uses around various mutable things
18:30:23 <Peaker> MyCatVerbs: also, instead of a "global variable" just use a monad transformer stack type that your entire game uses and modify that
18:30:41 <Peaker> The OpenGL library/Haskell wrapper really sucks :(  Segfaults all over the place
18:30:46 <MyCatVerbs> Peaker: right, and now we're back into everything-can-see-everything territory.
18:31:00 <Peaker> MyCatVerbs: except the stuff that's not in the monad
18:31:12 <Cale> MyCatVerbs: I don't understand at all what you mean by introducing a cycle in the communication graph.
18:31:13 <Peaker> MyCatVerbs: also, what's wrong with that as support for the global vars you wanted?
18:31:21 <necroforest> Peaker, i think you just mean the Haskell wrapper.
18:31:37 <Peaker> necroforest: probably :(
18:31:37 <MyCatVerbs> Cale: nodes are modules, classes, or however else you're dividing code up.
18:31:41 <Peaker> necroforest: not sure who's to blame
18:31:42 <Cale> MyCatVerbs: Just pass a reference to the new piece of state?
18:32:01 <Cale> MyCatVerbs: Or introduce the state into the existing datastructures being passed around
18:33:02 <persica> @hoogle
18:33:02 <lambdabot> No query entered
18:33:03 <lambdabot> Try --help for command line options
18:33:21 <Peaker> MyCatVerbs: via monad transformers, you get all the "globalness" you want in a pretty decent manner, IMO
18:33:51 <Peaker> MyCatVerbs: with the slight advantage that stuff is explicitly marked as "I can touch the global stuff" and you still get to be able to localize the global stuff for it (its not bound to a single global thing that can't be forked)
18:34:18 <MyCatVerbs> Peaker: but I can *still* fork so-called single global things. fork(2), remember?
18:34:20 <Cale> Well, and yeah, it's not really global, it's computation-local :)
18:34:30 <Peaker> MyCatVerbs: fork(2) is not a valid way to fork objects
18:34:38 <Cale> and *explicit* in the type
18:34:46 <Peaker> MyCatVerbs: it forces you to fork every other thing, too, and induces difficulties in communication, and also splits your control thread, etc
18:34:51 <Cale> So you know exactly what state is there.
18:34:59 <MyCatVerbs> Yes it is. Has worked just fine for C programmers of all descriptions for years now.
18:35:18 <Peaker> Cale: its still a very rough specification compared to what it could be without a big monad transformer stack
18:35:26 <Saizan> except that it doesn't work well with GHC's runtime :)
18:35:46 <Peaker> MyCatVerbs: fork(2) is not used to "fork global vars".. that's a byproduct
18:36:15 <MyCatVerbs> Peaker: concrete examples, please. *Why* would I want to have more than one copy of my game's simulation running in a single process?
18:36:37 <Peaker> MyCatVerbs: Testability, automation, multiplayer mode, ...
18:37:25 <Peaker> MyCatVerbs: its easier to test a function that has input and output than something that fiddles with some global environment
18:37:55 <Peaker> MyCatVerbs: You might want to instantiate your game in some other context for various automation/demonstration purposes
18:38:11 <Peaker> MyCatVerbs: Multiplayer mode might use multiple game instances showing simultaneously on screen
18:38:14 <MyCatVerbs> Peaker: if it's to host more than one game on a single machine, I can do that by fork()ing. All of the stuff you'd want to unit test in a game will reveal itself very, very quickly (and painfully) ingame as soon as you start playtesting. Automation of what? As for multiplayer mode, that tends to need to be built into the whole thing from scratch upwards anyway.
18:38:40 <Peaker> MyCatVerbs: fork()ing is not a very convenient or even portable way to do much
18:39:11 <Peaker> MyCatVerbs: it also entails a lot of performance costs
18:39:21 <Peaker> especially if you do it a lot
18:39:35 <MyCatVerbs> So don't. How many games ever need to?
18:40:07 <Peaker> MyCatVerbs: even a single fork causes any modification to any non-shared state to entail a COW. It causes sbrk shrinks in one process to not actually release any memory
18:40:33 * Peaker has to sleep
18:40:44 <pejo> Peaker, except that libc rarely gives memory back anyways.
18:41:01 <sjanssen> and GHC never does
18:41:05 <MyCatVerbs> Functions without side effects are easier to test, but that doesn't make any difference to the mountains of tightly-coupled crap that I'm going to end up with because my simulation consists almost entirely of code that *does* poke the global state all over the place.
18:41:13 <Peaker> pejo, sjanssen: Those 2 facts are pretty sad, IMO
18:41:24 <sjanssen> Peaker: agreed
18:41:58 <sjanssen> MyCatVerbs: a better question is: how is StateT any *less* convenient than global variables
18:42:20 <sjanssen> the benefits of encapsulating state are well known, are there any benefits to making it global?
18:42:23 <Peaker> sjanssen: requires liftIO'ing, I guess
18:42:58 <MyCatVerbs> sjanssen: I'll concede that.
18:43:26 <Peaker> sjanssen: MT's are a little more verbose
18:43:41 <sjanssen> Peaker: MT?
18:43:46 <Peaker> Monad Transformers
18:43:58 <sjanssen> not too much, IMO
18:43:58 <MyCatVerbs> Peaker: eh, it reduces to one enormous type synonym at the top of the file. Not much of an issue.
18:44:14 <Peaker> I agree its not much of an issue, but sjanssen asked for disadvantages :)
18:44:23 <sjanssen> and any complex application is going to want to use one of the other transformers at some point anyway (ErrorT for example)
18:44:28 <Peaker> You might have to sprinkle liftIO or other lifters in various places
18:44:46 <Peaker> sjanssen: IO already has ErrorT in it (yuck!)
18:44:52 <Peaker> well, sort of
18:44:58 <Peaker> (in the form of IO exceptions)
18:45:04 <MyCatVerbs> sjanssen: problem with encapsulating state inside StateT is th... actually, nevermind.
18:45:14 <sjanssen> liftIO should be the only required lift, all of MTL has automagic lifting
18:45:23 <Peaker> (I wish IO didn't have exceptions, or io-refs, or various other things that can be put in other monad transformers above it)
18:45:35 <sjanssen> xmonad's solution to liftIO is io = liftIO :)
18:45:58 <Peaker> sjanssen: I think magic lifting is a bad idea - I think you should explicitly specify which layer you want operations lifted to. I like having multiple StateT/ReaderT in my monad stack
18:46:16 <Peaker> sjanssen: not to mention the O(N^2) mess they make in the implementation side
18:46:37 <sjanssen> Peaker: even in that case you'll name each layer instead of calling lift: getWidget; setBaz; etc.
18:46:48 <MyCatVerbs> I was going to whinge about the necessity for mutable arrays, but thinking of the code I have sitting around, I see no reason why it should be a total *disaster* to use immutable arrays and copy the whole things out every simulation step, given that pretty much every single value inside the simulation gets changed every single frame.
18:47:18 <Peaker> sjanssen: I'd rather have O(layer count) lifters than O(layer count X combinator count) lifters.. instead of getWidget I'd have liftWidget $ ask ; so I can use various other useful combinators from the transformer there
18:48:25 <Peaker> So I don't have to copy all of getBaz,setBaz,modifyBaz, just: liftBaz $ modify (+1)
18:48:39 <Peaker> also, people already know what the various combinators like ask/get/put/modify do
18:49:01 <MyCatVerbs> It'd be really, really tempting to use GHC.Array.Base to make an "immutable" array type which allocates only two, and then "page flips" between them to avoid allocation.
18:49:44 <sjanssen> MyCatVerbs: sounds like the GC's job?
18:50:39 <MyCatVerbs> sjanssen: yes, but it'd require a "sufficiently smart" GC to be able to do that automatically without being explicitly informed that it was possible to do that. I'm not holding my breath waiting for one to crop up.
18:51:55 <MyCatVerbs> sjanssen: same attitude as abusing TH to get optimizations that, in a perfect world, the compiler would do for you, but it doesn't just yet. ;P
18:52:10 <sjanssen> MyCatVerbs: allocation is extremely cheap in GHC
18:52:24 <dolio> Forget about TH, the new hotness is abusing type families.
18:53:05 <sjanssen> MyCatVerbs: so what's the point in switching between specific arrays?  Cache friendliness?
18:53:12 <sjanssen> dolio: the real hot stuff uses both
18:53:41 <dolio> Well, I suppose you need template haskell to avoid writing 10 million instances manually.
18:54:13 <persica> Hrm, is there a good way to use QuickCheck to generate a list where all items in the list are unique within that list?
18:54:24 <dolio> I don't think template haskell supports type families until 6.12, though.
18:54:32 <coCocoa> Peaker: Quit wishing, and start writing a library. ;)
18:54:45 <MyCatVerbs> sjanssen: allocation's only cheap in the nursery, though. And cache warming *is* really nice to have.
18:55:35 <MyCatVerbs> sjanssen: really huge tables are going to blow past the nursery and go straight into the mark-sweep generation.
18:56:32 <monochrom> Yay, Haskell Weekly News!
18:58:15 <persica> bah! "nub" is such an odd name for a function that extracts unique elements.
18:58:56 <Twey> persica: It gets to the nub of the matter.
18:59:55 <harovali1> is anyone doing fancy stuff with parsers ?  like a visual parser generator ?  or even a system that parses or generates valid strings in the same grammar ? or somethiong equally wierd ? :-)
19:03:40 <fynn> Someone figured out the motivation behind Haskell's logo:
19:03:41 <fynn> http://www.gossipgamers.com/how-valve-got-half-lifes-logo/
19:04:48 <fynn> apparently we're pretty bad-ass here.
19:05:20 <monochrom> I inserted a delimited continuation into the stream given to a parser. This gives me a suspensible, resumable-in-many-ways parser.
19:06:04 <harovali1> monochrom: wow
19:14:13 <lepassive> is it ok to get capturedCount result == -2 ? in Regex.Light pcre ?
19:27:59 <fracture> noobish question:  is there a Prelude function to drop the last element off a list?
19:28:36 <fracture> (I guess I can write it)
19:28:40 <fracture> (if there isn't)
19:28:41 <mokus> fracture: init
19:28:54 <fracture> ah thanks
19:29:13 <mokus> fracture: careful, it dies on empty lists, like tail
19:29:40 <fracture> ah k
19:31:32 <roconnor> is there a ComonadTimes class?
19:32:08 <roconnor> @hoogle wtimes
19:32:08 <lambdabot> No results found
19:32:58 <roconnor> that would also make a good haskell newspaper
19:34:26 <xdie> hi all
19:34:38 <xdie> any can helpme to join lambdabot to #culturalibredigital
19:35:08 <xdie> @part #culturalibredigital
19:35:09 <lambdabot> Not enough privileges
19:36:08 <sjanssen> lambdabot: @join #culturallibredigital
19:36:52 <sjanssen> lambdabot: @part #culturallibredigital
19:37:06 <sjanssen> lambdabot: @join #culturalibredigital
19:37:10 <sjanssen> xdie: done
19:37:12 <xdie> @join #culturalibredigital
19:37:12 <lambdabot> Not enough privileges
19:37:24 <xdie> sjanssen, thanks!!
20:00:24 <fracture> can anyone help me with an error?
20:00:30 <fracture> I have:
20:00:34 <fracture> isSquare x = root == floor root
20:00:35 <fracture>     where root = sqrt x
20:00:38 <fracture> and get
20:00:47 <fracture>     Ambiguous type variable `t' in the constraints:
20:00:47 <fracture>       `Integral t' arising from a use of `isSquare' at List.hs:16:18-28
20:00:47 <fracture>       `Floating t' arising from a use of `isSquare' at List.hs:16:18-28
20:00:47 <fracture>       `RealFrac t' arising from a use of `isSquare' at List.hs:16:18-28
20:00:47 <fracture>     Probable fix: add a type signature that fixes these type variable(s)
20:00:56 <roconnor> @type floor
20:00:57 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
20:00:58 <fracture> what do I gotta do for that?
20:01:09 <roconnor> floor doesn't operate on Integral types
20:01:23 <heavensrevenge> hello
20:01:24 <roconnor> It works on things like Double and Float
20:01:26 <fracture> but sqrt returns a float, no?
20:01:33 <fracture> oh... only if its argument is a float?
20:01:44 <fracture> (thinking like C I guess)
20:01:48 <roconnor> and the float returns an integral type
20:01:52 <heavensrevenge> im not sure if this is appropriate for this channel, but ill be using haskell(haskell platform) in a new linux distro im creating
20:02:00 <MyCatVerbs> fracture: sqrt returns a Float if you feed it a Float, or a Double if you feed it a Double.
20:02:01 <roconnor> then you try to compare a floating type to an integral type
20:02:37 <MyCatVerbs> fracture: in C, you have two functions, double sqrt(double) and float sqrtf(float), for double and single-precision, respectively.
20:03:10 <MyCatVerbs> fracture: Haskell uses typeclass overloading to give you the same name for both of those functions, and type inference to work out which one it needs to give you where. Nifty, isn't it?
20:03:20 <fracture> sure
20:03:24 <fracture> it's like std::floor in C++
20:03:37 <fracture> but still not sure how to do what I'm trying to do :D
20:03:47 <MyCatVerbs> What're you trying to do? *scrolls up, reads*
20:04:08 <fracture> find out if a number is a square number
20:04:17 <roconnor> what type of number?
20:04:30 <Saizan> isSquare x = root == fromIntegral (floor root) where root = sqrt (fromIntegral x)  -- if x is Integral
20:04:32 <fracture> integer
20:04:58 <roconnor> @let isSquare x = root == fromIntegral (floor root) where root = sqrt (fromIntegral x)  -- if x is Integral
20:05:00 <lambdabot>  Defined.
20:05:31 <roconnor> @check \x -> isSquare (x*x :: Integer)
20:05:32 <lambdabot>   Not in scope: `isSquare'
20:05:41 <roconnor> damn it I defined it up there!
20:05:45 <fracture> hehe
20:06:09 <roconnor> @check \x -> let isSquare x = root == fromIntegral (floor root) where root = sqrt (fromIntegral x) in isSquare (x*x :: Integer)
20:06:10 <lambdabot>   "OK, passed 500 tests."
20:06:15 <roconnor> :/
20:06:16 <Saizan> > isSquare (4 :: Int)
20:06:17 <lambdabot>   True
20:06:56 <roconnor> > isSquare (10000000000^2 :: Integer)
20:06:57 <lambdabot>   True
20:07:04 <roconnor> > isSquare (10000000000000^2 :: Integer)
20:07:05 <lambdabot>   True
20:07:18 <roconnor> > isSquare (10000000000000000000000^2 :: Integer)
20:07:20 <lambdabot>   True
20:07:23 <fracture> cool
20:07:23 <mgsloan> > isSquare (934857322345873826^2 :: Integer)
20:07:24 <lambdabot>   True
20:07:29 <roconnor> > isSquare (10000000000000000000000^2 -1  :: Integer)
20:07:30 <lambdabot>   True
20:07:35 <fracture> > isSquare (3 :: Integer)
20:07:36 <lambdabot>   False
20:07:49 <roconnor> > isSquare (10000000000000000000000^2 - 2  :: Integer)
20:07:50 <lambdabot>   True
20:08:03 <fracture> huh
20:08:05 <roconnor> @check \x -> let isSquare x = root == fromIntegral (floor root) where root = sqrt (fromIntegral x) in isSquare (10000000000000000000000000 + x :: Integer)
20:08:06 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
20:08:12 <roconnor> @check \x -> let isSquare x = root == fromIntegral (floor root) where root = sqrt (fromIntegral x) in isSquare (10000000000000000000000000^2 + x :: Integer)
20:08:14 <lambdabot>   "OK, passed 500 tests."
20:09:20 <Saizan> i guess you need an integral square function
20:09:27 <fracture> (thanks for the help, btw)
20:10:17 <roconnor> > filter isSquare [1..] \\ [x^2 | x<-[1..]]
20:10:33 <lambdabot>   thread killed
20:10:36 <roconnor> hmm
20:10:40 <roconnor> not quite what I want to od
20:11:16 <roconnor> > filter (uncurry (/=)) $ zip (filter isSquare [1..]) [x^2 | x<-[1..]]
20:11:31 <lambdabot>   thread killed
20:11:35 <roconnor> > head $ filter (uncurry (/=)) $ zip (filter isSquare [1..]) [x^2 | x<-[1..]]
20:11:51 <lambdabot>   thread killed
20:11:56 <Saizan> the first one is too far, probably
20:12:03 <roconnor> I guess
20:12:50 * wli would use bounded Newton as usual.
20:12:50 <Berengal> > drop 1000000000 [1..]
20:13:12 * roconnor would use isqrt
20:13:29 <wli> roconnor: There's an isqrt in the libs?
20:13:33 <roconnor> no
20:13:35 <roconnor> ;(
20:15:42 <wli> Bounded Newton just keeps a bounding interval and rejects Newton steps falling outside it in favor of bisection. I usually do Newton steps from both endpoints and the midpoint and just take the tightest bounding interval arising from the old endpoints, all those Newton steps, and the midpoint.
20:16:33 <roconnor> does that work for extermely large integers?
20:17:00 <wli> Yes. It works all the time.
20:18:26 <roconnor> even on integers greater than 10^616 ?
20:18:30 <wli> It can't fail. It's just a particular strategy for narrowing the interval until it's of minimal width i.e. [a, b] with a + 1 >= b.
20:18:38 <wli> Yes.
20:18:56 <wli> If bisection works so does that.
20:18:57 <roconnor> are you operating on integers?
20:19:07 <wli> Sometimes.
20:19:14 <roconnor> sometimes?
20:19:36 <wli> I'd write an integer version for isqrt. One can have floating point versions, too.
20:20:51 <Haudrex> @bot
20:20:51 <lunabot>  :)
20:32:41 <copumpkin> @botsnack
20:32:41 <lunabot>  :)
20:32:48 <copumpkin> is lambdabot dead again?
20:32:51 <wli> > let isqrt n = let isqrt' (a, b) | n == 1 = (1, 1) | a * a == n = (a, a) | b * b == n = (b, b) | a + 1 >= b = (a, b) | otherwise = let c = (a + b) `div` 2 ; f t = (t + (n `div` t)) `div` 2 ; [x,y,z] = map f [a,b,c] ; m = Map.fromListWith (++) [((t*t) `compare` n, [t]) | t <- [a,b,c,x,y,z]] in case Map.lookup EQ m of { Just (x:_) -> (x, x) ; _ -> let (Just lo, Just hi) = (Map.lookup LT m, Map.lookup GT m) in isqrt' $ minimumBy (comparing (\(u,v) -> v - u))
20:33:00 <wli> ARGH
20:34:02 <roconnor> one liner
20:34:24 <wli> Sadly it seems slightly too long.
20:35:28 <pumpkin> @botsnack
20:35:28 <pumpkinbot> :)
20:35:29 <lunabot>  :)
20:35:55 <pumpkin> > let isqrt n = let isqrt' (a, b) | n == 1 = (1, 1) | a * a == n = (a, a) | b * b == n = (b, b) | a + 1 >= b = (a, b) | otherwise = let c = (a + b) `div` 2 ; f t = (t + (n `div` t)) `div` 2 ; [x,y,z] = map f [a,b,c] ; m = Map.fromListWith (++) [((t*t) `compare` n, [t]) | t <- [a,b,c,x,y,z]] in case Map.lookup EQ m of { Just (x:_) -> (x, x) ; _ -> let (Just lo, Just hi) = (Map.lookup LT m, Map.lookup GT m) in isqrt' $ minimumBy (comparing
20:35:58 <pumpkinbot>   mueval: Prelude.read: no parse
20:36:09 <wli> The line got truncated.
20:36:13 <pumpkin> oh
20:37:02 <wli> The end is minimumBy (comparing (\(u,v) -> v - u)) [(u, v) | u <- lo, v <- hi, u <= v, u >= a, v <= b] } in fst $ isqrt' (1, n) in isqrt $ 10^(616::Int) + 1
20:54:40 <pumpkin> @botsnack
20:54:41 <pumpkinbot> :)
20:54:41 <lunabot>  :)
20:54:45 <lambdabot> :)
20:54:55 <Hunner> heh
20:55:40 <roconnor> :)
20:55:51 <MyCatVerbs> :)
20:56:23 <pumpkin> omg they're bots!
20:57:01 <roconnor> pumpkin: everyone is a bot
20:57:05 <roconnor> except for you
20:57:15 <pumpkin> :o
20:57:18 <pumpkin> I'm organic
20:57:23 <pumpkin> I was grown without pesticides
20:58:24 <ray>   thread killed
20:58:43 * pumpkin gives in and installs aquamacs, just for agda
21:07:34 <eck> what's the correct/recommended way to represent an ssize_t in a haskell program that uses the ffi?
21:26:34 <dons> eck: CSize
21:27:18 <eck> dons, i was thinking of doing that, and then checking if it's negative by checking if the value is greater than (maxBound :: Word) `div` 2
21:27:46 <eck> it's not pedantically correct, but i think it would work in practice
21:28:09 <eck> glibc defines ssize_t as a __SWORD_TYPE (i.e. a "signed word")
21:28:26 <eck> does that seem reasonable?
21:30:02 <dons> ?src CSize
21:30:02 <lambdabot> Source not found.
21:30:19 <dons> -- | Haskell type representing the C @size_t@ type.
21:30:20 <dons> INTEGRAL_TYPE(CSize,tyConCSize,"CSize",HTYPE_SIZE_T)
21:31:46 <eck> now that i'm looking in the right place, looks like System.Posix.Types defines CSsize
21:31:59 <dons> no, Foreign.C.Types
21:32:11 <dons> oh, ssize_t?
21:32:19 <eck> yeah, the signed variant
21:32:27 <eck> (which is nonstandard, but heavily used by gnu)
21:32:28 <dons> yeah, that might be in the unix lib.
21:32:33 <dons> System.Posix.Types sounds right
21:50:34 <scutigera> SumSq.hs:6:7:
21:50:34 <scutigera>     Could not find module `Data.Array.Parallel.Unlifted':
21:50:34 <scutigera>  
21:50:47 <scutigera> trying some uvector examples...
21:51:04 <Cale> hmm... is the uvector package installed?
21:51:08 <pumpkin> that seems odd, doesn't sound like uvector
21:51:15 <pumpkin> isn't that from dph?
21:51:28 <Cale> Yeah, that's not a module in uvector
21:51:30 <scutigera> it's in the uvector example array
21:51:37 <scutigera> it's in the uvector examples dir
21:51:38 <pumpkin> oh, the examples may be out of date
21:51:43 <scutigera> :-)
21:51:48 <Cale> Try adding -package dph and see if it helps
21:51:58 <Cale> (dph is normally hidden)
21:52:10 <pumpkin> Cale: have you used agda much? #agda's pretty dead :P
21:52:27 <Cale> pumpkin: Not much, I've looked at it very briefly.
21:52:29 <scutigera> unknown package: dph
21:52:31 <pumpkin> ah ok
21:52:37 <Cale> scutigera: okay
21:52:50 <Cale> er...
21:52:58 <scutigera> just looking for some start-me-up code to get me going with uvector
21:53:00 <Cale> right, it's like 8 packages or something now
21:53:12 <pumpkin> scutigera: it works like list, with big Us on the end of each function name :P
21:53:32 <pumpkin> scutigera: except it can't be infinite, and there are occasional subtle differences in behavior
21:53:43 <pumpkin> but its API is mostly modeled after list's, I think
21:54:02 <scutigera> stupid question , how exactly do I import from the command line in ghci
21:54:09 <pumpkin> :m + Data.Array.Vector
21:54:19 <pumpkin> > toU [1..10]
21:54:22 <lambdabot>   Not in scope: `toU'
21:54:30 <pumpkin> fromU gets you back to a list
21:54:40 <pumpkin> try something like mapU (+1) . toU [1..10]
21:54:57 <pumpkin> you'll find it's pretty similar to list in most respects, but a hell of a lot faster if you use it right
21:55:05 <scutigera> ...and I'm on my way, many thanks !
21:55:26 <pumpkin> :)
21:55:34 <dons> need to finish it.
21:55:38 <dons> write it up.
21:55:40 * pumpkin whistles innocently
21:55:51 <dons> "a pragmatic array library for haskell" or something
21:55:54 <scutigera> so why is a separate lib needed for unboxed. Is not the wise and powerful compiler good at figuring out how to unbox ?
21:56:05 <pumpkin> scutigera: in an ideal world, maybe :)
21:56:05 <dons> not that wise :)
21:56:13 <scutigera> smart ??
21:56:16 <dons> though ghc is rather wise and powerful :)
21:56:28 <dons> glorious, some would say
21:56:34 <pumpkin> scutigera: in an ideal world, the compiler could figure out that you aren't using your list in a way that needs to be a list, so it'll make it contiguous and unboxed
21:56:48 <pumpkin> but not in 6.10 ;)
21:56:56 <Cale> scutigera: Unboxing things in general is tricky, especially with separate compilation, since polymorphic functions require boxing.
21:57:02 <dons> what analyses would they need. hmm
21:57:04 <ray> the halting problem is milestoned for version 7
21:57:14 <pumpkin> it'd be pretty epic if it could do that :)
21:57:19 <pumpkin> an epic morphism!
21:57:25 * pumpkin snickers
21:57:41 <dons> we'd start with a strictness analysis, i guess
21:57:47 <dons> it'd have to be both spine and element strict
21:58:00 <dons> if we have that, unboxing would be ok.
21:58:09 <dons> just a representation choice
21:58:17 <pumpkin> yeah
21:58:40 <dons> so i'd like to write a rule : forall (a :: xs) . ![!a] = UArr a
21:58:48 <Cale> and you never apply a polymorphic function to it from an already-compiled module
21:58:50 <pumpkin> dons: this weekend I'll clean the non-lazy-uarr stuff up and send you some patches... the lazy-uarr is complicated and while I'd like to do it, it's not worth holding the rest up because of it
21:59:00 <Cale> (like the prelude, for instance)
21:59:18 <Cale> As soon as you apply map, then changing the representation is out of the question, isn't it?
21:59:20 <pumpkin> that's why we need whole program optimization!
21:59:22 <dons> yeah, i just want strict uarrays to be good enough for usual array programs (which means separate mutable/immutable apis, docs, intro/elim via bytestrings)
21:59:31 <dons> Cale: inlining complicates that
21:59:44 <scutigera> still not clear.  e.g., (non-mutable) Array Double. Why not allocated as as single object of n*sizeof(double).  It's not mutable, so it could be allocated as a single block and unboxed...
21:59:55 <pumpkin> cool, I'll try to get most of that in order
21:59:58 <dons> scutigera: becaues of laziness
22:00:10 <Cale> scutigera: laziness, and polymorphism
22:00:14 <scutigera> so ML _could_ do that :-)
22:00:26 <Cale> scutigera: There are polymorphic functions on arrays, which work *regardless of the element type*
22:00:37 <dons> well, we can do it with a strict list too, yeah. but you want to turn a ~[] ~a structure into ![] !a
22:00:37 <Cale> That is, they don't care how large the elements of the array are.
22:00:55 <Cale> In order for that to work, you need a uniform representation.
22:01:03 <dons> we actually have a package for this, btw. for unboxing lists
22:01:06 <scutigera> polymorphism ? but type is known at compile time !
22:01:14 <Cale> scutigera: Not necessarily.
22:01:20 <Cale> scutigera: Modules are compiled separately.
22:01:20 <dons> http://hackage.haskell.org/packages/archive/adaptive-containers/0.3/doc/html/Data-Adaptive-List.html
22:01:32 <dons> hmm.. i should write that up too. "self-optimizing container types"
22:01:45 <Cale> scutigera: So when the polymorphic function is compiled, it has no idea what specific unboxed types you'll later apply it at.
22:02:13 * dons discovers getting a job makes finding time to write papers and finish libraries harder :/
22:02:32 <pumpkin> scutigera: things like LHC will try to use the information from all modules
22:02:43 <pumpkin> scutigera: but GHC treats external modules mostly as black boxes
22:02:44 <scutigera> Cale: sorry, you lost me... I'm still stuck on why type isn't known at compile time.
22:02:52 <Cale> scutigera: It's still polymorphic.
22:03:07 <Cale> scutigera: Data.Array.IArray, for instance
22:03:14 <Cale> Is an already compiled module
22:03:16 <dons> :t map
22:03:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:03:21 <Cale> Yeah?
22:03:33 <dons> there it is. needs to work on any 'a' (so 'a' needs a uniform representation)
22:03:36 <Cale> :t Data.Array.IArray.amap
22:03:37 <lambdabot> forall e' e (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.IArray a e') => (e' -> e) -> a i e' -> a i e
22:04:10 <scutigera> yes but at compile time I had to apply map to _something_.  Eventually type has to be resolved.
22:04:14 <Cale> Of course, this is already generalised so there can be specific instances for each specific element type of a UArray
22:04:30 <Cale> scutigera: But not at the time that the array library is compiled.
22:04:58 <Cale> The types at which it's eventually applied are resolved when you compile your program, which is in the future.
22:05:06 <scutigera> sound of my hand slapping my forehead.  So that's why the mlton folks are so busy.
22:05:15 <dons> inlining
22:05:35 <dons> so a lot of cool optimisatoins rely on the code in the lib being inlined /later/ into the user's use site
22:05:41 <dons> where now we have extra info
22:06:07 <scutigera> dons: speed opt or space opt, or both ?
22:06:20 <Cale> both
22:06:24 <dons> optimizations in general.
22:06:52 <Cale> If your inliner was sufficiently powerful and clever, maybe you could change the representation after all.
22:07:30 <Cale> But it would have to be extremely reliable.
22:08:31 <scutigera> does whole program optimization change things ? Now it _can_ know what's going where and unbox automagically.  mlton is very good at this.  is that enough or does laziness still cause problems ?
22:08:32 <Cale> It would have to either inline every polymorphic function or else derive a new version of it from the polymorphic one.
22:08:50 <Cale> Yeah, whole program optimisation/compilation solves this neatly.
22:09:03 <dons> scutigera: that's enough. we'd need to add new optimizations related to changing representations based on strictness
22:09:35 * wli discovers other people's solutions for the addition chain multiplication problem.
22:09:43 <scutigera> whole progrom is enough, or strictness is enough ?
22:10:12 <Saizan> whole program
22:10:25 <Cale> Whole program is enough, but your program itself would need to be consistently strict for the optimisation to apply.
22:10:28 <dons> to change representations
22:10:45 <wli> (Project Euler #122)
22:11:44 <Saizan> you might want to follow LHC's blog, or read about the optimizations on the GRIN intermediate language
22:12:23 <scutigera> lhc ? hadrons or haskells ?
22:13:02 <Cale> LHC is a Haskell compiler.
22:14:00 <scutigera> aah ! thanks.  I knew I had seen that somewhere, but couldn't remember the name.
22:17:54 <scutigera> uvector works on _any_ type that supports appropriate type classes (still learning how to read all the type decl stuff)
22:18:59 <pumpkin> scutigera: the UA class
22:19:27 <pumpkin> scutigera: you get all the Int/Word types, Char, Bool, strict pairs, Ratio, Complex, and unit :P
22:19:44 <pumpkin> oh, and Float and Double, of course
22:20:23 <dons> things that can be unboxed, basically
22:21:01 <dolio> Anything non-recursive.
22:21:52 <pumpkin> well, :*:
22:21:54 <dolio> Although I suppose you could do recursive structures that have their size specified in the type.
22:23:24 <wli> I don't see how other people are doing it.
22:23:28 <scutigera> well the numbers are what I'm interested in, but for my own education, tuples would _not be unboxable ?
22:23:51 <pumpkin> nothing polymorphic can be unboxed
22:24:13 <pumpkin> UArrs get around it by taking the two halves independently and making separate UArrs of each side
22:24:22 <pumpkin> and transparently dealing with them for you
22:24:33 <scutigera> pumpkin: referring to complex ?
22:24:41 <pumpkin> that too, and ratio
22:24:50 <pumpkin> those are just simple wrappers around the :*: instance
22:26:32 <scutigera> looks like :*: is "strict pair" ?
22:28:08 <pumpkin> yeah
22:28:20 <pumpkin> the * is because it's a "product" of the two types
22:30:28 <Twey> Say, here's a crazy thought
22:30:30 <scutigera> ok. hey wait.  a :*: b. Doesn't that mean that a and b can be different types ?
22:30:53 <pumpkin> yup
22:31:01 <Twey> Why don't we use layout for separating list/record entries, too, rather than requiring commas even when layout is enabled?
22:31:11 <pumpkin> scutigera: they can even be more strict pairs
22:31:16 <pumpkin> you can have a :*: b :*: c
22:31:41 <pumpkin> (a :*: b) :*: (c :*: (d :*: e)) :P
22:31:43 <pumpkin> go crazy :P
22:31:59 <pumpkin> probably not great for cache locality though
22:32:12 <pumpkin> but quite elegant
22:32:54 <scutigera> cache locality.  boxing ? pointer has to be de-referenced.  hey wait a minute this is the unboxed data type.
22:33:10 <pumpkin> that part is fine
22:33:22 <pumpkin> but the halves of a strict pair might be in different places
22:33:37 <pumpkin> so iterating over it requires fetching memory from potentially quite different locations
22:34:06 <pumpkin> probably not a big deal though
22:34:32 <scutigera> however if it's Doubles, all is good, right ?
22:34:43 <Saizan> Twey: i'm in for records, also Foo {foo x = ..} should desugar to Foo { foo = \x -> .. }
22:34:46 <scutigera> I mean, array of Doubles
22:34:54 <pumpkin> scutigera: sure thing
22:35:05 <Twey> Saizan: *nods* I agree entirely
22:35:11 <Twey> But why only records?
22:35:48 <scutigera> pumpkin: is uvector available under rev ctrl ? I just wget'ed.  Want to keep current on the changes.
22:35:57 <Twey> I mean to extend the principle to all multi-part datatypes with syntax â lists, records, tuples, &c.
22:36:03 <pumpkin> scutigera: sure thing, check out code.haskell.org/~dons/uvector iirc
22:36:16 <pumpkin> http://code.haskell.org/~dons/code/uvector/
22:36:21 <Saizan> for lists it's less apparent if the next line is a continuation of the earlier expression or not, but i guess it might not be bad
22:36:39 <Twey> Saizan: You tell by layout, like at top-level
22:36:43 * pumpkin is writing matrices in agda!
22:36:48 * pumpkin feels so dependent
22:36:52 <Twey> Indented more means it's a continuation; indented the same means it's not
22:37:31 <scutigera> pumpkin: oh - darcs ?
22:37:39 <Twey> It would be more consistent with how top-level separators (colons) are treated, and would also make that annoying style with the commas at the start of the line redundant
22:37:39 <pumpkin> scutigera: yup :)
22:37:59 <Twey> Er, semicolons**
22:39:49 <cads> can we lazily compose operatations on lazy sequences to create possibly infinite sequences which compute themselves only when we peek at them?
22:40:56 <Twey> cads: Yes
22:41:00 <Twey> Of course
22:41:10 <cads> i'd like to write a vector addition function that lets you splice a subvector some arbitrary place within an existing sequence, for example
22:41:38 <cads> err, that didn't make sense
22:41:55 <Twey> > take 10 . map (*2) $ filter ((== 0) . (`mod` 2)) [1..]
22:41:57 <lambdabot>   [4,8,12,16,20,24,28,32,36,40]
22:42:54 <scutigera> pumpkin: looks like darcs success.  I should be using uvector a lot.  I hope to file bug reports :-)
22:43:09 <pumpkin> scutigera: great, there's a trac up too, let me dig up the link
22:43:33 <scutigera> er, wait, I hope to NOT file bug reports !  trac ?
22:43:37 <pumpkin> http://trac.haskell.org/uvector/report
22:43:49 <pumpkin> in the (maybe likely) case that you find bugs :P
22:44:01 <pumpkin> the darcs version also has a lot more documentation, if you want to build local haddock
22:47:16 <scutigera> just run haddock at top level of uvector ?
22:47:37 <Saizan> run "cabal haddock --hyperlink-source"
22:47:40 <pumpkin> you can ask cabal-install to build docs for you in your .cabal/config
22:47:58 <Saizan> or that, or runghc Setup.hs
22:48:03 <dons> gimme a sec, i'll put up docs
22:48:34 <pumpkin> dons: is there somewhere in the trac I can put myself down to get notified of all new tickets? or can I only cc myself on individual ones?
22:48:51 <dons> hmm.
22:48:52 <dons> maybe??/
22:49:01 <dons> http://code.haskell.org/~dons/docs/uvector/
22:49:04 <dons> scutigera: ^
22:50:42 <scutigera> dons: many thanks.  haddock worked too.
22:58:03 <dons> sciolizer: what kind of problems are you tackling with uvector?
22:58:28 <pumpkin> I think he left :/
22:59:11 <Freidenker> I don't know much about haskell, but I've seen very little mature linear algebra package for haskell, is it because matrix manipulations are slow/complicated with Haskell ?
22:59:26 <pumpkin> @hackage hmatrix
22:59:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
22:59:34 <pumpkin> for the practical side of linear algebra
22:59:42 <pumpkin> hooks up to gsl and lapack
23:00:43 <Freidenker> gsl is GPL
23:02:45 <Freidenker> And it's unnacceptable for the science project I'm planning (and for science in general, IMO). Lapack is interesting, but HBlas is still incomplete.
23:03:25 <pumpkin> yeah, I'm not a fan of the GPL either
23:03:53 <dons> Freidenker: there are some big fancy linear algebra packages on hackage now.
23:04:01 <lament> what's the monadic name of [] ?
23:04:01 <dons> hmatrix-static is the hot new one.
23:04:10 <pumpkin> that one is also GPLed though :/
23:04:23 <dons> oh really?
23:04:31 <dons> hu
23:04:32 <dons> h
23:04:43 <pumpkin> yeah, I think hmatrix is considerd derivative work of gsl, which causes hmatrix-static to be derivative of hmatrix
23:04:43 <dons> oh, hmatrix is as  well.
23:04:47 <pumpkin> infected by the GPL once more
23:04:54 <dons> strange.
23:05:05 <dons> well, if gsl is GPL, prob. no way around it
23:05:23 <dons> blas is BSD3 http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas
23:05:33 <dons> Freidenker: what kind of library would you like to use?
23:05:39 <dons> maybe you could just roll a quick binding?
23:05:54 <Freidenker> Yea there's a way; F# with dnAnalytics, but I would prefer Haskell.
23:06:20 <dons> mmm
23:06:45 <dons> and you need BSD or LGPL?
23:07:23 <dons> everything that's currently available is on hackage, pretty much, so hunt around there. http://hackage.haskell.org/packages/archive/pkg-list.html  otherwise, rolling a binding to a C lib of choice is pretty doable
23:07:52 <Freidenker> Both you be OK. As long as my work isn't "infected" by the GPL license.
23:07:55 <Freidenker> ok thanks.
23:08:20 <dons> right. it is just GPL libs you'll want to avoid. hackage is about 80% BSD licensed stuff
23:08:26 <dons> and the licenses are indicated.
23:08:37 <Freidenker> Can you give me a reference for "binding to a C library", I really have no idea how to do it.
23:08:46 <lament> is there any way to throw away a value in a function building a list using do notation?
23:08:59 <Freidenker> oh nice, BSD is perfect.
23:09:15 <lament> i.e. there's a "val <- possibilities" somewhere, and for one of the possibilities I don't want to return anything
23:09:34 <pumpkin> lament: use a guard?
23:10:31 <lament> not sure how that would work
23:11:28 <pumpkin> > do x <- [1..5]; y <- [7..9]; guard (even x); return (x, y)
23:11:29 <lambdabot>   [(2,7),(2,8),(2,9),(4,7),(4,8),(4,9)]
23:11:36 <dons> Freidenker: you're looking for the 'haskell foreign function interface'
23:11:43 <lament> oh
23:11:47 <lament> :t guard
23:11:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:11:53 <lament> thanks
23:12:08 <dons> Freidenker: there's a lovely :) chapter in http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
23:13:28 <Freidenker> Great, thank you very much dons
23:14:20 <Freidenker> oh... even better, I just bought the book on amazon a couple of hours ago
23:16:13 <dons> heh
23:16:14 <dons> enjoy!
23:16:26 <dons> and be sure to lean on the community as much as you need for help/advice etc
23:17:41 <Twey> Oh, you did?  Haha, excellent coincidence
23:17:55 <pumpkin> Freidenker: we're so helpful you'll have to beg us to stop!
23:18:09 <Freidenker> Thanks, if I write my project in Haskell I'll need all the help I could get.
23:18:11 <pumpkin> Freidenker: the other day, someone asked a question on the haskell-cafe mailing list, and got 12 answers! :P
23:23:57 <thoughtpolice> pumpkin: that was pretty funny
23:24:14 <thoughtpolice> pumpkin: i believe mine was the first of the dozens that followed
23:24:23 <pumpkin> I believed mine was :P
23:24:33 <pumpkin> but now I just think the mail server was being slow
23:25:37 <PhDP> But I think I'll register to the normal haskell list. It says "Discussions on the Haskell mailing list which have drifted off topic, or are only of interest to a small number of subscribers, will be asked to move to Haskell-Cafe."
23:25:48 <quicksilver> the mail server has been very slow this week
23:25:51 <pumpkin> thoughtpolice: zomg http://dl.getdropbox.com/u/361503/Picture%201.png
23:25:51 <quicksilver> it ran out of disk space
23:25:58 <pumpkin> thoughtpolice: epic proof!
23:25:59 <quicksilver> PhDP: that guidance is slightly out of date, really.
23:26:14 <quicksilver> PhDP: the main haskell list is mostly used for announcements and so on
23:26:26 <quicksilver> PhDP: -cafe is the main list for discussing programming questions
23:26:29 <quicksilver> (and -beginners)
23:27:08 <PhDP> Then I'll go there, I'm fairly experienced in Java but I'm really a beginner in Haskell.
23:27:37 <quicksilver> the transition from java to haskell is routine. Just turn your brain inside out.
23:27:38 <PhDP> Is "Real World Haskell" good ? I mostly took it because it was recent and many of the other books used Hugs.
23:27:42 <quicksilver> Note: it may sting, slightly.
23:28:01 <thoughtpolice> haskell :: Brain -> Exploded
23:28:01 <quicksilver> I think RWH is great. I know the authors though so I'm probably biased.
23:28:31 <Apocalisp> Might want to outsource programming questions to #haskell and StackOverflow
23:28:42 <Apocalisp> ...instead of a mailing list
23:28:49 <PhDP> I'm only concerned about portability and missing OOdesign for large projects, otherwise as I have to deal mostly with trees and math I think I'll like it.
23:29:08 <Apocalisp> PhDP: You will not miss the OOness
23:30:07 <Saizan> unless you try to reimplement it with typeclasses, which will only bring yourself into pain and misery
23:30:36 <thoughtpolice> pumpkin: you use the regular gmail interface? :p i've been using sup happily for the past while
23:30:44 <pumpkin> sup?
23:30:59 <thoughtpolice> pumpkin: http://sup.rubyforge.org
23:31:16 <Apocalisp> "Large project" is something of a slippery concept when it comes to Haskell. You may find that your 500,000-line enterprise OO app can be replaced with 100 lines of Haskell and a few big words ending in "morphism".
23:31:31 <thoughtpolice> pumpkin: it's pretty nice but it still has some strange bugs that are fairly annoying that I'm somewhat getting tired of.
23:31:37 <pumpkin> ah
23:31:50 <pumpkin> zygohistomorphic prepromorphism
23:31:54 <thoughtpolice> pumpkin: I've been thinking of writing one in haskell, I just know nothing about email protocols etc/
23:31:58 <thoughtpolice> :p
23:32:11 <pumpkin> don't find out
23:32:17 <pumpkin> they're gross
23:36:38 <thoughtpolice> pumpkin: oh, and here's something cute I did with libffi+generate-c the other day (the part that works, anyway) - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4828#a4828
23:37:07 <pumpkin> oh, cool :)
23:37:21 <pumpkin> now we just need a bunch of c combinators
23:37:54 <thoughtpolice> pumpkin: i was thinking it would be neat to have a DSL of some sorts, generate optimized C from it, and compile and load it back into the executable
23:39:37 <pumpkin> yeah :)
23:39:44 <pumpkin> more awesome codegen opportunities
23:43:03 <thoughtpolice> pumpkin: I was thinking of actually doing it for the cmonad package :)
23:43:03 <bos> @seen dons
23:43:04 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 26m 37s ago.
23:43:20 <bos> trac on haskell.org seems to be stuck :-(
23:43:20 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
23:43:24 <pumpkin> thoughtpolice: nice :)
23:43:36 <thoughtpolice> bos: yeah, community.haskell.org is a little weird right now
23:45:30 <vininim> halp, cuda is eating my terminal
