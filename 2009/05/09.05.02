00:04:30 <wli> There must be almost no cases where more than 2 residues are eliminated for a given prime.
00:09:43 <Peaker> I think introducing unicode into a language is a great way to fragment the developer base further -- causing even more code duplication than we already have
00:20:22 <haskellnoob> I need a really fast sorting algorithm. Is a fast implementation of mergesort in Haskell available somewhere?
00:20:34 <wli> Aha, I'm keeping track of primes larger than is strictly necessary.
00:21:34 <bd_> haskellnoob: yes, it's called sort
00:21:38 <bd_> @src sort
00:21:38 <lambdabot> sort = sortBy compare
00:21:48 <bd_> er, where was the source code link command
00:21:58 <johnw> @src sortBy
00:21:58 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
00:22:03 <bd_> haskellnoob: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sortBy
00:22:06 <bd_> johnw: it lies
00:22:06 <bd_> :)
00:22:14 <bd_>  @src gives the  reference implementation
00:22:17 <bd_> not the efficient implementation
00:22:22 <johnw> ahh
00:22:26 <wli> @src insertBy
00:22:27 <lambdabot> insertBy _   x [] = [x]
00:22:27 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
00:22:27 <lambdabot>                                  GT -> y : insertBy cmp x ys'
00:22:27 <lambdabot>                                  _  -> x : ys
00:22:37 <haskellnoob> bd_ : but does the built-in sort not use the usual list data structure, which is copied around and not modified in place? that would be too slow for me.
00:22:52 <bd_> haskellnoob: have you benchmarked it?
00:23:53 <bd_> I mean, you can go into ST and do a quicksort if you really want to. But figure out if the built-in one is fast enough for your needs first
00:24:20 <haskellnoob> ok... but quicksort doesn't sort stably, does it? i need a stable sort as well.
00:24:45 <bd_> It's possible to make a stable quicksort or a non-stable mergesort :)
00:25:20 <haskellnoob> where can a get a fast, stable quick-or-merge sort? would i have to write one on my own?
00:25:37 <bd_> haskellnoob: Is the built-in sort fast enough for you?
00:25:48 <bd_> @check \l -> sortBy (compareBy fst) . map (\n -> (1, n)) l == l
00:25:49 <lambdabot>   Not in scope: `compareBy'
00:26:03 <bd_> @check \l -> sortBy (\(a, _) (b, _) -> a `compare` b) . map (\n -> (1, n)) l == l
00:26:04 <lambdabot>   Couldn't match expected type `a -> [(t, t1)]'
00:26:19 <bd_> @check \l -> (sortBy (\(a, _) (b, _) -> a `compare` b) $ map (\n -> (1, n)) l) == l
00:26:20 <lambdabot>       Occurs check: cannot construct the infinite type: a = (t, a)
00:26:20 <lambdabot>        Exp...
00:26:23 <bd_> bleh
00:26:37 <haskellnoob> bd_: i don't know, but i strongly suspect it is not fast enough for me. I could save some time by finding the fastest one that i can get to start with, is what i thought.
00:26:42 <Renderwahn> depending on what you are sorting you can maybe use radix sort
00:27:15 <Peaker> someone said (n+k) patterns are why Eq is required for Num, but it seems ordinary number patterns require this?
00:27:29 <Peaker> @type let f 0 = 1 ; f _ = 2 in f
00:27:30 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
00:27:31 <haskellnoob> Renderwahn: that would require a lexicographic ordering, wouldn't it?
00:27:41 <bd_> @check  \l -> (sortBy (\(a, _) (b, _) -> a `compare` b) $ map (\n -> (1, n)) l) == map (\n -> (1, n)) l
00:27:42 <lambdabot>   "OK, passed 500 tests."
00:27:53 <Peaker> it has to compare arg with (==) whereas ordinary pattern matching just has to match some specific constructor
00:28:03 <bd_> haskellnoob: Er, I would suggest finding out it if the obvious thing is fast enough :)
00:28:21 <bd_> You'll need to do the same work to validate whatever else if you don't end up using the built-in one after all
00:28:30 <haskellnoob> bd_: ok, i will try that :)
00:28:38 <wli> Peaker: I think it relies on a primitive case construct for built-in types like Int, Integer, Word, et al.
00:28:58 <Peaker> wli: Surely it works on your own Num instances too
00:29:01 <wli> Peaker: So it really shouldn't require Eq for those.
00:29:10 <haskellnoob> bd_: but it would be good to know if would need to roll one on my own, or can depend on an existing, tested one.. for estimating how much work it is. hence my question
00:29:20 <wli> Peaker: I'm not sure. I'd have to try it.
00:29:26 <Peaker> wli: what I mean is that even if n+k patterns are removed, Num would still need an Eq instance
00:29:39 <Peaker> and that there's an ugly pattern-match special case for nums :(
00:30:00 <wli> Peaker: I think that requires some verification.
00:30:14 <bd_> haskellnoob: I wouldn't know - I've always used the built-in one. And if there was a faster one I'm sure the GHC folks would love to include it in the standard distribution :)
00:30:18 <haskellnoob> bd_: if the answer is not obvious (Something along the lines of "use the mergesort from the Boost library"), then that is fine. I just wanted to know that there is something that is common knowledge about fast sorting that i am not missing.
00:31:09 <haskellnoob> also, how would i know if the built-in one is stable? is it documented somewhere?
00:31:27 <johnw> haskellnoob: wouldn't a proper answer require us to foreknow the problem and to have already done the analysis?
00:31:41 <bd_> -- | The 'sort' function implements a stable sorting algorithm.
00:31:47 <bd_> ^^^ from the documentation
00:32:17 <haskellnoob> ok. thank you. let me try it and see!
00:34:31 <Peaker> I think augustss played with a destructive in-place sort in IO or ST behind a purely functional interface -- and it was somewhat faster than the default sort
00:36:21 <haskellnoob> Peaker: would you happen to know where to find this code?
00:38:22 <Peaker> haskellnoob: I can't remember where it was
00:38:29 <haskellnoob> ok. thank you.
00:39:13 <wli> I could also try using just the smallest nontrivial prime divisor when such exists.
00:39:28 <wli> That would spare the pain of the full factorization.
00:41:10 <haskellnoob> how do I pick every other element from a list? pickEven [8,4,3,5,2] should evaluate to [8,3,2] .
00:41:30 <haskellnoob> (should have been pickOdd, i guess)
00:42:22 <wli> > let pickEven xs = [x | (x, k) <- zip xs [0..], even k] in pickEven [8, 4, 3, 5, 2]
00:42:23 <lambdabot>   [8,3,2]
00:43:46 <jn> > let pickEven = map snd  . filter (even . fst)  . zip [0..] in pickEven [8,4,3,5,2]
00:43:47 <lambdabot>   [8,3,2]
00:45:24 <wli> Well, I think I found a way to cut down space usage, at least.
00:46:26 <vixey> > concat $ zipWith ($) (cycle [return,const []]) [8,4,3,5,2]
00:46:27 <lambdabot>   [8,3,2]
00:47:11 * wli doesn't subscribe to Golf Digest.
00:50:39 <haskellnoob> pickEven (x:y:xs) = x : pickEven xs
00:50:40 <johnw> i really like that solution, vixey
00:50:41 <haskellnoob> pickEven x = x
00:51:56 <zoheb> yes that was good
00:52:55 <jn> haskellnoob: doesn't count. you need to traverse the list *at least* twice.
00:53:26 <vixey> zoheb!!
00:53:37 <zoheb> Hi vixey
00:53:44 <zoheb> what tiime zone r u in
00:54:16 <vixey> space time, 9 hundred hours incoming
00:54:37 <zoheb> that was informative !!
00:55:32 <zoheb> I am in space time too
00:55:43 <zoheb> > map snd $ filter (odd.fst) $ zip [1..] [8,4,3,5,2]
00:55:44 <lambdabot>   [8,3,2]
00:55:49 <zoheb> yahoo!!
00:56:18 <zoheb> ok, thats the exact same ... as the one posted before
00:56:23 * jn sues 
00:56:41 <zoheb> so somebody somewhere thinks exactly like me
01:00:17 <johnw> > let f x (y:ys) = if y < length x then x !! y : f x ys else []
01:00:18 <lambdabot>   <no location info>: parse error on input `;'
01:00:24 <johnw> f [8,4,3,5,2] [0,2..]
01:01:21 <beelsebob> > let f x (y:ys) = if y < length x then x !! y : f x ys else [] in  f [8,4,3,5,2] [0,2..]
01:01:22 <lambdabot>   [8,3,2]
01:01:27 <johnw> i thought there should be something like mapWith (!!) [0,2..] [8,4,3,5,2], but I couldn't find it
01:01:51 <Peaker> johnw: do you mean zipWith?
01:01:53 <beelsebob> there's also versions which aren't quadratic time
01:02:00 <johnw> yeah, but the zipWith solution doesn't "stop"
01:02:07 <SubStack> sure it does
01:02:08 <johnw> zipWith (!!) (repeat [8,4,3,5,2]) [0,2..]
01:02:21 <SubStack> just don't evaluate the whole result!
01:02:25 <johnw> true
01:02:28 <zoheb> @type !!
01:02:29 <lambdabot> parse error on input `!!'
01:02:36 <johnw> @type (!!)
01:02:36 <zoheb> @type (!!)
01:02:36 <lambdabot> forall a. [a] -> Int -> a
01:02:37 <lambdabot> forall a. [a] -> Int -> a
01:02:57 <zoheb> oh the index operator
01:03:26 <Peaker> johnw: you can use zipWith after takeWhile
01:04:10 <zoheb> Its 1 am here, quitting
01:04:13 <zoheb> bye everyone
01:07:55 <Peaker> > let f xs indices = zipWith (!!) xs $ takeWhile (<length xs) indices in f [5,4..1] [0,2..]
01:07:56 <lambdabot>       No instance for (Enum [a])
01:07:56 <lambdabot>        arising from the arithmetic sequence ...
01:08:04 <johnw> why doesn't map (!!) [0,2..] return a list of partial applications?
01:08:09 * QtPlaty[HireMe] is pondering hacking on hUnit to product TAP output.  "Would that e a desired thing?"
01:08:14 <johnw> > map (!!) [0,2..]
01:08:15 <lambdabot>       Overlapping instances for Show (Int -> a)
01:08:15 <lambdabot>        arising from a use of ...
01:08:22 <Peaker> johnw: it does
01:08:29 <Peaker> @type map (!!) [0,2..]
01:08:30 <lambdabot> forall a. (Enum [a], Num [a]) => [Int -> a]
01:08:48 <johnw> in ghci I get No instance for (Enum [a])
01:08:50 <johnw> hmm
01:08:52 <Peaker> @type map (flip (!!)) [0,2..]
01:08:53 <lambdabot> forall a. [[a] -> a]
01:08:54 <johnw> maybe because i'm trying to print a function
01:09:06 <Peaker> johnw: first arg of (!!) is a list, not the index
01:09:21 <Peaker> johnw: if you flip (!!) its what you intended
01:09:25 <johnw> thanks
01:10:14 <Peaker> > let f xs indices = map (xs!!) $ takeWhile (<length xs) indices in f [5,4..1] [0,2..]
01:10:15 <lambdabot>   [5,3,1]
01:10:33 <Peaker> more efficient to use drop repeatedly, probably
01:10:43 <johnw> how do I apply a list of functions to a list of arguments again?
01:10:55 <johnw> i'm hoogling as we spea
01:10:56 <johnw> k
01:11:08 <Peaker> johnw: zip-wise or cartesian-wise?
01:11:14 <Jedai> johnw: zipWith ($)
01:11:18 <johnw> ahh
01:11:34 <Jedai> johnw: or liftM2 ($) if you want cartesian-wise
01:11:36 <johnw> coming back to vixey's solution
01:12:19 <Peaker> > let f xs n = map head . takeWhile (not . null) . iterate (drop n) $ xs in f [5,4..1] 2
01:12:20 <lambdabot>   [5,3,1]
01:13:11 <Peaker> @type \f -> takeWhile (not . null) . iterate f
01:13:12 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [[a]]
01:13:29 <Peaker> @type \f -> map head . takeWhile (not . null) . iterate f
01:13:30 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a]
01:14:45 <wli> I'm not really getting very many additional primes from factoring things. Maybe using only the smallest nontrivial prime divisor or no divisors at all with a more intelligent primality test would help.
01:28:03 <Peaker> Haskell convention is to allow any type in when outputting a (). I am wondering if this is a good idea
01:28:11 <Peaker> @type sequence_
01:28:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
01:28:22 <Peaker> I mean, perhaps the type of sequence_ should be:  (Monad m) => [m ()] -> m ()
01:28:52 <Peaker> @type (<$)
01:28:53 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
01:29:20 <Peaker> @type sequence_ . map (()<$)
01:29:21 <lambdabot> forall (f :: * -> *) b. (Functor f, Monad f) => [f b] -> f ()
01:29:50 <Peaker> (You could always use ()<$  when you do want to throw away the value
01:30:01 <Peaker> I guess in mlist I'll keep with the Haskell convention, even if it is a bad idea
01:30:43 <wli> Yeah, factoring has almost no value.
01:32:31 <wli> Almost all the useful primes come from when 2*n*n-1 is prime.
01:43:03 <ski> Peaker : i've thought of that as well
01:50:16 <zoheb> Hey vixey, I just created a fn inspired by your example
01:50:23 <vixey> cool
01:50:27 <vixey> what is it?
01:50:29 <zoheb> (foldr1 (.) $ zipWith ($) (cycle [(:),const id]) $ [1..10] ) []
01:50:33 <zoheb> >(foldr1 (.) $ zipWith ($) (cycle [(:),const id]) $ [1..10] ) []
01:50:43 <zoheb> gotta leave
01:50:47 <vixey> > (foldr1 (.) $ zipWith ($) (cycle [(:),const id]) $ [1..10] ) []
01:50:48 <lambdabot>   [1,3,5,7,9]
01:50:59 <zoheb> bye
01:51:01 <vixey> Ohh nice
02:03:51 <cnwdup> Is there a function which marshals a haskell string into a "CU string"?
02:05:08 <Peaker> @hoogle CU
02:05:08 <lambdabot> Foreign.C.Types data CUChar
02:05:08 <lambdabot> Foreign.C.Types data CUInt
02:05:08 <lambdabot> Foreign.C.Types data CUIntMax
02:05:19 <Peaker> What's a CU string?
02:05:31 <Peaker> @hoogle utf8
02:05:31 <lambdabot> package utf8-light
02:05:31 <lambdabot> package utf8-string
02:05:31 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
02:05:34 <cnwdup> :type withCString
02:05:43 <cnwdup> @type withCString
02:05:44 <lambdabot> Not in scope: `withCString'
02:05:49 <Peaker> @hoogle withCString
02:05:49 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
02:05:49 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
02:06:06 <Peaker> @hoogle CUString
02:06:06 <lambdabot> No results found
02:06:07 <cnwdup> withCString passes a (Ptr CChar) and I need a function which passes a (Ptr CUChar).
02:06:20 <Peaker> @hoogle CUChar
02:06:20 <lambdabot> Foreign.C.Types data CUChar
02:06:27 <Peaker> is that an unsigned char?
02:06:33 <cnwdup> Yes.
02:06:43 <Peaker> cnwdup: I think maybe you can just coerce the ptr? signedness shouldn't matter
02:07:14 <cnwdup> Peaker, okay. Thanks.
02:10:04 <wli> I think this would be better as an imperative algorithm but card marking kills it.
02:20:46 <Peaker> yay, my mlist is beginning to show signs of working properly :)
02:22:06 <Axman6> bos: these sides from your talk are really nice and clear. I'll have to show them to a friend who i wow'd with my haskell skills today ;)
02:26:25 <wli> I don't think anyone cares about my Haskell skills, not that I have any.
02:26:58 <Axman6> bah, you amaze me with stuff you do all the time. i'm always totally lost and amazed :)
02:28:38 <wli> I'm not any good. There are plenty of better people around the channel.
02:29:23 <vixey> wli: I can do 5 monad transformers at once behind the back with a 360
02:31:09 <Axman6> Velociraptors: o/
02:31:22 <Velociraptors> allo :)
02:31:44 <Axman6> i was wondering... have you actually tried any haskell yet? :P
02:32:06 * Velociraptors got a bit distracted
02:33:26 <Axman6> dear me
02:33:40 * Axman6 takes a Mac Plus hostage!
02:45:27 <MrChutney> I have fallen in love with Haskell!
02:45:35 <MrChutney> How did I not find out about this sooner?
02:46:32 <Axman6> don't worry, we won't make fun of you for it ;)
02:46:38 <Peaker> MrChutney: has Haskell fallen in love with you, too?
02:47:51 <Peaker> can ST be threaded, or only IO?
02:49:15 <Axman6> only IO afaik, but you could use ST in different IO threads though
02:51:24 * liyang wonders why no one has made ``My other car is a head'' bumper stickers. (And my other cdr is a tail.)
02:52:37 <romildo> Hi.
02:53:08 <romildo> When I get an error from gtk2hs, like   (Gui:21404): Gtk-CRITICAL **: gtk_tree_view_set_cursor_on_cell: assertion `tree_view->priv->tree != NULL' failed
02:53:44 <romildo> what is the number 21404 in (Gui:21404):
02:53:46 <romildo> ?
02:54:50 <LeoD> a line number maybe?
02:56:00 <romildo> LeoD, no, it is not a line number. Gui.hs has only 746 lines.
02:56:31 <romildo> LeoD, at least in Gui.hs it is not a line number. Maybe in some other file?
02:56:43 <LeoD> maybe it's in the C source
02:59:20 <Gracenotes> hm, my IOArray quicksort isn't performing amazingly >_<
02:59:33 * Gracenotes tries it compiled
02:59:49 <monadic_kid> @src Functor State
02:59:49 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:00:08 <monadic_kid> @src instance Functor State
03:00:08 <lambdabot> Source not found. Are you on drugs?
03:00:23 <monadic_kid> lambdabot: yes
03:00:31 <monadic_kid> @botsnack
03:00:31 <lambdabot> :)
03:00:32 <lunabot>  :)
03:02:50 <Gracenotes> okay, 41 seconds for one million (Word64, Word64)s, sorting by the second
03:03:04 * Gracenotes wishes uvector wouldn't segfault ;_;
03:07:09 <Athas> MultiParamTypeClasses and FunctionalDependencies are the best ever.
03:07:18 <Athas> I could never write Haskell without those.
03:07:41 <Athas> That was my daily excitement over those two extensions, thank you.
03:07:50 <Gracenotes> oh, wow, using a better PRNG sped up my code x2
03:08:04 <Gracenotes> almost
03:08:11 <Gracenotes> o-o interesting
03:19:17 <Peaker> Gracenotes: are you separating the time measurement of the sequence generation from the sorting?
03:21:44 <Gracenotes> hm.. well.. generation time is 11% here.
03:22:18 <Gracenotes> still, I'm trying to do the little optimizations that make quicksort a lot faster. maybe I should use some kind of introsort
03:22:32 <Gracenotes> like I would be using if uvector wasn't segfaulting ;_;
03:22:57 <Peaker> do you know why it segfaults?
03:23:38 <Gracenotes> not sure. It seems to be the most innocent uses, like toU on a list
03:24:28 <Peaker> I wish I could tell a refactoring tool -- express this function using this other function (e.g, rewrite a pattern match in terms of foldr, or such)
03:24:45 <Peaker> Gracenotes: hmm.. debug it? :)
03:25:58 * wli continues to fail to speed up his PE#216 solution.
03:26:55 <Gracenotes> Peaker: actually, the problem seems to be not the list itself but anything to do with using uvector IO or reading the list from a file
03:27:33 <Gracenotes> even using unfoldU failed, with proper input
03:27:59 <Peaker> @hoogle unfoldU
03:27:59 <lambdabot> No results found
03:28:25 <Gracenotes> how am I supposed to debug if it the code is so simple, there's no reason it shouldn't work? :\
03:28:48 <Gracenotes> you can't exactly walkthrough "hPutU file (toU q)" in great detail
03:29:45 <Gracenotes> I know it executes 2 or 3 times before just dying
03:32:11 <Gracenotes> the only apparent variance is how many iterations it takes before it segfaults
03:32:31 <Peaker> Gracenotes: look at the result assembly?
03:33:19 <Gracenotes> heh. well, I don't know assembly that well
03:37:42 <Peaker> is it safe to unsafePerformIO on newMVar?
03:40:05 <wli> Hmm. An incredibly naive algorithm is running fast enough.
03:40:36 <EvilTerran> wli, which one's PE216?
03:42:40 <wli> Primes of the form 2*n^2-1 for 1 < n < 5*10^7
03:43:06 <wli> Specifically counting the number of such primes.
03:44:48 <EvilTerran> i see
03:48:35 <wli> Just computing the intersection of two infinite ordered lists seems to work.
03:48:59 <EvilTerran> snazzy
03:50:22 <wli> I tried some more sophisticated things and got disastrous results.
03:57:06 <wli> map (\p -> isqrt ((p + 1) `div` 2)) is slowing it down preposterously. Maybe isqrt is slow.
03:58:09 <Peaker> @pl \p -> isqrt ((p + 1) `div` 2)
03:58:09 <lambdabot> isqrt . (`div` 2) . (1 +)
04:01:57 <Berengal> GUI programming is hard for weird reasons...
04:02:12 <wli> Oh dear, I've not actually run the algorithm as it needed to be run.
04:02:52 <Berengal> I can't make a "save as..." button
04:03:03 <wli> I only ran it over about O(sqrt(searchspace))
04:03:06 <Berengal> Apparantly a file chooser button can't save...
04:04:13 <Peaker> yay - I put: mlist 0.0.2   out -- and now its really lazy, and has a "memo" that is pretty similar to lazy I/O
04:04:15 <Peaker> @hoogle hGetLine
04:04:15 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
04:04:15 <lambdabot> System.IO hGetLine :: Handle -> IO String
04:04:15 <lambdabot> Data.ByteString.Char8 hGetLine :: Handle -> IO ByteString
04:04:23 <Peaker> it shouldn't be
04:04:25 <Peaker> is hGetLine lazy?
04:05:45 <Peaker> Berengal: I don't think GUIs are intrinsically difficult
04:05:49 <Peaker> Berengal: I think "save" is a stupid UI feature
04:06:14 <Peaker> I think everything should always be saved by default, and revision control should be inherent in everything
04:06:43 <Berengal> Peaker: Agreed on that point, but in this case it's not so much "save" as "create a new file, possibly overwriting an old one"
04:07:28 <Berengal> Also, GUIs maybe aren't intrinsically difficult, but the documentation that usually exists tries to make it so
04:08:17 <Berengal> Glade has been a saviour though. Far from the swing I had to hardcode back at uni.
04:08:26 <Peaker> hGetLine is strict I/O and hGetContents is lazy. that's arbitrary and ugly :(
04:09:49 <wli> hGetLine is most of what I use.
04:10:21 <Peaker> wli: so maybe you can give me feedback about mlist which replaces lazy I/O? :)
04:10:42 <wli> Peaker: wtf. is mlist?
04:10:57 <Peaker> wli: do you know Python generators?
04:11:35 <wli> In all honesty I've not paid attention to Python since before 2000 and I don't remember it having anything called generators.
04:11:57 <Peaker> wli: well, MList is a list that's allowed to have side-effects in order to get the next elements
04:12:16 <Berengal> Peaker: It forgets the previous element?
04:12:45 <wli> Peaker: No big deal then.
04:12:52 <Peaker> Berengal: yes, but you can use   memo :: MList IO a -> IO (MList IO a)   and then it doesn't
04:13:08 <Peaker> Well, no more lazy I/O doing side effects as part of the evaluation
04:13:17 <Berengal> Peaker: Awesome. I always wanted memoized generators in python. Well, since I got used to lazy evaluation anyway
04:13:30 <Peaker> Berengal: Python has them too with itertools.tee
04:14:27 <Berengal> Peaker: tee just forks them though, doesn't it?
04:15:24 <Peaker> Berengal: yeah, but forking a generator lets you go forward and keep a current "ptr" at the same time, which is as good as memoizing
04:15:35 <Peaker> Berengal: I think its equivalent to memoizing
04:15:47 <Berengal> Except python generators can have side effects
04:15:53 <Peaker> so can mlists
04:16:03 <Berengal> Repeatedly?
04:16:03 <Peaker> tee() prevents the side effects from re-occuring, and so does memo
04:16:26 <Berengal> tee can do that? This is news to me
04:19:12 <Berengal> Apparantly you're correct
04:19:15 <Peaker> mlist is allowed to have side effects for each next element
04:20:26 <Berengal> Yeah, I understood that was sort of the whole point
04:21:03 <Peaker> so tee basically memoizes the parts of the generator that are still accessible
04:21:10 <Peaker> by anyone else
04:21:46 <Berengal> So is tee magic or just very clever?
04:22:01 <Berengal> I'm guessing just clever
04:22:37 <Peaker> Python exposes its internals so there's very little magic
04:23:17 <Berengal> It seems like the iterators returned by tee just iterate over a lazy list produced by the argument iterator
04:23:33 <Berengal> This has the side-effect of forcing the input generator though
04:24:07 <Berengal> If something else's using that generator as well, tee will mess up
04:29:03 <Peaker> Berengal: of course - if you want it not to - just tee before that
04:29:29 <Peaker> Berengal: similarly with mlist memo, if you memo an mlist and someone else also uses that mlist they will both generate side effects to get the items
04:30:18 <Berengal> Right
04:30:34 <wli> I think the naive list intersection thing isn't working after all, though it's working far better than expected.
04:30:41 <Berengal> I guess I'm just happy I don't have too much IO to deal with that can't be strict at the moment
04:31:35 <Gracenotes> I'd TAPL that
04:31:40 <Gracenotes> :|
04:33:59 * Gracenotes is going to take out House of Leaves from the library today
04:38:43 <wli> The sieve's internal state grows out of control with the naive algorithm. :(
04:39:43 <Peaker> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4484#a4484  proves that Python's tee isn't magic (implemented it in Python)
04:40:38 <Berengal> Yeah, that doesn't look too different from some lazy streams I implemented some time ago
04:51:58 <lostman> haskell sux buahahahahahahhahahahahahahahahahahhahahahahahahahahahhahahahahahahahahah
04:53:11 <mk15> Hi im trying to get the value out of an array...im using the function readArray which is of type "readArray :: (Ix i, MArray a e m) => a i e -> i -> m e". My question is how do I extract the "e"? My attempt so far is "let val = (\(m e) -> e) (readArray arr 1)"
04:55:30 <MyCatVerbs> mk15: (readArray arr 1) on its own is what you need. No (\(m e) -> e) in sight.
04:55:59 <Botje> mk15: readArray is for mutable arrays. If you are working with immutable arrays, arr ! index is what you want
04:56:52 <Botje> > let arr = listArray (1,5) [ 6..10 ] in arr ! 2
04:56:53 <lambdabot>   7
04:57:15 <mk15> Botje: Im working with a mutable array
04:57:42 <Botje> then you just need the readArray as MyCatVerbs said
05:00:00 <Berengal> It turns out that once upon a time you COULD use a FileChooserButton to select non-existing files, but not anymore...
05:00:17 <Berengal> Now I have to hack something together...
05:00:51 <mk15> hmm ok ill look into this some more
05:10:03 * wli tries to come up with more ways to sieve.
05:10:21 <wli> Or ways to sieve faster. Or something.
05:25:46 <wli> Going back to lists instead of Sets helps a little on space usage.
05:26:31 <wli> The sets were tiny and overlap was either rare or limited to numerous identical occurrences.
05:26:35 <opqdonut> yeah, i find that Sets are very rarely worth the effort
05:27:25 <wli> I find them plenty useful most of the rest of the time. This is actually the first time I've ever been so hard-pressed for space as to care about their space footprint.
05:32:21 <wli> I'm literally hitting 32-bit address space limitations (and frankly that sort of space footprint would be a crippling slowdown on 64-bit too) so I've got to do something to cram it all in.
05:34:00 <wli> It's taking well over 10 minutes to get to 10^6 and I've got to go to 50*10^6 so this is still not working out.
05:37:32 <wli> I may need a faster primality test than trial division.
05:41:18 <Botje> wli: you know about the improved sieve on haskell, right?
05:41:52 <Botje> one which automatically skips all numbers divisible by 3,5 or 7, iirc
05:42:11 <wli> The Eratosthenes code I have does that already.
05:42:18 <Botje> okay :)
05:42:26 <opqdonut> wli: using an array or merging lists or what?
05:42:49 <wli> opqdonut: For the Project Euler problem or Eratosthenes?
05:42:57 <opqdonut> erastothenes
05:43:07 <opqdonut> i find that maintaining a "skip list" makes for a nice idiomatic sieve
05:43:14 <opqdonut> of course it's not the real erastothenes
05:44:05 <wli> The Eratosthenes I've got uses a priority queue and a wheel. It even saves wheel state.
05:44:29 <opqdonut> ah
05:44:38 <wli> That is, for each inserted prime.
05:44:52 <opqdonut> yeah my skip list is basically a naive priority queue
05:47:41 <lightstep> can Text.XHtml produce files with non-default encoding? i'm trying to give it utf-8 text, but get stuff like &#215;&#155;&#149; in the output
05:50:59 <wli> I only use Data.Map
05:51:36 <opqdonut> are there any nice functional heap implementations?
05:52:08 <opqdonut>  hmm, Data.Heap
05:52:11 <igel> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/heap
05:52:20 <opqdonut> ah, okasaki
05:53:17 <wli> They might make more sense but Data.Map is easily accessible.
05:54:24 <wli> The huge space overheads here are the queue for sieving the things I'm actually interested in and the Eratosthenes queue.
05:56:33 <wli> There may also be some overheads for using Integer where Int would suffice.
05:59:07 <wli> Hmm. I don't even have to think about where any of this could overflow.
06:01:27 <wli> I might try switching everything over to Int with the same old structures just to see if it still works properly, then switch over to Int-specialized structures.
06:01:59 <paul424> hi what do you think of learing haskell throught project euler ? the task looks nice but they are thery monotonic : like find all primes all fiind sum of primes such that ...
06:03:30 <Stinger> monotonic or monotonous
06:03:37 <wli> I only do PE to keep busy.
06:04:00 <paul424> monotonous ;)
06:04:23 <SamB> yeah, monotonic has some mathematical meanings
06:04:37 <SamB> alone it just means "not going both up and down" ...
06:05:19 <SamB> (because that's the one thing that all four meanings have in common)
06:07:36 <Berengal> PE is okay for brain exercise.
06:08:34 <xcthulhu> (increasing but not strictly increasing)
06:08:40 * wli converts over to Int-specialized everything.
06:08:44 <xcthulhu> or decreasing but not strictly decreasing
06:09:12 * SamB is fairly certain that the Project Euler sequence is not monotonicly nondecreasing or monotonicly nonincreasing ;-P
06:09:42 <necroforest> monotonically monotonous
06:09:56 <xcthulhu> It roughly increases with difficulty
06:10:02 <necroforest> monoton(ically ous)
06:10:23 <SamB> (by the Project Euler sequence, I mean the sequence of answers, btw.)
06:10:51 <Berengal> The later problems are of varying difficulty
06:13:05 <wli> Hmm. I think it broke.
06:14:10 <SamB> wli: that isn't too surprising!
06:16:54 <wli> When the last thing you see out of it after converting it to Int everything is 32767, you know converting to Int everything broke it somehow.
06:17:33 <SamB> yeah.
06:17:46 <SamB> 0x7fff isn't likely too relevant.
06:18:16 <bidigo> Hi there, anybody uses multiple keyboard layouts with xmobar? If so, how do you show the currently active layout in xmobar?
06:18:46 <SamB> bidigo: maybe that's an #xmonad question?
06:19:33 <wli> > 2*32769^2-1 ::Int
06:19:34 <lambdabot>   2147614721
06:19:49 <wli> Well, here that's negative.
06:20:54 <bidigo> SamB: you're right, I'll ask it there. thx
06:21:03 <SamB> > bitSize (1 :: Int)
06:21:04 <lambdabot>   64
06:21:12 <SamB> wli: could that be why?
06:21:28 <SamB> > 2*32769^2-1 :: Int32
06:21:29 <lambdabot>   -2147352575
06:21:35 <SamB> I think it could
06:22:43 <Tobsan> @src const
06:22:44 <lambdabot> const x _ = x
06:22:53 <wli> I may have trouble.
06:24:13 <wli> Here bitSize (1 :: Int) is 32.
06:24:31 <SamB> wli: I wouldn't exactly categorize that as trouble
06:24:41 <SamB> I'm kinda used to having that ;-P
06:25:17 <Berengal> > bitSize (1::Int64)
06:25:18 <lambdabot>   64
06:25:46 * SamB isn't sure that Int64 is more time-efficient than Integer
06:25:55 <Berengal> Me neither
06:26:04 <wli> Well, I lose out on all the Int-specialized data structures if I don't find some way to keep almost everything as Int.
06:26:12 <SamB> (on platforms where bitSize (1 :: Int) == 32, I mean)
06:26:35 <Berengal> Yeah, I got that
06:27:07 <SamB> because:
06:27:09 <SamB> @src Integer
06:27:10 <lambdabot> data Integer = S# Int#
06:27:10 <lambdabot>              | J# Int# ByteArray#
06:27:26 <SamB> @src Int64
06:27:26 <lambdabot> data Int64 = I64# Int64#
06:27:54 <wli> The first thing that exploded on me was Eratosthenes since squares overflow very quickly.
06:28:08 <SamB> and Int64, I think, has really lousy primops on 32-bit systems
06:28:19 <SamB> compared to Int
06:28:28 <SamB> (add #s as needed ;-p)
06:28:59 <SamB> wli: well, you could upcast there
06:29:03 <wli> For the most part you're hosed.
06:29:17 <wli> Not if I'm using IntMap for a priority queue.
06:29:28 <SamB> I mean, you don't store the squares do you ?
06:29:52 <wli> You don't even start casting out until the square, which becomes the priority in the priority queue.
06:30:01 <SamB> oh
06:30:06 <SamB> sounds pretty crazy
06:30:25 <wli> = x : sieve' xs (IntMap.insert (x*x) [map (x*) xs] table)
06:30:39 <wli> Not interesting in the least.
06:31:07 <igel> is using newtype Foo = Foo Bar slower than using Bar?
06:31:26 <Berengal> igel: No
06:31:28 <igel> especially for derived instances
06:31:32 <SamB> igel: shouldn't be
06:31:40 <igel> that's good :)
06:31:52 <SamB> except Read/Show, of course ;-P
06:32:15 <SamB> since they have to stick on that "Foo" constructor
06:32:23 <SamB> and take it off
06:32:25 <igel> not if "instance Show Foo where show (Foo x) = show x" right?
06:32:36 <SamB> igel: that's not derived ;-)
06:32:41 <igel> yep
06:33:14 <SamB> also, I'd be doing that on showsPrec, not show
06:33:17 <igel> i'm currently using typefamilies and newtypes to redefine Ord instances and the like
06:35:11 <igel> and i was worried about the wrapping- unwrapping overhead
06:37:44 <SamB> newtypes don't have any such overhead in actuality -- the thing is whether or not they confuse the optimizer ;-)
06:38:04 <SamB> I'm not confinced they won't sometimes do that, but it should be mostly fine
06:39:55 <SamB> and it should do a lot less harm to optimization than profiling does, that's for sure
06:41:36 * SamB sent in a kernel patch yesterday -- he sent it to x86@kernel.org
06:41:44 * SamB wonders who or what that is
06:42:04 <igel> i'll have to test performance anyway
06:42:29 <igel> everything looks much more complicated but it's a way more beautiful solution than before
06:42:45 <SamB> igel: in short: in the machine code, there is no wrapping or unwrapping
06:43:09 <SamB> but in the Core representation, there is, because that's typed
06:43:19 <igel> that's what i was hoping
06:43:46 <SamB> the Haskell standard basically requires that there be no wrapping or unwrapping at runtime
06:44:52 <SamB> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
06:45:03 <SamB> (courtesy of http://www.haskell.org/haskellwiki/Newtype)
06:46:24 <SamB> thankfully, it does not mandate that the optimizer not get confused by this ever ;-)
06:47:26 <SamB> igel: but if you get any performance issues due to the optimizer getting confused by your newtypes, by all means report them!
06:47:42 <igel> all i'm doing is using newtypes to be able to inverse the Ord of a type, the optimizer should be able to understand this...
06:47:51 <igel> i will^^
06:49:12 <SamB> (which of course involves manually rewriting the portion that appears to be insufficiently optimized with newtypes stripped)
06:50:14 <SamB> (so you can compare the performance of the two versions)
06:50:21 <wli> Okay, I think I hacked it to handle overflow at least some of the time.
06:50:54 <SamB> wli: Linus would never let that into the kernel ;-P
06:51:36 <wli> The memory footprint is preposterously reduced.
06:51:39 * SamB is glad his kernel patch is not supposed to have any impact on the actual kernel binary
06:51:51 <SamB> wli: I mean with how confident you are that it's not buggy
06:52:41 <wli> If it were something I were doing for work I'd be a lot more stressed out about how buggy and/or bugfree it is.
06:53:08 <SamB> yeah.
06:53:50 <SamB> my patch basically replaces "0" "VM86_SIGNAL" on one line
06:53:56 <wli> The reduction in memory consumption is rather necessary in order to get this to actually be able to run since it's exhausting 32-bit address space otherwise.
06:54:07 <SamB> because I got confused trying to un-stubify vm86(2)
06:54:37 <SamB> wli: ah, yeah, that is kind of bad unless you happen to have a 64-bit CPU and kernel
06:54:58 <SamB> and preferably a few gig of RAM
06:55:00 <Berengal> Even with 64 bits you'd need more than 4GB of memory to really make use of it
06:55:12 <SamB> well, ther *is* swap
06:55:14 <Berengal> Once you hit swap, everything stops anyway
06:55:17 <wli> Well, the space footprint is pretty catastrophic without resorting to whatever Int is on the platform.
06:55:33 <SamB> Berengal: that's why I said "and preferably a few gig of RAM"
06:55:54 <wli> 64-bit would just not break down on the particular problem size.
06:56:16 <wli> It's part of why these Project Euler problems aren't great problems.
06:56:30 <Berengal> Yeah, 64 bits are usually enough
06:56:49 <SamB> you mean they should break the same on 64-bit as on 32-bit ?
06:56:52 <SamB> yeah, probably.
06:57:26 <wli> Well, the "programming challenge" they're supposed to present is overflowing 32-bit integers in intermediate calculations.
06:57:45 <wli> Most of the time Haskell blows this away by just using Integer everywhere.
06:58:07 <SamB> I did also write a real sieve to use for some of them
06:58:22 <SamB> with Array Int Bool
06:58:49 <SamB> well, I guess I used {ST,IO}Array while doing the sieving
06:59:22 <Berengal> I wrote a sieve in C once. Maybe I should go learn the FFI and bring that up to haskell...
06:59:33 <Berengal> It was pretty fast if I recall
06:59:43 <Berengal> And I used bits for bools
06:59:46 * SamB wishes man2html had an option to not act like a CGI script
06:59:58 <wli> Yeah, I'm trying to avoid doing the ST/IO Array things because of the card marking problems.
07:00:25 <Gracenotes> primes?
07:00:39 <Gracenotes> Miller-Rabin isn't so bad (the probabilistic version)
07:00:46 <olsner> Berengal: there's a shootout entry for that btw (bit-based prime sieve)
07:00:48 <Gracenotes> er, deterministic, I mean
07:01:09 <SamB> I actually solved one of those PE problems on my [sister's] Casio graphing calculator ;-P
07:01:18 <SamB> well, mostly on paper I suppose
07:01:36 <olsner> Berengal: depending on what you want to do, you could also play with rewriting that code using haskell arrays rather than FFI
07:02:12 <SamB> Berengal: you don't have to write as much code to do that in Haskell
07:02:25 <Berengal> olsner: Well, I'm usually well served by the one-liner list comprehension. I don't really have any motivation :P
07:02:44 <SamB> the {ST,IO,}UArray are already bitpacked when storing Bool ;-)
07:03:07 <SamB> (I tend to forget the U in conversation for some reason)
07:03:10 <Berengal> Awesome, but if I did this it would be to learn FFI, not to get fast primes
07:03:22 <SamB> okay then ;-)
07:03:22 <wli> Can you actually mutate them without hitting bad card marking problems?
07:03:31 <SamB> wli: bad card marking?
07:03:32 <olsner> ah, for learning the FFI, writing it in haskell is useless :P
07:03:47 <SamB> wli: I don't know what that means :-(
07:03:52 <wli> SamB: The problems are bad. The card marking is nonexistant.
07:04:26 <wli> SamB: The GC goes nuts on large arrays because it doesn't incrementally handle objects with high pointer fanout.
07:04:32 <Berengal> olsner: I don't really have any reason to learn FFI yet either. For some reason though, whenever I want to learn something for it's own sake the meta-syntactic computation I use has something to do with primes ;)
07:04:54 <SamB> wli: ur, I meant to say {ST,IO}UArray
07:05:07 <olsner> heh, "meta-syntactic computation" :)
07:05:08 <SamB> wli: now I think I know what you mean
07:05:14 <SamB> yes, that is a problem
07:05:30 <wli> SamB: Card marking is the name for incremental GC scanning of objects with high pointer fanout.
07:05:55 <SamB> yes, and GHC ... doesn' do it incremantaly
07:06:26 <olsner> but shouldn't it be "meta-semantic" or something? the meta-syntactic variables are, after all, meta-syntax
07:06:27 <SamB> wli: but I meant to say {ST,IO}UArray in the first place, and that hasn't got high pointer fanout
07:07:09 <wli> Because they're unboxed so the object has no embedded pointers.
07:07:20 <Berengal> olsner: Hehe, yeah, I know. I just wasn't about to figure out what to really call it though. I guess placeholder computation is good enough...
07:07:20 <olsner> ouch, ghc's rts' gc has poor handling of objects with many pointers?
07:07:41 <SamB> olsner: apparantly it's just the mutable ones ...
07:07:45 <SamB> http://hackage.haskell.org/trac/ghc/ticket/650
07:08:01 * SamB misses lambdabot
07:08:07 <wli> olsner: Well, it's not incremental. "Poor" depending on the tradeoffs you care about.
07:08:15 <EvilTerran> @bot
07:08:15 <lambdabot> :)
07:08:15 <lunabot>  :)
07:08:30 <olsner> it'd be nice to find some * to put in "meta-*ic computation", to point out the analogy to meta-syntactic variables
07:08:35 <SamB> EvilTerran: I said that because she didn't give the title for that bug page
07:09:07 <SamB> hah
07:09:12 <SamB> they claim "1 day"
07:09:14 <wli> I don't know why it would just be the mutable ones, but for some reason I think it's limited to such for reasons I don't know offhand.
07:09:50 <SamB> wli: it well, they have to re-scan the whole thing when just one element gets changed, iirc
07:09:53 <Berengal> wli: Something about some assumptions not holding for mutable structures
07:10:20 <SamB> wli: read the ticket ?
07:10:24 <wli> The all-Int version with overflow handling is only eating 19MB of RAM as opposed to running out of 32-bit address space.
07:10:36 <SamB> wli: that's always nice ;-)
07:11:11 <SamB> how in the world does it save that much RAM, though?
07:11:33 <wli> OTOH it's not gotten very far in the search so it may yet explode. I'm also unsure of whether the answers are remotely correct once the potential overflow threshholds are blown past.
07:11:57 <wli> SamB: IntMap/IntSet vs. Map/Set and Int vs. Integer for large collections.
07:12:02 <SamB> which problem are you working on?
07:12:09 <wli> 216
07:12:26 <SamB> wli: I still have trouble with the idea that IntMap/IntSet are so much better
07:12:36 <olsner> heh, nice that we're using bottom as a bugtracker field value "milestone changed from 6.10 branch to _|_." :)
07:12:41 <wli> I'm bombing it by virtue of algorithms too slow to get anything done in a reasonable amount of time.
07:13:02 <wli> SamB: I've no idea why the difference should be quite that drastic.
07:13:39 <SamB> why'd they have to go and split the list into pages?
07:13:58 <SamB> wli: oh, I guess 0x7FFF was actually relevant to the problem ...
07:15:25 <SamB> > 2*50000000^2-1
07:15:26 <lambdabot>   4999999999999999
07:15:49 <Berengal> > 2*50000000^2-1 :: Int
07:15:50 <lambdabot>   4999999999999999
07:15:50 <wli> SamB: Yeah, that's why.
07:15:57 <Berengal> > 2*50000000^2-1 ::Int32
07:15:58 <lambdabot>   937459711
07:16:22 <SamB> I don't think that sieve is the right approach, somehow!
07:16:46 <SamB> I would suggest a more probabalistic approach
07:16:48 <wli> Which sieve?
07:16:58 <SamB> well, perhaps no sieve!
07:18:17 <SamB> I'd be thinking a probabalistic approach to primality testing would be appropriate here
07:18:40 <Berengal> One of the first C programs I wrote found the first one million primes using a very simple test: choose a random number and check if it's coprime to the number tested, repeat a thousand times
07:18:57 <Berengal> It was reasonable fast, and failed about 0.0003% of the time
07:19:02 <blueonyx> hi, can someone give me a pointer how ghci loads code at runtime?
07:19:04 <SamB> really?!?
07:19:11 <wli> I don't know. IOUArray Int Bool seems like it may be a better idea here.
07:19:17 <Berengal> SamB: Really
07:19:18 <SamB> that's a bit surprising considering how stupid that sounds
07:20:08 <SamB> hmm, I guess all of those failures were false positives, since there's no way to get a false negative ;-)
07:20:15 <wli> Whenever I find quadratic residues cross them off, or something.
07:21:08 <Berengal> SamB: Well, it might have been more than a thousand repeats... I found it spent about 5µs doing a thousand iterations, and about 1.5s to check using a more advanced algorithm I had hacked together. I might just have removed the advanced one, or I might also have upped the number of iterations for the fast one
07:21:19 <SamB> anyway, if your program takes more than 5 minutes ... you should probably try a different algorithm
07:21:36 <olsner> probably slightly OT in here, but what happened to ghc's move from darcs?
07:21:58 <SamB> olsner: what was GHC moving to again?
07:22:18 <wli> It's basically where n turns out to be the least residue of the inverse of 2 mod p.
07:22:43 <wli> It's basically where n turns out to be the least residue of one of the square roots of the inverse of 2 mod p.
07:22:50 <olsner> i read that they were supposed to move to git (a long time ago, maybe a year or so)
07:23:06 <wli> Which is the same as the inverse of one of the square roots of 2 mod p.
07:23:17 <SamB> olsner: maybe they forgot ?
07:24:08 <SamB> what time zone is "UK time"?
07:24:21 * SamB is looking at http://hackage.haskell.org/trac/ghc/wiki/IRC_Meetings
07:24:52 <SamB> ah, BST
07:24:54 <olsner> ah, according to http://hackage.haskell.org/trac/ghc/wiki/Status/May09 it seems they added "fixing the build system" as a dependency for that task, and that some darcs problems were fixed meanwhile, so "it's not clear how high priority making this change is"
07:26:16 <wli> For odd primes p, (p+1)/2 is an inverse of 2.
07:27:33 <wli> If the least residue of (p+1)/2 is a perfect square, then you've found one of the primes you want.
07:29:05 * EvilTerran tries to work out why "I am not a Number, I am a Free Variable" is using this "data Stack x = Empty | Stack x :< x" type instead of []
07:29:18 <EvilTerran> ?go "I am not a Number, I am a Free Variable"
07:29:20 <lambdabot> http://www.cs.nott.ac.uk/~ctm/notanum.ps.gz
07:30:22 <olsner> EvilTerran: to differentiate lists used as stacks?
07:30:38 <EvilTerran> thing is, it isn't really using them as stacks
07:30:54 <wli> The bad news is that this doesn't find very many of the things you actually need to find.
07:33:37 <jeffwheeler> I've got a package with several dependencies, of which one depends on another package. How can I list the dependencies of all my dependencies, to figure out which dependency has the last dependency.
07:33:42 <jeffwheeler> Okay, that was rather cryptic.
07:33:44 <wli> Or maybe it does... let's see.
07:34:14 <jeffwheeler> My package depends on several, one depends on another. I can't seem to figure out how to find the dependency that depends on that other one . . .
07:34:34 <edwardk> jeffwheeler: you have something that you don't want to depend on and you have no idea who the culprit is?
07:34:50 <EvilTerran> olsner, and it isn't actually using [] *anywhere*, afaict
07:34:56 <jeffwheeler> edwardk: rather, the bad package just upgraded and now depends on an older version of quickcheck
07:35:28 <jeffwheeler> I'm fine depending on it, as long as it still lets people compile this package
07:36:12 <edwardk> jeffwheeler: ah
07:37:04 <wli> It seems to be taking a while to check for 1 < n < 10^4 (should be 2202 n such that 2*n^2-1 is prime).
07:38:07 <edwardk> @seen augustss
07:38:07 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
07:38:39 <olsner> EvilTerran: without really reading most of the paper, it seems it tries to make some point of it being a stack rather than something stack-like
07:40:21 <wli> Starting from the primes is truly dogslow.
07:45:10 <burp_> @src filter
07:45:10 <lambdabot> filter _ []     = []
07:45:10 <lambdabot> filter p (x:xs)
07:45:10 <lambdabot>     | p x       = x : filter p xs
07:45:10 <lambdabot>     | otherwise = filter p xs
07:45:14 <EvilTerran> olsner, yeah, i guess. i might ask conal about it by email sometime.
07:46:23 <olsner> EvilTerran: it might be a convention borrowed from huet's zipper paper
07:46:59 <EvilTerran> that's true. i'll look that up.
07:48:36 <olsner> hmm, reading more about the darcs-migration of ghc, it seems to point out a lot of improper dependencies between ghc and libraries
07:49:06 <SamB> there, I added a command to http://hackage.haskell.org/trac/ghc/wiki/IRC_Meetings to show when the next meeting is ;-)
07:49:55 <SamB> olsner: if you're still wondering, you could try to attend the next meeting ;-)
07:50:20 <SamB> I mean, I see you found out something
07:54:11 <wli> 5*10^7 bits is what... 5*10^4*5^3*2^3 bits so 5^4*10^4 Bytes, or 6.25*10^6 bytes, or 6.25MB, NFI how many MiB.
07:54:57 <olsner> > 5*10^7 / 2^20
07:54:58 <lambdabot>   47.6837158203125
07:55:17 <olsner> > 5*10^7 / (2^20 * 8)
07:55:18 <lambdabot>   5.9604644775390625
07:55:21 <wli> > log (5*10^7)/log 2
07:55:22 <lambdabot>   25.5754247590989
07:56:05 <wli> Looks like a little over 4MiB.
07:56:41 <olsner> I'd interpret the second line as telling us it's 5.96 MiB
07:57:04 <olsner> (2^20 * 8) being the number of bits in a MiB
07:57:30 <wli> Okay, 5.96MiB. No big deal.
07:58:06 <Berengal> Curry me lambdas, if I didn't get the GUI to act like I wanted on the first try...
08:01:06 <burp_> ?src even
08:01:06 <lambdabot> even n = n `rem` 2 == 0
08:01:09 <burp_> ?src odd
08:01:09 <lambdabot> odd = not . even
08:01:57 <burp_> ?src mod
08:01:57 <lambdabot> Source not found. There are some things that I just don't know.
08:02:12 <burp_> what is the difference between rem and mod?
08:02:15 <wli> Every time I find a solution of 2*n^2-1=0 mod p for some prime I can cross off two residues every time.
08:02:26 <Berengal> > rem -4 8
08:02:27 <lambdabot>       No instance for (Num (a -> a -> a))
08:02:27 <lambdabot>        arising from a use of `-' at...
08:02:39 <edwardk> you know when you start using unsafeCoerce with StableName you might be going down the wrong path.
08:02:40 <wli> So then it's a matter of scanning for the next unset bit.
08:02:44 <burp_> > rem (-4) 8
08:02:44 <Tobsan> > rem (-4) 8
08:02:46 <lambdabot>   -4
08:02:46 <lambdabot>   -4
08:02:48 <burp_> > mod (-4) 9
08:02:49 <lambdabot>   5
08:02:49 <burp_> > mod (-4) 8
08:02:50 <lambdabot>   4
08:02:55 <burp_> oh ok
08:03:13 <ski> > -4 `rem` 8
08:03:14 <lambdabot>   -4
08:03:32 <Berengal> Basically, quotRem and divMod are duals of eachother
08:04:38 <ski> `rem' gives same sign as numerator, while `mod' gives same sign as denominator, iirc
08:04:53 <Berengal> > mod 4 (-8)
08:04:54 <lambdabot>   -4
08:05:04 <Berengal> > mod (-4) (-8)
08:05:05 <lambdabot>   -4
08:06:03 <ski> (and `mod' is the one that usually is nicer, mathematically speaking, while `rem' usually have more direct hardware support)
08:07:18 <ski> (if you do `mod n d' or `rem n d', you usually (ime) more often know the sign of `d' than the sign of `n')
08:07:48 <ski> (of course, if both are non-negative, it doesn't matter, so `rem' can be used)
08:07:58 <ski> > rem 4 0
08:07:59 <lambdabot>   * Exception: divide by zero
08:08:02 <ski> > mod 4 0
08:08:03 <lambdabot>   * Exception: divide by zero
08:08:11 <Berengal> > quoteRem (-4) 8
08:08:12 <lambdabot>   Not in scope: `quoteRem'
08:08:19 <Berengal> > quotRem (-4) 8
08:08:20 <lambdabot>   (0,-4)
08:08:25 <Berengal> > divMod (-4) 8
08:08:26 <lambdabot>   (-1,4)
08:08:32 * ski expects `mod n 0 = n' .. :/
08:09:09 <Berengal> n >= 0, so n MOD 0 can't be n...
08:09:13 * SamB wishes his school's CS department's NFS server didn't have such a high per-file latency ...
08:09:17 <Berengal> Well, abs n
08:09:20 <ski> (s/both/both arguments/)
08:09:34 <edwardk> worst typing dodge i've ever needed: lookup k (S m) = fmap unsafeCoerce ∙ Prelude.lookup (unsafeCoerce k) =<< IntMap.lookup (hashStableName k) m
08:09:37 <ehird> 16:08 ski expects `mod n 0 = n' .. :/  ← wat?!
08:09:40 <burp_> filter even [1.100] <- is this the fastest way to get a list of all even numbers from 1 to 100?
08:09:53 <ski> Berengal : imo `mod n d' should give a value `r' that is congruent to `n' modulo `d'
08:10:26 <int-e> > [2,4..100]
08:10:27 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
08:10:34 <ski> and `n' is congruent to `r' modulo `0' if and only if `n' is the same as `r'
08:10:44 <burp_> int-e, oh thats nice
08:11:14 <burp_> I wonder if this boils down to the same
08:11:54 <ski> `n' congruent to `r' modulo `d' means there exists an `k' such that `n - r = k * d'
08:11:55 <wli> There has to be something beyond the search algorithm just being inefficient. Some lemma I'm missing on quadratic reciprocity or something.
08:12:19 <ski> in the case above, you have `n - r = k * 0 = 0' which implies `n = r'
08:12:40 <ski> so, if `mod n d' should return anything at all, it should return `n'
08:12:53 <Berengal> But it doesn't return anything
08:12:58 <EvilTerran> edwardk, O.o
08:13:02 <ski> yes, but it ought to :)
08:13:17 <mk15> Hi, if I use a do block in my function, does that imply that the function needs to return an action, or can I still return a value such as a Boolean
08:13:19 <ski> > 0 * error "foo"
08:13:20 <lambdabot>   * Exception: foo
08:13:28 <SamB> does anyone know how to forward their Unix mail without having to be able to edit /etc ?
08:13:53 <int-e> burp_: no, the latter never generates the odd numbers in the first place.
08:14:06 <p_l> SamB: Depends on the software you have in your system :)
08:14:52 <edwardk> evilterran: i'm tracing through an applicative trying to pick up sharing information to extract a context-free-grammar, and needed some heavy duty lifting =)
08:15:06 <SamB> no standard way, huh?
08:15:12 <SamB> looks like sendmail :-(
08:15:30 <int-e> SamB: if you're lucky you can just put an email address in .forward in your home directory.
08:15:49 <SamB> int-e: will that leave those emails available locally too or not ?
08:16:26 <p_l> SamB: You can use procmail to make more advanced rules
08:17:00 <ski> > and [d `mult` (n `div` d) + (n `mod_` d) == n | n <- [-9 .. 9] , d <- [-9 .. 9]]  where 0 `mult` _ = 0; _ `mult` 0 = 0; x `mult` y = x * y; n `mod_` 0 = n; n `mod_` d = n `mod` d
08:17:01 <lambdabot>   True
08:17:13 <p_l> SamB: http://partmaps.org/era/procmail/mini-faq.html#forward-copy
08:17:27 <dsfox> SamB: If .forward works your mails will not be available locally
08:17:49 <int-e> SamB: you can keep a local copy by adding a line saying \<your user name> (i.e. \samb , say)
08:18:07 <skorpan> > show ((1,2),(3,4))
08:18:08 <lambdabot>   "((1,2),(3,4))"
08:18:22 <skorpan> @instances Sow
08:18:24 <lambdabot> Couldn't find class `Sow'. Try @instances-importing
08:18:24 <skorpan> @instances Show
08:18:25 <ski> if we define `mod n 0 = 0', then `d * div n d + mod n d  =  n' for every `n',`d' (including `d' being zero), if we allow `0 * div n 0' to (lazily) evaluate to `0'
08:18:25 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
08:18:26 <EvilTerran> ?type \x -> do x -- mk15, a do-block itself must be a monadic action
08:18:27 <lambdabot> forall (t :: * -> *) t1. t t1 -> t t1
08:18:39 <skorpan> how do i override the instance for (a, b)?
08:18:46 <wli> Okay, if a prime is ever seen, it need never be considered again, so one can keep a seen set of primes whose square roots of the inverse of 2 have already been crossed off.
08:18:52 <EvilTerran> mk15, but a function can use monadic actions internally and not necessarily return something monadic
08:18:54 <skorpan> or rather the instance for Show ((Int, Int), (Int, Int))
08:19:01 <SamB> int-e: in .forward?
08:19:01 <ski> Berengal,ehird : does that explain why i want this better ?
08:19:13 <SamB> where is .forward documented?
08:19:24 <EvilTerran> mk15, of course, in the case of IO, you'll have to return IO {something} if you want your do-block that's in IO to do anything
08:19:51 <mk15> EvilTerran, thanks thats exactly what I was looking for
08:20:40 <int-e> SamB: does a man .forward work? http://www.feep.net/sendmail/tutorial/intro/forward.html
08:21:35 <burp_> int-e, ok, great
08:21:36 <int-e> (but that doesn't explain everything - you can pipe the mail to external programs as well, which is how you run procmail using .forward)
08:22:45 <SamB> int-e: I tried man forward but got nothing
08:22:46 <mk15> EvilTerran, im still a little confused...my function is available here http://haskell.pastebin.com/m7ee4d0d9
08:23:36 <EvilTerran> mk15, um, what exactly do you want it to do?
08:24:05 <mk15> EvilTerran, return a True or False based on the inputs
08:24:18 <EvilTerran> what about something like http://haskell.pastebin.com/m7faebfc9 ?
08:24:24 <SamB> int-e: thanks, that seems to do everything I wanted ;-)
08:24:35 <SamB> well, I mean, if it does anything at all, of course
08:24:56 <Berengal> ski: Yeah, I can see your point
08:26:29 <mk15> EvilTerran, this returns a boolean value in a monad correct? I could work with this, but thats why I was asking if its possible to return a pure boolean value (True or False)
08:27:07 <EvilTerran> mk15, there's no way of getting a value out of a monadic action in general
08:27:24 <EvilTerran> mk15, for some monads, there may not even be a value to extract
08:28:02 <mk15> EvilTerran, ok I will work with this thanks
08:28:05 <EvilTerran> mk15, some monads do support extracting values, such as State, which provides runState for that purpose
08:28:16 <EvilTerran> but i suspect the monad you're working in doesn't
08:28:48 <EvilTerran> BTW, mk15, the other thing to note, is that "if (some expression) then True else False" is exactly the same as just "(some expression)"
08:29:18 <SamB> int-e: which it seems to do
08:29:55 <wli> Hmm. The deterministic variant of Rabin-Miller is phenomenally stupid esp. for numbers within the ranges of this problem.
08:30:28 <mk15> haha yea I knew that for C, but in Haskell im being overly verbose to avoid the compilers wrath :D
08:31:02 <SamB> mk15: that doesn't usually help a whole lot
08:32:49 <mk15> SamB: maybe not, but the compilers has bit me in the ass a couple times when i thought I was being clever by using shortcuts :)
08:32:51 <wli> woops the numbers actually blow slightly past it
08:34:17 <olsner> the if ... then True else False pattern is really ugly though
08:34:49 <EvilTerran> olsner, at least it's not "if ... == True then True else False" :P
08:34:50 <Botje> that's a keelhauling offense!
08:35:01 <SamB> mk15: yeah, well, that if thing is kind of overdoing it
08:35:30 <olsner> EvilTerran: true .)
08:35:54 <wli> Still, [2 .. 2613] won't hurt much (I hope).
08:36:34 <wli> I'm seriously thinking trial division is killing me.
08:58:34 <olsner> @src on
08:58:34 <lambdabot> (*) `on` f = \x y -> f x * f y
08:58:53 <olsner> what's the proper fixity and precedence of `on`?
08:59:03 <vixey> @info on
08:59:03 <lambdabot> on
08:59:19 <Twey> Same as anything else in backticks, I guess
08:59:20 <Berengal> Default, I guess
09:00:17 <olsner> Twey: you can decide that for yourself by adding a infixl/infixr with a different precedence, so it just depends on which definition of `on` you use
09:02:25 <redline6561> i was hoping someone could help me with a scoping problem in this code (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2296).
09:03:17 <redline6561> how can i make dict available to the last function without using global variables?
09:04:11 <olsner> redline6561: simplest way, by adding another parameter to findFunnies
09:04:13 <Twey> redline6561: Pass it in
09:04:40 <mk15> EvilTerran, if I use a do block in my code does that automatically make it impure?
09:04:52 <redline6561> olsner, twey: thanks
09:04:57 <mk15> in my function I mean
09:05:04 <Twey>  mk15 No
09:05:06 <Twey> mk15: No
09:05:16 <Twey> It can arguably make it ugly, but not impure.
09:05:28 <Twey> Only the IO monad is impure; there are lots of pure monads.
09:05:36 <olsner> redline6561: you could rewrite it to be findFunnies dict = [...] and just call (findFunnies dict) in main
09:06:35 <redline6561> olsner: not quite sure i follow. given your earlier comment i was expecting something like this in main: map (findFunnies \x dict) dict
09:07:02 <redline6561> with a corresponding definition of findFunnies: findFunnies word set = map (isFunnyWord word) (sameLength word set
09:07:12 <redline6561> *)
09:07:17 <monochrom> delete \x
09:07:19 <mk15> Twey, I am using the Data.Array.IO array, which uses the IO monday...im guessing this monad is impure?
09:07:25 <Twey> mk15: Yes
09:07:26 <mk15> IO monad*
09:07:30 <olsner> redline6561: yes, that's the most obvious way, but the "word" that you pass into findFunnies comes directly from dict anyway
09:07:46 <mk15> how about the ST monad?
09:07:55 <Twey> ST is pure
09:08:06 <mk15> ok thanks!
09:08:16 <Twey> Well, it's not really pure
09:08:18 <EvilTerran> any impurity that may or may not be in a given implementation of ST is exactly that; implementation. it still has pure semantics.
09:08:24 <Twey> But it acts like it's pure, which is good enough
09:08:29 <Twey> Yeah
09:08:45 <olsner> so by inlining the map you now have in main, findFunnies becomes a function of only one thing (the dict) rather than a function of two things (dict, word) where the second comes from the first anyway
09:09:21 <olsner> it's mostly matter of taste though, since the two are basically equivalent
09:10:46 <poucet> hm
09:11:25 <gwern> hm. are the titles of PhD theses italicized or quoted?
09:11:31 <redline6561> olsner: okay. thanks! i'll swing through again if i further issues.
09:12:50 <vixey> both
09:13:14 <gwern> both? madness!
09:16:15 <zoheb> vixey hi!!
09:16:49 <vixey> oooo~
09:18:40 <FliPPeh> > let x = "Swine Flu" in x = "Cured"
09:18:40 <lambdabot>   <no location info>: parse error on input `='
09:18:44 <FliPPeh> There is no cure.
09:19:28 <novatrust> wtf, lambdabot actually parses haskell??
09:19:47 <FliPPeh> > [1..8]
09:19:48 <lambdabot>   [1,2,3,4,5,6,7,8]
09:19:58 <novatrust> [1..9]
09:20:10 <novatrust> > [1..9]
09:20:11 <FliPPeh> > take 10 [x*2 | x <- [1..]
09:20:12 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:20:12 <lambdabot>   <no location info>: parse error on input `;'
09:20:22 <FliPPeh> > take 10 [x*2 | x <- [1..]]
09:20:23 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
09:20:39 <novatrust> ooooh... I can learn haskell here! Goodbye evil GHC on VIsta
09:20:52 <Botje> GHC isn't evil
09:20:55 <FliPPeh> GHC evil on vista?
09:20:55 <Zao> novatrust: Note that lambdabot accepts private messages.
09:20:57 <FliPPeh> Vista is evil
09:20:58 <Botje> shift that word two spaces to the right >:)
09:21:04 <novatrust> lol!
09:21:08 <kadaver> > take 10 $ repeat swineFluVirus
09:21:08 <lambdabot>   Not in scope: `swineFluVirus'
09:21:12 <kadaver> > take 10 $ repeat "swineFluVirus"
09:21:13 <lambdabot>   ["swineFluVirus","swineFluVirus","swineFluVirus","swineFluVirus","swineFluV...
09:21:30 <FliPPeh> @faw Can Haskell cure Swine Flu?
09:21:30 <lambdabot> The answer is: Yes! Haskell can do that.
09:21:35 <FliPPeh> @faq Can Haskell cure Swine Flu?
09:21:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:21:36 <FliPPeh> !!!
09:21:53 <Botje> remain pure and pigs cannot harm you >:)
09:22:18 <FliPPeh> @faq Can Haskell heat up a burito in a microwave so much that it can not even it eat itself?
09:22:18 <lambdabot> The answer is: Yes! Haskell can do that.
09:22:23 <FliPPeh> Holy..
09:23:00 <FliPPeh> Isn't it fun that no single pig has been infected with swine flu, but yet it's called swine flu?
09:23:03 <FliPPeh> Life is random
09:23:20 <Botje> pigs just shrug it off, probably.
09:23:35 <FliPPeh> @faq Can Haskell do IO without Monads?
09:23:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:23:42 <byorgey> uh... lots of pigs have swine flu.
09:23:47 <p_l> FliPPeh: Pigs do get it
09:23:53 <FliPPeh> ;|
09:23:55 <byorgey> they always have.
09:24:06 <FliPPeh> I don't trust my local news sender anymoire :(
09:24:10 <FliPPeh> They keep telling my lies
09:24:45 <p_l> even the current variation of H1N1. it's just that what we call "swine flu" now is a mix of human, swine and avian flu, which apparently jumped from pigs and unlike avian flu, it can move from human to human
09:25:06 <FliPPeh> We've got 15 infections in germany!
09:25:08 <FliPPeh> Hooray
09:25:14 <mk15> ok so currently im under the impression that if im using the impure IO monad in a function...then that function is required to return a monadic value correct?
09:25:25 <novatrust> @faq Can haskell outperform haskell?
09:25:25 <lambdabot> The answer is: Yes! Haskell can do that.
09:25:55 <EvilTerran> mk15, yes; more specifically, that function is required to return IO (something)
09:25:56 <byorgey> mk15: correct.
09:26:16 <novatrust> When is Thomas Edison not Thomas Edison?
09:26:22 <Berengal> mk15: Not neccessarily. You could discard the monadic value (but then it won't be performed) or return it inside another structure (which won't perform it eitheR)
09:26:49 <FliPPeh> @faq Can Haskell divide by Zero?
09:26:49 <lambdabot> The answer is: Yes! Haskell can do that.
09:26:50 <FliPPeh> > 1/0
09:26:51 <lambdabot>   Infinity
09:27:00 <EvilTerran> mk15, the reason being that, if you want to do side-effects, they have to be part of the IO action called "main"
09:27:02 <Gracenotes> okay, I now have House of Leaves in my possession
09:27:04 <byorgey> Berengal: I guess it depends on what mk15 meant by "using"
09:27:28 <byorgey> I assumed it meant "performing I/O actions"
09:27:40 <byorgey> as opposed to "taking an IO action as a parameter"
09:27:51 <Berengal> byorgey: Yes, it does. I just find that IO values being first class values is awesome enough to point out
09:27:53 <mk15> ok so if instead I were to use an ST monad,  then my function could return a non-monadic value such as "True"? (EvilTerran this is what I was referring to earlier)
09:28:00 <byorgey> Berengal: that's a good point.
09:28:23 <byorgey> mk15: indeed, if you wrap the ST computation in 'runST'.
09:28:28 <EvilTerran> mk15, no, you'd have to return something in the ST monad
09:28:42 <byorgey> EvilTerran: ?
09:28:46 <EvilTerran> mk15, unless you weren't using the same ST variables outside that function
09:29:20 <byorgey> mk15: exactly what function are you trying to write?
09:29:23 <EvilTerran> byorgey, i'm thinking back to the code mk15 posted earlier; it was doing something with a passed-in mutable array, from the looks of things
09:29:30 <byorgey> it would probably help to be more specific
09:29:38 <byorgey> EvilTerran: ah, ok, I didn't see that
09:30:04 <mk15> byorgey: I am passing in a mutable array.....I was to examine this array and return a simple True or False based on some criteria
09:30:39 <byorgey> mk15: ok, yeah, you can't do that.
09:30:39 <novatrust> > inc (inc 3) => 5
09:30:40 <lambdabot>   <no location info>: parse error on input `=>'
09:30:59 <byorgey> you'll have to return either (IO Bool) or (ST Bool) depending which you are using for the mutable array
09:31:22 <EvilTerran> > succ (succ 3) >= 5 -- novatrust, is this what you were thinking of>?
09:31:23 <lambdabot>   True
09:31:24 <Saizan_> mk15: you can escape from ST only if you dont' "leak" any mutable thing outside
09:32:08 <novatrust> Honestly, I just picked it out of a haskell tutorial - I'm just starting to learn Haskell :-)
09:32:36 <Berengal> > succ True
09:32:37 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
09:32:43 <Berengal> huh
09:32:46 <byorgey> novatrust: the  =>  probably meant 'evaluates to'
09:32:52 <byorgey> novatrust: it isn't Haskell syntax
09:33:08 <byorgey> > let inc = (+1)  in  inc (inc 3)
09:33:09 <lambdabot>   5
09:33:52 <novatrust> > let inc = (+2) in inc (inc 1)
09:33:53 <lambdabot>   5
09:33:57 <novatrust> Hm...
09:36:28 <EvilTerran> > (succ False, pred True) -- Berengal
09:36:29 <lambdabot>   (True,False)
09:36:54 <Twey> So, how does everybody handle handles with concurrency?  My standard approach is to wrap it in a couple of threads that listen to a Chan each for new input/outpu, writing it as they read it
09:37:00 <Twey> output**
09:37:02 <Berengal> EvilTerran: I know, I was just experimenting with succing a bit too much
09:37:04 <Twey> Is that normal?
09:37:32 <Saizan_> Twey: i think so, yeah
09:38:10 <EvilTerran> Twey, well, i've seen a thread feeding from a many-to-one channel to an output handle a few times
09:38:40 <Twey> EvilTerran: I think that's basically what I do
09:38:53 * Twey nods.
09:39:08 <Berengal> I usually spawn off a bunch of threads with spesific tasks, then use message passing to communicate
09:39:15 <Twey> I just find it a bit odd that there's nothing for that purpose in the standard library
09:39:24 <Twey> Berengal: Yeah
09:39:44 * Berengal once wrote a simple "recieve" routine
09:40:00 <Twey> It's pretty trivial to write a function that takes a handle and returns an IO (Chan String, Chan String)
09:40:34 <Twey> I'm surprised it hasn't been abstracted into a separate two-way-channel type and a converter function, or something
09:41:24 <Twey> Berengal: Complete with spelling error?  :-P
09:45:57 <Berengal> Twey: Wouldn't be the same without it, would it ;)
09:48:51 * Berengal wonders about implementing a ReversableComputation functor
09:49:42 <EvilTerran> Berengal, wouldn't that be a Control.Category?
09:49:55 <edwardk> evilterran: it is
09:50:04 <Berengal> And also a functor, no?
09:50:16 <edwardk> Berengal: not over Hask
09:50:29 <EvilTerran> it wouldn't be a Functor
09:50:42 <edwardk> in category extras there is an ExpFunctor class it could instantiate
09:50:48 <EvilTerran> but is probably a functor in some way or another
09:51:03 <edwardk> but basically its an endofunctor over the groupoid generated by Hask, not Hask
09:51:38 <edwardk> there was a 'BiArrow' that got it wrong and tried to make them an Arrow
09:52:05 <Berengal> Category could work as well
09:52:10 <edwardk> i obsessed about these because i needed them to understand why the Weirich/Washburn catamorphism was too small to really use
09:52:11 <dons> interesting. uulib defines its own IntSet and IntMap
09:52:19 <edwardk> heya dons
09:52:25 <edwardk> dons: did you see my adaptive state monad?
09:52:30 <dons> edwardk: btw, you would totally love Conor's talk at ICFP PC Workshop about BiFunctors and IFunctors
09:52:36 <dons> ooh. no.
09:52:43 <dons> good idea!
09:52:44 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4458
09:52:55 <edwardk> 40% faster than the previous CPS transformed state and half the calories
09:53:10 <dons> really cool!
09:53:31 <dons> we need to throw all these things into a paper
09:53:32 <edwardk> it uses the stack layout from my ran transformed state, so basically what happens is the state sits UNBOXED two levels down on the stack! and fmapping over state, etc never partially applies enough to have to even move it
09:53:36 <edwardk> yes
09:54:15 <roconnor> pfft, unboxing
09:54:20 <roconnor> go back to ML!!!
09:54:23 <roconnor> :P
09:54:43 <edwardk> roconnor: meh, its 40% faster than the previously fastest state monad i could build for a lot of useful stuff
09:54:57 <roconnor> 40% faster if all you care about are Ints
09:55:17 <dons> unique supply!
09:55:17 <edwardk> interestingly this may make UState'd code faster than writing normal code in some cases ;)
09:55:24 <edwardk> dons: yeah, thats in the queue
09:55:36 <dons> are there any CPS monads on hackage?
09:55:37 <Cale> Well, it *is* a unique supply :)
09:55:44 <edwardk> dons: what i want to do is bolt this onto the right-kan extension transformer lib i'm working on
09:55:45 <dons> there's no mtl equivalent yet, iirc?
09:55:47 <infoe|wk> how to build a recurrence:  f(x)  such that  f(1) = 1;  f(2x) = 2f(x) - 1  -- you see ive only done recursion where x diminishes
09:56:13 <edwardk> dons: i have a lib i've been putting together of right-kan-extension transformers that can reimplement the MTL using this same stack layout
09:56:16 <EvilTerran> infoe|wk, what's f(3)?
09:56:23 <edwardk> dons: its not yet up on hackage
09:56:35 <infoe|wk> EvilTerran: 3
09:56:35 <Cale> infoe|wk: f(x) = 2 f (x` div` 2) - 1
09:56:37 <edwardk> but i have a now slightly dated version of my repository up on comonad.com iirc.
09:56:38 <eden_> hi, there, I'm having a little trouble defining an instance of the parsec Stream typeclass. I'm trying to define it for [(SourcePos, [Char])].
09:56:39 <Cale> er...
09:56:44 <Cale> infoe|wk: f(x) = 2 * f (x` div` 2) - 1
09:56:54 * Cale shouldn't mix notation...
09:56:58 <Cale> infoe|wk: f x = 2 * f (x` div` 2) - 1
09:56:59 <edwardk> dons: i also went through and rewrote uu-parsinglib to use Control.Applicative
09:56:59 <EvilTerran> infoe|wk, er, why?
09:57:11 <Saizan_> edwardk: it's a shame that you have to write distinct Functor/Monad instances for each of them
09:57:17 <edwardk> saizan: yeah
09:57:37 <edwardk> saizan: fortunately i _can_ inherit the Applicative, and all of the MonadFoo instances generically across all of them
09:57:42 <EvilTerran> infoe|wk,  f(2x) = 2f(x) - 1  implies  f(3) = 2f(1.5) - 1 = ???
09:57:55 <infoe|wk> evilterran: i am taking knuth's book "Concrete Mathematics" and going through it using F# in order to learn FP, i figured I would ask here as there are no F# channels with clue
09:58:01 <edwardk> saizan: for the equivalent StateT
09:58:32 <infoe|wk> EvilTerran: there is another component...  f(2n+1) = 2f(n) + 1
09:58:36 <infoe|wk> for the odd case
09:58:40 <EvilTerran> infoe|wk, ah, i see
09:58:54 <edwardk> saizan: all i need is an additional definition of MonadTrans, and the others come in from the general derivation, so I can bake it into AdaptStateT
09:58:59 <Cale> infoe|wk: Anyway, the idea is to divide :)
09:59:05 <eden_> the problem reported is: 'uncons' is not a (visible) method of class 'Stream'. I've written what I think makes sense after seing the simple definition for a list.
09:59:27 <edwardk> dons: oh. another toy, i almost have a new set of Applicative parser combinators ready to go that can parse in parallel as a monoid.
09:59:42 <EvilTerran> infoe|wk, well, for the first case, "f 1 = 1" would work
09:59:56 <Cale> eden_: I can take a look...
10:00:04 <EvilTerran> infoe|wk, and, for the other two, you could write something to the effect of
10:00:09 <edwardk> dons: the api should be very much like parsec/uu-parsinglib
10:00:12 <EvilTerran> f x | even x = ...
10:00:15 <EvilTerran>     | odd x = ...
10:00:17 <Berengal> f x | even x = 2* f (x `div` 2) - 1; | odd x = 2 * f (x `div 2) + 1
10:00:28 <dons> gotta get  them on hackage :)
10:00:33 <Cale> eden_: Ah, have you imported Text.Parsec.Prim?
10:00:42 <dons> truly parallel parsing would be interesting
10:01:48 <eden_> cale: Cheers. I start with: instance Stream [(SourcePos, [Char])] Identity (SourcePos, Char) where
10:02:29 <edwardk> dons: i have two versions of the implementation that i've been working on. not sure which one will win out. one uses 'Fox' style derivatives of an Applicative, the other uses lots of StableName and unsafeCoerce magic to tease out the context-free grammar recognized by an Applicative and then parses bottom up.
10:02:31 <eden_> cale: yes, it' found it, and the token function there.
10:02:50 <Cale> eden_: But it's complaining about uncons not being a method?
10:03:19 <edwardk> dons: re hackage and so forth, did you ever set up the repo for adaptive-containers on code.haskell?
10:03:20 <eden_> Cale: that's right.
10:03:30 <dons> i think so...
10:03:45 <dons> ah no!
10:03:56 <dons> http://code.haskell.org/~dons/code/adaptive-containers/ and i wondered why no one was pushing patches!
10:04:01 <edwardk> =)
10:04:11 <edwardk> i kept looking for it =)
10:05:04 <edwardk> dons: are you aware of any issues with comparing unsafeCoerced StableName's?
10:05:22 <redline6561> i had a scoping problem and hoped i could avoid a global variable through partial application. still having some issues though. help? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2296#a2297
10:05:33 <edwardk> dons: or separate stable names of the same value unsafeCoerced into different types?
10:05:39 <dons> mmm
10:05:46 <Cale> eden_: Can I see your code?
10:05:47 <dons> i'm not aware anyone's tried.
10:06:02 <Cale> eden_: I can write an instance of it...
10:06:08 <edwardk> I ask because the 'a' found its way all the way down into the prim: eqStableName# :: StableName# a -> StableName# a -> Int#
10:06:42 <tromp> @let f = 1 : merge (map (pred.(*2)) f) (map (succ.(*2)) f)
10:06:42 <lambdabot>  <local>:3:8: Not in scope: `merge'
10:06:42 <lambdabot>  
10:06:42 <lambdabot>  <local>:3:31:
10:06:42 <lambdabot>      Ambiguous occurrenc...
10:06:51 <eden_> I guess I can list it, it pretty short.
10:07:04 <Cale> redline6561: Separate the I/O from the rest of the problem.
10:07:09 <tromp> @let merge (x:xs) ys) = x: merge ys xs
10:07:09 <lambdabot>   Parse error
10:07:13 <Cale> @paste
10:07:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:07:16 <tromp> @let merge (x:xs) ys = x: merge ys xs
10:07:17 <lambdabot>  Defined.
10:07:20 <tromp> @let f = 1 : merge (map (pred.(*2)) f) (map (succ.(*2)) f)
10:07:21 <lambdabot>  <local>:4:31:
10:07:21 <lambdabot>      Ambiguous occurrence `f'
10:07:21 <lambdabot>      It could refer to either `L...
10:07:23 <Cale> eden_: ^^ paste it on hpaste :)
10:07:26 <edwardk> dons: the reason is i need something like: lookup :: StableName a → IntMap [(StableName Magic, f Magic)] → Maybe (f a); lookup k m = fmap unsafeCoerce ∙ Prelude.lookup (unsafeCoerce k) =<< IntMap.lookup (hashStableName k) m
10:07:26 <redline6561> cale: how so?
10:07:30 <eden_> instance Stream [(SourcePos, [Char])] Identity (SourcePos, Char) where
10:07:30 <eden_>     uncons []                 = return Nothing
10:07:30 <eden_>     uncons ((pos, [c]):ts)    = return $ Just ((pos, c), ts)
10:07:30 <eden_>     uncons ((pos, (c:cs)):ts) = return $ Just ((pos, c), (updatePosChar pos c, \
10:07:30 <eden_> cs) : ts)
10:07:32 <tromp> @let fs = 1 : merge (map (pred.(*2)) fs) (map (succ.(*2)) fs)
10:07:33 <lambdabot>  Defined.
10:07:37 <tromp> > fs
10:07:38 <lambdabot>   [1,1,3,1,3,5,7,1,3,5,7,9,11,13,15,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,3...
10:07:40 <Cale> eden_: okay then :)
10:08:01 <EvilTerran> @oeis 1,1,3,1,3,5,7,1,3,5,7,9,11,13,15,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29
10:08:01 <lambdabot>  Josephus problem: a(2n) = 2a(n)-1, a(2n+1) = 2a(n)+1.
10:08:01 <lambdabot>  [0,1,1,3,1,3,5,7,1,3,5,7,9,11,13,15,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,...
10:08:03 <Cale> redline6561: Have the functions take the dictionary set as a parameter.
10:08:09 <edwardk> dons: and i was being somewhat paranoid about how safe that would be ;)
10:08:19 <Cale> redline6561: And maybe write a pure function for constructing that dictionary from a string.
10:08:41 <Cale> redline6561: The only thing which should be in the IO monad is reading the actual dictionary file, and printing the results.
10:08:52 <edwardk> dons: i realize when invoking unsafeCoerce twice in one line and mixing in stuff that runs slightly outside of the operational semantics of haskell to get stable names its a little late to be paranoid, but still
10:08:56 <infoe|wk> wow ok you guyes ran with the josephus problem it seems
10:09:04 <infoe|wk> s/guyes/guys
10:09:04 <redline6561> ah
10:09:11 <redline6561> cale: thanks.
10:09:39 <Cale> redline6561: I can help you more directly with it in a moment if you like... just want to sort out eden_'s problem :)
10:09:41 <infoe|wk> I don't have a haskell but i have an F#, someone woke up over there and started helping me... quick with the math but no suggestions for implementing in F#
10:10:06 <eden_> Cale: you're a busy person...
10:11:29 <Cale> eden_: Where is updatePosChar?
10:11:33 <redline6561> cale: thanks very much for the offer. let me play with it for a few minutes (3-5) and private message you.
10:11:38 <Cale> Is that from Parsec too?
10:11:42 <Cale> redline6561: okay
10:11:53 <Cale> Ah, found it
10:12:18 <skorpan> @pl \ps -> length ps > 1
10:12:18 <lambdabot> (> 1) . length
10:12:18 <Cale> eden_: Okay, I get a totally different error.
10:12:33 <eden_> Cale: oh yes?
10:12:34 <Cale> eden_: I'm getting that functional dependencies conflict between instances.
10:12:36 <Berengal> Grargh! *deletes the entire .glade file he's working on*
10:13:05 <Cale> Specifically, that your new instance conflicts with the default instance: instance (Monad m) => Stream [tok] m tok
10:13:17 <eden_> Cale: Ah. not one I've met before...
10:13:35 <Cale> eden_: What've you imported at the top of your file?
10:13:48 <Cale> Did you import Text.Parsec.Prim?
10:14:33 <eden_> import Text.ParserCombinators.Parsec
10:14:33 <eden_> import Text.ParserCombinators.Parsec.Pos  ( updatePosChar )
10:14:33 <eden_> import Text.ParserCombinators.Parsec.Prim ( pzero )
10:14:33 <eden_> import Text.Parsec.Prim ( Parsec, Stream, token )
10:15:24 <Cale> eden_: There's your problem
10:15:35 <Cale> eden_: You didn't import the class you're trying to define an instance of.
10:15:36 <eden_> Cale: Have  I not imported or hidden something?
10:15:52 <Cale> Just import all of Prim, it'll save you trouble :)
10:16:45 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4492#a4492
10:16:53 <eden_> Cale: I'll give that a go. 'Stream' is in that import list, thought it would be enough...
10:16:54 <Cale> This works.
10:17:18 <Cale> Ah, you did import the class, but not its methods
10:17:29 <Cale> Why are you using the old deprecated module names?
10:17:47 <Cale> Text.ParserCombinators.* are only there for backward compatibility
10:18:18 <Cale> (perhaps the documentation should say something about that :)
10:19:08 <eden_> right. pzero is not in Text.Parsec.Prim. The documentation definately should!
10:19:28 <Cale> mzero is the same thing, I think
10:19:36 <Cale> There's also parserZero
10:20:11 <eden_> parserZero sounds interesting. I'll hoogle it....
10:20:24 <Cale> Though I think you're mostly just expected to use mzero
10:20:36 <Cale> Or empty, if you're an Applicative sort of person :)
10:20:49 <Cale> :t mzero
10:20:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
10:21:47 <Cale> :t empty
10:21:48 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
10:22:18 <Cale> (The only difference is which library abstraction you like better, they're defined the same way here)
10:24:02 <Berengal> parseFail = mzero?
10:26:18 <edwardk> hrmm. anyone here familiar with Van Wijngaarden grammars?
10:26:41 <defun> :t (>>)
10:26:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:26:44 <edwardk> i'm searching for a class of synthesizable attributes where the values must be monoidal unlike a knuth style attribute grammar which permits anything
10:26:51 <defun> :t (*>)
10:26:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
10:27:16 <Asztal> yes, parserZero is just mzero
10:28:28 <gnuvince_> How do I uninstall something with cabal?
10:28:38 <Berengal> gnuvince: Cabal install is forever
10:30:03 <defun> :t (<$)
10:30:04 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
10:30:09 <dmwit> gnuvince_: unregister it, then blow away its directory
10:30:16 <eden_> Cale: Okay, I've go to the point of getting function dependencies with Text.Parsec.String (imported from Text.Parsec?)
10:30:52 <skorpan> is it possible to somehow define my own instance of Show for (Int, Int)?
10:31:12 <Cale> eden_: Did you see my paste?
10:31:17 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4492#a4492
10:31:24 <eden_> Cale: I also had to turn on FlexibleInstances and  MultiParamTypeClasses
10:31:30 <Cale> skorpan: Not without wrapping it in a newtype
10:31:38 <Cale> eden_: yep
10:32:04 <skorpan> Cale: so newtype MyPos = MyPos (Int, Int) and then instance Show MyPos where?
10:32:05 <gnuvince_> dmwit: and how do I unregister a package?
10:32:23 <dmwit> ghc-pkg unregister
10:32:53 <Cale> skorpan: yeah
10:33:12 <Cale> skorpan: While you're at it, you basically might as well turn it into a proper data declaration
10:33:21 <Cale> data MyPos = MyPos Int Int
10:33:21 <skorpan> Cale: why?
10:33:44 <Cale> Well, this will let you strictify the fields if that ends up mattering...
10:33:52 <Cale> data MyPos = MyPos !Int !Int
10:34:02 <skorpan> i see
10:34:13 <Cale> and it's a lighter syntax
10:34:16 <skorpan> but this is basically just a matter of replacing newtype with data right?
10:34:22 <Cale> Less parens and commas to type :)
10:34:25 <Cale> yeah
10:34:32 <skorpan> cool, thanks
10:34:53 <eden_> Cale: Missed it. Is it the newtype SS thing that does the trick?
10:34:55 <Berengal> skorpan: Well, you'd have to replace the tuple as well, or you'd have a constructor taking a single tuple
10:36:25 <skorpan> why oh why does showList want ShowS...
10:36:33 <skorpan> feels like too much continuation.
10:36:58 <Cale> eden_: yes
10:37:15 <Cale> eden_: You can't define the instance otherwise, because there's already an instance which covers that case.
10:37:31 <Cale> skorpan: Don't define your own showList
10:37:43 <Cale> skorpan: Well, unless you *really* want to...
10:37:59 <Cale> skorpan: The default one is usually good enough. You can just define show
10:38:19 <ski> Twey : the `IO' monad also has pure semantics, in the same sense as e.g. `ST s' (i.e. you can't write code which breaks equational reasoning)
10:38:40 <ski> dons : at <http://code.haskell.org/~dons/code/adaptive-containers/> why do you talk about "polymorphic types" as opposed to "parametric types" ?
10:38:56 <skorpan> Cale: i basically want [2,3,4] to become "2, 3, 4"
10:38:57 <ski> dons : imo a polymorphic type would be one whose kind has an outer `forall' (similar to a polymorphic value being one whose type has an outer `forall', e.g. `[] :: forall a. [a]' is an example of a polymorphic list (value))
10:39:43 <Cale> skorpan: Oh, okay, then you really would need to write your own showList, however, it's probably more advisable to write a separate function to do this.
10:39:51 <skorpan> Cale: actually, i want [MyPos 3 4, MyPos 4 5] -> "L3C4, L4C5"
10:40:05 <Cale> skorpan: A lot of people rely on Show instances producing valid Haskell code.
10:40:33 <dropdrive> Hi, newbie question.  Given a ByteString that contains the string representation of a Double, how do I get a Double?  Thanks.
10:40:35 <skorpan> Cale: maybe you're right
10:40:38 <ski> (dons : actually, maybe "parametric types" should be "parameterized types". the former perhaps implies something with parametricity. cf. functions as parameterized values)
10:40:56 <dropdrive> Is it just read?
10:41:10 <Cale> dropdrive: You may have to unpack first...
10:41:34 <dons> edwardk: monoids unconditionally imports Test.QuickCheck in Data/Group/Combinators.hs
10:41:35 <Cale> dropdrive: though that isn't terribly efficient, I don't think there's an existing ByteString parser for Doubles.
10:41:38 <dons> although QC is supposed to be optional
10:42:04 <dons> ski: because we take polymorphic types, and then make them parametric
10:42:19 <dons> i.e. the types in the lib are mirrors of the standard polymorphic types
10:42:19 <ski> dons : imo `Maybe' is not a polymorphic type
10:42:30 <dons> well, that's an interesting point.
10:42:31 <ski> it is a parameterized type
10:42:38 <ray> it seems to be a common haskell mistake that whenever someone wants a function a -> String they think it needs to be show
10:42:39 <ski> same with tuple types, list types, et.c.
10:43:06 <dons> the concept I'm getting at is that the type uses a standard boxed closure representation to hold some unconstrained type 'a'
10:43:25 <ski> Flip :: forall_kind k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *  -- *this* would be a polymorphic type
10:43:39 <dropdrive> Cale: right, I always see people saying that unpacking is bad.  Is there an existing ByteString parser for anything else?  e.g. Integer, or 32-bit integers, etc.?
10:43:45 <edwardk> dons: ah woops
10:44:00 <edwardk> dons: i never did finish cleanup up those flags once i added them
10:44:20 <Cale> dropdrive: There's one for Int and Integer in the library
10:44:29 <ski> dons : i agree that's a useful property to name. but i would prefer not using the word `polymorphic' to describe that property of a type
10:44:37 <edwardk> hrmm, i need a name for a parser combinator library
10:44:40 <edwardk> Parsnip?
10:44:51 <roconnor> parsec
10:44:59 <edwardk> roconnor: =P
10:45:01 <ray> parsley
10:45:14 <edwardk> ray: iirc meacham grabbed that or was it frisbee?
10:45:31 <infoe|wk> sparse
10:45:34 <ski> dons : i might suggest `parametric'(?), though that might easily be confused with `parameterized' (i.e. taking parameters .. having a function kind `k0 -> k1')
10:45:43 <edwardk> whoa, parsley does appear to be untaken, hrmm
10:46:01 <olsner> parsley sounds like it would be most appropriate for an earley parser
10:46:09 <BONUS> parsony
10:46:13 <BONUS> :]
10:46:41 <dmhouse> ParCombLib!
10:46:46 <dmhouse> Oh wait, we're being fun.
10:46:51 <dropdrive> Cale: Thanks, I see it.  (I keep looking in Data.ByteString and not in Data.ByteString.Char8.)
10:46:59 <edwardk> olsner: well, its an earley-based parser, i just have to change the way it handles completion because it can parse in either left ro right or right to left order and has to fold together partial parses
10:47:14 <olsner> parsley then :)
10:47:18 <BONUS> parsetastic
10:47:25 <dmhouse> Parseosaurus.
10:47:38 <infoe|wk> parsalec
10:47:50 <ski> (dons : anyway. i don't know what the best term to use is. i just wanted to state my opinion that `polymorphic' is not appropriate)
10:47:51 <Berengal> Parseonaut?
10:48:42 <edwardk> skimming /usr/share/dict/words -- parson and parsimony are the only ones not yet mentioned ;)
10:49:27 <edwardk> parsimony has nice connotations
10:50:52 <dmhouse> "extreme or excessive economy or frugality; stinginess; niggardliness"?
10:51:09 <edwardk> dmhouse: if you are looking for a very conservative space efficient bottom up parser?
10:51:31 <dmhouse> I guess so.
10:51:46 <roconnor> I can't wait for the Density Comonad chapter of "learn you a haskell"
10:51:54 <edwardk> woot
10:51:58 <roconnor> or the zygohistomorphic prepromorphism chapter
10:52:15 <edwardk> roconnor: heh, you know i wound up using the yoneda lemma twice while deriving my parser combinators ;)
10:52:16 <roconnor> actually, I can wait for that last one
10:52:49 <roconnor> you mean (a -> b) -> (b -> r) -> (a -> r)  ?
10:52:50 <edwardk> its nice because you can apply it piecemeal to individual constructors in it GADT
10:53:00 <ray> learn you the definitions of scary-sounding category theory concepts
10:53:07 <olsner> yeah, I'm really dying for someone to produce a legible description of the zygohistomorphic prepromorphisms
10:53:14 <edwardk> nah that there is an isomorphism between forall a. (a -> b) -> f b    and f a
10:53:42 <roconnor> edwardk: your bound and free variables don't make sense there
10:53:50 <roconnor> forall b?
10:53:53 <edwardk> er forall b
10:54:12 <roconnor> that's the yoneda lemma?
10:54:48 <sclv> @remember roconnor I can't wait for the Density Comonad chapter of "learn you a haskell"
10:54:48 <lambdabot> Good to know.
10:54:50 <edwardk> i used it so i could replace constructors like Sym :: s -> Parser t s t -- with Sym :: s -> (t -> a) -> Parser t s a -- which made fmap not have to change the shape of the parser
10:55:15 <edwardk> roconnor: in essence, replacing Set with Hask
10:55:21 <roconnor> I had no idea that was the what Yoneda said
10:55:33 <roconnor> that seems way more useful than I was thinking
10:56:32 <roconnor> edwardk: why forall b. (a -> b) -> f b and not forall b. (a -> f b) -> f b  ?
10:56:33 <edwardk> roconnor: you can then view the yoneda lemma as a right kan extension along the identity functor
10:56:47 <roconnor> edwardk: that description doesn't help me :)
10:56:56 <edwardk> roconnor: because that would be the density monad =)
10:57:00 <edwardk> er codensit
10:57:16 <roconnor> right.  But wouldn't both make things more efficent
10:57:26 <roconnor> why choose one over the other?
10:57:43 <edwardk> roconnor: they both have uses. i use yoneda when i just want to accumulate fmaps and force fmap fusion
10:57:57 <edwardk> i use codensity when i want to do the same for binds
10:58:02 <roconnor> okay, that's why it looked like
10:58:21 <roconnor> but does yoneda fuse maps more efficently than codensity?
10:58:36 <roconnor> codensity appears to do all that yoneda does, plus more!
10:58:59 <roconnor> or does yoneda also work on plain functors?
10:59:07 <edwardk> fmap f m = Yoneda (\k -> runYoneda m (k . f))
10:59:15 <edwardk> and you can Yoneda anything, even a Comonad
10:59:27 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Functor/Yoneda.hs
10:59:44 <olsner> still, you can't simply Yoneda into mordor
10:59:46 <edwardk> though its more efficient to use the contravariant form of the yoneda lemma for comonads
11:00:31 <ski> edwardk : probably you meant an isomorphism between `forall b. (a -> b) -> f b)' and `f a'
11:00:49 <roconnor> edwardk: where is liftYoneda?
11:00:56 <edwardk> the contravariant yoneda lemma basically says there exists an isomorphism between exists b. (# b -> a, f b #) and f a
11:01:11 <edwardk> ski: yeah roconnor caught it shortly thereafter
11:01:21 <ski> (er, s/f b)/f b/)
11:01:23 <edwardk> roconnor: its hreturn
11:01:31 <edwardk> roconnor: Yoneda forms a higher order functor in category-extra terms
11:01:47 <ski> (edwardk : no, roconnor had `(a -> f b)' in it, not `(a -> b)')
11:02:04 <roconnor> [13:53] <roconnor> forall b?
11:02:17 <ski> <roconnor> edwardk: why forall b. (a -> b) -> f b and not forall b. (a -> f b) -> f b  ?
11:02:17 <roconnor> [13:53] <edwardk> er forall b
11:02:29 <edwardk> ski: i figured those were disjoint thoughts
11:02:36 <roconnor> they were
11:02:36 <ski> oh .. you are right
11:02:47 <ski> sorry, misunderstood
11:03:22 <roconnor> edwardk: strange.  Yoneda f  is a functor, but neither hreturn nor lowerYoneda have any (Functor f) restrictions
11:03:23 <edwardk> anyways hreturn is to let Yoneda just be an instance of http://comonad.com/haskell/category-extras/src/Control/Functor/HigherOrder.hs
11:03:39 <edwardk> roconnor: yep. thats the nice thing about Yoneda.
11:03:49 <roconnor> that's mindboggling
11:03:53 <ski> edwardk : is that similar to replacing `GetChar :: IO Char' with `GetCharBind :: (Char -> IO a) -> IO a' ?
11:04:16 <edwardk> roconnor: you need to know how to make an initial value in Yoneda f a, but from there you can map it. this lets you actually put 'constraints' on a without saying what they are
11:04:30 <kadaver_> hmm gtk2hs is gtk+haskell stuff?
11:04:41 <roconnor> edwardk: I didn't really understand that
11:04:43 <kadaver_> so to use gtk with c i dont need all that?
11:04:53 <edwardk> ski: that would be closer in spirit to ContT
11:05:20 <ski> yes .. i just wondered if one could think of this in terms of yoneda ..
11:05:38 <dufflebunk> kadaver_: GTK /is/ C.
11:06:01 <ski> hm .. with yoneda, you'd possibly get `GetCharMap :: (Char -> a) -> IO a' ..
11:06:07 <edwardk> ski: its closer to codensity than yoneda
11:07:17 <glguy> is there a script that posts to hpaste and uses '.' as the title and author?
11:07:37 <edwardk> roconnor: basically think of Yoneda f a being a mendler style encoding of f being a Functor. you need no secret decoder ring or dictionary to get inside f to manipulate it, thats packaged up in the type of Yoneda f.
11:08:16 <roconnor> I guess I would need to see some uses of Yoneda f where f isn't a functor
11:08:41 <ski> glguy : <http://haskell.org/haskellwiki/Hpaste.el> might be useful, if you use emacs
11:08:43 <glguy> edwardk, what kind of speedup didn't you see from the unboxed state monad?
11:08:57 <roconnor> but I imagine it as you are delaying putting a inside f, so you can play with it first.
11:09:16 <roconnor> hmm
11:09:20 <roconnor> not sure that makes sense
11:09:23 <edwardk> roconnor: ok, for that lets flip to the contravariant yoneda lemma and apply it to an f-Algebra
11:09:40 <edwardk> data Foldr a b = forall c. Foldr (c -> b) (a -> c -> c) c
11:10:13 <edwardk> glguy: its about 4x faster than the conventional MTL State and about 40% faster than the equivalent boxed CPS transformed State
11:10:23 <roconnor> instance HPointed Yoneda where
11:10:24 <roconnor> 	hreturn a = Yoneda (\f -> fmap f a)
11:10:27 <roconnor> what fmap is that?
11:10:36 <edwardk> hreturn says that f is a functor
11:10:45 <roconnor> oh pfft
11:10:52 <edwardk> class HFunctor m => HPointed m where 	hreturn  :: Functor f => f a -> m f a
11:10:54 <roconnor> I knew that functors would appear somewher
11:10:58 <roconnor> Now I feel better
11:11:09 <roconnor> the world makes sense again
11:11:12 <edwardk> roconnor: hahaha
11:11:25 <roconnor> edwardk: it seemed so impossible before
11:11:46 <edwardk> roconnor: you need a potentially valid definition of fmap to 'package up' a Yoneda, and you need a potentially valid definition of fmap to 'unpackage' a CoYoneda.
11:11:54 <edwardk> but you get the other side for free
11:12:12 <glguy> edwardk, is the only difference that Int#s are passed along by the bind?
11:12:18 <ski> can one have a useful example of an `f' where `HFunctor f', but no sensible `HPointed f' is possible ?
11:12:28 <edwardk> but note that you don't have to be able to supply the 'packaging' operation for all a' for Yoneda, or for unpackaging operation for all a for CoYoneda so there are cases where it applies that you can't define fmap
11:12:54 * ski probably should look at the exact definition of `HFunctor'
11:13:03 <wli> What's the new way if not Text.ParserCombinators.*?
11:13:09 <edwardk> glguy: well, if you look at the bind and return they partially apply the continuation so they work above the Int# on the stack
11:13:19 <edwardk> glguy: so it sits there unmolested
11:14:23 <edwardk> glguy: normally with State you keep shuffling it around among the top few slots of the haskell stack while you call funtions fmap this that and the other thing
11:14:50 <edwardk> in fact 10% of the speed win for just moving to the CPS transformed state was in swapping the order of the continuation and state just to avoid the constant flips
11:15:24 <edwardk> forall o. (a -> s -> o) -> s -> o -- is ~10% faster than forall o. s -> (a -> s -> o) -> o
11:15:29 <wli> Which constant flips?
11:15:51 <edwardk> because if you don't use the state s you can partially apply that function
11:16:21 <wli> What should one import if not Text.ParserCombinators.*?
11:16:37 <edwardk> wli: Text.Parsec.*
11:16:55 <edwardk> wli: or wait a few days for me to get bored and abandon my shiny new monoidal parser combinators
11:17:57 <edwardk> wli: you love all the obscura of various parser types. do you know a name for a class of grammars that only allows monoidal synthesized attributes?
11:18:14 <wli> edwardk: No clue.
11:18:28 <edwardk> wli: its close to a van wijngaarden grammar, in that the vW grammars used strings as the only form of attribute they allowed
11:18:33 <edwardk> and a string is a free monoid
11:19:48 <glguy> edwardk, does the story stay as fast if you make it a transformer?
11:20:09 <Cale> Well, the set of all strings is a free monoid ;)
11:20:40 <edwardk> glguy: what i have is a family of 'right kan extension transformers' that transform monads in right kan extension form into other right kan extensions, basically it only CPS transforms once.
11:20:48 <edwardk> glguy: in that case it does
11:20:59 <edwardk> glguy: and those extend apparently to cover the entire MTL
11:21:17 <edwardk> glguy: and you can codensity or yoneda the basic monads to get them into this form
11:21:47 <edwardk> so what i'm doing is making a data family RanT :: (* -> *) -> * -> *
11:21:58 <edwardk> and instantiating it for the different members of the MTL
11:22:06 <edwardk> its not _quite_ a MonadTrans, but its close
11:22:09 <glguy> I don't know what any of those category-theoretic terms are :)
11:22:10 * dufflebunk wonders why people say Haskell is only for academics, when there are discussions like this
11:22:14 <edwardk> and you'll be able to say
11:22:28 <edwardk> RanT (StateT s (ReaderT m IO)) a
11:22:30 <Twey> dufflebunk: Blub factor
11:22:44 <edwardk> and it'll CPS transform it once into an efficient form that looks like
11:22:54 <edwardk> forall o. (a -> s -> o) -> r -> s -> o
11:22:59 <edwardk> after the newtype noise is gone
11:23:25 <roconnor> edwardk: your m disappeared
11:23:35 <roconnor> er
11:23:38 <roconnor> your IO disappeard
11:23:39 <edwardk> er IO did =)
11:23:41 <edwardk> yeah
11:23:44 <roconnor> your m turned into an r
11:23:51 <Lemmih> Why is nofib called nofib?
11:23:59 <roconnor> edwardk: D-
11:24:00 <edwardk> ok, pretend i used StateT s (Reader r) a =)
11:24:07 <edwardk> you get the general idea
11:24:24 <Cale> Lemmih: Because it's designed to provide something better than fibonacci for benchmarking. :)
11:24:46 <edwardk> the goal is to make a nice easy to use type that you can just bolt in and it 'does the right thing'
11:24:59 <edwardk> btw- there are a number of yoneda and coyoneda cases in there of non-Hask functors
11:25:06 <Lemmih> Cale: Ah, thanks.
11:25:06 <roconnor> Lemmih: as such it is a less lying benchmark
11:25:06 <Igloo> It's a pun of both what Cale said, and also "not a lie" (like benchmarks generally are)
11:25:16 <edwardk> i need the yoneda lemma of Endo for instance
11:25:20 <Cale> dufflebunk: I prefer to say that it's for both academics and practical use. That's actually what I like about it.
11:26:06 <Twey> I would say that any serious academic language (i.e. not Iota) should be perfectly suitable for practical use
11:26:12 <Twey> If it's not, it's something of a failure :-P
11:26:23 <Cale> hmm...
11:26:23 <Twey> The one thing that does tend to be lacking is libraries.
11:26:26 <roconnor> dufflebunk: you may be laughing now, but when edwardk's code is only 50% slower than C, then we will see who is laughing!
11:26:27 <edwardk> i.e. -- Maybe a ~ Yoneda Endo a ~ ∀o. (a → o) → o → o ~ ∀o. (a → Identity o) → Endo o
11:26:32 <monochrom> Q: "Is Haskell of academic interest or practical interest?" A: "Yes!"
11:26:33 <dufflebunk> Cale: So do I. I still have no idea what they were talking about for the last 15 minutes though ;)
11:27:06 <edwardk> roconnor: and the last one you can see is Ran Identity Endo -- Maybe can be encoded as a right kan extension
11:27:10 <Cale> dufflebunk: They're talking about making use of ideas from category theory to make programs run faster.
11:27:14 <dufflebunk> roconnor: Probably me, because I'll be using it... well, if I ever figure out what it is
11:27:19 <Twey> @faq Can Haskell be used for practical or purely academic uses?
11:27:19 <lambdabot> The answer is: Yes! Haskell can do that.
11:27:36 <edwardk> dufflebunk: the goal is to make it opaque so you can use it like the MTL and not have to think about it
11:28:08 <edwardk> dufflebunk: same with the adaptive-container and adaptive-monad-ran stuff i've been obsessing about
11:28:31 <roconnor> edwardk: endo isn't a functor?
11:30:04 <dolio> It's not a Functor, certainly.
11:30:27 <roconnor> What is the use of Yoneda Endo then?
11:31:16 * gwern stifles a star wars joke
11:31:16 <roconnor> oh it is a CPSed Maybe
11:31:23 <roconnor> that is so bizarre
11:31:44 * wli tries to get deterministic Rabin-Miller going.
11:32:07 <cypher-> what kind of literature would you recommend to bring one up to speed with understanding what the heck you guys are alking abou?
11:32:10 <cypher-> *about
11:32:32 <roconnor> PhD in mathematics
11:32:37 <roconnor> j/k
11:32:50 <edwardk> gotta run
11:32:58 <cypher-> so it seems LOL
11:33:36 <roconnor> if it helps only edwardk and Cale even know what a Kan extension is.
11:33:57 <dolio> Endo is an ExpFunctor, from category-extras, or whatever. But I don't know where those come from in category theory, exactly.
11:34:52 <roconnor> cypher-: step 1 would be to study continuation passing style
11:35:13 <roconnor> I think that underlies a lot of the motivation of this conversation
11:35:30 <roconnor> and CPS is well documented
11:35:38 <cypher-> roconnor: I was trying to do that lately
11:35:56 <cypher-> and I saw an evil CPS exam question that I could not solve :-/
11:36:13 <cypher-> from last year's lambda calculus exam
11:36:19 <roconnor> I used a CPS transform to make my code 4x faster 2 years ago
11:36:31 <roconnor> that started me down this path of slow understanding
11:36:51 <roconnor> it really helps to have practical examples that you yourself have used and can relate to
11:37:42 <roconnor> I now know (2 years later) that my CPS transform was more accurately a codensity monad transform, which is similar in flavour to these Yoneda transforms
11:37:59 <roconnor> but if it weren't for that work 2 years ago, I'd be totally lost
11:38:24 <roconnor> My point is, it takes time an experience.
11:38:39 <cypher-> I see
11:38:46 <roconnor> perhaps it could be taught, but I think all this stuff is pretty new and maybe not well understood yet.
11:38:58 <roconnor> so few resources are available.
11:39:23 <cypher-> and now you're doing PhD or post-doc in computer science?
11:39:28 <roconnor> yes
11:40:54 <roconnor> cypher-: also, this stuff is only needed to develop these sorts of libraries (which of course is intersting), but won't be needed to use the libraries
11:43:05 <Cale> Heh, and in my case, saying that I know what a Kan extension is might be pushing it a little ;)
11:43:18 <Cale> I can understand the definition anyway :)
11:43:27 <glguy> that adaptive container instance for () seems to discard the (), which thanks to async exceptions can be any number of types
11:43:36 <roconnor> okay, only edwardk knows what a Kan extension is
11:43:52 <dolio> The thing about Kan extensions is that you need to know what (co)ends are first. And the only immediate resource is this: http://en.wikipedia.org/wiki/End_(category_theory)
11:43:56 <Cale> Apparently all concepts are Kan extensions.
11:43:58 <monochrom> Piaget's theory implies that you need concrete experience at one level of abstraction to learn the next. (It is a necessary condition, sometimes not sufficient, but nothing else is sufficient.) The idea that you can learn anything by just reading and talking is flawed. You have to play.
11:44:44 <dolio> Which doesn't really give you any intuition about what (co)ends are, or what motivates them.
11:44:47 <roconnor> monochrom: sounds like my advice on getting experience with CPS first is good advice.
11:45:51 <monochrom> Yeah, your conversation reminds me of that.
11:45:52 <dolio> There's also an edwardk blog post that shows how to encode them in Haskell, but I'm not sure that explains their motivation either. :)
11:46:58 <monochrom> Another point. Intuition is a person's own generalization of his/her concrete experience. It is very personal. The idea that someone else can tell you their intuition and it will make sense to you is flawed.
11:48:01 <monochrom> Until one day humans come with USB ports for downloading and uploading raw brain images.
11:49:08 <dufflebunk> damn, my brain image machine uses serial ports.
11:49:11 <dolio> I mean, I can watch edwardk say, "look, if I stick Endo in for g, and Id in for f, I get the type of CPSed Maybe," but that doesn't mean much to me.
11:50:05 <roconnor> dolio: well, it is pretty clear when you expand out the definitions
11:50:19 <roconnor> ... assuming you know what a CPSed Maybe looks like
11:50:28 <roconnor> which I suppose might be a big assumptions
11:50:50 <dolio> No, I get CPSed Maybe. I don't get why I should be thinking about Kan extensions with regard to that.
11:50:58 <roconnor> :)
11:51:24 <dolio> Other than "Ran f g a = forall o. (a -> f o) -> g o", and if we stick in certain things for f and g, we get the right thing.
11:51:41 <roconnor> I'm with you on that
11:52:53 * dufflebunk saunters back the relative simplicity of the FFI
11:53:53 <Philippa_> monochrom: yeah. I tell people my intuitions, and ones that I'm aware of but discard, but they're to offer people a partial map to try to attach their own intuitions to
11:54:51 <Philippa_> btw: anyone got any advice on idioms for using open recursion in haskell without driving yourself nuts?
11:55:06 <Philippa_> (I probably /really/ want it coupled with extensible records, but that's life for you)
11:55:13 <olsner> what's open recursion?
11:56:00 <FliPPeh> You and me baby ain't nothin' but mammals~
11:56:01 <FliPPeh> Lala.
11:56:06 <monochrom> I just mechanically turn "f ... = ... f ..." into "f ... s = ... s ...".  Or maybe I make s the first parameter rather than the last.
11:56:19 <FliPPeh> @faq Can Haskell do it like they do on the discovery channel?
11:56:19 <lambdabot> The answer is: Yes! Haskell can do that.
11:56:35 <Botje> first is better because you can still do partial application :)
11:57:03 <monochrom> Last is probably more convenient for fix.
11:57:22 <monochrom> Or is it? I can't think.
11:57:41 <ski> Philippa_ : would something like they use in the interpreters in "The Essence of Dataflow Programming" work ?
11:58:11 <monochrom> Yes, always make it first.  Turn "f = \params -> ... f ..." into "f s = \params -> ... s ...".
11:58:33 <Philippa_> ski: I haven't read that in a while and it went over my head a bit at the time - it might do, the comonad/context link makes sense
11:58:39 * EvilTerran notes that going from "foo ... = ..." to "foo foo ... = ..." (usually) works
11:59:03 <monochrom> Heh, evil reuse of names and use of shadowing.
11:59:05 <Philippa_> monochrom: in particular, I want a sensible idiom for doing open recursive record update
11:59:13 <EvilTerran> because the parameters' scope is inside the function name's scope
11:59:18 <ski> Philippa_ : this issue doesn't really have with monads or comonads to do .. i just mean how they define a class with a method `ev', and use that for a kind of open recursion
11:59:42 * EvilTerran is Evil.
11:59:51 <ski> (Philippa_ : that paper was just where i'd seen that style used)
11:59:59 <wli> Okay, this thing is cooking.
12:00:00 * ski is i
12:00:02 <Philippa_> ski: hmm, will read. If I need lots of boilerplate per field, it's going to be painful
12:00:29 <EvilTerran> ski, so "i" is your identity, then? :P
12:01:16 <ski> Philippa_ : btw, note that they use it for open recursion on a variant type (if haskell had variant type super-typing, they should have used that as well, coupled with this) .. but i suspect the open recursion on records would not be much different
12:01:29 <Philippa_> ski: *nod* - duality ahoy
12:01:50 <Philippa_> in fact, rather appropriately so: I'll be working with records of parsers, 'nuff said?
12:01:56 <ski> EvilTerran : no, `s k i' is the same function as `i'
12:02:07 * EvilTerran expands...
12:02:25 <ski> (Philippa_ : btw, you are making a function that *returns* a record, right ?)
12:02:30 <EvilTerran> skix = kx(ix) = x, i c wut u did thar.
12:03:51 <Philippa_> ski: well, what I /want/ to encode is a module-of-parsers I'll keep applying deltas to. I have to admit, I'm reaching that level of old-fartness where the level of encoding on nearasdammit anything tires me out
12:05:33 <skorpan> :t undefined
12:05:34 <lambdabot> forall a. a
12:05:43 <skorpan> :t ()
12:05:44 <lambdabot> ()
12:05:49 <skorpan> which is bottom?
12:05:54 <monochrom> undefined
12:07:15 <FliPPeh> > undefined
12:07:16 <lambdabot>   * Exception: Prelude.undefined
12:07:25 <ski> > let x = x in x
12:07:36 * JuanDaugherty cautions Phillippa about the old-fartness event horizon.
12:07:37 <ski> .
12:07:38 <skorpan> > let x = undefined in x
12:07:40 <lambdabot>   * Exception: Prelude.undefined
12:07:40 <lambdabot>   thread killed
12:07:40 <ski> ..
12:07:57 <skorpan> > let x = undefined in 5 * (x / x)
12:07:58 <lambdabot>   * Exception: Prelude.undefined
12:08:08 <JuanDaugherty> Philippa_ even
12:08:16 <skorpan> > let x = undefined in 5 * (x * 0)
12:08:17 <lambdabot>   * Exception: Prelude.undefined
12:08:27 <monochrom> undefined is not the only bottom. the other bottom is infinite loop. and how can you or anyone be sure that a loop is an infinite loop?
12:08:31 <ski> Philippa_ : you mean you're constructing a record of parsers ? mutually recursively defined in terms of "smaller instances of themselves" ?
12:08:38 <skorpan> monochrom: halting problem?
12:08:49 <monochrom> yes
12:08:55 <Philippa_> JuanDaugherty: I suspect how fast you get there depends on just how full of beans you are
12:09:08 <skorpan> why is the infinite loop bottom?
12:09:18 <ski> because it doesn't return a valid value
12:09:23 <wli> Okay, moving from trial division to deterministic Rabin-Miller reduces the space footprint to ca. 3MiB and vastly accelerates the progress through the search space.
12:09:28 <Philippa_> ski: sort of, yeah. Building up from a simple STLC surface syntax to something larger and more sugary, say
12:09:35 <Philippa_> (obviously that one wants extensible records)
12:09:44 <skorpan> does that mean that anything which doesn't return a valid value is bottom in haskell?
12:09:44 <monochrom> It doesn't give an answer. bottom is used to model that. no answer.
12:09:48 <Philippa_> I actually want to have one of these per sort too, mind
12:10:08 <dropdrive> How do I see what GHC thinks the signature of one of my functions is?
12:10:16 <Philippa_> but half of the point is being able to say "the usual, only..." with the difference being the record update. You can see where the recursion fits in there, right?
12:10:35 <monadic_kid> dropdrie: :t in the repl
12:10:51 <monadic_kid> dropdrie: :t <exper>
12:10:58 <monadic_kid> *<expr>
12:11:18 <ski> Philippa_ : ok
12:11:23 <dropdrive> monadic_kid: Ah.  Is there a way from the cmdline?  That would make like easier.
12:11:26 <Twey> :t (+)
12:11:27 <lambdabot> forall a. (Num a) => a -> a -> a
12:11:40 <ski> (Philippa_ : i once did a monad whose actions was records that included actions from two other monads. the monad operations constructing a new record with actions used both sub-actions of the records arguments .. i was thinking what you did was maybe somewhat similar to this)
12:11:52 <monochrom> skorpan: Yes, both "head []" and infinite loops are bottom.
12:12:22 <skorpan> monochrom: but head [] is only bottom because its value is undefined?
12:12:26 <EvilTerran> skorpan, yeah, bottom is anything which doesn't have a value
12:12:43 <skorpan> so what is the bottom *type*?
12:12:43 <ski> (Philippa_ : maybe .. if you care for it, i think i would better understand what you mean with code example)
12:12:45 <EvilTerran> be it because an exception gets thrown, or because it never evaluates
12:12:51 <ski> skorpan : no
12:12:54 <EvilTerran> skorpan, types aren't ordered in haskell
12:13:17 <monochrom> bottom has to be polymorphic since all sorts of programs of all sorts of types may end up giving no answer.
12:13:37 <ski> (except unboxed)
12:13:39 <EvilTerran> (well, i guess they are, but not like that)
12:13:54 <skorpan> in which languages are types ordered?  are there any programming languages which implement an ordered type system?
12:14:05 <yitz> dropdrive: :t *is* from the ghci command line. do you mean from the shell command line?
12:14:12 <ski> skorpan : type systems with subtyping ?
12:14:20 <dropdrive> yitz: Yes, sorry, from the shell cmdline.
12:14:26 <EvilTerran> skorpan, "is a subtype of" is a partial ordering
12:14:30 <skorpan> oh, i see
12:14:40 <EvilTerran> Scala has a bottom type in that regard
12:15:01 <EvilTerran> (a type that is a subtype of all types, so contains no values)
12:15:03 <EvilTerran> iirc
12:16:04 <yitz> dropdrive: umm... how about echo ':t map' | ghci? it gives a whole mess, but the type is in there somewhere.
12:16:32 <redline6561> excuse me. what pattern match cases do i need for a function :: [(String, String)] -> Bool
12:16:38 <dolio> Well, if you look at (impredicative?) higher-rank polymorphism, you can order some types.
12:16:58 <yitz> redline6561: depends what you're looking for
12:17:02 <dolio> Like (forall a. a) < any other type, in that the values in the first are contained in the second.
12:17:04 <monochrom> perhaps (x,y):rest
12:17:16 <ski> redline6561 : depends .. you could define `function _ = False' .. but that's probably not what you want
12:17:28 <dolio> And any-type < (exists a. a), since the latter contains every value of the former.
12:17:47 <dropdrive> yitz: I'll give it a shot, thanks.
12:17:59 <dolio> And so on.
12:18:07 <redline6561> yitz, ski: cale was helping me with this earlier -- http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2296#a2297
12:18:14 <redline6561> ski: that might not be a problem actually
12:20:01 <Cale> redline6561: [] and (x,y):xs would do
12:20:04 <unC0Rr> hello! what would be a good approach of getting asynchronous reply from mysql server? currently I use TChan and forkIO'd thread, but it freezes all program in mysql driver. With forkOS it seems nothing goes through TChan
12:20:31 <Cale> unC0Rr: Are you using the threaded runtime?
12:20:34 <redline6561> Cale: thanks!
12:20:39 <yitz> redline6561: you also might want just x, if you can work with the [(String, String)]
12:20:48 <redline6561> ski: that actually helped a bit, playing further...
12:21:06 <Cale> redline6561: Oh, you're looking for mapM or forM, I think
12:21:08 <unC0Rr> Cale: yes, or it would complain
12:21:11 <Cale> redline6561: from Control.Monad
12:21:22 <redline6561> Cale: i'll have a peek
12:21:31 <Cale> redline6561: printFunnies xs = forM xs $ \(x,y) -> print (...)
12:21:40 <redline6561> yitz: what do you mean by just x?
12:22:01 <yitz> redline6561: or xs. like what Cale just said.
12:22:10 <redline6561> yitz: okay. thanks.
12:22:29 <redline6561> cale: aha. much nicer than this monster ... printFunnies [[(a,b)]] = print (a ++ tail b ++ "\n")
12:23:36 <Cale> unC0Rr: hmm... I've never really tried interacting with mysql from Haskell... which database library are you using? (Or are you writing your own?)
12:24:05 <unC0Rr> Cale: hdbc with hdbc-mysql driver
12:24:30 <Cale> If you compile a program without -threaded and it does an FFI call which blocks, the whole program blocks.
12:25:30 <unC0Rr> I have already realized that
12:25:36 <Cale> okay
12:25:56 <ski> redline6561 : if you want your function to do something more interesting, but still non-recursive, you can do stuff like
12:25:59 <ski>   function [] = False
12:26:01 <Cale> I wonder what else it could be...
12:26:06 <ski>   function [("foo",_)] = True
12:26:17 <ski>   function [(s,t)] = s == t
12:26:30 <ski>   function (_:_) = False
12:27:08 <yitz> Cale: what do you think of my proposal for XNoMR by default in ghci?
12:27:21 <Cale> yitz: I think it should be by default in GHC.
12:27:41 <yitz> Cale: well, that will be harder to get everyone to agree upon
12:27:42 <Cale> I currently add it to my .ghci
12:27:49 <ski> redline6561 : but often, if you want a recursion, it suffices to consider two cases : `function [] = ...' and `function ((s0,s1):ss) = ..s0..s1..ss..' where the latter case includes a recursive call to `function'
12:27:52 <yitz> Cale: I think just about everyone does.
12:28:04 <Cale> But the only problem with that is that when I go to compile the program, sometimes I trip over that.
12:28:22 <lispy> yitz: I would prefer it as an overall default because I worry that turning it off in one and not the other will create confused newbies.
12:28:22 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:25 <yitz> Cale: really? what goes wrong?
12:28:55 <Cale> yitz: Well, I forget to put {-# LANGUAGE NoMonomorphismRestriction #-} in my code, and it doesn't compile.
12:29:09 <Cale> yitz: So I end up having to go back and edit it at that point.
12:29:12 <yitz> lispy: I think they get tripped up a lot more by having it on in ghci than they would by that.
12:29:19 <Cale> (just a small annoyance, but it would be moreso for a beginner)
12:29:22 <redline6561> ski: sorry. was away. thanks for that pointer.
12:29:31 <yitz> lispy: and I am pessimestic about the chances of getting it turned off by default in both
12:29:52 <lispy> yitz: yeah, may be best to get this for Haskell'
12:29:55 <Cale> Better than getting it turned off, perhaps, would be having it turned into a *warning*
12:30:06 <Zao> Is Leksah in any usable state or is it still quite experimental?
12:30:06 <Cale> The MR never should have been an error in the first place.
12:30:10 <lispy> Cale: good point
12:30:17 <yitz> Cale: when MR is off in ghci and you :load, it is also off when compiling the module?
12:30:23 <unC0Rr> Cale: added some tracing putStrLn, and I see it works when I do forkIO, and mysql driver refuses to connect when I do forkOS
12:30:26 <lispy> Zao: Never tried it, but the threads on -cafe made it sound quite usable
12:30:28 <Cale> yitz: I think so, yes
12:30:37 <yitz> Cale: hmm. maybe it'
12:31:02 <yitz> maybe it's possible for it to be off for stuff typed in ghci scope, but still on for :load ?
12:31:28 <redline6561> Zao: my impression was it's pretty usable. there's a cabal package for it. you'll need gtk2 installed on your OS though.
12:31:35 <Zao> lispy: I don't want to go through all the dependency hell to try it out :)
12:31:55 <redline6561> Zao: cabal install leksah should deal with dependencies provided gtk is installed
12:31:59 <yitz> I would be against a warning. it would be really annoying, it would come up all the time.
12:32:02 <Cale> unC0Rr: Interesting.
12:32:16 <Cale> unC0Rr: Is there a good reason to use forkOS?
12:32:16 <Zao> redline6561: I'm on Windows. No gtk, no editline, no pie.
12:32:18 <redline6561> Zao: of course if you don't have cabal...
12:32:23 <redline6561> Zao: ouch.
12:32:54 <Zao> Although I have msys and mingw installed so I could build all the packages that stupidly rely on sh.
12:33:03 <unC0Rr> Cale: my program is game server, so it's not good for it to freeze from time to time for seconds
12:33:28 <Cale> unC0Rr: Yeah, but Haskell threads are usually sufficient.
12:33:41 <Cale> unC0Rr: GHC's scheduler is not that bad.
12:33:49 <unC0Rr> Cale: not in this case, it seems
12:36:20 <Saizan> are you compiling with -threaded ?
12:36:40 <Cale> It's interesting, usually you only need forkOS to make something work with a foreign library that uses thread-local state.
12:36:58 <unC0Rr> Saizan: yes, I do
12:37:28 <Cale> forkIO/forkOS should not make any difference when it comes to how the program is scheduled
12:37:48 <Cale> Except that threads created by forkOS will always run on the same OS thread.
12:38:21 <redline6561> Zao: there are native gtk binaries for windows and editline shouldn't be needed for leksah...if you have cabal install it might not be too painful. Note issues 57 and 60: http://code.google.com/p/leksah/issues/list
12:39:32 <Zao> redline6561: The wiki mumbled about libedit.
12:39:58 <monochrom> yo dawg, we heard you like haskell, so we put haskell in your editor config files so you have to write haskell before you have an editor up for writing haskell.
12:40:03 <redline6561> Zao: ah, sorry. my bad.
12:40:31 <Zao> I'll probably not use it anyway, unless it happens to have an awesome vim mode.
12:43:11 <Twey> Bah, humbug.
12:43:22 <Cale> monochrom: hahaha
12:43:33 <Twey> How are we supposed to deal with varying linebreaks in Haskell?
12:43:40 <dons> silkworm looks awesome, http://www.reddit.com/r/programming/comments/8hcfl/silkworm_a_2d_physics_game_in_haskell_built_with/
12:43:40 <Twey> \n gets converted to the system linebreak, right?
12:43:52 <Twey> So how can we safely write \r\n, say for HTTP?
12:44:08 <Twey> If the program is run on Windows, that'll become \r\r\n
12:44:17 <Zao> Twey: Open files in binary?
12:44:27 <Twey> Zao: It's actually a socket
12:44:30 <Zao> Use bytestrings and write those?
12:45:18 <Twey> Seems a bit daft, for what's actually a text- and line-oriented protocol
12:45:22 <Philippa_> Twey: IIRC, that particular case works okay. Been a while since I ran into it
12:48:45 <Cale> Silkworm's cabal file seems a little broken. It's missing required deps.
12:48:53 <Cale> (Like Hipmunk, in particular :)
12:49:30 * Cale adds things to make cabal happier.
12:51:42 <Zao> redline6561: No Leksah for me, gtk2hs doesn't do 6.10.2 yet, and I sure am not building _that_ :)
12:52:29 <kadaver_> anyone here use CLojure?
12:53:19 * Cale grumbles about the hard-coded paths...
12:53:36 * kadaver_ grumbles about Cale
12:53:37 <Twey> Cale: Half the Cabal files are missing deps, it seems :-\
12:53:47 <Twey> Philippa_: Oh really?  \n isn't expanded on sockets?
12:54:05 <kadaver_> SPJ grumbles about kadavers mental health
12:54:37 <Twey> What's wrong with your mental health?  :-P
12:56:01 <pk> suppose I have f .. = .. g .. where (g = .. h .. where h = ..)
12:56:16 <pk> can h have acces of what's in f 's scope ?
12:56:31 <Twey> pk: Yes, so long as it's not shadowed somewhere
12:57:03 <pk> ho !
12:57:07 <dons> silkworm is addictive!
12:57:14 <Botje> unless h depends on stuff bound in g, you can just define it in parallel
12:57:17 <dons> Cale: i have a .cabal if you want it.
12:57:51 <dons> http://www.galois.com/~dons/Silkworm.cabal
12:57:55 <Cale> dons: That might be good, though I got it to compile. Did you manage to fix the problem with the game being unable to find its resources?
12:58:08 <dons> yeah, run it in Silkworm/Resources/
12:58:11 <dons> type 'haq'
12:58:11 <Cale> ah
12:58:23 <dons> then hit Return to start. then use the arrow keys to navigate the little silkworm
12:58:25 <Cale> It might be a good idea to make it install them somewhere under ~/.cabal
12:58:27 <dons> its kinda hard!
12:58:31 <pk> but can it access  "do variables"  ?
12:58:38 <Botje> no
12:58:40 <Twey> No
12:58:43 <pk> k
12:58:49 <pk> I need a let for that right ?
12:59:02 <dons> ah, in the screenshots the author gets further than i can get.
12:59:04 <Botje> yes
12:59:08 <dons> i can't get past the columns with gaps
12:59:47 <dons> it needs to use datadir though, to find where the resources are installed
13:00:00 <mercury^> dons: why can't I cabal install it?
13:00:02 <mercury^> :(
13:00:14 * Lemmih falls out over the edge.
13:00:28 <dons> oh, you finished the game, Lemmih ?
13:00:31 <Lemmih> Time to become a butterfly, little worm.
13:00:35 <dons> or did you go the wrong way :)
13:00:47 <Lemmih> Yeah, I think I finished it.
13:00:59 <dons> was it just the arrow keys you used?
13:01:19 <Cale> I just made it past those
13:01:28 <Cale> Hold right, and wiggle up and down a bit :)
13:01:58 <Cale> Heh, I've fallen off the edge of the world, it seems.
13:03:52 <Cale> The level is really short...
13:04:06 <dons> i wonder how you make new levels...
13:04:17 <dons> cabal install silkworm-levels
13:04:41 <Cale> It's a good start on a game though :)
13:04:45 <dons> Lemmih: duane might like a patch to have it use datadir in cabal to install the resources
13:05:12 <Cale> Yeah, it should be on hackage :)
13:05:20 <pk> m = do .. g .. let f = lala .. where g = .. f ..
13:05:31 <pk> does that work ?
13:05:35 <Botje> no
13:05:39 <pk> why ?
13:06:24 <Botje> in the do block, f is only visible from its declaration to the end of the block
13:06:47 <pk> ok
13:07:01 <pk> wait, why ?
13:07:43 <Botje> because that's how do blocks work
13:08:04 <Botje> the transformation from do blocks to regular haskell code is very simple, really
13:08:45 <Botje> @undo do { a; b ; c; let f = d; g; z <- h; i return $ d + z }
13:08:45 <lambdabot>  Parse error at ";" (column 28)
13:08:53 <Botje> @undo do { a; b ; c; let f = d; g; z <- h; i; return $ d + z }
13:08:53 <lambdabot>  Parse error at ";" (column 28)
13:08:58 <Botje> @undo do { a; b ; c; let f = d; g; z <- h; i; return $ d + z; }
13:08:58 <lambdabot>  Parse error at ";" (column 28)
13:09:03 <Botje> what.
13:09:04 <Botje> bleh
13:09:06 <mauke> @undo do { a; b ; c; let {f = d}; g; z <- h; i return $ d + z }
13:09:06 <lambdabot> a >> b >> c >> let { f = d} in g >> h >>= \ z -> i return $ d + z
13:09:12 <Botje> oh.
13:09:17 <Botje> thanks, mauke
13:09:38 <davidL> dons: how do I install the build dependency's based on the .cabal you linked?
13:09:52 <dons> cabal install
13:10:03 <davidL> ahh
13:10:08 <dons> in the Silkworm directory, after putting the .cabal file in the same dir as the current Silkworm stuff
13:10:10 <davidL> without arguments
13:10:13 <dons> yeah
13:10:22 <pk> >> is left associative ?
13:10:22 <davidL> there we go
13:10:35 <mauke> right associative, I hope
13:10:44 <Cale> pk: >> is actually associative, but I believe it associates to the right anyway
13:11:04 <Cale> x >> (y >> z) means the same thing as (x >> y) >> z anyway though
13:11:12 <pk> ok thx
13:11:16 <mauke> preflex: zdec z666U
13:11:16 <preflex>  ٦
13:11:56 <a_guest> When reading a file, should I use the Data.yteStream library or use hGetContents(etc.) on a handle?
13:12:10 <pk> got it
13:12:14 <pk> thx a lot
13:12:15 <a_guest> Data.ByteStream
13:12:20 <davidL> gah [6 of 7] Compiling Physics.Hipmunk.Space failed
13:12:27 <dons> galois.com/~dons/silkworm-linux-x86_64.tar.gz
13:12:35 <dons> binary for linux/x86_64
13:12:50 <dons> unpack; cd Resources ; ../dist/build/haq/haq ; play
13:13:02 <dons> davidL: yeah, likely you don't have chipmunk.
13:13:05 <dons> are you using arch linux?
13:13:08 <davidL> yeah
13:13:15 <dons> yaourt haskell-hipmunk
13:13:21 <dons> use yaourt instead of cabal install for things with C libs.
13:13:26 <dons> since it resolves them.
13:13:38 <dons> yaourt --noconfirm  --lightbg --aur -S
13:14:07 <davidL> excellent
13:14:27 <yitz> dons: how do you pronounce yaourt?
13:14:41 <mauke> frenchly
13:14:49 <yitz> ok
13:15:12 <dons> i don't pronounce it :)
13:15:26 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4500 <-- I have an evaluation-related question
13:15:41 <dolio> Hey dons, is the UIO stuff in uvector known to not work so great?
13:15:47 <Cale> ヤオールト :)
13:15:48 <dons> dolio: yeah. totally just a toy
13:15:53 <dolio> Okay.
13:15:53 <gwern> if I define 'getFileStore = darcsFileStore "./"', would that make each function get run everytime I do something like 'fs <- getFileStore'?
13:15:57 <dons> dolio: pumpkin has an alpha bytestring interface
13:16:05 <dons> which i think we should merge in.
13:16:14 <dolio> Probably a good idea.
13:16:17 <gwern> I ask because these functions are very expensive and I can't seem to track down some calls, and I think maybe things inside the record are getting run
13:16:18 <yitz> Cale: c'est francais aussi
13:16:56 <roconnor> gwern: what do you mean by run?
13:17:06 <roconnor> gwern: evaluation or execution?
13:17:07 <Cale> gwern: fs <- getFileStore means to run the action denoted by getFileStore
13:17:11 <gwern> they're IO functions all; that's what I mean
13:17:16 <Cale> gwern: That is, to execute it.
13:17:33 <Cale> Evaluation of IO actions doesn't mean a whole lot.
13:17:50 <gwern> Cale: oh. so 'darcsLog :: repo -> string' would actually run, generate a string?
13:17:57 <Cale> ?
13:18:14 <roconnor> gwern: well, if you bind getFileStore twice, and execute it, it will of course be executed twice.
13:18:33 <gwern> huh. maybe that is the problem
13:18:35 <roconnor> gwern: but any evaluation that happens will generally only occur once
13:18:39 <Cale> gwern: I'm not certain of what you are asking.
13:18:51 <davidL> woo, it works, I think
13:19:08 <Cale> If you define  getFileStore = darcsFileStore "./"  what you are doing is defining an action getFileStore which is the same as darcsFileStore "./"
13:19:24 <Cale> You can substitute one for the other without changing the meaning of your program.
13:20:03 <gwern> Cale: I am trying to call 'darcsLog' as little as possible. darcsLog is explicitly called, like once now, but when Heffalump edits a page, darcsLog is apparently running, even though manually looking over the gitit code, there should be no calls to darcsLog in the editing code - but there are f<- getFileStore calls, and I'm trying to figure out whether these bindings are the reason for darcsLog being run and wasting entire seconds
13:20:06 <Cale> Mind you, if there's a lot of computation which goes into working out just *which action* darcsFileStore "./" is.
13:20:07 <Cale> ..
13:20:10 <roconnor> Cale: well, let x = dacrsFileStore "./" in x >> x  could have different performace than dacrsFileStore "./" >> dacrsFileStore "./"
13:20:18 <Cale> Then it might be more efficient like that
13:20:21 <Cale> roconnor: right
13:23:24 <mae> dcoutts, dcoutts_, dcouts__: you around?
13:23:32 <gwern> Cale: so how would I make a record that does the same thing except that getFileStore doesn't force all these IO functions?
13:23:57 <Cale> gwern: If you want to run an IO action, there's nothing for it but to run the IO action.
13:23:59 <mae> I need some help, which flag can i use to differentiate between a windows and non-windows platform with the c preprocessor built into ghc
13:24:14 <Cale> gwern: You could instead store the result of the IO action the first time it is run.
13:24:19 <gwern> Cale: I don't want the IO actions in the record to be run unless they're actually used
13:24:29 <Cale> They won't.
13:25:05 <Cale> An IO action never gets run unless it is main or it is part of another IO action which gets run.
13:25:55 <roconnor> they won't even be evaluated either
13:26:27 <Cale> (but you could force an IO action to be evaluated without running it by using seq)
13:26:49 <mauke> or evaluate!
13:26:49 <BrokenClockwork> hey is there an amount function in Haskell?  amount -3 = 3 .... amount 3 = 3
13:26:59 <gwern> abs?
13:27:00 <BrokenClockwork> eh
13:27:00 <mauke> heh
13:27:01 <BrokenClockwork> absolute valute
13:27:02 <Cale> BrokenClockwork: you mean absolute value? It's called abs
13:27:07 <mauke> you are now German!
13:27:08 <BrokenClockwork> thanks
13:27:13 <roconnor> (but you can also execute IO using unsafePerformIO :P )
13:27:33 <roconnor> > abs (-3)
13:27:34 <lambdabot>   3
13:27:37 <roconnor> > abs (3)
13:27:38 <lambdabot>   3
13:27:38 <BrokenClockwork> well I am not just now a german, I was and will be a german :D
13:27:46 <roconnor> > deriv abs x
13:27:47 <lambdabot>   signum x * 1
13:27:57 <mauke> @let abdomen x = abs x
13:27:58 <lambdabot>  Defined.
13:28:18 <mauke> > abdomen (-pi)
13:28:20 <lambdabot>   3.141592653589793
13:28:20 <mercury^> @t deriv
13:28:20 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:28:32 <mercury^> :t deriv
13:28:33 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
13:28:51 <roconnor> :t x
13:28:52 <lambdabot> Expr
13:28:56 <mercury^> @src deriv
13:28:56 <lambdabot> Source not found. My mind is going. I can feel it.
13:29:03 <mercury^> What does deriv do?
13:29:06 <Jedai> > deriv (^ 3) x
13:29:07 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
13:29:16 <mauke> derives derivations
13:29:19 <roconnor> mercury^: takes a derivative
13:29:22 <gwern> what about CAFs? if darcsLog appears in the profiling output as a CAF, does that mean it was run?
13:29:42 <mercury^> How is it implemented?
13:30:03 <roconnor> mercury^: using automatic forward differentiation
13:30:12 <roconnor> aka dual numbers
13:31:28 <roconnor> dual numbers add a new number called epsilon where epsilon^2 = 0
13:31:59 <roconnor> (as opposed to complex numbers which add a new number i where i^2 = -1)
13:32:41 <roconnor> functions are suitably extended to operate on this epsilon
13:33:07 <roconnor> differentiation essentially takes the "epsilon component" of these numbers
13:33:22 <roconnor> (similar to taking the imaginary component of complex numbers)
13:33:50 <roconnor> for example
13:34:20 <roconnor> sin(a + epsilon*b) = sin(a) + b*epsilon*cos(a)
13:34:28 <roconnor> IIRC
13:34:55 <roconnor> cos(a + epsilon*b) = cos(a) - b*epsilon*sin(a)
13:34:55 <mercury^> But how can you implement all that on top of Haskell 98?
13:35:12 <mercury^> Giving x as an argument alone puzzles me...
13:35:14 <mauke> uh. easily?
13:35:19 <roconnor> by defining a datatype Dif a = Dif a a
13:35:21 <mauke> mercury^: x is a predefined variable there
13:35:24 <mauke> > x
13:35:25 <lambdabot>   x
13:35:31 <roconnor> and making suitable Num ... Floating instances
13:35:47 <roconnor> > diff (^2) 5
13:35:48 <lambdabot>   Not in scope: `diff'
13:35:52 <roconnor> > deriv (^2) 5
13:35:53 <lambdabot>   10
13:36:05 <roconnor> the x thing is totally different
13:36:13 <roconnor> the x is part of the simple reflection package
13:36:28 <roconnor> > foldr (+) z [a,b,c]
13:36:29 <lambdabot>   a + (b + (c + z))
13:36:44 <roconnor> > foldr f a [x,y,z]
13:36:45 <lambdabot>   f x (f y (f z a))
13:36:56 <roconnor> :t x
13:36:57 <lambdabot> Expr
13:37:13 <roconnor> Expr is a type of Number that prints like an expression
13:37:20 <roconnor> > sinh x
13:37:21 <lambdabot>   sinh x
13:37:38 <mauke> > sin 10 ^ 3 :: Expr
13:37:39 <lambdabot>   sin 10 * sin 10 * sin 10
13:38:02 <mercury^> Is there a paper on it?
13:38:48 <roconnor> so (+) :: Expr -> Expr -> Expr  is simply defined as foo + bar = AddExpr foo bar
13:38:59 <roconnor> where AddExpr is one of the constructors for Expr
13:39:11 <roconnor> then a suitable show instance is given to render the expressions
13:39:34 <roconnor> Expr and Dif are developed totally independent of each other
13:39:41 <roconnor> but you put them together
13:39:48 <roconnor> > deriv sinh x
13:39:49 <lambdabot>   (1 * exp x - negate 1 * exp (negate x)) * recip 2
13:39:53 <roconnor> and this is what you get
13:40:03 <mercury^> Quite neat.
13:40:42 <roconnor> > deriv sinh 1 :: CReal
13:40:43 <lambdabot>   1.5430806348152437784779056207570616826015
13:41:08 <roconnor> > deriv sinh 1 :: Double
13:41:09 <lambdabot>   1.5430806348152437
13:41:13 <roconnor> > deriv sinh 1 :: Expr
13:41:14 <lambdabot>   (1 * exp 1 - negate 1 * exp (negate 1)) * recip 2
13:41:30 <roconnor> > deriv sinh 1 :: Complex Expr
13:41:31 <lambdabot>       No instance for (RealFloat Expr)
13:41:31 <lambdabot>        arising from a use of `sinh' at...
13:41:35 <ManateeLazyCat> Hi, all, i have function "keymapTest :: [Window] -> E.Event -> WindowListT Bool", and function `onKeyPress` is "onKeyPress :: WidgetClass w => w -> (Event -> IO Bool) -> IO (ConnectId w)", so how to make expression "liftIO $ onKeyPress rootFrame $ \event -> keymapTest winList event" success? I added ">> return False" after "keymapTest winList event", but failed. Any suggestions? Thanks!
13:41:39 <roconnor> ah well
13:42:03 <roconnor> Complex Expr was really pushing it.
13:42:32 <ManateeLazyCat> Now, type is mismatch.
13:42:41 <roconnor> mercury^: there are several blog postings out there on simple reflection and on automatic differentiation in Haskell
13:43:36 <ManateeLazyCat> I try use ">> return False" to fix, but can't work.
13:47:18 <Cale> > 2 * deriv sinh 1 :: CReal
13:47:19 <lambdabot>   3.0861612696304875569558112415141233652031
13:47:26 <Cale> hmm
13:48:43 <roconnor> hmm?
13:49:22 <yitz> > cosh 1 :: CReal
13:49:23 <lambdabot>   1.5430806348152437784779056207570616826015
13:49:50 <yitz> > 2 * cosh 1 :: CReal
13:49:51 <lambdabot>   3.0861612696304875569558112415141233652031
13:50:05 <mauke> kosh :: Vorlon
13:50:10 <mercury^> :t (deriv (+ 3) x)
13:50:11 <lambdabot> Expr
13:50:24 <mercury^> Can you convert those back into functions?
13:50:40 <yitz> :t deriv (+3)
13:50:41 <lambdabot> forall a. (Num a) => a -> a
13:50:57 <ManateeLazyCat> If "expression -> argument" need argument's type is "IO Bool", but argument is "OtherType Bool", so how to make this expression work, "expression -> argument >> return False" can't work.
13:51:10 <ManateeLazyCat> Any tips?
13:51:38 <roconnor> > fromExpr x
13:51:38 <lambdabot>   Not in scope: `fromExpr'
13:51:54 <yitz> ManateeLazyCat: what is OtherType?
13:51:57 <roconnor> > reduce (deriv sinh x)
13:51:58 <lambdabot>   (1 * exp x - (-1) * exp (negate x)) * recip 2
13:52:08 <roconnor> > (deriv sinh x)
13:52:09 <lambdabot>   (1 * exp x - negate 1 * exp (negate x)) * recip 2
13:52:20 <roconnor> > reduce $ reduce (deriv sinh x)
13:52:21 <lambdabot>   (1 * exp x - (-1) * exp (negate x)) * 0.5
13:52:29 <ManateeLazyCat> yitz: "OtherType" is "StateT WindowList IO"
13:52:34 <roconnor> > reduce $ reduce $ reduce (deriv sinh x)
13:52:35 <lambdabot>   (1 * exp x - (-1) * exp (negate x)) * 0.5
13:52:49 <ManateeLazyCat> yitz: Now my `argument` is "StateT WindowList IO Bool"
13:52:57 <ManateeLazyCat> yitz: But need "IO Bool"
13:52:58 <roconnor> > reduction (deriv sinh x)
13:52:59 <lambdabot>   Not in scope: `reduction'
13:53:14 <yitz> ManateeLazyCat: you can get that to plain IO using evalStateT
13:53:30 <yitz> ManateeLazyCat: but you need to tell it what the initial state it
13:53:31 <yitz> is
13:53:43 * ManateeLazyCat pasted "my code" at http://paste2.org/get/196634
13:53:44 <ManateeLazyCat> yitz: See above
13:53:58 <roconnor> mercury^: in principle it is possible to convert back from an Expr, but I don't see a function in the lib
13:54:00 <ManateeLazyCat> yitz: Failed at line `53`
13:54:06 <RayNbow> http://www.reddit.com/r/haskell/comments/8hbgu/an_adaptive_state_monad_40_faster_than_our_best/ <-- will there be an adaptive state monad transformer, dons?
13:54:47 <ManateeLazyCat> yitz: I have do that, but i think must have something wrong.
13:56:00 <Saizan> RayNbow: yup
13:56:25 <ManateeLazyCat> yitz: I don't know how to transform `WindowListT Bool` to `IO Bool`. (`WindowListT` is `StateT WindowList IO`)
13:56:42 <yitz> ManateeLazyCat: where is line 53?
13:56:56 <RayNbow> Saizan: that will be interesting :)
13:57:04 <ManateeLazyCat> yitz: I mean error occur at line 53.
13:57:05 <Twey> ManateeLazyCat: With runState
13:57:09 <Twey> Er, runStateT
13:58:43 <ManateeLazyCat> yitz: GHC report error at 53 line of http://paste2.org/get/196634 ,
14:00:55 <ManateeLazyCat> yitz: If i remove ">> return False" from `53 line`, GHC will report "WindowListT Bool" mismatch "IO Bool", and looks ">> return False" is wrong.
14:02:02 <kaol> has anyone used cabal build system to set rpath for an executable?
14:02:12 <ManateeLazyCat> Now "liftIO $ onKeyPress rootFrame $ \event -> keymapTest winList event >> return False" will got can't match expected type `IO a`, against inferred type `WindowListT Bool'
14:03:53 <ManateeLazyCat> yitz: Have a way to fix?
14:03:55 <ski> ManateeLazyCat> :t keymapTest
14:04:00 <ski> ManateeLazyCat> :t onKeyPress
14:04:00 <Botje> what's the type of onKeyPress ?
14:04:13 <ManateeLazyCat> "onKeyPress :: WidgetClass w => w -> (Event -> IO Bool) -> IO (ConnectId w)"
14:04:19 * ski suspects some kind of "monad tunneling" is needed
14:04:22 <ManateeLazyCat> "keymapTest :: [Window] -> E.Event -> WindowListT Bool"
14:04:27 <ski> right
14:05:00 <ManateeLazyCat> ski: http://paste2.org/get/196634 and failed at `53` line
14:05:17 <ski> yes, i saw the paste
14:06:01 <ski> you need an operation `(IO a -> IO b) -> (StateT s IO a -> StateT s IO b)', i think
14:06:36 <paolino> which is the way to catch IO exception in a MonadTrans t => t IO ?
14:08:36 <ManateeLazyCat> ski: `(IO a -> IO b) -> (StateT s IO a -> StateT s IO b)'?
14:08:37 <paolino> catch looks not polymorphic in the monad
14:08:44 <paolino> :t catch
14:08:45 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
14:08:48 <Saizan> paolino: use the MonadError typeclass
14:08:55 <Saizan> ?type catchError
14:08:56 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
14:08:59 <ski> ManateeLazyCat : wait a moment, i'm trying to define it
14:09:09 <ManateeLazyCat> ski: Thanks
14:09:25 <paolino> ok, thnx
14:10:05 <ski> ManateeLazyCat : the basic problem is that `onKeyPress' only (directly) supports taking an `IO'-action as callback .. you can convert `IO' into `StateT s IO' .. but here the other direction is also needed
14:10:19 <ski> ManateeLazyCat : hence we need to do something special
14:10:58 <ski> hm
14:11:14 <ski> i wonder if the solution i'm coding will work here
14:11:38 <ski> i suppose that depends on how often the callback will be called .. and when
14:11:59 <ManateeLazyCat> ski: So `onKeyPress` just look the *first* `IO`-action, and ignore ">> return False"?
14:13:42 <ManateeLazyCat> ski: callback will respond when i `press key` with `rootFrame`.
14:14:46 <ski> @type let tunnelStateTinIO :: (IO a -> IO b) -> (StateT s IO a -> StateT s IO b); tunnelStateTinIO wrap ma = StateT (\s0 -> do ref <- newRef s0; b <- wrap (do s2 <- readRef ref; (a,s3) <- ma `runStateT` s2; writeRef ref s3; return a); s1 <- readRef ref; return (b,s1)) in tunnelStateTinIO
14:14:47 <lambdabot> Not in scope: `newRef'
14:14:47 <lambdabot> Not in scope: `readRef'
14:14:47 <lambdabot> Not in scope: `writeRef'
14:15:09 <ski> @type let tunnelStateTinIO :: (IO a -> IO b) -> (StateT s IO a -> StateT s IO b); tunnelStateTinIO wrap ma = StateT (\s0 -> do ref <- newIORef s0; b <- wrap (do s2 <- readIORef ref; (a,s3) <- ma `runStateT` s2; writeIORef ref s3; return a); s1 <- readIORef ref; return (b,s1)) in tunnelStateTinIO
14:15:10 <lambdabot> Not in scope: `newIORef'
14:15:10 <lambdabot> Not in scope: `readIORef'
14:15:10 <lambdabot> Not in scope: `writeIORef'
14:15:16 <ski> hrmpf
14:15:34 <tew88> Hmmm. How would I go about partially applying the modular function? Say if I wanted to apply `mod` 2 to a list of integers.
14:15:36 <MyCatVerbs> ski: lambdabot has no access to anything in IO.
14:15:49 <MyCatVerbs> tew88: map (`mod` 2) [1..]
14:16:03 <Zao> > map (flip mod 2) [0..10]
14:16:04 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0]
14:16:16 <Cale> > map (`mod` 2) [1..]
14:16:17 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
14:16:19 <ski> @type let tunnelStateTinIO :: (IO a -> IO b) -> (StateT s IO a -> StateT s IO b); tunnelStateTinIO wrap ma = StateT (\s0 -> do ref <- Data.IORef.newIORef s0; b <- wrap (do s2 <- Data.IORef.readIORef ref; (a,s3) <- ma `runStateT` s2; Data.IORef.writeIORef ref s3; return a); s1 <- Data.IORef.readIORef ref; return (b,s1)) in tunnelStateTinIO
14:16:20 <lambdabot> forall a b s. (IO a -> IO b) -> StateT s IO a -> StateT s IO b
14:16:32 <ski> MyCatVerbs : i know .. i just wanted to check the type
14:16:43 <tew88> Gah, I was trying that and it's throwing up parse errors. I guess it's something else.
14:16:45 <tew88> Cheers =)
14:16:48 <MyCatVerbs> ski: didn't even realise it had the types in scope at all.
14:17:18 <Cale> tew88: make sure they're actually backticks and not apostrophes
14:17:43 <ski> MyCatVerbs : so, whether using this will work depends on exactly what you want `onKeyPress rootFrame $ \event -> keymapTest winList event >> return False' to do
14:17:44 <Cale> But yeah, it could be something else :)
14:18:12 <ski> MyCatVerbs : `keymapTest' depends on an implicit `WindowList' state
14:18:49 <ManateeLazyCat> ski: Yep, i need transfor `WindowList` state to deeply function to handle state.
14:18:49 <ski> MyCatVerbs : *which* instance of that state do you want `keymapTest' to get as input state, whenever it is called in the callback ?
14:19:10 <MyCatVerbs> ski: what? I never actually read what you were typing.
14:19:22 <ManateeLazyCat> MyCatVerbs: Is me.
14:19:25 <ManateeLazyCat> ski: Me?
14:19:28 <ski> MyCatVerbs : sorry, wrong person :)
14:19:29 <ski> yes
14:19:38 <MyCatVerbs> Phew.
14:19:54 <ski> ManateeLazyCat : do you want `keymapTest' to always get the state that exists at the time the callback is registered ?
14:20:07 <ski> or maybe you want it to access some "current" state ?
14:20:17 <ManateeLazyCat> ski: Current state.
14:20:30 <ManateeLazyCat> ski: Wait, i paste my WindowList.hs
14:20:44 * ManateeLazyCat pasted "WindowList.hs" at http://paste2.org/get/196644
14:20:46 <ManateeLazyCat> ski: See above
14:20:57 <ski> since it's just an `IO'-callback, it has no direct way of knowing what the "current" state in the `WindowListT' monad is
14:21:46 <ManateeLazyCat> ski: onKeyPress just respond `rootFrame`, then i use `winList` to get current state of WindowList
14:21:56 <ManateeLazyCat> ski: onKeyPress just entry.
14:22:25 <ManateeLazyCat> ski: Then i use function `windowListGetList` get current monad state of WindowList in `evalStateT`.
14:22:46 <ski> (the solution with `tunnelStateTinIO' would work if `onKeyPress' called the callback directly after setting up some dynamic state, *before* `onKeyPress' returned .. but i think that's not the case here)
14:24:38 <ManateeLazyCat> ski: I try your `tunnelStateT`
14:24:56 <ski> i don't think it will work in your case
14:25:00 <kadaver_> if you created an mp3player and wanted to store playstatistics and playlists. wouldyou use a database or just serialize it somehow?
14:26:18 <ski> (i.e. the types should work out, but the behaviour would be wrong)
14:26:36 <MyCatVerbs> kadaver_: serialize the playlists as .m3u files since that's what every other mp3 player on the planet seems to support.
14:28:06 <MyCatVerbs> kadaver_: for play statistics, whatever. SQLite database maybe, just so you'd be able to run queries on it.
14:28:42 <ski> (ManateeLazyCat : currently looking at `keymapTest',`handleKeyPress' to see where you actually use the `WindowList' state)
14:29:43 <ManateeLazyCat> ski: `134` line
14:30:02 <ski> (the paste doesn't show line numbers)
14:30:22 <ManateeLazyCat> ski: "                --       windowSplitVertically window"
14:30:46 <ManateeLazyCat> ski: function `windowSplitVertically` use monad state of `WindowList`.
14:30:52 <MyCatVerbs> ManateeLazyCat: no instance for Num (a -> (String -> [String]) -> b), required by expression (`134` line) ;)
14:31:08 <MyCatVerbs> Well, lines rather than line, but still.
14:31:17 <ManateeLazyCat> ski: `windowSplitVertically` is "windowSplitVertically :: Window -> WindowListT (Window, Window)"
14:31:24 <ManateeLazyCat> ski: I show my Window.hs
14:31:36 * ManateeLazyCat pasted "Window.hs" at http://paste2.org/get/196657
14:31:37 <ManateeLazyCat> ski: See above
14:32:01 <ski> hm, ok .. (missed that code before since it was in a comment :)
14:32:34 <ManateeLazyCat> ski: Now i comment it, and test type, i will un-comment it if type match pass. :)
14:32:43 <jre2> is there a package for translating haskell records to python dictionaries?
14:33:29 <ski> ManateeLazyCat : ok .. i was for a while thinking the whole of `keymapTest' could be written in `IO' since it didn't appear to actually use `WindowListT'-specific effects ..
14:33:33 <ManateeLazyCat> ski: Now i integrate `callback` and `moand state` to handle `runtime state` with GTK application.
14:34:02 <ski> ManateeLazyCat : so, the problem is the callback will at unknown times want to access the "current" `WindowList' state
14:34:10 <kadaver_> MyCatVerbs: serialize? according to wikipedia it is just a text filewith a specified format
14:34:34 <ManateeLazyCat> ski: Yep.
14:34:44 <ski> ManateeLazyCat : the state that is passed around in `StateT WindowList' doesn't have a "current" state as far as some random `IO'-action is concerned
14:34:51 <ManateeLazyCat> ski: Exactly when i type key with `rootFrame`
14:35:06 <ski> (ManateeLazyCat : since that state is passed around in a "pure" fashion)
14:35:41 <MyCatVerbs> kadaver_: yes. If your playlists are just lists of filenames then an m3u file is one of many possible serialization formats for your playlists.
14:35:42 <ski> ManateeLazyCat : first, you want the callback to access the global state, not just a local state to that callback, right ?
14:35:50 <ManateeLazyCat> ski: I keep many function with `WindowListT`, then i can pass current state through *function-list*.
14:36:54 <ManateeLazyCat> ski: yep, but i don't want use *global state*, even some haskeller tell me *global state* is ugly and unnecessary.
14:37:06 <ManateeLazyCat> ski: I keep *local state* in main function.
14:37:14 <ski> ManateeLazyCat : e.g. are there other parts of the program that might change that state, except for that callback ?
14:38:02 <ski> (i don't mean "global state" as in a top-level variable of `IORef ..' type .. just in the sense of accessible from "all" of your program)
14:38:20 <ski> ManateeLazyCat : sorry, s/change/change or depend on/
14:38:32 <ManateeLazyCat> ski: Then won't change state, but other module need access current state, so i build many function to pass current state.
14:39:02 <ManateeLazyCat> s/then/them
14:39:14 <ski> ok .. what i'm thinking you possibly must do is .. keep the global state in an `IORef' cell instead of passing it around with `StateT'
14:39:37 <ski> (you may pass it around in `StateT' if you wish for local computations .. but your main loops should not do that)
14:39:48 <ManateeLazyCat> ski: IORef is ugly, and i don't want keep a global state.
14:40:10 <ski> i don't see any other way for the callback to communicate the state with the rest of the program
14:40:32 <ski> i'm assuming you have no idea when in the program the callback will actually be called
14:40:56 <Saizan> ReaderT (IORef s) IO seems the best approach here
14:41:07 <ski> so, whatever the current value in an `IORef'-cell is when the callback is invoked by the system, that's the state the callback will see
14:41:36 <ski> yes, you can make things nicer by accessing the `IORef' itself from `ReaderT'
14:41:46 <ski> but it's basically the same thing
14:43:12 <ManateeLazyCat> ski: See the implement of `windowHandleSynchronous` ( I use it in main loop for synchronous windows content) in Window.hs
14:43:27 <ManateeLazyCat> Window.hs at http://paste2.org/get/196657
14:43:38 <ski> (btw, to make things clear .. i don't mean "global state" in the sense that you couldn't have several instances of the main program, each with its own callbacks and `IORef'-cell)
14:44:43 * Baughn notes that javascript would be ever so much nicer with partial application. Why am I writing this again?
14:44:55 <skorpan> Baughn: i agree
14:44:56 <ManateeLazyCat> ski: I keep *local state* in main loop, but it looks like *global state*, because i do many thing in `evalSateT`.
14:45:03 <ski> (btw, you may want to consider the potential issue of race conditions in updating the state, if that's possible from more than one point in a running program)
14:45:30 <skorpan> Baughn: it *almost* has that though, since you don't have to provide all arguments to functions...
14:45:36 <skorpan> Baughn: so in a sense you could hack it :P
14:45:38 <ski> (ManateeLazyCat : we're probably using different definitions of "global" vs. "local" :)
14:45:47 <ManateeLazyCat> ski: I don't know how to write a better version now.
14:46:15 <Baughn> skorpan: Heh. I suppose I could, at that.
14:46:24 <ski> (hint : i used them as relative terms .. "global to foo", "local to bar")
14:46:25 <skorpan> Baughn: javascript is awesome, yes?
14:46:31 <Baughn> skorpan: No.
14:46:41 <skorpan> yes, it is, you're wrong
14:46:43 <Baughn> skorpan: It's just barely good enough. ^_^
14:46:48 * Baughn has high standards
14:47:11 <ski> it might be that there would be a nicer way to do this if the callback system supported that nicer way (i'm not sure what it would be, but i can imagine it might be possible)
14:47:23 <ManateeLazyCat> ski: So simple, my idea is use access state in main loop, and pass to other-module to handle *current* state, and pass entry is use gtk2hs callback.
14:47:58 <ski> but given that you can't change `onKeyPress', you need to communicate the state through state *in* `IO', such as `IORef'
14:48:31 <Baughn> skorpan: Still, it is at least good enough that I'm now writing my first.. software renderer.
14:48:57 <skorpan> Baughn: javascript is actually one of my top-three favorite languages
14:49:27 <Baughn> skorpan: Fourth place, here. Python and CL beat it.
14:49:27 <ManateeLazyCat> ski: Now gtk2hs's callback is not use Haskell style, I think if Haskell have own GUI libraries is better, but now i try to mix Haskell and gtk2hs.
14:49:42 <skorpan> Baughn: and haskell is no. 1?
14:49:54 <ManateeLazyCat> ski: yep, i can't change `onKeyPress`.
14:49:54 <skorpan> Baughn: for me it's python, javascript and haskell, in no particular order
14:50:02 <ManateeLazyCat> ski: That's the problem.
14:50:08 <ski> right
14:50:13 <Baughn> skorpan: But of course. :P
14:50:24 <povman> Good morning everyone!
14:50:33 <ManateeLazyCat> povman: morning.
14:50:41 <ski> povman : night
14:51:07 <Baughn> skorpan: I find myself missing the syntax support for functional programming in both CL and javascript. Python's.. hm, actually I think that's about on par with JS
14:51:08 <ManateeLazyCat> ski: `gtk2hs callback` use different (not Haskell style) to handle problem.
14:51:17 <Baughn> skorpan: But unlike javascript, CL has the MOP
14:51:25 <ManateeLazyCat> s/different/different way/
14:51:57 <ski> ManateeLazyCat : yes, i think you have to bite the bullet
14:52:00 <skorpan> Baughn: what's MOP?
14:52:11 <ski> Meta-Object-Protocol
14:52:39 * ski has only a very vague idea what that's actually about, though
14:52:50 <skorpan> is that some sort of super-reflection?
14:53:04 <ManateeLazyCat> ski: I have try IORef before, but many haskeller tell me that's a bad solution.
14:53:10 <Baughn> Kind of. It's an object system implemented in itself (think metacircularily).
14:53:22 <skorpan> Baughn: and python doesn't have this? (i'm thinking metaclassing)
14:53:32 <p_l> skorpan: Python is nowhere near this
14:53:33 <Baughn> skorpan: It has a pale shadow
14:53:47 <ski> ManateeLazyCat : yes, it's preferrable to avoid it. but given the design of gtk, it may be unavoidable in this situation
14:54:03 <ManateeLazyCat> ski: IORef give you global state, then any module can change it.
14:54:44 <ski> ManateeLazyCat : only any module that is passed the `IORef' in question as an argument
14:54:54 <Baughn> skorpan: As for exactly what I was missing from JS now.. well, this annoys: ' get("/maps/"+map[0], function(r) { showMap_list(divId,r); });'
14:54:59 <ski> (actually s/module/function/ .. but you said the former)
14:55:15 <ManateeLazyCat> ski: Gtk use the C style to handle problem, but hard to do those work in Haskell, sometimes.
14:55:36 <skorpan> Baughn: you mean shorter lambda?
14:56:28 <skorpan> in haskell, that would be kind of 'get ("/maps/" ++ head map) (showMap_list divId)'
14:56:39 <Baughn> Quite
14:56:52 <skorpan> no biggie
14:56:54 <ManateeLazyCat> ski: I think i need write some convertor if i use current solution.
14:56:54 <Baughn> It's no big deal, it's just.. annoying
14:57:00 <skorpan> yeah
14:57:12 <ski> ManateeLazyCat : doing what conversion ?
14:57:18 <skorpan> but javascript 1.8 has the new "lambda" syntax: function (r) showMap_list(divId, r)
14:57:29 <skorpan> that's perfectly valid in 1.8, which is in firefox 3
14:57:40 <ManateeLazyCat> ski: I don't know, but i don't want to use IORef.
14:57:43 <Baughn> skorpan: That said, I think I could easily grow to like JS a lot more, once I've gotten Prelude.hs written. :P
14:57:51 <Baughn> Er, .js
14:58:11 <skorpan> Baughn: there's always jquery ;P
14:58:11 <ManateeLazyCat> ski: I will add multi-thread in the future, so i think IORef will be a problem....
14:58:20 <skorpan> jquery is like a completely new javascript...
14:58:26 <ski> then maybe `MVar', instead of `IORef'
14:59:18 <ManateeLazyCat> ski: Do you mean concurrent?
14:59:35 <ski> or maybe `SampleVar'
14:59:38 <ski> yes
14:59:41 * Baughn recently had occasion to implement MVars in C++. They are.. well, one wonders why they aren't standard, that's what.
14:59:59 <dons> how'd you implement them?
15:00:02 <dons> reuse ghc's rts code?
15:00:11 <Baughn> Ah, no. Nothing that big.
15:00:26 <Baughn> Just the API, by a template class.. parametric polymorphism for the win
15:00:59 <dons> right, but the tricky bit is the synchronization, no?
15:01:20 <Baughn> Right, but at least I only had to write it /once/
15:01:34 <p_l> Baughn: What about Boost libraries?
15:01:43 <Baughn> Of course, five minutes later I spent half an hour figuring out why the compiler was complaining about missing types.. I'd forgotten it doesn't infer them
15:01:52 <ManateeLazyCat> ski: I study Haskell through my project, and i write a *works* version, and keep simple, if test pass, i will add more complex thing... I'm try to evolution my code.
15:02:09 <Baughn> p_l: I can't use them. They're fine if they work, but one tiny miss and you get half a book of error messages, and I'm not that good with C++.
15:02:21 <p_l> hahaha
15:02:35 <p_l> I heard that you always get those kind of sizes with templates :D
15:02:57 <Baughn> Yep, obviously parametric polymorphism absolutely /requires/ giant errors. >_>
15:03:18 <ski> ManateeLazyCat : i see
15:03:22 <p_l> heh. Unfortunately, no debugger support for that ;P
15:03:29 <Baughn> Well, I know it's a bit more than that, but.. seriously, haskell manages to keep the message size down
15:03:52 <ski> i can't give more advice that using `IORef' or one of it's concurrent cousins `MVar',et.c. ..
15:03:54 <sclv_> Baughn: until you start with the hlists that is.
15:04:00 <ski> s/that/than/
15:04:09 <Baughn> sclv_: I'm not planning to do type-level programming anytime soon
15:04:18 <ManateeLazyCat> ski: Thanks for your help.
15:04:23 <sclv_> it'll sneak up on ya.
15:04:27 <ski> (blame gtk !)
15:04:45 <ManateeLazyCat> ski: But i try to find other solution.
15:05:26 <Baughn> Nah. Although, GHC recently told me to turn on rank-n types, so I'm thinking I should learn a /little/ more about that type-checker now
15:06:01 <ski> (rank-n is not type-level programming)
15:06:02 <ManateeLazyCat> ski: Haskell haven't a complete GUI libraries now, so i try to use gtk2hs, even it's not perfect
15:06:15 <Baughn> ski: See? I'm still avoiding it. ^_^
15:07:48 <ManateeLazyCat> ski: If Haskell have complete GUI libraries like GTK, then my life will be more easier.
15:08:05 <dons> ManateeLazyCat: what's incomplete about gtk2hs?
15:08:21 <dons> people are building some pretty impressive systems with it. see e.g. leksah.org
15:09:03 <SamB> dons: well, it probably doesn't bind all GTK widgets in existance
15:09:07 <SamB> and so forth
15:10:44 <yitz> where is there more info about atom? no link from the hackage page.
15:10:50 <Baughn> skorpan: Incidentally, is "eval(xhr.responseText)" a reasonable way to deserialize JSON when I'm serving both the JSON and the script doing this?
15:11:09 <dons> yitz: funhdl.org
15:11:11 <SamB> Baughn: from the same server?
15:11:19 <Baughn> SamB: Same process, even
15:11:24 <SamB> probably
15:11:31 <skorpan> Baughn: it's reasonable, but i wouldn't call it very safe
15:11:45 <Baughn> skorpan: Well, how can it go wrong?
15:12:02 <dons> anyone have thoughts on a DPH version of gmp?
15:12:10 <SamB> if they can MitM you, they could just as well MitM the script as the JSON
15:12:17 <dons> how many gmp math ops can be written in a parallel fashion?
15:12:17 <Lemmih> DPH?
15:12:21 <ManateeLazyCat> dons: gtk2hs can't handle problem with Haskell style, maybe i missing something.
15:12:21 <dons> data parallel arrays
15:12:23 <skorpan> Baughn: i don't know the underlying rationale behind this, but it's generally considered harmful... i don't know. i never deal with fetching javascript through ajax.
15:12:35 <dons> ManateeLazyCat: oh, you mean its not a purely functional gui?
15:12:42 <ManateeLazyCat> dons: Yep
15:12:55 <yitz> dons: not much there either
15:13:06 <dons> yeah, if you want both comprehensive, and purely functional, you're out of luck. but there are purely functional gui libs (look at the reactive guis)
15:13:33 * SamB isn't even sure GTK is comprehensive -- hasn't found a character matrix widget yet :-(
15:13:49 <Lemmih> dons: Aren't the arrays too small to compensate for the overhead?
15:13:54 <dons> Lemmih: i think maybe for very large integers, with ops that are parallelisable, it might be ok.
15:13:59 <dons> big big bums
15:14:01 <dons> nums!
15:14:21 <dons> so not the typical Integer which is barely > Word64
15:14:30 <p_l> Baughn: eval is usable, but not necessarily sane
15:14:51 <yitz> dons: you'd need some new math for parallel mp. know of any work on it?
15:15:16 <dons> yitz: no, that's what i was wondering. surely people have published parallel math algos.
15:15:38 <dons> not my background though, so not sure what the standard refs. are.
15:15:45 <ManateeLazyCat> dons: I hope Haskell will develop a COMPLETE and PURELY functional GUI libraries, now i use gtk2hs, even code is ugly sometimes. At least it's the easiest way to build Haskell GUI program.
15:15:56 <dons> ManateeLazyCat: right. that's a good idea.
15:16:09 <dons> gtk2hs is merely as concise as every other language.
15:17:43 <yitz> dons: i don't know either, but i wouldn't be surprised if it's still pretty rough
15:18:11 <ManateeLazyCat> dons: Now i use gtk2hs develop a dynamic environment, after it complete, i will try to build PURELY functional GUI libraries, then will be perfect....
15:18:14 <dons> maybe very large integers are a bit of a niche.
15:18:21 <dons> unlike say, giant matrices.
15:18:53 <yitz> dons: they used to be a niche, not anymore, but math is still catching up
15:19:16 <yitz> dons: i'll bet nsa knows something about it :)
15:19:21 <dons> heh.
15:22:17 <ManateeLazyCat> ski: Thanks all for help, I will other way to fix my problem. :)
15:22:27 <necroforest> how do you have a purley function gui toolkit
15:23:16 <dons> MVC style.
15:23:27 <dons> you describe the gui, and hand that off to something to render
15:23:34 <dons> rather than directly manipulating the world.
15:24:06 <ManateeLazyCat> dons: But still low-code to render?
15:24:12 <ManateeLazyCat> s/still/still need
15:24:29 <dons> something's got to get into the graphics card, and rewriting the graphics libs is boring and needless.
15:25:15 <thoughtpolice> ManateeLazyCat: you describe things 'declaratively'
15:26:37 <sclv_> or declare things 'describatively'
15:26:38 <yitz> dons: google "parallel integer multiplication" actually turned up stuff
15:26:50 <yitz> dons: algos, conferences, etc.
15:27:08 <dons> mmm
15:27:24 <dons> yes. interesting!
15:27:26 <thoughtpolice> dons: oh, I went ahead and grabbed a copy of harrison's new book. i'm only on ch. 2, but I definitely need to spend more time with it
15:27:57 <sclv_> rah: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.671
15:28:29 <dons> cool
15:28:46 <dons> killer dph app. simple, declarative, efficient large integers?
15:29:15 <ManateeLazyCat> dons: BTW, leksah's not enough powerful, I think i can write a better GUI program use gtk2hs.
15:29:29 <dons> please do!
15:29:36 <ManateeLazyCat> dons: yes
15:29:40 <ManateeLazyCat> dons: I have do it.
15:30:01 <dons> you could write a gtk2hs gui tutorial while you're at it.
15:30:03 <ManateeLazyCat> dons: I think i will release it after some months later.
15:30:47 <ManateeLazyCat> dons: I have success develop synchronous buffer program use gtk2hs.
15:30:49 <sclv_> and something using ~9 instead if zillions of processors: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.7271
15:31:51 <Sentinel19> how do you convert an IO String to a String?
15:32:24 <dons> s <- getLine
15:32:26 <dons> that kind of thing.
15:32:46 <Sentinel19> getPage :: String -> String
15:32:46 <Sentinel19> getPage url = do
15:32:47 <Sentinel19>                 s <- openURL url
15:32:47 <Sentinel19>                 return s
15:32:50 <Sentinel19> that doesn't work
15:33:00 <dons> sclv_: oh, that last one looks good.
15:33:11 <dons> Sentinel19: getPage :: String -> IO String
15:33:18 <lhoersten> dons: whats up! great book
15:34:17 <novatrust> Is the person responsible for learnyouahaskell.com here by any chance?
15:34:35 <thoughtpolice> novatrust: BONUS is around here, yeah
15:34:48 <novatrust> I want to buy that man a beer. That website is pure win.
15:35:02 <dons> BONUS: <--
15:35:09 <dons> lhoersten: hi!
15:35:14 <novatrust> lol
15:35:24 <ManateeLazyCat> Bye all.
15:35:35 <lhoersten> dons: keep posting cool stuff on reddit and twitter. i like getting those random links =)
15:36:18 <dons> hehe
15:36:34 <ski> Sentinel19 : the `return s' converts the `s' back from `String' to `IO String'
15:36:45 <Sentinel19> oh
15:36:48 <kadaver_> i wrote a 400 LOC mp3player in Clojure. I am 100% confident it would be shorter and cleaner written in Haskell. it also wouldn't have this one really annoying bug because of threading.
15:36:55 <Sentinel19> so how do you return just String?
15:37:06 <ski> Sentinel19 : that's how the `IO'-monad works .. if you want to do `IO'-actions in a function, the return type must include `IO' somewhere
15:37:38 <ski> Sentinel19 : you can't .. instead you pass that string to some other pure function
15:37:48 <ski>   do s <- openURL url
15:38:00 <ski>      let result = pureFunction s
15:38:06 <ski>      return result
15:38:08 <ski> e.g.
15:38:13 <Sentinel19> ohh ok
15:38:15 <ski>   pureFunction : String -> Foo
15:38:44 <dons> kadaver_: and probably hella faster too
15:39:06 <dons> so why not write it in haskell?
15:39:42 <dons> lol "hack: a sexy Haskell Webserver Interface"
15:39:46 <yitz> dons: the paper by Jebelean found that straight parallel Katsuba is good for mult, but for div isn't worth it for < 10^4 bits even after some clever tricks
15:40:04 <kadaver_> dons: because I did it as an exercise there are already a million ones out there
15:40:06 <dons> i think to justify DPH we'd want even bigger limits
15:40:22 <dons> yitz: what parts of Num can be done in parallel?
15:40:36 <dons> (*), obviously. xor... (and other Bits things)
15:40:45 <yitz> yeah
15:40:59 <yitz> well, also div, but it's hard
15:41:23 <yitz> probably sqrt and stuff
15:41:25 <roconnor> 4 `div` 2 :: Expr
15:41:29 <roconnor> > 4 `div` 2 :: Expr
15:41:30 <lambdabot>   4 `div` 2
15:41:41 <roconnor> > div 4 2 :: Expr
15:41:42 <lambdabot>   4 `div` 2
15:46:11 <hs2> what does this mean " The last statement in a 'do' construct must be an expression"
15:46:29 <roconnor> hs2: cannot be of the form x <- foo
15:47:03 <hs2> umm not sure if i get you
15:47:35 <roconnor> > do { x <- return 7; y <- return 8 } :: Maybe Int
15:47:36 <lambdabot>   <no location info>:
15:47:36 <lambdabot>      The last statement in a 'do' construct must be an ...
15:47:43 <roconnor> > do { x <- return 7; return 8 } :: Maybe Int
15:47:44 <lambdabot>   Just 8
15:49:30 <novatrust> I would just like to say, the haskell community is probably the coolest group of people I've found online. If the RoR community is on one end of a spectrum, Haskell is on the far opposite.
15:50:54 <dons> heh
15:51:02 <dons> sigh. interwebs.
15:51:19 <Nafai> interwebs rock!
15:51:21 <gnuvince_> dons: what has they done now?
15:51:23 <MyCatVerbs> novatrust: thank you, everybody does their best.
15:51:24 <roconnor> RoR?
15:51:36 <novatrust> *Ruby on Rails
15:51:42 <roconnor> ah
15:51:43 <dons> roconnor is trapped in the interwebs.
15:51:47 <roconnor> I was thinking WoW clone
15:52:03 * roconnor checks out #rails
15:52:17 <roconnor> hmm
15:52:21 <roconnor> must be the wrong channel?
15:53:09 <hs2> so this should return string right? s <- getLine
15:53:10 <hs2>  let str = purefunction s
15:53:10 <hs2>  return str
15:53:33 <roconnor> well, it will return an IO String
15:53:36 <Baughn> hs2: Well, thereabouts. It's a bit verbose, but looks right.
15:53:50 <hs2> it doesnt seem to... :(
15:53:58 <roconnor> could be an indentation issue
15:54:03 <Baughn> "purefunction <$> getLine" does the exact same thing as those three lines. That said.. paste your code on hpaste
15:54:14 <roconnor> or a fundamental misunderstanding of monadic programming
15:54:19 <roconnor> one of the two :)
15:54:32 <hs2> probably both.. let me paste it on hpaste
15:54:42 <novatrust> Ah, here are a few explanations: http://cubiclemuses.com/cm/articles/2009/04/28/a-community-of-rockstars/ http://wooga.drbacchus.com/geek-arrogance-and-chauvinism
15:57:33 <roconnor> I'm not sure if haskell has rockstars.  Just a bunch of folk as various levels of ignorance ... and Oleg.
15:57:33 <hs2> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4504#a4504 thats a link to it
15:57:37 <roconnor> hs2: getData :: String -> IO String
15:57:38 <adamvo> The ((->) r) monad doesn't seem to be used much in practice: does anybody have any opinions about it?
15:57:50 <hs2> roconnor:  thats the think i dont want IO String there
15:57:55 <roconnor> adamvo: it is used a lot in #haskell
15:57:55 <hs2> thing*
15:58:03 <adamvo> roconnor: exactly
15:58:08 <roconnor> hs2: must be there.  Don't worry.  It'll be good
15:58:20 <centrinia> hs2, Put "unsafePerformIO $" before the "do" :p
15:58:26 <roconnor> adamvo: I think it might be used more if it weren't such a pain to import
15:58:38 <roconnor> centrinia: stop that. :)
15:58:41 <Cale> adamvo: It's one of my favourite monads actually
15:58:47 <Cale> adamvo: I use it all the time
15:58:49 <Baughn> centrinia: Stop telling newbies to hit the shiny button. The shiny, red button.. the jolly, candy-like button...
15:59:05 <hs2> what does the red button do/
15:59:12 <p_l> Baughn: Covered in blood?
15:59:14 <Baughn> Nobody knows
15:59:16 <Baughn> It's undefined!
15:59:25 <zerosoul> What is the best RAT soft do you guys think?
15:59:26 <centrinia> It launches missiles unpredictably.
15:59:30 <adamvo> hmm, in the newest base, its hidden away in Control.Monad.Instances
15:59:37 <Baughn> centrinia: Don't be too sure of that
15:59:43 <roconnor> hs2: when you want to use getData :: String -> IO String, #haskell will be here to help teach you to use it.  Basically you will still be able to use it inside do blocks
15:59:45 <Baughn> p_l: That makes.. sense
16:00:07 <Baughn> hs2: You can call pure functions from IO code, but not ever the other way around..
16:00:20 <Cale> hs2: unsafePerformIO takes an IO action and turns it into a magical value whose evaluation causes that IO action to execute. Because the evaluation order of a Haskell program isn't well-defined, this can result in lots of nonsense, and programs whose behaviour changes drastically under optimisations.
16:00:24 <Baughn> hs2: If you don't want an IO tag on the function, you'll have to read your input elsewhere
16:00:54 <Cale> hs2: Basically, you should treat using unsafePerformIO with the same level of seriousness as modifying your compiler. :)
16:00:55 <hs2> Ok that clears things up..
16:01:14 <Cale> (as it lets you cheat all kinds of safeguards)
16:01:58 <Baughn> I was about to protest, but..
16:02:14 * Baughn has the compiler upside down with various tubes hanging loose
16:03:10 <Sentinel19> does it take a lot of seriousness to modify a compiler/
16:03:12 <novatrust> Better not put those tubes in a series.
16:03:38 <Baughn> novatrust: That's just it. I'm trying to build a series of.. tubes, but the tubes keep /leaking/
16:03:54 <novatrust> Same problem Al Gore had?
16:03:56 <adamvo> Cale: agreed, but it doesn't seem to save much LOC, since the implicit argument can be added back with a couple of characters lost
16:03:57 <Baughn> Sentinel19: As you can tell, not very.
16:05:07 <kerlo> hs2: you can't (without Cale yelling at you) turn an IO String into a String, but you can easily turn a function taking a String into a function taking an IO String.
16:05:09 <p_l> Baughn: You should switch to avian UDP
16:05:30 <novatrust> lol
16:05:39 <Baughn> p_l: That works well in metropolitan area networks, but there are too many packet droppings to be useful indoors
16:07:10 <hs2> Ok so can you just move everything that you do with the input in a "do" and return the results instead?
16:08:33 <roconnor> sounds about right
16:08:50 <Sentinel19> return the results instead? didn't you always want to return the results?
16:09:22 <QtPlaty[HireMe]> Is there any way to abstract out patten matches, for example in case?
16:09:43 <hs2> I need to return a list of inputs for example.. but i guess it only will let me return a IO List not just a List
16:09:46 <kadaver_> example?
16:09:53 <adamvo> hs2: sure, but why not put that stuff in a separate pure function (which may be easier to test)?
16:10:56 <QtPlaty[HireMe]> I have a whole lot of functions that are basicly.  Send message to server, get reply from server, check reply to see its an error, parse the rest of the output.
16:11:22 <roconnor> QtPlaty[HireMe]: sounds like a job for a monad
16:11:49 <roconnor> Arguably the Maybe monad abstracts out it's pattern match
16:12:01 <roconnor> for a loose understanding of abstracting a pattern match
16:12:18 <roconnor> it certainly eliminates a series of nested case statements
16:12:26 <QtPlaty[HireMe]> I would like to abstract this out into a function that takes the thing to send, the responce that is expected and the parsing function.
16:22:33 <QtPlaty[HireMe]> It doesn't need to deconstruct the data, so I can just have a function 'foo -> Bool' and have that trip the parser.
16:23:22 <sclv_> in general it sounds like catamorphisms
16:23:34 <QtPlaty[HireMe]> sclv_: How so?
16:24:41 <novatrust> Are unit tests needed/used in haskell?
16:25:15 <sclv_> :t maybe
16:25:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:25:24 <sclv_> :t either
16:25:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:25:43 <Cale> novatrust: Sure, though we also have richer alternatives like QuickCheck
16:26:03 <novatrust> googling QuickCheck now
16:26:05 <QtPlaty[HireMe]> novatrust: I've been working with hUnit and it works well.
16:26:12 <dons> quickcheck is heavily used
16:26:15 <dons> hunit less so
16:26:44 <Cale> novatrust: Unit tests are not needed quite as much as in a dynamically typed language, but if you want to make sure that your program works, testing it is always a good idea :)
16:27:03 <novatrust> Thanks - very interesting
16:27:39 <Cale> There are some nice things about Haskell code which make it easy to test -- one in particular is that functions produce results which only depend on their input parameters.
16:28:04 <novatrust> And, if I understand correctly, that's how all pure functional languages should behave?
16:28:06 <Cale> So there's usually no need to construct elaborate contexts to test the pure bits of your program, at least.
16:28:09 <Cale> yeah
16:29:14 <Cale> And you can be sure that if a function gives the right value when testing it, it'll still give the right value when the actual program runs.
16:29:24 <novatrust> got it
16:29:39 <Sentinel19> > unwords ["aa","index.php?page=2"]
16:29:40 <lambdabot>   "aa index.php?page=2"
16:31:40 <Cale> novatrust: The other thing is that since there's no mutation going on, it's easier to compare the value you started with to the result -- you don't have to make a copy of it to stash somewhere.
16:32:11 <Cale> Again something sort of obvious, but nice to notice.
16:32:50 <novatrust> thanks for pointing that out - I hadn't thought of that
18:48:35 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:48:35 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
18:48:35 --- names: list (clog westbaer chessguy juturnas cognominal smorg jberryman guenni Adamant pjb3 synthase dolio Modius aik_ trie_ kniu sclv Smokey` novas0x2a Time`s_Witness ignotus21 augustss johnnowak saml shingo maxote true\false gcollins pejo younder Salve BrianHV kosmikus frink Asztal hesselink dunz0r kokekola nornagon nipuL Kerris7_ vxr_ skorpan OnionKnight ArneB EvilTerran nominolo marc Cairnarvon sbahra _mu_ Helkafen Sentinel19 hs2 thirsteh MrFahrenheit)
18:48:35 --- names: list (ingy Kisu NEEDMOAR CoryDambach ikkebr ml`_ gnufied povman jre2 PsiOmega gdsx Philonous Apocalisp yitz woggle dv_ mm_freak mahogny s76__ randomity adlan repnop ivan-kanis Rara`Avis MacTavish mattrepl Spockz|lap Debugger Saizan jinjing snhmib erg0t Alpounet bombshelter13_ det X-Scale purplefi1tmixer Plareplane jmillikin lametier defun thingwath igowen moozilla Trafalgard LouisJB cpfr kadaver_ turjo alvarezp roconnor xinming Associat0r yowgi)
18:48:35 --- names: list (dsfox jamii aeolist_ da-x monochrom whoppix Eridius_ _janne byorgey kayess lars_t danopia Draconx juhp_ Berengal zax _dls jan_ guerby ttt-- perspectival int-e Velociraptors seafood hazridi beelsebob BlackM jvoorhis alexsuraci dropdrive cypher- Taggnostr otto_s fnordus dcoutts Sargun_screen thewolt Draconx|Laptop kerm|t tverwaes adamvo Eelis amiri agib DarthArachides ski persica reilly bos intrados ixdz r0bby zakwilson Mortomes lambdabot)
18:48:35 --- names: list (karld welterde jedediah fadec @ChanServ user317 oubiwann tltstc mae kristofer sii dmwit QtPlaty[HireMe] iratsu Japsu sebbe1991 ToRA b4taylor Arnar prekrasni mrd gothos infoe|wk im_maciek Igloo morphir MiniSquish JoelMcCracken ray luite Gabbie scook0 Tsion CodeBlock decklin grul djarvelis haoyu Choko galdor nikanj_ _pizza_ tessier Axman6 t lament ehird JuanDaugherty SamB endojelly dixie raxas McManiaC loupgaroublond BONUS bohanlon omnihil)
18:48:35 --- names: list (kmeyer thetallguy Ornedan adimit megaTherion equanimity Liskni_si olsner jeffersonheard ath authentic boyscared gpolo__ mdmkolbe marmolak elias` Twigathy_ tew88 smtms drwhen eno Medved Jedai Zao thou drhodes dionoea Ferdirand lostman_ ehamberg kerlo stevan majoh kalven sbok Schmidt kennyv opqdonut Anthraxx qebab mfp qwr arjanoosting Debolaz sioraiocht canvon Dessous matthewp Twey sgwizdak Cthulhon djinni BMeph ski_ pragma_ elliottt ski__)
18:48:35 --- names: list (loop pettter thorkilnaur aempirei mikezack1es yottis felixc tero- lunabot dufflebunk andyou thomastc koala_man Deewiant dr4wd3 lstor kpk matthew-_ epokal jlaire cjay deiga Mitar Botje Laney tuukkah jones- Caelum felipe_ nablaa MyCatVerbs pcc1 flori fabjan_ gds fophillips qba duality skaar Aisling Hunner_bb PHO_ poucet ertai thoughtpolice rhelmer mokus Lemmih Elly cnwdup suiside mornfall ggl mattam jimki klugez Vq^ bremner wjt eek iggly mjrosenb)
18:48:35 --- names: list (bran_ issal icee sior|oifig jml Hunner smg saiam dogmaT wli mgs` Nanar hellige Thomas2 mercury^ soeren ziman quarks Bleadof burp_ ibid AnMaster Khisanth mlh_ ispiked tchakkazulu sjanssen MrDomino tvaal malouin koninkje_away cYmen taruti C-Keen miasma kapil michaelcdever inimino faXx segher Counter-Strike kolmodin sebas_ validuser hiredman aheller saccade__ TML nothingmuch filipegarcia hoopy koeien_ ponzao___ mle allbery_b laz0r osfameron)
18:48:35 --- names: list (eyck edwinb desp gnuvince dons Valodim stepnem trez Chile` netcat alexbobp newsham glith andrewsw sad0ur joed zeno Cale earthy shachaf kar-1 pastorn bindreturn Raevel yahooooo araujo ryanakca josh newt0n mstr gwern mauke orbitz dcoutts_ methos keseldude floyd mikm Poeir ned shepheb jfredett_ te ac jrockway dax Tobsan chr1s Workybob jonafan flippo Boney drbean saurik Cosmos95 Philippa_ roadwarrior crem LeoD memento mmmulani oms_ preflex Shurique)
18:48:35 --- names: list (tarbo Sisu mreggen galdor_ juhp idnar yango l-out glguy jnwhiteh elzurk hermitseal liyang qz nh nemik bogner tensh eelco DrSyzygyBE gnuvince_ agentzh clanehin StoneToad__ quicksilver birkenfeld nlogax Badger JaffaCake ttmrichter User6065 jrib sgcummin wolverian nwf Reiver willb erk aapole MarcWeber XGas proq vav levitation[A] electrogeek mikezackles_ u_quark Liempt zbrown SyntaxNinja xcthulhu flux sutats epmf kaol dejones mux mrsolo lanaer)
18:48:35 --- names: list (jlouis p_l zsol jleedev pshc SubStack ksandstr lispy davidL viraptor Jaak_ liesen_ Nafai octaviou1 noj Ralith wagle ik anders^^ bd_ Jiten nrl ido stalker_ mopped daf M| trofi^w polux joga regulate cods gOcOOl Tomas tromp pumpkin gbacon agemo Mr_Awesome dancor Stephan202 atsampson Baughn dqd dfranke Gilly Blub\0 qlife nasloc__ thedward integral)
18:48:37 <MyCatVerbs> juturnas: IIRC, any string of characters that doesn't parse as something else is an operator in Haskell.
18:48:40 <Berengal> If you want to make it an operator it can only consists of operator characters
18:48:51 <MyCatVerbs> juturnas: so yes, you can call the function *?.
18:48:56 <Berengal> I think you can even use something like · as an operator
18:49:12 <MyCatVerbs> Yeah, but users without good unicode support will hate you. ;)
18:49:12 <Berengal> > let (·) = (*) in 4 · 5
18:49:13 <lambdabot>   20
18:49:16 <juturnas> ok cool, thanks
18:49:25 <roconnor> > let (*?) = (*) in 4*? 5
18:49:25 <juturnas> wow thats cool
18:49:26 <lambdabot>   20
18:49:27 <MyCatVerbs> (Plus, Unicode in source files is a GHC extension, not part of H98 AFAIK).
18:49:53 <Berengal> Still, dot-product!
18:50:02 <roconnor> > let (*?) = (+) in 4*? 5
18:50:03 <lambdabot>   9
18:50:08 <MyCatVerbs> (Or at least H98 has nothing at all to say on the matter, and hence a H98 compiler might assume 7-bit ASCII)
18:50:12 <skorpan> let (··) = (..) in [4··10]
18:50:18 <skorpan> > let (··) = (..) in [4··10]
18:50:19 <lambdabot>   <no location info>: parse error on input `..'
18:50:33 <Berengal> .. is syntax, not an operator
18:50:39 <wli> No EBCDIC?
18:50:44 <skorpan> yeah, i know...
18:50:45 <MyCatVerbs> juturnas: also, rather than writing your own numerical stuff with vectors and matrices, I would recommend checking out hmatrix. It's an interface to libgsl and LAPACK and all that jazz.
18:50:49 <Berengal> > let (··) = enumFromTo in 4 ·· 10
18:50:50 <lambdabot>   [4,5,6,7,8,9,10]
18:51:06 <p_l> wli: and where's SIXBIT?
18:51:56 <juturnas> MyCatVerbs: Thanks, I'm all about code re-use.. checking it out now
18:52:11 <skorpan> > let (↑) = ((**) . (**)) in 4↑4
18:52:12 <lambdabot>       No instance for (Floating (a -> a))
18:52:12 <lambdabot>        arising from a use of `**' a...
18:52:17 <skorpan> > let (↑) = (**) in 4↑4
18:52:19 <lambdabot>   256.0
18:52:38 <skorpan> > let (↑) = \x -> ((x (**))**) in 4↑4
18:52:39 <lambdabot>       No instance for (Num ((a -> a -> a) -> a1))
18:52:39 <lambdabot>        arising from the lit...
18:52:44 <skorpan> hmm...
18:53:18 <adamvo> http://www.haskell.org/onlinereport/lexemes.html
18:53:21 <skorpan> > let (↑) = \x y -> ((x (**)) ** y) in 4↑4
18:53:22 <lambdabot>       No instance for (Num ((a -> a -> a) -> a1))
18:53:22 <lambdabot>        arising from the lit...
18:53:31 <adamvo> says H98 should have unicode source
18:53:43 <skorpan> > let (↑) = \x y -> (x ** x ** y) in 4↑4
18:53:45 <lambdabot>   1.3407807929942598e154
18:53:59 <skorpan> @pl \x y -> (x ** x ** y)
18:53:59 <lambdabot> liftM2 (.) (**) (**)
18:54:20 <wli> LAPACK can do arithmetic over Q(2^(1/3),x,(x^2+1)^(1/2))?
18:55:06 <adamvo> MyCatVerbs: H98 seems to require unicode actually
18:55:32 <MyCatVerbs> wli: I'm not even sure what you mean by that (arithmetic on polynomials or something?) but AFAIK no, it's just a big old bag of numerical solving routines. Matrix inversion, that kind of thing.
18:56:00 <wli> I know.
18:56:35 <wli> It doesn't help when you need arbitrary-precision rationals, algebraic number fields, function fields, etc.
18:57:34 <Berengal> Man, GUI programming is all upside-down and inconsistent
18:59:17 <kadaver_> berengal: need help?
18:59:21 <kadaver_> using gtk2hs?
19:00:11 <juturnas> Oh has anyone used the latest wxHaskell windows binary with ghc 6.10.2?  I can run an app but as soon as I mouse over it it crashes... I don't have enough know-how to file a bug report or anything yet tho
19:00:31 <Berengal> kadaver_: Yeah, using gtk2hs
19:01:27 <Berengal> Currently I've got http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4506#a4506
19:01:56 <Berengal> But when I run the dialog, it doesn't get any decorations, and I have to kill it...
19:04:20 <gwern> yeesh
19:04:24 <gwern> writing gitit plugins is not fun
19:04:48 <gwern> 2 hours for this dinky little thing
19:05:22 <gwern> how hard could it be to parse a page for URLs and send some HTTP archive requests? surprisingly hard given all the details and type stuff in gitit/happstack
19:06:06 <kadaver_> meh i cant run that sorry
19:07:04 <roconnor> oh
19:07:10 <roconnor> parse a page for URLs
19:07:14 <kadaver_> dont you ahve to put them in a box?
19:07:21 <roconnor> that sounds really annoying
19:07:38 <gwern> roconnor: even more annoying would be losing an external link to bit rot forever
19:07:39 <kadaver_> Berengal: dont you have to put the buttons in a box? I'm not sure.
19:07:45 <Berengal> kadaver_: I'm using Glade
19:08:07 <kadaver_> oh so it uses xml for layout?
19:08:08 <Berengal> kadaver_: It's what all the xmlGetWidget stuff is about
19:08:18 <kadaver_> havent done that, sorry for wasting youe time
19:08:38 <Berengal> kadaver_: The FileChooserDialog is its own dialog though
19:08:58 <Berengal> If you know how to create a "save as..." dialog properly, do tell :)
19:10:05 <hs2> @hoogle String -> Int
19:10:05 <lambdabot> Prelude read :: Read a => String -> a
19:10:05 <lambdabot> Text.Read read :: Read a => String -> a
19:10:05 <lambdabot> Prelude error :: String -> a
19:10:58 <hs2> @hoogle Char -> Int
19:10:58 <lambdabot> Data.Char digitToInt :: Char -> Int
19:10:58 <lambdabot> Data.Char ord :: Char -> Int
19:10:58 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
19:11:55 <Berengal> Well hooray, I got it to paint properly somehow.
19:13:07 <gwern> yay, my plugin is working!
19:13:14 * gwern sees the webcite ack emails coming in
19:16:02 <kadaver_> how hard is it to write an mp3 decoder if you dont know any uni level math( i know basic linalg), can program Haskell,Python and C well, know datastructures and algorithms(like an uni level undergraduate course)
19:18:17 <p_l> kadaver_: I don't think it would be hard, but don't expect great performance then
19:18:42 <p_l> till you learn various tricks, at least (It's not my scope, though)
19:19:29 <Berengal> You'll probably pick up some of that uni-level math on the way though
19:22:29 <gwern> is this redundant?
19:22:30 <gwern> archive [] = return ()
19:22:33 <gwern> archive a = when (isURI a) (liftIO $ archiveURL a)
19:23:06 <gwern> as far as I can tell, when does 'return ()' if the test fails right?
19:23:08 <gwern> @src when
19:23:08 <lambdabot> when p s = if p then s else return ()
19:23:39 <Saizan> you could tell that from the type
19:24:04 <gwern> @pl \a -> archivepage a >> return a
19:24:04 <lambdabot> liftM2 (>>) archivepage return
19:24:41 <gwern> so my plugin is about 8 lines of code... which I spent about 3 hours writing
19:25:07 <gwern> with haskell, I've learned as the time you invest in writing code approaches infinity, your LoC converges on 0
19:25:10 <Berengal> gwern: Right now I'm at 31 lines an 8 hours
19:25:23 <Zao> gwern: That 8 looked like an 0 in this font.
19:25:28 <Zao> Exceptionally coded in that case :)
19:25:36 <Saizan> paste the code!
19:25:39 <gwern> Zao: maybe he rounds down
19:25:46 <gwern> Saizan: what, my plugin code?
19:25:54 <Saizan> yeah
19:26:25 <gwern> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4507
19:27:56 <adamvo> heh, at least it takes only a couple of minutes to understand
19:29:15 <gwern> sure, because I've refactored the heck out of it, and you're glossing over the tedious details of the monad transformers here and the gitit plugin system, and the whole Pandoc type hierarchy
19:29:18 <Saizan> maybe you should check that the archive request succeeded (unless simpleHTTP already does that, but i'd be surprised)
19:30:02 <gwern> Saizan: webcite tells yo by default whether it succeeded in its email; it's possible to ask it for (XML) feedback immediately, but what would I do with it?
19:30:31 <adamvo> @hoogle processWithM
19:30:31 <lambdabot> No results found
19:30:40 <Berengal> Parse and check if it worked?
19:30:41 <gwern> all the plugin can do is rewrite the article text; I don't think it'd be a good thing to drop in little turds like '<!-- archive of immediately preceding link failed -->'
19:31:09 <gwern> adamvo: it's a pandoc function. it takes the AST that is a parsed pandoc doc, and is basically mapM
19:31:14 <gwern> I think
19:31:48 <gwern> so you see my code goes 'map function' on the document, and 'function' pattern matches only on external links
19:33:12 <adamvo> isn't the archivepage a >> return a redundant
19:33:25 <adamvo> since archivepage returns its argument anyways
19:33:55 <gwern> oh, you're right I think
19:34:42 <gwern> yeah, checks
19:36:46 <adamvo> gwern: and is it possible to leave the _p' out? I'm not so sure that binding to an unused variable is going to force evaluation...
19:37:08 <gwern> if it doesn't, there's something wrong - <- is supposed to force IO actions so far as I know
19:38:24 <adamvo> hmm, is your case much different from the forcing of such:  main = do { putStr "foo"; putStr "bar" }
19:38:47 <gwern> ?
19:39:46 <adamvo> gwern: I guess the difference is that putStr is strict
19:40:03 <Saizan> that _p' doesn't change anything semantically
19:40:06 <adamvo> > undefined >> putStr "hello"
19:40:07 <lambdabot>   * Exception: "<IO ()>"
19:40:28 <gwern> Saizan: right, it's there for -Wall
19:40:44 <Saizan> i mean, having a "foo <-" or not
19:40:47 <Saizan> not the name.
19:41:13 <Saizan> <- doesn't add any extra forcing
19:41:45 <Berengal> Seriously, do GUIs default to "broken"?
19:42:12 <Saizan> also, i can't tell what extra forcing you need there
19:44:19 <adamvo> > return undefined >> putStr "hello"
19:44:20 <lambdabot>   * Exception: "<IO ()>"
19:44:40 <Saizan> > return undefined >> putStr "hello" `seq` ()
19:44:41 <lambdabot>   ()
19:44:45 <Saizan> > undefined >> putStr "hello" `seq` ()
19:44:46 <lambdabot>   ()
19:45:05 <Saizan> > do x <- return undefined; putStr "hello" `seq` ()
19:45:06 <lambdabot>   Couldn't match expected type `t1 t' against inferred type `()'
19:45:18 <Saizan> > (do x <- return undefined; putStr "hello") `seq` ()
19:45:19 <lambdabot>   ()
19:45:42 <Saizan> not that this tells much about what happens when you execute IO actions
19:45:49 <Saizan> but we can't do that on lambdabot
19:47:20 <adamvo> lambdabot doesn't really execute IO, right?
19:47:21 <Saizan> however foo >>= \_ -> bar == foo >> bar by definition
19:47:33 <Saizan> right
19:48:45 <lispy> Zao: Never tried it, but the threads on -cafe made it sound quite usable
19:48:48 <lispy> oops
19:48:54 <adamvo> > writeFile "foo" "bar"
19:48:55 <lambdabot>   * Exception: "<IO ()>"
19:48:58 <Cale> I wonder why it gives an exception like that. I should probably figure that out. It should either give an error that there's no show instance, or it should display like IO ()
19:49:09 <lispy> Zao: sorry, I didn't mean to repeat that just now :)
19:49:51 <gwern> Cale: the show instance throws an error
19:50:01 <Cale> why not just produce the string?
19:50:26 * gwern was feeling superstitious that day and felt like calling error
19:50:39 <Cale> Where is the instance located?
19:51:01 <gwern> the show package, or whatever it's called
19:51:33 <Zao> lispy: Stuck in a time loop? :)
19:52:31 <lispy> Zao: hehe.  Nah, I just pressed up and hit enter without realizing that I was actually connected to IRC (usually my connection times out by now and doing what I did would reconnect me)
19:52:45 <Cale> > [print 15]
19:52:46 <lambdabot>   [<IO ()>]
19:52:50 <Cale> okay, fixed
20:19:07 <korpios> I'm having a problem installing the AppleScript package using cabal under OS X ... I get the error: /usr/lib/gcc/i686-apple-darwin9/4.0.1/include/xmmintrin.h:35:3: error: #error "SSE instruction set not enabled"  Google isn't yielding any fruit so far :/
20:20:50 <p_l> korpios: what cpu?
20:21:01 <korpios> p_l: Intel C2D
20:21:35 <p_l> I don't remember now where, but check what arguments are passed to gcc for whatever is getting compiled at that point
20:22:01 <korpios> yeah, I've been kicking up the verbosity on the compile to try to get a clue
20:23:12 <korpios> that particular header file seems to have a macro set up to error out if SSE isn't enabled ... but this proc has SSE so it makes sense that something's off in the flags
20:24:04 <p_l> btw... which OS X version? Cause I heard there was one that got 64bit userland outside of CLI...
20:24:46 <korpios> 10.5.6
20:25:14 <korpios> there are actually two sets of libs sitting in /usr/lib/gcc/i686-apple-darwin9
20:25:16 * p_l wonders if 64bit compiling would work...
20:25:31 <korpios> 4.0.1 and 4.2.1
20:25:58 <p_l> what about /usr/lib/gcc? is there another arch?
20:26:19 <korpios> powerpc-apple-darwin9
20:26:24 <korpios> is also sitting in there
20:26:29 * edwardk waves hello.
20:26:55 <korpios> but the compile seems to be looking at the right arch
20:26:59 <p_l> so no 64bits...
20:27:19 <p_l> weird. But I'm Apple-free guy, so I doubt I can help more...
20:27:35 <korpios> for all I know, installing the iPhone SDK screwed stuff up by putting GCC 4.2.1 side by side with 4.0.1
20:28:04 <korpios> p_l: np, I'll try to toy with the flags, thanks for the nudge ^_^
20:40:03 <hs2> anyone know how to do forkIO with system?
20:40:18 <hs2> forkIO $ system "ls"
20:41:37 <roconnor> @type system
20:41:38 <lambdabot> Not in scope: `system'
20:41:44 <roconnor> @hoogle system
20:41:44 <lambdabot> System.Cmd system :: String -> IO ExitCode
20:41:44 <lambdabot> module Distribution.System
20:41:44 <lambdabot> package system-inotify
20:43:20 <hs2> basically i get this
20:43:22 <hs2>     Couldn't match expected type `()' against inferred type `ExitCode'
20:43:23 <hs2>       Expected type: IO ()
20:43:23 <hs2>       Inferred type: IO ExitCode
20:43:32 <roconnor> ah
20:43:54 <roconnor> forkIO (system "ls" >> return ())
20:44:00 <hs2> I know why I get it.. but i cant figure out ...
20:44:01 <hs2> that
20:44:06 <hs2> urgh i was close
20:44:14 <roconnor> forkIO (fmap (const ()) system "ls")
20:44:15 <hs2> thanks!!!
20:44:29 <hs2> what would fmap (const()) do?
20:44:46 <roconnor> @type fmap (const ())
20:44:47 <hs2> > :i fmap
20:44:48 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
20:44:48 <lambdabot>   <no location info>: parse error on input `:'
20:45:20 <roconnor> fmap (const ()) turns a f a into a f () for any functor f
20:45:22 <hs2> calls system but eats its return value and sends back () instead?
20:45:51 <roconnor> >> return () is probably more common
20:45:58 <roconnor> but fmap (const ()) is more general :P
20:46:32 <roconnor> @hoogle f a -> f ()
20:46:32 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
20:46:32 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:46:32 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
20:47:46 <dons> Numeric.Units.Dimensional.Prelude> ((25 *~ foot) * (3 *~ metre)) :: Area Double
20:47:47 <dons> 22.860000000000007 m^2
20:47:52 <dons> dimensional++
20:48:22 <roconnor> compile time checking?
20:48:33 <roconnor> looks that way I guess
20:48:50 <Nafai> dons: Nice! That's something I've always wanted
20:49:00 <roconnor> do they have kelvin meter squared per second?
20:49:01 <Nafai> Does it have built in conversions between compatible units?
20:49:15 <adamvo> the errors aren't that pretty when you mess things with Dimensional however
20:49:39 <adamvo> but at least its done at compile-time
20:50:04 <dons> the errors are tricky, yeah.
20:50:25 <dons> $ grep -i kelvin *
20:50:25 <dons> QuantitiesTest.hs:y9 = 1 *~ (joule / kelvin)
20:52:15 <dons> i think it would be good if the .lhs used haddock
20:52:20 <dons> then the hackage page for dimensional would have info.
20:54:07 <adamvo> I find that writing type signatures helps immensely with the type errors you get with Dimensional
20:55:15 <hs2> roconnor:  when i do forkIO (fmap (const ()) system "ls") I get
20:55:16 <hs2>     Couldn't match expected type `IO ()' against inferred type `()'
20:55:16 <hs2>     In the first argument of `fmap', namely `(const ())'
20:55:16 <hs2>     In the first argument of `forkIO', namely
20:55:16 <hs2>         `(fmap (const ()) system "ls")'
20:55:39 <roconnor> my bad: forkIO (fmap (const ()) (system "ls"))
20:55:42 <dons> adamvo: yeah, i had to do that immediately to make sense.
20:57:00 <adamvo> forkIO (fmap (const ()) $ system "ls") -- or that
20:57:14 <hs2> ah
20:57:27 <roconnor> forkIO $ fmap (const ()) $ system "ls  -- or this
20:57:42 <hs2> forkIO (system "ls" >> return ()) for some reason this didnt work before.. i must have done something wrong with the  ()
20:58:02 <roconnor> forkIO . fmap (const ()) $ system "ls  -- or this
20:58:09 <hs2> cool thanks guys!
20:58:12 <adamvo> forkIO $ const () `fmap` system "ls" -- or the other
20:58:48 <hs2> ah i know why it didnt work  forkIO (system "ls " ++someoption >> return ())     ("ls" ++ someoption)
20:59:02 <hs2> forgot the () around someoption ++ "ls" thing
20:59:05 <hs2> lol
21:12:28 <kadaver_> how o you run HPong?
21:18:09 <Ricky_RocK> www.topfreesexvideo.com for free sex video and my other site www.criminal-lawyersite.com for criminal people
21:18:23 <kadaver_> who is behind the haskell platform?
21:19:25 <edwardk> kadaver_: the illuminati
21:19:44 <roconnor> kadaver_: simon
21:19:49 <roconnor> er
21:19:52 <roconnor> nevermind me
21:20:01 <kadaver_> i thought perhaps dons
21:20:07 --- mode: ChanServ set +o dons
21:20:14 <Saizan> roconnor: now you've uncovered his membership
21:20:16 --- mode: ChanServ set -o dons
21:20:24 <dons> heh
21:20:37 <kadaver_> does SPJ somehow feel haskell is, while not(never) finished, but finally ready for mainstream use?
21:20:37 <dons> it's interesting that 'types' are indicated with *~ in dimensionnal
21:20:50 <dons> you'd have to ask him.
21:21:09 <dons> people are happily using haskell for mainstream things, so its kind of a moot point
21:22:08 <dons> i wonder if we could actually say, e.g. (3 :: Feet) * (25 * Metres) instead of switcing to the value level
21:23:14 <Saizan> not with Num's *
21:23:32 <idnar> dons: 25 * Metres or 25 :: Metres?
21:28:16 <edwardk> should that be 75 Feet Meters or 75 meters in feet?
21:28:49 <edwardk> i presume the latter?
21:30:46 <edwardk> and wouldn't that be better then as (3 :: Feet) * (25 * meters) -- so meters :: Feet -- is the conversion ratio between them
21:31:07 <edwardk> and can be expressed using a class overload or some such
21:31:20 <kadaver_> anyoen know what you should pass to gcc when compiling gtk in C?
21:31:35 <Saizan> well, you want to document that 25 is Meters in its type
21:31:50 <Saizan> in addition to automate the conversions
21:32:32 <p_l> kadaver_: what are you compiling? GTK itself, or C code that calls gtk?
21:33:14 <edwardk> well, to me 25 is a number, 25 * meters is a unit of measurement. then (3 :: Feet) -- if you want the automatic ratio stuff should be ill typed or something uless there is a (3 * feet :: Feet) -- but i think thats hopeless
21:33:23 <edwardk> because the types don't look like they can work out
21:35:00 <edwardk> all this because people don't like saying meters 4 + feet 3
21:36:16 <Saizan> uhm, right, if i were to use types for physics i'd have Time vs. Space vs. Velocity not Meters vs. Feets
21:36:31 <roconnor> (4 `meters`) + (3 `feet`)
21:36:41 <haskellnoob> How do I apply a function to every pair of consecutive elements in a list? If the list is [1, 5, 7, 3] and the function is f, I would like to obtain [ f 1 5, f 5 7, f 7 3 ].
21:37:04 <roconnor> @quote aztec
21:37:04 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
21:37:19 <Saizan> > zip`ap`tail $ [1..]
21:37:20 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
21:37:22 <roconnor> zipWith f `ap` tail $ [1,5,7,3]
21:37:26 <roconnor> > zipWith f `ap` tail $ [1,5,7,3]
21:37:28 <lambdabot>   Add a type signature
21:37:28 <edwardk> saizan: exactly, though i'm even ok with the types also including the default yardstick just for practical how do i store it purposes
21:37:37 <roconnor> > zipWith f `ap` tail $ [1,5,7,3] :: [Expr]
21:37:39 <lambdabot>   [f 1 5,f 5 7,f 7 3]
21:38:45 <roconnor> I guess that needs the ((->)r) monad ?
21:39:19 <Berengal> I believe so
21:39:24 <Berengal> Or you could use <*>
21:39:32 <roconnor> > zipWith f <*> tail $ [1,5,7,3] :: [Expr]
21:39:34 <lambdabot>   [f 1 5,f 5 7,f 7 3]
21:40:05 <haskellnoob> where is this "ap" function defined?
21:40:09 <Berengal> ap = <*>, except ap needs monads
21:40:12 <haskellnoob> Is it part of the prelude?
21:40:20 <Berengal> Control.Monad, no?
21:40:25 * Berengal checks
21:40:43 <Saizan> however that can be rewritten as:
21:40:55 <roconnor> haskellnoob: The instance is in one of the Control.Monad.Somewhere
21:41:00 <Berengal> ?index ap
21:41:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
21:41:01 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
21:41:05 <Berengal> Right...
21:41:17 <Saizan> > (\xs -> zipWith f xs (tail xs)) [1,5,7,3]
21:41:18 <lambdabot>   Add a type signature
21:41:31 <Saizan> > (\xs -> zipWith f xs (tail xs)) [1,5,7,3] :: [Expr]
21:41:32 <lambdabot>   [f 1 5,f 5 7,f 7 3]
21:41:33 <edwardk> > (zipWith (,) <*> tail) . (zipWith (,) <*> tail) $ [1,2,3,4]
21:41:34 <lambdabot>   [((1,2),(2,3)),((2,3),(3,4))]
21:41:45 <roconnor> @unpl  zipWith f `ap` tail
21:41:45 <lambdabot> ((zipWith f) >>= \ b -> tail >>= \ a -> return (b a))
21:41:49 <roconnor> ugh
21:41:50 <Saizan> which is how i'd write it in a source file, probably
21:42:55 <haskellnoob> roconnor, Berengal : I am still quite innocent of monads, so this looks scary (because i don't understand it)! also, where can i find out more about <*> ? I can't recognize what that is.
21:43:15 <Saizan> <*> is from Control.Applicative
21:43:18 <roconnor> for <*> you can read http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
21:43:30 <Saizan> however you don't need them here
21:43:34 <haskellnoob> Saizan: Thanks, your definition makes sense.
21:43:43 <haskellnoob> (to me, that is!)
21:44:00 <Saizan> heh
21:44:06 <Berengal> Applicative functors are fun
21:44:10 <Saizan> have you ever seen the SKI combinators?
21:44:10 <Berengal> Especially functions
21:44:13 <roconnor> It's all aztec to me!
21:44:34 <edwardk> roconnor: heh made it to the point where greek isn't so bad?
21:44:37 <Saizan> ap = <*> = S in the usages above
21:44:39 <haskellnoob> Saizan: You asking me? I haven't even heard about either SKI or combinators
21:45:13 <Berengal> s a b x = a x (b x)
21:45:43 <Saizan> so yeah, ap f g x = f x (g x) in the usages above
21:46:25 <Berengal> so ap zip tail -> \x -> zip x (tail x)
21:48:06 <roconnor> edwardk: @quote aztec
21:48:12 <Saizan> have you ever thought about a repl for CT ? something where you type equations and get pretty diagrams and minimal type-checking
21:48:47 <edwardk> @quote aztec
21:48:47 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
21:48:58 <maurer2> What's the use difference between STMVar s and MVar s?
21:49:01 <edwardk> ahh
21:49:06 <haskellnoob> In Saizan's definition above, will using tail result in a copy of the whole original list (except for the first element) being constructed? If my original list had 1 GB worth of elements, will this code end up using nearly 2 GB of memory since it copies over nearly all of the input list?
21:49:17 <edwardk> now i just need combinators for quet`zal`coatl
21:49:18 <Berengal> haskellnoob: No
21:50:14 <roconnor> haskellnoob: check it out
21:50:15 <Berengal> haskellnoob: Since values in Haskell never change, it's safe to share them
21:50:18 <haskellnoob> Or is "tail" only "figurative", in that since ghc knows that the input list won't be modified, it just creates a new pointer to the existing list's second element (or some such)
21:50:21 <Saizan> haskellnoob: no, the tail is shared
21:50:24 <Saizan> ?src tail
21:50:24 <lambdabot> tail (_:xs) = xs
21:50:24 <lambdabot> tail []     = undefined
21:50:26 <roconnor> > (\xs -> zip xs (tail xs)) [1..]
21:50:27 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
21:50:31 <roconnor> no overflow
21:50:36 <roconnor> and it is an infinite list!
21:51:06 <Berengal> The smallest non-empty list you can get is "repeat foo" for any foo
21:51:12 <haskellnoob> thanks.
21:51:17 <Saizan> haskellnoob: yeah, it's more like that, [a] is a linked list, and tail just returns the next-node pointer
21:51:28 <roconnor> Berengal: smallest infinite?
21:51:36 <Berengal> roconnor: Smallest memory footprint
21:51:42 <Berengal> It doesn't need nil
21:51:52 <roconnor> ah
21:51:57 * wli notes Quetzalcoatl had an interesting tail.
21:52:14 <edwardk> haskellnoob: 'figurative'
21:52:55 <Saizan> (does tail imply mutation in english?)
21:53:26 <edwardk> haskellnoob: any time you say let foo = bar in (foo * foo) -- each of those foo's is the same foo, and in fact is bar -- they all reference the same thunk -- "its turtles all the way down"
21:53:44 <edwardk> Saizan: not really, just in the semantics he had in is head
21:54:12 <Berengal> Hehe, turtles all the way down...
21:54:55 <haskellnoob> edwardk: old thought patterns die hard...
21:55:45 <haskellnoob> will take some more time before i quit worrying about copies being made  :)
21:56:38 <Saizan> for contrast, init makes new nodes
21:57:15 <Saizan> ?src init
21:57:15 <lambdabot> init [x]    = []
21:57:15 <lambdabot> init (x:xs) = x : init xs
21:57:15 <lambdabot> init []     = undefined
21:58:07 <Berengal> haskellnoob: Take a look at vacuum, it can show you what your datastructures look like, and even give you nice graphs
21:58:19 <haskellnoob> Berengal: where do i find vacuum?
21:58:38 <Berengal> haskellnoob: cabal
21:58:43 <haskellnoob> thanks.
21:58:48 <Saizan> ?hackage vacuum-cairo
21:58:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-cairo
21:59:04 <Berengal> To get the graphs you want cairo, which requires some other non-haskell libs
21:59:58 <haskellnoob> Berengal: I use Ubuntu, so installing stuff is usually a no-brainer. Thanks.
22:01:13 <mmorrow> , vacuum [(0,1),(1,2)]
22:01:15 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[5,6]),(3,[]),(4,[]),(5,[7,8]),(6,[]),(7,[]),(8,[])]
22:01:23 <mmorrow> , vacuum ((zip`ap`tail) [0..2])
22:01:25 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[5,6]),(3,[]),(4,[]),(5,[4,7]),(6,[]),(7,[])]
22:01:44 <mmorrow> , (zip`ap`tail) [0..2]
22:01:45 <lunabot>  [(0,1),(1,2)]
22:02:06 <Saizan> > let xs = [1..2] in (xs,tail xs)
22:02:07 <lambdabot>   ([1,2],[2])
22:02:14 <Saizan> , let xs = [1..2] in vacuum (xs,tail xs)
22:02:16 <lunabot>  [(0,[1,2]),(1,[3,2]),(2,[4,5]),(3,[]),(4,[]),(5,[])]
22:02:26 <korpios> p_l: to follow-up, I finally got it working by passing --ghc-option='-optc-march=nocona' to cabal
22:02:28 <Peaker-laptop> @type vacuum
22:02:29 <lambdabot> Not in scope: `vacuum'
22:02:36 <mmorrow> , [$ty| vacuum |]
22:02:38 <lunabot>  forall a . a -> [] ((Int, [] Int))
22:02:52 <Peaker-laptop> Why are types formatted like that?
22:03:02 <mmorrow> (this vacuum is (toAdjList . vacuum) from the vacuum pkg)
22:03:20 <mmorrow> Peaker-laptop: TH Ppr weirdness
22:03:47 <mmorrow> , ppDoc (AppT ListT (ConT ''Int))
22:03:49 <lunabot>  [Int]
22:03:55 <mmorrow> , ppDoc (AppT (ConT ''[]) (ConT ''Int))
22:03:57 <lunabot>  [] Int
22:04:46 <mmorrow> so if you went through and made all the ConT ''[]'s into ListT it'd fix it
22:04:51 * mmorrow should do that
22:11:24 <p_l> korpios: Oh, so you made your C2 into Pentium 4? :D
22:12:41 <kadaver_> > 2^32
22:12:42 <lambdabot>   4294967296
22:12:55 <mmorrow> > maxBound :: Int
22:12:56 <lambdabot>   9223372036854775807
22:13:31 <mmorrow> , maxBound :: Int
22:13:33 <lunabot>  2147483647
22:14:02 <p_l> korpios: correct would be march=core2 (assuming your GCC is new enough) or march=native
22:14:52 <kadaver_> anyone ca explain to the dumbo kadaver how to run HPong?
22:14:56 <kadaver_> i cabaled it
22:15:09 <kadaver_> but there is no info on how to import and/or compiel and run it
22:15:21 <azathoth99> hi all
22:15:24 <azathoth99> whats crackin
22:15:30 <Berengal> kadaver_: Just run hpong
22:15:38 <Berengal> Oh, right, you're on windows, right?
22:15:48 <kadaver_> yes
22:15:57 <Berengal> There should be an .exe somewhere
22:20:40 <kadaver_> cool
22:21:18 <azathoth99> well gents
22:21:23 <azathoth99> hows the haskelling
22:21:34 <azathoth99> I heard darcs had soem kind of scaling problem
22:21:45 <azathoth99> and mercurial and git are the new kids on the block
22:21:58 <azathoth99> is the lastest darcs competitive?
22:22:44 <Saizan> with the new repository format it's much more efficient, though i'm not sure if there's been a comparative benchmark recently
22:23:00 <Saizan> though darcs works pretty differently from the others
22:23:46 <p_l> I find all three to be pretty good for my usage. It's much worse when I have to import something through SVN (but I managed this one, finally, to work) and CVS requires plain old hacks...
22:25:08 <Berengal> I got stuck in silkworm :(
22:27:16 <kadaver_> delete :: (e -> Ordering) -> AVL e -> AVL e
22:27:21 <kadaver_> what should I pass then?
22:27:46 <kadaver_> delete (=="hello") tree; doesnt work
22:27:52 <kadaver_> @type (==1)
22:27:53 <lambdabot> forall a. (Num a) => a -> Bool
22:29:17 <kadaver_> well the problem is the quadratic(?) performance in some cases right? merging huge files takes 2 weeks with darcs and instant with git
22:30:49 <Cale> Berengal: the game isn't very long though, just restart :)
22:37:29 <mmorrow> @src Ordering
22:37:29 <lambdabot> data Ordering = LT | EQ | GT
22:37:40 <mmorrow> @type (<)
22:37:41 <lambdabot> forall a. (Ord a) => a -> a -> Bool
22:37:47 <mmorrow> @type compare
22:37:48 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:38:33 <kadaver_> @type (==)
22:38:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
22:39:23 <azathoth99> http://en.wikipedia.org/wiki/Andrew_Tridgell is this gent considered smart by haskellers?
22:40:55 <p_l> "The broad extent of Tridgell's analysis started by telneting to a BitKeeper server and typing HELP[3], something that, seemingly, no-one else had previously thought to try." <-- I'd say pretty smart guy :3
22:41:59 <Peaker-laptop> I think the git approach of keeping whole revisions rather than diffs is actually a better idea, too -- you can always re-diff stuff in the future with better diff heuristics/precision
22:43:14 <Saizan> it's less ideal when you want to be able to commute patches
22:47:03 <Peaker-laptop> Saizan, you can always bolt these kinds of abilities on, e.g: rebase/etc.  though I think git really lacks in that department
22:47:58 <Peaker-laptop> Saizan, Its nice to be able to sign a revision as "tested" or such -- is that possible with darcs? ("This patch-set works well together", or such)
22:48:24 <kadaver_> the AVL tree is great but the API is a bit meh
22:48:51 <azathoth99> what kinda of apps are you gents building with haskell?
22:48:57 <Saizan> Peaker-laptop: yes, with context files or tags
22:49:43 <mmorrow> Peaker-laptop: have you seen this video? http://projects.haskell.org/camp/unique
22:50:32 <mmorrow> (note that i had to watch it on the youtube page to get it to work for some reason..)
22:51:01 <mmorrow> oh, n/m now it works from there..
22:52:19 <kadaver_> is there no insert method for AVL?
22:53:07 <Cale> kadaver_: I have a hard time believing that would be the case...
22:53:58 <Cale> push?
22:55:17 <kadaver_> This function searches the AVL tree using the supplied selector. If a matching element is found it's replaced by the value (e) returned in the (Eq e) constructor returned by the selector. If no match is found then the default element value is added at in the appropriate position in the tree.
22:55:31 <kadaver_> oh
22:55:38 <kadaver_> i didnt read the whole thng
22:55:48 <kadaver_> *embarassed smiley*
22:57:04 <kadaver_> but hwat the hell is a COrdering
22:57:40 <azathoth99> http://en.wikipedia.org/wiki/Git_(software) interesting
22:57:49 <azathoth99> so darc performance is bad?
22:57:52 <azathoth99> darcs
22:58:00 <azathoth99> or from haskell view is darcs better?
22:58:16 <TomMD> azathorth99: darcs performs quite well for me these days.
22:58:19 <azathoth99> any attempt at a haskell OS?
22:58:42 <TomMD> azahoth99: What does everyone always mean by that?
22:58:54 <Cale> azathoth99: darcs 1.x had performance issues, but 2.x basically fixed them
22:59:18 <Cale> azathoth99: There are some operating systems written in Haskell.
22:59:42 <TomMD> azathoth99: I've heard that many times, but everyone ends up meaning something different.  "A Haskell OS" is... Linux with all system utils re-written in Haskell.... or an OS without mutable files... or a kernel written in Haskell... or something else?
23:00:04 <Cale> There's House, and iirc, some people are working on an L4 kernel in Haskell.
23:00:58 <Cale> kadaver_: COrdering is a strange variant of Ordering which that AVL library uses.
23:01:18 <Cale> kadaver_: Do you already know what Ordering is?
23:01:32 <Cale> > compare "house" "tree"
23:01:33 <lambdabot>   LT
23:01:44 <Cale> @src Ordering
23:01:44 <lambdabot> data Ordering = LT | EQ | GT
23:01:57 <Cale> Basically, just the result of an ordering comparison
23:02:28 <Cale> COrdering is similar, except that the constructors are Lt, Eq, and Gt, and the Eq case takes a parameter
23:02:34 <kadaver_> yes
23:02:40 <Cale> data COrdering a = Lt | Eq a | Gt
23:03:02 <Cale> So that the comparison can produce a result in the case that there was a match.
23:03:10 <kadaver_> L4=?
23:03:21 <TomMD> @hoogle Osker L4
23:03:21 <lambdabot> Did you mean: :: Osker L4 /count=20
23:03:21 <lambdabot> No results found
23:03:21 <kadaver_> what the hell is an OS with no mutable files?
23:03:27 <TomMD> @go Osker L4
23:03:27 <lambdabot> No Result Found.
23:03:53 <azathoth99> I mean something I can put on my pc hardware
23:04:01 <Cale> kadaver_: It's a particular microkernel design.
23:04:04 <azathoth99> so i can browse web watch porn and have fun
23:04:11 <TomMD> kadaver_: There was an OS proposal with GCed package manager.
23:04:25 <p_l> azathoth99: You can run L4Linux over L4
23:04:26 <azathoth99> Im currently trying netbsd 5
23:04:32 <TomMD> kadaver_: And iirc, HaLFS is a GCed file system.
23:04:38 <azathoth99> l4linux whats that
23:04:57 <azathoth99> netbsd apparentyl has  a log structured fiel system
23:04:59 <azathoth99> sounds kinda cool
23:05:00 <Cale> azathoth99: Most of the operating system stuff which has been done in Haskell is fairly special purpose.
23:05:11 <Cale> (or is research material)
23:05:37 <TomMD> Hopefully we can change that soon here.
23:06:35 <p_l> azathoth99: l4linux is linux kernel as userspace application running on L4
23:07:25 <TomMD> A darned good idea too - its sad that no major distribution is L4 based.
23:18:55 <kadaver_> f it is microkernel it isnt linux...?
23:19:03 <kadaver_> i mena linux is the kernel right?
23:19:10 <kadaver_> it would be L4+KDE or what?
23:19:20 <kadaver_> or L4+linux filesystem?
23:19:33 <araujo> hello ...
23:19:39 <araujo> kadaver_, what is the question?
23:19:59 <azathoth99> hm
23:20:57 <kadaver_> i still dont get compare
23:22:25 <kadaver_> why would anyoen name a project Fiasco
23:23:06 <kadaver_> COrdering I mean
23:23:10 <thoughtpolice> Cale: maybe soon galois will send out their patches for ghc-on-xen
23:23:14 <thoughtpolice> :)
23:23:33 <araujo> kadaver_, you are the same guy who joins other language channels and troll?
23:24:48 <kadaver_> wtf?
23:25:43 <mmorrow> myEq :: (Ord a) => a -> a -> Bool; myEq a b = EQ == compare a b
23:25:58 <mmorrow> myLt :: (Ord a) => a -> a -> Bool; myLt a b = LT == compare a b
23:26:00 <mmorrow> etc
23:26:20 <kadaver_> i dont get it
23:28:50 <kadaver_> why do people do stuff like this?
23:28:56 <kadaver_> its like the worst API ever
23:31:36 <kadaver_> wtf
23:32:18 <kadaver_> i need Data.Ordering?
23:32:29 <p_l> kadaver_: l4linux is running linux kernel as userspace application on top of l4 kernel. this allows you to use both linux applications, as well as drivers, at the same time as other l4 apps
23:32:59 <p_l> oh, and I heard that L4 linux is actually faster on ARM than normal one :)
23:37:51 <kadaver_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4509#a4509
23:37:54 <kadaver_> bah kill me
23:40:45 <mmorrow> wouldn't that be redundant?
23:41:22 <kadaver_> i dont get it,at all
23:41:50 <mmorrow> well, since cadavers are already dead... ;)
23:46:58 <kadaver_> well do you know what i should do?
23:57:48 <kadaver_> algorithmic language
23:57:52 <kadaver_> as opposed to?
23:58:52 <dons> edwardk, Saizan interesting discussion. I guess the idea that metres/feet are types is just the wrong intuition. hence dimensional uses Area, Volume etc.
23:59:08 <ivanm> dons: what did you use to make those slides about haskell usage in galois?
