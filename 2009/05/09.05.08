00:00:37 <ivanm> Twey: well, I thought he meant usage wise ;-)
00:00:59 * ivanm has no idea what HSH.run actually does
00:01:12 <Twey> dancor_: Maybe System.Posix.createNamedPipe?
00:01:16 <Twey> Er, sorry
00:01:33 <Twey> No, yes, that's it
00:04:35 <ski> > "mkfifo" == "my_fifo"
00:04:36 <lambdabot>   False
00:05:20 <Twey> ivanm: It runs a command :)
00:05:33 <Twey> (command, [argument]), I presume
00:05:50 <ivanm> ski: eh, missed that
00:06:22 <ivanm> how about "curry HSH.run" ?
00:16:39 <dolio> Woo, quick-check-found bug #2.
00:18:03 <hatds> ?
00:18:14 <hatds> page says it doesn't exist
00:18:16 <Elly> dolio: ?
00:18:21 <Elly> dolio: do tell
00:18:34 <hatds> (quickcheck is just *that* good...)
00:18:49 <dolio> My radix sort was using "fromInteger i `xor` 128" for sorting Int8s.
00:19:05 <dolio> That generates negative indices, so quick checking it caused a segfault.
00:20:13 <Elly> ah, nice :)
00:20:26 <Elly> quickcheck needs to support detecting higher-order semantic errors
00:20:47 <Elly> like
00:20:58 <dancor_> Twey: thank you
00:21:07 <Elly> quickcheck should analyze your program and ensure that it is not equivalent to a one-line shell script
00:21:34 <Elly> "Test failed: 'program is a productive use of time'"
00:21:47 * Twey laughs.
00:22:05 <Elly> I vote that dons be responsible for implementing this
00:31:16 <ivanm> Elly: why dons?
00:31:29 <ivanm> AFAIK, he has never had anything to do with quickcheck (apart from using it)...
00:31:34 <ivanm> dons /= haskell
00:31:36 <Elly> why not dons?
00:31:48 <ivanm> why not actually get the QC devs to do it?
00:31:55 <ivanm> or, since you want it, _you_ do it
00:32:18 <Elly> ivanm: I think we have a seriousness mismatch here :P
00:32:37 <ivanm> or else I'm out-joking you by acting serious... ;-)
00:32:42 <Elly> maybe!
00:32:46 <Elly> it's not entirely clear
00:33:01 <_br_> Need to do music beat detection in (soft) real-time. I'd like to try haskell but don't know if its the right choice. Anybody got an idea?
00:33:42 <ivanm> depends... how do you do beat detection?
00:35:41 <_br_> get input from sounds source e.g. /dev/dsp, do some normalization, dft, extract onset components and all other features which interest me (probably using multiple cpu's) and then give a prediction which will be used for other problems e.g. calculate robot trajectories
00:35:57 <_br_> very roughly speaking...
00:37:32 <_br_> I was also playing with the idea of using Haskell or Erlang as a glue language and combine it with some C implemented libs or self impelemnted parts.
00:38:00 <_br_> Erlang supports soft-RT but the lack of math support is terrible...
00:38:01 <edwardk> hrmm, neat. i just realized that my style of parser can extract an arbitrary seminearring from the result. i.e. the # of parses without actually doing all of them.
00:38:13 <Elly> what's a seminearring?
00:38:31 <edwardk> a semiring with a distributive law only on one side
00:38:33 * Jebdm thinks it would probably be easier to use C as the glue language and implement the other bits in Haskell
00:38:41 <Elly> and a semiring is...? :P
00:39:18 <edwardk> semiring = a pair of monoids (i.e. multiplication and addition) with a distributive law and zero that cancels multiplication. =)
00:39:29 <Jebdm> Haskell seems to me to be great for doing actual processing, but a little more difficult to use for glue-like stuff that is easy in imperative languages
00:40:01 <Berengal> I often use haskell as a glue-language
00:40:13 <edwardk> elly: the naturals form a semiring. you have multiplication, addition, zero and one, zero cancels multiplication and (a + b) * c = a * c + b * c and c * (a + b) = c * a + c * b.
00:40:15 <Jebdm> I'm not saying it can't be done ;)
00:40:19 <Berengal> if all else fails, drop back to IO and use system :P
00:40:27 <_br_> Hm interesting advice :) thanks
00:40:37 <Jebdm> And I'm guessing that if you got good at it, it'd probably be safer than using something else.
00:40:54 <Berengal> I find haskell actually makes a rather nice scripting language if bash doesn't cut it
00:40:55 <Jebdm> But, at least in my opinion, it's a pain.
00:40:59 <Elly> edwardk: my grasp of algebraic structures is lacking :P
00:41:07 <edwardk> Jebdm: you're generating instructions for a virtual machine or something?
00:41:28 <Jebdm> edwardk: I'm implementing a virtual machine
00:41:30 <edwardk> Jebdm: what are you planning to do with these instructions once you have them?
00:41:35 <edwardk> Jebdm: ah
00:41:51 <Jebdm> A bit of a toy, but maybe some good will come out of it
00:41:51 <edwardk> Jebdm: is it an existing vm or are you making it up?
00:41:52 <ski> edwardk : why would that give you number of parses without computing (all of) them ?
00:42:05 <Jebdm> edwardk: I'm making it up
00:42:06 <ivanm> anyone know what the "haskell-refac-mode" listed here is? http://www.emacswiki.org/emacs/init-haskell.el
00:42:37 <Jebdm> edwardk: I'm experimenting with various ways to break out of von Neumann while still maintaining feasibility in hardware
00:42:41 <edwardk> Jebdm: then i'd challenge that you might be better off just interpreting over a machine that has its tokens defined in an ADT than concerning yourself with mapping them down to bytes and back up =)
00:43:51 <_br_> sorry another newb question,... what do you think about C+FFTW+GSL (ATLAS, CBLAS...)  vs C+FFTW+Haskell ... would it make sense to pass data to Haskell to do some math on it rather then to use the GSL stuff for that ?
00:43:52 <edwardk> ski: (a <|> b) <*> (c <|> d) -- i can generate a result in the seminearring as i parse that applicative. and combine across branches. (4 + 3) * (2 + 1)
00:44:10 <Jebdm> edwardk: The reason I cared about the enumeration value was that I was going to allow for user-defined instructions
00:44:23 <Jebdm> edwardk: and I was experimenting with different ways of encoding that
00:44:56 <edwardk> ski: basically i just work in a 'seminearring as alternative' alternative instance. ;)
00:45:30 <edwardk> Jebdm: model it as an escape code and let them supply an auxillary adt that models the next 'byte'
00:45:31 <Jebdm> edwardk: one possibility that occurred to me was to map negative instruction values to their abs, and then use that as an index on a seq of microthreads
00:46:30 <Jebdm> edwardk: since I'm defining calls as invocations of threads
00:46:48 <ski> edwardk : interesting .. (i wonder if one could relate that to some "almost bind" operations i was pondering a while ago)
00:46:57 <edwardk> hrm, did you ever see dave taylor's old pinky processor stuff?
00:47:19 <Jebdm> edwardk: then, if all threads are pure, I've basically got the lambda calculus in "hardware"
00:47:28 <Jebdm> well, at least with some fudging
00:47:44 <Jebdm> edwardk: nah, I'll check it out, though
00:48:00 <edwardk> ski: anyways i realized that a recognizing parser just computed in the boolean semiring. so i can use this to count potential parses or use any of my other seminearrings from the monoids package. i.e. generate a possible parse trie
00:48:11 <Jebdm> edwardk: got a link?
00:48:23 <edwardk> Jebdm: for the monoids stuff?
00:48:29 <fuzzbrain> \join #happs
00:48:51 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/ -- the parser combinators are coming still. an old version of the basic gadt is online though
00:49:03 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/
00:49:16 <Jebdm> edwardk: no, the pinky processor
00:49:29 <edwardk> Jebdm: sorry crossed the streams ;)
00:49:35 <edwardk> it seems it may have been taken offline
00:49:47 <edwardk> he had it up before he joined transmeta but thats now going on 12 years ago
00:50:04 <Jebdm> edwardk: what was the general gist?
00:50:27 <Jebdm> edwardk: yeah, i can't seem to find it via google (I found an old /. article, but the link from it is broken)
00:51:01 <edwardk> Jebdm: a tiny processor with 3 instructions one of which installed basically a wait for a register/memory location to receive a value designed to run several thousand very very very tiny processes at a time
00:52:34 <Jebdm> edwardk: what were the other two? subjneqz and the like?
00:52:40 <edwardk> ski: the nice thing is my 'recognizing parser' is just a dumbing down of my alternative instance to only express the seminearring portion of the grammar. i hadn't fully realized it i was just thinking of a list of parses
00:53:00 <edwardk> Jebdm: one was a write
00:53:01 <Jebdm> subjneqz = subtract and jump if not equal to zero
00:53:33 <edwardk> it wasn't designed to be silly minimalist it was designed so that with bitwise addressing it could be put out as an alternative parallel-only control flow architecture
00:53:49 <edwardk> you mentioned you were interested in non von-neumann designs, so i figured it was applicable
00:54:19 <Jebdm> I'm just trying to figure out how it achieved Turing-completeness
00:54:42 <ski> edwardk : `(>>=_) :: M a -> (a -> N b) -> N b', consider `M,N' being either of `[],Maybe',`State sr,Reader sr',`[],Const Natural'
00:54:52 <Jebdm> with only three instructions, one a write and one a read/wait, the other one would have to be something completely sufficient
00:55:42 <edwardk> Jebdm: nah, the write had basically a copy bit or flip bit flag, so you could build the cascade needed for mult/add, and it had a tricky indexing scheme that could write to arbitrary bits rather than larger registers
00:56:16 <edwardk> ski: GenMonad in uu-parsinglib, my old parameterized monad parse, there are lots of them
00:56:29 <edwardk> ski: heck i posted one the other day for unboxing monad like things
00:56:42 <Jebdm> huh, strange
00:56:52 <edwardk> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4610
00:56:53 <Jebdm> then the third instruction must've been some sort of conditional?
00:57:16 <edwardk> Jebdm: i think the wait had a positive or negative condition involved in it
00:57:25 <ski> edwardk : "them" being ?
00:57:33 <GoldyOrNugget> > map read [show i ++ show j | i <- [1..10], j <- [1..10]]
00:57:34 <lambdabot>   [* Exception: Prelude.read: no parse
00:57:41 <Jebdm> huh, interesting
00:57:46 <GoldyOrNugget> ?
00:57:54 <GoldyOrNugget> > map read [show i ++ show j | i <- [1..10], j <- [1..10]] -- why doesn't this work?
00:57:55 <lambdabot>   [* Exception: Prelude.read: no parse
00:57:59 <edwardk> ski: values of M and N that can be used for satisfying your (>>=-) like type
00:58:07 <edwardk> ski: look down at the bottom of that link =)
00:58:23 <Berengal> > [show i ++ show j | i <- [1..10], j <- [1..10]]
00:58:23 <wjt> > map read [show i ++ show j | i <- [1..10], j <- [1..10]] :: [Int]
00:58:25 <lambdabot>   ["11","12","13","14","15","16","17","18","19","110","21","22","23","24","25...
00:58:25 <lambdabot>   [11,12,13,14,15,16,17,18,19,110,21,22,23,24,25,26,27,28,29,210,31,32,33,34,...
00:58:38 <Berengal> > read "15"
00:58:39 <lambdabot>   * Exception: Prelude.read: no parse
00:58:42 <Berengal> > read "()"
00:58:43 <lambdabot>   ()
00:58:49 <Berengal> Conclusion: MR
00:59:59 <GoldyOrNugget> cool thx
01:00:03 <ski> edwardk : but that `Unboxed' is a function .. i was talking about there not necessarily being a fundep from `M' to `N'
01:00:33 <Twey> Huh, read defaults to unit?
01:00:45 <edwardk> ski: http://comonad.com/reader/2007/parameterized-monads-in-haskell/ =)
01:00:46 <Twey> Not in *my* GHCi
01:00:51 <Berengal> Everything containing unit defaults to unit
01:01:04 <edwardk> ski: i was pointing out an example of a similar type, that article actually generalizes your type a step further
01:01:05 <ski> edwardk : for the `[],Maybe' case, the idea is that in the "far-right" `(>>=)' we can avoid even potentially creating alternative solutions is we just want one global one (first or arbitrary)
01:01:21 * juhp is wondering what other distros are planning for haskell-platform
01:01:27 <edwardk> ski: sure
01:01:37 <edwardk> ski: uu-parsinglib uses this internally in their GenMonad
01:01:54 <Berengal> > uncurry (>).(read***read) $ ("15","10")
01:01:54 <juhp> not really sure whether the big tarball or the small on if the way to go
01:01:55 <lambdabot>   * Exception: Prelude.read: no parse
01:01:58 <ski> s/"far-right" `(>>=)'/"far-right" `(>>=)'-branch/
01:02:02 <Berengal> > uncurry (>).(read***read) $ ("()","()")
01:02:03 <lambdabot>   False
01:02:06 <ski> edwardk : for the `State sr,Reader sr' case, we can avoid returning the `sr'-typed value up that same branch
01:02:13 <Berengal> > uncurry (+).(read***read) $ ("15","10")
01:02:14 <lambdabot>   25
01:02:24 <ski> edwardk : and in the `[],Const Natural' case, we can avoid constructing the values
01:02:32 <edwardk> ski: http://comonad.com/haskell/monad-param/ has code for it
01:02:41 <ski> edwardk : the two former of these satisfy more laws than this latter one, though
01:03:24 <edwardk> sure
01:03:49 <edwardk> i put this together as part of a nice little security monad package that i never did bother to release.
01:04:22 <edwardk> where you can do parameterized binds merging classified and secret monads without having to deal with a manual 'lift' operation
01:07:57 <ski> edwardk : is that "Parameterized monads" really that related to what i was talking about (which appears to be same or similar to `Text.ParserCombinators.UU.Parsing.GenMonad')
01:08:01 <ski> ?
01:08:48 <edwardk> you are talking about GenMonad, but take my parameterized bind whenever m2 = m3 and you have your definition as well
01:08:51 <ski> (fyi <http://hackage.haskell.org/packages/archive/uu-parsinglib/2.0.0/doc/html/Text-ParserCombinators-UU-Parsing.html#t%3AGenMonad>)
01:09:00 <edwardk> ski: yeah i mentioned it above
01:09:27 <edwardk> i spotted it when i rewrote my copy of uu-parsinglib to be legible
01:09:28 <ski> (yes, just wanted to give direct link, if anyone wanted to see it)
01:09:46 <ski> have you written that `GenMonad' .. or someone else at UU ?
01:10:36 <edwardk> ski: http://comonad.com/haskell/uu-parsinglib-alt/Text/ParserCombinators/UU/Parsing.hs was my gutted version
01:10:42 <edwardk> ski: nah, someone over there did
01:11:28 <edwardk> ski: i just tried to read the resulting code that was distributed and couldn't make heads or tails of it, so i reformatted it, rewrote it to use control.applicative got rid of some bad instance declarations and put it away
01:11:29 <ski> ("gutted version" meaning the one you started from ? or the result ?)
01:11:58 <ski> (the latter, it appears)
01:12:08 <edwardk> P_m P_h P_f -- format great for latex based papers but terrible for human readability of the source.
01:12:39 <edwardk> there was an instance of Applicative f => Functor f -- great fun if you never want to write any code that uses this stuff or like overlapping instances
01:12:41 <edwardk> etc.
01:13:15 <edwardk> one of my later refactorings broke something down in the core of it and i haven't bothered to fix it because it prompted me to think about my own combinator set
01:13:28 <ski> ((edwardk : btw, i misread your blog post as just talking about `(>>=) :: m p0 p1 a -> (a -> m p1 p2 b) -> m p0 p2 b)')
01:13:36 <_br_> Anybody know a good reference on Haskell + Advanced Math?
01:14:00 <edwardk> ski: a common misparse of that article =)
01:14:09 <ski> @google haskell road
01:14:10 <lambdabot> http://homepages.cwi.nl/~jve/HR/
01:14:10 <lambdabot> Title: The Haskell Road
01:14:25 * ski wonders how much "advanced math" that book contains .. never read it
01:14:56 <Vq^> don't know if i should call it 'advanced'...
01:15:08 <Berengal> Mmmm, monoids...
01:15:23 <edwardk> anywyas i wrote that back before i started to completely abhor overlapping instances so the default definition for binding to Identity that is in there uses overlapping instances
01:15:28 <edwardk> but at least they are coherent ones
01:15:51 <ski> (fyi "The Haskell Road to Logic, Maths and Programming" by Kees Doets,Jan van Eijck)
01:16:04 <_br_> Thanks for the tip ski !
01:18:16 <ski> edwardk : anyway, ty for mentioning `GenMonad' (and maybe "Parameterized monads", too .. i'll see :) .. food for thought with comparing
01:18:51 <edwardk> ski: note the interesting fact that they eliminated the use of GenMonad in uu-parsinglib ;)
01:19:20 * ski hasn't yet seen what use of `GenMonad' they actually had
01:20:13 <edwardk> the idea is instead of using (>>=_) you can make up a new monad lets try data ListMaybe a = [a] :*: Maybe a
01:20:39 <edwardk> and you can define the bind of this monad to bind the list side together as usual, but ALSO to bind the list to your maybe using the (>>=-) you want.
01:20:54 <edwardk> and then if you use it as a LHS in (>>=) it propagates the list
01:21:44 <edwardk> but you can stop and extract the 'Maybe' out of it directly. note that the 'Maybe' like portion can get away with even being Applicative or weaker
01:24:23 <edwardk> the composite example in uu-parsing lib is the P_m monad.
01:24:29 <edwardk> which i think is a pretty neat idea
01:24:57 <edwardk> they have an applictive for 'futures' and a monad for 'history' and they let you build a monad out of the pair of them by working with history for all but the last bind
01:24:58 <ski> interesting .. this seems similar to another monad bitransformer i was sketching a time
01:25:09 <ski> (s/this/this aspect/)
01:26:33 <edwardk> ski: doaitse has a write up on the parser combinator page that mentions the genmonad abstraction and the P_h and P_f parsers and the derivation of P_m
01:27:31 <edwardk> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
01:28:06 <ski> (edwardk : i don't remember the exact details atm, but i had something like `Resume x = (Play x,Replay x)' where executing `Play' may throw an "exception" that contains a value of type `q' (question) together with a `Replay' action which you can start off by providing an `a' (answer), so it will fastforward through the history, and then start executing in `Play' from where it left off)
01:28:45 <edwardk> ski: hrmm
01:28:49 <ski> (yes, before you ask, this was used for CGI)
01:28:57 <edwardk> i think i tried that once for a Do/Undo thing as well
01:30:24 <ski> it seemed to work pretty well (a few rough edges to file off) .. at the end, we decided to do an interpreter on a datatype instead (partly because my labmate was uneasy about heavy monad magic ..)
01:30:54 <edwardk> heh, now that i think about it thats a lot like a toy continuable packrat parser that i never finished
01:31:39 <ski> (ty for the paper re `GenMonad')
01:31:40 <edwardk> if it needed information from further in the buffer than was available it'd throw out an exception with the location in the parse buffer that was needed to continue
01:32:25 <edwardk> i dusted it off the other day when i started thinking about parallelizable parsers again
01:33:48 <edwardk> if you have an array of productions, one very naive form of parallel parser would be to instead of reducing monoidally, would be to build the array for the entire input ala a normal packrat parser, and pick an arbitrary chunking boundary
01:35:23 <edwardk> then for each processor 'force' the production of all of the rules for a given offset. but thats not quite enough to fully parallelize things
01:36:19 <edwardk> now one _could_ claim that you could generate all parses for all positions in parallel, abusing packrat's worst case performance claims
01:37:31 * ski thinks he'd need to look up packrat parsing ..
01:37:59 <edwardk> and i suppose if you parsed right to left you'd have already forced all partial parses required
01:38:23 <ski> (right to left inside a chunk or over the chunks ?)
01:39:09 <edwardk> basically give each processor some subset of the rules to force and walk right to left over the input.
01:39:10 <mintsoup> ski lives in #haskell in addition to #prolog?1?! what a d00d
01:39:13 <mikm> Is there any special syntax for importing an operator?  I'm trying to do import Graphics.Rendering.OpenGL.GL ($=), but it's giving me a parse error.
01:39:25 <edwardk> (($=))
01:39:32 <edwardk> you're importing ($=)
01:39:51 <mikm> Ah, thanks
01:39:51 <ski> mintsoup : sorry ?
01:40:18 <mintsoup> ski unless you're someone else named ski you helped me with a prolog program about trees a couple nights ago ;o
01:40:30 <edwardk> mintsoup: we try not to think about the fact that he spends so much time slumming ;)
01:40:54 <ski> edwardk : (not understanding packrat parsing), i wonder why right-to-left wouldn't be symmetric to left-to-right (given random access of the tokens)
01:41:16 <ski> mintsoup : that may be so. i'm not very good at remembering nicks :)
01:41:25 <fuzzbrain> \quit
01:41:31 <mintsoup> ski; np, my problem was very mundane i'm sure ;)
01:41:33 <edwardk> ski: the grammar is biased in a PEG
01:41:46 <edwardk> ski: http://en.wikipedia.org/wiki/Parsing_expression_grammar
01:43:24 <ski> (mintsoup : i can't find your nick in the local scrollback, possibly you used a different nick&ip ?)
01:43:44 <ski> (mintsoup : but yes, i hang out in #prolog, too)
01:44:00 <mintsoup> naw.. it was almost 2.5 weeks ago now that i think about it==i just thought it was funny that you're here too ;D
01:44:17 * ski looks up "slumming"
01:44:24 * wli hasn't visited #prolog but hangs out on #mercury
01:44:37 <mintsoup> mercury makes you crazy you know
01:44:50 <edwardk> ski: =)
01:44:53 <wli> How so?
01:45:27 <ski> Mercury is cool
01:45:29 <mercury^> :(
01:45:40 <mintsoup> wli: http://en.wikipedia.org/wiki/Mercury_(element)#Hat_making
01:45:43 <mintsoup> :D
01:45:48 <edwardk> mintsoup: only in sufficiently large accumulations. i doubt wli gets to write enough code these days that it'll seriously affect him in the time he has left =)
01:46:20 <mintsoup> he does seem a little disorientated
01:46:42 * quicksilver agrees. Mercury is cool.
01:46:57 <mintsoup> O.o
01:47:34 <edwardk> quicksilver: bah, its usually the temperature of whatever is around it ;)
01:48:33 <mercury^> coincidentally:
01:48:39 <mercury^> 08:47 <@Triv> 70323:FMusic: Cryptic: Whatqhavetlowgoldobeenybreathing?
01:52:44 <edwardk> mercury^: why does that string look like its been lzss compressed?
01:57:38 <edwardk> holy crap there might actually be a parallel version of a peg parser that chunks
01:58:38 <edwardk> compute the follow set for each rule, then don't just force everything in the first slot in your chunk, but then force each element in the follow set of those rules until you run out of your 'chunk'
02:00:00 <edwardk> eventually you start needing rules from someone else but that should have been forced by the time you got there, it might need to ditch the infinite lookahead properties
02:02:42 <edwardk> you may need to keep forcing subsequent slots on failed rules though
02:04:20 <trez> if I do 'aRef = asks aReg' will this only be computed once?
02:05:02 <edwardk> trez: yeah
02:05:03 <ski> it its local context, provided it is not overloaded, yes
02:08:34 <quicksilver> well.
02:08:36 <edwardk> heh, turns out the limitation that i can only generate synthesized attributes doesn't matter you can emulate inherited attributes with a higher order function as a synthesized attribute.
02:08:36 <quicksilver> :t asks
02:08:37 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
02:08:45 <quicksilver> that produces an action
02:08:54 <quicksilver> the action 'aRef' may only be computed once
02:09:06 <quicksilver> but it will be performed anew each time you do "a <- aRef"
02:09:13 <quicksilver> maybe you meant "aRef <- asks aRef" ?
02:10:12 <ski> edwardk : limitation where ?
02:10:22 <ski> monoidal parsing ?
02:11:24 <edwardk> ski: in my bottom up tig-style parser, yeah
02:12:02 <edwardk> ski: right now i think i'm just going to start generating a bunch of parsers that can all parse a common grammar format and let them duke it out to see which ones are practical
02:12:23 <edwardk> ski: my intuitions in this space aren't good enough yet
02:12:29 <quicksilver> edwardk: "parserWars"
02:13:08 <Berengal> A long time ago in a galaxy far far away...
02:13:15 <edwardk> next round: Tomita vs. Kilbury. Fight!
02:14:11 <ski> (edwardk : i assume you've seen encodings of AG in LFPL, yes ?)
02:14:36 <wli> AG?
02:14:45 <ski> Attribute Grammars
02:14:52 <wli> What's LFPL then?
02:15:05 <ski> Lazy Functional Programming Languages
02:15:45 <ski> (.. or even in strict ones, though that's somewhat more roundabout)
02:15:46 <edwardk> ski: yeah i remembered a paper that was presented on them at msfp 08 and found that result and slapped my forehead ;)
02:16:23 <edwardk> ski: it was less obvious that i could apply the idea because i'm parsing in a very strange fashion
02:17:19 <edwardk> it was realizing that i could 'play' the result in an arbitrary applicative that let me spot the connection. i can be a little slow ;)
02:17:41 <ski> "Attribute Grammars as a Functional Programming Paradigm" by Thomas Johnsson in 1987 ?
02:17:55 <ski> (well, maybe not that one, if it was presented last year :)
02:18:50 <edwardk> attribute grammars as recursion schemes over cyclic representations of zippers
02:20:02 <edwardk> they cited the johnsson paper at least
02:20:48 <sinelaw> edwardk, that's a sentence to print on a banner and above your bed
02:21:17 <sinelaw> i mean, hang above your bed
02:21:17 <sinelaw> either that, or http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
02:22:01 <edwardk> sinelaw: well, the paper kinda got panned at the conference as not really providing anything new, but it was useful for jarring my memory ;)
02:22:37 <ski> (or "I wonder why I wonder why. I wonder why I wonder. I wonder why I wonder why I wonder why I wonder!")
02:23:25 <edwardk> bah, silly inductive definition. I wonder why I wonder why I wonder why ... =)
02:24:26 <edwardk> an infinite ambiguous central recursive parse ;)
02:24:32 <ski> (edwardk : hm, do you have a link to that paper ?)
02:24:57 <edwardk> ski: i just have a copy in front of me from the proceedings. it might be up at inria somewhere
02:25:32 <ski> google didn't turn anything but bibliograph info up
02:25:37 <ski> s//y/
02:27:27 <Axman6> s//x looks dangerous to me :o
02:27:33 <Axman6> /*
02:28:02 <edwardk> ski: hrmm i'm betting its just available via elsevier
02:28:13 <edwardk> welcome to the lovely racket that is academic publishing
02:33:28 <quicksilver> edwardk: perhaps this one is relevant? http://scholar.google.com/scholar?hl=en&lr=&cluster=11876937889091636326
02:36:34 <GoldyOrNugget> is it possible to slice a string? e.g. get "Hello World" into "World" easily?
02:36:48 <Deewiant> > drop 6 "Hello World"
02:36:49 <lambdabot>   "World"
02:37:26 <Berengal> > words "Hello World"
02:37:27 <lambdabot>   ["Hello","World"]
02:37:38 <Berengal> Might also work
02:37:50 <GoldyOrNugget> and if i wanted to get "llo Wor"?
02:38:09 <Deewiant> > drop 2 . take 9 $ "Hello World"
02:38:10 <lambdabot>   "llo Wor"
02:38:21 <Alpounet> > init "World"
02:38:23 <lambdabot>   "Worl"
02:38:29 <Berengal> > take 7 . drop 2 $ "Hello World"
02:38:32 <lambdabot>   "llo Wor"
02:38:36 <Alpounet> > drop 2 . init . init $ "Hello World"
02:38:37 <GoldyOrNugget> ooh, cool
02:38:38 <lambdabot>   "llo Wor"
02:38:38 <GoldyOrNugget> thanks
02:38:48 <Alpounet> as you see, there are _many_ ways...
02:38:49 <Deewiant> See also splitAt
02:38:53 <Deewiant> > splitAt 3 "Hello World"
02:38:54 <lambdabot>   ("Hel","lo World")
02:39:00 <GoldyOrNugget> > take 7 $ drop 2 $ "Hello World"
02:39:01 <lambdabot>   "llo Wor"
02:39:06 <GoldyOrNugget> yay!
02:39:44 <Berengal> , (\(splitAt 2 -> (_, splitAt 7 -> (s,_))) -> s) "Hello World"
02:39:47 <lunabot>  "llo Wor"
02:39:50 * GoldyOrNugget gasps
02:40:01 <Berengal> That one's somewhat more obscure...
02:40:12 <Berengal> For this purpose at least
02:40:27 <Deewiant> View patterns?
02:40:28 <Twey> ‘Somewhat more obscure’?  What *is* that?
02:40:31 <Twey> Oh, view patterns
02:40:36 <Twey> Of course
02:40:39 <Berengal> duh ;)
02:40:51 <Twey> That's completely redundant, though :-P
02:41:01 <Berengal> Yeah, I know...
02:41:06 <Berengal> Also, parenthesis everywhere
02:41:08 <edwardk> quicksilver: looks like a rehash of basically the same contents as the msfp paper
02:41:10 <Twey> Yeah
02:41:25 <doserj> > map ("Hello World"!!) [2..7]
02:41:26 <lambdabot>   "llo Wo"
02:41:46 <Deewiant> O(n*m) for teh win
02:41:54 <doserj> \o/
02:42:41 <Twey> , (\((\x -> words x) -> s) -> s) "h w"
02:42:42 <lunabot>  ["h","w"]
02:42:52 <Twey> , (\(\x -> words x) -> s -> s) "h w"
02:42:53 <Berengal> > filter (not . elem "Held") "Hello World"
02:42:53 <lunabot>  luna: Parse error in pattern
02:42:54 <lambdabot>   Couldn't match expected type `[[Char]]'
02:43:08 <Berengal> > filter (not . flip elem "Held") "Hello World"
02:43:09 <lambdabot>   "o Wor"
02:43:37 <Twey> , (\(\x -> words x -> s) -> s) "h w"
02:43:39 <lunabot>  ["h","w"]
02:43:43 <Twey> Hmn
02:44:25 <Twey> So the view pattern -> cuts off a lambda, but the lambda lambda doesn't?
02:44:34 <Twey> Er, the lambda ->
02:45:15 <Twey> Or is it simply that all view patterns must be bracketed?
02:45:33 <Twey> , (\words -> s -> s) "h w"
02:45:34 <lunabot>  luna: Pattern syntax in expression context: \ words -> s -> s
02:45:43 <Twey> , (\ (words -> s) -> s) "h w"
02:45:44 <lunabot>  ["h","w"]
02:45:50 <Twey> The latter, then
02:46:15 <Axman6> what just happened there ... o.O
02:46:22 <Berengal> , (\s -> length -> r) "Hello"
02:46:23 <lunabot>  luna: Pattern syntax in expression context: \ s -> length -> r
02:46:24 <edwardk> twey: you have to parenthesize or you're in an  ambiguous case in the grammar
02:46:38 <Twey> Aha
02:46:56 <edwardk> twey \(foo -> bar) -- had no legal parse before. so it was safe for them to extend it
02:47:09 * Twey nods.
02:47:16 <Axman6> for those who haven't seen it, this is a hilarious history history of programming languages: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
02:47:17 <C-Keen> is atom now the next cool thing in haskell?
02:47:25 <Twey> Whereas \foo -> bar -> baz requires backtracking
02:47:26 <edwardk> in fact since the pattern parser is usually the same as the expression parser, it was almost already done for them ;)
02:47:50 <wli> What's Atom?
02:47:50 <edwardk> Twey: plus, is likely just a typo that they would have given a nice error message for before
02:48:02 <Twey> C-Keen: I hadn't heard of it, so I'm guessing no :-P
02:48:10 <Twey> edwardk: *nods*
02:48:54 <edwardk> , ( (+1) -> (*4) -> x) 12
02:48:55 <lunabot>  luna: parse error on input `->'
02:49:00 <edwardk> aww
02:49:13 <edwardk> , ( (+1) -> ((*4) -> x)) 12
02:49:14 <lunabot>  luna: Pattern syntax in expression context: (+ 1) -> ((* 4) -> x)
02:49:22 <edwardk> er
02:49:46 <edwardk> , (\( (+1) -> ((*4) -> x)) -> x * 3) 12
02:49:47 <lunabot>  156
02:50:00 <edwardk> viewpatterns in viewpatterns woot
02:50:21 <quicksilver> yo dawg?
02:50:23 <edwardk> yo dawg i heard you liked view patterns
02:50:24 <edwardk> yeah
02:50:39 <Axman6> i think it's time for... another IOHCC!
02:50:47 <Axman6> -C... i think
02:51:11 <Berengal> map @pl ghc?
02:51:13 <edwardk> Axman6: too bad shapr's ex won't give him the harddrives that have the old iohcc winner entries. i really liked Remose
02:51:13 <edwardk> er Remorse
02:51:24 <Axman6> :(
02:53:49 <dolio> @check \(Blind f) (Blind g) (Blind h) x -> liftM2 (==) (\ (f -> (g -> (h -> y))) -> y) ((f :: Int -> Int) . (g :: Int -> Int) . (h :: Int -> Int)) x
02:53:49 <lambdabot>   Parse error at "->" (column 55)
02:54:34 <edwardk> lambdabot doesn't like viewpatterns
02:54:42 <dolio> @check \(Blind f) x -> f x == f x
02:54:44 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
02:54:44 <lambdabot>          ...
02:54:57 <dolio> @check \(Blind f) x -> f x == (f :: Int -> Int) x
02:54:58 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
02:54:59 <lambdabot>          ...
02:55:01 <dolio> Bah.
02:55:17 <edwardk> dolio: they are really handy for killing temporaries though
02:56:29 <edwardk> i hate sticking primes on the end of things so foo x (mappend x -> y) = ... -- lets me above ever naming a var just to mappend it )
02:56:41 <ski> "1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says \"No.\" to every query." ;)
02:56:52 <edwardk> ski: hahahaha
02:57:12 <Vq^> ski: :D
02:57:27 <ski> (that's from the link Axman6 showed just above)
02:57:52 <Axman6> :)
02:58:12 <ski> (see the next entry about `ML', too)
02:58:43 <dolio> @check \(Blind x) y -> x == y
02:58:45 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
02:58:45 <lambdabot>          ...
02:58:57 <ski> @type Blind
02:58:59 <lambdabot> forall a. a -> Blind a
02:59:03 <ski> @type Deaf
02:59:04 <lambdabot> Not in scope: data constructor `Deaf'
02:59:30 <edwardk> Lambda the Ultimate Kitchen Utensil =)
03:00:09 <dolio> Now I'm confused, because Blind doesn't seem to exist in QuickCheck-1.1.0.0, which is where it's claiming to get Arbitrary from.
03:00:45 <dolio> So it must be getting Blind from a newer version of QuickCheck, using two version of the library at the same time or something.
03:01:23 <dolio> Unless it's implementing it itself.
03:02:23 <edwardk> Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
03:04:38 <daf> edwardk: I suspect most "monads are hard" people have never heard of endofunctors, so I'm not sure "appease" is the right verb :P
03:05:13 <Peaker> I think that was a joke :-)
03:05:40 <Peaker> though with my limited knowledge of CT I don't understand how a Monad is a Monoid in any category..
03:06:42 <ski> not *any* category, a (endo-)functor-category !
03:07:04 <edwardk> peaker: you have 1 -> M, and MM -> M -- in the form of of return and bind.
03:07:14 <edwardk> those should look like the unit and mappend of a monoid
03:07:24 <edwardk> and they are required to satisfy the same laws
03:07:38 <edwardk> peaker: that is all that is saying =)
03:07:55 <Peaker> edwardk: doesn't it require the type of (m a) and (a -> m b)  to be the same?
03:08:22 <Peaker> edwardk: also, (a -> m a) -- where's the 'a' disappeared to?
03:09:25 <edwardk> peaker: its in the category of endofunctors, which you can't express directly in haskell so there are some notational differences
03:10:26 <edwardk> the index 'a' is implicit in that notation as we're talking about functors, they map every object and arrow in the category into the target category. and being endofunctors they map the category onto itself.
03:11:56 <_br_> My earlier question regarding Math and Haskell (beside the book reference which I got)... I also found this paper on it http://users.informatik.uni-halle.de/~thielema/Research/icfp2007mathematics.pdf
03:12:49 <edwardk> peaker: also that MM -> M -- is define in terms of join not bind
03:12:49 <ski> a natural transformation `eta : f >-> g' can be thought of as `eta :: forall a. f a -> g a'
03:12:52 <edwardk> @type join
03:12:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:13:22 <edwardk> return, join and fmap can define a category or you can use return and bind.
03:13:22 <ski> for `return :: forall a. a -> m a', this can be converted into `return :: forall a. id a -> m a', hence `return : id >-> m'
03:13:37 <edwardk> haskell went the latter route because its a better model for computation and only takes two definitions
03:13:56 <ski> similarly for `join :: forall a. m (m a) -> m a' turned into `join : m . m >-> m' (where that latter `.' is composition)
03:14:11 <Phyx-> Hello, i'm getting this error with a existential http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4718#a4718 does anyone know how to fix this?
03:14:46 <quicksilver> that's not an existential
03:14:49 <edwardk> data Foo a b c = forall m. Monad m => Foo { foo :: a -> b -> m c}
03:14:56 <quicksilver> that's a universal, which is your problem.
03:14:56 <edwardk> that makes it existential
03:15:02 <edwardk> its not even that
03:15:55 <ski> _br_ : ok
03:16:22 <edwardk> newtypes cannot contain existential values in ghc. (but in uhc they can)
03:16:42 <Phyx-> ok, granted it's not an existential, i still don't know how to fix that
03:16:43 <edwardk> thats why i needed to switch to data, and moving the forall outside of the constructor Foo made it 'existential'
03:16:43 <Peaker> edwardk: Isn't a Monad in that category really a special case of a monad with less of the features?
03:17:01 <ski> edwardk : provided there's no constraint on the hidden types ?
03:17:06 <quicksilver> Phyx-: edwardk showed you how to fix it.
03:17:07 <edwardk> peaker: no. you can define bind from fmap and join
03:17:16 <Phyx-> quicksilver: i tried that
03:17:18 <Phyx-> same error
03:17:24 <Phyx-> oh
03:17:28 <quicksilver> edwardk: it's a data type containing a universal value
03:17:30 <ski>   k =<< m = join (k `fmap` m)
03:17:37 <quicksilver> edwardk: that's what I meant by 'it's a universal'
03:17:56 <Peaker> edwardk: (1 -> M) means the arrow source is a constant/contains no information?
03:17:59 <edwardk> quicksilver: yeah but where is the explicit forall for m? it just has the constraint
03:18:13 <ski> Peaker : `1' there is `id', the functor mapping any type to itself
03:18:16 <quicksilver> edwardk: the forall is implicit, next to the constraint.
03:18:27 <ski> Peaker : so `1 a' is `a'
03:18:43 <Peaker> ski: so (1 -> M) is not return, its fmap?
03:18:50 <Phyx-> sorry, lol. boy, when the time i'm done with this i'll have a whole bag full of these extensions enabled
03:18:53 <ski> it's the type of `return'
03:19:08 <ski>   return :: forall a. a -> m a
03:19:09 <Peaker> ski: hmm.. is there any visualization of this?  I don't see how it works out
03:19:11 <ski>   return :: forall a. id a -> m a
03:19:13 <edwardk> quicksilver: fair enough. that never seems to work for me =)
03:19:18 <ski>   return : id >-> m
03:19:25 <Peaker> ski: I don't know what >-> is..
03:19:29 <ski> generally
03:19:32 <edwardk> peaker: he defined it above
03:19:39 <ski>   eta :: forall a. f a -> g a
03:19:43 <ski> corresponds to
03:19:50 <ski>   eta : f >-> g
03:19:55 <ski> Peaker : morphism arrow
03:20:05 <Peaker> edwardk, ski: is there any visual sketch explaining this relationship?
03:20:26 <edwardk> type (f :~> g) a = forall a. f a -> g a -- makes the >-> like definition from category-extras legal haskell
03:20:30 <Peaker> edwardk: I don't understand why (identity-arrow -> object in M) is return?
03:20:33 <ski> (you need a naturality condition, as well .. but you get that for free in haskell)
03:21:07 <edwardk> peaker: think of it this way, pretend for a minute you only have arrows that look like that :~> above for a sec
03:21:15 <Phyx-> edwardk: using that, it tells me that lose the ability to use the selector function foo and instead should use patternmatching style. is this correct?
03:21:15 <ski> Peaker : not "identity-arrow", "identity-functor" (which admittedly is the identity in the category of categories ..)
03:21:19 <edwardk> so do define anything you have to define a 'natural transformation'
03:21:31 <edwardk> phyx: yes
03:21:32 <gio123> ski:hi
03:21:35 <gio123> ski:please
03:22:13 <Phyx-> well.. that sucks.. lol
03:22:14 <edwardk> peaker: so now, in that view you need two functors to define an arrow. return needs just any value in the category, so lets look at the category through the 'lens' of the identity functor. Identity a -> m a
03:22:30 <edwardk> which is
03:22:36 <ski> (hm, istr you could use the selector notation for updating, though .. but i may be imagining things)
03:22:38 <edwardk> return :: Identity :~> m
03:23:17 <edwardk> since return :: a -> m a  ~ forall a. a -> m a ~ forall a. Identity a -> m a ~ Identity :~> m
03:23:17 <Peaker> edwardk: the Identity functor maps objects/arrows in a category to the same objects/arrows in the same category?
03:23:26 <edwardk> peaker: yeah
03:23:31 <edwardk> @src Identity
03:23:31 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
03:23:44 <edwardk> modulo newtype noise in haskell
03:24:16 <edwardk> does that view of return as a natural transformation make sense?
03:24:28 <ivanm> Axman6: I've got some spam with your name on it...
03:24:37 <Peaker> edwardk: needs to sink in for a moment :)
03:24:38 <Axman6> :o
03:25:06 <ivanm> Axman6: which is strange, because it wasn't from your email address (at least the one I know about... >_> ) and it was to an address that I didn't give you...
03:25:07 <ivanm> ;-)
03:25:17 <Peaker> edwardk: now why is using :~> appropriate here?
03:25:29 <Axman6> o.O
03:25:38 <edwardk> return :: a -> m a -- is polymorphic. so the forall is implicit already
03:25:44 <Axman6> whut? should i be scared
03:25:46 <Axman6> :P
03:25:46 <edwardk> its just making it explicit
03:25:59 <Phyx-> edwardk: pardon my ignorance, but is here anyway that i can make it work while keeping the selector functions?
03:26:12 * ski remembers with horror `class (Functor f,Functor g) => NatTrans f g where eta :: forall a. f a -> g a'
03:26:13 <edwardk> Phyx-: no
03:26:18 <edwardk> Phyx-: existentials can't be returned by selectors
03:26:22 <ivanm> Axman6: nah
03:26:34 <ivanm> just thought it was weird that it had your name as the sender
03:26:35 <Phyx-> hmm ok
03:26:39 <Axman6> me too
03:26:46 <ski> Phyx- : i seem to recall that, at least if you use GADT style, you can have the selectors
03:27:21 <ski> Phyx- : but you still won't be able to *use* the selector on a record .. you'll just be able to create and update records, using the selector
03:27:23 <edwardk> peaker: so now to use your monad you have to suffer a little with newtypes because haskell likes you to work for correctness, but you could use return just as before
03:27:27 <dolio> ski: Clearly there's only one natural transformation between any two functors.
03:27:33 * ski nods gravely
03:27:34 <edwardk> dolio: hah
03:27:47 <eden> edwardk : you've just answered something I ws going to ask about.
03:28:00 <Phyx-> ski: i'm just rethinking the whole thing atm
03:28:14 <edwardk> peaker: so now to define join we need to have a notion of functor composition handy
03:28:35 <Peaker> edwardk: I still didn't understand why you use :~> ?
03:28:44 <Axman6> #haskell: premeptive problem solving everyday
03:28:52 <edwardk> peaker: in the 'category of endofunctors' the 'arrows' are all natural transformations
03:29:12 <ski> Axman6 : and we're supposed to be *lazy* functional programmers !
03:29:16 <edwardk> :~> is definition of a natural transformation, which is enforced by parametricity (if you ignore seq)
03:29:30 <Axman6> i know! how disappointing :(
03:29:39 <ski> shocking, it is
03:29:50 <gio123> ski: please only for 2 minute can u pm
03:30:26 <Peaker> edwardk: this category of endofunctors -- what endofunctors does it contain?  All of them?
03:30:52 <dolio> Yes*.
03:30:58 <dolio> (*No.)
03:31:07 <ski> (Peaker : all endofunctors over a given category, yes)
03:31:09 <edwardk> basically if i have any non-seq wielding function of type f :~> g named h then given any function k, the fact that it is a natural transformation means you can 'slide' it over the fmap.. fmap k . h = h . fmap k
03:31:13 <edwardk> peaker: yes
03:31:27 <edwardk> as evidenced by the presence that we've used Identity and M so far.
03:31:29 <Peaker> edwardk: its a category of endofunctors for some category, or of endofunctors of all categories?
03:31:53 <edwardk> peaker: it can be either, since well, you'll never be able to compose endofunctors that would have to cross categories ;)
03:32:21 <edwardk> you'd have no arrows that cross from one category to the other.. or they wouldn't be endofunctors
03:32:27 <edwardk> so the notion is unambiguous either way
03:33:14 <edwardk> thats why we can just talk about the category of endofunctors and not care too much about the details
03:33:16 <Peaker> well, it has to be endofunctors of all categories for "Identity" of some category to contain any information at all?
03:33:52 <edwardk> remember arrows in a category are indexed by their endpoints. so Identity implicitly carries a parameter like Identity_Hask
03:34:34 <edwardk> category theory is 'monomorphic' and disambiguated by context and shared understanding mostly ;)
03:35:13 <Peaker> I don't understand what that means -- but I think you've given me enough food for thought that I might finally understand Monad<->Monoid relationship later/soon.. :)
03:35:24 <edwardk> so when i say M i'm talking about some endofunctor from some category C to itself. the category C in the category of endofunctors is an object in the category of endofunctors
03:36:03 <edwardk> the arrows in the category of endofunctors all run from an object (categor) back to itself. so you have a bunch of disconnected islands
03:36:44 <edwardk> since we're claiming the category of endofunctors is a category, associated with every object (category) in the category of endofunctors there is an Identity arrow.
03:36:54 <edwardk> which is the Identity functor for that category.
03:37:04 <Peaker> the category C is a category, not an endofunctor, so why is it "in the category of endofunctors"?
03:37:16 <eden> I've made myself a parsec stream that generates (SourcePos, Char) tokens. This means that I'm not able to use the standard Text.Parsec.Char combinators. I can redefine them all, but don't want to have to do it over and over. canyone think of a way of doing this?
03:37:30 <edwardk> peaker: a category has objects and arrows between objects. C is an object in the category
03:37:46 <edwardk> the arrows from them back to themselves are the arrows
03:38:01 <Peaker> edwardk: "the category C in the category of endofunctors" -- did you mean "the object C in the .." ?
03:38:27 <dolio> Objects in the category of endofunctors are endofunctors.
03:38:45 <edwardk> the short answer is yes
03:38:46 <Peaker> I gotta go. Thanks for that so far.
03:40:18 <edwardk> dolio: true
03:40:34 <edwardk> dolio: i'll tailor the explanation should he bring it back up again =)
03:41:19 <dolio> Probably easier if you just talk about the category of endofunctors for a certain category. Otherwise you'd have many I...
03:41:21 <edwardk> "the arrows from them back to themselves are the arrows" wow, its late and i'm barely coherent
03:41:39 <edwardk> i'm going to get an hour or two of sleep before work
03:41:43 <edwardk> later
03:41:44 <dolio> And many different ways to make the category monoidal, but each of which would only apply to some of the elements?
03:42:02 <dolio> Or would that make it not monoidal at all?
03:46:03 <ski> to be monoidal, you need a bifunctor
03:46:24 <ski> (that therefore can may every pair of objects to an object, et.c.)
03:46:41 <dolio> Yeah, so using the category of endofunctors over all categories (under a given size) wouldn't work.
03:47:37 <ski> right
03:47:52 <ski> (hence i said "over a given category")
03:49:37 <povman> arh! I must face the truth: that Reactive simply isn't fully developed yet! nooooo
03:49:46 <povman> slash wrists
03:51:01 <ski> backslash ankles
03:55:06 <ivan-kan`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4719
03:55:27 <ivan-kan`> is there a better way to write getRecursiveContent ?
03:56:05 <ivan-kan`> is it kosher to have multiple lets like I did ?
03:57:44 <eden> Let's try that again. I've got a parsec stream that works, and I've been able to write a satisfy function using the Text.Parsec.Prim.token function. I can write the other standard characteer combinators in terms of it, but want to use such modified combinators in several modules. I don't want to have to repeat this over and over though. Is there a shortish way or doing this.
03:57:47 <MyCatVerbs> ivan-kan`: nothing at all wrong with having multiple lets like that.
03:58:48 <MyCatVerbs> eden: stick all your modified combinators in one module which you import everywhere else that you want to use them from.
04:00:04 <ski> (ivan-kan` : though i'd elide the last one)
04:00:37 <ski> ivan-kan` : also, use `forM' instead of `mapM'
04:01:16 <ski>   forM filesize $ \(nom, act) -> do                           size <- act
04:01:18 <ski> er
04:01:44 <ski>   filesize' <- forM filesize $ \(nom, act) -> do
04:01:49 <ivan-kan`> ski OK, i just return DirTree (sum topdir filesize' dirtree)
04:01:49 <ski>     size <- act
04:02:00 <ski>     return (nom, size)
04:02:20 <ski> though that can probably be simplified more ..
04:02:40 <ski> @hoogle f (g a) -> g (f a)
04:02:40 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:02:41 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:02:41 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:03:02 <ski> > sequence (0,[1,2,3])
04:03:03 <lambdabot>   Couldn't match expected type `[m a]'
04:03:14 <ivan-kan`> it's a routine to get the IO out of IO Int getFileSize
04:03:35 <ski> hm
04:04:04 <ski> would it make sense to have `instance Traversable (w ,)' ?
04:04:56 <dibblego> what is (w ,) ?
04:05:12 <EvilTerran> insofar as Traversable instances for Id, Either e, etc would also make sense, yes
04:05:14 <dibblego> ((,) w) ?
04:05:27 <ski> dibblego : `(,) w', just with better (imo) (non-implemented) syntax
04:05:35 <eden> MyCatVerbs: I suppose that's the easiest way. I was hoping to be able to parameterise them somehow, so I can get them all at once when I write a satisfy function. Records didn't work,
04:10:30 <Axman6> hmm, what's the rold of isIEEE in prelude?
04:10:37 <Phyx-> I'm still having some problems trying to figure this out http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4718#a4721
04:13:49 <ski> @check isIEEE
04:13:50 <lambdabot>   "OK, passed 500 tests."
04:14:46 <doserj> > isIEEE (undefined::Double)
04:14:47 <lambdabot>   True
04:14:51 <doserj> > isIEEE (undefined::CReal)
04:14:52 <lambdabot>   False
04:16:49 <Phil_M> hey all. I'm trying to use the return values of 2 functions (both Ints) and divide them in another function return a float - but I can't seem to find a suitable operator. Does anyone know of one that takes 2 ints and returns a float?
04:17:25 <RayNbow> :t (/)
04:17:26 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:17:33 <RayNbow> :t fromIntegral
04:17:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:18:46 <Phyx-> so does anyone have any ideas on what i'm doing wrong?
04:18:49 <Phil_M> RayNbow: When I try / I get the error " Type : ...... -> Int Does not match : ...... -> Float. It seems to be returning an int instead of a float
04:19:32 <RayNbow> fromIntegral can convert a value of an integral type (e.g. Int) to a value of an arbitrary numeric type (e.g. Float)
04:20:02 <Phil_M> Ah, ok...I was just googling now to see what it did :P
04:20:09 <RayNbow> > let {x = 3 :: Int ; y = 2 :: Int} in fromIntegral x / fromIntegral y
04:20:10 <lambdabot>   1.5
04:20:42 <Phil_M> ah cool, thanks, I'll see if I can put it in my code
04:20:43 <doserj> > let (//) = (/) `on` fromIntegral in (3::Int) // (5::Int)
04:20:44 <lambdabot>   0.6
04:21:20 <RayNbow> Phyx-: using type constraints in data/newtype declarations is considered to be a Bad Idea (tm_
04:21:23 <RayNbow> (tm)*
04:21:48 <Phyx-> that may be, but I don't know how else to do it
04:22:22 <Phyx-> i tried adding m explicitly to Foo by that just introduces a whole lot of extra problems
04:24:43 <Phil_M> RayNbow: I managed to get fromIntegral to work perfectly. Thanks a lot!
04:24:54 <RayNbow> Phil_M: you're welcome :)
04:33:18 <Phyx-> bleh, this is pointless
04:33:26 <quicksilver> Phyx-: just leave the contraints out
04:33:33 <quicksilver> put them on the functions which need them
04:34:54 <Phyx-> *tries*
04:36:02 <quicksilver> They don't do much harm on the data declarations but they don't do much good, either
04:36:06 <quicksilver> except for the existential case
04:36:22 <Phyx-> well, leaving the constraint out dies with another neat error "Couldn't match expected type `m' against inferred type `f'" in the definition of createFoo
04:37:30 <ordnungswidrig> is anybody researching patch theory beyond vcs (darcs) and collaborative (live) editing?
04:39:17 <Phyx-> if i make it one specific monad, it's not a problem
04:39:20 <Phyx-> that works
04:39:46 <Phyx-> but when i say any, like i do now, it dies
04:39:57 <mreh> :t show
04:39:58 <lambdabot> forall a. (Show a) => a -> String
04:40:33 <mreh> what does the => mean?
04:40:46 <EvilTerran> Phyx-, that existential will be what's causing you the trouble
04:41:22 <EvilTerran> because it means the actual type that 'm' is can't escape the constructor
04:41:50 <Phyx-> hmm so just remove it?
04:42:06 <EvilTerran> can you parameterise Foo by m?
04:42:31 <quicksilver> Phyx-: why did you think you wanted it to be existential?
04:42:38 <quicksilver> mreh: it's just punctuation.
04:42:39 <Phyx-> that brings along so many other things i need to fix, but i guess i have no choice
04:42:46 <quicksilver> mreh: it separates the context from the type
04:42:52 <quicksilver> mreh: 'context' == all the classes.
04:43:28 <DrSyzygyIE> *snerk*
04:43:37 <DrSyzygyIE> >>> 1990 - A committee formed by Simon Peyton-Jones, Paul Hudak, Philip Wadler, Ashton Kutcher, and People for the Ethical Treatment of Animals creates Haskell, a pure, non-strict, functional language. Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
04:43:50 <Phyx-> quicksilver: well, becauze i wanted to avoid paramerizing Foo with m
04:43:56 <mreh> is that uncyclopedia?
04:44:00 <quicksilver> Phyx-: and why did you want to avoid that? :)
04:44:11 <quicksilver> Phyx-: I'm not trying to be difficult. But without understand the context of your choices...
04:44:16 <quicksilver> it's hard to suggest a good resolution.
04:44:17 <Phyx-> that changes it's kind, and then i have to change about 10 class instances and declarations
04:44:21 <DrSyzygyIE> mreh: Nope. James Iry: A brief, incomplete and mostly wrong history of programming languages.
04:45:53 <DrSyzygyIE> Also from the same: it's a syntax error to write FORTRAN while not wearing a blue tie.
04:46:01 <mreh> Infinite lists, for instance, are common in Haskell. In fact, all data items are treated as infinite lists of length 1. Other infinite lists may be longer.
04:46:05 <DrSyzygyIE> And >>> 1801 - Joseph Marie Jacquard uses punch cards to instruct a loom to weave "hello, world" into a tapestry. Redditers of the time are not impressed due to the lack of tail call recursion, concurrency, or proper capitalization.
04:46:12 <DrSyzygyIE> I'm done quoting random stuff now.
04:46:22 <Phyx-> quicksilver: well, that's the only reason, i wanted to avoid kind errors, and not to mention, i have no idea how i should change my class instances now
04:46:41 <DrSyzygyIE> mreh: "infinite lists of length 1" ??? _really_ ???
04:46:50 <DrSyzygyIE> What makes the list infinite if it has finite length?
04:47:17 <ordnungswidrig> what is this?  data X a b where f :: c -> d -> X a b
04:47:24 <ordnungswidrig> some kind of constructor?
04:48:14 <mreh> that was from uncylcopedia
04:48:22 <DrSyzygyIE> mreh: Oh, okay.
04:48:33 <DrSyzygyIE> Yeah, that'll make comparatively much sense. :-P
04:48:40 <ski> ordnungswidrig : the `f' should have initial letter in upper case
04:48:43 <mreh> what does .hs stand for?
04:48:48 <mreh> is it Homosexual?
04:48:50 <ordnungswidrig> ok
04:48:52 <ski> ordnungswidrig : it's GADT syntax
04:48:52 <ordnungswidrig> ski: right
04:48:59 <ski> mreh : Haskell Script
04:49:11 <Phyx-> quicksilver: because since i have for instance
04:49:12 <Phyx-> class RFoo g f where
04:49:12 <Phyx->   
04:49:13 <Phyx->   myfoo :: g a b c-> g (f a) (f b) (f c)
04:49:25 <Phyx-> now Foo would no longer work
04:49:39 <Phyx-> and i have no idea how to change that into something meaningfull, everything i tried failed
04:49:46 <mreh> This one is classic
04:50:02 <ski> mreh : no that quote about monads was from the link Axman6 pasted a little while ago
04:54:48 <mreh> :t show
04:54:49 <lambdabot> forall a. (Show a) => a -> String
04:55:01 <mreh> isn't show a Haskell action?
04:55:13 <DrSyzygyIE> What do you mean Haskelll action?
04:55:17 <mreh> im not sure
04:55:22 <mreh> let me find a reference
04:56:10 <mreh> command, not action
04:57:00 <ski> it's an action in the `(a ->)' monad
04:57:11 <mreh> p38 HSOE
04:57:38 * ski doesn't have that book
04:57:40 <mreh> that's a monad?!
04:58:21 <ski> > [(3+),(3*)] `ap` [4,5]
04:58:22 <lambdabot>   [7,8,12,15]
04:58:24 <ski> @type ap
04:58:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:58:49 <ski> > ((+) `ap` 5) 4
04:58:50 <lambdabot>       No instance for (Num (a -> a))
04:58:50 <lambdabot>        arising from the literal `5' at <...
04:58:55 * mreh does more reading
04:58:57 <ski> er
04:59:02 <ski> > ((+) `ap` return 5) 4
04:59:04 <lambdabot>   9
04:59:19 <ski> though that's not a very good example ..
04:59:24 <ski> (too simple)
04:59:26 <DrSyzygyIE> :t bind
04:59:27 <lambdabot> Not in scope: `bind'
04:59:33 <DrSyzygyIE> :t (>>=)
04:59:33 <ski> @type (>>=)
04:59:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:59:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:59:38 <DrSyzygyIE> Heh
05:00:34 <mreh> ski: well that's not so bad, i didn't understand it
05:00:36 <ski> mreh : `(rho ->)' (written `(->) rho' in haskell) is basically the same as `Reader rho', only you don't need to bother with `Reader',`runReader'
05:00:56 <DrSyzygyIE> > (show >>= (+)) $ 15
05:00:57 <lambdabot>       No instance for (Num String)
05:00:57 <lambdabot>        arising from a use of `+' at <inter...
05:01:01 <DrSyzygyIE> nooo....
05:01:05 <mreh> i've jumped too far ahead
05:01:08 <ski> > (do x <- (+3); y <- (*3); return (x,y)) 10
05:01:10 <lambdabot>   (13,30)
05:01:15 <ski> that's a better example
05:01:21 <mreh> i'm watching a video lecture, and the lecturer wrote:
05:01:34 <ski> the `10' is passed down and distributed over the action
05:01:42 <DrSyzygyIE> ski: What requirements are on the types of things that are allowed to live in (a ->) ?
05:01:48 <ski> it becomes an implicit input to `(+3)' and `(*3)'
05:02:00 <DrSyzygyIE> > (do x <- show; y <- (*3); return (x,y)) 10
05:02:00 <mreh> instance Show a => Show (List a) where
05:02:01 <lambdabot>   ("10",30)
05:02:06 <DrSyzygyIE> Ah!!!
05:02:32 <ski> DrSyzygyIE : no more requirement that what's necessary to make it type
05:02:37 <mreh> .... show (Cons x xs) = show x ++ " : " ++ show xs
05:02:53 <ski> (i.e. no restriction on what `a' may be)
05:02:55 <DrSyzygyIE> ski: Yeah, my run up there with show and *3 made it clear to me.
05:03:02 <vininim> ew
05:03:03 <mreh> how can you concat that string in the middle and still have it output
05:03:10 <DrSyzygyIE> ski: All your examples were not only a->, but actually all a->a.
05:03:27 <DrSyzygyIE> ski: I wanted to see something that allows different domains in the same monadic sequence.
05:03:35 <ski> > (do x <- (+3); y <- (*3); z <- flip replicate 'x' return (x,y,z)) 10
05:03:36 <lambdabot>   <no location info>:
05:03:36 <lambdabot>      The last statement in a 'do' construct must be an ...
05:03:48 <ski> > (do x <- (+3); y <- (*3); z <- flip replicate 'x'; return (x,y,z)) 10
05:03:50 <lambdabot>   (13,30,"xxxxxxxxxx")
05:03:59 <ski> happy ?
05:04:03 <DrSyzygyIE> Yup!
05:04:15 <DrSyzygyIE> Though, as I said, my own example above with show also shows off that.
05:04:34 <ski> (oh, didn't notice you put `show' in there)
05:04:46 <DrSyzygyIE> > (do x <- show; y <- (/3); z <- (+3); return (x,y,z)) 10
05:04:49 <lambdabot>   ("10.0",3.3333333333333335,13.0)
05:04:56 <DrSyzygyIE> :t (do x <- show; y <- (/3); z <- (+3); return (x,y,z)) 10
05:04:58 <lambdabot> forall a. (Fractional a) => (String, a, a)
05:05:06 <vininim> mreh:
05:05:08 <vininim> @type show
05:05:09 <lambdabot> forall a. (Show a) => a -> String
05:05:20 <DrSyzygyIE> > (do x <- show; y <- (/3) . fromInteger; z <- (+3); return (x,y,z)) 10
05:05:21 <lambdabot>   ("10",3.3333333333333335,13)
05:05:25 <DrSyzygyIE> :t (do x <- show; y <- (/3) . fromInteger; z <- (+3); return (x,y,z)) 10
05:05:26 <lambdabot> forall b. (Fractional b) => (String, b, Integer)
05:05:29 <DrSyzygyIE> Hah!
05:05:41 <DrSyzygyIE> :t (do x <- show; y <- (/3) . fromInteger; z <- (+3); return (x,y,z))
05:05:42 <lambdabot> forall b. (Fractional b) => Integer -> (String, b, Integer)
05:06:46 <mreh> vininim: i get that (++) takes a list, that Strings are lists, and show returns a list, but how does that get output onto the command line
05:06:57 <mreh> doesn't the show do the output?
05:07:06 <vininim> no, show just gives a string
05:07:28 <vininim> main monad or interpreter monad takes care of turning that string into output
05:07:38 <mreh> i see
05:08:15 <mreh> sort of, i wont bother asking how yet, it's a case of there being no simple examples for the material i am currently looking at
05:09:03 <mreh> so show isn't just a toString() method equiv., it also does some extra bits?
05:09:15 <mreh> function... not method
05:10:08 <vininim> mreh:
05:10:09 <vininim> > 1
05:10:11 <lambdabot>   1
05:10:22 <quicksilver> @remember NeilBrown I heard that if you chant "I don't think this can be done in Haskell" three times in front of a text editor, Don Stewart appears and implements it in one line...
05:10:22 <lambdabot> It is forever etched in my memory.
05:11:33 <ivanm> quicksilver: where was that again?
05:11:50 <vininim> mreh: the interpreter expects an expression derives typeclass Show, and then beside turning the expression into a string it performs output.
05:12:08 <vininim> *deriving
05:12:16 <quicksilver> ivanm: in the cafe
05:12:22 <ivanm> that's right...
05:12:42 <quicksilver> mreh: it's much like toString, yes.
05:12:56 <quicksilver> mreh: specifically, though it's, intended to produce a haskell-like syntax.
05:13:03 <quicksilver> that you can copy-paste into a program.
05:15:45 <mreh> :t 1
05:15:46 <lambdabot> forall t. (Num t) => t
05:16:26 <mreh> can I get class information?
05:16:50 <quicksilver> mreh: type ":i Num" into GHCi
05:16:56 <ski> @src Traversable
05:16:56 <lambdabot> class (Functor t, Foldable t) => Traversable t where
05:16:56 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
05:16:56 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
05:16:56 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
05:16:56 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
05:17:02 <mreh> :i Num
05:17:06 <mreh> :(
05:17:07 <quicksilver> mreh: this is not ghci.
05:17:10 <mreh> :D
05:31:14 <Philonous1> I wonder: Is breadth first search a good (canonic) example for the use of a continuation monad?
05:38:13 * ordnungswidrig fights the random class
05:38:27 <Phyx-> Berengal: it was easier to change than i expected, thanks for the help
05:38:45 <ski> (Philonous : are you looking at some example ?)
05:40:25 <ordnungswidrig>  let hexString x = take x (let hexDigit n = "0123456789abcdef" !! n in hexDigit <$> randomRs (0,15) (mkStdGen 1))
05:40:37 <ordnungswidrig> hexString :: Int -> [Char]
05:41:04 <ordnungswidrig> how can I replace mktStdGen 1 with, say getStdGen so that hexString is :: Int -> IO [Char] ?
05:41:32 <vininim> :t mkStdGen
05:41:33 <lambdabot> Int -> StdGen
05:41:40 <ivanm> @type getStdGen
05:41:40 <ski> @type getStdGen
05:41:41 <lambdabot> IO StdGen
05:41:42 <lambdabot> IO StdGen
05:41:49 <ivanm> @type sequence
05:41:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:42:10 <vininim> > getStdGen >>= randomRs (0,15)
05:42:11 <lambdabot>   Couldn't match expected type `IO b' against inferred type `[t]'
05:42:23 <ivanm> (randomR (0,15) =<< getStdGen) <-- do this n times
05:42:24 <ski> hexString x = liftM (\rgen -> take x (let hexDigit n = "0123456789abcdef" !! n in hexDigit <$> randomRs (0,15) rgen)) getStdGen
05:42:39 <ski>  -- massaged further as needed
05:42:44 <vininim> > getStdGen >>= (randomRs (0,15))
05:42:45 <lambdabot>   Couldn't match expected type `IO b' against inferred type `[t]'
05:43:02 <ski> @type randomRs
05:43:03 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
05:43:18 <ordnungswidrig> ski: hmm
05:43:28 <ordnungswidrig> when I run this from ghci the random gen is still the same...
05:44:09 <ski> @hoogle StdGen
05:44:10 <lambdabot> System.Random data StdGen
05:44:10 <lambdabot> System.Random getStdGen :: IO StdGen
05:44:10 <lambdabot> System.Random mkStdGen :: Int -> StdGen
05:44:13 <ordnungswidrig> will I have to wrap all this in a state monad?
05:44:14 <ski> @hoogle+
05:44:15 <lambdabot> System.Random newStdGen :: IO StdGen
05:44:15 <lambdabot> System.Random setStdGen :: StdGen -> IO ()
05:44:20 <Philonous> ski: No, it was actually just a snapshot. I thought about how you walk down the tree, save the state for later and continue at another branch. The idea is not at all rigorous.
05:44:44 <Philonous> And I just thought of a much easier way.
05:44:54 <ski> Philonous : it might work out well .. but i suspect it will be easier with composable continuations
05:45:03 <ski> Philonous : using list monad ?
05:45:07 <Philonous> Yes
05:45:09 * Phyx- is happy and loves haskell again
05:45:34 <vininim> > getStdGen >>= return.randomRs (0,15)
05:45:35 <lambdabot>   <IO [Integer]>
05:45:39 <ski> ordnungswidrig : yes, `getStdGen' only gets the global generator, it does not split it
05:45:53 <ski> ordnungswidrig : try `newStdGen'
05:46:07 <vininim> maybe IO from random should be whitelisted =P
05:46:08 <ordnungswidrig> ski: better that is
05:46:41 <ski> Philonous : care to show the code ? :)
05:46:52 * ordnungswidrig wonders if there is a more compact expression than: 
05:46:52 <ordnungswidrig>  let hexString x = liftM (\rgen -> take x (let hexDigit n = "0123456789abcdef" !! n in hexDigit <$> randomRs (0,15) rgen)) newStdGen
05:47:01 <Philonous> I didn't write any, yet.
05:47:10 <quicksilver> ordnungswidrig: intToDigit
05:47:15 <quicksilver> > intToDigit 11
05:47:16 <lambdabot>   'b'
05:47:19 <Philonous> At least not concerning the traversel
05:48:04 * ski tries to remember how to compute the elements of the Stern-Brocot tree ..
05:48:46 <ski> (istr one could do it directly on the numbers .. but maybe then it won't get ordered ?)
06:01:15 <eden_> I'm still having massive difficulties using a parsec stream I've defined. It's initial definition is "instance Stream s m Char => Stream (GenSourcePosStream s m) m (SourcePos, Char) where ..." The typechecker demands I add an instance for (Stream [Char] Identity Char) whenever I try using it. How do I go about doing this?
06:01:49 <solistic> Is anybody aware of an existing library function that can escape strings for use as part of an url? For example: urlquote "foo bar" == "foo%20bar".
06:03:57 <eden_> I've defined it like this, so I can (possibly) drop in a ByteString instead of [Char] later on, without having to modify too much.
06:04:04 <ivanm> solistic: probably just look through the web section on hackage
06:04:30 * pumpkin_ yawns
06:05:03 <ivanm> @time pumpkin_
06:05:04 <lambdabot> Local time for pumpkin_ is 2009-05-08 09:05:03 -0400
06:05:15 <ivanm> pumpkin_: I take it you haven't slept all night?
06:05:22 <pumpkin_> oh, I did sleep, just not enough
06:05:28 <pumpkin_> :)
06:05:38 <quicksilver> pumpkins never sleep, they just snuff their candles for a bit
06:05:44 <pumpkin_> not sure anything would ever be enough though
06:05:48 <pumpkin_> so that might be a tautology
06:06:51 <vininim> oh my, octave is slow.
06:06:58 <vininim> err wrong channel
06:07:24 <ordnungswidrig> vininim: is c++ not haskell :-)
06:08:37 <vininim> I thought about using hmatrix but it didn't have sparse matrices (and then I realized I didn't need it)
06:08:51 <solistic> ivanm, that is what i did, but it turned out to be the wrong place to go for. Just dicovered Network.URI (part of "base"). I think that should work.
06:09:15 <pumpkin_> I'd like to have a nice pure sparse matrix lib for haskell that had a really elegant API :P
06:09:35 <quicksilver> pumpkin: and a pony!
06:09:38 <ivanm> vininim: aren't sparse matrices only good in terms of saving memory?
06:09:39 <vininim> pumpkin_: with monad ponies too!
06:09:56 <pumpkin_> quicksilver: of course! the pony was for my benefit originally, surely it's still mine?
06:10:02 <ivanm> pumpkin_: s/sparse matrix lib/matrix lib with sparse matrix support/
06:10:04 <ivanm> ;-)
06:10:10 <pumpkin_> ivanm: sure ;)
06:10:19 <ivanm> let's generalize! ;-)
06:10:47 <quicksilver> ivanm: they're also faster to calculate with
06:10:49 <vininim> ivanm: yes, but that's the point
06:10:52 <quicksilver> for certain kinds of calculations.
06:11:03 <ivanm> quicksilver: only because there's less values to worry about?
06:11:12 <pumpkin_> *fewer
06:11:20 <eden_> Oh well. I guess I give up and just provide inaccurate error message positions...
06:11:20 <quicksilver> well yes.
06:11:23 <quicksilver> "only" ;)
06:11:23 <ivanm> pumpkin_: less, fewer, same diff
06:11:25 <pumpkin_> if you're gonna be pedantic, I might as well be too :P
06:11:40 <ivanm> quicksilver: I meant that there's nothing intrinsically more efficient about them
06:11:51 <igel> how can i tell ghc *not* to ignore asserts and still use -On?
06:11:54 <vininim> ivanm: when you have lots of 0's, it is by definition =P
06:11:54 * quicksilver wonders if saying "less, fewer, same diff" is a 12-hour bannable offence
06:11:59 <quicksilver> int-e: I'm not really following you.
06:12:00 <pumpkin_> lol
06:12:00 <ivanm> just that if you know there's lots of zeros, you can ignore a lot of calculations
06:12:00 <igel> i only find -fignoreasserts
06:12:05 <quicksilver> int-e: mis, sorry.
06:12:09 <ivanm> quicksilver: :o
06:12:22 <quicksilver> ivanm: they are more efficient to store and more efficient to calculate with.
06:12:36 <quicksilver> ivanm: what do you mean by "there is nothing intrinsically more efficient", then?
06:12:38 <pumpkin_> I wonder if the new annotations BSP added to GHC could be used to have some sort of tie-in with theorem provers
06:12:42 <quicksilver> those two things seem pretty important to me.
06:13:29 <ivanm> quicksilver: it's not that there's better algorithms or anything that work specifically if you have the number of entries being less than 1/6 of the maximum available or anything
06:14:05 <pumpkin_> well, it's about knowing beforehand that you have asymptotically fewer than rows*columns nonzero entries
06:14:23 <quicksilver> ivanm: "Results 1 - 10 of about 325,000 for algorithms for sparse matrices"
06:14:35 <quicksilver> ivanm: Yes. There are algorithms that work specifically better.
06:14:43 <pumpkin_> so you write algorithms that works in O(# of nonzero entries) rather than O(rowcount * colcount)
06:14:45 <ivanm> OK
06:14:46 <quicksilver> and entire subculture of mathematics is devoted to studying them.
06:14:53 <quicksilver> I find it pretty dull, myself.
06:14:59 <quicksilver> But some people think it's better than pecan pie!
06:15:08 <tombee> i probably agree with them
06:15:08 <tombee> :P
06:15:09 <quicksilver> mmm, peca pie.
06:15:20 <ivanm> s/pecan/apricot/
06:15:22 <ivanm> ;-)
06:19:00 <ivanm> http://en.wikipedia.org/wiki/Monadology <-- unfortunately, this in no way seems to be a predecessor of the typeclassopedia or a similar type of work :(
06:21:07 <ordnungswidrig> I have a Constructor D String  and a value IO String how to I lift the constructor into to IO monad?
06:21:19 <ordnungswidrig> ...to apply the value IO Stirng on it?
06:21:20 <tibbe> could some please help me with this type error: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4723#a4723
06:21:27 <tibbe> I think I need a type annotation somewhere
06:22:35 <quicksilver> ordnungswidrig: liftM D (thingy)
06:22:45 <quicksilver> ordnungswidrig: or equivalent D <$> thingy
06:22:57 <quicksilver> where <$> from Control.Applicative is fmap, which is the same as liftM
06:24:00 <ordnungswidrig> quicksilver: that works. but only for one level of constructor
06:24:02 <ski>   D `liftM` thingy  -- also
06:24:15 <quicksilver> ordnungswidrig: which is what you asked about.
06:24:30 <quicksilver> ordnungswidrig: (D . E) <$> thingy
06:24:36 <quicksilver> will work for two nested constructors
06:24:40 <quicksilver> I'm not sure what you need though.
06:24:43 <tibbe> anyone?
06:25:47 <ivanm> tibbe: are the line numbers in the paste right?
06:25:59 <Feuerbach> tibbe: skip (n - len) gives Stream (), but should be Stream r
06:26:10 <Feuerbach> (line 28)
06:26:18 <tibbe> ivanm: yes
06:26:44 <ivanm> eh, looks like Feuerbach knows what he's talking about :p
06:26:58 <tibbe> Feuerbach: I'm not sure if I understand
06:27:16 <tibbe> Feuerbach: the return type of skip should be Stream ()
06:27:33 <Feuerbach> yes, but function inside it should be polymorphic on r
06:27:58 <Feuerbach> it should yield Result r independently of Stream argument "a"
06:28:21 <Feuerbach> but on line 28 you return something of Result ()
06:28:56 <tibbe> Feuerbach: I don't see an obvious way to make it correct
06:29:10 <ivanm> tibbe: you probably can't
06:29:17 <ivanm> unless you make skip return Result r
06:29:32 <tibbe> ivanm: I have a very similar definition somewhere else
06:29:33 <tibbe> one sec
06:29:39 <tibbe> http://github.com/tibbe/hyena/blob/c981126f941ced0827dcef7eedff45842cd5bd91/Hyena/Parser.hs
06:29:46 <tibbe> I can't see the difference between the two
06:32:25 <ski> ivanm's `Result' includes a `Stream'. tibbe's doesn't
06:32:32 <eden_> I backed off from my general solution, and things have begun working properly. It'll be annoying when I want to use ByteStrings, but...
06:32:40 <Feuerbach> what's analog of skip there?
06:33:00 <ski> (um, actually tibbe pasted both links .. i confused persons)
06:33:13 <tibbe> ski: :)
06:33:27 <tibbe> ski: I have a definition that works, I'm trying to CPS it
06:33:35 <ski> so, the one in the paste recurs to `Stream' from `Result'
06:33:42 <ski> the other one doesn't
06:33:54 <tibbe> right
06:34:54 <ski> i would assume with a type like `Stream', the corresponding code would already be written in CPS
06:35:17 <tibbe> ski: let me give you the code I'm trying to CPS
06:35:44 * ski can't wait to sell it on the black market
06:38:22 <tibbe> ski: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4723#a4724
06:39:14 <tibbe> ski: my code might not make sense, I was playing around a bit
06:39:29 <tibbe> ski: if you look at the two lines I just paste it's basically a state monad mixed with cont
06:40:50 <ordnungswidrig> I have a constructor R a b and a value x = IO a. I lifted the constructor but had to flip it before:
06:41:09 <ordnungswidrig> liftM ((flip R) "xxx") x
06:41:51 <ordnungswidrig> how does this generalize when I have a function f a b c d e and value for any of the arguments, say "b", in a Monad, e.g. IO b ?
06:44:30 <tibbe> ski: is that even possible?
06:44:40 <Philonous> > let foo = 1: concatMap ( const []) foo in foo
06:44:42 <lambdabot>   [1* Exception: stack overflow
06:47:53 <ski> @unmtl ContT o (State s) a
06:47:53 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
06:48:57 <ski> newtype Stream a = Stream { unStream :: String -> Result a }
06:48:59 <ski> ER
06:51:33 <Phyx-> is there a standard function such as this
06:51:34 <Phyx-> (a->c) -> (a,b) -> (c,b)
06:51:34 <ski> tibbe : i'm not quite sure what you mean by "try to CPS", here ..
06:51:35 <Phyx-> ?
06:52:08 <ski> @type (*** id)
06:52:10 <lambdabot> forall b c a. (b -> c) -> (b, a) -> (c, a)
06:52:22 <ski> @index ***
06:52:23 <lambdabot> Control.Arrow
06:52:27 <Phyx-> ooh
06:52:29 <Phyx-> nice
06:52:31 <Phyx-> thanks
06:53:05 <ski> tibbe : do you want to CPS transform the function stored in `unStream' ?
06:53:14 <ski>   unStream :: String -> Result a
06:53:20 <gnuvince> > (+1) *** (0,0)
06:53:21 <lambdabot>   Couldn't match expected type `b' -> c''
06:53:25 <ski>   unStreamK :: String -> (Result a -> r) -> r
06:53:37 <Phyx-_> hmm
06:54:11 <ski>   unStreamK :: String -> (a -> String -> r) -> (Stream a -> r) -> r
06:54:50 <ski> so i suppose
06:55:19 <ski>   newtype StreamK r a = StreamK { unStreamK :: String -> (a -> String -> r) -> (Stream a -> r) -> r }
06:55:49 <ski> though maybe we want the same `r' everywhere, so
06:55:58 <ski>   newtype StreamK r a = StreamK { unStreamK :: String -> (a -> String -> r) -> (StreamK r a -> r) -> r }
06:56:08 <ski> and then
06:56:27 <ski>   newtype Stream a = Stream {unStream :: forall r. StreakK r a}
06:56:31 <Bacta> I've got balls of steel
06:56:42 <ski> Bacta : good for you
06:56:53 <Bacta> @
06:57:12 <Bacta> @faq can Haskell murder my wife?
06:57:13 <lambdabot> The answer is: Yes! Haskell can do that.
06:57:29 <Bacta> should be reiserbot
06:58:54 <ordnungswidrig> Monad m => (a -> b -> c) -> a -> m b -> m c
06:59:01 <ordnungswidrig> is there anything like that?
06:59:13 <idnar> @type liftM2
06:59:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:59:31 <ordnungswidrig> idnar: a != m a
06:59:32 <idnar> @type liftM2 . return
06:59:33 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a2 -> r) -> m a1 -> m a2 -> m r
06:59:40 <idnar> mmm, no
06:59:54 <vixey> :t \f a mb -> liftM (f a) mb
06:59:54 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
06:59:54 <ski> @type (liftM .)
06:59:55 <lambdabot> forall t a1 r (m :: * -> *). (Monad m) => (t -> a1 -> r) -> t -> m a1 -> m r
06:59:55 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a -> a1 -> r) -> a -> m a1 -> m r
06:59:59 <vixey> @messages
06:59:59 <lambdabot> mmorrow said 11h 18m 23s ago: that talk about dual graphs and such got me thinking.. here're two graphs and their dual (for the value of dual we were talking about) http://moonpatio.com/vacuum/
07:00:00 <lambdabot> gallery/duals.png , and here's the code that computed them http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2362#a2362 innnteresting
07:00:04 <Bacta> balls
07:00:05 <Bacta> balls
07:00:06 <Bacta> balls
07:00:06 <Bacta> balls
07:00:08 <Bacta> balls
07:00:10 <Bacta> balls of steel
07:00:10 <ordnungswidrig> i want to lift a constructor except a certain argument
07:00:14 <vixey> Bacta: ok
07:00:15 <idnar> @where ops
07:00:15 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:00:16 <lambdabot> mauke
07:00:21 <Bacta> i've got balls of steel
07:00:51 --- mode: ChanServ set +o Igloo
07:01:07 --- mode: ChanServ set +o dcoutts_
07:01:09 <vixey> Bacta: one questiont before you go
07:01:16 <vixey> Bacta: what was the point in that?
07:01:18 --- mode: Igloo set +b %*!*@unaffiliated/bacta
07:01:25 <RayNbow> http://tinyurl.com/okasaki-ch4-exercise <-- hmm, I can see extracting the first k elements of (sort xs) is O(nk) when using Selection Sort, but I don't see why it's O(nk) for Insertion Sort...
07:02:37 <Botje> RayNbow: you can constrain the list you're inserting to at most k elements
07:02:41 <jpcooper> hello
07:02:42 <Ginzor> someone know if the "fail :: String -> m a" function will typically print to stderr?
07:02:53 <jpcooper> is there any way in which I can make assertions on values in pure functions?
07:03:01 <ski> Ginzor : no
07:03:06 <Ginzor> ski: ok thanks
07:03:07 <dcoutts_> jpcooper: assert
07:03:11 <quicksilver> not per se, no
07:03:16 <quicksilver> oops scrolled up
07:03:21 <ski> Ginzor : it depends completely on the monad `m' in question
07:03:32 <Botje> RayNbow: so you start with an empty list, and just proceed as usual until your list contains k values. At that point you only alter the list if you find elements lesser than the biggest element in your list
07:03:43 <jpcooper> @hoogle assert
07:03:43 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:03:43 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
07:03:43 <lambdabot> Test.HUnit.Base class Assertable t
07:03:48 <ski> Ginzor : the default implementation of `fail' uses `error', maybe you really wanted to ask about that
07:03:52 <Peaker> what allows me to use "deriving Binary"?
07:04:01 <Botje> since you need to compare to at most k elements each time, your sort gets O(nk) complexity
07:04:03 <Ginzor> ski: yeah probably that's my question
07:04:07 <ivanm> Peaker: maybe generalizednewtypederiving?
07:04:11 <RayNbow> Botje: ah right... :)
07:04:24 <jpcooper> thanks dcoutts_
07:04:27 <Peaker> ivanm: its not a newtype
07:04:32 <ordnungswidrig> bye...
07:04:32 <Ginzor> or I'm using a Control.Monad.State monad and wanted to print errors to stderr
07:04:34 <jmcarthur> :t assert
07:04:36 <lambdabot> Not in scope: `assert'
07:04:37 <Peaker> ivanm: its an example data type: data Blah = Foo | Bar
07:04:44 <Ginzor> but it doesn't seem to do that when I use fail
07:05:07 <Botje> Ginzor: fail only prints something when it's evaluated.
07:05:11 * ski has no idea whether `error' would print to standard error (it would seem reasonable, i suppose)
07:05:18 <ivanm> Peaker: I dont' think Binary is one of the ones that the report says you can get for free...
07:05:23 <jmcarthur> :t Control.Exception.assert
07:05:25 <lambdabot> forall a. Bool -> a -> a
07:05:34 <jmcarthur> @src Control.Exception.assert
07:05:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:05:41 <Peaker> ivanm: not the report, but other deriving scripts
07:06:09 <Botje> Ginzor: if you want errors to be non-fatal, you could use WriterT State
07:06:09 <vininim> awesome, 72% Q1 on train data!!11 (lol cross validation will suck)
07:06:11 <quicksilver> Peaker: Data.Derive
07:06:19 <ivanm> well, the generalized extension is the only one I've heard of that can add extra "deriving ..." statements than what the report says...
07:06:26 <Botje> or ErrorT State if you want fatal errors
07:06:51 <dan> Peaker: Hello
07:07:08 <Ginzor> Botje: yeah, right now I use a monad transformer with IO, liftIO $ hPutStr stderr. I guess it makes the job done
07:07:08 <Peaker> dan: hey
07:07:15 <Botje> that works too :]
07:07:45 <dan> :t compare
07:07:46 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:07:47 <Peaker> quicksilver: thanks
07:07:58 <dan> :info compare
07:08:27 <dan> :info Ord
07:08:37 <Peaker> quicksilver: cabal install derive -- import Data.Derive should be enough?
07:08:45 <ski> @vixen Are you GHCi?
07:08:45 <lambdabot> let me answer that later, okay?
07:09:03 <quicksilver> Peaker: no.
07:09:11 <quicksilver> Peaker: how could that possibly work? ;)
07:09:24 <Peaker> quicksilver: TH? :)
07:09:24 <quicksilver> Peaker: how could an 'import' declaration add a new kind of deriving?
07:09:27 <quicksilver> read the docs.
07:09:33 <Peaker> quicksilver: I don't know how TH magic works. will do, thanks :)
07:13:03 <mm_freak_> dons: today i've tried the haskell platform with windows XP at work
07:13:10 <mm_freak_> so far it works well
07:13:54 <mm_freak_> i've yet to find a useful development environment, though…  i'll try eclipse next week
07:14:49 <RayNbow> EclipseFP is not very useful imo (at least the version I'm using... not sure if it's been updated in the meantime)
07:15:10 <Phyx-> @index unless
07:15:10 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:15:11 * RayNbow currently uses ghci and Notepad to write small Haskell applications :X
07:15:37 <Phyx-> :t unless
07:15:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:15:43 <Phyx-> ah
07:22:31 <mm_freak_> RayNbow: i'll try nevertheless
07:22:57 <mm_freak_> since i'm using visual studio at work, visual haskell sounds interesting, but it works only with 2003 and 2005
07:23:16 <mm_freak_> notepad++ is quite useless, too
07:24:24 <quicksilver> visual haskell is bitrotted too.
07:24:28 <quicksilver> IMO emacs is the best option.
07:25:00 <jdkoeck> hi
07:25:12 <Feuerbach> How to tell "cabal install" to rebuild? (I'm using cabal install as a replacement for runhaskell Setup ...)
07:25:41 <dcoutts_> --rebuild
07:25:56 <dcoutts_> sorry, no --reinstall
07:26:22 <Feuerbach> --reinstall has no effect
07:26:30 <dcoutts_> Feuerbach: if you're using it as a replacement for runhaskell Setup, then that's fine. It provides all the same commands as runhaskell Setup
07:27:00 <Feuerbach> all right, then I can do cabal clean :)
07:27:02 <Axman6> Feuerbach: cabal install --reinstall <package>
07:27:36 <dcoutts_> Axman6: he's using it for a local package
07:27:49 <Axman6> oh, missed that
07:27:59 <dcoutts_> Feuerbach: btw, see cabal --help
07:28:06 <dcoutts_> Axman6: so did I at first :-)
07:29:02 <Axman6> i hate oit when i do that. really must learn to read the whole question before asking that. so many times i've said "do X" and then i read it and they said "i tried X and Y and..." and i look like an idiot -_-
07:29:09 * Axman6 blames sleep deprivation
07:29:17 * quicksilver blames canada.
07:29:20 <ivanm> Axman6: good excuse
07:29:35 <ivanm> Axman6: can't forget the coriolis effect, either...
07:29:37 <jdkoeck> Question : how do I modify several arrays ? I would probably have to use STArray and some monad transformer magic, but I don't know how...
07:29:47 <ivanm> after all, our toilets flush the opposite way down here... :p
07:29:51 <Axman6> heh
07:30:38 <Feuerbach> dcoutts_: I did! :) I was looking for --rebuild or --reinstall, but first doesn't exist and second doesn't DWIM
07:31:40 <frwmanners> jdkoeck: how does your collection of arrays manifest itself?
07:32:44 <jdkoeck> frwmanners: I'm trying to implement the prim algorithm
07:33:20 <jdkoeck> frwmanners: I use several arrays to keep track of relations between vertices
07:33:37 <byorgey> jdkoeck: I don't see why modifying several arrays would be any harder than modifying one...?
07:33:44 <jdkoeck> frwmanners: I have three arrays : close, dist and in_tree
07:34:05 <byorgey> or are you just wondering how to use mutable arrays, period?
07:34:14 <jdkoeck> frwmanners: I know how to use STArray, but it's about modifying only one array
07:34:43 <frwmanners> jdkoeck: it's about making modifications within the ST monad
07:35:05 <byorgey> you can have multiple STArrays within the same ST computation.
07:35:44 <frwmanners> jdkoeck: do a <- newArray ...; b <- newArray ...; writeArray a ...; writeArray b ... &c.
07:35:44 <jdkoeck> byorgey: Yes, that's what I want to do
07:36:53 <jdkoeck> frwmanners: Duh, it's as simple as that? I feel really stupid now.
07:37:03 <jdkoeck> frwmanners: Thank you :)
07:37:09 <byorgey> heh =)
07:37:15 <byorgey> no need to feel stupid, jdkoeck
07:37:19 <byorgey> we've all been there =)
07:37:33 <jdkoeck> thanks byorgey :)
07:38:56 <Feuerbach> I just realized that cabal install for local packages does very smart rebuild. If I rebuild one package, packages that depend on it aren't rebuilt completely, but only modules that use that package are rebuilt
07:38:56 <ski> @type Data.Array.ST.runSTArray
07:38:57 <lambdabot> forall i e. (Ix i) => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
07:39:49 * ski mutters something about there ought to be a nice way of constructing several arrays that way ..
07:42:02 <frwmanners> ski: forall i e. (Ix i) => (forall s. ST s [STArray s i e]) -> [Array i e] ?
07:42:40 <Axman6> map runSTArray . runST
07:42:46 <Axman6> :t map runSTArray . runST
07:42:47 <lambdabot> Not in scope: `runSTArray'
07:42:50 <Axman6> bah
07:42:56 <jdkoeck> btw, i'm using matrices like this : type Matrix elem = Array Int (UArray Int elem)
07:43:13 <mreh> @src (.)
07:43:13 <lambdabot> (f . g) x = f (g x)
07:43:21 <jdkoeck> Is there a better way to do it ? Simple matrix library, perhaps ?
07:43:32 <mreh> why cant (.) be written = f g
07:43:59 <NEEDMOAR> ?
07:44:01 <mreh> obviously it cant
07:44:09 <frwmanners> Axman6: runSTArray takes from inside an ST already, I think
07:44:10 <ziman> because "f g" is f *applied* to g
07:44:32 <mreh> i get it
07:44:49 <mreh> f g x = (f g) x
07:45:01 <quicksilver> jdkoeck: there are several matrix libraries, yes.
07:45:07 <quicksilver> jdkoeck: alternatively Data.Map
07:45:09 <Axman6> works for things like map, but doesn't do the same thing
07:45:09 <quicksilver> or Data.IntMap
07:45:14 <ziman> yes, fucntion application is left-associative
07:49:08 <ski> frwmanners : obviously we should be able to construct differently typed arrays
07:49:41 <ski> @type map Data.Array.ST.runSTArray . runST
07:49:42 <lambdabot>     Cannot match a monotype with `[forall s.
07:49:42 <lambdabot>                                    ST s (GHC.Arr.STArray s i e)]'
07:49:42 <lambdabot>       Expected type: (forall s. ST s a)
07:50:09 <mreh> in ghci, the numbers associated with precedence, is 0 lowest, not highest like in other languages
07:50:33 <ski> 0 is the weakest precedence, yes
07:50:47 <ski> (and that's in Haskell, not just GHCi)
07:50:58 <mreh> i like to think of precedence as stickiness
07:52:09 <ski> so you could say that `*' has stronger stickines (precedence) than `+' ..
07:52:34 <mreh> and if they are just as sticky, you fall back up the laws of associativity
07:52:42 <mreh> s/up/upon/
07:55:22 * ski would prefer to not specify which way to associate (except maybe as implementation detail) for truly associative operators
07:55:43 <mreh> dont understand that
07:56:39 <frwmanners> ski: true; but I suppose if we actually want to do anything with them we're down to returning a massive tuple
07:56:51 <mreh> let fac n = foldr (*) 0 [1..n] in fac 3
07:57:00 <mreh> >  let fac n = foldr (*) 0 [1..n] in fac 3
07:57:01 <lambdabot>   0
07:57:08 <mreh> >  let fac n = foldr (*) 1 [1..n] in fac 3
07:57:09 <lambdabot>   6
07:57:29 <frwmanners> ski: which we get by doing a load of freezes on all the mutable arrays in question, then runST on the whole lot
07:57:37 <ski> frwmanners : it might be nice if there could be a useful class abstraction for this
07:58:18 <ski> (for optimal performance we'd need the unsafe freeze .. i was wanting to avoid having to check the uses were actually safe each time)
07:58:34 <ski> (s/check/manually check/)
08:00:43 <telemachus> Anyone have a guess why compilation of ghc-6.10.2 on a Mac (Intel iMac) keeps bailing out with this error: "ld: in /Users/hektor/sources/ghc-6.10.2/libraries/Cabal/dist-bootstrapping/build/libHSCabal-1.6.0.3.a, archive has no table of contents"?
08:00:50 <frwmanners> ski: difficulty seeing how you could do that if you want to return arbitrarily many specific types
08:01:32 <dcoutts_> ski: you can return multiple arrays, just use freeze and runST
08:02:01 <dcoutts_> ski: the only thing you loose is some efficiency since freeze must copy, unless you use unsafeFreeze
08:02:35 <dcoutts_> telemachus: yep, though I didn't know it affected ghc
08:03:02 <telemachus> dcoutts: do tell
08:03:14 <telemachus> (or rather, what did you think it affected?)
08:03:49 <dcoutts_> telemachus: it's the same as this problem: http://trac.haskell.org/haskell-platform/ticket/34
08:04:22 <telemachus> dcoutts_: thanks for the pointer (I had Googled without luck)
08:04:45 <dcoutts_> telemachus: the general issue is described in the Cabal trac http://hackage.haskell.org/trac/hackage/ticket/318
08:04:56 <telemachus> dcoutts_: and actually, building Haskell platform is my _real_ goal
08:05:13 <dcoutts_> telemachus: I presume you're using OS X 10.5.something right?
08:05:21 <telemachus> dcoutts_: yup
08:05:31 <telemachus> 10.5.6
08:05:39 <telemachus> (all good on my Debian box, all bad here)
08:05:40 <dcoutts_> telemachus: if you could note the version on one of those tickets, that'd be handy. It was not a problem in older OS X versions.
08:05:59 <telemachus> dcoutts_: will do
08:06:08 <roconnor> @quote Lamport
08:06:09 <lambdabot> Lamport says: Programmers will find any excuse to dismiss an approach that would require them to learn something new.
08:06:38 <mreh> what's the name of that tree you can implement as a list, where the nth element is in the (2n + 1)th position
08:06:59 <Axman6> binary tree?
08:07:18 <mreh> it is a binary tree also
08:07:19 <telemachus> dcoutts_: it looks like I can manually fix this with ranlib, perhaps. Time for me to learn a new tool...
08:07:19 <Axman6> pretty sure that's it
08:07:30 <mreh> minimum spanning tree
08:07:34 <dcoutts_> telemachus: yes
08:07:34 <mreh> that's the one
08:08:35 <telemachus> dcoutts_: ok, cool, am I safe in assuming that I need to run ranlib on the item that ld is complaining about? Or is the problem earlier?
08:09:12 <dcoutts_> telemachus: yup
08:09:47 <telemachus> (or apparently remove -q from the call to ar...)
08:09:58 <telemachus> dcoutts_: thanks for the help
08:10:30 <dcoutts_> telemachus: if you feel like writing a patch... :-)
08:11:07 <tombee> Having such a difficult time trying to apply haskell to a project, perhaps I need to start with a smaller more pointless project :P
08:11:15 <tombee> than my already small and pointless project, heh.
08:11:38 <telemachus> dcoutts_: A patch to the configure or Make file, you mean? (Sorry, not clear on what I would be patching...)
08:12:00 <dcoutts_> telemachus: it's the Cabal library that is calling ar with -q and not -s
08:12:10 <dcoutts_> telemachus: so it'd be a patch to the Cabal library
08:12:19 <trofi> @undo \f xs1 xs2 -> [f x1 x2 | x1 <- xs1, x2 <- xs2]
08:12:19 <lambdabot> \ f xs1 xs2 -> concatMap (\ x1 -> concatMap (\ x2 -> [f x1 x2]) xs2) xs1
08:12:40 <trofi> @undo \f [xs1, xs2, xs3] -> [f x1 x2 | x1 <- xs1, x2 <- xs2, x3 <- xs3]
08:12:40 <lambdabot> \ f [xs1, xs2, xs3] -> concatMap (\ x1 -> concatMap (\ x2 -> concatMap (\ x3 -> [f x1 x2]) xs3) xs2) xs1
08:12:51 <telemachus> dcoutts_: ah, k, well it sounds like the problem is known but the devs can't decide on the best solution
08:13:14 <telemachus> dcoutts_: ar -s being significantly slower than ar -q (if I followed the discussion on one of the tickets you linked)
08:13:21 <dcoutts_> telemachus: no, the solution is now clear, it's just a matter of doing
08:13:34 <dcoutts_> telemachus: yes, we were worried about that at first
08:14:17 <telemachus> dcoutts_: well, I'm actually off to teach some 9th graders English, but I'd be happy to write a patch later today (if that's really all it would take)
08:14:34 <dcoutts_> telemachus: :-) have fun
08:14:57 <telemachus> dcoutts_: thanks and thanks for the pointers to the solution
08:15:02 <dcoutts_> np
08:25:03 <mreh> could I do filter with fold?
08:25:20 <mreh> dont tell me how if you can
08:26:22 <Saizan_> yes, with foldr
08:27:03 <pumpkin_> you could do it with either fold couldn't you? it's just more efficient one way
08:27:22 <mreh> you can simulate foldr with foldl
08:27:25 <mreh> so yes
08:27:38 <Saizan_> for infinite lists you can't
08:27:43 <vixey> mreh:  foldr (\x ys -> ___) []
08:27:54 <vixey> ys is the processed rest of the list,  x is the new element to process
08:27:55 <Phyx-> Saizan_: but then filter wouldn't work either
08:28:04 <Saizan_> Phyx-: how not?
08:28:10 <Saizan_> > filter odd [1..]
08:28:12 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
08:28:13 <Phyx-> or rather, i mean, not terminate either
08:28:16 <vixey> and  foldr (\x ys -> x:ys) [] is id
08:28:20 <Jig> > let foldright f initial xs = foldl (\a b -> f b a) initial xs in foldright (+) 0 [1..5]
08:28:21 <lambdabot>   15
08:28:27 <Jig> > let foldright f initial xs = foldl (\a b -> f b a) initial xs in foldright (-) 0 [1..5]
08:28:28 <Saizan_> Phyx-: yeah, but with foldl you won't get any result
08:28:28 <lambdabot>   3
08:28:35 <Phyx-> Saizan_: true
08:28:35 <Jig> > foldr (-) 0 [1..5]
08:28:37 <lambdabot>   3
08:29:46 <tchakka> Does anyone here have experience with the gtksourceview2 package in gtk2hs?
08:30:05 <tchakka> I can't get it to see .lang files, not even the demo program runs well: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4725#a4725
08:30:26 <jdkoeck> \q
08:31:22 <Phyx-> tchakka: never got it to work either
08:31:23 <Jig> can you simulate foldl with foldr?
08:31:34 <hamishmack> tchakka: try something like export XDG_DATA_DIRS=/opt/local/share
08:31:50 <Saizan_> Jig: yes
08:32:13 <Jig> > let foldleft f i xs = foldr (a b -> f b a) i xs in foldleft (+) 0 [1..5]
08:32:14 <lambdabot>   <no location info>: parse error on input `->'
08:32:22 <Jig> > let foldleft f i xs = foldr (\a b -> f b a) i xs in foldleft (+) 0 [1..5]
08:32:23 <lambdabot>   15
08:32:26 <Jig> > let foldleft f i xs = foldr (\a b -> f b a) i xs in foldleft (-) 0 [1..5]
08:32:28 <lambdabot>   -15
08:32:31 <Jig> ok
08:32:40 <Jig> but what about laziness?
08:33:08 <Saizan_> the foldright you write with foldl can't be as lazy as the real foldr
08:33:20 <mreh> let reverse = foldr (:) [] in reverse [1..10]
08:33:21 <tchakka> Nope, no luck, hamishmack (I take it I have to change /opt/local/share to some directory in which gtksourceview-2.0/language-specs exists?)
08:33:29 <mreh> > let reverse = foldr (:) [] in reverse [1..10]
08:33:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:33:50 <tchakka> I do see the entry in my ~ show up twice, though.
08:34:46 <Saizan_> > let foldleft f i xs = foldr (\a b -> f b a) i xs in foldleft f z [1..5]
08:34:48 <lambdabot>   f (f (f (f (f z 5) 4) 3) 2) 1
08:34:56 <Saizan_> > foldl f z [1..5]
08:34:57 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
08:35:00 <hamishmack> tchakka: it should point to where gtksourceview2 was installed
08:35:10 <hamishmack> what OS are you using?
08:35:12 <mreh> > let reverse = foldr (\ a b (b : a) [] in reverse [1..10]
08:35:13 <lambdabot>   <no location info>: parse error on input `in'
08:35:20 <mreh> > let reverse = foldr (\ a b (b : a)) [] in reverse [1..10]
08:35:21 <Saizan_> Jig: not quite the same, btw ^^^
08:35:21 <lambdabot>   <no location info>: parse error on input `)'
08:35:28 <Jig> let reverse = foldr (flip (:)) [] in reverse [1..10]
08:35:33 <mreh> > let reverse = foldr (\ a b -> (b : a)) [] in reverse [1..10]
08:35:35 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
08:35:35 <lambdabot>        Expect...
08:35:37 <Jig> > let reverse = foldr (flip (:)) [] in reverse [1..10]
08:35:38 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
08:35:38 <lambdabot>        Expect...
08:35:44 <tchakka> hamishmack: Fedora 10, lemme check where it's installed to.
08:35:45 <pumpkin_> lol
08:36:17 * mreh brane aspoldes
08:37:07 <mreh> Haskell is more fun than paying my bills
08:37:16 * leadnose nods silently
08:37:17 <tchakka> hamishmack: Pointed it at /usr/share, but doesn't work either.
08:37:42 <Saizan_> > let myfoldl f z xs = foldr (\x rec a -> rec $ f a x) id xs z in myfoldl f z [1..3]
08:37:43 <lambdabot>   f (f (f z 1) 2) 3
08:37:57 <Saizan_> > let myfoldl f z xs = foldr (\x rec a -> rec $ f a x) id xs z in myfoldl (flip (:)) [] [1..3]
08:37:58 <lambdabot>   [3,2,1]
08:38:11 <Jig> > foldr (flip (:)) [1..10]
08:38:11 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
08:38:12 <lambdabot>        Expect...
08:38:15 <Jig> > foldr (flip . (:)) [1..10]
08:38:16 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
08:38:22 <Jig> > foldr (:) [] [1..10]
08:38:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:38:29 <Jig> > foldr (flip (:)) [] [1..10]
08:38:29 <pumpkin_> it's harder than that
08:38:30 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
08:38:30 <lambdabot>        Expect...
08:38:44 <Jig> > foldl (flip (:)) [] [1..10]
08:38:45 <hamishmack> tchakka: did you install gtksourceview2 from a rpm or from source?
08:38:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
08:38:48 <Jig> ah
08:38:57 <Jig> > foldr (:) [] [1..10]
08:38:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:39:09 <Jig> can i reverse with foldr?
08:39:21 <mreh> why would you want to
08:39:22 <tchakka> From an RPM.
08:39:38 <Jig> just to be sexy
08:39:43 <pumpkin_> > foldr (\x y -> y ++ [x]) [] [1..5]
08:39:44 <lambdabot>   [5,4,3,2,1]
08:39:49 <pumpkin_> it's inefficient though
08:39:52 <mreh> heh
08:42:18 <Saizan_> > foldr (\x ys -> ys . (x:)) id [1..5]
08:42:19 <lambdabot>       Overlapping instances for Show ([a] -> [a])
08:42:19 <lambdabot>        arising from a use o...
08:42:24 <Saizan_> > foldr (\x ys -> ys . (x:)) id [1..5] []
08:42:26 <lambdabot>   [5,4,3,2,1]
08:42:36 <pumpkin_> that's pretty
08:43:46 <mreh> he's using foldr to simulate foldl
08:44:00 <pumpkin_> yup, still pretty
08:44:23 <mm_freak> quicksilver: i'm using emacs in linux for almost anything that involves plaintext editing
08:44:50 <mreh> is the number of brane asplodes proportional to haskell understanding?
08:45:24 <Saizan_> yup
08:47:52 <jmcarthur> yes, asplodes = understanding
08:47:59 <mikm> See, this is why I like Haskell/functional languages.  It makes you think.
08:48:10 <jmcarthur> it makes you _realize_ ;)
08:48:44 <mikm> It hurts your head for a while, but once you grok it, it becomes fun puzzle solving
08:48:51 <mikm> Or so I imagine
08:49:55 <Lemmih> mikm: Where did you learn the word 'grok', OOI?
08:50:03 <jmcarthur> it actually becomes regular programming once you have it down, believe it or not. but by that time other languages are just primitive programming
08:50:24 <mreh> highest level programming
08:50:33 <mikm> Lemmih: I forget where I picked it up.
08:50:49 <mreh> grok is just one of those memes
08:51:02 <mreh> like foo a = bar a and all that
08:51:05 <sgcummin> no
08:51:10 <sgcummin> it's from stranger in a strange land
08:51:15 <eek> mikm: it's from "Stranger in a Strange Land" by Robert Heinlein
08:51:38 <mreh> like Quarks? they're from a poem
08:52:03 <applicative_kid> i wouldn't quite put it has a highest
08:52:40 <vixey> jmcarthur: I don't really feel that wway
08:52:52 <mreh> applicative_kid: as far as we know
08:53:18 <applicative_kid> what do you mean as we know? you can higher
08:53:33 <mreh> like what
08:53:42 <applicative_kid> you think it stops at functional?
08:53:48 <Phyx-> anyone else get the feeling that the compiler is teasing you at times? lol
08:53:49 <Lemmih> I find it intesting that most people who use the word 'grok' have never heard of Robert A. Heinlein. Even more interesting is that the word is almost exclusively used in the programming community.
08:53:49 <jmcarthur> haskell isn't really as high-level (technically) as a lot of people think. at least in GHC/Haskell i have some understanding of what is going on under the hood. scripting languages, for example, are far more cryptic to me
08:54:35 <applicative_kid> there are other paradigms in a the branch  of declarative langauges which are higher level
08:54:45 <tchakka> Aye that, jmcarthur. I find myself weirded out that my coding style is influenced by how GHC optimizes it.
08:54:59 <mreh> functional is declarative
08:55:01 <mreh> that's where i was going
08:55:19 <sgcummin> whois applicative_kid
08:55:22 <sgcummin> opps
08:55:40 <jmcarthur> tchakka, my coding _style_ is certainly not influenced. but it is nice that i can figure out how to optimize my code for its lower level representation without too much effort
08:56:07 <mreh> doesn't GHC optimise for you?
08:56:41 <applicative_kid> sgcummin: why do you want to know who i am?
08:56:49 <tchakka> It can optimise some code more efficiently than other code.
08:56:59 <jmcarthur> tchakka, minor concession to that, my style is influenced where a good higher level abstraction for some optimized code has not yet been discovered
08:57:16 <jmcarthur> mreh, it's a matter of understanding what it does and does not actually do
08:57:34 <tchakka> The canonical example that I find myself writing is a "go" helper function for the actual loop.
08:57:41 <applicative_kid> mreh: you said it "highest level" so i'm implying you meant the highest level programming language which is not correct
09:00:03 <mightybyte> Does ghci have something like :t that works for functions defined inside where clauses?
09:00:37 <Saizan_> mightybyte: no
09:00:59 <mightybyte> That's too bad.
09:01:19 <Saizan_> a bit, yeah
09:01:44 <doserj> the ghci debugger can be misused for that, I guess
09:02:18 <mightybyte> Having a way to examine the type for arbitrary expressions and non-top-level functions in my code would really improve my productivity.
09:03:12 <Saizan_> i've seen something like that in some scion screenshot
09:03:29 <applicative_kid> i should really finish the reading the book "The Art of prolog: Advanced Programming Techniques" that was an awesome book, I only got chapter 5 ages ago
09:03:36 <applicative_kid> awesome book for logic programming
09:06:40 <mreh> #haskell-in-depth
09:07:12 <mreh> is that the serious haskell channel?
09:07:34 <idnar> I are serious cat; this are serious haskell
09:07:54 <burp_> #haskell-in-real-depth
09:07:59 <burp_> for the real pros
09:08:10 <mreh> it sounds like the beginning of an inifinite regress
09:09:17 <Jig> highest more honorable programming
09:09:56 <Phyx-> aaaarrgggghhh 3 hours looking and it was a wrong ( :(
09:10:15 <Jig> so is it ineffecient to construct a parser by using try on 5 different language constructs?
09:10:36 <mreh> take it outside
09:10:40 <mreh> math boy
09:10:54 <mreh> this room is for constructing the best "lol" program
09:11:02 <mreh> > cycle "lo"
09:11:04 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
09:11:24 <Phyx-> wtf
09:11:47 <DrSyzygyIE> mreh: That regress ends with #oleg
09:12:00 <weilawei> so why does System.FilePath (isValid) say that isValid "" == True in my ghci and == False in the example..
09:12:04 <mreh> i would laugh if i got that joke
09:12:12 <mreh> what is #oleg?
09:12:28 <HairyDude> how do you put strictness annotations on record fields?
09:12:31 <Phyx-> i wanna play too
09:12:35 <Phyx-> > map chr $ cycle [108,111,108]
09:12:35 <DrSyzygyIE> mreh: http://okmij.org/ftp/README.html
09:12:36 <lambdabot>   "lollollollollollollollollollollollollollollollollollollollollollollollollo...
09:12:57 <tchakka> Oleg implemented Haskell in the type system. Or something... <_<
09:13:09 <Lemmih> HairyDude: field :: !Int
09:13:11 <mreh> :D
09:13:17 <DrSyzygyIE> mreh: Oleg is something of a legend of the Haskell community - he does things with the type system nobody thought was quite possible.
09:13:43 <HairyDude> hmm, that gives "unexpected strictness allocation"
09:13:48 <HairyDude> err, annotation
09:14:13 <Lemmih> HairyDude: field :: !(Maybe Int)
09:14:21 <HairyDude> ah, right
09:14:32 <mreh> Phyx-: i like it
09:15:03 <Jig> sme better way to change the suffix of a file than:
09:15:03 <Jig> toExe s = (reverse $ drop 1 $ dropWhile (/='.') $ reverse s) ++ ".exe"
09:15:16 <Phyx-> mreh: lol
09:15:23 <Jig> > let toExe s = (reverse $ drop 1 $ dropWhile (/='.') $ reverse s) ++ ".exe" in toExe "blah.jig"
09:15:24 <lambdabot>   "blah.exe"
09:15:52 <Saizan_> Jig: see System.FilePath
09:15:59 <Phyx-> hehhe
09:18:53 <Jig> is graph reduction a compilation technique?
09:19:15 <tromp> no, an evaluation technique
09:19:49 <quicksilver> it could be the basis of a compilation technique.
09:20:03 <dons> ghc targetting the iphone, anyone? http://caml.inria.fr/pub/ml-archives/caml-list/2009/05/516b25973cf5f56f39e7435cf50729fe.en.html
09:20:03 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:20:21 <quicksilver> dons: please please yes please please :)
09:21:16 <mreh> > [ x | x <- "hello", y <- [1..5], y > 3]
09:21:17 <lambdabot>   "hheelllloo"
09:21:24 <Jig> orgasm if being able to code iphone apps in haskell
09:21:25 <Phyx-> lol, i've notice idling here i seem to pick up usefull stuff once a while :P
09:21:59 <quicksilver> dons: I think the demand for it is well established, quite a few people have talked about it on the lists
09:22:04 <HairyDude> what is this ARR_WORDS constructor that profiling tells me about?
09:22:08 <quicksilver> dons: GHC doesn't have any kind of arm codegen, though
09:22:46 <quicksilver> although GHC's codegen is fairly generic and ARM is a fairly generic assembly language.
09:22:49 <Taejo> Jig: if I had an iPhone app for every orgasm, I'd be a rich man
09:22:54 <adityam> @pl g y = (Left y, Right f)
09:22:54 <lambdabot> g = flip (,) (Right f) . Left
09:23:19 <quicksilver> dons: I'm pretty sure someone tried and failed to get an unregisterised one going. I don't remember why.
09:23:22 <dons> quicksilver: it runs on the arm.
09:23:35 <quicksilver> only unregisterised.
09:23:40 <applicative_kid> pl for pointless?
09:23:47 <dons> yeah
09:23:51 <applicative_kid> awesome
09:24:40 <mreh> the nintendo DS is arm
09:25:25 <quicksilver> dons: it was kind of my hope that working on the x86 codegen I might get some better idea of the difficultly of writing an arm codegen.
09:25:38 <quicksilver> dons: but, there's a steep learning curve and I don' thave that much spare time for such hackin :)
09:26:56 <Phyx-> quicksilver: well, if there does come an arm codegen, that would be neat, not only for the iphone but all arm devices
09:27:04 <pointless_kid> how much effort is it to get up a cross-compiler going with ghc?
09:27:35 <quicksilver> pointless_kid: it's never been done.
09:27:44 <MyCatVerbs> @index mod'
09:27:44 <lambdabot> bzzt
09:27:48 <quicksilver> pointless_kid: so, you'd be treading new ground.
09:27:50 <quicksilver> MyCatVerbs: Data.Fixed
09:27:56 <Phyx-> mreh: yeah, i was actually looking at a way to run .NET micro on it, since it's about to go community supported. (so i assume we'd get sourcecode)
09:28:00 <quicksilver> pointless_kid: it's obviously not impossible, but it would definitely take some work.
09:29:15 <pointless_kid> i'm interested because linux is a lot better for haskell dev than on windows so i've been using linux on VM, i'm think of setting up a cross-compiling enviroment with gcc anyways so it would be great if I could do that with ghc
09:29:43 <mreh> you can cross compile gcc with cygwin
09:29:50 <quicksilver> but not ghc.
09:29:59 <quicksilver> ghc doesn't have cross-compiling support.
09:30:03 <pointless_kid> VM > using cgywin
09:30:04 <quicksilver> although it would be great if someone added it.
09:30:38 <Phyx-> hmm. what's in linux, mac that everyone prefers them over windows for haskell?
09:30:55 <quicksilver> lack of shit.
09:30:58 <Phyx-> ...
09:31:07 <mokus> decent terminal emulation and text editors
09:31:13 <quicksilver> properly designed OS with good command line tools
09:31:21 <quicksilver> and a range of excellent free software
09:31:26 <pointless_kid> haskell dev on windows is kind of sucky at the moment
09:31:27 <Phyx-> mokus: i use console.exe + powershell
09:31:43 <inimino> Unix
09:31:45 <pointless_kid> i'm talking about libraries mostl
09:31:49 <pointless_kid> *mostly
09:32:33 <Phyx-> anyway, to each his own, don't wanna start a flamewar
09:33:07 <mokus> Phyx-: console looks promising - I never really bothered looking for a better terminal in windows, because I only use it when I have to in the first place
09:33:24 <pointless_kid> Phyx: first of all if you need to use a library that is a binding to a C library you'll need to find mingw versions of the library (thats if you can) secondly if you have a problem with a haskell ibrary most of the time when you  speak to the devs they've only tested and acan only debug on a linux machine and never tested it on windows
09:34:20 <pointless_kid> Phyx: I've had issues in the past so i've given up and use linux in virtual machine so it's a lot less painful
09:34:34 <mokus> Phyx-: as for text editors, though, I've yet to find anything anywhere I like as much as TextMate
09:34:49 <Phyx-> mokus: i use Notepad++
09:34:58 <quicksilver> I have a hate/hate relationship with textmate
09:35:00 <pointless_kid> if i could cross-compile to windows that would be awesome
09:36:05 <pointless_kid> hence me saying it sucks to be a haskeller on windows
09:36:05 <mokus> Phyx-: I've tried quite a few, including Notepad++, and there are good ones out there, but TextMate is like text editing nirvana, at least for me ;-)
09:36:56 <mokus> quicksilver: to each his/her own, of course :)
09:37:05 <quicksilver> mokus: it's a good piece of software
09:37:19 <quicksilver> mokus: but it succeeds in being good by taking all the best ideas of some free editors (mostly emacs)
09:37:22 <pointless_kid> quicksilver: do you have an idea what would be involved in getting such an eniroment up?
09:37:33 <quicksilver> and then wrapping them up in an (admittedly polished) form
09:37:58 <quicksilver> and then, surprisingly, people continue to contribute to the community (with bundles and stuff) even though it's closed source and someone is paying for it.
09:38:02 <mokus> quicksilver: I totally agree - but for me, that's why I like it.  polish is worth an awful lot to me
09:38:04 <quicksilver> but that's their right, of course.
09:38:14 <quicksilver> but I think it's odd :)
09:38:25 <quicksilver> pointless_kid: A moderate idea, yes.
09:38:37 <pointless_kid> quicksilver: do tell :P
09:38:46 <quicksilver> pointless_kid: it would require someone to acquire a good knowledge of the GHC source code and go through it adding cross-compilation ability.
09:38:52 <quicksilver> it's not, technically, a massively difficult task.
09:39:03 <quicksilver> but it's probably quite a large task, and you'd need to learn a lot about how GHC works on the way.
09:39:15 <pointless_kid> quicksilver: awww thats a shame
09:39:49 <pointless_kid> gets some undergrads to do it as a school of summer project :P
09:40:04 <quicksilver> too hard for most GSoC students, I fear.
09:40:08 <quicksilver> GHC is a big code base to grok.
09:40:14 <quicksilver> not too hard for the best, of course.
09:41:24 <pointless_kid> maybe dotnet-hs will give me some hope then
09:44:14 * SamB is a bit upset at xchat for writing ~/.xchat2/servlist_.conf non-atomically
09:45:22 <psnively> Hi everyone! Dumb question: if I have a .cabal file and it specifies a bunch of flags, how do I pass values for those flags to the configure/build process?
09:45:47 <dcoutts_> psnively: cabal configure -f foo or -f -foo
09:46:04 <pointless_kid> hopefully mokehehe will submit those directx bindings
09:46:05 <psnively> dcoutts_: Thanks!
09:46:19 <quicksilver> directx bindings? pah!
09:46:20 <HairyDude> does -firrefutable-tuples have any effect on strictness?
09:46:31 <quicksilver> it would be sad to encourage people to write non-portable code in haskell
09:46:35 <dcoutts_> psnively: see cabal configure --help for the whole shebang
09:46:43 <quicksilver> I like the fact that most of the standard libs are (fairly) portable.
09:46:49 <psnively> dcoutts_: Gotcha, thanks again!
09:48:28 <pointless_kid> quicksilver: you're not going to win many game developers without such bindings
09:50:03 <pumpkin_> we don't want no game devs!!!
09:50:49 <psnively> I dunno. I'd go for OpenGL 2.1 bindings, personally.
09:51:40 <quicksilver> pointless_kid: what's wrong with using opengl and writing cross-platform games?
09:51:53 <quicksilver> pointless_kid: I certainly don't want to "win" over people who write games for only win32 ;)
09:52:38 <psnively> Amen.
09:53:19 <pointless_kid> psnively: many will disagree with you, i'd prefer the bindings to be updated to GL 3.1  and GL is graphics specific, i know direct3d and gl and gl is a bit of sucky API for games dev to honest, and many will say the same
09:53:34 <psnively> Sorry, I meant 3.1.
09:53:37 <vixey> pointless_kid: no it's not
09:53:47 <pointless_kid> vixey: what's not?
09:54:00 <vixey> "gl is a bit of sucky API for games dev" is not true
09:54:00 <quicksilver> pointless_kid: d3d is a totally sucky API for gamedev for one important reason - it's platform specific.
09:54:21 <quicksilver> pointless_kid: people writing games shouuld want their engines to be portable to DS, iPhone, PS3, etc etc.
09:54:22 <Jig> what si the difference between an .exe and an object file?
09:54:23 <psnively> Somehow, id, Epic, Blizzard... all manage to make a go of OpenGL. :-)
09:54:27 <quicksilver> D3D doesn't give you that.
09:54:30 <vixey> a lot of people don't care about that quicksilver
09:54:34 <Jig> object file has no main procedure?
09:54:36 <pointless_kid> quicksilver: yes but why do you think we use it?
09:54:37 <quicksilver> vixey: yeah, I know :(
09:54:41 <quicksilver> vixey: hence "should want"
09:54:47 <quicksilver> rather than "want".
09:55:01 <vixey> it's not a bad thing to be platform specific
09:55:23 <psnively> vixey: It's a bad thing to be platform-specific for the sake of being platform-specific.
09:55:26 --- mode: Igloo set -b %*!*@unaffiliated/bacta
09:55:52 <Phyx-> bleh, how i hate that Prelude.head error... never know where it is
09:55:53 <Phyx-> lol
09:56:30 <pointless_kid> vixey:  it is true and many will tell you the same thing
09:56:36 <Botje> Phyx-: use safeHead :p
09:56:44 <pointless_kid> vixey:  i work in the industry myself
09:57:08 <psnively> But if you really want to support game development, binding to a decent engine, maybe horde3d, maybe ogre3d...
09:57:17 <psnively> Er, bind to a decent engine, rather.
09:57:20 <psnively> SDL, of course...
09:57:28 <pointless_kid> i've got both 360 & PS3 SDKs on my machine at wokr
09:57:51 <Phyx-> :t safeHead
09:57:53 <lambdabot> Not in scope: `safeHead'
09:57:59 <Phyx-> @index safeHead
09:57:59 <lambdabot> bzzt
09:58:02 <Phyx-> lol
09:58:05 <Phyx-> hahahaah
09:58:11 <Phyx-> nice
09:58:15 <quicksilver> Phyx-: listToMaybe
09:58:35 <quicksilver> pointless_kid: my comments were meant to be taken fairly lightly.
09:58:45 * Phyx- changes
09:58:52 <eden_> I suppose games have a pretty short shelf life, so I
09:58:53 <quicksilver> pointless_kid: I'm aware of the popularity of D3D for real games development, but I wish it wasn't so :)
09:59:08 <quicksilver> pointless_kid: I'd rather encourage people towards cross-platform solutions.
09:59:11 <quicksilver> or "more portable" choices.
09:59:15 * psnively used to make his living porting pointlessly Windows-specific game code to the Mac.
09:59:21 <psnively> ==quicksilver
09:59:39 <eden_> it doesn't matter much if they are platform specific. You don't have to worry about the fututre.
10:00:00 <psnively> There isn't a good reason to be Windows-API-specific. Again, the biggies in the industry don't feel the need, and make millions of extra $ by being cross-platform from the outset.
10:00:32 <pointless_kid> lol
10:00:35 <Phyx-> somehow i doubt the financial gain is that much
10:00:55 <quicksilver> the financial gain for a good iPhone port is huge :)
10:00:55 <eden_> On the whole though, I do prefer cross platform solutions
10:00:59 <psnively> Phyx-: I don't know about generally, but it is for, e.g. Blizzard.
10:01:14 <quicksilver> if you do it well, at least.
10:01:27 <quicksilver> not that you're likely to use the same engine on the iPhone - but if lots of your code is portable, it's easier.
10:01:55 <psnively> quicksilver: OpenGL ES is really the only choice for mobile devices generally, I would say.
10:03:12 <eden_> Whilst the engine is at the heart of a game, most game development is not on the engine, it's on all the stuff that makes it worth playing, like graphics and sound
10:03:19 <Jig> what was that link to haskell videos again?
10:03:22 <Jig> @videos
10:03:22 <lambdabot> Unknown command, try @list
10:03:29 <Jig> @SPJ
10:03:30 <lambdabot> Unknown command, try @list
10:04:11 <psnively> eden_: Sure. But all of that sits on top of the engine. So having a portable engine is a pretty significant win (which is why, e.g. the Unreal tech is so popular: Windows, Mac, Linux, PS3, XBox 360...)
10:04:48 <telemachus> dcoutts: Let's assume I'm a bit slow today. Where's the 'ar' bit we were discussing earlier set?
10:05:47 <dcoutts_> telemachus: see use of arProgram in Distribution/Simple/GHC.hs in the Cabal library
10:05:55 <pointless_kid> not every company buys middleware/game engines
10:06:09 <pointless_kid> anyways this is getting ridicuolous, there is no problem adding directx bindings to haskell and it will only do it better
10:06:21 <telemachus> dcoutts_: looking...
10:06:55 <pointless_kid> and there are many who do prefer d3d over GL
10:07:07 <dcoutts_> telemachus: arArgs = ["q"++ arVerbosity]
10:07:18 <dcoutts_> telemachus: you've got the Cabal head branch from darcs?
10:07:46 <telemachus> no, actually, I have the tarball
10:07:51 <telemachus> (No Darcs here)
10:08:18 <dcoutts_> telemachus: the main thing is checking it works. It should be just changing from "q" to "sa" or something, but we need to check the man pages and then check it actually works on linux, osx and solaris
10:10:26 <psnively> pointless_kid: No one's claiming that everyone buys or uses middleware, and the question as to what should be included in a given language/library distro immediately touches on questions of portability. I don't think anyone is saying that no one, ever, should do D3D bindings for Haskell. But if the question is "should the standard library include them if it means taking resources of the GHC maintainers to develop and package them," then I say the answer
10:10:28 <psnively> That's all.
10:10:55 <kynky> whats wrong with ogl ?
10:11:15 <eden_> psnively: I don't disagree. I spent the early nineties writing voxel engines, They ended up in single-purpose medical platforms, which mad cross platform development totally essential.
10:11:20 <dcoutts_> telemachus: sorry, "rs" I think. r for insert and s for make the index.
10:11:25 <telemachus> dcoutts_: found it and changed to 'rs' (which was recommended on the ticket)
10:11:28 <telemachus> yup
10:11:33 <telemachus> trying make again
10:11:49 <vixey> somehow 'it is true' doesn't convince me
10:12:05 <pointless_kid> psnively: no one every said anything about making part of the standard library
10:12:20 <psnively> pointless_kid: Then we are in vehement agreement. :-)
10:13:10 <psnively> eden_: Generally speaking, I think platform-specific development is nuts. There are occasionally good reasons to the contrary, however.
10:13:27 <pointless_kid> it can go into hackage and hopefully mokehehe will do it soon
10:13:48 <telemachus> dcoutts_: I'll let you know shortly (trying a freshly untarred source) if it builds
10:14:08 <dcoutts_> telemachus: ok
10:16:00 <Phyx-> wait.. so you're all against platform specific developements, but yet you're all fine with haskell libraries that only work on linux.. isn't that a contradiction
10:16:21 <telemachus> Phyx-: Linux isn't a platform, it's a state of mind.
10:16:40 <kynky> and i thought it was a kernel
10:16:43 <pointless_kid> Phyx: good point from earlier on
10:17:39 <Phyx-> :)
10:22:04 <telemachus> dcoutts_: I'm off to my last class of the day, but we're already well past the place where previous builds blew up. I'll check back in later and let you know if it finished successfully, but it's looking good.
10:23:01 <dcoutts_> telemachus: great, perhaps when it finishes you could record your findings in that Cabal ticket (login as guest, passwd is on the front wiki page)
10:23:09 <pumpkin_> odysseus jr :o
10:27:49 <jberryman> I'm figuring out how to prepare a simple package for hackage, not sure where to place it in the module hierarchy. It's called DirectoryTree and provides a simple data type and various IO functions for opening and working with directories of files.
10:28:02 <jberryman> would System.Directory.DirectoryTree be acceptable?
10:34:47 <Botje> System.Directory.Tree ?
10:34:52 <roconnor> Data.Accessor ought to be part of the haskell platform
10:35:04 <roconnor> I'm surprised it isn't used more
10:35:30 * jmcarthur now feels required to see what Data.Accessor is
10:35:42 <roconnor> ideally, Haskell would generate Data.Accessors from record field names instand of generating projectors.
10:35:59 <jmcarthur> oh that one
10:36:52 <jberryman> Botje: oh yeah, that makes sense. is that a good idea since System.Directory is someone else's package?
10:37:28 <MoxJet> @t join
10:37:28 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:37:33 <MoxJet> @type join
10:37:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:37:38 <MoxJet> @type (join (*))
10:37:39 <lambdabot> forall a. (Num a) => a -> a
10:37:41 <roconnor> I didn't really understand Data.Accessor until I invented it myself, and though "Hmm, this seems familiar"
10:37:43 <MoxJet> how is this possible?
10:38:21 <roconnor> MoxJet: ((->)r) [aka (r ->)] is an instance of a Monad
10:38:44 <roconnor> @type join :: (r -> r -> a) -> (r -> a)
10:38:44 <Phyx-> oh, nice
10:38:45 <lambdabot> forall r a. (r -> r -> a) -> r -> a
10:38:46 <MoxJet> roconnor: Is that the reader monad?
10:39:02 <roconnor> MoxJet: it is called a reader monad.
10:39:11 <Jig> does Ocaml have more predictable performance than haskell?
10:39:12 <roconnor> @instances MonadReader
10:39:13 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
10:39:25 <roconnor> @src Reader r
10:39:25 <lambdabot> Source not found. That's something I cannot allow to happen.
10:39:28 <roconnor> @src Reader
10:39:28 <lambdabot> Source not found. Take a stress pill and think things over.
10:39:44 <Phyx-> lol
10:40:02 <roconnor> MoxJet: (Reader r b) and (r -> b) are isomorphic.
10:40:08 <Gracenotes> , src ''Reader
10:40:13 <lunabot>  newtype Reader i a = R' {unR :: (ReaderT i Id a)}
10:40:23 <Gracenotes> hm. that's one way to do it >_>
10:40:31 <roconnor> , src "ReaderT
10:40:32 <lunabot>  luna: lexical error in string/character literal at end of input
10:40:52 <Phyx-> '' not "
10:40:53 <Gracenotes> the way GHC does it is just Reader r a = Reader { runReader :: r -> a}
10:41:36 <Gracenotes> > let myread = Reader negate in runReader myread 10
10:41:37 <lambdabot>   -10
10:42:01 <MoxJet> can I import prelude hiding the Monad instance of (->)+
10:42:03 <MoxJet> ?
10:42:11 <Gracenotes> also known as the "environment" monad
10:42:38 <Gracenotes> mm. there is no way to select instances when importing, afaik :\
10:42:53 <Phyx-> oh oh...
10:42:55 <Gracenotes> but the Monad instance for (->)e isn't in Prelude. It's in Control.Monad.Instances
10:42:56 <roconnor> MoxJet: the Prelude doesn't have the Monad instance for (->)
10:43:06 <Phyx-> *forcably terminates ghc*
10:43:07 <roconnor> MoxJet: but if it did, then you couldn't hide it.
10:43:07 <SamB> MoxJet: is there some other instance you'd rather have?
10:43:09 <riddochc> Doing first set of exercises in Ch. 3 of Real World Haskell, and I'm running into the error "Not in scope: data constructor `List'" - http://pastie.org/472387
10:43:11 <Gracenotes> which is also included in places like Control.Applicative
10:43:33 <MoxJet> roconnor: oh, thanks, I had accidentally imported Control.Monad which imports Control.Monad.Instances
10:43:48 <riddochc> But defining the List (exactly as the book does) is the first thing I'm doing in my file.
10:44:04 <roconnor> MoxJet: I hope you are only doing this to help with error messages.
10:44:06 <MoxJet> SamB: I am defining it myself as a practice :)
10:44:12 <jmcarthur> riddochc, you defined a list type constructor, not a list data constructor
10:44:14 <roconnor> MoxJet: making your own (->) instance is dangerous
10:44:18 <jmcarthur> your data constructors are Cons and Nil
10:44:23 <roconnor> ... because Haskell sucks
10:44:44 <MoxJet> roconnor: do you mean if I make an instance that does not satisfy the monad laws?
10:44:46 <ziman> riddochc, pn line 8, the definition should be: toList (Cons x xs) = x:xs
10:44:50 <Gracenotes> instance selection leaves stuff to be desired... although some also argue included it would be nightmarish
10:45:00 <ziman> riddochc, pn line 8, the definition should be: toList (Cons x xs) = x:toList xs
10:45:12 <Gracenotes> *ing
10:45:27 <roconnor> MoxJet: I think you are get screwed if you make any Monad instance for (->) at all
10:45:53 <roconnor> MoxJet: because you will never be able to import the instance from Control.Monad
10:46:03 <SamB> roconnor: well, he could do it in an isolated module just to play with
10:46:10 <Gracenotes> riddochc: yeah :) if you want to pattern match against one argument, the whole thing usually has to be in parens.
10:46:12 <SamB> as long as he doesn't try to use it in a real program
10:46:20 <roconnor> MoxJet: and users will never be able to combine your work with any other work that uses Control.Monad
10:46:27 <roconnor> ... because Haskell sucks
10:46:46 <MoxJet> It is definitely in an isolated, toy module
10:46:54 <SamB> roconnor: will you stop saying that just because you CAN do that with your typeclasses in Coq ...?
10:46:55 <roconnor> okay then
10:47:21 <SamB> that can suck too, sometimes!
10:47:36 <vixey> hahaa
10:47:53 <SamB> and then there's that darn eq instance
10:47:54 <roconnor> SamB: my criticism has nothing to do with Coq or any other language.
10:48:30 <roconnor> SamB: the global nature of class instances destroys modularity
10:48:33 <SamB> you did write that implementation of typeclasses though, didn't you ?
10:48:48 <roconnor> this is sucky in absolute terms
10:48:52 * SamB is just checking his memory now
10:48:54 <ziman> which one should I learn, Agda or Coq?
10:48:59 * SamB is not trying to argue a point
10:49:04 <roconnor> SamB: nope, mattam did that.  I barely even know Ocaml
10:49:05 <SamB> ziman: both
10:49:06 <roconnor> :)
10:49:06 <riddochc> Hm.  Thanks, everyone.  As you can tell, I'm quite new to the language.  ziman: I was hoping to figure *that* part out on my own,  jmcarthur: thanks for reminding me of the distinction.
10:49:08 <SamB> roconnor: oh!
10:49:10 <vixey> ziman, for what purpose?
10:49:14 <SamB> see, that's why I was checking ;-)
10:49:15 <jmcarthur> ziman, i like both
10:49:23 <roconnor> good forbid I have to program in Ocaml :P
10:49:25 <roconnor> god
10:49:30 <vixey> Ocaml is fine
10:49:38 <vixey> It's good for big programs
10:49:41 <SamB> I know it's pretty bad, where it == my memory
10:49:44 <vixey> (unlinke haskell :p)
10:49:49 <SamB> well, camlp4 is a bit insane I think
10:49:50 <roconnor> vixey: :P
10:49:55 <roconnor> vixey: big programs are buggy
10:49:57 <SamB> or p5 or whatever they call it
10:50:05 <SamB> at least, how Coq seems to use it
10:50:09 <roconnor> vixey: best to write it all in one line in Haskell.
10:50:34 <roconnor> ziman: what do you want to do with Coq or Agda?
10:50:35 <ziman> riddochc, i see, sorry :)
10:50:50 <jmcarthur> ziman, if you are wanting something that is more easily used as a "normal" programming language, Agda. if you like the idea of tactics or the CoC, Coq
10:51:06 <ziman> vixey, roconnor, i'd like to try programming with dependent types and related stuff
10:51:09 <riddochc> It's okay.  That probably would've been my fifth try or so.
10:51:24 <roconnor> ziman: maybe start with Agda  (although I haven't used agda)
10:51:32 <jmcarthur> ziman, i think Coq has a bit more documentation at the moment, as well
10:51:32 <SamB> ziman: Coq is more mature, Agda is more a programming language and more epigramy (but not quite so mysteriously buggy as epigram 1)
10:51:39 <vixey> I think Coq is much more practical than Agda
10:51:54 <SamB> vixey: I think that comes with the mature bit, partly
10:51:58 <vixey> I've written various programs in Coq
10:52:09 <SamB> agda may become more useful as it matures
10:52:16 <vixey> With Agda you are always doing tedious proofs by writing out sequents in this weird 'lambda calculus' syntax
10:52:20 <roconnor> ya, but Agda seems to have the potential to be nicer to learn about dependently typed programming.
10:52:43 <vixey> Until Agda has de bruijn criteria it's just (a really cool) research language
10:52:47 <roconnor> I agree that Coq should be used for "practical" work
10:52:48 <leimy> vixey: Haskell is not good for big programs?
10:52:57 <SamB> the one thing I like about the Agda approach is that your proofs/programs don't randomly break because of changes in heuristics
10:52:59 <kynky> darcs is big
10:53:05 <ziman> are they usable as general-purpose languages?
10:53:08 <roconnor> LOLITA is big ... I'm told
10:53:12 <vixey> leimy, like GHC is a huge program and I really have so much trouble trying to hack it
10:53:15 <roconnor> ziman: nope
10:53:16 <SamB> kynky: that's supposed to be for or against?
10:53:19 <jmcarthur> vixey, is there any sort of FFI for Coq, or is it really more a matter of generating a pure Haskell library or something and writing an IO shell yourself?
10:53:22 <leimy> kynky: I can't figure out why I'd want to use darcs yet.
10:53:40 <vixey> Idris has a clever C FFI
10:53:43 <SamB> leimy: well, I wish it was a layer on git personally ...
10:54:00 <vixey> (Idris is another dependently typed language)
10:54:07 <kynky> port git backend to be in haskell ?
10:54:15 <SamB> it would be good for passing around mostly-independent patches before they make it into official history
10:54:24 <SamB> kynky: that part is the easy part
10:54:38 <kynky> good place to start :)
10:54:39 <SamB> I mean, Haskell code to handle git
10:54:47 <SamB> I think that part was done already once
10:55:05 <ziman> okay, thanks, i'll try writing some programs in Agda and see how it feels like :)
10:55:19 <Gracenotes> feels good man
10:55:21 <riddochc> The backend of git is definitely easy.  It's been done in just about every language you can imagine.  Making useful porcelain, on the other hand, is where it gets tricky.
10:55:23 <SamB> there was some darcs branch with support for git repos ... but it didn't support darcs-style patches on them, afaict, so what's the point ?
10:55:53 <SamB> I do like that git has such a simple repository model
10:56:11 <jmcarthur> it's important since git's interface exposes a lot of it
10:56:13 <MoxJet> @pl f x y = y
10:56:13 <lambdabot> f = const id
10:56:19 <kynky> made for merging not branching :)
10:56:35 <MoxJet> @pl f x y = x
10:56:35 <lambdabot> f = const
10:56:48 <Jig> to write a browser, are there good packages for most parts? like i dont want to write the rendering for example
10:56:49 <SamB> DVCes are always able to branch easily
10:57:04 <jmcarthur> Jig, maybe not Haskell packages, but you can always use the FFI
10:57:06 <SamB> Jig: a web browser? in Haskell? not really.
10:57:25 <SamB> we don't even have an XPCOM tool, do we?
10:57:25 <vixey> ziman: (but check out the Program extension of Coq -- for writing programs as you might guess :p)
10:57:33 <Gracenotes> @unpl flip const
10:57:33 <lambdabot> (\ b c -> c)
10:58:19 <riddochc> Jig: the number of useful HTML rendering engines is pretty small - gecko, webkit, opera's thingie, and IE's thingie. ;)
10:58:23 <SamB> (not that you'd want to use XPCOM in a Haskell web browser per-se.)
10:58:27 <telemachus> dcoutts_: Damn, same problem but for ghc itself. I suppose that the obvious thing I forgot is that I need to change the ar flags everywhere, yes?
10:58:49 <dcoutts_> telemachus: which .a file is it complaining about exactly?
10:58:49 <SamB> riddochc: you didn't mention links !
10:59:03 <telemachus> libHSghc-6.10.2.a
10:59:15 <riddochc> Samb: I did mention *useful*, though. ;)  Links doesn't do JS, does it?
10:59:18 <kynky> well there is gtk2hs, which has the Mozilla browser rendering engine in a Gtk+ widget
10:59:28 <SamB> riddochc: I think that's available
10:59:29 <kynky> for Jig
10:59:34 <roconnor> vixey: I don't know how people program in Ocaml, with your variables changing on you all the time. :P
10:59:37 <SamB> and it's hardly part of the HTML rendering per-se
10:59:38 <dcoutts_> telemachus: ah, yes then. Those .a files are not made by Cabal but ghc's build system of makefiles.
10:59:46 <telemachus> right then
10:59:50 <SamB> hey, it at least renders HTML, unlike lynx
10:59:56 <SamB> which just sort of puts it in a line
11:00:02 <ziman> vixey, thanks
11:00:04 <riddochc> SamB: These days, that's a distinction without much difference.
11:00:22 <SamB> riddochc: you ever tried to read a document that used tables in lynx?
11:00:30 <SamB> I mean used, not just abused
11:00:36 <riddochc> Ugh.
11:00:55 <SamB> you know, to display tabular information, not a navbar ;-)
11:01:12 <riddochc> Don't get me wrong, links is way better than lynx.  Still, without javascript support, a really large portion of the web is useless.
11:01:25 <SamB> I think some versions have JS though ...
11:01:39 * riddochc asks google.
11:01:54 <kynky> elinks has javascript support
11:02:09 <SamB> elinks also has a much more googleable name
11:02:57 <gwern> wait, elinks supports JS?
11:03:06 <kynky> yes
11:03:10 <SamB> gwern: off by default, if you're worried
11:03:19 <SamB> I'm fairly certain
11:03:24 <riddochc> Cool! The twibright labs people made some javascript support for links. I like their 'optar' project.
11:03:26 <Gracenotes> going from not supporting JS to supporting JS is quite a big leap
11:03:32 <kynky> its a use flag for it too
11:03:46 <gwern> SamB: I'm just surprised. I vaguely heard about extremely extremely hacky JS support in dev elinks, but I didn't know it had gone all the way to shipping
11:04:30 <telemachus> dcoutts_: I'll build again and let you know
11:04:40 <kynky> im using elinks 0.11.5
11:04:56 <dcoutts_> telemachus: you shouldn't have to make clean for that
11:05:12 <dcoutts_> telemachus: after updating the makefile just rm the offending .a file
11:05:30 <telemachus> right
11:07:37 <gwern> @remember JamesIry 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
11:07:37 <lambdabot> Done.
11:07:43 <gwern> @flush
11:07:57 <travisbrady> anyone know of a Haskell library to do journaled io ala libjio?
11:08:31 <travisbrady> actually i could hook into libjio via ffi
11:09:25 <Jig> a fulyl verified browser in Coq!
11:09:48 <telemachus> dcoutts_: I'm not seeing arArg anywhere _but_ in the Cabal file
11:10:02 <telemachus> ie, I'm not sure where to set the flags for ghc itself
11:10:34 <gwern> Jig: that sounds like a ridiculous waste of manpower
11:12:10 <dcoutts_> telemachus: look for AR_OPTS and $(AR) in the makefiles, eg in mk/*
11:12:47 <telemachus> $(AR) yup, AR_OPTS nope
11:12:50 <Jig> gwern: :P
11:12:51 <eden_> I'm having some trouble adding an instance declaration to an expression. I clearly don't understand what's going on, or what I'm supposed to do about it. Does anybody have any references for this kind of thing?
11:13:50 <dcoutts_> telemachus: you're using 6.10.x?
11:13:50 <telemachus> I'll dig around and let you know...
11:13:59 <telemachus> yup, 6.10.2
11:14:03 <gwern> Jig: 'don't worry, all you need to know to add an adblocker plugin is how to model compilation of finite-state machines in an intuitionistic logic; your university probably has some grad spots you could use while you work on this'
11:14:03 <dcoutts_> 'k
11:14:31 <dcoutts_> telemachus: so you don't see AR_OPTS in mk/opts.mk and mk/target.mk ?
11:15:54 <dcoutts_> telemachus: so I've got in mk/config.mk, AR = /usr/bin/ar clqs
11:17:58 <dcoutts_> telemachus: see aclocal.m4, the macro FP_PROG_AR_ARGS which sets the var ArCmd which gets substituted into mk/config.mk.in
11:24:26 <eden_> No clues at all?
11:25:37 <jmcarthur> :t show
11:25:38 <lambdabot> forall a. (Show a) => a -> String
11:25:57 <eden_> :t Stream
11:25:58 <lambdabot> Not in scope: data constructor `Stream'
11:26:19 <eden_> :t Text.Parsec.Prim.Stream
11:26:20 <lambdabot> Couldn't find qualified module.
11:29:55 <pumpkin_> eden_: can you be more specific?
11:34:45 <eden_> pumpkin_: Yes. I've got an instance of the TextParsec.Prim.Stream. It starts "instance Stream s m Char => Stream (SourcePosStream s m) m (SourcePos s) where...."
11:35:14 <pumpkin_> I mean, what's the problem?
11:35:20 <eden_> pumpkin_: The idea is to split
11:35:24 <roconnor> > 4/12
11:35:25 <lambdabot>   0.3333333333333333
11:36:25 <roconnor> > 1.04^(1/12)
11:36:26 <lambdabot>   Add a type signature
11:36:31 <roconnor> > 1.04**(1/12)
11:36:32 <lambdabot>   1.003273739782199
11:38:14 <eden_> pumpkin_: That's the question. It compiles Okay, but when I try to use it, It complains about needing an instance declaration for Stream [Char] Identity Char,
11:39:39 <eden_> I've tried separating things out into functions with type signatures, but the complaints only proliferate.
11:39:40 <pumpkin_> that should be covered by the Monad m => Stream ([] tok) m tok instance in Text.Parsec.Prim
11:40:44 <roconnor> > 1.04**(1/12) :: CReal
11:40:45 <lambdabot>   1.0032737397821988638592943204158789680534
11:41:41 <eden_> Partly. I'm splitting one stream into several streams, each one tupled up with it's starting position. This then generates a stream of (SourcePos, Char) tokens.
11:42:14 <pumpkin_> yeah, but I mean your Stream [Char] Identity Char fits Monad m => Stream ([] tok) m tok just fine doesn't it?
11:42:20 <pumpkin_> so that instance should already exist
11:42:50 <pumpkin_> so I'm not sure why it'd be complaining about the missing instance
11:43:46 <eden_> Yes. It does exist. And it's demanding that I add an instance declaration for that one somewhere. It's where and how that I'm confused about.
11:44:04 <pumpkin_> you've tried importing Text.Parsec.Prim ?
11:44:36 <eden_> yes.
11:45:16 <pumpkin_> hmm
11:46:22 <chadz> is there a nice way to (within a state monad):
11:46:31 <roconnor> > 1.04**12
11:46:32 <lambdabot>   1.6010322185676815
11:46:37 <roconnor> > 1.004**12
11:46:37 <chadz> gets foo >>= \f -> bar f
11:46:38 <lambdabot>   1.0490702075348057
11:46:51 <pumpkin_> chadz: gets foo >>= bar ?
11:46:59 <pumpkin_> what do you mean for state monad?
11:47:40 <eden_> I can make it work fine when I define the snd part of the tuple as an explicit String, but not when I want it to be another stream.
11:47:46 <chadz> well im working withi specific elements from the record i'm using in my state monad
11:48:13 <pumpkin_> eden_: maybe showing some code might help? I don't really understand how it couldn't work, as it stands :/
11:48:14 <chadz> i'm trying to figuer if there's a better way of accessing them other than (s<-get, or gets)
11:49:27 <eden_> It's a it long to paste here.
11:50:30 <pumpkin_> @hpaste
11:50:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:51:30 <eden_> @help
11:51:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:51:32 <roconnor> > 1.0032**12
11:51:33 <lambdabot>   1.0390831011312591
11:51:44 <eden_> help @hpaste
11:51:44 <roconnor> > 1.0033**12
11:51:45 <lambdabot>   1.0403267051542395
11:52:25 <eden_> @list
11:52:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:52:32 <eden_> \list
11:52:50 <Alpounet> is there any brand new library for neural networks ?
11:52:58 <Alpounet> (not being a binding of FANN)
11:54:16 <pumpkin_> eden_: just paste to the website and give us the link
11:54:56 <MoxJet> @pl f x y = [x,y]
11:54:57 <lambdabot> f = (. return) . (:)
11:55:24 <MoxJet> @pl f x y z = [x,y,z]
11:55:24 <lambdabot> f = (. ((. return) . (:))) . (.) . (:)
11:56:21 <MoxJet> @unpl (. (:[])) . (:)
11:56:21 <lambdabot> (\ e h -> ((:)) e (h : []))
12:00:43 <ksf> gecko now does speculative parsing.
12:00:57 <eden_> pumpkin_: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4729#a4729
12:01:21 <ksf> ...which isn't OT 'cos I'm wondering how to properly do that while unsafeMMaping a file without thrashing the disk
12:02:06 <MoxJet> @pl f g = (g .) id
12:02:07 <lambdabot> f = id
12:02:23 <ksf> ...not that I have a dual core, but it's just sensible to use spare oomph to speculatively parse stuff that's already in memory, anyway.
12:02:32 <Baughn> ksf: Trust the OS?
12:02:46 <ksf> I do, I'm not using windoze, after all.
12:06:11 <ksf> more importantly, during parsing memory usage for a block raises from (blocksize, mmaped) to (blocksize*2-peanuts+adt's), but after parsing is done, it's (blocksize-peanuts+adt's).
12:06:23 <ksf> so, by parsing lazy, I'm wasting memory.
12:08:35 <pumpkin_> eden_: so you get a runtime error?
12:08:49 <ksf> no, wait, it stays at 1*blocksize, at least for the bulk of the data, as lazy bytestrings don't copy stuff around when being splitted (at least i hope so)
12:08:51 <eden_> No. A type error.
12:09:09 <pumpkin_> eden_: can you include the full error in the paste?
12:09:13 <pumpkin_> you can update the paste
12:09:19 <trofi> @pl \p (a,b) -> (a `div` p, b `div` p)
12:09:19 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . flip div) (flip div)
12:09:51 <pumpkin_> trofi: it can be a lot simpler than that :P
12:09:59 <MoxJet> @type (***)
12:10:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:10:21 <pumpkin_> join (***) . flip div
12:10:22 <pumpkin_> might do it
12:10:27 <pumpkin_> but then again, it might not
12:10:44 <pumpkin_> :t join (***) . flip div
12:10:46 <lambdabot> forall a. (Integral a) => a -> (a, a) -> (a, a)
12:10:54 <jmcarthur> :t \p (a,b) -> (a `div` p, b `div` p)
12:10:55 <lambdabot> forall t. (Integral t) => t -> (t, t) -> (t, t)
12:11:49 <pumpkin_> of course, join (***) . flip div might not be the most readable thing ever
12:11:52 <pumpkin_> even if it is concise
12:12:20 <eden_> pumpkin_:This is the error, by the way, thanks for spending time on this... http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4729#a4731
12:12:29 <jmcarthur> @check \x y -> (join (***) . flip div) x y == ((\p (a,b) -> (a `div` p, b `div` p)) x y :: (Int, Int))
12:12:30 <lambdabot>   "* Exception: divide by zero
12:12:32 <pumpkin_> eden_: try removing the qualified exports
12:12:44 <pumpkin_> I mean, the list of them
12:12:49 <jmcarthur> @check \x y -> x /= 0 ==> (join (***) . flip div) x y == ((\p (a,b) -> (a `div` p, b `div` p)) x y :: (Int, Int))
12:12:50 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:12:50 <lambdabot>           ...
12:12:54 <jmcarthur> eh whatever
12:13:02 <pumpkin_> I mean, just make it module SourcePosStream
12:13:50 <eden_> you mean "module SourcePosStream where" and then the rest?
12:13:54 <pumpkin_> yeah
12:13:59 <pumpkin_> just as a test
12:15:57 <eden_> Nope. Exactly the same type error.
12:16:06 <pumpkin_> eden_: oh actually, does the module with the error import Text.Parsec.Prim ?
12:16:16 <pumpkin_> otherwise, you may have to re-export it from the one you pasted
12:17:13 <eden_> It does import Text.Parsec.Prim.
12:17:34 <eden_> what do you mean by re-export?
12:17:52 <pumpkin_> hmm, then I'm utterly confused and must leave anyway :/
12:18:02 <pumpkin_> maybe someone with more experience than me can help you :)
12:18:18 <pumpkin_> if a module imports something, it doesn't necessarily make that stuff available to modules importing it
12:18:49 <Zao> module Foo (omg, wtf, BBQ) where
12:19:20 <Zao> If the export list is missing, everything is exported.
12:19:53 <Zao> Similarly you can use an import list when importing a module to restrict what's imported.
12:20:35 <eden_> Okay. Either way, thanks for your time. I can carry on experimenting with the less capable version that does work.
12:22:35 <Alpounet> what does the 'derive' keyword exactly do ?
12:22:57 <Alpounet> for instance, if I derive Show, it will try to call show on each 'component' of the data type ?
12:23:21 <SamB> Alpounet: showsPrec, actually
12:23:52 <Alpounet> ok
12:23:55 <Alpounet> thanks ! :-)
12:24:50 <byorgey__> Alpounet: the derive keyword actually does different things depending on the type class being derived.
12:25:32 <Alpounet> but it kinda generates code instead of writing the instantiation ourselves ?
12:27:34 <MoxJet> @pl f g r = f (0:r) (r++[0])
12:27:35 <lambdabot> f = fix (const . (`ap` (++ [0])) . (. (0 :)))
12:28:44 <hatds> alpounet: yes
12:29:15 <Alpounet> ok thanks.
12:32:06 <jmcarthur> @pl f r = f (0:r) (r++[0])
12:32:07 <lambdabot> f = fix ((`ap` (++ [0])) . (. (0 :)))
12:40:38 <EvilTerran> > liftA2 (,) (0:) (++[0]) [1,2,3]
12:40:40 <lambdabot>   ([0,1,2,3],[1,2,3,0])
12:40:49 <Jig> gwern: :P
12:40:55 <Jig> does Ocaml have more predictable performance than haskell?
12:41:00 <vixey> yes
12:42:09 <Jig> dons: would it mean you'd be able to code iphone apps in haskell? or run ghci on it?
12:42:20 <Baughn> Depends on how you define "predictable".. well, but since haskell doesn't /have/ defined runtime behaviour, I suppose so
12:42:34 <Jig> what does it mean to have defined runtime behaviour?
12:43:59 <hatds> specified by a written standard?
12:44:23 <Berengal> "such and such does this and this"?
12:45:04 <Baughn> Quite
12:45:14 <Baughn> The output of a haskell program is defined, but now how it gets there
12:45:30 <Berengal> It's defined to be lazy though, isn't it?
12:45:36 <Baughn> Yes
12:46:12 <Baughn> (That affects the output, eg. "head [1..]"
12:46:18 <EvilTerran> it's defined to have non-strict semantics; that doesn't necessarily imply lazy evaluation, although that's the most obvious implementation
12:47:31 <roconnor> Why do people keep saying non-strict semantics.  Isn't it defined to have normal semantics?  (granted normal is a pretty misleading term here)
12:47:37 <EvilTerran> there could be implicit parallel evaluation going on under the hood without losing the semantics
12:48:10 <roconnor> I mean there are plenty of (stupid) evaluation orders between normal order and strict-order
12:48:15 <Berengal> Or it could be eager, as long as it knew when to not bottom out
12:48:22 <hatds> or something like a strictness analyzer would preserve the semantics but not have lazy evaluation..right?
12:48:22 <Berengal> (But that could be hard with infinite loops)
12:50:21 <ray> roconnor: probably because people consider strictness "normal"
12:50:39 <ray> the common definition and technical definition of "normal" conflict
12:50:47 <roconnor> ya ;(
12:50:51 <ray> so as always, the technical definition takes a beating :(
12:51:49 <Berengal> lazy evaluation was normal back in high-school math...
12:51:50 <roconnor> granted normal-order is on they syntax side.  I don't know if there is another word on the semantic side, which is really the side we care about.
12:52:44 <Cale> At the level of semantics, there's no way to distinguish normal order and lazy evaluation.
12:52:55 <telemachus> dcoutts_: Just for what it's worth, the development version of Cabal builds just fine if I edit the arArgs to 'rs' rather than 'q' in GHC.hs
12:53:01 <Cale> They both have the same non-strict semantics.
12:53:19 <roconnor> Cale: exactly, which is why I wonder what the termonology on the semantic side is.
12:53:30 <dcoutts_> telemachus: you mean the Cabal lib itself builds, or it enables other stuff to build correctly?
12:53:44 <Cale> You'd need to enrich your semantics with more details.
12:53:45 <telemachus> dcoutts_: the Cabal lib itself
12:53:56 <dcoutts_> telemachus: ok
12:54:01 <Cale> and it would turn into more of an operational semantics then
12:54:08 <Cale> hmm
12:54:23 <telemachus> dcoutts_: my real goal is to install the whole Haskell platform
12:54:23 <roconnor> no no, you don't need to go to operation semantics
12:54:40 <telemachus> but I've run into so many problems, that I'm taking it apart and looking at the pieces
12:54:44 <roconnor> we are just defining the denotations of programs
12:54:45 <Cale> Like, if your semantics encoded information about space and time usage, then the differences would become apparent.
12:54:46 <dcoutts_> telemachus: right, that'll be the test
12:55:19 <roconnor> [[ let x = 1:x in x ]] = ???
12:55:23 <dcoutts_> telemachus: if you're just trying to make it work rather than valiantly trying to fix it all for us then you might use the OS X binary rather than building it from source.
12:55:35 <telemachus> dcoutts_: I keep finding more places where I need to reset the arguments to ar.
12:55:43 <roconnor> maybe that isn't the best example to start with
12:55:45 <dcoutts_> telemachus: though you still need the Cabal lib fix to be able to build the HP
12:55:48 <roconnor> maybe it is okay
12:56:05 <telemachus> dcoutts_: I have ghc itself installed via the binary, but it was unable to build the HP
12:56:14 <telemachus> so I decided to compile a second version and try that
12:56:27 <telemachus> with, um, mixed results
12:56:29 <dcoutts_> telemachus: how many? I would expect just in Cabal and if you're building ghc then also in one place in ghc's configure/makefiles.
12:56:30 <telemachus> :0
12:57:02 <dcoutts_> telemachus: it's not the fault of ghc that the HP build fails, it's the same issue with Cabal calling ar.
12:57:46 <telemachus> Hmmm...ok, then maybe I've just gotten myself turned around
12:58:43 <telemachus> dcoutts_: I edited aclocal.m4 and the GHC.hs file for Cabal, and I'm now trying to build ghc with all the extended libraries
12:58:47 <telemachus> so we'll see...
12:58:51 <dcoutts_> ok
13:12:16 <liars> HOLY SHIT http://shop.ebay.ca/items/?_nkw=donald+trump+audio&_sacat=0&_trksid=p3286.m270.l1313&_odkw=donald+trump&_osacat=0
13:13:40 --- mode: ChanServ set +o mauke
13:14:40 --- mode: mauke set -o mauke
13:17:53 <travisbrady> anyone know where i can find examples of c2hs binding files?
13:20:38 * edwardk waves hello.
13:21:32 * Twey waves howdy.
13:24:05 <Jig> when will haskell have objects?
13:24:15 <edwardk> Jig: when it becomes another language ;)
13:24:18 <Zao> Never if I have any say.
13:24:26 <Zao> You can of course fake many aspects of OO, C-like.
13:24:30 <Jig> O'Haskell
13:24:42 <mauke> it already has them
13:24:46 <mauke> see OOHaskell
13:25:08 <Jig> O'Horrible
13:25:08 <Jig> was just kiddin
13:26:15 <Jig> what degree do you think i should gt electricalenginerr+applied math? in 2 eyars will have a very strong knowledge (already have...) of programming. knowing haskell,python,C,some Java and C++ and a little of a lot of others. havig studied several courses myself on algorithms, discrete math etc.
13:26:20 <Alpounet> in which package can I find Data.Tree ?
13:26:38 <edwardk> jig: and why do you think a deeper integration into the language would then be any better? =)
13:26:49 <Alpounet> I mean a simple, just basical Tree.
13:27:06 <Jig> edwardk; i dont?
13:27:19 <Jig> Alpounet: i have BST and a RBT i cna send you fi you want
13:28:28 <edwardk> jig: i started as an electrical engineering/computer engineering/engineering mathematics major, switched to actuarial science and economics and wound up graduated as a pure math/comp sci guy in a very short time table, so i'm not one to talk about making long term plans ;)
13:28:44 <Alpounet> Jig, they aren't on hackage ?
13:31:05 <Jig> BST is done basically i use it for some stuff but it could be improved a lot of ways and have more functions, it also isnt very optimized
13:36:22 <edwardk> jig: anything distinguish it from say data.map?
13:37:15 <tsLight> I was wondering if anyone could give me a hint on this
13:37:27 <tsLight> i have made a program that converts propositional formulas to conjunctive normal form
13:37:30 <tsLight> for example
13:37:41 <tsLight> p -> ((p -> q) -> q)
13:37:45 <tsLight> would be transformed to
13:37:54 <tsLight> (~p | (p | q)) & (~q | q)
13:38:06 <tsLight> now, what I would like to do is to print the result this way:
13:38:13 <tsLight> (~p | p | q) & (~q | q)
13:38:29 <tsLight> that is, only expressions that are AND'ed are parenthised (except if they are atomic)
13:38:51 <tsLight> my Formula is an algebraic type, binary-tree-like
13:38:59 <tsLight> any ideas?
13:39:19 <EvilTerran> what, "data Formula = And Formula Formula | Or Formula Formula | Not Formula | Var Var" kinda thing?
13:39:20 <vixey> tsLight: you can do CNF by a rewriting system
13:39:36 <vixey> that's the simplest algorithm I know for doing CNF
13:39:37 <tsLight> EvilTerran, exactly
13:39:37 <edwardk> 1.) ~q | q in CNF? second i'd recommend using showsPrec
13:39:43 <tsLight> vixey, what do you mean?
13:39:53 <vixey> you never heard of rewriting systems?
13:39:55 <edwardk> tsLight look at Text.Show
13:40:00 <tsLight> edwardk, yes its CNF, I dont evaluate it to true/false, i just show an equivalent formula in CNF
13:40:03 <EvilTerran> CNF expressions are isomorphic to [[(Bool, Var)]]
13:40:29 <vixey> oh you already did the CNF conversion
13:40:41 <tsLight> vixey, yes :)
13:40:51 <vixey> how ddid you do it?
13:41:01 <edwardk> tsLight: iirc cnf entails elimination of clauses that contain both q ^ ~q for any q in the set of variables =)
13:41:17 <EvilTerran> if you can re-express it in that type, that'd be more straightforward to print
13:41:34 <tsLight> several transformations: 1) Eliminate <->; 2) Eliminate ->; 3) Move not's inwards; 4) Distribute and's over or's
13:41:36 <edwardk> tsLight: but Text.Show has the machinery you want, showsPrec can manage the different precedence of | and &
13:41:36 <EvilTerran> tsLight, or you could do something like showsPrec, as edwardk suggests
13:41:46 <dolio> tsLight: edwardk is right. Figure out how the haskell libraries print operators with Show, and you'll know how to do it.
13:42:10 <tsLight> ok, right now I am sending it into a string
13:42:13 <edwardk> it turns out to be 2-3 lines using showsPrec and the combinators
13:42:15 <tsLight> will check out what you are saying
13:42:18 <edwardk> tsLight thats fine
13:42:24 <vixey> tsLight: yeah I think as a termrewriting system the program is much simpler
13:43:23 <edwardk> in fact when you need a 'precedence' for the operators you can steal the precedence of the boolean operators straight from the haskell prelude ;)
13:43:28 <pk> is it right to define recursive functions in FRP without mentioning the time delta used ?
13:44:17 <pk> because the result depends on it
13:44:33 <pk> you can't say the function is pure anymore
13:44:37 * edwardk just had a slightly disturbing thought of using his cheesy applicative tracing machinery for FRP.
13:45:03 <edwardk> pk: you usually define your function as a function of time, so the delta is known
13:45:20 <edwardk> knowledge of the sampling interval is a bit of a side effect or at least an event
13:46:08 <tsLight> edwardk, and how do I do that for printing? I am reading http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Show.html and I dont understand how I would use ShowsPrec to do what i want
13:46:40 <edwardk> tslight: lemme work up an example
13:47:11 <edwardk> tslight: what does your adt for formulae look like?
13:47:17 <tsLight> edwardk, thanks, if you want me to paste my printing function let me know
13:47:49 <tsLight> data Formula = At AtomicFormula | Neg Formula  | Bin Op Formula Formula
13:48:05 <tsLight> data Op = And | Or | Implies | DoubleImplies
13:48:47 <vixey> tsLight: but CNF doesn't have anything to do with printing out that stuff right?
13:48:56 <tsLight> at first I wanted to make a printing function that prints a general formula, parenthising only when its necessary
13:49:01 <tsLight> but then i realized I only need to print CNF
13:49:03 <tsLight> not general case
13:49:10 <vixey> well you should do the general case
13:49:19 <vixey> it's easier/more natural to deal with than the specific case
13:49:26 <tsLight> I have the same problem with the general case :)
13:49:34 <tsLight> I dont know how to put parenthesis only when its needed
13:49:38 <tsLight> according to the precedences
13:49:41 <vixey> I will show you how
13:49:46 <tsLight> :O
13:49:55 <vixey> http://andrej.com/plzoo/html/calc.html
13:50:07 <vixey> see what string_of_expression does
13:51:30 <tsLight> I've never seen 'match' before
13:51:37 <edwardk> almost done
13:51:38 <vixey> well it's ocaml
13:51:50 <vixey> match is like case
13:52:06 <vixey> anyway this guy writes very good code you can learn a lot from him that applies to haskell
13:52:40 <tsLight> I still dont understand that function :(
13:53:01 <vixey> you will, just think about it a bit -- will probably come as a flash of inspiration
13:53:11 <tsLight> its matching the precedences of the language operators
13:53:15 <tsLight> with the aritmetic expressions?
13:55:22 <tsLight> ah no
13:55:27 <tsLight> he is doing the precedences himself
13:55:38 <Jig> god
13:55:46 <Jig> C++ APIs are just generally et horrible?
13:56:35 <monadic_kid> C++ itself is horrible what do you expect the APIs to look
13:56:39 <monadic_kid> like
13:56:56 <Alpounet> that's wrong.
13:57:07 <monadic_kid> what's wrong?
13:57:14 <monadic_kid> my statement?
13:57:15 <Alpounet> "C++ itself is horrible [...]"
13:57:29 <monadic_kid> i'm far from wrong
13:57:36 <Alpounet> from truth too.
13:57:51 <monadic_kid> explain
13:58:05 <vixey> I'm guessing that 'horrible' might be a matter of opinion
13:58:16 <Alpounet> C++ is old, it has its historical context.
13:58:37 <vixey> really boring but #haskell-blah migth be a good place to talk about C++
13:58:41 <Alpounet> But things like Boost are great, and are close of the modern C++ uses and ideas.
13:58:54 <Alpounet> Let's stop talking about that, btw.
13:59:09 <monadic_kid> not yet, i didn't get a a chance
13:59:17 <vixey> monadic_kid: try #haskell-blah
13:59:39 <Alpounet> Must go, but we can talk about it later, no problem.
13:59:41 <Alpounet> bye.
14:00:04 <skorpan> "<Alpounet> But things like Boost are great"
14:00:09 <skorpan> proof that C++ is shit
14:00:13 <vixey> skorpan sigh
14:00:17 <monadic_kid> that was kind of pathetic
14:00:17 <skorpan> (kidding, geez)
14:00:25 <skorpan> (but not really though)
14:00:31 <dolio> I must say, the algorithms in the STL are nicely abstracted in their way.
14:00:32 <edwardk> something like *Main> pp (Bin And (Bin Or (At (Var "x")) (At (Var "y"))) (At (Var "z")))
14:00:32 <edwardk> "(x|y)&z" ?
14:00:37 <monadic_kid> Tell me something that I don't already know and then leave
14:01:00 <edwardk> @hpaste
14:01:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:01:04 <dolio> And the presentation on ranges that someone gave recently is interesting.
14:01:30 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4734#a4734
14:01:52 <dolio> Left me thinking, "is it a deficiency that we can't associate a uvector with a queue, and partial sort on their combination?"
14:02:07 <dolio> But then I thought, "why would anyone ever want to do that?"
14:02:13 <tsLight> edwardk, checking it out
14:02:41 <edwardk> tsLight: i decided to be anal retentive: "Show" should generally generate legal Haskell. the desired formatting isn't legal haskell, so i made another class
14:03:18 <tsLight> edwardk, I dont get what you mean, Show will not display the formulas as I want
14:03:23 <edwardk> tsLight: ppPrec ~ showsPrec and pp ~ show except 'pretty' not 'exact' haskell code.
14:03:42 <dolio> Although, it is a bit of a bummer that the stuff I've written only works for uvectors, whereas there's a bunch of other competing array implementations, and my stuff doesn't have anything specific to do with the implementation, other than needing certain operations.
14:03:49 <edwardk> tsLight: the meaning of Show should be literal haskell code, so i didn't just define a Show instance is what i'm saying
14:04:20 <tsLight> edwardk, ah, right
14:04:20 <Jig> edwardk: BST is not balanced so insert worst case is O(N^2) i wouldnt recommend using it in general since it isnt optimized
14:04:23 <edwardk> tsLight: both of those "Pretty" instances could be made instance of show
14:04:32 <Jig> RBT is faster and balanced
14:04:37 <Jig> but has no delete yet
14:04:38 <edwardk> Jig: fair enough. i'll stick to optimizing data.map ;)
14:04:54 <tsLight> edwardk, some strange character '∙' shows up in your pasted text, where did that come from?
14:04:55 <tsLight> :p
14:05:25 <edwardk> tsLight ah thats a => but your client must not like unicode. oh the dots sorry about that pasted it out of vim
14:05:30 <edwardk> replace with .
14:05:36 <monadic_kid> dolio: That someone, his name is Andrei Alexander and he's a well known C++ guru and wrote the book about modern C++ design/code. It looks like he's mostly given up on C++ and gone to D now
14:05:39 <tsLight> ok
14:05:45 <edwardk> my vim lifts periods to center dots
14:06:00 <edwardk> as long as they aren't in position where it would be interpreted as a namespace delimiter
14:06:06 <ziman> edwardk, how did you make it to do so? :)
14:06:22 <edwardk> ziman: some horrible regexes
14:06:35 <ziman> because that sounds quite cool :)
14:07:33 <edwardk> ziman: it also drops in lambdas and foralls, and some things on file load but reverts on saving, but its got some issues, it shows lambdas instead of \'s inside of "'s because i didn't make the regex smart enough to spot that its in a string
14:07:45 <mauke> Alexandrescu
14:08:10 <tsLight> edwardk, so that code works for the general case or just for CNF?
14:08:19 <monadic_kid> *Andrei Alexandrescu
14:08:32 * Cale can't follow the random comments about C++ which seem to be interspersed with the other conversations.
14:08:48 <edwardk> tslight for anything
14:08:54 <edwardk> tslight if you need parens it puts them in
14:09:06 <edwardk> tslight so if you wrap an and in an or it'll put parens around it
14:09:22 <tsLight> edwardk, I have to take some time to understand this first =)
14:09:55 <ziman> edwardk, that's nice; do you have the filetype (or is it something else?) plugin available somewhere?
14:10:15 <edwardk> ziman: i can toss it up in my haskell folder on comonad.com but it comes with no warrantees ;)
14:11:26 <Jig> C++ in blah
14:12:00 <ziman> edwardk, i understand that ;) please do if you will, i'd like to see how it's done
14:12:25 <vixey> tsLight: (edwardks code works the same as the one I linked btw)
14:12:40 <tsLight> ok
14:12:56 <edwardk> ziman: http://comonad.com/haskell/haskell.vim -- i don't know if the file encoding shows up right there, i'll tarball if it if won't download right for you
14:14:27 <ziman> edwardk, it shows okay, thank you!
14:14:51 <edwardk> ziman: if you don't want a dot to lift to center wait a sec and the imap will fail to fire. or just save the file and everything will reload
14:15:38 <edwardk> you can see i cut down some of the more gratiutous formatting ;)
14:16:49 <edwardk> the fancy looking regexes in the haskell->utf8 are to avoid converting parts of bigger symbols is all
14:18:06 <athos> @type factor
14:18:07 <athos> @type factors
14:18:07 <lambdabot> Not in scope: `factor'
14:18:08 <lambdabot> Not in scope: `factors'
14:18:11 <athos> eh.
14:18:16 <ziman> edwardk, works great ;)
14:18:26 <JohnDigs> hey, anyone know of a simple way to keep a count to generate unique integers?
14:18:31 <ziman> this is what i have been looking for "_
14:18:45 <EvilTerran> athos, fairly straightforward to write via a two-parameter recursive function
14:18:47 <Cale> JohnDigs: There are a few ways to manage that.
14:18:56 <edwardk> ziman: you may want to kill the greek letters they get a little annoying at times if you don't really like greek because they sort of pause your typing unexpectedly at times
14:19:05 <EvilTerran> there's probably cleverer ways of writing it, too
14:19:07 <edwardk> and i didn't make them as smart as i made the symbol operators
14:19:21 <JohnDigs> I've looked at Reader monads but I'm pretty new to monads :(
14:19:28 <edwardk> so alphaNum becomes αNum
14:19:29 <Cale> JohnDigs: You would want a state monad
14:19:37 <Cale> JohnDigs: (or a unique supply monad)
14:19:54 <athos> > length []
14:19:55 <lambdabot>   0
14:20:09 <Cale> JohnDigs: But you could also just handle it more manually by parameter passing -- that can get tedious though, and it's what the state monad abstracts.
14:20:15 <edwardk> fresh = do x <- get; put (x + 1); return x
14:20:17 <JohnDigs> is that the Control.Monad.State.Lazy one?
14:20:18 <tsLight> edwardk, what is the "ppPrec 11 f" doing in "ppPrec d (Neg f) = showParen (d > 10) $ showString "~" . ppPrec 11 f"? Why the magic 11?
14:20:20 <Cale> JohnDigs: If you want, I can write you a simple example.
14:20:33 <tsLight> edwardk, is it the max. precedence in haskell?
14:20:35 <edwardk> tsLight 'application has precedence 10
14:20:41 <Jig> @type join
14:20:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:20:48 <vixey> :t modify
14:20:49 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:20:53 <athos> > filter (length `isn't` (>3)) [[1,2],[3,4,5],[4,5,6,7,8],[9,10],[11..200]]
14:20:54 <Jig> > join (+) (1,2)
14:20:54 <lambdabot>   Not in scope: `isn't'
14:20:55 <lambdabot>       No instance for (Num (t, t1))
14:20:55 <lambdabot>        arising from a use of `+' at <inte...
14:21:01 <Jig> > join (*) [(1,2)]
14:21:02 <lambdabot>       No instance for (Num [(t, t1)])
14:21:02 <lambdabot>        arising from a use of `*' at <in...
14:21:03 <vixey> :t put
14:21:04 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
14:21:05 <Jig> > join (*) [1,2]
14:21:06 <lambdabot>       No instance for (Num [t])
14:21:06 <lambdabot>        arising from a use of `*' at <interact...
14:21:21 <vixey> :t join (*)
14:21:22 <lambdabot> forall a. (Num a) => a -> a
14:21:26 <EvilTerran> Jig, what are you trying to do?
14:21:27 <edwardk> tsLight: so you want applications on the right of an application to require parens i.e. a (b c)
14:21:30 <athos> ah, it's data.function.predicate
14:21:54 <EvilTerran> > uncurry (*) (1,2)
14:21:55 <lambdabot>   2
14:21:59 <edwardk> tsLight and so i chose the precedence levels to be compatible with Shows' showsPrec incase you used calls to showsPrec for other data types
14:22:39 <ziman> edwardk, yes, i'll use it for a while and see what modifications I'd make, now that I know how ;) thanks again
14:22:48 <tsLight> edwardk, I dont get the last you said, you havent used showsPrec in your example
14:22:50 <Jig> > curry (+) 1 2
14:22:51 <lambdabot>       Overlapping instances for Show ((a, b) -> (a, b))
14:22:51 <lambdabot>        arising from a...
14:22:58 <Jig> > curry 1 2
14:22:59 <lambdabot>       Overlapping instances for Show (b -> c)
14:22:59 <lambdabot>        arising from a use of `s...
14:23:08 <vixey> > curry (uncurry (+)) 1 2
14:23:10 <lambdabot>   3
14:23:20 <Flugan> Is there any function that combines two filter functions (a -> Bool) -> (a -> Bool) -> a -> Bool or equivalent
14:23:31 <mauke> :t (.)
14:23:32 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:23:40 <edwardk> tsLight: but you could if you wanted to pretty print an Int or a String or something
14:23:42 <mauke> wait, combine them how?
14:23:50 <tsLight> edwardk, ah
14:23:55 <edwardk> tsLight i.e. if your AtomicFormula was more cplicated than the cheesy one i put in there
14:24:08 <mauke> :t liftM2 (&&)
14:24:09 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
14:24:14 <tsLight> edwardk, yeah, mine was just a Char :P
14:26:11 <edwardk> filter ((&&) <$> f <*> g) -- works if you want to get all applicative about it but liftM2 (&&) or liftA2 (&&) are possibly clearer
14:26:57 * EvilTerran notes that a little work with typeclass shennanigans would make it possible to just use (&&) or (||)
14:27:04 <Jig> whats is &&
14:27:08 <EvilTerran> ?src (&&)
14:27:09 <lambdabot> True  && x = x
14:27:09 <lambdabot> False && _ = False
14:27:15 <edwardk> tsLight: you can improve what i wrote there, by lowering the precedence on one side of the binary operator to get infixr/infixl like operators to work kinda right
14:27:17 <Jig> i mean everything XX is applicative?
14:27:22 <Jig> and XXX are arrows
14:27:39 <EvilTerran> (&&) has nothing to do with applicative
14:27:42 <Jig> and all rockets are monads!
14:27:51 <tsLight> edwardk, yeah I will do some experiments
14:27:55 <Jig> <X> is appplicative?
14:27:55 <Cale> JohnDigs: for you: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4735#a4735
14:28:00 <Jig> what is && then?
14:28:04 <monadic_kid> jig: <*>
14:28:05 <edwardk> jig: 'a ->' is an Applicative functor, you can use pure to make a function that ignores its argument
14:28:10 <monadic_kid> jig: <$> == fmap
14:28:24 <Cale> JohnDigs: That's an example of using manual parameter passing and using the state monad to relabel the nodes of a tree from left to right with fresh labels.
14:28:24 <EvilTerran> Jig, look at the definition lambdabot gave above.
14:28:27 <edwardk> jig: <$> is fmap with a different name, <*> is 'ap' from Control.Monad for applicatives.
14:28:27 <vixey> :t (<$>)
14:28:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:29:13 <edwardk> > pure "hello" "world"
14:29:14 <lambdabot>       Ambiguous occurrence `pure'
14:29:14 <lambdabot>      It could refer to either `Control.Appl...
14:29:15 <Jig> > ((Just 1) +) <$> (Just 5)
14:29:16 <lambdabot>       No instance for (Num (Maybe t))
14:29:16 <lambdabot>        arising from a use of `+' at <in...
14:29:16 <monadic_kid> pure x <*> == <$>
14:29:29 <Jig> @ type (<$>)
14:29:37 <Cale> JohnDigs: Hopefully it helps a bit to understand those two approaches
14:30:46 <monadic_kid> :t (<*>)
14:30:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:31:11 <monadic_kid> :t pure id
14:31:12 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> a)
14:31:13 <JohnDigs> Cale: cheers man, I've been trying to find some good documentation for this State thingy
14:31:32 <Flugan> thank you
14:31:33 <JohnDigs> always better with an example
14:32:14 <edwardk> > Control.Applicative.pure "Hello" "World"
14:32:16 <lambdabot>   "Hello"
14:32:20 <Cale> JohnDigs: The important thing to understand is that all the State monad does is wrap that parameter passing style up so that you don't have to do all the wiring by hand.
14:32:44 <Cale> JohnDigs: So you can't do magic with it, it's still just a bunch of pure functions :)
14:32:47 <roconnor> @quote StateMonad
14:32:48 <lambdabot> No quotes match.
14:32:52 <roconnor> @quote MonadState
14:32:53 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:32:56 <roconnor> :/
14:33:06 <roconnor> @quote state
14:33:06 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
14:33:08 <roconnor> @quote state
14:33:09 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
14:33:20 <roconnor> @slap lambdabot
14:33:20 * lambdabot smacks lambdabot about with a large trout
14:33:31 <roconnor> lambdabot: you said you'd never forget
14:34:00 <vixey> ?. ++ . read . show . state ?. ++ . read . show . state
14:34:01 <Jig> > (1,2,3)+(4,5,6)
14:34:06 <roconnor> lambdabot: but you always forget!!
14:34:07 <Jig> > (1,2,3) ++ (4,5,6)
14:34:08 <lambdabot> Plugin `compose' failed with: Unknown command: "++"
14:34:10 <lambdabot>       No instance for (Num (t, t1, t2))
14:34:12 <lambdabot>        arising from a use of `+' at <...
14:34:14 <lambdabot>   Couldn't match expected type `[a]'
14:34:17 <inetic> hi guys, I'm trying to compile an example from this page: http://abstractabsurd.blogspot.com/2008/04/intro-to-sdl-with-haskell.html but it complains with this msg: "undefined reference to `__stginit_SDLzm0zi5zi5_GraphicsziUIziSDL_'", I'm guessing that I need to link the SDL library but what are the flags for that? thanks in advance
14:34:23 <roconnor> lambdabot: you are a big fat liar
14:35:05 <Cale> inetic: Sounds like you forgot --make
14:35:26 <inetic> Cale: "ghc --make" ?
14:35:30 <Cale> inetic: yeah
14:35:44 <monadic_kid> --make ModuleThatContainsMain
14:36:33 <inetic> Cale, monadic_kid, oh, gread it compiled :-), thanks
14:36:45 <roconnor> @remember MonadState Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
14:36:45 <lambdabot> Okay.
14:36:46 <inetic> heh, by gread I ment great
14:36:52 <roconnor> lambdabot: ya right
14:37:28 <edwardk> roconnor: clearly you should just learn to separate Church and state.
14:40:36 <kynky> tell that to the people living in the vatican cit
14:40:42 <kynky> city
14:48:09 <Jig> edwardk ++
14:54:41 <gwern> @quote dick
14:54:41 <lambdabot> No quotes match. Just try something else.
14:54:53 <gwern> @remember Axman6 what's @flush do? saves stuff to dick?
14:54:53 <lambdabot> Done.
14:55:01 <gwern> @quote MonadState
14:55:01 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
14:55:10 <gwern> @quote ephemeral
14:55:11 <lambdabot> No quotes match. :(
14:55:18 <gwern> @remember Baughn Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance.
14:55:19 <lambdabot> Good to know.
14:55:26 <gwern> @quote crummy
14:55:26 <lambdabot> No quotes match. Are you on drugs?
14:55:31 <gwern> @remember bos Crummy languages give static types a bad name.
14:55:32 <lambdabot> I will remember.
14:57:49 <tsLight> edwardk, I am trying to make infixl and infixr work based on your code, would you mind telling me whats wrong here? http://pastebin.com/m49c72e39
14:58:07 <tsLight> I get Syntax error in input (unexpected symbol "der")
14:59:39 <edwardk> tsLight: i'm betting you have tabs and spaces mixed in a way that is confusing haskell
14:59:56 <edwardk> also feel free to define p = prec op to cut down on the verbosity ;)
15:00:34 <tsLight> ok
15:02:36 <tsLight> I changed it to spaces and now I get "unexpected `}', possibly due to bad layout", but there is no "}" in my file :P
15:03:29 <edwardk> tslight: the problem is der and izq have to line up
15:04:30 <edwardk> or if the former is indented less then it doesn't realize that der starts a new statement, and if the latter is indented less then it thinks you ended the where clause and doesn't know what to do with this random garbage string it can't figure out =)
15:04:51 <tsLight> well they are aligned
15:04:54 <tsLight> I just re indented it using spaces
15:05:04 <tsLight> let me change the case
15:05:06 <tsLight> to see if its that
15:05:24 <tsLight> no, still doesnt work :P
15:05:48 <ordnungswidrig> is there something for (a -> m b -> c -> r) -> ma -> mb -> mc -> mr
15:06:08 <ordnungswidrig> like a liftN where one of the arguments is not lifted?
15:07:35 <applicative_kid> ordnungswidrig: applicative functors
15:08:11 <ordnungswidrig> applicative_kid: you me return f `ap` return a `ap` b `ap` return c ?
15:08:16 <ordnungswidrig> s/me/mean/
15:08:50 <tsLight> edwardk, ok i fixed it :P
15:08:52 <ordnungswidrig> /who #haskell-in-depth
15:08:54 <edwardk> tslight: you clearly have a layout problem. =)
15:08:57 <edwardk> hah what was it?
15:08:59 <tsLight> edwardk, you have been really helpful
15:09:12 <tsLight> edwardk, I indented the function itself, so all "=" align
15:09:14 <edwardk> we aim to please
15:09:22 <pumpkin_> moo
15:09:43 * edwardk goes pumpkin tipping.
15:10:10 <jmcarthur> @pl (a -> m b -> c -> r) -> m a -> m b -> m c -> m r
15:10:11 <lambdabot> (line 1, column 4):
15:10:11 <lambdabot> unexpected ">"
15:10:11 <lambdabot> expecting variable, "(", operator or ")"
15:10:20 <jmcarthur> djinn, duh
15:10:20 <gwern> @flush
15:10:21 <pumpkin_> djinn?
15:10:22 <jmcarthur> and that won't work
15:10:30 <pumpkin_> tsk tsk
15:10:41 <jmcarthur> @djinn (a -> m b -> c -> r) -> m a -> m b -> m c -> m r
15:10:41 <lambdabot> -- f cannot be realized.
15:10:44 <jmcarthur> failage
15:10:57 <pumpkin_> epic
15:11:00 <pumpkin_> just like a morphism
15:12:46 <ordnungswidrig> My real problem is: i have an constructor D a b c and a function f :: IO b and I want to lift D into IO but in a way that the lifted Constructor is d' :: a -> m b -> c
15:13:13 <ordnungswidrig> sorry the lifted Constructor is d' :: a -> m b -> D
15:13:19 <ordnungswidrig> ouch
15:13:26 <ordnungswidrig> d' :: a -> m b -> c -> D
15:13:37 <hatds> a -> mb -> c -> m D ?
15:13:41 <hatds> don't you mean?
15:13:45 <ordnungswidrig> hatds: yes, that's it
15:13:58 <ordnungswidrig> *d'oh*
15:14:06 <ordnungswidrig> it's 0:00 local time
15:16:16 <applicative_kid> > let f x y z = x + y + z
15:16:17 <lambdabot>   <no location info>: parse error on input `;'
15:16:17 <int-e> unlikely
15:20:28 <jmcarthur> :t \f a b c -> (pure f <*> a) <**> pure ($b) <*> c
15:20:30 <lambdabot> forall a (f :: * -> *) a1 a2 b. (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> a1 -> f a2 -> f b
15:20:35 <FunctorSalad> hmm shouldn't there be mapA in Control.Applicative?
15:20:51 <jmcarthur> which does what?
15:21:03 <applicative_kid> :t <$>
15:21:05 <lambdabot> parse error on input `<$>'
15:21:06 <jmcarthur> :t Data.Traversable.mapA
15:21:07 <lambdabot> Not in scope: `Data.Traversable.mapA'
15:21:08 <applicative_kid> :t (<$>)
15:21:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:21:17 <jmcarthur> :t Data.Foldable.mapA
15:21:18 <lambdabot> Not in scope: `Data.Foldable.mapA'
15:21:23 <jmcarthur> err, something?
15:21:53 <applicative_kid> > id <$> [1..10]
15:21:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:21:55 <FunctorSalad> jmcarthur: like mapM
15:22:02 <Jedai> @hoogle liftA
15:22:02 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
15:22:02 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:22:02 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
15:22:22 <Jedai> :t mapM
15:22:22 <jmcarthur> :t traverse
15:22:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:22:24 <lambdabot> Not in scope: `traverse'
15:22:29 <jmcarthur> :t Data.Traversable.traverse
15:22:30 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
15:22:39 <FunctorSalad> Foldable is excessive, Applicative is enough: mapA f = foldr (\x acc -> liftA2 (:) (f x) acc) (pure [])
15:22:39 <jmcarthur> like that?
15:22:50 <jmcarthur> oh, you just mean over lists
15:23:00 <jmcarthur> well, traverse suffices for that as well
15:24:14 <ordnungswidrig> > let liftM3' f m1 m2 m3       = do { x2 <- m2; return (f m1 x2 m3) } in let f a b c = (a,b,c) in (liftM3' f) 1 (Just 2) 3
15:24:15 <lambdabot>   Just (1,2,3)
15:24:54 <Jig> public static HashMap<String, Integer> countWords(String s) {
15:24:57 <Jig> is that generics?
15:25:04 <Jig> or parametric polymorphism?
15:25:32 <ordnungswidrig> jig: in java it's called "generics" or "parametrized type"
15:25:33 <edwardk> jig: generics
15:26:44 <Jig> geenrics ~= parametric polymorphism?
15:26:52 <ordnungswidrig> ~=?
15:27:16 <EvilTerran> "approximately equal"
15:27:34 <EvilTerran> like some people write, say, "~5" for "approximately five"
15:27:37 <Jig> roughly equal to
15:27:38 <lament>  ≅
15:27:40 <applicative_kid> Jig: it's all parametric polymorphism, the difference comes in how you implement it
15:28:01 <applicative_kid> Jig: Java, .NET and C++ implement it in 3 different ways
15:29:03 <Berengal> ≃
15:29:07 <ordnungswidrig> me goes to sleep now
15:31:15 <applicative_kid> Jig: generic constraints is bounded quantification, like how type classes do the same
15:31:57 <applicative_kid> except that generic constraints using interfaces such when it comes to operators
15:32:06 <applicative_kid> *using interfaces suck
15:33:59 <applicative_kid> it gets a bit confusing when you talking about existential types and the fact that type constaints is form of existential
15:34:09 <applicative_kid> *type constraints
15:34:56 <applicative_kid> there exists a T such that T is an instance of a type class or such that T implements an inteface
15:35:40 <applicative_kid> or is that just brain damaged thinking?
15:36:10 <Jig> hmm would you use maybe for readFile that fails or a new monad data Result a = Failure | Success a
15:36:34 <jberryman> haddock is failing with "parse error in doc string: ... " and I don't know why. everything looks okay to me.
15:36:40 <hatds> all I know is existentials and foralls are easily confused :)
15:37:24 <applicative_kid> well my last statement wasn't about existential types
15:37:27 <hatds> I would use maybe
15:37:46 <jberryman> Jig: yeah, no need to rename Maybe
15:37:59 <applicative_kid> You can view Maybe or Result/Either as the same thing except you can attach a message with Result/Etiher
15:38:52 <roconnor> @pl \x -> (log (1-x), log (1+x))
15:38:52 <lambdabot> ap ((,) . log . (-) 1) (log . (1 +))
15:38:57 <EvilTerran> Maybe is (almost) equivalent to Either ()
15:39:07 <roconnor> > ap ((,) . log . (-) 1) (log . (1 +))
15:39:08 <lambdabot>       Overlapping instances for Show (b -> (b, b))
15:39:08 <lambdabot>        arising from a use ...
15:39:22 <roconnor> > ap ((,) . log . (-) 1) (log . (1 +)) 0.406
15:39:23 <lambdabot>   (-0.5208759596194922,0.34074879338847325)
15:39:26 <applicative_kid> maybe >>= maybe >>= maybe >>= maybe <--- if one fails the whole result is nothing
15:40:13 <applicative_kid> @src Monad Either
15:40:13 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:41:00 <hatds> also useful is mplus:  maybe `mplus` maybe `mplus` maybe ...  = the first Just, or Nothing otherwise
15:41:48 <applicative_kid> @src Monad (Either a)
15:41:48 <lambdabot> Source not found. It can only be attributed to human error.
15:42:11 <Twey> @src (Either a) Monad
15:42:11 <lambdabot> Source not found. My pet ferret can type better than you!
15:42:15 <Twey> Hmph
15:42:21 <Twey> @src (Either a) (>>=)
15:42:22 <lambdabot> Source not found. It can only be attributed to human error.
15:42:27 * Twey shrugs.
15:42:46 <applicative_kid> i need a cheatsheet for lambdabot
15:43:08 <Jig> yeha like Parsec Left err Right result
15:43:08 <Jig> lol im coding Java again , has been a while.
15:43:08 <Jig> not i jsut want to make all methods static...
15:43:31 <applicative_kid> ouch
15:43:53 <applicative_kid> can't you use another language targetting the JVM?
15:46:51 <Jig_> then im just programming java in clojure
15:51:19 <jberryman> ah, so including a forward slash in your comment is an excuse for haddock to fail mysteriously. noted.
15:54:50 <applicative_kid> Bitstream Vera Sans Mono is an awesome font
15:55:02 <tsLight> edwardk, more trouble :P : http://pastebin.com/d3d3c6fa2
15:55:11 <tsLight> I am trying to make it print parenthesis only when strictly necessary
15:55:31 <tsLight> however when printing the formula: Bin And (Bin And (Bin Or (Bin Or (Neg (At 'a')) (At 'b')) (At 'a')) (Bin Or (Neg (At 'b')) (At 'a'))) (Bin And (At 'a') (Neg (At 'c')))
15:55:40 <tsLight> I get "(~a | b | a) & (~b | a) & (a & ~c)"
15:56:03 <tsLight> where it should be "(~a | b | a) & (~b | a) & a & ~c"
15:56:18 <Ralith> applicative_kid: seconded
16:02:03 <edwardk> tslight: sounds like your &'s are associated the wrong way in either the adt or the pretty printer
16:02:33 <tsLight> but why does it add parenthesis only at the end?
16:02:34 <tsLight> why not
16:02:39 <tsLight> "((~a | b | a) & (~b | a)) & (a & ~c)"
16:03:27 <gwern> hm. what's the best idiom for using getArgs? I want to do args <- getArgs; let delim = head args, but set delim to '%' if there are no arguments...
16:03:36 <gwern> @hoogle Data.Maybe
16:03:36 <lambdabot> module Data.Maybe
16:03:36 <lambdabot> Data.Maybe data Maybe a
16:03:36 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
16:03:37 <edwardk> tslight: i'm going to guess because you probably told it to increase the precedence only on one side
16:03:47 <gwern> @hoogle [a] -> Maybe a
16:03:48 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
16:03:48 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
16:03:48 <lambdabot> Prelude head :: [a] -> a
16:03:49 <tsLight> edwardk, you are right :P
16:03:58 <gwern> > listToMaybe []
16:04:00 <lambdabot>   Nothing
16:04:06 <gwern> > listToMaybe ['@']
16:04:07 <lambdabot>   Just '@'
16:04:10 <tsLight> edwardk, but shouldnt i do that to adjust for infixl/infixr?
16:04:23 <tsLight> add 1 to precedence only on 1 side
16:04:35 <tsLight> left for left-associative, and right for right-associative
16:04:36 <gwern> @hoogle Maybe a -> a -> a
16:04:36 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:04:37 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:04:37 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
16:04:55 <gwern> > fromMaybe '%' $ listToMaybe []
16:04:56 <edwardk> tslight: i''m guessing the problem you have is that you have &'s associated both ways in there.
16:04:56 <lambdabot>   '%'
16:05:00 <gwern> yay!
16:05:07 <dfadf>  
16:05:09 <gwern> Data.Maybe++
16:05:20 <gwern> @karma Data.Maybe
16:05:20 <lambdabot> Data.Maybe has a karma of 1
16:05:31 <tsLight> edwardk, I dont understand
16:05:49 <gwern> only 1? you lot are so ungrateful
16:05:53 <JohnDigs> Hey, I'm using Unique now instead of States to get a unique integer, how do I get the actual integer value from this? getting IO Unique not matching Unique
16:05:54 <edwardk> (a & b) & (c & d) -- how does your pretty printer flatten that?
16:06:04 <tsLight> let me see
16:06:59 <edwardk> vs. (a & (b & (c & d))) or the other case (((a & b) & c) & d)
16:07:27 <tsLight> it does "a & b & (c & d)" with the values of izq and der from my pastebin
16:07:30 <gwern> @hoogle String -> Char
16:07:30 <lambdabot> Prelude read :: Read a => String -> a
16:07:30 <lambdabot> Text.Read read :: Read a => String -> a
16:07:30 <lambdabot> Prelude error :: String -> a
16:08:11 <edwardk> the prec + 1 stuff is always 'safe' it avoids parenthesizing expressions of lower precedence but when you have an expression of the same precedence it doesn't know anything about the associativity of your expression. it doesn't know that the two parse trees are equivalent.
16:08:13 <tsLight> but then if it always adds parenthesis at the right, then why doesnt it do a & (b & (c & d))
16:10:12 <edwardk> tslight: devil's advocate your operation is associative so it doesn't matter if you show it with the full associativity of the original parse, so drop the +1's for And and Or
16:10:21 <edwardk> afk
16:10:49 <adityam> @pl f a b = g . h . l a b
16:10:49 <lambdabot> f = (((g . h) .) .) . l
16:10:50 <tsLight> ok, i was wondering if that would make it break for other formulas
16:12:29 <chessguy_work> @pl \a b -> g . h . l a b
16:12:29 <lambdabot> (((g . h) .) .) . l
16:36:42 <zakwilson> Is there a convenient way with Parsec to say "skip anything that is not parsed by one of these parsers"?
16:37:15 <pastorn> in ubuntu 9.04, i searched for cabal and got some hit on some "libhugs"-package
16:37:27 <pastorn> is that the one i want for my GHC hackery?
16:37:31 <telemachus> dcoutts_: interested in another round of "As the ar turns?"
16:37:36 <pastorn> or should i install from source?
16:37:40 <ksf> zakwilson, noneOf?
16:37:47 <ksf> that's from memory, though.
16:38:09 <zakwilson> noneOf only works on a list of characters
16:38:18 <Berengal> zakwilson: Something like 'try (string "foo") <|> try (string "bar") <|> string "baz" <|> return default' ?
16:38:42 <ksf> of course, it'll be quite inefficient, too, applying the same parsers twice, once to see if they match and once to see if they don't.
16:38:55 <zakwilson> Berengal: that's what I was trying to avoid, but it may be unavoidable.
16:39:16 <Berengal> zakwilson: You could always make a function doing that...
16:39:22 <ksf> hmmm... "anyChar `manyTill` parsers"?
16:39:28 <gwern> pastorn: avoid the ubuntu/debian packages for anything except ghc/hugs itself
16:39:39 <gwern> pastorn: also, hugs will probably disapoint you
16:39:49 <ksf> ...or maybe use seperateBy.
16:39:50 <zakwilson> ksf: maybe. I'll try it that way.
16:40:23 <telemachus> gwern: what's the issue with Debian ghc packages?
16:40:32 <zakwilson> Not seing seperateBy in the documentation.
16:40:45 <Berengal> telemachus: The ubuntu ones are way out of date
16:40:46 <gwern> telemachus: out of date, often badly. also very small subset of hackage packages
16:41:04 <Berengal> zakwilson: sepBy
16:41:06 * telemachus nods - noted
16:41:16 <pastorn> gwern: thanks :)
16:43:11 <edwardk> zakwilson: trying to do identifiers without matching keywords or something?
16:43:23 <zakwilson> sepBy and endBy look close to what I want, but I want the seperator to be anything that isn't matched by the parser.
16:43:44 <zakwilson> I may be using the wrong tool. I'm trying to tokenize English text.
16:44:31 <edwardk> zakwilson: ok, many1 alphaNum `sepBy` satisfy (not . isAlphaNum) =)
16:44:54 <edwardk> er many1 (satisfy ..
16:45:03 <ksf> what about interpunctation and stuff?
16:45:27 <edwardk> ksf: feel free to make the alphaNum smarter ;)
16:46:17 <zakwilson> I'm ignoring anything that isn't an end of sentence or newline. Much punctuation will be ignored, at least in the early version.
16:46:55 <skorpan> i'm thinking of writing a whitespace mode for yi...
16:48:34 <skorpan> what's good about whitespace as a programming language is that people will actually bother deleting trailing whitespaces their source code :P
16:59:15 <MoxJet__> @pl -x y
16:59:15 <lambdabot> (line 1, column 1):
16:59:15 <lambdabot> unexpected "-"
16:59:15 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:59:23 <MoxJet__> @pl \x y -> 1 < gcd x y
16:59:24 <lambdabot> ((1 <) .) . gcd
16:59:38 * inimino uses :set list always in vim
17:04:15 <cads> hey, does anyone here have any experience with any of the notational programming languages, such as J, APL, or Bthe language detailed in the backus paper?
17:09:19 <cads> I've been interested in APL since I first saw the fancy symbols and how damn terse programs were
17:09:56 * ivanm just came in, but that sounded like cads likes line noise...
17:11:02 <Twey> Like Perl?
17:11:27 <cads> well, if it's incredibly terse and specific code, it's not really noise, I suppose you could say then that my argument would apply to bz-encoded program code, but it's different here because it's human readable functional line noise
17:12:29 <cads> I mean, the code for the dot product in backus is something simple like /+|*transpose
17:13:16 <cads> twey, not like perl
17:13:28 <cads> perl's like a teletype threw up on the page
17:13:35 <cads> J's probably worse :)
17:13:58 <inimino> like Perl syntax but more terse, and with FP semantics
17:15:18 <Gracenotes> @botsnack
17:15:18 <lunabot>  :)
17:15:18 <lambdabot> :)
17:15:32 <cads> a quine! (,2#{:),~'(,2#{:),~'''
17:15:59 <Gracenotes> :o
17:16:09 <cads> look, 2 happy faces
17:17:50 <Gracenotes> , (:[]).  (:[])    $ "cads"
17:17:53 <lunabot>  [["cads"]]
17:18:11 <cads> haha
17:18:25 <cads> I've been devoured by square brackets
17:20:43 <cads> I'd like to understand the semantics of these languages, is well as explore the idea of notation based (rather than keyword based) programs
17:21:01 <cads> inimino: do you know whether J's come to be more used than APL?
17:21:38 <inimino> that's the general idea I've gotten but I don't have any data
17:22:05 * cads remembers back when haskell code looked like a bunch of varied emoticons to him
17:22:56 <inimino> I actually really like the idea of writing programs as a string of Unicode characters
17:24:38 <inimino> (that actually applies to every other programming language...)
17:25:05 <cads> sometimes I'd settle for writing code in tex if it'd let me use outlandish math syntax
17:25:14 <cads> that'd be fun
17:25:38 <inimino> I don't know if I'd be willing to go that far ;-)
17:26:08 <inimino> but a little bit of math notation would be great sometimes
17:27:03 <inimino> ∑ sums for example
17:28:28 <Jedai> inimino: Did you try Agda ?
17:28:46 <inimino> Jedai: not yet
17:28:53 <Jedai> It try to make use of unicode, most code use a lot of mathematical symbols
17:29:30 * sbahra wonders what is so great about using unicode symbols
17:29:30 <Jedai> inimino: I'm not sure most editors (and fonts) are ready for this yet but it's pretty spectacular
17:29:35 <sbahra> It might be prettier to read, but harder to write.
17:29:38 <inimino> sounds good
17:29:47 <sbahra> Haskell has UnicodeSyntax.
17:29:52 <inimino> well you know what they say about read/writing code
17:30:01 <inimino> yeah, I use UnicodeSyntax
17:30:20 <sbahra> inimino, is that really necessary? :-P
17:30:22 <Jedai> sbahra: depends on the editor, some let you write unicode symbols pretty easily (when you know how to use them properly)
17:30:38 <inimino> but there's still some things that could be Unicode and aren't, like =>
17:30:41 <inimino> sbahra: no, but I prefer it
17:30:44 <sbahra> (=>) is.
17:30:56 <sbahra>  \x21d2
17:31:03 <sbahra> x21d2
17:31:12 <sbahra> x21xd2
17:31:14 <sbahra> gr
17:31:22 <sbahra> ⇒
17:31:24 <ivanm> inimino: what do they say reading/writings code?
17:31:38 <inimino> and it's no extra effort if you configure your editor for it
17:31:48 <inimino> sbahra: yes, but last I checked you can't use that in type definitions without getting an error from GHC
17:31:59 <inimino> you can use → though
17:32:18 <jinho> does anyone know how to change the default install location for cabal on windows xp?
17:32:57 <inimino> ivanm: you only write code once, but it is read many times
17:33:18 <cads> well for example I'd like to sum over the elements of a set, so I could do  \sum_{a \in A} a^2. Look how purty that looks rendered: http://mathbin.net/12235
17:33:20 <ivanm> ahhh...
17:33:50 <Jedai> jinho: You'll have to find the config file location
17:34:04 <inimino> cads: yes, that is excellent :)
17:34:10 <cads> lol, that's more verbose than  "sum a"
17:34:11 <Jedai> jinho: try cabal --help
17:34:25 <Jedai> jinho: it should tell you where to find it
17:34:38 <inimino> I would use that programming language
17:35:35 <cads> i've seen haskell rendered to latex, that's fairly nice looking as well
17:35:38 <inimino> "sum a" isn't equivalent though
17:35:53 <inimino> you need a map and a fold, at which point I think the notation is at least as readable
17:36:10 <Jedai> sum . map (^2)
17:36:11 <bombshelter13_> Is the minimum size of a compiled haskell binary inherently quite large, or is there a way to cut them down in size?
17:36:16 <cads> oh wait, I squared my elements :)
17:36:51 <Jedai> bombshelter13_: It is pretty large since it must include the RTS
17:37:19 <Gracenotes> > foldl' ((+) . (^2)) 0 [1..5]
17:37:20 <lambdabot>   21909
17:37:37 <Jedai> bombshelter13_: The next version of GHC should bring support for shared library, current development version allows to write much smaller binary using this
17:37:42 <bombshelter13_> Jedai: is there any facility to selectively exlude portions of it that aren't needed?
17:37:50 <bombshelter13_> Jedai: ah, that sounds good.
17:38:07 <cads> > :t ((+) . (^2))
17:38:08 <lambdabot>   <no location info>: parse error on input `:'
17:38:16 <cads> @t ((+) . (^2))
17:38:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:38:26 <cads> bleh, I know what type it must have..
17:38:45 <ivanm> cads: what type?
17:38:47 <Jedai> bombshelter13_: The whole RTS is pretty much needed to run any Haskell program... (Don't forget to strip and compress your binary if you want to distribute them though)
17:38:56 <ivanm> go on, let's check your inbuilt type checker... ;-)
17:39:03 <Gracenotes> cads: in addition, the neat the part is, GHC might do that automatically :)
17:39:33 <bombshelter13_> Jedai: I'm not familiar with stripping and compressing a haskell binary, where can i learn about this? (assuming you're not talking about just putting it in a compressed archive for transmission)
17:39:35 <Gracenotes> sum xs = foldl (+) 0 xs, so it would transform foldl (+) 0 . map (^2) into something like foldl ((+) . (^2)) 0
17:39:50 <cads> ivanm: type of folds nyugga,  (b -> a -> b), no?
17:39:52 <Gracenotes> using map-fusion-ish things.
17:39:54 <Jedai> :t ((+) . (^2))
17:39:55 <lambdabot> forall a. (Num a) => a -> a -> a
17:40:04 <bombshelter13_> And honestly it's not so much that the binary size is something in anyway actually problematic for me, i'm mainly just curious as to why it's the case
17:40:11 <Gracenotes> the transformation is more natural for foldr though...
17:40:14 <Twey> cads: Depends what sort of fold it is
17:40:17 <Twey> :t foldl
17:40:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:40:18 <Twey> :t foldr
17:40:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:40:31 <ivanm> @type ((+) . (^2))
17:40:32 <lambdabot> forall a. (Num a) => a -> a -> a
17:40:39 <ivanm> so not quite! ;-)
17:41:06 <Jedai> bombshelter13_: Haskell binary are quite ordinary, the usual tools will works on them
17:41:27 <Gracenotes> it is of the type (a -> b -> a)
17:41:33 <Gracenotes> with a = b
17:41:59 <bombshelter13_> ah, i see
17:43:24 <jinho> is there a way to write a number in binary?
17:43:58 <Jedai> bombshelter13_: http://blog.well-typed.com/2009/04/hello-world-now-only-11k-using-ghc-with-shared-libs/
17:45:11 <Jedai> jinho: You mean directly like 0b010101111 ?
17:45:25 <jinho> Jedai: perfect
17:45:26 <jinho> thanks
17:45:36 <Jedai> jinho: Unfortunately no, though you could write a Quasiquoter
17:45:46 <jinho> haha
17:45:48 <jinho> oops
17:45:56 <Jedai> jinho: Sorry to have given you false hopes... :(
17:46:03 <Twey> > showIntAtBase 2 ("01" !!) "12" ""
17:46:04 <lambdabot>       No instance for (Integral [Char])
17:46:04 <lambdabot>        arising from a use of `showInt...
17:46:09 <jinho> np, appreciate the help :)
17:46:13 <Twey> > showIntAtBase 2 ("01" !!) 12 ""
17:46:14 <Gracenotes> Twey: I think it's more reading it
17:46:14 <lambdabot>   "1100"
17:46:25 <Twey> Ah, right
17:46:31 * Twey ponders.
17:46:38 <Jedai> jinho: writing a quasiquoter for this would be pretty easy I think, then you could write [b|01011111]
17:46:54 * Twey nods.
17:47:13 <Berengal> > foldl (\a n -> a*2+charToInt n) 0 "1100"
17:47:14 <lambdabot>   Not in scope: `charToInt'
17:47:18 <Gracenotes> of course, you do have your own quasiquoter: integer literals. You can define your own fromInteger for a Num. Except... then you'd have to convert it to an Int, or whichever
17:47:22 <Berengal> > foldl (\a n -> a*2+digitToInt n) 0 "1100"
17:47:24 <lambdabot>   12
17:48:00 <dolio> , [| 5 |]
17:48:01 <lunabot>  LitE (IntegerL 5)
17:48:27 <dolio> , $(LitE (IntegerL 5)) :: Float
17:48:28 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
17:48:45 <dolio> , $(litE (integerL 5)) :: Float
17:48:46 <lunabot>  5.0
17:48:55 <Twey> @let bin num = foldl (\a n -> a * 2 + digitToInt n) 0 num
17:48:57 <lambdabot>  Defined.
17:49:00 <Twey> > bin "1100"
17:49:02 <lambdabot>   12
17:52:03 <dolio> > readInt 2 (`elem` "01") digitToInt "01011010"
17:52:04 <lambdabot>   [(90,"")]
17:53:07 <mreh> is Cabal taken from cabal meaning "advising body
17:53:36 <ivanm> Cabal == Common Architecture for Building Applications and Libraries
17:53:52 <ivanm> there is no such thing as the secret shadowy organisation, the "Haskell Cabal"!
17:53:52 <ivanm> ;-)
17:53:54 <mreh> someone told me today CABAL are the initials of the advisors to King Charles II during the english reformation
17:54:22 <mreh> damn, i wanted brownie points
17:55:21 <ivanm> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html <-- lol
17:55:33 <ivanm> 'Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"'
17:55:40 <Berengal> Man, has that thing been linked to lately...
17:57:33 <Jig> > sortBy (cmp snd) [(1,2),(3,4),(2,3)]
17:57:34 <lambdabot>   Not in scope: `cmp'
17:57:41 <ivanm> Berengal: heh
17:58:22 <Jig> where is cmp?
17:58:26 <Berengal> compare
17:58:35 <Berengal> @type compare
17:58:36 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
17:58:44 <Berengal> You're probably looking for...
17:58:46 <Berengal> @type comparing
17:58:47 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:01:45 <bombshelter13_> Jedai: sorry, stepped afk, that link looks pretty good :)
18:02:23 <Jig> again,
18:02:47 <dolio> *Bin> (\[$b| 101 |] -> "okay!") 5 ==> "okay!"
18:03:02 <Jig> how can I do: parse :: Parser -> String -> (Construct, String)
18:03:10 <mmorrow> yay QuasiQuoters
18:03:10 <Jig> how can I do: parse :: Parser -> String -> (Maybe Construct, String)
18:03:26 <Jig> ie parse and if match return rest of the string
18:03:52 <mmorrow> prolog = Quasiquoter (\s -> [|"No."|]) (error "No.") -- ?
18:03:53 <dolio> mmorrow: Little heavy-weight.
18:04:03 <Berengal> Jig: Using parsec?
18:04:04 <Jig> nyone know HRay? i dont get how to call it
18:04:34 <Jig> yes
18:05:17 <mmorrow> dolio: what does 'b' do in pattern context?
18:05:29 <mmorrow> ohhh
18:05:31 <mmorrow> ok
18:05:37 <mmorrow> binary :)
18:06:14 <Jig> hmm is there any way tomanipulate images in haskell?
18:06:31 <dolio> Matches binary.
18:06:53 <Axman6> Jig: check hackage
18:06:56 <dolio> > (\0xff -> "okay!") 255
18:06:58 <lambdabot>   "okay!"
18:07:01 <ivanm> there's a PNG library IIRC...
18:07:06 <mmorrow> data Image = Image {w, h :: Int, pixels :: Ptr Word8} -- is what i'd probably do
18:07:32 <mmorrow> s/Word8/Word*/ for desired depth
18:07:50 <dolio> , [p| 255 |]
18:07:51 <lunabot>  luna: Tempate Haskell pattern brackets are not supported yet
18:08:51 <ivanm> anyone know what kind of input you need for this? http://yiopposite.blogspot.com/2009/05/lambda-calculus-interpreter-in-haskell.html
18:09:16 <Jig> Ptr is a C pointer?
18:09:40 <Berengal> Jig: Ptr is a haskell pointer I believe. C pointers are ForeignPtr
18:09:44 <Berengal> I may be wrong...
18:10:25 <pumpkin_> edwardk: omg your bowl won't add eggs? get a new bowl!
18:10:57 <Cale> whaaaaat
18:11:09 <dolio> Cale: You need to read more reddit.
18:11:42 <ivanm> Cale: what what?
18:11:42 <Cale> Ptr a is the Haskell-side representation of a C pointer to a value of type a
18:12:41 <pumpkin_> ivanm: in the?
18:12:58 <adamvo> @hoogle Ptr a
18:12:59 <lambdabot> Did you mean: :: Ptr a /count=20
18:12:59 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
18:12:59 <lambdabot> Foreign.ForeignPtr addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
18:13:26 <mmorrow> Jig: the concept of a pointer is language independent, and Ptr in haskell matches a pointer in C
18:13:27 <ivanm> oh, Cale was whatting Jig's query
18:13:36 <adamvo> @hoogle Ptr a -> ForeignPtr a
18:13:36 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
18:13:37 <lambdabot> Foreign.Concurrent newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
18:13:37 <lambdabot> Foreign.ForeignPtr newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
18:13:40 <pumpkin_> oh :(
18:13:45 <ivanm> pumpkin_: I was trying to work out what Cale was "whaaaaat"ing
18:13:52 <Cale> ivanm: No, I was whatting pumpkin's remark to edwardk
18:13:57 <pumpkin_> yay
18:13:59 <ivanm> oh
18:14:03 <ivanm> heh
18:14:07 <pumpkin_> ivanm: I thought you were making a samwell reference
18:14:13 <ivanm> yeah, I just ignored that one, sinse it made no sense to me
18:14:15 <ivanm> pumpkin_: who?
18:14:37 <pumpkin_> http://www.youtube.com/watch?v=fbGkxcY7YFU (I'll stop being off-topic now, sorry)
18:15:06 <mmorrow> a ForeignPtr (possibly) has an attached IO () action which'll be called to free the memory if the GC determines it's no longer reachable
18:15:42 <mmorrow> a plain Ptr isn't followed by the GC (although you could have a Ptr to memory that *is* GC-followed, but that probably would be a bad idea :)
18:15:56 <mmorrow> @src ForeignPtr
18:15:56 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
18:16:00 <mmorrow> @src ForeignPtrContents
18:16:00 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
18:16:01 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
18:16:01 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
18:16:05 <mmorrow> @src Ptr
18:16:05 <lambdabot> data Ptr a = Ptr Addr#
18:16:16 <MyCatVerbs> @type withForeignPtr
18:16:17 <lambdabot> Not in scope: `withForeignPtr'
18:16:19 <dolio> I can't believe that's in the @src database.
18:16:20 <mmorrow> a Ptr is just a memory address
18:16:23 <ivanm> pumpkin_: O...K... then...
18:16:25 <mmorrow> dolio: heh
18:16:31 <pumpkin_> yeah, I was surprised too
18:16:48 <dolio> Considering it's missing basic stuff that more people actually want to know about. :)
18:17:05 <mmorrow> @src span
18:17:05 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:17:15 <pumpkin_> @src Reader
18:17:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:17:32 <mmorrow> that ForeignPtr @src isn't even up-to-date anymore either
18:17:32 <solidsnack> For EMACS users, what is the Haskell mode of choice?
18:17:40 <MyCatVerbs> Somewhat embarrasing.
18:18:26 <ivanm> solidsnack: the default one
18:18:30 <ivanm> that's on the wiki
18:18:39 <ivanm> rather than any of the one-file-only modes
18:19:34 <solidsnack> This one?
18:19:35 <solidsnack> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
18:19:44 <solidsnack> Does it come with most Emacs installations these days?
18:20:22 <solidsnack> I'm prepping for a class and there are some people who use EMACS.
18:20:25 <dolio> mmorrow: That's how ForeignPtr is in the base that comes with 6.10.1.
18:20:44 <mmorrow> dolio: ah, it must have just changed recently then
18:20:53 <Berengal> solidsnack: It should be in the various distro repos. At least it's in ubuntu and arch
18:21:23 <solidsnack> Ah, okay. It's probably relatively easy to find it, I guess. Most of my students will be using Macs but whatever.
18:21:49 <mmorrow>   = PlainForeignPtr !(IORef (Finalizers, [IO ()]))
18:21:50 <mmorrow>   | MallocPtr      (MutableByteArray# RealWorld) !(IORef (Finalizers, [IO ()]))
18:21:53 <ivanm> solidsnack: nope
18:21:57 <ivanm> you have to install it yourself
18:22:04 <solidsnack> Ah, okay -- good to know.
18:22:08 <mmorrow> data Finalizers = NoFinalizers | CFinalizers | HaskellFinalizers
18:22:10 <ivanm> note that the latest version has a bug wrt cabal files
18:22:26 <ivanm> it tries to make your code a project, and looks for *.cabal and uses that as the root directory
18:22:36 <mmorrow> (it still has PlainPtr, but that Con hasn't changed)
18:22:41 <Berengal> Yeah, there are probably a few minor adjustemnts you need to make in you .emacs to get it to work just right
18:22:59 <ivanm> so if you don't have a cabal file for your project, but you do use cabal-install (and hence have ~/.cabal), it will always use ~/ as the root directory of your project
18:23:39 <solidsnack> ivanm: Interesting.
18:23:53 <solidsnack> ivanm: Thank you for the warning.
18:24:06 <pumpkin_> mmm
18:24:06 <ivanm> no worries
18:24:10 <Berengal> solidsnack: (setq inferior-haskell-find-project-root nil) fixes it
18:24:18 <ivanm> so you might be better off with a slightly older version
18:24:20 <solidsnack> Oh, good.
18:24:25 <ivanm> Berengal: I've had problems with that "fix"
18:24:31 <solidsnack> Oh?
18:24:46 <ivanm> IIRC, if you do have a .cabal file it doesn't work too well
18:25:03 <mmorrow> iirc @src is just a single .txt file in the lambdabot code... someone could just update it
18:25:06 <ivanm> solidsnack: there's a patch for the gentoo ebuild that they applied from upstream: let me find it for you, as it fixes this issue
18:25:08 <Berengal> ivanm: What, with the fix?
18:25:13 <ivanm> Berengal: yup
18:25:32 <Berengal> I haven't had any trouble with that... just make sure you :cd into the right root directory in ghci yourself
18:25:40 <mmorrow> http://code.haskell.org/lambdabot/State/source
18:25:55 <ivanm> bugger, the gentoo devs applied the patch to their own tarball...
18:26:03 <mmorrow> @src Either mfix
18:26:04 <lambdabot> mfix f = let a = f $ case a of
18:26:04 <lambdabot>                         Right r -> r
18:26:04 <lambdabot>                         _       -> error "empty mfix argument"
18:26:04 <lambdabot>          in a
18:26:20 <solidsnack> ivanm: Oh, curses.
18:26:27 <ivanm> yup
18:26:36 <ivanm> so I can find the tarball for you if you want the patched tarball
18:26:42 <mmorrow> @src unsafeIOToST
18:26:42 <lambdabot> unsafeIOToST (IO io) = ST $ \ s -> (unsafeCoerce# io) s
18:26:47 <mmorrow> @src unsafeSTToIO
18:26:47 <lambdabot> unsafeSTToIO (ST m) = IO (unsafeCoerce# m)
18:27:59 <mmorrow> @src toDyn
18:28:00 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
18:28:08 <pumpkin_> so much random stuff in lb
18:28:10 <solidsnack> ivanm: In here?
18:28:11 <solidsnack> http://mirror.its.uidaho.edu/pub/gentoo-portage/app-emacs/haskell-mode/haskell-mode-2.4_p20080826.ebuild
18:28:25 <ivanm> solidsnack: yup, that's the one
18:28:33 <ivanm> heh, just about to paste the link ;-)
18:28:46 * Jig is glad mental orgasm aren't sticky because he would have to buy a new computer. Pardon the generated images in your head.
18:28:47 <dolio> @src Dynamic
18:28:47 <lambdabot> Source not found. There are some things that I just don't know.
18:28:58 <dolio> , src ''Dynamic
18:29:01 <lunabot>  data Dynamic = Dynamic TypeRep Obj
18:29:08 <ikkebr> oi
18:29:08 <ivanm> Jig: arrrghhhh!!! my brains!!!
18:29:14 <dolio> , src ''Obj
18:29:15 <lunabot>  luna: Not in scope: type constructor or class `Obj'
18:29:18 <pumpkin_> mindgasm?
18:29:19 <dolio> Great.
18:29:34 <mmorrow> dolio: iirc it's just Any
18:29:43 <mmorrow> which iirc also is just
18:29:45 <mmorrow> data Any
18:29:47 <dolio> I guess Dynamic predated existentials.
18:30:18 <mmorrow> dolio: i think you'd still have to unsafeCoerce on the way out though..
18:30:32 <dolio> Yeah. But coercing on the way in is just wrong. :)
18:30:37 <mmorrow> heh
18:31:06 <pumpkin_> Dynamic has a really ugly api
18:31:38 <pumpkin_> maybe I just need to use it more
18:32:03 <dolio> No, definitely not. :)
18:32:11 <pumpkin_> thank god
18:32:39 * pumpkin_ gets back to lazy uvector
18:33:18 <dolio> You need to get dons to release a uvector with memcpy, and a fixed put/get. :)
18:33:42 <dolio> So I can release a uvector-algorithms that doesn't segfault/hang on certain algorithms. :)
18:34:09 <mmorrow> foreign import ccall unsafe "memcpy" c_mempty :: Ptr a -> Ptr b -> CSize -> IO ()
18:34:17 <mmorrow> haskellFFI++
18:34:25 <pumpkin_> he's using fancy additive memcpy though :P
18:34:43 <pumpkin_> but yeah, a new release would be cool
18:35:00 <mmorrow> pumpkin: did he write that memcpy by hand?
18:35:06 <pumpkin_> no :P
18:35:14 <ivanm> mmorrow: he wrote it by computer
18:35:16 <ivanm> ;-)
18:35:16 <dolio> I can't actually put memcpy in my library. dons hid all the modules that let you access the constructors for the arrays. :)
18:35:21 <pumpkin_> I don't think anyone writes memcpy by hand these days
18:35:28 <pumpkin_> I should hope not, anyway
18:35:34 <mmorrow> because from what i understand the memcpy in libc uses prefetching so it'll be faster than any code that doesn't do so
18:35:54 <Goldy`> how can i make a list in the form ['1', '2', '3'..'9'] without typing it out?
18:36:02 <pumpkin_> yeah, memcpys are ridiculously complicated and I'd never want to attempt one
18:36:10 <Zao> > ['1'..'9']
18:36:12 <lambdabot>   "123456789"
18:36:17 <Goldy`> cool, thanks!
18:36:19 <Goldy`> i didnt think of that
18:36:29 <Zao> .. works with just about any Enum a, I belive.
18:36:33 <mmorrow> i think doing so is just a matter making a single call to __builtin_prefetch (if you'r eusing gcc)
18:36:40 <MyCatVerbs> > ['a'..'z']
18:36:41 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
18:36:43 <dolio> > (length "['1'..'9']", length "\"123456789\"")
18:36:44 <lambdabot>   (10,11)
18:36:48 <mmorrow> then proceed with the for loop
18:36:53 <mmorrow> (or whatever)
18:36:56 <Saizan> ?type \x y -> [x .. y]
18:36:57 <lambdabot> forall t. (Enum t) => t -> t -> [t]
18:36:57 <pumpkin_> mmorrow: but memcpys have special cases for different sizes of copies and stuff, too
18:37:02 <pumpkin_> the ones I've seen on ARM, at least
18:37:10 <mmorrow> pumpkin: ah, hmm
18:37:13 <Jig> is it possibel to take values from a Storable array and put them in a haskelllist?
18:37:27 <pumpkin_> they do all sorts of ugly stuff to make it as fast as possible, but it probably only adds a few % after a while
18:37:58 <Saizan> Jig: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html#v%3ApeekArray
18:41:00 <dolio> pumpkin_: Oh, one thing I thought of when looking through uvector the other day: you might want to document the parameters to the memcpys.
18:41:08 <pumpkin_> oh yeah
18:41:09 <mmorrow> heh
18:41:13 <pumpkin_> that would make sense
18:41:24 <mmorrow> the eternal question
18:41:26 <pumpkin_> I'll stick that in
18:41:30 <dolio> Because it's not obvious what the Ints in "MUArr e s -> MUArr e s -> Int -> Int -> Int -> ST s ()" are.
18:41:39 <dolio> Or the arrs, I suppose.
18:41:40 <mmorrow> "arrrrgh, which is the src and which is the tgt???!?"
18:41:57 <pumpkin_> I think you flipped them didn't you?
18:42:01 <pumpkin_> from the c implementation?
18:42:08 <mmorrow> C is (tgt,src)
18:42:15 <dolio> Yeah, It's 'memcpy src dst'.
18:42:20 <pumpkin_> yeah
18:42:33 <dolio> But even I don't remember whether I put the length before the offsets or not. :)
18:43:09 <dolio> I probably put it after, but I'd rather not have to go source diving to verify it.
18:45:24 <zakwilson> I know next to nothing about hashing algorithms. I'm implementing something similar to CRM114's hyperspace classifier (see http://crm114.sourceforge.net/docs/KNN_Hyperspace_Filters/KNN_Hyperspace_Filters.html)
18:46:17 <ivanm> is there a way I can have "type ChurchNumeral a = (a -> a) -> a -> a", and make "ChurchNumeral a" an instance of Show (by using Strings) without specifying "ChurchNumeral String"?
18:46:26 <zakwilson> I'm looking for a suggestion for a hashing algorithm that's suitable. It's doing a nearest neighbor search on lists of features made up of (essentially) words.
18:47:13 <mmorrow> zakwilson: you mean a hash _function_, or a hash-table _datastructure_?
18:47:22 <zakwilson> It is desirable that the hashes be small (CRM114 uses 32-bit hashes). Collisions are, of course undesirable, but not a huge problem.
18:47:31 <mmorrow> ah, so a hash function
18:47:38 <zakwilson> A hash function. The original data is discarded once hashed.
18:47:40 <Jig_> > all (<10) [1..10]
18:47:42 <lambdabot>   False
18:47:45 <Jig_> > all (<10) [1..9]
18:47:46 <lambdabot>   True
18:50:05 <mmorrow> zakwilson: yesterday i was using the hash from the ELF spec, dunno if it's any good but i'd think so (i too don't know much about how to conjure a good hash function): http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2371#a2371
18:50:22 <mmorrow> (that code is verbatim from the spec)
18:50:57 <zakwilson> Thanks, mmorrow. I may give that one a try.
18:51:57 <mmorrow> np
18:52:11 <pumpkin_> ivanm: can't you just make the show for your numeral show c = show $ c (+1) 0 -- ?
18:52:39 <ivanm> pumpkin_: I wanted to show "succ succ succ ... zero" kind of thing
18:52:42 <pumpkin_> ohh
18:53:02 <pumpkin_> hmm
18:54:14 <Jig_> Word8 to Int?
18:54:18 <pumpkin_> fromIntegral
18:54:34 <pumpkin_> ivanm: I don't think it's possible :/
18:54:57 <ivanm> yeah, I tried using existentials but then you can't make instances for them (or else I'm doing it wrong)
18:55:03 <Jig_> how do I apply a function to both elemtns of a tuple?
18:55:10 * ivanm now has to figure out how to do equality on church numerals...
18:55:11 <pumpkin_> Jig: join (***) f ;)
18:55:13 <Jig_> fromIntegral (a,b)
18:55:30 <Jig_> > join (***) fromIntegral (12,45)
18:55:31 <lambdabot>   (12,45)
18:55:48 <pumpkin_> honestly though, you're probably better off with a bit of a lambda, or some repetition
18:55:57 <ivanm> pumpkin_: me or Jig?
18:55:59 <pumpkin_> I think arrow should contain a both function
18:56:04 <pumpkin_> ivanm: Jig_, sorry
18:56:14 <ivanm> thought so, just checking ;-)
18:56:20 <ivanm> pumpkin_: by "both", you mean join (***) ?
18:56:23 <pumpkin_> yeah
18:56:25 <Berengal> pumpkin_: I've thought the same thing
18:56:32 <ivanm> is that valid for all arrows?
18:56:37 <pumpkin_> or it might be implemented in terms of first and second, like they like to do in Arrow
18:56:38 <ivanm> or just for functions on tuples?
18:56:43 <ivanm> @type join (***)
18:56:43 <pumpkin_> I think it works for all of them?
18:56:43 <Berengal> @type join (***)
18:56:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:56:45 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:56:53 <ivanm> hmmm....
18:56:54 <pumpkin_> it'd just be first f >>> second f
18:57:06 <ivanm> looks like it might
18:57:16 <Berengal> or (\f ->f***f)
18:57:24 <ivanm> then again, I don't really understand Arrows, I just use them for functions on tuples ;-)
18:57:29 <ivanm> Berengal: which is join (***)
18:57:30 <ivanm> @src join
18:57:31 <lambdabot> join x =  x >>= id
18:57:42 <ivanm> @unpl join (***)
18:57:43 <lambdabot> ((***) >>= \ a -> a)
18:57:47 <ivanm> heh
18:57:48 <pumpkin_> ivanm: I think that's how 99.99% of people who know about arrows use them :P
18:58:39 * Berengal at least does
18:58:52 <MyCatVerbs> pumpkin_: lies. Four nines of people who know about arrows stay as far away from them as is humanly possible. ;)
18:59:19 <pumpkin_> hah
19:00:11 <MyCatVerbs> Though I'm curious as to whether basing everything (IO on up, etc) on Arrows rather than Monads would've made a better language in some respects.
19:00:18 <pumpkin_> I wonder how hard it would be to add an unboxed IO/ST ref to GHC
19:00:37 <pumpkin_> MyCatVerbs: it's nice though how simple the desugaring rules are for do notation
19:00:45 <pumpkin_> the arrow notation is kinda icky and has a lot more rules
19:01:17 <Berengal> We've got enough trouble with explaining monads as it is
19:01:19 <pumpkin_> and if we wanted Kleisli to be more practical, it should've been called K
19:01:45 <pumpkin_> :P
19:01:46 <Jig_> im a Klein Bottle
19:01:51 <Berengal> Hmm... Kleisli ((->)e) ...
19:01:55 <Jig_> i want to be a topologist
19:02:00 <Jig_> they have the coolest names
19:02:04 <Jig_> for things
19:02:26 <Gracenotes> you know, ReaderT and Kleisli are essentially the same type :)
19:02:31 <MyCatVerbs> pumpkin_: yes, there is that unfortunately. Still, it *might* be nice to have the smooth increase in power as one goes through Arrow, ArrowChoice, ArrowLoop, ArrowApply...
19:02:36 <Gracenotes> except with type params switched
19:02:44 <pumpkin_> MyCatVerbs: yeah
19:02:45 <Gracenotes> pretty interesting...
19:03:03 <pumpkin_> we can call it the Gracenote ReaderT-Kleisli isomorphism!
19:03:09 <dolio> , (λ x -> x) 5
19:03:09 * Berengal still doesn't know what arrows are properly
19:03:10 <lunabot>  luna: Pattern syntax in expression context: ۠x -> x
19:03:20 <Gracenotes> indeed it shall be so!
19:03:37 <pumpkin_> but ReaderT doesn't have all the nice Arrow instances defined on it
19:03:43 <pumpkin_> except through Kleisli
19:03:48 <MyCatVerbs> Berengal: things that have composition defined on them, and which you can build from pure functions.
19:04:05 <Berengal> MyCatVerbs: I thought that was categories
19:04:11 <Gracenotes> right. I think all the instances would be possible
19:04:18 <Gracenotes> the switched type params wouldn't be an issue
19:04:40 <Gracenotes> come to think of it, same with (->) and Arrow :P
19:04:50 <Jig_> is it not possible to pmatch on a group constructor?
19:04:51 <Jig_> ie
19:04:54 <Gracenotes> with Reader. It is just a newtype
19:04:56 <MyCatVerbs> Berengal: similar. AFAIK categories don't necessarily give you the "you can build from pure functions" thing, though. (Perhaps they do? If they do, then maybe they're equivalent. Hrm.)
19:05:01 <Jig_> data Blah = X | Y | Z
19:05:13 <Jig_> hmm (Blah x y) = x*y
19:05:20 <Berengal> MyCatVerbs: As I recall, Category = (.) & id
19:05:20 <pumpkin_> Jig_: you can pattern match against data constructors
19:05:23 <Jig_> rather than hmm (X x y) ...
19:05:27 <pumpkin_> Jig_: the Blah doesn't make sense
19:05:33 <Jig_> i mean rather than for each
19:05:39 <Jig_> it is a function that takes a Blah
19:05:47 <Jig_> and which one of them dosnt matter
19:05:49 <pumpkin_> Blah is the type, not the data constructor though
19:05:58 <pumpkin_> oh, then you don't need to specify it
19:06:05 <pumpkin_> hmm x y = x * y
19:06:07 <pumpkin_> :P
19:06:13 <pumpkin_> or more succinctly, hmm = (*)
19:06:16 <Berengal> MyCatVerbs: Also, I assume that by pure function you mean e.g functions returning monads for kleisli
19:06:18 <Jig_> no
19:06:20 <Gracenotes> if a Num instance is there
19:06:26 <Jig_> it is an X
19:06:28 <Jig_> or Y
19:06:35 <MyCatVerbs> Berengal: no, I mean pure functions.
19:06:41 <Jig_> lets say it is isntead
19:06:50 <Berengal> MyCatVerbs: Ah, as in arr?
19:06:53 <Jig_> data Blah = X a b c | Y a b c
19:06:54 <MyCatVerbs> Berengal: instance (Arrow (:->:)) says that you can glue an (a :->: b) and a (b :->: c) together with (>>>) to get an (a :->: c). And you can use (arr) to transform a function of type (a -> b) to an arrow (a :->: b).
19:06:56 <pumpkin_> arr matey
19:06:58 <MyCatVerbs> Yes.
19:07:01 <pumpkin_> Jig_: oh, you can't do that :P
19:07:08 <Jig_> hmm (_ a b _) = a*b
19:07:11 <pumpkin_> Jig_: you mean match on the number of args?
19:07:14 <Berengal> MyCatVerbs: Ah, I had forgotten about that
19:07:17 <Gracenotes> Jig_: so to match two of them, (X a b c) (Y a b c) = ...
19:07:18 <MyCatVerbs> pumpkin_: that is now going to go on the top of every Haskell file that I shall ever write, from this day forward.
19:07:35 <pumpkin_> Jig_: I'd like to be able to do that too, but nope :/
19:07:39 <Gracenotes> Jig_: except you'll need four cases to fully use both
19:07:58 <pumpkin_> MyCatVerbs: shiver me timbers!
19:08:20 <Gracenotes> at least. Not counting degenerate ones or extra matching. It's essentially a design issue. But... whose problem is this now? >_>
19:09:06 <pumpkin_> Jig_: the issue is that you'd be not just matching on number of parameters but their types
19:09:10 <Jig_> or wit
19:09:12 <Jig_>  duh
19:09:15 <Jig_> fromBlah
19:09:16 <pumpkin_> which probably means those types would need to be kept around at runtime
19:09:29 <Berengal> @type arr
19:09:30 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:09:32 <Berengal> @type (return.)
19:09:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
19:09:40 <Gracenotes> then there's blah :: (a -> b -> c -> d) -> (a -> b -> c -> d) -> Blah -> d
19:09:43 <Jig_> use fromBlah to match out and then use that for each function that does above
19:09:49 <Gracenotes> and I still have no idea what you guy are tlaking about
19:09:55 <MyCatVerbs> Berengal: then ArrowChoice gives you the combinators you need to make if statements inside arrow notation blocks. ArrowPlus says that the arrows are of some type that form a monoid. ArrowApply says that the arrows form a Monad. ArrowLoop says that you can use mdo notation inside the arrow notation blocks.
19:10:36 <Berengal> MyCatVerbs: And all this is just so we can get pretty diagrams, I assume ;)
19:10:38 <pumpkin_> I wonder how many different restatements of Monoid there are in the base libs
19:11:03 <MyCatVerbs> pumpkin_: FTFM.
19:11:18 <Jig_> couldn't we name things like (***) instead?
19:11:28 <ivanm> what library do I need to import to print utf8-chars again?
19:11:33 <Jig_> applyOnBoth
19:11:46 <MyCatVerbs> ivanm: System.IO.UTF8?
19:11:55 <ivanm> that's the one
19:11:56 <pumpkin_> Jig_: we like our operators!
19:12:10 <Jig_> > let applyOnBoth = join (***) in applyOnBoth (+1) (3,4)
19:12:12 <pumpkin_> Jig_: they can be daunting at first but you grow to love them
19:12:12 <lambdabot>   (4,5)
19:12:14 <Berengal> Jig_: Arrows outside arrow-do notation is hard enough as it is
19:12:30 <ivanm> grrr.... it still doesn't seem to work :@
19:13:13 <ivanm> then again, maybe it's emacs... :@
19:13:19 * pumpkin_ runs off to put away the grill
19:13:26 <MyCatVerbs> Berengal: well, sometimes it's nice to be able to say that you're only going to require a subset of those - IIRC there's at least one parser combinator library which defines an Arrow instance rather than a Monad instance, because Arrow, requiring fewer properties than Monad, gives them more freedom with the design.
19:14:58 <pumpkin_> I remember someone saying something about parsec not being as efficient as it could be due to its non-arrow-ness
19:15:05 <pumpkin_> but I may have mangled that in my n00bmemory
19:15:42 <pumpkin_> I wonder when I can stop being a haskell n00b
19:15:50 <Berengal> I partially get arrows, I believe. It's like when I was writing my own state monads but couldn't really grok what a monad was anyway
19:16:08 <ivanm> how can I get ghci to print utf8 chars properly?
19:16:11 <Berengal> The thing is I can't really abstract arrows away from functions yet :/
19:16:24 <pumpkin_> ivanm: I never succeeded :/
19:16:31 <Berengal> ivanm: Print to a file?
19:16:33 <ivanm> :(
19:16:45 <ivanm> Berengal: no, I want to do an interactive session for a talk
19:17:10 <Jig_> pumpkin: if you are a noob them I'm a hmm, boon?
19:17:11 <pumpkin_> ivanm: maybe 6.10.3 might help, aren't they moving to haskelline?
19:17:13 <Jig_> goon?
19:17:30 <ivanm> pumpkin_: I doubt it'll help
19:17:31 <pumpkin_> Jig_: not sure :) I don't know if I count as a noob anymore
19:17:47 <Berengal> ivanm: Does your terminal print utf8 in the first place?
19:17:47 <ivanm> though apparently after 6.10 they're meant to be using utf8 everywhere! \o.
19:17:49 <pumpkin_> ivanm: is it mangling the output, or still displaying escaped non-ascii chars?
19:18:08 <ivanm> Berengal: yes: putStrLn "λ" works; just doing "λ" doesn't :s
19:18:18 <ivanm> pumpkin_: \955 instead of λ
19:18:28 <pumpkin_> oh I think that's just the show instance for String
19:18:35 <pumpkin_> which is hardcoded to do that?
19:18:49 <pumpkin_> wait, Show instance for String?
19:18:49 <ivanm> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases <-- 6.12 should be using unicode!
19:18:52 <pumpkin_> what am I smoking
19:19:13 <adamvo> pumpkin_: doesn't it escape "?
19:19:23 <adamvo> > show "Fooey!"
19:19:23 <Berengal> String has it's own funky show instance, doesn't it?
19:19:24 <lambdabot>   "\"Fooey!\""
19:19:29 <pumpkin_> oh yeah, it does
19:19:31 <Berengal> > show ['a'..'b']
19:19:32 <lambdabot>   "\"ab\""
19:19:49 <Berengal> > show (['a'..'z'] ::[Char])
19:19:51 <lambdabot>   "\"abcdefghijklmnopqrstuvwxyz\""
19:19:58 <ivanm> > show "λ"
19:20:00 <lambdabot>   "\"\\955\""
19:20:02 <ivanm> :(
19:20:06 <ivanm> > "λ"
19:20:08 <lambdabot>   "\955"
19:20:20 <pumpkin_> , text "λ"
19:20:20 <Berengal> lambdabot does show as well
19:20:21 <lunabot>  
19:20:27 <zakwilson> I'm using Emacs and ghci/inferior-haskell. I have modules Foo.Bar and Foo.Baz as Bar.hs and Baz.hs inside directory ~/Foo. Foo.Baz imports Foo.Bar. When I try to load Foo.Baz, it can't find Foo.Bar. How should I handle this?
19:20:32 <pumpkin_> , utf8 "λ"
19:20:33 <lunabot>  luna: Not in scope: `utf8'
19:20:38 <Jig_> but how do I get a Ptr to a StorableArray (Int, Int) Word8
19:20:39 <Jig_> ?
19:20:53 <Jig_> zakwilson: it works if you compile
19:21:00 <Berengal> zakwilson: (setq inferior-haskell-find-project-root nil) in .emacs
19:21:04 <ivanm> , show "λ"
19:21:06 <lunabot>  "\"\\955\""
19:21:14 <ivanm> @botsmack
19:21:15 <lunabot>  :)
19:21:15 <lambdabot> :)
19:21:15 <Berengal> Although some people say it doesn't work as well as it should
19:21:18 <ivanm> the cheeky sods!
19:21:18 <ivanm> ;-)
19:21:22 <Berengal> :P
19:21:49 <Jig_> in ghci im not sure but you can solve it by loading them each in turn
19:21:50 <MyCatVerbs> pumpkin_: you stop being a Haskell n00b when you... eh. You're at the very least probably not a H98 n00b. ;)
19:22:15 <MyCatVerbs> pumpkin_: I think you stop being a Haskell n00b altogether roundabout the same time as when you get reincarnated as a Simon.
19:22:41 <adamvo> pumpkin_: teach me FFI! (is an official H98 addendum)
19:23:05 <ivanm> MyCatVerbs: any Simon?
19:23:17 <ivanm> or Simon {Marlow,Peyton-Jones} ?
19:23:24 <Berengal> I Simon* is good enough...
19:23:25 <zakwilson> Berengal: thanks, but that didn't work.
19:23:27 <dolio> Those two already exist.
19:23:34 <Jig> Berengal: thanks!
19:23:35 <MyCatVerbs> ivanm: the latter.
19:23:39 <ivanm> dolio: backwards reincarnation?
19:23:45 <Berengal> zakwilson: you need to :cd into the root directory in ghci in emacs yourself
19:23:56 <Jig> adamvo: i can teach you basic FFI, did it the other day
19:24:08 <MyCatVerbs> dolio: ah, but reincarnation doesn't necessarily have to treat time as linear.
19:24:13 <Jig> zakwilson: restart emacs?
19:24:17 <Jig> it worked for me
19:24:56 <Berengal> I wonder if people will start doing calculations in the kind-system...
19:25:00 <MyCatVerbs> dolio: my favourity crazy hypothetical religion is where there's only one soul, and it gets reincarnated into every single living thing in the universe. Just takes a while for it to make it all the way through. :)
19:25:13 <ivanm> Berengal: *shudder*
19:25:19 <Berengal> If calculations in the type-system are compile-time, are kind-system calculations done at write-time?
19:25:20 <ivanm> MyCatVerbs: I've thought of that as well
19:25:26 * Saizan thinks they already do
19:25:36 <Jig> but how do I get a Ptr to a StorableArray (Int, Int) Word8
19:25:39 <zakwilson> Got it working. Thanks, guys.
19:25:39 <MyCatVerbs> ivanm: damn. Have you filed yet?
19:25:47 <Jig> I have a StorableArray (Int, Int) Word8
19:25:50 * MyCatVerbs hopes desperately to beat ivanm to the patent office. ;)
19:25:51 <ivanm> which IMHO is the only fair way for karmic reincarnation to work (or at least to have a partitioning of "bodies" with one soul per partition)
19:25:59 <ivanm> MyCatVerbs: you mean do a hubbard? :p
19:26:05 * zakwilson is very happy that this community does not bite the newbies.
19:26:21 <ivanm> zakwilson: it's a bit hard to bite someone via the internet
19:26:32 <Berengal> ivanm: Not everyone's realized that :P
19:27:06 <Saizan> Jig: withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a
19:28:13 <zakwilson> But it's easy to ignore or flame someone for asking a semi-stupid question.
19:28:15 <adamvo> Jig: more of a joke, I also know how to call ex. sin from math.h, but I think I'll get around to it later :)
19:28:51 <Jig_> but what does the function do?
19:30:52 <MyCatVerbs> ivanm: hrmn? Well, I like it just for the idea that you shouldn't hurt anyone else because you're only hurting yourself. But what's the fairness problem with simplistic (linear-time, number of souls equal to number of concurrently-living critters) karmic reincarnation?
19:31:18 <Jig_>  (Ptr e -> IO a)
19:31:25 <Jig_> what function is that?
19:31:30 <ivanm> MyCatVerbs: so karmic reincarnation says that (AFAICT), for example, you set a dog on fire then you'll be reincarnated as a dog
19:31:40 <ivanm> to be really fair, you should then be a dog that gets set on fire
19:31:54 <ivanm> but this requires that someone else then suffers the karmic problem of setting a dog on fire
19:32:03 * MyCatVerbs snerks.
19:32:04 <ivanm> the only way out of this is if you set your dog self on fire
19:32:05 <Jig_> you set Donald Trump on fire you'll be a superrich dude?
19:32:09 <ivanm> Jig_: lol
19:32:13 <solidsnack> ivanm: Well, that's sort of true.
19:32:16 <ivanm> @hoogle Ptr e -> IO a
19:32:17 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
19:32:17 <lambdabot> Foreign.Storable peekByteOff :: Storable a => Ptr b -> Int -> IO a
19:32:17 <lambdabot> Control.Exception evaluate :: a -> IO a
19:32:25 <ivanm> Jig_: none? :s
19:32:29 <solidsnack> ivanm: Your suffering is someone else's karmic debt.
19:32:34 <mmorrow> , (text . utf8enc) "λ"
19:32:35 <MyCatVerbs> ivanm: I don't think that's it at all. More like, if you set a dog on fire then your next life will start at lower status than your current one.
19:32:35 <lunabot>  λ
19:32:44 <mmorrow> , "λ"
19:32:45 <lunabot>  "\955"
19:32:51 <mmorrow> , utf8enc "λ"
19:32:52 <lunabot>  "\206\187"
19:33:06 <ivanm> MyCatVerbs: I never claimed to fully understand how karmic reincarnation worked ;-)
19:33:09 <MyCatVerbs> ivanm: besides, most truly horrible people commit enough sins for it to be infeasible to pick out just one to bludgeon them with.
19:33:17 <solidsnack> The important thing to understand is that we are in fact reborn every instant.
19:33:37 <ivanm> MyCatVerbs: so with one-soul reincarnation, you get to suffer all of your previous sins!
19:33:51 <MyCatVerbs> Future, too, which might break it.
19:33:53 <solidsnack> Harm you inflict in this life is often revisited on you in this life.
19:33:56 <ivanm> mmorrow: why the two chars there?
19:34:16 <ivanm> MyCatVerbs: you're just looking at this from a linear time perspective ;-)
19:34:30 <MyCatVerbs> ivanm: because lambda is in the basic multilingual plane, which UTF-8 requires two characters to encode.
19:34:38 <mmorrow> the utf8-encoded form of a unicode char can be any of 1-4 bytes long
19:34:43 <BMeph> Sorry about feeding the -blah traffickers, but...what if the dog "asked for it"? ;p
19:34:47 <ivanm> MyCatVerbs: with the whole balancing-out-thing, so if I kill someone and then go and do a lot of charity work, does it cancel out?
19:34:53 <ivanm> MyCatVerbs: lol
19:34:58 <ivanm> mmorrow: ahhh, yes
19:35:05 <solidsnack> ivanm: Why would that be related?
19:35:26 <ivanm> BMeph: "oh please kind sir, would you set me on fire?  I'm feeling a mite chilly this morning..." ?
19:35:37 <mmorrow> , (text . utf8enc) "\x2200"
19:35:38 <lunabot>  ∀
19:35:41 <MyCatVerbs> ivanm: not quite. There's still maybe a linear string of events from the perspective of that one particular soul. Even though it gets reincarnated out-of-order from the universe's timescale, there's still *some* ordering on the route it takes through all these bodies.
19:35:41 <Jig_> how do I join 2 functions?
19:35:51 <ivanm> solidsnack: MyCatVerbs said previously that it's an average thing
19:35:53 <Berengal> "Light a man a fire and he's warm for a day. Light a man on fire and he's warm for the rest of his life".
19:35:55 <mmorrow> , utf8enc "\x2200"
19:35:56 <lunabot>  "\226\136\128"
19:35:59 <ivanm> MyCatVerbs: how do you know?
19:36:01 <Jig_> > join (***) ((*) . fromIntegral) (1,2)
19:36:02 <lambdabot>       Overlapping instances for Show (b -> b)
19:36:02 <lambdabot>        arising from a use of `s...
19:36:08 <Jig_> > join (***) (*) (1,2)
19:36:09 <lambdabot>       Overlapping instances for Show (b -> b)
19:36:09 <lambdabot>        arising from a use of `s...
19:36:10 <ivanm> Berengal: lol
19:36:19 <Berengal> -- Terry Pratchett
19:36:23 <solidsnack> Karma means "action". It's about the relationship among your actions. So you can imagine several threads passing through you at once.
19:36:24 <ivanm> that's right
19:36:25 <Jig_> > join (**) (*) (1,2)
19:36:26 <lambdabot>       Overlapping instances for Show ((t, t1) -> (t, t1))
19:36:26 <lambdabot>        arising from...
19:36:27 <mmorrow> , uncurry (*) (2,3)
19:36:27 <ivanm> which book is that from?
19:36:28 <lunabot>  6
19:36:29 <Jig_> > join (*) (1,2)
19:36:30 <lambdabot>       No instance for (Num (t, t1))
19:36:30 <lambdabot>        arising from a use of `*' at <inte...
19:36:38 <ivanm> solidsnack: concurrent living?
19:36:38 <BMeph> So, did this all start from Feynman's "one-electron" theory? :)
19:36:40 <Berengal> ivanm: Can't remember. I read them all in like five months
19:36:40 <MyCatVerbs> ivanm: because, while we could propose that the single soul is incarnated into every being concurrently from its own perspective, that kind of breaks the whole concept of "reincarnation".
19:36:47 <Jig_> > uncurry (*) $ join (***) fromIntegral (1,2)
19:36:48 <lambdabot>   2
19:36:48 <solidsnack> Not all one's activities relate to all of one's karma.
19:36:51 <mmorrow> @type join (*)
19:36:52 <lambdabot> forall a. (Num a) => a -> a
19:36:54 <mmorrow> @type uncurry (*)
19:36:55 <lambdabot> forall a. (Num a) => (a, a) -> a
19:36:57 <ivanm> MyCatVerbs: true
19:37:07 <ivanm> anyway... have we all had enough of this topic?
19:37:07 <ivanm> :p
19:37:30 <Berengal> It can at least move to -blah..
19:37:35 <solidsnack> yeah
19:37:54 * BMeph imagines a new TV show: "Martha Stewart's Concurrent Living"...
19:37:55 * ivanm can't be bothered joining -blah, and really should be doing stuff
19:37:55 <MyCatVerbs> ivanm: incidentally, please join #haskell-blah :)
19:38:56 * BMeph is waiting for Freenode', where ops can move others from channel to channel...
19:40:04 <ivanm> BMeph: heh
19:40:54 <Jig_> free doesnt do what i want
19:41:03 <Jig_> i need a pointer to the first elem or something
19:41:13 <Jig_> oh peekByteOff
19:41:18 <Jig_> no
19:41:29 <pumpkin_> Jig_: what are you trying to do?
19:41:42 <Jig_> http://hackage.haskell.org/packages/archive/pngload/0.1/doc/html/Codec-Image-PNG.html
19:41:52 <Jig_> i want the pixels of the image into a haskell-list
19:42:01 <Jig_> imageData :: PNGImage -> StorableArray (Int, Int) Word8
19:42:07 <Jig_> so I need a function
19:42:19 <Jig_> imgToList :: StorableArray (Int, Int) Word8 -> [Int]
19:42:23 <pumpkin_> oh, you shouldn't need to play with pointers
19:42:39 <pumpkin_> doesn't StorableArray have a typical Array interface?
19:42:47 <MyCatVerbs> Yes, it has a MArray instance.
19:45:01 <mmorrow> Jig_: for a recent thing i was doing i needed to get a (Ptr Word8) of plain rgb(a) pixels, and had to abandon using pngload because you'd need to rewrite its interface to be able to do so (just fyi, not sure if that's something you need, and it looks like it's not :)
19:45:44 <Jig_> ah
19:45:57 <MyCatVerbs> imgToList ra = getBounds ra >>= mapM (readArray ra) . uncurry enumFromTo
19:46:46 <MyCatVerbs> Hrmn. Still too pointy. :)
19:47:04 <mmorrow> i ended up ditching png's altogether actually, since i was writing the pixel data to video memory via opengl and getting the images from graphviz, and since PNG uses some form of zlib compression using png's would add the overhead of encoding the data just to immediately be decoded
19:47:05 <MyCatVerbs> @pl \ra -> getBounds ra >>= mapM (readArray ra) . uncurry enumFromTo
19:47:05 <lambdabot> liftM2 (>>=) getBounds ((. uncurry enumFromTo) . mapM . readArray)
19:47:45 <pumpkin_> o.O
19:47:47 <MyCatVerbs> Oooh, liftM2 over the (->e) Monad, of course.
19:47:52 <pumpkin_> eww
19:48:08 <pumpkin_> :P
19:48:10 <MyCatVerbs> pumpkin_: hrmph. Well, I like it, anyway. :P
19:48:19 <pumpkin_> I like liftM2 over ->e too, usually
19:48:29 <pumpkin_> but I don't think that makes it much clearer :P
19:48:38 <pumpkin_> (in this case)
19:48:44 <pumpkin_> liftA2 is 1000% better ;)
19:49:15 <ivanm> pumpkin_: so it's 10 times better?
19:49:20 <pumpkin_> yup
19:49:28 <MyCatVerbs> pumpkin_: I concur. Still, I got an enlightenment buzz out of realising how @pl did that. :)
19:50:14 <pumpkin_> it still takes me a little to figure out those post-composition things
19:50:19 <pumpkin_> (. f) . g
19:50:55 <mmorrow> @pl \a b -> g a (f b)
19:50:55 <lambdabot> (. f) . g
19:51:03 <mmorrow> @pl \a b c -> g a (f b c)
19:51:03 <lambdabot> (. f) . (.) . g
19:51:04 <pumpkin_> yeah :)
19:51:22 <mmorrow> well, that pattern is news to me :)
19:51:27 * mmorrow likes it
19:51:35 <mmorrow> @pl \a b c -> g a b (f c)
19:51:36 <lambdabot> flip flip f . ((.) .) . g
19:51:48 <mmorrow> @pl \a b c -> h a (g b (f c))
19:51:49 <lambdabot> (. ((. f) . g)) . (.) . h
19:51:53 <mmorrow> gr
19:51:54 <Jig_> extending the PNG lib to jpeg and bmp, would it eb a lot of work?
19:52:26 <mmorrow> Jig_: bmp's are pretty simple actually, so writing a reader/writer for those is pretty simple (replatively)
19:52:46 <mmorrow> jpeg on the other hand... you'd need to implement a discrete cosine transform
19:53:38 <mmorrow> Jig_: i'm using a C .bmp reader/writer i got from elsewhere currently (it just does 8x8x8 rgb uncompressed bmp's):
19:53:51 <MyCatVerbs> BMP writing is completely trivial. BMP reading is a little harder, because you have to support RLE.
19:53:53 <mmorrow> http://moonpatio.com/repos/vacuum-gl/c/bmp.c and bmp.h
19:54:00 <mmorrow> it's pretty easy to ffi to
19:54:10 <pumpkin_> I fit RLE encoding and decoding into a tweet :P
19:54:14 <mmorrow> MyCatVerbs: you don't *have* to ;)
19:54:46 <pumpkin_> http://twitter.com/pumpkingod/status/1521371641
19:54:47 <pumpkin_> :P
19:54:49 <MyCatVerbs> mmorrow: ...yes you do! You totally do! At least if you want it to reliably work!
19:54:57 <pumpkin_> thar, simple
19:55:02 <mmorrow> MyCatVerbs: that's just an option
19:55:15 <mmorrow> not all bmp's are run-length encoded
19:55:22 <MyCatVerbs> mmorrow: otherwise your lusers will string you up from lampposts next time they go to import a BMP file into your program and it mysteriously barfs.
19:55:54 <MyCatVerbs> mmorrow: ...yes, and not all C programs have "goto" statements in them. However, that's not a sufficient excuse to write a compiler that barfs on it. ;P
19:56:14 * pumpkin_ senses the n+k patterns topic coming up again
19:56:15 <mmorrow> MyCatVerbs: that's why i keep a stock of ninja-smokebombs. so i can NINJAVANISH at ANY POINT.
19:56:16 <ivanm> pumpkin_: no, you need a recursive "tweet": have a tweet that lists the url of that tweet :p
19:56:25 <Cale> The fact that goto statements are terrible style is a good enough reason though. :)
19:56:39 <pumpkin_> ivanm: that'd be pretty cool, I wonder how predictable the ids are
19:56:51 <ivanm> I don't use twitter, so wouldn't know ;-)
19:57:07 <MyCatVerbs> Cale: you can take goto away from me when you pry it from my cold, dead fingers. Same story as printf, really.
19:57:10 <pumpkin_> I do use twitter, and I still don't know
19:57:12 <Jig_> ty
19:57:51 <Cale> MyCatVerbs: If you're going to have goto, you might as well go with full continuations :)
19:57:59 <ivanm> is it just me, or is this content not really applicable for a "kids" encyclopedia? http://encyclopedia.kids.net.au/page/en/Entscheidungsproblem
19:58:13 <Cale> ivanm: ahaha
19:58:19 <pumpkin_> lol
19:58:29 <pumpkin_> do they just rip content from wikipedia and stick a colorful background on it?
19:58:31 * ivanm hates sites that just steal and repackage wikipedia content
19:58:34 <ivanm> pumpkin_: yup
19:58:38 <p_l> ivanm: it's applicable for "awesome encyclopedia for kids" :3
19:58:45 <ivanm> p_l: heh
19:59:29 * p_l is a guy who read "Aircraft Weaponry Lexicon" instead of watching evening cartoons as first grader
19:59:52 <ivanm> p_l: yes, but how old were you when you went to first grade?
19:59:52 <ivanm> :p
20:00:02 <pumpkin_> hah
20:00:08 <MyCatVerbs> Cale: semantically, sure. Implementation-wise, no. Doesn't implementing full continuations require a Hell of a lot more work? Whereas there are fairly easy mechanical transformations from programs with gotos in them to programs without.
20:00:29 <p_l> ivanm: ~7yo?
20:00:32 <mmorrow> Jig_: this is a great paper (although the haskell dialect is outdated, since haskell no longer has monad-comprehensions, but just replace them with do-blocks in your mind) http://people.cs.uu.nl/jeroen/article/jpeg/
20:00:59 <Cale> MyCatVerbs: Really? Isn't it fairly similar?
20:01:00 <ivanm> does anyone know what the official wording of the Entscheidungsproblem is?  Wikipedia just says that hilbert proposed it :s
20:01:05 <pumpkin_> mmorrow is like a talking bibliographyt
20:01:10 <mmorrow> Jig_: also, i just found this while googling for that paper and haven't seen it before. it looks interesting too http://www.imperialviolet.org/binary/jpeg/
20:01:18 <Cale> ivanm: That page gives it
20:01:26 <mmorrow> pumpkin_: heh. i should make a page of paper/whatever links.
20:01:36 <ivanm> Cale: s/official/original/
20:01:39 <dolio> @yow! 100% program coverage.
20:01:39 <lambdabot> I'm reporting for duty as a modern person.  I want to do the Latin Hustle now!
20:01:50 <pumpkin_> dolio: on uvector-algorithms??
20:01:53 <Cale> ivanm: Oh, as Hilbert worded it?
20:01:57 <ivanm> yeah
20:02:09 <MyCatVerbs> Cale: well, you have to allocate frames on the heap rather than the stack if you're going to have full continuations, and they practically all but require GC in order to be usable.
20:02:10 <dolio> Yes. Although only 98% of expressions.
20:02:14 <ivanm> the only other mentions I find are to his 10th problem which deals with diophantine equations
20:02:27 <pumpkin_> dolio: wow :)
20:02:38 <ivanm> and a lot of people say it goes back to Leibniz, but not in what way
20:03:31 <mmorrow> Jig_: (that jpeg paper though uses naive convolution instead of an fft-like discrete-cosine transform implem)
20:05:02 <mmorrow> (iirc)
20:05:03 <dolio> hpc is pretty nice.
20:05:29 <pumpkin_> yeah
20:05:46 <Jig_> can you always
20:05:51 <wli> What's this that goes back to Leibniz?
20:05:52 <Jig_> a <- m [GHC.Word.Word8]
20:05:56 <Jig_> to get rid of the m?
20:06:05 <pumpkin_> ??
20:06:45 <mmorrow> Jig_: yes, but you can only do that temporarily w/in a do-block
20:07:03 <mmorrow> the end-result of the do-block will still be (m a) for some 'a'
20:07:27 <ivanm> you can't escape a monad!
20:07:47 <pumpkin_> what if it's a monad with an escape hatch?
20:07:50 <ivanm> well, not quite: you _can_ escape Maybe, [], etc.
20:08:01 <ivanm> and you can do so unsafely from others with unsafePerformIO
20:08:11 <Jig_> (MArray Data.Array.Storable.StorableArray GHC.Word.Word8 m,
20:08:11 <Jig_>       Num b)=>
20:08:18 <Jig_> can i get ri of that soembow or simplify it?
20:08:21 <mmorrow> Jig_: pretty much, any image code in haskell that's not inefficient will probably be largely in IO
20:08:38 <Jig_> and when ghci derivers types that rent int he prelude do i have to import them then?
20:08:38 <mmorrow> (or ST i guess)
20:08:51 <ivanm> Jig_: import the correct modules to avoid having the explicit types so long?
20:10:22 <adamvo> or don't write type signatures
20:10:23 <Cale> Jig_: what do you mean by that? If x :: m t, where m is some monad, and inside a do-block you write v <- x, then v :: t
20:10:46 <Cale> (and the do-block as a whole will have type m a for some a)
20:10:49 <ivanm> adamvo: of course you should write type-signatures!
20:10:54 <ivanm> for documentation purposes if nothing else!
20:11:03 <Jig_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4739#a4739
20:11:08 <Jig_> panic! the impossible happened
20:11:17 <pumpkin_> zomg stop abusing GHC
20:11:19 * pumpkin_ pats GHC
20:11:27 <Gracenotes> wat you say?
20:11:37 <pumpkin_> LEAVE GHC ALONE!!1!!!
20:11:42 <mikm> :D
20:11:59 <ivanm> Gracenotes: "hit the road, Jack"?
20:12:02 <Gracenotes> try the compilation flag it recommends
20:12:06 <Jig_> i dont have ana ccount someone wanna post it?
20:12:16 <Gracenotes> and/or... report it as a bug.
20:12:18 <Jig_> i did that caused the error
20:12:29 <pumpkin_> Jig_: we don't have the code :P
20:12:33 <pumpkin_> Jig_: is it reproducible?
20:12:39 <Gracenotes> ivanm: rather, you have no chance to survive, make your time!
20:12:46 <pumpkin_> just showing them the error message without showing them what caused it won't help much
20:13:08 <ivanm> pumpkin_: sure it will... isn't SPJ a genius? :p
20:13:21 <mmorrow> Jig_: that looks like a ghc bug to me
20:14:15 <mmorrow> getOptions'.parseLanguage(2) went past eof token
20:14:22 <Gracenotes> oh, hm.
20:14:32 <Gracenotes> :.
20:14:32 <mmorrow> is the {-# LANGUAGE ... #-} pragma malformed in some weird way or something?
20:14:58 <ivanm> Cale: this is apparently the Entscheidungsproblem: "Was mathematics decidable?", according to the halting problem page on wikipedia
20:15:02 <mmorrow> (maybe the "#-}" is missing and ghc scanned the entire file trying to find it?)
20:15:11 <ivanm> I'm not sure if that's the wording he used or someone's summary though...
20:15:17 <Gracenotes> LANGUAGE pragma parsing seems entirely weird
20:15:34 <Gracenotes> in the quirkiness of the bugs its produces
20:17:08 <Jig_> n type-variable argument
20:17:08 <Jig_>       in the constraint: MArray StorableArray Word8 m
20:17:13 <Jig_> so how do I solve that?
20:17:19 <Jig_> it is a PITA with huge ass types too
20:18:49 <Jig_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4740#a4740
20:18:54 <Jig_> yes, reproducible
20:20:36 <mmorrow> Jig_: i almost forgot, i have some PNG writing code http://moonpatio.com/repos/png-writer/
20:21:07 <pumpkin_> lol
20:21:21 <mmorrow> (if i were to redo that pkg, i'd probably ditch the GADTs and make the interface simpler (although it's not really complex))
20:22:11 <mmorrow> this makes a random png image (w/ alpha channel random too!) http://moonpatio.com/repos/png-writer/tests/randPNG.hs
20:23:12 <mmorrow> it uses lists, so could be made much more efficient too
20:24:03 <Cale> ivanm: Well, that's the idea of it.
20:24:39 <Cale> ivanm: More specifically, if you have a first order system with some axioms is there a general algorithm to decide whether or not any given statement is true.
20:25:19 <mmorrow> Jig_: ah, so instead of:
20:25:21 <mmorrow> {-# LANGUAGE -XFlexibleContexts #-}
20:25:24 <mmorrow> you do:
20:25:26 <mmorrow> {-# LANGUAGE FlexibleContexts #-}
20:25:29 <Jig_> is it a minor bug?
20:25:40 <mmorrow> looks like ghc doesn't fail gracefully if the "-X" is there
20:26:38 <Jig_> so no bug report?
20:27:27 <Jig_> @type (***)
20:27:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:27:55 <Jig_> > join (***) (+1) (3,4)
20:27:56 <lambdabot>   (4,5)
20:27:57 <pumpkin_> Jig_: you should definitely submit a report :) I think MyCatVerbs has the same bug too though
20:28:18 <Jig_> i dont see how the type for (***) works really
20:28:38 <Jig_> it failed with
20:28:38 <Jig_> {-# LANGUAGE FlexibleContexts #-}
20:28:43 <Jig_> before when i tried
20:28:49 <Jig_> but not after you told me
20:28:54 <Jig_> maybe i diodns eomthign else wrong to then
20:29:09 <pumpkin_> Jig_: the a can be (->)
20:29:21 <pumpkin_> and you can use it infix
20:31:14 <BMeph> So, does annyone else find the "zipp0" handy? :)
20:31:37 <BMeph> (That is, zipp0 = zip [0..])
20:32:00 <Cale> Jig_: So replacing a with (->), the type specialises to: (***) :: (b -> c) -> (b' -> c') -> (b,b') -> (c,c')
20:33:03 <pumpkin_> BMeph: yeah, actually
20:33:06 <pumpkin_> it even has a name in uvector
20:33:25 <Cale> Jig_: So there's only one function it could really be: (f *** g) (x,y) = (f x, g y)
20:33:58 <BMeph> Jig_: I'd suggest "Conal's Crutch" (that's what I call it... ;) and change all the "a b c" declarations to "b ~> c" for better comprehension. :)
20:35:07 * BMeph likes to use "><" instead of "***", though.
20:37:53 <mmorrow> Jig_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4740#a4741
20:38:42 <mmorrow> Jig_: you can ditch the LANGUAGE all-together and just do {-# OPTIONS_GHC -fglasgow-exts #-} as a (temporary) fix for the moment
20:40:08 <mmorrow> i didn't need any flags for that paste though
20:40:25 <mmorrow> BMeph: yeah, i'm a fan of (<>) and (><)
20:41:34 * mmorrow just realized that getting a Ptr to the data in a Storable array is trivial, but oh well
20:47:15 * pumpkin_ is trying to figure out how to freeze his arrays
20:48:40 <Axman6> N.I.N.J.A, spray it on them and they'll freeze right up
20:49:33 <mmorrow> pumpkin: that kind of arrays?
20:49:49 <pumpkin_> mutable lazy UArrs
20:50:01 <mmorrow> i mean, what kind of primitive array
20:50:02 <pumpkin_> implemented a bit like lazy bytestrings
20:50:12 <pumpkin_> oh, not going that far down, but it's just using a MutableByteArray
20:50:15 <mmorrow> so a list of ForeignPtrs?
20:50:17 <mmorrow> oh, ok
20:50:19 <pumpkin_> there's a simple interface on top of them
20:50:21 <pumpkin_> MBUArr
20:50:26 <ivanm> pumpkin_: use dry ice
20:50:28 <ivanm> ;-)
20:50:44 <mmorrow> GHC.Prim.unsafeFreezeByteArray#
20:50:54 <mmorrow> MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
20:51:03 <pumpkin_> mmorrow: hah, it doesn't even use that :P
20:51:06 * mmorrow was doing something with arrays the other day
20:51:07 <pumpkin_> it unsafeCoerce# it
20:51:11 <mmorrow> heh
20:51:21 <pumpkin_> maybe that should be changed
20:52:34 <pumpkin_> so my issue is that I have a chunk folding function
20:52:43 <pumpkin_> for my strict chunks
20:52:54 <pumpkin_> and they contain MBUArrs, that live in ST
20:53:10 <mmorrow> so you want to escape ST?
20:53:11 <pumpkin_> and I need to call the freeze function on individual chunks, wrapping them in the immutable chunk constructors
20:53:20 <pumpkin_> the whole function should be in ST, I think
20:53:26 <mmorrow> oh
20:53:37 <pumpkin_> but calling runST on individual chunks feels wrong
20:53:56 <mmorrow> you could just call it once at the end?
20:54:21 <pumpkin_> yeah, that's what I want to do, but trying to figure out how to build up my immutable copy doing that
20:54:25 <mmorrow> (and use a monadic fold then, so maybe a problem if you only have a pure fold)
20:54:37 <pumpkin_> yeah, but I wrote the fold myself, so I could just write another one :P
20:54:54 <pumpkin_> and in fact, a nonmonadic fold over chunks that live in ST
20:54:55 <mmorrow> why don't you build up a mutable copy, then freeze it?
20:54:57 <pumpkin_> seems a little silly
20:55:07 <pumpkin_> I want an unsafeFreeze first
20:55:11 <pumpkin_> I'll make a safe one later
20:55:25 <pumpkin_> but UArr uses a lot of unsafe freezing (that's really safe) behind the scenes
20:55:30 <pumpkin_> to move from streams to arrays
20:56:18 <mmorrow> i'm not sure i see the point here :)
20:56:33 <pumpkin_> how do you mean?
20:56:35 <mmorrow> (or s/point/issueorwhatever/
20:56:35 <Jig_> did the first compiler introduce types?
20:56:35 <Jig_> ie fortran introduced types into programming?
20:57:07 <pumpkin_> oh, there's no issue really, I was just trying to figure it out, but I'll just make a monadic fold over the chunks
20:57:15 <mmorrow> ahh, cool :)
20:57:31 <dolio> Why do your lazy arrays have mutable arrays inside?
20:57:39 <pumpkin_> only my lazy mutable arrays do
20:57:41 <Jig_> why does (getElems . imageData) return something that is 3 times as big as array really is?
20:57:47 <dolio> Lazy mutable arrays?
20:57:54 <mmorrow> Jig_: RGB
20:58:14 <pumpkin_> dolio: like lazy arrays, but mutable :P
20:58:14 <mmorrow> interlaced
20:58:21 <pumpkin_> dolio: think it's silly?
20:58:24 <mmorrow> [r,g,b,r,g,b,r,g,b,...]
20:58:34 <dolio> pumpkin_: I'm skeptical, at least.
20:58:34 <Jig_> mmorrow: oh my, not good
20:58:44 <Jig_> my matrix_class is for double
20:58:48 <mmorrow> heh
20:59:08 <mmorrow> you can just convert it to whatever you need of course :)
20:59:31 <pumpkin_> dolio: now that I think of it, maybe I don't need them... hmm
20:59:42 <pumpkin_> although maybe I do
20:59:44 <pumpkin_> hrmm
21:00:36 <mmorrow> Jig_: (and with PNGs, you can get either 1,3,or 4 channels per pixel)
21:00:38 <pumpkin_> dammit, so much going on, this is hard to think about :P
21:00:43 <mmorrow> greyscale, rgb, rgba
21:01:27 <Jig_> hmm
21:01:31 <mmorrow> alpha ==> (0,255) := (transparent, fully opaque)
21:01:40 <Jig_> well really i should use hmatrix if i get serious about this
21:01:50 <Jig_> but can hmatrix store triples?
21:01:55 <mmorrow> Jig_: yeah, that would be a good choice
21:02:09 <mmorrow> Jig_: you can store the different channels in different matrices
21:02:34 <mmorrow> (so you'd have to deinterleave at some point)
21:03:36 <Jig_> lol this turned into a clusterf*ck fast
21:04:51 <dolio> pumpkin_: I guess you could use those to add storage to a mutable array without reallocating and copying all the old stuff.
21:05:10 <pumpkin_> I came up with a few contrived examples of why they'd be useful
21:05:27 <pumpkin_> they certainly wouldn't hurt, but it's getting quite complex
21:06:31 <mmorrow> Jig_: what sort of manipulations are you looking to do on images?
21:06:51 <dolio> But a Seq of mutable arrays would probably be better for that.
21:07:10 <dolio> I mean, you could never have an infinite mutable array.
21:07:33 <Jig_> mmorrow: implaying aroun with OpenCV(Open computer vision) too, i want to do facedetection/facerecognition eventually
21:07:39 <Jig_> i know about easyVision
21:07:48 <Jig_> but im on windows and ic ant get hmatrix going
21:08:01 <pumpkin_> dolio: that'd mean having a different representation for the mutable and immutable version though...
21:08:02 <Jig_> gsl hang up when i tried to copile it( after ~10 hours)
21:08:07 <mmorrow> hmm. install linux? :)
21:08:11 <mmorrow> Jig_: ooh, that sucks
21:08:35 <dolio> Yeah, I'm not necessarily suggesting it.
21:09:08 <pumpkin_> I was trying to keep the mutable one as similar to the immutable one as possible, although having O(1) snoc would be nice
21:09:23 <mmorrow> Jig_: i haven't done really any dev on windows, so i'm not sure what you should do
21:09:33 <dolio> A seq of mutable arrays is like a mutable rope.
21:09:38 <pumpkin_> yeah
21:09:42 <hatds> I compiled gsl on windows, but I'm not sure if I remember what I did
21:09:43 <pumpkin_> it sounds quite attractive really
21:09:49 <Jig_> i have ubuntu/vista 50/50 but cant get wireless going
21:10:08 <Axman6> tow of my least liked OS's...
21:10:11 <Axman6> two even
21:10:36 <Jig> :)
21:10:41 <Jig> you on Arch?
21:10:42 <pumpkin_> then we'd need Seq fusion :P
21:10:48 * p_l found he started disliking Ubuntu more than Vista
21:10:48 <Jedai> Jig: What kind of wireless chip ?
21:11:23 <Jedai> p_l: Really, why ?
21:11:46 <pumpkin_> I dunno, I'll keep working on mutable lazy uarrs the way I was going for now
21:11:53 <pumpkin_> maybe ropes will come later
21:11:56 <mmorrow> pumpkin_: this is a pretty "sequence" of Sequences http://moonpatio.com/vacuum/gallery/sequence.html
21:12:20 <mmorrow> it's neat to see how they grow
21:12:24 <pumpkin_> ooh nice
21:13:33 <mmorrow> pumpkin_: and Yi uses (Sequence ByteString) for ropes iirc
21:14:24 <Jig> realtek
21:15:00 <pumpkin_> yeah, a uvector rope would be quite nice
21:15:10 <Jig> a nice function for tuplify each triple of alist?
21:15:14 <Jedai> mmorrow: That don't seem to be a really good rope. Shouldn't they use a Fingertree with another monoid ?
21:15:20 <mmorrow> pumpkin: ah looks
21:15:24 <mmorrow> yeah, what Jedai said
21:15:26 <pumpkin_> yeah
21:15:30 <Jig> toRGB :: [Int] -> [(Int,Int,Int)]
21:15:33 <mmorrow> they use FingerTree directly
21:15:34 <mmorrow> http://code.haskell.org/yi/Data/ByteRope.hs
21:15:50 <pumpkin_> it'd be interesting to try to get fusion on that working
21:16:04 <Jedai> That makes sense
21:16:14 <pumpkin_> I guess you wouldn't necessarily have to do much
21:16:43 <mmorrow> , let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs in chunk 3 [0..]
21:16:44 <lunabot>  [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,2...
21:16:47 <mmorrow> , let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs in chunk 4 [0..]
21:16:48 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
21:17:17 <pumpkin_> don't like unfold?
21:17:31 <p_l> Jedai: Windows doesn't have some kind of binding philosophy of how things should work like Unix has, so it can't really break it. Various stuff I had seen out of various "friendly" distros nowadays make me scream
21:17:35 <mmorrow> , let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs in transpose (chunk 4 [0..15])
21:17:36 <lunabot>  [[0,4,8,12],[1,5,9,13],[2,6,10,14],[3,7,11,15]]
21:17:55 <mmorrow> [reds,greens,blues,alphas]
21:19:40 <Jig> i have it
21:20:31 <Jig> let xs = [1..20000000] in length xs < 3
21:20:35 <Jig> is lazy right?
21:20:38 <Jig> > let xs = [1..20000000] in length xs < 3
21:20:40 <lambdabot>   False
21:20:45 <Jedai> Jig: Nope
21:20:45 <Jig> > let xs = [1..2] in length xs < 3
21:20:47 <lambdabot>   True
21:20:49 <mmorrow> no it's not, unfortunately
21:20:53 <mmorrow> use take
21:20:57 <Jig> it seemd fast
21:20:59 <Jig> er
21:21:22 <pumpkin_> there's no way it can be lazy unless you use lazy numbers
21:21:23 <mmorrow> , (\n xs -> length (take n xs) < n) 4 [0..]
21:21:24 <lunabot>  False
21:21:31 <mmorrow> , (\n xs -> length (take n xs) < n) 4 [0..2]
21:21:32 <lunabot>  True
21:21:40 <Jedai> Jig: It's not lazy though that's pretty easy to correct, using take (alternatively you could use Peano integers and genericLength....)
21:22:28 <Jig> @type genericLength
21:22:29 <lambdabot> forall b i. (Num i) => [b] -> i
21:22:34 <Jedai> > 5 :: Nat
21:22:35 <lambdabot>   Not in scope: type constructor or class `Nat'
21:22:45 <Jig> peano integers = data Nat = O | S Nat ?
21:23:40 <Jedai> > (genericLength [0..] :: Natural) > 3
21:23:41 <lambdabot>   True
21:24:03 <Axman6> @src NAtural
21:24:03 <lambdabot> Source not found. Just try something else.
21:24:05 <Axman6> @src Natural
21:24:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:24:10 <Jig> nice pics mmorrow
21:24:21 <mmorrow> Jig: :)
21:24:47 <mmorrow> imagemagick's montage is great
21:25:02 <mmorrow> (as is graphviz)
21:25:08 <Jedai> Jig: Yes, that's Peano integers at their most naive
21:25:44 <Jig> i thought their whole point was being simple?
21:25:59 <Jig> same def as in Coq i think(?)
21:26:21 <Jedai> mmorrow: Vacuum really helped to visualize data structure in Haskell :)
21:26:51 <Jedai> Jig: Yep, simple, lazy and slow as hell, that's Peano integers !! ^^
21:27:06 <mmorrow> Jedai: :) i'm thrilled with how pretty the heap is
21:29:57 <pumpkin_>   foldrChunksMPrim :: (MBUArr s e -> b -> ST s b) -> b -> MLUArr e s -> ST s b
21:30:06 <pumpkin_> does that look like too crazy a type signature?
21:30:29 <Gracenotes> ... flip? .-.
21:30:35 <Gracenotes> :)
21:30:44 <Gracenotes> oops, L vs. B
21:30:55 <pumpkin_> for some reason the current library is inconsistent
21:31:00 <pumpkin_> I was going to ask dons about that
21:32:02 <pumpkin_> (with whether it puts the state thread parameter first or second)
21:33:05 <dolio> You can't define a type/data family with the state thread parameter in the first argument.
21:33:16 <pumpkin_> oh, that makes sense
21:33:20 <dolio> Not sure why it's first in the BUArr stuff.
21:33:22 <pumpkin_> so it'd probably be nicer to flip the MBUArr
21:33:27 <pumpkin_> well
21:33:30 <pumpkin_> *possible
21:35:08 <hatds> why isn't there a 'flip' for type constructors anyway?
21:38:28 * BMeph thinks everyone should just use STFUArrays... ;p
21:38:55 <hatds> *spitake*
21:39:04 <hatds> er spit take even
21:39:46 <adamvo> @hoogle fmap2
21:39:46 <lambdabot> No results found
21:40:42 <adamvo> derive uses it, any idea where to get this into scope?
21:41:48 <hatds> dunno?  http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
21:41:55 <hatds> googled it
21:43:16 <Berengal> fmap2 = liftA2 ?
21:43:45 <clugish> hi
21:43:46 <lambdabot> clugish: You have 1 new message. '/msg lambdabot @messages' to read it.
21:44:17 <BMeph> @hoogle something
21:44:18 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
21:44:25 <BMeph> HEh-heh. :)
21:44:44 <adamvo> anyways, the derived instance is:
21:44:46 <adamvo> instance Functor (TreeZ t1) where fmap _f (TreeZ a1 a2) = TreeZ (_f a1) (fmap (fmap (fmap (fmap _f) . fmap2 (fmap _f))) a2)
21:45:06 <adamvo> data TreeZ b a = TreeZ { focus :: a, parents :: [(b,Either (Tree b a) (Tree b a))]}
21:45:48 <Berengal> Either (Tree b a) (Tree b a) ?
21:45:53 <Berengal> What use is that?
21:45:56 <adamvo> I guess I'll just have to write that instance myself
21:46:26 <adamvo> Berengal: the focused leaf can be a left or right subtree
21:46:38 <adamvo> but only one
21:46:51 <Berengal> Oh, you just wanted Left and Right there
21:47:10 <adamvo> I guess that could be done as (Bool,Tree b a)...
21:47:44 <Berengal> I guess it makes sense when pattern matching on constructors
21:48:13 <Berengal> Bool might be clearer...
21:49:04 <adamvo> and it might confuse derive less
21:51:26 <adamvo> yep, no fmap2 showing up when I use (Bool,Tree b a)
21:53:12 <adamvo> heh, does anybody else find that you don't have to reason much about code anymore, so long as it passes a bunch of quickCheck tests (and actually compiles)?
21:54:04 <Berengal> Kinda. I reason about programs, but I seldom need to reason about code anymore
21:54:35 <Berengal> The code is just a means of expressing myself, it's not what I want to express itself.
21:55:57 <pumpkin_> hmm, can I not use bang patterns in lambdas?
21:56:14 <adamvo> ex. with this tree zipper, the implementation is pretty easy to verify, and it simplifies the actual problem quite a bit
21:58:23 <jinjing> for a moment, i though planet haskell is hijacked by planet ruby
22:06:33 * wli ponders addition chain multiplication.
22:07:29 <pumpkin_> why is there no foldrM?
22:08:23 <pumpkin_> oh, there is in Foldable
22:13:27 * wli fails.
22:20:56 <wli> Like what?
22:24:19 <cads> hey, how could I go about creating a survey of languages to find the language in which technical code is most succinctly expressed, say I'd like to find the language in which on average the same task will take fewer lines of code, whether it's a raytracer, or physics simulation, or graphics package or cad modeling package.
22:24:31 <cads> what languages do you guys think will be most concise for those floating point heavy, higher order mathematical abstraction reliant programs?
22:25:19 <pumpkin_> something like matlab with built-in everything related to vectors/matrices maybe?
22:25:22 <pumpkin_> but depends on the problem
22:25:49 <cads> I wonder how matlab does for cross platform compilation
22:25:55 <roconnor> is Haskell's type class polymorphism "the same as" dynamic dispatch?
22:25:56 <cads> that doesn't sound that bad
22:26:13 <pstickne_> roconnor:  short answer: no
22:26:20 <cads> matlab is a weak language but the packaged you get get to work with are pretty amazing
22:26:23 <roconnor> what's the long answer?
22:26:55 <pstickne_> oh, skipped the quotes...
22:27:06 <cads> roconnor: isn't it more like overloading?
22:27:08 <roconnor> ya, they are important. :)
22:27:22 <roconnor> what's the difference between overloading and dynamic dispatch?
22:27:40 <cads> overloading is statically bound and compiled in?
22:28:01 <cads> you're still having to decide types but it's done in a finite framework?
22:28:02 <roconnor> cads: right, but the dictionary look-up makes it feel like dynamic dispatch
22:28:24 <cads> well that's essentially all polymorphism can be, isn't it?
22:28:33 <roconnor> well ....
22:28:56 <roconnor> possibly
22:29:19 <cads> i wanna look at the implementation to see how that's done now!
22:30:56 <roconnor> JHC/LHC does case analysis on types
22:31:05 <roconnor> which is still arguably dynamic dispatch.
22:34:21 <Athas> Can't you do dynamic dispatch with typeclasses and existential types?
22:41:08 <Gracenotes> dynamic dispatch is, to me, a compile-time vs. run-time  thing
22:42:02 <Gracenotes> for inclusional polymorphism like typeclasses, it is run-time. dictionaries are maintained, like vtables in C++
22:42:56 <Gracenotes> for parametric polymorphism... hm, I'm not so sure about that. There is really not much dispatch involved; type checking happens just at compile-time
22:43:44 <Gracenotes> hm. I don't see why type classes don't have dynamic dispatch either ;_;
22:45:32 <cads> with dynamic dispatch I can manually invent a new type during runtime and set it loose in the system, and it handles it like normal operation
22:46:06 <Gracenotes> uh, runtime? Not so sure about that.
22:46:37 <cads> at least in ruby you can add methods to classes, remove methods, replace code, etc.
22:46:39 <Gracenotes> well, if your language supports dynamic reloading :)
22:47:21 <cads> all from normal code... creating new classes, even, packed with randomly generated lambdas, ruby can get really meta programmer-tastic
22:47:31 <Gracenotes> or reified internal structures. . . .. but that's an odd metric in that it's not applicable to all languages
22:47:37 <cads> but that's just a capability of duck typing
22:47:38 <p_l> cads: I'd prefer compilation, though, instead of eval
22:48:41 <cads> they are working on that, but if you want that look at smalltalk, I think even clojure has multimethods you can dynamically add submethods to
22:49:11 <p_l> cads: all respectable Lisp systems have that
22:49:21 <Associat0r> that is multiple dispatch
22:49:32 <p_l> Associat0r: I meant modification of code in runtime
22:49:46 <cads> hey, if I want to create and manipulate new types in a haskell program, what kind of extensions should I run?
22:50:01 <Cale> None?
22:50:02 <cads> that is, at runtime, or something
22:50:07 <Gracenotes> uh... Data.Dynamic? It's really a static language.
22:50:09 <Cale> That's not meaningful.
22:50:12 <Associat0r> p_l I was referring to cads
22:50:25 <Cale> Types are properties of the program which are checked at compile time.
22:50:31 <Cale> :)
22:51:10 <Gracenotes> right. type checking is sort of irrelevant after compile time, and anywhere it's required it's more of a barebones thing. so it seems
22:51:18 <cads> wait and haskell's very declarative
22:52:34 <Cale> If you need lots of different possible structures at runtime, you create very broad datatypes which have lots of values.
22:52:53 <Cale> (and so it's all just one type that you're using, but that type has a lot of values in it)
22:53:34 <cads> hrm, I think I forgot exactly what point I was making with oh wait, what about dynamic lists of elements of any type?
22:55:04 <Twey> Data.Dynamic and/or HList
22:55:15 <Twey> Well
22:55:38 <Twey> If you don't need to actually do anything with the contents, I imagine you can have a heterogenous list
22:55:39 <Gracenotes> or existentials.
22:55:58 <Twey> > [1, "hi", 9.5] :: [a]
22:55:59 <lambdabot>   Couldn't match expected type `a' against inferred type `[Char]'
22:56:07 <Twey> Oh, right
22:56:13 <Twey> Yeah, existentials.
22:56:47 <Gracenotes> the type system generally won't let you do anything that will cause types to blow up in your face, so existentials are limited in that you don't know what a general [exists a. a] will be like, so you can't do anything with it, really
22:57:16 <Gracenotes> well. forall.
22:57:39 <cads> hrm
22:58:50 <cads> with class based inheritance I can have a list of random types that all have at least a basic reflection methods... but I think we can encode those with type classes if we're clever
23:00:15 <Berengal> Disregarding reflection, you can have a type Box = forall a. (Show a) => Box a
23:00:29 <Berengal> You can then have a [Box] you can show on
23:00:43 <Berengal> (Assuming instance Show Box where show (Box a) = show a)
23:00:44 <cads> will it show [Box]?
23:00:51 <cads> oh
23:01:07 <cads> nice
23:01:22 <Elly> 2
23:01:25 <Elly> oops!
23:01:29 <Berengal> Also, I think UHC has something like [exist a. (Show a) => a]
23:01:44 <Berengal> But I haven't tried it
23:01:45 <mauke> a.k.a. [String]
23:02:19 <Berengal> mauke: No, it takes any showable type
23:02:25 <mauke> so does show
23:02:42 <Berengal> Okay, it takes all showable types then
23:02:59 <mauke> (I think there is no real difference between show and Box)
23:03:06 <Berengal> show is a function...
23:03:11 <mauke> so is Box
23:03:24 <mauke> Box :: (Show a) => a -> Box
23:03:35 <Berengal> Yes, true
23:04:01 <Berengal> How about Box :: (Show a, Eq a) => a -> Box
23:04:27 <mauke> no real difference :-)
23:04:58 <cads> hehe
23:05:02 <mauke> you can only compare elements with themselves, so Eq isn't really useful
23:05:08 <cads> I was thinking of that
23:05:19 <Berengal> (Show a, Eq a) => a -> a -> Box then
23:05:26 <mauke> Box :: (Typeable a) => a -> Box
23:05:48 <mauke> Berengal: (String, Bool)
23:05:49 <cads> see, you end up wanting to use type information at runtime
23:05:56 <Jig> what goes under numerical and what under math?
23:06:06 * Twey read that as Berengal :: (String, Bool)
23:06:24 <Jig> couldnt someone clean up or recommend people to use Data not DataStructures
23:06:37 <Berengal> More like [(String, Bool)] where type Statement = (String, Bool)
23:06:51 <Twey> There's no standardisation for module names beyond what's defined in the Report
23:12:02 <solrize_> @seen lemmih
23:12:02 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 13h 57m 49s ago.
23:12:06 <Cale> and even the names defined by the report are kind of deprecated now (aside from Prelude)
23:12:34 <Cale> Jig: Oh, you're talking about the package categorisations on hackage?
23:13:08 <Cale> Jig: That's even less regulated. Each package just has a list of tags, and it appears under those headings in the package list.
23:14:45 <Twey> Using Data.Foo is just a convention — packages are free to ignore it if they choose
23:18:15 <Berengal> Twey: Packages are also free to be ignored ;)
23:18:30 <Twey> Truly :)
23:26:32 <Jig_> anyone know Singular value decomposition?
23:26:32 <Jig_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4743#a4743
23:27:01 <Jig_> im supposed to predict the zero by mulltiplying u(n)*v(n) or soemthing for all factors and then sum them?
23:27:39 <noob123> ?! --- octave-3.0.2.exe:29:C:\Program Files\Octave\3.0.2_gcc-4.3.0\bin > Mommy Loves Cock 8
23:27:39 <lambdabot> Maybe you meant: . ? @ v
23:28:47 <Jig_> how di that get thre
23:30:36 <noob123> lol
23:30:53 <Axman6> ...
23:31:00 <solrize_> so does this holumbus distribution stuff mean that haskell is catching up with erlang
23:31:01 <solrize_> ?
23:31:22 <Axman6> well, i took it to mean that there's libraries to do erlang like stuff
23:31:39 <noob123> hi jig
23:31:48 <Jig_> hi
23:31:52 <noob123> deleted the line with the movie title?
23:31:56 <Jig_> yes
23:32:01 <noob123> :-D
23:32:10 <solrize_> axman6, yes, that's what i mean
23:32:16 <Jig_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4744
23:32:25 <Jig_> it was a link from a friend
23:32:27 <Jig_> hes a freak
23:45:52 <ksf> is there a usable darcs gui by now?
23:47:33 <Jig_> hmm does it make sense to multiply images?
23:47:46 <Jig_> ie have matrix multiplication for a matrix that reps images?
23:48:01 <Jig_> you aply filters normally which isnt the same really
23:51:14 <Jig_> is there some nice arrow to use ona 3 -tuple?
23:51:45 <pumpkin_> no, (n /= 2)-tuples are 3rd-class citizens
