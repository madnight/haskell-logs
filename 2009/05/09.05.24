00:00:20 <Neut> Cause its a guard it stops once it finds one which is valid
00:00:29 <copumpkin> dolio: works great
00:00:56 <dolio> Awesome.
00:01:04 <copumpkin> Prelude GHC.Integer> modExpInteger (3^17) (4^20000) (7^160)
00:01:04 <copumpkin> 618928464574875079049335204395986400456569777502324620865987838839989511452489437121589504952607045885791727658022613342936830757656286
00:01:28 <dolio> Is that right?
00:01:42 <copumpkin> it was correct on the smaller integers I tried it on :P
00:01:46 <dolio> :)
00:01:50 <copumpkin> proof by induction ;)
00:02:44 <Gracenotes> hm. that'd be interesting, in practice. Proving a function on a, b, c, where a = b = c = 0, and then proving that given any a b c, it's true for (a+1) b c, a (b+1) c, and a b (c+1)
00:03:10 <copumpkin> not sure that holds
00:03:18 <Gracenotes> I'm not sure either
00:03:24 <Neut> Can I get some help with the recursion in the courPoints function?
00:03:26 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2471#a2471
00:03:52 <dmwit> Why wouldn't that hold?
00:04:03 <erikc> what's the best package for doing runtime loading/linking of code? is it still hs-plugins?
00:04:06 <Gracenotes> seems like it should. Perhaps it needs to be proven, though >_>
00:04:13 <dmwit> It might be hard to prove those particular induction steps for most functions, but they seem valid enough to me.
00:04:31 <dmwit> erikc: The GHC API, I guess.
00:04:39 <dmwit> erikc: There's stuff like hint, too, now.
00:04:59 <dmwit> Neut: I'm not sure I understand what's wrong with your code.  What problem are you having?
00:05:24 <Neut> dmwit: because I have used guards it doesn't recurse threw, ie once it finds Jacks it only counts the jacks
00:05:32 <Neut> It doesn't keep going and check for Queens etc
00:05:59 <dmwit> I wouldn't think you would want recursion for that, anyway.
00:06:13 <Neut> How would you do it?
00:06:37 <outchanter> is it supposed to be "countRank hand Jack" on the right hand side for every case?
00:06:59 <Neut> No I realised that once I pasted, but it doesn;t make a difference
00:07:07 <Neut> it should be the card its checking for
00:07:12 <Neut> to times by that number
00:07:22 <copumpkin> dolio: so what do you think is needed... mpz_invert, mpz_fac, mpz_root, mpz_rootrem, mpz_sqrt, mpz_sqrtrem, mpz_perfect_power_p, mpz_perfect_square_p, (maybe jacobi, legendre, and kronecker?) (the prime functions in IO/ST) ?
00:07:29 <copumpkin> I guess not ST
00:07:31 <dmwit> sum [countRank hand rank * score | (rank, score) <- [(Jack, 1), (Queen, 2), {- and so on -}]] -- seems reasonable
00:07:49 <dolio> copumpkin: I'd just put in as many as you can, if it's easy.
00:07:57 <copumpkin> fair enough
00:08:03 <dmwit> Or some variation on that.  In any case, some maps and folds or a nice list comprehension seem like the way to go here.
00:08:22 <dmwit> But even better would be to simply have a function "score :: Rank -> Int".
00:08:44 <dmwit> Then it would be "courPoints = sum . map score".  Simple. =)
00:08:50 <dmwit> +t
00:09:05 <dolio> copumpkin: I'm not sure if both sqrt and sqrtrem are worth doing, of course. You could just do the latter and project out the former in Haskell.
00:09:15 <dmwit> Well, sum . map (score . fst), I guess.  But you get the idea.
00:09:41 <dolio> I'm not sure if there'd be a serious performance hit for that or not.
00:09:44 <copumpkin> dolio: I guess assuming it's not a lot more efficient
00:09:50 <copumpkin> yeah
00:10:01 <copumpkin> it seems reasonable
00:10:16 <dolio> It might matter if you're doing it in a really tight loop, but then, why would you?
00:10:21 <Neut> dmwit: list comprehension did the trick
00:10:21 <copumpkin> who knows :P
00:10:23 <Neut> thanks
00:10:30 <copumpkin> a crazy euler problem
00:10:35 <copumpkin> ;)
00:10:45 <copumpkin> some new form of asymmetric cryptography
00:10:50 <copumpkin> can't think of much else that would use this
00:13:04 <copumpkin> dolio: I don't know much about the algorithms behind this stuff... you think it's even worth separating the sqrt from the general root?
00:13:17 <dolio> No idea.
00:13:31 <copumpkin> I guess if they provided them separately, I'll provide them separately
00:13:33 <copumpkin> doesn't cost me much
00:14:25 <sm_> is there an existing lib that "openBrowserOn -- Attempt to open a web browser on the given url, all platforms." would fit into ?
00:14:55 <sm> System.IO ?
00:15:33 <sm> System.Process ?
00:16:37 <sm> System.WebBrowser ?
00:17:01 * sm guess the last
00:29:11 <jeffz`> sm, System.DesktopIntegration maybe?
00:40:08 <erikc> ugh, using hint inflates the executable size...a little bit
00:45:44 <twb> Does cabal run GHC with -Wall by default?
00:46:07 <ivanm> twb: I don't think so...
00:46:29 <twb> ivanm: I tried ./Setup build --ghc-option=-Wall, but it didn't seem to do anything differently.
00:48:30 <ivanm> is Fast Packed Strings a precursor to Bytestrings?
00:49:11 <Cale> ivanm: yes
00:49:29 <ivanm> thought so
00:52:05 <ivanm> is ndm's page on tagsoup here still valid? http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
00:52:09 <ivanm> ?
00:52:34 <chu_> hey guys, I'm looking for a way to deal with random numbers, specifically, I have an arbitrary list, and want to grab a random element from it, I can't find anything myself, does anyone have any references I could look at?
00:53:40 <twb> chu_: find the length of the list, then than the nth element from the list, where n is a random number between zero and the list length.
00:53:56 <twb> chu_: so your new question is: how do you generate a random number.
00:54:05 <chu_> Well, I have that much
00:54:06 <chu_> :)
00:54:24 <twb> hoogle(1) turns up some hits for "random".
01:01:05 <kuribas> Does anyone know if this library is production quality? http://www.carlssonia.org/ogi/Adaptive/
01:04:44 <ivanm> kuribas: define "production quality"
01:04:46 <Cale> It looks extremely old...
01:05:29 <ivanm> there's a 0.22 on hackage
01:05:36 <kuribas> ivanm: Fast enough to create an interactive application.
01:05:38 <ivanm> and adaptive-containers by dons version 0.3
01:05:53 <ivanm> kuribas: oh, I thought you were implying _stability_
01:06:36 <ivanm> which is the normal definition of "production quality" that I've heard
01:06:44 <kuribas> I see.
01:07:16 <kuribas> I am more concerned with memory usage and speed.
01:07:45 <kuribas> It's the only library I found that does incremental computing.
01:08:21 <kuribas> I want to write an interactive music notation program, where any changes to the score are automatically propagated.
01:08:22 <Cale> Well, I can imagine the implementation of priority queues as lists might be a little bit slow
01:08:52 <Cale> But it really depends on how big the computations get.
01:08:56 <kuribas> I could replace it then.
01:09:49 <Cale> Right, if it does what you want, then take it. If it's slow, you can always profile things and figure out what needs replacing.
01:10:11 <kuribas> Right.
01:10:20 <Gracenotes> , reallyUnsafePointerEquality 4 4
01:10:22 <lunabot>  luna: Not in scope: `reallyUnsafePointerEquality'
01:10:35 <Gracenotes> , reallyUnsafePtrEquality 4 4
01:10:38 <lunabot>  False
01:11:06 <Gracenotes> hm. Does anyone know how this is defined?
01:11:10 <Berengal> , let a = 4 in reallyUnsafePtrEquality a a
01:11:12 <lunabot>  True
01:11:44 <Gracenotes> it might be from reallyUnsafePtrEquality# (GHC.Prim), but it seems more advanced
01:12:03 <Berengal> More advanced how?
01:13:22 <chu_> I have tried to write a random function, but it fails (it's only 2 lines so that could explain why), could I paste it here and have someone help? I'm guessing it has to do with my non-existent understanding of monads...
01:13:48 <Berengal> @paste
01:13:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:13:57 <Cale> chu_: We can have a look
01:14:12 <chu_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5180#a5180
01:14:22 <Gracenotes> Berengal: well, for one, it returns True/False instead of an Int#
01:14:33 <copumpkin> the Int# just gets translated to Bool
01:14:38 <copumpkin> I think they're identical
01:15:21 <Cale> chu_: Seems to work in that it picks a random index from 0 up to the length of the list.
01:15:26 <voker57__> chu_: swap getStdRandom and randomR calls
01:15:34 <Cale> what?
01:15:38 <voker57__> eh...
01:15:39 <Gracenotes> I don't think so
01:15:49 <Berengal> chu_: Works on my machine
01:15:55 <Gracenotes> I# (reallyUnsafePtrEquality# 4 4)  -> yields 1
01:16:04 <Gracenotes> let a = 4 in I# (reallyUnsafePtrEquality# a a)  -> yields 1
01:16:11 <Gracenotes> not the same results as above
01:16:26 <voker57__> no, i'm wrong
01:16:33 <Berengal> Gracenotes: Did you notice the part where it says "reallyUnsafe"?
01:16:45 <Berengal> I'm betting RT is not something you can depend on
01:16:53 <Gracenotes> I'd at least like to see the source
01:17:07 <Gracenotes> if it's as simple as I#'ing it and checking against 0/1
01:18:03 <chu_> It apparantly cannot deduce (Random a) from the context of (Num a) a possible fix is to append (Random a) to the type signature for randomList, however I have no definition of randomList
01:18:20 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5180#a5181
01:18:40 <Cale> chu_: uhh...
01:18:48 <Cale> chu_: That looks like an error not associated with this code
01:19:23 <chu_> Well, if I comment out the drawInt function it runs :)
01:20:03 <Cale> What's the exact error message you're getting?
01:20:23 <chu_> No
01:20:27 <chu_> Works, now :)
01:20:28 <chu_> Cheers
01:20:29 <Berengal> chu_: If you have a type signature for the function that fails, try killing it and let ghc infer it for you
01:20:31 <chu_> Your version
01:20:31 <Cale> okay :)
01:20:40 <chu_> Thanks heaps
01:20:49 <Cale> Probably something else isn't a list of Ints
01:21:07 <Cale> Or doesn't expect an IO Int, but an IO <something else> ?
01:21:29 <Cale> anyway, seems okay now :)
01:21:48 <Berengal> Cale: Num a => a's are usually unified with Int with no trouble though
01:22:07 <Cale> Not if they need to be polymorphic...
01:22:12 <Cale> But I don't know.
01:22:23 <Berengal> If that were the case, the error message would be different
01:22:44 <Cale> chu_: You should also be aware that putting your whole algorithm in IO for the sake of random numbers is a bit drastic if that's what you're doing.
01:23:14 <Cale> chu_: but if it's something that already has to be in IO, this isn't too bad
01:26:10 <dons> Cale: you should write the definition guide to random numbers in haskell
01:26:11 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
01:26:15 <dons> srsly FAQ :)
01:27:23 <Cale> dons: I did that a long time ago, sort of, it was on the old wiki, but since the original questioner wasn't around to give an attribution, it was lost.
01:28:24 <Berengal> I can't find a de-facto standard Random monad anywhere. Is there one?
01:29:26 <Cale> There's a MonadRandom package on hackage
01:30:08 <Berengal> Ah, yes.
01:31:55 <sayyestolife> hmm, I'm trying to do a function that replace a certain char with another, but I can't seem to get the lambda right.. This is what I have so far "replace search replacement subject = map (\x if x == search then replacement) subject"
01:32:16 <sayyestolife> and it doesn't compile
01:32:33 <Berengal> sayyestolife: Your if needs an else clause
01:32:43 <sayyestolife> oh that is true
01:33:04 <sayyestolife> it still doesn't compile though
01:33:17 <Berengal> You also need the -> arrow in the lambda
01:33:39 <sayyestolife> Hmm.. Where?
01:33:45 <outchanter> after \x
01:33:53 <Berengal> What he said
01:34:03 <sayyestolife> ah okay
01:34:46 <Gilly> When using a relation db is it usually better to transfer only the ids of rows in the program and do small queries whenever you need some data or do one big query and transfer it all between functions? The problem with the first one is that pure functions will need their data in one shot anyways.
01:40:22 <tetha> mm, from my limited experience with databases, I recall that databases dislike tiny queries and the connection to the database tends to dislike gigantic queries, at least if its a network
01:41:41 <Gilly> well, it's local and the data includes only some text / integer fields, lot of them but not much in bytes.
01:42:23 <Gilly> the db i'm using is postgresql
01:43:16 <tetha> if its not large, just get everything you need and look if its too slow
01:43:51 <Gilly> yea, i guess that's the way :P
01:44:48 <Berengal> Let the db do as much work as possible. That way you get the best of both world: small dataset fetched in a single query.
01:44:48 <tetha> I mean, it will be slow due to something different by one of the laws of software optimization
01:45:23 <Berengal> Else, use lazy queries
01:46:29 <voker57__> @hoogle a -> [a] -> [a] -> [a]
01:46:30 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
01:46:30 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
01:46:30 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
01:46:47 <Gilly> Well, specialized queries would be the best but I think it makes the separation of GUI and DB a bit harder since different GUIs could need different queries.
01:46:52 <voker57__> @hoogle (a -> Bool) -> [a] -> [a] -> [a]
01:46:53 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
01:46:53 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:46:53 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:46:57 <chu_> Can I "create" a local variable in a do expression? Like x <- p * q or something.....
01:47:11 <copumpkin> let x = p * q
01:47:11 <Berengal> chu_: You can use let
01:47:18 <chu_> Awesome
01:47:24 <shachaf> chu_: Though it isn't a "variable", just a binding.
01:47:59 <voker57__> @hoogle a -> [a] -> ([a], [a])
01:47:59 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
01:48:00 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
01:48:00 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
01:48:53 <chu_> parse error on input let?
01:49:46 <chu_> i see
01:50:43 <shachaf> > runIdentity $ do { let x = 5; return x }
01:50:44 <lambdabot>   <no location info>: parse error on input `}'
01:50:47 <chu_> maybe not
01:51:13 <shachaf> > runIdentity $ do { let { x = 5 }; return x }
01:51:14 <lambdabot>   5
01:52:45 <chu_> thanks shachaf
01:53:44 <chu_> Should I really worry about working out all values before printing, or just print as I know the value? If that makes sense...
01:55:38 <shachaf> chu_: More context might make more sense. :-)
01:56:04 <Berengal> chu_: Not very. In the context of lazy evaluation, 'print' is likely to be (one of) the first functions your program calls. The rest of the program is mostly spent figuring out what exactly it is printing
01:57:34 <chu_> I have a few variables and I print them all out at the end, I could print out p (which requires a list comprehension and then the random grab from that list), before working out q (neither have any implications on the other), but normally I would work everything out then print the two values at the end. Just really wondering what's considered better practice in Haskell I guess
01:59:10 <Berengal> do {let x = foo; print x; let y = bar; print y} and do {let x = foo; let y = bar; print x; print y} will have very similar executions, if not identical
01:59:40 <chu_> yep, either way I'll get the same answer (I think), but is there a "prefered" form?
02:01:26 <chu_> Basically, I'm writing an implementation of RSA as I was taught (which is from a maths course), I just wanted to write Euler's gcd algorithm in haskell, but it was easier than I thought (I love recursion :)), so decided on writing the complete thing :p
02:02:19 <chu_> I have the bare bones, though no checking that the input values were in fact prime numbers...
02:02:25 <Gracenotes> not just the gcd algorithm, but the extended version...
02:02:35 <Gracenotes> if that's what you mean
02:02:43 <chu_> Yeah, haven't actually got to that point yet, but that will be fun too.
02:02:46 <Gracenotes> :)
02:03:29 <Gracenotes> plus some modular exponentiation (like, Russian peasant)
02:03:52 <Gracenotes> lots of number theory reached with just the RSA algorithm :D
02:03:55 <chu_> Yep :)
02:04:35 <chu_> It's a fun maths course (foundations of mathematics, we covered modular arithmetic and that's where RSA popped up)
02:05:04 <chu_> The follow-on course is called Cryptography and Number Theory ;)
02:06:12 <b_jonas> chu_: do you write a probabilistic composite test too, or just use one from a library (like gmp)?
02:06:46 <chu_> Well, I guess I will try writing my own, but probably give up :p
02:06:48 <b_jonas> just out of curiosity
02:06:53 <b_jonas> it's not hard
02:07:01 <Adamant_> chu_: just remember, full "real" versions of RSA have a lot of fiddly bits to protect against various attacks. but, implementing a casual version of RSA is fun, and good luck :)
02:07:05 <b_jonas> at least if you don't want it too efficent
02:07:17 <b_jonas> and I guess you don't
02:07:31 <b_jonas> Adamant_: sure, you need a block cipher to code the bulk of text fast
02:07:31 <chu_> Yeah, it's only for fun really
02:07:48 <Adamant_> chu_: hope you have fun! :)
02:08:14 <Adamant_> b_jonas: not even that. RSA is sensitive to a lot of potential attacks from implementation errors.
02:08:27 <b_jonas> Adamant_: sure
02:09:02 <b_jonas> Adamant_: you need a cryptographically secure random generator which is HARD,
02:09:12 <b_jonas> and lots of real world details mathematicians don't even think about
02:09:23 <Adamant_> b_jonas: you usually punt and use the OS's
02:09:35 <b_jonas> Adamant_: well sure, but someone has to implement that too
02:09:39 <Adamant_> right.
02:09:54 <b_jonas> chu_: if you have the Cormen book, it describes the Rabin-Miller test quite well
02:09:54 <Adamant_> b_jonas: I mean more like, if you don't pad RSA messages correctly
02:10:02 <Adamant_> you weaken the encryption
02:10:04 <chu_> Cormen book?!
02:10:12 <Adamant_> Intro to Algorithms
02:10:30 <Adamant_> good lighterweight TAOCP substitute
02:10:59 <outchanter> SICP has Rabin-Miller as an exercise IIRC
02:11:26 <chu_> Funnily enough, I actually do have the Cormen book :(
02:11:55 <chu_> I remember there were some MIT lectures on google video which taught directly from the text
02:14:28 <cayennext> I wanted to play with Parsec this weekend. I am on Ubuntu, installed ghc6-parsec-dev. But while compiling a simple program "import Parsec", it cannot find parsec library. I am running out of ideas. Could you help me?
02:14:41 <copumpkin> Text.Parsec?
02:14:48 <copumpkin> Text.ParserCombinators.Parsec ?
02:15:07 <cayennext> tahnk you very much
02:18:21 <bo0ts__> Good morning, if I define "addVectors a b = (fst a + fst b, snd a + snd b)" it type is "addVectors :: (Num a, Num b) => (a, b) -> (a, b) -> (a, b)". But isn't this the same as "addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)"? Is there any difference?
02:18:44 <bo0ts__> And more specifically: Why does the type inferer does it this way?
02:20:36 <outchanter> the first way would work on any pair of numeric types
02:21:05 <Berengal> bo0ts__: The numbers in the pairs don't have to be the same type. You could have a vector of (Int, Double) if you wanted
02:21:10 <monadic_kid> it's not the same, the compiler has inferred the most general types, as long as what ever subsitutes a and b are instances of the Num type classes you can add them
02:23:08 <bo0ts__> But (Num a) => (a, a) -> (a, a) -> (a, a) works on (Int, Double) Tuples as well.
02:23:21 <Berengal> No it doesn't
02:23:23 <bo0ts__> Or am I wrong? Let me check.
02:23:49 <copumpkin> the same type variable appearing in the type signature
02:23:50 <Berengal> Since there's only one type variable, only one type can be substituted for it
02:23:52 <copumpkin> implies that the types must be the same
02:24:06 <copumpkin> Berengal said it better
02:24:07 <copumpkin> :(
02:24:18 * Berengal flexes
02:24:19 * copumpkin cuts himself some more
02:24:32 * outchanter hands copumpkin some antiseptic
02:24:34 <copumpkin> I should probably go to sleep rather than wasting time on ghc primops that no one wants
02:24:46 <Berengal> I thought cohalloween was last month...
02:24:54 <bo0ts__> It does: addVectors (3, 3.2) (4, 4) -> (7.0,7.2)
02:25:10 <Berengal> bo0ts__: That's because all those literals are doubles
02:25:25 <monadic_kid> bo0ts__: (a, a) implies that the types of the tuple are the same, (Int, Double) have different types
02:25:52 <monadic_kid> bo0ts__: you can't subtitute (Int, Double) for (a, a)
02:26:03 <monadic_kid> bo0ts__: you can subtitute (Int, Double) for (a, b)
02:26:12 <copumpkin> :t 1
02:26:13 <chu_> b_jones - what if I had a function which returned a list of all factors of an input value, if the factors are just [1, n] it would be prime, and just composite anything that is not-prime?
02:26:14 <lambdabot> forall t. (Num t) => t
02:26:14 <copumpkin> :t 1.5
02:26:16 <lambdabot> forall t. (Fractional t) => t
02:26:20 <copumpkin> :t 1 :: Double
02:26:21 <lambdabot> Double
02:26:24 <copumpkin> :t 1.5 :: Int
02:26:26 <lambdabot>     No instance for (Fractional Int)
02:26:26 <lambdabot>       arising from the literal `1.5' at <interactive>:1:0-2
02:26:26 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
02:26:28 <copumpkin> :)
02:27:05 <Berengal> @type let x = 3; y = x / 1.5 in x
02:27:06 <lambdabot> forall t. (Num t) => t
02:27:21 <Berengal> Ah, no MR here
02:27:36 <copumpkin> you only get MR with f = g . h iirc ?
02:27:49 <copumpkin> if you know what I mean
02:27:49 <zachk> mr?
02:27:54 <copumpkin> monomorphism restriction
02:27:56 <Berengal> copumpkin: You get MR with all "foo = ..." declarations
02:28:36 <copumpkin> that seems even odder, if it isn't a function
02:28:47 <copumpkin> I can just barely see the justification for it if it's a function
02:29:03 <Berengal> copumpkin: Neither is f = g . h
02:29:10 <Berengal> If you squint a bit at least
02:29:14 <copumpkin> yeah, I guess
02:29:27 <copumpkin> meh :)
02:30:01 <Berengal> The result of functions has to be monomorphic. 3 is the result of 'fromInteger (3::Integer)', 3 has to be monomorphic
02:30:47 <Berengal> With -XNoMR it's the opposite: 3 is polymorphic
02:31:03 <Berengal> and so is x where x = 3
02:31:20 <Gracenotes> :>
02:31:52 <Berengal> Of course, I might be talking nonsense, but at least this is how I keep track of things, and it has proven to be consistent so far...
02:32:00 <copumpkin> wow Gracenotes
02:32:20 <copumpkin> go to sleep!
02:33:18 <Gracenotes> no u
02:34:22 <Gracenotes> does anyone else know, off the top of their head, the three mirth-related words beginning with "joc"?
02:34:42 <wli> jocular is one
02:34:43 <Gracenotes> is it a "thing"?
02:35:05 <copumpkin> jocund?
02:35:10 <Berengal> jocose?
02:35:11 <Gracenotes> yep
02:35:13 <Gracenotes> :)
02:35:23 <Gracenotes> I wonder if people group them, though
02:35:24 <copumpkin> jockstrap
02:35:25 <Berengal> W|A to the rescue!
02:35:26 <copumpkin> ;)
02:35:28 <Gracenotes> I do certainly
02:35:32 <Berengal> http://www75.wolframalpha.com/input/?i=joc___
02:35:32 <Gracenotes> Berengal: cheating!
02:35:43 <Gracenotes> copumpkin: lol
02:35:57 <copumpkin> definitely mirth :)
02:36:07 <Gracenotes> o_O
02:36:15 <Berengal> Hmm, jocoseness, jocosity
02:36:20 <Gracenotes> jocundity
02:36:26 <copumpkin> the mac os dictionary works just as well
02:36:28 <Gracenotes> real world
02:36:28 <copumpkin> as alpha
02:36:30 <Gracenotes> *word
02:39:08 <Gracenotes> ur jocundity is showin
02:58:04 * edwardk waves hello.
02:58:14 <copumpkin> omg an edwardk
02:58:18 <copumpkin> you're up late/early :o
03:01:03 <edwardk> late =)
03:01:09 <copumpkin> same here
03:01:58 <edwardk> been trying to get to sleep for 4-5 hours now, finally gave up and hopped on channel.
03:02:08 <copumpkin> aw
03:02:16 <copumpkin> pity no one's around
03:02:26 <copumpkin> I guess it'll put you to sleep more quickly
03:02:40 <edwardk> meh, made some progress on my parsers as a result of my being stuck awake
03:02:48 <Heffalump> morning
03:02:55 * Heffalump just had a nice lie-in
03:02:57 <copumpkin> hi :)
03:03:31 <edwardk> trying to get a cheap enough monoid for CFGs or PEGs that its a win to use the LZ78 stuff on something stronger than a regular expression
03:05:09 <edwardk> but right now the asymptotics on the algorithms i have for anything stronger seems to not pan out in favor of using the monoid, unless i do so with tricks, like resuming from the error productions you commonly see in production LALR grammars and relying on some meta properties about how they are placed
03:06:13 <wli> I don't entirely understand GLR but it has some interesting ideas kicking around.
03:06:45 <wli> Like the DAG instead of stack.
03:07:09 <mm_freak> say i have a thread, which runs some message loop (reading commands from a chan), what is the easiest way to signal this thread to exit?
03:07:47 <copumpkin> kill it with fire!
03:07:53 <copumpkin> or make a command that'll make it quit?
03:08:04 <copumpkin> (that you'd pass it through the chan)
03:08:12 <tetha> kill -9 will do so :)
03:09:22 <copumpkin> *sigh*, GHC builds take forever
03:09:32 <copumpkin> I need a THz computer
03:10:26 <tetha> we need the paralization man to make it go faster somehow
03:10:52 <copumpkin> if I had a THz computer, I wouldn't care too much about parallelization though
03:11:29 <tetha> neither about heating, I'd guess
03:11:35 <copumpkin> :)
03:11:59 <ivanm> tetha: sure you would
03:12:06 <ivanm> you'd worry about having too _much_ heating!
03:13:06 <p_l> ivanm: actually, he would worry about not freezing to death. The only cpus that reach 100GHz run in cryogenic conditions :D
03:13:24 <ivanm> heh
03:13:46 <ivanm> of course, we just need to think of a better type of computer architecture than x86...
03:13:46 <p_l> (superconductors)
03:14:11 * ivanm wonders what a haskell-oriented CPU would be like, just as how most CPUs these days are C-oriented
03:14:13 <tetha> don't go into quantum computers... I recently saw two examples of algorithms for them and I still am confused
03:14:35 <ivanm> lol
03:14:43 <ivanm> you're in good company then :p
03:14:58 * Botje took a quantum computing course this year
03:14:59 <p_l> ivanm: they are not so much C-oriented, I think. x86 is backward-compatibility oriented ;-)
03:15:04 <Botje> it's pretty cool :)
03:15:06 <kuribas> We need to compile to fpga's.
03:15:15 <Botje> ivanm: i suppose you saw the reduceron?
03:15:32 <ivanm> p_l: they're aimed at C-style programming (i.e. imperative)
03:15:37 <ivanm> Botje: don't think so...
03:15:38 * ivanm googles
03:15:48 <ivanm> wikis, rather
03:15:58 <ivanm> OK, I do have to google...
03:16:05 <copumpkin> hah
03:16:10 <copumpkin> Prelude GHC.Integer> factInteger 5#
03:16:10 <copumpkin> Bus error
03:16:19 <ivanm> lol
03:16:38 <copumpkin> I guess that one needs more work :P
03:17:13 <Peaker> ivanm: did you see the Reduceron?
03:17:17 <Botje> is factInteger :: Integer# -> Either Bus Integer# ? :)
03:17:24 <p_l> ivanm: well, you can try resurrecting one of those stackmachines :P
03:17:38 <ivanm> Peaker: why are you and Botje suddenly both interested in asking me the same question? :p
03:17:45 <copumpkin> Botje: unfortunately not :)
03:17:53 <copumpkin> Prelude GHC.Integer> modExpInteger (5^12) (123^123) (7^77)
03:17:53 <copumpkin> 87331940191622035906076347996440999531349066847140312619844183175
03:17:56 * p_l prefers RISCs which can be exploited in interesting ways by HLLs :P
03:17:58 <ivanm> :o
03:17:59 <copumpkin> that one still works, thankfully :)
03:18:28 <gio123> does somebody know latex editor supports utf-8?
03:18:45 <ivanm> gio123: emacs
03:18:52 <copumpkin> I use texshop or textmate
03:19:03 <Peaker> ivanm: ah, didn't see
03:19:09 <ivanm> Peaker: ;-)
03:19:14 * Saizan wonders how to write tests for a prettyprinter without a parser
03:19:24 <ivanm> the big red highlighting here makes it more obvious, I suppose :p
03:19:27 <b_jonas> Saizan: compare with fixed strings
03:19:38 <Saizan> b_jonas: i guess
03:19:51 <b_jonas> Saizan: like "[4, 2]" == show [4, 2]
03:20:11 <copumpkin> well, tomorrow we'll all be able to do our proejct euler problems a little bit faster with GHC head!
03:20:17 <copumpkin> but now I must sleep
03:20:26 <copumpkin> :P
03:20:28 <b_jonas> p_l: in fact it's the other way: C is x86 oriented
03:20:38 <Peaker> b_jonas: C predates x86?
03:20:43 <b_jonas> Peaker: I know
03:20:53 <ivanm> copumpkin: you? sleep?
03:20:55 <b_jonas> but they made the ieee floating point standard to mostly match 8087
03:20:58 <ivanm> you're joking, right? :p
03:21:04 <Peaker> C is Von Neumann oriented...
03:21:19 <b_jonas> and also most cpus have the wrong kind of divison which is why c89 allows it and c99 requires it now
03:21:26 <copumpkin> ivanm: I do sleep occasionally!
03:22:06 <p_l> b_jonas: C was made as structured assembler for PDP-11, which was very CISCy. So no wonder it meshes well with x86 :D
03:24:31 <Peaker> what's wrong about ieee division?
03:24:56 <b_jonas> (sorry, technical problem)
03:25:20 <Peaker> b_jonas: what's wrong about ieee division?
03:25:34 <b_jonas> Peaker: no, not that division
03:25:38 <b_jonas> Peaker: I'm talking about integer division
03:25:43 <p_l> brb - rebooting Windows Router
03:25:48 <b_jonas> Peaker: rounding the quotient towards zero instead of towards minus infinity
03:27:04 <Peaker> b_jonas: why is that wrong?
03:27:21 <Peaker> > (-1) `div` 2
03:27:22 <lambdabot>   -1
03:27:32 <Peaker> > (-1) `quot` 2
03:27:34 <lambdabot>   0
03:27:44 <Peaker> > (-1) `mod` 2
03:27:45 <lambdabot>   1
03:27:55 <Peaker> > (-1) `rem` 2
03:27:56 <lambdabot>   -1
03:28:08 <Peaker> b_jonas: ah, indeed divMod is much nicer to use
03:29:12 <b_jonas> Peaker: luckily some languages provide both in the library (like r6rs)
03:29:17 <b_jonas> or only the right one
03:30:24 <Peaker> b_jonas: well, that's not a major thing in C.. C has worse faults
03:30:45 <b_jonas> Peaker: sure, but p_l mentioned cpus
03:30:49 <Peaker> (its array degradation horror, its pointer syntax, its lack of parametrized types, ...)
03:31:05 <b_jonas> Peaker: there's a nice writeup about the history of C somewhere
03:33:08 <emmy> heyyy
03:33:26 <b_jonas> anyway, going back to read the Lem book now
03:33:37 <Botje> good morning, emmy
03:33:39 <MyCatVerbs> Peaker: lck of parametrized types is hardly a horror in a language whose *compilers* had to fit within roughly one megabyte!
03:34:21 <MyCatVerbs> That said, we're no longer in those days, so yeah. No real reason why we can't do better *now*.
03:34:24 <p_l> 1 megabyte? 32kb
03:34:29 <Peaker> MyCatVerbs: I didn't say it was a horror, just a fault :)
03:34:48 <Peaker> I think there's a low-hanging fruit here -- a C-like language with modern features
03:34:53 <emmy> any guy here
03:34:54 <Peaker> but nobody's taking it
03:35:09 <Peaker> C++ was supposed to handle it, but it did it all wrong :)
03:35:41 <Botje> emmy: if you have a question, just ask
03:35:50 <p_l> C++ was created with job security as a goal :P
03:36:29 <RayNbow> C++ is just an odd name... the name itself is full of evil side effects :p
03:36:38 <MyCatVerbs> Peaker: BitC?
03:36:56 <Peaker> MyCatVerbs: Lisp syntax :-(
03:37:12 <MyCatVerbs> Peaker: so?
03:37:24 <MyCatVerbs> Got any *relevant* problems with it?
03:38:25 <Peaker> MyCatVerbs: There are many developers who don't want to use a Lisp syntax (and I sympathize). I looked at BitC a while ago, and it does not seem like what I wanted, but I might be wrong
03:38:52 <Peaker> I want a strict, Haskell-like language, possibly with manual memory management (Still not sure if GC is really a problem in a systems programming language)
03:39:35 <wli> Peaker: I think it is because it's a bootstrapping question: it needs to be used to implement memory management).
03:40:05 <maltem> You can use ATS to pretend you were not programming in C
03:40:19 <Peaker> wli: Maybe it is possible to implement GC in a GC'd language, as long as you're careful not to cause allocation feedback loops..
03:41:17 <wli> Just because it's possible doesn't make it useful, desirable, un-awkward, etc.
03:41:56 <wli> The memory management subsystems of kernels, for instance, do a lot of strange things and get a lot of churn. That kind of interaction sounds nightmarish to someone who deals with that.
03:43:33 <wli> There are a lot of placement (esp. alignment) issues, for instance.
03:44:33 <wli> They're already pretty nasty just because of the demands going around without tripping over such a bootstrapping problem.
03:44:34 <yitz> yay! ghc compiles again on tiger. hope they apply the patch soon on macports.
03:51:42 <thomastc> is it evil to use Control.OldException
03:51:43 <thomastc> ?
03:51:58 <thomastc> I've got some code here that won't compile on ghc 6.10 because of changes in Control.Exception
03:52:26 <thomastc> and the insertion of the three characters "Old" is the simplest solution :)
03:52:37 <mauke> is it cabalized?
03:52:48 <thomastc> yes
03:53:04 <Saizan> add base < 4 to the build-depends then
03:54:30 <yitz> thomastc: i think it's not much harder than that to support the new exceptions though.
03:55:00 <yitz> usually
03:55:56 <skanev> hey guys
03:56:06 <thomastc> yitz: ok
03:56:07 <thomastc> doSafe :: IO a -> (String -> IO a) -> IO a
03:56:08 <thomastc> doSafe = catchJust (\ex -> Just $ show ex)
03:56:09 <skanev> Can someone tell me what is the difference between import and import qualify
03:56:12 <thomastc> this gives me an error
03:56:21 <skanev> or at least, point me to the proper documentation. I have hard time finding it :)
03:56:36 <yitz> @hoogle doSafe
03:56:36 <lambdabot> No results found
03:56:46 <yitz> @hoogle catchJust
03:56:46 <lambdabot> Control.Exception catchJust :: Exception -> Maybe b -> IO a -> b -> IO a -> IO a
03:56:48 <yitz> heh
03:57:05 <thomastc> hoogle still has the 6.8 definition?
03:57:22 <thomastc> :t catchJust
03:57:23 <lambdabot> Not in scope: `catchJust'
03:57:47 <thomastc> http://stackoverflow.com/questions/431527/ambiguous-type-variable-error-msg describes the same error I'm getting
03:57:56 <thomastc> albeit on a different function, but I doubt that it matters
03:58:30 <thomastc> skanev: http://en.wikibooks.org/wiki/Haskell/Modules#Qualified_imports
03:58:41 <thomastc> oh :(
04:00:00 <dancor_> Gilly: do you know if it's possible to use type-annotations for all functions when using Takusen?  it seems like you need certain things that are not exported (like Database.PostgreSQL.Enumerator.QueryStringTuned) to write out your type annotations
04:00:51 <yitz> thomastc: weird, there seem to be parens missing in that type
04:03:42 <thomastc> yitz: yes indeed... hoogle bug?
04:03:51 <thomastc> the web hoogle does it right
04:04:29 <thomastc> but either way, this is the old definition of catchJust... is there an easy way to make it work with the new one?
04:05:03 <igel> how important is it that 'show' produces valid haskell code?
04:07:01 <dancor_> > show const
04:07:02 <lambdabot>       Overlapping instances for Show (a -> b -> a)
04:07:02 <lambdabot>        arising from a use ...
04:07:09 <dancor_> > show (const :: Int -> Int)
04:07:10 <lambdabot>   Couldn't match expected type `Int' against inferred type `b -> Int'
04:07:38 <dancor_> anyway, i saw a "(String -> String)" the other day, which is def not valid code
04:08:23 <igel> well the thing is atm show produces valid haskell code, but it includes functions that are not exported by the module :)
04:08:38 <dancor_> but since there isn't really anything else you could do for a Show instance for (String -> String), i guess it's ok
04:08:41 <dancor_> ah
04:09:24 <dancor_> well show's often have "fromList" (unqualified) for things that are always imported qualified, right?
04:09:43 <igel> yep
04:09:46 <dancor_> i can offer you justifications but not advice ;)
04:09:53 <igel> :)
04:11:19 <Gilly> dancor_: had the same problem myself, i'd have needed Database.PostgreSQL.Enumerator.ColumnBuffer and Query. Worked without writing the annotation, though.
04:11:43 <Gilly> Maybe they should be exported for this purpose, *shrug*.
04:12:19 <igel> i'd rather remove the show instance than export this function
04:12:39 <yitz> thomastc: there are parens missing in the latest online docs also.
04:12:49 <yitz> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#5
04:13:02 <dancor_> ya.  i guess the current intent is that you just won't do annotations.  unfortunately then i can't figure out compiler errors.  maybe i'll hack takusen to export those things at least for me for now..
04:13:34 <sayyestolife_> hello
04:13:57 <dancor_> @faq Life?
04:13:57 <lambdabot> The answer is: Yes! Haskell can do that.
04:14:20 <thomastc> yitz: haddock bug, then?
04:14:27 <Heffalump> thomastc: yes
04:16:33 <sayyestolife_> So, I'm wondering what is a good way to implement a "game loop", at the moment I have a function that calls itself recursively (until game is over), and it doesn't feel very pretty
04:17:02 <igel> foo = do myloop; foo
04:17:07 <igel> you can also write
04:17:13 <igel> foo = forever myloop
04:17:19 <igel> that's pretty :)
04:17:40 <igel> :t forever
04:17:41 <dancor_> sayyestolife_: functional reactive programming is pretty but not really all figured out yet theoretically afaict
04:17:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
04:17:54 <sayyestolife_> okay, because I don't want to explode the stack
04:18:06 <sayyestolife_> dancor, okay
04:18:12 <igel> sayyestolife: the compiler will figure taht out
04:18:16 <dancor_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive
04:18:18 <igel> especially if you use "forever"
04:18:21 <dancor_> version 0.10.7 :/
04:18:25 <sayyestolife_> igel okay cool
04:20:51 <yitz> thomastc: dunno. anyway, I found it in the sources. It's:
04:21:00 <yitz> catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
04:22:16 <yitz> Control.Exception.Base
04:22:29 <yitz> so that's right for you, isn't it?
04:23:38 <thomastc> yitz: yes, that's the one I'm trying to use
04:23:52 <thomastc> but the function I pasted still uses the old def and gives an error on the new one
04:24:03 <thomastc> I'll just depend on base < 4 for now
04:26:13 <yitz> thomastc: maybe try doSafe = catchJust (Just . show . toException)
04:26:48 <yitz> thomastc: instead of doSafe = catchJust (Just . show) like you have now
04:29:15 <thomastc> :t fromException
04:29:16 <lambdabot> Not in scope: `fromException'
04:30:04 <thomastc> yitz: that gives me the same error, but on fromException instead of catchJust
04:32:30 <burp_> jo
04:32:34 <burp_> oops
04:51:23 <sayyestolife_> is any of the FRP-gui-libraries actually used commercially?
04:53:14 <Peaker> sayyestolife_: I think Anygma is using them
04:53:24 <Peaker> not sure if its truly gone into use yet
04:59:21 <dancor_> why isn't there an (instance (Monad m) => Applicative m)
05:00:16 <opqdonut> ?instances WrappedMonad
05:00:17 <lambdabot> Couldn't find class `WrappedMonad'. Try @instances-importing
05:00:20 <opqdonut> hmh
05:00:27 <mauke> dancor_: because then you couldn't have any other instances of Applicative
05:00:37 <opqdonut> ?instances-importing Control.Applicative WrappedMonad
05:00:39 <lambdabot> Couldn't find class `WrappedMonad'. Try @instances-importing
05:00:54 <dancor_> sounds like fixing the wrong problem?
05:00:59 <opqdonut> anyway, Monad m => Applicative (WrappedMonad m)
05:01:18 <Peaker> what's a Wrapped Monad?
05:01:30 <opqdonut> Peaker: it's just a newtype
05:01:40 <opqdonut> to make instances easier
05:01:45 <Peaker> dancor_: Haskell lacks this kind of relationship, it would create overlapping instances
05:01:47 <opqdonut> anyway, there is something wrong with the current typeclass system
05:02:05 <opqdonut> we need either chooseable instances or something completely different
05:02:18 <opqdonut> for these deep hierarchies we're seeing
05:02:28 <Peaker> I think overlapping instances should be proven/assumed equivalent
05:02:43 <Peaker> there's also the class aliases idea
05:02:47 <opqdonut> overlappinginstances is almost nice
05:03:05 <opqdonut> but you can't have both "instance Foo a => Bar a" and "instance Quux a => Bar a"
05:03:07 <McManiaC> @pl map (\_ -> ' ')
05:03:07 <lambdabot> map (const ' ')
05:04:12 <EvilTerran> opqdonut, what if there were a type that was an instance of both Foo and Quux?
05:04:30 <opqdonut> that is the question
05:05:44 <Peaker> opqdonut: you mean its logistically too difficult to get such remote instances to have identical semantics?
05:06:09 <Peaker> opqdonut: if they do have identical semantics, just choose one arbitrarily
05:06:17 <dancor_> i have imported a monad from a library and the monad has no applicative instance, and i want it to have the monadic one.  should i write the instance (in terms of the monad operators), or do something crazy with WrappedMonad (i can't determine what tho)
05:06:23 <opqdonut> Peaker: thus undecideableinstances
05:06:28 <opqdonut> but this is a slippery slope
05:06:54 <opqdonut> we need something more fundamental, something backed with solid type theory
05:07:00 <dancor_> sometimes things are applicatives in two ways.  i think it should be possible to do even that..
05:07:08 <opqdonut> yes, that's a related problem
05:07:11 <opqdonut> chooseable instances
05:07:33 <opqdonut> for example taking the contexts of instance decls into account while deducing might give enough power
05:07:46 <opqdonut> but IIRC there were some undecideability concerns there
05:08:14 <dancor_> it seems like you definitely have to specify which one to use
05:08:27 <opqdonut> indeed, but that can get cumbersome also
05:08:27 <Peaker> I think if there are two ways for (Maybe a) to be a Monoid, then it should really be two different types
05:08:30 <dancor_> a <*.2 b           :)
05:08:35 <Peaker> the way Maybe is a Monoid is part of the type Maybe
05:09:00 <opqdonut> Peaker: but you it would be nice for standard library functions to have just a Maybe version
05:09:07 <opqdonut> and not an OtherMaybe one also
05:09:08 <opqdonut> :t find
05:09:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
05:09:12 <Peaker> And if you want to force explicit instance choosing -- then have instances ONLY on newtypes, and not on data's
05:09:25 <dancor_> should there be a maybeable class
05:09:30 <opqdonut> dancor_: maybe
05:09:32 <dancor_> lol
05:09:43 <Peaker> opqdonut: you could have Maybe a, and RecursiveMonoidMaybe and LeftChoiceMonoidMaybe
05:09:56 <opqdonut> but the semantics of chaining maybes needs to be separated from the semantics of Maybe itself (this is a value or maybe not)
05:09:57 <Peaker> opqdonut: with shorter names, of course :)
05:10:14 <opqdonut> Peaker: yeah, that might work with some syntax sugar for dissecting the newtypes
05:10:34 <Peaker> opqdonut: if you disallow instances on data, and force people to use newtype to declare instances, you've effectively created an instance selection mechanism
05:11:12 <opqdonut> Peaker: of course instance selection is feasible technology-wise
05:11:19 <opqdonut> but it needs to be nice to use also
05:11:47 <twb> @pl \x -> x == 1 || x == 2
05:11:47 <lambdabot> liftM2 (||) (1 ==) (2 ==)
05:11:48 <Peaker> I think explicit instance naming will lead to non-global instances which are imported specifically/etc, and I think that's extra complexity that is not warrented
05:11:54 <twb> Ew.
05:12:05 <Peaker> twb: why? That's pretty
05:12:15 <twb> Not pretty enough
05:12:20 <Peaker> twb: you have an OR between the results of (1==) and (2==)
05:12:44 <mauke> :t (`elem` [1, 2])
05:12:45 <lambdabot> forall a. (Num a) => a -> Bool
05:12:50 <Peaker> liftA2 (||) (1==) (2==)
05:13:02 <Peaker> or that :)
05:13:49 <opqdonut> (||) <$> (1==) <*> (2==)
05:14:02 <twb> The actual code I was looking at is
05:14:06 <twb> @pl filter ("temp" `isPrefixOf`) dirfiles ++ filter ("tmp" `isPrefixOf`) dirfiles
05:14:06 <lambdabot> filter ("temp" `isPrefixOf`) dirfiles ++ filter ("tmp" `isPrefixOf`) dirfiles
05:14:27 <Vq^> flip elem [1,2]
05:14:28 <opqdonut> there's probably a neat version with <^ or something
05:14:53 <opqdonut> (1==) <^(||)^> (2==) or whatever the names of those operators were
05:15:58 <Japsu> d ^____^ b
05:16:09 <opqdonut> thanks for the input
05:16:11 <Japsu> no wait, you can't use _ in operators
05:16:20 <Japsu> d ^.^ b
05:16:57 * dancor_ considers a joint operator-obfuscation/ascii-art contest
05:18:15 <Vq^> the freedom to define operators in Haskell removes a lot of the fun in obfuscation
05:18:25 <Peaker> the "stack traces for ghc" paper by SPJ is ready for use in 6.10.3?
05:19:19 <MyCatVerbs> Vq^: it does rather expand the field, though.
05:19:31 <Peaker> @pl \dirfiles -> filter ("temp" `isPrefixOf`) dirfiles ++ filter ("tmp" `isPrefixOf`) dirfiles
05:19:31 <lambdabot> ap ((++) . filter ("temp" `isPrefixOf`)) (filter ("tmp" `isPrefixOf`))
05:21:01 <Peaker> @pl \isPrefixOf -> isPrefixOf "temp" <^(||)^> isPrefixOf "tmp"
05:21:01 <lambdabot> ap ((^>) . (<^ (||)) . ($ "temp")) ($ "tmp")
05:21:05 <Peaker> heh
05:22:07 <opqdonut> ..
05:22:30 <cognominal> I am refactoring some code and it does not compile anymore :  http://paste.factorcode.org/paste?id=696    The error is    parse error (possibly incorrect indentation)
05:22:34 <cognominal> any clue?
05:23:12 <opqdonut> cognominal: check spaces vs tabs
05:23:49 <mauke> cognominal: I randomly blame the first 'let'
05:23:52 <Peaker> cognominal: I think the let blah = blah $ \n ...      requires the stuff in the new line to be at least after the =, but I'm not sure
05:24:09 <opqdonut> wow, that let + case + where is horrible
05:24:16 <Peaker> or the "where" is not indented properly
05:24:19 <mauke> not after the =
05:24:30 <mauke> it has to be indented further than the start of the block
05:24:44 <Peaker> can "where" be on non-functions?
05:24:51 <opqdonut> yeah
05:24:54 <opqdonut> i'm wondering too
05:24:54 <Peaker> does each let get its own where?
05:25:37 <cognominal> what do you suggest?
05:25:56 <opqdonut> cognominal: defining all those helper functions with let too
05:26:01 <mauke> indent the let block more (by at least 3 spaces)
05:26:04 <cognominal> opqdonut,  yi does not insert tabs
05:26:08 <opqdonut> or even on the top level
05:26:27 <opqdonut> as they don't need to be under that closure
05:27:28 <Teja> good morning #haskell
05:28:04 <Wraithan> Howdy, figured I would setup vim to be more haskell friendly since I have been hacking in haskell a lot lately and was wondering if anyone had a recommended set, haskell vim comes up with tons of pages of plugins and I am just looking for some pointers to one or two of the better sets of plugins
05:28:27 <opqdonut> use emacs ;)
05:28:32 <Wraithan> s/haskell vim/googling haskell vim/
05:28:46 <Wraithan> opqdonut: bleh, not going to learn another operating system
05:30:54 <twb> bracket is basically UNWIND-PROTECT, right?
05:31:01 <mauke> yes
05:31:20 <Wild_Cat> speaking of editors and all that jazz, is there a web page for the GSoC project about better Haskell Eclipse integration?
05:31:38 <cognominal> still struggling with my function :(
05:32:20 <McManiaC> @pl \x -> (f x) * (g x)
05:32:21 <lambdabot> liftM2 (*) f g
05:32:37 <Beelsebob> :( f <^(*)^> g
05:33:43 <twb> I thought Eclipse was an IDE, not an editor.
05:33:59 <Beelsebob> it is
05:34:49 <McManiaC> show . length . show $ 5
05:34:56 <McManiaC> is there a "prettier" way?
05:35:12 <opqdonut> in terms of syntax, no
05:35:14 <McManiaC> k
05:35:17 <Wild_Cat> twb: it is an IDE (which includes an editor, if you wanna get technical). Hence the "and all that jazz" ;)
05:35:25 <Beelsebob> McManiaC: log base 10?
05:35:29 <opqdonut> if you want to know how many digits there are, use something else
05:35:30 <opqdonut> e.g. log
05:37:46 <McManiaC> hmmm how?
05:37:57 <Beelsebob> @hoogle log
05:37:58 <lambdabot> Prelude log :: Floating a => a -> a
05:37:58 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
05:37:58 <lambdabot> package logfloat
05:38:03 <opqdonut> > floor . logBase 10 . fromIntegral $ 3506
05:38:05 <lambdabot>   3
05:38:10 <opqdonut> > floor . logBase 10 . fromIntegral $ 1000
05:38:12 <lambdabot>   2
05:38:20 <opqdonut> gah, ceiling, not floor
05:38:41 <Beelsebob> > logBase 10 . fromIntegral 1000
05:38:42 <lambdabot>       No instance for (Num (a -> t))
05:38:43 <lambdabot>        arising from a use of `fromIntegr...
05:38:47 <Beelsebob> > logBase 10 . fromIntegral $ 1000
05:38:49 <lambdabot>   2.9999999999999996
05:38:52 <Beelsebob> floating point error
05:38:55 <Beelsebob> not wrong function
05:38:59 <opqdonut> ah
05:39:07 <opqdonut> yeah, floats are pretty ugly for that stuff
05:39:15 <opqdonut> repeated `div` by 10 might be better
05:39:25 <Beelsebob> probably
05:39:35 <Beelsebob> but probably as expensive as the show . length . show
05:39:44 <McManiaC> ehm
05:40:17 <opqdonut> but a bit nicer
05:40:32 <Beelsebob> not sure
05:40:37 <Beelsebob> show . length . show is pretty nice
05:40:40 <McManiaC> what would be the advantage against show . length . show?
05:43:00 <opqdonut> well the show of Integer probably just repeatedly divides by 10 and takes the remainder
05:43:33 <Beelsebob> opqdonut: believable, but it's a large chunk of code saved
05:43:56 <opqdonut> true
05:49:33 <EvilTerran> > logBase 10 . fromIntegral $ 1000 :: CReal
05:49:34 <lambdabot>   3.0
05:50:41 <Peaker> @src logBase
05:50:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:51:08 <EvilTerran> ?type logBase
05:51:09 <lambdabot> forall a. (Floating a) => a -> a -> a
05:51:09 <skanev_> @thomastc: Thanks
05:51:10 <lambdabot> Unknown command, try @list
05:51:27 <EvilTerran> it's a method of Floating, iirc
05:51:47 <thomastc> :t toException
05:51:48 <lambdabot> Not in scope: `toException'
05:51:51 <ivanm> @src Floating
05:51:52 <lambdabot> class  (Fractional a) => Floating a  where
05:51:52 <lambdabot>     pi                                                      :: a
05:51:52 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
05:51:52 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
05:51:52 <lambdabot>     (**), logBase                                           :: a -> a -> a
05:52:04 <Peaker> @src Double logBase
05:52:04 <lambdabot> Source not found. My pet ferret can type better than you!
05:52:08 <ivanm> yup, though I'd guess it has a default implementation
05:52:16 <ivanm> @src Float logBase
05:52:16 <lambdabot> Source not found. Wrong!  You cheating scum!
05:52:30 <EvilTerran> logBase b x = log x / log b -- ?
05:52:47 <ivanm> that's my guess
05:53:04 <Peaker> perhaps it loses more accuracy than alternate approaches
05:53:23 <EvilTerran> (and, by default, log x = logBase (exp 1) x, perhaps)
05:53:34 <b_jonas> how'd it lose accuracy? it has a division only, it's accurate
05:53:37 <EvilTerran> > logBase 10 100 -- if i've got the parameters of logBase the right way round
05:53:39 <lambdabot>   2.0
05:53:45 <b_jonas> only problem can be if it overflows or underflows
05:55:00 <Peaker> b_jonas: well, if it generates a larger number, then the mantissa may have less LSB's?  Also, generating two inaccurate doubles and dividing them -- is possibly less accurate than somehow bypassing the division? I'm semi guessing :)
05:55:25 <b_jonas> Peaker: it's two accurate doubles unless one of them overflows or underflows
05:55:42 <Peaker> b_jonas: if the log is an irrational number then surely they're inaccurate?
05:56:32 <b_jonas> yeah, but they're the best approximation for the log provided the input is accurate
05:56:37 <b_jonas> log is implemented precisely
05:56:54 <b_jonas> (on modern enough machines)
05:56:59 <b_jonas> it's just taken from libc
05:57:08 <Peaker> b_jonas: well, dividing two best approximations may result in a less accurate result than a best approximation, perhaps?
05:57:25 <Peaker> (because the inaccuracies might accumulate?  Just my intuition speaking here, though)
05:58:26 <Peaker> > log 1000 / log 10
05:58:27 <lambdabot>   2.9999999999999996
05:58:30 <b_jonas> Peaker: it's _division_, not addittion. division or multiplication does not lose accuracy
05:58:33 <Peaker> > logBase 10 1000
05:58:34 <lambdabot>   2.9999999999999996
05:58:48 <b_jonas> I'm not saying that logBase is necessarily best implemented that way
05:58:58 <Peaker> b_jonas: how come? Isn't the mantissa fixed/finite length?
05:59:03 <b_jonas> only that if it is implemented like that, then it is accurate unless there's an overflow or underflow
06:00:16 <Peaker> b_jones: so dividing a fully populated mantissa with another fully populated mantissa gives an accurate/correct fully populated mantissa?
06:00:41 <b_jonas> Peaker: yes, almost
06:00:49 <b_jonas> there is a bit of loss of course but very little
06:01:05 <Peaker> b_jonas: well, the fact log 1000 / log 10  is not 3 proves that logBase could be implemented more accurately than that?
06:01:41 <Peaker> well, very little inaccuracy is all you need to leak abstractions and break computations, sometimes.. e.g: Raise this inaccurate result to a big power
06:01:46 <b_jonas> oh and, by the way,
06:01:58 <b_jonas> there can't be an overflow or underflow there because log doesn't go that high
06:02:03 * wli would probably use Newton and/or binary search after an approximation derived from that.
06:02:24 <Alpounet> :)
06:02:47 <wli> Or maybe some strategy derived from that that gets upper and lower bounds, polished via binary search -bounded Newton.
06:03:29 <Peaker> b_jonas: well, as long as we agree that log division to implement logBase is slightly less accurate than alternate approaches
06:04:32 <b_jonas> Peaker: what? what alternate approaches is it less accurate from?
06:05:49 <Peaker> b_jonas: something less efficient that results in 3 when you use logBase 10 1000 ?
06:06:01 <b_jonas> I mean, you haven't suggested a real alternate approach yet
06:06:53 <Peaker> I could implement an integer-based log that worked on that example..
06:07:13 <Peaker> or you could use wli's approach
06:09:29 <MyCatVerbs> Peaker: wli's approach is to use log base division (or any other method that gets you close to a right answer) then iteratively get closer and closer approximations to the solution. That still won't necessarily get you exactly 3, depending on how many iterations you want to run it for, but it'll get you darn close.
06:10:20 <Peaker> MyCatVerbs: you can do a binary search on the whole mantissa
06:10:51 <Peaker> the whole range of doubles is at most 2^64 options long -- a binary search on that should take roughly 64 iterations?
06:13:18 <MyCatVerbs> Ooh, plan. Double's mantissa is 53 bits and Float's is 23.
06:14:50 <Peaker> you do need to search for the best exponent too
06:16:00 <MyCatVerbs> Not so much. Remember that you have fast approximations available to you.
06:18:54 <McManiaC> @pl foo x >> bar x
06:18:55 <lambdabot> foo x >> bar x
06:18:57 <McManiaC> ^^
06:19:36 <Peaker> MyCatVerbs: since the exponent size is pretty small, binary searching that too shouldn't add too much work
06:19:36 <mmorrow> @unpl liftM2 (>>) foo bar
06:19:37 <lambdabot> (foo >>= \ b -> bar >>= \ a -> return (b >> a))
06:19:45 <mmorrow> arr
06:19:47 <Peaker> @pl \x -> foo x >> bar x
06:19:48 <lambdabot> liftM2 (>>) foo bar
06:19:59 <McManiaC> ah :)
06:20:06 <mmorrow> @yarr
06:20:06 <lambdabot> Arrr!
06:20:10 <McManiaC> :D
06:20:27 <MyCatVerbs> Peaker: you're going to get within one bit of the right answer from even a crap approximation anyway!
06:20:57 <MyCatVerbs> Peaker: or do you know of logBase approximations that aren't accurate to within 2x in either direction?
06:22:16 <Peaker> MyCatVerbs: hmm.. logBase can't really get the exponent wrong, as the exponent, I suppose, should always be the smallest possible that doesn't lose MSB's
06:22:53 <Peaker> MyCatVerbs: in which case you just have to search around a very small range of the existing mantissa (far far closer than 2x, probably)
06:24:34 <MyCatVerbs> Hrmn. Linux's math.h manpages don't specify the errors.
06:25:01 <MyCatVerbs> Still. There are BSD-licensed math routines in the BSDs that do. IIRC log is quoted as something like 100 ULPs.
06:25:31 <mmorrow> i'd look here http://opengroup.org/onlinepubs/007908775/xsh/math.h.html
06:25:50 <mm_freak> i notice that the run* functions and their cousins (runState, runReader, evalStateT, etc.) are almost always flipped
06:28:23 <EvilTerran> mm_freak, yeah, they're defined that way round because that's what you get when you write "newtype State s a = State { runState :: s -> (a,s) }" or whatever
06:28:33 <EvilTerran> mm_freak, iirc, monadLib has them flipped as standard
06:28:49 <mm_freak> maybe i should have a look at that
06:28:54 <McManiaC> im trying to use something like "mapM putStrLn ["foo","bar"]", but i get "Couldn't match expected type `()' against inferred type `[()]'"
06:29:08 <mm_freak> McManiaC: use mapM_
06:29:23 <McManiaC> thx!
06:29:34 <mm_freak> mapM returns the results, while mapM_ returns ()
06:29:37 <maltem> Flipped as compared to ...?
06:29:50 <mm_freak> since putStrLn results in () two times, you get the list [(), ()] as result with mapM
06:29:51 <McManiaC> ok
06:29:52 <McManiaC> :)
06:30:19 <mm_freak> maltem: i very often write:  flip evalStateT someState $ do 
06:30:40 <mm_freak> or i use 'flip evalStateT someState' as a closure
06:30:47 <maltem> ah ok
06:31:20 <Twey> Is there a conventional difference between mapM_ and mapM'?
06:31:39 <Twey> I always thought they both just meant modified, but...
06:31:53 <maltem> _ often means "discard some result"
06:32:05 <maltem> ' often means "strict variant"
06:47:12 <McManiaC> how can i change only one field of a record?
06:47:32 <mauke> r{ field = x }
06:48:27 <Alpounet> > { field = 1 }
06:48:29 <lambdabot>   <no location info>: parse error on input `{'
06:48:38 <Peaker> I like writing Data.Accessors for a record
06:48:47 <Peaker> so I use the same name for a getter and a setter
06:50:27 <Heffalump> Peaker: yeah
06:50:33 * Heffalump should do that more consistently
06:50:44 <Peaker> Data.Accessor should be a Control.Category.Category though
06:51:00 <Peaker> instead of ^> and ^< it should use >>> and <<<
06:51:03 <Heffalump> really? Does anyone actually care about that?
06:51:09 <Heffalump> ah, for the nice names? :-)
06:51:23 <Peaker> and the nice properties that come with them
06:51:24 <Heffalump> yes, that'd be nice. Especially now that F# has similar looking composition operators.
06:52:02 <Peaker> also, there's probably some rich library of stuff on categories just waiting to happen and it could benefit from that, theoretically :)
06:52:20 <Heffalump> hmm.
06:52:33 <Heffalump> categories are so abstract I'm not convinced there's a rich library of stuff possible for them
06:52:33 <Peaker> Category also gives you id so you get a "self" accessor
06:52:55 <Heffalump> tricky though, overloading id is pretty weird
06:53:02 <Heffalump> leads to bad type errors when you get confused
06:53:35 <Peaker> so many things remind me I need to find time to work on a type-safety-preserving Haskell code editor :(
06:53:50 <Heffalump> you mean a refactoring tool?
06:54:10 <Peaker> I want to create a Haskell editor that edits the ASG directly, not a text representation of it - and also preserves type safety for all editing operations
06:54:27 <Heffalump> ah
06:54:29 <Peaker> Edits are allowed to change functionality, so its not a refactoring per-se
06:54:31 <Heffalump> that sounds hard
06:54:40 <Heffalump> how would part-written programs work?
06:55:06 <Heffalump> writing a usable structure editor in itself is hard
06:55:09 <Peaker> When you want an intermediate step that breaks types -- you get a missingConversion :: a -> b  = error "Forgot to replace this"   installed there by the editor to keep the types safe
06:55:35 <Peaker> all the missing conversions you have can be red and appear on an auto-TODO list on the side, like a compiler error list you can avoid repairing until you feel like it :)
06:55:58 <Peaker> maybe "type safe" is the wrong word, just "type check" it is :)
06:56:01 <EvilTerran> could require edits to be a refinement under the definedness ordering, and start with "undefined :: some type", then refining it stepwise down to an implementation
06:56:21 <pejo> Peaker, have you used the emacs Agda mode?
06:56:24 <Peaker> EvilTerran: what happens when you change the type of a called function?
06:56:27 <Peaker> pejo: nope
06:56:28 <Heffalump> that sounds inconvenient if you want to undo...
06:56:34 <Peaker> Heffalump: how come?
06:56:45 <Heffalump> Peaker: IM EvilTerran's suggestion
06:57:06 <Heffalump> undo would become invalid if you can only make your code more defined
06:57:15 <Heffalump> and once your code is fully defined, you could never change it
06:57:43 <RLa> is there standard function to check is string is substring of some other string?
06:57:56 <RLa> i can't find such function in Data.String
06:59:00 <RLa> how comes that such primitive function is not in standard library
06:59:15 <Saizan> see Data.List
06:59:17 <mauke> isInfixOf
06:59:41 <RLa> oh, found it
06:59:43 <RLa> thanks
06:59:57 <EvilTerran> Heffalump, i haven't thought it through, it was just a random idea
07:00:13 <Peaker> Heffalump: anyway, if the types consistently check, and the type-inference is "on the fly", then when types break and you get those auto-coercions, its pretty clear what the error means -- because inference won't go haywire and indicate an error someplace else
07:00:26 <Heffalump> not sure I see the point of the coercions then
07:00:39 <Heffalump> who decides where to put them?
07:00:42 <Peaker> Heffalump: the coercions allow you to the intermediate editing that breaks types shortly
07:00:51 <Peaker> Heffalump: the editor, whereever needs be to keep the types checking
07:00:53 <EvilTerran> Heffalump, and you would be able to replace something fully-defined with something else equally defined (think equational reasoning, Bird style)
07:02:10 <Peaker> Heffalump: for example, if you take a function Int -> Int, and change it to String -> Int -> Int,  then everyone calling it breaks -- so instead of "Breaking", they get an autoadapter :: (String -> Int -> Int) -> Int -> Int   installed on the call (and bookmarked for fixing) so the code keeps type-checking. Then when you get there, the error is much clearer than one you'd get if you'd compile it that way as text.. (This is the type it worked well with, an
07:02:10 <Peaker> d this is how it is now)
07:03:09 <Heffalump> interesting
07:03:21 <Heffalump> one problem is that there are things you can't fix up with a coercion
07:03:38 <Heffalump> missing type class instance is one example, but things can get subtler than that
07:03:40 <Peaker> Heffalump: the coercion is a->b -- it lets you coerce anything, of course its a runtime error
07:04:23 <Peaker> Heffalump: ah, I see what you mean
07:04:53 <Peaker> Heffalump: But if I change (Blah a => a) to just b  then, it can be coerced back for compatibility?
07:05:07 <Heffalump> I don't follow
07:06:06 <Saizan> > show undefined
07:06:07 <lambdabot>   "* Exception: Prelude.undefined
07:06:24 <Peaker> Heffalump: you mean if I had   a call to mappend on a String, and someone removed the String Monoid instance?
07:06:32 <Saizan> that's an ambiguous typeclass constraint without extended defaulting
07:06:58 <Peaker> @type undefined
07:06:59 <lambdabot> forall a. a
07:07:17 <Heffalump> Peaker: yes, for example
07:08:03 <Peaker> Heffalump: ah, I guess that can be considered a function deletion.. in which case you can probably convert the call to mappend_deleted of the right type instead of a coercion
07:08:38 * SamB wonders if he could configure his computer to boot straight into X and lock it with Xscreensaver, securely ...
07:08:41 <Saizan> what's the advantage over just annotating the source with the errors like eclipse does?
07:08:54 <SamB> Saizan: of what ?
07:08:58 <Peaker> Saizan: the types always check -- so the editor can help with completions/etc
07:09:03 * SamB likes the way slime does that ...
07:09:08 <Peaker> Saizan: the type inference can occur in the editor itself, too
07:09:30 <Saizan> the second part looks orthogonal to me
07:09:37 <SamB> Peaker: are you talking about some crazy structured editor ?
07:09:40 <SamB> or what ?
07:09:58 <Saizan> the first too, depending on how you do inference
07:10:03 <Peaker> Saizan: if the editor has no idea what the types of things are, because they don't even type-check, then it can do less inferencing, less completions, and less execution of the code as you edit it, I believe
07:10:36 <Peaker> Saizan: or if it has "partial knowledge" because types don't check - it might infer the wrong types everywhere (the usual thing that happens when you have a type error without top-level signatures)
07:10:42 <SamB> Peaker: type inference for completions sounds really hard ...
07:10:50 <Saizan> inserting coercions doesn't add knowledge about the types
07:11:03 <Peaker> SamB: completions based on actual types that were inferred with type-inference in the editor, as you edit
07:11:15 <Peaker> Saizan: it keeps existing knowledge in-tact, instead of re-inferring everything incorrectly
07:11:16 <walter_> Would you please give a irc paste URL ? Thanks
07:11:38 <Peaker> Saizan: also, it makes the error messages about broken things much more straightforward - because it utilizes knowledge about the change that occurred, rather than just looking at the new broken whole
07:11:40 <SamB> Peaker: what types would it be aware of when you were trying to enter the function ?
07:11:42 <mauke> http://hpaste.org/fastcgi/hpaste.fcgi/new
07:11:43 <Saizan> @paste
07:11:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:11:49 <SamB> the return type, maybe ...
07:11:55 <walter_> mauke, thank you
07:12:03 <SamB> not usually the argument types yet
07:12:45 <SamB> so how do you filter a set of functions on a "could eventually return" relation ?
07:12:51 <mmorrow> @type ($ ())
07:12:52 <Peaker> SamB: I am creating a new function?  it starts out as: "newFunc = fillThisField" and lets you replace fillThisField (which equals error "missing implementation"), and has type forall a. a
07:12:53 <lambdabot> forall b. (() -> b) -> b
07:12:59 <Peaker> SamB: when you add an argument it becomes a -> b
07:13:10 <Peaker> SamB: when you start using that argument it starts restricting the type based on unifications
07:13:16 <Peaker> SamB: and so on
07:13:40 <SamB> so you enter the args before going back to the function?
07:14:03 <Peaker> SamB: some UI gesture would "add an arg" to the function
07:14:04 <SamB> how do you make that easy?
07:14:06 * SamB gtg
07:14:20 <Peaker> SamB: either a keyboard key, or jumping to the function name and pressing "space" or some such
07:15:35 <mmorrow> Peaker: that'd be interesting if you came up with some super minimal example/proof-of-concept
07:15:58 <mmorrow> (dunno what such a thing would look like or whatever..)
07:16:02 <walter_> a little code, I can runghc to get correct result, but can not compile it with ghc. would you please give me some advice ? thanks
07:16:04 <walter_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5182#a5182
07:16:15 <Peaker> mmorrow: I am dying to work on this editor, but full-time job is consuming almost all of my mental energies... Last spurt of working on it, I got pretty far in creating a GUI toolkit for it (I think Gtk, Qt, etc are hopeless for creating a good code editor)
07:16:22 <Heffalump> walter_: use ghc --make
07:16:36 <Heffalump> or ghc -package tagsoup, but --make will figure that out for you
07:17:36 <walter_> Heffalump, great, I compiled it successfully. Thank you!
07:17:49 <mmorrow> Peaker: i mean though not a functioning program, but just some sort of mock-up or completely-fabricated screen-video of a hypothetical interaction
07:18:14 <mmorrow> because personally i have a hard time picturing how what you're talking about would work
07:18:22 <mmorrow> and i think that would make it clearer
07:18:23 <Peaker> mmorrow: ah, that's pretty difficult to create with any of the tools I know about
07:18:38 <mmorrow> Peaker: gimp? ;)
07:18:54 <Peaker> heh, imagery might be good enough, might be a good idea :)
07:19:04 <mmorrow> exactly! completely imaginary
07:19:12 <mmorrow> err, you said imagery..
07:19:14 <mmorrow> that too!
07:19:17 <Peaker> heh
07:20:03 <Saizan> or just the underlying type-inferrer that should support this
07:20:06 <Peaker> visually, I think it would be quite similar to Emacs/vim, at least as a first version -- serializing the ASG to an AST and then rendering it to screen with indentation.  The main noticeable difference would be much more useful key bindings that operate on the ASG rather than on the text letters
07:20:48 <Peaker> a key binding could show/hide type annotations and stuff like that -- which an image might not capture entirely
07:20:58 <Peaker> maybe a presentation could
07:51:21 * EvilTerran fights with LyX
07:52:10 * byorgey lends EvilTerran a +4 Wand of Typesetting
07:52:15 <_JFT_> dumb question but what is LyX?
07:52:25 <EvilTerran> I have a \textrm comment in a math box; i want to include a \vee in that comment. LyX appears to be refusing to let my typeset that regardless of what hoops i jump through.
07:52:27 <mauke> let me google that for you
07:52:35 <_JFT_> and how do you do the "emote" thing :P
07:52:45 <_JFT_> Doh!
07:52:48 <joga> /me <does something> :)
07:52:48 <byorgey> _JFT_: /me
07:52:50 <_JFT_> A TeX?
07:52:58 <mauke> also, it's called an "action"
07:53:05 <_JFT_> byorgey: Thank you!
07:53:24 * _JFT_ not fully awaken yet
07:53:25 <povman> @slap povman
07:53:26 * lambdabot pushes povman from his chair
07:53:30 <byorgey> EvilTerran: just putting it in $ $  doesn't work?
07:53:32 <povman> ow
07:53:42 <EvilTerran> byorgey, LyX seems to be taking the $s literally
07:53:53 <byorgey> EvilTerran: the other thing you might try is using \text instead of \textrm
07:53:58 <byorgey> you may have to import amsmath or something
07:54:16 <byorgey> \text is much better for text inside of math stuff, and lets you arbitrarily nest  $ $  and \text
07:54:30 * EvilTerran really doesn't like tex
07:55:41 <pejo> JFT, it's a visual editor for (la)tex.
07:56:06 <povman> who here uses HSSDL
07:56:15 <_JFT_> pelo: thanks
07:58:05 * EvilTerran notes that LyX's "insert math" button seems to be using \mbox, not $...$
07:58:24 <byorgey> mbox isn't for math.
07:58:32 <EvilTerran> well, don't blame me.
07:58:39 <byorgey> it's just... a box.  I don't know what the m stands for.
07:58:40 <EvilTerran> i click "insert math", it inserts an mbox.
07:58:46 <byorgey> bizarre.
07:58:48 <mauke> mathbox!
07:58:56 <EvilTerran> it doesn't seem to like nesting math in text in math
07:59:11 <byorgey> EvilTerran: the moral of the story is: don't use LyX.
07:59:31 <EvilTerran> byorgey, yeah, i think i might just go back to plaintext
07:59:51 <EvilTerran> i've already wasted about an hour i really didn't have spare mucking around with this
08:00:00 <byorgey> yes, that's what I would suggest
08:00:47 <byorgey> using LyX or other "WYSIWYG" editors to edit LaTeX is like trying to paint a picture in the dark
08:01:49 <EvilTerran> LyX claims to go for WYSIWY(mean) rather than WYSIWYG, but what *I* see is an unintuitive interface and inscruitable error messages.
08:02:28 <tetha> I always thought the good thing about latex is: you can just type and some program creates something nice to read, and thus never understood why things like Lyx exist
08:03:52 <EvilTerran> tetha, i've never found that i "can just type and some program creates something nice to read"
08:04:10 <EvilTerran> it always tends to turn into "just type and some program creates an incomprehensible error message"
08:04:39 <tetha> yes, it teaches you to work in very small iterations
08:04:43 <tetha> :)
08:04:58 <b_jonas> EvilTerran: but you're a programmer, so "just type and some program creates an incomprehensible error message" should be a perfectly usual experience
08:05:41 <b_jonas> you know how to handle that and fix your program
08:06:22 <Wraithan> Try the MS STL... you haven't seen incomprehensible until you mess up something using that
08:06:28 <Wraithan> (C++ that is)
08:07:20 * EvilTerran feels that TeX really needs to be replaced by something more appropriate to the current state of computing, but is yet to find such a thing
08:07:51 * mux has wondered about open-source implementations of XSL-FO
08:08:01 <EvilTerran> get rid of this multiple passes nonsense, use a nice formal syntax, etcetc
08:08:02 <Twey> EvilTerran: That would be Microsoft Word.  I disagree.
08:08:03 <tetha> well tex is in the curios situation that tex kind of sucks, but all alternatives I have seen so far suck even more
08:08:15 <EvilTerran> Twey, i mean a typesetting language, not a word processor.
08:08:31 <EvilTerran> so congrats on disagreeing with something i didn't mean.
08:08:33 <mux> I only know of commercial implementations of XSL-FO
08:08:33 <Twey> Typesetting languages are, alas, not appropriate to the current state of computing
08:08:58 <EvilTerran> if you say so
08:09:06 <Twey> Look around
08:09:12 <Twey> The current state of computing is Windows
08:09:14 <Wraithan> I've never used one myself... *shrug*
08:09:22 <Twey> It involves lots of pointing and clicking
08:09:27 <Twey> We're the outsiders :-P
08:09:34 <mux> that's simply not true
08:09:37 <EvilTerran> Twey, lots of people still use programming languages.
08:09:49 <Twey> A minority
08:09:53 <Wraithan> not the majority by a long shot though
08:10:04 <Twey> And of that minority, most of them probably use VB
08:10:04 <maltem> Twey, TeX sucks from a language (processing) point of view
08:10:25 <mux> when we're speaking typesetting language, we're clearly not talking about the lambda computer user to begin with
08:10:25 <Twey> maltem: I don't disagree
08:10:54 <Twey> Indeed
08:11:28 <b_jonas> lambda computer?
08:11:48 <mux> pun intended
08:12:49 <b_jonas> is that like a pointer machine based architecture with the machine code being structured, instead of one of the current ones that work with numbers and the machine code based on sequentially ran instructions encoded to numbers?
08:13:04 <walter_> Can Haskell deal with Big5 or GB2312?
08:13:17 <mux> b_jonas: in that context, lambda computer user == usual computer usuer
08:13:33 <sbahra> muxxxxxxxxx
08:13:40 <mux> oh hey sbahra
08:13:43 <sbahra> :]
08:13:53 <b_jonas> @faq Can Haskell deal with Big5 or GB2312?
08:13:53 <lambdabot> The answer is: Yes! Haskell can do that.
08:14:23 <b_jonas> walter_: deal in what way? what operations would you want to do on such data?
08:14:24 <walter_> great, where can find the document
08:14:33 <mux> walter_: I don't know if there are native implementations for those encodings, but you could still use the bindings to libiconv
08:15:01 <mux> those are chinese encodings right?
08:15:06 <walter_> yeah
08:15:33 <walter_> just download some page and write to a database
08:15:48 <b_jonas> just treat them as opaque byte strings then
08:16:00 * mux nods
08:16:03 <walter_> I think libiconv is a good idea
08:16:05 <b_jonas> or reencode them
08:16:20 <mux> you don't even need libiconv if you don't need to "understand" those encodings
08:16:28 <b_jonas> I'd recommend that encoding module because it seems nicely done,
08:16:28 <mux> as b_jonas said
08:16:37 <walter_> well, something I got is like \123\123\233\
08:16:50 <mux> walter_: but you're using String's, right?
08:16:52 <b_jonas> only I've no idea what the new versino has because I couldn't build the haddock documentation
08:17:01 <walter_> mux, yeah
08:17:03 <mux> walter_: try with ByteString
08:17:15 <b_jonas> mux: isn't that sort of irrelevatn?
08:17:15 <mux> it'll be faster anyhow
08:17:27 <b_jonas> sure but
08:17:39 <walter_> good, will try
08:17:41 <mux> b_jonas: I don't think so; String's have a builtin encoding
08:17:58 <mux> which causes the printing of those escape sequences if I'm not mistaken
08:18:11 <mux> whereas the ByteString module treats strings just as sequence of bytes
08:18:19 <b_jonas> mux: Strings is how you use them
08:18:28 <b_jonas> you can use them as a list of utf characters
08:18:32 <b_jonas> decoding bytes to it
08:18:35 <mux> but I guess he prints them on a handle at some point :-)
08:18:35 <b_jonas> but that's not the only way
08:18:46 <Wraithan> Any recommended scripts for vim for haskell ?
08:18:55 <mux> so using ByteString's would be much more convenient
08:18:58 <maltem> The input/output functions on Strings truncate badly (except in some new version of the libraries, I think)
08:19:00 <b_jonas> in fact the ghc Prelude does not use them that way
08:19:09 <mux> maltem: http://projects.haskell.org/haskellmode-vim/
08:19:20 <b_jonas> a String can mean anything, just like a number can mean anything
08:19:25 <mux> woops
08:19:27 <mux> Wraithan: http://projects.haskell.org/haskellmode-vim/
08:19:41 <mux> b_jonas: but they have some intrinsic meaning when you print them
08:19:55 <mux> (going in circles here)
08:20:08 <b_jonas> mux: it can be a sequence of bytes
08:20:25 <b_jonas> mux: if you're reading and writing the same encoding, and not processing much, there's no need to know its meaning
08:20:33 <b_jonas> you better just read it as a sequence of bytes
08:20:34 <mux> b_jonas: tell me how you hPutStr a String as a sequence of bytes then
08:20:40 <b_jonas> (whether in a String or bytestring)
08:20:49 <mux> it just doesn't work that way as far as I know
08:20:50 <maltem> b_jonas, Char /= Byte
08:21:05 <mux> yes, Char is a UTF-8 Char
08:21:09 <maltem> no
08:21:11 <mauke> mux: wrong
08:21:12 <mux> not to be confused with Char8 that is use in ByteString
08:21:14 <maltem> a Unicode code point
08:21:17 <mux> sorry
08:21:32 <mux> utf-8 is an encoding, unicode is a standard, etc, I'll punish myself for that shortcut
08:21:41 <Wraithan> Seems to be a arch package for that, looks like I will give it a go
08:21:56 <b_jonas> oh I'm tired of this sorry
08:21:58 <mux> in any case, using ByteString for opaque sequence of bytes still is the way to go
08:22:30 <maltem> it is.
08:22:59 <mux> not sure why b_jonas got so worked up over this :-P
08:23:38 <MyCatVerbs> Okay, kids.
08:24:03 <Badger> Okay, Cats.
08:24:11 <MyCatVerbs> mux: hPutStrLn in System.IO currently treats Chars as if they were bytes. That is how b_jonas can treat them as such.
08:24:40 <MyCatVerbs> That might change in future, but isn't likely to because it's likely to break existing apps that use it as if it did.
08:25:10 <mux> wow, that's broken
08:25:37 <maltem> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016558.html
08:25:46 <maltem> (about encoding-aware handles)
08:26:26 <MyCatVerbs> mux: perhaps. If you want things to work differently, use a library like System.IO.UTF8.
08:26:47 <MyCatVerbs> Or wait for one of the Simons to make Handles encoding-aware.
08:27:16 <mux> I don't, this wasn't my concern, but walter_'s
08:27:29 <walter_> :)
08:29:12 <walter_> infact I think I can write a function to convert that all to utf-8, then system.io.utf8 can deal with it.
08:29:38 <mux> walter_: you might also be interested in the compactstring package
08:30:00 <MyCatVerbs> walter_: System.IO.UTF8 is for using UTF8 with Strings specifically. You'd most likely get better performance using ByteString IO.
08:30:38 <MyCatVerbs> walter_: 'specially since, IIRC, all the libiconv bindings use ByteStrings.
08:30:55 <walter_> MycatVerbs, yeah, I think so.
08:31:16 <mux> walter_: and CompactString are just encoding-aware ByteString
08:31:49 <walter_> mux, I see. your advice on ByteString is quite good. Will try
08:32:21 <walter_> thanks you all!
08:32:26 <mmorrow> , (text . utf8enc) "\x2200"
08:32:28 <lunabot>  
08:32:40 <mmorrow> , utf8dec ""
08:32:42 <lunabot>  "\NUL"
08:32:45 <mmorrow> heh
08:32:50 <mmorrow> , utfenc ""
08:32:52 <lunabot>  luna: Not in scope: `utfenc'
08:33:03 <mmorrow> , utf8enc ""
08:33:04 <lunabot>  "\226\136\128"
08:33:12 <mmorrow> , utf8dec "\226\136\128"
08:33:14 <lunabot>  "\8704"
08:33:21 <mmorrow> , ""
08:33:22 <lunabot>  "\8704"
08:33:44 <mmorrow> all you have to do is encode, then you can use regular IO..
08:34:04 <mmorrow> (and decode on the way in)
08:34:08 <trofi> , text "hello"
08:34:09 <lunabot>  hello
08:34:15 <mmorrow> , 'text
08:34:16 <lunabot>  Text.PrettyPrint.HughesPJ.text
08:34:22 <trofi> , text "hello\nworld"
08:34:24 <lunabot>  hello
08:34:24 <lunabot>  world
08:35:12 <mmorrow> , let ntimes n = foldr (.) id . replicate n in ntimes 8 (braces . parens . brackets) (int 42)
08:35:14 <lunabot>  {([{([{([{([{([{([{([{([42])}])}])}])}])}])}])}])}
08:38:18 <EvilTerran> > (fmap (!!) . iterate) f x 10 :: Expr
08:38:19 <lambdabot>   f (f (f (f (f (f (f (f (f (f x)))))))))
08:39:40 * EvilTerran would write that as "result (result (!!)) iterate" if "result = (.)" were in scope
08:41:03 <paper_cc> is there a pretty name for (flip (.))?
08:41:15 <mauke> >>>
08:41:29 <paper_cc> @ty (>>>)
08:41:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
08:41:39 <EvilTerran> in the same context as result = (.), i've seen argument = flip (.)
08:41:41 <mmorrow> , let ntimes n = foldr (.) id . replicate n in ntimes 6 ((h::Expr->Expr) . (g::Expr->Expr) . f) x :: Expr
08:41:44 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f x)))))))))))))))))
08:41:47 <skorpan> maybe someone should create a database with things like that, which would be integrated in lambdabot?
08:41:52 <paper_cc> mauke: thanks =)
08:42:06 <EvilTerran> > let argument = flip (.) in argument (+1) f $ x :: Expr
08:42:07 <mmorrow> , fix ((h::Expr->Expr) . (g::Expr->Expr) . f)
08:42:07 <lambdabot>   f (x + 1)
08:42:09 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
08:42:34 <paper_cc> someone should teach Hoogle that b -> c is a special case of (Arrow a) => a b c
08:43:00 <paper_cc> (if that's possible, it'd be very nice)
08:43:05 <Peaker> what replaces old-locale for System.Locale?
08:43:05 <EvilTerran> paper_cc, and of Functor f => f c
08:44:10 <EvilTerran> (or indeed Monad m => m c, so Applicative and Functor as well)
08:44:38 * paper_cc still wonders why there's no (Monad m) => Functor m where fmap = liftM
08:44:52 <Heffalump> paper_cc: because it would overlap
08:45:11 <mmorrow> , fix (inn . Just)
08:45:14 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
08:45:20 <paper_cc> Heffalump: are there true cases when they don't match?
08:45:25 <paper_cc> s/true//
08:45:33 <sclv> its also backwards. functor is simpler than monad.
08:45:36 <Heffalump> I mean that it would overlap in the sense of overlapping instances.
08:45:52 <Heffalump> i.e. it would require GHC extensions that cause their own problems
08:45:57 <sclv> if things were set up in a proper hierarchy, liftM would be defined in terms of fmap.
08:45:59 <jmcarthur> paper_cc: what you really want is class Functor m => Monad m, not instance Monad m => Functor m
08:46:23 <jmcarthur> or, rather, class Applicative m => Monad m
08:46:40 <Peaker> sclv: liftM* would not need to exist?
08:46:42 <paper_cc> jmcarthur: yes, but it would break a lot of things
08:46:49 <mux> does anyone know where I can find the code source of the hackage script that builds documentation?
08:46:56 <jmcarthur> paper_cc: so would instance Monad m => Functor m
08:46:59 <sclv> Peaker: well, liftM2 requires `ap` as well.
08:47:00 <mmorrow> mux
08:47:06 <sbahra> mmorrow
08:47:07 <mmorrow> mux: probably in the hackage-server
08:47:11 <Peaker> sclv: liftM2 = liftA2 anyway
08:47:13 <mmorrow> sbahra!
08:47:16 <sbahra> :]
08:47:23 <mmorrow> ::)
08:47:31 <mux> mmorrow: thank you
08:47:35 <mmorrow> mux: it's on code.haskell.org/hackage-server iirc
08:47:42 <mux> yeah, google helped me to it
08:47:55 <mmorrow> google is pretty handay
08:49:52 <Peaker> hmm I reinstalled cabal-install and its attempting to open a filename "\34"
08:50:06 <mmorrow> heh
08:50:13 <mmorrow> , "\34"
08:50:14 <lunabot>  "\""
08:50:30 <EvilTerran> "!
08:50:35 <Peaker> strace's \34
08:50:37 <Peaker> I think its octal
08:50:47 <Peaker> > chr (8*3+4)
08:50:48 <lambdabot>   '\FS'
08:50:55 <mmorrow> hmm
08:51:33 <Peaker> arg. I copied the .cabal file of cabal-install cause I wanted an executable and accidentally had it overwrite cabal exec - so I reinstalled it, and it broke it :(
08:51:49 <dcoutts> doh!
08:51:49 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
08:52:16 <Peaker> dcoutts: any idea why cabal-install is attempting to open a weird character as a file?
08:52:20 <mux> mmorrow: unfortunately the build scripts don't seem to be in hackage-server
08:52:28 <dcoutts> Peaker: nope, details?
08:52:29 <Peaker> dcoutts: for any command, "cabal update", "cabal install ..", etc
08:52:30 <burp_> anyone knows of haskell gsl bindings except of hmatrix?
08:53:00 <mmorrow> mux: aww
08:53:01 <Peaker> dcoutts: I just re-ran 0.6.2's bootstrap script, it rebuilt cabal and installed it, and now this happens
08:53:14 <paper_cc> cat "~/.cabal/config" == ?
08:54:01 <mmorrow> mux: i just remembered about this: http://darcs.haskell.org/hackage-scripts/
08:54:10 <Peaker> paper_cc: a big file
08:54:15 <mux> mmorrow: I've been looking there too already :)
08:54:23 <mmorrow> grr
08:54:31 <mux> I should have said so, sorry
08:54:44 <mmorrow> mux: what are you looking for in particular?
08:55:03 <Peaker> paper_cc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5183#a5183
08:55:07 <mmorrow> i use this haddock cmd and it works pretty nicely:
08:55:09 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
08:55:35 <mux> mmorrow: I want to see for sure how hackage generates haddock documentation, because some of the functions of my module will be unavailable on some platforms, and yet I'd like the docs for them to be generated
08:55:37 <mmorrow> i wish i knew how to make the raw haddock command do that though
08:55:58 <mmorrow> mux: hmm, probably ask dcoutts
08:56:13 <paper_cc> Peaker: that's the default configuration =(
08:56:15 <mux> I was pondering defining those functions to error calls, but this is only if I cannot find something better
08:56:30 <mux> dcoutts: any idea about that haddock documentation generation problem?
08:56:33 <Peaker> paper_cc: yeah, something's screwed up
08:56:41 <dcoutts> paper_cc: my first suspicion would be that the thing got built wrong
08:57:49 <dcoutts> mux: the code used by the doc build client is not available afaik, what is the problem exactly?
08:57:58 * paper_cc came up with a non-functional cabal-install twice but couldn't understand the problem
08:58:10 <mux> dcoutts: I want to see for sure how hackage generates haddock documentation, because some of the functions of my module will be unavailable on some platforms, and yet I'd like the docs for them to be generated
08:58:44 <dcoutts> mux: it'll just be doing something like runghc Setup haddock. The client is linux I think.
08:58:47 <mux> ideally I'd get a nice __HADDOCK__ CPP macro defined, and at worse I gues I could define those functions to error calls in that case
08:59:02 <mux> dcoutts: ok, thanks.  any suggestions?
08:59:31 <Peaker> dcoutts: what could make it build wrong?
08:59:44 <dcoutts> mux: with haddock2 there's no way for your code to tell if it's being inspected by ghc vs by haddock
09:00:01 <dcoutts> mux: unless you change the haddock hook
09:00:27 <dcoutts> Peaker: messed up dependent packages
09:00:36 <Peaker> dcoutts: :(
09:00:37 <mux> mm, you mean I could costuomize my Setup.hs, so that the haddock hook ends up defining a CPP macro ?
09:00:39 <dcoutts> Peaker: cosmic rays, evil curses etc
09:00:54 <mux> if so, I guess that would be the cleanest way
09:00:56 <Peaker> Now I'm gonna have to scrap everything and reinstall, probably
09:01:14 <dcoutts> mux: probably, but it may be extremely ugly to do it
09:01:23 <mux> heh
09:01:28 <mux> dcoutts: ok, thanks again
09:01:32 <dcoutts> np
09:04:14 <mux> I think I'll go the easy way and define the functions to error "not available on this platform" when they don't exist :-P
09:15:37 <Peaker> so what replaces old-locale?
09:15:44 <EvilTerran> ... locale?
09:15:47 <Peaker> @hoogle defaultLocale
09:15:47 <lambdabot> No results found
09:16:02 <Peaker> @hoogle locale
09:16:02 <lambdabot> package old-locale
09:16:02 <lambdabot> package setlocale
09:16:11 <Peaker> no locale.. is it set-locale?
09:16:37 <zakwilson> I'm trying to get some code to use multiple cores. Anybody care to inspect a trivial example?
09:16:37 <Saizan> i think it's all in "time" now
09:16:41 <mux> I dont think there's a new locale package yet
09:16:47 <mux> Saizan: time depends on old-locale
09:17:03 <EvilTerran> zakwilson, sure, hpaste.org it if it's more than a line or two
09:17:08 <zakwilson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5184#a5184
09:18:41 <EvilTerran> zakwilson, what's the trouble?
09:18:52 <zakwilson> It only uses one core. This machine has four.
09:19:17 <EvilTerran> huh. it *looks* right to me
09:19:56 <zakwilson> I had the same problem on a dual-core Linux machine, so it's pretty clear to me that I'm doing something wrong.
09:20:09 <zakwilson> (Linux machine currently unavailable to test due to hardware failure)
09:20:24 <EvilTerran> i'm guessing something to do with ghc or RTS flags
09:20:48 <jmcarthur> zakwilson: how far are you letting it run? do you let it print out a few before giving up?
09:20:56 <zakwilson> Everything I've found online suggests that this is exactly right.
09:21:03 <jmcarthur> zakwilson: that is, how long does it take to calculate each value?
09:21:09 <zakwilson> I haven't let it print any. I could try with smaller values.
09:21:14 <zakwilson> I don't know. A long time.
09:21:58 <jmcarthur> zakwilson: try shorter computations and maybe a list that isn't infinite
09:22:00 <EvilTerran> zakwilson, have you tried a simpler example, say, "parAvg xs = let s = sum xs; l = genericLength xs in s `par` l `par` (s/l)"?
09:22:15 <paper_cc> zakwilson: what if you change replicate 100 200 to [1..100]? (that is, different input values)
09:22:16 <jmcarthur> i don't know how strategies treat infinite lists
09:22:54 <zakwilson> I changed it to (replicate 100 40) and got results printed after a few seconds. Still only used one core. All results printed at once.
09:22:58 <EvilTerran> just to see if it's compiling & running right, to narrow it down to either your flags or your code
09:23:05 <paper_cc> zakwilson: several threads may detect that they're computing just the same values
09:23:18 <jmcarthur> i'm doubtful about that one
09:23:28 * EvilTerran thinks paper_cc may actually have a point
09:23:35 <jmcarthur> err, oh i see
09:23:40 <jmcarthur> i interpreted the sentence wrong
09:23:40 <EvilTerran> , vacuum (replicate 100 200)
09:23:42 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[1,6]),(6,[1,7]),(7,[1...
09:23:52 <zakwilson> Just tested with a range. paper_cc seems to be correct.
09:24:07 <paper_cc> EvilTerran: how does one decrypt this?
09:24:12 <EvilTerran> every spine cell of that list points to the same number cell
09:24:22 <zakwilson> It's now using 370% CPU.
09:24:30 <EvilTerran> paper_cc, as a directed graph, (nodeId, successorNodes)
09:24:59 <EvilTerran> (0,[1,2]) is the outermost (:), (1,[]) is the number cell, (2,[1,3]) is the next (:), ...
09:25:10 <EvilTerran> , vacuum (repeat 100)
09:25:12 <lunabot>  [(0,[1,0]),(1,[])]
09:25:28 <EvilTerran> [(:) cell, 100 cell]
09:25:57 <paper_cc> EvilTerran: thanks
09:26:40 * paper_cc reads Haddock for GHC.Vacuum
09:27:47 <paper_cc> , vacuum (repeat 100) ! 0
09:27:49 <lunabot>  luna: Couldn't match expected type `a i e'
09:28:04 <paper_cc> :t (!)
09:28:05 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:28:21 <paper_cc> , lookup 0 $ vacuum (repeat 100)
09:28:23 <lunabot>  Just [1,0]
09:28:40 <EvilTerran> i guess the application of "fib" is getting fused with the "replicate", so the results are all stored in the same cell too. or something.
09:33:32 <hackagebot> bsd-sysctl 1.0.2
09:34:17 <duaneb> hi haskellians
09:34:30 <duaneb> what libs do I need to pass to LD to get it to link?
09:34:52 <duaneb> (Note: I'm not actually trying to use ld, but I do want to know this)
09:36:54 <Peaker> @hoogle makeRegex
09:36:54 <lambdabot> No results found
09:38:08 * mux pets hackagebot 
09:49:44 <duaneb> so yea
09:49:57 <duaneb> if anyone could tell me what libs ghc links into executables...
09:50:21 <Igloo> If you run it with -v you'll see the linker invocation
09:51:18 <dmwit> You could also use ldd on an already-built executable to see what libraries it's linked to.
09:52:16 <cdsmithus> Is anyone able to actually install reactive?  I'm having no luck so far.
09:53:00 <duaneb> Igloo: thanks much!
09:53:58 <cdsmithus> Currently, cabal-install is telling me that reactice depends on Stream, which depends on QuickCheck >= 2.0, while reactive itself needs QuickCheck < 2.0
09:54:49 <dcoutts> cdsmithus: if you can't find suitable versions, it's probably possible to hack it, ignore the warnings and do it anyway.
09:55:24 <dcoutts> cdsmithus: you'd have to cabal unpack and cabal configure; cabal build; cabal install --only  on the one that complains.
09:55:28 <duaneb> ahh
09:55:35 <duaneb> that's pretty scary O.O
09:55:57 <cdsmithus> Thanks.
09:56:37 <dcoutts> cdsmithus: it's unlikely that the package version clash would be a problem in practise unless both are actually exporting functions that use QC and you're trying to equate the two types or something
09:57:36 <cdsmithus> And I'm sure they aren't... it's just QuickCheck, after all
09:58:16 <dcoutts> cdsmithus: right, the problem is cabal doesn't know that. In other examples you'd really get type errors.
10:00:15 <cdsmithus> So I've done the cabal unpack... it looks like I need to find the unpacked copy to configure?  Any idea where that would be?
10:00:46 <dcoutts> cdsmithus: it unpacks to a subdir with the name of the package, eg cd reactive-x.y
10:00:56 <cdsmithus> Ah... silly me, not even checking the current directory
10:00:59 <cdsmithus> Thank you!
10:01:14 * dcoutts should clarify the status message
10:03:19 <cdsmithus> Great, that did it.  Thanks, Duncan.
10:04:12 <paper_cc> is it possible to replace GHC 6.10.1 with 6.10.3 without rebuilding every installed package?
10:04:22 <dcoutts> paper_cc: no
10:04:50 <paper_cc> oh
10:05:49 * paper_cc prepares himself for another recompilation of HOpenGL, Gtk2Hs and wxHaskell
10:05:59 <gwern> paper_cc: ghc isn't very consistent with its binary stuff, y'see
10:06:10 <gwern> just one of the things you'll have to get used to
10:06:50 <dcoutts> in theory it's supposed to be between minor releases, but it's never been possible in practise because it checks .hi file versions down to the ghc minor version
10:07:54 <paper_cc> dcoutts: can I just change the .hi headers?
10:08:06 <dcoutts> paper_cc: no
10:08:36 <dcoutts> paper_cc: well, if you knew the binary format and were prepared to risk it, it might be possible
10:17:20 <duaneb> that's pretty scary O.O
10:17:23 <duaneb> whoop
10:18:45 <mmorrow> mauke: ping
10:18:53 * paper_cc nevertheless reads compiler/iface/BinIface.hs
10:19:31 <mauke> mmorrow: pong
10:20:30 <mmorrow> mauke: hey. i'm trying to write an x86 equiv of this x86_64 code that i have and am failing (it's similar to your hell.s in that it needs to pc). wanna take a look? :)
10:20:33 * mmorrow pastes
10:21:09 <mmorrow> mauke: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2472#a2472
10:21:33 <mmorrow> i think for one i'm pushing the args in the wrong order
10:22:08 <mmorrow> (but i tried switching that too and it segfaults as well, so i must be doing something(s) else wrong too)
10:24:04 <mmorrow> mauke:  here's C code to test it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2472#a2473
10:24:49 <mauke> yeah, parameter order is wrong
10:24:50 <mmorrow> mapM_ (print . (+41)) [0..7]
10:29:02 <mauke> mmorrow: hah, 22 lines of compiler diagnostics
10:29:44 <mmorrow> hehe
10:35:55 <jrib> I looked through http://www.haskell.org/haskellwiki/Books but can I get a recommendation for a book for someone comfortable with abstract math and other programming languages and no real prior experience with haskell?
10:36:50 <mauke> mmorrow: that whole scheme doesn't work
10:37:00 <mmorrow> mauke: gah, apparently it's segfaulting in memcpy
10:37:03 <wli> I never learned Haskell from books. Someone else chime in here.
10:37:04 <babilen> i enjoy reading Real World Haskell - but it is the first contact i have with Haskell so i can't comment on other books
10:37:06 <mmorrow> (according to gdb)
10:37:09 <mmorrow> mauke: oh?
10:37:26 <mauke> wait, what are your semantics
10:37:45 <jrib> wli: did you just read documentation online and dive in that way?
10:37:53 <mauke> mmorrow: do you only support functions of a single argument?
10:37:58 <wli> jrib: And papers.
10:38:12 <wli> jrib: esp. springschool95.ps
10:38:20 <jrib> wli: hmm, what's a good source for haskell papers?  Would I find them on arxiv?
10:38:26 <mauke> or is that two arguments
10:38:36 <dmwit> jrib: The Gentle Introduction is nice (though definitely not book length).
10:38:49 <pejo> jrib, most authors have them on their homepage.
10:38:52 <mmorrow> mauke: so the stub function take an mmapped chunk of memory, then copies into it machine code + storage for a functionptr and a long, which when called will call that embedded function with the embedded long as first arg, and the arg that it was called with as second arg
10:39:02 <wli> jrib: I used the SEL-HPC functional programming archive when it was still around. I don't know that there is a centralized source anymore.
10:39:11 <dmwit> jrib: People also report great success with YAHT (unfinished, but possibly book length), LYAH (mid-size), and RWH (a very nice and recent book).
10:39:14 <mauke> mmorrow: ok, so the real function will always take two args
10:39:21 <mauke> hmm, this is doable
10:39:22 <mmorrow> mauke: yes
10:39:42 <mmorrow> mauke: totally, the x86_64 version seems to work ok
10:39:49 <dmwit> jrib: As for papers, the one that got me hooked on Haskell was SPJ's paper on composable contracts.
10:40:01 <mauke> mmorrow: I'm ignoring that, I don't know x86_64 :-)
10:40:14 <mmorrow> mauke: heh
10:40:32 <dmwit> jrib: http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm # this one
10:41:01 <mmorrow> mauke: the part of `stub' that actually executes when it's called is:
10:41:44 <mmorrow> stub buf = let asm = [|.... f: .long 0, a: .long 0 ...|] in memcpy buf asm (length asm)
10:41:50 <dmwit> Wow, you know what's the worst default ps viewer ever?  GIMP
10:42:07 <dmwit> Screw you, sysadmin, whoever you are.  (Aw, crap, it's me.)
10:42:13 <mmorrow> mauke: so i think what's happening is that i'm not passing the arg to stub along to memcpy correctly
10:42:13 <shapr> whoops
10:42:37 <mauke> mmorrow: yes, that's one of the problems
10:42:50 <mauke> I'm working on it :-)
10:42:56 <mmorrow> weee :)
10:44:49 <Philonous> Is it a fair assessment to say monads encode side effects of some sort? Because you can't have direct side effect you store a description of it and the bind operator will "perform" it for you.
10:45:10 <dons> the system performs it for you.
10:45:10 <gwern> they can do that, but what are the side effects of the maybe or list monads?
10:45:50 <Phyx-> lol, can UndecidableInstances cauze ghc to go into an endless loop when compiling?
10:46:00 <Philonous> In maybe you can either continue the computation (Just) or abort it (Nothing), Either lets you either continue or abort with an error message
10:46:20 <jrib> dmwit, pejo, wli: thank you for your suggestions
10:46:50 <gwern> Phyx-: extensions can do that
10:47:30 <EvilTerran> Phyx-, yes, hence the name "undecidable"
10:47:54 <Philonous> dons: I meant monads in general. If you write your own monad instance your bind operator will handle the side effects, does it not?
10:48:04 <EvilTerran> Phyx-, although i seem to recall the typechecker has a fixed recursion depth limit
10:48:13 <Philonous> dons: In the case of IO the bind operator just does it "magically" ;)
10:48:34 <Phyx-> EvilTerran: i figured asmuch, I think i also know why it's doing it, i was just blindly following ghc's suggestions without thinking it throught :P
10:48:47 <Phyx-> EvilTerran: well, it sucked up to 2gb of memory before i killed it
10:50:12 <dons> Philonous: no, bind has nothing to do with it. it doesn't 'handle the effects'
10:50:37 <dons> bind helps set up a dependency from one function to another, and lets you bind the result of one computation for use later
10:51:07 <RLa> is there patch for haddock that allows unicode or html entities in comments?
10:51:33 <gwern> haddock doesn't handle unicode?
10:52:11 <dblick> I'm trying to figure out the Bananas and Barbed wire paper.  It seems that ana = foldr and cata = Data.Lists.unfoldr; are there standard equivalents of hylo and para?
10:52:20 <RLa> gwern, no
10:52:38 <gwern> huh. could it be using the standard IO functions and mangling the unicode?
10:52:40 <RLa> it just strips out some non-ascii chars and screws up others
10:53:04 <gwern> hm. that does sound like the IO functions
10:53:07 <dmwit> dblick: buildr is likely to be one of them, though I don't actually know what a hylo- or paramorphism is.
10:53:17 <RLa> no idea about mangling, manual says in clear words: "ASCII only"
10:53:40 <EvilTerran> buildr?
10:54:21 <gwern> line 449 of Main.hs: 'str   readFile filename'
10:54:28 <gwern> that could be it
10:54:51 <RLa> gwern, is that for me?
10:54:59 <gwern> RLa: yeah
10:56:08 <RLa> i also have some mess here, i update haddock, during update said it's 2.4.2 but haddock -V gives 2.3.0
10:56:21 <dmwit> buildr has a weird type, and I always get it wrong, and I can't find it now...
10:56:25 <dmwit> Something like
10:56:38 <dmwit> :t (:)
10:56:39 <lambdabot> forall a. a -> [a] -> [a]
10:57:15 <dmwit> gah
10:58:00 <dcoutts> @seen Heffalump
10:58:01 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 2h 12m 7s ago.
10:58:44 <dmwit> buildr :: (forall b. (a -> b -> b) -> b -> b) -> [a] -- or something like that
10:58:59 <dmwit> buildr f = f (:) []
10:59:29 <dmwit> Let's see...
10:59:30 <dmwit> :t foldr
10:59:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:00:03 <byorgey> dblick: you've got those backwards, actually, foldr is the catamorphism for lists and unfoldr is the anamorphism
11:00:42 <byorgey> 'cata' meaning 'down' (fold a data structure 'down' into a summary value) and 'ana' meaning 'up' (build 'up' a data structure from a seed)
11:00:52 <dblick> byorgey, oops, yes, that's right. and it looks like hylo is composition of cata para?
11:01:17 <byorgey> cata ana.
11:02:01 <dblick> oops. right.
11:03:07 <byorgey> paramorphisms are generalizations of catamorphisms.
11:05:28 <Philonous> dons: Assuming that a side effect is a change of context, doesn't bind handle them insofar, as it applies a function in the current context, takes it's return values (which in the monadic case are descriptions of contexts) and merges them together to a new context?
11:08:37 <jaredj> hello all. open financial exchange (ofx) is an sgml-based language for financial facts (e.g. bank statements). if i write a parser for it, does it rightly go under Text, Data, Codec?
11:09:45 <sm> go jaredj! I need that
11:10:29 <sm> I'd guess Data
11:10:33 <byorgey> jaredj: Data is usually for data structures, so not that I think
11:10:39 <sm> doh
11:10:51 <byorgey> I mean, on some level it doesn't really matter that much.
11:10:51 <sm> Finance ?
11:12:03 <byorgey> jaredj: the other two sound fine.
11:12:41 <dons> Philonous: yeah, that's correct.
11:12:59 <dons> e.g. getChar :: World -> (World , Char)
11:13:34 * shapr boings cheerfully
11:16:35 <gwern> jaredj: I'd go with text. if it's sgml-based, then it's akin to html/xhtml, which are under text iirc
11:16:59 <gwern> (Language. would be my second choice; then codec, then data)
11:17:36 <dons> if it is full support for the language (parsing, pretty printing, etc) Language.*
11:17:41 <dons> else Text.*
11:18:08 <gwern> dons: come to think of it, is there any description of the hierarchy anywhere?
11:18:13 <fracture> is there an assertion function in haskell?
11:19:04 <dons> fracture: yep, assert
11:19:05 <gwern> @hoogle assert
11:19:06 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:19:06 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
11:19:06 <lambdabot> Test.HUnit.Base class Assertable t
11:19:08 <dons> gwern: yep.
11:19:20 <dons> but it was made radically obsolete by hackage
11:19:36 <fracture> huh
11:19:40 <gwern> ah. that makes sense... the categories in hackage could use a little cleanup, 'tis true
11:19:42 <dons> gwern: see 'proposals' http://haskell.org/haskellwiki/Applications_and_libraries
11:19:42 <fracture> does it throw an exception if the assertion fails?
11:19:49 <dons> si.
11:19:50 <fracture> I'd like something that terminates the program
11:20:05 <fracture> using exceptions for assertions is a Bad Idea
11:20:10 <fracture> makes exception safety difficult
11:20:22 <dons> Prelude> GHC.Base.assert (True == False) $ "hey"
11:20:23 <dons> "*** Exception: <interactive>:1:0-14: Assertion failed
11:20:24 <fracture> (at least in a language like C++... I haven't thought about how that might work over in a pure functional setting)
11:20:37 <gwern> fracture: personally, I'd just do something like 'when foo $ error 'impossible!' or  'if !foo then error 'impossible' else regular stuff'; about as long as importing C.E and using assert
11:20:41 <dmwit> How do you propose to terminate the program in a principled way without exceptions?
11:20:44 <dons> i think async exceptions in haskell are probably a bit different to what you're thinking of.
11:20:53 <gwern> dons: so it's not much different than an if with an error call
11:20:53 <fracture> gwern: ok
11:20:54 <gwern> @src assert
11:20:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:21:01 <gwern> @src Control.Exception.assert
11:21:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:21:02 <dons> gwern: but note the source locations
11:21:08 <dmwit> gwern: That's still an exception, and it doesn't give you line number information...
11:21:13 <dons> also, ghc will optimize asserts out
11:21:17 <dons> (there's a flag to control that)
11:21:24 <fracture> is there no library function to call abort()?
11:21:29 <dons> so yes, conditionals, with some pragmatic infrastructure
11:21:33 <dons> fracture: exitWith
11:21:41 <gwern> optimize asserts out? sounds kind of dangerous
11:21:42 <dmwit> fracture: Sure, there's an IO action for that.
11:21:44 <fracture> probably calls exit, eh?
11:21:47 <dons> but if you really really just want to terminate the (unix) process, there's the unix library
11:21:53 <fracture> abort() will leave a core dump on most OSes
11:22:09 <dons> best practice for exit conditions is exitWith, if you want to produce a core dump, poke around in the unix library (exitImmediately)
11:22:21 <fracture> hrm
11:22:52 <fracture> seems like a hole in the library if you have to use an OS-specific lib to terminate the program that way
11:23:02 <pjdell> i know this is off topic but when upgrading ram, do i need to match mhz from my old ram to my new ram.... so old ram is ddr2 667, new ram needs to be ddr2 667?
11:23:10 <fracture> is the unix lib implemented for win32?
11:23:10 <dons> fracture: to produce a portable core dump?
11:23:18 <shapr> pjdell: Or faster, but it depends on the chipset on your mobo
11:23:21 <gwern> fracture: there's some OS-neutral way to produce core dumps?
11:23:25 <dons> if it is posix functionality, it may be in the portable base library
11:23:29 <fracture> no, to terminate as a failure and do whatever is right in an OS-specific sense
11:23:36 <shapr> pjdell: Come to #haskell-blah
11:23:37 <fracture> abort() is part of standard C, for example
11:23:37 <dons> oh, then use exitWith
11:23:45 <dons> fracture: exitWith is how you terminate a haskell program portably
11:23:48 <dons> in System.Exit
11:23:49 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5185#a5185 whee
11:23:53 <gwern> yeah, exitWith would be fine. I don't think core dumps are even desirable in general
11:24:03 <fracture> no, they are desirable...
11:24:12 <fracture> if your program terminates due to improper programmer assumptions
11:24:41 <Cale> Are you seriously going to do something with a core dump of a Haskell program though?
11:24:42 <gwern> so the user now has these big useless binary files laying around. very friendly thing to do...
11:24:43 <fracture> I dunno what it's like to try to debug a ghc-compiled program's core though.... maybe it's useless anyway
11:24:51 <Cale> I don't think we have any tools which apply to them.
11:24:54 <dons> for experts, anyway
11:25:05 <dons> would be better to use exitWith and then use the ghci debugger
11:25:09 <fracture> gwern: the user can ulimit -c 0 if they don't want cores
11:25:10 <dons> or get a stack trace
11:25:26 <dons> .... why is your haskell program going to dump core though ...
11:25:32 <fracture> (or if they are on windows, they don't get cores by default anyway)
11:25:55 <gwern> fracture: oh, that's even better? make them understand and use an obscure option to an obscure command to avoid getting something they have no use for and which wastes their resources and time?
11:25:59 <gwern> epicycles...
11:26:11 <dons> let's step back a bit: what error case in your program do you think will be handled usefully via a core dump?
11:26:30 <fracture> let's say you have a function taking a sorted list as an argument
11:26:32 <dons> since the usual C-like things aren't possible, thanks to soundness of the type system.
11:26:39 <fracture> and it's a precondition violation to call it with an unsorted list
11:26:49 <fracture> in debug, I want to check the precondition
11:26:59 <dons> right. so an 'assert' call is appropriate
11:27:05 <dons> for runtime invariants you've not ruled out via the type system
11:27:18 <dons> that will then let you analzye the code later in the ghci debugger
11:27:33 <dons> you *do not want to dump core* to analyze that though. it will not be helpful.
11:27:37 <fracture> ok; sounds like it's just different than C
11:27:49 <fracture> the problem is, I don't want to be able to trap the assertion's exception
11:27:53 <dons> core dumps are really designed with gdb in mind :)
11:28:01 <fracture> (I don't know enough about the error system to know if that is a problem)
11:28:11 <dons> sure. that's fine. use assert and don't catch exceptions of that kind.
11:28:17 <dons> you'll work out how to do that easily enough
11:28:18 <duaneb> do any of these (http://haskell.org/haskellwiki/Research_papers/Domain_specific_languages#Hardware_design) describe the description of hardware in haskell?
11:28:26 <dons> duaneb: yes.
11:28:34 <fracture> does anyone every code to catch all exception types?
11:28:41 <dons> i hope not
11:28:43 <fracture> in library stuff, etc?
11:28:52 <dons> in libraries, unlikely
11:28:55 <fracture> (common practice in C++, and an essential part of exception-safe programming)
11:28:58 <fracture> ok
11:29:03 <dons> you can write such a handler though
11:29:09 <fracture> guessing it's just different (I'll learn up on this at some point)
11:29:11 <dons> library functions will indicate which errors they handle
11:29:13 <sclv> fracture: people do have handlers that catch and rethrow all exceptions
11:29:20 <sclv> including in Control.Exception -- for cleanup and such.
11:29:23 <fracture> sclv: right, that's what I'm worried about
11:29:39 <eivuokko> You rarely catch all exception in C++, without rethrowing.
11:29:50 <fracture> let me think a little more about how exception safety works in a pure functional setting though
11:30:02 <dons> fracture: i think you should just start programming :) these worries will go away once you work out type safe programming :)
11:30:04 <fracture> eivuokko: right; but if there was a precondition violation, you don't want to throw an exception at all in C++
11:30:12 <sclv> as for generally catching all exceptions -- I think it makes sense for component systems like servers, except even then there are a few that aren't really generally recoverable from.
11:30:13 <eivuokko> Also, ghc has async exceptions, which change things a bit.
11:30:32 <SamB> fracture: you mean, like, bracket ?
11:30:43 <sclv> ?hoogle bracket
11:30:44 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
11:30:44 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
11:30:44 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
11:30:45 <fracture> so... it seems like exception safety is a little different because of the lack of mutable state
11:31:12 <sclv> fracture: exceptions themselves have funny semantics because of laziness, really.
11:31:31 <dons> fracture: btw, ch19 of real world haskell covers how exceptions work. another great reference is 'tackling the awkward squad'
11:31:33 <sclv> you have to think differently about them, but you'll get the hang soon enough.
11:31:39 <fracture> dons: I'll check it out
11:31:41 <duaneb> dons: lava?
11:31:42 <dons> which describes threads, locks, exceptions in haskell, you'll work it out.
11:31:44 <SamB> fracture: personally, I'd think violated preconditions should lead DIRECTLY to an exception, if it wouldn't just give you the wrong answer ...
11:31:48 <dons> duaneb: lava, yes. (its on hackage).
11:32:01 <fracture> SamB: maybe in haskell (I don't know yet), in C++ that's wrong though
11:32:03 <gwern> RLa: did you fix haddock's unicode issues?
11:32:05 <dons> duaneb: there's some commercial ones (cryptol, bluespec). i think 'wired' is another open source one.
11:32:07 <monadic_kid> "exception safe code" is not about trying to catch all thrown exceptoins
11:32:15 <fracture> monadic_kid: I know
11:32:26 <monadic_kid> so why did you make that statement?
11:32:29 <fracture> I didn't
11:32:33 <dons> fracture: play around with Control.Exception a bit, you'll get how it works
11:32:41 <SamB> bracket sorta catches all errors ... but it releases them after cleaning up
11:32:47 <SamB> er.
11:32:47 <fracture> "exception safety" refers to a very specific set of coding practices
11:32:52 <SamB> s/error/exception/
11:32:54 <fracture> similar to "thread safety", or whatever other safety
11:33:09 <jkl2> I'm getting 'multiple definition' errors related to the 'process' package when running 'ghc --make'.  The problem is that ld is trying to link in both Ubuntu's version and my local version.  I don't know why both are being linked in.  What should I do?
11:33:10 <monadic_kid> fracture: i'm aware of what exception safe code refers to thanks
11:33:25 <fracture> then maybe you can help me understand how it works in haskell?
11:33:28 <SamB> fracture: such as, not having the program totally crash just because an exception got thrown from inside ?
11:33:41 <sclv> fracture: also, when you're not worried about speed with all capitals, then often its better to write total functions that return Maybe values or Either values than that throw exceptions.
11:33:50 <fracture> SamB: no; it has to do with reasoning about changes in program state when exceptions are thrownm to ensure all invariants still hold
11:33:59 <dons> fracture: best to learn by doing, rather than IRC though. you'll just get confused without some concrete code to work with.
11:33:59 <SamB> fracture: ah
11:34:03 <fracture> languages like java and C# do it very poorly (often not at all)
11:34:13 <dons> fracture: http://book.realworldhaskell.org/read/error-handling.html
11:34:14 <SamB> the best way to avoid that is to not have global state when you can help it
11:34:16 <fracture> and in python it is literally impossible to write exception safe code
11:34:38 <fracture> C# too IIRC (there are async thread abort exceptions, which prevent you from writing functions that are guaranted not to throw)
11:34:45 <monadic_kid> i'm not aware of any RAII like idioms in haskell
11:34:47 <SamB> fracture: I think you're exaggerating a bit wrt python ...
11:34:48 <dmwit> fracture: One thing some people do for invariants is to invent a newtype, hide the constructor, and write a "smart constructor" that first ensures the invariant holds, then constructs the newtype.
11:34:48 <fracture> dons: thanks, was just about to start reading that
11:34:49 <sclv> haskell's exception mechanisms are mostly really nice, except for when you have to reason about block and unblock...
11:35:05 <SamB> monadic_kid: why need RAII when we have bracket ?
11:35:10 <fracture> monadic_kid: sounds like bracket is somewhat like it?
11:35:23 <fracture> (bracket is like C++ scopeguard)
11:35:24 <dons> fracture: no, static guarantee the condition holds dynamically.
11:35:35 <dons> sort :: [a] -> Sorted [a]
11:35:41 <dmwit> fracture: For example: module SortedList (sortedList) where { newtype SortedList a = SortedList { toList :: [a] }; sortedList = SortedList . sort }
11:35:41 <dons> then you write functions of type Sorted [a] -> ...
11:35:54 <dons> and its not possible to be passed an unsorted list, assuming your smart constructor is correct.
11:35:54 <fracture> dmwit: ah that is very nice
11:36:03 <SamB> or in Coq, you could actually *prove* the invariants to hold
11:36:05 <sclv> bracket still interacts funny with lazy IO though, of course.
11:36:17 <fracture> (could get tedious for certain types of preconditions, but may be quite useful for some other ones)
11:36:21 <dons> so you can rule out a lot of 'asserts' statically --> leaning on the type system is a core part of becoming a good haskell programmer
11:36:23 <SamB> sclv: what doesn't ?
11:36:29 <fracture> (and static checking is almost always better)
11:36:35 <SamB> lazy IO may just not be the right way to do it :-(
11:36:44 <fracture> anyway I'll go read the exception chapter
11:36:46 <sclv> plus you can pass the generated handle right out of the bracket statement if you are irritating and evil (which is in essence what lazy io does)
11:36:54 <dmwit> fracture: Yes, it can get a little tedious for some conditions.
11:37:01 <dons> sclv: do you think bracket/handle should be in rnf?
11:37:30 <dons> (similar issue with Chan, MVars, IORefs, other things that say something about the scope/timeing/evaluatedness)
11:37:34 <sclv> dons: not really, i think. but maybe there should just be more documentation, and strict variants?
11:37:38 <pjdell> l
11:37:48 <dons> i guess strict variants are the usual practice
11:37:54 <dons> yes, that seems reasonable.
11:38:02 <eu-prleu-peupeu> hello haskellers
11:38:02 <dons> (possibly even by default..)
11:38:05 <eu-prleu-peupeu> hi dons
11:38:35 <SamB> yeah, like what the heck is with foldl ?
11:38:36 <sclv> sometimes i want to write thunks to chans, so that i can force evaluation elsewhere, for example.
11:38:38 <malosh> Hi. Is there a way to define a constant empty MArray in a program, like in ocaml with (let a=[| |]) ? I have a complicated record type for which I want to provide a default
11:38:54 <SamB> I think foldl should be deprecated in the next Haskell standard ...
11:38:58 <SamB> replaced with foldl''
11:39:03 <dmwit> fracture: On the other hand, it's also a pretty handy way to deal with some invariants.  There's a great example in xmonad; the X library doesn't distinguish between an Int pointing at a window and an Int pointing at (say) a screen, so xmonad uses newtypes to make sure that those two types of Int never switch places...
11:39:13 <SamB> then, in the one after that, we can alias foldl' as foldl ...
11:39:15 <sclv> s/thunks/unevaluated expressions/ (precision police)
11:39:23 <roconnor> malosh: MArray is more like a function than an actual object.
11:39:41 <fracture> dmwit: yeah, that sounds like a nice use of static typing
11:40:16 <dons> we followed a general rule of moving invariants into the type system, where possible, in xmonad. everything else was checked with quickcheck
11:40:22 <dons> and then coverage analysis to back that up.
11:40:33 <fracture> what's quickcheck?
11:40:41 <dmwit> ?check \x y -> x + y == y + x
11:40:42 <lambdabot>   "OK, passed 500 tests."
11:40:43 <eu-prleu-peupeu> hey dons, im ripping the xmonad code for a project of mine :) hope theres no problem with it
11:40:46 <SamB> dons: so has anyone rewritten xmonad in Coq yet ?
11:40:47 <dons> automatic test generatoin based on type information
11:40:54 <dmwit> fracture: It's a type-directed randomized tester.
11:41:02 <dons> eu-prleu-peupeu: will be interesting to see how you go. do let me know.
11:41:03 <SamB> eu-prleu-peupeu: did you not read COPYING ?
11:41:03 <fracture> ah sounds nice
11:41:14 <RLa> it fails on basic rule of testing that tests must be repeatable
11:41:25 <dons> RLa: it is repeatable
11:41:28 <roconnor> SamB: http://www.haskell.org/pipermail/xmonad/2009-May/007881.html
11:41:29 <RLa> oh
11:41:30 <dons> RLa: you feed a seed in.
11:41:30 <eu-prleu-peupeu> SamB, im "rewritting" it for a different purpose, most of the architecture stays the same though :)
11:41:31 <dmwit> ?check \n -> length (replicate n ()) == n
11:41:32 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n"
11:41:51 <dmwit> Oh, cool, there's a great example of a property I thought would be true.
11:42:03 <dons> heh
11:42:23 <SamB> dmwit: you just need a better type for it ;-P
11:42:27 <dmwit> ?check \n -> n > 0 ==> length (replicate n ()) == n
11:42:28 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:42:28 <lambdabot>           ...
11:42:29 <roconnor> dons: Do you really use seeds when QuickChecking xmonad?
11:42:42 <dmwit> ?check \n -> (n > 0) ==> (length (replicate n ()) == n)
11:42:43 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:42:43 <lambdabot>           ...
11:42:47 <dmwit> huh
11:42:57 <dons> roconnor: no, as i want to search more of the search space on each run
11:42:57 <roconnor> dmwit: ==> is busted in lambdabot
11:43:01 <dmwit> Oh, okay.
11:43:03 <dons> but e.g. ghc uses a fixed seed
11:43:14 <roconnor> oh interesting
11:43:35 <hatds> can use an 'if' I suppose
11:43:44 <SamB> something to do with SmallCheck, I expect ?
11:43:46 <dmwit> fracture: There's also smallcheck, which is similar, but exhaustive.  Naturally, it only works well for small, finite types... ;-)
11:44:00 <SamB> ?scheck \n -> (n > 0) ==> (length (replicate n ()) == n)
11:44:01 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:44:01 <lambdabot>           ...
11:44:07 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5187#a5187 naive factorial vs. primop factorial :P
11:44:14 <roconnor> I wonder if it is better to quickcheck 500 tests than repeatably test 1 test.
11:44:17 <SamB> hmm, no ...
11:44:29 <SamB> roconnor: probably neither is that great
11:44:29 <dons> there's a couple of model-based generators for quickcheck now too
11:44:30 <roconnor> possibly false dichotomy
11:44:34 <dons> and one that hooks up prologo
11:44:49 <sclv> ?check \n -> n <=0 || length (replicate n ()) == n
11:44:50 <lambdabot>   "OK, passed 500 tests."
11:44:53 <SamB> roconnor: both is better, but I'd think you'd want at least 3 or 4 pre-selected cases
11:44:54 <paper_cc> does GADT syntax for associated types work in GHC 6.10.3? (I looked at the ticket but it doesn't mention if the changes were committed to STABLE)
11:45:06 <SamB> roconnor: (selected on the basis of having failed in the past, possibly)
11:45:10 <dmwit> I remember reading something about quickcheck getting a way to minimize test cases... did anything ever come of that?
11:45:23 <dons> yes, it supports shrinking in QC 2
11:45:27 <dons> and has done for a while.
11:45:29 <roconnor> what I almost like more about QuickCheck is that you actually get write out Pi_1 formula giving specifications.
11:45:33 <SamB> reminds me of lazy smallcheck ...
11:45:41 <roconnor> that's even more important than checking them IMHO
11:46:43 <dons> stating all those invariants is the main thing, yes. they specify your program
11:46:59 <dons> then you get to choose whether to enforce them via the type system, an external static analysis, a runtime check, or testing
11:47:13 <dons> but first you need the properties.
11:47:26 <roconnor> often it is hard to enforce them via the type system.
11:47:41 * dmwit senses a circle in the conversation
11:47:45 <roconnor> and probably often hard to do a runtime check
11:48:04 <roconnor> and you can only test instaces.
11:48:09 <SamB> they might all 4 be hard
11:48:12 <roconnor> go static analysis!
11:48:36 <dons> depends on how much IO I think.
11:48:54 <dmwit> Yeah, it's hard to quickcheck Gtk interfaces.
11:48:59 * Baughn wonders if anyone has looked at using AOP/FOP in haskell
11:49:13 <duaneb> huh
11:49:13 <duaneb> so
11:49:20 <roconnor> oh ya.  I was only talking about quickcheck properties
11:49:22 <duaneb> I did `cabal install chalmers-lava2000`
11:49:24 <duaneb> and it installed
11:49:29 <duaneb> but neither I nor ghc can find it
11:49:34 <roconnor> which probably doesn't encompass all properties you want to check
11:49:40 <dmwit> duaneb: ghc-pkg list?
11:49:59 <dmwit> duaneb: (I'm guessing it's installed locally, and you're trying to compile something using the global package list.)
11:49:59 <roconnor> @seen Cale
11:49:59 <lambdabot> Cale is in #haskell-in-depth, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 25m 8s ago.
11:50:15 <roconnor> Cale: what would it take to get ==> working in @check again?
11:50:58 <Baughn> @tell frwmanners [..no version of filterE could work with...] <-- Could you expand on this?
11:50:59 <lambdabot> Consider it noted.
11:51:02 <dmwit> ?ask Cale what it would take to get ==> working in @check again
11:51:03 <lambdabot> Consider it noted.
11:51:20 <duaneb> yep
11:51:26 <duaneb> dmwit: it lists it as  chalmers-lava2000-1.0.2
11:51:41 <dmwit> duaneb: But does it list it in the global package list or in the local package list?
11:52:05 <duaneb> ahh, it's Lava200
11:52:38 <duaneb> dmwit: local
11:54:25 <dmwit> duaneb: Cool, and how are you compiling whatever it is that uses it?
11:54:38 <duaneb> dmwit: well
11:54:39 <duaneb> it compiles now
11:54:48 <duaneb> dmwit: I loaded 'Lava' instead of 'Lava2000'
11:55:41 <Baughn> I.. gah..
11:56:15 <Baughn> @tell conal Your Functor instance and your Monad instance for Event have differing definitions of fmap. One almost works in that filterE thing, the other fails.
11:56:16 <lambdabot> Consider it noted.
11:56:23 <Baughn> @seen conal
11:56:23 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 4h 10m 22s ago, and .
11:58:49 <skorpan> @pl \tree -> YiA (jsCompile tree)
11:58:49 <lambdabot> YiA . jsCompile
12:00:28 <Cale> roconnor: uh, I'm not sure.
12:00:28 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:02:04 <Cale> @check \x y -> x < y ==> x^2 < y^2
12:02:05 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:02:05 <lambdabot>           ...
12:02:37 <Cale> @check \x y -> x < y ==> x^2 < y^2
12:02:38 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:02:39 <lambdabot>           ...
12:02:41 <Cale> hmm
12:03:17 <Cale> ah...
12:03:31 <Cale> There are 3 versions of quickcheck installed
12:03:55 <Cale> But 1.1.0.0 is the global one...
12:05:12 <Cale> I don't know how to make it select a different one.
12:06:02 <Cale> @check \x y -> x < y ==> x^2 < y^2
12:06:03 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n1\n"
12:06:18 <Cale> Okay, so removing the user versions of QuickCheck worked.
12:06:53 <Cale> It would be nice to have a newer QuickCheck, but it seems to be picking the global rather than the user package, so I don't know what I can do about it.
12:07:15 <Cale> (I can't install things globally, or else I would have upgraded ghc by now)
12:07:58 <dino-> top
12:08:21 <Cale> charm
12:08:54 <Zao> Cale: Not enough space in $HOME or /tmp? :)
12:09:44 <Cale> Hmm...
12:11:32 <Cale> .oO(Do I really want to get into this?)
12:11:38 <Cale> Well, I suppose I can try it.
12:12:43 <Zao> My $HOME has gigs of self-built software, in order to work around Debian's awesometastic deployment speed.
12:13:31 <Cale> I usually install things in /usr/local/
12:18:59 <Cale> Whoops, this is an x86_64 machine apparently...
12:21:57 <Baughn> @src liftM
12:21:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:22:18 <Baughn> @. pl undo do { x1 <- m1; return (f x1) }
12:22:19 <lambdabot> f `fmap` m1
12:22:29 <Baughn> ..thanks, bot. Really.
12:37:28 <duaneb> is there a function for (\(a, b) -> a == b)?
12:37:57 <Taejo> duaneb: uncurry (==)
12:38:15 <Taejo> :t uncurry
12:38:18 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:38:24 <Taejo> :t uncurry (==)
12:38:25 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
12:38:27 <duaneb> right
12:56:17 <gwern> @seen nomeata
12:56:17 <lambdabot> nomeata is in #xmonad, #haskell and #darcs. I don't know when nomeata last spoke.
12:56:54 <gwern> @ask nomeata I find I've been sending darcswatch emails using 'OBSOLETE' or 'REJECTED' instead of '[OBSOLETE]'. could you generalize the keyword?
12:56:55 <lambdabot> Consider it noted.
12:57:48 <nomeata> gwern: sure, why not
12:57:48 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
12:59:45 <nomeata> gwern: done
13:00:07 <gwern> and maybe rerun on the old emails? :)
13:00:26 <nomeata> hmm, thats not possible, they are not saved
13:00:26 <gwern> (I was manually replying to them, but I'd rather not; I'm not sure that even works, as gmail strips attachments)
13:00:46 <gwern> how quickly does darcswatch refresh?
13:01:28 <nomeata> gwern: upon mails, about immediatelly
13:01:41 <nomeata> gwern: otherwise hourly
13:01:51 <gwern> (a decent gui/website for darcswatch would actually be good; it feels so fragile and like shots in the dark right now - one has no idea whether an email worked or not)
13:01:54 <Absolute0> What do I need to do to use data values in another module? Simply importing the module where the data type is defined doesn't seem to help.
13:02:15 <Absolute0> Do I need to export all the values as well?
13:02:34 <nomeata> gwern: maybe one should define two mail addresses, one to leech patches off maliing lists, and one where each mail gets a reply about the result
13:02:37 <nomeata> patches welcome :-)
13:02:40 <gwern> Absolute0: are you sure the original module exports it?
13:03:18 <gwern> nomeata: yeah yeah, I know. the obvious solution is to use happstack or one of the other web frameworks, except I don't know any of'em
13:03:53 <nomeata> gwern: right, enabling write-web-access would be helpful as well :-)
13:04:54 <gwern> be a good summer project though
13:04:56 <gwern> how hard could it be?
13:05:53 <nomeata> gwern: I have been avoiding that because I once thought of darcswatch as a purly passive thing that just watches projects
13:06:06 <nomeata> but it doesnt fit its current usage, I guess
13:06:18 <nomeata> it wouldnt actually be too hard to add some interaction there
13:07:54 <Cale> Absolute0: in the export list, if you want to export all the constructors, put (..) after the type name
13:08:16 <Cale> Absolute0: Same goes for the import list if you make it explicit.
13:08:40 <Absolute0> Cale: is there any syntax to simply export everything?
13:08:44 <Absolute0> with no hiding?
13:08:49 <Cale> Absolute0: leave the export list out.
13:08:57 <Absolute0> thats what I have..
13:09:26 <Cale> Hmm... can I see the module declaration and how you're importing it?
13:09:44 <Cale> If you just write
13:09:47 <Absolute0> nevermind I forgot the where keyword
13:09:49 <Absolute0> :)
13:09:50 <Cale> module MyModule where
13:09:52 <Cale> ah
13:10:18 <Cale> Yeah, that 'where' is a bit funny since GHC only permits one module per file regardless.
13:10:34 <Heffalump> but other implementations could behave differently
13:10:39 <Cale> But the language spec doesn't say anything about how the source should be broken into files.
13:10:50 <Heffalump> and apart from the exception for the indentation rule, it makes things very consistent with other declaration forms
13:11:11 <hatds> which means that in theory if want to compile the same project with different compilers you are boned
13:11:16 <gwern> nomeata: really, just a button to mark obsolete/rejected would be enough
13:11:27 <Absolute0> Do file names and modules file the java convention?
13:11:39 <Absolute0> Capital one per file etc..
13:11:45 <gwern> Absolute0: pretty much
13:11:58 <Zao> A.B.C usually lives in A/B/C.hs
13:12:02 <gwern> I'm not sure java allows Foo.hs, Foo/Bar.hs though
13:12:10 * gwern not very familiar with java
13:12:13 <Absolute0> company link as the module prefix?
13:12:19 <Heffalump> Absolute0: no
13:12:30 <Cale> That convention is ridiculous ;)
13:12:35 <Absolute0> com.sun.somecoolapp
13:12:36 <Heffalump> you avoid namespace clashes using the package system if absolutely necessary
13:12:55 <nomeata> gwern: hmm. I wonder if that couldnt be abused too easily (people obsoleting patches they dont like). with mail, at least the From of the mail is stored...
13:13:10 <Cale> The module path should express something about the purpose of the module, not who made it.
13:13:14 <gwern> nomeata: if abuse is an issue, authentication can be added later
13:13:25 <Absolute0> is the deriving keyword only limited to data definitions?
13:13:33 <Absolute0> or can it also be used with type synonyms?
13:13:37 <gwern> nomeata: no point in overengineering it - heck, as far as I know I'm the only person using darcswatch
13:13:40 <pumpkin> Cale: what if 100 different people made variations on a matrix library
13:13:43 <Heffalump> no, it can't be used on type synonyms
13:13:44 <Cale> It can be used with newtype and data
13:13:52 <nomeata> gwern: true again :-)
13:13:55 <Heffalump> pumpkin: then you use packages to pick one
13:13:58 <Absolute0> oh
13:14:01 <Cale> Not with type synonyms, since it's not valid to put different instances on those anyway.
13:14:09 <pumpkin> Heffalump: that's a pain to do unless you're using cabal isn't it?
13:14:22 <Heffalump> pumpkin: it can be a bit annoying, yes
13:14:22 <pumpkin> but I guess using cabal itself isn't a pain
13:14:38 <Cale> > 1 + 1 -- still working?
13:14:42 <lambdabot>   2
13:14:51 <nomeata> gwern: (Even I havent used it in quite a while. I havent submitted patches anywhere for a while, though)
13:14:51 <Cale> now...
13:14:52 <hatds> calling everything Data.Matrix is not a great system imho
13:15:04 <pumpkin> Data.Matrix.HATDS
13:15:07 <pumpkin> ;)
13:15:26 <Heffalump> in practice people use Data.Matrix.HATDS or whatever, yeah
13:15:27 <pumpkin> or just stick your initials onto the end of every module name
13:15:41 <pumpkin> not that I like that either
13:15:43 <Heffalump> it means that the top levels of the system are used for classification
13:15:53 <Absolute0> Can I limit type synonyms to certain ranges?
13:16:03 <pumpkin> nope
13:16:08 <Absolute0> say type x = [Int] where into is only positive
13:16:26 <Absolute0> or [Int] where Int is 0..9
13:16:28 <pumpkin> that would be very nice, but not possible :)
13:17:11 <gwern> well, you can have runtime checks
13:17:22 <gwern> but static checks put you into dependent types territory
13:17:48 <Absolute0> haskell has a slow learning curve :(
13:18:06 <Absolute0> 3 tutorials still having trouble..
13:20:12 <Raynes> Absolute0: Have you read Real World Haskell?
13:20:34 <Absolute0> http://rafb.net/p/hfFXnR76.html <-- In main ChessPiece cannot be converted to String
13:20:48 <Absolute0> Raynes: learn a good haskell is pretty nice.
13:21:17 <Absolute0> And since type synononyms cannot derive typeclasses i am stuck
13:21:25 <gwern> Absolute0: need to call show
13:21:27 <Absolute0> do I explicitly show the tuple?
13:21:30 <Absolute0> ah :)
13:21:36 <gwern> main = print (Pawn, White, ('a', 6))
13:21:49 <gwern> Char and Int already have show defined
13:21:56 <wli> use print instead of putStrLn
13:21:58 <dino-> I must be missing something simple about Parsec, but how do you do the regexp equivilent of "(.*)foo" ?
13:21:59 <gwern> and you derived show for piece and color; so you're good
13:22:05 <dino-> Everything up to "foo"
13:22:48 <Absolute0> gwern: print shows the same error
13:23:13 <mauke> dino-: everything up to the last "foo"
13:23:18 <mauke> hmm, nontrivial
13:23:27 <gwern> Absolute0: well, there are other errors in your file
13:23:29 <gwern> like the import
13:23:44 <Cale> Absolute0: If that's all one file, then you're in trouble :)
13:23:52 <Absolute0> gwern: I ran 'cat *hs|paste' you dummy
13:24:11 <Cale> Absolute0: but print should be okay
13:24:13 * gwern feels abashed?
13:24:25 <Absolute0> print calls show?
13:24:41 <gwern> Absolute0: yup
13:24:51 <gwern> print = putStrln . show, iirc
13:24:55 <gwern> @src print
13:25:00 <lambdabot> print x = putStrLn (show x)
13:25:32 <gwern> Absolute0: but yeah, that compiles for me if you replace the do putStrLn with print (and cm out the import)
13:25:49 <gwern> (main runs fine too)
13:26:09 <Absolute0> http://rafb.net/p/iNo7qR71.html
13:26:10 <gwern> oh good, hlint catches the redundant 'do'
13:26:29 <Absolute0> http://rafb.net/p/03HSrV84.html
13:26:54 * gwern has no idea why you put that annotation there
13:27:41 <Absolute0> what's the error?
13:27:53 <Absolute0> ah
13:27:55 <Absolute0> 1 sec
13:28:08 * Baughn folds, spindles and mutilates Data.Unamb
13:28:32 <Cale> Absolute0: the :: ChessPiece annotation applies to the entire expression, including the print
13:28:36 <Baughn> (Anyone with detailed knowledge of how unamb works, please speak up)
13:29:24 <Cale> Baughn: Well, I'm not sure, but as I recall, it just attempts to evaluate the two expressions concurrently, and the first one to complete wins.
13:29:39 <Baughn> Cale: ..yeah, there's a bit of subtlety in that
13:29:47 <Baughn> Cale: (The current one doesn't /work/. I'm fixing it.)
13:30:21 * Cale looks at the source...
13:30:26 <Cale> What's wrong with it?
13:30:43 <Absolute0> Cale: that's it. :)
13:31:14 <Baughn> Cale: ..I'm not really sure, to be honest, but the case of recursive unambs is giving me trouble.
13:31:35 <Baughn> Cale: There are further problems (like not using a specialized exception for both being bottom), so I figured I might as well just chuck the code and start over.
13:32:07 <Baughn> The current code fails, by way of race conditions. Simple code often works. Makes it hard to write test-cases.
13:33:08 <mux> is there an OS independant removeFile function?
13:33:17 <gwern> unamb sounds like a giant race condition... how could it fail that way?
13:33:56 <Cale> mux: Yes. It's in System.Directory
13:34:17 <Heffalump> gwern: the whole point of unamb is to race..
13:34:18 <gwern> actually, why couldn't you just grab a random bit and choose between the 2 functions? wouldn't that be the same thing as unamb? I don't see how a function calling unamb could tell the difference
13:34:20 <Baughn> gwern: It likes killing threads. Apparently it's a bit too eager about it.
13:34:25 <mux> Cale: thank you
13:34:28 <gwern> Heffalump: yeah, that's my point
13:34:34 <Heffalump> gwern: one thread might not ever terminate
13:34:37 <Baughn> gwern: And no, the point of unamb is that 'unamb undefined 2' evaluates to 2
13:34:50 <Baughn> gwern: Or, unamb a b evaluates to whichever value is not bottom
13:35:05 <gwern> oh. sounds like a strange function
13:35:10 <Baughn> Oh yes
13:35:28 <Heffalump> actually it's a very natural function
13:35:36 <Baughn> It escapes breaking referential transparency by the skin of its teeth and careful usage
13:35:41 <Heffalump> it just never occurred to anyone before conal came along :-)
13:35:49 <p_l> Baughn: is it somehow related to that old crazy macro known as amb?
13:36:05 <gwern> p_l: connor's amb?
13:36:12 <Cale> Conal's.
13:36:16 <Cale> oh
13:36:21 <Cale> p_l: no
13:36:27 <p_l> oh, ok
13:36:29 <Heffalump> (a && b) `unamb` (b && a) is one of the neat uses of it: an and that short-circuits on *both* arguments.
13:37:06 <Cale> It doesn't really escape breaking referential transparency.
13:37:21 <Heffalump> it breaks it if you violate the pre-condition
13:37:26 <Cale> right.
13:37:33 <Cale> Which isn't expressed in its type.
13:37:54 <gwern> precondition? don't pass it 2 bottoms?
13:38:20 <Cale> gwern: The parameters you pass it must be equal if they are not bottom.
13:38:48 <gwern> so unamb 2 3 is no good?
13:38:52 <Cale> right
13:39:09 <Cale> You will get a random result in that case.
13:39:23 <mauke> (a `unamb` b) && (b `unamb` a) ?
13:39:24 <Baughn> Also, an alligator will leap from your closet and eat you.
13:39:24 <Cale> (though practically speaking, I'm pretty sure you'll almost always get 2)
13:39:39 <Baughn> a `unamb` b is produces *undefined behaviour* if a /= b
13:39:56 <Cale> Not really though.
13:39:58 <gwern> what is unamb's type sig? not a -> a -> IO a, I assume from the precondition
13:40:06 <Baughn> gwern: a -> a -> a
13:40:16 <Baughn> It's implemented in terms of unsafePerformIO and race
13:40:30 <gwern> ah. so that's why randomness is bad, since you could run unamb 2 3 twice and get 2 different values
13:40:31 <dino-> mm.. manyTill anyChar (try (string "foo"))
13:40:35 <gwern> it claims to be pure
13:40:45 <Philonous> gwern: Actually passing it two bottoms is intended behaviour.  You could do something like True `unamb` (_|_  `unamab` _|_ )
13:40:59 <Baughn> gwern: It is pure, it just requires a precondition the type system can't check
13:41:02 <BMeph> dON'T PASS IT TWO *NON*-BOTTOMS, THEN. :)
13:41:05 <Taejo> gwern: it's pure subject to its precondition
13:41:13 <Baughn> Breaking it is bad, just like using unsafeCoerce is bad
13:41:15 <dino-> Is more like non-greedy (.*)foo
13:41:18 <BMeph> Whoops, Caps - soory.
13:41:36 <Taejo> BMeph: no, don't pass it two values that are incomparable in the definedness relation
13:41:39 <dons> roconnor: i see you made the front page of reddit :)
13:41:46 <Philonous> BMeph: You can pass it two non-bottoms if they are equal
13:42:04 <Heffalump> mauke: that looks wrong. If a finishes first, then it'll evaluate to a no matter what b is.
13:42:09 <Cale> (and that's also often needed)
13:42:14 <Philonous> BMeph: There is even a use for it: Suppose you have two compuations, one is very expensive, the other one very cheap, but you don't know which one is which
13:42:25 <Taejo> Philonous: more than that: (Just _|_ `unamb` Just (Just _|_)) is well-defined, the value is Just (Just _|_) (as I understand)
13:42:32 <mauke> Heffalump: oh, right
13:42:38 <mauke> whee, alcohol
13:42:59 <Heffalump> is unamb the one that goes deeply?
13:43:02 <Philonous> Taejo: Yes, that would make sense
13:43:19 <Cale> Taejo: no, that doesn't seem to work
13:43:29 <gwern> 'haskellers do it with bottoms.'
13:43:31 <dons> roconnor: yes, well done. nice article, clear application of theory. practical, unambiguous conclusion. teaches the reader. that's good blogging.
13:43:40 <BMeph> Fine, fine - don't pass it two non-bottom values that you *KNOW* cannot be equal. Does that cover it, or should there be more qualifications.
13:43:43 <BMeph> ?
13:43:43 <Cale> It only does WHNF
13:43:43 <Heffalump> dons: what article?
13:44:00 <Heffalump> BMeph: don't pass it two non-bottom values that you do not know must be equal
13:44:07 <Taejo> my bad, I'm thinking of lub
13:44:22 <Heffalump> lub is implemented by a type class, isn't it?
13:44:28 <Taejo> unamb requires that it's arguments are _|_ or equal
13:44:33 <gwern> Taejo: I'd hope haskellers do it with lub; although people do claim haskell is a S&M language...
13:44:35 <dons> roconnor's article on lotteries is on the reddit front page
13:44:46 <dons> gwern: though you hear that less these days,
13:44:53 <dons> it was more common a few years ago (more static typing these days?)
13:44:56 <Heffalump> dons: oh, yeah
13:45:15 <gwern> dons: well, with gay marriage becoming more accepted, what's a few kinks like a type system to people these days?
13:45:24 <dons> right.
13:45:26 <BMeph> Heffalump: If you don't know that they are equal, but you know that they could be equal, use something else, then? :)
13:45:55 <dons> after a decade of perl , python, ruby, its refreshing to see type systems coming back. (scala, f#, ) all applying ideas from ICFP :)
13:45:57 <Baughn> Heffalump: None of them go deeply, but you could do "x `unamb` (y `using` rnf)" if you'd like
13:47:38 <tetha> dons: the interesting thing about haskells type system is that it's powerful enough to be not in the way again
13:47:54 <Heffalump> Baughn: that doesn't help with going into the structure of the value
13:48:13 <Heffalump> you want (_|_, 3) `lub` (2, _|_) = (2, 3) [which is exactly what lub gives you]
13:48:34 <hackagebot> bsd-sysctl 1.0.3
13:48:42 <Baughn> Heffalump: Oh, like that. It would be an interesting exercise..
13:48:46 <dons> tetha: yup
13:48:57 <Baughn> Heffalump: You could do it by recursive use of unamb, of course
13:49:08 <Heffalump> Baughn: yes, I think that's what lub does, with a typeclass
13:51:48 <BMeph> If you did a defn like "b = map sum . inits $ b", would GHC be able to figure out that it's equal to "repeat 0" (er, denotatively, I mean)?
13:52:11 <Heffalump> > inits [3,4]
13:52:12 <lambdabot>   [[],[3],[3,4]]
13:52:34 <Heffalump> > fix (map sum . inits)
13:52:39 <lambdabot>   mueval-core: Prelude.read: no parse
13:52:40 <lambdabot>  mueval: ExitFailure 1
13:52:49 <Heffalump> ??
13:53:04 <BMeph> From Heffalumps examples, I'm guessing No. :\
13:53:16 <Taejo> > let b = map sum . inits $ b in b
13:53:17 <pumpkin> > let b = map sum . inits $ b in b
13:53:21 <pumpkin> :P
13:53:22 <lambdabot>   mueval-core: Prelude.read: no parse
13:53:22 <lambdabot>  mueval: ExitFailure 1
13:53:22 <lambdabot>   mueval-core: Prelude.read: no parse
13:53:22 <lambdabot>  mueval: ExitFailure 1
13:53:30 <Heffalump> it stack overflows in ghci
13:53:30 <monochrom> What?
13:53:41 <Heffalump> I think inits isn't lazy enough.
13:53:44 <Heffalump> @src inits
13:53:44 <lambdabot> inits []     =  [[]]
13:53:44 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
13:53:49 <Heffalump> yep, that's the problem.
13:53:51 <monochrom> Ah yes.
13:54:10 <monochrom> But "no parse" is really unsatisfactory.
13:54:33 <Taejo> > let loop = loop in loop :: String
13:54:39 <lambdabot>   mueval-core: Prelude.read: no parse
13:54:39 <lambdabot>  mueval: ExitFailure 1
13:54:48 <fracture_> I have a list, and want to do something for each element that involves all the elements before and after the current one
13:54:53 <Heffalump> @let inits' v = []:(case v of { [] -> [] ; (x:xs) -> map (x:) (inits' xs) } )
13:54:54 <lambdabot>  Defined.
13:54:55 <fracture_> anyone know what I should be looking at to do that?
13:54:59 <fracture_> (basically a for loop)
13:55:01 <Heffalump> > fix (map sum . inits')
13:55:03 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:55:06 <monochrom> Anyway you could predict the result yourself.  map sum (inits _|_) = map sum _|_ = _|_ done.
13:55:09 <pumpkin> nice :)
13:55:11 <lament> fracture_: perhaps a zipper
13:55:12 <fracture_> I tried splitAt with a map over a list of ints up to length, but it seems retarded
13:55:17 <fracture_> hmm ok
13:55:25 <Taejo> fracture: or a foldl
13:55:34 <Taejo> it depends on what exactly you're doing
13:55:37 <fracture_> I don't think I can do it with fold (unless I just don't know how)
13:55:45 <Taejo> even map foo . inits might be ppropriate
13:55:54 <Taejo> fracture_: what do you want to do?
13:55:55 <lament> but yeah, what are you doing, is it really O(n^2)?
13:56:21 <monochrom> "do something for each element that involves all the elements before and after the current one" contains almost no information.
13:56:34 <fracture_> yeah lemme be more specific
13:56:35 <Taejo> oh, I missed the "and after"
13:56:36 <lament> it says O(n^2)
13:56:43 <Taejo> so basically, it depends on the whole list
13:56:48 <lament> which suggests maybe not use lists at all here
13:56:58 <fracture_> so the problem is like... I have a list (it'll be something like [5,2,2,1]), I want to group it [[5],[2,2],[1]]
13:57:07 <monochrom> nub
13:57:08 <fracture_> then for each group in the group list, I want to mutate the first element of the group
13:57:14 <fracture_> concat the whole thing back together and recurse
13:57:16 <Botje> mutate?
13:57:16 <monochrom> err, group.
13:57:22 <Taejo> fracture_: to do the first part, use group
13:57:23 <fracture_> well, in an imperative way of thinking
13:57:27 <fracture_> yeah got that far
13:57:28 <lament> > group [5,2,2,1]
13:57:30 <lambdabot>   [[5],[2,2],[1]]
13:57:31 <Botje> what an odd concept
13:57:46 <Taejo> fracture_: then, use map to modify each list
13:57:57 <fracture_> that won't work, because I need the whole list for each iteration
13:58:00 <monochrom> I don't mind people talking about "mutate". We know how to deconstruct that.
13:58:12 <Taejo> fracture_: please explain
13:58:46 <fracture_> like, I want to recurse down my function with each group changed at a time
13:58:52 <monochrom> Mutate in what way? Concat the whole thing back --- we know how. Recurse in what way?
13:58:58 <Heffalump> so should I report a laziness bug against inits?
13:59:00 <fracture_> so like, first change the 5 to 2,2,1
13:59:13 <fracture_> then change the 2,2 to 1,1,1,1, but leaving the 5
13:59:19 <fracture_> err actually 2,1,1
13:59:45 <monochrom> When do you stop recursing? Is there a base case?
13:59:48 <fracture_> like for sake of making it simpler, imagine I just want to set the first element of each group to 0 in turn
13:59:52 * Baughn proceeds to deliberately break unamb's invariant. :P
14:00:07 <Taejo> fracture_: that's easy... no need to look at the rest of the list
14:00:11 <fracture_> so I'd get [[0],[2,2],[1]] first time, then [[5],[0,2],[1,1]]
14:00:17 <Cale> > map (\(x:xs) -> 0:xs) . group $ [5,2,2,1]
14:00:19 <lambdabot>   [[0],[0,2],[0]]
14:00:20 <fracture_> monochrom: yes
14:00:23 <Cale> huh?
14:00:31 <fracture_> yeah but I want the whole list each time
14:00:42 <Cale> "each time"?
14:00:53 <Cale> ah
14:00:59 <Cale> Maybe I know what you mean...
14:01:01 <fracture_> ok let's say I want to call the function "foo" (forget about recursion) N times
14:01:03 <fracture_> the number of groups
14:01:11 <fracture_> and each time should have a different mutated group in the list it gets
14:01:13 <fracture_> as an argument
14:01:15 <Taejo> fracture_: why not give an example of a call to your function, and the desired result
14:01:28 <fracture_> because it's a long story ;)
14:01:59 <fracture_> I guess I had something kinda like this yesterday (if anyone remembers that 'mappish' function)...  seems like there should be an easier way to do it though
14:02:02 <dmwit> A zipper is exactly the right data structure for this, in my opinion.
14:02:03 <Taejo> fracture_: I must say I don't see how it can be harder to give an example than a specification
14:02:14 <monochrom> By training and self-selection, programmers can express "how" but not "what", and nevermind "why". It's pretty sad.
14:02:17 <dmwit> It seems pretty clear what he wants to do.
14:02:29 <fracture_> Taejo: this question is more about how to do something generally than a particular function
14:02:40 <fracture_> if I just wanted the function, I'd stick with splitAt and a psuedo for loop
14:02:53 <fracture_> ok I'll look into zip
14:02:57 <dmwit> data Zipper a = Zipper { before :: [a], current :: a, after :: [a] } -- "before" is  stored in reverse order
14:03:10 <fracture_> is that from the library?
14:03:11 <dmwit> No, not zip; a zipper.  (They're really different. =))
14:03:13 <fracture_> ahh
14:03:16 <fracture_> this sounds more like it
14:03:35 <dmwit> next :: Zipper -> Maybe Zipper
14:03:35 <Taejo> how do you get lambdabot to remember quotes?
14:03:40 <monadic_kid> there was a good blog about zippers
14:03:53 <fracture_> dmwit: what lib is zipper in?
14:04:04 <dmwit> next (Zipper bs c []) = Nothing; next (Zipper bs c (a:as)) = Just (Zipper (c:bs) a as)
14:04:11 <dmwit> fracture_: I'm making it up as I go.
14:04:14 <fracture_> oh
14:04:18 <monadic_kid> http://blog.lab49.com/archives/2984
14:04:37 <dmwit> fracture_: I think there is some stuff for generic one-hole contexts, but it's a bit tricky to understand.
14:04:52 <dmwit> At least, I never understood it, though I never spent very long trying to. ^_^
14:05:18 <fracture_> hmm
14:05:33 <fracture_> seems potentially overkill for something this simple... let me look around though
14:05:34 <monadic_kid> purely-functional incremental mutation (Zippers): http://blog.lab49.com/archives/2984
14:05:52 <Taejo> @remember monochrom By training and self-selection, programmers can express "how" but not "what", and nevermind "why".
14:05:52 <lambdabot> Done.
14:08:21 <Cale> > map (\(xss,(y:ys):yss) -> xss ++ (0:ys):yss) . liftM2 zip inits (init . tails) . group $ [5,2,2,1]
14:08:23 <lambdabot>   [[[0],[2,2],[1]],[[5],[0,2],[1]],[[5],[2,2],[0]]]
14:08:30 <Absolute0> Is it possible to get a list of all the values of a type?
14:08:42 <Cale> Absolute0: Not in general.
14:08:56 <Absolute0> ie: data x = a | b | c ; listify x -> [a,b,c]
14:09:16 <fracture_> Cale: that looks nicer; a tad hard to understand for me thus far though
14:09:18 <fracture_> lemme think about it
14:09:20 <Cale> Types also cannot be parameters to functions.
14:09:26 <jaredj> Text.Parsec.Char> :t anyChar
14:09:32 * BMeph doesn't understand how someone can call something "simple" that they can't explain
14:09:34 <Cale> Well, perhaps I can make it easier to understand.
14:09:34 <jaredj> aw
14:09:42 <jaredj> > :t anyChar
14:09:43 <lambdabot>   <no location info>: parse error on input `:'
14:09:59 <Absolute0> Cale: so I have to tediously type all the values on my own to achieve that?
14:10:07 <Absolute0> seems very unhaskellish :)
14:10:31 <Philonous> Absolute0: derive Enum, than you can do [FirstCOnstructor .. LastCOnstructor]
14:10:40 <Cale> Absolute0: What should listify (IO ()) return?
14:10:41 <Absolute0> aha
14:10:42 <Absolute0> :)
14:10:45 <mux> is it possible to set the -N RTS flags at runtime these days?
14:10:47 <skorpan> is there any general alias for "return ()"?
14:10:57 <Absolute0> thanks Philonous :)
14:11:11 <Cale> skorpan: alias?
14:11:19 <Zao> pure () ? :)
14:11:22 <monadic_kid> pure () ? not really an alias
14:11:23 <Philonous> mux: I asked that yesterday, and the answer was: unfortunately no, you need to write a wrapper or use hooks from within C
14:11:23 <Cale> skorpan: That's pretty simple as it is :)
14:11:32 <BMeph> Can't do that with Integer, though - which may not be a bad thing. ;)
14:11:34 <dmwit> :t Text.Parsec.Char.anyChar -- jaredj, your syntax was wrong =)
14:11:35 <lambdabot> Couldn't find qualified module.
14:11:43 <mux> Philonous: we need to fix that at some point
14:11:58 <skorpan> Cale: yeah, but i use "trace" in monadic functions a lot, so i have to do e.g. 'trace "hello" $ return ()'
14:12:13 <Philonous> Absolute0: But afaik that only works iff all your constructors are Nullary
14:12:14 <Cale> skorpan: which monad?
14:12:25 <skorpan> Cale: in this case BufferM in Yi :P
14:12:33 <Cale> Isn't that a MonadIO?
14:12:41 <skorpan> probably, let me check
14:12:50 <skorpan> no, it's not :/
14:12:54 <Cale> hmm, okay
14:13:05 <skorpan> what were you thinking?
14:13:10 <Absolute0> How can I list all the possible operators on a typeclass?
14:13:15 <Cale> I was thinking  liftIO (print "hello")
14:13:15 <Absolute0> in ghci
14:13:17 <dmwit> skorpan: You could... you could write "done = return ()".  It wouldn't take that long.
14:13:32 <Cale> Absolute0: You... don't.
14:13:35 <dmwit> trace "hello" done
14:13:38 <skorpan> Cale: i need to use 'trace' though, because otherwise i'll mess the terminal up... yi catches traces and puts them in a file
14:13:48 <Cale> Absolute0: You look at the sourcecode for the typeclass :)
14:13:50 <dmwit> Or even traceMonad x = trace x (return ())
14:13:53 <skorpan> dmwit: yeah, but i was just asking
14:14:03 <Absolute0> Cale nothing like the python dir(Enum) in haskell?
14:14:07 <Cale> skorpan: Oh, weird.
14:14:09 <dmwit> :i Enum
14:14:19 <mux> skorpan: you could maybe add a WriterT to your monad stack and use "tell" instead of "trace"
14:14:23 <Cale> oh, I suppose that does give a definition
14:14:55 <skorpan> Cale: it's pretty cool though, it catches error and undefined as well
14:14:55 <dmwit> (@Absolute0)
14:14:55 <Philonous> Absolute0: If you want to make your type anumerable, just add deriving (Enum) after the type definition, ghc will then figure it out for you
14:15:03 <Cale> :info works
14:15:18 <Absolute0> Philonous: i got that working already :) Just curious what else Enum offers.
14:15:28 <Cale> I don't really use that though. It's usually better just to open up the documentation. :)
14:15:50 <Absolute0> ad hoc documentation ftw! :)
14:15:57 <Cale> Well, it's haddocked.
14:16:10 <lament> hadhoc
14:16:21 <Cale> So at least it'll be accurate, if not very elaborate.
14:16:29 <monochrom> ghci should just write the right program for you and save all the handshaking overhead.
14:17:00 * BMeph pities the fool who tries to "listify" Integer... >;)
14:17:28 <Cale> skorpan: Anyhow, you could define  traceM msg = trace msg (return ())
14:17:29 <dmwit> > let interleave (x:xs) ys = x : interleave ys xs in interleave [0..] [-1, -2..]
14:17:30 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
14:17:32 <Philonous> > [1.. ] BMeph: you mean like that? ^^
14:17:33 <lambdabot>   <no location info>: parse error on input `^^'
14:17:39 <dmwit> Philonous: I win!
14:17:57 <skorpan> Cale: yup, thanks
14:18:10 <BMeph> Philonous: Right - more like what dmwit did. :)
14:18:44 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]) in posRationals
14:18:45 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
14:18:51 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]) in posRationals :: [Rational]
14:18:52 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
14:18:54 <Philonous> In my list, the negative numbers come after all the positive ones. So it is complete, too :)
14:19:17 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]) :: [Rational] in 0 : (posRationals >>= \x -> [x,-x])
14:19:19 <lambdabot>   [0 % 1,1 % 1,(-1) % 1,2 % 1,(-2) % 1,1 % 2,(-1) % 2,3 % 1,(-3) % 1,1 % 3,(-...
14:19:49 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]) :: [Rational]
14:19:50 <lambdabot>  Defined.
14:20:32 <Cale> @let pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
14:20:33 <lambdabot>  Defined.
14:20:48 <BMeph> Philonous: But in your specification, you never mention negatives, so it's only "complete" if we believe hard enough... ;)
14:20:49 <Cale> > map (pyth . (+1)) posRationals
14:20:52 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
14:21:25 <monochrom> listify n = replicate n ()
14:22:20 <Cale> Philonous: Every element of an infinite list has a finite index at which it occurs. Which index in your list is -1 at? :)
14:23:15 <Deewiant> Cale: maxBound + 1
14:23:17 <BMeph> Cale: s/an/a countably/ surely? ;)
14:23:30 <Cale> BMeph: "list" means "countably"
14:23:32 <Philonous> Cale: How do you know that? You have just never seen one with an infinite index.
14:23:54 * wli would just interleave the positives and negatives.
14:23:57 <SamB> Philonous: you can't make such a list out of cons cells
14:24:02 <dmwit> Deewiant: No instance for "Bounded Integer"; Probably fix: declare an instance for Bounded Integer
14:24:04 <monochrom> We define list to be contably infinite.
14:24:09 <BMeph> Cale: That I did not know - thanks! :)
14:24:12 <Deewiant> dmwit: You're clearly using the wrong type
14:24:31 <Deewiant> There seems to be some garbage after "Int"; a typo?
14:24:43 <Cale> Lists are essentially functions from (initial segments of) the natural numbers to some set/type.
14:24:53 <dmwit> Deewiant: No typo, defaulting chooses Integer. ;-)
14:25:22 <Deewiant> dmwit: Your program is buggy, as -Wall will tell you
14:25:57 <dmwit> Anyway, (maxBound + 1 :: Int) isn't a valid index in any list.  So ha!
14:26:00 <dmwit> I win again!
14:26:10 * BMeph wonders if Deewiant compiles with "-Wall -e"...
14:26:17 <Cale> > maxBound :: Integer
14:26:18 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
14:26:19 <lambdabot>    arising...
14:26:27 <Deewiant> BMeph: I don't use -e :-P
14:26:33 <Philonous> SamB: That's true. But you can build a list as a graph where the vertexes are the elements and the edges point from any vertex to all it's predecessors. Than you can concatenate two infinite lists.
14:26:49 <Cale> @let triples = map (pyth . (+1)) posRationals
14:26:51 <lambdabot>  Defined.
14:27:03 <Deewiant> dmwit: That was just pseudocode, of course I meant toInteger (maxBound :: Int) + 1 ;-)
14:27:18 <dmwit> hee hee
14:27:23 <dmwit> Pedantry is Fun!
14:27:26 <Cale> I love that definition of the Pythagorean triples :)
14:27:29 <Deewiant> PiF!
14:27:32 <SamB> Philonous: that sounds a bit inside-out ...
14:27:43 * wli suspects there's a faster way to get Pythagorean triples.
14:27:46 <dmwit> :t toInteger
14:27:47 <lambdabot> forall a. (Integral a) => a -> Integer
14:27:49 <dmwit> :t fromIntegral
14:27:50 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:27:57 <dmwit> Haskell is weird.
14:28:13 <Cale> wli: well, it is pretty fast already
14:28:33 <Philonous> SamB: At least that's how you you concatenate infinite traces
14:28:39 <mux> wli: this page lists many methods and stuff about pythagorean triples: http://www.mcs.surrey.ac.uk/Personal/R.Knott/Pythag/pythag.html
14:28:40 <wli> I think there's some parametrization or some such.
14:28:46 <mux> m,n generators
14:29:08 <Cale> wli: That's what this is doing, is it not?
14:30:56 <Cale> It generates all the rationals greater than 1 and uses them to parametrise an arc on the unit circle via stereographic projection, and then kills off the common denominator to get an integer triple.
14:31:45 <mgee> Hey, just a quick question. How can I add elements of a list to another using the ":" operator and map? I tried: map (flip :myList) mySecondList ...
14:31:57 <wli> Apparently so. I guess it works.
14:32:16 <Cale> mgee: flip :myList is the same as flip : myList
14:32:17 <dmwit> :t (++)
14:32:18 <lambdabot> forall a. [a] -> [a] -> [a]
14:32:28 <skorpan> > let xs = [1, 2, 3] in map (\x -> x:xs) [4, 5, 6]
14:32:28 <dmwit> :t \myList -> flip (:myList)
14:32:30 <lambdabot>   [[4,1,2,3],[5,1,2,3],[6,1,2,3]]
14:32:30 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
14:32:30 <lambdabot>     In the first argument of `flip', namely `(: myList)'
14:32:30 <lambdabot>     In the expression: flip (: myList)
14:32:35 <skorpan> cool :)
14:32:42 <skorpan> not exactly what you wanted i guess
14:33:11 <dmwit> But yeah, you probably just want (++).
14:33:12 <Cale> mgee: Your constraint that we use : and map is a bit strange...
14:34:56 <mgee> skorpan: thx, that should work :)
14:35:12 <Cale> Oh, is that what you actually wanted?
14:35:26 <Phyx-> Hi, anyone else also have the problem that in ghci 6.10.3 you can't paste anymore? it only grabs the first character and not the rest, on windows
14:35:39 <Cale> paste?
14:35:54 <mgee> Cale: mhh. now when i look on the lambdabot post, i think its not... :-/
14:35:55 <Cale> I had no idea that ghci had anything to do with copying/pasting.
14:36:04 <Cale> > [1,2,3] ++ [4,5,6]
14:36:05 <lambdabot>   [1,2,3,4,5,6]
14:36:12 <Cale> mgee: Is that what you want?
14:36:23 <Cale> mgee: map is for doing something to each element of a list
14:36:30 <mgee> really?
14:36:42 <mgee> I thought ++ runs always the length of the longest list
14:37:01 <duaneb> Igloo: I'm the owner of the powerpc jump bug
14:37:04 <Cale> (++) always takes time proportional to the length of its *left* parameter.
14:37:11 <duaneb> how hard might something like this be
14:37:13 <Cale> Er, well, that's not quite true.
14:37:20 <mux> laziness often helps though
14:37:26 <Cale> That assumes that you evaluate the whole thing, yeah.
14:37:38 <mux> so it somehow get "fused" with the code that consumes the list
14:37:44 <Cale> It takes time proportional to the min of the number of elements you look at and the length of the left parameter.
14:38:14 <mgee> Cale: I have always a very short list and a very long list...
14:38:29 <Cale> The short list should go on the left then, if you care about performance.
14:38:38 <Cale> short ++ long
14:38:39 <pejo> mux, I think people will think the intermediate stuff disappears if you say fuse.
14:38:57 <mux> right, this isn't the correct term but I had no idea how else to put it
14:38:59 <mgee> Cale: it is on the left side, but the code is very slow...
14:39:17 <Cale> mgee: There's another approach you can take then
14:39:28 <mgee> Cale: yep. will look into it. thanks anyway :)
14:39:38 <Cale> mgee: Instead of working with lists, you can work with functions which add elements to the beginning of another list
14:39:41 <Phyx-> Cale: maybe or maybe not, but it's only not working in ghci 6.10.3
14:39:50 <Phyx-> works fine in anything else and every other version of ghci
14:39:51 <Cale> mgee: Then, composition of those functions becomes concatenation
14:39:56 <Phyx-> so, i'd say.. it's ghci
14:40:03 <mgee> Cale: I will try that approach now :)
14:40:05 <Cale> mgee: and to get a proper list at the end, you can apply the function to the empty list
14:40:11 <dmwit> mgee: If you have a list of lists, you might just want concat.
14:40:18 <Cale> composition is a constant-time operation
14:40:22 <dmwit> > concat [[1, 3, 5], [2, 4, 6], [3, 7]]
14:40:23 <lambdabot>   [1,3,5,2,4,6,3,7]
14:40:45 <Cale> Phyx-: Doesn't the terminal handle copy/paste?
14:41:22 <Cale> Phyx-: I don't see how it could even be ghci's responsibility... it just outputs characters and reads input from the keyboard.
14:41:34 <Phyx-> Cale: the terminal on itself works fine, and the same terminal + ghci 6.10.1 work aswell, wouldn't that stand to reason that it's something between the interaction of the terminal and ghci?
14:41:36 <pejo> Cale, haskeline handles the terminal
14:41:52 <mux> god bless haskeline
14:41:54 <Cale> pejo: I suppose it does output lots of control characters.
14:42:16 <Cale> Phyx-: The library used to handle line-editing has changed.
14:42:37 <Cale> Phyx-: as in when you press the arrow keys to get previous inputs etc.
14:43:10 <Cale> pejo: But haskeline doesn't even know the mouse exists...
14:43:32 <Cale> (or have any concept of what the current selection is)
14:43:43 <Phyx-> Cale: that works fine, what doesn't, is when i copy for instance some line from somewhere, and paste it to ghci, only the first letter is pasted, on another terminal window, with ghci not running it paste s full line
14:43:44 <Cale> at least, I wouldn't think that it does...
14:44:15 <Cale> Phyx-: Very strange. I'm not on windows, so I'm not sure.
14:44:26 <Cale> I can't try it myself.
14:45:12 <Phyx-> i can record it, one sec
14:45:30 <Cale> Well, I believe you :)
14:46:09 <Cale> I just can't imagine why it would happen. Windows has always had a strange terminal emulator though.
14:47:35 <Phyx-> it's pretty annoying at times, especially when i want to copy a line from my source and test in ghci
14:47:38 <fracture_> Cale: think I got what I wanted (starting from what I grokked in yours)
14:47:45 <Baughn> Assume I've got "unamb x = unsafePerformIO (foo x)"
14:47:47 <fracture_> mapping over a zip (inits foo) (tails foo) is the way to go
14:48:02 <fracture_> (actually I skip the last one of that)
14:48:21 <Baughn> Now, if something throws an exception to the thread running this code, the exception of course kills the thread
14:48:24 <fracture_> map (\(x,y) -> {whatever}) $ init (zip (inits foo) (tails foo))
14:48:44 <Baughn> But what happens if I (for let bar = unamb x) later re-evaluate bar?
14:48:56 <Phyx-> Cale: but mostly, i wanted to know if i was the only one with the problem, but i suppose most people here don't use windows
14:49:05 <Baughn> Or, rather - I happen to know it doesn't work, already. So how do I make it work, re-invoking the IO code?
14:49:23 <Heffalump> Baughn: huh? Do you mean unamb x y = unsafePerformIO ... ?
14:49:38 <Baughn> Heffalump: ..well, yes. I was simplifying a bit
14:51:02 <Phyx-> oh well,i'll test on my other pcs, if it's the same i'll file a bug report
14:51:24 <eivuokko> Phyx, http://trac.haskell.org/haskeline/ticket/80
14:51:49 <eivuokko> Phyx, You are not alone, that is.
14:52:48 <Phyx-> eivuokko: ah ok, and it's known, guess i'll wait it out :( can't go back to 10.1 since they fixed something in 10.3 i needed
14:52:57 <eivuokko> Or .2?
14:53:36 <Phyx-> oh, the bug is only .3? i skipped .2 so i don't know
14:53:59 <eivuokko> Yeah, should be.
14:54:08 <eivuokko> And it does work for me in .2 and Vista.
14:54:18 <Phyx-> ok, cool, i'll go back then to .2
14:54:54 <Phyx-> eivuokko: thanks :)
14:56:06 <Phyx-> brb
14:57:34 <Heffalump> Baughn: ok, so I don't follow your next point. What does for do?
14:57:48 <Heffalump> oh, it's english, never mind
14:58:00 <Heffalump> so why does it matter if you do later re-evaluate bar?
14:58:21 <Heffalump> foo in the definition of unamb is just 'amb', which is referentially transparent as long as the unamb precond is satisfied
14:58:29 <Heffalump> and doesn't do any weird IO observably
14:58:34 <Baughn> Heffalump: The problem is this:
14:58:49 <Baughn> Heffalump: If I say "let a = unamb expensiveOperation undefined"
14:58:58 <Baughn> Heffalump: And then I say "let b = unamb a 42"
14:59:08 <mgee> Cale: I solved it
14:59:26 <Baughn> Heffalump: If I use b, the thread evaluation a will necessarily be killed, to avoid doing the expensive operation.
14:59:27 <Heffalump> you're worried about expensiveOperation being repeated?
14:59:30 <Baughn> No
14:59:37 <Baughn> I'm worried about it /not/ being repeated.
14:59:50 <Baughn> See, if I then later demand the value of a, I get a threadKilled exception.
15:00:15 <mgee> Cale: The solution is somewhat plain... http://rafb.net/p/v8bAA088.html
15:00:16 <Heffalump> Baughn: right, yeah
15:00:26 <Baughn> Heffalump: So I need to work around that, somehow.
15:00:28 <Heffalump> nasty, ask conal about it?
15:00:34 <Baughn> I will, once he's around
15:00:48 <Heffalump> conal, your clever ideas are broken, please fix them, kthxbye ;-)
15:01:01 <EvilTerran> ?src (++)
15:01:01 <lambdabot> []     ++ ys = ys
15:01:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:01:01 <lambdabot> -- OR
15:01:01 <lambdabot> xs ++ ys = foldr (:) ys xs
15:01:04 <Baughn> Heffalump: Well, I've actually got a solution
15:01:08 <Baughn> Heffalump: The problem is, it's broken. ;)
15:01:10 <EvilTerran> mgee, that looks awfully familiar ^
15:01:42 <Baughn> Heffalump: Broken by throwTo not delivering exceptions immediately if a thread blocks, and then unblocks and blocks again in quick succession
15:01:46 <mgee> EvilTerran: I am sure haskell already has such function... please name it ;)
15:02:02 <Baughn> Heffalump: (Which is noted in the documentation as being undesirable, too. Heh. Now I know why.)
15:02:06 <Heffalump> Baughn: the real point is that asynchronous exceptions shouldn't affect a thunk
15:02:10 <EvilTerran> actually, that'd be more like \xs ys -> reverse xs ++ ys, but yours would indeed be more efficient than that. never mind, carry on.
15:02:19 <Heffalump> it feels more like a GHC bug to me than anything else
15:02:39 <fracture_> how would you sort a list in descending order?
15:02:48 <Baughn> Heffalump: You may be right about that. I'll try reporting it.
15:02:49 <Heffalump> fracture_: sortBy (flip compare)
15:02:53 <fracture_> thanks
15:02:57 <mgee> EvilTerran: I tried ++ before and it was too slow
15:03:00 <EvilTerran> > sortBy (flip compare) "abracadabra"
15:03:01 <lambdabot>   "rrdcbbaaaaa"
15:03:52 <Baughn> Heffalump: I've got this long .hs file of increasingly low-level main functions...
15:04:12 <Baughn> Heffalump: Hum. I started off by wanting to play a game. Now I'm filing GHC bug reports.
15:04:38 <Baughn> "Play game -> Write map generator UI -> Learn reactive -> Debug reactive -> Debug unamb -> Debug GHC"
15:04:53 <Heffalump> :-)
15:04:56 <eivuokko> It's dangerous to be a haskeller.
15:05:18 <Heffalump> it actually seems really broken for a to be changed by killing the thread evaluating it
15:05:50 <Heffalump> what does do { let a = somethingExpensive ; let b = a + 0 ; <evaluate b in a thread and kill it part way> ; return a } produce?
15:06:06 <Baughn> Ooh. Let me try.
15:06:31 * Baughn substitutes "unsafePerformIO $ threadDelay 1000000 >> return 42" for "expensive"
15:06:47 <Cale> mgee: That more or less *is* (++) though...
15:06:49 <xoclipse> i'm trying to build GHC 6.10.3 on centos 4..i'm getting this error: Configuring installPackage-1.0...
15:06:49 <xoclipse> cabal-bin: ghc-pkg dump failed
15:06:58 <xoclipse> ghc-pkg runs fine
15:07:06 <Cale> mgee: Except that it reverses the input list :)
15:07:28 <mgee> Cale: I replaced it now with a foldl expression :) but yeah I also wondered why my code is fast and the ++ code is not.
15:07:52 <Cale> mgee: Let's see both versions?
15:08:24 <Cale> In fact, this fastAdd is really slow compared to (++) in one way
15:08:34 <mgee> Cale: I suspect that ++ traverses the whole second list. while my code only traverses the first list completely
15:08:39 <Cale> no
15:08:46 <Cale> (++) doesn't touch the second list at all
15:08:59 <Cale> @src (++)
15:09:00 <lambdabot> []     ++ ys = ys
15:09:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:09:00 <lambdabot> -- OR
15:09:00 <lambdabot> xs ++ ys = foldr (:) ys xs
15:09:06 <Cale> Have a look :)
15:09:20 <Baughn> Heffalump: Well, that works. Hmmph.
15:09:29 <Baughn> Heffalump: Clearly I need a more complex test-case.
15:09:52 <Cale> It simply traverses the first list, outputting elements from it as it goes, until it reaches the end, at which case the result is the second list.
15:10:17 <Cale> > [1..5] ++ [1..]
15:10:18 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
15:10:27 <Cale> > [1..] ++ [1..5]
15:10:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:10:38 <Cale> (here, the second list is never used)
15:10:54 <mgee> Cale: mhh thats really strange
15:11:03 <Cale> @let fastAdd [] gs = gs; fastAdd (h:t) gs = fastAdd t (h:gs)
15:11:04 <lambdabot>  Defined.
15:11:06 <mgee> Cale: I just figured it out
15:11:13 <Cale> > fastAdd [1..5] [1..]
15:11:15 <lambdabot>   [5,4,3,2,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
15:11:17 <Heffalump> Baughn: hmm, so perhaps it's the unsafePerformIO in unamb that's the dubious thing
15:11:22 <Cale> > fastAdd [1..] [1..5]
15:11:27 <lambdabot>   mueval-core: Prelude.read: no parse
15:11:27 <lambdabot>  mueval: ExitFailure 1
15:11:29 <mgee> Obviously I was very stupid... I used the large list as left side...
15:11:29 <Cale> ... slow :)
15:11:38 <EvilTerran> > [1..] ++ undefined
15:11:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:11:59 <Heffalump> hmm, but your example had a similar unsafePerformIO
15:12:08 <Cale> mgee: yes, that would be a problem
15:12:14 <Heffalump> ah, but unamb messes around with MVars.
15:12:51 <Cale> mgee: If you're forced to do that, you should replace each (++) with (.) each small list xs with (xs++) or element x with (x:) and empty lists with id
15:13:09 <Cale> and then apply that function to [] when you're done composing/concatenating
15:13:16 <Baughn> Heffalump: Yep. I'm messing around with them too, now.
15:13:24 <mgee> Cale: you told me before to use the large list on the right side. i thought i did it, but i was wrong. now i corrected it and it works fast with ++. -.-
15:13:35 <mgee> Cale: Thanks for your help
15:13:37 <Cale> okay :)
15:13:41 <Cale> No problem :)
15:13:55 <mgee> Have to go. Bye :)
15:13:59 <Cale> ah okay
15:14:07 <Cale> See you around
15:18:37 <xoclipse> anyone here good with mvars?
15:20:18 <Cale> Sure, what about them?
15:20:29 <xoclipse> okay, so i'm working on a TCP server
15:20:41 <xoclipse> i want to have 2 + n(per client) threads
15:20:51 <xoclipse> one to accept, and one that will give status on the server, info about connected clients, etc,.
15:21:20 <Baughn> Heffalump: I am now scared
15:21:23 <xoclipse> what is the best way for the status thread to access information about each of the clients(which are blocking/looping on their own thread)
15:21:41 <xoclipse> right now I pass each client a state monad with an Mvar of serverstate
15:21:55 <Baughn> Heffalump: Very, very scared. I did "unsafePerformIO $ do myThreadId >>= print; threadDelay 1000000; myThreadId >>= print".
15:22:02 <xoclipse> then when something gets updated in a client, i use modifymvar to update the state
15:22:14 <xoclipse> then in the status thread it reads the mvar and prints out info from each client
15:22:17 <Baughn> Heffalump: Then I forked a thread to evaluate that. Then I killed the thread, and evaluated it in the main thread.
15:22:26 <Baughn> Heffalump: I got exactly two thread IDs printed. They were different.
15:23:09 <Zao> Was this on a bound thread or a regular one?
15:23:31 <Baughn> A regular one, but myThreadId prints the haskell thread id, not OS anything
15:23:43 <Baughn> s/print/gives/
15:25:00 <Baughn> Heffalump: Still. Much as this behavior scares me, I think I can use it.
15:25:11 <xoclipse> Cale: ideas? thoughts?
15:25:49 <Cale> xoclipse: State monad?
15:26:03 <xoclipse> data ClientVars = ClientVars {cHandle :: Handle, cSrvState :: ServerState, cLoggedIn :: Bool, cACV :: AuthClientV}
15:26:03 <xoclipse> type ClientState a = StateT ClientVars IO a
15:26:24 <xoclipse> well, i'm just using that to pass around the client's state
15:27:08 <Cale> xoclipse: So the call to forkIO looks something like  forkIO (runStateT (...) ...)
15:27:14 <xoclipse> yes
15:27:31 <Cale> Do you ever use put?
15:27:44 <xoclipse> liftIO for that
15:27:44 <Cale> er, oh, I see that you might
15:27:46 <xoclipse> rerrr
15:27:47 <xoclipse> sorr
15:27:50 <xoclipse> ret <- runStateT handle_new_client vars
15:28:10 <xoclipse> update_client_vars c = do
15:28:10 <xoclipse> 	modifyMVar_ (sClients (cSrvState c)) (modify_client c)
15:28:35 <xoclipse> that will update a client's vars based on handle
15:29:06 <xoclipse> it works fine
15:29:12 <Cale> I think I have to see more of the code to understand what you're doing though :)
15:29:15 <xoclipse> i'm just wondering if there is a better way to acheive this
15:29:25 <Baughn> @tell conal I've tracked the aforementioned problems to unamb; specifically, how it deals with exceptions. And how unsafePerformIO does it. I can't really describe it like this, but we need to talk about it.
15:29:25 <lambdabot> Consider it noted.
15:39:30 <gwern> Baughn: heh.
15:39:45 <gwern>  'Conal: meet in the parkin garage at 1 am. come alone. tell no one.'
15:40:56 <Saizan__> there was a thread on ghc-users about that problem
15:41:01 <Saizan__> maybe there's a ticket too
15:41:22 <Baughn> Saizan__: I don't think it's actually a problem
15:41:28 <ray> unsafeperformio should only be discussed in parking garages
15:41:39 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5194#a5194 <-- Here, see the code for yourself
15:41:43 <Saizan__> Baughn: well, "behaviour" :)
15:41:59 <Baughn> I've currently got it in a state where it *works*. unsafePerformIO restarting where it left off was the behavior I *wanted*, actually.
15:42:16 <roconnor> dons: oh man 140 comments for my article in the science reddit already
15:42:39 <Baughn> The only real problem is that I need some way to catch exceptions and.. hmm...
15:42:39 <gwern> (I just got the scoop on unsafePerformIO from a dev I call DeepSeq. GHC HQ is rotten to the core; they're going down, man - all the way down)
15:42:54 <gwern> roconnor: science reddit?
15:43:33 <Baughn> Right. The real problem here is that throwTo exceptions are /not/ delivered at the first possible moment.
15:47:27 <p_l> ... VS2010 - "native C++ libraries that use lambda functions" Somehow I didn't expect that
15:48:33 <roconnor> gwern: http://www.reddit.com/r/science/comments/8mus0/do_not_play_the_lottery_unless_you_are_a/
15:50:39 <chromakode> hey folks, is there a preferred way to get multiple case (guard-like functionality) in a do expression?
15:50:58 <chromakode> do you just create a function with guards and call it?
15:52:25 <Baughn> chromakode: Pretty much
15:52:42 <kpreid> chromakode: I don't know of a better way than do x <- a; case x of ...
15:52:55 <EvilTerran> chromakode, you can use a "case ... of ..." directly in a do-expression
15:52:59 <SamB> there's always case () of _ | ...
15:53:09 <chromakode> ah, yes, the guards in the case
15:53:17 <chromakode> that might be prettier
15:53:21 <kpreid> if you're going to call a separate function to do pattern matching then I would consider using a >>= thefunction
15:53:49 <chromakode> ah, good point, but I'll have more than one thing being pulled from a ST array
15:54:17 <chromakode> another question: is there an elegant way to separate my read-only operations so they can be applied lazily?
15:54:32 <chromakode> I have an STArray and a bunch of read only operations on it, and an occasional write
15:55:01 <kpreid> chromakode: The problem there is that you're using a STArray
15:55:06 <chromakode> it seems kind of odd to have to write all of the read-only operations out imperatively in "do" rather than just have it happen lazily
15:55:12 <kpreid> A many-mutable-points structure
15:55:13 <chromakode> kpreid: yeah :(
15:55:20 <kpreid> Are you sure you need that?
15:55:27 <dmwit> Well, there's always freezeArray.
15:55:38 <chromakode> kpreid: pretty sure. I'm in the process of rewriting an IArray implementation to see if I can improve performance.
15:55:48 <chromakode> will freezeArray hurt my performance?
15:56:03 <dmwit> It might.  It's O(n), where n is the length of the array.
15:56:07 <chromakode> it seems like at that point, I'm not doing better than having the IArray
15:56:12 <dmwit> (There's no other way to do it, really.)
15:56:42 <chromakode> that's too bad. I appreciate your insight.
15:57:10 <chromakode> is GHC smart enough to optimize IArray code, or does it just copy everywhere?
15:57:28 <chromakode> would profiling help me tell?
15:58:04 <Baughn> Heffalump: I.. solved my problem. In an insane manner.
15:58:15 <SamB> well, if you have to do several changes in a row, but trying to figure out how to do it with // gives you a headache, freezing can be of use ...
15:58:16 <dmwit> So, uh, pardon my french, but, uh, what's wrong with doing reads in the ST monad?
15:58:31 <SamB> dmwit: it's kind of ugly ...
15:58:43 <dmwit> It's not particularly ugly.
15:58:47 <chromakode> dmwit: well, I had all this nice, lazy code with guards
15:58:49 <dmwit> No worse than doing reads outside the monad.
15:58:54 <chromakode> want an example?
15:59:00 <SamB> dmwit: sure it is!
15:59:08 <dmwit> chromakode: STArrays aren't strict.
15:59:26 <chromakode> that's true.
15:59:30 <dmwit> STUArrays are...
15:59:39 <chromakode> well, that brings up a good point
15:59:49 <SamB> dmwit: if you have an ST array, you need to use the MArray interfaces to read it, and that's not as pretty as using the IArray interface, since you can't stick it in the middle of an expression ...
16:00:00 <dmwit> SamB: ...so?
16:00:06 <chromakode> but if I do a "getElems" or "getAssocs" on an STArray, is it evaled immediately?
16:00:12 <SamB> dmwit: and the names are longer ...
16:00:22 <chromakode> dmwit: it makes my code a lot uglier.
16:01:03 <dmwit> chromakode: No problem, there's this machine that turns ugly code into pretty code.
16:01:11 <chromakode> :)
16:01:15 <dmwit> =)
16:01:27 <chromakode> in this case, I'm feel like a machine turning pretty code into ugly code
16:01:33 <dmwit> (It's a shame it takes so long to run, and is so expensive to own and feed. ;-)
16:02:04 <ray> roconnor: ouch, some of those comments are terrible
16:02:19 <chromakode> yeah, it looks like getElems isn't lazy
16:02:27 <SamB> dmwit: what machine might that be ?
16:02:40 <dmwit> SamB: On here, I call it chromakode.
16:02:57 <chromakode> heh.
16:03:33 <dmwit> getElems isn't lazy?
16:03:42 <dmwit> :t runST
16:03:43 <lambdabot> forall a. (forall s. ST s a) -> a
16:03:44 <roconnor> ray: and my friends ask me why I don't have a comment system for my blog. :)
16:03:52 <dmwit> > runST (newSTRef () >>= readSTRef)
16:03:53 <chromakode> http://www.haskell.org/ghc/dist/current/docs/libraries/array/src/Data-Array-Base.html#getElems
16:03:53 <lambdabot>   ()
16:04:12 <chromakode> I'm pretty new to ST, so I don't know how to interpret it all.
16:04:56 <chromakode> do the reads get executed lazily?
16:05:08 <dmwit> > runST (newListArray (0, 1) [(0, 1), (1, undefined)] >>= getElems >>= return . head)
16:05:09 <lambdabot>   Not in scope: `newListArray'Not in scope: `getElems'
16:05:13 <dmwit> booo
16:05:17 <dmwit> :t ST.newListArray
16:05:19 <lambdabot> Couldn't find qualified module.
16:05:24 <roconnor> ST is like a mini local IO monad where you can only do memory stuff.
16:05:46 <chromakode> so if I do a read in a do expression, that gets done strictly?
16:05:52 <chromakode> or is it lazy too?
16:05:53 <roconnor> most often used for mutable arrays, but an also be used for mutable references.
16:06:12 <skorpan> cons is to (:) as nil is to...?
16:06:14 <skorpan> []?
16:06:22 <Cale> yes
16:06:29 <skorpan> (:) is a constructor, is [] that too+
16:06:33 <Cale> yes
16:06:42 <roconnor> chromakode: essentially all monads have lazy evalutation.
16:06:45 <skorpan> what about (:) makes it a constructor as opposed to a function?
16:06:55 <skorpan> or are constructors a subset of functions?
16:07:05 <chromakode> roconnor: but the hidden state type "s" that gets threaded through -- that doesn't force evaluation?
16:07:11 <Cale> Constructors are those functions which you are allowed to pattern match on.
16:07:24 <Axman6> @src []
16:07:24 <lambdabot> data [] a = [] | a : [a]
16:07:27 <roconnor> chromakode: generally not.
16:07:28 <Axman6> skorpan: ^^
16:07:45 <Cale> The constructors for an algebraic datatype completely determine the set of values which belong to it.
16:07:52 <chromakode> roconnor: mind = blown
16:08:11 <roconnor> chromakode: observe the following State monad:
16:08:20 <Cale> That is, every [a] value is either [] or x:xs for some x and xs.
16:08:32 <dmwit> chromakode: getElems is lazy here:
16:08:37 <skorpan> how come you can pattern match on ["hi"]?
16:08:40 <dmwit> runST (f (0, 1) [1, undefined] >>= getElems >>= return . head)
16:08:40 <dmwit> 1
16:08:48 <skorpan> is it simply syntactic sugar?
16:08:53 <chromakode> dmwit: terrific!
16:08:54 <dmwit> (where f = newListArray with a restricted type)
16:08:58 <roconnor> > runState (do {x <- get put undefined; put 7; y <- get; return (x,y)}) 10
16:08:59 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
16:09:00 <lambdabot>                     (...
16:09:01 <Cale> skorpan: Because that's syntax sugar for (('h':'i':[]):[])
16:09:10 <skorpan> cool
16:09:19 <roconnor> > runState (do {x <- get; put undefined; put 7; y <- get; return (x,y)}) 10
16:09:20 <lambdabot>   ((10,7),7)
16:09:29 <roconnor> ah
16:09:31 <Axman6> ie: hi robot monkey hat wearing monkey
16:09:33 <roconnor> dmwit: nice work
16:09:34 <skorpan> do constructors have higher precedence than other functions?
16:09:44 <chromakode> dmwit: thanks so much!
16:09:45 <Cale> no
16:10:00 <skorpan> i'm learning a lot :)
16:10:10 <Cale> They behave exactly as all other functions do. Precedence is set by infixl/infixr declarations.
16:10:10 <chromakode> dmwit: if it was an STUArray, would getElems be strict?
16:10:20 <dmwit> chromakode: You betcha.
16:10:34 <Cale> (for infix usages)
16:10:34 <Axman6> chromakode: ST is really cool once you figure out what it's for and how to use it. makes imperative programing fun and safe
16:10:35 <chromakode> okay, so I'd have to start worrying about that if I went STU
16:10:36 <dmwit> chromakode: 'U' stands for "strict". ;-)
16:10:36 <erikc> hrm, is it possible to use the ghc api to load a haskell module and interpret it, passing data from the host haskell program in? i cant find any mention of this
16:10:46 <skorpan> is the IO monad written entirely in C with a haskell layer?
16:10:57 <chromakode> dmwit, roconnor: thanks for taking the time to explain this to me
16:11:00 <dons> skorpan: hmm?
16:11:06 <thoughtpolice> skorpan: nope
16:11:07 <dons> ?src IO
16:11:07 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:11:08 <Axman6> g'day dons
16:11:12 <dons> yo Axman6
16:11:17 <skorpan> hm
16:11:18 <thoughtpolice> erikc: yeah
16:11:21 <roconnor> chromakode: we work hard to stamp out misunderstandings of strictness and monads.
16:11:29 <Cale> skorpan: Much of it is written in a sort of hacky low-level way in "Haskell"
16:11:42 <skorpan> Cale: oh, so it is in fact haskell all the way?
16:11:53 <erikc> thoughtpolice: any pointers on where that is in the docs?
16:11:56 <Cale> Depends on what you consider to be Haskell.
16:11:58 <Axman6> probably until you get to system calls skorpan
16:12:05 <dmwit> chromakode: Note that STArrays are nevertheless spine-strict.
16:12:07 <dons> well... s/hacky/low level systems code/
16:12:10 <chromakode> roconnor: your effort will be multiplied when I finally understand it enough to straighten someone else out ;)
16:12:10 <dmwit> So the following does actually puke:
16:12:14 <chromakode> dmwit: spine-strict?
16:12:20 <dons> making unix appear nice is the job of that layer
16:12:23 <dmwit> runST (f (0, 1) (1:undefined) >>= getElems >>= return . head)
16:12:34 <skorpan> @src getElems
16:12:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:12:37 <Cale> dons: I consider the abuse of the (->) type to be not only low-level, but also hacky :)
16:12:39 <skorpan> :t getElems
16:12:40 <lambdabot> Not in scope: `getElems'
16:12:44 <dmwit> chromakode: Yes; in other words, it is strict in the *number* of elements.
16:12:46 <dons> abuse of -> ?
16:12:50 <roconnor> > runST (f (0, 1) (1:undefined) >>= getElems >>= return . head)
16:12:51 <lambdabot>   Not in scope: `getElems'
16:12:52 <dons> in the def of IO?
16:12:53 <thoughtpolice> skorpan: the IO monad really just 'forces' an explicit data depency amongst every single monadic action, so that things happen in the 'right order'
16:12:58 <Cale> dons: Yeah
16:13:08 <skorpan> thoughtpolice: what about unsafeInterleaveIO?
16:13:12 <dons> abuse because of the unlifed RW# kind?
16:13:36 <Cale> Because arbitrary effects are part of the function.
16:13:38 <chromakode> dmwit: isn't that because you instantiate it with size?
16:13:47 <Cale> @src IO
16:13:48 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:13:55 <dons> ah. true enough. the State# is magic
16:14:03 <Cale> Those State# RealWorld values are just tokens.
16:14:08 <dons> where the magic meets the metal
16:14:13 <Cale> The actual effects happen in ->
16:14:20 <dmwit> chromakode: I'm not sure what you mean.
16:14:23 <skorpan> you guys are weird
16:14:27 <dons> right you are. there's no runtime State#
16:14:37 <dons> skorpan: applicatively weird!
16:14:38 <chromakode> dmwit: I wasn't sure what you meant by "strict in the *number* of elements"
16:14:46 <chromakode> skorpan: you'll get used to it
16:14:58 <skorpan> dons: applicatively?  "pure?"  i don't get the joke.
16:15:09 <dmwit> chromakode: Check my example above; I provided a list which became undefined before it had supplied enough elements to fill the array.
16:15:14 <Cale> skorpan: anyway, how I'd *like* to imagine the IO monad working is that on the pure Haskell side of things, it simply *encodes* effects in some fashion
16:15:33 <skorpan> @src putStr
16:15:34 <lambdabot> putStr s  = hPutStr stdout s
16:15:38 <skorpan> @src hPutStr
16:15:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:15:46 <skorpan> is that were the magic meets the metal?
16:15:47 <dmwit> chromakode: So construction of an array actually has to put a thunk in each slot of the array; that thunk isn't evaluated until it's demanded, but the thunk itself has to be defined.
16:15:50 <Cale> skorpan: and then on the low-level, RTS side of things (which may be implemented in C or directly in machine code), you have something which is pattern matching on those structures and carrying out the described effects
16:16:00 <chromakode> dmwit: ah! I see
16:16:06 <Cale> So, the way I like to picture it is something like:
16:16:10 <Cale> data IO a where
16:16:13 <chromakode> spine-strict is a quality of the data representation
16:16:15 <Cale>   ReturnIO :: a -> IO a
16:16:20 <dmwit> chromakode: right
16:16:23 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
16:16:24 <chromakode> thanks!
16:16:29 <Cale>   PutChar :: Char -> IO ()
16:16:34 <Cale>   GetChar :: IO Char
16:16:44 <Cale>   ForkIO :: IO () -> IO ThreadId
16:16:46 <dons> is Swiert's pure IO on hackage?
16:16:49 <Cale>   ..etc..
16:16:51 <dons> the IO GADT et al?
16:17:01 <dons> ah, IOSpec?
16:17:28 <Cale> skorpan: Then the RTS will evaluate the IO value called main until it determines what the top-level constructor is, (pattern matching it)
16:17:46 <Cale> skorpan: and then if it's a primitive, it carries out the described action
16:18:05 <Cale> skorpan: If instead, it's something like BindIO x f, it calls itself recursively.
16:18:38 <Cale> Like, if the RTS were also written in Haskell, it would look like:
16:18:47 <dons> the 2009 IO backlash is cool
16:18:51 <dons> i blame conal.
16:18:54 <dons> fermenting dissent
16:18:56 <Cale> exec (BindIO x f) = do v <- exec x; exec (f v)
16:19:06 <roconnor> IO backlash?
16:19:41 <skorpan> a friend of mine has written a cool little library for splay trees and i suggested that he names it Splarray...  good, yes?
16:19:46 <dons> there's just a /lot/ of talk on the intertubes about the problems and nature of how IO is done. It's interesting: the IO monad is clearly not a settled story
16:19:59 <Cale> skorpan: Why not SplayTree ? :)
16:20:06 <skorpan> Cale: because that's boring!
16:20:10 <dons> i think the introduction of Applicative and the revival of pure FRP has helped
16:20:16 * Axman6 likes Splats
16:20:17 <erikc> hrm...i dunno if the ghc api is the right route, what im looking for is a way to replace functions at runtime (the type of the function remains the same)
16:20:31 <skorpan> Cale: the cool thing about it is that you can apparently "index" it efficiently
16:20:45 <skorpan> hence, splarray!
16:20:48 <Cale> I have a feeling, though an uncertain one, that the IO monad will still be necessary for a long time.
16:21:23 <chromakode> hey Gracenotes
16:21:29 <dons> I don't see any replacement on the horizon.
16:21:31 <Axman6> Cale: how many programs don't need any IO at all?
16:21:32 <chromakode> dons: what is the 2009 IO backslash?
16:21:59 <dons> chromakode: just the revisting of design decisions in the implementation of IO
16:22:04 <Cale> The trouble with all the other nicer approaches so far is that they seem much less extensible in terms of primitive inputs and outputs.
16:22:16 <roconnor> I\O <- the IO backslash
16:22:20 <chromakode> dons: ah, thanks.
16:22:23 <Cale> Well, you end up implementing those new things in IO.
16:22:33 <Cale> Which is somewhat embarrassing isn't it? :)
16:22:35 <chromakode> Input *or* Output?
16:22:55 <SamB> Cale: that's the usual way of doing prototyping isn't it ?
16:22:57 * Gracenotes waves at chromakode
16:22:59 <roconnor> chromakode: you are the one who started with the blackslash comment.
16:23:00 <dmwit> chromakode: Wait until you hear about the crazy people advocating OI. ;-)
16:23:01 <roconnor> :)
16:23:09 <Gracenotes> roconnor: eek :o
16:23:14 <dons> and there's been a push to further stratify effects
16:23:17 <dmwit> OI is a comonad!  WOOOO
16:23:29 <chromakode> I can see why that would be a godo thing
16:23:30 <chromakode> *good
16:23:33 <Gracenotes> I've always wondered, what would an OI program that asks for you name and prints it looks like?
16:23:37 <dons> i.e. the total pure subculture, then layering non-termination, and partiality on top
16:23:39 <Gracenotes> *your
16:23:42 <Cale> SamB: But it seems impossible for them to reach the point where they are completely independent of the need to do so. Perhaps I'm wrong about that, but it seems like it to me.
16:23:42 <thoughtpolice> skorpan: not sure about unsafeInterleaveIO
16:23:44 <thoughtpolice> skorpan: hold on
16:23:54 <SamB> Cale: now that's a better complaint!
16:23:56 <chromakode> dons: I think we saw some of that in the ICFP Workshop in Portland, eh?
16:24:04 <dons> i think a lot of the effect stratification has been driven by Agda and Epigram leakage
16:24:06 <thoughtpolice> skorpan: http://www.haskell.org/haskellwiki/IO_inside
16:24:11 <thoughtpolice> skorpan: that has a ton of useful info
16:24:18 <dons> chromakode: right!
16:24:24 <thoughtpolice> erikc: look up 'hint' on package - that's the easy way
16:24:32 <dons> Daan's talk is exactly that. revisiting the mtl 10 years on
16:24:37 <thoughtpolice> erikc: plugins is also an alternative which works with GHC 6.10
16:24:41 <Gracenotes> a basic OI program? anyone?
16:24:47 <Gracenotes> oi.
16:24:59 <dons> did comonadic IO ever make it on to hackage?
16:25:05 <erikc> thoughtpolice: i did, i cant find a way to pass a value from the host program to the interpreted one with hint
16:27:06 <pumpkin> dolio: I got shot down!
16:27:26 <thoughtpolice> erikc: what about plugins?
16:27:36 <pumpkin> omg it's thoughtpolice
16:27:43 <thoughtpolice> erikc: it's pretty much in maintenance mode only, but it still works wonderfully
16:27:53 <pumpkin> I thought the registered 64-bit build gods had asked for your heart as a sacrifice
16:28:05 <thoughtpolice> especially considering the GHC API only allows you to use/retrieve polymorphic functions if you use unsafeCoerce#
16:28:39 <thoughtpolice> which is a problem I ran into back when I was writing one of my first haskell libraries; a GHC API wrapper that I wanted to have similar capabilities to, say, hint
16:29:02 <thoughtpolice> my package faded into unmaintenance and obsoleteness (ghc 6.6 only,) and it wasn't written all too awesome
16:29:05 <thoughtpolice> but it's still on hackage
16:29:32 <erikc> k, plugins built ok on mac, will try it out there, was having problems building it on win64
16:29:33 <thoughtpolice> erikc: afaik, you can still retrieve polymorphic functions with the GHC API etc as long as you use unsafeCoerce#
16:29:47 <erikc> i guess its just win32 really
16:30:37 <erikc> oh...so you mean, you interpret the eval of the function name and unsafe it coerce it back out to the host, then you apply it?
16:30:49 <thoughtpolice> erikc: right
16:30:54 <erikc> that makes too much sense <smacks self>
16:30:59 <thoughtpolice> erikc: the GHC API also provides a version that is protected with Data.Dynamic
16:31:05 <thoughtpolice> erikc: but that only allows monomorphic values
16:32:24 <erikc> and the function can outlive the interpreter session that created it?
16:36:18 <QtPlaty[HireMe]> Is there an easy way to embed text in a haskell program?
16:36:34 <erikc> quasiquote
16:36:51 <thoughtpolice> erikc: i believe so
16:37:02 <Gracenotes> hm, I've gotten an internal GHC error
16:37:05 <skorpan> is "data A" equal to "data A = A"?
16:37:06 <thoughtpolice> erikc: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/HscMain.html#v%3AcompileExpr
16:37:09 <Gracenotes> but they do call it unsafeCoerce for a reason
16:37:22 <Gracenotes> "internal error: ARR_WORDS object entered!"
16:37:41 <thoughtpolice> erikc: that will give you back an HValue you can unsafeCoerce#, e.g. let (x :: a -> b -> Int) = unsafeCoerce# hval
16:37:54 <EvilTerran> skorpan, no, "data A" has no constructors, so the only inhabitant is _|_
16:38:05 <EvilTerran> skorpan, while "data A = A" has the inhabitants {A, _|_}
16:38:14 <pumpkin> anyone know what the status of http://www.nabble.com/Microsoft-PhD-Scholarship-at-Strathclyde-td22437467.html is?
16:38:17 <pumpkin> did someone take the position?
16:38:17 <thoughtpolice> skorpan: 'data A' is an extension allowing empty data declarations
16:38:48 <pumpkin> thoughtpolice: made any progress with the registered build?
16:40:20 <Cale> QtPlaty[HireMe]: To be honest, if I have to embed text, I usually use unlines or concat along with a list of the lines.
16:41:02 <QtPlaty[HireMe]> Sure
16:41:06 <Cale> Some people seem unhappy with that though...
16:41:16 <thoughtpolice> pumpkin: did you see #ghc backlog when I was talking to Igloo?
16:41:33 <pumpkin> thoughtpolice: yeah, you have it building but it crashes due to weird RTS issues?
16:41:47 <thoughtpolice> pumpkin: well, the unregistered build works fine and generates working executables
16:41:53 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/interpolatedstring-qq -- there are packages like this
16:42:08 <pumpkin> thoughtpolice: yeah, I mean the stage 2
16:42:55 <Cale> and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Interpolation which does a different style of the same thing
16:44:04 <thoughtpolice> pumpkin: so, the registered stage1 compiler does work, but when it compiles programs, things immediately segfault in the RTS
16:44:14 <thoughtpolice> pumpkin: so, the stage2 compiler just segfaults no matter what
16:44:15 <pumpkin> I see
16:44:24 <pumpkin> have you looked where in the RTS?
16:44:43 <thoughtpolice> pumpkin: yes, and it's very lucky
16:44:52 <thoughtpolice> the RTS doesn't even call out to haskell before the crash
16:44:56 <thoughtpolice> so it's basically still initializing things
16:44:57 <pumpkin> ah :)
16:45:02 <thoughtpolice> so I get full stack traces, debugging etc.
16:45:03 <pumpkin> where is it?
16:45:33 <pumpkin> probably an incorrect offset into one of the internal structures due to some fields being of different sizes now?
16:45:47 <thoughtpolice> removeIndirections called by lookupStableName_
16:45:57 <thoughtpolice> pumpkin: potentially
16:47:08 <thoughtpolice> pumpkin: I have some RTS gdb functions that may help, and luckily I can simply build executables (like 'hello world') with the stage1 compiler and just pass -debug to the compiler so the executable gets linked with a debug version of the RTS
16:47:19 <pumpkin> ah :)
16:47:32 <pumpkin> so with the debug version of the RTS, you can actually tell what line it crashes on?
16:47:37 <pumpkin> that function is pretty small
16:47:47 <thoughtpolice> pumpkin: and I think I can kind of narrow down why it might be happening, at least a little anyway
16:47:50 <thoughtpolice> pumpkin: yes
16:47:51 <thoughtpolice> and yes
16:48:14 <Gracenotes> hm. It seems Integer is not really that infinite...
16:48:21 <pumpkin> Gracenotes: ?
16:48:29 <Gracenotes> it has a limit of 2^(2^x), where x is somewhat in the mid-thirties, can't figure out exactly where
16:48:32 <Gracenotes> *where
16:48:45 <pumpkin> 37 probably on a 64-bit arch
16:48:55 <Gracenotes> it's about 36 here
16:48:58 <SamB> Gracenotes: *mid* thirties ?
16:49:00 <Gracenotes> on 32-bit
16:49:09 <dcoutts> @seen blackh
16:49:10 <lambdabot> blackh is in #haskell. I don't know when blackh last spoke.
16:49:11 <pumpkin> "Support at the mpn and mpz levels for operands of up to 250 bits (on 64-bit machines). Current limits are: on 32-bit machines, 231 bits; on 64-bit machines, 237 bits."
16:49:15 <SamB> oh, right, more than one bit per byte ...
16:49:22 <Gracenotes> yes. 4 :)
16:49:23 <pumpkin> that's 2^31
16:49:26 <pumpkin> not 331
16:49:27 <pumpkin> 231
16:49:29 <Gracenotes> or, wait, no. silly me.
16:49:33 <pumpkin> http://gmplib.org/#DOC
16:49:46 <Gracenotes> but I mean Haskell's Integer type
16:49:50 <pumpkin> that's GMP
16:49:54 <Gracenotes> were you talking about GMP? ah.
16:50:22 <Gracenotes> but anyway, Haskell has a byte array as you know, and the length is set by an Int
16:50:43 <Gracenotes> just doing let (I# i) = 100; (J# _ b) = 4832948340129348 in J# i b, you can read lots of memory :)
16:50:50 <pumpkin> lol
16:50:53 <thoughtpolice> pumpkin: because, first I built the unregistered x86_64 compiler, which doesn't have the NCG - it only emits code via C. so, the stage1 registered compiler is built with it and compiled to C, then linked. well, the registered stage1 compiler has the native code generator, and when *it* compiles executables, even though the RTSs are no different (between the unregistered compiler and registered stage1), the generated executables segfault
16:51:07 <SamB> so 2^(8*31), then ?
16:51:45 <pumpkin> SamB: why *8?
16:51:57 <SamB> pumpkin: 8 bits in a byte ?
16:52:00 <thoughtpolice> pumpkin: this means there is likely some discrepancy between the RTS and x86_64, which is, again, likely a biproduct of the fact that it doesn't quite handle the x86_64/darwin combo
16:52:09 <pumpkin> SamB: it doesn't mention bytes anywhere though
16:52:39 <pumpkin> thoughtpolice: yeah, makes sense
16:52:43 <SamB> pumpkin: that's what the Haskell type can handle, I mean
16:52:59 <SamB> on 32-bit, anyway
16:53:05 <pumpkin> SamB: oh, yeah... but doesn't help much if GMP barfs sooner
16:53:32 <thoughtpolice> pumpkin: anyway, at least I get full stack traces
16:53:35 <pumpkin> :)
16:53:46 <SamB> if you manage to keep 2 gigs of the proccess address space free for the Integer, anyway ;-P
16:53:53 <pumpkin> :)
16:53:53 <Gracenotes> iirc, it uses Int indexing of byte arrays. guessing the internals is a bit tricky
16:54:00 <thoughtpolice> I have also come to the conclusion that there are 0 good gdb frontends out there that work on a mac
16:54:01 <Gracenotes> of course I could look at the source
16:54:05 <thoughtpolice> aside from cgdb
16:54:11 <thoughtpolice> which doesn't even compile; i had to grab a universal bindist
16:54:16 <thoughtpolice> :/
16:54:21 <pumpkin> Gracenotes: how do you mean indexing? it just treats the byte arrays as an opaque chunk of memory and hands them to gmp
16:54:22 <SamB> thoughtpolice: emacs doesn't work on a mac?
16:54:32 <Gracenotes> pumpkin: I'm not.. talking about gmp. still.
16:54:42 <thoughtpolice> SamB: never really used emacs' gdb facilities
16:54:47 <pumpkin> Gracenotes: o.O
16:54:54 <pumpkin> thoughtpolice: if you can construct an xcode project around it you can use xcode for gdb frontend :P
16:55:05 <pumpkin> Gracenotes: so what are you talking about?
16:55:13 <thoughtpolice> pumpkin: yeah, tried that already, not sure if it's worth the hassle :)
16:55:26 <thoughtpolice> SamB: how good are they?
16:55:31 <Gracenotes> pumpkin: Haskell primitives. I'm trying out various functions, like indexIntArray b (I# i) = I# (indexIntArray# b i), seeInteger (J# i b) = map (indexIntArray b) [0..I# i], etc.
16:55:49 <Gracenotes> looking under the hood
16:55:54 <pumpkin> Gracenotes: oh :) yeah, I see
16:56:07 <pumpkin> Gracenotes: I was just getting my hands dirty in the primop cmm last night
16:56:16 <SamB> thoughtpolice: not good enough that I bother with them when debugging GDB itself
16:56:21 <Gracenotes> cmm :?
16:56:26 <pumpkin> c--, ghc style
16:56:33 <Gracenotes> oic.
16:56:45 <pumpkin> rts/PrimOps.cmm
16:56:49 <Gracenotes> :o
16:56:51 <SamB> but of course when you do that you tend to re-invoke GDB a lot
16:56:52 <pumpkin> is where most of the out of line ones live
16:57:21 <Gracenotes> that does look pretty dirty
16:57:39 <Gracenotes> newMutVarzh_fast .. delicious
16:57:43 <pumpkin> yeah :P
16:57:46 <thoughtpolice> just zencoding
16:57:48 <pumpkin> where zh is the Z-encoded #
16:57:54 <Gracenotes> does that make a new fast Chinese mutable var? >_>
16:57:58 <pumpkin> newMutVar# is what that corresponds to
16:58:16 <pumpkin> the _fast suffix is identifying what kind of symbol that is
16:58:29 <pumpkin> it's not making a statement about its efficiency :P
16:58:58 <Gracenotes> is the code hand-written? or is it generated..?
16:59:04 <Gracenotes> hm. looks hand-written
16:59:08 <pumpkin> a lot of it is hand written
16:59:12 <pumpkin> there are some macros for repetitive ones
16:59:21 <thoughtpolice> cpp is awesome!
16:59:33 <thoughtpolice> pumpkin: actually I speculate the CPP is responsible for a problem like this, one way or another
16:59:37 <pumpkin> all the primops I added last night were handwritten
16:59:39 <pumpkin> could be
16:59:51 <thoughtpolice> really it can lead to such problems :(
16:59:59 <Gracenotes> any other interesting cmm files to browse?
17:00:13 <thoughtpolice> especially when you're dealing with 50,000 loc of both C and c--
17:00:15 <pumpkin> take a look at the other .cmm files in the rts
17:00:28 <thoughtpolice> well, really, a lot more than that
17:00:42 <Gracenotes> can't find many others
17:00:44 <Gracenotes> most are .c
17:00:44 <SamB> thoughtpolice: such problems as what ?
17:01:17 <pumpkin> Gracenotes: there aren't that many
17:01:47 <thoughtpolice> SamB: well,
17:01:49 <pumpkin> Gracenotes: a lot of the cmm is generated on the fly
17:01:55 <thoughtpolice> for example, just the other day I fixed a bug in GHC
17:02:07 <thoughtpolice> which lead to compilation failure when trying to do a registered x86_64/darwin build
17:02:13 <Gracenotes> it's definitely ugly
17:02:20 <thoughtpolice> because the case for x86_64 and darwin was silently ignored
17:02:23 <pumpkin> Gracenotes: prettier than raw asm though :)
17:02:25 <thoughtpolice> because it's never actually been properly tested
17:02:28 <SamB> thoughtpolice: ah.
17:02:39 <Gracenotes> well. still. the capitalization..
17:03:15 * SamB wishes there were better tools for testing buildability on multiple platforms, but of course in this case GHC'd have to be way easier to port ...
17:03:22 <Gracenotes> so. what primop stuff were you doing?
17:03:25 <thoughtpolice> SamB: CPP was the culprit; in ./compiler/cmm/CParse.hs:pprDynamicLinkerAsmLabel
17:03:42 <skorpan> could someone help me remove the boilerplate here?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5197#a5197
17:03:51 <SamB> or staticly checking things like that, even ...
17:04:09 <thoughtpolice> SamB: wolfgang t. added that case to that function nearly 2 years ago, but GHC has never really 'properly' worked on x86_64/darwin, so it was always pretty much silently ignored
17:04:41 <pumpkin> Gracenotes: adding a bunch more primops for the gmp integer interface, for Integer... but it turns out we're just about to separate gmp out of GHC so it was kinda pointless... but I might help out with the separation efforts now that I got myself interested in this stuff
17:04:47 <thoughtpolice> pumpkin: did that particular bug bite you when e.g. a registered stage1 was trying to compile stuff? because a registered stage1 has the NCG
17:05:11 <thoughtpolice> pumpkin: and that function seems fairly specific to the NCG, which would explain why it didn't show up in the unregistered build
17:05:14 <pumpkin> Gracenotes: I can now compute factorial of 50000 in 2.3 seconds using a primop instead of the 17 seconds it takes using the native haskell factorial :P
17:05:21 <Gracenotes> pumpkin: well, you must blag about it
17:05:39 <Gracenotes> so, what does the separation entail? Using a homebrew number library?
17:05:49 <pumpkin> Gracenotes: one day I'll get around to making a site of my own with a bloggish thing on it
17:06:05 <thoughtpolice> pumpkin: oh, on the replacing gmp note in #ghc, igloo has an integer library that is written mostly in haskell with decent performance
17:06:18 <pumpkin> Gracenotes: there are a few proposals... either making another library that's binary compatible with the subset of gmp that we use, or using igloo's replacement pure haskell lib
17:06:21 <thoughtpolice> pumpkin: http://darcs.haskell.org/packages/integer-simple/
17:06:21 <pumpkin> thoughtpolice: yeah, saw that :)
17:06:26 <pumpkin> there's also a super simple one :P
17:06:28 <pumpkin> that's slower
17:06:46 <thoughtpolice> pumpkin: we used HIntegerByInt in lhc-0.6.*
17:06:53 <Gracenotes> making a library for the purpose of binary compatibility? Sounds painful >_>
17:07:04 <Gracenotes> pumpkin: so you used gmp's factorial function directly?
17:07:08 <thoughtpolice> pumpkin: which does have pretty decent performance
17:07:08 <pumpkin> yeah
17:07:17 <thoughtpolice> pumpkin: having LHC use ghc as a frontend now is so much more better. :)
17:07:22 <Gracenotes> presumably the Integer constructors are based directly on it?
17:08:19 <pumpkin> Gracenotes: yeah, the J# constructor gets broken up and passed almost directly to gmp
17:08:27 <pumpkin> thoughtpolice: I bet
17:08:36 <hatds> skorpan: I think records are ugly as a rule but this does what you want:  data  Statement = FunDecl  { tokens :: [Token]  } | VarDecl { tokens :: [Token] } | etc..
17:08:38 <pumpkin> thoughtpolice: there was a good looking integer library on a .gov site but I forgot its name now
17:08:41 <Gracenotes> yes, with (,)
17:08:48 <pumpkin> I'd personally love to make the integer-simple ridiculously fast
17:08:49 <pumpkin> :P
17:09:12 <pumpkin> that seems like the most elegant solution
17:09:15 <skorpan> yeah hatds, but as you said that's horribly ugly...  however, i think i can solve this by deriving Foldable for each datatype and then making "firstTok x = head $ toList x"
17:09:51 <pumpkin> Gracenotes: you can see the semi-front-end functions to gmp in GHC.Integer
17:10:02 <Gracenotes> well, GHC.Prim
17:10:14 <pumpkin> well, those are direct representations of the cmm code
17:10:28 <pumpkin> GHC.Integer acts as the middleman between the S# | J# representation and the cmm
17:10:32 <Gracenotes> Integer contains the primitive wrappers
17:10:48 <Gracenotes> so, is there a way to make a really-really-fast factorial other than having an explicit low-level function?
17:10:50 <Gracenotes> :)
17:11:19 <pumpkin> well the issue is that we're constructing and deconstructing gmp ints all over the place when we work with them in haskell
17:11:21 <hatds> factorial function of what type?
17:11:27 <hatds> Int -> Int ?
17:11:29 <dmwit> factorial :: () -> ()
17:11:30 <pumpkin> Int -> Integer
17:11:44 <pumpkin> not much point in doing Integer -> Integer
17:11:50 <hatds> hehe
17:11:55 <Gracenotes> Int -> Integer, Integer -> Integer if you like >_>
17:12:39 <dmwit> Can you just use one of the approximations?
17:12:43 <dmwit> They're really quite fast.
17:12:48 <dmwit> And very accurate.
17:13:07 <dmwit> http://en.wikipedia.org/wiki/Stirling%27s_approximation
17:13:22 <Gracenotes> yes, I'm trying to see how big a maxBound factorial would be right now
17:13:31 <Gracenotes> exponentiation would be the most expensive part here
17:13:38 <idnar> factorial :: Void
17:13:55 <dmwit> > (2^29 :: Int)
17:13:56 <lambdabot>   536870912
17:14:14 <dmwit> > fromIntegral (2^29 :: Int) / exp 1
17:14:15 <lambdabot>   1.975037710877626e8
17:14:20 <dmwit> :t (**)
17:14:21 <lambdabot> forall a. (Floating a) => a -> a -> a
17:14:26 <thoughtpolice> pumpkin: with the new lhc, compiling the entire HIntegerByInt external core code generated by GHC (the .hs is ~2,500, the .hcr is ~17,000), takes 30s to complete compilation to GRIN, and according to GHC's RTS "44 MB total memory in use"
17:14:38 <dmwit> > (fromIntegral (2^29 :: Int) / exp 1) ** (2^29)
17:14:39 <lambdabot>   Infinity
17:14:41 <Gracenotes> ^^ would be better
17:14:47 <thoughtpolice> pumpkin: (resulting grin is about ~27kloc)
17:15:03 <dmwit> > ln
17:15:04 <lambdabot>   Not in scope: `ln'
17:15:07 <dmwit> > log (exp 1)
17:15:08 <lambdabot>   1.0
17:15:13 <thoughtpolice> pumpkin: this is opposed to taking 5 minutes while using up 600mb of memory on the same exact code :)
17:15:18 <pumpkin> nice :P
17:15:20 <pumpkin> how fast is it?
17:15:22 <pumpkin> the resulting code
17:15:30 <thoughtpolice> pumpkin: oh, which generated not working executables for that test on certain inputs
17:15:36 <thoughtpolice> it was still a bug
17:15:40 <thoughtpolice> pumpkin: it passes the testsuite now
17:15:42 <thoughtpolice> but it's quite slow
17:15:48 <thoughtpolice> we haven't implemented a backend quite yet
17:15:50 <dmwit> > 2^29 * (log (sqrt (2 * pi * 2^29)) + log (2^29 / exp 1))
17:15:50 <Gracenotes> @hoogle CReal
17:15:50 <lambdabot> No results found
17:15:51 <lambdabot>   1.6144159771912458e10
17:16:05 <dmwit> Gracenotes: Looks like it would have about 1.6e10 digits!
17:16:09 <dmwit> That's largish.
17:16:13 <dmwit> err
17:16:15 <thoughtpolice> lemmih is working on a second stage of grin, kind of like jhc's 'devolved form' (right before turning it to C) which should be easy to compile to LLVM
17:16:23 <dmwit> > 2^29 * (logBase 10 (sqrt (2 * pi * 2^29)) + logBase 10 (2^29 / exp 1))
17:16:24 <lambdabot>   7.01131950390604e9
17:16:34 <dmwit> Oh, well!  Only 7e9 digits!  Much better.
17:16:36 <thoughtpolice> i'm working on a dead code removal pass for GRIN/grin2
17:16:49 <Gracenotes> how about logBase 2?
17:16:50 <thoughtpolice> because that 27kloc of grin probably isn't all necessary
17:17:01 <dmwit> > 2^29 * (logBase 2 (sqrt (2 * pi * 2^29)) + logBase 2 (2^29 / exp 1))
17:17:02 <lambdabot>   2.3291099242257202e10
17:17:09 <Gracenotes> wha
17:17:17 <Gracenotes> *is suspicious*
17:17:22 <dmwit> Why?
17:17:27 <dmwit> That's the number of *digits* remember.
17:17:29 <Gracenotes> oh, missed the e
17:17:31 <dmwit> Not the actual answer.
17:17:50 <Gracenotes> darn notation. don't know why Haskell uses it >_<
17:17:56 <dmwit> > 2^29 * ((+) `on` logBase 2) (sqrt (2 * pi * 2^29)) (2^29 / exp 1)
17:17:57 <lambdabot>   2.3291099242257202e10
17:18:01 <thoughtpolice> pumpkin: the llvm bindings are annoying on my os x box, so I'm actually thinking about just pretty-printing LLVM-ir directly
17:18:16 <Gracenotes> dmwit: so an Integer could store it
17:18:19 <thoughtpolice> it would probably make it easier to use what garbage collection facilities are there, anyway
17:18:35 <Gracenotes> on a 32-bit machine, at least
17:18:50 <dmwit> uh
17:18:56 <MyCatVerbs> Gracenotes: please do not be assuming that all the world is a VAX.
17:19:10 <Gracenotes> hm. or... could it
17:19:15 <Gracenotes> 64-bit definitely
17:19:15 <dmwit> > 2.3e10 / (4 {- gigabytes -} * 1024 * 1024 * 1024 * 8)
17:19:17 <lambdabot>   0.6693881005048752
17:19:18 <MyCatVerbs> Gracenotes: but an Integer can store any arbitrarily large number. ^^
17:19:27 <Gracenotes> MyCatVerbs: not raly ;_;
17:19:28 <SamB> thoughtpolice: yeah, I think dead code removal is a pretty important transformation for grin ...
17:19:31 <dmwit> You think you can get 0.7 actual bits per physical bit?
17:19:34 <dmwit> I'd be really surprised.
17:20:11 <SamB> dmwit: huh ?
17:20:19 <dmwit> Did I say that wrong?
17:20:38 <SamB> dmwit: no, I just don't understand ...
17:20:48 <dmwit> The number takes 2.3e10 bits to store in an ideal world, and you have somewhere around 3e10 actual bits on the machine.
17:20:53 <dmwit> Do you really think you can make that fit?
17:20:58 <dmwit> Integer has a lot of overhead!
17:21:09 <thoughtpolice> SamB: we already have a dead code removal pass for SimpleCore, so we don't create any more GRIN than necessary
17:21:10 <MyCatVerbs> 1.6e10 is only about 15 gigabytes. :)
17:21:29 <thoughtpolice> because the convesion is fairly expensive
17:21:29 <MyCatVerbs> Er, 15 gigabytes long, assuming a compact binary representation.
17:21:35 <Gracenotes> I mean, assuming enough memory. An Integer is just a byte array, and the maximum length is the maximum size of Int# on a machine. However, I'm still not sure whether it's used a byte array or an int array
17:21:35 <idnar> dmwit: why does integer have so much overhead?
17:21:42 <Gracenotes> argh.
17:21:49 <SamB> dmwit: sure, if you use a filesystem with extents ...
17:21:55 <thoughtpolice> SamB: lemmih has just added sharing analysis to the points-to analysis so after that it should be good to remove a lot of stuff
17:21:56 <SamB> and a large enough block size
17:22:05 <Gracenotes> it doesn't help that ByteArray# is the generic Haskell unboxed array for all unboxed sizes
17:22:09 <thoughtpolice> we'll also want to interleave it after other optimizations naturally
17:22:11 <dmwit> idnar: The way I understand it, it's basically a linked list of Ints.
17:22:12 <MyCatVerbs> Gracenotes: surely you can come up with 16GB of RAM if you try really, really hard? :3
17:22:26 <Gracenotes> @src Integer
17:22:26 <lambdabot> data Integer = S# Int#
17:22:27 <lambdabot>              | J# Int# ByteArray#
17:22:29 <idnar> dmwit: I thought it was an array of Ints
17:22:37 <idnar> oh
17:22:40 <SamB> or, yeah, if you're using a swap partition that should be good
17:22:42 <idnar> of Bytes, I guess
17:22:46 <dmwit> Yes, it does seem to be an array.
17:22:51 <Gracenotes> idnar: but that's where it gets confusing
17:22:51 <dmwit> Therefore, I am very wrong.
17:23:14 <Gracenotes> because ByteArrays can be used to store ints, bytes, chars, etc.
17:23:28 <Gracenotes> and I'm not sure about the indexing system it uses, the number of bits per entry
17:23:30 <SamB> but the real question, IMO, is can you figure out how to COMPUTE the value with that little storage?
17:24:04 <Gracenotes> MyCatVerbs: *tries really hard*
17:24:09 <Gracenotes> :3
17:26:55 <skorpan> how can i make this prettier? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5198#a5198
17:27:02 <skorpan> without existentials
17:27:08 <MyCatVerbs> Gracenotes: Hell, 32GB of DDR3-2000 DIMMs should only cost about... $1350, if you're buying 4GB sticks. :)
17:27:39 <MyCatVerbs> Gracenotes: of course you would probably want 48GB instead, to have enough RAM to add three of those numbers together. ;D
17:27:59 <MyCatVerbs> skorpan: Maybe monad, probably.
17:28:17 <skorpan> i thought about that as well, but how?
17:28:29 <skorpan> this isn't Just a or Nothing, this is just True or False
17:28:41 <MyCatVerbs> guard
17:28:43 <Cale> skorpan: How about logic operators?
17:28:56 <sclv> skorpan: are the error messages all difft?
17:29:05 <Cale> if hasFailed blk || hasFailed c || hasFailed x
17:29:08 <Cale>    then error
17:29:10 <skorpan> sclv: "error" is not Prelude.error
17:29:13 <Cale>   else whatever
17:29:16 <Cale> er oops
17:29:21 <Cale> anyway, you get the idea
17:29:23 <skorpan> Cale: oh.. uhm.. :P
17:29:27 <sclv>  | failureOne = error a | failureTwo = error b | otherwise = passing case!
17:29:46 <skorpan> sometimes you can't see the forest for the trees...
17:30:18 <Cale> Or instead of whatever representation of failure you're using, you go with Maybe or Either
17:30:32 <Cale> and use the fact that it's a monad to combine results
17:30:35 <skorpan> neither of them make sense
17:30:56 <Cale> What does hasFailed currently do?
17:31:21 <skorpan> pattern match on constructors
17:31:29 <Cale> Which ones?
17:31:36 <skorpan>     hasFailed t = case t of
17:31:36 <skorpan>                     ForErr _ -> True
17:31:36 <skorpan>                     _        -> False
17:31:55 <Cale> aha, so instead of including ForErr in whatever type t is
17:31:59 <Cale> You use Maybe
17:32:06 <Cale> (or Either String)
17:32:21 <skorpan> i don't follow :\
17:32:27 <Cale> It becomes
17:32:43 <Cale> hasFailed (Left _) = True
17:32:49 <Cale> hasFailed (Right _) = False
17:33:20 <Cale> Where in the case that there's a failure, the argument to Left holds the error information or whatever
17:33:31 <skorpan> that doesn't really work well with the rest of my program...
17:33:37 <Cale> and if not, then it's Right x, where x is guaranteed not to be a failure
17:33:53 <Cale> The nice thing there is that you could then write:
17:33:58 <skorpan> i see what you mean, and that makes sense, but unfortunately that doesn't fit into this scenario
17:34:02 <Cale> okay
17:34:24 <Cale> Another option is to write a function which projects to Maybe
17:35:03 <Cale> failed :: Foo -> Maybe Foo
17:35:04 <skorpan> actually there's no reason not to use (||)
17:35:11 <skorpan> it was just so obvious i never really thought about it
17:35:15 <Cale> failed (ForErr _) = Nothing
17:35:20 <Cale> failed x = Just x
17:35:27 <sm> a question: can the monadic tree builders in Data.Tree help me build trees from pure values more efficiently ?
17:36:01 <sm> these: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Tree.html#3
17:36:16 <Cale> More *efficiently*, I doubt it...
17:36:57 <sm> so they are for using when you want to build from monadic values. ok, thanks
17:37:05 <Cale> But they might give you just the right sort of expression...
17:37:47 <sm> I am building a tree from a list of account names, and I sense it's duplicating a lot of work
17:38:28 <Cale> I never use Data.Tree by the way. It has a terrible Show instance, and not so much benefit over just writing my own tree datatype.
17:39:00 <Cale> But let's see what your code is doing. :)
17:39:28 <sm> I made my own show and utils.. working pretty well.. well thanks, let me paste
17:39:44 <pumpkin> doesn't Data.Tree have a nice separate pretty printer that its Show instance doesn't use?
17:40:00 <Cale> pumpkin: well, it has an ascii-graphical one
17:40:14 <Hydrant> hello... any ubuntu users here?  I'm trying to install ghc6 from karmic and getting problems.... so hoping someone has gone through this here before
17:40:15 <pumpkin> yeah
17:40:19 <Cale> But usually I would just prefer the derived one without the record syntax.
17:40:45 <Cale> Hydrant: I'm an Ubuntu user.
17:40:50 <Cale> Hydrant: What is karmic?
17:41:00 <sm> http://gist.github.com/117319
17:41:03 <Cale> Hydrant: In any case, I don't use Ubuntu's version of GHC.
17:41:19 <Cale> Hydrant: Because it's over a year out of date.
17:41:28 <Raynes> No one should use Ubuntu's version of GHC.
17:41:38 <Hydrant> Cale: alpha ubuntu... I'm trying to get ghc6 version ghc6-6.10.3
17:41:46 <Cale> Hydrant: ah
17:41:54 <Cale> Hydrant: Well, that would be current then.
17:42:00 <sm> while building the tree, subAccountNamesFrom is called (length accts) ^ 2 times.. I'd like to to better
17:42:02 <sm> do
17:42:17 <Cale> Hydrant: But if you're having trouble with it, the generic linux binary works well. (At least on the release Ubuntu)
17:42:38 * sm corrects himself: isSubAccountNameOf is called n^2 times
17:42:53 <Hydrant> generic linux binary ?
17:43:12 <Cale> http://haskell.org/ghc/download_ghc_6_10_3.html#x86linux
17:43:24 <Hydrant> In particular I'm attempting to install geordi, C++ bot... I found this one site that says if I don't use ubuntu ghc6 badness happens.. http://jpnurmi.kapsi.fi/blog/2008/01/24/howto-install-geordi-on-ubuntu/
17:44:01 <Cale> Whaaaat...
17:44:02 <Cale> hmm
17:44:41 <Cale> Oh, but that was written in 2008 anyway, I wonder how correct it is.
17:45:03 <Hydrant> yah, I'll try the binaries
17:45:19 <Cale> 6.10.1 wasn't even out yet.
17:45:45 <Cale> Nor was 6.8.3
17:46:00 <Cale> 6.8.2 was current when that blog post was written :)
17:47:38 <thoughtpolice> Cale: 6.8.2 is still current for a few distors (ubuntu/ppc etc.)
17:47:46 <thoughtpolice> Cale: at least xmonad works :)
17:48:06 <Cale> Well, only because those distributions have terrible Haskell support.
17:48:11 <thoughtpolice> hehehe
17:48:24 <thoughtpolice> well, arch pretty much has the most amazing haskell support you can get
17:48:52 <MyCatVerbs> Yes, Arch has a surprising record for not screwing with upstream packages.
17:49:05 <thoughtpolice> also there haven't been any recent linux/ppc bindists (i.e 6.10) i've been able to find
17:49:16 <thoughtpolice> and porting has only just recently started working again
17:49:55 <Cale> Oh, that seems true.
17:50:20 <Cale> I suppose because ppc machines are getting harder to obtain?
17:52:42 <Cale> sm: hmm, is it impossible to encode the data in such a way that the subaccounts of an account are accessible more directly?
17:53:46 <Cale> sm: The problem is that you're going through all the accounts every time to find the subaccounts, which are presumably the same things, and maybe even disjoint...
17:53:52 <sm> right
17:54:23 <sm> I've parsed in eg ["assets:bank:checking", "assets", "expenses:food"] and I want to make it a tree for easy access
17:54:36 <MyCatVerbs> Cale: you can still buy BlueGenes. :)
17:55:08 <MyCatVerbs> Cale: I guess the easiest way to get at a PowerPC chip at the moment is to buy an Xbox360 or a PS3, and dig up the SDKs for each.
17:55:13 <sm> it's surprising that this is expensive, but with 600 accounts this seems to allocate near a G of ram
17:55:44 <sm> not all at once, but.. so it takes a couple of seconds
17:57:52 <erikc> PS3 with linux, yea
17:58:23 <erikc> the powerpc element in the ps3 is garbage too
17:58:40 <pchiusano> hello
18:00:06 <Cale> sm: Is there a guarantee that if foo:bar exists, then so does foo?
18:00:07 <SamB> what? why not just buy a used Mac?
18:00:24 <sm> no, unless I call expandAccountNames
18:00:31 <Cale> okay
18:00:54 <Cale> Do you want to be careful not to represent foo when foo:bar exists but foo doesn't?
18:01:07 <p_l> SamB: While at it, why not a used IBM machine? :D
18:01:35 <SamB> p_l: what OSes did IBM provide for them ???
18:01:38 * p_l also recalls that there's quite a lot of embedded stuff with quite nice specs that uses PPC
18:01:43 <p_l> SamB: AIX and Linux
18:01:46 <sm> eh.. I want foo to appear in the tree, even if it wasn't in the original list. So I think no
18:01:51 <Cale> okay
18:01:55 <SamB> p_l: oh good, not MVS!
18:01:58 <p_l> and on newer, iOS aka AS400
18:01:59 <sm> the tree should contain all accts plus all their parents up to the root
18:02:06 <sm> this is all at http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/Ledger/AccountName.hs if it's easier to see. I appreciate the extra eyes!
18:02:11 <p_l> SamB: MVS and AIX are different. I know, I have MVS installed :D
18:02:50 <SamB> p_l: yeah, I'm a bit foggy on the relationships between POWER, PowerPC, and s/3[69]0
18:02:59 * p_l just noticed that he misread "good" as "noes"
18:03:37 <p_l> SamB: With newest machines (certain with POWER5 and later), the instruction sets of PowerPC and POWER "merged"
18:03:56 <p_l> s390 uses completely different design
18:04:18 <p_l> (but zOS is SUS-compliant)
18:04:19 <SamB> you mean they reintegrated all of POWER into the PowerPC at that point, and vice-versa?
18:04:38 <p_l> something like that, afaik
18:04:39 <SamB> p_l: what ???
18:04:45 <SamB> zOS is SUS compliant
18:04:46 <SamB> ?
18:04:53 <SamB> you can do that with EBCDIC ?
18:05:00 <p_l> SamB: Yeah, i heard it passed Single Unix Spec. testing
18:06:03 <p_l> and you can certainly do that with EBCDIC
18:08:27 <p_l> the funny thing is that nowadays, when you run AIX, it seems to be standard to run two partitions for one instance, with modded AIX managing devices...
18:09:07 <eden> any yi users about? I've ust installed it, set up the df
18:09:30 <Cale> sm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5201#a5201 -- maybe try this?
18:10:01 <Cale> sm: Oh, apparently that's the wrong order for efficiency.
18:11:30 <eden> lets continue that... set up the default emacs mode, but it doesn't recognise the escape key. Alas, the keymap documentation is limited to "hack as needed", which doesn't help....
18:13:51 <sm> Cale: that first builds up a tree with nested maps, one per item, then flattens it ?
18:14:15 <Cale> It builds up a bunch of path-shaped trees and merges them
18:14:23 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5201#a5202
18:14:36 <Cale> This seems to have no difficulty with 40000 or so items.
18:15:25 <Cale> Just tried it with 362880 = 9! items, and it was okay :)
18:15:37 <sm> very cool :)
18:15:48 <sm> let's see if I can try this before I must catch the bus
18:16:37 <Cale> You'll have to do the colon-splitting up front, but I suspect that you already do.
18:19:19 <eden> okay, maybe that was too vague. I'm using yi in vty mode, and the error reported in th bottom line is "Unrecognized input: Esc"
18:19:27 <shapr> p_l: Why do you want access to a Cell cpu?
18:20:31 <p_l> shapr: I think it was MyCatVerbs who stated that easiest way to get PowerPC is to buy PS3 or XBox360
18:20:55 <shapr> ah, right
18:22:11 <p_l> I'm personally more interested in getting POWER6, IA64, MIPS64 or AMD Fusion (and of course any modern Alpha)
18:22:14 <sbahra> p_l, except the XBox 360 is not very hackable at the moment.
18:22:27 <p_l> sbahra: yeah
18:22:28 <sbahra> Yes, I think IA64 is the most interesting out of all of these architectures.
18:22:43 <sbahra> You can find PPC Mac Mini on eBay for pretty damn cheap.
18:24:04 <pejo> Why is IA64 interesting? It's both expensive and "slow" in practice, unless you're doing numerical computations.
18:24:41 <pumpkin> ps3 is best price per flop in theory, isn't it?
18:24:44 <p_l> pejo: it had some interesting things - I once heard of a method that gave you closures in assembler code :)
18:24:48 <pumpkin> partially because sony's still selling it at a loss
18:25:00 <p_l> pumpkin: it's very limited when it comes to memory
18:25:05 <pumpkin> yeah
18:25:19 <pumpkin> if only they'd given us slots instead of stuck it straight on the board :/
18:25:27 <pumpkin> *sticking
18:25:34 <p_l> pumpkin: my friend managed to hit a bottleneck by simple playing with random number generation
18:25:43 <pumpkin> that sucks
18:25:51 <pumpkin> surely games would like more RAM too, and it's cheap
18:26:06 <p_l> pumpkin: console devs are used to much smaller amounts than 256MB :P
18:26:17 <pumpkin> yeah, but they could do crazy stuff with more
18:26:21 <pumpkin> :P
18:26:47 <shapr> pumpkin: ps3 ram isn't that cheap, it's at-cpu-speed RDRAM.
18:26:53 <pumpkin> ah
18:27:25 <p_l> if you want Cell for HPC, I'd go with IBM blade servers or those PCI-X/PCI-Express SoCs
18:27:28 <eden> pumpkin; by the way, I discovered the solution to the parsec problems you tried to help with was to simply "import Text.Parsec", and hide the clashing function names.
18:27:39 <shapr> The most recent generation of Cell blades has 1GB of RDRAM for each cell core, and slots for up to 4 or 8 gb DDR2 buffer memory, I forget how much.
18:27:45 <gwern> @seen nomeata
18:27:45 <lambdabot> I saw nomeata leaving #darcs, #xmonad and #haskell 2h 28m 54s ago, and .
18:27:47 <sm> Cale: got to convert this to my tree type.. or convert the app to the new one
18:27:49 <shapr> p_l: Those guys are expensive though.
18:27:56 <shapr> p_l: And a pain in the butt to run.
18:27:59 <sm> I'll let you know when I can compare performance
18:28:05 <Cale> sm: Okay
18:28:08 <p_l> shapr: if you want speed...
18:28:21 <sm> thanks a lot, I'm gone
18:28:30 <shapr> For example, I have what appears to be a perfectly sensible partition on this QS20 drive, but it still doesn't talk to the network.
18:28:35 <gwern> @tell nomeata might be good to amend the documentation for darcswatch to note that replies-to-emails *must* include the attachment - I've been experimenting and that seems to be the magical sauce I've been forgettting - gmail removes them by default
18:28:35 <lambdabot> Consider it noted.
18:28:41 <shapr> And I don't have a console cable, so I can't see what's broken.
18:28:41 <pumpkin> I'll be back later :)
18:28:53 <p_l> shapr: HMC?
18:28:58 <shapr> p_l: I found some cheap QS21s, but they're not compatible with the E chassis.
18:29:01 <shapr> HMC?
18:29:05 <shapr> What's that?
18:29:25 <p_l> Hardware Management Console
18:29:49 <shapr> The QS20 blades can't talk to the advanced management console for remote control.
18:30:00 <p_l> shapr: what about their enclosure?
18:30:06 <shapr> Your only option is the $50 hard-to-find serial cable.
18:30:12 <shapr> Er, what about their enclosure?
18:30:46 <shapr> I really wish I could get my hands on fourteen QS22s for little or no money. Not like that's gonna happen.
18:30:58 <p_l> shapr: I think the ones I had seen had Service Processor in chassis which let you talk from HMC to blades
18:31:23 <shapr> All the IBM BladeCenter blades except for the QS20s will let you remote control the console.
18:31:37 <shapr> And the QS21s only work in an H or T chassis.
18:31:54 <p_l> heh
18:31:57 <shapr> p_l: I have an E chassis and seven QS20s here in my apartment, want to help me fix them? :-)
18:32:27 <SamB> shapr: what is this cable you don't have ...?
18:32:41 <gwern> Haskellers! Tonight we write in Malbolge!
18:32:54 <shapr> It's some crazy custom order molex cable for the micro-serial plug on the front of the QS20 blades, want me to take a picture?
18:33:01 <SamB> gwern: no thanks
18:33:19 <SamB> I can't even remember if that's worse than intercal or not ...
18:33:24 <shapr> It's also a 24 day lag time cable order, it's frustrating.
18:33:32 <shapr> p_l: On the good side, my x86 blades work great :-)
18:33:36 <p_l> I have no real experience with them (I wasn't given access to that stuff - I learned about HMC due to being company representative during p560 installation)
18:33:57 <gwern> (go, stranger passing by, / and tell the haskellers that / obedient to their types / here we lie)
18:34:18 <gwern> SamB: what are you a woman? have you no guts for glory?
18:34:30 <shapr> p_l: Recent pix: http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter#
18:34:33 <p_l> gwern: a persian
18:34:46 <gwern> p_l: yes, well...
18:34:46 <SamB> gwern: I don't like to program in languages where I have to FIGHT just to get a VALID program ...
18:34:49 <EvilTerran> SamB, it's substantially worse than intercal, i believe
18:35:05 <gwern> SamB: but as a haskeller, you should feel right at home...
18:35:09 <SamB> I'd prefer something like Ulambda
18:35:25 <SamB> gwern: oh, that's not the same kind of fight at all
18:35:40 <SamB> that's where the compiler is seeing that I'm saying stuff that doesn't actually mean anything
18:35:47 <SamB> totally different
18:35:48 <gwern> eh. it's the same kind of fight in the same way a bar fight's a cat fight
18:35:56 <gwern> in mud
18:36:03 <Gracenotes> mud, you say
18:36:08 <p_l> shapr: hah, system complaining about not connected PSUs... It's one of my favourite messages, ever since commandeering an old proliant in high school :)
18:36:10 <SamB> what does any of this have to do with porn ...?
18:36:55 <eden> Nope? Oh well, however much nicer the syntax colourisation is in Yi, I can continue with ordinary emacs.
18:36:59 <byorgey> @remember gwern bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon
18:37:00 <lambdabot> It is forever etched in my memory.
18:37:59 <gwern> eden: it's kind of hard to debug an error like that. it could be a dozen things - you didn't enable vi mode right, vty doesn't like your terminal, you're using old libraries/yi, etc
18:38:52 <roconnor> what is the opposite of a "conservative assumption" ?
18:39:28 <EvilTerran> a nservative assumption? :P
18:39:33 <roconnor> :P
18:39:34 <gwern> a liberal
18:39:45 <roconnor> :)
18:41:02 <SamB> yeah, I guess a liberal assumption ...
18:41:18 <SamB> but you should specify what about when you mention it
18:41:26 <gwern> d'oh!
18:41:39 <EvilTerran> substantial assumption?
18:41:44 * gwern just sent an email meant for darcswatch with the cc 'REJECTED', to the patch author
18:41:51 <gwern> hope he isn't insulted -_-
18:42:29 <SamB> I mean, is it a lot of CPU, loads of RAM, an actual implementation of ISO C99 ?
18:42:31 <eden> gwern: For sure. But it's the only error message provided to me.It's most likely to be a configuration mistake. but without configuration documentation, all I can do is hope there's somebody with experience.
18:42:32 <SamB> what are you assuming ?
18:42:47 <gwern> eden: you could just steal one of the existing configs
18:42:55 <gwern> it's fairly safe to assume they work
18:42:57 <roconnor> I was going to say "detrimental assumption"
18:43:22 <gwern> isn't a conservative one a detrimental one?
18:43:23 <roconnor> SamB: I'm ignoring non-jackpot payouts of lotto tickets.
18:43:41 <roconnor> gwern: a conservative assumption is a harmless assumption.
18:43:42 <SamB> roconnor: they HAVE those ?
18:43:58 <eden> gwern: Fine. Where are they? I've looked pretty hard.
18:44:05 <roconnor> SamB: you can win like $5 for matching 3 numbers.
18:44:23 <gwern> a conservative assumption is that the bridge you are building will receive 10x the expected traffic. and they'll all be carrying elephants. a liberal one is that no one will cross it, except monks who massage the road surface with ghee as they recite hymns in praise of the designer
18:44:32 <SamB> roconnor: hmm, doesn't seem like a good one to ignore ...
18:44:34 <gwern> eden: in Yi/Users/
18:44:58 <SamB> gwern: wouldn't the glee cause added stress ?
18:45:18 * SamB also thought road traffic was measured in tons
18:45:19 <eden> gwern: Cheers. I take a look there.
18:45:20 <gwern> SamB: ghee is the food of the gods! how could you attribute evil effects to it?
18:45:42 <roconnor> SamB: Right.  I eventually took it into consideration.
18:45:44 <SamB> gwern: well, generally people move faster when gleeful
18:45:54 <gwern> no no, not 'glee', 'ghee'
18:46:04 <SamB> gwern: oh!
18:46:05 <SamB> oops
18:46:08 <SamB> misread
18:46:23 <SamB> so ... you want the bridge to get EATEN ?
18:46:30 <Hydrant> I'm trying to build a package, and getting an error: http://rafb.net/p/bNrvGy38.html
18:46:54 <eden> Ah, I'm from the West Midlands, the very home of Balti cooking. Ghee is a special
18:46:58 <gwern> SamB: no one would eat a bridge. even one dripping with ghee
18:47:07 <SamB> gwern: not even a God ?
18:47:17 <gwern> gods don't exist, silly
18:47:30 <SamB> well then how can you claim that they eat things ?
18:47:43 <gwern> can you claim they don't?
18:48:00 <eden> some of the brumigham boneheads would try a bridge if it had extra chillii sauce
18:48:01 <SamB> dunno!
18:48:15 <SamB> but you can't claim that they do, either
18:48:29 <SamB> eden: you mean burmingham ?
18:48:42 <gwern> I rather think it inherent in the definition of a god that were they to exist, they could eat a bridge
18:49:25 <SamB> I was talking about the ghee, actually
18:49:37 <byorgey> Hydrant: usually that error is caused by the required package (random in this case) missing from the Build-depends: line in the .cabal file for the package
18:50:05 <eden> Yes, Brumigham is the usual British colloquialism for Birmigham.
18:50:16 <eden> this get
18:50:32 <Hydrant> byorgey: fixed, going now
18:50:37 <eden> it gets sortend to "brum" most of the time.
18:50:38 <byorgey> Hydrant: great
18:51:33 <gwern> yes, that seems very british
18:52:03 <gwern> (when I visited london, I was surprised how it struck me as dirty and shabby; and what little I saw of the rest of England wasn't much different)
18:53:27 <eden> Did you spend much time in pubs? if so, then impression you got is totally reasonable.
18:54:58 <p_l> afk
18:56:25 <Adamant_> if you take a train in London, you will almost certainly go through some very crappy areas, but there are plenty of areas that are well taken care of.
18:57:27 <Adamant_> the college towns are quite nice for instance.
18:57:36 <Adamant_> outside of London.
18:59:17 <eden> gwern: youu say Yi/Users. I can't find such a thiing
19:04:49 <dmwit> Definitely the shortest doc I ever saw: http://www.haskell.org/ghc/docs/6.10.1/html/libraries/ghc/StrictAnal.html
19:05:25 <copumpkin> thing like that don't need an explanation
19:06:11 <EvilTerran> o.
19:07:34 <dibblego> remind me, how is  pronounced?
19:07:47 <kpreid> omega
19:07:58 <dibblego> ah yeah ta
19:08:11 <eden> I know some SMers that go about with T-shirts with the slogan "#!/usr/bin/perl -s", so I guess that's another way Haskell is more pure...
19:08:37 <malouin> dibblego: like a long o as in saw.
19:09:18 <jrockway> hey, anyone writing any media-player-related-things in haskell?
19:09:28 <jrockway> i am getting kind of fed up with the xmms2 design (and implementation)
19:09:43 <shapr> I like mpd
19:09:44 <jrockway> (mpd is not much different)
19:09:47 <jrockway> heh
19:09:54 <kpreid> and malouin provides the *other* answer.
19:10:01 <jrockway> both fail at copying the bits from a file to the audio hardware without changing them
19:10:11 <jrockway> xmms2 can't even play files with 24-bit samples
19:10:24 <copumpkin> can your hardware?
19:10:28 <jrockway> yes
19:10:55 <jrockway> anyway, just curious
19:11:17 <jrockway> a related issue is how vlc, mplayer, etc. crash when they encounter bad data
19:11:34 <jrockway> it annoys me, because your program should not die with a memory error because an input file contains an error :)
19:11:58 <copumpkin> that is bad
19:11:59 <dmwit> Wow, I've never had that happen.
19:12:14 <dmwit> What kind of junk are you feeding your poor pet players?
19:12:34 <alexey23> jrockway, pure xmms2 from command line is OK for me :-)
19:12:44 <dmwit> I feed mine jpgs sometimes by accident, but they don't crash... they just tell me off.
19:13:18 <jrockway> yeah, it is usually around corner cases
19:13:30 <jrockway> but really, i am just wondering if anyone else is working on this sort of thing
19:14:37 <dmwit> I do not SAGN.
19:14:44 <eden> Nah. fighting a text editor that claims to be like emacs is too much pain.One to give up as a bad job.
19:14:52 <dmwit> mpd just works for music, mplayer just works for video
19:15:20 <copumpkin> eden: ?
19:15:25 <jrockway> dmwit: i will agree that they work 99% as i'd expect
19:15:34 <jrockway> sometimes the 1% annoys me, though :)
19:15:57 <dmwit> I would think that if somebody started something new now, it would be more than 1% annoying. =P
19:16:31 <jrockway> for mplayer, yes
19:16:39 <jrockway> since there are 100 million different codecs to support
19:16:43 <jrockway> but for audio, it's simpler
19:16:50 <jrockway> mp3, vorbis, flac, wav, and you are done
19:17:32 <eden> copukin; I was trying yi.I don't mind tuning an editor, but it needs enough documentation for it to bbe worth the time.
19:17:38 <dmwit> What, you're not going to support my huge library of legacy Unix noises in .au format? ;-)
19:17:54 <jrockway> you can convert those to flac offline ;)
19:19:01 <roconnor> jrockway: awsome.  I put all those audio codecs into OS/2.  Apparently I'm done.
19:19:18 <roconnor> well, except for wav.  OS/2 comes with that.
19:22:23 <thoughtpolice> eden: yi is still very much a work in progress
19:22:28 <alexey23> jrockway, and there is real media / windows media stuff (but it is bad to promote proprietary technology...)
19:22:56 <thoughtpolice> eden: there are almost daily fixes/enhancements made to the codebase, especially by jpb
19:23:02 <roconnor> is mp3 still proprietary?
19:23:31 <gwern> eden: Yi/Users is a directory in the darcs repo; dunno if it's in the hackage tarball
19:23:43 <gwern> roconnor: far as I know. it's gif that fell out of patent recently
19:24:05 <roconnor> well, gif fell out many years ago
19:24:12 <alexey23> roconnor, a sort of.
19:25:18 <roconnor> ``The various patents claimed to cover MP3 by different patent-holders have many different expiration dates, ranging from 2007 to 2017 in the U.S.
19:25:21 <roconnor> according to wikipedia
19:25:52 <jrockway> interesting
19:26:06 <jrockway> i am largely migrated to FLAC... except for mp3s that I have downloaded or bought from amazon
19:26:10 <roconnor> I expect many of these patents to be questionable
19:26:23 <jrockway> i found a record label that will sell me un-DRM'd 192Khz 24-bit FLAC files, though, which i think is awesome
19:26:36 <roconnor> that is awesome
19:26:55 <eden> thoughtpolice: All software is a work in progress.I like haskell a lot, but is suffers horribly from libraries wit piss poor documentation. A list of type signatures is not documentation. It at least requires examples you can modify.
19:26:59 <Cale> I can't hear the difference between flac and ogg -q6 anyway.
19:27:16 <copumpkin> eden: types very often are almost as good as documentation
19:27:20 <Cale> And since I'm not editing the audio, it just seems like a waste of space to me. :)
19:27:21 <jrockway> (http://www.linnrecords.com/)
19:27:22 <copumpkin> eden: if not better! ;)
19:27:24 <alexey23> jrockway, FLAC is a waste of space.
19:27:29 <jrockway> incidentally, they are from glasgow
19:27:29 <copumpkin> space is cheap
19:27:30 <idnar> alexey23: space is cheap :P
19:27:36 <jrockway> alexey23: a 2TB hard drive is like $100 now
19:27:45 <jrockway> no need to throw away data to save a penny
19:27:53 <idnar> if I use FLAC, I don't need to worry about exactly how much lossiness I can tolerate
19:28:01 <idnar> and I can always switch to something better if something better comes along
19:28:04 <roconnor> I sort of agree with jrockwell.
19:28:17 <copumpkin> me too, I bought craploads of space just for that reason
19:28:21 <idnar> incidentally, decoding Ogg Vorbis is horribly computationally expensive, making it a poor choice for portable players and the like
19:28:35 <roconnor> I don't think I'd go out of my way to get FLAC, but I wouldn't bother coverting it either.
19:28:37 <jrockway> the key is to not leave your house :)
19:28:41 <eden> gwern; it's not in hackage. I used cabal to intsall it, which throws
19:28:53 <Cale> I don't have any portable computational devices.
19:28:54 <eden> ... away the source.
19:28:55 <jrockway> but i have rockbox on my ipod, and listening to flac and vorbis still leaves me with 10 hours of battery life
19:28:59 <copumpkin> jrockway: is the scottish chamber orchestra any good?
19:29:08 <gwern> eden: look into cabal unpack
19:29:15 <jrockway> copumpkin: some of it, yes
19:29:28 <idnar> Vorbis uses my battery up like 5x faster than anything else
19:29:44 <idnar> FLAC is also a bit of a battery hog, but that's mostly just because of the relatively larger filesize, rather than the actual decoding complexity
19:29:45 <eden> compukin I disagree. The type signatures are fine as reference material, but no good at all if you're new to something.
19:29:51 <idnar> Musepack definitely wins on decoding cost, though
19:30:21 <alexey23> jrockway, I don't think that it is practically possible for my hardware or my ears to feel the difference between high quality OGG and FLAC. And space is still important for portable players.
19:30:41 <jrockway> yeah, you can always encode to mp3 for use on the portable player
19:30:47 <Cale> Besides, the vast majority of the music I listen to was recorded in the 70's with not enough fidelity for it to make a difference anyway :P
19:30:56 <jrockway> i think good headphones makes the biggest difference out of anything
19:30:57 <eden> gwern I'll give that a try. still seems like a porr substite for actual documentaion.
19:31:00 <gwern> alexey23: one of the rare benefits of being hearing impaired! I *know* I can't hear the difference between ogg and flac :)
19:31:15 <idnar> jrockway: good headphones make it possible to tell the difference between bad and good encoding :P
19:31:18 <gwern> eden: yi's too big and complex and alpha to have good docs like xmonad
19:31:23 <dmwit> eden: Have you got a specific library you want more docs on?
19:31:41 <jrockway> yeah, i agree
19:31:50 <jrockway> i think most people have bad headphones and they say mp3 sounds fine, though
19:32:03 <jrockway> or they have bad headphones, and buy a $2000 DAC, and complain that it still sounds bad
19:32:06 <jrockway> well, yeah :)
19:32:10 <idnar> haha
19:32:12 <dmwit> Actually, a recent study showed that with good headphones, a lot of people *preferred* low-quality encodings.
19:32:16 <idnar> I wish I had a $2000 DAC :P
19:32:23 <jrockway> me too :)
19:32:25 <dmwit> Because they were used to the aliasing and stuff, and missed it in the high-quality encodings.
19:32:29 <idnar> dmwit: those are the people that turn the Bass knob up to 11 on their hifi, though
19:32:36 <copumpkin> ugh
19:32:50 <gwern> if I had a 2000USD DAC, I could sell it. that'd be nice
19:33:03 <jrockway> i am most annoyed by music that is clipped
19:33:03 <gwern> (get a better pair of hearing aids :)
19:33:06 <eden> dewit: I have yet to find good documentation for *any* package, so specifics don't make aany difference.
19:33:13 <jrockway> i wish i could obtain an un-"enhanced" version
19:33:21 <jrockway> since i can just turn up my volume knob to make it sound louder
19:33:25 <copumpkin> eden: it's part of the "avoid success at all costs" motto :)
19:33:26 <dmwit> eden: Specifics make a difference because there are people here in a position to create better documentation.
19:33:32 <Cale> mp3 does sound quite acceptable, but there are cases where I can tell the difference between mp3 and ogg at the same bitrate. They're usually not enough to actually bother me though.
19:33:36 <dmwit> eden: In my experience, the docs have been good, so that's why I ask.
19:33:36 <gwern> eden: hm. does the set of bad doc'd packages you've seen include xmonad?
19:33:38 <idnar> jrockway: clipping (especially frequency clipping) is like nails on a chalkboard to me
19:33:45 <copumpkin> eden: specifics also transform your criticism from whining to constructive criticism :)
19:33:49 <jrockway> yup, it ruins a lot of excellent music
19:34:02 <jrockway> (ok, it is mostly pop, but i do enjoy it from time to time ;)
19:34:34 <jrockway> the problem i've had with classical music is an insanely high noise floor
19:34:37 <idnar> jrockway: also, listening to low-bitrate encoding through headphones, or even high-bitrate encoding through cheap headphones, gives me a massive headache after like 5 minutes
19:34:53 <idnar> for a long time, I thought it was just impossible for me to use headphones / earphones
19:35:05 <idnar> then I was eventually introduced to high quality audio equipment :P
19:35:09 <jrockway> ahh :)
19:35:16 <dmwit> (...and therefore the people who wrote the docs you're complaining about may also think they're good.  They can't know any different until someone says a specific library. =)
19:35:20 <jrockway> i have always been a headphones person, since good speakers are out of my price range
19:35:44 <idnar> bad speakers still sound awful, but at least I don't get headaches
19:35:44 <jrockway> my apartment also has concrete floors, which makes for ... interesting ... acoustics
19:36:11 <dmwit> idnar: Yeah, I've gotten those headaches, too.  It's really annoying.
19:36:23 <davidL> if a string with length 2^{|V|+1} can be derived from a context-free grammar whose set of non-terminals is V, is this enough to prove (via the pumping lemma) that the grammar's language is infinite?
19:36:39 <jrockway> ok, i am being pulled away for dinner now :)
19:36:48 <jrockway> if i write anything haskelly for listening to music, i will report back
19:37:08 <eden> copumkin: you're right. But it's hard to provide constructive criticism for something that gives you no idea of exactly hat the problem is.
19:38:01 <dmwit> davidL: Definitely not.
19:38:02 <gwern> eden: generally, you look at a library and tell the author 'I have problem X, and this library seems to cover it, but after looking through it, I have no idea how to do X'
19:38:15 <dmwit> davidL: Consider the CFG S -> "aaaaaaaaaaaa"
19:38:24 <dmwit> davidL: It has only one nonterminal, and it derives a longish string...
19:38:37 <alexey23> davidL, no.
19:38:44 <copumpkin> eden: surely there was something you looked at that you wanted to find more about, but there was crappy documentation. Simply saying specifically which of the things you looked at were unsatisfactory, instead of extrapolating and saying all of haskell documentation is bad, would probably be helpful. Better still would be to contact the maintainers of the packages that have bad documentation to ask them (or provide!)
19:39:18 <eden> gwern: does that often work? Every time I've tried that I get pointed here.
19:39:33 <gwern> eden: it worked the last time I tried it with tagsoup
19:39:34 <davidL> dmwit: hmmm
19:39:35 * gwern shrugs
19:39:47 <roconnor> ugh
19:40:10 <dmwit> eden: Perhaps the problems you're having are related to the language, not the libraries. ;-)
19:40:21 <roconnor> Anyone asking me to provide documentation, please include a cheque with your request.
19:40:21 <davidL> dmwit: the CFG is in CNF, I forgot to mention
19:40:29 <gwern> roconnor: that'
19:40:31 <gwern>  s mean!
19:40:46 <roconnor> :)
19:40:59 <roconnor> I have better things to do than document my own code.  I already know how to use it. :P
19:41:25 <dmwit> davidL: In CNF, nonterminals go to pairs of nonterminals or a single terminal, is that right?
19:41:34 <davidL> dmwit: so S -> aaaaaaaaaaaaaa will be reduced to a grammar with many nonterminals
19:41:34 <dmwit> davidL: If so, then you don't even need the pumping lemma. =)
19:41:57 <roconnor> ...
19:42:09 <davidL> dmwit: why don't I need the pumping lemma?
19:42:17 <roconnor> actually, aside from finishing my thesis, I guess I don't actually have anything better to do.
19:42:38 * gwern loves thesis deadlines. I love the wooshing sound they make passing by
19:42:57 <roconnor> gwern: my deadline was last december
19:43:09 <gwern> a fond memory!
19:43:45 <dmwit> davidL: I guess it's basically the pumping lemma; but you could also use the pigeon-hole principle to show that you had to derive a "cycle" to get to that string.
19:43:59 <dmwit> But yeah, the lemma you're proposing should be true.
19:44:58 <eden> dmwit: I'm still learning. As with all languages, learning the language isn't usually the issue, it's learning how to use the libraries that's difficult. Extrapolating from every library I've tried to use to all the libraries that exist is also unfair, but doesn't lead to a way forward either.
19:45:27 <davidL> dmwit: I need to prove the language of all PDAs that accept infinite languages is decidable, so my proof was simply to attempt to generate a string that's at least 2^{|V|+1} long
19:46:12 <dmwit> You'll also need an upper bound, I think.
19:46:18 <davidL> hm, yeah
19:47:19 <dmwit> In fact, for decidability proofs, lower bounds usually don't matter. ;-)
19:47:35 <dmwit> Your algorithm can be spectacularly inefficient and nobody cares.
19:48:24 <davidL> yup
19:49:16 <eden> There are also some counter-examples. The parsec documentation is pretty good, even if it's so out of date that if nearly every package  has been renamed a couple of times.
19:49:41 <davidL> although a simpler method might be to try each derive each terminal in the grammar and see if it ever loops
19:50:18 <dmwit> davidL: There could easily be several ways to derive any given terminal.
19:50:27 <dmwit> ...or none
19:50:40 <davidL> dmwit: errr, I meant nonterminal
19:50:58 <dmwit> same complaint
19:51:49 <davidL> dmwit: well in CNF, "useless" nonterminals have been removed, so each nonterminal is reachable
19:52:46 <Axman6> hmm, i'm confused by http://en.wikipedia.org/wiki/One-way_function . wouldn't const x be a candidate, or (+)?
19:52:48 <davidL> and if from one nonterminal, you can get back to itself in any number of steps, the grammar is recurrsive and thus infinite
19:52:52 <dmwit> Hm, can it be as easy as cycle detection in the production graph?
19:53:34 <dmwit> Axman6: Add "injective" to the definition. ;-)
19:53:42 <davidL> dmwit: isn't the cycle the pump?
19:53:44 <Axman6> injective?
19:53:51 <dmwit> (+) is definitely not one-way, since it's easily invertible.
19:53:53 <dmwit> via (-)
19:54:01 <Axman6> hmm
19:54:42 <Axman6> so the point is not to get the outputs back that you put in from the output of the original function?
19:54:55 <dmwit> err... what?
19:55:11 <Axman6> yeah, that was difficult enough for me to understand :P
19:55:38 <dolio> They have to be injective if you're going to (necessarily) get back what you put in at all.
19:55:58 <dmwit> The interesting thing about one-way functions is that, given an output, it's hard to demonstrate *any* input that yields that output.
19:56:08 <jeffwheeler> What a difference a small underscore can make . . .
19:56:16 <Axman6> hmm
19:56:19 <dmwit> So const is a bad example, because given the output "3", I can demonstrate the input (3, ()), which yields that output.
19:56:20 <dolio> If you're just hashing, then you don't need injectivity.
19:56:30 <dolio> But 'const x' is a pretty bad hash.
19:56:33 <dmwit> (+) is also a bad example, because given the output "x", I can demonstrate the input (x, 0).
19:56:41 <Axman6> what's injective mean?
19:56:51 <dmwit> Injective means any two different inputs yield different outputs.
19:57:04 <Axman6> dmwit: so, you're not trying to find the exact input that was used to find the output then
19:57:12 <Axman6> ok
19:57:12 <dmwit> Not necessarily, no.
19:57:25 <Axman6> alright, i see how this is hard then ;)
19:58:16 <dmwit> Check the definition: we want that for any easy function A and one-way function f, f(A(f(x))) = f(x) should be unlikely.
19:58:29 <dmwit> (any easy, randomized function A)
19:58:46 <dmwit> So if A can demonstrate any input to f that gives the same answer as the original input to f...
19:59:20 <dmwit> dolio: If you're hashing, do you care about one-way-ness?
19:59:37 <Axman6> so a one way function would have to produce a unique output for every input?
19:59:47 <dmwit> No, I don't think so.
19:59:53 <dmwit> I said it above, but I didn't mean it.
20:00:14 <dmwit> It's okay if it gives the same output for several inputs, as long as all of those inputs are hard to find. =)
20:00:17 <dolio> dmwit: I don't know. I didn't really think about it. :)
20:00:26 <Axman6> heh, i see
20:00:46 <dolio> dmwit: If you can compute inverse images of a hash function easily, that'd probably be bad.
20:00:58 <dmwit> For hashing, though?
20:01:02 <dmwit> I mean, for password stuff, yeah.
20:01:14 <dmwit> But for a hashtable, who cares?
20:01:18 <dolio> I mean for cryptographic hashes.
20:01:22 <dmwit> oooooooooookay
20:01:27 <dmwit> Never mind, then. =)
20:02:14 <Axman6> so the point isn't that you don't know what was used to find the output, but that you need to find an input that produces that output
20:02:33 <dmwit> right
20:02:38 <Axman6> ok, excellent
20:02:42 <Axman6> thanks dmwit
20:02:49 <Axman6> dmwit++
20:02:51 <Axman6> dolio++
20:02:55 <dmwit> Think of it this way: you hacked into somebody's password database, and you have their hashed passwords.
20:03:16 <dmwit> You don't care if you get the exact password of the user; if you get some other random string that happens to hash to the same thing, that's fine with you.
20:03:24 <jeffwheeler> The whole username++ thing doesn't really make sense in #haskell.
20:03:29 <dmwit> eh?
20:03:33 <dmwit> ?karma
20:03:34 <lambdabot> You have a karma of 2
20:03:42 <jeffwheeler> A global state?
20:03:46 <dmwit> You bet!
20:03:57 <dmwit> There's lots of global state here!
20:04:09 <jeffwheeler> The syntax isn't even coherent in Haskell. :P
20:04:10 <dmwit> Like ?quote, ?karma, ?poll, ?seen, ...
20:04:23 <dmwit> ?tell jeffwheeler off
20:04:23 <lambdabot> Consider it noted.
20:04:25 <Axman6> poll?
20:04:29 <dmwit> poll!
20:04:30 <Axman6> @help poll
20:04:30 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
20:04:38 <Axman6> ah ha
20:04:50 <jeffwheeler> ?help tell
20:04:50 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
20:05:17 <jeffwheeler> I didn't get my message. :(
20:05:17 <lambdabot> jeffwheeler: You have 1 new message. '/msg lambdabot @messages' to read it.
20:05:25 <jeffwheeler> Oh, I see; it can't be a message to lambdabot.
20:07:20 <jeffwheeler> It doesn't interpret its own output, does it?
20:07:42 <jeffwheeler> > print $ "dmwit" ++ "++"
20:07:43 <lambdabot>   <IO ()>
20:07:50 <jeffwheeler> > "dmwit" ++ "++"
20:07:51 <lambdabot>   "dmwit++"
20:08:05 <Apocalisp> heh
20:08:23 <jeffwheeler> ?karma dmwit
20:08:24 <lambdabot> dmwit has a karma of 2
20:08:40 <Apocalisp> first time with lambdabot, jeffwheeler?
20:08:51 <jeffwheeler> Apocalisp: not at all
20:09:10 <Apocalisp> Didn't think so.
20:09:24 <jeffwheeler> Just playing about . . . #yi is being lame.
20:09:37 <Apocalisp> How is yi?
20:09:57 <jeffwheeler> I love it, although I've been trying to get tabs working in the Pango (GTK) UI all day, without much success . . .
20:10:27 <jeffwheeler> And we've also fallen from around 30 people in the room around the last release to 15.
20:10:40 <Apocalisp> why's that?
20:10:43 <jeffwheeler> no idea
20:10:54 <Apocalisp> I tried yi for a bit. Liked it quite a lot.
20:10:59 <dmwit> I've found a few ways to increase my own karma.
20:11:10 <jeffwheeler> Trick others?
20:11:10 <dmwit> It's not that hard... but not that useful, either. =)
20:11:32 <Apocalisp> thanks for pointedlist, by the way, jeffwheeler
20:11:51 <Apocalisp> Useful stuff.
20:11:51 <jeffwheeler> Apocalisp: your welcome; what'd you use it for?
20:12:09 <jeffwheeler> Much of the original source was from Yi, actually
20:12:20 <jeffwheeler> it had been in there for ages, and really didn't belong
20:12:25 <jeffwheeler> so I stripped it out and organized it a bit
20:12:33 <eden> To draw a provocative example, perl is horrible, huge ugly and ad-hoc lanugage, whereas haskel is beautiful small and coherent language. The documentation for packages in each is the other way round. Perl docs nearly always give you enough examples to go from a standing start, Haskell docs usually give you nothing to work from. This is a cultural problem, not a language problem. Haskell culture is also friendlier than  Perl cu
20:12:33 <eden> lture, but the differences make it easier to give up and for perl, rather than do thebetter thing and go for haskell.
20:12:42 <Apocalisp> I ported it to Scala and Java, that's what. :)
20:13:07 <jeffwheeler> Apocalisp: hehe, sweet :)
20:13:21 <Apocalisp> Oh, and I sent you a patch for find.
20:13:34 <jeffwheeler> Oh, that was you a while back?
20:13:40 <Apocalisp> yea
20:13:47 <jeffwheeler> :)
20:14:18 <QtPlaty[HireMe]> eden: I find myself in aggrement with you.
20:14:20 <Apocalisp> Saw that you changed it a bit. Mine worked for infinite lists, you know. :)
20:14:30 <jeffwheeler> Ha, what?!
20:14:39 <Berengal> eden: Agreed here as well
20:14:58 <jeffwheeler> I didn't realize any of the stuff would work for infinite lists.
20:15:01 <Berengal> Except for the last bit about giving up
20:15:29 <Apocalisp> jeffwheeler: With a bit of modification, pointedlist should work just fine for infinite lefts and rights.
20:15:42 <jeffwheeler> Apocalisp: I suppose it could; yes
20:15:45 <QtPlaty[HireMe]> eden: I don't know what you mean by "make it easier to give up and for perl"
20:17:31 <roconnor> eden: Intresting comment.  Are the perl package writers documenting their own work?
20:18:05 <roconnor> eden: I wonder if it is an effect of perl packages being older?  Hackage is relatively young.
20:18:41 <eden> Thanks from the both of you. It's nice to know it's not gust me.and Begegal, I don't intend to give up either. For QPlaty, I mean that many people interested in haskell do give it up.
20:18:48 <jeffwheeler> Apocalisp: oh, I get the difference; I'll upload the better version
20:19:01 <Apocalisp> yay, I win :)
20:19:10 <MyCatVerbs> roconnor: probably not. More that Perl has a really, really strong documentation culture.
20:19:21 <roconnor> MyCatVerbs: interesting
20:19:41 <jeffwheeler> Apocalisp: yeah, that was clever; I remember wondering why you did that
20:20:02 <jeffwheeler> Probably should have asked. ;)
20:20:05 <MyCatVerbs> roconnor: I bet that when you get right down to it, at least half of languages' usefulness is really community culture.
20:20:15 <roconnor> actually, I haven't really had a problem with lack of documentation.  However, it does seem to be pretty bad when other people point out examples.
20:20:48 <copumpkin> Monoid up until recently had particularly terrible documentation
20:20:50 <MyCatVerbs> You may have set your standards for documentation too low as a result of being used to what's available to you.
20:20:52 <gwern> MyCatVerbs: in the trivial sense that libraries and tool support is determined by community...
20:21:00 <Cale> http://www.flickr.com/photos/thisdude62/908235443/sizes/o/ -- hehehe
20:21:05 <walter_> I am quite green on Haskell, a simple question, how to write a [string] to a file with writeFile
20:21:10 <MyCatVerbs> gwern: no, in the nontrivial sense too.
20:21:12 <copumpkin> lol
20:21:18 <MyCatVerbs> walter_: put it through concat or unlines first.
20:21:22 <copumpkin> :t writeFile
20:21:24 <lambdabot> FilePath -> String -> IO ()
20:21:32 <roconnor> MyCatVerbs: perhaps.  OTOH, I'm used to reading papers to understand haskell packages.  Are other people not doing this?
20:21:50 <walter_> <MyCatVerbs>, thanks
20:21:56 <Apocalisp> jeffwheeler: Thanks, no worries.
20:22:00 <gwern> walter_: hoogle is your friend
20:22:01 <copumpkin> most other common languages don't have PDF documentation, let alone papers explaining them
20:22:07 <gwern> @hoogle [String] -> String
20:22:07 <lambdabot> Prelude unlines :: [String] -> String
20:22:07 <lambdabot> Prelude unwords :: [String] -> String
20:22:07 <lambdabot> Data.List unlines :: [String] -> String
20:22:17 <MyCatVerbs> roconnor: That is not what most programmers tend to call "good" documentation. I mean I suppose it's great in one sense, but you'll notice that a lot of these papers drift away from the practical implementations in small details.
20:22:20 <gwern> copumpkin: they'd argue they don't *need* academic papers explaining them...
20:22:26 <copumpkin> yup
20:22:28 <jeffwheeler> @hoogle [String] -> IO ()
20:22:29 <lambdabot> Distribution.Make defaultMainArgs :: [String] -> IO ()
20:22:29 <lambdabot> Distribution.Simple defaultMainArgs :: [String] -> IO ()
20:22:29 <lambdabot> Distribution.Simple.Command noExtraFlags :: [String] -> IO ()
20:22:36 <jeffwheeler> @hoogle String -> IO ()
20:22:37 <lambdabot> Prelude putStr :: String -> IO ()
20:22:37 <lambdabot> Prelude putStrLn :: String -> IO ()
20:22:37 <lambdabot> System.IO putStr :: String -> IO ()
20:22:37 <copumpkin> in some cases, I'd rather have good reference documentation than a paper
20:22:43 <jeffwheeler> Forget it . . .
20:22:44 <copumpkin> but papers do serve a very important purpose in many cases
20:22:55 <gwern> jeffwheeler: you have to piecewise with hoogle
20:22:55 <Berengal> roconnor: I too read papers to understand packages, but papers really suck at being references
20:22:59 <gwern> *to go
20:23:13 <jeffwheeler> gwern: indeed
20:23:18 <walter_> gwern, thanks, hoogle great!
20:23:39 <hatds> plus, not every package is worthy of an academic paper ;)
20:24:00 <MyCatVerbs> But Perl has a culture of good documentation, I guess because Larry and friends act like documentation is important.
20:24:00 <Berengal> Papers are good at explaining what some piece of code does, why it's useful and the various use-cases, but it's not indexed
20:24:19 <MyCatVerbs> Haskell has a culture of being as helpful as possible to the newbies. That seems to come down from the top, too.
20:24:20 <roconnor> MyCatVerbs: I sort of understand what you are saying.  It is a bit odd because I read papers to understand fundamental concepts about new idea, then I have an idea about how I expect the interface to be, and it is usually pretty close.
20:25:09 <MyCatVerbs> roconnor: That might work great for Control.Arrow, perhaps, but it really is not how I want to learn to use Data.Graph or Graphics.OpenGL. :/
20:25:13 <Berengal> I'm delighted when I come across a package written in literate style
20:25:32 <eden> Papers (which I also enjoy reading) are good at giving the rationale for programmin ideas, but their examples are usually very artificial, and give you little idea of how to put them into practice.
20:25:37 <roconnor> For example, when I got how lens's work, I then had no problem learning how to use Data.Accessor (a great package btw)
20:26:27 <copumpkin> fgl is particularly painful
20:26:29 <roconnor> MyCatVerbs: oh, there is a nice paper on how inductive graphs work.
20:26:34 <copumpkin> because there is no documentation and the paper about it is ancient
20:26:41 <copumpkin> and doesn't correspond to the current library
20:26:42 <roconnor> MyCatVerbs: that's what Data.Graph is right?
20:26:52 <copumpkin> roconnor: I think you're talking about fgl
20:27:01 <roconnor> oh okay
20:27:07 <roconnor> what is Data.Graph?
20:27:23 <copumpkin> a less ambitious graph library that's also less daunting to get started with :P
20:27:29 <roconnor> bah
20:27:30 <walter_> <lambdabot>, thanks
20:27:35 <roconnor> go read the paper :)
20:27:42 <copumpkin> roconnor: I have read the fgl papers
20:27:52 <walter_> hoogle makes haskell more charming
20:28:07 <hackagebot> pointedlist 0.3.4
20:28:23 <MyCatVerbs> roconnor: yes, I was referring to fgl.
20:28:27 <jeffwheeler> Woah, that's neat.
20:28:30 <copumpkin> roconnor: they explain how inductive graphs work, but not how to use the library... there's a paper on how to use the library from a few years ago, but a lot of the API has changed so the paper is out of date
20:29:09 <Cale> I dislike both Data.Graph and the fgl, sadly. I always end up representing graphs using something like Map Vertex (Set Vertex) (where Vertex is whatever appropriate type)
20:29:13 <Berengal> copumpkin: There's another point. Papers aren't updated, usually
20:29:30 <eden> copumpkin:You've de
20:29:32 <MyCatVerbs> walter_: lambdabot is unlikely to appreciate your gratitude, as heartfelt as it may be. ;)
20:29:36 <copumpkin> yeah... it's easier to keep documentation in sync when it's just comments next to the code
20:29:51 <MyCatVerbs> copumpkin: \begin{code} and \end{code}! :D
20:29:55 <copumpkin> or that :)
20:30:02 <Cale> That's why papers should be written in literate Haskell :)
20:30:03 <Berengal> I'd also like to think literate comments are easy to keep up to date
20:30:16 <MyCatVerbs> You can compile LaTeX to HTML as well, right?
20:30:29 <MyCatVerbs> I mean, reasonably nice looking HTML?
20:30:41 <copumpkin> yeah, as long as people don't lamely patch .lhs files without paying attention to the flow
20:31:03 * MyCatVerbs lames all over copumpkin's .lhs.
20:31:07 <eden> copumpkin:You've described the an instance of the very problem I've been complaining about.
20:31:09 <copumpkin> lol
20:31:14 <Berengal> Literate comments are more likely to explain what and why, not how, so changing the how doesn't invalidate the comments
20:31:18 <copumpkin> eden: yup :) I definitely acknowledge that it's a problem
20:31:37 <walter_> <MyCatVerbs> , :)
20:31:49 <copumpkin> but having to figure out documentationless libraries is good for the soul
20:31:52 <SamB> see, this is why they ought to include the source to their papers in their library distributions ;-P
20:32:02 <copumpkin> back when I was a young haskell neophyte, I had to walk uphill both ways
20:32:16 <SamB> copumpkin: with wolverines strapped to your back?
20:32:20 <copumpkin> absolutely
20:32:32 <dmwit> Does anybody have some free time and wants to make a Haskell binding to GEGL?
20:32:33 * copumpkin is a child of the 6.10.1 era
20:32:36 <dmwit> That would be pretty awesome...
20:32:50 <gwern> what is GEGL and why do we want it?
20:32:57 * SamB thinks he started with 6.4
20:33:00 <copumpkin> :o
20:33:11 * copumpkin bows to the master
20:33:18 * Berengal started at 6.8.2
20:33:21 <gwern> I remember worrying about 6.6 compatibility, but that's as far back as I go :)
20:33:34 <dmwit> http://gegl.org/ It's a library for modifying large images (maybe bigger than can fit in memory) in a space-efficient way, by lazily loading the parts you're modifying and lazily applying transformations, etc.
20:33:56 <MyCatVerbs> dmwit: it's also a cow to build. x_x
20:34:00 <dmwit> I bet.
20:34:04 <dmwit> It looks like a complicated library.
20:34:08 <MyCatVerbs> dmwit: oh and the documentation makes me want to hurt people with hammers.
20:34:17 <MyCatVerbs> Spiky hammers.
20:34:20 <gwern> dmwit: is it c++?
20:34:25 <Berengal> MyCatVerbs: It says "go hurt people with hammers"?
20:34:36 <MyCatVerbs> gwern: no, it's straight C, IIRC. That much, I like about it.
20:34:37 <Berengal> "Hurting people with hammers is fun"
20:34:44 <Berengal> "I once hurt someone with a hammer. It was a great time"
20:34:51 <dmwit> gwern: I don't know, but the docs say its got a C API.
20:34:57 <gwern> mm
20:34:58 <dmwit> And I guess that's the part that really matters.
20:35:11 <Berengal> "You know, hammers are enviromental, unlike lead bullets and guns"
20:35:19 <MyCatVerbs> Berengal: "On the applicativity of hammers to faces and the fun to be experienced therein."
20:35:50 <Berengal> "When all you've got is a hammer, everyone looks like a nail"
20:36:18 * idnar hammers Berengal's nails in
20:36:40 <gwern> when all you have is birth control, everything looks like something you can safely have sex with.
20:36:56 <Cale> "Face-smashing monads on the category of injuries."
20:37:04 <MyCatVerbs> Berengal: "A User-Centric Extrospective Study on Hammers and their Impact on Modern Society."
20:37:22 <MyCatVerbs> (Extrospective because we did our research on other people.)
20:37:24 <Berengal> MyCatVerbs: "[...] and faces"
20:37:40 <MyCatVerbs> Hahaha, I have a better on.
20:37:57 <MyCatVerbs> s/Modern Society/the Market Price of Reconstructive Surgery/
20:38:03 <MyCatVerbs> *one
20:38:29 <roconnor> I wonder what it is like to have a desire to document.
20:38:45 <eden> I can't help  thinking hat it's a better idea to focus of how we go about improving things than making jokes about hammering, bet there we go, it might be just me
20:39:06 <roconnor> maybe I could somehow learn to appreciate it
20:39:07 <MyCatVerbs> roconnor: "Hot diggity! The code I just wrote is awesome on toast. I must write about it! Otherwise nobody will realise how awesome my code is. Yesyesyesyesyes MANPAGES."
20:39:26 <MyCatVerbs> roconnor: I have a vague suspicion that it might be very similar to the driving force behind blogging.
20:39:43 <MyCatVerbs> eden: but hammers are fun. :(
20:39:44 <roconnor> MyCatVerbs: I can imagine being like that.
20:40:00 <MyCatVerbs> roconnor: I need to trick myself into being like that more often. :)
20:40:00 <Berengal> roconnor: I never consider my code complete until I've thoroughly commented it. It's the best way to understand just what it is I've written as well
20:40:19 <roconnor> MyCatVerbs: but does that produce good documentation.  I usually find it hard to imagine what it is like to not understand my code.
20:40:21 <eden> MyCatverbs: and jokes absolve you of any responsbl
20:40:28 <MyCatVerbs> Berengal: bah. The *code* isn't complete until any given comment you might care to make is redundant, because it reads like prose.
20:40:30 <Berengal> And yes, the need to comment is very much similar to the need to blog
20:40:46 <Berengal> At least for me
20:40:50 <MyCatVerbs> Berengal: the *prokect* isn't complete until it's documented well enough that anyone else who needs to pick it up won't have trouble. :)
20:40:58 <MyCatVerbs> *project
20:41:02 <roconnor> eden: hey, do you have a moment to look at my documentation, and maybe critique it?
20:41:53 <MyCatVerbs> eden: please lighten up a little. The world probably won't end for at least another five minutes.
20:42:06 <Berengal> I've noticed that I sometimes tend to comment in a stream of consciousness style...
20:42:41 <MyCatVerbs> Berengal: I've given presentations in stream of consciousness style.
20:42:51 <dolio> So your comments read like Ulysses?
20:42:56 <hatds> I can always tell later when I've done that, because it will be full of spelling errors
20:42:58 <MyCatVerbs> Berengal: unfortunately my consciousness can be very depressing indeed. Didn't make for a particularly fun presentation. =D
20:43:01 <eden> roconnor: Ooh. A challenge. Since I've been complaining, I guesss I'm onour boundto say yes.Give me the link.
20:43:27 <roconnor> eden: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
20:43:55 <roconnor> eden: I'm not much into documentation culture, so the docs probably suck
20:44:16 <roconnor> eden: OTOH, I did write this to be used, so I kinda tried.
20:45:15 <Berengal> > {- Yeah, right so I need this fibs thing -}let  fibs = {- they start with a 0, then a 1 -} 0:1 {- and then continues on... -} : {- but how to do the rest of the fibs? I need to somehow match up two and two previous fibs, like zip, except zip only creates tuples. I could use zipWith (+) -} zipWith (+) fibs  {- And then I need to get the second element. tail should do it I think -} (tail fibs) {- yeah, that looks about right -} in fibs
20:45:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:45:40 <copumpkin> lol
20:45:51 <MyCatVerbs> Berengal: oh my dear eyeparsers.
20:45:57 <Berengal> :P
20:46:08 <copumpkin> -} : {-  is awesome
20:46:17 <eden> MyCatVerbs. No, I won't lighten up. Asking people to do so is usually a good indicator of dismissing ideas people are uncomfortable with.
20:46:19 <roconnor> Berengal: presumably eden is talking about package documentation rather than code documentation?
20:46:23 <MyCatVerbs> It looks unmentionable.
20:46:28 <copumpkin> o.O
20:46:52 <eden> Berangal, roconorr: Berngal is right.
20:47:00 <Berengal> roconnor: Aren't they the same?
20:47:01 <MyCatVerbs> eden: I'm not dismissing your ideas. You are right, our documentation needs improving more than we need hammer jokes.
20:47:06 <Berengal> Especially with haddock
20:47:20 <roconnor> Berengal: nope
20:48:01 <Berengal> roconnor: You mean like the overarching goal of the package?
20:48:13 <roconnor> Berengal: I mean like the public interface
20:48:22 <roconnor> rather than implementation details.
20:48:47 <Berengal> roconnor: That's the exported functions and types, which are code, and can be haddocked
20:49:12 <roconnor> Berengal: yes, but your fib example was mostly about implementation details.
20:49:41 <copumpkin> eden: I don't think anyone will deny that documentation in haskell is lacking, but we're also all in this for the fun of it and many packages are written by people for their own needs, and then released for general consumption... and no one likes writing documentation :) some packages are written specifically for public release in mind, but many aren't, and are thus lacking documentation
20:49:49 <Berengal> roconnor: My fib example was an example of stream of conciousness style commenting. Something, I should probably add, I don't think is a good idea in general :P
20:50:10 <roconnor> Berengal: okay.
20:50:16 <roconnor> Berengal: I mean I know you were not serious
20:50:49 <roconnor> Berengal: but I thought it was a sort of comment on eden's comments, but I see now that it wasn't really related.
20:52:46 <copumpkin> eden: but I don't think being so serious about the issue will change anyone's mind, especially if you act like "ooh I've struck a nerve, I'll keep at it". We've acknowledged that it's a problem but most of us don't get paid to promote haskell and I think most people enjoy trying new ideas than documenting existing ones
20:53:50 * copumpkin shrugs
20:54:05 <copumpkin> I feel the internet is getting rather full of "pop psych" these days
20:54:31 <Berengal> roconnor: I also believe it's important to document the implementation as well, especially for open-source packages like the ones on hackage. If a package almost does what I want but not quite, I'm much more likely to write my version from scratch than modify the existing package if the implementation details are lacking
20:54:47 <roconnor> Berengal: true.
20:56:38 <eden> copumkin: Well, I'd hope I would change people mind, but that's nearly always a losing battle. However, it wuld be nice to less serious about it, but that will take some programmers doing the right thing, and actually tackling the issue.
20:57:10 <copumpkin> well, for what it's worth, the first thing I did when I started working on an existing library I enjoyed, was write documentation for it :)
20:57:20 <copumpkin> it helped me get to know the internals better, and was a benefit to other people too
20:57:35 <copumpkin> well, it's not fully public yet, but it will help people eventually
20:57:37 <roconnor> eden: What would help me is to understand how the perl people are motivated.
20:58:04 <Berengal> roconnor: Otherwise unintelligeble code?
20:58:13 <roconnor> Berengal: possibly
20:58:30 <roconnor> Berengal: if so, that will make it more difficult to motivate Haskellers
20:59:08 <Berengal> What I'd like, as a first step at least, is for people to understand that type variables are no different than normal variables: Giving them longer names won't kill you
20:59:37 <Berengal> The only reason single-letter type variables work is because type expressions are usually short and very isolated
20:59:49 <roconnor> Berengal: my type variable are as long as my normal variables :P
21:00:03 <Berengal> but with multi-param typeclasses and other funky type stuff going on, that changes quickly
21:00:37 <eden> roconnor: Interesting question. I think it's just plain consideration for people who are in the same situation as the writer once was.
21:01:50 <copumpkin> it's a bit like hazing
21:02:03 <copumpkin> you might hate it while you go through it, but you still inflict it on others :P
21:02:27 <eden> Hazing is a bit
21:02:33 <copumpkin> (just kidding, but not compeltely)
21:02:38 <copumpkin> *completely
21:03:07 <roconnor> eden: hmm. I'm not sure.  I find MyCatVerbs's  "Hot diggity!" comment more compelling.
21:03:28 <eden> Hazing is a bit strong.. and I was in paicuar year of school where w decide to stoppeople at
21:03:47 <eden> eden aaargh.
21:03:58 <copumpkin> keyboard problems? :)
21:04:01 <MyCatVerbs> roconnor: what? What? What am I being accused of saying now? WHAT DID I DO? AAAaaaaagh! *runs around*
21:04:05 <hatds> using libraries is the hardest part of programming
21:04:06 <copumpkin> but yeah, I didn't mean it with all the strong connotations
21:04:29 <roconnor> [23:39] <MyCatVerbs> roconnor: "Hot diggity! The code I just wrote is awesome on toast. I must write about it! Otherwise nobody will realise how awesome my code is. Yesyesyesyesyes MANPAGES."
21:04:31 <hatds> enough focus is given formally specifying languages, but there is very little formal specification of libraries
21:04:44 <hatds> different problems though
21:05:03 <MyCatVerbs> roconnor: oh right, yes. It was hypothetical, though. I can't remember ever having felt exactly like that while hacking.
21:05:25 <roconnor> MyCatVerbs: It comes pretty close to the reason I documented my colour lib.
21:05:30 <MyCatVerbs> roconnor: most of the code that I've really enjoyed writing actually made me cackle at the time instead, and caused deep shame upon later reflection.
21:05:44 <MyCatVerbs> ;)
21:06:07 <Berengal> MyCatVerbs: I've felt like that when hacking. Well, after I was mostly done
21:06:19 <hatds> generally the more I enjoy a piece of code the quicker I end up hating it
21:06:37 <dmwit> Berengal: No problem, my type variables are just as long as my normal variables... and they're all one letter long.
21:06:40 <dmwit> Bwahahaha!
21:06:48 <hatds> the best line of code I've ever written?  That's gonna last till tomorrow, tops.
21:07:16 <dmwit> Oh, yes, clever programmers are their own enemy.
21:07:20 <eden> I keep hitting the return button by mistake.I do have some pride in being in  the year at school to stop the institutional bullying.We simply decided that we hated it, and wouldn't do it, even tough we had suffered from it. It takes some stegnth, but it can be done...
21:07:58 <hatds> yea hazing is for jerks
21:08:06 <hatds> good for you guys
21:08:18 <copumpkin> :)
21:08:26 <MyCatVerbs> eden: I've no perspective on this, having never been through anything like it myself, but congratulations.
21:12:31 <eden> MyCatVerbs: Cheers. It wasn't all clean tough, we git some of the upper yaers to give a hard time to te people who wanted to keep bullying the younger years, but on the whole it was a may improvement. It didn't start up again even after I'd left the place.
21:13:00 <MyCatVerbs> eden: three cheers for lasting progress, huh. ^_^
21:15:15 <ewwiz> greetings fellow haskel'ers
21:15:33 <eden> To be glib, It a bit like good documentation... doing the right thing for the right reasons.
21:15:45 <shapr> hiya ewwiz
21:15:55 <copumpkin> ewwiz ewwiz?
21:15:58 <shapr> ewwiz: Have you written lots of Haskell?
21:16:14 <copumpkin> (pronounced like who is ewwiz)
21:16:19 <ewwiz> not that much. in the process of learning
21:16:39 <ewwiz> i was thinking like oooh-iz
21:16:45 <ewwiz> but it's up for interpretation
21:16:50 <copumpkin> yeah :) that's how I saw it
21:17:02 <mhaggag> Hello, another quick question. Is there a way, when installing a package from hackage, to get cabal to recursively download and install dependencies?
21:17:24 <mhaggag> (I'm trying to run Yi, but there's a ton of dependencies missing..)
21:17:28 <eden> eihter way, It's for in the morning and time to go to bed...
21:18:18 <MyCatVerbs> mhaggag: cabal install does that.
21:18:40 <ewwiz> i'm surprised how many participants are in this chat
21:18:42 <ewwiz> over 500
21:18:44 <MyCatVerbs> mhaggag: but it can't do anything about missing non-Haskell libraries, unfortunately.
21:19:06 <mhaggag> Hmm...can you elaborate a bit more? (Sorry, absolute noob here. I'm trying to follow the instructions on Yi/Hackage)
21:19:09 <roconnor> @lusers
21:19:09 <lambdabot> Maximum users seen in #haskell: 658, currently: 560 (85.1%), active: 16 (2.9%)
21:19:14 <MyCatVerbs> ewwiz: we're aiming for nine tho-er, I mean, people have been doing their best to grow this little community. It seems to have been working.
21:19:18 <hatds> hm, are there binaries available for Yi?
21:19:19 <mhaggag> What's the difference between "cabal install" and the configure/build/install sequence?
21:19:33 <roconnor> mhaggag: cabal install fetches dependencies
21:21:04 <mhaggag> I see. So in theory, I should be able to install cabal-install and use it to fetch the dependencies?
21:21:22 <mhaggag> (Do package manitainers have to do something special for this to work?)
21:21:27 <roconnor> it only fetches dependencies available on hackage.
21:21:38 <shapr> ewwiz: #haskell r0xx0rz!
21:21:50 <mhaggag> roconnor: I see, thanks.
21:22:19 <jmcarthur> mhaggag: maintainers must list the package's direct dependencies in the package's .cabal file
21:22:28 <jmcarthur> mhaggag: which you are supposed to do anyway
21:22:30 <shapr> ewwiz: Lots of people working hard to make this community.
21:23:37 <ewwiz> that's awesome
21:23:59 <mhaggag> jmcarthur: I see. So in theory I should be able to install yi that way, since it already lists its dependencies.
21:24:14 <jmcarthur> yeah #haskell is by far the most helpful, friendly, entertaining, intelligent crowd on irc ;)
21:24:22 <roconnor> ewwiz: shapr built the foundations of this community
21:24:42 <jmcarthur> mhaggag: there is no guarantee that those dependencies are also on hackage, but usually they are
21:24:51 <shapr> But nowadays, people like dons put in all the work!
21:24:56 <shapr> I am now an irresponsible parasite! w00!
21:24:59 <SamB> roconnor: or at least kept them from picking on the newbies ;-)
21:25:15 <roconnor> SamB: it was (and is) an important job
21:25:22 <ewwiz> are all of you guys professional programmers too or just doing haskell as a hobby?
21:25:25 <shapr> g'day twb
21:25:48 <SamB> well, I mean, he didn't actually design or build any of the people in this channel
21:25:49 <adu> hi
21:25:50 <Berengal> ewwiz: Can't we do both? :P
21:25:54 <shapr> I'm a professional programmer for a lot of years, but I have had a Haskell job for a year.
21:25:56 <jmcarthur> some of us use it professionally. i'm just a hobbyist right now, but there is always a chance i can sneak it in at work ;)
21:25:57 <SamB> though he did used to be a lambdabot maintainer, I think
21:26:31 <shapr> Yeah, I wrote the original plugin system for lambdabot, and hosted lambdabot for a few years.
21:26:43 <gwern> nobody is a lambdabot maintainer; they just sort of fake knowing what's going on in the codebase
21:26:45 <Berengal> It's possible to write haskell in any language. Painful in some, but possible...
21:26:54 * jmcarthur was designed and built by shapr
21:26:58 <shapr> :-P
21:27:06 <shapr> I haven't looked at the lambdabot sources much since I was maintainer.
21:27:16 <SamB> gwern: well, you know, the person who lets people break lambdabot
21:27:32 <shapr> Berengal: I've tried to write Haskell in C#, didn't turn out so well.
21:27:39 <twb> Is there a better way to say "do f; return ()" ?
21:27:39 <roconnor> Berengal: you can put a static type system into Python?
21:27:51 <SamB> roconnor: I think you can
21:27:52 <dmwit> twb: no
21:27:54 <shapr> You can actually, there's some neat research about that.
21:27:58 <Berengal> roconnor: You can pretend to...
21:28:00 <twb> Bleh
21:28:02 <roconnor> SamB: you mean by writing an external tool?
21:28:05 <dmwit> twb: Unless you consider "f >> return ()" better. =)
21:28:09 <SamB> those PyPy people, I think, did something of that nature ...
21:28:13 <roconnor> ok
21:28:13 <SamB> or are doing
21:28:17 * shapr hugs twb
21:28:25 <SamB> dunno how it works
21:28:33 <twb> shapr: easy there, big fella
21:28:44 <SamB> but it makes sense if you're trying to write a Python implementation in "Python", doesn't it?
21:28:59 <shapr> twb: I'm friendly, what can I say? :-)
21:29:04 <MyCatVerbs> Berengal: not really. Most languages don't give you Turing-complete type systems.
21:29:09 <roconnor> twb: do f; return () or f >> return ()  is not all that uncommon.
21:29:23 <jmcarthur> :t (<$)
21:29:25 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
21:29:37 <SamB> MyCatVerbs: haskell doesn't either, without unsafePerformTypeclass...
21:29:42 <SamB> er. well, something like that ;-P
21:30:06 <jmcarthur> :t () <$ Just 5
21:30:07 <lambdabot> Maybe ()
21:30:08 <adu__> yes
21:30:15 <jmcarthur> :t Just 5 >> return ()
21:30:16 <lambdabot> Maybe ()
21:30:18 <MyCatVerbs> SamB: overlapping and undecidable instances and MPTC, but I'd argue that they're as good as part of the language now.
21:30:40 <MyCatVerbs> SamB: just, not actually switched on by default, since they're too powerful for everyday usage.
21:30:40 <SamB> MyCatVerbs: not quite
21:30:48 <SamB> I don't remember them being written up quite as well
21:30:53 <jmcarthur> twb: ^^
21:31:08 <jmcarthur> () <$ f
21:31:16 <MyCatVerbs> SamB: this is true. But that's not to say that they aren't used and supported well enough.
21:31:42 <dmwit> jmcarthur is bringing Perl to Haskell, one miscalibrated modem at a time
21:31:59 <SamB> lol
21:32:07 <Berengal> Control.Applicative.Perl ?
21:32:17 <SamB> dmwit: did you know that perl code is, in fact, NOT just line noise?
21:32:25 <SamB> that's a common misconception
21:32:35 <dmwit> Oh, is it line noise at a specific baud rate, then?
21:32:41 <jmcarthur> SamB: you're full of crap
21:32:54 <SamB> dmwit: no! it actually MEANS *something*
21:32:57 <SamB> sometimes
21:33:00 <SamB> in the right context
21:33:06 <Berengal> Meh, Java has the worst signal/noise of the languages I've used...
21:33:43 <mauke> Haskell code is harder to read than Perl code
21:33:43 <jmcarthur> Berengal: c++ fares even worse for me
21:34:12 <Berengal> jmcarthur: Haven't done C++ so I couldn't say
21:34:18 <mauke> custom operators and sections give you all the line noise you need
21:34:23 <adu___> > (+) 1 2
21:34:24 <lambdabot>   3
21:34:26 <jmcarthur> Berengal: lucky
21:34:36 <adu___> > showIntAtBase 13 (" .begiklnortu"!!) 21086968406045718508607583582 ""
21:34:38 <lambdabot>   "but i like being broken..."
21:34:39 <Berengal> jmcarthur: Yes, I consider myself that
21:35:06 <MyCatVerbs> jmcarthur: Java isn't noisy, IMO. Rather, it has exceedingly low information content per byte.
21:35:06 <SamB> jmcarthur: the problem I have with C++ is that the signal isn't even in the code you write, always ...
21:35:24 <SamB> it's often in the code the compiler assumes you meant
21:35:49 <SamB> )and all too often, that signal is SIGSEGV ;-(
21:35:54 <Berengal> MyCatVerbs: That's what I mean by signal/noise
21:36:13 <MyCatVerbs> Berengal: noise *is* information. Java code carries exceedingly little information per byte. :)
21:36:25 <jmcarthur> MyCatVerbs: true. java is more like a very low volume signal than it is a signal drowned out by noise
21:36:34 <MyCatVerbs> Berengal: regularly structured code isn't really noise, even if it does encode very little of use.
21:37:31 <Berengal> MyCatVerbs: I don't know about you, but I consider the abhorringly long and repeated types to be noise
21:37:41 <jmcarthur> one good thing about java is the source code compresses well ;)
21:37:57 * MyCatVerbs thwaps Berengal with Shannon.
21:38:37 <copumpkin> someone should run lzma on the same algorithm implemented idiomatically in different languages
21:38:50 <monochrom> hehehe
21:39:15 <MyCatVerbs> Berengal: you might "consider..." but that's not what noise *is*. Java code *cannot* be noisy precisely because it has such atrociously low unpredictability because of all the repetition. :)
21:39:26 <jmcarthur> doesn't the shootout compare gzipped source file sizes?
21:39:34 <MyCatVerbs> Yep.
21:39:41 <jmcarthur> of course, the shootout isn't _idiomatic_ code
21:40:01 <Berengal> MyCatVerbs: Don't get technical with me now :P
21:40:20 <MyCatVerbs> Berengal: ;-;
21:40:20 <jmcarthur> i think it would be more interesting to compare compression ratios rather than final compressed size
21:40:33 <MyCatVerbs> Technical is all I have to get, other than just plain stupid.
21:40:48 <Berengal> What's noise when you're reading code is different from what's noise when interpreted as a signal
21:41:22 <twb> @pl \ p q r s -> f p q r s >> f p q r s
21:41:22 <lambdabot> ap (ap . (liftM2 (liftM2 (>>)) .) . f) f
21:41:24 <MyCatVerbs> Berengal: I'm going to have to engrave "Claude Shannon" on the side of a foam baseball bat and start hitting people with it, aren't I?
21:41:35 <twb> @pl \ p q r s -> f p q r s >> g p q r s
21:41:35 <lambdabot> ap (ap . (liftM2 (liftM2 (>>)) .) . f) g
21:41:52 <mauke> preflex: calc '36 2'100011000100100101101001101011101001
21:41:52 <preflex>  haskell
21:42:15 <adu> mauke: ooo
21:43:01 <copumpkin> twb: that seems like it should be nicer than that
21:43:07 <Berengal> MyCatVerbs: If you'd like, but why stop at foam?
21:43:21 <MyCatVerbs> Pacifism, mixed with cowardice.
21:43:21 <adu> > showIntAtBase 15 (" :?adehikmotuwy"!!) 35057979013641215828658211984217 ""
21:43:23 <lambdabot>   "mauke: how did you do that?"
21:43:40 <copumpkin> :t \ p q r s -> f p q r s >> f p q r s
21:43:42 <lambdabot> forall t t1 t2 t3 (m :: * -> *) a b. (SimpleReflect.FromExpr (t -> t1 -> t2 -> t3 -> m a), SimpleReflect.FromExpr (t -> t1 -> t2 -> t3 -> m b), Monad m) => t -> t1 -> t2 -> t3 -> m b
21:43:52 <mauke> preflex: calc '36 37439508
21:43:53 <preflex>  magic
21:43:56 <copumpkin> :t \f p q r s -> f p q r s >> f p q r s
21:43:57 <lambdabot> forall t t1 t2 t3 (m :: * -> *) a. (Monad m) => (t -> t1 -> t2 -> t3 -> m a) -> t -> t1 -> t2 -> t3 -> m a
21:44:20 <mmorrow> @type join (>>)
21:44:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
21:44:42 <mmorrow> @type join (>>) :: (Monad m) => (t -> t1 -> t2 -> t3 -> m a) -> t -> t1 -> t2 -> t3 -> m a
21:44:43 <lambdabot> forall t t1 t2 t3 (m :: * -> *) a. (Monad m) => (t -> t1 -> t2 -> t3 -> m a) -> t -> t1 -> t2 -> t3 -> m a
21:45:02 <mmorrow> (->) (>>=) ftw!
21:45:10 <adu> preflex help
21:45:11 <preflex>  try 'help help' or see 'list' for available commands
21:45:25 <Berengal> MyCatVerbs: I read that as "mixed with concrete" for a second :/
21:46:15 <MyCatVerbs> Berengal: now you are making me hungry.
21:47:18 <copumpkin> :)
21:50:26 <dmwit> (\c -> maybe (return []) c (peek priorityQueue)) $ do {- ... -}
21:50:27 * ewwiz tosses MyCatVerbs a reeses
21:50:29 <ewwiz> jeje
21:50:29 <dmwit> I feel vaguely dirty.
21:51:11 <MyCatVerbs> Danke, ewwiz.
21:51:17 <dmwit> Not least because I forgot the "\v ->" before that do.
21:52:32 <twb> I really, really hate it the way that Cabal will go ahead and install a newer version of e.g. filepath, so that packages installed via cabal can't be used with packages installed via Debian
21:53:32 <SamB> twb: so you want to be able to "pin" packages ?
21:53:36 <twb> Hmm, bizarrely, I can just ghc-pkg unregister old-time and filepath... even though "cabal upgrade Cabal" forced me to install them, it apparently doesn't need them.
21:53:40 <twb> SamB: basically, yeah
21:54:21 <twb> SamB: actually the IDEAL solution would be for Debian to have working Haskell packages
21:54:34 <SamB> twb: working how ?
21:54:41 <twb> It seems that two weeks in every three, most packages are awaiting binNMU due to a GHC update
21:55:04 <twb> So even of the subset of packages that are in apt, I can't install most of them.
21:55:09 <SamB> oh
21:55:16 <SamB> why can't they autobuild those ...?
21:55:31 <twb> SamB: because then there wouldn't be adequate quality assurance.
21:56:00 <SamB> ... test suites ?
21:56:18 <twb> No, quality assurance of the packaging.
21:56:52 <SamB> but there's no quality if there is no installable package ...
22:03:32 <dmwit> What the deuce?
22:04:19 <SamB> dmwit: what ?
22:04:47 <dmwit> I have a piece of code like
22:05:03 <dmwit> do { modify (\g -> blah blah blah); blah blah blah }
22:05:25 <dmwit> If I factor out the (\g -> blah blah blah) and name it, I get an error.
22:05:44 <twb> dmwit: blah blah blah is probably an infinite type
22:05:55 <dmwit> Urk, nope, it was the MR.
22:06:06 <dmwit> But the error message is incomprehensible.
22:06:15 <MyCatVerbs> twb: in which case he should be getting the error anyay anyway with the lambda. >>
22:06:16 <dmwit> "No instance for (MonadState (Grid i) m)"
22:06:43 <dmwit> But the type of another (perfectly satisfactory) identifier is MonadState (Grid i) m => m [Time]
22:06:49 <dmwit> So what is that supposed to mean?
22:07:11 <mauke> it wants to monomorph m but doesn't know how
22:07:40 <dmwit> How come it doesn't want to monomorph the other identifier?
22:07:45 <dmwit> There's no type signature on it.
22:08:00 <Cale> Is it a function binding?
22:08:11 <Cale> Or a pattern binding?
22:08:44 <dmwit> The acceptable one is a function binding; the unacceptable one is a (value) binding.
22:08:58 <Cale> Right. The MR only applies to pattern bindings.
22:09:05 <dmwit> oh
22:09:10 <Cale> If it has parameters, then the MR doesn't apply.
22:09:12 <dmwit> right
22:09:23 <dmwit> ok, ok
22:09:30 <dmwit> The MR is bewildering. =)
22:09:53 <MyCatVerbs> Thank Simon it's getting thrown out soon.
22:10:28 <MyCatVerbs> (If you ask me which Simon, the only response you will get is "yes". ;))
22:10:43 <dolio> Soon?
22:10:45 <mauke> [Simon]
22:10:58 <Cale> I wonder how many total hours people have wasted in confusion caused by the MR.
22:11:26 <twb> @MR
22:11:26 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
22:11:36 <twb> @wtf MR
22:11:36 <lambdabot> Maybe you meant: bf ft wn
22:11:38 <twb> Bah.
22:11:49 <Cale> Monomorphism Restriction
22:11:52 <Cale> @where mr
22:11:53 <lambdabot> I know nothing about mr.
22:11:54 <Cale> hmm
22:12:07 <dmwit> ?wiki MonomorphismRestriction
22:12:07 <lambdabot> http://www.haskell.org/haskellwiki/MonomorphismRestriction
22:12:27 <Cale> http://haskell.org/onlinereport/decls.html#sect4.5.5
22:12:43 <Cale> @where+ mr http://haskell.org/onlinereport/decls.html#sect4.5.5
22:12:43 <lambdabot> Okay.
22:13:58 <Berengal> Is there a proper 'solution' to polymorphic values?
22:14:12 <Cale> Let them be polymorphic?
22:14:26 <dmwit> Berengal: Add a type signature, or use the NoMonomorphismRestriction pragma.
22:14:45 <dolio> Get rid of mutability.
22:14:50 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}
22:14:54 <Cale> mutability?
22:14:57 <Berengal> Cale: I don't want the result of genericLength to be polymorphic
22:15:05 <Cale> Berengal: huh?
22:15:08 <dolio> (If you're ML.)
22:15:09 <Cale> Berengal: Why not?
22:15:29 <Berengal> Cale: let x = genericLength [1..10000] in (x `div` 2, x / 2)
22:16:08 <Cale> Berengal: that works fine, what's wrong with it?
22:16:09 <Berengal> Guess how many times the function will run
22:16:20 <Cale> genericLength will be computed twice, of course
22:16:47 <Cale> x will need to be evaluated once at every place where its type is specialised.
22:16:56 <dolio> > genericLength [1..10000000] :: Int
22:16:58 <lambdabot>   * Exception: stack overflow
22:16:58 <Berengal> Yes, I'd like for that not to happen
22:17:02 <Cale> Huh?
22:17:12 <Cale> It *has* to happen, or your program is meaningless.
22:17:41 <Berengal> Then I'd prefer it to be meaningless
22:17:46 <Cale> At least so long as there's no type on which / and `div` are defined
22:18:02 <Cale> Why would you prefer that?
22:18:13 <Berengal> Because I wouldn't want it to be computed twice
22:18:17 <Cale> How is it any worse than the situation with:
22:18:24 <dmwit> Berengal: An explicit type signature can specialize a polymorphic type.
22:18:38 <Cale> let x n = genericLength [1..n] in (x 10000 `div` 2, x 10000 / 2)
22:18:51 <dmwit> let x :: Integer; x = genericLength [1..10000] in (x `div` 2, x / 2) -- gives a type error
22:19:06 <Berengal> dmwit: Yes, I know, but I'm not in the habbit of putting type signatures on every expression
22:19:09 <Cale> Yes, and x will not be recomputed, because it's not polymorphic then.
22:19:19 <dmwit> Berengal: Just put it on the ones you want to be careful about recomputing.
22:19:25 <dmwit> Berengal: That is the solution.
22:19:31 <dmwit> Dunno what else you want from us.
22:20:09 <Berengal> dmwit: I'd rather the compiler told me about those than have to keep track of them myself. It's sort of the same reason we've got strong static typing, if you squint a bit
22:20:41 <Berengal> I agree that most of the time the MR just gets in the way, and I usually turn it off. There are however cases where I'd like it turned on
22:21:27 <ski> (`let x = ... in (x `div` 2, x / 2) :: (Integral i,Fractional q) => (i,q)' could be treated differently from `let x = ... in (x `div` 2, x / 2) :: (Integral a,Fractional a) => (a,a)' by the compiler ..)
22:21:52 <Cale> :t let x = genericLength [1..10000] in (x `div` 2, x / 2)
22:21:54 <lambdabot> forall i i1. (Integral i, Fractional i1) => (i, i1)
22:22:13 <Cale> I think it's pretty obvious from the type that two separate values are being computed there.
22:23:02 <Cale> We just need to get over the silly idea that just because something is a pattern binding that means it's a constant which can never be recomputed.
22:23:15 <Cale> Nothing in the language spec even guarantees that anyway.
22:23:16 <copumpkin>  :t (\x -> (x `div` 2, x / 2)) $ genericLength [1..10000]
22:23:34 <copumpkin> :(
22:23:37 <Cale> :t (\x -> (x `div` 2, x / 2)) $ genericLength [1..10000]
22:23:39 <lambdabot> forall a. (Fractional a, Integral a) => (a, a)
22:23:45 <copumpkin> why doesn't it like me?
22:23:50 <Cale> Because of the space
22:23:50 <ski> copumpkin : spacing
22:24:00 <copumpkin> oh my silly client doesn't even show that
22:24:04 * copumpkin slaps his client
22:24:21 <Berengal> Cale: It's not always that obvious though. Say you needed the length for three different expressions, each which just so happened to be using a different numeric type from the two others, and all of these expressions were sub-expressions, and thus not given a type signature
22:24:26 <copumpkin> (linkinus)
22:24:29 <ski> @slap copumpkin's-client
22:24:29 * lambdabot pushes copumpkin's-client from his chair
22:24:37 <copumpkin> :o
22:24:41 <Cale> Berengal: huh?
22:24:45 <dmwit> Yeah!  Get out of lambdabot's chair!
22:25:10 <Cale> Berengal: oh, well, then my program would at least work.
22:25:25 <ski> (fsvo work :)
22:25:41 <Cale> If it was a performance problem, I would look into it, and see that it was being re-evaluated and pick a monomorphic type.
22:26:21 <Cale> But I think it's a somewhat unlikely scenario regardless. Usually you know what types you're applying something at.
22:26:32 <Berengal> Cale: It'd also "work" if you removed the type system, or didn't bother to type-check
22:26:33 <ewwiz> perms, they're making up functions
22:26:46 <Cale> Berengal: Actually, it wouldn't.
22:26:56 <Berengal> Cale: But yeah, the scenario is unlikely, but not impossible
22:26:59 <Cale> Berengal: Because without a type system, typeclasses don't work.
22:27:11 <Cale> and so you can't have polymorphic constants like that
22:27:20 <Berengal> Cale: That's what weak typing is for
22:27:25 <Cale> Huh?
22:27:35 <Cale> No, it would just be entirely broken
22:27:49 <Berengal> Tagged values and implicit conversion?
22:27:58 <Cale> Because it would either be an integer or a floating point number, and the casting would result in a misinterpretation of the data.
22:27:59 <Berengal> It'd work fine in python, is what I'm saying
22:28:07 <dolio> Without a type system you have to pass dictionaries manually.
22:28:07 <Cale> Ah.
22:28:15 <dmwit> You're really espousing implicit conversion as a solution to the monomorphism restriction?
22:28:23 <twb> "Weak" typing is where every value is a always string, and each function implicitly attempts to convert that string to the desired type internally.
22:28:44 <dmwit> tcl!
22:28:45 <dmwit> yeah!
22:28:54 <twb> I was thinking sh, but whatever.
22:29:00 <MyCatVerbs> IIRC there are at least three or four TCL interpreters in Haskell.
22:29:04 <MyCatVerbs> Written in, I mean.
22:29:22 <twb> MyCatVerbs: so TCL isn't even self-hosted?  It must be shit, then :-)
22:29:51 <Cale> Hey, that's not fair, there are lots of decent languages for which self-hosting is an impossibility :)
22:29:55 <Berengal> dmwit: Nah, not really. I'm being somewhat more extreme than where my real opinions lie
22:30:04 <Cale> Like every language which isn't Turing complete :)
22:31:12 <Cale> Anyhow, I've turned the MR off in my .ghci and I always just turn it off at the module/package level if there's any trouble.
22:31:15 <hatds> how do people feel over monomorphic pattern bindings?
22:31:22 <hatds> http://haskell.org/ghc/docs/latest/html/users_guide/monomorphism.html
22:31:56 <dmwit> Cale: Nonsense, HQ9x+S is self-hosting but not Turing-complete.
22:32:28 <dmwit> Whoops, how did that 'x' get in there?
22:32:48 <MyCatVerbs> dmwit: it's the x combinator? :D
22:33:02 <Cale> hatds: Eh, maybe it's okay. I still think it's a bit unnatural.
22:33:13 <roconnor> is ./foo | sort | uniq the typical way of using uniq?
22:33:41 <dmwit> yes
22:34:01 <dmwit> There is no nub-alike feature in uniq.
22:34:26 <dmwit> However, ghc -e "interact (unlines . nub . lines)" gets you that. ;-)
22:34:31 <roconnor> :(
22:34:34 <roconnor> :)
22:35:16 <roconnor> $ ghc
22:35:16 <MyCatVerbs> roconnor: sort -u does uniq's job too.
22:35:17 <roconnor> -bash: ghc: command not found
22:35:19 <roconnor> aw crap
22:35:32 <roconnor> so uniq should never be run
22:35:34 <roconnor> well
22:35:38 <roconnor> I guess if it is already sorted
22:35:40 <twb> roconnor: uniq -c is useful
22:35:47 <roconnor> what's that?
22:35:51 <twb> RTFM?
22:36:01 <roconnor> bah I'm to lazy
22:36:09 <roconnor> I'll just take your word for it
22:36:11 <inimino> uniq -u is also very useful
22:36:17 <dmwit> I'll read it for you.
22:36:23 <dmwit> uniq -c counts the number of duplicates.
22:36:34 <roconnor> oh
22:36:51 <twb> It's (length &&& head) . groupBy
22:36:59 <dmwit> inimino: I don't understand; how is uniq different from uniq -u?
22:37:00 <roconnor> right
22:37:04 <twb> Sorry, s/By//
22:37:08 <inimino> cat a b b | sort | uniq -u # set difference
22:37:20 <dmwit> oooh
22:37:58 <dmwit> cat a b | sort | uniq -u # symmetric difference?
22:38:02 <inimino> it only prints lines which appear only once
22:38:10 <inimino> dmwit: yep
22:38:17 <dmwit> Assuming a and b really are sets, I guess.
22:38:24 <inimino> right
22:39:01 <inimino> assuming no duplicates, which you can always guarantee with ... well you know ;-)
22:39:04 <twb> The sh program I never use enough is paste (and join).
22:39:40 <roconnor> hmm
22:39:51 <roconnor> apparently there is an icombinator.net
22:39:58 <inimino> I don't think I've ever used paste
22:47:13 <roconnor> I know this has probably been said before, but twitter is very weird.
22:47:36 <roconnor> in particular trying to follow twitter conversations
22:49:40 <ski> bad reimplementation of threads ?
22:49:43 <dmwit> ?pl \g -> rnf (seqNo g) `seq` rnf (edges g) `seq` rnf (updates g)
22:49:43 <lambdabot> ap (seq . ap (seq . rnf . seqNo) (rnf . edges)) (rnf . updates)
22:49:50 <dmwit> yuck
22:50:09 <roconnor> ski: the worst implementation of threads :)
22:50:16 <dmwit> :t seq `on` rnf
22:50:17 <lambdabot> forall a. (NFData a) => a -> a -> Done
22:50:21 <dmwit> ooo
22:50:30 <dmwit> close...
22:50:33 <roconnor> ski: all comments are sorted by author.
22:50:38 <roconnor> then by time
22:50:50 <roconnor> not by topic :)
22:50:50 <dmwit> Oh, no, not that close.
22:51:24 * ski recalls <http://www.rants.org/2008/03/06/thread_theory/>
22:52:07 <copumpkin> :t seq `using` rnf
22:52:08 <lambdabot> forall a t. (NFData (a -> t -> t)) => a -> t -> t
22:52:12 <copumpkin> boo
22:54:02 <copumpkin> :t (compare `on`)
22:54:04 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
22:54:04 <copumpkin> :t comparing
22:54:06 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:58:02 <dmwit> Aha!
22:58:17 <dmwit> ?pl \g -> rnf (seqNo g, edges g, updates g)
22:58:17 <lambdabot> rnf . ap (liftM2 (,,) seqNo edges) updates
22:58:33 <dmwit> Still ugly, but the pointed version is much nicer.
22:58:42 * jmcarthur finally found an excuse to use (<=<) and suddenly realized that other cases for using it have been everywhere the whole time
22:59:57 <jmcarthur> it was random. something i wanted didn't type check, so i threw a <=< in there where i thought it made sense and all was well with the world
23:00:11 <jmcarthur> and now everything is a candidate for <=<
23:01:48 <copumpkin> yeah I found the same thing
23:01:59 <copumpkin> it looked silly until Cale explained it to me and now I want to use it everywhere
23:02:21 <copumpkin> or was it Cale? someone, anyway :)
23:02:34 <jmcarthur> i believe i recall the conversation
23:03:17 <jmcarthur> i already knew about it at the time, and even knew where i might apply it, but i hadn't used it then and didn't all the way until now
23:03:39 <copumpkin> I love it when things suddenly make sense :P
23:03:51 * copumpkin looks forward to more such feelings
23:04:13 <Peaker> maybe <=< indicates you should be using an arrow or category?
23:04:59 <jmcarthur> already looked into that, but i think that would be overkill for this particular scenario
23:05:12 <copumpkin> it's prettier with <=< than Kleisli and <<< though
23:05:17 <jmcarthur> this was just about making some code point free
23:06:22 <ewwiz> i'm a programmer. going to make the big bucks!
23:06:26 <jmcarthur> i like it when i can consider the operators invisible and just read the identifiers from right to left and get a story of how the function works
23:06:46 <copumpkin> ewwiz: to make the big bucks, you must first understand kleisli composition!
23:06:50 <copumpkin> or something like that
23:07:19 <copumpkin> or to understand the fixpoint combinator, you must first understand the fixpoint combinator
23:07:24 * copumpkin shrugs
23:07:38 <jmcarthur> i hate the flip function
23:07:46 <copumpkin> how com?
23:07:56 <jmcarthur> if i have to use flip to make something point free, i usually just don't make it point free
23:08:01 <Gracenotes> hm. it does make for some unreadable code.
23:08:07 <jmcarthur> it's intrusive, in the way i read code
23:08:09 <Zao> I find it quite convenient for rearranging arguments.
23:08:22 <copumpkin> I generally draw the line at two flips nearby
23:08:24 <jmcarthur> it makes me have to stop reading so i can back up and try again
23:08:26 <Gracenotes> imho it should only be used for functions with two 'arguments' (used informally)
23:08:29 <Zao> f (\x -> nine thousand line function) foo
23:08:30 <ewwiz> flip flops?
23:08:46 <Berengal> A flip every now and then isn't too bad, but I try to keep them at a minimum
23:08:48 <ewwiz> like a D flip flop?
23:08:55 <ski>   (`f` foo) $ \x -> nine thousand line function
23:08:56 <Gracenotes> a function that returns a function that returns a function that does not return a function
23:09:05 <copumpkin> how about functions called permute21, permute213, permute3142, and so on?
23:09:07 <copumpkin> a bunch of them :P
23:09:11 <jmcarthur> ewwiz: new to haskell?
23:09:13 <Zao> ski: That made my head hurt a bit.
23:09:14 <jmcarthur> :t flip
23:09:15 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:09:38 <jmcarthur> i find ski's notation _slightly_ easier to read, but i avoid it too
23:09:41 <ski> Zao : i used that a bit before `forM' came into being
23:09:44 <ewwiz> jmcarthur - just a little bit
23:09:48 * Gracenotes smites copumpkin with caddrarararrradr
23:09:52 <copumpkin> lol
23:09:52 <ski> (still use it for some cases)
23:09:55 <Zao> copumpkin: Once upon a time I used pointlessness to move an argument from being last to being the first argument.
23:10:02 <copumpkin> :)
23:10:04 <Gracenotes> heck, I don't even know what the extra r's are for
23:10:07 <Zao> copumpkin: If you squinted, my code was full of ascii boobs.
23:10:09 <copumpkin> I think that naming scheme seems reasonable though
23:10:14 <Gracenotes> cdadadaddddaaaaaaaaaddar
23:10:26 <Gracenotes> for those intricate data structure
23:10:35 <Gracenotes> s
23:10:50 <ski> huffman-encoded field access ?
23:11:12 <Zao> @pl \f a b c d e -> f e a b c d
23:11:12 <Gracenotes> quite possibly
23:11:13 <lambdabot> (((((flip .) . flip) .) . flip) .) . flip
23:11:17 <jmcarthur> i think rot functions might be easier to follow than permute, and even then i would never use them
23:11:32 <Zao> copumpkin: Would that break your flip comfort zone?
23:11:33 <copumpkin> well, rot functions would be a special case of the permute functions :P
23:11:39 <copumpkin> Zao: definitely
23:11:48 <Gracenotes> in Factor, rot functions are actually considered a sort of code smell
23:11:50 <ewwiz> has anyone ever used the book "Haskell, the craft of functional programming" by simon thompson?
23:11:58 <ski> yes
23:12:13 <jmcarthur> Gracenotes: i've never programmed in forth or factor, but i would think so as well!
23:12:24 <ewwiz> ski - is that a good book or are there better ones to learn from?
23:12:31 <Gracenotes> I always find similarities between pointless style in Haskell and stack-oriented style
23:12:44 <jmcarthur> Gracenotes: me too!
23:12:59 <jmcarthur> "do this, then do this to the result, then to this to that result, then ..."
23:13:03 <ski> ewwiz : i found it useful .. never really compared with others
23:13:14 <Gracenotes> jmcarthur: yep. It's generally called the 'applicative' style
23:13:21 <jmcarthur> right
23:13:27 <ewwiz> ski  - k, thx for the info
23:13:29 <Gracenotes> argument order can be a bitch, though
23:13:50 <jmcarthur> :t flip flip flip flip flip flip
23:13:52 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
23:14:02 <jmcarthur> fix anything
23:14:06 <ski> ewwiz : the "Haskell School of Expression" might be interesting if media examples strikes your fancy
23:14:10 <copumpkin> :t flip
23:14:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:14:22 <ski> ewwiz : there's a recent "Real World Haskell", too
23:14:32 <Gracenotes> :t flip . flip . flip . flip . flip . flip
23:14:33 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
23:14:34 <Gracenotes> noo
23:14:39 <Gracenotes> ... hm
23:14:48 <Gracenotes> an even number of flips :)
23:14:49 <jmcarthur> :t flip . flip . flip . flip . flip . flip . flip
23:14:50 <lambdabot> forall a b c. (b -> a -> c) -> a -> b -> c
23:15:52 <jmcarthur> :t (.).(.) -- comes up a lot if you take point free to the extreme and looks like boobies
23:15:53 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:15:53 <hatds> I remember seeing syntax like  f _3 _1 _2  to rearrange arguments arbitrarily, as well as f _1 _1 _2 to duplicate inputs
23:16:01 <copumpkin> :t fix flip
23:16:03 <lambdabot> forall b c. b -> b -> c
23:16:05 <hatds> I think it was in the Boost C++ libs
23:16:09 <ski> urgh
23:16:12 <copumpkin> that's a really useful one
23:16:19 <jmcarthur> that type signature looks familiar now...
23:16:42 <twb> RWH is also available free of charge, which is apparently unusual for Haskell textbooks.
23:16:52 <ski> > fix slip () ()
23:16:53 <lambdabot>   Not in scope: `slip'
23:16:55 <ski> > fix flip () ()
23:17:00 <lambdabot>   mueval-core: Prelude.read: no parse
23:17:00 <lambdabot>  mueval: ExitFailure 1
23:17:09 <stanv> Hello! are there any RSS with about haskell ?
23:17:21 <Gracenotes> jmcarthur: and, of course..
23:17:23 <twb> stanv: you mean blogs?
23:17:29 <Gracenotes> :t fmap fmap fmap `asTypeOf` ( (.).(.) )
23:17:30 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:17:33 <copumpkin> http://planet.haskell.org
23:17:35 <jmcarthur> stanv: check out planet.haskell.org
23:17:44 <Gracenotes> *fmap* *fmap* *fmap*
23:17:49 <ewwiz> ski - cool. i'll tell my friend, he's the one that's trying to learn haskell. he asked me for some help but, i know nothing about it
23:17:53 <ray> @fmap gracenotes
23:17:53 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:18:02 <copumpkin> Gracenotes: keep it for the hacathon
23:18:08 <ray> @cobotsnack
23:18:09 <lambdabot> :)
23:18:12 <copumpkin> wow, that's a really old link
23:18:14 <jmcarthur> oh! i saw it while playing with semantic combinators
23:18:28 <stanv> twb: I want regulary updated and easy reading. Something interesting about haskell.
23:18:32 <ray> hawiki's gone now
23:18:35 <copumpkin> yup
23:18:38 <Gracenotes> @botsnackco
23:18:38 <lambdabot> :)
23:18:38 <lunabot>  :)
23:18:45 <copumpkin> @cobotsnack
23:18:45 <lambdabot> :)
23:18:59 <copumpkin> only I can do it right
23:19:02 <ray> ):
23:19:15 <ski> @botsmack
23:19:15 <lambdabot> :)
23:19:15 <lunabot>  :)
23:19:16 <Gracenotes> something to do with Levenshtein distance, I think...
23:19:24 <jmcarthur> :t fmap.fmap
23:19:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
23:19:29 <ray> @botsack
23:19:30 <lambdabot> :)
23:19:30 <lunabot>  :)
23:19:31 <twb> Gracenotes: I don't think you write the `h'
23:19:41 <ray> :t fmap `fmap` fmap
23:19:42 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
23:19:58 <Gracenotes> twb: where? -.-
23:20:05 <copumpkin> :t (. fmap .)
23:20:07 <lambdabot> parse error on input `)'
23:20:09 <copumpkin> :(
23:20:17 <twb> Gracenotes: Levenstein
23:20:34 <jmcarthur> :t \a b -> a . fmap . b
23:20:35 <lambdabot> forall c a b (f :: * -> *) a1. (Functor f) => ((f a -> f b) -> c) -> (a1 -> a -> b) -> a1 -> c
23:20:35 <Gracenotes> oh. I'm pretty sure there was an h.
23:20:49 <twb> Hmm, apparently there is...
23:21:00 <jeffz`> stanv: there's also the haskell reddit, linked in the topic
23:21:14 <twb> I blame the transcriber (from cyrillic).
23:21:33 <ray> :t liftA2 liftA2 liftA2
23:21:34 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => ((a -> b -> c) -> f (f1 a)) -> (a -> b -> c) -> f (f1 b) -> f (f1 c)
23:21:45 <Gracenotes> nod
23:22:04 <copumpkin> :t liftA2 liftA2 liftA2 liftA2
23:22:05 <lambdabot> forall b c (f :: * -> *). (Applicative f) => (f c -> b -> c) -> (f (f c) -> f b -> b) -> f (f c) -> f b -> c
23:22:09 <copumpkin> that's more like it
23:22:10 <Gracenotes> you know, lots of interesting function types for the function instance of applicative
23:22:18 <Gracenotes> @type liftA2.liftA2.liftA2
23:22:19 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b c (f2 :: * -> *). (Applicative f, Applicative f1, Applicative f2) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
23:22:36 <copumpkin> :t liftA2 join
23:22:37 <stanv> jeffz`: thanks :)
23:22:37 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> b -> c) -> f b -> f c
23:22:46 <Gracenotes> can be useful in some cases, for combining the results of two three-argument functions
23:22:51 <Gracenotes> my example
23:23:29 <Gracenotes> or liftA3.liftA3, combing the results of three two-argument functions
23:23:33 <Berengal> I think I've been overexposed to applicative function style...
23:23:40 <copumpkin> no such thing
23:23:51 <ray> :t fmap pure
23:23:52 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f1 a -> f1 (f a)
23:23:56 <Berengal> I recently wrote 'isPrime = (==) <*> head . factorize'
23:24:13 <Gracenotes> adorable!
23:24:18 <Berengal> Without thinking about it. I was demoing haskell to a friend...
23:24:29 <Berengal> He was confused :/
23:24:39 <copumpkin> :)
23:24:44 <Gracenotes> except that it does rely on knowing about the exact ordering of factorize
23:25:00 <Berengal> Gracenotes: factorize :: Integer -> [Integer]
23:25:05 <Gracenotes> if it returns 1 or not
23:25:06 <Berengal> As it should be
23:25:46 <Berengal> Gracenotes: My version sepcial-cases out 0 and 1
23:25:51 <Gracenotes> if factorize 10 yields [10, 5, 2, 1], you're out of luck :) </unimportant>
23:26:04 <Berengal> Gracenotes: That would be divisors, obviously
23:26:15 <Berengal> factorize is prime factorization
23:27:02 <Gracenotes> ah. that makes it clearer.
23:27:27 <Gracenotes> I assumed factors <=> divisors here.
23:27:29 <Gracenotes> :)
23:27:38 <twb> Is HWN available by mailing list (or, say, in gmane)?
23:28:01 <Berengal> divisors = map head . group . sort . map product . filterM (const [True, False]) . factorize
23:28:10 <Gracenotes> <*> and =<< are useful, but not-so-clear, combinators
23:29:10 <twb> Ah, "New editions are posted to the Haskell mailing list".  Presumably that's a wider list, not just HWN.
23:29:10 <Berengal> Funktions are always funky when treated as funktors++
23:29:29 <copumpkin> applikatives and monkads?
23:29:31 <ray> even more useful and less clear than usual when you use the function functor
23:29:36 <jmcarthur> i don't get confused by <*> and =<< very easily
23:29:38 <twb> copumpkin: no, no, jive and soul
23:29:44 <ray> :t jive
23:29:46 <lambdabot> Not in scope: `jive'
23:29:51 <copumpkin> :t soul
23:29:52 <lambdabot> Not in scope: `soul'
23:29:54 <copumpkin> lambdabot has no soul
23:30:00 <twb> monkads are for jass.
23:30:22 <Gracenotes> applikatives
23:30:34 <ray> soul = pure; jive = (<*>)
23:30:38 <Berengal> *snap snap snap*
23:30:49 <copumpkin> @type loop (join *** id)
23:30:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:31:16 <copumpkin> how to make things more complicated than they need to be
23:31:25 <copumpkin> loop (f *** id) === f ?
23:31:32 <jmcarthur> @let soul = Control.Applicative.pure
23:31:33 <lambdabot>  Defined.
23:31:39 <ray> :t id `id` id
23:31:41 <lambdabot> forall a. a -> a
23:31:41 <jmcarthur> @let jive = (<*>)
23:31:43 <lambdabot>  Defined.
23:32:04 <copumpkin> @type loop (snd &&& fst)
23:32:06 <lambdabot> forall b. b -> b
23:32:11 <copumpkin> > loop (snd &&& fst) 5
23:32:13 <lambdabot>   5
23:32:21 <copumpkin> who needs id!
23:32:34 <copumpkin> @type loop (join *** loop (snd &&& fst))
23:32:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:32:43 <Gracenotes> > loop (loop (snd &&& fst)) 5
23:32:44 <lambdabot>   5
23:32:48 <Gracenotes> ..
23:33:05 <jmcarthur> :t loop
23:33:06 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
23:33:12 <jmcarthur> oh, that loop
23:33:30 <copumpkin> @type loop (join *** loop (second id &&& first id))
23:33:31 <lambdabot>     Occurs check: cannot construct the infinite type: d = (d, d1)
23:33:31 <lambdabot>       Expected type: d
23:33:31 <lambdabot>       Inferred type: (d, d1)
23:33:42 <copumpkin> oh whoops :)
23:33:42 <Gracenotes> loop f b = let (c,d) = f (b,d) in c
23:34:19 <ray> arrows need ~> or something
23:34:41 <Gracenotes> > loop (join (,) . snd) 10
23:34:46 <lambdabot>   mueval-core: Prelude.read: no parse
23:34:47 <lambdabot>  mueval: ExitFailure 1
23:34:55 <Berengal> Someone needs to create a class Bow so we can program in Bow and Arrow style
23:34:56 <Gracenotes> o-o
23:35:06 <Gracenotes> > "poke"
23:35:07 <lambdabot>   "poke"
23:35:55 <jmcarthur> > "o-o " <* "poke"
23:35:56 <lambdabot>   "oooo----oooo    "
23:36:08 <jmcarthur> woops
23:36:10 <jmcarthur> > "o-o" <* "poke"
23:36:11 <lambdabot>   "oooo----oooo"
23:36:54 <copumpkin> are people typically as ridiculous as they are in #hsakell at hackathons?
23:36:56 <Gracenotes> @vixen  How bored are people here?
23:36:56 <lambdabot> what can i do to amuse you into a state of un-boredness?
23:37:33 <ray> well, is there a lambdabot at hackathons to type random expressions?
23:37:44 <Gracenotes> @vixen some efficient immutable data structures, perhaps
23:37:44 <lambdabot> why, aren't you sure?
23:37:48 <Gracenotes> uh
23:38:07 <jmcarthur> > '?' <$ "I guess it is time for me to go to bed, but before I do, here's some random crap for lambdabot!"
23:38:08 <lambdabot>   "??????????????????????????????????????????????????????????????????????????...
23:38:10 <Berengal> Gracenotes: How can you "do" a structure anyway?
23:38:22 <copumpkin> don't ask
23:38:47 * ski . o O ( substitution/expression monad )
23:39:05 <Gracenotes> I was going to say "implement", but I don't want to ruin copumpkin's fantasy here
23:39:34 * copumpkin fantasizes some more
23:39:52 <ray> you can "do" a structure by making it an instance of MonadZero
23:39:53 <outchanter> clojure has array mapped hash tries ... I wonder if they're more efficient?
23:39:54 * Berengal just wondered if unicorns are Identity monads or Maybe monads...
23:40:12 <ray> unicorns are ContT
23:40:32 <Gracenotes> I'd say Identity
23:42:35 <Gracenotes> outchanter: possibly... they are mutable, though, and more suited for Clojure, maybe.
23:43:27 <copumpkin> outchanter: more efficient than what?
23:43:50 <copumpkin> definitely more efficient than our hashtables :P
23:44:50 <outchanter> I think they're used to implement immutable maps, actually. This seems to be a good explanation: http://arcanesentiment.blogspot.com/2008/08/array-mapped-hash-tries-and-nature-of.html
23:46:00 <copumpkin> sounds interesting
23:46:21 <Gracenotes> hm
23:47:28 <copumpkin> we'd need some kind of Hashable typeclass though
23:49:46 <Peaker> @unpl (==) <*> head . factorize
23:49:46 <lambdabot> (\ c -> ((==) <*> head) (factorize c))
23:49:54 <Peaker> @unpl (==) `ap` head . factorize
23:49:55 <lambdabot> (\ c -> ((==) >>= \ e -> head >>= \ d -> return (e d)) (factorize c))
23:50:01 <Gracenotes> eek
23:50:10 <Peaker> @unpl really sucks
23:50:10 <lambdabot> really sucks
23:50:23 <Gracenotes> maybe if you had a "funcAp", which is the specific function instance for ap
23:50:30 <Peaker> @unpl ((==) >>= \ e -> head >>= \ d -> return (e d)) (factorize c)
23:50:30 <lambdabot> ((==) >>= \ e -> head >>= \ d -> return (e d)) (factorize c)
23:50:44 <Peaker> well, it does know the type here
23:50:57 <copumpkin> @redo ((==) >>= \ e -> head >>= \ d -> return (e d)) (factorize c)
23:50:58 <lambdabot> (do { e <- (==); d <- head; return (e d)}) (factorize c)
23:51:01 <Gracenotes> not sure pl does much type inference
23:51:18 <ski> @pl \x -> x x
23:51:18 <lambdabot> join id
23:51:39 <copumpkin> @pl (\x -> x x) (\x -> x x)
23:51:43 <lambdabot> ap id id (ap id id)
23:51:43 <lambdabot> optimization suspended, use @pl-resume to continue.
23:52:02 <QtPlaty[HireMe]> copumpkin: Evil.
23:52:31 <ski> @pl \f -> (\t -> t t) (\g -> f (g g))
23:52:31 <lambdabot> join id . (. join id)
23:53:02 <copumpkin> lambdabot definitely doesn't like that
23:53:09 <Gracenotes> in demand: a funcAp
23:53:24 <Gracenotes> >_>  <_<
23:53:52 <ski> @pl (\g -> g g) (\g f -> f (g g f))
23:54:01 <lambdabot> ap id id (ap id . ap id id)
23:54:07 <lambdabot> optimization suspended, use @pl-resume to continue.
23:54:42 <jeffwheeler> @uptime
23:54:43 <jeffwheeler> :(
23:54:43 <Gracenotes> goodnight, sweet lambdabot
23:54:49 <lambdabot> uptime: 15s, longest uptime: 1m 10d 23h 44m 29s
23:54:53 <copumpkin> seems like a bit of a DOS
23:59:08 <Peaker> Hmm -- "cabal install" can find missing dependencies ("Blah is a member of hidden package ...") -- can a .cabal file construction be mostly automated?  Perhaps cabal-install knows what different APIs are provided by different versions and can even automate creating the right version range?
