00:01:40 <bastl> can someone give me a hint howto use DBDirect with an sqlite database? i cabal-installed haskelldb, but dont know how to run DBDirect ...
00:02:39 <dons> hmm. haskelldb is a bit underdocumented. You may well need the paper on it.
00:02:43 <dons> or ask on haskell-cafe@
00:02:47 <dons> i think hdbc is more popular
00:05:37 <bastl> Im just looking for a tool that generates the haskell types automatically from the schema.
00:10:04 <dons> i think asking haskell-cafe@ for "what is the best tool to generate haskell types from a database schema" would be a great thing to have answered
00:10:50 <bastl> ok, thanks.
00:10:53 <Axman6> hey dons
00:11:21 <Axman6> dons: you said that you guys at galois do a lot of work on computer simulators the other day right?
00:11:49 <dons> we have some projects involving simulating hardware, yep
00:12:11 <Axman6> have you worked on any of them?
00:12:26 <dons> not me personally, no.
00:12:41 <Axman6> just asking because it might be nice to have someone to get advice from when i get the time to work on this thing
00:13:34 <dons> I can put you in touch with Mark Tullsen, one of our main guys in this area.
00:14:08 <Axman6> that would be excellent. only thing is i won't have any time for this for another month or so, since we're coming up to the end of semester
00:17:09 <ivanm> dons: would you be one of the people answering such a query on -cafe though? :p
00:18:59 <flippanen> oes Macintosh have a package manager like apt-get?
00:19:07 <flippanen> where is cafe?
00:19:09 <flippanen> @cafe
00:19:10 <lambdabot> Unknown command, try @list
00:19:13 <flippanen> @haskell-cafe
00:19:13 <lambdabot> Unknown command, try @list
00:19:15 <flippanen> @haskellcafe
00:19:16 <lambdabot> Unknown command, try @list
00:19:24 <flippanen> @src nubBy
00:19:25 <lambdabot> nubBy eq []             =  []
00:19:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:19:25 <Axman6> flippanen: there's macports
00:19:42 <flippanen> wow, is nubBy O(n^2)?
00:19:44 * Axman6 hasn't heard anyone call a Mac a Macintosh for a long time
00:19:48 <Axman6> yes
00:19:51 <ivanm> flippanen: no
00:19:56 <Axman6> no?
00:20:01 <ivanm> it's O(nm), where is the number of unique elements
00:20:13 <ivanm> which is rather important when you have a large number of duplicates
00:20:15 <flippanen> but thats pretty bad
00:20:21 <flippanen> isnt sorting it first better?
00:20:22 <ivanm> in that case, it is nowhere near as bad as O(n^2)
00:20:22 <dancor_> where _is_ the number of unique elements :)
00:20:27 <flippanen> hen it doesnt preserve order though
00:20:33 <ivanm> dancor_: where it is
00:20:37 <ivanm> flippanen: and it isn't lazy
00:20:45 <ivanm> which IMHO is an important feature of nubBy
00:20:49 <flippanen> ok
00:20:59 <ivanm> Macs also have fink
00:21:05 <ivanm> and if you're really bored, gentoo-prefix
00:21:25 <Axman6> fink's outdated
00:21:57 <ivanm> is it?
00:22:06 <ivanm> *shrug* don't use a Mac, so wouldn't really know
00:23:34 <k_> so, anyone knows how to interface some hardware with haskell? I'm thinking something like serial port, usb port etc...
00:25:40 <dons> k_: via C.
00:25:48 <dons> call the C routines that get at  the hardware
00:28:51 <k_> ok, I just thought that there is a direct solution for this...
00:28:59 <dons> the FFI?
00:29:16 <dons> you want to open the device (in unix?) and then read bytes off it?
00:29:40 <k_> yes, read and write..
00:35:04 <pao> dons: thank you for the reply on text manipulation...
00:35:18 <pao> dons: text seems really what I was looking for
00:36:08 <pao> is there a way to the following more efficiently?  T.concat . take 10000 . repeat . T.pack $ "paolo"
00:37:23 <ivanm> pao: maybe by using cycle rather than repeat?
00:37:35 <ivanm> that would avoid having to concat it...
00:37:56 <pao> @type repeat
00:37:57 <lambdabot> forall a. a -> [a]
00:38:05 <ivanm> but it would be slightly more difficult to take the correct amount (you'd want 10000 * (length foo))
00:38:08 <ivanm> @type cycle
00:38:09 <lambdabot> forall a. [a] -> [a]
00:38:26 <pao> ivanm: let me try
00:38:29 <ivanm> pao: I'm not sure what T. is, so it might not be applicable
00:38:42 <pao> ivanm: Data.Text
00:38:52 <pao> ivanm: not available
00:39:04 <ivanm> @hoogle cycle
00:39:05 <lambdabot> Prelude cycle :: [a] -> [a]
00:39:05 <lambdabot> Data.List cycle :: [a] -> [a]
00:39:05 <lambdabot> Data.ByteString.Lazy cycle :: ByteString -> ByteString
00:39:13 <pao> @hoogle Text
00:39:14 <lambdabot> module Data.Generics.Text
00:39:14 <ivanm> @type Data.Text.pack
00:39:14 <lambdabot> module Distribution.Text
00:39:14 <lambdabot> module Test.HUnit.Text
00:39:15 <lambdabot> Couldn't find qualified module.
00:39:20 <dons> bos: does 'text' instance IsString?
00:39:20 <ivanm> @pack Data.Text.pack
00:39:21 <lambdabot> Maybe you meant: ask fact part smack
00:39:22 <copumpkin> I don't think there's a lazy Data.Text yet
00:39:27 <ivanm> @hoogle Data.Text.pack
00:39:27 <lambdabot> package packedstring
00:39:27 <lambdabot> package darcs-buildpackage
00:39:27 <lambdabot> package datapacker
00:39:27 <dons> (i.e. can we use overloaded string literals)
00:39:57 <pao> ivanm: the package is text
00:40:23 <ivanm> yeah, but the module is Data.Text, right?
00:40:33 <pao> ivanm: yep
00:49:56 <Axman6> "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."
00:50:00 <Axman6> - Brian Kernighan
00:50:03 <Axman6> i like that
00:51:58 <Wraithan> Is there a better way to strip everything except from the numbers from a string than using filter?
00:52:06 <Wraithan> IE: stripLetters value = filter (`elem` "1234567890") value
00:52:39 <Wraithan> Not that I am seeing a performance issue, just seems like a sloppy way of doing it
00:52:55 <flippanen> > 'a':: Int
00:52:55 <flippanen> > ord 'a'
00:52:55 <flippanen> > ord 'a
00:52:57 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
00:52:57 <lambdabot>   <no location info>:
00:52:57 <lambdabot>      lexical error in string/character literal at chara...
00:52:57 <lambdabot>   97
00:53:26 <dons> Wraithan: filter isNumber ?
00:53:28 <Axman6> :t isDigit
00:53:29 <lambdabot> Char -> Bool
00:53:45 <Axman6> > filter isDigit "asd123sfgj1254e3 flippanen 34t "
00:53:46 <lambdabot>   "1231254334"
00:53:48 * dons ponders isNumber vs isDigit
00:53:58 <dons> > filter isNumber "asd123sfgj1254e3 flippanen 34t "
00:54:00 <lambdabot>   "1231254334"
00:54:03 <dons> curious
00:54:04 <copumpkin> :o
00:54:08 <dons> ?Src isNumber
00:54:09 <lambdabot> Maybe you meant: rc src
00:54:09 <copumpkin> @index isNumber
00:54:09 <Axman6> indeed
00:54:10 <lambdabot> bzzt
00:54:12 <dons> ?src isNumber
00:54:12 <lambdabot> Source not found. Take a stress pill and think things over.
00:54:16 <copumpkin> @hoogle isNumber
00:54:16 <lambdabot> Data.Char isNumber :: Char -> Bool
00:54:21 <Axman6> @hoogle isDigit
00:54:21 <lambdabot> Data.Char isDigit :: Char -> Bool
00:54:21 <copumpkin> @hoogle isDigit
00:54:21 <lambdabot> Data.Char isDigit :: Char -> Bool
00:54:24 <copumpkin> lol
00:54:25 <Axman6> o.O
00:54:28 <dons> -- | Selects Unicode numeric characters, including digits from various
00:54:28 <dons> -- scripts, Roman numerals, etc.
00:54:28 <dons> isNumber :: Char -> Bool
00:54:32 <Wraithan> Looks like they are aliases of eachother
00:54:33 <dons> :D
00:54:34 <opqdonut> ah
00:54:37 <opqdonut> unicode
00:54:48 <copumpkin> aha
00:54:50 <copumpkin> not aliases
00:54:58 <Axman6> "Perl - The only language that looks the same before and after RSA encryption."
00:54:58 <Axman6> - Keith Bostic
00:55:03 <dons> heh
00:55:05 <dons> that's awesome
00:55:10 <Wraithan> So use isNumber?
00:55:18 <Hunner> > filter isNumber "abc一十"
00:55:19 <lambdabot>   ""
00:55:22 <dons> well, if you expect roman numberals :)
00:55:26 <dons> isDigit is prob. ok.
00:55:28 <copumpkin> I've met keith bostic
00:55:38 <Axman6> more like that here: http://www.storm-consultancy.com/blog/other/classic-programming-quotes/
00:55:47 <Wraithan> > filter isNumber "V13radXII"
00:55:49 <lambdabot>   "13"
00:56:09 <Wraithan> > filter isNumber "V 13 rad XII"
00:56:11 <lambdabot>   "13"
00:56:18 <Hunner> > filter isNumber "abc１９"
00:56:19 <lambdabot>   "\65297\65305"
00:56:23 <Hunner> almost
00:56:30 <copumpkin> > filter isNumber "9 a b c 4 Ⅸ"
00:56:31 <lambdabot>   "94\8552"
00:56:38 <Hunner> ah hah
00:56:39 <Wraithan> Doesn't seem to be keeping the roman numberals
00:56:41 <copumpkin> > text $ filter isNumber "9 a b c 4 Ⅸ"
00:56:43 <lambdabot>   94Ⅸ
00:56:52 <copumpkin> Wraithan: that's because you didn't type roman numerals according to unicode
00:57:00 <Wraithan> I see
00:57:02 <copumpkin> you typed a latin x and a latin i
00:57:17 <copumpkin> the common roman numerals have their own code points
00:57:22 <Wraithan> Well, I am just parsing acpi files, so I guess I will go with isDigit
00:57:45 <Wraithan> I shouldn't need unicode for that
00:58:40 <Wraithan> Thank you guys
01:01:49 <flippanen> > filter isNumber "hello12olleh"
01:01:50 <lambdabot>   "12"
01:02:48 <flippanen> > (filter isNumber "hello12olleh") :: Int
01:02:49 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
01:03:14 <Wraithan> > read (filter isNumber "hello12olleh") :: Int
01:03:16 <lambdabot>   12
01:03:48 <flippanen> > (filter isNumber "hello12olleh") :: Int + 4
01:03:50 <lambdabot>   Only unit numeric type pattern is valid
01:04:03 <copumpkin> :o
01:04:05 <Wraithan> flippanen: add a read to the start of the expression
01:04:08 <nlogax> what have i done wrong if i can't enter unicode characters into ghci? or must i use \numberz ?
01:04:23 <Wraithan> nlogax: your term support unicode?
01:04:38 <nlogax> Wraithan: yes, using utf-8
01:05:00 <Wraithan> Oh, then I don't know =/
01:05:08 <Wraithan> < noob to haskell, lol
01:05:19 <nlogax> me too :)
01:12:08 <Wraithan> Is there a way to convert from an int into a time format like HH:MM without having to do the formatting yourself
01:12:13 <Wraithan> Google is lacking in results
01:12:55 <flippanen> Data.Time?
01:12:58 <flippanen> not sure
01:13:13 <Wraithan> I was looking in there, and wasn't finding anything that took an int and returned a time
01:27:19 <quicksilver> Wraithan: what kind of int?
01:27:28 <quicksilver> I mean, how does your int represent a time?
01:28:31 <Wraithan> Well from the numbers I am getting from acpi it is easy for me to get it in hours as a Float, or in minutes as an Int
01:29:20 <Freidenker> 'dons' as in Don Stewart, as in 'one of the author of RWH' ?
01:29:50 <quicksilver> Wraithan: well that's so easy there is no functio for it ;)
01:32:01 <quicksilver> > let t = 24.35 :: Double  in show (floor t) ++ ":" ++ show (round ((t - fromIntegral (floor t)) * 60))
01:32:02 <lambdabot>   "24:21"
01:32:25 <quicksilver> although I'm sure you could poke at the Data.Time.Format stuff for more flexible formatting.
01:32:44 <Wraithan> I was looking at Data.Time.Format it takes strings
01:32:45 <sjanssen> PhDP: correct on all counts
01:32:46 <mauke> > uncurry (printf "%02d:%02d") . (`divMod` 60) $ 2345
01:32:47 <lambdabot>   Add a type signature
01:32:55 <mauke> > uncurry (printf "%02d:%02d") . (`divMod` 60) $ 2345 :: String
01:32:56 <lambdabot>   "39:05"
01:34:49 <quicksilver> "it takes strings" ?
01:34:54 <quicksilver> it takes FormatTime t => t
01:35:08 <quicksilver> the string is the format specifier
01:35:21 <quicksilver> e.g. "%H:%M"
01:37:08 <flippanen> > (+1) *** (+3) $ (1,2)
01:37:10 <lambdabot>   (2,5)
01:37:21 <flippanen> > (+1) &&& (+3) $ 5
01:37:23 <lambdabot>   (6,8)
01:37:42 <flippanen> > (subtract 3) &&& (\x -> x) $ 5
01:37:43 <lambdabot>   (2,5)
01:37:56 <flippanen> > (subtract 3) &&& id $ 5
01:37:58 <lambdabot>   (2,5)
01:38:11 <flippanen> wow i used id naturally for once!
01:38:20 <flippanen> is their an arrow for apply to left?
01:39:48 <flippanen> > (\(a,b) -> (a+1,b)) (1,2)
01:39:50 <lambdabot>   (2,2)
01:40:05 <flippanen> how are arrows cleaer than lambdas really?
01:40:07 <flippanen> > (\a -> (a+1,a)) (1,2)
01:40:08 <lambdabot>       No instance for (Num (t, t1))
01:40:08 <lambdabot>        arising from the literal `1' at <i...
01:40:11 <flippanen> > (subtract 3) &&& id $ 5
01:40:12 <lambdabot>   (2,5)
01:40:15 <flippanen> > (\a -> (a+1,a)) (1,2)
01:40:16 <lambdabot>       No instance for (Num (t, t1))
01:40:16 <lambdabot>        arising from the literal `1' at <i...
01:40:25 <flippanen> > (\a -> (a+1,a)) 3
01:40:26 <lambdabot>   (4,3)
01:40:28 <flippanen> > (\(a,b) -> (a+1,b)) (1,2)
01:40:30 <lambdabot>   (2,2)
01:40:41 <quicksilver> they're not, particularly.
01:40:53 <quicksilver> arrows weren't invented with the goal of being clearer than lambdas :)
01:41:52 <quicksilver> those arrow-assisted formulations are point-free, which means you can compose a bunch of them without having to make up names for the points.
01:42:02 <quicksilver> even that doesn't necessarily make it clearer :)
01:42:13 <photonen> i missed what ypu wrote
01:42:15 <photonen> you
01:42:19 <quicksilver> they're not, particularly.
01:42:21 <quicksilver> arrows weren't invented with the goal of being clearer than lambdas :)
01:42:21 <photonen> disconnected
01:42:22 <quicksilver> those arrow-assisted formulations are point-free, which means you can compose a bunch of them without having to make up names for the points.
01:42:25 <quicksilver> they're not, particularly.
01:42:31 <photonen> ok
01:42:39 <quicksilver> even that doesn't necessarily make it clearer :)
01:42:41 <photonen> i see
01:42:55 <photonen> arrows are combinatory logic constructs?
01:43:30 <quicksilver> they're not a classic combinatory logic construct, no.
01:43:39 <fasta> quicksilver: what was the purpose of arrows?
01:43:44 <quicksilver> to the extend that they are a system of combinators they are obviously non-un-related.
01:44:14 <quicksilver> fasta: a formulation of computation with effects which obeyed more (or different) laws than monads.
01:44:27 <quicksilver> fasta: permitting certain kinds of static optimisation, for example.
01:44:53 <photonen> arrows are more general than monads?
01:44:55 <fasta> quicksilver: that's not a very grand purpose ;)
01:45:06 <photonen> arrows >> monads >> applicables
01:45:07 <photonen> ?
01:46:16 <quicksilver> it's more like
01:46:23 <quicksilver> {arrows,monads} >> applicatives
01:46:31 <quicksilver> arrows and monads are strictly non-comparable.
01:46:43 <quicksilver> they' also different kinds, which makes it harder to compare.
01:46:47 <quicksilver> fasta: perhaps not :)
01:46:56 <quicksilver> fasta: you could read hughes' paper for a bit more background.
01:47:04 <quicksilver> I'm not sure arrows have really found their place yet.
01:47:07 <quicksilver> maybe it's all still to come.
01:47:08 <fasta> quicksilver: I already did. :)
01:47:19 <quicksilver> the invertible parsers are quite a neat idea.
01:47:56 <fasta> quicksilver: invertible anything is a field in itself.
01:48:48 <photonen> some eople want arrows to take monads place right?
01:48:53 <photonen> for GUis for example?
01:49:21 <Workybob> photonen: I'm not sure that's accurate
01:49:31 <Workybob> it's more a case of "arrows provide an interesting way of thinking about UIs"
01:49:39 <Raevel> is there any nicer way of writing uncurry . zipWith ?
01:50:00 <photonen> @src uncurry
01:50:00 <lambdabot> uncurry f p = f (fst p) (snd p)
01:50:14 <Axman6> :t uncurry . zipWith
01:50:15 <lambdabot> forall a b c. (a -> b -> c) -> ([a], [b]) -> [c]
01:50:31 <Axman6> :t uncurry zipWith
01:50:32 <lambdabot> forall a b c. (a -> b -> c, [a]) -> [b] -> [c]
01:51:17 <Workybob> Raevel: looks pretty nice to me
01:51:24 <Axman6> me too
01:51:26 <Workybob> what do you dislike about it?
01:52:17 <photonen> uncurry zipWith makes no sense tome
01:52:49 <photonen> > uncurry . zipWith (+) ([1,2,3],[4,5,6])
01:52:50 <lambdabot>   Couldn't match expected type `[a]'
01:52:56 <photonen> > uncurry zipWith (+) ([1,2,3],[4,5,6])
01:52:58 <lambdabot>   Couldn't match expected type `(a -> b -> c, [a])'
01:53:12 <photonen> > let uz = uncurry zipWith in uz (+) ([1,2,3],[4,5,6])
01:53:13 <lambdabot>   Couldn't match expected type `(a -> b -> c, [a])'
01:53:15 <Workybob> > (uncurry . zipWith) (+) ([1,2,3],[4,5,6])
01:53:16 <lambdabot>   [5,7,9]
01:53:19 <photonen> > let uz = uncurry . zipWith in uz (+) ([1,2,3],[4,5,6])
01:53:21 <lambdabot>   [5,7,9]
01:53:26 <photonen> > (uncurry zipWith) (+) ([1,2,3],[4,5,6])
01:53:28 <lambdabot>   Couldn't match expected type `(a -> b -> c, [a])'
01:53:28 <photonen> ah
01:53:34 <photonen> > (uncurry . zipWith) (+) ([1,2,3],[4,5,6])
01:53:35 <lambdabot>   [5,7,9]
01:54:07 <Raevel> i think i was confused, mostly :-)
01:55:46 <Axman6> > (uncurry zipWith) ((+),[1,2,3]) [4,5,6]
01:55:47 <lambdabot>   [5,7,9]
02:00:09 <photonen> hmm what is that axman?
02:00:30 <Raevel> > (uncurry (uncurry zipWith)) (((+),[1,2,3]),[4,5,6])
02:00:31 <lambdabot>   [5,7,9]
02:00:33 <Axman6> it's a stupid way to write a function ;)
02:01:09 <photonen> oh youre artially applying it
02:01:49 <photonen> > uncurry $ zipWith (+1) ([1,2],[3,4])
02:01:51 <lambdabot>   Couldn't match expected type `[b -> c]'
02:03:21 <Saleop> Hey guys, this haskell tutorial I'm reading (Learn You a Haskell for the Greater Good) says I can use 'div' with infix notation but my interpretter (GHC 6.10.3) gives an error when i try to do that. what gives?
02:03:33 <Raevel> anyway, (a -> b -> c) -> [(a, b)] -> [c] turned out to be a little more intuitive for this problem, and that's map (uncurry f)
02:03:38 <BONUS> what kind of error do yo get?
02:03:42 <BONUS> > 5 `div` 3
02:03:44 <lambdabot>   1
02:04:47 <Saleop> Ooooh. I was using the wrong kind of quotes. i was using ' instead of `
02:05:03 <BONUS> :)
02:05:13 <Saleop> thanks!
02:05:17 <BONUS> np
02:05:25 <Axman6> BONUS: have you had many/any complaints about things in LYAH?
02:05:47 * ivanm complained about the name
02:05:52 <BONUS> i get some corrections and critiques every now and then, which are always welcome
02:06:08 <BONUS> but not too many about it straight out being bad or something :)
02:06:20 <vegai> is there a way to detect that a socket converted to a handle is still alive?
02:06:36 <vegai> I'm using hIsWritable now, but it seems like that's not quite enough
02:06:41 <BONUS> gonna finish it up now over the summer and then release it as an irl book
02:06:41 <Axman6> yeah, i've only heard good things about it, so must be a good tutorial :)
02:06:43 <Axman6> nice work
02:06:45 <ivanm> BONUS: the name is bad
02:06:54 <ivanm> I didn't get anywhere past that, it was that bad
02:06:54 <ivanm> ;-)
02:06:59 <BONUS> haha
02:07:00 <Axman6> heh
02:07:05 <BONUS> i think the name is awesome
02:07:09 <ivanm> well, it doesn't make sense!
02:07:14 <Raevel> not only is it bad, it is gramatically incorrect!
02:07:22 <ivanm> Raevel: that's why it's bad
02:07:35 <BONUS> yeah, i started writing it mainly for myself, but then sort of people started liking it, didn't expect such a positive response, so i guess it's all good
02:07:42 <nlogax> BONUS: i found a small thing in "Syntax in functions". where it says "because we broke it into a head and a tail and discarded the tail.", wasn't it the other way around? :)
02:07:44 <Axman6> i don't think it would make a good book title, but it does make a good web tutorial title
02:08:11 <BONUS> maybe i'll just shorten it to Learn You a Haskell for the book thing
02:08:15 <algal> newbie question: is there a way to get tab completion in GHCi, under emacs?
02:08:16 <quicksilver> vegai: if you read from a closed socket, you get zero bytes. If you write to a closed socket you get SIGPIPE.
02:08:24 <quicksilver> vegai: I can't remember if "hIsEOF" works on sockets.
02:08:28 <cognominal> what is the haskell equivalent of the Perl ord?
02:08:31 <ivanm> algal: no
02:08:35 <ivanm> at least not that I've found
02:08:46 <BONUS> nlogax: yeah you're right, we discard the head
02:08:49 <algal> ivanm: thanks!
02:08:51 <BONUS> i'll fix that right away, thanks!
02:08:55 <Taejo> :t fromEnum
02:08:56 <lambdabot> forall a. (Enum a) => a -> Int
02:08:57 <nlogax> cool!
02:09:05 <quicksilver> cognominal: ord.
02:09:13 <Taejo> :t Data.Char.ord
02:09:14 <quicksilver> cognominal: although it works on Chars not Strings.
02:09:14 <lambdabot> Char -> Int
02:09:33 <quicksilver> cognominal: note that Chars are unicode code points, not in any particular encoding.
02:10:06 <algal> 2nd (and last) newbie question: is there a way, at the GHCi interactive prompt (under emacs), to dynamically lookup the comment string or docs for a function? Something like ?foo in iPython or Mathematica.
02:10:18 <cognominal> thx. how come did not give me the function given the signature?
02:10:28 <algal> maybe this is impossible b/c Haskell doesn't have a very strong convention for how to comment functions...?
02:10:39 <cognominal> s/how come/how come Hoogle/
02:10:42 <fasta> algal: there is no convention, although there is a package which does this. \
02:10:55 <ivanm> algal: :i, :t, etc.
02:11:04 <ivanm> fasta: oh? which one?
02:11:05 <quicksilver> there is a strong convention abotu how to comment functions
02:11:07 <quicksilver> haddock.
02:11:16 <ivanm> quicksilver: oh, duh, I thought fasta meant a lookup program
02:11:23 <ivanm> (for the package)
02:11:31 <photonen> algal: haddock
02:11:34 <quicksilver> I'm not aware of a way to get emacs to look up haddock-docs
02:11:34 <fasta> ivanm: yes, I meant that.
02:11:39 <photonen> -- | This is a comment
02:11:41 <quicksilver> although it souldn't be that hard in principle.
02:11:58 <algal> Hmm, thanks everyone. I knew about :t but I was hoping for docs now just the type signature. I'll check out haddock
02:12:09 <ivanm> quicksilver: well, you'd expect it to be a lot easier in emacs then in ghci in an xterm...
02:12:14 <ivanm> photonen: no, that is a Haddock comment
02:12:17 <ivanm> -- This is a comment
02:12:42 <algal> It seems if there's not a strong convention around where and how to associate a comment docstring with a function, then there's only so much you can do...
02:12:57 <ivanm> exactly
02:13:08 <ivanm> as it stands, the haddock docs are attached to the type sig, not to the function
02:13:28 <Axman6> :t toEnum
02:13:29 <lambdabot> forall a. (Enum a) => Int -> a
02:13:36 <fasta> ivanm: the tool I was talking about does something slightly related, but it's not what I said.
02:13:37 <Axman6> @instances Enum
02:13:38 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
02:13:51 <Axman6> > toEnum 1 :: Float
02:13:52 <lambdabot>   1.0
02:13:55 <ivanm> fasta: what tool were you talking about then?
02:14:01 <Axman6> > toEnum 100000000000000 :: Float
02:14:02 <lambdabot>   1.0e14
02:14:07 <Axman6> > toEnum 1000000000000000000000 :: Float
02:14:07 <fasta> ivanm: DocTest
02:14:08 <lambdabot>   3.87582e18
02:14:09 <ivanm> Axman6: well, IIRC the instance of Enum for Float is _bad_...
02:14:18 <ivanm> fasta: oh, is that the port of the python doctest stuff?
02:14:19 <Axman6> yeah, seems so...
02:14:24 <quicksilver> algal: there are strong conventions.
02:14:26 <fasta> ivanm: yes
02:14:28 <quicksilver> algal: it's called haddock.
02:14:36 <quicksilver> algal: that's how all the generated documents work.
02:14:56 <quicksilver> algal: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-List.html
02:14:59 <quicksilver> for example.
02:14:59 <fasta> I think if you write something which parses Haddock inside ghci, more people will use Haddock.
02:15:40 <algal> quicksilver: thanks, that's helpful. Starting out, it's hard to figure out which projects/conventions have traction.
02:16:06 <algal> FWIW, I've found the ?foo command available at the ipython or Mathematica prompt, which does  dynamic lookup of the docsting for foo, to be absolutely invaluable.
02:16:08 <fasta> algal: Haddock is the only convention there is, next to just putting the comment above the function.
02:16:36 <fasta> algal: yes, Common Lisp has it too. It's a good idea to standardize those things.
02:16:57 <quicksilver> algal: I've just got used to having a web browser open on the docs index.
02:17:06 <quicksilver> I agree that's not particularly clever, from a technical perspective.
02:17:10 <quicksilver> but it's "good enouch" for me.
02:17:22 <algal> fasta: yes, I forgot about CL. It really smooths REPL-based evelopment.
02:17:30 <ivanm> quicksilver: are enouch's related to eunuchs? ;-)
02:19:07 <quicksilver> yes, they are the eunuchs employed by SPJ  to write haskell documentation.
02:19:20 <ivanm> ahhh, OK
02:20:26 <harovali1> is there something that gives the permutations of a list?
02:20:46 <BONUS> Data.List.permutations
02:20:53 <BONUS> > permutations [1,2,3]
02:20:54 <lambdabot>   Not in scope: `permutations'
02:21:08 <BONUS> lambdabot doesn't have it cause it was introduced in 6.10 i think
02:21:19 <algal> FWIW, Mathematica's implementation of this is quite good since it provides two-levels of lookup and good linking. ?foo gives you a short docstring. ??foo gives you ?foo plus deeper metadata and annotations. Both info blurbs give you a hyperlink to the full docs. Handy.
02:21:25 <ivanm> BONUS: oh, I thought it was in other modules...
02:21:33 <ivanm> harovali1: there's a combinations library on hackage IIRC
02:22:03 <quicksilver> algal: A more rich REPL with structured graphics and links would be an interesting haskell project.
02:22:08 <quicksilver> algal: not a simple one though.
02:22:31 <Taejo> quicksilver: I'm sure I've seen something like that (a badly implemented one)
02:22:36 <Taejo> or at least incomplete
02:22:52 <ivanm> there was one (using Java for the display IIRC) that had a more "document"-like interface to the interpreter...
02:22:57 <ivanm> something like Mathematica's interface
02:23:16 <algal> I don't suppose GHCi is designed to be extensible for that sort of thing, eh...
02:23:18 <quicksilver> 'workbook' it's sometimes called.
02:23:23 * Axman6 dislikes mathematica's help crap
02:23:35 <Axman6> MATLAB's isn't much better
02:23:36 <quicksilver> algal: it wouldn't really be a question of extension. It would be a whole new front end.
02:23:40 * ivanm dislikes mathematica's interface
02:23:42 <quicksilver> algal: GHCi is really just an interpreter
02:23:47 <quicksilver> algal: (you could reuse that part easily enough)
02:23:48 <ivanm> Axman6: actually, I find matlab's help quite helpful
02:23:54 <yowgi> hello. doesn't quickCheck include minBound/maxBound?
02:23:58 <Axman6> yeah, i think it doesn
02:24:05 <ivanm> especially the help manual: quite a lot of good math stuff in there
02:24:07 <quicksilver> yowgi: that depends on the abitrary instance.
02:24:13 <Axman6> i think it just needs some getting used to*
02:24:41 <algal> Yeah, on the whole Mathematica is very hard to use. But the ? ?? syntax is one good point.
02:24:49 <yowgi> @type (\x -> (x :: Int) > (x-1))
02:24:50 <lambdabot> Int -> Bool
02:24:59 <yowgi> @check (\x -> (x :: Int) > (x-1))
02:25:01 <lambdabot>   "OK, passed 500 tests."
02:25:10 <yowgi> > (\x -> (x :: Int) > (x-1)) minBound
02:25:11 <lambdabot>   False
02:25:28 <yowgi> > (minBound :: Int) - 1
02:25:29 <lambdabot>   9223372036854775807
02:25:51 <photonen> wolfram alpha
02:26:03 <photonen> written entirely in mathematica?
02:26:09 <Axman6> i doubt it
02:26:13 <BONUS> hardly
02:26:18 <Axman6> but it does look pretty cool
02:26:28 <harovali1> how do I test if a string is contained in another ?
02:26:37 <BONUS> yeah. but i kind of have a feeling that they exaggerated the amount of mathematica used for it
02:26:40 <Axman6> harovali1: isInfixOf
02:26:43 <BONUS> to promote mathematica
02:26:51 <Axman6> wasn't convinced until i saw the screencast by steven wolfram
02:27:00 <ivanm> Axman6: yes, but does it work? how it looks is hardly a useful indicator...
02:27:18 <Axman6> well, the video seemed to show it working pretty well
02:27:34 <BONUS> we'll just haev to wait and see
02:27:42 <Axman6> being able to ask "what was the weather like when barak obama was born" is pretty cool
02:28:02 <Workybob> I do though want to know where it gets all that weather data from
02:28:02 <BONUS> i wonder how well it will do on haskell related stuf
02:28:17 <BONUS> or programming related stuff in general
02:28:23 <BONUS> like what happens if you type in Monad
02:28:26 <Axman6> probably not too well initially
02:28:31 <BONUS> or kleisli composition or something like that
02:28:39 <BONUS> yeah
02:28:41 <Axman6> but, they'll be expanding the data it has constantly
02:28:45 <yowgi> will it work on the reverse ? “what president was born when the temperature in the capital was over %d”
02:28:49 <Axman6> so should be really interesting
02:28:55 <cognominal> now, how to get the decimal representation of an Int?
02:29:01 <Axman6> yowgi: heh, it's possible
02:29:07 <quicksilver> cognominal: show ?
02:29:17 <Phyx-> Hi, is there a more efficient way to concat two lists other than (++)? or an alternate way?
02:29:24 <quicksilver> cognominal: to be fair, that's a unicode representation of the decimal representation of an Init
02:29:24 <cognominal> how, I always forget about show...
02:29:27 <Axman6> > fromIntegral (1234 :: Int) :: Double
02:29:29 <lambdabot>   1234.0
02:29:29 <quicksilver> but it may be good enough.
02:29:35 <Workybob> Phyx-: no, lists have linear append
02:29:38 <Workybob> that's the best you can do
02:29:48 <quicksilver> Phyx-: if you're concatting more than two lists, though
02:29:57 * ivanm is highly skeptical about anything from Stephen Wolfram being useful after reading his excuse for a scientific "theory"
02:29:59 <quicksilver> you might consider switching to the ([a] -> [a]) representation
02:30:04 <quicksilver> and concatenating them.
02:30:09 <quicksilver> by composition.
02:30:51 * photonen thinks ivanm will probably change his mind after seeing wolfram alpha
02:31:10 <Phyx-> quicksilver: ah ok, i'll try that, thanks :)
02:31:11 <ivanm> photonen: I aim to ensure that doesn't happen by never seeing it! ;-)
02:31:33 <harovali1> i've found that using the letters in EDITORIAL you can form REALIDIOT
02:31:48 <quicksilver> photonen: it would be better if you would stick to a single nick or a recognisable pair.
02:32:31 <ivanm> quicksilver: why, what is his other nick?
02:32:32 * Axman6 doesn't know who else photonen has been :o
02:33:45 <mgee> hi, what is the precision of Complex in haskell? is it arbitrary? like Integer? is Rational also arbitrary? (please provide a link to a webpage... :) )
02:34:07 <Axman6> @src Complex
02:34:07 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
02:34:14 <Axman6> depends on the instance you use
02:34:34 <mauke> @src Rational
02:34:34 <lambdabot> type Rational = Ratio Integer
02:34:38 <Axman6> @instances RealFloat
02:34:38 <Workybob> > 51234567890123489012890127890 :+ 032874659283765982376598237645982374659283765928374659827645982 :: Complex Integer
02:34:38 <lambdabot> Double, Float
02:34:39 <lambdabot>       No instance for (RealFloat Integer)
02:34:40 <lambdabot>        arising from a use of `show'...
02:34:47 <Workybob> :(
02:34:50 <mgee> mhh
02:34:58 <mauke> > 51234567890123489012890127890 :+ 032874659283765982376598237645982374659283765928374659827645982 :: Complex CReal
02:34:59 <lambdabot>   51234567890123489012890127890.0 :+ 3287465928376598237659823764598237465928...
02:35:07 <mgee> ok so RealFloat is limited precision and Rational is arbitrary?
02:35:08 <Axman6> > 1 + sqrt (-1) :: Complex CReal
02:35:09 <lambdabot>   1.0 :+ 1.0
02:35:15 <Axman6> no
02:35:20 <Axman6> you can use CReal
02:35:25 <Axman6> RealFloat is a class
02:35:54 <mgee> does there exist a wiki page or something, that explains this in detail? :)
02:36:13 <Workybob> explains what in detail?
02:36:26 <Axman6> it's not a very difficult subject :\
02:36:45 <Workybob> well, I think the problem is that mgee is seeing about 6 subjects all as 1
02:36:49 <Workybob> and hence seeing it as difficult
02:37:06 <Axman6> mgee: Complex has the same precision as the 'a' type you use
02:37:09 <Workybob> mgee: I'd suggest first understanding the Class system
02:37:15 <Workybob> then type constructors
02:37:16 <mgee> mhh ok so Complex can be limited precision or not. depending on the instance i use. CReal provides me a arbitrary precision, right?
02:37:21 <Workybob> (possibly in the other order)
02:37:27 <mgee> ah ok
02:37:27 <Axman6> mgee: yep
02:37:40 <algal> thanks for all the help, gentlemen. arrivederci
02:37:41 <Axman6> > showCReal 40 pi
02:37:43 <lambdabot>   "3.1415926535897932384626433832795028841972"
02:37:47 <Axman6> > showCReal 80 pi
02:37:48 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
02:37:50 <mgee> so i could use CInt and it would be limited?
02:37:57 <mgee> or Complex Int
02:38:00 <Axman6> CInt?
02:38:02 * Workybob wonders why Complex is limited to only Reals
02:38:08 <Workybob> why can't I have a complex integer?
02:38:10 <mgee> Complex Float
02:38:25 <mgee> ok so not ints ^^
02:39:01 <ivanm> hmmmm.... it would be cool to have gaussian integers available...
02:39:08 <Axman6> Workybob: probably because a lot of the functions used on Complex rely on fractional things, like sin and cos
02:39:10 <ivanm> not that I see any use for them though ;-)
02:39:17 <Workybob> Axman6: so?
02:39:43 <Workybob> by that logic "a lot of functions used on numbers rely on fractional things, like sin and cos"
02:39:45 <ivanm> Workybob: so you can only use floating point numbers for them
02:39:56 <Workybob> thus, the language shouldn't have Int or Integer anywhere
02:39:59 <ivanm> Workybob: a lot of the stuff that the Data.Complex module defines needs them
02:40:08 <Axman6> Workybob: hence why you can only use sin and cos on ...
02:40:11 <Axman6> :t sin
02:40:12 <lambdabot> forall a. (Floating a) => a -> a
02:40:16 <Axman6> Floatings :P
02:40:18 <mauke> :t signum
02:40:19 <lambdabot> forall a. (Num a) => a -> a
02:40:25 <mauke> heh
02:40:27 <Workybob> Axman6: yes... and why is this any harder for Complex
02:40:39 <Axman6> what do you mean?
02:40:40 <Workybob> instance RealFrac a => RealFrac (Complex a) where ...
02:40:51 <Workybob> now I can use sin on exactly the complex numbers I care about it on
02:40:52 <mauke> @src Integral
02:40:53 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:40:53 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:40:53 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:40:53 <lambdabot>     toInteger           :: a -> Integer
02:41:25 * Axman6 assumes people smarted than both he and Workybob decided on these things
02:41:27 <ivanm> Workybob: the cis, etc. stuff requires floating point stuff
02:41:39 <flippanen> what's a gaussian integer?
02:41:46 <ivanm> otherwise, you'd have to specialise cis, etc.
02:41:48 <Workybob> @type
02:41:49 <lambdabot> <no location info>: not an expression: `'
02:41:50 <Workybob> @type cis
02:41:51 <ivanm> flippanen: complex integers
02:41:51 <lambdabot> forall a. (RealFloat a) => a -> Complex a
02:41:59 <Workybob> ... it's already got the RealFloat constrait there
02:42:03 <ivanm> Workybob: actually, you're right
02:42:06 <Workybob> why do I need it on the type too?
02:42:16 <ivanm> that is strange that the constraint is on the data constcructor
02:42:18 <flippanen> ivan: as opposed to Data.Complex?
02:42:21 <ivanm> which is normally a no-no...
02:42:30 <ivanm> Workybob: I'm guessing it's needed for signum or something
02:42:36 <mauke> I doubt that
02:42:43 <ivanm> flippanen: well, "complex numbers" are real numbers
02:42:53 <mauke> signum (a :+ b) = signum a :+ signum b
02:43:19 <ivanm> whereas signum z  has the phase of z, but unit magnitude.
02:43:19 <Saizan_> signum z@(x:+y)     =  x/r :+ y/r  where r = magnitude z
02:43:29 <quicksilver> ivanm: hask, ImInYourMonad, kadavar, flippanen, more I can't remember.
02:43:30 <ivanm> Saizan_: exactly
02:43:36 <ivanm> quicksilver: :o
02:43:46 <Axman6> ah, yes
02:43:56 <mauke> oh
02:44:13 * Axman6 thought he had stuck with kadaver
02:44:55 <opqdonut> the only thing that needs to hold for signum is liftA2 (*) signum abs == id
02:44:58 <opqdonut> i guess
02:45:11 <Workybob> Saizan_: that makes sense
02:45:23 <quicksilver> signum x `elem` [-1,0,1] perhaps?
02:45:31 <opqdonut> quicksilver: nah
02:45:34 <quicksilver> > signum (1/0) :: Double
02:45:35 <lambdabot>   1.0
02:46:23 <opqdonut> i wonder whether a quaternion Num instance is feasible
02:46:28 <ivanm> > signum (3:+4)
02:46:29 <lambdabot>   0.6 :+ 0.8
02:46:48 <opqdonut> hmm, should be
02:46:49 <kadaver> if you insist
02:46:57 <ivanm> opqdonut: I'd say so
02:47:34 <opqdonut> ah, there's one in numeric-prelude
02:48:13 <flippanen> > \_ -> 1
02:48:14 <lambdabot>       Overlapping instances for Show (t1 -> t)
02:48:14 <lambdabot>        arising from a use of `...
02:48:19 <flippanen> > (\_ -> 1) 4
02:48:20 <lambdabot>   1
02:51:20 <flippanen> is there a way without fold to map over a list and pass a state between each map?
02:51:22 <yowgi> flippanen, (\_ -> x) = const x
02:51:25 <flippanen> between each element
02:51:35 <opqdonut> :t mapM
02:51:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:51:39 <Axman6> > signum ((-3) :+ (-4))
02:51:40 <opqdonut> in the state monad
02:51:40 <lambdabot>   (-0.6) :+ (-0.8)
02:51:41 <quicksilver> mapM in the state monad
02:51:46 <flippanen> > const 5
02:51:47 <quicksilver> or mapAccumR or mapAccumL
02:51:47 <lambdabot>       Overlapping instances for Show (b -> t)
02:51:47 <lambdabot>        arising from a use of `s...
02:51:52 <flippanen> > const 5
02:51:53 <lambdabot>       Overlapping instances for Show (b -> t)
02:51:53 <lambdabot>        arising from a use of `s...
02:51:57 <flippanen> > const 5 6
02:51:58 <lambdabot>   5
02:52:00 <quicksilver> which are basically mapM in the state monad unwrapped.
02:54:50 <opqdonut> > flip runState 2 $ mapM (\x -> do modify (+1); fmap (*x) get) [1,2,3]
02:54:51 <lambdabot>   ([3,8,15],5)
02:56:25 <Axman6> that right there is why i don't get the State monad
02:57:06 <ivanm> Axman6: heh, I just don't touch the state monad at all ;-)
02:57:17 * ivanm does a lot of list-based stuff
02:57:19 <Axman6> me either
02:57:42 <ivanm> I understand the point of it, but not how to use it (and have never really had a need to)
02:57:55 <Axman6> same here
02:58:36 <opqdonut> just regard it as one mutable variable
02:59:08 <opqdonut> "modify (+1)" is "var += 1", "fmap (*x) get" is just slang for "return x*var"
02:59:34 <ivanm> opqdonut: what is it getting? the 2, or mapping over the list?
02:59:45 <RayNbow> the only hard part of opqdonut's example is that it was on one line without syntax highlighting :p
02:59:54 * Axman6 thinks that thinking of get as the name of the variable might help him understand it somewhat
03:00:02 <opqdonut> ivanm: it's mapping over the list, threading the changes to var left-to-right
03:00:06 <opqdonut> var starts at value 2
03:00:20 <opqdonut> ?src mapM
03:00:21 <lambdabot> mapM f as = sequence (map f as)
03:00:29 <opqdonut> gah, bad definition
03:00:45 <ivanm> opqdonut: ahhh, so does 2 remain constant, or stay there from "run-to-run" (and end up as 5)?
03:01:02 <opqdonut> think about "mapM f (x:xs) = do a <- f x; as <- mapM f xs; return (a:as)"
03:01:22 <ivanm> @type runState
03:01:23 <lambdabot> forall s a. State s a -> s -> (a, s)
03:01:29 <opqdonut> ivanm: in a sense 2 changes into 5 during the execution of that
03:01:46 <opqdonut> but as you see, runState eliminates the monad
03:01:50 <ivanm> opqdonut: oh, "modify" changes the 2?
03:01:54 <opqdonut> yes.
03:01:57 <opqdonut> :t modify
03:01:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:02:00 <ivanm> that makes sense then
03:02:03 <opqdonut> s is the state type
03:02:10 <Saizan_> modify f = do s <- get; put (f s)
03:02:11 <ivanm> so it's a mapAccum kind of thing
03:02:12 <Axman6> what's get do?
03:02:13 <opqdonut> it would be nice if modify would return either the old or the new value
03:02:15 <opqdonut> instead of ()
03:02:31 <Saizan_> get simple gives you the "stored" value
03:02:31 <ivanm> Axman6: get a value
03:02:33 <opqdonut> ivanm: yes
03:02:47 <opqdonut> 1252.00  quicksilver$ which are basically mapM in the state monad unwrapped.
03:02:52 <Axman6> and modify modifies that value... ok
03:02:55 <opqdonut> (referring to mapAccumL and R)
03:03:08 <opqdonut> i could've said "a <- get; put (a+1)"
03:03:24 <ivanm> Axman6: IIUC, modify changes the state; get gets the value it acts upon (the items in the list in this case)
03:03:31 <ivanm> or do I have it the wrong way round?
03:03:53 <Saizan_> get gets the state
03:04:05 <ivanm> is the \ x -> ... getting the value from the list? or is x the state?
03:04:16 <Axman6> the ist
03:04:18 <Axman6> l*
03:04:21 <ivanm> *nod*
03:04:24 <opqdonut> ivanm: \x-> gets the val from the list
03:04:26 <opqdonut> get get's the state
03:04:29 <opqdonut> gah
03:04:31 <opqdonut> *gets
03:04:39 <ivanm> that's right, State just creates one big function, and runState applies it
03:04:58 <opqdonut> ?unmtl State s a
03:04:59 <lambdabot> s -> (a, s)
03:05:02 <opqdonut> see?
03:05:21 <opqdonut> State is just a dsl for propagating variables
03:05:29 <ivanm> *nod*
03:05:39 <opqdonut> instead of doing let (a,s1) = f s0; (b,s2) = g s1 in a+b
03:05:45 <ivanm> @type put
03:05:46 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
03:05:56 <ivanm> so put replaces the state?
03:05:59 * Saizan_ wonders how one can evade a State tutorial from Cale for so long on #haskell
03:06:00 <opqdonut> one does "a <- f; b <- g; return (a+b)"
03:06:04 <opqdonut> ivanm: yes
03:06:06 <ivanm> get returns the state?
03:06:13 <opqdonut> put is modify . const
03:06:13 <ivanm> and modify is kind of an fmap on the state?
03:06:16 <opqdonut> yes
03:06:21 <ivanm> Saizan_: I've already had a few ;-)
03:06:24 <opqdonut> so we have two "fmaps"
03:06:27 <ivanm> I can just never remember them ;-)
03:06:31 <opqdonut> the normal fmap that maps on the value
03:06:36 <opqdonut> and modify that fmaps the state
03:06:42 <Axman6> Saizan_: i've had one or two as well :P
03:06:49 <ivanm> opqdonut: *nod*
03:06:53 <ivanm> @src modify
03:06:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:06:54 <osfameron> I've managed to avoid any tutorials by *still* not having finished any complete program that actually requires state :-(
03:06:57 <ivanm> grrr...
03:07:00 <osfameron> pesky day job!
03:07:04 <opqdonut> (that earlier example could be rephrased as "liftM2 (+) f g" of course)
03:07:08 <ivanm> osfameron: I still haven't used one either ;-)
03:07:14 <osfameron> hehe
03:07:15 <quicksilver> no program requires state, of course.
03:07:20 <opqdonut> @src State modify
03:07:20 <lambdabot> Source not found. Take a stress pill and think things over.
03:07:21 <ivanm> I've just asked "wtf is this State stuff" a few times
03:07:25 <quicksilver> the state monad is just a convenietn set of combinators for building functions.
03:07:26 <opqdonut> @src modify State
03:07:26 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:07:29 <opqdonut> gah
03:07:33 <ivanm> IIRC, the only tutorial that I understood about State was in RWH
03:07:34 <opqdonut> yeah, quicksilver is right
03:07:41 <opqdonut> it's just syntax sugar really
03:07:42 <opqdonut> nothing deep
03:07:47 <quicksilver> or, alternatively, the state monad is a convenient way to use an existing set of combinators (the monad combinators) in a particular way to build functions.
03:07:51 <ivanm> opqdonut: he's right, but there's nothing there? ;-)
03:08:00 <ivanm> quicksilver: *nod*
03:08:27 <ivanm> when we refer to "combinators" in Haskell, do they have the same meaning as in the lambda calculus?  (which IIUC, is a way of combining functions)
03:08:30 <opqdonut> monad as useful set of combinators
03:08:33 <opqdonut> is the best view on monads i know
03:08:59 <opqdonut> ivanm: combinators in LC are sometimes defined as lambdaterms that merely permute their arguments
03:09:04 <opqdonut> which is a bit more restrictive
03:09:15 <quicksilver> I think of combinators as a style of programming without explicit lambdas.
03:09:17 <opqdonut> combinators are something one uses to build a DSL, IMO
03:09:27 <opqdonut> yeah, that's a good POV too
03:09:32 <ivanm> opqdonut: oh, I liked the one attributed to wadler in that "A Brief, Incomplete and Mostly Wrong history of programming languages" post ;-)
03:09:38 <quicksilver> in particular, they act directly on each other, or on higher order values.
03:09:58 <ivanm> quicksilver: come again?
03:11:54 <vegai> do you know if there's a nice way to detect that a socket that was converted to a handle is alive?
03:13:16 <ivanm> quicksilver: using combinators is a way of getting rid of variables? so it's related to pointfree programming?
03:13:23 <opqdonut> yes
03:14:01 <ivanm> so (.) is a combinator? (the simplest combinator?)
03:14:09 <opqdonut> yes :)
03:14:19 <Vq^> it's a simple combinator at least
03:14:28 <lilac> I is probably the simplest
03:14:29 <fasta> ivanm: I thought he had a good start, but at the end the jokes were not as good.
03:14:36 <vegai> I guess I should stop converting sockets to handles ... doesn't seem like a very stable mechanism
03:14:38 <opqdonut> (.), on, etc. are combinators in the "functions" language
03:14:42 <ivanm> and do combinators lead to pointfree, or does pointfree just happen to have the same basic properties?
03:14:48 <ivanm> fasta: I didn't mind them
03:14:49 <opqdonut> liftM2, ap, etc are combinators in the "monads" language
03:14:52 <ivanm> lilac: identity?
03:14:59 <ivanm> opqdonut: *nod*
03:14:59 <lilac> ivanm: yep.
03:15:10 <Axman6> lilac: there's something very pleasent about that sentense (I is probably the simplest
03:15:36 <lilac> Axman6: indeed ;-) I is so simple, I gets grammar wrong
03:15:39 <opqdonut> ivanm: combinator languages usually need something "to start with", some basic values (or nullary combinators) in addition to the combinators themselves
03:15:47 <Axman6> :)
03:15:58 <ivanm> *nod*
03:16:14 <opqdonut> for example in a "streams" language the simple things might be for example repeat and once (once 1 -> [1,0,0..])
03:16:24 <opqdonut> then we could start interleaving, delaying etc these signals
03:16:28 <opqdonut> and build any signal we wanted
03:16:43 <opqdonut> and have ghc's rewrite rules optimize some combinator combinations etc
03:16:54 <opqdonut> and change the internal representation of signals at will
03:17:03 <vegai> oh, even the sockets underneath don't detect that the connection was lost
03:17:05 <ivanm> streams == infinite list?
03:17:06 <opqdonut> combinator languages are really a "design pattern" if you will
03:17:25 <ivanm> *shudder* I hate design patterns (I failed the exam for that subject)
03:17:29 <opqdonut> ivanm: streams == a timeseries of values, can be realised for example as an infinite list
03:17:36 <opqdonut> or a function time->value
03:17:41 <ivanm> *nod*
03:18:08 <ivanm> I've only "used" streams in a course using SICP that had streams as haskell-style lazy lists (possibly infinite)
03:18:13 <opqdonut> i refer you to a paper "composing contracts", an exellent example of a combinator language
03:18:20 <opqdonut> ?google composing contracts
03:18:21 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm
03:18:21 <lambdabot> Title: Simon Peyton Jones: papers
03:18:25 <opqdonut> there ya go :)
03:18:33 <ivanm> ahhh, yet another SPJ paper ;-)
03:19:00 <ivanm> hmmm.... that almost warrants its own initialisation... "YASP"? :p
03:21:25 <vegai> unix sockets are horror...
03:21:45 * Workybob wonders where "No instance for (MonadIO Ghc)" is coming from
03:22:07 <ivanm> there's a type "Ghc"? :o
03:22:09 <ivanm> @hoogle Ghc
03:22:09 <lambdabot> module Distribution.Simple.GHC
03:22:09 <lambdabot> Distribution.Compiler GHC :: CompilerFlavor
03:22:09 <lambdabot> package ghc-core
03:22:21 <Workybob> ivanm: the Ghc monad
03:22:24 <Workybob> in ghc-api
03:22:26 <ivanm> ahhh
03:22:41 <Workybob> the docs say it has such an instance
03:23:35 <ivanm> @hoogle MonadIO
03:23:36 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
03:23:46 <ivanm> Workybob: maybe it's defined in Trans?
03:23:55 <Workybob> importing that
03:23:59 <Workybob> I need it for liftIO
03:24:34 <ivanm> weird :s
03:24:50 <ivanm> where's ghc-api? is it part of the GHC docs, or a seperate package on hackage?
03:24:54 <vegai> ah, unix socket faq to the rescue :)
03:25:14 <Workybob> here... http://www.haskell.org/ghc/docs/6.10.3/html/libraries/ghc/HscTypes.html#t%3AGhc
03:25:28 <ivanm> vegai: is the answer to Q1 something along the lines of "You shouldn't be touching this stuff"? :p
03:25:57 <ivanm> no sources :(
03:26:05 <ivanm> so can't check the source to make sure :(
03:26:21 <ivanm> Workybob: http://www.haskell.org/ghc/docs/6.10.3/html/libraries/ghc/MonadUtils.html#t%3AMonadIO
03:26:25 <ivanm> might be a different MonadIO...
03:26:46 <Workybob> ah, it is indeed
03:26:48 <Workybob> cheers
03:27:00 <ivanm> are they re-exporting it, or re-defining it? :s
03:27:18 <flippanen> > mapM randomR [1,2,3]
03:27:19 <lambdabot>       Overlapping instances for Show (g -> [(a, g)])
03:27:19 <lambdabot>        arising from a us...
03:27:58 <ivanm> @type randomR
03:27:59 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
03:28:23 <ivanm> flippanen: randomR takes two parameters...
03:28:30 <ivanm> neither of them are numbers
03:28:33 <ivanm> @type randomR
03:28:34 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
03:28:49 <ivanm> > randomR (1,4) (mkStdGen 3)
03:28:50 <lambdabot>   (2,160056 40692)
03:28:56 <ivanm> > randomRs (1,4) (mkStdGen 3)
03:28:57 <lambdabot>   [2,4,3,4,2,2,3,3,3,3,4,2,1,4,4,4,3,3,4,1,1,4,3,2,4,2,2,2,2,2,1,4,3,3,1,1,2,...
03:30:17 <flippanen> so can you mapM a list and pass on the generator between each?
03:30:41 <ivanm> hmmm?
03:30:54 <ivanm> sounds like you want mapAccumL, but it isn't really valid here
03:30:59 <ivanm> flippanen: what do you want to do?
03:31:32 <flippanen> pass along a seed in a function really
03:31:46 <flippanen> learn how to use randomGen better
03:31:52 <flippanen> ther eis the ones usign a global generator
03:32:07 <flippanen> but i want to use the pass along new seed and randmized value
03:32:07 <ivanm> ummmm.... well, you could do something like this:
03:32:23 <ivanm> > map (randomR (1,10) . mkStdGen) [1..10]
03:32:25 <lambdabot>   [(8,80028 40692),(2,120042 40692),(6,160056 40692),(10,200070 40692),(4,240...
03:32:30 <ivanm> don't know why you'd use mapM here...
03:32:36 <ivanm> > map (fst . randomR (1,10) . mkStdGen) [1..10]
03:32:37 <lambdabot>   [8,2,6,10,4,8,2,6,10,4]
03:32:56 <ivanm> though if you want to "thread" the seed through, you have randomRs or else use mapAccumL
03:33:53 <flippanen> @type mapAccumL
03:33:54 * Bacta farts
03:33:54 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:34:02 <flippanen> @slap Bacta
03:34:02 * lambdabot decomposes Bacta into several parts using the Banach-Tarski theorem and reassembles them to get two copies of Bacta!
03:34:14 <flippanen> @slap Bacta1
03:34:14 * lambdabot will count to five...
03:34:15 <flippanen> @slap Bacta2
03:34:16 * lambdabot jabs Bacta2 with a C pointer
03:34:26 <Bacta> ow :(
03:34:33 <ivanm> flippanen: that's enough methinks
03:34:37 <Bacta> @faq kick flippanen
03:34:37 <lambdabot> The answer is: Yes! Haskell can do that.
03:44:13 <lilac> @type (runState.).mapM.(State.)
03:44:14 <lambdabot> forall s a a1. (a1 -> s -> (a, s)) -> [a1] -> s -> ([a], s)
03:45:51 <mgee> does there exist a matrix library which works with CReal? the perfect would be: Matrix (Complex CReal) :D
03:46:15 <mgee> From what i read hmatrix only supports Double. but i will check if it works with CReal
03:49:14 <quicksilver> mgee: I'm sure it doesn't.
03:49:24 <quicksilver> hmatrix is an interface to one or more C libraries.
03:49:37 <quicksilver> CReal is a clever pure haskell representation of arbitrary precision reals.
03:50:23 <ivanm> mgee: hmatrix supports Float as well (though why you'd use Float rather than Double is beyond me)
03:50:44 <ivanm> IIRC, the type needs to be an instance of Storable as well
03:50:45 <mgee> quicksilver: mhh ok
03:50:59 <ivanm> mgee: you could use Array (Int,Int) CReal if you want to...
03:51:02 <mgee> ivanm: that would make sense, since hmatrix requires storable-complex
03:51:53 <mgee> ivanm: then i had to implement the matrix multiplication by myself, right? mhh that can't be too hard :D
03:51:57 <niarium> Hi, i'm trying to install SDL-0.5.3 package on Windows, and i successfully configured it with "runhaskell Setup configure" but can't install it, getting this >>> Setup: Error: Could not find module: Graphics.UI.SDL with any suffix: ["hi"]
03:52:26 <ivanm> niarium: do you have the SDL libraries for C installed?
03:52:36 <niarium> yes
03:52:50 <ivanm> hmmm...
03:53:02 <niarium> i'm actually coding in C with SDL
03:53:08 <ivanm> maybe it can't find them? *shrug*
03:53:57 <niarium> well... doesn't "Graphics.UI.SDL" mean a haskell package instead of a C library?
03:54:47 <ivanm> yes, but I figured let's get the obvious things out of the way ;-)
03:55:04 <ivanm> niarium: did you do "runhaskell Setup.hs build" first?
03:56:18 <niarium> i tried "cabal install SDL"
03:56:33 <ivanm> same problem?
03:56:55 <niarium> oh, guess you were right at the first place... "* Missing header file: SDL.h"
03:56:59 <niarium> :(
03:57:33 <ivanm> niarium: so you need to add the path to where SDL is installed to the cabal file using Include-Dirs:
03:57:42 <ivanm> that's what happens here on gentoo
03:57:55 <mgee> weird. i try to install HERA using cabal and in the configure step it always says:  Missing header file: hsmpfr.h. this file is delivered with HERA in a subfolder called "C"
03:57:56 <niarium> but the problem is that "Could not find module" thing comes when i manually specify the include dir and lib dir
03:58:34 <mgee> and the C directory is listed under "include-dirs" in the cabal file
03:59:00 <niarium> with --extra-include-dirs="C:\MinGW\include\SDL" --extra-lib-dirs="C:\MinGW\lib"
03:59:19 <dcoutts> mgee: it could be that trying to use hsmpfr.h fails
03:59:58 <mgee> dcoutts: because something in hsmpfr.h doesn't work?
04:00:13 <dcoutts> mgee: what it does is compile a trivial .c file that #includes hsmpfr.h and if that fails then it concludes that the file is missing, but it could be present but be borked
04:00:52 <dcoutts> mgee: right, for example perhaps you cannot actually include hsmpfr.h on its own, but have to list a bunch of other headers first
04:01:05 <dcoutts> in which case the .cabal file should list them
04:01:13 <mgee> dcoutts: i solved it
04:01:15 <mgee> :)
04:01:23 <dcoutts> mgee: how?
04:02:36 <mgee> the hsmpfr.h included "malloc.h". this include lead to an compile error, because the malloc.h seems to be always included on mac osx systems. so the include failed with "no such file or directory"
04:03:06 <dcoutts> mgee: right, unfortunately our error reporting on that is pretty poor
04:03:07 <mgee> there is an ifdef missing, which checks if the host system is a mac system
04:03:32 <niarium> ivanm: this is what i get when i try "cabal install SDL" with dir specified http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2430
04:04:15 <ivanm> *shrug* I don't know, have never touched SDL before
04:04:40 <ivanm> but it looks like the main problem is /Users/hercules/trunk/SDL-1.2/./src/main/win32/SDL_win32_main.c:246: undefined r
04:04:40 <ivanm> eference to `SDL_main'
04:04:57 <Wraithan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2431#a2431
04:05:13 <Wraithan> On line 24 how would I convert that from an IO Char to a String?
04:05:17 <Wraithan> So I could use it in the case
04:05:52 <niarium> IO Char to a String? you mean IO [Char] to a String?
04:06:00 <Wraithan> niarium: Aye, sorry
04:06:58 <dcoutts> mgee: would you mind filing a ticket about this issue that header file problems are not reported well, that it says the thing is missing and there's no easy way to see what the error really is.
04:07:04 <Wraithan> usually I have to use var <- IO [Char] returning function
04:07:12 <dcoutts> mgee: http://hackage.haskell.org/trac/hackage/
04:07:17 <Cale> Wraithan: that's right, that's what you do
04:07:21 <mgee> dcoutts: ok will do
04:07:35 <dcoutts> mgee: thanks, paste the details of your example
04:07:36 <Cale> Wraithan: run the action before the case.
04:08:38 <Cale> Wraithan: does that solution make sense?
04:09:40 <Wraithan> Yes and no, I guess it is my fault for putting IO [Char]s into the pairs instead of changing it back to a [Char] first
04:09:49 <Wraithan> I need to rethink how I have everything in this
04:11:56 <Cale> Wraithan: It's best not to think of an IO [Char] as being anything like a string
04:12:21 <Cale> It's an action, or program, which you may run in order to get a String.
04:12:46 <Wraithan> Actually I am having a hard time figuring out how it ended up as an IO [Char]
04:13:09 <Cale> I have your program here, which IO [Char] is it?
04:13:47 <niarium> probably because a battery state is something outside the world your code
04:14:06 <Cale> oh, I see, having loaded it into ghci :)
04:14:26 <Wraithan> Line 24 I am getting Couldn't match expected type `[Char]' against inferred type `IO Char'
04:14:34 <Cale> You have some cases where you're producing strings.
04:14:52 <Cale> It's the result of that case expression which is the problem
04:15:09 <Cale> A string isn't an IO action, but since this is a line of a do-block, it must evaluate to an IO action.
04:15:35 <Cale> (well, to some monadic action, and readFile is already the IO monad, so it must be that)
04:15:51 <Wraithan> I couldn't figure out how to make that function a let statement because of the batterState <- readFile
04:15:57 <Wraithan> perhaps I should seperate that out
04:16:08 <Cale> The problem is with ""
04:16:25 <Cale> "" is a String, what is it doing there?
04:16:29 <niarium> oh yeah
04:16:37 <niarium> should be something like return ""
04:16:42 <Wraithan> Oh
04:16:45 <Wraithan> I get it
04:16:53 <Cale> But even if it was return "", on the next line you have return 0
04:17:00 <Cale> So... it would just ignore it anyway.
04:17:04 <Wraithan> the return 0 part I left in there, meant to remove it
04:17:07 <Cale> ah
04:18:10 <Wraithan> I should seperate out the part where I read the file, so I can turn that function into a let .. in statement probably right?
04:18:58 <Wraithan> Then I could turn it into a pure function? instead of having the IO crap in there
04:19:01 <Cale> yeah
04:19:13 <Wraithan> This langauge, it hurts my head lol
04:19:22 <ski> Workybob : did you want the gaussian complex integers or the eisensteinian complex integers ?
04:19:29 <Cale> That would be a good idea. Even just having it take the contents of the state file as a string parameter is probably cleaner.
04:21:15 <ski> @quote hurting
04:21:16 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
04:21:16 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
04:21:20 <ski> @quote hurting
04:21:20 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
04:21:33 <ivanm> ski: what are the einstinian ones?
04:22:05 <Cale> @quote explode
04:22:06 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
04:22:06 <lambdabot> everyone inside.
04:22:13 <Cale> mm...
04:22:14 <ski> ivanm : add the three third-degree roots of unity to the integers
04:22:25 <Cale> Not quite the kind of explode I was thinking I'd get :)
04:22:30 <wli> ski: Eisenstein integers?
04:22:35 <ski> ivanm : also, s/einstein/eisenstein/
04:22:40 <ivanm> ski: so einstinian are a subset of gaussian?
04:22:46 <ski> no
04:22:49 <Wraithan> Once a year? More often than that I'd think, but then again, a car could only really explode once I guess
04:23:03 <FunctorSalad> @hoggle (b -> c) -> (a -> m b) -> a -> m c
04:23:03 <lambdabot> No results found
04:23:14 <FunctorSalad> I sometimes miss that one
04:23:17 <ski> the "imaginary units" are no eisensteinian integers
04:23:29 <FunctorSalad> "return . g <=< f" it is, I guess
04:23:34 <wli> No, Z[x]/(x^2+x+1) is not a superset or a subset of Z[x]/(x^2+1)
04:23:55 <ski> you could represent an eisensteinian integer as a triple of three naturals `(a,b,c)', where at least one of those are zero
04:24:03 <Cale> http://en.wikipedia.org/wiki/Eisenstein_integer has a good little diagram
04:24:09 <ivanm> yeah, just found it
04:24:36 <FunctorSalad> what is more integer about these than all the other Z[some complex number]? ;)
04:24:47 <Cale> I had a friend in uni with the last name Eisenstein. Everyone would ask if he was related to *that* Eisenstein, but he didn't know.
04:24:54 <ivanm> heh
04:25:04 <ivanm> ski: what are eisenstein integers used for?
04:25:05 <ski> FunctorSalad : how about `liftM g . f' ?
04:25:24 <FunctorSalad> ski: yep that works too
04:25:26 <ski> ivanm : heh, that i don't know
04:25:30 <ivanm> heh
04:25:52 * ski can't give a direct application of gaussian integers either, for that matter
04:25:59 <ivanm> true
04:26:21 <ivanm> though we ended up using them a lot in the number theory + abstract algebra course I did last year
04:26:31 <ivanm> and that's one of the few things I remember from it ;-)
04:26:36 <Cale> ivanm: I suppose they're a particularly nice Euclidean domain, and some things are known about primes in there.
04:26:55 <ivanm> *nod*
04:27:08 <Wraithan> :t readFile
04:27:09 <lambdabot> FilePath -> IO String
04:27:16 <Wraithan> :t FilePath
04:27:17 <lambdabot> Not in scope: data constructor `FilePath'
04:27:18 <ivanm> "In a footnote he [Gauss] notes that the Eisenstein integers are the natural domain for stating and proving results on cubic reciprocity and indicates that similar extensions of the integers are the appropriate domains for studying higher reciprocity laws."
04:27:25 <Cale> Wraithan: It's just another name for String
04:27:55 <Wraithan> Cale: Ok, wanted to make sure, was going to use that as a parameter of my readFileToString function
04:28:10 <Wraithan> Will just use String
04:29:09 <wli> Quadratic algebraic integer extensions of Z are a big topic in number theory.
04:29:11 <Cale> Wraithan: You can say FilePath as reasonable documentation if you like :)
04:29:29 <wli> Gaussian integers are one of the bigger ones.
04:29:50 <Cale> Also, it seems natural that the ring of algebraic integers of Q(something nice) is generally somewhat interesting.
04:30:07 <Cale> Roots of unity are particularly good :)
04:30:28 <wli> Cyclotomic extensions are a topic of their own (cyclotomy).
04:31:33 <Wraithan> I am having a hard time coming up with how I would have a function use readFile then return a String and not have it return IO anything
04:31:43 <Cale> Wraithan: Impossible.
04:32:11 <Cale> Wraithan: It can pass a String to another function, but if it does IO, an IO will be in its type.
04:32:21 <Wraithan> Ugh.
04:32:40 <Cale> Wraithan: The key is to do all your IO separately.
04:32:40 <Wraithan> I am about to just say fuck it and give up, all this IO stuff is bothering me.
04:32:59 <Cale> Wraithan: You only have a couple files to read, and then some output to do, based on that, yeah?
04:33:05 <Wraithan> Right
04:33:16 <Cale> Wraithan: So, very little of your program should be in the IO monad.
04:33:26 <Wraithan> Yeah, I think that as well.
04:33:30 <Cale> Specifically, *just* the parts which do IO
04:33:31 <ivanm> Wraithan: you read stuff in, pass the text to whatever functions do stuff with it, the return the output and you print/whatever the result
04:33:47 <Cale> The rest should be a pure function from the input to the desired output.
04:33:49 <blackh> Wraithan: At this point, I need to say some Zen koan or other to inspire you, but I can't think of anything.
04:34:07 <Wraithan> But since i can't just return a string from a function that reads that file it seems I would have to polute the shit out of my main function with file IO to get it done
04:34:19 <blackh> "If you want to prevail, you must be like water."  I don't think that's relevant, but it sounds good.
04:34:32 <ivanm> Zen master say: koan's usefulness like objects in Haskell
04:34:33 <Cale> Wraithan: main has to be in IO anyway
04:34:37 <ivanm> *shrug* sounds random enough
04:34:42 <Cale> Wraithan: The stuff which main uses does not.
04:34:48 <wli> Solving cyclotomic polynomials in terms of radicals could be interesting.
04:34:50 <ivanm> Wraithan: most mains are like that AFAIK
04:34:52 <opqdonut> Wraithan: au contraire, you can _fmap_ a pure function (String->String) over the IO String
04:35:03 <opqdonut> for example:
04:35:05 <opqdonut> :t interact
04:35:06 <lambdabot> (String -> String) -> IO ()
04:35:09 <ivanm> blackh: hmmm... we need an @zen to complement @yow...
04:35:30 <opqdonut> takes a pure function and makes an io action that reads stdin, applies the function, and outputs to stdout
04:35:38 <blackh> ivanm: I'm a cabal-ist.
04:36:06 <Wraithan> Hmmm
04:36:14 <ivanm> blackh: I have it on good authority from dcoutts that there is no such thing as the secret Haskell Cabal organization!
04:36:24 <ivanm> so you can't be a cabal-ist, since there is no cabal!
04:36:25 <ivanm> :p
04:36:25 <Wraithan> I think I will just start poluting my main function and blow it up with all my file IO
04:36:49 <ivanm> Wraithan: either that, or abstract out the file stuff to another function (that does the IO)
04:36:52 <Wraithan> I am so used to keeping all my IO in the functions that actually use it
04:36:58 <Wraithan> ivanm: how.
04:37:06 <ivanm> depends on what you're doing
04:37:13 <blackh> Wraithan: I only just got here. Do you want any suggestions on your code? Hopefully you've got a little bit more gumption before you give up yet.
04:37:31 <ivanm> but if you're doing the same thing on more than one file, abstract out the "get the file, apply function f to the contents, print the file out" to another function
04:37:50 <Wraithan> I can't return a string, so I can't get the contents of a file to a string without having to return an IO which seems to IO everything else
04:38:04 <raji> can someone tell me how to count the number of ways in this problem http://www.codechef.com/APRIL09/problems/A5 ? It is number of huffman trees/
04:38:28 <Wraithan> No, I just use 2 different files for 2 different parts of the application
04:38:31 <Wraithan> Well, soon to be 3
04:38:56 <ivanm> Wraithan: what are you trying to do?
04:39:12 <Wraithan> BAT0/state and BAT0/info for getting the battery state and time till charged, and AC/state for getting if my laptop is plugged in
04:39:15 <blackh> Wraithan: Let me try to understand your problem... hmm... Do you want it to run once and then exit, or does it loop?
04:39:29 <Wraithan> run once and exit
04:39:42 <Wraithan> Most of the functions will be moved over into a plugin for xmobar
04:39:51 <Wraithan> because xmobar's battery monitor is garbage.
04:40:03 <Wraithan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2431#a2431
04:40:07 <ivanm> Wraithan: OK, so you have an abstraction: Read a file, parse it, return the information
04:40:10 <Wraithan> Doesn't compile right now
04:40:14 <blackh> Ah, OK. Do you have to do graphics in xmobar, or does it do that bit?
04:40:21 <ivanm> so parseFile :: FilePath -> (String -> a) -> IO a
04:40:29 <wli> http://cg.cs.uni-bonn.de/personal-pages/weber/publications/pdf/WeberA/WeberKeckeisen99a.pdf
04:40:54 * ski to blackh mentions
04:40:57 <ski> @wiki Koans
04:40:58 <lambdabot> http://www.haskell.org/haskellwiki/Koans
04:41:08 <ivanm> Wraithan: for example, for getAC, you'd do it this way:
04:41:29 <Wraithan> blackh: not bothering with graphics, just want acurate information on my battery's % and their plugin doesn't even detect charging/discharging or does it determine the time left until it is discharged/charged
04:41:35 <ivanm> getAC = parseFile "/proc/acpi/ac_adapter/AC/state" (isInfixOf "on-line")
04:42:24 <Wraithan> wouldn't that make getAC return an IO Bool though?
04:42:25 <ivanm> @type interact
04:42:26 <lambdabot> (String -> String) -> IO ()
04:42:28 <wli> This suggests that one should be able to compute radical expressions for cos(k*pi/n) and sin(k*pi/n) for integer n, k with n /= 0.
04:42:29 <ivanm> Wraithan: yes
04:42:35 <ivanm> then you do stuff with it in main
04:42:48 <ivanm> OK, interact isn't applicable here
04:42:58 <Wraithan> afk one sec, hotdogs are going to burn
04:43:36 <ivanm> heh
04:45:57 <Wraithan> back
04:45:59 <Phyx-> ivanm: you the same ivanm from #java on efnet?
04:46:12 <ivanm> I doubt it
04:46:17 <ivanm> highly ;-)
04:46:27 <blackh> Wraithan: Here's a way to write getAC:: parseAC :: String -> Bool ; parseAC = isInfixOf "on-line"  - that is, just parse it...
04:46:27 * ivanm wants to know who stole his nick... :@
04:46:53 <ivanm> blackh: I believe I've covered that...
04:46:58 <ivanm> he doesn't like that it returns IO Bool
04:47:00 <blackh> Wraithan: Then you can say: main = do ; acStatus <- getAC `fmap` readFile "/proc/acpi/ac_adapter/AC/state
04:47:14 <ivanm> (though I used a different function)
04:47:42 <Wraithan> *googles fmap*
04:47:46 <blackh> make that:  acStatus <- parseAC `fmap` readFile "/proc/acpi/ac_adapter/AC/state"
04:48:45 <blackh> Wraithan: The use of fmap here is equivalent to:   text <- readFile "/proc/acpi..." ; let acStatus = parseAC text
04:49:08 <blackh> That is, you're passing the output through a pure function on the left of `fmap`
04:50:01 <Wraithan> Ok I think I understand
04:50:04 <blackh> So the point is that your I/O is reduced to three lines in main... Now....
04:50:31 <blackh> This is not type safe, in that it would be possible to mix up the files and the parsers.
04:50:47 <blackh> In this particular example, the program is so short that it doesn't matter.
04:50:47 * ivanm still thinks having a parseFile function is nicer than fmap...
04:51:26 <FunctorSalad> does anyone know of a bunch of test cases for SYB-like libs?
04:51:48 <FunctorSalad> (maybe I should start by looking in Syb.)
04:52:10 <wh1t3> hmmm, does anyone have any idea whether or not wxWidgets works on Vista?
04:52:13 <blackh> ivanm, Wraithan: That's a good point, but you can still do that while separating the I/O out from the parsing.
04:52:28 <wh1t3> i can load the package, but if i want to use something that uses it it instantly crashes
04:52:48 <blackh> Wraithan: Another way to make it more typesafe would be to use 'newtype'.  So it'd be something like this:
04:53:11 <Wraithan> blackh, ivanm: thanks for being patient, sorry I am being rather dense about this
04:53:50 <blackh> newtype ACStateContents = ACStateContents String
04:53:58 <blackh> All this does is wrap a type around it,... then
04:54:09 <blackh> readACState :: IO ACStateContents
04:54:19 <blackh> parseACState :: ACStateContents -> Bool
04:54:59 <blackh> This is probably overkill for this code but I am just trying to say that this is a way to separate the I/O and logic without any risk of using the wrong parser
04:56:06 <Wraithan> If I am in main anyway with this code, can't I (shouldn't I) just do fileContents <- readFile "/path/to/file"; let parsedValue = parse fileContents;
04:56:08 <blackh> Then: main = do ; acStatus <- parseACState `fmap` readACState
04:56:28 <Wraithan> without all this funky types or fmap stuff?
04:56:32 <blackh> Overdesigned, but you can see that you're now free to easily arrange these components in different ways.
04:56:35 <ivanm> Wraithan: having a seperate function to do that abstracts it out
04:56:52 <ivanm> even using an fmap halves the number of lines
04:56:54 <LeCamarade> Guys, I can't build gtk2hs, in order to build Leksah, and the error is Failed to load interface for `System.Glib.UTFString'
04:56:54 <blackh> Wraithan: Same but without the funky fmap stuff:
04:56:58 <LeCamarade> What to do?
04:57:05 <ski> Wraithan : that's doing the same as blackh's : acStatus <- parseAC `fmap` readFile "/proc/acpi/ac_adapter/AC/state"
04:57:06 <Wraithan> Right but I am still having a really hard time figuring out why or how that stuff works
04:57:07 <blackh> acTxt <- readACState
04:57:09 <ivanm> LeCamarade: why can't you build gtk2hs
04:57:16 <blackh> let acStatus = parseACState acTxt
04:57:21 <ski> Wraithan : the `fmap' is just a way to write it shorter
04:57:48 <Wraithan> I think I am going to skip over it for now and make it work again, as I have broken things lol
04:57:49 <FunctorSalad> fmapfmapfmap
04:57:55 <LeCamarade> ivanm, That's the error I'm getting.
04:58:12 <ivanm> LeCamarade: what error?
04:58:28 <ivanm> you can't start an irc message with '/', remember...
04:58:34 <ivanm> @slap FunctorSalad
04:58:34 <FunctorSalad> /
04:58:34 * lambdabot smacks FunctorSalad about with a large trout
04:58:48 <FunctorSalad> ivanm: /say /
04:58:49 <FunctorSalad> ;)
04:58:54 <ivanm> or //
04:58:56 <ivanm> or " /"
04:59:07 <canvon> blackh: [risk of using wrong parser] that problem wouldn't arise with ivanm's approach; file name and parser function would be on the very same logical line. using newtype here seems not only overkill, but much easier to mess up than filename-and-parser-on-the-same-line, because you'd have more type declarations / fancy-name-duplications than actual code
04:59:10 <blackh> Wraithan: You said "do fileContents <- readFile "/path/to/file"; let parsedValue = parse fileContents" which is the same as what I'm saying, just (as ivanm said), the `fmap` lets you shrink it to one line.
04:59:23 <flipLeft> http://www.reddit.com/r/programming/comments/8km2b/which_functional_language_to_learn/
04:59:23 <canvon> (ok I'm being way too slow here)
04:59:36 <flipLeft> I say, learn Haskell and you learn all functional languages...
04:59:52 <blackh> canvon: ivanm's way is better.
04:59:53 <LeCamarade> ivanm, Failed to load interface for `System.Glib.UTFString'
05:00:18 <ivanm> blackh: of course it is! ;-)
05:00:19 <Wraithan> blackh: I see, I just don't see the benefit I guess when I am having a hard time understanding everything and it is yet another thing
05:00:26 <ivanm> LeCamarade: that's gtk2h's problem?
05:00:35 <ivanm> methinks you need some gnome libs installed
05:00:40 <Wraithan> I am just going to code for a while, and get back to you guys, hopefully it will start working again once i am done redesigning it
05:00:42 <LeCamarade> Seems like it, from here.
05:00:45 <ivanm> (I thought that was leksah's build error)
05:00:53 <ivanm> LeCamarade: which compile-time flags are you using?
05:00:56 <LeCamarade> Isn't GLib part of Gtk2Hs?
05:01:19 <ivanm> LeCamarade: is there an error above that?
05:01:25 <ivanm> @seen dcoutts
05:01:25 <lambdabot> dcoutts is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 53m 50s ago.
05:01:47 <LeCamarade> The line that's erring has these flags:
05:01:48 <LeCamarade>  +RTS -RTS -split-objs -c glib/System/Glib.hs -o glib/System/Glib.o -O -XForeignFunctionInterface -iglib -package-conf package.conf.inplace -hide-all-packages -ignore-package glib -package base-4.0.0.0 -package-name glib-0.10.0 '-#include<glib-object.h>' -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include
05:02:36 <Wraithan> 'sides, new office on Hulu, gotta watch it
05:03:48 <LeCamarade> That file, glib/System/Glib.hs refers to a non-existent System.Glib.UTFString, it seems.
05:03:53 <ivanm> LeCamarade: no, the actual flags you're building gtk2hs with
05:04:00 <LeCamarade> I don't know how to proceed past thence.
05:04:27 <blackh> Wraithan: Perhaps getAC = parseAC `fmap` readFile "/proc/..." ; where parseAC = ...   This separates I/O and logic but keeps everything simple
05:04:48 <ivanm> hmmm... gtk2hs had a 0.10.1 release recently, didn't it?
05:05:03 <ivanm> (not related to LeCamarade's problem)
05:05:11 <LeCamarade> I just ./configured and then made.
05:05:29 <ivanm> LeCamarade: so the default options?
05:05:37 <ski> (ivanm : or `/msg #haskell /')
05:05:44 <LeCamarade> Yes, the defaults.
05:05:55 <ivanm> ski: heh
05:06:46 <canvon> /quote PRIVMSG #haskell :/
05:06:47 <canvon> :-)
05:07:03 <blackh> LeCamarade: I built gtk2hs-0.10.1 successfully on Ubuntu on ghc-6.10.2.  Perhaps if I give you my output of ghc-pkg that might help?
05:07:11 <ski__> /
05:08:21 <LeCamarade> blackh, Perhaps. I could get it, and then figure out how to make use of it, your ghc-pkg.
05:08:35 <LeCamarade> Ah, ghc-pkg(1)!
05:08:53 <LeCamarade> Yes, please, blackh.
05:10:20 <blackh> LeCamarade: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2432#a2432
05:10:53 <canvon> ski__: perhaps your client didn't display it (my client didn't on a test elsewhere), but the '/' arrived. ;)
05:11:10 <canvon> oh you have "ski", too
05:11:31 <ski> (it did. only i forgot to change the channel part :)
05:11:32 <kyevan> People shouldn't be allowed to use [foo, bar, baz] until they truly understand foo : bar : baz : []
05:11:43 <blackh> LeCamarade: Maybe some Haskell package or other needs to be some specific version. Or, it could be a missing development package for your OS. What OS?
05:12:31 <LeCamarade> SuSE Linux.
05:13:49 <blackh> LeCamarade: Shouldn't be too different to Ubuntu. At the end of the configure, there's a list of packages it found. Do you want a paste of my one?
05:13:52 <LeCamarade> I think I'll try installing all the little components of GTK.
05:14:17 <LeCamarade> Hold on, let me reconfigure. I've just install glib2-devel.
05:14:40 <blackh> It'll probably be something like that.
05:15:48 <LeCamarade> I'm going to add gio, glade, svgcairo, gtkglext, sourceview, and the mozembed. It should work like yours, then.
05:25:59 <cognominal> probably  a classic, how do I do an integer decrement :    ( - 1 ) $ 1        gives me an error message
05:26:35 <ski> > subtract 1 1
05:26:37 <lambdabot>   0
05:27:27 <ehamberg> > ((-) 1) $ 1
05:27:29 <lambdabot>   0
05:27:37 <ski> > ((-) 5) 2
05:27:39 <lambdabot>   3
05:27:44 <ski> > (flip (-) 5) 2
05:27:46 <lambdabot>   -3
05:27:52 <ski> > (subtract 5) 2
05:27:53 <lambdabot>   -3
05:28:06 <mmorrow> @src subtract
05:28:07 <lambdabot> subtract x y = y - x
05:29:32 <ivanm> converter: or pred
05:29:38 <ivanm> > pred 10
05:29:39 <lambdabot>   9
05:29:50 <mmorrow> > pred 0
05:29:52 <lambdabot>   -1
05:30:14 <mmorrow> for some reason i thought that was going to fail
05:30:30 <ski> > pred (1 / 0)
05:30:32 <lambdabot>   Infinity
05:30:33 <mmorrow> , toEnum (pred 0) :: Char
05:30:36 <lunabot>  luna: Prelude.chr: bad argument
05:30:52 <mmorrow> , pred '\0'
05:30:54 <lunabot>  luna: Prelude.Enum.Char.pred: bad argument
05:30:55 <ski> > pred (chr 0)
05:30:57 <lambdabot>   * Exception: Prelude.Enum.Char.pred: bad argument
05:31:13 <DrSyzygyIE> , minBound :: Char
05:31:15 <lunabot>  '\NUL'
05:31:16 <mmorrow> i don't see why the default for Enum isn't to wrap
05:31:19 <cognominal> thx
05:31:32 <DrSyzygyIE> , '\0' == minBound :: Char
05:31:34 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
05:31:41 <mmorrow> well, i guess then you couldn't do [False ..]
05:31:43 <sm> morning.. what's a good +RTS flag to use to track down where an openFile error is happening ?
05:31:46 <DrSyzygyIE> > '\0' == minBound :: Char
05:31:48 <lambdabot>   Couldn't match expected type `Char' against inferred type `Bool'
05:31:54 <sm> ie, an exception
05:32:01 <DrSyzygyIE> > '\0' == (minBound :: Char)
05:32:03 <lambdabot>   True
05:32:03 <ski> (mmorrow : but that's `fromEnum' ..)
05:32:05 <mmorrow> , '\0' == (minBound::Char)
05:32:07 <lunabot>  True
05:32:16 <mmorrow> ski: true
05:32:21 <ski> @type pred
05:32:23 <lambdabot> forall a. (Enum a) => a -> a
05:32:32 <DrSyzygyIE> , pred 0
05:32:34 <lunabot>  -1
05:32:42 <DrSyzygyIE> , pred minBound
05:32:44 <lunabot>  luna: Prelude.Enum.().pred: bad argument
05:32:51 <DrSyzygyIE> , pred minBound :: Int
05:32:52 <ski> though i suppose one could expect that `pred' and `fromEnum' might be related by such a law, given that they belong to the same class
05:32:53 <lunabot>  luna: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
05:32:58 <DrSyzygyIE> , pred minBound :: Integer
05:33:00 <lunabot>  luna: No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
05:33:02 <LeCamarade> Ah, I think I'm missing utf8-string.
05:35:25 <francescone> ciao
05:35:26 <francescone> !list
05:35:31 <francescone> uhuhuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu+
05:36:54 <raimo_> hey, how do I generate primes with sieve of atkin on haskell?
05:37:26 <raimo_> I found the following site with implementation but it's using some strange poly function http://www.haskell.org/haskellwiki/List_comprehension
05:38:18 <ivanm> never heard of a sieve of atkins...
05:38:59 <mmorrow> ivanm: http://en.wikipedia.org/wiki/Sieve_of_Atkin
05:39:04 <byorgey> raimo_: check out the 'primes' package on Hackage
05:39:19 <DrSyzygyIE> raimo_: That implementation defines poly while performing it.
05:39:31 <DrSyzygyIE> At least I think it does....
05:39:58 <DrSyzygyIE> ?hoogle poly
05:39:59 <lambdabot> module Debug.QuickCheck.Poly
05:39:59 <lambdabot> module Test.QuickCheck.Poly
05:39:59 <lambdabot> Distribution.Extension PolymorphicComponents :: Extension
05:40:01 <raimo_> defines while performing, how it's done?
05:40:07 <raimo_> I have to check the sources of that prime package
05:40:13 <DrSyzygyIE> Never mind. I was being stupid.
05:41:01 <raimo_> thanks for the hoogle anyway, hadn't heard of that before
05:41:18 <DrSyzygyIE> raimo_: Oh? It is a LOT more powerful than this!
05:41:26 <DrSyzygyIE> ?hoogle a -> b -> b
05:41:27 <lambdabot> Control.Parallel par :: a -> b -> b
05:41:27 <lambdabot> Control.Parallel pseq :: a -> b -> b
05:41:27 <lambdabot> Prelude const :: a -> b -> a
05:41:47 <Phyx-> Well i'll be darn.. it actually typechecked
05:41:54 <DrSyzygyIE> ?hoogle (a -> b -> b) -> b -> [a] -> b
05:41:55 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
05:41:55 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
05:41:55 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:42:02 <ski> @hoogle+
05:42:02 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:42:02 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
05:42:02 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
05:45:34 <mmorrow> @hoogle a
05:45:35 <lambdabot> Text.XHtml.Frameset abbr :: Html -> Html
05:45:35 <lambdabot> Text.XHtml.Strict abbr :: Html -> Html
05:45:35 <lambdabot> Text.XHtml.Transitional abbr :: Html -> Html
05:45:47 <mmorrow> @hoogle ->
05:45:47 <lambdabot> keyword ->
05:46:03 <mmorrow> @hoogle (a -> b) -> c
05:46:04 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
05:46:04 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
05:46:04 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:47:26 <romildo> Hi.
05:48:04 <romildo> Should the following program print the contents of p1.calc into standard output?
05:48:11 <romildo> main = withFile "p1.calc" ReadMode hGetContents >>= print
05:49:16 <romildo> Although the file p1.calc is not empty, it just prints the empty string with ghc-6.10.3 on my system.
05:49:25 <ski> @type System.IO.withFile
05:49:26 <romildo> Any clue
05:49:26 <lambdabot> forall r. FilePath -> GHC.IOBase.IOMode -> (GHC.IOBase.Handle -> IO r) -> IO r
05:49:42 <ski> i think this is because `hGetContents' is lazy
05:49:56 <ski> try
05:50:05 <ski>   main = withFile "p1.calc" ReadMode (hGetContents >>= print)
05:50:49 <ski> (above, the file was closed before any of the string returned by `hGetContents' was forced)
05:51:11 <ski> (i'd prefer an exception to an empty string, in this case)
05:52:26 <romildo> withFile "p1.calc" ReadMode (hGetContents >>= print) does not type check.
05:53:25 <canvon> romildo: guessing: \h -> hGetContents h >>= print
05:53:27 <ski> er, right
05:53:30 <ski> >=>
05:53:52 <canvon> @hoogle >=>
05:53:53 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:54:26 <ski> @type System.IO.withFile "p1.calc" System.IO.ReadMode (System.IO.hGetContents >=> print)
05:54:27 <lambdabot> IO ()
05:57:01 <romildo> So I have to process the contents of the file in the action passed to withFile, otherwise the file is closed too early, right?
05:57:55 <canvon> romildo: there's also readFile, btw
05:57:58 <ski> either that, or at least force the string before `withFile' returnd
05:58:55 <ivanm> when did ghc get stm?
05:59:03 <ivanm> 6.8? or even earlier?
05:59:22 <ski>   withFile "p1.calc" ReadMode (hGetContents >>= \s -> evaluate (genericLength s) >> return s) >>= print
06:00:16 <Saizan_> s/>>=/>=>/ ?
06:00:46 <ski> yes
06:00:52 * Saizan_ didn't see the above code
06:01:27 * ski 's brain seems to insist thinking that `hGetContents' actually was `getContents' ..
06:08:29 <gnuvince> Latin question: is it "in sito" that's used to designate an in-place modification?
06:08:45 <quicksilver> "in situ"
06:09:18 <gnuvince> quicksilver: merci.
06:09:27 <ski> @babel en la in place
06:09:27 <lambdabot> Plugin `babel' failed with: Error: Language la not supported
06:10:46 <sioraiocht> @src foldr
06:10:46 <lambdabot> foldr f z []     = z
06:10:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:14:06 <fasta> If you get a child in the xml library, why don't you get a zipped version of the tree? Now, if you suddenly decide that you need access to the parents from within the child, you basically need to rewrite it to use "cursors". There are conversion functions, but if you take the child, you just get a sub-tree, not the zipped version.
06:26:01 <quicksilver> fasta: which xml library? I agree, a version based on zippers would be nice for some things.
06:26:11 <fasta> quicksilver: The library is named xml.
06:26:36 <fasta> quicksilver: it is based on zippers, only the actual XML interface "proc" throws away the path.
06:26:57 <quicksilver> oh, weird.
06:27:03 <fasta> quicksilver: I was basically assuming it didn't do that.
06:27:30 <quicksilver> I have only used haxml and tagsoup
06:27:36 <fasta> quicksilver: so, now all my uses of xml can be replaced by some cursorToXML function except in the one place where I actually need the cursor.
06:27:58 <fasta> quicksilver: I also used haxml, but this API seemed cleaner.
06:28:12 <quicksilver> getChild :: Int -> Cursor -> Maybe Cursor
06:28:20 <quicksilver> doesn't that get you the zipped version?
06:28:42 <fasta> quicksilver: it does; that's what I was talking about.
06:28:57 <fasta> quicksilver: but the findChildren functions don't do that.
06:29:23 <fasta> quicksilver: what makes it weird is that one can convert an Element into a cursor.
06:31:31 <quicksilver> findChild also returns a Cursor?
06:31:38 <quicksilver> well, a Maybe Cursor
06:32:41 <quicksilver> the Text.XML.Light.Cursor version
06:32:44 <quicksilver> not the .Proc version
06:33:16 <fasta> quicksilver: findChildren :: QName -> Element -> [Element]
06:33:55 <fasta> quicksilver: but yes, I will use the Proc versions now for everything, but it would have been nice if the documentation would have said that they throw away the path.
06:36:09 <quicksilver> Yeah, documentation is always nice.
06:36:24 <quicksilver> I assume they chose to throw away the path to avoid a certain class of space leak
06:36:34 <quicksilver> where you load a big-ish tree and only keep some children.
06:40:27 <wh1t3_> Im trying to install cabal. It gives me the following error:
06:40:31 <wh1t3_> /usr/lib64/gcc/x86_64-suse-linux/4.3/../../../../x86_64-suse-linux/bin/ld: cannot find -lgmp
06:40:43 <wh1t3_> any idea why it would fail on that?
06:40:49 <wh1t3_> gmp is properly installed
06:41:19 <pejo> wh13, is it in a non-standard location?
06:41:33 <wh1t3_> gmp?
06:41:38 <pejo> Yes
06:41:42 <wh1t3_> It was alredy installed
06:41:46 <wh1t3_> this is a fresh system
06:41:50 <fasta> I would not be surprised if suse did some non-standard stuff.
06:42:49 <wh1t3_> ill remove it and have zypper reinstall, see if that makes any difference
06:44:31 <wh1t3_> hmmm, reinstalling has not solved it
06:44:37 <wh1t3_> think it might be a gcc error
06:47:37 <wh1t3_> hmmm, still the same error
06:47:48 <wh1t3_> it seems to me like everything is installed properly :/
06:49:00 <blackh> wh1t3_: Do you have the development package for gmp?
06:49:06 <wh1t3_> let me check
06:49:15 <pejo> wh13, for some reason your ld is not finding gmp in the locations it is searching. You might be able to fix that by passing some -L/wherever/libgmp/lib or simliar to it, but not sure how to do that.
06:49:25 <pejo> Ah, blackh has a good question.
06:49:36 <wh1t3_> thank you :)
06:49:54 <wh1t3_> that solved it blackh
06:50:13 <wh1t3_> pejo: yeh, i thought about changing the LDFlags, but wasnt sure on how to do that either :)
06:54:56 <jmcarthur> :t fix $ (<*>) (*>)
06:54:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b
06:55:08 * jmcarthur ponders whether something like that is useful
06:55:15 <jmcarthur> ever
06:56:33 <jmcarthur> it clearly can't ever return a value, so i'm guessing not, unless i'm forgetting some little detail about bottom or laziness
06:57:22 <Saizan> > (fix $ (<*>) (*>)) Nothing
06:57:24 <lambdabot>   Nothing
06:57:32 <jmcarthur> bah!
06:57:49 <Saizan> ?type (<*>) (*>)
06:57:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (f a -> f b) -> f a -> f b
06:58:29 <jmcarthur> of course! any applicative functor with an "empty" constructor might have a chance, depending on its semantics
06:58:55 <jmcarthur> is there a formal way of saying it "has an empty constructor" like that?
06:59:03 <jmcarthur> like Nothing or []
06:59:33 <quicksilver> they're zeroes of >>
06:59:45 <quicksilver> (equivalently *>)
07:00:05 <jmcarthur> well, [] isn't a zero of >>, but i guess that fits with this case anyway
07:00:08 <Berengal> empty of Alternative
07:00:32 <quicksilver> > [] >> [1,2,3]
07:00:33 <lambdabot>   []
07:00:34 <Berengal> > [] >> [1..10]
07:00:36 <lambdabot>   []
07:00:36 <quicksilver> jmcarthur: is it not?
07:00:44 <Berengal> > [1..10] >> []
07:00:45 <lambdabot>   []
07:00:49 <Berengal> Looks zero to me
07:00:57 <jmcarthur> did i mention i'm running on 3 hours of sleep? :\
07:01:01 <dcoutts> wh1t3: you must be missing the gmp package
07:01:02 <quicksilver> ;)
07:01:12 <quicksilver> dcoutts: he was missing the -dev package
07:01:20 <quicksilver> dcoutts: blackh sorted it :)
07:01:21 <dcoutts> right, I'm late :-)
07:01:46 <quicksilver> yes, the empty of Alternative is a unit for <|> but a zero for *>
07:01:49 <jmcarthur> > (fix $ (<*>) (*>)) []
07:01:50 <lambdabot>   []
07:02:04 <quicksilver> > [] <|> [1,2,3]
07:02:05 <lambdabot>   [1,2,3]
07:02:14 <jmcarthur> okay, so that makes sense
07:02:14 <Saizan> jmcarthur: that's another way to write forever, btw
07:02:38 <Saizan> "fix $ (<*>) (*>)" i mean
07:03:03 <quicksilver> it doesn't seem to be documented that empty should be a zero, though.
07:03:11 <Berengal> Saizan: Yes, that looked very much like forever for applicatives
07:03:35 <cnwdup> @src fix
07:03:35 <lambdabot> fix f = let x = f x in x
07:04:01 <Saizan> inling (<*>) you get fix (\forever x -> x *> forever x)
07:04:07 <jmcarthur> do the laws mandate this property?
07:04:16 <jmcarthur> that empty is a zero of *>?
07:06:07 <jmcarthur> it doesn't seem to me that that would be necessarily so, but i haven't tried proving it yet
07:08:11 <Saizan> from Control.Applicative's documentation you only know that (f a,<|>,empty) is a monoid, but the paper might have more
07:10:06 <quicksilver> I can't see alternative in the paper at all.
07:10:59 <u_quark> is there a way to make an instance of a class deriving the necessary functions like with "deriving ..." using "instance ..." ?
07:11:56 <quicksilver> u_quark: GHC has an extension called 'standalone deriving' for that
07:12:11 <jmcarthur> is Alternative supposed to be exactly like MonadPlus, besides also working for things that are not monads?
07:12:24 <jmcarthur> if that's the case, then clearly empty must be a zero
07:12:47 <u_quark> tnx quicksilver
07:13:02 <jmcarthur> at least, it must be if it's also a Monad
07:13:06 <quicksilver> you'd imagine so, wouldn't you, jmcarthur ;)
07:13:14 <quicksilver> the intentions are not made terribly clear, though.
07:13:32 <Berengal> I don't think there's anything that says it _has_ to be true
07:14:07 <jmcarthur> Berengal, well, _if_ it's supposed to be like MonadPlus, then it must be, since MonadPlus has that law
07:14:59 <Berengal> jmcarthur: Yes, but I can't remember them being equal being stated anywhere
07:15:03 <jmcarthur> oh, i love this in the documentation, under the MonadPlus laws: "but the instance for System.IO.IO defined in Control.Monad.Error in the mtl package does not satisfy the second one"
07:15:11 <jmcarthur> Berengal, right
07:15:21 <quicksilver> yes, it was later realised there are two different kinds of monadplus
07:15:30 <jmcarthur> yeah, monadplus should be split
07:16:29 <quicksilver> http://www.haskell.org/haskellwiki/MonadPlus
07:16:44 <quicksilver> in particular : [] satisfies Monoid, Left Zero, and Left Distribution.
07:16:44 <quicksilver> Maybe, IO and STM satisfy Monoid, Left Zero, and Left Catch.
07:17:06 <Saizan> for IO mzero is only a zero on the left of >> however
07:17:32 <quicksilver> well it's a kind of zero on the right
07:17:39 <quicksilver> up to equivalence of distinct zeroes :)
07:17:57 <quicksilver> oh, but the effects happen
07:18:02 <quicksilver> yes, I see your point :)
07:19:44 <Saizan> if we like to think of IO as "scripts" or "TODO lists" then v >> mzero is not the same script as mzero
07:20:06 <Saizan> but maybe that's not a sensible pov :)
07:20:16 <quicksilver> no, you are right.
07:20:21 <quicksilver> it's not equal.
07:21:47 <Berengal> Well, the only way to distinguish mzeros from other values in the IO monad is to run them, which means you can't have right zero, that should be obvious
07:27:44 <fracture> is there an integer division function in haskell?
07:27:47 <fracture> (/) seems to do fractionals
07:27:59 <Berengal> fracture: div
07:28:09 <fracture> thanks
07:30:09 <fracture> is there a better way than using filter and length to count the number of elements in a list satisfying a predicate?
07:30:18 <fracture> (noob questions, sorry ;) )
07:30:35 <Berengal> You could use a fold, but it wouldn't be much clearer
07:30:57 <fracture> thing with length seems like it would use more memory than necessary
07:30:57 <quicksilver> I think filter + lenth is a good way.
07:31:19 <fracture> ah maybe fold is what I want actually
07:31:23 <Berengal> > (\p ->foldl' (\a e -> if p e then a+1 else a) 0) even [1..20]
07:31:25 <lambdabot>   10
07:31:37 <Saizan> it should do it in constant memory anyway
07:31:39 <gnuvince> fracture: filter + length is good.  You could also be clever and do something like: (reduce + (for [e coll :when (pred? e)] 1))
07:31:49 <gnuvince> Oh wait, this is #haskell
07:31:52 <gnuvince> Sorry
07:31:57 <fracture> hah
07:32:04 <ski> @type \f -> fix (\g -> (g =<<) . f)  -- jmcarthur, also see this
07:32:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> m a) -> a -> m b
07:32:06 <gnuvince> sum [1 | e <- coll, pred e]]
07:32:29 <gnuvince> > sum [1 | n <- [1..10], odd n]
07:32:30 <fracture> kinda suprising to me there's no count function in Data.List actually
07:32:31 <lambdabot>   5
07:33:01 <Saizan> because it's so easy to do with filter and length that no-one bothered :)
07:33:01 <Berengal> count is simply (length.).filter anyway...
07:33:31 <Saizan> lazyness means that you don't have to worry about allocating a whole new list
07:33:31 <fracture> maybe I'm assuming more memory is used than will be?
07:33:38 <fracture> ah I see
07:33:45 <Berengal> It'll be done in constant space
07:34:03 <Saizan> and if list-fusion applies it won't allocate anything at all
07:34:16 <Berengal> I was just about to say that, but I'm not too sure if it does
07:34:17 <fracture> what's list-fusion?  a memory optimization case?
07:34:28 <quicksilver> you can't fuse a filter
07:34:34 <quicksilver> or can you
07:34:35 <quicksilver> hmm
07:34:43 <Berengal> quicksilver: I was slowly coming to that conclusion...
07:35:04 <quicksilver> the original fusion architecture was designed to make list comprehensions fast
07:35:08 <quicksilver> and filter is part of list comps
07:35:09 <dolio> filter fuses.
07:35:12 <dolio> length doesn't.
07:35:12 <quicksilver> so maybe it can.
07:35:38 <Saizan> since length is a foldl?
07:35:46 <dolio> Right.
07:35:55 <Berengal> foldr f acc . filter p = foldr (if' <$> p <*> f <*> const) acc
07:35:56 <dolio> It fuses under stream fusion, though.
07:36:05 <Berengal> where if' p t f = if p then t else f
07:36:19 <Berengal> Oh, and that should've been flip const for foldr
07:36:30 <Berengal> so let's say foldl' :)
07:37:04 <Berengal> Actually, I don't know what I'm saying at all
07:39:08 <ihatemyboss> how is the job market for haskell?
07:42:31 <jmcarthur> ihatemyboss, http://haskell.org/haskellwiki/Haskell_in_industry
07:42:59 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4902#a4902 <- a single loop with unboxed ints
07:44:42 <Berengal> Saizan: Fused by hand?
07:44:45 <blackh> ihatemyboss: My impression is that the market is not brilliant, but it is possible to get Haskell work.  You still have to make your own luck at this stage, but my money is on it changing slowly over the next few years.
07:45:09 <blackh> I use that term figuratively. I don't have any actual "money" as such. :)
07:46:19 <Botje> .. as that would require a haskell job, which is a thunk yet to be forced ;(
07:46:21 <ihatemyboss> lol
07:46:30 <ihatemyboss> oh
07:46:33 <ihatemyboss> ok
07:47:14 <ski> @type \f -> fix (\g -> (g . f =<<))  -- jmcarthur, actually this was what i was thinking of
07:47:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> m a -> m b
07:47:20 <fracture> so, I have a gigantic list of triples, and tried to get a particular element using:
07:47:26 <fracture> let max = maximumBy (\x y -> compare (third x) (third y)) myListOftriples
07:47:32 <fracture> and it gets a stack overflow
07:47:49 <fracture> but if I just type "myListOfTriples" into the interpreter, it goes on printing them without seeming to overflow
07:47:50 <Berengal> If Haskell truly is awesome then there should be plenty of opportunities in the software business for a startup
07:47:59 <fracture> is the problem maximumBy?  or my definition of the list?
07:48:02 <Berengal> fracture: maximumBy uses lazy foldl
07:48:09 <EvilTerran> fracture, it's maximumBy, sadly
07:48:11 <fracture> oh
07:48:14 <fracture> what can I use instead?
07:48:15 <Berengal> Try foldl1' max
07:48:18 <fracture> ok
07:48:20 <Berengal> needs Data.List
07:48:23 <fracture> ok
07:48:50 <blackh> Berengal: That's where it's going to happen in the short term. Bit by bit people are going to realize there is money to be made. I am trying to do this very thing myself.  Maybe I can hire everyone here when I become a Haskell tycoon.
07:49:21 <EvilTerran> or, say, foldl1' (\x@(_,_,x3) y@(_,_,y3) -> if x3 > y3 then x else y)
07:49:25 <blackh> Berengal: There's no "if" about it. Haskell is awesome (from a commercial point of view).
07:49:50 <Berengal> blackh: I'd agree, but there's no scientific proof of it since we lack sufficient empirical data
07:49:51 * jmcarthur intends to try a startup some time, and haskell will certainly be the primary language
07:49:59 <blackh> The companies that realize that now are the ones that will make money.
07:50:02 <Berengal> (Which is a good thing for any new haskell startup)
07:50:17 <fasta> Haskell only has mediocre tools. The language itself is quite good.
07:50:36 <ErhardtMundt> Twey: hello there again :D
07:50:40 <Berengal> Haskell doesn't need as good tools as the other languages
07:50:41 <blackh> That's the price you pay for early adoption, and it's true of any leading edge technology.
07:50:50 <osfameron> perhaps there is more money to be made programming in existing languages but using concepts stolen from haskell ? ;-P
07:50:59 <Berengal> Of course, I'm not saying we couldn't use better ones
07:51:22 <fasta> And libraries are of course also important.
07:51:27 <ErhardtMundt> osfameron: yo :)
07:51:29 <Berengal> osfameron: Have you tried functional programming in Java? It's painful. Excruciatingly painful
07:51:36 <blackh> osfameron: Possibly, but you don't get the full advantage of Haskell unless you actually use it.  That's the only way to get a real edge.
07:51:58 <fasta> Although, there are more than 1000 libraries, there are not a lot of libraries that do something non-trivial and are documented.
07:52:17 <fasta> That said, if you are building something new, libraries are worthless mostly.
07:52:18 <osfameron> ciao ErhardtMundt ;-)
07:52:37 <Berengal> If anyone's got a good idea for a startup and would like to hire me, I'd join in an instant
07:52:59 <osfameron> Berengal, blackh: true... I'm playing with it in Perl, and it's still vastly less convenient than Haskell.  But... has great libraries, and (not to be sneezed at) I *know* it, and know people who also do.
07:53:08 <osfameron> but yeah, I'd love to work for a haskell startup too ;-)
07:53:36 <fracture> eh... from a commerical perspective...  it kinda makes sense to use languages that everyone knows (no matter how shitty they are)
07:53:42 <fracture> makes your labor cost lower
07:53:43 <blackh> osfameron: That's quite right - there's an up-front cost with Haskell.
07:53:54 <ErhardtMundt> osfameron: words have reached my ears that Twey is a lojbanist
07:53:55 <hatds> probably depends on how big your staff needs to be
07:53:57 <Berengal> fracture: I very much disagree
07:54:07 <osfameron> actually, I think Perl+Haskell for a company would be a fantastic combination
07:54:08 <Berengal> when it comes to programming quality is everything, quantity is nothing
07:54:11 <blackh> fracture: I disagree.  That's only true if you ignore the hidden cost of poor software quality.
07:54:18 <fracture> depends what you are producing
07:54:31 <conal> fracture: following the herd has short-term benefit and long-term cost.
07:54:34 <osfameron> blackh: that's assuming all code in $other_language will be of poor quality
07:54:42 <fracture> I've worked in industries where quality is basically meaningless past does-it-crash-and-basically-work
07:54:48 <fracture> (and yes, it sucks to work on that kind of software.)
07:54:51 <osfameron> there may be critical parts of your work that need to be "proven correct"
07:55:12 <osfameron> but things like web frameworks where the "someone else already wrote it, it's convenient, does everything I want, and Just Works" may trump that
07:55:36 <fracture> conal: correct, but in some industries, once the product is done, you never maintain it
07:55:43 <fracture> so short term cost is everything
07:56:00 <jmcarthur> i would rather have a very hard time finding good developers than have a very easy time finding crappy developers. i know haskell developers tend to be much more competent than java developers. plus haskell is just a joy to use. that pretty much makes my decision
07:56:03 <conal> fracture: agreed.
07:56:11 <Berengal> Using a common-denominator language only works if your coders are in-house developers on in-house apps, because there are no competing apps
07:56:34 <blackh> osfameron: Yes, I think you're right.
07:56:47 <Wraithan> Any xmobar users know if there is a plugin for pidgin? Or will I be stuck writing that as well?
07:57:10 <jmcarthur> Wraithan, xmobar is very minimal. probably have to write your own. check #xmonad though
07:57:16 <Berengal> jmcarthur: Also, haskellers are most likely hobbyist haskellers, which means hobbyist programmers. Anyone who has their work as a hobby is bound to be above average
07:57:25 <jmcarthur> Berengal, definitely
07:57:33 <fracture> above average ability, for sure
07:57:39 <hatds> is there a name for the design pattern where you say "data Foo a = Foo a (a->Int-Int)"  or somesuch (bundling the function instead of using a typeclass)
07:57:41 <fracture> however sometimes hobbyist guys don't want to work on things that aren't interesting ;)
07:57:42 <Wraithan> I know the install is very minimal, was hoping there was a released plugin heh, will chek with #xmonad
07:57:44 <fracture> (I have this problem)
07:57:45 <Saizan> Berengal: no, fused by stream fusion
07:57:45 <ihatemyboss> then how come there arent any haskell companies?
07:58:01 <hatds> Galois?
07:58:12 <jmcarthur> i think i could trick myself into thinking almost any project is interesting if i'm writing in haskell
07:58:17 <Twey> ErhardtMundt: o/
07:58:18 <Workybob> there aren't any Haskell companies?
07:58:20 <conal> hatds: you could call it "explicit dictionary"
07:58:23 <Workybob> how am I getting paid ihatemyboss?
07:58:26 <Berengal> Saizan: That's what I though. Didn't look very hand-written
07:58:29 <Twey> You needed something?
07:58:38 <blackh> ihatemyboss: Because Haskell is at the early end of the "early adopters" curve
07:58:40 <ErhardtMundt> Twey: you're a lojbanist
07:58:45 <ErhardtMundt> Twey: am i wrong? :)
07:58:48 <Twey> Well, most projects *are* interesting if you're writing in Haskell
07:59:02 <fasta> ihatemyboss: I am also not getting paid ;)
07:59:05 <jmcarthur> and interestingly high number of lojbanists here ;)
07:59:09 <Wraithan> Twey: I am finding that as well
07:59:13 <fracture> <-- ex-lojbanist
07:59:18 <quicksilver> hatds: I would call it using higher order functions.
07:59:19 <camio> Workybob: You're getting paid?! :)
07:59:19 * blackh estas Esperantisto
07:59:21 <mmorrow> grrrrrrr. this TH prog was compiling for 15+ minutes, then stack overflowed
07:59:24 <Twey> There's not much work done so far on Haskell — it's all new and exciting stuff, figuring out solutions to real-world problems that have long been solved in other programming styles
07:59:26 <Workybob> camio: yeh, fair point
07:59:27 <Workybob> >.<
07:59:28 <Saizan> Berengal: that's the GHC.Core language too, i'd rather not touch that with a long stick :)
07:59:29 <Twey> ErhardtMundt: You are not wrong :)
07:59:37 <ErhardtMundt> blackh: saluton geamiko! ;)
07:59:38 * jmcarthur is an ex-lojbanist-wannabe
07:59:48 <osfameron> if everyone starts speaking lojban I'm going to cry
07:59:53 <Raevel> coi
07:59:54 <ErhardtMundt> Twey: haha, i saw you on youtube
07:59:56 <Twey> .i ki'u ma
08:00:06 <quicksilver> if everyone starts speaking lojban I'm going to kick them all one by one
08:00:09 <Twey> ErhardtMundt: Oh right, heh
08:00:12 <quicksilver> until it's just me an osfameron crying.
08:00:15 <Twey> quicksilver: *grin*
08:00:15 <fracture> no muedo recordar lojban ... solo espanol ahora
08:00:21 <fracture> .u'i
08:00:21 <Berengal> Saizan: Yeah, it was barely recognizeable, but I think I get it this time, short as it is.
08:00:26 <mmorrow> jmcarthur: ah yeah, i killed gcc for that switch trie on dict/words after about 30 minutes
08:00:27 <fracture> err puedo
08:00:28 <Wraithan> I don't speak lojban and never cared to learn it
08:00:38 <mmorrow> jmcarthur: a little too ambitious methinks :)
08:00:44 <jmcarthur> aw
08:00:49 <mmorrow> yeah, i was sad
08:00:50 <Twey> .u'i la cnisan
08:01:01 <jmcarthur> i would have left it running overnight, just to see what happens
08:01:01 <ErhardtMundt> i've never successed
08:01:02 <Workybob> I skipped learning lojban when it took me about 20 minutes to find out that it was about communicating efficiently from their webpage
08:01:07 <mmorrow> but it needed those 3.6 GB of ram back ;)
08:01:08 <Japsu> Qapla'
08:01:22 <mmorrow> jmcarthur: yeah, i should do that for sure
08:01:32 <Twey> It's really fairly easy, but the resources are a bit technical at the moment
08:01:34 <fracture> ghci seems to start to suck after you've made it do a lot of large computations
08:01:42 <jmcarthur> mmorrow, if you don't plan to do it, then i would like whatever you used to generate the .c file so i can try it myself
08:01:44 <fracture> like ... it doesn't respond to keyboard input well
08:01:48 <Twey> fracture: *nods*
08:01:53 <Asztal> Is the ST nomad good enough (complexity-wise) to make an interpreter for an imperative programming language? That is, is writeSTRef is O(1)?
08:01:56 <blackh> ErhardtMundt: Saluton! Sed mi preskau tute forgesis kiel paroli la lingvon!
08:01:58 <mmorrow> jmcarthur: sure. lemme stick it somewhere
08:02:07 <Twey> Workybob: It's not about efficient communication :-P
08:02:21 <ErhardtMundt> blackh: ho, ve!
08:02:31 <jmcarthur> Asztal, first of all, it's O(1). second of all, you probably don't even need an imperative monad to write an imperative interpreter, necessarily
08:02:34 <Workybob> Twey: oh, well then the web site is both shit at getting its point across and wrong :D
08:02:38 <Twey> First sentence on the page: « Lojban is a carefully constructed spoken language designed in the hope of removing a large portion of the ambiguity from human communication. »
08:02:39 <centrinia> It is about unambiguous communication. :p
08:02:43 <mmorrow> jmcarthur: (gcc compiles it for 10s of thousand of words in pretty short time)
08:02:50 <Twey> I think that pretty much covers it :-P
08:02:54 <Workybob> Twey: oh hey, they fixed it
08:03:03 <Workybob> unfortunately though, it's autorecognising that I'm in .be
08:03:05 <Twey> That site hasn't been properly updated in years
08:03:07 <mmorrow> jmcarthur: so it's more than enough to do anything reasonable
08:03:09 <centrinia> How would a spoken language use higher order functions?
08:03:09 <Workybob> and not letting me have an english description
08:03:11 <Workybob> so >.<
08:03:13 <Workybob> again... fail
08:03:15 <Twey> Heh
08:03:23 <Twey> Workybob: Language drop-down in the sidebar to the left
08:03:30 <quicksilver> mmorrow: did you ever work out why mdmkoble's Data.Dynamic think had a quadratic slowdown?
08:03:31 <Twey> Oh
08:03:32 <Twey> It's empty
08:03:35 <Twey> Yeah, that's fail
08:03:39 <blackh> ErhardtMundt: Mi nun lernas Hebreon kaj mi volas diri "im" anstatau "se", ktp, ktp. Tre konfuzinda. ^Gi venas ... hmm
08:03:40 <Workybob> Twey: the one where the first option is √ and the others are , , , and ?
08:03:46 <Workybob> :D
08:03:47 <Twey> Workybob: Oh you got options?
08:03:49 <Twey> I didn't get options
08:03:52 <Workybob> I got 5 options
08:03:54 <Workybob> all blank
08:03:55 <Workybob> one ticked
08:03:56 <Twey> You lucky chappie :(
08:04:15 <Twey> Yeah, the site sucks, I'm not going to deny that
08:04:29 <Twey> There've been a bunch of attempts to create a new one, but there seems to be some inertia
08:04:49 <fracture> problem with lojban is the language doesn't seem to fit up with known regularities in human universal grammar
08:05:00 <blackh> Twey: The big problem is a little thing called "English"
08:05:02 <fracture> so... it might not be possible for a neonatal human to learn the language
08:05:06 <ErhardtMundt> blackh: hehe… :)
08:05:12 <fracture> but it is (was) fun to play with
08:05:25 <Twey> fracture: Well, I don't think you can really decide that before it's been tried
08:05:44 <fracture> of course; it's a testable hypothesis
08:06:05 <fracture> but there's nothing remotely like elidable terminators in any human language
08:06:16 <jmcarthur> Asztal, you can also use an IntMap to simulate pointers to values with O(log n) dereferencing, which you can really consider a constant if you consider that the deepest the tree can ever go is 32 or 64 levels on most architectures today
08:06:26 <Twey> fracture: You sure of that?
08:06:28 <blackh> fracture: Could you translate "elidable terminators" into a human language for me?
08:06:35 <fracture> haha
08:06:38 <Twey> I would count parenthetical commas as pretty similar
08:06:54 <fracture> blackh:  in lojban, you have these grammar-only words that can be left out as long as it keeps the sentence parsing unambiguously
08:06:56 <Twey> And that's just in English
08:07:02 <fracture> they are like } or END or other things in programming languages
08:07:08 <Twey> Japanese has its particles
08:07:08 <fracture> but sometimes you have to put them in to keep a particular parse
08:07:19 <fracture> that's entirely different
08:07:30 <Twey> Which don't serve *exactly* the same purpose, but they're close enough that I'd consider them parallel
08:08:11 <hatds> what's the ghci command to see all instances defined by a module?
08:08:17 <hatds> or the current module, say
08:08:21 * EvilTerran would consider conjunctions which can often be elided in english to serve a similar purpose
08:08:21 <idnar> what the heck is human universal grammar?
08:08:32 <quicksilver> hatds: of a particular class?
08:08:35 <quicksilver> hatds: :i <classname>
08:08:41 <Twey> idnar: A highly controversial concept in linguistics
08:08:44 <fracture> oh man... haskell hijacked into lojban
08:08:57 <fracture> not that controversial (in my understanding)
08:09:00 <quicksilver> lojban, linguistics chatter --> to #haskell-blah please
08:09:04 <fracture> it's more like the established paradigm
08:09:10 <fracture> quicksilver: good call
08:09:12 <hatds> quicksilver: is there a command which works for all classes in some scope?
08:09:12 <Twey> fracture: It's really not
08:09:19 <quicksilver> hatds: no.
08:09:28 <quicksilver> hatds: I've never wanted that :) Why do you want that?
08:09:37 <Asztal> jmcarthur: I thought about that, but it just seems to me like a less efficient version of STRef
08:09:43 <idnar> Twey: I know pretty much nothing about linguistics, but the term sounds bogus even completely out of context :P
08:09:46 <Twey> http://en.wikipedia.org/wiki/Universal_grammar#Criticism
08:09:54 <Twey> idnar: *nods* It's pretty wacky
08:10:08 <fracture> twey:  -> #haskell-blah
08:10:08 <hatds> quicksilver: why not?
08:10:32 <quicksilver> hatds: hard to explain why I've never wanted something. I've only ever been interested in one class at once?
08:10:35 <Asztal> jmcarthur: I suppose you're not in a monad then, but eventually you'd want to stick that IntMap in a State monad and you'd not have gained much
08:10:45 <quicksilver> hatds: you could try :browse, which shows you everything.
08:10:59 <Twey> fracture: #lojban might be more appropriate
08:10:59 <quicksilver> Asztal, jmcarthur : ability to store old versions, for undo facilities, with good sharing.
08:11:04 <hatds> quicksilver: wouldn't have to type out the class names for one
08:11:08 <quicksilver> (is one reason to prefer the IntMap version)
08:11:10 <Twey> Or #(#)linguistics
08:11:25 <hatds> quicksilver: browse doesn't show instances
08:11:35 <quicksilver> hatds: interesting. I always assumed it did.
08:11:42 <quicksilver> Then, no, I don't think what you want is possible.
08:18:17 <mmorrow> jmcarthur: http://moonpatio.com/repos/switchtrie/
08:18:33 <mmorrow> quicksilver: so, it's a mystery to me
08:23:38 <Axman6> so, i've just finished the Google App Engine python tutorial, and i must say, both GAE and python are quite cool
08:23:46 <Axman6> GAE is very cool in fact
08:24:03 <mmorrow> quicksilver: err, meant to say "no, it's a ..."
08:29:36 <jmcarthur> mmorrow, thanks
08:30:15 <fasta> Axman6: Google App Engine (GAE) lets you run your web applications on Google's infrastructure for free.  How much CPU time do you get for free?
08:30:52 <jmcarthur> Asztal, yeah, as quicksilver says, using pure code provides really cheap undo/persistence, and also makes thread safety easier
08:31:08 <Axman6> fasta: 46 CPU hours / 24 hours
08:31:31 <fasta> Axman6: and it is protected by a Captcha?
08:31:54 <Axman6> 10Gbytes of outgoing and incoming bandwidth, 1GB of stored data and 2000 'recipient emails'
08:32:17 <Axman6> fasta: not sure what you mean. users log in using their google accounts
08:32:28 <fasta> Axman6: yes, that's what I meant.
08:32:30 <mmorrow> jmcarthur: np
08:32:31 <Asztal> jmcarthur: hmm. Thanks jmcarthur, quicksilver.
08:32:45 <Axman6> but you can also setup users for the site
08:32:56 <fasta> Axman6: so, if you can crack a captcha in less than 46 CPU hours, you can take over the entire farm ;)
08:33:12 <Axman6> eh?
08:33:45 <fasta> Oh, you can even take longer about it, btw.
08:33:55 <fasta> They must have some other precaution somewhere.
08:34:01 <Axman6> there's not much you could do to the system, since you can only use python or java at the moment, and they both have restrictions (like you can't write to disk i think)
08:34:22 <fasta> Axman6: but can you use sockets?
08:34:28 <Axman6> nope
08:34:43 <Axman6> you can't do any system calls
08:34:54 <Axman6> or, very few at least
08:35:05 <jmcarthur> Asztal, that said, ST is not only O(1), but it's also a pretty small constant
08:35:59 <Asztal> jmcarthur: Yeah, I just looked, it seems like GHC "understands" mutable variables, which is cool
08:37:03 <vegai> Asztal: understands like one might understand murderers? :P
08:37:28 <jmcarthur> Asztal, one potential problem with ST, though, is that it doesn't have a transformer, so you can't just throw it on top of IO. if your imperative language needs to do IO and you are using ST, you may have trouble doing everything you want. it might be better to just use IORef, in that case
08:37:41 <jmcarthur> Asztal, they are implemented the same way
08:37:44 <Asztal> It's looking that way, yes
08:38:05 <jmcarthur> or rather, they share the same implementation
08:38:20 <Berengal> unsafeIOtoST
08:38:30 <jmcarthur> Berengal, ew :P
08:38:36 <idnar> unsafeMagicWand
08:38:38 <Berengal> safer than unsafePerformIO anyway :P
08:39:09 <jmcarthur> but it still defeats the purpose of the ST monad
08:39:22 <Berengal> Yeah, it does
08:39:56 <quicksilver> STtoIO is not unsafe though
08:40:05 <Berengal> unsafeSTToIO is :P
08:40:25 <quicksilver> sure, but there's a safe way to do it.
08:40:33 <quicksilver> You can safely run polymorphic ST code in IO
08:40:57 <SamB> can safely run it anyway ;-)
08:41:04 <jmcarthur> as long as you don't obtain an STRef from it
08:41:27 <Berengal> It seems to me that IO is the most unsafe place to be anyway, so anythingToIO should be safe for everything...
08:41:29 <jmcarthur> it doesn't hurt the IO, but it does hurt the ST guarantees
08:41:47 <SamB> how about IntToIO
08:42:07 <MyCatVerbs> SamB: print
08:42:08 <Berengal> SamB: Sure, intToIO :: Int -> IO Int
08:42:13 <Twey> return
08:42:30 * SamB was thinking more along the lines of unsafeCoerce
08:42:49 <jmcarthur> maybeToIO :: Maybe a -> IO a
08:43:04 <hatds> eh, sometimes you just feel like saying data Foo = Foo <bunch of IORef Ints> and be done with it
08:43:09 <Berengal> Lists might be more troublesome... [a] -> IO a ?
08:43:19 <jmcarthur> yup
08:43:43 <Berengal> Still, I could define that pretty easily
08:43:46 <Berengal> head, frex
08:43:54 <Berengal> Well, return . head
08:44:21 <jmcarthur> regardless, STToIO breaks ST's type safety, so is unsafe
08:44:38 <Berengal> No, unsafeSTToIO does that
08:44:52 <Berengal> @type stToIO
08:44:53 <lambdabot> Not in scope: `stToIO'
08:44:59 <jmcarthur> wait, there are two variants of STToIO?
08:45:06 <Berengal> stToIO :: ST RealWorld a -> IO a
08:45:10 <Berengal> unsafeSTToIO :: ST s a -> IO a
08:45:12 <jmcarthur> oh
08:45:23 <jmcarthur> okay, that one is safe
08:45:39 <Twey> jmcarthur: That's safe (maybeToIO)
08:46:00 <jmcarthur> Twey, it's only as type safe as head
08:46:14 <Twey> maybeToIO (Nothing) = throw SomeException $ "ARGH!"; maybeToIO (Just a) = return a
08:46:19 <Twey> No, it's slightly safer
08:46:28 <Twey> Because you can use IO exceptions, which can be standardly caught
08:46:35 <jmcarthur> oh, exceptions, ew :P
08:46:44 <Berengal> Eh, head can be caught
08:46:48 <Twey> Well what else were you going to return?  :-P
08:46:50 <Berengal> head [] that is...
08:46:59 <Twey> Berengal: Yes, but not in H98, I think
08:47:02 <jmcarthur> Twey, i just wouldn't have defined that function ;)
08:47:13 <Twey> Control.Exception.catch can catch just about anything
08:47:20 <jmcarthur> my opinion is that partial functions should carry information about their partiality in their identifiers, just like unsafe functions are prefixed with "unsafe"
08:47:26 <Twey> But Prelude.catch, the H98-compliant version, is more limited
08:47:33 <Berengal> Twey: s/just about//
08:47:45 <Twey> Berengal: It can't catch segfaults
08:47:49 <Twey> :)
08:47:57 <jmcarthur> haskell doesn't have segfaults
08:47:59 <jmcarthur> ghc does
08:48:07 <Berengal> Twey: What he said :P
08:48:11 <Twey> jmcarthur: You've evidently never played with Foreign.Ptr
08:48:28 <jmcarthur> unsafe
08:48:31 <jmcarthur> :P
08:48:35 <Twey> Hehe
08:48:53 <Berengal> jmcarthur: Well, actually _more_ unsafe than just IO, since you can't segfault in haskell
08:49:08 <Berengal> to segfault you need to go outside, assuming a bug-free haskell implementation
08:49:12 <jmcarthur> Berengal, eh, i can use IO to kill the current process ;)
08:49:16 <quicksilver> jmcarthur: I used to think that (partial functions)
08:49:32 <Berengal> jmcarthur: Yeah, okay, but you can also install handlers...
08:49:36 <quicksilver> jmcarthur: but I have decided that in the absence of dependent types, partial functions are just too ubiquitous and too useful.
08:50:18 <jmcarthur> quicksilver, i think the partiality annotation should be very small and unobtrusive, like a _ or something
08:50:31 <Berengal> jmcarthur: It'd nag you forever though
08:50:33 <jmcarthur> rather than blaring, like "unsafe"
08:50:38 <hatds> hmmm any naming suggestions for partial functions?  I like sound of names like head* (like an asterisk/footnote) if only you could use such names
08:50:47 <jmcarthur> Berengal, it's supposed to. it says "you better know what you're doing"
08:51:38 <Berengal> jmcarthur: Eh, I don't think I've had the need to know partiality that bad ever
08:52:14 <jmcarthur> Berengal, at least in libraries that are new to you, having it marked in the identifier combined with type information would make it much more obvious what's going on
08:52:59 <Berengal> I know some functions are partial, and I always make a conscious decision how to treat them. I assume partial functions document their partiality in the documentation
08:53:19 <Berengal> Because just knowing a function is partial is pretty much useless
08:53:24 <jmcarthur> documentation doesn't travel with the identifier, though
08:53:38 <jmcarthur> if i am editing code i didn't write, i might just assume
08:53:42 <hatds> but sometimes it's useful.. like foldl' and foldl
08:53:45 <jmcarthur> that the types will save me
08:53:50 <Berengal> Okay, say I wrote a function head_partial :: [a] -> a, what information would you glean from that exactly?
08:54:15 <roconnor> @free head_partial :: [a] -> a
08:54:15 <lambdabot> f . head_partial = head_partial . $map f
08:55:11 <hatds> Berengal: so you remember to add a comment if you use it where it depends on invariants in your program
08:55:13 <jmcarthur> Berengal, than i _should_ check the documentation if i'm not familiar with it
08:55:20 <MyCatVerbs> Berengal: not much. You can get the fact that it's partial from the type alone, because [a] might be empty and () -> a isn't an axiom.
08:55:22 <jmcarthur> and what he said
08:55:43 <jmcarthur> this isn't about learning the function. this is about reading over existing code
08:55:49 <Berengal> MyCatVerbs: Okay, foo :: Int -> Char then :P
08:56:15 <jmcarthur> ^^ is a better example
08:56:24 <Berengal> jmcarthur: You should check the documentation anyway
08:56:55 <hatds> I prefer my code to be the documentation :)
08:57:01 <Berengal> hatds: Eh, I'm worse at documentation. Once I do write it though I'm usually careful about documenting my invariants
08:57:14 <MyCatVerbs> Berengal: can't be injective, Int is larger than Char. Could be surjective, though. =)
08:57:18 <Berengal> hatds: Types are a poor documentation.
08:57:31 <jmcarthur> types are excellent documentation
08:57:47 <jmcarthur> djinn would not be possible, otherwise
08:57:54 <MyCatVerbs> Types are perfect documentation, for what they do cover.
08:58:20 <Berengal> jmcarthur: Well, in a way. They're excellent in that they're always there and always correct. They're poor in that they carry very little information compared to the code or attached documentation
08:58:26 <inimino> MyCatVerbs: that sounds like a tautology :-)
08:58:27 <MyCatVerbs> Covering every interesting case in the type system is prohibitively difficult, however.
08:58:32 <fasta> Static types make it a lot easier to understand an unknown code-base.
08:58:49 <MyCatVerbs> inimino: No, it's just a restatement of the definition of a type checker, really.
08:59:20 <hatds> I view it as less of a question of "you should put it in the identifier" and more as "is there a convenient way to do so that it might look nice?"
08:59:38 <Berengal> Code always provides correct and complete documentation, but it can be hard to understand. Comments might be lacking or provide false documentation, but they can be as comprehensive as code and easier to understand
08:59:44 <hatds> it's no different that having nearly identical functions named func and func'
08:59:45 <jmcarthur> code doesn't have to "look nice." it must only be easily understandable
09:00:20 <Berengal> jmcarthur: I'd say those go hand in hand
09:00:44 <Berengal> Code that is easily understandable looks nice. The opposite is not always true
09:01:32 <hatds> perhaps a more motivating example would be if you had a list-like structure with functions that are partial when the corresponding list function isn't
09:01:49 <jmcarthur> Berengal, "looking nice" is an acquired taste, though. i don't think foldr' looks bad now, but i used to
09:01:53 <jmcarthur> err
09:01:54 <jmcarthur> foldl'
09:03:02 <Berengal> jmcarthur: It's possible to make objective observations though, such as if code follows the coding standard of the langauge
09:03:20 <quicksilver> you can make code look nice by colour coding the identifiers so that your program is a beautiful and delicate rendering of a mountain sunset.
09:03:30 <quicksilver> not great for the programmer who comes after you though.
09:03:46 <Berengal> quicksilver: Yes, I think I've seen something like that
09:03:59 <Berengal> I've got no idea what the program did though
09:04:36 <Berengal> Hence my earlier statement that code that looks nice isn't always easily understandable
09:04:41 <jmcarthur> Berengal, yes, i'm proposing a change to the coding standards, not a deviation from them :)
09:04:54 <jmcarthur> hypothetically, at least
09:05:08 <jmcarthur> err.... ideally, i mean
09:05:39 <Berengal> jmcarthur: It could be nice to put something like this in the coding standard, but I wouldn't put it in the language
09:06:19 <tetha> the problem with enforcing code styles is that there might be some gruesome case where not adhering to the standard results in more readability
09:06:27 <Berengal> Also, it can sometimes be hard to see if a function is partial or not, so annotating them specially might provide lots of false information
09:06:41 <jmcarthur> i don't see how it could be a part of the language itself anyway
09:07:25 <jmcarthur> could be nice if the type system tracked (perhaps implicitly) what functions are partial and warned you if you allow partiality to get all the way to the top level
09:07:46 <tetha> mm, good morning halte problem
09:07:48 <Berengal> jmcarthur: That would be putting it in the standard, no?
09:07:53 <jmcarthur> no
09:07:55 <Berengal> sorry, language
09:08:04 <jmcarthur> it wouldn't be a compiler error (without a flag for GHC or something), just a warning
09:08:13 <jmcarthur> only particular to some implementation
09:08:20 <jmcarthur> wouldn't not change semantics or the base type system
09:08:21 <EvilTerran> jmcarthur, seems related to what ndm's Catch does
09:08:25 <EvilTerran> ?where catch
09:08:25 <lambdabot> http://community.haskell.org/~ndm/catch/
09:08:27 <jmcarthur> EvilTerran, yes!
09:08:29 <hatds> let's change mapM_ to generalizedMap,  zipWithM to ZipWithMonad and   foldM to monadicFold
09:08:42 <hatds> yea or nay?
09:08:58 <jmcarthur> hatds, M is a decent convention, IMO
09:09:04 <hatds> exactly :)
09:09:09 <quicksilver> change "return" to "evaluateWithinFactory"
09:09:18 <EvilTerran> jmcarthur, although i'm guessing you want to cover possible non-termination as well as possible invocation of error
09:09:24 <Berengal> hatds: Let's change map :: (a -> b) -> [a] > [b] to map :: (a -> m b) -> [a] -> m [b]
09:09:26 <jmcarthur> although i would like it if Control.Functor.Categorical could be used to generalize mapM a bit
09:09:40 <quicksilver> and join to "enterpriseFactoryFactoryCombinationToolkitActivate"
09:10:04 <tetha> quicksilver: you mean "...ActivationProviderAct"?
09:10:16 <quicksilver> ah, indeed.
09:10:43 <glguy> mapM is generalized in Data.Traversable
09:10:51 <Berengal> >>= to goGoGadgetActionMultiplexer?
09:11:10 <hatds> :D
09:11:12 <jmcarthur> glguy, but you can't use the same function for both fmap and mapM
09:11:22 <jmcarthur> glguy, you can with Control.Functor.Categorical.cmap
09:11:23 <quicksilver> and throwDyn to itWouldHaveWorkedIfItWasntForThosePeskyKids
09:11:35 <jmcarthur> glguy, if you are willing to throw in some Kleisli, at least
09:12:13 <jmcarthur> i was just playing with that idea last night. unfortunately didn't seem to give much advantage due to need Kleisli
09:12:18 <jmcarthur> *needing
09:12:44 <jmcarthur> cmap = Kleisli . Data.Traversable.mapM . runKleisli
09:13:48 <jmcarthur> :t Kleisli . Data.Traversable.mapM . runKleisli -- I meant to do this instead of what I just did
09:13:49 <lambdabot> forall (t :: * -> *) (m :: * -> *) a b. (Monad m, Data.Traversable.Traversable t) => Kleisli m a b -> Kleisli m (t a) (t b)
09:14:32 <Berengal> If we could just partially apply type constructors...
09:14:40 <Berengal> We wouldn't need Kleisli
09:14:53 <jmcarthur> yeah
09:14:55 <jmcarthur> would be nice
09:15:06 <vixey> try prototyping a system that lets you partially apply
09:15:19 <jmcarthur> it gets weird
09:15:32 <jmcarthur> i tried it mentally, ran into some ambiguities
09:15:35 <Berengal> instance (Monad m) => Category (TypeLam A B -> A -> m B) where
09:15:35 <mib_716qnlzf> [x]:xs <-- why would this be wrong?
09:16:05 <Berengal> mib_716qnlzf: Not if xs :: [[a]]
09:16:09 <jmcarthur> mib_716qnlzf, it's not wrong if x :: [a] and xs :: [[a]]
09:16:14 <jmcarthur> err
09:16:16 <jmcarthur> x :: a
09:16:30 <Berengal> and x :: a
09:16:30 <Berengal> Otherwise, yes
09:16:50 <mib_716qnlzf> but i have an exam preparation question asking why that would be wrong, all haskell is saying is that unification would cause infinite type
09:16:57 <mib_716qnlzf> which i would like clarification
09:17:13 <Berengal> > let x = 1, xs = [[2]] in [x]:xs
09:17:14 <lambdabot>   <no location info>: parse error on input `,'
09:17:19 <jmcarthur> mib_716qnlzf, does the question specify the types of x and xs?
09:17:22 <Berengal> > let x = 1; xs = [[2]] in [x]:xs
09:17:24 <lambdabot>   [[1],[2]]
09:17:35 <mib_716qnlzf> jmcarthur: NO
09:17:45 <jmcarthur> mib_716qnlzf, then it's not a very good question
09:17:48 <mib_716qnlzf> sorry didnt meant to shout caps accident
09:18:05 <jmcarthur> mib_716qnlzf, the intent is probably for x::a and xs::[a] though
09:18:18 <jmcarthur> :t (:)
09:18:19 <lambdabot> forall a. a -> [a] -> [a]
09:18:21 <quicksilver> well.
09:18:22 <mib_716qnlzf> well the question is itself... [x]:xs=[x,xs]
09:18:28 <quicksilver> mib_716qnlzf says that haskell gives an error.
09:18:31 <mib_716qnlzf> if its false or not
09:18:34 <quicksilver> so there error *is* there in the question.
09:18:41 <vixey> [x]:xs=[x,xs] is not true
09:18:47 <quicksilver> the types are implied by the other part.
09:18:59 <Berengal> mib_716qnlzf: There's your answer then: [x]:xs is wrong only if forall a. x not :: a AND xs not :: [[a]]
09:19:05 <mib_716qnlzf> but why? I want to understand why its false.
09:19:28 <Berengal> Eh, I mess up my foralls
09:19:42 <jmcarthur> :t (:) -- for mib_716qnlzf
09:19:43 <vixey> these things are not equal
09:19:43 <lambdabot> forall a. a -> [a] -> [a]
09:19:48 <Asztal> in that case you're making [x] the first element of the list, so what it would be is [[x], ...]
09:19:54 <Berengal> [x]:xs is wrong only iff not exists a. x :: a AND xs :: [[a]]
09:19:54 <Asztal> where ... is xs
09:20:01 <quicksilver> mib_716qnlzf: [x,xs] is a list of two elements.
09:20:20 <quicksilver> mib_716qnlzf: [x]:xs is a list of lists, with one more elements than there are in xs.
09:20:35 <vixey> Reduce both sides to normal form and compare them
09:20:36 <mib_716qnlzf> oh ok i get it
09:20:39 <Berengal> @type [?x]:?xs
09:20:40 <lambdabot> Not in scope: data constructor `:?'
09:20:40 <lambdabot> Not in scope: `xs'
09:20:46 <quicksilver> so, they are both potentially valid, but can't be at the same time.
09:20:47 <Berengal> @type [?x]: ?xs
09:20:49 <lambdabot> forall t. (?xs::[[t]], ?x::t) => [[t]]
09:20:53 <vixey> they're syntactically different normal forms so they are different values
09:21:08 <vixey> Another way to tell whch is easier, is that they have different types
09:21:43 <Axman6> mib_716qnlzf: you're essencially trying to do something like thing = [ [1], [[2,3]] ]
09:32:25 <jmcarthur> mmorrow, what version of ghc are you using to build switchtrie?
09:32:35 <jmcarthur> it makes my 6.10.3 panic
09:33:48 <mmorrow> 6.10.1
09:33:54 <mmorrow> jmcarthur: what's the panic?
09:34:00 * mmorrow tries with 6.10.3
09:34:10 <jmcarthur> No match in record selector Var.tcTyVarDetails
09:35:06 <cocon>  /join #haskell
09:35:18 <cocon> What's RealWorld?
09:35:19 <Axman6> but we already did...
09:35:28 <Axman6> it's a type
09:35:31 <mmorrow> argh!
09:35:32 <mmorrow> No match in record selector Var.tcTyVarDetails
09:35:41 <cocon> what is RealWorld good for?
09:35:42 <roconnor> cocon: RealWord is a big hack that GHC does to implement IO.
09:35:45 <Axman6> that the compiler treats as special i think
09:35:55 <mmorrow> hmm, that's probably a result of some of the hackery in Trie... lemme fix it
09:36:16 <Axman6> it's good for implementing IO in terms of ST (or something very similar to it)
09:36:24 <mmorrow> well, s/fix/avoid the bug/
09:36:42 <cocon> RealWorld appears in the type of STM, which I'm trying to understand
09:36:55 <roconnor> cocon: don't understand STM that way
09:37:00 <Axman6> yeah
09:37:01 <cocon> what does it mean to parametrize the state monad with RealWord
09:37:06 <roconnor> consider STM an abstract data type consturctor
09:37:24 <cocon> ok
09:37:25 <Axman6> STM is one of those things that it's better to know how to use than how it works
09:37:41 <cocon> what can the STM constructor be applied to?
09:37:44 <jmcarthur> yeah, STM must be abstract
09:37:58 <jmcarthur> cocon, any type you want. it's a monad
09:38:12 <cocon> I meant the data constructor
09:38:21 <jmcarthur> you don't use the data constructor
09:38:29 <jmcarthur> it's not exported
09:38:38 <jmcarthur> you should probably be looking at the documentation, not the source
09:38:39 <conal> cocon: how STM is represented can change.   you can't rely on it.
09:38:39 <roconnor> I should have said consider STM an abstract type constructor.
09:38:53 <cocon> jmcarthur: it's in the haddock doc
09:39:17 <cocon> roconnor: thanks
09:39:46 <Axman6> cocon: like i said, find out how to use it, and don't worry about how it works. just assume it does :)
09:40:11 <tetha> hehe, that's my plan with monads now: use them for a month and then look into them again
09:40:24 <cocon> is newTVarIO evil?
09:40:31 <jmcarthur> i don't think so
09:40:37 <roconnor> cocon: I think, everything you see in GHC.Conc is "private".  Anyone care to back me up on this?
09:40:38 <cocon> it says it uses unsafePerformIO...
09:40:40 <mmorrow> jmcarthur: ok, just updated the repo http://moonpatio.com/repos/switchtrie/
09:40:43 <Axman6> been a while, i can't remember :P
09:40:54 <quicksilver> Yes. Don't attempt to understand STM by reading the source.
09:41:04 <quicksilver> Lots of the stuff in the GHC.* modules isn't even haskell.
09:41:05 <flipLeft> Axman6: im really htinking about Oz for study+surfing
09:41:07 <flipLeft> you surf?
09:41:13 <quicksilver> It's some evil imperative language which looks like haskell.
09:41:14 <jmcarthur> cocon, you could do the same by just running newTVar as a single atomic transaction, i think
09:41:14 <flipLeft> is it to hot to study :P ?
09:41:19 <cocon> quicksilver: I don't! it's here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
09:41:25 <jmcarthur> cocon, so newTVarIO should be safe, afaik
09:41:30 <flipLeft> to many crocs?
09:41:32 <mmorrow> jmcarthur: apparently ghc-6.10.3 barfs with standalone deriving with knot-tied constraints
09:41:37 <jmcarthur> cocon, those are the wrong docs ;)
09:41:40 <quicksilver> cocon: that's the private source documentation.
09:41:46 <cocon> oops
09:41:47 <quicksilver> it's intended for people working on the code
09:41:48 <jmcarthur> mmorrow, yuck!
09:41:49 <quicksilver> not people using the code.
09:41:58 <quicksilver> I don't mean it's secret :) it's just not helpful.
09:42:04 <Lemmih> cocon: Read the documentation again. It does not say it uses unsafePerformIO.
09:42:04 <quicksilver> for the purposes of learning how to use STM.
09:42:12 <Axman6> i don't surf, and right now, it's 10ºC, so no, not too hot to study where i am :P
09:42:21 <lament> does haskell need a neural network library?
09:42:32 <mmorrow> CAN HAZ BRAINZ?
09:42:33 <Axman6> lament: doesn't everyone?
09:42:43 <roconnor> here is the real documentation: http://www.haskell.org/ghc/docs/latest/html/libraries/stm/Control-Monad-STM.html
09:42:45 <cocon> Lemmih: right, it's a little hot here today
09:42:48 * Axman6 wonders who flipLeft is...
09:42:51 <lament> @faq CAN HAZ BRAINZ?
09:42:52 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:52 <roconnor> as you can see, it is totally undocumented :/
09:42:54 <jmcarthur> lament, i think some neural network stuff exists already, but don't hesitate to package up a nice standalone library. i think most people have written their own implementations over and over again
09:42:57 <mmorrow> yay!
09:43:09 <lament> jmcarthur: i've seen bindings to FANN on hackage.
09:43:22 <jmcarthur> lament, ah i never noticed that
09:43:39 <Lemmih> cocon: Don't mind them. You /are/ looking at the correct documentation.
09:43:47 <cocon> http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/GHC-Conc.html
09:43:55 <jmcarthur> mmorrow, yay all better!
09:43:57 <cocon> has the STM data constructor, too
09:44:02 <flipLeft> Axman6: city?
09:44:09 <flipLeft> which uni?
09:44:13 <jmcarthur> cocon, you are still looking at GHC.Conc
09:44:17 <mmorrow> jmcarthur: cool.
09:44:18 <flipLeft> you studied haskell there?
09:44:24 <jmcarthur> the modules starting with GHC are private
09:44:27 <cocon> jmcarthur: where should I look?
09:44:33 <jmcarthur> Control.Monad.STM
09:44:34 <roconnor> Lemmih: the STM constructor is not exported from Control.Monad.STM.
09:44:38 <EvilTerran> cocon, roconnor just gave you a link
09:44:53 <Axman6> flipLeft: canberra
09:44:57 <Axman6> ANU
09:45:03 <Axman6> and yes
09:45:07 <roconnor> The haddock documentation for Control.Monad.STM appears to be totally borked.
09:45:17 <jmcarthur> ugh
09:45:18 <EvilTerran> roconnor, but it does lead to a paper
09:45:31 <roconnor> EvilTerran: true
09:45:43 <Lemmih> cocon: The STM monad /is/ the IO monad. It just limits the actions you can run it in.
09:45:54 <quicksilver> no it isn't.
09:45:56 * quicksilver peers at Lemmih 
09:46:07 <jmcarthur> cocon, yeah, just read some material from here http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm
09:46:08 <quicksilver> Lemmih: IO doesn't have retry semantics.
09:46:12 <quicksilver> STM is quite different.
09:46:12 <flipLeft> ow inland Oz? why? are you ozzie?
09:46:20 <roconnor> Lemmih: that is implementation specific.
09:46:35 <Lemmih> quicksilver: It is isomorphic to the IO monad.
09:46:40 <quicksilver> how?
09:46:47 <jmcarthur> you can't IO -> STM
09:46:51 <jmcarthur> without unsafe stuff
09:46:55 <jmcarthur> so it can't be isomorphic
09:47:00 <quicksilver> how you can convert "readTVar a `orElse` readTvar b" into the IO monad?
09:47:00 <Axman6> flipLeft: why? because i was born here, and it's a really nice place
09:47:10 <Lemmih> jmcarthur: That is incorrect.
09:47:22 <quicksilver> (conversely you can't convert 'putStrLn "hello"' into STM)
09:47:31 <Lemmih> jmcarthur: (that it can't be isomorphic)
09:47:35 <quicksilver> I don't remotely see how you think they're isomorphic.
09:47:44 <jmcarthur> Lemmih, an isomorphic relationship has to be invertible
09:48:15 <jmcarthur> and complete
09:48:24 <mmorrow> jmcarthur: sigh, just realized i'm not escaping '\' in the generated C
09:48:29 <Lemmih> jmcarthur: unsafeIOToSTM compiles to 'id'.
09:48:33 <roconnor> Lemmih: please don't confuse the abstract type constructor with the concrete implementation.
09:48:38 <jmcarthur> Lemmih, that is implementation
09:48:48 <jmcarthur> it violates every rule about STM
09:49:04 <Lemmih> roconnor: I'm just pointing out why STM looks the say it does.
09:49:26 <Lemmih> roconnor: cocon asked about it and you didn't answer.
09:49:32 <flipLeft> Axman6: didnt mean to offend you im sure it is nice.
09:49:33 <jmcarthur> Lemmih, it looks like an abstract monad if you aren't peeking at the source
09:49:36 <flipLeft> but Oz is so hot I'd like to be clsoe to the seas
09:49:37 <flipLeft> sea
09:49:57 <Lemmih> jmcarthur: Excellent, and so it should.
09:50:00 <Axman6> depends where you are
09:50:06 <quicksilver> if we can use unsafeIOtoSTM to "prove" that IO is isomorphic to STM
09:50:13 <EvilTerran> ?type flip left
09:50:14 <lambdabot> forall b c d. Either b d -> (b -> c) -> Either c d
09:50:18 <quicksilver> we may as well use unsafePerformIO to "prove" that haskell is impure.
09:50:22 <EvilTerran> quicksilver, then we can use undefined to prove anything!
09:50:38 <roconnor> EvilTerran: different sort of proof :)
09:50:43 <quicksilver> and you still didn't answer what 'orElse' translates to, or how you get retry semantics in IO.
09:50:44 <jmcarthur> unsafeCoerce can prove anything
09:51:08 <Axman6> quicksilver: it can be emulated in IO though
09:51:21 <quicksilver> Axman6: not without a stupendous amount of machinery
09:51:30 <jmcarthur> quicksilver, orElse probably translates to an IO action that rolls back some STM stuff, but doesn't unlaunch the missiles
09:51:31 <Lemmih> quicksilver: The definition of STM is exactly the definition of IO. That's all I'm trying to say.
09:51:33 <quicksilver> Axman6: maintain your own MVCC system, checking for consistency.
09:51:47 <Lemmih> cocon should no more worry about the definition of IO than the definition of STM.
09:51:48 <roconnor> Lemmih: the implementation of STM is /not/ the definition of STM.
09:52:03 <Axman6> doesn't seem, too difficult to me... but... ok thinking about it more (and remembering the two arguments to orElse are STM actions), yes, there'd be a lot of machinery
09:52:06 <Axman6> :)
09:52:17 <Lemmih> The GHC source code definition of STM is exactly the GHC source code definition of IO.
09:52:28 <mmorrow> , text "\\'"
09:52:29 <jmcarthur> STM and IO are defined by their semantics, not their implementations. i think this is all just differences of terminology
09:52:33 <lunabot>  \'
09:52:41 <cocon> what's the implementation of IO?
09:52:46 <EvilTerran> Lemmih, that's an instance of the fundamental theorem of algebra
09:52:49 <mmorrow> , quotes (text "\\'")
09:52:49 <Axman6> @src IO
09:52:49 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:52:50 <jmcarthur> @src IO
09:52:50 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:52:50 <lunabot>  '\''
09:52:53 <Lemmih> cocon: Don't worry about that (:
09:52:57 * Axman6 wins for once
09:53:05 <Asztal> but your original assertion was that STM is just IO with limitations on what you can do
09:53:08 <jmcarthur> the IO source is highly misleading though
09:53:17 <cpriester> hi!
09:53:21 <cocon> Lemmih: I'm curious
09:53:26 <jmcarthur> there are limitations on what you can do in IO, as well
09:53:32 <quicksilver> Asztal: right.
09:53:34 <jmcarthur> you can't roll back with orElse, for example
09:53:36 <roconnor> jmcarthur: true, but cocon doesn't really want to know the implementation specifics of STM, or IO.  I don't know why Lemmih is telling him about it.
09:53:38 <quicksilver> and that assertion is quite misleading.
09:53:39 <Axman6> cocon: it's generally considered magic
09:53:40 <Asztal> it is "just IO" in a sense, but it has additional things
09:53:42 <EvilTerran> er, not theorem, axiom. "forall x, x is x" :P
09:53:52 <quicksilver> because STM has rollback abilities
09:53:55 <quicksilver> which IO does not having
09:53:59 <Axman6> cocon: also, it's implementation specific. ghc does it one way, i'm sure hugs does it another
09:54:02 <quicksilver> so I'd say STM is quite unlike 'IO with limitations'
09:54:12 <cpriester> i have a question about arrays: i changed from Data.Array do Data.Array.Unboxed.UArray and now the program stops execution with the message: "main: <<loop>>"
09:54:13 <jmcarthur> @src
09:54:13 <lambdabot> src <id>. Display the implementation of a standard function
09:54:15 <jmcarthur> @src STM
09:54:15 <lambdabot> Source not found. It can only be attributed to human error.
09:54:16 <glguy> maybe ST was intended?
09:54:16 <cpriester> What does that mean?
09:54:33 <jmcarthur> STM is (State# RealWorld -> (# State# RealWorld, a #)) with limitations
09:54:36 <jmcarthur> and so is IO
09:54:36 <roconnor> cpriester: GHC decided your program was stuck in an infinite loop.
09:54:38 <EvilTerran> cpriester, cells in unboxed arrays can't depend on other cells in the same array
09:54:46 <cocon> is there any hope for me to understand (State# RealWorld -> (# State# RealWorld, a #)) ? (I know I don't need it to write programs, bit I still wonder...)
09:54:46 <mmorrow> jmcarthur: err, i'm not escaping anything actually :/
09:54:47 <jmcarthur> they just have different limitations
09:54:48 <cpriester> Oh no.
09:54:54 <cpriester> How should i do memoisation, then?
09:55:02 <glguy> with boxed arrays
09:55:04 <roconnor> cpriester: use a boxed array
09:55:04 <EvilTerran> cpriester, because the unboxing means there's no room for laziness
09:55:06 <Axman6> cocon: it's pretty damn close to the State monad
09:55:12 <cpriester> Ok. I understand.
09:55:15 <mmorrow> jmcarthur: there's a toCChar in PprC in ghc though, should be drop-in
09:55:22 <cpriester> But the lazy ones are much too slow.
09:55:26 <cocon> what are the #s?
09:55:35 <Axman6> unboxed values cocon
09:55:41 <Axman6> @src Int
09:55:41 <lambdabot> data Int = I# Int#
09:55:48 <EvilTerran> cocon, they're not haskell, they're ghc-speak
09:55:50 <roconnor> cocon: those are all GHC specific implemenation nonsense.
09:55:57 <Axman6> Int# is a machine int (C int basically)
09:56:15 <cocon> and 'a #'?
09:56:16 <cpriester> With an input of 100000 values and an O(nlogn) precalculation (in space and time), it takes over 100 MB.
09:56:18 <Axman6> and Int is a thing that points to an int (or a function that will produce one i think)
09:56:32 <quicksilver> the # in State# doesn't really mean unboxed
09:56:36 <quicksilver> it just means 'implementation magic'
09:56:43 <quicksilver> I think.
09:56:50 <Axman6> true
09:56:50 <quicksilver> 'here be dragons'
09:56:52 <EvilTerran> cocon, read "#" as "here be dragons"
09:56:58 <quicksilver> # doesn't always mean unboxed.
09:56:58 <EvilTerran> quicksilver++ hehe
09:57:12 <Axman6> cocon: oh and it;s (# , #), which is an unboxed arrasy, not a #
09:57:13 <Lemmih> cocon: (# a, b #) is an unboxed tuple. It makes it possible to return two results without allocating an actual tuple.
09:57:15 <Axman6> array*
09:57:15 <cocon> how should the other #s be parsed? (# ... #)
09:57:29 <Axman6> god damn, why is all the interesting stuff on when i need to sleep?
09:57:29 <roconnor> I kinda wish @src would stop giving out GHC internal stuff.
09:57:38 * EvilTerran agrees
09:57:49 <fracture> is there a way to write a pattern that matches lists ending with something?
09:58:06 <Axman6> fracture: use isSufixOf
09:58:09 * EvilTerran would prefer "data Integer = ... | -1 | 0 | 1 | 2 | ..." etc :P
09:58:09 <Axman6> ff*
09:58:09 <fracture> something like foo (xs ++ "ASD") = something xs ++ "foo"
09:58:25 <EvilTerran> fracture, not with a pattern, unfortunately
09:58:28 <fracture> yeah I know about that... wondering if it can be done with patterns
09:58:30 <fracture> ah d'oh
09:58:37 <roconnor> fracture: not really.  You could sort of use views
09:58:43 <fracture> dunno views yet
09:58:50 <EvilTerran> fracture, because you're matching something deep in the structure of the list object (at the "far end", as it were)
09:59:06 <cocon> Axman6: array?!
09:59:16 <EvilTerran> fracture, so how far you navigate the list structure will depend on the list, so you can't do it in a standard pattern
09:59:23 <Axman6> uh, not array, tuple, sorry
09:59:29 <fracture> *nod*
09:59:31 <Axman6> it's 3AM, and i need sleep ;)
09:59:39 <cpriester> Well, that means, i cannot use haskell if i do a lot of memoisation?
09:59:49 <EvilTerran> cpriester, definitely not!
09:59:51 <Axman6> cocon: not at all
09:59:59 <Berengal> views are good, but guards are better
10:00:01 <Axman6> you just need to do it the right way ;)
10:00:03 <cocon> is State# RealWorld a phantom type?
10:00:08 <Berengal> At least i this case
10:00:09 <EvilTerran> ?faq can haskell do excellent memoisation?
10:00:09 <lambdabot> The answer is: Yes! Haskell can do that.
10:00:18 <Axman6> cocon: it's magic
10:00:23 <EvilTerran> cocon, it's a magic type
10:00:23 <fracture> is there a replace function for lists?
10:00:33 <jmcarthur> cpriester, are you feeling somehow that haskell is doing something unpredictable?
10:00:39 <roconnor> cocon: it's just magic
10:00:49 <Berengal> fracture: replace as in map?
10:00:50 <EvilTerran> cocon, being able to use # in these places requires use of the MagicHash extension, so "magic" is a technical term here :P
10:00:59 <lilac> cocon: it's sufficiently advanced technology
10:00:59 <mmorrow> jmcarthur: just pushed patch to fix char quoting
10:01:01 <fracture> (I wanna replace the last occurance of a substring with something else)
10:01:02 <cocon> the doc says 'The only purpose of the type parameter is to keep different state threads separate'
10:01:17 <mmorrow> jmcarthur: i think it actually works now :)
10:01:22 <jmcarthur> mmorrow, i will just wait until i get home to play with this
10:01:23 <jmcarthur> thanks
10:01:30 <Axman6> cocon: the SPJ paper on the ST monad is probably worth reading
10:01:36 <lilac> fracture: take a look at the Data.List.Split module on hackage
10:01:47 <roconnor> cocon: if you just want to write STM programs, you are heading down the wrong path here.
10:01:57 <cpriester> No, not unpredictable.
10:01:59 <Axman6> wow... my first paper recommendation :O
10:02:02 <roconnor> cocon: if you want to modify how GHC's STM implemenation works, then you are doing ok.
10:02:02 <cpriester> But its too slow.
10:02:20 <cpriester> In the wiki they dont use arrays, as far as i can see.
10:02:24 <cocon> roconnor: thanks, I'm aware of it. I'm just being curious now
10:02:26 <cpriester> For memoisation.
10:02:30 <roconnor> cocon: okay :)
10:02:32 <Axman6> cpriester: if you don't write it correctly, then yes
10:02:41 <jmcarthur> cpriester, i don't think this is a problem with haskell
10:02:49 <jmcarthur> you would have the same space-time tradeoff with any other language
10:03:12 <cpriester> No, why?
10:03:28 <Axman6> cpriester: i've used arrays quite effectively for memoisation. you need to use laziness a lot (and have arrays reference other values in the array for it to be effective)
10:03:34 <cpriester> I have exactly n*logn*sizeof(int) in C and O(nlogn) time
10:03:53 <jmcarthur> memoization, by definition, is keeping values around for a while
10:04:07 <jmcarthur> you are getting something different in haskell?
10:04:25 <cpriester> yes, i get much memory and time overhead.
10:04:49 <jmcarthur> source?
10:04:54 <jmcarthur> hpaste.org
10:04:56 <cpriester> Where can i paste it?
10:04:58 <cpriester> ah, ok
10:05:40 <fracture> hmm ok so, if I want to drop the last 5 characters in a string... is there a better way than using inits and !!
10:05:41 <lilac> cpriester: you probably have an unevaluated thunk somewhere holding on to a reference to something you thought you were done with
10:05:41 <fracture> ?
10:05:53 <cpriester> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4903#a4903
10:05:57 <lilac> fracture: take
10:06:10 <fracture> ah yeah
10:06:10 <fracture> thanks
10:06:15 <fracture> but
10:06:15 <glguy> > let dropLast n xs = zipWith const xs (drop n xs) in dropLast 2 [0..10]
10:06:16 <lambdabot>   [0,1,2,3,4,5,6,7,8]
10:06:18 <fracture> I have to use take and length?
10:06:24 <lilac> fracture: you can do better than take, but it's more work
10:06:26 <cpriester> This should precompute range minimum queries to be executed in constant time
10:06:28 <Axman6> fracture: sounds like you need a better data structure
10:06:33 <fracture> this is a String
10:06:41 <fracture> pretty normal operation with strings...
10:06:42 <lilac> fracture: (take/length will force the whole list into memory)
10:06:48 <glguy> fracture, the code I just pasted will do the drop lazily
10:06:49 <Axman6> glguy: i like that :)
10:07:00 <Axman6> what a nice definition
10:07:00 <roconnor> String is kinda a poor data type for strings.
10:07:06 <lilac> fracture: ByteString is often better for strings
10:07:07 <fracture> that'd be nice to have in Data.List, eh?
10:07:07 <cpriester> well, at the end, all of my array enrties should be computed.
10:07:13 <glguy> well, I didn't paste it
10:07:17 <glguy> but the code does what I said :)
10:07:22 <Zao> lilac: Lots of transcoding then.
10:07:22 <Axman6> @remember roconnor String is kinda a poor data type for strings.
10:07:23 <lambdabot> I will never forget.
10:07:30 <Zao> I'd go for the Text type instead.
10:07:44 <glguy> Axman6, I like that definition because you can use it on infinite lists as well
10:07:54 <Axman6> yeah :)
10:07:54 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text <- that one
10:08:32 <jmcarthur> cpriester, just a hunch, but what happens if you make the fields of your RMQ data type strict?
10:08:49 <cpriester> what? how can o do that?
10:08:55 <roconnor> Zao: bytestrings have O(1) length, right?
10:09:03 <metaperl_work> What term would define 'converting inches to feet and inches' ?
10:09:05 <roconnor> I mean the length function takes O(1) time?
10:09:08 <jmcarthur> actually, i don't know that that would help
10:09:15 <jmcarthur> try anyway, they are technically strict fields
10:09:29 <Berengal> roconnor: I'd imagine strict ones do
10:09:29 <lilac> roconnor: is that length in bytes or in Chars, though?
10:09:39 <cpriester> how can i do?
10:09:44 <jmcarthur> data (Ord a) => RMQ a = RMQ !(ArrayType Int64 a) !(ArrayType (Int64, Int64) Int64) -- cpriester
10:09:52 <roconnor> lilac: good point
10:10:04 <roconnor> lilac: presumably length :: Text -> Int  is in chars
10:10:09 <roconnor> but, is it still O(1)?
10:10:12 <fracture> glguy: thanks, that dropLast works fine
10:10:18 <fracture> question though; what's the const thing do?
10:10:24 <Berengal> @type const
10:10:26 <lambdabot> forall a b. a -> b -> a
10:10:28 <roconnor> bah, docs say it is O(n)
10:10:42 <fracture> h const is a function
10:10:48 <jmcarthur> i am doubtful that will help now, i don't see much let/case going on with that structure
10:10:49 <Axman6> > zipWith const [1..10] [50..]
10:10:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:10:53 <Axman6> > zipWith const [1..10] [50..55]
10:10:55 <lambdabot>   [1,2,3,4,5,6]
10:10:59 <cpriester> Seems, like there is no big difference.
10:10:59 <roconnor> apparently unicode makes dropping the last 5 characters kinda difficult.
10:11:03 <jmcarthur> yeah
10:11:22 <fracture> ah
10:11:25 <cpriester> Still much too slow.
10:11:26 <fracture> just returns the first argument?
10:11:48 <Berengal> > const "yes" "no"
10:11:50 <lambdabot>   "yes"
10:11:55 <Axman6> cpriester: maybe you should look into the ST monad. might be able to use it to get better performance
10:11:59 <fracture> nice
10:12:05 <Berengal> @src const
10:12:06 <lambdabot> const x _ = x
10:12:36 <fracture> that dropLast would be nice to have in Data.List :)
10:13:05 <cpriester> hm.
10:13:11 <roconnor> glguy: that's a nice function.
10:13:12 <Berengal> There are several list functions I'd like to see
10:13:12 <cpriester> i never used such things, yet.
10:13:28 <jmcarthur> cpriester, what exactly do this do, if you don't mind me asking?
10:13:41 <roconnor> glguy: very nice
10:13:44 <roconnor> glguy++
10:14:01 <cpriester> You can read a list of numbers and can query for a minimum number in a given interval.
10:14:04 <Axman6> cocon: you shoulod check out the paper "Lazy functional state threads" here: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
10:14:10 <cpriester> The query should be answered in constant time
10:14:42 <cpriester> so, a naive solution would be a lookup table in n^2
10:14:51 <cpriester> and this one is n log n
10:15:32 <cpriester> but space and time efficiency are worse than n^2 in other languages.
10:15:45 <cpriester> with those arrays
10:15:48 <jmcarthur> what is the algorithm called?
10:16:32 <Berengal> Oh, I know how to do this, but I forgot the name of the algorithm I'd use :/
10:16:45 <glguy> the naive solution would be to have a list of indexes sorted by their values
10:16:53 <cpriester> its described in the paper of bender and farach-colton
10:16:55 <glguy> and in one pass find the index that is in the range
10:17:04 <glguy> no?
10:17:39 <cpriester> yes, you can have a table for each index to each index.
10:17:45 <cpriester> but thats n^2 space
10:17:51 <glguy> no
10:17:53 <Berengal> No, that's n space
10:17:57 <glguy> one array with the indexes in order
10:18:01 <Berengal> 2*n, which is O(n) anyway
10:18:04 <glguy> and then you ask "is the first index in the range?"
10:18:34 <glguy> but that has slower lookup... and you wanted constant
10:18:52 <cpriester> yes, should be constant.
10:18:58 <jmcarthur> a finger tree could get you log n lookup
10:19:10 <Axman6> cpriester: look into the ST monad and STArrays
10:19:13 <Berengal> I believe I know how to get it down to O(m) where m is the size of the range
10:19:23 <cpriester> There are algorithms with O(n) precomputation and O(1) lookup, but O(n log n) precomp. would be enough for beginning.
10:19:23 <jmcarthur> what is the name of the paper?
10:19:43 <lilac> when you say "in a given interval", do you mean a sublist of the list, or filtering the list to numbers in an interval?
10:19:47 <jmcarthur> i'm mostly just curious. i doubt i would be able to help you today
10:19:49 <cpriester> The LCA Problem revisited
10:19:53 <jmcarthur> thanks
10:20:05 <Axman6> cpriester: actually, there's some stuff on my blog about STArrays (in regards to one of the shootout problems. managed to get my haskell version around 3x the C one)
10:20:29 <lilac> cpriester: (my previous question was for you... :)
10:21:15 <cpriester> lilac: I didnt understand the question, sorry.. I habe a list, say with elements from 1..n and i give two indexes, 1 <= i <= j <= n and i want the minimum element between i and j
10:21:26 <lilac> cpriester: ok, then i follow
10:22:14 <lilac> sounds possible in O(1) time and O(n) space
10:22:21 <cpriester> yes, it is.
10:22:32 <cpriester> but i first wanted to get it in O(nlogn) running.
10:22:34 <lilac> nice puzzle :)
10:22:38 <Berengal> Okay, so an array of (Int, Int), where the first number is the value and the second number is how many indexes you have to jump down to get to a lower value
10:23:04 <Berengal> Or just the index of the lower value
10:23:05 <cpriester> The second one is the log of the values in the interval.
10:23:30 <koeien> is wrapping with Word64 guaranteed ?
10:23:59 <Axman6> koeien: for three years
10:24:03 <Axman6> only for*
10:24:03 <koeien> ok. thanks
10:24:20 <Axman6> after that, you have to buy the extended warranty
10:24:21 <cpriester> for each index you save the minimums for 2^k ranges, k=1..log n
10:25:03 <Axman6> koeien: i'm assuming you mean is it guaranteed to be a 64 bit unsigned word?
10:25:42 <cpriester> And the case 2^(j+1) can be reduced to 2^j, that is, why i need memoisation.
10:26:12 <koeien> Axman6: i mean, maxBound + 1  behaves like i expect, on all platforms
10:26:22 <Axman6> should do
10:26:37 <Axman6> > maxBound + 1 :: Word64
10:26:38 <lambdabot>   0
10:26:44 <koeien> yes, i tested this
10:26:53 <koeien> but that is no guarantee on different platforms ;)
10:26:54 <Axman6> @src Word64
10:26:54 <lambdabot> Source not found. That's something I cannot allow to happen.
10:27:12 <koeien> ah, never mind. it says so at the end of the docs
10:27:30 * koeien should RTFM better
10:27:52 <koeien> ("all arithmetic is performed modulo 2^n")
10:27:59 <mmorrow> how does are Array indices handled when they're not simply Int
10:28:15 <mmorrow> in particular, say for (Int,Int,Int)
10:28:16 <mmorrow> ??
10:28:19 <dolio> @src ix
10:28:19 <lambdabot> Source not found. My brain just exploded
10:28:22 <dolio> @src Ix
10:28:22 <lambdabot> class (Ord a) => Ix a where
10:28:22 <lambdabot>     range           :: (a,a) -> [a]
10:28:22 <lambdabot>     index           :: (a,a) -> a -> Int
10:28:22 <lambdabot>     inRange         :: (a,a) -> a -> Bool
10:28:22 <lambdabot>     rangeSize       :: (a,a) -> Int
10:28:27 <Axman6> using Ix :)
10:28:28 <mmorrow> ahhh
10:28:43 * mmorrow had forgotten about that class
10:28:52 <gnuvince> What's Ix?
10:28:59 <gnuvince> _I_nde_x_?
10:28:59 <Axman6> rray in
10:29:00 <mmorrow> @instances Ix
10:29:01 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
10:29:01 <jmcarthur> basically things which can be ranges
10:29:04 <Axman6> array indicies*
10:29:07 <jmcarthur> for arrays
10:29:07 <Axman6> basically
10:29:27 <Axman6> @instances-importing Data.Array.Ix Ix
10:29:27 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
10:29:32 <dolio> indix ((1,2,3),(4,5,6)) (3,3,4)
10:29:35 <mmorrow> , index ((0,0,0),(10,10,10)) (2,6,3)
10:29:37 <dolio> > index ((1,2,3),(4,5,6)) (3,3,4)
10:29:37 <lunabot>  311
10:29:38 <lambdabot>   37
10:29:43 <Axman6> meh, i need to sleep. night all
10:30:24 <cpriester> Why are Arrays in the ST monad faster?
10:30:34 <dolio> Are they?
10:30:46 <mmorrow> , fmap (index ((0,0,0),(10,10,10))) (fmap ((,) 2 6) [0..9])
10:30:47 <lunabot>  luna: Couldn't match expected type `a -> (t, t1, t2)'
10:30:47 <cpriester> Someone said it.
10:30:48 <Twey> Well, they're faster than immutable arrays
10:30:48 <dons> faster than?
10:30:52 <mmorrow> , fmap (index ((0,0,0),(10,10,10))) (fmap ((,,) 2 6) [0..9])
10:30:53 <lunabot>  [308,309,310,311,312,313,314,315,316,317]
10:31:02 <dons> ST arrays have hardware support for their operations :)
10:31:11 <cpriester> Ah, ok.
10:31:26 <cpriester> But i think, i cannot use them like other arrays.
10:31:28 <dons> (ST arrays are basically safe C arrays)
10:31:41 <mmorrow> i'm debating whether to use an array to index a large number of statically generated functions
10:31:48 <mmorrow> (using (Int,Int,Int))
10:32:35 <dons> hmm.
10:32:40 <dons> couldn't you case on them?
10:32:46 <dons> and have ghc work out the best representation?
10:32:49 <mmorrow> hmm, maybe should just generate the code to call the appropriate function while i'm at it, so there's no indirection
10:34:13 <mmorrow> yeah, or case sounds ok too
10:35:21 * mmorrow is trying to get set up with andyjgill's kure pkg
10:35:45 <mmorrow> it's really nice
10:36:11 <mmorrow> (.... once you've bootstrapped yourself by generating gobs of code for your datatypes ;)
10:37:00 <mmorrow> i'm trying to get code generated for the TH AST, so then the bootstrap step is bootstrapped! :)
10:39:06 <mmorrow> (i.e. you can use kure to manipulate the TH ast to in turn generate kure support code for your datatypes to in turn be able to use kure to manipulate them)
10:39:37 * mmorrow 's brain splatters all over his keyboard
10:39:48 <vixey> and he was so young
10:42:21 <neoswish> does ghc support Implicit View Functions? because its throwing a parse error
10:42:54 <MyCatVerbs> neoswish: 6.10 does, but it's a language extension that you need to switch on.
10:43:44 <MyCatVerbs> You'll want to put {-# LANGUAGE ViewPatterns #-} at the top of your source file, above the module line.
10:44:35 <neoswish> MyCatVerbs, i did, but i can't write ( -> ...) , only (view -> ...)
10:46:04 * MyCatVerbs checks the manual.
10:46:23 <MyCatVerbs> neoswish: http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns doesn't mention implicit view patterns, so I don't think they're in there.
10:47:36 <MyCatVerbs> neoswish: implicit view patterns and implicit maybe are both mentioned on the wiki, but as features that will be added, rather than features that are already in there.
10:49:38 <mux> @pl \x _ -> f x
10:49:38 <lambdabot> const . f
10:51:42 <flipRight> @type (>>>)
10:51:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
10:51:58 <flipRight> > map ord [1..3]
10:52:00 <lambdabot>       No instance for (Num Char)
10:52:00 <lambdabot>        arising from the literal `1' at <inte...
10:52:03 <flipRight> > map char [1..3]
10:52:04 <lambdabot>       No instance for (Num Char)
10:52:04 <lambdabot>        arising from the literal `1' at <inte...
10:52:15 <flipRight> > map (char . (+48)) [1..3]
10:52:16 <lambdabot>       No instance for (Num Char)
10:52:16 <lambdabot>        arising from the literal `48' at <int...
10:52:30 <flipRight> > map (\x -> char $ x+48) [1..3]
10:52:30 <lambdabot>       No instance for (Num Char)
10:52:30 <lambdabot>        arising from the literal `48' at <int...
10:52:35 <flipRight> > map (\x -> chr $ x+48) [1..3]
10:52:36 <lambdabot>   "123"
10:52:44 <flipRight> > map (chr . (+48)) [1..3]
10:52:46 <lambdabot>   "123"
10:53:04 <flipRight> > map ((chr . (+48)) *** (+1)) [1..3]
10:53:05 <lambdabot>       No instance for (Enum (Int, b'))
10:53:05 <mux> > map intToDigit [1..3]
10:53:06 <lambdabot>        arising from the arithmetic seq...
10:53:07 <lambdabot>   "123"
10:53:12 <flipRight> > map ((chr . (+48)) &&& (+1)) [1..3]
10:53:13 <lambdabot>   [('1',2),('2',3),('3',4)]
10:53:48 <glguy> > map (intToDigit &&& succ) [1..3]
10:53:49 <lambdabot>   [('1',2),('2',3),('3',4)]
10:54:15 <flipRight> @src intToDigit
10:54:16 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:54:31 <flipRight> i dotn a-hole
10:55:11 <centrinia> @faq Can Haskell be used to make a bot that is more insulting than a 4chaner?
10:55:12 <lambdabot> The answer is: Yes! Haskell can do that.
10:57:27 <glguy> flipRight, http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Show.html#intToDigit
11:00:25 <flipRight> why is it so complicated?
11:00:34 <copumpkin> what is so complicated?
11:00:37 <flipRight> why nto jsut (chr . (+48)) ?
11:00:44 <flipRight> intToDigit
11:00:48 <glguy> > intToDigit 10
11:00:49 <lambdabot>   'a'
11:01:02 <flipRight> wait nevermind
11:01:08 <flipRight> no i meant the implementation
11:01:10 <flipRight> but nevermind
11:01:22 <copumpkin> :)
11:01:28 <centrinia> > chr . (+ (ord '0')) $ 0
11:01:29 <lambdabot>   '0'
11:01:31 <mux> this implementation is quite low-level for efficiency reasons
11:01:35 <centrinia> > chr . (+ (ord '0')) $ 9
11:01:36 <lambdabot>   '9'
11:01:39 <glguy> flipRight, it looks like they were going for speed, so they operated on unboxed Ints
11:01:41 <centrinia> > chr . (+ (ord '0')) $ 12
11:01:43 <lambdabot>   '<'
11:01:47 <flipRight> whata re al those #
11:01:51 <flipRight> soem sort of pragma?
11:01:55 <centrinia> > intToDigit 12
11:01:55 <mux> unboxed values
11:01:55 <glguy> flipRight, and used some unsafe function versions after manually checking the value ranges
11:01:57 <lambdabot>   'c'
11:02:39 <Absolute0> How do I enter quarded equation or literal functions into ghci or hugs?
11:02:54 <mux> Absolute0: you can delimite lines with ;
11:03:03 <Absolute0> mux x = 5 fails
11:03:17 <glguy> Absolute0, let mux x = 5
11:03:32 <Absolute0> so from a script let is implied?
11:03:59 <glguy> Absolute0, you have to treat the GHCi prompt like the body of the main function in do-notation
11:04:11 <mux> > let f x | x > 0 = x; otherwise = negate x in f (-2)
11:04:12 <lambdabot>   * Exception: /tmp/9058659933102619546:71:44-58: Non-exhaustive patterns in ...
11:04:16 <glguy> GHCi doesn't simulate the module top-level
11:04:27 <mux> > let f x | x > 0 = x; | otherwise = negate x in f (-2)
11:04:28 <lambdabot>   <no location info>: parse error on input `|'
11:04:35 <glguy> mux, no ; before the |
11:04:39 <Absolute0> also is ghc preferred over hugs?
11:04:42 <mux> doh, yeah
11:04:47 <mux> > let f x | x > 0 = x | otherwise = negate x in f (-2)
11:04:47 <glguy> Absolute0, yes
11:04:48 <lambdabot>   2
11:04:54 <Absolute0> The book by graham hutton seems to prefer hugs
11:05:01 <mux> > let x = 1; y = 2 in x + y
11:05:01 <Absolute0> the popular one that i am currently reading
11:05:02 <lambdabot>   3
11:05:15 <jeff_s_> would anyone like to help me with a little syntax problem? http://pastebin.com/d40ecd247
11:05:18 <copumpkin> Absolute0: hugs is getting old
11:05:27 <Absolute0> what makes ghc better?
11:05:27 <lament> Absolute0: that looks like a textbook.
11:05:27 <vixey> what is the rpoblem jeff
11:05:44 <lament> Absolute0: perhaps hugs could be better for use in a class.
11:05:55 <Absolute0> oh
11:06:00 <copumpkin> I think ghc has better error messages too
11:06:05 <mux> I think I can spot several problems with that code
11:06:12 <Jedai> Absolute0: I think Hugs was better suited for beginners at a time
11:06:21 <jeff_s_> vixey - just a parse error
11:06:32 <Jedai> But I'm pretty sure it has almost 0 advantages over GHCi now
11:06:35 <vixey> jeff_s: maybe line 6 should start:  main = ...
11:06:40 <lament> hugs is probably easier to install
11:06:43 <glguy> jeff_s_, basically everything is wrong :)
11:06:48 <jeff_s_> oh :P
11:06:54 <Twey> Absolute0: GHC has more extensions
11:06:56 <Absolute0> lament: not on linux
11:07:00 <mux> your program reduces to main = interact id
11:07:06 <glguy> jeff_s_, starting from the top, getLines doesn't need a () parameter
11:07:13 <mux> err, nope, sorry
11:07:17 <jeff_s_> *really*?! huh, i'm going to have to look at this some more
11:07:25 <mux> I missed the takeWhile part
11:07:26 <flipLeft> i never tried GHC but whats hard about haskell is things that if they werent hard at start i dont think you could call it haskell anymore, it would ahve to change to much
11:07:31 <Jedai> Absolute0: Besides for real use, GHC is just better (support more extensions, libraries, produce faster executable...)
11:07:33 <glguy> jeff_s_, you'll need to bind the result from getLine and getLines
11:07:38 <glguy> jeff_s_, in order to cons the results together
11:07:53 <glguy> jeff_s_, getLines will never return
11:08:00 <glguy> IO isn't lazy
11:08:00 <jeff_s_> oh ok
11:08:04 <flipLeft> im lazy
11:08:11 <jeff_s_> haskell is lazy
11:08:13 <flipLeft> i always said it was a good thing
11:08:19 <vixey> the point is, you can get the damn thing working faster with dynamic languages.
11:08:29 <glguy> jeff_s_, you can't have top level expressions like "map putStrLn ..."
11:08:38 <glguy> map isn't monadic and won't run putStrLn
11:08:48 <mux> main = interact (unlines . takeWhile (/= "42") . lines)
11:08:54 <mux> I think that's your program
11:08:57 <glguy> IO doesn't have equality
11:09:03 <jeff_s_> ok thanks. i'm used to ocaml so that's strange to me
11:09:05 <glguy> so you can't do (/= return "42")
11:10:02 <Absolute0> Why is main :: IO () and not just main :: IO
11:10:10 <glguy> because IO isn't a type
11:10:19 <glguy> :k IO
11:10:20 <lambdabot> * -> *
11:10:23 <Absolute0> what does appending () do?
11:10:23 <lament> @quote puerile
11:10:24 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
11:10:30 <Jedai> jeff_s_: just look at the types, map putStrLn produce a [IO ...] whereas in a do block you can only have things of type IO ...
11:10:52 <Jedai> Absolute0: IO is a type constructor, it's not a type
11:10:56 <gnuvince> Absolute0: you can think of IO as a "box" that contains a value of a certain type.  So IO () is an IO box that contains a value of type ().
11:10:58 <jeff_s_> thanks. it'll start to come to me with practice
11:11:15 <glguy> Absolute0, IO () is a computation that runs in IO, producing a () result
11:11:16 <gnuvince> Absolute0: it's not completely exact, but it's one way to think about it.
11:11:24 <Jedai> Absolute0: Like [] isn't a type but [Int] is a list of Int
11:11:51 <mux> to stick more closely to your code, using putStrLn etc, your code would be main = mapM_ putStrLn . takeWhile (/= "42") . lines =<< getContents
11:11:58 <Absolute0> basically IO () is simpler to an interface instance in Java?
11:12:08 <Jedai> Absolute0: a type constructor is kinda like a function at the type level
11:12:34 <Jedai> Absolute0: Your last sentence didn't make sense to me...
11:12:46 <Twey> Absolute0: IO is like a generic
11:12:54 <Twey> IO<()>
11:12:56 <mux> Absolute0: IO () is the type of a function in the IO monad (we often say action), that produces a () value when it is run
11:12:57 <Absolute0> is it possible to find a job coding haskell in the US?
11:13:01 <marcot> glguy: You can use map putStrLn
11:13:06 <Twey> Likely
11:13:09 <marcot> glguy: Is just not very practical..
11:13:13 <glguy> marcot, sure :)
11:13:20 <Jedai> Absolute0: It's posible, not very easy
11:13:20 <glguy> Absolute0, IO () is like 'void' in Java
11:13:26 <Absolute0> oh
11:13:28 <glguy> things that can do anything but don't return a value
11:13:28 <mux> yeah, you'd end up doing sequence_ . map putStrLn, which is just mapM_ ...
11:13:40 <Twey> Absolute0: You'd have better luck getting a job where they didn't care what language you used
11:13:42 <marcot> > sequence $ map putStrLn ["abc", "bca"]
11:13:44 <lambdabot>   <IO [()]>
11:14:18 <Twey> Oh, that's cool
11:14:25 <Twey> > return "hello" :: IO String
11:14:26 <Absolute0>  Twey I am going to try to implement a chess engine in haskell this summer
11:14:26 <lambdabot>   <IO [Char]>
11:14:29 <Twey> Aw, it's just type
11:14:37 <Absolute0> if that works out then i look for a job :)
11:14:42 <mux> Twey: lambdabot doesn't execute code in IO for security reasons :-)
11:14:45 <Twey> *nods* :)
11:14:56 <Twey> mux: I know — I just thought it might do some smart extraction
11:15:03 <mux> that would be cool.
11:15:05 <marcot> Absolute0: tell me if you find a job to work with haskell.
11:15:22 <Absolute0> maybe teaching a haskell course :-P
11:15:35 <Gracenotes> woo! Just finished my concert report... 3 pages... whew
11:15:43 <mux> Twey: there are implementations of restricted/sandboxed IO monads if I'm not mistaken
11:15:52 <mux> they could be used in lambdabot
11:16:01 <glguy> ST?
11:16:23 <Twey> mux: I don't think it's useful enough to bother
11:16:23 <Gracenotes> ST is unnatural o_o but, it's not IO
11:16:35 <mux> isn't ST still a bit broad for lambdabot ?
11:16:42 <[1]dan> does anyone know how i can hal daume, the writer of YAHT?
11:16:44 <mux> Twey: probably not. :-)
11:16:50 <[1]dan> contact
11:16:53 <glguy> Gracenotes, IO and ST about about the same thing
11:17:00 <marcot> Absolute0: I used to think like that when I studied Philosophy...
11:17:10 <Berengal> glguy: No, you can't do IO in ST
11:17:19 <Berengal> That's a pretty big difference
11:17:22 <Gracenotes> glguy: in terms of their impossibility to implement in "normal" Haskell
11:17:25 <mux> IO is just an instance of ST
11:17:34 <Twey> [1]dan: By 'phone, America 801-585-3586, or go to Utah and knock on his door :-P
11:17:35 <mux> or the other way around ST is a generalisation of IO
11:17:36 <glguy> In terms of one being writen in terms of the other
11:17:36 <Gracenotes> and in terms of internals, yeah
11:17:37 <Twey> http://www.cs.utah.edu/~hal/
11:17:42 <Twey> GIYF
11:17:47 <Gracenotes> but IO actions tend to interface, well, in the IO monad
11:17:59 <mux> I think you just need existential types to implement ST
11:18:11 <mux> maybe either FDs or ATs too
11:18:12 <marcot> What's the difference between ST and State?
11:18:21 <Twey> mux: Yeah, but it wouldn't be as fast
11:18:22 <Berengal> No, existential types should be enough
11:18:27 <glguy> one is a restricted IO allowing mutation
11:18:31 <Twey> The key to ST is in magic and secretly-impure optimisations
11:18:34 <Gracenotes> Twey: I'm so disappointed! He uses <table> on his website! (...to represent tabular data)
11:18:41 <[1]dan> does anyone here know Hal? I just want to let him know that he's got an outdated version of YAHT on his site, which is the first result in google search
11:18:50 <Twey> Gracenotes: Using anything but <table> to represent tabular data is an abuse
11:18:55 <MyCatVerbs> You could use WriterT [Char] ST, use a type alias, and then make a pile of actions like putStr = tell.
11:18:56 <Gracenotes> :P
11:19:11 <Absolute0> How can I fix my halve function: http://pastebin.com/fe71c197 ?
11:19:16 <Absolute0> its kind of confusing :)
11:19:22 <Twey> [1]dan: You can also email him at me@hal3.name
11:19:25 <Absolute0> line 9 breaks
11:19:37 <Twey> Er, this channel isn't publically logged, is it?
11:19:38 <Absolute0> i can't get the cons and , to work
11:19:41 <marcot> Ok, I find a message in Haskell on google.
11:19:43 <Twey> Damn
11:19:44 <Twey> It is
11:19:46 <Twey> Sorry Hal
11:19:50 <vixey> It looks wrong
11:19:53 <Gracenotes> Absolute0: splitting [1,2,3,4] into [1,2] and [3,4]?
11:19:59 <Absolute0> Gracenotes: yeah
11:20:12 <[1]dan> Twey: oops
11:20:13 <[1]dan> :)
11:20:17 <Twey> Yeah :(
11:20:18 <mux> what I love is that how it allows you to write perfectly pure code that needs mutation to perform efficiently without even needing unsafePerformIO - runST is way cooler :-P
11:20:26 <mux> *love about ST
11:20:26 <BONUS> halve xs = splitAt (length xs `div` 2) xs
11:20:37 <Gracenotes> Absolute0: in this case, it's not going to have efficient anyway, so may as well take the length and splitAt, as BONUS just did
11:20:39 <Absolute0> I dont want to use any other functions :)
11:20:44 <[1]dan> Twey: I did mail him though. Either he didn't see the email or doesn't care too much about it
11:20:52 <Gracenotes> then implement splitAt on your own
11:20:53 <Twey> [1]dan: He seems busy
11:20:54 <Absolute0> i am learning haskell...
11:20:59 <Twey> I'm sure he'll get to you
11:20:59 <Absolute0> so doing everything from scratch
11:21:00 <glguy> Gracenotes, check out what the difference in ST and IO is: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#unsafeIOToST
11:21:03 <BONUS> yeah, implement your own splitAt
11:21:05 <Absolute0> using splitat is useless
11:21:08 <Gracenotes> glguy: I know :)
11:21:12 <BONUS> > splitAt 3 [1,2,3,4,5]
11:21:14 <lambdabot>   ([1,2,3],[4,5])
11:21:18 <BONUS> why is it useless
11:21:21 <Berengal> Absolute0: You've got the types all wrong
11:21:36 <Absolute0> Can someone try to fix line 9?
11:21:38 <[1]dan> Twey: It's too bad for the haskellers who are just starting to learn haskell
11:21:44 <Absolute0> putting in a comma in the middle doesnt help :)
11:21:57 <Berengal> Absolute0: It's unfixable with the current type and algorithm
11:22:07 <Gracenotes> Absolute0: perhaps I should note... taking the length is not an O(1) operation
11:22:14 <Gracenotes> it takes O(n), because the list is singly linked
11:22:17 <[1]dan> Twey: For example it says in the outdated version that if you exhaust over guards after a successful pattern match, the next pattern isn't checked for a match
11:22:32 <Absolute0> Gracenotes: just want to get it running .
11:23:10 <Gracenotes> in some cases, recursion by pattern matching on a list like (x:xs) is a bad way to do it. Not all, though.
11:23:15 <MyCatVerbs> Absolute0: the easiest way to write mergesort is to (map (:[])), to turn your input list into a list of one-element lists.
11:23:27 <[1]dan> BONUS: So when is the next chapter of LYAH coming? :-)
11:23:30 <Gracenotes> I'm not even quite sure what you want to do here.... hm.
11:23:31 <Absolute0> how do i get this: otherwise = halve ([xi:head xs] , tail xs)
11:23:37 <MyCatVerbs> Absolute0: and then recursively merge adjacent pairs until there's only one element left.
11:23:53 <BONUS> [1]dan: planning on finishing this one in a week or two :) still gonna do a writeup of newtypes, monoids, and foldables
11:24:08 <BONUS> and then it's the monads chapter, which i hope to finish about a month from there
11:24:27 <BONUS> :)
11:24:41 <vixey> >  map return [1,2,4] :: [ Maybe Integer ]
11:24:42 <Berengal> BONUS: You need a drawing of a burrito
11:24:42 <lambdabot>   [Just 1,Just 2,Just 4]
11:24:47 <Berengal> Perhaps even a unicorn
11:24:47 <[1]dan> BONUS: Good luck :)
11:24:54 <vixey> >  map return [1,2,4] :: [ [] Integer ]
11:24:56 <[1]dan> BONUS: Haha
11:24:56 <lambdabot>   [[1],[2],[4]]
11:25:02 <BONUS> Berengal: a unicorn burrito? will do!
11:25:03 <BONUS> haha thanks
11:25:14 <vixey> > map ($())$ map return [1,2,4]
11:25:14 <Berengal> BONUS: Awesome :)
11:25:15 <lambdabot>   [1,2,4]
11:25:45 <Gracenotes> Absolute0: I'm not quite sure what the algorithm does... perhaps you should start again? :\ This isn't a problem you can solve so easily by taking a list element by element
11:25:51 <Berengal> vixey: :O
11:26:01 <jmcarthur> vixey, playing with obfuscation?!
11:26:02 <Berengal> The (->) r monad still amazes me
11:26:04 <BONUS> monads are just like unicorns. at first they don't make sense and then when you start to believe in them, they become useful
11:26:18 <jmcarthur> <3 (->) r monad
11:26:18 <Berengal> BONUS: Ask pumpkin about unicorns ;)
11:26:29 <BONUS> haha will do
11:26:30 <Absolute0> Gracenotes i want take (x:xs) appending x to the left half until left half and xs are of same or close size
11:26:46 <Absolute0> close in case size is odd
11:27:00 <[1]dan> monads are easy, maybe I should write a tutorial!
11:27:01 <jeff_s_> For what mux wrote is there a cleaner way to let ghc know that I want to use ByteString functions instead of String functions? Cleaner than doing "import qualified..." and prefixing all the ByteString functions.
11:27:03 <copumpkin> :o
11:27:21 <copumpkin> BONUS: sry, u stol my analogy
11:27:25 <copumpkin> except my analogy was more anal
11:27:33 <Gracenotes> Absolute0: hm. what left half? In that case, perhaps you want to retrieve the results of the recursive halve call, and then modify it
11:27:37 <BONUS> oh? well i guess its cause it makes sense! :]
11:27:57 <Berengal> At least as much sense as burritos and nuclear waste
11:27:59 <jmcarthur> @quote unicorn
11:27:59 <lambdabot> No quotes match. Maybe you made a typo?
11:28:01 <jmcarthur> @quote unicorns
11:28:01 <lambdabot> No quotes match. There are some things that I just don't know.
11:28:03 <jmcarthur> aw
11:28:04 <Gracenotes> for example, let (left, right) = halve yourarguments in (newLeft, newRight)
11:28:11 <copumpkin> BONUS: I had a good explanation of bind/join, fmap, and return, in terms of unicorns!
11:28:14 <[1]dan> @quote burrito
11:28:15 <lambdabot> No quotes match. Take a stress pill and think things over.
11:28:23 <Gracenotes> I sort of only see this as a dead end... but, then again, I did wake up only an hour ago
11:28:29 <BONUS> haha awesome
11:28:46 <Gracenotes> copumpkin: .. join sounds bloody
11:28:57 <copumpkin> Gracenotes: doesn't have to be
11:29:00 <copumpkin> you just have to be careful
11:29:23 <Berengal> join can be implemented in terms of bind, you just need more unicorns
11:29:45 <Berengal> Actually, I can't envision how join with unicorns would work...
11:29:52 <MyCatVerbs> Unicorn humping.
11:30:09 <copumpkin> well, do you recall how return and fmap worked in unicorns?
11:30:25 <Berengal> Not fmap, no
11:30:45 <copumpkin> fmap is massaging the unicorn's tummy and changing what you um, stuck into the unicorn
11:30:48 <Berengal> Actually, I don't quite get bind either, since there's no way the contents of a unicorn could get out of its horn...
11:30:50 <MyCatVerbs> Skin grafts.
11:30:52 <copumpkin> while leaving it in the unicorn
11:30:54 <[1]dan> hmm, a question for you guys: How can I see from within ghci which modules are importable?
11:31:08 <MyCatVerbs> fmap is where you change what the unicorn has tattoo'd on its bum.
11:31:10 <vixey> what is it unicorns are supposed to be symbolic of again?
11:31:17 <copumpkin> monads!
11:31:24 <jmcarthur> [1]dan, :m <tab key>
11:31:27 <copumpkin> return in unicorns needs lots of lube
11:31:27 <jmcarthur> :D
11:31:50 <copumpkin> and in that situation, join involves sticking an entire unicorn into another one
11:31:55 <copumpkin> and it becomes just one unicorn!
11:32:02 <flipRight> > 1 + 3
11:32:03 <lambdabot>   4
11:32:06 <MyCatVerbs> copumpkin: unicorn humping, totally.
11:32:15 <copumpkin> very deep humpage though
11:32:20 <flipRight> > join (Just [[]])
11:32:21 <lambdabot>   Couldn't match expected type `Maybe' against inferred type `[]'
11:32:29 <vixey> Unicorns are not found in Greek mythology
11:32:32 <copumpkin> and the humpage produces a single unicorn
11:32:33 <Berengal> copumpkin: Doesn't really explain why you can't just remove the outer unicorn though, or why the unicorn can digest other unicorns, but nothing else
11:32:33 <flipRight> > join (Just $ Just 5))
11:32:33 <flipRight> > join (Just $ Just 5)
11:32:35 <lambdabot>   <no location info>: parse error on input `)'
11:32:36 <lambdabot>   Just 5
11:32:37 <vixey> didn't know that
11:32:56 <vixey> ddo you think unicorns are real?
11:33:04 <[1]dan> jmcarthur: Doesn't work on windows :(
11:33:07 <copumpkin> Berengal: well, there are different subspecies of unicorns, and only those can be joined (a bit like viability of mating)
11:33:30 <copumpkin> Berengal: and if you remove the outer unicorn you're a murderer!
11:33:45 <Berengal> copumpkin: I have a feeling your analogy just isn't anal enough. Needs less eating references
11:33:55 <copumpkin> I didn't say eating
11:33:58 <copumpkin> I said it needed lots of lube
11:34:00 <jmcarthur> [1]dan, try hitting tab twice?
11:34:03 <Berengal> Ah
11:34:07 <copumpkin> :)
11:34:17 <[1]dan> jmcarthur: nope
11:34:18 <Berengal> And of course, unicorns are magical
11:34:24 <jmcarthur> [1]dan, i don't know, maybe the line editor / whatever is different on windows :(
11:34:40 <lament> monads can only be tamed by virgins?
11:34:53 <[1]dan> anyone knows if there's a chance of getting haskell to autocomplete stuff on windows?
11:34:56 <copumpkin> :)
11:34:59 <[1]dan> ghci that is
11:36:01 <mux> [1]dan: are you using 6.10.3? it's much easier to have it working with 6.10.3 because there is now a pure haskell module for handling line editing (haskeline) vs libedit/libreadline
11:36:10 <Berengal> I must admitt I understand monads better than I understand the unicorn analogy...
11:36:44 <[1]dan> mux: I d/ld it but haven't installed it yet, once i have it running to i need anything to make the autocomplete work?
11:36:59 <mux> [1]dan: nope
11:37:08 <mux> it Just Works (tm)
11:37:19 <koeien> is there something like ByteString for Word64's ?
11:37:22 <[1]dan> mux: wonderul, trying it now
11:37:26 <koeien> any library / approach that you'd recommend?
11:37:32 <[1]dan> mux: thanks a lot
11:37:35 <jmcarthur> i just read this analogy to my coworker who doesn't know haskell
11:37:40 <mux> [1]dan: you're welcome
11:37:43 <jmcarthur> he... thinks #haskell is crazy
11:38:05 <flipRight> why is concat not = join?
11:38:14 <flipRight> or why does concat exist?
11:38:25 <koeien> flipRight: join is something different (from monads/category theory)
11:38:27 <flipRight> > (join . join) [[[]]]
11:38:27 <glguy> concat just has a more specific type
11:38:28 <lambdabot>   []
11:38:32 <jmcarthur> concat is one of the joins
11:38:40 <vixey>  flipRight: concat = join is only true for one instace of monad
11:38:45 <glguy> you get less confusing error if you use concat when a function on lists was what you had in mind
11:38:45 <flipRight> > pure []
11:38:47 <lambdabot>       Ambiguous occurrence `pure'
11:38:47 <lambdabot>      It could refer to either `Control.Appl...
11:38:48 <dolio> flipRight: The Haskell98 committee thought the type of join would scare students.
11:39:05 <flipRight> > pure 5
11:39:06 <lambdabot>       Ambiguous occurrence `pure'
11:39:07 <lambdabot>      It could refer to either `Control.Appl...
11:39:09 <flipRight> oh
11:39:09 <Berengal> dolio: They were probably right
11:39:18 <flipRight> how can i use pure?
11:39:19 <flipRight> here
11:39:29 <glguy> qualify it
11:39:31 <Asztal> > Control.Applicative.pure 5
11:39:31 <Berengal> > Control.Applicative.pure 5 :: Maybe Int
11:39:32 <lambdabot>       No instance for (Show (f t))
11:39:32 <lambdabot>        arising from a use of `show' at <in...
11:39:33 <lambdabot>   Just 5
11:39:37 <Asztal> :(
11:39:41 <tetha> http://nopaste.ns-linux.org/?NWIyMz <- any glaring improvements visible in my first program in a long time? :)
11:40:04 <Asztal> > return 5
11:40:05 <lambdabot>       No instance for (Show (m t))
11:40:05 <lambdabot>        arising from a use of `show' at <in...
11:40:33 <hellige> i know this is a terrible question, and i don't want to start a war, but...
11:40:53 <hellige> if i want to use just ONE frp library to do non-gui related stream processing, which one should i pick?
11:40:55 <MyCatVerbs> hellige: don't worry, nobody else likes liverwurst either.
11:41:00 <hellige> MyCatVerbs: ;)
11:41:22 <ski> "Although we have omitted to elaborate on this, the axioms introduced here, namely those of a tabular allegory that has a unit and power objects, precisely constitute the definition of a *topos*." !
11:41:35 <MyCatVerbs> Oh. Dunno, I get the impression that not enough people are using them for that to be a good way to start a flame war yet.
11:41:52 <vixey> tetha, yes a few
11:41:55 <hellige> MyCatVerbs: haha. i just know that there are several, and that there doesn't seem to be any concensus
11:42:00 <camio> hellige: The one that has few enough bugs that I know of is yampa.
11:42:04 <hellige> MyCatVerbs: oops, consensus.
11:42:20 <hellige> camio: yeah i was wondering about yampa. it's one of the oldest, yeah?
11:42:31 <camio> hellige: But you may find yourself missing features of the buggy, but more elegant ones, like reactive.
11:42:44 <camio> hellige: Erm, not that old really.
11:43:23 <hellige> camio: well, i mean old in a good sense: seems like it's been around since early 2000s.
11:43:34 <ski> tetha : `s /= ""' should be `not (null s)'
11:43:39 <camio> hellige: Yeah, it's stable.
11:43:42 <hellige> camio: anyway, yeah, the problem is, i'm just not sure how to tell which features i actually need.
11:43:50 * mux needs to haddock-ize his sysctl module before uploading it on hackage
11:44:04 <ski> .. or at least that feels better, to me
11:44:08 <camio> hellige: Then stick with Yampa. It's fun to work with reactive until you run into a "not implemented yet" thing.
11:44:22 <hellige> camio: ok, i'll give yampa a shot.
11:44:44 <tetha> ski: I agree about not (null s) feeling better
11:44:44 <hellige> if it changes anything, virtually all of my streams are discrete.
11:44:51 <hellige> i'm not sure i need any continuous behaviors at all.
11:45:45 <ski> tetha : `readTree' might be done with a `State String' monad
11:45:58 <ski> though maybe that's overkill here ..
11:46:36 <Philippa> evenin'
11:46:44 <ski> (similarly `postfix',`postfix_intern' might be done with an output/writer monad)
11:46:50 <tetha> ah, I will take a look at it. little exercises with monads are a good thing
11:47:22 <ski> evening, Philippa
11:47:25 <ehird> @hoogle [a] -> a -> Int
11:47:26 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:47:26 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
11:47:26 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:47:31 <wli> moin
11:47:45 <MyCatVerbs> > ('a' : ) . undefined $ []
11:47:46 <lambdabot>   "a* Exception: Prelude.undefined
11:47:55 * Philippa looks at the ICFP accepted papers list and regrets that she's not going
11:48:10 <vixey> what happens at ICFP?
11:48:41 <MyCatVerbs> Lots of functional programmers packed into small rooms doing exotic things.
11:48:49 <MyCatVerbs> Research talks, mostly. ;P
11:49:08 <vixey> have you ever gone
11:52:52 * Philippa hasn't - but can at least nominally afford to this yer
11:52:54 <Philippa> *year
11:53:17 <Philippa> in reality, I can't without feeling distinctly annoyed about the money - especially after the whole mess with my now-housemate and now my PC dying...
11:54:06 <osfameron> how much does icfp cost?
11:54:28 <Philippa> don't think they've announced it yet - I was expecting accomodation to cost me more, tbh
11:54:47 <osfameron> yeah... I get to stay with parents as it's in Ed ;-)
11:54:58 <Philippa> *nod*. You should go, then!
11:55:31 <Philippa> unfortunately, the person I know best in Edinburgh isn't someone I should ask to put me up a week
11:56:37 <MyCatVerbs> vixey: no, I was guessing.
11:56:43 <ehird> !hoogle [a] -> [a] -> Maybe Int
11:56:48 <ehird> @hoogle [a] -> [a] -> Maybe Int
11:56:48 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:56:49 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
11:56:49 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
11:56:51 <ehird> hmm
11:56:57 <ehird> no elemIndex for substrings?
11:57:51 <ehird> :\
11:58:27 <Hunner> Is there a way to grab the a for (a -> b)? say to use in "func (a->b) = elements::[a]"?
11:58:31 <jeff_s_> if I have something of type [ByteString], and I want a prefix of it, I can use Prelude.takeWhile right?
11:58:46 <Hunner> "show elements::[a]"*
11:59:15 <MyCatVerbs> > (\substring -> fix (\r l -> case l of { [] -> Nothing; (a:as) -> if isPrefixOf substring l then Just 0 else fmap (+1) $ r as; } )) "foo" "barbazfooknuckles"
11:59:16 <lambdabot>   Just 6
11:59:18 <mux> Hunner: you need ScopedTypeVariables
11:59:25 <mux> Hunner: and then you need an explicit forall
12:00:13 <flipLeft> would haskell be good for flickr?
12:00:25 <flipLeft> is there a highperformance webserver writen in haskell?
12:00:38 <Zao> happstack?
12:00:45 <jeff_s_> never mind, I got it working!
12:07:50 <hatds> does this describe a named typeclass?  func :: a -> t b -> t a
12:08:19 <hatds> ah wait nvm, that's not what I've got
12:11:43 <jmcarthur> hatds, that does exist though
12:11:49 <jmcarthur> :t (<$)
12:11:50 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:11:54 <hatds> nah, it's trivial
12:12:14 <hatds> it just puts the same value 'a' everywhere
12:12:29 <jmcarthur> well, depending on the exact functor
12:13:32 <hatds> hmm.. in any case what I have is really just Int -> f b -> f Int
12:13:38 <jmcarthur> > '?' <$ "Hello, world!"
12:13:40 <lambdabot>   "?????????????"
12:13:43 <hatds> maps Ints over the data structure, but ignoring what was there before
12:14:10 <jmcarthur> > 5 <$ "Hello, world!"
12:14:11 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5]
12:14:13 <hatds> other than the shape of the strucute
12:15:18 <jmcarthur> > ("foo" <$ (+1)) 5
12:15:19 <lambdabot>   "foo"
12:15:43 <jmcarthur> > ("foo" <$ (+1)) undefined
12:15:44 <lambdabot>   "foo"
12:15:49 <danra> > "foo" <$ "bar"
12:15:50 <lambdabot>   ["foo","foo","foo"]
12:16:26 <danra> > 'o' <$ "bar"
12:16:28 <lambdabot>   "ooo"
12:16:46 <JoshTriplett> Does any module have a function which will perform a bit-scan forward or bit-scan reverse, ideally compiling into the single x86 instruction bsf or bsr on Intel processors?
12:17:08 <cpriester> what is a bitscan?
12:17:08 <wli> No.
12:17:30 <wli> Nor popcount / Hamming weight.
12:17:32 <cpriester> there no such x86-instruction.
12:17:44 <cpriester> popcount is implementing with lookups in menory
12:17:48 <cpriester> ..ed
12:18:29 <Asztal> BSR is one instruction, though not a particularly fast one
12:18:31 <cpriester> You could reimplement it using data.bits
12:19:18 <cpriester> Ah, cool. I didnt know
12:19:37 <JoshTriplett> Asztal: Fast compared to implementing it in software...
12:21:27 <gnuvince> @src (<**>)
12:21:28 <lambdabot> (<**>) = liftA2 (flip ($))
12:22:04 <gnuvince> @src (<*)
12:22:05 <lambdabot> (<*) = liftA2 const
12:22:10 <gnuvince> @src (*>)
12:22:11 <lambdabot> (*>) = liftA2 (const id)
12:22:16 <skorpan> @src liftA2
12:22:16 <lambdabot> liftA2 f a b = f <$> a <*> b
12:22:30 <skorpan> @src liftA
12:22:30 <lambdabot> liftA f a = pure f <*> a
12:22:41 <skorpan> @src (<$>)
12:22:41 <lambdabot> f <$> a = fmap f a
12:22:50 <skorpan> is liftA == (<$>)=
12:22:51 <skorpan> ?
12:23:23 <flipLeft> > map ord [1..10]
12:23:24 <lambdabot>       No instance for (Num Char)
12:23:24 <lambdabot>        arising from the literal `1' at <inte...
12:23:28 <vixey> :t liftA
12:23:30 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
12:23:49 <flipLeft> > map chr [1..10]
12:23:51 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n"
12:25:25 <hatds> lambdabot's gone quackers
12:26:04 <skorpan> vixey: so are they identical?
12:27:24 <hatds> I believe so
12:31:35 <vegai> @hoogle HtmlString
12:31:35 <lambdabot> Text.XHtml.Strict stringToHtmlString :: String -> String
12:31:49 <vegai> ah, where the bugger is that thing
12:32:03 <vixey>  When you are feeling strange, type @yow.
12:33:19 <vegai> garks, it's hidden in Text.XHtml.Internals
12:34:51 <vegai>  Happstack.Helpers.HtmlOutput.Common
12:34:54 <vegai> gotcha!
12:35:39 <vegai> I've got this weird impulse of importing everything meticulously
12:35:54 <mux> @pl \_ x -> return x
12:35:54 <lambdabot> const return
12:36:40 <glguy> vegai, when it is feasible, I like doing very specific imports so that people reading my code later will be able to figure out where functions came from
12:37:08 <vegai> indeed
12:42:16 <hatds> I want a text editor feature that will automatically shrink my imports and aguess how to enlarge my imports as the identifies in my file change
12:42:26 <hatds> *identifiers
12:42:56 <flipRight> > map id [1..10]
12:42:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:43:10 <fracture> why does the emacs haskell-mode place where clauses in a way contrary to recommendations in real world haskell :(
12:43:12 <flipRight> > map const [1..10]
12:43:13 <lambdabot>       Overlapping instances for Show (b -> a)
12:43:13 <lambdabot>        arising from a use of `s...
12:44:11 <flipRight> > map (const 5) [1..10]
12:44:12 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
12:44:13 <flipRight> > map (`const` 5) [1..10]
12:44:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:44:44 <flipRight> > map (\x->if odd x then x `const` 5 else 1) [1..10]
12:44:45 <lambdabot>   [1,1,3,1,5,1,7,1,9,1]
12:45:13 <roconnor> > [1..10] >> [5]
12:45:14 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
12:45:35 <roconnor> [5|_<-[1..10]]
12:45:39 <roconnor> > [5|_<-[1..10]]
12:45:40 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
12:45:56 <Lemmih> dcoutts_: Should we create an unstable-unstable branch of cabal-install?
12:50:00 <flipRight> > replicate 5 10
12:50:02 <lambdabot>   [10,10,10,10,10]
12:50:05 <flipRight> > replicateM 5 10
12:50:06 <lambdabot>       No instance for (Show (m [a]))
12:50:06 <lambdabot>        arising from a use of `show' at <...
12:50:13 <flipRight> @type replicate
12:50:14 <lambdabot> forall a. Int -> a -> [a]
12:50:28 <flipRight> @type replicateM
12:50:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:50:35 <Cale> > replicateM 5 [0,1]
12:50:37 <lambdabot>   [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0...
12:50:39 <flipRight> > a <- replicateM 5 10; return a
12:50:40 <lambdabot>   <no location info>: parse error on input `<-'
12:51:04 <flipRight> > a <- replicateM 2 [0,1]
12:51:05 <lambdabot>   <no location info>: parse error on input `<-'
12:51:09 <flipRight> > replicateM 2 [0,1]
12:51:10 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
12:51:16 <flipRight> cool
12:51:19 <flipRight> > replicateM 2 [0,1,0]
12:51:21 <lambdabot>   [[0,0],[0,1],[0,0],[1,0],[1,1],[1,0],[0,0],[0,1],[0,0]]
12:52:45 <flipRight> > replicateM 3 [0,1,0]
12:52:46 <lambdabot>   [[0,0,0],[0,0,1],[0,0,0],[0,1,0],[0,1,1],[0,1,0],[0,0,0],[0,0,1],[0,0,0],[1...
12:52:47 <flipRight> > replicateM 1 [0,1,0]
12:52:48 <lambdabot>   [[0],[1],[0]]
12:53:34 <flipRight> @type mapM
12:53:34 <flipRight> @src mapM
12:53:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:53:35 <lambdabot> mapM f as = sequence (map f as)
12:54:03 <flipRight> @type sequence
12:54:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:55:47 <Berengal> > filterM (const [True, False]) [1,2,3]
12:55:49 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:57:27 <Berengal> I can't for the life of me figure out what this thing I'm doing is called...
12:57:27 <roconnor> > filterM (sequence [odd, even]) [1,2,3]
12:57:28 <lambdabot>   [[1,3],[1],[1,2,3],[1,2],[3],[],[2,3],[2]]
12:57:41 <roconnor> Berengal: programming?
12:58:25 <Berengal> roconnor: I've got a list of values, which I fold into a monotonically increasing list
12:59:00 <roconnor> Berengal: merging?
12:59:05 <roconnor> hmm
12:59:14 <roconnor> I guess if values isn't sorted, then it isn't merging
12:59:36 <Berengal> No, they aren't sorted, so I'm dropping the ones who would cause an increase
12:59:56 <hatds> left to right maxima?
12:59:57 <mauke> [1,10,2,3,4,6,5] ==> ?
13:00:08 <Berengal> mauke: [1]
13:00:12 <mauke> :-(
13:00:15 <Berengal> no, wiat
13:00:21 <Berengal> I'm tired...
13:00:30 <Berengal> [1,2,3,4,6]
13:00:46 <Berengal> There's also indexes
13:00:57 <hatds> why not [1,10]?
13:01:07 <Berengal> Because 2 is lower than 10
13:01:11 <hatds> oh
13:01:32 <mauke> [1,10,11,12,2,3] ==> ?
13:01:42 <hatds> [1,2,3]?
13:02:01 <Berengal> Assuming you fold from the left, keeping a stack as an accumulator. Each element of the list is always kept on the stack, which means you have to drop all elements with a higher value than the current one
13:02:45 <Berengal> mauke: Yes, [1,2,3] as hatds said
13:03:00 <mauke> huh
13:03:11 <hatds> so you reading the values 1,2,3,4,5,6 (wherever they appear) ... and dropping any that occur to the left of a previous element?
13:03:59 <hatds> viewing a list as a permutation, you are removing inversions
13:04:50 <hatds> http://en.wikipedia.org/wiki/Permutation_group#Transpositions.2C_simple_transpositions.2C_inversions_and_sorting
13:04:57 <Berengal> Now, assuming the values are temperatures (indexed by year), after you've processed the temperatures [1900..2009] you could pop the top value (which is the temperature for 2009) and get the last year with a temperature less than this year
13:05:50 <Berengal> I'd show you my code, but it's hackish and fugly...
13:07:20 <Berengal> Or I could ignore that and show you anyway: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4904#a4904
13:07:44 <vixey> > type Stack = [NumberPair]
13:07:44 <vixey> We need to create some number pairs from a list of numbers
13:07:44 <vixey> > numberPairs :: [Int] -> [NumberPair]
13:07:46 <lambdabot>   <no location info>: parse error on input `type'
13:07:46 <lambdabot>   Not in scope: `numberPairs'    Not in scope: type constructor or class `Num...
13:07:52 <vixey> why did you just define it an not use it
13:08:21 <Botje> numberpairs look suspiciously like regular pairs ;)
13:08:47 <flipRight> @type sequence
13:08:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:08:50 <flipRight> @src mapM
13:08:51 <lambdabot> mapM f as = sequence (map f as)
13:09:01 <Berengal> vixey: I assumed I needed it and couldn't think of anything else to code just then. I assumed correctly and it unclogged my brain ;)
13:09:25 <cmcq> > [ h | l@(h:_) <- init . tails $ [1,10,2,3,4,6,5], h == minimum l ]
13:09:26 <lambdabot>   [1,2,3,4,5]
13:09:35 <Berengal> Botje: They are just regular pairs. They're also central to the algorithm. I like giving central things names
13:10:17 <hatds> do your lists have repetitions?
13:10:51 <Berengal> hatds: As in equal values?
13:10:55 <hatds> yea
13:11:17 <Berengal> Yes. I could probably drop them though, it shouldn't make any difference
13:12:25 <mux> @pl \x y -> return (f y x)
13:12:25 <lambdabot> (return .) . flip f
13:13:00 <vixey> :t flip ((return .) . f)
13:13:02 <lambdabot> forall b (m :: * -> *) a a1. (SimpleReflect.FromExpr b, Show a, Show a1, Monad m) => a -> a1 -> m b
13:13:19 <Berengal> O_o
13:13:27 <Berengal> :t f
13:13:27 <vixey> :t \f -> flip ((return .) . f)
13:13:28 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:13:29 <lambdabot> forall b (m :: * -> *) a a1. (Monad m) => (a1 -> a -> b) -> a -> a1 -> m b
13:14:06 <Berengal> Anyway, the clue is in the nextStack function
13:14:24 <Berengal> It builds up a list. That kind of list has a special name. I can't remember it
13:16:40 <cmcq> longest increasing subsequence?
13:17:08 <Berengal> It's not a subsequence
13:17:20 <cmcq> ok, and it's not the longest
13:17:29 <Berengal> No, it's the only
13:19:20 <Berengal> Using this algorithm you can figure out things like 'today was the hottest day since <foo>, and before that <bar> was even hotter' in O(n) time
13:21:23 <cmcq> ok, or if the list was the height of mountain ranges, it says which peaks you would see from the end?
13:21:48 <Berengal> Yes, that's a very good example
13:21:59 <Gracenotes> ... or is it? :o
13:22:27 <Gracenotes> indeed it is >_>
13:22:39 <Berengal> Assuming there's no such thing as angles or distance and everything is at ground level...
13:23:06 <Gracenotes> > nubBy (>) [1, 2, 4, 6, 7, 4, 2, 6, 1]
13:23:08 <lambdabot>   [1,2,4,6,7]
13:23:11 <Berengal> But such assumptions come naturally to us of the more theoretical persuation
13:23:30 <Gracenotes> of course, this miscalculates things like [1, 2, 1, 3, 5]
13:24:05 <Gracenotes> wait... or does it?
13:24:16 <Gracenotes> > nubBy (>) [1, 2, 1, 3, 5, 7, 4]
13:24:17 <lambdabot>   [1,2,3,5,7]
13:24:18 <Berengal> > nubBy (>) [1,2,1,3,5]
13:24:19 <lambdabot>   [1,2,3,5]
13:24:34 <Berengal> It should've been [1,1,3,5]
13:24:56 <hellige> anybody here know yampa?
13:25:03 <Gracenotes> hm? Well, I guess the mountain analogy isn't complete, then
13:25:14 * Gracenotes thought of the nubBy based on that
13:25:26 <Berengal> Of course, the list of mountain ranges has to be inverted. It's monotonically decreasing
13:25:46 <Berengal> Assuming you're standing at the end of the list of course
13:27:49 <Berengal> > nubBy (<) [5,3,1,2,1] -- <_< ← this is you watching the mountains. Numbers are height in km
13:27:50 <lambdabot>   [5,3,1,1]
13:28:07 <Berengal> Hmm, didn't quite work...
13:28:50 <Berengal> nubBy won't work, even for mountain ranges
13:29:40 <vixey> what
13:33:30 <glguy> > let nubBy _ [] = []; nubBy eq (x:xs) = x : nubBy eq (dropWhile (eq x) xs) in nubBy (<) [5,3,1,2,1]
13:33:31 <lambdabot>   [5,3,1,1]
13:33:39 <roconnor> ``It is useful to define gcd(0, 0) = 0 and lcm(0, 0) = 0 because then the natural numbers become a complete distributive lattice with gcd as meet and lcm as join operation. This extension of the definition is also compatible with the generalization for commutative rings
13:33:42 <glguy> you'd want one that compared adjacent elements
13:34:03 <vixey> > gcd 0 0
13:34:05 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
13:35:09 <trofi> :t lcm
13:35:10 <lambdabot> forall a. (Integral a) => a -> a -> a
13:35:19 <trofi> > lcm 0 0
13:35:21 <lambdabot>   0
13:35:26 <Berengal> glguy: You want to drop any previous values that would invalidate the monotonicity
13:35:35 <roconnor> I can't even believe it is controversial that gcd 0 0 = 0
13:35:57 <roconnor> it totally meets the specification of gcd
13:36:03 <Berengal> roconnor: Well, it's "controversial" that .9.. == 1...
13:36:17 <Gracenotes> glguy: right... nubBy is ill-defined for operators that aren't commutative
13:36:30 <Gracenotes> well, it's well-defined, but it it's quirky
13:36:34 <mauke> gcd 0 0 is clearly Infinity
13:36:51 <Taejo> Gracenotes: is it well-defined?
13:37:08 <vixey> the spec is gcd x y = k <=>  greatest k such that there exists i,j s.t. x = k*i /\ y = k*j
13:37:12 <vixey> ?
13:37:13 <Gracenotes> Taejo: for individual implementations anyway, although I'm not sure it's specified
13:37:19 <Berengal> Taejo: Yes, it's just not a good definition
13:37:22 <Gracenotes> mauke: indeed :) all numbers are divisors of zero, and so the greatest one is Infinity
13:37:34 <roconnor> vixey: the spec is that the gcd is a cd, and that every other cd divides the gcd.
13:37:34 <vixey> so 0 is the greatest k s.t.  0 = k*i = k*j ?
13:37:41 <seliopou> infinity is not an integer
13:37:53 <Gracenotes> an arbitrary high value hen
13:37:54 <Gracenotes> then
13:38:02 <seliopou> there's only one higher
13:38:22 <Taejo> gcd 0 0 is undefined then
13:38:23 <glguy> > ceiling (1/0) :: Integer -- sure it is :)
13:38:23 <Gracenotes> no, it's more arbitrarily high than that one :)
13:38:24 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
13:38:25 <seliopou> (my point is I'm pretty sure the right thing to say is that it's not defined)
13:38:27 <vixey> every other cd divides the gcd is better than greatest
13:38:43 <vixey> how does that 'divide's work for 0 though?
13:38:50 <Gracenotes> Berengal: although, the current definition of nubBy is rather efficient as it stands.
13:38:58 <roconnor> vixey: same as usual.
13:38:58 <hatds> Berengal: does this do what you want    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4904#a4906
13:39:04 <Taejo> OTOH, if you define gcd 0 0 = 0, you get a lattice
13:39:23 <Gracenotes> Berengal: making it consider pairs of elements would be inefficient for simple commutative things like ==
13:39:38 <Gracenotes> maybe there should be a separate function, who knows.
13:39:52 <Taejo> @src nubBy
13:39:52 <lambdabot> nubBy eq []             =  []
13:39:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:39:56 <Berengal> Gracenotes: Of course. It's a good definition for associative function, just not for others
13:40:15 <Berengal> functions*
13:40:33 <Gracenotes> at the moment it's necessarily inefficient as it stands, not that suitable for large inputs
13:40:35 <Taejo> > nubBy (>) [1, 2, 5, 2, 3]
13:40:37 <lambdabot>   [1,2,5]
13:40:50 <Taejo> > nubBy (>) [1, 2, 5, 2, 3, 7, 3]
13:40:52 <lambdabot>   [1,2,5,7]
13:41:03 <Taejo> > nubBy (<) [1, 2, 5, 2, 3, 7, 3]
13:41:05 <lambdabot>   [1]
13:41:39 <Berengal> hatds: Looks like it, but it has worse complexity
13:41:40 <roconnor> Taejo: It's not that you get a lattice, although that is true, it's that 0 *is* the gcd of 0 and 0 in that it is the unique number that divides 0 and every number that divides 0 also divides it.
13:42:01 <lament> 0 divides 0?
13:42:08 <wh1t3> > 0 div 0
13:42:09 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> a1))
13:42:09 <lambdabot>        arising from th...
13:42:10 <lament> uncontroversially?
13:42:11 <roconnor> lament: yes
13:42:19 <wh1t3> opps
13:42:23 <lament> roconnor: that's not uncontroversial. That's controversial.
13:42:24 <wh1t3> > 0 `div` 0
13:42:26 <lambdabot>   * Exception: divide by zero
13:42:31 <roconnor> lament: it divides 0 in many ways.
13:42:36 <Berengal> hatds: Yours is O(n^2) while mine is O(n)
13:42:40 <ehird> Is there a better way to construct a bytestring as you go than snoccing all the time? Kind of slow.
13:42:50 <hatds> Berengal: I see
13:42:51 <roconnor> everything divides 0.
13:43:07 <tromp> there's no reason not to define gcd(0,0)==0
13:43:22 <hatds> 0 is the unique generator of the ideal (0,0)
13:43:26 <vixey> <roconnor> everything divides 0.
13:43:28 <hatds> :)
13:43:53 <vixey> @remember <roconnor> everything divides 0.
13:43:53 <lambdabot> Done.
13:43:53 <hatds> and in general gcd(a,b) is the unique generator of (a,b)
13:43:56 <hatds> er, up to sign
13:44:00 <Taejo> roconnor: fair enough, but gcd isn't a good name
13:44:02 <sjanssen> ehird: you definitely don't want to snoc
13:44:06 <Botje> \\\
13:44:07 <Botje> A
13:44:08 <Botje> A
13:44:09 <Botje> A
13:44:10 <Botje> A
13:44:11 <ehird> sjanssen: Indeed.
13:44:11 <sjanssen> that's O(n) time and allocation
13:44:13 <Botje> A
13:44:14 --- mode: ChanServ set +o mauke
13:44:17 <ehird> sjanssen: So how should I do it?
13:44:21 <sjanssen> ehird: unfoldr?  Or use Data.Binary
13:44:32 <mauke> gcd 0 0 = product [1..]
13:44:37 <roconnor> Taejo: Greatest in the divisability order.
13:44:41 <Botje> oops, sorry guys :[
13:44:50 <ehird> sjanssen: Unfoldr cannot work; I need to peek at more than one element at a time.
13:44:56 <ehird> Specifically, in one case, I need to look at the next element.
13:45:06 <Botje> wrong window was highlighted when i was rubbing my keyboard
13:45:15 --- mode: mauke set -o mauke
13:45:31 <sjanssen> ehird: look at?
13:45:46 <ehird> sjanssen: That is, I need to consider more than one element at once to make the decision of what to emit.
13:46:22 <sjanssen> ehird: you can still do that with unfoldr, it just isn't particularly convenient
13:46:25 <Taejo> roconnor: fair 'nuf
13:46:31 <ehird> sjanssen: Oh? How?
13:46:35 <sjanssen> ehird: Data.Binary might be a good option, it's more flexible
13:46:46 <ehird> sjanssen: Also, I'm transforming a bytestring into a bytestring.
13:46:58 <ehird> (Invariant: The result is always less than or equal to the length of the input.)
13:47:09 <ehird> Also, Data.Binary is a serialization thing...
13:47:12 <ehird> Am I wrong?
13:47:27 <sjanssen> ehird: it provides a Monoid/Monad to efficiently construct lazy ByteStrings
13:47:33 <glguy> Data.Binary is a bytestring creation and a bytestring consuming thing
13:47:39 <roconnor> I wonder if there is a haskell' ticket ...
13:47:46 <ehird> sjanssen: Don't want lazy.
13:48:07 <sjanssen> ehird: you could always just pack a lazy list
13:48:19 <sjanssen> that will be a little bit better than snoc
13:48:20 <ehird> No, I really couldn't :-)
13:48:25 <sjanssen> why not?
13:48:34 <gqs> say I have some fiels named cold.blah cold.blah1
13:48:38 <ehird> This operation can be done at C-speed; it's really trivial
13:48:48 <gqs> how do i rename them hot.blah hot.blah1
13:49:02 <ehird> I'm just going through the elements, occasionally looking one beyond, and appending at most one character per iteration.
13:49:11 <gqs> and from what I hear haskell works nicely on 4 cpu?
13:49:23 <sjanssen> ehird: you've currently got O(n^2), packing a list is 100% less dumb
13:49:30 <ehird> i've currently got nothign
13:49:32 <ehird> *nothing
13:50:02 <sjanssen> so with unfoldr you have to code your function as a little state machine
13:51:04 <skorpan> was dons the starter of the yi project?
13:51:10 <dons> yeah
13:51:16 <skorpan> oh, nice, you're here
13:51:28 <dons> i wrote yi 0.1, then handed it over to jean-phillipe
13:51:35 <skorpan> i'm writing my thesis report and i'd like some information from you, if you have time?
13:51:45 <sjanssen> ehird: if you're really concerned about C speed, make a ForeignPtr and write to that
13:51:45 <dons> certainly
13:51:58 <ehird> sjanssen: I'm not concerned about C speed so much as C efficiency.
13:51:59 <dons> skorpan: if they're detailed, email might be better.
13:52:11 <skorpan> dons: i'll send you an e-mail then, thanks
13:52:16 <skorpan> answer me when you feel you have the time
13:52:19 <ehird> This thing is O(n) in the length of the input string, and I'd use B.unfoldr except I need to consider more than 1 element at once
13:52:51 <dons> skorpan: k.
13:53:42 <cmcq> was Yi really faster than vim? It seems a lot slower for basic editing operations
13:55:22 <dons> yi 0.1
13:55:29 <dons> was /very/ different to yi 0.4 or so.
13:55:40 <dons> yes, it was a lot faster, since that's exactly what i optimized it for :)
13:55:53 <dons> you can still download it. i should release it as 'yi-classic' or something
13:55:57 <skorpan> i can't imagine vim being slow :P
13:56:31 <cmcq> I'd be interested in a yi-classic - I'm not sure the dynamic loading stuff still exists in Yi
13:56:49 <dons> uses ghc-api now, affaik
13:56:56 <ehird> sjanssen: I see no fancy monad in Data.Binary...
13:57:05 <ehird> for constructing bytestrings
13:57:10 <sjanssen> ehird: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4907#a4907 is an example with lists, demonstrating outputting either 0 or 2 elements at a time
13:57:16 <sjanssen> ehird: Data.Binary.Put
13:57:22 <ehird> hmmm
13:57:41 <sjanssen> as you can see, inconvenient, but possible
13:57:47 <ehird> OK, then. Data.Binary.Put it is.
13:57:52 <ehird> Ugly, imperative, but it'll work.
13:57:58 <sjanssen> I think maybe somebody cloned Data.Binary for strict ByteStrings
13:58:02 <sjanssen> dons: do you recall?
14:00:06 <seydar> I LOVE HASKELL
14:00:10 <seydar> i mean
14:00:11 <seydar> hey
14:00:17 <skorpan> HASKELL YEAAAAAHHHHHH
14:00:32 * byorgey high-fives seydar
14:00:35 <ehird> http://hackage.haskell.org/packages/archive/binary-strict/0.1/doc/html/Data-Binary-Strict-Put.html
14:00:36 <ehird> huray
14:00:39 <ehird> er
14:00:46 * Berengal rocks out to some haskell code being piped to /dev/snd
14:00:46 <ehird> that'll teach me to hack urls
14:00:58 <roconnor> @src gcd
14:00:58 <ehird> http://hackage.haskell.org/packages/archive/binary-strict/latest/doc/html/
14:00:58 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
14:00:58 <lambdabot> gcd x y = gcd' (abs x) (abs y)
14:00:58 <lambdabot>    where gcd' a 0  =  a
14:00:58 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
14:01:17 <vixey> > 0 `rem` 4
14:01:19 <roconnor> Hmm, coq has a fast binary GCD algorithm.
14:01:22 <lambdabot>   0
14:01:32 <vixey> yeah just remove line
14:01:35 <vixey> 1
14:01:43 <ehird> sjanssen: seems to not have Put.
14:02:20 <roconnor> I wonder if a binary GCD algorithm would speed up the gcd in Haskell
14:02:26 <dons> sjanssen: yeah, binary-strict
14:02:41 <roconnor> not that I can really trust @src to tell me what GHC does
14:03:01 <roconnor> @src lcm
14:03:01 <lambdabot> lcm _ 0     =  0
14:03:01 <lambdabot> lcm 0 _     =  0
14:03:01 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
14:03:25 <sjanssen> ehird, dons: ah, deserialisation only
14:03:35 <sjanssen> sad, Put is the more useful bit
14:03:41 <opqdonut> roconnor: binary in the sense that it uses the bit representation?
14:03:49 <opqdonut> or in a "binary search" sense
14:04:10 <roconnor> opqdonut: binary in that it does odd /even analysis and division by 2.
14:04:17 <roconnor> so ya, in bit represenation
14:04:54 <dons> sjanssen: because we already have parser combinators for wire protocols?
14:04:57 <seydar> what's the nick of the drug addict who wrote learn you a haskell?
14:04:58 <roconnor> It's much faster in Coq, but coq doesn't use machine integers.
14:05:00 <dons> while binary ppr is less studied?
14:05:06 <seydar> and i mean that in the best possible way
14:05:08 <dons> seydar: BONUS
14:05:35 <dons> we prefer "creative individual" when referring to The Oracle.
14:05:43 <seydar> BONUS: ping
14:05:52 <byorgey> @remember seydar what's the nick of the drug addict who wrote learn you a haskell? and i mean that in the best possible way.
14:05:52 <lambdabot> Okay.
14:05:58 <Berengal> We have an oracle?
14:06:20 <bremner> Oracle bought us
14:06:31 <sjanssen> dons: I suppose a strict Put would do something like concatting the results of lazy Put in the end anyway
14:06:32 <bremner> oh, wait, that was Sun
14:06:36 <byorgey> Berengal: yes, a halting oracle
14:06:55 <lament> soon they'll buy the rest of the solar system
14:06:58 <byorgey> you give BONUS a function as input, and he will tell you whether he will get tired of trying to decide whether it halts or not
14:07:05 <Berengal> byorgey: Ah :( I was hoping for the premonitient virgin kind...
14:07:39 <Gracenotes> ?? -> ? -> *
14:07:39 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:07:45 <Gracenotes> :.
14:07:47 <dons> more in the sense of "visionary" imo :)
14:07:51 <byorgey> Berengal: well, I don't know BONUS that well.
14:08:07 <Berengal> byorgey: Me neither. It could still be true
14:08:41 <Gracenotes> hm. what's the most complicated kind anyone knows of in the commonly used libraries?
14:08:45 <Berengal> Halting oracles are common-place in haskell though. GHC can run some infinite loops in a matter of microseconds
14:08:51 <opqdonut> :kind StateT
14:08:53 <mauke> @kind ContT
14:08:56 <lambdabot> * -> (* -> *) -> * -> *
14:08:59 <Gracenotes> yes, ContT is my current candidate
14:09:06 <vixey> :k StateT
14:09:07 <MyCatVerbs> Gracenotes: ListT is screwier.
14:09:07 <lambdabot> * -> (* -> *) -> * -> *
14:09:11 <vixey> :k RWST
14:09:11 <MyCatVerbs> :k ListT
14:09:13 <lambdabot> Not in scope: type constructor or class `ListT'
14:09:13 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:09:17 <Gracenotes> ooh, even better
14:09:22 <Gracenotes> read writer state trans
14:09:24 <opqdonut> not really, same nesting level
14:09:33 <Gracenotes> well. yes. more params though.
14:09:40 <seydar> bos was right in his quote in May 2's HWN -- crummy languages DO give static typing a bad name. in short, haskell has made me want to do some unholy things with this newfound power
14:09:42 <Gracenotes> hm.
14:10:15 <MyCatVerbs> seydar: if you're ever wondering precisely what to do with it all, have a look at a few of Oleg's papers.
14:10:23 <ehird> sjanssen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4907 doesn't help. That's producing more than one element.
14:10:27 <ehird> I want to consume more than one element
14:10:34 <Gracenotes> MyCatVerbs: the MLIst?
14:10:35 <Gracenotes> i
14:10:42 <MyCatVerbs> seydar: Turns out that you can do more than you might expect with less than you might think. :)
14:12:19 <seydar> MyCatVerbs: look, i just want to finish my homework so i can get down and dirty with this pretty little girl i call haskell
14:12:37 <Gracenotes> use protection
14:13:04 <mauke> magical math girl hasukeru
14:13:17 <Gracenotes> haskell-san
14:13:25 <mauke> chan
14:13:30 <Gracenotes> oh. right.
14:16:50 <seydar> what happens if i have two data records with the same fields?
14:17:25 <hatds> you regret using records in the first place and go back to ADTs?
14:18:23 <seydar> hatds: should i be avoiding records?
14:18:58 <bremner> aren't records just syntactic sugar for ADTs? I don't understand hatds' comment.
14:18:58 <Twey> seydar: Compilation errors
14:19:23 <Twey> You can a) prefix them or b) put them in a separate namespace (module)
14:19:57 <Twey> Personally I think the latter solution is far neater
14:20:05 <Twey> But some people dislike having too many files
14:20:10 <ehird> sjanssen: are you sure it's possible to look one ahead with unfoldr?
14:20:13 <skorpan> i believe there's an extension allowing the same name for multiple datatypes?
14:20:24 <Twey> skorpan: There is?
14:20:41 <Twey> It's kind of integral to Haskell's record system
14:20:43 <skorpan> Twey: i think someone told me there is, but of course it doesn't make much sense since then you'd face having multiple declarations of two functions...
14:20:58 <Twey> There have been a few other proposals, but I don't think there's ever been an implementation
14:21:06 <Twey> skorpan: Well, no, you could theoretically do it with typeclasses
14:21:06 <skorpan> maybe i'm mistaken
14:21:13 <hatds> records are just sugar for ADTs, but the sugar is mostly trying to fool you into thinking they are like virtual functions
14:21:17 <Twey> I even saw a proposal for that
14:21:25 <skorpan> hatds: but they *are* functions
14:21:28 <Twey> But I didn't think it got implemented
14:21:41 <hatds> skorpan: but not overloaded in any sense
14:21:46 <seydar> ok Twey you might be able to help me with this problem. How do i do this with Data.Binary: "\001\002\376\375".unpack("s*") # => [513, -514]
14:21:49 * roconnor wishes record field labels created Accessors instead of projections.
14:22:02 <Twey> seydar: I don't speak Perl
14:22:10 <hatds> man, you won't believe this but
14:22:29 <Botje> it's ruby :p
14:22:33 <smorg> lambdabot is sexy but looks bored http://www.haskell.org/sitewiki/images/1/13/Lambdabot.png
14:22:39 <Twey> Botje: Your point?  :-P
14:22:53 <hatds> I just changed my GUI design to all ADTs with no "Widget" typeclass and no monolithic ADT containing every GUI element,   and I think it is going to work 10 times better
14:23:19 <hatds> you'd think you would want a function like draw :: Gui a => a -> IO ()
14:23:28 <Twey> Ew, drool :-P
14:23:30 <hatds> or draw :: Gui -> IO ()
14:23:38 <hatds> but they just wreck the design
14:23:45 <skorpan> hatds: so what did you do?
14:24:09 <hatds> simple, you have different types for different Widgets, with functions like   drawListBox
14:24:35 * seydar fades for din din
14:24:47 <skorpan> hatds: why is it better?
14:25:17 <Twey> seydar: You're not going to translate?  Mmkay...
14:25:36 <pumpkin> omg it's seydar
14:25:37 <glguy> seydar, you'd use getWord16host
14:25:41 <hatds> because you don't want every "draw" function to have the same types of arguments
14:26:04 <hatds> and you don't want to force it to by cramming the extra parameters into the widgets themselves
14:26:05 <glguy> seydar, and you have to use it repeatedly, checking for the end of the buffer
14:26:48 <glguy> seydar, so...  getWord16s = do e <-  isEmpty ; if e then return [] else liftM2 (:) getWord16host getWord16s
14:27:42 <roconnor> hatds: have you studied GuiTV?
14:27:50 <hatds> roconnor: no
14:28:27 <Gracenotes> ooh. apparently Wolfram|Alpha will launch tonight at 8 PM
14:28:34 <mgsloan> !!!
14:28:43 <mgsloan> Wolfram's an asshole, but alpha does look interesting
14:28:45 <Gracenotes> EST
14:29:07 <Gracenotes> and thus follow the stream of blogposts. and twitters. and overloaded servers.
14:29:12 <Twey> Hahaha
14:29:25 <mgsloan> so like 11pm on the good coast?
14:29:54 <bmh> howdy.
14:29:58 <Gracenotes> check your maths, grasshopper!
14:30:25 <vixey> <mgsloan> Wolfram's an asshole, but alpha does look interesting
14:30:30 <vixey> mgsloan: you're an asshole
14:30:39 <opqdonut> hehe
14:30:41 <vixey> go read Hello! magazine
14:30:45 <mauke> w
14:30:47 <Gracenotes> I only seduced him for his webapp!
14:31:02 <MyCatVerbs> mauke:  22:30:36 up  8:12,  5 users,  load average: 0.05, 0.12, 0.15
14:31:07 <mgsloan> vixey: lol.  I'm just kidding about the coast thing
14:31:11 <Twey> Mmm, I make that about three in the morning on the good coast
14:31:13 <bmh> Regardless of what you think of Wolfram, I think it's indisputable that Mathematica is a wretched language.
14:31:20 <mgsloan> at least I don't write a thousand page book about the ideas of others
14:31:24 <vixey> mgsloan: did ya hear that Katie and <can't remember his name> broke up!! omg I was like shuure
14:31:37 <mgsloan> bmh: really?  It is fairly expressive
14:31:40 <MyCatVerbs> bmh: regardless of what you think of Mathematica, at least it is not Matlab.
14:31:41 <Twey> Katie?
14:31:44 * Twey laughs.
14:31:48 <bmh> MyCatVerbs: fair
14:31:55 * mgsloan is confused
14:32:16 <bmh> mgsloan: My gripes are primarily syntactic
14:32:39 <bmh> I've been adrift in a sea of Mathematica, R and Matlab for the past few weeks. It's good to be back to Haskell.
14:32:47 <mgsloan> gotcha
14:32:51 <lament> Alpha is broken unless it answers every question about Haskell with "Yes! Haskell can do that."
14:33:12 <mgsloan> well before immersion in like a month or two of haskell I had tons of syntactic gripes
14:33:21 <mgsloan> until I figured out _why_ it was that way
14:34:07 <osfameron> hmmm, DRMcIver "We're just going to have to lump "functional" along with "closure" and "dsl" as perfectly useful terms which programmers have managed to beat to death through misuse." <-- from http://www.reddit.com/r/programming/comments/8kphh/a_problem_of_language_response_to_scala_is_not_a/
14:34:20 <osfameron> I thought closures were fairly well understood?
14:34:31 <glguy> because you spend a lot of time in #haskell?
14:34:41 <osfameron> or is he referring to the corruption of closure as "first class function" ?
14:34:58 <MyCatVerbs> osfameron: IMO, "closure" is a term that has already been beaten to death by programmers.
14:35:35 <MyCatVerbs> osfameron: it is supposed to denote a mathematical operation whose domain is contained entirely within its range, dammit! ;D
14:35:59 <osfameron> Am I misunderstanding?  A closure is a reference to a function that has "closed over" variables in its original lexical scope.
14:36:20 <inimino> the programming and algebra use of "closure" are the same
14:36:34 <MyCatVerbs> No, you understand perfectly, it's just that there are two different meanings.
14:36:35 <inimino> despite the fact that nobody seems to notice this
14:37:09 <MyCatVerbs> In programming we have these things called "closures" over lexical and sometimes even free variables.
14:37:27 * inimino should blog about it
14:37:48 <Gracenotes> hmmmm... I don't even think closures are necessarily functional programming constructs. But they can be used nicely with first class functions, though
14:38:05 <Gracenotes> could be wrong
14:38:23 <MyCatVerbs> In mathematics "closure" is the property of an operation that can be applied to its own output. For instance, lists are closed under (++) because the output is always another list, and arrows in a category are closed under composition because you always get another arrow out.
14:38:25 <osfameron> glguy: btw, my understanding of closures comes from Perl not #haskell (Perl has perfectly cromulent closures, to the surprise of, well, um, mostly everyone)
14:38:48 <glguy> osfameron, I just mean that you might not have been exposed to a representative audience :)
14:38:54 <MyCatVerbs> osfameron: and to lwall's surprise more than anyone else's. :)
14:38:58 <osfameron> hehehe
14:39:07 <Gracenotes> well, historically I'd be wrong; closures have referred almost entirely to first class functions with lexical scope
14:39:24 <MyCatVerbs> inimino: I can't say I see any connection there whatsoever, so please do. If I'm wrong about it, I'd like to be enlightened.
14:39:36 <osfameron> actually, DrHyde talked about closures the London Perl Workshop in November - I was surprised 'cos I thought people would find it noddy, but apparently it went down well.
14:40:12 <osfameron> (so $deity knows what they made of my monads talk which kinda assumed that as a basis ;-)
14:40:15 <MyCatVerbs> osfameron: I would bet that they were all just thinking "Well, that sounds pretty convenient. Yay."
14:40:28 <mauke> perl also has tail calls :-)
14:40:32 * Gracenotes needs to implement a functional programming language
14:40:52 <osfameron> mauke: huh?
14:41:03 <vixey> Gracenotes: which one??!!
14:41:05 <osfameron> mauke: I thought "has tail calls" meant "has *useful* tail calls" i.e. optimized ones ?
14:41:11 <mauke> yep
14:41:20 <osfameron> mauke: it doesn't do TCO
14:41:24 <inimino> MyCatVerbs: from the Wikipedia article http://en.wikipedia.org/wiki/Closure_%28mathematics%29
14:41:25 <Gracenotes> vixey: an brand new one, of course1!1!
14:41:28 <osfameron> or am Imisunderstanding you?
14:41:33 <mauke> osfameron: no, but the programmer can
14:41:39 <mauke> goto &func;
14:41:46 <osfameron> mauke: ah...
14:41:58 <osfameron> mauke: funnily enough that's slower than not doing it
14:42:00 <inimino> "When a set S is not closed under some operations, one can usually find the smallest set containing S that is closed. This smallest closed set is called the closure of S (with respect to these operations)."
14:42:02 <MyCatVerbs> inimino: *checks* there's nothing new in there to me, you'll have to explain it more closely.
14:42:06 <osfameron> mauke: though it does prevent your stack from getting blown I suppose
14:42:18 <vixey> Gracenotes: Will it be called LISP?
14:42:28 * mauke looks at http://mauke.ath.cx/stuff/perl/add.pl
14:42:28 <MyCatVerbs> inimino: because I still can't see anything in there tying the programmer's notion of lexical closures to the mathematical notion of closed operations.
14:42:30 <Gracenotes> probably not
14:43:00 <inimino> MyCatVerbs: take a chunk of code, find all the variables in it, close this set under the operation of reference-following, and you have what a programmer calls a closure
14:43:07 <osfameron> so... was DRMcIver complaining about programmers abusing the original algebraic term do you think?
14:43:13 <osfameron> seems an odd complaint
14:43:22 <MyCatVerbs> osfameron: no, not at all. *I* was. :)
14:43:36 <MyCatVerbs> osfameron: and SICP's authors do at one point, IIRC.
14:43:39 <gqs> meaning size in ram over time on cpu?
14:44:00 <inimino> MyCatVerbs: I think this is not widely recognized, as even SICP complains about it in a footnote
14:44:36 <hatds> but how are you comparing the programming term and the algebra term?  By treating programming functions as maps from their inputs to their outputs?
14:44:46 <MyCatVerbs> inimino: yeah, that's the first time I've heard it explained that way. Nice.
14:45:00 <inimino> hatds: no.
14:45:02 <inimino> MyCatVerbs: maybe I actually will blog about it ;-)
14:45:09 <MyCatVerbs> hatds: no, inimino is just saying that the programming term is just a special case of the mathematical term.
14:45:29 <MyCatVerbs> inimino: hang on, isn't the closure of an operation the *largest* closed set under that operation, not the smallest?
14:45:56 <MyCatVerbs> Otherwise doesn't make sense to me. Surely the empty set is closed under *every* operation, no?
14:46:05 <mauke> superset
14:46:31 <inimino> MyCatVerbs: the closure of a given set under an operation, is the smallest superset that is closed under that operation
14:46:39 <osfameron> mauke: interesting - I don't get what that's doing... will have to study when brain less fuzzy...
14:46:49 <MyCatVerbs> Ah, right, I see.
14:46:52 <mauke> osfameron: why, it adds two numbers
14:47:19 <osfameron> mauke: I guessed as much ;-)
14:47:27 <mauke> if you can actually figure out the control flow just from reading the source, I will praise your aura
14:47:29 <MyCatVerbs> Was confused because Wikipedia lists this backwards - referring to the set closed over as the subset rather than the closure as a superset.
14:47:47 <osfameron> mauke: the indentation vaguely suggests a manual Id monad
14:48:09 <osfameron> mauke: but I suspect my aura won't be praised in this case... I'll play with it in interpreter when I get a sec
15:07:50 * seydar returns from the dead
15:13:10 <lament> does anyone here play backgammon?
15:13:25 <gqs> I play wow
15:13:32 <gqs> I stink so gets lots advice
15:13:34 <gqs> :)
15:13:35 <lament> almost, but not quite
15:13:44 <gqs> i play with ghc
15:13:51 <gqs> but am better at wow
15:13:53 <gqs> :)
15:14:08 <gqs> can haskell be used to do shel scripting? or is it pretty bad with files
15:14:23 <Twey> gqs: It can, but it's not ideal for it
15:14:34 <Twey> There's a library, HSH, to make it easier
15:14:37 <lament> it's certainly not designed for it, while other things are
15:14:40 <mauke> gavino? is that you again?
15:14:50 <Twey> But frankly, a strongly-typed language wouldn't be my best choice for a throwaway script
15:15:05 <Twey> Maybe if it's going to be around for a while.
15:15:15 <dons> the problem is the art of knowing you're going to throw it away
15:15:21 <Twey> Heh, aye
15:15:33 <vixey> Yeah because strong types get in the way of programming, Writing in a dynamic language is essential if you just want to get the job done
15:15:40 <ehird> Anyone know how I could rewrite http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4908 to operate on strict ByteStrings? Preferably efficiently.
15:15:40 <vixey> ^^^^^ bullshit I read on reddit
15:15:49 <ehird> vixey: people are stupid
15:15:57 <vixey> lol
15:15:58 <Twey> vixey: It's mostly bullshit, aye
15:16:07 <Twey> But not entirely
15:16:19 <Twey> Strong types make you pay attention to your program and its correctness
15:16:23 <vixey> SO: If you just write normal haskell (don't spend half you time writing type signatures) does it take longer than 'dynamir language' -- no
15:16:29 <Twey> Which isn't a setback for any serious program, where you want to be doing so anyway, of course
15:16:32 <vixey> do you spend more time thinking about correctness.... no ....
15:16:57 <lament> vixey: sure it takes longer, you still need to write certain conversions
15:17:03 <vixey> 3 + "potato" giving a compiler error doesn't slow me down when I'm writing a script to sort a folder full of filer
15:17:05 <vixey> files*
15:17:06 * Twey nods.
15:17:06 <lament> that you otherwise wouldn't
15:17:15 <lament> e.g. between pure and IO values
15:17:16 <mm_freak_> is it reasonable to use String for on the fly-processing (e.g. parsing) and ByteString for storage (in a Map or whatever)?
15:17:35 <vixey> Writing monadic style programs is 'slower' than direct style programs
15:17:35 <vixey> ?
15:17:39 <MyCatVerbs> vixey: instance (Enum a) => Num [a] where... might give you pause. :)
15:17:40 <Twey> mm_freak_: Strings are slow
15:17:50 <Twey> mm_freak_: That would be reasonable if you don't care too much about speed
15:18:10 <vixey> well explains why Ocaml wins the race I guess (but I wouldn't find it any difference personally)
15:18:13 <mm_freak_> Twey: AFAIS they're only slow if they are really strings, but i'm having things in mind, where those get fusioned away
15:18:58 <mm_freak_> ByteStrings are fast, but they are painful to use in their current state =/
15:19:00 <Twey> mm_freak_: If you're sure they'll get optimised away, maybe
15:19:13 <Twey> I suspect they always will be
15:19:20 <Twey> That's what you get for going low-level
15:19:27 <mm_freak_> in fact my only problem is that there is no ByteString parser
15:19:42 <Twey> Really?  I thought Parsec worked on ByteStrings
15:19:54 <Twey> Ah, it's in here
15:19:54 <mm_freak_> i don't consider ByteStrings low-level, it's just that still most things work with Strings
15:19:56 <MyCatVerbs> Twey: GHC doesn't do warm fusion. AFAIK the only list fusion you will get at the moment is based on RULES pragmas for combinators like foldr.
15:19:57 <Twey> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-ByteString.html
15:20:52 <mm_freak_> Twey: wonderful!
15:20:57 <Twey> mm_freak_: Looks like you just need to import Text.Parsec.ByteString, and then you're good to go
15:21:04 <MyCatVerbs> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3022327 <- specifies how much you can count on to have lists fused away.
15:21:05 <mm_freak_> i'll give it a shot, thanks
15:21:18 <mm_freak_> it's not in GHC's base libs, unless i'm overlooking it
15:21:27 <mm_freak_> ah, it's parsec 3
15:21:39 <Twey> What comes with GHC these days?
15:21:57 <Twey> Don't we have parsec-3  bundled now?
15:22:00 <mm_freak_> parsec 2, apparently
15:22:11 <mm_freak_> % ghc --version
15:22:11 <mm_freak_> The Glorious Glasgow Haskell Compilation System, version 6.10.1
15:22:14 <Twey> Huh
15:22:22 <Twey> Yeah, I don't have it either, on my 6.10.3
15:22:28 <Twey> Well, you'll just have to install it
15:22:31 <ehird> Anyone know how I could rewrite http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4908 to operate on strict ByteStrings? Preferably efficiently.
15:22:39 <mm_freak_> it's already installed
15:22:47 <mm_freak_> seems like some other package needs it anyway
15:23:30 <mm_freak_> how do i express in cabal's Build-depends that parsec must be at least 3?
15:23:55 <dcoutts> mm_freak_: build-depends: parsec >= 3
15:24:03 <mm_freak_> ty
15:24:07 <dcoutts> simple :-)
15:27:01 <mm_freak_> i don't even need to import it
15:27:07 <mm_freak_> that does it: import Text.Parsec
15:29:26 <glguy> does fgl have any support for an inductive graph definition? (defining the starting node and the neighbor function)
15:33:31 <gqs> mauke are you there
15:33:39 <mauke> yes
15:34:03 <gavino> what did I do to offend you again? perhaps I may apologize
15:34:05 <mm_freak_> i was wrong…  importing Text.Parsec.ByteString is necessary
15:34:13 <mauke> gavino: you joined this channel
15:34:23 <mauke> well, and you started talking
15:34:30 <vixey> don't be daft mauke
15:34:36 <gavino> aren't you in the wrong channel
15:34:39 <mauke> vixey: hmm?
15:35:06 <glguy> this is a good topic for a /msg
15:35:22 <vixey> mauke: letting certain irc channels brand people as trolls and merrily following along just like how bulying works in high school
15:35:56 <mauke> I am not an IRC channel
15:36:03 <vixey> @quote recursion
15:36:03 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
15:36:03 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
15:36:03 <lambdabot> still
15:37:21 * Twey laughs.
15:42:26 <PetRat> Having an issue I don't understand about the Maybe constructor. See here : http://www.mibbit.com/pb/68mnPM
15:42:49 <mauke> PetRat: there is no Maybe constructor
15:42:52 <glguy> Maybe is a type constructor
15:42:54 <glguy> Just is a data constructor
15:43:24 <PetRat> Ah... okay it works now.
15:43:32 <vixey> data MovieReview = MovieReview {
15:43:34 <vixey> this line
15:43:46 <vixey> change it to:
15:43:46 <vixey> data MovieReviewX = MovieReviewY {
15:43:54 <vixey> now the difference is clearer
15:44:01 <adamvo> > data Foo a = Maybe a -- could have fooled me
15:44:02 <lambdabot>   <no location info>: parse error on input `data'
15:44:09 <osfameron> mauke: hehe, I like goto &{sub{...
15:44:21 <PetRat> I see. MovieReviewX is the name of a type. MovieReviewY is the constructor.
15:44:43 <hatds> you are allowed (and it is common) to use the same type name as constructor name
15:44:51 <PetRat> Are constructors considered to be functions? Equivalent in every way?
15:45:01 <vixey> constructorsr are functions
15:45:03 <adamvo> ?type Just
15:45:05 <lambdabot> forall a. a -> Maybe a
15:45:19 <lament> ?type Nothing
15:45:20 <lambdabot> forall a. Maybe a
15:45:20 <hatds> the only special property is that you can pattern match on constructors
15:46:26 <Gracenotes> PetRat: they are functions... and, interestingly, like any other function they can be hidden when you export a module. So it's possible to force one way to create an object
15:46:55 <Gracenotes> (and hiding a constructor also means you can't pattern match on it) But that's to do with the module system...
15:46:59 <PetRat> So you can pass constructors around as functions. I don't think you can use the "named field" notation out of context, thought: http://www.mibbit.com/pb/UX5D7L
15:47:11 <hatds> also, I suppose, normal functions "evaluate" things whereas constructors just sort of throw up mask over the values
15:47:55 <adamvo> I find it a smaller burden to name the only constructor of a datatype the same as the type. Is that why people do that?
15:48:20 <PetRat> If you pass a constructor as a function, apparently you can only call it with positional arguments. Is that true? It would be one difficulty in protecting against change.
15:48:44 <hatds> that can't really be avoided for any function
15:49:40 <PetRat> So does Haskell have anything equivalent to named arguments, optional arguments a la Python?
15:49:48 <hatds> pattern matching
15:49:59 <Gracenotes> PetRat: in addition, application of constructors is generally binding immediately
15:50:17 <lament> PetRat: not really.
15:50:34 <glguy> PetRat, you can simulate them by taking a record
15:50:36 <mauke> PetRat: http://okmij.org/ftp/Haskell/types.html#keyword-args
15:50:51 <glguy> f defaultArgs { someArg = 10 }
15:50:52 <hatds> (in my highly opinionated view) I think this is the best way to deal with "named arguments":
15:51:23 <Gracenotes> so if you have.. let cons = (:) in 1 `cons` [], the entire function call will be in memory, but with 1:[], it will be considered just [1]
15:51:32 <Gracenotes> as far as I know
15:51:55 <adamvo> cons may be inlined
15:52:13 <hatds> data MovieReview = MovieReview  String String String... and then in every function that takes just one MovieReview as a parameter conventionally force yourself to always bind it to the following   (MovieReview  title user review)
15:52:19 <Gracenotes> yes, that'd do it. a separate feature
16:00:50 <sjanssen>  /lastlog sjanssen
16:01:00 <sjanssen> don't mind me :)
16:02:18 <MyCatVerbs> ehird: Damn your function! Damn your function to Hell!
16:02:29 <ehird> MyCatVerbs: W...whut
16:02:32 <dfeuer> damn function
16:02:44 <MyCatVerbs> ehird: trying to write it in terms of foldr is driving me up the wall. My brain isn't working for some reason. x_x
16:02:49 <ehird> MyCatVerbs: >:)
16:13:16 <Cale> MyCatVerbs: What function?
16:18:51 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4908
16:20:25 <glguy> what is it supposed to do?
16:20:47 <MyCatVerbs> Splits a path into the part before the first / and the part after, with backslash escaping.
16:20:50 <ehird> Not a path!
16:20:53 <ehird> But, yes.
16:21:02 <ehird> Strip a string to the first /, with \s escaping the next character.
16:21:12 <ehird> And the goal is s/String/ByteString/
16:21:34 <glguy> strip to the first non escaped /?
16:21:42 <ehird> glguy: Yes, but also replace \x with x.
16:22:09 <mauke> my ($fst, $snd) = m{^((?:[^\\/]|\\.)*)/(.*)\z}s; $fst =~ s/\\(.)/$1/sg;
16:22:22 <idnar> aaaahhhh!
16:22:28 <ehird> mauke: congrats, you just rewrote oerjan's implementation
16:25:47 <glguy> ehird, the goal was to keep both ends before and after the /?
16:25:55 <ehird> glguy: Hum?
16:26:02 <glguy> a/b -> (a,b)
16:26:04 <glguy> or
16:26:07 <glguy> a/b -> a
16:26:08 <glguy> a/b -> b
16:26:14 <ehird> It turns ab\/cd\\\/aa/ccccc into ab/cd\/aa
16:26:30 <ehird> Ah, wait.
16:26:33 <ehird> glguy: yes
16:26:33 <ehird> (a,b)
16:26:36 <ehird> I forgot I changed that
16:26:58 <ehird> It turns ab\/cd\\\/aa/ccccc\/aaa into ab/cd\/aa , ccccc\/aaa
16:27:05 <ehird> the second return value is sent raw.
16:27:14 <ehird> The behaviour is correct as is in the code; I just can't get a bytestring version.
16:30:06 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4908#a4915
16:30:19 <glguy> that's without returning the remainder at least
16:30:37 <ehird> ah, that's pretty close
16:30:45 <ehird> glguy: those index calls though...
16:30:48 <glguy> with some indexing redundancy that  would fall out into a where clause
16:30:48 <ehird> hmm
16:30:50 <ehird> I guess they're fine
16:30:52 <ehird> what about the length one?
16:30:56 <ehird> do bytestrings store length?
16:30:59 <glguy> length on bytestring is stored
16:31:10 <glguy> but that could be pulled out too
16:31:12 <ehird> that's almost perfect then :-)
16:31:31 <glguy> you had to add a check in the trailing \ case
16:31:48 <glguy> and after you do that, you can safely switch to unsafeIndex
16:31:57 <ehird> right
16:31:57 <glguy> if performance is a concern
16:32:04 <ehird> trailing \ = no parse
16:37:21 <cognominal> is there a equivalent to succ for Enums that wraps to the first element when given the last?
16:37:49 <mauke> :t \x -> if x == maxBound then minBound else succ x
16:37:50 <lambdabot> forall a. (Enum a, Eq a, Bounded a) => a -> a
16:39:32 <cognominal> thx
16:49:15 <mux> yay
16:49:48 * mux retrieves the process list via his Sysctl haskell module
16:50:20 <dancor_> ooooh
16:51:49 <Zao> mux: Highly unportable, I assume?
16:51:50 <mux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4917#a4917
16:51:57 <adamvo> @hoogle Handle
16:51:58 <lambdabot> System.IO data Handle
16:51:58 <lambdabot> Control.Exception handle :: (Exception -> IO a) -> IO a -> IO a
16:51:58 <lambdabot> Control.Exception handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
16:52:02 <Zao> Indeed.
16:52:04 <mux> it may work on both FreeBSD and NetBSD
16:52:18 <mux> it'll work on OpenBSD when I handle them not having a by-name lookup
16:53:28 <mux> sysctl is more or less BSD only by nature
16:53:40 <mux> well, Linux has sysctl's too, I don't know if the API is compatible
16:56:24 <cads> hey, I remember reading a post where someone showed how to use a monad to factor out the common code to calculating the distribution of a random variable, and also for calculating the expectation of the random variable taking a certain set of values
16:57:49 <MyCatVerbs> mux: how are you calling sysctl? Via the userland program or the syscall?
16:57:59 <cads> I don't remember the exact detail of how he did that, though
16:58:39 <cads> I was wondering if you guys knew what the monad was called in haskell, the article's code was in ruby
16:59:06 <cads> I don't remember the exact punchline of how it worked :D
16:59:08 <MyCatVerbs> cads: sounds like a probability monad.
16:59:35 <MyCatVerbs> mux: apparently the syscall is considered deprecated in Linux, and the userland utility just does filesystem operations in /proc and /sys. :/
17:00:46 <vixey> does anyone hove the time in CST?
17:00:54 <cads> hehe, well obviously, a probability monad.. hehe, I should have thought of that
17:01:06 <cads> vixey, it'd be like 7?
17:01:09 <MyCatVerbs> cads: http://www.randomhacks.net/articles/2007/10/02/probability-monads-at-hac-07-ii sounds most useful. AFAIK the probability monad is roughly the list monad with numbers attached to every item.
17:01:17 <vixey> hmf
17:01:22 <vixey> thans
17:01:24 <vixey> thanks
17:01:48 <roconnor> that's 7 pm CT, which is currentlyin CDT.
17:01:49 <mux> MyCatVerbs: via the syscall
17:02:09 <cads> MyCatVerbs: hey, yeah, that's all a probability distribution is anyways
17:02:19 <mux> MyCatVerbs: which is why I'm using Storable instances to fetch structs
17:03:07 <MyCatVerbs> mux: I haven't looked at your code, but is that safe? I didn't think the structs' exact layouts were specified, except as "this struct will have at least these members...".
17:03:40 <mux> MyCatVerbs: it is entirely up to the caller to provide correct instances
17:03:47 <mux> but it is safe
17:03:48 <MyCatVerbs> Oh, I'm sorry, there are no structs in sysctl(3)'s interface.
17:04:04 <mux> not on the surface
17:04:18 <mux> FreeBSD has format strings embedded in special calls
17:04:32 <mux> it would have given S,kinfo_proc for the process sysctl for instance
17:05:16 <cads> MyCatVerbs: I can see how we could raise a random variable into a structure that would encapsulate the distribution and expectation functions, but I'm not sure what that structure would compose if it were to be a monad
17:05:39 <MyCatVerbs> cads: do you mean "comprise" rather than "compose"?
17:06:05 <mux> MyCatVerbs: the hpaste link was only a demo program's code and output, btw
17:06:25 <cads> a monad's got to be able to compose monadic values somehow :D
17:06:56 <centrinia> Haskell can be used to make a Quake 3 engine. :O
17:08:54 <MyCatVerbs> newtype Prob a = Prob [(a,Float)], instance Monad Prob where { return a = [(a,1)]; m >>= f = normalise (concatMap f) where normalise l = map (/(sum (map fst l))) l; } -- would be my first guess.
17:09:35 <gavino> centrinia: would it run decently fast?
17:09:54 <MyCatVerbs> Er, snd, not fst.
17:10:12 <roconnor> @faq can Haskell be used to make a Quake 3 engine?
17:10:12 <lambdabot> The answer is: Yes! Haskell can do that.
17:11:48 <centrinia> gavino, It gets about 60 frames per second on my 2.0GHz Athlon 64 system with a Geforce 7900 GS card.
17:12:14 <centrinia> Here: http://www.haskell.org/haskellwiki/Frag
17:12:50 <cads> MyCatVerbs: so the monadic value in that case is a list of values and their probabilities?
17:13:02 <mib_v7b5e2> greetings
17:13:11 <QtPlaty[HireMe]> Hi
17:18:42 <cads> MyCatVerbs: thanks for the link, I'm reading it now
17:19:01 <cads> it makes sense that there would be a few different kinds of probability monad
17:19:44 <mib_v7b5e2> you guys know what rocks?
17:19:57 <cads> paper scissors rock!
17:19:57 <opqdonut> stones?
17:19:59 <mib_v7b5e2> haskell
17:20:04 <mib_v7b5e2> haskell rocks
17:20:09 <MyCatVerbs> mib_v7b5e2: Bohemian Rhapsody.
17:20:10 <mib_v7b5e2> i'm sorry for seeming like a fanboy
17:20:35 <vixey> Bohemian Rhapsody!
17:20:36 <roconnor> @faq Does Haskell rock?
17:20:36 <lambdabot> The answer is: Yes! Haskell can do that.
17:20:54 <cads> hey, what's the job market like for haskell coders?
17:20:55 <mib_v7b5e2> but it's true. haskell is teh 1337h4x
17:20:57 <Baughn_> ..it can also, on occasion, not rock.
17:22:53 <mib_v7b5e2> yargh, what's the job market like for haskell coders?
17:23:33 <roconnor> @. elite faq Does Haskell rock?
17:23:33 <lambdabot> Th3 AN$WER Is: yez! h45kE1L C4N Do +|-|A7.
17:24:00 <MyCatVerbs> @.elite tell roconnor Some plugins should not be composed.
17:24:00 <lambdabot> +3|L Ro(OnNOr s0ME plUGINz0rz sHoU|d NO7 b3 (Omp0SeD.
17:24:01 <roconnor> ah, the elite faq, with all the elite answers at hand.
17:24:06 <mib_v7b5e2> @faq Does P=NP?
17:24:06 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:13 <mib_v7b5e2> interesting
17:24:36 <dolio> @faq How many roads must a man walk down?
17:24:36 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:43 <Elly> hm
17:24:50 <Elly> so haskell can prove P = NP...
17:24:54 <roconnor> @what love
17:24:55 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
17:25:04 <Gracenotes> baby don't hurt me
17:25:08 <gavino> no more!
17:25:16 <gavino> de de de de de de de de
17:25:23 <opqdonut> gavino: has one more "don't hurt me" before "no more" :)
17:25:42 <dolio> That's the wrong article, if that's the joke.
17:25:44 <gavino> ^-;
17:26:27 * Gracenotes NP: What is Love?
17:26:35 <Gracenotes> oooooh.
17:27:00 <mib_v7b5e2> you guys hear about the guy who supposedly found a near linear way to factor any number?
17:27:16 <mib_v7b5e2> http://eurocrypt2009rump.cr.yp.to/e074d37e10ad1ad227200ea7ba36cf73.pdf
17:27:18 <Gracenotes> Shor's theorem? that's n^3 in the number of bits
17:27:25 <vixey> mib_v7b5e2: what's the punchline?
17:27:36 <ali_clark> @src map
17:27:36 <lambdabot> map _ []     = []
17:27:37 <lambdabot> map f (x:xs) = f x : map f xs
17:27:45 <Gracenotes> the standard for factoring algorithms is the number of bits, not the actual number
17:27:57 <dolio> vixey: He's a crackpot. Badum-pish.
17:27:58 <Gracenotes> in case that's the, er, punchline
17:28:14 <vixey> haha
17:28:48 <mib_v7b5e2> Gracenotes: point is, if his method works (it's under peer review right now), then RSA might be moot
17:28:52 <gavino> rump?
17:29:19 <gavino> what!!
17:29:25 <gavino> as in rsa encryption?
17:29:31 <gavino> liek openSSH
17:29:40 <vixey> mib_v7b5e2: would it prove P = NP
17:29:42 <dolio> Yes. RSA is all about factoring integers.
17:29:45 <roconnor> does that make factoring faster than multiplication?
17:29:54 <mib_v7b5e2> vixey: would it really?
17:30:01 <vixey> I'm asking you..
17:30:07 <inimino> When my perpetual motion machine works, *lots* of things are gonna be moot.
17:30:12 <mib_v7b5e2> vixey: oh, no. not at all
17:30:14 <Gracenotes> http://groups.google.com/group/sci.crypt/browse_thread/thread/67ea1c4144aa59cb -- "From what I know SVP and CVP are NP-hard (in general). So, to prove that factoring integers is possible in polynomial time -- assuming this "prime number lattice" works -- you'd need to prove that the resulting SVP/CVP instances are always "easy" to solve"
17:30:43 <Gracenotes> not necessarily credible either, but, we'll see.
17:30:51 <flippo> inimino, you won't need it when I begin to market my antigravity machine.
17:30:58 <mib_v7b5e2> apparently this dude came out of nowhere
17:31:06 <bd_> Alternately, factor any 4096-bit number using the method. If it's used in practice even once, it'll put a lot of doubt into RSA, even if it doesn't cover /all/ keys.
17:31:10 <mib_v7b5e2> and during his talk no one understand wtf was going on
17:31:19 <Elly> what?
17:31:26 <vixey> he sounds awesome
17:31:28 <Elly> factoring in polytime on a quantum computer does not prove P = NP
17:31:31 <Gracenotes> did he implement the algorithm on a computer?
17:31:33 <inimino> flippo: well my machine is here now, today; I even have a video of it working which you can't see.
17:31:34 <roconnor> well, if no one knows or understands him, he must be right!
17:31:37 <mib_v7b5e2> Elly: we never said it did
17:31:46 <Elly> oh, okay
17:31:52 <Elly> I saw a mention of Shor's Algorithm above
17:32:00 <Gracenotes> yeah. n^3 in the number of bits
17:32:04 <Gracenotes> (with constant)
17:32:11 <flippo> inimino, anti-gravity is powered by cold fusion.  I have all the data.
17:32:21 <Gracenotes> after all, if his algorithm is a valid algorithm with a given time constraint, it must be implementable on a computer
17:32:32 <Gracenotes> with or without the given time constraint, really
17:32:37 <mib_v7b5e2> flippo: if i had anti-gravity, i would put it under my longboard and that's it
17:32:44 <Elly> you can implement Shor's on a traditional computer too
17:32:47 <Elly> it's just a bit slower :P
17:32:55 <Gracenotes> Elly: yeah. I can show you my Haskell code doing that ^_^
17:32:58 <Gracenotes> exponential slowdown
17:33:00 <inimino> cold-fusion-powered anti-gravity?  OK, you win :-)
17:33:04 <mauke> > map (("Schnorr" !!) . join (+)) [0..3]
17:33:06 <lambdabot>   "Shor"
17:33:11 <Elly> the naive way to do it would be O(2^n), I think?
17:33:31 <mib_v7b5e2> Gracenotes: that sounded like a programming conference pickup line
17:33:52 <Baughn_> inimino: Nah, my perpetual motion cold fusion antigravity device is even better. It has ninjas.
17:33:53 <mib_v7b5e2> Gracenotes: "what do you say we head back to my hotel room and we do a bit of pair 'gramming"
17:34:08 <flippo> For some reason, these mathematical breakthroughs never show up in peer-reviewed journals.  (Except for the real ones.)
17:34:12 <mib_v7b5e2> Baughn_: really? ninjas? how old ARE you?
17:34:31 <Elly> come on lads, give us your best ninj!
17:34:31 <Gracenotes> trial division is O(2^(b/2)), b = number of bits
17:34:57 <Baughn_> mib_v7b5e2: Ninjas are useful. They can assassinate anyone who tries to look inside the machine.
17:35:19 <tiglionabbit> would it require stateful code to turn a word list into a trie?
17:35:46 <mib_v7b5e2> oh here's a good on-topic question
17:35:50 <Gracenotes> by comparison, GFNS is O((b * (log b)^2)^(1/3)). subexponential, but still...
17:35:52 <Baughn_> tiglionabbit: Require? No. Stateful code might be easier/faster. Or not.
17:35:57 <mauke> tiglionabbit: unlikely, I have a trie in my xmonad.hs
17:35:58 <mib_v7b5e2> can i use currying for a module?
17:36:07 <Irrelevant> tiglionabbit, stateless code is turing complete, so no :P
17:36:28 <mib_v7b5e2> so i could write a function: getFunction "monkey" "MyModule"
17:36:34 <Gracenotes> a stateless turing machine... oh, the garbage collection...
17:36:50 <mib_v7b5e2> and it would return me the MyModule.monkey function
17:36:50 <vixey> a reversible turing machine --
17:36:51 <mauke> gFromList = foldr (uncurry gInsert) gEmpty
17:36:58 <Irrelevant> mib_v7b5e2, er, no. and that's got nothing to do with currying.
17:37:00 <vixey> running backwards
17:37:19 <mauke> gnirut
17:37:22 <Irrelevant> mib_v7b5e2, you could probably do something that'd happen at compile time with Template Haskell, but i don't see the point.
17:37:30 <Gracenotes> granted, zippers provide a nice stateless turing machine implementation with relatively little memory being thrown around everywhere
17:37:57 <Irrelevant> Gracenotes, a rather elegant one, too, iirc.
17:38:20 <mib_v7b5e2> Irrelevant: lame....
17:38:50 <Irrelevant> mib_v7b5e2, i can think of many reasons why including such functionality would be a terrible idea
17:38:56 <Baughn_> mib_v7b5e2: What are you trying to do, exactly?
17:40:30 <Gracenotes> http://code.haskell.org/lambdabot/Plugin.hs -- lambdabot's module-loading implementation
17:41:05 <Gracenotes> requires some trivial TH code in the modules themselves
17:41:49 <mib_v7b5e2> Baughn_: if you promise not to laugh
17:41:50 <Gracenotes> still, not recommended for simple apps -- there usually is a better way
17:42:06 <Baughn_> mib_v7b5e2: No promises, but you won't be able to tell if I do.
17:42:11 <mib_v7b5e2> Baughn_: so i could do:  myRecord . function
17:42:26 <hydo> Looking at jobs on craigslist can be a hoot sometimes.  Here's a requirement from one: "Familiarity with multiple dynamically typed languages such as PHP, Perl, Ruby, Haskell, or Python"
17:42:29 <Baughn_> mib_v7b5e2: ..huh?
17:42:33 <mib_v7b5e2> where . would get the `function` function from the appropriate module depending on the type of myRecord
17:42:53 <mib_v7b5e2> spare me! i tried to find a way to do OO in haskell!
17:43:06 <mauke> we already have that, see OOHaskell
17:43:16 <Baughn_> mib_v7b5e2: Specifically, apparently, you tried to do the most annoying parts of OO in haskell?
17:43:36 <Baughn_> mib_v7b5e2: We've got existentials and typeclasses, for all the /useful/ stuff
17:43:44 <Gracenotes> hydo: well, granted, they only got one wrong
17:43:52 <Gracenotes> and PHP is just... WTF-typed
17:44:13 <hydo> Gracenotes: The most important one, imo.
17:44:19 <mib_v7b5e2> Baughn_: yea, i tried to call a different function on a record with the same name
17:44:27 * mauke writes all his functions as Dynamic -> Dynamic
17:44:36 <vixey> lol
17:44:52 <Gracenotes> ($) :: Dynamic -> Dynamic -> Dynamic
17:45:01 <Gracenotes> mm... *raises eyebrows*
17:46:05 <EvilTerran> surely ($) :: Dynamic
17:46:05 <EvilTerran> :P
17:46:09 <mib_v7b5e2> i love haskell
17:46:21 <mib_v7b5e2> but BONUS needs to get on the monad business though
17:46:32 <mib_v7b5e2> because i feel like as soon as he posts it, i will understand monads a lot better
17:46:38 <mauke> newtype What = What (What -> What)
17:46:47 <Gracenotes> so long as he has copious examples
17:46:50 <hatds> who is BONUS?
17:46:54 <dolio> He doesn't have monads in there yet?
17:46:59 <vixey> type ModelOfLambdaCalculus = What
17:47:01 <Gracenotes> se dice a month
17:47:18 <mgsloan> hatds: he wrote the learn you a haskell for great good guide
17:47:29 <mauke> preflex: seen BONUS
17:47:29 <preflex>  BONUS was last seen on #haskell 6 hours and 19 minutes ago, saying: haha awesome
17:47:54 <Baughn_> mib_v7b5e2: I feel like a broken record, but have you tried reading the typeclassopedia?
17:47:57 <hatds> mauke, vixey: man :) if someone had explained this clearly back then I might have understood lambda calculus on the first or second pass
17:48:00 <Baughn_> mib_v7b5e2: It covers monads in some detail
17:48:11 <mib_v7b5e2> Baughn_: don't feel bad about repeating something
17:48:12 <gavino> happstack wont scale yet damn it
17:48:21 <mib_v7b5e2> worse come to worse, someone will learn something
17:48:28 <Gracenotes> hm... I thought Wolfram|Alpha was supposed to open 48 minutes ago >_>
17:48:36 <Baughn_> mib_v7b5e2: See, that prospect scares me.
17:48:41 <Gracenotes> scaling problems, who'd've thought, though?
17:48:59 <mib_v7b5e2> Gracenotes: what does wolfram *do*?
17:49:02 <inimino> Gracenotes: anthropic principle, no doubt
17:49:08 <Gracenotes> magic
17:49:12 <Baughn_> Math
17:49:30 <Baughn_> Or in this case, a search engine they claim can beat google
17:49:32 <Baughn_> We'll see.
17:49:32 <hatds> data Magic = Magic | MoreMagic
17:50:00 <inimino> I predict that what it will do is: fail to live up to the hype
17:50:03 <Baughn_> makeMagic = unsafePerformIO flipSwitch `seq` Magic
17:50:14 <vixey> it's not IO :(
17:50:14 <Gracenotes> > unsafeCoerce Magic :: Maybe Int
17:50:16 <lambdabot>   Not in scope: `unsafeCoerce'Not in scope: data constructor `Magic'
17:50:16 <Gracenotes> Nothing
17:50:18 <mib_v7b5e2> Baughn_: what would it have to do to beat google?
17:50:23 <guinea> Maybe Magic
17:50:28 <Baughn_> mib_v7b5e2: Magic. :P
17:50:32 <Gracenotes> it's true... it will coerce to that
17:50:34 <guinea> Just Magic
17:50:36 <vixey> makeMagic = unsafeCoerce unsafeCoerce MoreMagic
17:50:58 <Gracenotes> nullary constructors in the first position coerce to eachother, generally
17:51:00 <Baughn_> mib_v7b5e2: What they're /claiming/ it does is basically high-level narrow AI, but google has been doing the exact same thing for a decade. Wolfram has some good people. Google has more.
17:51:17 <mib_v7b5e2> Baughn_: it looks like it's up to me...
17:51:23 <mauke> http://dis.4chan.org/read/prog/1241993414
17:51:29 <vixey> Baughn you're so !! I don't know the word for it but sooo much!!
17:51:33 <mib_v7b5e2> Baughn_: testicle! it's not
17:55:39 <hatds> I feel kind of bad for everyone who wants to compete with google...  I imagine no one can express that they want to compete with google without the people assuming they are cocky
17:56:11 <hatds> (it sure got quiet here?)
17:56:21 <mib_v7b5e2> hatds: i hear what you're saying
17:56:36 <mib_v7b5e2> it's like that onion article "ugly guy has huge penis but unsure of how to get the word out"
17:59:08 <hatds> er no
17:59:23 <mib_v7b5e2> stfu it is too
17:59:38 <hatds> it's like saying "I want be the best person Haskell programmer there ever was" and then getting the reply "you won't live up to the hype"
17:59:49 <guinea> I was trying to understand the thing on 4chan
17:59:59 <Baughn_> It's 4chan
18:00:01 <guinea> loeb = fix (fmap . flip id =<<)
18:00:03 <hatds> that's where you went wrong :)
18:00:08 <Gracenotes> I want to be... the very best... like no one ever was
18:00:16 <vixey> http://www.wolframalpha.com/input/?i=monad&asynchronous=false&equal=Submit
18:00:23 <Gracenotes> to curry them is my real quest... to pointfree is my cause
18:00:24 <guinea> I'm a noob but how do you flip id?
18:00:33 <vixey> Assuming "monad" is a protein -- lol
18:00:40 <Gracenotes> I will travel across the land, using monads far and wide
18:00:42 <vixey> guinea: 'how' ?
18:00:51 <guinea> never
18:00:52 <Gracenotes> Haskell to understand the power that's inside.... *chorus, etc.*
18:00:56 <guinea> never mind
18:00:59 <zoheb> I want to write a function getIntFromConfigFile ::IO(Int) that reads a config file once and caches the integer, and then returns this integer for all subsequent calls, Is this possible?
18:01:12 <flippo> So when are we going to graduate from monads to abelian groups?
18:01:15 <Baughn_> The wolfram alpha video is rather impressive, but I'll be shocked if it actually works on the things I usually want to know about. :P
18:01:35 <skorpan> Baughn_: "what is fmap (flip . id =<<)"
18:01:36 <mauke> guinea: you can write flip ($) instead if that makes more sense to you
18:01:38 <Gracenotes> well. global IORefs have been suggested for that kind of thing, but... sort of suspect
18:01:39 <Baughn_> flippo: If you want to use abelian groups, you can make a typeclass to do just that. Is the abstraction useful?
18:01:48 <mib_v7b5e2> Baughn_: i haven't seen the video yet. what make it so impressive?
18:01:58 <Baughn_> mib_v7b5e2: I suggest you watch the video.
18:02:04 <flippo> Baughn_, of course not.  But that shouldn't stop us from designing it.
18:02:20 <BMeph> skorpan: Hint - (id =<<) is join. :)
18:02:30 <Baughn_> skorpan: Possibly. Now that really /would/ be impressive. ^_^
18:02:37 <skorpan> aha, so it's really "fmap (flip join)"
18:02:39 <zoheb> Gracenotes, does this involve unSafeperformIO ?
18:02:42 <skorpan> @src join
18:02:43 <lambdabot> join x =  x >>= id
18:02:44 <dolio> mauke: #7 is pretty good.
18:02:57 <skorpan> no it's fmap (flip . join)
18:03:08 <skorpan> which is fmap (flip . (x >>= id))
18:03:13 <Gracenotes> zoheb: yes :\ global variables have been a sort of problem. However, you can pass around an IORef everywhere instead, if you want.
18:03:43 <Japsu> here's an fmap, there's an fmap, and another little fmap, funny fmap, fuzzy fmap, fmap fmap ap.
18:03:51 <skorpan> fmap (flip . (\x -> x >>= id))
18:03:53 <mib_v7b5e2> ok cool cats and kittens
18:04:09 <mib_v7b5e2> i'll catch you all later, under my other nick seydar
18:04:14 <mib_v7b5e2> PEACE
18:04:14 <skorpan> i don't get it
18:04:16 <mib_v7b5e2> WAR
18:04:21 <Baughn_> skorpan: The thing is, this screencast.. if it isn't all hardcoded, the AI to generate it all would have to be scarily close to human level. Which is one reason I expect it is, and so will be very limited in scope.
18:04:51 <skorpan> Baughn_: but as i understood it, it's not really AI, just some weird way of structuring data?
18:04:51 <Gracenotes> zoheb: if you can carry it around, this would be good; or simply get it in the first place and use that
18:05:12 * Gracenotes wonders if there's good caching support anywhere
18:05:20 <Baughn_> skorpan: Anytime someone makes something actually /work/, they stop calling it AI. This would certainly have fallen under the heading a decade ago.
18:05:27 <guinea> mauke: my brain is tired, I had to fire up ghci and do some ":t" to get it
18:05:44 <mauke> ($) :: (a -> b) -> (a -> b); ($) = id
18:05:54 <Baughn_> skorpan: But I'm thinking mostly of the backend that's supposed to extract this sort of data from random websites
18:06:10 <skorpan> oh
18:06:15 <guinea> Isn't Alpha supposed to be more "curated" than google?
18:06:21 <skorpan> i never got to watch the screencast, justin.tv complained about my adblocker or something
18:06:28 <zoheb> So basically I writeIORef very early in the program and carry it around?
18:06:36 <Baughn_> guinea: "Shepherded" might be more accurate
18:06:46 <vixey> Alpha isn't a search engine
18:07:02 <Gracenotes> zoheb: ..or simply get the value early on and carry the value around
18:07:02 <dolio> It computes answers!
18:07:30 <guinea> more shepardized?
18:07:33 <Gracenotes> zoheb: it does sound like a configuration variable of sorts, after all
18:07:34 <Baughn_> vixey: It's supposed to give you the approximate information you'd get from doing a web search and then integrating the information in your head. More convenient, but it's still the same process
18:08:01 <vixey> :(
18:08:02 <zoheb> let me just try it out
18:08:03 <Baughn_> Hum. It's good at math, though. Not unexpected.
18:08:11 <Gracenotes> IORef might be excessive for just a write-once variable... dunno.
18:08:11 <vixey> It doesn't know what a monad is!!!
18:08:21 <Baughn_> Oh, it's online now?
18:08:26 <vixey> http://www.wolframalpha.com/input/?i=cube+vs.+dodecahedron+vs.+tetrahedron
18:08:33 <zoheb> Is there any other option?
18:09:07 <roconnor> I vote for tetrahedron
18:09:10 <Baughn_> Seems a bit overloaded. ^^;
18:09:16 <zoheb> apart from IORef, for this problem?
18:09:43 <zoheb> apart from carrying it around
18:09:55 <hatds> zoheb: the solution is to come to terms with reality that there is no global value which is not pure
18:10:39 <zoheb> I not attempting to write a pure function but an IO(Int)
18:10:44 <zoheb> efficiently
18:11:12 <roconnor> does implicit arguments solve this problem?
18:11:15 <Baughn_> vixey: ..I give. WA is useful.
18:11:17 <hatds> passing it to a function that needs it isn't ineffecient
18:11:22 <Baughn_> For science, at least.
18:11:23 <zoheb> Let me post some sample code using IORef and see if it makes sense
18:11:30 <vixey> oh?? how com
18:11:32 <vixey> how come
18:11:46 <vixey> I'm trying to get it to teach me partial integration
18:11:57 <hatds> global mutable variables make sense, you just don't have them in haskell
18:12:00 <vixey> is that even a thing?
18:12:31 <Baughn_> So I asked it about the location of mars, and it gave me a map of the sky from my current location. :D
18:12:41 <BMeph> Wow, it *is* better than Google! Instead of giving me irrelevant stuff, it just says, "Wolfram|Alpha isn't sure what to do with your input." Brilliant! ;p
18:12:45 <Gracenotes> again, if it's configuration, accessing it at the very beginning might be best///
18:13:00 <inimino> Baughn_: did the map have an arrow in it pointing at Mars?
18:13:49 <Twey> 02:00:59 < zoheb> I want to write a function getIntFromConfigFile ::IO(Int) that reads a config file once and caches the  integer, and then returns this integer for all subsequent calls, Is this possible?
18:13:59 <Baughn_> inimino: Ah, no.
18:14:00 <Twey> zoheb: Possible, yes; advisable, no
18:14:11 <Twey> Rethink your design
18:14:18 <Baughn_> inimino: I got "computation timed out", though. It's a bit broken right now.
18:14:27 <glguy> no globals?
18:14:29 <inimino> Baughn_: ah, too bad
18:14:32 <glguy> :t getStdGen
18:14:33 <lambdabot> IO StdGen
18:14:35 <zoheb> Twey, I guess it is possible if I use an IORef
18:14:39 <glguy> :t setStdGen
18:14:40 <lambdabot> StdGen -> IO ()
18:14:42 <Twey> zoheb: Yes
18:14:44 <mgsloan> is wolfram alpha public yet?
18:14:51 <Twey> But there are a lot of alternative approaches to this problem
18:14:56 <zoheb> Why is it not advisable?
18:15:00 <Twey> Most of which are better
18:15:12 <Twey> Because it requires every bit of code that uses that value to be impure
18:15:18 <Twey> Even though the value is essentially pure
18:15:40 <roconnor> Twey: would implicit arguments be useful here?
18:15:54 <Twey> As someone suggested, the simplest way is just to pick it up initially and pass it around as a pure value
18:15:55 <zoheb> ok, this was only a theoretical question BTW
18:16:05 <Twey> You could use a Reader monad to make that nicer, if you wanted
18:16:13 <Twey> roconnor: Not really
18:16:18 <roconnor> ok
18:16:21 <Gracenotes> or ReaderT, perhaps.
18:16:25 <Twey> It's only one argument; I don't see the problem with passing it around explicitly
18:16:28 <glguy> implicit params are the reader monad without all of the monadishness
18:16:34 <zoheb> But I might want to extend the functionality
18:16:44 <Twey> zoheb: To do what?
18:16:44 <guinea> Twey: even though every bit of code that uses it is impure, you can make that impure code by composing pure code?
18:16:56 <Twey> guinea: Yes
18:16:59 <roconnor> glguy: that's why I thought it would be good here.
18:17:05 <glguy> sure
18:17:06 <Twey> Well
18:17:12 <zoheb> Like the function might check timestamps of the config file each time, and reload the value if required
18:17:14 <Twey> Apart from the actually impure bit where it gets the value, of course
18:17:16 <guinea> Twey: so the impure bit can be only a few lines, packaging up the pure code
18:17:19 <glguy> implicit params are kind of out of favor now
18:17:31 <zoheb> In this case it isn't really pure
18:17:35 <Twey> guinea: A few lines *per function*
18:17:50 <Twey> zoheb: Hmm
18:18:07 <zoheb> what I am trying to do is a kind of memo-ization optimization without exposing the innards of the optimization to the caller
18:18:12 <hellige> anyone here know yampa?
18:18:14 <guinea> Twey: per function that interacts with refs or IO
18:18:14 <Twey> I think in that case you would make it impure
18:18:33 <Twey> guinea: Which zoheb is proposing be all of them, yes
18:18:51 <guinea> oh
18:18:53 <Twey> zoheb: Do you see the difference?
18:19:11 <zoheb> basically a memoizing optimization which somehow requires the fnction to "remember" what it did last time
18:19:11 <Twey> zoheb: In the one case you're only reading it once, and everything from that point on is pure
18:19:27 <Twey> zoheb: In the other, you're reading or checking the file anew each time
18:19:39 <zoheb> yes, i realise that
18:19:40 <Twey> So all accesses must be impure
18:19:50 <Twey> It's a fundamental difference, and it's reflected in the types for a reason
18:20:01 <zoheb> The basic thing I am trying to do is impure
18:20:26 <Twey> Personally I would let the user decide when they wanted to recheck it
18:20:44 <vixey> zoheb: I can show you how to memoize a simple function in a pure way
18:20:58 <zoheb> Yes vixey!
18:20:59 <glguy> don't forget memotrie
18:21:03 <vixey> ok lets use this example:
18:21:15 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2)
18:21:26 <vixey> so to memoize we should make a list of all the values
18:21:30 <zoheb> make it a list
18:21:30 <vixey> fibs = map fib [0..]
18:21:33 <vixey> yeah
18:21:35 <vixey> and then define
18:21:40 <vixey> fib' i = fibs !! i
18:21:50 <vixey> so then we have to make teh recursive calls use that lookup
18:21:59 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2)
18:22:00 <vixey> and that's it
18:22:18 <zoheb> hmmm
18:22:34 <zoheb> thats good
18:23:00 <koninkje> Of course, the fibs example highlights a big divide between dynamic programming (memoizing through recursion) vs general memoizing (between unrelated calls)
18:23:18 <vixey> lets look at performance
18:23:20 <vixey> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 100
18:23:26 <vixey> that's fib of 100 not memoized
18:23:36 <lambdabot>   thread killed
18:23:37 <vixey> it couldn't do it...
18:23:37 <vixey> > let fibs = map fib [0..] ; fib' i = fibs !! i ; fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2) in fib 100
18:23:40 <lambdabot>   354224848179261915075
18:23:46 <vixey> but the memoized version worked really quickly.. :)
18:23:53 <vixey> so it does do something
18:24:41 <koninkje> even better for fibs is to only keep a sliding window of he last two values, instead of the whole list ;)
18:24:55 <koninkje> zoheb: you may want to take a look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-memocombinators
18:24:56 <vixey> sure but that's kind of completely irrelevant
18:25:22 <vixey> yeah that memo combinator stuff uses unsafePerformIO/impure functions
18:25:25 <koninkje> vixey: no, it isn't. Again, the difference between dynamic programming and general memoization
18:25:29 <vixey> not sure why that would be worth using
18:25:41 <vixey> Do you know about containers koninkje??
18:25:45 <koninkje> they pretty up the open-recursion version
18:26:02 <koninkje> vixey: "containers" meaning?
18:26:10 <vixey> I take that as no
18:26:30 <koninkje> zoheb: also worth looking at http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
18:26:40 <dons> i even don't know which containers you're referring to, vixey
18:26:53 <koninkje> "containers" can mean a great manyu things, I don't know which one you mean
18:30:06 * edwardk waves hello.
18:30:14 <vixey> hi
18:30:18 * koninkje waves back
18:31:24 <edwardk> koninkje: heh, your endorsement of Haskell for computational linguistics has my wife picking up Real World Haskell and reading learn you a Haskell. ;) Even if she kicks me out of the room whenever she starts reading them ;)
18:31:51 <koninkje> heh heh
18:32:19 <koninkje> edwardk: well, I did tell her she didn't need to know any of That Stuff(tm) that you go on about ;)
18:32:27 <edwardk> haha
18:32:28 <edwardk> yeah
18:32:55 <edwardk> I realize I'm probably the worst advocate to have for getting people into Haskell ;)
18:33:43 <koninkje> Well I've found your blog a fascinating read at least (though I suppose I *was* already hooked on CT and Haskell)
18:33:56 <edwardk> She was somewhat relieved to know that this community thinks I'm as strange as the outside world does though ;)
18:34:08 * koninkje lol
18:35:11 <edwardk> the funny thing was i picked up haskell for a very practical purpose, it just never materialized because by the time i learned haskell i realized that what i had wanted to do wasn't very interesting =)
18:35:51 <roconnor> edwardk: I'm a big fan of your CPS package.
18:35:57 <roconnor> ... even though I've never used it.
18:36:00 <Asztal> I never fail to read cofree as coffee... it makes looking at category-extras interesting
18:36:00 <edwardk> roconnor: hah
18:36:10 <edwardk> i need some benchmarks to try it out with
18:36:28 <roconnor> you should run in on my Endo code.
18:36:36 <edwardk> roconnor: ?
18:36:47 <edwardk> as in icfp 07?
18:36:50 * koninkje wonders which free/forgetful functors generate the coffee monad
18:36:58 <roconnor> edwardk: yes
18:37:16 <dolio> My benchmarks suggest a manually CPSed ST is significantly faster than the standard implementation.
18:37:17 <edwardk> coffee isn't free, it usually costs at least 25 cents, or way more if you use the Starbucks comonad.
18:37:21 <dolio> Despite doing way more allocation.
18:37:22 <roconnor> enjoys a cup of hot cocomonad.
18:37:31 <roconnor>  /me
18:38:06 <edwardk> dolio: yeah, i worry a bit about how much more i'm allocating
18:38:08 <roconnor> edwardk: well, in the end GHC will probably change to render your library useless.
18:38:14 <hellige> one more try... anybody here know yampa or reactive?
18:38:16 <edwardk> roconnor: good =)
18:38:43 <edwardk> hellige: i know a lot about reactive's internals, but little about its practical usage
18:39:09 <hellige> hmm, still might help
18:39:11 <roconnor> edwardk: hmm, actually maybe you could add a module with a bunch of GHC rewrite rules.
18:39:26 <roconnor> edwardk: then simply importing your module would make all my code faster.
18:39:45 <edwardk> roconnor: where is your endo code? =)
18:40:06 <roconnor> edwardk:  good question
18:40:10 <hellige> edwardk: i've been trying to use yampa, but i'm a bit stuck. not sure if it's a yampa limitation, or my limitation...
18:40:34 <roconnor> darcs get http://r6.ca/icfp2007
18:40:42 <roconnor> that should  retrieve something
18:40:43 <hellige> edwardk: seems like yampa is tied rather strictly to an output sampling model..
18:40:46 <roconnor> no idea what though.
18:41:07 <hellige> but what i really want is just to produce a complete list of all the (discrete) output events.
18:41:21 <edwardk> i was playing with a little GADT to do the 'CCNF' optimization to 'causal normal form' for arrows that found its way into some paper the other day and realized i wanted to do the same cps transformation to make their normal form a little faster, but that i wasn't sure if it would really be a win.
18:41:24 <hellige> i'm using a few continuous signals internally, but the input and output are both discrete time-series.
18:41:53 <edwardk> hellige: yampa is kind of obnoxious to use, maybe its just the arrow syntax, but the model feels really restrictive
18:41:55 <centrinia> > let matmul xs ys = [[sum $ zipWith (*) x y | y <- transpose ys] | x <- xs]; matexp 0 x = [ [ if i == j then 1 else 0 | j <- [1..length (head x)]] | i <- [1..length x]]; matexp n x | n `mod` 2 == 0 = matexp (n `div` 2) (matmul x x) | n `mod` 2 == 1 = matmul x (matexp (n `div` 2) (matmul x x)) in map (\x -> head . tail . head $ matexp x [[1,1],[1,0]] ) [0..]
18:41:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:42:25 <roconnor> edwardk: the codensity monad transform (although I didn't know it by that name) speed my code up by a factor of 4.
18:42:25 <hellige> i haven't really looked at reactive yet. i've found yampa pleasant enough so far, but the interface to actually RUN the thing is really frustrating.
18:42:27 <edwardk> hellige: hrmm, ok
18:42:30 * coCocoa is looking for some comarshmallows
18:42:42 <hellige> i just want to say "here's a bunch of lists of events, pump them through and give me the results."
18:42:49 <edwardk> roconnor: over what monad?
18:43:02 <roconnor> edwardk: http://r6.ca/blog/20071028T162529Z.html
18:43:06 <edwardk> hellige: have you looked at reactive much?
18:43:13 <roconnor> edwardk: StateT DNA (MaybeT (Writer (Endo [RNA])))
18:43:26 <hellige> read some of conal's posts, but not too closely, no.
18:43:26 <roconnor> but I didn't use the mtl
18:43:32 <roconnor> because back then things didn't inline.
18:43:41 <roconnor> maybe they still don't.
18:44:11 <edwardk> hellige: look at the package for reactive, iirc it works via a little event pump that should do just what you want unless i misunderstand you
18:44:17 <roconnor> Endo [RNA] is really DList RNA
18:44:29 <hellige> edwardk: ok, it's next on my list anyway, i'll give it a look.
18:44:36 <hellige> right after star trek, that is...
18:44:37 <edwardk> roconnor: hrmm. yeah thats a straightforward codensity already
18:44:40 <hellige> thanks for your help!
18:45:15 <roconnor> edwardk:  your code would do something smarter with the maybeT bit.
18:45:16 <edwardk> poking at it to see if i can come up with a better split
18:45:53 <roconnor> edwardk:  are you looking at my blog or my code?
18:45:59 <edwardk> blog
18:46:07 <edwardk> just trying to see what it'd look like
18:48:47 <edwardk> something like: forall o. (a -> DNA -> [RNA] -> o) -> DNA -> [RNA] -> o -> o
18:49:25 <edwardk> would be the result of running Ran over StateT DNA (MaybeT (Writer [RNA])) -- instead of Codensity
18:49:39 <roconnor> :)
18:50:15 <roconnor> I suppose I could plug that in myself.
18:50:21 <edwardk> now, hand tuning that you might find its worth refactoring that slightly to get it into 'near-codensity' form
18:50:35 <roconnor> huh?
18:50:37 <Gracenotes> edwardk: where does the a come from?
18:50:46 <edwardk> forall o. (a -> DNA -> [RNA] -> o) -> o -> DNA -> [RNA] -> o
18:50:57 <roconnor> Gracenotes: monad type variable
18:51:07 <roconnor> parameter
18:51:16 <edwardk> Gracenotes: thats the cps'd writer-as-state, cps'd state and the maybe as yoneda endo
18:51:36 <edwardk> the 'a' is the contents of your monad
18:51:39 <Gracenotes> yes.... I at least get the o, though...
18:52:01 <Gracenotes> ... right
18:52:32 <edwardk> newtype DNAMonad a = DNAMonad (forall o. (a -> DNA -> [RNA] -> o) -> o -> DNA -> [RNA] -> o -- would be the form i'd probably put it in
18:54:56 <edwardk> i would love to hear how much faster or worse that made the code
18:55:33 <roconnor> too bad I'm editing my thesis
18:55:40 <edwardk> hah
18:55:44 <edwardk> is the code linked there?
18:55:58 <roconnor> darcs get http://r6.ca/icfp2007
18:56:08 <roconnor> I don't know what version that gets
18:56:23 <roconnor> If you want to look at it, I'll help direct you around it.
18:56:48 <edwardk> i'll see what it pulls
18:56:53 <edwardk> any instructions on how to use it?
18:56:53 <roconnor> I experimented with many different string representations, so it could be a mess
18:57:08 <roconnor> I'll pull it too and see
18:57:16 <edwardk> i just want to seek and destroy your monad ;)
18:57:32 <dons> anyone want to have a go, http://www.reddit.com/r/programming/comments/8ks2g/type_system_faceoff_what_type_system_will_give_me/
18:57:39 <dons>  seems like a haskell soln. waiting
18:58:43 <roconnor> edwardk: let's start by making DNAexec.hs
18:59:08 <edwardk> i don't see the cps'd monads in here
18:59:27 <edwardk>  Could not find module `MaybeT':
18:59:56 <roconnor> hmm
19:02:12 <roconnor> ah
19:02:18 <roconnor> found my cont branch
19:02:31 <Gracenotes> hm... just tried Wolfram|Alpha. It could do "jaws" (the movie), "x^2", and "sin {1,2,3,4}". Couldn't handle "newton fractal", "minimum of {0,1}", "meet of {0,1}", "turing machine", or "haskell programming language"
19:02:43 <Gracenotes> hm... seems to be down now
19:02:50 <SubStack> wolfram alpha is out?
19:02:56 <Gracenotes> no, wait, still seems to work:
19:02:59 <Gracenotes> http://www.wolframalpha.com/input/
19:04:06 <SubStack> :o
19:04:10 <SubStack> Gracenotes++
19:04:40 <edwardk> bah it thinks a monad is protein WDR92 ;)
19:04:54 <Gracenotes> see also http://www.wolframalpha.com/examples/
19:05:22 <Gracenotes> what it can do at this point. Seems the database isn't huge, but it's pretty neat :)
19:05:25 <roconnor> okay, how to send this to you.
19:05:56 <edwardk> It's good to know that a monad weighs 39.609 kilodaltons though.
19:07:16 <Gracenotes> no lambda calculus interpreter yet!
19:07:37 <Gracenotes> more cellular automaton support, really. Which is still Turing complete, of course
19:08:25 <hatds> so alpha is not a general search engine?
19:09:05 <hatds> y/n/m?
19:09:16 <Gracenotes> no... sort of many different computational engines rolled into one. The key function is taking natural language input and deciding what engines to feed it to
19:09:41 <edwardk> hatds: if you think of it as a little search engine for chemicals, proteins, and providing comparative analysis of a rather scattershot set of 'curated' data its probably better
19:09:48 <edwardk> it'll know next to nothing about pop culture, etc.
19:10:25 <hatds> edwardk: that's basically what I was wondering
19:10:31 <hatds> boring
19:10:31 <Gracenotes> hmm. sort of on-and-off.
19:10:59 <hatds> actual information is not what I want from a search engine oddly :)
19:11:06 <edwardk> on the other hand if you ask it things like http://www.wolframalpha.com/input/?i=1+billion+years+after+the+big+bang -- it'll come back with a nice summary of the expansion of the universe
19:11:36 <edwardk> hatds: wolfram alpha is more like an idiot-savant expert system than a search engine
19:11:41 <Gracenotes> it just gave me "Error: DataPacletFilter: Unable to get Connection Cannot create PoolableConnectionFactory (Too many connections)"
19:11:52 <Gracenotes> factory, huh? >_>  <_<
19:11:52 <hatds> edwardk: yea
19:12:13 <roconnor> edwardk:  try pulling again.  I suggest nuking your previous pull to be safe.
19:12:21 <edwardk> kk
19:12:39 <cjs> Aren't expert systems all idiots savant? At least, those that aren't just idiots?
19:13:05 <cjs> Anyway, this is really bugging me now: how does one pronounce the OCaml code "'a list"?
19:13:08 <hatds> Simon Peyton Jones no interesting results :(
19:13:28 <hatds> nothing for haskell either.. screw alpha!
19:13:59 <sjanssen> cjs: that's the same as [a] in Haskell, so I'd say "list of a"
19:14:21 <edwardk> ok, well, its got a bit more randomness to the kinds of queries it'll answer nicely. i'm sure it can basically answer all of the queries that wolfram thought to type into it personally, but then wolfram doesn't exactly strike me as a typical search engine user, so the choice of specialties might be a little... odd.
19:14:40 <travisbrady> how would I create an Int-like type that can only exist within some range, say, 0 to 10, this is my broken attempt: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2435#a2435
19:15:12 <Gracenotes> Bounded provides information... it doesn't really enforce anything
19:15:15 <roconnor> data Int10 = Zero | One | Two | Three | Four | Five | Six | Seven | Eight | Nin
19:15:21 <hatds> a literal '11' gets desugared into fromInteger 11
19:15:21 <Gracenotes> what you perhaps want is a hidden constructor
19:15:50 <hatds> (and fromInteger has type :: Num a => Integer -> a, so you can't make this fail to typecheck)
19:15:50 <Gracenotes> otherwise, not much can be done at compile-time without dependent types
19:16:15 <cjs> Ah, I don't use the "of" when speaking Haskell. E.g., "Lazy (List a)" is just "lazy list-eh?" But I'm curious as to what the OCaml guys use in common speech. "'a lazy_t" feels awkward to read backwards....
19:16:23 <edwardk> roconnor: still no MaybeT
19:16:28 <Gracenotes> hm. you could define a Num instance has all modulo 10s
19:16:38 <roconnor> oh, does it still want MaybeT?
19:17:01 <edwardk> yeah for DNAMonad
19:17:07 <Cale> Hmm, Wolfram Alpha seems annoying. Most of the time, it ignores my input and takes me back to the top level of the site.
19:17:11 * travisbrady googles "hidden constructor"
19:17:24 <koninkje> cjs: from the OCaml folks I know, they just read it in order, e.g 'a list ==> "alpha list"
19:17:29 <roconnor> edwardk ah opp
19:17:35 <roconnor> I didn't upload to my webserver
19:17:37 <roconnor> heh
19:17:47 <roconnor> plz delete again, and give me one sec
19:17:50 <edwardk> kk
19:17:56 <cjs> Ah, "alpha!" Duh. Ok, thanks.
19:18:13 <roconnor> okay it should be better now
19:18:47 <Gracenotes> hm.. impressive. http://www.wolframalpha.com/input/?i=E+augmented+major+seventh
19:19:37 <Cale> heh... http://www.wolframalpha.com/input/?i=1%2F2+mass+of+earth+(velocity+of+earth)^2+in+joules -- yes, that's what I meant.
19:19:39 <Gracenotes> doesn't like "F neapolitan sixth chord" though
19:19:41 <Cale> ;)
19:19:43 * roconnor tries to convince himself that his category is not enriched.
19:20:13 <edwardk> checking again
19:20:51 <edwardk> better
19:21:07 <edwardk> newtype DNAMonad a = DNAMonad { unDNA :: ∀r. (Cont (DNA → ([RNA], DNAState r)) a)} -- looks right to me now
19:21:36 <roconnor> it should almost build
19:21:47 <edwardk> fixed reference to forever
19:21:50 <edwardk> then it builds
19:21:50 <roconnor> you probably need to remove my definition of forever
19:21:59 <Gracenotes> doesn't seem to like "E major phrygian scale" either..
19:22:27 <Gracenotes> or s/major/dominant/
19:22:57 <edwardk> what is a good DNA to run? i didn't actually participate in 07
19:23:32 <Gracenotes> aha! It recognizes "E spanish phrygian"
19:23:39 <roconnor> edwardk: let me see
19:23:42 <Gracenotes> but not as the third
19:24:27 <Cale> Heh, you can tell that Wolfram was involved. Scales are also numbered.
19:24:59 <Cale> (according to a 12 bit code)
19:25:12 <Gracenotes> ooh, you can play the scale sound
19:25:19 <roconnor> edwardk: touch empty.dna
19:25:22 <Zao> Victory! I managed to build gtk2hs on Windows.
19:25:26 <Zao> I wonder if it works ;)
19:25:28 <roconnor> edwardk: and run it on that.
19:25:34 <Gracenotes> at least in whatever web browser it was tested in
19:26:48 <edwardk> ./DNAexec empty.dna > empty.rna ?
19:27:37 <roconnor> that's good
19:27:53 <roconnor> the result should be the same as endo.rna
19:28:17 <edwardk> estimated runtime a few minutes?
19:28:27 <roconnor> um
19:28:31 <roconnor> maybe 2 minutes
19:28:40 <roconnor> that's what I said in my blog
19:28:53 <roconnor> but it sort of depends on which string represenation is being used.
19:29:41 <roconnor> it seems to be using Data.Seq
19:29:44 <roconnor> which is pretty fast
19:29:48 <roconnor> but kinda a memory pig
19:30:02 <bwr> Trying to capture the screen. not anywhere close yet. Trying to use gtk2hs to get the screen definitions. Can someone take a look at this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4919#a4919
19:30:59 <edwardk> k 56 seconds using the original version there
19:31:08 <roconnor> okay
19:31:13 <roconnor> sounds pretty resonable
19:31:26 <roconnor> did you have your computer in 2007? :)
19:31:42 <edwardk> that was in a VM ;)
19:31:48 <roconnor> oh god
19:31:50 * Twey laughs.
19:32:06 <Twey> Wolfram|Alpha isn't sure what to do with your input.
19:32:18 <Twey> Related inputs to try:
19:32:29 <Twey> number of legs   Animals: wolf   Movies: legs
19:32:41 <edwardk> I did run it with -O2 -fspec-constr -fdicts-cheap -funbox-strict-fields though
19:33:44 <Twey> Some of the outputs for names have \n in them
19:34:32 <roconnor> edwardk:  I just didn -O2
19:34:33 <roconnor> did
19:34:45 <edwardk> i wanted it to be fair, since i tend to use those myself
19:35:44 <edwardk> trying to parse your DNAMonad
19:36:02 <roconnor> edwardk: we need to get it down to 16 seconds to compete with C. :)
19:36:18 <edwardk> hah
19:36:34 <edwardk> its good to have a goal
19:37:27 <edwardk> done is your 'mzero'?
19:38:26 <roconnor> um
19:38:30 <roconnor> probably
19:38:49 <roconnor> oh
19:38:53 <roconnor> I don't think I'm a monadPlus
19:38:58 <roconnor> fail is my done
19:39:06 <Gracenotes> mzero is identity over mplus
19:39:35 <edwardk> well the monadplus would 'resume' a 'done' =)
19:40:35 <roconnor> oh I don't implement fail
19:40:37 <edwardk> it should be able to be monadplus because it's maybet'd
19:40:38 <roconnor> strange
19:41:09 <roconnor> it could be, but I never use mplus
19:41:16 <Twey> What is it with mathematicians and their prepositions?
19:41:29 <Twey> They always choose such odd prepositions to refer to things
19:41:33 <roconnor> I like how I say forever, but it actually stops eventually
19:42:12 <Twey> Like ‘identity over mplus’ — why on Earth would it be ‘over’?  mplus is not a set, nor anything with a discernable maximum bound that identity could be considered above
19:43:52 <Gracenotes> in the range of things to be mplus'd, mzero is identity. too literally
19:44:09 <bwr> Anyone mind taking a look at my code?
19:45:09 <TomMD> Is your code somehow offensive?
19:45:17 <bwr> I don't think so, but it doesn't work
19:45:34 <TomMD> Well feel free to paste it.
19:45:36 <TomMD> @where paste
19:45:37 <lambdabot> http://hpaste.org/new
19:45:42 <bwr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4919#a4919
19:46:11 <roconnor> @pl \(x,y) -> f x y
19:46:12 <lambdabot> uncurry f
19:46:17 <bwr> I am trying to capture the screen, but I am making small steps towards that.
19:46:28 <bwr> Just trying to get screen dimensions currently
19:47:34 <TomMD> Gah, I don't have gtk2hs installed these days, but I'm looking anyway.
19:47:34 <bwr> I get nothing from the screenGetDefault
19:47:48 <roconnor> @pl \p -> f (fst p) (snd p)
19:47:48 <lambdabot> uncurry f
19:47:56 <roconnor> @pl \p -> f (pi1 p) (pi2 p)
19:47:56 <lambdabot> liftM2 f pi1 pi2
19:48:10 <TomMD> bwr: Oh, so it compiles but doesn't act how you want it to?
19:48:49 <bwr> Yes
19:49:38 <TomMD> bwr: Well, the GTK site says 'screen_get_default' returns None if there is no default, so I'm guessing gtk2hs translates None -> Nothing.
19:49:48 <TomMD> Do you have a reason to expect a default?
19:50:00 <bwr> I only have one screen :P
19:50:38 <bwr> Well, i was looking at an example in a different language
19:50:41 <TomMD> bwr: Does displayGetDefault return properly?
19:50:50 <bwr> and they were using screenGetDefault
19:51:04 <bwr> i don't know where displayGetDefault is
19:51:23 <TomMD> I just guessed it might based on what I saw in the C api.
19:51:48 <bwr> the haskell docs on screenGetDefault says to see displayGetDefault
19:51:51 <bwr> but i haven't seen where that is
19:51:56 <TomMD> ah, I see.
19:52:00 <hatds> I'd try calling the function in a stand alone C function first, but I'm always terrible at grokking libraries
19:52:01 <bwr> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/Graphics-UI-Gtk-Gdk-Screen.html#v%3AscreenGetDefault
19:52:07 <hatds> *stand alone C program
19:52:22 <TomMD> Sorry, its too specific for me to help any - I'm just stabbing in the dark so its probably a waste of time.
19:52:33 <bwr> ok, thanks for looking though
19:52:51 <riddochc> Going through Real World Haskell. Starting in about ch. 7, (the first chapter on I/O), the $ symbol is used... but not explained. It's not in the index, as far as I can tell, and I'm now in ch. 9, and still don't know what it signifies.
19:53:08 <hatds> f $ x = f x
19:53:35 <edwardk> done >>= _ = done ?
19:55:15 <MyCatVerbs> riddochc: ($) takes a function and an argument and applies the function to the argument.
19:55:57 <MyCatVerbs> riddochc: i.e. it does nothing, semantically. Its only purpose is to split expressions in half, so you can get away with fewer brackets.
19:57:45 <roconnor> edwardk: ya
19:58:11 <edwardk> making headway. stuck doing some work stuff at the same time
19:58:22 <riddochc> MyCatVerbs: Oookay, that helps a little... by bracket, you're not referring to the function used for exception handling, I assume?
19:58:33 <ray> he means parentheses
19:58:38 <MyCatVerbs> riddochc: no, I mean parentheses. Sorry, I'm British.
19:58:48 <ray> you can write f $ g x y z
19:58:54 <ray> instead of f (g x y z)
19:59:10 <riddochc> Ah!  I get it, then.
19:59:13 <MyCatVerbs> riddochc: $ has really low precedence, so it (almost always) splits expressions in half.
19:59:22 <roconnor> edwardk:  I don't really see how my code gets that law, but I hope it holds.
19:59:33 <ray> normal function application, on the other hand has reeeeeeeeeeeeeeeeally high precedence
19:59:44 <MyCatVerbs> A common way to write long chains of composed functions is, (foo . bar . baz . bleeple $ input)
19:59:59 <riddochc> So maybe that means it was explained in the section on . but I missed it the first time through...
20:00:03 <roconnor> done = DNAMonad (Cont (\_ _-> ([], Done)))
20:00:13 <roconnor> That's pretty damning though
20:00:15 <ray> i don't remember, because i already knew haskell before i got RWH
20:00:38 <MyCatVerbs> riddochc: no, you're not the first to complain about this, I believe it's actually missing or some such thing.
20:00:42 <riddochc> Yeah, obviously I'm just learning it for the first time.
20:00:55 <roconnor> edwardk: was empty.rna the same as endo.rna?
20:01:08 <riddochc> Huh.  Well, the index has a reference to ($) but not just $
20:01:09 <MyCatVerbs> Personally, I'd recommend Learn You A Haskell first, anyway. Then pretty much any guide will do.
20:01:25 <MyCatVerbs> riddochc: ($) is just the prefix way of writing $.
20:01:30 <ray> yeah, we refer to operators by their prefix forms usually
20:01:32 <MyCatVerbs> ($) f x = f $ x
20:01:35 <edwardk> yeah
20:01:43 <MyCatVerbs> @where lyah
20:01:44 <lambdabot> www.learnyouahaskell.com
20:01:56 <MyCatVerbs> for Great Good!
20:02:06 <edwardk> slogging through the writer instances
20:02:10 <ray> it's like that ruby one but with more content and fewer cartoons
20:02:11 <edwardk> er instance
20:02:33 <edwardk> did you actually use the listen or pass? =)
20:02:49 * shapr gives edwardk the Iron Man Fire Extinguister award for today.
20:02:56 <edwardk> hah
20:03:03 <MyCatVerbs> ray: it's like _why's Poignant Guide, only with mere cartoons rather than actual hallucinations.
20:03:09 <edwardk> did you light... er... start it back up after?
20:03:14 <hydo> lyah++
20:03:17 <adamvo> @hoogle Monad Either
20:03:17 <lambdabot> Did you mean: :: Monad (Either a a) /count=20
20:03:17 <lambdabot> No results found
20:03:22 <MyCatVerbs> Haskell on a sugar rush rather than Ruby on lysergic.
20:03:25 <shapr> Not yet, who would hold the fire extinguisher? :-)
20:03:28 <edwardk> shapr++ for finally getting the bladeserver to turn on!
20:03:30 <hatds> does anyone ever wish there was a way to assign a type synonym by specifying a global value?  like type FunType = f  where f is global
20:03:35 <riddochc> Right, ($) isn't explained until partway through ch. 10, but is first used in ch. 7
20:03:42 <adamvo> @hoogle Monad (Either a a)
20:03:43 <lambdabot> Warning: Unknown type Monad
20:03:43 <lambdabot> Control.Monad.Error runErrorT :: ErrorT e m a -> m (Either e a)
20:03:43 <lambdabot> Control.Arrow returnA :: Arrow a => a b b
20:04:09 <shapr> But tomorrow morning I'll put the dual quad Xeons into one of the blades and install some flavor Linux. What's the best distro for doing eight-core Haskell goodies?
20:04:14 <riddochc> But as far as I can tell, it's not exactly an explanation anyway... more of a passing reference.
20:04:28 <shapr> I need to download an ISO(s) overnight, I figure.
20:05:22 <MyCatVerbs> hatds: hrmn? There's type Foo = Bar, for declaring type synonyms.
20:05:32 <riddochc> Anyway, yes, I read the a bit of read you a haskell before I started this book... up until the explanations there weren't working for me.
20:05:40 <hatds> MyCatVerbs: I want something like 'typeof'
20:05:58 <hatds> MyCatVerbs: type Foo = reverse
20:06:05 <MyCatVerbs> hatds: ah. Look for type reification in Haskell''. ;)
20:06:24 <edwardk> no idea, still on the drop =/
20:06:26 <cjs> I thought I'd seen an example somewhere once of library functions (outside of Control.Monad) that worked with arbitrary monads. Maybe something like a lookup :: Monad m => a -> b -> m c, in order to let the user of the library define the control flow and/or failure behaviour. Can anybody remind me what I'm really trying to bring to mind here?
20:06:44 <edwardk> cjs: Data.Map used to work that way for lookup
20:06:52 <edwardk> cjs: Frisby still uses that convention
20:07:03 <MyCatVerbs> cjs: lookup :: (Monad m) => Map k v -> k -> m v, is pretty common.
20:07:24 <MyCatVerbs> cjs: the idea is that you use the Monad's (return) for success, and its (fail) for failure.
20:07:26 <cjs> Ah, did it! My first thought was Data.Map.lookup, but then I looked it up and its result was Maybe a.
20:07:45 <cjs> Then I decided I might be going crazy. :-)
20:07:52 <MyCatVerbs> For example, if I do (lookup...) :: Maybe a, I get back either Just a, or Nothing.
20:08:08 <MyCatVerbs> But if I do (lookup...) :: [a], I get back either a singleton list or the empty list.
20:08:16 <cjs> But it seems to me that that idiom is no longer commonly used.
20:08:29 <riddochc> I'm kind of enjoying learning Haskell so far, because there are some new concepts I haven't run into in any other language I've used, and I enjoy a good conceptual challenge, but it's really seeming like there's no *single* introduction that really discusses every topic in a way that makes sense.
20:08:34 <cjs> Are there any examples perhaps using MonadPlus to gather result sets or anything like that?
20:09:00 <riddochc> So I find myself skipping back and forth between several.
20:09:01 <MyCatVerbs> Nah, it's pretty common, AFAIK.
20:09:25 <cjs> riddochc: No, I doubt there is. Haskell is huge and complex in that way. And Monads are just too general. They're used for control flow, state, and lord knows what else.
20:09:33 <MyCatVerbs> cjs: the thing is that most of these basic types are easily transformable to one another, so it doesn't matter too much.
20:09:36 <roconnor> edwardk I don't use listen or pass I don't think.
20:09:46 <roconnor> you should be able to omit them.
20:10:17 <roconnor> edwardk: pass is stupid anyways.
20:10:34 <edwardk> roconnor: yeah, trying the last couple of functions in here now
20:10:36 <MyCatVerbs> cjs: e.g. transforming from (Maybe a) to (Monad m) => (m a), is just a matter of (\x -> case x of { Nothing -> fail "nothing"; Just x -> return x; }
20:10:59 <riddochc> I must admit, though, I'm still leaning towards Lisp, when it comes to my language of choice. Or ruby, depending on what I'm doing.
20:11:29 <roconnor> maybe (fail "nothing") return
20:11:38 <roconnor> @type maybe (fail "nothing") return
20:11:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
20:11:52 <MyCatVerbs> roconnor: oh, nicer than what I'd written.
20:12:00 <MyCatVerbs> cjs: though there is a line of thought that says that the (fail) function should never, ever have been part of Monad's interface, which has kind of pushed that idea out of fashion a little.
20:12:21 <roconnor> @type maybe (fail "Error: Prelude nothing") return
20:12:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
20:12:36 <cjs> MyCatVerbs: Right. And making the default "error", well....
20:12:58 <riddochc> Thanks for the explanation of $. I appreciate that there's enough interest in haskell that I can ask about this on a friday evening anyway.
20:13:24 <roconnor> ugh, I'm not even sure my theorem is provable.
20:13:30 <MyCatVerbs> Yes. Putting (fail) in as defaulting to (error) basically screws up any hope whatsoever of being able to keep track of totality discipline with Monad.
20:13:34 <cjs> But also I can see a tension between how one woud want libraries structured for development of production-quality systems, and how one wants them structured for learning and experimentation.
20:13:35 <roconnor> this could make it hard to prove.
20:14:05 <idnar> MyCatVerbs: well, that's not a problem, just use MonadZerro instead (or whatever)
20:14:21 <cjs> MonadZorro? :-)
20:14:26 <idnar> haha
20:14:39 <cjs> What would that do, I wonder?
20:14:40 <MyCatVerbs> idnar: other way 'round. You have no assurance that nobody used (fail) in your Monad-using code.
20:15:01 <MyCatVerbs> idnar: of course you also have no assurance that nobody used (head []) or (undefined), but oh well.
20:15:04 <idnar> MyCatVerbs: I was referring to the "fail should never have been part of Monad" comment
20:15:31 <cjs> MyCatVerbs: Perhaps what we need for that is really a separate MonadControl class or something, for 'fail'.
20:15:37 <MyCatVerbs> idnar: oh sorry, my bad. Yes, should've been in MonadZorro or MonadError or something.
20:16:09 <MyCatVerbs> cjs: yes, this is the widely-held opinion, AIUI.
20:16:09 <idnar> "MonadZorro" has me bursting into little giggles every few seconds now
20:16:09 <wli> MonadZero and MonadError are the proper approaches. Monad should not have fail.
20:16:56 <MyCatVerbs> The \_ in MonadZorro's implementation of (>>) is where he hides the mask and sword while he's slumming it in order to pass unnoticed by the authorities.
20:17:07 <cjs> So what are the chances that we'll get a new version of the standard libraries with these things fixed. Maybe throw in Functor as a requirement for Monad, as well.
20:17:39 <edwardk> well my DNAMonad compiles, testing
20:17:44 <MyCatVerbs> cjs: approximately nil. All languages suck, and this kind of thing is IMHO the most inescapable reason why.
20:18:05 <cjs> "Haskell: we suck less."
20:18:38 <dons> no compromises!
20:18:40 <MyCatVerbs> I mean there are other reasons too, but most of them are possible to avoid, unlike cruft issues.
20:19:26 <roconnor> edwardk: I feel like it is 2007 all over again.
20:19:34 <edwardk> heh
20:20:08 <roconnor> dons: except for the MR
20:21:02 <dons> well, its going.
20:21:27 <dons> we already did the test that nothing breaks , and performance is fine.
20:21:46 <edwardk> well i suppose an implementation that causes you to spew memory is a bad idea to introduce into the code for Endo ;)
20:21:50 <edwardk> still waiting =)
20:22:21 <edwardk> otoh, i may have broken it for other reasons
20:23:01 <cjs> MR?
20:23:21 <koninkje> monomorphsim resriction
20:23:32 <cjs> Ah, that one.
20:24:07 <edwardk> @hpaste
20:24:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:24:32 <Saizan> oh, Endo there is the alien?
20:25:11 <edwardk> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4920#a4920 is where i took it, but it seems a tad slower
20:25:33 <edwardk> i may have screwed up the termination criterion or something
20:26:56 <edwardk> i may also be paying some n^2 cost in the mappends
20:27:57 <roconnor> edwardk: ;(
20:28:20 <roconnor> edwardk: what is runDNAMonad?
20:28:22 <edwardk> anything obviously wrong with that?
20:28:30 <edwardk> i just pasted extractRNA
20:28:39 <edwardk> which was the only one i needed to run your DNAexec
20:28:45 <wli> What are you guys doing with RNA and/or DNA?
20:28:54 <cjs> Saving Endo.
20:28:59 <edwardk> hah
20:29:26 <SubStack> wolfram alpha said a monad was some DNA thing
20:29:43 <edwardk> SubStack: it thinks its a protein
20:30:16 <SubStack> that's the thing
20:31:49 <SubStack> DNA is pretty lispy, modifying itself and what-not
20:32:48 <roconnor> edwardk: presumably you get the correct result.
20:33:17 <edwardk> roconnor: er it hasn't yet actually _terminated_ =)
20:34:41 <roconnor> oh my
20:34:45 <edwardk> going on ~15 minutes or so =)
20:35:00 <roconnor> edwardk: I bet you screwed up the termination condition
20:35:09 <edwardk> otoh the other version seemed to incrementally generate empty.rna
20:35:12 <edwardk> and this one doesn't
20:35:18 <edwardk> so i think i did something wrong
20:35:19 <edwardk> yeah
20:35:24 <roconnor> edwardk: check if "forever done" runs forever in ghci.
20:35:40 <edwardk> good idea
20:35:56 <roconnor> edwardk: oh, well, if you are not even generating any RNA, that is even worse.
20:36:14 <roconnor> I should generate RNA even when running forever.
20:36:54 <edwardk> extractRNA (forever done) undefined yields [] immediately
20:37:13 <roconnor> that's good
20:38:30 <edwardk> and tell works, hrmm
20:39:31 <roconnor> edwardk:  it seems a bit strange that z is used twice in bind.
20:39:35 <edwardk> going to undo the writer as state optimization and see what i get
20:40:23 <edwardk> it makes sense when you see 'z' as the failure continuation that has to be copied to both 'g' and the result of f
20:40:31 <roconnor> oh
20:40:31 <edwardk> just like k does
20:40:49 <roconnor> @src (>>=) Cont
20:40:50 <lambdabot> Source not found. You type like i drive.
20:40:51 <edwardk> 'z' is 'what to do when done'
20:41:10 <edwardk> 'k' is 'what to do when more'
20:43:42 <roconnor> k isn't used twice
20:44:10 <roconnor> but I find you explaintion for z plausible
20:44:13 <roconnor> your
20:44:37 <edwardk> thats because you do different things for the left and right side when you have more available.
20:46:13 <edwardk> DNAMonad g >>= f = DNAMonad (\k z s w-> g (\a s' w' -> getDNAMonad (f a) k z s' w') z) s w -- is that fully eta expanded
20:47:01 <edwardk> er swap the last s w over the )
21:01:10 <adamvo> is anybody familiar with the Control.Exception in base version 4?
21:02:04 <adamvo> I'm not sure how to go about catching all errors that happen, so that I can display a nicer error message with gtk2hs instead of to stderr
21:02:18 <edwardk> well, if i write out the result in reverse i'm faster at least
21:02:43 <roconnor> nooo
21:02:56 <roconnor> that's just wrong
21:02:57 <edwardk> so i should be able to difference list it
21:02:58 <adamvo> there's an ambiguous type variable
21:03:21 <Axman6> adamvo: SomeException is probably what you need
21:03:48 <edwardk> it shaved about 1/6th off the time
21:03:48 <roconnor> edwardk: I figured the cps transform would associate everything the correct way automagically
21:03:55 <Axman6> i think you need something like catch action (\SomeException e -> ...)
21:04:07 <Apocalisp> Given an [x] and a parser for x, I can find all the xs that will be consumed by the parser. Can the other way be achieved? Given a [Parser x] and an x, can we find all the parsers that would consume x?
21:04:10 <Axman6> but it's been a while since i've needed to use Control.Exception
21:04:31 <edwardk> i guess it associates everything the opposite way you'd like. i flopped the arguments w and w' in the mappend and bam, fast.
21:04:54 <adamvo> Axman6: thanks, that works
21:05:06 <Axman6> hooray :)
21:05:07 <roconnor> edwardk: that seems peculiar
21:05:14 <roconnor> edwardk: anyhow DList it
21:05:15 <dons> someone needs to write a 'so you want to migrate to the new exceptions?' post.
21:05:39 <roconnor> which is just another CPS transform
21:05:41 <roconnor> :)
21:05:42 <edwardk> roconnor: well, if you think about it, i _am_ appending to a list here
21:05:44 <Apocalisp> somebody should write a monad tutorial as well
21:05:44 <Axman6> dons: you've got plently of time right?
21:05:45 <Axman6> :P
21:06:01 <edwardk> and that will be slow, flipping that, made each tell into more or less a prepend
21:06:15 <dons> i have little  time :/ i try to write things as i get time though. i have some flights coming up, which is can be good blogging time.
21:06:20 <edwardk> which is the happy case for a list
21:06:30 <dons> but we need more people writing and building!
21:06:40 <Axman6> yeah id be writing more if i wasn't so bogged down with uni
21:06:51 <roconnor> edwardk: if all the appends were all associated the correct way, there would be no problem.
21:07:11 <roconnor> edwardk: but with the CPS transform I'm totally lost as to which way things are being appended.
21:07:20 <Axman6> luckily i am getting some haskell stuff done by helping a friend with her assignments in haskell for a course i did last semester
21:07:28 <Axman6> s/semester/year
21:07:53 <edwardk> here they are being appended on the end. so you have a lot of short strings beind appended to a big one
21:08:12 <roconnor> edwardk: did you check that the "backwards append" actually produces the wrong result?
21:08:20 <edwardk> yeah
21:08:24 <edwardk> it was bytewise reversed
21:08:28 <Axman6> dons: Ben L wrote this assignment... and i think he forgot how little the students in the course actually knew. even i'm finding it hard >_<
21:08:44 <dons> Axman6: fwiw, i set a goal when i was doing my hons. to try to write some haskell every day. pays off over 5 years
21:08:59 <dons> i bet benl's assignments are fun :)
21:09:03 <roconnor> edwardk: hmm, I wonder if I had the same problem with my Codensity implementation.
21:09:12 <Axman6> yeah this one's pretty cool
21:09:13 <roconnor> edwardk: I think I would have noticed.
21:10:32 <edwardk> i think effectively one of your other involutions from nesting everything probably played the same role as a difference list
21:10:44 <roconnor> good
21:10:53 <roconnor> I mean, I have no idea what you said.
21:11:00 <edwardk> using the difference list i get basically the same speed as my reversed version
21:11:08 <roconnor> and the right answer?
21:11:24 <edwardk> yep
21:11:28 <edwardk> so only a few % faster
21:11:33 <roconnor> good
21:11:40 <roconnor> that's what I expected
21:11:46 <Axman6> dons: supposed to be writing the AI for a game of othello (Go?). the problem is that there's some pretty confusing data structures (like, this tree has members of this kind, which hold more of those trees... sounds easy enough, but took a while to figure out)
21:11:52 <Apocalisp> Ah hah. What I want is "Predicate Matching".
21:12:05 <edwardk> now to optimize :)
21:12:43 <Saizan> can the cps'ed writer-as-state produce results lazily?
21:12:59 * Saizan tries it
21:15:27 <roconnor> edwardk: if you branch I can give you instructions on how to get my pre-cps monad.
21:15:29 <edwardk> fully applying gets me a few percent more
21:15:46 <roconnor> edwardk:  that should be 4 times slower
21:15:50 <roconnor> but maybe GHC has changed
21:15:55 <edwardk> i'm ok with this one as a competitor
21:16:01 <roconnor> ok
21:16:21 <roconnor> edwardk: what does fully applying get mean?
21:16:24 <roconnor> eta expand?
21:16:29 <Saizan> it appears like it can't
21:16:57 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4920#a4922
21:17:06 <edwardk> yeah
21:17:25 <edwardk> which causes ghc to try to call with all arguments
21:17:37 <roconnor> that's moronic
21:17:45 <roconnor> damn you GHC!!!!
21:19:32 <edwardk> do you always tell singletons?
21:19:55 <roconnor> I don't think so
21:19:59 <roconnor> but I'm not certain.
21:20:08 <roconnor> it's possible
21:20:34 <roconnor> grep tell
21:20:55 <roconnor> GHC always disappoints me
21:21:06 <edwardk> trying with an optimized tell'
21:21:50 <roconnor> I hope tell is inlined and ([x]++) gets compiled to (x:)
21:21:57 <roconnor> but then again, GHC always disappoints me.
21:22:23 <edwardk> tell' :: RNA → DNAMonad (); tell' w' = DNAMonad (λk _ s w → k () s (λt → w (w':t))) -- gave a 0.5% speedup or so.
21:22:28 <edwardk> but thats in the margin of error
21:26:54 <Jedai> roconnor: I seriously doubt it
21:27:06 <roconnor> Jedai: doubt what?
21:27:33 <Jedai> roconnor: that ([x]++) get compiled to (x:)
21:27:39 <roconnor> I bet it does
21:27:52 <roconnor> (with -O2)
21:28:16 <dolio> Stupid non-monospace monospace...
21:28:18 <Twey> I doubt it makes much difference anyway
21:28:24 <Twey> It's still O(1)
21:28:30 <Jedai> Twey: That I can believe though
21:28:37 <koninkje> I'm pretty sure it does when rewrite rules are enabled (e.g. -O2), though take a look at the core
21:28:38 <roconnor> Jedai: I bet I can dig up a GHC rule
21:28:43 <edwardk> Twey: most of what we're obsessing about is trying to change the constant ;)
21:28:47 <Twey> Heh
21:29:07 <roconnor> @source GHC.List
21:29:07 <lambdabot> GHC.List not available
21:29:13 <Jedai> roconnor: GHC Rules don't let you pattern match against a value
21:29:38 <Jedai> Or at least I don't think they do
21:31:22 <Jedai> As far as I can tell, the best you can hope for, supposing some inlining is to have ([x]++) compiled to (x:).([]++)
21:32:02 <SubStack> gah, it should not be possible to patent maths
21:32:03 <SubStack> but it is
21:32:11 <roconnor> which GHC module is ++ defined in?
21:32:22 <Jedai> And of course ([]++) is id, but you can't express that with GHC rules, it would have to be hardcoded in GHC, I'm not sure it jibes well with GHC philosophy
21:32:54 <Jedai> @source Prelude
21:32:54 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
21:32:59 <glguy> specconstr ought to be able to tell []++ is id
21:33:21 <hatds> call pattern specialization on (++) -- isn't it?
21:33:41 <roconnor> Hmm, that file has no rules
21:33:49 <hatds> well I mean in principle
21:34:05 <Jedai> @source GHC.Base
21:34:06 <lambdabot> GHC.Base not available
21:34:51 <Jedai> glguy: That's good, then I guess this optimization is possible, is it really done ?
21:34:54 <hatds> Nil is a constructor for List, so (++) can be specialized on it
21:35:08 <roconnor> let's see
21:35:10 <roconnor> "++"    [~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
21:35:33 <koninkje> Jedai: why can't you specify ([]++) = id as a rule?
21:36:15 <Jedai> koninkje: As far as I can tell that's not how rules work
21:36:29 <Jedai> koninkje: rules don't pattern match against value
21:36:31 <roconnor> "foldr/single"  forall k z x. foldr k z [x] = k x z
21:36:33 <roconnor> ta da!
21:36:39 <koninkje> Jedai: yeah they do
21:36:49 <roconnor> Jedai: I think I did it.
21:36:49 <dons> ghc gets rid of ++[] via the ++ rule, iirc
21:36:58 <Jedai> Ok I'm wrong... That's a good thing :)
21:37:05 <dons> yeah, it removes f = (++[])
21:37:05 <dons> {-# INLINE f #-}
21:37:06 <dons> x = f "haskell"
21:37:11 <roconnor> "augment/nil"   forall (g::forall b. (a->b->b) -> b -> b) .
21:37:13 <roconnor>                         augment g [] = build g
21:37:18 <roconnor> dons: that uses the augment/nil rule
21:37:21 <dons>     1 ++
21:37:21 <dons>     1 augment/nil
21:37:22 <dons>     1 fold/build
21:38:02 <roconnor> dons: and getting rid of [x]++ uses the foldr/single rule right?
21:38:32 <roconnor> Jedai: you owe me a coke!
21:38:35 <roconnor> I think
21:39:02 <dons> where 'x' is a constant?
21:39:13 <roconnor> where x is some term
21:39:17 <roconnor> some expression
21:39:32 <dons> doesn't fire.
21:39:34 <Jedai> roconnor: I'll be more than happy to give you one ! GHC Rules are more powerful than I believed. :)
21:39:38 <roconnor> god dam nit.
21:39:41 <dons> e.g. f x = (++[x])
21:39:41 <dons> {-# INLINE f #-}
21:39:41 <dons> x = f 'x' "haskell"
21:39:47 <roconnor> no no
21:39:51 <roconnor> [x]++
21:40:13 <dons> as in?
21:40:18 <dons> x = ['x'] ++ "haskell" ?
21:40:24 <roconnor> ya
21:40:37 <dons> nope :/
21:40:46 <dons> need more list algebra rules
21:41:33 <roconnor> "foldr/single"  forall k z x. foldr k z [x] = k x z
21:41:38 <roconnor> seems like it should fire
21:42:27 <edwardk> trying out optimizing consume
21:44:27 <roconnor> dons: what GHC command do you do to list rules?
21:46:18 <dolio> Use ghc-core.
21:47:17 <dons> I use ghc-core
21:53:52 <roconnor> ghc-core is a program?
21:54:54 <dons> yep
21:55:03 <dons> a ghc wrapper to display intermediate info
21:55:07 <roconnor> I don't have it
21:56:20 <dons> cabal install ghc-core
21:57:01 <roconnor> ah -ddump-simpl-stats
21:57:48 <roconnor> dons: optimizing ['x']+"haskell" seems to work for me
21:57:56 <roconnor> 5 RuleFired
21:57:58 <roconnor>     1 ++
21:57:59 <roconnor>     1 augment/build
21:58:01 <roconnor>     1 foldr/single
21:58:02 <roconnor>     1 unpack
21:58:04 <roconnor>     1 unpack-list
21:58:07 <roconnor> foldr/single is the key rule
21:58:43 <Jedai> ghc-core also give you Core output which is useful to check if the rule fired at the good place
21:59:03 <roconnor> Jedai: Well I'm pretty convinced. :)
21:59:12 <roconnor> reading Core is a big pain
21:59:23 <roconnor> unless ghc-core makes pretty core
21:59:35 <Jedai> I tried myself and it didn't optimize it, I believe that other rules interferred
21:59:48 <roconnor> :/
22:00:05 <Jedai> roconnor: the core is colored and prettier than otherwise
22:00:21 <roconnor> $ ghc --version
22:00:23 <roconnor> The Glorious Glasgow Haskell Compilation System, version 6.8.2
22:00:33 <Jedai> roconnor: also if you use html output you have links from identifier to their definition
22:00:38 <roconnor> Jedai: is your and dons, version of GHC broken?
22:00:44 <Jedai> 6.10.2
22:00:57 * roconnor won't upgrade
22:01:23 <dons> roconnor: did you look at  the core?
22:01:35 <roconnor> not with ghc-core
22:01:42 <dons> ah, i get no foldr/single
22:01:54 <roconnor> what rules do you get?
22:01:55 <dons> weird
22:01:59 <dons> module M (x) where
22:02:00 <dons> x = ['x'] ++ "haskell"
22:02:12 <dons>     1 augment/build
22:02:12 <dons>     1 fold/build
22:02:12 <dons>     1 foldr/app
22:02:13 <roconnor> $ cat foo.hs
22:02:14 <roconnor> main = putStr (['x']++"haskell")
22:02:21 <dons> curious
22:02:39 <dons> nope.
22:02:55 <roconnor> dons: oh man
22:03:00 <roconnor> that doesn't seem good at all.
22:03:27 <dons> 6.10.3
22:05:23 <roconnor> dons: what other rules are fired?
22:05:33 <roconnor> It is pecular that fold/build fires.
22:05:40 <Jedai> roconnor: fold/build and foldr/app
22:06:23 <roconnor> presumably at least ++ fires?
22:06:25 <cjs> How do I partially apply the subtraction operator to a right-hand side?
22:06:40 <roconnor> cjs: use "subtract"
22:06:46 <cjs> Ah.
22:06:47 <roconnor> @(subtract 3) 4
22:06:48 <lambdabot> Unknown command, try @list
22:06:51 <roconnor> > (subtract 3) 4
22:06:52 <lambdabot>   1
22:09:07 <dolio> Where is foldr/single defined?
22:09:40 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html
22:09:52 <dons> Base.lhs:"foldr/single"  forall k z x. foldr k z [x] = k x z
22:13:07 <Jedai> roconnor: the problem is not fold/build though
22:13:29 <roconnor> something seems broken
22:13:35 <Jedai> roconnor: The problem is that foldr/app runs before foldr/single...
22:13:48 <roconnor> oh
22:14:24 <Jedai> "foldr/app"     [1] forall ys. foldr (:) ys = \xs -> xs ++ ys
22:14:48 <roconnor> http://www.haskell.org/ghc/docs/6.8.2/html/libraries/base/src/GHC-Base.html is the same
22:15:14 <Gracenotes> hm? What performance gain is there for ++ over foldr?
22:17:52 <edwardk> Gracenotes: ++ should eventually 'get out of the way' while foldr will sit there replacing constructors on you
22:18:12 <Gracenotes> what
22:18:15 <edwardk> or wait
22:18:20 <edwardk> @src (++)
22:18:20 <lambdabot> []     ++ ys = ys
22:18:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:18:20 <lambdabot> -- OR
22:18:20 <lambdabot> xs ++ ys = foldr (:) ys xs
22:18:31 <edwardk> heh guess not
22:18:38 <edwardk> well
22:19:11 <edwardk> the defintiion should be the same, perhaps just better specialization
22:19:58 <edwardk> i was thinking for a sec that the difference was like anamorphism vs. apomorphism, but its not
22:20:09 <Jedai> This rule doesn't seem very useful, except maybe to beautify the core afterward
22:20:46 <roconnor> which rule?
22:20:53 <Jedai> foldr/app
22:20:57 <Saizan> "foldr/app"     [1] forall ys. foldr (:) ys = \xs -> xs ++ ys
22:21:28 <Jedai> The annoying one that seems to interfere with foldr/single in your exemple
22:21:44 <roconnor> Jedai: what are all the rules that fire for you?
22:22:05 <roconnor> I still don't get why you are seeing a fold/build rule fire.
22:22:14 <magical_pony> BONUS: your haskell guide is amazing. that is all.
22:22:23 <Jedai> 1 ++
22:22:23 <Jedai>     1 augment/build
22:22:23 <Jedai>     1 fold/build
22:22:23 <Jedai>     1 foldr/app
22:22:58 <Gracenotes> bonus has not spoken for 10 hours ;_;
22:23:08 <Gracenotes> *poke* *poke*
22:23:40 <Jedai> roconnor: I don't think fold/build is the problem, from what I see there's no way it would interfere with  foldr/single
22:24:06 <roconnor> Jedai: it doesn't fire for me
22:25:14 <Jedai> roconnor: Right but ghc 6.10 is supposed to do things better than 6.8, so we can suppose that some of the others optimization makes it possible to run it
22:26:18 <roconnor> that doesn't seem like a safe assumption to me
22:26:20 <dons> Jedai: nope.
22:26:40 <roconnor> this is a tiny tiny piece of code we are talking about
22:26:50 <dons> its entirely possible rule firing could be messed up. uvector rules seem to pass, fwiw, but there's no regressoin suite for build/foldr
22:27:08 <dons> so a bug report about "why didn't the single rule fire?' is well worth it.
22:27:12 <roconnor> dons: scary
22:27:14 <Jedai> Right, but I still don't see why fold/build would mess up foldr/single
22:27:24 <dons> i have a regression suite for streams. they're ok.
22:27:46 <dons> but foldr/build is 15 years old.we didn't have test suites for libs then
22:27:48 <Jedai> dons: On that I agree, but it seems to me that the problematic rule is foldr/app, not fold/build
22:27:56 <roconnor> Jedai: the foldr/build rule detroys the foldr!
22:28:09 <Jedai> roconnor: Not this one
22:28:12 <roconnor> I mean the fold/build rule destorys the foldr
22:28:26 <roconnor> huh?
22:28:29 <roconnor> "fold/build"    forall k z (g::forall b. (a->b->b) -> b -> b) .
22:28:31 <roconnor>                 foldr k z (build g) = g k z
22:28:32 <roconnor> see
22:28:36 <roconnor> it eliminates the foldr
22:28:47 <roconnor> no foldr means no foldr/app rule can fire.
22:29:08 <roconnor> dons: where do I post the bug?
22:30:12 <Jedai> roconnor: foldr/app runs, so it's obvious that fold/build didn't destroy the foldr where foldr/single should run
22:30:48 <roconnor> good point
22:31:24 <roconnor> Jedai: which only serves to confuse me more :)
22:31:32 <Jedai> roconnor: I think fold/build destroy a foldr indeed but not the foldr created by the "++" rule
22:31:46 <Jedai> roconnor: maybe this foldr is somewhere in putStr
22:31:48 <roconnor> Jedai: what is your code?
22:32:10 <Jedai> hello = ['h'] ++ "ello"
22:32:11 <Jedai> main = putStr hello
22:32:18 <roconnor> maybe we should be trying dons's code
22:33:02 <roconnor> module Foo where x = ['x']++"haskell"
22:33:22 <roconnor> 5 RuleFired
22:33:24 <roconnor>     1 ++
22:33:25 <roconnor>     1 augment/build
22:33:27 <roconnor>     1 foldr/single
22:33:29 <roconnor>     1 unpack
22:33:30 <roconnor>     1 unpack-list
22:34:49 <Jedai> roconnor: Ok, I avow myself puzzled :
22:35:08 <roconnor> What rules do you have with module Foo
22:35:13 <Jedai> 6 RuleFired
22:35:13 <Jedai>     1 ++
22:35:13 <Jedai>     1 augment/build
22:35:13 <Jedai>     1 fold/build
22:35:13 <Jedai>     1 foldr/app
22:35:14 <Jedai>     1 unpack
22:35:16 <Jedai>     1 unpack-list
22:35:17 <roconnor> BTW, it seems you were half right about [
22:35:35 <roconnor> BTW, it seems you were half right about [x]++ not being optimized.  Let's call our bet a draw :)
22:35:55 <Jedai> I don't see a foldr to destroy other than the one that foldr/app touch afterward...
22:36:45 <Jedai> roconnor: No no, you were correct, I thought GHC rules less powerful than they really were. Though they remain confusing in their application...
22:38:08 <roconnor> Jedai: btw, does []++ optimize?
22:38:15 <roconnor> should call foldr/nil
22:39:14 <Jedai> roconnor: It does
22:39:31 <roconnor> oh
22:39:41 <roconnor> what are all the rules that fire?
22:42:02 <dolio> ++, augment/build, foldr/nil, unpack, unpack-list
22:42:50 <Jedai> I don't see where fold/build run in module Foo where x = ['x']++"haskell"
22:45:35 <roconnor> dolio Jedai : what version of GHC are you running?
22:45:42 <dolio> 6.10.3
22:45:44 <Jedai> roconnor: 6.10.2
22:46:06 <roconnor> You both agree about the 5 rules for the foldr/nil case?
22:46:19 <Jedai> roconnor: I do
22:47:17 <dolio> Incidentally, rewriting 'foldr (:) ys' into '\xs -> xs ++ ys' allows it to then be rewritten into '\xs -> augment (\c n -> foldr c n xs) ys'.
22:47:34 <Jedai> dolio: Nope, look at the phases
22:47:38 <roconnor> dolio: the rule sequences prevent loops like that
22:47:43 <roconnor> er phases
22:47:44 <roconnor> ya
22:47:58 <Jedai> dolio: "++" is [~1] and "foldr/app" is [1]
22:48:19 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/3234
22:48:26 <dolio> Is [1] after [~1]?
22:49:02 <Jedai> dolio: Yes, I believe so, [~1] is until phase 1 and [1] is from phase 1 on
22:49:09 <dolio> Ah.
23:02:22 <hatds> Nil is a constructor for List, so (++) can be specialized on it
23:02:29 <hatds> ignore me :)
23:02:38 <Jedai> roconnor: The problem appears to be the String in particular
23:03:44 <Jedai> roconnor: their particular optimisation create a build around the ['h'] which remove the foldr before foldr/single can be applied
23:04:18 <Jedai> roconnor: with other types foldr/single still fire correctly
23:05:08 <Jedai> roconnor: I suspect that details of the moment of inlining of build explain the difference between 6.8 and 6.10
23:05:57 <happycamper> alo alo
23:06:17 <Jedai> happycamper: Yes ?
23:06:38 <happycamper> saying hello to make sure this is working. :D
23:07:06 <Axman6> happycamper: it is, hooray, you win!
23:07:16 <happycamper> well, sarcasm is lovely.
23:07:34 <happycamper> I am looking for someone
23:07:45 <edwardk> no, you really do win, you're our 5000th customer today.
23:07:57 <happycamper> a professional programmer to help me flesh out an idea.
23:07:58 * Axman6 wasn't being sarcastic :(
23:08:05 <edwardk> please remain still while we take down your personal information to send you your prize =)
23:08:11 <happycamper> lol ed
23:08:14 <Jedai> happycamper: Maybe you could just tell you what you want to do...
23:08:26 <Jedai> *us
23:08:29 <happycamper> ...
23:08:42 <happycamper> well, I kinda don't want to spread the idea to far.
23:08:45 <happycamper> too*
23:09:00 <TomMD> Then IRC is likely the wrong place to find help.
23:09:11 <happycamper> really? hrm.
23:09:21 <tessier> It burns when I pee. What do you guys recommend?
23:09:23 <TomMD> If you desire professional help and confidentiallity then I'd say so.
23:09:31 <bpalmer> tessier: consider a stronger type system.
23:09:35 <Jedai> happycamper: Yep, wrong place, except if you're looking to pay your helper (still wrong place but well...)
23:09:49 <tessier> bpalmer: Definitely. Next time I'll have more protection.
23:09:57 <Axman6> tessier: asking for help on IRC. we're all doctors here
23:10:00 <coCocoa> happycamper: How about Just tell us 1) and 2). You can save "????" and "Profit!" for yourself, that way. ;)
23:10:02 <Cale> tessier: A song by Frank Zappa entitled "Why Does It Hurt When I Pee?" might give you some ideas.
23:10:48 <happycamper> well, I appreciate the advise.  I am not knowledgeable to pull off what I want to do, and really don't want to openly share.  Again, thanks all.
23:11:05 <edwardk> heya kowey
23:11:21 <Jedai> happycamper: Don't forget you can still ask specific questions here*
23:11:26 <kowey> hey, edwardk :-)
23:11:30 <Axman6> happycamper: we're all about sharing here
23:11:51 <sjanssen> @users
23:11:52 <lambdabot> Maximum users seen in #haskell: 658, currently: 539 (81.9%), active: 13 (2.4%)
23:11:55 <Jedai> happycamper: We're not going to piece together your idea from little bit and steal it... probably
23:12:20 <happycamper> I really do appreciate it.  and I would steal it if I were you.
23:12:21 <Axman6> not unless it's a totally awesome idea
23:12:21 <happycamper> lol
23:12:25 <coCocoa> Jedai: You never know, though - we're wicked smart, here. ;p
23:12:35 <happycamper> I really truely think that this is a REALLY good idea.
23:12:45 <happycamper> but, yall dont know me... so hard to judge
23:12:50 <happycamper> :D
23:13:29 <edwardk> happycamper: one thing you'll find about programmers is they typically have more than enough work to do and enough irons in the fire that they really don't usually want another project =)
23:13:30 <happycamper> I think it would be "freaking sweet" to pull it off... and the ad revenue would be insane.  grr... reaches for programming book :P
23:13:51 <happycamper> i'd image so ed.
23:14:02 <happycamper> Still, I am branching out. :D
23:14:16 <sjanssen> happycamper: look on craiglist?  Or one of those rent-a-coder sites?
23:14:37 <happycamper> tbh, didn't realize there was a rent a coder website...
23:14:38 <happycamper> lol
23:15:02 <sjanssen> any way, if you need a programmer, you'll probably need to give them money, and #haskell isn't a great place to look
23:16:05 <happycamper> roar
23:16:38 <sjanssen> happycamper: so do you have specific questions for Haskell?
23:16:43 <sjanssen> s/for/about
23:16:58 <TomMD> If Haskell were still alive I'd have specific questions for him.
23:17:31 <glguy> for example?
23:18:02 <Axman6> "do you like this totally sweet language we named after you?"
23:18:06 <TomMD> For a silly start, what does he think of having a programming language named in his honor using a name he was never fond of ;-)
23:18:13 <bpalmer> "Are you comfortable in that coffin?"
23:18:16 <solrize_> i'd invite him out for some of that spicy indian stew, i forget what it's called
23:19:09 <TomMD> Beyond that - I'd have to read papers he actually wrote - not having read his papers I always felt the terms 'curry' and 'uncurry' should be reversed.
23:19:50 <TomMD> I suppose claiming something in the form of A cross B is your form 'curried' would be a bit persumptuous.
23:22:54 <hydo> Is it still generally accepted that on osx, you should download the GHC bin package instead of using ports/fink?
23:23:12 <Cale> TomMD: I doubt he named the terms after himself.
23:23:25 <TomMD> Well, they are named after him now.
23:23:35 <Cale> TomMD: It's more common that the author uses some notation, and then other people name it after him.
23:23:43 <coCocoa> I always think of currying a horse, to keep straight which one does what. :)
23:23:46 <TomMD> Yes, I understand your point.
23:24:10 <Cale> hydo: I'm not sure, but given that ports will probably make you compile it yourself, yeah, the package will save a lot of time.
23:24:33 <hydo> Yea, true.  Didn't think of it that way...
23:24:40 <TomMD> I've decided that compiling ghc in an emulator is a bad thing to do.
23:25:43 <sjanssen> hydo: yes, I've heard the .pkg installer has seen quite a bit of work lately
23:25:58 * glguy has always just used macports
23:26:05 <Jedai> TomMD: Compiling GHC when you don't abolutely have to is a bad idea anyway
23:26:26 <TomMD> Jedai: I have too - some modifications that don't come in a binary from anyone else.
23:26:36 <TomMD> *have to
23:26:55 <Jedai> TomMD: What are they ?
23:26:56 <sjanssen> off topic: I wonder if anyone has made an argument against from-source packaging from an environmental perspective
23:26:58 <glguy> I have two
23:27:20 <Jedai> glguy: I have three myself
23:27:25 <TomMD> Jedai: Some research I'm embarking on as part of my studies at PDX.
23:27:34 <glguy> Jedai, want to buy mine?
23:27:49 <Jedai> glguy: Maybe more in fact, I should still have some old development version around
23:27:50 * wli cries
23:27:57 * wli used to live in PDX.
23:28:10 <glguy> Jedai, what are we talking about?
23:28:36 <Jedai> glguy: I'm not sure but I still have three or four
23:28:42 <TomMD> wli: Yes, I recall you lamenting your loss before.
23:29:32 <Jedai> TomMD: Well, when you're testing extensions to GHC you don't have much choice anyway...
23:30:37 <TomMD> Yep.  I'm hoping to add new pragma so GHC will spit out sort of a static program analysis - but that would be a ways away.
23:30:55 <glguy> sjanssen, I imagine we have a long way to go before compiling or not makes a significant difference in envrionmental footprint
23:31:39 <Jedai> sjanssen: You could say that the CPU cycles used to compile are compensated by the CPU cycles spared by more efficient executable but I would ask for statistics...
23:32:45 <sjanssen> Jedai: I'm highly skeptical of that claim
23:33:23 <Jedai> sjanssen: I would be too thus the call for statistics
23:34:05 <TomMD> What if the compiled copy saves time at the correct moment, thus stopping a coal plant from spewing excess emissions?
23:35:04 <glguy> does GHC's -fasm do much by way of arch specific optimizations?
23:35:51 <glguy> I'd be surprised if a self-compiled version had any benefit at all, performance wise
23:36:01 <Jedai> glguy: Not yet I believe but it should only improve
23:36:06 <TomMD> glguy: Not sure how well it performs when you compare architectures against each other, but for my uses on x86_64 the difference is nill between that and -fvia-c.
23:36:35 <glguy> the only time that compiling it yourself helps if you enable features that aren't on all processors in your architecture
23:36:48 <glguy> but I didn't think that ghc's assembler made use of a ny of those anyway
23:38:30 <glguy> for example, using -march=native with gcc
23:40:54 <mrbabbyman> how do I do an x combinator in haskell
23:41:12 <copumpkin> how is mrbabbyman formed?
23:42:45 <mrbabbyman> copumpkin: ??
23:45:31 <glguy> mrbabbyman, do you have a URL explaining the X combinator?
23:46:06 <sjanssen> mrbabbyman: alternatively, what does X look like in LC?
23:46:16 <davidmccabe> I'm rewriting some python code in haskell which prints out a table. It's basically going to concatenate a bunch of strings together in a nested loop. What would be the idiomatic haskell way to do that?
23:46:52 <sjanssen> davidmccabe: perhaps a concatMap?  Or list comprehension?
23:48:07 <davidmccabe> For the curious, here's the original: http://pastie.textmate.org/private/jvk1qhbsan04aixzszlelg
23:49:09 <sjanssen> davidmccabe: you could do a fairly direct translation of that, but it wouldn't be the best way
23:53:53 <davidmccabe> sjanssen: That's what I figured.
23:57:55 <Jedai> davidmccabe: I would probably write this in some small functions
23:58:34 <davidmccabe> Oops, have to go! Sorry to ask and run.
