01:04:26 <hackagebot> reflection 0.2.0 - Functional Pearl: Implicit Configurations (EdwardKmett)
01:04:43 <edwardk> ah, i've been tattled on by hackagebot
01:05:07 <gwern> the bot knows no lies
01:06:19 <ray> time your uploads for when it's down
01:20:14 <Ford_Perfect> Hi one beginner question, how can i use timers in haskell? i need to run function every 60 seconds in order to get fresh data in program cache?
01:23:48 <Gertm> what's the mod key for the 'right logo/context' key? (I asked in #xmonad but they're all asleep)
01:24:33 <ksf> huh?
01:24:39 <ksf> by default, xmonad uses alt.
01:25:39 <ksf> if you want to figure out the code of a particular key, xev is helpful.
01:57:33 <ksf> do we have a full-haskell alternative to readline by now?
01:57:38 <ksf> if yes, what's it called?
01:57:42 <mxc> haskelline
01:57:45 <mxc> not sure if its complete
01:58:00 <mxc> ooh, i think i win a prize:
01:58:02 <ksf> doesn't seem to be on hackage
01:58:03 <mxc> Com/EKC/Platform1/Instances/Binary.hs:1:0:ghc: panic! (the 'impossible' happened)
01:58:03 <mxc>   (GHC version 6.10.4 for i386-apple-darwin):
01:58:03 <mxc> 	Could not convert Language.Haskell.TH.Syntax.Dec to Language.Haskell.Exts.Syntax.Decl
01:58:22 <mxc> oops
01:58:25 <mxc> spelled wrong
01:58:26 <mxc> http://hackage.haskell.org/package/haskeline
02:00:05 <ksf> works like a charm
02:00:07 <mxc> (my GHC panic was from Data.Derive not playing nicely with type synonyms, which i think is a known bug, so no prize :(
02:16:56 <ray> @ghc
02:16:57 <lambdabot> ghc says: WARNING: SE CAFs unsupported, forcing UPD instead
02:35:53 <poe> Ford_Perfect: file:///usr/local/share/doc/ghc/libraries/base/Control-Concurrent.html threadDelay & co.
02:37:06 <Ford_Perfect> thanks poe
02:56:00 <hackagebot> haddock 2.5.0 - A documentation-generation tool for Haskell libraries (DavidWaern)
03:15:26 <gwern> http://www.liveink.com/ <-- interesting. basically parses the logical structure of the english for you, and turns it into a tab-formatted tree
03:16:00 <gwern> can't figure out if they predate http://www.readingonline.org/articles/r_walker/ though
03:17:31 <gwern> oh nice, there's a patent on this walker's research from 1998: http://www.patentstorm.us/patents/5802533.html
03:17:35 <gwern> -_-
03:18:23 <gwern> way to go there. no mention of the patent at all in his article
03:18:30 * gwern thinks that's academically dishonest
03:19:54 <pozic> How can parsec parse the grammar: x:= <number>|x'?'
03:20:19 <pozic> Besides the number alternative there are many other alternatives.
03:20:22 <mauke> equivalent to x := <number>
03:20:55 <pozic> mauke: the '?' here is a literal char.
03:21:04 <mauke> oh, whoops
03:21:36 <mauke> x = number >> many (char '?')
03:22:20 <pozic> I was mostly worried about the alternatives.
03:22:28 <pozic> But I think the same applies.
03:45:23 <eu-prleu-peupeu> hi
04:25:47 <Philip> hi
04:30:08 <fbru02> hi !
04:31:00 <Philip> ;)
04:35:45 <Philip> how do I have to declare this? d f x = ((f (x + 0.0001)) - (f (x - 0.0001))) / 0.0002
04:36:53 <Oejet> Philip: Using ghc or ghci?
04:37:05 <Philip> Oejet: yes.. ghc
04:37:18 <mauke> what do you mean by "declare"?
04:37:28 <Philip> Oejet: actually I'm using runhaskell
04:37:48 <Oejet> Philip: Then it should work. Any syntax errors?
04:37:51 <Philip> mauke: something like d :: (a -> a) -> a -> a
04:38:02 <mauke> :t let d f x = ((f (x + 0.0001)) - (f (x - 0.0001))) / 0.0002 in d
04:38:04 <lambdabot> forall a a1. (Fractional a1, Fractional a) => (a -> a1) -> a -> a1
04:38:07 <Philip> Oejet: kind of... it says:
04:38:13 <Philip>     No instance for (Num (a -> a1))
04:38:14 <Philip>       arising from the literal `2' at hello.hs:9:16
04:38:14 <Philip>     Possible fix: add an instance declaration for (Num (a -> a1))
04:38:21 <Philip> bla x = x + x
04:38:24 <Philip> print (d (bla 2))
04:38:55 <mauke> did you mean print (d bla 2)?
04:38:59 <Philip> mauke, lambdabot: thanks... I'll try both
04:39:09 <Philip> mauke: yes ;)
04:39:32 <Philip> mauke: ok it works
04:40:10 <dschoepe_> Philip: you don't have to say thanks to a bot by the way :)
04:40:12 <Oejet> It says that it expects (bla 2) to be a function, because you called it as (d (bla 2)).
04:40:44 <Philip> dschoepe_: lol
04:40:50 <Philip> dschoepe_: very smart bot ;)
04:40:56 <Oejet> Philip: Do you understand the error message now?
04:41:02 <dschoepe_> Philip: (lambdabot is the bot, not mauke)
04:42:14 <Philip> Oejet: kind of... although what I don't understand... this error message (the possible fix to be precise) kind of suggests that this (d (bla 2)) could be made valid syntax
04:42:21 <Philip> dschoepe_: ok ;)
04:42:31 <EvilTerran> it is valid syntax
04:42:36 <EvilTerran> it just means something different
04:43:49 <Philip> ok
04:45:06 <Oejet> Philip: Yes, I think, it says, that if you made 'f' an instance of Num, you could use '+' on two of them, and it would then know how to evaluate it.
04:46:28 <Philip> Oejet: really? but what would it do with f (x + 0.0001)?
04:47:20 <Oejet> Well, or rather the other way around: If you could make the litteral '2' an instance of Num(a->a1) it would know how to do it.
04:47:40 <Oejet> *literal
04:48:11 <Philip> interesting...
04:50:07 <Oejet> So if numbers (2, 0.001, etc) could both be added (Num, +) and applied as functions (a->a1).
04:50:45 <Oejet> Which is where my understanding stops too.
04:51:02 <Philip> ;)
04:51:42 <mauke> a "number" is anything that implements the Num interface
04:51:49 <mauke> you can make functions do that
04:52:14 <Philip> oh ok
04:53:00 <Oejet> So instead of telling you that you are _wrong_, it tells you, that in principle you are almost right, if you just implement the type classes, as mauke said.
04:58:52 <Philip> A functionality I sometimes miss in C++ when using templates ;)
05:08:25 <dafra> hi, is there some way to parttern match several constructors in the same pattern, like in OCaml : case op of Add | Sub -> ...   ?
05:09:18 <mauke> no
05:09:28 <dafra> :(
05:09:58 <ziman> not exactly an answer to you question but I usually use "BinOp Add Term Term" just because all binary ops have similar properties
05:10:48 <ziman> this can be used not only with terms and operators, of course
05:11:07 <dafra> ziman : i do the same.
05:12:09 <dafra> ziman: but how to group additive and multiplicative cases : case op of Add,Sub -> additive | Mul,Div -> multiplicative
05:15:06 <pejo> dafra, fun op | isAdditive op = additive RET | isMultiplicative = multiplicative RET | otherwise = panic "Ooops"
05:15:33 <pejo> Doesn't do exactly what you want, but might be readable depending on your context.
05:15:51 <Berengal> I think you'll need either a function to do it for you and use guards, or make a few new types (AdditiveOp, MultiplicativeOp etc)
05:30:44 <HugoDaniel> can someone help me ouy with this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3337#a3337 plz ?
05:33:21 <Lemmih> HugoDaniel: 'R' only takes a single type argument. You're giving it two.
05:35:51 <ziman> @kind InterleavableIO
05:35:52 <lambdabot>     Not in scope: type constructor or class `InterleavableIO'
05:36:02 <ziman> i'd say InterleavableIO expects a (* -> *) as the first argument
05:36:30 <HugoDaniel> its in: Control.Monad.Trans.InterleavableIO
05:36:34 <ziman> but R (..stuff..) is a simple type
05:37:03 <HugoDaniel> http://hackage.haskell.org/packages/archive/interleavableIO/0.0.1/doc/html/Control-Monad-Trans-InterleavableIO.html
05:37:07 <HugoDaniel> i can't understand the documentation
05:37:27 <ziman> class MonadIO inner => InterleavableIO inner ...
05:37:31 <HugoDaniel> class MonadIO inner => InterleavableIO inner trans buffer | trans -> inner buffer  ? :(
05:37:55 <ziman> therefore `inner' must be a monad, monads have kind * -> *
05:38:09 <HugoDaniel> oh
05:38:11 <HugoDaniel> but R is a monad
05:38:23 <HugoDaniel> and MonadIO
05:38:28 <idnar> @seen conal
05:38:28 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 4h 57m 54s ago, and .
05:38:44 <mauke> you're not passing R, you're passing (R (ReaderT r (StateT s IO) a))
05:38:52 <idnar> @tell conal http://conal.net/blog/feed/ has a trailing space that seems to be causing problems for some software
05:38:53 <lambdabot> Consider it noted.
05:38:54 <ziman> well, put only R there, then
05:39:09 <idnar> @tell conal sorry, I mean a /leading/ space
05:39:10 <lambdabot> Consider it noted.
05:39:30 <ziman> (i don't know what the code is expected to mean)
05:41:49 <HugoDaniel> argh :/
05:41:57 <HugoDaniel> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
05:42:36 <HugoDaniel> im having a bad time with this... i wish i could understand it so it would make sense, my 'logic' approaches dont work
05:42:55 <HugoDaniel> if R is a monad, how come R (ReaderT r (StateT s IO) a) is not ?
05:43:27 <mauke> what
05:43:35 <mauke> if sqrt is a function, how come sqrt 2 is not?
05:44:12 <HugoDaniel> sorry, im in despair
05:44:13 <HugoDaniel> :P
05:45:47 <kpreid> well, you've got *two* monads there...
05:46:04 <kpreid> R is one of 'em and ReaderT r (StateT s IO) is the other
05:46:52 <kpreid> On the other hand, if R were actually a monad transformer then R (ReaderT r (StateT s IO)) *would* be a monad.
05:47:38 <ziman> @kind ReaderT
05:47:39 <lambdabot> * -> (* -> *) -> * -> *
05:48:20 <damajah> real beginner Q here, im trying to do a task from Learn You a Haskell, and get a compile err
05:48:30 <HugoDaniel> hmm i see
05:48:30 <ziman> @kind ReaderT r (StateT s IO)
05:48:32 <lambdabot> Not in scope: type variable `r'
05:48:32 <lambdabot> Not in scope: type variable `s'
05:48:41 <damajah> trying to add bump to todo.hs http://pastebin.com/m76060d53
05:48:42 <ziman> @kind ReaderT Int (StateT Int IO)
05:48:43 <lambdabot> * -> *
05:49:17 <pao> @unmtl ReaderT r (StateT s IO)
05:49:17 <lambdabot> err: `ReaderT r (StateT s IO)' is not applied to enough arguments, giving `/\A. r -> s -> IO (A, s)'
05:50:46 <pao> @unmtl ReaderT r (StateT s IO Char)
05:50:46 <lambdabot> err: `ReaderT r (s -> IO (Char, s))' is not applied to enough arguments.
05:50:49 <EvilTerran> @unmtl ReaderT r (StateT s IO) a
05:50:49 <lambdabot> r -> s -> IO (a, s)
05:51:19 <pao> EvilTerran: thanks
05:51:42 <EvilTerran> unmtl works on fully-applied types (kind *)
05:51:59 <pao> yep
05:54:50 <HugoDaniel> hmm
05:55:30 <damajah> ++ should append a String to a List of Strings right? http://pastebin.com/d27746f4a I cant see where the Char comes from.
05:55:54 <EvilTerran> damajah, ++ appends two lists of the same type
05:56:00 <EvilTerran> String = [Char]
05:56:20 <HugoDaniel> im trying to be able to do the glut callbacks inside this "R" monad
05:56:21 <damajah> ah ok.
05:56:26 <HugoDaniel> because of the state
05:56:48 <HugoDaniel> yes, i could transform it, or just do everything in IO, but it would be kind of jerky :/
05:57:01 <Lemmih> damajah: You want ':'.
05:57:16 <HugoDaniel> also i have several helper functions to manipulate the R state that would be nice to use inside the glut callbacks
05:57:41 <damajah> i tried that but i got a different error about no exhaustive patterns or something, i will try again
05:57:53 <EvilTerran> HugoDaniel, i recall seeing something in here a day or two ago about embedding other monads in IO
05:58:17 <EvilTerran> for instance, turning a State s a transparently into an IO a with an internal IORef
05:58:23 <damajah> "Non-exhaustive patterns in function bump" at runtime
05:58:36 <damajah> even though i didnt think i was pattern matching
05:58:46 <HugoDaniel> EvilTerran: yes, that is what InterleavableIO supposedly does :/
05:58:58 <HugoDaniel> if i could understand it :D
05:59:12 <mauke> damajah: [fileName, numberString] is a pattern. it matches lists with exactly two elements
05:59:56 <damajah> hmm i can see it would be a pattern in another context, but on the rhs of an = in a let...
06:00:18 <mauke> damajah: what?
06:00:23 <damajah> oh I get you..
06:00:26 <jorick> Hey wth! http://haskell.org/ghc/docs/latest/html/libraries/ doesn't mention opengl and glut?
06:01:10 <HugoDaniel> jorick: they aren part of ghc std libs
06:01:20 <HugoDaniel> but they are included in the haskell platform libs
06:02:06 <HugoDaniel> so if you want to give them a quick go, try out the haskell platform ;)
06:03:04 <HugoDaniel> also, if you're looking for a compreensive list of all the haskell packages, try this url instead: http://hackage.haskell.org/packages/archive/pkg-list.html
06:04:11 <jorick> i found their docs in hackage, but i can't figure em out
06:04:30 <HugoDaniel> hmm
06:04:41 <HugoDaniel> well, if you are looking for opengl example programs
06:04:57 <HugoDaniel> then download glut through darcs, and check the examples dir
06:05:31 <HugoDaniel> youll find lots of examples, including the opengl redbook source code, and the first example from the opengl orangebook
06:06:53 <jorick> i just want to know how to make my window unreshapable
06:08:01 <mauke> haha, impossible
06:08:25 <mauke> I have absolute control over my windows
06:08:38 <HugoDaniel> :D
06:08:45 <damajah> ahhh the learn you a haskell example had an error in it
06:08:50 <HugoDaniel> well jorick, youll have to use glfw instead of glut for that
06:08:55 <damajah> the error wasnt in my modification
06:09:14 <HugoDaniel> http://hackage.haskell.org/packages/archive/GLFW/0.4.1/doc/html/Graphics-UI-GLFW.html#t%3AWindowHint
06:10:27 <mornfall> Hm. Anyone can point out what's wrong with this?
06:10:28 <mornfall> class Named a where
06:10:28 <mornfall>     type Name a :: *
06:10:28 <mornfall>     name :: a -> Name a
06:11:02 <mornfall> I get a kind error on the last line, claiming that a is * -> * -> * (why on earth?)
06:11:45 <mornfall> I have exactly the same thing a few lines later, with just different names, and it works fine.
06:12:00 <jorick> HugoDaniel, that does seem like it has a lot of the things i'm looking for, but no menu's :(
06:12:12 <mornfall> Could *use* of the class induce kind error in the class definition?
06:13:13 <mornfall> Ah, indeed, it's used wrongly later. Puzzling.
06:13:53 <Peaker> mornfall: weird that it doesn't complain at the wrong use later, the kind definition seems to be the authorative one
06:14:17 <jorick> HugoDaniel, and it seems that .... GLFW applications can only open one window.
06:14:31 <mornfall> I guess the problem is the wrong use is a class itself.
06:15:23 <Peaker> mornfall: what are your "Name"s btw? Why don't they have a uniform type?
06:15:34 <Peaker> a concrete type that is
06:19:07 <mornfall> Because I don't care at this level.
06:19:47 <HugoDaniel> oh
06:20:04 <HugoDaniel> jorick: are you going to use glut menus ?
06:20:10 <HugoDaniel> those are really ugly and bad :/
06:20:15 <jorick> oh
06:20:35 <HugoDaniel> i would reccommend building your own menu system, or relying on a toolkit (gtk ?)
06:22:30 <HugoDaniel> as for several windows, i dont know, maybe managing your self several glfw contexts could be a sollution, perhaps forking processes with different windows each, bahh :/
06:23:25 <Peaker> GLUT has a menu system?
06:23:53 <jorick> well, i just wanted to learn how to do graphics in haskell, i want to build a game with it in the near future
06:24:01 <Peaker> difficulty of having multiple windows -> evidence of the evil of global variables
06:24:19 <Peaker> GLUT is a bit of a mess. Someone should abstract it into niceness
06:24:46 <badsheepy> isnt there reactive-glut or something
06:24:50 <HugoDaniel> yes
06:25:13 <jorick> i was thinking my first just trying to get it so that i can drive a red rectangle around the screen, i'm aiming for the feeling you have when you drive those bulldog cars in GTA 1
06:25:40 <HugoDaniel> is it 3D or 2D ?
06:25:47 <HugoDaniel> if its 2D you could try out the cairo lib
06:26:07 <jorick> well i'm going to start in 2D, but if possible i'd like to change the code to become 3D afterwards
06:32:41 <mmorrow> you can have multiple windows with GLUT, you just need to forkOS a thread for each one
06:32:57 <mmorrow> since each window needs its own thread-local state
06:34:47 <HugoDaniel> exactly
06:35:36 <HugoDaniel> i like the approach that the open scene graph guys did on this case of multiple windows
06:35:54 <mmorrow> oh?
06:35:58 <HugoDaniel> creating virtual screens inside the same context
06:36:11 <HugoDaniel> you could have several for each scenegraph
06:36:29 <mmorrow> hmm, interesting
06:37:07 <HugoDaniel> they use their own context system, not glut/glfw/sdl, even though its possible
06:37:13 <HugoDaniel> to use any of these
06:37:55 <michaelfeathers> I'm doing something and I think there has to be a simpler way.
06:38:27 <michaelfeathers> ..and in Haskell there usually is.
06:38:36 <HugoDaniel> :D
06:38:39 <HugoDaniel> return ()
06:40:48 <michaelfeathers> This function computes row and column from the absolute position in a document in the most obtuse way possible. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8212#a8212 I wonder if there is a simpler way?
07:16:44 <preflex> (@where ops)
07:18:07 <pozic> Is there a library/idiom to create a data structure which is exactly the same as another one, but has one field more in one of its constructors? The idea is not to touch the code which creates the original data structure.
07:19:09 <pozic> What I want to express is deriveddata Foo = add field bar to constructor Baz.
07:19:37 <Botje> i think you want extensible records, then
07:19:43 <Saizan> pozic: is it recursive?
07:21:19 <pozic> Saizan: the extra field is not recursive.
07:21:56 <pozic> Botje: which don't exist in any useable shape, you mean?>
07:22:04 <Saizan> but the structure is?
07:22:16 <pozic> Saizan: the original structure is, yes.
07:23:19 <Saizan> mh,that complicates things
07:24:09 <Saizan> i guess you've a default value for this field, right? otherwise it'd be hard to imagine how to not modify the code that builds up the structure
07:25:03 <pozic> The default value is undefined.
07:25:28 <pozic> It computes some semantic information.
07:25:33 <Saizan> hah
07:26:03 <Saizan> http://comonad.com/reader/2009/incremental-folds/ <- this'd be a nice pattern if you could modify the original structure
07:26:39 <Saizan> otherwise you've to build a sort of parallel tree on the side
07:26:48 <Saizan> i think
07:29:34 <paolino> hi, where is possible to learn using Network.HTTP.Browser ?
07:30:07 <pozic> Saizan: that approach doesn't seem to make things easier.
07:31:10 <Saizan> pozic: a structure like that is easier to extend
07:33:51 <pozic> Saizan: I see how :> can help, but the point of the In constructor escapes me.
07:34:25 <purplepenguins> paolino: you can read the haddock documentation, it's helpful
07:34:47 <purplepenguins> search for it on hoogle
07:34:54 <paolino> purplepenguins: the example in the main page is not compiling due to sign errors :-/
07:35:11 <purplepenguins> sign errors?
07:35:20 <Saizan> pozic: the part about Mu is only an introduction
07:35:36 <paolino> yes, I have to comment out signatures to make it compile
07:35:53 <purplepenguins> hmm
07:36:54 <paolino> purplepenguins: anyway it's not using browse function, I need redirects to happen transparently
07:37:02 <pozic> Saizan: http://splonderzoek.blogspot.com/2009/02/incremental-fold-design-pattern.html has to change the data type, which makes it a trivial. I am not sure where http://comonad.com/reader/2009/incremental-folds/ keeps this field.
07:37:21 <purplepenguins> i wouldn't know, i've never used it
07:37:26 <purplepenguins> and i can't find it on hoogle either
07:37:30 <Saizan> ata (f :> m) = f (f :> m) :> m
07:37:36 <Saizan> pozic: in the 'm'
07:38:11 <Saizan> pozic: you've the main structure defined with 'f' and the possible extensions go into 'm'
07:42:54 <pozic> Saizan: what does going in and out of fixpoint mean? I know what a fixed point of a function is.
07:43:13 * edwardk perks up at mention of his blog.
07:44:00 <Saizan> pozic: it's the fixed point of a type here
07:44:04 <edwardk> pozic: try to wrap up some partially folded value as you layer on a functor?
07:44:12 <edwardk> er trying to
07:44:45 <Saizan> pozic: basically 'f' is a non-recursive functor, the recursion is given by taking it's fixed point
07:45:00 <pozic> edwardk: I want to compute one value by traversing over the tree once and then store that value in a field which doesn't exist yet, but would exist if I would copy the whole data type.
07:45:32 <edwardk> in and out refer to the outermost newtype wrapper. ultimately your term looks like In (f (In (f (In f (In f ...)))) -- out takes that to f (In (f (In (f ...)))) -- and In takes you back, so you are able to apply another layer of f.
07:45:37 <pozic> edwardk: but this copy pasting of a data structure seems like a really bad idea.
07:45:44 <edwardk> pozic: that is exactly what the incremental fold stuff is for =)
07:46:12 <pozic> edwardk: only it doesn't solve the problem of also being able to handle mutable data structures.
07:46:35 <pozic> edwardk: that's not what I need, now, I think, but for a real program that is sort of a danger.
07:46:48 <mreh> how does one pronounce ">>" and ">>="
07:47:05 <edwardk> pozic: define an f-algebra that takes you from f m -> m -- and then you can apply it incrementally by just using f :> m, and at every level of the structure you'll have your extra field
07:47:17 <edwardk> mreh: usually as 'bind' and er... 'bind' ;)
07:47:22 <Petrosian> mreh: "Then" and "bind"?
07:47:37 <edwardk> Petrosian's suggestion is good
07:47:38 <pozic> "and then" and "bind", imho
07:47:46 <mreh> cool
07:48:16 <edwardk> pozic: nothing says that f cannot include IORefs, etc.
07:48:58 <edwardk> pozic: if f is traversable you can define a monadic catamorphism with the same properties
07:49:24 <edwardk> pozic: i use this with minor modification where the entire type of the functor changes out from under me
07:49:56 <pozic> edwardk: ok, that sounds very interesting.
07:50:18 <mreh> :t return
07:50:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:50:24 <pozic> edwardk: I cannot verify what you say, however, because I don't know what an F-algebra is by heart.
07:50:26 <edwardk> type f :> m = f (m f); data Exp f = App (Exp :> f) (Exp :> f) | Var (Var :> f); newtype Var f :: (* -> *) = V String
07:50:47 <edwardk> note that expressions include f-wrapped Vars as well as nested f-wrapped expressions
07:50:52 <edwardk> via App
07:51:01 <mreh> :t >>
07:51:02 <lambdabot> parse error on input `>>'
07:51:06 <mreh> :t (>>)
07:51:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:51:27 <edwardk> now you can define a simpler f since we moved the fold into the common :> by using data Ann a e = Ann a e -- to deal with annotated trees
07:52:23 <edwardk> Ann 12 (App (Ann 23 (V "Hello")) (Ann 34 (V "Bar")))) -- would be a member of Exp :> Ann Int
07:53:05 <edwardk> and you can strip all such annotations by just using data Mu a = Mu a, Mu (App (Mu (V "Hello") (Mu ("V "Bar"))) is a member of Exp :> Mu
07:53:48 <pozic> edwardk: your point is that you don't need Ann a e anymore, right?
07:53:58 <Philonous> cabal installing hmatrix complains that " *** Sorry, I can't link GSL.", even though I added --extra-include-dirs and --extra-lib-dirs and GSL as well as lapack are definitely present and accounted for. Do I miss something?
07:54:20 <pozic> Philonous: PEBKAC
07:54:22 <edwardk> if you want something that looks like a 'base functor', then use a data type that discards the second argument. data Base a e = Base a
07:54:34 <pozic> Philonous: I know it worked a few versions ago.
07:54:58 <pozic> Philonous: especially, if you are on Linux, you probably don't have the dev libraries installed.
07:55:08 <dcoutts> Philonous: if GSL is using a ./configure script then it may not respect --extra-lib-dirs and --extra-include-dirs
07:55:10 <edwardk> pozic: and that you pay nothing for it, note that V there is just a newtype constructor, so is Mu, so that Mu-based definition is structurally isomorphic to App (V "Hello") (V "Bar") -- and has no superfluous data constructors
07:55:23 <nainaide> How to use "getArgs" to get a input  in ghci, please?
07:56:02 <edwardk> or rather its even cheaper than that, since V is a newtype so its isomorphic to App (Var "Hello") (Var "Bar") -- i actually forgot the Var wrappers in the above code, sorry ;)
07:56:34 <dcoutts> nainaide: by default there are no args available in ghci, you can set them using :set args foo bar
07:56:48 <Saizan> edwardk: you flipped f and m in the definition of :>, right?
07:56:48 <dcoutts> nainaide: then you get what you set, ie getArgs >>= print
07:56:49 <dcoutts> ["foo","bar"]
07:57:04 <edwardk> in any event you can define a "Ann e"-coalgebra that adds layers
07:57:27 <nainaide> docutts, thanks
07:57:37 <pozic> edwardk: do you have time for another example based on my data type?
07:57:38 <Philonous> pozic: the includes are there (I'm on FreeBSD)
07:57:56 <edwardk> its funny that you use an "Ann e" coalgebra with carrier (f :> Ann e) rather than an f-Algebra with carrier e, but that is what it turns into
07:58:12 <mmorrow> Philonous: you may need -lgslcblas
07:58:24 <edwardk> pozic: i'm kind of rushed at the moment, so i'll look at it, but then I have about an hour and a half obligation before I'll be back
08:00:03 <Baughn> > let there be light
08:00:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:00:12 <Baughn> Ha. I knew it!
08:00:36 <nainaide> docutts, set args works great!
08:02:08 <Philonous> mmorrow: Where do I set -lgslcblas ?
08:02:55 <mmorrow> Philonous: you have it if you have gsl installed, i mean you should add that to whatever so that ld gets it
08:03:05 <Philonous> Ah thanks
08:03:34 <mmorrow> Philonous: iirc there's a cabal flag that the .cabal checks to see if it should use that cblas lib
08:04:54 <mmorrow> Philonous: (oh, i though thought you said "where do i GET -lgslcblas")
08:07:18 <HugoDaniel> hmm
08:07:38 <HugoDaniel> i have managed to fixe the InterleavableIO stuff i was trying to do
08:07:40 <HugoDaniel> here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3343#a3343
08:08:22 <HugoDaniel> i just ditched the Control.Trans.InterleavableIO and defined my own class... i was not understanding the documentation, nor was i being able to use it :/
08:08:44 <HugoDaniel> it always complained about kind errors, so ehh
08:11:25 <HugoDaniel> http://hackage.haskell.org/packages/archive/interleavableIO/0.0.1/doc/html/Control-Monad-Trans-InterleavableIO.html  this is much too confusing for me, and i feel it does not follow the logic from the original post
08:11:28 <HugoDaniel> back to code now
08:14:12 <Saizan> HugoDaniel: the documentation is quite horrible because of the names of the type variables
08:14:29 <Saizan> HugoDaniel: though s/inner/IO/ and you get your version
08:14:51 <HugoDaniel> ah
08:15:09 <HugoDaniel> i was reading it completely different then :/
08:23:13 <Peaker> HugoDaniel: what are you trying to do?
08:24:52 <HugoDaniel> i want glut to do display/update callbacks inside my monad
08:25:59 <Peaker> HugoDaniel: glut has a mainLoop :: IO () thing that calls callbacks which are IO, right?
08:26:46 <Phyx-> hmm looks like to fix this i need the wxHaskell src..
08:28:19 <HugoDaniel> yes
08:28:24 <HugoDaniel> exactly peaker
08:28:36 <HugoDaniel> and i want the callbacks to be inside this R monad
08:28:48 <HugoDaniel> the R monad has all the state needed for rendering
08:29:03 <HugoDaniel> is just a message handling monad
08:29:10 <HugoDaniel> so that all the render objects can be pure
08:29:20 <HugoDaniel> no IO involved in them
08:30:09 <EvilTerran> are the callbacks synchronous?
08:30:24 <HugoDaniel> im not sure
08:30:44 <Cale> HugoDaniel: You could turn any R monad computation into an IO computation which manipulates a pair of IORefs
08:30:58 <Cale> HugoDaniel: and use that as a way to make the callbacks work
08:30:59 <EvilTerran> or one tuple IORef, if you prefer
08:31:14 <EvilTerran> Cale, i think that's what this interleavable stuff is about
08:31:16 <HugoDaniel> i see
08:31:35 <HugoDaniel> i did it according to this post: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
08:31:36 <Cale> Oh, quite possibly, I haven't actually finished reading the paste :)
08:32:08 <HugoDaniel> anyway, these are not my ideas, i just rip from here and there and try to paste it all together
08:32:17 <EvilTerran> Cale, from what i remember of reading about it, the idea is that you could write an instance of some class for each monad transformer that can have its effects embedded in IO
08:34:59 <moonpatrol> whats considered a "core" package by cabal ?
08:35:17 <Cale> moonpatrol: core?
08:35:28 <Cale> moonpatrol: Where are you seeing that?
08:35:53 <moonpatrol> i just ran cabal upgrade to see what it would suggest, and it just says its not recommended to upgrade core packages
08:36:11 <Cale> ah
08:36:23 <Cale> Probably it means the packages that come with GHC.
08:36:32 <moonpatrol> ahh okay
08:36:39 <moonpatrol> thanks
08:44:32 <Phyx-> if there anyway to change the generated "main" of a haskell file without diving into the ghc code?
08:45:22 <int-e_> what do you want to change about it?
08:46:46 <Phyx-> int-e_: i'm trying to enable Fs redirection on x64 windows machines
08:47:09 <Phyx-> since it generates 32bit assemblies, but some wx programs are currently trying to load the 64bit dlls which ofcourse die
08:49:22 <Phillemann> I loaded the Text.Regex.Posix package and executed "string =~ pattern :: [String]", but it returns an error instead of a list of results.
08:49:56 <Cale> Phillemann: which string and pattern?
08:50:11 <Phillemann> "ananas" =~ "na" :: [String]
08:50:40 <Cale> ah, you're referring to the type error
08:50:49 <skorpan> :t (=~)
08:50:50 <Phillemann> No instance for (RegexContext Regex [Char] [String])
08:50:51 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:50:54 <Cale> There's no instance of RegexContext to make that work
08:51:13 <Phillemann> Cale: Which means...? :>
08:51:31 <Phillemann> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ - according to this tutorial, it _used_ to work.
08:51:33 <Cale> Phillemann: Which means there's no way to treat that expression as a list of strings
08:51:51 <Cale> yeah, some of the contextual stuff has changed since the early versions of the library
08:52:06 <Phillemann> Hmmm, ok.
08:52:14 <int-e_> Phyx-: I'm not sure. Maybe you can go the "calling Haskell from C" route, i.e. call your Haskell main function via FFI after your custom initialisation and initialising the RTS?
08:53:14 <Cale> Prelude Text.Regex.Posix> getAllTextMatches ("ananas" =~ "na") :: [String]
08:53:14 <Cale> ["na","na"]
08:53:19 <int-e_> Phyx-: oh. look here: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
08:53:27 <skorpan> see that's not the same
08:53:58 <Phillemann> Cale: Ah, nice. Thanks. :)
08:54:06 <Phyx-> ah, i completely forgot about that one, thanks int-e_
08:54:44 <nainaide> In http://www.haskell.org/all_about_monads/examples/example8.hs, I try to do lookup with " lookup "double"  [("double",(2*)),      ("halve",(`div`2)),("square",(\x->x*x)), ("negate", negate), ("incr",(+1)),        ("decr",(+(-1)))]" , but I got error. Any Idear ? Thanks
08:55:19 <Cale> nainaide: What error?
08:55:58 <Cale> > lookup "double" [("double",(2*)), ("halve",(`div`2)), ("square",(\x->x*x)), ("negate", negate), ("incr",(+1)), ("decr",(+(-1)))] <*> Just 5
08:56:00 <lambdabot>   Just 10
08:56:23 <nainaide> Cale, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8213#a8213
08:56:59 <Cale> nainaide: It's telling you that it can't show a function
08:57:08 <pozic> Where can I find the code for http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf ?
08:57:36 <Cale> nainaide: The result of evaluating that expression will have type Num a => Maybe (a -> a)
08:57:40 <nainaide> Cale, ghci just doesnt know how to it? no errors
08:57:52 <pozic> I would like to know what 'k' is passed to reifyIntegral. They don't define that in the paper.
08:57:55 <Cale> nainaide: It can't print the result, because it's a function.
08:58:08 <Cale> (well, a Maybe function)
08:58:21 <nainaide> Cale, thanks, I understand.
08:59:21 <nainaide> Cale, I had thought I can do it step by step.
09:00:35 <c_wraith> wouldn't it be more fun to write square as join (*)  >_>
09:00:48 <c_wraith> > join (*) 25
09:00:49 <lambdabot>   625
09:03:26 <gwern> @tell Gracenotes ever wanted to do some skydiving? there's a stonybrook study that apparently will pay you to: http://lsec.bme.stonybrook.edu/Site/Participating_in_Studies.html
09:03:26 <lambdabot> Consider it noted.
09:12:38 <gwern> 'if you force it to be polymorphic, it goes from 3x slower to 80x slower...'
09:12:45 <gwern> man, these crazy quicksort routines
09:13:36 <EvilTerran> c_wraith, i'd write square as (^2), personally
09:13:46 <c_wraith> :t (^)
09:13:48 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:13:54 <c_wraith> :t (^2)
09:13:55 <lambdabot> forall a. (Num a) => a -> a
09:14:02 <c_wraith> Interesting.
09:14:06 <copumpkin> I dunno, (^2) does a lot of extra stuff
09:14:15 <copumpkin> which is unnecessary for an exponent of 2
09:14:19 <c_wraith> yeah, it has to deal with negative exponents
09:14:20 <c_wraith> and the like
09:14:31 <copumpkin> I don't think ^2 deals with negative ones actually
09:14:35 <c_wraith> but join(*) is needlessly obtuse :)
09:14:37 <EvilTerran> ^^ deals with negatives
09:14:41 <skorpan> :t join (*)
09:14:43 <lambdabot> forall a. (Num a) => a -> a
09:14:43 <copumpkin> but it does repeated squaring
09:14:43 <EvilTerran> > 2 ^ (-1)
09:14:44 <lambdabot>   * Exception: Negative exponent
09:14:46 <skorpan> :t join
09:14:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:14:56 <skorpan> so join (*) works in the (->) monad?
09:15:00 <skorpan> or rather (->a)
09:15:02 <skorpan> or whatever it was
09:15:07 <Phillemann> Isn't there a standard function to replace a substring of a string?
09:15:09 <copumpkin> yup, ((->)a)
09:15:27 <EvilTerran> (\x -> x*x) may be faster than (^2) on the metal, but (^2) is faster in my head, so i'll use that at least 'til i've profiled and found it to be too slow :)
09:15:31 <skorpan> Phillemann: probably in MissingH
09:16:36 <EvilTerran> ?type (^^2)
09:16:38 <lambdabot> forall a. (Fractional a) => a -> a
09:16:41 <EvilTerran> ?type (**2)
09:16:42 <lambdabot> forall a. (Floating a) => a -> a
09:16:55 <Makoryu> ?type (^2)
09:16:57 <lambdabot> forall a. (Num a) => a -> a
09:17:32 <Phillemann> skorpan: Ah, indeed. Thanks. :)
09:17:48 <skorpan> glad i could help for once :)
09:22:31 <Cale> Why is it that blog software is always so terrible at text processing? The code on edwardk's blog somehow had spurious extra spaces added into the middle of operator symbols: < *> and then when I tried to comment about it, my < *> got deleted from the message entirely rather than being converted to HTML character entities.
09:22:59 <Zao> Better safe than sorry?
09:23:31 <pikhq> Cale: s/<// is easier than s/</&lt;/
09:24:00 <Cale> pikhq: It did something even more baffling than that though: it matched the < and > and removed everything in between.
09:24:26 <pikhq> Cale: *facepalm*
09:24:39 <jpcooper> hello
09:24:46 <jpcooper> is it okay for a socket to be simultaneously read from and written to?
09:24:56 <Cale> yes
09:24:57 <jpcooper> that is, a handle associated with a socket
09:25:13 <jpcooper> okay
09:29:34 <Cale> Somewhat interestingly, the blog *did* let me type HTML character entities directly.
09:29:53 <Cale> &lt; didn't get turned into &amp;lt;
09:30:06 <pozic> Cale: all web software is written based on regular expressions.
09:30:24 <pozic> Cale: "Nobody" does proper parsing.
09:30:34 <Cale> It leaves me amazed that anything works at all.
09:31:08 <pozic> The only way to stop this madness is to do it correctlty yourself.
09:31:33 <Cale> Haha, like I could be convinced to program for the web.
09:31:53 <pozic> I am also not convinced whether doing the right thing is always the smartest thing after reading http://comonad.com/reader/2009/incremental-folds/
09:32:05 <luite> pozic: do you know a javascript parser library that you can recommend?
09:32:33 <pozic> Conceptually, it is brilliant, but I cannot use it within a few minutes :(
09:32:46 <pozic> The paper about reflection is also great.
09:32:58 <pozic> luite: I am not a web-programmer by choice.
09:33:37 <pozic> There are people that compile Haskell to JavaScript, IIRC.
09:33:46 <pozic> But I am not sure how fast that runs.
09:34:02 <luite> ah, I've been looking for one, to parse simple expressions, but there are only a few, none of which seem to be actively developed or maintained
09:34:05 <pozic> You also don't actually need a library to do parsing.
09:34:24 <Makoryu> What's the current status of GHC on BSD?
09:34:52 <luite> it makes things easier :p but parser combinators in javascript don't have the advantage of the haskell syntax
09:34:55 <gwern> ailing, last I heard
09:34:57 <pozic> Makoryu: there is no such thing as BSD.
09:35:01 <gwern> do the BSDs even have ghci?
09:35:07 <pozic> Makoryu: but it works on some BSDs.
09:35:24 <ksf> don't the bsd guys claim they can run anything linux?
09:35:33 <pozic> ksf: yes, and that actually works.
09:35:43 <pozic> (for very non-trivial software)
09:35:46 <Zao> Running things under the linux emul layer is admitting defeat.
09:36:08 <pozic> It is also a way to keep your OS relevant.
09:36:36 <Peaker> "emulation layer" sounds bad but may actually be a very thin translator
09:36:40 <ksf> but then, to my best of knowledge ghc doesn't use much more than open, close, malloc and select.
09:37:01 <pozic> I don't think a user can notice whether something is being emulated from a performance point of view.
09:37:02 <Peaker> ghc uses malloc, and not directly sbrk or such?
09:37:06 <ksf> that is, if you've got a POSIX OS, it should run out of the box.
09:37:15 <ksf> Peaker, hell if I know.
09:37:24 <Peaker> select sucks, libevent is nicer :)
09:37:35 <ksf> last time I did assembly under linux, I used mmap to malloc.
09:38:18 <ksf> sbrk just increases your stack, doesn't it?
09:38:23 <c_wraith> I like libev a bit more than libevent
09:38:30 <c_wraith> But both are better than raw select
09:38:37 <p_l> ksf: no, it manipulates pointer that signifies "end of data sement"
09:38:41 <p_l> *segment
09:39:06 <c_wraith> mmm.  data cement.  good for keeping buried data from floating to the top of the lake at an inopportune ime.
09:39:08 <c_wraith> *time
09:39:37 <ksf> ...which would have meant that I had to care about stuff like memory fragmentation and so on.
09:40:15 <p_l> ksf: afaik, many modern allocators use mmap as well
09:43:26 <ksf> the people at school loved it, being used to all that messy dos stuff.
09:43:40 <ksf> 32bit registers, a sane kernel interface...
09:44:11 <ksf> (that's actually more or less the same as the clib, modulo utility functions)
09:47:46 <Phyx-> http://www.projectcartoon.com/cartoon/2 LOL!!!
09:49:43 <Phyx-> http://www.projectcartoon.com/cartoon/1 better one
09:49:55 <sm> wahahaha, thank you Phyx- :)
09:50:40 <Phyx-> hehehe :)
09:50:56 <kynky> in gtk2hs because onDestroyEvent is deprected instead of onDestroy window mainQuit , you have to do window `on` deleteEvent $ tryEvent $ liftIO $ mainQuit ?
10:07:15 <coco> how can I make a string into uppercase?
10:07:32 <skorpan> :t map toUpper
10:07:34 <lambdabot> [Char] -> [Char]
10:07:39 <skorpan> > map toUpper "hello"
10:07:41 <lambdabot>   "HELLO"
10:07:47 <coco> thanks
10:08:12 <skorpan> coco: http://www.haskell.org/hoogle/ is great for stuff like this
10:08:48 <Lemmih> Hm, there should be a TH library for sending coding questions to #haskell.
10:10:21 <edwardk> cale: yeah, i unfortunately can't seem to make my syntax highlighter _not_ put those extra spaces in
10:12:49 <Cale> edwardk: Are you sure it's the syntax highlighter?
10:13:04 <edwardk> cale: its some interaction between the syntax highlighter and wordpress
10:13:19 <edwardk> but since it is a wordpress plugin... i blame the highlighter ;)
10:13:30 <Cale> edwardk: I'm betting that whatever is responsible for converting characters into HTML character entities is converting "<" into "&lt; " rather than "&lt;"
10:13:47 <edwardk> or i think it is the plugin anyways
10:16:05 <RayNbow> edwardk, is Oleg's paper in your latest blog post an accessible introduction to reflections?
10:16:19 <edwardk> RayNbow: since its the only introduction, yeah ;)
10:16:43 * RayNbow adds it to his ToRead pile
10:16:45 <edwardk> cale: the text is sitting in between pre tags, if you don't use the highlighter it comes through fine
10:16:54 <Cale> ah
10:17:01 <gwern> hm. who is bjorn bringert on #haskell?
10:17:05 <edwardk> its a little tricky to read past the oleggery, but once you get it, it seems obvious
10:18:38 <Lemmih> gwern: bringert
10:18:39 <RayNbow> @quote oleg
10:18:40 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
10:19:13 <gwern> @seen bringert
10:19:13 <lambdabot> I saw bringert leaving #haskell.se, #ghc and #haskell 9m 19h 15m 40s ago, and .
10:19:23 <gwern> 9 months?
10:19:34 <gwern> well, I guess I shan't bother leaving a lambdabot message then
10:26:47 <Saizan> edwardk: in the last example on the incremental fold post, is it possible to get the full tree out without retraversing it all to apply getReduction at every node?
10:28:08 <Saizan> s/tree/list/
10:28:22 <Saizan> it applies similary to trees i guess
10:28:39 <damajah> is there any known problem configuring and building mtl as part of haskell platform?
10:29:18 <damajah> make didnt generate Setup, and when i generate it manually install complains that i need to run configure first
10:29:30 <damajah> which i did at the top level
10:33:16 <edwardk> Saizan: you can make a incremental fold that generates Mu Tree and carry that as part of your fold 'payload'
10:33:34 <edwardk> Saizan: note the shape of the spine in the graph i showed
10:33:49 <edwardk> so adding a layer will also update the 'traditional' list or whatever
10:35:20 <edwardk> i.e. instance Algebra (List a) [a] where phi (Cons x xs) = x:xs; phi Nil = []
10:35:46 <edwardk> then you just carry around the list in the cofree comonad's payload slot
10:37:06 <edwardk> er though, in that case, the last example i used that Mon monoid-based List a-algebra for that same effect
10:38:25 <Saizan> i want the payload produced by the algebra introduced by the reflection as well, but without the region parameter so it can escape, i guess that just means a different algebra though
10:38:39 <Saizan> "means i need to use"
10:38:55 <edwardk> yeah
10:39:02 <edwardk> the reflection algebra there was just an example
10:39:44 <edwardk> oh, only code change to work with 0.2 is to change "Reflects" to Reifies and do some fiddly Lambda bits
10:40:02 <edwardk> i should probably retroactively update the code in that post to reflect current practice
10:45:36 <mreh_> how do I add to the list of directories GHC searches for imported headers?
10:47:57 <rawzoo> helloo
10:48:08 <twanvl> mreh_: do you mean for C headers you use with the FFI?
10:49:44 <rawzoo> http://shop.maadhyam.org
10:50:41 <mreh_> twanvl, just a regular import declaration at the top of my haskell source
10:51:42 <twanvl> in that case: ghc looks in installed packages and the current directory. If you want to use multiple directories you should use hierarchical names.
10:54:40 <mreh_> twanvl: can I install my own packages?
10:55:06 <ksf> yep, the easiest way is via cabal.
10:55:11 <mreh_> packages, as in source, not debian packages
10:55:13 <MyCatVerbs> mreh_: No. Permission DENIED! ;)
10:55:26 <MyCatVerbs> mreh_: The easiest way is with cabal install --user.
10:55:46 * dcoutts notes that --user is the default
10:55:56 <MyCatVerbs> And put ~/.cabal/bin in your PATH.
10:56:03 <alec> Text.CSV.ByteString uses strict bytestrings, but I want my CSV file parsed lazily.  If I want to use lazy bytestrings, is there any way I can use this library, or do I need to roll my own?
10:56:08 <MyCatVerbs> dcoutts: as has tripped me up, once or twice. ;)
10:56:39 <dcoutts> MyCatVerbs: do you mean that "runghc Setup" not looking at user packages has tripped you up?
10:56:42 <mmorrow> heh, x86_64 has an instr SKINIT: "Secure Init and Jump with Attestation"
10:56:59 * mmorrow gives it his vote for "best named instruction evar"
10:58:31 <MyCatVerbs> dcoutts: Nah, I install everything through cabal anyway. But I've once or twice had occasion to yelp, "hang on a minute, I wanted that system-wide" and ^C a cabal install. ^^
10:58:35 <copumpkin> lol
10:58:49 <dcoutts> MyCatVerbs: right
10:59:14 <copumpkin> mmorrow: it turned out to be quite easy to translate an "indirect" graph structure (using arrays/intmaps to represent nodes and edges) to a direct one
11:00:05 <mreh_> i was disappointed that RWH doesn't really cover most of the tool set that comes with ghc
11:00:09 <mmorrow> copumpkin: nice
11:00:29 <mmorrow> copumpkin: what's the rep of the "direct" one?
11:00:45 <MyCatVerbs> It's neat stuff. BTW, did you know that it's quite easy to install the whole of GHC quite happily in a user account (as opposed to, say, /usr/local) iff you hack libraries/Cabal/Distribution/InstallDirs.hs and replace "/usr/local/" in there with your own desired PREFIX?
11:00:47 <copumpkin> mmorrow: this is how I was doing it
11:00:47 <copumpkin> data ExplicitNode a = ExplicitNode { node      :: a
11:00:47 <copumpkin>                                    , neighbors :: [ExplicitNode a]
11:00:48 <copumpkin>                                    }
11:00:57 <mmorrow> copumpkin: ahh, totally
11:01:05 <MyCatVerbs> I don't suppose it's something that people are going to be doing all that often, but it ended up being quite useful to me.
11:01:14 <dcoutts> MyCatVerbs: did you know you can just use --prefix= ? :-)
11:01:21 <mmorrow> copumpkin: and you can untie the know with a StableNames
11:01:25 <mmorrow> *knot
11:01:36 <mmorrow> s/a//
11:01:50 <copumpkin> mmorrow: yeah, I was considering writing some graph algorithms on this representation using stablenames
11:01:58 <MyCatVerbs> dcoutts: yes, but I have to remember that every single time I install something from cabal.
11:02:04 <MyCatVerbs> (Or do I?)
11:02:13 <dcoutts> MyCatVerbs: and you can set the prefix in the ~/.cabal/config file. I don't think it should ever be the most convenient thing to hack the source to change the default.
11:02:27 <mmorrow> copumpkin: hmm, i dunno if i'd use StableName in the algo itself though (not sure if they'd cause a lot of overhead)
11:02:42 <copumpkin> mmorrow: well, it's hard to keep track of what you've already seen otherwise
11:02:51 <copumpkin> although I could apply a tag once
11:02:52 <MyCatVerbs> I'll have to remember ~/.cabal/config, but still.
11:03:05 <mmorrow> copumpkin: you'd have to keep a (IntMap [StableName]) seen set
11:03:17 <MyCatVerbs> dcoutts: the benefit here was having cabal install --global target my home directory rather than the machine's root.
11:03:17 <dcoutts> MyCatVerbs: but it's a one time thing, and it's mentioned in the --help and it's mostly self-documenting
11:03:44 <dcoutts> MyCatVerbs: yes you can do that via the ~/.cabal/config
11:03:58 <mmorrow> copumpkin: which would make it essentially the same as an indirect rep (actually probably worse, since you have to key on the hashStableName, then linearly search the hash bucket ([StableName]) you lookup in the IntMap)
11:04:04 <MyCatVerbs> dcoutts: Cool! I have reached new heights in failure to RTFM. :)
11:04:11 <dcoutts> heh heh :-)
11:04:30 <copumpkin> mmorrow: well I was thinking along the lines of a function that gives each node an id, once
11:04:31 <mmorrow> copumpkin: (this is fresh in my mind because that's exactly what vacuum does now)
11:04:33 <copumpkin> possibly an integer
11:04:40 <MyCatVerbs> In my defense, I was compiling GHC at the time anyway and the sources were right there. So vulnerable, so hackable, so crunchy...
11:04:44 <copumpkin> mmorrow: ExplicitNode a -> ExplicitNode (Int, a)
11:04:52 <copumpkin> and then do all your work on the (Int, a) version
11:04:59 <edwardk> copumpkin: have you seen the lib that andy gill wrote?
11:05:01 <mmorrow> copumpkin: oh totally. that's literally what vacuum does
11:05:01 <copumpkin> so each node has an easy id
11:05:11 <copumpkin> edwardk: don't think so :)
11:05:14 <mmorrow> copumpkin: but s/a/HValue/ so it can work with any type
11:05:14 <copumpkin> mmorrow: ah ok
11:05:29 <copumpkin> mmorrow: I tried vacuuming undefined and it was amusing to see the result :P
11:05:32 <copumpkin> it happily sucked it in
11:05:43 <mmorrow> copumpkin: hehe
11:05:51 <copumpkin> vacuum really sucks!
11:05:53 <MyCatVerbs> dcoutts: Though I suspect that that's probably the only point where I'll ever be able to honestly say that hacking the sources was less work than checking the documentation. Sorry. :)
11:06:05 <mmorrow> copumpkin: gah, i'm going to upload the most recent vacuum right now. i keep saying i am and never do it.
11:06:17 <mmorrow> (most recent being the darcs repo version)
11:06:28 <copumpkin> ah
11:06:43 <copumpkin> edwardk: do you have a link?
11:07:19 <mmorrow> copumpkin: "data-reify" on hackage
11:07:27 <copumpkin> oh
11:08:26 <mmorrow> copumpkin: that does the same StableName dance too, but instead of unpackClosure# and HValue, it uses a class that you implem for your particular type, then it can makes the sharing explicit given that instance
11:08:33 <copumpkin> ah
11:08:56 <mmorrow> copumpkin: the accompanying paper is nice too
11:09:47 <copumpkin> I'll check it out, thanks :)
11:20:20 <HugoDaniel> hi conal
11:20:44 <conal> HugoDaniel: hi
11:20:44 <lambdabot> conal: You have 5 new messages. '/msg lambdabot @messages' to read them.
11:20:48 <conal> eep
11:24:31 <conal> HugoDaniel: i see you're in #glfw also.  do you know whether glfw is friendly with ghci?  i.e., if one can open & close a glfw window without killing ghci?
11:27:10 <HugoDaniel> conal: i have no problems with it in windows :)
11:27:29 <conal> HugoDaniel: even in ghci?
11:27:31 <HugoDaniel> i also like the fact that glfw c code comes bundled inside the haskell module
11:27:41 <HugoDaniel> yes, i always work inside ghci
11:27:44 <conal> HugoDaniel: glad to hear.  :)
11:27:48 <roconnor> @seen jkff
11:27:48 <lambdabot> I saw jkff leaving #haskell 1d 4h 55m 25s ago, and .
11:27:58 <HugoDaniel> you could try out in your setup, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPong-0.1.2 here
11:28:02 <conal> does anyone here use glfw in os x?
11:28:17 <conal> HugoDaniel: will do.  thx.
11:28:45 <conal> i recently switched from linux to os x and found that glut & ghci don't get along on os x.
11:28:54 <HugoDaniel> oh :/
11:29:19 <conal> yeah.  and the common response i get is "oh yeah.  i don't use ghci". :/
11:29:28 <conal> i want my repl!
11:29:52 <HugoDaniel> eheh
11:29:56 <gwern>  * Add --use-unicode flag for displaying prettier versions of common symbols
11:29:58 <gwern> ooh
11:31:11 <gwern> hm. is c.h.o down? my get of GF is stuck at 661 patches, and has been running for hours
11:32:21 * gwern needs a gf!
11:33:07 <dcoutts> gwern: c.h.o seems to be online
11:33:15 <ksf> well, if you're already at the 661th date to get her, you should maybe consider switching to another one.
11:33:38 <gwern> I heard gfs respect persistence
11:34:18 <conal> when i run hpong on os x, i get "Working in unbundled mode.  You should build a .app wrapper for your Mac OS X applications."  anyone know how to do such a thing?  i'm new on os x.
11:34:38 <sjanssen> that's an interesting error
11:34:43 <sjanssen> or warning?
11:35:28 <conal> sjanssen: sounds like a warning to me.  i don't get an app window, and the program doesn't return to the shell.
11:35:42 <conal> andyjgill: hi!
11:36:21 <Vanadium> Is there an explanation as to why ST works, for dummies?
11:36:57 <gwern> Vanadium: how dummy do you want?
11:36:59 <Vanadium> I am trying to read the Lazy Functional State Threads paper thing but I do not think I get the type system stuff being used here :|
11:37:20 <Vanadium> gwern: Somewhere around lyah level?
11:37:38 <HugoDaniel> conal: http://osdir.com/ml/haskell-cafe@haskell.org/2009-05/msg00121.html here is something related :/
11:38:16 <gwern> 'GF was first created in 1998 at Xerox Research Centre Europe, Grenoble, in the project Multilingual Document Authoring. At Xerox, it was used for prototypes including a restaurant phrase book, a database query system, a formalization of an alarm system instructions with translations to 5 languages, and an authoring system for medical drug descriptions.'
11:38:19 <Vanadium> Maybe I should figure out this forall trickery first.
11:38:37 <gwern> no wonder it's so large and complex; 11 years of accretion and natural language stuff will do that to you
11:39:16 <conal> HugoDaniel: thx!
11:40:45 <HugoDaniel> conal: http://blog.inquirylabs.com/2009/05/02/silkworm-game-written-in-haskell/
11:40:45 <conal> ah.  i was running hpong from an emacs sub-shell.  if i run it in a terminal, i get graphics, but no interaction.
11:40:50 <HugoDaniel> glfw + haskell + osx
11:41:05 <MyCatVerbs> Vanadium: it's not all that complicated, I think.
11:41:14 <conal> HugoDaniel: cool.  thx again.
11:41:53 <MyCatVerbs> Vanadium: Every ST action, STRef and STArray has a tag 's'. runST requires that that tag must be exactly (forall a. a), which means that that tag must have no constraint on it whatsoever.
11:41:58 <moonpatrol> only if haskell could weedeat my lawn...
11:42:34 <MyCatVerbs> Vanadium: if you ever try to misuse ST, then you'll cause the tag to become more constrained than that, and runST will balk at it, so your program won't compile.
11:42:56 <Vanadium> I do not understand the nature of the constraints here
11:48:51 <gwern> Destructive updates make no sense!
11:48:54 <gwern> TELL THE PEOPLE
11:49:00 <HugoDaniel> spread the word :)
11:49:15 <ksf> THERE ARE NO DESTRUCTIVE UPDATES
11:49:38 <ksf> there's just World () threading your universe through your pineal gland.
11:51:29 <pikhq> There are no updates.
11:51:37 <pikhq> There is only evaluation.
11:52:10 <conal> and/or: the universe is a pure function of space-time
11:52:10 <skorpan> i hate destructive updates since i tried (sort list-of-strings #'string-lessp) in elisp which removed one element in the list under certain circumstances
11:53:35 <HugoDaniel> destiny
11:53:35 <Makoryu> > let IO = Writer in "COME ON YOU APES, DO YOU WANT TO LIVE FOREVERRR" -- Someone should reimplement IO as a State monad just for shits and giggles
11:53:36 <lambdabot>   Not in scope: data constructor `IO'
11:53:59 <pikhq> Makoryu: That would be quite amusing.
11:54:13 <pikhq> "No, really. Haskell is *purely* functional."
11:54:26 <conal> heh
11:55:02 <conal> and so is C (http://conal.net/blog/posts/the-c-language-is-purely-functional/)
11:56:09 <pikhq> conal: Funny you should mention that...
11:56:16 <pikhq> That is actually what inspired me to learn Haskell.
11:56:27 <conal> pikhq: seriously?!
11:56:30 <pikhq> Yeah.
11:56:42 <conal> cool :)
11:59:59 <Phyx-> IO as a State Monad?
12:00:02 <Phyx-> o.O
12:00:03 <conal> HugoDaniel: i'm grateful for the Silkworm pointer.  It shows me how to wrap up programs as os x apps.
12:00:10 <copumpkin> @src IO
12:00:10 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:00:16 <copumpkin> Phyx-: yup!
12:00:31 <Phyx-> lol, wtf
12:00:39 <Phyx-> @src RealWorld
12:00:39 <lambdabot> Source not found. Are you on drugs?
12:00:46 <Phyx-> I suppose
12:00:50 <copumpkin> RealWorld does almost nothing
12:00:53 <conal> i think that "definition" is a hack though.  the semantics don't match IO
12:01:37 <mike-burns> I assume that's only how it pretends to work and the compiler really does something very different with IO.
12:01:39 <HugoDaniel> cool conal :)
12:01:46 <Makoryu> Ostensibly, IO is defined in terms of RealWorld. In actuality, GHC (and some other implementations) just have IO primitives with side effects
12:01:50 <copumpkin> mike-burns: nope, that's GHC's definition
12:02:07 <Phyx-> well, semantically that newtype made sense, but i always thought IO was some kinda black voodoo
12:02:28 <sjanssen> Phyx-: it's implemented on black voodoo
12:02:30 <conal> semantically, the newtype doesn't make sense, since IO has concurrent & nondeterministic semantics.
12:02:35 <sjanssen> RealWorld# is especially magic
12:02:39 <Phyx-> ah
12:02:50 <copumpkin> it has no hash! :P
12:03:01 <copumpkin> it's not unlifted :o
12:03:03 <copumpkin> it's magick
12:03:33 <sjanssen> @src RealWorld
12:03:34 <lambdabot> Source not found. There are some things that I just don't know.
12:03:54 <sjanssen> oh, I guess it isn't unlifted, didn't know that
12:04:01 <conal> i.e., i don't think that type can account for concurrency.  that's why i think it's a lie/hack.
12:04:05 <Phyx-> can you actually use RealWorld in your own programs?
12:04:18 <Makoryu> I don't think it's exported
12:04:20 <sjanssen> conal: it isn't as though that's the exposed user interface
12:04:53 <sjanssen> conal: that definition just happens to be the most straightforward way GHC can deliver the desired semantics
12:05:22 <conal> what's State# ?
12:05:41 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#t%3AState%23
12:05:53 <conal> copumpkin: thx
12:06:16 <copumpkin> but the basic idea is that those things are only for the typechecker
12:06:24 <conal> sjanssen: is forkIO really definable in terms of that IO representation?
12:06:39 <copumpkin> that is actually GHC's internal definition of it
12:06:54 <Phyx-> @src forkIO
12:06:55 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
12:06:55 <lambdabot>     where action_plus = catchException action childHandler
12:06:59 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#IO
12:07:09 <conal> i wonder how it could work.  that definition is the classic denotational semantics of sequential (non-concurrent) imperative languages.
12:07:20 <Phyx-> what are the (# #) blocks
12:07:31 <copumpkin> unlifted tuples
12:07:35 <Phyx-> ah
12:08:16 <conal> and how is fork# defined?
12:08:33 <sjanssen> conal: compiler primitive
12:08:36 <Makoryu> That looks like a primitive to me
12:09:07 <conal> that's what i figured.
12:09:49 <conal> i get the impression that many people think IO really is definable via this representation.  which i think is not the case.
12:09:58 <copumpkin> how is it not?
12:10:32 <copumpkin> RealWorld doesn't have any particular meaning beyond convincing the compiler to create dependencies that lead to sequential execution
12:10:35 <conal> copumpkin: because there are operations on IO that (I think) require magic to implement.
12:10:35 <copumpkin> as far as I can tell
12:10:59 <sjanssen> conal: I think everybody knows that RealWorld is a lie
12:11:10 <trofi> :]
12:11:24 <conal> sjanssen: i'd hope so.  i get a different impression from many comments.
12:11:29 <Phyx-> -.-
12:11:41 <Makoryu> sjanssen: That and TheCake#
12:12:05 <conal> it matters to me, because i'd like people to realize that when they use IO, they've left the simple/rigorous semantics of functional programming.
12:12:19 <sjanssen> conal: I don't think that's quite true
12:12:45 <sjanssen> I'd say that using IO is like using purely function semantics to script an imperative machine
12:13:08 <conal> sjanssen: me too.  except that the machine itself has no precise semantics.
12:13:20 <MarcWeber> nominolo: I've some new patches for you. What do you think, is it time to announce the working vim backend on haskell-cafe ? If there are more users maybe some more patches will be provided as well..
12:13:26 <conal> and people really do rely on IO meaning something, even though they don't know what the meaning is.
12:13:27 <Cale> Well... depends on what you mean by 'has'
12:13:35 <conal> in a precise way.
12:13:39 <Cale> Of course in some sense it has a precise semantics.
12:13:44 <yitz> conal: what's not precise about it?
12:13:45 <sjanssen> values of type 'IO a' are still pure until you dig into compiler primitives
12:14:28 <conal> i'm not suggesting IO isn't 'pure', since everything is pure if you look at it that way.  i mean having a tractable, precise denotational semantics.
12:14:29 <Cale> I think it comes down to what it means for mathematical objects like this to exist ;)
12:14:31 <Trinithis> Wait, for concurrency, couldn't RealWorld be used in that threading can be implemented in a single threaded manner?
12:15:00 <sjanssen> Trinithis: possibly, except that GHC's threads are pre-emptive and concurrent
12:15:01 <Cale> I really dislike that RealWorld approach even if it could be made to work.
12:15:12 <conal> Trinithis: and IO is nondeterministic.
12:15:46 <Trinithis> nondeterminism could be solved though.. .I think (even given that RealWorld isnt a great way to think abou tit)
12:15:56 <sjanssen> a deterministic IO wouldn't be terribly useful
12:15:59 * ksf prefers to think of the IO monad as the warm, fuzzy realm of POSIX semantics.
12:16:21 <pikhq> sjanssen: Useful? Bah.
12:16:34 <ksf> though it's arguably more fuzzy than warm, not only occasionally.
12:16:43 <Cale> conal: Obviously there is *some* mathematical object that we could attach to IO actions such that equality of those mathematical objects is whatever notion of equivalence on IO actions we'd like to impose.
12:16:52 <dilinger> mm, sharp pointy POSIX
12:16:53 <Cale> and that would be a semantics for IO
12:16:57 <dilinger> er, i mean warm and fuzzy
12:17:10 <conal> Cale: yeah.  i want a tractable (simple) mathematical object.
12:17:21 <conal> for me, simple & precise denotational semantics is the foundation of precise reasoning about functional programs.  and it doesn't hold for IO.
12:18:00 <Cale> I suppose for IO, the denotational semantics has to be a little more complicated.
12:18:13 <copumpkin> people often say that IO is a generic sin bin
12:18:18 <Phyx-> 21:12 < sjanssen> I'd say that using IO is like using purely function semantics to script an imperative machine
12:18:21 <Phyx-> 21:13 < conal> sjanssen: me too.  except that the machine itself has no precise
12:18:21 <copumpkin> that isn't verypretty
12:18:25 <yitz> conal: forks are an unordered set of ordered IO actions, each of whose order relative to other threads is undetermined. Do you need something else?
12:18:25 <Cale> copumpkin: I'm not sure I agree with that.
12:18:30 <copumpkin> has there been any work in improving IO?
12:18:41 <Phyx-> oops, sorry about that, accidently pressed insert
12:18:41 <copumpkin> Cale: how would you put it?
12:18:59 <Cale> I think IO is an appropriate compromise for interacting with what already exists outside of Haskell.
12:19:04 <yitz> copumpkin: why does it need to be improved?
12:19:39 <copumpkin> yitz: because haskell likes to experiment with new approaches to things? :P
12:19:42 <conal> copumpkin: i think there was a lot of progress until monadic IO, which avoided the problem of functional I/O rather than solving it.
12:20:05 <conal> yitz: to improve reasoning.
12:20:16 <yitz> conal: what can't you reason about?
12:21:03 <Trinithis> Has anyone found out if comonadic io is possible?
12:21:09 <conal> i don't have a semantic model for IO, so i have almost no basis for what IO programs mean.
12:21:17 <conal> yitz: ^^
12:21:30 <conal> yitz: and meaning is always where i start with reasoning.
12:21:48 <Cale> I don't care to say that the IO monad avoids the problem of functional I/O. It is a solution. It may not be an ideal solution for all circumstances, but it does have one simple advantage over many approaches: it is very obvious how to design IO monad interfaces to existing functionality.
12:22:10 <Trinithis> IO monad vs Uniqueness types?
12:22:38 <conal> Cale: by "avoids the problem", i mean avoids avoids having to discover a useful, compositional semantics.
12:22:47 <conal> Cale: of course it's a very useful hack.
12:23:23 <Cale> Whether we like it or not, the whole model of computing up to this point has been imperative, and in order to be at all practically useful, a language *must* be able to interface nicely with that stuff.
12:23:24 <yitz> conal: I'll agree with Cale here. The primitive IO actions are denotationally opaque, because they represent calls to outside systems that were not designed to have well-defined denotational semantics.
12:23:48 <Cale> (at least, as a general purpose language)
12:24:09 <yitz> conal: however, each has an informal description, in the language of the outside systems, that in practice everyone understands pretty well.
12:24:09 <Cale> But I'm all for trying other ways of structuring programs which are more amenable to analysis
12:24:14 <conal> Cale: i guess different people have different questions.  mine is always "what does it mean?", and so monadic IO leaves me unsatisfied.
12:24:33 <yitz> conal: write an operating system
12:24:46 <yitz> conal: (really. it would be great!)
12:25:03 <conal> yitz: that's exactly the sort of research people were doing before monadic IO came along.
12:25:22 <conal> yitz: and the sort of work i'd like to see the research community return to.
12:25:25 <Cale> conal: I'm not sure they really stopped, have they?
12:26:06 <conal> Cale: if you mean with simple denotational semantics, i haven't seen much since monadic IO
12:26:59 <sjanssen> conal: if the IO Monad hadn't been invented, do we have any assurance that a better alternative would have been invented?
12:27:20 <sjanssen> even if IO isn't the best solution, I think its invention is key to any success Haskell has had thus far
12:27:21 <conal> sjanssen: we never have assurance.  i think we'd have had a better chance.
12:27:37 <Cale> Before the IO monad, we were using continuation passing I/O. Was that actually easier to analyse?
12:27:40 <conal> sjanssen: me too, for some value of "success"
12:28:20 <conal> Cale: i don't know, but i sure don't advocate the continuation passing model.  i advocate continuing to work on the problem.
12:29:17 <conal> my real beef with monadic IO is only that it superficially looks like it's functional/denotational IO, and i suspect that surface resemblance is why people stopped working on functional/denotational IO.
12:29:48 <Cale> I'm just wondering what other approaches existed that people stopped working on.
12:29:57 <conal> so i don't want to banish the IO trick (generating semantically opaque imperative computations).  i want to encourage thought about semantically transparent alternatives.
12:30:19 <conal> semantically transparent and pragmatically usable.
12:31:08 <conal> in my bones, i'm a researcher.  so i'm not satisfied with "it works" and "it's better than continuation-passing IO", etc.
12:32:06 <conal> though my comments sometimex spark defensive replies, i really mean no criticism of the IO trick or of folks who like to use IO.
12:33:40 <gwern> '24 June 2009: GF version 3.0 released. No longer beta! ' <-- it only took 11 years to get out of alpha and beta!
12:34:00 <michaelfeathers> So is there anything like read :: Integer which works with somethiing like Maybe or Either?
12:34:55 <gwern> michaelfeathers: what do you mean?
12:35:07 <conal> michaelfeathers: there's reads, which gets you close.
12:35:21 <gwern> :t reads
12:35:22 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:35:26 <michaelfeathers> gwern: it looks like you have to be in the IO monad to catch exceptions.
12:35:34 <michaelfeathers> ..with try and handle.
12:35:42 <conal> michaelfeathers: i don't know if there's a standard function :: [(a, String)] -> Maybe a
12:35:58 <mux>  :t lookup
12:36:03 <gwern> :t maybe
12:36:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:36:05 <conal> michaelfeathers: yeah.  don't use read
12:36:41 <gwern> hm for some reason I thought there was a readMaybe
12:36:46 <michaelfeathers> Just want to convert a text representation of an integer into an Int
12:36:56 <michaelfeathers> (searching)
12:37:33 <conal> michaelfeathers: afaik, people keep reinventing readMaybe or the [(a, String)] -> Maybe a function.  could easily go into the Prelude, along with reads.
12:38:11 <trofi> :t readS
12:38:13 <lambdabot> Not in scope: `readS'
12:38:15 <conal> or a read variant that takes a default.
12:38:34 <trofi> :t reads
12:38:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:38:56 <trofi> :t execute
12:38:58 <lambdabot> Not in scope: `execute'
12:39:05 <michaelfeathers> It's just that read has that nasty exception
12:39:20 <conal> michaelfeathers: right.  use reads instead.
12:39:38 <trofi> :t evaluate
12:39:39 <lambdabot> Not in scope: `evaluate'
12:39:44 <conal> michaelfeathers: in a utility function of type Read a => [(a, String)] -> Maybe a
12:40:02 <michaelfeathers> Thx
12:40:07 <conal> :)
12:40:46 <conal> michaelfeathers: oh.  i mean Read a => String -> Maybe a, defined using that other utility function.
12:41:13 <trofi> @src reads
12:41:14 <lambdabot> reads = readsPrec minPrec
12:47:48 <Peaker> conal: about the IO stuff -- you say people have stopped working on finding other solutions, but you have worked on it quite a bit, and your work has gotten many others to try things out as well.. I think the current research problems revolve more around implementation issues than design questions, no?
12:49:46 <Peaker> About reads, there's that HT utils package which has a read in Maybe, iirc
12:50:03 <conal> Peaker: right, i have worked on functional/denotational approaches to I/O, and some others have been inspired by my work.  that's what i meant by "not much".  i'd like to see fundamentally innovative work in addition to FRP.  and i think the problems in frp are in both implementation and model.
12:51:01 <conal> Peaker: (and i do enjoy that people like the frp ideas)
12:51:09 <Peaker> conal: s/like/love :-)
12:51:24 <conal> :D
12:52:18 <Phyx-> lol
12:52:24 <Peaker> conal: yairchu is making some progress with his attempt at FRP.  He's focusing more on succeeding to implement it than on a simple denotational semantics, but I'm hoping he'll end up with nice ones
12:52:58 <conal> nice.  i hope so also.
12:54:01 <conal> and more than embracing FRP, i'd like to see folks embrace denotational design, which is what gave rise to FRP.
12:55:22 <Peaker> conal: I think luqui's article about "Semantic Design" was great at illustrating that point. I definitely changed the way I think about software design due to that.  I think that maybe, if a tutorial showed how to attack problems denotationally and how nicely it ends up, it could convince more people
12:55:23 <mreh> these dependencies on hackage dont list any version numbers?
12:55:49 <Orclev> semantic design? link?
12:56:01 <conal> Peaker: i bet you're right.  i like that article of luqui's.
12:56:06 <Peaker> Orclev: http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
12:56:13 <Orclev> thanks
12:57:19 <conal> Peaker: semantic design is a constant thread through all of my work, but i've only recently started talking about it explicitly.  maybe i realized only recently that it's an unusual perspective.
12:58:21 <Orclev> ooooh, yeah, just from the first couple paragraphs that makes sense... it's actually the way I'm used to thinking about OO design and the way I approach most problems intuitively, I just didn't have a name for it
12:58:25 <conal> when i learned denotational semantics (at CMU), it was taught as a tool for defining programming languages.  it's much more useful as a tool for defining data types, since we define many more types than languages.
12:59:36 <conal> Orclev: also check out http://conal.net/blog/posts/denotational-design-with-type-class-morphisms/ .  it's somewhat specific to type classes but is the most direct thing i've written about denotational design.
13:00:32 <conal> i now use the term "denotational design" rather than "semantic design" to distinguish from other notions of "semantics" (particularly operational notions)
13:00:58 <Orclev> I'm still working on wrapping my head around type classes, I'm still pretty new to haskell and functional programming, most of my experience is in Java and Perl
13:00:59 <Peaker> my understanding of denotational semantics is that to understand an expression's meaning you only have to understand the meaning of its component sub-expressions, and the meaning of the expression's composition should be the composition of the meanings
13:01:28 <Peaker> conal: do you think that captures the essence, or is too narrow/wide?
13:02:58 <conal> Peaker: that part is spot on.  i'd add something you probably mean implicitly: every syntactic category has a meaning.  and the meaning of an utterance of belongs to the meaning of the category's meaning.
13:03:29 <conal> Peaker: however, those descriptions are biased toward languages & expressions, while i prefer to think of types & values.
13:03:44 <conal> Peaker: which is a broader/simpler notion
13:03:55 <conal> well, broader anyway.
13:04:16 <conal> and a lot more useful.
13:05:19 <Orclev> what do you mean by syntactic category?
13:05:30 <Peaker> "expression" may be a bit too specific, but I imagine things that compose as well as expressions would have to be pretty similar or even isomorphic to expression graphs
13:05:39 <conal> Orclev: e.g., expression vs statement in C
13:05:56 <conal> Orclev: or expression vs pattern or definition in haskell
13:08:23 <conal> and there's a folk wisdom in denotational semantics that the essence of a language (semantically) is contained in the definitions of semantic domains (meanings of the syntactic categories) alone.
13:08:51 <conal> the particular meanings of the syntactic constructors (application, abstraction, assignment, ...) just fill in details.
13:09:18 <conal> that wisdom at the heart of how i design software.
13:09:36 <conal> and what luqui was getting at in his blog post
13:11:50 <Peaker> conal: I wonder if relatively inexperienced developers are capable of implementing software designed this way. The way the denotations translate to an implementation may be somewhat tricky
13:12:16 <Peaker> conal: It may just be a preconception though, implementing non-denotational software is tricky as well, to say the least
13:13:59 <conal> Peaker: given some code, i'm always curious first about "What does it implement?"  those developers can bang out some code, but without knowing what question they're answering, it's hard for me to care about the code.
13:14:16 <ksf> conal, I guess when you want to have a rigirous semantic for IO, you're going to have to implement a limited set of IO actions on top of the current IO Monad
13:14:41 <Peaker> ksf: or use an alternate paradigm
13:14:45 <ksf> there's certainly a lot of stuff that could be showed into different monads to untangle things.
13:14:59 <Peaker> ksf: why necessarily "monads"?
13:15:18 <ksf> Peaker, I won't say anything against using another paradigm if it makes sense.
13:15:19 <conal> ksf: i'm more interested in replacing IO with something more tractable, rather than explaining the current sin bin.
13:16:02 <ksf> well, at some point we've got to interface to the POSIX world... whether that beast is called IO or FFI is just an alpha conversion.
13:16:46 <Peaker> ksf: firstly, we might instead replace the POSIX world. Secondly, even if you do, you don't have to focus on the POSIX/FFI side of things, you can possibly abstract it away into something that has simple semantics
13:17:01 <conal> pure, lazy functional programming is implemented with lots of side-effects.  i suspect we can replace even more of our current low-level thoughts on programming models with high-level thoughts, moving machinery into the RTS.
13:17:05 <ksf> I don't think it makes much sense to completely give up that FFI-monad, even though there's much, much sense to be found in doing a cleaner semantics.
13:17:06 <Orclev> Like I said before, I'm relatively new to Haskell, but my understanding is that IO is conceptually a transformation of the "world state", although in practice I can see how it kind of turns into a sin bin
13:17:11 <Peaker> (in which case, you wouldn't mind that your nice semantics are implemented via non-tractable semantics)
13:17:48 <conal> Orclev: that conceptual model is the misconception i mentioned earlier that worries me.
13:18:11 <Peaker> ksf: oh, sure, you can expose the non-tractable world somewhere deep down the machine (e.g RTS). But that's not the kind of interface people should be using for ordinary work, just for implementing the language/RTS
13:18:21 <conal> Orclev: because it's a comforting lie.  i prefer a discomforting truth.
13:19:01 <Phyx-> damnit, i hate it when i missplace haskell files
13:19:51 <conal> Orclev: the lie is that the conceptual model doesn't explain concurrency.  not even concurrency between the world (universe) and a computation -- let along between computations.
13:20:42 <ksf> conal, is there really a way to model nondeterministic multithreading without having full control of the OS?
13:21:09 <ksf> I guess the best you can do is to ensure proper separation of concurrent accesses.
13:21:20 <jfoutz> the (few) bits of threading in haskell code i've done always look erlangish. some threads with mchans hooking up the communication. i really like that model.
13:21:44 <conal> ksf: i wouldn't try.  modeling the mess keeps the mess.
13:22:04 <Peaker> ksf: you can use threads in an implementation of a clean semantics, though
13:22:13 <conal> Peaker: exactly!
13:22:18 <Peaker> (the implementation of the clean semantics may based in unclean semantics)
13:22:24 <Orclev> conal: well, concurrency is itself something of a lie, as if you dig down deep enough very little actually occurs at the same time, it's just that we deal with chunks of execution that are so coarse they appear to overlap when in reality at the smallest levels they're interleaved rather than overlaped
13:22:44 <conal> just like pure, lazy functional programming uses lots of side-effects and has simple formal semantics.
13:23:10 <jfoutz> Orclev: no, not really any more. dual core or more chips are quite common.
13:23:30 <conal> besides, do we want to model *machines*??
13:23:43 <conal> or use machines to model our ideas?
13:23:44 <badsheepy> iwant to model massive robots
13:23:48 <badsheepy> but thats notimportant rightnow
13:24:08 <conal> personally, i'm more interested in using machines than in modeling them.
13:24:23 <ksf> the problem isn't whether they're concurrent or not, the problem is the unpredictability, or rather, unclean semantics around the unfettled edges of concurrent access. POSIX is full of them, networking likewise.
13:24:24 <Orclev> jfoutz: I've got a quad-core, and even though quite a bit can happen concurrently in the chip, once you start interacting with the rest of the system most of the concurrency goes away... hell, most multi-core systems don't even have seperate L2 cache for each core
13:24:26 <monochrom> To model a massive robot, just model a general robot, then let mass = 1000kg or something.
13:25:07 <badsheepy> increasing mass without side effects would violate so many rules of physics :o
13:25:26 <ksf> conal, just as a thought, it might be wise to start working on networking, which is a smaller domain, and at least as messy.
13:25:31 <conal> even in #haskell (devoted to a functional programming language) i keep seeing these arguments that presume we ought to be modeling our machines.
13:26:02 <monochrom> Yeah. The machines should model us instead.
13:26:10 <conal> heh.
13:26:16 <conal> at least model our thoughts.
13:26:23 <ksf> every model is a lie.
13:26:55 <ksf> if you dig down into it, IO () is the purest you can get: just the same, monadic fixpoint of the universe, all the time.
13:26:59 <monochrom> <dalek1> Hai I'm trying to model monochrom  <dalek4> That's easy, he's so logical.
13:28:09 <Peaker> conal: Haskell is also a powerful imperative language :)
13:28:27 <Philippa> conal: many people have a need to model the machine in the immediate term for various reasons - it's not unreasonable to make those arguments
13:28:28 <conal> ksf: on "every model is a lie", i'd rephrase: our implementations don't match our models exactly.  i don't mind.  for me, forms exists to suggest ideals, not to be ideals.
13:28:49 <jfoutz> conal: modeling an actual computer is pretty silly, but i can imagine some utility in modeling real physical systems, like water flowing to reservoirs ... the great hope for OO was to represent ideas more like average people think about things.
13:29:24 <jfoutz> <- average programmer.
13:29:27 <conal> jfoutz: yeah -- modeling physical systems.  OO has a fundamental failing though, of using a discrete time model.
13:29:28 <ksf> ugh. we should program in fuzzy logic, then.
13:29:56 <Orclev> bah, duty calls, I need to attend to something which is unfortunate as this was getting rather interesting
13:30:10 <conal> Peaker: sort of, though i'd say differently: Haskell is a powerful functional language that can be used, among other things, to describe imperative computations.
13:30:11 <ksf> brains are awfully hard to program. instead of giving you errors, they just don't do what you'd like them to do.
13:30:38 <Peaker> conal: yeah, what I mean is that not all #haskell'ers would be functional programmers looking to do everything functionally
13:31:17 <ksf> that is, they just don't segfault in any sane manner. which is a bugger if you forgot to initialise your memory properly.
13:31:43 <Philippa> *nod*. Haskell makes a powerful general modelling language, and thus a powerful base for a multi-paradigm system for example
13:32:10 <conal> Peaker: yeah.  i was confused for a while, assuming that Haskell programmers wanted what i want, which is to use the functional paradigm pervasively, rather than leaving a big chunk to a semantically traditional imperative engine.
13:32:59 <ksf> well it's always tempting to just tool around with accustomed semantics in a more powerful way.
13:33:19 <conal> ksf: yeah.  haskell+IO is great for that game!
13:33:31 <ksf> way better than messing around with C macros.
13:33:54 <jfoutz> ksf: i guess... most people have specialized hardware in their brain for interacting with newtownian physics. if there is an approximate mapping between the code and a physical model, you get some benifits.
13:33:57 <Philippa> conal: not everyone who's happy using the IO monad uses it as a 'big chunk', either - it's pretty common to make it as thin a layer as you can
13:34:43 <ksf> we don't only have specialized hardware for newtonian physics, but also for abstract interactions.
13:35:15 <jfoutz> fair enough. :)
13:35:25 <ksf> like "I can tell person A to give object B to person C" can be reduced to "I gave person C object B"
13:35:31 <conal> jfoutz: the inherently discrete-time nature of imperative computing (e.g., C or IO) thwarts that newtonian goal.  i don't see OO folks admitting that point.
13:36:09 <ksf> (the interesting bit is that truth is only defined in a specific context, there)
13:36:50 <Philippa> conal: it's at least somewhat non-obvious to the average programmer that it /is/ inherently discrete-time
13:37:09 <ksf> ...I also don't see OO guys implement a gearbox if they want to multiply or divide.
13:37:38 <Philippa> or alternatively, what the consequence of not being discrete time would be - "but surely events happen at fixed moments and I can sample as needed?"
13:38:02 <ksf> uhm isn't even reality discrete?
13:38:03 <conal> suppose OO were "improved" (for modeling) to use continuous time.  how might it turn out?  i'm guessing it'd look something like pure functions and maybe frp.
13:38:05 <Philippa> (if you want to look at it another way, they can encode what feels like enough of FRP /extremely badly/)
13:38:57 <conal> ksf: maybe or maybe not.  in any case, our mainstream programming models haven't even caught up with newton yet.
13:39:00 <Philippa> depends, not least on the formulation of OO involved - is there a difference between field access and message-passing?
13:39:02 <p_l> ksf: discrete and possibly only 3 dimensional (including time)
13:39:09 <ksf> continuity is just another lie we use because our perception is limited.
13:39:32 <Philippa> (a continuous model needs a notion of property precisely so it can change over time, messages ~= events)
13:40:12 <Philippa> it's likely to at least look like an imperative-flavoured layer on top of FRP though. UnrealScript is the closest example I can think of
13:40:39 <jfoutz> smalltalk with one thread per object. something like that maybe.
13:40:51 <Philippa> jfoutz: no, that's not enough at all
13:41:32 <conal> jfoutz: threads don't help much.  dynamic values still change discretely in that model.
13:42:08 * Philippa wonders briefly if conal has her on ignore - if so, he'd probably appreciate the mention of UnrealScript
13:42:55 <conal> Philippa: hi.  not on /ignore.
13:43:39 <Philippa> thanks
13:43:54 <Philippa> have you met US before? If not, want a summary?
13:44:05 <jfoutz> conal: i think i see. threads can get you far enough to model... say a traffic intersection where events happen at well cordinated times, but you're still kinda hosed if you want to model a pool table.
13:44:24 <conal> Philippa: i'll look it up.  thx.
13:45:09 <Philippa> the bits you'll want to check for are latent functions and states
13:45:45 <conal> jfoutz: it could be a fun thought experiment.  suppose you want to model continuous dynamic values as such.  go from there.
13:45:54 <Philippa> it's pretty much equivalent to a monadic layer on top of an FRP setup with a central message 'switch'
13:46:27 <conal> jfoutz: in following through, you may notice that you've been programmed by imperative/OO languages as much as you've programmed in them.
13:46:39 <Philippa> I'm not quite sure whether you'd consider that an abomination or a sensible way of thinking up to a point, mind :-)
13:46:39 <copumpkin> in soviet russia!
13:46:44 <jfoutz> conal: i don't doubt that at all.
13:47:17 <Philippa> (it seems to me that for games it's largely the right thing while game designers model their domain the way they do at the moment)
13:48:34 <conal> early computers were so weak, that the languages had to relect their sequential nature (for efficiency).  sadly, while machine power increased enormously, those early languages still dictate programmers' thinking.
13:49:01 <copumpkin> a soviet-russia-based argument is what's lacking
13:49:08 <copumpkin> it'll make imperative programmers see the error of their ways
13:49:49 <nominolo> MarcWeber: yes, I want to smooth out the build process a little bit and then release it.  It's a bit unfortunate that I can't test the Vim stuff myself; other OS X users will likely have similar issues.
13:49:52 <conal> as pat hanrahan said, modern "general purpose" cpus execute only one program: a simulator of an old-fashioned, von neumann sequential computer
13:50:04 <thoughtpolice> it seems most programming languages were prematurely optimized for sequential execution
13:50:09 <mreh> anyone involved with the OpenGL package
13:50:14 <nominolo> MarcWeber: But this first release will be clearly marked as "preview" though, so that's fine.
13:50:15 <syntaxglitch> Philippa, wasn't UnrealScript devised in large part by Epic's CEO?
13:50:22 <copumpkin> mreh: not me, but I'm interested in it
13:50:23 <Philippa> syntaxglitch: yep
13:50:24 <thoughtpolice> and it's becoming harder to get out of :>
13:50:31 <ksf> the first thing that comes to mind if you want to model anything inside a game is usually "state machine"
13:50:34 <thoughtpolice> syntaxglitch: by Tim Sweeney, yeah
13:50:37 <copumpkin> thoughtpolice: zomg, what did you do with the doublethink?
13:50:37 <Philippa> he's muchly regretting having implemented it with a single pass compiler, it's a maintenance nightmare now
13:50:38 <jfoutz> conal: i think i see what you're getting at, if there are threads with objects or not, i still have to pass around a time value, constantly asking, well, what were you at 10?
13:50:45 <conal> thoughtpolice: and not just programming languages but also software engineering education.
13:50:47 <mreh> copumpkin, there's some kind of bug, or dependency issue
13:50:47 <syntaxglitch> I note that because Sweeney is an occasional participant on Lambda the Ultimate
13:50:53 <nominolo> MarcWeber: ultimately, I'd like it to have a good out-of-the-box experience a la Claus Reinke's Vim scripts
13:50:58 <mreh> i doubt it interest you
13:51:05 <Philippa> ksf: depends a bit, there. If you're modelling the ball in pong first, maybe not
13:51:20 <thoughtpolice> copumpkin: hehehe
13:51:26 <ksf> make some autonomous objects, make their state be their behaviour in the world, watch the beatiful emergent phenomena.
13:51:28 <nominolo> MarcWeber: e.g., a Vimball and perhaps nicer short commands
13:51:47 <conal> jfoutz: even more fundamentally, what's inside a thread?  if it's sequential execution, you're back to discrete time
13:51:54 <sshc> how do I determine where an infinite recursion is taking place?
13:51:55 <nominolo> conal: have you done any performance evaluations of your reactive library?
13:52:07 <mreh> sshc: you can't
13:52:20 <copumpkin> well in some cases you can
13:52:21 <copumpkin> but usually not
13:52:24 <mreh> "the halting problem is a good place to start"
13:52:29 <ksf> conal, "inside" the thread is some computation and a (virtual) cpu.
13:52:40 <ksf> the rest is illusion.
13:52:44 <sshc> is there a debugger for haskell?
13:52:54 <conal> ksf: because you believe in form more than in ideal.
13:52:57 <nominolo> sshc: ghci has (a simple) one
13:53:26 <conal> nominolo: no.  reactive doesn't even work yet.  i got stuck on some tricky bugs that may be RTS bugs and may be laziness subtleties.  sigh.
13:54:09 <nominolo> conal: it doesn't?  It took me a while to get a basic "hello world" working, so I didn't test it much further.
13:54:24 <copumpkin> @hackage reactive
13:54:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive
13:54:54 <ksf> well I don't think threading has any place in semantics... at least not in those I use to reason. Whether we've got a big thread that sequentialises every operation in the universe, or whether we've got a huge number of threads, one for each atom that synchronize through locks, it doesn't matter.
13:55:01 <conal> nominolo: several folks have tried to help track down the problems.  they typically end up trying to implement reactive from scratch using different approaches.  i haven't heard of a success (implementation agrees with semantics) yet.
13:55:03 <ksf> I'm a model agnostic, so to say.
13:55:16 <mreh> does anyone know when mapAccumL was added to base? I can't tell from hackage
13:55:23 <copumpkin> 6.10 I think
13:55:37 <mreh> why?!
13:55:42 <copumpkin> why not?
13:55:53 <mauke> I think mapAccumL is much older
13:56:12 <mreh> well it's in base 3.0.2.0
13:56:16 <conal> ksf: your implementation/form bias comes through in your language.  (as does my model/ideal bias.)
13:56:19 <mauke> it's in H98
13:56:23 <mauke> module List
13:56:28 <conal> ksf: e.g., "lie" and "illusion"
13:56:55 <mreh> [1 of 1] Compiling Data.Tensor      ( src/Data/Tensor.hs, dist/build/Data/Tensor.o )
13:56:55 <mreh> src/Data/Tensor.hs:333:18: Not in scope: `mapAccumL'
13:57:15 <nominolo> sshc: re debugger: there's a Monad Reader article on it
13:57:17 <conal> ksf: that's why i like to make those biases explicit and/or switch to more explicit language (like "implementation & model differ").
13:57:42 <ksf> well, that's because I don't see threads as a thing existing by themselves, but as a thing conjured up by sticking a computation to it, seperating it from the rest.
13:58:03 <nominolo> conal: btw, why do your Behaviours need to be continuous?
13:58:18 <ksf> they don't need to be, there's also stepper.
13:58:28 <nominolo> I heard there might be some weird issues about the notion of "at the same time" and loops
13:58:29 <conal> nominolo: do you mean why continuous time?
13:58:33 <nominolo> yes
13:58:35 <ksf> behaviours need to be sampleable at any time, though, not just at the time of events.
13:59:06 <nominolo> right
13:59:16 <conal> my push-pull paper and the reactive implementation show that most behavior operations don't need time to be continuous.  just fully ordered.
13:59:21 <conal> nominolo: ^^
13:59:32 <sjanssen> mreh: forgotten Data.List import?
13:59:33 <conal> nominolo: however, i like continuous time for the same reason as continuous space.
13:59:35 <ksf> hmm I guess in reality, a thing can't influence itself in the same planck second. you need at least two: influence something else, that influences you, in the next planck second.
13:59:51 <conal> nominolo: better composability.  e.g., zoomable.
13:59:53 <mreh> sjanssen: I wish it were my code :)
14:00:15 <mreh> i
14:00:16 <sjanssen> mreh: it should be easy to see if Data.List is imported
14:00:16 <mreh> i
14:00:24 <mreh> i'm pulling it off cabal
14:00:27 <conal> nominolo: just like continuous vs discrete fonts (outline vs bitmap)
14:00:34 <nominolo> conal: ok, that leads me to a question:  In your GLUT+reactive you clear the screen each time, no?
14:00:36 <mreh> i'll try and get the source
14:01:00 <Philippa> can the issues re loops be solved simply by forcing everything through a delay?
14:01:17 <nominolo> conal: ok, I didn't look close enough yet to see whether the problems I was told about actually exist.
14:01:17 <Philippa> t may depend on t-epsilon, but not on t?
14:01:19 <conal> nominolo: yeah.  though that's not the only possibility.  it could do temporal anti-aliasing.
14:01:25 <poe> mreh: cabal unpack packagename gives you the source in ./packagename-version
14:01:33 <ksf> nominolo, that's the first law of thermograhpics: the sum of all pixel values over time is constant ;)
14:01:38 <mreh> poe: thanks
14:01:57 <Philippa> people actually code up temporal antialiasing in various forms, too - consider motion blur...
14:02:07 <conal> nominolo: there are some subtleties, and people often confuse implementation issues with semantic issues.  so i'd take those comments with salt.
14:02:57 <conal> nominolo: continuous time makes the semantics really simple and precise.  much more so than discrete, threaded approaches.  for instance, frp semantics is deterministic.  which is huge simplifier.
14:03:27 <nominolo> conal: well ideally implmentation and semantics should match ;)
14:03:30 <conal> deterministic and pervasively, finely concurrent
14:03:41 <ksf> btw, conal: did you ever think about recording , rewinding and playing back a run of a reactive program?
14:03:43 <conal> nominolo: indeed!
14:03:56 * ksf thinks it should be quite trivial
14:04:01 <ksf> ...up to a point.
14:04:04 <Philippa> nominolo: yeah, unfortunately taking discrete samples of continuous behaviour is rather infamous for producing artefacts
14:04:06 <conal> ksf: yes, certainly.  i have some examples in the early fran tutorial.
14:04:15 <nominolo> Philippa: yet unavoidable
14:04:22 <mreh> sjanseen: you were corrct
14:04:37 <conal> ksf: http://conal.net/fran/tutorial.htm
14:04:40 <mreh> now I need to patch this package somehow, waiting for an update will take ages
14:04:41 <nominolo> conal: I was wondering how one could FRP-ise Gtk
14:04:52 <Philonous> I got hmatrix to install after manually fixing the config.hs. Apparently the test for gsl ignored extra-include-dirs and extra-lib-dirs and uses bash syntax that is not compatible with tcsh
14:04:53 <nominolo> conal: and was wondering how to do incremental updates
14:05:12 <conal> nominolo: incremental updates for semantics or for performance?
14:05:18 <nominolo> performance
14:05:42 <Philippa> nominolo: well yes. The thing is, there's a lot of stuff that had continuous semantics somewhere in the spec chain
14:05:46 <nominolo> you could collapse multiple redraw events into one of course
14:05:47 <conal> nominolo: to FRP-ise *any* imperative toolkit, i start by asking which discrete inputs are naturally discrete and which are natural continuous.
14:06:01 <sjanssen> mreh: is Data.Traversable imported in that file?
14:06:07 <conal> nominolo: a lot of incrementality happens automatically in reactive
14:06:22 <mreh> sjanssen: yes
14:06:32 <conal> nominolo: because it's much more of a data representation than previous frp architectures.
14:06:35 <mreh> is Data.List reexported by it?
14:06:44 <nominolo> conal: right, so I basically any state is a Behaviour and any change of state is an Event
14:07:09 <ksf> usually, there's a duality.
14:07:15 <nominolo> sure
14:07:15 <sjanssen> mreh: Data.Traversable exports another version of mapAccumL, which this package probably uses
14:07:18 <conal> nominolo: yeah -- close.  though i like to separate state-change from events.
14:07:20 <sjanssen> mreh: which GHC version are you on?
14:07:25 <ksf> i.e. buttonState :: Behaviour vs. ButtonClick and buttonRelease.
14:07:30 <nominolo> conal: ah, interesting
14:07:30 <conal> nominolo: s/separate/distinguish
14:07:40 <conal> ksf: yeah
14:07:40 <mreh> 6.8.3
14:07:46 <nominolo> conal: right, that's what they do in those "cells" frameworks for changes
14:07:46 <mreh> sjanssen ^
14:08:02 <nominolo> those generalised Excel frameworks
14:08:29 <ksf> it'd be a bugger of course if you sample buttonState on a buttonClick event and get "up" because buttonState hasn't been updated yet.
14:09:32 <ksf> well I guess it's undecidable in general whether one wants to have a delay in such situations or not.
14:09:34 <sjanssen> mreh: yeah, looks like mapAccumL was added in 6.10.  You might want to mail the author suggesting a base >= 4 constraint
14:09:45 <mmorrow> conal: when you say that you want a model of IO that has "semantically transparent", i don't understand what that means, but i really want to. can you explain? (in as concrete terms as possible, given that no such thing currently exists :)
14:09:57 <mmorrow> *that is "seman...
14:09:59 <nominolo> right, I came across that problem once -- if one thing triggers two other things which then trigger the same thing -- you suddenly end up with two events
14:10:00 <conal> ksf: yeah.  there are details to get right.  what i love about having a precise & tractable denotational semantics is that we know what "right" is. :)
14:10:58 <mreh> sjanssen: okay, what would you suggest the best path for me too?
14:11:16 <conal> mmorrow: i mean having a simple & precise mathematical model (semantic domain).  such a model then gives us (correct) intuitions and a basis for dependable reasoning.  for instance, we get "good for equational reasoning" etc.
14:12:30 <mmorrow> conal: so then applied to IO, this would mean that the language specifies exactly what to expect with e.g. forkIO, unsafePerformIO, block (...forkIO (... unsafePerformIO ....) ...), etc?
14:12:55 <sjanssen> mreh: if importing Data.List fixes the issue you can do that
14:13:07 <mmorrow> so defining exactly what those things mean and requiring implementations to implement them accordingly?
14:13:10 <Peaker> mmorrow: I think the Wikipedia entry on denotational semantics starts out well. It cleared things up for me
14:13:11 <conal> mmorrow: yes, via denotational semantics.
14:13:16 <ksf> mmorrow, that is, if not impossible, close to implossible.
14:13:28 <conal> mmorrow: denotational semantics for the IO type, not for the Haskell language.
14:13:48 <mmorrow> ksf: why? simply implement them so they behave as specified in the spec :)
14:13:55 <mmorrow> conal: hmm
14:13:59 <ksf> as you can't tell what two forkIO's writing to a file do to a third thread reading that file.
14:14:08 <ksf> same with chans.
14:14:26 <ksf> ...well it might work for forkIO, but use forkOS and you're lost.
14:14:29 <mmorrow> ksf: nor can you tell what (+) will do if the computer's on fire
14:14:57 <Berengal> mmorrow, probably _|_
14:15:02 <mmorrow> :)
14:15:04 <conal> mmorrow: that exercise is how i evaluate type designs.
14:15:22 <akatsuki> I want to make a dog in hs.
14:15:23 <conal> mmorrow: as luqui described
14:15:33 <conal> mmorrow: at http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
14:15:37 <mmorrow> conal: start your computer on fire, then start summing things?
14:15:39 <mmorrow> ;)
14:15:40 <ksf> akatsuki, sorry, we only got support for ponies.
14:15:41 * mmorrow looks
14:16:28 <akatsuki> ksf: whereis support?
14:16:36 <ksf> try "cabal install pony"
14:16:55 <conal> mmorrow: so i'd expect the outcome of that exercise would be hints at directions to look for replacing IO.
14:18:13 <mmorrow> conal: perfect
14:18:36 <conal> mmorrow: :)  and i don't expect much value to come from explaining the current IO type, because IO's purpose is to be the "sin bin", i.e., where we put things we don't know how to explain.
14:19:07 <sm> Item in the feed library does not derive Eq. Is there a shorthand way I can do that, or must I implement (==) in full detail ?
14:19:26 <conal> sm: try StandaloneDeriving
14:19:55 <nominolo> conal: do you know anything about reactive constraint programming?
14:19:57 <conal> sm: something like "deriving instance Eq Item"
14:20:07 <sm> thanks! will do
14:20:39 <nominolo> conal: it came up here http://lambda-the-ultimate.org/node/3560#comment-50482
14:21:04 <conal> nominolo: see http://conal.net/tbag/, which evolved in to FRP.  it was functional+constraint-based, reactive, and used continuous time.
14:21:08 <conal> nominolo: looking ...
14:23:27 <conal> when i moved from Sun to Microsoft Research, i intended to extend TBAG with fully declarative reactivity, sticking with constraint programming.  i wanted to understand functional reactivity before generalizing to relational (logic/constraint-based) reactivity.  which became fran/frp.
14:24:15 <conal> i still haven't returned to my original intention of fully relational temporal+reactive programming.
14:25:14 <ksf> but... but...
14:25:23 <ksf> conal, that blog post says "Sometimes we have to play all sorts of tricks to get an efficient implementation. But the point is that whatever representation we choose, and however we implement the operations on it, those operations must all have precise, meaningful definitions in the semantic domain."
14:25:47 <ksf> so then, what's wrong with using unsafePerformIO while implementing reactive
14:25:52 <ksf> (and yes, I'm teasing)
14:26:02 <conal> ksf: i
14:26:19 <conal> ksf: i'm not opposed to useing unsafePerformIO, when it's realy safePerformIO.
14:27:05 <conal> all of pure lazy functional programming is implemented via unsafePerformIO.
14:27:37 <conal> unsafePerformIO goes by a different name when used *inside* the RTS.
14:28:24 <ksf> yeah. I even found an excuse to use unsafeCoerce.
14:28:34 <conal> ksf: me too.  one use inside Eros.
14:28:48 <ksf> which is enumerating the Set of Doubles.
14:29:25 <conal> ksf: i hope to eliminate that one use, because it's only by *trying* to eliminate uses that i learn which uses can be eliminated.  and i'm curious.
14:29:45 <mmorrow> ksf: http://www.netlib.org/fdlibm/s_nextafter.c
14:30:38 <copumpkin> wow :P
14:30:57 <nominolo> looks like simple bit-level manipulation
14:31:11 <copumpkin> sure
14:31:41 <copumpkin> I was going to use unsafeCoerce in that enumerable module I wrote
14:31:52 <mmorrow> maybe we need a haskell pkg wrapping that :)
14:31:52 <ksf> yep that's more complex than map unsafeCoerce ([0..upperBound ::Word32] :: [Word23]) :: [Float]
14:31:54 <copumpkin> but decided to just avoid enumerating IEEE floats/doubles at all
14:31:54 <conal> similarly, people who believe that imperative thinking is somehow necessary are unlikely to discover otherwise.
14:32:39 <ksf> I recently discovered that I never really thought imperatively.
14:33:02 <conal> ksf: good for you!  it's a tough habit to kick.
14:33:16 <ksf> that is, I simply just don't get my old code if I read it as statements.
14:33:16 <NEEDMOAR> 7j #linux.no
14:33:57 <MyCatVerbs> NEEDMOAR: I'm curious. What keyboard layout do you use? Is your / key right next to your 7 key?
14:34:05 <copumpkin> or shift+7
14:34:05 <ksf> problems ensue if I need to keep too many statements in my head to see all the data deps, of course.
14:34:28 <ksf> iirc the german layout has / on shift+7
14:34:37 <conal> ksf: the image i get is that your imperative code is output of a compiler that's in your head.
14:34:43 <MyCatVerbs> copumpkin: ooh, I hadn't thought of that.
14:34:43 <Raevel> several european ones do
14:34:51 <Deewiant> Most European QWERTY-derivatives do
14:35:09 <conal> ksf: and you grok it when you're able to decompile back your mental source code.
14:35:12 <MyCatVerbs> Spiffy. You learn something new every day. ^_^
14:35:13 <copumpkin> aha: http://en.wikipedia.org/wiki/File:KB_Norway.svg
14:35:21 <copumpkin> mystery solved!
14:35:50 <ksf> well yes I'm thinking in data flow and fixed points.
14:35:55 <copumpkin> I remember my dad had a french keyboard where the numbers required shift
14:36:08 <copumpkin> that is, you couldn't type numbers without pressing shift
14:36:08 <MyCatVerbs> And we didn't even have to bring that stupid mutt and his meddling bipedal companions in.
14:36:55 <ksf> and a bit blurry and fuzzy blue-and white structures on a black background in 3d space
14:37:02 <NEEDMOAR> MyCatVerbs: as copumpkin said, shift + 7, I use an Spanish keyboard.
14:37:14 <copumpkin> ah :)
14:37:20 <MyCatVerbs> Cool beans. ^^
14:37:31 <ksf> ...but I only ever see one side of them, so I'm using dimensional transformations to follow links etc.
14:38:02 <akatsuki> "cool beans. ^^"
14:38:09 <akatsuki> thats so gay, stop saying that pls
14:38:22 * mauke braces for impact
14:38:23 <ksf> I'm already at a loss imagining truly three-dimensional structures... quad trees work, barely.
14:38:35 <ksf> (I guess 'cos they're space-filling)
14:38:41 <Makoryu> akatsuki: Frosted butts
14:39:03 <ksf> I think I could argue that I'm used to reason on paper.
14:39:36 <mauke> Makoryu: but who would frost a cake with their butts?
14:39:50 * Berengal uses his slight synesthetic abilities to reason
14:39:56 <Makoryu> mauke: Did you mean: "but who would frost their butts with a cake?"
14:40:17 <mauke> I don't think so. I mean, that wouldn't make any sense
14:40:52 <ksf> thinking sequentially, I'm quite prone to make errors.
14:41:10 <akatsuki> ksf: :PPPPPPPPppppPpP
14:41:17 <ksf> ...the equivalent of forgetting to propagate a carry while adding and such.
14:41:22 <akatsuki> I love the way functional programmers speak
14:41:29 <akatsuki> Like they're functionalizing thoughts
14:41:33 <akatsuki> see!
14:41:42 <Berengal> ksf, carries and signs are the death of me :(
14:41:54 <mauke> akatsuki: ... are you IRCing as root?
14:42:07 <akatsuki> mauke: no
14:42:26 <akatsuki> It's a spoof with the vhost
14:42:27 <moonpatrol> ha
14:42:31 <ksf> he's one of those guys who renamed the uid 0-user.
14:42:40 <ray> i wish @pl worked on english
14:42:47 <ray> @pl i wish @pl worked on english
14:42:48 <lambdabot> i wish @ pl worked on english
14:43:00 <monochrom> haha?
14:43:05 <ksf> (which is a really mean thing to do to people who're trying to brute force your ssh)
14:43:43 <mauke> ksf: meh, root logins over ssh should be disabled anyway
14:43:44 <ray> you could rename root to clyde and make a passwordless user named root
14:44:01 <akatsuki> mauke: why are you using /whois on me
14:44:11 <akatsuki> mauke: do you have a peculiar interest in me
14:44:15 <ray> except instead of a shell, it would play ascii star wars
14:44:18 <ksf> yeah but nothing beats being stoned and having someone despair 'cos they're not able to brute force a 4-char password.
14:44:18 <akatsuki> mauke: would you like my green light?
14:45:18 <mauke> akatsuki: you're weird
14:45:20 <Berengal> For a second, my internal typechecker balked at '4-char password' :P
14:45:43 <mauke> Berengal: it's all fine as long as you don't read it as '4-chan password'
14:45:45 <ksf> or discovering that someone left open a root shell and changing their prompt to C:\
14:45:50 <ray> no instance for Password
14:45:56 <Berengal> mauke, indeed. Who uses passwords on 4-chan?
14:46:16 <mauke> the site owners, presumably?
14:46:27 <akatsuki> mauke: elaborate on your theorie?
14:46:59 <MyCatVerbs> mauke: Of course not, because that would be a type mismatch. 4chan uses tripcodes, not passwords. :)
14:47:00 <mauke> akatsuki: no
14:47:24 <Cale> ksf: better yet, add something to their .bashrc which catches all signals, as well as adding an extra sleep to the end of their .bashrc each time it's run. It will take longer and longer for them to log in, and they won't be able to Ctrl-C to stop it.
14:47:58 <mauke> sl is a nice program
14:49:22 <ray> or just add that to the global bashrc as punishment for bash users
14:50:10 <monochrom> I use bash.
14:50:26 <ksf> my condolences.
14:50:48 <Ke> since when is bash bad
14:50:52 <Makoryu> I use zsh, and my sole complaint is that it echoes ^D as %
14:50:53 <ksf> since zsh
14:50:54 <Ke> =oP
14:50:58 <monochrom> I punish all non-bash users.
14:51:17 <fbru02> what is so much better about zsh?
14:51:30 <Ke> it couldn't do utf-8
14:51:44 <Ke> probably by now does
14:51:51 <fbru02> vim keybindings?
14:52:32 <Berengal> Ooo, I have postgres installed. Why have I been using sqlite all this time?
14:52:38 <ksf> {01..10} giving 01, 02, ... instead of behaving like {1..10}?
14:52:46 <copumpkin> Berengal: cause it's local and lightweight?
14:52:49 <ksf> precommands?
14:52:52 <mauke> ooh, nice. zsh has stopped segfaulting on ^D
14:52:56 <ray> copumpkin: zomg eq instance for functions
14:53:04 <Berengal> copumpkin, postgres is local on my machine as well, and quite a bit fancier
14:53:04 <copumpkin> ray: lol, people don't like it though :P
14:53:13 <copumpkin> ray: I'm still not sure how I feel about it :P
14:53:13 <ksf> ...so that you can actually set the title of your xterms to the program your'e running atm?
14:53:34 <ray> grab your lab coat and goggles because you're doing mad haskell
14:53:39 <ksf> there's a thousand little niceties hidden in zsh that make it just that tiny bit better, all over the place.
14:54:05 <copumpkin> ray: people weren't too happy that I wrote a function that either returns false or doesn't terminate (depending on the domain of the function you're looking at) :P
14:54:43 <monochrom> Haha sounds like a fun function!
14:55:14 <ray> copumpkin: they're just villagers with pitchforks and torches
14:55:25 <copumpkin> ray: lol
14:55:37 <copumpkin> well for functions with finite domains it will eventually terminate :P
14:55:50 <copumpkin> ray: even more useless than the Eq instance for functions is the Enumerable instance for them though :P
14:56:06 <monochrom> How does your function know a function's domain?
14:56:24 <copumpkin> it's Enumerable a, Enumerable b, Eq a => Enumerabe (a -> b)
14:56:43 <copumpkin> I then do some nasties and generate all functions of that type :P
14:56:49 <copumpkin> all total functions at least
14:56:50 <Saizan_> Enumerable a, Eq b => Eq (a -> b)
14:56:59 <monochrom> Ah! Thanks.
14:57:04 <copumpkin> Saizan_: yeah, I have that, but people didn't approve :P
14:57:26 <monochrom> I'm OK with it.
14:57:27 <ray> don't listen to them
14:57:36 <Saizan_> copumpkin: be like conal :)
14:57:53 <monochrom> I don't use it but why should I stop you?
14:57:53 <copumpkin> Saizan_: well, I sort of agree with them, but don't want to take it out either :P
14:58:00 <copumpkin> http://gist.github.com/167980 is the code if anyone's interested
14:58:49 <monochrom> FWIW there are a huge number of other hugely useless things and the huge majority of people still do them. Such as spectator sports.
14:58:58 <copumpkin> *Enumerable> (even :: Integer -> Bool) == odd
14:58:58 <copumpkin> False
14:59:09 <copumpkin> that kind of stuff works fine
14:59:13 <copumpkin> just don't ask if even == even
14:59:14 <copumpkin> :P
14:59:45 <ray> it's better than nothing though
14:59:56 <copumpkin> ray: well, if you really don't know whether they're equal or not
15:00:07 <copumpkin> you probably don't want to call it
15:00:11 <copumpkin> as it'll never terminate if they are equal
15:00:15 <mmorrow> copumpkin: hehe  http://gist.github.com/100370
15:00:15 <Vanadium> Just solve the halting problem and you can evaluate even == even easily
15:00:22 <ray> it's not like big scary industry programmers will be relying on your function equality test for billions of dollars worth of stuff
15:00:42 <copumpkin> mmorrow: yeah :P use that if you ever want to disassemble iphone kernels :P
15:00:50 <monochrom> Yeah, they rely on buggy leap-year code instead.
15:01:03 <mmorrow> copumpkin: i wouldn't have known wtf .idc was before yesterday
15:01:15 <copumpkin> *Enumerable> (+ (1 :: Word8)) == (+2) . (subtract 1)
15:01:15 <copumpkin> True
15:01:18 <copumpkin> that kind of stuff also works fine
15:01:37 <copumpkin> as long as you have a finite domain it'll eventually work
15:02:01 <ray> as long as it doesn't erroneously return True where it should return False or vice versa, i think it's correct
15:02:03 <Vanadium> So even == even would work if you used type signatures to limit the domain to Word8?
15:02:07 <copumpkin> yeah
15:02:08 <ray> i don't care if it diverges
15:02:15 <copumpkin> *Enumerable> (+) == (-)
15:02:15 <copumpkin> False
15:02:17 <copumpkin> that also works fine
15:03:09 <copumpkin> and you can do (+) == (+) and get True if you use a finite Num type
15:03:30 <ray> also, i didn't know about Omega
15:03:32 <ray> that's pretty cool
15:03:36 <copumpkin> Omega is wonderful
15:03:50 <Vanadium> copumpkin: Soo basically you are writing a slightly more thorough QuickCheck?
15:04:02 <monochrom> SlowCheck
15:04:09 <copumpkin> Vanadium: well, the idea was just to write a general enumerable class that allows you to enumerate all values of a given type
15:04:19 <copumpkin> Vanadium: but that allowed me to write a sort-of-Eq class for functions too
15:04:22 <ray> PossiblyTakesForeverCheck
15:04:31 <monochrom> FullCheck
15:04:37 <Saizan_> CheckUntil^C
15:04:38 <copumpkin> Vanadium: for example I have instance (Enumerable a, Enumerable b, Eq a) => Enumerable (a -> b) where
15:04:49 <monochrom> fsck --full
15:04:49 <copumpkin> the Eq a constraint bothers me but there's no way around it
15:04:49 <Vanadium> Right
15:05:29 <monochrom> I wonder if you also want to write an Ord instance, and how.
15:05:49 <ray> hmm
15:05:57 <copumpkin> yeah, I was wondering if I should specify some kind of law for instances
15:06:06 <ksf> whether or not a is smaller than b and by how much?
15:06:12 <copumpkin> that the list be ordered in "ascending magnitude" order whatever that means
15:06:26 <copumpkin> if I had some meaningful definition, I could get Ord on a whole bunch of odd things
15:06:53 <monochrom> list uses lexicographical ordering.
15:06:58 <copumpkin> yeah
15:07:10 <Saizan_> with constTrue = \a b .. -> True you can write fullCheck f = f == constTrue
15:07:41 <copumpkin> well, it'd also be quite possible for me to make a way to specify if an Enumerated type is finite or not
15:07:46 <copumpkin> and then write a real Eq instance for those
15:07:55 <copumpkin> and make an "exhaustive smallcheck"
15:08:05 <copumpkin> I dunno, maybe smallcheck already does this
15:08:09 <monochrom> X-Check
15:08:31 <copumpkin> and the only non-finite one I have is Integer
15:08:38 <copumpkin> well, along with lists
15:08:39 <edwardk> so, are you making Float Enumerable? =)
15:08:46 <copumpkin> edwardk: I was tempted to, but avoided it :P
15:08:49 <ksf> float is definitely enumerable.
15:08:51 <edwardk> bah ;)
15:08:53 <ray> functions are ok, floats are icky
15:08:58 <edwardk> ksf: yes, exactly =)
15:09:10 <copumpkin> also Integer isn't really infinite, as GMP stops at around 2^50 bits iirc
15:09:12 <monochrom> Whatever floats your boat.
15:09:17 <ray> it is enumerable though, just make sure you do the real enumeration
15:09:18 <ksf> it's not only enumeratable, it's a closed set.
15:09:22 <copumpkin> yeah, my previous iteration of this unsafeCoerced
15:09:24 <edwardk> it just needs to be slightly more fine grained than the
15:09:26 <copumpkin> but I didn't like that
15:09:27 <ray> not some FAKE one like enum
15:09:39 <edwardk> > [1.0..] :: [Float]
15:09:40 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
15:09:41 <copumpkin> I should instance Enumerable CReal ;)
15:09:44 <edwardk> Enum instance
15:09:48 <ksf> nah not that one.
15:09:49 <copumpkin> edwardk: yeah, that bothers me a lot
15:10:04 <edwardk> copumpkin: there you run into the same problems as Integer
15:10:09 <Berengal> I like scripting languages
15:10:12 <copumpkin> edwardk: yeah :P
15:10:22 <copumpkin> edwardk: well, also I don't really have a good "order" to enumerate them in
15:10:32 <ksf> map unsafeCoerce ([1..maxBound ::Word 32] :: [Word32]) :: [Float]
15:10:41 <copumpkin> since they're not really countable if I think of them as reals
15:10:58 <copumpkin> ksf: yeah, but then you don't get them in order
15:11:07 <edwardk> sure you do, concentric circles around denormalized 0? how about starting from the one that shares its structure with the integer 0, the one that shares the structure with integer 1...
15:11:10 <Saizan_> ksf: why two annotations for Word32 there?
15:11:19 <edwardk> heh ksf beat me to it
15:11:29 <copumpkin> edwardk: oh, I was talking about a good order for CReal :P
15:11:30 <edwardk> ksf: though, you missed 0 ;)
15:11:33 <ksf> 'cos I'm not shure whether that maxBound propagates to the outside.
15:11:44 <copumpkin> ksf: it has to
15:11:53 <ksf> ...actually, because I wrote the [Word32] first.
15:12:09 <Saizan_> that's enough too
15:12:25 <ksf> don't forget: rationals are enumerable, too.
15:12:35 <copumpkin> ksf: yeah, I was just too lazy to write the instance
15:12:45 <copumpkin> I was going to do it in terms of my (,) instance, but then I get duplicates
15:12:58 <Saizan_> nub
15:13:00 <copumpkin> I had one in my previous iteration of this but I lost the code
15:14:45 <copumpkin> length (enumerate :: [Word8 -> Bool]) -- is a bad idea though :P
15:15:26 <copumpkin> maybe I should write a cardinality method, along with some cardinal number type
15:15:36 <copumpkin> so I can calculate it statically
15:16:23 <ksf> > 2^9
15:16:24 <lambdabot>   512
15:16:37 <copumpkin> > 2^256
15:16:38 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
15:16:46 <ksf> oh yes
15:16:53 <bjorkLinux> lambdabot, is a spambot.
15:17:20 <ksf> wait no
15:17:23 <Phyx-> spam is unsolicited
15:17:31 <ray> copumpkin: incidentally, i think you should do the unsafeCoerce thing for floats
15:17:32 <bjorkLinux> heheh.
15:17:32 <ksf> it's 256*2
15:17:34 <ikanobori> RayNbow: Hi.
15:17:34 <Phyx-> lambdabot never says something unsolicited
15:17:43 <copumpkin> ray: if you insist
15:17:49 <bjorkLinux> thanks for the distinction.
15:17:53 <bjorkLinux> lambdabot, is a flood bot.
15:17:55 <copumpkin> I'll add a finite class too
15:17:55 <ray> it's the only enumeration that makes sense
15:18:01 <copumpkin> and make Eq only work on finite instancs
15:18:08 <copumpkin> to make edwardk happy
15:18:21 <copumpkin> *Enumerable> length (enumerate :: [Ordering -> Bool])
15:18:21 <copumpkin> 8
15:18:28 <copumpkin> ksf: ?
15:18:31 <Phyx-> o.O
15:18:36 <Phyx-> 8 what?
15:18:44 <ray> 8 functions! ah ha ha ha ha
15:18:44 <ksf> functions.
15:18:47 <copumpkin> 8 total functions from Ordering to Bool
15:18:49 <ksf> @src Ordering
15:18:49 <lambdabot> data Ordering = LT | EQ | GT
15:19:06 <Phyx-> heh
15:19:18 <edwardk> copumpkin: you should include partial ones too =)
15:19:31 <edwardk> anything that obeys monotonicity ;)
15:19:34 <copumpkin> edwardk: how would I generate those?
15:19:53 <Phyx-> isn't that 7 functions? 3! + 1?
15:20:07 <copumpkin> Phyx-: how many functions from Bool -> Bool ?
15:20:09 <edwardk> sprinkle undefines throughout, and optionally demand or seq your input ;)
15:20:16 <copumpkin> there's id, not, const False, and const True
15:20:25 <copumpkin> edwardk: thanks for the help :P
15:20:37 <ksf> 2*2, not 2^2.
15:20:52 <copumpkin> ksf: powerset?
15:20:57 <Phyx-> copumpkin: oh, ok, like that
15:21:17 <edwardk> so either inspect your input or not, if you don't then return either bottom or a constant value. and always consider bottom a valid member of the  output as well
15:21:25 <ksf> no matter what you say to convince me that it's more than multiplicative, my brain won't accept it today.
15:21:27 <edwardk> that should cover all monotonic functions
15:21:34 <Berengal> Does anyone know why my haddock produces inferior results to the one on hackage?
15:22:06 <copumpkin> it somehow feels a little dirty to enumerate over partial functions too though
15:22:09 <Berengal> And by inferior I mean the Takusen docs are severely lacking in both documented modules and included documentation
15:22:20 <edwardk> oh, and you need to optionally seq the input as well, because that is also distinguishable in Haskell ;)
15:22:20 <copumpkin> like, saying that there are 8 functions from Ordering to Bool feels good
15:23:58 <edwardk> copumpkin: http://blog.sigfpe.com/2008/02/how-many-functions-are-there-from-to.html
15:24:34 <copumpkin> ah yeah
15:24:35 <edwardk> obviously length (enumerate :: [() -> ()]) == 4
15:24:42 <copumpkin> do you really think I should do that?
15:25:05 <edwardk> heh, not completely, i do think that that is what newtype wrappers are for =)
15:25:25 <edwardk> [Partial () -> ()] [() -> Partial ()] [Partial () -> Partial ()] -- etc
15:25:29 <copumpkin> I see
15:26:08 <hackagebot> archlinux 0.2 - Support for working with Arch Linux packages (DonaldStewart)
15:26:21 <ray> i was worried for a bit there
15:27:06 <Saizan_> ksf: total functions A -> Bool are in bijection with the subsets of A
15:32:14 <ksf> powersets are very fine indeed, still the problem is that either the flag is moving or the wind is moving.
15:32:30 <copumpkin> :o
15:32:39 <monochrom> powerset and wind and flag?
15:32:46 <ksf> ...and remembering that it's actually mind that's moving doesn't gain you a thing, as it just moved.
15:33:40 <monochrom> You know you have done FP too much when you think nothing changes except your mind.
15:34:03 <monochrom> Perhaps s/FP/referential transparency/
15:34:33 <monochrom> "Nothing moves! Only the STG is playing mind tricks."
15:34:35 <ksf> http://en.wikipedia.org/wiki/The_Gateless_Gate number 29
15:34:42 <ksf> though I understand it a bit differently.
15:34:50 <edwardk> copumpkin: the Partial newtype would allow you to include bottoms in your enumeration as well ;)
15:35:02 <copumpkin> ooh :P
15:35:22 <edwardk> though you'd be careful because you want Partial (Partial a) to only have one bottom
15:35:32 <ksf> ...as a duality between the only still point in the universe (the universe as a whole itself) and the only still point in mind/perception (mind/perception itself)
15:35:51 <copumpkin> I updated it
15:35:52 <copumpkin> http://gist.github.com/167980
15:35:53 <ksf> that is, as long as you can't see both wind and flag at the same time, you're not grokking the truth.
15:35:57 <copumpkin> no Partial newtype yet
15:36:15 <copumpkin> but it should mitigate edwardk's disgust with the Eq instance for functions
15:36:37 <ksf> likewise, as long as you -- the flag -- is not one with your surroundings -- the wind -- illusion gets created.
15:36:44 <edwardk> so perhaps extending the typeclass with class Enumerable a where enumerate :: [a]; enumeratePartial :: [[a]]; enumeratePartial = enumerate ++ [undefined] -- then you can make the instance for Partial set its enumeratePartial = enumerate and voila no extra bottoms
15:37:00 <copumpkin> *Enumerable> cardinality (undefined :: Word8 -> Word8)
15:37:00 <copumpkin> 323170060713110073007148766886699519604441026697154840321303454275246551388678908931972014115229134636887179609218980194941195591504909210950881523864482831206308773673009960917501977503896521067960576383840675682767922186426197561618380943384761704705816458520363050428875758915410658086075523991239303855219143333896683424206849747865645694948561760353263220580778056593310261927084603141502585928641771167259436037184618573575983511523016
15:37:05 <copumpkin> ack
15:37:12 <monochrom> Cool number.
15:37:28 <ksf> add some thoughts about fixpoints and limitations of feedback and stuff and you get some quite powerful mantras.
15:37:50 <edwardk> cardinality -- good name
15:37:55 <Zerax> Potentially rookie question, is there any reason why function application couldn't be right associative?
15:38:12 <copumpkin> data Cardinal = Finite Integer | Aleph Integer maybe?
15:38:15 <edwardk> does it start handing back alephs? =)
15:38:16 <edwardk> heh
15:38:25 <monochrom> Could be, but I prefer left.
15:38:25 <ksf> Zerax, $ is.
15:38:38 <ksf> and that is...
15:38:41 <ksf> @src ($)
15:38:41 <lambdabot> f $ x = f x
15:38:46 <ksf> provably function application.
15:38:48 <mauke> Zerax: well, it would suck for calling curried functions
15:38:49 <edwardk> copumpkin: well, if you're using it on Enumerables, you're kind of stuck down Aleph 0
15:38:53 <monochrom> All language design is peference, not can/cannot.
15:38:58 <edwardk> copumpkin: er down to
15:39:01 <copumpkin> edwardk: even for the function types?
15:39:10 <copumpkin> I could claim at least that it's higher
15:39:21 <copumpkin> even if it's a lie
15:39:24 <copumpkin> since I can't do them all :P
15:39:30 <Zerax> It's just I'm writing a parser for untyped lambda calculus, and left associativity makes my brain hurt more.
15:39:37 <monochrom> "map f xs" benefits from left-associative.
15:39:52 <edwardk> gah, gotta run
15:40:03 <HugoDaniel> bed time
15:40:03 <HugoDaniel> hasta
15:40:10 <pikhq> monochrom: *All* language design?
15:40:26 <monochrom> If you just write a parser, you should let the parser get hurt, not your brain.
15:40:28 <ksf> pikhq, yes. as proof, see malbolge.
15:40:30 <Saizan_> Zerax: are you using an LL parser?
15:40:37 <pikhq> What if I represent "True" as any function that halts, and "False" as any function that doesn't halt?
15:40:48 <Zerax> LL?
15:40:49 <copumpkin> length . show $ (2 ^ 64) ^ (2 ^ 16)
15:40:51 <pikhq> Surely I can't do that?
15:40:52 <copumpkin> > length . show $ (2 ^ 64) ^ (2 ^ 16)
15:40:55 <lambdabot>   1262612
15:40:57 <pikhq> ksf: Touch.
15:41:08 <Saizan_> Zerax: recursive descent parser, the ones that get into an infinite loop with left-recursion
15:41:44 <Saizan_> Zerax: there's a standard way to tranform your grammar to avoid left-recursion, or e.g. in parsec there's chainl
15:41:59 <Zerax> Ah okay
15:42:30 <monochrom> I guess it hurted you because you didn't know this trick.
15:43:08 <Zerax> Most possibly, I am a bear of little brain.
15:43:53 <conal> Zerax: the curry/uncurry isomorphism is a (the?) strong reason for choosing left-associativity of application.
15:44:16 <monochrom> I always think the point of using computers is so that we let them boggle at what would boggle us.
15:44:18 <Zerax> Yes, that makes sense.
15:45:30 <Zerax> One does need to express the problem succinctly enough, after doing so it usually doesn't boggle us as much.
15:47:28 <ksf> computers help us to solve problem we wouldn't have without them.
15:47:35 <Zerax> Indeed
15:48:10 <monochrom> humans solve problems humans wouldn't have without humans.
15:48:15 <ksf> like, for example, explaining and examplifying recursion
15:48:25 <Philonous> Is there a particular reason why Num requires Show and Eq? This seems to be rather silly.
15:48:55 <copumpkin> Philonous: it is silly
15:49:07 <monochrom> Show is probably silly. Eq is because pattern matching "f 0 = xxx"
15:49:36 <mauke> not a good reason
15:49:47 <mauke> you could just f :: (Num a, Eq a) => a -> ...
15:49:50 <sjanssen> but it is *a* reason
15:50:17 <ksf> oh yes, we need voluntary class restraints.
15:50:50 <ksf> like, if you don't implement MonadFail, you get compiler warnings on incomplete matches.
15:50:50 <edwardk> Philonous: 'convenience' basically.. a lot of folks have complained about it ever since, but for newbiews being able to say 'Num a => a' rather than "Num a, Eq a, Show a => a" goes a long way
15:50:59 <ksf> ...in addition to that Num Eq thing.
15:51:14 <ksf> s/restranits/constraints
15:51:45 <edwardk> i don't like the reasoning but that seems to be where things went
15:51:57 <ksf> what about Num Eq Show <*> a?
15:52:09 <copumpkin> :o
15:52:58 <ksf> instance Functor TypeClass where ...
15:53:13 <ksf> I think there's a lot of fun to be had there for our type theorists.
15:53:43 <copumpkin> could do something like that in agda, but you don't really have typeclasses
15:54:08 <monochrom> pikhq: What you try to exemplify is also a preference choice between "more powerful but may take forever" and "less powerful but may be faster".
15:54:19 <ksf> yep, I noticed that while implementing Rationals.
15:54:42 <copumpkin> but they can approximate typeclasses with a bit of work
15:54:50 <copumpkin> and a lot of the standard library is structured that way
15:54:56 <pikhq> monochrom: *cough* Halting problem says that that couldn't be implemented.
15:54:56 <ksf> not Nat, though.
15:55:31 <ksf> who is halting and why do we keep his problems around?
15:55:41 <monochrom> No. Halting problem says you can implement if you accept nontermination.
15:55:44 <copumpkin> John Halting
15:56:15 <hackagebot> TrieMap 0.0.1.0 - An implementation of generalized tries with sophisticated map type inference. (LouisWasserman)
15:56:37 <monochrom> In fact I use one of those theorem provers that says "this may diverge" once in a while. Implemented and in use here-and-now.
15:57:03 <Philonous> I don't like Num at all. It forces entirely unrelated operations into one type class and adds silly constraints for good measure. I know there is the Numerical Prelude, but the idea of needing extra packages just to fix the standard lib seems wrong.
15:57:25 <copumpkin> Philonous: a lot of us feel the same way :P
15:57:42 <pikhq> monochrom: But you then get half-Boolean logic.
15:58:03 <randomwords> The Integral/Real problems are particularly annoying
15:58:16 <monochrom> I don't have a problem with that.
15:58:16 <pikhq> And dammit, you could implement that.
15:58:26 <pikhq> It just wouldn't be much use.
15:58:34 <monochrom> See how much it is preference. You have a problem but I don't.
15:58:49 <pikhq> Your point has been taken.
15:59:17 <Berengal> Is malbolge turing complete though?
15:59:28 <pikhq> Berengal: No; finite memory.
15:59:30 <monochrom> PVS's "grind" command is in use in real projects. Diverges. Try telling those people "wouldn't be much use" and getting dismissed.
15:59:33 <ksf> it's assumed to be.
15:59:40 <Berengal> pikhq, ignoring that
15:59:55 <pikhq> Then you have to redesign the language dramatically.
15:59:59 <copumpkin> can it simulate a linear-bounded automaton
16:00:04 <copumpkin> how about that? :P
16:00:16 <pikhq> copumpkin: That is an open question.
16:00:17 <Berengal> There are infinite-memory malbolges out there
16:01:29 * copumpkin is sad at how elementary the math courses on iTunes U are
16:01:34 <ksf> search http://www.lscheffer.com/malbolge.shtml for turing.
16:03:00 <ksf> trying to brute force an sk-evaluator into malbolge is a thing that'll occupy quite a large cluster for a significant time.
16:03:04 <randomwords> copumpkin: MIT OCW is probably a better destination
16:03:16 <ray> monochrom: people are too scared of divergence
16:03:23 <randomwords> or a text book
16:03:27 <copumpkin> randomwords: I thought they mirrored all their stuff on iTunes U
16:03:40 <copumpkin> randomwords: I'm at a university myself :P just wanted to browse and see what was available
16:03:54 <randomwords> copumpkin: I know, I do the same thing from time to time
16:03:55 <copumpkin> the only algebra course I could see was high-school algebra
16:04:08 <randomwords> copumpkin: After something more modern?
16:04:36 <copumpkin> a bit :)
16:05:42 <ray> i hate high-school algebra, it's the reason you can't just call abstract algebra "algebra"
16:06:16 <copumpkin> my school does anyway
16:06:23 <monochrom> Oh you can't just call math "math" either.
16:06:30 <randomwords> ray: I feel your pain
16:07:07 <monochrom> "I major in math." "Oh so you calculate numbers all day?"
16:07:13 <copumpkin> lol
16:07:14 <randomwords> Like when you try to explain your degere and people assume it's just really advanced arithmetic
16:07:40 <purplepenguins> high-school algebra was algebra first though
16:08:05 <monochrom> As another example, look at "math libraries" in all languages. They are sine, cosine, log. There is no set theory, no group theory, no limit, no graph... no math.
16:08:18 <copumpkin> yeah, it's sad
16:08:23 <randomwords> "math libraries"?
16:08:50 <fbru02> is the common notation in haskell for types when you see a 'w' it means monoid and when you see an m it means monad?
16:09:04 <copumpkin> I've seen w mean comonad
16:09:13 <ray> w means comonad to me
16:09:23 <Vanadium> w means purple worm
16:09:24 <Saizan_> w means monoid when you use it with the Writer monad
16:09:25 <purplepenguins> well, most programmers don't have familiarity with those things
16:09:32 <purplepenguins> Vanadium: right answer!
16:09:34 <copumpkin> oh, yeah, that makes sense
16:09:38 <ray> if i see a m with kind * it means monoid and if i see a m with kind * -> * it means monad
16:09:55 <copumpkin> @src Writer
16:09:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:09:57 <randomwords> That's abusive
16:10:06 * copumpkin abuses more
16:10:11 <pikhq> It's such a shame that so many people think that "math" means "evaluation of arithmetic and trigonometric functions"...
16:10:34 <ray> math majors must, like, solve 30TH DEGREE POLYNOMIALS
16:10:37 <pikhq> Oh, and a hint of symbolic manipulation.
16:10:39 <copumpkin> @index unsafeCoerce
16:10:39 <lambdabot> bzzt
16:10:44 <copumpkin> @hoogle unsafeCoerce
16:10:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:10:45 <monochrom> "Data.Set" "Data.Graph" instead of "Math.Set" "Math.Graph" tells you what programmers think: "they're very useful data structures BUT IT IS NOT MATH!"
16:10:46 <Asztal> MonadLib uses 'i' for monoid, I think :(
16:10:50 <ray> and then you have to explain how computers do that stuff for you
16:11:04 <p_l> monochrom: what would you say about theorem prover as a library? :P
16:11:05 <randomwords> graph theory = advanced applications of spreadsheets
16:11:13 <Vanadium> They are not maths, they are computer science :|
16:11:14 <fbru02> pikhq math is as far as i know topology and on top of that you build the other stuff
16:11:29 <pikhq> ray: Well, it's not like there's such a thing as a computer algebra system.
16:11:53 <purplepenguins> I was kinda bummed out when i heard about the insolvability of the quintics
16:12:04 <randomwords> purplepenguins: Really?
16:12:18 <randomwords> The proof is nice..
16:12:26 <pikhq> fbru02: That's at least more reasonable than "Well, we've got + and -, and * and /, and sin() and cos(), and here's algebra, and oh, surprise! Here's calculus (and we won't tell you that you've got higher-order functions!)!"
16:12:32 <purplepenguins> well, yes, i found the proof nice
16:12:45 <purplepenguins> but i was kinda hoping that math would let me solve outrageously high-degree polynomials
16:13:00 <randomwords> Well you can, just not in terms of radicals
16:13:01 <pikhq> Oh, yeah. And chuck in a bit of two-dimensional Euclidean geometry for the heck of it.
16:13:03 <copumpkin> there,
16:13:04 <copumpkin> *Enumerable> cardinality (undefined :: Bool -> Float)
16:13:04 <copumpkin> 18446744073709551616
16:13:04 <fbru02> pikhq what is the foundation of all math?
16:13:17 <medfly> well, at least they think maths is useful, right?
16:13:22 <pikhq> fbru02: Formal reasoning.
16:13:32 <medfly> imagine if they knew what it meant.
16:13:35 * medfly protects self.
16:13:50 <monochrom> theorem prover as a library is cool!
16:14:07 <ray> lol copumpkin
16:14:10 <fbru02> well u see i would say that that belongs to logic / philosophy
16:14:46 <pikhq> And so would I. The two fields have some overlap.
16:14:53 <ksf> fbru02, ten pounds of flax.
16:15:06 <pikhq> (particularly with logic)
16:15:26 <syntaxglitch> math stimulates dopamine production, makes you alert, and lets you think faster
16:15:29 <syntaxglitch> wait, no, that's METH
16:15:30 <syntaxglitch> sorry
16:15:37 <medfly> hahaha
16:15:53 <ray> meth lets you do better math
16:16:00 <syntaxglitch> ray, it worked for erdos
16:16:08 <fbru02> pikhq i really loved the (i dont remember) lament
16:16:11 <medfly> I don't think he used meth
16:16:16 <syntaxglitch> fbru02, Lockhart
16:16:17 <ray> amphetamine
16:16:20 <ray> similar
16:16:25 <ray> probably better
16:16:32 <monochrom> Prufrock is a theorem prover as a library in Haskell. Uses typeclass so inference rules and procedures can be polymorphic over several logics.
16:16:41 <syntaxglitch> if memory serves me erdos used a combination of amphetamine and methylphenidate
16:17:05 <syntaxglitch> a.k.a. adderall and ritalin
16:17:38 <fbru02> syntaxglitch you nailed it but i cant use that stuff if not i would try it
16:18:25 <pikhq> syntaxglitch: Erds, you mean.
16:18:45 <syntaxglitch> both drugs have a lot of abuse potential and will get you in jail real fast if you have them without a prescription, yes
16:19:05 <syntaxglitch> pikhq, yeah, too lazy to put the things over the o properly :(
16:19:46 <fbru02> syntaxglitch i have a condition that using them will get me in the ER or worse
16:19:56 <syntaxglitch> fbru02, ahh, that's even more drastic
16:19:57 <fbru02> thats worse than jail
16:20:02 <gwern> ritalian will put you in jail?
16:20:05 <medfly> fbru02, prisoners would disagree
16:20:06 * gwern is skeptical
16:20:10 <ksf> ghc 6.2?
16:20:20 <syntaxglitch> gwern, just as much as amphetamine will
16:20:24 <fbru02> hehe guys ill back back after eating
16:20:50 <syntaxglitch> ritalin is also a dopaminergic stimulant with similar effects to amphetamine, which I think it's actually derived from
16:20:58 <medfly> yup.
16:21:09 <medfly> but even ritalin has an abuse potential.
16:21:14 <syntaxglitch> both are strictly controlled substances in most places
16:21:20 <copumpkin> I updated the gist to add enumerable ratios and floats/doubles
16:21:39 <copumpkin> I couldn't be bothered to figure out the cardinality of finite rationals though
16:21:56 <copumpkin> *Enumerable> length (enumerate :: [Ratio Word8])
16:21:57 <copumpkin> 39640
16:21:57 <copumpkin> apparently
16:25:41 <randomwords> How "complete" does an application before it's OK to upload to hackage?
16:25:53 <ray> there are no standards
16:26:05 <copumpkin> being in haskell, it's automatically awesome
16:26:07 <ray> i would say it should work
16:26:10 <randomwords> lawless wasteland. Got it
16:26:16 <syntaxglitch> well, it's probably good if it actually compiles
16:26:34 <ray> see, some people say it should compile, others say it should compile and do something
16:26:48 <Berengal> I lean towards bug-free > features
16:26:54 <shachaf> *Do* something? Whatever happened to purity?
16:27:30 <randomwords> Well - don't hate me if it's terrible
16:27:30 <medfly> :)
16:27:43 <copumpkin> randomwords: what is it?
16:27:56 <ray> it's probably better than my unsafedestroyuniverse module
16:28:04 <gwern> heh. lawless wasteland
16:28:06 <ray> which i chickened out of uploading to hackage
16:28:10 <Berengal> randomwords, if it sucks we could all just not use it, which can't be worse than the current situation
16:28:20 <tommd> ray: is there a "safeDestroyUniverse" or is the word 'unsafe' just redundant?
16:28:24 * copumpkin ponders whether he should steal the "enumerable" package name
16:28:26 <Berengal> ray, you should, seeing there's an Acme category now
16:28:46 <gwern> @remember randomwords How "complete" does an application before it's OK to upload to hackage? <ray> there are no standards <randomwords> lawless wasteland. Got it.
16:28:46 <lambdabot> I will never forget.
16:29:01 <tommd> Don't forget to flush.
16:29:07 <gwern> @flush
16:29:08 <ray> berengal: it's not that, it's just that i cant' decide whether destroying the universe is really unsafe
16:29:13 * gwern nevar forgets to flush!
16:29:31 <tommd> Almost quote worthy right there.
16:29:31 <shachaf> ray: It doesn't seem unsafe to me.
16:29:31 <ray> in a sense, it doesn't really have side effects
16:29:38 <Berengal> ray, provide an alternative implementation: safeDestroyUniverse = unsafeDestroyUniverse
16:29:39 <shachaf> I mean, there are no noticeable side effects.
16:29:43 <gwern> but, then, why do I have to? shouldn't the garbage collector catch it?
16:30:06 <shachaf> Hmm. What type would it have?
16:30:12 <shachaf> Probably :: a, given that it doesn't return.
16:30:16 <ray> yeah
16:30:35 <ray> any attempt to evaluate it forces the destruction of the current universe
16:30:35 <randomwords> shachaf: Does it have a type, given noone will ever observe it?
16:30:39 <ray> it's a bit like error
16:30:48 <shachaf> randomwords: Well, the program still needs to type-check.
16:30:56 <ray> in fact, it is implemented with error
16:31:03 <ray> since destroying the universe is currently not possible in haskell
16:31:26 <ray> it's unsafeDestroyUniverse = error "Please consider the current universe destroyed."
16:31:30 <shachaf> I'm sure lambdabot would disagree.
16:31:33 <shachaf> @faq Can Haskell destroy the universe?
16:31:34 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:47 <tommd> @faq Can Haskell protect the universe?
16:31:48 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:51 <ray> well, maybe haskell can, but the hardware is lacking
16:31:51 <pikhq> Actually destroying the universe would result in an IO value which does not have a RealWorld in it;.
16:31:53 <tommd> Humm, we have a problem.
16:31:53 <copumpkin> ray: you should definitely put that on hackage
16:32:01 <pikhq> That is to say, it would be a type failure.
16:32:01 <tommd> I don't think Lambdabot-Logic is sound.
16:32:02 <pikhq> ;)
16:32:08 <ray> copumpkin: i haven't decided whether it's safe yet!
16:32:12 <copumpkin> it'd be amusing to construct an IO with undefined instead of RealWorld
16:32:32 <pikhq> @src IO
16:32:33 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:32:36 <ray> in one sense it has side effects, in another it doesn't
16:32:39 <shachaf> Hmm. If you can destroy the universe, you can sort in O(n) time, right?
16:32:49 <copumpkin> shachaf: even faster!
16:32:50 <pikhq> Hmm. unsafeCoerce could maybe do it.
16:32:54 <ray> O(1) time
16:33:01 <pikhq> shachaf: Assuming many-worlds, O(1).
16:33:01 <copumpkin> O(0) time!!
16:33:07 <pikhq> O(oo) worlds, though.
16:33:09 <Vanadium> O(1)?
16:33:09 <randomwords> Does lambdabot die if we make it say a paradox?
16:33:11 <medfly> :)
16:33:17 <pikhq> copumpkin: That's still O(1)
16:33:23 <copumpkin> pikhq: nope!
16:33:25 <Berengal> ray, maybeUnsafeDestroyUniverse?
16:33:29 <copumpkin> it's faster than O(1)!!!11!!!
16:33:30 <medfly> @faq Can Haskell fail miserably?
16:33:30 <lambdabot> The answer is: Yes! Haskell can do that.
16:33:48 <burp> lol
16:33:49 <ray> berengal: i think i'll just call it destroyUniverse and mention in the docs that it may or may not be considered to have side effects :)
16:33:51 <pikhq> What you do is shuffle the list you want to sort. If it's not sorted, destroy the universe.
16:33:51 <copumpkin> taking no time is better than taking some constant amount of time
16:34:11 <Berengal> ray, "may contain traces of side effects"
16:34:12 <pikhq> (it is highly recommended to make sure it's a truly random shuffle)
16:34:24 <pikhq> copumpkin: 0 is a constant.
16:34:40 <syntaxglitch> pikhq, what you want there is specifically quantum randomness
16:35:00 <copumpkin> pikhq: O(1) = k * 1 * whatevervariableyoucareabout
16:35:03 <syntaxglitch> assuming you're thinking of the quantum suicide bogosort algorithm
16:35:03 <pikhq> syntaxglitch: Quite.
16:35:14 <copumpkin> pikhq: 0 has quite different behavior as a multiplicative constant
16:35:36 <randomwords> I like this: http://www.dangermouse.net/esoteric/intelligentdesignsort.html
16:35:40 <copumpkin> thus, I stand by my statement that O(0) time is better than O(1), since it takes no time at all
16:35:54 <ray> O(0) is if the list is already sorted and if you already know it's sorted
16:36:14 <copumpkin> that still takes time
16:36:21 <Berengal> randomwords, :O! I invented that! (but a year after that page was last updated... :/)
16:37:49 <gwern> > fromIntegral (1.0) :: Int
16:37:50 <lambdabot>   Add a type signature
16:37:57 <gwern> > fromIntegral (1.0 :: Double) :: Int
16:37:59 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
16:37:59 <lambdabot>    arising from a use ...
16:38:08 <gwern> hm.
16:38:30 <Saizan_> sigh, i want an IDE that shows me types above toplevel definitions without putting them into the files.
16:39:02 <gwern> :t fromIntegral
16:39:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:39:19 <gwern> :i Num
16:43:46 <randomwords> Saizan_: If I understand you correctly, then I think vim-haskellmode does what you want.
16:45:41 <kniu> I ran into a brick wall.
16:45:49 <kniu> Figuratively.
16:46:07 <ray> i have actually run into literal brick walls before
16:46:11 <ray> i recommend it
16:46:29 <kniu> If the types of abstractions are themselves abstractions, you can't really do "accurate" typechecking anymore.
16:47:03 <kniu> There's no fool-proof way to compare functions that I know of.
16:47:48 <gwern> I once saw my dog run into a brick wall
16:47:57 <gwern> it was hilarious. he made this really startled quick yelp
16:48:49 * copumpkin wonders who the downvoters are on the haskell subreddit
16:48:58 <copumpkin> everything seems to get at least a couple of downvotes
16:49:14 <randomwords> copumpkin: Probably bots that downvote everything in an attempt to game the system
16:49:30 <skorpan> you just lost it
16:51:26 <kniu> some people don't like haskell.
16:51:36 <kniu> It's that simple.
16:52:36 <copumpkin> kniu: then why subscribe to the haskell subreddit and go out of their way to downvote every story on it?
16:53:09 <kniu> Malice.
16:53:15 <gwern> they need something to smear the bubbling bile of their bubeous chaudrons onto
16:53:21 <copumpkin> sad
16:53:40 <randomwords> kniu: Never ascribe to malice that which is adequately explained by bots
16:54:20 <gwern> @wn chaudron
16:54:23 <lambdabot> No match for "chaudron".
16:54:31 <gwern> oh come on wordnet. it's not *that* obscure
16:54:42 <kniu> did you mean cauldron?
16:54:55 <copumpkin> chaudron sounds french
16:54:59 <kniu> I, too, have never seen that word.
16:55:11 <copumpkin> http://en.wiktionary.org/wiki/chaudron
16:55:13 <copumpkin> :P
16:56:34 <kniu> (obsolete)
16:56:48 <dons> copumpkin: i can ban users on the subreddit, if you find out their names
16:56:52 <dons> and am happy to
16:57:27 <copumpkin> dons: unfortunately I can't find out :/ seems like something reddit should allow moderators though, to see users who only ever downvote stories
16:57:44 <dons> yep
17:00:03 <randomwords> It would be nice to have a bit more discussion on the haskell subreddit
17:07:56 <Philonous> automatic differentiation is really cool. Two years ago I wouldn't have dreamed of writing "derive (\x -> exp (x^^2 -3x) +5)" and actually get the derivative without symbolic computations.
17:10:59 <jfoutz> yes it is.
17:12:34 <jfoutz> when i was first starting out i wrote this, http://metavar.blogspot.com/2008/02/higher-order-multivariate-automatic.html
17:12:59 <jfoutz> it's pretty horrible code, but it was very satisfying.
17:13:34 <jfoutz> i actually ended up using it to compute normals of ... stuff.
17:18:43 <Philonous> I'd like use it to compute the Hessian of the log-likelihood function for logistic regression
17:36:20 <codebliss> Hello guys.  Code and error message at (http://haskell.pastebin.com/m6c075c2b), I tried defining my own type sig of course, but honestly it didn't help  =P.
17:36:58 <copumpkin> you need another Inc
17:37:11 <codebliss> Pattern match Inc (Inc a) ?
17:37:25 <shachaf> codebliss: Try to define your own signature again.
17:37:32 <copumpkin> evaluate (Inc a) = Inc . (+1) . evaluate $ a
17:37:59 <copumpkin> actually
17:38:02 <copumpkin> not that either
17:38:26 <Lemmih> codebliss: You can't do that. Haskell is statically typed.
17:38:28 <codebliss> evaluate :: (Num a) => Inc a -> a
17:38:31 <codebliss> Oh.
17:38:53 <codebliss> Oh, I see.  No way to do any number of nested Inc's -> single lifted a?
17:38:54 <Lemmih> codebliss: evaluate (Inc a) = a+1 ?
17:39:17 <codebliss> I was just working on some theory code.  evaluate (Inc (Inc 5)) = 7
17:39:24 <copumpkin> then you have some issues with evaluate a = a
17:39:25 <Lemmih> codebliss: Sure: data Inc a = Int (Int a) | Val a
17:39:26 <copumpkin> you don't want that
17:39:27 <codebliss> Doing some category schnaz
17:39:31 <codebliss> Ah
17:39:47 <codebliss> And then escape those?
17:39:55 <codebliss> That makes perfect sense, was wondering how they did that
17:39:58 <Lemmih> codebliss: evaluate (Int v) = 1+evaluate v; evaluate (Val v) = v
17:40:42 <Philonous> Lemmih s/Int/Inc
17:41:44 * Lemmih applies Philonous rigorously.
17:43:16 <codebliss> My brain gets it, but my hands don't.  data Inc a = Inc (Inc a) | Val a
17:43:28 <codebliss> I want it to be able to be like a tree
17:44:07 <jfoutz> data Tree = Branch a a | Leaf ?
17:44:11 <jfoutz> grr.
17:44:18 <jfoutz> data Tree a = Branch a a | Leaf ?
17:44:18 <Saizan_> elements of that type will be of the form Inc^n (Val x)
17:44:24 <Saizan_> where n can be 0
17:44:28 <copumpkin> jfoutz: only structure?
17:44:42 <Saizan_> i.e. Val x, Inc (Val x), Inc (Inc (Val x)), ..
17:44:47 <copumpkin> jfoutz: not sure you'd get very far with that kind of Tree
17:44:50 <jfoutz> copumpkin: wow. i suck.
17:44:53 <jfoutz> hahaha.
17:44:55 <copumpkin> well
17:45:04 <copumpkin> you could get a fixpoint of it
17:45:10 <codebliss> Touche.
17:45:41 <jfoutz> i really need to type this stuff in ghc and compile it before ... here.
17:46:09 <codebliss> It works, I forgot to put Val before the constant
17:48:41 <syntaxglitch> sometimes I really suspect I'm not smart enough to be using Haskell :(
17:49:19 <jfoutz> i only feel that way when i'm actually using it. afterwords i feel great.
17:49:57 * copumpkin tries to figure out how to add edwardk's Partial suggestion for functions
17:50:17 <syntaxglitch> I just spent like two hours trying to understand how "powerset = filterM (const [True, False])" works :\
17:50:45 <copumpkin> syntaxglitch: for each element, both pick it and don't! :P
17:50:53 <syntaxglitch> yeah, I know that now :P
17:51:27 <jfoutz> > mapM (const [True, False]) [1..3]
17:51:29 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
17:52:09 <copumpkin> edwardk: would it be cheating to do data Partial a = Partial a | Undefined instead of newtype Partial a = Partial a? :P
17:52:13 <syntaxglitch> It's not that I can't understand how stuff works, it just... takes me a while to puzzle it out, and I don't think I'd ever be able to come up with stuff like that :(
17:53:36 <jfoutz> syntaxglitch: you'd be surprised. It's not crazy hard, it's just alien. takes a while to wrap your head around it.
17:53:58 <copumpkin> anyone know of an easy way of counting the number of fractions with numerator/denominator smaller than a constant?
17:54:04 <syntaxglitch> It actually makes crazy amounts of sense in the end, it's just hard to get to that point.
17:54:49 <BMeph> copumpkin: Besides length , and a list comp? :)
17:54:50 <syntaxglitch> Is there any good way to pound this stuff into my head faster? My math background is a bit weak, which probably doesn't help...
17:54:58 <copumpkin> BMeph: yup :)
17:55:10 <kulakowski> copumpkin: Farey sequences?
17:55:21 <copumpkin> BMeph: according to that, there are 39640 distinct Ratio Word8s
17:55:55 <jfoutz> syntaxglitch: i think it's just puzzling it out. It took me a long time to get pointers, but htat was a long time a go... so it dosn't seem as hard as it was :)
17:56:17 <Philonous> jfoutz: The idea with the IntMaps is nifty. But couldn't you represent constants with emtpy maps rather than another constructor? That would save you a lot of code
17:56:21 <copumpkin> kulakowski: interesting, but I need fractions > 1 too
17:56:31 <BMeph> copumpkin: ...and? You think it's wrong, or just want independent confirmation? :)
17:56:50 <copumpkin> BMeph: I'd appreciate a method that doesn't involve waiting 20 seconds for it to compute
17:57:36 <jfoutz> Philonous: I don't think i couldn ever figure out how to deal with the case where i'd diff with respect to one variable, and then the next. that implementation gives you the full tree (i think)
17:58:27 <syntaxglitch> jfoutz, any idea where I could find some sort of exercises or problems to puzzle over, help stretch my understanding?
17:59:27 <syntaxglitch> I've seen stuff for mundane functional programming topics done in haskell, but not much for using monads and other uniquely haskellish stuff.
17:59:29 <jfoutz> syntaxglitch: yeah, these are neat. and haskell has lots of tricks to make really satisfying solutions. http://projecteuler.net/
17:59:43 <jfoutz> oh, i see. hrm.
18:00:06 <kulakowski> copumpkin: How large of constants?
18:00:21 <copumpkin> kulakowski: well, I'm trying to count the number of Ratio Word16, for example
18:00:27 <jfoutz> syntaxglitch: this one is pretty cool. http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
18:00:44 <copumpkin> kulakowski: so all fractions such that numerator and denominator < 6556
18:00:48 <kulakowski> yeah
18:00:48 <copumpkin> 65536 I mean
18:00:58 <jfoutz> but it's more about adding stuff on than monads themselves.
18:01:11 <syntaxglitch> jfoutz, http://projecteuler.net/index.php?section=profile&profile=syntaxglitch :)
18:01:33 <jfoutz> syntaxglitch: the wikibook is pretty good. maybe implement maybe? and list?
18:01:44 <jfoutz> syntaxglitch: nice. :)
18:02:34 <syntaxglitch> doing a couple project euler problems earlier this week is actually what got me trying to learn Haskell again, in fact
18:02:52 <syntaxglitch> even though the only really interesting project euler problem I've solved, I did with pencil & paper
18:03:05 <syntaxglitch> (problem 202)
18:03:59 <Berengal> syntaxglitch, 204 gives some nice insights into lazy programming
18:05:04 <kulakowski> copumpkin: if there are n fractions between 0 and 1, then there are 2n-1 total (all the ones bigger than 1 are reciprocals)
18:05:34 <syntaxglitch> Berengal, hm, maybe I'll try that one next
18:05:59 <copumpkin> syntaxglitch: hmm, seems promising
18:06:11 <hackagebot> bindings-common 0.2.2 - Low-level library bindings, base package. (MauricioAntunes)
18:06:56 <kulakowski> not sure if that and doing the farey series is fast enough for you or not
18:07:22 <copumpkin> kulakowski: sure beats computing the length of the list of all fractions :P
18:07:28 <copumpkin> kulakowski: I'll give it a go sometime, thanks :)
18:10:14 <kulakowski> copumpkin: I vaguely remember doing farey sequences (or the modification that you want, in fact), wish I could find the code :/
18:13:33 <syntaxglitch> on a related note, what's some good math to read up on that's relevant to haskell, other than the obvious category theory stuff?
18:14:28 <ray> types
18:14:56 <ray> take a look at system f
18:15:24 <syntaxglitch> ray, hm, okay. Thanks!
18:16:22 <copumpkin> a good dose of algebra (not the high school kind) should also be handy
18:16:38 <randomwords> copumpkin: Still talking about algebra?
18:16:42 <copumpkin> lol
18:16:54 * copumpkin is a fan
18:17:10 <purplepenguins> algebra is the purest math
18:17:27 <randomwords> purplepenguins: That's debatable
18:17:34 <randomwords> define purity
18:17:41 <purplepenguins> by my notions of purity anyway
18:17:44 <ray> no side-effects, duh
18:17:48 <purplepenguins> hah
18:17:59 <syntaxglitch> how about the pure untyped lambda calculus? That's pretty pure :P
18:18:05 <purplepenguins> yes, i suppose so
18:18:13 <purplepenguins> hmm
18:18:16 <purplepenguins> category theory
18:18:30 <syntaxglitch> I once spent an afternoon figuring out how to implement subtraction on Church numerals. That was fun.
18:18:53 <purplepenguins> i still don't quite understand category theory
18:19:03 <randomwords> It seems like you're conflating purity and generality
18:19:10 <purplepenguins> i've been truding through maclane at maybe ten pages a month
18:19:25 <syntaxglitch> category theory is "general abstract nonsense" apparently
18:19:26 <ray> purity's just a random term anyway
18:19:31 <syntaxglitch> which does sound fun
18:19:42 <ray> you can define it to mean generality and abstractness and nonsensity
18:19:50 <ray> and then category theory is the purest
18:20:15 <randomwords> or something equivilant
18:20:21 <purplepenguins> is there something more general than category theory?
18:21:08 <ray> you could come up with something if you wanted
18:21:14 <ray> the trick is coming up with something interesting
18:21:21 <purplepenguins> yes, of course
18:21:25 <syntaxglitch> purplepenguins, probably. If mathematicians have run out of ways to generalize things further than math is over
18:21:32 <syntaxglitch> s/than/then
18:22:05 <purplepenguins> eventually you're reach an event horizon of generality, and then one statement can generalize everything including itself
18:23:06 <kulakowski> I'm not entirely sure what generality even means in this context
18:23:11 <randomwords> Is there an easy way to convert between boxed and unboxed types?
18:23:33 <copumpkin> pattern match and apply the box?
18:23:58 <copumpkin> :k (->)
18:23:59 <lambdabot> ?? -> ? -> *
18:24:03 <ray> lure the type into the box with some tasty type treats
18:24:06 <copumpkin> you can't write a function that returns an unboxed type
18:24:33 <copumpkin> well, actually
18:24:43 <copumpkin> hmm, I guess you can
18:24:56 <randomwords> I don't need to return an unboxed type
18:25:07 <randomwords> but I need to unbox an argument to be passed to a function
18:25:11 <copumpkin> but anyway, f (I# i#) = moo i#
18:26:32 <randomwords> And to rebox?
18:26:40 <copumpkin> just apply I#
18:26:42 <copumpkin> or whatever the box is
18:26:44 <copumpkin> @src Int
18:26:44 <lambdabot> data Int = I# Int#
18:26:45 <randomwords> Yeah, thought so
18:26:51 <randomwords> I guess I need to import that
18:27:28 <randomwords> I do feel dirty playing with unboxed types
18:27:39 <copumpkin> what are you doing with them?
18:27:48 <randomwords> Trying to optimise a function
18:28:06 <randomwords> I'm interested to see what kind of speedup I can get (if any)
18:28:09 <copumpkin> hmm
18:28:31 <randomwords> @src Double
18:28:32 <lambdabot> data Double = D# Double#
18:29:47 <randomwords> @src D#
18:29:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:30:09 <Axman6> that is the source for D#
18:30:23 <randomwords> I'm trying to find where it's defined
18:30:29 <copumpkin> GHC.Types probably
18:31:19 <copumpkin> GHC.Prim will also allow you to actually do things with the unboxed values
18:32:17 <ray> there are no lambdacats about unboxed types
18:35:46 <copumpkin> ray: sounds like a job for drong
18:35:57 <randomwords> lambdacats?
18:36:02 <ray> @where lambdacats
18:36:03 <lambdabot> http://arcanux.org/lambdacats.html
18:36:37 <randomwords> squee
18:36:40 <ray> i want something like a cat crawling out of a box with the caption saying "Cat# is unboxed" or something
18:37:07 <copumpkin> *iz
18:37:14 <randomwords> the foldl sleep one is pure awesome
18:37:43 <copumpkin> I like http://arcanux.org/lambdacats/io-monad.jpg
18:37:55 <copumpkin> and http://arcanux.org/lambdacats/impossible.jpg :P
18:38:10 <copumpkin> ray: zomg, boxed cat! http://arcanux.org/lambdacats/boxed.jpg
18:38:42 <ray> boxed, but not unboxed!
18:38:48 <copumpkin> :P
18:40:51 <copumpkin> we need a category theory subreddit!
18:41:10 <copumpkin> http://www.reddit.com/r/algebra :(
18:41:43 <randomwords> Weird, unboxing gives a 2x slowdown. I guess the compiler is smarter than I am
18:41:52 <syntaxglitch> algebra is b& :(
18:42:02 <copumpkin> randomwords: that's odd, can I see?
18:42:10 <randomwords> Let me check I'm not being stupid first
18:42:15 <copumpkin> ok :)
18:43:58 <ray> what module should destroyUniverse be in? I have it in Acme.Control.DestroyUniverse, but is it really Control?
18:45:08 <jfoutz> probably System.
18:46:13 <codebliss> I'm just messing with implementing some category theory.  I'm a relative noobie, amount-of-code-created wise.  Any suggestions?  http://haskell.pastebin.com/d10d86c
18:46:22 <ray> well, it would be System if i had decided it was unsafe
18:46:36 <ray> but i'm leaning towards it being safe
18:46:50 <jfoutz> that makes sense. hmm.
18:47:45 <ray> it doesn't break referential transparency at all
18:47:59 <jfoutz> Foreign?
18:48:05 <jfoutz> It's definitly not Data.
18:48:22 <Axman6> urgh, when did quickcheck get so broken? trying tp upgrade my outdated packages, and i keep getting errors about QC versions (without telling me which package has the problem)
18:49:03 <ray> the closest stuff that isn't in Prelude seems to be in Control
18:49:57 <Axman6> which universe is being destroyed?
18:50:00 <jfoutz> lessee... Data no. Debug, no. Distribution, no. Foreign, no. Graphics... maybe. Language, no. Network no. System, Text, Test. no no no.
18:50:02 <ray> the current one
18:50:08 <jfoutz> go for it. control it is.
18:50:23 <copumpkin> given the universality of universe destruction
18:50:41 <copumpkin> I'd argue against putting it anywhere
18:50:44 <copumpkin> just put it at the top level
18:50:46 <kynky> studied at universities
18:50:50 <shachaf> You people are still talking about unsafeDestroyUniverse?
18:50:57 <ray> no, it's no longer unsafe
18:51:01 <jfoutz> it's not unsafe.
18:51:49 <Berengal> Which time library is the recommended one these days?
18:52:40 <jfoutz> Data.Time i would guess.
18:53:10 <randomwords> copumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3345#a3345
18:53:31 <copumpkin> mandelbrot?
18:53:58 <randomwords> It's my hello world of graphics programming
18:54:11 <randomwords> Also hackage is lacking a decent fractal app
18:54:15 <randomwords> thought I'd give it a shot
18:56:08 <copumpkin> I'd take a look at the core it spits out
18:56:13 <copumpkin> and see why it's slower
18:56:21 <randomwords> That's not fun
18:56:24 <copumpkin> :P
18:57:21 <randomwords> to be honest I think the boxed is reasonably close to optimal in terms of what GHC spits out
18:58:21 <copumpkin> why are you doing log (sqrt x) ?
18:59:16 <syntaxglitch> randomwords, good choice of hello world
18:59:23 <syntaxglitch> I've written some horrible, horrible mandelbrots
18:59:31 <fbru02> randomwords: what is the unboxed thing ?
18:59:32 <randomwords> copumpkin: It smoothes the colour
18:59:44 <randomwords> copumpkin: Stops banding
18:59:45 <copumpkin> randomwords: yeah, but why not 0.5 * log x?
18:59:57 <syntaxglitch> randomwords, my current record for absurdity is writing a mandelbrot renderer in GNU Make :)
19:00:03 <randomwords> copumpkin: Good point - still a drop in the ocean
19:00:13 <randomwords> syntaxglitch: That's insane
19:00:19 <syntaxglitch> randomwords, you have no idea
19:00:46 <syntaxglitch> make doesn't even have a proper native concept of numbers
19:00:56 <randomwords> haha
19:01:09 <syntaxglitch> and I had to recurse for each point by invoking another instance of make
19:01:34 <syntaxglitch> but the only things it invokes are more makes and echo to print the output
19:02:21 <syntaxglitch> fortunately make has very fast handling for long lists of tokens, so I used the number of tokens in a variable to represent numbers
19:02:32 <syntaxglitch> e.g. "x x x x" = 4
19:02:50 <syntaxglitch> plus fixed point math to simulate non-integral values
19:02:52 <syntaxglitch> it was horrible
19:04:04 <randomwords> copumpkin: It seems that even in the boxed version the compiler unboxes the function. I guess it's slight wittier in it's optimisations.
19:04:14 * syntaxglitch has done mandelbrots in Javascript and MS-DOS Batch as well, as well as a few sane languages... not haskell yet, though
19:04:55 <ray> cabal should really support the BSD2 license
19:05:04 <ray> the endorsement clause sucks
19:05:16 * randomwords will beat GHC at it's own game
19:06:44 <dcoutts> ray: you mean endorsement or advertising?
19:06:55 <ray> i mean endorsement
19:07:03 <dcoutts> ray: lots of packages omit that clause and label it BSD3
19:07:16 <dcoutts> technically it's not quite right
19:07:33 <ray> BSD2 isn't exactly a fringe license either, it's what freebsd uses
19:08:44 * dcoutts claims it was a mistake to label it BSD3 in the first place
19:08:54 <dcoutts> it was certainly a mistake to include BSD4
19:09:02 <dcoutts> it should just have been BSD
19:09:22 <ray> yeah, possibly
19:09:38 <ray> people do actually use both bsd2 and bsd3 though
19:09:45 <ray> bsd4 doesn't get use
19:10:19 <randomwords> copumpkin: The dump output differences are weird
19:11:01 <randomwords> It's almost exactly the same function except in the unboxed version the arithemtic operations are arranged in a slightly different (presumably worse) order
19:11:35 <randomwords> So I guess GHC is applying different top level optimisations
19:14:47 <randomwords> So with some careful brackets I can get back to the original boxed function
19:15:26 * randomwords has now bored everyone to sleep
19:15:37 <purplepenguins> *yawn*
19:19:13 <Makoryu> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3346#a3346 <- Speaking of optimization, I'm concerned about this program's performance
19:19:59 <randomwords> That quine is illegal and you should be ashamed
19:20:22 <Makoryu> I see you read all of the comments
19:21:11 <randomwords> I did
19:21:18 <suravad> Anyone willing to help analyze a newbs code?  It works, I'm just looking to get style and performance pointers and the like.
19:22:38 <suravad> It's also short.  39 lines.
19:23:21 <othercriteria> Upload it to pastebin?
19:24:26 <Makoryu> suravad: Ideally the pastebin you should use is hpaste or moonpatio
19:24:34 <Makoryu> (Well, same thing)
19:24:40 <suravad> Makoryu:  Will doo.
19:25:52 <Phyx-> has hpaste been resurrected?
19:26:03 <suravad> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3347#a3347
19:26:21 <suravad> Mostly I'm curious about the isMatch function.
19:28:16 <suravad> I know the algorithm is suboptimal... I'm not too concerned about that.
19:28:28 <suravad> I'm just trying to get a feel for the language (C programmer),
19:28:53 <randomwords> Is there a reccomended liscence for applications in hackage?
19:31:02 <ray> bsd
19:32:15 <Makoryu> suravad: Looks fine to me. Could be a little more compact (are you using tabs for indentation?) but still fine, and perfectly clear.
19:32:48 <Makoryu> Though, I'm curious why you pass the return value of parse the way you do
19:34:20 <suravad> Makoryu:  nick, ident (user, host).
19:34:34 <suravad> I assume.  (I didn't actually write that part)
19:35:02 <Makoryu> suravad: Oh?
19:35:23 <Makoryu> Waiiit a minute. Is this from lambdabot?
19:35:25 <suravad> Makoryu:  IRC hostmasks are nick!user@host  user@host is the ident response.
19:35:55 <Makoryu> suravad: Yes.
19:37:19 <suravad> It may have originally come from lambdabot...  Beyond that dunno.
19:37:28 <suravad> The isMatch was entirely my creation.
19:44:17 <Makoryu> suravad: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3347#a3348 <- Well, I sure made it shorter, but I dunno if it's better
19:44:28 <Saizan_> > Left 'a' `mappend` Right ()
19:44:29 <lambdabot>   No instance for (Data.Monoid.Monoid
19:44:29 <lambdabot>                     (Data.Either.Either...
19:44:59 <Makoryu> suravad: It's worth pointing out that you don't need guards on every pattern
19:45:58 <Makoryu> And also that you can use literals in a pattern match
19:47:28 <Phyx-> can't you also drop "mc == '?' -> isMatch m' r'"
19:47:38 <Phyx-> the otherwise case covers it
19:47:40 <Makoryu> Oh, yeah
19:47:46 <Makoryu> I didn't even notice that
19:47:55 <Makoryu> Though, that might not be what he means, in that case
19:51:10 <Phyx-> true
19:59:41 <suravad> Makoryu:  Thanks.  Your condensed version is nicer...
20:06:16 <Makoryu> suravad: Glad to be of help
20:06:24 <suravad> :)
20:06:41 <suravad> I'll probably bug you guys some more in the future...
20:07:33 <Phyx-> guess i should get some coding done
20:07:38 <Phyx-> don't feel like it though
20:09:20 <Alpounet> hi
20:10:32 <Phyx-> hi
20:36:53 <dainanaki> Hey everyone, I'm having a little trouble with the emacs haskell minor mode stuff.
20:37:06 <dainanaki> I can't get tab completion working with ghci in emacs.
20:37:13 <dainanaki> Is there some way to fix this?
20:40:05 <purplepenguins> i've neve had tab completion in ghci in emacs
20:40:14 <purplepenguins> didn't know you could
20:40:43 <dainanaki> Tab completion works in ghci in the terminal, so I figured there must be some way to make it work in emacs too.
20:41:19 <dainanaki> I just started with emacs about 3 weeks ago and my tab-completion reflex is driving me crazy.
20:44:08 <jfoutz> i think there's a slime binding for haskell.
20:44:47 <pikhq> dainanaki: Use the Emacs terminal emulator?
20:46:03 <dainanaki> No dice, still no tab completion
20:46:39 <dainanaki> wait, if I use the ansi-term it works
20:47:40 <dainanaki> I guess I'll have to rebind it somehow
20:49:48 <nominolo> dainanaki: when run as a subprocess ghci will assume the terminal doesn't support tab completion
20:50:46 <dainanaki> nominolo, is there any way to bypass that?
20:51:50 <nominolo> not sure, external processes use comint mode instead of term-mode for external processes
20:52:05 <nominolo> probably requires more than just a trivial patch to change that
20:52:58 <dainanaki> bah
20:53:00 <jfoutz> isn't emacs tab key extra special as well?
20:53:49 <dainanaki> I figured emacs ought to be friendly enough to let me bypass the extra specialness, but apparently not.
20:55:59 <jfoutz> haskell shim and hasklell scion are both referenced in yi, they might be worth checking out.
20:56:47 <jfoutz> hrm. looks like neither one is very far along.
20:56:49 <dainanaki> nominolo seems to be in charge of scion
20:57:28 <nominolo> yup.  that would be the more involved solution ;)
20:57:46 <dainanaki> does scion have a ghci with tab completion?
20:57:55 <nominolo> but I have a bit bigger plans for scion, which requires more GHC API changes
20:58:01 <nominolo> no, not yet
20:58:16 <dainanaki> because I will get more involved if necessary.
20:58:41 <dainanaki> Silly as it sounds, not having tab completion is a bit of a deal-breaker for me right now.
20:59:04 <nominolo> so what would be needed is some ghci-library, i.e., same features as ghci (or more) but with the frontend-part decoupled
20:59:18 <jfoutz> what did you edit with before?
20:59:28 <nominolo> dainanaki: how about just using ansi-term then?
21:00:19 <dainanaki> ansi-term seems to be the best situation. I just need to figure out how to build my own C-c C-l function
21:00:30 <nominolo> dainanaki: you could try turning the haskell mode into using ansi-term.  see inf-haskell.el
21:04:15 <dainanaki> whew, it might take me a while to get this. time to learn elisp.
21:04:50 <andresj> so anyone know of a good place for programming challanges/exercises? :D
21:05:46 <dainanaki> Project Euler!
21:06:21 <dainanaki> Also, build a program that will take a list of characters and a scrabble board as input and output a list of optimal moves.
21:06:26 <andresj> dainanaki: I've seen that oneI am not the very push-your-algorithms kinda guy though; I need some professional training :P
21:06:47 <andresj> dainanaki: (about the second one) now _thats_ what im talking about! :P
21:06:50 <dainanaki> Then go with scrabble solving.
21:06:59 <dainanaki> That's what I'm working on right now.
21:07:03 <andresj> lol thats pretty cool, actually
21:07:45 <andresj> hum... or a scrabble game, for that matter
21:07:50 <dainanaki> particular words that are very high scoring are gypsyfy
21:07:58 <dainanaki> xylylic
21:08:01 <nominolo> dainanaki: the alternative is to extend ghci to provide a command for completion.  the haskell-mode could then use that behind the scenes
21:08:29 <ray> there are only 2 'y's in scrabble
21:08:31 <dainanaki> nominolo, that actually sounds like a good thought.
21:08:51 <dainanaki> the tile count constraints haven't been implemented yet
21:09:05 <copumpkin> it'd be nice if the default Show instances could avoid infinite loops
21:09:20 <copumpkin> by some stablename hackery
21:58:09 <edwardk> copumpkin: kinda cheaty, yeah
21:58:46 <copumpkin> ?
21:58:55 <copumpkin> I cheat a lot, which one are you referring to?
21:59:03 <ray> probably the last thing you said
21:59:11 <copumpkin> didn't seem to fit
22:01:33 <edwardk> copumpkin: the last question you asked me about Partial
22:02:59 <copumpkin> oh
22:03:09 <copumpkin> yeah :)
22:03:13 <copumpkin> I put that on hold while I thought about it
22:03:45 <edwardk> the nice thing about Partial is you can just map getPartial over your enumeration and extract it
22:04:37 <edwardk> ironically the data Partial adds another bottom ;)
22:04:46 <SANDERS> anyone here use happstack?
22:05:05 <copumpkin> edwardk: yeah, but that one doesn't count :P
22:05:22 <ray> i thought Partial was going to be a newtype
22:05:25 <copumpkin> it was
22:05:28 <SANDERS> I'm trying to do something similar to http://tutorial.happstack.com/src/StateTExample.hs but which does not reset the state
22:05:35 <copumpkin> but then I wasn't sure how to build functions of Partial
22:05:45 <copumpkin> since it isn't as simple as just mapping the extra element
22:06:02 <edwardk> correct
22:06:07 <edwardk> you need to maintain monotonicity
22:06:11 <copumpkin> yeah
22:06:17 <copumpkin> and since I can't actually catch undefined
22:06:19 <copumpkin> unless I go impure
22:06:21 <edwardk> but you can enumerate the scenarios
22:06:26 <edwardk> you don't catch undefined
22:06:55 <copumpkin> so I put a dummy value there to reason about it and then map back to a true undefined?
22:06:55 <edwardk> you only define the functions that can be defined purely, with the addition of seq, just make sure that you only enumerate distinguishable cases
22:07:05 <edwardk> no, because then you risk a lack of monotonicity
22:07:21 <copumpkin> hmm
22:07:50 <copumpkin> but I can't reason about undefined unless I can catch it, since I want to enumerate the domain and range independently
22:07:58 <edwardk> i.e. you might have a function that returns Bottom, True, False -- in response to True, False, and Bottom respectively
22:08:21 <edwardk> yes, you can, thats why i mentioned making two functions, heh, one sec let me mock it up
22:08:29 <copumpkin> hmm :)
22:10:19 <Axman6> @src take
22:10:20 <lambdabot> take n _      | n <= 0 =  []
22:10:20 <lambdabot> take _ []              =  []
22:10:20 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:10:44 <Nehal> ok, i just had a final exam, this question that was on it is bugging me: "what is the most general type (the type inferred by Haskell) of the function defined below?   s f g x = f x (g x)"     any clues? :)
22:11:34 <edwardk> @type \f g x -> f x (g x)
22:11:36 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
22:11:38 <edwardk> =)
22:11:48 <Nehal> that was fast :)
22:11:55 <edwardk> in a language without subtyping thats about all you can do
22:11:55 <copumpkin> @type ap :: (t -> t1 -> t2) -> (t -> t1) -> t -> t2
22:11:57 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
22:13:20 <copumpkin> erg0t coalgebra!
22:13:45 <erg0t> ?
22:13:46 <copumpkin> :P
22:13:49 <copumpkin> just being silly
22:13:56 <copumpkin> http://comonad.com/reader/2008/elgot-coalgebras/
22:13:57 <erg0t> :)
22:15:09 <edwardk> elgot ;)
22:15:22 <copumpkin> I know :P
22:15:36 <lament> Waiting For Ergot
22:15:52 <edwardk> ergot is a fungus, i do not understand this argot you speak ;)
22:16:01 <lament> Cogito, Ergot Sum
22:17:20 <lament> are people who get high on ergot called ergonauts?
22:17:45 <edwardk> copumpkin: do you have a link to your code?
22:18:15 <ray> put it on hackage!
22:18:23 <ray> (when it's done)
22:18:24 <copumpkin> edwardk: my code?
22:18:29 <edwardk> the enumerable fragment
22:18:34 <copumpkin> oh http://gist.github.com/167980
22:20:47 <edwardk> you generate just the Eq instance for (a -> b) -- do you generate Enumerable for them?
22:21:03 <copumpkin> yeah, it's at the top
22:21:15 <copumpkin> line 29
22:21:49 <copumpkin> I'm not particularly happy with that function by the way
22:21:58 <copumpkin> so if you have a more elegant way of writing it, I'd be happy to see it
22:22:33 <copumpkin> and I should probably restrict it to finite domains too, as the sequence will fail miserably otherwise
22:22:39 <edwardk> i'm just going to brute force whatever comes to mind ;)
22:22:44 <copumpkin> ok :P
22:23:58 <Axman6> is there a way to hide an instance declaration of a class? i want to hide the Binary [a] instance
22:24:08 <copumpkin> nope
22:24:13 <Axman6> damn
22:24:17 <Axman6> urgh
22:25:13 <Axman6> urgh, how annoying. guess i'll have to fake it somehow
22:25:22 <copumpkin> put a newtype wrapper around it
22:25:27 <copumpkin> and make an instance for that
22:25:33 <Axman6> yeah :\
22:26:43 <Axman6> newtype List a = [a]?
22:26:51 <Axman6> oh, needs a wrapper doesn't it
22:27:01 <copumpkin> yeah
22:27:04 <edwardk> why let xs = enumerate rather than just enumerate?
22:27:23 <copumpkin> edwardk: lame attempt at avoiding double enumeration, forgot I'd even put that there
22:27:28 <edwardk> heh
22:28:29 <ray> don't comment out that Eq instance for functions
22:28:38 <ray> if you must, put it in Data.Enumerable.Controversial or something
22:28:45 <copumpkin> lol
22:29:00 <copumpkin> is this worth putting on hackage? it was really just me playing around
22:29:04 <ray> i think so
22:29:12 <edwardk> i like it
22:29:19 <ray> it's worth more than my destroyUniverse lame joke
22:29:23 <copumpkin> lol
22:29:28 <copumpkin> have you put that up yet?
22:29:30 <ray> no
22:29:39 <ray> (maybe Data.Enumerable.SmallMindsKeepOut)
22:29:55 <copumpkin> lol
22:30:41 <copumpkin> but if I am to include both instances
22:30:42 <copumpkin> they overlap
22:30:55 <copumpkin> I guess they should get a module each
22:31:22 * copumpkin can finally use his hackage account
22:31:47 <copumpkin> ack, now I need to remember how to write .cabal files
22:32:26 <ray> yeah, overlapping instances suck
22:33:58 <ray> anyway, nobody sees a problem with [1..] :: [Integer] diverging, so what's the problem with (even :: Integer -> Bool) == even diverging? :)
22:34:17 <copumpkin> the fact that there's no remedy
22:34:20 <copumpkin> I think :P
22:34:27 <ray> you should expect even less from your function equality tests after all
22:34:36 <copumpkin> [1..] can be used with all sorts of useful functions
22:34:40 <edwardk> copumpkin: if it makes you feel better, its proving tricky to figure out a remotely elegant hack to get you all of the monotone definitions, though Enumerable a => Enumerable (Maybe a) looks helpful
22:34:44 <copumpkin> but once you enter my (==), there's no turning back
22:34:58 <copumpkin> oh, I forgot about Maybe, thanks
22:34:58 <ray> step into my (==), said copumpkin to the fly
22:35:19 * copumpkin wonders about Either too
22:35:35 <ray> hmm
22:35:40 <edwardk> easy enough, though you need to do the interleaving there
22:36:22 <copumpkin> yeah
22:38:02 <copumpkin> > transpose [[1..], [-1,-2..]]
22:38:03 <lambdabot>   [[1,-1],[2,-2],[3,-3],[4,-4],[5,-5],[6,-6],[7,-7],[8,-8],[9,-9],[10,-10],[1...
22:38:07 <copumpkin> whee
22:38:10 <Trinithis> would this work for Enumerable: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8226#a8226
22:39:32 <Trinithis> oh... I didnt see the original
22:39:33 <Trinithis> nvm
22:40:32 <copumpkin> *Data.Enumerable> enumerate :: [Maybe Bool]
22:40:33 <copumpkin> [Nothing,Just False,Just True]
22:41:00 <copumpkin> *Data.Enumerable> enumerate :: [Either Bool Bool]
22:41:01 <copumpkin> [Left False,Right False,Left True,Right True]
22:41:49 <copumpkin> I'm going to force my function enumeration to be finitely enumerable too
22:42:02 <edwardk> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8226#a8227 is what i started, but i haven't got the Enumerable (a -> b) right yet
22:42:11 <edwardk> in general i can do something like
22:42:32 <copumpkin> (I like your arrows by the way, what editor do you use?)
22:42:33 <edwardk> enumerate = result where result | testArg isPartial result = ... scary monotone stuff; | otherwise = ... your existing implementation
22:42:35 <edwardk> vi
22:42:42 <Trinithis> I think it would have to be Maybe b for functions
22:42:47 <edwardk> vim to be precise
22:42:49 <Trinithis> unless cardinality is same
22:42:50 <copumpkin> ah
22:42:53 <copumpkin> Trinithis: ?
22:43:07 <edwardk> Trinithis: you can map to many targets from one input
22:43:23 <Trinithis> o right
22:43:24 <edwardk> Trinithis: nothing says anything about the injectivity or surjectivity of the function
22:44:10 <copumpkin> *Data.Enumerable> length (enumerate :: [Bool -> Bool -> Bool])
22:44:11 <copumpkin> 16
22:44:39 <copumpkin> I wonder what the answer is for Partial Bool -> Partial Bool -> Partial Bool
22:44:49 <Trinithis> what is a Partial Bool
22:44:55 <edwardk> i added enumeratePartial and enumerateTotal because i need to be able to ask for the total subset of Partial values, and the partial subset of raw types
22:45:04 <edwardk> Trinithis: True, False or bottom
22:45:05 <copumpkin> edwardk: that makes sense
22:45:24 <copumpkin> Trinithis: basically telling Enumerable that I want it to take bottom into account
22:45:31 <Trinithis> ok
22:45:39 <copumpkin> it doesn't exist yet :)
22:45:52 <ray> instance Enumerable Void where enumerate = []
22:45:55 <copumpkin> is there a good skeleton .cabal file I can use somewhere?
22:46:01 <edwardk> Trinithis: that way when enumerating it can properly generate monotone functions that handle bottom correctly, but only enumerate distinguishable
22:46:03 <copumpkin> where does Void exist?
22:46:05 <edwardk> ray heh
22:46:20 <Trinithis> ok
22:46:21 <copumpkin> instance Enumerable (Partial Void) where enumerate [undefined]
22:46:21 <edwardk> Data.Void is in category-extras for one
22:46:27 <ray> yeah
22:46:35 <ray> i wish it were in the prelude
22:46:44 <edwardk> copumpkin: instance Enumerable a => Enumerable (Partial a) covers that ;)
22:46:51 <copumpkin> edwardk: true :P
22:47:02 <copumpkin> ray: doesn't seem much use unless it can be truly void
22:47:07 <edwardk> note that the code there for Partial is careful to handle the Partial (Partial a) case properly
22:47:18 <edwardk> you only get one bottom
22:47:28 <copumpkin> edwardk: ah, nice
22:47:29 <ray> well, prelude probably doesn't want extensions like EmptyDataDecls
22:47:38 <ray> but i think you can define Void without that
22:47:51 <copumpkin> well, you can have something equivalent with newtype Void = Void Void
22:47:56 <copumpkin> but it's still not really void
22:48:12 <ray> anyway, screw the real prelude, it's in my prelude
22:48:18 <copumpkin> lol
22:48:27 <copumpkin> edwardk: mind if I merge your stuff in?
22:48:33 <edwardk> copumpkin: feel free
22:48:41 <copumpkin> edwardk: you're welcome to make changes to the gist directly, so it tracks your changes
22:48:47 <copumpkin> (as being from you)
22:48:52 <edwardk> that would require me to learn git ;)
22:48:59 <copumpkin> nah, the web interface will keep track of it
22:49:05 <copumpkin> but I guess you don't have a github account?
22:49:08 <edwardk> you know i'm not so big on that learnin stuff
22:49:11 <copumpkin> lol
22:49:21 <copumpkin> yeah, you're such a simpleton
22:49:30 <copumpkin> :)
22:49:49 <edwardk> oh yeah and please remove my $ 's from the definition for Partial a ;)
22:50:07 <edwardk> i had thought at first that the  body was going to be a tidge longer than it turned out to be ;)
22:50:16 <copumpkin> lol
22:50:31 <Trinithis> the screen isnt wide enough on gist
22:50:34 <copumpkin> so wait, what will be the difference between enumerateTotal and enumerate?
22:51:01 <edwardk> (enumerateTotal :: [Partial ()]) => [Partial ()]
22:51:03 <copumpkin> Trinithis: yeah, and I'm pretty bad about keeping a maximum column length
22:51:27 <edwardk> (enumerate :: [Partial ()]) => [(), error "bottom"]
22:51:33 <edwardk> but for non-partial types they are the same
22:51:48 <copumpkin> ah
22:52:10 <copumpkin> seems like there's slight redundancy there
22:52:12 <edwardk> when i have a function of the form [Partial a -> b], i can ask the arg if it is partial with isPartial, but then i have to enumerate just the total subset ;)
22:52:26 <Trinithis> Why Tagged?
22:52:39 <edwardk> but i can't extract the argument type from the Partial a because I only know that it is some type that implements enumerable
22:52:46 <edwardk> Trinithis: to avoid passing dummy arguments
22:53:05 <edwardk> i started using that the other day, it greatly simplifies my life
22:53:10 <copumpkin> :P
22:53:14 <copumpkin> it changes name a lot though
22:53:17 <edwardk> for one you can make Tagged into a Monad easily
22:53:34 <edwardk> i call it Tagged in reflection as well. i didn't like Lambda
22:53:43 <copumpkin> ah, I thought it was :> for a while
22:53:50 <edwardk> so an a `Tagged` b is a b carrying an a tag
22:54:00 <Trinithis> ok
22:54:08 <edwardk> yeah it was, but then i wanted to kill TypeOperators in my quest to purge extensions from Data.Reflection
22:54:14 <copumpkin> :)
22:54:21 <Trinithis> but why in the isPartial? Wouldnt a Bool simply do?
22:54:23 <edwardk> so i switched to memberless newtypes, etc.
22:54:35 <copumpkin> btw, any opinions on versioning schemes to use? what's the most favored one?
22:54:37 <edwardk> Trinithis: it wouldn't mention the variables that bind the class
22:54:53 <edwardk> so you would have no mechanism for instance selection.
22:54:54 <ray> start with 0.00, increase by .01 every time you make a notable change
22:54:56 <copumpkin> it saves that ugly thing I'm doing in cardinality
22:55:04 <copumpkin> I should probably convert cardinality to that too
22:55:07 <ray> or something
22:55:14 <ray> versioning sucks
22:55:33 <edwardk> you could define isPartial :: a -> Bool -- and just call it with (undefined :: a) and require that all such methods ignore their argument, etc. as a social contract like is done with some things for storable, etc.
22:55:37 <ray> er, i mean, numbering releases sucks, version control is great
22:55:50 <copumpkin> yeah, that's the ugly thing
22:55:51 <edwardk> but that prevents some compiler optimization, and always passes the argument because _some_ instance might use it
22:55:53 <copumpkin> made me feel dirty
22:56:05 <Trinithis> edwardk: Ah, that example did it for me :D
22:56:06 <edwardk> the newtype offers better code interface hygiene
22:56:06 <copumpkin> I'll convert cardinality to that too
22:56:25 <edwardk> copumpkin: woot. the Tagged revolution is upon us ;)
22:56:29 <copumpkin> yay
22:56:35 <edwardk> copumpkin: did you see the blog post re reflection?
22:56:53 <copumpkin> oh, not yet
22:56:56 <edwardk> i used the Tagged Applicative instance in there to clean up the example
22:57:06 <copumpkin> nice :) I'll check it out
22:57:44 <Trinithis> @hoogle Tagged
22:57:44 <lambdabot> No results found
22:58:21 <ray> @hackage reflection
22:58:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reflection
22:58:57 <copumpkin> edwardk: is there a nicer way than doing this?
22:58:57 <copumpkin>   cardinality = Tagged $ unTagged (cardinality :: Tagged b Integer) ^ unTagged (cardinality :: Tagged a Integer)
22:59:08 <ray> i'd better come up with a real haskell package before i upload joke packages
22:59:19 <ray> i don't want to be run out of haskell
22:59:21 <copumpkin> lol
22:59:27 <copumpkin> @hackage drong
22:59:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/drong
22:59:38 <edwardk> copumpkin: yeah, see the code for reflection on how i hook up things like Cons, etc.
22:59:44 <copumpkin> okay :)
22:59:54 <ray> not only does it not use the shorter urls, it can link to spurious packages
23:00:13 <edwardk> but note that Tagged can be made into a trivial monad, so you can use the sugar, all you need is a couple of operations to lift your a and b into a common tag
23:00:17 <copumpkin> edwardk: maybe Tagged should be in a separate package? so individual packages don't reinvent it every time
23:00:33 <ray> if it's really all that useful, it should be
23:00:47 <edwardk> copumpkin: yeah i'm thinking you're probably right
23:01:03 <edwardk> copumpkin: the name Tagged work for you?
23:01:03 <copumpkin> cause right now I'm just copying and pasting your instances and retag :P
23:01:08 <edwardk> the other name i thought about was Phantom
23:01:09 <copumpkin> yeah, makes sense
23:01:17 <copumpkin> Phatom sounds more dramatic :P
23:01:23 <copumpkin> but tagged seems simple
23:01:28 <edwardk> yeah
23:01:36 <Trinithis> I like Tagged more
23:01:48 <copumpkin> Data.Tagged ?
23:01:48 <edwardk> Data.Tagged ?
23:01:50 <edwardk> heh
23:01:56 <edwardk> @stereo
23:01:56 <lambdabot> Unknown command, try @list
23:01:59 <edwardk> @quote stereo
23:02:00 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
23:02:13 <ray> where your module names are proposed
23:02:16 <edwardk> i guess where your questions are asked in glorious stereo
23:02:21 <copumpkin> wow, that was close
23:02:28 <copumpkin> I almost said the same thing as edwardk there too
23:02:29 <shachaf> Ugh. They can't even have bothered to add it back in correctly?
23:02:31 <copumpkin> stopped myself just in time
23:02:43 <ray> @quote quadrophonic
23:02:44 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
23:02:46 <edwardk> ok, Data.Tagged it is.
23:02:58 <copumpkin> shachaf: what's wrong with it?
23:03:01 <copumpkin> was it anonycale?
23:03:04 <edwardk> package name tagged? tagged-values? tags?
23:03:12 <copumpkin> tagged sounds good to me
23:03:26 <copumpkin> principle of least suprise or something along those lines
23:03:33 <edwardk> yeah
23:03:38 <copumpkin> surprise even
23:03:43 <ray> package names are a bit of a free for all
23:03:56 <shachaf> copumpkin: Well, for one, it was "majestic".
23:04:00 <ray> we have some sort of standard for module names
23:04:02 <copumpkin> oh
23:04:13 <copumpkin> shachaf: I think that's before my time :)
23:04:25 <ray> i like @quote contrapunctal, but i think it vanished
23:04:29 <shachaf> But it was removed for a reason. :-) Though I suppose the overuse is not as bad now.
23:04:41 <BMeph> @quote contrapuntal
23:04:41 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:04:49 <ray> oh, just misspelled?
23:04:50 * BMeph wins!
23:04:57 <copumpkin> lol
23:05:16 <BMeph> @wn contrapuntal
23:05:19 <lambdabot> *** "contrapuntal" wn "WordNet (r) 2.0"
23:05:19 <lambdabot> contrapuntal
23:05:19 <lambdabot>      adj 1: relating to or characteristic of or according to the rules
23:05:19 <lambdabot>             of counterpoint; "contrapuntal base"
23:05:19 <lambdabot>      2: having two or more independent but harmonically related
23:05:21 <lambdabot>         melodic parts sounding together [syn: {polyphonic}] [ant:
23:05:23 <lambdabot>         {monophonic}]
23:05:30 * copumpkin wonders what ntrapuntal is
23:05:30 <ray> oh, ok
23:05:32 * BMeph wins AGAIN!
23:06:27 <coshachaf> Hmm.
23:06:31 <coshachaf> That doesn't feel right.
23:06:37 <ray> now you're in bizarro world
23:06:44 <copumpkin> you get used to it
23:06:49 <edwardk> copumpkin: should i keep the Retag stuff in the Data.Tagged package? its kinda specific to the craziness i was doing
23:07:04 <copumpkin> the retag function is definitely handy
23:07:09 <copumpkin> (I think)
23:07:11 * BMeph thinks ray should make his joke packages use the Lore.* hierarchy
23:07:16 <edwardk> k
23:07:16 <Trinithis> what is the type of retag
23:07:18 <copumpkin> I'm gonna use it in my crazy algebra library for sure
23:07:35 <edwardk> i'll keep retag in, and the type for Retag -- and you can use what you will
23:07:53 <ray> bmeph: well, it's not a joke data type..
23:08:06 <edwardk> actually i'll kill the special type for it to make the api clearer
23:09:33 <copumpkin> so just Tagged a b -> Tagged c b?
23:09:58 <copumpkin> or a :~> c :P
23:10:59 <edwardk> ii dropped the :~> or Retag type from the Tagged package so its just Tagged a c -> Tagged b c
23:11:07 <copumpkin> cool
23:11:17 <edwardk> ok, uploading
23:12:02 <copumpkin> nice
23:12:29 <edwardk> how is that for rapid development ;)
23:12:51 <ray> can't you do class Unused t where unused :: t -> (); unused _ = ()
23:12:51 <copumpkin> very rapid indeed!
23:13:14 <edwardk> Ray: nah, coz if it doesn't reference the constructor i still get the warnings it was made to silence
23:13:39 <edwardk> every constructor needs to be used at least once or exported or -Wall complains
23:13:51 <ray> ah, silly -Wall
23:13:55 <edwardk> i can use emptydatadecls, but then i appeal to an extension
23:13:56 <copumpkin> there are some cases where it's impossible to make -Wall shut up anyway aren't there?
23:14:04 <edwardk> copumpkin: ok, try to pull it now
23:14:06 <copumpkin> oh but those cases also are in extensions
23:14:08 <Axman6> anyone have any idea why this Binary instance is failing with "List ["*** Exception: too few bytes. Failed reading at byte position 51" http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8229#a8229
23:14:15 <Axman6> i'm sure it's something obvious
23:14:16 <edwardk> i'll bump to 0.3 on reflection and switch to using Data.Tagged
23:14:17 <ray> well, emptydatadecls is an obvious extension :P
23:14:37 <hackagebot> tagged 0.0 - Provides a newtype wrapper for phantom types to avoid passing dummy arguments (EdwardKmett)
23:14:41 <copumpkin> edwardk: purrfect!
23:15:05 <Axman6> the problem seems to be in the get definition, as the put seems to work on
23:15:07 <Axman6> ok*
23:15:59 <Axman6> hmm, maybe not
23:17:50 <edwardk> uploading the updated reflection library now and updating my blog post
23:18:08 <ray> exciting!
23:18:42 <hackagebot> reflection 0.3.0 - Functional Pearl: Implicit Configurations (EdwardKmett)
23:19:46 <copumpkin> cool :)
23:20:14 <edwardk> i may bump Tagged a notch to add the dummyToTagged and taggedToDummy functions or something like that
23:20:28 <edwardk> the @@ example was fairly compelling
23:20:35 <edwardk> for folks that do like that nonsense
23:20:45 <edwardk> and it would give a path to migrate more easily
23:20:54 <Axman6> argh, nothing wrong with my code, just getting types wrong >_<
23:21:48 <ray> gravatar is creepy
23:22:10 <ray> i keep forgetting that i have a picture on it, and it shows up to haunt me
23:22:50 <copumpkin> lol
23:23:04 <edwardk> i also think i'd like to crank the fixity on @@ to like 9, so it can bind very tightly
23:23:10 <ray> it's blurrier than i'd like too
23:23:16 <edwardk> foo @@ (undefined :: Int) + 1, etc.
23:23:31 <copumpkin> seems decent
23:25:53 <copumpkin> so wait, what was the isPartial for?
23:27:23 <edwardk> copumpkin: enumerate = result where result | testArg isPartial result = crazy monotone stuff; | otherwise = your definition for the function enumerable
23:27:36 <copumpkin> ah I see
23:28:11 <edwardk> i'm going to do the annoying bits and add data and typeable instances for Tagged, along with Foldable and Traversable ;)
23:28:18 <copumpkin> ooh
23:28:41 <copumpkin> so your instance Enumerable a => Enumerable (Partial a)
23:28:48 <copumpkin> is not adding the undefined
23:29:05 <copumpkin> is that intentional?
23:29:18 <edwardk> erm, is it? it should call enumeratePartial unless i fubared
23:29:45 <copumpkin> hmm
23:29:55 <edwardk> note that it calls enumeratePartial on the base type which adds the [error "bottom"] if it needs to
23:30:03 <edwardk> that way Partial (Partial a) only has one botton
23:30:05 <edwardk> er bottom
23:30:07 <copumpkin> ah yes, the default instance
23:30:19 <copumpkin> or definition, rather
23:30:22 <edwardk> yeah
23:30:22 <copumpkin> but doesn't your Partial a instance override that?
23:30:25 <Axman6> could someone take a look at this, and give me any thoughts they have about it, in regard to the current Binary [a] instance, which uses length? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8230#a8230
23:30:29 <edwardk> for itself
23:30:45 <edwardk> not for its argument that its asking to enumeratePartial
23:30:51 <copumpkin> oh, of course
23:30:53 * copumpkin kicks himself
23:30:55 <edwardk> map Partial enumeratePartial -- thats the arg type
23:31:02 <Axman6> trying to make something that doesn't force the whole list at once
23:31:10 <edwardk> its a little trixsy ;)
23:31:13 <Axman6> or, the tail of the list
23:31:19 <copumpkin> edwardk: even your short snippets are enough to fool me :P
23:33:13 <edwardk> <- sneaky
23:33:31 <Axman6> no one? :\
23:33:43 <ray> i don't know Binary :(
23:33:50 <Axman6> :(
23:34:11 <edwardk> Axman6: sorry oine sec
23:34:16 <Axman6> it's a pretty nice package, and the haddock docs for it are quite clear
23:34:17 <edwardk> Axman6: i wrote one with a newtype wrapper once
23:34:45 <edwardk> Axman6: just encode a bit for the type tag and recurse
23:34:59 <Axman6> eh?
23:35:19 <edwardk> my fragment if i could find it looks a lot like what you have there
23:35:22 <edwardk> whats the problem?
23:35:33 <copumpkin> :t (^)
23:35:34 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:35:38 <edwardk> my main issue with the Binary [a] instance is that it does two traversals with a huge !@#*() space leak in the meantime
23:35:54 <Axman6> just wondering if anyone had any thoughts on improving it. thinking there must be a way to avoid the final put of 0
23:36:11 * edwardk waits for copumpkin to request an instance of Integral for Integral b => Tagged a b ;)
23:36:22 <copumpkin> lol
23:36:24 <copumpkin> nah
23:36:34 <edwardk> you need to indicate when you stop somehow
23:36:34 <Axman6> edwardk: yeah, i saw something on -cafe and thought i'd try and make an attempt at resolving it
23:37:33 <edwardk> Axman6: so are you taking an integer of some stride through the list is that it?
23:37:40 <Axman6> well, if the final chunk has a header length < maxBound, then you don't need to
23:37:49 <hackagebot> text 0.4 - An efficient packed Unicode text type (BryanOSullivan)
23:38:01 <copumpkin> annoying orphan instance warnings
23:38:04 <copumpkin> for my function equality
23:38:06 <Axman6> edwardk: i'm not sure what you mean
23:38:09 <edwardk> Axman6: ah. mine was naive and just used a single 0 or 1 bit for each cell, wasting a byte for each entry
23:38:22 <Axman6> yeah, i wanted to avoid that
23:38:51 <Axman6> i guess 8 bytes extra isn't a huge amount
23:38:57 <edwardk> @seen bos
23:38:57 <lambdabot> bos is in #ghc, #haskell and #haskell-in-depth. I don't know when bos last spoke.
23:39:06 <edwardk> bos: around? i saw the new data.text
23:39:43 <bos> yep, here.
23:40:11 <edwardk> bos: i wanted to mention that i went to use data.text the other day and i couldn't because the internals aren't available like they are for data.bytestring
23:40:33 <bos> edwardk: what internals do you need?
23:40:39 <edwardk> and i had an application for which using shared slices of the bytestring are pretty much critical to my memory footprint
23:40:57 <edwardk> i can slice your data.text nodes, but because of surrogate pairs its O(n)
23:41:21 <edwardk> whereas with bytestrings i can track a position, even if they are utf8 encoded, and slice by cursor
23:42:12 <bos> edwardk: so you need an iterator interface, and slicing that uses it?
23:42:37 <ray> oh, the boston haskell meeting isn't secret anymore, but it's on the same day as a funeral
23:42:45 <edwardk> bos: that would pretty much solve my problem. that and something like Data.Binary.Builder for Data.Text
23:42:56 <edwardk> Ray: lovely
23:43:44 <copumpkin> zomg
23:43:52 <edwardk> whose?
23:43:53 <hackagebot> enumerable 0.0.1 - Provides a typeclass for enumerating all values in types (DanielPeebles)
23:43:57 * copumpkin faints
23:44:26 <bos> edwardk: ok, file a bug at http://trac.haskell.org/text/
23:44:42 <ray> godfather's sister
23:44:46 <ray> i am going to be a pall bearer
23:44:48 <edwardk> bos: k, take a look at that code fragment I PM'd you to get a feel for how i'm using the bytestrings
23:45:25 <edwardk> data.text would be a much nicer fit for me, and is far more likely to have a longer lifespan than my minimalist utf8 encoded bytestrings
23:45:28 <bos> edwardk: will do.
23:46:22 * bos <$> bed
23:46:26 <edwardk> basically i build an iteratee monad that holds onto a fingertree of bytestrings, and i make a parsec 3 stream instance for that monad that works with cursors over the fingertree
23:46:58 <edwardk> that lets me ask to slice the input between two cursors very efficiently because usually they come from the same bytestring in the fingertree
23:47:18 <edwardk> data.text may be a bad fit because my fragments can end mid-character though
23:47:40 <bos> the iterator interface wouldn't allow that.
23:47:54 <bos> anyway, good night. if you have thoughts you want me to remember, file a bug!
23:48:09 <edwardk> bos: what i mean is if i slice up my input file on 64k boundaries i wouldn't be starting in a way that data.text would be happy to transcode
23:48:16 <edwardk> so i may be stuck with bytestrings
23:48:31 <edwardk> but regardless, a cursor interface would be useful
23:49:18 <edwardk> k
23:49:18 <edwardk> will file
23:49:18 <copumpkin> couldn't you slice your buffer on 64k +- a couple of bytes if you landed in the middle of a character?
23:49:18 <copumpkin> or does that put too much logic in the slicing?
23:49:22 <edwardk> copumpkin: no, because the whole point of the monoid stuff is it can be handed basically anything ;)
23:50:00 <edwardk> that said, the bit i'm presenting is how to make a monoid that does handle just resuming from slightly into the next segment, but it adds a fair bit of logic to it, and logic means overhead
23:51:34 <copumpkin> but maybe some way of specifying a "slicing strategy" that most classes use a default for, but Text could have a special function?
23:51:34 <copumpkin> ah
23:51:34 <edwardk> its a  good tradeoff for say, the bulk of my lexer/parser, but would suck for this part
23:51:49 <edwardk> now that i'm thinking about it data.bytestring is a much better fit for what i'm doing right now, because there isn't much point transcoding from utf8 to ucs2 for data.text and then back down, since for the most part i'm just treating the dumb utf8 blocks once they are sliced as opaque blobs
23:54:20 <copumpkin> hmm, cabal install enumerable is failing for me
23:54:24 <copumpkin> says there's two .cabal files
23:54:34 <copumpkin> Please use only one of: ["./._enumerable.cabal","./enumerable.cabal"]
23:54:47 <copumpkin> not sure how the _ one got there, since it's not in the folder I created
23:55:15 <edwardk> copumpkin: ._... is that an editor temporary file of some sort?
23:55:17 <copumpkin> ah crap, I included the dist folder
23:55:24 <copumpkin> nope, it's definitely not in the folder
23:55:24 <ray> you haskell people are making me consider running linux in a vm or something :(
23:55:32 <copumpkin> but maybe the dist is confusing it
23:55:39 <copumpkin> ray: ?
23:56:16 <ray> well, i have my PC, and i have a remote virtual server, but half of hackage depends on sh or something, and i can't link haskell without eating all the memory on the server
23:56:20 <edwardk> ray: thats what i do
23:56:36 <edwardk> (the vm that is)
23:57:12 <copumpkin> yeah, my 0.0.1 is definitely broken
23:57:18 <copumpkin> I can't fix it, right? I must upload 0.0.2
23:57:32 <edwardk> correct
23:57:48 <ray> i didn't see hackagebot say anything =o
23:57:55 <ray> oh, there it is
23:57:59 <ray> *ahem*
23:58:36 <ray> and yeah, except if i'm going to run some terrible os in a vm, it's going to be bsd at least
23:58:44 <ray> :)
23:58:56 <hackagebot> vacuum 1.0.0 - Extract graph representations of ghc heap values. (MattMorrow)
23:59:03 <edwardk> heh well, i would invert and run windows in the vm, but its harder to game that way ;)
23:59:26 <ray> i wouldn't, that chapter of my life is over for good
23:59:53 <edwardk> gaming? or linux as desktop?
