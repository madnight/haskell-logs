00:00:28 <Cale> I once did a bunch of functional things as strings of dc commands (like map a quote over a stack, etc.), but I can't find my file.
00:01:19 <dolio> Heh, "Standarize GHC.Prim.Any"
00:03:41 <copumpkin> is it just me or does http://hackage.haskell.org/packages/archive/lazysplines/0.1/doc/html/src/Numeric-LazySplines.html look like you could get a decent Applicative instance in there?
00:04:15 <copumpkin> I guess it isn't general enough for Applicative
00:05:32 <copumpkin> ah well
00:05:40 <dolio> Which part? There aren't any new types in there.
00:05:50 <olsner> copumpkin: that file looks pretty packed, not sure you can get any more into it
00:06:04 <dolio> And (,) e, [] and (->) e are already applicatives.
00:06:31 <olsner> there are exactly 4 blank lines in there...
00:07:26 <copumpkin> dolio: yeah, just the kinds of functions looked kinda applicative, there's a liftS, a inSpline2, and various other things that looked roughly like applicative on Double
00:07:36 <copumpkin> but it obviously wouldn't work
00:08:17 <dolio> liftS looks like pure for a suitable applicative.
00:08:41 <dolio> [] `O` (,) (SomeMonoid Double) `O` []
00:09:04 <copumpkin> I saw that O very recently somewhere
00:09:07 <copumpkin> what's it from?
00:09:17 <dolio> Type-Compose or something.
00:09:20 <copumpkin> ah
00:09:27 <dolio> Although I think that uses .: more often.
00:09:29 * sbahra hugs copumpkin 
00:09:42 <dolio> It's meant to look like composition.
00:09:50 * copumpkin hugs sbahra back, or something
00:09:54 <copumpkin> I see
00:10:36 <sbahra> dc seems like it could be fun. :-)
00:10:47 * sbahra adds to TODO list for tomorrow
00:31:12 <aleator> Any minds smarter than mine to help with this leaky piece of code? http://haskell.pastebin.com/d4169fe43
01:08:38 <endojelly> I think I just understood comonads
01:08:42 <endojelly> (thanks to sigfpe)
01:09:10 <Saizan> yay!
01:09:10 <Axman6> link?
01:09:15 <endojelly> http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html
01:09:31 <endojelly> the causal stream function example really did it for me
01:09:43 <endojelly> (don't worry if you don't know what "causal stream function" means, it's explained)
01:10:22 <aleator> Any minds smarter than mine to help with this leaky piece of code? http://haskell.pastebin.com/d4169fe43
01:10:23 <opqdonut> casual stream function
01:11:11 <endojelly> just a casual, casual easy thing
01:11:39 <Saizan> endojelly: the paper he links to is also nice
01:11:42 <opqdonut> aleator: problem must be d being too lazy
01:12:05 <endojelly> Saizan, oh? ok, will look at it
01:12:40 <opqdonut> aleator: alternatively, the first version hangs on to a' and b' but with the second one they can be gc'd immediately after the return
01:13:59 <aleator> opqdonut: So it should work if I print out both sums and result of d, right?
01:14:49 <opqdonut> it's worth a shot
01:15:01 <opqdonut> sums shouldn't matter
01:16:08 <aleator> opqdonut: Well, doesn't work either..
01:18:14 <opqdonut> run a heap profile
01:18:16 <opqdonut> no use guessing
01:21:42 <ray> i sometimes think of comonads as being for codata what monads are for data
01:24:24 <ray> "sometimes" meaning "when it's useful" there
01:26:31 <mreh> what do I do when I want to reference two identically named constructs from two different Modules in Haskell?
01:26:44 <mreh> so as not to be ambiguous
01:27:39 <ray> use the module name
01:28:03 <chrisbrown> mreh: qualify with the module name: Module.fun
01:28:22 <mreh> sweet, thanks, should have probably tried it
01:29:01 <ray> kinda sucks infix though
01:29:43 <EvilTerran> mreh, if you "import Module qualified as M", then that'd be "M.fun", which is a bit nicer imo
01:30:26 <EvilTerran> er, "import qualified Module as M", rather. you can drop the "qualified" if you want to refer to the unambiguous names unqualified.
01:31:02 <mreh> mmmm, syntactic sugar
01:31:06 <EvilTerran> i feel the canonical example is "import Data.Map as M; import Data.Set as S" (because of the many name clashes between the two)
01:31:18 <ray> i don't think that's syntactic sugar :)
01:32:04 <mreh> Wikipedia: a construct in a language is called syntactic sugar if it can be removed from the language without any effect on what the language can do
01:33:02 <ray> do notation is syntactic sugar, the : constructor is arguably syntactic sugar, the module system is not
01:33:36 <EvilTerran> ray, but "import as" and unqualified names could be considered syntactic sugar
01:33:37 <mreh> but the use of "as" is a feature that just makes it easier for a hooman to use
01:33:54 <mreh> it's still functionally the same without it
01:33:58 <kulakowski> ray: I'd argue the opposite, that [1,2,3] is sugar for 1 : 2 : 3 : []
01:34:07 <ray> kulakowski: that's not the opposite
01:34:21 <ray> that's sugar atop sugar
01:34:24 <opqdonut> : is definitely not syntactic sugar
01:34:29 <opqdonut> it's pattern matchable and everything
01:34:35 <opqdonut> it's a valid constructor name and so on
01:35:13 <kulakowski> I'm not sure I'd call infix constructors sugar, but it's a subjective thing
01:35:19 <ray> well, it's the only one in h98
01:35:40 <ray> in ghc? arguably :)
01:35:48 <kulakowski> I'll tell 1998 :)
01:36:38 <quicksilver> infix constructures are absolutely haskell98
01:36:47 <quicksilver> (:) happens to be the only one in the prelude
01:36:50 <kulakowski> yeah I was about to say
01:36:51 <ray> are they? i thought you had to turn them on
01:36:57 <quicksilver> nope.
01:37:08 <Deewiant> You could still call them syntactic sugar, though
01:37:34 <kulakowski> An operator symbol starting with a colon is a constructor. -- From the report.
01:38:22 <ray> then i wouldn't call it sugar, just normal syntax
01:38:28 <int-e> ray: you're thinking of type operators (i.e. infix type variables and type constructors)
01:38:36 <ray> yes, i am
01:38:54 <ray> do those also need to start with :? i am now hopelessly confused
01:39:49 <Deewiant> All operators are arguably sugar
01:40:53 <ray> haskell is sugar, because it gets compiled to machine code
01:41:16 <Deewiant> No, because machine code is less expressive than Haskell
01:41:54 <mreh> has the Module Concurrent been depreciated?
01:42:08 <ray> i don't know, i don't follow haskell securities
01:46:15 <monn> is there any practical usage of y combinator?
01:46:42 <Axman6> mreh: why do you say that?
01:47:01 <mreh> Axman6: say what?
01:47:16 <Axman6> your question about the concurrent module
01:47:50 <EvilTerran> monn, not really, no. it's mostly useful to demonstrate that recursion can be implemented in the untyped lambda calculus.
01:47:57 <Deewiant> > fix ((0:) . scanl (+) 1)
01:47:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:48:27 <EvilTerran> in haskell, sometimes fixed-point combinators are useful, but "fix" is defined directly in terms of recursion
01:48:36 <EvilTerran> "fix f = x where x = f x"
01:49:37 <HugoDaniel> good morning
01:49:46 <monn> Cool
01:53:23 <ray> huh. a type variable can be a regular operator, but type constructor that's an operator has to start with :
01:53:31 <ray> so the : is like a capital letter
01:53:57 <ray> that explains the ~> arrow thing
01:54:26 <fasta> While cabal install yi, I get: ~/.cabal/lib/derive-0.1.4/ghc-6.10.2/HSderive-0.1.4.o: unknown symbol `syb_DataziGenericsziSchemes_zdseverywhereM_info' Loading package derive-0.1.4 ... linking ... ghc: unable to load package `derive-0.1.4'
02:02:22 <EvilTerran> ray, yeah; well, apart from (->), that's a special case
02:04:07 <endojelly> ray, haskell treats : as a capital letter?
02:04:10 <endojelly> I did not know that?
02:04:37 <endojelly> wait that makes no sense
02:04:47 <endojelly> I don't need whitespace in expr:type
02:06:14 * ManateeLazyCat pasted "exception problem." at http://paste2.org/get/383055
02:06:14 <ManateeLazyCat> Last line in above code, i got error "Ambiguous type variable `e' in the constraint: `E.Exception e' arising from a use of `E.catch'", so strange, (\_ -> ...) can't work?
02:06:57 <ManateeLazyCat> Probable fix: add a type signature that fixes these type variable(s)
02:06:57 <quicksilver> no, you need to constraint the type
02:06:57 <quicksilver> to what you actually want to catch.
02:07:18 <ManateeLazyCat> quicksilver: All exception.
02:07:57 <ManateeLazyCat> quicksilver: I want catch all exception, so i write `_`
02:09:34 <ManateeLazyCat> quicksilver: I really can't see why above code can't work, i copy from haskellfm project, it compile success, my can't work now?
02:09:56 <EvilTerran> endojelly, : is to operator characters what a capital letter is to alphanumeric characters
02:09:58 <ManateeLazyCat> Any idea?
02:10:01 <quicksilver> ManateeLazyCat: because the exception library changed.
02:10:12 <endojelly> EvilTerran, aah. to operator characters.
02:10:13 <fasta> If I have newtype P = P Int, how do I export the type P and the constructor P without getting a warning of duplicated exports?
02:10:14 <endojelly> thx
02:10:23 <quicksilver> fasta: P(P)
02:10:28 <ManateeLazyCat> quicksilver: What's mean exception library changed?
02:10:47 <EvilTerran> endojelly, in that any operator starting with : is a constructor, and other operators are not
02:10:51 <quicksilver> ManateeLazyCat: It means the library, which supplies the exception type and the routeines which work on it, changed from one GHC version to the next.
02:10:57 <quicksilver> the versions are incompatible.
02:10:59 <fasta> quicksilver: thanks
02:11:06 <quicksilver> code which works on one will not work on the other.
02:11:55 <ManateeLazyCat> quicksilver: Badly, so new exception library can't support `_` for match all exception?
02:11:57 <endojelly> EvilTerran, that is actually really useful information, because I remember that, some time ago, I was wondering if I could use an operator name as constructor
02:12:07 <quicksilver> ManateeLazyCat: no badly, no. It changed very well.
02:12:22 <quicksilver> ManateeLazyCat: and one of the things it means is you can no longer use _ to match all exceptions, yes.
02:12:40 <quicksilver> You can use SomeException, although catching all exceptions is generally a mistake.
02:12:41 <endojelly> EvilTerran, I ended up using a normal capitalized constructor name and using a helper function which just had the constructor as expression
02:13:16 <ManateeLazyCat> quicksilver: I see, i change code.
02:14:08 <quicksilver> ManateeLazyCat: the old interface is still there as Control.OldException.
02:14:10 <EvilTerran> endojelly, the other way you could do that would be to wrap the alphanumeric constructor in backticks
02:14:49 * EvilTerran tries to think of a binary alphanumeric constructor that lambdabot would have in scope
02:15:04 <endojelly> EvilTerran, yeah, but I really wanted it to be an operator 8)
02:15:40 <quicksilver> EvilTerran: there aren't any in the core libs, weirdly.
02:16:25 <quicksilver> EvilTerran: most of the product types in the core libs are (,) ;)
02:16:38 <EvilTerran> quicksilver, yeah, that's what i thought
02:17:36 <EvilTerran> quicksilver, and the others use an operator constructor
02:17:40 <EvilTerran> (:+ etc)
02:19:00 <EvilTerran> > 1 `Node` [2 `Node` [], 3 `Node` []]
02:19:02 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []},Node...
02:19:18 <EvilTerran> found one! :D
02:19:25 <quicksilver> ;)
02:25:15 <chrisf1> hi #haskell, just trying to install haskell platform on ubuntu-jaunty-amd64 - in `sudo make install` it fails with "Error: The mtl-1.1.0.2/Setup script does not exist or cannot be run"
02:32:40 <Gracenotes> hm. What's the best way to store a DAG, and one with efficient node lookup at that (all nodes have a number 1, 2, 3..) :/
02:33:14 <quicksilver> there is no best way to store a dag.
02:33:19 <Gracenotes> I guess each node could include information about parent/children, but there are 3000 nodes :/
02:33:23 <EvilTerran> Gracenotes, i quite like "Map Int (Set Int)" as a general-purpose graph representation
02:33:34 <quicksilver> intmap from nodes to sets of children
02:33:36 <EvilTerran> or IntMap IntSet, if you need big graphs
02:33:40 <quicksilver> springs to mind.
02:34:19 <Gracenotes> hm. And for information about parent nodes, perhaps (IntSet, IntSet)? This is actually in Python, not Haskell, but they do share some of the same data structures
02:35:02 <Gracenotes> I suppose it's necessarily a lot of information to store
02:35:13 <ziman> in python i'd create a Node class and represent the edges using references between them
02:35:27 <quicksilver> yes, you can store 'forward neighbours' and 'backward neighbours'
02:35:34 <EvilTerran> it's hard to represent a graph so that any query you might want to make is efficient
02:35:48 <quicksilver> Gracenotes: well, 3000 nodes is pretty small.
02:35:57 * Gracenotes needs to stop thinking about it in terms of trees >_>
02:36:01 <fasta> If you want to have fast graphs, you write it in the ST monad. For 3000 nodes, you can use Int<*>.
02:36:56 <fasta> I wonder whether anyone would be willing to pay for a quality graph data structure library.
02:36:59 <Gracenotes> perhaps.. I should have one array with all the links, length of 3000, and another array with all the node information...
02:37:10 <fasta> It's like FAQ #1 here.
02:38:14 <Gracenotes> at least, though, let me see if I can write a Haskell program to make collecting the graph data easier
02:38:22 <EvilTerran> fasta, i thought that was "how do i : onto the end of a list?" :P
02:38:55 <Deewiant> Is fgl not "quality"?
02:40:07 <fasta> Deewiant: fgl is a toy
02:40:08 <Gracenotes> I don't think I've programmed in... eh... don't exactly remember.
02:40:19 <fasta> Deewiant: for small inputs it will work, for large inputs, no.
02:40:42 <EvilTerran> fgl uses "data Graph a = Node a [Graph a]" or something analogous, doesn't it?
02:40:55 <Deewiant> fasta: How large?
02:40:56 <EvilTerran> something that's liable to trip up on cycles etc, anyway
02:41:18 <fasta> Deewiant: Somewhere between 1K and 10K would be the limit of acceptable waiting, for me.
02:42:34 <Deewiant> EvilTerran: Looking at the source it has "data Gr a b = Gr (IntMap (IntMap b, a, IntMap b))" (modulo some type synonyms)
02:44:12 <Deewiant> The other version is "Gr (FiniteMap Int ([(b,Int)], a, [(b,Int)]))"
02:44:29 <fasta> They used to use contexts.
02:44:31 <Deewiant> Where FiniteMap is an internal type hackage doesn't have
02:44:58 <fasta> If they stopped using that, fgl might be used until 10Ks of nodes.
02:45:02 <Deewiant> No, actually it does
02:45:16 <Deewiant> FiniteMap a b = Empty | Node Int (FiniteMap a b) (a,b) (FiniteMap a b)
02:45:32 <Deewiant> fasta: Well, they are contexts. 'type Context' a b = (IntMap b, a, IntMap b)
02:45:53 <fasta> That type used to be a tuple of lists.
02:46:07 <Deewiant> fasta: Yes, that's the other one I showed above.
02:46:26 <fasta> Ok, so, the bounds of fgl are now different, probably for the better.
02:46:28 <Deewiant> Data.Graph.Inductive.Tree is lists, Data.Graph.Inductive.PatriciaTree is IntMaps.
02:46:55 <fasta> Still, I would use one without all the log n indirections.
02:55:41 <lysgaard> I have a do clause. In it i do a Control.Monad.StateT.modify. Do i have to get the state again to se the change in the same do clause? I see no change in the state if i don't
02:56:58 <quicksilver> lysgaard: what do you mean "you see no change"?
02:57:02 <quicksilver> lysgaard: how are you observing it?
02:57:30 <quicksilver> (alternative way to ask the question: "How could you see the change in the state without getting it?")
02:57:31 <Deewiant> do a <- get; modify f; print a -- see the old state
02:57:38 <Deewiant> (Presumably)
02:58:00 <fasta> lysgaard:  do s<-get;modify (+1);t<-get => t/=s
02:58:12 <lysgaard> quicksilver: Deewiant You're both on the right trock
02:58:25 <fasta> lysgaard: if you see anything else, return your machine to your vendor ;)
02:58:37 <lysgaard> fasta: Hehe
02:58:49 <quicksilver> lysgaard: well, in Deewiant's example, "a" is just a value. It doesn't matter what you do to the state after that, "a" is just a value and haskell values are immutable.
02:58:55 <lysgaard> Well, i just wondered i this was the expected behavior.
02:59:13 <lysgaard> Is the reason for this immutable data in haskell?
02:59:16 <Deewiant> lysgaard: 'modify' doesn't go backwards in time and change the value of a :-)
02:59:51 <lysgaard> Deewiant: True. I gues i just had a lapse of imperative thought :S
03:00:29 <quicksilver> lysgaard: a reason? More like, its' the whole point :)
03:00:36 <quicksilver> lysgaard: it's what haskell is all about. purity. value.
03:02:03 <lysgaard> quicksilver: Yeah, you're right. Just me falling back sometimes to the old mindset
03:07:37 <EvilTerran> lysgaard, it may help to bear in mind that "x <- foo" in a do-block is (approximately) equivalent to (foo >>= \x -> {rest of the block})
03:09:54 <lysgaard> EvilTerran: Ah, never looked at it that way
03:10:18 <EvilTerran> that's how do-blocks desugar
03:16:35 <LeoD> k
03:16:38 <LeoD> oops
03:17:51 <chrisf1> update on haskell-platform install on ubuntu-jaunty-amd64: there seems to be something broken in the make process - `make install` requires mtl to be built, but it doesn't happen!
03:18:47 <chrisf1> doing cd packages/mtl-* && ghc --make Setup.hs && ./Setup configure && ./Setup build fixes the problem
04:19:52 <ziman> @pl sequence . repeat
04:19:53 <lambdabot> sequence . repeat
04:21:29 <ray> @unpl sequence . repeat
04:21:30 <lambdabot> (\ c -> sequence (repeat c))
04:21:51 <ray> is that what you wanted? (though it's not useful either)
04:22:17 <ziman> i wanted to know whether there's a single function equivalent to this
04:22:28 <ziman> like mapM = sequence .: map
04:24:04 <ray> replicateM i think
04:24:34 <ray> or, no
04:24:56 <quicksilver> ziman: no, because it's not useful
04:24:56 <ray> that isn't infinite
04:24:56 <Deewiant> genericReplicateM (1/0) ;-)
04:25:24 <quicksilver> ziman: it would need to "perform" all the effects before it returned any result.
04:25:31 <quicksilver> in general sequence is not useful on infinite lists.
04:25:32 <ziman> quicksilver, i see
04:26:21 <quicksilver> there might be a couple of monads in which it's OK, but I haven't thgouth hard about that.
04:26:32 <quicksilver> it's certainly ok in the identity monad, where sequence = id.
04:27:40 <Deewiant> It's okay in Maybe/Either where it means "loop forever or until Nothing/Left" ;-)
04:27:47 <Deewiant> Of course, with repeat it's somewhat useless
04:28:39 <ray> > sequence . repeat $ Nothing
04:28:40 <lambdabot>   Nothing
04:28:49 <ray> that's like all you can do
04:29:18 <Deewiant> sequence . repeat with Maybe = maybe undefined Nothing
04:29:34 <Deewiant> sequence . repeat with Either = either Left undefined
04:29:39 <quicksilver> ah yes, you're right.
04:30:03 <quicksilver> is it then also OK for lists of IO computations which eventually throw an exception?
04:30:06 <quicksilver> probably.
04:30:18 <Deewiant> Yes, for IO it's of course also fine
04:30:46 <Deewiant> But again, with repeat, less so
04:31:06 <quicksilver> well IO actions can be arbitrarily complex inside and reflect external state
04:31:20 <quicksilver> you can easily devise something which runs several times and then dies with an exception
05:04:46 <EvilTerran> quicksilver, ziman, etc; it could be useful for such monads as ErrorT State, i guess
05:04:49 <EvilTerran> > flip runState (2^3 * 3^2 * 5, 2, []) . runErrorT . sequence . repeat $ do (x, d, ds) <- get; guard (x > 1); if x `mod` d == 0 then put (x `div` d, d, d:ds) else put (x, d+1, ds) :: ErrorT String (State (Int,Int,[Int])) ()
05:04:50 <lambdabot>   (Left "",(1,5,[5,3,3,2,2,2]))
05:05:55 <quicksilver> EvilTerran: yes, or 'Exit'
05:06:04 <EvilTerran> Exit?
05:06:17 <quicksilver> EvilTerran: ...which is just the Error monad renamed to emphasis that the 'Left' value is to be thought of as the final value of a computation
05:06:36 <quicksilver> it's Either where you think of 'Right' as incomplete computation and 'Left' as finished.
05:07:07 <EvilTerran> uh... the type parameters for success and failure will have to be in the same order, right?
05:07:11 <ziman> EvilTerran, nice! :)
05:07:28 <quicksilver> yes, the monad definition is exactly the same
05:07:36 <quicksilver> it's just a different way of thinking of it
05:07:49 <quicksilver> insetad of "termination by exception" you think of that as "normal termination"
05:07:54 <EvilTerran> ziman, of course, there's far less imperative ways of getting the prime factors out of a number :P
05:07:58 <QP> @src ArrowLoop
05:07:58 <lambdabot> Source not found. Just try something else.
05:08:06 <QP> @src loop
05:08:06 <lambdabot> Source not found. That's something I cannot allow to happen.
05:08:11 <quicksilver> and instead of "normal termination" you think of that as "data embodying incomplete execution"
05:08:20 <EvilTerran> i see
05:08:33 <QP> @hoogle ArrowLoop
05:08:34 <lambdabot> Control.Arrow class Arrow a => ArrowLoop a
05:08:58 <EvilTerran> QP, it's defined in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html - the "source" links down the right do the obvious
05:09:30 <QP> yes, i want to display it in here, so i can ask a question about it where we can all see it.
05:10:00 <QP> basically, instance ArrowLoop (->) where
05:10:17 <EvilTerran> class Arrow (~>) => ArrowLoop (~>) where loop :: ((b,d) ~> (c,d)) -> (b ~> c
05:10:17 <EvilTerran> )
05:10:24 <QP> loop f b = let (c,d) = f (b,d) in c
05:10:44 <QP> how does that definition work?
05:10:50 <QP> d isn't defined!
05:10:59 <quicksilver> > let a = 1:a in a
05:11:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:11:06 <quicksilver> QP: how does that definition work? a isn't defined!
05:11:11 <QP> ok...
05:11:22 <EvilTerran> it's defined in "let (c,d) =". definitions in haskell can be recursive even if they're not functions.
05:11:38 <EvilTerran> "loop f b = c where (c,d) = f (b,d)"
05:11:41 <LeCamarade> Which cabal install exports Network.Server ?
05:11:56 <LeCamarade> I have a compile that needs it, and I don't remember what I cabal installed for it.
05:12:18 <LeCamarade> I mean Network.HTTP.Server
05:12:26 <quicksilver> ghc-pkg find-module Network.HTTP.Server
05:14:04 <LeCamarade> quicksilver, I see no returns. I guess I'll first run a cabal update. Thanks, still. I had totally forgotten about ghc-pkg. :o)
05:14:35 <Phyx-> hehehe
05:15:25 <quicksilver> @google Network.HTTP.Server haskell
05:15:26 <lambdabot> No Result Found.
05:15:30 <quicksilver> :(
05:15:39 <quicksilver> looks like http-server
05:15:41 <quicksilver> from my google
05:16:14 <Phyx-> question, what's involved in registering the same packages in multiple ghc compilers? i hae 2 ghc 10 and 1 ghc 6.8 installed, i (and paying attention to the syntax change) added the modules to the packages.conf files. ghc-pkg for the respective ghc's show them, but yet it won't load...
05:16:51 <LeCamarade> quicksilver, It is http-server.
05:16:58 <LeCamarade> A Galois offering. :o)
05:17:24 <quicksilver> Phyx-: different ghcs are binary incompatible
05:17:27 <LeCamarade> I'm glad I knew about it before my latest project began.
05:17:29 <quicksilver> Phyx-: so that's not likely towork.
05:18:01 <Phyx-> quicksilver: :( i wanted to have to avoid installing all these packages on all of them
05:18:20 <quicksilver> not much you can do about that.
05:18:29 <quicksilver> binary incompatible is binary incompatible ;)
05:18:44 <Phyx-> i would think taht the 9.10.x ones would be binary compatible though
05:18:59 <quicksilver> you would think wrong.
05:19:16 <quicksilver> if they change the compiler, they've changed the copmiler :)
05:19:19 <Phyx-> wouldn't be the first nor last time i'm afraid
05:19:19 <quicksilver> that's the thing about compilers.
05:19:28 <quicksilver> when you change them, they produce different code
05:19:32 <quicksilver> that's why you did it :)
05:19:42 <quicksilver> of course, it certainly might work sometimes.
05:19:53 <quicksilver> if they didn't happen to change the .hi file and so on
05:19:57 <quicksilver> but you might be missing out on bug fixes
05:20:04 <quicksilver> and you might expose strange untested bugs.
05:20:28 <Phyx-> hmmm, so answer is "don't even think about it"
05:20:40 <quicksilver> it certainly sounds unwise to me :)
05:21:18 <Phyx-> heheh
05:21:26 <QP> > let f (b,False) = (b+1,b==10); let f (b,True) = (b, True); let (c,d) = f (1,d) in c
05:21:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:22:43 <quicksilver> you don't want the extra lets, QP
05:22:46 <Deewiant> > let f (b,False) = (b+1,b==10); f (b,True) = (b, True); (c,d) = f (1,d) in c
05:22:52 <lambdabot>   mueval-core: Prelude.read: no parse
05:22:52 <lambdabot>  mueval: ExitFailure 1
05:23:09 <QP> > let f (b,bool) = if bool then (b,True) else (b+1,False), (c,d) = f (1,d) in c
05:23:10 <lambdabot>   <no location info>: parse error on input `,'
05:23:32 <Deewiant> You want a semicolon, not a comma
05:23:48 <QP> > let f (b,bool) = if bool then (b,True) else (b+1,False); (c,d) = f (1,d) in c
05:23:53 <lambdabot>   mueval-core: Prelude.read: no parse
05:23:53 <lambdabot>  mueval: ExitFailure 1
05:24:03 <Deewiant> Infinite loop
05:24:09 <Phyx-> don't you need {} around it?
05:24:14 <Deewiant> No
05:24:28 <QP> ok, can anyone show me a concrete example of this loop definition `doing` anything?
05:25:05 <QP> it just seems to me like lambdabot quite rightly doesn't know where to start with d
05:26:58 <QP> > let f (b,d) = (1:b,d); (c,d) = f (2,d) in c
05:27:00 <lambdabot>   No instance for (GHC.Num.Num [t])
05:27:00 <lambdabot>    arising from the literal `2' at <inter...
05:27:36 <QP> > let f (b,d) = (1:b,d); (c,d) = f ([],d) in c
05:27:37 <lambdabot>   [1]
05:28:58 <idnar> > let f (b,bool) = if' bool (b,True) (b+1,False); (c,d) = f (1,d) in c
05:29:00 <lambdabot>   Not in scope: `if''
05:29:02 <idnar> bah
05:29:07 <Deewiant> QP: That ends up calling itself infinitely, I think; since d depends on f (1,d) which depends on d which depends on f (1,d) ...
05:29:35 <randomwords> I've just started getting the linker error. <command line>: can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header). any ideas?
05:29:38 <idnar> yeah, I don't think that can do anything
05:29:46 <QP> > let f (b,d) = (1:d,1:b); (c,d) = f ([],d) in c
05:29:47 <lambdabot>   [1,1]
05:30:02 <QP> now, can i get three.... ??
05:30:43 <QP> > let f (b,d) = (d,1:b); (c,d) = f ([],d) in c
05:30:44 <lambdabot>   [1]
05:31:29 <QP> > let f (b,d) = (d,d++b); (c,d) = f ([],d) in c
05:31:34 <lambdabot>   mueval-core: Prelude.read: no parse
05:31:34 <lambdabot>  mueval: ExitFailure 1
05:35:06 <lilac> > let f (b, xs) = (if null xs then 1+b else b, b:xs); (c,d) = f (1,d) in c
05:35:08 <lambdabot>   1
05:40:36 <lilac> QP: a good trick here is: imagine d on the RHS were a new special value D which acts like _|_ if you try to use it. what value does the d on the LHS get?
05:41:20 <lilac> if that's D or _|_ then it's not going to work. if you get something like d = 1:D, then the result is fix (1:), etc.
05:44:42 <Deewiant> > let f (b,d) = let x = head b in first (x:) (f (x+1:d, b)); (c,d) = f ([1], d) in c
05:44:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:48:39 <lilac> well, if you're not actually using d at all, then it doesn't matter if it's _|_ :)
05:49:08 <Deewiant> Sure it's using d, last c == d ;-)
05:49:34 <Deewiant> Except not quite, more like d `isSuffixOf` c
05:51:19 <lilac> well, if you can actually look at the aleph_0'th element of the list, then you can see that it didn't "work"
05:51:37 <Deewiant> But we can't, so it's moot. :-P
05:51:51 <Deewiant> All _|_'s look alike
05:52:00 <lilac> Try telling that to Renault
05:52:06 <Deewiant> :-)
05:53:44 <LeCamarade> Is there a handy guide for how to create a cabal package?
05:53:59 <Axman6> the wikibook covers it, sort of
05:54:02 <LeCamarade> Basically what YAHT is to Haskell?
05:54:06 <LeCamarade> Okay.
05:54:07 <dcoutts> LeCamarade:  http://haskell.org/cabal/
05:56:20 <luite> dcoutts: do you know what can cause this gtk2hs build error? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8251
05:59:25 <thaldyron> LeCamarade: there's also a section in the online Real World Haskell
05:59:33 <thaldyron> LeCamarade: book
06:04:45 <Phyx-> doesn't the wiki only cover the old syntax?
06:05:52 <gwern> probably. haven't looked at it in a while
06:07:03 <fasta> luite: show the context of mmsystem.h:944 and more people can help you.
06:07:25 <luite> ok, I'll attach it
06:09:25 <fasta> luite: I mean it is not impossible to debug that. It just takes time. The first step would be to see whether the c2hsLocal.exe is correct.
06:10:00 <fasta> luite: most likely, however, some mingw implementation is wrong, which causes c2hslocal to give back an error.
06:10:26 <luite> I was expecting it to be some version issue with the gcc 3.4.5 headers in my mingw install
06:11:23 <dcoutts> luite: I don't know specifically. I'd have to look at the header. I might be some weird syntax or might be some missing macro that gives us broken syntax.
06:12:25 <luite> hm, I wonder why my revisions don't show up
06:13:19 <luite> this is from mmsystem.h: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8260
06:15:00 <hackagebot> hfractal 0.1.1.0 - OpenGL fractal renderer (ChrisHoldsworth)
06:16:13 <luite> it's the first time the DRVCALLBACK macro is used, I don't know where it's defined (a grep through the include tree doesn't yould any #define)
06:22:30 <Phyx-> hrm, what the hell is the typechecker complaining about
06:22:34 <Phyx-> it's wrong! :P
06:23:39 <Phyx-> hrm, ok.. ok.. it was right
06:26:50 <dcoutts> Heffalump: thanks for your response. I agree with what you say. While wearing my release team hat I try not to be too partial in presenting the issue. :-)
06:33:57 <fasta> Why doesn't anyone implement syntax for data Z x = Z l| Y l where l = Z x? It's not like there are alternatives, right?
06:34:59 <quicksilver> data ProtoZ x k = Z l | Y l
06:35:20 <quicksilver> newtype Z x = Mu (ProtoZ x)
06:35:31 <quicksilver> s/k/l/; # sorry
06:36:01 <Phyx-> would that work?
06:36:09 <quicksilver> that's not a serious proposal, Mu-types are a pain.
06:36:15 <Phyx-> wouldn't it say redifinition of Z or something?
06:37:34 <dcoutts> how is it different from data Z x = Z (Z x) | Y (Z x) ?
06:38:04 <quicksilver> dcoutts: fasta's point is just to save typign (Z x) twice
06:38:22 <fasta> In larger data types, the payoff is ofcourse larger.
06:38:31 <dcoutts> you can use type synonyms
06:38:46 <quicksilver> not locally with a definition.
06:52:07 <Athas> Is there a way to hide one of the instances of a datatype from the importers of my module?
06:52:40 <quicksilver> Athas: classes have instances, not datatypes.
06:52:46 <quicksilver> Athas: is that what you meant?
06:52:58 <EvilTerran> Athas, unfortunately, haskell instance resolution wouldn't make much sense if instances weren't implicitly global, so they are.
06:53:11 <quicksilver> but basically, no, instances are not easy to hide.
06:53:20 <quicksilver> you have to layer the type behind another type which is in another module
06:53:27 <Phyx-> "not easy" i thought you couldn't at all
06:53:27 <quicksilver> why do you want to?
06:53:33 <Athas> quicksilver: oh right, I meant that my type WM is an instance of CatchIO, but I wanted to hide that fact.
06:53:48 <quicksilver> why do you want to hide it?
06:54:07 <Athas> I have to replace a bunch of the standard CatchIO functions with my own, so any user who thought "oh, this is a CatchIO instance" and used it would be in for an unpleasant surprise.
06:54:17 <quicksilver> make a newtype
06:54:17 <Athas> Specifically, I have a monad that combines ErrorT and CatchIO.
06:54:29 <EvilTerran> import a module with an "instance Foo Bar", but hiding the instance; write your own "instance Foo Bar"; call a function from the imported module with a "Foo a => a -> ..." type... which instance do you use?
06:54:29 <quicksilver> secretWM, which implements CatchIO
06:54:37 <quicksilver> and then make the "real" WM not implement it.
07:04:41 <mreh> I think I'm in far over my head with my simple Asteroids game, using HGL i've come across this: newtype Key = MkKey X.KeySym deriving Show
07:05:15 <mreh> what difference does newtype make to me?
07:05:54 <lilac> mreh: semantically, 'newtype' means almost the same as 'data'
07:06:24 <Phyx-> only it always has 1 field
07:06:39 <lilac> the primary difference is that pattern matches on MkKey always succeed, even if the value is undefined
07:07:18 <lilac> operationally, newtypes can be implemented slightly more efficiently
07:08:35 <mreh> does it always have the one constructor then?
07:09:17 <Phyx-> yes
07:10:24 <mreh> import qualified Graphics.X11.Xlib as X
07:10:24 <mreh> clearly X is this module. can't find a KeySym anywhere in it though :(
07:10:47 <mreh> KeySym is an existing type right?
07:11:00 <mreh> for this to semantically correct
07:11:08 <quicksilver> yes.
07:11:40 <pozic> Why do newtypes exist, when data Bar=Bar !Type is the same?
07:11:46 <quicksilver> mreh: http://hackage.haskell.org/packages/archive/X11/1.4.5/doc/html/Graphics-X11-Types.html#t%3AKeySym
07:11:52 <quicksilver> pozic: they are not the same :)
07:12:20 <pozic> A difference with ~, then.
07:12:24 <pozic> I forgot.
07:13:58 <quicksilver> for a newtype, case b of Bar y -> .... does not force anything
07:14:23 <quicksilver> it compiles away to nothing.
07:14:49 <mreh> does anyone know how to "plug" HGL Event into the Graphics.HGL.Key methods
07:15:03 <mreh> like "isUpKey"
07:15:11 <mreh> they accept completely different types
07:16:26 <quicksilver> mreh: it looks like Key is one alternative for Event
07:16:33 <quicksilver> http://cvs.haskell.org/Hugs/pages/libraries/HGL/Graphics-HGL-Window.html#t%3AEvent
07:16:51 <mreh> quicksilver: I've just worked it out, inside of the Key type is another Key object!
07:16:55 <mreh> tres confusing
07:17:14 <quicksilver> no.
07:17:22 <quicksilver> inside of the Key *constructor*
07:17:28 <quicksilver> is a value of the Key *type*
07:17:33 <quicksilver> constructor != type
07:17:37 <quicksilver> (yes, that is confusing)
07:18:17 <mreh> sorry, I'm Javarising
07:18:44 <quicksilver> I think HGL is pretty much disused and deprecated, by the way
07:18:55 <mreh> quicksilver: I
07:19:01 <mreh> quicksilver: I'm making asteroids :)
07:19:21 <mreh> it was just for fun, I wanted a small API to use
07:20:15 * quicksilver nods
07:22:34 <lilac> pozic: given data D = D !Int and newtype N = N Int: _|_ is in type D, but D _|_ is not. N _|_ is in type N, but _|_ is not.
07:25:20 <quicksilver> pozic: basically, the whole purpose of newtypes is to make wrapping/unwrapping O(0).
07:25:40 <quicksilver> strict data can't do that in general, because in general there can be multiple constructors.
07:25:50 <lilac> incidentally, why are newtypes limited to a single contained element?
07:25:56 <quicksilver> it has often been debated if single-cosntructor strict data should automatically get newtype optimisation.
07:26:00 <lilac> is it solely for newtype-deriving?
07:26:12 <quicksilver> no, newtype predates newtype-deriving by 20 years :P
07:26:34 <quicksilver> it's because wrap/unwrap is supposed to be a NOP.
07:26:43 <quicksilver> how could wrapping two elements be a NOP?
07:26:48 <Phyx-> grr why does it work in ghci but when i call the function it dies
07:27:41 <quicksilver> monomorphism restriction?
07:28:07 <lilac> quicksilver: wrapping two elements being a NOP would require that not all elements are the same size (or all elements are size 0).
07:28:59 <Phyx-> quicksilver: nah, the function is broken, in ghci i test the line that goes bad, it works, so it must be breaking in conjuction with the rest
07:29:07 <lilac> but that alone doesn't sound like it's intractible
07:29:21 <quicksilver> lilac: eh?
07:29:41 <lilac> quicksilver: i guess i don't see the problem
07:29:46 <quicksilver> lilac: if you have two different fields, they are in general represented by data objects at different addresses.
07:29:55 <quicksilver> how can I make a single object out of that, whilst doing no work?
07:30:14 <lilac> your single object is a collection of two pointers, in the same way a normal newtype is a single pointer
07:30:31 <quicksilver> but that's not no work.
07:30:36 <lilac> why not?
07:30:38 <quicksilver> that's allocating two pointers and storing them.
07:30:59 <quicksilver> Given "newtype Foo = MkFoo Bar"
07:31:06 <lilac> i'm not allocating anything, any more than a normal newtype allocates its pointer
07:31:40 <quicksilver> OK, now I understand what you mean by 'not all elements are the same size'
07:32:05 <quicksilver> that's a deep and fundamental implementation obligation though
07:32:14 <quicksilver> I don't see how you could expect to design a calling convention for that kind of thing
07:32:26 <quicksilver> where sometimes "one object is two objects"
07:33:06 <lilac> suddenly the fog clears for me. polymorphism requires that all elements are the same size
07:33:18 <quicksilver> not just polymorphism
07:33:21 <quicksilver> (although, yes)
07:33:28 <lilac> one reason is enough ;-)
07:33:37 <lilac> the point of boxed representations is that they're uniform
07:33:37 <quicksilver> also, type erasure and parameter passing require it too
07:34:00 <quicksilver> right
07:34:01 <lilac> even for monomorphic parameters?
07:34:50 <quicksilver> no, you're right, for monomorphic parameters you can do what you like
07:34:54 <quicksilver> as long as you're consistent.
07:35:02 * quicksilver struggles to articulate what he was trying to get at
07:35:04 <lilac> but in that case the function itself needs to do auto boxing and unboxing
07:36:21 <lilac> ok, it would be a terrible idea to extend newtypes in that direction :)
07:36:44 <quicksilver> it would somehow be like having secret unboxed tuples in your language.
07:36:54 <quicksilver> GHC does have unboxed tuples, of course.
07:37:20 <lilac> if it weren't a kind error, newtype Foo = Foo (# Bar, Baz #) would be roughly what we're talking about, i think
07:39:22 <Phyx-> :r
07:39:23 <Phyx-> oops
07:40:22 <fasta> Is there a working fold derivation mechanism already?
07:44:53 <twanvl> fasta: deriving Foldable is in Ghc HEAD
07:51:02 <etpace_> @src foldl
07:51:03 <lambdabot> foldl f z []     = z
07:51:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:52:11 <fasta> twanvl: is it documented somewhere already? (saying _exactly_ what it does?)
07:55:38 <fasta> twanvl: never mind, I have seen your mail already.
08:00:11 * edwardk waves hello.
08:01:35 <Pure> Hi
08:03:07 <Pure> Where can I find a Haskell compatible text editor?
08:03:50 <osfameron> any programmer's text editor will do
08:04:23 <jpcooper> Pure, emacs with haskell-mode
08:04:26 <fasta> Pure: assuming you are on Windows, I would suggest you install Linux, but if you don't want that, just install the special Windows version of Emacs.
08:05:21 <fasta> If you don't want to learn Emacs, install Context, which has Haskell syntax high-lighting.
08:05:45 <osfameron> Context?
08:05:57 <fasta> And you can use VIM of course too, but I don't use that a lot for Haskell programming. But some do.
08:06:06 * osfameron uses vim
08:06:19 <fasta> osfameron: it's what was suggested we should use at university >5 years ago.
08:06:39 <osfameron> I suspect textpad, textmate, notepad+, jedit... i.e. any editor really will do just fine
08:06:41 <fasta> osfameron: of course I would have rather had them put Emacs through my throat, but I didn't know that back then.
08:06:55 <fasta> If you are really hardcore, ed ;)
08:06:58 <Baughn> Pure: All things considered, you may also want to keep http://learnyouahaskell.com/ handy.
08:07:04 <osfameron> gedit/kate that come with your default ubuntu install have pretty good syntax highlighting even
08:07:21 <fasta> Yes, most Windows users I know just use gedit on Ubuntu.
08:07:30 <fasta> (because they never learned to use Emacs)
08:07:34 * osfameron keeps meaning to sit and learn emacs at some point, but just doesn't like it
08:07:38 <edwardk> ed is more masochistic than hardcore these days ;)
08:07:48 <Pure> Reading
08:07:56 <osfameron> it also used to be annoying to setup on ubuntu (emacs I mean), something to do with the fonts.  I think that's all resolved now though
08:08:12 <fasta> osfameron: if you want to learn Emacs, the best thing you can do is read the O'Reilly book which covers writing major-modes too.
08:08:25 * edwardk does his haskell coding in vim/gvim
08:08:49 <fasta> osfameron: yes, my credo has been "install from CVS".
08:08:51 <osfameron> fasta: I started off doing the builtin tutorial.  It used to make me so angry that I tried it about 4 or 5 times and gave up every time :-(
08:09:06 <fasta> osfameron: yes, I still don't use the C-p key bindings.
08:09:08 <osfameron> eventually I did get through it.  It looks very powerful, and much more consistent than vim
08:09:13 <osfameron> but I don't "like" it :-)
08:10:00 <fasta> Imho, Emacs is too slow and could use better modes, but those are my only issues. The architecture is great.
08:10:02 <osfameron> ideally I want something with the scripting power of Emacs, and the usability of vim... I should really look at yi again at some point...
08:10:03 <roconnor> When I was learning Emacs the backspace key kept on bringing up Help.  Then I got someone to fix that, but I could no longer figure out how to get help.  ... Then I learned vi.
08:10:48 <osfameron> when I first learnt Emacs, I kept hanging the terminal.  Then I learnt about ^s (such a silly default for a modern terminal... should be disabled)
08:10:59 <roconnor> osfameron: ya, that too
08:11:16 <roconnor> trying to save was hell.
08:34:37 <Trinithis> what about yi?
08:36:05 <skorpan> what about it?
08:36:06 <Trinithis> are there good resources to learn config files for yi?
08:37:20 <fasta> Trinithis: you read the README file, the wiki page, then the documentation and finally and the source code, I think.
08:37:41 <Trinithis> ok
08:45:03 <Baughn> Pure: Don't be afraid to ask if you've any questions. We're very friendly.
08:45:14 * Baughn owns several copies of "To serve man".
08:51:34 <Pure> Is it pssible to make a TELNET server using Haskell?
08:51:47 <Baughn> @faq Can haskell be used for a Telnet server?
08:51:48 <lambdabot> The answer is: Yes! Haskell can do that.
08:52:10 <Baughn> Pure: ..it's a general-purpose programming language. There isn't much it can't be used for.
08:52:28 <Pure> Blowing stuff up?
08:52:42 <Berengal> Baughn, you can't curse at it for sucking
08:53:00 <Baughn> Berengal: I can. Trust me on this.
08:53:14 <pikhq> Pure: A Telnet server would probably come in at a hundred lines or so.
08:53:26 <Baughn> Pure: With the appropriate peripherals.
08:53:48 <Pure> Are there any docs anywhere?
08:53:52 <Berengal> Baughn, you are a demanding man. Me, I program in java for a living...
08:54:01 <pikhq> Yes. Haskell is very well documented.
08:54:13 <copumpkin> pikhq: not sure about that :P
08:54:19 <copumpkin> but it's pretty decent a lot of the time
08:54:28 <Baughn> Berengal: I'm also an author of an FRP implementation. With sufficient use of unsafePerformIO, there is plenty of need for cursing.
08:54:39 <Baughn> Pure: What docs are you looking for?
08:55:26 <Berengal> Baughn, perhaps refactoring FRP implementations into their own runtimes could work?
08:55:50 <Baughn> Berengal: But I don't want to write a new language! ;_:
08:55:53 <Baughn> I /like/ using haskell
08:56:07 <Berengal> Baughn, I mean, concurrency isn't implemented in a library using unsafePerformIO, it's built into the runtime
08:56:11 <Pure> Just some that tell me what functions there are and how to use them
08:56:24 <Berengal> You could still use haskell, but provide runtime support for some of the library functions
08:56:57 <Berengal> (I like to think of unsafePerformIO as unsafeExtendRuntime)
08:57:23 <Berengal> But what do I know, I haven't tried FRP much...
08:57:39 <quicksilver> Baughn: sure, but you weren't implementing it in haskell, then :)
08:58:04 <jmcarthur_work> i am of the opinion that we don't actually need unsafePerformIO to write decent FRP implementations, we just haven't discovered a good way yet
08:58:49 <Berengal> jmcarthur_work, I hope you're right, otherwise haskell could be considered less powerful than strict mutable languages
08:58:51 <jmcarthur_work> or, at the most, we might need a minor extension that is more generally useful than for just FRP or something
08:59:15 <jmcarthur_work> Berengal, well, of course, at the worst we could just write an interpreter
08:59:28 <Pure> Would it be easier to write in an imperitive language for things like a server?
08:59:28 <jmcarthur_work> efficiency is the only concern
08:59:41 <jmcarthur_work> Pure, certainly not! :)
09:00:18 <quicksilver> Baughn: you were implementing it in a fiddly and not entirely well understood impure language which is part of GHC.
09:00:19 <Baughn> Berengal: Not in the least. You can certainly write an unsafePerformIO implementation if /every function that touches it is in IO/.
09:00:30 <fasta> jmcarthur_work: did anyone write down what exactly it is that they want with FRP?
09:00:32 <Baughn> quicksilver: Yeah, I know. I should write some documentation based on what I discovered.
09:00:42 <Baughn> Berengal: Which is what they /always/ are, in other languages
09:00:54 <quicksilver> fasta: The moon on a stick. Preferably also a pony.
09:01:46 <fasta> I mean, how can you ever claim to have solved FRP, when there is no precise specification of what FRP is?
09:02:12 <fasta> It shouldn't be too hard to specify a language with the desired semantics. Implementing that language efficiently is then the FRP problem.
09:02:15 <quicksilver> sure, it's not really something you can solve in an absolute sense.
09:02:17 <Baughn> quicksilver: The moon is currently wriggling on my stick, and I've got half a pony.
09:02:27 <quicksilver> Baughn: half a pony is very messy :(
09:02:35 <badsheepy> depends on which half
09:02:39 <fasta> Right, so, it will keep people occupied forever. No wonder it is a "research" topic.
09:03:14 <Pure> Does emacs come with haskell support?
09:03:37 <Baughn> quicksilver: I noticed. ;_;
09:03:43 <Berengal> Pure, it has haskell support, but it might not come with it built in
09:04:04 <deech> Pure, http://www.haskell.org/haskell-mode/
09:04:05 <Baughn> Pure: That's a no. You want the CVS version of haskell-mode anyway.
09:04:10 <quicksilver> it comes built in to recent versions, although I prefer to use an alternative indentation mode
09:04:18 <fasta> Is there a way to do attribute grammar like things, while still being in Haskell and not writing manual folds?
09:04:25 * Berengal prefers yi to haskell-mode
09:04:43 <randomwords> I want to like yi
09:04:52 <jfoutz> me too.
09:04:53 <deech> Berengal: I'd like to use Yi, just don't know how.
09:04:57 <fasta> (of course there is a way, but I meant more like, is there a decent library)
09:05:21 <Berengal> deech, it's just like emacs (or vim, or cua)
09:05:30 <quicksilver> fasta: there is some stuff on the wiki but I don't know if it's any good.
09:05:33 <Berengal> But extensible in haskell
09:05:33 <Baughn> quicksilver: unsafeExtendRuntime isn't all bad the way I'm using it now. I'll see if I can figure out a safe packaging of this scheme.
09:05:43 <quicksilver> Baughn: sure, it's not all bad at all.
09:05:47 <quicksilver> Baughn: you just need to understnad it.
09:05:54 <randomwords> yi has good potential but I end up missing my plugins
09:06:02 <Baughn> quicksilver: ..and it isn't explained anywhere.
09:06:05 <Baughn> Except #ghc
09:06:07 <deech> But the M-x commands are all different. And no 'describe-mode' or 'info' so without docs, I'm out of luck.
09:06:40 <Berengal> deech, yes, the built-in docs are not there :/ It's a hurdle, I admitt, but I've become used to it. Took me about a day...
09:07:07 <Berengal> It's also nice to be able to write a short type-inference plugin in an hour without bothering with elisp
09:07:27 <deech> Berengal: Can you write something on what Yi provides for Haskell programming?
09:09:41 <randomwords> Yeah - the more written about yi the better
09:10:43 <fasta> It provides that it doesn't cabal install with ghc-6.10.2.
09:10:47 <deech> randomwords: yeah, what I want to know is specifically if 'describe-mode' existed in Yi, I was editing a haskell file in Yi and invoked 'describe-mode', what would it tell me.
09:13:35 <Nafai> The problem with Yi compared to Emacs is that it is not (as far as I'm aware) self-documenting.
09:13:47 <Nafai> I can't do describe-mode, describe-function, describe-key
09:15:45 <deech> Nafai: This maybe more difficult to implement that it sounds. In Lisp it is very easy to write a function to parse another function's definition and pick up doc-strings etc. In Haskell this seems much more involved.
09:17:05 <Nafai> deech: Yeah, I figured as much.
09:17:23 <Nafai> I've actually been doing a lot of elisp programming lately and having those things is really really helpful
09:17:57 <doublethink_work> @hackage uuagc
09:17:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuagc
09:18:01 <doublethink_work> fasta: ^^
09:18:02 <doublethink_work> ?
09:18:22 <mightybyte> Does cabal/cabal install have a way to use a local mirror of hackage (for when you're on an isolated network)?
09:18:46 <doublethink_work> mightybyte: check ~/.cabal/config
09:19:01 <quicksilver> deech: but you wouldn't do it that way.
09:19:13 <quicksilver> deech: a "Yi" command would not be merely a function
09:19:16 <randomwords> I wish yi had a way of someone using vimballs
09:19:27 <randomwords> s/someone/somehow
09:19:28 <quicksilver> deech: it would be data Command = Command DocString Implementation OtherStuff
09:19:53 <Nafai> It would be interesting, though, to try to re-implement the stuff I'm writing now in Emacs Lisp on top of Yi and see how it compares
09:20:27 <mightybyte> doublethink_work: I found the local repo option and set it, but it says I'm missing a package list.
09:20:42 <jfoutz> yi chose to avoid coupling docs with implementations. it is possible to grab the haddoc documentation out of yi's implementations.
09:21:18 <quicksilver> jfoutz: but in an extensible editor, you really want the documentation of all internal functions/variables introspectable from the editor
09:21:27 <mightybyte> doublethink_work: I downloaded archive.tar, but I haven't found a package list file anywhere.
09:21:27 <quicksilver> jfoutz: that's clearly one of the best things about emacs.
09:21:38 <Nafai> quicksilver: Indeed.
09:21:48 <quicksilver> (and you want people who write new functions/commands/variables to have a canonical place to put the docs for what they write)
09:21:51 <dcoutts> mightybyte: there's a couple things you can do, you can cabal fetch the packages you think you'll need later, or you can make a local repo (in the appropriate format)
09:21:58 <quicksilver> jfoutz: if that uses haddock as a mechanism, that seems fine.
09:22:08 <quicksilver> but it has to be automated + ubiquitous, however it works.
09:22:45 <gwern> > replicateM "YHVH"
09:22:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:23:00 <jfoutz> quicksilver: i think the whole hconf restart trick should probly be swiched to the GHC package. yi is very cool, but it seems like there are some underlying things that make it hard to deal with.
09:23:15 * quicksilver watches on in horror as a bolt of lightning fries gwern where he stands.
09:23:25 <mightybyte> dcoutts: Well, I've got all the packages from the archive.tar.  How do I create the local repo?
09:23:46 <gwern> quicksilver: the lightning will come as soon as my blasphemy typechecks
09:23:47 <dcoutts> mightybyte: the remote and local repo formats are the same
09:23:59 <gwern> jfoutz: the hconf stuff got split out to dyre
09:24:02 <dcoutts> mightybyte: in particular they need the index
09:24:49 <Nafai> quicksilver: Agreed about the automated + ubiquitous
09:24:59 <jfoutz> gwern: oh, cool.
09:25:07 <doublethink_work> jfoutz: yi uses dyre now, not hconf. hooking into the GHC API is an option but it's harder to maintain over time
09:25:21 <doublethink_work> the restart trick with dyre, in the same way xmonad does it, really is a neat solution IMO
09:25:32 <gwern> which is why people should use hint instead of ghc api direct
09:25:41 <gwern> centralize the removing-sharp-edges bit
09:26:18 <doublethink_work> hint is quite nice
09:26:20 <Nafai> hint looks nice
09:26:28 * doublethink_work contributed a patch for ghc 6.11 annotations
09:27:29 <Pure> Do I need to put module in my code?
09:27:39 <Pure> If so, before or after imports?
09:27:51 <randomwords> no and before
09:28:44 <luite> is there a pure functional vector graphics library that could be used (possibly after some modification) to output SVG? (besides hieroglyph, which depends on hs2gtk, which I still have not been able to build)?
09:29:14 <quicksilver> not that I know of, luite
09:29:24 <saml> > printf "<svg>%s</svg>" "<curve/>" :: String
09:29:26 <lambdabot>   "<svg><curve/></svg>"
09:29:32 <luite> hehe
09:30:08 <quicksilver> a simple SVG generator would be pretty simple though
09:30:19 <luite> saml: that's a fairly minimalist approach to such a libray :p
09:30:53 <quicksilver> http://www.lisperati.com/haskell/
09:30:57 <quicksilver> generates svg iIRC
09:31:09 <Pure> Does main automaticly execute?
09:31:43 <quicksilver> in compiled programs, yes
09:32:14 <Pure> Not in interppreted?
09:32:37 <saml> Pure, it does i think. via runhaskell
09:32:49 <saml> it automatically executes main
09:32:53 <Pure> Or I could stop being lazy and type main
09:33:57 <luite> quicksilver: that's true, but I'd something like hieroglyph can also render graphics to png files or gtk windows, possibly with interactivity. I'd like to have something that can do both, interactive gfx in a window, and a pure part that can be run separately to generate static vector graphics
09:35:06 <dschoepe> Just to check that I understand this correctly: Is the second part of the exercise here(http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category ) not a category, because "f · (g · h) = (f · g) · h" simplifies to "f · id_a = id_b · h" and f and h aren't necessarily equal?
09:35:11 <luite> I'm waiting for about the 20st build of gtk2hs today, it's getting a bit frustrating, so I wanted to explore other options in the meantime
09:35:59 <luite> especially since builds on windows are so slow
09:36:17 <Phillemann> What's the syntax again for nesting records? I mean like in "data Foo = Foo { bar :: { baz :: String, qux :: Int } }"
09:36:31 <luite> oh the build failed
09:36:33 <luite> great
09:37:58 <Athas> Don't you need to define the inner record as its own type, Phillemann?
09:38:18 <Phillemann> Athas: Well, I don't know. :>
09:38:19 <lilac> gwern: it's ok, they fixed the lightning bug in later releases based on the NT kernel
09:38:36 <EvilTerran> Phillemann, you can't, each record field must be associated with a datatype
09:39:13 <Phillemann> EvilTerran: And I cannot define the data type "on the fly"? Well, okay then.
09:39:26 <EvilTerran> afraid not
09:39:36 <Athas> It would be an anonymous type... that would be very hard to work with.
09:39:48 <Athas> Haskell records are just syntactic sugar anyway, aren't they?
09:39:54 <EvilTerran> no-one seems to like the existing record system, but we can't seem to agree on anything better
09:40:11 <Phillemann> Athas: They're not really sugar to me.
09:40:20 <Athas> Phillemann: how do you mean?
09:40:44 <Phillemann> There should be some kind of namespacing mechanism, so I don't have to prefix the "getter functions".
09:40:57 <Athas> You don't.
09:41:16 <Athas> You just give them their name.
09:41:24 <Phillemann> Well, I don't have to, but I have to except name clashes then.
09:41:43 <Phillemann> except = expect.
09:42:24 <skorpan> what was the flag to ghc to show the minimal set of imports needed?
09:42:25 <Athas> Indeed, but you should try it out.  It may be a lesser problem than you expect.
09:42:46 <Athas> I used to fret endlessly about intra-module name clashes, but they almost never happen, and are easy to fix anyway.
09:42:46 <doublethink_work> skorpan: ghc -ddump-minimal-imports i think
09:42:57 <doublethink_work> Athas: truth
09:42:59 <skorpan> thanks
09:44:35 <lilac> dschoepe: yes, that's right (if f and h were equal, we wouldn't have added a new morphism)
09:46:40 <lilac> dschoepe: except that g . h = id_b and f . g = id_a :)
09:47:08 <Pure> Can I set the type of a channel to a list?
09:47:58 <lilac> lists are first-class like any other type, so i would imagine so. do you mean a Chan?
09:48:09 <Pure> Yes
09:48:31 <Pure> I.e. Control.Concurrent.Chan
09:48:53 <_Ray_> Hey, question. On haskell.org I see this image: http://www.haskell.org/sitewiki/images/4/47/SubEthaEdit.png . Does anyone know where to get this color scheme for Haskell under SubEthaEdit? I haven't been able to find it. Looks like Zenburn?
09:49:38 <lilac> Pure: then yes, you can have a "Chan a" for any type "a" including a list of some other type
09:50:01 <Pure> [String, String]?
09:50:07 <lilac> that's not a type
09:50:24 <EvilTerran> Pure, [...] at the type-level only takes a single parameter
09:50:26 <lilac> the [] type constructor takes a single type. perhaps you want [ (String,String) ] ?
09:50:30 <Pure> Would you mind enlightening me
09:50:33 <Pure> Oh right
09:51:04 <EvilTerran> > ([1,2,3] :: [Int]) == (1 : 2 : 3 : [] :: [] Int)  -- sugary on the left, desugared on the right
09:51:06 <lambdabot>   True
09:51:10 <EvilTerran> Pure, ^
09:51:41 <monochrom> Syntax is sugar.
09:51:56 <lilac> be aware of the unfortunate asymmetry here. "[] Int" is the same as "[Int]" but "[] 42" is not the same as "[42]"
09:52:00 <pikhq> EvilTerran: I OBJECT! ... [] is still special syntax! ... I'm not sure where I'm going with this.
09:52:22 <EvilTerran> monochrom, pikhq - i mean, the right is less sweetened than the left. pedants.
09:52:25 <monochrom> [] is special syntax but irreducible.
09:52:46 <pikhq> And (:) is the constructor, rather than, say, [].
09:53:09 <monochrom> I am not a pedant. I am not objecting. I am just making a passer-by remark that all syntax is sugar. All.
09:53:22 <EvilTerran> monochrom, sorry, i forgot my ;)
09:53:24 <lilac> > ([1,2,3] :: [Int]) == ((:) 1 ((:) 2 ((:) 3 [])) :: [] Int) -- even less sugar on the right, woo
09:53:25 <lambdabot>   True
09:54:05 <pikhq> lilac: Looks a lot like Core.
09:54:30 <monochrom> Syntax is sugar. Semantics is syntax. Sugar is illusion. <-- party line of my party!
09:55:42 <lilac> pikhq: add in a few type lambdas and I#s and i think it's there
09:57:21 * copumpkin wants easy type lambdas
09:58:10 <lilac> > GHC.Exts.I# 42#
09:58:12 <lambdabot>   Not in scope: data constructor `GHC.Exts.I#'
09:59:11 <jfoutz> monochrom: i'm reading the denotational sematics wiki article right now. don't you have to pick something to be the object you are representing?
09:59:58 <monochrom> Yes. You pick another syntax.
10:00:50 <monochrom> Suppose you pick "sets" to be your semantic domain. What is "sets" and how is it defined? Axiomatic formalized set theory is yet another syntax.
10:01:13 <monochrom> Unaxiomatic unformalized set theory is out of the question.
10:02:51 <monochrom> But Platonists disagree. Platonists axiomatize that there is unaxiomatic unformalized set theory in the ideal, and the axiomatic formalized version is just a partial story.
10:04:35 <kiris> are C pointers monoids?
10:05:05 <monochrom> No. Combining two pointers doesn't give a pointer.
10:05:19 <monochrom> At least when I'm a pedant.
10:05:26 <jfoutz> monochrom: hrm. I think you're saying all this is is mapping syntax to syntax, and there's nothing ... what were the axioms? primal? a priori?
10:05:41 <jfoutz> given.
10:06:13 <kiris> oh yeah. ptr + ptr is probably undefined
10:06:21 <monochrom> Axioms are invented. Some to model the world. Some to satisfy curiosity.
10:09:51 <hackagebot> bindings-common 0.2.5 - Macros and modules to facilitate writing library bindings. (MauricioAntunes)
10:14:53 <hackagebot> OpenCLRaw 1.0.1000 - The OpenCL Standard for heterogenous data-parallel computing (JeffersonHeard)
10:16:02 <luite> hm, haskell.org down?
10:16:22 <jfoutz> monochrom: are you saying no axioms without syntax? (not trying to be dense, this is just a new way of looking at things)
10:16:29 <kiris> luite: not responding for me
10:16:38 <jeffheard_home> Alrighty folks.  OpenCL is out
10:16:58 <jeffheard_home> OpenCL Raw that is.  I'm working on an API similar to Sven's other Open* APIs
10:17:04 <kiris> http://downforeveryoneorjustme.com/haskell.org
10:17:51 <jeffheard_home> The documentation license kind of sucks, though.  The one that Kronos group puts out.  I basically have to direct everyone to the spec.
10:18:36 <jfoutz> monochrom: might be better if you tell me to just go read X than try to explain.
10:18:44 <jeffheard_home> kiris: wow, what a useful site for OCD ppl like me
10:20:07 <luite> kiris: ah, useful site :p
10:21:22 <lilac> this code is making my machine swap like crazy, what have i done wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8266
10:22:05 <edwardk> jeffersonheard: hrmm opencl bindings?
10:22:55 <jeffheard_home> edwardk: Yes, indeed
10:23:05 <edwardk> how usable are the raw bindings?
10:23:27 <jeffheard_home> About as usable I'd suspect as the OpenGLRaw bindings.
10:23:30 <edwardk> Apple only?
10:23:32 <jeffheard_home> To be specific
10:23:33 <jeffheard_home> no
10:23:35 <jeffheard_home> not apple only
10:23:41 <jeffheard_home> it's based directly on the header
10:23:44 <jeffheard_home> but doesn't require it.
10:23:50 <edwardk> nice
10:23:55 <jeffheard_home> nVidia has beta drivers for OpenCL
10:24:01 * lilac rewrites in python ;-(
10:24:06 <edwardk> yeah that was why i inquired =)
10:24:06 <jeffheard_home> AMD has production-ready drivers in OpenCL
10:24:12 <jeffheard_home> lilac, I'm sorry.  I can't see it
10:24:26 <arjanb> lilac: probably some + is evaluated lazy and building up a big expression in memory
10:24:27 <jeffheard_home> why is my ghost appearing and disappearing in the chatroom I wonder...
10:24:49 <jeffheard_home> edwardk: The raw bindings aren't completely raw, btw
10:24:54 <jeffheard_home> all the constants are wrapped in newtypes
10:25:15 <jeffheard_home> and return types etierh return an Either or Maybe value depending on whether or not they're supposed to return a value when called
10:25:25 <edwardk> jeffheard_home: i can live with that
10:25:41 <jeffheard_home> allocation of temporaries is handled by the bindings as well
10:26:05 <dschoepe> lilac: thanks
10:26:21 <jeffheard_home> I can't guarantee them yet; they're not well tested, but they're being actively developed, and as well as I could proofread and test initially I have.  I know that i can create a context and a memory object and a kernel
10:26:23 <jeffheard_home> and run them
10:26:23 <edwardk> jeffheard_home: my main concern is that it doesn't asymptotically destroy you like, say, the shader support in HOpenGL
10:26:49 <jeffheard_home> edwardk: Haven't tried the shader support in HOpenGL.  why does it asymptotically destroy you?
10:26:58 <lilac> arjanb: i thought that too, but the recursive call is only passing the tail of the input data and two strict ints, so there's not really anywhere for a big thunk to hide
10:27:22 <edwardk> jeffheard_home:you can't just allocate one, it deals with lists of these things internally on its own and differences them by hand, etc. to export a cleaner api
10:27:49 <edwardk> when you need a bunch of shaders and have a better way to track their ids then it is just wasting your time on busy work
10:28:24 <arjanb> lilac: right, so time to look at the generated core
10:28:41 <lilac> arjanb: it made my eyes hurt ;-)
10:29:07 <jeffheard_home> edwardk: ahhh no.  the whole genObjects thing?  No, I expose the OpenCL reference counting stuff in OpenCLRaw.  The temps i'm referring to are specifically things like pointers to handles that are returned and such like that
10:29:14 <edwardk> given that all i was going to use HOpenGL for was access to shaders... ;)
10:31:35 <arjanb> lilac: you can get used to it after a while, can you add it to the paste?
10:31:41 <lilac> arjanb: sure thing
10:31:53 <edwardk> attachedShaders, getAttachedShaders, setAttachedShaders, its all a mess there
10:32:54 <edwardk> setAttachedShaders is the one that basically made me put the library down
10:33:26 <edwardk> http://hackage.haskell.org/packages/archive/OpenGL/2.3.0.0/doc/html/src/Graphics-Rendering-OpenGL-GL-Shaders.html#setAttachedShaders
10:33:34 <lilac> arjanb: the core is here: http://metafoo.co.uk/tmp.html
10:34:35 <lilac> i don't think it's thunk building; there are only 3 let-bound vars and they're all functions
10:34:52 <lilac> running it with "+RTS -M50M", it runs out of heap
10:35:38 <lilac> (the input file is 29MB, but it should be constant-space so that's not excuse)
10:37:21 <arjanb> it looks like it's using Integer
10:38:31 <mmorrow> lilac: i think `interact' is your problem, since "process (cycle "asdf")" runs fine in ghci
10:38:46 <lilac> @src interact
10:38:47 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:39:14 <lilac> inserting a 'trace' anywhere fixes it
10:40:46 <jeffheard_home> I would suspect putStr there
10:41:27 <jeffheard_home> ow.  edwardk, I see the problem there.
10:41:39 <jeffheard_home> I promise not to do that in my final "cooked" bindings
10:41:47 <edwardk> jeffheard_home: much obliged =)
10:42:22 <edwardk> i really should email sven and point out that the current way of handling it really hurts certain usage patterns
10:42:46 <lilac> changing the RHS of the 'go (x:xs) ...' line to ' | k `mod` 1000 == 0 = <old RHS> | otherwise = <old RHS>' fixes it
10:42:51 <mmorrow> lilac: ghci> putStr . process =<< readFile "/dev/urandom" -- runs fine too
10:43:04 <mmorrow> lilac: are you compiling with -O2 ?
10:43:08 <lilac> mmorrow: yes
10:43:18 <mmorrow> weird
10:44:56 <arjanb> a bug in the optimizer maybe?
10:45:15 <jeffheard_home> I'm actaully kind of tempted, honestly, because of some of the research that our HPC director's doing, to bind MPI as well and put the two together into one heterogenous computing library...
10:46:15 <lilac> arjanb: good thought. if i remove -O2, the problem goes away
10:46:25 <Cale> Yeah, it must be something the optimiser is doing
10:47:05 <eevar_> there's no amd64-build of ghc for windows?
10:48:02 <mmorrow> lilac, arjanb: ah, it looks like it's because it's using Integer and just building up massive Integers
10:48:34 <mmorrow> because just adding a (k::Int) to the RHS of one of the cases makes it run in constant space
10:48:49 <Cale> My guess is that something is being floated up which really should not be.
10:49:01 <mmorrow> so maybe !k on an Integer isn't working correctly
10:49:12 <Cale> mmorrow: oh? Interesting.
10:49:22 <mmorrow> (that, or the Integers are just getting ginormous)
10:49:29 <mmorrow> whereas Int wraps
10:49:50 <mmorrow> but >1GB Integers?!?
10:49:59 <c_wraith> Yeah, that shouldn't happen. :)
10:50:02 <lilac> mmorrow: n is at most 10000, k is at most length xs
10:50:03 <Cale> Let's do a little tracing
10:51:17 <mmorrow> lilac: i'm going "./Foo < /dev/urandom"
10:52:22 <lilac> go (x:xs) !n !k = go xs 0 (n+k+1)
10:52:27 <lilac> ^^ minimal failing testcase
10:52:48 <Cale> k doesn't appear to be growing very quickly.
10:53:10 <mmorrow> go (x:xs) !n = go xs (n+1) -- wouldn't this be minimal?
10:53:14 * mmorrow tries
10:53:16 <lilac> mmorrow: no, that works
10:53:29 <mmorrow> hrm
10:55:32 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8268#a8268 <-- core of that 'go'
10:56:02 <lilac> why are there two case analyses matching '0'?
10:56:42 <Cale> Wow, that's odd. Compiling with -prof -auto-all appears to make the space leak disappear
10:58:01 <Cale> hmm
10:58:12 <lilac> looks like it's specialized it for the case where n is 0
11:00:02 <dschoepe> Is there a way of proving "join . fmap join = join . join" for Maybe, besides demonstrating it for every possible input(Nothing, Just Nothing,...)?
11:00:26 <Cale> dschoepe: You do a case analysis.
11:00:53 <Cale> (you must do a case analysis somewhere, because that's how join and fmap are defined)
11:01:46 <lilac> dschoepe: LHS is Nothing iff (...), RHS is Nothing iff (...), if LHS and RHS are both Just then they must be equal because (...)
11:02:23 <dschoepe> Cale, lilac: thanks
11:03:31 <Cale> join Nothing = Nothing -- join.1
11:03:37 <Cale> join (Just x) = x -- join.2
11:03:46 <hehee> If I have a pure function, is it possible to feed into its variable the result of an openFile?
11:03:48 <Cale> fmap f Nothing = Nothing -- fmap.1
11:03:58 <Cale> fmap f (Just x) = Just (f x) -- fmap.2
11:04:18 <lilac> hehee: yes, using fmap. but you won't get a pure result.
11:04:23 <Cale> (join . fmap join) Nothing = join (fmap join Nothing) -- composition
11:04:42 <Cale> = join Nothing -- fmap.1
11:04:50 <Cale> = Nothing -- join.1
11:05:01 <hehee> lilac: Is there any way to open a file of, say, IPs and sent the list of them to a pure function and get a pure result?
11:05:44 <Cale> (join . join) Nothing = join (join Nothing) -- composition
11:05:47 <sbahra> hehee, yes.
11:05:50 <lilac> hehee: your overall action involves IO, so the result must live in the IO monad.
11:05:53 <Cale> = join Nothing -- join.1
11:05:56 <Cale> = Nothing -- join.1
11:05:59 <sbahra> hehee, final result will not be pure, though.
11:06:27 <dschoepe> Cale: Thanks, that's the way I did it, then repeated it for Just Nothing, and the other possibilities. I just wanted to see whether there's another way.
11:06:44 <Cale> dschoepe: Yeah, it'll be Just Nothing and then Just (Just x)
11:06:55 <lilac> @type fmap ?someProcessing (readFile "list-of-IPs")
11:06:57 <lambdabot> forall b. (?someProcessing::String -> b) => IO b
11:07:15 <dschoepe> Cale: wouldn't it be 3 layers? So Just (Just (Just x)) as the last case?
11:07:20 <hehee> Ah, should work just fine.
11:07:27 <mmorrow> lilac: i'd make a ticket, something weird is definitely happening
11:07:30 <Cale> dschoepe: hmm
11:07:37 <dschoepe> @type join . join
11:07:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
11:07:57 <nainaide> How to write UTF-8 String to file, please?
11:08:08 <Cale> dschoepe: ah, yes, that's right
11:08:24 <mmorrow> @hoogle hPutString
11:08:25 <lambdabot> No results found
11:08:29 <mmorrow> @hoogle hPutStr
11:08:30 <lambdabot> Data.ByteString hPutStr :: Handle -> ByteString -> IO ()
11:08:30 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
11:08:30 <lambdabot> Data.ByteString.Char8 hPutStr :: Handle -> ByteString -> IO ()
11:08:37 <mmorrow> argh
11:08:41 <lilac> dschoepe: i'd do it like this: LHS is Just x iff argument is Just (Just (Just x)), RHS is Just x iff argument is Just (Just (Just x)). otherwise, LHS and RHS are both _|_ if the value is partial. otherwise, LHS and RHS are both Nothing
11:08:53 <mmorrow> nainaide: there's a package utf8-string
11:09:05 <mmorrow> nainaide: that has the functions you need
11:09:13 <lilac> dschoepe: that way around there's only really 3 cases to consider, rather than 27
11:09:19 <dschoepe> lilac: Thanks.
11:09:31 <lilac> 27? 7, i think :-/
11:09:40 <dschoepe> wouldn't be just 4?
11:09:42 <mmorrow> nainaide: (they just utf8-encode the strings first)
11:09:42 <lilac> 10?
11:09:52 <mmorrow> , utf8enc "\x2200"
11:09:54 <lunabot>  "\226\136\128"
11:09:56 <hehee> Seems fmap takes tuples and my function takes lists
11:09:59 <mmorrow> , text (utf8enc "\x2200")
11:10:00 <lunabot>  ∀
11:10:06 <dschoepe> Nothing, Just Nothing, Just (Just Nothing), Just (Just (Just x))
11:10:16 <mmorrow> utf8snowmen!
11:10:16 <lilac> _|_, N, J _|_, J N, J J _|_, J J N, J J J x
11:10:34 <dschoepe> ah, bottom, okay
11:10:38 <mmorrow> , text (utf8enc "☃")
11:10:38 <shachaf> lilac: J J J _|_?
11:10:39 <lunabot>  ☃
11:10:44 <nainaide>  mmorrow , Can I just hPutStrLn  utf8enc "\x2200" ?
11:10:52 <lilac> shachaf: that's part of the general J J J x case
11:11:08 <mmorrow> nainaide: you can do that too, yes. that's all the utf8-string package is doing
11:11:26 <nainaide> thanks, will try now.
11:12:05 <mmorrow> nainaide: the utf8enc/other misc functions lunabot's using are in http://moonpatio.com/repos/lunabot/Luna/Bot/Util/UTF8.hs
11:12:15 <mmorrow> if you want to do it yourself
11:13:33 <nainaide> mmorrow,  what is the UTF8.hs for ?
11:13:42 <hehee> ugh, I can't figure this IO out.
11:14:01 <mmorrow> nainaide: what do you mean? that's the module that lunabot uses
11:14:05 <hehee> I'm now gettign it to compile with my function in main, but the program produces no output.
11:14:10 <mmorrow> , utf8enc "\x2200"
11:14:11 <lunabot>  "\226\136\128"
11:14:18 <mmorrow> utf8enc is in that module
11:14:22 <hehee> fmap seems to work, but I'm not getting a thing output.
11:14:36 <nainaide> mmorrow, I see. :)
11:14:39 <mmorrow> :)
11:15:13 <hehee> Shouldn't this 'fmap encode (readFile "data.txt")' give me the result of 'encode'?
11:15:53 <edwardk> hehee: as a value in IO, yes
11:16:21 <hehee> How do I see the output? Can I put it into a textfile or onto the screen?
11:16:22 <lilac> hehee: it gives you, in some sense, a value representing a computation which produces the value of 'encode' after reading a file
11:16:36 <edwardk> hehee: what is the type of encode?
11:16:41 <lilac> hehee: you'll need either (>>=) or do-notation for that
11:16:41 <edwardk> @type encode
11:16:43 <lambdabot> Not in scope: `encode'
11:17:10 <Cale> hehee: You need to connect that up with another IO action for printing to the screen or writing to a file.
11:17:14 <hehee> [a] -> [(int, char)]
11:17:38 <Cale> hehee: do x <- fmap encode (readFile "data.txt"); print x
11:17:53 <edwardk> hehee: main = do x <- fmap enco... er.. copy cale ;)
11:18:01 <Cale> hehee: Or:   fmap encode (readFile "data.txt") >>= print
11:18:14 <Cale> Or if you prefer:  print =<< fmap encode (readFile "data.txt")
11:18:27 <Cale> These are all the same thing
11:18:27 <lilac> Or: do x <- readFile "data.txt"; print (encode x)
11:18:40 <Cale> Indeed
11:19:30 <pikhq> Or: print <<= encode <$> readFile "data.txt"
11:19:34 <pikhq> MOAR OPERATORS
11:19:41 <hehee> Alright, thanks guys. I get output, and now I need to fix my function!
11:19:42 <Cale> hmm <<= ?
11:19:59 <pikhq> ...
11:20:00 <Baughn> =<<
11:20:05 <pikhq> =<<.
11:20:07 <lilac> or: (print <$>>=<>) encode readFile "data.txt"
11:20:14 <lilac> i may have made that operator up
11:20:15 <mmorrow> :o
11:20:17 <Cale> ahaha
11:20:24 <pikhq> lilac: IS A FISHY
11:20:39 <Cale> Any sufficiently long string of operator symbols looks like a fish.
11:20:50 <monochrom> Like ++++++
11:20:55 <hehee> As much as I hate the IO method in haskell now, I can see being really nice once I figure it out.
11:21:07 <edwardk> cale: i'll start calling that Cale's Lemma. ;)
11:21:08 <jeffheard_home> (print *-_-*-_-*-_-*-------) encode readfile "data.txt"
11:21:19 <lilac> (<$>><>) :: Monad m => (a -> m b) -> (c -> a) -> (d -> m c) -> d -> m b
11:21:19 <jeffheard_home> my program flatlined...
11:21:23 <mmorrow> , let (----------------------------------+) = (*) in 3 ----------------------------------+ 5
11:21:25 <lunabot>  15
11:21:26 <Baughn> Or: (readFile >=> encode) "data.txt" >>= print
11:21:35 <edwardk> @remember Cale's Lemma: Any sufficiently long string of operator symbols looks like a fish.
11:21:36 <lambdabot> Good to know.
11:22:03 <Cale> hehee: Right. It is nice, particularly because IO actions are first class values that you can pass around and manipulate using functions you write yourself. This gives you the ability to add any new control structures you might need on your own without relying on the language providing them for you.
11:22:26 <Cale> hehee: Control.Monad has many common control structures already
11:22:40 <pikhq> hehee: We're just playing with said control structures ATM.
11:22:44 <Cale> hehee: For example, mapM/forM give you what is essentially a for-each loop.
11:22:47 <Baughn> hehee: Or, as they say, it's like having the ability to overload semicolon. :P
11:23:00 <hehee> heh
11:23:09 <Cale> Baughn: That's a whole other dimension of the abstraction though...
11:23:23 <Cale> I'm just talking about the IO combinator library alone for now :)
11:23:23 <edwardk> Baughn: Usually it just succeeds in overloading the programmer
11:23:27 <Baughn> We also have first-class semicolons. :3
11:24:28 <olsner> although, as with all other "Monads are <foo>" statements, that's only one of many ways to view them
11:24:29 <Cale> hehee: It turns out that a certain pattern into which combining IO actions fits is one that many other libraries fit into as well.
11:24:46 <edwardk> Baughn: clearly they are second class and inferior since i can't use the ; for my comonad sugar ;)
11:25:14 <lilac> @type let (<$>>=<>) f i s h = (f.i)=<<s h in (<$>>=<>)
11:25:15 <lambdabot> forall b (m :: * -> *) b1 a t. (Monad m) => (b -> m b1) -> (a -> b) -> (t -> m a) -> t -> m b1
11:25:35 <Cale> hehee: We give that pattern a name (Monad) so that any library which can implement return and (>>=) in a way which is sensible becomes a monad, and this lets us reuse all the stuff which is written in terms of those functions (mostly control-structure-like things)
11:26:09 <Cale> So, for instance, forM, which is a for-each loop in IO, can be put to use in a parsing library to give the concatenation of appropriately constructed parsers
11:26:47 <Cale> (or sequence, which turns a list of IO actions into a single IO action which performs them all just becomes plain concatenation)
11:28:30 <Cale> (Like most programming abstractions, monads are just another way to reuse code effectively)
11:31:06 <Cale> http://cheese.blartwendo.com/web21-demo.html -- ahaha
11:32:19 <sbahra> Cale, :)
11:38:20 <Cale> "An easy way of checking whether your browser is standards compliant is to check whether the installation files for your browser were smaller than 50MB, or the run-time memory usage is less than 300MB. If this is the case, you should download a more recent browser to get the full Web 2.1 experience."
11:39:07 <Makoryu> @hoogle t -> [t] -> Bool
11:39:08 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:39:08 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:39:08 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:39:12 <Makoryu> Ah, d'oh
11:40:13 <lilac> @type (((<2).length).).(:)
11:40:15 <lambdabot> forall a. a -> [a] -> Bool
11:42:33 <hehee> Is there any way I can import a file in haskell as just one list?
11:43:00 <lilac> hehee: what's the format of the file?
11:43:09 <hehee> tried dos/unix txt
11:43:16 <hehee> has 1 ip per line
11:43:30 <hehee> also tried to format the entire thing like 1 haskell list.
11:43:31 <lilac> hehee: read the file, then apply 'lines' to it
11:44:14 <Gilly> :t readFile
11:44:15 <lambdabot> FilePath -> IO String
11:44:42 <hehee> ah
11:45:24 <hehee> works in ghci
11:45:50 <hehee> Okay, so I have 'fmap lines ("data.txt")' and I need to apply my function to its output
11:46:19 <hehee> can I just do 'fmap encode $ fmap lines ("data.txt")'?
11:46:20 <edwardk> hehee: doe syour function take one ip or all of them?
11:46:24 <hehee> all
11:46:28 <hehee> and makes a list
11:46:33 <hehee> 1 ip per element
11:46:35 <edwardk> hehee: then you have it
11:46:36 <lilac> hehee: that should be "fmap lines (readFile "data.txt")"
11:47:04 <hehee> lilac: err yeah, I need to apply my enocde function to that list of ip's now.
11:47:18 <edwardk> or you can: fmap (encode . lines) (readFile "data.txt')
11:47:55 <edwardk> encode <$> lines <$> readFile "data.txt" might be more legible though
11:48:24 <mm_freak> fmap (read . lines) readEntireFile
11:48:31 <nainaide> mmorrow, what is utf8dec for ? can you give me a demo ? thanks
11:48:48 <nainaide> btw utf8enc works well for me
11:49:33 <hehee> hah! It worked
11:49:37 <hehee> quick too
11:49:45 <Cale> hehee: fmap encode . fmap lines = fmap (encode . lines)
11:50:16 <hehee> whew, function construction still makes my head spin.
11:51:53 <Cale> Well, if it helps any, that could also be written  fmap encode (fmap lines x) = fmap (\v -> encode (lines v)) x
11:52:56 <hehee> Cale: That's how I usually picture functions in my head, comming from lisp
11:57:31 <Philonous> Given "newtype Dual tag a = Tower [a]" how does "bundle x0 (Tower xs) = toTower (x0:xs)" 'force its second argument's structure', but "toTower (x0:fromTower x')" where "fromTower (Tower xs) = xs" does not? This is bunk, is it not?
11:57:32 <lambdabot> Philonous: You have 1 new message. '/msg lambdabot @messages' to read it.
11:58:42 <mmorrow> , "☃"
11:58:44 <lunabot>  "\9731"
11:58:48 <mmorrow> , utf8enc "☃"
11:58:49 <lunabot>  "\226\152\131"
11:59:00 <mmorrow> , utf8dec "\226\152\131"
11:59:01 <lunabot>  "\9731"
11:59:22 <mmorrow> , (utf8dec . utf8enc) "☃" == "☃"
11:59:23 <lunabot>  True
11:59:31 <mmorrow> , "☃" == "\9731"
11:59:32 <lunabot>  True
11:59:47 <ones> In the language shootout what's the difference between "CPU secs" and "Elapsed secs"?
12:00:05 <pikhq> @check (utf8dec . utf8enc) == id
12:00:06 <lambdabot>   Not in scope: `utf8dec'Not in scope: `utf8enc'
12:00:15 <ivanm> ones: I would guess that CPU secs == how much time was actually spent on the app
12:00:24 <ivanm> as opposed to other programs that might be running
12:00:46 <jmcarthur_work> also not counting syscalls, i bet
12:00:47 <ones> no, elapsed secs is usually smaller than cpu secs
12:00:54 <mauke> preflex: zdec z2603U
12:00:55 <ivanm> :o
12:00:55 <preflex>  ☃
12:01:02 <jmcarthur_work> oh, total spu time, summed across all cores
12:01:04 <jmcarthur_work> *cpu
12:01:06 <ivanm> ones: multi-core/parallelism?
12:01:15 <ivanm> jmcarthur_work: yeah, that'd be my guess as well
12:01:29 <mmorrow> , isSymbol '☃'
12:01:30 <lunabot>  True
12:01:32 <mmorrow> :o
12:01:50 <edwardk> ones: multiple cores can run more than one CPU second in a wall-clock second
12:01:54 <mmorrow> , let (☃) = (+) in 41 ☃ 1
12:01:55 <lunabot>  42
12:02:15 * mmorrow is using the snowman in haskell code now
12:02:17 <ones> oh so in the quad-core ones elapsed secs should be 1/4 of the CPU secs?
12:02:25 <ivanm> oh, if anyone here uses the graphviz library I maintain, I'm sure you'd all be glad to know that I'm re-writing all the parsing/printing stuff to fix the horrible quoting issue whilst I'm meant to be on holidays :s
12:02:58 <mmorrow> ivanm: you sound thrilled and non-bitter! :)
12:03:05 <jmcarthur_work> ones, only if all four cores are at 100%
12:03:28 <ivanm> mmorrow: heh
12:03:55 <hehee> Anyone know a useful way in haskell to match IPs in a list against many different IP ranges?
12:04:00 <ones> also why's the size GZIPed size and not just the size?
12:04:07 <ivanm> ones: to get rid of spaces, etc.
12:04:09 <mmorrow> nainaide: just highlighting you to check if you saw the above utf8{enc,dec} stuff
12:04:15 <jmcarthur_work> ones, to combat golfing a bit
12:04:15 <hehee> I was thinking of converting this list of IP ranges to arrays and matching against that, but It'll be huge.
12:04:53 <nainaide> mmorrow, thank you!
12:05:01 <jpcooper> say I have two systems which work independently. They communicate with each other by channels, one for each direction. There is a set of commands for one system and another set for the other. I'm wondering where I should put these commands. I wish I could but the commands in the same files as their corresponding systems
12:06:09 <sclv> ?seen copumpkin
12:06:09 <lambdabot> I saw copumpkin leaving #kata, #concatenative, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah 1h 58m 14s ago, and .
12:06:55 <jpcooper> what I'm trying to write is a chat server where there's a core which handles people in channels and propagating messages to the respective people, and I've got another part of the system that is going to be handling the accepting of connections from outside and also getting input from the outside and sending it to the core
12:07:28 <jpcooper> could anyone advise me on this?
12:07:57 <monochrom> Put the commands in its own module.
12:08:20 <mmorrow> jpcooper: if you might possibly have > 1024 concurrent users, you may need to FFI to epoll/whatnot somehow
12:08:20 <jpcooper> I thought of that, but the commands then need certain data types defined in the respective modules
12:08:27 <sclv> ?tell copumpkin there's a hack to shove applicatives in  by packing an (a->Double, Double->a) dictionary directly -- otherwise you stumble over typeclass constraints.
12:08:28 <lambdabot> Consider it noted.
12:08:34 <mmorrow> jpcooper: since ghc's iomanager uses select()
12:09:09 <jpcooper> at the moment communication will be done through Network's sockets and through Fastcgi
12:09:49 <mmorrow> jpcooper: ok, so you can't have > 1024 concurrent connections currently then
12:10:00 <jpcooper> why is that?
12:10:07 <jpcooper> some restriction on select()?
12:10:09 <ivanm> because
12:10:10 <ivanm> ;-)
12:10:19 <mmorrow> jpcooper: select() can only have 1024 fd's open at any one time
12:10:22 <mmorrow> jpcooper: right
12:10:55 <jpcooper> dats grate
12:11:00 <inimino> isn't there a package for using epoll/kqueue now?
12:11:09 <dschoepe> Are all functors in Haskell actually endofunctors(for the category of Haskell types)?
12:11:10 <mmorrow> jpcooper: there was some effort to replace select with epoll/kqueue/whatever-given-the-platform, but i think that's stalled
12:11:10 <jpcooper> well I'll design it so that I can interchange things
12:11:18 <jpcooper> this is just a toy project so it's not too important
12:11:43 <Saizan> dschoepe: all the instances of Functor at least
12:11:56 <dschoepe> Saizan: yes, that's what I meant. Thanks
12:12:28 <jpcooper> so what you suggest is for me to put the commands for both of the systems in a single file?
12:12:52 <luite> is c2hs known to have problems parsing calling conventions?
12:13:24 <Saizan> jpcooper: i'd keep them separate
12:13:34 <lilac> hehee: use Data.Set.
12:13:59 <Saizan> jpcooper: System1.Interface and System2.Interface
12:13:59 <jpcooper> right so one file for commands for each system
12:14:08 <mmorrow> inimino: the thing is that unless it's build into the rts, you can't use Handle with it, and it won't be integrated into the scheduler, so you'd need to write your own forkIO-thread scheduler around it if you want to implement blocking IO
12:14:10 <lilac> hehee: build a set of your IPs, then given the range from IP A to IP B, use Data.Set.split / Data.Set.splitMember to find the set of IPs in the range
12:14:37 <jpcooper> but the interface files will need to import the respective systems for certain types defined in the systems. I suppose I'll just have to put the type definitions in there as well
12:14:48 <Saizan> mmorrow: fdToHandle mighy work for that
12:14:53 <doublethink_work> mmorrow: i believe bos was the one working on that
12:15:06 <doublethink_work> mmorrow: but i haven't heard anything about that recently anyway
12:15:16 <Saizan> jpcooper: yeah
12:15:17 <mmorrow> Saizan: but the IOManager'll just use select() on it then
12:15:34 <jpcooper> thanks for your suggestions, people
12:15:44 <inimino> mmorrow: I see; ugly
12:16:36 <mmorrow> doublethink_work: yeah, bos and tibbe iirc
12:16:47 <lilac> hehee: something like: anyBetween :: Ord a => Set a -> a -> a -> Bool; anyBetween s a b = let (_,startMember,s') = splitMember s a; (eltsBetween, _) = split s' b in startMember || not (null eltsBetween)
12:17:11 <lilac> hehee: (that's for a range including the startpoint but excluding the endpoint)
12:19:59 <jpcooper> Saizan, how do the sub-modules work there?
12:20:32 <tibbe> mmorrow: where're working on replacing the I/O manager with one that uses epoll/kqueue/etc
12:21:53 <mmorrow> tibbe: yay! :)
12:23:02 <doublethink_work> tibbe: think it'll make it into ghc 6.12?
12:23:55 <tibbe> doublethink_work: unlikely, both me and bos have been very busy lately
12:23:55 <artagnon> In a list of proper fractions, I want to find the one just lesser than 3/7 .. I wrote http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8269#a8269 -- Could I get hints on how to improve it?
12:24:08 <tibbe> doublethink_work: patches welcome! http://github.com/tibbe/event
12:24:10 <artagnon> mostly memory-usage wise.
12:24:21 <tibbe> doublethink_work: there's even a small design doc
12:24:30 <artagnon> It'd be nice if fracList were only computed until 3/7 in the first place
12:25:58 <randomwords> artagon: Something like [ (x,y) | y <- [2 .. lim], x <- [1..y], gcd x y == 1, y*3 < x*7]
12:26:18 <randomwords> Still - there's a cleverer way to solve this problem
12:26:34 <artagnon> randomwords: Ah, nice suggestion for starters :)
12:26:36 <artagnon> Is there?
12:26:50 <randomwords> artagnon: Actually I think you want x*7 < y*3
12:26:59 <randomwords> yes, but telling isn't in the spirit of PE
12:27:24 <artagnon> ofcourse. All I want is a hint.
12:27:28 <artagnon> I NEVER ask for answers.
12:27:33 <mmorrow> tibbe: oh, so replacing the rts IOManager is secondary?
12:28:41 <hehee> Does anyone know of an efficient way of matching ips against multiple IP ranges in haskell?
12:29:00 <randomwords> artagnon: hint - It's not neccessary to actually compute the fractions
12:29:04 <tibbe> mmorrow: replacing it is the goal. However, we believe creating a separate library will lead to a better design. bos tried to hack the IO manager directly and he said he didn't think that was a good idea
12:29:15 <hehee> I have maybe 200-300 IP ranges and thousands of IPs to match them with.
12:29:23 <randomwords> s/compute/construct
12:29:29 <tibbe> mmorrow: once the library is done it shouldn't be too hard to replace the IO manager
12:29:37 <artagnon> Right, thanks for the hint.
12:29:48 <randomwords> artagnon: At least not all of them
12:30:01 <artagnon> Within 25 seconds, my version bloats up so much that I'm not even able to switch between windows.
12:30:12 <artagnon> So I *have* to improve it.
12:30:14 <gwern> hehee: hm. your problem is ringing algorithm bells in my head... bloom filters or tries maybe
12:30:40 <mmorrow> tibbe: it seams to me that one could just define the interface, implement an instance of it for select(), redo the IOManager to use that interface, and plug in the select() inplem until the epoll/etc gets figured out
12:30:55 <tibbe> mmorrow: indeed
12:31:01 <tibbe> mmorrow: we're figuring out that interface
12:31:08 <tibbe> mmorrow: it's a pretty small interface actually
12:31:11 <hehee> gwern: gonna check them out.. Every way I can think of is very slow
12:31:20 <mmorrow> tibbe: cool
12:31:26 * mmorrow checks out teh code
12:31:35 <tibbe> mmorrow: it needs some more thought though and I haven't had the time
12:31:48 <tibbe> mmorrow: the code is a bit rough, I'm playing with backend design
12:31:53 <tibbe> mmorrow: just be warned
12:32:00 <mmorrow> tibbe: :)
12:32:33 <tibbe> mmorrow: the current IO manager has a O(n) behavior we need to get rid of
12:32:46 <tibbe> mmorrow: the event libraries does so by using arrays of callbacks instead of a linked list
12:33:56 <mmorrow> tibbe: could always use an IntMap/whatever and settle with O(lg n) (should that make it easier in the short-run for whatever reason)
12:34:31 <mmorrow> but i don't know the details yet of course..
12:35:17 <tibbe> mmorrow: it would make it slightly simpler
12:35:50 <tibbe> mmorrow: but I rather start with fast and go towards easier code for these things. I find it hard, once you written a OKish version, to optimize it
12:36:13 <tibbe> mmorrow: we're taking the performance from day one approach and then generalize/make simpler
12:36:49 <tibbe> mmorrow: the code is very low level currenlt
12:36:52 <tibbe> currently*
12:37:06 <tibbe> also, working with the default mutable array types is annoying
12:37:12 <tibbe> especially the Ix part
12:37:25 <tibbe> can't we just have zero based arrays like everyone else?
12:37:29 <mmorrow> tibbe: ooh yay, if we're peek/poke'ing then that sounds good
12:37:54 <mmorrow> (as opposed to writeLKJSDKArray'ing)
12:39:39 <reece> boobs
12:39:57 <mmorrow> oh, i see. so MutableArray# directly you mean
12:40:11 <artagnon> @src maximum
12:40:12 <lambdabot> maximum [] = undefined
12:40:12 <lambdabot> maximum xs = foldl1 max xs
12:40:41 <tibbe> mmorrow: yes
12:40:51 <tibbe> mmorrow: I really needed a dynamically resizing array
12:41:01 <tibbe> mmorrow: so I created one
12:41:09 <dschoepe> I'm having trouble grasping the connection between monads from category theory and monads in Haskell: η is a mapping between functors and corresponds to `return', but return is just a mapping from Hask to Hask and hence a functor, not a natural transformation. What am I missing?
12:41:33 <mmorrow> tibbe: hmm, although from what i understand mutable arrays (of ptrs to haskell values) have bad interaction with the GC
12:41:58 <mmorrow> tibbe: in that the entire array needs to be scanned if just one cell is mutated
12:42:17 <mmorrow> tibbe: given the current GC
12:42:22 <artagnon> @src max
12:42:23 <lambdabot> max x y = if x <= y then y else x
12:42:31 <tibbe> mmorrow: yes
12:42:50 <tibbe> mmorrow: so in the long run a specialized IntMap might be a better choice
12:43:07 <mmorrow> tibbe: right, that's exactly what i was wondering
12:44:53 <tibbe> mmorrow: we need a good benchmark
12:45:40 <tibbe> mmorrow: for the peek/poke stuff an array is probably faster
12:45:52 <tibbe> mmorrow: since it basically a ForeignPtr
12:45:58 <mmorrow> yeah, that'd be an interesting benchmark in general too
12:46:22 <mmorrow> right, for arrays of not-ptrs-to-haskell-values definitely
12:46:28 <hackagebot> mps 2009.8.18 - simply oo (JinjingWang)
12:46:34 <artagnon> randomwords: I did something even smarter... To reduce memory usage, I collapsed the maximum function to do a foldl1' instead of a foldl1 :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8269#a8270
12:46:47 <artagnon> randomwords: ofcourse, it should be still as slow
12:46:54 <tibbe> mmorrow: so the backend themselves use unboxed arrays, the generic part of the library currently uses a boxed array to hold the callbacks
12:46:59 <artagnon> but atleast it runs without hanging my WM :)
12:47:31 <mmorrow> tibbe: ah, ok i see
12:48:18 <tibbe> mmorrow: we want to be able to find the callback for a ready file descriptor in O(1) (or O(lg n)).
12:48:22 <mmorrow> tibbe: hmm, so then the part that's holding the callbacks would become the part of the scheduler that's holding callbacks i take it?
12:48:32 <artagnon> randomwords: Now I have to do something clever to increase the speed. It doesn't finish in under a minute :'(
12:48:40 <tibbe> mmorrow: the IO manager currently scans all file descriptors that are registered for events
12:49:06 <tibbe> mmorrow: so the I/O manager would hold a reference to the EventLoop data structure
12:49:29 <tibbe> mmorrow: functions like waitForRead (or whatever they are called) would call functions on the EventLoop
12:49:51 <tibbe> mmorrow: there's some work on thread safety that needs to be done. I'm thinking about having one EventLoop per OS thread
12:49:56 <tibbe> mmorrow: as that's more efficient
12:49:56 <edwardk> dschoepe: perhaps it is better to think of fmap as the action of the functor on arrows, and return as the canonical morphism from a -> m a
12:49:58 <mmorrow> tibbe: ah, ok. so then this array/IntMap in the EventLoop structure would be *the* place callbacks are stored
12:49:59 <tibbe> mmorrow: or should be
12:50:08 <tibbe> mmorrow: exactly
12:50:12 <mmorrow> tibbe: as in, there wouldn't be any duplicatio
12:50:14 <mmorrow> gotcha
12:51:28 <tibbe> mmorrow: :)
12:51:34 <tibbe> mmorrow: I'm glad it makes some sense
12:52:07 <jpcooper> how can one module import another which is in a lower directory?
12:53:09 <jmcarthur_work> import DirName.SubDir.ModuleName
12:53:29 <jmcarthur_work> these are relative to the root of the project, not to the current module
12:53:35 <mmorrow> tibbe: ooh, this reminds me. someone wrote this webserver, which ffi's to epoll, and posix aio, and implements it's *own* thread scheduler, *and* uses multiple OS threads, *and* etc etc.. it's pretty cool and from iirc 2006, and i'm surprised it's not common knowledge (i just happened to stumble across it a few months ago, and hacked it to build with current GHC). i don't recall the link, but i've got the code somewhere
12:53:40 * mmorrow looks for it
12:53:57 <jmcarthur_work> so even if you current module is DirName.MyModule, you still say DirName at the beginning of the import
12:54:49 <tibbe> mmorrow: I would be interested to see it, I might have tripped over it before
12:55:06 <jpcooper> thanks
12:55:18 <tibbe> mmorrow: the second idea I had with the event library is that it would allow you to do such things. You can use it directly in your program and skip the I/O manager
12:55:28 <mmorrow> tibbe: i'm going to stick the darcs repo somewhere, once i find it in all my crap
12:55:42 <mmorrow> tibbe: that would be neat for sure
12:56:43 <mmorrow> nice, i found it. it's called "Unify"
12:57:34 <bos> mmorrow: sure, it's well enough known.
12:57:55 <mmorrow> ah nice, it came out of the nowhere for me
12:58:23 <bos> this is peng li's project, right>
12:59:02 <mmorrow> i added a hierarchical namespace (Unify.*), and fixed random pieces that prevented it from building with current ghc
12:59:15 <mmorrow> cleaning up the repo an uploading now..
12:59:20 <doublethink_work> mmorrow: unify apparently has amazing scaling capabilities
12:59:33 <luite> dcoutts: do you know if c2hs (the gtk2hs version) has problems parsing calling conventions (__stdcall) in typedefs? I found out that CALLBACK is defined __stdcall in <windef.h>, and when I undefine it, I can compile the whole gtk2hs package
12:59:46 <edwardk> doublethink_work: oh?
13:00:01 <bos> 10M threads isn't that different from what stock GHC can handle these days.
13:00:07 <tibbe> bos: so why wasn't it more successful?
13:00:09 <mmorrow> edwardk: you can have 1000s of concurrent connections, etc
13:00:10 <edwardk> is there a link to it?
13:00:12 <luite> dcoutts: (building the installer still gives some problems with paths in the package .config files, and I'm not sure if the binaries work at all)
13:00:27 <edwardk> even the old and crufty pre-mmorrow version =)
13:00:46 <bos> tibbe: he hacked on the internals of GHC, and simonpj thought his changes were too intrusive and messy to take.
13:00:53 <bos> he never cleaned up his patches.
13:00:57 <doublethink_work> "Our implementation demonstrates how to use these techniques by building an application-level thread library with support for multiprocessing and asynchronous I/O mechanisms in Linux.  The thread library is type-safe, is relatively simple to implement, and has good performance.  Application-level threads are extremely lightweight (scaling to 10,000,000 threads!) and our scheduler, which is implemented as a modular and extensible event-driven syst
13:00:58 <tibbe> bos: ah
13:01:04 <doublethink_work> edwardk: http://www.seas.upenn.edu/~lipeng/homepage/unify.html
13:01:30 <doublethink_work> bos: yeah, there were some linear scaling issues a while back IIRC, but these days ghc can get up to 10M pretty easy from what I can tell
13:01:37 <dcoutts> luite: I'd have to check the C parser for if it handles that extension. This might be a new thing in the mingw header files. Normal GNU syntax uses __attribute__((stdcall))
13:02:13 <bos> doublethink_work: yes it can.
13:02:25 <bos> now all the bottleneck is in the I/O manager.
13:02:29 * tibbe pushes the unify paper on his reading stack
13:02:41 <luite> dcoutts: it may already be converted to that syntax by the preprocessor, I'm not sure about that
13:02:46 * bos wishes he had a month or so to hack on GHC internals.
13:02:59 <tibbe> doublethink_work: GHC is still O(n) in the number of watched file descriptors
13:03:20 <tibbe> bos: me too!
13:03:29 <tibbe> bos: the event library hasn't had the love it deserves
13:03:39 <bos> tibbe: yeah. sadface :-(
13:04:57 <edwardk> doublethink_work: ok, i remember reading that now.
13:04:58 <tibbe> bos: do you think there's any hope we ever finish the event lib?
13:04:59 <luite> dcoutts: I'll try to fix the paths in the installer package first and look into this after that. can I assume that c2hs sees what's in the .i file?
13:05:05 <tibbe> bos: do you even agree with the approach?
13:05:23 <bos> tibbe: i think the idea makes a lot of sense.
13:05:50 <bos> tibbe: i really ought to finish the text library before i spend lots of cycles on the event stuff.
13:06:15 <bos> i've made lots of progress on it in the past half-week after not having time or energy to hack for months.
13:06:22 <tibbe> bos: yes
13:06:50 <tibbe> bos: I'm in a slump right now, lots of things to hack on but none of them has a crystal clear path forward
13:07:04 <tibbe> bos: hyena is stuck on some iteratee thinking stuff
13:07:05 <bos> but yeah, i want to be able to use haskell in my native environment (big distributed applications), and i can't until we fix the I/O manager.
13:07:19 <edwardk> tibbe: hyena?
13:07:19 <mmorrow> ok, a cabal'ed darcs repo with haddock docs (w/ src links) http://moonpatio.com/repos/unify/
13:07:25 <edwardk> tibbe: what are you using iteratees for?
13:07:31 * bos is wary of oleg's work.
13:07:37 <tibbe> bos: my efficient bytestring table that can store 100+ Gb is stuck on binary not being a good fit for my deserialization needs
13:07:44 <tibbe> edwardk: web server
13:07:49 <bos> tibbe: really?
13:07:53 <tibbe> edwardk: i need to speak to oleg again at icfp
13:07:56 <tibbe> bos: yes
13:07:58 <edwardk> bos: i just spent a whole bunch of time redesigning iteratees to meet my needs
13:08:07 <edwardk> bos, tibbe: hence my curiosity
13:08:08 <bos> tibbe: what's the problem with binary for your use?
13:08:12 <tibbe> bos: well, it's not much more than a ParserT really
13:08:44 <edwardk> tibbe: i have an backtrackable-iteratee based parsec 3 Stream data type i'm using now that works fine
13:08:56 <mmorrow> (that .cabal builds unify-httpd, unify-loadgen, and a library)
13:09:16 <tibbe> bos: Two things really. 1) It's not as well suited for parsing predefined formats as it is for parsing data generated by binary. 2) it doesn't work well when you don't want lazy I/O
13:09:24 <mmorrow> all of which use epoll (so i guess you need linux as well)
13:09:43 <tibbe> edwardk: all my parser designs essentially end up the same. A resumable parser based on continuations
13:10:00 <bos> tibbe: i didn't find it to be a problem for predefined formats. i have a binary-based parser for the MySQL wire protocol, which works fine.
13:10:08 <tibbe> bos: Im trying to turn Oleg's ideas to something "Haskellish"
13:10:29 <bos> but i haven't ported my parser to my binary fork that is resumable.
13:10:36 <tibbe> bos: what do you do if the input is large and you don't want lazy I/O?
13:10:43 <tibbe> bos: ah :)
13:10:45 <edwardk> tibbe: i'm currently using these little iteratee based parsec parsers behind a monoidal wrapper that knows how to spawn new ones at nice 'eye of the needle' points in the grammar, so i can get monadic left to right parsing with context-free boundaries for nice languages.
13:11:01 <tibbe> bos: my point exactly, at the base I think binary should be a resumable CPS based parser
13:11:16 <bos> tibbe: agreed.
13:11:23 <tibbe> edwardk: I'm not sure I understood all of that
13:11:51 <bos> tibbe: i think he said that his parser operates incrementally.
13:11:53 <tibbe> bos: iteratee's are not much more than that, except they allow the continuation to perform side effects
13:12:01 <tibbe> bos: as
13:12:30 <jeffheard_home> isn't there some way to make newtypes derive all their instances from their oldtypes that you don't redefine yourself?
13:12:38 <edwardk> tibbe: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3160#a3163 is my modified iteratee, because i need to allow for backtracking to make parsec happy
13:12:42 <tibbe> bos: I'm also thinking about what a good network library should look like
13:12:46 <edwardk> tibbe: its changed a bit since then but the general idea is the same
13:12:50 <jeffheard_home> newtype K = K Int deriving (Num,Integral) or something?
13:12:59 <Heffalump> yes, juse use NewtypeDeriving
13:13:13 <edwardk> tibbe: a few differences from usual, the addition of the cursor data type and the use of fingertrees of strict bytestrings as a buffer
13:13:16 <tibbe> edwardk: I'll try to read that when I have time. Thanks
13:13:32 <edwardk> tibbe: i'm giving a presentation tomorrow that uses them, i'll post up the slides after
13:13:50 <jeffheard_home> HeffaLump, thanks
13:13:53 <tibbe> edwardk: cool!
13:13:59 <tibbe> edwardk: coming to ICFP?
13:14:08 <bos> tibbe: yeah
13:14:11 <edwardk> tibbe: i'm wrapping all of that with a monoid that makes it so you can parse fragments in parallel or incrementally
13:14:16 <edwardk> tibbe: fraid not
13:14:46 * tibbe wishes he had two weeks of hacking following ICFP
13:15:06 <tibbe> I wonder how much could be done with two weeks worth of hacking with a lot of smart people
13:15:23 <edwardk> tibbe: so basically what i wanted was for you to be able to write the lexer (and actually the parser) in parsec, but still get it to run in parallel at a high level.
13:15:43 <tibbe> edwardk: I see
13:16:03 <tibbe> I'm also thinking about writing a parallel processing library inspired by Google's Sawzall
13:16:05 <doublethink_work> edwardk: what's kata?
13:16:07 <edwardk> tibbe: so i use iteratees to make it so you can feed the parsec'd chunks more input on the right, and i make a monoid that wraps all of this that scans for a good error production location in the bytestring fragments and starts a parser there
13:16:12 <edwardk> doublethink_work: my toy language
13:16:49 <doublethink_work> edwardk: fun! link? repo?
13:17:19 <tibbe> edwardk: interesting
13:17:23 <edwardk> doublethink_work: kata == untyped haskell w/ multiple inheritance and some interesting mixin techniques for ML-like modules replacing type classes, designed so that it can typecheck definitions but not dispatch so that i can play in spaces which involve a lot of subtyping that would be prohibitive to work in in a stronger typed language
13:17:46 <edwardk> doublethink_work: mostly just the channel at this point. the repo will go public sometime soon
13:17:54 * tibbe thinks that it'd be useful to write down some Haskell design patterns. i.e. how to use continuations to decouple consumers/producers
13:19:09 <tibbe> bos: oh, the biggy I want to tackle is the I/O library
13:19:09 <luite> dcoutts: ok, I seem to have built a functional gtk2hs installer for ghc 6.10.4
13:19:14 <edwardk> tibbe: so basically you can feed the input into a fingertree, and i'll start parsers at the resumption points in the grammar, generate my tokenstream and then merge token streams in a higher level iteratee based parsec parser/monoid that takes care of merging bitonic sequences of layout and of the dyck language structure and running small parsers inside those delimited bounds
13:19:17 <bos> tibbe: yep
13:19:20 <dcoutts> luite: well done!
13:19:39 <luite> thanks for the help :)
13:19:58 <luite> although you might have been a tad optimistic when you said that I was already 3/4 done yesterday ;)
13:20:00 <edwardk> tibbe: then if you type into the middle of the tree, it can reparse just by crawling up the fingertree, resuming the appropriate iteratee with different input, etc.
13:20:11 <dcoutts> luite: wishful thinking it seems
13:20:20 <tibbe> edwardk: I'm sorry but that's a bit over my head :)
13:20:24 <edwardk> tibbe: but sharing the vast majority of the previous parse
13:20:36 <dcoutts> luite: I suggest you send tale of your trials to the gtk2hs-users mailing list to embarrass the devs into making a proper release and improving the docs on how to build from source.
13:20:39 <tibbe> edwardk: is this for an editor?
13:20:43 <edwardk> tibbe: initial parse in parallel, then reparse in logarithmic time ;)
13:20:48 <edwardk> tibbe: no, the whole compiler ;)
13:21:13 <edwardk> tibbe: though, the design is so that when you bolt an editor on it, the intellisense like functionality, etc. can be blazingly fast
13:21:15 <tibbe> edwardk: ok, but why do you need this incremental, error correcting behavior?
13:21:26 <edwardk> tibbe: because compilers don't just compile these days
13:21:42 <edwardk> you want them to help you refactor, typecheck, do tab completion...
13:21:52 * tibbe knows too little about modern compilers
13:21:58 <tibbe> edwardk: ok
13:22:11 <tibbe> edwardk: I remember a yi paper about parsing for editors
13:22:15 <edwardk> tibbe: so i've been experimenting with kata to see what a 'modern compiler' design should be
13:22:24 <tibbe> edwardk: cool :)
13:22:25 <edwardk> tibbe: yeah, though the approach there was approximate. mine is exact
13:22:34 <edwardk> tibbe: no probabalistic parsing
13:22:46 <tibbe> edwardk: I see
13:23:19 <edwardk> tibbe: its been tricky figuring out how to parse things like layout using monoids, etc. efficiently
13:23:37 <edwardk> but really there is a common idiom that emerges over and over, so once you get that down, its all good.
13:23:45 <edwardk> i just need to figure out how to factor that into a library
13:24:00 <luite> dcoutts: yes, I've tried to keep a log of the steps needed to build this thing, there may be some things I have overlooked (and many unnecessary steps). I'll post a list of these steps and ask for comments.
13:24:23 <tibbe> edwardk: write a blog post about it!
13:24:27 <edwardk> i've been building a parser combinator set that does this in general for applicative grammars, but the optimized special case cruft i'm working with now seems to be more efficient in general
13:24:50 <edwardk> tibbe: heh, well, i did a presentation on some of this at hac-phi, and have slides on my blog
13:24:59 <tibbe> edwardk: was it you who did work on the ran functors stuff?
13:25:02 <edwardk> tibbe: i'm doing two more on the topic tomorrow,
13:25:05 <edwardk> tibbe: yeah
13:25:11 <tibbe> edwardk: please post the slides
13:25:34 <edwardk> tibbe: for the talks tomorrow? will do
13:25:36 <tibbe> edwardk: I've been thinking about efficient monad implementations lately. Did you learn anything about performance from doing it?
13:25:52 <edwardk> tibbe: yeah, stay in codensity as long as possible before reverting to general purpose ran
13:26:00 <tibbe> edwardk: my hunch right now is that CPS state monads (e.g. for parsers) optimize better
13:26:05 <edwardk> tibbe: which i admit probably means nothing to anyone but me ;)
13:26:10 <edwardk> tibbe: they do
13:26:13 <tibbe> edwardk: that means nothing to me I'm afraid
13:26:16 <edwardk> some times up to 4x better
13:26:20 <Heffalump> tibbe: is that just an artefact of the current GHC, or is it fundamental in some way?
13:26:30 <tibbe> edwardk: what's the intuition behind, why is it faster?
13:26:31 <jmcarthur_work> yeah, CPS is great for monads and monad transformers
13:26:31 <edwardk> but they seem easier for the strictness analyzer to figure out
13:26:40 <tibbe> Heffalump: edwardk: my question exactly
13:27:04 <edwardk> tibbe: and when you look at it, fmap, etc. can manipulate just a partial application when you stay in codensity, and state is Codensity Reader
13:27:17 <tibbe> edwardk: what's codensity?
13:27:27 <mmorrow> @unmtl StateT s (Cont o) a
13:27:28 <lambdabot> s -> (a -> s -> o) -> o
13:27:35 <edwardk> tibbe: in general codensity allows for the cps transformation of anything that doesn't need the monad.
13:27:40 <mmorrow> @unmtl ContT o (Reader s)  a
13:27:41 <lambdabot> (a -> s -> o) -> s -> o
13:27:43 <mmorrow> @unmtl StateT s (Cont o) a
13:27:44 <lambdabot> s -> (a -> s -> o) -> o
13:28:01 <edwardk> tibbe: newtype Codensity f a = Codensity { forall o. (a -> f o) -> f o }
13:28:18 <edwardk> ContT without callCC or the requirement that f even be a Functor.
13:28:57 <tibbe> Iteratee is basically StateT Cont
13:29:03 <edwardk> tibbe: in general monad-ran works with codensity and arbitrary right kan extensions, but when its working with codensity monads it is faster. that said, you can often preserve the use of codensity even after applying a transformer
13:29:42 <edwardk> for instance StateT can yield a codensity monad when applied to a codensity monad, so some type family tricks could speed it way up
13:30:26 <edwardk> tibbe: 'right kan extension' is newtype Ran f g a = Ran { forall o. (a -> f o) -> g o } -- clearly Codensity f = Ran f f
13:30:44 <tibbe> random question on the topic of performance. Does UNPACK work on polymorphic fields?
13:30:54 <edwardk> tibbe: but codensity offers further optimization opportunities, because instance Monad (Codensity f ) doesn't care about f at all
13:31:00 <edwardk> tibbe: nope
13:31:08 <edwardk> thats why the adaptive containers lib exists
13:31:15 <tibbe> edwardk: that's what I thought but I've seen it in code
13:31:31 <tibbe> edwardk: the compiler should really warn
13:31:35 <edwardk> tibbe: interestingly you can do unpacked cps transformed monads and they perform quite nicely in some cases...
13:31:41 <edwardk> because the kinds don't get in your way as much
13:31:54 <Saizan> does Codensity (f `O` g) relates in some way to Codensity f and Codensity g?
13:32:57 <edwardk> i.e. cps transformed integer state: newtype IntState a = IntState (forall o. (a -> Int# -> o) -> Int# -> o) -- is clearly a codensity monad  -- and can be partially applied for fmap, etc. but leaves your state unboxed further down the stack if you don't use it
13:33:50 <copumpkin> :o
13:33:50 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
13:34:01 <tibbe> edwardk: how come the Int doesn't have to be boxed there?
13:34:03 <edwardk> tibbe: also note that you can break IO, STM, and ST s into two halves so they two can be reflected as codensity monads!
13:34:13 <tibbe> edwardk: wouldn't that change the meaning of the program?
13:34:23 <edwardk> tibbe: sure, but if you want an unboxed state monad...
13:34:25 <copumpkin> sclv: you referring to that lazy spline library?
13:34:33 <tibbe> edwardk: I usually do, just asking
13:35:11 <edwardk> tibbe: yes it changes the meaning, but I can provide, with type families and some magic something that looks like UStateT Int (Reader Env a) -- as an unboxed integer state transformer monad
13:35:32 <edwardk> tibbe: so you opt in to use it, just like you do with adaptive containers, etc.
13:35:41 <edwardk> tibbe: a lot of the time we want strict containers, state, etc.
13:35:42 <tibbe> edwardk: ok
13:36:04 <tibbe> has anyone used adaptive-containers and can comment about the quality of the library?
13:36:04 <edwardk> tibbe: and it has been known to kick some serious tail performance wise. it can also be dog slow on other benchmarks, so its not always a win
13:36:52 <edwardk> tibbe: adaptive-containers is pretty good. i was starting to put together a fairly massive extension to it, but my extension turned out to be quite the rabbit hole to go down for a seemingly short term win. (since if they ever fix the UNPACKer it would be totally worthless)
13:37:07 <copumpkin> what needs fixing?
13:37:13 <edwardk> there is also unboxed-containers iirc which i slapped together to include an Unboxed Set
13:37:19 <edwardk> copumpkin: the API doesn't scale.
13:37:40 <edwardk> there is a way you can make a much more scalable API, but it requires some seriously horrible mental gyrations to get right
13:37:47 <copumpkin> you mean writing {-# UNPACK #-} next to every field is a little tedious?
13:37:55 <copumpkin> or the underlying machinery just isn't flexible enough
13:38:12 <tibbe> bos: oh another thing I would like to work on. A proper containers lib
13:38:14 <edwardk> i mean by doesn't scale that it handles only up to tuples, and only of the primitive data types. you can't feed it newtypes of them, you can't hand it bigger types, etc.
13:38:26 <copumpkin> ah, yeah
13:38:26 <bos> tibbe: different from edison?
13:38:36 <tibbe> edwardk: what fixes does the unpacker need?
13:38:41 <edwardk> but you can derive a version that uses a bounded number of slots, etc. that can with some massaging handle more or less anything unboxed
13:39:37 <tibbe> bos: dunno, I'll have to look into it
13:39:41 <edwardk> tibbe: it could with some work unpack through type/data families that resolve monomorphically, all of the invariants it requires as i understand it would be maintained.
13:39:47 <edwardk> adaptive could then be very simple
13:40:22 <edwardk> tibbe: i haven't thought about this in a few months, so i'm a bit rusty on the ins and outs
13:40:50 <tibbe> edwardk: ok
13:42:04 <dons> woo. opencl http://www.reddit.com/r/programming/comments/9bhxp/haskell_gets_an_opencl_layer_direct_access_to_the/
13:42:25 <Nafai> Fancy!
13:42:27 <edwardk> tibbe: ideally i would go finish the horrible type hackery needed to deal with packable and unpackable data types and then define the small family of 100 or so instances that are needed to handle unboxing all types that use up to 5 slots or so, which would cover basically all of the existing adaptive instances, but I can't bring myself to take that long of a detour from my current research =)
13:43:05 <Nafai> 404 on the project homepage though :(
13:43:44 <copumpkin> edwardk: the IHG needs to hire you to work full-time on haskell/ghc too!
13:44:24 <edwardk> copumpkin: i'm open to any offer that is in my rational self-interest to accept ;)
13:45:03 <artagnon> randomwords: I came back to thank you. I solved it, all thanks to your hint. It executes in under a second now :D -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8269#a8271
13:45:13 <randomwords> artagnon: No problem
13:45:30 <tibbe> edwardk: perhaps just writing down what needs doing would encourage someone to do it
13:47:11 <edwardk> tibbe: basically the idea is quite simple. the current adaptive-containers has to deal with all possible inputs in the encoding of the data family. i.e. if you want AdaptivePair (Int,Char) -- you need an instance to explicitly handle that case. but what about AdaptivePair (Sum Int, Char) -- or AdaptivePair (Float, Int) -- all different.
13:47:52 <tibbe> edwardk: I understand
13:48:08 <edwardk> tibbe: you can change this by defining a certain set of valid slot types, and assigning those slots a canonical order. i.e. Int before Float before 'Boxes', then you don't have to deal with all of the interleavings, just the overall counts
13:48:41 <edwardk> tibbe: and you can define a MPTC/set of type families for Packing and Unpacking from a primitive data type to those slot types.
13:48:46 <tibbe> edwardk: but the interleavings could matter, no?
13:49:12 <edwardk> tibbe: that is the magic, they don't, as long as you unswizzle to the same original order when you unpack them through the view
13:49:57 <tibbe> edwardk: cool
13:50:09 * tibbe needs to focus on reviewing dcoutts stuff now
13:50:11 <tibbe> edwardk: :)
13:50:13 <edwardk> tibbe: adaptive-containers/unboxed-containers works by providing a view that is used by the library which doesn't know about the underlying packing
13:50:32 <tibbe> edwardk: makes sense
13:51:39 <Vanadium> What module am I supposed to import for parsec :|
13:52:13 <edwardk> tibbe: so with a phantom type indicating the packer/unpacker to use across the tree, and a type family that is based on the packed representation, you can get by with combinatorially far fewer data instances. i.e. instead of 10^n where n is the number of distinct types you have you need only the number of ways your slots can sum up to or including 10, in their canonical ordering =)
13:52:29 <Lemmih> Vanadium: Text.ParserCombinators.Parsec
13:52:42 <Vanadium> Thank you
13:52:45 <edwardk> er sorry not 10^n n^10
13:53:08 <edwardk> n is currently something like 13-14
13:53:22 <edwardk> and the number of slot types is something like 3-4
13:55:02 <edwardk> the number of ways 3 naturals can add up to 10 or less is way lower
13:55:23 <edwardk> tibbe: letting you go then ;)
13:57:42 <tibbe> edwardk: thanks for all the explanations
13:59:18 <ddvlad> while :: IO Bool -> IO ()
13:59:18 <ddvlad> while m = m >>= flip when (while m)
13:59:37 <ddvlad> am i missing something? is this not a very common usage pattern, or is the function not defined?
14:00:41 <olsner> some want while's defined in other ways, and it apparently comes up seldom enough that no-one can agree to put a specific form into the prelude
14:00:52 <olsner> (besides, building your own isn't that hard)
14:01:30 <pikhq> @src until
14:01:31 <lambdabot> until p f x | p x       = x
14:01:31 <lambdabot>             | otherwise = until p f (f x)
14:01:41 <pikhq> @type until
14:01:43 <ddvlad> olsner: makes sense, yes, but 'building your own' is a common newbie (me!) pitfall -- i roll my own, then realise there's something already defined
14:01:43 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:02:00 <ddvlad> heh, cool :)
14:02:09 <pikhq> And I thought it was more useful than that.
14:02:38 <c_wraith> > until (> 34) (*2) 1
14:02:40 <lambdabot>   64
14:03:02 <c_wraith> well, that's basically what I expected from it, anyway
14:03:28 <_-jn> hi, can you help me? I have a function (call it F), an Integer C and two lists of the same length (call them [X] and [Y]). I want to "map" them toghether like: <map> F X C Y, with the elements of [X] and [Y].  Is that possible?
14:03:35 <ddvlad> yep, i met `until' before, it's probably why i was so sure something similar had to be there
14:03:45 <olsner> @ty until . not
14:03:46 <lambdabot>     Couldn't match expected type `a -> Bool'
14:03:46 <lambdabot>            against inferred type `Bool'
14:03:46 <lambdabot>     In the second argument of `(.)', namely `not'
14:04:02 <olsner> @ty until . (not.)
14:04:03 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:04:14 <enolan> @type zipWith
14:04:16 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:04:41 <pikhq> _-jn: zipWith (f c) x y
14:05:20 <_-jn> ok, thank you, I will try that!
14:05:35 <enolan> _-jn: zipWith combines two lists with elementwise with a given function.
14:05:35 <enolan> remove the first with
14:06:09 <c_wraith> > zipWith (*) [1, 2, 3] [1..]
14:06:11 <lambdabot>   [1,4,9]
14:06:42 <c_wraith> and obviously, the length of the result list is the length of the shorter input list
14:07:22 <olsner> @unpl fmap f . g
14:07:23 <lambdabot> (\ c -> fmap f (g c))
14:07:38 <olsner> ehm, obviously
14:07:41 <c_wraith> > join $ zipWith (*) $ [0..]
14:07:43 <lambdabot>   Couldn't match expected type `[a1] -> a'
14:07:48 <c_wraith> oops
14:07:59 <srush> has anyone used graphics-drawingcombinators?
14:08:02 * olsner has become pointless, apparently
14:08:09 <srush> I can't seem to get the spriting to work
14:08:37 <c_wraith> > join (zipWith (*))  [0..]
14:08:39 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
14:09:17 <arw__> @ty join
14:09:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:10:25 <jmcarthur_work> :t join (a -> a -> b) -> (a -> b)
14:10:28 <lambdabot> parse error on input `->'
14:10:35 <jmcarthur_work> :t join :: (a -> a -> b) -> (a -> b)
14:10:36 <lambdabot> forall a b. (a -> a -> b) -> a -> b
14:12:35 <Philonous> > (return 5) 3
14:12:36 <lambdabot>   5
14:14:08 <mrsolo> getting back to haskell again.. is emacs still the best editor all around for haskell?
14:14:10 <Philonous> > (return 5) >>= (+)  $ 2
14:14:12 <lambdabot>   7
14:14:54 <arw__> mrsolo: isn't the choice of an editor a matter of taste?
14:15:20 <Berengal> mrsolo, I'm currently voting yi. Leksah is also a good alternative
14:15:29 <mrsolo> somewhat but it more influenced by what kind of support it has for particular proramming language
14:15:41 <copumpkin> edwardk: did you see my earlier question about "combinatorial algebra"
14:15:42 <copumpkin> ?
14:15:58 <mike-burns> mrsolo: vim has great Haskell support. So much so that I think the choice of an editor is a matter of taste.
14:16:26 * CosmicRay is very happy to have his nick back, finally.
14:16:31 <sclv> copumpkin: yep, that library
14:16:36 <skorpan> mrsolo: yi has come a long way in its haskell-mode
14:16:39 <CosmicRay> mike-burns: actually I think that both vim and emacs have rather poor haskell support, vim worse than emacs
14:16:40 <mrsolo> oh it does? hmm i will read up on it then
14:17:05 <mrsolo>  ...
14:17:07 <mike-burns> CosmicRay: Emacs and vim have poor support when compared with what?
14:17:14 <CosmicRay> mike-burns: their support for Python
14:17:24 <mike-burns> Okay, sure.
14:17:44 <mike-burns> I thought you meant when compared with the Haskell support in yi or something.
14:17:45 <CosmicRay> mike-burns: I use Emacs for Haskell.  Compared to all the other Haskell modes out there, it's great :-)
14:17:55 <CosmicRay> but it still sucks.
14:18:08 <CosmicRay> as the informal slogan of an ISP I used to work for goes, "we suck less"
14:18:21 <randomwords> vim-haskellmode gets the job done
14:18:22 <mike-burns> Right. That's similar to the slogan for the mutt email client.
14:19:20 <mike-burns> I will never dispute that something can be improved. That said, vim and emacs have decent Haskell support that could be improved.
14:19:23 <Berengal> Yi is quite active these days. Last week the mailing list had about 60% of the activity the cafe did
14:19:35 <CosmicRay> wow
14:19:55 <Berengal> Granted, many of the mails are patches...
14:20:12 <Berengal> Anyway, I'm 60 patches behind in just four days...
14:20:25 <CosmicRay> that is not a bad thing
14:20:43 <Berengal> Indeed not... I should get some more of mine out there
14:22:01 <mrsolo> ok thx i will look into yi
14:22:50 <mrsolo> yes imho emacs haskell support is somewhat minimal compares to slime...
14:23:39 <vyom> i am writing some haskell code and i see a pattern but I cant quite figure out what I need. I have a function like (a -> Result b) -> [a] -> ? -> Result [b] I need to figure out what to use in place of '?' to get the desired transformation (Result belongs to typeclass Monad, Function and Applicative)
14:24:04 <mreh> drawShip (Ship { pos = p, ornt = o, shape = s })
14:24:05 <mreh>    = drawShape . shape . (Translate p) . (Rotate (0,0) o) $ s
14:24:14 <mreh> is that pattern match on a record well formed?
14:24:18 <Berengal> @type mapM
14:24:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:24:43 <Berengal> vyom, ^^ that help?
14:25:15 <vyom> Berengal:  awesome! thanks.. it was just at the tip of my brain :).. just could put it together
14:28:26 <arw__> is it normal, that cabal only looks for binaries in $PATH, not in ~/.cabal/bin?
14:28:49 <mike-burns> I put .cabal/bin in my $PATH.
14:28:52 <dcoutts> arw__: yes, you can add ~/.cabal/bin to your path, or tell cabal to install somewhere else
14:29:05 <dcoutts> like ~/.bin if that's already on your path
14:29:23 <arw__> ok. just wanted to be sure, because i just stumbled over that when trying to install yi, and it couldn't find alex, although it was installed.
14:34:18 <seydar> what's up my type bondage loving brothers of the haskell world
14:35:41 <seydar> michaelfeathers: so if you're not using curses for vih
14:35:56 <seydar> michaelfeathers: what are you using? (I haven't had a chance to look at the code, will do so now)
14:37:36 <mrsolo> i got yi running seem easy enough..where can i get some user documentation on keymap?
14:38:03 <seydar> mrsolo: hahaha i had the same issue when i started out
14:38:20 <seydar> mrsolo: you have to look at the source code, but don't worry, it's SUPER simple and clean
14:40:22 <seydar> mrsolo: lemme know if you have trouble
14:40:46 <mrsolo> *.hs files under Keymap?
14:43:24 <seydar> mrsolo: i believe so
14:44:52 <copumpkin> :o
14:47:30 <pumpkin> zomg it's seydar
14:47:58 <seydar> pumpkin: zomg it's pumpkin
14:48:20 <pumpkin> yarly
14:48:32 <seydar> my mom used to call me pupmkin. she had a cat named punk and when i was first born she was still used to saying punk
14:48:42 <seydar> so she came up with a name that would allow for an easy transition
14:48:59 <pumpkin> lol
14:51:14 <pumpkin> seydar: so are you the haskell meister yet?
14:51:23 <seydar> no i've had zero time
14:51:32 <seydar> i was supposed to have time to do some haskell this weekend
14:51:36 <seydar> but then i met this GIRL
14:51:50 <seydar> gentlmen in the room: girls will hurt your programming prowess like none other
14:51:58 <mreh> you met a girl?!
14:52:02 <seydar> s/gentlmen/gentlemen
14:52:02 <jmcarthur_work> your story is unbelievable, sorry
14:52:03 <mreh> how did you do it
14:52:28 <seydar> mreh: well i was just hanging out with these people at a pizzeria
14:52:39 <seydar> and then this girl walks in and sits down with us
14:52:45 <mreh> like cleaning up after them?
14:52:51 <seydar> now she goes to my school, so i know her, but have NEVER spoken a word to her
14:53:03 <seydar> and then boom we just kinda talked for three hours
14:53:13 <seydar> then the next night we all went cosmic bowling
14:53:33 <mreh> does she program haskell too, I never know what to talk about
14:53:51 <slash_> And what happened in reality?
14:54:07 <seydar> i avoided talking about 'gramming, so instead i just said whatever i could to make sure she was talking
14:54:17 <seydar> slash_: i talked to my dog lovingly and pretended she was human
14:54:27 <seydar> no but really, i met a girl and it killed all my haskell time
14:54:36 <pumpkin> dammit
14:54:39 <pumpkin> tell her you're busy
14:54:39 <seydar> what a bitch! she should've been more considerate about my time to gram!
14:54:50 <seydar> instead she had to show up all pretty and stuff
14:54:54 <seydar> totally unappreciated
14:54:57 <pumpkin> tell her to **** off
14:55:00 <seydar> hahaha
14:55:18 <pumpkin> "I'm busy, leave me alone"
14:55:22 <pumpkin> that'll get you even more popular with the ladies
14:55:32 <seydar> orly? lemme write that down
14:55:44 <RayNbow> "return" the girl and make sure you hide the data constructors
14:55:50 <pumpkin> :o
14:56:08 <RayNbow> or making her "pure", that also works :p
14:57:52 <seydar> what's everyone's favorite data structure?
14:58:33 <Vanadium> C arrays :|
14:58:34 <arw__> the 5-tuple.
14:58:35 <RayNbow> seydar: when I'm feeling dirty, IO :p  (or doesn't that one count? :p)
14:58:42 <Boney> convince her you're a motherfucking genious and that programming in haskell will make you ritch once you get your project working.
14:58:47 <Boney> I mean bill gates ritch.
14:58:59 <ikanobori> rich
14:59:02 <Boney> she'll imagine being part of that and leave you too it.
14:59:06 <Boney> sorry.
14:59:17 <Boney> sadly english is my _first_ language.
14:59:34 <mrsolo> rich? right..  php yes... haskell doubt it
14:59:54 <Boney> mrsolo: it doesn't have to be true.  duh.
14:59:54 <ikanobori> Haskell will make you look like RMS.
14:59:55 <pumpkin> seydar: toe trees
15:00:00 <doublethink_work> seydar: finger trees are pretty awesome
15:00:10 <doublethink_work> either that, or the OneTuple!
15:00:13 <doublethink_work> @hackage OneTuple
15:00:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OneTuple
15:00:17 <Boney> seydar: probably any auto-balancing tree.  such as red black trees.
15:00:21 <seydar> what are the one and five tuples?
15:00:22 <pumpkin> wow
15:00:25 <doublethink_work> which is obviously like, the most general data structure there could ever be
15:00:26 <pumpkin> that's a pretty awesome tuple
15:00:53 <seydar> wow man i can find an application in everything
15:01:00 <pumpkin> OneTuple === Identity
15:01:11 <seydar> pumpkin: yea, i figured that out
15:01:14 <doublethink_work> pumpkin: NO WAI
15:01:25 <arw__> not quite as good as ()
15:01:25 <RayNbow> pumpkin: but OneTuple is more EnterPrisey
15:01:31 <pumpkin> doublethink_work: i repurt u 2 thoughtpolice
15:01:42 <doublethink_work> sorry guys, the lolcat inside is coming out slightly
15:01:48 <athos> unfortunately, getting rich by hacking haskell is not to be taken literally, that's a common misunderstanding. what the author meant was: to get mentally richer
15:01:54 <mreh> @faq will Haskell make me more rich than Bill Gates?
15:01:54 <lambdabot> The answer is: Yes! Haskell can do that.
15:01:55 <doublethink_work> it's been a horribly unproductive day here at the office due to network group issues :(
15:02:12 <jmcarthur_work> what, you can't get rich with haskell?!
15:02:14 <ikanobori> I heard a lot of the big NYSE firms use Haskell for their high-frequency trading systems?
15:02:23 <jmcarthur_work> dang, what am i doing here?!!!
15:02:29 <randomwords> jmcarthur_work:  You can only die trying..
15:02:49 <RayNbow> @go haskell in industry
15:02:51 <seydar> @faq will Haskell take care of my dog in the mornings for me?
15:02:51 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
15:02:51 <lambdabot> Title: Haskell in industry - HaskellWiki
15:02:52 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:00 * jmcarthur_work learns ruby on rails lololololol
15:03:09 <seydar> @faq will Haskell tell me what this strange rash is?
15:03:10 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:19 <seydar> oh whew i was worried for a moment
15:03:34 <RayNbow> hmm... what's the Haskell equiv. of RoR? Haskell on Track (HoT)?
15:03:36 <athos> @faq will haskell allow me to launch nuclear missiles?
15:03:36 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:38 <jmcarthur_work> > show seyder'sStrangeRash
15:03:39 <lambdabot>   Not in scope: `seyder'sStrangeRash'
15:03:42 <copumpkin> RayNbow: turbinado
15:03:49 <copumpkin> or HoT
15:03:50 <copumpkin> :P
15:04:05 * RayNbow is co-nfused by copumpkin's appearance
15:04:08 <athos> well, now i'm trouble
15:04:09 <jmcarthur_work> haskell on hails?
15:04:27 <athos> i learned haskell because SPJ always said that you can't launch weapons of mass destruction with haskell
15:04:28 <doublethink_work> haskell blazing trails
15:04:38 <jmcarthur_work> athos, just don't use IO
15:04:49 <copumpkin> zomg an edwardk
15:04:52 <RayNbow> athos: well, you can... but SPJ locked unsafePerformIO in Pandora's box
15:05:10 <copumpkin> damn, I got my hopes up when I saw vili's nick
15:05:11 <copumpkin> that it was wli
15:05:13 <jmcarthur_work> unsafeUnlockUnsafePerformIO
15:05:37 <doublethink_work> yo dawg, I heard you like side effects, so we put side effects in ur laziness so you can launch missiles whenever you're forced
15:05:39 <athos> RayNbow: heh, what a clever man that is. i bet SPJ took the red pill
15:05:42 <seydar> how does unsafePerformIO work?
15:05:50 <doublethink_work> seydar: deep magic
15:05:55 <RayNbow> @src unsafePerformIO
15:05:56 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
15:06:09 <edwardk> copumpkin: yo
15:06:11 <copumpkin> onoes, the real world
15:06:16 * copumpkin hides
15:06:22 <jmcarthur_work> exposed!
15:06:23 <doublethink_work> that tv show is terrible.
15:06:25 <RayNbow> don't trust lambdabot, she's spreading lies about the IO magic
15:06:28 <seydar> edwardk: are you stuck in the mountains as well?
15:06:45 <copumpkin> seydar: you should come down to boston tomorrow for the haskell user group!
15:06:57 <edwardk> seydar: nah i'm down in boston
15:07:01 <seydar> shise monkey, tomorrow?
15:07:07 <seydar> i might be able to, or i might now
15:07:09 <seydar> not*
15:07:26 <copumpkin> that's a tautology isn't it?
15:07:28 <edwardk> seydar: you should follow copumpkin down out of the mountains and visit civilization
15:08:03 <seydar> edwardk: it's plenty hot up here. down there it will only be hotter
15:08:20 <edwardk> it'll be at MIT, there will be smart people and stuff, and well, there will also be me, but don't hold that against the smart people.
15:08:57 <copumpkin> lol
15:09:11 <athos> copumpkin: what about your nickname?
15:09:16 <athos> are you stuck in some kind of comonad?
15:09:21 <leimy_> conal: around?
15:09:24 <copumpkin> athos: nah, my arrows get reversed occasionally
15:09:30 <copumpkin> not sure how it happens
15:09:34 <edwardk> he just lost a dual with a pumpkin.
15:09:39 <edwardk> it was messy
15:09:41 * copumpkin cries
15:09:51 <athos> > extract copumpkin
15:09:53 <lambdabot>   Not in scope: `copumpkin'
15:10:00 <seydar> copumpkin: can you encourage linden to accept my friend request on fb?
15:10:01 <athos> lambdabot's a bitch
15:10:04 <copumpkin> instance Copointed Copumpkin
15:10:13 <copumpkin> seydar: I only barely know her :P
15:10:21 <edwardk> copumpkin: does that mean you are of higher kind?
15:10:29 <doublethink_work> > let extract = drop 2 in extract 'copumpkin'
15:10:30 <copumpkin> edwardk: only the highest kinds for me
15:10:31 <lambdabot>   <no location info>:
15:10:31 <lambdabot>      lexical error in string/character literal at chara...
15:10:38 <doublethink_work> > let extract = drop 2 in extract "copumpkin"
15:10:39 <lambdabot>   "pumpkin"
15:10:42 <copumpkin> hawt
15:10:52 <athos> haxx!
15:11:19 <copumpkin> anyone know anything about "combinatorial algebra"? or did I just coin the term?
15:11:20 <doublethink_work> boxx!?
15:11:29 <RayNbow> :t extract
15:11:30 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
15:11:37 <jakewheat> hello all, i'd like to announce a work in progress sql parser in haskell
15:11:39 <copumpkin> whoa, that's not the extract I was thinking of
15:11:44 <jakewheat> code here: http://launchpad.net/hssqlppp/prealpha/prealpha1/+download/snapshot-180809.zip
15:11:44 <RayNbow> @hoogle extract
15:11:45 <lambdabot> No results found
15:11:51 <RayNbow> :i extract
15:11:51 <conal> leimy_: yeah
15:11:57 <RayNbow> @index extract
15:11:58 <lambdabot> bzzt
15:12:01 <edwardk> copumpkin: it exists
15:12:20 <leimy_> conal: if you were presented with a problem that looked like something like an advanced "expect" implementation might work, would you reach for FRP? :-)
15:12:37 <copumpkin> zomg http://www.mscs.dal.ca/~faridi/research/inverse_systems/algebracombinatorics2009.html
15:12:43 * conal parses ...
15:13:02 <conal> leimy_: what's "expect"?
15:13:08 <doublethink_work> unix tool
15:13:16 <edwardk> conal obviously needs a faster parallel parser ;)
15:13:21 <doublethink_work> @go man extract
15:13:22 <lambdabot> No Result Found.
15:13:26 <doublethink_work> :(
15:13:32 <leimy_> Expect is a language based on TCL that would allow one to match a pattern and respond with a follow up command.
15:13:49 <leimy_> people would use it to automate tasks with FTP and telnet capable devices/services
15:14:00 <edwardk> conal: unix tool/library for automated interaction on sockets, or with commands via pipes, etc. pattern recognition/response stuff
15:14:12 <conal> hm.
15:14:13 <copumpkin> seydar: quit thinking about girls and work on haskell!
15:14:31 <leimy_> at any rate, I'm basically trying to program a managed power strip via serial that I have to log into and do SMASH CLP commands to.
15:14:38 <leimy_> it's like having a shell with a filesystem on the other side.
15:14:54 <seydar> copumpkin: not at a computer with haskell so i might as well
15:14:57 <RayNbow> @faq Can Haskell be used to build artificial girls?
15:14:58 <lambdabot> The answer is: Yes! Haskell can do that.
15:14:59 <leimy_> I'm thinking I might just use expect, but in some ways, that may not be good enough.
15:15:20 <copumpkin> we need an online "AJAX" ghci like _why's online irb
15:15:24 <copumpkin> that'd be cute
15:15:29 <athos> actually there's a strong connection between girls and haskell
15:15:46 <copumpkin> is there a functor between Girl and Hask?
15:15:55 <edwardk> copumpkin: or he could think about Haskell as a girl: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
15:15:56 <Berengal> > text "copumpkin, you mean something like lambdabot?"
15:15:56 <randomwords> Forgetful
15:15:57 <lambdabot>   copumpkin, you mean something like lambdabot?
15:16:10 <copumpkin> > text "Berengal: yes, but with a web interface"
15:16:11 <lambdabot>   Berengal: yes, but with a web interface
15:16:31 <Berengal> > text "copumpkin, like a web-based irc-like client of sorts?"
15:16:32 <lambdabot>   copumpkin, like a web-based irc-like client of sorts?
15:16:43 <Taejo> copumpkin: it's a Galois connection
15:16:51 <Saizan> > text "copumpkin: there actually was a web-interface, but it bitrotted"
15:16:52 <lambdabot>   copumpkin: there actually was a web-interface, but it bitrotted
15:16:57 <copumpkin> > text "lighter-weight than something like that"
15:16:58 <lambdabot>   lighter-weight than something like that
15:17:06 <copumpkin> > text "Saizan: that's a pity"
15:17:07 <lambdabot>   Saizan: that's a pity
15:17:19 <Saizan> heh
15:17:22 <seydar> text "this is doubling the traffic in the channel"
15:17:23 <copumpkin> Taejo: zomg
15:17:32 <leimy_> conal: in some ways, it's sort of "awk-like".  When you see pattern "blah" do action "foo"
15:17:37 <copumpkin> > text "seydar: lern 2 lambdabot kthxbai"
15:17:38 <conal> leimy_: hard to tell.  looks like 'expect' is imperative, so if that's what you want, i wouldn't recommend frp.
15:17:39 <lambdabot>   seydar: lern 2 lambdabot kthxbai
15:17:46 <Saizan> it'd probably be easy to restore, having a server to put it up
15:17:49 <leimy_> conal: it's somewhat imperative.
15:17:52 <conal> leimy_: but maybe you can look at the problem functionally.
15:18:07 <copumpkin> Saizan: I have a VPS we could use, and a couple of haskell-related domain names to host it on
15:18:14 <leimy_> actually for my purposes I have to be able to figure out what precisely the state is, possibly trying to reset the device back to the beginning state to get my stuff to run.
15:18:26 <leimy_> and from there I'm trying to keep it mostly stateless.
15:19:53 <HugoDaniel> hi
15:20:02 <conal> HugoDaniel: hi
15:20:28 <seydar> > text "copumpkin: imma own yo face"
15:20:29 <lambdabot>   copumpkin: imma own yo face
15:20:34 <copumpkin> lol
15:20:41 <seydar> hm, i wonder
15:20:53 <seydar> text "/msg copumpkin wazzap fool"
15:20:53 <copumpkin> I bet you do
15:20:57 <copumpkin> nope
15:21:04 <copumpkin> won't work
15:21:08 <seydar> what why not
15:21:23 <copumpkin>  PRIVMSG /MSG copumpkin wazzap fool ?
15:21:36 <olsner> I think you're doing it wrong
15:21:47 <seydar> how do i do it right then
15:21:57 <copumpkin> using the @msg command on lambdabot
15:22:52 <seydar> nonono LAME
15:23:08 <copumpkin> no can haz hax 4 lambdabot kthx
15:23:08 <seydar> @msg copumpkin imma make you my dog's bitch
15:23:09 <lambdabot> Not enough privileges
15:23:22 <seydar> @tell copumpkin imma make you my dog's bitch
15:23:23 <lambdabot> Consider it noted.
15:23:50 <seydar> so what are the runtimes for zippers?
15:24:05 <seydar> this is the datastructure, not how long it takes for my to unzip my pants
15:24:13 <copumpkin> moving around should be constant time
15:24:14 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
15:24:58 <fergie> does anyone know a good beginners tutorial on how to use the curl library?
15:25:10 <seydar> copumpkin: does it bring anything unique or useful to the table?
15:25:33 <copumpkin> seydar: a cursor-like view of a datastructure
15:26:06 <seydar> how can it make things faster, though? or is it just more understandable
15:26:38 <copumpkin> well if you had a list and wanted to change one element of it
15:26:39 <Saizan> you can replace the value at the position you are currently in constant time
15:27:04 <Saizan> "currently are"
15:27:53 <Saizan> which would require you to reconstruct all the parent nodes normally
15:28:21 <seydar> oh, so all this black magic only works on linked lists
15:28:29 <seydar> arrays would bring the system crashing down
15:28:37 * erikc <3 parsec
15:28:49 <copumpkin> seydar: it works on a bunch of datastructures
15:29:03 <copumpkin> but arrays aren't very elegant datastructures
15:29:06 <Saizan> it works on arbitrary trees
15:29:30 <seydar> ok i hypothetically have a huge confession to make
15:29:36 <leimy_> conal: I guess I'm really wondering if the whole control of this thing could be done via some version of "interact" :-)
15:29:41 <seydar> hypothetically speaking, this friend of mine
15:29:45 <seydar> who's really more of a friend of a friend
15:29:52 <leimy_> because I'm trying to automate what is essentially an interactive program.
15:30:19 <conal> leimy_: ah!  that'd be my first inclination
15:30:26 <leimy_> conal: yeah.
15:30:29 <seydar> doesn't understand what trees are really useful for other than inserting elements into a binary tree to get a predictable sorted result
15:31:02 <copumpkin> where do you think fruit comes from?
15:31:29 <Saizan> read okasaki's thesis :)
15:31:44 <conal> leimy_: and if you're interested in interact, check out TV, which generalizes interact to a simple algebra (composable).
15:32:07 <leimy_> conal: In fact, since I'm basically going to be talking to it over a telnet-ish interface.  So all I need is something like interact on a handle (which I know how to do)
15:32:16 <leimy_> conal: oh yeah, you pointed me at TV before.
15:32:21 <leimy_> I forgot about that.
15:32:44 <leimy_> TV is Tangible Value right?
15:32:47 <conal> yeah
15:33:00 <conal> leimy_: interact is the special case of unary functions.  TV generalizes interact to non-functions and to curried functions.
15:33:09 <conal> oh -- and beyond IO
15:33:11 <seydar> Saizan: but in general, what are trees good for?
15:33:19 <seydar> hypothetically speaking
15:33:27 <leimy_> conal: So it might help me with dealing with certain states of the input stream?
15:33:41 <leimy_> well the "input stream's contents" anyway :-)
15:33:52 <Saizan> all kinds of datastructures where you want non-linear access and sharing of subparts
15:34:05 <Saizan> arrays are efficient only if mutable
15:34:13 <copumpkin> you get implicit trees in most ADTs anyway
15:34:21 <Saizan> (and if you don't need persistence)
15:34:26 <conal> leimy_: if you have just functions, and if they're unary, and if you want IO for I/O, then interact would give you as much as TV.
15:34:55 <leimy_> conal: interact might be enough then.
15:35:00 <leimy_> but I'll look into TV all the same
15:35:20 <conal> leimy_: cool.
15:35:28 <leimy_> conal: and thanks again! :-)
15:35:30 <seydar> Saizan: that makes sense, thanka
15:35:42 <conal> leimy_: :)
15:36:48 <jakewheat> Hello all, sorry to bother you but can anyone on this channel help me with a problem posting to haskell-cafe? I get 'You are not allowed to post to this mailing list' when I try to post (I've probably done something wrong.) I'm posting from jakewheatmail@gmail.com.
15:37:22 <copumpkin> jakewheat: did you subscribe to the list using that address?
15:37:55 <jakewheat> yes, but I tried to post first before subscribing and then again after subscribing
15:40:26 <seydar> does haskell ever have to worry about write barriers?
15:41:03 <erikc> getting to use some haskell for the first time in a couple months
15:41:08 <erikc> it's like coming home to logic!
15:41:32 <erikc> seydar: what kind of write barriers?
15:41:51 <seydar> object write barriers, though i fear to say object in this channel
15:42:29 <jakewheat> erikc: my sql parser uses parsec
15:43:16 <jfoutz> conal: your denotational design with type class morhpisms was really nice. thank you.
15:43:26 <copumpkin> seydar: you don't really need them
15:43:53 <seydar> copumpkin: yargh, i didn't think so
15:44:11 <copumpkin> well, some of the GC fixes for mutable arrays call for them I think
15:44:23 <seydar> what are trees NOT good for?
15:44:24 <copumpkin> I'm not sure what the current idea to resolve that is though
15:44:28 <conal> jfoutz: i'm glad you like it.  :)  thx for the feedback.
15:45:27 <conal> jfoutz: i stumbled onto the TCM pattern when i was fiddling with denotational semantics for FRP a couple years ago.  i like to tweak definitions in the direction of poetry, and that pattern kept coming up.
15:46:31 <conal> beauty gives me stronger design confirmation than proofs & tests.
15:46:39 <leimy_> conal: reverseT = tv (oTitle "reverse" defaultOut) reverse  <-- says run the "reverse" function on the data from tv, with title "reverse" and send output to the defaultOut output "device"?
15:46:48 <jfoutz> conal: coming up with *some* sort of design is the number one problem i have with functional programming i get stuff working, but everything looks so horrible. I think if i really focus on good up front design, i'll do so much better.
15:47:33 <conal> leimy_: nearly.  the *whole* of reverse, not just its output gets the default visualization.
15:47:59 <conal> leimy_: for functions, the default output (visualization) is a "lambda" with default input for the domain and default output for the range.
15:48:27 <conal> jfoutz: totally.  go for it.
15:49:29 <conal> jfoutz: and denotational semantics is the clearest & deepest software design tool i know.
15:49:43 <conal> jfoutz: although i don't think it's taught as such.
15:50:25 <conal> jfoutz: btw, have you read luke palmer's blog post on "semantic design"?
15:50:37 <conal> @go luke palmer semantic design
15:50:39 <lambdabot> No Result Found.
15:50:46 <seydar> @go johnny go go go
15:50:47 <lambdabot> http://www.youtube.com/watch?v=uMY5VGYh2Go
15:50:47 <lambdabot> Title: YouTube - Go Johnny Go - Chuck Berry
15:50:49 <conal> http://www.google.com/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Flukepalmer.wordpress.com%2F2008%2F07%2F18%2Fsemantic-design%2F&ei=w96JSrj1HIHQsQPpk-TWDQ&usg=AFQjCNEWAY_O7OBEK2QAAA5DuxHJjZWtMw&sig2=qN1p7Zrb-Eu-MWxBic8xkA
15:50:52 <conal> oops!
15:50:57 <jfoutz> conal: I did, the day you were talking about object representation of continuous time.
15:51:02 <conal> http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
15:51:06 <conal> great
15:53:26 <jfoutz> conal: denotational semantics wasn't tought to me in any sense. a fair bit of design patters and object decomposition. probably the most useful design class i had was compilers, the prof just kept driving home the idea of simplification.
15:54:19 <leimy_> I'm beginning to wish Linux, like Plan 9, had bidirectional pipes :-)
15:54:24 <jfoutz> asserted every line of code adds (total lines of code) * epsilon bugs. eventually you reach critical mass, and every line adds a bug.
15:55:07 <conal> jfoutz: wow.  lucky you to have had that prof.
15:56:30 <seydar> jfoutz: who was your prof?
15:56:43 <jfoutz> dr. ackley.
15:56:47 <conal> that formula makes sense to me for imperative (IO) code.  there can be quadratically many interactions among lines of code.
15:57:43 <conal> hm.  maybe more so for haskell IO code than for C, since haskell code can be much more tight.
15:57:55 <seydar> jfoutz: does he have a homepage?
15:57:56 <conal> (as an upper bound for # of interactions, i mean)
15:58:12 <jfoutz> he is an amazing lecturer. Stuck teaching c++ to 80 kids, in the 4th week he pointed at each of us and called us by name. (not the compiler class)
15:58:32 <conal> jfoutz: nice :)
15:58:35 <jfoutz> http://www.cs.unm.edu/~ackley/
16:17:49 <copumpkin> pretty quiet
16:18:20 <randomwords> until you ruined it
16:18:28 <copumpkin> I made it better
16:25:22 <Vanadium> @pl \(a, b) -> a >>= \x -> b >>= \y -> return (x, y)
16:25:23 <lambdabot> uncurry (liftM2 (,))
16:25:28 <Vanadium> Figures.
16:25:47 <skorpan> digits!
16:26:12 <copumpkin> would it make sense to say that there's a forgetful functor (or two) from semirings to monoids? is there a category of semirings and one of monoids?
16:28:03 <randomwords> Presumably two?
16:28:23 <Vanadium> Is there a function in the prelude that takes a string and returns the same string minus surrounding whitespace?
16:28:39 <copumpkin> Vanadium: nope, but I'm quite proud of my efficient golfed one
16:28:54 <copumpkin> takes me a while to remember it though
16:28:56 <Vanadium> Ahah, now I am curious
16:28:58 <randomwords> efficient and golfed are mutually exclusive
16:29:20 <Saizan> the category of algebraic structure X is generally where the arrows are X homomorphisms
16:29:29 <copumpkin> > init . tail . groupBy isSpace . (" " ++) . (++ " ") $ "  moo    baa       "
16:29:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Bool.Bool'
16:29:34 <Philonous> Vanadium: dropWhile (isSpace) . reverse . dropWhile (isSpace) . reverse
16:29:44 <inimino> not in APL
16:29:48 <copumpkin> > join . init . tail . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "  moo    baa       "
16:29:50 <lambdabot>   "moo    baa"
16:29:53 <copumpkin> there
16:30:29 <copumpkin> Saizan: yeah, I thought so, just hadn't heard of the category of semirings before, so was wondering if there was some reason
16:30:35 <shapr> @yow !
16:30:35 <lambdabot> LBJ, LBJ, how many JOKES did you tell today??!
16:30:51 <Vanadium> Thanks :3
16:31:01 <copumpkin> Vanadium: mine's lazier :P
16:31:12 <shapr> I'm looking for any suggestions for what to say about haskell-mode tomorrow.
16:31:30 <shapr> I'm covering the built-in features, anything else?
16:31:35 <Axman6> "Haskel: FUCKYEAH!"
16:31:39 <copumpkin> lol
16:31:42 <Axman6> ll*
16:31:55 <erg> shapr: i'm giving a factor presentation tomorrow to the twin cities lisp group
16:31:56 <copumpkin> Axman6: *haskle, like eu-prleu-prpeu would say
16:32:02 <erg> shapr: who are you presenting to?
16:32:07 <Axman6> heh
16:32:09 <copumpkin> erg: bostonians!
16:32:11 <shapr> I'm presenting to the Boston Area Haskell User's Group
16:32:17 <shapr> Supposedly copumpkin will be there.
16:32:21 <copumpkin> yay!
16:32:21 <shapr> But Riastradh will not.
16:32:26 <copumpkin> shapr: why not?
16:32:27 <Axman6> ok, got to get going, picking up stuff from the post office. yay new knife :D
16:32:42 <copumpkin> shapr: you associate me with Riastradh btw? :o
16:32:56 <shapr> emacs integration projects other than haskell-mode are: hs-lint, shim and scion. Did I miss anything?
16:33:08 <shapr> copumpkin: Not really, just saying...
16:33:16 <shapr> Riastradh is unable to show up tomorrow, dunno why.
16:33:24 <copumpkin> aw, does he usually go?
16:33:24 <shapr> erg: Where will you present?
16:33:32 <erg> common roots cafe in minneapolis
16:33:50 <shapr> Personally, I'm pretty excited that I get to talk about emacs in the MIT AI Lab Reading Room, that's like... where emacs got started :-)
16:33:50 <erg> slava has done all the other talks, so i volunteered for this one :)
16:34:30 <shapr> Slava does have much to say about factor.
16:34:37 <shapr> Makes sense, since he's the primary author.
16:34:50 <erg> i have the second highest number of patches!
16:34:54 <sm> shapr: you've got hoogle lookups ? part of haskell-mode I guess
16:35:05 <shapr> sm: Yeah, though it seems very few people know about that.
16:35:13 <shapr> And the interactive :type and :info commands.
16:35:21 <erg> shapr: i've met dons
16:35:29 <shapr> ooh, I'm jealous, I haven't!
16:35:30 <sm> it's darn useful when coding locally, where it can call a browser
16:36:05 <erg> http://factorcode.org/dharmatech/erg-dons-latte.jpg me and dons
16:36:09 <shapr> xerox had ghci on acid working at one point, it was all the spiffy lambdabot commands in ghci.
16:36:17 <shapr> I don't know if it still works though.
16:36:19 <sm> nothing to do with haskell-mode, but handy in an emacs side buffer: run sp in auto-recompile mode
16:36:36 <shapr> The sgml tool?
16:36:42 <shapr> erg: Nice!
16:36:55 <sm> and I copied someone's blog on using flymake with ghc, haven't had time to try it but I can dig it up
16:37:00 <shapr> I have to wear one of my Haskell t-shirts tomorrow.
16:37:04 <sm> in fact I did try it and didn't get it working
16:37:04 <shapr> I'll wear the EuroHaskell t-shirt.
16:37:09 <shapr> sm: Ooh yes!
16:37:54 <sm> http://www.emacswiki.org/emacs/FlymakeHaskell is what I found just now
16:38:03 * shapr reads
16:39:14 <sm> google finds a video demo also
16:39:29 <shapr> That should be useful.
17:22:33 <monochrom> I want newbies!
17:22:51 <newbie> can u lern me a haskle?
17:22:52 <randomwords> #haskell slash-fic coming up..
17:23:17 <monochrom> I can download haskell to your brain through a usb port.
17:24:03 <newbie> wuts a usb port?
17:24:11 * benmachine swallows a hub
17:25:13 <monochrom> a usb port lets you learn haskell and recharge batteries
17:25:25 <Adamant> there was an old newbie who swallowed a hub, we don't know if when it comes out which way it will flub, and there's the rub
17:25:41 <edwardk> important, nowadays that haskell comes with batteries included
17:26:26 <monochrom> http://hackage.haskell.org/platform/  is haskell with batteries. Needs usb port to learn and recharge.
17:27:52 <newbie> :o
17:27:58 <newbie> wut r batries?
17:29:16 <monochrom> Batteries satisfy the following axioms...
17:33:32 <leino> I'm sort of a newbie as well, and I wonder why haskell seems to be so popular among "math-types"
17:33:59 <dons> Eleven Reasons to use Haskell as a Mathematician http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html
17:34:25 <leino> thanks
17:35:02 <leino> that blog is already in my favourites, but I haven't gotten around to reding much of it yet
17:35:25 <monochrom> It's popular among rational people.
17:36:14 <dons> do you remember the programmers survey that founds more athiests as a % in the haskell community, than any other language group?
17:36:17 <dons> also witches.
17:36:42 <pikhq> dons: The first I can see. The second confuses me greatly.
17:36:53 <jfoutz> hahaha. that's awesome.
17:36:56 <monochrom> That is only because I didn't take the survey. I am theist.
17:37:23 <leino> wizards use lisp though, right?
17:37:39 * pikhq is a weird sort of Christian
17:37:52 <randomwords> Although I seem to remember someone saying somethin along the lines of "Whoever designed the numeric classes in prelude knew just enough math to be dangerous"
17:38:04 <monochrom> In http://groups.google.com/group/comp.lang.functional/msg/f2b477068bfc05aa I conjecture why theists may have an easier time learning recursion.
17:38:19 <Lemmih> pikhq: The kind that worships a zombie?
17:38:31 <pikhq> Lemmih: Hah.
17:39:03 <pikhq> Try the one that thinks that "be good to each other" is something you should actually do.
17:39:07 <pikhq> s/one/kind/
17:39:10 <pikhq> ;)
17:39:43 <luite> is there an easy way to have cabal generate haddock documentation for all installed packages?
17:41:01 <ray> monochrom, interesting
17:41:48 <monochrom> Just two data points. :)
17:43:16 <jfoutz> I always liked card's bit in _children of the mind_ about how the gods always provide a scientific explination, and it must be found or they would be naked, requireing no faith to be seen.
17:44:28 <jfoutz> but that is probably *not* haskell.
17:47:37 <dcoutts> luite: for all packages you install subsequently, yes. For all packages already installed, not without re-installing them.
17:47:39 <ManateeLazyCat> How to use Text.Regex.TDFA replace all match string with given string?
17:48:13 <randomwords> I wish cabal handled installing of profiling versions of packages better
17:49:15 <dcoutts> so do I :-)
17:49:31 <dcoutts> I wish ghc-pkg could tell Cabal if the profiling version was present or not
17:49:51 <dcoutts> we've got a longer term plan to do it better
17:50:18 <dcoutts> by registering each "way" separately (profiling is a "way")
17:50:27 <randomwords> That makes sense
17:51:17 <pikhq> @hoogle fix
17:51:17 <lambdabot> Data.Function fix :: (a -> a) -> a
17:51:17 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:51:17 <lambdabot> module Control.Monad.Fix
17:51:50 <monochrom> Would you like a fix of a tutorial on fix? :)
17:52:10 <pr> hehe
17:54:18 <luite> ah yes, that would be great. I have cabal set to build profiled versions of everything, because it's such a hassle to reinstall all dependencies when you want to profile just one thing
17:54:43 <randomwords> Especially when you have to chase a chain of 5/6 dependencies
17:54:50 <pikhq> monochrom: I was just trying to remember where the import was, and was too lazy to open up Hoogle in my browser.
17:55:10 <monochrom> I think Data.Function is now the preferred one.
17:57:13 <benmachine> hmm, when I cabal sdist it creates a tarfile with src/Main.hs in it (Main-Is) but not the rest of src/ (Hs-Source-Dirs)
17:57:40 <dcoutts> benmachine: sounds like you didn't list the "other-modules: " that your program uses.
17:57:50 <benmachine> probably you are right
17:58:06 <benmachine> it builds fine though :(
17:58:48 <benmachine> aha, I see
17:58:50 <benmachine> thanks
18:06:01 <ezyang> Hallo all!
18:21:59 <Vanadium> Is there a Haskell equivalent to printf that gets away with not quite as much type hackery?
18:23:15 <ezyang> Vanadium: Aww, type hackery is the best part!
18:26:37 <jfoutz> > Text.Printf.printf "%d" (23::Int)
18:26:38 <lambdabot>   Add a type signature
18:27:20 <jfoutz> > (Text.Printf.printf "%d" (23::Int)) :: String
18:27:22 <lambdabot>   "23"
18:27:52 <pikhq> :t Text.Printf.printf
18:27:53 <lambdabot> forall r. (PrintfType r) => String -> r
18:28:15 <pikhq> Figures.
18:28:24 <pikhq> :src PrintfType
18:28:28 <pikhq> @src PrintfType
18:28:28 <lambdabot> Source not found. You type like i drive.
18:28:42 <ManateeLazyCat> @hoogle matchAll
18:28:42 <lambdabot> No results found
18:28:49 <ManateeLazyCat> @type matchAll
18:28:50 <lambdabot> forall regex source. (RegexLike regex source) => regex -> source -> [MatchArray]
18:30:39 <Makoryu> Do you have to enable an extension in order to use RegexLike?
18:32:02 <ManateeLazyCat> Makoryu: What's extension?
18:32:26 <Makoryu> A language extension, I mean
18:32:48 <Makoryu> There's one for multiple-type-variable typeclasses
18:33:30 <ManateeLazyCat> Text.Regex.TDFA> matchAllRegex source regex = matchAll (makeRegex regex) source
18:33:41 <ManateeLazyCat> Text.Regex.TDFA> @let matchAllRegex source regex = matchAll (makeRegex regex) source
18:33:42 <aavogt> the class RegexLike
18:33:50 <ezyang> I seem to recall a blog post/article that made a small DSL for printf style expressions
18:33:52 <ManateeLazyCat> @let matchAllRegex source regex = matchAll (makeRegex regex) source
18:33:54 <lambdabot>  Defined.
18:34:01 <ManateeLazyCat> :t matchAllRegex
18:34:02 <lambdabot> forall compOpt execOpt regex source1 source. (RegexMaker regex compOpt execOpt source, RegexLike regex source1) => source1 -> source -> [MatchArray]
18:35:20 <ManateeLazyCat> ghc got: Could not deduce (RegexLike regex source1)
18:35:35 <ManateeLazyCat> Makoryu: Which extension i need add in source code?
18:35:46 <ManateeLazyCat> for multiple-type-variable
18:35:58 <aavogt> you don't need to compile it with -XMultiParamTypeClasses, to use a library function that uses it
18:36:48 <ManateeLazyCat> :t matchAllRegex
18:36:49 <lambdabot> forall compOpt execOpt regex source1 source. (RegexMaker regex compOpt execOpt source, RegexLike regex source1) => source1 -> source -> [MatchArray]
18:37:00 <aavogt> but you might have to enable that option if you want to write type signatures like that one
18:38:29 <ManateeLazyCat> aavogt: Still can't work when i enable that option.
18:38:45 <ManateeLazyCat> aavogt: GHC got "Could not deduce"
18:39:13 <aavogt> Vanadium: there's a template haskell printf (at least mentioned in the TH papers and ghc documentation) which may or may not count as type hackery...
18:39:48 <ManateeLazyCat> aavogt: If i don't write type signature, GHC can pass, otherwise compile failed.
18:39:54 <ray> haskell *is* type hackery
18:39:58 <pikhq> aavogt: Isn't that a bit of Olegery?
18:41:20 <ray> the magic in Text.Printf seems to be instance (PrintfArg a, PrintfType r) => PrintfType (a -> r)
18:41:28 <ray> nothing too esoteric
18:42:11 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8274#a8274
18:42:24 <glguy> I can see this being useful when parsing and unparsing binary formats
18:42:32 <glguy> with tagged values
18:44:07 <aavogt> pikhq: I don't think the TH printf is by Oleg
18:44:33 <pikhq> Eh.
18:44:39 <ray> oleg's printf isn't TH
18:44:50 <ray> it is crazy and i don't understand it
18:45:07 <pikhq> Ah, yeah. That would be Oleg.
18:45:57 <ray> apparently it avoids possible blowing up at runtime (which can happen with Text.Printf because the type system doesn't know what format specifiers are in your string)
18:46:12 <aavogt> yeah, the one in TH is pretty straightforward: you use it like  $(printf "formatstring %d %f") decimal float -- and then it writes the function for you, which gets checked at compile time
18:46:23 <ski> (isn't it just the type class trick ?)
18:49:38 <ManateeLazyCat> aavogt: GHC can't pass when i enable "{-# LANGUAGE MultiParamTypeClasses #-}"
18:51:28 <ManateeLazyCat> aavogt: I missing something?
18:57:38 <chessguy> hmm. easiest way to decide if everything in a (non-infinite) list is equal?
18:57:46 <copumpkin> == ?
18:57:56 <aavogt> assume == is transitive?
18:57:57 <ezyang> sounds... like a reduce?
18:58:10 <copumpkin> > [1..10] == [1..11]
18:58:12 <lambdabot>   False
18:58:21 <glguy> Ithink he means
18:58:24 <glguy> [1,1,1,1,1,1]
18:58:25 <chessguy> copumpkin, no, i want to see if every element is the same
18:58:26 <glguy> vs
18:58:29 <ezyang> oh, I think you want all
18:58:29 <copumpkin> oh
18:58:29 <glguy> [1,2,2,1,1]
18:58:33 <Cale> chessguy: uncomputable
18:58:34 <aavogt> :t all (uncurry (==)) . ap zip tail
18:58:35 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:58:51 <Cale> chessguy: If they *are* all equal, you can't tell, anyway.
18:58:52 <copumpkin> > (==1) . length . group $ [1..10]
18:58:53 <lambdabot>   False
18:59:10 <chessguy> Cale, what are you talking about?
18:59:16 <Philonous> Cale: Non-infinite
18:59:16 <ezyang> What semantics do you want if the list is empty?
18:59:23 <Cale> Oh, non-infinite :)
18:59:23 <copumpkin> > null . tail . group $ replicate 10 1
18:59:24 <lambdabot>   True
18:59:29 <ezyang> Also, a less clever implementation might be...
18:59:32 <copumpkin> > null . tail . group $ replicate 10 1 ++ [4]
18:59:33 <lambdabot>   False
18:59:35 <chessguy> ezyang, i don't care, because i'm going to check that separately
18:59:54 <chessguy> @type null . tail . group
18:59:56 <lambdabot> forall a. (Eq a) => [a] -> Bool
19:00:01 <chessguy> that's cute
19:00:11 <c_wraith> :t group
19:00:12 <Cale> yeah, group is an effective way to do it
19:00:13 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
19:00:19 <copumpkin> drop 1 might be better
19:00:27 <Cale> especially as it handles the empty case nicely
19:00:30 <Cale> > group []
19:00:31 <lambdabot>   []
19:00:33 <chessguy> @type drop 1 . group
19:00:35 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
19:00:37 <copumpkin> but then tail goes and messes it up again
19:00:48 <Cale> right, drop 1 is better at that :)
19:00:59 <copumpkin> @type null . drop 1 . group
19:01:00 <lambdabot> forall a. (Eq a) => [a] -> Bool
19:01:09 <chessguy> actually, i know the list is non-empty too
19:01:24 <ezyang> I feel like group does too much work
19:01:27 <copumpkin> it sort of seems like you'd want it to be undefined for empty lists
19:01:45 <ray> every element of an empty list is equal, though
19:01:47 <chessguy> anyway, it doesn't matter, this is a dirty little script
19:01:57 <chessguy> null . tail . group is fine
19:02:08 <c_wraith> yeah, group is kind of bad if there are a lot of different values.  I guess it doesn't matter if the list is short
19:02:13 <aavogt> ManateeLazyCat: I can't figure it out either
19:02:16 <ezyang> > let xs = [1,2,3,4] in any ((==) (head xs)) xs
19:02:18 <lambdabot>   True
19:02:22 <ezyang> erm
19:02:26 <copumpkin> c_wraith: it won't go any further than the first different value
19:02:28 <ray> copumpkin: and since every element of an empty list is equal.. zomg function equality
19:02:35 <ezyang> let xs = [1,2,3,4] in all ((==) (head xs)) (tail xs)
19:02:39 <c_wraith> @src group
19:02:41 <lambdabot> group = groupBy (==)
19:02:41 <ray> as long as there aren't any functions to compare
19:02:42 <ezyang> > let xs = [1,2,3,4] in all ((==) (head xs)) (tail xs)
19:02:44 <lambdabot>   False
19:02:47 <c_wraith> @src groupBy
19:02:48 <lambdabot> groupBy _  []       =  []
19:02:48 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:02:48 <lambdabot>     where (ys,zs) = span (eq x) xs
19:02:51 <copumpkin> > null . tail . group [1, 2, undefined]
19:02:52 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:02:56 <copumpkin> > null . tail . group $ [1, 2, undefined]
19:02:57 <lambdabot>   False
19:03:09 <copumpkin> so it won't do any more work
19:03:19 <ray> > null . tail . group $ [undefined, 2, 3]
19:03:21 <ezyang> ahh, nice laziness :-)
19:03:21 <lambdabot>   * Exception: Prelude.undefined
19:03:39 <ezyang> I approve.
19:03:53 <copumpkin> :)
19:04:10 <copumpkin> ray: fine, just mock me cause of my semialgorithm :P
19:04:13 <copumpkin> :(
19:04:14 <chessguy> @index group
19:04:15 <lambdabot> Data.List
19:04:16 * copumpkin weeps
19:04:28 * ray is the Totality Police
19:04:34 <copumpkin> onoes
19:04:39 <ezyang> dun dun dun
19:04:46 <ray> is that a non-total function i see there
19:05:01 <ray> i find you guilty of partiality
19:05:04 <copumpkin> lol
19:05:13 <copumpkin> I'm not convinced my enumerator of functions is correct
19:05:27 <copumpkin> in fact, I'm reasonably sure it's wrong
19:05:28 <ray> i sentence you to hang by the neck until undefined
19:05:42 <ray> well, it doesn't work at all for Partials
19:05:48 <copumpkin> well, even excluding those
19:05:56 <ray> try enumerate [Partial () -> Partial ()]
19:05:57 <copumpkin> it's too simplistic
19:05:58 <Cale> > null . drop 1 . group $ replicate 1000 0 ++ 1 : repeat 0
19:06:00 <lambdabot>   False
19:06:02 <ray> :: even
19:06:23 <copumpkin> like if I enumerate :: [(Int -> Int) -> Bool]
19:06:34 <copumpkin> it'll happily generate a bunch of random ****
19:06:42 <ezyang> I wonder what ap zip tail does
19:06:45 <copumpkin> so I need to think more carefully about it
19:06:49 <ezyang> > ap zip tail [1,2,3,4]
19:06:51 <lambdabot>   [(1,2),(2,3),(3,4)]
19:06:55 <copumpkin> it's a cute pattern
19:06:56 <ezyang> oooh, nice
19:06:57 <copumpkin> ap on functions is S
19:07:08 <Makoryu> @hoogle ap
19:07:08 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:07:08 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
19:07:08 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
19:07:21 <copumpkin> actually
19:07:28 <copumpkin> I guess (Int -> Int) -> Bool is fine
19:07:37 <copumpkin> maybe my function enumerator isn't broken
19:07:43 <copumpkin> I was thinking polymorphic functions and I can't generate those anyway
19:07:45 <ezyang> uggh, right, it uses the list monad.
19:07:55 <aavogt> it uses the function monad
19:07:56 <copumpkin> ezyang: the ((->) r) monad
19:08:07 <copumpkin> but it could be done with the applicative too
19:09:15 <ezyang> How is it using the reader monad?
19:09:33 <copumpkin> :t ap
19:09:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:09:35 <ezyang> oh, i see
19:09:49 <ezyang> dang, I have no intuition for this one
19:10:02 <ray> @src Applicative (->)
19:10:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:10:05 * ezyang pops open typeclassopedia 
19:10:06 <copumpkin> the first function must be a (a -> b) and you're giving it zip, so m is [x] ->
19:10:24 <copumpkin> m (a -> b), sorry
19:10:46 <chessguy> @pl \c -> f c && g c
19:10:46 <lambdabot> liftM2 (&&) f g
19:11:05 <ezyang> ok.
19:11:09 <ezyang> Let me chase the types for a sec
19:11:44 <copumpkin> :t (ap, zip, tail)
19:11:46 <lambdabot> forall (m :: * -> *) a b a1 b1 a2. (Monad m) => (m (a -> b) -> m a -> m b, [a1] -> [b1] -> [(a1, b1)], [a2] -> [a2])
19:12:37 <copumpkin> gotta run, bbiab :)
19:13:02 <ezyang> ok
19:13:06 <smarmy> > let ts = tail [1,2,3,4]; zipPartial = zip [1,2,3,4]; result = zipPartial ts in result
19:13:07 <lambdabot>   [(1,2),(2,3),(3,4)]
19:13:09 * ezyang is still chasing types 
19:13:20 <smarmy> in steps ;)
19:13:28 <ezyang> right, I see that's what the tail is being used for
19:13:31 <ezyang> I forgot what ap does
19:14:13 <chessguy> @pl m i b = t (z (f t) i b)
19:14:14 <lambdabot> m = (t .) . z (f t)
19:14:30 <chessguy> @pl m i b = t (z (f g) i b)
19:14:31 <lambdabot> m = (t .) . z (f g)
19:14:48 <ezyang> Ohhh... it's <*> from applicative
19:15:19 <smarmy> ap in this case is (a -> b -> c) -> (a -> b) -> a -> c, where m is (a ->)
19:15:33 <chessguy> @hoogle Int -> [a] -> a
19:15:34 <ezyang> which is fmap
19:15:34 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:15:34 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:15:34 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:15:54 <ray> <$> is fmap
19:16:13 <ezyang> I think... it will make more sense then
19:16:40 <ray> :t fmap fmap fmap fmap fmap fmap fmap
19:16:42 <ezyang> s/$/*/
19:16:42 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
19:17:25 <ezyang> Ok, that means I still need to get intution for the function functor
19:17:33 <ray> function functor is easy
19:17:35 <ray> fmap = (.)
19:17:49 <ray> you probably do need to get intuition for S though
19:18:24 <smarmy> fmap is (b -> c) -> f b -> f c, and when f is (a ->), becomes (b -> c) -> (a -> b) -> (a -> c), or (.)
19:18:26 <ray> basically, s f g x = f x (g x)
19:18:39 <ray> and for functions, ap = s
19:18:56 <ezyang> I am... failing to see the difference between fmap and ap
19:19:07 * ezyang checks types 
19:19:09 <ray> they are pretty different :)
19:19:13 <smarmy> fmap takes (a -> b), while ap takes f (a -> b)
19:19:16 <Makoryu> > fmap x y z
19:19:18 <lambdabot>   Couldn't match expected type `a -> b'
19:19:20 <ezyang> aha
19:19:22 <smarmy> well, m (a -> b)
19:19:26 <smarmy> it's lifted, either way
19:19:56 <smarmy> fmap lifts a function into a context.  ap takes an already lifted function and applies it in a context
19:20:03 <jfoutz> @src liftM3
19:20:03 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
19:20:05 * ezyang tries very hard to think of zip as in a lifted context 
19:20:20 <ray> ap can take a f (a -> b)
19:20:25 <ray> for any applicative functor f
19:20:28 <ezyang> what would... unlifted zip look like?
19:20:33 <ray> except it's called <*> in that case
19:20:39 <ray> now
19:20:44 <smarmy> the context, in that case, is reader.  f (b -> c) becomes a -> b -> c
19:20:48 <ray> the f there can be e ->
19:20:59 <Makoryu> @pl bS = let go fs (' ':xs) = " " ++ go fs xs; go (f:fs) (x:xs) = f [x] ++ go fs xs; go _ [] = [] in b . i . go (cycle [u, o])
19:20:59 <smarmy> and zip is a binary function, so it works
19:20:59 <lambdabot> (line 1, column 4):
19:21:00 <lambdabot> unexpected "="
19:21:00 <lambdabot> expecting variable, "(", operator or end of input
19:21:03 <ray> :t ap zip
19:21:05 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
19:21:11 <Makoryu> @pl let go fs (' ':xs) = " " ++ go fs xs; go (f:fs) (x:xs) = f [x] ++ go fs xs; go _ [] = [] in b . i . go (cycle [u, o])
19:21:12 <lambdabot> (line 1, column 12):
19:21:12 <lambdabot> unexpected "'"
19:21:12 <lambdabot> expecting pattern
19:21:15 <Makoryu> >:|
19:21:30 <jfoutz> @src liftA3
19:21:31 <lambdabot> Source not found. :(
19:22:06 <ray> ap zip tail x = zip x (tail x)
19:22:34 <smarmy> ezyang: in your example, you can think of using the reader monad to apply operations in a context.  the context is that of "taking a list as input".  so [1,2,3,4] is passed to both zip and tail as the context.  then the result of the latter is fed to the former in typical applicative form
19:22:41 <A1kmm> Does anyone know if there is a standard way to efficiently take each element from a list and repeat it n (n being a parameter) number of times. i.e. a standard version of
19:22:42 <Makoryu> :t ap
19:22:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:22:59 <A1kmm> repeatEach n s = repeatEach' n s 0
19:23:00 <jfoutz> that's a neat function.
19:23:01 <A1kmm> repeatEach' n s@(sh:st) i =
19:23:03 <A1kmm>     if i == n
19:23:04 <A1kmm>     then
19:23:06 <A1kmm>         repeatEach n st 0
19:23:07 <A1kmm>     else
19:23:09 <A1kmm>         sh:repeatEach n s (i + 1)
19:23:11 <c_wraith> :t (<*>)
19:23:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:23:16 <aavogt> @type concatMap (replicate 5)
19:23:17 <lambdabot> forall a. [a] -> [a]
19:23:18 <ezyang> oooooh, chaining
19:23:36 <c_wraith> since monads *should* be Applicatives..
19:23:38 <aavogt> > replicate 5 =<< "hello"
19:23:39 <lambdabot>   "hhhhheeeeellllllllllooooo"
19:24:39 <ray> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs in fibs
19:24:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:24:42 <ezyang> I wish Monads were applicatives, and the type hierarchy made sense
19:24:50 <SubStack> splendid!
19:24:58 <ezyang> Nice
19:25:04 <A1kmm> Thanks aavogt
19:25:24 <ray> that's just the classic fibs made a little bit more pointless
19:25:27 <SubStack> I keep forgetting there is an `ap`
19:25:51 <ezyang> Ohhh, what is `ap` backwards?
19:26:05 <ezyang> hmm, does that even make sense
19:26:08 <ray> flip ap?
19:26:11 <ray> :t flip ap
19:26:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
19:26:28 <SubStack> I've internalized arrows well enough now though
19:26:36 <aavogt> A1kmm: no problem, the Prelude has pretty useful functions that hide all that recursion
19:26:42 <ezyang> I guess I'm thinking monadically, which do >>=
19:26:46 <SubStack> takes forever to change your native model of computation
19:26:52 <ray> :t (=<<)
19:26:53 <ezyang> (results pass from left to right)
19:26:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:26:57 <ezyang> yuppp
19:26:59 <aavogt> @let pa = flip ap
19:27:00 <lambdabot>  Defined.
19:27:06 <ray> note that =<< looks suspiciously similar to fmap
19:27:17 <ezyang> ya
19:27:28 <smarmy> :t (>=>)
19:27:30 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:27:30 <ezyang> But the power is because it (a -> m b) and not (a -> b)
19:27:34 <ezyang> >=> is awesome :-)
19:27:38 <ray> the power is join
19:28:05 <ezyang> ok, back to the original question
19:28:13 <ray> when you lift that (a -> m b) with fmap, you get m a -> m (m b)
19:28:17 <ezyang> > ap zip tail [1,2,3]
19:28:18 <lambdabot>   [(1,2),(2,3)]
19:28:26 <ray> you just need to join the result to get back to m b
19:28:33 <ezyang> yes.
19:28:59 <ray> ap zip tail [1,2,3] is just zip [1,2,3] (tail [1,2,3])
19:28:59 <ezyang> Ok, so passing the result from tail to zip makes sense
19:29:15 <ray> so zip [1,2,3] [2,3]
19:29:22 <kyagrd> @type pa pa
19:29:23 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (m a -> (m (a -> b) -> m b) -> b1) -> m a -> b1
19:29:26 <ezyang> What I don't understand is why it's zip [1,2,3] (tail [1,2,3]) and not zip $ tail [1,2,3], I think
19:30:02 <kyagrd> @let ma = liftM id
19:30:03 <lambdabot>  Defined.
19:30:04 <jfoutz> S copies for you
19:30:05 <ray> because the definition is f x (g x), not f (g x)
19:30:07 <shachaf> ezyang: ap x y z = x z (y z), yes?
19:30:07 <kyagrd> @type ma ma
19:30:09 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m a1
19:30:30 <kyagrd> sorry for babbling :)
19:30:31 <ezyang> mmm... yes
19:30:35 <aavogt> @type ap pa
19:30:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m (a -> b)) -> m a -> m b
19:30:41 <ray> ezyang: if you read about the ski combinator calculus, it's just the s combinator
19:30:46 <ezyang> i derived that result while following types when deriving the (->) a monad
19:30:53 <ezyang> ray: never read about it :-(
19:30:59 <ray> it's cool, you should
19:31:06 <shachaf> ezyang: So ap zip tail [1,2,3] = zip [1,2,3] (tail [1,2,3]) .
19:31:07 <ezyang> But I've never really quite gotten an intuitive grasp for what that means
19:31:20 <ray> it's like the lambda calculus without lambdas or variables
19:31:29 <ezyang> O.o
19:31:43 <ezyang> eww: (R g) >>= h = R $ \x -> (runReader $ h (g x)) x
19:31:47 <ezyang> (that was what I derived)
19:32:01 <ray> S is what we're talking about now, K is const, and I is id
19:32:06 <shachaf> ezyang: It says that you using the two functions S x y z = x z (y z) and K x y = x, you can make any function in the lambda calculus.
19:32:14 <shachaf> ray: I is SKK. :-)
19:32:17 <ezyang> Nice.
19:32:22 <ray> yes, I is not technically needed
19:32:27 <Makoryu> :t ap id id
19:32:29 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
19:32:29 <lambdabot>     Probable cause: `id' is applied to too few arguments
19:32:29 <lambdabot>     In the second argument of `ap', namely `id'
19:32:30 <ray> you can make it with S and K
19:32:40 <ezyang> Uhh, let me try
19:32:46 <shachaf> > ap const undefined 1
19:32:48 <lambdabot>   1
19:33:03 <smarmy> and interestingly, the (->) applicative implements both S and K
19:33:16 <smarmy> which is just remarkably elegant
19:33:20 <ezyang> S K K K?
19:33:28 <jfoutz> K
19:33:28 <shachaf> S K K K = K
19:33:33 <ezyang> hmm
19:33:47 <jfoutz> ap const const const
19:33:52 <jfoutz> > ap const const const
19:33:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
19:33:54 <lambdabot>    arising from a use...
19:33:56 <ezyang> oh, I was close
19:34:03 <ezyang> I want I x = S K K x
19:34:09 <ezyang> and the second K isn't really necessary
19:34:19 <Makoryu> ap const pizza 1
19:34:20 <ray> > ap const undefined $ 1
19:34:22 <lambdabot>   1
19:34:26 <Makoryu> > ap const pizza 1
19:34:28 <lambdabot>   Not in scope: `pizza'
19:34:31 <Makoryu> FINE
19:34:33 <ray> S K placeholder, really
19:34:38 <shachaf> S K _ = (\x y z -> x z (y z)) K _ = (\z -> K z (_ z)) = (\z -> z)
19:35:03 <ezyang> threading convos is so hard...
19:35:25 <shachaf> ezyang: You mean on IRC?
19:35:32 <leithaus> have you ever looked at Hagverdi's linear combinators?
19:35:45 <ezyang> shachaf: yeah
19:35:50 <shachaf> You get used to it. :-)
19:35:59 <ray> irc is almost as easy as haskell
19:36:03 <shachaf> If there was some IRC client that could solve that, though, it would be neat.
19:36:06 <ezyang> well, if you're struggling to understand what's being said, it's tough to tell
19:36:11 * shachaf can't imagine how it would work.
19:36:13 <ezyang> Yeah! It's called barnowl+zephyr :-P
19:36:18 <ezyang> You have what are called instances
19:36:36 <ezyang> Everything still gets dumped in one screen, but separate conversations have distinct identifiers attached to them
19:37:18 <chessguy> hm. i have a string with \n's in it, and i want to print it in main so that it actually has the output on separate lines, how do i do it?
19:37:22 <smarmy> sounds like that would require audience participation.  that which requires complete compliance... can't work
19:38:17 <chessguy> like i want to pipe 'main = print "1\n\2"' to a file and be able to see the lines...on separate lines, if that makes sense
19:38:17 <kulakows1i> The irc server just has to read all the messages and figure out which conversation they belong too
19:38:33 <shachaf> chessguy: You can lines it.
19:38:34 <ezyang> kulakows1i: ideally, you attach a small bit of metadata
19:38:45 <ezyang> I mean, we could do it inband, like
19:38:49 <ezyang> topic: this is about a topic
19:38:56 <chessguy> shachaf, how would that help?
19:38:58 <kulakows1i> ezyang: Or have a really good AI
19:38:59 <ezyang> but yeah, client compliance is a problem
19:39:02 <kulakows1i> is what I meant
19:39:02 <ezyang> hahaha
19:39:22 <ray> chessguy: putStr
19:39:23 <shachaf> chessguy: I must misunderstand. What do you mean? :-)
19:39:32 <ray> you're probably using print
19:39:36 <ray> that shows it first
19:39:56 <ezyang> why... is understanding functor instance for (->) so difficult...
19:40:07 <ezyang> erm, (->) e
19:40:12 <chessguy> ah, putStr is what i want
19:40:20 <kulakows1i> I bet you could do suprisingly well by looking at timing of messages and analyzing previous conversations in the channel, markov chains and whatnot
19:40:24 <ray> ((->) e) to be precise
19:40:25 <chessguy> sorry, i know i didn't explain that very clearly
19:40:35 <ray> chessguy: it was perfectly clear to *me* :)
19:40:56 <chessguy> well, for better or worse, you and i are on the same wavelength :)
19:41:23 <dibblego> ezyang, I have a method of explaining that which usually works, but has some initial requirements
19:41:23 <jfoutz> > runCont (callCC (\k -> foldM (\a v->if (v==1) then return True else k False) True [1,2..])) id
19:41:24 <lambdabot>   False
19:41:40 <chessguy> boo-yeah, that's what i'm talking about!
19:41:57 <ezyang> hmm... is fmap g f = f . g or g .f
19:42:03 <ezyang> to the type machine!
19:42:09 <copumpkin> ray: so you're too good for the boston meetup tomorrow?
19:42:13 <copumpkin> jfoutz: wow :P
19:42:15 <copumpkin> ezyang: think about the types
19:42:18 <ray> i'm too sexy for boston haskell
19:42:29 <ray> well, there's this minor funeral too, but mainly i'm too sexy
19:42:31 <copumpkin> ray: drong the cat will be there
19:42:35 <copumpkin> aw
19:42:38 <ray> he lives in maryland :)
19:42:39 <copumpkin> ok
19:42:46 * chessguy wonders how many pages 6555 lines would take up
19:42:50 <copumpkin> ray: he's coming up specially to meow at us
19:43:26 <ezyang> ok, what's partially confusing me is me thinking of a function as b -> c and not ((->) c) b
19:43:38 <shachaf> That's not the same thing.
19:43:44 <shachaf> b -> c = (->) b c
19:43:46 <smarmy> yeah, those are backwards
19:43:47 <ezyang> did I interpose the order
19:43:49 <ezyang> yes I did
19:43:52 <shachaf> Just like a + b = (+) a b
19:43:56 <shachaf> It's the same thing on a type level.
19:44:18 <ezyang> oh holy crap
19:44:23 <ezyang> it just suddenly became obvious
19:44:31 <copumpkin> :)
19:44:46 <ezyang> ((->) e) a
19:44:50 <copumpkin> you can use –> on values too ;)
19:44:52 <ezyang> if I fmap a -> b
19:44:55 <smarmy> ezyang: you have f (a -> b) -> f a -> f b.  f becomes (e ->).  then (e -> a -> b) -> (e -> a) -> e -> b.  e is the environment.  it's passed to the original function and the original argument.
19:44:56 <ezyang> then I get ((->) e) b
19:44:59 <ezyang> o hman
19:45:05 <copumpkin> > let (–>) = (+) in 5 –> 7
19:45:06 <lambdabot>   12
19:45:11 <copumpkin> O:-)
19:45:13 <chessguy> darn, 120 pages
19:45:15 <ray> zomg value-level -> is heresy
19:45:26 * copumpkin polishes his halo
19:45:31 <ezyang> value level?
19:45:46 <copumpkin> > let (–) = (+) in 5 - (6 – 7)
19:45:48 <lambdabot>   -8
19:45:56 * copumpkin whistles
19:46:05 <shachaf> Ooh!
19:46:15 <ezyang> ok, on to pointed
19:46:21 <shachaf> > let (–) = (-) in (–5) 6
19:46:22 <lambdabot>   1
19:46:29 <shachaf> Finally.
19:46:32 <copumpkin> lol
19:46:43 <copumpkin> I'd be all for that actually
19:46:47 <copumpkin> but it's a little sneaky and hard to read :P
19:46:57 <ezyang> why do we have emdashes
19:47:05 <shachaf> (Hmm, I suppose you could make a Num instance for functions that would subtract when given negative numbers.)
19:47:46 <copumpkin> shachaf: yeah but then you'd get a load of other undesired behavior
19:47:50 <ezyang> is pure x = \_ -> x for ((->) e)?
19:47:57 <copumpkin> yup
19:47:57 <dibblego> yes
19:48:03 <smarmy> yeah.  pure = K = const
19:48:05 <copumpkin> a.k.a. const x
19:48:05 <ezyang> Is there a more elegant way of writing that?
19:48:09 <ezyang> Ohhh, const
19:48:15 <copumpkin> :)
19:48:15 <shachaf> Or pure x _ = x
19:48:16 <dibblego> pure = const
19:48:28 <ezyang> Ok, on to applicative
19:48:33 * shachaf likes the BASIC thing augustss did with Num instances.
19:48:37 <smarmy> pure = K.  <*> = S.  bask in the beauty
19:48:44 <smarmy> :)
19:48:50 <shachaf> And by "likes" I mean "is repulsed by".
19:48:51 <copumpkin> applicative adds the all-important f (a -> b) -> f a -> f b
19:48:57 <ezyang> K x y = x definitely jives with pure
19:48:59 <shachaf> In a positive way. :-)
19:49:10 <sohum> is there any way to add a constraint to a type synonym?
19:49:28 <ezyang> although I guess you don't get a real meaning for K x, do you?
19:50:02 <shachaf> "real meaning"?
19:50:12 <ezyang> mmm... like, well defined semantics
19:50:21 <ezyang> oh, no, that's just a partially applied function
19:50:26 <ezyang> hok
19:51:02 <ezyang> g <*> a dun dun dun
19:51:19 <shachaf> "K x y = x" means "K = \x -> \y -> x"
19:51:36 <shachaf> It's just a short way or writing it.
19:51:49 <ezyang> yup, curryin
19:51:52 <ezyang> *currying
19:52:01 <shachaf> Well, not really currying. But let's not get into that. :-)
19:52:09 <ezyang> ok, in g <*> a, g :: (->) e (a -> b), and a :: (->) e a
19:52:11 <smarmy> hehe... yeah.  partial application
19:52:40 * copumpkin made curry yesterday, and it was really yummy. I had some leftovers and was looking forward to eating them for dinner tonight, but my roommate ate them before I got back!!!
19:52:42 <shachaf> @ty (<*>)
19:52:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:53:05 <smarmy> ezyang: yes
19:53:20 <ezyang> I think I get confused if I write it out e -> a -> b, etc
19:53:44 <inimino> copumpkin: you ought to have fully applied yourself to the curry when you had the chance
19:53:50 <smarmy> ezyang: heh... i noticed you had an epiphany with (->) e.  strange how minds differ.  i find that obtuse
19:54:00 <copumpkin> inimino: yeah :(
19:54:05 <ray> the e in (->) e stands for easy
19:54:13 * copumpkin wants (-> e)
19:54:15 <ray> just like the e in haskelle
19:54:20 <ezyang> smarmy: I got a lot of practice looking at this notation for easier instances
19:54:20 <copumpkin> *haskle
19:54:23 <ezyang> Like Maybe
19:54:28 <ray> copumpkin: it'd be (e ->) then
19:54:40 <copumpkin> ray: no, I want the other one
19:54:43 <ezyang> looking it like that reminds me that e is part of the context, and not actually what I care about
19:54:49 <ray> WHY CAN'T WE SECTION TYPE OPERATORS, SIMON
19:54:56 <ray> ahem
19:55:03 <ray> i mean, we should be able to section type operators
19:55:09 <copumpkin> newtype Moo a b = Moo (b -> a)
19:55:18 <copumpkin> newtype Moo a b = Moo { unMoo :: b -> a }
19:55:27 <ray> instance Zomg (Moo a)
19:55:54 <ezyang> OHHHHH!
19:56:00 <ezyang> Second epiphany
19:56:06 <copumpkin> yay
19:56:11 <copumpkin> ez ==? easy
19:56:17 <ezyang> the parameter shows up twice because we need to unwrap g from its monadic context
19:56:22 <ezyang> erm, context
19:56:25 <ezyang> since I'm still in applicative
19:57:56 <ezyang> Ok, so here's the verbose version:
19:57:57 <ezyang> g <*> a = \e -> (g e) (a e)
19:58:25 <ezyang> It appears to typecheck
19:58:27 <shachaf> Verbose?
19:58:34 <shachaf> (<*>) g a e = g e (a e)
19:58:44 <shachaf> That's the same as before. :-)
19:58:59 <ezyang> ok, so now I want to assure myself that the two expressions are equivalent :-)
19:59:00 <ray> pattern binding or lambda, same thing
19:59:10 <ezyang> putting e at the end gives me lambda for free, yup
19:59:12 <Rotaerk> how do you like dem apples`
19:59:18 <dibblego> you might consider removing the parentheses from "(g e)"
19:59:25 <ezyang> and partial application means I don't need parentheses from g e
19:59:27 <ezyang> savvy
19:59:47 <ezyang> so, (<*>) g a e = g e (a e) obscures two things
20:00:00 <shachaf> Obscures?
20:00:08 <ezyang> In my mind, at least
20:00:13 <copumpkin> now, you may wonder in future why we have two functions that do the same thing
20:00:14 <copumpkin> :t ap
20:00:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:00:17 <copumpkin> :t (<*>)
20:00:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:00:31 <smarmy> because haskell wants to be perl
20:00:34 <ezyang> cuz monad isn't inheriting applicative :-)
20:00:36 <shachaf> copumpkin: Why do we have both map and (.)? :-(
20:00:47 <ezyang> shachaf: Wait what?
20:00:49 <copumpkin> shachaf: I'm still not convinced by that one :P
20:01:02 <shachaf> ezyang: (.) = fmap = map
20:01:16 <ezyang> I know the fmap = map equivalence...
20:01:22 <roconnor> (.) = (>>>)
20:01:24 <roconnor> sooo
20:01:29 <roconnor> (>>>) = fmap!
20:01:31 <ezyang> ohh, ok, not Prelude (.)
20:01:32 <roconnor> ...
20:01:43 <roconnor> stupid non-transitive equality
20:01:48 <dibblego> ezyang, instance Functor ((->) e) where fmap = (.)
20:02:02 <dons> mmorrow: http://hackage.haskell.org/package/haskell-src-meta-0.0.4 depends on an old haskell-src-exts
20:02:06 <dons> mmorrow: can you update?
20:03:10 <ezyang> anyway, it obscures: 1. that g <*> a returns a function (this is if you're not comfortable with partial application), and 2. that we're unwrapping g and a from their contexts by giving them e
20:03:24 <ezyang> (2) was the crucial bit for me to understand
20:03:37 <sohum> are there any extensions I can use for type Parser m a b = Monad m => a →  m (b, a)
20:03:41 <sohum> to work?
20:03:44 <smarmy> re 1: it returns an applicative, not a function.  it just so happens to be a function in this case
20:03:56 <ezyang> smarmy: Ah, right.
20:03:57 <smarmy> it's supposed to be obscured in that way.  that's the power of generalization
20:04:07 <smarmy> now that code works for EVERY applicative
20:04:13 <smarmy> not just functions
20:04:29 <ezyang> ehm, we were talking about the instance of applicative for ((->) e)?
20:04:37 <ezyang> I appreciate the power of applicative
20:04:50 <shachaf> ezyang: After a while f g x = ... and f g = \x -> ... start looking the same. :-)
20:04:56 <smarmy> we were, but then you tried to beat down the g <*> a notation, and i rose to its defense
20:04:58 <ezyang> but if I'm not comfortable with the computation context it's operating in... :o)
20:05:06 <smarmy> :)
20:05:17 <ezyang> Yes. I was very confused at the beginning of the conversation
20:06:27 <ezyang> Ok, so...
20:06:33 <smarmy> you could sya that it obscures the meaning of ANY particular applicative, such as (->), but that's by design.  generalization has that effect
20:06:37 <roconnor> > 8/3
20:06:39 <lambdabot>   2.6666666666666665
20:07:11 <BMeph> sohum: Better: Give your type a tag name, so you stop freaking out the compiler, please. :)
20:07:28 <copumpkin> Data.Tagged!
20:07:57 <sohum> BMeph: sorry?
20:08:13 <ezyang> ok, so tail being a "container" is obvious
20:08:34 <shachaf> "container"?
20:08:48 <ezyang> mmm, as a reader
20:08:52 <BMeph> ezyang: When you said "we're unwrapping g and a from their contexts by giving them e", do you mean that you're "injecting" a new context into the situation? 'Cause I don't know what contexts they're being unwrapped from... :)
20:09:23 <ezyang> BMeph: so... they're sort of naturally injected from the functions we use
20:09:31 <ezyang> (which is teh reason we couldn't use fmap)
20:09:35 <smarmy> shachaf: it's an infinite container, producing any number of lists when fed an input.  so yeah, in a way
20:09:35 <ezyang> *the
20:09:46 <sohum> actually, according to http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html, -XLiberalTypeSynonyms is supposed to make things like type Discard a = forall b. Show b => a -> b -> (a, String) work. copying and pasting that into a test file, enabling -XLiberalSynonyms, and compiling it with ghc 6.8.2 doesn't.
20:10:06 <shachaf> smarmy: What is what?
20:10:23 <smarmy> 42
20:10:30 <ezyang> zip :: [a] -> [b] -> [(a, b)] versus zip :: (->) [a] ([b] -> [(a, b)])
20:10:57 <BMeph> sohum: type Parser m a b = Monad m => <Insert name of type tag here> a -> m (b, a)
20:11:26 <BMeph> Or, to be more explicit, rather:
20:11:42 <BMeph> sohum: type Parser m a b = Monad m => <Insert name of type tag here> ( a -> m (b, a) )
20:11:54 <sohum> BMeph: what's a type tag?
20:11:54 <ezyang> Ok, now I see why you guys kept emphasizing the type of 'ap zip'
20:12:29 <shachaf> ezyang: Hum?
20:12:32 <roconnor> @quote aztec
20:12:33 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
20:12:37 <ezyang> ap zip :: ([a] -> [b]) -> ([a] -> [(a,b)])
20:12:49 <BMeph> sohum: Maybe even do it record-style if you're feeling especially masochistic. However, it you're talking just about the Unicode, the flag is easy to find, I just forget its name now. :)
20:13:03 <sohum> BMeph: no, not the unicode
20:13:09 <sohum> BMeph: the constraint
20:13:17 <sohum> BMeph: the unicode is an artifact, ignore it
20:13:25 <sjanssen> sohum: what is the error?
20:13:45 <sohum> sjanssen: "Illegal polymorphic or qualified type: (Monad m) => a -> m (b, a)"
20:14:17 <sohum> sjanssen: if I add a forall m. to the front, it throws a parse error on the =>
20:15:29 <ezyang> what
20:15:34 <ezyang> :t ($) 2
20:15:36 <lambdabot> forall a b. (Num (a -> b)) => a -> b
20:15:49 <ezyang> What does that even mean...
20:16:04 <copumpkin> that's more confusing than it needs to be
20:16:11 <copumpkin> :t ($ 2)
20:16:12 <lambdabot> forall a b. (Num a) => (a -> b) -> b
20:16:13 <sjanssen> sohum: I don't think you can achieve what you want
20:16:19 <copumpkin> ezyang:
20:16:21 <copumpkin> :t ($)
20:16:23 <lambdabot> forall a b. (a -> b) -> a -> b
20:16:27 <copumpkin> the first argument must be a function
20:16:29 <copumpkin> :t 2
20:16:31 <lambdabot> forall t. (Num t) => t
20:16:36 <copumpkin> but 2 has that type
20:16:41 <sohum> sjanssen: then what's the first example of http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html, 7.4.3 doing that's different?
20:16:48 <copumpkin> so it wants to find an instance of Num that's a function
20:16:54 <ezyang> Hahahahaha
20:16:56 <ray> stupid open typeclasses
20:16:57 <ezyang> Ok.
20:17:04 <sjanssen> sohum: the class constraint there is on a forall bound type variable
20:17:05 <wgsilkie> a/wg 1
20:17:15 <ray> possible fix: add an instance for Num (a -> b)
20:17:15 <ray> :)
20:17:16 <sjanssen> sohum: your type variable is bound in 'type'
20:17:17 <ezyang> I guess... Church Numerals!
20:17:22 <wgsilkie> Oops!  Sorry.
20:17:45 <ray> > 3 2
20:17:47 <lambdabot>   Add a type signature
20:17:57 <ray> oh, lambdabot is too clever
20:17:58 <shachaf> > 3 2 :: Bool
20:17:59 <lambdabot>   No instance for (GHC.Num.Num (t -> GHC.Bool.Bool))
20:17:59 <lambdabot>    arising from the lite...
20:18:09 <sohum> sjanssen: aaah
20:18:18 <ezyang> And these are Haskell's infamously unhelpful type messages :-)
20:18:22 <ray> ghci's all "Possible fix: add an instance declaration for (Num (t -> t1))"
20:18:23 <BMeph> :t (2 $)
20:18:25 <lambdabot> forall a b. (Num (a -> b)) => a -> b
20:18:30 <BMeph> @bo
20:18:31 <lambdabot> :)
20:18:34 <copumpkin> ezyang: I think they're generally pretty good actually, but could be improved
20:18:40 <ezyang> They make /sense/
20:18:48 <ezyang> But you do have to twist your head around them
20:18:53 <shachaf> Well? That's a valid fix in some cases!
20:18:59 <ray> indeed
20:19:01 <ezyang> Yep
20:19:16 * BMeph prefers Scott numerals...
20:19:33 <ray> like if you're embedding basic in haskell
20:20:57 <Makoryu> ezyang: Blame GHC, not Haskell itself. Other implementations are said to give more newbie-friendly error messages
20:21:07 <ezyang> Makoryu: Fair point
20:21:33 <Makoryu> I've actually never used anything but GHC, come to think of it...
20:21:37 <sjanssen> ezyang: I don't think "unhelpful" is correct
20:22:11 <ezyang> Ok. I think I understand 'ap zip tail'. But to make sure, could someone quiz me?
20:22:13 <sjanssen> they really are helpful once you know Haskell
20:23:11 <ezyang> ==sjanssen
20:23:27 <mmorrow> dons: yes i'll do that
20:24:43 <ezyang> No one? :-(
20:24:55 <sohum> sjanssen: thank you!
20:25:10 <shachaf> ezyang: "quiz"?
20:25:14 <smarmy> ezyang: sounds like you've got it
20:25:50 <BMeph> ezyang: Quiz #1: What does 'ap' do? ;)
20:26:01 <ezyang> It performs ($) inside a Monadic context
20:26:25 <shachaf> ($) = id. :-)
20:26:33 <BMeph> ezyang: WOOT!
20:26:41 <BMeph> shachaf: Hush, you! ;p
20:26:41 <shachaf> Though I suppose -- never mind.
20:26:52 <shachaf> ($)'s type is right in this context, actually.
20:27:03 <ezyang> ap :: (Monad m) => m (a -> b) -> m a -> m b
20:27:09 <ezyang> (tried typing that from memory)
20:27:13 <ezyang> :t ap
20:27:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:27:16 <smarmy> ezyang: try a variantion of your example.  without cheating, what is the output of ap (++) tail [1,2,3,4]?
20:27:24 <ezyang> hmm.
20:27:25 <BMeph> :t liftM ($)
20:27:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
20:27:38 <dibblego> :t liftM2 ($)
20:27:39 <BMeph> Whoops, rather:
20:27:40 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
20:27:43 <BMeph> :t liftM2 ($)
20:27:45 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
20:27:56 <BMeph> dibbelgo: Tank you. :)
20:27:56 <ezyang> (++) :: [a] -> [a] -> [a]
20:28:11 <dons> mmorrow: thanks! (note it blocks interpolated-strings-qq which is a bit popular)
20:28:20 <ezyang> so...
20:28:44 <ezyang> oh, pattern matching duh
20:28:57 <mmorrow> dons: :)
20:29:14 <ezyang> [1,2,3,4,2,3,4]
20:29:31 <ezyang> not a 100% sure, want to doublecheck types
20:29:43 <ezyang> yup, final answer
20:29:44 * BMeph cyber high-fives ezyang
20:29:50 <smarmy> yep
20:29:55 <smarmy> :)
20:30:10 <smarmy> how about: ap (,) id True
20:30:21 <shachaf> ezyang: OK, what about: ap [(+1),(*2)] [1,2,3]
20:30:22 <ezyang> Is it... bad if I figured that out by thinking, "Hmm, zip gets [1,2,3,4] and [2,3,4] passed as parameters... so just swap zip with ++..."
20:30:25 <smarmy> sorry, meant: ap (,) not True, but either or
20:30:38 <ezyang> ok, lessee
20:30:45 <shachaf> ezyang: Well, sure. Or expand it out:
20:30:52 <absentia> is there an advantage of using Haskell over programming ina  funcational way in say, C++ or Lisp?
20:31:08 <shachaf> ap (++) tail [1,2,3,4] == (++) [1,2,3,4] (tail [1,2,3,4]) == (++) [1,2,3,4] [2,3,4]
20:31:08 <dibblego> absentia, yes
20:31:31 <ezyang> shachaf: I think the list context is easier to understand. [2,2,3,4,4,6'
20:31:54 <ezyang> s/'/]/
20:32:07 <shachaf> Well, [2,3,4,2,4,6], actually. But that's the idea. :-)
20:32:19 <ezyang> Huh.
20:32:29 <ezyang> I thought it used concat?
20:32:49 <shachaf> It does.
20:32:59 <ezyang> ap (,) not True... thinking
20:33:00 <absentia> what might that/those be?
20:33:35 <jfoutz> > (++) [1,2,3,4] [2,3,4]
20:33:36 <lambdabot>   [1,2,3,4,2,3,4]
20:33:41 <roconnor> absentia: algebraic data types and laziness
20:33:54 <shachaf> ap fs xs = [f x | f <- fs, x <- xs]
20:33:59 <ezyang> oh... no... it uses a cartesian product
20:34:02 <ezyang> == shachaf
20:34:04 * BMeph prefers succ over (+1), for some reason. And no, just because it's vulgarly 'fun' to say, "Succ it!"
20:34:15 <ezyang> ok, I always forget which is the outer "loop"
20:34:25 <shachaf> (Note that an alternative implementation is ap fs xs = [f x | f <- fs | x <- xs], if you accept that sort of syntax.)
20:34:39 <roconnor> > succ maxbount :: Int
20:34:40 <lambdabot>   Not in scope: `maxbount'
20:34:43 <roconnor> > succ maxbound :: Int
20:34:45 <lambdabot>   Not in scope: `maxbound'
20:34:48 <roconnor> > succ maxBound :: Int
20:34:50 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
20:34:57 <roconnor> > (+1) maxBound :: Int
20:34:58 <lambdabot>   -9223372036854775808
20:35:06 <ezyang> mm... that still doesn't make it obvious which is the outer loop
20:35:20 <shachaf> ezyang: Hm? That's a different function.
20:35:21 <ezyang> roconnor: hahaha
20:35:33 <jfoutz> absentia: c++ throw is pretty scary.
20:35:39 <ezyang> I guess, I don't have a terribly good grasp of list comprehensions
20:35:41 <shachaf> @check \x -> (succ x :: Int) == (+1) x
20:35:42 <lambdabot>   "OK, passed 500 tests."
20:35:49 <mmorrow> hurray for non-breaking minor releases!
20:36:10 <shachaf> ezyang: Oh, the [x | ... | ...] isn't official syntax.
20:36:14 <ezyang> ok, goes from left to right
20:36:27 <ezyang> as in left is the outer loop
20:36:31 <ezyang> oh no
20:36:34 <ezyang> right to left
20:36:41 <ezyang> no left to right
20:36:45 * ezyang tears heads out 
20:36:48 <Makoryu> > read "pizza"
20:36:50 <lambdabot>   * Exception: Prelude.read: no parse
20:36:51 <ezyang> *hair
20:37:16 <absentia> jfoutz: why is throw scary?  where can I read about what makes algebraic data types a desired thing?
20:37:16 <Makoryu> > read "11"
20:37:16 <jfoutz> as long as it's not your own.
20:37:18 <lambdabot>   * Exception: Prelude.read: no parse
20:37:20 <Lycurgus> @check \x -> (succ x :: Int) == (+1) x
20:37:21 <lambdabot>   "OK, passed 500 tests."
20:37:24 <smarmy> > [(a,b) | a <- ['a'..'c'], b <- [1..3]]
20:37:25 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
20:37:27 <kyagrd> > read "11" :: Integer
20:37:29 <lambdabot>   11
20:37:38 <ezyang> (,) :: a -> b -> (a,b)
20:37:46 <ezyang> not :: Bool -> Bool
20:37:48 <jfoutz> absentia: there's no way to tell what call might unwind the stack.
20:37:52 <Lycurgus> (looked like a build msg which in context could have been, was just checking)
20:37:55 <kyagrd> when you do just read "11" I think it defaults do  read "11" :: ()
20:37:58 <kyagrd> > read "()"
20:38:00 <lambdabot>   ()
20:38:05 <ezyang> :t not
20:38:06 <lambdabot> Bool -> Bool
20:38:13 <ezyang> ok. that's kind of an odd ap
20:38:20 <ezyang> (ap (,) not)
20:38:29 <Makoryu> kyagrd: ... Y'know I never even considered that. I thought it would just fail to default to anything :p
20:38:29 <ezyang> oh, I see
20:38:35 <Makoryu> :t ap (,) not
20:38:37 <lambdabot> Bool -> (Bool, Bool)
20:38:40 <ezyang> (,) :: Bool -> b -> (Bool, b)
20:38:48 <Cale> absentia: The question about what makes Haskell a nicer language for functional programming than C++ or varieties of Lisp is something which is complicated to answer, as it's the result of the combined effect of a lot of features.
20:38:54 <ezyang> Makoryu: shhhh!
20:38:55 <kyagrd> ap (,) not $ False
20:39:03 <kyagrd> > ap (,) not $ False
20:39:05 <lambdabot>   (False,True)
20:39:11 <kyagrd> > ap (,) not $ True
20:39:12 <lambdabot>   (True,False)
20:39:16 <ezyang> Aw, I was trying to derive that in my head ^_^
20:39:26 <kyagrd> @src ap
20:39:26 <lambdabot> ap = liftM2 id
20:39:32 <absentia> cale: ya, I'm just shopping around for a new[er] language to play with... haskell keeps popping up.
20:39:46 <shachaf> ezyang: ap (,) not False == (,) False (not False) = (,) False True = (False,True)
20:40:01 <shachaf> absentia: Oh, it's great for playing. :-)
20:40:08 <smarmy> ezyang: seems the crowd beat you to it.  no soup for you!
20:40:16 <ezyang> :-(
20:40:17 <dons> Cale: quick answer: are operations on functions first class? e.g. (.) and ($) and currying? no? it's not a functional language
20:40:26 <dons> :)
20:40:35 <jfoutz> absentia: algebraic data types are handy any time you might want a union or *maybe* an object hierarchy
20:40:44 <ezyang> it seems reasonably obvious now, though
20:40:48 <shachaf> dons: Sure, but LISP has that, no?
20:40:55 <smarmy> yep.  pretty straightforward
20:41:08 <Cale> absentia: Algebraic datatypes are nice because they unify a lot of other mechanisms for defining datatypes (structure/product types and unions/sum types, parametric datatypes, recursive datatypes)
20:41:22 <dons> shachaf: they don't use (.) for composition :)
20:41:34 <absentia> I'm afraid I don't know anything about purely functional data types.
20:41:39 <ezyang> dons: I'm sure they have some thingy to do that.
20:41:46 <aavogt> ap (flip ap) (fmap (+)) [1..3]
20:41:48 <dons> definitely. macros for sure.
20:41:49 <absentia> I'm just tryig to decide if I should look into lips -- finally... or haskell.  can't really decide.
20:41:49 <Cale> absentia: So you can, for example, define a binary tree of values of an arbitrary type parameter by  data Tree a = Leaf | Branch a (Tree a) (Tree a)
20:41:55 <ezyang> thinking
20:42:05 <Cale> absentia: and then proceed to define operations on that new type:
20:42:12 <Cale> size :: Tree a -> Integer
20:42:14 <dons> absentia: you could download the haskell platform and start playing with ghci in 5 minutes. http://hackage.haskell.org/platform/
20:42:16 <Cale> size Leaf = 0
20:42:16 <absentia> cale: ok
20:42:20 <ezyang> agggh
20:42:23 * shachaf prefers lazy functions to macros where both are used to do the same thing.
20:42:27 <Cale> size (Branch x l r) = 1 + size l + size r
20:42:34 <shachaf> (E.g., if.)
20:42:53 <hackagebot> Control-Engine 1.1.0.1 - A parallel producer/consumer engine (thread pool) (ThomasDuBuisson)
20:43:00 <absentia> dons: ya, have it..  reading learn you a haskell
20:43:05 <shachaf> absentia: This channel is slightly biased. :-) But I would say that Haskell would be more helpful for learning to "think functionally".
20:43:11 <ezyang> aavogt: that's mean
20:43:33 <aavogt> ezyang: yeah, I can't do it :)
20:43:44 <ezyang> ok, that turns into (flip ap) [1..3] (fmap (+) [1..3])
20:43:44 <absentia> I read the erlang thesis... has some nice ideas...  but just seemed a little more targetted.
20:43:46 <Cale> absentia: Notice that we define functions at least initially by matching patterns: we say separately what the result is in the case that the tree is a Leaf and the tree is a Branch, and variables get bound to the appropriate parts of the structure.
20:44:06 <ezyang> which is then (flip ap) [1..3] [(+1), (+2), (+3)]
20:44:17 <ezyang> Then ap [(+1),(+2),(+3)] [1,2,3]
20:44:19 <ezyang> Aha!
20:44:19 <absentia> right, I like strict/lazy.
20:44:37 <ezyang> [2,3,4,3,4,5,4,5,6]
20:44:47 <dons> haskell's the grandchild of lisp. its a much younger, more modern language. it encorporates the lessons and mistakes of lisp into something new.
20:44:48 <ezyang> >  ap (flip ap) (fmap (+)) [1..3]
20:44:49 <lambdabot>   [2,3,4,3,4,5,4,5,6]
20:44:51 <Cale> absentia: This tends to produce much clearer definitions than having to explicitly test using some predicate and if/then/else, along with projection functions (leftChild/rightChild/etc.)
20:44:54 <ezyang> whooo!
20:45:14 <absentia> hm
20:45:15 <Cale> (and avoids problems like leftChild being accidentally applied to a Leaf node)
20:45:19 <jfoutz> dons: that's a great way of putting it.
20:45:26 <absentia> ok, I'll finish reading that book (I'll probably read it twice) ... and hang out here.
20:45:40 <ezyang> I wonder how to derive that without any intermediate steps
20:46:30 <ezyang> I don't think I can keep track of so many steps
20:46:53 <hackagebot> haskell-src-meta 0.0.5 - Parse source to template-haskell abstract syntax. (MattMorrow)
20:47:01 <Cale> absentia: Another really nice thing about Haskell is its type system -- aside from the fact that it lets you so conveniently define new datatypes like this, it also can infer the types of functions (and check that the inferred type matches with any explicit types you choose to give)
20:47:09 <absentia> oh, granted.. with pure functional, I can see how making things parallel might be easier/safer.. but are there any thoughts on parallel haskell vs making  C and or C++ parallel?
20:47:13 <Cale> absentia: Types are really nicely expressive too.
20:47:17 <smarmy> ap (flip ap) (fmap (+)) [1..3] -> ap (flip ap [1..3]) (fmap (+) [1..3]) -> ap (\x -> ap x [1..3]) [1+,2+,3+] -> (ap [1+,2+,3+] [1..3]) -> [2,3,4,3,4,5,4,5,6]
20:47:44 <absentia> cale: I like the inference... and I don't want to confuse the type system... but doesn't lisp infer (at runtime) and c++ (0x/1x?) have type inference?
20:47:45 <Cale> absentia: Oh, in terms of parallelism and concurrency, starting from a pure functional language is a much much saner approach.
20:47:49 <smarmy> sorry.  i'm behind. just playing
20:47:53 <ezyang> :-)
20:48:05 <Cale> absentia: Lisp is (for the most part) dynamically typed.
20:48:29 <Cale> absentia: Which means that it has no static type system and waits until the program is actually running before checking.
20:48:44 <Makoryu> absentia: Lisp in general (ie. in most dialects) has very little use for type inference
20:48:46 <pikhq> *Dynamically* typed? Bah. It's untyped. :P
20:48:50 <Cale> (this is not at all the same thing as statically inferring types)
20:48:53 <mmorrow> dons: done
20:49:01 * pikhq still thinks that they should use Church numerals
20:49:06 <Cale> Yeah, dynamic types aren't really types ;)
20:49:12 <dons> mmorrow: woo, thanks!
20:49:15 <dons> that unblocks a lot of packages :)
20:49:31 <Makoryu> pikhq: Lisps will still throw an error if you try to read a pair as an int
20:49:47 <copumpkin> what depends on haskell-src-meta?
20:49:52 <aavogt> > read "abcde" :: Int
20:49:53 <lambdabot>   * Exception: Prelude.read: no parse
20:50:07 <absentia> right... if I'm going OO, I like the idea of sending messages... but to me, it seems that's something that could be implemented at a higher level, if an application required it... having it in a lanuage just seems like the wrong level -- although it does allow for some nice programs (ie: objective-c / smalltalk, etc).
20:50:14 <Cale> absentia: C++, as far as I know, doesn't have type inference... there might be something coming in the new proposed standards for it, but it probably won't work as nicely as with Haskell's type system.
20:50:32 <absentia> cale: correct...
20:50:47 <Cale> absentia: I seem to recall seeing some noise about an auto keyword you can use explicitly when you want the type inferred.
20:50:52 <pikhq> absentia: foo `par` bar -- versus lines of boilerplate to start a new thread, lots of manual communication between them, and painful parallel algorithms.
20:50:58 <absentia> bingo
20:50:58 <pikhq> (trivial example)
20:51:18 <Cale> But that means you still have to say 'auto', and I'm not sure if or how well it works for function types.
20:51:33 <pikhq> Cale: It works just fine for function types.
20:51:36 <Cale> > let map f [] = []; map f (x:xs) = f x : map f xs in map
20:51:37 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> a) -> [t] -> [a])
20:51:38 <lambdabot>    arising...
20:51:41 <Cale> :t let map f [] = []; map f (x:xs) = f x : map f xs in map
20:51:43 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
20:52:11 <absentia> pikhq: right, depends on the algorithm... for objc, you can use nsprocessqueue, etc... it will farm out threads to as many cpus/cores that you have, etc.  but, alas, it's still goig to be side-effect gotcha (race condition) ridden.
20:52:12 <Cale> Here, the polymorphic type of this function 'map' is being inferred by the Haskell compiler
20:52:23 <Makoryu> Cale: C++ uses type inference to determine how to instantiate a template in some circumstances
20:52:44 <absentia> mak:  I didn't mean with templates... I also don't consider that the same thing.
20:52:48 <pikhq> :t parMap
20:52:50 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
20:53:16 <smarmy> Makoryu: with "some circumstances" never quite being the right ones
20:53:19 <Makoryu> absentia: Yeah, C++'s use of inference is extremely limited
20:53:20 <pikhq> absentia: Too much code.
20:53:25 <Makoryu> smarmy: Tell me about it
20:53:26 <pikhq> You should just be able to say "
20:53:33 <pikhq> Do this in parallel".
20:53:43 <copumpkin> zomg dons has a shirt!
20:53:44 <copumpkin> http://www.reddit.com/r/haskell/shirt/9bflz/haskell_jobs_galois_is_hiring/
20:54:05 <Cale> absentia: Yeah, in Haskell, all functions are required not to have side effects. We encode effects as values of particular types explicitly, and so there's information at the type level about what a function is allowed to do.
20:54:25 <Makoryu> absentia: The new Grand Central feature will let you dispatch parallelism from Obj-C in a much more Haskell-ish way... Still too verbose though
20:54:29 <Cale> absentia: This means that by default, it's easy to decide that you want to parallelise something and know that it will be safe to do so.
20:54:55 <absentia> man,I can't wait to get opencl gong.
20:55:07 <Cale> absentia: Of course, that's just pure parallelism and not (nondeterministic) concurrency
20:55:57 <absentia> ya, when I go concurrent, I use message passing.  seems to simplifer things (for the apps that I need)
20:55:57 <dons> and there's no one parallelism mechanism that works for all problems. you need /lots/ of approaches, like you need lots of ways to do sequential control.
20:56:11 <dons> languages that offer only 1 way to write parallel programs aren't going to be general purpose.
20:56:50 <dons> locks, messages, stm. thread sparks, data parallelism, work queues, parallel strategies for data.
20:57:18 <mmorrow> edwardk: here's a repo with 80% of the TH stuff that i'm planning on adding to haskell-src-meta (it's in the Info module) (also not that this pkg has strayed from being KURE-specific since i named it, it's kind of just a big disorganized mess with some experiments and misc.. ;) http://moonpatio.com/repos/kure-th/
20:58:03 <BMeph> Heh-heh, Galois is like the Flying Frog of Haskell...except Galois actually does things, and doesn't have to put down every other language on the planet to get business... ;p
20:58:22 <mmorrow> edwardk: i looked at the 1000+ line wall of TH and random comments of ghci sessions and did a "arghhh, i'll have to organize this \"tomorrow\"" :)
20:58:27 <Axman6> copumpkin: http://www.reddit.com/r/reddit/shirt/969sy/your_ip_ip_address_has_been_logged_your_isp_wrong/ :(
20:58:33 <luite> testglut.exe: user error (unknown GLUT entry glutInit)   -- what can cause these errors? (I get the same type of error when running an OpenGL program)
20:58:38 <dons> BMeph: i don't think flying frog is actually a business.
20:58:40 <copumpkin> Axman6: aw
20:58:44 <Axman6> :'(
20:59:01 <mmorrow> dons: i though they were amphibians myself
20:59:03 <Axman6> that's like the 12th top story of all time, i want my damn shirt!
20:59:08 <dons> i think its a guy trolling usenet. that's not a business model.
20:59:23 <absentia> what language does lying frog use?
20:59:30 <absentia> er, flying.. flying.. not lying.
20:59:38 <dons> oh, its just a guy with a blog. he doesn't write code. :) we make fun
20:59:45 <copumpkin> F# and ocaml
20:59:49 <pikhq> absentia: Yes, message passing is very good for *concurrent* programming. And Haskell does that quite well.
20:59:56 <absentia> oh, right... F#
20:59:58 <copumpkin> now he disses ocaml too cause he has a new F# book out
20:59:59 <dons> well, i'm not sure he actually writes code as part of his business.
21:00:01 <BMeph> absentia: I hope you're prepared to be quoted a ot! ;)
21:00:09 <BMeph> *lot
21:00:13 <dons> usenet isn't a target platform
21:00:19 <absentia> bmeph: why?
21:00:25 <copumpkin> lying frog
21:00:27 <copumpkin> that's cute
21:00:29 <absentia> did I put my foot in my mouth again?
21:00:30 <copumpkin> if only he were french
21:00:35 <luite> I run haskell platform 2009.2.0.2 on windows (amd64), my opengl and glut packages are installed by cabal-install, no errors were reported
21:00:51 <absentia> I was reading some huge thrad the other day where the frog guy kept demanding that some other guy write a program that was approached the speed of C or something.
21:00:56 <Makoryu> dons: He writes lots of highly optimized fibs functions
21:00:56 <absentia> it was quite funny.
21:01:02 <Makoryu> dons: If you know what I mean
21:01:29 <copumpkin> didn't he write a slow raytracer in mathematica to show that mathematica is slow?
21:01:35 <pikhq> absentia: A program approaching the speed of C? Haskell can do that. ;)
21:01:42 * absentia can write a slow ______ in any language!
21:01:56 <copumpkin> absentia: yeah, but yours isn't a PROOF that the language is slow, his is
21:02:06 <absentia> pik: ya, loking at the great language shootout...
21:02:08 <andresj> hey, i'm trying to find out how to play, using Haskore, a Haskore.Music.GeneralMIDI.T. any ideas? I found Haskore.Interface.MIDI.Write.fromGMMusicAuto, but i'm not sure how to generate a "Context time dyn Note"
21:02:44 <dons> like i said, that's not a business model. its an internet crank model.
21:02:45 <luite> unfortunately the speed of haskell will never exceed c :p
21:02:49 <shachaf> absentia: I'd like to see you write a slow program in HQ9+.
21:02:50 <dons> luite: hehe
21:02:55 <absentia> slow is relative.. I changed my design in my C++ program over the last two days.. my web app response time went down from like 19+ seconds or more to .2ms
21:03:28 <absentia> luit: maybe.... with the parallel stuff, if you can code faster, have safer implementations.. and then can just crank up the cores....
21:03:36 <shachaf> luite: "languages don't have speeds", etc., etc.
21:03:41 <luite> absentia: it's mass would become infinite :p
21:03:44 <absentia> what's HQ9+?
21:03:50 <shachaf> luite: In the shootout, GHC already beats gcc for thread-ring.
21:03:59 <Makoryu> luite: I see what you did there
21:03:59 <shachaf> @go HQ9+
21:04:00 <lambdabot> http://www.cliff.biffle.org/esoterica/hq9plus.html
21:04:00 <lambdabot> Title: HQ9+
21:04:16 * Axman6 is still quite proud that the top thread-ring entry is his modified version :D
21:04:20 <dons> mmorrow: note the update breaks hmatrix-static (it needs older -meta)
21:04:21 <Makoryu> absentia: A language that satirizes the "Turing tarpits" that were popular a few years back
21:04:23 * absentia goes to find his favorite schlemiel painter algoritm set.
21:04:34 <absentia> oh
21:04:55 <absentia> whre is erlang in thread-ring?
21:04:55 <absentia> :->
21:04:56 <dons> haskell's faster than C on the shootout in 3 programs atm.
21:05:01 <dons> absentia: much slower.
21:05:11 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
21:05:15 <luite> shachaf: I did mean a different c though
21:05:36 <shachaf> luite: ?
21:05:45 <Makoryu> Erlang excels at distributed computation, and actually does pretty poorly with shared memory parallelism
21:05:54 <absentia> just seems to me that haskel is 2-4 times slower than C++ .. with like >~3 being the average.
21:06:12 <dons> about 2x is the average for optimized code.
21:06:18 <dons> erlang's more like 15x?
21:06:20 <Axman6> absentia: depends on the task. and like all languages, you have to know how to write fast code
21:06:38 <dons> C++ is still the low level + type-based optimization king
21:06:43 <copumpkin> the compiler still has a lot of room for improvement
21:06:44 <absentia> haskell only uses one cpu?
21:06:47 <smarmy> i think there's a lot of code out there where a small constant factor isn't a big deal
21:06:48 <absentia> in that benchmark?
21:06:48 <mmorrow> dons: argh. what do you suggest (re: hmatrix)?
21:06:56 <dons> absentia: yes, its more efficient not to swap threads
21:06:59 <dons> the ghc runtime spots that.
21:07:05 <Makoryu> absentia: You can improve the speed further with some effort (including dropping down to C in places). Consider the alternatives though... Scripting languages are 50-100 times slower than C and C++
21:07:09 <mmorrow> dons: (you mean on account of the version constraint only, right?)
21:07:14 <dons> mmorrow: right, yes.
21:07:19 <dons> just fyi. no action required.
21:07:22 <Axman6> absentia: the thread ring benchmark is really a sequencial program
21:07:29 <Makoryu> (I say "scripting languages" like it actually means something... Basically just Perl, PHP, Python, and Ruby)
21:07:35 <absentia> ya, my c++ thing I mentioned before is a server -- not multi-threaded... single threaded...  totally flies.
21:07:36 <smarmy> Makoryu: exactly.  within a small factor of C is inconsequential for common tasks
21:07:37 <mmorrow> dons: ah, ok.
21:07:47 <shachaf> Makoryu: "P languages". :-)
21:07:50 <absentia> axman6:  that's funny.
21:07:51 <luite> shachaf: bah I wanted to give some wikipedia link without immediately revealing the answer, I meant the physical constant c
21:08:06 <copumpkin> absentia: did you just start learning haskell? your nick looks really familiar from somewhere
21:08:12 <shachaf> luite: Ah -- I see.
21:08:26 <luite> sorry for the bad joke ;)
21:10:04 <Makoryu> shachaf: Or perhaps P3R if I don't feel like typing :p
21:10:12 <absentia> ya, just started looking into haskell ... I haven't quite cross the threshold into functional programming yet.  I'm stuck on the other side.
21:10:20 <shachaf> Makoryu: 'R' is an evolved 'P'.
21:10:35 <Makoryu> shachaf: True!
21:10:51 <copumpkin> absentia: welcome then! let's hope you cross soon :D
21:11:03 <Makoryu> shachaf: Write it as Руби and people will be none the wiser
21:11:09 <absentia> I wish the great language shootout had forth.
21:11:22 <absentia> copumpkin:  thanks!
21:11:25 <Makoryu> absentia: Hmm, you can request languages, can't you?
21:11:27 <dons> someone needs to get a forth compiler into every distro.
21:11:35 <dons> and then write entries for all the programs
21:11:40 <copumpkin> there used to be more languages on the shootout
21:11:43 <copumpkin> not sure where they went
21:11:49 <absentia> mak: not important.
21:11:52 <Axman6> they aren't selected by default
21:12:03 <Makoryu> copumpkin: Some of them are hidden from the main index
21:12:05 <sohum> if I have type Foo a b = ..., is there any way to make Foo an instance of Monad?
21:12:22 <dons> sohum: is it wrapping some other monad type?
21:12:28 <dons> like type Foo a b = (a, b) ?
21:12:44 <ezyang> Yes, instance Monad (Foo a) where...
21:12:45 <sohum> dons: no
21:12:51 <dons> 'type' is a shallow synonym, so it is indistinguishable from the underlying type
21:12:59 <Makoryu> sohum: Then you have to write your own instance either way
21:13:02 <absentia> I like forth and the stack machine philosophy, I ust don't have the discipline to not write bad code and shoot myself in the foot.
21:13:07 <tommd> dons: Are you using Control-Engine for something or just playing around?
21:13:20 <sohum> ezyang: I tried that. Type synonym 'Foo' should have 2 arguments, but has been given 1
21:13:21 <luite> hm, are there known problems with the opengl bindings on windows 7, or should I be able to get this to work?
21:13:37 <dons> tommd: http://www.galois.com/~dons/arch-haskell-status.html
21:13:38 <tommd> dons: If you are using it then feel free to give me feedback - I built it just to off-load code from another project and only built a couple toys with it otherwise.
21:13:46 <dons> it just showed up with a red flag
21:13:57 <dons> so no. as long as it builds, i'm fine.
21:14:09 <tommd> I see
21:14:30 <dons> btw, click on 'downloads' -- its sortable :)
21:14:44 <sohum> Makoryu: I'm fine with writing it, that's not an issue. the problem is haskell refuses to understand instance Monad (Foo a) where
21:14:59 <dons> sohum: ah so you have a type error
21:15:42 <absentia> I just wisn there was a programming language that didn't make my eyes bleed.
21:15:45 <sohum> dons: not really. I want (Foo a) to be the monad, because that's what has kind * -> *
21:16:29 <ezyang> Hm. I know you can definitely fix it by newtype'ing it
21:16:30 <suravad> Say I have module X and in X I say import qualified Data.ByteString.Char8 as S.  If I then in another module say import X can I then use X.S?
21:16:40 <andresj> absentia: do you mean the type?
21:16:54 <absentia> just the asthetics.
21:16:55 <andresj> absentia: I have this idea in my head of haskell but neatly typed, like math
21:17:00 <Axman6> heh, i'm running Ada thread-ring entry, it's supposed to take 9 minutes on 4 cores
21:17:09 <Makoryu> sohum: Try constraining the instance. IIRC you can do: instance Num a => Monad (Foo a) where ...
21:17:10 <andresj> absentia: instead of ->, have →. instead of . have center-dot
21:17:17 <Axman6> though, i do still really like Ada's concurrency stuff, it's really well though out
21:17:26 <Makoryu> absentia: The syntax, then?
21:17:28 <absentia> oh, yes, a?? is must better than ->
21:17:29 <absentia> :->
21:17:35 <absentia> mak
21:17:37 <dons> Axman6: you should port Ada's concurrency mechanisms to haskell
21:17:41 <copumpkin> –> is a valid operator
21:17:44 <absentia> mak: yes, mostly syntax.
21:17:48 <suravad> Axman6:  It only took 100 task forces to make. :)
21:17:58 <absentia> I like scala -- unicode variables..   weeeel
21:18:09 <suravad> Anyone on my question?
21:18:15 <Makoryu> Axman6: Is it like Fortran's (parallelized splice assignments)?
21:18:25 <Axman6> dons: i'm not sure they could be ported easily. they sort of rely on imperative code
21:18:28 <Makoryu> Axman6: Wait, scratch that, you said concurrency
21:18:33 <aavogt> suravad: no, exports aren't qualified
21:18:37 <Cale> suravad: the answer is no, unfortunately.
21:18:47 <suravad> Is there anyway to do something like that?
21:18:59 <dons> Axman6: the IO monad is there for you.
21:19:15 * dons has a theory you can build any concurrency construct with MVars and forkIO
21:19:32 <Axman6> yeah
21:19:53 <suravad> aavogt/Cale?
21:20:09 <Makoryu> suravad: You can re-export types, preferably by defining "type Foo = SomeOtherModule.Bar"
21:20:14 <fynn> What's the most recent Sweeney reference to possible use of (a) Haskell(-like) language for programming GPGUs like Larrabee?
21:20:25 <BMeph> You can't do a qualified export? :)
21:20:25 <dons> data parallel haskell on the gpu
21:20:32 <suravad> Makoryu:  Sweet... That'll do. :)
21:20:54 <aavogt> BMeph: you can?
21:20:55 <suravad> Makoryu:  But won't that treat it as a totally unique type?
21:20:57 <dons> fynn: http://www.comlab.ox.ac.uk/ralf.hinze/WG2.8//26/slides/manuel.pdf
21:21:00 <Axman6> not sure how well you could do rendezvous with haskell cleanly. it's ppossible, but... i don't know how :)
21:21:15 <dons> write haskell-cafe@ saying it is impossible :)
21:21:22 <BMeph> aavogt: No fair, I asked first. :)
21:21:22 <Axman6> dons: if you're interested, take a look at http://www.adahome.com/Tutorials/Lovelace/s13s2.htm (hopefully it's somewhat clear)
21:21:38 <Makoryu> suravad: No. That's how String is aliased to [Char]... Note that they're completely interchangeable in all situations
21:21:39 <dons> btw, idea: i'd like a set of pandoc-based markdown combinators, http://www.reddit.com/r/haskell_proposals/comments/9bljg/a_markdown_edsl_based_on_pandoc/
21:21:50 <suravad> Makoryu:  Sweet.  Thanks.
21:21:57 * suravad is slowly learning Haskell.
21:22:00 <fynn> dons: thanks!
21:23:10 <sohum> ezyang: I can't find a way to fix it with newtypes
21:23:12 <fynn> dons: (not Sweeney, though ;)
21:23:14 <Axman6> anyway, with natural deduction, and or elimination, we've been given (P v Q ([P] => r) ([Q] => r))/r. does r have to be P or Q? or can it be any arbitrary thing?
21:23:18 <copumpkin> fynn: also look for gpugen and obsidian
21:23:20 <dons> right, but he's referring to that.
21:23:28 <dons> gpugen. data parallel haskell in general
21:23:36 <Axman6> (i hope that syntax makes some sense, writing proofs on IRC is hard)
21:23:38 <dons> tim's a great guy. he happily wrote a great blurb on the back of RWH.
21:23:39 <fynn> I guess the last specific Sweeney reference is is his 2006 presentation
21:23:56 <fynn> his latest doesn't mention Haskell by name :(
21:24:06 <sohum> Makoryu: why would constraining the instance help?
21:24:38 <ezyang> sohum: What you do is you define a newtype that is a wrapper around (Foo a).  It's basicaly the same as constraining it, except even more so
21:24:51 <Makoryu> sohum: I'm.... not actually sure. I seem to recall it working
21:25:05 <Makoryu> Rather, I think I saw that somewhere
21:26:28 * Makoryu really should know the type system a lot better than he does right now
21:26:52 <BMeph> Heh-heh, "Laziness prevented bad habits" - now THAT should be on a T-shirt! :)
21:28:31 <sohum> ezyang: how do I wrap Foo a without losing the generality of the a?
21:28:42 <ezyang> You can't.
21:28:55 <ezyang> (at least, not that I know of)
21:29:00 <horms> t
21:29:02 <horms> oops
21:29:28 <shachaf> sohum: Is this the type synonym thing?
21:30:19 <sohum> shachaf: kinda. I have a type Foo a b = ..., and I want to make (Foo a) an instance of Monad. haskell chokes on instance Monad (Foo a) where...
21:30:39 <shachaf> sohum: You can't do that, you have to use a newtype.
21:30:53 <ezyang> or constrain a
21:30:53 <shachaf> sohum: type is really a type synonym; it's indistinguishable from the original type.
21:31:07 <absentia> good night.
21:31:15 <absentia> xn/win shrink 3
21:31:15 <absentia> xn/win shrink 3
21:31:28 <copumpkin> :o
21:34:07 <hackagebot> control-event 1.1.0.0 - Event scheduling system. (ThomasDuBuisson)
21:34:59 <sohum> shachaf: newtype barfs on the forall I have in it. I guess I have to use a data, then
21:35:26 <shachaf> sohum: What, is this an existential type?
21:35:31 <shachaf> sohum: What are you trying to do exactly?
21:36:07 <sohum> shachaf: type Parser a b = forall m. Monad m => a -> m (b,a)
21:36:51 <copumpkin> onoes, monadic parser :(
21:36:59 <ezyang> Just... use parsec...
21:37:08 <sohum> ezyang: can't, that would be cheating
21:37:13 <sohum> ;)
21:37:16 <ezyang> Oh, is this RWH's fault?
21:37:32 <sohum> no, but same idea
21:38:11 <ezyang> I feel like there was some GHC option that would make this work
21:38:47 <sohum> ezyang: the type declaration? yep, -XLiberalTypeSynonyms
21:38:59 <purejadekid> 'cabal update' gives me 'Warning: No remote package servers have been specified. Usually you would have one specified in the config file.'
21:39:03 <ezyang> oh, no not that, writing the instance
21:39:08 <sohum> ezyang: but that's not working too well with the instance, so...
21:39:09 <purejadekid> but the docs say 'Note that the ~/.cabal/config file is not created until you run a cabal command for the first time, eg cabal update.'
21:40:04 <purejadekid> I can't for the life of me find the syntax for the line that will say something like "remote-repo: http://hackage.haskell.org/foo"
21:40:20 <purejadekid> then 'cabal update' will be happy and so will I
21:41:27 <dons> remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
21:42:41 <purejadekid> dons: thanks. wow I got pretty close just guessing it and grep-ing the source
21:44:12 <Makoryu> sohum: Constraining the instance (instance Bar a => Monad (Foo a) where ...) does in fact work, for what it's worth
21:44:42 <sohum> Makoryu: where Foo is defined as type Foo a b = ... ?
21:44:50 <Makoryu> sohum: Yep
21:45:47 <Makoryu> sohum: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3353#a3353
21:45:55 <sohum> Makoryu: ...weird. I'm still getting the "should have 2 arguments" error
21:46:35 <sohum> Makoryu: ..Foo is defined as data Foo a b in your paste
21:47:09 <Makoryu> sohum: Oh shit, I misread that
21:47:36 <Makoryu> Sorry. Hrm.
21:47:41 <sohum> np, just crush my hopes why dontcha ;)
21:48:52 <Saizan> what's the original prolem?
21:52:42 <purejadekid> now 'cabal update' or 'cabal install foo' both yield 'cabal: fromFlag NoFlag. Use fromFlagOrDefault'
21:54:02 <dons> purejadekid: which version of Cabal and cabal-install ?
21:54:09 <dons>     Cabal-1.6.0.3
21:54:27 <Makoryu> Saizan: sohum's type is defined as "type Foo a b = ..." and he wants to write "instance Monad (Foo a) where ..."
21:54:29 <dons> $ cabal -V
21:54:29 <dons> cabal-install version 0.6.2
21:54:49 <purejadekid> cabal-install 0.6.2 cabal 1.6.0.2
21:55:03 <sohum> Saizan, which apparently you can't, whithout adding the extra verbosity of a newtype or data
21:55:17 <dons> trying updating to Cabal-1.6.0.3. cabal install Cabal ; cabal install cabal-install
21:55:48 <purejadekid> cabal install Cabal -> cabal: fromFlag NoFlag. Use fromFlagOrDefault
21:57:45 <purejadekid> can you cat your config file? Maybe I'm missing something basic. When cabal-install finished installing no config file was created so mine just has remote-repo: foo and symlink-bindir: foo
21:58:00 <blackdog> mike-burns: i have a cheer squad now, it appears. suppose i'd better get it finished :)
21:58:02 <tommd> What? No votes for the LambdaCalculator - this is an outrage!
21:58:20 <dons> purejadekid: http://www.galois.com/~dons/config
22:00:27 <purejadekid> dons: 'remote-repo-cache: foo' and then 'cabal update' made it so cabal install Cabal works
22:00:57 <dons> great
22:01:06 <dons> how did you config file get mangled?
22:02:44 <tommd> unsafeMangleConfig - we really should rethink the automatic generation of random implementations for functions that start with the word 'unsafe'.
22:02:54 <tommd> It was a bad feature.
22:03:02 <purejadekid> dons: it never existed
22:03:19 <dons> tommd: haha
22:03:19 <purejadekid> I installed cabal-install form a tar.gz  (bootstrap.sh on Mac OS X Leopard)
22:03:27 <dons> tommd: actually -- that is a package i want to see on hackage
22:03:58 <tommd> Randomly rewrite 'unsafe*' to _something_?  I'd love to see it.
22:04:16 <dons> randomly generate unsafe* functions
22:04:31 <dons> also, i want some evil RULES packages
22:04:34 <tommd> yes, 'rewrite' could mean 'generate' if no implementation exists.
22:04:44 <tommd> I was considering how to do this with RULES actually.
22:04:48 <dons> that you import System.Harmless, and it rewrites f x = .. evil .. x
22:04:53 <purejadekid> with unsafeCoerce, don't all unsafe functions technically already have the same type?
22:05:17 <tommd> purejadekid: They all have any type you want.
22:07:54 <purejadekid> btw are the '-- foo' lines in .cabal/config comments? or some sort of sub-option?
22:08:16 <tommd> -- is a comment in Haskell land
22:08:31 <purejadekid> tommd: and in cabal land?
22:08:36 <tommd> so is {-  comment! -}
22:08:36 <tommd> but I don't think you'll see that in cabal.
22:08:37 <copumpkin> same
22:09:57 <tommd> cabal is a peninsula belonging to the kingdom of Haskell and connects it to the kingdom of mortals.
22:12:25 <Makoryu> I thought Haskell was a republic
22:12:40 <purejadekid> the People's Republic of Simons
22:12:42 <Makoryu> At least, that's what they call it at the Ministry of Safety and Happiness
22:13:17 <dons> i think its a revolutionary movement :) it is unclear if we've established a republic yet
22:14:23 <Axman6> dons: one of the computer labs here has been names 'The People's Glorious Revolutionary Computer Lab" :)
22:14:27 <Axman6> named*
22:14:50 <ezyang> Goodnight #haskell. It was fun times!
22:14:54 <Axman6> o/
22:15:00 <luite> hm, reinstalled haskell platform, so I'm sure I used the preinstalled version of the OpenGL bindings: TestOGL.exe: user error (unknown OpenGL call glGenBuffersARB, check for GL_ARB_vertex_buffer_object or OpenGL 1.5)
22:15:02 <purejadekid> hackage must be the capital of cabal land
22:17:12 <purejadekid> luite: I never have been able to get OpenGL shader stuff to compile in Windows, even outside of Haskell
22:18:03 <luite> purejadekid: the main problem is that this error appears right after starting the program, and that the program doesn't run at all
22:18:57 <purejadekid> so it compiles/links. do you think the drivers are dlls and are missing the ARB extensions for shaders?
22:19:23 <purejadekid> also, have you gotten a simple C+OpenGL+shaders app working with said OpenGL drivers?
22:19:39 <purejadekid> just as a reference point?
22:19:52 <luite> it does compile yes
22:20:25 <luite> I have a working haskell thing that doesn't directly use OpenGL but uses glut instead (I had to get a glut32.dll file in that directory though)
22:22:39 <purejadekid> does basic OpenGL/glut work for you? I remember having luck with that in Windows but not much beyond that (when the same OpenGL project would work in Linux or OS X) specifically with shaders
22:24:41 <luite> it seems to work (I can render a sphere without textures or shaders)
22:25:56 <luite> is there some command on windows (or haskell/ghci) that prints the supported opengl extensions, like glxinfo in linux?
22:28:14 <kyagrd> last time when I used windows on a physical machine there would be some control pannel in windows about graphic card acceleration and etc
22:29:04 <kyagrd> it was quite a while ago, but I believe there would be some similar things now.  Maybe there would be one that you can download and install from the opengl homepage.
22:30:57 <luite> ah I found a GLEW info tool
22:31:27 <luite> which says that everything higher than OpenGL 1.1 is missing....
22:31:32 <luite> that might be a problem :p
22:32:18 <luite> OpenGL vendor string: Microsoft Corporation
22:32:18 <luite> OpenGL renderer string: GDI Generic
22:32:19 <luite> OpenGL version string: 1.1.0
22:33:13 <p_l> luite: it means that you don't have OpenGL driver installed
22:33:39 <luite> yeah I figured, but I have the latest ATI drivers installed
22:33:55 <p_l> luite: then it means that the installation is broken somehow
22:34:28 <p_l> or GLEW is broken with regards to Windows GL model
22:34:43 <p_l> but I doubt it :D
22:46:21 <fynn> dons: any idea how many of the ideas from the 2005 presentation actually got anything close to implementation?
22:50:16 <copumpkin> fynn: which is that?
22:50:21 <copumpkin> (presentation that is)
22:50:35 <fynn> copumpkin: the 2005 Sweeney presentation.
22:50:40 <copumpkin> hmm
22:51:09 <copumpkin> still not sure which that is :P
22:51:12 <fynn> He praises things like ST and STRef, and writes a lot about how great it would be to have tools that have all those capabilities that Haskell has.
22:51:28 <fynn> copumpkin: http://www.google.com/url?sa=t&source=web&ct=html&cd=1&url=http%3A%2F%2F74.125.155.132%2Fsearch%3Fq%3Dcache%3AwlTJdRbLmjoJ%3Awww.st.cs.uni-saarland.de%2Fedu%2Fseminare%2F2005%2Fadvanced-fp%2Fdocs%2Fsweeny.pdf%2Bsweeney%2Bhaskell%26cd%3D1%26hl%3Den%26ct%3Dclnk%26gl%3Dus&ei=jS2KSozOOIOcsgOvoInEDQ&usg=AFQjCNGsiq9b6uIuTMrevXY_BpcgiqCmXA&sig2=q5p5Q1N-UV9RU2i_bmEBCw
22:51:40 <fynn> woops, damn Google links
22:51:41 <copumpkin> ah, thanks
22:51:50 <jre2> > pl \x y -> x y
22:51:52 <lambdabot>   <no location info>: parse error on input `\'
22:52:13 <shachaf> jre2: @pl (and the answer is id or ($).)
22:52:34 <jre2> @pl \x y -> x y
22:52:35 <lambdabot> id
22:53:09 <jre2> @pl \x -> a x + b x
22:53:09 <lambdabot> liftM2 (+) a b
22:53:36 <jre2> shachaf: thanks
22:54:44 <solrize> there's a pdf of that
22:55:40 <Axman6> @pl \x -> x*x
22:55:40 <lambdabot> join (*)
22:55:44 <solrize> groups.csail.mit.edu/cag/crg/papers/sweeney06games.pdf
22:55:55 <Axman6> :t (->) join
22:55:57 <lambdabot> parse error on input `->'
22:56:00 <Axman6> dang it
22:56:06 <Axman6> @src (->) join
22:56:06 <lambdabot> Source not found. You type like i drive.
22:58:24 <Axman6> @botshuvit
22:58:24 <lunabot>  :)
22:58:25 <lambdabot> Unknown command, try @list
22:58:32 <luite> p_l: yep, something was wrong with the installation of the driver. I have now installed it manually (by extracting the ati driver package, modifying the .inf file and installing from device manager), and it works fine now :)
22:58:36 <shachaf> @src join
22:58:36 <lambdabot> join x =  x >>= id
22:58:41 <Axman6> heh, that worked out better than expected
22:59:09 <luite> apparently ati's windows 7 driver package is borked
22:59:13 * copumpkin stares at Saizan
22:59:15 <shachaf> Axman6: For (r ->), join f x = f x x
22:59:46 <Axman6> yeah, i was explaining it to a friend
23:01:29 <copumpkin> induction :: forall p n. Nat n => n -> p Z -> (forall x. Nat x => p x -> p (S x)) -> p n
23:01:36 * copumpkin loves haskell
23:03:07 <Axman6> jesus copumpkin >_<
23:03:21 <Axman6> you hurt my brain far too often these days, i don't think we can be friends
23:03:26 <copumpkin> lol
23:04:16 <Axman6> src?
23:05:12 <copumpkin> I went back to that email from ryan ingram a while back on simple dependent types in haskell
23:05:25 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
23:06:43 <copumpkin> it's rather mind-bending
23:06:49 <copumpkin> for me at least :)
23:07:04 <copumpkin> still stuck on proving commutativity
23:11:31 <jre2> is there a more concise way of expressing "foo x = f x + g x" when f and g are pure? using liftM2 just makes it more convoluted
23:12:16 * BMeph immediately thinks of a more convoluted way, involving `on`...
23:12:23 <copumpkin> nope
23:12:28 <copumpkin> on has two vars
23:12:40 <copumpkin> unless you join the result :P
23:13:03 <copumpkin> jre2: why is it more convoluted?
23:13:14 <BMeph> copumpkin: (+) `on` ($x) >;)
23:13:27 <copumpkin> lol
23:13:38 * BMeph chuckles evilly
23:13:42 <Makoryu> jre2: If you instantiate Num a => Num (a -> a), you can define (+) = liftM2 (+) and then write "foo = f + g"
23:13:46 <Makoryu> :t on
23:13:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:14:00 <copumpkin> @pl \x -> (+) `on` ($x)
23:14:01 <lambdabot> ((+) `on`) . flip id
23:14:13 <copumpkin> on (+) . flip id
23:14:17 <copumpkin> not too bad :P
23:14:25 <Makoryu> flip id?!
23:14:33 <copumpkin> :t flip id
23:14:34 <Makoryu> :t flip id
23:14:35 <lambdabot> forall b c. b -> (b -> c) -> c
23:14:36 <lambdabot> forall b c. b -> (b -> c) -> c
23:14:43 <Saizan> flip id x == ($x)
23:15:01 <Makoryu> Ah
23:15:13 <Saizan> ($) = id
23:15:19 <copumpkin> Saizan: are you too asleep to give hints for that old problem I was working on? :P
23:15:30 <BMeph> :t let (^+^) = liftM2 (+) in (?f) ^+^ (?g)
23:15:32 <lambdabot> forall (m :: * -> *) a1. (?g::m a1, ?f::m a1, Monad m, Num a1) => m a1
23:15:43 <Saizan> copumpkin: not more than usual :) where are you stuck?
23:15:55 <Makoryu> BMeph: Hmm, what's the ? for?
23:15:56 <copumpkin> the inductive case for commutativity :( still
23:16:19 <copumpkin> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8275#a8275
23:16:33 <copumpkin> the problem is the last line
23:17:02 <BMeph> Makoryu: Implicit Parameter - it tells GHCi (and lambdabot) to "fill in the type" for you. :)
23:17:05 <Saizan> oh, you've done it with induction, let me see
23:17:14 <copumpkin> how would you do it?
23:17:27 <copumpkin> also, I think my plusZeroIsComm might be useless
23:17:35 <copumpkin> given that it's doing it in the same order as my :+
23:18:41 <BMeph> I just read an oleg/CCS paper doing that, but the first argument was the one pattern-matched.
23:18:52 <jre2> can anyone explain "Monad ((->) a1)"? (from the type of liftM2 (+) f g)
23:19:45 <shachaf> jre2: It's like the Reader monad.
23:19:52 <Makoryu> jre2: Normally, function types are written (a -> b), right? But you can always convert infix notation to prefix notation even in a type signature, so (a -> b) is the same as (->) a b
23:20:00 <shachaf> Just expand out the types and it'll make more sense. :-)
23:20:32 <Makoryu> jre2: And then that's curried, so that the return value is the "free" parameter to the Monad instance
23:20:50 <Makoryu> The type of the return value, I should say
23:21:40 <Makoryu> jre2: Make sense?
23:22:56 <jre2> Makoryu: I think I follow, but I'm not sure what to do with the result, so perhaps not.
23:23:57 <shachaf> jre2: Look at the type of liftM2:
23:23:59 <shachaf> @ty liftM2
23:24:00 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:24:19 <shachaf> liftM2 :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c
23:24:33 <shachaf> If you replace "m x" with "r -> x", you get:
23:24:49 <shachaf> liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> r -> c
23:24:53 <Saizan> copumpkin: no, plusZeroIsComm seems necessary
23:25:01 <copumpkin> hmm ok :)
23:25:10 <copumpkin> I had convinced myself it was last time I worked on this
23:25:17 <copumpkin> and then I looked back and wasn't so sure
23:25:47 <jre2> shachaf: that version is clear
23:28:13 <Saizan> however for the other case the proof goes like:  "y + S z =(+def) S (y + z) =(w) S (z + y) =(+def) z + S y"
23:28:34 <Saizan> copumpkin: where w is the PlusIsComm y z witness
23:28:55 <copumpkin> ah, hmm
23:29:24 <Saizan> so i wonder why it doesn't work directly
23:29:47 <Saizan> maybe it's the (w) passage that needs an help to apply the proof under the S
23:33:07 <copumpkin> hmm
23:40:26 <Trinithis> > not `($)` True
23:40:27 <lambdabot>   <no location info>: parse error on input `('
23:41:42 <sohum> :type <bla> gives <bla? :: (Monad m) => m (Char, [Char]). why does the monad not get printed when I run the code?
23:42:42 <sohum> alternatively, when <bla> calls fail, ghci just locks up. whether I suffix it with :: Maybe (Char, [Char]) or not. why?
23:49:48 <jre2> can you define "foo f g h x = f (g x) (h x)" in terms of liftM2?
23:50:52 <copumpkin> yeah, that is liftM2 :P
23:50:59 <copumpkin> or liftA2
23:51:13 <jre2> what about the other way around?
23:51:42 <copumpkin> @type liftA2 `asTypeOf` let foo f g h x = f (g x) (h x) in foo
23:51:43 <lambdabot> forall a b c t. (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
23:51:44 <hackagebot> control-event 1.1.0.1 - Event scheduling system. (ThomasDuBuisson)
23:52:01 <copumpkin> liftM2 and liftA2 are more general than foo
23:52:11 <Saizan> copumpkin: gah, my conclusion was not what we wanted to prove there
23:52:28 <copumpkin> Saizan: I was having trouble getting somewhere :P
23:52:32 <copumpkin> but assumed it was me being stupid
23:52:45 <copumpkin> so what I'm really trying to get is
23:52:45 <copumpkin> (z :+ y) :== (y :+ z)          ->         (S z :+ y) :== (y :+ S z)
23:52:54 <copumpkin> forall z.
23:53:04 <purplepenguins> man, i've been unlucky with armor...
23:53:05 <Saizan> i get to prove y + S z = z + S y, but we need = S z + y
23:53:23 <copumpkin> ah :)
23:53:31 <purplepenguins> oops wrong window
23:53:47 <copumpkin> Saizan: can't I get to the latter one though?
23:53:54 <Trinithis> @ty \x y -> ap x (y `asTypeOf` (\r -> w))
23:53:56 <lambdabot> forall b t. (Monad ((->) t)) => (t -> Expr -> b) -> (t -> Expr) -> t -> b
23:54:34 <Saizan> copumpkin: i think so, similar to how you do it in plusZeroIsComm
23:56:07 <Optimo> Not enough pictures, copumpkin: http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html
23:56:25 <copumpkin> lol
23:56:33 <Optimo> im super cereal
23:56:57 <Optimo> I will read it after breakfast tho
23:57:41 <Optimo> gnight lil rhaskells
