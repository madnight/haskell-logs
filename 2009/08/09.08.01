00:20:08 <copumpkin> @@ @djinn @type on
00:20:10 <lambdabot>  f a b c _ = a (b c) (b c)
00:20:33 <copumpkin> @@ @djinn @type \f -> liftM2 f
00:20:35 <lambdabot>  Cannot parse command
00:22:12 <copumpkin> @djinn (a -> b ->c) -> (d -> a) -> (d -> b) -> d -> c
00:22:13 <lambdabot> f a b c d = a (b d) (c d)
00:22:20 <copumpkin> oh djinn
00:36:26 <copumpkin> using iterate feels dirty somehow
00:37:13 <dufflebunk> When I run 'runhaskell Setup.lhs configure --user --enable-executable-profiling', then build it, it keeps trying to link in profiling versions of other libraries like regex-tdfa. Anyone know how to get it to stop doing that?
00:37:29 * dufflebunk seems to be having lots of trouble with cabal today
00:37:59 <copumpkin> I don't think it'll let you only have a partially profiling-enabled binary
00:39:36 <hackagebot> pop3-client 0.1 - POP3 Client Library (PeterVanDenBrand)
00:40:20 <dufflebunk> that would be odd
00:42:17 <dufflebunk> I tried install regex-tdfa with the executable profiling enable, it didn't install the profiling lib.
00:44:24 <dufflebunk> if I run the ghc command without the -package and -hide-all-packages it works... good enough for now I guess.
00:46:52 <dufflebunk> bah, nope, didn't work.
00:53:40 <hackagebot> pop3-client 0.1.1 - POP3 Client Library (PeterVanDenBrand)
01:33:48 <thaldyron> Is there a function that checks if a string is a valid posix regexp?
01:34:33 <gwern> hm. how many strings aren't valid regexps?
01:35:04 <Berengal> hdbc vs haskelldb vs takusen?
01:35:06 <gwern> not many I'd think; the only invalid ones are just those that don't close ranges or something, I'd expect
01:36:30 <thaldyron> gwern: exactly, the problem is that I need to catch those before (=~) throws an exception
01:36:39 <gwern> why not catch the exception?
01:37:02 <Berengal> It throws an error, not an exception
01:37:46 <gwern> that's rotten; you should complain about that
01:37:53 <thaldyron> Berengal: I think it throws an IOException
01:37:55 <gwern> an error for a bad regexp is a bit much
01:38:09 <Berengal> thaldyron: I got a user error
01:42:21 <thaldyron> Berengal: well the following handler catches it:
01:42:25 <thaldyron> (print $ ("blba" =~ "[a-z" ::  Bool)) `catch` (\(e::IOException) -> print $ "EXCEPTION " ++ show e)
01:43:47 <dmwit> Throw in a little unsafePerformIO and that might even be usable.
01:44:59 <Berengal> It seems to me it might use unsafePerformIO already, since I can only find IO functions to compile...
01:45:20 <Berengal> (Which return an Either, so might be nicer to use)
01:46:31 <dmwit> validRegexp re = unsafePerformIO (return (("" =~ re) `seq` True) `catch` (const (return False)))
01:47:59 <Berengal> Prelude Text.Regex.Posix Control.Monad.Error> "" =~~ "asdf[asdf" :: Either [Char] Bool
01:47:59 <Berengal> *** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 7,"Unmatched [ or [^"))
01:48:02 <Berengal> :(
01:48:38 <dmwit> Berengal: Try my off-the-cuff regex validator and let me know how you like it. ;-)
01:48:39 <Berengal> That one could at least use fail
01:48:47 <dmwit> yeah
01:49:08 <Berengal> dmwit: I'm not the one who has a use for it. I use parsec :P
01:49:08 <dmwit> Actually, no, unless it has an (Error e) => constraint on the first argument to the Either in its type.
01:49:36 <Berengal> String is an Error
01:49:37 <dmwit> 30 year warrantee!*
01:49:49 <dmwit> (the fine print: * if it breaks you get to keep all the pieces)
01:50:10 <dmwit> Berengal: Right, but I'm saying the type of =~~ has to advertise the Error constraint.
01:50:30 <dmwit> Whether or not the concrete type you've chosen happens to be an instance of Error is immaterial here.
01:50:31 <Berengal> No, it needs to advertise the Monad constraint, which it does
01:50:42 <Berengal> Since Monad has fail
01:50:43 <dmwit> Sure, or that. =)
01:50:46 <mmorrow> in "([|res.(0); rcx|], res)" in ocaml, is "[|...|]" some kind of quoting mechanism (of some sort)?
01:53:08 <mmorrow> heh, n/m it's an array :)
01:53:47 <mmorrow> for a second there i thought something tricksy was happening..
01:57:24 <gwern> for a moment I was trying to figure out what the ; was doing there
01:57:55 <gwern> then I saw that it was ocaml
02:06:41 <Berengal> I wonder if I can write my own irc client...
02:11:21 <thaldyron> Is there a reason why there's no "Exception e => MonadError e IO" instance, but only a "MonadError IOError IO" instance?
02:12:38 <Deewiant> Because Exception is a lot newer than MonadError and IOError
02:12:47 <pozic> Heinrich Apfelmus writes "But fortunately, it is very easy to change data structures in Haskell." It is my understanding that changing data structures in Haskell is more difficult than in any other normal imperative programming language, because of the change to monadic code, which is often a global change, which requires a lot of work. I say this because he uses a hashtable as an example of such a data structure to which it is supposedly easy to switch.
02:13:44 <Deewiant> pozic: Why would monadic code be any different from non-monadic code in this sense
02:14:31 <Berengal> Monadic code uses combinators, which work on functions, not data
02:15:25 <thaldyron> Deewiant: I see - well the Exception instance is straightforward anyways...
02:16:44 <|Jedai|> pozic: changing data structure is not hard, especially since the compiler will tell you where your old code isn't correct anymore in most case
02:17:37 <|Jedai|> pozic: but transforming a pure program to use monadic style because you want a new functionality and you need a monad for it while not difficult is tedious at best :)
02:17:59 <|Jedai|> pozic: at least you only have to do it once
02:18:23 <Gilly> What is the preferred way to implement an authentication system in Happstack?
02:18:41 <|Jedai|> Gilly: There was a blog article on that somewhere
02:19:21 <Gilly> Alright, I'm gonna check if I can find it.
02:19:32 <|Jedai|> Gilly: and isn't there an exemple in the tutorial ?
02:20:21 <Gilly> Yea but I find the tutorial a bit complex. :)
02:20:31 <|Jedai|> Gilly: http://softwaresimply.blogspot.com/2008/02/using-happs-state.html
02:20:45 <Gilly> And I also read about this happstack-auth package but it isn't in Hackage yet.
02:20:52 <|Jedai|> Gilly: You have authentification somewhere in there
02:21:29 <Gilly> Thanks, I'm going through that.
02:21:36 * dmwit aGeneralGameInfo<ESC>21a Nothing -- lololol
02:26:27 <|Jedai|> Gilly: http://softwaresimply.blogspot.com/2009/04/adding-authentication-to-blog-app.html
02:26:39 <|Jedai|> Gilly: Maybe this would be more up to date
02:28:52 <pozic> |Jedai|: yes, you only have to do it once, but it is something you don't have to do in any other programming language, because by default everything already runs in the IO monad.
02:29:20 <Gilly> Yea - it uses the happstack-auth module I mentioned. But to me it seems its not meant to be used in real projects yet (it's not even in Hackage).
02:33:32 <|Jedai|> Gilly: it's not "polished", which could mean the interface is a little rough around the edge
02:33:59 <|Jedai|> Gilly: but I don't know if it could be used in real projects or not
02:34:11 <stanv> does bad to use `!!' operator ?
02:34:49 <dmwit> stanv: Generally, yes.
02:35:19 <stanv> :((
02:35:25 <dmwit> stanv:
02:35:28 <dmwit> ?hpaste
02:35:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:35:37 <dmwit> stanv: Maybe we can help you get rid of your !! operators.
02:36:11 <Gilly> |Jedai|: They also say that the way they store passwords hasn't been solidified yet.
02:37:07 <|Jedai|> stanv: it depends on the size of your index, but on the other hand you really shouldn't need it very much, or you shouldn't be using lists in the first place
02:37:31 <|Jedai|> stanv: Haskell has a pretty nice array library
02:37:52 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7788#a7788
02:38:39 <|Jedai|> Gilly: Well, take a look, maybe you could use it as a base at least
02:41:40 <|Jedai|> stanv: You should probably be using an array
02:42:49 <stanv> ok :)
02:45:14 <|Jedai|> stanv: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7788#a7789
02:45:37 <|Jedai|> stanv: but if you want to use a list, do something like that
02:47:46 <stanv> :) cool :)
02:48:24 <|Jedai|> stanv: or rather that (if you really need it, length isn't a very good idea on lists either) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7788#a7790
02:48:41 <|Jedai|> but on the other hand, with an array it would really be easier
02:49:48 <|Jedai|> pictureToRep pic = (snd (bounds pic), filter (pic ! i == '#') . range (bounds pic))
02:50:02 <|Jedai|> or something like that
02:50:16 <stanv> so, pic!!y!!x - is bad thing, right ?
02:50:29 <|Jedai|> stanv: right
02:50:40 <stanv> ok
02:51:00 <|Jedai|> stanv: every time you call that you have to read again your list from the beginning
02:51:59 <|Jedai|> So, let say your picture is h*w, the complexity of my proposition would be O(hw) while your first would be O(h²w²)
02:53:14 <stanv> ok :)
02:53:26 <|Jedai|> stanv: Your second one was correct though
02:53:47 <stanv> it wasn't my:))
02:54:06 <stanv> i copy past from other student :)
02:56:14 <|Jedai|> stanv: he had the right idea, his code is a little bit verbose, but it's correct and the complexity is O(hw)
02:58:57 <stanv> it to hard learn haskell in 26 years :(
02:59:36 <dmwit> hehe
02:59:48 <dmwit> I guess you mean at age 26, but the way you said it is very funny. =)
02:59:54 <|Jedai|> In 26 years ? I think 4 months is enough to get the basics, after that...
03:00:19 <Berengal> I don't think anyone knows haskell completely...
03:00:44 <|Jedai|> Depends on what "know" means I guess
03:00:51 <vegai> Learn Haskell in 30 years!
03:00:54 <stanv> |Jedai| - think in haskell very well
03:01:25 <|Jedai|> It's easier to know the whole language than C++ but the possibilities are endless ^^
03:01:46 * ppavelV6 started learning haskell in 34. Worries if he has enough time to master it
03:01:51 <Berengal> |Jedai|: I guess I'm sort of including all the CT and all that stuff as well into the language...
03:02:14 <stanv> I know C++ in deep :)
03:02:15 <|Jedai|> Berengal: If you see it that way, sure !! ;)
03:03:13 <ppavelV6> Haskell is a culture on its own not just the language
03:03:22 <|Jedai|> stanv: all the template subtleties, memory allocation curstomization, Boost ...?
03:04:02 <Berengal> Haskell has a lot of extensions though, unlike other languages.
03:04:02 <stanv> 3 from 5 :)
03:04:12 <Berengal> Knowing the report is not enough
03:04:52 <|Jedai|> Berengal: Right, but it's enough to do a good deal already, it won't allow you to understand all the Haskell around tho
03:05:01 <stanv> Haskell leadership, constructor now work for Microsoft :( on F# language %(
03:05:18 <|Jedai|> stanv: You're confused
03:05:29 <|Jedai|> stanv: SPJ don't work on F#
03:05:42 <|Jedai|> stanv: though he works for Microsoft Research
03:06:54 <stanv> hmm, ok
03:07:01 <|Jedai|> stanv: the F# creator came from the functional (OCaml, Haskell) word but he wasn't the primary worker on Haskell at all
03:07:27 <Berengal> There are worse things than F# as well...
03:07:39 <Berengal> Well, I assume so. It's functional
03:08:23 <|Jedai|> Right, F# isn't a bad language, they're trying interesting things (though the interaction with .Net and its type system is a little bit iffy IMHO)
03:08:26 <ppavelV6> GHC is a masterpiece. Better code generation will not harm though
03:09:12 <|Jedai|> ppavelV6: Yep, and shared libraries, and in a far away future we'll even have binary compatibility
03:09:32 <Athas> Is there a useful way to search documentation on hackage.haskell.org?
03:09:39 <|Jedai|> ppavelV6: and they still have to improve the type family
03:09:41 <pozic> GHC a masterpiece? Since when?
03:09:41 <vegai> ghc is a tad large
03:09:51 <Berengal> Athas: There's hoogle
03:09:55 <Athas> Or more specifically, is there a more useful set of documentation for the X11 package?
03:09:58 <ppavelV6> |Jedai| binary compatibility with what?
03:10:12 <trofi> with prev versions
03:10:23 <pozic> ppavelV6: between multiple implementations and starting with GHC versions.
03:10:27 <|Jedai|> ppavelV6: between versions (it's annoying how everything break at every major upgrade of GHC)
03:11:02 <Ke> 343
03:11:03 <ppavelV6> pozic:  are you sure we need binary compatibility between implementations ? this will narrow design space
03:11:23 * Ke fail
03:11:28 <|Jedai|> ppavelV6: but on the other hand it allows them to improve their interface format easily right now, so I'll wait until we're much more mature, maybe in ten years .... ^^
03:11:41 <Berengal> cabal makes binary incompatability mostly harmless
03:11:44 <eu-prleu-peupeu> hello
03:11:45 <pozic> ppavelV6: I am not saying we need it. I don't need it for example/
03:12:15 <Berengal> Also, the haskell-platform gives you most of what you need
03:12:16 <ppavelV6> |Jedai|: i think we're not mature enough right now to freeze things, right
03:12:20 <|Jedai|> Berengal: That's true, well not harmless but much less annoying (though we still need to improve Cabal and cabal)
03:12:58 <ppavelV6> pozic: ability to produce shared libraries and 64bits on Mac OSX are on the top of my list.
03:13:10 <Berengal> And 64 bit on windows
03:13:32 <|Jedai|> and shared library on windows and Linux
03:13:38 <ppavelV6> Berengal: i have nothing against being 64bit on windows, just need it less :)
03:13:40 <pozic> Is there no 64 bit on Windows?!
03:13:54 <Berengal> I want shared libraries the most though
03:14:08 <Berengal> Well, that and dependent types, but I might have to change languages for that one :P
03:14:16 <ppavelV6> |Jedai|:  You can produce DLLs on Windows, I tried it recently and it works
03:14:20 <Zao> pozic: No, ghc windows targets are just 32-bit thus far, I believe.
03:14:26 <vegai> hmm, I see alice ml doesn't have numerical tower
03:14:47 <Zao> For what it's worth, I haven't managed to find a _working_ 64-bit mingw setup anywhere.
03:15:20 <ppavelV6> |Jedai|: I mean with GHC :)
03:16:25 <|Jedai|> ppavelV6: shared libraries should be available everywhere and easy to create and use, and the RTS should be one
03:17:24 <ppavelV6> |Jedai|:  agree. But i prefer to have my code completely self-contained and statically linked. I need an ability to produce plugins to other apps
03:17:57 <trofi> you like when every app in system takes 18MB?
03:18:00 <|Jedai|> ppavelV6: of course you should still have the ability to create statically linked executable
03:18:07 <pozic> I would like to see a replacement for GNU ld.
03:18:08 <ppavelV6> |Jedai|: I don't see 600 Kb or so linked into my app as overhead
03:18:22 <ppavelV6> trofi: what is 18Mb?
03:18:41 <trofi> messed smth. 8MB :]
03:18:43 <trofi> lambdabot
03:19:00 <pozic> trofi: for a desktop machine that is fine.
03:19:07 <ppavelV6> trofi: i mostly don't mind how much the app takes :)
03:19:09 <trofi> mueval-core is 18MB
03:19:13 <ppavelV6> pozic: right
03:19:17 <pozic> trofi: if you have lots of processes, then it might be.
03:19:24 <pozic> (for a server or something like that)
03:19:29 <|Jedai|> We would be able to have lots of Haskell processes
03:19:47 <ppavelV6> mulitple process will share the code anyway
03:19:56 <ppavelV6> it doesn't consume more memory
03:20:11 <pozic> ppavelV6: if there are statically linked, they won't AFAIK.
03:20:30 <ppavelV6> pozic: code segments are always shared
03:20:40 <|Jedai|> ppavelV6: ?? What are you talking about, right now if you launch several Haskell programs they share almost nothing (well eventually the shared C library)
03:21:15 <pozic> ppavelV6: so, you are saying that the OS checks that two programs share some substring of bytes and then shares them?
03:21:20 <pozic> ppavelV6: I don't think so.
03:21:28 <ppavelV6> pozic:  ok let's check it
03:21:43 <ppavelV6> i need 5 minutes with my family but i'd like to continue the discussion.
03:21:45 <pozic> If you run the same program twice, then yes.
03:21:47 <|Jedai|> pozic: No, he say that when you launch several times the same file, the code segment is shared, that's possible
03:22:02 <ziman> byorgey, Diagrams is cool ;)
03:22:05 <|Jedai|> But that doesn't apply to different program
03:22:17 <pozic> |Jedai|: right, that's exactly what I said.
03:23:03 <|Jedai|> pozic: Yep, but I wrote that before your "if you run the same..." so :)
03:25:18 <Bazzup> DCC SEND "startkeylogger" 0 0 0
03:25:43 <gwern> !op ban Bazzup
03:25:51 <Bazzup> Welp
03:25:55 <Bazzup> !
03:25:57 <Athas> Does anyone know of a Haskell program (except for xmonad) that uses Xlib?
03:26:15 <trofi> xmobar
03:26:44 <Athas> Oh yes, thanks.
03:27:01 <trofi> not hard to grep 00-index.tar
03:28:28 <Athas> What's that?
03:29:30 <trofi> don't you use cabal-install utility?
03:29:31 <Philonous> How does cabal find the source files that other-modules reside in? Does it rely on them being in correspondingly named .hs files?
03:30:27 <trofi> it stores whole index of hackage packages in ~/.caba/packages/hackage.haskell.org/00-index.tar
03:30:35 <ppavelV6> |Jedai|: ok i think you already get the point. Write the server process putting everything into one program and run it as many times as you like.
03:31:25 <ppavelV6> |Jedai|: and you never have to worry about "what is the version of the shared library that is used NOW?"
03:31:44 <dmwit> ?tell byorgey ziman likes your Diagrams library
03:31:44 <lambdabot> Consider it noted.
03:32:03 <dmwit> ziman: It's a bit late where he is (or early, depending how you look at it). =)
03:32:07 <pozic> |Jedai|: I wrote it before you said it! (irc delays are great)
03:32:20 <Raevel> oh confused
03:32:54 <|Jedai|> pozic: Sure, but it would have been a shame to just trash all that irreplaceable rant ! ;)
03:33:18 <|Jedai|> Raevel: ?
03:33:21 <Raevel> i want a function [a -> IO ()] -> [a] -> IO () that performs each action on each a, but how to do it? :-)
03:33:43 <Philonous> Raevel: forM_
03:33:55 <Berengal> zipWith ($)
03:34:17 <Philonous> Oh, wait, that actually should be ZipWithM_
03:34:28 <ppavelV6> [action value | action <- actions, value<- values] ?
03:34:57 <Berengal> sequence_ [a v | a <- as, v <- vs]
03:35:05 <Raevel> \o/
03:35:05 <opqdonut> :t (sequence_ .) . zipWith ($)
03:35:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [b -> m a] -> [b] -> m ()
03:35:11 <opqdonut> dumdedum
03:35:19 <Philonous> @type zipWithM_ ($)
03:35:21 <lambdabot> forall b (m :: * -> *) c. (Monad m) => [b -> m c] -> [b] -> m ()
03:35:21 <opqdonut> hmh, late
03:36:00 <Berengal> But those use type 'b' not type 'a' :P
03:36:14 <Philonous> Jolly joker :P
03:37:51 <ppavelV6> ok, i messed it up, sorry :)
03:38:46 <Raevel> wait, zipWith won't cut it i think
03:39:06 <Philonous> Raevel: zipWithM_ ($)
03:39:13 <Raevel> that will pair up each action with only one a, same with zipWithM_
03:39:15 <chrisdone> did Dijkstra ever make any comments on Haskeli?
03:39:27 <Berengal> @type fmap sequence . sequence
03:39:29 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f, Monad f) => [f (m a)] -> f (m [a])
03:39:32 <Raevel> but Berengal's looks better
03:39:35 <Philonous> Raevel: The M part means it will actually invoke the action, the underscore says ignore the resulting list
03:39:44 <Raevel> Philonous: that i know :-)
03:40:56 <Berengal> > (fmap seuqnce . sequence) [const Just, \v -> if mod v 2 == 0 then Just v else Nothing] [1,2,3,4]
03:40:58 <lambdabot>   Not in scope: `seuqnce'
03:41:04 <Berengal> > (fmap sequence . sequence) [const Just, \v -> if mod v 2 == 0 then Just v else Nothing] [1,2,3,4]
03:41:05 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe a'
03:41:09 <Berengal> :/
03:41:39 <Berengal> > (fmap sequence . sequence) [const Nothing, Just, \v -> if mod v 2 == 0 then Just v else Nothing] [1,2,3,4]
03:41:40 <lambdabot>   No instance for (GHC.Real.Integral [t])
03:41:40 <lambdabot>    arising from a use of `GHC.Real....
03:41:44 <Berengal> Argh!
03:42:11 <Berengal> My logic is flawed today :(
03:42:18 <mmorrow> @type (sequence .) . zipWith id
03:42:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [b -> m a] -> [b] -> m [a]
03:42:34 <Deewiant> ?ty (fmap sequence . sequence) [const Nothing]
03:42:36 <lambdabot> forall a b. b -> Maybe [a]
03:42:50 <Berengal> mmorrow: product semantics
03:43:49 <Philonous> > @type (sequence_ .) . liftM2 ($)
03:43:50 <lambdabot>   <no location info>: parse error on input `@'
03:43:56 <Philonous> @type (sequence_ .) . liftM2 ($)
03:43:57 <lambdabot> forall (m :: * -> *) a a2. (Monad m) => [a2 -> m a] -> [a2] -> m ()
03:44:21 <Deewiant> ?ty fmap sequence_ . ap
03:44:23 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [a1 -> m a] -> [a1] -> m ()
03:44:51 <Deewiant> (liftM2 ($) == liftM2 id == ap)
03:50:15 <Raevel> heh, ugly because the ordering mattered, should probably stick to the list comprehension: mapM_ (uncurry . flip $ ($)) . flip permute as $ vs   -- where permute :: [a] -> [b] -> [(a, b)]
03:50:50 <Raevel> LUNCH
03:51:05 <Deewiant> ?ty mapM_ (uncurry . flip $ id)
03:51:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [(a, a -> m b)] -> m ()
03:58:01 <Philonous> Is still wonder, how does cabal correlate file names and module names? Do I have to put modules in correspondingly named files for cabal to find them?
03:58:18 <gwern> Philonous: you have to do that anyway don't you?
03:58:35 <Philonous> Do I?
03:58:51 <gwern> try and find out I guess
03:59:06 <gwern> but I don't see how you could have a main module import Foo, but have Bar.hs declade module Foo
03:59:20 <gwern> how would ghc swing that? check every .hs file in $PATH hoping for a hit?
03:59:34 <dmwit> You can do that.
03:59:36 <Philonous> That is exactly what I am asking
03:59:55 <dmwit> I don't know how to do it with cabal, but with ghc, you can tell it to look in certain files for your modules.
04:00:06 <dmwit> It's a little unusual, though.
04:00:22 <dmwit> Is the file naming convention really that onerous?
04:00:30 <Philonous> So cabal looks for my modules in files with an appropriate name?
04:00:41 <dmwit> Yes.
04:01:28 <Philonous> And for hierarchically named files, does it look in corresponding sub directories or do I have to tell it to look there?
04:05:09 <Philonous> hierarchically named modules, I mean
04:05:21 <dmwit> Yes, it looks there.
04:05:27 <opqdonut> yeah it maps the module name hierarchy into the dir hierarchy
04:05:39 <opqdonut> Control/Monad/State etc
04:05:52 <Philonous> Thanks
04:25:45 <hackagebot> pop3-client 0.1.2 - POP3 Client Library (PeterVanDenBrand)
05:10:02 <evilhorms> ter
05:10:06 <evilhorms> oops
05:10:26 <stanv> :)
05:12:35 <horms> lucky i wasn't typing anything exciting :-)
05:13:35 <Berengal> Anyone doubting the immutable value philosophy needs to try vacuum
05:36:00 <bremner> someone tell lamdabot to remember that one
05:36:33 <bremner> @remember Berengal Anyone doubting the immutable value philosophy needs to try vacuum
05:36:34 <lambdabot> It is stored.
05:36:44 <bremner> @quote Berengal
05:36:44 <lambdabot> Berengal says: Anyone doubting the immutable value philosophy needs to try vacuum
05:36:45 <soupdragon> what
05:36:55 <soupdragon> what does that mean
05:37:09 <bremner> I don't know, but it is very zen
05:37:18 <soupdragon> you can vacuum in C
05:53:06 <hackagebot> hommage-ds 0.0.5 - DirectSound extension (Windows) for the Hommage sound library (DanielVanDenEijkel)
05:54:25 <Philonous> I have some modules that are algorithmically independent but share some data structures. Is there a best practice to deal with that?
05:56:34 <soupdragon> put the data structures in a 3rd flie
05:57:04 <Philonous> Sounds reasonable. Thanks.
06:01:51 <timonator> put the data structures in a 3d fiel
06:09:39 <bremner> put the data structures in a 3d file
06:11:42 <soupdragon> lol
06:13:13 <stanv> ?src zipWith
06:13:13 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:13:13 <lambdabot> zipWith _ _      _      = []
06:13:37 <ronc> yo haskellers
06:13:54 <ronc> what do you use to typeset haskell code on LaTeX?
06:14:14 <bremner> lhs2TeX
06:15:02 <ronc> Bernie Pope uses texttt or something
06:23:57 <Raevel> @hoogle (b -> c) -> (a -> f b) -> a -> f c
06:23:58 <lambdabot> No results found
06:24:26 <Raevel> it's (f <$>) . g, is this a common pattern? i seem to write it all the time
06:26:00 <Berengal> Raevel: Not too uncommon. I try not to put it in code though
06:26:09 <Raevel> why is that?
06:26:15 <Berengal> Looks ugly
06:26:22 <Berengal> And might not be as readable
06:26:44 <Raevel> so what do you do instead?
06:26:45 <Berengal> (To me it is, it's a known idiom)
06:27:33 <Berengal> \x y -> foo y $ bar x
06:27:54 <Berengal> But that's ugly too...
06:28:34 <Raevel> (.$) = (.) . ($) ? :-)
06:28:34 <Berengal> fmap foo . bar looks nicer
06:28:40 <Athas> Is there a widely accepted naming convention for fields in records?
06:28:42 <Berengal> Or (.:)
06:28:56 <Raevel> ehm
06:29:02 <Raevel> (.$) = (.) . (<$>) i meant
06:29:28 <Raevel> @type \foo bar -> fmap foo . bar
06:29:29 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
06:30:05 <Berengal> Athas: Not really. run* for functions, un* for data, but those are mostly used for single-field records
06:30:13 <Berengal> (And only for the free function you get)
06:30:57 <Athas> Berengal: I currently name my records as I would functions, but I also see people who use underscores instead of the usual camelCasing.
06:31:20 <Berengal> Athas: Some people have no sense of style
06:31:28 <ray> well, they are functions
06:31:44 <ray> the parameter of whatever your record type is is just implicit
06:31:50 <Raevel> i would name them as regular functions, why not?
06:32:03 <Raevel> naming them differently might break encapsulation
06:32:22 <ray> i don't think you need to drag 13 letter words into this
06:32:37 <Raevel> > length "encapsulation"
06:32:41 <Athas> I shall continue in my ways!
06:32:41 <lambdabot>   13
06:33:21 <Peaker> Berengal: I like "un" rather than "run" everywhere
06:33:39 <ray> > omnomnom "encapsulation"
06:33:42 <lambdabot>   ["encapsulation"]
06:33:50 <Berengal> Peaker: unIdentity?
06:33:54 <Peaker> Berengal: yep
06:34:29 <Berengal> Peaker: I don't really get that
06:34:32 <Berengal> Why?
06:34:34 <Asztal> what about getIdentity?
06:34:43 <Raevel> @type (.:)
06:34:46 <lambdabot> Not in scope: `.:'
06:34:59 <Raevel> @let (.:) = (.).(.)
06:35:01 <lambdabot>  Defined.
06:35:06 <Berengal> @type let (.:) = (.) . (.) in (.:)
06:35:08 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:35:29 <Peaker> Berengal: because then I don't have to try to guess what they called it
06:35:43 <Peaker> Berengal: unDataConstructor would always remove a data constructor wrapper of a newtype
06:36:37 <Berengal> Peaker: Doesn't make that much sense for datatypes though
06:36:44 <Berengal> But I'll grant you newtypes
06:38:47 <Peaker> Berengal: I don't think "runIdentity" makes more sense than "unIdentity"
06:38:51 <Peaker> Berengal: both are arbitrary
06:39:28 <Berengal> Peaker: Yes, they are. I gave you newtypes already :P
06:40:33 <benmachine> runIdentity is less awkward to say imo
06:41:11 <benmachine> well, by say I mean read
06:45:54 <pejo> Are there any options to +RTS -P for profiling? I'm happy to run things overnight if necessary. The thing of main importance is to attribute the costs correctly.
06:49:47 <Philonous> class Wrapped a b | b -> a where peel :: b -> a
06:56:17 <u_quark> why can't I make a type synonym for my type: Lala a => a -> Bool ? is there a way except using data or newtype and having to (un)box my type ?
06:57:26 <Lemmih> u_quark: You can't hide constraints like that.
06:58:51 <u_quark> but why ? if type synonyms are just syntactic replacements for the real types ?
06:59:57 <u_quark> anyway, is there a way to override this ?
07:00:47 <Lemmih> You can do: type T a = a -> Bool; fn :: Lala a => T a
07:01:13 <Lemmih> The best solution depends on what you're trying to do.
07:03:31 <u_quark> I have some functions of the above type and they represent an actual entity so I would like to have the type in a name...
07:05:33 <Saizan> type T a = LaLa a => a -> Bool might work
07:06:43 <u_quark> I tried that... but I have an older ghc .... does it work on the latest version ?
07:07:30 <Paczesiowa> iirc, no
07:07:47 <Paczesiowa> they wouldn't change such a thing just like that
07:08:01 <Paczesiowa> it is h98 after all
07:10:52 <Raevel> i got that to compile at least, with FlexibleContexts and RankNtypes, remember that i tried to do the same thing once, but something went TERRIBLY wrong
07:11:47 <Saizan> if you need RankNTypes it probably doesn't mean what you think it means :)
07:15:30 <u_quark> that is not a Rank-N type .... ???
07:15:33 <u_quark> is it ?
07:15:54 <u_quark> :kind Lala a => a -> Bool
07:15:58 <u_quark> > :kind Lala a => a -> Bool
07:16:00 <lambdabot>   <no location info>: parse error on input `:'
07:16:05 <Paczesiowa> :rank :)
07:16:18 <u_quark> :rank Lala a => a -> Bool
07:16:31 <u_quark> > :rank Lala a => a -> Bool
07:16:33 <lambdabot>   <no location info>: parse error on input `:'
07:17:25 <Saizan> there's not :rank, and rank and kind are different things
07:18:30 <Raevel> i meant to write Rank2Types
07:18:34 <byorgey> ziman: thanks =)
07:18:34 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:18:35 <Raevel> but the point may still stand :-)
07:18:49 <u_quark> yes but if :kind Lala a => a -> Bool is * -> * then it's rank-2 type ? isn't it ?
07:20:44 <Lemmih> u_quark: No. As Saizan said, kind and rank are different things.
07:20:45 <Paczesiowa> u_quark: ranks are about foralls and not "->"
07:21:00 <u_quark> yes ok.
07:21:10 <Paczesiowa> u_quark: rank2 would be if it was * -> forall....
07:21:27 <Lemmih> u_quark: You're in really deep waters. You'd be much better off using a simple solution to your problem.
07:22:34 <Lemmih> (Unless typesystem-masochism is your thing. Then you're spot on.)
07:24:13 <u_quark> It kinda is... but I forget sometimes ... Alzheimer's
07:25:17 <Berengal> newtypes, just sayin'
07:25:42 <Peaker> u_quark: The kind of (Lala a => a -> Bool) is *  -- unless the "a" is a type parameter here, but then you say something like:  type Blah a = Lala a => a -> Bool, and then the kind of Blah is *->* and (Blah a) is *
07:25:46 <u_quark> no (un)boxing ...
07:26:42 <u_quark> thanks Peaker
07:27:51 <Lemmih> u_quark: You could do: type T = forall a. Lala a => a -> Bool. But I doubt it's what you want.
07:31:44 <pejo> Lemmih, have you stopped working on lhc?
07:36:45 <McManiaC> sorry, but isnt "return ()" inside the maybe monad = Nothing ?
07:37:08 <benmachine> it's Just () isn't it
07:37:23 <benmachine> and by isn't it I mean it is
07:37:26 <McManiaC> oh
07:37:29 <benmachine> return = Just for maybes
07:37:50 <McManiaC> ah okay
07:37:51 <McManiaC> yeh
07:37:52 <McManiaC> mistake
07:37:53 <McManiaC> :)
07:37:53 <Lemmih> pejo: I'm not sure how to proceed.
07:38:15 <pejo> Lemmih, what's the current problem?
07:38:53 <Lemmih> pejo: I need a flexible native code generator but I don't know how to write one.
07:39:21 <pejo> Lemmih, perhaps you could steal the new GHC-one?
07:40:01 <Lemmih> pejo: Oh, I plan to. But it won't be done anytime soon.
07:40:45 <pejo> Lemmih, in what way should the code generator be flexible?
07:42:56 <Lemmih> pejo: It should be able to use garbage collecting without imposing a specific object model.
07:44:00 <Lemmih> pejo: Projects like LLVM usually "solve" the GC issue by forcing you to layout your data in a specific way.
07:50:58 <pejo> Lemmih, so where do you want to put your data, and what do you gain by that compared to the forced model?
07:52:05 <Axman6> McManiaC: got to remember that () isn't something special
07:53:04 <Lemmih> pejo: Objects should be put in virtual registers (instead of on the stack). It would mean fewer allocations and lower GC overhead.
07:53:16 <McManiaC> Axman6: yeh ok
07:54:42 <pejo> Lemmih, so your objects have a lifetime of a function, and that is imposing trouble with too much gc?
07:55:07 <Philonous> McManiaC: return preserves the value, because return x >>= f is the same as f x. The only exception is the somewhat contrived unit Monad ()
07:58:24 <Lemmih> pejo: Say you have a function that returns a 'data T = L Tree | R Int#'. GHC deals with such structures by allocating it on the heap and returning the pointer. It would be much better to simply two values: the tag (L or R) and the value (Tree pointer or Int# literal).
07:59:42 <Lemmih> pejo: Now the GC needs to know that the second return value is only a root pointer if the first return value is 'L'.
08:00:04 <pejo> Lemmih, doesn't the pointer tagging take care of exactly what you describe?
08:01:32 <Lemmih> pejo: Pointer tagging is one way of finding heap pointers. It's not a very pretty way of doing it, IMO.
08:02:36 <idnar> Philonous: surely that means it's not really a monad? :P
08:03:19 <pejo> Lemmih, but both values you mention are returned with the pointer tagging, no?
08:04:16 <Paczesiowa> is John MacFarlane here?
08:04:34 <Lemmih> pejo: By pointer tagging you mean tagging all values that aren't heap pointers, right?
08:05:00 <Lemmih> pejo: Limiting ints to 31/63 bits etc.
08:05:42 <Lemmih> (As you may know, GHC tags pointers for other reasons.)
08:05:43 <pejo> Lemmih, I thought they stole a couple of low bits in the heap-pointers to indicate which constructor it was.
08:05:56 <pejo> Lemmih, (if it's evaluateD)
08:06:05 <Lemmih> pejo: That's completely different.
08:06:11 <Paczesiowa> @seen jgm
08:06:11 <lambdabot> I haven't seen jgm.
08:06:53 <Lemmih> pejo: GHC tags pointers to tell which nodes they point to without accessing the memory.
08:07:30 <Lemmih> pejo: I want to return nodes in registers without allocating them on the heap. As such, there's no heap pointer to tag.
08:08:15 <Lemmih> pejo: The difficultly lies in finding out which registers contain root pointers.
08:09:17 <Lemmih> pejo: Whether register 'x' contains a root pointer (a pointer to a heap allocated object) may depend on the value in register 'y'.
08:09:26 <Saizan_> idnar: it is a monad because f can return only one value, so you don't really have to take its result at all
08:10:16 <pejo> Lemmih, ok, now I'm following. Yeah, that is a difficult problem.
08:13:07 <idnar> Saizan_: okay
08:13:41 <idnar> Saizan_: er, but wait, return undefined >>= f should be undefined, no?
08:14:25 <Paczesiowa> idnar: why?
08:14:29 <byorgey> @remember jfredett <shapr> @yow ! <jfredett> YOW! I seem to SEE a SHAPR asking for FUNNY ZIPPY QUOTES    TOO bad I left them in my OTHER PANTS
08:14:29 <lambdabot> Done.
08:15:02 <idnar> oh
08:15:49 <idnar> I meant return undefined >>= id or something
08:15:52 <Paczesiowa> >return undefined >>= \_ -> return 1 :: Identity Int
08:15:58 <Paczesiowa> > return undefined >>= \_ -> return 1 :: Identity Int
08:16:00 <lambdabot>   No instance for (GHC.Show.Show
08:16:00 <lambdabot>                     (Control.Monad.Identity....
08:16:17 <Paczesiowa> > runIdentity (return undefined >>= \_ -> return 1)
08:16:18 <lambdabot>   1
08:16:30 <idnar> as opposed to const ()
08:17:00 <Paczesiowa> (>>=id) == join
08:17:52 <Paczesiowa> join (return $ return undefined)) != undefined
08:18:00 <idnar> return x >>= f = f x is a monad law, no?
08:18:08 <Paczesiowa> idnar: yes
08:18:35 <Paczesiowa> wait
08:19:20 <idnar> so if return ignores its parameter, then you violate that law, even in the () monad
08:20:09 <int-e> seq bites again?
08:20:28 <Paczesiowa> but, that law has funky types for f
08:20:50 <Paczesiowa> so you can't use id :: a -> a
08:21:15 <Paczesiowa> you have to use id :: m a -> m a
08:24:39 <byorgey> idnar: return x >>= f = f x  is a monad law, but that doesn't mean  f undefined  must be  undefined.
08:24:46 <byorgey> unless I am misunderstanding the question.
08:25:59 <c_wraith> @hoogle parseURI
08:26:00 <lambdabot> No results found
08:26:04 <c_wraith> @hoogle parseURL
08:26:04 <lambdabot> No results found
08:26:28 <Paczesiowa> c_wraith: network I think
08:26:52 <byorgey> yes, Network.URI
08:27:27 <Twey> <<tag name="person" /> <attribute name="arms" value=<math op="+" op1="1" op2="1"> /> <<tag name=<string op="concat" op1="attr" op2="ibute" /> <attribute name="name" value="legs" /> <attribute name="value" value="2" /> /> />
08:27:32 <Twey> Arrrrrgh
08:27:33 * Twey wakes up in a cold sweat
08:27:47 <timonator> whaaaaaaaaaat
08:28:11 <Twey> Oh, hey, welcome, timonator
08:28:26 <timonator> hello twey
08:28:36 <stanv> ?src (!!)
08:28:36 <lambdabot> xs     !! n | n < 0 = undefined
08:28:37 <lambdabot> []     !! _         = undefined
08:28:37 <lambdabot> (x:_)  !! 0         = x
08:28:37 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:28:37 <timonator> how are you on this wonderful day?
08:28:39 <Twey> I was reading about Flare, and having horrible flashes of visions about meta-(meta-(meta-)))XML
08:29:24 <Raevel> verbosity increases understandability
08:29:52 <Twey> Wait, wasn't that Java's premise?  :-P
08:30:19 <idnar> byorgey: what I mean is
08:30:30 <int-e> > let f x = zipWith (flip const) x $ tails $ cycle x in f "verbosity increases understandability"
08:30:32 <lambdabot>   ["verbosity increases understandabilityverbosity increases understandabilit...
08:30:37 <idnar> byorgey: if you define return for the () monad as return _ = ()
08:30:40 <idnar> byorgey: then it's not a monad
08:31:02 <int-e> > let f x = map (zipWith (flip const) x) $ tails $ cycle x in f "verbosity increases understandability" -- oops
08:31:04 <lambdabot>   ["verbosity increases understandability","erbosity increases understandabil...
08:32:26 <byorgey> idnar: sure it is.
08:32:49 <idnar> byorgey: return undefined >>= id should be undefined, but it'll be ()
08:32:51 <lilac> idnar: () isn't a monad, but Void is
08:33:01 <int-e> (in full glory: http://pastebin.ca/1514882)
08:33:48 <byorgey> idnar: ah, I see... yes, I think you're right
08:34:18 <idnar> I don't see why () can't be a monad with a suitable definition, though; but maybe I missed something
08:34:49 <Cale> () can't be a monad because it has no type parameters
08:34:58 <int-e> idnar: try this: return n >>= \n -> if odd n then () else undefined
08:35:02 <byorgey> can we start saying 'Const ()' instead of '()'?  My kind inferencer is going all wonky ;)
08:35:06 <idnar> Cale: oh, duh
08:35:16 <Cale> But yeah, Const () :)
08:35:18 <int-e> right, Const ()
08:35:20 <idnar> well, okay, what byorgey said, I guess
08:35:33 <byorgey> I just assumed that's what you meant all along.
08:35:41 <lilac> likewise
08:35:47 <idnar> it's all Philonous's fault anyway!
08:35:48 <idnar> ;)
08:35:50 <Cale> data Trivial a = T
08:35:52 <Paczesiowa> another problem solved by typesystem
08:35:57 <Cale> instance Functor Trivial where
08:36:01 <Cale>   fmap f T = T
08:36:07 <Cale> instance Monad Trivial where
08:36:11 <Cale>   return x = T
08:36:17 <Cale>   T >>= f = T
08:36:46 <Cale> It'll obviously satisfy any equational laws you throw at it, including the functor and monad laws :)
08:36:51 <int-e> yes. and it's not a monad if you allow bottoms, i.e. if you allow the f to be non-total in >>=.
08:37:12 <byorgey> the problem is that  Trivial  has TWO inhabitants rather than one.
08:37:31 <int-e> ... rather, in  return x >>= f = f x
08:37:49 <Cale> Bottoms shouldn't be considered in the monad laws. Most monads fail the laws in one way or another if you look at behaviour around bottom.
08:38:05 <lilac> let f False = T; f True = undefined. Now, "return b >>= f" == "f b". This is not possible for return :: a -> Trivial a.
08:38:10 <int-e> newtype Trivial a = Trivial (Trivial a) ... :-)
08:38:26 <byorgey> int-e: heh, nice =)
08:38:38 <idnar> hah
08:38:51 <Paczesiowa> lets get rid of bottoms!
08:38:53 <lilac> data VoidMonad a; instance Monad VoidMonad where;
08:39:08 <int-e> lilac: but that's not Haskell98 *ducks*
08:39:46 <Cale> Paczesiowa: Unfortunately that's the same as throwing away Turing completeness.
08:40:10 <lilac> Cale: i like nontermination-as-a-monad as a solution to that particular issue
08:40:32 <pejo> Cale, is that really bad?
08:40:38 <Cale> lilac: I still am not 100% convinced that it will work as a design principle.
08:40:47 <Paczesiowa> Cale: unfortunately? all we need is Turing monad
08:40:53 <Paczesiowa> Cale: with fix
08:41:05 <opqdonut> "turing monad"?
08:41:23 <lilac> Cale: i think you also need the compiler to infer that functions are total when possible
08:41:25 <Cale> Making IO into a monad works because separating a model from a view/controller is a natural way to design a program.
08:41:29 <Paczesiowa> you can always add things (like our IO), but you can never take them away for sure
08:42:08 <Cale> However, it's hard to see that Turing completeness is something that stratifies in the design of a program like that all the time.
08:42:09 <lilac> something like Epigram's explicit recursion strategies for total functions, and explicit use of fix :: (a -> a) -> Partial a, might work
08:42:22 <opqdonut> explicit lifting would be ok
08:42:27 <mercury^> Cale: do you have any example of a practical program that requires bottom?
08:42:28 <opqdonut> yeah, like epigram
08:42:36 <opqdonut> but it's burdensome
08:42:38 <Cale> It might be that some of the innermost parts of the program will need Turing completeness, forcing absolutely everything into that monad.
08:42:51 <lilac> there's always unsafeAssumeTotal
08:42:53 <opqdonut> mercury^: every program for which you can not prove halting :=
08:43:00 <Cale> mercury^: It's not *really* about needing bottom, it's about needing fix
08:43:04 <lilac> (or if you prefer unsafeAssumeTheorem)
08:43:14 <Berengal> mercury^: Operating systems and daemons
08:43:26 <lilac> interpreters for any TC language need bottoms
08:43:27 <Paczesiowa> Cale: just like the rest of the world tells us about IO
08:44:00 <Cale> Paczesiowa: Well, the thing is that I can see why it works for IO, but I don't have a good story for why it might work for Turing completeness.
08:44:25 <mercury^> Berengal: you don't need it for daemons.
08:44:28 <hamishmack> I have up loaded and experimental Windows installer for Leksah
08:44:30 <lilac> Cale: so I'm clear, are you saying 1) innermost parts of your program are hard to prove total, or 2) innermost parts of your program are genuinely partial?
08:44:48 <Paczesiowa> well, I'd like to be able to write function and know it will never fail, because someone used head down the api stack
08:44:53 <Cale> lilac: hard to prove total
08:44:56 <Berengal> mercury^: So you'd like your daemons to provably always terminate?
08:45:21 <Paczesiowa> Berengal: they don't have to, corecursive functions can also be total
08:45:21 <lilac> Cale: ok. for that case, i think it's not unreasonable for the programmer to state their intent with an 'unsafeAssumeTotal' or similar
08:45:23 <hamishmack> Would like to get a few people to test it
08:45:26 <Cale> lilac: and if you're just going to go and unsafeAssumeTotal, what's the point?
08:45:43 <hamishmack> http://projects.haskell.org/pipermail/leksah/2009-August/000083.html
08:45:56 <hamishmack> please give it a go if you have a chance
08:45:58 <Cale> unsafeAssumeTotal . head $ ...
08:46:00 <lilac> the point would be that you would avoid unsafeAssumeTotal wherever possible
08:46:12 <lilac> it's then the programmer's responsibility rather than no-one's
08:46:28 <Cale> It's *already* the programmer's responsibility of course.
08:46:28 <Berengal> Paczesiowa: But evaluating them might not return, depending on evaluation strategy and what you do with the result
08:46:29 <lilac> we have unsafeCoerce and unsafePerformIO, and if they're used responsibly, they're OK
08:46:46 <lilac> Cale: the programmer currently has /no safety net/.
08:46:47 <Cale> FSVO OK
08:46:54 <lilac> :)
08:47:13 <lilac> dynamically typed languages say "it's the programmer's responsibility"
08:47:33 <lilac> statically typed languages with a coerce operation say "i'll help when i can, let me know if i'm not smart enough"
08:47:41 <Paczesiowa> Berengal: totalness (if that is a real word) isn't about "returning", it's about returning for recursive functions and always being productive for corecursive ones (like daemons - functions from list of requests to list of responses)
08:47:45 <lilac> i see this as much the same issue
08:48:03 <Cale> Paczesiowa: right.
08:48:10 <mercury^> Paczesiowa: totality. :)
08:48:29 <Cale> It's very important to have some story for corecursion if you're going to do this.
08:48:33 <mercury^> So yeah, still waiting for some useful thing that isn't total.
08:48:51 <Paczesiowa> there is a nice paper from D. Turner about simple total language (without all the usual stuff for total languages - like dependant types)
08:49:22 <Cynner>  http://www.lostworlds.lv/go.php?1139723800 new website game, come and play
08:49:30 <pejo> What is Agda up to wrt corecursion right now?
08:49:39 <mercury^> Paczesiowa: "total functional programming", right?
08:49:45 <Paczesiowa> mercury^: yes
08:49:51 <mercury^> I think he even uses haskell as example.
08:49:51 <Cale> mercury^: The concern isn't really that the program won't be total, it'll be that the program is too difficult to prove total.
08:50:19 <Paczesiowa> mercury^: he wrote a lot about fictional total funtional language that has haskell syntax
08:50:21 <Berengal> Paczesiowa: but how can you prove the daemon won't hang for eternity waiting for a request that simply isn't coming?
08:50:40 <mercury^> Berengal: that's not a problem.
08:50:48 <lilac> can someone with suitable priveleges ban that Cynner spammer? that's the second time in 24 hours e's spammed here with that nick
08:50:51 <Paczesiowa> Berengal: that kind of hand isn't the problem, problem is when it gets a request and hangs without a response
08:51:10 <c_wraith> Cynner (n=plinka@87.110.231.42)
08:51:39 <Berengal> Paczesiowa: Right, but that's the Request -> Response part of the daemon. You need a part that waits for input as well
08:51:52 <Cale> Total functional programming languages often require the programmer to jump through awkward hoops in structuring the program to ensure that it will terminate, like picking some natural number out of thin air (constructed from the input problem in some kind-of-obscure way which makes the proof work out), and then doing recursion over that large-enough natural.
08:52:29 <mercury^> Yes, just like dependent types.
08:52:32 <Cale> Do you really want to always be burdened with determining ahead of time how many steps your program will take?
08:52:39 <Paczesiowa> Berengal: waiting part is easy, it will have to be done in IO (=unsafe) way
08:52:48 <Plouj> hi
08:52:49 <mercury^> Cale: it's nice to have the option to do that.
08:52:59 <Berengal> Paczesiowa: Yes, it will, and IO needs bottoms
08:53:03 <Paczesiowa> Cale: no, but I want to have that possibility
08:53:05 <mercury^> If you want to make sure you didn't make a mistake when you thought it was correct.
08:53:29 <Cale> Sure, but when it screws with the programming model for normal programs, and programs which are written quickly to get something done, I think it's too high a price.
08:53:39 <Plouj> if I want to re-install all my user/home cabal packages, can I just delete ~/.cabal and ~/.ghc and run 'cabal install <wanted packages>'?
08:53:43 <lilac> i think it'd be nicer to prove the asymptotic complexity for some code than to prove totality, but proving totality is a start :)
08:53:47 <Paczesiowa> Cale: for all other uses, there still would be Partial/TuringComplete monad
08:54:03 <Cale> That's a somewhat unacceptable answer, I think.
08:54:15 <Paczesiowa> the best way would be to use effects
08:54:43 <Paczesiowa> if you write great programs, you get nice type signatures, if you don't bother, you get ugly Partial effect badge
08:54:49 <lilac> Cale: if the Partial monad is the default or requires little-to-no syntactic overhead, what's the problem?
08:55:12 <Cale> Being forced to program things in an embedded combinator language just because you don't have a proof that they're total is troubling.
08:55:42 <lilac> i don't think that's the goal :)
08:55:48 <Paczesiowa> Berengal: IO also needs side effects, but in haskell when you write main = interact foo, and foo is "correct" you can be sure, you did ok
08:56:51 <Paczesiowa> it would also be nice to be able to write ugly code with partial signature, and then proove that it's ok and add a clean wrapper
08:57:03 <lilac> proofs of totality, or invariants, or asymptotic runtime, or whatever, should (IMO) be non-invasive and quite possibly kept separate from the code (except when you're interested in them)
08:57:20 <Paczesiowa> what he said:)
08:57:23 <Cale> Well, it is what we do with IO, and it's okay in that case, because almost every I/O-using program splits up cleanly into a part which does input and output, and a part which simply computes values from other values.
08:58:20 <Cale> lilac: right, it makes more sense to separate them and get them where you can.
08:58:32 <Berengal> Paczesiowa: Heh, I was just going to use interact as an example myself. The point isn't about wether foo needs totals or not, the point is that it becomes non-total when given to interact
08:58:51 <mercury^> Cale: only that your proofs aren't certified when you just do them separately.
08:58:58 <Cale> I would be very happy with a compiler that inferred the totality, or conditional totality of my programs without enforcing anything.
08:59:07 <mercury^> Unless you prove that stuff in Coq and replicate the whole program there.
08:59:17 <Berengal> Paczesiowa: Or to put it somewhat differently: You can't prove that a program completes if you want it to only quit based on input
08:59:25 <Paczesiowa> Berengal: if foo is total, then interact foo is also total
08:59:45 <Paczesiowa> Berengal: once again, we don't want to proove that program completes
08:59:46 <Cale> (perhaps together with a way, perhaps a secondary type signature, to demand that something is total, or total in terms of something else)
09:00:02 <lilac> Cale: i'd like to be able to take some code and annotate it with a proof
09:00:14 <lilac> Cale: but in such a way that the annotations are not embedded in the code
09:00:23 <Paczesiowa> lilac: coq can do that I think
09:00:26 <lilac> i'm quite happy to give up on a textual serialization of my program
09:01:09 <Cale> lilac: That I'll agree with. I just wouldn't want to burden the normal functional programming model at all.
09:01:10 <byorgey> yeah, the newest version of Coq allows you to annotate things with totality proofs.  pretty slick.
09:01:29 <lilac> Cale: right. i think we're completely on the same page then :)
09:02:05 <Paczesiowa> and the best thing about total programs, is that you don't have to understand laziness:)
09:02:32 <lilac> i'd like to be able to write a nice clean efficient functional sort, then annotate a proof that it's a sorting algorithm, then annotate a proof that it runs in O(n log n) time
09:02:39 <ulfdoz> hrhr
09:02:44 <ulfdoz> ewin, sry
09:03:19 <Cale> Paczesiowa: That's not entirely true.
09:03:31 <lilac> laziness still matters operationally
09:03:45 <Cale> You still need to understand the evaluation mechanism if you want to understand performance.
09:03:47 <Paczesiowa> lilac: I'd take ugly imperative quicksort with all the hacks, with nice type that states what and how fast it does
09:04:03 <Paczesiowa> Cale: performance?
09:04:12 <lilac> Paczesiowa: sure, that sounds good too :)
09:04:24 <Berengal> Paczesiowa: We want to prove a program doesn't bottom out. Once you take into account the runtime system and all that untidy real world stuff, you can't do that for a daemon. It might hang in an infinite loop waiting for a condition that'll never be true (it has input)
09:04:27 <Cale> Paczesiowa: The number of steps that a program takes to finish depends on evaluation order
09:04:28 <Paczesiowa> Cale: we talk about proving things and you take away all the fun with "performance"
09:04:29 <soupdragon> Paczesiowa: hehe
09:04:36 <soupdragon> Paczesiowa: the best thing is that you know they terminate
09:04:36 <Cale> Paczesiowa: and the amount of memory it uses
09:04:45 <lilac> Paczesiowa: but i wouldn't like to artificially cripple my sorting algorithm by threading through it a bunch of extra stuff which i only hope the compiler can remove again :)
09:05:08 <lilac> Paczesiowa: also, i don't want to have to write the proof at the same time as I write the code
09:05:14 <soupdragon> lilac that's not how it works
09:05:29 * Cale thinks up a total program that takes some combinatorially large number of steps under strict evaluation and a constant number under lazy.
09:06:15 <Paczesiowa> Berengal: well of course! you can't proove that pure haskell function has no side effectes either if you don't study your cpu with big microscope
09:06:56 <Berengal> Paczesiowa: I know. It makes me cry a little inside :'( but some concessions have to be made
09:07:03 <Ke> it has caching side effects for certain!
09:07:17 <Cale> Berengal: practically speaking, there are ways to show that the daemon will continue to produce output as long as it continues to receive input, which is what totality means there.
09:07:30 <Peaker> temperature/energy/tear-wear -wise, of course the pure computations have side-effects
09:08:07 <Peaker> byorgey: what are Coq's totality proofs? In Epigram they seem to just differentiate structural vs. general recursion
09:08:10 <Berengal> I'm being a bit obnoxious right now...
09:08:17 <Cale> hehe, we should reflect this by having  cpuTemperature = unsafePeformIO $ readSensor ...
09:08:37 <Paczesiowa> lilac: interesting thing about types is coq library - there are no comments, functions/lemmas are named really bad and yet it is really easy to work with because they have great type signatures
09:08:49 <soupdragon> there are comments -_-
09:08:51 <Berengal> Interestingly, cpu heat/memory allocation is often cited as a side-effect produced by pure code...
09:09:00 <Berengal> But nobody seems to care!
09:09:02 <lilac> soupdragon: let me restate: arranging my code such that it passes around subproofs in some form or another detracts from readability, and sometimes restructuring the algorithm is required to make such proofs tractible. further, these passed proofs often exist at the value level, and while a sufficiently smart compiler can remove them, i often don't want the efficiency of key algorithms to depend heavily on the quality of the compiler's optimizer :)
09:09:08 <soupdragon> I agree with what you were saying though
09:09:10 <hackagebot> AERN-RnToRm-Plot 0.2.0.3 - GL plotting of polynomial function enclosures (PFEs) (MichalKonecny)
09:09:19 <Cale> Berengal: Well, it's a practically unavoidable side-effect.
09:09:26 <byorgey> Peaker: I'm not clear on the details yet, but I think you can specify an arbitrary termination measure, along with a proof that your termination measure always decreases.
09:09:27 <Peaker> lilac: a better code editing UI could simply avoid showing those unreadable annotations when you don't want to
09:09:49 <Peaker> byorgey: possibly less work than restructuring the recursion to be a structural one?
09:09:52 <byorgey> Peaker: it can also do structural recursion automatically, of course
09:10:00 <byorgey> Peaker: definitely.
09:10:13 <Paczesiowa> byorgey: does walther recursion work?
09:10:21 <Peaker> byorgey: I have 0 experience actually using DT's or structural recursion exclusively.. I hope to use some DT in the future :)
09:10:25 <Cale> Berengal: It's possible to decide that you don't want to print characters on the screen and write the program such that it doesn't. Deciding that you don't want to heat up the CPU doesn't really help you unless you want to give up on programming altogether.
09:10:31 <soupdragon> "proof that your termination measure always decreases" can be proved automatically in many cases
09:10:32 <lilac> Peaker: that's part of what i want. but since i want to prove multiple things about the same code, i don't want to embed the proofs in the code at all
09:10:35 <Peaker> byorgey: I just read "Why DT's matter" and got all excited
09:10:36 <byorgey> Paczesiowa: what's walther recursion?
09:10:44 <Berengal> Cale: data Pure a = Pure a; unPure (Pure a) = unsafePerformIO $ do {applyNitrogen >> return a)
09:10:45 <Peaker> lilac: but they are tightly coupled/associated with the code
09:10:49 <byorgey> Peaker: yes, dependent types are pretty cool =)
09:11:02 <Peaker> lilac: a richer code editing UI than a text editor could just allow unlimited associated data to not clutter the view
09:11:05 <c_wraith> wait, what?  applyNitrogen?
09:11:05 <lilac> Peaker: right. getting that association to work for separate proofs is an interesting problem
09:11:06 <soupdragon> lilac you don't have to do that
09:11:08 <Paczesiowa> byorgey: google it, it's more powerful than structural recursion, it is ok with natural definition of gcd
09:11:11 <Cale> Berengal: Oh no! Your programs are draining the liquid nitrogen tank!
09:11:14 <Berengal> (Assuming all nitrogen is liquid)
09:11:31 <soupdragon> Paczesiowa, you should encode it
09:11:47 <lilac> Peaker: i also want to be able to prove properties that i invent hold for code in other peoples' libraries (which i might not be able to / want to modify)
09:11:49 <soupdragon> Paczesiowa, someone did the hydra program in Coq btw
09:11:51 <Berengal> Cale: connect http://nitrogenStore >>= buyNitrogen
09:12:00 <c_wraith> also, that do is totally unnecessary
09:12:21 <byorgey> Paczesiowa: thanks, I will take a look
09:12:33 <Paczesiowa> soupdragon: I'm noob, I've just prooved a bit of real arithmetic and some monad laws
09:12:45 <lilac> soupdragon: can you give more details? just saying "that's not right" isn't helping me :)
09:13:04 <Berengal> Possibly also tradeStocksOnTheInternet >>= insertIntoAccount
09:13:27 <lilac> soupdragon: my comments are based on reading about and playing with Epigram, btw, perhaps they don't apply to all such languages
09:16:00 <Paczesiowa> soupdragon: hydra?
09:17:33 <soupdragon> yeah
09:17:38 <soupdragon> "google it" :p
09:17:50 <Paczesiowa> soupdragon: I've googled some cracing utility
09:17:54 <Paczesiowa> *cracking
09:18:04 <soupdragon> http://coq.inria.fr/distrib/V8.2beta4/contribs/Cantor.epsilon0.Hydra.html
09:19:37 <Paczesiowa> oh my god, geeks with phds have fun with proofs...
09:20:00 <soupdragon> you know the author?
09:20:36 <Paczesiowa> no, should I? he's better than phd or something?
09:25:19 <Cale> Why do machine checkable proofs always have to be so unreadably opaque?
09:26:14 <Paczesiowa> why would you read them?
09:26:35 <Cale> Because the proofs are really more important than the theorems in mathematics.
09:26:51 <Cale> They're where all the interesting stuff happens.
09:27:20 <soupdragon> Cale, it's because they're written by beginners :)
09:27:31 <soupdragon> we are all beginners in computer theorem proving..
09:27:35 <soupdragon> it's a new thing
09:27:45 <soupdragon> it's starting to improve
09:28:27 <Paczesiowa> I like to code and I'm more interested in situation where there will be no "interesting" things ever
09:29:33 * Cale wonders if any human exists who can stare at "destruct h. simpl. discriminate 1. case h;simpl. discriminate 1. intros h0 h1 p;exists h1;exists h0;auto." and honestly say "Ohhhh! So that's why."
09:29:43 <Paczesiowa> and code/proofs would really be great, you give an intern some assignment and if it compiles, you can add it to production code, no need to read it
09:30:02 <etpace> Hey guys, I'm trying to make a "lazy" tree transversal (without relying on haskell laziness), the initial call would return a tuple say (1, f), where 1 is a leaf on the tree and calling f returns the next item: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7794#a7794 is my attempt and I've tried the computation so it seems ok, the problem is: the seemingly "infinite" type of f, and what f I should pass initially
09:30:10 <soupdragon> Cale, yeah that's what I'm saying .. it's unreadible and unmaintainable this is the good way to do it
09:30:15 <Paczesiowa> Cale: there are also tools to read interactively those proofs
09:30:42 <soupdragon> Cale, I meant.. not the good way*
09:32:09 <Cale> etpace: Haskell is not quite like the untyped lambda calculus :)
09:32:41 <Paczesiowa> Cale: and these aren't proofs, they're instructions to generate proofs
09:32:43 <etpace> so am I approaching it incorrectly?
09:33:15 <Saizan> are there any known problems with Data.ByteString.writeFile ?
09:33:57 <Cale> etpace: Well, you're essentially producing a list, only, with a strange type.
09:34:13 <etpace> yeah a "lazy" list
09:34:34 <Cale> etpace: It's probably possible to define a recursive newtype for your functions such that this works
09:34:50 <Cale> etpace: But, in the end, it will amount to pretty much the same thing as using a list.
09:34:52 <lilac> listTree :: (Tree a) -> (a -> (a, (
09:34:55 <lilac> ^^ parse error
09:35:08 <etpace> Yeah, the problem is i'm not sure on the type lilac
09:35:09 <Cale> lilac: He stopped writing the type there... it's an infinite type.
09:35:12 <etpace> it would seem that's infinite
09:35:37 <lilac> which type is it the fixed point of?
09:35:50 <Cale> also, it's a little off
09:36:16 <lilac> is it Mu (\b -> (Tree a) -> (a -> (a, b))) ?
09:36:49 <etpace> I know it's no different from using a list, it's more of a learning exercise on how I'd do something like this to have a lazy list in another language
09:37:01 <etpace> I'm not sure what that means lilac
09:37:06 <Cale> actually, this is really weird
09:37:20 <Berengal> etpace: Thunking in other languages means iterators, and pray you've got reentrant functions
09:37:21 <Cale> You're passing f the parameter 0 in the empty list case.
09:37:32 <Cale> Er, empty tree case, sorry
09:37:33 <etpace> yeah, f doesn't use the argument at all though
09:37:45 <lilac> etpace: i think you might want something like: data List a = Nil | (a, () -> List a)
09:38:12 <etpace> Is a reentrant function meaning, when I hit a Leaf/Empty I can go back to the branch?
09:38:40 <soupdragon> reentrant??
09:38:47 <soupdragon> that's to do with multithreadin
09:38:53 <etpace> oh, ok
09:38:54 <Berengal> etpace: A reentrant function is a "function" you can step back into after it's returned a value. It makes no sense in haskell
09:39:18 <lilac> reentrant means that the function can be called from something it calls and it will operate correctly
09:39:39 <benmachine> it means a function that can be re-entered :P
09:39:53 <lilac> re-entered (while it's already running)
09:39:56 <benmachine> yeah
09:40:12 <benmachine> does a function interrupted by a signal handler and then resumed fall into that?
09:40:24 <benmachine> (a signal handler or something else asynchronous)
09:40:43 * Cale doesn't understand what is meant by 'entered' ;)
09:40:51 <benmachine> presumably it does if the signal handler calls that function
09:41:02 <Cale> (perhaps by willful ignorance here ;)
09:41:05 <benmachine> heh
09:41:17 <lilac> all pure functions are reentrant, so we're pretty safe in haskell land
09:41:34 <Cale> Well, no other functions are functions.
09:41:49 <Cale> Unless you want to talk about all the uncomputable ones :)
09:41:52 <lilac> arguably partial functions aren't functions either :)
09:41:59 <benmachine> surely you could make an IO function non-reentrant
09:42:06 <Cale> Nah, they're functions with slightly larger codomains
09:42:23 <lilac> benmachine: the function itself would be reentrant, but the IO action is a different matter... :)
09:42:33 <benmachine> lilac: hah
09:42:37 <benmachine> suppose so
09:43:06 <Cale> Applying a function of type a -> IO b has no side effects or anything. It just gives you a value of type IO b ;)
09:43:32 <Cale> anyway
09:43:41 <benmachine> so what happens when you actually run main is basically a coincidence
09:44:13 <Cale> etpace: You probably want to go with lilac's type suggestion. It would be what you'd use for a lazy list in a strict language.
09:44:29 <Cale> data List a = Nil | Cons a (() -> List a)
09:44:44 <lilac> thanks for fixing it :)
09:44:47 <Twey> 17:29:33  * Cale wonders if any human exists who can stare at "destruct h. simpl. discriminate 1. case h;simpl. discriminate 1.  intros h0 h1 p;exists h1;exists h0;auto." and honestly say "Ohhhh! So that's why."
09:44:51 * Twey honestly said it.
09:45:02 * Twey didn't say it honestly, but he did honestly say it.
09:45:14 <Cale> heh
09:45:19 <lilac> although probably: data ListVal a = Nil | Cons a List a; type List a = () -> ListVal a
09:45:47 <lilac> unless you want your list to always be in WHNF
09:45:54 <Cale> right
09:46:05 <Berengal> I've now had a coffee, and appologize for my previous misuse of lingo
09:46:20 <Berengal> I meant resumeable functions, not reentrant
09:47:33 <Cale> People seem to use the word 'function' in awfully strange and abusive ways. :)
09:48:09 <Berengal> Cale: I got tired of putting it in quotes all the time.
09:48:13 <etpace> what does the arrow do?
09:48:17 <Berengal> Also, people didn't understand me :(
09:48:31 <benmachine> maybe we should call all the other ones procedures or subroutines
09:48:44 <benmachine> but then people look at you like you just arrived from 1980
09:48:55 <etpace> oh, I see
09:49:06 <Cale> etpace: u -> v is the type of functions which take a parameter of type u, and send it to a value of type v
09:49:06 <etpace> how do you define a function in haskell that takes no type?
09:49:14 <Cale> etpace: You don't.
09:49:15 <etpace> or is it, it takes the empty tuple?
09:49:20 <Twey> You don't — that's not a function.
09:49:24 <Cale> etpace: Every function in Haskell takes exactly one parameter.
09:49:37 <Twey> A function is a mapping from one set of values to another.
09:49:41 <byorgey> etpace: but yes, you could use  ()  (the unit type, or empty tuple) as the argument type
09:49:47 <Cale> (those which appear to take more are really producing other functions)
09:49:47 <Berengal> Function without parameters are simply values
09:49:49 <Twey> You could, but it would be pointless.
09:49:53 <glguy> :t ()
09:49:55 <lambdabot> ()
09:49:57 <byorgey> then it would "effectively" not take a parameter, in the sense that the parameter would convey no information
09:49:59 <Twey> (and not in a good way)
09:50:07 <byorgey> but you'd still have to pass it  () as an argument.
09:50:14 <glguy> the () has two values, () and undefined :)
09:50:35 <Berengal> (() ->) has one use: memoization
09:50:44 <byorgey> now glguy, let's not get ahead of ourselves, that's like lesson 15 or so =)
09:50:44 <Berengal> Or rather, disabling it when it's unwanted
09:50:50 <Twey> Berengal: Ewww.
09:51:05 <Cale> It can be useful, but only very rarely.
09:51:16 <Berengal> Twey: I know, I've never used it. Seen it a couple of times in libraries (like Data.Numbers.Primes)
09:51:21 <Philonous> @type let f :: (); f = f in f -- this is not undefined
09:51:23 <lambdabot> ()
09:51:26 <byorgey> ah, yeah, I used that once
09:51:28 <Twey> Doesn't GHC have an annotation of some sort for that?
09:51:29 <glguy> byorgey: but with things like asynchronous exceptions, you can put just about *anything* in a value and type it is ()
09:51:44 <glguy> byorgey: seems wrong to claim that it passes no information
09:51:45 <Berengal> Actually, I think Data.Numbers.Primes used a proper function, but one which returned the same value for every argument...
09:51:49 <Cale> Basically, if you define a constant, even if it's very large, once computed it will not be recomputed.
09:52:19 <Berengal> > let f:: (); f = f in f
09:52:21 <Cale> Instead it will be recorded until it's completely out of scope, which at the top-level usually means pretty much never.
09:52:23 <byorgey> glguy: but if you tried to teach someone without starting at half-truths, their brain would explode.
09:52:24 <lambdabot>   mueval-core: Prelude.read: no parse
09:52:24 <lambdabot>  mueval: ExitFailure 1
09:52:52 <glguy> byorgey: OK. What week do you find out that * actually has higher precedence than + ?
09:52:57 <Cale> But if you define a function, functions don't remember their results for any given parameter
09:53:06 <Cale> Even when the domain is as small as ()
09:53:18 <byorgey> glguy: eh?
09:53:39 <glguy> byorgey: I remember in school when they told us that you didn't resolve the operators left to right
09:53:45 <Philonous> Cale: Not in general, but you can make them do that
09:53:47 <glguy> it was crazy
09:53:51 <byorgey> hehe
09:54:41 <Cale> Philonous: Well, not in GHC>
09:54:47 <Cale> s/>/./
09:54:51 <byorgey> glguy: well, the problem with much primary-school education these days (at least in the US) is that teachers continue to insist on the half-truths, _even when students explicitly question them_
09:54:55 <Philonous> Cale: http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
09:55:09 <Philonous> Works pretty well for me
09:55:18 <Cale> Philonous: Oh, I know about that, yes.
09:55:22 <glguy> Philonous: in that case the function isn't doing the memoization
09:55:25 <byorgey> that's just as bad, if not worse, than stating all the technically correct details up front.
09:55:30 <glguy> the value is
09:55:56 <Philonous> glguy: But what you get is a memoizing function
09:56:27 <Cale> Philonous: That library uses unsafePerformIO internally to extend GHC's evaluation model :)
09:56:44 <Philonous> Cale: I looked at the source and didn'T find unsafePerformIO
09:56:47 <glguy> \o/
09:57:03 <Cale> er, hmm
09:57:28 <Philonous> Cale: That whas my first guess, too, though.
09:57:56 <Cale> oh, I see, it just explicitly represents memo tables.
09:58:04 <Philonous> This seems to be the core of it: bool f = cond (f True) (f False)     where     cond t f True  = t   ;  cond t f False = f
09:58:55 <Philonous> I think it's a neat trick
09:59:34 <Twey> Philonous: That's (??)
09:59:44 <Twey> I think
09:59:45 <Twey> Oh no
09:59:51 <Twey> Sorry, I misread :)
10:00:57 <etpace> How do I add an explicit Show for a function, say I want show () -> List a, just to print "function" or something
10:01:06 <etpace> just anything at all, so I can print it in ghci
10:01:22 <byorgey> etpace: instance Show (a -> b) where show _ = "function"
10:01:25 <Berengal> etpace: instance Show (() -> List a) where
10:01:56 <byorgey> I think there's even a module which already defines that for you
10:02:17 <byorgey> ah yes, Text.Show.Functions
10:02:19 <Twey> Would be nicer to use TH to show the type of the function
10:02:31 <byorgey> or just Typeable
10:02:45 <etpace> is there an option that shows a function as its type?
10:02:56 <Twey> Yeah, Text.Show.Functions just says <function>
10:03:22 <byorgey> import Data.Typeable; instance (Typeable (a -> b)) => Show (a -> b) where show = show . typeOf
10:03:35 <byorgey> something like that ought to work
10:03:50 <benmachine> > typeOf id
10:03:52 <lambdabot>   Add a type signature
10:03:59 <benmachine> ^ you have to work that out though
10:04:30 <byorgey> benmachine: well, usually in context the type of an argument to 'show' will be known by type inference.
10:04:53 <benmachine> hmm
10:05:03 <benmachine> I'm not so sure
10:05:45 <benmachine> if you have 'show id' then there is no context for id
10:05:58 <byorgey> but when would you ever have "show id" ?
10:06:08 <byorgey> in real code.
10:06:27 <Philippa> to be fair: normally, defaulting kicks in
10:06:31 <benmachine> in real code I dunno, but it'd come up a lot in ghci
10:06:50 <benmachine> I'm not sure why you'd want a show for functions in real code anyway :P
10:07:02 <Philonous> benmachine: In ghci you can just punch :t in front of the whole expression
10:07:08 <benmachine> but if you did, I can't imagine that you'd never get a polymorphic type there
10:07:21 <benmachine> I suppose so yes
10:07:41 <benmachine> so there's a question of why would you ever want a show for functions in the first place
10:07:51 <benmachine> > id
10:07:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:07:53 <lambdabot>    arising from a use of `...
10:08:48 <benmachine> it would be kind of cool if showing an expression did something akin to @pl on it
10:08:53 <benmachine> kind of cool, also kind of impossible
10:08:55 <Philonous> Any programm that evaluates user supplied expressions might
10:08:56 <benmachine> but there you go
10:09:15 <copumpkin> how deep should it go?
10:21:55 * brad_larsen just stumbled upon <http://www.haskell.org/haskellwiki/Type_witness>.  Awesome!  dynamic casts w/o unsafeCoerce.
10:22:34 <brad_larsen> (`cast' in Typeable uses unsafeCoerce)
10:30:19 <tromp> is there any ghc-6.10 version packaged for ubuntu 9.04?
10:31:31 <soupdragon> brad_larsen, bizarre lengths people go to, to aviod defining the equaltiy GADT
10:33:11 <Saizan_> tromp: does this fit? i've found it in my logs https://launchpad.net/~frej/+archive/ghc6.10
10:34:42 <tromp> let me try
10:37:06 <tromp> i get W: GPG error: http://ppa.launchpad.net jaunty Release: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY DA3B53950FCA6B52
10:40:25 <Nafai> tromp: Do this:
10:40:37 <Nafai> sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com DA3B53950FCA6B52
10:40:43 <Nafai> And then do apt-get update again
10:42:37 <hackagebot> liboleg 2009.8.1 - A collection of Oleg Kiselyov's Haskell modules (2009-2008) (DonaldStewart)
10:45:16 <tromp> shouldn't  sudo apt-get upgrade ghc6   upgrade from my 6.8.10 to 6.10.x ?
10:45:35 <tromp> i get  The following packages have been kept back: ghc6
10:46:16 <tromp> or shld i just remove & install?
11:02:09 <ertai> @where+ archers ertai
11:02:09 <lambdabot> I will never forget.
11:02:34 <brad_larsen> soupdragon:  the equality GADT?
11:02:40 <brad_larsen> soupdragon:  do share
11:04:03 <copumpkin> data (:==) a b where
11:04:14 <copumpkin> Moo :: (a ~ b) => (:==) a b
11:04:14 <copumpkin> ?
11:04:27 <copumpkin> (I'm a fan of cows)
11:04:52 <ertai> ?where+ archers shepheb dmwit webframp dschoepe Wraithan fumbles jelly12gen ertai
11:04:53 <lambdabot> I will remember.
11:05:23 <brad_larsen> soupdragon: this thing:  data Eql a b where Refl :: Eql a a ?
11:06:18 <copumpkin> :o
11:06:48 <copumpkin> what's with the archers stuff?
11:07:27 <lilac> data Frog a b = (a ~ b) => Ribbit a b
11:07:37 * lilac doesn't need no stinkin' GADT syntax
11:07:59 <lilac> maybe that should be "data Frog a b = (a ~ b) => Ribbit"
11:08:15 <brad_larsen> copumpkin: any idea how that would be used instead of type witnesses for casting?
11:10:18 <vav> copumpkin: people to ping when arch linux users have ghc upgrade problems to sort.
11:10:26 <copumpkin> oh :P
11:10:27 <lilac> brad_larsen: f :: Eql a b -> a -> b; f Refl a = a
11:10:30 <soupdragon> data Equal a b where Refl :: a -> Equal a a
11:10:46 <copumpkin> I was thinking bows and arrows
11:10:48 <soupdragon> or
11:10:51 <soupdragon> data Equal a b where Refl :: Equal a a
11:11:00 <brad_larsen> hmm
11:11:10 <soupdragon> depends.. on stuff..
11:11:28 <lilac> brad_larsen: inside 'f Refl a', GHC knows that a ~ b (since the ctor was Refl)
11:12:38 <brad_larsen> i currently use the type witness approach to do dynamic casting, so I can implement an Eq instance for an existential data type
11:13:30 <brad_larsen> something like:  data Exp :: * -> * where Eq :: (ToWitness a) => Exp a -> Exp a -> Exp Bool
11:13:41 <soupdragon> weird
11:13:45 <tromp> my cabal complains about  * Missing C library: GL
11:13:49 <tromp> how to install that?
11:14:04 <brad_larsen> soupdragon: yes, weird and warped, undoubtedly.  ;-)
11:14:06 <sjanssen> tromp: which operating system are you on?
11:14:13 <tromp> jaunty ubuntu
11:14:36 <brad_larsen> soupdragon: haven't done enough type system hackery to know a better way to go about things
11:14:49 <soupdragon> brad_larsen, what you wrote is fine
11:15:20 <brad_larsen> <soupdragon> brad_larsen, bizarre lengths people go to, to aviod defining the equaltiy GADT
11:15:27 <sjanssen> tromp: libgl-dev, I think
11:15:27 <brad_larsen> that had me wondering
11:19:00 <sjanssen> @yow!
11:19:00 <lambdabot> Thousands of days of civilians ... have produced a ... feeling for the
11:19:00 <lambdabot> aesthetic modules --
11:21:46 <hackagebot> yst 0.1 - Builds a static website from templates and data in YAML or (JohnMacFarlane)
11:24:24 <Paczesiowa> has anyone looked recently at sumfile benchmark? haskell is 20% faster there then C, but on my machine it's almost 4 times slower:/
11:24:31 <Paczesiowa> *than
11:25:32 <tristes_tigres> lies, damn lies and bechmarks
11:28:24 <mae> tristes_tigres: hallelujah!
11:31:27 <tromp> ah; i finally found the answers at http://nathanwiegand.com/blog/
11:36:41 <michaelfeathers_> Anyone here going to ICFP next month?
11:43:10 <dufflebunk> When I run 'runhaskell Setup.lhs configure --user --enable-executable-profiling', then build it, it keeps trying to link in profiling versions of other libraries like regex-tdfa. Anyone know how to get it to stop doing that?
11:44:38 <dufflebunk> or alternatively, how to install the profiling libraries of other packages.
11:48:21 <vav> dufflebunk: what platform are you on (and install method)?
11:49:19 <dufflebunk> linux, and I used cabal to install regex-tdfa
11:50:57 <vav> ok, well with cabal install use same flag for the supporting libs to enable profiling, (can clean and reinstall if needed) for distro versions there are pkg mgr flags or (debian) `-prof' suffix for profiling version
11:51:34 <dufflebunk> I tried cabal install regex-tdfa ----enable-executable-profiling but it didn't install the profiling libraries
11:51:43 <enolan> --enable-library-profiling
11:51:49 <dufflebunk> s/--/-/
11:52:41 <dufflebunk> of course, it's not an executable
11:52:49 * dufflebunk goes off to try a new switch
11:54:40 <dufflebunk> it would be nice if I didn't need the profiling version though. I don't want to profile the regex stuff, I want to profile my stuff.
11:55:35 <Cale> It's annoying how GHC has such random conventions when it comes to prefixing options with - and --
11:55:53 <bremner> -what do --you -mean?
11:56:19 <nego> Hello gents, I'm thinking of learning Haskell and wanted to get some advice.
11:56:19 <enolan> This one is cabal having random conventions though.
11:56:34 <dufflebunk> nego: my advice: do it
11:57:13 <nego> I have, pretty much, only functional programming experience (Lisp, scheme, ocaml, ML).
11:57:37 <soupdragon> nego interesting you are rare :p
11:58:17 <nego> I'm kind of a hobbyist Mathematician, and that's why I got involved in CS.
11:58:32 <Saizan_> Cale: --enable-library-profiling is for cabal
11:58:39 <Saizan_> Cale: ghc has -p
11:58:47 <nego> I'm taking a semester off from school to get up to speed in my Math and CS studies before I switch my major.
11:59:00 <dufflebunk> Bah, nope. When I try to build the profiling regex library it fails to build without regex-base installed for profiling.
11:59:26 <Saizan_> dufflebunk: recurse!
11:59:29 <dufflebunk> I do not want to reinstall all my modules with profiling enabled. Surely it's not necessary.
11:59:46 <nego> What I really want to do a lot of is data visualization, and I was curious as to how well Haskell's opengl interface performs.
12:00:10 <Saizan_> dufflebunk: unless you're willing to hack ghc it is necessary
12:00:30 <nego> Right now, I'm looking at Ocaml, AliceML, F# and Haskell. Haskell seems to have the neatest books.
12:00:58 <nego> and the monads system makes more sense to me than doing OO in other programming languages.
12:01:12 <dufflebunk> Saizan_: so to profile my program I have to reinstall all the modules with profiling. Then to make a non-profiling executable I have to reinstall them all all over again?
12:01:48 <Philonous> Someone should tell that to the OO programmers
12:02:10 <Saizan_> dufflebunk: no, when you --enable-library-profiling you get it built and installed both ways
12:02:26 <dufflebunk> Ah, ok. That's better then.
12:02:52 <Twey> interface FunctionFromAToB<A, B> { B function(A); }
12:04:12 <Saizan_> dufflebunk: you might want to put "library-profiling: True" in your ~/.cabal/config so that you always get the profiling version installed
12:04:24 <nego> Also, in terms of speed. Is Haskell competitive with ocaml and F#? Does/will it have comparable concurrent support?
12:04:55 <nego> I've done some searching on this, but I see a lot of studies that state the exact opposite of each other.
12:06:24 <nego> and lastly, does anyone have some source code examples of data visualization in Haskell?
12:06:48 <Saizan_> GHC has great support both for concurrency and parallelism
12:07:21 <dufflebunk> Yay! It built this time.
12:07:22 <Philonous> nego: speed is a property of implementations and the concrete programme you are writing, but ghc seems to do quite well
12:07:57 <Philonous> nego: https://s7-us2.ixquick.com/do/highlight.pl?c=hf&rid=MELMOTLPNPPO&l=english&cat=web&sp=14cacd89be0cd970c0e2017299288efc&ts=MTI0OTE1MzYxMg%3D%3D&q=language+shootout&u=http%3A%2F%2Fshootout.alioth.debian.org%2F.%2Fu64q%2Fbenchmark.php%3Ftest%3Dall%26amp%3Blang%3Dall&/file.gz
12:08:03 <Saizan_> it uses userland threads scheduled over OS threads, so you can have millions of them running without problems
12:08:16 <Philonous> sorry, I meant http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&amplang=all
12:08:40 <dufflebunk> thanks Saizan_ vav and enolan
12:08:53 <nego> Thanks gents
12:09:57 <Saizan_> and it's quite nice to be able to parallelize an algorithm by simply adding `par` annotations (provided that the algorithm has some parallelism to harness)
12:10:57 <vav> nego: http://vis.renci.org/jeff/hieroglyph is worth checking out
12:11:29 <hackagebot> sendfile 0.5 - A portable sendfile library (MatthewElder)
12:14:53 <Philonous> nego: Because of the non-strict semantics of haskell, performace (both in regards to time and space) can be harder to reason about than in a strict language.
12:17:05 <nego> Philonous: That's one of the reasons I wanted to come here and ask. I figured the results wouldn't be a great prediction for my future code.
12:17:16 <nego> Everything about Haskell sound neat though
12:17:35 <badsheepy> i find it somewhat like reasoning with a weasel
12:17:50 <nego> Please, explain
12:18:16 <badsheepy> im just severely broken in the head :(
12:18:20 <badsheepy> :D
12:18:23 <nego> hah
12:19:41 <Athas> Does syntax exist for denoting that an integer literal is of type Int32?
12:20:05 <copumpkin> 5 :: Int32 ?
12:20:06 <mercury^> 3 :: Int32
12:20:17 <copumpkin> my number is bigger than yours!
12:20:30 <mercury^> :<
12:20:30 <Athas> I suppose that's good enough.  Is there an interesting reason why type inference doesn't handle this?
12:20:39 <copumpkin> Athas: it does
12:20:40 <soupdragon> no no
12:20:44 <mercury^> It does.
12:20:44 <soupdragon> 32 :: Int32
12:20:48 <soupdragon> duh :p
12:20:49 <copumpkin> lol
12:20:55 <Cale> Athas: It does, but if you never specify anywhere that it's supposed to be an Int32, the default is Integer
12:20:57 <Athas> Oh right, I was looking at the wrong spot in my code.
12:21:04 <copumpkin> :t 5
12:21:06 <lambdabot> forall t. (Num t) => t
12:21:08 <vav> > (maxBound + 1) :: Int32
12:21:10 <lambdabot>   -2147483648
12:21:12 <copumpkin> zomg
12:21:15 <Cale> Numeric literals are polymorphic
12:24:35 <jrty> if I have a type like: data Foo = A | B; how can I extend this to a new type Bar where A, B, and C are constructors for Bar?
12:25:04 <soupdragon> yes
12:25:08 <soupdragon> sort of
12:25:20 <soupdragon> it's more like  FromFoo A, FromFoo B, C
12:25:35 <copumpkin> data FooWithC = Foo Foo | C
12:25:36 <copumpkin> :P
12:26:14 <BMeph> Classes are open, and types are closed. :)
12:26:33 * copumpkin signs up for BMeph's classes
12:26:42 <BMeph> (Is that the right terminology? :)
12:27:42 <idnar> haha
12:28:28 <jrty> copumpkin: that works, but it seems awkward
12:28:34 <copumpkin> jrty: yeah it is
12:29:35 <jrty> so the idiomatic approach would be to use classes?
12:29:43 <soupdragon> no
12:38:36 <Saizan_> jrty: it mostly depends on what you're doing at an higher level
12:39:00 <Saizan_> jrty: this approach might be a good fit http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
12:59:19 <michaelfeathers> jrty: nice link.  Thx.
13:00:36 <michaelfeathers> er, Saizan.
13:01:52 <Saizan_> thanks to Cale that has written the article :)
13:02:34 <Cale> :)
13:03:15 <michaelfeathers> Coming from an OO background, that is the thing which freaks me out the most about algebraic data types: the "openness" of them in the Open/Closed sense.
13:03:49 <nego> The exact opposite is what freaks me out about OO actually.
13:04:12 <nego> Well, not so much freaked out... but I don't yet see the value in the OO method for that.
13:04:17 <Saizan_> the closedness you mean?
13:04:24 <nego> yeah
13:04:37 <vegai> the value may become apparent when there's a large team of mediocre programmers
13:05:28 <Cale> michaelfeathers: They are closed in the sense that all the cases are explicit in one place.
13:05:31 <Saizan_> (i realize closed/openness is ambiguous since you might be thinking of methods or contructors)
13:05:49 <vegai> then again, large teams are passé
13:06:26 <Cale> You could also be thinking about topology I suppose, but I'm not sure what topology you'd be talking about ;)
13:07:13 <michaelfeathers> Cale: except that you can pattern match on them anyplace.. so the number of places you have to potentially change when you add a case can be large.
13:07:28 <Cale> michaelfeathers: Right.
13:07:57 <Cale> michaelfeathers: But changes in types always lead to lots of changes elsewhere.
13:08:13 <Cale> michaelfeathers: It's similar in nature to what happens if you add a new method to a base class.
13:09:08 <michaelfeathers> Cale: Adding a method to a base class can be innocuous.  Affects the compile, but no code change until you use it.
13:10:10 <Saizan_> it's more like what happens if you add a method to a base interface
13:10:22 <Saizan_> fsvo base
13:11:01 <Cale> michaelfeathers: Sorry, abstract base class.
13:11:31 <michaelfeathers> Saizan: To me it seems worse.. pattern matches are more likely exhaustive than not.. right?
13:11:33 <Cale> michaelfeathers: The expectation being that you're going to have to implement that method on all the subclasses.
13:11:50 <Cale> michaelfeathers: It's the exact same issue in disguise :)
13:11:56 <michaelfeathers> So if you add a case, chances are you are revisiting most of the functions which deconstruct the type.
13:12:19 <Saizan_> what cale said :)
13:12:20 <michaelfeathers> Cale: yes, abstract method is a better analogy.
13:12:56 <Cale> michaelfeathers: It's just that inheritance muddies the issue somewhat.
13:14:43 <michaelfeathers> Cale: True... when I have my OO goggles on.. I like to think of an ADT as presenting a set of functions which allow you to use the ADT without knowing about it.. typically by translating to other types.
13:15:07 <Cale> michaelfeathers: When you add a new method to a base class with a default implementation, then the children can use that implementation, but it's harder to say right away that it's really the right implementation for them to have.
13:15:09 <michaelfeathers> Seems that you need that at some level to prevent types from being known every place.
13:15:33 <Cale> So the language is helping you out by doing something automatic, but it might not actually be the right thing :)
13:15:41 <Saizan_> http://okmij.org/ftp/Computation/Subtyping/ <- this enlightens a pretty crucial problem of oop
13:16:11 <randomity> michaelfeathers: in OO, when you add an case you can just add it cleanly as another subclass. When you add an operation, you have to touch every subclass. In Haskell, the situation is the reverse
13:16:17 <michaelfeathers> Cale: yes, and it's rare for me to add concrete methods to base classes.. often they end up their due to duplication removal.
13:16:51 <michaelfeathers> randomity: yup, that was an old saying about OO and procedural too.
13:16:51 <randomity> I think the Haskell solution is cleaner: adding an operation doesn't affect the other classes, but adding a new case does (the base type has changed, there's another possibility)
13:17:02 <Saizan_> (which is the reason why i prefer typeclasses over subtyping)
13:17:28 <randomity> surely when you add a new case, you've changed stuff? but when you add a new operation, it's independant of the existing operations?
13:17:43 <Cale> Of course, looking at the article that I wrote, there's a way to turn things around just as easily in Haskell whenever extending the cases is more important than extending the operations.
13:17:44 <BMeph> That reminds me of another "problem" with OO (and ADTs) that someone else has mentioned: what if you want a new type that's like an existing type, but with certain constructors removed?
13:18:00 <michaelfeathers> I think it is funny that both the OO and FP worlds arrived at the same problem.  In OO it is pointed to by Open/Closed.  In FP it is 'the expression problem.'
13:18:46 <Saizan_> BMeph: then you want extensible variants :)
13:19:44 <Saizan_> which are the dual to extensible records
13:19:58 <Saizan_> (of?)
13:20:14 <BMeph> Saizan_: Do you have a reference for tha? It sounds like it's the right answer, but I haven't heard of it before.
13:20:25 <BMeph> for *that
13:21:33 <Saizan_> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.21.6627
13:21:58 <Saizan_> http://lambda-the-ultimate.org/node/1119
13:23:16 <Cale> michaelfeathers: Traditional OO and FP take dual approaches to which program designs they make easy, but yeah, the overall problem is the same :)
13:23:33 <Cale> (It's not really an OO vs. FP issue, but something more fundamental)
13:23:37 <Saizan_> both nice, the type system of the latter one is simpler, iirc
13:24:15 <michaelfeathers> Cale: yup.
13:38:12 <martint> does anyone else have trouble building haskell platform 2009.2.0.2?  my build breaks with the following: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3128#a3128
13:40:09 <dons> checking...
13:40:41 <dons> dcoutts: do you know what's going on here? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3128#a3128
13:41:10 <dons> what ghc vesrsion, martint
13:41:34 <martint> dons: The Glorious Glasgow Haskell Compilation System, version 6.10.4
13:43:06 <dons> mmm
13:43:21 <dons> martint: dcoutts will know. I'm not sure what's going on there, no one else has reported this.
13:43:29 <dons> see if you can build the package by hand
14:11:03 <defun> hi. haskell strikes me as a very fast language (performace-wise). However, by browsing old mailing list archives, etc. I get the impression that at one point this was not true. Haskell's speed seems to be a fairly recend developments, and I was hoping that someone here can tell me which year, or which GHC release helped improve performace. And what optimizations were responsible for this performace increase. Thanks.
14:11:27 <Cale> defun: It's been a gradual process over the last few years.
14:11:39 <Cale> defun: Well... really since Haskell started.
14:12:08 <defun> I see. So there is no definitive period, where "haskell became fast"?
14:12:16 <Cale> defun: Haskell is in part a project to better understand how to compile languages with non-strict semantics.
14:12:26 <sclv_> there are a series of articles on ghc (generally co-authored by spj) that describe various optimizations
14:12:41 <defun> sclv_: thanks.
14:13:14 <sclv_> additionally there is the work by dons, dcoutts and others on stream fusion
14:13:16 <Cale> defun: I'd say a major point was the introduction of ByteStrings
14:13:26 <defun> ByteStrings?
14:13:26 <sclv_> (and bytestrings)
14:13:48 <defun> Are they related to Strings?
14:14:15 <sclv_> defun: direct representation of byte arrays for strings, etc, rather than strings in haskell which are lazy lists of chars
14:14:16 <Cale> defun: Many of the things which were slow before are related to the fact that String is a lazy linked list of 32-bit Chars.
14:14:36 <Cale> defun: Which is a convenient representation for manipulation, but sucks performance-wise
14:14:40 <sclv_> they also provide good interfaces for networking, serialization, etc.
14:15:01 <defun> what is a byte array?
14:15:10 <sclv_> an array of bytes
14:15:19 <defun> oh I see.
14:15:22 <jrty> nicer way to write: all (==(head xs)) xs ?
14:15:28 <sclv_> its a clean semantics for very low level things
14:16:59 <soupdragon> jrty, oooo
14:17:17 <copumpkin> jrty: (==1) . length . group
14:17:18 <copumpkin> :P
14:17:32 <jrty> heh
14:17:39 <soupdragon> :t join (all . (==) . head)
14:17:41 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:18:34 <jrty> aha
14:22:14 <soupdragon> jrty.. but it breaks on []
14:22:23 <soupdragon> I think someone knows an even better way
14:23:06 <dufflebunk> I'm looking for a function that has a type of (a -> b) -> (a -> c) -> a -> (b, c), and does the obvious. hoogle doesn't find something, does anyone have a handy composition for it?
14:23:27 <copumpkin> > cycle []
14:23:29 <lambdabot>   * Exception: Prelude.cycle: empty list
14:24:43 <soupdragon> :t liftA2 (,)
14:24:45 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
14:24:50 <soupdragon> :t liftA2 (,) :: (a -> b) -> (a -> c) -> a -> (b, c)
14:24:52 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
14:25:05 <soupdragon> :t liftA2 (,) :: [b] -> [c] -> [(b, c)]
14:25:07 <lambdabot> forall b c. [b] -> [c] -> [(b, c)]
14:25:08 <soupdragon> stuff like that
14:25:09 <pikhq> And here I was about to do something with the function monad.
14:25:45 <copumpkin> :t (&&&)
14:25:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:25:51 * dufflebunk goes to read about Applicative
14:25:57 <copumpkin> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
14:25:59 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
14:26:10 <pikhq> Ah, yeah. (&&&). Arrows. :)
14:26:37 <pikhq> > (+2) &&& (*2) $ 50
14:26:38 <lambdabot>   (52,100)
14:28:49 <dufflebunk> every time I ask a question like that, I get an answer that blows my mind. I have no idea how that type a b (c, c') could give me what I want.
14:29:28 <copumpkin> let b = (a ->)
14:29:48 <copumpkin> (you can't write (->) sections but that's what it basically is)
14:30:05 <pikhq> dufflebunk: Well, you see, (a ->) is a type.
14:30:13 <dufflebunk> O_O
14:30:16 <pikhq> And as it happens, that type is an instance of Arrow.
14:30:29 <copumpkin> dufflebunk: you can think of (->) as a two-parameter type constructor
14:30:45 <copumpkin> :k (->)
14:30:47 <lambdabot> ?? -> ? -> *
14:30:53 <pikhq> (not to mention an instance of Monad, of Applicative, and of Functor)
14:31:15 <copumpkin> well, (->) is the Arrow instance and ((->) a) is the instance of Monad, Applicative, and Functor
14:31:25 <pikhq> copumpkin: Well. Yeah.
14:31:53 <pikhq> Hmm.
14:31:55 <pikhq> @instances Arrow
14:31:56 <lambdabot> (->), Kleisli m
14:32:18 <pikhq> Okay, so function and the monads. Cool, cool.
14:32:39 <Athas> The X11 library defines a bunch of types that are pointers underneath (using newtype); is there a general facility for checking whether they're null?
14:35:18 <Saizan_> (==nullPtr) ?
14:35:31 <shapr> heh
14:35:47 <Athas> They're wrapped in a newtype, eg: newtype FontStruct = FontStruct (Ptr FontStruct)
14:35:51 <Saizan_> never used it though
14:36:02 <Saizan_> the newtype constructor is not exposed?
14:36:13 <copumpkin> Athas: that looks like a useful type
14:36:22 <Athas> Hmm, I suppose that it is.
14:42:24 <martint> dons: mtl-1.1.0.2 comes with ghc 6.10.4.  fresh out of the hp tarball, make tells me "Platform package mtl-1.1.0.2 is already installed. Skipping..." before it happily completes.  make install then tells me "The mtl-1.1.0.2/Setup script does not exist or cannot be run".  see new log here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3128#a3129
14:43:18 <martint> the earlier log was when i just confused myself and did a further configure/make afterwards
14:46:19 <EnglishGent> hello
14:46:52 <shapr> howdy
14:46:56 <copumpkin> greetings!
14:47:53 <defun> when i do patter matching with list should I do "func (x:xs) = ... ; func [] = ..." or should I do "func [] = ... ; func (x:xs) = ..."? In other words should the empty list argument come first or last? And why?
14:47:59 <defun> *pattern
14:48:12 <copumpkin> in that case, it doesn't matter
14:48:28 <copumpkin> but if one pattern is strictly more general than the other one, it should appear afterwards
14:48:30 <copumpkin> or it won't get called
14:54:43 <Athas> Hrm, it looks like the newtype constructor is not exposed...
14:55:35 <Athas> Has anyone here experience with using queryFont from the X11 library?  It doesn't look like it's usable if you can't query the value for null-ness.
15:30:37 <mmmulani> how do you create an MArray with elements of type Bool?
15:32:00 <copumpkin> :t listArray
15:32:02 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:32:07 <copumpkin> oh whoops
15:32:20 <benmachine> @hoogle MArray
15:32:21 <lambdabot> module Data.Array.MArray
15:32:21 <lambdabot> Data.Array.Base class Monad m => MArray a e m
15:32:21 <lambdabot> Data.Array.MArray class Monad m => MArray a e m
15:32:24 <copumpkin> :t newArray
15:32:26 <lambdabot> Not in scope: `newArray'
15:32:32 <copumpkin> newArray :: Ix i => (i, i) -> e -> m (a i e)
15:33:30 <mmmulani> so would "a = newArray (2,10) 0" work?
15:33:52 <copumpkin> not 0
15:34:17 <mmmulani> :S
15:34:17 <copumpkin> newArray (2, 10) False for example
15:34:50 <mmmulani> hmm newArray (2,10) False gives me an error as well
15:34:58 <copumpkin> "an error"?
15:35:11 <copumpkin> are you constraining the return type sufficiently?
15:35:55 <mmmulani> hmmm, I'm doing this in the interpreter
15:36:08 <mmmulani> I'm not making a type definition at all
15:38:09 <Cale> mmmulani: note that newArray (2,10) 0 would be an action, and so a would just be defined as the same action as that.
15:38:14 <Cale> (not an array)
15:38:45 <mmmulani> hmm, I'm going to try following the wikibooks tutorial on mutable arrays
15:38:56 <Cale> mmmulani: You may want to turn off the monomorphism restriction...
15:39:28 <Baconizer> ohaider
15:39:37 <Baconizer> I'm trying to decide which language to learn
15:39:44 <copumpkin> Baconizer: you know which one we'll suggest
15:39:46 <Baconizer> Pretty much for the first time
15:39:50 <Baconizer> copumpkin: I know :P
15:40:06 <Baconizer> I'm just wondering if everyone would say this is a beginner-friendly
15:40:09 <Baconizer> I guess so :P
15:40:12 <Nafai> Baconizer: If you want something that will influence the way you think about programming in a very profound way, Haskell is an excellent choice
15:40:13 <skorpan> Baconizer: it's not
15:40:17 <copumpkin> it is
15:40:31 <pikhq> It is easier to learn as a first language than as a second one.
15:40:35 <copumpkin> being unspoiled by imperativism is good :P
15:40:36 <Cale> mmmulani: try  a <- newArray (2,10) 0 :: IO (IOArray Int Int)
15:40:41 <Baconizer> Okay
15:40:42 <Baconizer> I'
15:40:42 <Nafai> In some ways, an intelligent beginner at programming would have an easier time with Haskell than an experienced programmer
15:40:50 <Baconizer> will try Haskell then
15:40:51 <Baconizer> :D
15:40:53 <Nafai> But people already said that
15:40:54 <Cale> mmmulani: By restricting the type, you can get it to work in ghci
15:40:55 <pikhq> copumpkin: Makes it harder to argue in favor of Haskell, though.
15:41:03 <copumpkin> why?
15:41:15 <Cale> mmmulani: The error was basically that the type of array you wanted to make was ambiguous.
15:41:16 <pikhq> Tricks like "infinite list of all the fibonacci numbers" are less impressive. :P
15:42:23 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
15:42:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:43:20 <mmmulani> ohhhh
15:43:40 <mmmulani> Cale: what's the different between IOArray and MArray?
15:43:46 <copumpkin> can't that be done even more succinctly using a nubBy?
15:43:48 <BMeph> I especially like my rooted/free tree count functions. :)
15:43:55 <Cale> mmmulani: MArray is the general interface which IOArray is an instance of
15:44:21 <Cale> mmmulani: (along with STArray, StorableArray and a few others)
15:44:23 * benmachine pokes Baconizer 
15:45:11 * BMeph contemplates seeing if giving drugs to Baconizer will get him fried... ;p
15:45:21 * copumpkin cries
15:46:03 <Baconizer> :o
15:46:11 <Baconizer> benmachine: you are a Haskell fan?
15:46:15 <benmachine> yes
15:46:31 <benmachine> I'm not much good at it
15:46:35 <Baconizer> Neat, I'll have someone to bug about my problems then :P
15:46:41 <benmachine> but it's the most fun ever
15:46:49 <Cale> Baconizer: feel free to ask any questions here
15:46:58 <benmachine> you already have 586 such people :P
15:47:11 <Cale> Baconizer: There are usually people hanging around willing to answer beginner questions any time of day.
15:47:11 <benmachine> including ChanServ
15:47:14 <copumpkin> Baconizer: often any question you ask will lead to 3 or 4 people jumping over themselves to answer it first
15:47:19 <Baconizer> benmachine: yes, but you should be the most fun to bother :P
15:47:35 * benmachine is okay with that
15:47:46 <benmachine> but y'know, half of the time I'd just end up asking here >_>
15:47:48 <copumpkin> Baconizer: I don't think it's much bother... most of us enjoy answering questions :)
15:47:51 <dufflebunk> Yeah, I ask all sorts of beginer questions and they usually get answered pretty quickly.
15:47:56 <Baconizer> Yays
15:48:10 <benmachine> #haskell is possibly the nicest support channel I've ever seen
15:48:29 <benmachine> and probably would still be so if it had any serious competition for that position
15:50:23 <dufflebunk> benmachine: it doesn't have competition, so it's not still the nicest?
15:51:23 <benmachine> dufflebunk: it is the nicest, and if it had competition, it would still be the nicest
15:51:40 <benmachine> its victory is not conditional on the presence of competition
15:52:17 <benmachine> this did not make much sense to begin with and has not been improved by exploration
15:52:35 * benmachine abandons the idea and just hugs everyone instead
15:55:28 <dufflebunk> :t (\ (a,b) -> any (curry q a . (:[])) b)
15:55:29 <lambdabot>     Couldn't match expected type `(a, b) -> c'
15:55:29 <lambdabot>            against inferred type `Expr'
15:55:29 <lambdabot>     In the first argument of `curry', namely `q'
15:56:30 <copumpkin> :t q
15:56:31 <lambdabot> Expr
15:57:01 <benmachine> @index q
15:57:01 <lambdabot> bzzt
15:57:06 <mike-burns> > q
15:57:08 <lambdabot>   q
15:57:37 <copumpkin> :t f
15:57:39 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:58:03 <copumpkin> > foldr f a [b, c, d, e]
15:58:05 <lambdabot>   f b (f c (f d (f e a)))
16:00:20 <al23> Hi! Is there a Haskell code search working like grep on sources, not just checking function names and types?
16:01:51 <SamB> al23: ... what was the problem with grep?
16:02:18 <gwern> al23: hayoo?
16:02:22 <al23> SamB: it is not nifty web based thing :-)
16:02:47 <al23> SamB: Actually, it's OK for local sources.
16:03:16 <al23> gwern: I thought hayoo searches only function names and types.
16:03:27 <gwern> it doesn't do haddocks?
16:03:36 <gwern> only names and types sounds like hoogle
16:06:24 <al23> gwern: Oh. You're right. Hayoo works with haddocks as well; it just gives matching names/types on first pages.
16:08:44 <BMeph> > let { facs = ap (filter . ((==0) . mod) (enumFromTo 1) ; rootT n = (map rootedT [0..]) !! n ; rootedT 0 = 0; rootedT 1 = 1; rootedT n = flip div n' (sum [ d*rootT d | d <- facs n' ] + sum ([sum [ d*rootT d | d <- facs (n-j) ] * rootT j | j<- [2..n']])) where n' = pred n} in rootT 18
16:08:46 <lambdabot>   <no location info>: parse error on input `;'
16:08:59 <al23> Hm. Google code search is OK. But I'm not sure whether it indexed all the Hackage stuff, for example.
16:09:35 <defun> This just occurred to me: There has been some fuss about microkernels and monlithickernels, between my friends who are OS geeks (and C geeks). Wouldn't the whole distinction between microkernels and monolithic kernels be significantly blurred if a hypothetical kernel was written in a parralel/concurrent language such as erlang or parralel haskell?
16:10:17 <defun> *parallel
16:10:35 <BMeph> > let { facs = ap (filter . ((==0) .) . mod) (enumFromTo 1) ; rootT n = (map rootedT [0..]) !! n ; rootedT 0 = 0; rootedT 1 = 1; rootedT n = flip div n' (sum [ d*rootT d | d <- facs n' ] + sum ([sum [ d*rootT d | d <- facs (n-j) ] * rootT j | j<- [2..n']])) where n' = pred n} in rootT 18
16:10:40 <lambdabot>   mueval-core: Prelude.read: no parse
16:10:40 <lambdabot>  mueval: ExitFailure 1
16:11:17 * BMeph preferred "thread killed" to this "no parse" message... :\
16:11:21 <BMeph> > let { facs = ap (filter . ((==0) .) . mod) (enumFromTo 1) ; rootT n = (map rootedT [0..]) !! n ; rootedT 0 = 0; rootedT 1 = 1; rootedT n = flip div n' (sum [ d*rootT d | d <- facs n' ] + sum ([sum [ d*rootT d | d <- facs (n-j) ] * rootT j | j<- [2..n']])) where n' = pred n} in rootT 16
16:11:26 <lambdabot>   mueval-core: Prelude.read: no parse
16:11:26 <lambdabot>  mueval: ExitFailure 1
16:15:52 <BMeph> nice; changing the (!!) to "genericIndex" makes it run must better - and faster! I wonder why...
16:17:21 <BMeph> > let { facs = ap (filter . ((==0) .) . mod) (enumFromTo 1) ; rootT = ((map rootedT [0..]) !!) ; rootedT 0 = 0; rootedT 1 = 1; rootedT n = flip div n' (sum [ d*rootT d | d <- facs n' ] + sum ([sum [ d*rootT d | d <- facs (n-j) ] * rootT j | j<- [2..n']])) where n' = pred n} in rootT 16
16:17:23 <lambdabot>   235381
16:17:41 <gwern> BMeph: patches welcome, if they don't break the testsuite
16:17:45 <BMeph> Oh, never mind; it's the eta reduction.
16:18:30 <BMeph> That's an interesting "point" (heh-heh) of improvement. ;)
16:18:58 <defun> what's a good irc channel of general operating system discussions (i.e. non-os-specific)?
16:19:43 <BMeph> defun: One where they discuss the OS' merits, instead of just saying "X rocks, Y sux"? ;p
16:20:18 <defun> BMeph: yes
16:20:18 <gwern> no such place
16:20:24 <defun> damn.
16:20:44 <BMeph> Not yet... :)
16:26:37 <defun> What used to be called parallel haskell is now built-into ghc, correct?
16:27:20 <gwern> defun: I believe so
16:27:35 <gwern> note that not all the parallel or distributed research got folded into ghc; like mobile haskell didn't
16:28:52 <BMeph> gwern: "mobile haskell"? I presume that's not haskell with a "Deep South" accent... ;)
16:29:12 <gwern> BMeph: nah. think closures/continuations serialized over the network
16:29:18 <gwern> was a ghc fork; dead now, of course
16:30:21 <defun> i see. thanks. btw, it seems that erlang focuses on concurrency/process and haskell focuses parallelism. Not that I am biases towards either, but why was the choice made to focus of parallelism? (I suppose I should also ask erlang-people why they focus of concurrency)
16:31:29 <dons> mm. haskell was originally all about concurrency
16:31:33 <gwern> defun: probably just the community focus; erlang was started at a telecom that needed process / machine distribution. haskell users have never really needed that, while they did want thread parallelism
16:31:53 <dons> i.e. we had concurrent haskell for 15 years before parallel haskell made it big.
16:32:09 <gwern> why does each continue in its vein? probably lack of demand and manpower; each is a very difficult task, after all
16:32:15 <dons> but perhaps: parallelism is about performance, and erlang's not been concerned with that as much as fault tolerance (hence process isolation is big in erlang)
16:32:43 <gwern> it's not like the ghc devs would reject patches adding mobile haskell features; it's just no one has done'em; I doubt the erlang devs would reject cool threading features either
16:32:51 <dons> i don't think it is fair to say haskell focus on parallelism over concurrency. it focuses on both more than fault tolerance in the erlang sence
16:32:54 <dons> sense.
16:33:12 <defun> dons: what does haskell offer as fault-tolerance mechanism?
16:33:17 <defun> types?
16:33:30 <gwern> how often would haskellers even use erlang-like features? it doesn't seem like very
16:33:34 <dons> exception handling and asynchronous exceptions, a la erlang.
16:33:41 <dons> but without the process monitoring libraries of OTP
16:33:50 <gwern> even most happs users are running on single boxes
16:34:02 <dons> what do you mean 'erlang-like' ?
16:34:13 <defun> what is OTP?
16:34:30 <dons> large library for erlang to do with fault tolerance
16:34:44 <defun> I see.
16:34:45 <gwern> dons: I'd say what I think of as being erlang-style is multiple nodes on a network, monitoring each other, and swapping around code to run at other nodes
16:34:52 <BMeph> @go OTP
16:34:53 <lambdabot> http://www.urbandictionary.com/define.php?term=otp
16:34:53 <lambdabot> Title: Urban Dictionary: otp
16:34:58 <dons> oh, distribution.
16:35:06 <dons> gwern: not so sure about the 'code swapping'...
16:35:15 <gwern> dons: you'll admit, that's not something haskell currently does
16:35:20 <dons> yes, certainly there is less work on distributed haskell
16:35:40 <dons> but look how confused the conversation is. erlang == concurrency? distribution? fault tolerance? but not parallelism?
16:35:54 <dons> too much branding, not enough technical detail about what people are actually seeking.
16:36:11 <gwern> dons: mm. my understanding was that erlang was interpreted, and the messages nodes sent didn't have to be dumb data but could be functions/code
16:36:13 <BMeph> That would be interesting, though - a module that lets you use MVars like Handles.
16:36:17 <dons> if you want to do distributed systems, erlang has good library and language support for that.
16:36:36 <dons> if you want to do multicore concurrency, haskell has very good support, and more than just message passing.
16:36:45 <gwern> (not that interpretation is necessarily required for that, but it makes it much easier)
16:36:52 <dons> if you want to make programs faster via parallelism, haskell has more support for that
16:37:00 <dons> erlang is compiled also, gwern
16:37:06 <dons> the runtime does some degree of hotswapping
16:37:14 <pikhq> gwern: Erlang is designed with hotswapping of code in mind.
16:37:29 <dons> gwern: i.e. plugins-like runtime code replacement, as we do in haskell
16:37:35 <vav> dons: Any comment re: "<Athas> Has anyone here experience with using queryFont from the X11 library?  It doesn't look like it's usable if you can't query the value for null-ness."? (FontStruct constructor is not exported) -- I'm curious about how that should be handled, too.
16:37:37 <dons> but more thoroughly
16:37:48 <dons> vav: i've not used it
16:38:12 <pikhq> Oddly, my main complaint with Erlang is that its syntax doesn't look very nice.
16:38:26 <defun> pikhq: completely agree.
16:38:27 <pikhq> I can find no other (major) faults.
16:38:44 <dons> the erlang wikipedia article is much clearer than the haskell article
16:38:55 <BMeph> Hm... "newtype Ptr a = MaybeT IORef a"? ;)
16:38:58 <dons> gwern: what would prevent someone from rewriting the haskell wikipedia article?
16:39:08 <gwern> dons: their rewrite being crap
16:39:17 <gwern> among many other possibilities
16:39:22 <dons> but you could in theory rewrite the /entire article/ ?
16:39:40 <dons> to actually talk about the key points of the language and toolchain, a la the erlang entry
16:39:46 <dons> rather than myths and toys, as it does now.
16:39:54 <dons> and ancient systems :/
16:40:02 <gwern> dons: sure, but there's an etiquette to it
16:40:18 <gwern> assuming there are multiple active other contributors to it
16:40:31 <Twey> pikhq: I don't care about the syntax nearly so much as the weird-ass typesystem, or lack thereof
16:40:33 <gwern> (no one really cares if you do a major rewrite of an article only you edit, obviously)
16:41:00 <Twey> Also, the distinction it makes between built-in functions (‘BIFs’) and everything else
16:41:16 <pikhq> Twey: Haskell seems to be one of a very few languages that have a nice typesystem.
16:41:27 <Twey> It cries out for type-level purity checking like Haskell's, but lacks it
16:41:50 <Twey> So you can only use runtime-provided functions in a load of contexts where purity is required.  You can't even tell it that a function is pure.
16:42:00 <dons> the libraries section is particularly poor. the language features section is superficial
16:42:02 <pikhq> Wait, really?
16:42:05 <pikhq> Urrrgh.
16:42:13 <dons> we could link to the many wikipedia articles about things like GADts , typeclasses etc.
16:42:19 <Twey> pikhq: Yeah, but most languages at least distinguish between a string and a list of ints.
16:42:27 <Twey> Rather than guessing based on the values of those ints.
16:42:52 <dons> gwern: the current article has the feel of 'this is a big complicated language, i can't hope to cover it coherently'
16:42:56 <dons> so no one has tried
16:42:57 <pikhq> Twey: Even C does that! (though it doesn't distinguish between a string and an array of characters. :P)
16:43:13 <gwern> dons: haskell on the surface is a big complicated language
16:43:15 <Twey> Aye :)  It's the int/character distinction that counts, though.
16:43:20 <desp> @src intersperse
16:43:20 <lambdabot> intersperse _   []     = []
16:43:20 <lambdabot> intersperse _   [x]    = [x]
16:43:20 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
16:43:34 <dons> gwern: right, and our wikipedia article makes it look like no one can be bothered trying to explain it
16:44:11 <gwern> a lot of that text is pretty old
16:44:18 <gwern> I think most of it is easily pre 08
16:44:24 <Twey> I really like the concept of Erlang, and in a way it succeeds majorly in its goal, but those two things (admittedly, coupled with the syntax, which is rather awkward to edit) really spoil it for me.
16:45:22 <hamishmack> Anyone got a windows machine they would like to try Leksah on?
16:46:46 <BMeph> defun: Sorry, that didn't help; OTP = "Open Telecom Platform"
16:47:23 <Twey> Heh, when I was learning Erlang, it took me ages to figure out what the OTP *was*
16:48:13 <desp> Twey: I don't really see what's the problem with treating characters as integers.
16:48:36 <ahnurmi> i think it's very lucky that erlang had numbers instead of ascii or latin-1
16:48:42 <desp> Yes.
16:49:00 <Twey> desp: The problem is when the time comes to define character-specific functions
16:49:04 <BMeph> hamishmack: You bet! :)
16:49:13 <desp> Twey: what's the problem?
16:49:18 <ahnurmi> after all, a haskell character isn't always a character
16:49:28 <copumpkin> why not?
16:49:39 <ahnurmi> it can be a combining character, which really isn't a character
16:49:39 <hamishmack> BMeph: I have made an installer
16:49:40 <Twey> I don't have a problem with handling chars internally as codepoints (heck, what else could you do?) but they need to be at least tagged so you can tell what's intended to be a character and what's not
16:49:59 <hamishmack> http://leksah.org/Leksah-0.6.1.0.exe
16:50:06 <Twey> Erlang does have numbers instead of ASCII or Latin-1, but its guessing algorithms assume 128-bit ASCII
16:50:08 <desp> Twey: if you're passing incorrect data to your character-processing function, then that's another type of problem.
16:50:14 <BMeph> hamishmack: Clicking...
16:50:24 <desp> Twey: you mean 7-bit ASCII, that is, ASCII.
16:50:27 <Twey> (i.e. a string is a list of ints >= 0 and < 128)
16:50:32 <Twey> Er, yes.  Heh.
16:50:39 <Twey> Sorry, brain-fart.
16:50:44 <desp> No problem. ;)
16:51:06 <pikhq> Twey: Bu,but a String is a [Char]!
16:51:13 <desp> Anyway, I agree with your comments about the oddness of the type system, which coming from a Haskell perspective is like rock-climbing without safety ropes.
16:51:15 <Twey> pikhq: But a Char is not an Int.
16:51:21 <pikhq> I know!
16:51:39 <Twey> It might be *internally*, and that's a sane way to do it, but we *can* tell them apart and decide what the intention was of the person who created the datum.
16:52:00 <Twey> desp: I was actually coming from a Python perspective
16:52:04 <pikhq> But not in Erlang.
16:52:13 <Twey> That's why I switched to Haskell.
16:52:16 <Twey> pikhq: Right.
16:52:20 <pikhq> desp: From a Haskell perspective, most type systems are like that.
16:52:54 <pikhq> (the type system, such as it is, of the untyped lambda calculus is not like that... Any other examples?)
16:53:37 <BMeph> hamishmack: Ooh, Shiny! "Collecting metadata..." :)
16:55:27 <desp> Twey: if your function cannot handle ints larger than 127, then you can add a guard...
16:56:09 <desp> pikhq: Qi
16:56:21 <desp> pikhq: I need to learn it some day.
16:57:19 <Twey> desp: To do what?
16:57:28 <pikhq> desp: I need to look it up.
16:57:45 <copumpkin> f :: {Int n, n < 128} => n -> n
16:57:54 <copumpkin> really useful function
16:58:26 <desp> Twey: to SAVE THE WORLD!!!1
16:59:39 <burp> um, this is possible?
16:59:45 <burp> is that an extension?
17:00:48 <pikhq> :t f :: {Int n, n < 128] => n -> n
17:00:49 <lambdabot> parse error on input `{'
17:00:54 <pikhq> :t f :: {Int n, n < 128} => n -> n
17:00:56 <lambdabot> parse error on input `{'
17:01:08 <pikhq> If so, poor \bot doesn't know it.
17:03:45 <BMeph> hamishmack: Nice - thank you! It looks seksay! GG on the pre-packaging. :)
17:05:55 <BMeph> Say, does this look like a non-confusing operator: " p -?> (t, f) = \a -> if (p a) then (t a) else (f a)" ?
17:06:19 <idnar> why the tuple?
17:06:36 <Twey> Why the lambda?
17:06:42 <Twey> Why the brackets?
17:06:53 <pikhq> Why anything?
17:07:05 <Twey> p -?> (t, f) a = if p a then t a else f a
17:07:08 <Twey> Er
17:07:15 <Twey> (p -?> (t, f)) a = if p a then t a else f a
17:07:28 <Twey> Or guards
17:07:54 <idnar> p -?> t f a = if p a then t a else f a
17:08:09 <Twey> That's the non-tuple version
17:08:24 <idnar> the lambda makes the usage a little more obvious, I suppose
17:08:38 <Twey> Oh, I think you still need brackets
17:08:47 <BMeph> I just wanted to cut down on any other meaning questions besides those given. :)
17:08:49 <Twey> (p -?> t f) a = if p a then t a else f a
17:09:35 <Twey> kiris has a function similar to this in his HigherOrder library
17:09:36 <idnar> Twey: those parens can't be right
17:09:50 <idnar> (p -?> t) f a = ... maybe?
17:09:50 <Twey> idnar: No, they're not, sorry :)
17:09:58 <Twey> Yeah, that's what I meant
17:10:12 <Twey> Although I don't see why yours wouldn't work, now
17:10:16 <Twey> That's how . is defined, though...
17:10:18 <Twey> @src (.)
17:10:19 <lambdabot> (f . g) x = f (g x)
17:10:42 <Twey> You can't pattern-match on functions, after all
17:11:15 <Twey> Yeah, parse error
17:11:46 <Twey> You need the brackets around the operator for some reason
17:13:11 <Twey> Also, I'd prefer to rename the variables to comply with convention
17:13:30 <Twey> (p -?> y) n x = if p x then y x else n x
17:13:45 <Twey> kiris' was called ‘bool’ by analogy with ‘maybe’
17:13:53 <Twey> :t maybe
17:13:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:14:22 <BMeph> Twey: Well, if it's called 'bool', then it isn't an operator, is it? ;)
17:14:59 <BMeph> Hmm, I guess that's another qualifier:
17:15:06 <Twey> bool n y x = if x then n x else y x
17:15:16 <Twey> BMeph: Sure, if you put it in backticks.  :)
17:15:18 <BMeph> 1) I just wanted to cut down on any other meaning questions besides those given; 2) I want it in operator form.
17:16:15 <BMeph> And shouldn't that be "bool n y x = if x then y x else n x"? :)
17:17:46 <Twey> Yes
17:17:54 <Twey> I need food... and sleep.  >.<
17:18:09 <Twey> Erm
17:18:27 <Twey> Oh yes, other point: there's no point in providing p x, because you can compose it in
17:18:29 <BMeph> hamishmack: Just one quibble: "File does not exist /home/jutaro/Develop/leksah/data/welcome.txt"
17:18:34 <Twey> (so long as x is the last argument)
17:21:58 <BMeph> Twey: Well, I have one that's just "if p then y else n", and this one is just my "liftA3"'d version of it. :)
17:28:31 <copumpkin> > 5 `max` 6
17:28:33 <lambdabot>   6
17:29:56 <hamishmack> BMeph: Thanks for testing that.
17:32:06 * pikhq has been reading up on Parsec.
17:32:17 <pikhq> I think I adore it.
17:33:37 <BMeph> hamishmack: My pleasure - literally! ;)
17:50:01 <michaelfeathers> Does anyone use unfold for anything?  I can't think of where I would use it.
17:54:07 <gwern> michaelfeathers: you just need to think harder
17:55:11 <michaelfeathers> gwern: That's not working. :)
17:55:24 <gwern> then grep source repos looking for examples
17:55:33 <gwern> there's one in yi
17:56:21 <michaelfeathers> Maybe these guys know: http://portal.acm.org/citation.cfm?id=289423.289455
17:59:47 <dons> gwern: ok. quick modernisation of the language features section, http://en.wikipedia.org/wiki/Haskell_%28programming_language%29  and added conferences.
18:00:20 <dons> the article has no narrative thread though, sadly.
18:01:54 <gwern> michaelfeathers: this is what I get for local grep http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7805#a7805
18:02:04 <dons> gwern: a haskell porthole might be nice. there are lots of articles about haskell things throughout wikipedia, but they're not tagged as such
18:02:15 <gwern> portal, you mean?
18:02:30 <dons> yes
18:02:49 <dons> but a small, circular hole in every page would also be good
18:03:44 <gwern> michaelfeathers: I get the impression unfold is more important as an idea than a specific function
18:04:48 <dons> michaelfeathers: it is foundational to a number of optimizations based on identifying recursive functions
18:05:14 <sjanssen> michaelfeathers: unfoldr is useful for building lists of all sorts
18:06:10 <McManiaC> i know fold, what is unfold?
18:06:38 <gwern> michaelfeathers: on the other hand, unfoldr gets more hits: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7805#a7806
18:06:42 <sjanssen> McManiaC: fold deconstructs, unfold constructs
18:06:43 <gwern> @hoogle unfold
18:06:44 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
18:06:44 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
18:06:44 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
18:06:47 <gwern> @hoogle unfoldr
18:06:48 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:06:48 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
18:06:48 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
18:08:35 <sjanssen> > unfoldr (\n -> if n == 0 then Nothing else Just ('a', n - 1)) 10 -- replicate 'a' 10
18:08:37 <lambdabot>   "aaaaaaaaaa"
18:17:09 * byorgey makes blackberry-blueberry-lambdaberry jam
18:18:26 <gwern> dons: btw, you know you don't need underscores or %28s in wikilinks right?
18:19:16 <gwern> dons: also, what's the logic behind the syntax extension section? you start off with the least important one; I wouldn't even mention that or postfix operators
18:19:47 <Phyx-> Hello
18:19:55 <mae_phone> gwern, how's it going? Make it to hack phi?
18:20:01 <benmachine> hello
18:20:26 * gwern ponders my answer. if I say yes, will mae go around asking everyone 'do *you* know who gwern galt is?'
18:20:28 <Phyx-> does anyone know, when compiling a shared lib, where does ghc store the function closures? they don't seem to be in the generated .a file
18:21:10 <gwern> dons: the related languages section - think languages that can compile into haskell count? eg. I'm thinking of coq here
18:28:27 <a_coder> why does foldr1 (const id) give you the last element of a list?
18:29:30 <dontbelieve> hi do anyone know where I can get an example of a working haskell chat server?
18:31:15 <gwern> > foldr1 (const id) [x, y, z, b]
18:31:17 <lambdabot>   b
18:31:29 <gwern> > foldr1 a [x, y, z, b]
18:31:31 <lambdabot>   Couldn't match expected type `a -> a -> a'
18:31:37 <gwern> arrgh
18:31:42 <a_coder> how does it work?
18:31:47 <gwern> this simplereflect stuff never quite seems to work right
18:32:35 <a_coder> const :: a -> b -> a; id :: a -> a; (const id) :: b -> a -> a.. how does that work?
18:32:46 <gwern> > const id "foo"
18:32:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:32:47 <lambdabot>    arising from a use of `...
18:33:03 <thoughtpolice> > const id "foo" $ 4
18:33:04 <lambdabot>   4
18:33:21 <Vanadium> That $ was not strictly necessary, was it
18:33:22 <byorgey> a_coder: when const is applied to id, it has type  (a -> a) -> b -> (a -> a)
18:33:22 <thoughtpolice> const id will just return the identity function regardless of what you give it
18:33:27 <Saizan> i got 18 votes on arch on a package of mine, so someone _is_ using it!
18:33:29 <gwern> a_coder: const ignores its second argument; so what happens is you get something like 'id . id . id . id . last-element'
18:33:32 <thoughtpolice> Vanadium: no
18:33:33 <byorgey> a_coder: so 'const id' has type  b -> (a -> a)
18:33:42 <byorgey> which can be written without the parens as  b -> a -> a
18:33:44 <gwern> > foldr f z [1,2,3]
18:33:46 <lambdabot>   f 1 (f 2 (f 3 z))
18:34:01 <gwern> > let f = (const id) foldr f z [1,2,3]
18:34:03 <lambdabot>   not an expression: `let f = (const id) foldr f z [1,2,3]'
18:34:06 <gwern> > let f = (const id) in foldr f z [1,2,3]
18:34:08 <lambdabot>   z
18:34:14 <Vanadium> Could ($) be defined as ($) = id?
18:34:16 <gwern> hm.
18:34:30 <benmachine> @type ($)
18:34:31 <lambdabot> forall a b. (a -> b) -> a -> b
18:34:31 <gwern> > foldr1 f z [1,2,3]
18:34:33 <byorgey> Vanadium: yes
18:34:33 <lambdabot>   Couldn't match expected type `[a]'
18:34:34 <a_coder> i'm confused..
18:34:39 <gwern> > foldr1 z [1,2,3]
18:34:41 <lambdabot>   Couldn't match expected type `a -> a -> a'
18:34:54 <gwern> interesting. maybe simplereflect doesn't handle foldr1
18:34:59 <benmachine> I guess that makes sense
18:35:04 <vav> > foldr1 f [a,b,c] :: Expr
18:35:06 <lambdabot>   f a (f b c)
18:35:40 <gwern> a_coder: anyway, you see what foldr1 produces, right? now substitute for f, (const id)
18:36:05 <gwern> so you get, '(const id) a ((const id) b c)'
18:36:54 <gwern> starting from the inside, b gets ignored, and c returned; then the outermost const id ignores a, and returns the second argument - c
18:37:48 <a_coder> ok
18:38:05 <benmachine> const id == flip const?
18:38:41 <gwern> @check \x -> const id x == flip const x
18:38:43 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
18:38:43 <lambdabot>    arising from a use of `GHC.Cla...
18:39:24 <benmachine> @check \x y -> const id x y == flip const x y
18:39:25 <lambdabot>   "OK, passed 500 tests."
18:39:45 <a_coder> > foldr1 (flip const) [1,2,3]
18:39:46 * benmachine isn't entirely confident in @check
18:39:47 <lambdabot>   3
18:40:36 <gwern> benmachine: how can you not trust quickcheck?
18:41:06 <a_coder> but why does (const id) equal (flip const)?
18:41:07 <benmachine> hmm
18:41:15 <Axman6> there's a goot chance it defaulted to () there
18:41:25 <benmachine> @check \a -> typeOf a == typeOf ()
18:41:26 <lambdabot>   "OK, passed 500 tests."
18:41:32 <benmachine> ^ this kind of bothers me :P
18:41:58 <Axman6> @check \x y -> const id x y == flip const (x :: Double) (y :: Int)
18:41:59 <lambdabot>   "OK, passed 500 tests."
18:42:00 <gwern> weakstomached knave!
19:06:23 <mmmulani> what does a ! in the function declaration line do?
19:08:15 <Petrosian> mmmulani: Got an example? It has a few meanings
19:08:32 <Petrosian> (depending on the context)
19:08:43 <mmmulani> Petrosian: http://www.haskell.org/haskellwiki/Prime_numbers#Bitwise_prime_sieve
19:09:13 <Axman6> mmmulani: it's a strictness annotation
19:09:14 <Petrosian> mmmulani: It means the arguments are strict
19:09:27 <Axman6> f !x = g x == f x = x `seq` g x
19:09:41 <Phyx-> Is it possible to generically convert from and to two isomorphic datatypes? The only difficult I see myself is when there are multiple constructors in the two datatypes with the same types, i'd have to rely on constructor index then
19:09:50 <Axman6> very useful for tight looping things, or where you might blow the stack
19:10:16 <mmmulani> is it the ($!) entry in the Prelude?
19:10:25 <Petrosian> mmmulani: http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html Might be a useful read
19:10:56 <mmmulani> ahhh
19:10:58 <Axman6> i's not the same as $!
19:11:14 <copumpkin> it's related
19:11:43 <pikhq> @src ($!)
19:11:44 <lambdabot> f $! x = x `seq` f x
19:12:01 <mmmulani> can functions with strict parameters be used in ghci?
19:12:17 <pikhq> mmmulani: Why couldn't they?
19:12:35 <mmmulani> pikhq: it seems to not be working for me
19:12:42 <mmmulani> I tried "let sqr !a = a^2"
19:12:45 <Petrosian> mmmulani: You need to :set -XBangPatterns
19:12:46 <mmmulani> and then sqr was not accessible
19:12:49 <mmmulani> ahhhh
19:13:00 <Petrosian> It's an extension, not Haskell98
19:13:29 <ray> there's no reason to do it for that function, because it's strict either way
19:13:44 <mmmulani> Petrosian: thanks
19:13:55 <wgsilkie> !help
19:14:03 <wgsilkie> How do I use lambdabot?
19:14:10 <idnar> ray: only if (^) is strict :P
19:14:23 <Petrosian> wgsilkie: What do you want to use it for?
19:14:34 <Petrosian> > 1 + 1
19:14:36 <lambdabot>   2
19:14:38 <ray> idnar: i am making the assumption that it is really exponentiation, like it looks like
19:14:59 <idnar> ray: there are Num instances with lazy operators
19:15:16 <wgsilkie> Petrosian: I don't even know what it can do?
19:15:45 <Petrosian> wgsilkie: A lot of stuff
19:15:52 <Petrosian> Evaluate expressions
19:15:55 <Axman6> wgsilkie: it can evaluate haskell, tell you the types of things, tells you quotes, send people messages
19:15:58 <Axman6> and much more
19:16:03 <Axman6> @quote lambdabot
19:16:03 <lambdabot> lambdabot says: fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
19:16:15 <wgsilkie> Eeek!
19:16:23 <Axman6> wtf
19:16:24 <Axman6> @quote lambdabot
19:16:25 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
19:16:37 <wgsilkie> I'll just watch others use it for now.
19:16:45 <wgsilkie> Oh, I see.
19:16:49 <meanburrito920_> :)
19:16:59 <Petrosian> wgsilkie: You can use it through private message too
19:17:08 <Petrosian> If you'd rather use it in private ;)
19:17:11 <ray> > let 2+2=5 in 2+2 -- lambdabot loves big brother
19:17:13 <lambdabot>   5
19:17:25 <Axman6> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
19:17:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:17:31 <wgsilkie> Scary.
19:17:59 <wgsilkie> How would I define a function that takes the firsr n items from a list (does something with them) and calls itself on the rest of the list?
19:18:16 <wgsilkie> And stops when the list is less than n.
19:18:21 <Axman6> > let fibs = 1:1:zipWith (\!x !y -> x+y) fibs (tail fibs) in fibs !! 100000
19:18:22 <lambdabot>   <no location info>: parse error on input `->'
19:18:31 <Axman6> > let fibs = 1:1:zipWith (\!x y -> x+y) fibs (tail fibs) in fibs !! 100000
19:18:32 <lambdabot>   <no location info>: parse error on input `->'
19:18:34 <Axman6> :(
19:18:35 <wgsilkie> (It would call itself with n, so that stays the same.)
19:18:55 <Axman6> > let fibs = 1:1:zipWith (\x y -> x `seq` y `seq` x+y) fibs (tail fibs) in fibs !! 100000
19:18:59 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
19:19:02 <Axman6> > let fibs = 1:1:zipWith (\x y -> x `seq` y `seq` x+y) fibs (tail fibs) in fibs !! 10000000
19:19:07 <lambdabot>   mueval-core: Prelude.read: no parse
19:19:07 <lambdabot>  mueval: ExitFailure 1
19:19:10 <Axman6> > let fibs = 1:1:zipWith (\x y -> x `seq` y `seq` x+y) fibs (tail fibs) in fibs !! 1000000
19:19:13 <lambdabot>   * Exception: stack overflow
19:19:18 <Axman6> heh
19:19:35 * Axman6 has achieved all three lambdabot return states :o
19:19:39 <Petrosian> wgsilkie: You might want to start by looking at the `take' function
19:19:46 <wgsilkie> Petrosian: I did.
19:19:50 <Petrosian> > take 5 [1..]
19:19:51 <lambdabot>   [1,2,3,4,5]
19:19:56 <wgsilkie> How do I ask lambdabot about a function?
19:20:11 <Axman6> :t map
19:20:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:20:14 <ray> wgsilkie: something like (map f) . (chunk n)
19:20:14 <mmmulani> wgsilkie: sounds like you want iterate
19:20:15 <Petrosian> wgsilkie: @src will show its source, @ty its type
19:20:15 <Axman6> @src map
19:20:16 <lambdabot> map _ []     = []
19:20:16 <lambdabot> map f (x:xs) = f x : map f xs
19:20:43 <benmachine> note that @src is illustrative and not necessarily what it is Really Doing
19:20:59 <wgsilkie> @src chunk
19:20:59 <lambdabot> Source not found. Are you on drugs?
19:21:11 <mmmulani> @src iterate
19:21:12 <lambdabot> iterate f x =  x : iterate f (f x)
19:21:14 <wgsilkie> Hmm...
19:21:22 <ray> chunk from the somethingorother package
19:21:28 <mmmulani> @src iterateUntil
19:21:29 <lambdabot> Source not found. Just try something else.
19:21:29 <Petrosian> Also, @src is hand filled I believe, so not complete
19:21:37 <benmachine> yeah
19:21:37 <ray> @hackage split
19:21:38 <Axman6> @hoogle iterate
19:21:38 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
19:21:38 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
19:21:38 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
19:21:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
19:21:44 <ray> from that package
19:21:46 <benmachine> it's just a text file
19:21:48 <benmachine> I saw it :o
19:22:03 * wgsilkie looks up map in his Haskell docs.
19:22:15 <benmachine> > map f [a,b,c]
19:22:17 <lambdabot>   Add a type signature
19:22:21 <benmachine> fgsfds
19:22:22 <Petrosian> I'm not sure I'd use iterate for that either... seems like an odd way to go about it
19:22:23 <Badger> hurr
19:22:25 <benmachine> > map f [a,b,c] :: [Expr]
19:22:27 <lambdabot>   [f a,f b,f c]
19:23:20 <wgsilkie> @src map
19:23:20 <lambdabot> map _ []     = []
19:23:21 <lambdabot> map f (x:xs) = f x : map f xs
19:23:55 <wgsilkie> So map takes a function and a list, and runs the function on every item in that list?
19:24:08 <Petrosian> Correct
19:24:19 <wgsilkie> What does . do?
19:24:25 <Petrosian> It's function composition
19:24:27 <Petrosian> @src (.)
19:24:27 <lambdabot> (f . g) x = f (g x)
19:24:29 <wgsilkie> That one really confused me.
19:24:47 <wgsilkie> @src ($)
19:24:47 <lambdabot> f $ x = f x
19:25:01 * wgsilkie also gets $ and . mixed up.
19:25:03 <Phyx-> *sigh*
19:25:20 <Rotaerk> hmm, need some design advice
19:26:44 <wgsilkie> What's the difference between f $ g x and (f . g) x?
19:26:53 <Axman6> there isn't one
19:27:14 <Axman6> > (f $ g x, (f . g) x)
19:27:15 <lambdabot>   Add a type signature
19:27:23 <Axman6> > (f $ g x, (f . g) x) :: (Expr, Expr)
19:27:25 <lambdabot>   Add a type signature
19:27:31 <Axman6> -_-
19:27:34 <benmachine> :P
19:27:47 <ray> @vixen Add a type signature
19:27:49 <lambdabot> *giggles*
19:27:58 <Rotaerk> I'm building a tactical RPG and I'm mostly used to OO design, but I'm interested in trying an FP design approach (although I haven't learned much more than the basics of FP)
19:28:00 <wgsilkie> > take $ reverse [3,5,7]
19:28:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:28:13 <wgsilkie> > reverse [3,5,7]
19:28:15 <lambdabot>   [7,5,3]
19:28:30 <pikhq> :t take
19:28:32 <lambdabot> forall a. Int -> [a] -> [a]
19:28:36 <Petrosian> wgsilkie: `take' needs another parameter; the number of elements to take
19:28:37 <ray> note the Int
19:28:40 <Petrosian> > take 4 [1..4]
19:28:41 <lambdabot>   [1,2,3,4]
19:28:50 <wgsilkie> > reverse take 2 [3,5,7,11]
19:28:51 <lambdabot>   Couldn't match expected type `[a]'
19:28:57 <wgsilkie> > reverse $ take 2 [3,5,7,11]
19:28:59 <lambdabot>   [5,3]
19:29:06 <Rotaerk> the entire state of a battle, including the grid layout and the arrangement of combatants on it, as well as the statuses of the combatants themselves, is immutable
19:29:15 <wgsilkie> > reverse . take 2 [3,5,7,11]
19:29:16 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:29:32 <benmachine> > reverse . take 2 $ [3,5,7,11]
19:29:34 <lambdabot>   [5,3]
19:29:37 <wgsilkie> > reverse . tail [3,5,7,11]
19:29:39 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:29:42 <ahnurmi> i believe it's the precedences/associativity that make (.) and ($) confusing
19:29:47 <ray> function application has
19:29:51 <ray> HIGHEST PRECEDENCE
19:29:51 <wgsilkie> > tail [3,5,7,11]
19:29:52 <pikhq> > reverse . tail $ [3,5,7,11]
19:29:53 <lambdabot>   [5,7,11]
19:29:53 <benmachine> wgsilkie: the thing to remember is that working with . produces a function
19:29:54 <lambdabot>   [11,7,5]
19:29:59 <ray> HIGHEST PRECEDENCE IN GIGANTIC LETTERS
19:30:01 <benmachine> whereas $ applies a function
19:30:12 <benmachine> so if you want a value, you need a $ somewhere (or brackets)
19:30:17 * wgsilkie gets it now.
19:30:18 <Rotaerk> the combatants only exist for the lifetime of the battle, but they are tied to *characters* that persist after the battle.  combatants have status (current health, effects, etc), but characters have attributes (exp, strength, stamina, etc)
19:30:23 <ray> if you were function application, and you started a band, it would be namede
19:30:23 <benmachine> if you want a function, usually you don't want $
19:30:26 <ray> HIGHEST PRECEDENCE
19:30:42 <Axman6> except record syntax
19:30:53 <ray> if you were function application, and you were being seated at a banquet, you would have
19:30:55 <ray> HIGHEST PRECEDENCE
19:30:58 * wgsilkie goes back to his terminal.
19:31:00 <Rotaerk> as such, the combatants need to somehow reference the characters... but because of immutability of these characters, any changes will result in a new object for the character... so I can't reference directly
19:32:22 <Rotaerk_> I guess my question is how do you guys deal with identity in the face of immutability
19:32:26 <Rotaerk_> just use ID's like with relational DB's?
19:32:47 <Rotaerk_> and perhaps a map from ID to state
19:35:26 <michaelfeathers> http://unfoldr.com/
19:36:03 <pikhq> Rotaerk_: Monads.
19:36:32 <Rotaerk_> hmm, k, guess I should research those then
19:36:36 <ray> rotaerk_: be sure not to let your oo design experience cause you to overthink things
19:37:11 <Rotaerk_> I never understood "overthink"
19:37:16 <ray> :)
19:37:57 <pikhq> Rotaerk, have you ever used a factory of factories?
19:38:02 <ray> when you're working with mutable state, you don't get worried because each member variable or whatever can only hold one value at a time, right?
19:38:03 <wgsilkie> @src map
19:38:04 <lambdabot> map _ []     = []
19:38:04 <lambdabot> map f (x:xs) = f x : map f xs
19:38:05 <pikhq> If so, you overthink things a lot. :P
19:38:35 <Rotaerk_> pikhq, haven't really needed a factory before *shrug*
19:38:45 <pikhq> wgsilkie: The source is not going to change when you look away from it.
19:39:00 <ray> it will if i have my day
19:39:03 <wgsilkie> Is there a variation on map that's like this: map f (x:xs) = f (x:xs) : map xs.
19:39:26 <ray> occurs check
19:39:43 <ray> (is the error you would get if you tried to write that)
19:39:51 <benmachine> wgsilkie: what type would that function have?
19:39:59 <Rotaerk_> ray, not sure why that would cause concern
19:40:16 <benmachine> mm actually it's perfectly fine
19:40:30 <benmachine> so long as f is [a] -> a or something
19:40:59 <wgsilkie> benmachine: OK.
19:41:34 <ray> actually, you'd get regular old type errors before you got an occurs check
19:41:43 <benmachine> uhm, in answer to your question it doesn't ring any bells
19:41:43 <Rotaerk_> hmm I might just do my first version using a mixture of immutability and mutability for now
19:41:43 <pikhq> > map (head . (+1)) (tails [1..])
19:41:43 <wgsilkie> Is there a more concise way to get that than rewriting map?
19:41:50 <lambdabot>   No instance for (GHC.Num.Num [a])
19:41:50 <lambdabot>    arising from the literal `1' at <inter...
19:41:57 <Rotaerk_> I don't want to go off on a tangent again studying FP in greater depth until i've made something
19:42:03 <pikhq> Clearly I misthought.
19:42:22 <pikhq> Rotaerk_: Monads are likely the answer here.
19:42:26 <ray> rotaerk_: well, you're going "immutable" like there's no way to update things ever
19:42:31 <benmachine> map ((+1) . head) (tails [1..])
19:42:38 <benmachine> er
19:42:40 <benmachine> > map ((+1) . head) (tails [1..])
19:42:41 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:42:48 <benmachine> um
19:42:59 <pikhq> Um.
19:42:59 <benmachine> that's boring :P
19:43:03 <wgsilkie> benmachine: What'd that do?
19:43:11 <benmachine> wgsilkie: I'm not absolutely sure
19:43:23 <shepheb> it might help to not that map head tails == id
19:43:27 <pikhq> I'm not entirely sure what I was writing, either.
19:43:27 <shepheb> note*
19:43:29 <copumpkin> > map (take 3) (tails [1..])
19:43:31 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
19:43:38 <benmachine> pikhq: I think it was the right sort of thing
19:43:47 <shepheb> oh, except for the error at the end >_>
19:43:51 <pikhq> It had something to do with wgsilkie's question.
19:44:04 <pikhq> benmachine: Bad example, though.
19:44:06 <wgsilkie> @src tails
19:44:06 <lambdabot> tails []         = [[]]
19:44:07 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
19:44:18 <benmachine> > tails [1,2,3,4]
19:44:19 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
19:44:34 <wgsilkie> Ah.
19:44:43 <vav> Rotaerk if you haven't seen it yet http://cale.yi.org/index.php/A_look_at_OO_from_Haskell might be relavent
19:44:48 <Rotaerk_> ray, well the way I had planned is... actions performed by characters are transforms on the battle state.  e.g. for "walk", you pass in the current state, and it returns a new one representing the post-movement position of the character
19:45:03 <wgsilkie> > map (sum $ take 3) (tails 1..20)
19:45:05 <lambdabot>   <no location info>: parse error on input `..'
19:45:12 <wgsilkie> > map (sum $ take 3) (tails [1..20])
19:45:13 <lambdabot>   Couldn't match expected type `[a]'
19:45:17 <Axman6> @check \xs -> length (tails xs) >= 1
19:45:18 <lambdabot>   "OK, passed 500 tests."
19:45:19 <pikhq> Rotaerk_: I know I've said this a lot, but have you considered a monad?
19:45:25 <copumpkin> > map (sum . take 3) (tails [1..20])
19:45:27 <lambdabot>   [6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,39,20,0]
19:45:44 <ray> rotaerk_: so if you know you can update things, what's the problem with updating other things? :)
19:45:50 <ray> and it's true, you want a monad
19:45:51 <wgsilkie> Oh, yeah... duh.
19:46:59 <Rotaerk_> pikhq, thanks :P I've got that, however understanding monads is going to require taking a detour from coding and learning about them, which is why I'm considering just using mutability for now as my means of establishing object identity (and then replace later with monads once I understand em)
19:47:22 <benmachine> Rotaerk_: monads now monads now
19:47:23 <benmachine> :P
19:47:33 <wgsilkie> How do I get tails in GHCI?
19:47:36 <benmachine> they're not actually that hard
19:47:39 <benmachine> @index tails
19:47:39 <lambdabot> Data.List
19:47:54 <pikhq> Rotaerk_: Monads aren't exceptionally hard, they're just deep and insightful.
19:47:54 <benmachine> import Data.List
19:47:58 <Rotaerk_> ray, it's not a question of updating but rather, making sure I can *identify* the pre-changed and post-change object in the same way
19:48:02 <wgsilkie> benmachine: Thanks!
19:48:02 <SamB> pikhq: are they, now?
19:48:10 <SamB> pikhq: well, I mean, they're pretty handy ...
19:48:13 <pikhq> And they are essential to grokking commonly used Haskell.
19:48:18 <ray> it's not any different
19:48:24 <SamB> you've probably been wanting them almost as long as you've been programming
19:48:40 <SamB> but are they really that deep?
19:48:43 <ray> you don't worry about accidentally using the state from 3 turns ago, so why worry about using a character sheet from 3 battles ago
19:48:53 <pikhq> SamB: Deep in the way a zen koan is deep.
19:49:01 <SamB> maybe!
19:49:14 <SamB> but not nearly as head-explodey as continuations, that's for sure!
19:49:31 <Rotaerk_> ray, hmm true
19:49:33 <ray> and yes, monads
19:50:04 <ray> do not believe the hype
19:50:23 <goomba> no, catch the fever
19:51:25 <ray> of all the things that are hard to understand in the world, monads rank somewhere in between how to use vending machines and how to use elevators
19:51:38 <Rotaerk_> heh
19:52:17 <goomba> monads are wierd because the monadness is in your brain and not in the program
19:52:41 <ray> well, at least partially in a typeclass definition
19:54:15 <SamB> ray: the hardest to understand thing is that it's so simple and easy
19:54:32 <ray> yes, that is true
19:54:59 <ray> ray's monad tutorial: monads are so simple and easy that you may come to understand them and not realise it because you were expecting more
19:57:37 <dons> gwern: re. syntax extns. just trimmed the list from ghc user guide
19:57:43 <dons> feel free to edit !!
19:57:57 <dons> but the article needs a top level design. maybe based on the history of haskell paper?
19:58:08 <dons> covers all the main innovations, history, use, future
19:58:21 <dons> so would provide a good structure, with some authority
19:58:42 <pikhq> ray: It took me four days to get monads, just because I was expecting more to it.
19:59:03 <dons> gwern: i'll try to stub out the design on the haskell wiki, and ask for some collab finishing it
19:59:30 <Axman6> @src [] (>>=)
19:59:30 <lambdabot> xs >>= f     = concatMap f xs
19:59:48 <pikhq> ray: In a way, it's like the concepts of (basic) calculus -- you keep on expecting there to be more to it. :P
20:04:50 <pikhq> Me pensas ke boscopo parolas Esperanton.
20:04:53 <pikhq> s/Me/Mi/
20:07:19 <vav> @quote ray monads
20:07:19 <lambdabot> ray says: of all the things that are hard to understand in the world, monads rank somewhere in between how to use vending machines and how to use elevators
20:08:13 <inimino> @quote
20:08:13 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
20:16:10 <nanothief> Is there a way to simplify writing the template haskell macro found at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3130#a3130 ?
20:18:34 <ashumz> hello
20:21:16 <pikhq> > "hello"
20:21:18 <lambdabot>   "hello"
20:25:29 <ashumz> word.
20:34:10 <Axman6> > text "hello ashumz"
20:34:11 <lambdabot>   hello ashumz
20:37:43 <byorgey> nanothief: you should be able to do that with quotation brackets, I think?
20:38:46 <nanothief> byorgey: that's what I hoped, howver I don't know how to insert a Name into the quotation.
20:39:17 <nanothief> eg [d| data $name = $name Int |] -- how do I create name?
20:42:13 <byorgey> nanothief: hmm, I guess I'm not sure
20:42:22 <byorgey> I'm playing around with it, I'll let you know if I figure it out =)
20:43:46 <nanothief> byorgey, I managed to get it a lot better using syb: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3131#a3131 That might be the best I can do
20:44:12 <byorgey> heh
20:44:17 <byorgey> that's kind of ugly though =)
20:44:26 <nanothief> yeah :S
20:44:28 <deech> Hi all, is there a way to enable tab completion in emacs haskell-mode?
20:45:55 <deech> I guess I am sticking with the terminal then!
20:46:09 <deech> Miss the C-c C-l loading though.
20:46:30 <nanothief> oh you mean for inferior-haskell mode
20:47:12 <nanothief> don't know how to do that unfortunately
20:49:53 <byorgey> deech: you can use mod-/ which does generic emacs completion, based on similar things you have typed in the buffer.  but there's no program-aware tab completion for haskell.
20:50:33 <dufflebunk> deech: emacs has M-/  in every buffer
20:51:02 <dufflebunk> oh, nm. I'm too slow
20:51:35 <deech> byorgey dufflebunk , thanks - I discovered that shortcut only a few weeks ago and it has changed my life. It is what I am using to complete your nicks right now!
20:51:51 <nanothief> byorgey, from http://www.mail-archive.com/haskell-cafe@haskell.org/msg52513.html it appears that splices in type locations isn't supported, so [d| data $name = $name Int |] probably isn't possible
20:52:27 <byorgey> deech: heh, my IRC client has tab completion for nicks, but yeah, if your IRC client is in emacs that could be handy =)
20:52:37 <byorgey> nanothief: I see.
20:55:29 <deech> Has anyone here gotten wxhaskell to work? I compiled and installed the darcs version and running wxAsteroids gives me a zillion 'undefinedReference's
20:56:23 <deech> wxcore and wx are part of ghc-pkg list.
20:59:57 <SamB> deech: references to what ?
21:03:17 <hackagebot> yst 0.2 - Builds a static website from templates and data in YAML or (JohnMacFarlane)
21:03:56 <deech> samb, I think just about everything. I try compiling the 'Minimal.hs' included with the wxHaskell distribution and during the linking phase  hundreds of errors like thie : undefined reference to `wxManagedPtr_GetPtr' , keep scrolling by.
21:05:48 <SamB> deech: so, like, C or C++ symbols ?
21:07:55 <deech> SamB: yeah I guess. And wxGTK 2.8 is installed on my system.
21:10:59 <deech> I just saw that someone else has this issue on wxhaskell-devel ( http://www.mail-archive.com/wxhaskell-devel@lists.sourceforge.net/msg00487.html ) with no resolution.
21:17:45 * SamB wishes WHOIS worked for phone numbers
21:29:07 <Jvlaple> why this happen http://www.noelshack.com/uploads/16062009/photo10097605.jpg
21:29:39 <copumpkin> Jvlaple: heh
21:29:48 <copumpkin> @where ops
21:29:49 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
21:29:49 <lambdabot> mauke
21:30:34 <Badger> huh
21:30:39 --- mode: ChanServ set +o bos
21:30:41 <Badger> I didn't even know that was possible
21:30:42 <copumpkin> Jvlaple: luckily I'm totally unfazed by that, but it's not nice
21:30:45 <lispy> Jvlaple: please take that somewhere else like #haskell-blah
21:30:55 --- mode: bos set +b *!n=chatzill@*.wa.bigpond.net.au
21:31:02 --- kick: Jvlaple was kicked by bos (bos)
21:31:07 <lispy> Jvlaple: this channel is for conversations about haskell
21:31:15 --- mode: bos set -o bos
21:31:26 <Badger> copumpkin: seen it all before, eh :P
21:31:37 <SamB_XP> copumpkin: did you *have* to go "heh"?
21:31:49 * SamB_XP did not want to see that, whatever it may have been
21:31:50 <copumpkin> SamB_XP: it was critical
21:33:35 <ashumz> hahaha
21:38:08 --- mode: ChanServ set +o shapr
21:38:57 --- mode: shapr set -o shapr
21:53:42 <hackagebot> haskeem 0.7.9 - A small scheme interpreter (UweHollerbach)
21:56:29 <dufflebunk> Are there any modules for creating and accessing trees on disk rather than in memory?
21:57:28 <copumpkin> not explicitly trees
21:57:38 <copumpkin> although it'd be great to somehow have a fingertree-on-disk package
21:57:51 <copumpkin> with efficient on-disk storage
21:58:15 <dufflebunk> Not explictly trees, but something more generic then?
21:59:42 <copumpkin> less generic, you have a binding to berkeley db
21:59:49 <copumpkin> two of them actually I think
21:59:58 <copumpkin> one gives you a Data.Map-like interface to berkeley db
22:00:04 <copumpkin> and the other gives you a more direct interface to it
22:03:28 * edwardk perks up at the mention of fingertrees
22:04:58 <edwardk> sebastian visser was at hac phi and i wound up giving him an apomorphism for some tree traversal algorithms so he could apply them on disk in haskell, not sure what lib it was in/for though
22:05:32 <copumpkin> zomg
22:05:47 <copumpkin> a nice on-disk generic tree would be wonderful
22:06:34 <edwardk> as i recall he had a paramorphism based insert i replace with an apomorphism based one so it was clearer what parts of the tree remained untouched
22:06:54 <edwardk> not sure what he was planning on using it for though
22:07:12 <copumpkin> :o
22:07:17 <copumpkin> so many morphisms
22:07:25 * dufflebunk once again has to look up words in google
22:07:56 <Axman6> anyone used the Solaris x86 binaries before? they seem to be broken
22:10:34 <dufflebunk> grr, paramorphism -> catmorphism -> homomorphism... error call stack overflow.
22:10:50 <jrty> why is it that I can't do ':m +HUnit' in ghci even though HUnit is clearly installed as per ghc-pkg list?
22:11:03 <copumpkin> "Every monad arises from some adjunction—in fact, typically from many adjunctions—in the above fashion"
22:11:48 <copumpkin> someone needs to come up with an elegant way to express graph algorithms in haskell
22:12:00 <edwardk> copumpkin: sounds like you've been nominated ;)
22:12:17 <copumpkin> edwardk: I'm trying, but nothing satisfies my nothing of elegance :P
22:12:23 <copumpkin> haven't given up though
22:12:28 <dufflebunk> jrty: perhaps it needs to be :m Test.HUnit ?
22:12:53 <jrty> ah yes, thanks dufflebunk
22:12:55 <edwardk> i've been stuck obsessing about Dyck languages for 48 hours now. I think it is time to see a therapist.
22:13:01 <copumpkin> :o
22:13:14 * dufflebunk snickers
22:13:20 <edwardk> I have like 7 of them that come up in my parser
22:14:11 <edwardk> moreover i have several very similar monoids that keep coming up that i want to just generalize away but i don't want to go off and work on parsimony until this works, so its very chicken-and-the-egg ;)
22:14:23 <copumpkin> oh no
22:14:55 <copumpkin> > join par edwardk
22:14:57 <lambdabot>   Not in scope: `edwardk'
22:17:09 <edwardk> i did have a really nifty way to employ a cofree comonad for incremental folds of an f-algebra come up as a nifty way to support minimizing the syntax changes being made by a code refactoring browser today though.
22:17:46 <edwardk> better yet its being done in a monoid, so its very much a perfect storm of my weird obsessions
22:18:16 * edwardk apologizes for scaring off elbar
22:18:20 <copumpkin> lol
22:18:24 <Axman6> "i did have a really nifty way to employ a cofree comonad for incremental folds of an f-algebra come up as a nifty way to support minimizing the syntax changes being made by a code refactoring browser today though." <-- that's the sort of talk that scares people away from this channel :P
22:18:26 <copumpkin> too late, he's not coming back
22:18:30 <Axman6> ha
22:19:26 <Axman6> @users
22:19:26 <lambdabot> Maximum users seen in #haskell: 661, currently: 560 (84.7%), active: 9 (1.6%)
22:19:27 <dufflebunk> so a homorphism is just a mapping between two algebraic structure, but I've no idea what a catamorphism is, so I think I have no hope of figuring out what a paramorphism is
22:19:33 <edwardk> basically i'm keeping the lexeme information well into the syntax tree as an annotation attached as the value in the cofree comonad of my syntax functor
22:19:43 <edwardk> catamorphism = generalized foldr
22:20:03 <edwardk> for functors other than lists
22:20:25 <SamB_XP> edwardk: functors including, but not limited to, lists
22:20:39 <copumpkin> is iterate a named recursion scheme?
22:20:49 <copumpkin> it seems kinda general
22:20:49 <dufflebunk> they turn algebraic structures into single values by traversing them once?
22:21:10 <edwardk> anyways by keeping that lexeme info i can always pretty print out a source fragment exactly as i read it, but then what happens when you mutate the tree? so i have a small incremental fold that takes the folds of smaller source fragments and generates an updated one. i.e. given the syntax fragments for each statement of a where clause i can build a new where clause
22:21:49 <edwardk> dufflebunk: basically replace the cons and nil constructors with function applications. for other functors do the same thing.
22:22:12 <edwardk> SamB_XP: fair enough ;)
22:22:17 <BMeph> " i've been stuck obsessing about Dyck languages for 48 hours now." <-- That doesn't help pack 'em in either. ;)
22:22:32 <edwardk> copumpkin: yes, its a special instance of a prepro or postpromorphism
22:22:43 <copumpkin> :o
22:22:48 <jimmyjazz14> uhhg how does one convert a String to Word8
22:22:50 <copumpkin> but it's not zygohistmorphic?
22:23:04 <edwardk> well, it is trivially so. ;)
22:23:12 <jimmyjazz14> or more specific a String to a lazy bytestring
22:23:17 <edwardk> it just doesn't exploit the zygo or histo structure =)
22:23:21 <copumpkin> aw damn
22:23:25 <BMeph> A paramorphism is just a shifted-over anamorphism. Nothing to worry about. ;)
22:23:42 <edwardk> BMeph: ?
22:23:44 <copumpkin> edwardk: do you have any real-life algorithms expressed in terms of these schemes?
22:23:49 <Axman6> jimmyjazz14: pack?
22:23:55 <Axman6> :t pack
22:23:56 <lambdabot> Not in scope: `pack'
22:24:12 <edwardk> copumpkin: a few. i wrote a binary tree insert apomorphism off the cuff at hac phi for sebastiaan
22:24:20 <Axman6> :t Data.ByteString.Word8.Lazy.pack
22:24:21 <lambdabot> Couldn't find qualified module.
22:24:27 <Axman6> :t Data.ByteString.Lazy.pack
22:24:28 <lambdabot> [Word8] -> BSLC.ByteString
22:24:37 <Axman6> :t Data.ByteString.Lazy.Char8.pack
22:24:38 <edwardk> you want the Data.ByteString.Lazy.Char8.pack
22:24:38 <lambdabot> [Char] -> BSLC.ByteString
22:25:29 <lispy> does Haskell have an equivalent of the prototype constructional pattern from OO?
22:25:34 <edwardk> copumpkin: in general i treat them like a rathole down which productive programmers go to die ;)
22:26:25 <jimmyjazz14> ByteStrings are much pain
22:26:27 <edwardk> lispy: data Foo = Foo { bar :: a, baz :: a -> a }; defaultFoo :: Foo; defaultFoo = Foo { ... };
22:26:34 <edwardk> lispy: we use it all the time =)
22:26:40 * dufflebunk gives up and decides to finally break down and read the paper about bannans and lenses
22:26:44 <edwardk> defaultFoo could be viewed as a prototype
22:27:00 <Axman6> jimmyjazz14: how so?
22:27:02 <lispy> edwardk: But, in OO languages they use it with subtyping.
22:27:19 <edwardk> dufflebunk: i wrote a short knol on google forever ago about catamorphisms that might work as a starting point
22:27:28 <lispy> edwardk: the defaultFoo pattern you show certainly has uses, but it's not as general as what the cool kids are doing in OO languages
22:27:34 <edwardk> yeah
22:27:46 <Axman6> there are no cool kids doing OO >_>
22:27:50 <edwardk> well, then implement it in kata and you're all done ;)
22:27:51 <BMeph> :t Data.ByteString.Char8.pack
22:27:53 <lambdabot> String -> BSC.ByteString
22:27:56 <edwardk> and subtype at will ;)
22:27:58 <lispy> edwardk: heh
22:28:05 <copumpkin> edwardk: mauke has a package for that iirc
22:28:17 <BMeph> ...or that one, if it's supposed to be a strict BS. ;)
22:28:22 <Axman6> BMeph: interesting that the lazy one says it takes a [Char], but that one takes a String
22:28:24 <lispy> I'm not suggesting we need it, but it just struck me that I don't really think we ever do it
22:28:26 <jimmyjazz14> Axman6: just seems like a lot of work to convert strings around so much
22:28:27 <edwardk> dufflebunk: http://knol.google.com/k/edward-kmett/catamorphisms/3qi7x2qrdushx/2
22:28:45 <Axman6> jimmyjazz14: well, they're best for efficient input and output afaik
22:28:53 <lispy> class PrototypeFactor a where new :: a -> a, ?
22:29:22 <lispy> That seems kind of silly.  And maybe it should be multiparameter?
22:29:22 <BMeph> Axman6: Yeah, isn't it, though? :)
22:29:22 <Axman6> oh god damn it
22:29:30 <lispy> How would you simulate the subtyping?
22:29:34 <jimmyjazz14> Axman6: yeah I understand that. I guess -XOverloadedStrings is suppose to ease some of the pain
22:29:48 <dufflebunk> edwardk: thanks, I'll give it a read
22:30:03 <Axman6> has anyone managed to get the x86 Solaris binaries to work?
22:30:26 <BMeph> Axman6: Isn't that benl's bailiwick? :)
22:30:36 <Axman6> not x86
22:30:46 <Axman6> and he doesn't have anything to do with the binaries
22:31:22 <BMeph> Axman6: Oh, that's right, he's doing the SPARC. Hmm, Solaris x86...
22:31:28 <edwardk> now i just need to figure out the best way to express the fold in question, since i keep changing out functors on the way
22:31:42 <Axman6> both the 6.10.1 and 6.10.4 version fail with:
22:31:43 <Axman6> installPackage: Error: Could not find module:
22:31:43 <Axman6> Data.Array.Parallel.Unlifted.Sequential.Flat.UArr with any suffix: ["hi"]
22:31:43 <Axman6> gmake[1]: *** [install.library.dph/dph-prim-seq] Error 1
22:32:03 <Axman6> i it possible the file names got truncated?
22:32:20 <Axman6> because there's UArr.h and UArr.p in there, both are binary files
22:32:35 <copumpkin> :o
22:32:45 <copumpkin> probably
22:32:55 <Axman6> urgh
22:43:03 <copumpkin> hmm interesting, positive reals, max, and * form a semiring?
22:43:44 <shepheb> what's missing from a semiring vs. a ring?
22:44:06 <copumpkin> that (+) be invertibel
22:44:16 <copumpkin> invertible, even
22:44:23 <shepheb> copumpkin: thanks
22:44:38 <edwardk> copumpkin: there are lots of dioid-like semirings
22:45:22 <copumpkin> interesting
22:45:34 <copumpkin> well, interesting in that I didn't know what a dioid was until I just looked it up
22:45:44 <edwardk> heh
22:46:03 <Baconizer> Does anything ever happen with Hircules?
22:46:15 <copumpkin> Hircules?
22:46:22 <copumpkin> lol
22:46:24 <copumpkin> doubt it
22:46:40 <edwardk> dioid = semiring with a + a = a
22:46:47 <copumpkin> yeah :)
22:47:05 * copumpkin goes and adds that to his unusable algebra library
22:47:05 <Baconizer> posted by juhp 272 days ago :<
22:47:14 <edwardk> hahahaha
22:47:31 <edwardk> its in monoids, well, the old one. there are a few dioids anyways
22:47:48 <edwardk> the current 'practical' monoids omits ringoid on up
22:48:14 <erikc> herculoids are the bomb
22:48:28 <copumpkin> are herculoids strong?
22:48:33 <erikc> unbreakable
22:48:58 <edwardk> i dunno, but I hear they can be used to quickly solve the Aegean stables problem.
22:49:24 <edwardk> though, you have to be willing to permit side effects
22:53:10 <Infamous_Cow> the standard libraries link on haskell.org is linking to a 404
22:55:00 <FunctorSalad_> that's not good
23:00:55 <sjanssen_> Infamous_Cow: interesting
23:03:40 <sjanssen_> hmm, I don't think the link should be to current anyway
23:06:57 <sjanssen> I'd fix it, but I have no idea what this wiki markup is doing
23:08:12 * Beelsebob ponders if Captain Obvious is anyone in here
23:08:43 <Axman6> hey Beelsebob, did you happen to see that story i posted to reddit?
23:08:53 <Beelsebob> Axman6: not sure, which?
23:09:02 <Axman6> http://www.reddit.com/r/reddit.com/comments/969sy/your_ip_ip_address_has_been_logged_your_isp_wrong/?sort=top
23:09:07 <Beelsebob> oh, yes
23:09:08 <Beelsebob> :P
23:09:14 <Axman6> 11th most popular link on reddit of all time :D
23:09:22 <Beelsebob> hahaha
23:09:25 <Beelsebob> awesome
23:09:29 * Axman6 iz teh internetz famus
23:10:12 <sjanssen> Infamous_Cow: it's fixed, thanks for pointing that out
23:10:31 <Baconizer> haha
23:10:38 <Infamous_Cow> sjanssen: im still getting a 404
23:10:39 * Baconizer makes a note to rickroll people with that
23:11:08 <Beelsebob> Baconizer: ohhh, now that would make it better – add a link for explaining why you were there, that links to a rickrolling
23:11:09 <Beelsebob> >.>
23:11:10 <Infamous_Cow> sjanssen: nevermind, browser cache
23:11:20 <FunctorSalad_> "* Beelsebob ponders if Captain Obvious is anyone in here"   ._.
23:11:49 <Beelsebob> FunctorSalad_: someone posting on my blog
23:12:02 <Beelsebob> that I'd like to talk to over IRC, because the via-blog discussion is slow
23:17:01 <mmorrow> woohoo, just fixed vacuum so that annoying "ARR_WORDS entered" crash can never happen again
23:18:38 <mmorrow> (the nodes were getting entered (seq ==> entered) before i could check their closure type, so delaying the seq until after the closure type's known and then only evaluating the node if it's a THUNK was the trick)
23:19:26 <mmorrow> and then the vacuumLazy variation simply doesn't evaluate the node if it's a THUNK
23:20:06 <mmorrow> but both versions suffered from this problem of entering "unpointed" closures previously
23:20:45 <mmorrow> the code in the infotables of unpointed closures being e.g.:
23:20:47 <mmorrow> INFO_TABLE(stg_ARR_WORDS, 0, 0, ARR_WORDS, "ARR_WORDS", "ARR_WORDS")
23:20:48 <mmorrow> { foreign "C" barf("ARR_WORDS object entered!") never returns; }
23:21:19 <mmorrow> and since entering means jumping to the code in the info table..
23:23:37 <mmorrow> (normally haskell code knows not to enter such closures, but since the unpackClosure# primitive coerces all closures (including unpointed ones) to HValue, code was being fooled into entering them (and crashing))
23:23:59 <mmorrow> </unsolicited info>
23:24:00 <mmorrow> :)
23:27:40 <wgsilkie> What's the expression terminator in Haskell (if there is such a thing)?
23:28:05 <c_wraith> sometimes it's ;
23:28:05 <mmorrow> you mean like a semicolon in a C-like language?
23:28:07 <wgsilkie> So I can, in GHCi, do several things on one line.
23:28:12 <Axman6> you can use ;, but it's not needed
23:28:17 <mmorrow> wgsilkie: ;
23:28:28 <wgsilkie> OK, thanks!
23:29:01 <wgsilkie> Erm, this isn't working.
23:29:13 <wgsilkie> print "Hello!"; print "Bye!"
23:29:17 <wgsilkie> > print "Hello!"; print "Bye!"
23:29:18 <lambdabot>   <no location info>: parse error on input `;'
23:29:27 <wgsilkie> Yeah, I get thet.
23:29:27 <c_wraith> oh.
23:29:29 <wgsilkie> *that
23:29:30 <c_wraith> yyou're in the IO monad
23:29:31 <mmorrow> you need "do""""'
23:29:35 <mmorrow> err
23:29:37 <mmorrow> you need "do"
23:29:40 <mmorrow> or ">>"
23:29:49 <c_wraith> or just...  print "Hello" >> print "Bye"
23:29:49 * wgsilkie has to zip off.
23:29:50 <mmorrow> print 4 >> print 4
23:29:56 <mmorrow> do print 4; print 4
23:30:07 <c_wraith> yay monad syntax. :)
23:31:18 <c_wraith> mmorrow:  doesn't do syntax with ; also require braces?
23:31:37 <mmorrow> , do x <- [0..9]; return x
23:31:40 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
23:31:53 <c_wraith> guess not, then
23:31:57 <Rotaerk> hrm.. someone told me haskell doesn't have D3D bindings, but http://www.haskell.org/~simonmar/lib-hierarchy.html seems to indicate that's not the case..
23:32:07 <Rotaerk> is it new? or maybe just crappy?
23:32:23 <mmorrow> c_wraith: if you have a "let" in there, you need them for the let-bindings to avoid ambiguity
23:32:34 <mmorrow> , do x <- [0..9]; let y = 4; return (x,y)
23:32:35 <lunabot>  luna: parse error on input `)'
23:32:40 <mmorrow> , do x <- [0..9]; let {y = 4}; return (x,y)
23:32:42 <lunabot>  [(0,4),(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4),(8,4),(9,4)]
23:38:59 <sjanssen> Rotaerk: those are just notes on what a hypothetical library hierarchy might look like
23:39:15 <Rotaerk> ah
23:39:51 <wgsilkie> I suppose it doesn't make much sense for anything outside monads.
23:52:15 <edwardk> hrmm
23:52:26 <edwardk> newtype (e :> f) = In { out :: f (e f) }
23:52:57 <edwardk> data Exp f = Paren (Exp :> f) | App (Exp :> f) (Exp :> f)
23:53:24 <edwardk> then you can use things like data Ann a e = Ann a e with Exp :> Ann a to represent a cofree comonad over the expression type
23:53:39 <edwardk> or data Base a e = Base a -- to express something like the 'base functor' for your expression
23:54:03 <edwardk> or data Free a e = Return a | Free e -- aka Either to represent the fixed point
23:54:12 <edwardk> er to represent the free monad
23:54:24 <edwardk> and note Base = Const and Ann = (,)
23:54:41 <edwardk> and Mu = Id
23:56:30 <edwardk> but by tieing things off there Exp can recurse into itself non-uniformly. it can recurse into Pat :> f  or Decl :> f, etc
23:57:20 <edwardk> which lets me attach annotations to a tree defined incrementally in terms of f-algebra-like folds
23:58:39 <erikc> woops, desktop cmoputer froze up, totally overheated, crazy heatwave
23:58:50 <mmorrow> heh, i was considering something almost exactly like that yesterday
23:59:18 <hackagebot> network-data 0.1.0 - Library for network data structures (ex: ip/udp/tcp headers and helper functions) (ThomasDuBuisson)
23:59:27 <edwardk> i found myself needing it to attach the stream of lexemes to my parsed syntax tree in such a way that when i refactor it i leave as much as possible unmodified
23:59:31 <mmorrow> (considering retroactively using it for some code, and ultimately decided it'd be too much effort, but it's a neat thing)
23:59:42 <mmorrow> data Ann f a b = Ann a (f (Ann f a) b)
23:59:52 <mmorrow> type AnnE a b = Ann Exp a b
