00:12:47 <mmorrow> roconnor: "@djinn DJ r a -> Cont r a" nice, i think that says it the best
00:12:52 <mmorrow> @djinn DJ r a -> Cont r a
00:12:53 <lambdabot> f a b =
00:12:53 <lambdabot>     case a of
00:12:53 <lambdabot>     DJ c -> b (c b)
00:14:15 <mmorrow> "pass yourself partially applied to the continuation, to the continuation"
00:14:29 <hackagebot> texmath 0.1.0.3 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
00:15:01 <mmorrow> s/partially//
00:16:39 <Saizan> mmorrow: hah, that's "forsome" in escardo's post
00:16:42 <mmorrow> no, pass yourself as the continuation, partially applied to the continuation-taking function to the conitnuation function
00:17:04 <mmorrow> *to the continuation-taking function
00:17:26 <mmorrow> "pass yourself as the continuation, partially applied to the continuation-taking function to the continuation-taking function" i meant to say
00:19:05 <mmorrow> well i don't know what it says, but that's a simple/clear insight into what it can do/does
00:19:17 <mmorrow> (the djinn output is)
00:20:12 <mmorrow> Saizan: that's also i think essentially the same thing that the monadLib `Label' type does (maybe)
00:20:18 <mmorrow> , src ''Label
00:20:23 <lunabot>  newtype Label m a = Lab ((a, Label m a) -> m ())
00:20:35 <quicksilver> ah, that old chestnut. The simple/clear insight that you can't put into words :)
00:20:54 <quicksilver> possibly some definition of simple/clear I was previously unfamiliar with.
00:21:26 <mmorrow> , [$ty| label |]
00:21:28 <lunabot>  luna: Exception when trying to run compile-time code:
00:21:43 <mmorrow> , ''labelM
00:21:44 <lunabot>  luna: Not in scope: type variable `labelM'
00:21:45 <mmorrow> , 'labelM
00:21:46 <lunabot>  luna: Not in scope: `labelM'
00:22:04 <mmorrow> , [$ty| labelCC |]
00:22:07 <lunabot>  forall a b . ContM a => b -> a ((b, Label a b))
00:23:15 <mmorrow> , runCont id (do (n,go) <- label 0; when (n < 127) (jump (n+1) go); return n)
00:23:16 <lunabot>  luna: Not in scope: `label'
00:23:22 <mmorrow> , runCont id (do (n,go) <- labelCC 0; when (n < 127) (jump (n+1) go); return n)
00:23:23 <lunabot>  127
00:25:54 <mmorrow> it uses the newtype Label to hide the infinite type so you can stick the `k' in "callCC (\k -> ..)" in a datatype, then call it later to jump to that point with the val updated
00:25:57 <mmorrow> if you want
00:26:01 <mmorrow> quicksilver: heh
00:29:06 <mmorrow> quicksilver: simple compared to e.g.
00:29:09 <mmorrow> @djinn DJ (DJ o a) (DJ (DJ o a) a) -> DJ (DJ a (DJ o a)) a
00:29:10 <lambdabot> f a =
00:29:10 <lambdabot>     case a of
00:29:10 <lambdabot>     DJ b -> DJ (\ c ->
00:29:10 <lambdabot>                 case b (\ d ->
00:29:10 <lambdabot>                         case d of
00:29:12 <lambdabot>                         DJ e -> DJ (\ _ -> e (\ f -> DJ (\ _ -> f)))) of
00:29:14 <lambdabot>                 DJ g -> g (\ h ->
00:29:16 <lambdabot>                            case c h of
00:29:18 <lambdabot>                            DJ i -> DJ (\ j ->
00:29:20 <lambdabot>                                        case i (\ _ -> h) of
00:29:22 <lambdabot>                                        DJ k -> k (\ _ -> j h))))
00:31:00 <quicksilver> if only C had a goto which allowed you to pass a parameter. What evil could we then perpetuate
00:31:26 <c_wraith> ....  longjmp!
00:31:27 <mmorrow> quicksilver: coincidently, i wish that existed probably daily ;)
00:31:41 <c_wraith> longjmp is just a fancy goto, right?  :)
00:32:34 <mmorrow> c_wraith: the thing that's unfortunate though is that i think it's only defined behavior if you longjmp to a setjmp point that's directly up-stack
00:33:28 <c_wraith> I thought it would work in the same stack frame, too
00:33:37 <c_wraith> obviously, it doesn't go down-stack.
00:33:43 <mmorrow> although it seems to work when that's not the case, you might just be waiting to the locals on the stack you're using to get overwritten
00:33:52 <mmorrow> c_wraith: /across/ stack :)
00:34:04 <c_wraith> Oh, yeah
00:34:09 <c_wraith> Not going to be reliable doing that
00:34:34 <quicksilver> the things that's even more unfortunate is there is no type system checking you're doing it right
00:34:38 <quicksilver> :)
00:38:35 <hackagebot> texmath 0.1.0.4 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
00:41:17 <sbahra> Silly question.
00:43:09 <sbahra> import System.Posix.POpen
00:43:20 <sbahra> main = popen "/bin/ps auxww" [] Nothing >>= putStrLn . (\(a,b,c) -> head $ lines a)
00:43:31 <sbahra> Is this not supposed to work? Output is empty here.
00:45:45 <sbahra> Seems like the program exists prematurely.
00:45:56 <sbahra> haha
00:46:03 <sbahra> It also seems like it exits prematurely.
00:48:49 <quicksilver> sbahra: the first argument to popen is a FilePath
00:49:11 <quicksilver> sbahra: I doubt, personally, that there is a file called 'ps auxww' in your '/bin/' directory.
00:49:35 <sbahra> Apparently, that "file path" is supposed to be a command
00:49:44 <sbahra> popen :: FilePath                       -- Command
00:50:17 <sbahra> quicksilver, I initially assumed the same as you and did:
00:50:44 <sbahra> main = popen "/bin/ps" ["ps", "auxww"] Nothing >>= putStrLn . (\(a,b,c) -> head $ lines a)
00:51:38 <sbahra> quicksilver, here is what happens if I do this from ghci. :-)
00:51:55 <sbahra> Prelude System.Posix.POpen> popen "/bin/ps" ["ps", "auxww"] Nothing
00:52:00 <sbahra> [sbahra@centrino tmp]$
00:52:13 <sbahra> I'm not sure why it does, but it exits.
00:52:23 <sbahra> s/exits/terminates/
00:52:26 <quicksilver> well nonetheless I'm sure that's the right way.
00:52:44 <quicksilver> maybe executeFile doesn't work well from inside ghci?
00:53:10 <sbahra> quicksilver, yes.
00:53:15 <sbahra> quicksilver, comment is not accurate.
00:53:21 <sbahra> quicksilver, it is command and then argument.
00:53:35 <sbahra> quicksilver, but execute file is done in the context of a forked process.
00:53:56 <sbahra> I'm not sure why ghci should exit if a child process does exit.
00:54:21 <quicksilver> the source I'm looking at doesn't use forkProcess at all
00:54:25 <quicksilver> I"m not sure how it could ever work
00:54:30 <quicksilver> http://hackage.haskell.org/packages/archive/popenhs/1.0.0/doc/html/src/System-Posix-POpen.html#popen
00:54:34 <quicksilver> just looks broken to me.
00:54:40 <sbahra> quicksilver, line 66.
00:54:44 <quicksilver> it runs executeFile in the main process and kills it
00:54:59 <sbahra> Wow. :-/
00:55:06 <sbahra> Maybe I'm not using the hackage version. :-)
00:55:08 <sbahra> Or something like that.
00:55:12 * sbahra is looking at source from hackage
00:55:20 <sbahra> cabal
00:55:36 <sbahra> quicksilver, http://hackage.haskell.org/package/popenhs
00:55:48 <sbahra> quicksilver, line 66.
00:55:52 <sbahra> quicksilver, are we looking at the same file?
00:57:18 <sbahra> It seems I'm using the correct one.
00:58:23 <mmorrow> sbahra: System.Process.readProcess works
00:58:52 <mmorrow> mapM_ (print . words) . lines =<< readProcess "ps" ["aux"] []
00:59:20 <sbahra> Thanks.
00:59:54 <dibblego> http://paste.pocoo.org/show/135468/ can any geometry geeks spot an error?
01:02:26 <sbahra> quicksilver, let me know please, I am curious. :-)
01:05:31 <doserj> dibblego: what is the code supposed to do? what result did you expect?
01:05:44 <Axman6> dibblego: looks interesting, wish it was something i knew about :)
01:06:03 <dibblego> doserj, give the lat/long after projecting a vector from a given lat/long
01:06:14 <dibblego> -- http://williams.best.vwh.net/avform.htm#LL
01:06:50 <doserj> dibblego: on the unit circle?
01:07:23 <dibblego> yes, using Great Circle
01:09:16 <dibblego> the given lat/long is nothing like I'd expect
01:09:27 <dibblego> yet I see no error in the computation
01:10:00 <doserj> dibblego: what did you expect?
01:10:55 <dibblego> I expected something less dramatic than Coord -46 -60 when projecting 10 kilometres at 45 degrees from Coord 27 153
01:11:14 <doserj> dibblego: where do you get kilometres on a unit circle?
01:11:17 <mmorrow> dibblego: iirc the latlong measures one of the angles the two angle the opposite way as spherical coords do, so if you used that formula verbatim you might have (latitude i think) one borked
01:12:00 <mmorrow> *.. one of the two angles the opp..
01:12:24 <dibblego> I did use the formula verbatim but I don't know why that is erroneous
01:12:53 <mmorrow> spherical measures phi from the pole, whereas lat/long measures latitude from the equator
01:14:19 <doserj> dibblego: distance 10 is roughly 1.5 times round the globe
01:14:51 <dibblego> so then I must normalise it somehow?
01:16:31 <doserj> dibblego: well, if you want to calculate results on the earth, you have to bring the size of the earth into the equations
01:17:08 <dibblego> you mean d/earthRadius instead of d
01:18:07 <doserj> yes
01:19:12 <dibblego> that makes sense, thanks
01:19:53 <nlogax> hmm, weird. rented some more RAM on the VPS and managed to run ghc --make Setup to install cabal. looked like everything worked, but in my ~/.cabal i only have lib and share, no bin :o what did i miss?
01:20:38 <doserj> nlogax: did you install the package Cabal, or the package cabal-install?
01:25:20 <sbahra> mmorrow, this is terrible, I am trying to print out the last column of ps auxw on Linux.
01:25:27 <sbahra> mmorrow, http://codepad.org/dBoFb106
01:25:38 <sbahra> mmorrow, do you know of a much more "compressed" method for this?
01:27:07 <nlogax> doserj: oh.. there were two of them. Cabal of course... :D
01:27:09 <nlogax> thanks
01:27:17 <sbahra> Nevermind.
01:28:11 <quicksilver> sbahra: I think we are looking at the same file.
01:28:25 <quicksilver> sbahra: I don't see any use of forkProcess in that file
01:28:43 <sbahra> quicksilver, line 66?
01:28:49 <sbahra> quicksilver, pid <- forkProcess
01:28:51 <quicksilver> which file are you looking at?
01:28:56 <quicksilver> I have : http://hackage.haskell.org/packages/archive/popenhs/1.0.0/doc/html/src/System-Posix-POpen.html#popenEnvDir
01:28:56 <sbahra> quicksilver, POpen.hs
01:29:57 <quicksilver> yup. I just downloaded it from hackage
01:30:04 <quicksilver> there is no occurrence of forkProcess in the file.
01:30:11 <quicksilver> there is one occurence of 'forkIO' which is commented out.
01:31:06 <quicksilver> in any case it's a library from 2001 and I'm pretty sure it's superseded by the newer System.Process
01:31:14 <quicksilver> but I'm intrigued how you can see a forkProcess which I can't see
01:32:55 <sbahra> quicksilver, uhm.
01:33:04 <sbahra> quicksilver, can you give me the md5 sum of the file you are looking at? :-)
01:33:22 <sbahra> There is definitely a forkProcess in my copy.
01:33:23 <quicksilver> f62041b6fa67d42a960bf187037197a7  popenhs-1.0.0/System/Posix/POpen.hs
01:33:44 <sbahra> 734019687283143519f4aee589b39140  POpen.hs
01:34:00 <quicksilver> sbahra: where did you get it from?
01:35:00 <roconnor> @free (((a -> r) -> a) -> r -> ((a -> r) -> a)) -> (a -> r) -> a
01:35:00 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
01:35:12 <sbahra> quicksilver, indeed. :-)
01:35:18 <doserj> there are 3 versions on http://www.haskell.org/~petersen/haskell/popenhs/, only one on hackage, though.
01:35:23 <sbahra> quicksilver, I fetched it off somewhere else, I think the author's home page or similar. :-)
01:35:34 <sbahra> quicksilver, the one on hackage is really useless.
01:35:47 <roconnor> @free join :: (((a -> r) -> a) -> r -> ((a -> r) -> a)) -> (a -> r) -> a
01:35:47 <lambdabot> (forall p q. (forall f1 f2. g . f1 = f2 . f                            =>                             f (p f1) = q f2)             =>              (forall x f3 f4. g . f3 = f4 . f
01:35:47 <lambdabot>           =>                               f (h p x f3) = k q (g x) f4)) => g . f5 = f6 . f => f (join h f5) = join k f6
01:36:35 <quicksilver> sbahra: "has been tested on ghc 5 so far"
01:36:42 <quicksilver> :)
01:36:47 <sbahra> haha
01:36:50 * quicksilver recommends the new system.process calls instead.
01:36:54 <sbahra> Yeah.
01:37:10 <sbahra> Well, I was just having a quick discussion with some guy regarding Haskell's suitability for some tasks.
01:37:17 <sbahra> For this problem, "popen" was the first thing to come to mind.
01:38:19 <quicksilver> sure, popen is the traditional unix name for it
01:38:36 <quicksilver> readProcess is the System.Process name for it :)
01:39:43 <roconnor> @seen BMeph
01:39:43 <lambdabot> BMeph is in #haskell, #concatenative, #haskell-in-depth, #ghc, #haskell-blah and #haskell-overflow. I last heard BMeph speak 2h 1s ago.
01:40:34 <quicksilver> being a perl scripter I've always used open("ps auwx |") or `ps auwx`
01:40:37 <quicksilver> have you seen hsh?
01:40:41 <quicksilver> hsh is nice for this kind of thing.
01:41:06 <profmakx> roconnor, I have thought about using the J monad in computational algebra. i have just not come around thinking about it more closely
01:41:09 <SubStack> :o
01:41:36 <roconnor> profmakx: you are saying you thought about it, but not very hard?
01:41:37 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
01:41:52 <profmakx> yeah, because i did not have time yet
01:42:01 <profmakx> phd is taking up a lot of time atm
01:42:25 <path_> hi I have a question. I was trying to define a function lengths as [0..length xs] so that I could feed it a list and get an array from 0 till number of items in the list
01:42:35 <path_> is there a way to do that in a points free style?
01:42:36 <roconnor> stupid phds
01:42:48 <luite> path_: enumFromTo
01:43:06 <path_> that takes 2 parameters is it
01:43:07 <path_> ah
01:43:12 <luite> enumFromTo 0 :p
01:43:55 <path_> yeah I got it =p
01:47:18 <SimonAdameit> Hi
01:47:48 <SimonAdameit> is there a built in function like tail but that gives [] for [] instead of raising an exception?
01:47:51 <quicksilver> @pl \xs -> [0..length xs]
01:47:51 <lambdabot> enumFromTo 0 . length
01:47:57 <quicksilver> path_: ^^ ;)
01:48:09 <quicksilver> SimonAdameit: drop 1
01:48:15 <path_> ah
01:48:18 <SimonAdameit> thanks!
01:48:20 <path_> whats @pl ?
01:48:31 <skorpan> would haskell have any sort of nice abstraction for this?  http://pastebin.com/m3eb582dc
01:48:40 <quicksilver> path_: pointless
01:48:48 <quicksilver> path_: it produces pointless code :)
01:49:58 <path_> lol
01:50:05 <path_> nice
01:50:54 <doserj> skorpan: sth like Data.List.lookup True [(M && S && C), a),...]?
01:51:02 <quicksilver> skorpan: well you could make a lookup table
01:51:06 <quicksilver> ah yes, as doserj says.
01:51:15 <doserj> sorry, quicksilver :)
01:51:16 <quicksilver> would certainly be easier to read
01:51:21 <Saizan> where the values are lambdas
01:51:41 <skorpan> :t lookup
01:51:44 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
01:51:50 <quicksilver> lists-of-pairs is quite a general idiom actually
01:52:02 <quicksilver> I find various kinds of lookup tables quite often useful.
01:52:14 <quicksilver> (lists-of-tuples sometimes)
01:52:34 <skorpan> but i was thinking some neat little function which given [C, M, S, s] returns the function i just gave you :)
01:52:48 <skorpan> i was thinking something along the lines of fmap flip foldM scanl
01:53:26 <doserj> sth that calculates the longest subsequence of true predicates?
01:54:21 <path_> how about subsequences
01:54:24 <quicksilver> > map inits . tails $ [a,b,c,d]
01:54:28 <Saizan> skorpan: well, nothing stops you from building up the lookup table with a function like that :)
01:54:28 <lambdabot>   [[[],[a],[a,b],[a,b,c],[a,b,c,d]],[[],[b],[b,c],[b,c,d]],[[],[c],[c,d]],[[]...
01:54:33 <fasta> Are Oleg's generic zippers packaged up somewhere?
01:54:39 <path_> and then find from the right where everything is true :)
01:54:41 <quicksilver> > filter (not.null) . map inits . tails $ [a,b,c,d]
01:54:43 <lambdabot>   [[[],[a],[a,b],[a,b,c],[a,b,c,d]],[[],[b],[b,c],[b,c,d]],[[],[c],[c,d]],[[]...
01:54:47 <roconnor> @type filterM
01:54:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:54:53 <quicksilver> > filter (not.null) . concatMap inits . tails $ [a,b,c,d]
01:54:55 <lambdabot>   [[a],[a,b],[a,b,c],[a,b,c,d],[b],[b,c],[b,c,d],[c],[c,d],[d]]
01:54:58 <quicksilver> there you go :)
01:55:13 <skorpan> that's disgusting
01:55:17 <skorpan> damn you haskell!
01:55:17 <quicksilver> ?
01:55:23 <skorpan> i mean disgusting in a positive sense
01:55:27 <purplepenguins> :t not.null
01:55:29 <lambdabot> forall a. [a] -> Bool
01:55:33 <path_> whats inits.tail mean?
01:55:40 <path_> first letter of everything but the first?
01:55:45 <skorpan> \x -> inits (tails x)
01:55:45 <purplepenguins> :t null
01:55:47 <lambdabot> forall a. [a] -> Bool
01:55:48 <skorpan> oh, hehe
01:56:08 <path_> ah
01:56:09 <skorpan> > tails [a,b,c]
01:56:11 <lambdabot>   [[a,b,c],[b,c],[c],[]]
01:56:15 <path_> oh
01:56:25 <skorpan> reminds me of scanl a bit
01:56:29 <purplepenguins> :t concatMap
01:56:30 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:56:32 <skorpan> @src talis
01:56:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:56:34 <skorpan> @src tails
01:56:35 <lambdabot> tails []         = [[]]
01:56:35 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
01:56:40 <skorpan> @src scanl
01:56:41 <lambdabot> scanl f q ls = q : case ls of
01:56:41 <lambdabot>     []   -> []
01:56:41 <lambdabot>     x:xs -> scanl f (f q x) xs
01:57:05 <purplepenguins> @src concatMap
01:57:06 <lambdabot> concatMap f = foldr ((++) . f) []
01:57:22 <quicksilver> @remember skorpan i mean disgusting in a positive sense
01:57:22 <lambdabot> Nice!
01:57:31 <skorpan> hehe
01:58:18 <c_wraith> @src scanl
01:58:18 <lambdabot> scanl f q ls = q : case ls of
01:58:18 <lambdabot>     []   -> []
01:58:18 <lambdabot>     x:xs -> scanl f (f q x) xs
02:00:10 <path_> I dont understand this -> xxs@(_:xs)
02:00:20 <skorpan> path_: they put the name on the pattern matched stuff
02:00:21 <path_> I understand _:xs
02:00:30 <path_> but whats xxs@
02:00:34 <skorpan> you can use "xxs" to refer to that list
02:00:37 <quicksilver> xxs becomes a name for the whole thing
02:00:41 <path_> ah
02:00:57 <path_> got it
02:04:52 <cadabra> With Posix regex, I can't seem to use ^ and $ in alternatives. For example, this is False: "foo" =~ "[ ^]foo" :: Bool
02:05:11 <quicksilver> that's correct.
02:05:27 <quicksilver> that means "a space or a caret followed by 'foo'"
02:05:34 <quicksilver> so your string does not match it.
02:05:57 <skorpan> cadabra: what would you like the regexp to do?
02:05:58 <roconnor> @type fold
02:06:00 <lambdabot> Not in scope: `fold'
02:06:05 <roconnor> @hoogle fold
02:06:05 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
02:06:05 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
02:06:05 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
02:06:20 <path_> is there a version of take that allows me to say take till there are n items left?
02:06:27 <skorpan> takeWhile
02:06:40 <quicksilver> cadabra: try "( |^)foo"
02:06:50 <quicksilver> path_: take (length xs - n)
02:06:55 <path_> yeah but the predicate workson the element
02:07:02 <skorpan> : takeWhile
02:07:07 <skorpan> :t takeWhile
02:07:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:07:09 <path_> hehe ok I was wondering if there was a built in function or something =p, but ok
02:07:14 <skorpan> hm, you're right
02:07:16 <skorpan> :(
02:07:40 <path_> take and takewhile are there in some of the OO languages taking functional paradigms :)
02:07:44 <quicksilver> cadabra: although "^ ?foo" or "^ *foo" seem more natural ;)
02:08:56 <Axman6> ok, so, has someone got a simple, or canonical example of dependant types?
02:09:02 <path_> doesnt haskell allow infix operations? Can I say - 10 1?
02:09:06 <path_> to do 10 - 1
02:09:15 <Axman6> path_: (-) 10 1
02:09:16 <nlogax> path_: (-) 10 1
02:09:22 <path_> ah right
02:09:34 <quicksilver> path_: haskell does allow infix operations. "10 - 1" is infix.
02:09:35 <path_> and then I can flip it right
02:09:35 <path_> flip (-) 1
02:09:41 <Axman6> i seem to remember there being some dependant type thing where you'd have a list whose size was defined by its type?
02:09:45 <quicksilver> path_: I think you meant "how do I use an infix operator prefix?"
02:09:47 <path_> oops I meant prefix
02:09:49 <path_> yeah
02:13:15 <Axman6> quicksilver: surely you've got some nice examples of dependent types?
02:13:26 <roconnor> Ugh
02:13:29 <quicksilver> Axman6: lists of length n?
02:13:33 <Axman6> sure
02:13:48 <quicksilver> Axman6: cons :: a -> List a n -> List a (n+1)
02:13:56 <quicksilver> Axman6: tail :: List a (n+1) -> List a n
02:13:57 <quicksilver> and so on.
02:13:57 <Axman6> so it's that simple?
02:14:03 <quicksilver> the idea is that simple.
02:14:10 <Saizan> data Vec n a where VNil :: Vec Z a; VCons :: a -> Vec n a -> Vec (S n) a
02:14:13 <quicksilver> implementing is a ctulhoid nightmare.
02:14:16 <Axman6> is it implemented anywhere?
02:14:19 <quicksilver> agda
02:14:22 <quicksilver> epigram
02:14:26 <quicksilver> coq
02:14:26 <roconnor> this paper says that the category of continuous functions between Scott Domains form a CCC, but I learned yesterday that Domains have no coproduct, and every CCC has a coproduct, so now I'm confused.
02:14:40 <Saizan> in agda it's not hard, but it's not easy to implement agda i guess :)
02:14:47 <Axman6> i see, thanks quicksilver
02:14:49 <quicksilver> Saizan: yes, that's what I meant.
02:14:55 <quicksilver> implementing the language :)
02:15:08 <quicksilver> Axman6: you can somewhat encode that in haskell, as Saizan showed
02:15:14 <Axman6> yeah
02:15:15 <quicksilver> especially with extensions.
02:15:20 <quicksilver> but some parts get quite hard in haskell.
02:16:29 <fasta> What does newPrompt do?
02:16:58 <fasta> The paper that defines it says that is creates a new prompt, which is not terribly useful.
02:17:06 <fasta> it*
02:17:45 <Saizan> it works as a delimiter for the continuation
02:18:13 <fbru02> hey guys mornin
02:18:27 <Saizan> the control operators using that prompt will capture the continuation up to that point, afaik
02:18:45 <Saizan> s/k/u/
02:19:00 <fbru02> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3377#a3377 im still trying to use my RPN calculator , but im stuck making it print a value will anyone take a look at the code ?
02:20:22 <Saizan> fbru02: "liftIO $ print $ head prevStack" should work
02:20:48 <Saizan> assuming liftIO is in scope
02:21:06 <LeoD> @pl \f x -> zip (map f x) x
02:21:07 <lambdabot> join . (zip .) . map
02:21:52 <fbru02> Saizan: thanks, it compiles, but then i dont get any output in the the console, i was expecting a 3
02:22:57 <Saizan> fbru02: oh, it's pushNextState and popNextState that are wrong
02:23:02 <quicksilver> fbru02: popNextState and pushNextState don't do anything
02:23:06 <Axman6> :t map (second (undefined :: Int -> Bool)) . join zip
02:23:08 <lambdabot> [Int] -> [(Int, Bool)]
02:23:23 <Axman6> :t map (first (undefined :: Int -> Bool)) . join zip
02:23:24 <lambdabot> [Int] -> [(Bool, Int)]
02:23:26 <quicksilver> they just create functions which they throw away
02:23:35 <Axman6> :t map (first (undefined :: a -> b)) . join zip
02:23:36 <lambdabot> forall b d. [d] -> [(b, d)]
02:24:13 <Saizan> you've to do something like "runStateT (push 3 >> pop) []"
02:24:13 <fbru02> quicksilver: Saizan: thanks but i still dont see what should i change :(
02:24:45 <Saizan> where [] is the initial state
02:24:46 <Axman6> ok, i'm a little scared that i can write code like that so easily these days... i'm also scared that i understood the List a = Mu (Cons a) thing the other day...
02:25:04 <Saizan> (i assumed an empty stack was correct)
02:29:38 <fbru02> Saizan : yes empty stack should work, thanks, it compiled,  but i still don't see any output in the console :(
02:30:08 <Saizan> fbru02: did you enter 2 lines?
02:30:56 <fbru02> Saizan: no just the one you gave me , i thought that executed 2 actions
02:31:48 <Saizan> fbru02: what expression are you executing or what are you using as main?
02:31:56 <Axman6> you know what? Ada is pretty damn awesome. makes concurrent code really nice to write
02:32:07 <Saizan> *Main> runStateT (push 3 >> pop) []
02:32:07 <Saizan> 3
02:32:07 <Saizan> (3,[])
02:34:01 <fbru02> nice perfect
02:34:20 <fbru02> Saizan: i was making a stupid mistake but fixed it , thanks for spending the time to help me
02:34:43 <Fairweather> can someone explain this to me? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8399#a8399
02:35:09 <fasta> Saizan: a prompt is just a delimited continuation marker, right?
02:35:34 <Fairweather> it seems that using @ causes a type error
02:36:32 <fasta> I am not a native English speaker, but to me "delimited continuation handle" is a lot more clear than a "prompt", which can mean a million things.
02:36:33 <quicksilver> Fairweather: yes.
02:36:37 <Saizan> fbru02: np :) btw, did you get the idea behind? you've to connect your StateT actions together for them to communicate, runStateT brings you back to IO
02:36:42 <quicksilver> Fairweather: it's because they are "Left" in different Eithers.
02:36:56 <quicksilver> Fairweather: "Left err" on its own could be "Left" for any possible Right.
02:37:05 <quicksilver> Fairweather: but the symbol "s" is bound to some particular Right.
02:37:10 <quicksilver> (which is not the one you use below)
02:37:12 <Saizan> fasta: the name is somewhat historical i presume
02:37:32 <quicksilver> Fairweather: so sometimes you just have to write "Left err -> Left err" even though it seems odd.
02:37:44 <Saizan> however it's something like an handle indeed
02:38:37 <Fairweather> I see
02:38:49 <Fairweather> is there a way to get around this with type annotations?
02:39:01 <quicksilver> no.
02:39:03 <quicksilver> "s" has a type.
02:39:08 <quicksilver> you can't change that fact.
02:39:10 <fbru02> Saizan: now i get it :)  so doing runStateT and not passing around (connectiing, chaining) the actions means that i lose the state, right ?
02:39:17 <Fairweather> ok, thanks
02:39:24 <quicksilver> you could have a 'rebless' function which converts one Left to another
02:39:34 <quicksilver> :t let rebless (Left a) = Left a in rebless
02:39:36 <lambdabot> forall t t1 b. Either t t1 -> Either t b
02:39:44 <quicksilver> -- note t1 /= b
02:39:50 <quicksilver> but, I think that's not really any clearer
02:39:56 <Saizan> fbru02: well, runStateT gives you back the last state together with the result, so you could plug it into the next runStateT call
02:40:14 <quicksilver> fbru02: or you oculd just do *everyting* in your state monad
02:40:19 <Saizan> fbru02: but that's against the point of using StateT
02:40:26 <quicksilver> and only all runStateT once, at the outer level
02:41:19 <Fairweather> oh, I get it
02:41:21 <fbru02> Saizan: quicksilver : perfect !! im quite happy i get this, i like my RPN more than the ones that are out there thanks
02:41:24 <Fairweather> :) thanks, quicksilver
02:42:12 <nomeata> Data.Time.Clock.DiffTime has a Show instance, but no read instance :(
02:43:25 <quicksilver> nomeata: I think that is not true.
02:43:31 <quicksilver> nomeata: I think it's just in a different module
02:43:43 <quicksilver> the show instances are in Format and the read instances are in Parse or ParseTime or something
02:44:01 <nomeata> quicksilver: I found them there for UTCTime, but not DiffTime.
02:45:15 <quicksilver> nomeata: hmm. I think you're right. Odd.
02:45:31 <quicksilver> nomeata: ah well you can go to and from rational I guess
02:46:24 <nomeata> quicksilver: well, I can not change the Show instance, so I’d need to change the derived instances of every datatype I planned to use DiffTime in. I’ll just work with Integers for now...
02:46:27 <fasta> Saizan: it is the same for withSubCont, which could be named delimitedCallCC.
02:47:54 <fasta> Or delimitedCallCCFromMarker/handle, which would be even clearer.
02:58:30 <hackagebot> hscolour 1.14 - Colourise Haskell code. (MalcolmWallace)
03:03:07 <Axman6> "I just noticed that /r/conspiracy/ has only 8834 subscribers. Why is reddit suppressing the *real* numbers?" XD
03:03:21 <galdor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8401#a8401
03:03:29 <galdor> cabal build error on amd64
03:03:52 <SimonAdameit> besides usin filter, is there a function to delete all occurences of a specific element from a list?
03:04:07 <SimonAdameit> delete only removes the first
03:04:11 <quicksilver> no, that's what filter is for :)
03:04:13 <quicksilver> IMO.
03:04:21 <SimonAdameit> ok, thanks :)
03:04:27 <quicksilver> you could use delete + repeat
03:04:30 <quicksilver> but filter seems simpler
03:04:34 <quicksilver> :t delete
03:04:37 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
03:04:45 <quicksilver> no, not delete + repeat. \\ and repeat
03:04:52 <skorpan> filter (==x) is simple enough
03:04:58 <quicksilver> > [1,2,3,4,3,2,3,5,3] \\ repeat 3
03:05:00 <skorpan> or maybe that's filter (/=x)
03:05:05 <lambdabot>   mueval-core: Prelude.read: no parse
03:05:05 <lambdabot>  mueval: ExitFailure 1
03:05:09 <quicksilver> > [1,2,3,4,3,2,3,5,3] // repeat 3
03:05:11 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
03:05:24 <quicksilver> :t (\\)
03:05:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:08:15 <noteventime> Is there some implementation of map that doesn't have the Eq constraint on the type?
03:08:21 <noteventime> Map*
03:08:36 <skorpan> that sounds strange
03:08:41 <galdor> what should I do about the cabal build error?
03:08:44 <galdor> should I contact someone ?
03:09:31 <noteventime> CompactMap on hackage seems to not have the constraint
03:10:03 <EvilTerran> noteventime, how're you going to lookup in a mapping where you don't at least have an Eq constraint on the key type?
03:10:06 <roconnor> :( CompactMap isn't what I hoped it would be :D
03:10:10 <skorpan> noteventime: it uses Binary
03:10:51 <lilac> noteventime: in order to be able to do lookups, you need either a fixed key type or some class constraint on the key (or a type with only one inhabitant i guess)
03:10:57 <noteventime> EvilTerran: Can't you have the constraints on the operations on the type?
03:12:00 <quicksilver> noteventime: Certainly. Data.Map has no constraints on the type itself.
03:12:15 <noteventime> quicksilver: Ohh, them I must have done some mistake
03:12:22 <noteventime> Sorry :)
03:12:26 <quicksilver> however, without an Ord constraint you can only build empty maps and singleton maps
03:12:30 <quicksilver> and check their size
03:12:34 <quicksilver> so it's not terribly useful
03:13:50 <lilac> quicksilver: if you're still trying to convince Ashley Yakeley about the "right" way to do a Data instance for Fixed, Data.Map seems like a pretty good example
03:14:04 <noteventime> Indeed not, but it was more of an aesthetical issue :)
03:14:10 <lilac> it contans an Int (the size) but the Data instance is careful not to expose it
03:14:34 <quicksilver> lilac: He just didn't appear to see my point at all. I'm not sure what else I could say.
03:15:01 <quicksilver> but you're right that thta's a good example
03:16:01 <fasta> It seems that the p value on http://hackage.haskell.org/packages/archive/CC-delcont/0.2/doc/html/Control-Monad-CC.html#t%3APrompt is basically line noise. What is its use? E.g. Scheme doesn't have these explicit prompt parameters.
03:17:03 <roconnor> @type sequence
03:17:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:19:06 <path_> anyone know a list method that takes an element, a list and returns a list with the element prepended before each item of the list?
03:20:00 <roconnor> path_: \e l -> map (\x -> [e,x]) l ?
03:20:02 <quicksilver> map (x:)
03:20:11 <wjt> > (\x xs -> concat (map ((:[]) . (x:)) xs)) 3 [1..5]
03:20:12 <lambdabot>   No instance for (GHC.Enum.Enum [a])
03:20:13 <lambdabot>    arising from the arithmetic sequence...
03:20:33 <quicksilver> or do you mean intersperse?
03:20:42 <roconnor> > (\x xs -> concat (map ((x:) . (:[])) xs)) 3 [1..5]
03:20:44 <lambdabot>   [3,1,3,2,3,3,3,4,3,5]
03:20:45 <quicksilver> :t intersperse
03:20:47 <lambdabot> forall a. a -> [a] -> [a]
03:20:55 <quicksilver> > intersperse 3 [1..5]
03:20:57 <lambdabot>   [1,3,2,3,3,3,4,3,5]
03:21:22 <EvilTerran> > (\x -> foldr (\y -> (x:).(y:)) []) 0 [1..5]
03:21:24 <lambdabot>   [0,1,0,2,0,3,0,4,0,5]
03:21:37 <ski> andrewsw-afk : right
03:21:46 <path_> hmm not exactly, maybe its map (\item -> foo:item) items ?
03:22:05 <roconnor> @djinn Integer
03:22:06 <lambdabot> Error: Undefined type Integer
03:22:15 <EvilTerran> path_, what should the result be for 0 and [1..4], say?
03:22:28 <quicksilver> path_: that was my first suggestion
03:22:31 <quicksilver> path_: map (x:)
03:23:01 <path_> no its more like 'A'  ["a","b","c"] -> ["Aa","Ab","Ac"]
03:23:10 <path_> oh yeah
03:23:12 <path_> lol
03:23:16 <EvilTerran> ah, yeah, that'll be (map . (:))
03:23:17 <quicksilver> > map ('A':) ["a","b","c"]
03:23:19 <lambdabot>   ["Aa","Ab","Ac"]
03:23:28 <Axman6> > map ('A':) ["a","b","c"]
03:23:29 <lambdabot>   ["Aa","Ab","Ac"]
03:23:30 <path_> I didnt realise you could curry 2 variables :o
03:23:42 <EvilTerran> > (map . (:)) 'A' ["foo", "bar", "baz"]
03:23:43 <quicksilver> I think ou might be misusing the word 'curry'
03:23:43 <lambdabot>   ["Afoo","Abar","Abaz"]
03:23:52 <path_> yeah lol I might
03:24:50 <path_> ok here's the problem Im trying to solve. I got something but it doesnt even compile. Im gonna try and pastie it =p
03:28:32 <path_> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3378#a3378
03:28:48 <path_> Ive added as a comment there the behavior I expected
03:28:55 <path_> I sorta got it I thought
03:29:06 <path_> but now I have parse error
03:29:41 <quicksilver> path_: you need some () around your infixes
03:29:44 <path_> no not parse error it says
03:29:52 <path_> "couldnt match expected type"
03:29:53 <path_> oh
03:29:58 <quicksilver> (length xs - n + 1)
03:30:08 <quicksilver> also, there is no need to nest where clauses like that
03:30:18 <quicksilver> just put (foo,bar) in the same where clause
03:30:27 <path_> ah
03:30:31 <path_> with the same indentation?
03:30:33 <nomeata> Hi. Is there something in the standad libraries to implement simple locking (i.e. I only want one instance of a program to run at the time, and it should detect stale locks?)
03:30:44 <quicksilver> path_: yes
03:31:07 <path_> well now it says "parse error on input '='"
03:31:31 <quicksilver> the ( of (foo needs to line up with subseq
03:31:48 <path_> yeahI got that :)
03:31:55 <noteventime> Is the interpretation of the insert function on page 2 in "Denotational design with type class morphisms" really correct? o_o
03:31:56 <path_> hmm but the first clause, depends on the second clause
03:31:58 <path_> is that ok
03:32:06 <path_> cause foo and bar are defined below
03:32:11 <path_> oh wait I havent used bar
03:32:19 <noteventime> Ohh Sorry
03:32:19 <Axman6> nomeata: like a semaphore? try Control.Concurrent.QSem
03:32:20 <noteventime> It is
03:32:51 <nomeata> Axman6: I meant a lock in between processes, not within one.
03:33:09 <quicksilver> path_: that is fine
03:33:21 <path_> no I mean, I meant to
03:33:25 <quicksilver> path_: in haskell, lists o definitions at the same level are mutually recursive
03:33:30 <path_> thats function isnt even doing what I wanted
03:33:31 <path_> oh
03:33:32 <path_> ok
03:34:19 <nomeata> hmm. maybe what’s in System.IO.Posix, file:///usr/share/doc/ghc6-doc/libraries/unix/System-Posix-IO.html#7
03:34:38 <fasta> What happened to the MatrixComponent Double instance in Graphics.Rendering.OpenGL.GL.CoordTrans?
03:34:51 <path_> I modified it to this -> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3378#a3379
03:35:03 <path_> I still get the parse error though
03:35:33 <fasta> According to the documentation it exists, according to the source there is some _gldouble instance, which I assume is translated by some preprocessor to a Double, but according to the compiler it doesn't exist.
03:35:38 <path_> and the parse error is at the comma
03:36:19 <quicksilver> path_: I don't get a parse error
03:36:20 <stanv> I can't understand declaration: instance (Show a, Show b) => Show (a,b) where show (x,y) = "(" + show x ++ "," ++ show y ++ ")"
03:36:26 <quicksilver> path_: I get that 'i' isn't defined.
03:36:57 <path_> hmm let me just check there's no different between the pastie and what I have on my machine:x
03:36:59 <quicksilver> which is true. I didn't read your code closely enough. You do need nested where clauses because you're trying to use the local variable i
03:37:14 <quicksilver> path_: maybe you're using tabs and they got convereted to spaces when you pasted it
03:37:15 <Raevel> heh, i missed that too
03:37:38 <path_> ah
03:37:44 <quicksilver> fasta: There was some talk of changing GLDouble to a newtype but I didn't think that had happened yet
03:38:11 <path_> yeah now I get not in scope i
03:38:12 <path_> hmm
03:38:53 <path_> should I go back to nested wheres?
03:39:09 <roconnor> stanv: what confuses you?
03:40:03 <path_> i is meant to be whatever the function subseq is called with
03:40:05 <path_> as a parameter
03:40:08 <Axman6> stanv: what don't you understand about it?
03:40:16 <stanv> instance (Show a, Show b) => Show (a,b)
03:40:18 <quicksilver> path_: yes, you should go back to nested wheres. sorry for confusing you.
03:40:19 <path_> I dont know how to pass it to the last line : /
03:40:24 <path_> ok np
03:40:44 <Axman6> stanv: it means that to be able to show something of type (a,b), both the a and the b have to be instances of Show too
03:40:48 <roconnor> stanv: that line says that for the type (a,b) to be showable, that we first require that both a and b be each showable types.
03:41:23 <roconnor> without the (Show a) constraint, the code "show x" would not be allowed
03:41:33 <roconnor> similarly for (Show b) and the code "show y"
03:41:46 <stanv> what is `=> Show (a,b)' ?
03:41:59 <roconnor> the instance we are going to define
03:42:22 <stanv> we define (Show a, Show b)
03:42:23 <roconnor> one could try to write 'instance Show (a,b) where show (x,y) = "(" + show x ++ "," ++ show y ++ ")"'
03:42:28 <roconnor> with no constraints
03:43:01 <roconnor> but GHC would say something like "cannot find instance of Show a needed by the code 'show x'"
03:43:06 <fasta> quicksilver: I am sure they broke it already in a released version.
03:43:15 <fasta> quicksilver: I just downgraded and it works again.
03:43:17 <quicksilver> fasta: odd.
03:43:25 <quicksilver> fasta: which version were you using? the one that didn't work?
03:43:40 <fasta> quicksilver: the latest.
03:44:07 <fasta> quicksilver: by "doesn't work" I mean "is not backwards compatible".
03:44:18 <Axman6> stanv: it's like this:
03:44:22 <Axman6> :t (<)
03:44:24 <lambdabot> forall a. (Ord a) => a -> a -> Bool
03:44:44 <quicksilver> perhaps a bug in the refactoring over OpenGLRaw
03:44:56 <Axman6> stanv: what that says is: to compare two a's, the a type has to have implemented the Ord class
03:46:14 <stanv> ok... I need some time to understand it. thanks
03:46:56 <roconnor> apparently f : Cont Omega is a quantifier in a topos with subobject classifier Omega
03:48:04 <stanv> now clear! thanks :)
03:50:40 <path_> uhh I think I still need some help :/, I messed up somewhow. -> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3378#a3380
03:50:57 <path_> if you dont mind QS
03:52:16 <quicksilver> path_: and the problem now is? It gives an error, or it just doesn't do what you want?
03:52:49 <path_> well type errors really. Which in this case Im guessing means it doesnt do what I think it does lol
03:52:58 <path_> couldnt match expected type [int]
03:53:06 <path_> against inferred type a-> a->[a]
03:53:11 <quicksilver> I think you want () around (subseqs (n-1) bar)
03:53:19 <fasta> With delimited-continuations, how can you say something like   X:  print n;n=n+1 if n<20 goto Y else return  Y:  print n;n = n+1; goto X?
03:53:20 <quicksilver> concatMap (\item -> (last foo):item)subseqs (n-1) bar
03:53:29 <quicksilver> this calls concatMap with four parameters
03:53:36 <fasta> (X and Y are labels. )
03:53:37 <path_> oh in general when do I need brackets?
03:53:43 <quicksilver> the lambda, subseqs, (n-1) and bar
03:53:55 <path_> around the right most function always?
03:53:57 <fasta> I am looking for a case where it is useful to have two newPrompt calls.
03:54:40 <quicksilver> path_: no.
03:54:45 <quicksilver> path_: you must think abtu what it means, that's all
03:55:00 <quicksilver> path_: do you want to pass 'subseqs', the function, to concatMap ?
03:55:03 <quicksilver> (No)
03:55:12 <quicksilver> You want to pass the result of (subseqs (n-1) bar)
03:55:23 <path_> right
03:55:23 <quicksilver> or, to ask the same question a slightly different way
03:55:30 <quicksilver> is (n-1) an argument of concatMap, or subseqs?
03:55:37 <quicksilver> it is the former but you wanted it to be the latter.
03:56:04 <quicksilver> in "f g x" f is given two parameters, g and x
03:56:16 <quicksilver> in "f (g x)" f is given one parameter, the (result of) "g x"
03:56:18 <quicksilver> make sense?
03:56:23 <path_> yeah
03:56:32 <path_> hmm
03:57:26 <path_> I modifyied it again and I now end up with cannot construct the infinite type a = [a] -> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3378#a3381
03:57:57 <path_> should the result for 0 be [[]] ?
03:58:03 <path_> I assumed [] = [[]]
03:58:10 <Kim__> I recall haskell functions (in reality) only take one parameter; given more parameters the functions just return another function… is this correct?
03:58:29 <quicksilver> path_: [[]] is definitely quite different from []
03:58:33 <quicksilver> > length [[]]
03:58:36 <lambdabot>   1
03:58:37 <quicksilver> > length []
03:58:39 <lambdabot>   0
03:58:39 <nlogax> Kim__: yep
03:58:47 <path_> hmm
03:58:50 <opqdonut> [] and [[]] can be of the same type tho
03:59:03 <path_> oh but it should be [] though. Yeah I meant the same type
03:59:04 <opqdonut> [[a]] is the most general type they both belong to
03:59:08 <Kim__> nlogax: Awesome
03:59:41 <path_> Im trying to given a list and integer i, return all combinations of length i
03:59:50 <path_> so if 0 is the integer I return an empty list
04:00:03 <quicksilver> I think [[]] is a better answer actually
04:00:08 <nlogax> Kim__: that's why the type signatures look like they do, when you give it one argument, you munch up one thing in the sig and the results is a function with the new signature
04:00:09 <quicksilver> but I don't think it will solve your type error :)
04:00:21 <poe> > ((sequence .) . replicate) 1 [1,2,3]
04:00:23 <lambdabot>   [[1],[2],[3]]
04:00:25 <poe> > ((sequence .) . replicate) 2 [1,2,3]
04:00:27 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
04:00:36 <Kim__> nlogax: So that's why there's all those funky arrows…
04:00:49 <path_> poe yeah but that has repeats like [2.2]
04:00:58 <path_> [2,2]
04:01:19 <quicksilver> path_: well anyway I could solve your question another way but that's not the point, is it?
04:01:26 <path_> yeah
04:01:27 <quicksilver> path_: the point is to help you debug your code so you understand the problems.
04:01:51 <quicksilver> path_: I think you need to think about what 'subseq' and 'subseqs' return
04:01:55 <path_> well Id love both. To understand where I went wrong and eventually how I improve my level of thinking to make it shorter :)
04:02:01 <path_> hmm ok
04:02:05 <quicksilver> (i.e. lists of lists, or just lists)
04:02:35 <quicksilver> subseq currently just returns a list.
04:02:41 <path_> can I specify a type signature for subseq inside the where clause? so that the compiler can tell me that it matches or doesnt?
04:02:41 <quicksilver> because it concats the return of the map
04:02:46 <quicksilver> yes, you can
04:02:52 <quicksilver> subseq :: ....
04:03:09 <quicksilver> I think it would be a good idea to put types on subseqs and subseq
04:04:02 <path_> right, let me give that a shot :). In general its a -> b -> c if a is parameter 1, b is parameter 2 and c is the output correct?
04:04:08 <quicksilver> right
04:04:55 <Kim__> How would I go on about creating an infinite list with the following pattern: [ (1, 2, 3), (4, 5, 6), (7, 8, 9) ] and so on? I tried “[ (a, b, c) | a <- [1,4..], b <- [2, 5..], c <- [3,6..] ]” but it only evaluates c (obviously).
04:04:57 <etpace_> :t [[]]
04:04:58 <lambdabot> forall a. [[a]]
04:05:01 <EvilTerran> path_, in general, if the type is "a -> b", then a is the parameter, and b is the result
04:05:14 <path_> ok
04:05:43 <poe> > [(i,i+1,i+2) | i <- [1,4..]]
04:05:43 <EvilTerran> path_, as -> is right-associative, "a -> b -> c" is the same as "a -> (b -> c)", ie, "take something of type a, give back something that takes something of type b and give back something of type c
04:05:45 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23...
04:05:54 <path_> aha
04:05:54 <EvilTerran> *and gives back
04:05:58 <EvilTerran> ?type map
04:06:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:06:04 <EvilTerran> ?type map (+1)
04:06:06 <lambdabot> forall a. (Num a) => [a] -> [a]
04:06:25 <Kim__> poe: Oh… doh, thanks :P
04:07:55 <poe> > unfoldr (Just . splitAt 3) [0..] -- list are more malleable :)
04:07:57 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,...
04:09:14 <lilac> > zip3 [1,4..] [2,5..] [3,6..]
04:09:15 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23...
04:09:44 * Kim__ is confused
04:10:06 <Kim__> Thanks yet again, that'll take some headwrapping around
04:10:13 <poe> > [(i,j,k) | i <- [1,4..] | j <- [2,5..] | k <- [3,6..]]
04:10:14 <EvilTerran> > map (take 3) . iterate (drop 3) $ [1..]
04:10:15 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23...
04:10:17 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
04:10:19 <poe> more similar to yours
04:10:36 <EvilTerran> ([[a]] instead of [(a,a,a)], again, but similar)
04:10:38 <lilac> poe's most recent one is a GHC extension
04:11:29 <Kim__> I'm still reading tutorials, haven't seen the dot operation before though
04:11:30 <lilac> the zip3 one is [(a,b,c)] which might possibly be important
04:12:52 <hackagebot> elerea-examples 1.0.2 - Example applications for Elerea (GergelyPatai)
04:13:51 <EvilTerran> ?src (.)
04:13:51 <lambdabot> (f . g) x = f (g x)
04:15:08 <path_> ok I think I got the types write now
04:15:10 <EvilTerran> Kim__, (.) is function composition; as you can see by that source, it's a normal operator, definable in pure haskell
04:15:11 <path_> but the answer wrong
04:15:11 <path_> lol
04:15:46 <Kim__> ?src $
04:15:47 <lambdabot> f $ x = f x
04:15:52 <Kim__> :o
04:16:07 <EvilTerran> $ does nothing but save on parentheses
04:16:24 <Kim__> Trying to figure out how to rewrite the map/take/iterate/drop expression
04:16:47 <lilac> f . g . h $ x y = (f . g . h) (x y) = ((f . g) . h) (x y) = (f . g) (h (x y)) = f (g (h (x y)))
04:16:48 <EvilTerran> it's very low precedence, so <some expression> $ <some other expr> usually means (<some expression>) (<some other expr>)
04:18:04 <EvilTerran> > iterate (drop 3) [1..]
04:18:06 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:18:32 <EvilTerran> er, that doesn't really illustrate anything. nvm. <.<  >.>
04:18:40 <Kim__> hehe
04:18:42 <lilac> > map (take 3) (iterate (drop 3) [1..])
04:18:44 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
04:18:45 <EvilTerran> > iterate (drop 3) [1..10]
04:18:47 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10],[],[],[],[],[],[],...
04:19:29 <Kim__> ?src iterate
04:19:35 <lambdabot> iterate f x =  x : iterate f (f x)
04:21:10 <lilac> > ap (fmap fmap take) (flip iterate [1..] . drop) 3
04:21:12 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
04:24:30 <path_> oops, gtg, thanks for the help so far
04:24:33 <path_> bbl
04:24:40 <path_> think Im getting it though
04:28:49 <lilac> > snd $ mapAccumL (\xs n -> swap $ splitAt n xs) [1..] [3,1,4,1,5,9]
04:28:51 <lambdabot>   [[1,2,3],[4],[5,6,7,8],[9],[10,11,12,13,14],[15,16,17,18,19,20,21,22,23]]
04:29:06 * EvilTerran gets to thinking about a function (showToDepth n x) that shows x, except eliding everything beneath n constructors (with a "..." or something)
04:29:18 * EvilTerran suspects a Data constraint would be enough
04:29:33 <quicksilver> I would think so, yes.
04:29:39 <Saizan> considering you can write gshow with it..
04:29:40 <quicksilver> of course, Data instances are allowed to lie to you :)
04:29:50 <quicksilver> but assuming you believe the data instance then yes, that would work.
04:30:03 <quicksilver> I bet mmorrow has an altogether more evil way of doing it, though.
04:30:14 <EvilTerran> is "Data instances can lie to you" any more of a problem than "Monad instances can lie to you"?
04:30:22 <quicksilver> they're more likelyt o, I think.
04:30:26 <quicksilver> There are good reasons for them to do so.
04:30:39 <quicksilver> it makes sense for a Data instance to lie about implementation details that aren't part of the abstraction.
04:30:39 <EvilTerran> i'm not sure what you mean
04:30:44 <EvilTerran> ahh, of course
04:30:56 <quicksilver> for example, Data.Map's Data instance does not admit that it contains an Int
04:31:07 <quicksilver> we were just talking about this earlier.
04:31:08 <lilac> Data can and should lie sometimes, whereas Typeable absolutely must not
04:31:14 <quicksilver> right.
04:31:23 <quicksilver> Typeable really should be a compiler thing
04:31:38 <quicksilver> because a lying typeable instance can cause arbitrary behaviour
04:31:50 <quicksilver> (in, admittedly, rather obscure circumstances)
04:32:00 <lilac> i recall someone suggesting that Typeable should /only/ be derivable (no user-written instances allowed)
04:32:08 <quicksilver> further more, the compiler-provided Typeable instance is broken anyway.
04:32:29 <quicksilver> it should actually embed the package + version number
04:33:34 <lilac> hah, good point :)
04:33:53 <lilac> does the compiler know the name and version number of the package it's building?
04:35:48 <quicksilver> lilac: it must do, because it shows full package+version+type things it its error messages when you get a diamond dependency
04:36:28 <quicksilver> lilac: you get things like "expected: bytestring-1.1.4:Data.Bytestring, actual: bytestring-1.1.5:Data.Bytestring"
04:37:00 <quicksilver> of course, assuming that each package version breaks the concrete type rep is a pessimistic assumption.
04:37:10 <quicksilver> it may well be that unsafeCoercing between those two is safe
04:37:13 <lilac> it knows that for dependencies. on the other hand, if you change the version number of the package you're building, cabal build only rebuilds files you changed
04:37:16 <quicksilver> ...and if it is, then the Typeable instance is actually correct.
04:37:37 <quicksilver> but in *general* it's certainly not safe.
04:38:11 <quicksilver> in fact, Typeable then becomes a useful tool for working in a diamond dependency situation
04:38:14 <quicksilver> haha.
04:38:16 <quicksilver> unexpected consequence.
04:38:31 <lilac> unsafeCoerceBetweenVersions :)
04:38:34 * quicksilver nods
04:44:15 <Stinger> hmm
04:44:34 <Stinger> thinking about getting RWH + another haskell book
04:44:44 <Stinger> anything that would complement that well?
04:45:16 <Stinger> have read bits of SoE before
04:45:25 <Raevel> was just about to say soe
04:45:37 <Stinger> heh well its not too dear so I may get that one
04:45:59 * dqd likes The Craft of Functional Programming.
04:46:04 <ski> > mapM (State . splitAt) [3,1,4,1,5,9] `evalState` [1..]  -- lilac
04:46:06 <lambdabot>   [[1,2,3],[4],[5,6,7,8],[9],[10,11,12,13,14],[15,16,17,18,19,20,21,22,23]]
04:46:07 <Stinger> yeah just looking at that one now
04:46:29 <quicksilver> ski: cute
04:46:57 <quicksilver> I mean, it's not news to me that mapAccum is just mapM in state
04:47:05 <quicksilver> but that came out nicer than I woudl have expected :)
04:47:15 <Stinger> which was first? hugs or ghc?
04:47:45 <ski> hbc ?
04:49:24 <quicksilver> depends if you separate hugs from gofer
04:50:01 <quicksilver> if you consider them the same program, then gofer is the eldest of the three by far, I think
04:51:42 <Stinger> holy hell
04:52:22 <Stinger> Hutton is $42 paperback, $124 hardcover
04:52:31 <Stinger> is the cover solid gold?
05:04:49 <ray> stinger: no, then it wouldn't be "hard"cover
05:04:57 <ray> it's carbon nanotubes
05:06:21 <solrize> http://flint.cs.yale.edu/flint/publications/smc.html   :-O wowwww
05:06:34 <Saxcrazedmaniac> hi guyz
05:08:15 <Josh_> hi Asztal and cycloid
05:08:37 <Josh_> here's 569 users here but barely anyone is talking...
05:08:41 <Josh_> **there's
05:09:22 <Asztal> that's just how IRC is
05:09:25 <Asztal> @users
05:09:25 <lambdabot> Maximum users seen in #haskell: 658, currently: 568 (86.3%), active: 9 (1.6%)
05:09:43 <ray> the only haskell feature better than the monomorphism restriction is n+k patterns
05:09:49 <Josh_> i thought IRC would be different
05:10:07 <Josh_> but i guess i was being naive
05:10:13 * solrize used an n+1 pattern recently 
05:10:19 <solrize> it worked out nicely
05:10:27 <int-e> shame on you.
05:10:29 <Josh_> dats a simple sequence
05:10:39 <ray> wow, you're right, there's no lynch mob
05:10:45 <ray> that means it's slow right now
05:10:45 <Josh_> O_o
05:11:28 <Josh_> IRC is very overrated
05:11:38 <opqdonut> irc is underrated
05:11:41 <benmachine> nah it's lovely
05:11:53 <Josh_> barely anyone talks
05:11:59 <opqdonut> Josh_: if all the 569 really were talking at the same time it'd be hell
05:12:03 * benmachine is barely anyone
05:12:09 <ray> actually, calling irc overrated might spawn a better lynch mob, because it's believable
05:12:25 <opqdonut> mut yeah, this is a low-activity period
05:12:27 <solrize> so why do Haskellers tolerate C instead of wanting a more type-safe language for low level primitives?
05:12:34 <opqdonut> guess it's early morning in the states or something
05:12:50 <Josh_> opqdonut: i mean a small percentile of the people connected
05:13:02 <ray> solrize: what are you talking about?
05:13:05 <int-e> solrize: C is pretty good at what it does. But there's CMM because C wasn't enough for some things.
05:13:19 <int-e> @quote assembler
05:13:19 <lambdabot> dons says: that's 3 things i've never seen in the one sentence before: my assembler .. a bunch of type classes .. a natural syntax
05:14:00 <solrize> ray, for example a lot of the GHC runtime is written in C, and lots of stuff in the library system is FFI-wrapped C functions
05:14:29 <ray> yeah
05:14:48 <ray> that's not really tolerating
05:14:49 <int-e> and there's a lot of good code out there written in C which would be a shame not to be able to reuse.
05:14:55 <ray> because c is perfectly good there
05:15:22 <Josh_> ok bye everyone, i'm going
05:15:23 <solrize> "the last good thing written in C was schubert's 9th symphony"
05:15:31 <ray> in the long run i'd like to see it in haskell, but it works out fine
05:15:45 <Josh_> wait, what exactly is haskell??
05:15:55 <ray> http://haskell.org/
05:16:16 <Josh_> kk thnx
05:16:30 <m_g> Why do you join if you do not know haskell?
05:16:38 <int-e> m_g: to learn?
05:16:55 <ray> well, this is one of the largest channels on freenode
05:17:05 <Josh_> ok i skimmed the 1st paragraph
05:17:13 <drwho> umm sorry about this simple question but I forgot
05:17:23 <drwho> how do I do inline comments in haskeel?
05:17:23 <Josh_> does anyone know how i bookmark this channel??
05:17:28 <drwho> haskell*
05:17:31 <int-e> drwho: {- comment -}
05:17:32 <m_g> drwho: --
05:17:38 <drwho> ok thanks
05:18:25 <solrize> i feel like haskell needs a low level imperative embedded DSL that still uses Haskell types, and GHC could be written sort of like Orbit (which had an embedded assembler with S-expressions for machine instructions)
05:18:45 <solrize> Orbit = Scheme compiler from way back
05:18:48 <ski> Josh_ : you could enter "#haskell" in "channels to join on connect", somewhere in the server config in X-Chat, iirc
05:19:01 <quicksilver> solrize: it has one :)
05:19:07 <quicksilver> solrize: although its' kind of the opposite of embedded.
05:19:14 <solrize> you mean C? :)
05:19:18 <quicksilver> and I mean GHC, of course.
05:19:28 <quicksilver> GHC has a low level imperative language which still uses haskell types.
05:19:33 <quicksilver> and Haskell is an embedded DSL in this.
05:19:44 <Josh_> ski: thank you, i just think i figured it out
05:20:01 <quicksilver> there are pros and cons to this approach.
05:20:07 <quicksilver> It means that more of GHC appears to be written in haskell.
05:20:10 <solrize> i don't understand what you mean
05:20:12 <quicksilver> but on the other hand it actually isn't.
05:20:18 <solrize> what language?  is that a joke?
05:20:22 <quicksilver> not at all.
05:20:24 <quicksilver> it doesn't have a name.
05:20:30 <quicksilver> (as far as I know)
05:20:48 <solrize> i mean, are things like the RTS garbage collector written in it?
05:20:59 <quicksilver> no, it's not quite good enough for that.
05:21:00 <ski> (Josh___ : Server List -> Freenode -> Edit -> Channels to join)
05:21:06 <quicksilver> but the IO monad is.
05:21:18 <quicksilver> and MVars and stuff are, to some extent at least.
05:21:27 * benmachine mentally inserts a second colon in ski's line out of habit
05:22:26 <solrize> i still don't get it, you mean it's possible to write a gc in the i/o monad with mvars?  sure, true in principle, but wouldn't it suck?
05:23:58 <int-e> Most of the MVar operations are primitives.
05:26:12 <int-e> (Written in CMM, which really doesn't know about Haskell types anymore, as far as I understand.)
05:29:11 <solrize> hey dcoutts
05:37:58 <EvilTerran> quicksilver, this is something other than GHC Core?
05:43:44 * tibbe tries to remember Edward Kmett's handle.
05:44:56 <ski> edwardk
05:48:22 <quicksilver> EvilTerran: yes.
05:48:47 <quicksilver> solrize: well, that wasn't my point, no.
05:49:09 <quicksilver> EvilTerran: it it something that looks like haskell, smells like haskell, but isn't haskell
05:50:19 <EvilTerran> quicksilver, er, what does haskell smell like?
05:50:22 <EvilTerran> ... curry? :P
05:51:01 <quicksilver> EvilTerran: GHC.IO is written in it, for example.
05:51:07 <Baughn> Is it possible to make cabal run derive on some particular .hs files (without a too-complex Setup.hs)?
05:51:48 <quicksilver> actually there aren't striking examples in that file.
05:52:45 * Baughn wonders if he can do it with TH instead
05:53:12 <quicksilver> EvilTerran: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html
05:53:17 <quicksilver> EvilTerran: that's a better example
05:53:26 <Baughn> ..ah. Yay.
05:53:57 <Lemmih> quicksilver: That's not Haskell?
05:54:03 <quicksilver> Lemmih: I would argue not.
05:54:04 <int-e> Baughn: Yes, TH works nicely with derive. import Data.DeriveTH $(derives [makeFoo, makeBar] [''Type1, ''Type2])
05:54:09 <quicksilver> Lemmih: it's an impure language.
05:54:19 <Baughn> int-e: Yep, I just found that module (by accident).
05:54:21 * int-e is too slow.
05:54:21 <quicksilver> Lemmih: some of those # primitives actually have genuine side-effects.
05:54:44 <quicksilver> Lemmih: for example, that file contains the implementation of unsafePerformIO
05:54:52 <quicksilver> unsafePerformIO is about as impure as it gets :)
05:55:02 <Baughn> quicksilver: You speak heresy. unsafePerformIO does not have an implementation.
05:55:23 <quicksilver> Baughn: exactly.
05:55:26 <quicksilver> so that language is not haskell.
05:55:41 <Baughn> Ah.
05:55:58 <quicksilver> underlying GHC's haskell, is an impure language which looks very very much like haskell
05:56:05 <quicksilver> but has unregulated side-effects
05:56:09 <quicksilver> and even mutability
05:56:15 <quicksilver> (although the mutability is very rarely used)
05:56:18 <Lemmih> quicksilver: Would you say that the FFI isn't Haskell?
05:56:19 <EvilTerran> quicksilver, i see.
05:56:38 <tibbe> @seen edwardk
05:56:39 <lambdabot> I saw edwardk leaving #haskell 1d 4h 4m 52s ago, and .
05:56:47 <Baughn> Lemmih: The FFI is at least part of.. a haskell standard
05:56:51 <tibbe> @help tell
05:56:52 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
05:56:54 <quicksilver> Lemmih: no, I wouldn't. And I agree that this is splitting hairs to some extent.
05:57:02 <Baughn> The FFI implementation, wouldn't be haskell
05:57:02 <quicksilver> Lemmih: but the FFI, used correctly, is pure.
05:57:50 <tibbe> @tell edwardk I'd love to discuss iteratees and monoids with you some day. I've been playing around with resumable parsers for HTTP servers for a while and started a fold/monoid based library for parallel processing ala Google's Sawzall
05:57:50 <lambdabot> Consider it noted.
06:16:44 * nomeata thinks that Data.Maybe lacks a "justIf :: Bool -> a -> Maybe a" function.
06:17:28 <nomeata> Or better "justIf :: a -> Bool -> Maybe a" so that one can write "value `justIf` valid"
06:17:38 <kpreid> @pl \b a -> guard b >> a
06:17:42 <lambdabot> (>>) . guard
06:17:48 <kpreid> @pl \a b -> guard b >> a
06:17:49 <lambdabot> flip ((>>) . guard)
06:18:01 <kpreid> @type (>>) . guard
06:18:10 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
06:18:30 <nomeata> @pl \b a -> guard b >> return a
06:18:30 <lambdabot> (. return) . (>>) . guard
06:18:47 <nomeata> @type (. return) . (>>) . guard
06:18:50 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
06:18:50 <endojelly> contrived.
06:18:59 <kpreid> Oh, I missed that you had a -> Maybe a, not Maybe a -> Maybe a
06:19:26 <kpreid> @djinn a -> Bool -> Maybe a
06:19:26 <lambdabot> f a b =
06:19:27 <lambdabot>     case b of
06:19:27 <lambdabot>     False -> Nothing
06:19:27 <lambdabot>     True -> Just a
06:19:54 <nomeata> endojelly: I don’t think it’s contrived. I often find myself writing the ididom "if a then Just v else Nothing"
06:20:19 <nomeata> where "v `justIf` a" would be much nicer to read and write.
06:20:48 <kpreid> @. pl djinn a -> Bool -> Maybe a
06:20:48 <lambdabot> (line 3, column 11):
06:20:48 <lambdabot> unexpected ">" or "-"
06:20:48 <lambdabot> expecting variable, "(", operator or end of input
06:20:52 <kpreid> (shame)
06:21:22 <endojelly> nomeata, nono, I get that that's very useful (I also find myself in that situation quite often), I just think that the expression itself is pretty contrived. to me, djinn's output with case is much clearer than (. return) . (>>) . guard
06:21:36 <endojelly> I get that it's pretty elegant und would probably use it (if I came up with it), still contrived 8)
06:21:51 <pozic> There isn't a way to obtain the constructor for a given value, is there?
06:22:10 <nomeata> pozic: no, constructors are not first class citizens in Haskell
06:22:11 <dschoepe> pozic: pattern matching?
06:22:25 <endojelly> pozic, your data type could have constructors with different arity
06:22:29 <nomeata> endojelly: ok. I don’t care how it’s done, as long as it ends up in Data.Maybe or somewhere :-)
06:22:31 <kpreid> pozic: Data.Generics lets you do that 'sort of'
06:22:37 <endojelly> pozic, so then you suddenly have the problem that they have different types.
06:22:47 <endojelly> but yeah, you can do a lot with generics
06:22:48 <nomeata> Are there more people here that would think it’s useful?
06:22:56 <pozic> endojelly: but I am only interested in those constructors with the same type.
06:23:15 <endojelly> nomeata, I'm all for it. my last project was *full* of that idiom
06:23:47 <endojelly> pozic, what do you mean? what I mean is, imagine you have data Foo = Foo1 Int | Foo2 Int Int
06:24:14 <endojelly> pozic, and value v of type Foo. now, which type would the expression "constructorOf v" have?
06:24:22 <endojelly> pozic, Int -> Foo or Int -> Int -> Foo?
06:24:37 <pozic> endojelly: you are misunderstanding.
06:24:39 <kpreid> pozic: you can, of course, write a function specific to your data type which returns the constructors
06:24:44 <endojelly> pozic, I am?
06:25:22 <pozic> How does this Data.Generic stuff work then in the case where I want to select all constructors with type Int -> Foo a -> Foo a?
06:25:35 <endojelly> pozic, then please elaborate what I am misunderstanding
06:26:07 <kpreid> pozic: lots of existentials
06:26:10 <endojelly> or what exactly you are trying to do
06:26:13 <kpreid> better to write your own function
06:27:03 <pozic> endojelly: you are right in that what you said is impossible, but I was talking about data Foo = Foo1 Int | Foo2 Int | ... | FooBar Int Int and then given a value of type Foo, return the Foo1, Foo2 constructors and a Nothing when given a Foobar.
06:27:19 <kpreid> e.g. getConstr (Left x) = Left; getConstr (Right x) = Right; getConstr :: Either a a -> (a -> a -> Either a a)
06:27:21 <kpreid> Er
06:27:24 <kpreid> e.g. getConstr (Left x) = Left; getConstr (Right x) = Right; getConstr :: Either a a -> (a -> Either a a)
06:27:56 <pozic> kpreid: yes, I had that plan before I got here, but all the boiler plate...
06:28:41 <nomeata> endojelly: http://hackage.haskell.org/trac/ghc/ticket/3446
06:29:04 <endojelly> pozic, so a function that returns Just Constr if the constructor Constr has the right arity... besides the fact that it seems pretty ugly to me, are you sure that this will save you a lot of boilerplate? you'd have to handle the Maybe
06:29:06 <pozic> toConstr in Data.Generics is probably useful.
06:29:54 <endojelly> nomeata, very nice!
06:31:29 <pozic> But there is no way to turn that Constr into a function, never mind then.
06:31:58 <quicksilver> Data.Generics can solve your problem, but it will be very painful
06:32:10 <quicksilver> Data.Generics is a really frustrating API, or at least I find it so ;)
06:33:44 <endojelly> pozic, well, now I want to try it out anyway 8) wait a minute
06:34:31 <kpreid> nomeata: the "justIf" name, while appropriate in here, reminds me of a certain book on logic I read which used "just in case" to mean "if"
06:35:17 <endojelly> oh, sorry, didn't know there actually was a data type "Constr" in generics. I didn't mean that
06:36:56 <kpreid> I remember using Data.Generics extensively for something, but not what
06:38:23 <Gracenotes> @hoogle char
06:38:24 <lambdabot> Text.Parsec.Char char :: Stream s m Char => Char -> ParsecT s u m Char
06:38:24 <lambdabot> Text.ParserCombinators.ReadP char :: Char -> ReadP Char
06:38:24 <lambdabot> Text.PrettyPrint.HughesPJ char :: Char -> Doc
06:38:35 <kpreid> popular name
06:39:36 <Gracenotes> quite so... /me is not using it top-level though
06:40:48 <Zharf> chapter 8 of yaht really got me confused o.O
06:41:02 <Gracenotes> making a nice corecursively constructed IntMap atm
06:41:54 <kpreid> corecursively?
06:42:14 <arcatan> nstruct and co-nstruct
06:42:30 <ray> induction and coinduction
06:42:31 <nomeata> contranstruct?
06:42:38 <Gracenotes> ha
06:42:58 <nomeata> worker, coworker, contraworker...
06:43:13 <lilac> biworker
06:43:28 <lilac> contravariant homworker
06:43:39 <Gracenotes> it's an IntMap from node number -> node for directed acyclic graphs. sinks are the base case, and the nodes refer to each other
06:43:41 <nomeata> usine, cousine, contrausine
06:43:46 <kpreid> ah
06:43:49 * kpreid suspected
06:43:57 <lilac> contraffee?
06:44:00 <ray> #haskell naturally transforms into a storm of category theory puns
06:44:03 <endojelly> pozic, nah, sorry, doesn't work out like I want it to
06:44:08 <kpreid> so I can say my GraphLife is a corecursive scheme
06:44:24 <endojelly> pozic, although this might help you: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Data-Data.html#2
06:44:49 <lilac> does the GHC contrafrontend turns haskell into contrare?
06:44:53 <ray> in haskell the line between data and codata is blurry
06:45:01 <fasta> I wonder who 'invented' ->, instead of =. To me it seems like a terrible idea in hindsight.
06:45:13 <lilac> fasta: you mean for case and lambda?
06:45:32 <Gracenotes> kpreid: the entire line is something like finalMap = IntMap.fromList . map (\c -> some expression involving finalMap) . IntMap.keys $ char
06:45:36 <ray> it makes sense in lambda
06:45:38 * kpreid nods
06:45:43 <ski> and in `case'
06:45:50 <Gracenotes> I doubt it could work for cycles though...
06:45:51 <fasta> lilac: for case, I am not sure about lambda.
06:45:52 <lilac> fasta: or... foo :: a = b = (a, b); foo = (,)
06:45:55 <arcatan> and and = does not make sense in lambda methinks
06:45:57 <ski> (but `|->' would be better)
06:46:06 <ray> well, i mean in lambda it's coincidentally the same symbol used for function types
06:46:12 <fasta> lilac: oh, right, lambdas ;)
06:46:15 <ray> so function types and function values both have a ->
06:46:29 <Gracenotes> cycles would be bottom nodes... and not bottom as in sink :P
06:46:31 <fasta> lilac: it has never annoyed me in lambdas.
06:46:41 <kpreid> Gracenotes: not for cycles? http://switchb.org/kpreid/2007/graph-life/GraphLife.hs is just that in buildRandomTorus
06:47:02 <lilac> fasta: i think it'd look weird in case, as if you were defining the LHS rather than mapping from it
06:47:16 <ski> (ray : in lambdas, `|->' would be better than `->')
06:47:26 <skorpan> wtf?
06:47:27 <skorpan> no!
06:47:29 <ray> why's that
06:47:41 <lilac> ski: eww. `.' i could deal with, though
06:47:50 <quicksilver> standard mathematical notation
06:47:51 <ski> `case e of m' is basically `(\m) e'
06:48:01 <ray> . would be nice, but . is already so mangled
06:48:07 <ray> in haskell that is
06:48:10 <quicksilver> you wouldn't need the lambda at all then
06:48:17 <skorpan> ·
06:48:18 <quicksilver> you could just have id = x |-> x
06:48:20 <lilac> quicksilver: parsing that would be painful
06:48:31 <ski> lilac : `.' would work as well. i've seen mathematicians suggesting infix `.' for lambda abstractions :)
06:48:40 <quicksilver> lilac: making the compiler writer's job painful is one of the main duties of a language designer.
06:48:47 <Gracenotes> kpreid: where is the cyclic corecursion?
06:48:54 <ski> lilac : so e.g. `forall x . P(x)' would be `forall (x . P(x))'
06:49:10 <kpreid> Gracenotes: look at the references to 'cs'
06:49:29 <lilac> ski: i was thinking in lambdas rather than in types. (\x. x + 1)
06:49:33 <Gracenotes> ah. and what type are the values of cs?
06:49:51 <lilac> i was actually a little surprised when i first learned haskell used -> rather than . for that
06:49:55 <ski> lilac : `forall x . P(x)' is the constant `forall' applied to the lambda 'x . P(x)'
06:50:07 <kpreid> Gracenotes: cs is an array mapping (Int,Int) to Cell
06:50:18 <lilac> ski: i'd still want the 'lambda' symbol in there, as in standard notation
06:50:35 <ski> (`forall x. P(x)' is pretty standard)
06:51:15 <kpreid> Gracenotes: are you pointing out that there is no reference to the Array itself within the Cells?
06:52:10 <Gracenotes> hm. well, that's not important, the important bit is using the Array to make the network of Cells themselves
06:52:16 <kpreid> yup
06:52:33 <nomeata> What options are there on Haskell to parse command line arguments. I only see the parseargs package.
06:52:44 <Gracenotes> perhaps I'm forgetting that it can be lazily generated: in my case, the whole thing needs to be generated before I can assign layers to it
06:52:52 <ski> lilac : .. yes, i agree that it feels right to have a lambda in there, to convert from a morphisms to a value
06:53:08 <dschoepe> nomeata: System.Console.GetOpt
06:53:10 <Gracenotes> I see. It's pretty magical either way though >_>
06:53:30 <nomeata> dschoepe: ah, nice, thx.
06:54:23 <Gracenotes> and the layer algorithm works recursively with the sinks as the base case
06:54:50 <kpreid> ah
06:55:16 <Gracenotes> the reason for it is that I'm trying to implement some form of the sugiyama method, actually
06:55:57 <Gracenotes> for simple DAG drawing, assign each node to a vertical layer, switch nodes around horizontally to minimize crossings, position to draw
06:56:22 <Gracenotes> mm, what are you trying to do?
06:56:45 <Gracenotes> oh, life? :)
06:56:48 <kpreid> yah
06:56:50 <QtPlaty[HireMe]> Other option output the data in dot format and let graphviz deal with it.
06:58:29 <Gracenotes> QtPlaty[HireMe]: yeah, I've been working with dot, but I'm trying to see if I can display a DAG in HTML with canvas using Haskell serverside to arrange positions and whatnot
06:59:08 <Gracenotes> dot's default output format already does this, but, eh, I'll see how far I can go :P
06:59:40 <hackagebot> prelude-plus 0.0.0.2 - Prelude for rest of us (YusakuHashimoto)
06:59:55 <endojelly> gfoldl is really giving me headaches
07:00:01 <Gracenotes> at least, it positions it, although the file still needs to parsed
07:00:45 <path[l]> hi
07:03:18 <path[l]> wow did I actually find a time when the channel sleeps
07:03:38 <Gracenotes> *ZzzzZzZZZZZzzzZZz*
07:03:52 <path[l]> hehe
07:03:55 * SubStack is not sleeping today
07:04:02 <SubStack> for the principle of it
07:04:07 * QtPlaty[HireMe] is fending off cat attacks :D
07:04:17 <ski> (the channel never sleeps, it's just hiding, waiting for the appropriate moment to dash out for the kill)
07:04:28 <SubStack> s/kill/punchline/
07:04:34 <path[l]> I have a question, whats the recommended way when I have a List representation of key value pairs to change it into a sort of Map like structure where I get vs sets of values
07:04:35 <ski> same thing :)
07:04:42 <path[l]> kinda like a group by clause in sql
07:04:43 <QtPlaty[HireMe]> Sounds like this cat.
07:04:59 <skorpan> path[l]: sounds like Data.Map.fromList?
07:05:03 <ski> QtPlaty[HireMe] : hungry cat ? lonely cat ?
07:05:28 <QtPlaty[HireMe]> Lenely cat, its currently kneeding my tummy + helping my type
07:05:33 <skorpan> > Data.Map.fromList [(1,2), (2,3)]
07:05:35 <lambdabot>   Not in scope: `Data.Map.fromList'
07:05:35 <path[l]> I was thinking so, but Data.Map.fromList takes [(a,a)] to a Map a a
07:05:44 <skorpan> path[l]: really?
07:05:45 <path[l]> whereas I want Map a [a]
07:06:05 <dschoepe> @type Data.Map.fromList
07:06:07 <Deewiant> > M.fromList [(1,2),(2,3)]
07:06:08 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
07:06:09 <lambdabot>   fromList [(1,2),(2,3)]
07:06:27 <path[l]> so if I have [(1,2),(1,3)] to become a structure where looking up 1 gives me [2,3]
07:07:31 <dschoepe> > groupBy ((==) `on` fst) . sort $ [(1,2),(1,3)]
07:07:33 <lambdabot>   [[(1,2),(1,3)]]
07:07:59 <dschoepe> > map (map snd) . groupBy ((==) `on` fst) . sort $ [(1,2),(1,3)]
07:08:07 <lambdabot>   [[2,3]]
07:08:12 <ski> @type Data.Map.fromList . map ((fst . head) &&& map snd) . groupBy ((==) `on` fst)
07:08:13 <lambdabot> forall a b. (Ord a) => [(a, b)] -> M.Map a [b]
07:08:15 <Deewiant> > M.fromList $ map (\xs@((f,_):_) -> (f, map snd xs)) $ groupBy ((==) `on` fst) [(1,2),(1,3)]
07:08:18 <lambdabot>   fromList [(1,[2,3])]
07:09:14 <Gracenotes> perhaps some form of fromListWith
07:10:11 <Gracenotes> > M.fromListWith (++) [(1, [1,2]), (2, [3,4]), (1, [5,6])]
07:10:13 <lambdabot>   fromList [(1,[5,6,1,2]),(2,[3,4])]
07:10:34 <SubStack> nice
07:11:10 <Gracenotes> I wish there was a version that didn't require the values to be pre-wrapped, though..
07:11:28 <path[l]> yea
07:11:55 <jmcarthur_work> wait, what would the type be?
07:12:04 <Deewiant> It'd need to take two different functions, wouldn't work?
07:12:17 <Gracenotes> e.g. not (a -> a -> a) -> [(Key, a)] -> IntMap a, but also (though more complicated) (a -> a -> b) -> (b -> b -> b) -> [(Key, a)] -> IntMap b
07:12:46 <ski> Eq b => (a -> b) -> (b -> b -> b) -> [(k,a)] -> Map k b
07:13:32 <quicksilver> fromListWith and intersectionWith are the overlooked jewel in Data.Map's crown.
07:13:34 <Gracenotes> or like that, but in that case you could just preprocess the list with the (a -> b) function, map (second f)
07:13:49 <quicksilver> you can use intersectionWith (*) to calculate the total cost of an order against a menu
07:13:55 <quicksilver> which is really quite cool.
07:14:09 <Gracenotes> in the case of lists, it's map (\(a, b) -> (a, [b]))
07:14:20 <quicksilver> and intersectionWith (-) to remove an order from stock.
07:14:30 <quicksilver> Gracenotes: map (second (:[]))
07:14:32 <quicksilver> ;)
07:14:35 <Gracenotes> :[]
07:14:36 <path[l]> I tried using fromListWith and got a sorta answer. But not a good one
07:14:37 <path[l]> hmm
07:14:37 <ski> return
07:14:43 <path[l]> let me try that
07:14:45 <quicksilver> I don't like using return for :[]
07:14:53 <quicksilver> it's deceptive polymorphism
07:15:01 <Deewiant> Too bad that IntMap's intersectionWith's type is still (a -> b -> a) and not (a -> b -> c)
07:15:02 <ski> it depends
07:15:03 <path[l]> map(snd(:[])) <--- is this the same thing
07:15:04 <path[l]> ?
07:15:07 <ski> no
07:15:07 <Gracenotes> eh, it gets compiled in as (:[]) anyway, teh compiler iz smart
07:15:08 <quicksilver> (deliberately using a polymorphic name when you know the monomorphic type you're using)
07:15:19 <path[l]> whats second?
07:15:20 <quicksilver> oh, it wasn't an efficiency complain
07:15:24 <path[l]> not the same as snd
07:15:25 <quicksilver> just a readability one
07:15:30 <ski> second f ~(a,b) = (a,f b)
07:15:31 <quicksilver> path[l]: it's "snd" lifted up to functions
07:15:35 <quicksilver> > snd (1,2)
07:15:37 <lambdabot>   2
07:15:39 <quicksilver> > second (+1) (1,2)
07:15:40 <jmcarthur_work> map (second pure)
07:15:41 <lambdabot>   (1,3)
07:15:44 <path[l]> ah
07:15:56 <ski> Gracenotes : the question was what was most readable to a human
07:16:00 <path[l]> it applies a function on the second is it
07:16:26 <Gracenotes> ski: true. It's also like @pl using ap and =<< left and right, can be annoying
07:16:47 <ski> @type snd
07:16:48 <ski> @type Endo . second . appEndo
07:16:49 <lambdabot> forall a b. (a, b) -> b
07:16:50 <lambdabot> forall c d. Endo c -> Endo (d, c)
07:16:51 <Gracenotes> and join. in this case there's no real monomorphic variant, however
07:16:59 <Deewiant> There are for ap and =<<?
07:17:09 <ski> interesting
07:17:36 <ski> (`flip concatMap')
07:17:59 <Deewiant> Oh, for lists, right
07:18:03 <Deewiant> I was thinking for functions
07:18:49 <Gracenotes> I was thinking about (r->), actually. Personally I find <*>, join, and =<< easy enough to read in code for that instance
07:20:02 <Gracenotes> they are usually placed close the functions they modify. I understand your problem with return, though -- it can be hard to keep track of the type of the data structure(s) you're putting through a loop
07:20:09 <ski> Gracenotes : generally i will use the more polymorphic version, if there seems to be some point in having that generality (even if i don't use it, atm); but prefer to use the more specific version if i'm already decided on working with the more specific types
07:20:37 <jmcarthur_work> yeah i don't get the whole "(->)a is such a confusing monad" thing. it's the simplest monad i can think of besides identity
07:20:42 <quicksilver> I agree with that rule of thumb ski .
07:21:03 <quicksilver> jmcarthur_work: it's confusing because it makes more expressions which should simply fail to type check, instead typecheck into something odd and give a strange error.
07:21:09 <Gracenotes> it's difficult to think of as a monad, but convenient as heck to use as simple combinators...
07:21:15 <ski> (so if i'm already working with lists, then i generally prefer `(:[])' to `return' .. sometimes i use `return' anyway, if i'm using `do'-blocks, though)
07:21:18 <quicksilver> jmcarthur_work: if you're trying to write a do block in the IO monad, but you miss off a function argument
07:21:26 <quicksilver> jmcarthur_work: then the cmopiler will infer you are in the (->) monad
07:21:33 <quicksilver> and you get a very surprising type mismatch
07:21:44 <jmcarthur_work> i've never been surprised by it, really
07:21:52 <quicksilver> no, but you understand the language well.
07:21:54 <path[l]> Im confused about second. If second applies a function onto the second part of a pair, what does it return? The result of the function, or the entire pair
07:21:55 <jmcarthur_work> maybe the first time i saw it as a beginner
07:22:04 <quicksilver> it is not you who are the person who gets confused by these things, therefore
07:22:13 <jmcarthur_work> path[l], the entire pair with the second element replaced
07:22:14 <path[l]> why is second (+1) (1,2)  --> (1,3) and not just 3
07:22:15 <lilac> path[l]: the function you pass to second returns the new second element. second returns the new pair
07:22:21 <path[l]> ah
07:22:32 <quicksilver> @type do putStrLn; x <- getLine; return x
07:22:34 <lambdabot>     Couldn't match expected type `IO String'
07:22:34 <lambdabot>            against inferred type `String -> String'
07:22:34 <lambdabot>     In a stmt of a 'do' expression: x <- getLine
07:22:49 <quicksilver> I think that's a confusing error :)
07:23:00 <quicksilver> especially to someone who has only just learnt the IO monad
07:23:03 <quicksilver> and is learning by example.
07:23:07 <jmcarthur_work> path[l], second f (x, y) is the same as fmap f (x, y)
07:23:20 <Twey> It's confusing to me
07:23:20 <quicksilver> it is not the expected, simple message "putStrLn requires one argument and you gave it zero
07:23:26 <path[l]> one more tweak on it any idea how I could get from [(1,2)] to [(1,[1,2])]. ?
07:23:27 <jmcarthur_work> path[l], but second f _|_ /= fmap f _|_
07:23:29 <Twey> Where's there a String -> String?
07:23:51 <path[l]> heh Im sorry I dont know what fmap is
07:24:06 <Twey> There's a String -> IO (), an IO String, and an a -> IO a
07:24:12 <path[l]> second is useful but it only allows me to operate on the second element
07:24:15 <ski> > (map . second . map . first) (*10) [(0,[(1,'a')]),(2,[(3,'b'),(4,'c')]),(5,[(6,'d'),(7,'e'),(8,'f')])]  -- path[l]
07:24:17 <lambdabot>   [(0,[(10,'a')]),(2,[(30,'b'),(40,'c')]),(5,[(60,'d'),(70,'e'),(80,'f')])]
07:24:33 <Twey> putStrLn >> getLine >>= return
07:24:39 <Twey> Oh!
07:24:45 <Twey> It ends up being in the function monad?
07:24:50 <quicksilver> right.
07:24:54 <skorpan> what's the point of >>= return?
07:25:03 <Twey> And then getLine gives the error.  I see.
07:25:03 <quicksilver> skorpan: nothing at all, it was a simple/stupid example.
07:25:17 <LeoD> sometimes i'd like an editor allowing me to write from right to left, just for haskell :P
07:25:36 <quicksilver> so the answer to jmcarthur_work's question "in what context is the (->) monad considered confusing" is "when you miss out a parameter in a do block, you get a very unexpected error"
07:25:42 <Twey> LeoD: Set your editor to Arabic mode :þ
07:25:45 <LeoD> :D
07:25:49 <ski> ? siht ekil
07:25:53 <skorpan> LeoD: just rebind SPC to backward-word in emacs ;P
07:25:55 <Twey> Hehe
07:26:04 <quicksilver> there is a similar, although less convincing, argument about (,) and [] being confusing monad instances
07:26:04 <LeoD> skorpan: vim :P
07:26:15 <path[l]> ski Im not so sure if I read that right its a map of a function on the second which is a map of the first
07:26:16 <quicksilver> they all increase the number of complete mistaken programs which partly or completely typecheck.
07:26:16 <skorpan> LeoD: just start using emacs and rebind SPC to backward-word in emacs ;P
07:26:20 <LeoD> :P
07:26:21 <Twey> 15:23:07 < jmcarthur_work> path[l], second f (x, y) is the same as fmap f (x, y)
07:26:21 <EvilTerran> fortunately the (->) and (,) Monad instances are only in scope if you import Control.Monad.Instance
07:26:24 <EvilTerran> s
07:26:26 <Twey> — wow, that's unhelpful :-P
07:26:42 <path[l]> I wanted something like a map where I can replace the second element with an array including the first
07:26:42 <jmcarthur_work> Twey, it's not unhelpful if you know what fmap is
07:26:53 <jmcarthur_work> Twey, i didn't know path[l]'s level of experience
07:26:59 <Twey> jmcarthur_work: It is, because fmap on pairs is arbitrary
07:27:04 <path[l]> so like (1,2) -> (1,[1,2]) but for a whole map
07:27:14 <Twey> ‘fmap on pairs is second’ is the only way to define it
07:27:20 <ski> path[l] : the `map . second . map . first' reads as "enter every element of the list, enter the second part of the pairs, enter every sublist, enter the first part of the pairs"
07:27:20 <EvilTerran> the fact that fmap works like second on pairs is an artifact of the haskell type system
07:27:21 <jmcarthur_work> Twey, it's defined...
07:27:31 <Twey> Yes, it's defined, as second
07:27:35 <ski> path[l] : and thet's where you apply the `(* 10)' function
07:27:36 <jmcarthur_work> Twey, and that definition as given isn't true
07:27:42 <Gracenotes> EvilTerran: (,) monad...? O_O
07:27:43 <Twey> How so?
07:27:44 <jmcarthur_work> it's not the same as second
07:27:54 <jmcarthur_work> > second id undefined
07:27:57 <lambdabot>   (* Exception: Prelude.undefined
07:28:00 <jmcarthur_work> > fmap if undefined
07:28:02 <lambdabot>   <no location info>: parse error on input `if'
07:28:05 <jmcarthur_work> > fmap id undefined
07:28:06 <lambdabot>   No instance for (GHC.Show.Show (f a))
07:28:07 <lambdabot>    arising from a use of `M6013890868...
07:28:09 <path[l]> ski : yeah thats how I read it too. I wanted one that reads, enter every element on the list, take both parts of the pair and replace the second part with a list of both
07:28:15 <Twey> Oh, fmap is lazier?
07:28:16 <jmcarthur_work> > fmap id undefined :: (Int, Int)
07:28:18 <lambdabot>   * Exception: Prelude.undefined
07:28:22 <jmcarthur_work> Twey, second is lazier
07:28:28 <Gracenotes> thar's no (,) monad, return is totally out of this world
07:28:35 <EvilTerran> Gracenotes, Monoid w => Monad (w,)
07:28:35 <ski> path[l] : do you have an example to clarify what you mean ?
07:28:43 <jmcarthur_work> Gracenotes, return x = (mempty, x)
07:28:45 <EvilTerran> ?src (,) return
07:28:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:28:54 <Twey> quicksilver: ‽
07:28:57 <Gracenotes> You didn't say Monoid! You didn't say Monoid! >_<
07:28:59 <Twey> Er, jmcarthur_work
07:29:03 <ski> (there is a `Monoid w => (w,)' monad)
07:29:22 <jmcarthur_work> Twey, ?
07:29:25 <EvilTerran> Gracenotes, the "monoid" is a constraint on the type of one of the elements of the pair. it's still a Monad instance i'm talking about. calm down.
07:29:27 <Gracenotes> there is that, true enough. *sulks and continues codin*
07:29:37 <Twey> jmcarthur_work:
07:29:47 <Twey> Prelude> fmap id undefined
07:29:49 <Twey> *** Exception: Prelude.undefined
07:29:55 <Twey> Prelude Control.Arrow> second id undefined
07:29:56 <Gracenotes> lol
07:29:57 <Twey> (*** Exception: Prelude.undefined
07:29:59 <jmcarthur_work> right
07:30:01 <path[l]> sure so if I have [(1,2),(1,3),(2,4)] I want to go to [(1,[1,2]),(1,[1,3]),(2,[2,4])]. This is an intermediate step to get to a place where I can have a hash 1 -> [1,2,3] and 2 -> [2,4]
07:30:09 <EvilTerran> fmap id = id, so fmap id undefined = undefined
07:30:15 <jmcarthur_work> Twey, it went ahead and assumed the (,) constructor in the case of second
07:30:21 <EvilTerran> there's no such requirement for second, so i guess it makes sense to make it as lazy as possible
07:30:25 <Twey> Ah
07:30:37 <ski> path[l] : yes, several of us gave answers for that above
07:31:03 <ski> path[l] : in this case, `map' won't do, because you want to combine several of the elements in the list together
07:31:05 <Twey> EvilTerran: Well, it *should* be.  I don't see anything preventing one from defining a fmap that breaks that law.
07:31:26 <jmcarthur_work> Twey, what should be?
07:31:30 <path[l]> ski well I was going to use a map to do the first step and then use fromListWith to get to the second step
07:31:37 <EvilTerran> Twey, there isn't anything, just like there's nothing stopping you defining an utterly broken Monad instance that satisfies none of the axioms
07:31:43 <path[l]> I understand how to use fromListWith but not the map for the first step
07:31:59 <ski> path[l] : or, hm ..
07:32:02 <Deewiant> > M.fromListWith union $ map (\x -> (fst (head x), fst (head x) : map snd x)) $ groupBy ((==) `on` fst) [(1,2),(1,3),(2,4)]
07:32:03 <lambdabot>   fromList [(1,[1,2,3]),(2,[2,4])]
07:32:10 <ski> > (map ((fst . head) &&& map snd) . groupBy ((==) `on` fst) . sort) [(1,2),(1,3),(2,4)]
07:32:11 <Twey> instance Functor Num a => BrokenFunctor a where fmap f (BF x) = BF . f $ x + 1
07:32:12 <lambdabot>   [(1,[2,3]),(2,[4])]
07:32:19 <Twey> EvilTerran: Yeah
07:32:34 <Twey> Someone should really figure out a way to enforce that
07:32:41 <path[l]> looks like Deewiant got it, now I have to understand that =p
07:32:48 <jmcarthur_work> Twey, it's enforceable in some languages
07:32:53 <quicksilver> Twey: what is interesting is that it's enough to ensure fmap id = id
07:33:02 <jmcarthur_work> Twey, but haskell's type system is not powerful enough
07:33:03 <quicksilver> Twey: if you get that part right, you automatically obey the other laws.
07:33:10 <quicksilver> parametricity++
07:33:10 <ski> path[l] : neither mine nore Deewiant's solution give the same answer as you gave in the example
07:33:15 <EvilTerran> quicksilver, theorems for free?
07:33:18 <quicksilver> right.
07:33:18 <Twey> jmcarthur_work: In what languages?  What feature is necessary?
07:33:21 <EvilTerran> yay!
07:33:21 <Deewiant> ski: Mine did
07:33:31 <EvilTerran> Twey, well, Agda and Coq can probably do it
07:33:33 <path[l]> really? Deewiant's solution looks right to me
07:33:42 <path[l]> though he jumped straight to the end
07:33:44 <Deewiant> ?pl \x -> (fst . head &&& (fst (head x):) . map snd) x
07:33:44 <jmcarthur_work> Twey, well, i can't claim to know the minimal feature set necessary, but dependent types is sufficient
07:33:45 <lambdabot> (fst . head &&&) =<< (. map snd) . (:) . fst . head
07:33:46 <EvilTerran> what with the ability to enforce arbitrary predicates at compile-time, iirc
07:33:46 <ski> hm, maybe the `fromListWith union' is confusing me
07:33:51 <ski> > M.fromListWith union $ map (\x -> (fst (head x), fst (head x) : map snd x)) $ groupBy ((==) `on` fst) [(1,2),(1,3),(2,4)]
07:33:53 <lambdabot>   fromList [(1,[1,2,3]),(2,[2,4])]
07:33:59 <jmcarthur_work> Twey, yeah, i was thinking agda and coq
07:33:59 <ski> er
07:34:03 <ski> > map (\x -> (fst (head x), fst (head x) : map snd x)) $ groupBy ((==) `on` fst) [(1,2),(1,3),(2,4)]
07:34:04 <lambdabot>   [(1,[1,2,3]),(2,[2,4])]
07:34:05 <jmcarthur_work> there are others too
07:34:14 <Deewiant> Oh, true, groupBy does it already so it's pointless
07:34:16 <Twey> jmcarthur_work: Don't we have an extension for that?
07:34:21 <jmcarthur_work> Twey, nope
07:34:26 <ski> Deewiant : path[l] said `[(1,[1,2]),(1,[1,3]),(2,[2,4])]'
07:34:28 <EvilTerran> not for dependent types
07:34:40 <Deewiant> ski: Yes, for the intermediate result
07:34:45 <jmcarthur_work> closest we have is GADTs, maybe, but that's a very loose comparison
07:34:47 <Twey> Oh, just a few ideas: http://www.coverproject.org/TalksUntilSpring2004/DependentTypesInHaskell.pdf
07:34:55 <jmcarthur_work> i think we have indexed types coming soon?
07:34:59 <Deewiant> ski: But did he really want that, or was it just meant as a way to get to the end?
07:35:00 <EvilTerran> we have partiality, anyway, which slightly dilutes the point of dependent types
07:35:08 <ski> Deewiant : i don't know
07:35:14 <path[l]> yeah it was just a way to get to the end :)
07:35:14 <jmcarthur_work> numerical indexes only, iirc?
07:35:41 <Deewiant> Well, doesn't matter
07:35:42 <Deewiant> > map (\x -> (fst x, fst x : [snd x])) [(1,2),(1,3),(2,4)]
07:35:44 <lambdabot>   [(1,[1,2]),(1,[1,3]),(2,[2,4])]
07:35:46 <Deewiant> > M.fromListWith union $ map (\x -> (fst x, fst x : [snd x])) [(1,2),(1,3),(2,4)]
07:35:47 <lambdabot>   fromList [(1,[1,3,2]),(2,[2,4])]
07:36:23 <path[l]> what does union $ do?
07:36:35 <EvilTerran> the same as union (...)
07:36:37 <Deewiant> Nothing, there
07:36:45 <Deewiant> It's (M.fromListWith union) $
07:36:48 <ski> `M.fromListWith union $ ...' is the same as `M.fromListWith union (...)'
07:36:50 <path[l]> Im confused by the $
07:36:58 <Deewiant> It's just to avoid brackets
07:37:01 <path[l]> ah
07:37:03 <EvilTerran> although not in that context, as "union $" isn't part of the syntax tree there
07:37:04 <Deewiant> > M.fromListWith union (map (\x -> (fst x, fst x : [snd x])) [(1,2),(1,3),(2,4)])
07:37:06 <lambdabot>   fromList [(1,[1,3,2]),(2,[2,4])]
07:37:09 <jmcarthur_work> path[l], ($) is function application with a different fixity
07:37:12 <Deewiant> ?src $
07:37:12 <lambdabot> f $ x = f x
07:37:34 <EvilTerran> jmcarthur_work, and precedence. that's the important bit.
07:37:35 <jmcarthur_work> it binds very loosely and is right associative
07:37:38 <quicksilver> path[l]: basically "a b c d $ e f g" is just "(a b c d) (e f g)"
07:37:44 <path[l]> ah ok
07:37:45 <jmcarthur_work> EvilTerran, i was conflating the terms :\
07:37:47 <path[l]> now I get it
07:37:51 <path[l]> thanks quicksilver
07:38:05 <EvilTerran> (we try not to talk about the associativity, it makes Cale jumpy :P)
07:38:15 <jmcarthur_work> haha
07:38:50 * EvilTerran guesses "fixity" is as good a term for "precedence and associativity" as any, actually
07:39:31 * ski thinks precedence ought to be relative
07:40:27 <jmcarthur_work> infixl * >+ <$    ?
07:40:33 <jmcarthur_work> i like numbers ;)
07:40:40 <lilac> ski: there's no need for it to even be acyclic :)
07:40:53 <hackagebot> accelerate 0.5.0.0 - An embedded language for accelerated array processing (ManuelChakravarty)
07:40:56 <ski> lilac : have i claimed that :)
07:40:58 <ski> ?
07:41:06 <jmcarthur_work> shoot i went the wrong way there
07:41:26 <lilac> ski: no, i'm just agreeing with you in a roundabout way
07:41:33 <jmcarthur_work> still, the notation is horrible, and i can think of no better way to express relative precedence
07:41:44 <path[l]> should I be saying import Data.Map as M ?
07:42:20 <jmcarthur_work> path[l], "should" is a strong word, but if you want to avoid all possible conflict: import qualified Data.Map as M
07:42:42 <path[l]> well no I just want to do whats considered the most common practice :)
07:42:46 <ski> precedence "+" =< "*"
07:43:22 <lilac> precedence + Int < + Bool
07:44:26 <ski> lilac : of course, one might make an even more lax system, by making the two sides of an infix operator have different precedences :)
07:44:29 * EvilTerran was thinking sth to the effect of "data Prec = Below Prec | Middle | Above Prec deriving (Eq, Ord)"
07:45:05 <ski> EvilTerran : we want a dense ordering
07:45:13 <lilac> EvilTerran: data Prec = Between [Prec] [Prec] -- yay, surreal precedences
07:45:24 <EvilTerran> ski, meaning what exactly?
07:45:26 <ski> (or .. hm, maybe that's what you're saying)
07:45:55 <EvilTerran> my suggestion has an infinite number of values between any two non-equal values
07:46:01 * jmcarthur_work is just happy to have operators at all
07:46:07 <EvilTerran> (which is what i thought dense meant)
07:46:13 <ski> EvilTerran : `dense R <=> forall x z. R (x,z) => exists y. R (x,y) /\ R (y,z)'
07:46:35 <ski> EvilTerran : yes, i misinterpreted what you were suggestinh
07:46:58 <EvilTerran> it'd probably've been clearer had i used GADT syntax; it usually is, i find :P
07:47:34 <ski> (EvilTerran : for some reason i was thinking 'Below' was an inverse of `Above')
07:47:53 * EvilTerran notes he'd probably want to make Below and Above strict in their parameter so you couldn't have infinite ones
07:48:03 <EvilTerran> ... or could you?
07:48:07 <EvilTerran> eh, nvm.
07:48:07 * ski finds the current algebraic data type syntax not that bad
07:48:33 <ski> it's useful to avoid repeating the same result type over and over again
07:48:49 <jmcarthur_work> yeah i at least like basic ADT syntax as a shortcut
07:48:50 <lilac> data Foo a = (a ~ Int) => Foo Bool | (a ~ Bool) => Bar Int
07:48:52 <EvilTerran> yeah, the standard ADT syntax isn't *bad*, and it's nicely terse, but at the expense of some intuitive meaning
07:49:12 <ski> how do you mean ?
07:49:22 <ski> lilac :)
07:49:35 <lilac> we don't need no stinkin GADT notation :)
07:49:37 <jmcarthur_work> i like how GADT syntax is more like a function type signature
07:49:44 <EvilTerran> constructor names and type names alongside each other
07:50:14 <ski> the ADT syntax might be nicer, if sprinkled with a few quotes and unquotes
07:50:29 <path[l]> hmm there's a concatMap but no union map? :/
07:50:32 <jmcarthur_work> i'm not just spouting out constructor names, i'm declaring the types of the constructors
07:50:33 <ski> data Either a b = `(Left ,a) | `(Right ,b)
07:50:58 <ski> (to avoid confusion between arguments, and types of the arguments)
07:51:24 <jmcarthur_work> path[l], you might want to look in Data.Foldable
07:51:30 <path[l]> ah
07:52:10 * ski still waits for an example use of GADT records
07:53:05 <path[l]> :t concatMap
07:53:08 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:53:27 <jmcarthur_work> :t foldMap
07:53:29 <lambdabot> Not in scope: `foldMap'
07:53:35 <jmcarthur_work> :t Data.Foldable.foldMap
07:53:37 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
07:54:21 <jmcarthur_work> (Data.Map's Monoid instance gives you union)
07:54:36 <jmcarthur_work> and lists are Foldable
07:55:18 <path[l]> I dont know what a monoid is @.@
07:55:29 <gwern> @quote monoid
07:55:29 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
07:55:29 <lambdabot> read
07:55:32 <path[l]> maybe I should stick to the basics for now lol
07:55:43 <jmcarthur_work> path[l], an identity element (mempty) and as associative operation (mappend)
07:55:50 <gwern> path[l]: actually, monoids are really easy to understand. I don't understand monads, but I think I understand monoids
07:55:57 <jmcarthur_work> path[l], for Map, identity is an empty Map, and mappend = union
07:55:59 <path[l]> hmm
07:56:27 <jmcarthur_work> gwern, monads are monoids ;)
07:56:31 <gwern> path[l]: it's basically anything that acts like a list, but with ways of adding any new item besides (:)
07:56:38 <gwern> jmcarthur_work: vicious lies!
07:56:43 <gwern> I refuse to believe that
07:56:45 <path[l]> oh ok I think I see
07:57:07 <ski> the integers form a monoid, with `0' and `(+)'
07:57:08 <jmcarthur_work> gwern, http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
07:57:23 <ski> (the integers also form another monoid, with `1' and `(*)')
07:58:15 <gwern> path[l]: so for a list, 1 `mappend` 2 `mappend` 3 `mappend` 4 becomes 1,2,3,4; but you know a Map doesn't allow you to have 2 keys the same, so map uses something besides (:) - it overwrites the original, so (1,2) `mappend` (1,3) `mappend` (2,3) will be {(1,3), (2,3)} (if you follow my fake syntax)
07:58:25 <path[l]> aha
07:58:26 <path[l]> ok
07:58:46 <gwern> the (1,3) overwrites the (1,2), since that's just how Map rolls as a monoid
07:58:55 <djahandarie> cuz dats how i roll
07:59:03 <gwern> path[l]: this is actually how xmonad's keybindings works, btw
07:59:09 <gwern> keybindings are a monoid!
07:59:25 <path[l]> heh ok
07:59:25 <gwern> we just don't actually use the monoid typeclass in xmonad :( (yet...)
07:59:36 <djahandarie> Haskell should be renamed to IOIsAPainWithThisLanguage
07:59:48 <path[l]> haha
07:59:48 <jmcarthur_work> djahandarie, except that would be wrong
08:00:03 <jmcarthur_work> haskell makes my favorite imperative languages
08:00:04 <djahandarie> jmcarthur_work, I know lol, it was a joke
08:00:06 <jmcarthur_work> including IO
08:00:08 <gwern> path[l]: which makes sense - xmonad users get a default set of keybindings, right? and each keybinding is unique to key - there aren't 2 keys for Mod-m
08:00:12 <jmcarthur_work> djahandarie, ;)
08:00:17 <path[l]> right
08:00:33 <jmcarthur_work> the worst thing about Monoid is the names mempty and mappend
08:00:40 <EvilTerran> IO is more of a pain when it could happen practically anywhere in your code, IMO :P
08:00:41 <Gracenotes> okay, maayybbe this is excessive use of (r->) combinators, ((,) <*> (getSubnodes <*> flip IntMap.lookup comp)). whatevs.
08:00:51 <jmcarthur_work> they are too long for what they do and only express one way to use Monoid
08:00:58 <jmcarthur_work> (appending)
08:01:03 <Gracenotes> the infixity of <*> didn't help there :(
08:01:07 <gwern> but then how do you update mod-m's keybinding? well, you do originalKeyMap `mappend` myKeymap, and anywhere they 'conflict', the monoid 'mappend' operator chooses the binding from myKeymap
08:01:17 <path[l]> ok here's a hopefully really simple question. Why is this wrong? -> L.map (\key -> M.lookup key ah) ['A','B']
08:01:19 <EvilTerran> ?type \a b -> (,) <*> (a <*> b)
08:01:21 <lambdabot> forall a a1 a2. (a -> a2 -> a1) -> (a -> a2) -> a -> (a, a1)
08:01:23 <gwern> I was all SQUEEE! when I realized xmonad keybindings were a monoid
08:01:52 <gwern> path[l]: ['a', 'b'] is not a map, it's a list. you need something List -> Map
08:02:06 <gwern> wait, what's L.map?
08:02:14 <jmcarthur_work> gwern, if you like monoids, edwardk's stuff is looking amazing, just btw
08:02:16 <path[l]> L is Data.List
08:02:18 * gwern realizes I have perhaps put my foot in my mouth
08:02:39 <Gracenotes> monoids? in my xmonad?
08:02:47 <jmcarthur_work> xmonoid
08:02:48 <gwern> Gracenotes: it's more likely than you would think!
08:02:58 <gwern> path[l]: I guess we'd need to see the error
08:03:19 <path[l]> oh ok
08:03:21 <path[l]> sec
08:03:24 <jmcarthur_work> thanks freenode
08:03:42 * gwern wonders where the hell that foo? in my bar? meme came from, and why I think the correct response is it's more likely than you would think!; it doesn't seem to be the right answer based on most people's lack of followup
08:04:34 <path[l]> Ambiguous type variable `m' in the constraint:
08:04:34 <path[l]>       `Monad m' arising from a use of `M.lookup' at <interactive>:1:13-27
08:04:34 <path[l]>     Probable fix: add a type signature that fixes these type variable(s)
08:05:01 <gwern> @hpaste
08:05:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:05:10 <path[l]> ok
08:05:13 <jmcarthur_work> path[l], you must be on an old ghc
08:05:31 <gwern> jmcarthur_work: was it new ghc or old that used Maybe in Map?
08:05:37 <path[l]> yeah I am, I wont be able to upgrade for the moment either :/
08:05:46 <jmcarthur_work> path[l], for older versions of Data.Map, they used a monad as the result of lookup
08:06:02 <jmcarthur_work> the idea being you can use Maybe or Error or something with a good definition for fail when the value isn't there
08:06:08 <path[l]> ah
08:06:10 <jmcarthur_work> gwern, new ones use Maybe
08:06:20 <gwern> ah
08:06:29 <gwern> didn't occur to me that might be the issue
08:06:47 <Gracenotes> just explicitly imply Maybe somewhere
08:07:05 <Gracenotes> ...that was an oxymoron, wasn't it
08:07:07 <jmcarthur_work> path[l], well the solution is to force the result to be in the Monad of your choice (i recommend Maybe)
08:07:16 <path[l]> oh ok
08:07:26 <path[l]> Maybe is Nothing or Just X isnt it?
08:07:30 <quicksilver> right
08:07:30 <jmcarthur_work> right
08:07:32 <skorpan> left!
08:07:38 <Gracenotes> middle
08:07:40 <quicksilver> skorpan: no, that's Either!
08:07:43 <path[l]> but Im not sure how to force it
08:07:52 <Zao> Using Left for failure is discriminatory to left-handed people!
08:07:56 <skorpan> data Probably a = Yes | Maybe a, much more useful
08:08:06 <jmcarthur_work> haha
08:08:07 <ski> path[l] : what do you want to do in case of failure ?
08:08:16 <ski> handle the failure directly in some way ?
08:08:24 <quicksilver> path[l]: (\key -> Lookup key ah :: Maybe Int)
08:08:26 <path[l]> failure meaning the key is missing? I dont care, it shouldnt happen lol
08:08:34 <quicksilver> where ah well
08:08:35 <path[l]> so the smaller the code the better
08:08:37 <quicksilver> in that case use (!)
08:08:39 <Gracenotes> in that case use (!)
08:08:42 <Gracenotes> lol
08:08:48 <Zao> "The impossible just happened"
08:08:51 <Gracenotes> (jynx)
08:08:56 <gwern> @remember Gracenotes just explicitly imply Maybe somewhere
08:08:57 <lambdabot> Done.
08:09:01 <gwern> @quote Gracenotes
08:09:01 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
08:09:04 <EvilRanter> gwern, a google for "X? In My Y?" may clarify things
08:09:13 <Gracenotes> truly
08:09:18 <gwern> @quote Gracenotes
08:09:18 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
08:09:21 <gwern> @quote Gracenotes
08:09:22 <lambdabot> Gracenotes says: oh great, I have class 9:00 AM monad next semester
08:09:28 <Gracenotes> you can't escape from the posets
08:09:39 <gwern> @quote Gracenotes
08:09:39 <path[l]> oh ! is a lookup
08:09:39 <lambdabot> Gracenotes says: oh great, I have class 9:00 AM monad next semester
08:09:43 <gwern> bah
08:09:48 <gwern> Gracenotes = teh unfunny
08:09:51 <jmcarthur_work> @quote imply
08:09:51 <lambdabot> Gracenotes says: just explicitly imply Maybe somewhere
08:09:57 <path[l]> crap does that become M.!
08:10:01 <ski> yes
08:10:05 <ski> foo M.! bar
08:10:19 <Gracenotes> it's not so bad though
08:10:19 <quicksilver> I normally import (!) unqualified for that reason
08:10:22 <EvilRanter> path[l], i'd import (!) and the Map type unqualified
08:10:28 <path[l]> oh ok
08:10:28 <ski> (you can import `!' unqualified if you want)
08:10:30 <Gracenotes> but, indeed, (!) is the most dangerous game
08:10:32 <gwern> EvilRanter: oh. huh, and I was wondering whether maybe it was from _Spaceballs_
08:10:46 <EvilRanter> just the internet, i'm afraid :)
08:11:02 * gwern feels a tad more disgruntled than a few minutes ago
08:11:26 <path[l]> wait I have to import ! explicitly? Map alone isnt enough?
08:12:03 <EvilRanter> gwern, yeah, there's something depressing about finding a phrase you use as the subject of a page on encyclopedia dramatica
08:12:12 <jmcarthur_work> path[l], import Data.Map ((!), Map) ; import qualified Data.Map as M
08:12:32 <jmcarthur_work> path[l], that way you can use (!) and Map unqualified, but the other stuff must be qualified
08:12:37 <path[l]> ah ... thanks
08:14:33 <path[l]> crap I broke something. Between List and Map somehow now my code is constructing an infinite type
08:16:18 <jmcarthur_work> infinite types are my least favorite error
08:16:23 <path[l]> heh
08:16:48 <jmcarthur_work> i think it's because the error message doesn't pinpoint exactly where the error is
08:18:04 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8402#a8402 <--- This seems like it should work
08:18:12 <Gracenotes> omg, huge type error D:
08:18:49 <Gracenotes> for me, at least. But I think it was more of a big expression containing a type error than a big error
08:19:06 <gwern> :t Data.Map.key
08:19:08 <lambdabot> Not in scope: `Data.Map.key'
08:19:12 <gwern> :t Data.Map.(!)
08:19:15 <lambdabot> Couldn't find qualified module.
08:19:21 <gwern> @hoogle (!)
08:19:22 <lambdabot> keyword !
08:19:22 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
08:19:22 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
08:19:22 <jmcarthur_work> > map (\key -> key ! ah) ['A','B'] $ Data.Map.fromList [('A',"ACB"),('B',"BFA"),('C',"CDA"),('D',"DC"),('E',"EF"),('F',"FBE")]
08:19:27 <lambdabot>   Not in scope: `ah'Not in scope: `Data.Map.fromList'
08:19:42 <jmcarthur_work> oh duh
08:19:53 <gwern> ah ! key?
08:19:54 <path[l]> sorry ah was that hash
08:20:02 <jmcarthur_work> hash?
08:20:07 <path[l]> oh is that how it is >>
08:20:12 <fasta_> What is the Haskell mode keybinding to insert <newline>zomg in the following context? zomg a b c d = 4<position of point> and after pressing the keybinding we have  zomg a b c d = 4<newline>zomg <point>
08:20:13 <jmcarthur_work> oh, Map... Map is not a hash table
08:20:28 <path[l]> sorry that was stupid. it was ah ! key
08:21:03 <path[l]> oh it's not?
08:21:14 <jmcarthur_work> it's a balanced tree
08:21:31 <path[l]> ah
08:22:22 <ski> @type (Data.Map.!) -- gwern
08:22:23 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
08:23:02 <gwern> fasta_: man, I've no idea what're you askin'
08:23:43 <Gracenotes> like.. \nzomg? It seems you are talking about a specific text editor... of sorts...
08:23:48 <path[l]> wow this worked. Amazing
08:23:50 <ski> fasta_ : `RET TAB' ?
08:24:02 <gwern> jmcarthur_work: btw, you can't use Data.Map in mueval; ghc api doesn't allow qualified imports, so importing data.map would lead to all sorts of issues
08:24:12 * gwern is apologetic
08:24:31 <gwern> would - would it help if I sliced my belly with a lambda?
08:24:34 <fasta_> ski: that doesn't insert the function name again.
08:24:35 <jmcarthur_work> > Data.Map.fromList [('a', "foo"), ('b', "bar")]
08:24:37 <lambdabot>   Not in scope: `Data.Map.fromList'
08:24:43 <jmcarthur_work> :O
08:25:21 <gwern> er. I wrote mueval. I think I know what will and will not work, jmcarthur_work...
08:25:22 <ski> fasta_ : sorry, `RET TAB TAB'
08:25:49 <jmcarthur_work> gwern, i was just verifying for myself
08:25:50 <fasta_> ski: that doesn't do anything here.
08:25:59 <jmcarthur_work> i did not doubt
08:26:06 <ski> here it does what you asked about
08:26:29 <jmcarthur_work> i remember things better when i see them
08:26:58 <Deewiant> jmcarthur_work: M.fromList
08:27:40 <jmcarthur_work> > M.fromList [('a', "foo"), ('b', "bar")]
08:27:42 <lambdabot>   fromList [('a',"foo"),('b',"bar")]
08:27:44 <jmcarthur_work> oh
08:28:07 <gwern> also, am I the only one who thinks the show instance for map is awful
08:28:20 <Deewiant> What should it be
08:28:37 <jmcarthur_work> i'm back and forth on it
08:28:42 <Berengal> gwern, it doesn't jive, but I have no better alternative
08:28:46 <quicksilver> it's pretty much the right thing for it to be
08:28:58 <quicksilver> although it's a little painful modulo qualification
08:29:00 <ski> fasta_ : it works in haskell-mode 2.0 .. maybe it's not the same in all versions ..
08:29:02 <gwern> Deewiant: it should be something cool! like maybe {(,) <indent-and-newline>}
08:29:03 <quicksilver> (like so much else)
08:29:29 <Deewiant> gwern: But the point of Show is that what you get should be a Haskell expression evaluating to that value
08:29:42 <gwern> Deewiant: obviously we also need some literal map syntax
08:29:45 <Deewiant> If you want {} then use a prettyprinter
08:29:49 <ppavelV6> hi everybody
08:30:02 <gwern> we have syntax for tuples and lists and functions STOP OPPRESSING MY MAP HERITAGE
08:30:18 <Deewiant> What about Sequence, IntMap, the various tries and arrays? :-P
08:30:18 <gwern> it's total disparate impact! the haskell constitution forbids it
08:30:21 <ski> fasta_ : for some reason, though, it appears to not work when `zomg' is indented and `4' is on more than one line
08:30:33 <quicksilver> well, one approach would be to define some operators which the Show instance could use
08:30:35 <gwern> Deewiant: they can go suck a bannana
08:30:50 <Deewiant> Well that's not a very constructive attitude
08:30:54 <gwern> they're not in *my* heritage
08:31:04 <fasta_> ski: I think the reason is that the author only had limited time to work on it, like with every other mode in Emacs.
08:31:09 <ppavelV6> what is the supposed ghc's behavior when faced "well-formed" undecidable instances? i'm afraid it's just hangs on compilation instead of reporting "context reduction stack overflow" or something like this :(
08:31:19 <lilac> my map heritage has literal syntax for hashmaps. i demand equality
08:31:24 <dino-> I was thinking that too. It may be counterintuitive to the word "show", but I use Read/Show as a serialization mechanism quite often.
08:31:45 <quicksilver> you could have ('a' --> "foo" ||| 'b' --> "bar" ||| 'c' --> "baz") as part of a valid Show instance
08:31:51 <quicksilver> if you defined those operators carefully.
08:31:58 <quicksilver> (and add whitespace to taste)
08:32:03 <gwern> lilac: let's team up on whitey^Wlisty and get some affirmative action going
08:32:36 <quicksilver> ppavelV6: I believe it will report some kind of stack overflow in certain cases
08:32:49 <lilac> gwern: how about { foo -> bar, baz -> quux }?
08:32:50 <quicksilver> ppavelV6: I wouldn't be surprised if there are some cases which fail to terminate in ways it doesn't notice, though.
08:33:17 <gwern> lilac: actually, that's not too bad. might conflict with lambdas or records tho
08:33:20 <Gracenotes> would be nice if NFData were derivable...
08:33:27 <ppavelV6> quicksilver: hmmm... it's a bit strange to me to think about the situation when stack overflow can go unnoticed
08:33:30 <ppavelV6> %)
08:33:44 <lilac> gwern: "<quicksilver> making the compiler writer's job painful is one of the main duties of a language designer."
08:34:00 <gwern> @quote compiler.*writer
08:34:01 <lambdabot> No quotes match. I've seen penguins that can type better than that.
08:34:20 <gwern> @remember quicksilver making the compiler writer's job painful is one of the main duties of a language designer.
08:34:21 <lambdabot> Done.
08:34:22 <gwern> @flush
08:35:06 <Gracenotes> it's not possible to make typeclasses magically derivable, is it? e.g. "If each datatype in each constructor iis an instance of X, make the whole damn thing an instance of X." but in compiler-speak
08:35:12 <gwern> 'excelhustler.com' sounds dirty, but it really isn't :)
08:35:42 <Gracenotes> although... with details pertaining to the particular typeclass. like for NFData, just rnf them all and seq them together
08:36:12 <gwern> Gracenotes: I'm sure there's something on hackage to do that
08:36:12 <Gracenotes> so it can't really be that magical after all
08:36:30 <ppavelV6> ok... the ability to hang the compiler kills the whole idea :( should i try to isolate the case or this is unavoidable behavior anyway?
08:36:39 <lilac> Gracenotes: depends what level of hackery you consider to be magic.
08:36:51 <Berengal> Gracenotes, you could probably hack up something with TH
08:37:05 <lilac> template haskell lets you do that sort of thing, and there are a couple of pre-built toolkits for it
08:37:09 <gwern> Gracenotes: wow, stonybrook has a terrible graduation rate according to fafsa
08:37:41 <lilac> Gracenotes: http://repetae.net/computer/haskell/DrIFT/
08:37:46 <myname_> hi, anyone know what's the most practical way to do concurrent programming in haskell?
08:38:10 <Gracenotes> gwern: I think it's due to the dropout rate in the first year mainly
08:38:16 <Berengal> lars9, what kind of concurrency are we talking?
08:38:20 <kpreid> lars9: there is lots of stuff under Control.Concurrent in ghc's libs
08:38:32 <Berengal> +
08:38:34 <gwern> Gracenotes: even considering the transfer rate it's still a lousy grad rate
08:38:37 <lars9> such as multi-threading?
08:38:40 <jpcooper> hello
08:38:47 <Berengal> lars9, forkIO
08:38:47 <Gracenotes> gwern: ...and the continuation of the general attitude that motivates that into subsequent years
08:38:52 <kpreid> lars9: oh certainly. the real question is, how do you want those threads to communicate?
08:38:55 <jpcooper> how can I create a time-out on the returning of a thread?
08:38:55 <Berengal> @type forkIO
08:38:58 <lambdabot> Not in scope: `forkIO'
08:39:01 <gwern> Gracenotes: and just about everything else I suppose
08:39:01 <kpreid> lars9: yes, forkIO is the basic concurrency primitive
08:39:09 <kpreid> @type Control.Concurrent.forkIO
08:39:11 <lambdabot> IO () -> IO GHC.Conc.ThreadId
08:39:15 <lilac> lars9: there's some useful info here: http://www.haskell.org/haskellwiki/GHC/Concurrency
08:39:20 <Gracenotes> @hoogle timeout
08:39:21 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
08:39:21 <lambdabot> module System.Timeout
08:39:21 <lambdabot> package control-timeout
08:39:21 <jpcooper> that is, I would like to wait a maximum of a certain time on reading from a handle
08:39:28 <Gracenotes> @ jpcooper
08:39:36 <jpcooper> oh thanks
08:39:50 <Gracenotes> System.Timeout takes a a nanosecond timeout, an action, and a possible result, depending on whether it's not interrupted..
08:40:16 <gwern> hm. timeout? maybe I could use that in mueval
08:40:24 <gwern> except it'd be another dep
08:40:43 <lars9> thanks to all. i read the haskell wiki page about concurrency. it mentioned forkIO & STM.
08:40:44 <jpcooper> Gracenotes, the docs say that it takes microseconds
08:40:44 <Gracenotes> I thought it was in base. unfortunately it's not stable for system calls, though, at all.
08:40:52 <Gracenotes> oh. well, trust the docs :)
08:41:09 <lars9> so I was thinking which on is more used, forkIO & STM
08:41:15 <Gracenotes> gwern: after all, it's lightweight threads, not good for interrupting heavyweight C FFI action
08:41:21 <kpreid> lars9: they are not different
08:41:30 <kpreid> lars9: forkIO is how you create a thread, period.
08:41:32 <Berengal> lars9, STM isn't concurrency, only very relevant to concurrency
08:41:40 <kpreid> lars9: STM is something you use on top of threads
08:41:58 <lars9> kpreid: Berengal: thanks :)
08:42:41 <kpreid> lars9: if you want the simplest safe thing, use forkIO and MVars. STM is for when you need to coordinate changes in more complex ways
08:42:53 <kpreid> er, slightly off there
08:42:58 <kpreid> I'm not saying 'don't use STM'
08:43:16 <kpreid> I'm saying 'If you don't want to use STM and don't need it' then use look at MVar
08:44:11 <lars9> kpreid: i see. so STM is for more advanced and complex models?
08:44:17 <Berengal> STM is simply a way of combining actions that read and write to memory in such a way that the reads and writes are all conceptually atomic, even under composition
08:44:23 <jmcarthur_work> lars9, just to make sure, you are wanting concurrency, not parallelism, right?
08:44:50 <doublethink_work> STM is an alternative to locks when you need to deal with shared memory inbetween multiple threads
08:44:53 <Berengal> MVars don't have that guarantee. Instead, they guarantee that there's a write for every read
08:45:09 <doublethink_work> it is very attractive due to the fact that STM is very composable, and it's much safer and easier to get right than otherwise
08:45:10 <Gracenotes> okay, so it seems the kanji components with the longest paths are 日 and 目
08:45:43 <doublethink_work> lars9: STM works largely like a database does
08:45:44 <Gracenotes> and also 丶, although that's not a kanji itself... lemme check...
08:46:17 <lars9> thanks guys for the overview you gave
08:46:22 <doublethink_work> you attempt to atomically change values, and these values can 'rollback' and 'retry' much like a database can rollback a failed transaction
08:46:59 <doublethink_work> you absolutely have to have good error handling when dealing with locks, and locks + errors are remarkably stupidly difficult. it is much easier with STM
08:47:13 <path[l]> hi guys. I need some help. I mostly got this working. But I need 2 things. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8403#a8403 <--- the last line has an error
08:47:18 <lars9> Gracenotes: what do you mean by "longest path"? :)
08:47:36 <path[l]> I dont understand this error
08:47:43 <doublethink_work> path[l]: what is the error?
08:48:05 <path[l]>  Ambiguous type variable `b' in the constraint:
08:48:05 <path[l]>       `Ord b' arising from a use of `minSize' at mmadness.hs:20:10-16
08:48:11 <lars9> yeah. multi-threading programs in C are very easy to be buggy. so I was thinking if haskell can do better in it
08:48:14 <path[l]> Possible cause: the monomorphism restriction applied to the following:
08:48:14 <path[l]>       doStuff :: [(b, b)] -> Maybe [b] (bound at mmadness.hs:20:0)
08:48:39 <Berengal> path[l], it doesn't know which type the resulting expression has
08:48:44 <path[l]> hmm
08:49:03 <doublethink_work> lars9: indeed, and STM gives you more benefits than that!
08:49:16 <doublethink_work> transactions are composable first off.
08:49:16 <Berengal> path[l], and it needs to, because 'doStuff' can't be polymorphic because of the MR
08:49:37 <doublethink_work> on top of that with transactions it's easy to do things like get a 'snapshot' of the world that is totally consistent, because operations are atomic anyway
08:49:46 <path[l]> ok whats an MR? and why does it not know?
08:49:51 <Berengal> path[l], Either write a specific type signature for 'doStuff', or add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file
08:49:54 <doublethink_work> it's not as trivial to organize a snapshot when you're dealing with locks
08:50:05 <doublethink_work> path[l]: the monomorphism restriction is a wart
08:50:25 <Berengal> path[l], the monomorphism restriction (MR) is a restriction saying that a value cannot be polymorphic
08:50:30 <path[l]> oh
08:50:37 <Berengal> And a value is anything that doesn't take parameters, even when it's a function
08:51:09 <arw> and doing locking correctly in all kinds of situations is very hard. things like deadlocks in special situations are common.
08:52:04 <path[l]> why is it polymorphic now?
08:52:26 <doublethink_work> path[l]: your type is something like 'Ord a => a', but it needs to be a concrete type, like, say, 'Int'
08:52:36 <path[l]> oh
08:52:37 <path[l]> hmm
08:52:50 <path[l]> you mean Ive not specified what its a list of?
08:53:03 <doublethink_work> well, the type is polymorphic
08:53:05 <doublethink_work> that is the problem
08:53:12 <doublethink_work> you can just disable the monomorphism restriction
08:53:22 <doublethink_work> most everybody does anyway :)
08:53:33 <path[l]> so why is there a monomorphic restriction? is it for a good reason?
08:53:34 <doublethink_work> arw: truly locks are a 30 year old technology that for some god unknown reason we are still using today. i hope STM or something similar at least can bridge the gab
08:53:41 <mux> I don't use it if there's perfectly reasonable type signature to add
08:53:45 <Gracenotes> lars9: back... I mean, form the longest sequence of kanji composing each other.
08:54:07 <Gracenotes> at least in the 300 I've gathered data on
08:54:16 <doublethink_work> path[l]: it's due to compiler optimizations. due to the semantics of how type classes are implemented, it was deemed possible that a type like 'Ord a => a' could be evaluated twice in reality, rather than once
08:54:18 <quicksilver> path[l]: it's there for a reason, but a bad reason.
08:54:35 <path[l]> hmm
08:54:38 <Gracenotes> right now I'm trying to code up finding what the sequences actually are
08:54:40 <Berengal> path[l], yes, there's a good reason, but there's an even better reason for removing it
08:54:44 <doublethink_work> rather than leave such a problem to the whims of the particular compiler, they made it part of the language that you cannot have polymorphic values
08:54:57 <path[l]> heh
08:55:01 <doublethink_work> and avoid the issue entirely
08:55:27 * quicksilver doesnt like this use of the word 'value'
08:55:35 <mux> > let anagram = (==) `on` sort in anagram "RACE" "CARE"
08:55:36 <quicksilver> it doesn't really fix with the normal haskell terminology.
08:55:37 <lambdabot>   True
08:55:38 <doublethink_work> quicksilver: sry? :(
08:55:47 <quicksilver> I would say "syntactically not a function
08:55:56 <quicksilver> or "not in function syntax"
08:55:58 <quicksilver> or some such.
08:56:00 <doublethink_work> hm, fair enough
08:56:03 <quicksilver> functions are values in haskell.
08:56:09 <Berengal> The syntax element is my biggest gripe with the MR actually...
08:56:14 <quicksilver> ML's related - but different - value restricion uses the word value.
08:56:24 <path[l]> :t 'A'
08:56:26 <lambdabot> Char
08:56:31 <doublethink_work> quicksilver: what is ML's value restriction?
08:56:42 <jpcooper> @hoogle priority queue
08:56:43 <lambdabot> No results found
08:56:56 <Berengal> I'd be okay with non-functions being nonomorphic as long as function definitions with no parameters were allowed
08:57:00 <fasta_> Who understands Oleg's generic zippers? Please raise hands. I am not interested in asking a question about them now, just curious to who has _seriously_ looked at them.
08:57:21 <jmcarthur_work> Berengal, me too
08:57:51 <Berengal> Allowing type signatures for polymorphic values should be allowed too
08:57:53 <dolio> I do, somewhat/
08:58:00 <quicksilver> doublethink_work: they don't permit things which are syntactically-not-functions to be polymorphic *at all*
08:58:01 <jmcarthur_work> also agreed
08:58:09 <quicksilver> doublethink_work: not even parametric polymorphic
08:58:18 <quicksilver> doublethink_work: so it's a stronger restriction.
08:58:47 <gwern> Gracenotes: also, have I ever mentioned how much I despise SOLAR >.<
08:58:53 <quicksilver> Berengal: I wouldn't, it breaks the convenience of using combinators
08:58:55 <Gracenotes> it sucks.
08:59:14 <quicksilver> Berengal: but just to follow your argument through, how would you distinguish between a non-function and a function with no parameters?
08:59:38 <Berengal> quicksilver, it would inconvenience monads somewhat, yes. 2) type checking
08:59:39 <Gracenotes> it is like the direct frontend of a complicated and/or poorly designed database with no thought for UI design
08:59:48 <gwern> it's from Oracle
08:59:59 <gwern> the only way it could be worse is if it was from CA
09:00:20 <quicksilver> Berengal: oh, I see, you mean base it on the type being (->) rather than anything syntactic?
09:00:28 <Berengal> quicksilver, yes
09:00:43 <quicksilver> I hit the MR more often with non-functions than functions though :)
09:00:47 <path[l]> ok now that Ive modified it, comes my bigger question. This code works ... can anyone help me write this nicer. Haskellize it :) -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8403#a8406
09:01:13 <gwern> make it lazier
09:01:17 <gwern> or stricter
09:01:26 <Berengal> Actually, I have other reasons for wanting the MR gone as well, but they're purely practical considerations (combinators being one of them), but the syntax element goes against my sense of mathematical elegance
09:01:42 <Gracenotes> gwern the main problem, really, is that SOLAR has problems with serverside state. It meticulously ensures that the client stays in a particular state, unable to freely roam its page or (gasp) use any sort of tabs
09:02:01 <path[l]> well I think lazier is better, but I mean just more succint. I want to learn some of the common idioms people use
09:02:04 <path[l]> to solve problems
09:02:05 <gwern> Gracenotes: I think I tried once to keep the course catalogue open and have another tab do the registering
09:02:19 <path[l]> especially the first function is really ugly, with 2 nested wheres
09:02:44 <gwern> path[l]: I don't think most people would write enumFromThen 0...
09:02:50 <gwern> they'd just write [0..
09:02:52 <Gracenotes> the only solution is to screen scrape all the content! although... at the speed it uses, that would take weeks
09:02:55 <path[l]> ah
09:03:45 <path[l]> god I need to learn how to write test cases
09:03:58 <jmcarthur_work> path[l], even better, learn quickcheck! :)
09:04:13 <mux> yeah, I was going to say that, enter the wonderful land of QuickCheck :-)
09:04:19 <path[l]> hehe I just opened up that chapter of RW
09:04:20 <path[l]> H
09:04:21 <Phyx-> morning
09:04:46 <path[l]> thanks gwern, I made that change. I'd love more suggestions :)
09:04:51 <jmcarthur_work> i'm also a fan of smallcheck and lazysmallcheck, although they haven't gained the popularity that quickcheck has
09:04:56 <gwern> path[l]: you'll get extra points for smallcheck
09:05:01 <jmcarthur_work> all three do different things though
09:05:01 <gwern> those are even more esoteric
09:05:15 <lars9> haskell's function has no side effect, is this characteristic helpful for concurrency?
09:05:18 <Phyx-> what's smallcheck?
09:05:24 <Berengal> lars9, very
09:05:25 <mux> path[l]: I think most people would write `enumFromTo 0 (length xs)' as `[0..length xs]'; I only use enumFromTo if there's a possibility for a point-free version
09:05:27 <Phyx-> lars9: yup
09:05:30 <gwern> Phyx-: see?
09:05:34 <jmcarthur_work> lars9, more for parallelism than concurrency :)
09:05:41 <path[l]> mux i changed that :)
09:05:44 <Phyx-> gwern: see what?
09:05:54 <lars9> so, is there any article talking about this?
09:05:55 <Deewiant> Phyx-: See, nobody knows about smallcheck
09:05:58 <gwern> I guess my case is -
09:05:58 <jmcarthur_work> Phyx-, exhaustive checking with inputs up to some given depth
09:06:01 * gwern puts on shades
09:06:07 <gwern> rested
09:06:11 <Phyx-> lol
09:06:18 <Deewiant> YEEEEEEEEEEEAAAAAAAAAHHHH
09:06:23 <Phyx-> jmcarthur_work: how does that differ from quickcheck then?
09:06:31 <fasta_> Phyx-: not random
09:06:37 <lars9> i mean is there any article talking about using haskell's pure functionalness to help concurency
09:06:38 <jmcarthur_work> Phyx-, quickcheck is not exhaustive
09:06:50 <Deewiant> Phyx-: Quickcheck just tests X random inputs (where X = 100 by default)
09:06:55 <mux> there's also lazycheck, which I personally never used
09:06:59 <path[l]> Im looking for 3 things mainly 1) what naming/coding convention etc is common in the haskell world. How much of that code is really ugly crap to people 2) can I make the code faster or lazier or something 3) The first function looks terrible to me
09:07:02 <jmcarthur_work> i like lazysmallcheck
09:07:11 <Phyx-> ah right
09:07:12 <Phyx-> hmmm
09:07:17 <gwern> Deewiant: well, each is not random; it's biased towards small input and iirc will discard dupes
09:07:29 <Phyx-> how does it do exaustive checking? you have to specify the domain and how it can traverse it?
09:07:33 <Deewiant> Well yes, it's not that simple
09:07:42 <Deewiant> But basically it's random
09:07:52 <mux> it's not uncommon to have an infinite value space though
09:07:52 <jmcarthur_work> it's like smallcheck, but it tries building structures with _|_ near the ends and assumes that if the test passes with a partially defined structure then it would pass for all possible values that could have been used in place of _|_
09:08:16 <quicksilver> jmcarthur_work: which is a safe assumption.
09:08:26 <quicksilver> jmcarthur_work: that's called monotonicity and it's pretty fundamental.
09:08:29 <jmcarthur_work> right
09:08:36 <quicksilver> ah, sorry
09:08:48 <quicksilver> for some reason I read your comment as suggesting that was not sensible :)
09:08:52 <jmcarthur_work> haha
09:09:02 <quicksilver> I read the beginning as "I like ... but ... "
09:09:04 <jmcarthur_work> no i love lazysmallcheck, as i've said twice already ;)
09:09:05 <quicksilver> not it's like
09:09:12 <jmcarthur_work> heh
09:09:19 <gwern> wonder if malbolge has monotonicity
09:10:30 <lilac> seems like monotonicity is a consequence of the halting problem
09:10:34 <jmcarthur_work> Phyx-, you describe your data types constructors to smallcheck and it determines how to generate all values up to given depth
09:11:13 <gwern> hm. you know, ratemyprofessor.com would be a lot more helpful if commenters had to classify themselves as to whether they're geeks, jocks, etc
09:11:22 <Phyx-> jmcarthur_work: but, by definition up to a given depth != exaustive no?
09:11:23 <jmcarthur_work> Phyx-, for example, something similar to serial = con1 Just \/ con0 Nothing   -- although i forget the exact syntax. that is the syntax for a similar DSL i've been working on
09:11:37 <jmcarthur_work> Phyx-, it's exhaustive *up to* that depth
09:11:55 <gwern> 2 groups of commentors on this one professor either love him to death, or despise him utterly; but I don't know whether the lovers are fellow philosophy/religion geeks like me or whether they're the hatahs
09:12:02 <Phyx-> ~~right
09:12:28 <jmcarthur_work> Phyx-, it means you have proven that the property holds up to that depth. with quickcheck you can't make any proofs, only disproofs
09:12:35 <fasta_> gwern: who?
09:12:43 <gwern> fasta_: a william chittick
09:12:56 <gwern> not that the specific professor matters; I use him as an example
09:13:04 <jmcarthur_work> Phyx-, and the idea is that most failing cases will be small cases
09:13:06 <Phyx-> in terms of finding bugs though, aren't random testing and exaustive testing almost equal? random testing on average finds bugs quicker, but not always guaranteed to find bugs, and exaustive testing always finds the bugs, but is slower
09:13:23 <quicksilver> Phyx-: that doesn't sound 'almost equal' to me
09:13:28 <Phyx-> hehe
09:13:28 <quicksilver> that sounds like 'important tradeoff'
09:13:31 <jmcarthur_work> Phyx-, actually, i have found smallcheck to test more cases for more quickly than quickcheck does
09:13:39 <jmcarthur_work> Phyx-, regardless, they are complementary
09:13:41 <Phyx-> ok ok, i stretched the truth somewhat
09:13:48 <jmcarthur_work> *far more quickly
09:13:52 <quicksilver> smallcheck is more likely to find a really good, characteristc counterexample
09:13:58 <quicksilver> because it always finds the smallest - in some sense.
09:14:03 <jmcarthur_work> yeah, if there is a failing case, you want it to be simple
09:14:05 <Phyx-> jmcarthur_work: isn't that maybe due to in how quickcheck generates cases?
09:14:10 <jmcarthur_work> probably
09:14:12 <quicksilver> although quickcheck 2 has shrinking
09:14:19 <Phyx-> quicksilver: but doesn't quickcheck 2 shrink?
09:14:22 <Phyx-> oops, you said that
09:14:22 <Phyx-> lol
09:14:24 <quicksilver> when I used quickcheck seriously for some tough indexing stuff
09:14:30 <quicksilver> I wrong shrinking by hand, in effect.
09:14:37 <quicksilver> s/ng/te/
09:14:57 <mux> shrinking in QuickCheck seriously rocks
09:15:01 <jmcarthur_work> i have run into many cases where quickcheck could churn away on a property for a long time and report success, but smallcheck would find an error within a fraction of a second
09:15:19 <mux> you gotta love being handed the simplest possible cases for which your test fails :-)
09:15:23 <jmcarthur_work> just because the error case was small and quickcheck never touched it before it went on to the big ones
09:15:37 <Phyx-> jmcarthur_work: but the reverse can also be true
09:15:46 <jmcarthur_work> Phyx-, right. they are complementary
09:16:17 <jmcarthur_work> i have used quickcheck, smallcheck, and lazysmallcheck all in the same project before
09:16:25 <Phyx-> :O
09:16:33 <jmcarthur_work> each one providing distinct advantages over the others
09:16:42 * Phyx- has only used quickcheck, but i will take a look at smallcheck
09:17:51 <jmcarthur_work> i have not used quickcheck 2's shrinking before, i guess. i never knew about it!
09:17:58 <gwern> jmcarthur_work: what a disgustingly moderate opinion
09:18:11 <jmcarthur_work> gwern, ?
09:18:21 <gwern> 'each has its strong points'
09:18:26 <gwern> jesus would spit you out!
09:18:27 <jmcarthur_work> you mean i must choose a favorite?
09:18:32 <gwern> YES
09:18:33 <Phyx-> gwern: but it would be true :P
09:19:07 <Phyx-> gwern: that's like saying he has to choose between imperative and functional programming languages :P
09:19:15 <gwern> Phyx-: HE HAS
09:19:18 * Phyx- doesn't think that's a hard decision for you lot
09:19:20 <Phyx-> lol
09:19:21 <jmcarthur_work> Phyx-, ummm..... i would choose functional, in that case ;)
09:19:40 <Phyx-> awww
09:19:45 <Gracenotes> @hoogle unsafePerformIO
09:19:46 <lambdabot> Foreign unsafePerformIO :: IO a -> a
09:19:46 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
09:19:49 <sjanssen> Phyx-: no, it's like deciding between straight and phillips screwdrivers
09:20:17 <jmcarthur_work> it's like choosing between a screwdriver and a ham sandwich
09:20:22 <Phyx-> sjanssen: lol
09:20:27 <Phyx-> jmcarthur_work: hahahh
09:20:37 <jmcarthur_work> i choose both
09:20:40 <Phyx-> are you calling imperative languages ham sandwiches?
09:20:41 <sjanssen> jmcarthur_work: not really, both things do approximately the same thing
09:21:03 <sjanssen> but quick and smallcheck have advantages in different domains
09:21:05 <jmcarthur_work> it was an exaggeration
09:21:26 <jmcarthur_work> but i can eat a ham sandwich while screwing
09:21:28 <jmcarthur_work> ...
09:21:44 <Phyx-> sjanssen: but sometimes smallcheck isn't applicable, in for instance infinite domains?
09:21:49 <jmcarthur_work> that didn't come out right
09:21:50 <gwern> and ham sandwiches are forbidden us, for reasons of purity?
09:22:09 <jmcarthur_work> Phyx-, i think that is missing the point
09:22:24 <Phyx-> gwern: right, hand sandwiches have sideeffects
09:22:25 <jmcarthur_work> Phyx-, smallcheck does not exist to check every possible case
09:23:12 <Phyx-> jmcarthur_work: yes i know, up to a specific point it checks all cases, so it's still applicable in an infinite dommain, but if the domain if infinite, quickcheck which does random testing should have much higher chance of finding an error
09:23:30 <jmcarthur_work> Phyx-, why do you say it has a higher chance?
09:23:44 <jmcarthur_work> Phyx-, usually errors can be found in simple cases
09:24:47 <Phyx-> jmcarthur_work: right, but if you've chosen your domain subset to small for smallcheck, it would never find one. while quickcheck might
09:24:55 <jmcarthur_work> might
09:25:25 <jmcarthur_work> i still don't see how that makes it more useful. just different
09:25:44 <quicksilver> if you use either tool then, sooner or later, you will become ware fo the kind of errors that each fails to find.
09:25:49 <jmcarthur_work> huh, i like quickcheck 2's shrink
09:25:55 <quicksilver> quickcheck is very poor at finding errors of probability 0
09:26:00 * Zharf sighs
09:26:09 <quicksilver> smallcheck is very poor at finding errors which only occur when the data set gets above size M
09:26:16 <quicksilver> those are both important classes of error.
09:26:24 <quicksilver> which is more common is very domain-specific, I think.
09:26:33 <jmcarthur_work> the man speaks the truth
09:26:40 <Phyx-> i'm actually interested in how smallcheck generates values from the domain. I presume it always generates them in the same order?
09:26:45 <jmcarthur_work> yes
09:26:50 <Phyx-> jmcarthur_work: he usually does!
09:26:54 <lilac> what we need is problematiccasescheck
09:26:55 <Phyx-> untill he's sleepy
09:27:30 <quicksilver> lilac: or, provecorrect
09:27:35 <mux> no, we need findmybugs
09:27:41 <Phyx-> jmcarthur_work: how does it do the sequential generation? do you have to specify how to walk through it
09:27:51 <Phyx-> quicksilver: speaking of prove correct, i was wondering if that wasn't possible
09:27:52 <jmcarthur_work> no, we need makeitcorrect
09:27:59 <lilac> jmcarthur_work: no, writeitforme
09:28:08 <mux> getitdone
09:28:09 <jmcarthur_work> win
09:28:21 <Phyx-> quicksilver: if you specify for each pure function, what it does in terms of induction, you should be able to automatically prove a program no?
09:28:22 <jmcarthur_work> Phyx-, no, you just specify its constructors, in most cases
09:28:28 <gwern> sudo writeitforme
09:28:35 <jmcarthur_work> Phyx-, it's a bit simpler than quickcheck's Arbitrary, in my opinion
09:28:45 <mux> gwern: ^C^C^Ckillall -9 skynet
09:28:57 <lilac> writeitforme --do-what-i-mean --now
09:29:19 <lilac> mux: permission denied
09:29:31 <mux> alright, I fail. :-)
09:29:32 <Phyx-> jmcarthur_work: well,i'll give you that, Arbitrary is a bit involved, but isn't that due to the need to support complex types like Trees? to control the branching?
09:29:38 <jmcarthur_work> Phyx-, your proof idea sounds like constructive logic
09:29:54 <jmcarthur_work> Phyx-, trees are rather easy to express in smallcheck
09:30:03 <jmcarthur_work> lemme look up the API again to make sure i don't mutilate this
09:30:55 <Phyx-> jmcarthur_work: constructing trees isn't the problem, but quickcheck gives you control over how to construct it. for instance you can force the creation of balanced trees
09:31:47 <jmcarthur_work> data Tree a = Branch (Tree a) a (Tree a) | Empty ; instance Serial a => Serial (Tree a) where series = cons3 Branch \/ cons0 Empty
09:32:26 <jmcarthur_work> Phyx-, well, that's tougher, but smallcheck (and especially lazysmallcheck) have fairly efficient ways to prune the search space, too
09:32:51 <Phyx-> ah ok
09:33:12 <Phyx-> brb
09:33:30 <jmcarthur_work> Phyx-, also, if you can figure out how to make a function Int -> [a] for your type that generates the values for you then you can write a specialized Serial for it anyway
09:34:19 <u_quark> has anyone tried to compile gtk2hs-0.10.1 with ghc-6.10.4 ?
09:36:22 <gwern> NA NAHh, NUH NA NAH NAH NU NAH NAAA!!!! constdamacy!
09:37:24 <Phyx-> uhh..
09:37:27 <Phyx-> has gwern lost it?
09:37:52 <gwern> I've been possessed by the spirit of _why!
09:38:01 <gwern> WOOO bring me a synthesizer and a mike
09:38:10 * Phyx- gives you guitar hero
09:38:13 <Phyx-> all i have sir...
09:38:44 * gwern does mad air riffs. I shall make you my duke of marmalade
09:39:34 * Phyx- is scared
09:40:23 <Phyx-> jmcarthur_work: is there any such consructive logic testing for haskell? i know for imperative languages you can use something like Hoare logic
09:40:58 <quicksilver> well everything you can do with hoare logic works for haskell too
09:41:02 <quicksilver> but, it's much simpler
09:41:05 <quicksilver> due to lack of mutation
09:41:12 <quicksilver> so you don't get hoare triples at all
09:41:29 <quicksilver> you just get theorems about how the output of a function is related to the input.
09:41:47 <quicksilver> you could use hoare triples in monads if you wished.
09:42:06 <Phyx-> right, that's why i suggested some kind of induction way of specifying your function specifications, isn't that all haskell (pure) functions are
09:42:14 <quicksilver> yes.
09:42:18 <quicksilver> it's much simpler
09:42:35 * gwern snerks at this one teacher's name - 'Eva Kittay'
09:42:38 <quicksilver> hoare logic is about answering the question "Proof is easy in a pure functional language, how do we do it in an imperative one?"
09:42:53 * Phyx- was thinking of making something like that in his summe rbreak, but i pulled into the partying and wasting of braincells
09:43:10 <jmcarthur_work> Phyx-, could just play with Coq or Agda and see how proofs work there
09:43:38 <Phyx-> jmcarthur_work: i've seen a coupld of talks on Agda, never used them myself though
09:44:27 <Phyx-> last one i've seen was a way to produce parsers and their correctness proofs in Agda
09:44:41 <jmcarthur_work> agda is fun
09:44:52 <jmcarthur_work> so is coq, but i've used agda more
09:44:57 <Trinithis> Is mappend for "Monoid b => Monoid (a -> b)" just function composition?
09:45:07 <jmcarthur_work> agda interfaces with haskell, too, it's more useful to me
09:45:46 <jmcarthur_work> Trinithis, mappend = liftA2 mappend
09:45:50 <lilac> Trinithis: how could it be? it'd be mappend :: Monoid b => (a -> b) -> (a -> b) -> (a -> b)
09:46:04 <Trinithis> oh right
09:47:11 <Phyx-> jmcarthur_work: interfaces how? FFI?
09:47:24 <jmcarthur_work> Phyx-, yup
09:47:33 <jmcarthur_work> its FFI is haskell :)
09:47:44 <Phyx-> ah
09:48:28 <jmcarthur_work> my main beef with agda is a general lack of documentation
09:48:38 <jmcarthur_work> but it's not so bad
09:48:47 <Phyx-> I'm currently working on a way to make it easier to make windows dll, for my own uses, lol. I'd only have to put --@@ Export before a function and it'll be exported, (well, my preprocess would generate the needed FFI code and convertions from and between haskell types)
09:48:49 <jmcarthur_work> mostly just the standard libraries throw me off
09:50:44 <jpcooper> say I have a map which maps a session ID to a list of replies to be sent. I would like it so that a thread can get access to the map without blocking other threads, and for a thread not to be able to read its replies while the main thread is adding more. Which is the best way in which to go about this?
09:51:09 <jpcooper> *a thread can get access to its replies in the map
09:51:11 <Phyx-> jmcarthur_work: http://phyx.pastebin.com/d4169e5d1 , currently working on the convertion of the datatypes
09:51:51 <jpcooper> is keeping the map an an IORef the best solution?
09:52:15 <Phyx-> jmcarthur_work: and i plan to generate the C and C# classes/types automatically aswell
09:52:31 <jpcooper> actually sorry, I just realised that I can use a normal map with MVars
09:53:07 <jpcooper> no I can't
09:55:45 <jmcarthur_work> Phyx-, oh that's pretty nice
09:59:38 <Phyx-> jmcarthur_work: the only thing i'm still debating is, that i need to generate two and from convertions between two isomorphic datatypes, one the pure haskell type and one the haskellFFI type. I could do this at runtime using generic programming techniques, if i inforce that they must be isomorphic and constructors in the same order. howeevr this would be at runtime and rather slow, so i'm leaning towards just producing the convertion functions from the preproc
09:59:49 <Phyx-> insted of use/abuse of Data.Data and Typeable
10:02:45 <Phyx-> the trade off of the latter approach is that i would need the actual sourcecode for ever datatype i need to transform, and i would need to be able to "trace" datatype dependencies. which isn't always possible
10:05:24 <jpcooper> anyone?
10:05:44 <Zharf> vim (and haskellmode-vim) fails me
10:07:16 <jpcooper> I need some kind of mutable map
10:08:39 <Phyx-> jpcooper: mutable map? Data.Map?
10:09:07 <jpcooper> I need to allow it to be read concurrently
10:09:12 <Phyx-> ah
10:10:08 <jpcooper> at the moment I'm considering just keeping the map in an MVar
10:10:22 <Phyx-> @package persistent-map
10:10:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/persistent-map
10:10:28 <Phyx-> maybe that?
10:10:37 <jpcooper> thanks
10:10:40 <Phyx-> didn't take a look at what it really is, but the description sounds good
10:11:41 <quicksilver> Phyx-: keeping the whole map in an MVar is a good solution if you will modify it rarely.
10:11:53 <quicksilver> although a TVar is also interesting.
10:12:22 <quicksilver> people discuss more sophisticated structures like a tree which is TVars all the way down so you can concurrently modify disjoint brnaches
10:12:31 <quicksilver> but I think that's a fairly exotic case personally.
10:13:09 <Phyx-> quicksilver: i assume you mean jpcooper :P
10:13:37 <jpcooper> quicksilver, it's going to be modified a lot
10:13:55 <Phyx-> but still, keeping the whole map in a MVar wouldn't allow concurrent access to the map would it? It would just controll access to the map no?
10:14:13 <jpcooper> exactly
10:14:19 <Phyx-> the map operations would still be thread-unsafe
10:14:38 <jpcooper> gah
10:14:48 <jpcooper> concurrency rots the mind
10:14:56 <cwraith> Er.  I must have missed the part where you specified that this is a non-functional map. :)
10:15:22 <jpcooper> Phyx-, though why would it be unsafe if only one thread can view it at once?
10:16:01 <quicksilver> Phyx-: you can use it safely
10:16:11 <quicksilver> effecitvely you'd have two choices
10:16:16 <Phyx-> jpcooper: sure, it would be safe then
10:16:24 <quicksilver> (1) read and keep a copy - it risks being out of date, but no mutexes
10:16:28 <Phyx-> but for instance, lookups should be allowed concurrently by more than 1 thread
10:16:39 <Phyx-> while when modifications are going on you need to lock it
10:16:43 <jpcooper> yes I want concurrent reads but mutex for write
10:16:57 <cwraith> So...  you want a reader-writer lock?
10:16:59 <quicksilver> (2) take/work/put - thi  is mutex style.
10:17:18 <cwraith> Those are somewhat sophisticated, and you should always prefer an existing implementation for it.
10:17:20 <quicksilver> jpcooper: use readMVar for read, then, but takeMVar/dostuff/putMvar for write
10:17:29 <jpcooper> aah
10:17:36 <quicksilver> jpcooper: that mutexes your write while allowing reads safely.
10:17:45 <Phyx-> cwraith: non functional map?
10:17:51 <quicksilver> of course, the reading threads may then be working of 'old data', if it takes a while to do its thing
10:18:00 <quicksilver> but gnereally that's a sacrifice you're prepared to make.
10:18:14 <quicksilver> better to work off old data than block writeres out.
10:18:16 <Phyx-> quicksilver: ah, i see what you're saying now
10:18:30 <cwraith> Phyx-, if you're using a functional data structure, there are no concurrency issues with readers
10:18:32 <jpcooper> quicksilver, because they've been queueing?
10:18:46 <jpcooper> no that doesn't make sense
10:19:02 <quicksilver> jpcooper: when you call readMVar you get the value of the map at *that* point in time
10:19:09 <jpcooper> yes of course
10:19:10 <quicksilver> if it gets modified 10 us later
10:19:15 <quicksilver> then, that's just something you live with.
10:19:18 <jpcooper> that's fine for my application
10:19:21 <quicksilver> in many applications this is fine
10:19:32 <andrewsw> ski_: thanks a lot. that really helped! :)
10:19:40 <quicksilver> what is nice about Data.Map is that the amount of data copying minimal.
10:19:52 <Phyx-> cwraith: well, aren't functional data structures immutable, so by default, there's no problem with writing either, it just won't write to the same structure
10:19:58 <quicksilver> even if the map got modified 10 us later, the 'new' map and the 'old' map still share 99% of their in-memory storage.
10:19:59 <Phyx-> wait, no, neevr mind
10:20:10 <cwraith> that's true, Phyx-
10:20:11 <quicksilver> FSOV 99%.
10:20:35 <jmcarthur_work> i personally think TVars all the way down would at least make a cool benchmark for STM, though
10:20:39 <cwraith> But if you change the reference (as the MVar discussion is talking about), you have the potential to read stale data, which is a form of concurrency issue
10:20:57 <jpcooper> jmcarthur_work, the threads using the map would have to do IO as well
10:21:20 <jmcarthur_work> jpcooper, the IO must be atomic as well?
10:21:26 <jpcooper> no
10:21:37 <jpcooper> what I want to say is that I don't see what difference it would make
10:21:57 <jmcarthur_work> then in the TVar scenario you could just do atomically (...) >>= ioStuff
10:22:11 <jpcooper> sure
10:22:17 <jmcarthur_work> i wasn't recommending the TVar approach anyway
10:22:28 <jmcarthur_work> i was just saying a map made out of TVars would make a neat experiment
10:24:32 <Phyx-> out of curriousity, which synchronization primitives are theire libs for? mutexes? and...?
10:26:34 <path[l]> aw come on, no one had any suggestions for me?
10:26:44 * Twey scrolls up.
10:26:49 <Phyx-> path[l]: what did you ask?
10:26:53 * Twey scrolls up more.
10:26:55 <jmcarthur_work> yeah i can't find it
10:27:18 <path[l]> oh I had finally finished that problem. I was hoping for feedback and suggestions for changes
10:27:26 <Twey> What problem was that?
10:27:32 <path[l]> missing idioms, shortcuts and bad naming conventions
10:27:42 <path[l]> umm its a pretty silly academic type problem =p
10:27:42 <quicksilver> Phyx-: MVars and TVars and Chans and TChans
10:27:54 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8403#a8406 <--- its all here
10:27:57 <path[l]> with my comments
10:28:18 <quicksilver> Phyx-: MVars are slightly more clever than ordinary mutexes; mutexes are just one of the things you can do with them
10:28:39 <Phyx-> ah ok, Chans i know, what's TChan?
10:28:53 <jmcarthur_work> channels in STM
10:29:00 <Phyx-> ah ok
10:29:25 <Phyx-> path[l]: i constantly get told by my proffesors that i have bad haskell coding style, so i wouldn't know
10:29:32 <Phyx-> can't find any clear guidelines
10:29:36 <jmcarthur_work> they actually can go a bit faster than Chans in some cases since a lot of the error checking that Chan has to do for every operation can be delayed until the end of a transaction
10:29:36 <path[l]> lol
10:30:00 <path[l]> well really its a "what would you change" question
10:30:04 <quicksilver> same thing but in STM ;)
10:30:04 <path[l]> :)
10:30:11 <path[l]> I wanna see what tricks I missed
10:30:16 <Phyx-> path[l]: link?
10:30:24 <jmcarthur_work> Phyx-, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8403#a8406
10:30:47 <cwraith> path[l], I'd suggest putting explicit type declarations on your top-level functions.  It's handy when reading code.
10:31:02 <cwraith> Well, your top-level declarations, code or otherwise
10:31:06 <jmcarthur_work> yeah, especially when asking for help :)
10:31:13 <path[l]> hmm ok. I have one on the top line, but you suggest on the others too?
10:31:17 <quicksilver> so you can guarantee consistency.
10:31:24 <jmcarthur_work> i put type signatures on all top level functions
10:31:29 <path[l]> ok
10:31:29 <quicksilver> e.g. safely read two items and know they will truly be consecutive.
10:32:28 <path[l]> ok I can quickly modify that
10:34:09 <Phyx-> path[l]: i write types before the actual body, it helps keep me focused onw hat i'm trying ot achieve
10:35:14 <path[l]> ah
10:35:20 <path[l]> Ill try that :)
10:36:46 <lilac> path[l]: in charHash, the lambda can be rewritten: (\(x,y) -> (x, [x,y])) which might be clearer
10:36:48 <Phyx-> also usefull for debugging, as it'll thor an error at the function instead of where it was used
10:37:20 <Phyx-> throw*
10:37:22 <path[l]> ah I see that makes sense
10:37:23 <path[l]> lilac
10:38:01 <lilac> in allSubSeqs, enumFromTo 0 (length xs) would be more idimatically written as [0..length xs]
10:38:20 <path[l]> oh I forgot to update that. I changed the enimfromTo
10:38:21 <path[l]> s
10:38:42 <lilac> i'd write [0..length xs] >>= flip subseqs xs
10:39:35 <mauke> zipWith const [0 ..] xs
10:39:51 <mauke> ah, off by one
10:40:59 <lilac> path[l]: i think allSubSeqs can be written significantly better
10:41:11 <path[l]> :o, ok
10:41:22 <path[l]> hmm I didnt understand [0..lengths]
10:41:25 <lilac> > filterM (const [True, False]) [1..4]
10:41:26 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
10:43:27 <lilac> > inits [1..4] >>= (init . tails)
10:43:29 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
10:45:00 <lilac> path[l]: minor thing: you don't need parens around Char in the type of doStuff. [(Char, Char)] -> Maybe [Char] is fine
10:45:17 <Phyx-> bbl
10:45:27 <path[l]> huh? but its a
10:45:32 <path[l]> whats that called
10:45:40 <path[l]> tuple
10:45:58 <lilac> yeah. you need (Char, Char). but ((Char), (Char)) is excessive
10:46:08 <path[l]> ah
10:46:15 <ray> there are no one-tuples
10:47:15 <lilac> path[l]: use M.size hash instead of length (M.keys hash)
10:47:30 <path[l]> oh ok
10:47:33 <path[l]> thats nice
10:48:53 <lilac> path[l]: nub is pretty horrible, performance-wise. if you care about that, you might want to use Data.Set
10:49:25 <path[l]> yeah I do
10:49:25 <path[l]> ok
10:49:27 <lilac> if not, i'd find "nub (xs >>= (hash!))" easier to read
10:49:28 <path[l]> let me read up on Data.Set then
10:50:43 <ray> a Data.Set isn't capable of having duplicate elements, so you don't need nub
10:50:55 <ray> it also keeps things ordered for you
10:52:02 <path[l]> yeah
10:53:53 <path[l]> ok fair enough
10:53:57 <path[l]> Ill work on that
10:54:08 <dons> ?yow
10:54:09 <path[l]> any suggestions on the first subseqs
10:54:09 <lambdabot> ... I have read the INSTRUCTIONS ...
10:54:27 <path[l]> I didnt understand the suggestion about [0..length xs] >>= flip subseqs xs
10:55:22 <Berengal> Does STM have any sort of timeout?
10:56:00 <dons> Berengal: you mean, if a transaction doesn't succeed after a period ?
10:56:06 <Berengal> dons, exactly
10:58:47 <Berengal> for example 'watchdog pingChan = forever $ atomically (stmTimout 1000 (readTChan pingChan) >> return True `orElse` return False) >>= \gotPing -> when (not gotPing) restartThread'
10:59:29 <Berengal> It probably isn't hard to do with MVars though...
11:10:56 <al23> Hi! I found out that many attempts to teach Haskell for newcomers (e.g. the Hutton's textbook) just ignore monads and arrows. What do you think about it? How would you teach monads/arrows in a course on Haskell? (Well, I mean pedagogical issues, not conceptual.)
11:11:57 <dons> arrows aren't so important
11:11:59 <dons> monads are.
11:12:06 <erikc> al23: i'd teach it as a programmable semicolon
11:12:18 <Baughn> I'd probably try to teach the functor/applicative/monad hierarchy
11:12:31 <Baughn> (That's how I finally got it fully, so I'm biased)
11:12:31 <erikc> the larger picture stuff will probably only come if they study/experiment on their own
11:13:04 <al23> Baughn, OK, I think I got it that way too.
11:13:04 <erikc> use examples of the common monads
11:13:21 <Berengal> Baughn, ditto
11:13:45 <Berengal> But I had been doing monadic programming with Maybe, State and IO for a while before monads finally clicked
11:14:01 <jmcarthur_work> i think practice is far better than instruction for monads
11:14:04 <Baughn> Same. Heck, I even implemented State.
11:14:25 <Baughn> Understanding the hierarchy helped immensely with understanding /why/ to use monads
11:14:40 <jmcarthur_work> but yeah, i like Functor -> Applicative -> Monad, maybe skipping Applicative, but i don't know
11:14:59 <Baughn> Splitting Applicative, here (Pointed's nice)
11:15:24 <jmcarthur_work> i only say maybe skip Applicative because it doesn't seem to contribute to Monad besides pure = return, and you might as well just do Pointed, like Baughn said
11:15:32 <Berengal> Heh, me too. I implemented both Maybe and State, and understood those pretty well, but it wasn't until I learned applicatives that monads finally made sense. I groked Functors a bit before then
11:15:33 <Baughn> @type maybe (return ()) -- By the way, is there another name for this?
11:15:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
11:16:05 <jmcarthur_work> i guess i do like the *motivation* of needing Monads when you only have Applicative
11:16:21 <jmcarthur_work> Applicative makes it obvious that you need join for certain things
11:16:31 <jmcarthur_work> and bind is a simple derivation from there
11:16:46 <erikc> al23: also, who are the students? :)
11:16:53 <Berengal> jmcarthur_work, or the other way around, for sequential monads (like IO)
11:16:55 <Baughn> Indeed. It was a sad day when they decided not to put join inside the monad class
11:16:57 <jmcarthur_work> although the motivation for join also comes easily just from Functor and Pointed
11:17:04 <al23> There are plenty of tutorials on monads (for every fancy :-). But many of them are not so good...
11:17:09 <Berengal> Depends on the context
11:17:21 <al23> erikc, well, some abstract motivated students.
11:17:25 <Baughn> al23: Have you read the typeclassopedia?
11:17:40 <al23> Baughn, yes.
11:17:50 <Berengal> What I think is lacking, or at least what lacked when I learned monads, is a focus on the difference between Monad and instances of Monad
11:18:05 <Baughn> al23: All right. Speaking for myself only, what I'd try to do is turn that into a class.
11:18:16 <Baughn> Er.. lecture series
11:18:23 <Baughn> ..lecture? It's not that large
11:18:38 <jmcarthur_work> i wish it was easy to just teach the types without the student being like "so what?"
11:18:51 <Berengal> In essence though, it's all there in the types
11:18:55 <jmcarthur_work> monads really aren't hard, besides that "so what?" part
11:19:03 <al23> :-)
11:19:05 * Baughn pokes Control.Monad
11:20:12 <al23> OK, The Typeclassopedia is very good.
11:20:32 <Berengal> Perhaps something like 1: why you can't have IO in a pure lazy language, 2: this is a monad, look at the pretty types, 3: zomg! IO after all!
11:20:49 <erikc> it's full of stars!
11:20:56 <jmcarthur_work> i'd maybe skip step 1
11:21:06 <jmcarthur_work> might distract from step 2
11:21:20 <Berengal> jmcarthur_work, it's required for the motivation
11:21:27 <Berengal> Doesn't have to be emphasized
11:21:30 <jmelesky> is there a takeWhile or filter that returns index as well as value?
11:21:31 <jmcarthur_work> i would show a few pure examples that could benefit from a monad first
11:21:37 <Gracenotes> @src unzip
11:21:38 <jmcarthur_work> maybe, list, etc.
11:21:38 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
11:21:41 <Berengal> jmcarthur_work, you do that in step 2
11:21:41 <jmcarthur_work> show the common structure
11:22:32 <jmcarthur_work> i don't think IO is the only motivation for monads
11:22:42 <dino-> jmcarthur_work: re: "so what?"  I had read something at one point, I think it was Chris Smith. About how static type checking and testing are working towards the same goal. Types working harder for you eliminates work.
11:22:43 <jmcarthur_work> and it's not a very intuitive motivation, for sure
11:22:52 <Berengal> jmcarthur_work, you show that too in step 2 :)
11:22:54 <dino-> This always seems to me like it should mean a lot to everybody.
11:23:27 <jmcarthur_work> dino-, yeah, see how far that gets you in #ruby ;)
11:23:31 <erikc> haha
11:23:48 <dino-> jmcarthur_work: Or Perl, yep.
11:24:03 <Gracenotes> @type foldr (\(a,b) ~(as,bs) -> (a++as,b++bs)) ([],[])
11:24:05 <lambdabot> forall a a1. [([a], [a1])] -> ([a], [a1])
11:24:43 <pr> @hayoo forall a . (a -> b) -> [a] -> [a]
11:24:44 <lambdabot> Unknown command, try @list
11:24:48 <pr> @hoogle forall a . (a -> b) -> [a] -> [a]
11:24:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
11:24:49 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
11:24:49 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
11:25:22 <hackagebot> X11-xdamage 0.1.0 - A binding to the Xdamage X11 extension library (DonaldStewart)
11:25:27 <Gracenotes> > (foldr (\(a,b) ~(as,bs) -> (a++as,b++bs)) ([],[]) $ repeat ([1],[2])) !! (10^5)
11:25:29 <lambdabot>   Couldn't match expected type `[a]'
11:25:42 <Berengal> Woah, I just saw how a stack and point-free code is the same thing
11:26:04 <Gracenotes> <everyone> Congratulations! <shinji> thanks, all ^_^
11:27:02 <Gracenotes> Berengal: it's cool, right, like how dup is join, swap is flip, and =<< and <*> are dup + function application
11:27:23 <hackagebot> X11-xshape 0.1.0 - A binding to the Xshape X11 extension library (DonaldStewart)
11:27:25 <Gracenotes> you know Factor, or Forth, or some other language?
11:27:52 <Berengal> Gracenotes, indeed. I was just thinking about GolfScript using a stack to minimize the need for variables, and then realized this was exactly what pointless code does too
11:28:31 <Gracenotes> it's also why stack-based languages are called "applicative", I think...
11:28:42 * EvilRanter thought they were called "concatenative"
11:29:00 <Gracenotes> that too. concatenative is applicative+some other stuff, iirc
11:29:08 <EvilRanter> ... because concatenation works as composition in stack-based languages
11:29:34 <dino-> This is what I was thinking of: http://www.pphsg.org/cdsmith/types.html
11:30:20 * erikc <3 factor
11:30:30 <erikc> dont think i could program in it, but i love the idea of it
11:30:42 <Gracenotes> I wouldn't exactly call point-free Haskell concatenative... the term seems to be used more for languages where it's built in heavily\
11:31:10 <jmcarthur_work> it's concatenative *style*
11:31:33 <jmcarthur_work> or at least bears very strong resemblance to concatenative style
11:31:42 <Gracenotes> the term is also applied to languages. So, languages particularly amenable to the concatenative style. I suppose.
11:33:39 <Taejo> is there a function in the libraries that works like zipWith mappend, but extends the shorter list with mempty
11:34:01 <jmcarthur_work> Taejo, no, but i reimplement it all the time and have thought about a little package for it
11:34:16 <Zharf> ha, haskell-platform doesn't even compile
11:34:32 <Gracenotes> even ones where you can specify the function and default value would be nice
11:34:53 <roconnor> @djinn ((a -> DJ b) -> DJ a) -> DJ a
11:34:53 <lambdabot> Error: kind error: (KVar 2,KStar)
11:35:03 <roconnor> @djinn ((a -> DJ r b) -> DJ r a) -> DJ r a
11:35:04 <lambdabot> -- f cannot be realized.
11:35:24 <dolio> Heh, I tried that yesterday.
11:35:44 <jmcarthur_work> DJ?
11:35:47 <roconnor> @djinn J r (Cont r a) -> Cont r a
11:35:48 <lambdabot> f a b = a (\ c -> c b) b
11:36:06 <roconnor> @src callCC
11:36:06 <lambdabot> Source not found. Sorry.
11:36:17 <dolio> @djinn J Void a -> Not a -> a
11:36:17 <lambdabot> f a = a
11:37:13 <Berengal> roconnor,J?
11:37:22 <dolio> J r a = (a -> r) -> a
11:37:41 <roconnor> @djinn-src
11:37:41 <lambdabot> Unknown command, try @list
11:37:45 <roconnor> @list
11:37:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:37:50 <dolio> @djinn-env
11:37:50 <lambdabot> data () = ()
11:37:50 <lambdabot> data Either a b = Left a | Right b
11:37:50 <lambdabot> data Maybe a = Nothing | Just a
11:37:50 <lambdabot> data Bool = False | True
11:37:50 <lambdabot> data Void
11:37:53 <lambdabot> type Not x = x -> Void
11:37:54 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:37:56 <lambdabot> type Cont r a = (a -> r) -> r
11:37:58 <lambdabot> data DJ r a = DJ ((a -> r) -> a)
11:38:00 <lambdabot> type J r a = (a -> r) -> a
11:38:02 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
11:38:55 <roconnor> Berengal: http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
11:39:05 <Berengal> roconnor, thanks
11:39:06 <roconnor> jmcarthur_work: ^^
11:39:37 <jmcarthur_work> oh that
11:40:14 <jmcarthur_work> very Cont-like
11:40:16 <roconnor> DJ is data J
11:40:35 <roconnor> jmcarthur_work: there is a natural transfrom from J to Cont
11:41:01 <dolio> @djinn J Void (Either a (Not a))
11:41:02 <lambdabot> f a = Right (\ b -> a (Left b))
11:41:23 <dolio> @djinn J r (Either a (a -> r))
11:41:24 <lambdabot> f a = Right (\ b -> a (Left b))
11:41:41 <roconnor> I think J Void is a bad type to have
11:41:49 <roconnor> oh
11:41:54 <roconnor> never mind
11:41:58 <roconnor> I take that back
11:42:00 * Berengal doesn't get it
11:42:25 <dolio> roconnor: Yeah, well, "Not a -> a" is a pretty nonsensical type.
11:43:15 <dolio> @djinn Cont Void (Either a (Not a))
11:43:15 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
11:45:00 <Gracenotes> @djinn Monad m => (a -> b) -> m a -> m b
11:45:01 <lambdabot> -- f cannot be realized.
11:45:49 <Gracenotes> djinncat haz inadequate typeclass polymorphism
11:46:31 <Gracenotes> djinncat's logical framework not leik it
11:46:38 <dolio> Using monad correctly given how djinn handles type classes would require rank-2 polymorphism.
11:47:28 <hackagebot> openid 0.1.2.0 - An implementation of the OpenID-2.0 spec. (TrevorElliott)
11:48:28 <hackagebot> bindings-libusb 0.0.7 - Check bindings-common package for directions. (MauricioAntunes)
11:52:20 <twanvl_> @djinn (a -> m a, b -> m b, m a -> (a -> m b) -> b) -> (a -> b) -> (m a -> m b)
11:52:21 <lambdabot> f (_, a, b) c d = a (b d (\ e -> a (c e)))
11:53:12 <twanvl_> if djinn did just instantiate the class for all the types mentioned in the signature, it could probably handle 90% of the cases
11:55:25 <dolio> @djinn J r (Either a (a -> J r b))
11:55:25 <lambdabot> -- f cannot be realized.
11:59:49 <dolio> @djinn Cont r (Either a (a -> Cont r b))
11:59:49 <lambdabot> f a = a (Right (\ b _ -> a (Left b)))
12:00:34 <dolio> @djinn (((a -> Void) -> a) -> a) -> Either a (Not a)
12:00:34 <lambdabot> -- f cannot be realized.
12:00:45 <dolio> I wonder why djinn can't figure that out...
12:00:57 <dolio> Oh, I think I know...
12:02:06 <dolio> @djinn (((Either a (Not a) -> Void) -> Either a (Not a)) -> Either a (Not a)) -> Either a (Not a)
12:02:06 <lambdabot> f a =
12:02:06 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
12:02:06 <lambdabot>     Left d -> Left d
12:02:06 <lambdabot>     Right e -> Right e
12:06:09 <etpace_> Does anyone here use vim? I've installed haskell-mode for it, but I can't really get it to indent properly, what's the correct method?
12:07:06 <mauke> what happens?
12:08:04 <etpace_> well, with guards and otherwise, i'd like the guards to be aligned, but highlighting and using `=' seems to just dedent items
12:17:41 <nomeata> Cabal does not proivde directly for installing files to locations like /etc, does it?
12:17:57 <dcoutts> nomeata: no
12:18:18 <dcoutts> nomeata: only data files, which traditionally go in $share
12:18:27 <nomeata> ok, thanks
12:18:45 <dcoutts> nomeata: you're welcome to propose something of course
12:19:04 <dcoutts> nomeata: the problem with /etc is that it's not clear that it works for per-user installs
12:19:27 <dino-> On a similar note, I had written some custom Setup.hs code recently to install the man page for something.
12:19:53 <nomeata> dcoutts: yes, I didn’t really expect it, but I wanted to check.
12:19:55 <dino-> yeah, that's probably a screw-up for mine too.
12:19:55 <dcoutts> dino-: I hope eventually we'll get better support for man pages in Cabal directly
12:19:59 <dino-> user/global
12:20:34 <dcoutts> nomeata: eg for a tool that can be run per-user, one would usually have it initialise for that user the first time it runs
12:21:07 <dcoutts> nomeata: and that could be by copying a data file in $share to the config location, like ~/.appname or whatever
12:21:21 <nomeata> My case was a autostart .desktop file, which either goes to /etc/xdg/autostart , or ~/.config/autostart
12:21:42 <dcoutts> nomeata: hmm
12:22:00 <nomeata> but it really is no issue. People either know what to do, or they use distribution packages :-)
12:22:13 <dcoutts> nomeata: I see, so that's something for external packages, rather than for the package itself
12:23:04 <dcoutts> nomeata: the other problem of course is we'll bump into the problem that each distro arranges /etc differently, eg where bash completion scripts live etc etc
12:24:05 <nomeata> Yes, I really don’t think there is a need to create a fully featured package management system again, when there are already good ones in use out there.
12:24:21 <nomeata> (Which kind of ignores windows users, but they don’t have /etc anyways :-))
12:24:43 <dcoutts> nomeata: sure but there's the issue of translating
12:24:45 <dino-> nomeata: It's called C:\WINDOWS there
12:24:56 * nomeata notices that I really should not put really in each sentence.
12:25:12 <dcoutts> nomeata: we do want to make it possible to automate the conversion of most packages from Cabal to native formats
12:26:04 <dino-> Out of curiosity, did Apple stay with /etc or did they invent something new for OSX?
12:27:44 <dino-> nomeata: If it helps, the Setup I did for the man page copy/install is in this project: http://ui3.info/darcs/uacpid/
12:28:24 <nomeata> dino-: thx. but I’ll leave it to the user/package maintainer to install the autostart file. maybe not everyone wants it
12:28:49 <dino-> wise choice
12:32:45 <nomeata> ah, my haskell-based automatic rule based time tracking tool starts to work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8413#a8413
12:34:41 <nomeata> hmm, the Chart library does not provide a widget to include in ones own application, even though it can display charts in a gtk window.
12:36:09 <endojelly> First record: 2009-08-21 10:16:44.951741 UTC
12:36:09 <endojelly> Last record: 2009-08-21 10:16:44.951741 UTC
12:36:13 <endojelly> nomeata, that right?
12:36:26 <endojelly> Total time recorded: 11460s
12:36:29 <endojelly> guess not?
12:36:39 <nomeata> endojelly: of course not, typo in the variable name :-)
12:36:42 <nomeata> endojelly: thx
12:36:54 <endojelly> 8)
12:42:48 <boscop> meow
12:45:40 <orclev> ok, I'm a haskell noob, but I can't seem to figure out how to do this... I've got a [String] and I want to re-arrange the elements, so I'm trying to do something like "foo (x:y:z:zz) = [z:x:y:zz]"
12:46:19 <orclev> only it keeps complaining it can't match the expected type Char against the inferred type String
12:46:30 <orclev> or some variation on that
12:47:15 <jfoutz> > (\(x:y:z:zz) -> z:y:x:zz) [1..5]
12:47:17 <lambdabot>   [3,2,1,4,5]
12:48:11 <jfoutz> z is a char, zz is a list, when you stick the [] around z:zz, it tries to make something like [[x]]
12:49:31 <orclev> shouldn't z by a String though? so a [Char]?
12:49:55 <jfoutz> > (\(x:y:z:zz) -> z:y:x:zz) "hello"
12:49:57 <lambdabot>   "lehlo"
12:49:57 <jfoutz> vs
12:50:06 <jfoutz> > (\(x:y:z:zz) -> [z:y:x:zz]) "hello"
12:50:07 <lambdabot>   ["lehlo"]
12:50:44 <jfoutz> not sure why your foo was giving you trouble...
12:52:26 <orclev> hmm... it's not a single string though, I'm not trying to re-arrange the String, it's a [String] and I'm trying to change the order of that
12:52:56 <jfoutz> > (\(x:y:z:zz) -> z:y:x:zz) ["hello","b","c","d"]
12:52:58 <lambdabot>   ["c","b","hello","d"]
12:53:25 <orclev> yeah, that's what I'm doing.... wierd
12:53:43 <jfoutz> i think you're on the right track. maybe add type declarations to your functions. maybe something isn't what you think it is.
12:53:44 <mauke> orclev: no, you said you're doing [z:x:y:zz]
12:53:59 <orclev> I've tried both
12:54:25 <jfoutz> well, even so
12:54:39 <jfoutz> > (\(x:y:z:zz) -> [z:y:x:zz]) ["hello","b","c","d"]
12:54:41 <lambdabot>   [["c","b","hello","d"]]
12:55:19 <orclev> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3382#a3382
12:55:42 <jfoutz> ah. i see.
12:55:46 <mauke> the first line is wrong
12:55:49 <mauke> e is not at the end
12:55:50 <jfoutz> so....
12:55:54 <jfoutz> :t (:)
12:55:56 <lambdabot> forall a. a -> [a] -> [a]
12:55:56 <poe> ?type ?x:?xs
12:55:59 <lambdabot> Not in scope: data constructor `:?'
12:55:59 <lambdabot> Not in scope: `xs'
12:56:16 <jfoutz> see, : sticks a Char on the front of a String
12:56:32 <mauke> or a string in front of a list of strings
12:56:49 <jfoutz> you can't use : to do
12:56:55 <orclev> hmm... well, it should match all elements exactly... do I need to append a "empty" variable on the end to match the non-existent remainder?... or does it match against []?
12:57:06 <jfoutz> > (\x:xs -> xs:x) [1..4]
12:57:08 <lambdabot>   <no location info>: parse error on input `:'
12:57:13 <mauke> orclev: what are you trying to match?
12:57:19 <jfoutz> > (\(x:xs) -> xs:x) [1..4]
12:57:20 <lambdabot>   Occurs check: cannot construct the infinite type: t = [[t]]
12:57:39 <orclev> something like ["X","Y","Z","ZZ"]
12:57:53 <mauke> f [a, b, c, d] = [c, d, a, b]
12:58:40 <orclev> ah, that did it, appending a junk variable to the end made it work
12:58:52 <jfoutz> > (\(x:y:z:[]) -> z:y:x:[]) [1,2,3]
12:58:53 <lambdabot>   [3,2,1]
12:59:03 <orclev> yeah, more or less
12:59:21 <EvilTerran> isn't that (\[x,y,z] -> [z,y,x])
12:59:23 <EvilTerran> ?
12:59:32 <jfoutz> EvilTerran: yeah
12:59:48 <orclev> EvilTerran, maybe so, but ghc doesn't seem to like it when you're matching against [String]
13:00:09 <orclev> hmm
13:00:13 <mle> sure it does
13:00:22 <orclev> doh, [x,y,z] is shorthand for x:y:z:[] isn't it?
13:00:25 <jfoutz> orclev: hmm. i'm not explaining the (:) operator well.
13:00:38 <jfoutz> :t (:)
13:00:40 <lambdabot> forall a. a -> [a] -> [a]
13:00:58 <orclev> ok, I see where I got confused
13:00:59 <jfoutz> it takes a thing and a list, ans sticks the thing on the front of the list.
13:01:17 <jfoutz> oh good. :)
13:01:27 <endojelly> actually, it's what the list *is* 8)
13:01:34 <endojelly> it's the lists constructor
13:02:09 <endojelly> a list of type [a] has two constructors: [] and a : [a]
13:03:01 <endojelly> so, yeah, [x,y,z] is just syntactic sugar for x:y:z:[]
13:03:03 <EvilTerran> > 1:2:3:[]
13:03:05 <lambdabot>   [1,2,3]
13:03:10 <EvilTerran> > 1:[2,3,4]
13:03:11 <lambdabot>   [1,2,3,4]
13:04:36 <orclev> this fixed version: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3382#a3383
13:04:46 <orclev> the fixed version even
13:05:03 <endojelly> orclev, looks good
13:05:14 * jfoutz agrees
13:05:15 <orclev> heh, not only looks good, it actually works :P
13:05:50 <endojelly> orclev, nono. we don't care about that, that's already proven. we only care about whether it looks good ;)
13:05:56 <orclev> lol
13:06:33 <endojelly> nomeata, have you had any news about justIf?
13:06:34 <orclev> was it kneuth I think that has the quote about "I've only proven this, I haven't tested if it actually works"
13:06:44 <msteele_> yes
13:07:08 <endojelly> orclev, knuth (without e), yes
13:07:11 <endojelly> "I have only proven it correct, not tested it."
13:07:37 <jfoutz> orclev: one big difference, if you pass in a long list, you'll get a pattern match error. the other style (while broken) just works on the front of *any* list
13:08:07 <jfoutz> well. not any list... any list that's long enough.
13:08:46 <orclev> jfoutz, I'm not really concerned about passing too many parameters, this is plugging into a interface that always returns 4 or 3 items and if it returned more or less I wouldn't know how to interpret that anyway
13:09:21 <orclev> although the point is well take
13:09:23 <orclev> taken
13:09:25 <jfoutz> ok. :)
13:11:21 <orclev> ok, one last thing sort of related to lists... I remember reading something about using ++ versus : where one of them gives really bad performance when concatenating strings? or am I remembering something wrong?
13:12:05 <EvilTerran> orclev, as it stands, if you get the wrong number of items you'd get a run-time error "Non-exhaustive patterns in function myOrderArrange", which I imagine is fine in this situation
13:12:19 <orclev> EvilTerran, correct
13:12:37 <EvilTerran> orclev, : takes constant time, as it's a constructor
13:12:52 <EvilTerran> and ++ does one : for each item in its left parameter
13:13:01 <EvilTerran> (well, if you force the entire list afterwards)
13:13:20 <EvilTerran> ?src (++)
13:13:20 <lambdabot> []     ++ ys = ys
13:13:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:13:21 <lambdabot> -- OR
13:13:21 <lambdabot> xs ++ ys = foldr (:) ys xs
13:14:29 <dschoepe> Does darcs send support signing with PGP/MIME instead of inline signing?
13:16:23 <orclev> hmm... am I missing something or can I just do "foo" : x?
13:17:57 <EvilTerran> orclev, if x :: [String], yes, otherwise, no
13:18:22 <EvilTerran> > let x = words "and some other words" in (x, "foo":x)
13:18:24 <lambdabot>   (["and","some","other","words"],["foo","and","some","other","words"])
13:28:17 <Taejo> @pl gates n gs = SN n [gs]
13:28:17 <lambdabot> gates = (. return) . SN
14:03:46 <Phyx-> evening
14:05:32 <copumpkin> evening Phyx-
14:05:59 <fbru02> evening !
14:06:28 <Phyx-> :)
14:06:33 <Phyx-> everyone having a good friday?
14:06:39 <Phyx-> almost quitting time aint it?
14:06:57 <fbru02> nah im learning hask because i like it :)
14:06:57 <copumpkin> yup yup
14:07:04 <copumpkin> fbru02: hask the categorY?
14:07:19 <Phyx-> or, shortcut for haskell?
14:07:35 <fbru02> copumpkin: category and haskell the language im currently reading cat theory for the comptuer scientist
14:07:41 <copumpkin> h
14:07:42 <copumpkin> ah
14:07:56 <Taejo> :t ((^), (^^), (**))
14:07:58 * Phyx- is buying books for the next term
14:07:59 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
14:08:09 <Phyx-> amazon.co.uk here i come
14:08:41 <Phyx-> > Just 1 `mappend` Just 2
14:08:43 <lambdabot>   Add a type signature
14:08:51 <Phyx-> > Just 1 `mappend` Just 2 :: Maybe Int
14:08:52 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:08:52 <lambdabot>    arising from a use of...
14:08:53 * Berengal is trying to write a completely bug-free concurrent server
14:09:05 <Phyx-> > (Just 1 `mappend` Just 2) :: Maybe Int
14:09:08 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:09:08 <lambdabot>    arising from a use of...
14:09:16 <copumpkin> > Just (Sum 1) `mappend` Just (Sum 2)
14:09:17 <lambdabot>   Just (Sum {getSum = 3})
14:09:18 <Phyx-> > (Just 1) `mappend` (Just 2) :: Maybe Int
14:09:20 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:09:20 <lambdabot>    arising from a use of...
14:09:41 <Berengal> STM is fun
14:09:42 <EvilTerran> Phyx-, the Monoid instance for Maybe a depends on a Monoid instance for a to merge Justs
14:10:07 <copumpkin> > Just (Product 5) `mappend` Just (Product 2)
14:10:08 <lambdabot>   Just (Product {getProduct = 10})
14:10:09 <copumpkin> > Just (Product 5) `mappend` Nothing
14:10:11 <lambdabot>   Just (Product {getProduct = 5})
14:10:22 <EvilTerran> > getFirst $ First (Just 1) `mappend` First (Just 2)
14:10:24 <lambdabot>   Just 1
14:10:40 <EvilTerran> > getLast $ Last (Just 1) `mappend` Last (Just 2)
14:10:42 <lambdabot>   Just 2
14:11:24 <copumpkin> > getFirst $ Last undefined `mappend` Last 5
14:11:26 <lambdabot>   Couldn't match expected type `Data.Monoid.First a'
14:11:33 <copumpkin> > getLast $ Last undefined `mappend` Last 5
14:11:34 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
14:11:34 <lambdabot>    arising from the lite...
14:11:42 <Berengal> Is there any reason to use 'newtype Foo = Foo (Bar, Bar)' instead of 'data Foo = Foo Bar Bar'?
14:12:15 <Berengal> I guess you could get some instances for free...
14:12:20 <EvilTerran> maybe if you want the NewtypeDeriving
14:12:21 <copumpkin> yeah
14:12:34 <Berengal> But other than that?
14:13:00 <EvilTerran> not that i know of
14:13:26 <EvilTerran> it'd be like using "newtype Foo = Foo (Either Bar Baz)" instead of "data Foo = FooBar Bar | FooBaz Baz"
14:18:53 <jmcarthur_work> the free instances is pretty nice though
14:19:10 <Berengal> They can be, if they're interesting
14:19:14 <EvilTerran> normal deriving will do the job for the standard ones, of course
14:19:16 <Berengal> And relevant
14:19:25 <Phyx-> wow, this internet sucks
14:19:26 <jmcarthur_work> EvilTerran, not Functor, Monad, etc.
14:19:35 <jmcarthur_work> oh "the standard ones"
14:19:37 <jmcarthur_work> n/m
14:19:54 <EvilTerran> jmcarthur_work, yeah, i meant "for the ones it works for" by that; a bit of a truism, really
14:19:55 <Phyx-> copumpkin: Sum?
14:19:55 <Berengal> won't we be able to derive Functor and Monad soon?
14:20:10 <jmcarthur_work> Berengal, fat chance
14:20:17 <jmcarthur_work> Berengal, did you hear that somewhere?
14:20:23 <EvilTerran> Phyx-, it's a newtype defined in Data.Monoid
14:20:25 <copumpkin> Phyx-: there are multiple monoids over the same set (type) so they give newtypes to choose which one you want
14:20:36 <Phyx-> ah
14:20:47 <Berengal> jmcarthur_work, perhaps it was for other things, like Traversible, given Monad etc.
14:20:47 <Phyx-> 1 `mappend` 2
14:20:51 <Phyx-> > 1 `mappend` 2
14:20:52 <lambdabot>   Add a type signature
14:20:56 <Phyx-> > 1 `mappend` 2 :: Int
14:20:57 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:20:57 <lambdabot>    arising from a use of...
14:21:07 <EvilTerran> > Sum 1 `mappend` Sum 2
14:21:09 <lambdabot>   Sum {getSum = 3}
14:21:12 <EvilTerran> ?type Sum
14:21:14 <lambdabot> forall a. a -> Sum a
14:21:19 <Phyx-> ah
14:21:19 <EvilTerran> > 1 :: Sum Int
14:21:21 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
14:21:21 <lambdabot>    arising fr...
14:21:23 <EvilTerran> no?
14:21:27 <roconnor> no
14:21:34 <luite> is there a way to find out if two things have the same value constructor, for something like:  f x y | (x has same constructor as y) = y
14:21:37 <Phyx-> i thought there would be a mappend for Num
14:21:41 * EvilTerran finds that slightly unexpected
14:21:42 <Phyx-> :t mappend
14:21:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:21:49 <Phyx-> with that being +
14:21:50 <jmcarthur_work> a lot of the newtypes don't have Show :(
14:21:56 <jmcarthur_work> it's really dumb
14:22:06 <copumpkin> the most useful one of all doesn't have it
14:22:06 <EvilTerran> jmcarthur_work, i was looking for a Num instance (there isn't one of those either)
14:22:07 <copumpkin> > Identity 5
14:22:09 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity t))
14:22:09 <lambdabot>    aris...
14:22:11 <jmcarthur_work> yeah
14:22:14 <jmcarthur_work> it's sucks
14:22:17 <jmcarthur_work> -'
14:22:21 <copumpkin> > fmap (+1) $ Identity 5
14:22:22 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity a))
14:22:22 <lambdabot>    aris...
14:22:25 <copumpkin> it's not even a friggin functor
14:22:25 <EvilTerran> copumpkin, there's no Show (f (Mu f)) => Show (Mu f), either :(
14:22:30 <copumpkin> oh it is
14:22:33 <copumpkin> but it's still not show
14:23:26 <copumpkin> EvilTerran: lol
14:24:10 <copumpkin> :k Mu
14:24:12 <lambdabot> (* -> *) -> *
14:24:17 <copumpkin> > undefined :: Mu Identity
14:24:19 <lambdabot>   No instance for (GHC.Show.Show
14:24:19 <lambdabot>                     (L.Mu Control.Monad.Iden...
14:24:24 * EvilTerran considers writing up a load of instances for Data.Monoid and sending them in
14:24:26 <copumpkin> > undefined :: Mu Sum
14:24:28 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Monoid.Sum))
14:24:28 <lambdabot>    arising from a us...
14:24:40 <jmcarthur_work> EvilTerran, i, for one, would love that
14:24:44 <copumpkin> > undefined :: Mu Maybe
14:24:45 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
14:24:45 <lambdabot>    arising from a u...
14:24:50 <copumpkin> :P
14:26:15 <EvilTerran> Dual, Sum, and Product could use Num instances
14:26:27 <EvilTerran> and those, First and Last could use Functor instances
14:26:35 <xuei> umm, www.haskell.org seems down right now
14:26:38 <copumpkin> all of them should be Functor
14:26:43 <xuei> :i Mu
14:26:57 <copumpkin> I'd argue any newtype should automatically be a functor :P
14:27:03 <EvilTerran> copumpkin, Endo? All? Any?
14:27:10 <Heffalump> copumpkin: newtype Foo = Foo Int ?
14:27:15 <jmcarthur_work> copumpkin, newtype Foo = Foo () ?
14:27:17 <jmcarthur_work> hey!
14:27:18 <copumpkin> lol
14:27:19 <copumpkin> fine
14:27:25 <Heffalump> Int is better than () !
14:27:28 <copumpkin> parametrized newtypes
14:27:32 <jmcarthur_work> why?
14:27:35 <EvilTerran> identity newtypes?
14:27:45 <jmcarthur_work> Heffalump, why?
14:27:53 <Heffalump> I was joking
14:27:57 <jmcarthur_work> :\
14:28:03 <Heffalump> just trying to claim the superiority of my example
14:28:05 <jmcarthur_work> i was trying to think of snarky comebacks for whatever you said
14:28:16 <Heffalump> copumpkin: newtype Foo a = Foo (a -> a)
14:28:33 * copumpkin restricts his statement further
14:28:44 <Heffalump> all newtypes that are functors should be functors?
14:28:48 * EvilTerran considers that greater code reuse could be achieved by replacing all these identity newtypes with "newtype Tag t a = Tag { unTag :: a } deriving ({- lots -})"
14:28:56 <copumpkin> Heffalump: nope, a lot of ones that should be aren't functors
14:29:16 <Heffalump> all newtypes that can be functors should be functors?
14:29:21 <copumpkin> yeah!
14:29:23 <copumpkin> that's the one
14:29:23 <copumpkin> :P
14:29:39 <Heffalump> what about the ones that are implementing data abstraction?
14:29:48 <EvilTerran> then it'd be "data Sum; ... Tag 1 `mappend` Tag 2 :: Tag Sum Int"
14:30:02 <EvilTerran> or "Tag 1 `mappend` Tag 2 :: Tag Product Int"
14:30:33 <EvilTerran> admittedly, that'd need -XFlexibleInstances/Contexts/whatever to make it useful in general, but i figure those extensions are pretty popular already
14:31:46 <EvilTerran> could be useful as a time-saving measure, at least, when you want the usual Eq, Ord, Read, Show, etc the same, but a different Monoid instance or whatever
14:31:56 * EvilTerran garbles
14:35:11 <copumpkin> I hereby recall my statement about newtype Functors :P
14:35:40 <copumpkin> "all newtypes that make sense as Functors should be automatically Functors"
14:35:46 <copumpkin> there, let's see if anyone can encode that into GHC :P
14:35:53 <EvilTerran> that sounds deliciously undecidable
14:36:04 <EvilTerran> and what happens if you want a different Functor instance for a change?
14:36:11 <EvilTerran> or does parametricity ensure that's impossible?
14:36:24 <Phyx-> oops
14:36:27 <copumpkin> well then GHC should infer that you wanted a different functor instance
14:36:28 <Phyx-> i keep forgetting i'm on irc
14:36:31 <copumpkin> :P
14:36:37 <Phyx-> (Just 1) `mplus` (Just 2)
14:36:42 <Phyx-> > (Just 1) `mplus` (Just 2)
14:36:43 <lambdabot>   Just 1
14:37:00 <Phyx-> why mplus and mappend?
14:37:12 <copumpkin> one is a deeper monoid than the other :P
14:37:20 <ray> i always mix those up
14:37:36 <Phyx-> copumpkin: i think it's just a point of confusion :P both typeclasses do essentially the same
14:37:38 <Deewiant> Anybody have a copy of The Monad Reader #8?
14:37:51 <copumpkin> Phyx-: not really
14:37:55 <ray> DIFFERENT KINDS
14:37:57 <copumpkin> maybe call them Monoid1, Monoid2
14:38:03 <copumpkin> :P
14:38:25 <ray> monadplus has that little monad constraint
14:38:36 <Phyx-> hm
14:38:43 <ray> so it's not just * -> * monoid
14:38:50 <dilinger> Deewiant: http://themonadreader.wordpress.com/previous-issues/ 's not giving it up, eh? :/
14:38:50 <copumpkin> Phyx-: Monoid wants things of kind *, and MonadPlus wants * -> *
14:38:56 <copumpkin> ray: is that fundamental though?
14:38:56 <jmcarthur_work> there are also laws involving Monad
14:39:04 <ray> copumpkin: to monadplus, yes
14:39:07 <Deewiant> dilinger: haskell.org isn't giving anything up at the moment
14:39:15 <ray> i'm open to a Monoid2 or something
14:39:16 <Berengal> not all monadplus instances are monoids
14:39:25 <Phyx-> copumpkin: oh ok, didn't take a look at the kinds
14:39:34 <copumpkin> Monoid_2, agda style
14:39:50 <ray> berengal: that is why MonadOr is proposed
14:40:10 <jmcarthur_work> we need this abstraction down on the Functor level, not just applicative and monad
14:40:21 <jmcarthur_work> and we need two versions for the different sets of laws
14:40:22 <Deewiant> Ah, Google has an HTML cache of it
14:40:34 <jmcarthur_work> and we need to have FunctorZero and FunctorPlus separately
14:40:35 <Berengal> I want a MonadFail first
14:40:45 <jmcarthur_work> MonadFail = FunctorZero ?
14:40:45 <ray> MonadZero is MonadFail
14:40:51 <jmcarthur_work> or does it need to take a string parameter?
14:40:57 <ray> and yeah, Monad is largely too heavy
14:41:03 <Berengal> Okay, I want fail out of Monad...
14:41:08 <jmcarthur_work> agreed
14:41:11 <glasser> I'm trying to build a haskell project (TorDNSEL).  I have GHC 6.8.2 and it calls for 6.6.  It's getting a syntax error on this line at the #.  Am I doing something dumb?
14:41:11 <glasser> import GHC.Prim (Addr#)
14:41:11 <glasser>  
14:41:24 <Berengal> But I still want to pattern match in do expressions
14:41:35 <jfoutz> MonadWhale
14:41:37 <glasser> src/TorDNSEL/Main.hs:81:21: parse error on input `#'
14:41:37 <glasser>  
14:41:38 <ray> berengal: just only allow irrefutable patterns, unless it's a MonadZero
14:41:46 <Berengal> ray, ziggactly
14:41:54 <ray> easy
14:42:02 <Berengal> but it's not done :(
14:42:18 <ray> the code is trivial
14:42:20 <Berengal> I doubt the technical difficulties are the real problem
14:42:26 <dschoepe> I need some help understanding this quote: It basically says that each endofunctor that forms a monoid with some natural transformation η as neutral element and μ as composition, is a monad. Is that correct?
14:42:30 <dschoepe> @quote wadler monad
14:42:31 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
14:44:12 <EvilTerran> Berengal, with -XNoImplicitPrelude, you can do that already.
14:44:42 <Berengal> EvilTerran, you're right, I didn't think of that
14:45:08 <copumpkin> glasser: {-# LANGUAGE MagicHash #-}
14:45:15 <Berengal> But I'd also have to rewrite the entire monad library and every monad instance ever
14:45:52 <ray> that's not hard
14:45:53 <ray> do it
14:45:59 <ray> it gets it out of your system
14:46:01 <copumpkin> it's mechanical rewriting
14:46:07 <copumpkin> no problems to be solved
14:46:08 <ray> it's good clean fun
14:46:33 <ray> do it all in terms of join
14:46:43 <Berengal> Could do it just to get alternative-monad package out on hackage
14:46:54 <copumpkin> dschoepe: how is μ composition?
14:47:10 <Berengal> perhaps with a proper functor->pointed->applicative->monad hierarchy going as well
14:47:13 <ray> if you're willing to polish it enough for hackage, that makes you stronger than me
14:47:20 <ray> i just wrote it for my own mental health
14:47:51 <Berengal> Heh, I don't polish either
14:48:12 <Berengal> But I might still put it up on hackage if I do it
14:49:07 <copumpkin> :t (>=> return)
14:49:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
14:49:17 <dschoepe> copumpkin: err, I meant μ is the associative operation of the monoid
14:49:19 <Phyx-> @google isbn 0071108130
14:49:20 <ray> oh, a monoid *in* the category of endofunctors, not a monoid on it
14:49:21 <ray> now i get it
14:49:22 <lambdabot> http://www.amazon.co.uk/Fundamentals-Corporate-Finance-Standard-Educational/dp/0071108130
14:49:31 <copumpkin> dschoepe: it's a unary function
14:49:33 <Phyx-> thank you lambdabot
14:49:34 <ray> the monoid is the natural transformations
14:50:35 <copumpkin> http://en.wikipedia.org/wiki/Monoidal_category http://en.wikipedia.org/wiki/Monoid_(category_theory)
14:50:56 <dschoepe> copumpkin: Thanks, I'll read those.
14:51:10 <copumpkin> it's related to the algebraic sense of monoid but not quite the same
14:57:43 <Phyx-> @type (>>>)
14:57:45 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:57:59 * Phyx- needs to read up on category theory himself
14:58:05 <Phyx-> @type (>>> id)
14:58:06 <lambdabot> forall a b. (a -> b) -> a -> b
14:58:20 <Phyx-> @type (id >>> id)
14:58:21 <lambdabot> forall a. a -> a
14:58:31 <Phyx-> @type (id >>> flip)
14:58:38 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:58:57 <Phyx-> (id >>> flip) (+) 1 2
14:59:09 <Phyx-> that's a roundabout way of calculating +
14:59:10 <Phyx-> lol
14:59:14 <Phyx-> > (id >>> flip) (+) 1 2
14:59:15 <lambdabot>   3
14:59:22 <Phyx-> @type (id >>> fmap)
14:59:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:59:39 <copumpkin> it's just flip (.) for functions
14:59:40 <Phyx-> right, so (id >>> f) == f
14:59:50 <copumpkin> <<< is (.)
14:59:59 <Phyx-> oh, really
15:00:06 <Phyx-> why the cat class?
15:00:15 <copumpkin> because other things fit into it too
15:00:21 <copumpkin> :k Kleisli
15:00:23 <lambdabot> (* -> *) -> * -> * -> *
15:00:27 <Phyx-> right, can you give me an example?
15:01:13 <copumpkin> @type runKleisli $ Kleisli (+) <<< Kleisli (+)
15:01:14 <lambdabot> forall b. (Num b) => b -> b -> b
15:01:28 <copumpkin> > (runKleisli $ Kleisli (+) <<< Kleisli (+)) 2 3
15:01:29 <lambdabot>   8
15:01:33 <roconnor> @quote haiku
15:01:33 <copumpkin> :)
15:01:34 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
15:01:40 <roconnor> @quote haiku
15:01:40 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
15:01:44 <roconnor> @quote monad haiku
15:01:45 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
15:01:49 <ray> edwardk mentioned writing a book
15:01:54 <ray> just wait for that
15:02:05 <copumpkin> we pressured him at the boston haskell group
15:02:22 <Phyx-> hrm... where'd it get the 8 from?
15:02:26 <Phyx-> 2*3+2 ?
15:02:38 <copumpkin> Phyx-: 3 + (2 + 3)
15:02:55 <Phyx-> right, so i was right, lol
15:02:59 <copumpkin> Kleisli x <<< Kleisli y === x <=< y
15:03:13 <Phyx-> @type (<=<)
15:03:15 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:03:20 <copumpkin> > ((+) <=< (+)) 2 3
15:03:21 <lambdabot>   8
15:03:28 <Phyx-> @type (<=<) return
15:03:30 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> a -> m b
15:03:37 <ray> <=< and >=> is just kleisli arrow composition without the Kleisli wrapper or the Arrow interface
15:03:42 <Phyx-> @type (<=<) return fail
15:03:44 <lambdabot> forall b (m :: * -> *). (Monad m) => String -> m b
15:03:48 <ray> it can be neater sometimes
15:03:49 <roconnor> > ((+) <=< (+)) x  y
15:03:52 <lambdabot>   x + y + y
15:03:52 <Phyx-> @type (<=<) return fail "Epic"
15:03:54 <lambdabot> forall b (m :: * -> *). (Monad m) => m b
15:03:58 <Phyx-> > (<=<) return fail "Epic"
15:04:00 <lambdabot>   No instance for (GHC.Show.Show (m b))
15:04:00 <lambdabot>    arising from a use of `M4670265657...
15:04:04 <copumpkin> lol
15:04:08 <Phyx-> o.O
15:04:14 <copumpkin> you didn't specify your monad
15:04:21 <ray> > (<=<) return fail "Epic" :: [()]
15:04:22 <copumpkin> > (<=<) return fail "Epic" :: Maybe Int
15:04:26 <lambdabot>   []
15:04:26 <lambdabot>   Nothing
15:04:28 <Phyx-> the
15:04:28 <Phyx-> 00:03 < lambdabot>    arising from a use of `M4670265657...
15:04:31 <Phyx-> is the o.O
15:04:33 <Phyx-> lol
15:04:46 <copumpkin> ah, lambdabot's error messages could be improved :P
15:04:47 <Phyx-> > (<=<) return fail "Epic" :: IO a
15:04:49 <lambdabot>   Add a type signature
15:04:52 <Phyx-> > (<=<) return fail "Epic" :: IO Int
15:04:54 <lambdabot>   <IO Int>
15:04:57 <Phyx-> lol
15:05:14 <Phyx-> > (<=<) return fail "Epic" :: [IO Int]
15:05:16 <lambdabot>   []
15:05:26 <copumpkin> I quite enjoy <=<
15:05:48 <Phyx-> copumpkin: i bet
15:05:49 <Phyx-> :P
15:05:54 <copumpkin> :o
15:05:58 <copumpkin> it's a rocket ship!
15:06:02 <Phyx-> @type (<=<) fail return
15:06:05 <lambdabot> forall (m :: * -> *) c. (Monad m) => String -> m c
15:06:11 <Phyx-> the order doesn't matter?
15:06:24 <Phyx-> > (<=<) return fail "Epic" :: Maybe ()
15:06:26 <lambdabot>   Nothing
15:06:32 <Phyx-> > (<=<) return fail "Epic" :: Maybe String
15:06:33 <lambdabot>   Nothing
15:06:38 <Phyx-> > (<=<) return fail "Epic" :: String
15:06:38 <copumpkin> (<=< return) === (return <=<) === id
15:06:40 <lambdabot>   ""
15:06:52 <Phyx-> ah ok
15:07:12 <copumpkin> :t [(<=< return), (return <=<), id]
15:07:13 <lambdabot> forall a b (m :: * -> *). (Monad m) => [(a -> m b) -> a -> m b]
15:07:16 <ray> kleisli's rocket ship
15:07:35 * Phyx- is tired of getting viagra mail spam
15:08:13 <dolio> So just buy some already and they'll get off your back.
15:08:19 <Phyx-> > (<=<) sequence mapM
15:08:21 <lambdabot>   Couldn't match expected type `[a1] -> a'
15:08:26 <Phyx-> @type (<=<) sequence
15:08:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m [m a]) -> a1 -> m [a]
15:08:49 <Phyx-> dolio: then what'll i do with them... they're not like mentos.. I can't pop em in cola to see cool effects
15:09:06 <ray> enlarge your kleisli arrow, please the category ladies
15:09:11 <Phyx-> @hoogle a -> m [m b]
15:09:12 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:09:12 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:09:12 <lambdabot> Data.Tree unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
15:09:19 <copumpkin> @remember ray enlarge your kleisli arrow, please the category ladies
15:09:19 <lambdabot> It is forever etched in my memory.
15:09:35 <monochrom> onoes!
15:09:42 <SamB_XP_> what is the size of an arrow?
15:09:50 <Phyx-> ray: but... what if the arrow is pointing the wrong way?
15:10:02 <SamB_XP_> (or an instance of any other structure, for that matter?)
15:10:08 <copumpkin> its strength!
15:10:19 <copumpkin> still doesn't really make sense
15:10:42 * Phyx- hangs the sign on the door "We're away getting Coffee"
15:12:05 <Phyx-> yay, i solved my gui creation problem
15:12:44 <monochrom> Do not forget the gui destruction problem, lest you would have a gui leak.
15:13:05 <cwraith> does it matter how the arrowhead is shaded?
15:13:31 <monochrom> Phong shading!
15:13:35 <Phyx-> cwraith: oh which arrow?
15:13:41 <Phyx-> monochrom: meh, glossy is overated!
15:13:47 <Phyx-> cartoon shading!
15:13:55 <cwraith> hmm.  who am I today?
15:13:59 <monochrom> ray-trace it. ray. :)
15:14:06 <Phyx-> Elmer Fud
15:14:20 <c_wraith> there's some room to breath, now.
15:14:28 <Phyx-> monochrom: ray tracers are remarkably easy to write, lol
15:14:42 * Phyx- has never tried to make one in haskell though
15:15:02 <ray> if i wanted to write one, i could just search all my irc logs for all the times someone's highlighted me by talking about them
15:15:06 * monochrom traces ray
15:15:15 <monochrom> hehe
15:15:27 * ray casts himself into the scene
15:15:57 * Phyx- absorbes all light
15:16:51 * Phyx- turns the lights back on. I don't trust you guys in the dark
15:20:37 <Phyx-> In brightest Monads, in blackest Categories,
15:20:37 <Phyx-> No evil shall escape my mapM
15:20:37 <Phyx-> Let those who worship for(int x=0; x < n; x++)  might,
15:20:38 <Phyx-> Beware my power... foldl's light!
15:21:05 <monochrom> or foldl''s light
15:21:44 <nvoorhies> good fast raytracers are a devil to write though
15:22:27 <Phyx-> monochrom: i thought people might read over the extra '' :P
15:22:44 <Phyx-> nvoorhies: that's true
15:24:25 <Phyx-> oh, i read crying
15:33:40 <Phyx-> everytime i watch this, i find it cool http://www.vimeo.com/4167288
15:37:20 <smarmy> i think we've finally run out of haskell
15:38:24 <Phyx-> never
15:38:27 <jfoutz> hmm. so agda?
15:38:30 <Phyx-> haskell if infinite
15:38:59 <monochrom> we run out of computable functions
15:39:04 <Phyx-> > let haskell = "Haskell" in cycle haskell
15:39:07 <lambdabot>   "HaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHask...
15:39:19 <copumpkin> why the let?
15:39:25 <copumpkin> > cycle "Haskell"
15:39:27 <lambdabot>   "HaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHask...
15:39:30 <Phyx-> wanted to be fancy
15:39:35 <copumpkin> > let haskell = "Haskell" : haskell
15:39:37 <lambdabot>   not an expression: `let haskell = "Haskell" : haskell'
15:39:39 <copumpkin> > let haskell = "Haskell" : haskell in haskell
15:39:41 <lambdabot>   ["Haskell","Haskell","Haskell","Haskell","Haskell","Haskell","Haskell","Has...
15:39:49 <Phyx-> > toDec 12345425
15:39:52 <lambdabot>   [1,2,3,4,5,4,2,5]
15:39:55 <Phyx-> still there
15:39:56 <Phyx-> heheh
15:40:18 <monochrom> > fix ("haskell" ++)  {- it has the desirable side effect of saying haskell++ :) -}
15:40:20 <lambdabot>   "haskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhask...
15:40:51 <Phyx-> heh
15:41:03 <Phyx-> @type (--)
15:41:05 <lambdabot> parse error (possibly incorrect indentation)
15:41:10 <Phyx-> oops
15:41:12 <Phyx-> that's comment
15:41:12 <Phyx-> heheh
15:41:24 <monochrom> For your eyes only!
15:41:29 <Phyx-> hahaha
15:41:43 <Phyx-> > map ord "Haskell"
15:41:45 <lambdabot>   [72,97,115,107,101,108,108]
15:42:02 <Phyx-> > map toDec $ map ord "Haskell"
15:42:05 <lambdabot>   [[7,2],[9,7],[1,1,5],[1,0,7],[1,0,1],[1,0,8],[1,0,8]]
15:42:23 <Phyx-> > concatMap toDec $ map ord "Haskell"
15:42:24 <lambdabot>   [7,2,9,7,1,1,5,1,0,7,1,0,1,1,0,8,1,0,8]
15:42:33 <Phyx-> lol, no way to reconstruct that one
15:43:09 <copumpkin> you could produce a list of all possible strings that led to that list
15:43:18 <edwardk1> heh, i had the same thought
15:43:23 <Heffalump> <aol>
15:43:24 <edwardk1> plus you could place likelihoods on character choice
15:43:28 <Phyx-> only if you know what the resulting string should be
15:43:36 <edwardk1> most probable parse and all that
15:43:53 <copumpkin> Phyx-: see if you can get it to do that :P
15:43:59 <jaj> you can compare the resulting strings with a dictionary
15:44:04 <Phyx-> you don't even need to do all that, you could prune your search space
15:44:15 <monochrom> Neat project!
15:44:24 <Phyx-> because you know that the alpha characters are within a certain range
15:44:30 * copumpkin gets the feeling takeWhileM would come in handy here
15:44:33 <copumpkin> pity it doesn't exist
15:44:34 <jfoutz> > concat $ unfoldr (\_->Just ("Haskell",0)) 0
15:44:36 <lambdabot>   "HaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHask...
15:44:37 <Phyx-> 7292 would likely not be a letter :P
15:44:44 <hackagebot> monoids 0.2.0.2 - Monoids, specialized containers and a general map/reduce framework (EdwardKmett)
15:44:50 <copumpkin> ooh new monoids
15:44:56 <Phyx-> lol
15:45:11 <edwardk1> copumpkin: heh, actually all i did was version bump the dependency on text at someone's request
15:45:17 <Phyx-> oh got, getting excited over monoids! and i thought i was weird for dreaming about monads...
15:45:20 <copumpkin> ah :)
15:45:35 <edwardk> Phyx-: monoids are better than monads. there are so many more of them ;)
15:45:35 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:45:42 <copumpkin> edwardk: how many more?
15:45:47 <copumpkin> :P
15:45:51 <Twey> > concat $ unfoldr (const $ Just ("Haskell", ())) ()
15:45:53 <lambdabot>   "HaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHask...
15:45:58 <edwardk> @seen tibbe
15:45:59 <lambdabot> I saw tibbe leaving #haskell, #ghc and #haskell-in-depth 8h 3m 11s ago, and .
15:45:59 * copumpkin still wants to count algebraic structures
15:46:03 <jfoutz> :src toDec
15:46:06 <monochrom> Monads are better than monoids, the axioms are so much more powerful!
15:46:12 <jfoutz> @src toDec
15:46:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:46:34 <edwardk> copumpkin: well, each monad wrapped around a monoid gives rise to a monoid, so you have at least as many ;)
15:46:46 <edwardk> monochrom: bah, quantity over quality ;)
15:47:02 <copumpkin> besides, everyone knows monads are hard
15:47:05 <copumpkin> monoids are cute and easy
15:47:19 <edwardk> yeah i can summarize a monoid on a slide without the audience's brain exploding ;)
15:47:20 <monochrom> My monads are hard.  <duck>
15:47:20 <copumpkin> after all, how many monoid tutorials do you see on the web? how many monad tutorials?
15:47:23 <copumpkin> lol
15:47:55 <edwardk> i tried to do that with a comonad once. they were still picking skull fragments out of the carpet when i came back the following month
15:48:04 <monochrom> There are more C tutorials than Haskell tutorials, if you go with that.
15:48:12 <endojelly> what are monoids again? a unit operator and one that adds to a monoid?
15:48:28 <edwardk> endojelly: an associative operator with a unit
15:48:33 <edwardk> endojelly: pretty simple really
15:48:39 <endojelly> thanks
15:48:56 <copumpkin> monochrom: ergo c is better than haskell, clearly!
15:48:57 <monochrom> Like ""++x=x and (x++y)++z = x++(y++z)
15:49:11 <monochrom> Err use [] instead of "" to be general.
15:49:43 <Philonous> copumpkin: Well, aren't monads just monoids after all?
15:49:52 <endojelly> so what do you call something which has a unit and an associative and commutative operator?
15:50:02 <monochrom> commutative monoid
15:50:16 <copumpkin> Philonous: it's a different kind of monoid though
15:50:16 <endojelly> counter would be an instance of that
15:50:23 <endojelly> monochrom, oh, ok 8)
15:50:27 <copumpkin> counter?
15:50:43 <endojelly> a simple counter
15:50:47 <copumpkin> ah
15:50:48 <endojelly> starts at zero and you can add stuff to it
15:50:53 <copumpkin> well if you can decrement it, you get a group!
15:51:01 <Philonous> copumpkin: I mean, the monad laws are really just the monoid laws in disguise.
15:51:10 <monochrom> To see how monads are monoids, you need quite a bit of background, which IMO not worth it for some people.
15:51:34 <ray> well, you just need to look at kleisli arrow composition
15:51:40 <ray> i guess that is a lot of background
15:51:41 <endojelly> oh. then every group is a monoid. cool.
15:51:56 <edwardk> ray: yeah. i gave up trying to pack that into a slide as well ;)
15:51:59 <copumpkin> endojelly: yep :)
15:52:00 <ray> monoids are just associative and  have an identity
15:52:09 <ray> edwardk: 3 slides
15:52:24 <endojelly> copumpkin, thanks!
15:52:47 <edwardk> endojelly: yeah, so is every category that only has one object, or the endomorphisms of an object in any category, orr...
15:52:49 <endojelly> I remember, it took me about 15 seconds to learn what a monoid is
15:52:56 <endojelly> I had to because of the Writer monad
15:53:07 <endojelly> which is parameterized with a Monoid
15:53:10 <endojelly> which makes sense
15:53:12 <copumpkin> monoids are super cute!
15:53:18 <edwardk> endojelly: i have a bunch of slides about monoids and monoidal parsing on comonad.com
15:53:19 <copumpkin> like, totally
15:53:19 <monochrom> the Monoid class was introduced for the Writer class :)
15:53:31 <copumpkin> let's add the Semigroup class
15:53:32 <edwardk> too bad they didn't go the extra distance and make a Semigroup class
15:53:33 <smarmy> i'm going through those slides
15:53:38 <smarmy> iteratee is kicking my arse
15:53:44 <endojelly> edwardk, cool. what is monoidal parsing?
15:53:49 <ray> zomg moe anthropomorphisation of algebra concepts
15:53:54 <edwardk> smarmy: iteratees hurt the brain at first. thats why i started with 'partial'
15:54:04 <copumpkin> ray: like, omg!
15:54:28 <edwardk> endojelly: basically i've been building a bunch of parsers that can run by chunking the  input up, feeding the chunks to a monoid and then combining the partial parses monoidally
15:54:30 <endojelly> if this were japan, monoids would aready have cute faces.
15:54:32 <monochrom> iteratees comforted my brain
15:54:33 <copumpkin> ray: you going to the next bostonhaskell?
15:54:40 <ray> probably
15:54:47 <copumpkin> ray: you gonna bring drong?
15:54:49 <endojelly> edwardk, wow, sounds nice
15:54:51 <ray> lol
15:55:02 <ray> i only travel with CATS
15:55:04 <edwardk> ray: it'd be good to see you there
15:55:06 <copumpkin> endojelly: not only nice, but supercool & cute!
15:55:15 <endojelly> copumpkin, supercool!
15:55:21 <copumpkin> like, totally
15:55:31 <endojelly> like, yeah
15:55:32 <ray> monoid-chan has an associative hair ribbon and carries around an identity element
15:55:37 <copumpkin>  /j #valleyhaskell
15:55:47 <edwardk> endojelly: to be fair you have to give up something to get something, so in my case i need some minor global invariants in my grammar or worsened asymptotics
15:56:04 <edwardk> but most programming language grammars already have the invariants i need
15:56:09 <endojelly> edwardk, what kind of global invariances?
15:56:18 <endojelly> edwardk, do you have any quick examples?
15:56:49 <edwardk> endojelly: well, the second set of slides on comonad reference an iteratee based parsec wrapped in a monoid, which uses the error productions in the grammar to fire off sub-lexers in parallel.
15:56:56 <endojelly> I hope it's not something like "yeah, basically your language has to be a more constrained regular language. like, it can only contain one character."
15:57:22 <endojelly> edwardk, that's... impressive
15:57:39 <ray> your language has to have one character and one production rule
15:57:39 <edwardk> so it needs the invariant that after a non backslashed newline, any lexeme is valid, since in kata the language in question a non-backslashed \ cannot occur in a string and the matching of {- and -} is done later in the parser
15:57:53 <endojelly> edwardk, would you give me a link to those slides?
15:58:07 <edwardk> http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
15:58:30 <copumpkin> endojelly: you in the boston area? :o
15:59:11 <endojelly> copumpkin, not at all, I'm in Europe. why?
15:59:29 <copumpkin> oh, was just going to say you could go to the next boston meetup and catch the presentation :)
15:59:42 <Phyx-> edwardk: more != better :P
15:59:43 <smarmy> when is it?
16:00:01 <endojelly> ah 8)
16:00:27 <Phyx-> jfoutz: lol, it was a let decleration
16:00:41 <copumpkin> smarmy: week of the 14th of september
16:00:51 <Phyx-> jfoutz: defined as toDec = (reverse.unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)))
16:00:53 <endojelly> ray, AND the production rule has to be productive.
16:00:55 <copumpkin> smarmy: you can vote for specific dates that suit you though
16:01:02 <jfoutz> oh, hehe.
16:01:19 <dino-> Does anyone know, with cabal data-files, I'm trying to get an entire directory and all of its contents. But 'data-files: foo' or 'foo/' or 'foo/*' or 'foo/*.*' don't work. There seems to be no way to do it unless they have an extension or you explicitly list each file.
16:01:21 * Phyx- would like to bring up his petition for an unfoldl again
16:01:25 <dino-> Am I missing something?
16:01:32 <copumpkin> Phyx-: what is that?
16:01:37 <copumpkin> oh
16:01:45 <copumpkin> there is an unfoldl somewhere on the intarwebz
16:02:07 <Phyx-> i meant in prelude like unfoldlr
16:02:07 <Phyx-> lol
16:02:16 <copumpkin> it's not particularly efficient
16:02:29 <Phyx-> copumpkin: neither is calling reverse at the end everytime
16:02:59 <copumpkin> @let unfoldl f x = case f x of Nothing     -> []; Just (u, v) -> unfoldl f v ++ [u] -- we miss you wli
16:03:00 <endojelly> hmm. so (.) is an endomorphism?
16:03:02 <lambdabot>  Defined.
16:03:15 <Phyx-> we miss you wli?
16:03:27 <copumpkin> Phyx-: he wrote that and nobody seems to know where he disappeared to
16:03:31 <Phyx-> :|
16:03:37 <Phyx-> why do programmers keep dissappearing...
16:04:18 <Phyx-> @type unfoldl
16:04:20 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
16:04:22 <Phyx-> @type unfoldr
16:04:23 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:04:43 <Phyx-> @let toDec = (unfoldl (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)))
16:04:44 <lambdabot>  <local>:13:0:
16:04:46 <lambdabot>      Multiple declarations of `L.toDec'
16:04:46 <lambdabot>      Declared at: <loc...
16:04:52 <Phyx-> can't you override it?
16:04:58 <copumpkin> not in @let bindings
16:05:03 <Phyx-> blef
16:05:08 <Phyx-> bleh*
16:05:15 <Phyx-> @let toDec' = (unfoldl (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)))
16:05:15 <copumpkin> > let toDec = (unfoldl (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10))) in toDec 1234
16:05:18 <lambdabot>  Defined.
16:05:19 <lambdabot>   [1,2,3,4]
16:05:31 <copumpkin> Phyx-: :t divMod
16:05:35 <Phyx-> @check \x->toDec x == toDec' x
16:05:37 <lambdabot>   Not in scope: `toDec'Not in scope: `toDec''
16:06:05 <Phyx-> copumpkin: ? i need both operations done seperately
16:06:07 <Phyx-> :t divMod
16:06:09 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
16:06:11 <Phyx-> oh
16:06:24 <monochrom> (if a production rule is not productive, is it still a production rule? a non-productive production rule?)
16:08:00 <Phyx-> how do you get a rule that doesn't produce anything? (i'm assuming cfg)
16:08:57 <monochrom> S->S is one. Perhaps there are more subtle ones.
16:09:16 <monochrom> I am not sure if S->AB is one.
16:09:16 <Phyx-> but that does produce something, just not directly
16:09:26 <Phyx-> well
16:09:27 <Phyx-> depends
16:09:38 <Phyx-> if you count the empty language as something that's produced
16:10:10 <monochrom> You win.
16:10:21 <Phyx-> :|
16:10:35 <Phyx-> I'm sorry :(
16:10:47 <monochrom> No it's fine! Be happy! :)
16:10:56 <Phyx-> lol
16:11:13 <copumpkin> ooh, two JaffaCakes
16:11:19 <copumpkin> I guess nobody will notice if I eat one then
16:11:30 <Phyx-> one of them passed their expiration date
16:11:57 <copumpkin> (...and thus ended the great era of GHC, when one of its core developers was accidentally eaten by a hungry pumpkin)
16:11:59 <monochrom> Speaking of eat. I saw a Continental Airline ad: "Eat. There are people who starve on other airlines."
16:12:35 <copumpkin> :o
16:12:59 <monochrom> It is bragging that it is one of the few airlines who offer food with no extra charge.
16:13:34 <Phyx-> lol
16:13:50 <Phyx-> american airlines doesn't even offer paid food on certain flights
16:13:51 <endojelly> edwardk, great slides
16:14:41 <copumpkin> alright, snack time, I'm hungry
16:15:11 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return (10 `divMod` a))
16:15:13 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [t])
16:15:13 <lambdabot>    arising from a use of...
16:15:20 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return (10 `divMod` a)) 123
16:15:22 <lambdabot>   [1,0]
16:15:30 <copumpkin> you have it backwrads
16:15:34 <copumpkin> sort of like my RA
16:15:40 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return (a `divMod` 10)) 123
16:15:44 <copumpkin> additionally, it's doubly backwards
16:15:45 <lambdabot>   * Exception: stack overflow
16:15:49 <Phyx-> lol
16:15:57 <copumpkin> @let swap ~(a, b) = (b, a)
16:15:57 <lambdabot>  <local>:14:0:
16:15:58 <lambdabot>      Multiple declarations of `L.swap'
16:15:58 <lambdabot>      Declared at: <loca...
16:16:00 <copumpkin> bah
16:16:05 <Phyx-> copumpkin: how so?
16:16:08 <copumpkin> @let switcharoo ~(a, b) = (b, a)
16:16:10 <lambdabot>  Defined.
16:16:20 <Phyx-> why do i have it backwards?
16:16:22 <copumpkin> > unfoldl (\a -> guard (a/= 0) >> return (switcharoo (a `divMod` 10))) 123
16:16:24 <lambdabot>   [1,2,3]
16:16:45 <Berengal> @type unfoldl
16:16:46 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
16:16:51 <copumpkin> @let switcharoo' = (snd &&& fst)
16:16:51 <Berengal> > divMod 15 10
16:16:54 <lambdabot>  Defined.
16:16:55 <lambdabot>   (1,5)
16:17:03 <Phyx-> copumpkin: why do i have to do a switcharoo
16:17:11 <copumpkin> Phyx-: it's divMod, not modDiv :P
16:17:35 <medfly> airlines normally offer food for extra charge? strange.
16:17:35 <medfly> I must be living in a place where few companies hold a monopoly on flying... oh, wait.
16:17:43 <Phyx-> copumpkin: ah
16:17:46 <Berengal> @type curry. flip . uncurry
16:17:47 <Phyx-> :t swap
16:17:47 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> (a, b) -> c) -> a -> b -> (a1, b1) -> c
16:17:49 <lambdabot> forall t t1. (t, t1) -> (t1, t)
16:17:50 <Phyx-> ehh
16:18:02 <copumpkin> @type uncurry (flip (,))
16:18:03 <lambdabot> forall b a. (a, b) -> (b, a)
16:18:11 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return $ (snd *** fst) (a `divMod` 10)) 123
16:18:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
16:18:16 <Phyx-> eek
16:18:27 <Phyx-> @type (snd *** fst)
16:18:29 <lambdabot> forall a c a1 b. ((a, c), (a1, b)) -> (c, a1)
16:18:32 <Phyx-> ah
16:18:36 <copumpkin> &&& :P
16:18:38 <Phyx-> @type (snd &&& fst)
16:18:40 <lambdabot> forall a c. (a, c) -> (c, a)
16:18:41 <Phyx-> heheh
16:18:42 <Phyx-> yeah
16:18:50 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return $ (snd &&& fst) (a `divMod` 10)) 123
16:18:52 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) (t, t)))
16:18:52 <lambdabot>    arising from a u...
16:18:57 <copumpkin> aw
16:19:25 <Phyx-> why did that fail....
16:19:37 <Phyx-> arising from a u... ?
16:19:57 <mle> truncated error
16:20:02 <Phyx-> > (snd &&& fst) (123 `divMod` 10)
16:20:03 <lambdabot>   (3,12)
16:20:08 <Phyx-> > return (snd &&& fst) (123 `divMod` 10)
16:20:10 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, c) -> (c, a))
16:20:10 <lambdabot>    arising from ...
16:20:15 <Phyx-> > return $ (snd &&& fst) (123 `divMod` 10)
16:20:16 <lambdabot>   No instance for (GHC.Show.Show (m (c, c)))
16:20:16 <lambdabot>    arising from a use of `M32748...
16:20:33 <Phyx-> > return ((snd &&& fst) (123 `divMod` 10)) :: Maybe (Int,Int)
16:20:35 <lambdabot>   Just (3,12)
16:20:47 <Phyx-> > unfoldl (\a -> guard (a/= 0) >> return ((snd &&& fst) (a `divMod` 10))) 123
16:20:48 <copumpkin> it's a precedence error with $ I think
16:20:48 <lambdabot>   [1,2,3]
16:20:59 <Phyx-> i should be able to use fmap no?
16:21:16 <Phyx-> ah no, that'w >>= return
16:22:23 <Phyx-> @type modDiv
16:22:25 <lambdabot> Not in scope: `modDiv'
16:22:49 * Phyx- cleans up his code
16:23:00 <Phyx-> uhm.. what's that unfoldl definition aagin
16:23:27 <nomeata> endojelly: yes, I was asked to follow the proper procedure at http://www.haskell.org/haskellwiki/Library_submissions
16:23:39 <nomeata> endojelly: I prepared and sent a patch
16:24:22 <endojelly> nomeata, cool. did you include documentation and everything?
16:25:36 <veinor> Can someone please explain to me why foldl (+) foo is so much worse than foldr (+) foo?
16:25:37 <Phyx-> @index (&&&)
16:25:37 <lambdabot> Control.Arrow
16:25:48 <Berengal> veinor, it isn't
16:25:53 <veinor> Hm
16:25:59 <Berengal> Not for (+) anyway
16:26:11 <veinor> Well you get my point.
16:26:15 <Phyx-> but it is much worse for foldl' (+) foo
16:26:31 <Phyx-> errr
16:26:36 <veinor> I know why foldl' is better than foldl
16:26:52 <veinor> but what I don't know is why for some f foldl f 0 foo is worse than foldr f 0 foo
16:26:56 <Berengal> In general, however, foldl is worse than foldr, because it always builds up a huge thunk and has to traverse the whole list, but foldr can stop early
16:26:56 <Phyx-> well, then i'll go with what Berengal mentioned
16:27:15 <veinor> Berengal: stop early?
16:27:47 <Berengal> > foldr (\n acc -> if n = 10 then n else n + acc) 0 [1..]
16:27:50 <lambdabot>   <no location info>: parse error on input `='
16:28:00 <Berengal> > foldr (\n acc -> if n == 10 then n else n + acc) 0 [1..]
16:28:02 <lambdabot>   55
16:28:04 <jfoutz> ugh
16:28:08 <jfoutz> > cycle . reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10 + b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then (0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) [7,2,9,7,1,1,5,1,0,7,1,0,1,1,0,8,1,0,8]
16:28:09 <lambdabot>   "HaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHaskellHask...
16:28:20 <jfoutz> that took forever.
16:28:37 <veinor> iohcc?
16:28:58 <nomeata> endojelly: a bit, yes
16:29:14 <veinor> > foldr (\n acc -> if n == 3 then n else n + acc) 0 [1..]
16:29:15 <lambdabot>   6
16:29:18 <veinor> cool
16:29:30 <Phyx-> copumpkin: made it "toDec x = unfoldl (\x -> guard (x /= 0) >> return (modDiv 10)) x"
16:29:33 <Phyx-> much cleaner
16:29:36 <Phyx-> yaay
16:29:38 <Phyx-> made modDiv = \a -> (snd &&& fst).(divMod a)
16:29:54 <Phyx-> these things should be in prelude!
16:29:55 <Phyx-> lol
16:29:56 <endojelly> nomeata, cool! I hope it gets included
16:30:08 <veinor> Berengal: so haskell 'knows' that it can stop traversing [1..]?
16:30:28 <endojelly> I was also very, very glad that intercalate got included into the standard library
16:30:31 <endojelly> :t intercalate
16:30:34 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:30:43 <Berengal> veinor, yup. foldr gives the f function access to the result of the rest of the traversal. Of course, it won't be computed yet, but that doesn't matter since haskell is lazy
16:30:47 <veinor> intercalate reminds me of intercal
16:31:00 <endojelly> whoever spent some time writing a lot of Show instances knows what I mean 8)
16:31:07 <Berengal> If f decides that the rest of the computation is irrelevant, it can discard it, and it won't be computed
16:31:27 <endojelly> veinor, maybe there should be an Intercal monad. with comeFrom.
16:31:32 <veinor> Berengal: but in cases where foldr will traverse the whole list it's just as inefficient as foldl?
16:31:46 <nomeata> endojelly: I guess you could help by observing any discussions on library@ (not there yet, but my mail should appear on http://www.haskell.org/pipermail/libraries/2009-August/thread.html eventually)
16:31:51 <jfoutz> comefrom! best control flow operator ever.
16:31:55 <Phyx-> jfoutz: :O you found it!
16:32:02 <jfoutz> :)
16:32:04 <Berengal> veinor, it can be. (+) is, (&&) and (||) isn't
16:32:04 <smarmy> veinor:  imagine left associativity in a fold.  for a small computation, it looks like ((((f ...) ...) ...) ...) ...).  but in the infinite case, it's just (((((((((((((((... and so on
16:32:07 <endojelly> nomeata, okay!
16:32:52 <veinor> yeah, that's what I was thinking
16:32:56 <veinor> Berengal: right because of short-circuiting
16:32:58 <Phyx-> jfoutz: that's... one hell of a line
16:33:02 <Berengal> veinor, you know how a list can be written a:(b:(c:(...(:([]))))))?
16:33:09 <veinor> yep
16:33:20 <Berengal> foldr simply replaces all : with f, and the last [] with the initial seed
16:33:25 <veinor> ah, cool
16:33:53 <Berengal> so it turns into a `f`(b `f`(c `f`(...`f`(seed)))))
16:34:12 <jfoutz> Phyx-: yeah, i'm sure there's a better way to do it. fold was the only thing i could really put togheter though. couple of false starts with groupby and takewhile.
16:34:18 <Berengal> foldl does the same, but it reverses the list as well, in a way
16:34:20 <Phyx-> toDec 0
16:34:23 <Phyx-> > toDec 0
16:34:25 <lambdabot>   []
16:34:34 <Phyx-> fail
16:35:02 <Phyx-> > toDec (-123)
16:35:02 <Berengal> so you get (((((((a)`f`b)`f`c)`f`...)`f`seed
16:35:07 <lambdabot>   mueval-core: Prelude.read: no parse
16:35:07 <lambdabot>  mueval: ExitFailure 1
16:35:16 <Phyx-> jfoutz: still cool though
16:35:17 <Phyx-> lol
16:35:49 <veinor> > toDec -123
16:35:49 <Berengal> (or seed `(flip f)` (z `(flip f)` (y `(flip f)` (.....))))
16:35:51 <lambdabot>   No instance for (GHC.Num.Num (a -> [a]))
16:35:51 <lambdabot>    arising from the literal `123' ...
16:35:58 <veinor> >:|
16:36:04 <jfoutz> > reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10 + b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then (0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord "mustBeLetters"
16:36:07 <lambdabot>   "mustBeLetters"
16:36:10 <edwardk> endojelly: thanks =)
16:36:26 <veinor> jfoutz: what the hell does that do?
16:36:40 <jfoutz> oh, sorry
16:36:47 <c_wraith> it appears to be "id" for letters. :)
16:36:55 <jfoutz> > concatMap toDec $ map  ord "mustBeLetters"
16:36:57 <lambdabot>   [1,0,9,1,1,7,1,1,5,1,1,6,6,6,1,0,1,7,6,1,0,1,1,1,6,1,1,6,1,0,1,1,1,4,1,1,5]
16:37:01 <jfoutz> reconstructs that.
16:37:14 <edwardk> jfoutz: nice job
16:37:29 * jfoutz giggles
16:37:30 <Phyx-> hrm.. Integral is not a subclass of Num?
16:37:51 <veinor> @pl reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10 + b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then (0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord
16:37:55 <lambdabot> reverse (snd (foldl (uncurry (ap (ap . (ap .) . ap ((.) . ap . (if' .) . flip flip (map ((==) . ord) (['a'..'z'] ++ ['A'..'Z'])) . ((any . flip id) .) . (+) . (10 *)) ((((,) 0 .) .) . flip . (((:) .
16:37:55 <lambdabot> chr) .) . (+) . (10 *))) (flip . ((,) .) . (+) . (10 *)))) (0, []) (toDec =<< map ord)))
16:37:55 <lambdabot> optimization suspended, use @pl-resume to continue.
16:38:00 <veinor> haha
16:38:05 <veinor> @pl-resume
16:38:07 <lambdabot> reverse (snd (foldl (uncurry (ap (ap . (ap .) . ap ((.) . ap . (if' .) . flip flip (map ((==) . ord) (['a'..'z'] ++ ['A'..'Z'])) . ((any . flip id) .) . (+) . (10 *)) ((((,) 0 .) .) . flip . (((:) .
16:38:07 <lambdabot> chr) .) . (+) . (10 *))) (flip . ((,) .) . (+) . (10 *)))) (0, []) (toDec =<< map ord)))
16:38:14 <jfoutz> great way to spend a friday afternoon.
16:38:18 <Berengal> Why does lambdabot call @pl optimizing?
16:38:27 <veinor> Berengal: That sure as hell looks optimized to me!
16:38:31 <Phyx-> veinor: you meant (-123) not -123 which is a function
16:38:35 <veinor> @upl reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10 + b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then (0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord
16:38:36 <lambdabot> Maybe you meant: pl unpl url
16:38:41 <veinor> @unpl reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10 + b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then (0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord
16:38:42 <lambdabot> (reverse (snd (foldl (\ (a, r) b -> if any (\ f -> f ((a * 10) + b)) (map (\ x c -> c == (ord x)) ((['a' .. 'z']) ++ (['A' .. 'Z']))) then (0, (chr ((a * 10) + b)) : r) else (((a * 10) + b), r)) (0,
16:38:42 <lambdabot> []) (concatMap toDec (map ord)))))
16:38:56 <Berengal> veinor, pesimized, more like
16:38:57 <Phyx-> jfoutz: that's not exatly more readable :P
16:39:41 <Phyx-> @pl reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10+ b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then(0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord
16:39:45 <lambdabot> reverse (snd (foldl (uncurry (ap (ap . (ap .) . ap ((.) . ap . (if' .) . flip flip (map ((==) . ord) (['a'..'z'] ++ ['A'..'Z'])) . ((any . flip id) .) . (+) . (10 *)) ((((,) 0 .) .) . flip . (((:) .
16:39:45 <lambdabot> chr) .) . (+) . (10 *))) (flip . ((,) .) . (+) . (10 *)))) (0, []) (toDec =<< map ord)))
16:39:45 <lambdabot> optimization suspended, use @pl-resume to continue.
16:40:02 <Phyx-> @pointless reverse . snd $ foldl (\(a,r) b -> if any (\f-> f $ a*10+ b) (map (\x -> (==ord x)) $ ['a'..'z'] ++ ['A'..'Z']) then(0,(chr (a*10+b)):r) else (a*10+b,r)) (0,[]) $ concatMap toDec $ map ord
16:40:05 <lambdabot> reverse (snd (foldl (uncurry (ap (ap . (ap .) . ap ((.) . ap . (if' .) . flip flip (map ((==) . ord) (['a'..'z'] ++ ['A'..'Z'])) . ((any . flip id) .) . (+) . (10 *)) ((((,) 0 .) .) . flip . (((:) .
16:40:05 <lambdabot> chr) .) . (+) . (10 *))) (flip . ((,) .) . (+) . (10 *)))) (0, []) (toDec =<< map ord)))
16:40:05 <lambdabot> optimization suspended, use @pl-resume to continue.
16:40:10 <Berengal> rpn calculator time! calculate "2 3 + 3 14 * +", type String -> Integer
16:40:54 <jfoutz> it can't make it id, because there are very few sequences that actually mean anything.
16:41:11 <Phyx-> jfoutz: ?
16:41:54 <jfoutz> er... lambabot can't optimize much.
16:42:11 <Phyx-> pl never could
16:42:18 <Phyx-> it already has problems with most things monads
16:42:55 <jfoutz> it's a list of digits as arguments for one thing, not Integers. only defined for a pretty narrow set of 2 and 3 digit sequences.
16:43:45 <jfoutz> Berengal: hehehe.
16:43:56 <Phyx-> I wish lambda bot's modules shared state...
16:45:48 <Phyx-> > toDec' 123456789123456789
16:45:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9]
16:45:55 <Phyx-> :t toDec
16:45:57 <lambdabot> forall a. (Integral a) => a -> [a]
16:46:30 <endojelly> :t toDec'
16:46:32 <lambdabot> forall t. (Integral t) => t -> [t]
16:46:50 <endojelly> @src toDec
16:46:50 <lambdabot> Source not found.
16:46:54 <endojelly> @src toDec'
16:46:54 <lambdabot> Source not found. I feel much better now.
16:47:19 <Phyx-> lol
16:47:34 <Phyx-> endojelly: toDec x = unfoldl (\x -> guard (x /= 0) >> return (x `modDiv` 10)) x
16:47:48 <endojelly> nice
16:48:02 <Phyx-> @pl unfoldl (\x -> guard (x /= 0) >> return (x `modDiv` 10))
16:48:03 <lambdabot> unfoldl (ap ((>>) . guard . (0 /=)) (return . (`modDiv` 10)))
16:48:09 <Phyx-> hmm no thanks
16:48:17 <veinor> has @pl ever produced something better than its input?
16:48:30 <Phyx-> on occasions
16:48:39 <Phyx-> for instance
16:48:43 <jfoutz> @pl id. id . id
16:48:43 <lambdabot> id
16:48:48 <monochrom> haha
16:48:55 <veinor> @unpl id
16:48:56 <lambdabot> (\ a -> a)
16:49:02 <veinor> @pl (\ a -> a)
16:49:02 <monochrom> Yes @pl can produce good stuff.
16:49:03 <lambdabot> id
16:49:13 <veinor> Has it ever done something good that was non-trivial? :P
16:49:18 <mle> yes.
16:49:20 <mreh> I'm so sad and lonely
16:49:21 <Phyx-> @pl (\(Just y) (Just x)->(Just y))
16:49:21 <lambdabot> (line 1, column 9):
16:49:21 <lambdabot> unexpected "y"
16:49:21 <lambdabot> expecting operator or ")"
16:49:28 <Raevel> mreh: :-(
16:49:57 <veinor> @pl (\y x -> y)
16:49:57 <lambdabot> const
16:50:07 <veinor> mle: such as?
16:50:21 <opqdonut> @pl (\a b c x y z -> a x z)
16:50:21 <Phyx-> veinor: i remember feeding it a line once
16:50:21 <lambdabot> const . const . (const .)
16:50:23 <Phyx-> and got
16:50:24 <Phyx-> liftM2 (+) (fmap (*b^i) val)
16:50:26 <Phyx-> back for instance
16:50:38 <endojelly> @unpl ap
16:50:39 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
16:50:52 <Phyx-> @unpl liftM2 (+) (fmap (*b^i) val)
16:50:52 <lambdabot> (\ f -> (fmap (\ g -> g * (b ^ i)) val) >>= \ c -> f >>= \ a -> return (c + a))
16:51:01 <opqdonut> unpl is very eager
16:51:06 <Phyx-> lol, i did have something like that
16:51:07 <veinor> @pl  (\ f -> (fmap (\ g -> g * (b ^ i)) val) >>= \ c -> f >>= \ a -> return (c + a))
16:51:08 <lambdabot> liftM2 (+) (fmap (b ^ i *) val)
16:51:11 <veinor> :o
16:51:34 <endojelly> would be nice if @unpl could sugar monads
16:52:06 <Berengal> do we have a @do?
16:52:08 <Berengal> @do
16:52:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:52:10 <Phyx-> @let modDiv = \a -> (snd &&& fst).(divMod a)
16:52:13 <lambdabot>  Defined.
16:52:14 <Berengal> huh...
16:52:22 <Lemmih> Berengal: redo.
16:52:24 <Phyx-> @do liftM2
16:52:24 <lambdabot> liftM2 not available
16:52:36 <Berengal> @redo (\ f -> (fmap (\ g -> g * (b ^ i)) val) >>= \ c -> f >>= \ a -> return (c + a))
16:52:39 <Phyx-> :t modDiv
16:52:46 <lambdabot> (\ f -> do { c <- (fmap (\ g -> g * (b ^ i)) val); a <- f; return (c + a)})
16:52:46 <lambdabot> forall b. (Integral b) => b -> b -> (b, b)
16:52:48 <Smokey`> are there any good resources I can look at on parallel programming in Haskell?
16:52:52 <Phyx-> lambdabot: is awefully slow today
16:52:56 <opqdonut> Smokey`: rwh is pretty good
16:53:10 <endojelly> Berengal, I guess it's just @doc
16:53:20 <endojelly> @do Data.Data
16:53:21 <lambdabot> Data.Data not available
16:53:27 <EvilTerran> ?vixen are you feeling okay?
16:53:27 <endojelly> @doc Data.Data
16:53:27 <lambdabot> Data.Data not available
16:53:30 <lambdabot> yeah, i'm ok
16:53:33 <Phyx-> anyway to view the definitions of @let back?
16:53:40 <endojelly> @unlet
16:53:41 <endojelly> ;)
16:53:42 <EvilTerran> Phyx-, er, scrollback?
16:53:43 <lambdabot>  Defined.
16:53:51 <Phyx-> endojelly: thanks for clearing everything
16:53:52 <Phyx-> lol
16:53:53 <mreh> is anyone here an MBTI INTP?
16:53:58 <Phyx-> EvilTerran: lol
16:54:01 <veinor> lol MBTI
16:54:03 <endojelly> Phyx-, ... sorry, didn't know it would to that!
16:54:05 <veinor> @pl (\x y -> y)
16:54:06 <lambdabot> const id
16:54:09 <Phyx-> > toDec 123
16:54:10 <Berengal> @. pl . undo . redo unpl liftM2 (+) (fmap (b ^ i *) val)
16:54:11 <lambdabot> liftM2 (+) (fmap (b ^ i *) val)
16:54:12 <lambdabot>   [1,2,3]
16:54:17 <Phyx-> oh, they're still around
16:54:18 <Berengal> Go \b!
16:54:18 <Phyx-> yay
16:54:19 <Phyx-> lol
16:54:27 <endojelly> @help unlet
16:54:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:54:28 <Phyx-> :t undo
16:54:29 <lambdabot> Not in scope: `undo'
16:54:33 <blackdog_> mreh: only INTPs believe in MBTI.
16:54:52 <Berengal> blackdog, INTJs too
16:54:53 <Berengal> some of them
16:54:55 <Phyx-> @index undo
16:54:55 <lambdabot> bzzt
16:54:56 <mle> ...how did mbti come up in here?
16:54:58 <Phyx-> wtf
16:55:01 <mreh> blackdog_: circular logic
16:55:08 <Phyx-> Berengal: where'd your undo come from
16:55:09 <Phyx-> :P
16:55:13 <EvilTerran> i have a friend who claims to be ESTJ
16:55:25 <Berengal> @undo do {x <- foo; x}
16:55:25 <lambdabot> foo >>= \ x -> x
16:55:37 <mreh> where's off topic here?
16:55:41 <Berengal> Phyx-, ↑
16:55:41 <EvilTerran> #haskell-blah
16:56:02 <mle> I didn't condemn it for being off, just curious.  But yeah, I guess it is.
16:56:12 <veinor> ok why the heck does const id 3 return its first value?
16:56:15 <veinor> er, const id
16:56:17 <monochrom> do {x <- foo; x} is join foo
16:56:20 <blackdog_> mreh: no, it just implies that i must be INTP. who's that coercive logic dude? raymond someone?
16:56:30 <veinor> er, second
16:56:30 <monochrom> join foo is not john woo
16:56:32 <Berengal> veinor, const is the function taking an argument and returning the constant function to that argument
16:56:42 <opqdonut> :t const
16:56:42 <lambdabot> forall a b. a -> b -> a
16:56:44 <opqdonut> :t const id
16:56:46 <lambdabot> forall a b. b -> a -> a
16:56:54 <Phyx-> 01:53 < Berengal> @. pl . undo . redo unpl liftM2 (+) (fmap (b ^ i *) val) <-- that undo
16:56:56 <Berengal> 'const id' logically returns its second argument...
16:57:01 <opqdonut> takes the first arg, throws it away
16:57:07 <EvilTerran> const id x y = (const id x) y = id y = y
16:57:08 <Berengal> Phyx-, that's just \b command composition
16:57:09 <mreh> blackdog_ : haskell-blah?
16:57:14 <opqdonut> takes second, applies id
16:57:19 <Phyx-> EvilTerran: i'm INTJ :P
16:57:22 <veinor> Berengal: no, const takes two arguments and applies id to the second :/
16:57:29 <veinor> or returns the second, whatever
16:57:34 <Phyx-> Berengal: ok
16:57:48 <monochrom> > const id 3 4
16:57:49 <lambdabot>   4
16:57:51 <Berengal> veinor, no, const takes two arguments and returns the first. 'const id' takes two arguments and applied id to the second
16:57:57 <monochrom> I can't reproduce what you claim.
16:58:06 <veinor> Ibleeeh.
16:58:11 <veinor> I am getting this mixed up.
16:58:15 <veinor> const x y = x
16:58:24 <veinor> ... oh. Dur. Now I get it.
16:58:34 <Berengal> const' x y z = x z
16:58:53 <EvilTerran> INTP is meant to be uncommon, but most of the people who seem to be the sort to do the MBPT of their own volition seem to be INT*...
16:59:13 <monochrom> The scientific method works.
16:59:28 <veinor> const id x = id, durp.
16:59:40 <mreh> monochrom: there is no scientific method
16:59:53 <mreh> INTP discussion in haskell-blah!
16:59:57 <veinor> Now I'm trying to think about why you would need const. I'm sure there's a reason I just can't think of it.
17:00:15 <opqdonut> well constant functions are handy
17:00:22 <Berengal> > foldr const 0 [1..]
17:00:24 <lambdabot>   1
17:00:31 <EvilTerran> quicksilver, surely "the scientific method appears to fit the available data"? :P
17:00:32 <opqdonut> and SK(I) needs it ;)
17:00:34 <jfoutz> everybody's favorite
17:00:45 <Berengal> I use const all the time
17:00:49 <monochrom> Nice thing to plug intoo some very general higher-order functions to get them to do simple things.
17:00:50 <jfoutz> > filterM (const [True,False]) [1..3]
17:00:52 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:01:03 <jfoutz> which is awesome.
17:01:09 <opqdonut> indeed
17:01:09 <Berengal> power set ftw
17:01:11 <veinor> does that generate the power set?
17:01:13 <veinor> awesome :D
17:01:14 <opqdonut> yes
17:01:24 <opqdonut> nondeterministic choice
17:01:28 <opqdonut> whether to include each element
17:01:31 <veinor> @doc filterm
17:01:32 <lambdabot> filterm not available
17:01:39 <Phyx-> jfoutz: oh that's a nice definition
17:01:47 <veinor> I just don't know what filterM does :<
17:01:50 <jfoutz> i read about it. not mine :)
17:02:08 <Phyx-> veinor: it's monadic filter
17:02:12 <EvilTerran> veinor, it's like filter, except the predicate deciding whether to include an element or not in the result list is monadic
17:02:12 <jfoutz> @src filterM
17:02:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:02:16 <jfoutz> @src filter
17:02:16 <lambdabot> filter _ []     = []
17:02:16 <lambdabot> filter p (x:xs)
17:02:16 <lambdabot>     | p x       = x : filter p xs
17:02:16 <lambdabot>     | otherwise = filter p xs
17:02:30 <EvilTerran> in the case of filterM (const [True,False]), it's using the non-determinism monad
17:02:38 <veinor> I should probably read up on how the list moand works then
17:02:39 <Berengal> I've found filterM to be mostly useless, except in a few nondeterministic cases
17:02:46 <Berengal> such as the power set
17:03:03 <EvilTerran> read that as "filter the list, and regardless of each element, include it in one reality but exclude it in another"
17:03:26 <Phyx-> bbl
17:03:27 <EvilTerran> Berengal, i've found it useful for such things as seeing which files in a list exist
17:03:28 <Phyx-> time to go home
17:03:58 <Berengal> EvilTerran, I guess that could be useful too. I tend not to do too much IO though...
17:06:13 <Berengal> The list monad is great fun though
17:06:16 <EvilTerran> ...
17:06:24 <Berengal> Almost as fun as the function applicative
17:06:29 <EvilTerran> .oO( heretical thought for the day: Mu IO )
17:06:55 <opqdonut> Berengal: function as in reader?
17:07:06 <EvilTerran> Mu IO Cthulhon Fthaghu?
17:07:07 <Berengal> opqdonut, function as in a -> b
17:07:17 <Berengal> which is reader, yes
17:07:21 <opqdonut> ok
17:07:43 <opqdonut> EvilTerran: Mu IO sounds fun, certainly. probably pathologically non-halting though
17:07:54 <Berengal> EvilTerran, fix (forever . join . Mu)
17:08:07 <Berengal> or something...
17:08:14 <wolverian> hrm, I was using fundeps to encode a Mapping type class. I have an instance of a Mapping that has another Mapping in its context. with fundeps it's fine. can I do the same with associated types? I can't figure out how to specify the associated types for the context's instance
17:09:19 <Saizan> wolverian: use ~ ?
17:09:33 <Berengal> wolverian, in general, 'class Foo a b | a -> b' turns into 'class Foo a where t type B a :: *'
17:09:58 <Berengal> -t
17:10:02 <wolverian> Berengal: right. I'm having trouble with this one instance.
17:10:12 <sshc> Hi, can anybody recommend a good reference for learning monads?
17:10:20 <wolverian> Saizan: oh, didn't see that on the wiki. let me see.
17:10:21 <monochrom> Haha Mu IO.
17:10:40 <c_wraith> sshc, my recommendation would be "you don't need to learn about monads just yet."
17:10:44 <Berengal> sshc, typeclassopedia
17:11:04 <Berengal> learn functors first, then pointed and applicatives
17:11:22 <Berengal> But basically, all you need to know about monads is in the types...
17:11:29 <wolverian> Saizan: which part of the user guide would that be in?
17:12:04 <wolverian> found it.
17:12:06 <Saizan> wolverian: not sure, however "a ~ b" is a contraint that says that a is the same type as b
17:12:37 <ycombination> how do I evaluate expressions within a string? In Ruby, I would do mystring = "I saw #{a} and #{b}, and #{c}". How do I do that in Haskell?
17:12:54 <mauke> printf :-)
17:13:01 <Berengal> ycombination, you can't. You need to write your own eval
17:13:02 <wolverian> thanks, got it.
17:13:20 <wolverian> type families are *much* nicer to read than fundeps, IMHO
17:13:22 <Berengal> for simply printing values, printf, or show
17:13:35 <Berengal> wolverian, yes! I've been saying that since I first saw them
17:13:36 <Lemmih> > printf "I saw %s and %s." "the moon" "the sun" :: String
17:13:38 <lambdabot>   "I saw the moon and the sun."
17:13:47 <ycombination> ok, thanks
17:14:00 <mauke> this should be possible with TH
17:14:15 <Berengal> I think TH has a $(printf) already
17:14:19 <Lemmih> And overkill.
17:14:27 <mauke> you can't have too much overkill
17:14:36 <Berengal> , $(printf "I saw %s and %s) "the moon" "the sun"
17:14:38 <lunabot>  luna: lexical error in string/character literal at end of input
17:14:42 <Berengal> :/
17:14:50 <Berengal> , $(printf "I saw %s and %s") "the moon" "the sun"
17:14:50 <mauke> Berengal: not printf, the #{ } stuff
17:14:53 <lunabot>  "I saw the moon and the sun"
17:14:58 <Berengal> , $(printf "I saw %s and %s") "the moon" 5
17:15:00 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Base.String)
17:15:15 <mle> show 5
17:15:16 <Berengal> mauke, isn't that just quotation?
17:15:33 <mauke> hmm?
17:15:36 <Berengal> pluss a bit of plumbing I guess...
17:15:45 <Berengal> Seems similar to what hsp does
17:17:55 <jfoutz> Berengal: nowhere *near* as bad as i thought it would be.
17:17:58 <jfoutz> fst . fromJust $ foldM (\(t,s) o -> lookup o ((map (\(c,f) -> (c,(f t (head s), tail s))) [('+',(+)),('-',(-)),('*',(*))]) ++ [(' ',(0,t:s))] ++ (map (\x -> (chr (x+48),(t*10+x,s))) [0..9]))) (0,[]) "12 12*"
17:18:08 <jfoutz> > fst . fromJust $ foldM (\(t,s) o -> lookup o ((map (\(c,f) -> (c,(f t (head s), tail s))) [('+',(+)),('-',(-)),('*',(*))]) ++ [(' ',(0,t:s))] ++ (map (\x -> (chr (x+48),(t*10+x,s))) [0..9]))) (0,[]) "12 12*"
17:18:10 <lambdabot>   144
17:18:22 <Berengal> jfoutz, not bad
17:18:23 <jfoutz> i'm a little loosy goosey with the spaces though.
17:19:13 <jfoutz> like, i use them as a number completion operator.
17:19:40 <dcoutts_> dino-: about the file globbing in .cabal files, yes, that's correct
17:21:42 <veinor> jfoutz: D:
17:22:30 <jfoutz> awww. it's not *that* bad.
17:23:04 <jfoutz> > fst . fromJust $ foldM (\(t,s) o -> lookup o ((map (\(c,f) -> (c,(f t (head s), tail s))) [('+',(+)),('-',(-)),('*',(*))]) ++ [(' ',(0,t:s))] ++ (map (\x -> (chr (x+48),(t*10+x,s))) [0..9]))) (0,[]) "7 12*6+"
17:23:06 <lambdabot>   * Exception: Prelude.head: empty list
17:23:15 <jfoutz> hmm. maybe it is :)
17:23:27 <EvilTerran> jfoutz, maybe lex would be useful?
17:23:31 <EvilTerran> ?hoogle lex
17:23:31 <lambdabot> Prelude lex :: ReadS String
17:23:32 <lambdabot> Text.Read lex :: ReadS String
17:23:32 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
17:23:37 <jfoutz> > fst . fromJust $ foldM (\(t,s) o -> lookup o ((map (\(c,f) -> (c,(f t (head s), tail s))) [('+',(+)),('-',(-)),('*',(*))]) ++ [(' ',(0,t:s))] ++ (map (\x -> (chr (x+48),(t*10+x,s))) [0..9]))) (0,[]) "7 12* 6+"
17:23:39 <lambdabot>   90
17:23:41 <EvilTerran> > lex "7 12*6+"
17:23:43 <lambdabot>   [("7"," 12*6+")]
17:23:56 <EvilTerran> > unfoldr (Just.lex) "7 12*6+"
17:23:57 <lambdabot>   Not in scope: `Just.lex'
17:24:00 <EvilTerran> > unfoldr (Just . lex) "7 12*6+"
17:24:02 <lambdabot>   Couldn't match expected type `(a, GHC.Base.String)'
17:24:05 <EvilTerran> hm
17:24:17 <jfoutz> yeah, i get your drift.
17:24:26 <twanvl_> > unfoldr (listToMaybe . lex) "7 12*6+"
17:24:30 <lambdabot>   ["7","12","*","6","+","","","","","","","","","","","","","","","","","",""...
17:24:40 <EvilTerran> twanvl_, ah, of course
17:24:58 <EvilTerran> > lex "" -- hmm
17:25:00 <lambdabot>   [("","")]
17:25:05 * EvilTerran would've expected that to be []
17:25:29 <dolio> > lex "      "
17:25:31 <lambdabot>   [("","")]
17:25:42 <jfoutz> on the downside, then i would need an if.
17:26:18 <dolio> [] is a parse failure. Doesn't make for a good base case.
17:26:39 <dolio> Presumably.
17:28:42 <EvilTerran> dolio, i was thinking lex's contract was to remove exactly one token from the start of the string, if possible
17:28:54 <EvilTerran> so a lack of tokens would be a parse failure
17:29:35 <twanvl_> > foldl (\s@(~(a:b:c)) o -> maybe (read o:s) (\x -> x a b:c) (lookup o [("+",(+)),("-",(-)),("*",(*))])) [] . takeWhile (not . null) . unfoldr (listToMaybe . lex) $ "7 12*6+"
17:29:37 <lambdabot>   [90]
17:30:12 <EvilTerran> altho, from the docs:
17:30:21 <EvilTerran> "If the input string contains only white space, lex returns a single successful `lexeme' consisting of the empty string. (Thus lex "" = [("","")].) If there is no legal lexeme at the beginning of the input string, lex fails (i.e. returns [])."
17:30:23 <jfoutz> oh, that's nice.
17:30:51 <Berengal> > (foldl (\st@(~(t:s:r)) w@(c:_) -> maybe (read w:st) (\o->o s t:r) (lookup c [('+',(+)),('-',(-)),('*',(*)),('/',div)])) [] . words) "5 6 + 3 *"
17:30:53 <lambdabot>   [33]
17:31:06 <dolio> > lex "(((35)))"
17:31:07 <lambdabot>   [("(","((35)))")]
17:31:39 <EvilTerran> those two sentences strike me as mutually contradictory, but i guess it works if you read it with pattern-failure-like fall-through
17:31:42 <dolio> At least lex is no longer used in read. :)
17:32:05 <dolio> Well, you could see the empty string as 'white space'.
17:32:14 <dolio> 0 white space characters. :)
17:33:03 <dolio> > all isSpace ""
17:33:04 <lambdabot>   True
17:33:39 <otto_s_> > all undefined ""
17:33:41 <lambdabot>   True
17:34:00 <Berengal> > any undefined ""
17:34:01 <lambdabot>   False
17:37:11 <Berengal> words is a good enough lexer for me
17:37:17 <jfoutz> yeah.
17:37:29 <dolio> I've certainly never used lex.
17:37:30 <jfoutz> two stacks. so much better.
17:37:32 <Berengal> and foldl is a free stack-based machine
17:38:17 <jfoutz> yeah. that's a really slick way to do it.
17:39:03 <Berengal> I did it without lambdas once, but I forgot how :/
17:39:18 <jfoutz> try @pl ;)
17:39:29 <Berengal> @pl foldl (\st@(~(t:s:r)) w@(c:_) -> maybe (read w:st) (\o->o s t:r) (lookup c [('+',(+)),('-',(-)),('*',(*)),('/',div)])) [] . words
17:39:30 <lambdabot> (line 1, column 11):
17:39:30 <lambdabot> unexpected "@"
17:39:30 <lambdabot> expecting letter or digit, operator, pattern or "->"
17:39:39 <Berengal> :(
17:40:40 <Berengal> I guess it's not that easy to @pl at-patterns...
17:41:24 <dolio> It'd be a pain, at least.
17:41:56 <dolio> Preprocess to turn the right-side stuff into equivalent functions.
17:41:57 <Berengal> Not always possible either. It requires functions extracting the relevant bits out of a structure
17:42:18 <dolio> @pl \(x:y) -> (x,y)
17:42:18 <lambdabot> liftM2 (,) head tail
17:42:47 <dolio> That's technically wrong.
17:44:03 <Berengal> It is?
17:44:08 <dolio> Yes
17:44:17 <dolio> > liftM2 (,) head tail undefined
17:44:20 <lambdabot>   (* Exception: Prelude.undefined
17:44:29 <dolio> > (\(x:y) -> (x, y)) undefined
17:44:30 <lambdabot>   * Exception: Prelude.undefined
17:44:57 <Berengal> Ah, I see
17:45:24 <dolio> The pl version is equivalent to \~(x:y) -> (x, y)
17:45:48 <jfoutz> Berengal: you proably moved the stack manipulation into the operators. some crazy combination of (+) . head
17:46:00 <Berengal> Yeah, it'd need a strict function applicative/monad instance to be correct
17:46:24 <Berengal> jfoutz, nope, just the pattern bindings
17:47:04 <Berengal> jfoutz, I defined the stack as 'stACK@(~(tOP:sECOND:rEST))'
17:47:14 <jfoutz> er... for your lambda free implementation of the calculator
17:47:25 <Berengal> oh, yes, possibly
17:47:47 <Berengal> I think I just layered on the applicatives and arrows like I was making a giant hueg like xbox lasagna
17:47:55 <jfoutz> i mean, whatever works... just seems a natural way to get rid of them.
17:47:57 <jfoutz> hahaha
17:47:58 <Berengal> and mixed it good with spaghetti just to be sure
17:48:20 <jfoutz> hmm. speaking of food.
17:48:24 * jfoutz waves goodbye
17:48:28 <Berengal> Indeed...
17:48:31 * Berengal makes lasagna
18:19:10 <uninverted> Does haskell have any equivalent of lisp's 'apply'?
18:20:02 <mauke> what would its type be?
18:20:59 <uninverted> mauke: Ah. It would imply variable argument lengths, which I don't think haskell has. Thanks.
18:21:39 <mauke> > ""++ printf "%s %c %d" "varargs!" 64 42
18:21:42 <lambdabot>   "varargs! @ 42"
18:22:53 <uninverted> mauke: Hmm... I've got some thinking to do :)
18:23:13 <Draconx> I found printf's implementation to be very cute when I read it.
18:23:25 <monochrom> What does apply do?
18:23:49 <mauke> monochrom: apply f [x1, x2, ..] = f x1 x2 ..
18:24:05 <monochrom> I guess you can try f <$> x <*> y <*> z <*> ...
18:25:19 <sbahra> mauke, did you see the comparison sgt was asking for yesterday in #C?
18:25:34 <mauke> sbahra: no
18:25:59 <sbahra> mauke, http://codepad.org/dBoFb106
18:26:08 <sbahra> mauke, Haskell equivalent (sort of) of that Python.
18:26:20 <sbahra> mauke, do you know a much more concise way off the top of your head?
18:26:57 <sbahra> mauke, (print out last column of ps auxww on Linux, in Haskell)
18:27:30 <mauke> needs more intercalate
18:28:07 <sbahra> Sure.
18:28:08 <mauke> wait, that looks broken
18:28:21 <mauke> unwords and unlines are in the wrong order
18:28:30 <sbahra> It works.
18:28:48 <sbahra> unlines is not used.
18:29:03 <sbahra> [sbahra@centrino tmp]$ runhaskell popen.hs |tail -2
18:29:03 <sbahra>  /usr/lib/ghc-6.10.4/ghc -B/usr/lib/ghc-6.10.4/. -dynload wrapped -ignore-dot-ghci -x hs -e :set prog "popen.hs" -e :main [] popen.hs
18:29:03 <sbahra>  ps auxww
18:29:05 <mauke> it should be
18:29:29 * sbahra was hoping something much cleaner
18:29:46 <sbahra> It obviously isn't efficient, I should avoid using unlines and unwords all together.
18:30:02 <sbahra> Though, it would be nice if there was something similar to Python's split. :-P
18:30:03 <mauke> :t intersperse
18:30:09 <lambdabot> forall a. a -> [a] -> [a]
18:30:18 <sbahra> mauke, _mapM
18:30:31 <copumpkin> Data.Split
18:31:16 <sbahra> copumpkin, huh?
18:31:19 <mauke> oh, you insert spaces between every chunk and before the newlines
18:31:25 <sbahra> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
18:31:39 <copumpkin> whoops, that's what I meant
18:31:50 <mauke> s = unlines . map (unwords . drop 10 . words) . lines
18:32:00 <sbahra> Better :-)
18:32:33 <sbahra> heh
18:33:00 <mauke> print +(split)[-1] for `ps auxww`;  # clearly the second best solution
18:34:38 <mauke> whoops, should be (split ' ', $_, 10) of course
18:40:13 <sbahra> Data.List.Split is good for this. :-)
18:41:46 * sinsun Free Chinese Class is still welcome Linux users and friends. Join #sinsun-says
18:42:18 <mauke> sinsun: how is that haskell related?
18:42:19 <copumpkin> sinsun: people don't enjoy advertising in their channels
18:42:38 <copumpkin> sinsun: you'll get much worse reactions from other channels
18:58:46 <dolio> @djinn J r a -> Cont r a
18:58:47 <lambdabot> f a b = b (a b)
18:59:02 <dolio> @djinn Cont r a -> J r a
18:59:02 <lambdabot> -- f cannot be realized.
18:59:03 <copumpkin> that's so weird
19:00:29 <dolio> From very limited experimentation, it appears you might be able to prove 'J Void T' where T is any classical theorem.
19:00:45 <Philonous> @hoogle J
19:00:45 <lambdabot> package jack
19:00:45 <lambdabot> Text.Parsec.Language javaStyle :: LanguageDef st
19:00:45 <lambdabot> Text.ParserCombinators.Parsec.Language javaStyle :: LanguageDef st
19:00:50 <dolio> Similar to how you can prove 'Cont Void T'.
19:01:05 <copumpkin> Philonous: roconnor's reddit post from yesterday
19:01:20 <copumpkin> Philonous: http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
19:01:24 <Philonous> Thanks
19:02:08 <dolio> @djinn Either a (Not a) -> ((a -> b) -> a) -> a
19:02:08 <lambdabot> f a b =
19:02:08 <lambdabot>     case a of
19:02:08 <lambdabot>     Left c -> c
19:02:08 <lambdabot>     Right d -> b (\ e -> void (d e))
19:02:14 <copumpkin> wow, edwardk's response clarifies it so much :P
19:02:21 <dolio> @djinn J Void (((a -> b) -> a) -> a)
19:02:21 <lambdabot> f a b = b (\ c -> void (a (\ _ -> c)))
19:03:24 <dolio> @djinn J Void (Not (Not a) -> a)
19:03:24 <lambdabot> f a b = void (b (\ c -> a (\ _ -> c)))
19:03:27 <copumpkin> cantor = sequence (repeat bit)
19:03:30 <dolio> Those are two biggies.
19:03:36 <copumpkin> how can you sequence something infinite?
19:03:49 <dolio> Depends on the monad.
19:03:55 <copumpkin> ah, fair enough
19:04:08 <dolio> > sequence (repeat id) 5
19:04:10 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
19:04:21 <copumpkin> ah yeah
19:06:14 <Saizan> @djinn J r (((a -> r) -> r) -> a)
19:06:14 <lambdabot> -- f cannot be realized.
19:06:20 <dolio> The whole point of the searchable-infinite-sets thing is that you can do that kind fo thing.
19:06:21 <copumpkin> is peirce on that page supposed to be pierce?
19:06:37 <dolio> No, it's actually spelled weirdly.
19:06:47 <copumpkin> oh odd, what is it referring to?
19:06:55 <dolio> Peirce's law.
19:07:07 <Saizan> aka callCC
19:07:17 <Saizan> (in Cont)
19:07:20 <copumpkin> ah cool
19:07:40 <copumpkin> lol "Written out, this means that P must be true if there is a proposition Q such that the truth of P follows from the truth of if P then Q"
19:08:09 <EvilTerran> that seems... vaguely modal?
19:08:11 <copumpkin> does that mean we couldn't write callCC in agda?
19:08:28 <dolio> Only in a monad.
19:09:36 <dolio> @type let peirce :: ((p -> q) -> p) -> p ; peirce = undefined in peirce (\k -> Right (\e -> k (Left e)))
19:09:38 <lambdabot> forall q a. Either a (a -> q)
19:09:42 <ManateeLazyCat> Why i got "c2hs: does not exist" when i run "c2hs buffer.h Buffer.chs"? I have install c2hs through cabal and ln -s to "/usr/local/bin"? Strangle....
19:09:52 <copumpkin> wow
19:10:01 <dolio> That'd be somewhat bad to be able to write in Agda.
19:10:21 <dcoutts> ManateeLazyCat: that's c2hs telling you some file does not exist
19:10:39 <dolio> @djinn Either a (Not a)
19:10:39 <lambdabot> -- f cannot be realized.
19:11:05 <ManateeLazyCat> dcoutts: "c2hs buffer.h Buffer.chs" is right usage?
19:11:31 <ManateeLazyCat> dcoutts: "some file does not exist"? What file?
19:12:01 <dolio> Or, I suppose not bad per-se, but it doesn't make any sense with what the types mean.
19:12:07 <dcoutts> ManateeLazyCat: both those files exist?
19:12:56 <ManateeLazyCat> dcoutts: You mean i must create Buffer.chs before i run "c2hs buffer.h Buffer.chs"?
19:13:06 <dcoutts> ManateeLazyCat: of course!
19:13:23 <ManateeLazyCat> dcoutts: I consider c2hs will create Buffer.chs automatically.
19:13:33 <dcoutts> ManateeLazyCat: I think you might want to read the user guide
19:13:38 <copumpkin> what's chs?
19:13:47 <dcoutts> copumpkin: it's like hsc2hs, but better
19:13:58 <ManateeLazyCat> dcoutts: Yes, i'm reading "Usage of C->Haskell" first chapter....
19:14:00 <copumpkin> :o
19:14:32 <dcoutts> ManateeLazyCat: just like hsc2hs requires you start with a .hsc file, c2hs requires you start with a .chs file
19:14:46 <ManateeLazyCat> dcoutts: Oh, i see, Thanks! :)
19:15:08 <dcoutts> ManateeLazyCat: it does not magic up a binding from the header, you've got to say which C functions and C types you want to bind
19:15:38 <dolio> @type callCC $ \k -> return . Right $ k . Left
19:15:40 <lambdabot> forall b (m :: * -> *) a. (MonadCont m) => m (Either a (a -> m b))
19:15:49 <EvilTerran> hm... would too much -XMagicHash leads to -XIncoherentInstances? :P
19:16:06 <copumpkin> :)
19:16:11 <dcoutts> ManateeLazyCat: what it does, if you say which C function name you want to import, it makes a FFI import with the correct types given the type of the C function declared in the .h file
19:16:43 * EvilTerran will stop looking at the Language.Extension haddock for random things to play with now
19:17:03 <ManateeLazyCat> dcoutts: I'm study c2hs before i binding VTE library, i'm reading "Foregin Function Interface", "The binding Generator C->Haskell", "C-> Haskell or Yet Another Interfacing Tool", "Haskell Bindings to C from Start to Finish", and those resource is enough? Have other article need to read?
19:18:23 <ManateeLazyCat> dcoutts: I see. thanks for explain! I think i need read and understand those resource before i binding VTE API......
19:19:10 <dcoutts> ManateeLazyCat: there's a post on the gtk2hs blog about the code generator
19:19:24 <dcoutts> ManateeLazyCat: but understanding c2hs is the place to start
19:19:56 <ManateeLazyCat> dcoutts: gtk2hs blog? Where?
19:20:45 <dcoutts> ManateeLazyCat: gtk2hs website
19:22:18 <ManateeLazyCat> dcoutts: I found another FFI Preprocessor -- "http://www.haskell.org/greencard/", how about that? GreenCard and c2hs, which better?
19:22:38 <dcoutts> ManateeLazyCat: I don't think greencard is maintained anymore
19:29:32 <ManateeLazyCat> dcoutts: http://farm3.static.flickr.com/2676/3821227364_e739332f63_o.png is screenshot of my project, i have finish editor module and FileManager module, next to add VTE module in it, but first need binding VTE API first.
19:30:18 <ManateeLazyCat> dcoutts: http://farm3.static.flickr.com/2539/3843685031_9184ddf049_o.png this is another screenshot.
19:30:39 <dcoutts> jolly good
19:31:39 <ManateeLazyCat> dcoutts: Thanks for your great work for gtk2hs, otherwise my project can't born.... :)
19:32:02 <veinor> I think I've written the first ever pure-haskell ID3 tag reader
19:32:11 <veinor> NO YOU CAN'T HAVE IT
19:33:19 * dcoutts notes he's not worked seriously on gtk2hs for ~2 years
19:34:00 <dcoutts> coincidentally I'm just building a gtk2hs-0.10.1 windows installer for ghc-6.10.4
19:35:23 <ManateeLazyCat> dcoutts: But you help many gtk2hs newbie (like me) at IRC. Otherwise we will block some problem long time...
19:35:28 * jfoutz tries to resist sying the simpsons did it.
19:35:41 <jfoutz> veinor: have you checked out dons's hmp3?
19:35:55 <jfoutz> http://www.cse.unsw.edu.au/~dons/hmp3.html
19:36:07 <veinor> Didn't show up on a google search, so I didn't know about it. Now I don't feel special :<
19:36:19 <veinor> Oh, it's a player, not an ID3 thing.
19:36:26 <jfoutz> veinor: you are a unique little snowflake :)
19:36:31 <veinor> :)
19:36:48 <veinor> I was actually writing it as part of a haskell mpd ncurses frontend
19:36:59 * jfoutz giggles
19:37:01 <veinor> Which I will start... right after I organize my music collection
19:37:30 <veinor> which I will do by writing a quick python script to make appropriate symlinks
19:45:22 * copumpkin is trying to golf matrix multiplication for [[a]
19:45:23 <copumpkin> ]
19:45:23 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
19:45:58 <jfoutz> hmm.
19:46:05 <jfoutz> :t transpose
19:46:06 <lambdabot> forall a. [[a]] -> [[a]]
20:08:31 <veinor> IRC... for Emacs?
20:08:35 <veinor> I guess it really is an operating syste.
20:08:37 <veinor> m
20:08:57 <jfoutz> there used to be a web browser. not sure if it's still maintained.
20:09:40 <jfoutz> the spreadsheet mode is pretty nice.
20:09:57 <jfoutz> er, table-mode
20:12:30 <copumpkin> hmm, polymorphic recursion is what I need
20:14:49 <Saizan_> mmh, juicy
20:15:00 <copumpkin> any cheap and easy way to get it?
20:15:24 <Saizan_> apart from giving a type signature?
20:15:33 <SamB_XP_> and staying away from SML?
20:16:06 <Saizan_> SML gives you no way to get polymorphic recursion?
20:16:09 <monochrom> The first time I saw an IRC client it was part of emacs.
20:16:31 <monochrom> In fact that's the first application of emacs I saw too. I knew it as an editor later.
20:16:40 <Nafai> Wow
20:17:34 <SamB_XP_> monochrom: crazy shit!
20:18:46 <elliottt> dons: you around?
20:22:24 <copumpkin> hmm, transposing this typenat matrix is proving difficult
20:22:45 <monochrom> matrix in the types?!
20:23:09 <copumpkin> only its size is type-level
20:23:12 <jfoutz> oh. i thought i was doing ok. ha!
20:23:14 <copumpkin> it still holds values
20:23:23 <copumpkin> although I do have a type-level vector
20:23:39 <copumpkin> not much use though
20:24:31 <jfoutz> @hoogle [a]->[[a]]
20:24:32 <lambdabot> Data.List inits :: [a] -> [[a]]
20:24:32 <lambdabot> Data.List tails :: [a] -> [[a]]
20:24:32 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
20:25:55 <veinor> copumpkin: the matrix has you
20:26:00 <copumpkin> onoes
20:26:07 <hackagebot> openid 0.1.3.0 - An implementation of the OpenID-2.0 spec. (TrevorElliott)
20:26:52 <SamB_XP_> does pumpkin has the comatrix?
20:27:15 <monochrom> hahahahah
20:29:09 <Makoryu> Someone could reimplement curl in Haskell and call it hurl
20:29:15 <monochrom> "adjunction law: co pumpkin ⊑ matrix  iff  pumpkin ⊑ co matrix"
20:29:26 <monochrom> haha hurl
20:30:28 <copumpkin> :o
20:37:00 <copumpkin> so this fails:
20:37:01 <copumpkin> transposeMat :: forall a m n. (Nat m, Nat n) => Mat a m n -> Mat a n m
20:37:01 <copumpkin> transposeMat Nil = Nil
20:37:07 <copumpkin> where Nil :: Vec a Z
20:37:23 <copumpkin> and type Mat a m n = Vec (Vec a m) n
20:38:49 <copumpkin> it says     Couldn't match expected type `m' against inferred type `Z'
20:40:02 <jfoutz> :t on
20:40:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:44:36 <veinor> @hoogle on
20:44:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:44:37 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
20:44:37 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
20:44:43 <veinor> what does on do?
20:45:18 <copumpkin> > ((+) `on` (*5)) 5 7
20:45:20 <lambdabot>   60
20:45:42 <veinor> Cool.
20:46:07 * veinor looks through data.Function
20:46:16 <copumpkin> not much else in there of interest
20:46:16 <veinor> how can you define fix?
20:46:18 <copumpkin> except fix
20:46:22 <copumpkin> two ways
20:46:39 <copumpkin> let fix f = f (fix f)
20:46:44 <copumpkin> but that's inefficient
20:47:00 <copumpkin> @src fix
20:47:00 <lambdabot> fix f = let x = f x in x
20:47:10 <veinor> > fix (+1)
20:47:16 <lambdabot>   mueval-core: Prelude.read: no parse
20:47:16 <lambdabot>  mueval: ExitFailure 1
20:47:16 <copumpkin> that won't get you very far
20:47:18 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml  you could have re-invented fix too
20:47:24 <veinor> fix fix
20:47:28 <veinor> whoops
20:47:29 <veinor> > fix fix
20:47:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
20:49:09 <ski> > fix (1:)
20:49:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:49:42 <copumpkin> > fix ((0:) . scanl (+) 1)
20:49:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:49:54 <ski> > (\b -> fix (\pow_b n -> if n == 0 then 1 else b * pow_b (n-1))) 2 5
20:49:56 <lambdabot>   32
20:50:07 <veinor> neat
20:52:57 <jfoutz> well, here's my silly multiply...
20:53:00 <jfoutz> > (\x y -> take (length $ transpose y) $ unfoldr (\s -> Just (splitAt (length x) s)) [sum (zipWith (*) r c) | r <- x, c <- transpose y]) [[1, 0, -2],[0,3,-1]] [[0,3], [-2,-1],[0,4]]
20:53:01 <lambdabot>   [[0,-5],[-6,-7]]
20:54:33 <jfoutz> i remember doing somethink like copumpkin's typed multipy with c++ templates a long long time ago...
20:54:47 <copumpkin> ack
20:54:52 <copumpkin> that's complicated
20:55:18 <jfoutz> meh. it ended up being very slow and lame.
20:55:46 <Phyx-> hmm you guys still up
20:55:54 <Phyx-> what timezone are you guys? lol
20:56:04 <copumpkin> I'm new england
20:56:15 <jfoutz> mountain
20:56:26 <ski> /ctcp Phyx- time
20:57:05 <Phyx-> i'm currently on vacation, but my clock is still on my time back home
20:57:10 <Phyx-> why it told you 6am ski
20:57:27 <ski> CTCP TIME reply from Phyx-: Sat Aug 22 05:56:16 2009
20:57:28 <ski> rather
20:57:38 <Phyx-> almost 6am
20:57:54 <ski> (same as my clock)
20:58:24 <Phyx-> i would never be up at that hour
20:58:34 <Phyx-> unless i have a deadline and am pulling an all nighter
20:59:15 * ski woke up maybe half an hour ago
20:59:16 <Phyx-> I heard those aren't healthy...
20:59:53 <Phyx-> "You need to sleep" is what i keep hearing from everyone
20:59:56 <edwardk> copumpkin: response?
21:00:01 <edwardk> copumpkin: oh, the j monad
21:00:01 <copumpkin> ?
21:00:06 <copumpkin> ah yeah
21:00:52 <ski> (is `\a -> (a -> r) -> a' called the "response" monad ?)
21:00:56 <copumpkin> > transpose [[1],[2,3]]
21:00:56 <edwardk> i was thinking about transcribing that into a blog post actually, since reddit is somewhat ephemeral ;)
21:00:57 <lambdabot>   [[1,2],[3]]
21:01:12 <copumpkin> edwardk: yeah, that'd be cool
21:02:02 <edwardk> there are some other combinators i was thinking about adding to it as well, for instance, it should be possible to generate a list or Set given an Eq or Ord instance depending on how anal retentive you want to be about the monad laws
21:02:31 <edwardk> i.e. ask for one element using 'or' and then add it to a set, and then ask for the next element that isn't a member of the set you've already drawn...
21:06:40 <copumpkin> ah neat
21:07:00 <monochrom> > 8*60*60*1000000
21:07:01 <lambdabot>   28800000000
21:07:12 <monochrom> Phyx-: You need threadDelay 28800000000
21:07:40 <Phyx-> monochrom: hm?
21:07:50 <monochrom> sleep 8 hours :)
21:07:53 <Phyx-> oh
21:08:02 <Phyx-> i'll be changing 6 timezones on monday
21:08:07 <Phyx-> so i'll get plenty on the plane
21:08:07 <Phyx-> :)
21:08:08 <monochrom> Fun
21:08:30 <Phyx-> 9-10 hour flight, depending on weather and if the pilot steps on it
21:09:53 <inimino> some planes do have pedals but they're not the kind you want anyone to step on
21:10:35 <Phyx-> well, it depends, the 777 usually does 9, 9.30 on it, the 747 does it in 8.45
21:10:42 <Phyx-> so depends on which one they fly with
21:13:33 <dino-> Phyx-: Where are you traveling to-from?
21:14:11 <dino-> s/traveling/travelling/
21:14:32 <Phyx-> dino-: .an -> .nl
21:15:25 <Phyx-> or, from Curacao to the netherlands
21:16:01 <edwardk> aww. i couldn't quite come up with a comonad for J.
21:16:19 <dino-> Phyx-: Ack, you're in tropical paradise. Stay there!
21:16:42 <Phyx-> dino-: tired of the sun
21:16:49 <dino-> Seriously, though, I'd love to travel to .nl too.
21:16:51 <edwardk> hrmm, maybe one for Search though
21:17:22 <Phyx-> dino-: anywhere specific? amsterdam? (or did you mean .an)
21:17:28 * monochrom tried a http://www.gov.an/ to find out what is .an . It was successful.
21:19:16 <dino-> Phyx-: Just the Randstad area, there seems to be tech work. I think the US is trying to kill us with our culture's fixation on the poor healthcare system.
21:19:40 <ski> edwardk : `J r a = (a -> r) -> a' ?
21:19:50 <edwardk> ski: yeah
21:20:04 <ski> where is this coming from ?
21:20:05 <edwardk> though Search locks r to True
21:20:23 <edwardk> http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
21:21:09 <edwardk> given my second post in there, extract = choose (const True) -- works for Copointed
21:21:23 <edwardk> for J Bool
21:21:41 <edwardk> but i don't have a way to rotate the focus around the set to make the comonad
21:22:06 <copumpkin> > sum []
21:22:08 <lambdabot>   0
21:22:10 <copumpkin> is that a good thing?
21:22:28 <ski> yes
21:22:32 <edwardk> 0 is the unit for addition
21:22:51 <ski> `sum' is a monoid homomorphism
21:23:30 <Phyx-> dino-: ah, i live in Randstad
21:23:43 <Phyx-> or, a Randstad area
21:24:53 <ski> (`[a]' is the free monoid on `a')
21:25:39 <jrockway> hmm, i am having a weird type inference problem; runhaskell and ghc (via "cabal build") are disagreeing about the inferred type
21:26:07 <jrockway> ghc infers "try getLine" to IO (Either Exception String)
21:26:18 <jrockway> and runhaskell infers it to IO (Either IOException String)
21:26:47 <jrockway> i don't really care about this value, as I am just going to kill the program, but i can't get it to compile if i am not explicit, or am explicit in the wrong direction
21:27:32 <SamB_XP_> jrockway: it sounds like they are using different "try" functions ...
21:27:46 <jrockway> i am actually qualifying it
21:27:49 <jrockway> here is the code: http://github.com/jrockway/pmerge/blob/0bce17b9004d2b366a2a108dd728066e295d2b03/pmerge.hs
21:27:53 <SamB_XP_> @type System.IO.try
21:27:55 <lambdabot> Not in scope: `System.IO.try'
21:28:00 <SamB_XP_> @type Prelude.try
21:28:01 <lambdabot> Not in scope: `Prelude.try'
21:28:08 <jrockway> it's Control.Exception.try
21:28:14 <SamB_XP_> jrockway: huh ...
21:28:35 <dino-> Phyx-: I hope you have a good trip. I haven't personally been on such a long flight. But I think we're going to be travelling more.
21:28:46 <SamB_XP_> jrockway: I would expect Exception for that
21:28:54 <SamB_XP_> @type Control.Exception.try
21:28:56 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
21:29:01 <SamB_XP_> @hoogle try
21:29:01 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
21:29:01 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
21:29:01 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
21:29:19 <Phyx-> dino-: i fly it about twice a year back and forth, i just nod off for the majority of it
21:33:40 <jrockway> the amusing part is that i am actually throwing away this value, so i don't actually care what the type is :)
21:34:00 <Phyx-> @type Control.OldException.try
21:34:03 <lambdabot> forall a. IO a -> IO (Either Control.OldException.Exception a)
21:34:59 <Phyx-> anyway to catch errors thrown by "error" ? try forces me to be in an IO monad
21:36:27 <hackagebot> hums 0.2.4 - Haskell UPnP Media Server (BardurArantsson)
21:36:40 <ski> you can only catch `error' in `IO'
21:37:04 <Phyx-> sucks
21:37:15 <ski> otherwise it'd not be pure
21:38:00 <Phyx-> doesn't the use of error itself make the function impure? instead of just partial?
21:38:09 <ski> no
21:38:48 <ski> @src head
21:38:48 <lambdabot> head (x:_) = x
21:38:48 <lambdabot> head []    = undefined
21:38:50 <ski> @src undefined
21:38:51 <lambdabot> undefined =  error "Prelude.undefined"
21:38:55 <ski> @type head
21:38:56 <lambdabot> forall a. [a] -> a
21:39:04 <ski> no `IO' in the type of `head'
21:39:07 <jrockway> incidentally, rewriting with catch makes this go away
21:39:15 <jrockway> a little less pretty however
21:39:19 <ski> (no other monad in the resullt, either)
21:39:55 <blackdog> i still don't really understand exceptions in haskell. can you throw them from pure code?
21:40:11 <jrockway> yes
21:40:16 <Phyx-> @type catch
21:40:17 <blackdog> that would seem to undermine pretty much any guarantees of totality you have...
21:40:18 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:40:22 <jrockway> you can only catch them in IO, though
21:40:31 <jrockway> or use the Exception monad, but those are different exceptions
21:40:41 <jrockway> (i think.)
21:40:44 <ski> @hoogle throw
21:40:44 <lambdabot> Control.Exception throw :: Exception -> a
21:40:44 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
21:40:44 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
21:41:00 <ski> jrockway : do you mean `Either e' and `ErrorT e m' ?
21:41:04 <blackdog> just makes me worry that there's no type-directed way of ensuring a piece of code won't throw an exception
21:41:30 <jrockway> hmm, i thought there was some other exception mechanism
21:41:37 <jrockway> but i always use Either or ErrorT
21:41:38 <Phyx-> it's a rather inconvenience no? ina pure function to not be able to "catch" an error, i know that makes it impure, but still it's an annoying inconvenience at times
21:41:58 <jrockway> it makes sense to me
21:42:15 <Phyx-> never said it didn't
21:42:18 * ski only uses `error' for "implementation error" or "precondition not satisfied"
21:42:24 <Draconx> blackdog, indeed there is not.  But this is already the case since Haskell permits non-exhaustive pattern matches and also has undefined.
21:42:24 <Phyx-> just said it's an inconvenient
21:42:25 <Phyx-> or
21:42:26 <blackdog> I think it's impure already, though.
21:42:36 <Phyx-> functions like head should be rewritten to use the Maybe monad
21:42:40 <Phyx-> and not just fail
21:42:43 <blackdog> Draconx: undefined is a bit different - that's just bottom
21:42:50 <smarmy> i don't know if i'd call it impure
21:42:56 <jrockway> Phyx-: agreed
21:42:58 <smarmy> the pure code doesn't have to catch exceptions
21:43:00 <blackdog> Draconx: and most compilers will warn you about non-exhaustive pattern matches statically
21:43:00 <smarmy> io does
21:43:05 <smarmy> and io has exception semantics
21:43:07 <jrockway> people are confused because the first functions they see in haskell are the weird oens
21:43:14 <jrockway> in real code, everyone uses Maybe/Either
21:43:18 <ski> Phyx- : or `Either e' (if this `Error e' constraint could be purged)
21:43:22 <jrockway> for some value of everyone :)
21:43:29 <blackdog> smarmy: sure. but i would like to call some pure code with a guarantee that it won't do anything weird
21:43:55 <Phyx-> ski: both would be better then just doing error
21:43:59 <smarmy> hmmm.  i see your point.  the type system doesn't tell you that pure code will have exception semantics in the io monad.  it's just assumed
21:44:05 <ski> blackdog : `error "foo"' is bottom in the same way the `undefined' is
21:44:12 <jrockway> blackdog: i think there is a lint you can run on your codebase to determine that you won't mis-pattern-match, etc.
21:44:16 <Phyx-> @unless
21:44:16 <lambdabot> Unknown command, try @list
21:44:24 <ski> @type unless
21:44:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:44:33 <Phyx-> ah, forgot the @type
21:44:33 <blackdog> jrockway: if you just turn on -Wall in ghc, it'll do it
21:44:43 <Phyx-> looks like i'm not at my sharpest at this hour
21:45:46 <Draconx> blackdog, They're no different -- both these things allow you to define functions which crash your program.
21:46:18 <Draconx> blackdog, pure functions, rather.
21:46:34 <blackdog> isn't the classic definition of undefined just undefined, though?
21:46:39 <blackdog> technically, that should loop forever
21:46:40 <ski> well-typed programs don't go wrong :)
21:47:07 <blackdog> i already have to accept that my code may run forever because of the halting theorem, unless i have some stronger evidence that it finishes
21:47:39 <smarmy> haskell can't solve the halting problem?  stupid language... and after i spent all this time learning it
21:47:44 <ski> another definition of `undefined' is `undefined | False = undefined'
21:48:09 <ski> > let undefined | False = undefined in undefiend
21:48:10 <lambdabot>   Not in scope: `undefiend'
21:48:12 <ski> > let undefined | False = undefined in undefined
21:48:14 <blackdog> ski: so that would get picked up by -Wall
21:48:14 <lambdabot>   * Exception: <interactive>:1:137-165: Non-exhaustive patterns in function u...
21:48:48 <tingi> why do we get virtual timer expired in haskell ?
21:48:53 <ski> yes, that would say `undefined' possibly is partial
21:49:18 <ski> (or maybe even "surely", if it's that smart)
21:50:34 <blackdog> i wonder how far you could push the idea of only using total functions (including bottom, not talking about guaranteed completion)
21:51:03 <blackdog> if you use IEEE floating point, you don't get div by zero exceptions, do you? just NaN
21:51:17 <ski> > 0 / 0
21:51:18 <lambdabot>   NaN
21:51:31 <ski> > 0 `div` 0
21:51:32 <lambdabot>   * Exception: divide by zero
21:51:44 <blackdog> yeah, not much you can do about it if you're in the integers
21:51:50 <smarmy> blackdog: wasn't there a paper on total functional programming not too long ago?  i have it here somewhere...
21:52:03 <blackdog> unless you want to return a Maybe from every division :)
21:52:18 <ski> (well, it would be nice if  n `mod` 0 = n  )
21:52:32 <blackdog> ski: does that make sense?
21:52:36 <tommd> > 4 `mod` 0
21:52:39 <lambdabot>   * Exception: divide by zero
21:52:48 <blackdog> surely you can't have n `mod` m being more than m
21:52:57 <ski> why not ?
21:52:59 <blackdog> or equal to, really
21:53:01 <smarmy> this may have been it: http://lambda-the-ultimate.org/node/2003
21:53:11 <ski> every number is only congruent to itself, modulo zero
21:53:39 <Draconx> blackdog, sure -- the quotient ring Z / 0*Z is isomorphic to Z.
21:53:58 <ski> "modulo one" induces the coarsest quotient on the integers
21:54:09 <ski> while "modulo zero" induces the finest quotient
21:54:30 <ski> `0' is the greatest element in the division partial order
21:56:21 <blackdog> ski: hm, fair enough. my maths is rustier than it should be. quotient rings are number theory? group theory?
21:56:32 <ski> ring theory
21:58:18 <copumpkin> anyone have any suggestions about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8418#a8418 ?
22:02:40 <ski> what if you try unwrapping into
22:02:40 <Draconx> blackdog, Z / nZ is just arithmetic mod n from elementary number theory.  My previous comment just says we get all the integers again when n = 0.
22:02:52 <ski>   foldr1Vec :: forall a n. (a -> a -> a) -> Vec a (S n) -> a
22:02:58 <ski>   foldr1Vec f (x `Cons` xs) = foldr1VecCons f x xs
22:03:00 <ski>     where
22:03:16 <ski>     foldr1VecCons :: forall a n. (a -> a -> a) -> a -> Vec a n -> a
22:03:46 <copumpkin> isn't that just foldrVec?
22:03:59 <ski>     foldr1VecCons f x  Nil          = x
22:04:33 <ski>     foldr1VecCons f x (y `Cons` xs) = f x (foldr1VecCons f y xs)
22:04:45 <copumpkin> ah, yes it is
22:04:49 <ski> copumpkin : i suppose it amounts to that, yes
22:04:51 <copumpkin> well ,that worked, thanks :)
22:05:35 <ski> `foldr1VecCons' was derived by the equation
22:05:35 <ski>   foldr1VecCons f x xs = foldr1Vec f (x `Cons` xs)
22:05:44 <ski> (so it's a specialized version)
22:05:49 <copumpkin> yeah
22:06:04 <ski> of course it would be even better if this wouldn't be needed
22:06:20 <copumpkin> foldr1Vec :: (a -> a -> a) -> Vec a (S n) -> a
22:06:20 <copumpkin> foldr1Vec f (x `Cons` xs) = foldrVec f x xs
22:06:21 <copumpkin> that worked
22:06:31 <copumpkin> although strangely enough, so did Vec a n
22:06:35 <copumpkin> in the type
22:06:44 <copumpkin> but I guess haskell just isn't smart enough
22:06:46 <copumpkin> :P
22:06:54 <ski> if you use `Vec a n' in that type, you get a partial function
22:06:58 <copumpkin> yeah
22:07:12 <copumpkin> that's what I was hoping to avoid, but I was also hoping haskell would catch that :P
22:07:29 <ski> try with `-Wall'
22:15:49 <copumpkin> hmm, reverseVec is proving quite difficult oo
22:15:50 <copumpkin> too
22:16:01 <copumpkin> in fact, working with this in general is quite difficult, let's go shopping
22:16:05 <copumpkin> (that is, play with agda)
22:17:12 <ski> do you have `appendVec' ?
22:17:23 <copumpkin> oh no, forgot to write that one
22:17:32 <copumpkin> gimme a sec
22:17:39 <ski> "nrev" should be simple, given that
22:19:24 <edwardk> copumpkin: just tuned in, type length measured lists?
22:19:26 <copumpkin> hmm, the obvious approach obviously won't work :P
22:19:31 <copumpkin> edwardk: yup
22:19:39 <copumpkin> figured I'd waste some time, since I have so much of it
22:19:40 <ski> you need an addition of vector lengths
22:19:49 <copumpkin> ski: already have that
22:20:03 <copumpkin> but the obvious foldrVec Cons ys xs won't work, so I'm going to try something a bit cleverer
22:20:18 <edwardk> copumpkin: i have a library fragment lying around here for part of that somewhere
22:20:28 <copumpkin> edwardk: but the fun is figuring it out! :D
22:20:34 <edwardk> yeah, it was ;)
22:20:36 <ski> indeed
22:21:31 * edwardk needs to stop fiddling with J. I now have Show and Read instances for J Bool
22:21:41 <ski> heh
22:22:06 <ski> how do you show them ?
22:22:07 <edwardk> i got bored and wrote conversions to sets and lists (the latter being lazy so able to handle infinite sts)
22:22:09 <edwardk> er sets
22:22:52 <edwardk> then I show them as fromList [1,2,3] -- or whatever using the conversion to List
22:22:56 <edwardk> so I need Eq and Show
22:23:06 <edwardk> for the element type to show the list
22:23:33 <edwardk> Just like with my LZ78 code, I _can_ make it function with Eq, but its faster with Ord, so i'm at a crossroads ;)
22:23:52 <edwardk> so i just made methods that do the right thing for either scenario
22:23:54 <ski> what's `MkK $ \k -> if k 2 then 3 else 4' shown as ?
22:24:02 <edwardk> MkK ?
22:24:08 <ski> er, `MkJ'
22:24:23 <ski> assuming `newtype J r a = MkJ {unJ :: (a -> r) -> a}'
22:24:55 <edwardk> that being outside of the laws of p (find p xs) -- will probably blow up ;)
22:25:01 <edwardk> testing
22:25:50 <ski> what does that law amount to, for `f' in `MkJ f' ?
22:25:50 <edwardk> "fromList [3]"
22:28:41 <edwardk> the law for well formed members of Search comes out to something like 'if there is an x in xs such that f x == True then f (find f xs) == True'
22:29:18 <edwardk> i believe your k 2 then 3 else 4 example fails that metacondition
22:29:34 <ski> what is `find' here ?
22:29:52 <ski> one of escardo's complicated recursive traps ?
22:30:13 <edwardk> er actually
22:30:35 <edwardk> in my notation that should be choose not find, in escardo's notation find = is unJ
22:30:43 <ski> (i.e. i wonder if the law can be expressed without reference to one of those definitions)
22:31:10 <edwardk> er
22:31:18 <edwardk> so rephrasing it correctly
22:31:25 <edwardk> using the definitions from my reddit post
22:31:40 <edwardk> if there is an x such that f x == True then f (choose f xs) == True
22:32:11 <edwardk> where choose f (J g)  = g f
22:32:22 <ski> (also, `choose' is total, regardless, iirc)
22:32:27 <edwardk> just flips it around so it is in the same position as the stuff from Data.List, etc.
22:32:28 <edwardk> yeah
22:32:31 <_roconnor> > sqrt(1576.09*666.79)
22:32:34 <lambdabot>   1025.1444049986324
22:32:35 <edwardk> otherwise J returns _something_ ;)
22:32:55 <edwardk> but in general it tries to honor your predicate
22:36:00 <copumpkin> hmm, I can't seem to keep my contexts around to prove things to the typechecker
22:36:22 <ski> hm, i'm not sure what the "there is an x in xs" means
22:37:56 <edwardk> for data J r a = J ((a -> r) -> a) -- that statement doesn't make sense, but for J Bool, then it comes down to set membership, otherwise the conventions aren't very clear
22:39:23 <ski> `elem x (J f)' means what in terms of `x' and `f' ?
22:39:36 <ski> (assuming `r = Bool')
22:39:53 <lowlycoder> given an array, how do I get the n-th item?
22:39:57 <copumpkin> !
22:40:02 <copumpkin> arr ! n
22:40:22 <lowlycoder> Prelude> let x = [1, 2, 3, 4, 5]
22:40:22 <lowlycoder> Prelude> x ! 2
22:40:22 <lowlycoder> <interactive>:1:2: Not in scope: `!'
22:40:28 <lowlycoder> !! ?
22:40:30 <ski> > array (0,4) [(i,i^2) | i <- [0..4]] ! 3
22:40:31 <lambdabot>   9
22:40:41 <lowlycoder> i'm an idiot; i'm using a list
22:40:48 <ski> lowlycoder : that's a list, not an .. right
22:41:04 <ski> > [1, 2, 3, 4, 5] !! 2
22:41:06 <lambdabot>   3
22:41:10 <ski> if you really need it
22:41:16 <ski> but it's better to avoid that
22:42:34 <edwardk> ski: elem passes the Search monad the predicate "(==) x" and gets back an element, that may or may not (==) x, but if it doesn't, then it shouldn't be allowed to return a response given any predicate (modulo the weaknesses of the notions of equality provided by Haskell) that satisfies (==) x
22:43:18 <edwardk> so if I ask 'elem 1 xs' and get back False, no query I give xs should yield 1
22:45:38 <ski>   elem x (J f) = False  <=>  forall k. f k /= x
22:45:38 <ski> ?
22:45:56 <edwardk> i also wonder if a more efficient version of J could be constructed. in particular it constantly has to keep reapplying mapped functions as it goes yeah
22:46:01 <edwardk> er
22:46:03 <edwardk> yeah =)
22:46:26 <ski> (add an ` = True' to the end)
22:47:19 <ski>   elem x (J f) = True  <=>  exists k. f k == x = True
22:47:20 <ski> i suppose
22:47:49 <edwardk> ski: in any event, that is the hidden invariant for Search to have a viable interpretation
22:48:43 * ski wonders if that's right
22:48:46 <edwardk> elem x (J f) = True happens iff choose x (J f) == x
22:49:18 <edwardk> escardo points out in the original article that you can treat J as a valid monad beyond that constraint, but that it loses its set/search like connotation
22:49:33 <edwardk> (i'm paraphrasing)
22:49:52 <ski> obviously that means we should search for valid uses if it beyond `r = Bool', then :)
22:50:11 <edwardk> one option might be to say something like
22:50:42 <edwardk> data J a = J (forall r. (a -> r) -> (r -> Bool) -> a)
22:51:06 <edwardk> that should allow a lot of things like bind to avoid doing extra work
22:51:18 <edwardk> since it has to remap the same function multiple times
22:51:36 <ski>   forall r. (a -> r) -> (r -> Bool) -> a  ~=  (exists r. (a -> r,r -> Bool)) -> a  ~=  (a -> Bool) -> a
22:51:52 <edwardk> ski: i realize they are isomorphic =)
22:52:00 <copumpkin> hmm
22:52:40 <edwardk> oh, now i remember the difference i wanted
22:52:52 <edwardk> data J a = J (forall r. (a -> r) -> (r -> Bool) -> r)
22:52:56 <edwardk> better =)
22:53:22 <ski> strange
22:53:25 <edwardk> now it should be able to be used to obtain the fmapped result directly
22:53:56 <edwardk> that should be ~ Yoneda J
22:54:02 <edwardk> now that i think about it
23:00:14 <ski> > tabulate (0,-2) $ \i -> i*i
23:00:16 <lambdabot>   array (0,-2) []
23:01:11 <copumpkin> writing appendVec is hard!
23:02:03 <copumpkin> maybe cause I still can't get my contexts to stick around
23:02:16 <_roconnor> edwardk: if r is another lattice, then you can search for witness of quantifiers for other toposes
23:02:24 <_roconnor> or something like that
23:02:57 * roconnor doesn't really understand what he is saying
23:03:08 <dolio> @djinn J Void (a -> a)
23:03:08 <lambdabot> f a b = void (a (\ _ -> b))
23:04:13 <edwardk> _roconnor: the problem i had was trying to come up with the mechanism for classifying by r into more than the binary set of what you want.
23:04:18 <edwardk> vs what you don't
23:05:04 <roconnor> set r to your subobject classifier
23:05:47 <edwardk> ok, so now that you have set r to that, what 'a' do you get back?
23:06:40 <roconnor> heh, now it is beyond me.
23:06:41 <edwardk> miglet(?) or someone suggestioned using (a -> r) -> r -> a -- instead
23:06:46 <copumpkin> bah, these type errors are impossible to interpret
23:06:47 * roconnor doesn't really understand what he is saying
23:06:53 <edwardk> that basically let you classify and choose a classification
23:07:18 <edwardk> but thats weakly equivalent to passing it the (a -> Bool) in the first place
23:07:20 <roconnor> edwardk: http://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf
23:08:06 <ski> copumpkin> :t appendVec
23:08:07 <Makoryu> Is there an extension for curried pattern matching? For example, allowing you to write \(,) -> (:)
23:08:15 <copumpkin> ski: appendVec :: forall a m n. Vec a m -> Vec a n -> Vec a (n :+ m)
23:08:26 <Makoryu> Er, \(,) -> (++)
23:08:45 <edwardk> roconnor: added to my reading list
23:08:54 <roconnor> Makoryu: nope
23:08:54 <dolio> @type uncurry (++)
23:08:56 <lambdabot> forall a. ([a], [a]) -> [a]
23:09:46 <ski> `\(,) -> (++)' wouldn't be the same as `\(a,b) -> a ++ b' anyway
23:10:47 <ski> (`\((,) a b) -> ...' is not `\(,) a b -> ...')
23:10:50 <roconnor> supWitness : J r a ~ (a -> r) -> a returns the point at which p acheives it's maxiumum in the PO r.
23:10:56 <roconnor> similarly for infWitness
23:11:11 <roconnor> thats as far as I got :)
23:11:41 <edwardk> roconnor: that makes sense
23:11:43 <ski> but `True' is not larger than `False' here, right ?
23:11:51 <Makoryu> dolio: That's probably a better idea >_>
23:12:11 <roconnor> ski: either way is fine.  Dual PO is a PO
23:12:42 <ski> i thought the PO was the definedness ordering, here
23:12:51 <Makoryu> ski: True, not that it'd matter.
23:12:59 <roconnor> ski: I don't think so
23:13:19 * ski notes that he's not actually looked at that paper ..
23:13:28 * roconnor neither
23:13:33 <roconnor> well
23:13:37 <roconnor> I looked at the first 2 pages so far
23:13:38 <copumpkin> hrmrm
23:13:53 <dolio> Is it still searching infinite sets exhaustively?
23:13:57 <ski> `(:+)' is a type family ?
23:14:06 <copumpkin> yeah
23:14:22 <copumpkin> recursing on the 2nd argument
23:14:32 <copumpkin> which is why the m and n are flipped in the type signature
23:14:43 <copumpkin> I suspect that's causing me some trouble
23:14:50 <ski> not the the first one, as is traditional ?
23:14:59 <copumpkin> I should probably switch it, eh
23:15:08 <copumpkin> all my other code relies on it though, bah :P
23:15:40 <ski>   appendVec = flip flipAppendVec
23:16:06 <copumpkin> oh, I mean I'm recursing on the second type parameter to :+
23:16:15 <copumpkin> on the first to appendVec
23:16:23 <ski> oh
23:16:39 <copumpkin> type family (:+) a b
23:16:39 <copumpkin> type instance x :+ Z = x
23:16:39 <copumpkin> type instance x :+ S y = S (x :+ y)
23:17:02 <copumpkin> Vec a m -> Vec a n -> Vec a (n :+ m)
23:17:15 <copumpkin> that's what I meant by flip, it's m -> n -> (n :+ m)
23:17:27 <copumpkin> because I have appendVec Nil ys = ys
23:20:11 <harblcat> hi all. I have a question..
23:21:01 <ski> how do you do. might i ask about what question you have ?
23:21:48 <harblcat> if I'm working with the State monad, and using a 'record' to hold the state I want to keep track of, is there a more concise way to get at a bit of the total state?
23:22:10 <ski> @type gets
23:22:12 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
23:22:30 <harblcat> I am currently doing something like "state <- get; let wanted_bit = bit state; ..."
23:22:40 <jrockway> getFoo = foo get
23:22:55 <ski>   wanted_bit <- gets bit
23:23:04 <jrockway> er, liftM maybe
23:23:39 <ski> harblcat : try that
23:23:57 <harblcat> I'll give it a shot, thanks.
23:25:21 <copumpkin> damn, I need undecidable instances for my type-level nat multiplication
23:27:25 <Saizan_> undecidable instances is not that bad
23:28:20 <jekor> So what do you do when you want to use take or (!!) but you only have an Integer?
23:28:31 <Saizan_> copumpkin: btw, i still wonder why you have :+ defined recursing on the second argument :)
23:28:37 <ski> @type genericTake
23:28:39 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
23:28:45 * jekor slaps forehead
23:28:47 <jekor> Thanks, ski.
23:28:48 <copumpkin> Saizan_: I couldn't make up my mind so I flipped a coin :P
23:28:54 <copumpkin> Saizan_: but it's proved to be a pain
23:29:06 <copumpkin> and now I want to flip it but then I need to change a bunch of stuff :P
23:29:16 <copumpkin> I bet HaRe isn't smart enough to do that for me :(
23:29:16 <Saizan_> heh
23:29:42 <Saizan_> does HaRe works currently?ù
23:29:50 <copumpkin> haven't even tried it :)
23:30:19 <harblcat> ski: it worked. and I think I understand how, too. progress! thanks.
23:34:40 <edwardk> i should get some sleep the scheme workshop is in a few hours
23:35:11 <ski> any interesting talks scheduled ?
23:35:43 * ski cleverly tries to distract edwardk away from sleep
23:35:46 <edwardk> ski: for today? maybe 1 or 2, nothing that i remember other than a bit about how "if programming is math, why aren't mathemeticians teaching programming?"
23:36:07 <edwardk> ski: the day after there is a bit from oleg and cc shan, which I'm looking forward to
23:36:27 <ski> which conference is this ?
23:36:40 <edwardk> mostly looking for a new audience to proselytize the power of monoids to ;)
23:36:56 <ski> i say go for it !
23:37:45 * Saizan_ wonders which will be the cool algebraic structure next year
23:38:00 <edwardk> Saizan_: i'm hoping to start people on a right seminearring kick ;)
23:38:09 * ski hears something about Bol loops
23:38:43 <edwardk> but even just having a ringoid that has a cancellative zero would do for my purposes.
23:38:53 <edwardk> at least most of them
23:39:42 <edwardk> ski: http://users.csc.calpoly.edu/~clements/scheme-workshop-2009/
23:39:52 <ski> ty
23:40:32 <ski> (heh, eli)
23:41:33 <edwardk> heh i figure the scheme audience is easy to proselytize monoids to... they have the easiest language to parse monoidally!
23:41:57 <edwardk> its just a minor modification to the bicyclic monoid to capture the non-dyck language components, and its done
23:42:45 <ski> `bicyclic' ?
23:43:24 <edwardk> ...)..)..(..(... + ...) = ...)...)..(...
23:43:32 <BMeph> edwardk: That may be a point of interest to what's-his-face that does Liskell. :)
23:43:34 <path[l]> hi guys I have a question about types.
23:43:39 <path[l]> :t lookup
23:43:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
23:43:44 <ski> BMeph : therp ?
23:43:52 <edwardk> bitonic sequences of unpaired closing then opening braces.
23:44:21 <ski> path[l] : yes ?
23:44:22 <copumpkin> path[l]: well we have a question for you too
23:44:31 <path[l]> ! in map says Ord k => Map k a -> k -> a ... now if I have a map of Int to char. the Map is Map Int Char
23:44:38 <path[l]> but whats Ord K
23:44:39 <path[l]> ?
23:44:41 <edwardk> its related to the bicyclic monoid given by basis elements p and q, with the law pq = 1
23:44:48 <edwardk> when p = ( and q = )
23:44:55 <ski> `Ord k' means the type `k' must support ordering
23:45:00 <path[l]> ah
23:45:01 <copumpkin> path[l]: it says that the type k must be an instance of Ord
23:45:02 <path[l]> ok
23:45:12 <BMeph> ski: Clemens Fruhwirth (I hope that's spellt right... ;)
23:45:23 <edwardk> then when the value of the monoid = 1 then you have a system of balanced parentheses.
23:45:29 <path[l]> so once I specify a type thats Ord, that doesnt matter anymore
23:45:33 <path[l]> thank you
23:45:35 <ski> -!- therp [n=nil@81.94.56.25]
23:45:35 <ski> -!-  ircname  : Clemens Fruhwirth
23:46:33 <edwardk> ski: i use a modification of the bicyclic monoid to parse layout monoidally
23:46:41 <ski> edwardk : it's some kind of free construction, yes ?
23:47:31 <edwardk> well, for a free construction it is an awful lot of work to get right. ;) it isn't minimal, given the extra law pq = 1. and there are lots of not-quite bicyclic monoids for other Dyck languages.
23:47:58 * ski has no idea what `Dyck' means, here
23:48:18 <edwardk> Dyck is a guy who studied languages of balanced token pairs basically
23:48:30 <edwardk> {[]()} {} [], etc.
23:49:05 <ski> so "non-dyck language components" is like the "'","`",",",",@" tokens ?
23:49:10 <edwardk> yeah
23:49:24 <ski> or symbols and numerals, too ?
23:49:41 <copumpkin> @hackage reflection
23:49:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reflection
23:50:34 <edwardk> i basically jam them all into some big monoidal value that looks like data Bitonic m a = Bitonic (Seq (m,Closing a)) m (Seq (Opening a, m))
23:50:41 <edwardk> symbols and numerals too
23:50:45 <edwardk> anything you don't pair up
23:51:00 <edwardk> though, for me there are a fairly liberal set of things you _do_ pair up.
23:51:12 <edwardk> i.e. i pair 'case' and 'of', 'if' and 'else', etc.
23:51:32 <edwardk> and i use that to relax layout inside of the paired section
23:52:20 <edwardk> which gives the ghc if-then-else full-outdent-in-do-sugar hack and similar generalizations to other pair-like identifiers
23:52:31 <edwardk> er pair-like tokens
23:53:08 <BMeph> ski: Good catch. :)
23:53:09 <fbru02> which shell do you guys recommend , ksh ?
23:54:20 <path[l]> one more thing. [] is a shortcut for array construction and stuff. Is there something similar for Data.Set in haskell?
23:54:36 <ski> `[',`]' is for lists, not arrays
23:54:42 <copumpkin> (and no)
23:54:50 <ski> and, no, there's no syntactic sugar for `Data.Set'
23:54:52 <copumpkin> Set.fromList [..]
23:54:54 <blackdog_> path[l]: fromList usually works ok
23:55:07 <path[l]> oh ok
23:55:19 <path[l]> and yes Im sorry I meant list :)
23:55:35 <copumpkin> we forgive you, just this once :)
23:55:43 <path[l]> damn Im so noob, Im struggling to read the code I wrote just last night
23:55:44 <path[l]> lol
