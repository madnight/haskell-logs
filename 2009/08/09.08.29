00:00:13 <jauaor> Makoryu: what doesn't make it low level?, pretty much low level
00:00:19 <Makoryu> IIRC you can still get away with the screwy metaprogramming antics that Ruby programmers give each other headaches with
00:00:20 <jauaor> the design?
00:00:36 <erikc> Makoryu: you certainly can
00:00:42 <jauaor> and yes, as i said, objc is supposed to be like that
00:01:20 <Makoryu> jauaor: But low-level programming isn't....
00:01:34 <jauaor> Makoryu: isn't what?
00:01:47 <Makoryu> jauaor: ....Isn't supposed to be like that.
00:01:59 <jauaor> Makoryu: I don't follow you .. like what?
00:02:15 <jauaor> objc is pretty much a low level language
00:03:08 <jauaor> objc is just a 'strict' superset on top of C
00:03:19 <lament> this only shows how utterly useless the low/high level designations are
00:03:46 <jauaor> I mean ... objc is just message passing added to c
00:04:11 <jauaor> any C program compile with an objc compiler
00:04:14 <jauaor> or it should
00:04:17 <lament> jauaor: and smalltalk is just message passing
00:04:28 <lament> so objc is smalltalk added to c
00:04:35 <jauaor> mmm... it's what i said
00:04:38 <monochrom> (smalltalk is objc minus c?)
00:04:40 <jauaor> objc = smalltalk+c
00:04:52 <jauaor> lisaac = eiffel+c
00:05:16 <erikc> monochrom: precisely
00:05:20 <jauaor> hah
00:05:32 <lament> monochrom: more or less, yes
00:05:41 <monochrom> I am insightful!
00:05:50 <Makoryu> monochrom: Obj-C is Smalltalk with inline C... So yes. :p
00:06:25 <jauaor> :|
00:06:41 <lament> Makoryu: it isn't, though
00:06:51 <lament> it's C with inline smalltalk :)
00:06:59 <monochrom> haskell = hindleymilner + haskell
00:07:02 <Makoryu> lament: OR IS IT
00:07:04 <dolio> Maybe I'm just easily impressed. But that lisaac example looks like somewhat ugly ruby with a lot of variable/type declarations. And it performs on par with C. That seems impressive to me.
00:07:14 <Makoryu> monochrom: Can't construct infinite type etc.!
00:07:30 <monochrom> Don't worry, haskell is lazy, and that (+) is lazy too!
00:07:32 <dolio> In fact, it uses more smalltalk-isms than the ruby entry does, even.
00:07:49 <jauaor> dolio: they focus a lot in optimization
00:07:57 <jauaor> for the current implementation
00:08:52 <jauaor> the current implementation ... mm.. well, the one I tested a few months ago, translate from lisaac to plain c
00:09:00 <jauaor> it doesn't seem trivial stuff
00:09:03 <Makoryu> Say, there aren't a whole lot of C compilers written in Haskell, are there?
00:09:18 <Axman6> none that i kow of
00:09:19 <monochrom> I think there is none.
00:09:20 <copumpkin> there should be!
00:09:22 <Axman6> know*
00:09:27 <copumpkin> hcc
00:09:38 <Axman6> yeah, i have wanted to see a C compiler written in haskell
00:09:52 <jauaor> :)
00:10:05 <adh0c> I think that's just mental masturbation
00:10:23 <nlogax> .·o( fap fap.. )
00:12:27 <Makoryu> adh0c: True in the sense that the Sepples competition (clang/LLVM) has an enormous head start. And yet....
00:45:05 <copumpkin> *crickets*
00:45:14 <Elly> I hear crickets outside!
00:45:29 <Elly> it is a welcome change from emergency services
00:48:22 <copumpkin> I actually just hear rain
00:48:28 <copumpkin> which is quite nice :)
00:49:33 <Elly> ahh, life in the city
01:10:16 <ezyang> Anyone up during this ungodly hour?
01:11:26 <nlogax> it's 10:11 here, you timezone-insensitive clod!
01:11:51 <ezyang> 10:11 is pretty ungodly, at least for college students :-P
01:12:06 <nlogax> :D
01:12:08 <ezyang> Anyway, the question is, if I have a command line Haskell application, what's the standard way of doing a fatal error?
01:12:19 <ezyang> in Python, I would have just thrown an uncaught exception
01:12:42 <Twey> error if it's truly impossible (reflects a bug in your program)
01:12:55 <Twey> Otherwise, throw an exception
01:13:04 <ezyang> ... wait, Haskell has those? ^_^
01:13:22 <Twey> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
01:13:45 <ezyang> excellent
01:15:54 <Twey> Some monads have them
01:16:31 <nlogax> the dreaded OutOfCheese error..
01:18:33 <ezyang> Division By Cucumber?
01:18:37 <ezyang> Please reinstall the universe.
01:20:04 <RayNbow> those are nothing compared to NeedMoreCurryException
01:25:12 <ezyang> Ok, looks like throwDyn is the "right way"
01:39:49 <maxstahl> anybody in here?
01:40:42 <maxstahl> aw nobody stays up as late as me :(.
01:45:06 <blackh> Hello!  I'm in here!  I'm in an unpopular timezone.
01:45:19 <adh0c> GMT+1 reporting in
01:45:46 <blackh> +12 over here
01:46:22 <adh0c> Marshall Islands?
01:46:39 <dibblego> nyoo zuhlund
01:46:53 <Cale> -4 here, it's 4:46 am
01:47:14 <adh0c> 10:48
01:47:23 <adh0c> which means I'm in the future, Cale
01:47:45 <mxc> i'm here
01:47:51 <blackh> dibblego: Correct.
01:48:07 <mxc> UTC +8
01:48:27 <mxc> i just bought a new cat today..
01:48:29 <adh0c> when I hear "New Zealand" I think canned beer and gigantic spiders
01:48:35 <adh0c> is that stereotype correct?
01:48:43 <mxc> came all the way from cupertino..
01:49:07 <blackh> adh0c: The first half is correct, but the second half is definitely not.  Our spiders are small.
01:49:18 <adh0c> ok then, deadly spiders
01:49:23 <blackh> adh0c
01:49:28 <blackh> ..small and harmless
01:49:35 <blackh> You're thinking of Australia
01:49:44 <adh0c> maybe I am
01:49:57 <adh0c> ok, so canned beer it is
01:50:18 <blackh> Yes, canned, definitely.
01:51:01 <dibblego> Lion Red in nyoo zuhlund
01:51:04 <blackh> mxc: I'm picking up some chicks tomorrow.  Sussex light.
01:51:32 <mxc> i was referring to osx snow leopard :(
01:51:38 <adh0c> huh?
01:51:45 <adh0c> chicks? haskell programmers?
01:51:49 <adh0c> does not compewt
01:51:52 <mxc> but, speaking of that, when i hear NZ, i think of how they dominate the annual durex surveys
01:51:53 <blackh> dibblego: Yeah, eh!
01:53:14 <blackh> ah0c: Yes, three chicks.  I will need a big light bulb because they're very small.  I have to feed them mashed grain.
01:53:28 <adh0c> oh
01:53:32 <adh0c> now everything is clear
01:53:38 <mxc> i know of one female haskell programmer, in amsterdam
01:53:41 <mxc> pretty cute too
01:53:48 <adh0c> for a while there I thought you were talking about social interaction (!)
01:53:53 <adh0c> with females(!!)
01:55:10 <mxc> female haskell programmers are great, they keep the in/out compartmentalized, the rest of their thinking is pure..
01:55:19 <blackh> mxc: Excellent.  I only know one female programmer, but she is sadly not a Haskell programmer.
01:55:22 <mxc> they're cool with being bound
01:55:26 <adh0c> dohoho
01:55:49 <mxc> ioActionWithHer >>= my bedpost
01:55:52 <therp> @ho avg
01:55:52 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
01:55:56 <therp> @hoogle avg
01:55:56 <lambdabot> No results found
01:56:00 <mxc> anyway, gotta run
01:56:12 <blackh> mxc: See ya!
01:56:12 <therp> is it really the case that no base module defines the average function?
01:56:17 <adh0c> run, mxc, run
01:56:52 <int-e> @type liftM2 (/) sum (fromIntegral . length)
01:56:53 <blackh> therp: I think that would be right.
01:56:54 <lambdabot> forall b. (Fractional b) => [b] -> b
01:57:18 <adh0c> therp, let average x = sum x / length x
01:57:53 <int-e> (or genericLength)
01:57:59 <adh0c> yes
01:58:03 <blackh> Or even ... sum x / realToFrac (length x)
01:58:57 <int-e> @pl average x = sum x / fromIntegral (length x)
01:58:58 <lambdabot> average = liftM2 (/) sum (fromIntegral . length)
01:59:10 <int-e> thought so.
01:59:18 <blackh> Oh yeah. :)
02:00:32 <paulvisschers> I'm having a weird problem with the control-monad-exception package
02:00:47 <paulvisschers> I have version 0.2 installed
02:01:33 <blackh> What's the problem?
02:02:03 <paulvisschers> it's documentation on hackage suggest that there are a bunch of instances of both MonadThrow and MonadCatch, but when I load it up in ghci, and get the information using :i, it says only a single instance exists, for IO
02:02:35 <paulvisschers> s/it's/its
02:03:09 <Cale> paulvisschers: you imported the relevant module?
02:04:09 <paulvisschers> I've imported Control.Monad.Exception.Class, they're in there
02:04:52 <int-e> paulvisschers: you need to load both the modules defining the instances and the modules defining the relevant types, I think
02:06:06 <paulvisschers> I have StateT imported, so those instances should load then right?
02:07:47 <Cale> hmm
02:07:56 <Cale> the code is definitely there anyway
02:08:09 <Cale> It's not just in the documentation
02:08:29 <Cale> There's no way to avoid having instances be exported too.
02:08:47 <Cale> So perhaps it's a problem with :info?
02:09:08 <paulvisschers> oh I think I might know what the problem is
02:10:05 <paulvisschers> I got some errors with monads-fd conflicting with mtl, so I hid the former, but that is what the package depends on, so those instances should also only work for those
02:10:45 <paulvisschers> I guess I should hide mtl and unhide monads-fd and see what happens
02:11:29 <Cale> mmm, yeah, that might be it
02:13:43 <paulvisschers> ok that worked, now I have both the IO and StateT instances
02:14:01 <paulvisschers> Cale, int-e: thanks guys
02:19:39 <Alpounet> Hi.
02:19:47 <blackh> Hello!
02:19:57 <Alpounet> Can one explain me what does 'arr' exactly do ?
02:20:31 <blackh> It lifts a Haskell function from a -> b into any kind of arrow
02:20:45 <Alpounet> how does arr do that ?
02:20:55 <Alpounet> lambdabot can't give me any hint (@src) on that :)
02:21:23 <blackh> It's defined in a type class, so the kind of arrow it gives you depends on the result type that's inferred
02:21:34 <c_wraith> :t arr
02:21:35 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
02:22:07 <Alpounet> okay
02:22:30 <Alpounet> with the simplest arrow (->), it is somehow equivalent to 'id', right ?
02:22:44 <c_wraith> @src (->) arr
02:22:45 <lambdabot> arr f = f
02:22:50 <c_wraith> looks like id to me
02:22:59 <Alpounet> heh, okay thanks :)
02:23:24 <blackh> > (arr (1+)) 5
02:23:25 <lambdabot>   6
02:23:34 <blackh> There's an example of arr doing nothing. :)
02:25:00 <Alpounet> :)
02:25:30 <c_wraith> @instances Arrow
02:25:31 <lambdabot> (->), Kleisli m
02:25:39 <c_wraith> @src Kleisli arr
02:25:39 <lambdabot> Source not found. Wrong!  You cheating scum!
02:25:58 <c_wraith> @src (Kleisli m) arr
02:25:58 <lambdabot> Source not found. My pet ferret can type better than you!
02:26:25 <c_wraith> I suppose that's what happens when lambdabot is fed sources manually
02:27:33 <Alpounet> Thanks anyway for the explanations, I'll go on on my own to figure out more things about arrows.
02:30:16 <blackh> Alpounet: I've been doing arrows too (using Yampa)
02:33:44 <thaldyron> Can anyone tell me what the error "hp2ps: prog.hp, line 141609, samples out of sequence" means?
02:34:09 <adh0c> the samples aren't in the sequence they're supposed to be?
02:34:31 <thaldyron> adh0c: well yes, but why does that happen?
02:34:48 <adh0c> how do you supply the samples?
02:34:58 <blackh> thaldyron: IIRC, this happens because it's half written a sample when it got interrupted.  The way to fix it is to edit the file and chop off the last half sample.
02:35:50 <thaldyron> adh0c: by running ./prog +RTS -sstderr -hy -p  && hp2ps -e8in -c prog.hp
02:36:05 <thaldyron> blackh: thanks I'll try that
02:36:24 <adh0c> so the samples are from a file?
02:36:40 <adh0c> if yes, make sure that it's formatted correctly
02:37:13 <adh0c> if it's some other source, make sure it won't generated improper samples
02:37:22 <adh0c> s/generated/generate/
02:37:39 <thaldyron> adh0c: yes it's from a file
02:37:49 <thaldyron> adh0c: I'll look into it
02:38:17 <adh0c> check the line 141609
02:38:31 <adh0c> maybe there's something missing
02:38:48 <adh0c> assuming you know what's supposed to be in each line
02:39:22 <thaldyron> adh0c: yep, there is as the file is only 139232 lines long...
02:39:33 <adh0c> so
02:39:43 <blackdog> anyone got a good example of working with STArrays?
02:39:43 <adh0c> the program tries to read out of file?
02:40:06 <adh0c> please ensure that the reading loop isn't doing something silly
02:40:38 <Alpounet> blackh: I'll see what Yampa is :)
02:40:42 <adh0c> assuming you can check hp2ps
02:40:42 <thaldyron> mhm, I think I've found a race condition, I'll need to check it
02:41:01 <Alpounet> Oh ok. Quite interesting.
02:44:28 <blackh> Alpounet: It looks very good for the problem I'm trying to solve (writing a video game) but I'm still experimenting with how to achieve composability nirvana.
02:45:01 <mlesniak> In the paper "Runtime Support for Multicore Haskell" (Marlow et al.) it's written that a 32bit GHC has better parallel performance than a 64 bit system. Anyone knows how big the influence is (approximately)?
02:45:44 <adh0c> 32 bit GHC performs better in parallel than 64 bit GHC?
02:45:47 <adh0c> that's odd
02:46:03 <mlesniak> The paper mentions, that ... (wait a sec)
02:47:28 <mlesniak> "...The system was running Fedora 9. Although the OS was running in 64bit mode we used 32 bit binaries for our measurements (programs compiled for 64bit tend to place more stress on the memory system and garbage collector resulting in less parallelism)..."
02:47:59 <adh0c> how did they get the "programs compiled for (...)" part?
02:48:06 <adh0c> did they actually measure it?
02:48:30 <mlesniak> That's not written there, but I assume Marlow, Peyton Jones and Singh know what they are talking about ;-)
02:48:48 <mjs22> 64 vs 32 bit can have different overhead for paging and virtual memory in the OS
02:48:49 <adh0c> maybe they do, but there's that thing called scientific rigor
02:48:55 <blackh> mlesniak: Those guys are a bunch of wallies.
02:49:24 <mlesniak> <- not competent enough to judge this
02:49:44 <mlesniak> anyhow, I'd like to try it by myself, but how can I generate 32 bit binaries on a 64 bit system?
02:49:46 <adh0c> I'm competent enough to notice lack of concrete data to back up claims
02:50:00 <adh0c> mlesniak, with a compiler?
02:50:02 <mlesniak> Installing 32 bit version does not work, lack of libraries, etc...
02:50:05 <mlesniak> adh0c, ;-)
02:50:06 <p_l> 32bit code being faster happens on PPC and MIPS, afaik
02:50:23 <mjs22> mlesniak: easy.  pass -m32 to gcc
02:50:40 <mlesniak> adh0c, I couldn't find information on how to compile ghc as 32 bit on the 64 bit system from source
02:50:42 <p_l> but that's due to increased cache/memory bandwidth use without any special changes to processing speed
02:50:59 <mlesniak> mjs22, Hmmm, what about ghc?
02:51:43 <mjs22> mlesniak: ghc calls gcc.  in fact, the fix I ran into today to make ghc happy on the new OSX was to force the -m32 flag to the compiler and assembler to force 32-bit binaries
02:52:01 <Twey> ghc *can* call gcc
02:52:01 <mlesniak> mjs22, hmm, sounds reasonable, will try this
02:52:15 <Twey> You'll probably need the deprecated -fvia-c for that to work
02:52:21 <adh0c> got to go
02:52:22 <adh0c> afk
02:52:50 <mjs22> mlesniak: I added this to the ghc command line to do it : "-opta -m32 -optc -m32 -optl -m32"
02:53:51 <mlesniak> mjs22, cool, thanks for the hint!
02:56:09 <Alpounet> what are the most used arrows ?
02:56:27 <dolio> Functions.
02:57:04 <dibblego> (->)
02:57:10 <dibblego> also, Kleisli m
02:57:24 <dolio> No one really uses Kleisli, though.
02:57:35 <dibblego> I do, but in Scala
02:58:31 <Alpounet`> Hi back.
02:58:43 <blackh> Alpounet: Yampa uses arrows to maintain two pieces of state behind the scenes.  1. Each signal function has (behind the scenes) the ability to replace itself.  2. It counts time.
02:58:46 <jiyunatori> hey there ! I got a weird error with HDBC-MySQL. When I try to access the server locally I got "Can't connect to local MySQL server through socket '' (111)" (notice the lack of socket file) but it is accessible from another computer on the network.
02:59:06 <Alpounet`> Ok. I'll have to look closer at Yampa !
02:59:16 <jiyunatori> locally, I can access the server with the "mysql" command, though.
02:59:59 <blackh> Alpounet`: It's a little difficult to follow at first, but stick with it - it's not all that bad, really.  I think it's a really good example of the kind of stuff you can do with arrows.  I can send you some examples if you want
03:01:26 <Alpounet`> hmm, I'd appreciate that, actually !
03:01:34 <blackh> I'll paste you one.
03:02:13 <Alpounet`> Thanks.
03:03:37 <blackh> Alpounet`: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3448#a3448
03:03:51 <Alpounet`> thanks blackh
03:05:41 <tibbe> dons: what's new in ghc-core-5.0?
03:07:06 <Alpounet`> blackh: yeah, that's actually the kind of code I was looking for to figure things out about arrows
03:07:50 <RayNbow> dibblego: what was unit called again in LINQ?
03:09:01 <blackh> Alpounet`: Great! The arrow syntactic sugar is not as simple as the one for monads. I used a tiny bit of it in that example. I'd be happy to explain things that I've figured out.  The official documentation for arrows is not easy to follow.
03:09:52 <dibblego> unit? you mean ()? I don't it's there
03:10:08 <Alpounet`> blackh: a good arrow tutorial, like there are for monads, would be welcome indeed :)-
03:10:09 <dibblego> or do you mean a -> m a in LINQ expressions? I don't think there is one
03:10:10 <Alpounet`> :-) *
03:10:15 <RayNbow> dibblego: I meant return
03:10:19 <dschoepe> blackh: the problem is that most of the "official documentation" are actually papers.
03:11:18 <blackh> I ended up reading the paper for the arrow syntactic sugar, because I couldn't find a good tutorial.  Alpounet`, if you can't find a good tutorial about it either, maybe I could write one.
03:11:19 <RayNbow> dibblego: hmm, then what's the minimum requirement for LINQ? SelectMany is bind...
03:11:51 <dibblego> the expressions just desugar to method calls, so depends which methods you want to use (Select is just map)
03:12:42 <Alpounet`> blackh: I think I wouldn't be the only one benefitting from it.
03:13:05 <Alpounet`> The better source I found for the moment, to learn about arrows, is the dedicated chapter in the wikibook. But still, it's too much "concise".
03:14:14 <blackh> Alpounet`: I would have benefited from the tutorial I haven't written yet. Well, I've got a couple of hours spare right now, so I might even get started.
03:14:42 <blackh> ...it would help cement my knowledge.
03:15:24 <Alpounet`> Well, many users would appreciate it !
03:16:08 <blackh> I'll give it a go!
03:17:09 <dschoepe> blackh: instead of a separate tutorial, you could also write the section about arrows in the wikibooks haskell tutorial
03:17:12 <Alpounet> I mean : we already have many abstract papers etc about arrows. I like them because I love the mathematical side of arrows. But concerning the concrete use of arrows, there isn't that much papers.
03:17:45 <blackh> dschoepe: That's a good idea. I'll see what's there already.
03:18:57 <Alpounet> Yeah, completing the wikibook looks like a good idea, since, for the moment, it's not detailed enough IMO.
03:20:27 <blackh> Well, there are two pages - Arrows and Understanding Arrows
03:20:52 <blackh> Looks like Understanding Arrows covers most of it, but not the do notation
03:26:47 <blackh> OK - here's a plan.  At the moment I don't want to spend the time trying to make the whole wikibook tutorial flow, so I think I'll start with a separate tutorial, with a view to integrating it into the wikibook later.
03:28:14 <gwern> blackh: do that and I'd give even odds you'll never integrate it into the wikibook
03:30:15 <blackh> gwern: I think I have to do it that way, because I need to put quite a lot of effort into dreaming up an example that's simple yet uses all the power of the arrow.   That'll be difficult enough without having to fit it into what's already there.
03:35:23 <Vanadium> blackh: It is a wiki, you could always try to just format your tutorial properly and then hope that someone else comes along and integrates it properly
03:35:37 <Vanadium> I mean, wiki-markup and putting it on the right page and linking it
03:36:12 <blackh> You mean, write it as a separate page and put a link with a note saying "please integrate" ?
03:36:16 <gwern> or just put it in a toplevel section on its own
03:36:17 <Eelis> given "data D = D { a :: A, b :: B, c :: C }", if i only use the "a" and "c" accessors, ghc's -Wall warns that "b" is defined but not used, even if i do occasionally pattern match on D's and use the B's that way.
03:36:33 <gwern> Eelis: try '_b'?
03:36:56 <gwern> that's the usual way of telling ghc that you're not using it, although dunno if it works inside a data
03:37:17 <Eelis> this seems like a silly warning to me, as the only ways to get rid of it i can think of are (1) to stop using record syntax and define "a" and "c" separately, or (2) to artificially use the "b" accessor in code that's really more clearly expressed as a pattern match on D.
03:37:38 <Eelis> are there nicer solutions i overlooked?
03:37:56 <Twey> Eelis: Turn off the warning.  ;)
03:37:57 <Eelis> gwern: that works. thanks. seems like an awfully compiler-specific hack though
03:38:35 <gwern> Eelis: it might be ghc specific but I'd be surprised of the other compilers didn't do it
03:38:35 <Eelis> am i the only one that thinks that particular warning is silly?
03:38:37 <Twey> Warnings are for your information only.  If you know they don't apply to you, feel free to ignore them.
03:38:43 * gwern wonders if it is in the report
03:38:53 <Vanadium> Eelis: It seems pretty silly.
03:38:56 <gwern> Eelis: why is it silly? you *aren't* using it
03:38:57 <Twey> I don't.  It's a useful warning in some situations.
03:39:19 <gwern> it's often a useful warning, IMO
03:39:20 <Saizan> Eelis: are you pattern matching using the field name? like bar D{b = foo} = ?
03:40:57 <Eelis> ok, i have no interest arguing against the establishment :)
03:40:58 <Eelis> Saizan: no
03:42:28 <dolio> It can catch typos, at least.
03:42:54 <dolio> If you write "foo :: whatever ; foo [] = something ; foom = something_else".
03:43:04 <dolio> You'll presumably get a warning that foom is unused.
03:43:19 <mmorrow> Eelis: -Wall warns about name shadowing, but with "case" i make a point to shadow names
03:43:30 <Eelis> that's a totally different case. i'm specifically talking about record field names.
03:44:39 <mmorrow> Eelis: the point is -Wall is someone's opinion, you can agree with it or not.
03:45:45 <mmorrow> it's there to tell you things that might be useful under certain circumstances
03:45:49 <Eelis> mmorrow: in my book a warning is by definition silly if there's no way to "fix" the code. but i guess in this case the leading underscore hack is the "fix"
03:46:15 <mmorrow> Eelis: an Error mean you need to "fix" your code
03:46:16 <Eelis> i don't think that's an appropriate criterion for warnings.
03:46:29 <Eelis> yep
03:46:44 <mmorrow> Eelis: then change it :)
03:46:51 <Eelis> change what? you lost me
03:47:18 <mmorrow> Eelis: submit a patch to ghc which disables and/or modifies this warning
03:48:31 <Eelis> heh, i prefer to stick to uncontroversial bugs when reporting things :) i can't be bothered to start an argument about this on a mailing list or tracker.
03:49:34 <mmorrow> Eelis: then that warning remains :)
03:50:30 <Eelis> yep, and i'll just use the leading underscore hack. no big deal.
03:50:34 <Saizan> there should be a pragma to suppress warnings in block of codes
03:50:46 <Saizan> *blocks of code
03:50:49 <mmorrow> Saizan: hmm, that could be nice
03:50:53 <Eelis> yes!
03:51:04 <mmorrow> Saizan: how would you indicate which block of code?
03:51:22 <Saizan> mmorrow: i'm not sure, maybe layout
03:51:32 <Saizan> mmorrow: or a matching pragma to close it
03:51:36 <mmorrow> Saizan: err, where would the pragma go
03:51:39 <mmorrow> ah
03:52:17 <Saizan> it could span over the next declaration
03:52:23 <mmorrow> hmm, i think i'd prefer a pragma to *enable* warning for a block of code
03:52:43 <Vanadium> { use warnings; ... } ?
03:52:47 <mmorrow> because i feel like when i care about warning is the exception
03:52:51 <Vanadium> Are we reduced to stealing from perl now? :V
03:53:07 <Saizan> and you should be able to suppress a specific warning at a time
03:53:25 <Saizan> Vanadium: i was stealing from Java, actually
04:02:54 <Phyx-> Are we stealing now?
04:02:55 <Phyx-> :O
04:03:45 <endojelly> didn't we somehow steal from ML? 8)
04:05:59 <Phyx-> endojelly: nothing has ever been proven!
04:06:19 <endojelly> Phyx-, tell that to the parents who lost their children!
04:06:25 <hhhhhh> hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
04:06:40 <Phyx-> endojelly: they died serving their language!
04:06:46 <Phyx-> hhhhhh: hello
04:06:55 <hhhhhh> hello
04:06:55 <int-e> hi^37
04:07:09 <Phyx-> >repeat "hi"
04:07:15 <Phyx-> > repeat "hi"
04:07:16 <lambdabot>   ["hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi"...
04:07:32 <endojelly> > "h" ++ repeat "i"
04:07:33 <hhhhhh> i am from algeria :D
04:07:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:07:33 <RayNbow> > cycle "hi! "
04:07:35 <lambdabot>   "hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi! hi...
04:07:38 <int-e> oh. this is #haskell. 'h':replicate 37 'i' then.
04:07:41 <endojelly> > "h" ++ repeat 'i'
04:07:42 <lambdabot>   "hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii...
04:08:43 <hhhhhh> hiiiiiiiiiii
04:09:10 <int-e> still prime.
04:09:34 <Phyx-> lol, you bums scared him off
04:11:11 <Twey> @hoogle (a, a) -> [a]
04:11:12 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
04:11:12 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
04:11:12 <lambdabot> Prelude snd :: (a, b) -> b
04:11:26 <Twey> @hoogle [a] -> (a, a)
04:11:26 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
04:11:26 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
04:11:26 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
04:11:46 <Twey> Hmph.  ☹
04:11:57 <endojelly> Twey, what were you looking for?
04:12:20 <Twey> I've often had use for a function (\(a, b) -> [a, b]) or (\[a, b] -> (a, b)]
04:12:36 <int-e> > two [1]
04:12:38 <lambdabot>   Not in scope: `two'
04:12:38 <Twey> More the latter than the former
04:12:49 <Twey> I was wondering if there was something pre-built
04:13:09 <endojelly> ah
04:13:50 <int-e> @type join (liftM2 (,))
04:13:51 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
04:14:08 <Twey> :t head . join (liftM2 (,))
04:14:09 <lambdabot> forall a2. [a2] -> (a2, a2)
04:14:36 <Twey> But that's almost as long as the lambda version :þ
04:15:40 <dolio> :t join (,) . head
04:15:41 <lambdabot> forall a. [a] -> (a, a)
04:15:50 <EvilTerran> > uncurry ((++) `on` pure) (x,y)
04:15:51 <lambdabot>   [x,y]
04:16:49 <int-e> Twey: and it doesn't do what you want
04:17:04 <Twey> Really¿
04:17:06 <Twey> ?**
04:17:07 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
04:17:16 <Twey> Gack
04:17:25 <int-e> > head . join (liftM2 (,)) $ [1,2]
04:17:26 <lambdabot>   (1,1)
04:17:32 <Twey> Oh, drat
04:17:33 <int-e> > (!! 1) . join (liftM2 (,)) $ [1,2]
04:17:34 <lambdabot>   (1,2)
04:17:43 <Twey> Ah
04:17:45 <int-e> > (!! 1) . join (liftM2 (,)) $ [1,2,3]
04:17:46 <lambdabot>   (1,2)
04:18:08 <Twey> > join (liftM2 (,)) $ [1..5]
04:18:09 <EvilTerran> > foldr (curry $ second fst) undefined [x,y]
04:18:10 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
04:18:11 <lambdabot>   (x,y)
04:18:12 <EvilTerran> :D
04:18:22 <Twey> Ah, interesting
04:18:28 <int-e> Twey: I was reimplementing 'two'.
04:18:35 <Twey> *nod*
04:19:08 * EvilTerran is cogolfing
04:19:41 <dolio> Cogolfing?
04:19:52 <int-e> > liftM2 (,) (!!0) (!!1) [x,y]
04:19:54 <lambdabot>   (x,y)
04:20:02 <EvilTerran> > (head &&& (!!1)) [x,y]
04:20:03 <lambdabot>   (x,y)
04:20:06 <dolio> > id id id id id id id id id id id id id id foldr (curry $ id id id id id id second fst) undefined [x,y]
04:20:07 <lambdabot>   (x,y)
04:20:10 <EvilTerran> dolio, not going for short, going for interesting
04:20:25 <ikeg> dolio: nice shot
04:20:47 <EvilTerran> liftM2 (,) = (&&&) -- for the right instances of Monad and Arrow
04:21:25 <mmorrow> , (length . filter (reverse "alia" `isPrefixOf`) . fmap reverse) dict
04:21:33 <lunabot>  Killed.
04:21:34 <mmorrow> , (length . filter (reverse "alia" `isPrefixOf`) . fmap reverse) dict
04:21:39 <lunabot>  227
04:21:50 <EvilTerran> , [$ty| dict |]
04:21:53 <lunabot>  [] String
04:22:02 <EvilTerran> , dict
04:22:04 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
04:22:09 <EvilTerran> hm
04:22:10 <mmorrow> it's /usr/share/dict/words, mmapped from a file
04:22:14 <EvilTerran> ahh
04:22:24 <mmorrow> to a bytestring, then words and unpacked
04:22:52 <int-e> > filter (('a'==) . head) dict
04:22:53 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8803 :)
04:22:54 <lambdabot>   Not in scope: `dict'
04:22:58 <int-e> , filter (('a'==) . head) dict
04:23:00 <lunabot>  ["a","a'","a-","a.","a1","aa","aaa","aah","aahed","aahing","aahs","aal","...
04:23:10 <Twey> , length $ filter ("alia" `isPrefixOf`) dict
04:23:14 <lunabot>  6
04:23:16 <mmorrow> , sort . reverse . fmap reverse $ dict
04:23:21 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:23:21 * Twey scratches his head.
04:23:23 <Twey> Oh
04:23:28 <mmorrow> , sort . fmap reverse $ dict
04:23:29 <Twey> , length $ filter ("alia" `isSuffixOf`) dict
04:23:32 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:23:33 <lunabot>  227
04:23:38 <Twey> That's the one
04:23:40 <mmorrow> , sort $ dict
04:23:45 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
04:24:05 <mmorrow> i'm amazed that that makes it
04:24:41 <Twey> Laziness FTW?
04:25:00 <int-e> , sortBy (compare `on` reverse) dict
04:25:04 <lunabot>  ["hee-hee!","he-he!","M'","O'","a'","ca'","ha'","wa'","d'","chef-d'","Mac...
04:25:13 <mmorrow> it has to load this 14MB (stripped) prog, compile to bytecode, execute the bytecode, mmap this many MB file, do ByteString.words, do fmap ByteString.unpack, then sort
04:25:16 <int-e> slower, but better memory-wise.
04:25:26 <Twey> , indexOf "'mid" dict
04:25:27 <lunabot>  luna: Not in scope: `indexOf'
04:25:40 <mmorrow> , elemIndex "Kilimanjaro" dict
04:25:43 <lunabot>  Just 211337
04:25:47 <Twey> Oh, that's the one
04:25:53 <Twey> , elemIndex "'mid" dict
04:25:55 <lunabot>  Just 242949
04:25:57 <Twey> Huh.
04:26:00 <mmorrow> , elemIndex "calesthenics" dict
04:26:04 <lunabot>  Nothing
04:26:09 <mmorrow> spelling?
04:26:15 <int-e> , ap elemIndex last dict
04:26:16 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [[a]]
04:26:17 <Twey> , elemIndex "calaesthenics" dict
04:26:21 <lunabot>  Nothing
04:26:23 <Twey> , elemIndex "calæsthenics" dict
04:26:26 <lunabot>  Nothing
04:26:36 <Twey> Oh
04:26:39 <Twey> , elemIndex "calisthenics" dict
04:26:42 <lunabot>  Just 58664
04:26:42 <Twey> Apparently
04:26:49 <mmorrow> wut
04:26:58 <Twey> Not as Greek as it looks :þ
04:27:17 <mmorrow> wow, it is with an "i"
04:27:22 <Twey> Yeah
04:27:23 <int-e> , ap (flip elemIndex) last dict
04:27:26 <Twey> Surprising
04:27:26 <lunabot>  Just 479829
04:27:41 <mmorrow> , length dict
04:27:43 <lunabot>  479830
04:27:56 <mmorrow> , (length . filter (reverse "tion" `isPrefixOf`) . fmap reverse) dict
04:28:00 <lunabot>  7827
04:28:05 <int-e> most inefficient and unreliable, approximate implementation of length. ;)
04:28:11 <mmorrow> heh
04:28:45 <dolio> @type isSuffixOf
04:28:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
04:30:21 <mmorrow> [23:21] <mmorrow> bah, Real Programmers reverse
04:30:28 <mmorrow> :)
04:30:40 <Twey> Haha
04:30:55 <mmorrow> @src isSuffixOf
04:30:55 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
04:30:56 <Twey> A Real Programmer would express that as an unfold.
04:32:20 <mmorrow> , elemIndex "Ariadne" dict
04:32:22 <lunabot>  Just 24404
04:32:32 <mmorrow> /usr/share/dict/words has some random stuff in it
04:32:43 <mmorrow> , elemIndex "boogy" dict
04:32:45 <lunabot>  Just 48437
04:32:55 <Vanadium> @type dict
04:32:57 <lambdabot> Not in scope: `dict'
04:36:23 <mmorrow> , elemIndex "bogart" dict
04:36:25 <lunabot>  Just 47429
04:37:49 <mmorrow> , elemIndex "scram" dict
04:37:52 <lunabot>  Just 361947
04:39:15 <EnglishGent> hello all :)
04:39:43 <endojelly> , elemIndex "soxx" dict
04:39:46 <lunabot>  Nothing
04:39:51 <endojelly> , elemIndex "remy" dict
04:39:54 <lunabot>  Nothing
04:40:05 <mmorrow> , elemIndex "mire" dict
04:40:08 <lunabot>  Just 245054
04:41:21 <mmorrow> , elemIndex "triskaidekaphobia" dict
04:41:24 <lunabot>  Just 427124
04:41:34 <p_l> lol triskaidekaphobia xD
04:41:49 <mmorrow> , elemIndex "agoraphobia" dict
04:41:51 <lunabot>  Just 7564
04:44:28 <mmorrow> , elemIndex "tron" dict
04:44:31 <lunabot>  Just 427677
04:45:11 <mmorrow> all we need is a synonym graph for a thesaurus
04:46:29 <Vanadium> Does the ST monad predate monads?
04:47:44 <mauke> monads predate haskell
04:48:19 <Vanadium> The discovery of monads, then. And the naming of >>=.
04:48:51 <mmorrow> , elemIndex "monad" dict {- !!! -}
04:48:54 <lunabot>  Just 248574
04:49:27 <mauke> , dict !! 248575
04:49:29 <lunabot>  "monadal"
04:49:36 <Vanadium> , elemIndex ">>=" dict
04:49:36 <Phyx-> , head dict
04:49:38 <lunabot>  "1080"
04:49:39 <lunabot>  Nothing
04:49:52 <Phyx-> , head dict
04:49:54 <lunabot>  "1080"
04:49:57 <Phyx-> hm?
04:50:17 <Phyx-> , take 3 dict
04:50:19 <lunabot>  ["1080","10-point","10th"]
04:50:21 <mmorrow> Phyx-: /usr/share/dict/words
04:50:57 <Phyx-> mmorrow: ok.. what does that usually contain? random words?
04:51:00 <mmorrow> , drop 248573 dict
04:51:02 <lunabot>  ["monactinellidan","monad","monadal","monadelph","Monadelphia","monadelph...
04:51:07 <|randomwords|> You called?
04:51:09 <mmorrow> Phyx-: "all" english words
04:51:13 <Phyx-> oh
04:51:33 <mauke> , elemIndex "vorpal" dict
04:51:34 <Phyx-> , elemIndex "Google" dict
04:51:37 <lunabot>  Just 462994
04:51:37 <lunabot>  Nothing
04:51:55 <mauke> , elemIndex "cromulent" dict
04:51:58 <lunabot>  Nothing
04:52:17 <mmorrow> , elemIndex "gangrene" dict
04:52:20 <lunabot>  Just 155386
04:52:50 * mmorrow makes a note to add ">>=" and "cromulent" to this words.txt
04:52:52 <Phyx-> wasn't "Google" accepted into the english dictionary?
04:52:56 <mauke> > filter ("oog" `isInfixOf`) dict
04:52:57 <lambdabot>   Not in scope: `dict'
04:53:00 <mauke> , filter ("oog" `isInfixOf`) dict
04:53:04 <lunabot>  ["boogaloo","booger","boogerman","boogers","boogeyman","boogeymen","boogi...
04:53:17 <mauke> , filter ("oogl" `isInfixOf`) dict
04:53:21 <lunabot>  ["googlies","googly","googly-eyed","ooglea","oogloea","pseudozoogloeal","...
04:53:21 <mmorrow> boogerman?!
04:53:32 <mauke> video game
04:53:42 <mauke> and possibly a comic
04:53:43 <hackagebot> hfractal 0.2.0 - OpenGL fractal renderer (ChrisHoldsworth)
04:53:46 <mmorrow> @remember words pseudozoogloeal
04:53:46 <lambdabot> Done.
04:53:53 <skorpan> , filter ("eniz" `isInfixOf`) dict
04:53:57 <lunabot>  ["adenization","agenize","agenized","agenizes","agenizing","Albeniz","alb...
04:54:22 <Vanadium> < lunabot>  ["monactinellidan","monad","monadal","monadelph","Monadelphia","monadelph.. <- Totally moving to Monadelphia
04:54:53 <mauke> @dict monadelphia
04:54:54 <lambdabot> Supported dictionary-lookup commands:
04:54:54 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
04:54:54 <lambdabot> Use "dict-help [cmd...]" for more.
04:55:24 <Phyx-> , filter ("oob" `isPostfixOf`) dict
04:55:25 <lunabot>  luna: Not in scope: `isPostfixOf'
04:55:33 <Phyx-> @hoogle postfix
04:55:33 <lambdabot> Text.Parsec.Expr Postfix :: ParsecT s u m (a -> a) -> Operator s u m a
04:55:47 <mmorrow> suff
04:56:01 <EnglishGent> a quick question - I'm writing my first real Haskell program (to do something useful) woo! - is there a way to put the equivalent of debugging printfs in the code? I'm guessing something using unsafePerformIO
04:56:15 <|randomwords|> debug.trace
04:56:17 <EnglishGent> my program is actually fidling with my file-system.. so i'd like to be sure it works! :)
04:56:31 <mmorrow> @hoogle trace
04:56:31 <lambdabot> Debug.Trace trace :: String -> a -> a
04:56:31 <lambdabot> module Debug.Trace
04:56:31 <lambdabot> package traced
04:57:01 <Phyx-> , let isPostfixOf =reverse.isPrefixOf in filter ("oob" `isPostfixOf`) dict
04:57:02 <lunabot>  luna: Couldn't match expected type `[a]'
04:57:11 <EnglishGent> ah - is there documentation on the Debyg package somewhere? I didnt know one existed
04:57:14 <mmorrow> @type isSuffixOf
04:57:15 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
04:57:18 * EnglishGent thinks he should perhaps take a look
04:57:23 <EnglishGent> oh - and ty mmorrow :)
04:57:28 <Phyx-> EnglishGent: yes, look at hoogle
04:57:31 <pr> 1/win 22
04:57:34 <pr> oops!
04:57:40 <Phyx-> @index Debug
04:57:40 <lambdabot> Network.Socket
04:58:05 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
04:58:13 <Phyx-> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
04:58:16 <Phyx-> oops
04:58:20 <Phyx-> mauke: beat me to it
04:58:47 <Phyx-> , filter ("oob" `isSuffixOf`) dict
04:58:52 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:58:59 <Phyx-> :P
04:59:05 <mmorrow> , filter ("oob" `isSuffixOf`) dict
04:59:10 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:59:18 <mmorrow> :(
04:59:21 <skorpan> can an infix also be a prefix/suffix?
04:59:57 <Phyx-> :t isPrefixOf.reverse
04:59:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
04:59:58 <pr>  > "foo" `isInfixOf` "foobar
04:59:59 <pr>  > "foo" `isInfixOf` "foobar"
05:00:14 <pr> > "foo" `isInfixOf` "foobar"
05:00:15 <lambdabot>   True
05:00:24 <Phyx-> , let isPostfixOf =reverse.isPrefixOf in filter ("oob" `isPostfixOf`) dict
05:00:24 <lunabot>  Killed.
05:00:30 <mmorrow> it's building
05:00:30 <mauke> > "x" `isInfixOf` "x"
05:00:31 <lambdabot>   True
05:00:37 <mmorrow> , filter ("oob" `isSuffixOf`) dict
05:00:37 <Phyx-> , let isPostfixOf =reverse.isPrefixOf in filter ("oob" `isPostfixOf`) dict
05:00:38 <lunabot>  luna: Couldn't match expected type `[a]'
05:00:41 <lunabot>  Killed.
05:00:42 <Phyx-> wtf
05:00:47 <mmorrow> , filter ("oob" `isSuffixOf`) dict
05:00:54 <lunabot>  Killed.
05:00:58 <Phyx-> why the type error luna
05:01:03 <mmorrow> wow, that must take a crapload of memory
05:01:05 <pr> Phyx-: reverse.isPrefixOf
05:01:06 <poe> , foldr (/) 1 . map fromIntegral . catMaybes . map (`elemIndex` dict) . words $ "post-Christmas deadheads"
05:01:08 <lunabot>  3.1415926536189365
05:01:09 <mmorrow> i just upped the rlimits
05:01:11 <pr> @type isPrefixOf
05:01:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:01:13 <pr> @type reverse
05:01:14 <lambdabot> forall a. [a] -> [a]
05:01:18 <EnglishGent> thanks :)
05:01:19 <Phyx-> ah
05:01:20 <Phyx-> yes
05:01:22 <Phyx-> typo pr
05:01:23 <Phyx-> :)
05:01:24 <skorpan> isPrefixOf . reverse then?
05:01:25 <pr> :)
05:01:38 <Phyx-> , let isPostfixOf =isPrefixOf.reverse in filter ("oob" `isPostfixOf`) dict
05:01:40 <int-e> isPrefixOg `on` reverse
05:01:40 <lunabot>  ["boo","boob","boobed","boobery","boobialla","boobie","boobies","boobily"...
05:01:44 <int-e> *Of
05:01:46 <Phyx-> yay
05:01:47 <mmorrow> , (length . filter (reverse "tion" `isPrefixOf`) . fmap reverse) dict
05:01:52 <lunabot>  7827
05:01:53 <Phyx-> hmmm wtf does isSuffixOf do then
05:01:54 <mauke> @check join isInfixOf
05:01:55 <lambdabot>   "OK, passed 500 tests."
05:01:59 <Phyx-> @src isSufficOf
05:02:00 <lambdabot> Source not found.
05:02:08 <mmorrow> , (length . filter (reverse "oob" `isPrefixOf`) . fmap reverse) dict
05:02:09 <Phyx-> @src isSuffixOf
05:02:09 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
05:02:13 <lunabot>  5
05:02:15 <skorpan> , filter ("agina" `isPostfixOf`) dict
05:02:16 <lunabot>  luna: Not in scope: `isPostfixOf'
05:02:19 <int-e> , let isPostfixOf = isPrefixOf `on` reverse in filter ("oob"  `isPostfixOf`) dict
05:02:24 <lunabot>  Killed.
05:02:31 <skorpan> , let isPostfixOf = isPrefixOf . reverse in filter ("agina" `isPostfixOf`) dict
05:02:34 <lunabot>  []
05:02:45 <int-e> you have to reverse both arguments
05:02:53 <Phyx-> yup
05:03:13 <Phyx-> but, i was aiming for "boob" so "oob" was an ambigram
05:03:14 <Phyx-> :P
05:03:27 <Phyx-> errr, or what ever the word is
05:03:58 <int-e> , sortBy (comparing sort) dict
05:03:59 <lunabot>  luna: Not in scope: `comparing'
05:04:05 <int-e> , sortBy (compare `on` sort) dict
05:04:11 <lunabot>  Killed.
05:04:14 <int-e> :-(
05:04:15 <mmorrow> heh
05:04:18 <Phyx-> , take 1 $ sort dict
05:04:22 <lunabot>  ["&c"]
05:04:25 <int-e> , sortBy (compare `on` sort) (take 1000 dict)
05:04:27 <lunabot>  ["Aaron's-beard","A'asia","a'","2,4,5-t","2,4-d","Abd-el-Kadir","Abd-el-K...
05:04:41 <Phyx-> :t compare `on` sort
05:04:42 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
05:04:46 <Phyx-> hmm
05:04:48 <Phyx-> :t sort
05:04:50 <lambdabot> forall a. (Ord a) => [a] -> [a]
05:04:52 <Phyx-> :t compare
05:04:53 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:04:59 <Phyx-> oh, nice
05:04:59 <mmorrow> , sortBy (compare `on` sort) (take 100000 dict)
05:05:02 <lunabot>  ["A&M","A&P","AT&T","&c","ca'-thro'","ar'n't","bo's'n","cat-o'-nine-tails...
05:05:53 <mmorrow> wtf is "bo's'n"
05:06:07 <|randomwords|> ghetto boson?
05:06:17 <mmorrow> ahh, of course
05:06:24 <Phyx-> what's a boson?
05:06:31 <mmorrow> @go boson
05:06:33 <int-e> > groupBy ((==) `on` sort) . sortBy (compare `on` sort) $ ["alabama", "hits", "lager", "banana", "regal", "this"]
05:06:34 <lambdabot> http://www.boson.com/
05:06:34 <lambdabot> Title: Boson: Cisco Network Simulators, Practice Exams, Instructor Led Training
05:06:34 <lambdabot>   [["alabama"],["banana"],["lager","regal"],["hits","this"]]
05:06:48 <mmorrow> @oed boson
05:06:48 <lambdabot> Maybe you meant: bid id let oeis read redo
05:07:04 <mmorrow> an elementary particle
05:07:18 <int-e> @oed fermion
05:07:18 <lambdabot> Maybe you meant: bid id let oeis read redo
05:07:29 <|randomwords|> @oed electron
05:07:29 <lambdabot> Maybe you meant: bid id let oeis read redo
05:07:32 <int-e> oh. wait, it's correcting the command :/
05:07:41 <|randomwords|> ah
05:07:51 <mmorrow> i forget the dictionary cmd
05:08:02 <int-e> @dict height
05:08:02 <lambdabot> Supported dictionary-lookup commands:
05:08:02 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
05:08:02 <lambdabot> Use "dict-help [cmd...]" for more.
05:08:17 <mmorrow> @web1913 boson
05:08:20 <lambdabot> *** "Boson" web1913 "Webster's Revised Unabridged Dictionary (1913)"
05:08:20 <lambdabot> Boson \Bo"son\ (b[=o]"s'n), n.
05:08:20 <lambdabot>    See {Boatswain}. [Obs.] --Dryden.
05:08:31 <Phyx-> i needa find a way to get to bed before 6am... damn insomnia...
05:08:32 <mmorrow> guess bosons weren't discovered yet
05:08:40 <Phyx-> counting haskell functions doesn't help anymore
05:08:42 <Phyx-> :|
05:09:10 <int-e> http://xkcd.com/571/
05:09:29 <Vanadium> id, id . id, id . id . id, id . id . id . id, id . id . id . oh god there are way too many haskell functions
05:09:55 <int-e> Phyx-: or perhaps it's better this way: http://countyoursheep.keenspot.com/d/20030611.html
05:10:12 <int-e> > iterate id "sleep"
05:10:13 <lambdabot>   ["sleep","sleep","sleep","sleep","sleep","sleep","sleep","sleep","sleep","s...
05:10:43 <int-e> > cycle (sequence ["s","lh","e","e","p"])
05:10:45 <lambdabot>   ["sleep","sheep","sleep","sheep","sleep","sheep","sleep","sheep","sleep","s...
05:10:54 <Phyx-> int-e: hahhah, i wish that helped
05:11:08 <Phyx-> unfortunately, when i try. the sheeps i think of, always end up insulting me :|
05:12:18 <malosh> Hi. Did someone ever managed to run ghc on a playstation 3 ?
05:13:07 <p_l> malosh: if GHC works on linux running on G5 macs, then it should work on Playstation 3 as well
05:13:42 <Phyx-> hasn't sony removed the "other os" option?
05:13:51 <malosh> Yes, but I'd like to know if it had been _actually_ done, and also if the parallel features of the cell are usable from haskell
05:14:10 <p_l> Phyx-: I don't think so, the "other os" option seemed to be used in their SDK
05:14:29 <Phyx-> p_l: well, widespread reports are, that the PS3 slim no longer has it
05:14:31 <malosh> Phyx- : you mean that http://www.playstation.com/ps3-openplatform/index.html is obsolete ?
05:14:49 <p_l> malosh: a little bit of FFI should allow to control SPUs, but you need a code generator for it
05:15:30 <Phyx-> malosh: yes, that
05:15:57 <p_l> malosh: also, if you are more interested in practical use, why not grab a Cell-powered computer instead of PS3?
05:16:25 <Phyx-> they sell the sell processor?
05:16:33 <Phyx-> outside of a ps3 i mean
05:17:32 <p_l> Phyx-: ... of course, PS3 gets leftovers
05:17:47 <malosh> because if I can use my cell cpu also for the cool graphics on ps3 games, that'd be cool
05:17:48 <Phyx-> really? i thought cell was designed for the ps3
05:18:05 <p_l> malosh: you won't get "cool graphics"
05:18:25 <p_l> malosh: one of the spus is running a hypervisor that locks out access to graphics chip
05:18:52 <malosh> Phyx- : wikipedia says the "other os" option was removed with the introduction of ps3 "slim". You're right, I won't buy one !
05:20:26 <p_l> Phyx-: Sony might have worked together with IBM on Cell, but PS3 only uses the oldest model and afaik usually gets the damaged ones (which have one SPU not passing tests, and thus disabled)
05:21:01 <Phyx-> i don't get it, why would sony want a damaged cpu
05:21:59 <p_l> Phyx-: because they want quantity, not quality? :D They needed lower prices, and Cell, especially in beginning, was very expensive to manufacture causing flaws in produced units
05:22:20 <Phyx-> what kind of flaws
05:23:01 <p_l> Phyx-: basically, quite often some of the SPUs were damaged. The ones that had only one SPU damaged had it disabled and shipped to Sony
05:23:17 <p_l> also, IBM machines use a newer, faster variant of Cell
05:23:59 <Phyx-> mkay
05:24:31 <p_l> not to mention that those machines don't suck at I/O :>
05:25:25 <p_l> my friend used his PS3 for some numerical computation, I recall that he complained about I/O performance
05:25:50 <p_l> (he needed to shuffle data around a lot due to small amount of memory and disk wasn't fast enough)
05:27:26 <etpace_> > sequence ["f", "o", "o"]
05:27:28 <lambdabot>   ["foo"]
05:27:34 <skorpan> :t sequence
05:27:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:27:40 <skorpan> what the hell?
05:27:50 <skorpan> oh, the list monad?
05:27:52 <skorpan> [Char]?
05:27:55 <etpace_> looks like it
05:28:16 <jethr0> hi, how do I change the type of a CFloat to a Float
05:28:37 <twanvl> realToFrac
05:28:39 <Phyx-> @hoogle CFloat -> Float
05:28:39 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
05:28:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:28:39 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
05:28:44 <jethr0> thx
05:30:32 <Phyx-> @hoogle Float -> CFloat
05:30:33 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
05:30:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:30:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:31:09 <Phyx-> hmm how do you go the other way around?
05:31:14 <Phyx-> Float -> CFloat
05:32:26 <Phyx-> > let foo = unsafeCoerce :: Float -> CFloat in foo 5.0
05:32:27 <lambdabot>   Not in scope: type constructor or class `CFloat'Not in scope: `unsafeCoerce'
05:32:55 <mauke> Phyx-: realToFrac
05:33:07 <benmachine> @index CFloat
05:33:08 <lambdabot> Foreign.C.Types, Foreign.C
05:33:17 <Phyx-> mauke: that does both ways?
05:33:32 <mauke> and more!
05:33:37 <Phyx-> ooohh
05:33:53 <benmachine> they both have a Real instance and a Fractional instanec
05:33:54 <Phyx-> would that do CInt <-> Int aswell?
05:33:55 <benmachine> ce
05:34:00 <mauke> Phyx-: fromIntegral
05:34:03 <Phyx-> ofcourse now. Fractional
05:34:04 <Phyx-> hehe
05:34:18 <benmachine> Int is not Fractional
05:34:19 <Phyx-> mauke: ah, thanks, i was using unsafeCoerce
05:34:23 <mauke> ...
05:34:28 <mauke> you're crazy
05:34:30 <Phyx-> benmachine: lol, i said that :P
05:34:40 <Phyx-> mauke: i've been told that before, :P
05:35:48 <Phyx-> @index CBool
05:35:48 <lambdabot> bzzt
05:35:51 <Phyx-> ah ok
05:36:23 * Phyx- makes a cabal file to test his library
05:44:53 <jethr0> has anyone managed to get hSDL to run on Mac OS?
05:46:36 <Alpounet> SDL does, so hSDL should.
05:47:00 <jethr0> hmm, a fried of mine has problems building hSDL with cabal...
05:47:10 <jethr0> which SDL did you use? Darwin Ports?
05:50:59 <mmmulani> do any mutable lists exist for haskell?
05:52:09 <int-e> non-serious answer: Control.Concurrent.Chan
05:52:27 <int-e> mmmulani: what do you want to do with them?
05:52:55 <int-e> maybe Data.Sequence fits your purposes?
05:57:14 <Lemmih> jethr0: It's tricky but possible.
05:57:38 <Phyx-> @google cabal file specification
05:57:39 <lambdabot> No Result Found.
05:57:45 <Phyx-> @google cabal file
05:57:47 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Packaging
06:00:18 <mmmulani> int-e: hmm, that may actually work
06:00:37 <mmmulani> int-e: hoping to memoize a function but the input values of kind of random Integers
06:00:38 <jethr0> Lemmih: hmm, there is mention of a file "Core/Examples/Test.hs" which should contain an example of how to initialize SDL under MacOs. any idea where i can find that file?
06:00:49 <Lemmih> jethr0: No, sorry.
06:00:56 <jethr0> *grmf*
06:01:01 <EvilTerran> mmmulani, are the inputs in a finite range?
06:01:31 <Lemmih> jethr0: You could try mailing the guy who added that example.
06:01:35 <EvilTerran> mmmulani, the normal way of memoising in haskell is not to use mutable structures, but to use a lazy structure
06:01:46 <int-e> mmmulani: oh. you can build a trie for that. the MemoTrie package does that.
06:02:02 <mmmulani> EvilTerran: mostly finite. I tried using lists but the memory use was ridiculous
06:02:05 <mmmulani> int-e: ouu, will look at that
06:03:08 <EvilTerran> mmmulani, if, say, your inputs are all going to be in the range [0..n], you could make an array with indices [0..n] and values map f [0..n]
06:03:17 <mmmulani> oh true
06:03:21 <mmmulani> hmmm
06:03:26 <EvilTerran> none of the values would be forced until you needed them
06:03:59 <EvilTerran> but, once a value gets forced, it won't be calculated again the next time you pull it out of the array
06:04:21 <EvilTerran> and Data.Array has O(1) indexing :)
06:05:23 <int-e> mmmulani: or if you want something self-contained, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8812#a8812
06:05:31 <EvilTerran> mmmulani, you can do a similar trick if the inputs could be arbitrary integers, but it's a bit more involved; the MemoTrie package does the work for you for that sort of thing, iirc
06:05:48 * int-e should publish his own memoizing trie code some time.
06:06:40 * EvilTerran should publish his "logarithmic lists" some time
06:07:41 <int-e> yes, that's nice if the used arguments are in a small range and dense.
06:07:47 <EvilTerran> (basically, a list of arrays, with the arrays of lengths "map (2^) [0..]", so you have O(log n) indexing but can have infinite domain ('cos of laziness))
06:08:04 <mmmulani> ahahaah
06:08:28 <int-e> EvilTerran: I've discovered that idea at some point, too :)
06:08:42 <int-e> (I'm sure there are many others)
06:14:19 <hackagebot> agum 2.0 - Unification and Matching in an Abelian Group (JohnRamsdell)
06:40:40 <path[l]_> whats the difference between an unboxed and a boxed array
06:41:24 <Taejo> path[l]_: a boxed array is represented as an array of pointers to values on the heap
06:41:40 <Phyx-> Warning: WinDll.cabal: Unknown fields: hs-source-dirs (line 24) <-- is that no longer allowed? I'm getting an error Setup: Error: Could not find module: WinDll.Converter with any suffix: ["hi"]
06:41:50 <Taejo> with the usual representation of objects (i.e., as thunks)
06:41:58 <path[l]_> ok
06:42:02 <Taejo> whereas unboxed arrays contain the values themselves
06:42:30 <path[l]_> so an unboxed array is of fixed size too?
06:42:39 <path[l]_> is an unboxed array faster then?
06:42:45 <path[l]_> to access
06:42:53 <Taejo> yeah, they should be
06:43:02 <Taejo> any array type has fixed size
06:43:22 <path[l]_> hmm
06:43:25 <path[l]_> ok
06:43:57 <path[l]_> I had a code I ported from ruby to haskell and I only got a 30% improvement. dons suggested I try using an unboxed array to see how much it would help
06:44:03 <path[l]_> let me try that then
06:45:30 <Phyx-> hmm why can't cabal find my modules..
06:46:41 <Lemmih> Phyx-: Did you tell it where to look?
06:47:11 <Phyx-> Lemmih: i'm trying to figure out how to tell it that
06:47:21 <Phyx-> i though Hs-Source-Dirs: WinDll would do
06:48:04 <Lemmih> Phyx-: What did you name your modules?
06:48:21 <Phyx-> WinDll.Converter, WinDll.Identifier, WinDll.NativeMapping,
06:48:23 <Phyx-> wtc
06:49:02 <chessguy> edwardk:  ping?
06:49:10 <Lemmih> Phyx-: Then you shouldn't change the hs-source-dirs.
06:49:32 <Phyx-> Lemmih: same error
06:49:35 <Lemmih> Phyx-: GHC will look for WinDll.Converter in WinDll/Converter.hs
06:49:43 <Phyx-> yeah, it's there
06:49:50 <Phyx-> but it won't find it :|
06:50:28 <Phyx-> Lemmih: http://phyx.pastebin.com/m68b414ec is my whole cabal file
06:51:27 <Lemmih> Phyx-: And what happens when you run cabal?
06:51:45 <Phyx-> Setup: Error: Could not find module: WinDll.Converter with any suffix: ["hi"]
06:52:02 <Lemmih> Phyx-: Did you build the project?
06:52:06 <chessguy> somewhat off-topic, but has anyone seen a nice zipper implementation in c#?
06:52:20 <Phyx-> Lemmih: arrggg, sorry, i forgot :P
06:52:43 <Phyx-> wow, i should get something to eat... starvation is bad for one's ability to think
06:54:09 <Phyx-> thought you already was together
06:54:33 <path[l]_> I dont understand. Can I use listArray to create a UArray?
06:54:42 <path[l]_> its polymorphic is it?
06:55:16 <Lemmih> path[l]_: Yes.
06:55:21 <path[l]_> ah
06:55:49 <Lemmih> path[l]_: Keep in mind that only a few elements can be used in unboxed arrays.
06:55:55 <path[l]_> right
06:56:00 <path[l]_> I only need Ints though
06:56:08 <Lemmih> That should work.
06:56:15 <Lemmih> Did you import Data.Array.Unboxed?
06:56:59 <path[l]_> yeah
07:00:51 <path[l]_> ok that didnt do anything to my time
07:01:06 <path[l]_> the whole thing still takes 1.6 seconds to execute as opposed to 2.3 in ruby
07:01:13 <path[l]_> 1.7
07:04:20 <EnglishGent> @hoogle (x -> IO y) -> [x] -> IO [y]
07:04:21 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:04:21 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:04:21 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
07:04:54 <Alpounet> @instances Ord
07:04:55 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:08:32 <hackagebot> encoding 0.6.1 - A library for various character encodings (HenningGuenther)
07:20:02 <mmmulani> hmm, how would I apply Memotrie to the naive fib function?
07:20:38 <EnglishGent> @hoogle (x -> Bool) -> IO [x] -> IO [x]
07:20:39 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
07:20:39 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
07:20:39 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
07:21:11 <EnglishGent> hello mmmulani :)
07:22:58 <EnglishGent> @hoogle (x -> IO Bool) -> IO [x] -> IO [x]
07:22:59 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
07:22:59 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:22:59 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:24:01 <mmmulani> EnglishGent: hey
07:24:11 <Berengal> mmmulani, fib = memo go where go 1 = 1; go n = fib (n -1) + fib (n - 2)
07:24:36 <mmmulani> Berengal: thanks, figured it out from re-reading the documentation
07:24:42 <mmmulani> I did not expect it to be that easy
07:24:51 <EnglishGent> is there a more elegant way to do 'filter doesDirectoryExist (getDirectoryContents x)' than writing a new function with a do monad? I can see how to do the later - but if feels clumsy
07:24:57 <EnglishGent> :)
07:24:58 <Berengal> Yeah, you just have to know which is memoized and which isn't
07:25:14 <Berengal> filterM
07:27:07 <EnglishGent> @hoogle (x -> IO Bool) -> IO [x] -> IO [x]
07:27:07 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
07:27:07 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:27:07 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:28:52 <EnglishGent> why does hoogle list filterM in those results? you cant do 'filterM doesDirectoryExist (getDirectoryContents ".")' -- it's a type error
07:28:57 * EnglishGent confused now :|
07:29:22 <Berengal> EnglishGent, you can do filterM doesDirectoryExist <=< getDirectoryContents
07:29:23 <int-e> getDirectoryContents "." >>= filterM doesDirectoryExists
07:29:44 <EnglishGent> ah - thanks Berengal :)
07:30:38 <EnglishGent> what's the <=< ?
07:30:50 <Berengal> It's like (.), but for monads
07:30:58 <Berengal> @type (<=<)
07:30:59 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
07:31:13 <path[l]__> heh
07:31:27 <EnglishGent> thanks int-e as well :)
07:31:35 <EnglishGent> @type (>>=)
07:31:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:31:48 <int-e> aka Kleisli composition.
07:32:42 * EnglishGent feels he is slowly coming up to speed with Haskell (I come from a lisp background) - but much of my monadic stuff still feels clumsy generally .. I'm sure I'm naming things more often that you have to
07:33:01 <benmachine> @src (<=<)
07:33:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:33:35 <Berengal> @src (>=>)
07:33:36 <lambdabot> Source not found. I am sorry.
07:34:34 <etpace_> Hmm, I'm not sure which of Reader or State I need for this, or if either
07:34:37 * benmachine wishes there was an @src+
07:34:53 <EnglishGent> what would that do benmachine? (serious question)
07:34:55 <EnglishGent> :)
07:35:13 <Saizan> add to the source database, i guee
07:35:16 <benmachine> EnglishGent: tell lambdabot to remember something for @src
07:35:34 <Berengal> etpace_, RWS!
07:35:40 <etpace_> RWS?
07:35:46 <etpace_> reade rwith state?
07:35:46 <Berengal> Or to go completely crazym RWST IO
07:35:47 <EnglishGent> btw int-e - what's Kleisli composition? I've heard of Kleisli categories - but I dont know what they are either (yet)
07:35:55 <benmachine> reader writer state
07:35:56 <Berengal> reader-writer-state
07:36:03 * EnglishGent is trying to wade through some category theory as well... it's not the easiest subject to self-teach :|
07:36:06 <etpace_> hmm
07:36:23 <etpace_> I wonder if its easier to write it without a monad first of all, and then convert it?
07:36:36 <ski> EnglishGent : `Kleisli' converts from `Monad' to `Arrow'
07:37:13 <Berengal> @type Kleisli
07:37:14 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
07:37:21 <Berengal> @src Kleisli
07:37:22 <lambdabot> Source not found.
07:37:34 <int-e> EnglishGent: (>=>) is - the Kleisli category works with arrows of the form a -> m b where m is a monad.
07:37:34 <Saizan> etpace_: that's a quite instructive process
07:37:42 <ski>   newtype Kleisli m a b = Kleisli (a -> m b)  -- more or less
07:38:07 <ski> @kind RWH
07:38:08 <lambdabot> Not in scope: type constructor or class `RWH'
07:38:16 <int-e> (and (>=>) and (<=<) are flipped versions of each other)
07:38:22 <Saizan> RWH :: book
07:38:53 * benmachine came up with f >=> g = \a -> f a >>= g -- does that look right?
07:38:59 * Berengal isn't actually that fond of (<=<)
07:39:06 <Saizan> benmachine: yup
07:39:08 <ski> (`RWS' being "Real World State" ? :)
07:39:17 <int-e> @src IO
07:39:17 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:39:36 <int-e> close, but spelled differently :)
07:39:44 <int-e> hmm, RWS = Reader Writer State
07:40:01 <ski> Berengal :  `$' : `.' :: `=<<' : `<=<'
07:40:13 <int-e> = one monad to fit them all
07:40:35 <Berengal> ski, the last two are effectfull, or at least can be. Effects should always go from left to right
07:40:35 <ski> bah, no angelic nondeterminism
07:40:49 <ski> why ?
07:41:13 <Berengal> Because effects are linear
07:41:19 <ski> (also, i'm not sure i'd say the effects there go from right to left .. rather from inside to outside)
07:41:46 <ski> (`liftM2' and `ap' is another thing)
07:42:19 <benmachine> Berengal: I'd agree that you shouldn't make long chains with =<< but doing things like putStrLn =<< getLine can sometimes be clearer
07:42:27 * ski is not sure what "linear" means that ..
07:42:30 <Berengal> benmachine, yeah, I tend to do that myself
07:42:46 <Berengal> ski, neither am I, I just hoped it would sound fancy
07:42:49 <ski> (.. presumably it doesn't mean that effects can neither be discardable nor copyable)
07:44:07 <ski>   foo =<< (bar =<< baz)  =  (foo <=< bar) =<< baz
07:45:09 <ski>   =  foo <bar <baz>>  -- reflective syntax
07:45:18 <path[l]__> hey Berengal did you have time to look at that problem the other day?
07:45:34 * benmachine wonders which is better out of foo `fmap` bar =<< baz and foo =<< bar `fmap` baz
07:45:36 <Berengal> dur.r..
07:46:10 <EnglishGent> hmm - how about the equivalent of logical-and & or - for IO Bool -> IO Bool -> IO Bool
07:46:15 <EnglishGent> or perhaps more generally
07:46:28 <EnglishGent> @hoogle (x -> y -> z) -> IO x -> IO y -> IO z
07:46:29 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:46:29 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:46:29 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
07:46:34 <benmachine> @type liftM2 (&&)
07:46:36 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
07:46:52 <ski> Berengal : .. the point being that there's no two parallel sub-expressions whose effects could be performed in either order. one needs the results from one of them to build the next action, so there's only one order possible
07:47:31 <Berengal> ski, when doing effectful programming, sequence is important. To best display this sequence the various computations should be written in the same sequence
07:48:14 <Berengal> It'd be fine if everything was written right-to-left, bottom-to-top, but it's not
07:48:17 <ski> in this case, there's no sequence, there's a nesting
07:48:27 <EnglishGent> actually - what if you dont care about the order they are done in? I actually have real-world problems involving this (code currently in Java) - where I have 2 or more threads responsible for computing a boolean result - and all I care about is the and/or over them - so as soon as *any* thread produces an answer you can abort them all
07:49:19 <Berengal> EnglishGent, threads are magic. Besides, you do care about order, because you can't start anding the bools before they've been produced
07:49:40 <EnglishGent> yes you can - if one of them is False then the and with anything else must be false
07:50:02 <EnglishGent> so as soon as one thread produces a result of false you can stop all the others
07:50:02 <etpace_> > [(x, y) | x <- [-1..1], y <- [-1..1], x /= y]
07:50:03 <lambdabot>   [(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0)]
07:50:05 <gwern> and is lazy! who knew :)
07:50:18 <ski> (Berengal : in case it's not clear, i agree with you that sequence is important to show properly (with non-commutative effects). i'm just not sure this is a case where that applies)
07:50:49 * EnglishGent would agree that the order does make a difference in many cases! but not in the one I'm thinking of :)
07:50:55 <blackh> Alpounet:  http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
07:51:02 <Berengal> ski, monads are always nesting anyway. A ten-line long do block is ten levels deeply nested
07:51:08 <blackh> If anyone else would like to read Stephen's Arrow Tutorial and comment on it, please do
07:51:33 <gwern> blackh: if I don't understand arrows at the end can I have a refund?
07:51:35 <MisterN> Berengal: and a function call with 3 parameters is 3 levels deeply nested?
07:51:50 <ski> Berengal : yes, but `(a,b) <- liftM2 (,) ma mb' is not (properly) nesting, in that sense
07:51:56 <blackh> gwern: I tell you what. I'll refund *double* what you paid.
07:52:21 * gwern chortles. the joke is on blackh, I paid a pretty sum for this internet access!
07:52:37 <blackh> :)
07:53:19 <ski> MisterN : taken literally, yes. but there's no effect dependencies between the actuals
07:53:19 <etpace_> is there a replace nth function? (before I make a messy splitat)
07:53:25 <Alpounet> blackh: yay, thanks. I'm openin' it.
07:53:41 <gwern> @hoogle Int -> a -> [a] -> [a]
07:53:41 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:53:41 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
07:53:41 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
07:53:49 <gwern> etpace_: guess not
07:53:54 <ski> etpace_ : no. call it `(!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]'
07:53:55 <etpace_> ok, thanks
07:53:56 <int-e> etpace_: no. wanting one is usually a sign that you're using lists where, say, Data.Map would be more appropriate
07:54:01 <Berengal> ski, well, liftM2 nests it's computations internally... I don't think nesting is that important when dealing with monads anyway, it's the traversal of the resulting tree that's important, not the tree itself
07:54:41 <etpace_> I'm using lists (2d) to represent a Maze, (each 'pixel' is an element in the array)
07:54:44 <int-e> etpace_: or Data.Sequence, which has an 'adjust' function for that purpose.
07:54:47 <etpace_> is there a more appropriate data type
07:55:07 <gwern> certainly sounds like an array to me
07:55:09 <benmachine> etpace_: maybe Data.Array
07:55:24 <Berengal> ski, anyway, I like applicatives. Effects always go from left to right, even in the face of combinators like (<*)
07:55:40 <etpace_> thanks
07:55:58 <ski> Berengal : my point is that in some sense, "function call" is always after "argument evaluation". there might be different orders to perform effects amongst arguments, but the "function call" has to happen afterwards
07:56:28 <ski> Berengal : of course, this point only applies to monads. applicative functions doesn't have effectful "function calls", in this sense
07:56:36 <ski> s/functions/functors/
07:56:45 <blackh> Alpounet, gwern: Type your comments as you think of them.  Make sure you say 'blackh' or I'll miss them.
07:57:08 <gwern> blackh: alas I was just about to take a nap
07:57:39 <blackh> gwern: I'm going to sleep shortly, but my computer will stay on and collect your comments.
07:58:03 <gwern> my computer is going to sleep shortly too, but I'll stay awake and submit my comments
07:58:10 <gwern> wait that made no sense
07:58:16 * gwern needs a nap
07:58:29 <ski> (Berengal : .. the nesting i was talking about corresponds to uses of `join :: m (m a) -> m a')
07:58:53 <edwardk> chessguy: pong
08:00:15 <Alpounet> blackh: that really helps me seeing arrows more clearly
08:00:46 <blackh> Alpounet: Great! I was totally confused about arrows until recently so I haven't forgotten what it was like.
08:02:14 <ski> edwardk : hm, do you remember what free monads were ?
08:02:41 <edwardk> ski: yeah
08:02:52 <ski> (in haskell syntax, e.g.)
08:02:58 <edwardk> newtype Free f a = Return a | Roll (f (Free f a))
08:03:11 <edwardk> its basically a + f (a + f( ....))
08:03:23 <ski> right, ok, istr something like that, but i wanted to check
08:03:45 * ski nods
08:04:13 <ski>   instance Functor f => Functor (Free f)
08:04:32 <edwardk> its the 'sum-type' monad you get from a functor. if the functor has a monoidal structure, you can get a prod-type monad as well. a * f(a * f( ...)) where return a = a * fzero; and you use the functor plus on the subtrees.
08:04:58 <edwardk> instance Functor f => Monad (Free f) -- even
08:05:15 <ski> "functor has a monoidal structure" being ?
08:05:34 <ski> (yes, but i'm not sure i was after the `Monad' instance, here)
08:05:54 <edwardk> if you have class Functor f => FunctorZero f where fzero :: f a; fplus :: f a -> f a -> f a -- where for each a that forms a monoid.
08:05:58 <ski> like `MonadPlus' ?
08:05:58 <chessguy> hey edwardk , i was wondering if you've ever run across a nice zipper implementation in c#
08:06:00 <ski> ok
08:06:12 <chessguy> (run across or written)
08:06:36 <edwardk> chessguy: not that i can think of. i hand implemented a cheesy one for something a while back, but in general when in imperative-land i do as the imperative folks do ;)
08:07:22 <chessguy> heh. ok
08:07:26 <chessguy> just thought i'd check
08:08:20 <Alpounet> blackh: gotta go now, but I've bookmarked it and will try to give you a more complete feedback soon. But as far as I've read, it's really good :-)
08:09:19 <blackh> Alpounet: If I'm offline I should catch your comments when I come back.  See ya!
08:09:28 <Alpounet> See ya :)
08:10:32 <edwardk> @hpaste
08:10:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:11:09 <edwardk> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8814#a8814 <- the 'cofree monad' in scheme ;)
08:12:35 <edwardk> there is a much more horrible transcription of it inside of category-extras that uses the generic PMonad machinery to build up a Monad off of the fixpoint of a PMonad and a definition of PMonad for the base functor PCofree used by Cofree given FunctorPlus
08:12:45 <ski> (why `define-curried' ?)
08:12:47 <benmachine> I wish there was a way in darcs of splitting a hunk into pieces, so that if I for example added two functions adjacent in the source I could record only one of them
08:12:54 <edwardk> that allows you to use bihylo, etc
08:13:26 <edwardk> ski: that way you can just say (make-cofree-monad) without arguments to get a function that will take a functor-plus
08:13:52 <edwardk> it is more an artifact of the fact that the entire library is written that way
08:13:56 * ski was pondering pretending an applicative functor was a monad, by residualizing `join's in something like `Free' above ..
08:14:15 <etpace_> hmmm do I have to do anything special for my (Int, Int) to be an `Ix'?
08:14:35 <ski> no
08:14:55 <ski> @instances-importing Ix Ix
08:14:55 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
08:15:07 <edwardk> ski: http://comonad.com/scheme/monads/curried.scm has the definition for define-curried which gives over/underapplication ala haskell
08:15:11 <etpace_> Couldn't match expected type `i' against inferred type `(Int, Int)' <-- what causes that then?
08:15:23 <ski> etpace_ : paste ?
08:16:42 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8815#a8815
08:17:58 <CalJohn> Can anyone tell me what "the terminal set" is?
08:18:23 <ski> CalJohn : possibly the terminal object in `Set' ?
08:19:19 <etpace_> any ideas ski?
08:19:42 <ski> what type is `[(0,1), (1,0), (-1, 0), (0, -1)]' intended to have ?
08:19:58 <CalJohn> ski: ah, thanks
08:20:20 <mattam> CalJohn: the set with a single element. To which every other set has a single arrow (the constant map).
08:20:27 <etpace_> [Current] == [(Int, Int)]?
08:21:12 <Saizan> etpace_: the problem are the given type signatures
08:21:18 <ski> etpace_ : yes (it wasn't obvious if that was an intended equality, though)
08:21:23 <dsouza> CalJohn: maybe the set of terminals of a given grammar?
08:21:50 <ski>   possibleMoves :: Maze Current -> [Current]  -- maybe this would be better ?
08:22:04 <ski> (and maybe you want to rename `Current' to `Position' ?)
08:23:14 <etpace_> Probably be better to change it in the data decleration
08:23:16 <etpace_> thanks
08:23:55 <ski> btw
08:23:56 <ski>   moveFuture m =  possibleMoves m >>= return . construct m
08:24:00 <ski> can be written as
08:24:12 <ski>   moveFuture m =  liftM (construct m) (possibleMoves m)
08:24:33 <etpace_> cool, thanks
08:25:03 <etpace_> lifts a function from a -> b to [a] -> [b] (in this context)?
08:25:11 <ski> (or s/liftM/fmap/, or even `s/liftM/map/, if you prefer)
08:25:35 <ski> (since the monad was `[]')
08:28:13 <EnglishGent> silly question - how do you put a " character in a string?
08:28:19 * EnglishGent assumes there is some way to escape it
08:28:27 <Lemmih> > "\""
08:28:29 <lambdabot>   "\""
08:28:30 <ski> > ['"']
08:28:31 <lambdabot>   "\""
08:28:39 <EnglishGent> ty! :)
08:28:42 <MisterN> , "\""
08:28:43 <lunabot>  "\""
08:28:44 <ski> > fix show
08:28:45 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
08:28:45 <MisterN> > "\""
08:28:46 <lambdabot>   "\""
08:28:57 <MisterN> what's the difference between lunabot and lambdabot? :)
08:29:06 <ski> they're different bots
08:29:08 <c_wraith> ski, that's horrible. :)
08:29:56 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
08:29:56 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
08:30:17 <c_wraith> and that's just baffling. :)
08:30:22 <EvilTerran> @help yhjulwwiefzojcbxybbruweejw
08:30:22 <lambdabot> V RETURNS!
08:30:48 <EvilTerran> @@ (@v); (@help v)
08:30:48 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"; let v = show v in v
08:31:29 <Saizan> > __compileExpr
08:31:31 <lambdabot>   Not in scope: `__compileExpr'
08:31:33 <CalJohn> dsouza: the context is category theory.  i think i'm fairly satisfied that it's the singleton set of the terminal object
08:32:05 <etpace_> hmm
08:33:02 <ski> > read (concatMap (\i -> replicate i '\\' ++ ['"']) [0..]) :: String
08:33:03 <lambdabot>   "* Exception: Prelude.read: no parse
08:33:29 <etpace_> :t iterate
08:33:30 <lambdabot> forall a. (a -> a) -> a -> [a]
08:33:45 <ski> CalJohn : no, the terminal object *is* (")the(") singeton set in `Set'
08:34:45 <etpace_> ski: solve m = iterate (concatMap moveFuture) [m] should eventually find a winner, right? but how can I tell iterate when to stop once I've found a solution?
08:35:17 <c_wraith> I suspect the answer involves ContT.  >_>
08:35:44 <ski> etpace_ : this is regarding your paste, yes ?
08:35:53 <etpace_> yes
08:35:54 * ski hasn't actually read it
08:36:17 <ski> (.. only type-checked it here and there)
08:37:01 <etpace_> hmm ok
08:37:05 <ski> how is "winner" defined ?
08:37:25 <ski> any state with no future ?
08:37:27 <etpace_> If Position == Finish, I guess ill implement a isWInner
08:37:47 * ski notices there's a `Finish' constructor ..
08:38:01 <etpace_> Yeah, its for a maze, so Finish is the 'goal'
08:38:12 <CalJohn> ski: wikipedia (http://xrl.in/2zvb) lead me to the conclusion that a terminal object is an object T in category C for which all objects in C have a morphism to T.  is that understand wrong?
08:38:38 <ski> s/have a morphism/have a unique morphism/
08:38:43 <ski> otherwise right
08:39:19 <CalJohn> i've just seen why you corrected me earlier
08:39:30 <ray> mmm, unique morphisms
08:39:58 <ray> an initial object is the same thing, but morphisms from instead of morphisms to
08:40:04 <ski> etpace_ : i would use an exception to stop, i suppose
08:40:21 * ski wonders which way to compose ..
08:40:35 <ski> @unmtl ErrorT e [] a
08:40:36 <lambdabot> [Either e a]
08:40:48 <ski> @unmtl ListT (Either e) a
08:40:48 <lambdabot> Either e [a]
08:41:26 <ski> i think you'd want the latter
08:41:48 <benmachine> > concatMap (\i -> replicate i '\\' ++ ['"']) . map pred $ iterate (*2) 1
08:41:49 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
08:41:49 <deadlyx> @help unmtl
08:41:50 <lambdabot> unroll mtl monads
08:43:20 <ski> (c_wraith : this doesn't feel like a problem where the full force of `Cont'/`ContT' is needed .. but one could use it, if one wanted to)
08:43:24 <etpace_> i'm not quite sure what those signify ski
08:43:45 <benmachine> > read . concatMap (\i -> replicate i '\\' ++ ['"']) . map pred $ iterate (*2) 1 :: String
08:43:49 <c_wraith> Exceptions feel sorta dirty for escaping from a recursive search.  I'm not saying I haven't done it before...  But haskell should be purer than that. :)
08:43:50 <lambdabot>   mueval-core: Prelude.read: no parse
08:43:50 <lambdabot>  mueval: ExitFailure 1
08:43:58 <ski> `moveFuture' moves from one state to the next (nondeterministically)
08:44:14 <ski> c_wraith : by "exception" i mean `Either' :)
08:44:36 <c_wraith> mildly better :)
08:44:54 <c_wraith> I should learn to use Cont at some point.
08:45:02 <c_wraith> Maybe I'll do that while my car's in the shop today.
08:45:06 <ski> you need a way to "break the loop", to be able to stop the infinite descent
08:45:19 <c_wraith> speaking of which, time to take my car to the shop
08:45:37 * ski wonders where c_wraith's cdr is
08:45:48 <ski> (c_wraith : why only "mildly" ?)
08:46:36 <ray> time to take my jacket to the cleaners
08:47:08 <ski> etpace_ : anyway, `Either' should be able to break the loop
08:47:23 <etpace_> ok
08:47:27 <ski> hm
08:47:57 <ski> do you want a depth-first traversal of the game tree ?
08:48:55 <etpace_> I'm not sure, i've just setup a naive solution, I think its breadth first though as it doesnt follow only one board until it terminates?
08:49:52 * int-e wishes Bulat would stop stating falsehoods as facts. :/
08:50:01 <eu-prleu-peupeu> helloo
08:50:03 <ski> `(>>=)' on `[]' implements depth-first search
08:50:23 <etpace_> ok then
08:50:47 <ski> if every path is finite, you should still find any success state
08:53:19 <etpace_> Is there a printer/'shower' for Data.Array?
08:56:17 <Saizan> int-e: like?
08:56:42 <ski> > tabulate (-3,3) $ \i -> i^2
08:56:44 <lambdabot>   array (-3,3) [(-3,9),(-2,4),(-1,1),(0,0),(1,1),(2,4),(3,9)]
08:57:40 <int-e> Saizan: http://www.haskell.org/pipermail/haskell-cafe/2009-August/065601.html
08:58:38 <Berengal> length . show
08:59:06 <MisterN> :t tabulate
08:59:07 <lambdabot> forall i a. (Ix i) => (i, i) -> (i -> a) -> Array i a
08:59:40 <MisterN> @src tabulate
08:59:41 <lambdabot> Source not found. :(
08:59:50 <int-e> Saizan: although the more usual case is about performance issues which are harder to refute, but seem to be based on an understanding of ghc 6.4 or 6.6, ignoring recent progress.
09:00:09 <ski>   tabulate :: Ix i => (i,i) -> (i -> a) -> Array i a
09:00:10 <ski>   tabulate ix f = array ix [(i,f i) | i <- range ix]
09:00:33 <ski> (not in libraries, afaik)
09:00:36 <etpace_> Hmm
09:00:37 <int-e> Berengal: yes, length . show performs quite well, although you can do better. (obviously - you can avoid constructing that whole list of digits)
09:02:07 <Berengal> {-# FUSIONPLOXKTHX #-} length . show :P
09:02:48 <Saizan> do people really consider div to be linear?
09:03:06 <int-e> Saizan: it is essentially linear. it's just a constant factor off multiplication.
09:03:26 <etpace_>                        b = bounds m
09:03:27 <etpace_>                        isFree (x,y) = (m ! (min (max x 0) (fst b)), min (max y 0) (snd b)) == Future
09:03:38 <etpace_> is there a better way to not access invalid index's?
09:03:43 <benmachine> I remember talking to someone about this recently and working out something pretty fast with logarithms
09:03:48 <etpace_> becaise thats quite nasty ;s
09:05:51 <Berengal> etpace_, well, you'll get an exception on invalid indices, but that makes it a partial function
09:06:31 <ski> @type fix . (>=>)
09:06:32 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
09:06:34 <ski> @type fix . ((=<<) .) . flip (.)
09:06:36 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> m a) -> m a -> m b
09:06:42 <edwardk> int-e, saizan: hrmm, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.6422 points out it can be done with the same complexity as the karatsuba algorithm which is n^(log_2 3)
09:06:46 <MisterN> are arrays lazy?
09:06:55 <ski> would `iterateM_'
09:07:09 <ski> be a usable name for the former of those ? any better suggestion ?
09:07:39 <Berengal> ski, I dunno, iterate's useful because it's lazy
09:07:51 <Berengal> iterateM_ can't terminate
09:08:13 <ski> it can, with `Either e' or `Cont o', e.g.
09:08:24 <ski> (also with expression monads)
09:08:34 <Berengal> Ah, yes, that's true
09:09:14 <edwardk> I wonder if a similar result would hold for Schönhage–Strassen or Fürer's algorithms
09:09:17 * ski thinks the name `subst' would be cute for the latter of those two ..
09:09:18 <Berengal> I'd say 'loop' if it weren't so often used as a foo name
09:10:17 <EnglishGent> horray!
09:10:18 <int-e> Saizan: 1/x - a = 0 has the newton iteration x |-> 2x - a*x^2, allowing you to double the digits of the inverse in each step. So to find a result of n digits, you need c*f(n) + c*f(n/2) + c*f(n/4) + ... = c*f(n) steps (where f(n) is the number of operations for a multiplication)
09:10:27 * EnglishGent completes his first-real world, non-tutorial Haskell program :D
09:10:33 * EnglishGent breaks out the champagne :)
09:11:04 <int-e> Saizan: err = O(f(n))
09:12:31 <ski> > let fibonacci n = fib n where fib = (arr !); arr = tabulate (0,n) fib'; fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-2) + fib (n-1) in fibonacci 100  -- MisterN
09:12:33 <lambdabot>   354224848179261915075
09:13:52 <ski> (Berengal : hm .. with the list monad of course, too .. but that's not too useful)
09:14:09 <MisterN> ski: sorry, i don't understand that code.
09:14:20 <ski> > (fix . (>=>)) (const []) ()
09:14:22 <lambdabot>   []
09:14:38 <ski> MisterN : it lazily defines an array `arr' in terms of itself
09:15:14 <MisterN> ski: so array has to be a rather advanced data structure?
09:15:27 <MisterN> (internally)
09:15:33 <ski> not really
09:15:37 <Berengal> No, it's just a bunch of contiguous memory
09:15:54 <ski> when the array is forced, all the cells are constructed, and filled with thunks
09:16:23 <ski> accessing and forcing those thunks may recursively access and force other thunks in the array
09:16:57 <ski> in the above array, each cell (but the first two) is defined in terms of the two previous cells
09:17:21 <ski> so forcing one of them will end of forcing every earlier cell in the array
09:18:04 <ski> (and because the values resulting from those forces are cached/stored in the array, further accesses to them will not recompute)
09:18:12 <Saizan> mh, an Array is basically an UArray of pointers to thunks or is it a contiguous block of thunks?
09:18:30 <MisterN> Berengal: but contiguous memory can't be lazy?
09:18:36 <int-e> Saizan: it's a block of pointers
09:18:40 <Berengal> MisterN, no, but the contents can be
09:18:56 <MisterN> so an array has to have fixed size, too?
09:19:00 <ski> yes
09:19:13 <ski> no infinite arrays
09:19:13 <int-e> Saizan: but unlike UArrays, the garbage collector has to follow these pointers if the array was modified, so I'd be reluctant to say that they're like UArrays.
09:19:35 <Berengal> Also, you can't update an Array because it's immutable. Any mutation causes copying
09:20:07 <Saizan> you can't update UArrays either
09:20:45 <int-e> oh, I was getting ahead of myself. the GC has to follow the pointers when evacuating the Array. As there can be many such pointers, this can be very expensive.
09:21:06 <hackagebot> hark 0.2 - A Gentoo package query tool. (MarkusDittrich)
09:21:08 <hackagebot> hlint 1.6.6 - Source code suggestions (NeilMitchell)
09:21:34 <int-e> Things are worse for mutable arrays (IOArrays and STArrays) where every GC has to check those pointers if the array was modified, even if the array in question is in an older generation.
09:23:01 <int-e> I should add that this statement is completely ghc-centric, based on the current state of affairs.
09:23:29 <Berengal> Is there a way of turning off gc for a little while?
09:23:56 <Berengal> Would such a thing even be smart?
09:24:14 <Saizan> you can disable the major collections, i think
09:27:48 <SamB_XP> what the heck ... google toolbar is trying to turn firefox into Chrome, isn't it?
09:28:38 <SamB_XP> I opened a new tab and find a chrome-style thumbnail page ...
09:28:46 <eu-prleu-peupeu> :)
09:28:58 <eu-prleu-peupeu> SamB_XP: try opera 10 :)
09:29:10 <eu-prleu-peupeu> its the best
09:29:11 <eu-prleu-peupeu> ever
09:29:14 <eu-prleu-peupeu> ...in the world
09:29:17 <SamB_XP> with Google Toolbar in the upper right
09:29:29 <int-e> back to the roots - use mosaic.
09:29:32 <SamB_XP> eu-prleu-peupeu: is it light on RAM? is it portable?
09:29:37 <eu-prleu-peupeu> yes :)
09:29:38 * int-e wonders whether that can even be compiled nowadays.
09:29:44 <eu-prleu-peupeu> opera 10 is teh best evar!
09:29:47 <SamB_XP> int-e: does that support any recent standards?
09:29:54 <skorpan> opera would be nice if it didn't suck
09:30:04 * Berengal browses with GET
09:30:04 <int-e> SamB_XP: what part of "back to the roots" didn't you understand?
09:30:04 <SamB_XP> int-e: I'd probably get better mileage out of amaya!
09:30:05 <eu-prleu-peupeu> skorpan: its teh best in teh world forever!
09:30:14 <SamB_XP> int-e: the roots kind of sucked :-(
09:30:21 <int-e> SamB_XP: I'm sure it will work great with gopher.
09:30:34 <eu-prleu-peupeu> http://www.opera.com/browser/next/
09:30:35 <etpace_> @hoogle String -> [String] -> String
09:30:35 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
09:30:35 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
09:30:35 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
09:30:37 <eu-prleu-peupeu> go for it! :D
09:30:47 <eu-prleu-peupeu> opera is for browsers what haskell is for programming
09:30:50 <int-e> eu-prleu-peupeu: can you stop advertising or should we look for ops?
09:30:58 <ksf> uzbl!
09:31:02 <eu-prleu-peupeu> eheh
09:31:04 <eu-prleu-peupeu> sorry then
09:31:21 <eu-prleu-peupeu> im a fan :P
09:31:27 <int-e> SamB_XP: and I'm kidding, of course.
09:32:00 <SamB_XP> eu-prleu-peupeu: what is the oleg of opera?
09:32:10 <EnglishGent> @hoogle [a] -> [a] -> [a]
09:32:11 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
09:32:11 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
09:32:11 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
09:32:52 <EnglishGent> @hoogle [a] -> a -> Bool
09:32:52 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
09:32:52 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
09:32:52 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
09:33:00 <eu-prleu-peupeu> SamB_XP: what is oleg ?
09:34:28 <Berengal> @quote Oleg
09:34:29 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
09:35:09 <ksf> @quote olegfacts
09:35:09 <lambdabot> No quotes match. stty: unknown mode: doofus
09:35:14 <ksf> @quote Olegfacts
09:35:15 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:35:18 <ksf> hm.
09:35:23 <ksf> @quote oleg-facts
09:35:23 <lambdabot> No quotes match. You type like i drive.
09:35:26 <ksf> @quote oleg
09:35:26 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
09:35:35 <ksf> @quote oleg
09:35:35 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
09:36:12 <ksf> @where+ oleg http://okmij.org/ftp/
09:36:12 <lambdabot> Done.
09:36:30 <c_wraith> hmm.  Is there any pretty example of permutation code in the list monad?
09:36:31 <etpace_> If I have a list and I want to split the elemenst into sublists of length n, how would I do that? like foo 3 [1..9] = [[1,2,3], [4,5,6], [7,8.9]]
09:37:15 <int-e> > let n = 3 in takeWhile (not null) . map (take n) . iterate (drop n) $ [1..10]
09:37:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:37:25 <int-e> > let n = 3 in takeWhile (not . null) . map (take n) . iterate (drop n) $ [1..10]
09:37:27 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
09:37:58 <etpace_> thanks
09:38:39 <eu-prleu-peupeu> i think haskell name should be changed to "the haskell"
09:38:50 <eu-prleu-peupeu> "the 'the haskell' programming language"
09:38:55 <Saizan> > let n = 3 in unfoldr (\xs -> do guard (not . null) xs; return (splitAt n xs)) $ [1..10]
09:38:57 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:39:30 <Saizan> > let n = 3 in unfoldr (\xs -> do guard . not . null $ xs; return (splitAt n xs)) $ [1..10]
09:39:31 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
09:39:54 <ksf> , let hex = ['0'...'9'] ++ ['a'..'f'] ++ ['A'..'F'] in filter ((/= 0) . length . (\\ hex)) . map nub $ dict
09:39:55 <lunabot>  luna: Not in scope: `...'
09:40:01 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F'] in filter ((/= 0) . length . (\\ hex)) . map nub $ dict
09:40:03 <int-e> > let n = 3 in unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt n)) [1..10]
09:40:03 <lunabot>  ["10-point","10th","1-point","12-point","16-point","18-point","1st","20-p...
09:40:04 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
09:40:48 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F'] in filter ((== 0) . length . (\\ hex)) . map nub $ dict
09:40:51 <lunabot>  ["108","2","2D","3D","A","a","A1","a1","A4","A5","A","a","A","a","A","A",...
09:41:35 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex)) . map nub $ dict in filter (length == 4) words
09:41:36 <lunabot>  luna: Couldn't match expected type `a -> GHC.Bool.Bool'
09:41:54 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex)) . map nub $ dict in filter ((==4).length) words
09:42:00 <lunabot>  Killed.
09:42:04 <ksf> meh.
09:42:21 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex)) . map nub $ dict in drop 100 words
09:42:24 <lunabot>  ["AFC","AFC","afd","af","af","B","b","B91","BA","Ba","ba","BA","ba","baed...
09:42:51 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex)) . map nub $ dict in drop 105 words
09:42:54 <lunabot>  ["B","b","B91","BA","Ba","ba","BA","ba","baed","Bab","ba","Bab","ba","Bab...
09:43:53 <int-e> , maximum . map length . group . sort $ dict
09:43:59 <lunabot>  Killed.
09:44:46 <int-e> oh. map nub
09:45:12 <int-e> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words =  filter ((== 0) . length . (\\ hex) . nub) $ dict in drop 105 words
09:45:15 <lunabot>  ["B","b","B911","BA","Ba","ba","BAA","baa","baaed","Bab","bab","Baba","ba...
09:45:30 <holmak> @djinn a -> b -> a
09:45:31 <lambdabot> f a _ = a
09:45:45 <ksf> oh.
09:46:10 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ dict in filter ((==4).length) words
09:46:15 <lunabot>  Killed.
09:46:28 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ dict in take 10 $ filter ((==4).length) words
09:46:30 <lunabot>  ["1080","AAAA","AAEE","abac","Abad","Abba","abba","Abbe","abbe","abed"]
09:46:54 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ dict in take 10 $ filter ((==8).length) words
09:46:59 <lunabot>  Killed.
09:47:08 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ dict in filter ((==8).length) words
09:47:13 <lunabot>  Killed.
09:47:54 <ksf> smells like fuse fail.
09:48:19 <eu-prleu-peupeu> if i have a huge data record, how do i change only one of its values ?
09:48:37 <eu-prleu-peupeu> say data Foo = Foo { a :: Int, b :: Int, ... z :: Int }  ...
09:48:45 <mauke> use record update syntax
09:48:56 <c_wraith> let foo2 = foo { q = 5 }
09:48:57 <ksf> foo { a = 2}
09:49:06 <eu-prleu-peupeu> ah ok
09:49:08 <eu-prleu-peupeu> thanks
09:49:16 <int-e> , let isH c = 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' in filter (\xs -> all isH xs && length xs == 8) words
09:49:17 <lunabot>  luna: Couldn't match expected type `[[GHC.Types.Char]]'
09:49:22 <ksf> or, usually defaultFoo { z = 3 }
09:49:41 <eu-prleu-peupeu> hmm
09:50:34 <eu-prleu-peupeu> so, if i have let f = Foo 1 2 3 ..., then i could do func old_foo = old_foo { a = 10 } ?
09:50:50 <eu-prleu-peupeu> and func f, would update it ?
09:50:52 <int-e> , let isH c = 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' in filter (\xs -> all isH xs && length xs == 8) dict
09:50:57 <lunabot>  Killed.
09:51:00 <mauke> eu-prleu-peupeu: it would return a new value
09:51:02 * int-e shrugs
09:51:04 <eu-prleu-peupeu> yes
09:51:06 <ksf> eu-prleu-peupeu, your old_foo is bottom.
09:51:11 <mauke> ksf: no
09:51:14 <eu-prleu-peupeu> bottom ?
09:51:26 <ksf> ...well, for everyting excetp a.
09:51:38 <mauke> no
09:51:42 <eu-prleu-peupeu> argh
09:51:47 <eu-prleu-peupeu> i really dont understand it :/
09:51:47 <ksf> wut?
09:52:07 <eu-prleu-peupeu> i want to avoid doing this: func (Foo a b c ...) = Foo 10 b c ...
09:52:09 <ksf> oh, there's a "func" before old_foo
09:52:21 <eu-prleu-peupeu> how do i avoid it ?
09:52:40 <ksf> f x = x { a = 10 }
09:52:57 <eu-prleu-peupeu> ok
09:52:59 <eu-prleu-peupeu> thanks
09:59:01 <ksf> , length $ filter ((==8).length) dict
09:59:06 <lunabot>  Killed.
09:59:18 <ksf> , length $ filter ((==8).length) $ take 1000 dict
09:59:21 <lunabot>  138
09:59:22 <Berengal> updateA a x = x{a}, with some exctentions
09:59:36 <Berengal> extentions*
09:59:48 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 dict in filter ((==8).length) words
09:59:50 <lunabot>  []
10:00:03 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 . drop 1000 dict in filter ((==8).length) words
10:00:05 <lunabot>  luna: Couldn't match expected type `a -> [a1]'
10:00:11 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 $ drop 1000 dict in filter ((==8).length) words
10:00:13 <lunabot>  []
10:00:18 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 $ drop 2000 dict in filter ((==8).length) words
10:00:20 <lunabot>  []
10:00:28 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 $ drop 3000 dict in filter ((==8).length) words
10:00:30 <lunabot>  []
10:00:32 <ksf> wtf
10:00:41 <ksf> , let hex = ['0'..'9'] ++ ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 dict in filter ((==4).length) words
10:00:44 <lunabot>  ["1080","AAAA","AAEE","abac","Abad","Abba","abba","Abbe","abbe","abed"]
10:00:56 <trez> ehrm
10:01:03 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 $ drop 1000 dict in filter ((==4).length) words
10:01:05 <lunabot>  ["ACAA","acad","acca","acce"]
10:01:06 <Berengal> , [$ty|dict|]
10:01:09 <lunabot>  [] String
10:01:13 <Berengal> Nice
10:01:17 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 1000 $ drop 2000 dict in filter ((==4).length) words
10:01:19 <lunabot>  ["ACDA","aced"]
10:01:31 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ dict in filter ((==4).length) words
10:01:37 <lunabot>  Killed.
10:01:38 <Colours> hi! is there any way to cross-compile FreeBSD binaries with GHC on a Linux system?
10:02:07 <ksf> I'm searching for words like deadbeef and cafebabe, but it won't let me.
10:02:22 <ksf> , length dict
10:02:25 <lunabot>  479830
10:02:41 <etpace_> > (1,2) `mplus` (3,4)
10:02:42 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 dict in filter ((==4).length) words
10:02:42 <lambdabot>   No instance for (Control.Monad.MonadPlus ((,) t))
10:02:42 <lambdabot>    arising from a use of ...
10:02:44 <lunabot>  ["AAAA","AAEE","abac","Abad","Abba","abba","Abbe","abbe","abed","ACAA","a...
10:03:04 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 dict in filter ((==8).length) words
10:03:07 <lunabot>  []
10:03:19 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ dorp 100000 dict in filter ((==8).length) words
10:03:20 <lunabot>  luna: Not in scope: `dorp'
10:03:24 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 100000 dict in filter ((==8).length) words
10:03:27 <lunabot>  ["Fabaceae"]
10:03:34 <ksf> hey!
10:03:42 <Berengal> @wn fabaceae
10:03:45 <lambdabot> *** "Fabaceae" wn "WordNet (r) 2.0"
10:03:45 <lambdabot> Fabaceae
10:03:45 <lambdabot>      n : a large family of trees, shrubs, vines, and herbs bearing
10:03:45 <lambdabot>          bean pods; divided for convenience into the subfamilies
10:03:45 <lambdabot>          Caesalpiniaceae; Mimosaceae; Papilionaceae [syn: {Leguminosae},
10:03:47 <lambdabot>           {family Leguminosae}, {family Fabaceae}, {legume family},
10:03:49 <ksf> , 0x fabaceae
10:03:49 <lambdabot>           {pea family}]
10:03:50 <lunabot>  luna: Not in scope: `fabaceae'
10:03:53 <ksf> , 0xfabaceae
10:03:54 <lunabot>  4206546606
10:04:05 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 200000 dict in filter ((==8).length) words
10:04:08 <lunabot>  []
10:04:12 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 300000 dict in filter ((==8).length) words
10:04:15 <lunabot>  []
10:04:19 <ksf> , let hex = ['a'..'f'] ++ ['A'..'F']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 400000 dict in filter ((==8).length) words
10:04:22 <lunabot>  []
10:04:35 <davidL> > dict
10:04:36 <ksf> I expected much more words.
10:04:37 <lambdabot>   Not in scope: `dict'
10:04:48 <ksf> lambdabot doesn't know it.
10:04:51 <Berengal> ksf, things like deadbeef and cafebabe are composite words
10:05:16 <ksf> yep, but I can't be ared to go through all those 4-word results.
10:05:17 <Berengal> , length . filter (>=8 . length) $ dict
10:05:18 <lunabot>  luna: Couldn't match expected type `[a] -> c'
10:05:32 <Berengal> , length . filter ((>=8) . length) $ dict
10:05:36 <lunabot>  Killed.
10:05:38 <davidL> , dict
10:05:40 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
10:05:49 <ksf> there's also 5+3, 6+2 and 7+1...
10:05:53 <davidL> , length $ dict
10:05:55 <lunabot>  479830
10:06:11 <Berengal> , length . filter ((>=8) . length) . take 100000 . drop 0 $ dict
10:06:13 <lunabot>  67383
10:06:28 <Berengal> , filter ((>=8) . length) . take 100000 . drop 0 $ dict
10:06:30 <lunabot>  ["10-point","11-point","12-point","16-point","18-point","20-point","48-po...
10:06:50 <Berengal> , length . filter ((>=8) . length) . take 100000 . drop 100000 $ dict
10:06:53 <lunabot>  70291
10:08:38 <ksf> , let hex = ['a'..'f'; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 400000 dict in filter ((==8).length) words
10:08:39 <lunabot>  luna: parse error on input `;'
10:08:46 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000 $ drop 400000 dict in filter ((==8).length) words
10:08:49 <lunabot>  []
10:09:02 <c_wraith> @hoogle [a] -> Int -> (a, [a])
10:09:02 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
10:09:02 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:09:02 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:09:07 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000  dict in filter ((==8).length) words
10:09:10 <lunabot>  []
10:09:35 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000  dict in filter ((==4).length) words
10:09:38 <lunabot>  ["abac","abba","abbe","abed","acad","acca","acce","aced","adad","adda","a...
10:09:54 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000  $ drop 100000 dict in filter ((==4).length) words
10:09:57 <lunabot>  ["decd","deda","dedd","deed","ebcd","ecad","ecce","edda","edea","face","f...
10:10:03 --- mode: ChanServ set +o monochrom
10:10:11 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000  $ drop 200000 dict in filter ((==4).length) words
10:10:14 <lunabot>  []
10:10:17 --- mode: monochrom set -b *!*@ip72-223-102-120.ph.ph.cox.net
10:10:23 --- mode: monochrom set -o monochrom
10:10:26 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 100000  $ drop 100010 dict in filter ((==4).length) words
10:10:29 <lunabot>  ["decd","deda","dedd","deed","ebcd","ecad","ecce","edda","edea","face","f...
10:11:14 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8816#a8816 any tips o ntidying that up? its quite a mess
10:11:15 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in length $ filter ((==4).length) words
10:11:18 <lunabot>  49
10:11:30 <ksf> well ok.
10:11:46 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10  $ filter ((==4).length) words
10:11:48 <lunabot>  ["abac","abba","abbe","abed","acad","acca","acce","aced","adad","adda"]
10:11:54 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10  $ drop 10 $ filter ((==4).length) words
10:11:57 <lunabot>  ["affa","baba","babe","bade","baff","bead","bede","beef","caba","caca"]
10:12:01 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10  $ drop 20 $ filter ((==4).length) words
10:12:03 <lunabot>  ["cace","cade","cafe","caff","ceca","cede","dabb","dace","dada","dade"]
10:12:07 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10  $ drop 30 $ filter ((==4).length) words
10:12:10 <lunabot>  ["daff","dead","deaf","debe","decd","deda","dedd","deed","ebcd","ecad"]
10:12:13 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10  $ drop 40 $ filter ((==4).length) words
10:12:17 <lunabot>  ["ecce","edda","edea","face","fade","faff","feeb","feed","feff"]
10:12:55 <gwern> '# It’s hard to know when to stop. List comprehensions, for example, are really cool and natural, but they make a surprising number of problems too easy and allow students to avoid writing loops. We show them toward the end of our intro course but don’t require the students to use them.'
10:13:05 <gwern> lol. this is for python list comps even
10:13:14 <ksf> , 0xdeadfeed
10:13:15 <lunabot>  3735944941
10:13:33 <ksf> so  3735944941 is going to be the new insult in the blogosphere.
10:13:37 <gwern> let's hope the next version of python drops all maps and folds and unfolds so students can write everything in loops!
10:14:02 <Berengal> I've already written a loop once! Why should I have to write one again?
10:14:02 <skorpan> gwern: i heard at google people are forbidden to use map and reduce
10:14:12 <Berengal> skorpan, now that's ironic...
10:14:19 * gwern was about to say
10:15:08 <gwern> skorpan: why would they do that?
10:15:17 <skorpan> because they're confusing, etc
10:15:32 <ksf> cafefeed is good, too.
10:15:38 <skorpan> i can't recall where i heard this
10:15:44 <Berengal> .... I thought google hired /good/ programmers...
10:15:45 <gwern> skorpan: that sounds like an unlikely reason for Google
10:16:19 <ksf> , drop 200000 dict
10:16:21 <lunabot>  ["intracellular","intracellularly","intracephalic","intracerebellar","int...
10:16:31 <skorpan> "Update: lambda, filter and map will stay (the latter two with small changes, returning iterators instead of lists). Only reduce will be removed from the 3.0 standard library. You can import it from functools."
10:16:38 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in  filter ((==8).length) words
10:16:41 <lunabot>  []
10:16:56 <etpace_> what's reduce in haskell, fold?
10:17:01 <Berengal> foldM
10:17:09 <etpace_> :t foldM
10:17:11 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:17:18 <Berengal> Well, everything in python is in IO
10:17:22 <gwern> Berengal: is it really foldM?
10:17:25 <monochrom> loops are overrated.
10:17:37 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in  filter ((==3).length) words
10:17:41 <lunabot>  ["aaa","aba","abb","abc","abd","acc","ace","adc","add","ade","afb","afd",...
10:17:46 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in  filter ((==5).length) words
10:17:47 <skorpan> http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Using_apply,_filter,_map,_reduce
10:17:49 <lunabot>  ["abaca","abada","abaff","abede","addda","added","adead","aface","baaed",...
10:17:56 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in  filter ((==6).length) words
10:18:00 <lunabot>  ["accede","afaced","bacaba","baccae","baffed","beaded","bedaff","bedded",...
10:18:11 <skorpan> "Cons:  Higher-order functional programming tends to be harder to understand."
10:18:11 <Warrigal> > dict
10:18:12 <lambdabot>   Not in scope: `dict'
10:18:12 <Berengal> gwern, well, foldM1 possibly
10:18:16 <Warrigal> , dict
10:18:18 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
10:18:22 <Berengal> It's been a while since I did any python now
10:18:24 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in length $ filter ((==6).length) words
10:18:26 <Warrigal> Huh.
10:18:26 <cpettitt> :t foldl'
10:18:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:18:27 <lunabot>  24
10:18:37 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 10 $ filter ((==6).length) words
10:18:39 <lunabot>  ["accede","afaced","bacaba","baccae","baffed","beaded","bedaff","bedded",...
10:18:50 <Warrigal> , map reverse . sort . map reverse $ dict
10:18:52 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 8 $ filter ((==6).length) words
10:18:54 <lunabot>  ["accede","afaced","bacaba","baccae","baffed","beaded","bedaff","bedded"]
10:18:55 <lunabot>  ["hee-hee!","he-he!","M'","O'","a'","ca'","ha'","wa'","d'","chef-d'","Mac...
10:19:03 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 8 $ drop 8 $ filter ((==6).length) words
10:19:06 <lunabot>  ["bedead","bedeaf","beebee","beefed","cabbed","cadded","dabbed","daffed"]
10:19:14 <ksf> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in take 8 $ drop 16 $ filter ((==6).length) words
10:19:16 <lunabot>  ["decade","decede","deeded","deface","defade","efface","facade","feeded"]
10:19:37 <Warrigal> , let hex = ['a'..'f']; words = filter ((== 0) . length . (\\ hex) . nub)$ take 200000 dict in  filter ((==4).length) words
10:19:40 <lunabot>  ["abac","abba","abbe","abed","acad","acca","acce","aced","adad","adda","a...
10:19:45 <uzytkownik> Hello. Is such recursive definition: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8817#a8817 allowed? typeOf does not depends on the argument so recursion is not executed (unsafePerformIO makes it lazy). Is it possible to write it nicer?
10:19:47 <Warrigal> Those are the IPv6 words.
10:19:54 <eu-prleu-peupeu> how do i transform a function f :: a -> b -> c -> d into f :: a -> c -> b -> d ?
10:20:01 <ksf> so the proper magic bytes for a sound file are "bedeafed"
10:20:09 <Warrigal> @djinn (a -> b -> c -> d) -> a -> c -> b -> d
10:20:09 <lambdabot> f a b c d = a b d c
10:20:19 <Warrigal> @pl f a b c d = a b d c
10:20:19 <lambdabot> f = (flip .)
10:20:21 <eu-prleu-peupeu> is there any "flipLast" function ?
10:20:25 <monochrom> "problem ... avoid writing loops" indicates a religious movement. The intellectual thing to do is let students decide what to avoid.
10:20:29 <Warrigal> eu-prleu-peupeu: by using (flip .)
10:20:46 <etpace_> the power of lambdabot...
10:20:48 <uzytkownik> eu-prleu-peupeu: (\a c b d -> f a b c d)
10:20:48 <eu-prleu-peupeu> ah nice
10:20:49 <eu-prleu-peupeu> :D
10:20:50 <eu-prleu-peupeu> amazing
10:20:58 <Warrigal> I am, I know.
10:21:11 <Warrigal> :-P
10:21:20 <eu-prleu-peupeu> flip . is a really nice idea, i would have never thought that
10:21:29 <etpace_> There should be a command that runs djinn >>= pl
10:21:36 <etpace_> for more magic
10:21:41 <eu-prleu-peupeu> :D
10:21:44 <ksf> Warrigal, ["abac","abba","abbe","abed","acad","acca","acce","aced","adad","adda"] ["affa","baba","babe","bade","baff","bead","bede","beef","caba","caca"] ["cace","cade","cafe","caff","ceca","cede","dabb","dace","dada","dade"]["daff","dead","deaf","debe","decd","deda","dedd","deed","ebcd","ecad"]  ["ecce","edda","edea","face","fade","faff","feeb","feed","feff"]
10:21:47 <eu-prleu-peupeu> what does pl do ?
10:21:47 <monochrom> It is equivalent to "problem ... avoid doing arithmetic mentally" 50 years ago.
10:22:02 <ksf> @pl f x = x
10:22:02 <lambdabot> f = id
10:22:05 <etpace_> converts a function to point-free style
10:22:11 <ksf> @pl f a b = f b a
10:22:11 <lambdabot> f = fix flip
10:22:19 <Warrigal> eu-prleu-peupeu: it takes a function defined as an equation or lambda and turns it into a function build out of other functions.
10:22:23 <benmachine> @. djinn pl (a -> b -> c -> d) -> a -> c -> b -> d
10:22:23 <lambdabot> Cannot parse command
10:22:23 <lambdabot> Cannot parse command
10:22:23 <lambdabot> Cannot parse command
10:22:27 <benmachine> wat
10:22:30 <benmachine> oh
10:22:30 <Berengal> monochrom, that's not only 50 years ago...
10:22:31 <mauke> you're doing it wrong
10:22:35 <eu-prleu-peupeu> ah ok
10:22:38 <benmachine> @. pl djinn (a -> b -> c -> d) -> a -> c -> b -> d
10:22:38 <lambdabot> f = (flip .)
10:22:41 <benmachine> \o/
10:22:46 <Vanadium> @pl \a b c d e f g -> a b c d e g f
10:22:47 <lambdabot> ((((flip .) .) .) .)
10:22:52 <eu-prleu-peupeu> and djinn ?
10:22:57 <eu-prleu-peupeu> what does djinn does ?
10:23:03 <Warrigal> djinn takes the type of a function and gives you a function with that type.
10:23:04 <benmachine> djinn tries to make a function that matches the given type signature
10:23:07 <trofi> @pl \a b c d -> d c b a
10:23:07 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
10:23:17 <benmachine> it is not necessarily the function you want, though
10:23:25 <benmachine> but in simple cases like this it probably is
10:23:25 <Axman6> @djinn Maybe a -> Bool
10:23:25 <lambdabot> f a =
10:23:25 <lambdabot>     case a of
10:23:25 <lambdabot>     Nothing -> False
10:23:25 <lambdabot>     Just _ -> True
10:23:26 <eu-prleu-peupeu> ahah
10:23:27 <eu-prleu-peupeu> :)
10:23:30 <Vanadium> @pl \f -> ((((flip .) .) .) .)
10:23:30 <lambdabot> const ((((flip .) .) .) .)
10:23:35 <Vanadium> eerr.
10:23:38 <eu-prleu-peupeu> this is great!
10:23:39 <Vanadium> @pl \f -> ((((f .) .) .) .)
10:23:39 <lambdabot> (.) . (.) . (.) . (.)
10:23:41 <Warrigal> @pl \e t a o i n s h r d l u f -> (t h i s) (i s) (f u n) (e h)
10:23:44 <lambdabot> ((const . const . (((((const . const . const) .) .) .) .)) .) . flip (flip . ((flip . ((flip . ((ap . (flip .)) .)) .) . ((((flip .) .) .) .)) .) . flip flip (flip (flip . flip id)) . ((.) .) . (
10:23:44 <lambdabot> flip .) . ((flip .) .) . ((((.) .) .) .) . ((((.) .) .) .) . join . (ap .) . ((flip .) .) . (flip .) . flip)
10:23:44 <lambdabot> optimization suspended, use @pl-resume to continue.
10:23:50 <eu-prleu-peupeu> you guys rock
10:23:57 <Warrigal> Sometimes, pl give you something huge.
10:24:18 <c_wraith> Ok...  This works, but it feels...  horrible.  Please tell me I'm missing a use of the list monad somewhere:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8818#a8818
10:24:32 <monochrom> Loop conservatists should preach their religion with "imagine what if you're on a deserted island with only a programming langauge that supports only loops".
10:25:23 <eu-prleu-peupeu> this is like automagic code generation!
10:25:35 <Warrigal> To an extent.
10:25:35 <eu-prleu-peupeu> great :)
10:25:44 <c_wraith> I feel like someone's about to give an example of DOSing lambdabot. :P
10:25:51 <Axman6> monochrom: no conditionals?
10:25:54 <eu-prleu-peupeu> i have a dream, a dream where programmers are all unemployed by the power of haskell :D
10:25:58 <Warrigal> @djinn (forall a. a) -> b
10:25:58 <lambdabot> -- f cannot be realized.
10:26:07 <Warrigal> djinn is sometimes dumb.
10:26:07 <Vanadium> Someone teach djinn about unsafeCoerce :'(
10:26:10 <copumpkin> o.O
10:26:24 <ksf> ...and const.
10:26:31 <Vanadium> Right
10:26:32 <MisterN> @djinn unsafeCoerce
10:26:32 <lambdabot> -- f cannot be realized.
10:26:45 <Warrigal> @djinn unsafeCoerce -> unsafeCoerce
10:26:45 <lambdabot> f a = a
10:26:46 <Berengal> c_wraith, you could make a 'select' function :: [a] -> [(a, [a])]
10:26:48 <MisterN> Vanadium: he doesn't seem to like being told about it :)
10:27:21 <c_wraith> Berengal: Would that end up doing anything particularly different from what I am already doing?
10:27:38 <Berengal> c_wraith, then 'perms ls = do {(elem, rest) <- select ls; perm <- perms rest; return (elem:perm)}
10:27:53 <c_wraith> Berengal: Sure, but that's not fundamentally different
10:28:21 <Berengal> c_wraith, it's imho much more elegant though
10:28:45 <c_wraith> Berengal: So basically, you're saying lists are a poor tool for permuting?
10:29:35 <Berengal> c_wraith, I wouldn't say that
10:29:45 <c_wraith> Hmm.  Also, that'd require a base case that's missing.
10:29:59 <c_wraith> It'd require that perms [] = [[]]
10:30:22 <Berengal> c_wraith, you're doing a lot of unneccessary pattern matching. Also, you don't need to know the length of the list to permute, which you now compute n^2 times
10:34:24 <Berengal> c_wraith,
10:34:41 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8818#a8819
10:35:06 <Phyx-> oh, i was disconnected?
10:35:14 <Phyx-> which haskell god did i piss off this time
10:35:14 <c_wraith> No, no.  I can't look at that.  I have to figure this out myself. :)
10:35:33 <Berengal> Heh
10:35:47 <Berengal> Get you nondeterministic hat on
10:35:49 <Berengal> your*
10:37:18 <mauke> > let ʙᴜᴛᴛᴇʀ = 42 in ʙᴜᴛᴛᴇʀ
10:37:20 <lambdabot>   42
10:38:07 <gwern> you know, helmuth used to say that when you anthropomorphize objects, you unanthromoprhize people
10:38:11 <gwern> makes you think
10:44:15 <monochrom> I think "objectize people" is even better wording.
10:44:51 <monochrom> However, leveling the playing field for objects and people is good.
10:45:09 <mauke> makes me think I should anthropomorphize more objects
10:46:13 <gwern> mauke: I think the japanese with their moe anthropomorphism have filled the global quota
10:46:44 <monochrom> Unlimited anthropomorphism for just $30 a month!
10:46:52 <dons> ?yow
10:46:53 <lambdabot> NATHAN ... your PARENTS were in a CARCRASH!!  They're VOIDED -- They
10:46:53 <lambdabot> COLLAPSED They had no CHAINSAWS ... They had no MONEY MACHINES ... They
10:46:53 <lambdabot> did PILLS in SKIMPY GRASS SKIRTS ... Nathan, I EMULATED them ... but
10:46:53 <lambdabot> they were OFF-KEY ...
10:46:57 <dons> huh
10:47:03 <monochrom> But more seriously, why should there be a quota?
10:47:21 <monochrom> And why should there be the axiom that objectizing people is bad?
10:47:53 <gwern> but desden codak had a good point there. I was just reading some philosopers on transhumanism, and they point out that if you humanize objects like programs, then logically you're also objectifying humans, which is easy to forget
10:47:58 <eu-prleu-peupeu> ahah
10:47:58 <Phyx-> lambdabot is voilent
10:47:59 <eu-prleu-peupeu> :D
10:48:17 <eu-prleu-peupeu> amazing
10:50:06 <monochrom> Every rhetoric like this tries to expose your double standard or other cognitive dissonances by pointing out that you have a dilemma. So far so good. Then it goes on as though you have only one way out of the dilemma, forgetting that every dilemma has two ways out.
10:50:45 <mauke> wait, I have a dilemma?
10:51:25 <gwern> monochrom: dilemmas have at least 3 ways out
10:51:30 <monochrom> Here is another example. A vegetarian preaching ad I saw recently shows a kitten and a chicken, and says "why love one but eat the other?"
10:52:18 <gwern> monochrom: less meat on the kitten
10:52:22 <mauke> that has at least three answers and four reactions
10:52:35 <monochrom> It thinks the only logical conclusion is "love both, eat neither". I think an equally logical and in addition more delicious conclusion is "I love cats and chickens! I eat them for breakfast."
10:52:49 <gwern> monochrom: but you don't eat cats for breakfast
10:53:15 <gwern> so at the least there is a dissonance between your stated preferences and revealed preferences, as the economists might say
10:53:28 <mauke> I don't eat chickens for breakfast
10:53:37 <Phyx-> gwern: cats sound good right about now...
10:53:52 <mauke> I can love and eat cats/chickens
10:54:05 <dm`> If ByteString.cons is O(n), why isn't there an O(1) operation to append a single byte to a ByteString?
10:54:13 <mauke> I'm more likely to eat chicken because that's what's actually sold here
10:54:23 <copumpkin> dm`: ?
10:54:28 <mauke> dm`: that sounds impossible
10:54:28 <dsouza> cats eating chickens is even more lovely
10:54:30 <copumpkin> dm`: there are two bytestrings
10:54:40 <dsouza> s/is/are/
10:55:26 <gwern> dm`: to get O(1) append wouldn't you need a rope?
10:55:40 <dm`> Both Lazy and regular ByteString only have cons.  There's append, but that requires the overhead of creating another ByteString.  I want to build up a string one character at a time, but efficiently.  I even know the final size the string will be.
10:55:43 <gwern> not just a bytestring?
10:55:55 <uzytkownik> Hmm. One could says that the intelligence is the difference between chicken and cat...
10:56:18 <gwern> uzytkownik: there isn't that much a distinction. and reputedly pigs are smarter than most cat breeds
10:56:28 <dm`> I mean O(1) amortized.  Obviously you might need to grow the buffer at some point.  But ByteString.cons seems to call memcpy every time.
10:56:33 <badsheepy> course chickens are no good at eating vermin on your pile of grain :o
10:56:36 <copumpkin> dm`: if you want to build something up
10:56:39 <copumpkin> use http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Lazy.html#v%3Aunfoldr
10:56:52 <gwern> badsheepy: chickens are fine for eating the insect vermin!
10:57:21 <gwern> but seriously, don't ropes made of bytestrings give you O(1) append? I could've sworn that was one of their neat properties
10:57:25 <monochrom> uzytkownik: The ad claims that they have similar levels of intelligence, probably chickens are a bit ahead.
10:57:25 <BMeph> monochrom: I know I'm about fifteen minutes late, but I still prefer "objectify". :)
10:57:26 <dm`> Oh, I was looking at the wrong ByteString!  Duh.
10:57:41 <monochrom> Oh! objectify is right.
10:57:50 <gwern> -_-
10:57:51 <dm`> But still, it's weird that the reverse order is prefered.  I can always call reverse at the end I suppose.
10:58:09 <gwern> of course objectify is right, it's the word I used
10:58:41 <uzytkownik> gwern: Therefore I said 'one' not I. I'd love situation when we can use a replicator from Star Trek to get meat. However in certain cases (especially childs) we have no good replacement for it.
10:58:52 <gwern> monochrom: of course, it's not like babies are very smart either
10:59:14 <monochrom> Oh I love babies too. Like I love newbies.
10:59:27 <gwern> they do some things yeah but not nearly as much as a full grown chimp or grey parrot or sheep dog or doplhin
10:59:39 <gwern> monochrom: you live to serve them?
10:59:43 <gwern> (for dinnner)
10:59:50 <monochrom> I just don't eat those objects who learn Haskell.
11:00:03 <badsheepy> id eat a dolphin
11:00:03 <badsheepy> they are smug
11:00:19 <copumpkin> dm`: an unfold is still probably more efficient if you want to build it up, and allows you to build things up at the end
11:00:22 <ski> but who will eat the eaters !?
11:00:39 <badsheepy> a chilling thought :o
11:00:55 <badsheepy> probably people with giant forks
11:00:56 <monochrom> fix eat
11:01:28 * ski gives monochrom a paradox from Russel
11:01:33 <BMeph> "I love children, but I could never eat a whole one"? ;p
11:01:47 <monochrom> haha
11:02:08 <gwern> BMeph: have you been hanging around rec.humor.dead-babies again?
11:02:29 <copumpkin> or a modest proposal
11:03:57 <BMeph> gwern: Eight years with "Uncle Sam's Misguided Children" does strange things to a man's soul... ;)
11:05:44 <monochrom> I too wonder why just because you generate the characters of a string in the forward direction, you need append to store it.
11:06:26 <monochrom> I mean, the inference seems to assume imperative programming.
11:06:31 <SamB_XP> monochrom: I don't even know what you just said
11:06:44 <monochrom> It's OK.
11:08:13 <dm`> hmm... unfoldr might indeed be what I was looking for.  Thanks!
11:08:41 <SamB_XP> oh, you said the characters of ...
11:09:33 <ksf> are there any reasons left why stream-fusion shouldn't be the default list implentation?
11:09:58 <ksf> I've read something about a ghc glitch that made something not fuse as it should, but that was ages ago.
11:10:03 <SamB_XP> doesn't trac allow bug dependencies ??
11:10:21 <ksf> I guess that's called a "duplicate"
11:10:26 <SamB_XP> there should be a bug about the fact that stream fusion isn't integrated yet, depending on those other issue's bugs ...
11:10:33 <gwern> ksf: the reason is we don't live in a perfect world!
11:10:35 <SamB_XP> ksf: not the same thing at all
11:10:49 <SamB_XP> last I heard, there were supposed to be some actual reasons
11:10:58 <dsouza> what is stream-fusion?
11:11:06 <ksf> http://www.cse.unsw.edu.au/~dons/streams.html
11:11:10 <SamB_XP> dsouza: have you heard of foldr/build fusion?
11:11:21 <ksf> ...and there's also http://hackage.haskell.org/trac/ghc/ticket/915
11:11:24 <SamB_XP> stream fusion is supposed to be it's more-powerful replacement
11:11:28 <ksf> slated for 6.12
11:11:56 <dsouza> SamB_XP: nope, not really.
11:12:14 <SamB_XP> there are some academic papers you could read, I think ;-)
11:12:19 <ksf> it was slated for 6.8 once, though.
11:12:25 <ksf> the stream-fusion paper is fun.
11:12:30 <SamB_XP> but I don't think anyone's figured out how to prove stream fusion correct yet :-(
11:12:34 <ksf> It's a good read and interesting.
11:12:42 <SamB_XP> ksf: what was the name again?
11:12:48 <dsouza> ok I'll try to read that one :-)
11:13:03 <ksf> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html   From Lists to Streams to Nothing at All
11:13:43 <SamB_XP> hmm ... needz moar punz, but still a better title than average ;-)
11:14:09 <ksf> ...but the "nothing at all" part is true.
11:14:10 <monochrom> From kittens to burgers to nothing at all.  How about that? :)
11:14:33 <ksf> all code suddenly disappears into a black hole, all fixpoints are fused into one...
11:15:05 <gwern> in the end, there is only True
11:15:49 * EvilTerran thought that'd be "return ()" :P
11:16:38 <c_wraith> Berengal:  what I have now uses ++ instead of length.  That's not an improvement
11:17:29 <gwern> EvilTerran: well, Parmenides proved that Nothing cannot exist, so obviously that's not it
11:18:02 <monochrom> > listToMaybe []
11:18:03 <lambdabot>   Nothing
11:18:22 * monochrom proved that Parmenides cannot exist.
11:18:33 <gwern> monochrom: but Nothing is something; I can pass it around and manipulate it and such
11:19:21 <Berengal> c_wraith, why are you using ++?
11:19:25 <Lemmih> gwern: If nothing is something, isn't everything nothing?
11:19:25 <monochrom> I agree that Nothing exists.
11:19:46 <gwern> Lemmih: the Haskell Nothing is something, but it isn't an actual ntohing
11:19:48 <copumpkin> why isn't jhc on hackage by the way?
11:19:55 <c_wraith> Because I can't figure out how to do it with (:)
11:19:58 <thaldyron> According to the documentation, STM.retry blocks the current thread until one of the TVars that were read in the transaction are modified. So when I only write a value to a TVar in a transaction and then retry, I should be blocked forever, right?
11:19:59 <Lemmih> copumpkin: John doesn't want it there.
11:19:59 <gwern> copumpkin: because john hates cabal
11:20:00 <endojelly> > let f x = show (length x) ++ f x in f ""
11:20:01 <SamB_XP> copumpkin: because john doesn't like cabal
11:20:01 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
11:20:05 <copumpkin> wow
11:20:11 <MisterN> , dict
11:20:13 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
11:20:19 <copumpkin> is his position outlined somewhere? beyond "I hate it"
11:20:30 <SamB_XP> copumpkin: I can't really blame him, considering how GHC-centric it is in practice
11:20:33 <pr> , length dict
11:20:34 <monochrom> thaldyron: I think yes.
11:20:35 <lunabot>  479830
11:20:37 <MisterN> , reverse dict
11:20:38 <Berengal> c_wraith, you want to generate one permutation at a time and append it to a list of accumulated permutations. That's easily done with (:)
11:20:39 <lunabot>  ["ZZZ","zZt","Zz","ZZ","zyzzyvas","zyzzyva","Zyzzogeton","Zyzomys","zythu...
11:20:50 <SamB_XP> copumpkin: though the specifics of his hatred do not necessarily know any logic
11:20:58 <gwern> copumpkin: it's sort of outlined in some old -cafe threads
11:21:03 <SamB_XP> well, I mean, some of them are logical enough!
11:21:13 <thoughtpolice> copumpkin: he thinks cabal has made some dubious design decisions and simply thinks autoconf etc is better for JHC
11:21:16 <SamB_XP> you can also finds some ranting on the JHC list a bit back
11:21:26 <copumpkin> ah
11:21:38 <thaldyron> monochron: Mhm, in my sample code the thread is woken up if another thread writes the TVar...
11:21:46 <thoughtpolice> copumpkin: patches to put JHC on hackage were the start of LHC, on that note :p
11:21:56 <copumpkin> thoughtpolice: ah I see
11:21:59 <c_wraith> Berengal: It's creating the sublists to permute that is now using ++
11:22:01 <thoughtpolice> then we dumped john's code because it was just too broken. :/
11:22:05 <gwern> which reminds me, I need to redo my cabalization of drift
11:22:11 <thoughtpolice> and now we have Lemmih's code which is great! :)
11:22:12 <gwern> just to spite him for insulting my cabalization
11:22:15 <copumpkin> :)
11:22:17 <SamB_XP> copumpkin: honestly, the current core packages are not a good fit for JHC ...
11:22:20 <monochrom> thaldyron: That's consistent with the doc and your conclusion.
11:22:24 <copumpkin> ah
11:22:42 <copumpkin> thoughtpolice: I submitted an epic ghc trac ticket last night by the way :P
11:22:49 <gwern> (oh, john whines how I forgot to include some script WHICH NO ONE EVER USED! so obviously it has to be deleted. I don't blame ross for deleting it, but it still rankles)
11:22:55 <thaldyron> monochrom: not really, as this should only happen if I had *read* the TVar in the transaction which I didn't
11:23:08 <SamB_XP> copumpkin: ... there are far too many extensions and such used in them :-(
11:23:15 <c_wraith> Berengal:  Lists are just not especially friendly with "pull an element out of the middle"
11:23:24 <SamB_XP> gwern: what script?
11:23:41 <gwern> SamB_XP: I don't really remember. some sh script which I think did something with stdin
11:23:42 <thoughtpolice> SamB_XP: 'ghc-drift'
11:23:46 <SamB_XP> c_wraith: well, the middle is rarely the easiest place to get something from :-(
11:23:53 <SamB_XP> thoughtpolice: what the heck is that for?
11:23:55 <thoughtpolice> it's some weird counterpart frontend type-thing for drift
11:24:02 <Berengal> c_wraith, you can write a function that instead pulls out all elements in turn
11:24:09 <Berengal> c_wraith, and returns a list of them :P
11:24:10 <thoughtpolice> SamB_XP: no clue, I just remember the ranting/yelling on -cafe a while back about it :)
11:24:13 <gwern> as I said, no one used it so it didn't even occur to me to include it
11:24:15 <SamB_XP> thoughtpolice: and he yelled over this ?
11:24:19 <thoughtpolice> SamB_XP: yep
11:24:23 <SamB_XP> does *he* use it!?!
11:24:29 <thoughtpolice> SamB_XP: well, it's because jhc used it
11:24:41 <thoughtpolice> SamB_XP: if you were to install the cabalized drift, ghc-drift would not be included
11:24:45 <SamB_XP> oh. that's not quite noone!
11:24:47 <thoughtpolice> but it is needed for the jhc build process
11:24:56 <Berengal> c_wraith, have you done any prolog?
11:25:00 <SamB_XP> that's a bit more yell-worthy than I thought ;-P
11:25:08 <idnar> heh
11:25:20 <gwern> SamB_XP: well, it's not like anyone was installing jhc at the time
11:25:23 <c_wraith> Berengal: I have not
11:25:36 <SamB_XP> gwern: what is this "install" thing?
11:25:38 <gwern> at that point jhc had gone something like 12 months without a single patch and didn't even build for me
11:25:46 <gwern> this was long before lhc
11:26:07 <SamB_XP> gwern: but still ... what else does anyone use drift for?
11:26:26 <gwern> iirc, yi used it for a while before switching to derive
11:26:37 <gwern> and a few other misc. projects used it in small capacities
11:26:54 <SamB_XP> yeah, okay, so a few people
11:27:00 <Berengal> c_wraith, okay. Well, consider the function that given a list nondeterministically returns an element of the list and the list without that element...
11:27:08 <SamB_XP> /things
11:27:24 <Berengal> This can be represented as a deterministic function that takes a list and returns a list of such pairs
11:27:53 <SamB_XP> the list monad. yay.
11:28:10 <Berengal> Nondeterministic functions can have more than one result, represented in haskell by cons  (:)
11:28:42 <Berengal> Or even no results, represented by []
11:29:19 <Berengal> Anyway, selecting one element of an empty list can't be done, so 'select [] = []'
11:29:44 <c_wraith> Blah.  Try not to directly tell me how to do the non-base case. :)
11:29:47 <gwern> SamB_XP: but I suspect that the # of non-john-related projects using drift is asymptotically approaching 0 by now
11:29:59 <gwern> not being cabalized is a problem for everyone except roundy and meachem
11:30:05 <c_wraith> Berengal:  I'd much rather have a hint.
11:30:17 <thoughtpolice> derive is quite awesome because you need no preprocessor for it
11:30:22 <thoughtpolice> biggest advantage by far :)
11:31:05 <Berengal> c_wraith, I was going to leave that up to you
11:31:06 <monochrom> The non-base cases are the easiest.
11:31:24 <ksf> cabalizing a project and learning that you don't need any custom preprocessors or stuff is creepy.
11:31:25 <Berengal> c_wraith, a hint: write two cases for 'select (x:xs)'
11:31:44 <ksf> there I was, writing elaborate ghc -E `pkgconfig` rules...
11:32:00 <Berengal> select (x:xs) is sort of recursive in itself, but it recurses in a different dimention
11:32:03 <c_wraith> Berengal:  That might be the bit I was missing.  Let me think for a while. :)
11:32:52 <ksf> the only non-hs or non-chs file left is a custom .h file.
11:33:07 <Berengal> Two equal patterns with different results won't work in haskell of course, but you can 'or' the two rhses by using :
11:33:12 <ksf> ...which gets eaten by chs without any complaints.
11:34:07 <ksf> ...and maybe I can even get rid of that, using #c #endc
11:34:47 <ksf> what came as a real surprise to me is that cabal supports pkgconfig now.
11:35:20 <ksf> ...last time I tried, I had to hack up Setup.hs
11:35:52 <ksf> so, is there any reason left why any lib shouldn't be cabalized?
11:36:45 <Saizan> ksf: it lacks preprocessor chaining and dep. analysis for preprocessors that need it
11:37:24 <ksf> mmmh yes we don't have a make.
11:38:00 <ksf> it knows about %.hs: %.chs but doesn't let you express it, at least not painlessly.
11:38:04 <c_wraith> Berengal:  Just to be contrary, I kept the name "extract". :)
11:38:07 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8822#a8822
11:38:24 <c_wraith> Also, I used a list comprehension where it was more succinct than a do block :)
11:38:35 <ksf> things like Version.hs: .EVERYTHING would be cool, too.
11:38:52 <ksf> ...so you can write your custom get-version-from-git thingie.
11:39:09 <BMeph> Someone should do an 'hsake' project, based on cabal, so that we don't wind up trying to make cabal do everything itself. :)
11:39:34 <BMeph> Just to be clear, by "Someone," I really mean "Someone else". ;)
11:39:40 <ksf> hsake is a good name.
11:40:02 <Saizan> yeah, Cabal is primarily the .cabal file format and interface, not the minimal build system bundled with it
11:40:04 <c_wraith> haskell sake?
11:40:15 * Saizan is slowly developing hbuild
11:40:20 <ksf> haskell m^Hake. or h sake.
11:40:21 <copumpkin> hbuild?
11:41:22 <Saizan> copumpkin: http://hackage.haskell.org/trac/hackage/wiki/HBuild
11:41:23 * ksf thinks Setup.hs should be abanoded altogether with build-type: Simple.
11:41:44 <Saizan> ksf: cabal-install ignores it
11:41:47 <ksf> ...the other possibility being build-Type: Setup Setup.hs
11:41:54 <ksf> cabal sdist creates it.
11:42:15 <Saizan> it's handy for distro installers
11:42:44 <Berengal> Nondeterministic programming is sort of like working with logarithms. Everything become weaker: enumerating all values becomes producing one value, predicates become tautologies...
11:42:47 <Saizan> i.e. archlinux's pacman calls the Setup.hs rather than requiring cabal-install to be installed
11:42:50 <ksf> one could argue that if you can runhaskell Setup.hs, you can build cabal-install, too.
11:43:39 <copumpkin> Saizan: ah, neat
11:43:41 <c_wraith> Now, to change it to "perms :: Eq a => [a] -> [[a]]".  This should be amusing.
11:43:49 <ksf> we could go with just foo.cabal and foo.hsake
11:43:53 <EnglishGent> another question (sorry I seem to have so many) - is there a way of persuading GHC to provide a warning if you assign a value to a variable inside a do block - but then dont use it? I've just caught a potentially dangerous bug where I was doing exactly that
11:44:22 <ksf> ...where hsake specializes on path-agnostic dependencies.
11:44:44 <ksf> (paths are the abyss of make)
11:44:46 <Saizan> EnglishGent: i'm sure there's a warning on unused bindings
11:45:01 <Saizan> ksf: what do you mean?
11:45:17 <Berengal> EnglishGent, -Wall
11:45:44 <ksf> there's just no painless way to do paths non-recursively, and recursive make is evil in general.
11:46:02 <Berengal> EnglishGent, or -fwarn-unused-binds
11:46:08 <ksf> no wonder most makefiles are autogenerated these days.
11:47:18 <ksf> if someone decides to do it, omake might be a good reference.
11:47:39 <ksf> ...it's the ocaml make and utterly scriptable (and impure)
11:47:53 * Saizan prefers the vesta system
11:48:08 <ksf> it's also a mess if you have a peek under the hood.
11:48:31 <ksf> still, it gets things like project roots right.
11:49:08 <etpace_> > foldl (\(c,s) x -> if c == ' ' then (c*2,s ++ (replicate c ' ')) else (c, s)) (1, "") "foo bar bizzle bob"
11:49:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:49:30 <ksf> there's a OMakeRoot in the root of your project, and if you call omake further down, it's going to use the OMakeRoot (with settings and stuff) as well as you current directory's OMakefile
11:50:27 <c_wraith> Berengal: Ok, this was pretty clean  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8822#a8823
11:50:30 <Saizan> still, i don't think custom makefiles should be the norm
11:51:13 <etpace_> > foldl (\(c,s) x -> if x == ' ' then (c*2,s ++ (replicate c ' ')) else (c, s)) (1, "") "foo bar bizzle bob"
11:51:15 <lambdabot>   (8,"       ")
11:51:15 <ksf> I guess it's actually a matter of making internal knowledge that cabal has configurable from the outside.
11:51:56 <Berengal> c_wraith, the guard is unneccessary
11:51:57 <EnglishGent> thanks Berengal :)
11:52:16 <c_wraith> Berengal:  Not if I want to eliminate duplicate permutations
11:52:16 <EnglishGent> it didnt warn me by default Saizan
11:52:32 <Berengal> c_wraith, that'll only happen if there's duplicates in the input
11:52:37 <EnglishGent> and as I'm writing a script to mess with my precious data - I'd much rather it be bug-free
11:52:38 <c_wraith> Berengal: Exactly
11:52:46 <EnglishGent> :)
11:52:48 <Berengal> If that's what you need, then fine
11:54:00 <c_wraith> In a lot of search problems, there can be duplicate inputs, at the level I care about.
11:54:47 <c_wraith> This whole project was the first step in teaching myself to deal with order-based searches.
11:55:05 <Berengal> Ah
11:55:42 <yitz> Saizan: an asteroid? I guess if vesta hits, that will solve all of those problems in a certain sense
11:56:16 <c_wraith> But that's enough for now.  Time to get some exercise and a shower.
11:56:39 <yitz> Saizan: link to what you really meant?
11:57:11 * ksf wonders why ghc can't figure out that my instances terminate
11:58:02 <Berengal> ksf, halting problem?
11:58:23 <ksf> ...Ive got class Foo a b | a -> b and instance Foo a b => Baz b
11:59:37 <yitz> google finds a *lot* of things called "vesta". after 3 pages, I still haven't found anything that could possibly be what Saizan is referring to.
11:59:46 <ksf> ...and use only functions from Foo that only mention b to define Baz.
11:59:57 <ksf> ...as, conversely, every Foo is a Baz.
12:00:05 <ksf> (or, rather, every b)
12:00:27 <Berengal> ksf, if you have two instances for Foo a Int, which of those should it choose?
12:00:51 <ksf> none, because it shouldn't allow those.
12:01:09 <Berengal> ksf, why not?
12:01:30 <ksf> ...because undecidability only arises if you've got more than one thing to choose.
12:01:56 <Berengal> And that's what you've got with two instances for Foo a Int
12:02:29 <ksf> ...the inntances always look like Foo SomeType SomeNewTypeForCIntOrWhatEver
12:03:10 <Berengal> ksf, you don't know that. I might have secretly written another instance. Classes are open
12:03:20 <ksf> ...my argument is that I could leave away -XUndecidableInstances and conversely have ghc error out as soon as a second instance comes into scope.
12:03:40 <ksf> but you can't hide it from ghc, it's all-knowing.
12:05:24 <ksf> that is, two instances for Foo a Baz would be an error that I'd like to be warned about, it contradicts design invariants.
12:06:06 <Berengal> ksf, class Foo a b | a -> b, b -> a?
12:06:07 <int-e> then add a fundep | b -> a
12:06:18 <ksf> I can?
12:06:22 <int-e> yes
12:06:28 <ksf> ouch.
12:06:40 <Berengal> Or class Foo a where data B a :: *
12:06:58 * Berengal dislikes fundeps
12:07:10 <ksf> no that won't work.
12:07:22 <ksf> a is an enum type b is something like CLong
12:07:40 <Berengal> class Foo a where newtype B a :: *
12:08:04 <ksf> ...that's still a single-param typeclass.
12:08:06 * dschoepe also finds type families a lot clearer/more readable than fundeps
12:08:09 <Berengal> instance Foo SomeType where newtype B SomeType = SomeNewTypeForCLong CLong
12:08:59 <ksf> ...and I want to have Foo T1 CIntNewType1, Foo T2 CIntNewType2, Foo T3 CLongNewType3
12:09:33 <Berengal> instance Foo T1 where newtype B T1 = CIntNewType1 CInt, instance Foo T2 where newtype B T2 = CIntNewType2 CInt
12:11:18 <Saizan> yitz: you should have googled "vesta system" :) http://www.vestasys.org/
12:11:20 <ksf> hmm I've also got instance (Show a, Foo a b) => Show b
12:11:47 <Berengal> instance (Show a, Foo a) => Show (B a)
12:12:56 <yitz> @google vesta system
12:12:57 <lambdabot> http://www.vestasys.org/
12:12:57 <lambdabot> Title: Vesta Configuration Management System
12:13:06 <yitz> ha. yep. thanks.
12:13:08 <ksf> but that isn't generic, is it?
12:13:20 <Berengal> Generic in what way?
12:13:21 <dschoepe> ksf: it is
12:13:31 <dschoepe> ksf: it works for any instance of Foo and Show
12:13:34 * ksf is going to have to make backups of his source and try
12:13:52 <Berengal> type families can do everything fundeps can, plus some other nifty things
12:14:18 <copumpkin> :o
12:14:20 <Saizan> Berengal: prove it!
12:14:23 <EvilTerran> Berengal, i thought there were some things that one can do but the other can't
12:14:28 <EvilTerran> both ways
12:14:46 <copumpkin> I thought they were mostly equivalent, but the type family code wasn't up to it yet
12:15:02 <Berengal> EvilTerran, such as?
12:15:05 * roconnor was under the same impression as copumpkin
12:15:07 <int-e> class Foo a b c | a b -> c, b c -> a, c a -> b ... how do you encode that?
12:15:18 <roconnor> although I'm not sure how GADTs interact with fundeps and type families
12:15:29 <copumpkin> int-e: with code that won't compile under GHC head, even
12:15:35 <roconnor> int-e: something about type equality
12:15:40 <sjanssen> it's been demonstrated that fundeps and type families are equivalent
12:16:27 <copumpkin> you'd have superclass equality constraints, but then GHC would complain about its implementation of type families not being up to the task yet
12:16:41 <copumpkin> or something like that :)
12:17:07 <ksf> typefamilies don't seem to support newtypes
12:17:23 <int-e> data families can have newtypes as members
12:17:57 <Saizan> sjanssen: with or without OverlappingInstances ?
12:18:47 <EvilTerran> ksf, iirc, if a class has an associated data type, you can use "newtype" instead of "data" in instances
12:18:49 <ksf> that is, class Foo a where newtype Bar a :: * doesn't work
12:19:15 <roconnor> have we all come to the conclusion that retuning Mabye foo is better than returning (Monad m) => m foo for partial functions?
12:19:16 <int-e> ksf: right. you have to write 'data' there, but you can still make all members newtypes.
12:19:18 <ksf> ...I'm going to try again when I come to the instance decls.
12:19:32 <int-e> s/members/instances/
12:19:37 <Saizan> roconnor: it seems so
12:19:42 <EvilTerran> ie, class Foo a where { data Bar a }; instance Foo Eek where { newtype Bar Eek = EekBar ... }
12:19:50 <roconnor> ok
12:20:57 <Berengal> Hmm, is it possible to derive instances for type families?
12:21:32 <roconnor> hmm, should I put my colour repo on code.haskell.org?
12:21:46 <int-e> Oh. TH can't deal with type families yet, IIRC.
12:22:09 <SamB_XP> Berengal: what do you mean?
12:22:15 <Saizan> is there a simple breadth first MonadPlus on hackage?
12:22:39 <Berengal> SamB, can you automatically derive, say, Show, for either the family or an instance?
12:22:57 <SamB_XP> hmm.
12:23:13 <roconnor> Saizan: almost certainly ... not sure where
12:23:20 <SamB_XP> how do you make an instance of a family again ?
12:23:46 <Berengal> SamB, data instance ...
12:23:54 <Berengal> Or in class instances, just data
12:25:11 <roconnor> What's the right version constraints I need to on the base depencency?
12:25:20 <SamB_XP> Berengal: and then you write the data constructors?
12:25:30 <Berengal> SamB, yep
12:25:37 <SamB_XP> roconnor: do you use exceptions?
12:25:39 <Berengal> The rhs is the same as any data declaration
12:25:59 <roconnor> SamB_XP: I use H98 + Hierarchical names
12:26:18 <SamB_XP> roconnor: no library functions?
12:26:56 <SamB_XP> well, anyway, if it's worked "forever" with no changes, then you can probably do (base >= 3 && base < 5) or something ?
12:27:02 <roconnor> H98 library functions via importing their heirarchial names
12:27:10 <roconnor> ok
12:27:49 <roconnor> SamB_XP: think that is a good thing to add to: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
12:27:57 <roconnor> some contraints need to be put in that example
12:28:53 <SamB_XP> roconnor: something like that ... but there would need to be guidelines about when to require base 4 and when base 3 is okay, probably?
12:29:02 <ksf> how to export a newtype constructor of a type family?
12:29:43 <roconnor> SamB_XP: ya, that ought to be described somewhere for reference
12:29:56 <Berengal> ksf, you can't, I think
12:30:03 <Berengal> ksf, you need a constructor function in the class
12:30:12 <Berengal> Or I may be wrong
12:30:15 <SamB_XP> Berengal: that sounds kind of sick
12:30:29 * Berengal tests
12:30:46 <SamB_XP> roconnor: well, I think the initial example should probably have (base >= 4, base < 5) ...
12:31:05 <roconnor> done
12:31:50 * ksf looks at his client code and sees that he doesn't actually use it.
12:31:59 <roconnor> SamB_XP: hmm, now I'm not so sure.  I have GHC 6.8, which comes with ubuntu, which only has base 3
12:32:02 <ksf> (and shouldn't)
12:32:05 <etpace_> How would I use Either to stop iterate, uh, iterating?
12:32:12 <ksf> compiles.
12:32:16 <roconnor> SamB_XP: that suggests we should be more flexable
12:32:20 <SamB_XP> roconnor: okay, sure
12:32:23 <ksf> ...and, praise haskell, runs flawlessly.
12:32:27 <poe> ?type unfoldr -- etpace_ this use maybe, check the source
12:32:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:33:09 <Berengal> ksf, module Foo (Bar(IntBar)) where class Foo a where data Bar a \n instance Foo Int where newtype Bar Int = IntBar Char
12:33:26 <SamB_XP> roconnor: but probably there should always be a (base < $next-major-version-to-be-released)
12:33:42 <roconnor> that appears to be required by hackage's upload
12:33:47 * ksf thinks he tried that.
12:33:57 <Berengal> ksf, I just did, and it worked
12:34:04 <ksf> ...anyway, clients shouldn't care about what a Bar contains.
12:34:13 <ksf> I might be mistaken.
12:34:30 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8816#a8816 any tips on tidying that up? its quite a mess
12:34:33 <Berengal> No they shouldn't... silly clients always wanting to look at people's internals...
12:34:43 <ksf> ...the whole point is to hide all that usage of Bits CLong, after all.
12:35:47 <etpace_> I dont' think I can use that poe, as im iterating concatMap
12:35:53 <Berengal> etpace_, inRange
12:35:57 <Berengal> @type inRange
12:35:59 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
12:36:28 <etpace_> that sure helps
12:36:29 <Berengal> > inRange ((0,0), (9,9)) (5,6
12:36:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:36:32 <Berengal> > inRange ((0,0), (9,9)) (5,6)
12:36:34 <lambdabot>   True
12:36:42 <Berengal> > inRange ((0,0), (9,9)) (11,3)
12:36:44 <lambdabot>   False
12:38:34 * ksf always feels his zen pushing if he looks at that associated type.
12:38:57 <ksf> somehow, type families seem to be more straight-forward, in the scope sense.
12:39:41 <Berengal> ksf, I love them for their reduction of MPTCs. There's few things as confusing as MPTCs, especially when there's fundeps involved, because they don't show up in constraints
12:39:55 <Berengal> s/constraints/contexts
12:40:34 <ksf> ...the haddock doesn't mention my Monoid, Read and Show instances.
12:41:00 <ezyang> No instance for (GHC.Exception.Exception MyError); how should I go about debugging this error?
12:41:33 <EvilTerran> etpace_, is m an array?
12:42:19 <etpace_> yes
12:42:29 <badsheepy> i have this function here http://haskell.pastebin.com/d50ce6245 that i thought would be nicer rewritten as filter.. but it loses its stopping point if i do so
12:42:49 <badsheepy> is there a nice function i could use to do that :)
12:43:00 <ksf> ...you know that you're coding haskell if you don't even run your program, just check if it compiles.
12:43:10 <ezyang> badsheepy: takeWhile?
12:43:27 <badsheepy> oh yeah, i could just takewhile ont he filter
12:43:29 <badsheepy> how silly of me
12:43:30 <badsheepy> hehe
12:43:31 <badsheepy> ty:D
12:46:03 * Phyx- is in a coding mood
12:46:04 <Phyx-> so he will
12:46:07 <ezyang> Ok, I need help
12:46:36 <Knight_Lord> Hi, i'm trying to write my first haskell program. How do I convert an Int to a String?
12:46:39 <Phyx-> ezyang: with?
12:46:43 <Phyx-> Knight_Lord: show
12:46:43 <dschoepe> Knight_Lord: show
12:47:02 <ezyang> Phyx-: A typecheck error
12:47:04 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8826#a8826
12:47:05 <Knight_Lord> Many thanks
12:47:23 <Phyx-> ezyang: where?
12:47:26 <Berengal> ezyang, what's the error?
12:47:40 <ezyang> The error is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8827#a8827
12:47:50 <EvilTerran> etpace_, i'd write that function as http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8816#a8828
12:48:11 <ezyang> I think I am fundamentally misunderstanding the way Control.Exception works
12:48:22 <dschoepe> ezyang: you need to make MyError an instance of Exception
12:48:30 <Phyx-> ezyang: well, you need to create an instance of Exception for MyError
12:48:45 <EvilTerran> etpace_, er, that "inRange (bounds m) xy" should be "inRange (bounds m) (add xy)", but aside from that
12:48:52 <ezyang> Ah, so the error message is correct
12:49:06 <etpace_> ahh, short circuiting with and
12:49:08 <etpace_> good idea
12:49:19 <Phyx-> ezyang: yes, you only have an instance of Error defined, Error does not imply Exception
12:49:22 <Berengal> ezyang, Error is used by MonadError, which has throwError. throw is used by the exception system
12:49:25 <ezyang> dschoepe: Do I need the Error?
12:49:34 <EvilTerran> etpace_, oh, and the parameter to isFree should be just "xy", not "(x,y)". i gotta proof-read better <.< >.>
12:49:45 <ezyang> or if I'm using the exception system, I don't really need the monad system?
12:50:09 <Berengal> They're two different ways of dealing with exceptions
12:50:38 <Berengal> MonadError can deal with exceptions in a pure way. Control.Exception uses asynchronous exceptions, which are a completely different beast
12:51:10 <EvilTerran> etpace_, it's a shame there isn't some kind of "tryIx :: Array i e -> i -> Maybe e" that does the bounds check for you, really
12:51:27 <hackagebot> colour 2.3.0 - A model for human colour/color perception (RussellOConnor)
12:51:39 <ezyang> Berengal: Ah, so it looks like I actually want MonadError in this case
12:51:59 <Philonous> badsheepy: takeWhile can't prevent you from geeting cought in a loop. But why don't you just "divisors' [1.. ceiling . sqrt . fromIntegral $ num]"?
12:52:06 <thaldyron> I've just had a look at "Lightweight concurrency primitives for GHC" and I'm wondering if anyone knows if the described prototype implementation of the RTS is available somewhere?
12:52:22 <Philonous> You'd even replace n multiplications with one sqrt.
12:52:23 <EvilTerran> etpace_, otherwise you could write that last line as "isFree = maybe False (`elem` [Future, Finish]) . tryIx m". oh well.
12:52:27 <Berengal> ezyang, if you plan on catching it later, yes. Although IO doesn't treat them very differently at all
12:52:55 <EnglishGent> Knight_Lord - (show x)
12:53:12 <etpace_> that is a bit cleaner
12:53:12 <ezyang> Berengal: I may want to implement some kind of global catch which prints out something nice
12:53:16 <EnglishGent> works for any showable type - which includes ints and a lot more :)
12:53:17 <EvilTerran> Philonous, there's something kinda ugly about resorting to floating-point math in an integer problem
12:53:48 <ezyang> `noMsg' is not a (visible) method of class `Error' ?
12:54:20 <Berengal> ezyang, if you plan on having this at the very top level, I'd probably use Exception. MonadError is more to give pure computations the ability to fail
12:54:25 * roconnor looks around for GMP's integer square root
12:54:37 <ezyang> ok
12:55:39 <Philonous> EvilTerran: I agree, though I think square roots are rather common in integer problems.
12:55:50 <ezyang> Berengal: copy that
12:56:12 <EvilTerran> Philonous, yeah, it'd be nice if there was an efficient integer square root function in the bundled libs.
12:58:49 * ksf wants haddock comments on instances
12:59:06 <Phyx-> @src ModuleName
12:59:07 <lambdabot> Source not found. You type like i drive.
12:59:18 <Phyx-> @index ModuleName
12:59:18 <lambdabot> bzzt
12:59:21 <thoughtpolice> @seen dons
12:59:21 <Phyx-> :|
12:59:22 <lambdabot> dons is in #haskell, #yi, #concatenative, #haskell-in-depth, #ghc, #xmonad, #darcs and #arch-haskell. I last heard dons speak 2h 5m 44s ago.
12:59:31 <endojelly> aren't square roots already very elementary once you have distances on so much as 2-dimensional planes?
13:00:01 * Phyx- dives into the wide world of undocumented GHC api....
13:00:19 <Berengal> Phyx-, don't forget your goggles!
13:00:25 <ksf> ...and wth does haddock duplicate class documentation?
13:01:50 <Phyx-> Berengal: yup, can't forget the protective head and eyewear!
13:03:34 <etpace_> What's wrong with throw test catch e -> putStrLn (show e)? I'm getting invalid syntax for `->'
13:04:02 * Phyx- curses at the fact that the ghc documentation is missing a "source" button
13:04:20 <Berengal> etpace_, throw test `catch` (\e -> putStrLn (show e))
13:04:42 * roconnor sudo rm -r /usr/local/lib/*/ghc-6.6*/
13:05:20 <ksf> is there a class for a -> a -> Bool that isn't Eq?
13:05:23 <Phyx-> roconnor: ?
13:05:39 <roconnor> I just ran that command
13:05:39 <ksf> ...more like (a .&. a) /= 0
13:05:45 <roconnor> I think it is useful enough to share
13:05:57 <Phyx-> heh
13:06:04 <ksf> or should I just use Eq?
13:06:25 <skorpan> :t (.&.)
13:06:26 <lambdabot>     Ambiguous occurrence `.&.'
13:06:26 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
13:06:26 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
13:06:33 <skorpan> :t Data.Bits..&.
13:06:34 <lambdabot> parse error on input `Data.Bits..&.'
13:06:38 <skorpan> ...
13:06:44 <roconnor> ksf: you should only use Eq for equivalence (or maybe partial equivalence)
13:06:49 <Gracenotes> ==^.&.^==
13:06:58 <ksf> :t Data.Bits.(.&.)
13:07:00 <lambdabot> Couldn't find qualified module.
13:07:06 <Deewiant> :t (Data.Bits..&.)
13:07:08 <lambdabot> forall a. (Bits a) => a -> a -> a
13:07:24 <skorpan> @instances Bits
13:07:25 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
13:07:25 <Stinger> THAT fixes it? :/
13:07:29 <skorpan> @instances Data.Bits.Bits
13:07:29 <lambdabot> Int, Integer
13:07:34 <ksf> well HasX != HasXY.
13:07:46 <Gracenotes> :t (Test.QuickCheck..&.)
13:07:47 <lambdabot> forall prop1 prop2. (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
13:08:00 <Gracenotes> meh. I sayeth.
13:08:08 <roconnor> Phyx-: freed up 37M ... I guess that isn't very much
13:08:30 <etpace_> geez, it complains about ambiguity with Control.Exception Berengal, but i need my type to be an instance of Exception, (the docs was where I picked up my incorrect attempt beforehand), any ideas?
13:09:00 <ksf> wait the whole thing needs to care about association
13:09:15 <Phyx-> hmmm my preprocessor is performing beautifully... go little converter go!
13:09:22 <Berengal> etpace_, which ambiguities?
13:09:45 <etpace_> Prelude.catch and Control.Exception.catch
13:09:58 <Berengal> etpace_, import Prelude hiding (catch)
13:10:20 <Berengal> Or import qualified Control.Exception as E and use E.catch
13:10:26 <ksf> HasXY `foo` HasX should return false, not true.
13:10:30 <etpace_> ok, thanks
13:10:46 <ksf> ...provided that HasXY == HasX || HasY
13:11:24 <ksf> ...which makes me think of... a Bool typeclass!
13:11:31 <skorpan> not again
13:11:54 <ksf> which would allow me to stop thinking about a monoid instance.
13:12:21 <etpace_> How can I add a type decleration for a lambda
13:12:38 <skorpan> ::
13:13:04 <roconnor> types for lambda variables is an extension of H98 IIRC
13:13:07 <etpace_> > \e :: Int -> e + 5
13:13:08 <lambdabot>   Illegal result type signature `Int'
13:13:08 <lambdabot>    Result signatures are no longer supp...
13:13:21 <Deewiant> :t \(e :: Int) -> e + 5
13:13:21 <etpace_> I seem to need it to throw/catch
13:13:22 <lambdabot> Int -> Int
13:13:33 <ksf> ...what I want is (a `xor` not b) /= 0
13:13:36 <roconnor> > \(e :: Int) -> e + 5
13:13:37 <lambdabot>   Overlapping instances for GHC.Show.Show
13:13:37 <lambdabot>                              (GHC.T...
13:13:44 <ksf> clearly, I didn't write enough c lately.
13:13:45 <skorpan> ksf: xor is (/=)
13:13:48 <mauke> :t \e -> (e :: Int) + 5
13:13:50 <lambdabot> Int -> Int
13:13:51 <Berengal> -XScopedTypeVariables
13:14:06 <Berengal> etpace_, ↑ that was for you
13:14:10 <ksf> skorpan, but only for single bits.
13:14:24 <skorpan> ksf: zipWith (/=) ? :/
13:14:25 <ksf> ...otherwise, the codomains differ.
13:14:27 <skorpan> *tries hard*
13:14:27 <etpace_> I need that as well as DeriveDataTypeable it seems
13:14:37 <ksf> I've got a CLong, not a list.
13:14:42 <Berengal> Put it in a LANGUAGE pragma
13:14:47 <skorpan> @hoogel CLong -> List
13:14:47 <lambdabot> Maybe you meant: hoogle hoogle+
13:14:52 <skorpan> @hoogle CLong -> List
13:14:53 <lambdabot> Warning: Unknown type List
13:14:53 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:14:53 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
13:14:55 <skorpan> (i'm kidding)
13:17:09 <ksf> (a `xor` complement b) /= 0 is utter nonsense.
13:17:52 <Phyx-> @hoogle lexTokenStream
13:17:53 <lambdabot> No results found
13:17:56 <Phyx-> god damnit
13:17:58 <Vanadium> Is there a button to make "cabal install foo" install foo so that jhc can see it?
13:18:01 <ksf> @check \a b -> ( a `xor` (complement b) /= 0 ) == True
13:18:02 <lambdabot>   Add a type signature
13:18:02 <Phyx-> don't tell me they changed that again
13:18:16 <ksf> @check \a b -> ( (a :: CLong) `xor` (complement b) /= 0 ) == True
13:18:17 <lambdabot>   Not in scope: type constructor or class `CLong'
13:18:23 <ksf> @check \a b -> ( (a :: Int) `xor` (complement b) /= 0 ) == True
13:18:24 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n0\n"
13:18:30 <ksf> @check \a b -> ( (a :: Int) `xor` (complement b) /= 0 ) == False
13:18:31 <lambdabot>   "Falsifiable, after 0 tests:\n1\n1\n"
13:19:02 <ksf> @check \a b -> ( (a :: CUInt) `xor` (complement b) /= 0 ) == True
13:19:03 <lambdabot>   Not in scope: type constructor or class `CUInt'
13:19:06 <MisterN> @check x == x
13:19:08 <lambdabot>   "OK, passed 500 tests."
13:19:14 <MisterN> @check x == 0
13:19:15 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:19:32 <MisterN> @check x >= 0
13:19:33 <lambdabot>   "OK, passed 500 tests."
13:19:37 <MisterN> haha
13:19:40 <skorpan> @check x > 0
13:19:41 <lambdabot>   "OK, passed 500 tests."
13:19:46 <ksf> @check \a b -> a >= 0 && b >= 0 && ( (a :: Int) `xor` (complement b) /= 0 ) == True
13:19:47 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n-3\n"
13:19:48 <skorpan> @check x > 10
13:19:49 <lambdabot>   "OK, passed 500 tests."
13:19:53 <skorpan> heh, x is huge!
13:19:56 <MisterN> @check x > 1000
13:19:57 <lambdabot>   "OK, passed 500 tests."
13:20:01 <medfly> !
13:20:01 <MisterN> @check x > 100000000
13:20:02 <lambdabot>   "OK, passed 500 tests."
13:20:04 <ksf> @check \a b -> a >= 0 && b >= 0 || ( (a :: Int) `xor` (complement b) /= 0 ) == True
13:20:05 <lambdabot>   "Falsifiable, after 1 tests:\n2\n-3\n"
13:20:07 <skorpan> @check x > 10000000000000000000000000000
13:20:08 <lambdabot>   "OK, passed 500 tests."
13:20:09 <medfly> huh, what
13:20:09 <MisterN> @check x < 100000000
13:20:10 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:20:15 <Deewiant> skorpan: \x -> x
13:20:17 <MyCatVerbs> skorpan: what!?
13:20:20 <MisterN> man what is x
13:20:20 * ksf should get some rest.
13:20:24 <Deewiant> > fromIntegral 1000000 :: Expr
13:20:26 <MisterN> @check x > 1000000000000000000000000000000000000000000000000000000000
13:20:26 <lambdabot>   1000000
13:20:27 <lambdabot>   "OK, passed 500 tests."
13:20:34 <skorpan> > x
13:20:36 <lambdabot>   x
13:20:37 <MisterN> @check x > 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000
13:20:38 <lambdabot>   "OK, passed 500 tests."
13:20:40 <Phyx-> is there a difference between GHC.Ptr and the one in Foreign?
13:20:40 <Deewiant> @check \x -> x > 100
13:20:40 <medfly> that's not right, is it?
13:20:42 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
13:20:58 <medfly> @check \x -> x > 10
13:20:59 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
13:21:15 <MyCatVerbs> Phyx-: IIRC no, but use the one in Foreign anyway 'cuz the name "GHC.Ptr" isn't portable.
13:21:20 <Deewiant> It's just x :: Expr, which evidently is greater than any integer :: Expr
13:21:22 <medfly> @check \x -> x /= 10
13:21:24 <lambdabot>   "Falsifiable, after 139 tests:\n10\n"
13:21:27 <medfly> :o)
13:21:27 <Phyx-> MyCatVerbs: ok, thanks
13:22:04 <skorpan> is it possible to generate a pseudorandom number using ST?
13:22:56 <Vanadium> @check \x -> quickCheck (/= x)
13:22:57 <lambdabot>   Not in scope: `quickCheck'
13:22:59 <Vanadium> aaww
13:23:31 <MyCatVerbs> skorpan: What, out of nowhere? ST is required to be deterministic, so no.
13:23:45 <Knight_Lord> Can anyone help me with my instance Show http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3450#a3450 ?
13:23:49 <ksf> what I _really_ want is a .&. b == a
13:23:49 <roconnor> @seen cabal
13:23:50 <lambdabot> Last time I saw cabal was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
13:23:50 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
13:23:50 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 9m 14d 22h 2m 35s ago, and .
13:24:00 <roconnor> ... I wasn't expecting that
13:24:01 <MyCatVerbs> skorpan: If you mean can you write RNGState -> (Int, RNGState) in the ST monad, then sure, but you can write that in pure code too.
13:24:08 * MyCatVerbs smacks roconnor upside the head.
13:24:11 <mauke> preflex: seen cabal
13:24:11 <preflex>  Sorry, I haven't seen cabal
13:24:14 <Knight_Lord> It says i can't do pattern matching in instance declarations but i don't really know how to fix it
13:24:20 <skorpan> MyCatVerbs: well, i meant some equivalent of the IO random
13:24:33 <roconnor> @seen dcoutts
13:24:34 <lambdabot> I saw dcoutts leaving #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone 13h 56m 44s ago, and .
13:24:39 <mauke> Knight_Lord: missing (
13:24:43 <MyCatVerbs> skorpan: You could store the current RNG state in an STRef.
13:24:47 <mauke> Knight_Lord: missing 'show'
13:24:57 <inimino> @seen lambdabot
13:24:57 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
13:24:57 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
13:24:57 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
13:24:57 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
13:24:58 <MyCatVerbs> skorpan: You might as well use StateT ST instead, as do that.
13:25:09 <MyCatVerbs> inimino: please don't trigger that on purpose.
13:25:10 <skorpan> MyCatVerbs: but the RNG would still come from IO, right?
13:25:13 <Knight_Lord> mauke: appart from the (
13:25:20 <Knight_Lord> mauke: what missing show?
13:25:22 <skorpan> i'm not sure why i'm asking really
13:25:27 <MyCatVerbs> skorpan: If you want the initial state to actually be *random* then yes.
13:25:35 <mauke> Knight_Lord: instance Show Board where show ... = ...
13:25:36 <skorpan> got it
13:25:41 <MyCatVerbs> But you can supply an initial state in pure code just fine.
13:26:21 <MyCatVerbs> skorpan: e.g. mkStdGen :: Int -> StdGen in System.Random - note the lack of need for the IO monad.
13:27:06 <skorpan> MyCatVerbs: but if i'm going to be pure-only, the random number sequence would be the same each time i run the program, right?
13:27:20 <skorpan> so passing any integer which doesn't come from IO would be pretty useless
13:27:51 <ksf> reproducibility of randgens is important.
13:28:11 <ksf> you might, for example, save the seed you used to generate a map in the safefile.
13:28:14 <Knight_Lord> mauke: Thanks. But it still complains about The equation(s) for `show' have two arguments http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3450#a3451
13:28:27 <mauke> Knight_Lord: missing ( )
13:28:29 <skorpan> ksf: but reproducibility is not a problem in IO
13:28:30 <MyCatVerbs> skorpan: yyyep, 'zactly.
13:28:47 <MyCatVerbs> skorpan: reproducability is important in practice for algorithms that use RNGs.
13:29:05 <Knight_Lord> mauke: many thanks :)
13:29:11 <MyCatVerbs> You want to always always always save a copy of the RNG seed anyway if you're running it for data analysis.
13:29:49 <lispy> ghc-core is complaining about my use of catch.  Is there a way to make cabal dump out the core?
13:29:56 <MyCatVerbs> Just in case you get a really freakishly unlikely result, and you need to replay it to examine why it happened, for example. People do get bitten by that in practice.
13:30:07 <ksf> so, in fact, /dev/lavalamp is overrated.
13:30:10 <lispy> (or a way to make ghc-core use cabal)
13:33:47 <ksf> the biggest haskell fail is lacking typeclasses.
13:33:49 <MyCatVerbs> ksf: Maybe not. There's nothing wrong with using real randomness for your initial seeds - just make sure to save them afterwards.
13:33:51 <ksf> e.g. for Set.
13:34:05 <ksf> MyCatVerbs, sure.
13:34:15 <MyCatVerbs> ksf: oh and /dev/lavalamp is exceedingly necessary for crypto.
13:34:25 <MyCatVerbs> But that should go without saying, right? ^^
13:34:35 <lispy> ksf: IIRC, edison defines collection types and uses type classes a lot
13:34:37 <ksf> ...though it's also a good idea to let the user enter a custom seed, so they can give their favourite maps to friends.
13:34:46 <skorpan> hehe
13:35:54 <ksf> EDiSon (Efficient Data Strucutres) *groan*
13:36:58 <MyCatVerbs> ksf: Indeef. Just don't let on how low the Kolmogorov complexities of your randomly-generated maps really are when in earshot of impressionable users. ;)
13:36:58 <lispy> hmm...adding -ddump-simpl to the ghc options in your .cabal file does nothing useful
13:38:57 <MisterN> @check x != x
13:38:58 <lambdabot>   Not in scope: `!='
13:39:40 <MyCatVerbs> MisterN: /=
13:39:49 <Phyx-> @hoogle stringToStringBuffer
13:39:49 <MyCatVerbs> @check x /= x
13:39:49 <lambdabot> No results found
13:39:51 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:39:52 <Phyx-> damnit
13:39:54 <Phyx-> @index stringToStringBuffer
13:39:55 <lambdabot> bzzt
13:41:27 <sjanssen> lispy: -ddump-simpl might not work with --make
13:41:55 <lispy> sjanssen: -ddump-simpl seems to use stdout
13:42:03 <sjanssen> lispy: yes, it would
13:42:13 <lispy> it also doesn't require linking so I'm able to run it over just this one file
13:42:49 <ksf> ensuring that generated maps hold some properties isn't trivial, at all. e.g. ensuring that there is a path from the top left to the bottom right, so that units can storm the enemies' castle.
13:43:07 <ericP> quickee q: with if i edit .hs files with haskell-mode, helium them to get .lvms, how do i execute them on linux (ubuntu 9.04)?
13:43:21 * lispy is starting at Galois in October!!
13:43:23 <dons> hey all, a little announcement :)
13:43:36 <dons> yay lispy!
13:43:43 <lispy> Good times
13:44:15 <ksf> in the end you're doing things like spreading wood and water seeds over the map and let them grow, but keep distance.
13:44:34 <Phyx-> @index unsafePerformIO
13:44:34 <lambdabot> System.IO.Unsafe, Foreign
13:44:48 <lispy> dons: I did some heap profile of darcs while trying to record patches.  It uses tons of memory and I'm finding it's all lists.  And the unpackPSfromUTF8 is partialy to blame (we rewrote that during the hackathon).  Any suggestions?
13:45:23 <dons> hmm
13:45:34 <dons> what was the type of unpackPSfromUTF8 ?
13:45:37 <lispy> dons: I'm guessing the real problem is the consumer of unpackPS
13:45:44 <thoughtpolice> dons: the new ghc-core (0.5) isn't giving me colorized output :/
13:45:51 <lispy> unpackPSfromUTF8 :: B.ByteString -> String
13:45:58 <dons> thoughtpolice: hmm. it should be using the new ansi and colorize packages.
13:45:59 <ksf> ...all that while being unable to decide whether or not you should be glad that the original algorithms were coded by a two-bit engineer who just generated maps until the pathfinder succeeded to find a path...
13:46:02 <dons> thoughtpolice: checking...
13:46:30 <lispy> dons: if we're expanding bytestrings into regular strings I can see why it would be wasteful
13:46:33 <dons> thoughtpolice: works for me.
13:46:56 <lispy> so maybe I should look for ways to avoid that function...
13:47:05 <c_wraith> hmm.  laziness means that short-circuiting isn't always necessary in search functions, doesn't it?
13:47:27 <dons> lispy: yeah. that's not good
13:47:38 <dons> lispy: hmm. time to think about the Data.Text library? ...
13:47:42 <ksf> laziness means that you can return results before you've inspected the whole structure.
13:47:51 <ksf> it's best grokked with corecursion.
13:47:54 <lispy> dons: what is the pupose of Data.Text?
13:48:03 <dons> lispy: actually unpackPSfromUTF8 should have an equivalent in the utf8-string library
13:48:05 <ksf> err recursing on codata.
13:48:11 <dons> lispy: unicode packed strings
13:48:31 <ksf> don't immitate my use of words with co-, or people are going to laugh about you, too.
13:48:33 <c_wraith> ksf:  It means I was thinking about this problem upside-down.  That's nice, because I was having real trouble with it, that way. :)
13:48:34 <dons> thoughtpolice: not sure how to debug this. need more info
13:48:45 <lispy> oh here is the problem, we need to convert bytestrings to filenames
13:49:14 <dons> ok. so that should only be a small amount of data?
13:49:25 <lispy> unpackPSfromUTF8 is only called in one place
13:49:47 <lispy> Well, you might think that, but in my case, I'm using the linux source as my test
13:49:52 <lispy> lots of files
13:49:57 <dons> oh, so 1000s of little calls to this thing
13:49:59 <dons> ok.
13:50:21 <lispy> ps2fn :: B.ByteString -> FileName
13:50:21 <lispy> ps2fn ps = FN $ decode_white $ unpackPSfromUTF8 ps
13:50:26 <lispy> That's the culprit
13:50:38 <lispy> I wonder if we could just make the FileName store a bytestring and gain a lot
13:50:52 <lispy> it would probably just push the problem down
13:50:52 <dons> i did that in hmp3 back in the day
13:51:07 <dons> you can reimplement the Directory lib using bytestrings for strings
13:51:10 <dons> and never convert
13:51:16 <dons> not sure how much you care   to do that though
13:51:22 <lispy> hhmm
13:51:34 <lispy> newtype FileName = FN FilePath
13:51:41 <lispy> :t FilePath
13:51:42 <lambdabot> Not in scope: data constructor `FilePath'
13:51:48 <lispy> FilePath is just String, right?
13:51:52 <Makoryu> @info FilePath
13:51:52 <lambdabot> FilePath
13:52:00 <ksf> Stream Char?
13:52:01 <Makoryu> lambdabot: Oh, you're a great help
13:52:03 <Deewiant> ?src FilePath
13:52:04 <lambdabot> type FilePath = String
13:52:04 <Makoryu> @src FilePath
13:52:05 <lambdabot> type FilePath = String
13:52:41 <c_wraith> hmm.  my permutation code is stupidly inefficient.
13:52:54 <c_wraith> well...
13:53:04 <c_wraith> > product [1..10]
13:53:05 <roconnor> > permutations [1,2,3]
13:53:05 <lambdabot>   3628800
13:53:06 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
13:53:39 <sjanssen> lispy: where do these ByteStrings come from initially?  Is it feasible to always use them as String rather than ByteString?
13:53:39 <Deewiant> ?hoogle permutations
13:53:39 <lambdabot> No results found
13:53:47 <c_wraith> Yeah, taking minutes to evaluate "length $ f [1..10]" is bad.
13:53:48 <edwardk> gah  darcs on windows is annoying when it crashes it locks up hard
13:53:55 <sjanssen> it's plausible that String is more efficient if your filenames are not terribly long
13:54:03 <lispy> edwardk: bug reports please :)
13:54:13 <lispy> edwardk: BTW, darcs needs more windows testers/users :)
13:54:30 <lispy> sjanssen: hmm yes
13:54:43 <c_wraith> @src permutations
13:54:43 <lambdabot> Source not found. That's something I cannot allow to happen.
13:54:46 <dons> lispy: fwiw, we can set you up with full dev environments at work
13:54:55 <dons> if you need say, linux, solaris, mac, windows for testing.
13:55:15 <edwardk> lispy: just griping because i drop down to a dos shell to run it, then i can't ctrl-c to break out or anything it just goes off to lala-land
13:55:34 <lispy> dons: oh nice
13:55:39 <defun> dons: does galois hire student interns over the summer?
13:56:13 <defun> dons: or whatever the appropriate word is (employee,etc)...
13:56:27 <lispy> The galois summer of code :)
13:56:47 <defun> lispy: that would be nice, imho. ^_^
13:56:52 <lispy> edwardk: anything you can do to improve the windows experience for darcs is a win
13:57:08 <dons> defun: its easiest for us to have US interns (already eligibile to work in the US), but otherwise, yes, we do sometimes have interns
13:57:16 <lispy> edwardk: even if it's just letting us know what is frustrating
13:58:13 * dons crunches hackage stats for august
13:58:14 <defun> dons: is there some place that I can apply? I wish to work there over the summer. I'm in the US. Couldn't find anything on their website...
13:58:53 <EnglishGent> @hoogle when
13:58:53 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:59:27 <dons> defun: apply to jobs2009 (link the our recruiting emails), with your experience and resume, and state your timeframe for the internship
14:00:03 <defun> dons: thanks.
14:01:00 <edwardk> lispy: point me to where to file a bug report ;)
14:01:12 <c_wraith> Anyone see an obvious performance issue with this implementation?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8830#a8830
14:01:24 <lispy> edwardk: http://bugs.darcs.net/
14:01:35 <c_wraith> Oh, wait.  I'm running in ghci.  that might be the problem
14:05:06 <mux> > [1..] `genericIndex` 1000000000000
14:05:11 <lambdabot>   mueval-core: Prelude.read: no parse
14:05:11 <lambdabot>  mueval: ExitFailure 1
14:05:27 <mux> > [1..] `genericIndex` (1000000000000::Integer)
14:05:32 <lambdabot>   mueval-core: Prelude.read: no parse
14:05:32 <lambdabot>  mueval: ExitFailure 1
14:06:10 <c_wraith> Eh.  It's still slower than I'd expect, compiled with -O2
14:06:13 <Phyx-> @src SrcSpan
14:06:14 <lambdabot> Source not found. :(
14:06:17 <Phyx-> Oh damnit
14:06:31 <c_wraith> So, re-raising the question:  Anyone see an obvious performance issue with the source in my hpaste above?
14:06:38 <Phyx-> i hate these abstract datatypes
14:06:55 <MisterN> @src genericIndex
14:06:55 <lambdabot> Source not found. There are some things that I just don't know.
14:07:09 <MisterN> lambdabot: you apparently know nothing at all.
14:07:18 <edwardk> lispy: http://bugs.darcs.net/issue1587?@template=item&@pagesize=50&@startwith=0
14:07:42 <Phyx-> is a FastString FFI compatible?
14:08:31 <lispy> edwardk: thanks.  BTW, what version of darcs and when you say dos shell, that's cmd.exe?
14:08:39 <Phyx-> @hoogle FastString -> CWString
14:08:39 <lambdabot> Warning: Unknown type FastString
14:08:39 <lambdabot> Foreign.Ptr castFunPtrToPtr :: FunPtr a -> Ptr b
14:08:39 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
14:08:53 <Phyx-> @hoogle FastString -> String
14:08:54 <lambdabot> Warning: Unknown type FastString
14:08:54 <lambdabot> Distribution.Text display :: Text a => a -> String
14:08:54 <lambdabot> Prelude show :: Show a => a -> String
14:10:54 <mux> @rc iterate
14:10:54 <lambdabot> Maybe you meant: rc src
14:10:59 <mux> @src iterate
14:10:59 <lambdabot> iterate f x =  x : iterate f (f x)
14:12:17 <mux> > let f = (+1) in iterate f 0 `genericIndex` 1000000000000
14:12:23 <lambdabot>   mueval-core: Prelude.read: no parse
14:12:23 <lambdabot>  mueval: ExitFailure 1
14:12:29 <mux> damn.
14:13:37 <mux> alright, it seems a strict version of iterate is useful
14:13:49 <Jedai> It is :)
14:13:55 <copumpkin> iterate'
14:13:56 <copumpkin> !
14:14:36 <mux> Prelude Data.List> let f = (+1) in iterate f 0 `genericIndex` 10000000
14:14:36 <mux> *** Exception: stack overflow
14:14:36 <mux> Prelude Data.List> let iterate' f x = x `seq` x : iterate' f (f x)
14:14:36 <mux> Prelude Data.List> let f = (+1) in iterate' f 0 `genericIndex` 10000000
14:14:36 <mux> 10000000
14:14:54 <Jedai> Though it's pretty easy to write, it should probably be in the standard library (it's a common need)
14:15:10 <mux> I was wondering about that
14:15:44 <mux> many of the things I thought would be useful in the standard libraries turned out to be unwanted by the community
14:15:52 <copumpkin> like what?
14:16:08 <mux> I don't even remember right now :)
14:16:47 <copumpkin> :o
14:17:15 <Saizan> what's the use case for indexing into an iterate'd list? aside from one liners on irc :)
14:17:45 <EnglishGent> hi copumpkin :)
14:17:46 <Knight_Lord> I have a very simple question. I have a datatype with an Char and an Int. How can extract them from the datatype in a function? I tried a,b = x without much luck
14:17:53 <copumpkin> EnglishGent: hi!
14:18:03 <mux> Saizan: avoids having to write boilerplate code with a counter to repeatedly apply a function n times
14:18:13 <ski> Knight_Lord : what is the datatype in question ?
14:18:19 <copumpkin> Knight_Lord: if you have data MyData = Oi Char Int, then you can do f (Oi c i) = i
14:18:59 <EnglishGent> ok - I need sleep...
14:19:05 <Knight_Lord> copumpkin: many thanks
14:19:09 * EnglishGent wishes everyone a very pleasant evening - gnight all :)
14:19:21 <copumpkin> EnglishGent: g'night!
14:19:21 <mux> copumpkin: oh, there was those : http://www.haskell.org/pipermail/libraries/2007-December/008780.html
14:19:28 <Knight_Lord> EnglishGent: good night
14:19:48 <mux> copumpkin: not that it really matters - I don't remember having needed those again
14:21:15 * ski has used those, fwiw ..
14:22:03 <Berengal> I've found many functions that seem really useful and unintrusive at first, but which I've completely forgotten about later
14:22:06 <mux> it's the kind of functions you use once in a while, but it's so nice to have them ready when you need them - at least that's how I view things and why I thought it would be nice to have
14:22:26 <copumpkin> like strength!
14:22:35 <Berengal> I have to wonder though, do I forget about them because they're not standard, or is it really because they're less useful than I thought at first
14:22:39 <lispy> :t breakSpace
14:22:42 <lambdabot> Not in scope: `breakSpace'
14:22:45 <ski> and `graph',`cograph' !
14:22:54 <copumpkin> ski: what do those do?
14:23:46 <ski>   graph :: Arrow (~>) => (a ~> b) -> (a ~> (a,b))
14:23:48 <ski>   cograph :: ArrowChoice (~>) => (a ~> b) -> (Either a b ~> b)
14:24:02 <copumpkin> :o
14:24:29 <copumpkin> graph f a = (a, f a) ?
14:24:46 <ski>   graph f = id &&& f
14:24:50 <copumpkin> fair enough :)
14:24:52 <ski>   cograph f = f ||| id
14:26:05 <ski> (e.g. in
14:26:11 <ski>    tabulate ix f = array ix [f `graph` i | i <- range ix]
14:26:12 <ski> )
14:26:37 <copumpkin> makes sense
14:26:59 <copumpkin> how would you use cograph though?
14:27:22 <copumpkin> I can see how they're related, but can't think of a use case :)
14:29:08 <ski> one related operation is
14:29:10 <ski>   catEithers :: (e -> a) -> ([Either e a] -> [a])
14:29:16 <ski>   catEithers f = map . cograph
14:29:18 <copumpkin> oh!
14:29:49 <copumpkin> @hoogle catEithers
14:29:50 <lambdabot> No results found
14:29:52 <Makoryu> :t (|||)
14:29:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
14:29:57 <copumpkin> it should be in Data.Either
14:30:42 <copumpkin> Makoryu: that type signature is a lot clearer if you use an infix ArrowChoice type variable
14:31:03 <Makoryu> copumpkin: That's exactly how I was reading it, in fact
14:31:06 <mmorrow> inject :: (a -> s) -> (b -> s) -> ([Either a b] -> [s])
14:31:07 <copumpkin> ok :)
14:31:09 <ski> @type \f -> ((cograph f . fmap return) =<<) . runErrorT
14:31:10 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m a1) -> ErrorT a m a1 -> m a1
14:31:18 <copumpkin> mmorrow: isn't that +++ ?
14:31:21 <mmorrow> seems more "mathy" to me
14:31:22 <Deewiant> inject = map .: either
14:31:31 <jesboat> @pl \ (d1, w1) (d2, w2) -> (min d1 d2, w1 ++ w2)
14:31:32 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . min)
14:31:33 <Deewiant> ?ty (map .) . either
14:31:34 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> [Either a b] -> [c]
14:31:44 <copumpkin> :t (+++)
14:31:45 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
14:32:04 <copumpkin> I guess it's almost +++ but not quite
14:32:16 <copumpkin> cause it needsmoar lists
14:32:26 <copumpkin> and moar flattening
14:32:55 <mmorrow> inject :: (s -> s -> s) -> (a -> s) -> (b -> s) -> [Either a b] -> s
14:33:19 <ski> mmorrow> inject foo bar baz []
14:33:59 <mmorrow> project ::
14:34:10 <mmorrow> i can't think of a symmetric "project" for that one though
14:34:45 * copumpkin is afraid of injections
14:34:45 <Knight_Lord> If you had to represent a tic tac toe board as a datatype would you prefer a tuple a list or something? I'm trying three tuples of three but i'm not sure if it's a good ide
14:35:07 <mmorrow> data Sum s a b = Sum (a -> s) (b -> s)
14:35:18 <mmorrow> data Prod p a b = Prod (p -> a) (p -> B)
14:35:22 <mmorrow> s/B/b/
14:35:35 <copumpkin> that's cute
14:35:36 <mmorrow> i like
14:35:38 <roconnor> I would use triples of triples
14:35:46 <roconnor> but I might make my own triple type
14:35:56 <copumpkin> unboxed!
14:36:20 <roconnor> so I can make my triples traversable
14:36:26 <augustss> Maybe an Int ;)
14:36:45 <roconnor> so I apply symmetries to check rows with the same code that checks columns
14:37:39 <randomwords> roconnor: Was it you that suggested a similar datatype for a Sudoku solver?
14:37:39 <Knight_Lord> roconnor: my code to add a move doesn't look very nice http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3452#a3452
14:37:46 <augustss> > 3^9
14:37:47 <lambdabot>   19683
14:37:49 <defun> Has anyone read Concepts, Techniques and Models of Programming by Van Roy? If so, how is it? Worth a read? Worth paying for? How does it compare to Types and Programming Languages?
14:38:31 <Knight_Lord> roconnor: please bear in mind it's my first program ever
14:38:38 <ski> defun : i'd say it's worth a read
14:39:27 <defun> ski: ok! amazon.com, here I come! Thanks.
14:39:39 <ski> defun : it nicely illustrates similarities and differences in when variables are bound to denotations, and when they are evaluated, if nothing else
14:43:09 <mmorrow> augustss: heh, i just realized you meant a single Int to represent the entire board state
14:43:30 * copumpkin is playing with she
14:43:48 <mmorrow> why not her?
14:44:17 <copumpkin> don't ask me, ask conor!
14:45:13 <mmorrow> that'd be amusing if he refered to "she" as she/her depending on where in the sentence it is
14:45:59 <mmorrow> probably more s/amusing/confusing/ actually, but maybe for the best
14:46:30 <Berengal> mmorrow, possibly not amusing. We're quite used to pronouns after all
14:46:51 <Berengal> s/amusing/confusing/*
14:46:55 <roconnor> randomwords: ya, tic tac toe is just a simplified version of Sudoku ... kinda.  They can share the same triple code!
14:47:02 <mmorrow> Berengal: exactly why it would be confusing!
14:47:03 * copumpkin is having trouble writing reverse for lists with a length
14:47:39 <mux> http://hackage.haskell.org/trac/ghc/ticket/3474
14:48:12 <copumpkin> @hoogle snoc
14:48:13 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
14:48:14 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
14:48:14 <lambdabot> Data.ByteString.Lazy snoc :: ByteString -> Word8 -> ByteString
14:48:31 <roconnor> Knight_Lord: you should write modifier routines that modify rows and columns
14:48:36 <randomwords> roconnor: mmm, I remember thinking it was a witty solution - at least in concept. I've never actually seen the code written down. It intereseted me how you could possibly generalise the datatype to n x n sudoku.
14:48:54 <randomwords> It would probably be something horrible with templates
14:48:56 <mmorrow> , ppDoc <$> (let mkrev n = do xs <- replicateM n (newName "x"); lamE [tupP (fmap varP xs)] (tupE (fmap varE (reverse xs))) in mkrev 6)
14:48:57 <lunabot>  \(x_0, x_1, x_2, x_3, x_4, x_5) -> (x_5, x_4, x_3, x_2, x_1, x_0)
14:50:32 <roconnor> Knight_Lord: modifyTriple 1 new (a,b,c) = (new,b,c) ; modifyTriple 2 new (a,b,c) = (a,new,c) ...
14:50:33 <Makoryu> Knight_Lord: That's a monster of a function!
14:51:24 <Makoryu> roconnor: I was just thinking the same thing, except that I'd apply new to a
14:51:37 <randomwords> Or you could use Data.Accessor
14:51:47 <Makoryu> That is: mTr 1 f (a,b,c) = (f a,b,c); etc.
14:51:54 <roconnor> maybe modifyTriple is a bad name. updateTriple
14:52:16 <roconnor> randomwords: I couldn't decide if suggesting Data.Accessor would be too complicated for Knight_Lord
14:52:30 <Knight_Lord> roconnor: it probably would :)
14:52:50 <randomwords> roconnor: Good point. It's more machinery to deal with, but it can look cleaner.
14:53:47 <Knight_Lord> Is it possible to call main with arguments?
14:54:03 <ski>   type TicTacToe a = TTTK a Identity; newtype TTTK a k = TTTK (TK (TK (R a)) k); newtype R a k = R (k a)
14:54:07 <ski>   newtype TK ca k = TK (ca (T0 ca k)); newtype T0 ca k a0 = T0 (ca (T1 ca k a0)); newtype T1 ca k a0 a1 = T1 (ca (T2 k a0 a1)); newtype T2 k a0 a1 a2 = T2 (k (a0,a1,a2))
14:54:39 * ski is not quite satisfied with that ..
14:54:59 <roconnor> randomwords: I'd totally suggest Data.Accessor if this were not his first program.
14:55:34 <endojelly> ski, what is that?
14:55:35 <Makoryu> Knight_Lord: No. However, you can retrieve command-line arguments using System.getArgs, and in ghci you can set those with ":set args foo bar etc."
14:55:41 <roconnor> Knight_Lord: let's start with something easy.  Write to functions switchSide that returns Second given First, and vice versa
14:56:07 <ski> endojelly : why, it's a representation type for a tic-tac-toe board
14:56:08 <roconnor> Knight_Lord: and a function that given First returns Cross and given Second returns Circle
14:56:23 <endojelly> ski, why is it so complicated?
14:56:24 <roconnor> Knight_Lord: then use these function to abstract over t and cut the number of case statements in half.
14:57:18 <ski> endojelly : sadly, i think it's not complicated enough .. :(
14:57:25 <endojelly> ski, what are you trying to do?
14:57:32 <lispy> > join (Just (Just 1))
14:57:33 <mmorrow> , let pp = (vcat . fmap text); tictactoe = replicateM 3 (replicateM 3 "_ox") in pp (tictactoe !! 9934)
14:57:33 <lambdabot>   Just 1
14:57:34 <ski> have some fun
14:57:34 <lunabot>  ooo
14:57:34 <lunabot>  oxo
14:57:34 <lunabot>  xxo
14:57:41 <lispy> > join Nothing
14:57:42 <lambdabot>   Nothing
14:58:04 <mmorrow> augustss suggested a single Int as a rep
14:58:07 <Knight_Lord> roconnor: thanks for the tips. I'll do that after i finish with IO
14:58:11 <mmorrow> , 3^9
14:58:12 <lunabot>  19683
14:58:24 <copumpkin> w00t, I just wrote reverse for "lengthed vectors"
14:58:33 <ski> endojelly : it's basically a CPS version (of a sort) of a more mundane version of `TicTacToe'
14:58:41 <roconnor> Knight_Lord: Then we will work on reducing the number of cases by a factor of 3, and then by another factor of 3
14:58:45 <endojelly> ski, ooh, ok
14:58:47 <mmorrow> i'm not sure the best way to move from a given state to another though with Int
14:59:07 <maxstahl> howdy everybody
14:59:09 <maxote> can i define   rev [x0,x1,..,xn] = [xn,..,x1,x0]  and the compiler can recognize it?
14:59:30 <mmorrow> maxote: is n fixed?
14:59:47 <mmorrow> maxote: (no you can't)
14:59:50 <maxote> n is natural, it's from 0 to N
14:59:59 <ski> (endojelly : taking CPS (of a sort) of a type, is a technique still in search of a problem. i wanted an example to play with)
15:00:00 <uzytkownik> maxote: Why not reverse?
15:00:03 <endojelly> could you do that with template haskell?
15:00:07 <mmorrow> maxote: so not fixed then?
15:00:13 <copumpkin> unfortunately my reverse function is very inefficient
15:00:13 <endojelly> ski, ah!
15:00:32 <mmorrow> , ppDoc <$> (let mkrev n = do xs <- replicateM n (newName "x"); lamE [listP (fmap varP xs)] (listE (fmap varE (reverse xs))) in mkrev 15)
15:00:34 <lunabot>  \[x_0,
15:00:34 <lunabot>    x_1,
15:00:34 <lunabot>    x_2,
15:00:40 <mmorrow> , ppDoc <$> (let mkrev n = do xs <- replicateM n (newName "x"); lamE [listP (fmap varP xs)] (listE (fmap varE (reverse xs))) in mkrev 6)
15:00:42 <lunabot>  \[x_0, x_1, x_2, x_3, x_4, x_5] -> [x_5, x_4, x_3, x_2, x_1, x_0]
15:00:43 <edwardk> lispy 2.2.0 and yeah its cmd.exe
15:00:49 <maxote> i'm said all it highest declaratively.
15:00:56 <mmorrow> but if it's not fixed, TH won't help
15:01:00 <edwardk> lispy i just pulled it from the darcs site a while back
15:01:12 <copumpkin> I guess I can't write a Monad instance for vectors with length
15:01:26 <mmorrow> copumpkin: it could be like mappend for typles
15:01:29 <mmorrow> tuples
15:01:30 <copumpkin> and only the zipper-like applicative instance makes sense
15:01:50 <copumpkin> mmorrow: hmm?
15:02:20 <maxote> it seems that Haskell is still not highest level language.
15:02:36 <mmorrow> , $(tupE (fmap lift (replicate 10 [0::Int])) `mappend` $(tupE (fmap lift (replicate 10 [1::Int]))
15:02:37 <lunabot>  luna: parse error (possibly incorrect indentation)
15:02:45 <roconnor> copumpkin: sure you can, join takes the diagonal
15:02:47 <mmorrow> , $(tupE (fmap lift (replicate 10 [0::Int]))) `mappend` $(tupE (fmap lift (replicate 10 [1::Int])))
15:02:48 <lunabot>  luna: Not in scope: `mappend'
15:02:52 <mmorrow> wut!
15:02:54 <Lycurgus> maxote: no, that would be something like English.
15:03:01 <copumpkin> roconnor: interesting
15:03:13 <roconnor> copumpkin: and the usual
15:03:16 <lispy> edwardk: okay, 2.3.0 has been released, FWIW
15:03:21 <copumpkin> roconnor: the usual?
15:03:25 <lispy> edwardk: it's possible the bug was fixed?
15:03:32 <Lycurgus> or maybe the join of chinese and english
15:03:36 <roconnor> the usual monad for vectors of a fixed length
15:03:54 <ski> endojelly : it might entice you to know that `BranchK . LeafK . T0 . BranchK . LeafK . T0 . LeafK . T1 . T1 . I $ (0,(1,2))' describes a binary tree, where the branching structure is separated from the node content, and the former is taken in depth-first-order
15:04:02 <copumpkin> roconnor: ah :) I guess I don't know enough to know what's "usual" yet :)
15:04:07 <mmorrow> copumpkin: are these vectors in the math sense, or vector := "n of something"
15:04:19 <ski> (endojelly : and this was a more interesting example of a (sortof-)CPS:ed type)
15:04:21 <copumpkin> mmorrow: n of something :)
15:04:22 * roconnor has been considering making his RGB type a monad.
15:04:32 <copumpkin> where n is a type-level number
15:04:59 <copumpkin> my reverse is defined in terms of a foldr right now though :/
15:05:13 <copumpkin> which needs to use snoc, which is inefficient
15:05:43 <ksf> is a set that can have members that can be more than one element a proper set?
15:05:52 <roconnor> copumpkin: just write foldl using foldr, and then write reverse using foldl
15:06:16 <lispy> ksf: can be more than one element?
15:06:16 <augustss> copumpkin: which reverse?
15:06:16 <augustss> mmorrow: State changes is a bit of arithmetic.  Or bit fiddling with 2 bits per square.  Or you can use tables.
15:06:18 <augustss> but i'd only use an Int if I was desperate for speed
15:06:32 <copumpkin> augustss: foldr (flip snoc) [] right now
15:06:33 <ksf> like HasXY, which implies both HasX and HasY.
15:06:38 <copumpkin> which is ugly
15:07:01 <ksf> that is, there are pre-defined conjunctives which are part of the contained type.
15:07:16 <lispy> ksf: you lost me :)
15:07:19 <ski> ksf : are you talking about a set of sets ?
15:07:21 <lispy> ksf: concrete example?
15:07:27 <ksf> ...ignore the last sentence.
15:07:34 <ksf> ...and take the example of the one above.
15:07:41 * lispy wonders if ksf is tihnking of a multiset
15:07:47 <ksf> ski, no, I'm talking about bitmasks.
15:08:06 <ksf> no, I don't want a bag.
15:08:23 <Berengal> ksf, you mean a union?
15:08:29 <ski> what is this `HasX' ?
15:08:32 <lilac> roconnor: this monad: join (RGB (RGB r _ _) (RGB _ g _) (RGB _ _ b)) = RGB r g b?
15:08:38 <roconnor> ksf: Heyting Algebra!!
15:08:46 <ksf> if you HasXY is a member, then so are HasX and HasY. conversely, if bost HasX and HasY is a member, than HasXY is a member
15:08:56 <ski> lilac : yes. `(ColorAxis ->)'
15:08:57 <ksf> ski, something like "Foo"
15:08:58 <copumpkin> as types?
15:09:01 <mmorrow> augustss: ahh, the 2bits-pre-square sounds nice
15:09:01 <roconnor> lilac: that would be the one.  I just added an applicative instance, because that seems reasonably useful.
15:09:13 <edwardk> lispy: i just took the binary that was on the darcs site ;)
15:09:19 <ski> ksf : what does "member" mean, here ?
15:09:25 <roconnor> lilac: not sure where you'd want to use the full monad for RGB.
15:09:27 <lispy> edwardk: you can cabal build it now
15:09:34 <lispy> edwardk: cabal install darcs -f-curl
15:09:35 <ksf> operationally, bits are set. semantically, member of the set.
15:09:54 <lispy> edwardk: not sure what the implications are of -f-curl for http access, but I suspect it works as well as the HTTP lib
15:09:58 <edwardk> the machine in question doesn't have ghc or cabal installed =/
15:10:01 <lilac> roconnor: i can see applicative being useful, but monad seems weird :)
15:10:02 <ski> ksf : maybe s/member/subset/ ?
15:10:21 <roconnor> lilac: ya, that's why I haven't made a monad instance yet.
15:10:23 <ski>   {x,y} =< {x,y,z}
15:10:41 <ski> the `{x,y}' possibly being your `HasXY'
15:10:55 <ksf> ...exacty. HasXY is both a possible subset (HasX and HasY) of the set, but also a possible member.
15:11:05 <ski> (and `{x,y,z}' is some given set one wants to check)
15:11:05 <roconnor> lilac: since this is basically the reader monad with domain 3, the monad instance might not add anything.
15:11:30 <ski> ksf : i'd say it's just a subset, and skip talking about members, here
15:11:30 <Knight_Lord> Can i redefine MyType  + MyType?
15:11:32 <roconnor> lilac: I vaguely recall the monad reader being no more powerful than the applicative reader ... somehow.
15:11:33 <edwardk> lispy: also, if i build it directlyt with cabal will that include ssh support? or will i have to fish around and install cygwin and all that to get ssh to work in that setting?
15:11:47 <lilac> roconnor: reader applicative plus 'flip' = reader monad
15:11:50 <edwardk> lispy: without ssh support i'd basically be stuck dead in the water anyway
15:11:50 <ksf> I'm just worrying about http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Coll.html#t%3ASetX and the Eq requirement
15:11:50 <Knight_Lord> What someone from C++ would call overload + for MyType
15:11:52 <lispy> edwardk: I'm not sure
15:11:54 <roconnor> lilac: oh ya, in that ifM and ifA are equivalent in the reader monad.
15:12:03 <ksf> ...which is a bit dodgy in the presence of things like HasXY
15:12:07 <lispy> edwardk: well, maybe darcs.net has a 2.3 binary?
15:12:21 <edwardk> http://wiki.darcs.net/Binaries#for-windows-without-cygwin
15:12:32 <edwardk> 2.2.1 is the best they have, i just tried it, no dice
15:13:03 <lispy> edwardk: I guess we need Salvatore to upload a new one
15:13:13 <lispy> edwardk: we really need more windows champions :(
15:13:28 <lispy> I don't even have a windows box at home
15:13:51 <lilac> @type [ap . flip, (=<<)]
15:13:52 <lambdabot> forall a b b1. [(a -> b1 -> b) -> (b1 -> a) -> b1 -> b]
15:14:29 <edwardk> lispy: i usually use linux, but my current project is using plt scheme and that works best for me in windows
15:14:51 <lispy> edwardk: ah
15:15:07 <edwardk> i wasn't planning on bashing my head against darcs when i selected it. it was just reflex ;)
15:15:20 <copumpkin> hmm, writing this with a foldl is harder than I thought
15:15:30 <roconnor> @src reverse
15:15:31 <lambdabot> reverse = foldl (flip (:)) []
15:15:48 <copumpkin> yeah...
15:15:59 <copumpkin> I know how to do that :P
15:16:00 <ski> ksf : why not just `hasXY = union hasX hasY' ?
15:16:01 <roconnor> @src foldl
15:16:02 <lambdabot> foldl f z []     = z
15:16:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:16:05 <roconnor> :/
15:16:08 <copumpkin> I also know how to do that :P
15:16:16 <copumpkin> but writing it so it takes a length is more difficult
15:16:31 <copumpkin> for example, my "lengthed" foldr is :: (forall n. a -> p {n} -> p {S n}) -> p {Z} -> Vec {n} a -> p {n}
15:16:44 <copumpkin> I can't trivially translate it to a foldl
15:16:48 <roconnor> copumpkin: do you know that (S (n + m)) (S n + m) and (n + S m) are all the same type?
15:16:50 <copumpkin> because the p {Z} will not be of Z anymore
15:17:09 <copumpkin> I haven't proved it in this module, but pretty much
15:17:28 <copumpkin> I can add that
15:17:46 <ksf> because then i'd either have to do wrapper functions for my adt, or live with mixed case. also, I coulnd't "insert" hasX, as insert is (in edison, and general), a -> c -> c
15:18:13 <lilac> > foldr (\a f xs -> f (a:xs)) id "hello world" []
15:18:14 <lambdabot>   "dlrow olleh"
15:18:20 <mmorrow> , foldr s z [a,a,a,a,a,a]
15:18:21 <lunabot>  luna: Couldn't match expected type `a -> b -> b'
15:18:38 <mmorrow> , foldr (s::Expr->Expr->Expr) z [a,a,a,a,a,a]
15:18:39 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr
15:18:42 <lispy> :t foldr (flip (:))
15:18:43 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
15:18:43 <lambdabot>       Expected type: b
15:18:43 <lambdabot>       Inferred type: [b]
15:18:46 <mmorrow> , s
15:18:49 <lunabot>  s
15:18:50 <mmorrow> , z
15:18:52 <lunabot>  z
15:18:54 <mmorrow> , a
15:18:56 <copumpkin> lilac: I guess I can just do it the way lilac did it
15:18:56 <lunabot>  a
15:19:00 <mmorrow> ?
15:19:01 <copumpkin> it'd be nice to have a good foldl though
15:19:02 <lispy> :t foldl (flip (:))
15:19:03 <lambdabot> forall b. [b] -> [b] -> [b]
15:19:09 <mmorrow> , foldr s z [a,a,a,a,a,a::Expr]
15:19:10 <lunabot>  luna: Couldn't match expected type `a -> b -> b'
15:19:11 <lispy> :t foldl1' (flip (:))
15:19:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
15:19:13 <lambdabot>       Expected type: a
15:19:13 <lambdabot>       Inferred type: [a]
15:19:26 <lispy> :t foldl' (flip (:)) []
15:19:27 <lambdabot> forall b. [b] -> [b]
15:19:38 <lispy> > foldl' (flip (:)) [] "hello world"
15:19:39 <lambdabot>   "dlrow olleh"
15:20:21 <mmorrow> copumpkin: you may need to invert your typelevel numeric rep something like
15:20:23 <mmorrow> , foldr f z (replicate 4 a)
15:20:25 <lunabot>  f a (f a (f a (f a z)))
15:20:26 <mmorrow> , foldl f z (replicate 4 a)
15:20:28 <lunabot>  f (f (f (f z a) a) a) a
15:20:43 <copumpkin> mmorrow: yeah, that makes it easier, but then it makes functor and other instances rather useless
15:20:50 <mmorrow> but since it's usually S(S(S(S Z))), i'm not sure
15:21:05 <mmorrow> copumpkin: yeah, so maybe foldl reverse is not possible
15:21:05 <copumpkin> I've been playing with a Flip newtype to do what I did so far
15:21:13 <copumpkin> my snoc foldr one
15:21:17 <edwardk> copumpkin: you could borrow my version, which uses base 2 or base 16.
15:21:28 <edwardk> copumpkin: and is pretty good at showing equality, etc.
15:21:35 <copumpkin> yeah, but not invented here!
15:21:36 <copumpkin> :P
15:21:39 <edwardk> copumpkin: hah
15:21:59 * copumpkin gets back to work on his latest uselss thing :)
15:22:18 <mmorrow> , [a,a,a,a]
15:22:20 <lunabot>  [a,a,a,a]
15:22:24 <edwardk> copumpkin: base 2 gives you 2s complement arithmetic so you can represent negative number and succ and pred can both be total ;)
15:22:40 <mmorrow> i wonder why [a,a,a,a] doesn't work, but (replicate 4 a) does (for SimpleReflect)
15:22:52 <mmorrow> , foldl f z [a,a,a,a]
15:22:54 <lunabot>  f (f (f (f z a) a) a) a
15:22:57 <mmorrow> !!
15:23:02 <mmorrow> , foldr f z [a,a,a,a]
15:23:04 <lunabot>  f a (f a (f a (f a z)))
15:23:05 <ski> (edwardk : 2-adic numbers ?)
15:23:07 <mmorrow> , foldr s z [a,a,a,a]
15:23:08 <lunabot>  luna: Couldn't match expected type `a -> b -> b'
15:23:10 <copumpkin> edwardk: that's nice :)
15:23:16 <mmorrow> , [$ty| f |]
15:23:19 <lunabot>  forall a . FromExpr a => a
15:23:22 <mmorrow> , [$ty| s |]
15:23:24 <lunabot>  Expr
15:23:27 <mmorrow> ohh
15:23:54 <copumpkin> okay so lilac's version can't really work either
15:23:58 <copumpkin> cause my rank isn't high enough :P
15:24:21 * copumpkin settles for his snoc version for now
15:24:33 <copumpkin> @pl \x y -> Flip $ unFlip y `snoc` x
15:24:33 <lambdabot> (Flip .) . flip (snoc . unFlip)
15:24:40 <copumpkin> :P
15:25:19 <ksf> data Peano = Succ Peano | Pred Peano | Zero?
15:25:35 <ski> that's noncanonical
15:25:35 <copumpkin> not sure that counts as Peano :P
15:25:47 <copumpkin> is it Zero or is it Succ (Pred Zero) ?
15:26:09 <superciuk> ciao
15:26:24 <ksf> well, I'd claim that you can't express a canonicality-constraint in haskell, but then oleg would come along.
15:26:37 <superciuk> !list
15:26:38 <Optimoe> I syndicate the following:
15:26:38 <Optimoe> iPodTVNova_Movies iPodTVNova_Television
15:27:14 <ski> ?
15:28:30 <ksf> Optimoe, that's nice for you. what does it have to do with us?
15:28:57 <Makoryu> Optimoe: ಠ_ಠ
15:30:36 <skorpan> Makoryu: damn you for hanging my emacs
15:31:13 <Makoryu> skorpan: （　´_ゝ`）
15:31:19 <dons> Package popularity stats for the month, now up, http://donsbot.wordpress.com/2009/08/29/haskell-popularity-rankings-september-2009/
15:32:08 <endojelly> ski, oh, yes, that's nice
15:32:18 <endojelly> ski, thanks
15:33:47 <blackh> Wo hoo - I'm at no. 75!  My package is so innovative and sexy that people can't resist it.  (It sends email.)
15:34:57 * copumpkin just wrote unzip
15:35:07 <roconnor> blockio: HA HA
15:35:08 <copumpkin> > unzip = runUnzipper . fold (\(a, b) ~(Unzipper (as, bs)) -> Unzipper (a :> as, b :> bs)) (Unzipper (Nil, Nil))
15:35:10 <lambdabot>   <no location info>: parse error on input `='
15:35:23 <sjanssen> copumpkin: lrn2prelude
15:35:34 <copumpkin> sjanssen: I R WRITING NOO PRELUDE KTHX
15:35:36 <dons> roconnor: i don't think blockio is available on hackage anymore
15:35:46 <roconnor> ah
15:36:09 <hackagebot> monoid-transformer 0.0.2 - Monoid counterparts to some ubiquitous monad transformers (HenningThielemann)
15:36:10 <Deewiant> Unsurprisingly, the deps for cabal-install top the list
15:36:32 <dons> right. like core-utils for linux
15:36:37 <dons> stuff what everyone needs :)
15:36:42 <copumpkin> this is the type: unzip :: Vec {n} (a, b) -> (Vec {n} a, Vec {n} b)
15:36:59 <SamB> Deewiant: no kidding -- how the heck are you going to install anything else without that, except that, once you've used it?
15:37:13 <Deewiant> SamB: I worked fine without it for months :-P
15:38:41 <sjanssen> copumpkin: wut?  Is that using she?
15:38:46 <copumpkin> sjanssen: ya!
15:38:57 * copumpkin molests she
15:39:17 <dons> ah
15:39:20 <SamB> shouldn't it be "her"?
15:39:37 <ksf> what makes instance (Bits a) => Monoid a undecidable?
15:39:47 <copumpkin> SamB: then people would think I was a pervert
15:40:16 <mauke> instance (Monoid a) => Bits a  -- enjoy your loop
15:40:23 <edwardk> Now we just think you are a pervert without a sense of English grammar ;)
15:40:34 <copumpkin> edwardk: why do you hate I? :(
15:40:46 <ksf> but you can't define Bits in terms of a mere monoid!
15:40:48 <edwardk> Must be from your crazy wordtrotting background ;)
15:40:56 <edwardk> er worldtrotting even
15:41:01 <SamB> ksf: I can think of two
15:41:11 <SamB> Well, possibly
15:41:23 <edwardk> ksf: the problem is that there are other Monoids than ones that are given by Bits
15:41:39 <edwardk> ksf: so the first problem you get is the ambiguous instance head you just introduced
15:41:46 * ski idly wonders what the dual of `Hom' is
15:41:53 <SamB> ski: CoHom ?
15:41:58 <mauke> ksf: doesn't matter
15:42:05 <copumpkin> ski: Het
15:42:15 <ski> SamB : what it *is*, not what it would be named :)
15:42:17 <edwardk> ksf: the second problem you get is that the body of the instance is the same as the head, so that is where your undecidable instances comes in.
15:42:21 <edwardk> er is the same size as the head
15:42:57 <ksf> ...and if I add a contstraint on a witness class?
15:43:11 <edwardk> ksf: the right solution is to make something like instance Bits a => Monoid (And a); instance Bits a => Monoid (Or a) -- etc.
15:43:36 <copumpkin> now we get back to the hard one: transpose :: Vec {n} (Vec {m} a) -> Vec {m} (Vec {n} a)
15:43:42 <edwardk> and just make newtype wrappers, now you have a size decrease between the head and body so its decidable
15:43:57 <ksf> ...er yes adding constraints doesn't make it less undecidable in general.
15:43:59 <edwardk> _and_ for that matter you are no longer concerned with conflicting instance heads with the rest of the library
15:44:08 <ski> consider `id : Id_C >-> Hom_C' and `(.) : Hom_C . Hom_C >-> Hom_C'
15:44:56 <ksf> ...so I'm going to make a newtype wrapper around CLong and CInt to make monoids, and then make newtype wrappers around that to make my distinct types...
15:45:10 <mun> hi
15:45:18 <mun> can anyone see why there's a parse error on line 5? http://haskell.pastebin.com/m63730ae1
15:45:40 <edwardk> ksf: the last problem you had was that there is that the choice of Monoid for your Bits instance was arbitrary. was it And, Or, or something else.
15:46:00 <ksf> 0 and or.
15:46:03 <SamB> I thought And and Or were over Bool
15:46:10 <poe> mun: maybe you need parens around (opts ..})
15:46:11 <ski> mun : missing ` do' after `Just file ->'
15:46:19 <lispy> ?hoogle join
15:46:19 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
15:46:19 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
15:46:19 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
15:46:33 <edwardk> SamB: the names I made up on the spot. there is Any and All i think in the Monoid library
15:46:42 <edwardk> @hoogle Any
15:46:43 <lambdabot> Data.Monoid newtype Any
15:46:43 <lambdabot> Data.Monoid Any :: Bool -> Any
15:46:43 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
15:46:52 <ski> mun : also, the `case mast of ...' should be indented less
15:46:54 <ksf> ...yeah, I was already thinking in bitsets, only the or monoid makes sense there
15:47:42 <SamB> edwardk: oh, is that what they're called ?
15:47:49 <copumpkin> join/meet
15:47:58 <copumpkin> any relation to join in monads?
15:48:00 <SamB> ksf: is that so?
15:48:14 <SamB> copumpkin: the type is different
15:48:21 <SamB> I mean, totally different
15:48:46 <edwardk> interestingly i never made an instance of a SemiRing that had .&. and .|. for the monoids library. There is something kind of similar for Data.Ring.Semi.BitSet though
15:48:57 <copumpkin> SamB: yeah, doesn't mean they're unrelated though :P
15:49:02 <copumpkin> (although they probably are)
15:49:07 <ksf> ...at least it wouldn't make sense to me.
15:49:12 <mun> ski, hmm why do i need a do after Just file? isn't the whole block under a do already?
15:49:17 <ski>   join :: Monad m => m . m -> m
15:49:17 <ski>   join :: Lattice l => (l,l) -> l
15:49:19 <mun> ski, i.e. the do on line 2
15:49:27 <ksf> you build up a bitset by or'ing elements together with 0 as identity, that's a monoid.
15:49:42 <dschoepe> mun: a do block ends in case expressions, ifs, etc.
15:49:50 <edwardk> ksf: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Ring-Semi-BitSet.html
15:49:58 <mun> dschoepe, ooh!
15:50:11 <edwardk> ksf: thats the basic idea though for that type I go a step farther and maintain an exponent/mantissa representation
15:50:20 <ski> mun : the `case ... of ...' is just an expression that is placed in the outer `do'-block. the branches in it are not considered to be "command sequences" themselves (that might be a nice thing to allow, but is not currently allowed)
15:50:32 <edwardk> ksf: and allow for negative mantissas to represent 'mostly-full' bitsets.
15:50:50 <mun> ski, thanks
15:51:06 <edwardk> ksf: this has the nice property that it allows for you to ask for a 'full' bitset or complement one.
15:51:34 <ski> (mun : i'd just put the ` do' after the `->' there ..)
15:52:02 <ksf> but it won't let me use the same bitmask as FreeType.
15:52:07 <edwardk> ksf: the exponent tracks the position of the first set (or in the negative mantissa case, unset) bit and the Integer stores the rest of the significant bits
15:52:35 <ksf> my goal is to keep the representation, and just provide a sane interface.
15:52:51 <edwardk> ksf: alas, not, it was intended for my own use for dealing with mostly compact bit set representations of character sets for regexps, etc.
15:53:12 <edwardk> ksf: the small newtype wrapper is your best bet. its like 5 lines with appropriate newtype deriving anyways
15:53:20 <ksf> yep.
15:53:36 <mun> ski, does that mean i'd need a do on line 17 and 18 as well?
15:53:52 <randomwords> Dons: In the csv file detailing hackage downloads, what do the numbers represent?
15:54:30 <ksf> ...we should add "ask in #haskell if you want to use UndecidableInstances: Chances are you don't need it, but just don't know why" to the ghc errors.
15:55:00 <ski> mun : you don't need one there, since you don't sequence several things together .. you can put one there if you like there, though (for consistency or something), if you care for that
15:55:09 <copumpkin> > let transpose = foldr1 (zipWith (++)) . map (map pure) in transpose [[1,2],[3,4]]
15:55:10 <lambdabot>   [[1,3],[2,4]]
15:55:17 <mun> ski, i see. thanks
15:55:43 * ski often puts a `do' to all branches, if one branch has gotten it
15:56:03 <dons> randomwords: downloads per month
15:56:12 <dons> randomwords: load it up in open office
15:56:58 <roconnor> > let transpose = foldr1 (zipWith (++)) . map (map pure) in transpose []
15:57:00 <lambdabot>   * Exception: Prelude.foldr1: empty list
15:57:05 <roconnor> > transpose []
15:57:06 <lambdabot>   []
15:57:16 <ski> @type foldr (zipWith (:)) (repeat [])
15:57:17 <lambdabot> forall a. [[a]] -> [[a]]
15:57:22 <sshc> is there a standard library function that turns a string into a list of Word8's (bytes)?
15:57:42 <randomwords> dons: Just wondered if they were scaled at all (e.g. 1000's of downloads)
15:57:46 <roconnor> map (toEnum . fromEnum)
15:57:50 <roconnor> map (toEnum . fromEnum) "hello"
15:57:50 <randomwords> that was a little optimistic I guess
15:57:52 <dons> map ord
15:57:55 <roconnor> > map (toEnum . fromEnum) "hello"
15:57:58 <dons> randomwords: hehe
15:58:00 <lambdabot>   [* Exception: Prelude.Enum.().toEnum: bad argument
15:58:01 <dons> no, actual downloads
15:58:08 <ksf> heh. I still have to use instance Bits a => Monoid (Or a) where
15:58:10 <roconnor> > map (toEnum . fromEnum) "hello" :: [Word8]
15:58:11 <lambdabot>   [104,101,108,108,111]
15:58:12 <randomwords> They seem low - especially for some packages
15:58:14 <roconnor> @type ord
15:58:15 <lambdabot> Char -> Int
15:58:20 <ski> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
15:58:21 <ski> > foldr (zipWith (:)) (repeat []) []
15:58:21 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
15:58:22 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
15:58:27 <dons> randomwords: 1.2M downloads?
15:58:35 <ksf> ...even though I got a bits restraint on the newtype.
15:58:37 <dons> some packages are not widely advertised.
15:58:42 <ksf> ...and derive Bits.
15:58:46 <dons> i'd really encourage people to write and talk about packages that are good
15:58:51 <dons> since we have no recommendation engine
15:58:56 <randomwords> I guess you don't update everything every month as well
15:59:01 <roconnor> dons: Data.Accessor is awesome!
15:59:02 <dons> riht
15:59:11 <dons> roconnor: the data-accessor package?
15:59:15 <roconnor> yes
15:59:18 <randomwords> and data-accessor-template
15:59:21 * dons thinks we need a review site.
15:59:29 <pr> good idea
15:59:37 <roconnor> I'd put it in the haskell platform if it were up to me
15:59:47 <roconnor> Actually I'd put it into haskell' if it were up to me
16:00:04 <copumpkin> ski: that's even neater, thanks!
16:00:06 <roconnor> screw projection functions for records, they should be accessor functions.
16:00:56 <randomwords> A review site is a nice idea
16:01:40 <roconnor> how would a review site help?
16:01:43 <lispy> dons: when I see people wearing shirts that say, http://hackage.haskell.org/user/matty  then I'll know we have a great recomendation system :)
16:02:06 <dons> well, we need some recommendation engine
16:02:08 <dons> so you can review, vote, and cross-link packages
16:02:17 <roconnor> hmm
16:02:17 <dons> netflix-like rankings? :)
16:02:18 <randomwords> roconnor: There's a lot of chaff on hackage - it would be nice to get to the wheat quickly sometimes
16:02:22 <ski> > getZipList . Data.Traversable.sequenceA . map ZipList $ [[1,2,3],[4,5,6],[7,8,9]]  -- copumpkin, also this
16:02:24 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
16:02:29 <dons> you like data-accessor , we think you might like data-accessor-template
16:02:30 <randomwords> in some categories at least - games springs to mind
16:02:30 <lispy> I fully agree.  I bet github is doing this right
16:02:37 <roconnor> randomwords: I agree, but how will we sort through all the reviews?  A review of reviews?
16:02:41 <copumpkin> ski: hah, very nice
16:03:03 <dons> like we have to sort through download stats.
16:03:07 <dons> any data is better than none.
16:03:38 <lispy> We can sort of think of hackage as github for the haskell community
16:03:43 <dons> right
16:03:56 <dons> or the amazon.com
16:04:08 <lispy> true
16:04:37 <roconnor> what does github do?
16:04:50 <copumpkin> it's a place for gits to git together
16:04:55 <lispy> roconnor: besides serving up repositories, it appears to have a bit of social networking built in
16:05:09 <roconnor> I mean what does it do wrt this problem
16:05:54 <lispy> oh, sorry.  I don't actually know.
16:05:58 <sjanssen> github isn't really used as an index, is it?
16:06:11 <sjanssen> you receive links to an interesting repositories from a third party
16:08:23 <Knight_Lord> How can i convert a Maybe String in a String if I know that it's not Nothing?
16:08:42 <ski> @type fromJust
16:08:43 <lambdabot> forall a. Maybe a -> a
16:08:49 <benmachine> > fromJust Nothing
16:08:51 <lambdabot>   * Exception: Maybe.fromJust: Nothing
16:08:52 <roconnor> Knight_Lord: fromJust, but this is a sign of a poor design
16:09:04 <roconnor> use it for now
16:09:10 <roconnor> we will teach you how to avoid using it later.
16:09:13 <benmachine> heh
16:09:15 <lispy> Oh, that's interesting.  I changed darcs to use its lazy parsing monad and removed the bangs from the patch data type and it went up 10% in efficiency
16:09:25 <benmachine> often using case is just as easy as fromJust
16:09:36 <Knight_Lord> Not in scope: `fromJust'
16:09:39 <benmachine> case expr of Just x -> x
16:09:41 <lispy> total memory is use stayed the same though
16:09:46 <roconnor> Knight_Lord: import Data.Maybe
16:09:58 <benmachine> import Data.Ben.Is.Slow.At.Answering
16:10:04 <dons> lispy: would be interesting to see the live heap graph
16:10:22 <lispy> dons: how so? I have before and after as pdfs
16:10:33 <lispy> I mean, what should I look for?
16:10:36 <sshc> > "hello" :: [Word8]
16:10:36 <lispy> it definitely changed
16:10:37 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
16:10:51 <sshc> How do I convert a string to an array of bytes?
16:10:53 * ksf is confused
16:10:54 <randomwords> roconnor: By the way - did you actually write a sudoku solver using triples of triples - or is it just an idea. I'd love to see it
16:10:58 <roconnor> > map (toEnum . fromEnum) "hello" :: [Word8]
16:11:00 <lambdabot>   [104,101,108,108,111]
16:11:02 <dons> lispy: well, that the shape of the curve changed, but overall required allocs doesn't
16:11:11 <roconnor> randomwords: Conor McBride did
16:11:21 <ksf> I've got newtype MyFlag = MyFlag (Or Integer) deriving (Monoid) and instance Bits a => Monoid (Or a) where, and it compiles.
16:11:24 <benmachine> oh I was going to write a sudoku solver
16:11:25 <ksf> I think it shouldn't.
16:11:33 <randomwords> roconnor: Any idea where it is - I can't seem to find it?
16:11:35 <lispy> dons: the thing that changed was that one of the bands pretty much disappeared, but the band under it had the same shape
16:11:44 <ksf> ...as ghc can't possibly derive a Monoid without that Bits instance.
16:11:44 <roconnor> randomwords: I'm not certain it is published
16:11:44 <randomwords> roconnor: And one of you needs to change your name
16:12:03 <ksf> wait, Integer _has_ a bits instance.
16:12:04 <randomwords> it's confusing my dyslexic mind
16:12:28 <dons> lispy: i think it'd be interresting to start using hp2any on darcs, http://just-bottom.blogspot.com/2009/08/more-profiling-goodies.html
16:12:43 <sshc> lexdysia doesn't exist
16:12:53 <lispy> I have 6.10.4, is that new enough?
16:13:08 <roconnor> @go sudoku traversable
16:13:09 <lambdabot> No Result Found.
16:13:19 <roconnor> lies
16:13:43 <Knight_Lord> many thanks
16:14:32 <roconnor> randomwords: this is close: http://www.haskell.org/haskellwiki/Liyang/sudoku.hs
16:14:41 <roconnor> but because he uses newtypes he has less access to symetries
16:14:59 <roconnor> waitMissiles :: State TBool -> STM ()
16:15:03 <copumpkin> hmm, can't seem to get she to accept my induction function
16:15:08 <roconnor> launchMissiles :: State Bool -> IO (State Bool)
16:15:12 <randomwords> I was especting something a little more terse, but I'll have a read
16:15:15 <roconnor> mad :: State Bool -> IO Bool
16:16:42 <ski>   awaitMissile :: Missile -> IO Void
16:17:27 <lispy> dons: hmm.. hp2any-graph is a bit akward to install because it needs glut and my opengl isn't built for profiling
16:18:24 <ski> (or `OI Missile -> Void' ?)
16:19:32 <jmcarthur> roconnor: i just came back to my computer and misread "Conor McBride did" as "Conor McBride died" and got momentarily worried
16:19:43 <roconnor> :)
16:19:45 <jmcarthur> just thought you should know that
16:20:08 <copumpkin> edwinb: you around? :)
16:23:55 <Knight_Lord> How can i avoid fromJust in this case http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3453#a3453 ?
16:25:01 <dschoepe> liftM3 (,,) (addState ..) (addState ..) (addState ..)
16:25:31 <Knight_Lord> dschoepe: what's liftM3?
16:26:09 <dibblego> @src liftM3
16:26:10 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
16:26:12 <dschoepe> Knight_Lord: it lifts a function with 3 arguments to work in a monad. In this case, the result will be nothing is any of the parameters is nothing
16:26:26 <dschoepe> > liftM2 (,) (Just 4) (Just 5)
16:26:28 <lambdabot>   Just (4,5)
16:26:31 <dschoepe> > liftM2 (,) (Just 4) Nothing
16:26:32 <lambdabot>   Nothing
16:26:37 <ksf> two methods into the instance, already spawning another, equally long instance, I'm deciding that edison is overkill.
16:26:39 <lispy> dons: hmm...hp2any-graph doesn't seem to work for me.  "Error starting profile reder thread.  Did you enable heap profiling?"  <-- have you seen this before?
16:26:41 <dmwit> Knight_Lord: You could use pattern matching for addState, it's a bit more idiomatic.
16:26:51 <Knight_Lord> dmwit: how could i do that?
16:26:52 <dmwit> addState Empty b = Just b
16:26:56 <dmwit> addState a Empty = Just a
16:26:57 <copumpkin> > intersperse 1 []
16:26:58 <lambdabot>   []
16:27:00 <dmwit> addState _ _ = Nothing
16:27:12 <mauke> Knight_Lord: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3453#a3454
16:27:29 <lispy> dons: I was doing heap profiles all along so I think I enabeled.  Plus my commands match rwh and the hp2any docs for how to do profiling
16:27:32 <copumpkin> gotta love the error messages SHE produces: Vec.lhs:96:56: Not in scope: type constructor or class `:$#$#$#:+'
16:27:44 <dmwit> I like liftM3 better than case here.
16:28:00 <dmwit> Even better might be sequence, if he were using lists instead of triples.
16:28:03 <byorgey> copumpkin: hehe
16:28:13 <copumpkin> feels like it's swearing at me :)
16:28:20 <dmwit> (Though that comes with its own problems, of course: not statically guaranteed a list of length three.)
16:28:22 <dschoepe> dmwit: but its a bit harder to understand, considering that this is Knight_Lord first Haskell program
16:28:23 <byorgey> perhaps SHE is.
16:28:48 <dmwit> right
16:28:55 <dmwit> byorgey: Can you send email?
16:28:56 <Knight_Lord> mauke: isn't that the same as i posted?
16:28:58 <dmwit> err
16:29:02 <copumpkin> byorgey: oh, that's right, and she's swearing at me because I keep calling her it
16:29:10 <mauke> Knight_Lord: which one?
16:29:12 <dschoepe> Knight_Lord: the lower one is from mauke
16:29:13 <byorgey> copumpkin: =)
16:29:29 <copumpkin> > intersperse 1 [1]
16:29:29 <Knight_Lord> oh i had to reload
16:29:30 <lambdabot>   [1]
16:30:07 <Knight_Lord> That looks much nicer, thanks
16:30:23 <Berengal> I need a project
16:30:42 <lispy> Berengal: do you use windows?
16:30:55 <Berengal> lispy, nope. You've got a windows project?
16:31:08 <Berengal> (I do have windows installed, but I seldom use it)
16:31:13 <lispy> Berengal: well, darcs could use more devs on windows.  In general though, I'd say help out with darcs :)
16:31:29 <randomwords> or yi
16:31:32 <lispy> Berengal: or, dons was just saying that hackage needs a review site
16:31:40 <lispy> Berengal: a recommender service
16:33:02 <blackh> For Arrow fans, I've written an Arrow tutorial and I'm soliciting comments. http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
16:33:09 <Knight_Lord> My tic tac toe program kinda works. Now i just need to add some artificial inteligence
16:33:11 <Berengal> lispy, darcs doesn't sound too bad, especially as we need a new VCS (CVS sucks) at work, and darcs may be a good candidate. Git suffers from lack of windows support
16:33:34 <Berengal> lispy, any hints on where to start looking?
16:33:51 <lispy> Berengal: ah yeah, darcs could really use a better front end on windows. Tortoise darcs exists, but it's lacking
16:34:06 <lispy> Berengal: well, what would you like to achieve?
16:35:42 <Berengal> lispy, 1: get to know darcs properly, 2: get to know the code properly 3: figure out what needs to be done 4: do it
16:36:05 <lispy> Berengal: the darcs bug tracker is a good place to look, http://bugs.darcs.net and also the wiki has stuff, http://wiki.darcs.net
16:36:50 <lispy> Most of the windows stuff wouldn't require you to know the patch theory
16:37:48 <Berengal> I've only used darcs in a very limited manner, so I don't even know how to use it properly
16:38:16 <blackh> Knight_Lord: Great!
16:38:39 <Knight_Lord> :)
16:39:31 <ksf> @hoogle a -> a -> Bool
16:39:31 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
16:39:31 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
16:39:31 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
16:39:36 <ksf> @hoogle a -> b -> Bool
16:39:36 <lambdabot> Prelude const :: a -> b -> a
16:39:36 <lambdabot> Data.Function const :: a -> b -> a
16:39:36 <lambdabot> Control.Parallel par :: a -> b -> b
16:40:41 <lispy> Berengal: I think the wiki has a roadmap too, which could help you
16:41:18 <Berengal> lispy, I'll have a look.
16:42:35 <mauke> preflex: seen RayNbow
16:42:35 <preflex>  RayNbow was last seen on #haskell 12 hours, 35 minutes and 2 seconds ago, saying: > cycle "hi! "
16:44:02 <mauke> RayNbow: if you're reading this, solutions to http://golf.shinh.org/p.rb?find+minimum+cyclic+parts#Haskell are now available
16:52:30 <jaredj>  @seen sm
16:53:49 <mauke> preflex: seen sm
16:53:50 <preflex>  sm was last seen on #haskell 21 hours, 44 minutes and 11 seconds ago, saying: I've spent a good number of hours chasing this darcs bug and now the blasted thing is working
16:54:53 <jaredj> preflex?
16:55:14 <copumpkin> mauke: 6st is hilarious btw
16:55:15 <jaredj> are people forking lambdabot or something?
16:55:45 <m3ga> i've forgotten my password for trac.haskell.org. anyone know how to get it back or reset it?
16:55:46 <lambdabot> m3ga: You have 1 new message. '/msg lambdabot @messages' to read it.
16:56:01 <edwinb> copumpkin: yes!
16:56:15 <copumpkin> edwinb: I was wondering if you were a she expert!
16:56:31 <mauke> jaredj: preflex isn't related to lambdabot
16:56:38 <edwinb> in as much as there is such a thing...
16:56:46 <edwinb> I haven't used it for a couple of weeks, mind
16:56:57 <edwinb> also, more importantly, I've just spent several hours in an Edinburgh pub ;)
16:57:08 <copumpkin> edwinb: I was hoping to write something like induction :: {:n :: Nat:} => {n} -> p {Z} -> (forall m. p {m} -> p {S m}) -> p {n} but was having trouble :)
16:57:15 <copumpkin> but if you're drunk I'm in no rush :)
16:57:19 <mun> does anyone know why line 22 about 'the last statement in a do construct must be an expression'? http://haskell.pastebin.com/m78247301
16:57:54 <mauke> mun: line 24 doesn't line up with line 21
16:58:03 <edwinb> on the face of it it seems like it ought to work
16:58:14 <edwinb> but now is probably not a time when I can help ;)
16:58:22 <copumpkin> ok, thanks :)
16:58:23 <Phyx-> mun: neither does line 23
16:58:28 <Cale> Yeah, mauke got it... since line 24 is indented more, it becomes part of line 21
16:58:40 <Phyx-> oh, nvm, i see
16:58:54 <mauke> part of line 22
16:58:59 <Cale> er, 22 yeah
16:59:11 <mun> argh.. i think i need some vertical highlighter for emacs
16:59:51 <edwinb> copumpkin: prod me tomorrow or the day after, I may have the actual expert nearby...
16:59:58 <Phyx-> i always use the tab delimiter markers in my editor
17:00:05 <copumpkin> edwinb: okay :) I'll keep trying and see if I can figure it out on my own, too
17:00:14 <Phyx-> they show, even though i have tabs replaced bby spaces :)
17:00:39 <edwinb> and now, I have to get up in 6 hours, so I'm off. Night night!
17:00:50 <copumpkin> g'night :)
17:00:56 <Phyx-> gnight
17:01:31 <Phyx-> hmm... what's a "professional student"
17:02:07 <jaredj> grants > tuition?
17:02:20 <randomwords> Postgrad?
17:02:34 <copumpkin> whee, I almost have transpose working!
17:02:36 <Phyx-> hmm
17:02:39 <jaredj> sounds like a phdcomics.com setup :)
17:02:48 <Phyx-> jaredj: lol
17:02:51 <Phyx-> i was just wondering
17:03:03 <Phyx-> since the page said "resources for grad students and professional students"
17:03:15 <Phyx-> so i was wondering what amateur students are then..
17:03:29 <Phyx-> copumpkin: transpose of what? matrices?
17:03:36 <jaredj> bah who learns about something just because they want to
17:03:38 <dmwit> I thought a professional student was one that was taking classes, but not trying to get a degree/doctorate.
17:03:39 <jaredj> ;)
17:03:45 <ski> Phyx- : lists with a known length, i think
17:03:55 <copumpkin> Phyx-: yep :) what ski said
17:04:00 <copumpkin> effectively matrix
17:04:24 <Phyx-> dmwit: those exist?
17:04:28 <copumpkin> whee > transpose :: {:m :: Nat:} => Vec {n} (Vec {m} a) -> Vec {m} (Vec {n} a)
17:04:40 <Phyx-> hmm.. how do you transpose a list of unknown lenght..
17:04:52 <dmwit> Phyx-: Sure.  It takes a long time to get a degree; it takes much shorter to take the one or two classes that matter to your employer.
17:04:57 <ski> copumpkin : the `{:m :: Nat:} => ' signifying ?
17:05:18 <copumpkin> ski: that m must be a Nat
17:05:28 <jaredj> and that it's part of a template?
17:05:31 <ski> yes .. but why is `n' not in there ?
17:05:34 <Phyx-> dmwit: ah, true
17:06:00 <copumpkin> ski: it wasn't needed, but m needed to be for me to call pure
17:06:09 <copumpkin> ski: I could just add it for consistency
17:06:18 <ski> it wasn't needed for what ?
17:06:22 <Phyx-> what kind of extension is that?
17:06:24 <ski> hm
17:06:32 <ski> copumpkin : ah .. i think i see
17:06:46 <Phyx-> and, isn't the length known? it's in the type no?
17:06:46 <copumpkin> @hackage she
17:06:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
17:06:49 <copumpkin> Phyx-: ^^
17:06:55 <Phyx-> lol @ she
17:07:15 <ski> copumpkin : in case `n' is zero, you still need to know the length of the list to return .. but the length of the input can be read off the input directly
17:07:35 <jaredj> love the description
17:07:36 <copumpkin> yeah
17:07:53 * ski wonders if this would be an actual blind quantification of `n'
17:07:55 <skorpan`> is the e-mail address to the she maintainer correct? i.e. is the she-mail correct?
17:07:59 <copumpkin> also, the parser doesn't seem capable of letting me put multiple type constraints in the {: :} block yet, so I'm glad I don't need it :P
17:09:29 <ski> `exists a0,a1 :: a. Equal a a0 a1' is isomorphic to `a'. opinion ?
17:09:32 <lispy> skorpan`: haha
17:09:37 <lispy> skorpan`: clever
17:11:16 <dmwit> ski: Equal takes three arguments?
17:11:39 <ski>   Equal :: (a :: *) -> a -> a -> *
17:11:42 <dmwit> ah, yes, I see
17:11:48 <dmwit> took me a bit to parse, sorry
17:12:14 <dmwit> Well, that seems fine, provided 'a' is inhabited.
17:12:34 <ski> why not for noninhabited types `a' ?
17:12:37 <dmwit> i.e. `exists a0,a1 :: a. Equal a a0 a1' is isomorphic to `exists a0 :: a', maybe
17:12:38 <copumpkin> would an Applicative instance for matrices make sense? with ziplist like behavior?
17:12:43 <copumpkin> *ziplist-like
17:12:49 <dmwit> ski: Because then the exists clause is false...
17:12:59 <dmwit> oh
17:13:00 <ski> dmwit : and so is `a', then
17:13:26 <lispy> :t ($!)
17:13:27 <lambdabot> forall a b. (a -> b) -> a -> b
17:14:14 <dmwit> ski: Okay, I buy it.
17:15:24 <ski> would this preclude a `data Equal (a :: *) where Refl :: Equal a a0 a0' implementation ?
17:15:46 <ski> (er s/where/ :: a -> a -> * where/)
17:16:31 <jaredj> the question of a mere mortal: i'm parsing an SGML file with compound elements. What's the right data structure for an element all of whose parts I haven't parsed? A stack of parts? A complete record composed entirely of Maybes?
17:16:42 <ski> (since it appears that e.g. the type `exists b0,b1 :: Bool. Equal Bool b0 b1' would only have one inhabitant, then ..)
17:17:20 <dmwit> That doesn't look well-kinded.
17:17:29 <dmwit> Are we assuming some extensions here?
17:17:49 <ski> we are assuming something like Agda2 (or probably Coq works as well)
17:17:54 <dmwit> ok
17:18:04 <ski> (to get dependent types to begin with)
17:18:21 <dmwit> In that case Equal Bool b0 b1 has only one inhabitant, but it has two monomorphic types, which is just what you want.
17:18:31 <dmwit> i.e. it has types Equal Bool True True and Equal Bool False False.
17:18:54 <ski> yes, those are the possible "instances" (not quite right word)
17:19:05 <dmwit> (Not sure what the right words are.)
17:19:32 <ski> (we could call it "coinstance" 'til we come up with a better term :)
17:20:04 <mun> can anyone see why there's a parse error on line 32? http://haskell.pastebin.com/m7bf889cb
17:20:22 <dmwit> mun: let ... in
17:20:28 <ski> it seems to me that in one conception of an equality type, the type has at most one inhabitant
17:20:31 <dmwit> let ... in case ... of
17:20:36 <dmwit> oh
17:20:39 * copumpkin almost has a matrix applicative instance
17:20:41 <dmwit> mun: Let me look again. =P
17:20:42 <mun> oops
17:20:52 <ksf> (. f) id = f
17:21:00 <mun> hmm
17:21:03 <mun> i do have let in
17:21:05 <ksf> ...just wanted to mention it.
17:21:11 <dmwit> mun: At a guess, the case branches need to be indented more than newLG.
17:21:24 <ski> mun : the branches must be more indented than `newLQ'
17:21:35 <ski> (er, s/LQ/LG/)
17:21:45 <dmwit> mun: (let also introduces a block, in case you didn't know)
17:21:54 <mun> oh? ok
17:22:23 <dmwit> Also, may I suggest that 50-line functions are a code smell?
17:22:46 <ski> (what about 50-line types ?)
17:22:58 <dmwit> Those, too.
17:23:05 <ksf> did anyone of you ever want data types and typeclasses to be the same thing?
17:23:23 <lispy> ksf: those people went off and made smalltalk?
17:23:24 <pardus> even if 50-line type is an AST for compiler?
17:23:26 <mun> dmwit, i'll try to do better :)
17:23:38 <ski> ksf : not yet
17:23:52 <dolio> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8834#a8834
17:23:57 <dmwit> mun: You might like either MaybeT IO or EitherT IO, based on the deeply-nested maybe-cases there.
17:24:06 <lispy> ksf: I want a better module system first :)
17:24:51 <mun> dmwit, sorry i'm quite new.. could you explain why MaybeT IO/EitherT IO?
17:24:55 <copumpkin> whee, I haz applicative
17:25:16 <augustss> ksf: you mean as in a class being a record with methods?
17:25:23 <benmachine> is EitherT different from ErrorT?
17:25:45 <dmwit> ?unmtl MaybeT IO a
17:25:45 <lambdabot> IO (Maybe a)
17:25:59 * ksf doesn't know what he means, anymore. he's happily wallowing in confusion.
17:26:29 <Cale> ksf: It seems like that would make typeclasses a whole lot less expressive
17:26:59 <ksf> How come you people know what I meant by that, If even I don't?
17:27:16 <Cale> Unless you mean passing dictionaries explicitly, which would make things like arithmetic a massive pain
17:27:17 <dmwit> mun: ioma >>= fatoiomb = do { ma <- ioma; case ma of { Nothing -> return Nothing; Just a -> fatoiomb a } }
17:27:22 <copumpkin> addMat :: (Num a, {:m :: Nat:}, {:n :: Nat:}) => Mat m n a -> Mat m n a -> Mat m n a
17:27:22 <copumpkin> addMat = liftA2 (+)
17:27:23 <ski> dolio : hm, ok. now what if the existentials are blind ?
17:27:25 <copumpkin> yay
17:27:54 <dolio> ski: You mean, like, non-constructive.
17:28:01 <dmwit> mun: Which is exactly the pattern you're using in your code: case x of Nothing -> return Nothing {- essentially, since you can just throw your error at the top level -}; Just x -> doSomethingWithX x
17:28:31 <ski> dolio : i mean like `exists x : A. P x' only containing a proof of `P x', not the actual `x' witness
17:28:42 <ksf> copumpkin, who gave you these crazy ideas? have you been visiting #agda, again?
17:28:49 <ski> s/like/like inhabitants of/
17:28:57 * copumpkin looks guilty
17:29:01 <copumpkin> ksf: maybe O:-)
17:29:37 <ski> (dolio : i.e., "the other way around" to `{x : A | P x}')
17:29:37 <dolio> ski: Then it'd probably be hard to get the x back, I assume.
17:30:14 <dolio> I'm not really that well read in type theories like that, though.
17:30:18 <ski> dolio : but what if we have `data Equal : (A : Set) -> A -> A -> Set where Refl : (a : A) -> Refl A a a' instead ?
17:31:40 * ski wonders whether this variation is related to the intensional vs. extensional equality thing
17:31:51 <dolio> Well, there's that, but wouldn't you expect those sorts of proofs to be squashed in the same way?
17:32:19 <dolio> Perhaps not.
17:32:25 <ski> no, the argument to `Refl' there would be material
17:33:27 <ski> we have `(x0,y0) = (x1,y1)  <=>  x0 = x1 /\ y0 = y1'
17:33:52 <ski> i want "similar" laws for other constructions than (binary) products
17:33:53 <defun> what does the Data.IORef library do?
17:34:10 <ksf> what's the term for an a that has a membership relation a -> a -> Bool?
17:34:39 <Makoryu> defun: It creates mutable references, basically. (They can only be used in the IO monad.)
17:34:52 <defun> thnx
17:35:01 <ski> e.g. `(\x0. y0) = (\x1. y1)  <=>  (x0 = x1 -> y0 = y1)' (more or less)
17:35:46 <ski> ksf : how would an operation with type `a -> a -> Bool' mean a membership relation ?
17:36:02 <copumpkin> yay, I have a Num instance for my Mat
17:36:09 <copumpkin> unfortunately the (*) has the wrong type
17:36:12 <copumpkin> but hey
17:36:13 <ksf> hasMember a b = a .&. b == b
17:36:27 <idnar> Mat?
17:36:31 <copumpkin> matrix
17:36:37 <copumpkin> sized matrix
17:36:39 <ski> copumpkin : make a `VectorSpace' instance ?
17:36:54 <copumpkin> ski: yeah, gonna do that next, need to move though, the library is closing :P
17:37:13 <ski> (the library you're writing is closing ??)
17:37:29 <ksf> ...I guess it should be called "isSubset"
17:37:35 <copumpkin> the one I'm sitting in is closing :P
17:37:37 <copumpkin> bbiab :)
17:37:49 <Lycurgus> there's no debian cabal package (other than the one for developing packages)?
17:38:17 <ski> ksf : yes, that's how the order is defined in a lattice
17:38:26 <ski> copumpkin : .. oh
17:39:29 <ksf> ...I'm going to keep the name "Maskoid",though, as "BitSet" is already used and it's an internal class, anyway.. At least until someone who is not me cleans up the code.
17:40:19 <ksf> ...actually, I should rename BitSet Set and Maskoid BitSet.
17:40:46 <erikc> oooh...snow leopard is LP64
17:40:55 <ski> ksf : not `BitSubSet' for the latter, then ?
17:41:45 <ksf> well, the latter only has one function: hasMember :: a -> a -> Bool.
17:42:04 <ksf> ...but you're right.
17:42:44 * ski is not sure
17:42:55 <ksf> no, you're not, as the former doesn't mention bits, at all.
17:44:35 <ksf> ...so Set and Subset it is.
17:46:24 <ksf> ...no I'm going to call the class SetClass and the associated type Set.
17:48:00 <dolio> ski: Thinking about it some more, I guess it might make sense since there's one inhabitant of the equality type per inhabitant of a.
17:48:30 <dolio> ski: Unless the whole overall existential is squished to one element if the equality type is inhabited for any a.
17:49:02 <ski> no, only the witness is left behind
17:50:12 <ski> (i.e. for a blind `exists', `exists a : A. B', where `B' does not depend on `a', should be isomporphic to `B')
17:53:02 <ski> i was thinking one possibly could introduce a type `Forgotten : Set -> Set' (or maybe codomain `Prop' ?), where `Forgotten A' has a single inhabitant iff `A' is inhabited (otherwise `Forgotten A' is uninhabited)
17:53:20 <ski> and it seemed to me that such a `Forgotten' would form a monad
17:53:33 <SamB> ski: that sounds kind of crazy...
17:53:34 <dolio> Well, I have read about type theories like this.
17:53:38 <ski> assuming
17:53:53 <ski>   return : {A : Set} -> A -> Forgotten A
17:54:08 <dolio> They have a squash operator that is inhabited by a featureless element if the set they're applied to is inhabited.
17:54:47 <dolio> I forget if the operator was in something already, or if the paper was proposing it as a basis for something an existing system did by another means.
17:54:53 <hackagebot> hfractal 0.3.0 - OpenGL fractal renderer (ChrisHoldsworth)
17:54:54 <ski> the blind version of the existential `exists a : A. P a' could then maybe be encoded as `exists (return a) : Forgotten A. P a' (where the existential there is material)
17:55:43 <ski> dolio : interesting. do you remember where you saw this ?
17:55:44 <dolio> Naturally, it ends up being useful for quotient types, as I recall.
17:56:20 <ski> (yes, `Forgotten A' would be related to the coarsest quotient on `A' .. but i'm not sure it's quite the same idea)
17:57:03 <ski>   bind : {A B : Set} -> Forgotten A -> (A -> Forgotten B) -> Forgotten B
17:57:25 <dolio> So, skimming, I think the right paper is: Quotient Types: A Modular Approach.
17:57:40 <ski> the operational semantics of `bind' would be `bind (return _)  ~>  return _'
17:58:06 <dolio> And NuPRL and MetaPRL are the languages they're drawing-from-but-trying-to-do-better-than.
17:58:20 <ski> (er, `bind (return _) _ ~>  return _')
17:58:42 <ski> (or possibly even `bind _ _  ~>  return _')
17:59:01 <ski> dolio : ty
18:01:08 <lispy> ?check \xs -> take 1 (reverse (xs :: String)) == last xs
18:01:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:01:50 <lispy> ?check (\xs -> take 1 (reverse (xs :: String)) == last xs)
18:01:51 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:02:12 <lispy> ?check (\xs -> take 1 (reverse (xs :: [Int])) == last xs)
18:02:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
18:02:17 <lispy> Why is that failing?
18:02:24 <lispy> :t last
18:02:25 <lambdabot> forall a. [a] -> a
18:02:29 <lispy> :t take
18:02:30 <lambdabot> forall a. Int -> [a] -> [a]
18:02:35 <lispy> oh
18:03:27 <lispy> ?pl \f -> reverse $ drop 1 $ reverse f
18:03:27 <lambdabot> reverse . drop 1 . reverse
18:04:06 <lispy> > drop 1 "elloh"
18:04:07 <lambdabot>   "lloh"
18:04:17 <lispy> > init "hello"
18:04:19 <lambdabot>   "hell"
18:04:42 <lispy> > last []
18:04:43 <lambdabot>   * Exception: Prelude.last: empty list
18:04:50 <lispy> > take 1 []
18:04:52 <lambdabot>   []
18:12:31 <copumpkin> hmm
18:12:35 <copumpkin> not sure I can represent my VectorSpace instance nicely
18:12:37 <copumpkin> maybe I can actually, hrm
18:14:37 <copumpkin> so I could write an instance for Vector, but it represents LinearMap more abstractly than I could slap my matrix in
18:18:45 <Haji03> hey dis a hw help chan>?
18:19:26 <Haji03> any1 help me???
18:19:35 <copumpkin> Haji03: probably not, but ask anyway
18:19:43 <Haji03> kk ty
18:20:00 <Haji03> the ? is how do religious beliefs reflect interaction with the environment?
18:20:13 <Lycurgus> wrong channel
18:20:19 <Haji03> then whats the Channel
18:20:23 <Haji03> im new to this server
18:20:33 <Lycurgus> definitely not this one
18:20:44 <Haji03> it said this on some site from google
18:21:09 <Axman6> which site?
18:21:13 <dibblego> in that case, that site got it very wrong
18:21:22 <Axman6> because, this is definitely the wrong place
18:21:31 <Haji03> ok i get it
18:21:36 <Haji03> but can anyone please help me
18:21:39 <Haji03> this ? is stumping me
18:21:45 <Haji03> or atleast tell me a chan for hw help
18:21:46 <mauke> Haji03: this channel is about Haskell
18:22:03 <Lycurgus> the programming language
18:22:36 <Haji03> copumpkin
18:23:01 <copumpkin> Haji03: I don't know, people don't like to answer homework questions on any IRC as far as I know
18:23:11 <copumpkin> Haji03: but the basic point is that this is not the right place for that
18:23:13 <Haji03> yes
18:23:17 <Haji03> swiftirc.net
18:23:18 <Haji03> has one
18:23:21 <Haji03> but there afk atm
18:23:23 <copumpkin> then try that one
18:23:29 <copumpkin> and wait :)
18:23:35 <Haji03> due tomoro
18:23:39 <Haji03> and its like 12 am
18:23:41 <Haji03> cant w8
18:23:42 <copumpkin> here
18:23:45 <copumpkin> "I tried to buy a Renault in a Renault shop, but there were no salesmen available, so I came into this Ford shop. Why won't you sell me a Renault?!"
18:23:51 <Phyx-> oh geebus, 3.30am..
18:23:53 <Phyx-> g'night all
18:24:48 <dibblego> Haji03, this channel has nothing to do with religion, beliefs, interaction, the environment or homework
18:25:06 <Haji03> OMG REALLY
18:25:14 <Haji03> LIKE 20 ppl alredy said that
18:25:23 <Haji03> idiot...
18:25:36 <copumpkin> lol, he's in #wikipedia now
18:25:41 <dibblego> 20 times lucky *wink*
18:25:42 * ski shakes head in bewilderment
18:25:54 <Haji03> fuck all u niggers
18:25:57 <Lycurgus> cabal built fine from the tarballs with a little looking for dependencies but I'm surprised there's no debian pkg for the cmd line level
18:26:07 <copumpkin> lol
18:26:21 <copumpkin> I sure hope he wasn't older than 13
18:27:11 * copumpkin tries to figure out how to write *^ generically for his vectors
18:28:40 <copumpkin> without requiring Num, that is
18:29:03 * copumpkin gives in and asks for Num
18:29:12 * copumpkin hates Num
18:30:04 <dolio> What's the type of *^ look like?
18:30:20 <copumpkin> (*^) :: Scalar v -> v -> v
18:30:32 <copumpkin> where Scalar is an associated type
18:31:05 <dolio> Right. Well, you have to get scalar multiplication from somewhere.
18:31:25 <copumpkin> yeah, was just hoping the vector-space package had a non-num version of it somewhere
18:31:28 <copumpkin> since it already has AdditiveGroup
18:31:49 <dolio> Ah.
18:32:12 <ski> can one write `class VectorSpace v where type Scalar v; instance Num (Scalar v); ...' ?
18:32:24 <copumpkin> oh I can sort of get around it
18:33:00 <dolio> You can write 'class Num (Scalar v) => VectorSpace v where type Scalar v :: * ; ...' assuming that's properly implemented.
18:33:16 <ski> ok
18:38:13 <harblcat> so I've come to the assumption that using the List monad is kinda like list comprehensions...
18:38:29 <copumpkin> very much so :)
18:38:49 <copumpkin> in fact, comprehensions apparently used to work for arbitrary monads
18:38:53 <dolio> Seems like that'd probably be a conclusion, not an assumption. :)
18:39:03 * lispy waits for the ensuing conversation about monad comprehensions
18:39:15 * lispy types too slowly :)
18:39:19 <harblcat> dolio: I *thought* I was using the wrong word...
18:39:44 <copumpkin> dammit, my Num-free instance is not working
18:39:49 <Phyx-> 03:25:30 < Haji03> fuck all u niggers <-- rofl
18:40:30 <harblcat> Also, List is an interesting way to do non-deterministic stuff..
18:40:41 <copumpkin> harblcat: yep!
18:41:21 <copumpkin> dammit, why isn't this working
18:42:47 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8836#a8836 :(
18:45:14 <copumpkin> @seen Haji03
18:45:15 <lambdabot> I saw Haji03 leaving #haskell 19m 19s ago, and .
18:45:22 <copumpkin> preflex: seen Haji03
18:45:22 <preflex>  Haji03 was last seen on #haskell 19 minutes and 28 seconds ago, saying: fuck all u niggers
18:45:25 <copumpkin> lol
18:47:25 <dolio> copumpkin: type Scalar (Vec n a) = Scalar a.
18:47:32 <copumpkin> oh duh
18:47:49 <copumpkin> thanks :)
18:50:00 <ezyang> I don't understand how you can throw an exception in pure code.  It doesn't... make sense
18:50:41 <Axman6> > error "EXCEPTION!!!!"
18:50:43 <lambdabot>   * Exception: EXCEPTION!!!!
18:50:45 <benmachine> it's fine; only catching them causes problems
18:51:01 <Phyx-> :t throw
18:51:03 <lambdabot> Not in scope: `throw'
18:51:11 <Phyx-> @hoogle throw
18:51:12 <ezyang> :t Control.Exception.throw
18:51:12 <lambdabot> Control.Exception throw :: Exception -> a
18:51:12 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
18:51:12 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
18:51:13 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
18:51:33 <ezyang> It means I can't trust a pure function to give me a result...
18:51:47 <dolio> That's true anyway.
18:51:52 <ezyang> I suppose
18:51:58 <dolio> f x = f x gives you no results.
18:52:10 <ezyang> The other thing that bothers me is that it isn't encoded anywhere in the types
18:52:27 <benmachine> ezyang: how would you access the result, in any case?
18:52:28 <copumpkin> ezyang: you want total functional programming!
18:52:52 <ezyang> benmachine: What do you mean?
18:52:58 <ezyang> copumpkin: Mua ha ha ha
18:53:50 <benmachine> ezyang: I might have had a point but it would probably require keeping my eyes open to articulate it
18:53:51 <ezyang> copumpkin: I guess, in that case, I should use something like Either
18:53:54 <benmachine> not keen on that at the moment
18:53:59 <ezyang> :-)
18:54:36 <copumpkin> woot, I haz VectorSpace and InnerSpace instances now
18:55:51 <pr> > let f x = x ++ error "ARGH!!!!" in f "EVIL"
18:55:52 <lambdabot>   "EVIL* Exception: ARGH!!!!
18:56:01 <copumpkin> *Vec> ((1 :> 2 :> 3 :> Nil) <.> (5 :> 6 :> (7 :: Double) :> Nil))
18:56:01 <copumpkin> 38.0
18:56:03 <copumpkin> woot
18:56:11 * copumpkin needs him some syntactic sugar now
18:56:16 <ezyang> whoa
18:56:31 <copumpkin> > 1 * 5 + 2 * 6 + 3 * 7
18:56:33 <lambdabot>   38
18:57:08 <ezyang> Oh yeah, that's my other question: the type signature indicates "a" is the return type of the function... but that's not specified anywhere...
18:57:33 * copumpkin wonders how to bring his Mat type into this
18:57:45 <pikhq> ezyang: Yeah, and? That means that it can result in a value of any type.
18:58:02 <copumpkin> or HasBasis, hmm
18:58:17 <Axman6> copumpkin: what's the type of <.>
18:58:18 <ezyang> pikhq: but... what is it's value?
18:58:18 <Axman6> ?
18:58:26 <dolio> Bottom.
18:58:30 <ezyang> :t (<.>)
18:58:31 <copumpkin> (<.>) :: (InnerSpace v) => v -> v -> Scalar v
18:58:31 <lambdabot> Not in scope: `<.>'
18:58:41 <Axman6> i see
18:58:43 <pikhq> ezyang: Depends: what function are you talking about, and what is its argument?
18:58:45 <ezyang> dolio: ... What's bottom?
18:58:51 <ezyang> pikhq: throw
18:58:54 <pikhq> Ah.
18:58:54 <dolio> It's a value that inhabits every Haskell type.
18:58:57 <Vanadium> error :: String -> a does not mean so much "i will return a value of type a" as it means "i will not return a value that is not of type a" :V
18:59:04 <pikhq> That's bottom, yeah.
18:59:05 <ezyang> oh... is that sort of like null?
18:59:18 <copumpkin> ezyang: yeah, except you can't touch it
18:59:18 <Vanadium> and since the entire point of error is to, in fact, not return, it might as well promise any value
18:59:20 <dolio> Not exactly.
18:59:26 <Vanadium> err, any type
18:59:37 <Vanadium> ezyang: It is sort of like throwing an exception in an imperative language
18:59:58 <ezyang> Ok. Is there a function whose value is bottom?
19:00:02 <dolio> In 'f x = f x' the result of f x is bottom.
19:00:14 <copumpkin> ezyang: it's like null in that every type contains the value, but unlike it in that you can't test for it (and if you even look at it, you explode into a million pieces)
19:00:26 <ezyang> Hmmmm...
19:00:28 <Axman6> > let f x = g x; g x = f x in f 1
19:00:34 <lambdabot>   mueval-core: Prelude.read: no parse
19:00:34 <lambdabot>  mueval: ExitFailure 1
19:00:35 <ezyang> But there's isBottom
19:00:40 <vininim> 0 is not null!
19:00:41 <copumpkin> ezyang: that's a hack in quickcheck
19:00:42 <Axman6> :t let f x = g x; g x = f x in f
19:00:44 <lambdabot> forall t t1. t -> t1
19:00:49 <ezyang> :t Test.QuickCheck.Batch.isBottom
19:00:50 <lambdabot> Couldn't find qualified module.
19:00:59 <ezyang> lambdabot fail
19:01:00 <copumpkin> ezyang: but in reality, it's impossible to write isBottom
19:01:03 <copumpkin> @hoogle isBottom
19:01:04 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
19:01:05 <Vanadium> ezyang: "returns bottom" basically means "does not return successfully, ie hangs or throws errors"
19:01:12 <ezyang> ok
19:01:22 <ezyang> But, we /are/ able to catch exceptions, no?
19:01:33 <Vanadium> Only in the context of IO
19:01:49 <Vanadium> You are not able to "catch" infinite recursion like in the f x = f x case
19:02:00 <ezyang> Vanadium: So... the compiler needs to support it?
19:02:10 <pr> @type [undefined]
19:02:12 <lambdabot> forall a. [a]
19:02:23 <Vanadium> The "value" of f x is still bottom, even though you cannot do anything with it
19:02:24 <ray> yeah, let's just add a halting oracle to our compiler
19:02:38 <Vanadium> ezyang: What do you mean?
19:03:05 <Axman6> speakig of halting, anyone know much about WP calculus? i'm quite liking it
19:03:10 <vininim> :t id
19:03:10 <Axman6> ing*
19:03:11 <ezyang> Vanadium: as in, it would be impossible for me to reimplement "catch"
19:03:11 <lambdabot> forall a. a -> a
19:03:24 <ezyang> without utilizing hacks or something
19:03:36 <ray> white phosphorous calculus?
19:03:41 <Makoryu> ezyang: Correct.
19:03:47 <ezyang> Ok.
19:03:56 <Axman6> ray: weakest precondition
19:04:06 <vininim> :t throw
19:04:07 <lambdabot> Not in scope: `throw'
19:04:13 <copumpkin> ski: you know if vector-space has any facility for me to implement my linear maps using my matrices? I can't see it (I wrote Vec instances for everything)
19:04:28 <vininim> :t Control.exception.throw
19:04:29 <lambdabot> Couldn't find qualified module.
19:04:48 <ezyang> :t Control.Exception.throw
19:04:50 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
19:04:58 <Makoryu> ezyang: There's an entirely different type of exception that uses the Either type to represent either a useful value or an error
19:05:08 <pr> @type Reader
19:05:10 <lambdabot> forall r a. (r -> a) -> Reader r a
19:05:19 <ezyang> Makoryu: Yep
19:05:42 <ezyang> But that's far more useful for algorithmic programming, as opposed to system programming
19:06:21 <copumpkin> @seen conal
19:06:21 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 4d 5h 44m 30s ago, and .
19:06:36 <ezyang> ... haskell-iphone?
19:06:38 <vininim> :t undefined
19:06:39 <lambdabot> forall a. a
19:06:47 <ezyang> ooh, is undefined bottom?
19:06:58 <pr> it is
19:07:01 <Makoryu> @src undefined
19:07:01 <lambdabot> undefined =  error "Prelude.undefined"
19:07:05 <Makoryu> @src error
19:07:05 <lambdabot> error s = throw (ErrorCall s)
19:07:06 <lispy> > let undefined = bottom in undefined
19:07:07 <lambdabot>   Not in scope: `bottom'
19:07:09 <ezyang> ho ho ho ho
19:07:15 <Makoryu> @src ErrorCall
19:07:15 <lambdabot> Source not found.
19:08:11 <altmattr> I am trying to remember the name of the haskell program that supervises other code - or something like that.  Someone has used it to make a paste bin that compiles and runs your code.
19:08:32 <mmorrow> copepad.org is the site
19:08:55 <mmorrow> there's a description page there
19:09:07 <defun> does haskell work/compile yet, to the iphone?
19:09:12 <mmorrow> err
19:09:26 <mmorrow> ah n/m
19:09:36 <Makoryu> defun: I dunno! Let's go to #haskell-iphone and ask them.
19:09:44 <altmattr> mmorrow: legend!
19:10:50 <mmorrow> legend?
19:11:11 <mmorrow> altmattr: link?
19:11:19 <vininim> codepad.org
19:11:37 <altmattr> mmorrow: sorry, wrong punctuation
19:11:41 <altmattr> mmorrow: legend!
19:12:01 <mmorrow> is "legend" the name of the haskell pkg/whatnot?
19:12:11 <mmorrow> if so, is it available anywhere
19:12:11 <mmorrow> ?
19:12:32 * copumpkin doesn't really get how the HasBasis class works in vector-space
19:12:42 <copumpkin> it doesn't seem to correspond to my intuition on bases
19:12:47 * mmorrow has no idea what "lengend!" means
19:13:13 <Gracenotes> @botsnack
19:13:13 <lunabot>  :)
19:13:14 <lambdabot> :)
19:13:23 <Gracenotes> :(
19:13:54 <altmattr> mmorrow: it means you are a legend, a great legend, a fine individual who has improved my day.
19:14:14 <altmattr> mmorrow: and that my typing is terrilbe
19:14:52 <mmorrow> altmattr: ah :)
19:15:12 * altmattr curses his macbook keyboard
19:15:30 <mmorrow> altmattr: unfortunately the codepad.org guy has all the code under wraps
19:16:30 <altmattr> mmorrow: I want to have a chat with him since I am working on a project to allow students at our uni to compile and run little bits of code on our servers - to help write programming quizzes that are automatically marked
19:16:39 <copumpkin> can anyone figure out how http://hackage.haskell.org/packages/archive/vector-space/0.5.7/doc/html/Data-Basis.html works?
19:16:59 <altmattr> mmorrow: codepad does everything we need!
19:17:26 <mmorrow> altmattr: he was in here at one point, but i don't recall his nick, so not sure if he hangs around
19:17:45 <altmattr> mmorrow: it is a great job he has done
19:18:03 <mmorrow> altmattr: yeah, that's definitely a first-of-its-kind site
19:18:45 <Berengal> There is some previous art in \b
19:19:28 <mmorrow> Berengal: not as a publicly available site, that allows arbitrary code execution and no restriction on imports/libraries used
19:19:45 <Berengal> mmorrow, yeah, it's pretty neat in that
19:21:04 <mmorrow> http://codepad.org/xlGfYO8n
19:21:06 <mmorrow> yay
19:21:31 <Makoryu> Berengal: \b?
19:21:36 <Berengal> Makoryu, lambdabot
19:21:40 <Makoryu> Ah
19:22:02 <Berengal> mmorrow, possible hole found?
19:22:16 <Berengal> Eh, probably not. You can do that in c easily
19:22:21 <davidL> > (pascal 5 3)
19:22:23 <lambdabot>   Not in scope: `pascal'
19:22:37 <defun> hey would it be possible to make an OS in haskell, that is similar in architecture to xmonad, and runs on bear metal? In the sense that, there is a lean, verified core, and all the other 'applications' are loaded as plugins? Not sure how recompilation/dynamic loading would be handled... And god help  you if you want to upgrade GHC... any thoughts?
19:23:17 <mle> defun: House tried to address some of these questions
19:23:20 <davidL> defun: see the HASP project and the House OS
19:23:42 <defun> mle, davidL: thanks
19:23:45 <altmattr> defun: and the reliance on a particular version of a particular compiler is not at all unusual for operating systems
19:24:15 <defun> ah, that's good news.
19:24:33 <Makoryu> defun: If an OS like that gained enough traction, GHC would inevitably come with options geared towards building it.
19:25:19 <defun> sweet. I guess I better get started right away :)
19:27:14 <copumpkin> hmmm hmm hmm
19:27:25 <copumpkin> I guess my Basis type for Vec would be Nat
19:27:30 <mmorrow> dang, looks like you can't FFI import stuff on codepad.org
19:27:34 <copumpkin> as an index into the vector
19:27:38 <mmorrow> (iirc it uses hugs too)
19:27:46 <Gracenotes> speaking of which, have they made a compiler that does the linux kernel other than gcc yet?
19:28:28 <mmorrow> Gracenotes: i'm sure a bunch
19:28:40 <Makoryu> Gracenotes: They're working on it. A few compilers (clang, tcc, and pcc, I think) can do FreeBSD, but Linux uses a lot of GCC-specific extensions
19:28:49 <mmorrow> at least icc i know for sure
19:28:57 <mmorrow> open64?
19:29:06 <Gracenotes> ah. that might be it.
19:29:34 <mmorrow> i was just trying open64 out the other day, it's nice
19:29:51 * mmorrow wishes he had icc though
19:30:17 <mmorrow> supposedly it generate much better code than gcc
19:31:54 <Makoryu> That's probably not hard
19:32:40 <Makoryu> GCC's back end is notoriously poorly designed... It's a hack on top of a kludge on top of a steaming pile of line noise
19:34:10 <mmorrow> heh
19:34:57 <BMeph> BBL - trying to make Vista behave... :(
19:35:51 <dmwit> Huh.  I never thought of it before, but having password requirements like "includes a number and a letter" actually *reduces* the search space for attackers.
19:35:54 <dmwit> =(
19:36:03 <Makoryu> dmwit: Hmm, true....
19:38:22 <mmorrow> dmwit: that's like saying that putting your valuables in a safe reduces the amount of your house someone trying to steal them needs to search
19:38:25 <dolio> A lot of requirements stupidly narrow it even more than that.
19:38:41 <dolio> Like, 'can't start or end with a number.'
19:39:22 <mmorrow> , let login = (=="zoology") in filter login dict
19:39:26 <lunabot>  ["zoology"]
19:39:27 <Axman6> dolio: might reduce the search space, but it also makes people use (usually slightly) more complex passwords
19:39:32 <dmwit> I guess the real question is, given human nature, is the distribution of passwords flatter with these requirements than it would be if they were just guidelines?
19:39:49 <dmwit> Where "flatter" is defined rigorously using entropy, of course.
19:40:02 <Axman6> uh, s/dolio/dmwit
19:40:16 <defun> or alternatively, one can take the MIT exokernel, and layer a library-OS written in haskell.
19:40:30 <dmwit> Axman6: Complexity of the password is unimportant.
19:40:51 <Axman6> defun: sounds like an excessive way to produce secure passwords :P
19:41:02 <mmorrow> dmwit: since it's hard to exhaustively search, having the passwd not be a dictionary word makes it a lot harder to choose which subspace you'll search
19:41:07 <Axman6> dmwit: well, yeah, but it increases length usually
19:41:09 <dmwit> Axman: uKblVx6DE is a complex password, but if the requirement is, "Your password must be uKblaVx6DE", that's a bad password. =)
19:41:12 <defun> Axman6: lol, not what I was refering to...
19:41:48 <mun> can anyone see why, on line 22, it can't match type `ResultT IO ([LIB_ITEM], DGraph, LibEnv, LogicGraph)' against inferred type `IO ([LIB_ITEM], DGraph, LibEnv, LogicGraph)? http://haskell.pastebin.com/m72f608a1
19:42:56 <dmwit> mun: :t item
19:42:57 <dmwit> ?
19:43:53 <dmwit> mun: oh
19:44:23 <dmwit> mun: It's because the RHS of your <- is a ResultT, but the entire function is an IO.
19:44:50 <copumpkin> @hoogle showsPrec
19:44:51 <lambdabot> Prelude showsPrec :: Show a => Int -> a -> ShowS
19:44:51 <lambdabot> Text.Show showsPrec :: Show a => Int -> a -> ShowS
19:45:21 <dmwit> showsPrec was very mysterious to me, until one time I tried to write a syntax-tree pretty-printer.
19:45:39 <dmwit> And then I looked at the type, and went... "Oh!"
19:45:41 <dmwit> haha
19:46:28 <mun> dmwit, but the RHS of <- shouldn't be a ResultT, right? foldM returns m a, thus IO ([LIB_ITEM], DGraph, LibEnv, LogicGraph)
19:46:49 <dmwit> mun: foldM returns m a, but here m is decided by the type of ana, which returns a ResultT.
19:48:15 <Gracenotes> meow
19:48:42 * ksf considers writing a class for every function he defines.
19:49:06 <mun> dmwit, but doesn't ana calls runResultT, which gives m (Result a).. m should be IO right?
19:49:23 <ksf> seriously, I'm fed up with typeclasses that contain more elements than the bare nescessities.
19:49:31 <dmwit> mun: ana doesn't call runResultT in what you pasted, no.
19:49:40 <dmwit> mun: The top-level constructor is ResultT.
19:49:52 <dmwit> ana .... = let ... in ResultT (do ...)
19:50:04 <ksf> ...and names that are occupied by selfish, classless definitions.
19:50:04 <dmwit> (I've elided the unimportant parts.)
19:50:12 <ksf> damn them communists!
19:50:18 <mun> dmwit, ooh! damn missed that.. thanks
20:04:37 * copumpkin tries to figure out how to write HasBasis generically
20:04:50 <mun> dmwit, with foldM ana... since foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a and ana returns ResultT (m Result a), then ana doesn't have the type a -> b -> m a right?
20:04:50 <copumpkin> but I'm starting to think it isn't possible
20:06:01 <dmwit> mun: um
20:06:20 <dmwit> mun: I think ana does indeed have the type (a -> b -> m a).
20:06:33 <mun> dmwit, hmm right.. but how come?
20:07:05 <dmwit> Most likely (ResultT m' Result) is a monad.
20:07:19 <dmwit> So m = ResultT m' Result in the above type.
20:07:24 <copumpkin> w00t
20:07:41 <dmwit> mun: Be careful about conflating 'm's that aren't related. =)
20:08:12 <dmwit> In particular, the 'm' in the type of foldM and the 'm' in the type of "ana" that you wrote above need not necessarily be the same m.
20:09:12 <ksf> is there a way to properly haddock c2hs-processed enums?
20:09:55 <SamB_XP> ksf: member-by-member, or?
20:10:08 <ksf> exactly that's what I want.
20:10:20 <SamB_XP> and I guess you'd have to get c2hs to output the haddock markup?
20:10:32 <ksf> exactly.
20:10:45 <SamB_XP> but where the heck would you *write* the comments?
20:11:09 <ksf> ...and I'm quite surprised vim does exactly what I want when I indent a rectangular selection
20:11:20 <ksf> ...in the header file, in my case.
20:11:27 <SamB_XP> ksf: ah.
20:11:38 <SamB_XP> probably not...
20:11:44 <mun> dmwit, right right
20:11:48 <SamB_XP> ... yet
20:11:53 <ksf> there's also the possibilty of just listing them, and have c2hs zip up two lists.
20:12:13 <ksf> ...both of which aren't supported, to the best of my knowledge
20:12:17 <ksf> (which isn't much)
20:12:38 <ksf> ...or match by name, or whatever.
20:12:54 <SamB_XP> well, for it to be anything like reliable, it ought to involve both names and docs
20:13:12 <mun> dmwit, thanks
20:13:20 <dmwit> cheers
20:14:04 * copumpkin can't convince SHE to accept his infinite natural
20:14:20 <SamB_XP> copumpkin: good for her
20:14:28 <copumpkin> :(
20:14:40 <SamB_XP> she should not accept such an abomination!
20:14:54 <SamB_XP> it's ... unnatural
20:14:54 <copumpkin> but without it I can't write functions like repeat
20:15:21 <dmwit> Maybe Natural?
20:15:29 <copumpkin> this is at the type level
20:15:30 <SamB_XP> you perhaps want a co-natural
20:16:04 <dmwit> repeat is not inductive; does she have some restrictions about mu vs nu?
20:16:19 <dmwit> (As it's by Conor, I wouldn't be surprised at all if it were quite strict indeed about such things.)
20:16:38 <copumpkin> not sure, there's not much information
20:23:06 <forgot> is there any way to undo an import in ghci?
20:24:49 <Draconx> forgot, :m - modulename
20:24:52 <Gracenotes> :m -Bla
20:25:06 <Gracenotes> er. at least it seems to work here
20:25:06 <mithos28> is there an easy fix to getting ghc working with snowleopard?
20:25:17 <forgot> ok
20:25:27 <lispy> mithos28: are you running the 64bit kernel or the 32bit kernel?
20:25:53 <lispy> mithos28: I was doing testing for our snow leopard release at work and discovered that by default it boots on most machines into a 32bit kernel
20:26:05 <mithos28> how would i check?
20:26:08 <copumpkin> the kernel bit-ness shouldn't affect it
20:26:11 <lispy> mithos28: and since some people are saying that ghc is working on snow leopard it miht be a good data point
20:26:11 <copumpkin> mithos28: uname -a
20:26:31 <copumpkin> what affects it is the default architecture that gcc builds for
20:26:41 <copumpkin> which switched from i386 to x86_64 in snow leo
20:26:47 <mithos28> 10.0.0 Darwin Kernel Version 10.0.0: Fri Jul 31 22:47:34 PDT 2009; root:xnu-1456.1.25~1/RELEASE_I386 i386
20:26:50 <copumpkin> consistently, regardless of your kernel arch
20:27:10 <dmwit> copumpkin: whoops
20:27:20 <copumpkin> ?
20:27:53 <dmwit> copumpkin: That sounds like somebody made a mistake.  Default builds for x86_64 even on i386 machines?  I say "whoops". =)
20:28:15 <copumpkin> dmwit: well, on any x86_64-capable machine it builds for x86_64 I guess :P
20:28:32 <copumpkin> but most intel macs are 64-bit so that's most of them
20:29:06 <copumpkin> this makes me sad: > instance (HasBasis a, () ~ Basis a, a ~ Scalar a, {:n :: Nat:}) => HasBasis (Vec n a) where
20:29:16 <mithos28> the haskell cafe logs show that 6.10.1 seem to work for someone
20:29:17 <copumpkin> that a ~ Scalar a restricts it a lot
20:29:38 <copumpkin> but without it, I can't get it to compile
20:30:04 <ksf> haddock fails on paragraphs inside lists.
20:30:39 <ksf> I wouldn't care about that, if c2hs would let me document enums properly.
20:30:50 <lispy> mithos28: try rebooting and holding down 6 and 4.  That's supposed to force a boot into the 64bit kernel.
20:31:02 <Axman6> lispy: SL uses the 32 bit kernel by default so that drivers work. doesn't affect anything else
20:31:11 <mithos28> ok ill try that
20:31:38 <Axman6> there's no reason to boot into the 64 bit kernel (and unless you're on a machine with SSE4, it won't boot into it anyway)
20:31:57 <lispy> Hmm
20:32:02 <lispy> Then what is the issue with gcc?
20:32:09 <lispy> Guess I don't quite understand
20:32:29 <copumpkin> mac os supports running i386, x86_64, and sometimes ppc code natively, regardless of the kernel, since 10.5
20:32:41 <copumpkin> in 10.5, gcc built for i386 by default, unless you asked it to do otherwise
20:32:49 <copumpkin> in 10.6, the default switched (when possible) to x86_64
20:33:02 <matsuura> the hell with you all.. >:(
20:33:12 <lispy> hi matsuura
20:33:17 <matsuura> oh, hey :D
20:33:35 <SamB_XP> copumpkin: why "and sometimes ppc"?
20:33:51 <SamB_XP> and how can it run x86_64 code natively on i386?
20:33:54 <copumpkin> SamB_XP: there's a program called rosetta that will launch ppc apps
20:34:01 <copumpkin> it can't, but most macs are x86_64
20:34:13 <SamB_XP> oh
20:34:15 <Axman6> SamB_XP: all macs sold in like the last 2 years have been 64 bit
20:34:30 <Axman6> there were only a few Core Solo and Duo machines
20:34:35 <SamB_XP> and of course mac users buy new computers every 2 years
20:35:00 <Axman6> mac users buy new macs every 5 years, because they last that long ;)
20:35:05 <matsuura> hey SamB_XP
20:35:06 <matsuura> >_>
20:35:15 <SamB_XP> hey
20:35:30 <matsuura> you e-stalking me? :(
20:35:39 <copumpkin> >   decompose = toList . indexed
20:35:39 <copumpkin> >   decompose' = (!!)
20:35:40 <lambdabot>   <no location info>: parse error on input `='
20:35:41 <lambdabot>   <no location info>: parse error on input `='
20:35:47 <SamB_XP> matsuura: no, are you e-stalking me?
20:35:58 <SamB_XP> ;-{
20:36:00 <SamB_XP> er.
20:36:02 <SamB_XP> ;-P
20:36:03 <matsuura> SamB_XP: no... but i'm very moise atm
20:36:12 <SamB_XP> that's better ;-)
20:36:13 <Axman6> moist?
20:36:25 <lispy> Hey, taking it haskell-blah :)
20:36:30 <lispy> er take it to
20:36:32 <matsuura> It's not what you think, sorry
20:36:32 * copumpkin wonders what to do with his vector-space instances
20:36:47 <lispy> copumpkin: create an army of sentient robots?
20:37:03 <SamB_XP> lispy: hmm. how?
20:37:22 <Berengal> Why does cabal install parsec default to 2.1, not 3?
20:37:47 <SamB_XP> Berengal: apparently 3 breaks a lot of stuff
20:38:09 <Berengal> SamB_XP, so it's a kludge
20:38:34 <mithos28> lispy: that didn't seem to change the kernel
20:38:35 <SamB_XP> there's like a file full of the preferred latest versions of things, I think
20:38:56 <SamB_XP> to keep people from running into the bleeding edge by mistake, aiui
20:39:09 <Berengal> People need to specify upper bounds...
20:39:42 <Berengal> I'd say "otherwise they deserve to run into the bleeding edge", but unfortunately they're not the ones it causes problems for...
20:39:59 <SamB_XP> some versions just aren't very good, maybe?
20:40:55 <Berengal> I'm talking about the cabal packages. Dependencies should always have upper bounds
20:41:26 <Berengal> (Perhaps hackage could reject packages without?)
20:41:33 <mithos28> lispy: it looks like apple has limited the boot to the 64 bit kernel to 64-bit EFI machines, so that trick will not work on my machine
20:43:20 <stianhj> anyone having problems with HsColour and GHCi, or just me? HsColour seems to forget a '\n' on the last line of it's output..
20:44:27 <Axman6> mithos28: i said it earlier, but you might have left by then, but you can't boot the 64 bit kernel uless you have SSE4
20:44:28 <SamB_XP> Berengal: if something goes wrong in another package despite it's having a supposedly-compatible version number, should your package suffer for it?
20:45:01 <Axman6> mithos28: there's also no reason to use the 64 bit kernel. it'll break basically anything that uses a kext, and gets you basically no benefits
20:45:23 <Berengal> SamB_XP, no, but not specifying upper bounds doesn't fix this... quite contrary, in fact
20:45:33 <mithos28> Axman6: I think i must have left, all im trying to do is get ghc to work
20:45:40 <copumpkin> has anyone golfed matrix multiplication at any point?
20:45:44 <copumpkin> as lists of lists?
20:45:45 <copumpkin> :P
20:46:10 <SamB_XP> Berengal: true, so upper bounds should probably be specified whenever using packages believed to follow the PVP, sure
20:46:34 <SamB_XP> Berengal: otherwise I dunno what you should do ...
20:46:46 <dmwit> copumpkin: Not as lists, but as arrays.
20:46:55 <Berengal> SamB_XP, the worst you could do is ==
20:47:12 <SamB_XP> but regardless, having a file of what versions are the max that is "known reasonable" isn't that horrible ...
20:47:31 <copumpkin> dmwit: hmm, can I see it?
20:47:52 <Berengal> SamB_XP, it is when I have to spent 30 minutes figuring out why something doesn't work :/
20:47:54 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8837#a8837
20:48:08 <copumpkin> :o
20:48:27 <luite> Axman6: doesn't a 64 bit kernel allow the kernel allow for more kernel memory, for things like disk cache?
20:48:49 <dmwit> copumpkin: Well, it does a few other things, too. ^_^
20:48:53 <Axman6> luite: no
20:48:59 <Berengal> In this case, I was rebuilding packages with profiling, which unfortunately can't be done automagically, and somewhere in my chain I rebuilt parsec-2.1 where something further up the chain depended on parsec-3.0
20:49:13 <SamB_XP> Berengal: ah, yeah
20:49:31 <lispy> Berengal: you can tell cabal to always enable library profiling
20:49:46 <Berengal> lispy, I've done that, but unfortunately not from the start
20:49:48 <Axman6> well, it may allow YB of RAM for applications... but ... well... practicallity. the 32 bit kernel handles >4GB of RAM for 64 bit apps just fine. has done so since 10.4
20:49:52 <SamB_XP> Berengal: it really should be easier to just get cabal to add profiling builds to the versions you already have ...
20:49:52 <lispy> Berengal: ah yeah
20:50:00 <lispy> Berengal: I think it's a bug in the cabal defaults to not enable it
20:50:05 <Berengal> lispy, after I did, I had to spend two hours rebuilding just to be able to install new packages
20:50:29 <SamB_XP> ... how the hell can apple's 32-bit kernel run 64-bit apps?
20:50:41 <Berengal> Every now and then I encounter a new un-profiled package I have to rebuild, but I don't encounter the 10-level deep dependencies any more
20:50:41 <SamB_XP> must be some kind of 64-bit microkernel...
20:50:47 <luite> Axman6: oh really? I thought that was one of the good reasons for switching, kernel memory is fairly limited because of the kernel/app split (I only use linux and windows though, don't know about mac)
20:51:03 <Gracenotes> you are now thinking about yawning
20:51:07 <Axman6> yeah well Apple are smarter than that ;)
20:51:12 <Gracenotes> yawn with me :3
20:51:16 <dmwit> You are now conscious of your breathing.
20:51:17 <Axman6> Gracenotes: you're a jerk :P
20:51:24 <lispy> Gracenotes: subliminal!
20:51:25 <dmwit> You are now aware of how bad your posture is.
20:51:29 <SamB_XP> luite: well, the kernel may have that limitation, yes ...
20:51:40 <Berengal> You now have an itch
20:51:44 <lispy> suddenly this became a lot more like a text adventure
20:51:47 <Axman6> the kernel doesn't need to use more than 4GB of RAM
20:51:48 <lispy> east
20:51:50 <dmwit> haha
20:51:52 <dmwit> It is dark!
20:51:53 <Berengal> You see a dark coridor
20:51:54 <lispy> pickup lambdabot
20:51:54 * Gracenotes gives Berengal lice
20:52:01 <Axman6> as long as it can let applications do so, everything's good
20:52:02 <SamB_XP> hmm. how the heck does a 64-bit read call concerning an address > 4GB work?
20:52:09 <Berengal> lambdabot is bolted to the ground. It cannot be picked up
20:52:23 <Axman6> SamB_XP: Apple magic
20:52:35 <SamB_XP> apple is always so damn smart with these things
20:52:41 <Axman6> yup
20:52:51 * copumpkin can write the diagonal of the matrix product really easily with simple list operations
20:53:02 <SamB_XP> why did they do something as dumb as using a totally different ABI from everyone else for their i386 port?
20:53:18 <copumpkin> Think Different (tm)
20:53:26 <erikc`> is the abi better at least?
20:55:41 <Axman6> SamB_XP: Mach-O?
20:55:58 <SamB_XP> Axman6: I meant the calling convention, not the image format
20:56:14 <SamB_XP> win32 and mainstream *nix already disagree about *that*
20:56:17 <copumpkin> hmm, I have all the elements of the matrix product but in diagonal order :o
20:56:33 <Axman6> SamB_XP: they use a different calling convention?
20:57:59 <ksf> there are other calling conventions that ccall and linux syscalls?
20:58:13 <lispy> ksf: yeah
20:58:24 <lispy> ksf: windows has a calling convention
20:58:34 <lispy> and pascal/fortran have some too, IIRC
20:58:48 <ksf> heck, I even painfully duplicated the ccall spec in nasm preprocessor-macros...
20:58:49 <SamB_XP> well, what windows calls "cdecl" is the default most places for C ...
20:59:10 <copumpkin> aha: transpose [[row `dot` col | row <- x] | col <- transpose y]
20:59:17 <copumpkin> that seems simple enough
20:59:17 <Draconx> is "cdecl" the calling convention specified in the SysV ABI i386 supplement?
20:59:24 <SamB_XP> Draconx: essentially
20:59:38 <SamB_XP> I haven't noticed any real differences
20:59:40 <copumpkin> @let dot xs ys = sum $ zipWith (*) xs ys
20:59:42 <lambdabot>  Defined.
20:59:56 <ksf> push left to right, caller clears the stack, return in rax/mmsomething
20:59:56 <copumpkin> @let mul x y = transpose [[row `dot` col | row <- x] | col <- transpose y]
20:59:57 <lambdabot>  Defined.
21:00:01 <copumpkin> :t mul
21:00:03 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
21:00:17 <SamB_XP> and I sure hope the same is true for x86_64, though I in fact have no actual idea
21:00:43 <lispy> SamB_XP: I think x86_64 uses different registers, at least on linux
21:00:53 <lispy> SamB_XP: I recall this being a problem for me in the compiler I was writing
21:01:30 <SamB_XP> lispy: I mean, I hope the Windows ABI agrees with the sysv supplement for *x86_64*
21:01:43 <SamB_XP> I know the ABIs themselves are quite different
21:01:44 <ksf> x86 has 8 more registers, you _have_ to use them for _something_...
21:01:58 <SamB_XP> that's presumably a good thing ;-)
21:02:01 <ksf> 8? was it 8?
21:02:12 <SamB_XP> ksf: x86 has 8 quasi-GPRs
21:02:12 <copumpkin> depends which ones you count
21:02:21 <SamB_XP> x86_64 has 8 new GPRs
21:02:38 <ksf> eax ebc ecx edx esi edi ebp ... uhm.
21:02:54 <SamB_XP> I say quasi-GPRs because at leat 6 of them have non-GP uses as well
21:02:56 <mmorrow> x86_64 is %rdi,%rsi,%rdx,%rcx,%r8,%r9 for ccall
21:03:04 <SamB_XP> that is, register-specific operations
21:03:04 <mmorrow> first 6 in regs yay!
21:03:13 <ksf> accumulator base count data.
21:03:49 <SamB_XP> oh, wait, I think they *all* have unique operations that use them
21:03:51 <ksf> repnz stosb.
21:04:41 <ksf> ...uses at least ecx and edi
21:04:53 <ksf> ...and of course ebp
21:05:02 <SamB_XP> the x86_64 also has, what ... the SSE registers for sure ?
21:05:05 <ksf> no we aren't segmented, it doesn't.
21:05:07 <Axman6> > mul [[1,0,0],[0,1,0],[0,0,1]] [[1,2,3],[4,5,6],[7,8,9]]
21:05:09 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
21:05:17 <ksf> mmx and sse.
21:05:23 <ksf> ...which overlap with the fpu ones.
21:05:31 <SamB_XP> SSE doesn't use FP regs
21:05:45 <ksf> not using, but overlapping.
21:05:48 <SamB_XP> or, well, I mean -- not except for interop purposes
21:05:51 <ksf> you can't use them at the same time.
21:05:55 <mmorrow> flip: xchgq %rdx,%rdi; jmp %rdx
21:06:03 <SamB_XP> MMX is the one that overlays the x87 regs
21:06:14 <ksf> you shouldn't use x87 on amd64 if you can help it, anyway.
21:06:16 * mmorrow doesn't want to imagine how to do that flip on x86
21:06:18 <SamB_XP> SSE has it's own xmm regs
21:06:46 <mmorrow> err, jmp *%rdx
21:06:57 * ksf doesnt read AT&T
21:07:02 * mmorrow hates intel
21:07:05 <mmorrow> :)
21:07:56 <ksf> there's just no better assembler than nasm.
21:08:01 <mmorrow> hehe
21:08:03 <ksf> ...at least the last time I used one.
21:08:04 <Draconx> depends what you're doing.
21:08:56 <Draconx> I find nasm syntax to be annoying as a compiler target, for example.
21:08:57 <ksf> writing an arcanoid-clone with proper collision in 32 bit assembly for linux.
21:09:18 <mmorrow> :o
21:09:32 <SamB_XP> Draconx: why's that?
21:09:46 <ksf> I've still got most of the code, but the collision detection found its way into the bit bucket.
21:10:06 <Draconx> SamB_XP, The issue that bugged me most was needing to declare external identifiers as such.
21:10:15 <SamB_XP> hmm.
21:10:19 <mmorrow> i don't like all the dwords everywhere
21:10:21 <ksf> you see the class of the code, though, as the reflect code is more involved that what's used.
21:10:25 <mmorrow> s/dword/whatever/
21:10:30 <SamB_XP> Draconx: that's a good thing for actual programming, though
21:10:30 <mmorrow> movq,movl
21:11:00 <Draconx> SamB_XP, probably.
21:11:24 <SamB_XP> it means your typos don't all become linker errors ;-)
21:11:25 <ksf> ...and, tbh, I couldn't be arsed to talk to the X server in assembly.
21:12:22 <mmorrow> SamB_XP: if you're making a bunch of typos in asm, linker errors will probably be the least of your worries
21:12:36 <SamB_XP> mmorrow: I mean in long symbol names
21:12:43 <Draconx> SamB_XP, actually, this wouldn't have been a problem, except that it is an error to declare an internally-defined symbol as extern.
21:12:48 <ksf> ...so there's a custom standard library with a quick fprintf (thanks to nasm macros et all), as required by exercise rules, but the clib gets linked in as a result of linking in libX.
21:12:49 <SamB_XP> those are the kind of thing you're most likely to typo in
21:12:55 <SamB_XP> Draconx: oh.
21:12:57 <cjay> weird, the package fclabels seems to duplicate functionality of data-accessor and data-accessor-template
21:12:58 <Draconx> SamB_XP, so I couldn't just extern all symbols used in the translation unit.
21:13:05 <SamB_XP> Draconx: I see.
21:13:13 <SamB_XP> that does sound a bit annoying
21:14:55 <ksf> ...at the same time, there were people who did not want to dig into linux and figure out how to code in assembly, there, so they wrote for real-mode DOS.
21:15:02 <ksf> I did _not_ envy them.
21:15:23 <ksf> especially because of MASM and TASM, which are equally abysmal.
21:15:31 <mmorrow> oh noes i accidently the teh os
21:15:36 <SamB_XP> what, they weren't allowed to use NASM there?
21:15:38 <SamB_XP> that sucks!
21:15:39 * copumpkin is running out of pretty operators :(
21:15:47 <mmorrow> copumpkin: unicode!
21:15:52 <copumpkin> mmorrow: soon!
21:15:53 <ksf> ...I guess they didn't figured they could.
21:15:53 <copumpkin> :P
21:17:23 <SamB_XP> of course, so does 16-bit x86 ASM -- it's got WAAY more restrictive addressing modes than I'd known
21:17:32 <SamB_XP> I learned this in ASM class in the spring
21:18:19 <ksf> ...you know, the lecture was taught by a 45-year old guy who still used windows 3.11, loved netware, and had a model railway in his basement.
21:18:51 <Axman6> what a maddog
21:19:15 <forgot> is there a way to use groupBy to group adjacent elements: groupBy n [1,2,3,5,6] = [[1,2,3],[5,6]]?
21:19:31 <SamB_XP> ksf: what's wrong with having a model railway in your basement?
21:20:02 <ksf> nothing... by itself.
21:20:11 <dmwit> forgot: Not really, no.
21:20:16 <Draconx> forgot, yes, but it will be horrible.
21:20:31 <forgot> ok then how do i group adjacent elements?
21:20:32 <dmwit> forgot: In general, you're not "supposed" to groupBy any function that isn't really an equivalence relation.
21:20:42 <ksf> in fact, I wish I had enough room for my lego, but I _don't_ use linux 2.2
21:20:46 <dmwit> forgot: However, consider this:
21:20:49 * araujo wonders if anyone speaks chinese here
21:20:59 <dmwit> > zipWith (-) [1,2,3,5,6] [1..]
21:21:00 <lambdabot>   [0,0,0,1,1]
21:21:06 <SamB_XP> ksf: he used linux 2.2 ... recently?
21:21:32 <ksf> I've got no Idea. but I would have to, If I did aspire to be like him.
21:21:50 <copumpkin> anyone wanna see what I've been working on? http://gist.github.com/177854 !!!
21:21:58 <ksf> ...and, of course, ghc 2.0
21:22:01 <forgot> oh then i can then use group on that right?
21:22:26 <copumpkin> sadly, ^**^ came to mean matrix multiplication
21:22:46 <SamB_XP> oh, my assembly teacher had an old pre-internet Linux laptop running who-knows what version, and dual-booting with DOS
21:22:49 <ksf> otoh, with all those debian users, there should be a lot of 2.2 installs around.
21:23:12 <mmorrow> , let goo [] = []; goo (x:xs) = (\(acc,_,_) -> reverse acc) (foldl (\(acc,x,xs) y -> if x+1==y then (acc,y,x:xs) else (reverse(x:xs):acc,y,[])) ([],x,[]) xs) in goo [1,2,3,5,6]
21:23:14 <lunabot>  [[1,2,3]]
21:23:15 <SamB_XP> ksf: I don't think most of us are silly enough to run stable on personal machines ;-)
21:23:16 <mmorrow> grr
21:23:28 <copumpkin> mmorrow: check out my fancy sized vectors and matrices!
21:23:31 * copumpkin grins
21:23:55 <dmwit> copumpkin: > -- comments????
21:24:26 <copumpkin> dmwit: I started with the example Vec.lhs in she, and never bothered unlitting it, but I should do that eventually :P
21:24:36 <copumpkin> dmwit: but I agree, kinda dumb :P
21:24:53 <dmwit> I'm just saying, it ought to be just "comments" rather than "> -- comments".
21:24:59 <copumpkin> yeah :)
21:25:07 <mmorrow> copumpkin: oh nice
21:25:07 <copumpkin> I'm saying, kinda dumb of me :P
21:25:11 <dmwit> heh
21:25:22 <mmorrow> copumpkin: what does "{S}" mean?
21:25:38 <copumpkin> mmorrow: see the data Nat where Z; S thing?
21:25:47 <dmwit> I guess brackets raise values to the type level.
21:25:50 <copumpkin> it derives SheSingleton, which means she will give me a type-level version of that
21:25:55 <copumpkin> yep
21:26:24 <mmorrow> oh, you mean without the "Z" ? (i'm confused)
21:26:44 <copumpkin> oh, without the Z, I was hoping for the type-level equivalent of fix S
21:26:49 <copumpkin> but it didn't work
21:26:52 <mmorrow> what's the significance of "Singleton" in that
21:26:52 <mmorrow> ?
21:26:54 <mmorrow> ah
21:26:58 <mmorrow> ok
21:27:04 <copumpkin> not sure :) you'll have to ask the pigworker
21:27:09 <mmorrow> :o
21:27:22 <copumpkin> ( http://twitter.com/pigworker )
21:27:35 <mmorrow> copumpkin: btw, i always laugh when someone does ":o" for some reason
21:27:41 <copumpkin> :o
21:27:46 <mmorrow> hehe
21:27:51 <copumpkin> laff laff
21:28:04 <mmorrow> falaffel
21:28:10 <copumpkin> :o
21:28:21 * copumpkin accidentally the IQ of this entire channel :o
21:28:34 <dmwit> The whole IQ??
21:28:41 <copumpkin> yes :(
21:29:14 <dmwit> http://arcanux.org/lambdacats.html !!1!
21:29:35 <SamB_XP> hooray! he boosted our IQ by somehow figuring out how to feed a Magic Tab to the entire channel!
21:30:07 <SamB_XP> ... entirely by accident!
21:30:13 <copumpkin> lol
21:30:26 * copumpkin ponders bringing in his heavy algebra guns to this code now
21:30:49 <SamB_XP> copumpkin: what rules does that have that light algebra lacks?
21:31:13 <copumpkin> light algebra = two algebraic classes in vector-space
21:31:16 <mmorrow> @bot
21:31:16 <lunabot>  :o
21:31:16 <lambdabot> :)
21:31:21 <copumpkin> heavy algebra = the whole shebang that I wrote that time
21:31:54 <Gracenotes> I approve of lunabot's current emotion
21:32:05 <SamB_XP> @bot
21:32:05 <lunabot>  :o
21:32:05 <lambdabot> :)
21:32:05 <copumpkin> oh my, it changed!
21:32:10 <SamB_XP> it did ?
21:32:12 <mmorrow> :o
21:32:14 <copumpkin> :o
21:32:15 <SamB_XP> how does it change?
21:32:20 <dmwit> :O
21:32:24 <SamB_XP> :D
21:32:27 <copumpkin> damn, dmwit has us beat
21:32:29 * SamB_XP tries to change it
21:32:51 <mmorrow> SamB_XP: must have quit/joins hidden
21:33:01 <mmorrow> s/://
21:33:02 <copumpkin> SamB_XP: I think lunabot's temporary absence might have been mmorrow carving a new expression into the poor bot's face
21:33:08 <SamB_XP> mmorrow: no
21:33:10 * copumpkin knows all about carved expressions :(
21:33:27 <SamB_XP> I'm going to need to see a PNG of that face, mister!
21:33:57 <SamB_XP> you know, at first when I read "carving a new expression" I was thinking of the kind of expression that produces a value ;-)
21:33:58 <Gracenotes> mmorrow leverages emoticon-displaying technology to create a synergy between lunabot and the encompassing zeitgeist of the channel
21:34:08 <mmorrow> since the evaluator is a different binary though, that can be changed/modified without stopping the bot
21:34:11 <mmorrow> which is nice
21:34:48 <dmwit> lambdabot: now scriptable in bash!
21:34:58 <SamB_XP> dmwit: huh?
21:35:01 <mmorrow> Gracenotes: you may want to become a professional book back-cover-blurb writer
21:35:08 * copumpkin tries to decide what else to do with this big chunk of useless code
21:35:22 <copumpkin> I guess I should add some basic matrix operations beyond multiplication and addition
21:36:09 <SamB_XP> copumpkin: such as?
21:36:10 <copumpkin> any ideas of something interesting to do?
21:36:21 <copumpkin> well, I don't have an identity of size n yet
21:36:25 <SamB_XP> well, determinant comes to mind as a thing
21:36:28 <copumpkin> inversion sounds painful but I might write it it
21:36:30 <copumpkin> the trace
21:36:32 <SamB_XP> I don't know if that's interesting ...
21:36:33 <copumpkin> yeah, determinant
21:37:06 <mmorrow> copumpkin: implement Integer multiplication via FFT
21:37:06 <copumpkin> trying to think of something that would benefit from this representation other than user code
21:37:20 <Gracenotes> u has cross product
21:37:22 <copumpkin> mmorrow: doing a dft through a matrix?
21:37:37 <copumpkin> Gracenotes: I guess I could add that, using the vector-space class for it, but it's rather specific
21:37:42 <copumpkin> to particular-sized vectors
21:38:10 <Gracenotes> this is true. are you doing a int-dependent-types-type thing?
21:38:12 <copumpkin> or I could try to figure out how to get rid of that damn a ~ Scalar a constraint I have
21:38:17 <copumpkin> Gracenotes: yeah
21:38:23 <mmorrow> copumpkin: only do the dft for the base cases, then collapse the tree upwards by merging subcomps
21:38:32 <copumpkin> mmorrow: hrm
21:38:53 <copumpkin> @pl Mat . transpose $ map (\col -> map (\row -> row <.> col) (unMat x)) (transpose . unMat $ y)
21:38:53 <lambdabot> Mat (transpose (map (flip map (unMat x) . flip (<.>)) (transpose (unMat y))))
21:39:02 <copumpkin> @pl x ^**^ y = Mat . transpose $ map (\col -> map (\row -> row <.> col) (unMat x)) (transpose . unMat $ y)
21:39:02 <lambdabot> (line 1, column 10):
21:39:02 <lambdabot> unexpected "="
21:39:02 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
21:39:06 <copumpkin> lol
21:39:15 <copumpkin> @pl x * y = Mat . transpose $ map (\col -> map (\row -> row <.> col) (unMat x)) (transpose . unMat $ y)
21:39:15 <lambdabot> (line 1, column 7):
21:39:15 <lambdabot> unexpected "="
21:39:15 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or end of input
21:39:19 <copumpkin> oi :(
21:39:29 <Gracenotes> io
21:40:17 <copumpkin> does it make sense for matrix multiplication to require that inner product space?
21:40:24 <copumpkin> I can't see how to do without it
21:40:30 <copumpkin> but I don't remember anyone mentioning that constraint
21:42:18 <mmorrow> matrices are just reps of linear maps that and handey to use to compute things
21:42:31 <copumpkin> yeah
21:42:35 <copumpkin> I know :)
21:42:40 <mmorrow> so just a vector space
21:42:45 <copumpkin> yeah, that's what I thought
21:43:01 <copumpkin> but how do you define matrix multiplication (as composition of linear maps) without the dot product?
21:43:21 <mmorrow> since matrix mult is composition of linear maps
21:43:22 * copumpkin should read his old linear algebra book
21:43:29 <mmorrow> right
21:43:33 <copumpkin> :P
21:43:37 <mmorrow> oh
21:43:39 <mmorrow> erm
21:44:06 <copumpkin> I've always thought of matrix multiplication (in practical terms) as taking the inner product of the rows and columns in the way that makes sense
21:45:37 <mmorrow> well, the dot product doesn't necessarily have to be [a,b,c] . [e,f,g] = a*e+b*f+c*g
21:45:45 <mmorrow> (?)
21:45:58 <mmorrow> it's just the inner product
21:46:11 <copumpkin> yeah?
21:46:14 <mmorrow> the vectors may not even "be" tuples of something
21:46:21 <copumpkin> yeah, I know
21:46:23 <mmorrow> they could be functions, or ...
21:46:39 <copumpkin> anyway, I got rid of the constraint :P
21:47:17 <copumpkin> I still have that damn a ~ Scalar a though
21:47:18 <mmorrow> hmm
21:47:52 <copumpkin> maybe I should incorporate psykotik's matrix zipper stuff
21:47:59 <copumpkin> see if I can make it super-duper typesafe
21:48:00 <mmorrow> ahh, wikipedia++
21:48:29 <mmorrow> "The general form of an inner product on C^n is" (i'm sure you can replace C by "a field k"):
21:48:43 <mmorrow> <x,y> = y*Mx
21:48:57 <mmorrow> where M is any symmetric positive-definite matrix
21:49:48 <mmorrow> copumpkin: err, but the whole matrix thing assumes that vectors *are* tuples of elems of some field i guess
21:49:58 <copumpkin> yeah
21:50:14 <mmorrow> copumpkin: so maybe the fact that you can use the matrix rep at all means that that vector space *does* have an inner-product
21:50:22 <copumpkin> hmm
21:51:26 <copumpkin> I guess that makes sense, it'd be odd to to have a vector space of functions and then treat the linear maps as matrices (how would the matrices look? :P)
21:51:28 <Gracenotes> turn around bright eyes
21:51:31 * ksf would like to have two different export lists in a module, without hacking around the scheme by introducing more modules.
21:51:35 <mmorrow> copumpkin: right
21:51:58 <ksf> ...more than one module in a file would be fine, though.
21:52:56 <mmorrow> copumpkin: so i guess, "matrices are representations of linear maps of vector spaces of the form k^n, for some field k"
21:53:05 <copumpkin> that makes sense
21:53:26 <mmorrow> and a vector space of that form i think has an inner-product
21:53:34 <mmorrow> well, it definitely does
21:53:46 <mmorrow> dot
21:54:14 <mmorrow> but not the converse
21:54:47 <mmorrow> a vector space having an inner product doesn't imply that it's k^n
21:54:51 <mmorrow> (clearly)
21:54:55 <copumpkin> yeah :)
21:56:13 * copumpkin hates having to write showsPrec
21:56:24 <mmorrow> copumpkin: for a GADT?
21:56:33 <copumpkin> yeah
21:56:45 <copumpkin> does your gadt deriver have magic for that?
21:57:23 <SamB_XP> it's fixed in the HEAD, I think
21:57:27 <SamB_XP> for standalone derivings anyway
21:57:34 <copumpkin> hm?
21:57:48 <mmorrow> copumpkin: derive-gadt ftw http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8838#a8838
21:58:26 <copumpkin> ooh thanks :)
21:58:38 <SamB_XP> deriving instance Show (YourGadt a) should work in GHC head, I think ...
21:58:38 <mmorrow> ugh, hmm that shows a way that the ones other than Show could be improved
22:01:02 <mmorrow> copumpkin: that "derive-gadt" prog takes a module on stdin, and'll derive what you tell it for every GADT decl in said module
22:01:11 <copumpkin> oh wait, this might not like my SHE
22:01:20 <sshc> how do I see if a String can be read into a number?
22:01:25 <copumpkin> sshc: reads
22:01:50 <mmorrow> copumpkin: a lot of times i make a scratch file and paste particular gadts into that just to cat them into derive-gadt
22:02:10 <mmorrow> copumpkin: the she syntax isn't in the actual GADT decls themselves, right?
22:02:19 <copumpkin> >   (:>) :: x -> Vec n x -> Vec {S n} x
22:02:20 <lambdabot>   <no location info>: parse error on input `{'
22:02:22 <copumpkin> is one of the constructors
22:02:29 <copumpkin> data Vec :: {Nat} -> * -> * where
22:02:31 <mmorrow> oh crap
22:02:41 <mmorrow> maybe preproc it first?
22:02:55 <copumpkin> then I rely on the back-end-behavior of SHE which may be variable
22:02:59 <mmorrow> ohhh, ok. i just realized what she does now.
22:03:36 <copumpkin> :o
22:03:43 <SamB_XP> what does she do?
22:03:51 <mmorrow> copumpkin: well worst case you can paste the gadt into a scratch module, touch it up, and then just use derive-gadt to get the tedious shell written, then touch it up
22:03:51 <copumpkin> she bangs, she bangs
22:03:52 <SamB_XP> ... and what are her rates?
22:03:55 <copumpkin> oh baby, she moves, she moves
22:04:39 <copumpkin> I might actually make a non-standard (i.e., not Read-able) Show output
22:04:47 <copumpkin> cause I'm getting really annoyed at seeing the :> and Nil constructors all the time
22:04:53 <mmorrow> copumpkin: oh nice, you have that "induction" function in there
22:04:59 <copumpkin> mmorrow: yeah, but it don't work :(
22:05:20 <copumpkin> mmorrow: gonna figure that out later and then prove me some schtuff
22:05:33 <mmorrow> copumpkin: i think you may need the type family too
22:05:40 <copumpkin> which type family?
22:05:59 <mmorrow> (or at least i did for "nest", which dolio generalized in agda to induction)
22:06:04 <mmorrow> copumpkin: i'll paste
22:06:23 <copumpkin> I had a functioning induction function in my last attempt at this, but I'm not used to she
22:06:35 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166#a2166
22:06:54 <copumpkin> ah
22:07:26 <copumpkin> doesn't sseem like I should need that
22:07:29 <copumpkin> I called that Replicate I think
22:07:30 <mmorrow> dolio used "induction" to replace my type family
22:07:50 <mmorrow> (and to replace nest's implem)
22:07:55 <copumpkin> hrm
22:08:18 <Makoryu> Huh, apparently the J community has its own Oleg...... Literally. There's a prominent J programmer named Oleg.
22:08:28 <Makoryu> Surely not the same guy though
22:08:48 <copumpkin> mmorrow: I'm not sure that's necessary... in ryan ingram's framework I had induction with no type family
22:09:02 * ksf begins to understand that the key to learning haskell is to take enjoying getting one's mind blown seriously.
22:09:04 <mmorrow> copumpkin: did you need a class?
22:09:12 <Makoryu> ksf: Pretty much!
22:09:13 <copumpkin> mmorrow: yeah, but it had no associated types
22:09:27 <copumpkin> mmorrow: it was using type equality though :o
22:09:31 <mmorrow> , nesty $(nat 18) (:[]) 42
22:09:33 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
22:09:42 <mmorrow> could you e.g. that?
22:10:01 * copumpkin looks
22:10:07 <copumpkin> I think so
22:10:10 <mmorrow> the type family i guess is essential only to be able to have the return type not mention any GADTs/whatnot
22:10:11 <Axman6> , $(nat 10)
22:10:13 <lunabot>  N (N (N (N (N (N (N (N (N (N Z)))))))))
22:10:16 <mmorrow> copumpkin: oh interesting
22:10:24 <Axman6> , type nesty
22:10:25 <lunabot>  luna: parse error on input `type'
22:10:37 <Axman6> , [$ty|nesty|]
22:10:39 <lunabot>  forall a b c . N c -> (forall d . d -> b d) -> a -> Nest c b a
22:10:48 <ksf> don't we have type level integrals, by now?
22:10:57 <ksf> (weren't people shouting for it for ages?)
22:10:58 <copumpkin> mmorrow: I'd need to wrap it in a newtype first
22:11:03 <copumpkin> (I think
22:11:05 <mmorrow> Axman6: it's just this, but had to rename in lunabot http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166
22:11:12 <mmorrow> , 'nest
22:11:13 <lunabot>  Text.PrettyPrint.HughesPJ.nest
22:11:26 <ksf> but I guess they blew that chance by implementing two's-complement type level naturals...
22:11:31 <mmorrow> , nesty $(nat 18) Just 42
22:11:33 <lunabot>  Just (Just (Just (Just (Just (Just (Just (Just (Just (Just (Just (Just (J...
22:11:57 <mmorrow> , $(fmaps 18) (*2) (nesty $(nat 18) (:[]) 42)
22:11:59 <lunabot>  luna: Context reduction stack overflow; size = 20
22:12:05 <copumpkin> aw
22:12:07 <mmorrow> , $(fmaps 8) (*2) (nesty $(nat 8) (:[]) 42)
22:12:09 <lunabot>  luna: No instance for (GHC.Num.Num [t])
22:12:23 <mmorrow> i can't figure out how to up the context stack via the ghc-api DynamicFlags
22:12:27 <mmorrow> , $(fmaps 9) (*2) (nesty $(nat 8) (:[]) 42)
22:12:30 <lunabot>  [[[[[[[[[84]]]]]]]]]
22:13:20 <mmorrow> , ppDoc <$> fmaps 9
22:13:23 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap)))))))
22:13:30 <mmorrow> TH++
22:13:31 <copumpkin> mmorrow: anyway, I think induction is still possible
22:13:33 <copumpkin> :P
22:13:44 <mmorrow> copumpkin: i'm interested to see it
22:13:54 <mmorrow> that'd be cool
22:14:11 <copumpkin> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8839#a8839
22:14:18 <copumpkin> that's what I had before
22:14:49 <mmorrow> copumpkin: ah, ok. so the class there is having the same function as the type family
22:14:57 <copumpkin> really?
22:15:04 <mmorrow> yeah
22:15:47 <copumpkin> so what would the type family look like?
22:15:59 <mmorrow> mine was
22:16:03 <mmorrow> type family Nest n (f :: * -> *) a
22:16:03 <mmorrow> type instance Nest () f a    = f a
22:16:03 <mmorrow> type instance Nest (N n) f a = f (Nest n f a)
22:16:10 <copumpkin> ah that one
22:16:18 <mmorrow> which exactly mirrors the function
22:16:25 <copumpkin> yeah
22:16:34 <mmorrow> which was my favorite part :)
22:16:46 <mmorrow> but annoying that that had to be duplicated in haskell
22:17:06 <Axman6> , toInt (nest 3)
22:17:07 <lunabot>  luna: Couldn't match expected type `Luna.Nest.N a'
22:17:13 <Axman6> , toInt $(nest 3)
22:17:14 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
22:17:15 <mmorrow> , toInt $(nat 1000)
22:17:18 <lunabot>  1000
22:17:22 <copumpkin> mmorrow: the funny thing is that I have almost that exact type family in the other code too, for another reason :P
22:17:23 <Axman6> uh, yeah
22:17:52 <copumpkin> I guess it isn't quite identical
22:18:11 <mmorrow> copumpkin: yeah, i think that pattern is essentially what's at the root of what `induction' (the function) is
22:18:42 <mmorrow> and it applies at both the type and value levels
22:18:59 <copumpkin> hmm
22:19:06 <copumpkin> I don't see how the code I pasted got around that though
22:19:23 <copumpkin> I mean, I see how it works, but I don't see why in the absence of caseNat a type family is needed
22:19:27 <mmorrow> the neat thing about the agda code is how the same code can be used for the type and the value computation
22:19:33 <copumpkin> yeah :)
22:20:07 <sclv> isn't casenat just a cps transform over the type family?
22:20:15 <mmorrow> copumpkin: there's some other stuff going on in yours too that kinda makes it hard to pin down the exact mapping between implems
22:20:37 <mmorrow> like in your, the class is also used in the GADT *and* in the function
22:21:04 <mmorrow> so there's some sort of interaction there in addition to whatever the classes add in and of themselves
22:21:27 <mmorrow> i can't quite pin it down at first glance
22:21:41 <mmorrow> oh wait
22:21:46 <mmorrow> you have no GADTs
22:21:51 * mmorrow cleans his glasses off
22:22:00 <copumpkin> :P
22:22:28 <mmorrow> right, so in yours the classes are doing what the GADT+tyfamily combo is doing in mine
22:23:03 <ksf> I guess automatically deriving value-level functions from type level functions would be an idea.
22:23:43 <sclv> that's sort of what she does, right?
22:23:53 <ksf> she == agda?
22:24:33 <ksf> I guess so, the compiler just notices that the function is needed at run-time and thus outputs it.
22:24:51 <sclv> she = http://personal.cis.strath.ac.uk/~conor/pub/she/
22:26:03 * copumpkin gets the best of both worlds and adds the Nat typeclass back
22:26:24 <ksf> "strathclyde" is a wonderful name to train british pronounciation.
22:27:04 <mmorrow> sclv: ah yeah, it's the fold
22:27:44 <copumpkin> there we go
22:27:51 <copumpkin> now I haz induction the way I'm used to it :)
22:28:32 <SamB_XP> I can has induction with melted cheeze on top?
22:28:48 <sclv> three strategies for any problem: 1) cps transform it. 2) pass the dictionary explicitly. 3) firstify it.
22:28:51 <copumpkin> u can only haz inducheezburger
22:28:51 <mmorrow> copumpkin: so  (instance selection ==== GADT matching-determines-the-type) and (explicit ~ ==== type family)
22:28:59 <mmorrow> copumpkin: is the iso i believe
22:29:06 <copumpkin> mmorrow: yeah, makes sense
22:29:11 <copumpkin> since ~ comes from -XTypeFamilies anyway
22:29:12 <copumpkin> brb
22:30:14 <SamB_XP> copumpkin: you seem to have hit lambdabot on yuor way in?
22:31:30 <copumpkin> ?
22:31:50 <mmorrow> @bot
22:31:50 <lunabot>  :o
22:31:59 <Woof> lament D :
22:32:02 <Woof> Oops
22:32:06 <Woof> lambdabot*
22:33:09 <SamB_XP> [01:28:58] <-- copumpkin has quit (Read error: 104 (Connection reset by peer))
22:33:10 <SamB_XP> [01:29:26] <-- lambdabot has quit (Read error: 60 (Operation timed out))
22:33:10 <SamB_XP> [01:29:36] --> copumpkin (n=pumpkin@129.170.241.32) has joined #haskell
22:33:20 <copumpkin> :o
22:33:25 <copumpkin> whoops :)
22:33:32 <SamB_XP> huh. why is that last one bold ???
22:34:13 <gwern> too few people are downloading gitit
22:34:20 <gwern> why aren't you all using gitit???
22:34:30 <mmorrow> gwern: i'm still running
22:34:32 <gwern> everyone can use a personal wiki!
22:34:32 <Gracenotes> don't let the door hit you on the way out, lambdabot!
22:34:33 * mmorrow checks version
22:34:44 <mmorrow> gitit version 0.4.1
22:34:46 <Gracenotes> pssh. bots nowadays.
22:34:49 <gwern> -_-
22:34:52 <gwern> mmorrow: update already
22:34:56 <mmorrow> gwern: heh
22:35:01 <gwern> the longer you wait the more painful
22:35:19 <mmorrow> gwern: i use it locally a bunch
22:35:28 <mmorrow> gwern: what version is it at now?
22:35:37 <SamB_XP> gwern: what sort of function are we talking about?
22:35:44 <gwern> we're at .6 something, and we've made a ton of changes since .4
22:35:53 <SamB_XP> is it superlinear, because otherwise there's not that great a motivation ;-)
22:37:16 <gwern> SamB_XP: I'd say it's superlinear because if you wait long enough, changes that could've been incrementally merged by git/darcs at constant cost will require manual intervention
22:39:23 * mmorrow thinks someone should write a pkg called divine-intervention
22:39:36 <copumpkin> :o
22:39:50 <mmorrow> no idea what it'd do, but whatever it does it'd have to be good
22:40:07 <gwern> obviously it'd smite your harddrive
22:40:15 <gwern> a good rm -rf / would do the trick
22:40:16 * mmorrow votes for it to do "forever (system "xeyes &"))"
22:40:32 <mmorrow> "i can seeeeeee you!"
22:40:37 <copumpkin> lol
22:40:57 <SamB_XP> mmorrow: maybe hijack GDI's Ion Cannon?
22:41:32 <mmorrow> SamB_XP: and end it all with a nice "fix (\o -> mapM_ forkIO [o,o])" for good measure
22:41:52 <SamB_XP> or for NOD fans, unsafeLaunchMissle
22:42:04 <copumpkin> @pl fix (\o -> mapM_ forkIO [o,o])
22:42:08 <mmorrow> i think haskell has the prettiest forkbomb of them all
22:42:33 <SamB_XP> I still think the shell forkbomb is kinda cute
22:42:34 <mmorrow> , [$pl|fix (\o -> mapM_ forkIO [o,o])|]
22:42:35 <copumpkin> @bot
22:42:35 <lunabot>  :o
22:42:40 <lunabot>  Killed.
22:42:42 <mmorrow> , [$pl|fix (\o -> mapM_ forkIO [o,o])|]
22:42:43 <copumpkin> aw
22:42:48 <lunabot>  Killed.
22:42:49 <mmorrow> SamB: yeah that one's good too
22:43:01 <copumpkin> no pl for you!
22:43:12 <mmorrow> , [$pl|fix (\o -> mapM_ forkIO (o:o:[]))|]
22:43:18 <lunabot>  Killed.
22:43:20 <mmorrow> , [$pl|\o -> mapM_ forkIO (o:o:[])|]
22:43:21 <mmorrow> wtf
22:43:26 <lunabot>  Killed.
22:43:27 <copumpkin> poor lunabot
22:43:30 * copumpkin strokes lunabot
22:43:31 <copumpkin> there, there
22:44:27 * copumpkin will write induction and prove some stuff tomorrow!
22:45:54 <copumpkin> I guess I could write a Num instance for strictly square matrices
22:46:01 <copumpkin> with meaningful functions
22:46:16 <mmorrow> , [$pl|\o -> [o]|]
22:46:18 <lunabot>  return
22:46:18 <copumpkin> except for fromIntegral :P
22:46:29 <mmorrow> , [$pl|\o -> [o,o]|]
22:46:31 <lunabot>  ap (:) return
22:46:41 <Axman6> :t ap (:)
22:46:52 <Axman6> :O
22:46:58 <mmorrow> , [$plQ|\o -> [o,o]|]
22:46:59 <lunabot>  luna: Not in scope: `plQ'
22:47:16 <Axman6> , [$ty|ap (:)|]
22:47:20 <lunabot>  forall a . (a -> [] a) -> a -> [] a
22:47:30 <mmorrow> , [$ty| [$pl|\o -> [o,o]\|] |]
22:47:33 <lunabot>  Doc
22:47:35 <mmorrow> grr
22:47:59 <Gracenotes> :t ap const
22:48:07 <Saizan> copumpkin: having 1 to be the identity matrix would be cool
22:48:11 <Gracenotes> oh. I forgot.
22:48:28 <mmorrow> , [$plQ|\o -> [o,o,o]|]
22:48:29 <lunabot>  luna: Not in scope: `plQ'
22:48:31 <copumpkin> Saizan: I was thinking of that, and then fromIntegral be a multiple of the identity matrix
22:48:32 <mmorrow> , [$pl|\o -> [o,o,o]|]
22:48:38 <lunabot>  Killed.
22:48:52 <copumpkin> Saizan: still seems kinda dirty to require all the values to be square, but I can live with that I guess
22:49:12 * copumpkin wonders how to write identity :: Mat m n a elegantly
22:49:35 <copumpkin> I should really write a Field typeclass so I can get at one and zero abstractly
22:49:38 <dmwit> identity :: n -> Vec n a -- seems like a first step
22:49:41 <dmwit> err
22:49:51 <dmwit> identity :: Nat -> Vec n a
22:50:07 <copumpkin> dmwit: that would fill in the nth value with a 1 and everything else with a 0?
22:50:11 <dmwit> yeah
22:50:28 <dmwit> Didn't you have some kind of HasBasis class?
22:50:28 <copumpkin> hmm, I already use that function as a method elsewhere, so I might as well just make it available
22:50:30 <copumpkin> yeah
22:50:31 <dmwit> How does that work?
22:50:38 <copumpkin> yup, almost exactly that :)
22:50:41 <dmwit> =)
22:50:49 <sshc> if a function returns "Either String Int", how do I get the Right side of it (to add with something else)?
22:51:03 <copumpkin> sshc: fmap (+1)
22:51:04 <SamB_XP> sshc: well, it might not have one!
22:51:08 <dmwit> sshc: You aren't guaranteed to *have* a right side!
22:51:16 <dmwit> on the other hand:
22:51:18 <sshc> oh
22:51:21 <sshc> how do I know?
22:51:24 <dmwit> > liftM2 (+) (Right 3) (Right 72)
22:51:30 <copumpkin> aw
22:51:35 <copumpkin> , liftM2 (+) (Right 3) (Right 72)
22:51:37 <lunabot>  Right 75
22:51:46 <copumpkin> , liftM2 (+) (Left 3) (Right 72)
22:51:49 <lunabot>  Left 3
22:51:50 <dmwit> Oh, is \bot dead?
22:51:53 <copumpkin> yeah :(
22:52:01 <copumpkin> I knocked it out when I left earlier, by mistake
22:52:06 <dmwit> , liftM2 (+) (Left "error, does not compute") (Right 72)
22:52:08 <lunabot>  Left "error, does not compute"
22:52:30 <dmwit> sshc: Most primitively, you "know" by doing pattern matching.
22:52:32 <copumpkin> that instance kinda bothers me :)
22:52:49 <dmwit> sshc: However, we have several nice facilities for mucking about with Eithers, including a Functor and a Monad instance.
22:53:02 <dmwit> And the "either" catamorphism.
22:53:09 <dmwit> Whooo, what other math terms can we dig up?
22:53:14 <copumpkin> bifunctor!
22:53:23 <dmwit> category-extras++
22:53:27 <SamB_XP> clown!
22:53:28 <SamB_XP> joker!
22:53:34 <copumpkin> costrength!
22:53:41 <dibblego> disjunction
22:53:58 <SamB_XP> zipper!
22:54:13 <Axman6> coaddition!
22:54:14 <Axman6> >_>
22:54:19 <copumpkin> :o
22:54:26 <copumpkin> copumpkin!
22:54:28 <SamB_XP> Axman6: is that multiplication or subtraction?
22:54:33 <Axman6> yes!
22:54:38 <copumpkin> SamB: tetration! ;)
22:54:39 <SamB_XP> lol
22:54:44 <copumpkin> just cause I can
22:55:02 * dmwit would like to see the category where coaddition was tetration
22:55:06 <copumpkin> lol
22:55:35 * copumpkin edges towards the door
22:55:41 <Lanjiao> > 3+3
22:55:47 <copumpkin> , 3 + 3
22:55:51 <lunabot>  6
22:56:38 <copumpkin> When the night get old, good lambda bots go to sleep. As the moon comes out, with it comes the luna bot!
22:56:50 <Gracenotes> thank you, firefox, for being so smart as to use HTTP 206 on my download. you are wonderful. for now. </an ode\>
22:57:17 <SamB_XP> ?
22:57:23 <dmwit> meow mix, meow mix, we want meow mix </cat ode\>
22:57:51 <sshc> copumpkin: what happened to lambdabot?
22:58:12 <Gracenotes> dmwit: are you positive about that? </cathode\>
22:58:15 <copumpkin> sshc: beats me
22:58:34 <SamB_XP> sshc: see above
22:58:44 <copumpkin> oh yeah
22:58:51 <copumpkin> the library is closing, must go home now!
22:59:01 <SamB_XP> bye!
22:59:27 <dmwit> I think the script for this movie was written while high on marijuana. =/
22:59:33 <sshc> ,(Just 3,"")
22:59:34 <lunabot>  (Just 3,"")
22:59:48 <sshc> why are there two bots?
23:00:10 <Axman6> why not?
23:00:14 <Axman6> they do different things
23:00:18 <gwern> two heads are better than one
23:00:29 <SamB_XP> that, and lambdabot is always falling over
23:01:16 <sshc> Cromulent: embiggens
23:01:37 <Lanjiao> > Just 3
23:01:51 <sshc> ,(Just 3)
23:01:52 <lunabot>  Just 3
23:02:05 <dmwit> "Give me five bees for a quarter," you'd say.  But anyway, there I was, with an onion on my belt -- which was the fashion at the time -- ...
23:02:14 <Lanjiao> > Just 3 >>= Just 4
23:02:30 <sshc> ,(Just 3 >>= Just 4)
23:02:31 <lunabot>  luna: Couldn't match expected type `t -> Data.Maybe.Maybe b'
23:02:32 <dmwit> , Just 3 >>= \n -> Just (n + 4)
23:02:33 <lunabot>  Just 7
23:02:42 <dmwit> , Just 3 >> Just 4
23:02:43 <lunabot>  Just 4
23:03:15 <Lanjiao> > Just 4 >>= Nothing >= Just 3
23:03:30 <dmwit> Lanjiao: ...you have to use ", " instead of "> ".
23:03:35 <dmwit> Surely this pattern is obvious by now.
23:03:35 <Gracenotes> lambyy
23:03:36 <dmwit> =P
23:03:56 <Lanjiao> dmwit, thanks
23:07:13 <SamB_XP> > XYZZY
23:08:31 <dmwit> Who will help me choose a name for a field?
23:08:38 <dmwit> The field is :: Bool;
23:08:56 <dmwit> if it's True, the record is definitely illegal; if it's False, there's no guarantees either way.
23:09:12 <gwern> sounds like typechecking!
23:09:13 <dmwit> definitelyIllegal?
23:09:49 <SamB_XP> absolutelyBogus?
23:10:27 <SamB_XP> bogusForSure?
23:10:48 <dmwit> "bogus" isn't right; a record can be sensible but illegal
23:11:01 <dmwit> But "illegalForSure" might work.
23:11:02 <SamB_XP> oh
23:11:29 <SamB_XP> why can it be sensible but illegal?
23:11:37 <dmwit> (It's weird.  To be honest, I'm not sure why this exists.)
23:11:43 <dmwit> http://www.red-bean.com/sgf/properties.html#KO
23:13:25 <sjanssen> dmwit: data Possibly = Definitely | NotSure; illegal :: Possibly
23:13:35 <dmwit> ah
23:13:37 <dmwit> I like that better.
23:14:18 <sjanssen> or perhaps a newtype, if you'd like to make use of existing Bool operators
23:14:52 <SubStack> HStringTemplate could use some continuations for page inclusion I think
23:14:58 <dmwit> I have several other pseudo-Bool's, so I'll follow the style of the other ones.
23:18:34 <SubStack> hmmm supergroups might do this
23:20:07 * ksf thinks haddock should provide http access to tar.gz contents
23:20:35 <ksf> so that you can point to http://haddock/package/latest/tgz/examples
23:21:57 <ksf> -2,.s/haddock/hackage
23:21:59 <SamB_XP> ksf: you mean hackage?
23:22:02 <SamB_XP> yeah, you do ;-)
23:22:07 <Lanjiao> , 3+4
23:22:09 <lunabot>  7
23:22:41 <Lanjiao> ,3+4
23:22:42 <lunabot>  7
23:22:43 <ksf> it's a rare occasion to use proper ed ranges.
23:22:53 <Lanjiao> ,Just 4 >>= Just 3
23:22:54 <lunabot>  luna: Couldn't match expected type `t -> Data.Maybe.Maybe b'
23:23:01 <ksf> nowadays, it's all shift+v or 1,$
23:23:07 <Lanjiao> ,Just 4 >> Just 3
23:23:08 <lunabot>  Just 3
23:23:18 <Lanjiao> ,Just 4 >> Nothing >> Just 3
23:23:19 <lunabot>  Nothing
23:27:00 <Lanjiao> ,3
23:27:02 <lunabot>  3
23:27:16 <Lanjiao> ,3+4
23:27:17 <lunabot>  7
23:27:49 <ksf> it's going to stay that way, haskell doesn't know side-effects.
23:28:38 <Lanjiao> , 3+4
23:28:40 <lunabot>  7
23:30:20 <dmwit> Lanjiao: What are you doing?
23:30:41 * elbar is missing lambdabot allready ;)
23:31:08 <elbar> @yarr
23:32:37 <Lanjiao> dmwin, just for test, sorry. My network wasn't good and i didn't see the response. so test several times
23:33:34 <glguy> How can I get cabal-install to use the ghc in a non-standard location?
23:34:02 * copumpkin is back!!!1!!111
23:36:01 * glguy found it
23:36:05 <dmwit> Lanjiao: Ah.  For that kind of thing, you might like to try /msg instead, it's more private. =)
23:36:25 <dmwit>  /msg lunabot , "for example, like this, but without a space in front, of course"
23:39:21 <Lanjiao> dmwit, thanks, i'll try
23:44:52 <glguy> To build on Snow Leopard with the ghc binary "-opta -m32 -optl -m32 " works, but what do I add to ~/.cabal/config ?
23:45:02 <glguy> my first guess was to add as-option: and ld-option: lines
23:46:36 <dmwit> I see no such options in my cabal config.
23:47:03 <dmwit> Perhaps flags: ?
23:49:19 <glguy> I think that that is for the cabal flags
23:49:24 <glguy> the user-defined ones
23:49:30 <dmwit> mmm
23:49:49 <dmwit> Perhaps you can hack the compiler: line.
23:49:57 <dmwit> compiler: ghc -opta -m32 -optl -m32
23:49:59 <dmwit> =P
23:50:19 <glguy> no, afaict, the compiler: line is pattern matched against things like "ghc"
23:50:24 <glguy> and "nhc98"
23:51:42 <glguy> with-compiler: takes a path
23:51:53 <glguy> I guess I could make a script that add my flags to the ones passed in
23:51:56 <glguy> and calls the real ghc
23:52:01 <glguy> but that seems really unfortunate
23:52:44 <dmwit> indeed
23:56:08 <glguy> well, it worked
