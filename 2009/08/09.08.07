00:09:38 * ManateeLazyCat interesting dyre, Maybe use it integrate with my project......
00:11:05 <artagnon> Darn, I can't seem to figure out what's wrong with this code: http://pastebin.com/d36a942d3
00:11:27 <artagnon> GHCI says "Occurs check: cannot construct the infinite type: a = [a]". What does that mean?
00:12:45 <ManateeLazyCat> artagnon: That men when "a = [a]", function will failed.
00:13:28 <artagnon> ManateeLazyCat: I see. Why though?
00:13:58 * ManateeLazyCat See source code.
00:14:03 <artagnon> fibSequence needs to be called with a list. I see no other way
00:14:59 <c_wraith> > fix $ (0:) . scanl 1 (+)
00:15:00 <lambdabot>   No instance for (GHC.Num.Num
00:15:00 <lambdabot>                     ((a -> a -> a) -> (a -> a ...
00:15:19 <c_wraith> > fix $ (0:) . scanl (+) 1
00:15:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:15:23 <artagnon> Corrected a couple of silly mistakes: http://pastebin.com/d3ec07c0e
00:15:37 <BMeph> artagnon: [1, 2] ;)
00:15:43 <artagnon> !
00:16:04 <artagnon> BMeph: Thanks. That took care of one error.
00:16:16 <artagnon> I still get cannot construct the infinite type: a = [a] though
00:16:31 <ManateeLazyCat> artagnon: Replace l : [last l + secondLast l] to l ++ [last l + secondLast l]
00:16:33 <quicksilver> artagnon: the problem is your use of :
00:16:36 <c_wraith> generally that means that you're attempting to use something as a list and as an element of that list somewhere
00:16:50 <ManateeLazyCat> artagnon: Because first argument of (:) can't be [a]
00:16:51 <c_wraith> often using : when you mean ++, for instance
00:16:55 <quicksilver> artagnon: (:) conses a single element into a list. the thingn the left of the : should be a single element.
00:17:14 * ManateeLazyCat pasted "right code" at http://paste2.org/get/364769
00:17:15 <artagnon> ManateeLazyCat, quicksilver: Ah I see. Thank you! :)
00:17:24 <ManateeLazyCat> artagnon: http://paste2.org/get/364769
00:17:38 <artagnon> Compiles perfectly now
00:18:26 <ManateeLazyCat> artagnon: When you want concat list, try to use ++ instead :
00:18:41 <ManateeLazyCat> artagnon: : will failed when first argument is type [a]
00:19:19 <artagnon> ManateeLazyCat: Right, Got it.
00:19:29 <artagnon> now my logic is flawed. Stack Overflow :p
00:19:40 <BMeph> ManateeLazyCat: BZZZT! Actually, : will fail when second argument is not [[a]]. ;)
00:20:01 <Lemmih> artagnon: Rethink your approach.
00:20:37 <Lemmih> artagnon: Generate a lazy sequence. Avoid use of 'length' and '++'.
00:21:35 * BMeph goes to bed
00:23:11 <artagnon> Lemmih: Ok, will try and get back after some time when I have some better code.
00:23:13 <artagnon> Thanks :)
00:23:16 * artagnon waves
00:36:05 <wgsilkie> Why do I keep getting this in Hugs? <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3206#a3206>
00:36:42 <Pistahh> wgsilkie: put "let " in the beginning
00:37:15 <Lemmih> wgsilkie: You can't define functions in the REPL.
00:37:34 <wgsilkie> That gives "ERROR - Syntax error in expression (unexpected end of input)".
00:37:41 <wgsilkie> Lemmih: Come again?
00:37:53 <Lemmih> wgsilkie: What Pistahh said only works in GHCi.
00:38:01 <wgsilkie> Oh.
00:38:02 <Lemmih> wgsilkie: Write you functions in a file and load it.
00:38:07 <Lemmih> *your
00:38:11 <quicksilver> or use ghci.
00:38:14 <wgsilkie> So what *can* I do in Hugs?
00:38:25 <Lemmih> wgsilkie: Evaluate expressions.
00:38:26 <quicksilver> evaluate expressions.
00:38:32 <wgsilkie> Oh...
00:38:45 <wgsilkie> OK, how do I use guards in GHCi?
00:38:48 <wgsilkie> Or can I?
00:39:16 <quicksilver> > let f x | x > 0 = 1 | x < 0 = 2 in f (-8)
00:39:18 <lambdabot>   2
00:39:22 <Lemmih> Sure. Just keep everything on one line.
00:39:31 <quicksilver> guards don't have to be written on multiple lines, that just looks prettier
00:39:47 <quicksilver> or you can use :{ and :} to enter multiline expressions.
00:40:23 <quicksilver> the reason haskell repls don't do definitions is that haskell source is (mostly) not ordered. You can have forward references, backward references, and mutual recursion anywhere.
00:40:31 <quicksilver> it's not a very good reason, to be honest.
00:40:43 <quicksilver> but the poitn is that typing in a .hs file line-by-line is not likely to work in general.
00:40:55 <artagnon> wait... can someone give me a hint on how to improve this code? http://pastebin.com/d3ec07c0e
00:40:56 <wgsilkie> Ah, thanks, quicksilver!
00:40:58 <quicksilver> IIRC hbc *did* support definitions and even data definitions in its REPL.
00:41:05 <artagnon> er, sorry
00:41:09 <artagnon> that has an error
00:42:00 <artagnon> http://pastebin.com/d60b82d39 << The code looks ugly
00:43:24 <artagnon> In other words, I want to define an abstract infinite list containing the fibonnaci series and then sum upto the first n numbers in the sequence. I've employed an ugly C-like looping + summing mechanism
00:43:51 <quicksilver> well we can simply tell you the answer
00:43:56 <quicksilver> but I"m not sure that's what you want :)
00:44:02 <artagnon> no, it isn't :)
00:44:05 <artagnon> I want a hint
00:44:23 <quicksilver> definitions can be recursive, even of values.
00:44:50 <quicksilver> consider something of the form: fibs = 1 : 1 : <some expression which refers to fibs>
00:44:52 <artagnon> fibList l = l+1:l for example?
00:45:07 <quicksilver> you're trying to define a list, not a function.
00:45:15 <artagnon> oh
00:45:16 <artagnon> ok
00:45:28 <quicksilver> > let ones = 1 : ones in ones
00:45:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:45:47 <quicksilver> > let s = 1 : (map (+1) s) in s
00:45:48 <artagnon> huh?
00:45:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:45:56 <artagnon> ok
00:45:57 <quicksilver> definitions of values can be recursive.
00:46:04 <quicksilver> I'm just giving a couple of simpler examples
00:46:07 <quicksilver> simpler than fibs.
00:46:08 <artagnon> I think I get it
00:46:12 * artagnon nods
00:46:19 <artagnon> Thanks for the hint! :)
00:46:36 * artagnon notes down the examples and goes off to try
00:46:46 <Axman6> last l > 400000 ...
00:46:52 <mmorrow> , (
00:46:53 <lunabot>  luna: parse error (possibly incorrect indentation)
00:46:55 * Axman6 tries to avoid last whereever possible
00:47:14 <mmorrow> , fix (\ones -> 1 : ones)
00:47:15 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:47:29 <mmorrow> , let ones = 1 : ones in ones
00:47:30 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:47:32 <artagnon> Axman6: Hm. How do I avoid last?
00:47:34 <mmorrow> @src fix
00:47:34 <lambdabot> fix f = let x = f x in x
00:47:51 <blackdog> artagnon: compute the list in the other order:)
00:48:00 <blackdog> </helpful>
00:48:03 <artagnon> ah
00:48:51 <artagnon> anyway, I have to be off now
00:48:52 <artagnon> Thanks again
00:49:00 <Axman6> fibsequence l = ... fibsequence l ++ ... that... well doesn't do anything
00:52:10 <wgsilkie> > (fib (n-1)) + (fib (n-2))
00:52:11 <lambdabot>   Not in scope: `fib'Not in scope: `fib'
00:52:20 <wgsilkie> @help
00:52:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:52:56 <wgsilkie> Um, how do I use lambdabot to test my syntax?
00:53:35 <Axman6> well... using actual functions is a good start :)
00:53:46 <wgsilkie> Right now, I want to figure out how to write that with as few parentheses as possible.
00:53:52 <c_wraith> > let fib n = 3 in  (fib (n-1)) + (fib (n-2))
00:53:53 <lambdabot>   6
00:53:56 <c_wraith> hehe. :)
00:54:14 <Axman6> fib (n-1) + fib (n-2)
00:54:44 <c_wraith> Function application by juxtaposition is always higher-precedence than binary operators
00:54:48 <wgsilkie> > let fib n = 3 in  fib (n-1) + fib (n-2)
00:54:50 <lambdabot>   6
00:55:12 <c_wraith> That's the only rule you really need to know to figure out minimum parens for that expression
00:55:50 <wgsilkie> c_wraith: Juxtaposition meaning what in this context?
00:56:00 <c_wraith> f a b
00:56:20 <c_wraith> So in your expression, fib n
00:56:31 <Axman6> wgsilkie: function application binds higher than infix functions
00:56:53 <quicksilver> @pl (fib (n-1)) + (fib (n-2))
00:56:54 <lambdabot> fib (n - 1) + fib (n - 2)
00:57:01 <Axman6> so (f x) * (g y) == f x * g y
00:57:01 <wgsilkie> So, f a b + g c d is the same as (f a b) + (g c d)?
00:57:07 <quicksilver> wgsilkie: it's not really what @pl is for, but it does remove unnecessary parens
00:57:15 <Axman6> wgsilkie: yep
00:57:31 <Axman6> quicksilver: it doesn't stand for parenless?
00:57:33 <wgsilkie> But f a+b is (f a) + b?
00:57:44 <c_wraith> correct again
00:57:52 <wgsilkie> OK, I've got it noe.
00:57:55 <wgsilkie> *now
00:57:58 <wgsilkie> Thanks!
00:58:30 <Axman6> that's something that often trips people up: using f n+1, the see it as f (n+1) but it's really f n (+) 1
00:58:45 <mercury^> It's annoying with exponentiating.
00:58:56 <Axman6> or (f n) + 1 i think
00:59:13 <c_wraith> the latter, definitely.
00:59:24 <Axman6> yeah
00:59:48 <c_wraith> also (+ 1) . f $ n
00:59:56 <c_wraith> But now I'm just being silly. :)
01:01:01 <mercury^> Would be nice if you could use something of type -> a whenever type a is required.
01:01:36 <olsner> "-> a"? that's not a proper type
01:01:40 <mercury^> Like: let f n = n+1; g = f+1;
01:01:51 <mercury^> olsner: b -> a for all b.
01:02:03 <Axman6> (1+) .f
01:02:22 <mercury^> Axman6: yes, that's what it would convert to.
01:02:24 <Axman6> ((1+) . f)*
01:02:57 <c_wraith> I saw this earlier, and it amused me:
01:03:24 <c_wraith> @pl \x -> f1 (f2 x) (f3 x)
01:03:24 <lambdabot> liftM2 f1 f2 f3
01:03:37 <olsner> mercury^: perhaps you could do that by writing a Num instance for (Num a => b -> a)
01:03:39 <Saizan_> you can make an instance for Num b => Num (a -> b)
01:04:08 <Saizan_> we already have a similar one for Monoid
01:04:33 <mercury^> But it should work in more general cases too.
01:05:00 * Axman6 notes that 1+f doesn't really make mathematical sense
01:05:08 <c_wraith> @src (->) >>=
01:05:08 <lambdabot> Source not found. Do you think like you type?
01:05:15 <c_wraith> @src (->) (>>=)
01:05:16 <lambdabot> f >>= k = \ r -> k (f r) r
01:05:33 * Axman6 still doesn't get the (->) monad
01:05:48 <olsner> think Reader
01:06:00 * Axman6 still doesn't get the Reader monad
01:06:02 <Axman6> >_>
01:06:06 <olsner> hehe :)
01:06:16 <quicksilver> Axman6: it makes perfect mathematical sense
01:06:21 <quicksilver> Axman6: if you define it appropriately.
01:06:45 <Saizan_> i.e  1 = const 1
01:07:11 <quicksilver> it's not that uncommon to see 1 = const 1 assumed in functional analysis
01:07:15 <Axman6> well, to me, 1 + f x makes sense, but if f is a function, then it doesn't make sense to add numbers to it
01:07:21 <quicksilver> and its very common to define (+) and (*) pointwise.
01:07:32 <quicksilver> Axman6: your sense of sense is too narrow, then :) broaden your mind.
01:07:46 <Axman6> no, i'm sleepy!
01:07:49 <quicksilver> it's pretty common notation in areas of mathematics which are about studying functions R -> R
01:07:55 <c_wraith> best time to broaden it.
01:08:01 <olsner> fromIntegral = const . fromIntegral or something
01:08:03 <c_wraith> You'll understand it until you fall asleep.
01:08:23 <c_wraith> Or at least, once you wake up, you won't be able to prove you didn't understand it before you fell asleep.
01:09:19 <ziman> > let { f = (+1); g = f <^ (+) ^> 3 } in g 5
01:09:20 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
01:09:47 <c_wraith> lambdabot doesn't have the bat operator? that makes me sad
01:15:29 <mercury^> I guess a slightly more general version would be to automatically fmap anything when it doesn't make sense otherwise.
01:15:44 <mercury^> So that you can do 1+[1..] also.
01:16:33 <Axman6> yuck
01:17:36 <Ferdirand> wouldn't that break partial application ?
01:18:09 * Axman6 thinks it would break haskell
01:18:18 <mercury^> I'm almost certain it breaks *something* if you aren't very careful.
01:18:25 <mercury^> Ferdirand: got the example at hand?
01:20:19 <mercury^> Could automatically use applicative functors in cases such as [1..]+[2..]*[3..] also.
01:22:04 <ziman> but [a] is not Applicative :)
01:22:44 <quicksilver> yes it is.
01:22:56 <quicksilver> but not with the definition mercury^ wanted for that example.
01:23:05 <mercury^> There are ziplists.
01:23:14 <quicksilver> > liftA2 (+) [1..] [2..]
01:23:15 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
01:29:08 <Ferdirand> mercury^: well, if i'm not mistaken
01:29:33 <Ferdirand> implicit fmap would allow any t to be turned into a (r -> t) from the (->) monad, yes ?
01:31:37 <Ferdirand> oh, i guess maybe it only loses usefulness for (->), maybe not the others
01:32:18 <mercury^> I don't see how it loses usefulness in (->) yet.
01:32:46 <Ferdirand> f :: r -> r, x :: r. what is the type of (f x) ?
01:33:08 <mercury^> r
01:34:10 <Ferdirand> f :: t -> t, x :: r
01:34:26 <Ferdirand> then (f x) :: t -> t
01:36:03 <mercury^> Maybe I'm not familiar enough with (->), but I cannot follow that example.
01:37:46 <ManateeLazyCat> @let f x g h = do a <- f x; if a then g else h
01:37:47 <lambdabot>  <local>:4:18:
01:37:47 <lambdabot>      Ambiguous occurrence `f'
01:37:47 <lambdabot>      It could refer to either `L...
01:38:05 <Ferdirand> ah wait, it's not correct, forget it.
01:38:07 <ManateeLazyCat> @let ifM f x g h = do a <- f x; if a then g else h
01:38:08 <lambdabot>  Defined.
01:38:14 <ManateeLazyCat> :t ifM
01:38:16 <lambdabot> forall t (m :: * -> *) b. (Monad m) => (t -> m Bool) -> t -> m b -> m b -> m b
01:39:09 <ManateeLazyCat> > ifM (IO True) (putStrLn "True") (putStrLn "False")
01:39:10 <lambdabot>   Not in scope: data constructor `IO'
01:39:33 <ManateeLazyCat> > ifM (\t -> return True) (putStrLn "True") (putStrLn "False")
01:39:34 <lambdabot>   Overlapping instances for GHC.Show.Show
01:39:35 <lambdabot>                              (GHC.I...
01:39:38 <Ferdirand> i was thinking of pure, not fmap
01:40:46 <ManateeLazyCat> > ifM (\t -> return True) "True" "False"
01:40:48 <lambdabot>   Overlapping instances for GHC.Show.Show
01:40:48 <lambdabot>                              ([GHC....
01:41:40 <mercury^> Could be a nice topic for a bachelor thesis to set out trying to make things like 1+[2,3..] and (+1)+1 work and see how it is best done, if possible.
01:43:14 <Ferdirand> will it play well with type inference ?
01:45:22 <mercury^> Ferdirand: I think it would be done after a first pass of inference. That pass will say "something's not right", and then that mechanism would try to fix it.
01:46:27 <Ferdirand> but it might be hard to locate where the problem is
01:47:20 <Ferdirand> or maybe it's similar to having overlapping instances
01:53:47 <blackdog> has there been much work done on making it easy to call haskell from other languages?
01:54:07 <blackdog> c2hs seems to be mostly concerned with going the other way
01:56:46 <dmwit> blackdog: Not much.  The FFI specifies both directions, but that's about it.
01:57:42 <blackdog> righto. guess i can cope with putting in the translation layer for the moment
01:59:10 <quicksilver> mercury^: any change which makes more expressions typecheck runs the risk of making the language more hostile to newbies.
01:59:21 <quicksilver> mercury^: ideally you want a mistake to be a compile error
01:59:26 <quicksilver> not be accepted and do something odd.
02:01:01 <mercury^> Hmm, but in this case it does something fairly intuitive I think.
02:01:46 <mercury^> It will be far more often the case that a newbie means what it would mean under this interpretation than not.
02:02:36 * Axman6 would argue that 1+[1..] could be either [2..] or 1:[1..]
02:02:48 <Axman6> i mean, if you're adding something to a list...
02:04:11 <quicksilver> mercury^: as part of a recursion it might easily be simply not what you mean
02:04:29 <quicksilver> g a b c = .... g (a+l) b c
02:04:39 <quicksilver> I didn't mean to add the list l, I should have taken the head of it, etc.
02:04:43 <int-e> Axman6: hmm, it could be 2:[2..] -- using lists as power series and their obvious? num instance.
02:05:25 * Axman6 fails to see how it's be 2:[2..] but accepts this as more proof for his argument
02:05:55 <int-e> Axman6: the 1 would actually be [1] and addition would add corresponding elements of two lists.
02:06:29 <Axman6> ah yes
02:42:23 <blackdog> hey, #haskell. i need some help - what would you call a ruby-haskell bridge? just one way, lets ruby call haskell inline.
02:43:11 <soupdragon> RASKELL
02:43:28 <soupdragon> HUSKY
02:43:41 <Twey> blackdog: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
02:43:42 <blackdog> some claimjumping bastard got it already:)
02:43:56 <Twey> And use Ruby's C FFI
02:44:02 <soupdragon> claimjumping bastard ??a
02:44:03 <blackdog> Twey: Yeah, that's what i've done
02:44:23 <blackdog> soupdragon: i'm only joking - someone's got a google code site up with that name but with no code
02:44:32 <soupdragon> oh?
02:44:52 <blackdog> Twey: i've written it, and i'm trying to make it more convenient to use - i just need a good name
02:45:22 <Twey> Hubris :-P
02:45:27 <blackdog> ... oooh, that's good
02:45:48 <Twey> Thankyou.
02:46:11 <Twey> (also a dig at Ruby, presuming to call upon the might of Haskell :-P)
02:46:21 <akiel> how do I add source files from a non leksah project to a new package created by leksah? The reason is that I don't see my modules in leksah.
02:47:03 <blackdog> Twey: play nice with the scripters, 'k?
02:47:42 <Twey> Heh
02:49:11 <kynky> i like ruby and haskell, but thought they diametrically apart
02:50:49 <blackdog> kynky: yeah, that's why they go together like peanut butter and chocolate
02:51:17 <kynky> :)
02:51:20 <blackdog> people are already dropping down to C to write extensions - why not write in something that's almost as fast and much less painful?
02:52:06 <quicksilver> blackdog: like haskell, for example?
02:52:31 <kynky> oh you mean ruby drop down to haskell, was gonn say haskel dropping down to ruby? :)
02:53:25 <Twey> Almost... as... fast?
02:53:31 <Twey> Oh, I see.
02:53:40 <Twey> Heh.  Yes.
02:53:49 <quicksilver> there can't be many cases where ruby would outperform ghc.
02:53:54 <kynky> why not all haskell i say, haskell great for prototyping
02:53:56 <Twey> Or any.
02:55:11 <kyf>  http://www.lostworlds.lv/go.php?1139723800 NEW WEBSITE GAME,COME AND PLAY.
02:55:14 <kynky> ruby is really slow even with rubinus/jruby/yarv etc, haskell is comparable to C in speed, if you wnt faster then ocaml i though
02:55:53 <elbar> so ocaml is faster than c?
02:56:21 <quicksilver> there re occasionas when ocaml and haskell beat C, yes.
02:56:34 <quicksilver> all depends how much effort you're prepared to put into writing clever code.
02:56:44 <kynky> haskell for instance cant be beaten on thread creation in any language
02:56:59 <kynky> ghc does help with optimisations
02:57:04 <mercury^> You can implement faster threads with the same properties in C.
02:57:13 <xenoblitz> hi people, thanks for adding my little blog to the haskell reddit :) This is me today :D
02:57:32 <benmachine> mercury^: but it's much more of a headache :P
02:57:55 <quicksilver> mercury^: sure but comments of that form are not terribly meaningful.
02:58:03 <quicksilver> you can implement all of GHC in C
02:58:03 <mercury^> Ofc, in this case someone already did it for you.
02:58:12 <quicksilver> and, indeed, vice versa.
02:58:18 <kynky> quicksilver, sorry
02:58:37 <Axman6> quicksilver: well, not quite vice versa
02:58:51 <mercury^> quicksilver: if the goal is to just compile a program (not a compiler that compiles another program), there could very well be differences.
02:58:55 <mercury^> So it's not all the same.
02:59:35 <mercury^> It could well be that GHC does better on some low level optimisations than GCC. It just isn't so.
03:00:41 <Axman6> huh?
03:01:05 <mercury^> But you are right in that questions about highest possible performance are less meaningless than questions about average performance using reasonable coding effort.
03:01:05 <quicksilver> mercury^: well there are some cases. You may not call them "low-level"
03:01:50 <quicksilver> mercury^: GHC generaqtes better code than GCC for certain IO loops.
03:02:01 <quicksilver> arguably that's because of the different IO primitives presented.
03:02:24 <mercury^> quicksilver: Well, I believe that for every haskell program you write, I could write (with potentially very large effort) a C program with the same functionality, that, when compiled with GCC, has higher performance than your haskell program compiled with GHC.
03:02:34 <mercury^> But as I said, that's not a very useful measure of performance.
03:03:28 <blackdog_> mercury^: you'd have to assume you both have the same amount of time to make it a fair contest
03:03:45 <benmachine> well, it depends what you are competing in
03:03:46 <Axman6> mercury^: want to go beat the thread ring benchmark entry from the shootout?
03:04:03 <mercury^> Axman6: shouldn't be hard, as the benchmark has ridiculous rules.
03:04:06 <Axman6> mercury^: if you can get it even 3 times slower than the haskell entry by using C, i'll be very impressed
03:04:08 <mercury^> I've already complained about that once.
03:04:12 <benmachine> if your aim is to find the most efficient language, then that's a complex issue
03:04:30 <mercury^> Axman6: the other languages do worse because their threads have other properties.
03:04:35 <Cale> "Most efficient language"?
03:04:44 <Axman6> mercury^: so?
03:04:45 <benmachine> Cale: well exactly :)
03:04:45 <soupdragon> C
03:04:49 <Cale> Languages aren't efficient or inefficient, only implementations are.
03:04:53 <Axman6> their threads should have better properties ;)
03:04:59 <mercury^> Axman6: the benchmark doesn't say what threads are.
03:05:13 <quicksilver> Cale: some kinds of efficiency are language issues.
03:05:14 <mercury^> I could win the contest by writing a C program that does something fairly trivial that one could view as solution.
03:05:27 <Axman6> concurrent threads of execution. it's a fairly well defined term
03:05:28 <quicksilver> expressivitity and so on.
03:06:08 <Cale> quicksilver: Well, inexpressive languages can make the compiler's job arbitrarily hard, sure.
03:06:25 <blackdog_> mercury^: an interesting counterexample might be something like FFTW, which takes a description of the problem and uses metaprogramming to optimise the code for that particular problem. that would be very difficult to do in C.
03:06:26 <mercury^> Axman6: so you agree that the benchmark can be won by a 20 line C program that uses no includes. What's your point about the haskell superiority then?
03:06:39 <Axman6> wtf?
03:06:51 <Axman6> where did i say anything at all close to what you just said?
03:07:17 <Axman6> so no, i do not agree
03:07:20 <chrisbrown> Cale: but you could argue all languages are as equally as expressive, as they are all turing complete
03:07:24 <Cale> It would be really hard for a C compiler to discover that some routine is really carrying out matrix multiplication and do a bunch of inlining and discover that it's multiplying my an identity matrix at some point. A language for which matrices are a primary concern would have less trouble with that.
03:07:34 <blackdog_> chrisbrown: aw, man, don't do that.
03:07:37 <Cale> by*
03:08:08 <chrisbrown> blackdog_: don't do what? it's a valid point :)
03:08:17 <mercury^> blackdog_: yes. You can do better than any compiler if you do something smart of course. :)
03:08:37 <blackdog_> chrisbrown: it's such a boring point, though. it has nothing to do with practical selection of language.
03:08:45 <Cale> chrisbrown: You could, if you had some way to take a program in any Turing complete language and turn it into a program in some other Turing complete language while *preserving efficiency*
03:08:58 <blackdog_> mercury^: but some mediums of expression will let you be smarter more easily :)
03:08:59 <Cale> But that's not possible.
03:09:20 <Cale> (or at least, I don't know how to do it)
03:09:52 <Axman6> and if Cale doesn't know how, no one does ;)
03:10:08 <Cale> haha
03:11:06 <Cale> and of course, it's not just languages, but language implementations at that point
03:12:08 <Axman6> mercury^: so what;s your problem with the thread ring benchmark?
03:12:22 <Cale> There might be some problems for which one compiler gives better code for some program implementing something than any possible program which solves the same problem as compiled by some other compiler.
03:12:43 <Cale> So at that point, it really does become impossible.
03:12:55 <mercury^> The problem is that the stupid contest should specify inputs and outputs and not vaguely prescribe any internals that should happen at program execution.
03:13:11 <chrisbrown> Cale: efficiency and expressivity are two different things. I'm not sure one depends on the other
03:14:19 <chrisbrown> and I'm not sure how you could say one language is "more expressive" than another, if both languages give you a viable solution
03:14:23 <Axman6> so you want the thread testing benchmark to be  main(..){ int n = atoi(argv[1]); printf("%i",n % 503);}?
03:14:43 <Cale> chrisbrown: Whether or not you can solve a problem has little to do with how expressive the language is.
03:15:01 <chrisbrown> Cale: so how exactly do *you* define expressiveness?
03:15:44 <Cale> chrisbrown: Well, it has to do with the amount of effort you have to spend to get a practical solution to a problem, on average.
03:15:48 <Axman6> j programming
03:15:50 <Axman6> whoops
03:16:04 <Cale> chrisbrown: It's not easy to measure.
03:16:05 <Axman6> hmm, smaller chan than i was expecting
03:16:11 <chrisbrown> Cale: it's impossible to meaure
03:16:17 <mercury^> There shouldn't be a threads benchmark to begin with.
03:16:23 <Axman6> why the hell not?
03:16:24 <chrisbrown> and it would depend on each person
03:16:27 <Axman6> that's retarded
03:16:32 <Cale> chrisbrown: But it's easy to discuss qualitatively.
03:16:45 <chrisbrown> that is also massively subjective
03:16:48 <Axman6> if anything, there should be more. they're becomming more and more important every day
03:17:02 <Cale> chrisbrown: As most things are :)
03:17:02 <kynky> a good indication though ?
03:17:16 <mercury^> Axman6: and that benchmark is oh so meaningful. :)
03:17:25 <chrisbrown> I just think it's very easy to say "oh, this language is really expressive"
03:17:31 <chrisbrown> but it doesn't actually mean very much
03:17:35 <Cale> chrisbrown: But there are problems for which it's easy to see that one language/implementation is winning versus another in terms of expressivity.
03:18:02 <Axman6> well it shows how much overhead you can expect to get from a language using threads. that's not a non-trivial piece of imformation
03:18:11 <Axman6> it also shows how easily threads can communicate
03:18:29 <chrisbrown> Cale: nah, I don't buy that
03:18:44 <Cale> chrisbrown: If I only have to write one line of nice readable code to solve some problem in a reasonably efficient way, whereas to get similar efficiency, you have to write 30 lines...
03:18:54 <mercury^> That benchmark gives you virtually no information at all. I don't know how to make this more obvious to you, so this discussion ends here for me.
03:19:14 <chrisbrown> certainly not using the term "expressive", possibly "cleaner syntax" perhaps
03:19:46 <Axman6> mercury^: i just can't see that you have any point at all. is it just that C is not a good language for this benchmark, so it's a crappy benchmark?
03:19:56 <Cale> Expressiveness is all about providing useful abstractions which let you get the program you're after without being impractical to use.
03:20:32 <mercury^> Axman6: C is the perfect language for the benchmark.
03:20:42 <Axman6> ok, well write a good antry for it
03:20:49 <Axman6> entry*
03:20:57 <Axman6> (wtf did that a come from?)
03:20:57 <chrisbrown> Cale: right, but my 30 line abstraction might be so much easier to understand than your 1 line abstraction in my eyes. Therefore mine is more expressive
03:21:47 <Axman6> and prove that you can have low overhead communication between threads in C, that switching between threads isn't slow
03:22:03 <Cale> chrisbrown: If we took the same amount of time to write it, or I took less time (as is quite likely, as it was only one line of code), then it's easy to say that you just don't know the language I'm using.
03:23:01 <therp> chrisbrown: no, I disagree with that. with that line of reasoning you could argue that you just need to teach someone the basic primitives of assembler, that would be assignments, conditionals, jumps and a few math operations and that's sufficient for him to understand a unification algorithm.
03:23:46 <Beelsebob> therp: no you couldn't
03:23:59 <Beelsebob> chrisbrown's point is not that longer code is more understandable
03:24:10 <Beelsebob> it's that shorder code is also not necessarily more understandable
03:24:25 <Gwern-away> so I have 'main = do vs@(inf:pronunc:meaning:_je:_tu:_il:_nous:_vous:_ils:[]) ←  getArgs', but what's the best way to catch a pattern-match failure here? putting in catch or onException from Control.Exception leads to type errors (since a [a] is expected)
03:24:53 <chrisbrown> Beelsebob: exactly!!
03:25:03 <Beelsebob> gwern: there's a couple of libraries on hackage for parsing arguments in a sensible way
03:25:34 <Gwern-away> Beelsebob: I can get away with dead-simple parsing like this, I just want to dump a help message upon any error
03:25:49 <Beelsebob> then just use a case expression
03:26:00 <therp> Beelsebob: well true, but how useful is that statement? yes, neither is longer code necessarily more understandable, nor shorter. but that's a quite weak finding
03:26:10 <Beelsebob> case vs of exact_right_patern -> do shit; _ -> print help message
03:26:16 <Gwern-away> ah
03:26:37 <HugoDaniel> hi
03:27:26 <therp> Beelsebob: the good thing about concise short code is, that you don't have to go into detail if you understand the abstractions.
03:27:37 * Beelsebob nods
03:27:53 <therp> Beelsebob: that's not an option with long code. you always have to read the whole thing to abstract the pattern from it, even when you have done that thousand times
03:27:54 <Beelsebob> the good thing about long code is that it's often easier to space the code out and seperate concepts
03:28:12 <Beelsebob> that's not true at all therp
03:28:18 <Beelsebob> long code is not the same as unabstracted code
03:28:55 <therp> Beelsebob: to me it is. abstractions should always make things shorter (at least in my ideal world, why would I otherwise abstract than?)
03:29:08 <Gwern-away> Beelsebob: yeah, case epxression works
03:29:17 <altmattr> therp: to make them more abstract
03:29:19 <Beelsebob> because independant of code length, it makes a concept easier to understand therp
03:29:38 <altmattr> therp: to reuse them
03:29:49 <altmattr> in fact, that is the only reason to abstract if you ask me, for re-use
03:29:54 <Beelsebob> indeed
03:29:58 <Beelsebob> which *usually* makes code shorder
03:30:01 <Beelsebob> shorter*
03:30:01 <therp> Beelsebob: only if you reuse them. otherwise, you make the reader learn an abstraction that he only learned once.
03:30:03 <Beelsebob> but not always
03:30:23 <therp> Beelsebob: s/only learned/only used/
03:30:28 <altmattr> therp: but now we are talking about different things
03:30:35 <kynky> abstraction is helpful in some design patterns
03:30:45 <altmattr> the last time I abstracted somethign for re-use it got *longer* and *more complicated*
03:30:55 <altmattr> and I am pretty sure I was doing it right
03:31:07 <altmattr> so shorter != more abstract
03:31:17 <therp> altmattr: so you are doing eager abstraction :)
03:31:42 <QtPlaty[HireMe]> altmattr: Abstraction reduces total length not local length
03:31:56 <altmattr> nope - but I am not the person who benefits from my abrstraaction
03:32:00 <Beelsebob> therp: either that or his condition for forcing an abstraction is different to yours
03:32:04 <altmattr> the bloke down the hall using my code dies
03:32:05 <altmattr> does
03:32:11 <Beelsebob> i.e. it doesn't depend only on code length
03:32:22 <altmattr> my code does not get shorter, but hte amount of code in the universe does
03:32:25 <Axman6> altmattr: oh shit, better call an ambulance :O
03:32:42 <quicksilver> "the bloke down the hall using my code dies" <- OK kids, let that be a lesson about using unsafePeformIO.
03:32:48 <altmattr> Axman6: :)
03:33:09 <altmattr> freudian I'm sure
03:33:28 <Axman6> you hate that guy don't you
03:33:41 <Axman6> and one day, he'll end up in a dumpster
03:34:00 <altmattr> if he's lucky
03:34:31 <therp> to change the topic a bit. is there some standard backtrace facility in sight for GHC based compilations in next decade?
03:34:53 <therp> I'm tired of grepping library source code for the panics I get
03:35:15 <Beelsebob> therp: backtraces are near impossible in an efficient graph reduction machine
03:35:20 <tkr> is there  any nice installation package for WinXP to get haskell+opengl+glut ?
03:35:30 <Beelsebob> having said that, iirc, ghci can do it if you have the debuggerer on
03:35:31 <chrisbrown> there may be an argument to introduce an abstraction that is longer: think of eliminating clone instances; repacing them with a function call may result in code that easier to understand, albeit longer
03:35:33 <Axman6> tkr: tried the haskell platform?
03:35:36 <tkr> I did it on my work linux box, but would like to also have my hobby at home. :)
03:35:41 <chrisbrown> I don't think lenght of code == understandabiltiy
03:35:47 <tkr> Axman6: nope. Im clueless with Windows. what is that?
03:36:03 <quicksilver> tkr: the haskell platform has opengl I think.
03:36:04 <Axman6> http://hackage.haskell.org/platform
03:36:07 <Beelsebob> tkr: install linux on your home box?
03:36:09 <Beelsebob> >.>
03:36:13 <Axman6> Beelsebob: no!
03:36:22 <tkr> Beelsebob: I should. but I should also teach my GF how to use it then. :)
03:36:37 <tkr> quicksilver, Axman6: thanks. Ill check out the platform you are talking about.
03:36:38 <Beelsebob> tkr: a word of warning: my experience of the Haskell platform on windows is that glut doesn't work right
03:36:46 <QtPlaty[HireMe]> chrisbrown: Yeah,  code can be hard to understand due to being overly verbose and overly dence.  Only the middle way gives understandable code.
03:36:46 <therp> Beelsebob: why would I need efficient execution of execution fails? premature optimization on a conceptional level :/.
03:36:47 <Beelsebob> you need to be very careful to find the right glut library
03:36:47 <Axman6> tkr: there's a windows installer
03:37:16 <Beelsebob> therp: how does it know your code is going to fail before it runs it?  That would involve solving the halting problem
03:37:17 <therp> Beelsebob: also I would be totally happy with a limited backtracing facility down to the depth of 10 maybe.
03:37:23 <tkr> Axman6: you are just telling me to be annoying or going to give out some useful information also? ;)
03:37:24 <quicksilver> therp: the answer is yes. The backtraces will be done using the cost centre code.
03:37:25 <Beelsebob> therp: the basic problem is that there is no stack
03:37:32 <Beelsebob> so you can't give a backtrace of the non-stack
03:37:34 <altmattr> therp: the difference between efficient graph reduction and naive graph reduction is not turning on a few optimisations
03:37:37 <Axman6> eh?
03:37:44 <tkr> Axman6: windows installer for haskell platform with opengl and glut, do you mean?
03:37:44 <chrisbrown> QtPlaty[HireMe]: the point is that there is no metric for this; understandability is purely a user's opinion. what is understandable to one person might be difficult for another.
03:38:07 <QtPlaty[HireMe]> chrisbrown: I'm not tottaly in aggremnt.
03:38:15 <chrisbrown> QtPlaty[HireMe]: :)
03:38:21 <Axman6> tkr: yes, the haskell playform has a windows installer. all you need to do is run it, and you'll get all the basics you'll need (including nice things like OpenGL, GLUT and cabal-install)
03:39:05 <tkr> Axman6: ok. thanks. Ill try it later when finished work. :)
03:39:33 <therp> Beelsebob: true, there is nothing dynamic that resembles the static call chain. why is it so difficult to put it there
03:39:55 <Beelsebob> therp: because it's inefficient ;)
03:40:02 <astrobunny> o.o
03:40:03 <therp> altmattr: why is that an excuse for being developer unfriendly?
03:40:10 <Beelsebob> you have to store a static call chain at every single node in the graph
03:40:23 <Beelsebob> which is a lot of memory
03:40:33 <therp> Beelsebob: well, kinda. I said that I'm ok with a limited version. that would help a LOT
03:40:38 <altmattr> therp: you can't have both in one compiler, fast or naive
03:40:51 <Beelsebob> therp: well, as I said, IIRC, ghci does it if you turn the debugger on
03:41:09 <altmattr> therp: it is one of the unpleasant side-effect of pure lazy evaluation
03:41:20 <therp> altmattr: I'm arguing that one should build a good compiler (good as in easy to use and play with) first, before one offers something fast
03:41:20 <astrobunny> isnt there a way to step back down the stack by reverse-evaluating the recursed function?
03:41:23 <altmattr> ghci debugger will get you the facilities you want
03:41:33 <Beelsebob> therp: they did build a good compiler
03:41:36 <Beelsebob> they did that many years ago
03:41:41 <Beelsebob> then they built a fast one
03:41:45 <therp> Beelsebob: the problem with ghci debugger is, how can I turn that one for a precompiled package?
03:41:48 <Beelsebob> (also many years ago, but a smaller many)
03:41:58 <altmattr> therp: well, most people here think it is easy to use
03:42:09 <Beelsebob> therp: you don't... sorry
03:42:14 <therp> Beelsebob: the problem is not within my own code. if it would be I wouldn't need a backtrace to at least guess where the error is comming from
03:42:15 <altmattr> the lack of feature X which bugs you is not a death sentance
03:43:00 <therp> altmattr: well, I today started to write a blog post called "Good bye Haskell"
03:43:01 <altmattr> therp: have you looked at other haskell compilers?  hugs/uhc/nhc/yhc?
03:43:03 <Beelsebob> therp: sounds like the correct solution is either to grab the source and fix it; or to file a bug report with the author
03:43:39 <altmattr> therp: I will be interested to read it, I myself have just recently commited to another language in part because of things haskell is not good at
03:43:47 <therp> altmattr: well not seriously. the haskell universe is centered around ghc. unfortunately
03:44:01 <therp> altmattr: what language is that?
03:44:03 <altmattr> therp: uhc looks very good
03:44:09 <altmattr> therp: scala
03:44:11 <Beelsebob> therp: what's unfortunate about that?
03:44:18 <Beelsebob> ghc is currently the best compiler there is
03:44:31 <therp> altmattr: can I practically compile something like xmonad with uhc?
03:44:35 <altmattr> Beelsebob: unless you want to backtrack :)
03:44:50 <Beelsebob> altmattr: no compiler will let you do that
03:44:56 <therp> Beelsebob: definitely not. sorry to say but the GHC internals are far from nice.
03:44:57 <Beelsebob> (ofc the hat rewriter will)
03:44:59 <altmattr> therp: well, all haskell98 code will compile, what beyond that I am not sure
03:45:28 <mercury^> So nothing of interest compiles. :>
03:45:47 <altmattr> mercury^: I guess that is why we need haskell' :)
03:45:56 <therp> Beelsebob: also I dislike the concept to compile to binary objects and even worse bundle them up as static .a libraries. I would rather prefer to stay close to the source, as close as possible (yes for those guys that start to worry about efficient, just cache compilations)
03:45:58 <altmattr> give the compiler writers a camp-fire to crowd around
03:46:26 <Beelsebob> therp: okay... so grab the source, and use it like you want to...
03:46:26 <altmattr> therp: ?
03:46:50 <quicksilver> it's weird. Obviously different programming patterns highlight different problems.
03:46:59 <quicksilver> I've never once been bothered by the lack of backtraces.
03:47:51 <altmattr> quicksilver: me neither, but I have wished for working hat
03:48:01 <Axman6> i have once or twice. getting strange errors and having no idea where they came from sucks.
03:48:13 <Axman6> (like errors about arrays in code that didn't use arrays)
03:48:24 <lilac> i have sometimes wondered "where is this 'error' being called from" but almost never "who built this thunk?"
03:48:28 <therp> Beelsebob: of course, I could always fetch the source from somewhere, forget about the worries that the version might the wrong one, use grep and hope for the best. but frankly, that's not how I want to spend my time
03:48:42 * lilac is missing anglohaskell to work ;(
03:48:46 <altmattr> quicksilver: it also depends on your background, I have never been a big user of debuggers, but I know those who have miss them terribly
03:48:54 <Beelsebob> the only time I've ever wanted a stack trace is when I've got "Prelude.head: empty list" or equivalent – but really, that's my fault for using non-total functions
03:49:08 <therp> quicksilver: frankly, I don't believe that.
03:49:21 <quicksilver> therp: How can I convince you?
03:50:04 <Axman6> therp: quicksilver has never written bad code >_>
03:50:24 <therp> quicksilver: how would you solve the problem I'm having (with porting Shim to ghc-6.10). loading something in Emacs gives me "unknown package filepath". where would I search for the culprit of that exception without back traces?
03:50:50 <Axman6> o.O
03:50:50 <therp> quicksilver: the only thing that comes to my mind is grep+the guess that this error comes from Cabal or ghc/compiler/main/Packages*
03:51:16 <therp> Axman6: that should rather be "quicksilver never has used bad code" =)
03:51:23 <Axman6> heh
03:51:43 <therp> again, I don't need backtracking for my own stuff. I know my own stuff.
03:52:02 <quicksilver> well perhaps therp is right; I don't use many libraries.
03:52:03 <altmattr> I can say with my hand on my heart that I have never used bad haskell code
03:52:12 <malcolmw> as I understand things, ghci's debugger can give you a limited stack backtrace
03:52:15 <altmattr> I have written plenty of bad code :)
03:52:17 <malcolmw> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
03:52:26 <therp> indeed there is my culprit. ./compiler/main/Packages.lhs:missingPackageMsg p = ptext (sLit "unknown package:") <+> text p
03:52:27 <quicksilver> I've never heard of the error "unknown package"
03:52:58 <therp> quicksilver: presumably because the shim code written for ghc-6.6 assumes something different then ghc-6.10 supplies.
03:53:22 <therp> quicksilver: btw I have neither heard of that error. and having that as final output in my log doesn't help me at all to fix it.
03:53:40 <therp> quicksilver: that's why I would like to have backtraces to see at least what code provoked it.
03:53:56 <quicksilver> I don't really understand.
03:54:02 <quicksilver> That's not a haskell exception, is it?
03:54:06 <quicksilver> It's an error message from GHC.
03:54:15 <quicksilver> even with backtraces, you wouldn't have got one for that.
03:54:36 <therp> quicksilver: ah, I forgot to mention ./compiler/ghci/Linker.lhs:	= ghcError (CmdLineError ("unknown package: " ++ packageIdString new_pkg))
03:55:01 <therp> grepping is unfortunately not a reliable tool for those things
03:56:15 <soupdragon> > 1+1
03:56:16 <lambdabot>   2
03:56:55 <quicksilver> therp: OK, but this is quite a specific problem with the GHC API
03:57:04 <quicksilver> it's not raelly a general problem with haskell the language, or GHC the compiler.
03:57:16 <quicksilver> it is well known that the GHC API is poorly documented and hard to use.
03:57:58 <therp> quicksilver: if I can't fix problems other people produce (and they will do as not all people have time to write decent code) I blame that one the language
03:58:04 <lilac> therp: it sounds like something is using a package called filepath which GHC hasn't heard of. grepping for 'filepath' might be more useful
03:58:36 <quicksilver> therp: but you're not talking about a general case of the language.
03:58:38 <lilac> @hackage filepath
03:58:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
03:58:49 <quicksilver> you're talking about an issue with a large, fiddly, mostly undocumented library (the GHC API)
03:58:54 <quicksilver> the problems are with that library.
03:59:04 <quicksilver> they're not with the language, nor with the compiler in its normal usage pattern.
03:59:14 <therp> lilac: thanks, filepath is also in ghc-pkg list. further it complains about Cabal-1.6.0.3 being missing. that's also in my package installation. there is something else broken.
03:59:16 <quicksilver> a large fiddly mostly undocumented library will cause trouble in any language.
04:00:00 <FunctorSalad> therp: aren't traced being added in the next ghc? maybe don't quit just yet ;o
04:00:06 <FunctorSalad> *traces
04:00:13 <FunctorSalad> ISTR having read something
04:00:30 <therp> quicksilver: yes, but the difference is how a programmer can react to such a _normal_ situation. please don't try to argue that this is an isolated single case. the common case is that code does not work. in haskell not as often as for java libs but still the same
04:01:04 <lilac> therp: for what it's worth, i agree that haskell needs much better debugging tools.
04:01:59 <lilac> although if i got to control who worked on what, i'd put tools for finding space leaks above tools for producing backtraces
04:01:59 <therp> lilac: at the moment I'm trying to port SHIM http://code.haskell.org/shim/  which seems to be orphaned by the author, so that we can get a last some better and more integrated development tools
04:02:18 <altmattr> lilac: I am not so sure.  GHC is missing a bunch of tools that other langauges have, but it has a real REPL, the single greatest debugging tool of all time
04:02:29 <abc>  http://www.lostworlds.lv/go.php?1139723800 NEW WEBSITE GAME,COME AND PLAY.
04:02:30 <therp> lilac: did you see the nice profiling working on planet.h.o.?
04:02:40 <Axman6> @where ops
04:02:40 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:02:40 <lambdabot> mauke
04:02:45 --- mode: ChanServ set +o quicksilver
04:02:50 --- mode: quicksilver set +b *!*n=plinka@87.110.228.*
04:02:50 --- kick: abc was kicked by quicksilver (FUCK OFF YOU TWERP)
04:02:59 <Axman6> ta quicksilver
04:03:00 <quicksilver> there is precious little point though
04:03:09 <quicksilver> they quit after one URL anyway.
04:03:13 <Axman6> yeah :\
04:03:16 --- mode: quicksilver set -o quicksilver
04:03:21 <mmorrow> haha, he botched the first attempt with "* abc has quit (Excess Flood)"
04:03:32 <lilac> therp: yeah, i saw the pretty pictures
04:03:43 <quicksilver> therp: My claim is that debugging a "large mostly undocumented broken java library" is no more pleasant.
04:03:53 <quicksilver> therp: I don't dispute that code is often broken
04:04:04 <quicksilver> I dispute that it's ever fun or easy to debug large undocumented code bases
04:04:09 <quicksilver> (in any language)
04:04:26 <lilac> therp: but i want more! i'd like to be able to see an object and trace back what's holding a reference to it
04:05:01 <lilac> i think that's actually possible with vacuum-like techniques
04:05:12 <therp> quicksilver: pleasant or not :) If I need to, I could try it. yes, I could also use grep, find the error in a function, and try to grep for calls to that function in Shim. If I'm unlucky there are several intermediate functions and the grep trick doesn't work anymore.
04:05:31 <mmorrow> lilac: it can't tell you what's holding on to something, just what something is holding on to
04:05:44 <altmattr> hang on - doesn't everyone debug everything with grep?
04:05:57 <lilac> mmorrow: no, but starting from gc roots and working forward can tell me what's holding on to something
04:06:03 <mmorrow> lilac: (you'd have to vacuum /all/ live roots to get all live data)
04:06:07 <mmorrow> exactly
04:06:08 <lilac> *nod*
04:06:23 <lilac> but when that's what i want, it'd be great if there was a tool that could do that
04:06:32 <mmorrow> lilac: the GC ? :)
04:06:50 <therp> lilac: never ever look at SBCL (=Common Lisp), Slime, nor sb-profile which even has an emacs frontend
04:07:03 <lilac> mmorrow: i don't care which tool, i just want a debugging environment in which i can easily solve space leaks :)
04:07:14 <altmattr> amen
04:07:18 <therp> s/sb-profile/sb-sprof/ probably
04:07:19 <mmorrow> lilac: it'd be nice if the GC had an accessible-from-haskell-code interface
04:07:20 <FunctorSalad> http://hackage.haskell.org/trac/ghc/wiki/ExplicitCallStack
04:08:04 <akiel> can someone please help me with leksah or point me to a source - I read the manual again but have still some problems
04:13:41 <mmorrow> therp: it'd easy to get frustrated hacking with the ghc-api. i spent two hours earlier trying to be able to reference the same copy of a symbol from both code in a module and code that that module is evaluating via the ghc-api. since every level of eval seems to link in a _completely new copy_ of the entire rts+every imported package, i resorted to trying to use dlsym as a backdoor into the top-level syms. of course that failed, so i fel
04:13:41 <mmorrow> l back to trying to do all initialization within `eval' itself using a crapload of unsafePerformIO+IORefs..which tenuously works... but unfortunately `eval "42"' now takes 4.5 seconds (this was to try to implem per-user @let (you can do data decls, classes, instances too) for lunabot)
04:13:46 <mmorrow> wow, that was long :)
04:14:18 <mmorrow> so 4.5 seconds for ", 42" i think is too much.. time to start over :(
04:15:25 <FunctorSalad> , data Foo = Foo (Foo -> Int)
04:15:26 <lunabot>  luna: parse error on input `data'
04:15:27 <therp> mmorrow: ah, I was bit by that too in my early Liskell experiments. yes, interactive evaluation (byte code) and compile code live in different worlds
04:16:11 <hackagebot> cpphs 1.8 - A liberalised re-implementation of cpp, the C pre-processor. (MalcolmWallace)
04:16:12 <mmorrow> therp: thankfully it's the eventual goal for ghc to use dynamic libs, so they'll only be one copy of everything linked in
04:16:25 <therp> mmorrow: I would argue to abandon compiled code, reimplemented the assembler pass in haskell (that exists already imho somewhere in a different project), so that we can compile directly to memory without the .s->.o step
04:17:21 <therp> mmorrow: ah dynamic libs again. I was involved in that 2 years ago. first, GHC shouldn't go down that road, and second the devs are not sufficiently interested in that feature
04:17:29 <mmorrow> therp: totally! that would be awesome.
04:18:05 <therp> mmorrow: that's why I stopped, despite having dynamic lib working on (at some point in time) the three big plattforms: windows DLLs, OS x dylibs and ELF DSO
04:18:37 <matsuura> So, is it worth it to learn haskell?
04:18:41 <therp> ok, that was hello world, plus some significant regressions in the test suite, but it bitrotted and the restructing of the build system
04:18:42 <matsuura> Please be honest with me
04:18:50 <therp> matsuura: definitely
04:18:51 <malcolmw> therp: well, if the devs are not interested in it, at least some companies are, and they are paying for it to be implemented
04:19:23 <matsuura> therp: why? what are some benefits? Do I have to be a mathematician? Can I make applications that are rich and dynamic?
04:20:01 <altmattr> matsuura: always it depends on what you are using it for, however, Haskell is a language that can be recommended just for expanding your mind :)
04:20:57 <therp> matsuura: because useful abstractions are written so beautiful and clearly in haskell
04:21:26 <mmorrow> matsuura: dynamic, sure. you can write a [Word8] into some malloced memory then call it if you like.
04:21:26 <altmattr> matsuura: no, you don't need to be a mathematician
04:22:07 <mmorrow> matsuura: http://moonpatio.com/repos/ohhai.hs
04:22:30 <matsuura> So, where should I start?
04:22:35 <matsuura> I want to become the best!
04:22:53 <burp> o0
04:23:49 <therp> matsuura: I enjoyed coding project-euler.net problems
04:23:52 <Axman6> matsuura: learning haskell will make you a better programmer when using many other languages, though once you learn why haskell is so awesome, you won't want to use the other languages
04:24:12 <Axman6> matsuura: start with the learn you a haskell for great good tutorial:
04:24:16 <Axman6> @where lyah
04:24:17 <lambdabot> www.learnyouahaskell.com
04:24:21 <Axman6> matsuura: ^^^^^^^^^^^^^^
04:24:49 <matsuura> therp: I am not a mathematician
04:24:54 <matsuura> I cannot do those
04:25:06 <therp> matsuura: come on. those are not hard.
04:25:13 <therp> at least the first 30 :)
04:25:13 <Axman6> yeah, they're really not
04:25:17 <burp> lyah is not mathematic
04:25:25 <Axman6> matsuura: to be good at programming, you need to know some maths anyway
04:25:28 <therp> therp is not a mathematician :)
04:25:34 <Axman6> neither am i
04:25:38 <quicksilver> I hated the project-euler problems, conversely.
04:25:43 <Axman6> i'm a programmer ;)
04:25:45 <quicksilver> I thought they were boring and mostly pointless :)
04:25:52 <quicksilver> so, don't think that's the only way to learn a language.
04:26:00 <quicksilver> I'm a mathematician.
04:26:05 <matsuura> can I learn haskell while be a Windows User?
04:26:14 <Axman6> yep
04:26:30 <Axman6> @where platform
04:26:31 <lambdabot> http://hackage.haskell.org/platform/
04:26:38 <matsuura> I want to kill myself
04:26:40 <Axman6> matsuura: ^^^ there's an installer there
04:26:56 <blackdog> @faq can haskell be learnt as a windows user?
04:26:57 <lambdabot> The answer is: Yes! Haskell can do that.
04:30:29 <mmorrow> > fix error
04:30:31 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
04:30:45 <Axman6> i see haskell isn't magic yet :(
04:30:59 <Axman6> matsuura: need to tell it which error, duh
04:31:06 <Axman6> uh, mmorrow, not matsuura
04:33:38 <Axman6> oh shit, Haskell quit!
04:36:33 <matsuura> hahaha
04:40:49 <Axman6> matsuura: so, started with lyah?
04:41:26 <matsuura> Axman6: no
04:41:31 <matsuura> I started with installing
04:41:32 <matsuura> :)
04:41:41 <matsuura> what is lyah?
04:41:42 <Axman6> well, start reading while it's installing ;)
04:41:46 <Axman6> @where lyah
04:41:46 <lambdabot> www.learnyouahaskell.com
04:41:48 <kulakowski> @where lyah
04:41:48 <lambdabot> www.learnyouahaskell.com
04:41:49 <Axman6> ^^^^^^^^^^^^^^^
04:41:50 <matsuura> oh, I was watching porn, sorry
04:41:56 <Axman6> -_-
04:42:17 <matsuura> hahahaha @ learnyouahaskell page
04:45:01 <mmorrow> matsuura: so, decided not to kill yourself and watch porn instead?
04:45:25 <matsuura> yeah
04:45:31 <matsuura> :)
04:45:47 <mmorrow> :)
04:45:52 <matsuura> felt, maybe, a quick wank would satisify my terrible desire to put my flesh inside other flesh
04:46:12 <mmorrow> are you sober?
04:46:44 <mmorrow> if you're gonna do this, just get it out now.
04:47:01 <matsuura> moozilla: okay okay
04:47:06 <matsuura> no no, mmorrow **
04:47:12 <matsuura> but yeah, iKid..
04:47:25 <matsuura> anyways.. was looking at ms-sys.sourceforge.net
04:47:30 <matsuura> caught my attention
04:52:10 <mightybyte> What's the term for defining types in a typeclass?  (i.e. class Foo a where type Bar...)
04:53:35 <abbe> hi all
04:54:28 <EvilTerran> mightybyte, associated (data types|type synonyms)
04:54:33 <quicksilver> mightybyte: type familes / associated types
04:54:44 <EvilTerran> (depending on whether you use "data" or "type")
04:54:54 <mightybyte> Can you do the same thing with newtype?
04:55:15 <EvilTerran> i think, if you use "data" in the "class" decleration, you can use "newtype" in the "instance" decl
04:55:35 * abbe has finally written the code to populate Map using State monad available at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7969#a7969
04:56:13 <abbe> though it works, i'm just curious if I've used state monad properly.
04:56:37 <mightybyte> Ok, so that allows you to "create types within a typeclass", can you create types within another type?
04:57:02 <mightybyte> (i.e. data Foo a = ...newtype Ind a)
04:58:45 <int-e> abbe: the                          put . M.insert x (length x)
04:59:04 <abbe> int-e, sorry, i forgot to save the working code :(
04:59:10 <int-e> abbe: oops. anyway that line looks incomplete
04:59:18 <int-e> abbe: do you know about  modify?
05:00:02 <dschoepe> abbe: also it might be simpler to use foldr/foldl instead of the State monad
05:00:18 <int-e> true.
05:00:20 <Asztal> is it possible to use a flag such as -lglut in the OPTIONS_GHC pragma, or am I doing something wrong? (also, shouldn't the glut package do this for me?)
05:00:50 <int-e> @type fromList . map (id &&& length)
05:00:51 <lambdabot> Not in scope: `fromList'
05:01:13 <dschoepe> Asztal: afaik, linker options don't work there
05:01:15 <int-e> @type Data.Map.fromList . map (id &&& length)
05:01:16 <lambdabot> forall a. (Ord a) => [[a]] -> M.Map [a] Int
05:01:27 <abbe> int-e, dschoepe , was just trying to understand state monads. Corrected the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7969#a7970
05:01:49 <abbe> int-e, modify is not part of state monad, is it ?
05:01:51 <dschoepe> abbe: okay, if that is the case, you should take a look at modify
05:01:53 <dschoepe> @type modify
05:01:55 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
05:02:10 <int-e> @source modify
05:02:10 <lambdabot> modify not available
05:02:14 <int-e> @src modify
05:02:15 <lambdabot> Source not found. Just try something else.
05:02:32 <int-e> abbe: it's implemented in terms of put and get.
05:03:55 <abbe> yes. btw, is there any benefit of using ($) other than a syntactic sugar ?
05:04:05 <int-e> abbe: but it captures a common pattern - reading the state, applying a function to the state, and writing back the result.
05:04:10 <int-e> @src ($)
05:04:11 <lambdabot> f $ x = f x
05:04:13 <dschoepe> abbe: there are situations when you really need it.
05:04:23 <dschoepe> > map ($3) [(1+),(3+)]
05:04:24 <lambdabot>   [4,6]
05:04:35 <Axman6> abbe: you usually use it like f . g . h $ x
05:04:36 <int-e> @type flip id 3
05:04:38 <lambdabot> forall b c. (Num b) => (b -> c) -> c
05:04:39 <int-e> ;-)
05:05:34 <abbe> okay, thanks dschoepe int-e Axman6 :)
05:05:58 <Axman6> abbe: which is nicer than (f . g . h) x
05:06:33 <abbe> okay
05:12:54 <eevar2> us "real world haskell" a decent starting point?
05:12:56 <eevar2> *is
05:13:58 <xenoblitz> eevar2: yes :)
05:14:44 <eevar2> ok, thanks
05:14:51 <Axman6> i'd recommend learn you a haskell if you're starting from scratch
05:14:56 <Axman6> @where lyah
05:14:57 <lambdabot> www.learnyouahaskell.com
05:17:13 <dschoepe> eevar2: "A Gentle Introduction to Haskell" is also a nice tutorial(at least in my opinion): http://haskell.org/tutorial/
05:17:14 <twanvl> Does this crash ghci for anyone else:
05:17:19 <twanvl> > let ar=array (1,2) [(i,undefined)|i<-range (bounds ar)] in ar!1
05:17:25 <lambdabot>   mueval-core: Prelude.read: no parse
05:17:25 <lambdabot>  mueval: ExitFailure 1
05:17:52 <eevar2> i assume there's a fair bit of overlap in all this intro material
05:18:55 <dschoepe> eevar2: yes, but rwh is way more oriented towards real world applications than the other two
05:19:32 <therp> is there any irc channel for uhc?
05:19:52 <quicksilver> as far as I know, this one is the only one
05:20:15 <quicksilver> twanvl: just seems to hang ghci for me. I guess that's a valid behaviour for _|_
05:21:02 <twanvl> quicksilver: it shouldn't be bottom, but I understand why it is
05:21:25 <dschoepe> strangely it doesn't hang if you use [(1,_|_),(2,_|_)] instead of the list comprehension for me
05:21:49 <Axman6> twanvl: yeah, just hangs here
05:21:53 <twanvl> dschoepe: the problem is that it uses (bounds ar)
05:22:12 <Axman6> oh, heh. interesting
05:22:29 <dschoepe> twanvl: ah, yes because of the recursive definition
05:23:04 <dschoepe> I guess that's the bottom quicksilver meant
05:27:00 <Pavel__> how to fix paste from cliboard on Windows for Haskell-Platform-2009.2.0.2. It pastes only a single character. ghc-6.10.1 works fine and paste the whole line. Thanks
05:27:43 <Pavel__> I did not find any bug about it so I assume it is configuration issue
05:30:04 <int-e> hmm, could that be a haskeline problem?
05:33:22 <quicksilver> twanvl: why "shouldn't" it?
05:33:24 <quicksilver> twanvl: ;)
05:33:35 <pganelin> I just searched. It seems neither ghc-6.10.1 neither Haskell-Platform-2009.2.0.2 include this package. Does it mean I should install it for the platform and issue may be fixed?
05:33:38 <quicksilver> twanvl: I mean, it would be quite reasonable for it not to be. But it's also quite reasonable for it to be so.
05:33:57 <quicksilver> twanvl: not everything has to be maximally lazy. Sometimes there are reasons not to be.
05:34:40 <twanvl> you are right, lazyness is probably not very useful here
05:35:13 <twanvl> I was just looking for a quick and dirty way to avoid repeating the bounds :)
05:35:46 <twanvl> there ought to be a function "funArray :: Ix i => (i,i) -> (i -> e) -> Array i e"
05:35:47 <gwern> is it plausible that under cygwin, bash could exist but not sh?
05:36:30 <quicksilver> twanvl: there did, although, that's not very hard to write.
05:36:38 <koala_man> my cygwin installation has sh
05:37:18 <matsuura> yeah, so this is fun
05:38:09 <dschoepe> twanvl: there's accumArray which you can use for that
05:39:41 <gwern> (argh, why does reddit suck so much for the past few weeks)
05:41:00 <blackdog> gwern: is it missing cool stuff that's happening, or just low signal-to-noise?
05:41:18 <gwern> eh? no, it's broken on a more fundamental level ie. the browser level
05:41:41 <int-e> pganelin: I thought ghc-6.10.4 switched to haskeline instead of editline (this does not necessarily affect the installed packages)
05:42:16 <Axman6> matsuura: am i sensing some sarcasm there?
05:43:03 <matsuura> Axman6: o_o
05:43:05 <matsuura> no
05:43:12 <matsuura> how could haskell not be fun?
05:43:15 <Axman6> so you're liking haskell so far then?
05:43:20 <matsuura> yes
05:43:20 <matsuura> o_o
05:43:25 <Axman6> well good :)
05:43:42 <matsuura> especially the whole list thing
05:43:44 <matsuura> :o
05:43:48 <matsuura> reminds me of scheme a little
05:44:03 <Axman6> yeah, lists are very important to haskell. it's good if you love them ;)
05:44:12 <matsuura> but I do
05:44:30 <matsuura> reminds me of the art of folding
05:44:35 <matsuura> or folds
05:44:38 <matsuura> one or the other
05:45:05 <Axman6> well, guess what
05:45:11 <Axman6> @src foldl
05:45:11 <lambdabot> foldl f z []     = z
05:45:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:45:13 <Axman6> @src foldr
05:45:13 <lambdabot> foldr f z []     = z
05:45:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:45:34 <matsuura> :O
05:46:32 <Axman6> you know what else i cool about lists?
05:46:44 <Axman6> > [1..] -- they can be infinite
05:46:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:46:47 <koeien> they are lazy! :)
05:46:47 <matsuura> http://learnyouahaskell.com/painter.png
05:46:52 <matsuura> lol
05:47:45 <koeien> > let even n = n `mod` 2 == 0 in takeWhile (<= 37) $ filter even [1..]
05:47:47 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36]
05:48:31 * Axman6 is happy, we've started doing inductive proofs in haskell now in my formal methods course at uni
05:53:59 <gwern> oh dear. is darcs hlint broken for anyone else?
05:54:09 <gwern> on the nonexistent Hint.Import
06:08:23 <Quantumplation> Is there a way to curry a function and rearrange the parameters? Or "Partially apply" things other than the first parameter?
06:08:51 <lilac> Quantumplation: you can use 'flip' for that
06:08:52 <saml> > (\a b c -> f b c)
06:08:53 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1 -> t2 -> t3)
06:08:53 <lambdabot>    arising fr...
06:09:04 <lilac> Quantumplation: or operator sections
06:09:34 <lilac> > let fm = flip map "hello world" in (fm toUpper, fm isSpace)
06:09:35 <quicksilver> Quantumplation: that's what lambda notation is for, I woiuld argue.
06:09:36 <lambdabot>   ("HELLO WORLD",[False,False,False,False,False,True,False,False,False,False,...
06:09:49 <quicksilver> (\x -> f 5 x 10)
06:09:58 <lilac> > (/3) 9
06:10:00 <lambdabot>   3.0
06:10:09 <quicksilver> operator sections are just a useful special case
06:10:27 <quicksilver> giving the second argument special treatment (like the first argument already had)
06:11:08 <quicksilver> flip lets you move the arguments around but I personally find it very ugly compared to the elegance of lambda notation.
06:11:28 <Axman6> EQUAL RIGHTS FOR THIRD ARGUMENTS!
06:11:33 <Botje> flip foo b vs \x -> foo x b ?
06:11:37 <quicksilver> @pl \f a b c d -> f d a c b
06:11:38 <lambdabot> ((flip . (flip .) . flip) .) . flip
06:11:42 <quicksilver> Botje: yes.
06:11:53 <Botje> boo :P
06:11:56 <Quantumplation> Haha, oh jeez.  All this terminology is quite abit above my head right now. =) I'm following the "learn you a haskell" tutorials, and It's just gotten to the curried functions section.
06:12:22 <Quantumplation> I've got 9 years of imperative programming behind me, It's quite difficult to shift the mindset, but it's been an absolute blast so far. =)
06:13:07 <Axman6> Quantumplation: does (\x y z -> f z x y) make sense to you?
06:14:07 <Quantumplation> erm, slightly, but i've never been exposed to that notation... I'm just going off what seems like would make sense heh
06:14:57 <Quantumplation> I'll just keep reading the guide. =) I'm sure it covers lambda notation later, I was just curious for a sneak peek.
06:14:57 <Axman6> it's called lambda notation. \ is supposed to represent a lambda, and comes from... well lambda calculus :P
06:15:05 <mauke> > (\x y z -> (z, x, y)) 1 2 3
06:15:07 <lambdabot>   (3,1,2)
06:15:14 <mauke> > (\x -> x + 1) 41
06:15:16 <lambdabot>   42
06:15:21 <Axman6> it lets you create annonymous functions
06:15:26 <Quantumplation> ah ok
06:15:34 <Quantumplation> much like lambda's in c#
06:15:40 <Quantumplation> (Doh lol)
06:15:53 <Axman6> most likely
06:15:57 <Axman6> i've never used C#
06:16:25 <mauke> C♯
06:17:53 <copumpkin> C♮
06:18:09 <mauke> D♭
06:19:06 <copumpkin> :(
06:19:12 <copumpkin> my client doesn't like non-bmp characters
06:19:46 <Quantumplation> :-S This Project Euler problem 11 is really tricky.
06:20:30 <Quantumplation> (the "find maximum product of 4 numbers in a line of this 20x20 grid)
06:22:54 <Pistahh> C =||=
06:23:02 <mauke> hmm, I did that in C
06:23:51 <mauke> ... using brute force
06:24:01 <lilac> i did it in haskell, i think, using a slightly refined brute force approach
06:24:04 <copumpkin> Quantumplation: think about how many 4-number sequences there are in that grid
06:24:50 <mauke> simply trying all possibilities takes approximately 0.000s
06:25:00 <copumpkin> yeah :P
06:25:00 <lilac> > 78 * 78 * 96 * 83
06:25:02 <lambdabot>   48477312
06:25:10 <lilac> mauke: sure, but where's the fun in that?
06:25:15 <copumpkin> although you can probably avoid a little bit of recomputation if you try
06:25:20 <mauke> copumpkin: no point in that
06:25:21 <copumpkin> I just brute forced it too though :P
06:25:22 <copumpkin> yeah
06:25:44 <mauke> lilac: I like to solve all euler problems with brute force where possible
06:26:18 <copumpkin> mauke is such a brute!
06:27:05 <Quantumplation> 16 * 20 + 16 * 20 + 16*16 + 16*16
06:27:07 <Quantumplation> right?
06:27:30 <lilac> Quantumplation: looks about right to me
06:27:36 <roconnor> @hoogle getpass
06:27:37 <lambdabot> No results found
06:27:41 <lilac> > 16 * (2*16 + 2*20)
06:27:42 <lambdabot>   1152
06:27:59 <Quantumplation> And you can discard any that include 00
06:28:14 <RayNbow> hmm, is there a name for equations of the form x_1 + x_2 + ... + x_n = r   with   x_i >= 0 ?
06:28:41 <int-e> Quantumplation: s/16/17/g
06:28:52 <mauke> really?
06:28:56 <Quantumplation> why 17?
06:29:04 <copumpkin> anything lower is illegal
06:29:09 <lilac> yeah, it's 17
06:29:21 <mauke> then my program is wrong
06:29:26 <int-e> Quantumplation: because there are only 3 "extra" numbers compared to the single one you start with.
06:29:47 <lilac> it'd be 20 if we wanted runs of 1, or 1 if we wanted runs of 20. so it's 20 - n + 1
06:30:44 <roconnor> <Quantumplation> why 17? <copumpkin> anything lower is illegal
06:30:48 <Quantumplation> Oh, guess your right
06:30:55 <roconnor> what a strange conversation to jump into the middle of
06:30:59 <Quantumplation> lol
06:31:51 <Quantumplation> not knowing how to do loops is throwing me off
06:32:02 <mauke> recursion
06:32:06 <int-e> RayNbow: some sort of partitions.
06:32:10 <mauke> keep loop state in parameters
06:32:26 <lilac> or [f x y | x <- [0..16], y <- [0..16]]
06:33:15 <Quantumplation> mauke: That's what i've been doing, but it gets cluttered quickly
06:33:42 <int-e> prods (a:b:c:d:xs) = a*b*c*d : prods (b:c:d:xs); prods _ = []. :-)
06:33:56 <RayNbow> int-e: hmm, yeah... that's one way to look at it
06:34:12 <RayNbow> I was thinking of some kind of distribution
06:34:28 <RayNbow> (where you distribute r thingies over n bins)
06:35:39 <int-e> RayNbow: it's a combination with repetition then.
06:36:27 <Quantumplation> int-e: that takes care of your horizontal products... what about vertical and two diagonals?
06:36:38 <lilac> vprods (as:bs:cs:ds:ess) = vprods' as bs cs ds:vprods (bs:cs:ds:ess); vprods' (a:as) (b:bs) (c:cs) (d:ds) = (a*b*c*d):vprods' as bs cs ds
06:36:41 <lilac> that's vertical
06:37:01 <lilac> or you can do "map prods $ transpose xs"
06:37:03 <int-e> Quantumplation: transpose. for diagonals, I wrote a custom diags :: [[a]] -> [[a]] function.
06:37:18 <Quantumplation> ah ok
06:38:22 <Quantumplation> what's the $ represent there?
06:38:25 <RayNbow> int-e: that's right... I was just looking for a nice name for that kind of equation :)
06:38:34 <RayNbow> @src ($)
06:38:34 <lambdabot> f $ x = f x
06:38:56 <RayNbow> map prods $ transpose xs   ==   map prods (transpose xs)
06:39:00 <Quantumplation> Ah ok
06:39:16 <Quantumplation> it's a way of breaking up the right assosciative function application then?
06:39:32 <lilac> maximum $ do x <- [0..19]; y <- [0..19]; xAdd <- [0..1]; yAdd <- [0..1]; guard (xAdd + yAdd > 0); return $ product [xs!!x+xAdd*d!!y+yAdd*d | d <- [0..3]] where xs!!n = fromJust 0 (listToMaybe (drop n xs))
06:39:47 <idnar> Quantumplation: it's more about lower precedence, not associativity
06:40:09 <int-e> lilac: that's missing one direction
06:40:26 <lilac> int-e: yeah, you're right :)
06:40:44 <lilac> (xAdd,yAdd) <- [(0,1),(1,0),(1,1),(1,-1)]
06:40:49 <int-e> lilac: and it goes out of range, too.
06:40:55 <lilac> int-e: that's not a problem
06:41:06 <int-e> ah
06:41:10 <int-e> nasty
06:41:21 <lilac> it doesn't type-check; that /is/ a problem :)
06:41:45 <RayNbow> kill the type-checker! :p
06:41:46 <int-e> wrong precedences?
06:42:05 <lilac> nah, my !! only works on Num a => a
06:42:46 <lilac> xs!!n = fromJust mempty (listToMaybe ..), and using the Product monoid, would probably work fine
06:43:34 <mauke> > ["xy"] !! 0 !! 1
06:43:36 <lambdabot>   'y'
06:43:40 <lilac> i'd guess there's a more elegant way of dealing with the out-of-range-ness though
06:44:17 <lilac> @type ?xs !! ?x + ?xAdd * ?d !! ?y + ?yAdd * ?d
06:44:19 <lambdabot> on the commandline:
06:44:19 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
06:44:19 <lambdabot> Top level:
06:44:48 <lilac> the precedence is wrong too, actually ;-)
06:45:01 <Quantumplation> =/ I was having trouble the other day where !! was inferring int, when i needed Integer
06:45:14 <lilac> type (!!)
06:45:21 <lilac> @type (!!)
06:45:23 <lambdabot> forall a. [a] -> Int -> a
06:45:26 <RayNbow`> :t genericIndex
06:45:27 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
06:45:36 <RayNbow`> @hoogle genericIndex
06:45:37 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
06:45:53 <lilac> Quantumplation: yeah, list indices are Int by default in all the common operations (i think to avoid ambiguity)
06:46:02 <lilac> @type length
06:46:04 <lambdabot> forall a. [a] -> Int
06:46:10 <RayNbow`> :t genericLength
06:46:12 <lambdabot> forall b i. (Num i) => [b] -> i
06:46:15 <lilac> @type take
06:46:17 <lambdabot> forall a. Int -> [a] -> [a]
06:46:23 <lilac> @type genericTake
06:46:24 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:46:37 <pganelin> int-e: I run haskell without cygwin and haskeline works only under cygwin. There re ano files matching *haskeline" for both installations
06:46:42 <Quantumplation> ah =/ lol what module is the generic_ stuff in?
06:46:49 <lilac> @index genericTake
06:46:50 <lambdabot> Data.List
06:46:50 <RayNbow`> Data.List
06:46:53 <Quantumplation> k
06:47:19 <int-e> pganelin: Fair enough. It was merely a guess, and I'm not using Windows.
06:47:51 <pganelin> int-e: thanks
06:49:34 <mauke> my solution to problem 11: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7975#a7975
06:50:39 * RayNbow` wonders if there's a CT-heavy solution for problem 11 on the hawiki
06:52:04 <int-e> mauke: added mine (without title, sorry)
06:52:55 <RayNbow`> hmm, there's an Arrow solution on the wiki
06:53:05 <mauke> added a slight simplification
06:57:58 <mercury^> I once deleted my folder with haskell solution to most problems. :(
06:58:25 <quicksilver> lilac: I think it's for performance.
06:58:59 <mercury^> I can remember that I had two solutions to that one, one using arrays, one lists. Surprisingly, the list version was fully fused, so it was really fast.
07:00:35 <mauke> my list version should be pretty inefficient. it's all brute force, nothing cached, uses !! twice for every element access
07:00:42 <mauke> and it runs in 0.00s
07:01:01 <mxc> hm. is there no way to error calls?
07:01:04 <idnar> heh
07:01:12 <mercury^> Yeah, I used larger matrices for testing performance.
07:02:01 <quicksilver> mxc: sentence fails to parse.
07:02:21 <mxc> Data.Binary.decode is failing on something
07:02:55 <mxc> looking through the code, i know where its failing, and when it falls, it ultimately calls: error "too few bytes. Failed reading at byte position 1"
07:03:17 <mxc> i'd like to catch this in my code, tried Prelude.catch and am experimenting with Control.Exception.catches
07:03:29 <quicksilver> you can, although it's not recommend.
07:03:38 <mxc> but the haddock docs suggest that error doesn't raise an exception, just terminates execution
07:03:38 <quicksilver> Binary is not really designed for untrusted data.
07:03:52 <quicksilver> in GHC error does, in fact, raise an exception.
07:04:01 <mxc> quicksilver - i know..  all the data is being encoded and decoded using the Data.derive derivations
07:04:21 <mxc> quicksilver - but, at some point in getting passed over the wire, i'm messing it up somehow
07:04:45 <mxc> if i promise to take the code out when i'm done debugging, will you tell me how to catch it ?
07:05:00 <jeffwheeler> Apparently this syntax is incorrect: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7978#a7978
07:05:26 <jeffwheeler> Because it fails with 'parseField' on a non-field; should I be checking outside the flag and setting the default there?
07:05:38 <jeffwheeler> Or, is that even possible?
07:07:22 <quicksilver> mxc: I don't know, I always forget
07:07:39 <quicksilver> it might even depend which version of base / the exceptions library you have
07:07:57 <mxc> i think i have an idea
07:09:40 <quicksilver> I think the exception type is called ErrorCall
07:09:43 <quicksilver> @hoogle ErrorCall
07:09:44 <lambdabot> Control.Exception ErrorCall :: String -> Exception
07:09:44 <lambdabot> Control.Exception errorCalls :: Exception -> Maybe String
07:12:20 <mxc> errorcall!
07:12:21 <mxc> thats it
07:12:22 <mxc> thnkas
07:13:56 <mxc> weird.. still not catching it
07:15:08 <int-e> mxc: are you sure that the error call happens within your catch block? you have to actually force its thunk.
07:15:36 <mxc> i see the error text getting printed to stdout my it doesn't trigger my handler
07:15:53 <int-e> so   foo <- decodeFile ... `catch` blah  won't work.
07:16:23 <blbrown_win> I was trying to run with this example with gtk2hs, but getting the error below  http://paste.lisp.org/display/84881
07:16:23 <mxc> yeah.. but, if i see the argument to error get prined on stdout, then i know its been forced right?
07:18:24 <horms> :t fmap
07:18:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:20:34 <int-e> mxc: does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7979#a7979 work for you?
07:20:57 <int-e> (note ... using the new exception system that comes with base 4)
07:21:15 <mxc> int-e thats basically what I did and its not catching it
07:21:16 <mxc> thanks
07:21:35 <mxc> anyway, i'm going to just try to work it out by hand... :(  for a bit
07:22:17 <quicksilver> int-e: really? Binary decode is lazy?
07:22:29 <quicksilver> bah.
07:22:33 <int-e> mxc: actually, try renaming main to main' and using main = main' `catch` ...
07:22:43 <int-e> quicksilver: there's a decodeFile' that's strict, IIRC.
07:23:14 <int-e> quicksilver: but the whole low level decoding machinery works on lazy bytestrings.
07:26:36 <mxc> int-e : if the error is called from a thread besides the main thread, would the main trick still work?
07:26:52 <int-e> mxc: ah. nope.
07:27:18 <mxc> so i need to do something like catch (forkIO a) ...
07:27:43 <int-e> no, you'd have to catch inside the action passed to forkIO
07:27:48 <mxc> yeah
07:27:52 <mxc> i thought i was
07:27:56 <int-e> forkIO (a `catch` ...)
07:28:17 <mxc> because i wrapped every occurence of decode with the catch
07:28:33 <mxc> (there are 2, it wasn't hard)
07:29:25 <quicksilver> int-e: it's not really the lazy bytestring I'm complaining about but the interleaved IO, I guess.
07:29:45 <hackagebot> yaml 0.0.3 - Support for serialising Haskell to and from Yaml. (MichaelSnoyman)
07:30:08 <quicksilver> although I suppose any lazy operation - even a pure one - doesn't really have an elegant way to return errors
07:30:22 <quicksilver> unless it is using a special return type with error markers threaded through
07:30:27 <quicksilver> Binary doesn't have that luxury.
07:31:17 <Axman6> @hackage yaml
07:31:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yaml
07:32:18 <mxc> quicksilver - wouldn't having a type of decode :: ByteString ->  Either String a be a partial solution
07:32:54 <mxc> i guess that would be the special return type you mentioned
07:33:00 <quicksilver> mxc: that wouldn't be lazy any more.
07:33:12 <quicksilver> it would have to check for errors before deciding to return "Left" or "Right".
07:33:22 <quicksilver> I mean, that is the solution I favour, personally :)
07:33:27 <quicksilver> but, it does away with laziness.
07:33:39 <mxc> i dont see why
07:33:53 <mxc> you can't have a lazy decode that returns Either
07:33:56 <EvilTerran> you have to parse in full to be sure there aren't any errors, before you can return Right
07:34:02 <mxc> oh i see
07:34:03 <mxc> yeah
07:34:04 <int-e> mxc: you have to read in and decode all of a to decide whether to return Left foo or Right a
07:34:12 <mxc> true
07:34:35 <int-e> quicksilver: I'd like to have a choice.
07:34:40 <quicksilver> int-e: choice is good.
07:34:51 <quicksilver> unless one alternative is bad, of course.
07:35:31 <mxc> you could do some very ugly stuff with IORefs and unsafePerformIO...  but i'm pretty sure thats a terrible idea
07:35:47 <quicksilver> mxc: what I meant by special type with error markers threaded through is something like
07:36:10 <quicksilver> data ListWithError a = Cons a (ListWithError a) | SuccessfulEndOfList | Error String
07:36:27 <quicksilver> that can return partial data even though their might be an error later.
07:36:37 <quicksilver> of course it's more complex (but same idea) with more complex data shapes.
07:36:46 <mxc> interesting
07:36:54 <quicksilver> and you might even allow the list to continue after the error
07:37:03 <int-e> add some continuations and you'll get iterators.
07:37:22 <quicksilver> data ListWithError a = Cons a (ListWithError a) | SuccessfulEndOfList | ErrorButLetsCarryOn String (ListWithError a) | ErrorAndIGiveUp String
07:38:12 <EvilTerran> quicksilver, replacing (Mu f) with Mu (Either Error `O` f) ?
07:43:10 <soupdragon> can functional programming be liberated from the von neumann architecteur?
07:55:47 <quicksilver> EvilTerran: yes, except you might possibly not want to allow errors in every possible single place
07:55:51 <quicksilver> EvilTerran: but, yes, basically.
07:59:32 <wmealing1> mergeSort :: Ord a => [a] -> [a]
07:59:40 <wmealing1> what do you call the "Ord a" part of that definition ?
07:59:43 <codebliss> @t on
07:59:44 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:59:50 <codebliss> :t on
07:59:52 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:00:43 <wmealing1> Type enforcement ?
08:01:39 <quicksilver> wmealing1: constraint
08:01:57 <wmealing1> thanks
08:01:59 <quicksilver> or, "class constraint" or "typeclass constraint" or s/constraint/context/
08:02:05 * wmealing1 nods
08:02:26 <wmealing1> I see it mentioned, i think i understand what it does.. just not sure what the correct term is
08:03:03 <quicksilver> it's an additional constraint on the type "a"
08:03:11 <quicksilver> which is why htat's a good word for it.
08:03:26 <quicksilver> it works for all types a ... as long as you can find an Ord instance.
08:14:07 <codebliss> > let fancy n = replicate 5 '*' ++ n ++ replicate 5 '*' in fancy "I am bored."
08:14:09 <lambdabot>   "*****I am bored.*****"
08:14:47 <ray> -*={fancy}=*-
08:15:05 <codebliss> I love .::Fancy::.
08:16:37 <Gracenotes> hey. Anyone know of any good pastebin sites for plain text?
08:16:54 <RayNbow> define "good"? :p
08:16:59 * RayNbow often uses dpaste
08:17:14 <Gracenotes> uh. suitable >_> :)
08:17:29 <ray> servicable
08:18:15 <codebliss> > takeWhile ((/=) 0) $ iterate (flip mod 10) 900
08:18:16 <lambdabot>   [900]
08:18:25 <codebliss> > 900 `mod` 10
08:18:26 <lambdabot>   0
08:18:29 <codebliss> Oh.
08:18:45 <codebliss> > takeWhile ((/=) 0) $ iterate (/10) 900
08:18:47 <lambdabot>   [900.0,90.0,9.0,0.9,9.0e-2,9.0e-3,9.0e-4,8.999999999999999e-5,8.99999999999...
08:18:52 <codebliss> *facepalm*
08:19:34 <jmcarthur_work> > takeWhile ((/=) 0) $ iterate (`div` 10) 900
08:19:35 <lambdabot>   [900,90,9]
08:25:46 <mathrick> hiya, I just need a second opinion
08:25:50 <quicksilver> mathrick: No.
08:25:59 <mathrick> <mauke> f x + f x creates two thunks <mauke> it will actually call f twice
08:25:59 <quicksilver> (did it have to be an informed second opinion?)
08:26:05 <mathrick> quicksilver: preferably
08:26:08 <mathrick> but noted
08:26:09 <quicksilver> shame.
08:26:18 <mathrick> well, anyway, is what mauke's saying true?
08:26:23 <mauke> mathrick: yes
08:26:24 <Berengal> mathrick: Yes
08:26:24 <quicksilver> yes.
08:26:27 <idnar> yes
08:26:29 <sjanssen> mathrick: probably
08:26:34 <Berengal> Unless the compiler feels very generous
08:26:36 <mathrick> ok, I wonder where I got the idea it reused thunks
08:26:40 <quicksilver> I don't think anything in the report forbids a compiler from doing CSE.
08:26:47 <quicksilver> but, in practice they are very conservative about it
08:26:52 <quicksilver> because it causes space leaks.
08:26:54 <mathrick> yeah, I meant in practice
08:26:56 <sjanssen> it would be acceptable for a Haskell compiler to eliminate the common subexpression, but no existing compiler does
08:27:01 <idnar> I think there are some extremely limited scenarios under which it will happen
08:27:01 <mathrick> quicksilver: howso?
08:27:06 <||Zero||> hola a todos
08:27:07 <quicksilver> I think GHC would CSE that in the following slighly different case:
08:27:07 <idnar> but perhaps I'm mis-remembering
08:27:10 <mathrick> mauke: YOUR OPINION ISN'T SECOND
08:27:12 <Berengal> GHC does CSE, but it's very conservative about it
08:27:14 <quicksilver> let e = f x in f x + f x
08:27:15 <||Zero||> alguien habla espaol
08:27:25 <quicksilver> (which looks a bit odd, but still)
08:27:37 <quicksilver> I think GHC will in fact CSE that to "let e = f x in e + e"
08:27:51 <Berengal> i've seen it reduce a O(2^n) algorithm to a O(n) by CSE alone though
08:28:03 <quicksilver> depending if the pattern still looks like that once the optimiser gets to it.
08:28:10 <quicksilver> mathrick: how can it cause a space leak?
08:28:12 <mathrick> quicksilver: how does optimistic thunking cause space leaks?
08:28:14 <mathrick> yeahj
08:28:15 <quicksilver> mathrick: consider the following:
08:28:23 <pikhq> mathrick: Lazy evaluation and garbage collection means that a common subexpression will end up keeping stuff around a lot.
08:28:36 <quicksilver> mathrick: sum(<long list expression>) / length (<long list expression>)
08:28:48 <copumpkin> Berengal: roconnor's thing that he posted to reddit?
08:28:50 <quicksilver> mathrick: if you CSE, the whole list gets kept in memorry
08:28:53 <Berengal> copumpkin: Yup
08:28:56 <quicksilver> because it's going to be used again.
08:29:12 <quicksilver> if you don't, then both sum and length can traverse it (separately) GCing as they go along.
08:29:20 <mathrick> ah
08:29:35 <idnar> of course, in that particular case, if you consume the lists in "parallel", you don't need to keep the whole list around
08:29:41 <quicksilver> indeed.
08:29:50 <quicksilver> there was a need proof of concept with `par` which proved this.
08:29:57 <idnar> but that's getting even harder for the poor compiler to figure out
08:29:59 <||Zero||> hey can somebody tell me how can i make 3d grapics in haskell
08:29:59 <quicksilver> but practical examples aren't that simple :)
08:30:00 <pikhq> CSE is rather difficult to do well in a lazy language, garbage-collected language.
08:30:13 <pikhq> ||Zero||: OpenGL bindings.
08:30:18 <mauke> mathrick: http://www.haskell.org/haskellwiki/GHC:FAQ#Subexpression_Elimination
08:30:22 <mathrick> idnar: I thought the entire fusions thing was just that
08:30:48 <Berengal> mathrick: No, fusion is just not building the list in the first place
08:30:49 <quicksilver> fusion is about eliminating unnecessary construction/destruction
08:30:52 <mathrick> aha
08:30:59 <||Zero||> with opngl can i make 3d graphics
08:31:02 <Berengal> Nothing about parallel evaluation
08:31:08 <mathrick> ||Zero||: yes, that's what opengl is
08:31:29 <||Zero||> can you tell give a tutorial or web
08:31:38 <mathrick> ||Zero||: http://en.wikipedia.org/wiki/OpenGL
08:31:45 <mathrick> explanation of what OpenGL is
08:31:55 <mathrick> you will probably find a spanish version as well
08:32:02 <jmcarthur_work> ||Zero||, i think the nehe tutorial has been ported to haskell somewhere
08:32:06 <||Zero||> i need one
08:32:15 <voker57> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3213 <- parsec problem
08:32:50 <mathrick> anyway, thanks for your assistance, and have a fine weekend
08:32:51 <||Zero||> somebody have a complete program of that
08:32:56 <nainaide> Is there any demo for multiple argument  input for Haskell CGI ? Thanks
08:33:24 <quicksilver> ||Zero||: try http://www.haskell.org/haskellwiki/OpenGLTutorial1
08:34:06 <quicksilver> voker57: well, I think your "item" requires a ||| at the end
08:34:23 <quicksilver> voker57: isn't that what the (lookahead seperator) does?
08:34:56 <voker57> quicksilver: lookAhead tells that ||| should be after item if I understand correctly
08:35:02 <voker57> it doesn't consume input
08:35:10 <mauke> yes, but the ||| still has to be there
08:35:10 <||Zero||> but i have to dowload some library before
08:35:11 <quicksilver> yes
08:35:20 <quicksilver> voker57: and there isn't a ||| afgter the '4', is there?
08:35:23 <quicksilver> so that's why it crashes
08:35:28 <voker57> ah
08:35:32 <quicksilver> your input string doesn't match your grammar.
08:35:32 <jmcarthur_work> ||Zero||, opengl is a library
08:35:43 <voker57> ok, understood
08:35:52 <||Zero||> so i hav to donload that before
08:36:06 <jmcarthur_work> yes
08:36:18 <||Zero||> sorry but im a noob in haskell
08:36:23 <jmcarthur_work> ||Zero||, if you have cabal-install it should be as easy as "cabal install opengl"
08:36:46 <||Zero||> cabal install
08:36:58 <||Zero||> sorry but i only use winhugs
08:37:00 <quicksilver> or, opengl comes with the haskell platform.
08:37:19 <lilac> Mu (Either Error `O` (,) (Maybe Error) `O` f) perhaps for the latter form
08:37:33 <quicksilver> lilac: something like that, yes.
08:37:36 <jmcarthur_work> i would recommend using ghc rather than hugs, especially for 3d graphics
08:38:01 <jmcarthur_work> well, maybe it's no matter
08:38:06 <||Zero||> do you thing that ill get problems with hugs
08:38:37 <doublethink_work> no, hugs is just old and not nearly as featureful as GHC
08:40:51 <||Zero||> opengl is only for haskell
08:41:06 <||Zero||> ??
08:41:11 <pikhq> No, OpenGL is the standard 3D library.
08:41:23 <pikhq> It happens to have very good Haskell bindings.
08:41:42 <jmcarthur_work> well, good bindings. not a good haskell-style api
08:41:52 <pikhq> jmcarthur_work: Fair enough.
08:42:10 <jmcarthur_work> but it's at least very familiar to those who already know opengl in C
08:43:01 <lilac> quicksilver: i was further back in the scrollback than i thought, oops :)
08:43:10 <||Zero||> i want a code of a 3d graphic
08:43:35 <mauke> ||Zero||: do you know any haskell?
08:43:42 <||Zero||> yes
08:44:08 <||Zero||> but i need to expose a code about 3 dgraphics
08:44:31 <copumpkin> > let (a, b, c) = (b + 1, c + 2, 4) in (a, b, c)
08:44:32 <lambdabot>   (7,6,4)
08:45:29 <||Zero||> sombody has a code of that
08:45:30 <||Zero||> ??
08:45:44 <copumpkin> ||Zero||: hackage.haskell.org
08:45:55 <copumpkin> ||Zero||: lots of opengl stuff on there if that's what you want
08:57:52 <||Zero||> i need a tutorial of opengl in haskell
08:58:02 <||Zero||> but with 3 d graphics
08:58:46 <||Zero||> does anyone know
08:58:47 <wmealing1> i'd imagine most openGL is 3d
08:58:58 <Beelsebob> I'm not sure that's true
08:59:11 <||Zero||> but in haskell there are too few
08:59:14 <Beelsebob> vast quantities of it are 2D because it just gives quick access to a framebuffer
08:59:23 <dmwit> I think the NeHe tutorials have been partly translated to Haskell.
08:59:24 <Beelsebob> |||Zero||: it's mostly identical to OpenGL anywhere else
08:59:25 <wmealing1> 3d with no z index
08:59:28 <Beelsebob> with a few cleaned up bits
08:59:31 <dmwit> Google for it.
08:59:33 <Beelsebob> wmealing1: yep
09:00:48 <msteele__> ||Zero||: copumpkin already gave you a link to find Haskell Opengl.  There are tutorials and examples on that page.
09:01:04 <||Zero||> yes im looking for that in google but i cant find one
09:01:20 <msteele__> ||Zero||: http://www.haskell.org/haskellwiki/Opengl
09:01:20 <||Zero||> yes but there are in 2d
09:01:45 <wmealing1> 2d is just 3d with no z index
09:02:03 <wmealing1> work on the 2d to start with
09:02:08 <wmealing1> once you have that downpat, think about the 3d
09:02:34 <||Zero||> oke ill prove that
09:02:41 <||Zero||> then ill come back
09:02:49 <wmealing1> good luck !
09:03:42 <b1lal> can any1 here help me with a haskell problem?
09:04:47 <Axman6> b1lal: not if you don't tell us what it is first
09:04:59 <Axman6> (preferably using actual words where possible)
09:05:43 <b1lal> sorry
09:05:48 <||Zero||> one question i have to dowload and install the opengl library
09:05:50 <||Zero||> first
09:05:57 <||Zero||> i use winhugs
09:06:04 <Axman6> @where platform
09:06:05 <lambdabot> http://hackage.haskell.org/platform/
09:06:15 <Axman6> ||Zero||: go ^^^^^^^ and download the windows installer
09:06:49 <||Zero||> oke
09:07:47 <b1lal> i need to Write Haskell functions male, female :: string -> bool whch will tell the for finding out the gender for a given name which can be inferred from the title.
09:07:55 <copumpkin> ||Zero||: don't run before you can walk ;)
09:08:05 <||Zero||> yes
09:08:29 <b1lal> Cw_09> female "King Arthur"
09:08:31 <||Zero||> but my teacher aks that and i have to get it as soon as posible
09:08:37 <b1lal> false so on
09:08:51 <||Zero||> hey that windows installer is opengl library
09:08:54 <||Zero||> ???
09:09:22 <Axman6> it's the haskell platform. it has GHC, OpenGL, GLUT, cabal-install, and many other libraries
09:09:40 <Saizan_> so it won't install opengl for winhugs
09:09:53 <Saizan_> but i'm not sure if that library works on hugs
09:10:54 <||Zero||> after install that i can call the libraries in my program
09:10:56 <||Zero||> ??
09:11:03 <Saizan_> the haddock says portable
09:11:35 <Saizan_> ||Zero||: you can if you start to use ghc, the compiler that'll be installed
09:11:56 <Axman6> b1lal: do you have a list of names that are male and female?
09:12:12 <b1lal> yeh
09:12:25 <b1lal> theres a list of titles
09:12:35 <||Zero||> but with hugs
09:12:42 <||Zero||> what im thinking
09:13:18 <||Zero||> is that ill install the windows installer and theni can star to do my program
09:13:22 <||Zero||> in hugs
09:13:30 <||Zero||> with nothig else to do
09:13:34 <Saizan_> ||Zero||: with you could start from the OpenGL sources on hackage, but maybe you've it already in your winhugs installation?
09:13:37 <Axman6> you should use ghci instead of hugs
09:13:45 <Saizan_> s/with/with hugs/
09:13:55 <b1lal> should identify the gender by the titles Ms., Miss, Mrs., Lady,
09:14:01 <mauke> preflex: seen ndm
09:14:02 <preflex>  ndm was last seen on #haskell 90 days, 5 hours, 55 minutes and 45 seconds ago, saying: plus with current compiler technology, it would be slower
09:14:49 <||Zero||> oke thanks
09:15:02 <||Zero||> ill try in hugs
09:15:04 <Saizan_> ||Zero||: yeah, it seems that if you've used the installer from http://cvs.haskell.org/Hugs/pages/downloading.htm you already have OpenGL installed
09:16:08 <||Zero||> a compilador that dont have problems??
09:16:29 <copumpkin> :o
09:16:57 <b1lal> any ideas axman6
09:17:31 <Axman6> b1lal: you need to define the question better. tell us what you have to work with, some example inputs and outputs etc.
09:18:03 <mauke> b1lal: what part are you having problems with?
09:18:38 <||Zero||> thanks to everybody
09:18:43 <||Zero||> ill come back
09:18:51 <||Zero||> with my doubths
09:19:11 <||Zero||> and please if i wrute something wrong
09:19:22 <||Zero||> tell me so i can improve my english
09:19:27 <b1lal> i need to define a function male, female:: string -> bool  for finding the gender of given name for example Cw_09> female "Ms. Green" true and so on
09:19:55 <byorgey_> b1lal: is this a homework assignment?
09:20:02 <b1lal> yes
09:20:20 <mauke> b1lal: what part are you having problems with?
09:20:32 <pikhq> b1lal: We will point you in the correct direction, rather than writing the function for you.
09:20:38 <byorgey_> b1lal: if you don't even know how to start you should go ask your teacher or TA or someone like that.  we are happy to help if you are having specific problems with some code, etc. but we won't do your homework for you
09:20:44 <pikhq> Unless you've got a problem, that direction is "your textbook".
09:20:51 <b1lal> thts wht im here for
09:21:25 <byorgey_> b1lal: have you tried writing the function?  do you have some code you could paste for us to take a look at?
09:21:59 <b1lal> i dont knw where to start
09:22:09 <b1lal> im new to programming
09:22:22 <b1lal> in haskell
09:22:50 * Berengal would use a monoid
09:23:22 <copumpkin> hmm, do polymorphic variants in ocaml correspond to anything obvious in haskell?
09:23:25 <hackagebot> hack-contrib-press 0.1.2 - Hack helper that renders Press templates (BrandonBickford)
09:23:25 <pikhq> b1lal: http://catb.org/esr/faqs/smart-questions.html I cannot recommend reading this enough.
09:24:41 <quicksilver> copumpkin: they correspond to an obvious hole.
09:24:50 <copumpkin> lol
09:25:08 <mauke> (`elem`["ms.","miss","mrs.","lady"])`fmap`map(toLower)`fmap`(!!0)`fmap`words
09:25:30 <pikhq> mauke: :)
09:25:47 <quicksilver> copumpkin: although you can certainly encode fragments of them in rather verbose typeclasses
09:26:01 <quicksilver> copumpkin: possibly even all of them.
09:26:07 <copumpkin> I think I see
09:26:13 <copumpkin> do they basically represent subtyping?
09:26:15 <copumpkin> it seems like it
09:27:13 <quicksilver> a particular kind of, yes.
09:27:46 <quicksilver> it's the non-positional nature that's particularly hard to represent.
09:28:00 <quicksilver> otherwise we do, afterall, have "forall b . Either Foo b"
09:28:17 <mxc> I almost dont wnt to admit what was killing me earlier...
09:28:25 <quicksilver> but because of positionality you have to have something like
09:28:55 <mxc> basically, unsynchronized writes to a socket in the server were causing obscure failures in Binary.decode on the clients
09:28:57 <quicksilver> class HasFooAlternative a where inFoo :: Foo -> a; outFoo :: (Foo -> b) -> (a -> b) -> a
09:29:06 <quicksilver> mxc: yeeha!
09:29:18 <quicksilver> mxc: I think it's a valid criticism of Data.Binary that it makes this stuff hard to diagnose though.
09:29:41 <mxc> quicksilver: WRT to haskell, i'm still in a beggars can't be choosers mentality
09:30:21 <mxc> so i'll just say that it would be nice if dons et al. made that kind of stuff easier to diagnose
09:32:27 <mxc> anyway, i didn't choose haskell for its reputation as being well suited to n-tier, real time systems
09:32:45 <mxc> but the impurity and type system of erlang are what keep me here
09:35:05 <lilac> > (flip elem ["mr","king","lord","sir"] . map toLower . takeWhile (isLetter)) "Sir Elton John"
09:35:06 <lambdabot>   True
09:35:41 <Axman6> :t any
09:35:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:36:29 <_nickel> whats the pre-requsite knowledge for using and enjoying the Algebra of Programming
09:36:37 <lilac> @@ @type any . (==) :: @type elem
09:36:40 <lambdabot>  forall a. (Eq a) => a -> [a] -> Bool
09:37:05 <doublethink_work> _nickel: I have a copy right now, and it's kind of a tough read, but some background in logic/proofs etc will help
09:37:47 <_nickel> I have a undergrad in cs but in reading about the book that sounds insufficient
09:40:17 <timl> tiML
09:42:29 <hackagebot> network-fancy 0.1.3 - Networking support with a cleaner API (TaruKarttunen)
09:43:39 <Lemmih> Is Karttunen a common Finnish surname?
09:44:23 <Lemmih> taruti: Any relation to Einar Karttunen?
09:45:20 <taruti> yes, quite common.
09:46:21 <mxc> it says a lot about haskell that this morning I had a pretty big project but the entire thing had to run in one process and now i have a project where individual components cna be started and stopped as separate processes just with a different config file and no code changess..
09:46:34 <mxc> (given my lack of experience with haskell especially)
09:46:46 <mxc> says a lot about actors and message passing too i guess
09:47:47 <jmcarthur_work> network-fancy looks nice
09:49:39 <sm> nice, mxc
10:09:07 <c_wraith> how does ghc's garbage collector deal with fragmentation?
10:09:33 <mauke> with an IRON FIST
10:09:48 <c_wraith> good to know.  :)
10:10:36 <c_wraith> But I was more curious if it uses a copying strategy to compact used memory in its heap. :)
10:11:23 <sbahra> That would be ugly.
10:11:32 <_nickel> doublethink_work: any ideas for how I can tell if I'll be able to get something from the book?
10:11:46 <c_wraith> heap fragmentation is also ugly....
10:12:17 <Berengal> irc fragmentation :)
10:12:36 <c_wraith> haha
10:13:17 <c_wraith> Basically, we have a long-running service that occasionally will start growing rapidly.
10:13:22 <sbahra> Not as ugly as a "copying strategy" to "compact used memory". :)
10:14:01 <c_wraith> sbahra:  java is quite successful with its hybrid strategy...  It uses a copying collector for the more recent generations, and a mark & sweep collector for the old generations
10:14:08 <lilac> c_wraith: some quick googling says "parallel generational-copying garbage collector"
10:14:18 <c_wraith> Both of those involving compacting used memory via copying
10:14:32 <lilac> c_wraith: java's GC is in my experience a joke (at least for desktop apps)
10:14:33 <mauke>   -c  Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.
10:15:25 <c_wraith> But, we're not certain fragmentation is the real issue.
10:15:40 <c_wraith> We'll look into it if it turns out there isn't a horrible code problem.
10:33:07 <defun> hey, how would one make function "increment x" that keeps incrementing the Int x by 1, and never stops.
10:33:30 <mauke> you can't increment Ints
10:33:43 <defun> mauke: why not?
10:33:53 <mauke> because that doesn't make sense
10:34:05 <defun> 1 2 3 4 5
10:34:09 <mauke> you can't modify numbers
10:34:09 <hackagebot> network-fancy 0.1.4 - Networking support with a cleaner API (TaruKarttunen)
10:34:16 <defun> oh.
10:34:16 <msteele__> > iterate (+1) 1
10:34:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:34:19 <mauke> 1 := 2 what
10:35:09 <defun> so, it is only doable, through lists. That seems to work fine, thanks.
10:35:33 <defun> I had my suspicion that would be the case. :)
10:35:43 <mauke> ...
10:37:24 <ray> unsafePerformIO . putMVar
10:37:25 <ray> :)
10:38:48 <michaelfeathers> Is there a shorthand for using 'if' in anonymous functions?   \x -> if x > foo then foo else x
10:38:58 <mauke> that is the shorthand
10:39:19 <mauke> min foo
10:39:22 <michaelfeathers> Yeah, I don't recall an ternary operator.
10:39:52 <michaelfeathers> mauke: that was just an example.. the real thing doesn't reduce to min.
10:40:23 <michaelfeathers> thx.
10:40:35 <Deewiant> Define if' a b c = if a then b else c, which may help
10:41:29 <erikc> is that working with legacy code michael feathers
10:41:57 <michaelfeathers> Er, the Haskell isn't legacy, but I am the legacy guy.
10:42:06 <yrlnry> You could define (?) and (:) operators that faked up what you wanted, maybe.
10:42:14 <erikc> :) right, i like your book
10:42:16 <mauke> (:) already exists
10:42:20 <mauke> and it's a constructor
10:43:00 <Twey> @let (y ?? n) p = if p then y else n
10:43:01 <lambdabot>  Defined.
10:43:15 <michaelfeathers> erikc: Thx.  It dawned on me several years ago that the worst problems I see in legacy code can't happen (easily) in Haskell.
10:43:30 <Twey> michaelfeathers: (foo ?? x) . (> foo)
10:43:42 <lilac> michaelfeathers: give your function a name then use guards :)
10:43:55 <Twey> (or, in this specific case, (min foo))
10:44:06 <ray> ?? is a totally pointless operator
10:44:07 <lambdabot>  is a totally pointless operator
10:44:10 <ray> lol
10:44:19 <Twey> ray: I know.  It's lovely.  ^_^
10:44:25 <michaelfeathers> Twey: There's a (??) operator?
10:44:35 <Twey> michaelfeathers: There is now.  I just defined it.
10:44:49 <Twey> You can also find it in chrisdone's HigherOrder library, on Hackage.
10:44:55 <ray> it's in my prelude
10:45:01 <Twey> *nod*
10:45:17 <michaelfeathers> Ah, k, I missed the lambdabot line.
10:45:41 <lilac> > let True <?> a = return a; False <?> _ = mzero; Just a <:> _ = a; Nothing <:> a = a   in  (3 < 4) <?> "OK" <:> "The universe is falling apart!"
10:45:43 <lambdabot>   "OK"
10:45:49 <erikc> with the right precendences, you can also do something like cond !? tp !: fp
10:45:59 <Twey> lilac: *shudder*
10:46:12 <erikc> cond !? tp !: fp  ---> cond !? (tp, fp) ----> if cond then tp else fp
10:46:27 <yrlnry> lilac: Yeah, that's just what I had in mind.
10:46:29 <Saizan_> you don't need tuples or Maybe
10:46:40 <Twey> But the ‘p ? y : n’ construction is horrible.
10:47:09 <Twey> Nobody wants to curry on n, and it involves way too much type-hackery however you do it.
10:47:16 <ray> yeah, just because C does it doesn't make it good (this is a general statement that applies to more than ?:)
10:47:20 <lilac> > let if' b t e = if b then t else e in  if' (3 < 4) "OK" "Chaos, death and destruction ensue!"
10:47:21 <lambdabot>   "OK"
10:47:31 <Saizan_> > let (?) a b c = if a then b else c in (3 < 4) ? "OK" $ "The universe is falling apart"
10:47:32 <lambdabot>   "OK"
10:47:35 <Twey> I think if' is defined in \b already, isn't it?
10:47:42 <ray> > if'
10:47:43 <lambdabot>   Not in scope: `if''
10:47:44 <pikhq> ray: Corollary: just because C doesn't do it doesn't make it bad.
10:47:48 <ray> people keep defining it
10:47:48 <lilac> Twey: the <:> operator is really useful by itself
10:47:52 <Twey> ray: Well, it's okay in C, because they don't have currying anyway.
10:47:55 <erikc> Saizan_: kudos
10:48:08 <lilac> Twey: and <?> is just a guard and a >>
10:48:23 <ray> C doesn't use juxtaposition to apply functions either, and operators are all special syntax
10:48:26 <Twey> lilac: Sure
10:48:35 <ray> it works out for these reasons
10:49:09 <lilac> @let  True <?> a = return a; False <?> _ = mzero; Just a <:> _ = a; Nothing <:> a = a
10:49:10 <lambdabot>  Defined.
10:49:29 <lilac> > [1,2,3,4] >>= (\n -> even n <?> 3*n+1)
10:49:31 <lambdabot>   No instance for (GHC.Real.Integral [t])
10:49:31 <lambdabot>    arising from a use of `GHC.Real....
10:49:36 <lilac> > [1,2,3,4] >>= (\n -> even n <?> (3*n+1))
10:49:37 <lambdabot>   [7,13]
10:50:11 <pikhq> That is... Actually more useful than you would expect.
10:50:43 <lilac> > lookup 2 [(1,True),(3,False)] <:> False
10:50:45 <lambdabot>   False
10:50:46 <lilac> > lookup 3 [(1,True),(3,False)] <:> False
10:50:48 <lambdabot>   False
10:50:54 <lilac> > lookup 1 [(1,True),(3,False)] <:> False
10:50:56 <lambdabot>   True
10:51:03 <Milo-> how about pastebin?
10:51:17 <twanvl> <:> is a bad name IMO
10:51:19 <Milo-> http://moonpatio.com <- that there, for example
10:51:39 <lilac> Twey: yeah, i know. i'm open to suggestions :)
10:51:56 <michaelfeathers> I don't get it.. is <:> some sort of monadic shortcircuit 'and'?
10:52:03 <lilac> s/Twey/twanvl/
10:52:26 <lilac> michaelfeathers: <:> is flip fromJust
10:52:34 <ray> <?>? wait, you called the other operator that
10:52:45 <twanvl> I believe ghc calls it `orElse`
10:53:00 <michaelfeathers> ah, k
10:53:19 <lilac> twanvl: i quite like that. do they have a <?> equivalent?
10:55:10 <twanvl> lilac: not that I know of
10:55:47 <twanvl> it could be called  returnIf
10:56:09 <twanvl> but that doesn't work infix
10:56:30 <lilac> thenReturn?
10:57:28 <twanvl> I'm not sure you want to use that function infix
10:58:56 <lilac> one could put the condition in the middle, python-style: thing `unless` bool `orElse` fallback
10:59:29 <shachaf> Isn't (<:>) just (flip fromMaybe)?
10:59:42 <lilac> it's flip fromJust
10:59:52 <twanvl> ?type fromJust
10:59:53 <lilac> no, wait, as you were :)
10:59:53 <lambdabot> forall a. Maybe a -> a
11:00:12 <jmcarthur_work> :t (<:>)
11:00:13 <lambdabot> forall t. Maybe t -> t -> t
11:00:28 <jmcarthur_work> :t flip fromMaybe
11:00:29 <lambdabot> forall a. Maybe a -> a -> a
11:00:47 <twanvl> by the way, returnIf sounds to me like it has type  (a -> Bool) -> a -> m a, which is also a useful function
11:03:06 <mmmulani> lambdabot, help
11:03:23 <michaelfeathers> How do all of those other languages live without something as useful as intercalate?
11:03:24 <mmmulani> @def $
11:03:24 <lambdabot> Maybe you meant: bf let
11:03:31 <mmmulani> @define $
11:03:43 <mmmulani> @def map
11:03:44 <lambdabot> Maybe you meant: bf let
11:03:48 <mmmulani> @ map
11:04:02 <twanvl> ?src ($)
11:04:03 <lambdabot> f $ x = f x
11:04:14 <byorgey_> michaelfeathers: it's a sad existence indeed.
11:04:20 <twanvl> mmmulani: what are you looking for?
11:04:54 <Peaker> @type let maybe nothing just x = fromMaybe nothing (just <$> x) in maybe
11:04:56 <lambdabot> forall a a1. a -> (a1 -> a) -> Maybe a1 -> a
11:05:04 <mmmulani> twanvl: that :P
11:08:19 <lilac> michaelfeathers: python has string.join
11:08:48 <_-jn> Hello, has anyone here worked with entrycompletion in gtk2hs?
11:08:51 <Berengal> string.join should be in list...
11:08:51 <michaelfeathers> lilac:  True, I've spent  more time in the old mainstream: C++, Java, C#.
11:10:13 <Berengal> michaelfeathers: How those languages live without something as useful as lambda abstraction is a bigger mystery to me
11:12:23 <kyagrd> Berengal: python has lambda, C# has delegates
11:12:46 <pikhq> Berengal: C++0x has lambda.
11:12:49 <Peaker> Berengal: ease of learning the language, the amount of hype, and the number of useful libraries are probably the main factors in a language's adoption, and the latter 2 feed each other
11:12:53 <pikhq> (it's a hack, though)
11:13:06 <Berengal> kyagrd: I wasn't including python
11:13:29 <michaelfeathers> I notice a lot of examples with big recursive functions.. and I used to think they were big because the author was trying to make sure that all of the recursive calls are in the same function, but now I realize that with laziness, TCO isn't quite applicable, is it?
11:13:29 <Peaker> Haskell suffers from all 3, though the latter 2 are rapidly improving in Haskell. Ease of learning greatly helped by recent RWH and BONUS's, but still its a very difficult language to learn, relatively, I think
11:13:31 <Berengal> Peaker: C++ easy to learn?
11:13:44 <Peaker> Berengal: If you include horribly-styled C++, then ya
11:13:45 <doublethink_work> pikhq: don't you have to specify the environment explicitly in c++0x lambdas?
11:13:51 <Peaker> Berengal: which is the kind of C++ most people learn
11:14:07 <Twey> :t orElse
11:14:07 <Peaker> Berengal: learning enough of C++ to make something that looks like it works sometimes is easy :)
11:14:08 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
11:14:12 <kyagrd> My mistery is that people are still creating untyped (dynamically typed languages). Lisp was enough aready for that why need another dynamic language that has less powerful macro.
11:14:16 <pikhq> doublethink_work: No. You have to specify what gets bound into the closure.
11:14:20 <Peaker> Twey: is that mplus?
11:14:22 <pikhq> And whether it's a reference or not.
11:14:25 <Twey> Looks like it.
11:14:27 <doublethink_work> pikhq: ah
11:14:36 <pikhq> doublethink_work: And there's shorthand for specifying "everything".
11:14:44 <Peaker> kyagrd: I totally see why people make untyped languages
11:14:59 <Twey> @qc \a b -> orElse a b == mplus a b
11:15:00 <lambdabot> Not enough privileges
11:15:03 <Twey> :(
11:15:13 <Twey> Not enough privileges to run a quickcheck?  Eh?
11:15:13 <Peaker> kyagrd: IMO, the reason was that type classes weren't yet invented, and still aren't that widely known. Without type-classes, I'd rather have an untyped language than a statically typed one
11:15:16 <pikhq> Peaker: The main factors in language adoption are the amount of hype, the amount of useful libraries, and the amount of things written in it.
11:15:19 <kyagrd> Peaker: And they specify types when they are doing unit tests, and VM's that guess types to infer it later anyway.
11:15:21 <Berengal> kyagrd: The newer dynamic languages are created by disillusioned C(++)-family programmers who always thought lisp was something weird
11:15:25 <twanvl> ?check \a b -> orElse a b == mplus a b
11:15:26 <lambdabot>   Not in scope: `orElse'
11:15:34 <Twey> Weird.
11:15:34 <doublethink_work> Peaker: I've been reading a bit of stroustrup's book in my spare time (since we use C++ here a bit at work,) and it's very much a "there's an exception to a rule's exception EXCEPT when you do [blahblah]" language, but otherwise it is not so bad
11:15:40 <Peaker> pikhq: I think ease of learning is an important factor
11:15:58 <Peaker> doublethink_work: I think its a horrible language, but you can get started doing crappy things pretty quickly
11:16:06 <pikhq> Peaker: I would think that, but the fact is, there's very few popular languages that are easy to learn.
11:16:13 <pikhq> Let's see here...
11:16:13 <Twey> ?check let orElse = flip fromJust in \a b -> orElse a b == mplus a b
11:16:14 <lambdabot>   Occurs check: cannot construct the infinite type:
11:16:14 <lambdabot>    a = Data.Maybe.Maybe a...
11:16:17 <Twey> Gah.
11:16:18 <pikhq> Python. Python is easy to learn.
11:16:19 <Peaker> kyagrd: Unit tests are not exactly specifying "types"
11:16:29 <Twey> Lua is easy to learn.
11:16:36 <Telvistazo> Where do Negroes go when they die?  Find out the answers and debate the rammifications at Chimpout Forum!  Check it out here?  Do Negros go to heaven and hell, or do they rot like cats and dogs?  http://www.chimpout.com/forum/showthread.php?t=65552
11:16:41 <Twey> Java's pretty easy to learn, too.
11:16:43 <Nafai> One of the biggest things that really turned me off of C++ was reading Stroustrups "Design and Evolution of C++"
11:16:43 <Peaker> pikhq: C#/Java are easy to learn, in the sense that you can start churning half-working things out pretty quickly
11:16:45 --- mode: ChanServ set +o mauke
11:16:45 --- mode: mauke set +b *!*@201.171.60.178.dsl.dyn.telnor.net
11:16:51 <erikc> it's a horrible language, and any significant c++ project would be well served by splitting into a C kernel with a higher level language driver
11:16:59 <kyagrd> Peaker: They are specifying types at least, and even more say generate positive integers to test or what not.
11:17:01 <Berengal> Programming is hard in general. There's nothing a language can do to remedy that, and trying to do so is just doing programmers everywhere a disservice
11:17:07 <Nafai> I couldn't have disagreed with some of the motivations more
11:17:21 <pikhq> erikc: Oh, absolutely.
11:17:26 <doublethink_work> Peaker: there are lots of exceptions to language rules etc, which is quite bothersome, but IMO I've seen that with it you -can- get a decent level of abstraction while living with such a language
11:17:28 <Twey> Berengal: Sure, but there's a difference between spending time on a problem and spending time on the language you're using to solve that problem
11:17:33 <Peaker> kyagrd: well, they're not specifying it in a limited language that doesn't have type-classes. I don't think people are against the concept of specifying behaviors -- just against poor/weak static type systems that get in the way
11:17:38 <michaelfeathers> So, how would I factor the case for ':' out into a separate function in this code?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7986#a7986
11:17:44 <Twey> Solutions aren't supposed to introduce more problems than absolutely necessary :-P
11:17:45 <doublethink_work> Peaker: of course, the amount of work necessary for it indeed makes it fall into the "horrible language" category a lot
11:17:45 --- mode: mauke set -o mauke
11:17:47 <Peaker> kyagrd: I prefer an untyped language over one whose type system is like C#/C++
11:17:56 <Twey> I concur.
11:17:58 <pikhq> The whole idea behind C++ is "more abstractions with C". And at that point, you may as well use a proper high-level language.
11:18:15 <Twey> *nod*
11:18:17 <pikhq> Peaker: Shame that C++0x concepts are being taken out.
11:18:18 <Peaker> doublethink_work: yeah, and you're still stuck with nullable references, really crappy exceptions, constructors that cannot signal failure, no GC, etc
11:18:24 <Berengal> Twey: Sure, but I don't see how mainstream languages help in that regard
11:18:26 <kyagrd> Peaker: sure I agree languages that does not naturally support REPL is not worth.
11:18:29 <Peaker> pikhq: I like it - its putting another nail in C++'s coffin
11:18:32 <pikhq> (concepts ~= typeclasses)
11:18:35 <Twey> Berengal: They don't.  I think that was the point.
11:18:44 <Peaker> pikhq: I'd rather extend the gap between Haskell and the other languages as much as needed to make people switch :)
11:18:57 <erikc> C++ isnt particularly good at OO, and the compilation model makes it an awful mess for generic programming (all the code in headers, massive amounts of cloning, link-time elimination of duplicates)
11:19:00 <Berengal> Twey: I don't even know what we're talking about anymore :/
11:19:00 <byorgey_> michaelfeathers: just take that do block and literally move it into a definition, and then replace the do block with the name of the new function.
11:19:02 <pikhq> Peaker: So, get rid of C# monads? ;)
11:19:03 <byorgey_> michaelfeathers: is that what you mean?
11:19:05 <Twey> Berengal: Heh.
11:19:07 <doublethink_work> Peaker: there are semantics for throwing exceptions in constructors if you're talking about
11:19:12 <erikc> so what's left is the C++ is good as a syntax extension to C
11:19:37 <Peaker> pikhq: heh, monads in languages that: A) Don't have "do" notation  B) Don't have nice syntax for lambda abstractions  C) Don't have laziness   are not that useful, I don't think
11:19:38 <doublethink_work> *talking about that
11:19:49 <michaelfeathers> byorgey: I'm wondering if I should be concerned if the recursive call ends up in the extracted function.
11:19:56 <Peaker> doublethink_work: Yeah, but you don't want to use exceptions because they're like nullable types -- you can't statically restrict them at all
11:19:58 <Twey> Peaker: You'd be surprised
11:20:01 <pikhq> Peaker: C# uses monad comprehensions instead of "do". The rest are good points.
11:20:02 <doublethink_work> Peaker: I mean, I'm writing a few toy projects in C++ right now for my own fun, but I probably wouldn't start a business around C++ or anything
11:20:09 <byorgey> michaelfeathers: no, nothing to worry about.
11:20:20 <byorgey> michaelfeathers: it just means that now those two functions will be mutually recursive.
11:20:32 <Twey> Python doesn't have any of those things either, but it manages to work out okay with monads.
11:20:58 <SamB> Twey: what Python library uses monads?
11:20:59 <Twey> (thanks to first-class functions and function decorators)
11:21:08 <Berengal> Twey: Python can't dispatch on the result type of functions. That makes monads somewhat crappy
11:21:08 <kyagrd> byorgey: by the way are you not working on haskell weekly news any more?
11:21:19 <Twey> Berengal: That's true, but they still have a significant amount of uses
11:21:21 <SamB> Berengal: that hardly rules out their use ...
11:21:26 <Twey> SamB: I don't know one, alas
11:21:32 <byorgey> michaelfeathers: although if I were writing that code, I would write mainLoop inside a  StateT Buffer IO monad
11:21:48 <SamB> Twey: oh. in what sense does that count as "working out", then?
11:21:55 <byorgey> michaelfeathers: and then you could just have 'mainLoop' do a single action, and have vih call 'forever mainLoop'
11:21:55 <pikhq> http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
11:21:58 <Berengal> Twey, SamB: Using Haskell as the baseline, I don't think my observation is wrong
11:22:01 <Peaker> doublethink_work: if C++ had a sane syntax, proper exception restrictions, non-nullable pointers, GC, concepts, and gotten rid of implementation inheritance, it would become very close to Haskell, and a decent language :)
11:22:02 <byorgey> so you'd cut out the explicit recursion
11:22:03 <pikhq> Not useful, but a nice hack, at least.
11:22:10 <Peaker> well, not that close, maybe, but much closer
11:22:17 <SamB> Berengal: okay, they can be a bit awkward, yes
11:22:19 <michaelfeathers> byorgey: I'm used to thinking about tail call optimization in strict languages.. so that feels wrong.. is there a rule of thumb I can use to understand whether I am growing the stack?
11:22:26 <SamB> Berengal: but the proof is in the pudding!
11:22:27 <pikhq> Peaker: The major problem C++ has is that it's a systems programming language that pretends not to be.
11:22:33 <pikhq> :P
11:22:41 <Peaker> I wonder how BitC is
11:22:44 <SamB> so ... lets all have some pudding and maybe we'll find whether P=NP or not!
11:22:51 <Peaker> it seems to even have type-classes, or at least something similar
11:23:05 <Twey> SamB: Well, popularity /= potential utility
11:23:06 <erikc> Peaker: the lack of gc is prolly the biggest reason for C++'s popularity, it's the most power you can get without biting the gc bullet
11:23:17 <byorgey> michaelfeathers: yes, the rule is, if x calls itself recursively, is there any reason that the old x needs to continue holding on to any memory etc.?
11:23:21 <michaelfeathers> byorgey: Ah, k.  I've haven't used that yet.  Will have to give it a try.
11:23:26 <Berengal> SamB: Meh, I don't use monads in python. You can get enough hacks out of modifying object dictionaries and magic methods :P
11:23:30 <SamB> Twey: I never said it needed to be a popular library
11:23:31 <byorgey> michaelfeathers: i.e., will the old x need to continue doing any more work after the new x is finished?
11:23:39 <erikc> Peaker: bitc is dead
11:23:51 <SamB> but it would be easier to believe that they were actually useful if *someone* actually *used* them!
11:23:58 <michaelfeathers> byorgey: Thx.  Makes sense.
11:24:33 <byorgey> michaelfeathers: what you have is of course a classic case where the old call to 'mainLoop' doesn't need to do any more work, it just passes control to the new invocation of 'mainLoop'
11:25:07 <byorgey> michaelfeathers: so garbage collection will just come along behind and clean up after the old invocations of mainLoop, and bingo, O(1) memory usage.
11:25:36 <byorgey> michaelfeathers: haskell's (at least ghc's) runtime doesn't even really use a 'stack'
11:25:39 <byorgey> it's just graph reduction
11:26:26 <Peaker> erikc: really? how come?
11:26:45 <Peaker> erikc: did he stop developing it and coyotos?
11:26:47 <byorgey> kyagrd: I am still working on it.  I just skipped a week due to organizing HWN, and then skipped another week due to... being lazy. =P
11:27:00 <byorgey> kyagrd: you can expect another one out tomorrow.
11:27:01 <erikc> Peaker: yea, he went to work at microsoft research on that distributed os project they have giong
11:27:11 <byorgey> kyagrd: but in fact I will probably be looking for someone to take over for me soon.
11:27:39 <Peaker> btw, the proliferation of tons of nearly-identical languages (Python ~= Ruby ~~~= Perl, Java ~= C# ~= VB.NET) is really feeding into people's "All PL's are really the same deal, packaged differently"
11:27:52 <Peaker> erikc: oh.  And what about the guys he promised to sell Coyotos to?
11:27:57 <skorpan`> C# ~= VB.NET? what?
11:28:16 <erikc> Peaker: dunno, that's just what i read on the bitc mailing list, that bitc was effectively dead
11:28:17 <_nickel> skorpan: it all looks the same to people who don't use imperative languages
11:28:17 <pikhq> skorpan`: It's different syntax and *slightly* different semantics.
11:28:20 <Peaker> skorpan`: C# and VB.NET are really almost identical languages, with different syntax. Same semantics, except some different associations of standard names such as (==)
11:28:26 <Peaker> erikc: since when?
11:28:40 <_nickel> skorpan: its very much the same though even from my perspective
11:28:49 <doublethink_work> erikc: since shapiro moved to microsoft research to work on midori I think
11:28:57 <_nickel> skorpan: I'm a ruby programmer by trade
11:29:09 <skorpan`> _nickel: i left ruby for python
11:29:18 <erikc> Peaker: http://www.coyotos.org/pipermail/bitc-dev/2009-April/001784.html
11:29:27 <_nickel> skorpan: and I'm sure it didn't take you too long to transition
11:29:32 <skorpan`> i found ruby code difficult to read, due to its somewhat loose syntax
11:29:40 <doublethink_work> Peaker: I think it had to do with the fact that bitc may be seen as a 'competing technology', so he naturally has a no-compete agreement in his contract
11:29:45 <pikhq> _nickel: Ruby and Python are very similar. Except that Ruby makes some poor choices (IMO) compared to Python.
11:29:51 <doublethink_work> so he had to stop development
11:30:03 <skorpan`> does ruby have tail recursion elimination? :)
11:30:04 <_nickel> pikhq: lets not start that discussion here :D
11:30:21 <Peaker> When I suggest Haskell at work, people raise the "People don't know this language" as if it was the only factor worth looking at. As if a different PL can't offer inherent advantages
11:30:25 <pikhq> _nickel: I'll just say that they have similar semantics and leave it at that, then, okay?
11:30:27 <Peaker> (except which libs are available)
11:30:56 <_nickel> pikhq: entirely accurate imo
11:31:06 <Plouj> hi
11:31:06 <skorpan`> Peaker: people understanding the language at all is a pretty heavy factor imo :P
11:31:29 <Peaker> erikc: Shapiro lost a lot of points with me now.. :-P
11:31:35 <Plouj> can someone direct me to an overview explanation of why there doesn't exist a way to call C++ code from Haskell?
11:31:36 <pikhq> skorpan`: The thing is, "people knowing the language" is a terrible way of judging a language.
11:31:56 <skorpan`> they aren't judging the language, they're judging the language *choice*
11:31:57 <mauke> Plouj: it boils down to "there isn't a way to call C++ code from C++"
11:32:10 <Plouj> I know there are ABI incompatibility between different C++ compilers, but what if the C++ library has the source available and the gcc compiler is available
11:32:14 <Peaker> They think if people have to spend months studying this language before they are effective (Which I think is the case with Haskell), there's no way it would justify that with returns
11:32:14 <erikc> mauke: well put :)
11:32:16 <c_wraith> Ruby's worst design choice is actually cultural.  People treat it as acceptable to modify other code in other packages all the time.  You end up with horrible situations where when something breaks, you have no clue what package is responsible for it.
11:32:19 <pikhq> skorpan`: A sufficiently skilled programmer can reasonably learn just about any language.
11:32:50 <Plouj> mauke: how do the thousands of C++ libraries work them? After all, I hear that C++ probably has the most number of libraries available
11:32:53 <pikhq> Peaker: ... Months? Try a couple of weeks.
11:33:08 <Plouj> mauke: I'm thinking of all the game middleware in existance
11:33:09 <pikhq> (though I readily admit I'm a bit crazy when it comes to language learning)
11:33:12 <skorpan`> pikhq: but then there's the issue of having the company pay for people to learn that language. if i were a project manager, i certainly wouldn't choose haskell if a small percentage of the coders know the language.
11:33:14 <erikc> Plouj: they are all compiled with the same compiler on their respective platforms
11:33:16 <michaelfeathers> byorgey: I swear I remember that either Hugs or ghci had a switch years ago which showed you the reductions.. I kinda wish that was still around.
11:33:36 <Plouj> erikc: so, why can't the same be done with gcc and libraries compiled with gcc?
11:33:39 <Peaker> pikhq: I guess it depends on the kinds of learning resources you have.  I had learned Haskell from tutorials on the web, back about 15 months ago. It took me months of part-time learning to get effective with it.  Maybe if there's a teacher and better learning materials it can't take a much shorter time
11:33:39 <skorpan`> a couple of weeks to be efficient in haskell? get real
11:33:59 <pikhq> Peaker: I self-taught.
11:34:12 <byorgey> michaelfeathers: I doubt that Hugs or ghci had such a feature, but there are tools for showing you reductions, such as Hood or Hat
11:34:34 <Peaker> And it took me about 8-9 months for Haskell to really "click", from which point it became easy to understand anything new.  My friend, who had better learning resources took far less than that, though
11:34:46 <sbahra> pikhq, what have you done with Haskell? :-)
11:34:50 <Berengal> Peaker: It took me about a week of getting to know h98. I was still a crappy functional programmer, but I knew the /language/
11:35:00 <sbahra> pikhq, I mean, what exhibits your "effectiveness" in the language?
11:35:09 <doublethink_work> Peaker: I believe a lot in technology > politics, but unfortunately the bureaucrats tend to win a lot. I think a large class of desktop software is probably more suitable to be written in haskell, and maybe it will be sooner than we think :)
11:35:14 <erikc> Plouj: not sure I follow, to get Haskell to call C++, Haskell would know how to mangle C++ names correctly, to do that it needs to be able to expand C++ templates
11:35:17 <Peaker> Berengal: I don't mean knowing the language (syntax, basic behavior), I mean understanding how to solve real problems with it, in a way that actually justifies the language switch
11:35:35 <pikhq> sbahra: Not *that* much. The technically "non-trivial" stuff is writing parsers in Parsec.
11:35:50 <doublethink_work> Peaker: things like LYAH and RWH definitely help the push that way too :)
11:35:53 <Peaker> doublethink_work: I think if Haskell got a few pieces in the puzzle completed (e.g a working Reactive implementation), start-up companies using Haskell would simply have a huge advantage over those that don't
11:36:02 <Berengal> Peaker: The clue is to use it as a scripting language as much as possible, the hope someone else gets stuck maintaining it while you're on vacation
11:36:11 <erikc> Plouj: and that's a significant enough piece of work that the only ppl with enough vested interest in it is Microsoft with C++/CLI
11:36:20 <sbahra> pikhq, sounds like a puff of hot air to me.
11:36:25 <Peaker> Berengal: I've done that on one script, unfortunately it turns out to be a less useful script than I had hoped, though :)
11:36:28 <pikhq> sbahra: Fair enough.
11:36:33 <doublethink_work> Peaker: FRP libs (in particular, reactive) are pretty neat
11:36:45 <doublethink_work> Peaker: I've been thinking of doing some things with elerea but have been really busy with work
11:37:03 <pikhq> sbahra: My problem is convincing myself to write *anything* ATM, though.
11:37:06 <Peaker> doublethink_work: I haven't seen an FRP API I'd like to use except Reactive yet
11:37:07 <Plouj> erikc: heh, I love how Haskell came from a Microsoft lab
11:37:24 <doublethink_work> and I'm going to try to spend this weekend furiously working on GHC/OSX 64bit support
11:37:28 <Peaker> doublethink_work: Yampa seems to really over-complicate problems, and I didn't understand Elerea at a glance, but it seems somewhat imperative
11:37:57 <doublethink_work> Peaker: the elerea-examples package helps explain it a bit, but it's a bit less declarative than reactive is, yeah
11:38:04 <erikc> Plouj: im a game developer and i wish every day that middleware was wrapped under a C interface (even if it was C++ internally)
11:38:15 <Plouj> erikc: you write games in Haskell?
11:38:20 <erikc> no, in C++
11:38:23 <Plouj> humm
11:38:37 <Plouj> is Haskell your hobby?
11:38:39 <erikc> and C++ middleware causes tons of grief with binding to scripting languages :)
11:38:40 <erikc> yea
11:38:48 <Plouj> my goal is to write some games in Haskell for a hobby
11:38:54 <Peaker> I wrote a little game in Haskell. I should polish it and relase it maybe :)
11:39:14 <Makoryu> C++ needs to be put to sleep. It's bitten enough people, don't you think?
11:39:30 <Plouj> Makoryu: I vote yes please.
11:39:35 <erikc> not to mention that every single game middleware has its own set of linaer algebra types/operations, its own set of 'smart' pointers, its own resource handling semantics
11:39:43 <Plouj> I keep wanting to write games, but can't get myself to learn C++.
11:40:08 <doublethink_work> Peaker: but the basic idea behind elerea simply seems to be just setting up some input sinks, and the returned signals are Applicatives, and when you use them, they sort of 'block' until the sink is fed.
11:40:12 <Plouj> it seems more productive to learn Haskell than C++
11:40:19 <Peaker> I don't mind C++ existing out of my sight. Unfortunately, almost everywhere I work, there's a silent movement trying to push C++ to replace C, and they do have some good points working for them (RIAA is much nicer in C++, etc). I still would really prefer to keep a distance from C++ though
11:40:34 <Botje> I don't mind C++
11:40:39 <doublethink_work> Peaker: reactive is a lot lot lot more declarative however and that's an advantage
11:40:44 <Peaker> doublethink_work: so it has only discrete "signals", which are like Reactive's non-exposed Reactive values?
11:41:09 <Vanadium> RAII is even nicer than the RIAA.
11:41:50 <erikc> Plouj: my suggestion would be, write the engine kernel in C++, expose the kernel calls as C calls, write the game in Haskell
11:42:05 <doublethink_work> Peaker: yeah, the signals are attached sort of to the 'outside world' (things like mouse position, window size etc.) by creating a sink, and you basically have a driver that gets inputs and feeds them to the sink. the 'signal network' is then 'stepped forward' and the applicative values are filled
11:42:21 <Plouj> erikc: what do you mean by the engine kernel? Do you mean just using Haskell as a scripting language for "gamecode"?
11:42:30 <Peaker> doublethink_work: but do signals have a "current" value?
11:42:45 <doublethink_work> Peaker: 'current'?
11:42:52 <erikc> Plouj: yea, that might sound trite but the game code accounts for a huge amount of the code :)
11:42:57 <doublethink_work> Peaker: sorry, my FRP-fu is not so good, especially with reactive :)
11:43:00 <Peaker> doublethink_work: Like:  data Reactive a = a `Stepper` Event a
11:43:03 <Plouj> erikc: I was thinking of combining the Nexuiz engine with Haskell
11:43:12 <Peaker> doublethink_work: A Reactive is a "discretely changing value"
11:43:15 <erikc> e.g. the game Psychonauts is 150k LOC of lua, 100k of c++
11:43:28 <Plouj> humm
11:43:39 <Peaker> doublethink_work: A "Behavior a"  is a continuous changing value (or a discretely changing one)
11:43:44 <Plouj> sounds like a realistic hybrid approach
11:43:54 <Plouj> or practical
11:44:03 <doublethink_work> Peaker: ah. well, signals have a 'current' value which you get by applying them (with <*> etc since they're applicative)
11:44:11 <Plouj> that way I don't have to figure out how to write OpenGL in Haskell
11:44:19 <Peaker> doublethink_work: something like "keyboardInputs" cannot have a current value though, it may be empty
11:44:26 <Plouj> the pointer types confuse me at the moment
11:44:38 <Peaker> doublethink_work: In Reactive:  Event a   semantically means   [(Time, a)]    and    Behavior a   semantically means (Time -> a)
11:44:48 <Peaker> doublethink_work: It sounds like SIgnal a = Event a   in elerea, no?
11:45:04 <doublethink_work> Peaker: I think so, yeah.
11:45:33 <doublethink_work> Peaker: I've been meaning to go through the implementation since it's quite small but like I said, haven't got around to it
11:45:37 <Peaker> doublethink_work: I see. And when you combine them with <*> do you get sort of a zip of them, which fires when either fires?
11:45:53 <doublethink_work> Peaker: yeah, and you can force dependencies between signals etc
11:46:35 <Peaker> doublethink_work: Ah, in Reactive, if you want to get event firing when either fires, you use the Monoid.  Applicative gives you cartesian product of events, like the list its semantically emulating
11:47:18 <erikc> Plouj: even the ppl doing "100% C++" games have dialects/DSLs for game code which are effectively scripting languages (they have coroutines, gc, event systems, reflection/metadata), they just refuse to recognize they've rebuilt 80% of a scripting language
11:47:20 <doublethink_work> neat. elerea only has the applicative interface as it stands
11:47:34 <Plouj> I see
11:47:38 <doublethink_work> Peaker: I think patai g. put some work into separating the 'side-effectul' stuff from the non-effectful stuff in elerea-1.x
11:47:42 <Plouj> erikc: what game company do you work at?
11:47:55 <erikc> slant six games
11:49:37 <Plouj> ooh, Canadian
11:49:53 <kyagrd> Is there a way to program conditions that are based on GHC's type checking mechaism?
11:49:56 <Plouj> erikc: did you ever use Haskell at work?
11:50:30 <erikc> once, i wrote a relational algebra library so i could write relational queries of memory allocation/deallocation traces
11:50:54 <erikc> to do stats analysis of the heap
11:51:02 <Plouj> wow, sounds complicated
11:51:05 <erikc> unfortunately i was the only one who could use it :)
11:51:16 <erikc> very little code actually
11:51:27 <Plouj> I mean the concept
11:51:40 <Plouj> sounds like you were stuck with some hard to track memory bug?
11:51:46 <erikc> hideously hard
11:51:57 <kyagrd> I have a function f (generated by template haskell splicing) and if I am sure that it would either be (Integer, Integer) -> Integer or (Integer, Double) -> Double ... can I run somehow GHC's type checker and see which one works?
11:52:27 <erikc> needed a system where i could ask questions like 'find me any frame where there was a memory leak and list those leaks'
11:52:35 <kyagrd> One way is to use Dynamic if f is a monomorphic function. but when f is polymorphic I can't use Dynamic
11:53:05 <Plouj> oh, in deallocation traces, I see
11:53:38 <Saizan_> kyagrd: something with reify?
11:54:13 <Saizan_> kyagrd: or you could try to splice a an expression where you annotate that function with each type in turn seeing if it succeeds
11:54:15 <kyagrd> @hoogle reify
11:54:15 <lambdabot> package reify
11:54:16 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
11:54:16 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
11:54:55 <kyagrd> Saizan_: Yeah but can I do that in a program? and get the result as a Haskell boolean value or Maybe type?
11:56:13 <Saizan_> kyagrd: i think so, using recover
11:56:26 <kyagrd> @hoogle recover
11:56:26 <lambdabot> Language.Haskell.TH recover :: Q a -> Q a -> Q a
11:56:26 <lambdabot> Language.Haskell.TH.Syntax recover :: Q a -> Q a -> Q a
11:56:26 <lambdabot> Data.Generics.Aliases recoverMp :: MonadPlus m => GenericM m -> GenericM m
11:56:30 <Plouj> What! Maybe is a monad?
11:56:37 <kyagrd> Oh, ...
11:56:39 <Saizan_> it is!
11:56:53 <Plouj> is Either a monad?
11:56:55 <Saizan_> > Just 1 >>= \x -> return (x+1)
11:56:56 <lambdabot>   Just 2
11:56:56 <kyagrd> Saizan_: Thanks, I think that was what I needed
11:57:09 <kyagrd> Plouj: Maybe is of course a monad!
11:57:09 <Saizan_> Plouj: Either e is one
11:57:34 <Saizan_> Plouj: though mtl only has an instance for Error e => Either e, to cope with the fail method
11:58:02 <Plouj> kyagrd: I thought it was just an ADT
11:58:32 <Plouj> I think RWH book even showed a simple implementation of maybe
11:58:46 <kyagrd> Plouj: Monad is just a type class.  Any ADT can be defined as an instance if there is a proper meaning as a monad.
11:59:12 <Plouj> kyagrd: I thought that Monads implied side effects
11:59:18 <kyagrd> Oh, not any ADT, it should be type constructor.
11:59:23 <shachaf> Plouj: Not at all. :-)
11:59:33 <shachaf> Lists are monads also.
11:59:34 <kyagrd> Plouj: That is only ONE popular use of monad.
11:59:35 <Plouj> shachaf: ok, I'll wait till I get to the Monad chapter then :)
11:59:35 <shachaf> @instances Monad
11:59:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:59:38 <Saizan_> it depends on how you define "side effects"
11:59:52 <Saizan_> if you mean I/O or mutable state then no :)
11:59:57 <kyagrd> There is even an Identity monad :)
12:00:21 * shachaf wonders whence people get this misconception, given how common it is.
12:00:42 <Plouj> shachaf: every tutorial/book I read about haskell
12:00:57 <Plouj> in particular, RWH
12:01:05 <Saizan_> shachaf: the first monad is often IO
12:01:10 <shachaf> Plouj: Really?
12:01:21 <shachaf> Saizan_: You don't even need to use the word "monad" at that point.
12:01:45 <Saizan_> but they do! :)
12:01:46 <shachaf> Does it really say "monads imply side effects" anywhere?
12:02:40 <Saizan_> i don't think it does, but it might give that impression if monads are primarily discussed to cope with side effects
12:02:58 <Plouj> yeah, exactly
12:03:13 <Plouj> that's why there is this channel :)
12:03:15 <Saizan_> http://www.haskell.org/all_about_monads/html/index.html <- nice of overview of common monads
12:03:32 <shachaf> The first place monads are mentioned in RWH, it seems, is chapter 7.
12:03:40 <shachaf> "Monads are a powerful way of chaining functions together purely and are covered in Chapter 14, Monads. It's not necessary to understand monads in order to understand I/O."
12:03:59 <Plouj> erikc: so, would you recommend someone to learn C++ in order to get into the game industry? Would you actually recommend people who care about programming languages to get into the game industry?
12:08:12 <ksf> Plouj, please, the knive in my heart is already painful enough as it is, you don't have to turn it inside the wound.
12:09:07 <ksf> it's mostly c++ for pc and console, and java and a bit of actionscript for web stuff.
12:09:19 <kyagrd> , $(recover [| 1 + 'a' |] [| 1 + 1 |])
12:09:21 <lunabot>  2
12:09:28 <kyagrd> , $(recover [| 1 + 4 |] [| 1 + 1 |])
12:09:29 <ksf> all of which make language enthusiasts whince.
12:09:30 <lunabot>  2
12:09:44 <Plouj> ksf: I'm sorry. I didn't realize I was so violent!
12:09:45 <kyagrd> Why are they same? Is there a documentation what recover means in TH?
12:10:18 <Plouj> ksf: well, "Python" returns some jobs on major sites too, unlike "Haskell"
12:10:46 <ksf> otoh, iff you can get your team to do stuff in c and generate parts of it with, say, haskell, you might be in for a win.
12:11:10 <ksf> actually, the best way to get people to use haskell might be exactly that: a better c preprocessor.
12:11:21 <kyagrd> I've heard of some game companies using lua or python for scripting. Why not haskell then.
12:11:40 <doublethink_work> ksf: the 'write haskell code which generates other code' approach works quite well
12:11:43 <ksf> 'cos its not as easy to be sure of run-time properties.
12:11:57 <ksf> furthermore, lua is a charm.
12:12:09 <shachaf> kyagrd: qRecover :: m a -> m a -> m a -- Recover from the monadic 'fail' -- The first arg is the error handler
12:12:10 <Plouj> ksf: whats the difference between a c preprocessor and just compiling Haskell to machine binaries?
12:12:13 <ksf> it's meant to be embedded, fast, sleek and has cool semantics.
12:12:24 <ksf> Plouj, headaches.
12:12:32 <kyagrd> shachaf: but what happens when it doesnt fail?
12:12:33 <Plouj> ksf: please explain :)
12:12:40 <kyagrd> , $(recover [| 1 + 4 |] [| 1 + 1 |])
12:12:41 <lunabot>  2
12:12:42 <ksf> in game programming, you want predictability of run-time behaviour.
12:12:50 <burp> @pl \r v -> (r,v)
12:12:50 <lambdabot> (,)
12:12:55 <kyagrd> I was expecting this to be 5 but its still 2
12:12:59 <kyagrd> , $(recover [| 1 + 'a' |] [| 1 + 1 |])
12:13:01 <lunabot>  2
12:13:19 <ksf> messing around with laziness is kinda awkward if laziness can potentially spread over more than one frame.
12:13:45 <shachaf> Well, for one, something is up with lunabot.
12:13:47 <Plouj> oh really
12:13:48 <shachaf> , 1 + 'a'
12:13:49 <ksf> games aren't really rt-critical, but they're coded that way, and for a reason.
12:13:50 <lunabot>  'b'
12:13:58 <Plouj> ksf: so you're saying that haskell isn't really good for programming the game logic?
12:13:59 <burp> @pl \r v -> return (r,v)
12:13:59 <lambdabot> (return .) . (,)
12:14:01 <burp> ow, this is ugly
12:14:07 <burp> no shortcut for it? :>
12:14:23 <kyagrd> shachaf: I get the same result with my GHCi command line too
12:14:37 <burp> hm, I don't need it
12:14:38 <shachaf> kyagrd: What, 1 + 'a' = 'b'?
12:14:44 <ksf> for scripting it's a viable choice.
12:14:46 <kyagrd> , $(recover [| 1 + 'a' |] [| 1 + 1 |])
12:14:48 <lunabot>  2
12:15:03 <ksf> ...but you usually don't need such abstractive power for scripting.
12:15:11 <doublethink_work> Plouj: I think he means write the game logic in a domain specific language, and then have the DSL generate efficient code which you can then compile
12:15:12 <kyagrd> What I expected of recover is to fall back to the second if it fails to splice (because of type error)
12:15:30 <kyagrd> But when it suceeds I thought it would use the first one, but still falls back to the second.
12:15:31 <ksf> and especially lua has such a simple implementation that everyone can understand it.
12:15:34 <kyagrd> , $(recover [| 1 + 4 |] [| 1 + 1 |])
12:15:35 <lunabot>  2
12:15:44 <doublethink_work> Plouj: this has the advantage your DSL encodes a lot about your problem domain, so your generate code may be amentable to certain types of optimization which the compiler couldn't otherwise know
12:15:59 <kyagrd> recover = const ? :(
12:16:31 <ksf> it's also questionable whether it makes much sense to use a scripting language that's semantically way apart from the host language, it makes interfacing a headache
12:16:37 <kyagrd> Oh I mean ... recover = flip const
12:17:21 <Plouj> ksf: so what kind of code (its responsibility) would you generate with haskell?
12:17:55 <ksf> everything you'd usually use templates for.
12:17:58 <Plouj> just whatever seems suitable for a particular problem?
12:19:18 <ksf> would have to read up about typesafe code generation first, though.
12:19:27 <doublethink_work> Plouj: for an example of the generating code from haskell approach, I like this example: http://www.cs.utk.edu/~dongarra/cell2006/cell-slides/09-Christopher-Anand.pdf
12:19:42 <shachaf> kyagrd: Well, I know little about TH.
12:19:46 <doublethink_work> Plouj: it's about a tool called 'coconut' which generates extremely efficient C code from a high level DSL written in haskell
12:19:58 <shachaf> kyagrd: However, "-- The first arg is the error handler".
12:20:06 <doublethink_work> Plouj: the generated code is nearly 4x faster than hand-written C code in a lot of cases :)
12:20:10 <shachaf> (How does one ask lunabot for a type?)
12:20:19 <ksf> that's a way cool title page.
12:20:40 <kyagrd> , $(recover [| 1 + 1 |] [| 1 + 'a' |])
12:20:42 <lunabot>  'b'
12:20:50 <kyagrd> :(
12:21:09 <kyagrd> I'm more confused
12:22:29 <kyagrd> And, in my ghci (version 6.10.4)  $(recover [| 1 + 1 |] [| 1 + 'a' |])  is just a type error.
12:22:51 <shachaf> As I said, something is up with lunabot.
12:23:39 <Plouj> doublethink_work: wow, looks like a lot of work just to write some game :)
12:24:07 <kyagrd> shachaf: recover doesn't seem to recover from type errors, I was hoping that
12:24:11 <Plouj> need to know not just the various languages invoved, but be smart enough to reason about them together
12:24:26 <Saizan_> kyagrd: quotations are typechecked before they are passed as arguments
12:24:41 <shachaf> kyagrd: No, (and it only works for Quasi instances, and not for IO).
12:24:51 <Saizan_> kyagrd: but if you build that expression with TH constructors you'll be able to use recover
12:25:07 <Saizan_> , [| 1 + 1 |]
12:25:09 <lunabot>  InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (IntegerL 1)))
12:25:27 <Saizan_> ..maybe
12:26:36 <kyagrd> , InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (IntegerL 1)))
12:26:37 <lunabot>  luna: The section `Language.Haskell.TH.Syntax.VarE
12:26:54 <ksf> doublethink_work, sounds like it's cell-only.
12:29:08 <kyagrd> , $(recover [| 1 + 1 |] ([|(+)|]`appE`[|1|]`appE`[|Nothing|]))
12:29:09 <lunabot>  luna: No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
12:30:06 <kyagrd> , [| (+) |] `appE` [| 1 |] `appE` [| 'a' |]
12:30:07 <lunabot>  AppE (AppE (VarE +) (LitE (IntegerL 1))) (LitE (CharL 'a'))
12:30:22 <kyagrd> , $(recover [| 1 + 1 |] ([|(+)|]`appE`[|1|]`appE`[|'a'|]))
12:30:25 <lunabot>  'b'
12:30:32 <kyagrd> , [| (+) |] `appE` [| 1 |] `appE` [| Nothing |]
12:30:33 <lunabot>  AppE (AppE (VarE +) (LitE (IntegerL 1))) (ConE Nothing)
12:30:39 <kyagrd> , $(recover [| 1 + 1 |] ([|(+)|]`appE`[|1|]`appE`[|Nothing|]))
12:30:40 <lunabot>  luna: No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
12:30:45 <kyagrd> grrrrrrr ...
12:31:18 <doublethink_work> ksf: yeah
12:31:36 <doublethink_work> Plouj: but you get awesome guarantees and benefits!
12:31:39 <kyagrd> Saizan_: It doesn't work for the manually buit ExpQ either
12:32:03 <doublethink_work> Plouj: the DSL approach requires a bit of investment up front, but when done properly it can dramatically decrease development time over longer periods
12:32:21 <doublethink_work> and can end up being much more maintainable
12:33:43 <kyagrd> , $(recover [| "TH recover mystery" |] (fail "error"))
12:33:44 <Plouj> doublethink_work: wouldn't it be rather hard to debug the actual DSL implementation if you have to dig through two different layers of languages?
12:33:45 <lunabot>  "TH recover mystery"
12:33:57 <Plouj> if your code starts to segfault :)
12:34:12 <ksf> Plouj, that's not supposed to happen.
12:34:26 <doublethink_work> Plouj: what ksf said :)
12:34:30 <Plouj> heh, ok
12:34:36 <ksf> using an edsl should increase safety drastically.
12:34:42 <doublethink_work> if you structure your DSL properly you shouldn't have incorrectly generated code
12:34:54 <ksf> ...otherwise the edsl isn't worth the bytes it's made of.
12:34:58 <doublethink_work> ksf: true
12:35:04 <dino-> Also, couldn't that sort of be used as an argument to never come down out of the assembly language trees?
12:35:25 <doublethink_work> Plouj: using an embedded domain specific language also means that your DSL is actually haskell code, so it gets all the awesome haskell-typechecking benefits
12:35:39 <kyagrd> , $(recover [| "TH recover mystery" |] (LitE(IntegerL 1) `AppE` LitE(IntegerL 1))
12:35:40 <lunabot>  luna: parse error (possibly incorrect indentation)
12:35:41 <doublethink_work> Plouj: you can go a long way to use the type system to guarantee the DSL's representation/generation is correct
12:35:48 <ksf> ...and here I am, with a single core machine and a graphics card not even supporting CUDA.
12:35:50 <kyagrd> , $(recover [| "TH recover mystery" |] (LitE(IntegerL 1) `AppE` LitE(IntegerL 1)))
12:35:52 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Q
12:36:01 <kyagrd> , $(recover [| "TH recover mystery" |] (return $ LitE(IntegerL 1) `AppE` LitE(IntegerL 1)))
12:36:03 <lunabot>  luna: No instance for (GHC.Num.Num (t -> a))
12:36:22 <kyagrd> grrr ... if type error is not a failer then what does recover recover from?
12:36:24 <Plouj> doublethink_work: yeah, that sounds exciting
12:36:37 <doublethink_work> Plouj: it's a very formidable approach, but it *does* require a bit of work up-front and the payoffs may not be immediate
12:36:38 <Plouj> I hope RWH provides me with enough examples to get started
12:37:22 <ksf> i'd like such a system that spans multiple targets.
12:37:38 <Plouj> llvm?
12:38:14 <doublethink_work> llvm costs a bit in terms of memory, and the LLVM-generated bitcode is in fact platform-specific
12:38:26 <doublethink_work> but it's awesome nonetheless :)
12:38:28 <ksf> ...from cpu to gpu.
12:38:37 <Plouj> I meant generating LLVM code
12:38:48 <Plouj> and then using llvm to generate the platform-specific code
12:39:10 <Plouj> but tht probably would prevent some optimizations
12:39:53 <doublethink_work> right, the requirement though is that the LLVM bitcode must be generated on the same target (or set up to build that way from the get-go)
12:40:11 <doublethink_work> you can have LLVM bitcode and from that generate PPC or X86 asm for example, but LLVM does not take into account endianness for example
12:40:32 <doublethink_work> so the asm generated is probably completely incorrect
12:40:47 <ksf> like generating a cell version for the ps3 and a 4-core/gpu version for pc's.
12:41:04 <doublethink_work> if llvm had a gpu target that would be super-duper awesome
12:41:36 <doublethink_work> but it would require a shitload of work I imagine, especially considering the programming models just inbetween different cards is largely incompatible :)
12:41:57 <ksf> well, CUDA straigthens out most things.
12:42:21 <ksf> with my current card, I've got to use evil texture tricks to get data into and out of stuff...
12:42:28 <Saizan_> kyagrd: maybe recover doesn't do what i think it does at all..
12:43:19 <sclv> i'd be shocked if recover recovered from a type error -- there's a staging problem there...
12:43:22 <doublethink_work> ksf: I mean ATi v. nVidia, really. CUDA does go a long way if you're on an nvidia card though
12:45:02 <kyagrd> Saizan_: recover does recover from explicit call on the fail function.  But type error don't seem to be one of them strange.
12:51:12 <obk> I am told I missed a great discussion yesterday about how to enforce evaluation of a list of computations. Funnily enough, I just hit this problem today... is there an archive I could look at, or a simple hpaste-d conclusion, or something?
12:51:58 <obk> (My problem is that I create a list of results, then sort it; if I don't Debug.Trace each computation it all becomes lazy and runs out of memory)
12:52:21 <ksf> seq is your friend.
12:53:02 <obk> Ah, seq... I sure wish there was a whole chapter in RWH explaining how exactly it works :-)
12:53:21 <mux> obk: you need to use either seq or bang patterns or maybe a strict variant of your list processing function if there is one
12:53:34 <ksf> yep, we need a haskell blackbook.
12:53:48 <Nafai> blackbook?
12:54:00 <ksf> describing all that arcane black magick.
12:54:20 <obk> mux: Hmmmm - is there a strict version of "map"?
12:54:22 <ksf> ...there's a "graphics programming blackbook" around, somewhere.
12:54:27 <mux> obk: can you paste your code somewhere?
12:54:39 <mux> no there isn't
12:54:44 <mux> but you probably don't want that
12:55:04 <sclv> kyagrd: type errors happen at a different stage
12:55:27 <sclv> template haskell just generates code. the typechecking comes when compiling the generated code.
12:55:38 <sclv> you can't mix the two up.
12:55:56 <kyagrd> sclv: is there any way to do different things based on the result of wehter type check suceeds or not?
12:55:58 <raceRider> How can I change comma to a broken pipe as the delimiter here: line = sepBy cell (char ',')
12:55:58 <obk> mux: I really want that ;-)
12:56:05 <sclv> not with plain template haskell.
12:56:22 <sclv> the th stage is over and done with before the typechecker even gets a crack at it
12:56:33 <kyagrd> I've heard that one strength of TH is that it can generate intermediate expressions that is not exactly type correct and then do something else ... but how do people do it?
12:56:46 <ksf> raceRider, line = sepBy cell (char '|') ?
12:57:05 <raceRider> | is not the same as broken pipe.
12:57:20 <sclv> not sure what you mean. you can generate anything you want, but the obligation is on you to make sure it compiles.
12:57:49 <opqdonut> raceRider: you can use ascii codes
12:57:56 <opqdonut> or rather, unicode codes
12:57:59 <raceRider> ksf, that would work for pipe symbols but not char broken pipe
12:58:01 <sclv> ?hoogle rnf
12:58:01 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
12:58:04 <sclv> obk ^^
12:58:12 <raceRider> opqdonut: how to use ascii codes?
12:58:24 <ksf> well, then copy&paste what you need, or look up the ascii code and use http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html#v:chr
12:58:58 <obk> sclv: Thanks, I'll look into it
12:59:08 <kyagrd> unless I use GHC API there is no hope in general that I can use the result of type checking on ExpQ hmm ...
12:59:14 <ksf> > chr 23
12:59:15 <lambdabot>   '\ETB'
12:59:19 <ksf> > chr 42
12:59:20 <lambdabot>   '*'
12:59:21 <kyagrd> GHC API is the last hack I want deal with :(
12:59:23 <burp> @hoogle [(r,v)] -> ([r],[v])
12:59:23 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
12:59:23 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
12:59:50 <raceRider> when using char 166, which is the broken pipe, ghc complains about UTF-8
12:59:59 <ray> > unzip []
13:00:01 <lambdabot>   ([],[])
13:00:04 <ksf> > chr 166
13:00:05 <lambdabot>   '\166'
13:00:10 <ksf> hmmm
13:00:10 <ray> i'm glad that's not an error
13:00:25 <raceRider> \166 also gets the UTF-8 errors
13:00:46 <sclv> kyagrd: what is the type of 'x'?
13:00:57 <raceRider> char
13:01:11 <sclv> ah, imagine those are normal quotes -- not haskell quotes
13:01:17 <tromp_> Char even
13:01:22 <sclv> it depends if it is part of let x = (10::Int) in x
13:01:36 <sclv> or let x = "a string" in x
13:01:47 <sclv> so you can't just typecheck an arbitrary fragment and get anything meaningful.
13:02:14 <QP> is it possible to define an instance of class A for all types with instances of class B? so say instance (A a) => B a where...  ?
13:02:19 <ray> yes
13:02:25 <kyagrd> sclv: it is either Integer, Double, or array or matrix.  I only have four possiblities, and I am processing untyped script, and trying to just make sure that it is sane.
13:03:06 <sclv> kyagrd: you need to write your own system to enforce this though, is my point, because in the general case there's no way to do a "recover" that does what you want without writing a fundamentally different type system.
13:03:17 <sclv> so you can just write your own typechecker
13:03:22 <sclv> which should be simple in your case.
13:03:24 <kyagrd> So I'm just thought I would convert them into haskell using template haskell and use the type checking result ...
13:03:53 <kyagrd> But I am also buliding a haskell model for that too. to check against a real implementation.
13:04:19 <kyagrd> So, I really need a haskell type checked version of that anyway, and I want to fully autmoated it.
13:04:44 <sclv> well you write your own type checker, and then the haskell type checked version is guaranteed correct (assuming you wrote it correctly)
13:04:59 <kyagrd> The point is I don't want to write my type checker :)
13:05:32 <sclv> alternately, you write a syntax tree for your intermediate representation that enforces your typing rules.
13:05:35 <kyagrd> I think the most light (in terms of the coding amount) I think what I can do is generate a .hs file and run ghc on it and use the result of that using process or something.
13:05:43 <sclv> this is a way to write a type checker while pretending not to.
13:07:06 <SamB> sclv: and it's probably a pain ;-)
13:07:32 <SamB> mostly because of things that GADTs don't let you do, I suspect
13:11:15 <QP> can anyone tell me why I might get an 'illegal instance declaration' error for "instance (ClassA a) => ClassB a where"?
13:12:20 <kyagrd> QP: paste your source code on hpaste
13:16:14 <QP> kyagrd: ok it is up
13:16:37 <QP> 'describe' is just :: String -> IO String
13:17:46 <kyagrd> are you using ghci?
13:17:51 <QP> yes
13:18:18 <kyagrd> then error message will tell you that you need felxible instances, I believe
13:18:26 <obk> fullyEvaluate x = rnf x `seq` x -- If this was in Prelude it would have saved me quite a few days of pain...
13:18:27 <QP> yes that's right
13:18:46 <QP> why is ghci so fussy?
13:19:16 <kyagrd> hmm strange
13:19:24 <QP> it seems ok to me...
13:21:20 <Lemmih> QP: It's not portable Haskell.
13:21:41 <kyagrd> If what you want is that to be a Visible then it should be Object, then I recommend using it in the class declaration rather than instance declaration
13:22:00 <QP> no, i want every Object to be a Visible
13:22:17 <kyagrd> then
13:22:29 <kyagrd> class Visible a => Object a where
13:22:36 <kyagrd> would be the right thing to do
13:22:45 <kyagrd> @info Ord
13:22:46 <lambdabot> Ord
13:23:07 <QP> but then I have to define Visible instances before i do the Object instances!
13:23:21 <QP> I only want to have to define Object instances
13:23:32 <QP> can't i have the Visible instances for free?
13:23:44 <kyagrd> QP: Haskell class is not OO class
13:28:13 --- mode: irc.freenode.net set +o ChanServ
13:28:15 <kyagrd> As you can see from Eq and Ord you should define instances for both
13:28:15 <kyagrd> @src Ord
13:28:19 <lambdabot> class  (Eq a) => Ord a  where
13:28:19 <lambdabot>     compare      :: a -> a -> Ordering
13:28:19 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:28:19 <lambdabot>     max, min         :: a -> a -> a
15:39:50 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
15:39:50 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
15:39:50 --- names: list (clog nohluhtC michaelfeathers jsgf poh dolio blackdog randomwords alexsuraci` leino pejo rsnake bos pstickne jeffwheeler trie anji stianhj waern_ leithaus acangiano dv_ Philippa Rotaerk zenso Paczesiowa longh cytzol blastbeat1 voker57 moozilla adlan AVbd det alexsuraci Mr_Awesome angelixd al23 novas0x2a wjt tommd kniu paulvisschers_ enolan Philonous resistor_ FunctorSalad_ Infamous_Cow Pthing QP Jedai BfrOv3rfl0w_ Tobsan solidsnack Aikawa)
15:39:50 --- names: list (bgs100 obk Makoryu sdschulze c_wraith whoppix MrFahrenheit hackagebot Beelsebob noteventime themroc- Asztal Plouj Alucard_Not_Orca cying boyscared Khisanth mikm carlocci niksnut _-jn thingwath kyagrd Gracenotes Nshag ajhager mrsolo encryptio defun willb erikc tew88 ulfdoz iblechbot Peaker AndyP cods loop_ kar-1 liyang kokekola jensen_ equanimity majoh fnordus cjay stroan_ kynky caligula__ turjo doublethink_work Cale atsampson hazridi THC4k)
15:39:50 --- names: list (yango gogonkt_ mapreduce travisbrady sm mriou BCoppens Schmallon augustss_ tomh- erg0t anders^^ athos koeien phyrex1an proq ddvlad jan_ mattrepl jmelesky QplQyer_ kpreid Tsion sutats medfly Raynes kayess Apocalisp tensh dfrey rawrsy sioraiocht nathanic chris2 arjanb faXx ArneB roconnor mbz saml cheddar Trafalgard djahandarie mm_freak XGas_ jrick boscop ichor paulvisschers twanvl LeCamarade|Away Tomas ksf dancor m3ga RayNbow` hkBst MrDomino)
15:39:50 --- names: list (jleedev_ PsiOmega RayNbow kosmikus hiratar_away blackh Bleadof fooltron cognominal trofi ErhardtMundt WorkyBob mikezackles Saizan Choko Taggnostr jbauman DoubleDose bd__ Poeir mmorrow vili mercury^ jmcarthur Berengal r0bby pikhq sclv woggle otto_s intrados Ytinasni kingdj goomba stepnem master_of_master Sam___ astrocub ZelluX byorgey welterde sebas_ Ferdirand Baughn LeoD earthy mjrosenb _br_ Counter-Strike purplepenguins guerby deavid Jacolyte_)
15:39:50 --- names: list (authentic philipp_ Nereid eivind galdor araujo Dreixel_ aik__ SamB dibblego trez gbeshers sebbe1991 shapr Ycros fophillips thou Striki_ danopia gpolo gnufied CESSMASTER neurogeek||m g0ju lhnz triplez jmillikin MacMagnus jao profmakx int-e jims OnionKnight Schmidt nlogax dqd noj Rivelli` cjs jrib edwardk quicksilver Gertm olsner tltstc greap agentzh qebab jaredj_ felipe_ jfredett xinming Cthulhon Optimo wagle_home Vulpyne DarthArachides Draconx)
15:39:50 --- names: list (lambdabot BMeph|out alexbobp ChilliX yrlnry endojelly Mitar polux Igloo Botje tromp_ p_l dino- defn __marius__ kortsi Twigathy badsheepy ziman dfranke drhodes frederik BrianHV ibid raimo miasma opqdonut StarFire ahnurmi Deewiant jlaire yottis Vq vav omnihil Stephan202 edwinb thedward wli bran_ gereedy jlouis Nafai laz0r joga snhmib burp dons magicman|sleep jrockway dixie nothingmuch allbery_b osfameron michie1 SimonRC ski Lemmih PHO__ Paradox924X)
15:39:50 --- names: list (jml Rembane shepheb _janne mornfall chr1s ytshen d3z Valodim jnwhiteh icee nornagon inimino fishey daf impl Sisu karld sbok _Jordan_ Cronecker Blub\0 ToRA mlh Jiten matthew-_ ido thoughtpolice Gabbie matsuura randomity Hunner epokal koninkje_away dufflebunk kalven ottom MyCatVerbs nwf yahooooo wolverian tomaw_ jvoorhis pettter jfoutz nasloc__ dcolish tomaw` kadoban dmwit etpace eelco mike-burns saccade andrewsw-afk wgsilkie aavogt jonafan)
15:39:50 --- names: list (CalJohn koala_man fadec tessier__ webframp kapil bohanlon marmolak newsham lispy rey_ agemo jeffersonheard joed gOcOOl cmeme mmmulani otulp Jaak pragma_ spoop quarks kolmodin tonyIII Hong_MinHee malouin tra26 EvilTerran luite therp LionMadeOfLions easy4 Milo- SubStack xci ingyfoo mfp_ StoneToad takamoron msteele__ deech mml` sgwizdak Jacolyte choener idnar t orbitz nimred shachaf ahf Megant dr4wd3 ksandstr tkr J11 daed sbahra McManiaC Aisling)
15:39:50 --- names: list (suiside nominolo|uni thetallguy gbacon benmachine tarbo u_quark Gilly taruti electrogeek harlekin Ornedan Pistahh Ke Michitux smg mkfort netcat saiam glitch Badger erk fxr dumael integral lament gdsx m-i-l-a-n Armored_Azrael bjorkintosh And[y] AnMaster mgs` canvon neurocyte pcc1 mixis deiga malcolmw sjanssen xian thetallguy2 preflex JaffaCake Zao te tuukkah ath hiredman lanaer maxote aempirei gnuvince Axman6 erg peddie eno Ringo48 poucet)
15:39:50 --- names: list (ni| jvogel QtPlaty[HireMe] jajamana dcoutts_ thomastc ville Modius flux aluink regulate mrd tavelram mightybyte up_the_irons Liskni_si Shurique Vanadium cpfr dfeuer Twey @ChanServ desp sad0ur DrSyzygy ehamberg TML astrobunny epmf lilac mae dogmaT jones- Boney ray gwern nablaa Laney Anthraxx davidL arjanoosting bremner djinni hellige sunnavy mux klugez dionoea Nanar mattam ennen lunabot Raevel periodic Reiver)
15:39:50 <Peaker> Saizan: that's how I got into Haskell in the first place. I was writing a declarative infrastructure to deal with value modifications which was a bit like FRP, and hit some difficulties, and decided to look at what existing functional languages do, so I discovered Haskell
15:39:59 <SamB> mike-burns: an experienced programmer may no longer think that qualifies as "at least"
15:40:11 <Peaker> Saizan: I wanted a GUI that is declaratively associated with a model so all the updates are auto-handled/etc
15:40:34 <SamB> solidsnack: no!
15:40:38 <Peaker> Saizan: I got that part right, but failed to define the model as a function of user inputs. Then I super-admired conal for getting it at least close to right in his FRP model
15:40:51 <ray> an experienced programmer will start to wish broken programs didn't run
15:41:06 <ray> they're not looking for the satisfaction of seeing the computer do something anymore
15:41:23 <mike-burns> solidsnack: Maybe the author intended that as the difference between `foldr' and writing it out? I really have no idea.
15:41:37 <SamB> ray: exactly!
15:41:45 <ray> after about the 300th segmentation fault, they'll wish it were just not possible to dereference null pointers
15:41:49 <SamB> they want an error message as helpful, and as soon, as possible
15:42:06 <pikhq> An experienced programmer will start to wish that things didn't work because he was thinking about the problem wrong, not because of something retarded like null pointer dereferenccing.
15:42:38 <SamB> pikhq: hmm.
15:42:39 <mike-burns> ray: Totally. And that's where I suspect the "Haskell is hard" claims may come from; inexperienced programmers who don't appreciate it.
15:43:04 <SamB> pikhq: well, if he could find a language that would handle the one sort of problem but not the other ...
15:43:07 <dino-> At my last job I was trying to get my Perl co-workers interested. At one point I wrote some code in Perl and then Haskell to illustrate how monadic Maybe can do a lot of the dreary return value checking for you. With lots of comments and yada. I really need to clean that up and put on the www.
15:43:12 <pikhq> I find that ghc errors out when I've been thinking wrong, and so the types don't match.
15:44:15 <mike-burns> I think pikhq is talking about a somewhat common thing (from what I know of Haskell programmers). I too find that once the program compiles with ghc, it's probably works.
15:44:37 <c_wraith> Heh.  Your programs are too simple, then. :)
15:44:49 <mike-burns> Heh, this is probably true.
15:45:13 <pikhq> c_wraith: Yeah, but Haskell makes a lot of things quite simple.
15:45:23 <c_wraith> Nothing makes OpenID simple. :)
15:45:32 <pejo> mike-burns, Haskell is hard. I don't think that tells too much about the programmer.
15:45:32 <pikhq> Imagine writing a parser in some other language, and compare with the sheer joy that is Parsec.
15:45:36 <SamB> mike-burns: heck of a lot more likely to work than for a Python or C program
15:45:46 <SamB> programming is hard, too
15:45:52 <mike-burns> c_wraith: A library that handles OpenID for you makes it simple ...
15:45:53 <Gracenotes> ..let's go shopping
15:46:01 <SamB> it just ... doesn't hit you all at once, if you code in Python
15:46:16 <pikhq> pejo: Haskell does the easy stuff for you so you think about what's hard.
15:46:26 <jeffwheeler> pikhq: well, if you're building off libraries, Python has some pretty easy stuff, too
15:46:28 <mike-burns> pejo: Haskell is as hard as programming is hard.
15:46:40 <SamB> mike-burns: but more concentratedly hard
15:46:51 <SamB> since it takes out the filler
15:46:54 <mike-burns> Okay I see your point. And I suspect it's the one I was making too.
15:46:55 <Peaker> mike-burns: I disagree. Haskell could be significantly easier
15:46:58 <michaelfeathers> I was on a mailing list once and someone on a Ruby project was talking about using Haskell for some XML processing in his Rails application.
15:47:19 <pikhq> jeffwheeler: I don't think there's anything *quite* as nice as using parser combinators, though.
15:47:24 <SamB> michaelfeathers: did he say why?
15:47:24 <Peaker> mike-burns: for example, a specialized Haskell editor could keep code type-safe, so you never have to wrestle with unreadable (and often misleading!) error messages
15:47:25 <Gracenotes> Haskell is the premier enterprise XML-parsing language
15:47:46 <michaelfeathers> We laughed the thought of someone trying to maintain it years later not knowing what it was.  The cool thing about Haskell is that there is no chance anyone will modify it and make it run unless they understand it.
15:47:57 <SamB> Peaker: instead, I'd have to wrestle with the editor
15:47:58 <Gracenotes> oh. hah.
15:48:07 <Peaker> SamB: why do you think?
15:48:15 <michaelfeathers> SamB: He didn't say.
15:48:30 <SamB> well, I have to wrestle with something!
15:48:42 <SamB> otherwise I'm not really programming anymore, am I?
15:48:45 <Peaker> SamB: If it kept code type-safe by inserting type adapters such as   toBeImplemented :: a -> b ; toBeImplemented = error "adapting type until you fix it"
15:48:58 <kyagrd> Why people think Haskell is hard is about type checking and the Monad
15:49:02 <dino-> michaelfeathers: Interesting observation.
15:49:12 <Peaker> SamB: Yeah, but the errors you will have are about which types actually broke, rather than wrong errors based on an analysis of a whole broken program, ignoring its history
15:49:27 <Peaker> SamB: which is what ghc gives you now
15:49:35 <mike-burns> kyagrd: Ah, The Monad. Everyone has a tutorial to try to explain that it's not hard at all, which adds to the mystique.
15:49:37 <SamB> Peaker: hmm.
15:49:46 <michaelfeathers> We've had 50 years of making programming easier and look at what it's gotten us.  It's time to try the alternative.
15:49:47 <SamB> history is good
15:49:55 <mike-burns> Haha.
15:49:58 <medfly> so basically the guys here seem to be discussing a text editor which involves another Haskell programmer checking your code.
15:50:12 <SamB> but I might wish it would leave my code alone until I said otherwise
15:50:16 <kyagrd> I mean some people are just are offended about getting type errors rather than runtime erros, which I think is insane.
15:50:30 <SamB> kyagrd: yeah.
15:50:47 <Peaker> SamB: you don't like the idea of putting these adapters? What if the adapters were "invisible" and only showed as red markup on your code?
15:50:57 <mike-burns> I do Haskell outside of work because I'm sick of all the runtime errors at my job.
15:51:02 <pikhq> kyagrd: People think they'll get type errors and *then* have to hunt down runtime errors.
15:51:05 <SamB> Peaker: red would perhaps be good
15:51:42 <SamB> but if I was changing the type of some central thing, I might want to tell it to just "sit tight" and leave the code that I don't touch in the last-approved state
15:51:55 <Peaker> SamB: I think its a UI issue, and the devil is in the details and all that, but Haskell development can certainly be easier.. I like the idea of on-the-fly type-inference, on-the-fly execution of my code with some Arbitrary-like Example type-class.  on-the-fly hlint.  Haskell could be easier
15:52:00 <pejo> pikhq, I think you're oversimplifying; Haskell brings its own set of problems to your programming, they're just not the same problems as C brings.
15:52:03 <kniu> So I'm writing an interpreter.
15:52:05 <Peaker> SamB: And I think the main point from which extra ease could come is a great editor
15:52:21 <kniu> What's the most common way to do mutually recursive definitions?
15:52:25 <SamB> Peaker: but too bad for the author(s) of said editor
15:52:34 <pikhq> pejo: Which problems, aside from "You're thinking wrong!"
15:52:42 <Peaker> SamB: unless the burden of text parsing is taken away :)
15:53:09 <SamB> Peaker: that would help reduce the irrelevant headaches, yes
15:53:20 <SamB> but not eliminate all of the headaches
15:53:27 <Nafai> I also need easy navigation to definitions of functions in my editor
15:53:33 <Nafai> No matter where those functions are defined!
15:53:54 <SamB> Nafai: what if they turn out to be compiler primitives?
15:53:56 <Peaker> SamB: I really want to write that editor, what headaches do you think I'd have when I finally do?
15:54:17 <mike-burns> Peaker: Convincing people to leave emacs/vim.
15:54:22 <SamB> Peaker: what to do when some bozo starts editing the data type definition ?
15:54:32 <SamB> adding args, etc.
15:54:39 <pikhq> Peaker: Convincing people to leave 40 year old editors.
15:54:44 <SamB> replacing it with a type synonym...
15:54:59 <SamB> well, obviously convincing people to leave emacs/vim is one too
15:55:03 <erikc> the right way to do it on windows is to resurrect visual haskell
15:55:08 <erikc> which was pretty damn awesome
15:55:24 <SamB> erikc: it can't be anywhere near as awesome as what Peaker wants to do
15:55:27 <mike-burns> Oh yeah, you could target the Windows platform to reduce the emacs/vim issue.
15:55:34 <pejo> pikhq, "you're thinking wrong" is a bit of a catch-all. I can't step through my program in a sane way like I'd do in a strict language. Space leaks. Error messages from the type system are hard to understand. There's certainly a bunch of others as well.
15:55:58 <bjorkintosh> programming is too hard for programmers, it appears.
15:56:14 <SamB> bjorkintosh: yes.
15:56:18 <SamB> that's why we ALWAYS get it wrong
15:56:34 <mike-burns> It's why test-driven development has only become more popular.
15:56:41 <SamB> some versions of cat(1), true(1), and false may be bug-free
15:56:44 <kyagrd> Error messages from type system is far less harder to examine than "segmentatail fault" or "bus error" messages :)
15:56:56 <erikc> SamB: have you checked out vs2010's f# support?
15:57:01 <SamB> kyagrd: not to debug, though, necessarily
15:57:26 <SamB> erikc: no, but the things Peaker wants are things that could not possibly depend on being embedded in VS
15:57:44 <pikhq> SamB, says someone who hasn't gotten the segmentation faults a few calls deep into libc.
15:58:05 <erikc> ah
15:58:09 <SamB> pikhq: you mean him, right?
15:58:30 <SamB> anyway, half the time when you get a segfault it's because of something that went wrong much, much earlier
15:58:32 <pikhq> ... No.
15:58:43 <Nafai> SamB: Okay, except for those
15:58:51 <kyagrd> SamB: only half?
15:58:58 <SamB> pikhq: I'm saying the type error is way easier to debug than the crazy thing
15:59:16 <pikhq> SamB: And... Isn't that what kyagrd said?
15:59:27 <SamB> kyagrd: okay, I meant, there are two kinds of segfaults: the kind that happens in the bad code, and the kind where the bad code was way earlier
15:59:32 <pikhq> Well, he said "less hard".
15:59:44 <SamB> pikhq: oh!
15:59:46 <SamB> sorry
15:59:52 <SamB> his english was hard to understand
15:59:55 <SamB> ;-P
16:00:25 <kyagrd> should of said "easier" than "less harder" :)
16:00:45 <tuukkah> where does this truth arise: "Manually caching the results of a deterministic function on platforms that do it automatically (such as SQL and Haskell)" - http://sites.google.com/site/yacoset/Home/signs-that-you-re-a-bad-programmer
16:00:54 <tuukkah> "truth"
16:01:05 <sjanssen> tuukkah: that isn't actually true in Haskell
16:01:16 <tuukkah> sjanssen, exactly
16:01:17 <SamB> someone must have been misunderstanding okasaki?
16:01:17 <sjanssen> but it's a commonly repeated misconception
16:01:45 <SamB> he abuses the term "memoize" in a way that might lead people to this misconception
16:02:12 <tuukkah> the short correction would be "not caching, but calling by need"?
16:02:14 <kyagrd> I've also seen misconception that haskell by default evaluates expressions in parallel.
16:02:40 <SamB> kyagrd: well, people used to think that was a good idea, at any rate!
16:03:18 <FunctorSalad_> why is it a bad idea?
16:03:31 <pikhq> kyagrd: There's no reason for Haskell *not* to, except, of course, for the terrible performance involved.
16:03:34 <SamB> FunctorSalad_: because it's too hard
16:03:47 <FunctorSalad_> for the compiler?
16:03:51 <pejo> FunctorSalad, it's difficult to determine what is worth doing in parallel.
16:03:56 <SamB> and/or the RTS
16:03:58 <pikhq> FunctorSalad_: There's significant overhead involved in doing that for *everything*.
16:03:58 <kyagrd> FunctorSalad_: And, we are doing lazy evaluation.
16:04:10 <pikhq> And it's damn near impossible to algorithmically determine what's worth doing that for.
16:04:27 <waern_> is research.microsoft.com down for some of you?
16:04:41 <pejo> waern, works for me.
16:04:42 <FunctorSalad_> kyagrd: I thought the evaluation order was unspecified as long as the non-strict semantics hold, but I don't know this for a fact
16:04:43 <jeffwheeler> waern_: nope
16:04:44 <kyagrd> In eager evaluation, doing it in parallel may always be a win, but in lazy evaluation it is not sure at which point you would want to start it.
16:05:00 <pejo> FunctorSalad, the problem is efficiency, not preserving the semantics.
16:05:02 <FunctorSalad_> kyagrd: oh ok, misunderstood your point
16:05:25 <SamB> FunctorSalad_: yeah, sorry
16:05:33 <waern_> pejo, jeff: okay. I've been trying to access SPJ's paper about let bindings all day
16:05:52 <SamB> it's not hard to do, just hard to do and get benefit
16:06:09 <FunctorSalad_> I see
16:06:23 <thoughtpolice> FunctorSalad_: yeah, the problem is mainly that some expressions are too trivial for their computation to outweigh the actual cost of sparking a new thread and all that
16:06:32 <FunctorSalad_> but at least the easy cases are made easy by things like parMap
16:06:58 <kyagrd> @hoogle parMap
16:06:58 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:07:15 <kyagrd> @hoogle Strategy
16:07:15 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
16:07:15 <lambdabot> package StrategyLib
16:07:17 <FunctorSalad_> (to do manually I mean, of course)
16:07:27 <thoughtpolice> FunctorSalad_: but there has still been work in the area, see Tim Harris's paper "Feedback Directed Implicit Parallelism" - AFAICS, it mainly does implicit parallelism on a program, runs it, and uses the results to further guide optimization/what's worth parallelizing, a lot like profile-guided optimization in gcc/msvc etc
16:07:58 <pikhq> Ah, parMap. "Do this in parallel".
16:08:00 <pikhq> :)
16:08:48 <FunctorSalad_> thoughtpolice: nice
16:08:51 <thoughtpolice> strategies are a pretty good middle ground though - if your computations are pure you can a lot of times just add a few 'parMap' calls etc. in there as an afterthought and still get really good improvements in speed
16:09:06 <thoughtpolice> which is quite satisfying :)
16:10:34 <shapr> @quote
16:10:34 <lambdabot> Botje says: unlike bridges, tentacles work just fine in programming
16:12:37 <kyagrd> @hoogle Done
16:12:37 <lambdabot> Control.Parallel.Strategies type Done = ()
16:12:43 <kyagrd> Ah,
16:13:23 <Peaker> btw: I'm reviewing a text-diff of changes I made in a C program. its showing me every line that uses a variable I changed the name of :-(  We are so in the stone-age of software development
16:13:57 <pikhq> Peaker: And to think, we used to be in the Bronze Age.
16:14:02 <mike-burns> Well C isn't exactly representative of a modern language ...
16:14:19 <Peaker> mike-burns: but git is modern rcs
16:14:22 <FunctorSalad_> kyagrd: the strategy part is impure apparently
16:14:41 <Peaker> a non-textual editor is not enough, it needs to be accompanied by a non-textual revision control too, and on-the-fly inference, execution, etc
16:14:51 <FunctorSalad_> (clearly there's only one function into () unless you count seq)
16:14:57 <mike-burns> Peaker: So ... Smalltalk?
16:15:16 <Peaker> mike-burns: Smalltalk is still textually edited. not sure how they do rcs
16:15:35 <FunctorSalad_> (not that it would much sense to lazily evaluate the strategy after the main computation ;o)
16:15:59 <Peaker> mike-burns: in fact, Smalltalk keeps its textuality in run-time even, doing dynamic name lookups, meaning that the coed editor has no way at all to know what names would refer to what things until runtime of that particular line
16:16:32 <Peaker> (Names should be syntax for encoding source code links that form a graph, and in Smalltalk they aren't)
16:16:46 <mike-burns> True. But ENVY/Developer is better than git at some things.
16:17:06 <mike-burns> Like you check in methods, not files. But of course Smalltalk doesn't have files.
16:17:33 <mike-burns> But yes, you are correct. We need to get past all this.
16:18:02 <Peaker> a rename should be a really cheap change, like a documentation change.  or not like, exactly a documentation change
16:19:51 <pejo> Peaker, Martin Erwig is doing work in that area, but it's still in early stages. http://web.engr.oregonstate.edu/~erwig/ToSC/
16:20:38 <SamB> dons: why aren't there 2009 stats listed on http://www.cse.unsw.edu.au/~dons/irc/ ?
16:22:08 <SamB> dons: they're THERE, too!
16:30:25 <kyagrd> , [$ty| \ x -> x |]
16:30:27 <lunabot>  forall a . a -> a
16:32:28 <kyagrd> Anyone remember where was lunabot's source code? (can't find out googling)
16:34:33 <dmwit> kyagrd: ping mmorrow, I think he's the author
16:34:37 <dmwit> not totally sure of that
16:34:46 <dmwit> ?where lunabot
16:34:47 <lambdabot> http://moonpatio.com/repos/lunabot/ {- currently just the bare bot + ghc-api-eval + eval-rlimit-sandboxed-stdin->stdout (and no docs) -}
16:34:54 <dmwit> Oops, don't even need a ping. =)
16:35:19 <kyagrd> didn't know lambdabot was so smart :)
16:35:46 <kyagrd> I think I need to steel some lunabot code
16:36:01 <kyagrd> , [$th| x < y |]
16:36:02 <lunabot>  luna: Not in scope: `th'
16:36:07 <kyagrd> , [$ty| x < y |]
16:36:09 <lunabot>  Bool
16:36:24 <kyagrd> , [$ty| \ x y -> x < y |]
16:36:27 <lunabot>  forall a . Ord a => a -> a -> Bool
16:36:38 <mike-burns> "If reading this makes your eyes bleed, don't say I didn't warn you!" - a comment at the top of some of that lunabot code you need to steal
16:38:42 <kyagrd> , [$ty| x |]
16:38:44 <lunabot>  Expr
16:38:52 <kyagrd> , [$ty| x+x |]
16:38:55 <lunabot>  Expr
16:38:59 <kyagrd> , [$ty| x + x |]
16:39:02 <lunabot>  Expr
16:39:05 <kyagrd> , [$ty| x < x |]
16:39:07 <lunabot>  Bool
16:43:31 <kyagrd> , [$ty| \ x y z -> x y z |]
16:43:34 <lunabot>  forall a b c . (c -> b -> a) -> c -> b -> a
16:44:01 <kyagrd> , [$ty| \ x y z -> 1 |]
16:44:04 <lunabot>  forall a b c d . Num a => d -> c -> b -> a
16:44:22 <kyagrd> , [$ty| (\ x y z -> 1) :: Int -> Int -> Int -> Int |]
16:44:25 <lunabot>  Int -> Int -> Int -> Int
16:44:36 <kyagrd> , [$ty| (\ x y z -> 1) :: Int -> Int -> Int -> Bool |]
16:44:38 <lunabot>  luna: Exception when trying to run compile-time code:
16:46:30 <burp> I see ugly HT spam
16:49:40 * RayNbow needs a sanity check...
16:49:53 <RayNbow> is it possible for a probability density function to return a value larger than 1?
16:50:54 <dmwit> RayNbow: Sure.
16:51:28 <dolio> Isn't the dirac delta function a probability density function?
16:51:36 <dolio> And its value at a point is 'infinite' or something.
16:51:52 <RayNbow> @google dirac delta function
16:51:53 <lambdabot> http://en.wikipedia.org/wiki/Dirac_delta_function
16:51:53 <lambdabot> Title: Dirac delta function - Wikipedia, the free encyclopedia
16:51:57 <dmwit> You don't even have to go so exotic as that.
16:52:03 <stepcut> is there a word to describe Haskell data types which could (in theory) be serialized (ie, where, where, read . show == id). Types that don't have functions in them, etc.
16:52:09 <RayNbow> hmm...
16:52:09 <dmwit> What's the PDF for the uniform distribution on the range [0, 0.5]?
16:52:29 <dmwit> Easy: f(x) = 2 (except outside that range, where it's 0)
16:52:38 <dolio> Yeah, what matters is that the integral from negative to positive infinity is 1.
16:52:52 <RayNbow> I see :)
16:54:51 <kyagrd> I made ghc do the impossible thing while compiling lunabot :(
17:05:33 <gwern> stepcut: concrete data types?
17:06:33 <burp> @unpl flip . ((flip . (flip .)) .)
17:06:34 <lambdabot> (\ n b c f i -> n c f i b)
17:07:06 <dmwit> I wonder why ?unpl chose those particular variable names.
17:07:23 <mauke> n f i
17:07:24 <dmwit> They seem sort of... random.
17:07:38 <burp> @pl \f g (a,b) -> (f a, g b)
17:07:38 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
17:07:43 <burp> wowthis is horrible =)
17:07:52 <dmwit> :t (***)
17:07:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:08:00 <mauke> :t f *** g
17:08:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (SimpleReflect.FromExpr (a b c), SimpleReflect.FromExpr (a b' c'), Arrow a) => a (b, b') (c, c')
17:08:08 <burp> tell someone to unpl that by hand
17:08:29 <dmwit> :t (***) `asTypeOf` (\f g (a, b) -> (f a, g b))
17:08:30 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
17:16:56 <gwern> @check \x -> dropWhile (\=':') x ==  tail $ snd $ break (≡ ':') x
17:16:57 <lambdabot> Plugin `check' failed with: Enum.toEnum{Word8}: tag (8801) is outside of bounds (0,255)
17:17:32 <gwern> @check \x -> dropWhile (/=':') x ==  tail $ snd $ break (≡ ':') x
17:17:33 <lambdabot> Plugin `check' failed with: Enum.toEnum{Word8}: tag (8801) is outside of bounds (0,255)
17:17:51 <dmwit> Did you mean to put an equivalence sign there?
17:18:07 <dmwit> @check \x -> dropWhile (/=':') x ==  tail $ snd $ break (== ':') x
17:18:07 <gwern> oh, no. bleh
17:18:08 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:18:11 <gwern> @check \x -> dropWhile (/=':') x ==  tail $ snd $ break (== ':') x
17:18:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:18:45 <dmwit> no tail
17:19:09 <dmwit> > (dropWhile (/= ':') "abc:def", snd . break (== ':') $ "abc:def")
17:19:10 <lambdabot>   (":def",":def")
17:19:33 <mauke> @src break
17:19:34 <lambdabot> break p =  span (not . p)
17:19:38 <mauke> @src span
17:19:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:19:44 <dmwit> heh
17:19:59 <dmwit> span p = takeWhile p &&& dropWhile p
17:20:17 <mauke> :t \p -> takeWhile p &&& dropWhile p
17:20:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:20:31 <mauke> oh, right
17:20:49 <mauke> :t liftA2 (&&&) takeWhile dropWhile
17:20:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:21:51 <RayNbow> > let {g 1 r = [[r]] ; g n r = concat [map (i:) (g (n-1) r') | i <- [0..r], let r'=r-i]} in length $ g 10 3
17:21:53 <lambdabot>   220
17:22:41 <RayNbow> > let {g 1 r = [[r]] ; g n r = concat [map (i:) (g (n-1) r') | i <- [0..r], let r'=r-i]}   in   g 2 10
17:22:42 <lambdabot>   [[0,10],[1,9],[2,8],[3,7],[4,6],[5,5],[6,4],[7,3],[8,2],[9,1],[10,0]]
17:23:55 * RayNbow wonders if there's a nicer definition for g...
17:24:05 <dmwit> > let {g 0 0 = [[]] ; g 0 _ = []; g n r = concat [map (i:) (g (n-1) r') | i <- [0..r], let r'=r-i]} in g 2 10
17:24:06 <lambdabot>   [[0,10],[1,9],[2,8],[3,7],[4,6],[5,5],[6,4],[7,3],[8,2],[9,1],[10,0]]
17:24:23 <dmwit> Oh, yes, there should be a nicer definition.
17:25:32 <skorpan> "let" inside a list comprehension, wow
17:26:45 <dmwit> > let g 0 0 = [[]]; g 0 _ = []; g n r = do { x <- [0..r]; xs <- g (n-1) (r-x); return (x:xs) } in g 2 10 -- let's start this way...
17:26:46 <lambdabot>   [[0,10],[1,9],[2,8],[3,7],[4,6],[5,5],[6,4],[7,3],[8,2],[9,1],[10,0]]
17:27:54 <RayNbow> ah right... monadic do notation <3
17:28:32 <dmwit> Hmm, let's see.
17:30:54 <twanvl> [ x:xs | x <- [0..r], xs <- g (n-1) (r-x) ] -- list comprehension is better?
17:31:22 <dmwit> probably
17:33:04 <dmwit> :t filterM
17:33:05 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:35:06 <dmwit> > let g n r = filter ((r ==) . sum) . replicateM n $ [0..r] in g 2 10 -- the hideously inefficient way =)
17:35:07 <lambdabot>   [[0,10],[1,9],[2,8],[3,7],[4,6],[5,5],[6,4],[7,3],[8,2],[9,1],[10,0]]
17:36:04 <RayNbow> :D
18:00:21 <ManateeLazyCat> @src zip
18:00:21 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
18:00:21 <lambdabot> zip _      _      = []
18:02:59 <RayNbow> bah... Haskell makes you forget about time
18:03:03 <RayNbow> 3 AM already...
18:07:18 <jaredj_> question: polymorphism.
18:07:35 <blackdog> jaredj_: yes
18:07:39 <blackdog> HTH!
18:07:40 <jaredj_> i have a function that could be inferred to be of many types
18:07:48 <jaredj_> i use it as one type
18:07:58 <jaredj_> then i use it as another, and the old type sticks
18:08:01 <araujo> hello there guys
18:08:04 <araujo> what sup?
18:08:04 <jaredj_> blackdog:  :)
18:08:19 <jaredj_> stir fry for me
18:08:26 <jaredj_> it was tasty
18:08:37 <mike-burns> jaredj_: Does it work if you specify the type explicitly?
18:08:51 <jaredj_> in one case or the other
18:08:54 <jaredj_> but not both
18:09:09 <blackdog> jaredj_: pastie?
18:09:12 <jaredj_> i've already run into this once and have some functions duplicated, with the type as part of their name
18:09:17 <jaredj_> :d sec
18:09:35 <blackdog> usually it's fine - you can use map over lists of anything, for instance
18:09:52 <jaredj_> sure
18:10:41 <jaredj_> http://patch-tag.com/r/ofx1/snapshot/current/content/pretty/Text/OFX1/GradualRecord.hs
18:11:11 * blackdog started a project to let ruby talk to haskell, and it turned into a shell script. maybe took a wrong turn at albuquerque?
18:11:51 <jaredj_> look at the halfTagIsInt and halfTagIsTransactionType for an example
18:11:56 <mike-burns> blackdog: Ruby calling Haskell functions as methods?
18:12:02 <blackdog> mike-burns: yeah
18:12:20 <jaredj_> both of the times i've had this problem, i've been using higher-order functions. has that anything to do with it?
18:12:20 <blackdog> mike-burns: gotta work on the data mapping, currently it's a bit manual
18:12:25 <mike-burns> blackdog: How are you communicating between the two languages?
18:12:50 <Rotaerk> so you all mostly use vim in haskell mode?
18:13:05 <blackdog> mike-burns: C FFi
18:13:10 <mike-burns> Rotaerk: There are some emacs people in here too.
18:13:23 <mike-burns> blackdog: Ah that makes sense. Sounds both tedious and worth it.
18:13:29 <blackdog> jaredj_: you're not showing the usage of halfTagIsInt, though
18:13:35 <gwern> Rotaerk: or emacs or yi
18:13:39 <blackdog> mike-burns: it's actually embarrassingly easy atm
18:13:53 <blackdog> mike-burns: https://github.com/mwotton/Hubris/tree
18:14:04 <blackdog> of course, the downside is that you need to install jhc
18:14:09 <mike-burns> Aha.
18:14:12 <blackdog> because ghc's support for dynamic libs is not so great right now
18:14:14 <jaredj_> blackdog: see .../Text/OFX1.hs
18:14:25 <ManateeLazyCat> @let headM = liftM head
18:14:26 <lambdabot>  Defined.
18:14:31 <ManateeLazyCat> @let lastM = liftM last
18:14:32 <lambdabot>  Defined.
18:14:46 <jaredj_> blackdog: i don't know if i can summarize faster than you can just read the code
18:14:55 <blackdog> jaredj_: that's fine, i'll have a look
18:14:56 <soupdragon> :t head ?x
18:14:57 <lambdabot> forall a. (?x::[a]) => a
18:15:01 <soupdragon> :t headM ?x
18:15:02 <lambdabot> forall (m :: * -> *) a. (?x::m [a], Monad m) => m a
18:15:03 <soupdragon> :t head `fmap` ?x
18:15:05 <lambdabot> forall a (f :: * -> *). (?x::f [a], Functor f) => f a
18:15:38 <mike-burns> blackdog: "so we can write inline Haskell" - my coworkers would kill you, but I'd love this.
18:15:43 <Rotaerk> hmm hadn't heard of yi
18:15:49 <blackdog> jaredj_: yeah, i see your problem
18:15:59 <blackdog> what you can do is nail the type down at the site of usage, though
18:16:13 <blackdog> (halfTagIs :: Somefunkytype)
18:16:23 <jaredj_> erk
18:16:35 <blackdog> jaredj_: usually you get away with not doing it because in context, the type is obvious
18:16:43 <blackdog> but parsing's a bit tricky that way
18:16:51 <jaredj_> can you say "FOO" `(halfTagIs :: Somefunkytype)` (\ x s -> bla)?
18:17:18 <blackdog> jaredj_: i think so, but why ask me when you have a perfectly good interpreter? :)
18:17:22 <jaredj_> :)
18:17:26 <blackdog> mike-burns: where do you work?
18:17:28 <jaredj_> k
18:17:41 <mike-burns> blackdog: I work at a Ruby on Rails place named thoughtbot.
18:17:43 <blackdog> mike-burns: actually, if you can come up with some good use cases for me, i'd be forever grateful
18:17:59 <deech`> Hi all, does anyone know if the STM monad is evaluated lazily? For example, is readTVar only evaluated when that TVar is used, or when the function is called?
18:18:08 <mike-burns> blackdog: Use cases would probably be speed improvements. Not sure if I can think of a real one that I could use this for though ...
18:18:16 <blackdog> mike-burns: it's a chicken and egg thing
18:18:23 <blackdog> people won't use rails for things that need to be fast
18:18:34 <blackdog> but if the tough bits are isolated, it could work really nicely
18:18:51 <mike-burns> blackdog: Really it's just that Ruby isn't the slowest part of any of our apps.
18:19:27 <blackdog> mike-burns: yeah. this is the rails sweet-spot, i guess - usually it's all IO dominated
18:19:49 <soupdragon> jaredl, no that doesn't work
18:20:13 <mike-burns> Yeah. I use Haskell for all my non-Web apps/the really awesome Web apps. But I don't (yet) get paid for that, sadly.
18:20:45 <blackdog> the rationale behind allowing ruby access to haskell inline is that it's a good way to slip in the back door
18:20:55 <mike-burns> Totally.
18:20:56 <blackdog> the trojan horse approach
18:21:11 <blackdog> except that in the middle of the night, instead of killing them, we just stop them from changing their variables
18:21:19 <mike-burns> But that won't fly at my job; they'll call me out on it and make me defend it for a week.
18:21:37 <blackdog> yeah.
18:21:44 <blackdog> which is why i need a kickarse use case
18:21:58 <mike-burns> I've been trying to find one myself for a while.
18:22:31 <blackdog> the real problem is that in haskell you have to build a lot of basic functionality yourself still
18:22:44 <mike-burns> A coworker wrote some utility usage plotting functionality in Scala in his spare time to try to get Scala in, but he had to abandon that for unrelated reasons.
18:22:56 <blackdog> we're not in the position that you can have a screencast that shows how to build a kickarse web-app in three and a half minutes
18:23:06 <ManateeLazyCat> @let zip' a b = (a, b)
18:23:07 <lambdabot>  Defined.
18:23:10 <mike-burns> Yeah. I want to be, but I don't know how to get there.
18:23:12 <ManateeLazyCat> @let zipM' a b = liftM2 zip' a b
18:23:13 <lambdabot>  Defined.
18:23:32 <ManateeLazyCat> @let zipM' = liftM2 zip'
18:23:33 <lambdabot>  <local>:6:0:
18:23:33 <lambdabot>      Equations for `zipM'' have different numbers of arguments
18:23:33 <lambdabot> ...
18:23:59 <mike-burns> The next killer screencast will be the one that shows how to build a rocking mobile app in three-and-a-half minutes.
18:24:13 <ManateeLazyCat> @let zip' a b = (a, b)
18:24:14 <lambdabot>  <local>:7:0:
18:24:14 <lambdabot>      Multiple declarations of `L.zip''
18:24:14 <lambdabot>      Declared at: <local...
18:24:15 <mike-burns> I think iPwn might get us there soon.
18:24:17 <blackdog> mike-burns: mind if i pick your brain for a second? i've been trying to think of a good way of modelling data marshalling from Ruby to haskell and back
18:24:25 <ManateeLazyCat> :t zip'
18:24:26 <lambdabot> forall t t1. t -> t1 -> (t, t1)
18:24:30 <mike-burns> blackdog: I love talking about both Ruby and Haskell.
18:24:31 <ManateeLazyCat> :t zipM'
18:24:32 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => m a1 -> m a2 -> m (a1, a2)
18:25:04 <blackdog> currently thinking of mapping hashes and arrays in ruby to Yaml structures in Haskell, to avoid getting bogged down with a big unwieldy translation layer
18:26:08 <blackdog> mike-burns: oh, you're a bostonian... you know shapr, then?
18:26:34 <mike-burns> blackdog: The ideal is if `class Foo; def initialize(a,b,c);...;end;end' => `data Classes = Foo a b c'. Or something like that.
18:26:46 <ManateeLazyCat> @let applyM2 xs f g = forM xs (\x -> zipM' (f x) (g x))
18:26:46 <ManateeLazyCat>  
18:26:46 <lambdabot>  Defined.
18:26:50 <ManateeLazyCat> :t applyM2
18:26:52 <lambdabot> forall a (m :: * -> *) a1 a2. (Monad m) => [a] -> (a -> m a1) -> (a -> m a2) -> m [(a1, a2)]
18:27:01 <mike-burns> blackdog: I've met shapr and the rest of the Boston Haskell crew. Our meetups are packed!
18:27:48 <blackdog> mike-burns: you mean the instance vars of ruby, not the initialisation args, right?
18:28:24 <mike-burns> blackdog: I mean that if I write in Ruby `Foo.new(1,2,3)' it'd be awesome to have that be the same as Haskell's `Foo 1 2 3'.
18:29:13 <blackdog> mike-burns: that can't really work, because 'new' can do computation, so it's possible 'Foo.new(1,2,3)' should map to 'Foo 2 4 6'
18:29:18 <mike-burns> But that may be way too complicated to implement. And I'm not sure how inheritence, and especially mixins, would play into this.
18:29:28 <blackdog> yeah, exactly. i'm thinking 80
18:29:29 <mike-burns> Oh damn, you're right.
18:29:33 <blackdog> % solution is the way to go
18:30:04 <blackdog> a certain amount of dicking around is ok - it only needs to be more pleasant than dropping down to C
18:30:04 <mike-burns> Are you concentrating on Ruby -> Haskell or Haskell -> Ruby?
18:30:08 <blackdog> pretty low bar
18:30:12 <blackdog> Ruby calling Haskell
18:30:16 <mike-burns> Okay.
18:30:28 <blackdog> doesn't seem any point going the other way. we all know that haskell can do anything, right?
18:30:40 <mike-burns> @faq Can Haskell call Ruby?
18:30:40 <lambdabot> The answer is: Yes! Haskell can do that.
18:30:48 <blackdog> heh, i knew someone would do that
18:31:15 <blackdog> @faq can Haskell build dynamic libraries callable by C?
18:31:15 <lambdabot> The answer is: Yes! Haskell can do that.
18:31:18 <blackdog> FILTHY LIES
18:32:00 <mike-burns> The hsload.rb sample you provide is great, but you're wondering about passing something besides a number to a Haskell function.
18:32:38 <mike-burns> The other thing to worry about is that all classes are open. So an instance of Hash might be modified from the one that comes with Ruby, in unexpected ways.
18:33:06 <mike-burns> Also instances are open too, so just because obj.is_a?(Hash) doesn't mean that it quacks like one anymore.
18:33:53 <mike-burns> OTOH if someone's willing to call Haskell from Ruby, they're willing to promise not to modify Hash.
18:34:31 <mike-burns> You could provide HsHash, HsArray, HsObject, and know how to marshall those.
18:35:28 <mike-burns> Hm you just reconnected. I wonder if you saw the stuff I was blabbering about.
18:35:59 <blackdog_> yeah, wifi dropped out
18:36:07 <blackdog_> i think the cafe's trying to get rid of me:)
18:36:13 <blackdog_> but i can see it in the logs
18:36:37 <mike-burns> HaskyPants.sum_hs(HsArray([1,2,3]))
18:36:51 <blackdog_> basically, i'm thinking of serialising ruby structures somehowe
18:36:59 <blackdog_> i won't be calling back into ruby to eval stuff
18:37:31 <blackdog_> won't be taking advantage of haskell laziness, either - just calling functions written in Haskell as if they're from C
18:37:37 <mike-burns> In Rails we serialize Ruby into JSON to pass over the wire. ActiveResource can turn any ActiveRecord-serialized JSON into a Ruby object.
18:38:11 <blackdog_> mike-burns: yep. i'm hoping to be able to use an in-memory rep, though, to avoid dumping and reparsing
18:38:19 <blackdog_> something like Syck might work
18:38:54 <mike-burns> That's a YAML dumper/parser though?
18:39:03 <blackdog_> anyway, think i'm gonna bail, i feel a bit bad about taking up a space in the cafe in the busy time
18:39:06 <blackdog_> yeah
18:39:09 <mike-burns> Okay happy hacking!
18:39:22 <blackdog_> a JSON equivalent would work, but it's allbehind the scenes anyway so it doesn't much matter
18:39:27 <mike-burns> Right.
18:39:58 <mike-burns> I think you can serialize most objects to JSON/YAML. But not Proc objects.
18:42:21 <Saizan_> a function to escape an haskell String to use it in an SQL INSERT query?
18:44:43 <soupdragon> How do you do 3D character animation on Haskell?
18:45:08 <mike-burns> Saizan_: HDBC has safeFromSql
18:45:51 <mike-burns> Does anyone have an example of a DND source in gtk2hs? Or can point me to a tutorial or really slim example online?
18:46:26 <jaredj_> blackdog_: aha!
18:46:38 <jaredj_> blackdog_: i wrote the type for my parseResultIs well enough to get the right error
18:46:55 <jaredj_> [...]    Possible cause: the monomorphism restriction applied to the following: [...]
18:50:50 <kniu> @hoogle fix
18:50:51 <lambdabot> Data.Function fix :: (a -> a) -> a
18:50:51 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:50:51 <lambdabot> module Control.Monad.Fix
18:51:40 <jaredj_> > fix (\x -> 1-x)
18:51:45 <lambdabot>   mueval-core: Prelude.read: no parse
18:51:45 <lambdabot>  mueval: ExitFailure 1
18:52:29 <hackagebot> dyre 0.7 - Dynamic reconfiguration in Haskell (WillDonnelly)
18:53:10 <blackdog> jaredj_: nice :)
18:53:24 <jaredj_> how big a deal is -XNoMonomorphismRestriction?
18:53:28 <blackdog> now you just need to chuck the no monomorphism thing on
18:53:31 <blackdog> do it
18:53:44 <blackdog> widely regarded as a misfeature in the first place
18:53:58 <jaredj_> but does it impose a requirement on users of my library?
18:54:06 <dmwit> No.
18:54:31 <dmwit> It is wholly equivalent to providing top-level type signatures for each of your values.
18:54:59 <blackdog> mike-burns: yeah, i'm thinking concrete values only
18:56:15 <jaredj_> do i do it with {- -} or in my .cabal file or what?
18:56:31 <dmwit> {-# LANGUAGE #-} is pretty standard
18:57:29 <kniu> @src fix
18:57:30 <lambdabot> fix f = let x = f x in x
18:58:06 <mike-burns> blackdog: The more you hide behind the scenes the better. It could be XML for all I care so long as my Haskell code gets a list and my Ruby code passes an Array.
18:58:38 <soupdragon> XML!!!
18:58:55 <blackdog> mike-burns: well, you might get a JSONArray [a] or something similar
18:59:09 <blackdog> you ok with pattern-matching a tag?
18:59:15 <mike-burns> Okay I can deal with that.
18:59:54 <blackdog> soupdragon: pipe down at the back there, mister purist
19:00:32 <mike-burns> sum_hs (JSONArray xs) = sum xs    -- like this?
19:00:40 <blackdog> exactly
19:00:50 <mike-burns> Yeah I could definitely deal with that.
19:06:57 <dufflebunk> Anyone have a version of ghc 6.10 for redhat 4?
19:07:53 <dufflebunk> nm, I'll ask in #ghc
19:08:01 <jaredj_> arhg
19:08:25 <dmwit> dufflebunk: Uh, I guess the first place to look would be the binary distro on haskell.org.
19:08:31 <dmwit> I'm going to assume you already went there...?
19:08:44 <dufflebunk> dmwit: Yeah, the libc on rh4 is too old.
19:08:58 <mmorrow> dufflebunk: so none of the bindists worked i take it? i had to use ghc-6.4 to build a 6.8 then build a 6.10 with that on this one hosted centOS machine before
19:09:20 <mmorrow> (i got the ghc-6.4 from yum)
19:09:26 <dufflebunk> mmorrow: I may have to do that too. I'm hoping to avoid it.
19:09:58 <mmorrow> good luck :)
19:10:08 <kniu> :t fix fix
19:10:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
19:10:09 <lambdabot>     Probable cause: `fix' is applied to too many arguments
19:10:09 <lambdabot>     In the first argument of `fix', namely `fix'
19:10:32 <jaredj_> ftfy
19:12:07 <ray> :k Mu
19:12:09 <lambdabot> (* -> *) -> *
19:12:16 <ray> there's your type-level fix
19:18:38 <jaredj_> @djinn GenParser t () a -> GenParser t b ()
19:18:39 <lambdabot> Error: Undefined type GenParser
19:19:05 <soupdragon> :t fix . In
19:19:06 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `Mu f'
19:19:06 <lambdabot>     In the second argument of `(.)', namely `In'
19:19:06 <lambdabot>     In the expression: fix . In
19:19:09 <soupdragon> :t fix In
19:19:10 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
19:19:11 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
19:19:11 <lambdabot>       Expected type: f (Mu f)
19:19:13 <soupdragon> :t In . fix
19:19:15 <lambdabot> forall (f :: * -> *). (f (Mu f) -> f (Mu f)) -> Mu f
19:19:22 <soupdragon> :t fix (In . fix)
19:19:23 <lambdabot>     Couldn't match expected type `f (Mu f) -> f (Mu f)'
19:19:23 <lambdabot>            against inferred type `Mu f'
19:19:23 <lambdabot>     In the first argument of `fix', namely `(In . fix)'
19:19:36 <soupdragon> :t (In . fix) id
19:19:37 <lambdabot> forall (f :: * -> *). Mu f
19:19:45 <soupdragon> no ..
19:21:16 * jaredj_ 's head implodes
19:23:56 <sm> hi jaredj_
19:24:29 <ray> what to do when people are talking about Mu and your head is imploding
19:24:43 <ray> not even talking i guess, just lambdabotting
19:25:13 <sm> and people complain about hackagebot spam...
19:25:28 <mmorrow> @type \f -> out (fix (In . f . out))
19:25:29 <lambdabot> forall (f :: * -> *). (f (Mu f) -> f (Mu f)) -> f (Mu f)
19:26:03 <mmorrow> @type \f -> fix (In . f . out)
19:26:04 <lambdabot> forall (f :: * -> *). (f (Mu f) -> f (Mu f)) -> Mu f
19:26:49 <mmorrow> @pl \f -> fix (In . f . out)
19:26:50 <lambdabot> fix . (In .) . (. out)
19:28:43 <pikhq> Mu makes my head hurt. Also kinds.
19:28:51 <ray> what module is lambdabot getting Mu from
19:29:23 <mauke> @src Mu
19:29:24 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:30:03 * mmorrow likes Mu f = Mu (f (Mu f)); inn = Mu; out (Mu f) = f
19:30:15 <ray> yeah, just wondering if it's in some package
19:30:22 <mauke> @index Mu
19:30:22 <lambdabot> bzzt
19:30:30 <ray> i have too many random .hs files
19:30:30 <mauke> @hoogle Mu
19:30:31 <lambdabot> package mueval
19:30:31 <lambdabot> Distribution.Simple.Command multiOption :: Name -> get -> set -> [get -> set -> OptDescr a] -> OptionField a
19:30:31 <lambdabot> Distribution.Extension MultiParamTypeClasses :: Extension
19:30:58 <mmorrow> ray: http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/Mu.hs
19:31:08 <mmorrow> that module has Eq,Ord,Read,Show for Mu as well
19:31:19 <ray> mmorrow: i think i prefer the recordy version, even if it's just renaming Mu the constructor to In
19:31:39 <ray> maybe if it stops making my head explode i'll prefer it the other way
19:31:51 <mmorrow> ray: i like the Mu-as-con version because then there's symmetry between inn/out
19:32:21 <dancor> what does mu du
19:32:47 <mmorrow> , muT [0..3]
19:32:49 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
19:33:16 <ray> i'll just darcs get lunabot, it's probably useful
19:33:31 <Axman6> what is Mu anyway?
19:33:31 <mmorrow> random Mu stuff in http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/T.hs
19:33:54 <mmorrow> ray: be warned that the stuff in Luna/Bot/Lib is disorganized atm
19:34:18 <dmwit> Axman6: Mu is type-level recursion.
19:34:43 <mmorrow> ray: although i've actually got that cleaned up locally.. but i've got to remove a failed attempt at per-user-@let from my local repo before i can push
19:35:14 <ray> sounds like it sounded like a good idea at the time
19:35:20 <pikhq> Mah head asploded.
19:35:23 <mmorrow> heh
19:35:36 <mmorrow> ray: it actually does work, but ", 42" takes 4.5 seconds..
19:35:46 <dmwit> Axman6: For example, if (type ListF f a = Either () (a, f a)), then type List a = Mu ListF a.
19:35:50 <dmwit> :k Mu
19:35:52 <lambdabot> (* -> *) -> *
19:36:07 <ray> if it's only 4.5 seconds it might not be so bad
19:36:07 <ray> :)
19:36:11 <dmwit> Whoops, didn't quite get that right.
19:36:26 <ray> unless it gets exponentially slower for real expressions or something
19:36:37 <mmorrow> ray: no, just a constant hit
19:36:46 <mmorrow> ray: yeah, true. maybe it is worth it
19:36:59 <mmorrow> ray: (you can @let datatype, classes, instances too)
19:37:15 <Rotaerk> hmm how's SHIM?
19:37:35 <mmorrow> ray: hmm, maybe i'll make two different repos.
19:37:41 <dmwit> type ListF a f = Either () (a, f a); type List a = Mu (ListF a) -- maybe this is closer to correct
19:38:09 <dmwit> ack, no, I obviously don't understand fixpoints
19:39:00 <mmorrow> data List a x = Nil | Cons a x
19:39:06 <mmorrow> err
19:39:10 <mmorrow> data L a x = Nil | Cons a x
19:39:17 <mmorrow> type List a = Mu (L a)
19:39:56 <dmwit> thanks =)
19:40:09 <ray> mmorrow: a constant hit doesn't sound too bad
19:40:24 <mmorrow> dmwit: that's stolen from "evolution of a haskell programmer"
19:40:49 <dmwit> Also, (Either ()) is really just a lame name for Maybe.
19:40:58 <dmwit> Maybe I had better get some sleep.
19:41:19 <ray> evolution of a haskell programmer was where i first saw Mu
19:41:57 <Axman6> mmorrow: so what's type List a = Mu (L a) saying?
19:42:49 <dmwit> It's the usual list type. =)
19:42:50 <pikhq> Axman6: Read "Mu" as "fix" and it sorta makes senses.
19:43:18 <pikhq> Yes, your head should be asploding.
19:43:21 <ray> it's on the type level, so there's extra constructors from what it would be on the value level, but yeah
19:43:49 <dmwit> It's the smallest type that satisfies (t = L a t), that is, (L a (L a (L a (L a ...)))).
19:43:57 <Axman6> ah, so it's be Mu (L a) -> L a (Mu (L a)) -> L a (Mu (L a (Mu (L a))) ->...
19:44:05 <dmwit> Right!
19:44:10 <Axman6> interesting
19:44:23 <Axman6> so, that means that list has to be infinite?
19:44:25 <Axman6> maybe not...
19:44:29 <dmwit> No.
19:44:30 <ray> nope
19:44:32 <dmwit> Only the type is infinite.
19:44:33 <ray> stops at Nil
19:44:36 <dmwit> The values can be finite.
19:44:41 <Axman6> how interesting
19:44:47 <ray> the same way fix can stop
19:44:49 <dmwit> If you leave out the Nil, then you're playing with fire.
19:44:51 <Axman6> :k Mu
19:44:52 <lambdabot> (* -> *) -> *
19:45:06 <dmwit> You're taking advantage of Haskell's Mu = Nu thing. =)
19:45:06 <ray> ^^ looks strangely similar to :t fix
19:45:16 <Axman6> indeed
19:45:19 <mmorrow> Axman6: http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/Mu.hs
19:45:24 * Axman6 doesn't think it's strange at all thlugh ;)
19:45:43 <mmorrow> Axman6: that module has that L/List type (stolen almost verbatim from "evolution of a haskell programmer")
19:45:51 <Axman6> heh
19:45:58 <mmorrow> fromL = cata (unL [] (:))
19:45:58 <mmorrow> toL   = ana (list Nil Cons)
19:46:10 <mmorrow> fromL :: List a -> [a]
19:46:19 <mmorrow> toL :: [a] -> List a
19:46:32 <mmorrow> , toL [0..3]
19:46:34 <lunabot>  Mu (Cons 0 (Mu (Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu Nil))))))))
19:46:41 <mmorrow> , fromL (toL [0..3])
19:46:44 <lunabot>  [0,1,2,3]
19:50:09 <byorgey> yay type-level fixpoint!
19:51:40 <Axman6> , toL [1..]
19:51:42 <lunabot>  Mu (Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu (Cons 4 (Mu (Cons 5 (Mu (Cons 6 (M...
19:52:08 <pikhq> , toL [1..3]
19:52:10 <lunabot>  Mu (Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu Nil))))))
19:52:25 <pikhq> Mmm, type-level recursion.
19:52:26 <Axman6> , out . toL $ [1..]
19:52:28 <lunabot>  Cons 1 (Mu (Cons 2 (Mu (Cons 3 (Mu (Cons 4 (Mu (Cons 5 (Mu (Cons 6 (Mu (C...
19:52:54 <pikhq> Now, is there a type-level "map"? :P
19:53:31 <ray> well, there's a Functor instance
19:54:11 <Axman6> , muT' [1..5]
19:54:13 <lunabot>  Mu (T (Mu (T (Mu (Tip 1)) (Mu (Tip 2)))) (Mu (T (Mu (Tip 5)) (Mu (T (Mu (...
19:54:20 <Axman6> binary tree?
19:54:49 <ray> yes
19:55:00 <mmorrow> yeah, a perfect binary tree
19:57:05 <mmorrow> , ppDoc <$> foldT [|0|] (\a b -> [|($a,$b)|]) (mapMuT lift (muT [0..7])) id
19:57:07 <lunabot>  (((0, 1), (2, 3)), ((4, 5), (6, 7)))
19:57:38 <mmorrow> (TH to avoid the infinite type since (,) isn't' recursively defined)
19:57:58 <mmorrow> , $(foldT [|0|] (\a b -> [|($a,$b)|]) (mapMuT lift (muT [0..7])) id)
19:57:59 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
19:58:11 <mmorrow> , $(foldT [|0::Int|] (\a b -> [|($a,$b)|]) (mapMuT lift (muT [0..(7::Int)])) id)
19:58:13 <lunabot>  (((0,1),(2,3)),((4,5),(6,7)))
19:58:44 <mmorrow> , let t = $(foldT [|0::Int|] (\a b -> [|($a,$b)|]) (mapMuT lift (muT [0..(7::Int)])) id) in (snd . fst . snd) t
19:58:46 <lunabot>  5
20:02:16 <pikhq> Ma head asploded.
20:05:59 <ray> just a lot of stuff in there, but it's conceptually not too complicated
20:06:05 <dufflebunk> whee, ghc 6.10.4 stage1 ghc built on rh4
20:06:40 <mmorrow> dufflebunk: yay, what version did you end up having to start at?
20:07:38 <dufflebunk> 6.8 binaries worked on rh 4.6.
20:07:44 <mmorrow> ah nice
20:09:52 <dufflebunk> now to continue with my cunning plan of getting HAskell into my work place.
20:11:15 <mmorrow> heh
20:17:18 <kyagrd> happy hacking weekend ~!
20:18:18 <kyagrd> Is there an GHC option to run the type checker only?
20:18:18 <|zzz|> anyone know some good general programming IRC channels?
20:18:46 <kyagrd> |zzz|: arn't you arealdy in one of them?
20:18:59 <|zzz|> kyagrd: i mean general programming
20:19:03 <mike-burns> We're definitely not general, though I don't know if a general one could even exist.
20:19:11 <ray> it would degenerate
20:19:14 <|zzz|> like you can come in and ask a question about c, or java, or haskell
20:19:18 <ray> fire and brimstone
20:19:44 <dmwit> kyagrd: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id470545
20:19:47 <shachaf> |zzz|: If it's not Haskell, it's not programming! Heathen!
20:19:48 <dmwit> kyagrd: looks like no
20:20:04 <|zzz|> why is it that a general one cannot exist?
20:20:11 <kyagrd> Yeah I've seen the document and just wondering if there's any undocumented stuff
20:20:36 <dmwit> The documentation is pretty complete, in my experience.
20:20:47 <shachaf> |zzz|: In theory #haskell-blah almost covers it, but probably not in practice.
20:20:58 <mike-burns> |zzz|: We, as a culture, enjoy specialization, and argue about subjective topics. The channel would be nothing but fighting.
20:22:04 <heatsink> |zzz|, you can try #cs if you want to talk about programming topics that are unrelated to a programming language.
20:22:16 <|zzz|> that's not really true is it; there's stackoverflow.com which is any programming questions
20:22:47 <mike-burns> StackOverflow.com is not a bunch of people talking.
20:22:51 <kyagrd> There's less than 10 people in #cs :)
20:22:54 <shachaf> heatsink: CS and programming are hardly the same thing. :-)
20:23:23 <heatsink> shachaf, well... if you take the programming language out of programming, what are you left with?
20:23:34 <dmwit> There is, incidentally, a #programming.
20:23:36 <shachaf> The VM. :-)
20:23:51 <mike-burns> heatsink: The culture and community.
20:23:57 <shachaf> Libraries, the computer.
20:23:59 <dmwit> err, ##programming
20:25:26 <pikhq> heatsink: Math.
20:25:50 <heatsink> mike-burns, it seems to me that each programming language has its own culture and community, with some common membership.
20:25:51 <pikhq> The programming language is nothing more than notation for mathematics.
20:26:01 <|zzz|> not that many people on #programming
20:26:30 <mike-burns> heatsink: This is true, and is why there can't be a general purpose programming channel.
20:27:01 * Axman6 is hearing some very bad stuff about #c
20:27:20 <heatsink> I think it's ##c
20:27:35 <Axman6> well, that too
20:27:42 <|zzz|> ##c "you're banned from that channel"?
20:27:49 * BMeph is amused that GHC, coming from Glasgow, follows the old meme, "If it ain't Scottish,..."
20:28:52 <|zzz|> is there a list of the most popular programming irc channels?
20:29:04 <dmwit> Yes.
20:29:06 <dmwit> Next question!
20:29:25 <mike-burns> Can you demonstrate this?
20:29:25 <|zzz|> please elaborate
20:29:49 <dmwit> http://www.livinginternet.com/r/ru_list.htm
20:29:51 <heatsink> I got an unfriendly and unhelpful response when I asked a question in ##c.
20:30:24 <|zzz|> hmm i can't even get in ##c
20:30:58 <dmwit> |zzz|: Looks like you're using a web gateway.
20:31:00 <mauke> *!*@gateway/*
20:31:08 <dmwit> Likely a troll long ago used the same gateway.
20:31:40 <|zzz|> but i'm not banned off wikipedia, or anything
20:31:49 <ray> they ban all gateways
20:32:06 <BMeph> ray: What about Dell? ;p
20:32:06 <dmwit> ...because you're not using a web gateway for Wikipedia, presumably...
20:32:24 * dmwit has trouble imagining what such a thing would even mean
20:32:35 <dmwit> Like... a proxy... but with a web browser in your browser...
20:32:35 <ray> wikipedia to irc gateway
20:33:26 <mauke> the free irc channel anyone can edit
20:33:30 <gwern> ray: you laugh, but we do provide that
20:33:40 <pikhq> ##c is an uncouth place, and it does not make me feel any more confident about the common usage of C.
20:34:07 <ray> i mean irc to wikipedia gateway, of course
20:34:09 <dmwit> I dunno.  The times I've been in ##c, ##c++, and ##java, they've been helpful enough.
20:34:30 <mauke> I forget which #java was the troll channel
20:34:32 <gwern> ray: actually...we may provide that via the antivandalism channels & bots
20:34:41 <mike-burns> #haskell is probably the most friendly programming channel. My sample data is not nearly large enough for me to convince anyone of this.
20:35:09 <shachaf> #haskell is probably the most friendly Haskell programming channel.
20:35:36 <ray> Haskell is probably the most friendly programming language discussed on irc
20:35:39 <dancor> it's certainly the most modest
20:35:42 <pikhq> #haskell is at least a member of the set of friendly programming languages.
20:35:50 <pikhq> Erm.
20:35:55 <pikhq> Programming language channels.
20:35:56 <|zzz|> what do you mean by most friendly... helpful answers or?
20:36:15 <dancor> it means you have a build problem and no one answers ;)
20:36:26 <gwern> @faq is haskell the most modest language around?
20:36:27 <lambdabot> The answer is: Yes! Haskell can do that.
20:36:32 <dmwit> For example, last time I was in ##c, they explained to me that arrays and pointers are different.  That's the kind of edge case that you can't find unless you've been using the language for years.
20:36:47 <shachaf> dmwit: What, with sizeof?
20:36:52 <shachaf> Or something else?
20:37:01 <mauke> with the power of WORDS
20:37:01 <dmwit> Yep, that and constness.
20:37:04 <mike-burns> |zzz|: I mean that we encourage beginner questions.
20:37:31 <shachaf> "friendly" means "few trolls". Therefore #grhgh is the friendliest channel ever.
20:37:57 <dmwit> Was #grhgh the one where everybody talked like zombies? ^_^
20:38:16 <ray> i think "friendly" means "uses the word 'troll' the least"
20:38:31 <ray> excepting reference to the mythical creature
20:39:25 <ray> gwern: you need the bitlbee of wikipedia, though
20:39:34 <shachaf> ray: This is the first time I've ever used the word, for what it's worth.
20:39:38 <ray> :)
20:39:51 * shachaf generally avoids slang like that quite heavily.
20:40:10 <shachaf> I am simply in an odd state of mind at the moment (as a result of being sick, perhaps?).
20:40:11 <ray> i'm only against that word because people throw it around like a baseball
20:40:31 <shachaf> ray: Wait, I didn't use the word! It was in quotation marks!
20:40:35 * shachaf 's record is spotless.
20:41:15 <ray> besides, there is probably a nice correlation between number of "troll"s and usage of the word "troll"
20:41:39 <pikhq> ray: Bitlbee. :)
20:41:46 <shachaf> (There is nothing mythical about trolls, by the way; there's one nearby (at the bridge, of course).)
20:42:02 <ray> pikhq: you can't add your wikipedia account
20:42:07 <mauke> Metroid Prime 3 Corruption - Chocolate Rain.mp3
20:42:14 <pikhq> ray: Shame.
20:42:16 <heatsink> mauke: whta
20:42:26 <ray> i have kappas under my bridge
20:42:59 <gwern> mauke: is chocolate rain an euphemism for being shat upon?
20:43:05 <gwern> kind of like golden showers?
20:43:12 <mauke> you're disgusting
20:43:25 <shachaf> tcsl27.mid
20:43:25 * gwern isn't the one posting provocative song titles
20:43:31 <ray> i think everyone thought that the first time
20:43:35 <pikhq> ray: I have bridges under my kappa.
20:44:38 <mauke> gwern: http://www.youtube.com/watch?v=EwTZ2xpQwpA
20:44:48 * gwern isn't sure I dare click
20:46:25 <heatsink> This is haskell.  What could possibly "go wrong"?
20:46:51 <gwern> it is dark. you are liable to be eaten by a _|_
20:47:07 <shachaf> "pitch black"! "likely"!
20:47:29 <shachaf> Sorry. I am apparently the Infocom quote police.
20:47:43 <gwern> shachaf: note that since liable has 3 syllables, the total syllable count is preserved in my variant
20:48:10 <pikhq> You are being evaluated with the following argument: "It is pitch black. You are likely to be eaten by a _|_." `seq` _|_
20:49:13 <shachaf> gwern: Hum. It messes up the rhythm anyway, though.
20:49:46 <gwern> one could argue that. it's unclear where the stresses are
20:49:53 <gwern> for a misquote, I think one could do much worse
20:52:38 <ray> it is chalk white. you are likely to be eaten by a Mu.
20:53:26 <mae> hello!
20:53:38 <mae> gwern: how is gitit going?
20:53:49 <Rotaerk> hrm, what's the point of the _ command in vim
20:54:06 <Rotaerk> it's the same as +, but goes down one fewer line
20:54:41 <mike-burns> Rotaerk: There are a ton of vim commands that may only be useful once in your lifetime.
20:54:47 <Rotaerk> heh
20:54:57 <dmwit> _, +, and <CR> are very closely related =)
20:54:58 <ray> one of them is "vim" at the shell prompt
20:55:12 <dmwit> Nonsense.
20:55:18 <dmwit> There's plenty of times where you don't have X.
20:55:21 <dmwit> err...
20:55:29 <dmwit> At least, I've had plenty of times where I haven't had X.
20:55:45 <dancor> dmwit: haven't had a +?
20:55:46 <Saizan_> so people generally uses vim in graphic mode?
20:55:54 <dancor> oh xorg
20:56:00 <ray> weird
20:56:11 * dmwit doesn't have gvim at work
20:56:11 <mike-burns> Saizan_: I use gvim.
20:56:12 <ray> i figured graphic mode was just to appeal to the kids
20:56:16 <dancor> i use vim in terminal
20:56:20 <ray> i never have x but that is neither here nor there
20:56:22 <dmwit> And they haven't installed the gtk-dev libraries, either, so I can't build it myself. =(
20:56:33 <dancor> i always have x/xforwarding and rarely use it
20:56:43 <ray> oh, i always have x forwarding i guess
20:57:04 <dancor> i'll keep _ and + in mind for remapping..
20:57:46 <pikhq> ... People do text editing in X?
20:58:00 <pikhq> I thought that gvim and emacs' X support was a toy.
20:58:01 <pikhq> :P
20:58:19 <Rotaerk> I'm using gvim in windows
20:58:19 <mike-burns> gvim has nicer fonts than my term.
20:58:52 <Rotaerk> kind of tempted to try that haskell IDE though
21:15:11 <mxc> saizan_ i basically use macvim, full screen on a second monitor, with :set guioptions=g
21:15:17 <mxc> minimal, beautiful
22:18:13 <hackagebot> haskeem 0.7.12 - A small scheme interpreter (UweHollerbach)
22:26:06 <cheddar> how do I read null separated string from a TCP handle?
22:26:16 <cheddar> like words, but with \0 instead of space
22:31:11 <dibblego> cheddar, see Data.List.Split
22:31:39 <mmorrow> (or just use the ByteString split function if you're using ByteStrings)
22:31:52 <mmorrow> (or write your own)
22:32:10 <mmorrow> adding a whole new package dep for one function may be overkill
22:32:52 <cheddar> hmm, not sure which to choose
22:33:02 <cheddar> thanks for the suggestions
22:34:13 <kyagrd> mmorrow: Hi, did you know that you lunabot source can make ghc 6.10.4 to do the impossible? :)
22:34:20 <matsuura> cheddar: o_o
22:34:28 <dmwit> cheddar: If it's actually a String, takeWhile seems appropriate; if it's a ByteString already, using its function is probably better.
22:34:38 <cheddar> I'm actually reading from a TCP socket
22:35:29 <cheddar> and the contents are ASCII encoded integers and floats separated by nulls
22:35:35 <mmorrow> , let split _ [] = []; split a xs = let (ys,zs) = break (==a) xs in ys : split a (drop 1 zs) in split '\0' "asdf\0jkl;\0a3333333"
22:35:36 <lunabot>  ["asdf","jkl;","a3333333"]
22:35:48 <mmorrow> kyagrd: uhoh, no i didn't know that.
22:35:57 <mmorrow> kyagrd: what's the context?
22:36:11 <dmwit> cheddar: ...right.  I'm just asking whether the way you're reading gets you back values of type String or ByteString.
22:36:18 <dmwit> ...or even something else.
22:36:19 <mmorrow> kyagrd: (i haven't tested on >=6.10.3 yet)
22:36:25 <dmwit> [Word8] or whatever it is.
22:36:31 <cheddar> dmwit: I haven't settled on which way to read yet :-/
22:36:43 <dmwit> What are your choices?
22:37:14 <dmwit> I mean, there can't be all that many functions that read from TCP sockets.
22:37:17 <cheddar> string is probably the simplest
22:37:25 <mmorrow> kyagrd: the lunabot code is finicky due to the ghc-api
22:37:27 <cheddar> the other is a buffered read
22:37:32 <cheddar> which I probably won't use
22:37:42 <dmwit> Buffered/unbuffered is orthogonal to what type you get.
22:37:47 <cheddar> because I don't want the hassle of dealing with managing it myself
22:38:18 <cheddar> I think I'll use connectTo
22:38:30 <mmorrow> kyagrd: in what context did you get the "the impossible happened" message?
22:39:39 <dmwit> Ah, okay, so you really can get your choice of ByteString, String, [Word8], etc.
22:39:48 <cheddar> I guess I could do getContents and split the string at '\0', but I'm wondering if that's "bad"
22:39:55 <kyagrd> mmorrow: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg23199.html
22:39:57 <dmwit> cheddar: If what you're reading is in a binary format, then may I suggest using one of the libraries for reading binary formats?
22:40:02 <cheddar> or I could read characters and append them to make a string
22:40:11 <dmwit> nothing wrong with getContents
22:40:17 <cheddar> dmwit: no the data is ascii encoded, not binary format
22:40:56 <dmwit> ok
22:41:04 <mmorrow> kyagrd: ahhh, ok. i've actually came across this before. what's actually causing the panic is some bug in standalone deriving with a recursive knot-tied context introduced in 6.10.2
22:41:09 <kyagrd> kyagrd: Oh, well I of course did cabal configure before cabal build, although it is not on the post.
22:41:14 <dmwit> I would start simple, then, and get complicated when it becomes a problem. =)
22:41:25 <dmwit> getContents and split, if that's what you're comfortable with. =)
22:41:48 <cheddar> I think I'll just read characters and append them until I reach '\0' and then return the string
22:41:59 <mmorrow> kyagrd: and that instance isn't actually that crucial for lunabot, i'll comment it out in the repo as a temp fix.
22:42:23 <kyagrd> mmorrow: But, it is a GHC bug anyway though.
22:42:26 <mmorrow> kyagrd: but yeah, i'd forgotten about this bug.
22:42:30 <mmorrow> kyagrd: yes
22:42:36 <cheddar> thanks dmwit
22:42:55 <mmorrow> kyagrd: have you already filed a ticket?
22:43:21 <kyagrd> No, I just posted on the ghc bugs list not a ticket (I don't acutally know how to do it since I've never done it before)
22:43:54 <kyagrd> You might want to make a tag of the current freeze so GHC developers to look in maybe?
22:50:56 <mmorrow> kyagrd: here's the minimal code from lunabot that triggers that http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7993#a7993
22:51:32 <mmorrow> kyagrd: ok, cool. i can file the ticket if you'd like.
22:51:52 <kyagrd> mmorrow: Sure, go ahead.
22:52:21 <mmorrow> kyagrd: ok. (to do so, you'd go to http://hackage.haskell.org/trac/ghc/)
22:53:15 <copumpkin> what were linear implicit parameters?
22:53:31 <copumpkin> can't find much about them except how they were removed
22:54:35 <kyagrd> mmorrow: Oh, I thought you were going to do it.
22:55:53 <kyagrd> kyagrd: Well I'll file it for ghc 6.10.4 then :)
22:59:13 <mmorrow> kyagrd: i'm doing it now
22:59:26 <mmorrow> kyagrd: i just meant that as an "fyi" :)
22:59:40 <mmorrow> (i just clicked submit..)
23:00:27 <mmorrow> kyagrd: http://hackage.haskell.org/trac/ghc/ticket/3423#preview
23:02:05 <mmorrow> kyagrd: err, bad link
23:02:11 <mmorrow> kyagrd: http://hackage.haskell.org/trac/ghc/ticket/3423
23:02:52 <Rotaerk> hmm anyone got haskell mode installed in vim for windows?
23:02:58 <Rotaerk> http://projects.haskell.org/haskellmode-vim/ is what I'm looking at
23:03:09 <Rotaerk> the instructions don't seem to work though
23:17:36 <mmorrow> is trac just reaaaaally slow in general, or is hackage.haskell.org/trac/ghc's httpd to blame?
23:20:11 <impl> mmorrow: Trac is slow, especially when it has to weed through a large number of comments.
23:20:13 <impl> commits*
23:21:30 <mmorrow> a gitit hack that does what trac does would be a killer app for sure
23:28:13 <mxc> is there a type like Rational but that uses Int's instead of Integers?
23:29:26 <copumpkin> :k Ratio Int
23:29:28 <lambdabot> *
23:29:40 <copumpkin> why though?
23:30:30 <mxc> a way to do fast decimal arithmetic
23:30:41 <copumpkin> hmm
23:30:48 <Saizan_> there's also Data.Fixed
23:31:09 <copumpkin> mxc: you sure Rational is slowing you down? it uses native words for small values anyway
23:31:19 <mxc> haven't even tried it
23:31:31 <mxc> looking to replace doubles and just thinking about the best way
23:31:34 <copumpkin> it does add a check to see if it still fits every time, but unless you're doing something very tight it might just be a little premature
23:31:55 <mxc> really, so for small numbers Integers are basically as efficient as Ints?
23:31:59 <copumpkin> why you replacing doubles?
23:32:10 <copumpkin> mxc: well, minus the size check
23:32:24 <mxc> doubles + financial code = killer rounding errors
23:32:28 <copumpkin> ah I see
23:32:39 <copumpkin> a fixed point representation might be best then
23:32:46 <mxc> yeah
23:33:48 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
23:34:03 <mxc> reading it now..
23:56:15 <mmorrow> mxc: you have to round to .XX at given points anyways.. you can always just make that explicit and use Doubles (like e.g. if you need to match how some existing code (that you don't have control over) executes a particular algo)
23:56:54 <mxc> fair point
23:57:37 <damajah> is there anything like Maven for Haskell, that sets up a "convention" based project structure with unit tests, build scripts, packaging etc all set up?
