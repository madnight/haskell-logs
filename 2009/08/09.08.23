00:01:26 <taruti> basically it is about making the type checker believe that it is really a bijection between the types.
00:01:29 <copumpkin> mine was a little simpler without the GADT in between
00:02:01 <taruti> copumpkin: did you have the value type vs visible type difference?
00:02:18 <Orclev> cool, I finished my script to upload stuff automagically to hpaste from irssi
00:02:30 <copumpkin> I can't exactly see what you're doing there, but I can paste my code (it's quite short), if it helps
00:02:39 <copumpkin> unfortunately I had to use undecidableinstances :/
00:02:45 <copumpkin> but I'm positive they're decidable :P
00:02:49 <taruti> please paste it, maybe I can get some ideas from it
00:03:56 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8473#a8473 , if you look down to line 103 it looks very similar to what you're trying
00:04:42 <copumpkin> but maybe your case is harder because of the GADT
00:04:44 <Axman6> @hoogle yeild
00:04:45 <lambdabot> No results found
00:04:53 <copumpkin> @hoogle yield
00:04:54 <lambdabot> Control.Concurrent yield :: IO ()
00:04:59 <Axman6> yeah.. heh
00:05:44 <Orclev> my xmonad config (xmonad.hs): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8474#a8474
00:06:03 <copumpkin> Orclev: #xmonad ?
00:06:04 <Orclev> hmm
00:06:10 <dmwit> Cool, double-spaced code.
00:06:12 <Orclev> copumpkin: was testing my script
00:06:21 <Orclev> yeah... that's not supposed to happen
00:06:24 <Orclev> better fix that
00:07:19 <taruti> copumpkin: the extraction works for me too without the fd-thing.
00:07:28 <copumpkin> ah :/
00:07:43 <Orclev> copumpkin: with my irssi script the command to generate that message was /hpaste -t my xmonad config -f /home/me/.xmonad/xmonad.hs
00:07:45 <taruti> seems like everyone is reinventing hlist like records
00:08:23 <copumpkin> taruti: yeah, I'm still noobish so just experimenting with what can be done :) no particular goal in mind beyond finding out what I can represent in the type system and what I can't
00:09:11 <Orclev> from what little I've seen the question is mostly what can't you represent with the type system with the answer being not much
00:09:56 <copumpkin> taruti: oh I think I see the problem
00:10:18 <copumpkin> oh maybe not
00:10:20 <copumpkin> :P
00:10:29 <taruti> hmm?
00:10:36 <Axman6> hmmmm, i don't remember threading in haskell being so damn slow
00:11:22 <Axman6> running the thread-ring code with and without +RTS -N2, and without it, it takes 9 seconds, but with it, it's still running after quite some time
00:11:25 <taruti> hmm, seems like the problem is the FD not unifying
00:11:28 <Axman6> this is not good
00:11:49 <copumpkin> taruti: just out of curiosity, what are you writing?
00:11:56 <Axman6> this is ghc 6.10.3 btw
00:12:02 <copumpkin> Concurrent/Process ?
00:12:04 <taruti> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8475#a8475 is a simpler version failing.
00:12:24 <taruti> copumpkin: cleaning up some erlang style concurrency code for newer GHCs
00:12:31 <copumpkin> taruti: and you absolutely need the fundeps?
00:12:55 <taruti> copumpkin: the 6.10.* type family code seems too immature.
00:13:19 <taruti> of course that works with an unsafeCoerce# but that would be evil
00:13:39 <copumpkin> :)
00:13:56 <Axman6> hmm, i wonder wtf is wrong here
00:14:06 <taruti> the GADT does not capture the class context iirc which seems to be the cause
00:15:30 <adu> wow are type families still the hot topic?
00:15:30 <Saizan_> the gadt does capture class contexts
00:15:43 <Axman6> adu: sadly
00:15:50 <copumpkin> why sad?
00:16:08 <Axman6> because it means no one's helping me ;)
00:16:16 <adu> and I thought it was just another silly language extension
00:16:24 <adu> Axman6: can I help?
00:16:46 <copumpkin> adu: they're pretty awesome
00:16:59 <adu> copumpkin: yeah, I'm aware
00:17:14 <Axman6> adu: well, compiling http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=ghc&id=3 and running it with -N2 on my machine gives me vastly slower runtimes than without -N2
00:18:04 <Axman6> ah, adding -qm -qw speeds things up a hell of a lot
00:18:33 <Axman6> vastly reduces the system time
00:18:48 <Axman6> though still slower than without -N2
00:19:02 <adu> Axman6: do you mean -O2?
00:19:10 <Axman6> no, +RTS -N2
00:19:15 <Axman6> threads
00:19:53 <dmwit> Hitting 'n' instead of 'o' would be an impressive typo on every keyboard layout I know of.
00:19:59 <Saizan_> well, there's no parallelism there, so adding threads will only add overhead, no? especially in GC
00:20:15 <Axman6> Saizan_: yeah
00:20:31 <Axman6> the program is iherently sequencial
00:20:34 <adu> is -N a ghc or gcc option?
00:20:35 <Axman6> inherently*
00:20:42 <Axman6> it's a rutime option
00:20:57 <Axman6> ghc -threaded foo; ./foo +RTS -N2
00:20:58 <hackagebot> bytestring-nums 0.2.1 - Parse numeric literals from ByteStrings. (JasonDusek)
00:22:24 <Saizan_> btw, it seems a cheating entry
00:22:32 <Axman6> how so?
00:22:49 <copumpkin> if they design bad tests, it's not our fault
00:22:56 <Saizan_> it's not "keeping alive 503 threads" by any standard definition of thread
00:23:08 <Axman6> how is it not?
00:23:13 <Axman6> they don't have to be OS threads
00:23:16 <Saizan_> how is it?
00:23:18 <adu> Axman6: have you tried -O9?
00:23:25 <Saizan_> there's a single forkIO there
00:23:43 <Axman6> no there isn't
00:23:43 <Saizan_> oh
00:23:45 <Saizan_> sorry
00:23:48 <Axman6> ;)
00:23:51 <Saizan_> i missed half of the code :)
00:23:56 <Orclev> lol
00:24:15 <Axman6> heh
00:24:37 <copumpkin> taruti: so visible is what shows up in the type, but the representation is a separate type?
00:24:51 <taruti> copumpkin: yes.
00:25:06 <adu> so the foldM makes 503 threads?
00:25:09 <taruti> copumpkin: I'm thinking of a simpler way of doing this (5min)
00:25:42 <Saizan_> adu: 502
00:25:49 <taruti> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8476#a8476
00:25:51 <adu> oh, right
00:26:28 <dmwit> 503 is a weird number
00:26:31 <copumpkin> taruti: couldn't you just use two separate type functions?
00:26:42 <dmwit> Is there some library that uses 9-bit thread id's and keeps 9 threads to itself or something?
00:26:49 <taruti> copumpkin: the problem is that they wouldn't unify
00:27:08 <copumpkin> just as standalone type families?
00:29:07 <copumpkin> taruti: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8476#a8477 ?
00:29:14 <copumpkin> taruti: whoops, I forgot a parameter for the ctx
00:30:00 <hackagebot> bytestringparser-temporary 0.1.0 - Combinator parsing with Data.ByteString.Lazy (JasonDusek)
00:30:15 <adu> copumpkin: I thought type families must have an argument...
00:30:35 <copumpkin> well, he'd go and fill in the type instances for his more specific types
00:30:51 <copumpkin> but he didn't provide any visible, impl pairs
00:31:50 <adu> and is "End" a type name or type constructor?
00:33:13 <taruti> copumpkin: that appears to work, thanks :)
00:33:36 <copumpkin> np! :)
00:35:19 <copumpkin> lol, you can coax a Any out of that code quite easily
00:35:26 <Axman6> dmwit: i think it's just a arbitrary, not very nice number (possibly a prime)
00:36:03 <adu> Axman6: it would run faster if you changed the 503 to a 3
00:36:09 <copumpkin> taruti: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8476#a8478 :P
00:36:12 <dmwit> > any ((== 0) . (503 `mod`)) [2..502]
00:36:14 <Axman6> probably
00:36:14 <lambdabot>   False
00:37:01 <u_quark> primes are nice numbers :P
00:37:24 <copumpkin> choices are decent steaks, but primes are still better
00:37:28 <adu> > any ((== 0) . (500 `mod`)) [2..502]
00:37:29 <lambdabot>   True
00:37:36 <Axman6> u_quark: except when you need to divide them up :P
00:37:55 <dmwit> > any ((== 0) . (500 `mod`)) [2..499] -- a bit more fair
00:37:56 <lambdabot>   True
00:38:00 <adu> > filter ((== 0) . (500 `mod`)) [2..502]
00:38:02 <lambdabot>   [2,4,5,10,20,25,50,100,125,250,500]
00:38:14 <u_quark> Axman6: product of tow big primes ? also bad...
00:39:32 <taruti> copumpkin: now the recursive instance just hangs.
00:39:40 <copumpkin> taruti: oh no :(
00:39:40 <adu> i wonder if anyone has gone back in time with the factorization of RSA-1024 and claimed the prize
00:40:18 <copumpkin> taruti: what's your code?
00:40:26 <copumpkin> solidsnack: had you seen bytestring-lexing?
00:40:45 <taruti> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8476#a8479
00:41:10 <solidsnack> copumpkin: It's broken.
00:41:18 <solidsnack> copumpkin: Also, it only does doubles.
00:41:19 <copumpkin> ah
00:41:58 <solidsnack> So actually, I'm trying to build a fast JSON parser but I've got to back fill these other things :)
00:47:24 <solidsnack> I have to laugh at the fact that my last 3-4 updates to the nums package showed up on this channel one right after another :)
00:52:46 <copumpkin> taruti: hmm, I can't convince it!
00:54:11 <taruti> copumpkin: ok, I'll just use the simpler definition with the constructor as a datatype. That coupled with GADTs seems to make for clean code.
00:54:56 <copumpkin> taruti: ok :) I'm sure it's solvable but you'd need someone who has half a clue, unlike me :P
01:04:00 <yitz> dmwit: 503 is a beautiful prime number, what's weird about it?
01:04:28 <dmwit> too many 1s in its binary representation
01:04:55 <dmwit> Any number with more than one significant digit is weird.
01:04:58 <yitz> dmwit: try a different base
01:05:18 <dmwit> I accept sodium hydroxide only, sorry.
01:06:16 * dmwit wonders briefly if there is a rigorous way to order things by "arbitrariness"
01:06:50 <yitz> dmwit: number of times it occurs in oeis
01:06:50 <dmwit> i.e. 505 is more arbitrary than 500 or 512, but less arbitrary than 503
01:06:55 <dmwit> heh
01:08:39 <koala_man> maybe you could approximate it with the number of factors?
01:09:28 <dmwit> Hey, that's not bad.
01:10:26 <dmwit> Larger factors are more abitrary, or maybe lower exponents are more arbitrary.
01:14:54 <copumpkin> coproduct is just sum?
01:15:29 <copumpkin> (in terms of types, at least?)
01:16:24 <ziman> disjoint union
01:17:22 <copumpkin> yeah
01:17:51 <copumpkin> so if (,) is product, Either is coproduct?
01:18:10 <Saizan> yes
01:21:31 <Saizan> with f : C -> A, g : C -> B you've (f &&& g) :: C -> (A,B) such that fst . (f &&& g) = f; snd . (f &&& g) = g
01:21:38 <Saizan> flip the arrows and you get Either
01:22:06 <copumpkin> :t (+++)
01:22:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
01:22:21 <Saizan> :t (|||) -- this one
01:22:23 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
01:22:35 <copumpkin> yeah, I always confuse them
01:22:55 <jpcooper> @hoogle (,)
01:22:56 <lambdabot> Prelude undefined :: a
01:22:56 <lambdabot> Data.Array.Base arrEleBottom :: a
01:22:56 <lambdabot> Test.QuickCheck.Batch bottom :: a
01:22:59 <Axman6> well this is nice. just checked out the latest llvm, ran ./configure --prefix=blah; make; and it errored out almost straight away
01:23:03 <Axman6> whoops
01:23:04 <copumpkin> +++ and *** are both bimap aren't they?
01:23:12 <Saizan> yes
01:23:19 <gwern> hum. that's not cool. my xosd binary segfaults
01:23:21 <gwern> @seen dons
01:23:21 <lambdabot> dons is in #haskell-in-depth, #yi, #xmonad, #ghc, #haskell, #arch-haskell, #concatenative and #darcs. I last heard dons speak 6h 8m 43s ago.
01:23:33 <gwern> I don't think it's supposed to segfault
01:24:33 <adu> gwern: maybe it is :)
01:24:36 <Saizan> f : A -> C; g : B -> C; (f ||| g) :: Either A B -> C such that (f ||| g) . Left = f; (f ||| g) . Right = g
01:24:45 <gwern> no, I'm sure the haddocks would mention that
01:25:01 <Saizan> it's nice that (|||) is a destructors while (&&&) is a constructor
01:28:37 <gwern> hm, strace has the answer
01:28:45 <gwern> for once, that POS is actually helpful to me
01:28:55 <gwern> apparently xosd doesn't like the font I specified
01:29:10 <gwern> well, gee, thanks for SEGFAULTING
01:29:36 <gwern> because that's the most sensible thing to do if the font isn't exactly right -_-
01:30:53 <jpcooper> is there any reason as to why a Maybe transformer is not included in Control.Monad.Trans?
01:34:41 <yitz> jpcooper: look for MaybeT on hackage
01:42:08 <notsonerdysunny> what is the purpose of s in "newtype Wrap s a = Wrap a deriving (Eq, Ord) "
01:43:02 <notsonerdysunny> would 's' in the above expression have a definite type?
01:44:32 <notsonerdysunny> my point is ... isn't the above expression equivalent to "newtype Wrap a = Wrap a deriving (Eq,Ord)"
01:46:02 <path[l]> inside a monad what does this statement mean? True <- return (x /= y)
01:49:28 <roconnor> path[l]: pattern matches to the left of <- call fail if they fail
01:49:37 <roconnor> otherwise they, well, pattern match
01:49:41 <path[l]> ah
01:50:05 <path[l]> so x <- [1,2,3] could be an assignment or a pattern match?
01:50:06 <roconnor> [x | Just x <- [ Just 1, Nothing, Just 2]]
01:50:08 <roconnor> > [x | Just x <- [ Just 1, Nothing, Just 2]]
01:50:14 <lambdabot>   mueval-core: Prelude.read: no parse
01:50:14 <lambdabot>  mueval: ExitFailure 1
01:50:19 <roconnor> pft
01:50:23 <roconnor> , [x | Just x <- [ Just 1, Nothing, Just 2]]
01:50:26 <lunabot>  [1,2]
01:51:03 <roconnor> , do {Just x <- [ Just 1, Nothing, Just 2; return x}
01:51:04 <lunabot>  luna: parse error on input `;'
01:51:10 <roconnor> , do {Just x <- [ Just 1, Nothing, Just 2]; return x}
01:51:12 <lunabot>  [1,2]
01:51:14 <path[l]> when you do x < - y, x can even be constrained on the left huh?
01:51:22 <roconnor> that's what I'm saying
01:51:30 <roconnor> In your case True is a pattern that has no variables
01:51:32 <path[l]> ok, thanks :), this is making more sense
01:51:51 <path[l]> Im reading about monads, to understand list monads, to learn how to make a backtracking thingy
01:52:26 <Axman6> > [x | x@True <- [True, False, True]]
01:52:28 <lambdabot>   [True,True]
01:53:44 <path[l]> ah, hehe ok
01:54:52 <roconnor> True <- return (x /= y)  can actually be rewritten as "guard (x/=y)"
01:54:59 <roconnor> which I think would be more clear
01:56:13 <copumpkin> guard require MonadPlus though
01:56:31 <Axman6> :t guard
01:56:31 <copumpkin> but I guess in this case it's an instance :)
01:56:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:56:51 <jethr0> good <insert local time of day here>, haskell
01:56:53 <notsonerdysunny> Hello everybody .. I'm a beginner .. I am reading and trying to understand a haskell code ... It might sound silly but I don't understand how "newtype Wrap s a = Wrap a" would be different from "newtype Wrap a = Wrap a" .. can anybody help?
01:56:58 <copumpkin> > x | x <- [True, False, True], x]
01:57:00 <lambdabot>   <no location info>: parse error on input `|'
01:57:01 <copumpkin> > [x | x <- [True, False, True], x]
01:57:03 <lambdabot>   [True,True]
01:57:39 <copumpkin> notsonerdysunny: valuewise, there is no difference
01:57:47 <Axman6> notsonerdysunny: neither do i :) (except the kind of Wrap goes from being * -> * to * -> * -> *
01:57:54 <copumpkin> notsonerdysunny: the first one carries around an extra type
01:58:03 <notsonerdysunny> what is the extra 's' doing?
01:58:12 <jethr0> has anyone here any experience with opengl or sdl programming in haskell?
01:58:13 <copumpkin> a form of annotation
01:58:23 <Jedai> notsonerdysunny: it's called phantom type
01:58:27 <notsonerdysunny> copumpkin .. why would one want to do that ?
01:58:43 <notsonerdysunny> would googling for phantom type help me in this regard?
01:58:47 <copumpkin> yeah
01:58:57 <path[l]> is guard the exact same as True <- ?
01:58:57 <Baughn> jethr0: Slightly. Let me guess, having trouble getting sdl to work?
01:58:58 <roconnor> copumpkin: oh, right about guard.  If you aren't in a MonadPlus, then I guess you have to write something like that.
01:59:12 <elbar> ?src guard
01:59:13 <lambdabot> guard True  =  return ()
01:59:13 <lambdabot> guard False =  mzero
01:59:16 <roconnor> path[l]: I was wrong.  guard requires you to be working in a MonadPlus
01:59:18 <roconnor> sorry
01:59:20 <jethr0> i've been planning to write a game in haskell and was wondering whether there was any kind of game engine like fungen still active?
01:59:21 <Baughn> jethr0: SDL tends to need a custom main, which doesn't play well with haskell. It should be pretty well documented, though..
01:59:23 <notsonerdysunny> ok thx .. let me look
01:59:28 <path[l]> whats MonadPlus? isnt it just an import?
01:59:34 <jethr0> Baughn: do you know if there is a tutorial for hsdl?
01:59:41 <Jedai> notsonerdysunny: it's really nice to leverage Haskell type system to check you're not doing bad thing with data without causing the explosion of quantity of code that using different types would do
01:59:50 <roconnor> path[l]: MonadPlus is a subclass of Monad with the operations mplus and mzero
01:59:58 <path[l]> ah ok
02:00:10 <copumpkin> notsonerdysunny: say you have a goober type that comes from two different sources. You want to keep goobers from different sources separate, so you "annotate" each goober with where it came from, even though valuewise it's the same goober
02:00:32 <Jedai> notsonerdysunny: like adding two Wrap together, with this phantom type trick you can check that those "Wrap" represent the same thing or not
02:00:34 <Baughn> jethr0: I'm not aware of any tutorials. However, it's sufficiently close to SDL that you shouldn't need one; it's a very simple binding.
02:00:35 <roconnor> I don't know what monad you are using True <- return (x/=y) in
02:00:38 <jethr0> Baughn: to be honest, opengl is a little on the low-level side of things for my taste. can you recommend SDL under haskell?
02:00:39 <roconnor> it might be a MonadPlus
02:01:15 <copumpkin> @src fail []
02:01:15 <lambdabot> Source not found. You untyped fool!
02:01:21 <Baughn> jethr0: For graphical output, SDL is even lower-level than opengl, and I much prefer opengl
02:01:22 <copumpkin> @src [] fail
02:01:23 <lambdabot> fail _      = []
02:01:32 <Baughn> jethr0: For keyboard input, window management and all that, sure, use SDL.
02:01:32 <roconnor> @src [] mzero
02:01:32 <lambdabot> mzero = []
02:01:50 <Jedai> notsonerdysunny: if you didn't use this trick you would have to use several types to represent the different Wrap and you would have to write one function for each type to do the addition even though it's exactly the same operation
02:01:51 <roconnor> path[l]: pattern match failure will call fail
02:01:58 <Baughn> jethr0: (Specifically, use SDL to grab an opengl context)
02:02:04 <roconnor> path[l]: guard will call mzero when false
02:02:29 <roconnor> path[l]: usually fail x = mzero when mzero exists
02:02:34 <path[l]> ah ok
02:03:23 <copumpkin> bedtime for me
02:04:24 <path[l]> can I use the guard clause to write something that taken a list gives me a list of all lists of combinations.
02:04:26 <path[l]> ?
02:04:40 <jethr0> sry, dropped out. really flakey network connection I am on ;(
02:04:59 <path[l]> basically I wouldnt want for example [1,2,3,4] to give me [1,1,1,1], but Id want [1] and [1,3,4] etc
02:05:18 <Baughn> path[l]: http://hackage.haskell.org/package/permutation <-- You'll want this library.
02:05:36 <path[l]> hehe ok
02:07:47 <notsonerdysunny> thanks Jedai .. let me work with it
02:07:50 <jpcooper> -- 'readline' already has type 'String -> IO (Maybe String)'; we just need
02:07:50 <jpcooper> -- to wrap it.
02:07:50 <jpcooper> maybeReadLine :: String -> MaybeIO String
02:07:50 <jpcooper> maybeReadLine prompt = MaybeT (readline prompt)
02:07:53 <jpcooper> I don't understand this
02:08:00 <jpcooper> this is in the documentation of Control.Monad.Maybe
02:08:20 <jpcooper> where type MaybeIO = MaybeT IO
02:08:45 <jpcooper> wouldn't the type of maybeReadLine be MaybeIO (Maybe String)?
02:09:30 <Jedai> jpcooper: no
02:09:34 <jpcooper> why not?
02:09:45 <Baughn> jpcooper: MaybeIO already includes a Maybe. Why would you want two?
02:09:48 <jethr0> Baughn: thx
02:09:52 <jethr0> Baughn: are you aware of anything higher-level than opengl that can be used sanely for game programming?
02:09:53 <jpcooper> Baughn, I don't want it to
02:10:00 <Jedai> jpcooper: the "Maybe" part, the "possibility of failure" part is already included in the MaybeIO monad
02:10:07 <Baughn> jpcooper: Then don't use MaybeIO
02:10:19 <jpcooper> you don't understand me
02:10:25 <jpcooper> what is the type of MaybeT?
02:10:34 <Baughn> jethr0: There are a couple engines, but I'm not aware of any of them being bound to haskell
02:10:49 <Baughn> jpcooper: It's a type constructor, not a value
02:10:58 <Baughn> Its *kind* is * -> * -> *
02:11:02 <jethr0> right. i thought "FunGen" looked nice, but it seems badly deprecated and OLD
02:11:03 <jpcooper> so what do those two lines mean?
02:11:09 <jpcooper> maybeReadLine = MaybeT (readline prompt)
02:11:17 <Baughn> Oh..
02:11:27 <Baughn> So I guess it's a type constructor /and/ a value?
02:11:55 <jpcooper> I don't see how MaybeT (readline prompt) could have the type MaybeIO String in the end
02:12:33 <Baughn> What's the type of MaybeT?
02:13:07 <Jedai> jpcooper: look at the definition of MaybeT
02:13:18 <jpcooper> I don't know
02:13:32 <jpcooper> newtype MaybeT m a = MaybeT {
02:13:32 <jpcooper> runMaybeT :: (m (Maybe a))
02:13:32 <jpcooper> }
02:13:35 <jethr0> path[l]: see below
02:13:38 <dschoepe> :t MaybeT
02:13:40 <lambdabot> Not in scope: data constructor `MaybeT'
02:13:43 <jethr0> filterM (const [True, False]) [1,2,3,4]
02:13:49 <jethr0> > filterM (const [True, False]) [1,2,3,4]
02:13:51 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
02:14:16 <Megant> it's type is MaybeT m a -> m (Maybe a)
02:14:31 <jpcooper> isn't that runMaybeT's type?
02:14:44 <Megant> oops, right
02:15:31 <dschoepe> Megant: just change the direction of the arrow and it's correct.
02:15:31 <Jedai> jpcooper: it's type is "m (Maybe a) -> MaybeT m a"
02:15:47 <Megant> yeah
02:15:59 <Jedai> jpcooper: so "readline prompt" is of type "IO (Maybe a)"
02:16:00 <jpcooper> apparently it is but I can't see it defined anywhere?
02:16:27 <Jedai> jpcooper: it is in the definition of MaybeT, didn't you see it
02:16:31 <Jedai> ??
02:16:48 <jpcooper> is this common with all monad transformers where TypeT :: m (Type a) -> TypeT m a?
02:16:59 <dschoepe> yes
02:17:00 <Jedai> jpcooper: maybe what's confusing you is that MaybeT is both a type constructor and a data constructor
02:17:06 <jpcooper> Jedai, I can't see it on http://hackage.haskell.org/packages/archive/MaybeT/0.1.0/doc/html/Control-Monad-Maybe.html
02:17:15 <jpcooper> dschoepe, knowing this would have saved me a lot of time
02:17:31 <Jedai> jpcooper: it's defined in the chunk of code you just showed us
02:18:07 <Jedai> jpcooper: dschoepe may be right but it's not mechanically the case, just a convention
02:18:21 <jpcooper> right
02:18:37 <Jedai> jpcooper: besides it's not even true for every monad transformer in the standard library
02:18:50 <path[l]> jethr0 I didnt understand how that worked
02:18:51 <Jedai> or maybe it is...
02:19:06 <jpcooper> Jedai, I don't see quite how it is defined in the previous code
02:19:30 <Jedai> newtype MaybeT m a = MaybeT { runMaybeT :: (m (Maybe a)) }
02:19:40 <dschoepe> jpcooper: MaybeT, as a data constructor, has one field. passing the constructor a value of the type of this field, creates a value
02:19:49 <jpcooper> oh yes
02:19:54 <dschoepe> just like when you have data Foo = Foo Int and you call Foo 42
02:19:54 <jpcooper> I understand now
02:20:02 <Jedai> jpcooper: here, MaybeT is a data constructor (with record syntax)
02:20:09 <jpcooper> yes of course
02:20:13 <jpcooper> thanks
02:20:52 <path[l]> :t filterM
02:20:55 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:22:19 <Jedai> jpcooper: and by the way, ReaderT is not m (Reader a) -> ReaderT m a
02:22:30 <dschoepe> path[l]: that works because of the way the list monad works: x >>= \y -> f y binds y to each value of the list x and calls f on it. (>>=) = concatMap
02:22:47 <dschoepe> > do { x <- [1..3]; return (x+2) }
02:22:50 <lambdabot>   [3,4,5]
02:22:52 <jpcooper> Jedai, okay
02:23:42 <path[l]> oh shit I gtg, Ill bring this up again when I return :)
02:26:24 <jethr0> path[l]: to be honest me neither. but it works ;)
02:26:24 <jethr0> basically it works in the list monad by taking each element given once and once not taking it.
02:26:25 <jethr0> so if the input is [1,2,3,4], then it looks at the "1" and continues two alternative routes, one of taking the "1" and one of leaving it out.
02:29:09 <etpace_> the list monad seems pretty magical
02:30:03 <c_wraith> @src List (>>=)
02:30:03 <lambdabot> Source not found. You type like i drive.
02:30:09 <c_wraith> @src [] (>>=)
02:30:10 <lambdabot> xs >>= f     = concatMap f xs
02:30:36 <etpace_> @src concatMap
02:30:37 <lambdabot> concatMap f = foldr ((++) . f) []
02:31:30 <Jedai> etpace_: it isn't really
02:31:55 <etpace_> I guess it's because I don't really understand it
02:32:38 <dschoepe> jethr0: it becomes clear when you replace filterM by its definition.
02:35:58 <jethr0> dschoepe: hehe, at least to the compiler/lambda calculus/turing machine ;)
02:36:25 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8483#a8483
02:36:32 <mercury^> Does anyone see why that doesn't typecheck?
02:36:54 <paulvisschers> How do I convert from lazy bytestrings to strict ones?
02:37:11 <mercury^> paulvisschers: concat . toChunks
02:37:13 <paulvisschers> or use binary to make strict bytestrings to begin with
02:37:40 <mercury^> Don't get what you mean with that.
02:37:59 <jethr0> has anyone ever played with GLFW, the cross-platform opengl framework?
02:39:29 <paulvisschers> I'm trying to use BerkeleyDB, which expects Data.ByteString.Internal.ByteString, but Binary's encode gives me a Data.ByteString.Lazy.Internal.ByteString, so how do I get a strict bytestring?
02:39:47 <mreh> what makes : nextState evs s = return $ doBullets . doRoids . doShip . (foldl procEv s) $ evs
02:39:49 <mercury^> paulvisschers: I just told you how you can convert.
02:40:01 <mreh> and nextState evs s = return $ doBullets . doRoids . doShip . (foldl procEv s  evs ) different
02:40:21 <paulvisschers> so is there an encode and decode for strict bytestrings?
02:40:44 <paulvisschers> mercury^: well sure, but that seems a bit indirect and inefficient
02:41:28 <mercury^> mreh: in the later version, you apply foldl procEv s to evs, in the first one it starts at doBullets
02:42:17 <mreh> mercury^ would you say they still have the same type?
02:42:29 <mreh> compiler tells me the latter has type a -> State
02:42:42 <mreh> and the first just State
02:43:05 <mercury^> mreh: that's not surprising, because they are different after all.
02:46:12 <mreh> :t (.)
02:46:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:46:25 <mreh> oh i see
02:46:46 <mreh> :i (.)
02:46:55 <mreh> no liek :(
02:50:39 <hackagebot> haskell-src-exts 1.1.3.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
02:51:42 <JOSH_> Hello everyone
02:52:36 <JOSH_> ...
02:53:50 <JOSH_> ok...
02:53:55 <JOSH_> bye everyone then, :)
02:55:31 <mreh> HELLO!
02:57:20 <JOSH_> Hi mreh
02:57:43 <mreh> a/s/l?
02:57:52 <mreh> i'm just kidding
02:58:04 <mercury^> Ok, the code I posted above compiles if I add a dummy argument to "a".
02:58:18 <mreh> sounds like hacking to me
02:58:30 <mreh> JOSH_ what brings you here?
02:58:35 <mercury^> Yes, I bet this is another stupid bug.
02:58:41 <JOSH_> mreh: I got bored
02:58:47 <JOSH_> what brings you here?
02:58:49 <mreh> :O
02:59:09 <mreh> JOSH_, i had problems with my haskell
02:59:24 <JOSH_> What's haskell?
02:59:30 <mreh> but it was so simple it would embarrass a warthog
02:59:57 <mreh> a lazy evaluated statically typed functional language
03:00:02 <JOSH_> I don't know what haskell is, sorry.
03:00:03 <mercury^> Aha, eta-blowing it works too.
03:00:13 <JOSH_> I have no clue what you just said. :D
03:00:20 <mreh> JOSH_ it's a programming language
03:00:21 <JOSH_> I'm only 14
03:00:33 <mreh> nobody is perfect
03:00:58 <mreh> does your father know you're chatting in a programming forum?
03:01:05 <JOSH_> lolz
03:01:06 <JOSH_> no
03:01:19 <mreh> i was 21 when I came out
03:01:27 <JOSH_> came out?
03:01:38 <mreh> i said "dad, I want to be an engineer"
03:01:49 <JOSH_> lolz
03:01:57 <JOSH_> I prefer Physics
03:02:15 <mreh> anyway, this is a room for talking about haskell, so we can't chat here
03:02:29 <mreh> it has to be on topic in this forum
03:02:34 <JOSH_> lolz ok
03:03:16 <JOSH_> Ok bye everyone, I'm going
03:50:13 <voker57> is there any library for working with digital signatures? Can't find any on hackage
03:54:22 <Jedai> voker57: digital signature ? which exactly ?
03:54:58 <voker57> Jaak: i'
03:55:01 <voker57> oops
03:55:18 <voker57> Jedai: I'd settle for any, say DSA
03:57:20 <edwardk1> @seen bos
03:57:20 <lambdabot> bos is in #ghc, #haskell and #haskell-in-depth. I last heard bos speak 12h 12m 6s ago.
03:59:37 <Jedai> voker57: you have the Crypto package that should have everything you need, no ?
04:00:28 <Jedai> voker57: and HsOpenSSL
04:00:37 <voker57> Jedai: there's only en/decryption and digests
04:00:47 <voker57> just noticed hsOpenSSL
04:01:08 <Jedai> Jedai: HsOpenSSL has everything you need then
04:01:41 <voker57> yeah, thanks. Something native would be better though...
04:02:05 <Jedai> voker57: why ?
04:02:25 <voker57> Jedai: extra dependancy outside cabal
04:02:44 <Jedai> voker57: ok, to prove that Haskell's is bigger, but otherwise, it's more practical and reassuring to use a well known library like openSSL
04:02:53 <Jedai> voker57: ah ok
04:18:30 <jkff> Hi folks. In case anyone remembers I was going to start a small project introducing algebraic constructs like monoids, lattices etc. into practical programming. I've started it: http://code.google.com/p/jalgebra/ . It's in Java, there are now extremely few things and things that are there are very sketchy (I've spend about 2 hours in total on it), and I don't yet know what to do further, but it has been started. I am very open to discussion and sugge
04:20:55 <zeno_> lol
04:21:01 <zeno_> all up in ur side effects
04:21:14 <zeno_> EXERT PRINTF UNSAFE LAMBDA X
04:21:47 <jkff> Hm, what?
04:21:48 <SubStack> oh goodness
04:22:42 * SubStack lifts zeno_ 
04:23:11 <zeno_> OH GOODNESS
04:23:14 <zeno_> me
04:23:19 <SubStack> <$>
04:23:21 <zeno_> up onto the rack?
04:23:31 <SubStack> perhaps, perhaps
04:23:36 <zeno_> <$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$
04:23:38 <zeno_> ><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$>
04:23:39 <zeno_> <$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$
04:23:42 <zeno_> ><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>
04:23:44 <SubStack> !_!
04:23:47 <zeno_> <$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$>v<$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$><$
04:23:55 <Raevel> thank you irc server
04:23:57 <jkff> Huh
04:24:50 * SubStack should get working on that blog of his with comics and such
04:25:06 <smorg> <$> is one of the arrows I think
04:25:10 <SubStack> and haskell!
04:25:33 <SubStack>  <$> is like liftM except when it's not
04:25:42 <jkff> :t (<$>)
04:25:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:26:11 <SubStack> smorg: arrows, morelike
04:26:14 <jkff> <$> is fmap.
04:26:19 <SubStack> er, applicative
04:26:24 <SubStack> silly me
04:26:45 <zeno_> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:29:35 <smorg> wth
04:32:48 <zeno_> [05:29] [MOTD] -
04:32:50 <zeno_> [05:29] [MOTD] -  ________________________________________________________________
04:32:54 <zeno_> [05:29] [MOTD] - |   _   _    _    ____  ____     ____ _   _    _  _____ ____     |
04:32:56 <zeno_> [05:29] [MOTD] - |  | | | |  / \  |  _ \|  _ \   / ___| | | |  / \|_   _/ ___|    |
04:32:58 <zeno_> [05:29] [MOTD] - |  | |_| | / _ \ | |_) | | | | | |   | |_| | / _ \ | | \___ \    |
04:33:02 <zeno_> [05:29] [MOTD] - |  |  _  |/ ___ \|  _ <| |_| | | |___|  _  |/ ___ \| |  ___) |   |
04:33:04 <zeno_> [05:29] [MOTD] - |  |_| |_/_/   \_\_| \_\____/   \____|_| |_/_/   \_\_| |____/    |
04:33:06 <zeno_> [05:29] [MOTD] -  \   ____________________________________________________________
04:33:08 <zeno_> [05:29] [MOTD] -   \ |
04:33:10 <zeno_> [05:29] [MOTD] -    \\
04:33:10 --- mode: ChanServ set +o Saizan
04:33:12 <zeno_> [05:29] [MOTD] -     v
04:33:14 <zeno_> [05:29] [MOTD] -     .-------------'```'----......,,__                        _,
04:33:16 <zeno_> [05:29] [MOTD] -    |                                 `'`'`'`'-.,.__        .'(
04:33:16 --- mode: Saizan set +b *!*n=andrew@*.hsd1.co.comcast.net
04:33:16 --- kick: zeno_ was kicked by Saizan (Saizan)
04:33:33 --- mode: Saizan set -o Saizan
04:35:57 * kfish yawns
04:37:04 <Makoryu> EXPERT MOTD PASTER
04:37:27 <Makoryu> What was he doing before he spammed <$>?
04:43:42 <twb> On an alpha machine, I am apparently getting this for darcs 2.3:
04:43:42 <twb> ld: cannot find -lHSrts_thr
04:43:45 <twb> What is happening?
04:43:52 <twb> http://buildd.debian.org/build.php?arch=alpha&pkg=darcs&ver=2.3.0-1 for the full log
04:45:05 <mercury^> How do I write to a Ptr?
04:45:38 <eivuokko> Mostly with functions called poke.
04:46:09 <mercury^> Ah, thanks.
04:50:13 <Taejo> :t foldM
04:50:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:50:24 <Saizan> twb: i don't think the threaded runtime is available on alpha
04:51:31 <twb> Hmm, so if Darcs has started depending on it, then Darcs no longer works on Alpha?
04:53:19 <Jedai> twb: I don't think darcs does, it just try to use it, a little change in the .cabal file (or a switch) should arrange that
04:54:07 <twb> OK, so I need to take this up with upstream?
04:56:00 <Jedai> twb: You can
04:56:16 <Jedai> twb: for your own case though you don't need to
04:56:59 <Jedai> I wan't even aware we had a working GHC on Alpha :)
04:57:01 <twb> Well, I actually have an upstream developer hat, too, so it's easy and preferable to fix upstream problems upstream :-)
04:57:13 <Jedai> twb: sure ! ^^
05:06:29 <twb> Jedai: so you're saying to add -f-rts in .cabal, so that it won't try to use the RTS features?
05:09:56 <Saizan> twb: you need to remove -threaded from ghc-options somewhere, or make it conditional
05:10:41 <Saizan> twb: if !arch(alpha) ...
05:12:33 <twb> Thanks.  I'll just check that without -threaded, it  actually works on x86, at least
05:13:31 <mercury^> Are IORef Ints automatically unboxed? If not, how do I best make sure they are? (Preferably have them in a register)
05:13:45 <mercury^> (The int, not a pointer to it)
05:15:42 <Saizan> mercury^: you mean you want only one level of indirection?
05:16:11 <Saizan> i don't think you can do that with IORefs
05:16:23 <mercury^> :(
05:17:19 <mercury^> Every time I try to optimise haskell I think "this would be so easy in C" all the time.
05:18:01 <mercury^> But in this case I blame the interface of Data.ByteString.Internal.create
05:18:15 <twb> The problem is if you were writing it all in C, you'd be saying "this <other part> would be so easy in Haskell
05:18:43 <skorpan> indeed
05:18:44 <twb> I know so many languages, that problem is unbearable enough that I can't program
05:18:50 <Vanadium> :D
05:18:53 <skorpan> so many languages lack a good "map"
05:18:57 <twb> It's not funny :-(
05:19:11 <twb> skorpan: many of them even require mapping to be sequential!
05:19:39 <mercury^> But it is rather disappointing that there is no fast way to generate a string.
05:19:47 <mercury^> It's such a fundamental task.
05:19:49 <twb> Now, what REALLY pisses me off is that most languages have no LET, i.e. no elegant way to create a new lexical scope, and define exactly where it ends.
05:20:05 <twb> mercury^: erm, Unicode is FAR from simple
05:20:08 <Vanadium> {}?
05:20:14 <twb> mercury^: if you want ASCII, maybe try bytestrings?
05:20:22 <mercury^> twb: an ASCII string. And I'm using bytestrings.
05:20:34 <twb> OK, I only know OF bytestring, not the nasty innards
05:20:46 <Vanadium> What are you creating a string from?
05:21:09 <mercury^> There is a function that takes a state and gives you a character.
05:21:30 <twb> mercury^: a haskell function, or C function?
05:21:35 <mercury^> haskell function
05:21:47 <mercury^> I need to update the state after it has run
05:22:06 <mercury^> But ByteString.create only takes an io action that receives a pointer for every character
05:22:29 <mercury^> So I need the io action to access and update the state somehow
05:22:48 <mercury^> IORef seemed like the solution, but if it involves lots of indirection that's rather disappointing
05:24:09 <olsner> are you sure you need an IO action to generate the characters? sounds like an unfold otherwise
05:24:16 <Vanadium> create :: Int -> (Ptr Word8 -> IO ()) -> IO ByteString
05:24:21 <Vanadium> Looks funny.
05:24:40 <mercury^> olsner: the unfoldrN function is very slow, I hoped I could make it faster by using create.
05:25:02 <Vanadium> mercury^: Maybe you can just look at create's implementation and make your own create?
05:25:15 <Vanadium> It does not seem very complicated
05:25:22 <twanvl> it doesn't receive a pointer for every char, only for the first one
05:25:33 <twanvl> it is a pointer to the entire buffer
05:25:37 <mercury^> Oh.
05:26:04 <twanvl> you can write it with pokeElemOff or poke and plusPtr
05:26:42 <mercury^> twanvl: thanks, that should work just fine.
05:29:48 <Baughn> @index MaybeT
05:29:49 <lambdabot> bzzt
05:30:41 <twanvl> ?hackage MaybeT
05:30:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
05:47:48 <Vanadium> Is there a function (m a, m b, m c) -> m (a, b, c)?
05:47:59 <EvilTerran> ?type liftM3 (,,)
05:48:04 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
05:48:11 <Vanadium> Ooh.
05:48:15 <EvilTerran> close enough?
05:48:22 <Vanadium> Yeah.
05:48:28 <EvilTerran> :)
05:48:35 <Vanadium> Thanks.
05:48:52 <EvilTerran> ?type \x y z -> (,,) <$> x <*> y <*> z -- equivalent
05:48:54 <lambdabot> forall a a1 a2 (f :: * -> *). (Applicative f) => f a -> f a1 -> f a2 -> f (a, a1, a2)
05:51:57 <Milo-> what was the other great book for learning about functional languages, not RWH..?
05:52:47 <ski> (.. maybe you're thinking of SICP ?)
05:52:50 <badsheepy> SICP is scheme and is rekno..
05:52:50 <Philonous1> http://mitpress.mit.edu/sicp/
05:52:54 <badsheepy> waah
05:52:54 <Milo-> SICP that's the one <3
05:53:43 <ray> warning: not equivalent to zip3
05:53:51 <ski> @web1913 rekno
05:53:52 <lambdabot> No match for "rekno".
05:54:21 <ray> what's that, does it search a 1913 copy of the web that's out of copyright?
05:54:39 <ski> @help web1913
05:54:39 <lambdabot> I perform dictionary lookups via the following 13 commands:
05:54:39 <lambdabot> all-dicts ... Query all databases on dict.org
05:54:39 <lambdabot> devils ...... The Devil's Dictionary
05:54:39 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
05:54:39 <lambdabot> elements .... Elements database
05:54:41 <lambdabot> [9 @more lines]
05:55:12 <badsheepy> rekno.. is what you get when you start typing reknowned and then someone else replies before you:p
05:56:01 * Baughn notes that Message.hs now has passed thirty imports
05:57:04 <ray> go for 50
05:58:38 <dsdeiz> hello, is there a way to simulate a keyboard event?
06:02:33 <Muzzleflash> I have this snippet which shows the ascii value of every character given: interact (++ "\n").concat.intersperse ",".map (show.ord)
06:02:46 <Muzzleflash> However, it doesn't insert the new line?
06:03:10 <Muzzleflash> I'm running it in GHCi
06:06:54 <yitz> Muzzleflash: I think you need a $ after interact
06:07:24 <Muzzleflash> I've actually defined let test = (++ "\n").concat.intersperse ",".map (show.ord)
06:07:26 <Muzzleflash> then interact test
06:07:36 <yitz> ok
06:08:29 <Muzzleflash> Maybe it has something to do with buffering? If I change (++ "\n") to ("\n" ++) it insert a newline at the beginning. However only before the first line
06:09:09 <yitz> Muzzleflash: in ghci, how do ever get to the end? I find I have to hit ^C, so it never gets to the newline (in 6.10.3)
06:09:16 <yitz> do you
06:09:49 <Muzzleflash> I don't get to the end
06:10:00 <Muzzleflash> I don't know if you can make an "end of file" char or something
06:10:03 <yitz> ok, so you'll never see the newline
06:10:22 <yitz> yeah, when I type ^D, it just says "10," :)
06:10:43 <Muzzleflash> It says "10,4,"
06:10:43 <EvilTerran> Muzzleflash, you're only putting a newline on the end there
06:11:06 <EvilTerran> is that what you want?
06:11:16 <yitz> Muzzleflash: when you run it as a compiled program, it should be ok
06:11:20 <Muzzleflash> EvilTerran: No I want a newline after every output
06:11:28 <ski> then say so ?
06:11:36 <yitz> Muzzleflash: oh, so then you have to intersperse it.
06:11:47 <EvilTerran> Muzzleflash, as as in, "10,\n4,\n..."?
06:12:04 <Phyx-> @index guard
06:12:04 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:12:06 <Muzzleflash> EvilTerran: I want a newline after every line, not every number
06:12:24 <ski>   interact (intercalate ",\n" . map (show . ord))
06:12:24 <ski> ?
06:12:25 <yitz> @type guard
06:12:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:12:35 <EvilTerran> Muzzleflash, you're not doing anything line-by-line there
06:12:46 <yitz> Phyx-: it's in Control.Monad
06:12:59 <EvilTerran> "The interact function takes a function of type String->String  as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device"
06:13:06 <mapreduce> > fix ("like fix "++)
06:13:08 <lambdabot>   "like fix like fix like fix like fix like fix like fix like fix like fix li...
06:13:16 <Phyx-> yitz: yes, i already found that with @index :)
06:13:23 <yitz> ok
06:13:48 <Phyx-> hrm. what's an Irrifutable pattern failed error mean again?
06:13:52 <EvilTerran> Muzzleflash, you may want something like "main = interact (unlines . map test . lines)"
06:14:07 <EvilTerran> > let Just x = Nothing in x -- Phyx-
06:14:09 <lambdabot>   * Exception: <interactive>:1:137-152: Irrefutable pattern failed for patter...
06:14:11 <Jedai> Phyx-: that someone used ~
06:14:23 <EvilTerran> you can get the same effect with ~s
06:14:30 <Jedai> Phyx-: or let like EvilTerran just showed :)
06:14:42 <yitz> > let f ~(_:_) = "oops" in f []
06:14:44 <lambdabot>   "oops"
06:14:53 <EvilTerran> > (unlines . map ("!"++) . lines) "foo\nbar\nbaz\n"
06:14:55 <lambdabot>   "!foo\n!bar\n!baz\n"
06:15:05 <ski> yitz :)
06:15:18 <Muzzleflash> EvilTerran: Thanks that works
06:15:18 <EvilTerran> > (\ ~(Just x) -> x) Nothing
06:15:19 <yitz> > let f ~(_:xs) = xs in f []
06:15:19 <Phyx-> hmm, how do i fix this...
06:15:21 <lambdabot>   mueval-core: Prelude.read: no parse
06:15:21 <lambdabot>  mueval-core: GhcException "mkTopLevEnv...
06:15:22 <lambdabot>   * Exception: <interactive>:1:137-150: Irrefutable pattern failed for patter...
06:15:32 <EvilTerran> uhh
06:16:02 <EvilTerran> Phyx-, it should give you a line number
06:16:21 <Muzzleflash> I don't understand why my earlier code stopped at concat and printed it, and didn't ++
06:16:39 <EvilTerran> Muzzleflash, "The interact function takes a function of type String->String  as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device"
06:16:53 <Phyx-> EvilTerran: yes, it does, i'm just trying to think how i can fix it without breaking the program :P
06:17:11 <Phyx-> some prime number generator
06:17:14 <EvilTerran> Muzzleflash, so you were translating any newlines on stdin into their ascii code and printing them out that way, and only appending a newline to the end of the output
06:17:18 <EvilTerran> not the end of each line
06:18:19 <Muzzleflash> EvilTerran: I think I understand know. Thanks
06:18:29 <EvilTerran> :)
06:19:06 <Phyx-> @pl (\a-> a<=j && a >= j)
06:19:06 <lambdabot> liftM2 (&&) (<= j) (>= j)
06:20:44 <Phyx-> weee upper bounding works, now to add lower bounds to the generation of primes
06:23:31 <ski> Phyx- : like `0' being a lower bound of primes ?
06:24:09 <ski> (.. or maybe that's an upper bound, actually)
06:24:19 <Baughn> ..it's neither. Sure not a prime.
06:24:26 <ski> (say `1', instead)
06:24:33 <Baughn> (say "2")
06:24:39 <yitz> @pl (\j a-> a<=j && a >= j)
06:24:40 <lambdabot> ap (ap . ((&&) .) . flip (<=)) (flip (>=))
06:24:57 <ski> surely a bound of primes need not be a prime itself ?
06:25:25 <yitz> flip (<=), flip (>=)? @pl has flipped
06:25:31 <Phyx-> ski: for instance yes
06:25:52 <Phyx-> Baughn: i mean, the bounds on the search space
06:26:04 <Phyx-> search for all primes between 20 and 100 for instance
06:26:11 <Phyx-> i could filter, but that's dog slow
06:26:17 <yitz> @pl (\a j-> a<=j && a >= j)
06:26:18 <lambdabot> ap (ap . ((&&) .) . (<=)) (>=)
06:26:37 <magthe> anyone around with some experience in hslogger and syslog?
06:26:42 <gwern> Phyx-: there're an absurd number of prime searches on the wiki
06:27:04 <gwern> one of them assuredly does what you want
06:27:14 <Baughn> Phyx-: I wonder, what's the lower limit at which probabilistic prime checks become faster than absolute ones?
06:27:40 <Baughn> Keeping in mind that the check must be repeated until the probability of programmer error is greater than that of spurious yes/no
06:28:18 <gwern> Baughn: well, according to SICP that isn't very many checks at all
06:28:38 <Phyx-> gwern: yes, i'm modifying the wheel method from the wiki to do what i want, since it seems to be the fastest
06:28:48 <Baughn> gwern: True.
06:28:57 <Phyx-> Baughn: hmm no idea really :)
06:29:05 <Baughn> I just find it a bit silly that people still use the deterministic checks. :P
06:29:25 <Phyx-> hey i'm just trying to win a contest :P
06:29:32 <gwern> SICP has an amusing footnote that goes something like 'after 4 random checks, the probably of a false positive is approximately 1 in foozillion, which is less than the chance of a stray cosmic ray causing an erroneous computation. That the probabilistic one is not acceptable illustrates the difference between engineering and mathematics'
06:30:01 * Baughn is a mathematical heretic
06:30:27 <Baughn> (I consider the probability of error in the /proofs/ of the deterministic methods to be nonzero)
06:30:27 <yitz> Baugh, with your definition, I can use isPrime = const $ unsafePerformIO randomIO
06:30:57 <gwern> ah, here we go
06:30:58 <Baughn> yitz: How the heck does that give you a low probability of error
06:31:00 <gwern> 'Numbers that fool the Fermat test are called Carmichael numbers, and little is known about them other than that they are extremely rare. There are 255 Carmichael numbers below 100,000,000. The smallest few are 561, 1105, 1729, 2465, 2821, and 6601. In testing primality of very large numbers chosen at random, the chance of stumbling upon a value that fools the Fermat test is less than the chance that cosmic radiation will cause the ...
06:31:06 <raimo_> how do I pattern match strings in haskell?
06:31:06 <gwern> ... computer to make an error in carrying out a ``correct'' algorithm. Considering an algorithm to be inadequate for the first reason but not for the second illustrates the difference between mathematics and engineering.'
06:31:09 <Phyx-> damnit, pattern match failure :s
06:31:16 <yitz> Baughn: it's about the same as the probability of programmer error
06:31:23 <raimo_> like case ("STARTSWITHTHIS " ++ rest) -> ...
06:31:32 <Phyx-> lol... and it says 6 is a prime now
06:31:36 <Baughn> yitz: No. In this case, you knew exactly what you were doing. That was no error.
06:31:38 <ski> (also, in one sense, `0' is a prime, in integral domains)
06:32:49 <gwern> raimo_: painfully
06:32:58 <raimo_> so parser combinators are way to go?
06:33:01 <gwern> raimo_: eg, ('f':'o':'o':[])
06:33:13 <ski> > case "chalk" of "cheese" -> True; _ -> False
06:33:17 <lambdabot>   False
06:33:27 <yitz> gwern: it's common to run something like the Fermat test against about 32 primes. You get pretty good odds then.
06:34:00 <gwern> ski: but that wouldn't let him use a _ wildcard or a rest variable would it?
06:34:07 <canvon> raimo_: or you could use guards, i.e.: s | "STARTSWITHTHIS " `isPrefixOf` s
06:34:55 <ski>   s | Just rest <- stripPrefix "STARTSWITHTHIS" s = ..rest..
06:35:18 <canvon> nice
06:35:22 <canvon> @hoogle stripPrefix
06:35:23 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
06:35:31 <raimo_> I'm creating a very simple parser but this seems too limited for that
06:35:36 <gwern> hm, I don't know which is worse, using stripPrefix or pattern-matching with a _ wildcard
06:35:43 <canvon> ..and my Data.List is too old again :(
06:36:29 <mreh> can a keyboard not transmit more than three key presses at once?
06:36:45 <yitz> gwern: I'm getting the feeling you had a bad day. Come on, chin up, smile!
06:36:48 <ski> depends on the keyboard, i assume
06:36:56 <badsheepy> mostly not cause of physical build thingies
06:36:58 <mreh> ski: depends on the technology too
06:37:03 <skorpan> mreh: i know i can hit M-C-% which requires four keys
06:37:05 <badsheepy> word:o
06:37:21 <skorpan> mreh: i can also hit M-C-S-s-x in xulrunner and they're all recognized
06:37:22 <mreh> I think HGL is just crappy
06:37:33 <gwern> yitz: mm. I'm just feeling unmotivated. I was trying to build a little XOSD script but I discovered dons' binding is apparently crippled so I couldn't have the nice background for the text I wanted
06:37:45 <gwern> disgruntled, is the word, in the old sense of lacking gruntledness
06:37:51 <yitz> gwern: that's too bad
06:37:54 <ski> (skorpan : but maybe that's because most of those are bucky bits ?)
06:38:06 <skorpan> ski: probably yes
06:38:10 <yitz> gwern: oh, yeah, I saw you segfaulting fonts earlier
06:38:12 <gwern> ski: iirc, X lets you have smoething like 6 or 7 chorded modifies
06:38:29 <gwern> yitz: I fixed that, but the functionality I need ins't there
06:38:30 <mreh> well i'm pressing left right and space together, and the thing doesn't fire the guns on my spaceship :(
06:38:36 <yitz> hmph
06:38:41 <skorpan> lol
06:38:50 <mreh> the space signal isn't arriving in the event queue
06:38:59 <gwern> yernah firin yer lazer beams?
06:39:02 <shapr> @yow
06:39:02 <lambdabot> When this load is DONE I think I'll wash it AGAIN ...
06:39:27 <mreh> my space ship is running the Hugs Graphics Library
06:40:07 <gwern> hugs is bugs?
06:40:09 <mreh> it's why the Imperial Fleet got so *$"(& up
06:40:27 <mreh> in a run
06:40:29 <mreh> rug*
06:40:40 <yitz> gwern: is eeyore taken as a nick?
06:40:50 <gwern> yitz: try and see?
06:40:55 <gwern> I'd expect it to be
06:41:19 <gwern> irc network the size of a planet, and what do they expect me to do? change to a cleverly morose nick
06:41:31 <yitz> haha
06:42:45 <Baughn> What's more, my left diode /hurts/
06:43:23 <gwern> Baughn: you say that, but the truth is my left big toe *does* hurt a little
06:43:37 <mreh> it's it "all the diodes down my left hand side hurt"
06:43:50 <Baughn> mreh: Yeah, but..
06:43:56 <Baughn> I'm human. How many diodes do you expect me to have?
06:44:14 <gwern> Baughn: you could have a lot. pacemakers, hearing aids, etc
06:44:23 <gwern> surely they have a lot of diodes
06:44:25 <Baughn> gwern: I've got one, and it's external.
06:44:26 <mreh> several when I'm finished with you
06:44:50 * Baughn is currently holding a penlight, picked up specifically for the purpose of holding a diode
06:44:51 <mreh> carry it around in your pockets?
06:45:09 <gwern> is that a diode in your pocket or are you just electrified to see me?
06:46:13 <mreh> good old #haskell
06:46:32 <gwern> because nobody is as offtopic as we all are
06:46:38 * Baughn transports all of #haskell to Rokkenjima
06:46:51 <ski> @where Rokkenjima
06:46:52 <lambdabot> I know nothing about rokkenjima.
06:46:59 <yitz> @vixen are we getting off topic?
06:47:00 <gwern> #haskell is legion
06:47:01 <lambdabot> You choose a topic, any will do
06:47:24 <Baughn> Right. I've picked a topic: The Rokkenjima haskeller mass-murders. Discuss.
06:47:28 <bd_> @faq Can Haskell keep this channel on topic?
06:47:29 <lambdabot> The answer is: Yes! Haskell can do that.
06:47:33 <bd_> \o/
06:47:52 <gwern> ....when the seagulls cry?
06:48:07 <gwern> I didn't even know there was anything besides Higurashi
06:48:20 <Baughn> gwern: Ha. You're in for a treat, then.
06:48:23 <mreh> HGL things i'm pressing the space bar 6 times in 30ms
06:48:38 <Baughn> gwern: ..just ...the umineko VNs are much better than the anime, IMO, and fully translated. So get that.
06:48:41 <Phyx-> hrm, using "gaurd" cauzes it to terminate futher computation no? how do i make it just skip the current computation and continue?
06:48:51 <bd_> Phyx-: when?
06:48:51 <bd_> :t when
06:48:55 <Baughn> Phyx-: The function of guard varies depending on monad
06:48:56 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:48:56 <bd_> ...
06:48:58 <gwern> Baughn: I've never done VNs before
06:49:05 <Baughn> Though "skipping further computation" is certainly common
06:49:06 <Milo-> Is there CUPS support for Haskell, or how would you go around making a program in Haskell, that has a 'print' feature?
06:49:11 <bd_> so eg: when (not conditionToSkipProcessing) someAction
06:49:21 * Phyx- tries when
06:49:25 <Baughn> Phyx-: Anyway, you may be looking for Control.Monad.when
06:49:28 <Phyx-> Baughn: it's the list monad btw
06:49:58 <Baughn> Milo-: Me? I'd write out postscript, or pdf, or whatever, and pass it to lpr.
06:50:09 <gwern> Milo-: I've never heard of anything. call some more standard program to do it?
06:50:12 <mmorrow> Milo-: use the FFI to call whatever C function(s) you need
06:50:29 <Milo-> okay, so pure haskell is out of question
06:50:31 <Milo-> :)
06:50:39 <mmorrow> Milo-: what is "pure haskell"?
06:50:55 <Milo-> apparently horse-contests.
06:50:57 <mmorrow> it'll be pure haskell after you wrap the FFI binding :)
06:51:24 <Makoryu> Milo-: Since the whole IO monad is founded on FFI calls, you're kind of doomed from the start if you're looking for a pure Haskell anything :p
06:51:42 <ray> people still print from their own computers? that's so 90s
06:52:04 <Milo-> speaking of postscripts and pdfs, how do you create pages like that?
06:52:16 <Makoryu> Pages like... what?
06:52:27 <Milo-> whoops, my thoughts were mixed
06:53:11 <Milo-> how do you create document files with certain formatting and then save them as pdfs?
06:53:24 <Milo-> latex pops in to my mind
06:53:26 <Makoryu> From Haskell?
06:53:29 <Milo-> yes
06:53:34 <mmorrow> Milo-: are you on windows or unix?
06:53:34 <yitz> gwern: libxosd seems simple enough. why not just fix the binding?
06:53:35 <Makoryu> \_o/
06:53:39 <Milo-> mmorrow unix
06:53:49 <gwern> yitz: because I don't know C
06:53:52 <gwern> at all
06:54:01 <ray> take the 2 minutes to learn C then
06:54:28 <mmorrow> Milo-: there're some libraries that you can use to build pdf's, but personally that sounds extremely painful to me
06:54:29 <gwern> 2 minutes?
06:54:29 <yitz> gwern: eh, you probably don't need to know any C to fix whatever is broken in that binding. or ask people here to help
06:54:35 <ray> 2 minutes.
06:54:40 <ray> well, for a working knowledge anyway
06:54:52 <ray> it takes a lifetime of study to satisfy the pedants in ##c for example
06:55:04 <mmorrow> Milo-: what sort of stuff do you want to turn into a pdf?
06:55:16 <yitz> ray: no, it could take months. variable can *change value*. functions have *side effects*. it's all so confusing.
06:55:26 <Phyx-> hmm aren't there any build in ghc functions to time a function execution time?
06:55:32 <ray> no it isn't
06:55:40 <mmorrow> Milo-: i've use haskell to generate latex, then run latex/pdflatex on that
06:55:41 <ray> just think of it as instructions for a state machine
06:55:53 * yitz gasps in horror
06:55:55 <ray> a von neumann machine even
06:56:09 <mreh> 2 minutes (-_-)
06:56:18 <Milo-> mmorrow grab some text-fields from GUI and create the page form from those informations.
06:56:24 <Milo-> receipt-application
06:56:25 <yitz> ray: how do you say "move tape one square to the left" in C?
06:56:43 <ray> p++;
06:56:43 <mreh> that's not a state machine
06:56:46 <ray> where p is a pointer
06:57:02 <mreh> Turing machine
06:57:05 <yitz> &tape++
06:58:08 <mmorrow> Milo-: ah ok. i was actually using the latex for generating pretty bills/invoices, but i'm not sure how you'd go about generating to pdf's directly
06:58:12 <ray> that takes the address of tape++
06:58:13 <yitz> gwern: seriously, take a look at dons' binding, and ask here if you get stuck. it ought to be easy to fix.
06:58:23 <Milo-> mmorrow no need to do it directly
06:58:32 <Milo-> I think I can learn LaTeX, while at it
06:59:32 <ray> gwern: it's been 5 minutes, so you are no doubt a C expert by now :)
06:59:49 <gwern> I'm sorry, I was sucking my thumb
06:59:56 <gwern> although I did learn ruby and python
07:00:01 <ray> mmorrow: same way you'd write any other format
07:00:26 <ski> @type pages
07:00:28 <lambdabot> String -> [String]
07:00:57 <mmorrow> ray: sure, but also the whole "formatting everything" thing..
07:01:20 <mmorrow> ray: which sounds horrific to do at the pdf-specific level
07:01:21 <yitz> @src pages
07:01:24 <lambdabot> Source not found. My brain just exploded
07:01:25 <ray> i don't think people realise that C is a really simple and minimal language
07:01:27 <ray> mmorrow: i bet!
07:01:52 <yitz> lambdabot should remember the @src of @let bindings
07:01:53 <ray> if a given c program is hard to understand, it's for similar reasons to why the equivalent brainfuck program is hard to understand
07:01:56 <ray> not because C is hard
07:02:17 <ray> maybe they confuse it with c++
07:02:31 <gwern> yitz: @let stuff is just a textfile; you want to edit @src to fall back to parsing the @let .hs, fine by me
07:02:37 <gwern> I'd apply that patch
07:03:38 <ski> > unpages []
07:03:42 <lambdabot>   ""
07:03:46 * ksf is missing release notes on hackage
07:04:23 <yitz> gwern: may i guess that let.hs always consists of a bunch of lines all beginning with "let"?
07:04:30 <gwern> yitz:
07:04:31 <gwern> no
07:04:38 <ksf> you know, the kind of text that you read to figure out whether or not it's worthwile to re-try using a library
07:04:41 <gwern> ksf: there's a cabal bug I opened...
07:04:45 <yitz> darn
07:04:59 <gwern> @wn illicit
07:05:02 <lambdabot> *** "illicit" wn "WordNet (r) 2.0"
07:05:02 <lambdabot> illicit
07:05:02 <lambdabot>      adj 1: contrary to accepted morality (especially sexual morality)
07:05:02 <lambdabot>             or convention; "an illicit association with his
07:05:02 <lambdabot>             secretary" [ant: {licit}]
07:05:04 <lambdabot> [3 @more lines]
07:05:18 <ksf> in other news, xhb's compile time is abysmal.
07:05:21 <yitz> @more
07:05:22 <lambdabot>      2: contrary to or forbidden by law; "an illegitimate seizure of
07:05:22 <lambdabot>         power"; "illicit trade"; "an outlaw strike"; "unlawful
07:05:22 <lambdabot>         measures" [syn: {illegitimate}, {outlaw(a)}, {outlawed}, {unlawful}]
07:05:49 <Phyx-> what's the fastest way to print a list? i would assume putStr.unlines is very slow?
07:05:57 <ksf> print.
07:06:15 <ksf> > show [1..]
07:06:16 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:06:23 <Phyx-> that's just \x->putStrLn (show x)
07:06:25 <ksf> print is putStrLn . show
07:06:43 <Phyx-> and not to mention it doesn't do the same was putStr.unlines
07:06:46 <ksf> :t putStrLn . show
07:06:49 <lambdabot> forall a. (Show a) => a -> IO ()
07:06:55 <Phyx-> which doesn't print a haskell representation of lists
07:07:00 <yitz> Phyx-: why should putStr.unlines be slow?
07:07:13 <mreh> for the purposes of education is anyone willing to look over my code?
07:07:19 <mreh> to educate me
07:07:45 <Phyx-> yitz: it shouldn't now that i think about it, it does only 1 I/O action, i had in y head map putStrLn, lol, sorry
07:08:44 <michaelfeathers> show [1..]
07:08:50 <ski> mreh : if you don't paste it, nobody can look
07:08:51 <EvilTerran> Phyx-, the number of IO actions shouldn't make much difference, anyway
07:09:00 <mreh> ski: it's a whole 200 lines
07:09:04 <ski> @hpaste
07:09:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:09:06 <Phyx-> EvilTerran: i'm printing a very large list
07:09:21 <michaelfeathers> > show [1..]
07:09:23 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:09:24 <EvilTerran> Phyx-, write what looks nice. optimise only if it's too slow. :)
07:09:38 <Phyx-> EvilTerran: well, the contest is about speed so :p
07:09:43 <EvilTerran> ah
07:09:47 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8489#a8489
07:10:19 <Berengal> Yesterday I was delighted to see that happstack can run hsp pages. Today I'm shocked to learn that it doesn't translate the request, but simply gives hps an empty one
07:10:27 <mreh> i'm not happy with the program structure, but then I don't know a better way to implement it
07:10:34 <mreh> it still feels a bit imperative
07:10:59 <EvilTerran> mreh, well, it's asteroids; it'd be difficult to make it non-imperative.
07:11:12 <Baughn> mreh: FRP?
07:11:22 <Phyx-> :t forM
07:11:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
07:11:24 <mreh> Baughn, is that conals thing?
07:11:37 <Baughn> mreh: Kind of, though his doesn't properly work, it's the purest
07:11:51 <Baughn> mreh: There are other FRP implementations of hackage that do work, though. Although they aren't quite as nice.
07:12:19 <mreh> i'll give it a go
07:12:40 <Baughn> Adding a notion of pure, time-varying values makes a lot of seemingly imperative things pure
07:13:35 <mreh> Baughn: what I'm doing it folding instructions over one object, each one does its own thing to it, and it just feels like destructive updates all over again
07:13:45 <mmorrow> gwern: learning C is easy, but writing C code that doesn't just segfault immediately takes about a week. but still, a week isn't a long time.
07:14:00 <gwern> I'd rather learn some scheme in that week
07:14:02 <Baughn> mreh: I know the feeling, and FRP really helps. You should look into it. :)
07:14:25 <mreh> Baughn: is it a framework?
07:14:37 <mmorrow> gwern: write a scheme interp in C! two birds with one stone
07:14:42 <Baughn> mreh: I'm not sure. Is lazy evaluation a framework?
07:14:52 <Baughn> mreh: It's implemented using unsafeExtendRuntime
07:14:58 <gwern> mmorrow: that - that sounds like it would be one of the worse ways to learn C
07:15:09 * mmorrow imagines the segfault tsunami that'll occur in the first few days
07:15:32 <Jedai> mreh: there are "framework" for FRP, Reactive, Yampa (IIRC), others....
07:16:14 <Baughn> mmorrow: I learned C back in the days of DOS
07:16:21 <Baughn> My programs never segfaulted.
07:16:41 <mreh> why are you learning C? systems programming
07:16:41 <mmorrow> Baughn: oh yay, s/segfault/accidently the OS memory image/
07:16:44 <ray> just don't do anything untoward with memory and you won't segfault
07:16:59 <Berengal> Use the stack, Luke
07:17:03 <mreh> ray: haha
07:17:11 <Baughn> mmorrow: I found out how the interrupt vector works, the hard way. xD
07:17:19 <mreh> just dont fuck it up, you'll be FINE!
07:17:31 <ray> mmorrow: i purposefully the whole memory
07:18:08 <Berengal> What was the point of DOS anyway?
07:18:14 <ray> follow these simple rules: only use your own memory, ask for memory if you need it, give back your memory when you're done
07:18:29 <Baughn> Berengal: It was a file manager. Given the limitations of the processor, a pretty decent one.
07:18:30 <ray> do what your mother taught you, but with memory
07:18:38 <Baughn> Berengal: ..back in the DOS 2.0 days, that is
07:18:45 <ray> norton commander's a file manager 9_9
07:18:51 <mreh> I was still in nappies then
07:18:56 <Baughn> Norton commander doesn't include a file system. :P
07:19:04 <yitz> and when you segfault, look at your code again and go back to rule 1.
07:19:07 <ray> yeah file managers usually don't
07:19:16 <Baughn> This one did
07:19:47 <ray> i am trying to say "you are wrong" in a polite way :(
07:19:50 <Berengal> It was better than windows (pre NT), that's for sure...
07:19:57 <yitz> operating systems usually do include a file system, and this one didn't
07:20:21 <ray> berengal, that's like saying emacs is better than bsd, that's for sure
07:20:23 * Berengal was dual-booting DOS on the family computer until they got win 2k
07:20:25 <gwern> > 5000 / 30
07:20:25 <ray> er, bsd is better than emacs
07:20:28 <lambdabot>   166.66666666666666
07:20:39 <ray> while true, it's a bit of a weird comparison
07:20:41 <Baughn> ray: I'll admit that file managers usually don't include filesystems. However, when you look at what DOS was actually /used/ for, in its latter days...
07:21:05 <Baughn> Most programs included their own gpu drivers, even. :/
07:21:10 <mreh> what did you do before the O/S?
07:21:16 <mreh> switch banks
07:21:33 <mreh> the o/s is an integral part of the Von Neumann concept of stored programmes
07:21:37 <Berengal> mreh, bootable floppies/tapes containing a single program
07:21:47 <ray> baughn: it's not a very fancy operating system, but that's what it is
07:22:06 <Baughn> Okay, okay. :P
07:22:27 <ray> now i can sleep at night, thanks
07:22:31 <trofi> > 5 `div` 0
07:22:33 <lambdabot>   * Exception: divide by zero
07:22:37 <trofi> > 0 `div` 0
07:22:39 <lambdabot>   * Exception: divide by zero
07:22:42 <Baughn> > 0 / 0
07:22:44 <lambdabot>   NaN
07:22:50 <ski> > 0 `mod` 0
07:22:52 <lambdabot>   * Exception: divide by zero
07:22:55 <ray> > 4444 / 0
07:22:57 <lambdabot>   Infinity
07:23:19 <trofi> > 0 / (0 / 0)
07:23:22 <lambdabot>   NaN
07:23:30 <ski> > atan2 0 0
07:23:31 <lambdabot>   0.0
07:23:38 <ray> > (1 / 0) / (0 / 0)
07:23:40 <lambdabot>   NaN
07:23:50 <mreh> trofi's is my favourite
07:23:56 <ray> > 0 / 0 :: CReal
07:24:02 <lambdabot>   mueval-core: Prelude.read: no parse
07:24:02 <lambdabot>  mueval: ExitFailure 1
07:24:15 <trofi> mreh: which one? :]
07:24:28 <mreh> 2
07:24:35 <ray> 2 is not 1
07:24:36 <mreh> i mean 3
07:24:53 <Berengal> > let hush = cycle (show (0 / 0)) in hush
07:24:55 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa...
07:25:05 <trofi> cool :]
07:25:12 <mreh> cycle "lo"
07:25:15 <mreh> > cycle "lo"
07:25:17 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
07:25:31 <Makoryu> > foldl1 (/) [0,0,0]
07:25:32 <mreh> >take 100 $ cycle "lo"
07:25:32 <lambdabot>   NaN
07:25:59 <pikhq> Baughn: DOS was most certainly an OS. Though, it only offered to other programs a bootloader-type thing and some more interrupts for better primitives than what just the BIOS handed you. :)
07:26:01 <mreh> > take 100 $ cycle "lo"
07:26:03 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
07:26:31 <trofi> BIOS is a good OS
07:26:47 <olsner> DOS did afaik provide high-level functions for file I/O using FAT
07:26:49 <mmorrow> was it 0x100 that you always got loaded at? (you := a program)
07:26:52 <trofi> longest presence on market
07:27:14 <Berengal> mmorrow, wasn't it 0x200?
07:27:22 <trofi> @go .org 0x100
07:27:23 <lambdabot> No Result Found.
07:27:27 <trofi> @go .org 0x200
07:27:27 <mmorrow> heh
07:27:28 <lambdabot> No Result Found.
07:27:31 <trofi> :]
07:27:42 <olsner> mmorrow: that's .com's that are loaded at 0x100 then started
07:27:46 <ski> @go inc $d020
07:27:47 <lambdabot> No Result Found.
07:27:56 <trofi> @go int 21h
07:27:58 <lambdabot> http://spike.scu.edu.au/~barry/interrupts.html
07:27:58 <lambdabot> Title: DOS Interrupts
07:27:58 <mmorrow> olsner: yeah, that's what i mean
07:28:17 <ski> @go ffd2
07:28:17 <lambdabot> http://www.ffd2.com/fridge/
07:28:18 <lambdabot> Title: The Fridge
07:28:18 <olsner> (I suspect the location of the segment was up to DOS though - so it would load somewhere and set DS/CS so that offset 0x100 points to the program)
07:28:44 <olsner> (and .exe files can have more complex memory maps than that, with separate segments and stuff)
07:29:30 <mmorrow> ahh right, segments and that stuff
07:29:47 <Berengal> Back when we had segments...
07:30:11 * Phyx- submits his attempt
07:30:21 * Phyx- hopes it's fast enough
07:30:22 <Baughn> We still have segments
07:30:26 <Baughn> They can even be handy
07:30:35 <Berengal> We do?
07:30:43 <trofi> does x86_64 long mode implement it?
07:30:51 <Baughn> ..no idea, probably not
07:31:01 <mmorrow> movq %cs:42(%rax,%rbx,8), %rdx
07:31:04 <ksf> @seen conal
07:31:05 <lambdabot> I saw conal leaving #haskell-iphone and #haskell-blah 1d 8h 11m 11s ago, and .
07:31:05 <olsner> I think x86_64 explicitly removes segmentation support
07:31:14 <trofi> thread local stuff is in %gs on ia32
07:31:18 <Baughn> Berengal: Sure. The OS sets the code and data segment to both cover the same 4GB area, but programs can change that themselves if they want
07:31:28 <ksf> in 64bit mode, iirc, yes.
07:31:37 <Baughn> Berengal: It has some uses for emulation, I think
07:31:56 <trofi> mmorrow: they present as instruction format is compatible, but do they actually work?
07:32:04 <ksf> there's much legacy that's thrown out in 64bit mode.
07:32:17 <olsner> I think x86_64 retained fs and gs for special stuff like TLS or kernel data though
07:32:21 <mmorrow> some of the %*s regs are disabled on x86_64, but some still mean the same thing
07:32:30 <ksf> ...you can't even do virtual real-mode instances.
07:32:40 <trofi> vm86?
07:32:52 <ksf> well like those windoze dos windows
07:33:02 <ksf> back on win95
07:33:13 <trofi> sw emulation is faster and more reliable i suspect
07:33:14 <Phyx-> "time limit exceeded "
07:33:15 <Phyx-> fail
07:33:33 <ksf> yep, dosbox rules.
07:33:55 <dcoutts> trofi: it's probably not faster, but there's probably very little that needs real-mode that cares about performance
07:34:15 <mmorrow> http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24594.pdf
07:34:19 <ksf> actually, there's a lot that needs real-mode and cares about performance.
07:34:29 <dcoutts> ksf: really? like what?
07:34:29 <ksf> ...like, games that are running way too fast.
07:34:34 <dcoutts> hah
07:34:43 <Berengal> Too true :(
07:34:46 <dcoutts> ok, so they care about the perf being too high
07:34:53 <dcoutts> so sw emulation is great :-)
07:34:54 <Makoryu> http://oceanpark.com/ap5.html <- Anyone care to plunder this and make a Haskell library from it?
07:35:03 <mmorrow> Note:
07:35:03 <mmorrow>    1. In 64-bit mode, the CS, DS, ES, and SS segment overrides are ignored.
07:35:12 <trofi> yep
07:35:56 <ksf> ...well, if you want segmentatioin, you can bitmask your segment into the reg you want to dereference.
07:36:01 <mmorrow> so FS and GS only i guess
07:37:07 <hackagebot> astrds 0.1 - an incomplete 2d space game (AndresLoeh)
07:37:15 <trofi> hm, objdump does not show any seg prefixes on /lib/libpthread.0.so
07:37:28 <trofi> ah, %fs
07:38:12 <ksf> so, re-checking haskell's gui support after a year, not much has changed.
07:38:50 <ksf> gtk2hs and wxhaskell are still IO, grapefruit is still unreadable, and reactive still won't work for more complex stuff.
07:38:58 <mmorrow> Makoryu: this is a neat article/whatever (tangentially related to your link) http://code.haskell.org/~morrow/misc/schemec.txt
07:39:07 <Jedai> ksf: nope, you'll have to do something yourself (it would be immensely appreciated I think)
07:39:08 <mmorrow> Makoryu: don't recall where i originally got that from
07:39:33 <ksf> ...well, me doing something depends on reactive working.
07:40:27 * EvilTerran found a postscript quick reference that was about half a dozen printable pages a while ago, but can't find it now... anyone know what i'm thinking of?
07:40:32 <dcoutts> ksf: gtk2hs and wx will remain IO (or possibly some very thin wrapper over IO) that's their appropriate place in the stack.
07:40:42 <Phyx-> did GHC 6.6 have TH?
07:40:50 <mmorrow> yes
07:40:58 <Phyx-> thanks
07:41:00 <ksf> well, it's not like reactive isn't working... it's the Monoid etc. Event instances that mess up everything if you do something complex.
07:41:14 <ksf> suddenly, events just don't propagate, or lag beyond comparison.
07:41:35 <trofi> Phyx-: even ghc-6.4 has it
07:41:45 <mmorrow> Phyx-: the first version(s) of TH had a lot of difference (wrt the AST) than the current form
07:42:12 <ksf> ...which, in the end, means that I can't use reactive to manage Gtk2hs or wxhaskell.
07:42:22 <mmorrow> like s/Name/String/, reify wasn't an actualy function, the constructors had different names, ...
07:42:31 <dcoutts> Phyx-: it was one of the major new features in ghc-6.0
07:43:43 <trofi> what will wait us in ghc-7.0?
07:44:00 <ksf> ...which reminds me, I should check the reactive mailing list, as well.
07:44:01 <Jedai> trofi: Haskell' !!!
07:44:09 <Axman6> the Quantum computation monad will become standard
07:44:21 <Phyx-> dcoutts: ah ok cool :) i was just wondering since this thing only compiles the submissions with 6.6
07:44:26 <EvilTerran> ah, found it, was thinking of http://www.math.ubc.ca/~cass/graphics/manual/pdf/a1.pdf
07:44:38 <Phyx-> trofi: mind reading abilities
07:44:45 <Baughn> Axman6: "Two operations that are real in the opposite direction cancel out, leaving a no-op"
07:45:02 <ski> (EvilTerran : what's it about ?)
07:45:04 <trofi> Jedai: i thought it's mostly implemented in current ghc along with draft evolution
07:45:18 <trofi> Phyx-: cool :]
07:45:20 <EvilTerran> ski, it's just a reference of the postscript operators
07:45:36 <trofi> Phyx-: and in -8.0 writing respectively?
07:45:49 <EvilTerran> ski, i'm idly plotting writing some kind of ps-generating haskell library
07:45:53 <Jedai> trofi: it is, but it will become the standard, so that wa don't need a gazillion extension to write our hello world
07:46:04 <Axman6> hey, i didn't say it wouldn't be controvertial Baughn :P
07:46:05 <EvilTerran> and i wanted to look at it to give my meandering ideas more context :)
07:46:10 <trofi> \o/
07:46:22 <Phyx-> trofi: time travel/warping/bending abilities
07:46:36 <trofi> :]
07:46:38 <Baughn> EvilTerran: What we need is a way to compile haskell to postscript
07:47:03 <EvilTerran> Baughn, uh... that's *possible*, i guess...
07:47:42 <EvilTerran> i guess your entry point wouldn't be :: IO ()
07:47:52 <EvilTerran> PS monad?
07:47:58 <Baughn> Indeed. It'd be :: [Page]
07:48:28 <Phyx-> GHC stage restriction: `iPrimes' is used in a top-level splice, and must be imported, not defined locally <--- how annoying... anyway to work around that? i need it all in 1 file
07:49:10 <EvilTerran> Phyx-, sadly not; it's to make it impossible to have "foo ... = ... $(foo ...) ..."
07:49:31 <Phyx-> guess i can't use this method either then...
07:49:31 <Phyx-> :(
07:49:46 <EvilTerran> why does it have to be in the same file?
07:50:28 <Phyx-> the submision system only allows 1 file to be pasted in
07:50:32 <Phyx-> and it has to be main
07:50:39 * ski . o O ( `$(foo .. = ..); bar .. = ..$(foo ..)..' ?)
07:50:47 <EvilTerran> does the submission system even support TH?
07:51:11 <Phyx-> it support ghc 6.6.1 all i know
07:51:12 <Phyx-> lol
07:57:34 <mmorrow> Phyx-: you can always just include everything you need inside a splice inside the $(....)
07:57:49 <raimo_> how can I match any string with Parsec?
07:58:05 <mmorrow> , $(let tup xs = tupE (fmap lift xs) in tupE [0..9::Int])
07:58:06 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
07:58:11 <mmorrow> , $(let tup xs = tupE (fmap lift xs) in tup [0..9::Int])
07:58:13 <lunabot>  (0,1,2,3,4,5,6,7,8,9)
07:58:19 <Berengal> After reading through lots of various libraries, I'm thinking maybe a naming convention for classes and class type variables is a good thing
07:58:35 <EvilTerran> raimo_, well, it'll need to know when to stop
07:58:49 <raimo_> http://haskell.pastebin.com/mc437540 this complains that Expected type: GenParser Char () String Inferred type: GenParser Char () Char
07:58:55 <EvilTerran> unless you're going to cover it in "try"s and potentially do lots of backtracking
07:59:12 <raimo_> I wan't to have everything till the end of the string I'm parsing
07:59:13 <mercury^> http://rohanlean.de/pub/fasta.hs -- draft for a new fasta submission. Please read/test and make suggestions.
07:59:36 <mmorrow> Phyx-: so you'd have to include the definition of `iPrimes' inside each $(...) you use it in
08:00:09 <Phyx-> mmorrow: i only use it once, so i could
08:00:16 <Berengal> raimo_, anyToken returns Char, not String. Try many anyToken
08:00:35 <raimo_> ah, thnaks
08:00:37 <raimo_> thanks
08:00:47 <mmorrow> Phyx-: what is this submission thing out of interest?
08:01:10 <Phyx-> mmorrow: https://www.spoj.pl/problems/PRIME1/
08:02:21 <mercury^> Heh, people suggesting Miller-Rabin there.
08:02:36 <mmorrow> haha, so you're just going to generate a massive lookup table? :)
08:02:54 <Phyx-> i did try that, using c# but failed, time limit exceeded, but they were running mono 1.0
08:02:57 <Phyx-> so
08:03:17 <mercury^> Phyx-: what bounds are there on the interval?
08:03:29 <Phyx-> mercury^: they don't say ahead of time
08:03:34 <mmorrow> two numbers m and n (1 <= m <= n <= 1000000000, n-m<=100000)
08:03:40 <Phyx-> but i've seen solutions ~7secs still getting accepted
08:03:47 <mercury^> Ah, then any sieve should work.
08:03:55 <Phyx-> mercury^: oh, i thought you meant time interval
08:05:02 <mercury^> If you want to learn something, have a look at primegen if you want to know how to ace that.
08:05:22 <mercury^> http://cr.yp.to/primegen.html
08:05:33 <EvilTerran> .oO( http://www.primegrid.com ... )
08:05:43 <Phyx-> ah, cool, thanks :)
08:06:11 <mercury^> Anyone had a look at the fasta program yet?
08:06:16 <EvilTerran> (because everyone needs DVDs full of prime numbers :P)
08:06:31 <Phyx-> EvilTerran: lol
08:06:41 <solrize_> phyx, m and n are so close together and so small that you don't have to do anything fancy.  just sieve out the numbers with small divisors, do a miller-rabin test on any that make it through the sieve.
08:07:09 <Phyx-> asus is on crack to think that i'll pay to redownload my mobo usermanual...
08:07:34 <EvilTerran> yarr!
08:07:43 <Phyx-> solrize_: my problem has always been output, the program seems fast enough, it's the outputting of the results that made my earlier attempts slow
08:08:40 <mmorrow> do they not link to the code of previously submitted solutions?
08:09:16 <mmorrow> that's kind of annoying..
08:09:40 <mercury^> mmorrow: maybe you can view them once you solved the problem.
08:10:04 <Phyx-> mmorrow: no, you can never view them afaik
08:10:04 <Deewiant> mercury^: You can't, since the solutions are ranked. (IIRC)
08:10:05 <Phyx-> only your own
08:10:13 <Phyx-> lemme see of the ones i have solved
08:10:19 <mmorrow> :o what fun is that?
08:10:29 <Deewiant> Since they have the ranking, the idea is of course that you can't just copy the best solution
08:10:37 <mercury^> I see.
08:10:37 * mmorrow wonders what the people are doing with this code..
08:10:39 <Deewiant> But yeah, it's a bit annoying.
08:10:46 <Phyx-> nope
08:10:48 <Phyx-> you can't
08:10:50 <Phyx-> lol
08:11:23 <mmorrow> also, how do you know that the entire thing isn't just fixed?
08:11:41 <EvilTerran> because the fnords say so
08:11:46 <EvilTerran> (hail eris!)
08:12:22 <Phyx-> mmorrow: because you do see people passing it
08:12:42 <Phyx-> mmorrow: https://www.spoj.pl/status/PRIME1/
08:13:00 <EvilTerran> mmorrow, anyway, it's on the internet, it *must* be true! :P
08:13:03 <mmorrow> Phyx-: right, but i mean in principle
08:13:10 * Berengal wonders if a wheel would be useful
08:14:04 <Phyx-> Berengal: i did try
08:14:06 <Phyx-> exceeded time
08:14:40 <Phyx-> but that's because i used the version on the haskell wiki, and it does 3 operations on the resulting list to filter it and a n^2 one
08:14:47 <Phyx-> i could rewrite that to be mroe efficient i suppose
08:14:56 <ray> read from firstbillionprimes.txt
08:15:11 <mercury^> Using lists for prime generation is a bad idea.
08:15:39 <ray> no, naively using lists for prime generation is a bad idea
08:15:42 <impl> It's nice for the first 65536 or so
08:16:12 <Berengal> I had some success in c with 'for (int i = 0; i < 1000; i++) {if (gcd(n, rand()) != 1) {isPrime = 0; break;}} if (isPrime) {isPrime = miller(n)}'
08:17:37 * Phyx- wonders if anyone passed the PRIME1 using haskell
08:17:43 <Phyx-> all i see are failed attempts
08:18:10 <mercury^> Using bitarrays, with multiples of 2,3,5 (iirc) removed lets you pack 30 numbers into 8 bits.
08:18:31 <impl> http://svn.freebsd.org/viewvc/base/head/games/primes/
08:19:04 <mercury^> Did someone look at http://rohanlean.de/pub/fasta.hs yet?
08:19:48 <Igloo> Phyx-: I have, apparently
08:20:20 <Phyx-> Igloo: really? just now?
08:20:33 <Igloo> Phyx-: No, in 2004
08:20:38 <Phyx-> ah
08:20:40 <Phyx-> lol
08:20:59 <Phyx-> i was thinking... i can't suck that much :P
08:31:49 <mightybyte> Looks like the RWH book website is down.
08:34:39 <dschoepe> mightybyte: the google cache works
08:50:57 <Vanadium> How do I use STUArrays in a ST from Control.Monad.ST.Lazy?
08:51:30 <olsner> using the ordinary MArray interfaces?
08:52:46 <Vanadium> Apparently STUArrays with the lazy ST are not instances of MArray :\
08:52:55 <olsner> aah, the ST is a different ST
08:53:12 <olsner> strictToLazyST looks like it could be what you're looking for
08:53:20 <Vanadium> Hm
08:53:48 <Vanadium> I suspect not
08:53:53 <Vanadium> Ah, I see
08:53:55 <Vanadium> Thanks
08:55:31 <Jedai> @type strictToLazyST
08:55:35 <lambdabot> Not in scope: `strictToLazyST'
08:55:50 <EvilTerran> ?hoogle strictToLazy
08:55:51 <lambdabot> Control.Monad.ST.Lazy strictToLazyST :: ST s a -> ST s a
08:56:09 <EvilTerran> whee, name ambiguity
09:04:06 * byorgey makes lambda-garlic mashed potatoes
09:07:46 <osfameron> mmm, lambda-garlic
09:09:14 <Philonous1> this is crazy stuff: http://perception.inf.um.es/~aruiz/dynamic.avi
09:10:05 <dolio> What is it?
09:10:42 <Philonous1> Augmented reality with haskell easyVision
09:11:32 <EvilTerran> hurray for augmented reality
09:16:14 <mmorrow> http://perception.inf.um.es/~aruiz/darcs/
09:21:39 <poe> mmorrow: is visualball included? :)
09:23:07 <mmorrow> poe: not sure, but maybe :)
09:23:34 * mmorrow was just browsing the directory tree on that webserver after watching the video
09:24:15 <poe> README says it requires IPP to build. uhm.
09:32:25 <mmorrow> , utf8dec "\239\187\191"
09:32:27 <lunabot>  "\65279"
09:32:44 <mmorrow> , flip showHex [] 65279
09:32:45 <lunabot>  "feff"
09:34:01 <mmorrow> , characterClass '\xfeff'
09:34:02 <lunabot>  luna: Not in scope: `characterClass'
09:34:32 <mmorrow> , generalCategory '\xfeff'
09:34:33 <lunabot>  Format
09:34:54 <dmwit> err
09:35:39 <mmorrow> apparently windows stuff inserts that char as the first char in unicode files
09:36:08 <mmorrow> breaking programs that try to parse said files..
09:36:10 <EvilTerran> mmorrow, that'll be the byte-order mark
09:36:19 <mmorrow> EvilTerran: ray just enlightened me
09:36:35 <EvilTerran> it's the programs' fault
09:36:36 <EvilTerran> :P
09:36:43 <mmorrow> EvilTerran: which program?
09:37:09 <mmorrow> the producer of the file with that char in it, or the prog trying to parse the resulting file?
09:37:13 <ray> initial BOMs should really be ignored
09:37:26 <EvilTerran> i mean, the BOM is standard, so it's the programs that break which're at fault for breaking
09:37:43 <mmorrow> maybe `tred' still asplodes without it..
09:37:49 <mmorrow> (haven't tried)
09:38:10 <byorgey> hi all, maybe a silly question, but for anyone who has been to ICFP before, how do people usually dress?
09:38:14 <EvilTerran> although it's probably more the unicode consortium's fault for suggesting initial ZWNBs for these things when that was exceptionally likely to make older code fall over
09:38:27 <mmorrow> , text "\239\187\191"
09:38:28 <lunabot>  
09:38:53 <mmorrow> i guess trying to copy-paste it is futile
09:39:03 <jungehexe> hallo i'm a haskell newbie and i need help: i'm trying to catch primitive events as in Hudaks example: -- is  key 'a'  pressed
09:39:04 <jungehexe> isA:: Maybe UserAction ->Bool
09:39:04 <jungehexe> isA (Just (Key a True)) = True
09:39:04 <jungehexe> isA _ = False
09:39:08 <ray> yeah, it has zero width
09:39:10 <mmorrow> oh i got it
09:39:21 <ray> you'll need buffer maniuplation or something
09:39:23 <jungehexe> but i' somehow can' imagine how to test it
09:39:27 <mmorrow> , eval "\239\187\191 42"
09:39:31 <lunabot>  luna: lexical error at character '\187'
09:39:40 <mmorrow> , eval (utf8dec "\239\187\191 42")
09:39:42 <lunabot>  luna: lexical error at character '\65279'
09:39:44 <jungehexe> sorry of the question is doof
09:39:54 <mmorrow> i guess ghc also doesn't handle it
09:40:31 <yitz> EvilTerran: it's not the consortium's fault. they were just codifying after the fact an MS "embrace and extend".
09:40:39 <mmorrow> jungehexe: you probably need to do 'a'
09:40:50 <mmorrow> jungehexe: isA (Just (Key 'a' True)) = ..
09:41:20 <mmorrow> otherwise you'd be binding whatever Char that happened to be to the name "a"
09:41:27 <jungehexe> mmorrow: and how to catch the space key than?
09:41:31 <mmorrow> ' '
09:41:34 <jungehexe> ah ok
09:41:56 <mmorrow> (i'm guessing, but that makes sense)
09:41:57 <jungehexe> mmorrow: thanks
09:41:59 <mmorrow> np
09:45:44 <jungehexe> mmorrow: sorry for troubling more - and how do icatch  special keys als enter, shift etc?
09:46:18 <mmorrow> jungehexe: i'm not sure, haven't ever used that code before. but taking a guess, there's probably another data constructor like "Key" for those
09:46:37 <mmorrow> jungehexe: isA (Just (Meta Alt (Key 'a' True))) -- or something
09:47:23 <mmorrow> data KeyPress = Key Char Bool | Meta MetaChar KeyPress | .... -- or sometihng
09:47:33 <mmorrow> data MetaChar = Alt | Ctrl | ...
09:48:04 <mmorrow> bear in mind i just made that up and the actual implementation is most certainly different
09:49:29 <jungehexe> mmorrow: Meta Alt (Key 'a' True)) should be smth like alt and a pressed together?
09:50:19 <jungehexe> mmorrow: i see that u make it up :) but it helps me to get throug hthe structures
09:51:02 <jungehexe> although how it's actually implemented is also a good question
09:52:13 <Zharf> hi, I've been reading http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot  while trying to learn haskell, there's a line "loop st    = catch (runReaderT run st) (const $ return ())
09:52:19 <Zharf> " around halway through
09:52:40 <Zharf> and ghc doesn't like it at all, saying Ambiguous type variable `b' in the constraint: ...
09:53:07 <Zharf> I've no idea how I should fix it <.<
09:53:42 <gwern> my usual heuristic is to remove all type sigs and see how the inferred type differs from my written type
09:54:20 <mmorrow> jungehexe: "Meta Alt (Key 'a' True)) should be smth like alt and a pressed together?"
09:54:23 <mmorrow> jungehexe: exactly
09:54:42 <dmwit> :t bracket
09:54:49 <lambdabot> Not in scope: `bracket'
09:54:59 <dmwit> :t Control.Exception.bracket
09:55:01 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:55:14 <jungehexe> (Just (Key 'i' True))
09:56:01 <jungehexe> sorry didn' mean to paste it
09:56:05 <dmwit> Zharf: My guess is just that you need to give "run" a less polymorphic type signature.
09:56:58 <dmwit> like "run :: Net ()" or something like that
09:57:33 <dmwit> ...which it seems to have already.
09:57:33 <dmwit> hum
09:57:37 <Zharf> yeah
09:57:58 <vav> Zharf: import Control.OldException rather than Control.Exception I think
09:58:15 <dmwit> Oh, that sounds believable.
09:58:23 <Zharf> vav, ahah that compiles
09:58:55 <vav> tutorial is likely older than base-4
09:59:36 <Zharf> I need to research more at some point on this
09:59:51 <dmwit> Perhaps somebody (not it!) should update it.
10:01:07 <Zharf> dmwit, I would if I can figure this thing out eventually :)
10:27:09 <byorgey> dcoutts: ping
10:27:17 <dcoutts> byorgey: pong
10:27:45 <dmwit> *poke*
10:27:49 <byorgey> dcoutts: will there be sheets/linens in the flat, or should I bring my own?
10:28:06 <dcoutts> byorgey: good question, I'll check and get back to you
10:28:11 * byorgey pokes dmwit back
10:28:18 <byorgey> dmwit: shouldn't you be asleep?
10:28:21 * dmwit pukes
10:28:24 <dmwit> byorgey: =)
10:28:28 <dmwit> byorgey: I was mostly joking. =)
10:30:24 <byorgey> dmwit: ah =)
10:30:51 <byorgey> dcoutts: ok, as long as you let me know within the next four hours or so, which is when I leave for the airport =)
10:30:59 <byorgey> er, five hours
10:31:02 <dcoutts> byorgey: oh, um.
10:31:28 <byorgey> if that's not possible then maybe I'll just bring some in case.
10:31:34 <dcoutts> byorgey: ok I'll find out or give you my best guess
10:31:39 <byorgey> ok, thanks =)
10:32:01 * dmwit starts composing a new country song: "Just in case, in mah suitcase"
10:32:23 <byorgey> dcoutts: I'm going to the summer school first, hence the early departure
10:32:28 <dcoutts> byorgey: I see
10:33:41 <mc___> is there a built in function which produces the cartesian product of two lists until a certain criteria is met?
10:34:06 <dcoutts> mc___: list comprehensions ftw!
10:34:48 <dmwit> mc___: Do you need infinite products?
10:34:49 <mc___> dcoutts: alright, I'll try :)
10:34:58 <mc___> dmwit: nope
10:34:59 <dmwit> If not, list comprehensions + takeWhile works just fine.
10:35:03 <dmwit> great =)
10:39:11 <cadabra> In Text.Regex.Posix, can I use parens without creating a group?
10:42:52 <cadabra> That is, I need to mark a subexpression without creating a capture group.
10:43:30 <cadabra> I believe the pattern elsewhere was something like (:? ... )
10:44:25 <EvilTerran> perl uses (?: ... ), as (? ... : ... ) is a grouping with options in the first ... (and no capture)
10:45:02 <cadabra> Ah, thanks.
10:45:34 <EvilTerran> ie, (?i: ... ) would be a case-insensitive grouping
10:45:40 <dmwit> It still boggles me that whoever first did regexen decided that parens should be used for both grouping and capture.
10:45:53 <EvilTerran> but that's not posix regex, that's pcrs, so i doubt it'll be the same
10:47:33 <Twey> dmwit: Yeah, it is a tad nuts.
10:48:32 <cadabra> What boggles me a tad is that ghc _does_ ship regex support, but that support is posix rather than pcre.
10:49:16 <Twey> cadabra: http://swtch.com/~rsc/regexp/regexp1.html
10:49:43 <dmwit> Isn't there a PCRE library on hackage?
10:50:16 <||Zero||> hello im here again
10:50:35 <dmwit> Oh noes!
10:50:48 <||Zero||> main = do
10:50:48 <||Zero||>   (progname, _) <- getArgsAndInitialize
10:51:02 <||Zero||> ca someone explain me what this lines do exactly
10:51:19 <||Zero||> (progname, _) <- getArgsAndInitialize
10:51:39 <dmwit> It's equivalent to
10:51:55 <dmwit> getArgsAndInitialize >>= \(progname, _) ->
10:52:04 <dmwit> Does that answer your question, or do you need more?
10:52:28 <||Zero||> i think a little more
10:52:38 <dmwit> getArgsAndInitialize is a monad action returning a tuple; this line runs the action, discards the second half of the tuple, then continues.
10:53:40 <cadabra> So "<- ..." is running the action. "(progname, _)" is doing pattern matching on the result, and binding the first item in the tuple to "progname"
10:53:50 <Twey> cadabra: PCRE suffers from that, POSIX doesn't (IIRC)
10:54:11 <dmwit> (Actually, to be precise, the action isn't being run, but *composed*.)
10:55:50 <cadabra> Twey: suffers from what? Lack of non-capturing groups?
10:56:10 <||Zero||> (progname,_)->
10:56:13 <||Zero||> what is it
10:56:22 <dmwit> cadabra: speed, I think
10:56:38 <dmwit> ||Zero||: As written, that's an error.
10:56:48 <Twey> 18:49:16 < Twey> cadabra: http://swtch.com/~rsc/regexp/regexp1.html
10:56:52 <dmwit> ||Zero||: However, with a \ in front, it becomes an anonymous function.
10:57:07 <Twey> PCRE is monstrously inefficient on some patterns
10:57:13 <||Zero||> what does it do exactly
10:57:13 <dmwit> (i.e. a function which just happens not to have a name)
10:57:42 <dmwit> ||Zero||: It's exactly the same as (let foo (progname,_) = ... in foo), but without binding the name foo. =)
10:57:57 <cadabra> Fair enough.
10:58:05 <dmwit> > (\x -> x + 1) 3
10:58:07 <lambdabot>   4
10:58:09 <mc___> what can I do when I need to get the element at which takeWhile stops?
10:58:16 <dmwit> > (let succ x = x + 1 in succ) 3
10:58:18 <lambdabot>   4
10:58:31 <dmwit> mc___: cry
10:58:37 <Heffalump> head . dropWhile
10:58:51 <Twey> cadabra: Try in Python: re.match("a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
10:58:53 <dmwit> mc___: Try span
10:59:01 <Twey> And settle in to wait :
10:59:08 <dmwit> mc___: (If you want both the ones you took as well as the ones you didn't take.)
10:59:27 <dschoepe> mc___: head . dropWhile (not . p)
10:59:37 <Twey> (Java/Python/Perl/Ruby/PHP/&c.)
10:59:43 <mc___> I only need the one I didn't take, thanks for your respones!
11:00:07 <dschoepe> (beware that head is a partial function)
11:00:12 <||Zero||> import Graphics.Rendering.OpenGL
11:00:12 <||Zero||> import Graphics.UI.GLUT
11:00:12 <||Zero||> main = do
11:00:12 <||Zero||>   (progname, _) <- getArgsAndInitialize
11:00:12 <||Zero||>   createWindow "Hello World"
11:00:13 <||Zero||>   mainLoop
11:00:23 <||Zero||> in thsi code wht exactly do
11:00:27 <||Zero||> (progname, _) <- getArgsAndInitialize
11:00:30 <||Zero||> that line
11:00:32 <dmwit> ||Zero||: In the future, please use hpaste.
11:00:33 <dmwit> ?hpaste
11:00:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:00:45 <Vanadium> ||Zero||: Syntax sugar for the >>= operator.
11:01:08 <Twey> ||Zero||: You need a more thorough understanding of monads to comprehend it properly.  To that end, I recommend http://haskell.org/haskellwiki/Monads_as_computation
11:01:27 <dmwit> ||Zero||: Also, perhaps you should read the documentation for getArgsAndInitialize.  It's the only way to know exactly what that code does. =)
11:01:33 <Twey> ||Zero||: If you just want to use it, you can think of it as an imperative-style assignment.
11:02:51 <||Zero||> i only want to use but but when my teacher ask me what is that
11:03:00 <||Zero||> what can i say
11:03:50 <Twey> You can say it's getting the arguments to the program and initialising SDL, and extracting the program name from the return value.
11:04:10 <dmwit> ||Zero||: Study up on the IO monad and on the OpenGL library, then you'll be able to answer your teacher well. =)
11:04:25 <dmwit> ?go the io monad for people who just don't care
11:04:26 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
11:04:27 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
11:04:40 <dmwit> ?go hopengl
11:04:41 <lambdabot> http://www.haskell.org/HOpenGL/
11:04:59 <dmwit> Actually, I wonder if that's part of gtk2hs.  In which case
11:05:02 <dmwit> ?where gtk2hs
11:05:02 <lambdabot> http://haskell.org/gtk2hs/
11:05:43 <EnglishGent> hello :)
11:05:53 <dcoutts> dmwit: the OpenGL package is not part of gtk2hs, but you can use them together instead of using GLUT.
11:06:07 <dcoutts> gtk2hs provides a "GL in a widget" thing
11:06:18 <dmwit> ah
11:06:27 <dmwit> EnglishGent: Cheerio, chap!
11:06:33 <dcoutts> dmwit: then you use the normal OpenGL package to do the drawing in that widget
11:07:53 <EnglishGent> hi dmwit :)
11:08:40 <mercury^> http://rohanlean.de/pub/fasta.hs -- draft for a new fasta submission. Please read/test and make suggestions.
11:09:53 <Deewiant> mercury^: "cannot eta reduce here?!?"?
11:10:02 <mercury^> Yes, try it.
11:10:11 <Deewiant> Oh, you mean it's a type error?
11:10:15 <mercury^> Yep.
11:10:21 <Deewiant> {-# LANGUAGE NoMonomorphismRestriction #-}
11:10:32 <mercury^> That thing is starting to annoy me. :)
11:10:38 <Deewiant> :-P
11:11:49 <||Zero||>  http://www.haskell.org/HOpenGL/
11:12:35 <||Zero||> displayCallback $= clear [ ColorBuffer ]
11:12:47 <||Zero||> what this line do
11:12:53 <||Zero||> does
11:13:01 <dmwit> ||Zero||: READ THE DOCS
11:13:38 <||Zero||> what docs
11:13:46 <copumpkin> o.O
11:13:54 <Deewiant> Didn't you just link to them?
11:13:55 <dmwit> http://hackage.haskell.org/package/OpenGL-2.3.0.0 ?
11:13:57 <Deewiant> I.e. HOpenGL
11:16:14 <EvilTerran> dmwit, there's very little in the haddocks beyond type signatures and cross-references to the opengl spec
11:16:42 <dmwit> I refuse to believe that OpenGL has no docs anywhere on the net.
11:16:44 <Deewiant> Then read the OpenGL spec :-P
11:16:45 <mux> I really wish those were in Data.List : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8491#a8491
11:16:53 <dmwit> I reject your reality and substitute my own.
11:17:46 <||Zero||> kind of dificult cause im not a english speaker
11:18:10 <Vanadium> ||Zero||: Become one
11:18:22 <||Zero||> displayCallback $= clear [ ColorBuffer ]
11:18:23 <Zao> ||Zero||: displayCallback is much similiar to the thing with similiar name in GLUT.
11:18:27 <dmwit> I bet there's OpenGL docs in other languages, too. =)
11:18:35 <Vanadium> OffenGL
11:18:41 <Zao> $= is state variable assignment in this case.
11:18:43 <||Zero||> but in a few words what this line does
11:19:04 <Zao> If you read the docs, you see that displayCallback wants an IO () action to call whenever it feels it needs to redisplay.
11:19:20 <Zao> In this case, the action is the expression (clear [ ColorBuffer])
11:20:07 <||Zero||> clear [colorBuffer]
11:20:19 <Zao> Case matters.
11:20:20 <||Zero||> what does it do
11:20:21 <Deewiant> mux: pairWith f = concatMap (\(x:xs) -> zipWith f (repeat x) xs) . init . tails
11:20:29 <Zao> ||Zero||: You tell me, you have the documentation.
11:20:47 <Zao> Look up the definition of glClear in the OpenGL specification.
11:20:50 <Vanadium> It clears the colorBuffer so that you can start with new colors
11:20:55 * Baughn wonders if anyone here would be interested in a distributed group membership protocol, with unicast messages and encryption
11:21:15 <Zao> In the native world glClear takes a bitfield of things to clear.
11:21:27 <Zao> Which is one of colorbuffer, depth and stencil, if memory serves me right.
11:21:33 <mux> Deewiant: yeah, I thought the version with explicit recursion was a bit clearer
11:21:33 <||Zero||> so i can write a color there
11:21:36 <Zao> No.
11:21:45 <Zao> That's what glClearColor is for, setting the clear color.
11:21:55 <||Zero||> oke
11:21:55 <Zao> ||Zero||: I strongly recommend reading up on OpenGL itself.
11:22:02 <Deewiant> mux: I couldn't gather an intuition for what it did just from that either, without trying that ;-)
11:22:05 <Baughn> ||Zero||: And also joining #opengl. ;)
11:22:06 <Zao> ||Zero||: http://nehe.gamedev.net is an OK introduction.
11:22:12 <mux> Deewiant: heh, oh well :)
11:22:17 <EvilTerran> ?type \f -> zipWith f <*> drop 1
11:22:21 <Zao> As is the Red Book.
11:22:21 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
11:22:28 <EvilTerran> mux, owzat? ^
11:22:45 <mux> wow.
11:22:54 <EvilTerran> (or, if you prefer, pairWith f xs = zipWith f xs (drop 1 xs)
11:23:07 <Deewiant> EvilTerran: Not the same thing.
11:23:13 <mux> ah, yeah, not the same
11:23:25 <EvilTerran> oh, sorry, assumed an implementation from the type signature :P
11:23:33 <EvilTerran> (and the name)
11:23:39 <mux> djinn tends to do that :-P
11:23:43 * EvilTerran must practice reading the question
11:23:47 <mux> pair selects all distinct pairs from the list
11:23:56 <Vanadium> Does gtk2hs let you draw with cairo?
11:24:02 <EvilTerran> mux, distinct indexwise?
11:24:09 <mux> yeah, only indexwise
11:24:18 <mux> they are not compared, as the type signature shows by lacking an Eq constraint
11:24:29 <EvilTerran> i thought so :)
11:24:57 <mux> pairWith is just the obvious higher-order generalization
11:25:03 <||Zero||> mainLoop
11:25:07 <||Zero||> ??
11:25:25 <EvilTerran> > let pairWith f xs = [(x,y) | x:ys <- tails xs, y <- ys] in pairWith (,) "abc"
11:25:26 <lambdabot>   [('a','b'),('a','c'),('b','c')]
11:25:37 <dmwit> damn, beat me to it
11:25:44 <dmwit> I was going to suggest the "tails" approach =P
11:25:51 <EvilTerran> yay list comprehensions
11:25:55 <mux> nice one
11:25:59 <dmwit> Also, you want f x y, not (x, y).
11:26:05 <dcoutts> Vanadium: yes
11:26:14 <EvilTerran> the specifics of how that "x:ys" pattern-match works out is surprisingly important, there
11:26:19 <Vanadium> Awesome
11:26:22 <EvilTerran> dmwit, yeah, of course :P
11:26:50 * ||Zero|| slaps Zao around a bit with a large trout
11:26:50 <Deewiant> EvilTerran: Yes, it lets you avoid the "init" I had to use
11:26:57 <||Zero||> sorry
11:27:02 <mercury^> Deewiant: I updated it a bit. Anything you noted while reading or running it?
11:27:09 <||Zero||> i didnt know what was that
11:27:19 <Zao> ||Zero||: How about looking up anything you do not recognize?
11:27:20 <mux> the nice thing with my variant was that I didn't have to worry about the extraneous [] :-)
11:27:28 <||Zero||> Zao the tutorial is for visual c++
11:27:45 <Deewiant> mux: But you do manual recursion, which is much worse in any case ;-)
11:27:52 <Deewiant> mercury^: I didn't really look at it much, that comment just popped out at me :-P
11:27:53 <Zao> ||Zero||: The OpenGL concepts largely carry over.
11:28:00 <mux> heh
11:28:08 <mux> Deewiant: my version seems faster in GHCi, too :-P
11:28:11 <EvilTerran> mux, that's what i meant about the "x:ys" pattern - because it's in a comprehension, the pattern-match failure turns into []
11:28:17 <jpcooper> could anyone direct me on a guide on importing modules in different directories? For some reason, I haven't been able to figure it out
11:28:21 <mux> EvilTerran: *nods*
11:28:21 <Deewiant> mux: GHCi doesn't count for anything, it does no optimization of any kind. :-P
11:28:21 <jpcooper> me to*
11:28:28 <EvilTerran> > [() | False <- [False]]
11:28:30 <lambdabot>   [()]
11:28:31 <EvilTerran> > [() | False <- [True]]
11:28:33 <lambdabot>   []
11:28:44 <mux> this is also how mapMaybe works
11:28:47 <mux> @src mapMaybe
11:28:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:28:51 <mux> ah, too bad.
11:28:56 <EvilTerran> ?src Maybe fmap
11:28:56 <||Zero||> mainLoop
11:28:57 <lambdabot> fmap _ Nothing       = Nothing
11:28:57 <lambdabot> fmap f (Just a)      = Just (f a)
11:29:01 <Baughn> ||Zero||: The haskell opengl bindings have a /little/ better interface, but it's mainly the same thing
11:29:01 <||Zero||> what this line oes
11:29:06 <mux> pattern match failures are surprisingly useful with lists
11:29:20 <Baughn> ||Zero||: And if you use OpenGLRaw, they're the exact same thing as the C bindings
11:29:23 <EvilTerran> mux, would that be "mapMaybe f xs = [y | Just y <- map f xs]"?
11:29:48 <mux> yup
11:29:49 <EvilTerran> ?src catMaybes
11:29:50 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:29:54 <Zao> ||Zero||:
11:29:55 <Zao> http://hackage.haskell.org/packages/archive/GLUT/2.2.1.0/doc/html/Graphics-UI-GLUT-Begin.html#v%3AmainLoop
11:30:04 <Zao> That's the fine manual. I recommend you read it.
11:30:24 <jpcooper> no one at all?
11:30:54 <dmwit> jpcooper: The module name must match the directory hierarchy.
11:31:03 <dmwit> Foo.Bar.Blag must go in Foo/Bar/Blag.hs
11:31:03 <EvilTerran> dmwit, isn't that only with --make?
11:31:15 <jpcooper> dmwit, it is
11:31:17 <dmwit> Otherwise, check out the -i argument to ghc.
11:31:33 <dmwit> jpcooper: What error are you getting, exactly?
11:31:49 <EvilTerran> i thought you could just name the files of all the required modules, and ghc would ignore the file names once it'd pulled the module names out of 'em
11:31:52 <jpcooper> Could not find module `Chat.Core.Interface'
11:32:02 <jpcooper> Chat.Handler.Interface is trying to import the previous
11:32:18 <dmwit> From which directory are you running ghc?
11:32:20 <Baughn> EvilTerran: It tends to give me errors if the filename doesn't match the module name
11:32:29 <dmwit> (Is it the directory that has Chat/ in it?)
11:32:29 <jpcooper> the names of the modules are "Chat.Core.Interface" and "Chat.Handler.Interface"
11:32:32 <Baughn> There may be a switch to override that, I suppose
11:32:35 <jpcooper> hmm maybe not
11:32:40 <dmwit> jpcooper: ;-)
11:33:11 <jpcooper> do you know how to find out where it is?
11:34:11 <dmwit> ...where what is?
11:34:23 <||Zero||> so in my code mainLoop will call as necessary any callbacks that have been registered
11:34:35 <EvilTerran> jpcooper, er, pwd?
11:34:51 <jpcooper> I did try :pwd. I'll have a look in System.Directory
11:35:00 <dmwit> Wait. Stop.
11:35:03 <dmwit> What are you doing?
11:35:15 <jpcooper> @hoogle pwd
11:35:16 <lambdabot> No results found
11:35:27 <Deewiant> ?hoogle getCurrentDirectory
11:35:27 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
11:35:28 <jpcooper> dmwit, I'm trying to make ghci tell me which directory it is in
11:35:33 <dmwit> Why?
11:35:49 <jpcooper> I just want to know
11:36:18 <jpcooper> I suppose that emacs starts in the file's directory
11:37:45 <||Zero||> myPoints :: [(GLfloat,GLfloat,GLfloat)]
11:37:59 <||Zero||> GLfloat means thatthis is from Open GL
11:38:01 <Baughn> ||Zero||: Yes. By the way, are you on linux?
11:38:16 <||Zero||> no im n windows
11:38:22 <EvilTerran> jpcooper, if you're in ghci and want to know the current directory, ":!pwd" should do it
11:38:32 <jpcooper> thanks
11:38:45 <EvilTerran> altho note that doing ":!cd ..." won't stick, that's why there's a :cd
11:39:16 <||Zero||> myPoints = map (\k -> (sin(2*pi*k/12),cos(2*pi*k/12),0.0)) [1..12]
11:39:28 <||Zero||> in thsi line k will be 1 until 12
11:39:40 <EvilTerran> ":!cd ..." = fork a process, which changes its working directory, then stops :P
11:40:11 <EvilTerran> 2*pi*k/12 = pi*k/6 ...
11:40:44 <||Zero||> yeah but
11:40:54 <||Zero||> k will tke the values 1 until 12
11:41:11 <Baughn> That's the idea, yes
11:41:14 <||Zero||> ???
11:41:27 <Baughn> ||Zero||: Yes, it does. What's your question?
11:41:30 <||Zero||> so i can get the points
11:42:19 <Baughn> > [(sin (2*pi*k/12), cos (2*pi*k/12)) | k <- [1..12]] - You may prefer this syntax
11:42:22 <lambdabot>   Not in scope: data constructor `You'Not in scope: `may'Not in scope: `prefe...
11:42:36 <Baughn> > [(sin (2*pi*k/12), cos (2*pi*k/12)) | k <- [1..12]] -- Now with bonus comments
11:42:38 <lambdabot>   [(0.49999999999999994,0.8660254037844387),(0.8660254037844386,0.50000000000...
11:43:08 <||Zero||> jeje
11:43:09 <||Zero||> <||Zero||> k will tke the values 1 until 12
11:43:10 <||Zero||> <Baughn> That's the idea, yes
11:43:10 <||Zero||> <||Zero||> ???
11:43:10 <||Zero||> <Baughn> ||Zero||: Yes, it does. What's your question?
11:43:10 <||Zero||> <||Zero||> so i can get the points
11:43:15 <||Zero||> sorry
11:43:22 <||Zero||> dont read that
11:43:29 <Baughn> ..please end your next sentence with a question mark.
11:46:05 <||Zero||> renderPrimitive Points $ mapM_ (\(x, y, z)->vertex$Vertex3 x y z) myPoints
11:46:12 <||Zero||> what this line does???
11:46:28 <||Zero||> renderPrimitive Points???
11:48:08 <EvilTerran> ||Zero||, you mentioned earlier that you are not an english speaker. you may have more luck on one of the channels listed at http://haskell.org/haskellwiki/IRC_channel#Related_channels where people speak the same language as you
11:48:29 <EvilTerran> (if there is a haskell channel for your language)
11:49:12 <||Zero||> yes  but im trying to imprve my english
11:49:39 <gwern> can't blame the bloke for that
11:50:49 <||Zero||> can someone explain me what that line does
11:51:20 <gwern> I wonder why renderPrimitive is happy to take a []?
11:51:56 <||Zero||> renderPrimitive Points $ mapM_ (\(x, y, z)->vertex$Vertex3 x y z) myPoints
11:52:03 <||Zero||> ??? please explain me
11:52:16 <gwern> :t mapM_
11:52:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:52:33 <gwern> ||Zero||: so the second argument to renderPrimitive is obviously just m()
11:52:48 <gwern> and Points is I'm guessing part of an abstract datatype
11:53:31 <gwern> ||Zero||: you understand ADTs like data Foo = Bar | Qux?
11:53:36 <Baughn> Correct. Points tells it what sort of primitive to render, in this case meaning "light up one pixel per vertex" or so
11:53:49 <||Zero||> vertx$Vertex3
11:54:28 <ksf> how do I "pass" a type annotation into a function?
11:54:29 <gwern> well, you usually only call mapM_ for sideeffects; maybe vertex does some IO?
11:54:43 <gwern> ksf: you mean like 'foo (1::Int)'?
11:54:56 <Zao> A wild guess would be that it's the analogue of glVertex.
11:54:57 <ksf> yep, though 1 is a variable.
11:55:08 * gwern thinks you can do it just like that
11:55:18 <ksf> ...and I don't want to have that variable on the caller-side.
11:55:27 <gwern> > let foo x = id x in foo (1::Int)
11:55:29 <lambdabot>   1
11:55:29 <ksf> ...but I need the type annotation to fix the class instance
11:55:41 <gwern> > let x = 1 in let foo x = id x in foo (x::Int)
11:55:42 <lambdabot>   1
11:56:14 <||Zero||> so that line will put the points in the map in this case in the window
11:56:15 <Zao> renderPrimitive takes a primitive type and an IO a in which you're only allowed a subset of GL actions.
11:56:28 <Zao> Other OpenGL wrappers enforce that invariant with proper monads.
11:56:40 <Baughn> So.. renderPrimitive calls glBegin or some such
11:56:56 <ksf> more like let foo t = bar (x :: t) in (foo Int)
11:56:56 <Zao> Baughn: Matched pair of Begin/End, with the provided action inbetween.
11:57:02 <Baughn> That's going to be *slow*, then
11:57:07 <Zao> http://cvs.haskell.org/Hugs/pages/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BeginEnd.html#v%3ArenderPrimitive
11:57:13 <Baughn> I figured it'd use glDrawArrays at least
11:57:18 <Zao> Baughn: As he's just picking up OpenGL, I doubt performance is remotely relevant.
11:57:24 <Baughn> ..true, I guess
11:57:40 <Baughn> Zao: On the other hand, is glBegin still part of gl 3, even?
11:57:49 <Zao> Probably.
11:58:01 <Zao> Unless you use one of the magical deprecation-fu thingies.
11:58:37 <||Zero||> SO IN THE ALL the code what this line do
11:59:06 <Baughn> Draws the points you pass to it, I should think.
12:00:02 <Zao> ||Zero||: It calls glBegin with the specified primitive type, performs the IO action you pass in, and calls glEnd.
12:00:05 <ksf> ...I can fix one type of the class by providing signatures for foo's result, but I need to fix the second one, too: I'm trying to do dlFun ("fopen" :: IO Int) :: IO Fd
12:00:13 <Zao> As for the IO action, it's a sequence of glVertex, glColor, etc calls.
12:00:21 <Zao> If you do not know what they do, read the Red Book.
12:00:23 <ksf> ...with marshalling and dlopening done by typeclasses.
12:00:48 <ksf> but then, I guess I'm just overkilling things.
12:01:06 <ksf> (as usually when I use any language pragmas, at all)
12:03:01 <||Zero||> what does vertex$Vertex3 do
12:03:56 <Zao> $ is function application with low precedence.
12:04:03 <gwern> Vertex3 is a type defined as containing 3 nums, like 'data Vertex3 = Vertex3 Int Int Int' or something; so 'Vertex3 x y z' creates a value, and 'vertex' consumes it
12:04:15 * EvilTerran envisages gratuitous syntactic sugar
12:04:19 <Zao> vertex (Vertex3 0.1 0.2 0.3)
12:04:38 <Zao> A call to glVertex with a value constructed with Vertex3.
12:07:54 <EvilTerran> f $ x = f x
12:11:25 <mercury^> $ = id
12:11:43 <Milo-> is there a mirror for RWH book?
12:11:54 <Deewiant> Yes: Google's cache
12:11:55 <Milo-> would like to carry on reading while the site is offline :(
12:12:18 <Milo-> should have downloaded the package :P
12:13:42 <dmwit> There's a dead-tree edition, you know. =P
12:17:54 <||Zero||> import Graphics.Rendering.OpenGL
12:17:54 <||Zero||> import Graphics.UI.GLUT
12:17:54 <||Zero||> myPoints :: [(GLfloat,GLfloat,GLfloat)]
12:17:54 <||Zero||> myPoints = map (\k -> (sin(2*pi*k/12),cos(2*pi*k/12),0.0)) [1..12]
12:17:54 <||Zero||> main = do
12:17:54 <||Zero||>   (progname, _) <- getArgsAndInitialize
12:17:56 <||Zero||>   createWindow "Hello World"
12:17:58 <||Zero||>   displayCallback $= display
12:18:00 <||Zero||>   mainLoop
12:18:02 <||Zero||> display = do
12:18:04 <||Zero||>   clear [ColorBuffer]
12:18:06 <||Zero||>   renderPrimitive Points $ mapM_ (\(x, y, z)->vertex$Vertex3 x y z) myPoints
12:18:07 <Milo-> pastebin?
12:18:08 <||Zero||>   flush
12:18:10 <||Zero||> what i need to change here
12:18:12 <||Zero||> to create triangles
12:19:49 <selbram>   renderPrimitive Triangles $ mapM_ (\(x, y, z)->vertex$Vertex3 x y z) myPoints
12:20:07 <selbram> does that work?
12:20:35 <||Zero||> let me see
12:22:25 <||Zero||> yes it works
12:22:42 <||Zero||> so it nly join the points to make triangles
12:22:51 <selbram> yes
12:25:54 <jfoutz> any suggestions for an abstract algebra book or online course?
12:27:10 <kaol> what's your background?
12:28:03 <jfoutz> i've had some calculus, diffeq, linear algebra. out of school for a few years, but fairly comfortable with proofs.
12:28:55 <jfoutz> and discrete math.
12:29:37 <Zao> ||Zero||: Pasting code in the channel is considered rude. Use a paste site like hpaste.org and paste the link to your content.
12:29:56 * ksf suffers the curse of liftIO
12:31:12 <jfoutz> kaol: i was thinking about "the haskell road to logic, maths and programming" not sure how much of that would be new. might be a good refresher though.
12:31:33 <jfoutz> and that's not abstract algebra. :)
12:31:58 <copumpkin> :o
12:32:34 <Stinger> I liked Fraleigh "a first course in abstract algebra"
12:32:44 <ichor> I too used fraleigh.
12:33:22 <Stinger> nicely presented book I thought
12:34:17 <ichor> Yeah, and good exercises.
12:34:59 <Stinger> I'm too lazy for exercises
12:35:04 <jfoutz> hehehe.
12:35:12 <jfoutz> you have to work some problems.
12:35:30 <jfoutz> hmm. i have to work some problems. you may not.
12:35:58 <ichor> Well, fraleigh has more than enough of them.
12:37:30 <jfoutz> ok. looks good to me. thanks.
12:38:17 <Cale> Dummit and Foote is a commonly recommended text
12:39:59 <Stinger> while we're on maths books, someone give me a good book covering Lebesge integration and fourier series (and Laplace if possible)
12:40:07 <Stinger> Lebesgue
12:40:46 <kw317> there was this short book I had.. I think it was Zafrany and someone.. hold on
12:41:07 <Cale> There's a really good free text online called Modern Real Analysis by Ziemer
12:41:31 <kw317> Pinks and Zafrany was OK for my needs
12:42:15 <Cale> It focuses on measure theory and Lebesgue integration and results following in that direction. I don't think it has much Fourier analysis in it though.
12:42:19 <Stinger> bah, RWH has gone up $1 or so since two days ago on amazon
12:42:39 <Raevel> the nerve!
12:43:06 <Stinger> Ideally I would like to get Real and Complex Analysis by Rudin, but I dunno if I can afford it atm
12:43:18 <Cale> I never really got a good treatment of Fourier analysis in undergrad. My prof for the course was bad enough that the department head later apologised to us (privately).
12:43:31 <Stinger> haha ouch
12:44:10 <jfoutz> Cale: in the context self study, any opinion about Dummit and Foote vs Fraleigh?
12:44:14 <Stinger> all my fourier analysis was kind of via maths for engineering
12:44:27 <Cale> I haven't seen Fraleigh myself.
12:44:33 <Stinger> so not hugely rigorous
12:44:38 <jfoutz> ok.
12:47:16 <Cale> jfoutz: But, I'll check it out and compare... there was another one which I wanted to recommend, but the name of the author is escaping me...
12:48:08 <path[l]> hi
12:50:26 <Cale> hi
12:51:39 <Cale> Ah! It was by Artin, right.
12:52:03 <jfoutz> well, there was a nice instructor review of fraleigh. says it's got lots of short chapters with lots of examples, problems aren't to challenging as compared to dummit and foote. so, while likely less thorough, probably an easier introduction for me.
12:52:12 <path[l]> today morning some demonstrated something wierd to me while I was here. Let me see if  I can reproduce that
12:52:39 <path[l]> filterM [const(True),const(True)] [1,2,3,4]
12:52:51 <path[l]> no that looks wrong
12:53:02 <jfoutz> > filterM (const [True,False]) [1..3]
12:53:06 <path[l]> damn I wish this  irc progy kept logs
12:53:08 <lambdabot>   mueval-core: Prelude.read: no parse
12:53:08 <lambdabot>  mueval: ExitFailure 1
12:53:18 <path[l]> ah that looks correct
12:53:20 <mauke> > filterM (return [True, False]) [1..3]
12:53:23 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:53:49 <path[l]> I was wondering how that avoid duplicates?
12:54:06 <mauke> it doesn't
12:54:08 <jfoutz> duplicate what?
12:54:11 <path[l]> but first I needed to look up filterM
12:54:26 <jfoutz> > 1
12:54:27 <lambdabot>   1
12:54:56 <copumpkin> path[l]: the interpretation there is that in the nondeterminism (list) monad, for each element of [1..3], both select and don't select each element
12:55:14 <path[l]> oh
12:55:31 <path[l]> so umm first select the element, then select anything else?
12:55:42 <selbram> its the set of subsets, basically
12:55:50 <mauke> no, for each element select it and don't select it
12:55:56 <copumpkin> path[l]: you select AND don't select it
12:56:15 <mauke> every choice splits the universe in two copies
12:56:24 <||Zero||> Ponts and triangles
12:56:32 <copumpkin> splitRealWorld :: RealWorld -> (RealWorld, RealWorld)
12:56:33 <||Zero||> how GHC recognize then
12:56:34 <copumpkin> ;)
12:56:38 <||Zero||> them
12:56:47 <mauke> snakes and ladders
12:56:57 <||Zero||> renderPrimitive Points $ mapM_ (\(x, y, z)->vertex$Vertex3 x y z) myPoints
12:56:58 <copumpkin> ||Zero||: how do you mean?
12:56:59 <path[l]> I dont follow at all :/
12:57:14 <||Zero||> if i change Points
12:57:21 <||Zero||> and put Triangles
12:57:34 <||Zero||> the image change to Triangles
12:57:35 <copumpkin> path[l]: do you see how the set of subsets of a set is equivalent to binary numbers?
12:58:05 <||Zero||> so Points and Triangles are know by GHC or Opengl
12:58:14 <selbram> renderPrimitive takes a bunch of points and renders them when given Points, and takes sets of three points and turns them into triangles when given Triangles
12:58:24 <Zao> They're primitive types defined by the OpenGL library.
12:58:25 <path[l]> umm actually no. Unless you mean each element of the set is a bit, so any combination of bits is a subset
12:59:11 <Zao> ||Zero||: Yet again, I strongly recommend that you read the Red Book.
12:59:13 <copumpkin> path[l]: well say you have {1,2,3} and you select {2,3}. if you assign each element a bit, that bit can either be on or off, and it specifies whether that element should appear in the output
12:59:25 <Zao> There might be a translated version in spanish or peruvian or whatever your native language is.
12:59:27 <||Zero||> red book
12:59:33 <||Zero||> where is it
12:59:39 <Zao> http://fly.srk.fer.hr/~unreal/theredbook/
12:59:39 <path[l]> oh ok, my guess was actually right?
12:59:40 <path[l]> lol
12:59:43 <path[l]> wow
12:59:55 <lispy> hi
12:59:57 <copumpkin> http://www.opengl.org/documentation/red_book/
13:00:33 <copumpkin> path[l]: pretty much, so if you want to generate all subsets of {1,2}, you basically have the choice of either selecting both 1 and 2, selecting only one of them, or selecting neither, that is 11, 01 or 10, or 00
13:00:47 <path[l]> right
13:01:20 <copumpkin> ok
13:01:49 <copumpkin> :t filterM
13:01:54 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:01:54 <||Zero||> what are another primitive types of open gl librarye
13:02:36 <copumpkin> path[l]: do you understand nondeterminism in the CS-ey sense?
13:03:11 <copumpkin> path[l]: like the difference between a DFA or an NFA, for example
13:03:20 <lispy> copumpkin: are you using the list monad to get all the subsets or something like that?
13:03:25 <path[l]> umm nope sorry I dont
13:03:40 <copumpkin> lispy: yeah, just trying to explain why that filterM works
13:03:58 <copumpkin> y'all are welcome to chime in :P I'm trying to figure out a good way to tie this together
13:04:09 <lispy> oh, that code is so evil :)  (not really, just hard to grok for me)
13:04:47 <mauke> every time you list, the world is cloned
13:04:58 <mauke> every subworld works with one element
13:05:09 <etpace_> ` value like 100 or "what" can be viewed as a deterministic computation that has only one result, whereas a list like [1,2,3] can be viewed as a computation that can't decide on which result it wants to have, so it presents us with all of the possible results'
13:05:14 <mauke> at the very end all results are collected in a single list
13:05:24 <etpace_> can anyone explain that?
13:05:27 <path[l]> ok
13:05:38 <copumpkin> I guess "a computation that can't make up its mind" is a decent approximation
13:05:42 <copumpkin> for nondeterminism
13:05:50 <mauke> a normal filter predicate returns True or False to indicate which elements to select
13:05:57 <path[l]> I can see a list a list of possible answers, only one of which is correct
13:06:04 <lispy> > filter (const True) [1..10]
13:06:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:06:09 <mauke> our filterM version returns a list of both True and False
13:06:17 <copumpkin> so for that filterM (const [False, True]) is a filter that can't make up its mind whether to include each element
13:06:22 <etpace_> but what seperates "what" from [1,2,3]
13:06:51 <mauke> so for the first element we get two worlds, one seeing True and one seeing False as the result from the filter predicate
13:07:12 <path[l]> so filter gives you once answer on applying the filter. filterM gives you one answer for each application of the filter?
13:07:30 <path[l]> so does filterM say it applies filter1, filter 2 and gives you both?
13:07:31 <mauke> each world then tries the same function on the second element, which creates 4 worlds
13:07:35 <path[l]> ok
13:07:40 <path[l]> hmm
13:07:50 <mauke> it looks like a tree
13:07:54 <lispy> is that definition efficient?
13:07:55 <path[l]> yeah
13:08:04 <path[l]> I understand it now
13:08:18 <mauke> the first world will have seen True for every element, the last world will have seen False
13:08:31 <path[l]> is there a reason why the source code for sequences does not use this? It seems smaller
13:08:33 <mauke> everything in between will get some combination
13:08:41 <lispy> So, instead of creating subsets, how would you list all permutations using the list monad?
13:08:44 <path[l]> is it to make sequences lazy?
13:09:03 <path[l]> hmm let me think about that
13:09:12 <copumpkin> , permutations [1..3]
13:09:13 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
13:09:35 <copumpkin> could probably be done with a foldM and an insert inside it
13:09:44 * copumpkin thinks
13:09:45 <lispy> ?src permutations
13:09:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:09:46 <mauke> > filterM (return [True, False]) "www"
13:09:49 <lambdabot>   ["www","ww","ww","w","ww","w","w",""]
13:10:07 <path[l]> is there something similar I could do to take an N element list and get subsequences of size m only?
13:10:13 <path[l]> with filterM
13:10:17 <lispy> > filterM (return [True]) [1..4]
13:10:18 <lambdabot>   [[1,2,3,4]]
13:10:26 <copumpkin> path[l]: not really, filterM doesn't keep the kind of state you need
13:10:35 <lispy> > filterM (return [False]) [1..4]
13:10:36 <lambdabot>   [[]]
13:10:40 <copumpkin> path[l]: it has no memory of whether previous elements were selected or not
13:10:43 <mauke> > filterM (return [True, True]) "www"
13:10:45 <lambdabot>   ["www","www","www","www","www","www","www","www"]
13:10:48 <lispy> > filterM (return [False, True]) [1..4]
13:10:49 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
13:10:52 <path[l]> hmm right
13:11:12 <copumpkin> path[l]: so because it has no memory, it can't count them up... of course, you could just filter ((==3) . length) on the result :)
13:11:33 <path[l]> yeah
13:11:34 <mauke> bonus points if you can explain what 'return' does there
13:11:41 <jmillikin> Is there a way to implement something like hGetContents in pure haskell? I'd like to create (getFoos :: Handle -> IO [Int]), with the list being infinite and pulled from a handle, but can't figure out how to extract an infinite list from IO
13:11:50 <copumpkin> that return is sneaky
13:12:08 <mauke> jmillikin: that looks like it requires unsafeInterleaveIO
13:12:09 <copumpkin> @type return 5 :: a -> Int
13:12:12 <lambdabot> forall a. a -> Int
13:12:12 <lispy> jmillikin: unsafeInterleaveIO may help
13:12:19 <mauke> @src hGetContents
13:12:19 <path[l]> well return is supposed to give you a list with the element in it
13:12:20 <jmillikin> thanks
13:12:21 <mercury^> http://rohanlean.de/pub/fasta.hs -- draft for a submission. Can someone with a Q6600 please tweak the value of lc?
13:12:23 <Heffalump> jmillikin: the implementation of hGetContents uses unsafeInterleaveIO behind the scenes, which in turn uses unsafePerformIO. So no.
13:12:23 <lambdabot> Source not found. :(
13:12:29 <copumpkin> path[l]: in that case, nope
13:12:32 <Deewiant> > return (+1) 1 2
13:12:32 <mauke> path[l]: not in this case
13:12:34 <Vanadium> jmillikin: Why not just use hGetContents to begin with?
13:12:34 <lambdabot>   3
13:12:36 <path[l]> ah
13:12:47 <copumpkin> > (return 5) 2
13:12:49 <lambdabot>   5
13:12:51 <Heffalump> jmillikin: well, unsafePerformIO is defined in the FFI spec, but it's validity in this case is a bit dubious
13:13:08 <jfoutz> :t (return 5) 2
13:13:09 <copumpkin> path[l]: that return is for the ((->) a) monad instance
13:13:10 <lambdabot> forall t. (Num t) => t
13:13:18 <jmillikin> Vanadium: that function will be used multiple times per handle, but its list will only be iterated a few times per use.
13:13:19 <copumpkin> path[l]: and is const in disguise, basically :)
13:13:28 <Vanadium> Oh, I see
13:13:31 <jmillikin> It's my understanding that hGetContents will prevent re-using the handle
13:13:37 <Vanadium> Yes, it does. Sorry.
13:13:38 <mercury^> Heffalump: how can something be "invalid" when it works flawlessly?
13:13:41 <path[l]> I dont get it, sorry
13:13:49 <lispy> > filterM ([const True, const False]) [1..4]
13:13:50 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
13:13:56 <jfoutz> copumpkin: that is pretty devious.
13:14:08 <jmillikin> I'm basically trying to figure a way to remove the "IO" from functions that really don't need it, but just need to lazily pull from somewhere
13:14:37 <copumpkin> path[l]: do you see how ((->) a) is a Functor instance?
13:14:43 <lispy> jmillikin: very likely you're thinking about the code 'inside out' of how you'd want to write it in Haskell
13:14:43 <Heffalump> mercury^: I'm not sure I'd call hGetContents "flawless"
13:14:53 <copumpkin> jfoutz: hah, blame lispy :P
13:14:55 <mercury^> jmillikin: sounds exactly like unsafePerformIO
13:15:11 <path[l]> actually not really, I just started reading on what a monad is, so I dunno what a functor is
13:15:22 <path[l]> is it something that ALWAYS returns a?
13:15:24 <copumpkin> path[l]: ah, I'd start with functor and build up to monad :) it's a lot clearer
13:15:29 <copumpkin> @src Functor
13:15:29 <lambdabot> class  Functor f  where
13:15:30 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:15:35 <jmillikin> lispy: probably. I'm trying to implement a DBus unmarshaller, but to pull messages from the socket requires pulling in chunks, where each chunk describes how long the following chunk is
13:15:42 <copumpkin> path[l]: in another language, Functor might be called Mappable
13:15:47 <path[l]> I mean ((->)a)
13:15:50 <Heffalump> ah, so you need a limited hGetContents
13:15:57 <pr> @hoogle IO a -> IO a
13:15:58 <lambdabot> Control.Exception block :: IO a -> IO a
13:15:58 <lambdabot> Control.Concurrent runInBoundThread :: IO a -> IO a
13:15:58 <lambdabot> Control.Concurrent runInUnboundThread :: IO a -> IO a
13:15:58 <path[l]> hmm ok
13:16:00 <Heffalump> that sounds reasonable (modulo the usual hGetContents limitations)
13:16:01 <lispy> > filterM ([const [True, False]]) [1..4]
13:16:02 <copumpkin> path[l]: ((->) a) is equivalent to (a ->) (but haskell can't do sections of ->
13:16:04 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
13:16:08 <Heffalump> just look at the source and write your own - it's not that complicated
13:16:10 <jfoutz> path[l]: if i had to do it over again, i'd start with the typeclassopedia.
13:16:19 <lispy> copumpkin: what am I doing wrong there, I want to replace the return with const
13:16:20 <jmillikin> My current implementation is (unmarshal :: IO ByteString -> IO Message), but there's no reason it can't just be (ByteString -> Message) except for the lazy pulling
13:16:24 <copumpkin> path[l]: so when you see fmap's type signature
13:16:30 <pr> > filterM (const [True, False]) [1..4]
13:16:31 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
13:16:39 <copumpkin> lispy: hmm?
13:16:46 <copumpkin> :t fmap
13:16:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:16:52 <mauke> lispy: why don't you just replace the return with const?
13:16:55 <lispy> pr: thanks, I see.  Yes, that makes total sense now
13:17:03 <path[l]> actually I was on the typeclass chapter of RWH. I jumped ahead cause I wanted to finish a problem I was working on =p. Making a backtracking solver. So trying to understand the list monad now
13:17:13 <jfoutz> path[l]: it's here, the third article http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
13:17:17 <Vanadium> I would probably try to strictly read in and only lazily unmarshal to avoid just the usual hGetContents caveats.
13:17:20 <lispy> mauke: for some reason I was thinking the return was giving something in the list monad
13:17:33 <path[l]> ah ok thanks
13:17:37 <copumpkin> path[l]: we've said that f = c ->, so the signature of fmap for (c ->) (aka ((->) c)) is (a -> b) -> (c -> a) -> (c -> b)
13:18:21 <etpace_> Whats the requirements for something to be a functor, just that it has kind * -> *?
13:18:39 <copumpkin> yeah, and its instance needs to satisfy the laws
13:18:42 <lispy> etpace_: being able to define fmap is important :)
13:18:59 <path[l]> erm, maybe I should read up a little more and come back to this conversation
13:19:01 <path[l]> thanks guys
13:19:12 <copumpkin> path[l]: the typeclassopedia is helpful, I recommend it :)
13:19:30 <path[l]> is that the pdf  jfoutz just linked me to?
13:19:45 <jfoutz> yeah
13:20:02 <copumpkin> path[l]: even if you just look at this graph: http://snapplr.com/8hhf
13:20:30 <copumpkin> shouldn't there be a copointed before comonad?
13:20:36 <||Zero||> color $ (Color3 (1.0::GLfloat) 0 0)
13:20:40 <||Zero||> what colo r is that
13:20:47 <mauke> my guess: red
13:21:03 <copumpkin> I'd guess red too :P
13:21:17 <arw> R G B, mix, done :)
13:21:23 <mauke> that graph looks complicated
13:21:45 <||Zero||> color $ (Color3 (1.0::GLfloat) 0 0)
13:21:46 <||Zero||>     vertex $ (Vertex3 (0::GLfloat) 0 0)
13:21:46 <||Zero||>     vertex $ (Vertex3 (0::GLfloat) 0.2 0)
13:21:46 <||Zero||>     vertex $ (Vertex3 (0.2::GLfloat) 0.2 0)
13:21:46 <||Zero||>     vertex $ (Vertex3 (0.2::GLfloat) 0 0)
13:21:51 <mauke> simplified version: Functor --> Applicative --> Monad
13:22:01 <lispy> ||Zero||: please use hpaste for more than 2-3 lines
13:22:02 <mauke> even more simplified: Functor --> Monad
13:22:03 <copumpkin> ||Zero||: someone's already mentioned that pasting to the channel is impolite
13:22:16 <copumpkin> @hpaste please ||Zero||
13:22:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:22:27 <||Zero||> this is a 	
13:22:27 <||Zero||> square
13:22:32 <||Zero||> oke sorry
13:22:49 <||Zero||> sorry please
13:23:02 <||Zero||> but in that part of the code
13:23:14 <etpace_> will i be able to understand that pdf once ive finished the lyah section on monoids? i'm halfway through applicative functors currently
13:23:19 <path[l]> heh
13:23:29 <||Zero||> what are the coordinates
13:23:38 <||Zero||> to make the 	
13:23:39 <||Zero||> square
13:23:44 <copumpkin> ||Zero||: uh
13:24:01 <lispy> ||Zero||: they are the vertices
13:24:02 <copumpkin> ||Zero||: (0,0,0) (0,0.2,0) (0.2,0.2,0) (0.2,0,0)
13:24:09 <mauke> ||Zero||: the <enter> key is not punctuation
13:24:28 <jfoutz> etpace_: it's intended for beginners, starts with "Have you ever had any of the following thoughts?
13:24:31 <jfoutz>  What the heck is a monoid, and how is it dierent from a monad?
13:24:32 <mauke> also, why is there a <tab><newline> before square?
13:24:48 <etpace_> sounds good
13:25:44 <||Zero||> i dont know i only wrote
13:27:19 <copumpkin> "If we are lucky, someday MonadZero
13:27:20 <copumpkin> will be restored, and fail will be banished to the bit bucket where it belongs [77]."
13:28:01 <||Zero||> color $ (Color3 (0::GLfloat) 1 0)
13:28:04 <||Zero||> what color is that
13:28:31 <jfoutz> ||Zero||: what color do you think it is?
13:28:40 <copumpkin> ||Zero||: keep in mind, R G B
13:28:43 <copumpkin> Red, Green, Blue
13:28:53 <copumpkin> you have 0 for Red, 1 for Gree, and 0 for Blue
13:28:57 <copumpkin> what color is that?
13:29:09 <path[l]> ooh the typeclassopedia sounds like its aimed at me
13:29:18 <||Zero||> green???
13:29:21 <jfoutz> path[l]: it is really swell.
13:29:27 * jfoutz cheers for ||Zero|| 
13:29:37 <||Zero||> jejejejeje
13:29:37 <copumpkin> ||Zero||: :)
13:29:56 <copumpkin> the more you try to figure out for yourself, the better it will stick in your head forever
13:30:18 <endojelly> so, how is ((->) c) a Functor?
13:30:24 <endojelly> I wanna know the rest 8)
13:30:45 <copumpkin> endojelly: really?
13:30:49 <endojelly> yes.
13:30:50 <mauke> endojelly: functions are maps from keys to values
13:31:29 <endojelly> ah, ok.
13:31:30 <copumpkin> endojelly: simply write ((->) c) as (c ->) and substitute it into (a -> b) -> f a -> f b, and get (a -> b) -> (c -> a) -> (c -> b), which is conveniently enough the type of (.0
13:31:34 <copumpkin> (.) even
13:31:41 <endojelly> copumpkin, oh.
13:31:44 <endojelly> that was easy.
13:31:47 <Philippa> jfoutz: amongst other things, it's much simpler than a monad
13:31:48 <copumpkin> :)
13:31:51 <endojelly> so mapping is just composing
13:31:55 <endojelly> thanks!
13:32:00 <endojelly> and now: how is it a Monad?
13:32:08 <copumpkin> I'd step through applicative first
13:32:11 <||Zero||> nd what happen if i want to change that to 3d graphic
13:32:12 <endojelly> ok, I thing I can gather that myself, but how is that useful?
13:32:19 <Philippa> a monoid is basically a type with an associative binary function on it and an element that's the identity for that type
13:32:43 <copumpkin> endojelly: things like liftA2 (,) (+1) (2^)
13:32:52 <Philippa> associative means that it doesn't matter what shape the call tree is if you string a bunch together - just what the flat sequence looks like
13:32:53 <copumpkin> > liftA2 (,) (+1) (2^) 5
13:32:57 <lambdabot>   (6,32)
13:32:59 <jfoutz> Philippa: oh, hehe, sorry. i was quoting the introduction to the typeclassopedia.
13:33:00 <mauke> for a Monad you need return :: a -> (b -> a) and join :: a -> (a -> b) -> (a -> b)
13:33:06 <Philippa> IOW, however you use the function, it behaves like a 'sequence'
13:33:14 <copumpkin> sequence [(+1), (2^), (3*)] 5
13:33:18 <Philippa> the identity is just something that you can put into the function and get the other parm back
13:33:18 <copumpkin> > sequence [(+1), (2^), (3*)] 5
13:33:21 <lambdabot>   [6,32,15]
13:33:34 <Philippa> so there's more than one monoid on numbers - + and 0, * and 1
13:33:39 <Philippa> that make sense?
13:33:42 <endojelly> mauke, ah, so return is const
13:33:48 <mauke> endojelly: yep
13:33:53 <Philippa> perhaps more importantly, ++ and [] are a monoid
13:34:22 <etpace_> if i have let x = (++) <$> getLine <*> getLine; y <- x; return y, when is getline executed? when letting x, or when i action the IO with y>
13:34:27 <jfoutz> Philippa: yes. yes it the first part make sense.
13:34:30 <Vanadium> Are Monads Monoids?
13:34:40 <copumpkin> Vanadium: by some definition, yes
13:34:44 <mauke> etpace_: no
13:34:50 <endojelly> mauke, and bind.. uh, bind just returns its second argument?
13:34:50 <Vanadium> By any definition that ships with ghc?
13:34:51 <||Zero||> vertex $ (Vertex3 (0::GLfloat) 0 0)
13:35:00 <||Zero||> if i want to do that but in 3d
13:35:00 <mauke> endojelly: you want join, not bind
13:35:07 <BMeph> jfroutz: If I were wondering about that question, I'd also imagine it being asked in Eugenia Cheng's voice. :)
13:35:14 <etpace_> eh mauke?
13:35:15 <copumpkin> Vanadium: you couldn't easily represent Monads' monoidness using the Monoid class
13:35:25 <Vanadium> Aw :(
13:35:25 <endojelly> mauke, oh. ok. so join just returns its second argument?
13:35:34 <ksf> waaagh rwh is down
13:35:38 <mauke> endojelly: oh, wait. that type is wrong
13:35:47 <copumpkin> although with <=< or >=> you can sort of get close
13:35:51 <ksf> join only takes one argument...
13:35:52 <BMeph> Er, *jfoutz, I meant. :)
13:35:53 <mauke> endojelly: join :: (b -> (b -> a)) -> (b -> a)
13:35:54 <ksf> :t join
13:35:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:36:03 <mauke> endojelly: (forgot parens around first part)
13:36:23 <mauke> etpace_: actions are executed by the runtime systems, outside of Haskell itself
13:36:40 <mauke> s/systems/system/
13:36:56 <lispy> mauke: I think etpace_ means to ask, when will the value be demanded
13:37:11 <mauke> what does that mean?
13:37:14 <copumpkin> haskell is typically not a good language for asking when
13:37:19 <ksf> join (Foo (Bar a)) = Bar a >>= Foo
13:37:35 <ksf> ...not exactly, but that's the idea.
13:37:50 <endojelly> mauke, so what is join in that case?
13:38:08 <ksf> endojelly, you cal always derive join from >>= and >>= from join
13:38:14 <copumpkin> etpace_: oh but for your question, they're executed in left to right order
13:38:19 <endojelly> ksf, ok
13:38:22 <ksf> @where typeclassopedia
13:38:22 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
13:38:26 <ksf> have a look at that.
13:38:36 <mauke> endojelly: you're given a function that takes two 'b's and returns an 'a'. you're also given a 'b'. you need to create an 'a'. what do you do?
13:39:00 <etpace_> but are they executed at the first or the second line?
13:39:06 <mauke> etpace_: no
13:39:07 <jfoutz> ksf: the typeclassopedia is made out of win and awesome.
13:39:11 <copumpkin> etpace_: how do you mean?
13:39:16 <endojelly> mauke, I plug in the b into both places?
13:39:20 <mauke> endojelly: right
13:39:22 <copumpkin> etpace_: you can't really reason about haskell programs like that
13:39:28 <mauke> endojelly: join f = \x -> f x x
13:39:36 <endojelly> ah. nice.
13:39:39 <copumpkin> > let double = join (+) in double 5
13:39:41 <lambdabot>   10
13:40:00 <mauke> endojelly: bind m f = join (fmap f m)
13:40:19 <ksf> ...but that's for Monad (->). mauke is being evil.
13:40:30 <mauke> er, what?
13:40:31 <jfoutz> BMeph: oh! category theory lectures on youtube. cool.
13:40:37 <copumpkin> that's the one he was asking for :)
13:40:41 <ksf> ah.
13:40:44 <copumpkin> jfoutz: they're pretty clear, too
13:40:48 <ksf> still, any (->) instance is evil.
13:40:52 <endojelly> ksf, yes, that's the one I wanted to know, I'm familiar with the others
13:40:56 <etpace_> Well, if I have do let x = getLine; return "foo", getLine is never 'executed', or is it?
13:41:07 <copumpkin> etpace_: it isn't executed
13:41:12 <copumpkin> oh wait
13:41:17 <ksf> sure it is.
13:41:21 <ksf> x is just thrown away
13:41:23 <copumpkin> yeah, I thought that was let x ... in
13:41:24 <mauke> wtf.
13:41:32 <ksf> the IO monad is strict
13:41:35 <mauke> copumpkin: what's the difference?
13:41:38 <||Zero||> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8494#a8494
13:41:41 <mauke> ksf: WHAT
13:41:54 <CalJohn> ksf: i'm fairly sure the io monad is not strict
13:42:05 <etpace_> I thought IOs only happen when they were 'actioned' with <-?
13:42:18 <copumpkin> ksf: oh yeah, you're right
13:42:19 <||Zero||> reshape suppose to put the graphic in all the window
13:42:20 <mauke> etpace_: they don't happen then
13:42:21 <||Zero||> ???
13:42:22 <ksf> I'm fairly sure getLine >>= (\_ -> return "foo") reads a line
13:42:51 <mauke> ksf: that's unrelated to the strictness of IO, which is unrelated to the meaning of let x = getLine; return "foo"
13:43:14 <ksf> ...which means that your notion of "strictness" in this context is different from mine.
13:43:25 <mauke> and both are irrelevant
13:43:29 <Zao> ||Zero||: It adjusts the viewport. You probably want to regenerate and set a new projection matrix as well.
13:43:31 <ksf> exactly.
13:43:31 <jfoutz> ||Zero||: reshape is the function that gets called when the window changes size.
13:43:48 <mauke> etpace_: <- really only helps you build bigger IO actions
13:44:15 <||Zero||> i thought that it was going to put the graphic in all the window
13:44:17 <etpace_> hmm, ok, thanks
13:44:19 <BMeph> ksf: I
13:44:24 <BMeph> ...
13:44:26 <mauke> etpace_: you can think of <- as executing an action, but only in the context of some other action. i.e. "when this whole thing gets executed, it will run getLine here"
13:44:30 <||Zero||> so if i want to know how it works waht can i do??
13:44:32 <ksf> BMeph, you?
13:44:34 <Zao> ||Zero||: No, that's what the displayCallback does when needed.
13:44:46 <BMeph> ksf: I am curious - what is your definition of "strictness"? :)
13:44:48 <Zao> ||Zero||: Read up on how OpenGL works in the red book or nehe.
13:44:49 * copumpkin hangs his head in shame
13:44:54 <copumpkin> mauke: there :)
13:44:55 <Zao> And read up on how GLUT works.
13:45:05 <lispy> or the haskell nehe conversion
13:45:10 <lispy> ?where nehe-tuts
13:45:11 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
13:45:15 <ksf> "side effects occur though stuff isn't pulled"
13:45:27 <mauke> etpace_: basically your whole program constructs one big action and binds it to 'main'. the runtime system then takes that action and actually executes it
13:45:50 <ksf> that is, [1..] >>= (\_ -> return 1) will terminate.
13:46:24 <endojelly> > (return 5) 10
13:46:27 <lambdabot>   5
13:46:31 <BMeph> ksf: That's your definition? :)
13:46:40 <ksf> well, operationally, yes.
13:46:43 <lispy> ksf: that doesn't terminate in ghci
13:47:02 <ksf> you don't want to hear me talking about semantics.
13:47:40 <copumpkin> O.o
13:47:48 <ksf> yeah of course it doesn't, that's "repeat 1"
13:47:51 <copumpkin> (one of my eyes is bigger than the other, don't be hatin)
13:47:54 <BMeph> ksf: Why is that? Can you only discuss them in German? ;)
13:47:57 <etpace_> so <- tells it where to execute it, where would it be executed if an IO action is never '<-'d?
13:48:17 <mauke> etpace_: huh?
13:48:19 <ksf> I've got no idea what kind of language my brain speaks.
13:48:29 <mauke> more concrete example, please
13:48:56 <lispy> ksf: I'm getting confused.  You said it would terminate, was that a mistake?
13:48:57 <etpace_> well like my let example, if I have main = do let x = getLine; return "foo", is getLine ever actioned?
13:48:59 <dschoepe> etpace_: <- is just for binding the value a monadic action returns to a name. just writing "getLine" will also read a line, it will just not be given a name
13:49:04 <ksf> I could wave my hands in the air and generally look like an acidhead trying to explain something, but that wouldn't help anyone.
13:49:12 <ksf> lispy, yes.
13:49:13 <etpace_> ok, thanks, I understand
13:49:17 <mauke> etpace_: no, you're just making an alias for getLine
13:49:31 <etpace_> ahh, right
13:49:32 <mauke> etpace_: (also, strictly speaking that's a syntax error)
13:49:50 <mauke> also consider: getLine is not a function. it's a constant.
13:49:59 <lispy> ksf: okay, I was worried I was missing something cool :)
13:50:48 <||Zero||> what i have to do in the code to make it 3d graphic
13:50:59 <||Zero||> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8494#a8494
13:51:10 <BMeph> ksf: Just to be clear, I was responding to the "[__47] <ksf> you don't want to hear me talking about semantics." line. I was just wondering why I (or others) didn't want to - well, "hear you talking" - about it. :)
13:51:12 <copumpkin> oh my
13:52:09 <dmwit> ?index Void
13:52:09 <lambdabot> bzzt
13:52:13 <dmwit> ?hoogle Void
13:52:14 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:52:18 <malouin> So the standard library says that the permutations of "ab" are "ab" and "ba", but what do you call the sense of permutation where "a", "b", and "" are also permutations of "ab"?
13:52:22 <copumpkin> dmwit: @djinn's Void?
13:52:27 <dmwit> yeah
13:52:31 <dmwit> data Void
13:52:46 <copumpkin> I think it's just in djinn
13:52:52 <ksf> each time I visit archive.org, I imagine roboter arms grappling for tapes on the wink of my mouse.
13:53:01 <lispy> malouin: subsets?
13:53:08 <dmwit> copumpkin: aw
13:53:29 <ksf> anyway, not only rwh is down, but now also archive.org
13:53:37 <BMeph> malouin: Do you mean subsequences? :)
13:53:58 <opqdonut> BMeph: i guess he means subsequences of permutations
13:54:05 <copumpkin> yeah :/
13:54:06 <dmwit> permutations of subsets!
13:54:07 <||Zero||> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8494#a8494
13:54:16 <opqdonut> i mean, i guess he means "ca" would be a permutation of "abc"
13:54:23 <||Zero||> is there any change that i can do to make it a 3d graphic
13:54:46 <BMeph> opqdonut: Let's find out! - malouin: Is opqdonut right? :)
13:54:49 <dmwit> ?faq is there any change that i can do to make it a 3d graphic
13:54:49 <lambdabot> The answer is: Yes! Haskell can do that.
13:55:04 <copumpkin> @djinn (a -> r) -> r
13:55:04 <lambdabot> -- f cannot be realized.
13:55:13 <jfoutz> ||Zero||: it is 3d.
13:55:19 <BMeph> @djinn (a -> r) -> a
13:55:19 <lambdabot> -- f cannot be realized.
13:55:20 <mauke> unsafePerformReader?
13:55:29 <roconnor> @djinn a
13:55:30 <lambdabot> -- f cannot be realized.
13:55:50 <||Zero||> no this is 2d
13:55:52 <jfoutz> ||Zero||: what are you trying to do?
13:55:57 <lispy> ||Zero||: go to http://nehe.gamedev.net/lesson.asp?index=01 then for the associated haskell source look here: http://projects.codersbase.com/repos/nehe-tuts/
13:56:01 <||Zero||> what i need to change to make it 3d
13:56:02 <copumpkin> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
13:56:02 <lambdabot> f a b c = a (\ d -> b d c)
13:56:12 <opqdonut> @djinn (Bool -> r) -> r
13:56:12 <lambdabot> f a = a False
13:56:18 <opqdonut> for a specific a it's all right
13:56:28 <copumpkin> it always is!
13:56:33 <mauke> @djinn (Void -> r) -> r
13:56:34 <lambdabot> -- f cannot be realized.
13:56:38 <copumpkin> fine
13:56:39 <copumpkin> :P
13:57:03 <Berengal> That should obviously be f a = a undefined
13:57:07 <endojelly> > (+2) `ap` (*3)
13:57:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
13:57:11 <endojelly> :t (+2) `ap` (*3)
13:57:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:57:15 <lambdabot>     Probable cause: `*' is applied to too few arguments
13:57:15 <lambdabot>     In the second argument of `ap', namely `(* 3)'
13:57:17 <BMeph> @djinn Not r -> r
13:57:18 <lambdabot> -- f cannot be realized.
13:57:21 <malouin> lispy,BMeph: not quite either one -- for all subsets, all orderings of each subset.
13:57:21 <mauke> :t (+) `ap` (*3)
13:57:23 <lambdabot> forall a. (Num a) => a -> a
13:57:36 <copumpkin> @djinn a -> Void
13:57:36 <lambdabot> -- f cannot be realized.
13:57:44 <endojelly> > ((+) `ap` (*3)) 10
13:57:45 <lambdabot>   40
13:57:55 <endojelly> this gives me headaches :/
13:57:56 <copumpkin> @djinn List a -> Bool
13:57:57 <lambdabot> Error: Undefined type List
13:58:07 <copumpkin> @djinn-add data ListN a as = Nil | Cons a as
13:58:08 <endojelly> :t ap
13:58:09 <lispy> :t (+) <*> (*3)
13:58:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:58:10 <malouin> lispy,BMeph so I suppose I would be looking for map permutations $ subsequences list
13:58:11 <lambdabot> forall a. (Num a) => a -> a
13:58:12 <||Zero||> but to be more exactly in my code what can i do to make it a 3d
13:58:16 <BMeph> malouin: Was opqdonut correct here - " <opqdonut> i mean, i guess he means "ca" would be a permutation of "abc""? :)
13:58:19 <mauke> endojelly: liftM2 is the general case
13:58:24 <copumpkin> @djinn-add type List a = Fix (ListN a)
13:58:24 <lambdabot> Error: Undefined type Fix
13:58:26 <copumpkin> :(
13:58:31 <malouin> opqdonut: yes
13:58:31 <lispy> malouin: yeah, you'll need a nub in there too
13:58:34 <mauke> endojelly: liftM2 c f g x = c (f x) (g x)
13:58:46 <mauke> endojelly: ap is the same thing with f = id
13:58:49 <endojelly> mauke, hmm, I begin to get it
13:58:59 <endojelly> mauke, thanks
13:59:04 <lispy> ||Zero||: compare with those examples.  See what they setup that you do not setup.  Read the tutorial or a book on it and think about it more :)
13:59:12 <mauke> (for g = id you can use >>=)
13:59:22 <copumpkin> @djinn Not (Not (((a -> b) -> a) -> a))
13:59:22 <lambdabot> f a =
13:59:22 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
13:59:32 <mauke> :t ap `asTypeOf` (=<<)
13:59:33 <lambdabot> forall a b. (a -> a -> b) -> (a -> a) -> a -> b
13:59:40 <endojelly> > liftM2 (*2) (+3)
13:59:42 <lambdabot>   Overlapping instances for GHC.Show.Show
13:59:42 <lambdabot>                              (((a2 ...
13:59:45 <endojelly> :t liftM2 (*2) (+3)
13:59:46 <lambdabot> forall a2 r. (Num (a2 -> r)) => ((a2 -> r) -> a2) -> (a2 -> r) -> r
13:59:51 <mauke> missing c
14:00:03 <mauke> > liftM2 (,) (*2) (+3) 42
14:00:05 <lambdabot>   (84,45)
14:00:09 <endojelly> oh, ok
14:00:19 <mauke> > liftM2 (,) id (+3) 42
14:00:21 <lambdabot>   (42,45)
14:00:25 <BMeph> mauke: You meant: "with c = id", right? :)
14:00:25 <mauke> > ap (,) (+3) 42
14:00:27 <lambdabot>   (42,45)
14:00:28 <mauke> BMeph: no
14:00:42 <lispy> > (,) <*> (+3) 42
14:00:44 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a, a1))
14:00:44 <lambdabot>    arising from a us...
14:00:53 <lispy> > (,) <*> (+3) $ 42
14:00:54 <lambdabot>   (42,45)
14:01:01 <lispy> That looks like line noise :)
14:01:18 <copumpkin> looks kinda cute to me
14:02:17 <malouin> lispy,BMeph,opqdonut: subpermutations list = concat $ map permutations $ subsequences list
14:02:42 <endojelly> :t liftM
14:02:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:02:50 <BMeph> malouin: permusubtations? ;)
14:02:50 <lispy> malouin: concatMap :)
14:02:53 <copumpkin> > permutations <=< subsequences $ [1..5]
14:02:55 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
14:03:05 <endojelly> :t liftM (,) (*2)
14:03:07 <lambdabot> forall b a. (Num a) => a -> b -> (a, b)
14:03:09 <malouin> This relates to the problem of, suppose you have a password which can be up to N elements long, but you can't reuse elements for whatever reason.
14:03:18 <endojelly> > liftM (,) (*2) 5 7
14:03:20 <lambdabot>   (10,7)
14:03:24 <malouin> how do you chose a random one.
14:03:33 <copumpkin> malouin: expressing it with <=< is cuter!
14:03:36 <Berengal> @type permutations <=< filterM (const [True, False])
14:03:38 <lambdabot> forall a. [a] -> [[a]]
14:03:39 <copumpkin> like, totally supercute
14:03:41 <||Zero||> but is kind of dificult to compare a c++ code with haskell code
14:03:43 <SubStack> fishes!
14:03:49 <endojelly> > liftM id (*2) 5
14:03:50 <lambdabot>   10
14:03:51 <malouin> <=<, eh?
14:04:09 <endojelly> > liftM (+3) (*2) 5
14:04:10 <lambdabot>   13
14:04:25 <copumpkin> :t (<=<)
14:04:26 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:04:27 <mmorrow> this is equally as interesting as it's horrifying http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/25112.PDF
14:04:27 <lispy> ||Zero||: I transalted the nehe examples to Haskell.  I also gave you the link to that code already.  It's here: http://projects.codersbase.com/repos/nehe-tuts/
14:04:44 <copumpkin> mmorrow: lol
14:04:59 <malouin> where does <=< come from?
14:05:01 <lispy> :t (<=<)
14:05:07 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:05:10 * copumpkin pays mmorrow for two years to apply that document to GHC's codegen
14:05:12 <Cale> malouin: Control.Monad
14:05:15 <copumpkin> (if only I had the moneh)
14:05:16 <malouin> Cale: thanks
14:05:29 <roconnor> @type \l x -> foldr ($) x l
14:05:31 <lambdabot> forall b. [b -> b] -> b -> b
14:05:32 <mmorrow> copumpkin: there are a few gems in there too... e.g.: "Avoid conditional branches that depend on random data, as these branches are difficult to predict."
14:05:40 <copumpkin> difficult :O
14:05:40 <roconnor> @type foldr (.) id
14:05:42 <lambdabot> forall a. [a -> a] -> a -> a
14:05:53 <Cale> malouin: (<=<) and return give a very nice way to write the 3 monad laws:
14:06:01 <Cale> 1) return <=< f = f
14:06:06 <Cale> 2) f <=< return = f
14:06:10 <mmorrow> "When using SSE and SSE2 instructions to perform loads and stores, it is best to interleave them in the following patternLoad, Store, Load, Store, Load, Store, etc."
14:06:12 <mmorrow> BUT
14:06:17 <||Zero||> :o
14:06:18 <Cale> 3) (f <=< g) <=< h = f <=< (g <=< h)
14:06:20 <||Zero||> lets see
14:06:30 <mmorrow> "If using MMX loads and stores in 32-bit mode, the loads and stores should be arranged in the following patternLoad, Load, Store, Store, Load, Load, Store, Store, etc."
14:06:35 <mmorrow> oo
14:06:38 <copumpkin> mmorrow: wow
14:06:57 <Deewiant> mmorrow: Why is it horrifying :-P
14:07:36 <malouin> awesome.
14:07:37 <malouin> subpermutations = permutations <=< subsequences
14:07:49 <lispy> :t (>=>)
14:07:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:08:14 <BMeph> lispy: Good call. :)
14:08:42 <lispy> It still seems like in general you'll need a nub
14:08:54 <lispy> Unless you don't mind duplicates
14:09:21 <Berengal> If the original list doesn't have duplicates, there won't be in the resulting list either
14:09:27 <malouin> Cale: interesting
14:09:49 <BMeph> lispy: There are only duplicates in the result if there are duplicates in the original list, su if you do "nub" beforehand, it works. :)
14:10:00 <Berengal> monads are monoids in the category of endofunctors. It makes sense the monad laws should be in there somewhere
14:10:09 <BMeph> Berengal: Heh-heh. :)
14:10:29 <Cale> Berengal: While that's true, this presentation doesn't quite highlight that view :)
14:10:54 <BMeph> Berengal: Don't you mean monoid laws? ;)
14:11:12 <Berengal> BMeph, there's a difference? ;)
14:11:15 <roconnor> @quote endofunctors
14:11:16 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
14:12:39 <BMeph> Berengal: There is in Hask. ;)
14:12:45 <Cale> This one is that a monad is an endofunctor which makes the Kleisli composition give rise to a category, with return as the identity.
14:13:32 <Berengal> BMeph, why must there always be such special cases in CS :(
14:14:33 <lilac> @quote lilac haiku
14:14:34 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
14:14:34 <lambdabot> read
14:18:21 <roconnor> that is such a good monad tutorial
14:19:17 * BMeph gives a standing ovation
14:20:28 <dmwit> I think the tutorial would be complete without jmcarthur's approval.
14:20:51 <copumpkin> I dunno, it adds a certain je ne sais quoi
14:21:10 <dmwit> je ne sais quoi = extra line? ;-)
14:21:25 <copumpkin> quite possibly :)
14:23:45 <Orclev> @source Eq
14:23:46 <lambdabot> Eq not available
14:24:23 <mauke> @src Eq
14:24:23 <lambdabot> class  Eq a  where
14:24:23 <lambdabot>     (==), (/=)   :: a -> a -> Bool
14:27:21 <ksf> can I add an FinalizePtr to a vanilla haskell ADT?
14:27:49 <ksf> ...that is, run something as soon as some data goes out of scope, not save a ptr in the adt.
14:28:03 <lispy> ksf: you probably want bracket
14:28:29 <lispy> ksf: finalizers are notorious for not running when you want them to
14:28:46 <lispy> ksf: making them inappropriate for scarce resources like file handles
14:28:54 <mauke> finalizers + as soon as = bad idea
14:29:21 <lispy> ksf: bracket on the other hand, offers a scope-ish wrapper around a computation
14:29:24 <lispy> :t bracket
14:29:27 <lambdabot> Not in scope: `bracket'
14:29:35 <ksf> mmmh I want to save a handle to a .so in my StateT
14:29:36 <lispy> am I spell it wrong ?:)
14:29:46 <dmwit> id id = id
14:29:59 <lispy> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:30:16 <mauke> @hoogle bracket
14:30:16 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
14:30:17 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
14:30:17 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
14:31:36 <ksf> ...I guess I just have to put deinitialisation stuff where it don't belong, that is inside my runApp.
14:32:18 <lispy> ksf: perhaps, but maybe you showed people here your code they could offer ideas?
14:33:01 <ksf> hell no it's a mess. give me an hour.
14:35:32 <lispy> hehe, suit your self :)
14:35:54 <copumpkin> whose self?
14:37:02 <dmwit> my self
14:37:15 <mauke> my $self = shift;
14:38:08 <lispy> ksf: also, finally
14:38:09 <lispy> :t finally
14:38:13 <lambdabot> Not in scope: `finally'
14:38:15 <lispy> ?hoogle finally
14:38:15 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
14:40:04 <rdeshpande> hmm, the rwh online book link is still down.. anyone know if there is a tarball of the internet version somewhere else? i'd love for something like this so i can grep quickly.
14:43:14 <ManateeLazyCat> :t withIntConv
14:43:16 <lambdabot> Not in scope: `withIntConv'
14:43:26 <ManateeLazyCat> :t peekIntConv
14:43:27 <lambdabot> Not in scope: `peekIntConv'
14:43:38 <ManateeLazyCat> @hoogle withIntConv
14:43:38 <lambdabot> No results found
14:43:46 <ManateeLazyCat> @type withIntConv
14:43:47 <lambdabot> Not in scope: `withIntConv'
14:44:41 <ManateeLazyCat> C2HS> :t withIntConv
14:44:52 <ManateeLazyCat> @C2HS> :t withIntConv
14:44:52 <lambdabot> Unknown command, try @list
14:45:25 <kpreid> psst...Keal just joined #math.
14:48:01 <Twey>  On the other hand xmonad has great defaults, key bindings and xinerama support but is crippled by not being written in C. 
14:48:13 <Twey> Plthsplktfff
14:48:19 <mauke> FSVO "crippled"
14:48:19 <copumpkin> Twey: where's that?
14:48:23 <Twey> http://www.scrotwm.org/
14:49:05 <Axman6> wtf?
14:49:08 <copumpkin> wow, he's calling xmonad cripped by a language when he uses CVS for his revision control?
14:49:08 <copumpkin> :P
14:49:20 <Valodim> hahaha
14:50:14 <mauke> Linux: crippled by not using CVS
14:50:51 <Axman6> Linux: Crippled by default
14:50:52 <Axman6> >_>
14:51:24 <lispy> :t (>_>)
14:51:26 <lambdabot> parse error on input `)'
14:51:26 <Twey> Also, apparently hijacking the meta key is a sane default
14:51:53 <copumpkin> why would he call it scrotum anyway?
14:51:58 <copumpkin> who wants to use a WM called scrotum
14:52:14 * Twey shrugs.
14:53:27 <Twey> A Welsh scrotum, too, it seems :
14:53:48 * Axman6 is still somewhat bewildered that he's calling haskell a crazy, unsupportable language
14:54:23 <BMeph> My guess: Someone who (still) giggles when saying, "Ha-ha, I made you say..." :)
14:54:56 * BMeph is annoyed at the default of black background and dark blue links...
14:55:16 <nvoorhies> It makes sense if you subscribe to the infinite-monkey-all-bugs-are-shallow school of thought
14:55:32 <copumpkin> I wonder how many lines of C it's written in
14:55:36 <copumpkin> compared to xmonad's lines
14:56:07 <Axman6> http://www.reddit.com/r/haskell/comments/9de9m/on_the_other_hand_xmonad_has_great_defaults_key/ for discussion
14:57:12 <sjanssen> Axman6: tell them 1985 called and they want their programming language back
14:57:23 <d4> "I breathe fire but my belly's all ashes"
14:57:56 <rdeshpande> are any of you guys using yi for haskell? Im just getting into haskell this weekend and looking to create an optimal environment
14:58:08 <sjanssen> Axman6: I believe the correct quote is "unportable language"
14:58:11 <ray> axman6: that's pretty old
14:58:15 <sjanssen> they also call it a syndrome :)
14:58:37 <ray> crazy unportable language syndrome, yes
14:58:39 <ray> with hyphens
14:59:32 <ray> did it have hyphens? i'm thinking it did
15:00:02 <Taejo> it did
15:00:39 <haskellrox> hi, I'm playing with the wikibook tutorial where one exercise is to define (!!).  But (!!) already exists in Prelude, so when I try to ":l exclam.hs" in ghci, it complains about an "ambiguous occurence `!!'".  Can I play with my code in ghci somehow?  Thanks
15:00:50 * copumpkin loves his library!
15:00:53 <copumpkin> I got ATTAPL
15:01:07 <copumpkin> haskellrox: import Prelude hiding ((!!))
15:01:10 <EvilTerran> haskellrox, import Prelude hiding ((!!)) at the top of your module
15:01:50 * arcatan invokes the majestetical stereo quote
15:02:02 * EvilTerran prefers the contrapuntal fugue quote
15:02:10 <haskellrox> copumpkin, EvilTerran: perfect, thank you!
15:02:23 <lispy> ?quote majestetical
15:02:24 <lambdabot> No quotes match. My brain just exploded
15:02:34 <lispy> lambdabot: omg, mine too!
15:02:56 <Axman6> haskellrox: you could also always give it another name ;)
15:03:07 <Axman6> @quote quote
15:03:07 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
15:03:13 <Axman6> @quote quote
15:03:14 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
15:03:25 <haskellrox> Axman6: yep, I've used that solution in the past but figured this was a chance to learn something new :)
15:03:25 <Axman6> heh
15:03:32 <Axman6> righto
15:03:33 <arcatan> hmm, majestical, anyway.
15:04:18 <mauke> @quote majestic
15:04:19 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
15:04:33 <haskellrox> is there a list of some interesting haskell projects that an intermediate haskeller could jump into?
15:04:47 <ray> try the haskell_proposals reddit?
15:04:53 <lispy> haskellrox: darcs :)
15:06:39 * ksf has to re-think his understanding of IO
15:06:43 <haskellrox> lispy: darcs and xmonad are pretty much the only popular haskell projects I can name off the top of my head.  I guess I'll check them out, but anything smaller/in earlier stages?
15:06:44 <ksf> it's lazy, after all.
15:07:00 <ksf> wait.
15:07:05 <jfoutz> ok.
15:07:11 <lispy> haskellrox: only, all of hackage ;)
15:07:29 <ksf> no, it isn't.
15:07:33 <haskellrox> lispy: good point :)
15:07:43 <ksf> I traced the wrong fun
15:08:07 <lispy> A tree can't be a monad can it?
15:08:15 <EvilTerran> lispy, i think it can
15:08:22 <c_wraith> I don't see why not.  List is.
15:08:33 <lispy> Hmm...
15:08:51 <c_wraith> @src [] (>>=)
15:08:51 <lambdabot> xs >>= f     = concatMap f xs
15:09:03 <byorgey> lispy: yes, it can.  bind corresponds to substituting subtrees for leaves.
15:09:18 <lispy> (Node a b) >>= f = Node (a >>= f) (b >>= f)
15:09:25 <ksf> calling dlsym for every call isn't the most effective thing one can do.
15:09:26 <EvilTerran> for "data Tree a = Leaf a | Branch (Leaf a) (Leaf a)", say, return = Leaf; join (Leaf t) = t; join (Branch l r) = Branch (join l) (join r)
15:10:16 <sm> g'day all
15:10:40 <byorgey> lispy: in fact, for any functor f, the tree given by  data Tree a = Var a | f (Tree a)  is a monad, in particular the 'free monad' over f
15:11:13 <mauke> free the monads!
15:11:13 <byorgey> implementing the Monad instance is left as an exercise for the reader.
15:11:23 <lispy> heh
15:11:30 <byorgey> hi there sm
15:11:35 <mauke> free the theorems!
15:11:35 <lispy> Well, does that line I pasted look about right?
15:11:45 <mauke> free the mallocs
15:11:46 <lispy> it type checks, now i was trying to think of ways to run it :)
15:12:02 <copumpkin> @free bracket
15:12:04 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `bracket'\n\n"
15:12:08 <||Zero||> k
15:12:14 <copumpkin> @free fix
15:12:15 <lambdabot> f . g = h . f => f (fix g) = fix h
15:12:21 <byorgey> lispy: looks right, along with  (Leaf a) >>= f = f a
15:12:23 <mmorrow> @free ap
15:12:24 <lambdabot> Expected variable or '.'
15:12:30 <lispy> byorgey: right, that one was easy :)
15:12:33 <copumpkin> @free loop
15:12:33 <byorgey> =)
15:12:35 <lambdabot> Expected variable or '.'
15:12:37 <lispy> byorgey: well, it actually works the way I would expect
15:12:37 <copumpkin> :(
15:12:50 <lispy> It just seems odd that >>= = fmap
15:12:55 <lispy> But, not that odd I supose
15:13:06 <mmorrow> i always though @free was figuring this stuff out
15:13:09 <mmorrow> *thought
15:13:12 <byorgey> lispy: how is >>= = fmap ?
15:13:23 <byorgey> note that  fmap f (Leaf a) = Leaf (f a),  not f a
15:13:40 <byorgey> that's the difference.
15:13:43 <lispy> oh riht
15:13:52 <mmorrow> @type (join .) . flip fmap
15:13:54 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
15:14:08 <mmorrow> @type flip ((join .) . fmap)
15:14:09 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
15:14:42 <byorgey> (Leaf a) >>= f = f a   -- apply f to values at leaves and substitute the resulting tree for the leaf
15:14:48 <mmorrow> @pl only figures out one of those oddly
15:14:48 <lambdabot> only figures out one of those oddly
15:15:01 <mmorrow> @pl (join .) . flip fmap
15:15:01 <lambdabot> (join .) . flip fmap
15:15:06 <mmorrow> @pl flip ((join .) . fmap)
15:15:06 <lambdabot> (>>=)
15:15:12 <byorgey> (Node a b) >>= f = Node (a >>= f) (b >>= f)   -- to substitute at an internal node, apply the substitution to both branches and put together the resulting subtrees
15:15:13 <lispy> byorgey: yeah, so in fmap you get something that it stucturally the same, but with (>>=) you can get a new tree
15:15:34 <byorgey> lispy: right.
15:15:57 <mmorrow> modulo a tricksy fmap implem
15:16:12 <byorgey> s/tricksy/unlawful/
15:16:16 <mmorrow> heh
15:16:19 <lispy> I was just typing that :)
15:16:59 <mmorrow> fmap f (Leaf a) = Branch (Leaf (f a)) (Leaf (f a))
15:17:03 <mmorrow> illegal?
15:17:38 <copumpkin> @free either
15:17:41 <lambdabot> g . k = p . f => g . q = f1 . h => g . either k q = either p f1 . $map_Either f h
15:17:59 <mauke> mmorrow: that doesn't look fusable
15:18:17 <mauke> also, obviously illegal by fmap id = id
15:18:24 <mmorrow> damn!
15:18:46 <mmorrow> well, depends on you (==) implem ;)
15:18:49 <mmorrow> *your
15:19:06 * mmorrow is groping at this point
15:19:38 <dschoepe> wouldn't that instance also violate fmap f . fmap g === fmap (f . g)?
15:19:56 <mauke> yeah, that's what I meant by fusion
15:19:57 <mmorrow> yeah, true
15:20:04 <dschoepe> ah, okay
15:20:11 <mmorrow> mauke: ahh
15:20:12 <haskellrox> Can I make ghci print the definition of a function somehow?  So I load ghci, type ":def zip" and get back how it is defined in Prelude?
15:20:23 <dschoepe> haskellrox: lambdabot in this channel can do that
15:20:24 <lispy> ?src zip
15:20:24 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:20:24 <lambdabot> zip _      _      = []
15:20:42 <dschoepe> haskellrox: (you can also run it locally, just cabal install lambdabot)
15:20:52 <lispy> haskellrox: what lambdabot returns with ?src is not the GHC implementation, it is just a sample of how to do it
15:21:19 <c_wraith> @src zipWith
15:21:19 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:21:19 <lambdabot> zipWith _ _      _      = []
15:21:21 <ksf> ok, here's the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8496#a8496
15:21:21 <lispy> haskellrox: for the ghc implementation, you could look at the haddocks, they give a link to the src
15:21:42 <dschoepe> @where hayoo
15:21:43 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:22:07 <mmorrow> ghc can derive Functor in head btw
15:22:08 <haskellrox> lispy: hmm, wish it was integrated into ghci :(  thanks lispy and dschoepe
15:22:11 <mmorrow> (just remembered this)
15:22:39 <lispy> haskellrox: at some point, you could integrate lambdabot and ghci
15:22:48 <lispy> haskellrox: it was called ghci on acid, not sure if it still works
15:22:51 <mauke> @where goa
15:22:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
15:23:00 <lilac> mmorrow: even for GADTs? :)
15:23:27 <mmorrow> lilac: GADT deriving isn't even the same problem as regular ADT deriving
15:23:47 <ksf> using a .so is much, much pain right now.
15:23:58 <ksf> ...unless I missed some magic c2hs feature or so.
15:24:31 <mmorrow> like e.g. to derive Read (for the parts of the GADT that you can do so for), you'd need to generate multiple Read instances, and weirdness like that
15:24:39 <ksf> you can't even properly use its marshalling magic 'cos it generates the wrong foreign imports.
15:25:16 <mmorrow> but Show is just one instance (again for the part of the GADT that you can even have a Show)
15:25:17 <lilac> mmorrow: i think in the case of Functor there basically isn't a workable instance in many cases
15:25:51 <mmorrow> lilac: ah, but there may be for a /subset/ of the GADT, rather than it just being yes or no
15:26:42 <lilac> i think if, in any constructor, the last type variable is constrained, there won't be a derivable Functor instance
15:26:45 <mmorrow> data Foo a where A :: a -> Foo a; B :: a -> Foo (Maybe (Foo b)); C :: () -> Foo a
15:27:10 <mmorrow> instance Functor Foo where fmap f (A a) = A (f a); fmap f (C ()) = C ()
15:27:13 <PetRat> A few months ago I download GHC 6.8.3 for Windows. I am playing with Data.Map today and noticed that a few functions are missing, like toDescList. I thought, "Okay I need a more recent version of Data.Map" so I tried to use cabal to look for Data.Map. I used "cabal list Map" but didn't find it.
15:27:37 <ksf> the package is called containers iirc.
15:27:41 <mmorrow> hmm, but then i guess you'd error out if you did "fmap f (B 4)"
15:27:45 <ksf> ...but then, it could be in base by now.
15:27:46 <lispy> ksf: I think you could use finally to replace your 'where f = ...'
15:27:50 <lilac> mmorrow: that's not law-abiding. fmap id (B x) != B x
15:27:53 <lispy> ?hoogle finally
15:27:54 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
15:28:10 <mmorrow> lilac: but what's the type of (B x) ?
15:28:20 <mmorrow> Foo (Maybe (Foo b))
15:28:22 <ksf> lispy, but I want to close even if there aren't any exceptions.
15:28:28 <mmorrow> not (Foo a)
15:28:35 <lispy> ksf: yeah
15:28:37 <mmorrow> which causes weird problems
15:28:46 <lilac> mmorrow: that unifies. a = Maybe (Foo b)
15:29:08 <mmorrow> but suppose then that
15:29:11 <EvilTerran> but then what do you give to the f in (fmap f)?
15:29:12 <PetRat> ksh: I just tried "cabal install containers" and it barfed on Data/IntMap--said couldn't find Data.Data
15:29:15 <mmorrow> data Foo a where B :: a -> Foo (Maybe (Foo b))
15:29:21 <lispy> "computation to run afterward (even if an exception was raised) "
15:29:34 <lispy> ksf: that's from the documentation
15:29:41 <mmorrow> can this even have a functor instance since it's impossible to have a (Foo a) for all 'a' ?
15:29:51 <PetRat> what pacakage has Data.Data?
15:29:55 <mmorrow> err, this is better
15:29:56 <mmorrow> data Foo a where B :: a -> Foo (Maybe (Foo a))
15:30:26 <mauke> PetRat: base
15:30:39 <EvilTerran> PetRat, you may need to update your ghc
15:30:49 <lilac> mmorrow: that can't have a Functor instance, since "fmap fromLeft . fmap Left" for instance isn't the same as "fmap id"
15:30:54 <PetRat> okay just tried "cabal install base" and it immediately gave error: "internal error: impossible"
15:30:56 <mmorrow> lilac: you'd need to do (newtype Bar a = Bar (Foo (Maybe (Foo a))))
15:31:01 <mun> hi
15:31:09 <mmorrow> lilac: then you can have a Functor for that though
15:31:10 <EvilTerran> PetRat, yeah, the version of the base package is irretrievably tied to the ghc version
15:31:13 <ksf> well yes but I don't want dl* exceptions to leak that far to the outside, anyway.
15:31:17 <EvilTerran> PetRat, because ghc uses it
15:31:23 <EvilTerran> (or something)
15:31:26 <PetRat> EvilTerran: thanks.
15:31:41 <PetRat> EvilTerran: is it true that older versions of Data.Map did not have toDescList?
15:31:53 <lilac> mmorrow: yeah, Bar looks like a Functor. it'd be really cool if the Functor instance for Bar could be generated (assuming all constructors for Foo are visible)
15:31:56 <EvilTerran> ... from what i recall, yes
15:32:09 <ksf> openUnitSync either opens the lib and resolves all symbols or doesn't create a structure to use.
15:32:16 <mmorrow> lilac: but then what would the name of "Bar" be?
15:32:33 <mun> in line 7 in the function http://haskell.pastebin.com/m7f7de04d , item is supposed to be a value constructor. how come (map item alibItems) is a singleton rather than a list? isn't ana's last argument a singleton?
15:32:36 <mmorrow> FooFunctor? or do you mean making that transparent to the haskell code?
15:32:51 <mmorrow> lilac: (i'm not sure if it could be made transparent?)
15:32:56 <PetRat> EvilTerran: so basically I can't update containers because it needs Data.Data, which is in base, so I can't get Data.Data, so I can't update containers without installing the latest ghc... does this make sense?
15:33:29 <PetRat> Is there a way to get the latest Data.Map without installing all of containers?
15:33:35 <EvilTerran> PetRat, yeah, that seems like an accurate description of your current misadventure =/
15:33:42 <mmorrow> lilac: i think this is really (in some sense) just the class machinery breaking down when being applied to GADTs
15:34:54 * SamB thinks there ought to be some bibtex fields for peer-to-peer file identifiers
15:35:20 <lispy> SamB: as in, bibtex + bitorrent?
15:35:35 <SamB> or emule or whatever
15:35:42 <mun> oh nevermind
15:36:52 <mmorrow> lilac: actually, that first Functor instance for the original Foo is valid with this small addition http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8497#a8497
15:37:02 <mmorrow> (fmap f (B a) = unsafeCoerce (B a))
15:37:16 <EvilTerran> ...
15:37:19 <mmorrow> since (B :: a -> Foo (Maybe (Foo b))
15:37:26 <EvilTerran> unsafeCoerce isn't real haskell :P
15:37:26 <mmorrow> the 'a' and 'b' aren't related
15:38:00 <lispy> do the standard libraries have a dup2?
15:38:14 <lispy> ?hoogle dup2
15:38:15 <lambdabot> System.Posix.Internals c_dup2 :: CInt -> CInt -> IO CInt
15:38:25 <lispy> So, I guess just in posix...
15:38:38 <lilac> mmorrow: you're now creating values which aren't supposed to exist
15:38:46 <lispy> interesting that the web version of hoogle doesn't have as much stuff as lambdabot
15:38:51 <mmorrow> lilac: actually i'm wrong since you can't include B in that at all
15:39:24 <lilac> fmap fromJust (B 42) == B 42 :: Foo (Foo b), violating the GADT constraint on B
15:39:40 <mmorrow> lilac: that classes can't do "everything that's not Show" (e.g.) makes them conflict with GADTs
15:40:01 <mmorrow> lilac: right
15:40:57 <lilac> fundamentally, Foo is simply not a Functor, just like 'data NotFunctor a = NF (a -> Bool)' isn't
15:40:59 <mmorrow> lilac: it seems to me that classes and things like Functor just aren't compatible with GADTs (in general)
15:41:41 <mmorrow> since with classes you have no way to say "instance Functor Foo (where this is an 'a', but NOT the B con)"
15:42:35 <Baughn> http://brage.info/~svein/lazywater.jpg <-- Haskell: If you don't look at it, it won't fall.
15:42:46 <mmorrow> like, regular ADTs are uniform in the sense that given a type `a' in (Bar a), you can have a (:: Bar a) for each constructor
15:43:15 <mmorrow> but not GADTs, which breaks how class instance selection happens
15:44:16 <mmorrow> lilac: hmm, maybe for Functor this is ok like you say
15:44:33 <mmorrow> lilac: err, i'm not sure
15:45:14 <mmorrow> lilac: i don't think you can say "Foo isn't a Functor" or "Foo is a Functor" because the fact that Bar has that fixed type makes in not comparable to a regular ADT
15:45:56 <lilac> I meant specifically that Foo is not a functor because there provably does not exist a law-abiding Functor instance
15:46:26 <mmorrow> lilac: but wrap newtype Bar a = Bar (Foo a) and you get one by sleight-of-hand
15:46:48 <mmorrow> it un-gadt-ifies it and "fixes" the B constructor
15:46:48 <lilac> do you? how so?
15:47:31 <lilac> doesn't it have exactly the same problems, modulo adding/removing Bar constructors?
15:47:54 <mmorrow> i'm trying to see if GADT-pattern-matching-determining-the-type saves us here..
15:48:20 <lilac> i don't see what we need saving from, to be honest
15:48:36 <mmorrow> we'll see in one moment after i finish typing :)
15:48:59 <lilac> GADTs or no GADTs, some types have law-abiding Functor instances (GADTs included), others do not.
15:49:49 <mmorrow> lilac: so what are you saying, that for the case of Functor either a GADT has a Functor instance or it doesn't, and which is the case is always determinable?
15:50:33 <mmorrow> err, s/always determinable/always involves every GADT constructor in the case that it does/
15:50:37 <mmorrow> ?
15:50:49 <mmorrow> (because this is what i'm trying to determine)
15:51:14 <lilac> that sounds at least as hard as being able to show whether a type is inhabited
15:51:34 <lilac> consider this: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=8497#a8498
15:52:27 <mmorrow> ok, what about it?
15:52:45 <lilac> in cases where 1) the last type parameter of a GADT is not constrained in any constructor, and 2) all uses of that type in that constructor are in positive positions, there would seem to be a (derivable) Functor instance
15:53:39 <lilac> in place of (2) i really mean whatever condition GHC currently uses...
15:54:25 <mmorrow> gah, this is just like the Ord constraint on Set (or equiv) disallowing a Functor instance
15:54:28 <lilac> if condition (1) is violated and said constructor is inhabited, there would seem to be no legal Functor instance (though i don't see exactly how to prove that)
15:54:33 <mmorrow> classes just can't express it
15:55:44 <lilac> for Foo, would you like to say something like, "Foo is a kinda-Functor, but only between non-Maybe (Foo a) types"?
15:56:43 <lilac> i would think that parametricity is such a fundamental part of what Functor means that calling Foo a Functor would not be helpful
15:57:45 <mmorrow> if you could do     instance Functor Foo | (Foo a, a ~ Maybe (Foo b)) => fmap <one for each of the cons> | otherwise => fmap .. <a case for A and one for C>
15:58:40 <lilac> how do you fmap from Foo (Maybe (Foo a)) to Foo b?
15:59:00 <mmorrow> `b' is just a place-holder
15:59:19 <lilac> no, i mean, for some specific a and b.
15:59:29 <lilac> suppose i give you f :: Maybe (Foo Int) -> String
15:59:37 <mmorrow> (Maybe (Foo a) -> Maybe (Foo b)) -> Foo (Maybe (Foo a)) -> Foo (Maybe (Foo b))
16:00:00 <mmorrow> you would only consider the B con in the case that it's possible for it to exist
16:00:10 <lilac> what is fmap f (B 123)
16:00:24 <mmorrow> what is the type of `f' ?
16:00:31 <lilac> f :: Maybe (Foo Int) -> String
16:00:44 <mmorrow> hmm
16:00:56 <EvilTerran> mmorrow, might http://okmij.org/ftp/Haskell/typecast.html#local-fd help?
16:00:56 <mmorrow> well, what is
16:01:05 <mun> hi
16:01:55 <mmorrow> lilac: right, this is exactly the oddity that i think makes classes and GADTs not play well with each other
16:02:18 <mmorrow> lilac: GADTs are fundamentally not like this
16:02:34 <EvilTerran> mmorrow, although this same oddity comes up with explicit existential quantification
16:02:39 <lilac> mmorrow: i don't think that conclusion is valid. some GADTs are not Functors. some (non-G)ADTs are not Functors.
16:02:40 <mmorrow> EvilTerran: right
16:03:02 <mmorrow> lilac: sure, but i'm talking about classes in general
16:03:18 <mun> in http://haskell.pastebin.com/m3020cb24, does anyone know how Lib_defn ln ls ps an (line 12) is of type AParser st LIB_DEFN?
16:03:19 <mmorrow> lilac: i agree with you on Functor (after that last point)
16:04:57 <lilac> mmorrow: do you think this problem is not just limited to fmap and its cousins?
16:05:04 <mmorrow> lilac: so this makes me think also now that deriving Functor is trivial for a GADT
16:05:18 <mreh> what's a good idiomatic way of going through a list replacing elements? fold i suppose, using it in composition with the list identity function?
16:05:20 <mmorrow> lilac: consider Read for GADTs
16:05:36 <lispy> ?hoogle whileM
16:05:37 <lambdabot> No results found
16:05:49 <mmorrow> lilac: it's cousins?
16:05:54 <lilac> mmorrow: read for any type with an existential is pretty hard i think
16:06:01 <mmorrow> lilac: no existentials
16:06:24 <mmorrow> lilac: i've got a strategy for doing Read in
16:06:50 <mmorrow> http://hackage.haskell.org/package/derive-gadt
16:06:54 <mun> what does <|> mean?
16:06:55 <mmorrow> Show,Eq,Ord,Read
16:07:25 <mmorrow> lilac: it handles all the constructors of a given GADT that are monomorphic and that have no existentially typed contents
16:07:26 <lilac> mmorrow: presumably you need (at the very least) overlapping instances for this?
16:07:29 <monoidal> seen roconnor
16:07:32 <mmorrow> lilac: no
16:07:33 <copumpkin> @hoogle (<|>)
16:07:33 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
16:07:33 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
16:07:33 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
16:07:46 <monoidal> @seen roconnor
16:07:46 <lambdabot> roconnor is in ##logic, #haskell-blah and #haskell. I last heard roconnor speak 1h 26m 20s ago.
16:07:50 <EvilTerran> mun, uh, the type of that expression is set by wherever Lib_defn is defined
16:07:52 <lilac> mmorrow: ah, only monomorphic ones, right :)
16:08:07 <mmorrow> lilac: err, actually not only monomorphic
16:08:17 <EvilTerran> mun, and <|> is parsec's alternation operator; it's described in the docs somewhere
16:08:35 <mmorrow> lilac: it computes (possibly overlapping) groups of mutually-unifying constructors, then generates an instance of the class for each of these groups
16:08:40 <mun> EvilTerran,  i see. thanks
16:08:44 <lilac> mmorrow: how do you derive Read for 'data Foo a where A :: Int -> Foo Int; B :: a -> Foo a' with no overlaps?
16:08:55 <mmorrow> easy:
16:08:59 <pikhq> @src Text.Parsec.Prim.(<|>)
16:09:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:09:03 <mmorrow> instance Read (Foo Int) where ...
16:09:04 <mun> EvilTerran, but what is st in AParser st LIB_DEFN?
16:09:12 <pikhq> @src Control.Applicative.(<|>)
16:09:12 <mun> EvilTerran, is it a variable?
16:09:13 <lambdabot> Source not found. Do you think like you type?
16:09:19 <EvilTerran> mun, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#or
16:09:24 <mmorrow> lilac: so it never makes an instance for the unconstrained "a"
16:09:29 <pikhq> Hmm...
16:09:32 <pikhq> @instances Alternative
16:09:33 <EvilTerran> mun, it's a type variable
16:09:34 <mmorrow> in that sense it's limited
16:09:35 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
16:09:42 <monoidal> roconnor: you gave another version of compose on reddit. Is it just a matter of taste, or is there a visible advantage to that version?
16:10:08 <lilac> mmorrow: oh. that's slightly disappointing ;-)
16:10:14 <mmorrow> lilac: but also, Read for (Foo a) can't be done with classes
16:10:30 <mmorrow> since it'll always complain about (A n)
16:10:39 <mmorrow> "a is not Int"
16:11:23 <lilac> mmorrow: but that's ok since the 'Foo a' instance will never be used for Int
16:11:24 <Keal> Buy my album! http://www.amazon.com/Opposite-Hate-Mr-Keal/dp/B00006AFJG :D
16:11:28 <Keal> @keal
16:11:28 <lambdabot> i lack in verbal and social expression
16:11:33 <lilac> since the 'Foo Int' instance is more specific
16:11:42 <mmorrow> read "A 42" :: Foo Int
16:11:54 <mmorrow> read "B 42" :: Foo Int
16:12:13 <mmorrow> lilac: oh, are you saying /with/ overlapping instances?
16:12:25 <EvilTerran> mun, in the context of the type signature on line 3, it means that "library lG" has type "AParser st LIB_DEFN" for any choice of type st.
16:12:29 <mmorrow> lilac: (would ghc allow that?)
16:12:41 <lilac> *tries*
16:12:43 <mmorrow> err, even then though you'd pattern-match fail
16:12:45 <mmorrow> on
16:12:47 <mmorrow> read "B 42" :: Foo Int
16:13:12 <mmorrow> (if it chose the (Foo Int) instance that is)
16:13:49 <EvilTerran> mun, with reference to the type definition on the first line, this means library works for parsers with any state type of the form "AnnoState st"
16:13:55 <lilac> the Foo Int instance needs to know how to read A and B, the Foo a instance only needs to read B
16:14:16 <mmorrow> lilac: ah right
16:14:19 <Keal> :|
16:14:27 <mmorrow> lilac: and this only needs OverlappingInstances ?
16:15:01 <mun> EvilTerran, i've pasted the deinition of LIB_DEFN here http://haskell.pastebin.com/m7cbed47d but how does return (Lib_defn ln ls ps an) give a type containing AParser?
16:15:35 <EvilTerran> mun, that's "return" at work
16:16:11 <EvilTerran> mun, in that "type AParser st a = GenParser Char (AnnoState st) a", and "GenParser Char (AnnoState st)" is a Monad, so "AParser st" is also a Monad
16:16:48 <EvilTerran> mun, incidentally, you can write that first line as "type AParser st = GenParser Char (AnnoState st)"
16:17:04 <Keal> @keal
16:17:04 <lambdabot> its because the timeline diverges and past events themselves unhappen
16:19:37 <mmorrow> lilac: this is what that pkg currently generates for "Foo a where A :: Int -> Foo Int; B :: a -> Foo a" http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8497#a8500
16:20:08 <mun> EvilTerran, hmm firstly, how do you know GenParser Char (AnnoState st) is a Monad?
16:20:52 <mmorrow> lilac: i think i just realized what "class" of classes Functor belongs to: "class C f where ..." where f :: * -> ... -> *
16:20:56 <lilac> mmorrow: you also need FlexibleInstances
16:21:32 <mmorrow> lilac: and in those cases the GADTs can only be made an instance of them if *every* constructor has a type like "Foo a"
16:21:36 <EvilTerran> mun, http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html#t%3AGenParser
16:21:50 <mmorrow> lilac: i.e. the GADT is really just an ADT
16:22:09 <EvilTerran> mun, the whole point of Parsec is that it's a monadic parser, and "GenParser tok st" is the monad it works in
16:22:16 <mmorrow> so real GADTs aren't Functors (??)
16:22:25 <mmorrow> s/Functor/whatever/
16:22:50 <lilac> mmorrow: here's a working Read and Show for that Foo (for all a): http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=8497#a8501
16:23:44 <mmorrow> lilac: cool, i'll add an option that'll generate instances that rely on overlap
16:24:07 <lilac> mmorrow: here's a GADT that's not an ADT but is a Functor: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=8497#a8498
16:24:14 <mun> EvilTerran, i see. so return passes the type LIB_DEFN into the GenParser tok st monad, so that's why the type is correct?
16:24:16 <mmorrow> lilac: is instance resolution in the presence of overlap specified?
16:24:34 <lilac> yes, in the GHC manual somewhere
16:24:40 <EvilTerran> ?type return -- mun, yes; "return" is the function for injecting a pure (non-monadic) value into any monad
16:24:53 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:25:17 <mun> EvilTerran, it's clear now. thanks a lot!
16:25:56 <lilac> mmorrow: ghc uses the "most specific matching instance" (assuming it's uniquely determined)
16:26:03 <EvilTerran> mun, and the main reason to need to inject pure values into a monad is that the lines in a do-block must be in that block's monad
16:26:05 <mmorrow> lilac: ah right, so ammending that statement.. GADTs such that all for all the non-monomorphic constructors are like "Foo a"
16:26:25 <EvilTerran> so, if you've worked out a pure value within the do-block, you need "return" on the last line so you can, well, return in
16:26:26 <lispy> :t pure
16:26:27 <EvilTerran> *it
16:26:28 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:26:37 <lispy> > pure 1 :: [Int]
16:26:40 <lambdabot>   [1]
16:27:00 <mmorrow> lilac: is that ghc-only though (i.e. (err, i guess only ghc has GADTs, but..) is the choice of how to resolve overlap different depending on the compiler?)
16:27:08 <lispy> ?pl \x -> return (isNothing x && wait)
16:27:08 <lambdabot> return . (&& wait) . isNothing
16:27:21 <lispy> ?pl foo >>= \x -> return (isNothing x && wait)
16:27:21 <lambdabot> ((&& wait) . isNothing) `fmap` foo
16:28:11 <mmorrow> lilac: ah! better: if you think of e.g. "Foo (Something a)" like it were a class constraint on the "a", then it's *exactly* the same situation that Set is in with Functor
16:28:27 <mun> EvilTerran, yep. one more thing though, with the library function (library :: LogicGraph -> AParser st LIB_DEFN) does it actually return an implemented parser? is the parser implemented in Parsec already?
16:28:38 <mmorrow> namely that you have no way to constrain the 'a' in "instance Functor Foo"
16:29:47 <lilac> mmorrow: 'data Foo a where A :: b -> Foo (Maybe b)' is basically the same as 'data Foo = forall b. (a ~ Maybe b) => A a
16:30:15 <lilac> mmorrow: so in that sense, it does seem like exactly the same situation
16:30:16 <mmorrow> not the same kind
16:30:21 <mmorrow> though
16:30:22 <mmorrow> yeah
16:30:35 <mun> EvilTerran, how does GenParser actually parse the content? assuming the content is defined by the a in GenParser Char (AnnoState st) a, how is the data defined in a compatible with GenParser such that it can parse it correctly?
16:30:48 <lilac> yeah, the latter case should have been 'data Foo a = ...'
16:30:55 <mmorrow> ah, right
16:31:24 <mmorrow> yeah, this way seeing it makes it make more sense exactly what the obstacle here is
16:31:33 <EvilTerran> mun, uh... i'm not sure what you mean. parsec gives you "building block" parsers (which are actions in the (GenParser tok st) monad), and you assemble them into more (GenParser tok st) actions
16:32:11 <EvilTerran> GenParser is abstract, it's best to trust the implementation to work right :)
16:32:18 <SamB_XP> EvilTerran: I thought you had to give it some building blocks ?
16:32:26 <EvilTerran> ?hoogle runParser
16:32:27 <lambdabot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
16:32:27 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:32:27 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
16:32:29 <mmorrow> lilac: gotta run. re: derive-gadt: patches welcome! :)
16:32:31 <EvilTerran> ...
16:32:32 <SamB_XP> except it has them already for CharParser
16:32:51 <lilac> mmorrow: i might have a go, but probably not for a little while! :)
16:33:06 <EvilTerran> mun, and then you pass your finished parser to runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
16:33:12 <EvilTerran> or some other function defined from that
16:33:37 <mun> EvilTerran, but does the library function return the finished parser?
16:33:40 <EvilTerran> (parse, parseFromFile, and parseTest are all provided by parsec)
16:34:04 <mun> EvilTerran, in this code this is how runParser is called: runParser (library lgraph { currentLogic = defLogic opts }) (emptyAnnos ()) file input
16:34:14 <EvilTerran> mun, runParser, given the finished parser as an abstract GenParser value, gives you back a function of type "st -> SourceName -> [tok] -> Either ParseError a"
16:35:02 <EvilTerran> mun, you could think of runParser as a compiler from abstract parsers (GenParsers) to functions
16:37:59 <mun> EvilTerran, right. but how do you 'assemble' the building block parsers?
16:38:20 <EvilTerran> mun, with the combinators in the Text.ParserCombinators.Parsec modules
16:39:45 <EvilTerran> mun, have you looked over http://legacy.cs.uu.nl/daan/download/parsec/parsec.html ?
16:40:30 <EvilTerran> you can skip down to http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#UserGuide if you want to get straight to the tutorial bit
16:40:32 <British0zzy> hey haskellers, what are your favorite tutorials or introductions to parsec??
16:40:37 <mun> EvilTerran, no i haven't. thanks for the link
16:43:16 <EvilTerran> British0zzy, the link i just mentioned is the "official" one
17:04:57 <burp> > fmap (*3) (+100) 1
17:05:02 <lambdabot>   mueval-core: Prelude.read: no parse
17:05:02 <lambdabot>  mueval: ExitFailure 1
17:05:58 <burp> whats the problem?
17:06:10 <burp> > (.) (*3) (+100) 1
17:06:13 <lambdabot>   303
17:06:18 <mauke> > fmap (*3) (+100) 1
17:06:21 <lambdabot>   303
17:06:35 <endojelly> it does that sometimes, lately
17:07:12 <lispy> > filterM (const [True, False]) [1..3] -- I still don't fully get this
17:07:13 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:07:26 <lispy> :t filterM
17:07:31 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:07:32 <kbp> I have a question: "Int has limited-precision integers, while Interger is for arbitrary-precision" <---- could someone explain it to me? I cant get it (difference bw Int and Integer)
17:07:33 <mauke> @src filterM
17:07:34 <lambdabot> Source not found. I feel much better now.
17:07:52 <mauke> > 999 ^ 2 :: Int
17:07:54 <lambdabot>   998001
17:07:57 <mauke> > 9999 ^ 2 :: Int
17:07:59 <lambdabot>   99980001
17:08:07 <mauke> > maxBound :: Int
17:08:09 <lambdabot>   9223372036854775807
17:08:22 <mauke> > (maxBound :: Int) + 1
17:08:23 <lambdabot>   -9223372036854775808
17:08:34 <mauke> > 9223372036854775807 + 1 :: Integer
17:08:36 <lambdabot>   9223372036854775808
17:09:27 <endojelly> :t ap
17:09:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:09:34 <lispy> In that usage, you're just using filterM like an identity function?
17:09:57 <endojelly> > (+1) `ap` [2,3,4,5]
17:09:58 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
17:10:06 <copumpkin> endojelly: `fmap`
17:10:09 <copumpkin> or <$>
17:10:09 <endojelly> > [(+1)] `ap` [2,3,4,5]
17:10:10 <lambdabot>   [3,4,5,6]
17:10:13 <copumpkin> or that :)
17:10:17 <endojelly> > [(+1),(+4)] `ap` [2,3,4,5]
17:10:18 <lispy> > filterM (const (Just True)) [1..4]
17:10:19 <lambdabot>   [3,4,5,6,6,7,8,9]
17:10:20 <lambdabot>   Just [1,2,3,4]
17:10:22 <endojelly> copumpkin, no I'm trying to understand ap 8)
17:10:27 <copumpkin> ah ok :)
17:10:29 <endojelly> but I think I got it
17:10:38 <c_wraith> ap is just <*>
17:10:39 <c_wraith> :)
17:10:48 <c_wraith> (but requires monads)
17:10:50 <endojelly> yeah, I didn't know <*> either
17:10:51 <mauke> > 999999 ^ 99 :: Int
17:10:53 <lambdabot>   5920146666018336447
17:11:00 <lispy> :t (<*>)
17:11:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:11:04 <EvilTerran> kbp, Ints are fixed-length, like C ints; there's a limit to the magnatude of numbers they can represent
17:11:22 <EvilTerran> kbp, while Integers can hold numbers of near-arbitrary size
17:11:34 <EvilTerran> > 999999 ^ 99 :: Integer
17:11:36 <lambdabot>   999901004850843154764304477976514369139655131740633508461194231534839921730...
17:11:44 <endojelly> but, truth be told, I'm not really sure yet when ap is useful. or common
17:11:48 <kbp> EvilTerran: even bigger than 2^64?
17:11:50 <EvilTerran> > length $ show (999999 ^ 99 :: Integer)
17:11:51 <lambdabot>   594
17:11:53 <endojelly> the thing I just did with the lists is nifty, but hardly common?
17:11:56 <EvilTerran> kbp, massively so
17:11:57 <lispy> > 99^99999 :: Integer
17:11:59 <lambdabot>   334060064317792914430486372645512124217815706770376769891842739347760011480...
17:12:09 <heatsink> :t fmap
17:12:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:12:13 <heatsink> :t ap
17:12:15 <EvilTerran> kbp, on 64-bit architecture, it may even be 2^(2^64), in theory (although you'd run out of memory first)
17:12:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:12:23 <endojelly> :t (Just (+1)) `ap` Just 5
17:12:24 <lambdabot> forall a. (Num a) => Maybe a
17:12:28 <heatsink> fm :: (m a -> b -> c) -> a -> b -> c
17:12:29 <kbp> thank you EvilTerran
17:12:30 <endojelly> > (Just (+1)) `ap` Just 5
17:12:32 <lambdabot>   Just 6
17:12:38 <endojelly> that's nice, too, but how is that useful
17:12:41 <c_wraith> endojelly: You can use do syntax and binding to never need ap.
17:12:49 <copumpkin> endojelly: you know liftA* or liftM* ?
17:12:53 <c_wraith> But sometimes it's more concise to just use it
17:12:55 <endojelly> copumpkin, yes!
17:12:59 <endojelly> copumpkin, I use those sometimes
17:13:03 <copumpkin> endojelly: you know how there's only up to liftM5 or so?
17:13:05 <lispy> So, I'm just wondering.  If the filterM thing works the way I think it does, there must be similar elegant ways to get the list monad to give you all the subsets
17:13:05 <EvilTerran> endojelly, you can use `fmap` and `ap` to do liftM*s with an arbitrary number of parameters
17:13:09 <endojelly> copumpkin, yes
17:13:26 <copumpkin> endojelly: liftMx f ... = f <$> a <*> b <*> ... <*> x
17:13:28 <endojelly> EvilTerran, oh? how so?
17:13:30 <endojelly> ooooh.
17:13:39 <copumpkin> you can see how that works if you break it down
17:13:42 <endojelly> that makes sense
17:13:48 <EvilTerran> > (,,,) <$> [1,2] <*> "ab" <*> "XY" <*> [False,True]
17:13:49 <lambdabot>   [(1,'a','X',False),(1,'a','X',True),(1,'a','Y',False),(1,'a','Y',True),(1,'...
17:13:54 <endojelly> copumpkin, yes, I understand
17:14:00 <copumpkin> it's pretty neat
17:14:02 <copumpkin> :)
17:14:07 <endojelly> cool. thanks!
17:14:51 <lispy> EvilTerran: whoa
17:14:57 <lispy> EvilTerran: that's actually really nice
17:15:11 <dibblego> @google Applicative Programming with Effects
17:15:13 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
17:15:13 <lambdabot> Title: Applicative Programming with Effects
17:15:19 <endojelly> > liftM2 (,,) [True,False] "ab"
17:15:22 <lambdabot>   Overlapping instances for GHC.Show.Show
17:15:22 <lambdabot>                              (c -> ...
17:15:34 <endojelly> > liftM2 (,,) [True,False] "ab" [1,2]
17:15:36 <lambdabot>   Couldn't match expected type `[t1] -> t'
17:15:44 <endojelly> :t liftM2
17:15:45 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:15:45 <EvilTerran> > liftM3 (,,) [True,False] "ab" [1,2]
17:15:47 <dibblego> > liftM3 (,,) [True,False] "ab" [1,2]
17:15:47 <lambdabot>   [(True,'a',1),(True,'a',2),(True,'b',1),(True,'b',2),(False,'a',1),(False,'...
17:15:49 <lambdabot>   [(True,'a',1),(True,'a',2),(True,'b',1),(True,'b',2),(False,'a',1),(False,'...
17:15:59 <EvilTerran> > liftM3 (,,) [True,False] "ab" [1,2] == (,,) <$> [True,False] <*> "ab" <*> [1,2]
17:16:01 <lambdabot>   Precedence parsing error
17:16:01 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `Co...
17:16:04 <EvilTerran> bah
17:16:05 <endojelly> oh, of course, thanks
17:16:19 <endojelly> :t (***)
17:16:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:18:23 <shachaf> lispy: What do you mean?
17:18:46 <endojelly> > liftM (+1) (Just 5)
17:18:49 <lambdabot>   Just 6
17:18:57 <endojelly> :t liftA
17:18:59 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:19:09 <endojelly> so that works on every functor
17:19:12 <endojelly> I get that now
17:19:21 <endojelly> I should take a look into Data.Functor
17:19:28 <c_wraith> @instances Arrow
17:19:29 <lambdabot> (->), Kleisli m
17:19:49 <endojelly> huh. there is no Data.Functor %)
17:20:14 <endojelly> ah, it's Control.Applicative
17:20:25 <endojelly> "This module describes a structure intermediate between a functor and a monad: it provides pure expressions and sequencing, but no binding."
17:20:28 <endojelly> oh, ok
17:21:17 <endojelly> but since liftA is just fmap and <*>, which both work on Functors, shouldn't liftA work on Functors, too?
17:21:22 <endojelly> instead of requiring Applicative?
17:21:35 <endojelly> aah, I see
17:21:41 <endojelly> every Functor is Applicative?
17:21:49 <endojelly> no
17:21:51 <endojelly> so...
17:21:58 <dibblego> every Applicative is a Functor
17:22:03 <copumpkin> endojelly: if you want to bend your mind over a function's type signature, try loop :P
17:22:07 <endojelly> :t liftA
17:22:09 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:22:13 <endojelly> :t (<*>)
17:22:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:22:15 <endojelly> :t fmap
17:22:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:22:29 <kbp> In the truth table: A (+) B (a circle with the plus inside), how can I read it? what does it mean? (I cant google because I don't know how to type that symbol)
17:22:38 <monoidal> xor?
17:22:53 <copumpkin> kbp: what's the truth table? it's often xor, but is also used as a generic operator
17:22:58 <kbp> xor is an upper arow
17:23:12 <kbp> oh yea, it's xor
17:23:22 <kbp> upper arrow is nor... I get int thank you
17:23:22 <monoidal> kbp, 'oplus
17:23:26 <monoidal> \oplus
17:23:28 <kbp> *it
17:23:54 <endojelly> > 10 <* Just 5
17:23:57 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:23:57 <lambdabot>    arising from the lite...
17:24:00 <monoidal> xor = (/=)
17:24:07 <EvilTerran> endojelly, <*> needs Applicative
17:24:11 <EvilTerran> Functor only has fmpa
17:24:12 <EvilTerran> *fmap
17:24:18 <burp> > pure (++"test") <*> Nothing
17:24:20 <lambdabot>   Nothing
17:24:40 <endojelly> EvilTerran, ah, I confused it with <$>
17:24:59 <EvilTerran> <$> is just an infix name for fmap
17:25:01 <EvilTerran> ?src (<$>)
17:25:02 <lambdabot> f <$> a = fmap f a
17:25:12 <endojelly> ok
17:25:26 <endojelly> :t (10 <*)
17:25:27 <lambdabot> forall (f :: * -> *) a b. (Num (f a), Applicative f) => f b -> f a
17:25:42 <copumpkin> :t loop
17:25:44 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
17:26:08 <endojelly> :t (() <*)
17:26:09 <lambdabot>     Couldn't match expected type `f a' against inferred type `()'
17:26:10 <lambdabot>     In the first argument of `(<*)', namely `()'
17:26:10 <lambdabot>     In the expression: (() <*)
17:26:18 <mauke> oh, does it fix d?
17:26:27 <copumpkin> basically
17:26:42 <endojelly> damn, I'm always confusing $ and *
17:26:47 <endojelly> and then wondering what the hell is going on 8)
17:26:57 <monoidal> Suppose data Expr = T | F | And Expr Expr | Or Expr Expr. Now I want to add quantifiers, how would you do it?
17:26:58 <endojelly> > 10 <$ Just 5
17:26:59 <lambdabot>   Just 10
17:27:03 <endojelly> that's what I wanted.
17:28:01 <conal> @ping ksf
17:28:04 <lambdabot> pong
17:28:10 <conal> oops
17:28:18 <conal> ksf: ping
17:28:22 <conal> @help ping
17:28:22 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(42,62): Non-exhaustive patterns in case
17:28:26 <conal> :(
17:28:27 <monoidal> the obvious way is ForAll (a -> Expr), but will I be able to get a symbolic version of a formula?
17:28:34 <endojelly> :t pure (+) <*> Just 1
17:28:36 <lambdabot> forall a. (Num a) => Maybe (a -> a)
17:28:46 <endojelly> :t pure (+) <*> Just 1 <*> Just 2
17:28:48 <lambdabot> forall a. (Num a) => Maybe a
17:28:51 <endojelly> > pure (+) <*> Just 1 <*> Just 2
17:28:52 <lambdabot>   Just 3
17:28:57 <endojelly> ok yeah I think I got it now
17:29:19 <endojelly> liftM was always really useful
17:29:44 <burp> > (++) <$> Just "co" <*> Just "ol"
17:29:46 <lambdabot>   Just "cool"
17:30:36 <EvilTerran> monoidal, that's an incredibly complicated question, i've managed to spend most of a year reading up on it
17:31:09 <endojelly> > Just "un" *> Just "cool"
17:31:11 <lambdabot>   Just "cool"
17:31:46 <monoidal> EvilTerran, there is no simple solution?
17:32:09 <EvilTerran> it depends on what you need
17:32:27 <burp> > (+) <$> Just 1 <*> Just 2
17:32:29 <lambdabot>   Just 3
17:32:46 <EvilTerran> monoidal, the most direct would be "data Expr = ... | Var String | ForAll String Expr"
17:33:07 <EvilTerran> monoidal, but then you have to worry about variable name shadowing, safe substitution, etc etc
17:33:27 <EvilTerran> i've seen your suggestion done before - i believe it's called "active abstract syntax"
17:33:28 <monoidal> yes, I'd like to not worry about that
17:33:45 <monoidal> I'd like to write brute force SAT/QBF solver with a comparatively easy interface
17:34:09 <monoidal> putting a formula to DNF/CNF, prenex normal form
17:34:12 <endojelly> :t filterM
17:34:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:34:22 <EvilTerran> (i may be remembering wrong)
17:34:36 <lispy> HOAS?
17:34:40 <EvilTerran> lispy, ah, that's the one
17:34:42 <lispy> highorder abstract syntax
17:34:46 <EvilTerran> AAS is something else, my bad
17:34:48 <lispy> higher*
17:34:59 <lispy> There was a cool paper about it in like 2007 at ICFP
17:35:17 <monoidal> exactly that. Thanks
17:35:31 <EvilTerran> monoidal, de Brujin indices are another fairly straightforward possibility
17:36:55 <EvilTerran> monoidal, they have the advantage of eliminating the problem of name collisions, but you have to fiddle around a bit with the Ints when you do substitutions etc, and free variables are fiddly
17:37:15 <lispy> monoidal: what are you doing again?
17:37:43 <monoidal> I'd like to write some simple logic formula manipulation system
17:38:27 <EvilTerran> monoidal, i've read about a few other approaches for representing syntax with quantifiers; there's a paper "i am not a number, i am a free variable" which is already in haskell
17:38:59 <EvilTerran> and one which i think was in o'caml, so fairly readily adapted, called the "calculus of indexed names and named indices"
17:39:59 <lispy> monoidal: oh, I'm not really sure what you need for creating that.  So, it will be rank-n formulas?
17:40:27 <EvilTerran> i came upon another haskell one recently, altho i've only skimmed the paper, by the name of "de Brujin notation as a nested data type"
17:40:30 <lispy> I'm not sure I asked that correctly.  So you'll be able to put universal and existential quantifiers anywehre in the formula?
17:41:10 <monoidal> yes. Something like forall a (exists b (a or b))
17:41:27 <EvilTerran> monoidal, all of these beyond concrete variable names, de Brujin indices, and HOAS are rather more involved, and each have their own pros and cons; anything beyond one of those may well be overkill for what you're doing
17:41:37 <lispy> If you use HOAS, then you may run into problems anytime your language can express something that Haskell + Extensions cannot express
17:41:56 <lispy> In particular, if you allow impredicative things
17:42:13 <lispy> I should warn you that, at this point, I'm outside my area of expertise :
17:42:14 <lispy> :)
17:42:30 <monoidal> Oh, with impredicativity Russel could arrise?
17:43:18 <lispy> Well, Haskell + Extensions doesn't like impredicativitiy
17:43:18 <lispy> it's undecidable in general IIRC
17:43:19 <monoidal> IIUIC I don't need it impredicativity
17:44:05 <lispy> Okay. I think the only time you may need it is if you wanted to write something that polymorphicaly handled something with a fancy type
17:44:24 <Twey> HOAS?
17:44:29 <Twey> Haskell On A Stick?
17:44:32 <monoidal> I need only a simple type theory, no dependent types or polymorphic :)
17:44:32 <lispy> But in that case, you could probably create an exitential wrapper
17:44:42 * heatsink looks at Chakravarty's website thing
17:44:55 <lispy> Twey: exactly :)  You  use GADTs to represent the types (quantifiers and all) in your abstract syntax data type
17:44:59 <heatsink> So HOAS is representing object language quantifiers with meta language functions?
17:45:06 <Twey> Haha!
17:45:15 <Twey> Nice
17:45:35 <lispy> Oddly enough, darcs does something similar with patch sequences
17:45:44 <lispy> But, the intent is different
17:45:48 <heatsink> That's how I interpret Lam :: (Term s -> Term t) -> Term (s -> t)
17:46:00 <Twey> I was actually (semi-)joking about the on a stick part.  It's very humorous to me to find that that is in fact what it stands for.
17:46:14 <heatsink> What?
17:46:19 <EvilTerran> monoidal, CINNI (http://formal.cs.uiuc.edu/stehr/cinni_eng.html) stikes me as being likely to be closest to what you want - it strikes a good comprimise between concrete variable names and de Brujin indices. unfortunately, the paper's quite dense, and describes it in incredibly general terms that can get a bit hard to follow in places
17:46:25 <heatsink> Is "stick" some categorical terminology I'm not familiar with?
17:46:29 <EvilTerran> Twey, er, it's "higher-order abstract syntax"
17:46:32 <Twey> I don't think so.
17:46:35 <Twey> EvilTerran: Oh
17:46:38 <Twey> That's less amusing :
17:46:40 <lispy> Twey: no I was teasing you :)
17:46:42 <EvilTerran> i think you were being wound up
17:46:54 <lispy> heatsink: :P
17:47:19 <lispy> as I understand it, higher-order here refers to the logical quantifiers
17:47:23 <Twey> Haha, seems so
17:47:28 <Twey> Evil lispy!
17:47:34 <lispy> just like first and second order logic
17:47:35 <monoidal> EvilTerran, is the paper available online?
17:48:04 <lispy> monoidal: http://www.citeulike.org/user/keigoi/article/3821628
17:48:35 <lispy> That's a good paper
17:48:35 <lispy> Not easy to follow
17:48:39 <lispy> But, the content is good
17:48:50 <EvilTerran> monoidal, er, sorry, i thought there was a link from that page; one second
17:50:48 <EvilTerran> monoidal, do you have access to those online technical paper repositories through a university or something? i can only find it on those
17:52:18 <monoidal> I'm not sure which ones are available. I can access jstor, but I don't remember acm or others
17:53:35 <monoidal> Thanks for all feedback. I wouldn't suppose that this could be so complex.
17:53:56 <lispy> monoidal: citeulike and xciteulike are both decent for getting access
17:54:08 <EvilTerran> monoidal, as one of my professors told me, "variables are hard"
17:54:57 <SamB_XP> lispy: I think you mean citeseer
17:55:00 <SamB_XP> and citeseerx
17:55:50 <lispy> oh, citeulike, citeseer, and citeseerx, thanks
17:56:26 <lispy> usually I don't think about them unless they come up in a google search :)
18:00:50 <monoidal> I've found that paper, and will read referenced material from CINNI. thanks lispy and EvilTerran
18:05:07 <BMeph> Does Haskell have a system for thread supervision, a la Erlang?
18:05:18 <copumpkin> supervision?
18:14:18 <kbp> is it possible to write a haskell program that can simplify logical expressions? (like v , ^, (+), xor, nand, nor etc)
18:14:53 <EvilTerran> yes
18:15:05 <kbp> (e.g. simplify (P<=>R) ^ ((P^Q) => R)
18:15:28 <EvilTerran> given an appropriate definition of "simplify". oh, and "logical expression".
18:17:39 <EvilTerran> for instance, an evaluator of propositional logic with no variables would be very straightforward
18:18:51 <copumpkin> how about encoding it in the type syste
18:18:51 <copumpkin> m
18:19:16 <heatsink> If you are interested in Boolean logic with free variables, there are ways to simplify it, but finding a "simplest" form is a very difficult problem in general.
18:21:02 <EvilTerran> you could aim for a canonical form, like conjunctive normal form, but it won't necessarily be the simplest form
18:21:26 <kbp> I've just found out the Wang's Algorithm on Google, im trying to writing a program that apply that algorithm to simplify...
18:21:41 <kbp> clausial form
18:22:50 <kbp> thank you for your ideas :)
18:25:46 <SamB_XP> isn't that such a great name for an algorithm?
18:26:37 <purplepenguins> i'm sure Wang is happy with it
18:27:18 <SamB_XP> eh, he probably hates the name ;-P
18:27:30 <SamB_XP> I bet people make a lot of poor jokes about it, after all!
18:33:18 <heatsink> Well, at least his name isn't "Long Wang".
18:33:31 <heatsink> There's one at my school.
18:36:46 * SamB_XP attempts to stifle the urge to ask if he is popular with the girls
18:37:27 <copumpkin> looks like you failed
18:37:55 <path[l]> haha
18:40:18 <EvilTerran> hm...
18:41:33 * EvilTerran determines that "class Control.Category.Category cat => CartesianClosed cat" isn't going to work
18:41:52 <EvilTerran> but category-extras' take makes my brain melt =/
18:50:48 <RyanT5000> is there any way to keep haskell code running while GCs take place? is this what the parallel GC does?
18:51:16 <Zao> Isn't the parallel in the parallel GC just that the GC pass has parallelism in it?
18:51:28 <RyanT5000> Zao: i was afraid that might be it :P
18:52:17 <RyanT5000> i'm in a situation where i can't afford 0.11 second random delays (specifically: a game, and i don't want to drop 2-3 frames sporadically)
18:52:46 <RyanT5000> which is how long GC takes given my game and platform (iphone)
18:52:54 <RyanT5000> (big GCs take that long, not small ones - they're fine)
18:53:12 <copumpkin> you could ask the gc to run occasionally when you have time to spare?
18:53:18 <copumpkin> to avoid big GCs?
18:53:29 <copumpkin> not sure whether that's possible
18:54:14 <RyanT5000> well, we tried that
18:54:25 <RyanT5000> it seems like it's whenever the old generations are getting GCed that there's a problem
18:54:34 <BMeph> How about the Wang tiles guy, "Hao Wang"?
18:54:42 <BMeph> Once his tiling conjecture was proven invalid, imagine how many "Hao Wang, you are!" jokes he had to go through... ;p
18:54:42 <mmorrow> RyanT5000: the parallel GC does collection in parallel, but a major collection's still stop-the-world
18:54:45 <RyanT5000> our current solution is to put a simple rendering algorithm in a C thread
18:54:56 <RyanT5000> which (obviously) is independent of the haskell runtime
18:55:02 <mmorrow> RyanT5000: also ghc's GC doesn't have bounded collection time
18:55:17 <RyanT5000> then we use pthreads stuff to marshal stuff between the C thread and the haskell thread(s)
18:56:03 <heatsink> RyanT5000: It's called "concurrent" when the GC and mutator run at the same time
18:56:48 <RyanT5000> heatsink: ah, good to know
18:57:03 <RyanT5000> i assume there's no way to make multiple haskell environments with separate GC systems, right?
18:57:07 <mmorrow> RyanT5000: and since ghc currently uses a single global heap, concurrent collection would noticeably hurt performance
18:57:17 <RyanT5000> ah, i see
18:58:39 <mmorrow> RyanT5000: there's a paper that looks into the possibility of a concurrent collector for ghc (a few years old) that you might find interesting
18:58:58 <mmorrow> RyanT5000: also a recent paper about the rts talks about this issue as well
18:58:59 <dolio> > fix $ \f -> 0 : (zipWith (+) f (1 : f))
18:59:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:59:09 <RyanT5000> mmorrow: hm; any idea who it's by?
18:59:16 * mmorrow is finding links
18:59:52 <lispy> RyanT5000: very likely to be by simon marlow
19:00:07 <RyanT5000> lispy: yeah, i guess that's true :P
19:00:21 <copumpkin> dolio: scanll!
19:00:25 <mmorrow> RyanT5000: well this is the new one http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/
19:00:34 <mmorrow> RyanT5000: trying to remember the name of the other one
19:01:16 <mmorrow> the title's some play on words with "concurrent"
19:01:29 <RyanT5000> hm
19:01:36 <lispy> has anyone made tools for converting a .prof file to something where the columns line up better, like excel?
19:01:48 <dolio> copumpkin: I was checking that that actually worked, because I cold have sworn that was the trick to doing it sufficiently 'guarded'.
19:01:57 <copumpkin> dolio: oh ok :)
19:02:02 <Phyx-> evening
19:02:19 <mmorrow> RyanT5000: ah n/m, this is it http://www.haskell.org/~simonmar/papers/ExploringBarrierToEntry.pdf
19:02:34 <mmorrow> (play on words with "barrier" ;)
19:02:43 <lispy> heh, the Simons always have such cute names on their papers
19:02:54 <lispy> like being lazy with class
19:03:57 <mmorrow> RyanT5000: a concurrent gc wasn't pursued beyond that paper though i don't believe
19:04:19 <RyanT5000> that's unfortunate
19:04:37 <mmorrow> RyanT5000: but the comments in the new paper about the changes that'd need to happen to support this/related to this are informative
19:04:40 <heatsink> lispy: I get the feeling they're continuing the Wadlerian tradition
19:04:44 <RyanT5000> it makes a whole class of uses of haskell much more difficult
19:05:18 <RyanT5000> mmorrow: yeah, i'll definitely take a look
19:05:29 <mmorrow> RyanT5000: yeah, regarding realtime stuff, timber is interesting
19:05:39 <mmorrow> http://timber-lang.org/
19:06:07 <lispy> I see now that .prof files open in excel pretty much how I want
19:08:15 <SamB_XP> lispy: what ... the ... heck?
19:08:34 <lispy> SamB_XP: well, Excel makes it easier to move things around and sort by column
19:08:47 <lispy> SamB_XP: i'm trying to understand why darcs uses so much memory
19:08:58 <SamB_XP> what black magic allows you to open the .prof files in it ?
19:19:56 <heatsink> SamB_XP: Excel has pretty good support for reading in ASCII format tables.  It probably infers columns based on spaces.
19:33:32 <blackdog> are S and K enough to build the rest of lambda calc?
19:34:15 <blackdog> the wiki article handwaves about a "reduced version of lambda calculus"...
19:35:22 <heatsink> Well, I think so, as unlambda pretty much uses them for everything.
19:36:01 <sjanssen> blackdog: in untyped lambda calculus, yes
19:36:04 <blackdog> cool.
19:37:29 <blackdog> (am trying to work out what the minimal set of flags you need on a perl regex to build a turing-equivalent machine are)
19:40:13 <veinor> Haha
19:40:25 <veinor> Whenever someone comes up with something, the first question is 'is it turing complete'?
19:41:11 <blackdog> well, yeah. but regular expressions are meant to be regular :)
19:41:18 <SamB_XP> blackdog: I thought they were only NP-complete!
19:41:46 <copumpkin> I'm still curious to see if there's any formal basis for perl regexps
19:41:55 <blackdog> you talking about the reduction of 3-SAT to perl regexes on plover.org?
19:42:26 <blackdog> bah, perl.plover.com i mean
19:42:43 <SamB_XP> blackdog: at least that ...
19:43:00 <blackdog> copumpkin: don't think so. they migh tbe trying to clean them up in perl6, but they've been endlessly extended in perl5
19:43:16 <SamB_XP> I was reading stuff on LtU and perlmonks regarding http://swtch.com/~rsc/regexp/regexp1.html
19:43:24 <copumpkin> oh I just mean, is there some class of formal languages that perl regexps can recognize?
19:43:49 <ray> regular ones? :)
19:43:57 <copumpkin> well yeah,
19:43:59 <copumpkin> but what more?
19:43:59 <blackdog> copumpkin: oh, right. yeah. i'm trying to prove that they can accept anything a turing machine can.
19:44:00 <SamB_XP> ray: not just that!
19:44:04 <monoidal> perl's regexpes are more expressive
19:44:16 <SamB_XP> they have backreferences
19:44:20 <glguy> Perl's regular expressions aren't
19:44:26 <monoidal> perl regexp matching is NP-hard
19:44:26 <blackdog> but it's all about which flags you use - there's a mechanism for including arbitrary perl code in there, that'd just make it a boring translation
19:44:40 <blackdog> monoidal: yeah, but that's the algorithm for doing the matching
19:45:08 <blackdog> you take a 3-SAT instance and reduce it to a particular regex
19:45:20 <blackdog> am trying to show that a given perl regex can implement a turing machine
19:45:37 <blackdog> without using the really really cheaty runtime flags
19:45:38 <copumpkin> not sure that's true
19:45:55 <copumpkin> not that I could prove it isn't
19:45:56 <ray> oh, perl regexps? of course there's no formal basis, it's perl
19:46:03 <blackdog> copumpkin: what's not true?
19:46:09 <blackdog> the NP proof is here, btw: http://perl.plover.com/NPC/NPC-3SAT.html
19:46:17 <copumpkin> ray: yeah, but people can reason about them after they were created :P
19:46:39 <copumpkin> blackdog: I don't "feel" that they're turing-equivalent, but I couldn't prove it either way :P
19:47:00 <monoidal> blackdog, I'd try something easier first - like proving it's PSPACE-complete
19:47:21 <monoidal> *-hard
19:48:13 <blackdog> monoidal: not sure i take your meaning. we're not talking about runtime cost or space here, it's about fundamental computability - language recognisers and all that.
19:48:55 <blackdog> copumpkin: to sketch a proof: there's a flag "/e" which executes the regular expression until it won't match any more.
19:49:24 <blackdog> copumpkin: you should be able to encode a turing tape as the input, and all the turing machine operations on the regex itself
19:49:26 <gwern> @rememer RichardOKeefe Some of the most appalling mathematical notation can be found in the Correspondence Analysis community, where the meaning of a subscript may depend not on the value of the subscript expression but its spelling.
19:49:26 <lambdabot> I will never forget.
19:49:38 <blackdog> (probably easier to do with SK combinators, but either way)
19:49:56 <monoidal> blackdog: If I understand correctly, you are trying to show that parsing is at least as hard as computing any recursive function. I'd try a reduction to some less expressive computional model
19:50:11 <monoidal> *from
19:50:58 <monoidal> this is a simpler task. If this is Turing-complete, then you should be able to reduce QBF to it
19:51:14 <blackdog> monoidal: hang on, where does parsing come in?
19:52:15 <blackdog> in concrete terms, i'd like to build a single regex that when applied to an unlambda program, gives the answer
19:52:28 <monoidal> hm, I probably misunderstood you
19:53:09 <monoidal> OK I was speaking of something different
19:53:14 <blackdog> i think i ended up in the same confusion when i looked at the 3SAT reduction, too - it's all about the implementation of the regex engine
19:53:26 <SamB_XP> blackdog: good luck getting call/cc correct!
19:55:11 <blackdog> SamB_XP: i don't have to, do i? so long as i can implement s,k and i...
19:55:26 <SamB_XP> hehehe
19:55:39 <monoidal> i=skk
19:55:52 <blackdog> true :)
20:00:12 <monoidal> is it possible for the matching algorithm to not halt?
20:01:12 <blackdog>  perl -pe '$_="a"; s/a/aa/g'
20:01:30 <blackdog> now, i can't prove it never halts... :)
20:01:38 <blackdog> at least not empirically
20:03:01 <blackdog> oh, wait, that's got an implicit loop in it
20:03:45 <u_quark> is there a way to hide a package in ghc within a file... with a pragma ?
20:06:30 <Saizan>  u_quark: tried with {-# OPTIONS_GHC -hide-package foo #-}? i'm not sure if it'll work
20:06:47 <u_quark> ow thanks Saizan
20:07:50 <mc___> is there something like NumPy for haskell, I googled for it but could find anythin useful
20:10:51 <mle> just an array library?
20:11:15 <MarcWeber> dcoutts: Does the cabal-install planner to something much more sensible than brue force to find a solution?
20:18:33 <Axman6> mc___: what do you want to do?
20:19:36 <||Zero||> http://projects.codersbase.com/repos/nehe-tuts/
20:19:51 <||Zero||> i have a error in lesson 7
20:20:22 <||Zero||> lispy u gave me that page
20:20:32 <||Zero||> do u know why i receive that error
20:21:52 <||Zero||> ??????
20:22:21 <||Zero||> please can u tell me
20:22:29 <Saizan> MarcWeber: yes
20:23:31 <Axman6> ||Zero||: you'd have to tell us what the error is
20:23:36 <Saizan> MarcWeber: much more sensible in terms of performance, though it's not guaranteed to find a solution
20:24:12 <MarcWeber> Saizan: So how can this be done? Asking this question is probably much faster than reading all the code.
20:24:33 <MarcWeber> it's not guaranteed to find a solution? What do you mean exactly? Can it miss possible solutions ?
20:24:42 <mmorrow> Saizan: cabal-install uses depth-first search, right?
20:24:48 <||Zero||> see in the link above
20:24:49 <Saizan> it can miss possible solutions, yeah
20:24:54 <||Zero||> this is
20:24:55 <||Zero||> http://projects.codersbase.com/repos/nehe-tuts/
20:24:56 <Saizan> it never backtracks.
20:24:58 <mmorrow> Saizan: i've wondered why not breadth-first?
20:25:01 <SamB_XP> it can fail to solve problems that are solvable?
20:25:02 <||Zero||> since lesson 6
20:25:13 <SamB_XP> ah, yes, it can
20:25:17 <Saizan> it just sorts the packages first and start eliminating possibilities
20:25:22 <Saizan> *starts
20:26:08 <Saizan> so, if early in the search it picks some version of a package it won't ever reconsider that choice
20:26:16 <MarcWeber> Saizan: I'd like to rewrite the functionality of cabal-install in nix.
20:27:12 <Saizan> MarcWeber: i'd go for an algorithm that gives more guarantees on being able to find a solution
20:27:29 <Saizan> using constraint programming techniques
20:27:30 <||Zero||> axman6 did u see wht is the problem
20:27:36 <MarcWeber> So actually this limitation can be implemented easily later on. So if A package THE_TARGET requires B-2.0 and A and A requires B-1.9 it will fail because it has chosen B-2.0 previously?
20:27:53 <Saizan> (the cabal-install solver was meant to be a temporary solution, afaiu)
20:28:11 <SamB_XP> so, in other words, go NP?
20:28:17 <Axman6> ||Zero||: no, i didn't, becuase you didn't show us the error message you're getting
20:28:22 <MarcWeber> Saizan: I hope I can reduce the "planner time" by specifying sensible flag defaults.
20:29:19 <Saizan> MarcWeber: yeah, it'll fail like that
20:29:38 <MarcWeber> Saizan: The funny part: Only taking latest versions of all packages results in a file containing dependencies of size 700kb ! It's amazing
20:30:03 <||Zero||> coul not find module Util
20:30:08 <MarcWeber> Saizan: Then I'm lucky. I can implement that as well by adding kind of take 1.
20:30:10 <||Zero||> tht is the error
20:31:01 <Saizan> MarcWeber: ah, wait, in your example it'll sort it out i think
20:31:34 <mmorrow> gah, i can't remember the link to sw17ch's article about regex implementation
20:31:41 <Saizan> MarcWeber: since it'll consider A first and prune out inconsistent versions of B
20:31:45 <mmorrow> it's very relevant to cabal-install
20:32:02 <Saizan> MarcWeber: it does a toposort of the dependencies first
20:32:11 <mmorrow> namely, how a depth-first implementation of the search has exponential complexity
20:32:33 <MarcWeber> Saizan: I already found a test case: leksah. cabal-install didn't find a solution.
20:32:33 <mmorrow> and a breadth-first scales
20:32:59 <MarcWeber> Saizan: What do you mean by top-sort?
20:33:15 <Saizan> MarcWeber: topological sort, according to the dependency graph
20:33:45 <MarcWeber> Saizan: I'll look it up.
20:34:03 <Saizan> however i can't say i understand the algorithm deeply
20:34:29 <Saizan> MarcWeber: so your aim is to mimick cabal-install or simply to have a good planner?
20:34:40 <MarcWeber> You had to write it in order to do so.
20:34:52 <MarcWeber> Saizan: A fast good planner should be enough.
20:35:53 <||Zero||> do someone know what i receive that error???
20:36:02 <MarcWeber> Saizan: Btw have you tried scion yet?
20:36:25 <Saizan> MarcWeber: not yet, is it easy to setup with emacs?
20:37:03 <MarcWeber> It should. I have failed to do so :-) I've completed the vim backend. But nominolo has been using it for a long while now with success.
20:37:31 <Saizan> ||Zero||: "could not find module Util" means that you're missing the Util module, maybe you forgot to copy an Util.hs file?
20:37:34 <||Zero||> Axman6 i told u the error
20:38:02 <Makoryu> Axman6: That xmonad quote you posted is hilarious
20:38:12 <||Zero||> util.hs file must be copied in the same file right??
20:38:30 <Axman6> Makoryu: heh, yeah
20:38:32 <Saizan> in the same directory
20:39:01 <||Zero||> i forgot to copy in the same directory
20:39:05 <||Zero||> jejeje plop
20:39:34 <mmorrow> MarcWeber: here's a topsort http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8502#a8502
20:40:09 <MarcWeber> Saizan: If you want I can show you how to setup the vim backend. That's done in about 5min. The features should roughly the same. Then you can decide whether you want to spend more time on it.
20:41:19 <ksf> hmmm. do I want to hack on conjure (and, most importantly, start to figure out what it already can do), or suffer the agony of binding to one of those c++ torrent libraries?
20:41:25 <ksf> ...or procrastinate?
20:41:31 <ksf> descisions, descisions...
20:42:39 <Saizan> MarcWeber: ok, where do i start?
20:43:07 <MarcWeber> Saizan: http://github.com/nominolo/scion get the git repo. Then use cabal install to compile the binary.
20:43:07 <Saizan> ksf: bind!
20:44:35 <ksf> I could do that inotify thing to make the app less portable to windoze.
20:44:39 <ksf> that's a good idea.
20:45:25 <Saizan> MarcWeber: done
20:45:34 <MarcWeber> Saizan: So topsort is used to build the bottom most deps first? Eg look at  http://en.wikipedia.org/wiki/Topsort (Examples). This isa requirement. I mean you can't build your target unless its dependencies are built. I fail to see how this affects performance. So it dependence on the sort beeing used. Maybe dcoutts can tell me more about it.
20:45:48 <MarcWeber> Saizan: Have a look at the README.markdown. Section Vim:
20:45:54 <mmorrow> MarcWeber: this is a better (@@) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8502#a8503
20:47:09 <MarcWeber> mmorrow: Have a look at the wikipedia articel "topsort" It shows that many different solutions exists. The question is: Which one to use to get the fastest planning result ?
20:47:20 <MarcWeber> Saizan: Also add "filetype plugin indent on
20:47:34 <MarcWeber> " (without ") after those lines to your .vimrc
20:47:57 <mmorrow> MarcWeber: it's irrelevant to speed of finding a set of deps that satisfy the version constraints
20:48:29 <MarcWeber> mmorrow: No, because flags can change things :)
20:48:56 <MarcWeber> mmorrow: I may be lacking some understanding though
20:49:07 <mmorrow> MarcWeber: dood, the complexity is in your search strategy.
20:49:30 <Saizan> it may affect which or if you find a solution, but not the speed
20:49:59 <mmorrow> like, do you follow all possible maybe-will-work paths in parallel? or blindly follow the first one until you either succeed or fail, and if fail start over at the last fork?
20:50:35 <mmorrow> currently i believe cabal-install does the latter, but if it fails it errors out rather than backtrack
20:50:50 <mmorrow> (??)
20:50:59 <Saizan> yeah, that's my understadning too
20:51:12 <mmorrow> i really wish i could remember that link to sw17ch's regex article
20:52:09 <mmorrow> MarcWeber: for instance, parsec does depth-first search of the search-space
20:52:19 <mmorrow> MarcWeber: which is why you need "try"
20:52:36 <Saizan> and the topsort is used to decide in which order to look at packages, and the starting ones are those which are not dependencies of others
20:53:38 <Saizan> mmorrow: that's not totally true, String -> [(a,String)] is depthfirst but you don't need try
20:54:13 <mmorrow> hmm, but does it consider the entire String match as a unit?
20:54:33 <Saizan> try is needed because parsec throws away branches of the backtracking tree by default
20:54:46 <MarcWeber> Saizan: There is no other way. How should you know where to start when picking dependencies going bottom up? I mean you don't know yet which packages are at the bottom.
20:54:52 <mmorrow> , runP ((char 'a' >> char 'c') +++ (char 'a' >> char 'b')) "ab"
20:54:57 <lunabot>  ("b","")
20:55:12 <MarcWeber> mmorrow, Saizan : order of visiting nodes can make a difference : http://dpaste.com/84437/ (when doing  backtracking)
20:55:44 <Saizan> MarcWeber: you can easily do a first pass where you collect all the possibily interesting packages, that's what cabal-install does before the topsort actually
20:56:14 <mmorrow> MarcWeber: sure, it may affect your ultimate solution, but we're considering any two solutions to be just as good
20:57:14 <MarcWeber> Saizan: You don't know all of them. Because dependencies of C may depend on the version of C.
20:57:24 <Saizan> MarcWeber: you get the union
20:58:07 <mmorrow> , runP (pfail +++ (char 'a' >> char 'c') +++ (char 'a' >> char 'b')) "ab"
20:58:09 <lunabot>  ("b","")
20:59:48 <SamB_XP> mmorrow: http://swtch.com/~rsc/regexp/regexp1.html
20:59:55 <mmorrow> SamB_XP: wooo!
21:00:00 <mmorrow> ahh
21:00:02 <mmorrow> swtch.com
21:00:11 * mmorrow was trying with sw17ch
21:00:25 <SamB_XP> had it open already, I did
21:00:31 <mmorrow> heh
21:00:43 <Saizan> MarcWeber: however, i'd really go with the constraint programming route to write a solver
21:00:56 <SamB_XP> and now if I google for regular expressions it comes up near the top, for me ;-)
21:04:18 <mmorrow> i love how the perl graph is in (s) and the nfa one is in (ms)
21:05:37 <absentia> 2009-08-24T00:04:19.714+0000 ns get_ping 0.084000 ms
21:05:59 <MarcWeber> Saizan: http://dpaste.com/84440/ . How is your vim setup?
21:06:20 <MarcWeber> mmorrow: What's so exciting about those regular expressions ?
21:06:43 <mmorrow> MarcWeber: the search method
21:07:08 <mmorrow> MarcWeber: imagine instead of regular expressions, we're matching, say, package constraints ;)
21:07:27 * dmwit blinks
21:07:34 <dmwit> , runP (char 'a') "a"
21:07:36 <lunabot>  ("a","")
21:07:37 <SamB_XP> MarcWeber: how absolutely awful most mainstream languages' implementations are
21:07:43 <dmwit> , :t runP
21:07:44 <lunabot>  luna: Couldn't match expected type `(Text.ParserCombinators.ReadP.ReadP
21:07:48 <dmwit> err
21:07:55 <mmorrow> dmwit: one sec
21:08:08 <MarcWeber> hehe :-) \d+\.\d+\.\d+ ?
21:08:48 <MarcWeber> SamB_XP: What are you talking about now? What code have you been looking at?
21:09:14 <SamB_XP> MarcWeber: just look at the graph near the bottom
21:09:14 <mmorrow> dmwit: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3394#a3394
21:09:28 <mmorrow> dmwit: shortest and longest parses
21:09:35 <SamB_XP> with PCRE, Python, Perl, and Ruby on the top there
21:09:37 <u_quark> is lunabot better than lambdabot ? does it only eval haskell ?
21:09:44 <mmorrow> (err, first and last more correctly)
21:09:53 <mmorrow> u_quark: it only evals haskell
21:10:10 <SamB_XP> and awk, tcl, GNU grep, Thompson NFA, and GNU grep at the bottom
21:10:18 <MarcWeber> SamB_XP: Which page?
21:10:29 <SamB_XP> http://swtch.com/~rsc/regexp/regexp1.html
21:10:41 <SamB_XP> The following graph plots time required to check whether a?nan matches an:
21:10:41 <u_quark> it evals haskell in a better way than lambdabot/mueval ?
21:10:45 <SamB_XP> then the graph
21:11:00 <mmorrow> u_quark: a little differently
21:11:14 <mmorrow> u_quark: http://moonpatio.com/repos/lunabot/
21:11:16 <dmwit> mmorrow: Why return ([a], String) when you know it will have exactly one element?
21:11:25 <dmwit> s/exactly/at most/
21:11:29 <mmorrow> dmwit: ([],String) is a failed parse
21:11:30 <MarcWeber> SamB_XP: He. I remember. I've bookmarked that page. There is a vim page AFAIK adding this ipmlementation. However I don't konw how usable it is. The "background compilation" patch is very bad and buggy.
21:11:31 <mmorrow> i hate Maybe
21:11:34 <mmorrow> :)
21:11:40 <dmwit> ...
21:11:42 <u_quark> is it quicker/more secure ? --yes there is no information there ...
21:12:10 <mmorrow> u_quark: maybe either, or neither, not sure
21:12:22 <u_quark> ok
21:12:43 <mmorrow> u_quark: it does template-haskell (although lambdabot could do this too, but it's disabled)
21:13:10 <mmorrow> u_quark: and it talks directly to ghc through the ghc-api rather than through an external process (mueval)
21:13:28 <mmorrow> well, the bot and the evaluator are in separate procs
21:13:42 <mmorrow> so you can use rlimits on the eval proc to control it
21:13:51 <mmorrow> and killing it doesn't zap the bot
21:14:09 <MarcWeber> Saizan: So how are you going ?
21:15:29 <mmorrow> u_quark: lunabot isn't very well documented
21:15:48 <mmorrow> u_quark: so if it works, it'll work nicely, but if it doesn't you'd need to hack
21:16:47 <u_quark> and it's not in hackage either
21:16:52 <mmorrow> u_quark: no
21:17:06 <mmorrow> u_quark: it's not quite completely organized yet
21:18:59 <Axman6> so, how hard do you think it would be to a) parse C using haskell, and b) compile it?
21:19:20 <Makoryu> Axman6: As hard as any language, really
21:19:40 <Axman6> not, not as hard as C++ ;)
21:19:58 <Makoryu> Well.... Any language actually usable by mortals
21:20:59 <u_quark> tnx mmorrow
21:21:08 <ray> parsing isn't too hard
21:21:47 <Berengal_> Parsing is one of the strong points of haskell
21:21:58 <Berengal_> Well, everything is a strong point of haskell...
21:22:03 <Makoryu> I'm more curious about the parts *after* parsing
21:22:09 * Axman6 wish he understood parsing, but hasn't tried to before
21:22:14 <Makoryu> What's the GHC approach to decorating the syntax tree?
21:22:32 <Axman6> Makoryu: tinsel
21:22:36 <Axman6> and a star
21:23:18 <u_quark> Makoryu: happy supports attributes grammars
21:23:22 <Makoryu> Axman6: ENTERPRISE QUALITY
21:23:29 <Makoryu> u_quark: Hmmmmm, I'll take a look
21:23:30 <u_quark> (last time I checked)
21:23:52 <Axman6> Makoryu: titanium tinsel!
21:23:54 * Makoryu has never actually implemented a working semantic analyzer in any language
21:24:01 * Makoryu is ashamed of this
21:25:25 <Berengal_> You could probably just eval the AST with a Writer ASM... for sufficient values of just
21:25:43 <u_quark> it's quite fun with attribute grammars, especially with haskell that you don't have to make all attributes be top-down or bottom-up due to laziness
21:26:36 <mmorrow> u_quark: np
21:27:13 <Axman6> is there any reason why cabal-install can't be included with GHC?
21:27:37 <Saizan> MarcWeber: ah, sorry, i need to work on something else right now, i'll try it out later
21:27:51 <MarcWeber> Saizan: I'll fall asleep now. Hopefull I'll dream about topsort algorithms.. :) cu
21:28:11 <Saizan> MarcWeber: bye :)
21:31:18 <Axman6> topsort?
21:32:03 <Saizan> http://en.wikipedia.org/wiki/Topsort
21:32:27 <Axman6> ah
21:41:18 <Axman6> excelent, gitit crashes on OS X
21:42:00 <path[w]> hello
21:42:06 <Axman6> o/
21:42:59 <dmwit> path[w]: Cheerio, good chap!
21:43:16 <dmwit> How may we be of service on such a fine night for such a fine gentlemen?
21:43:45 <dmwit> Can we interest you in some of our refined monad?  Only the purest essence of computation offered here.
21:44:07 <Axman6> obviously, IO is off the menu tonight
21:44:42 <dmwit> House Special!  We offer a StateT RealWorld# m a.
21:44:49 <path[w]> its morning here. Just reading the monad guides linked on haskellwiki. Just saying hi =p
21:45:11 <dmwit> Ah, in that case, I strongly suggest the sigfpe, one of our finest dishes.
21:45:17 <dmwit> ?go you could have invented monads and maybe you already have
21:45:18 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
21:45:18 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
21:45:26 <path[w]> haha I have that open too
21:50:15 <agnokapathetic> so i'm looking at http://matpalm.com/median/index.html (curently #6 on hacker news) and thinking this could be done faster with Radix Sort rather than Quick Sort (my question is in two parts): A: is this a correct line of thinking? and B: is there a handy haskell radix sort somewhere for reference?
21:51:33 <dmwit> A: probably
21:51:35 <dmwit> B: no
21:52:11 <agnokapathetic> thanks dmwit :) thats exactly what Google said
21:52:18 <dmwit> As for B, you might want to have a look at Data.Bits.
21:52:37 <dmwit> That would probably be the right class to use when implementing radix sort.
21:52:56 <agnokapathetic> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.3607 derivives his own Digit type
21:53:08 <agnokapathetic> but i think that might be more suited to arbitrary precision
21:53:17 <agnokapathetic> rather than raw Ints
21:54:58 <dmwit> But uh...
21:55:10 <dmwit> Isn't there a really well-known, really clever O(n) solution for median?
21:55:52 <dmwit> Like, the one that gets introduced in Algorithms 101, and everybody stares in awe at the magic number (5/7 or something) that is just big enough and also just small enough to make the proof of O(n)-ness go through...
21:56:37 <blackdog> O(n) might not be good enough if it restricts you to  a single-threaded computation
21:56:53 <dmwit> Radix sort is going to do that, anyway, no?
21:57:02 <jfoutz> at first look, since he's only generating numbers from 200 to 300, it seems like you could estimate the frequency of each value, and come up with a really good guess.
21:57:03 <Orclev> paticularly not with how common multi-core systems are now
21:57:17 <path[w]> is Radix sort O(n)?
21:57:34 <path[w]> hmm yeah I guess it's 6 passes of n for digits upto a million
21:57:37 <dmwit> It is O(m*n), m the size (in bits) of the values.  Since m is constant... yes.
21:57:38 <path[w]> neat
21:57:58 <path[w]> I miss not having studied CS lol
21:58:02 <dmwit> But flash-sort is pretty much guaranteed to be faster.
21:58:06 <blackdog> jfoutz: yeah, that's what i was thinking - unless some of the numbers are way bigger than a trillion, a frequency table is better
21:58:10 <Rotaerk> what module do you guys use for DB interaction
21:58:20 <dmwit> Flash-sort is really, really great when you have a lot of information about the distribution of values that are coming in.
21:58:20 <path[w]> whats that 5/7 thing you were talking about dmwit
21:58:20 <Rotaerk> HDBC? HaskellDB?
21:58:23 * Axman6 quite likes beadsort
21:58:36 <Saizan_> agnokapathetic: there's a radix sort here http://hackage.haskell.org/packages/archive/uvector-algorithms/0.1.1/doc/html/Data-Array-Vector-Algorithms-Radix.html
21:59:14 <Draconx> path[w], it's "Blum, Floyd, Pratt, Rivest and Tarjan".
21:59:54 <path[w]> wow I didnt know sorting could ever be done in less than nlogn time till now
22:00:15 <dmwit> path[w]: n log(n) assumes the only operation you have is comparison.
22:00:22 <Draconx> I think it's main purpose is to prove that you can obtain worst-case nlogn with quicksort.
22:00:30 <dmwit> Radix sort does more than comparison, so the impossibility result doesn't apply.
22:01:10 <blackdog> Draconx: you can't, can you? I thought there was always a pessimal input to quicksort, if you know the pivot selection function.
22:01:25 <Draconx> blackdog, the aforementioned algorithm allows you to pick the optimal pivot every time.
22:01:36 <Draconx> (in linear time)
22:02:07 <path[w]> so you mean nlogn is only for non ordinal things where you have comparisons but not necessarily a mapping to numbers?
22:02:41 <Rotaerk> guess i'll look into HDBC
22:03:19 <Draconx> blackdog, in practice though, random pivot is usually better.
22:03:40 <dmwit> If the only way you have to observe the elements of a list is via comparison (i.e. is a less than b), then any general-purpose sorting algorithm takes at least c*n*log(n) time for some constant c and large enough n.
22:04:11 <dmwit> You can imagine all kinds of other observations (not just mappings to numbers) that break this result.
22:04:17 <jfoutz> hmm. with the size of the numbers restricted to 32 bits, it seems like there's not enough room to drag the median to far away from the mean.
22:05:44 <path[w]> I see
22:07:02 <copumpkin> are there any type analysis systems that would allow occasional inference that a smaller subtype would be sufficient to hold all values in a larger declared type? say I wrote x :: Integer; x = 42... it can statically determine that I can store that in an Int behind the scenes (ignoring that the integer-gmp stores it as such already), but can that be done for more complicated expressions?
22:07:23 <copumpkin> (and I realize that it's not possible in general, but have people tried doing it for certain non-general cases?)
22:07:57 * copumpkin pre-emptively braces himself against the "it's not possible" people :)
22:08:05 <mauke> sounds like something a lisp compiler would do
22:08:22 <path[w]> meh the flashsort java applets dont work
22:10:47 <jfoutz> yeah, worst case, 2^32 -1 and 10^12-1 ones, averages to 5.2... so you could calculate the average, then make another pass counting above and below the average value, (avg -1) .. (avg-5), (avg+1)..(avg +5) two passes. embarasingly parallel.
22:11:48 <dmwit> path[w]: Yeah, the flashsort guy is kind of a crank.  I never could find any of his papers, either.
22:12:39 <copumpkin> @go flashsort
22:12:40 <lambdabot> http://www.neubert.net/FSOIntro.html
22:12:40 <lambdabot> Title: FlashSort Algorithm
22:13:02 <copumpkin> it's not in my CLRS book, so it does not exist
22:13:08 <dmwit> http://www.ddj.com/architect/184410496
22:13:11 * copumpkin plugs his ears and goes lalala
22:13:36 <copumpkin> ooh
22:13:36 <copumpkin> The algorithm FlashSort sorts in O(n) time without the manipulation of n extra "tag" bits.
22:13:49 <dmwit> The idea is pretty easy to understand: go through the list once, swapping each element with its "expected" position, then clean up after yourself, now that the list is damn near sorted.
22:14:18 <copumpkin> his paper is a .doc? :o
22:14:22 <copumpkin> flashsort--
22:14:57 <jfoutz> hrm. how can the median not be the mean?
22:15:01 <jfoutz> > (2^32 -1 + 999999999) `div` 10^12
22:15:06 <lambdabot>   mueval-core: Prelude.read: no parse
22:15:06 <lambdabot>  mueval: ExitFailure 1
22:15:17 <jfoutz> yeah whatever
22:15:34 <dmwit> jfoutz: What's the median of the list [2, 2, 3]?
22:15:46 <Trinithis> 2
22:15:56 <jfoutz> dmwit: there's not enough room
22:15:56 <dmwit> ...and the mean? ;-)
22:16:08 <Trinithis> 7/3
22:16:09 <copumpkin> 2, with rounding!
22:16:16 <dmwit> meh
22:16:20 <dmwit> [2,2,30], then
22:16:24 <copumpkin> :(
22:16:26 <Trinithis> l.ol
22:16:28 <sshc> is there a standard function to test if a list is a singleton?
22:16:36 <copumpkin> sshc: null . drop 1
22:16:36 <dmwit> null . drop 1
22:16:41 <copumpkin> :)
22:16:46 <dmwit> or
22:16:52 * copumpkin resists the urge to bring up the stereo quote
22:17:00 <dmwit> (1 ==) . (genericLength :: [a] -> Natural)
22:17:05 <dibblego> > null . drop 1 $ [] -- singleton??
22:17:06 <lambdabot>   True
22:17:09 * Trinithis wants to hear
22:17:11 <dibblego> bzzt
22:17:11 <dmwit> whoops!
22:17:20 <copumpkin> dibblego: oh no!
22:17:30 <jfoutz> dmwit: how about (take 1000000000000 [1,1...]) ++ [any32bitnumber])
22:17:52 <dmwit> > 10^12 :: Int
22:17:54 <lambdabot>   1000000000000
22:18:04 <dmwit> > 10^12 :: Word32
22:18:06 <lambdabot>   3567587328
22:18:11 <dmwit> ah
22:18:15 <dmwit> I see what you're getting at.
22:18:28 * jfoutz nods
22:18:42 <copumpkin> liftA2 (/=) null (null . drop 1)
22:18:46 <copumpkin> how's that as a isSingleton!
22:18:51 <jfoutz> you only have to look "near" the average value.
22:19:00 <dmwit> uh
22:19:05 <path[w]> you think so?
22:19:24 <dibblego> (== 1) . length . take 1
22:19:35 <jfoutz> i *think* so... but i could be really really bad at math.
22:19:40 <dmwit> dibblego: take 2
22:19:42 <path[w]> 10 1s, 5 2s and 8 millions
22:19:48 <copumpkin> dibblego: but it didn't use any funky applicative instances :(
22:19:49 <path[w]> the median is 1 isnt it
22:19:56 <copumpkin> dibblego: code golf is not complete without applicative :(
22:20:02 <path[w]> so what does "near" mean
22:20:17 <dibblego> pure id <$> (== 1) . length . take 1
22:20:18 <dmwit> singleton [_] = True; singleton _ = False
22:20:21 <path[w]> or is median 2?
22:20:22 <copumpkin> lol
22:20:25 <path[w]> Im confused
22:20:30 <dibblego> pure id <*> (== 1) . length . take 1
22:20:37 <path[w]> s median the middle number?
22:20:39 <copumpkin> dibblego: thanks!
22:20:44 <dibblego> np :)
22:20:45 <path[w]> or the most occuring number
22:20:46 <dmwit> dibblego: You have to take 2!
22:20:48 <Trinithis> :t (take1 >>= (==) . take 1)
22:20:52 <lambdabot> Not in scope: `take1'
22:20:57 <Trinithis> :t (take 1 >>= (==) . take 1)
22:20:58 <lambdabot> forall a. (Eq a) => [a] -> Bool
22:20:59 <dibblego> dmwit, why 2?
22:21:12 <dmwit> dibblego: Otherwise all lists longer than length 1 would satisfy your predicate.
22:21:45 <dmwit> > (==1) . length . take 1 $ [1,2]
22:21:48 <lambdabot>   True
22:21:56 <dmwit> > (==1) . length . take 2 $ [1,2]
22:21:57 <lambdabot>   False
22:22:04 <dibblego> yes, that may be, but I'd really like to avoid using Applicative
22:22:12 <copumpkin> :(
22:22:28 <copumpkin> you can use Monad like Trinithis did
22:22:33 <dmwit> :t ap (==) (take 1)
22:22:35 <lambdabot> forall a. (Eq a) => [a] -> Bool
22:22:35 <Trinithis> mine failed
22:22:36 <dibblego> even Applicatives have over-use injuries
22:22:41 <Trinithis> it succeeds on []
22:22:59 <dmwit> oh, no, that's still bad
22:23:03 <Trinithis> :t (take1 >>= (==) . take 2)
22:23:04 <lambdabot> Not in scope: `take1'
22:23:07 <Trinithis> (take1 >>= (==) . take 2) []
22:23:10 <copumpkin> lol
22:23:11 <Trinithis> > (take1 >>= (==) . take 2) []
22:23:13 <lambdabot>   Not in scope: `take1'
22:23:16 <copumpkin> take1 is not a function!
22:23:18 <copumpkin> :)
22:23:20 <Trinithis> > (take 1 >>= (==) . take 2) []
22:23:21 <lambdabot>   True
22:23:25 <Trinithis> oh
22:23:41 <Axman6> @pl \xs -> null xs /= take 1 xs
22:23:42 <lambdabot> liftM2 (/=) null (take 1)
22:23:44 <u_quark> (\x-> case x of { [_] -> True; _ -> False })
22:23:54 <Axman6> > \xs -> null xs /= take 1 xs $ []
22:23:55 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:24:14 <Axman6> > (\xs -> null xs /= take 1 xs) $ []
22:24:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:24:26 <Axman6> :t (\xs -> null xs /= take 1 xs)
22:24:27 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
22:24:28 <lambdabot>     In the second argument of `(/=)', namely `take 1 xs'
22:24:28 <lambdabot>     In the expression: null xs /= take 1 xs
22:24:38 <copumpkin> Axman6: you forgot a null
22:24:44 <Axman6> > (\xs -> null xs /= (null . take 1 xs)) $ []
22:24:45 <Axman6> indeed
22:24:45 <lambdabot>   Couldn't match expected type `a -> [a1]'
22:24:49 <copumpkin> and a $
22:24:55 <Axman6> >_<
22:24:59 <Trinithis> fromisJust . listToMaybe . take 1 $ []
22:25:00 <Axman6> > (\xs -> null xs /= (null . take 1 $ xs)) $ []
22:25:01 <copumpkin> then it just becomes what I wrote earlier
22:25:02 <lambdabot>   False
22:25:05 <Axman6> > (\xs -> null xs /= (null . take 1 $ xs)) $ [1]
22:25:06 <lambdabot>   False
22:25:10 <Trinithis> > isJust . listToMaybe . take 1 $ []
22:25:10 <Axman6> lame
22:25:12 <lambdabot>   False
22:25:21 <copumpkin> Trinithis: that won't work for same reason dibblego's didn't earlier
22:25:42 <Trinithis> oops, i forgot
22:26:29 * copumpkin votes for the pattern matching against [_] :P
22:26:34 <copumpkin> despite no applicative :(
22:26:56 <Saizan_> ?pl inits xs !! 1 == xs
22:26:56 <lambdabot> inits xs !! 1 == xs
22:27:02 <Saizan_> ?pl \xs -> inits xs !! 1 == xs
22:27:03 <lambdabot> (==) =<< (!! 1) . inits
22:27:06 <copumpkin> lol
22:27:06 <dibblego> > let isSingle = (/=) <$> null <*> (null . drop 1) in isSingle <$> [[], [7], [7, 8]]
22:27:08 <lambdabot>   [False,True,False]
22:27:15 <u_quark> copumpkin: :)
22:27:38 <copumpkin> :)
22:27:40 <sshc> > (==1) . length $ "simplest"
22:27:41 <lambdabot>   False
22:27:45 <sshc> > (==1) . length $ "s"
22:27:46 <lambdabot>   True
22:27:49 <sshc> > (==1) . length $ ""
22:27:49 <copumpkin> sshc: what if it's infinite!
22:27:50 <lambdabot>   False
22:27:54 <dmwit> sshc: wrongest
22:28:02 <copumpkin> sshc: you want dmwit's natural genericLength then
22:28:11 <sshc> copumpkin: oh I didn't think of infinite
22:28:24 <dmwit> Or even just plain undefined.
22:28:30 <sshc> > (==1) . length $ [1,1..]
22:28:34 <Saizan_> or even just a long list
22:28:35 <copumpkin> > genericLength [1..] > (3 :: Natural)
22:28:35 <lambdabot>   mueval-core: Prelude.read: no parse
22:28:35 <lambdabot>  mueval: ExitFailure 1
22:28:36 <lambdabot>   True
22:28:56 <Saizan_> length is O(n)
22:29:11 <sshc> dmwit: undefined?
22:29:12 <copumpkin> unless it's lazy
22:29:20 <dmwit> > let singletonA [_] = True; singletonA _ = False; singletonB = (== 1) . length in (singletonA (undefined:undefined), singletonB (undefined:undefined))
22:29:22 <lambdabot>   (* Exception: Prelude.undefined
22:29:39 <dmwit> eh?
22:29:47 <dmwit> eh?oh
22:29:51 <dibblego> > let isSingle = (/=) <$> null <*> (null . drop 1) in isSingle <$> [[], [undefined], [undefined, undefined]]
22:29:54 <lambdabot>   [False,True,False]
22:29:56 <Saizan_> [_] = _:[]
22:30:06 <dmwit> > let singletonA [_] = True; singletonA _ = False; singletonB = (== 1) . length in (singletonA (undefined:undefined:undefined), singletonB (undefined:undefined:undefined))
22:30:08 <lambdabot>   (False,* Exception: Prelude.undefined
22:30:34 <dmwit> dibblego: It's not the values that matters, it's the tails.  But your definition is just fine in this regard.
22:30:58 <dibblego> hmm yes
22:35:23 <Trinithis> > (\xs -> not . null $ do {[x] <- [xs] ; [x]}) [1,2]
22:35:24 <lambdabot>   False
22:37:10 <dmwit> cute
22:37:18 <copumpkin> :)
22:38:55 <dmwit> :t foldr
22:38:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:41:08 <dmwit> > let f _ (Just False) = Just True; f _ _ = Nothing in fromMaybe False . foldr f (Just False) $ [1]
22:41:09 <lambdabot>   True
22:41:39 <dmwit> > let f _ (Just False) = Just True; f _ _ = Nothing; singleton = fromMaybe False . foldr f (Just False) in map singleton (tails [1,2])
22:41:41 <lambdabot>   [False,True,False]
22:41:45 <dmwit> \o-
22:42:12 <dmwit> aw
22:42:21 <dmwit> > let f _ (Just False) = Just True; f _ _ = Nothing; singleton = fromMaybe False . foldr f (Just False) in singleton [1..]
22:42:24 <lambdabot>   * Exception: stack overflow
22:42:27 <dmwit> =/
22:43:46 <sshc> > let lastButOne xs = fst $ foldl (\acc x -> (acc, x)) (xs !! 1, xs !! 2) in lastButOne "foobar"
22:43:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
22:43:56 <sshc> ^ ?
22:44:17 <Makoryu> :t foldl
22:44:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:44:20 <Makoryu> :t foldr
22:44:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:44:40 <dmwit> > let singleton = ([0] ==) . zip [0..] in map singleton [[], [()], [(), ()], repeat ()]
22:44:42 <lambdabot>   No instance for (GHC.Num.Num (t, ()))
22:44:42 <lambdabot>    arising from the literal `0' at <i...
22:44:48 <dmwit> whoops
22:44:55 <dmwit> > let singleton = ([0] ==) . zipWith const [0..] in map singleton [[], [()], [(), ()], repeat ()]
22:44:57 <lambdabot>   [False,True,False,False]
22:45:04 <dmwit> \o/
22:45:52 <dmwit> sshc: You probably want to fold over xs.
22:45:55 <copumpkin> :)
22:46:01 <dmwit> sshc: Also, your accumulators are not so likely to be lists themselves.
22:46:25 <mmorrow> , let singleton xs = not null xs && take 1 xs == take 2 xs in fmap singleton [[], [()], [(), ()], repeat ()]
22:46:26 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
22:46:35 <mmorrow> , let singleton xs = (not . null) xs && take 1 xs == take 2 xs in fmap singleton [[], [()], [(), ()], repeat ()]
22:46:36 <lunabot>  [False,True,False,False]
22:46:53 <dmwit> mmorrow: But that puts an Eq constraint on your elements. =(
22:46:57 <mmorrow> grr
22:47:21 <copumpkin> it's amazing how much fun can be had with simple questions like that :P
22:47:26 <mmorrow> , let singleton xs = (not . null) xs && length (take 2 xs) == 1 in fmap singleton [[], [()], [(), ()], repeat ()]
22:47:27 <lunabot>  [False,True,False,False]
22:47:38 <dmwit> not lazy enough
22:47:48 <mmorrow> , let singleton = (==1) . length . take 2 in fmap singleton [[], [()], [(), ()], repeat ()]
22:47:50 <lunabot>  [False,True,False,False]
22:47:58 <Saizan_> > let singleton = ([()] ==) . zipWith const (repeat ()) in map singleton [[], [()], [(), ()], repeat ()]
22:48:00 <lambdabot>   [False,True,False,False]
22:48:00 <mmorrow> dmwit: ?
22:48:03 <dmwit> I lied.
22:48:05 <mmorrow> heh
22:48:52 <sshc> dmwit: aren't I already folding over xs?
22:48:53 <copumpkin> , let singleton = (==1) . length . take 2 in fmap singleton [[], [()], [(), ()], repeat (), (undefined : undefined)]
22:48:55 <lunabot>  luna: Prelude.undefined
22:49:00 <dmwit> > let singleton = ([0] ==) . zip [0,0] in map singleton [[], [1], [1,2], [1..]]
22:49:01 <lambdabot>   No instance for (GHC.Num.Num (t, b))
22:49:02 <lambdabot>    arising from the literal `0' at <in...
22:49:10 <dmwit> ack
22:49:15 <dmwit> > let singleton = ([0] ==) . zipWith const [0,0] in map singleton [[], [1], [1,2], [1..]]
22:49:16 <lambdabot>   [False,True,False,False]
22:49:41 <mmorrow> > let singleton = ([0] ==) . zipWith const [0,0] in map singleton [[], [1], [1,2], [1..], repeat undefined]
22:49:43 <lambdabot>   [False,True,False,False,False]
22:49:57 <mmorrow> , let singleton = ([0] ==) . zipWith const [0,0] in map singleton [[], [1], [1,2], [1..], repeat undefined]
22:49:59 <lunabot>  [False,True,False,False,False]
22:50:09 <mmorrow> , let singleton = (==1) . length . take 2 in fmap singleton [[], [()], [(), ()], repeat undefined]
22:50:10 <lunabot>  [False,True,False,False]
22:50:16 <mmorrow> um
22:50:22 <mmorrow> oh
22:50:25 * Axman6 has a feeling using [()] and [(),()] would be more efficient
22:50:26 <copumpkin> repeat undefined isn't the problem
22:50:27 <mmorrow> undefined : undefined
22:50:40 <dmwit> yep
22:51:00 <u_quark> > let singleton = (==1) . length . take 2 in singleton undefined
22:51:01 <dmwit> Axman6: SAVE THE CYCLES
22:51:02 <lambdabot>   * Exception: Prelude.undefined
22:51:07 <dmwit> Axman6: ...collect the whole set
22:51:07 <Axman6> yeah man!
22:51:08 <copumpkin> but is undefined : undefined a singleton?
22:51:16 <dmwit> copumpkin: undefined
22:51:16 <mmorrow> that's cheating
22:51:21 <u_quark> > (\x-> case x of { [_] -> True; _ -> False }) undifined
22:51:23 <lambdabot>   Not in scope: `undifined'
22:51:24 * Axman6 is attempting to, but they're damn hard to find!
22:51:25 <copumpkin> dmwit: yeah, that's what I thought
22:51:28 <u_quark> piffff
22:54:28 <Axman6> @src () Eq
22:54:29 <lambdabot> Source not found. My pet ferret can type better than you!
22:54:31 <Axman6> :(
22:54:43 <mmorrow> (==)?
22:54:51 <mmorrow> @src () (==)
22:54:51 <lambdabot> () == () = True
22:55:28 <mmorrow> _ == _ = True
22:55:58 <dmwit> > undefined == (undefined :: ())
22:56:00 <lambdabot>   * Exception: Prelude.undefined
22:56:02 <copumpkin> mmorrow: different strictness
22:56:04 <dmwit> mmorrow: too lazy
22:56:06 <dmwit> =)
22:56:17 <sshc> > lastButOne xs = fst . foldl (\acc x -> (snd acc, x)) (xs !! 1, xs !! 2)
22:56:19 <lambdabot>   <no location info>: parse error on input `='
22:56:29 * dmwit agrees with mmorrow on what it should be, though
22:56:35 <mmorrow> but which strictness is the right one!!
22:56:44 <dmwit> _ == _ is the one true way
22:56:44 <sshc> > let lastButOne xs = fst . foldl (\acc x -> (snd acc, x)) (xs !! 1, xs !! 2) in lastButOne [1, 2, 3]
22:56:47 <copumpkin> mmorrow: the prelude is never wrong
22:56:47 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> t)
22:56:47 <lambdabot>    arising from a use of...
22:56:47 <mmorrow> heh
22:56:53 <dmwit> sshc: Soooo complicated.
22:57:02 <copumpkin> except when it comes to typeclasses :)
22:57:05 <dmwit> > let lastButOne = (!!1) . reverse in lastButOne [1..5]
22:57:06 <lambdabot>   4
22:57:35 <copumpkin> > let lastButOne = last . init in lastButOn [1..5]
22:57:36 <lambdabot>   Not in scope: `lastButOn'
22:57:37 <sshc> dmwit: my goal is to use fold to find the second to last element in a list
22:57:40 <copumpkin> > let lastButOne = last . init in lastButOne [1..5]
22:57:41 <lambdabot>   4
22:57:58 <dmwit> head . tail . reverse
22:58:17 <dmwit> sshc: Then I challenge you: why aren't you supplying xs to the fold?
22:58:36 <dmwit> sshc: I also challenge you: why 1 and 2 rather than 0 and 1?
22:58:43 <copumpkin> @let times = (foldr (.) id .) . replicate
22:58:45 <sshc> dmwit: oh whoops
22:58:48 <lambdabot>  Defined.
22:58:55 <sshc> dmwit: the former shouldn't make a difference
22:59:03 <dmwit> eh?
22:59:07 <Axman6> > times 100 (^2) 2
22:59:09 <sshc> dmwit: function currying? or whatever that's called
22:59:13 <lambdabot>   mueval-core: Prelude.read: no parse
22:59:13 <lambdabot>  mueval: ExitFailure 1
22:59:16 <sshc> > let lastButOne xs = fst . foldl (\acc x -> (snd acc, x)) (xs !! 0, xs !! 1) in lastButOne [1, 2, 3]
22:59:18 <mmorrow> , let go [a,b] = a; go (x:xs) = go xs; go _ = error "omg omg" in go [1..5]
22:59:18 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> t)
22:59:18 <lambdabot>    arising from a use of...
22:59:19 <lunabot>  4
22:59:21 <Axman6> > times 100 (*2) 2
22:59:23 <lambdabot>   2535301200456458802993406410752
22:59:23 <copumpkin> > let lastBut n = last . (n `times` init) in lastBut 3 [1..5]
22:59:25 <lambdabot>   2
22:59:26 <dmwit> sshc: Check again what you've written.
22:59:33 <sshc> > let lastButOne xs = fst . foldl (\acc x -> (snd acc, x)) (xs !! 0, xs !! 1) xs in lastButOne [1, 2, 3]
22:59:34 <mmorrow> that's like 15 traversals though :P
22:59:35 <lambdabot>   Couldn't match expected type `a -> (a1, b)'
22:59:40 <copumpkin> mmorrow: mine?
22:59:48 <dmwit> sshc: Your lastButOne function already binds its argument, so you can't just claim "eta reduction" or anything like that. =)
23:00:07 <mmorrow> copumpkin: ok two
23:00:09 <mmorrow> :)
23:00:10 <copumpkin> Axman6: I meant it to be used infix
23:00:14 <dmwit> sshc: Getting closer, but needs more ($).
23:00:21 <copumpkin> mmorrow: you positive?
23:00:22 <dmwit> (or more parens)
23:00:30 <mmorrow> what is times?
23:00:37 <copumpkin> mmorrow:  I just @let it above
23:00:39 <sshc> > let simple x = (+3) in x 3
23:00:41 <lambdabot>   Couldn't match expected type `t1 -> t'
23:00:49 <sshc> > let simple x = (+3) x in x 3
23:00:50 <lambdabot>   Couldn't match expected type `t1 -> t'
23:00:52 <copumpkin> mmorrow: @let times = (foldr (.) id .) . replicate
23:00:56 <Axman6> copumpkin: should've made it an infix function  then :P
23:00:58 <sshc> whoops
23:01:00 <mmorrow> ah nice, i like that one
23:01:08 <sshc> > let simple x = (+3) in simple 3
23:01:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:01:10 <lambdabot>    arising from a use of `...
23:01:10 <copumpkin> > 5 `times` (+1) $ 5
23:01:12 <lambdabot>   10
23:01:14 <mmorrow> copumpkin: last + init
23:01:16 <sshc> > let simple x = (+3) x in simple 3
23:01:18 <lambdabot>   6
23:01:19 <copumpkin> I guess :)
23:01:45 <sshc> > let lastButOne xs = fst $ foldl (\acc x -> (snd acc, x)) (xs !! 0, xs !! 1) xs in lastButOne [1, 2, 3]
23:01:46 <lambdabot>   2
23:01:54 <dmwit> Hooray!
23:01:56 <sshc> :)
23:01:59 <dmwit> sshc++
23:02:07 <dmwit> You are now a level 2 Haskell mage.
23:02:07 <mmorrow> , take 1 . reverse $ [1..5]
23:02:08 <lunabot>  [5]
23:02:11 <dmwit> Use your powers wisely...
23:02:15 <mmorrow> is one traversal i guess too
23:02:24 <mmorrow> err
23:02:27 <dmwit> !!1
23:02:31 <mmorrow> , (!!1) . reverse $ [1..5]
23:02:32 <lunabot>  4
23:02:32 <copumpkin> sshc: now write lastBut n
23:02:32 <mmorrow> right
23:03:05 <sshc> copumpkin: does it need to use fold?
23:03:08 <mmorrow> , let lastButN n = (!!n) . reverse in lastBut 1000000000000 [0..4]
23:03:09 <lunabot>  luna: Not in scope: `lastBut'
23:03:09 <copumpkin> sshc: mine did :)
23:03:12 <dmwit> sshc: yes
23:03:14 <mmorrow> , let lastButN n = (!!n) . reverse in lastButN 1000000000000 [0..4]
23:03:16 <lunabot>  luna: Prelude.(!!): negative index
23:03:31 <dmwit> sshc: hint: lists are n-ary tuples, provided all the tuple entries have the same type ;-){
23:03:33 <copumpkin> not sure how robust to odd cases my version was
23:03:37 <mmorrow> oh right, 32bits
23:03:51 <copumpkin> damn them for using signed types
23:04:03 <copumpkin> no negative index errors if they'd just used a damn nonnegative type :P
23:04:07 <dmwit> :t genericIndex
23:04:09 <copumpkin> I guess Word wasn't in h98
23:04:10 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
23:04:14 <mmorrow> , let lastButN n = (!!n) . reverse in lastButN 10000 [0..4]
23:04:15 <lunabot>  luna: Prelude.(!!): index too large
23:04:24 <mmorrow> lose-lose
23:04:41 <copumpkin> > let lastBut n = last . (n `times` init) in lastBut 10 [1..5]
23:04:42 <hackagebot> bytestringparser-temporary 0.3.0 - Combinator parsing with Data.ByteString.Lazy (JasonDusek)
23:04:43 <lambdabot>   * Exception: Prelude.init: empty list
23:04:47 <copumpkin> bah :)
23:04:59 <mmorrow> omg for a split second i thought the hackagebot output was the result
23:05:08 <copumpkin> hah
23:06:38 <copumpkin> bos is git-trolling on twitter :P
23:07:38 <sshc> dmwit: copumpkin: I'll have to do that in the morning ;)
23:07:40 <sshc> g'night
23:07:43 <PetRat> I'm still having trouble finding the function toDescList in Data.Map. I installed the latest version of GHC on Windows (6.10.4). I attempted to remove all references to previous version in environment variables. I checked that the ghc directory has containers-0.2.0.1.
23:07:58 <copumpkin> sshc: g'night :)
23:08:10 <copumpkin> PetRat: I didn't think it had one
23:08:16 <bos> copumpkin: it's an easy target ;-)
23:08:24 <copumpkin> bos: :)
23:09:30 <PetRat> Weird, it was in some docs that I downloaded, but looking at haskell.org I don't see it any more.
23:09:36 <glguy> PetRat: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/src/Data-Map.html
23:09:41 <glguy> that function is commented out
23:10:01 <copumpkin> aw
23:11:49 <glguy> bos: Do you expect ghc-6.10.4 to make it into f11?
23:12:06 <bos> glguy: i've currently no plans to push it there. why?
23:12:20 <ManateeLazyCat> dcoutts: When i use c2hs binding C library, i use below type match pair: glong => CLong, gunit16 => Word16, gunichar => Char, when i use Char match i use "(fromIntegral . ord)" transform in function body. Above transform are complete correct? Thanks!
23:12:31 <PetRat> I found this code in docs I downloaded a couple monts ago: toDescList :: Map k a -> [(k,a)]
23:12:31 <PetRat> toDescList t  = foldlWithKey (\xs k x -> (k,x):xs) [] t
23:12:32 <glguy> Curiousity, mostly. It was described as a bug fix with few changes
23:12:43 <glguy> I have been fortunate enough to not knowingly experience those bugs
23:12:48 <glguy> but I thought I'd ask
23:14:08 <PetRat> Basically I need a way to look at the few highest key/value pairs in a map. I thought I could convert to a descending list, then with the help of laziness, it would only look at the few values I needed.
23:14:38 <copumpkin> is there a Data.Map zipper?
23:15:00 <dmwit> PetRat: Isn't there a maxKeyView?
23:15:28 <copumpkin> @hoogle maxView
23:15:29 <lambdabot> Data.IntSet maxView :: Monad m => IntSet -> m (Int, IntSet)
23:15:29 <lambdabot> Data.Map maxView :: Monad m => Map k a -> m (a, Map k a)
23:15:29 <lambdabot> Data.Set maxView :: Monad m => Set a -> m (a, Set a)
23:15:32 <dmwit> findMax, deleteFindMax seem appropriate
23:15:34 <ManateeLazyCat> Anyone use c2hs ?
23:16:07 <dmwit> :t M.maxViewWithKey
23:16:07 <PetRat> dmwit: Yes!
23:16:08 <lambdabot> forall k a. M.Map k a -> Maybe ((k, a), M.Map k a)
23:16:35 <PetRat> If you want a few values, then a few calls to deleteFindMax would work. A little inefficient perhaps.
23:16:56 <dmwit> Yes, it doesn't seem optimal.
23:19:35 <ChthonLaptop> Query:  Since Haskell does not allow variables to change freely, how would I best keep track of a changing hit point total in a game?
23:20:00 <ManateeLazyCat> ChthonLaptop: IORef.
23:20:01 <dmwit> :t runState
23:20:03 <lambdabot> forall s a. State s a -> s -> (a, s)
23:20:07 <Trinithis> > maybe False (not . null) . zipWithM const [Just True, Nothing] $ [1,2..]
23:20:09 <lambdabot>   False
23:20:14 <ManateeLazyCat> ChthonLaptop: Or State Monad.
23:20:33 <u_quark> some hand made monad for the state of the game
23:21:03 <ChthonLaptop> I thought that Haskell didn't have states.
23:21:07 <Cale> Or by passing the game state explicitly as a parameter to functions that need it.
23:21:23 <Cale> (and pass a different game state along whenever it changes)
23:22:04 <u_quark> haskell doesn't have state but can "emulate" state as Cale says
23:22:08 <Cale> ChthonLaptop: The results of Haskell functions don't rely on any external state.
23:22:32 <copumpkin> Trinithis: :o
23:22:43 <Cale> But the results of IO actions can depend on state.
23:22:51 <dmwit> :t zipWithM
23:22:53 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
23:23:06 <Cale> and there are various other things which you can do to avoid or simulate state
23:23:45 <dmwit> :t \f xs ys -> sequence $ zipWith f xs ys
23:23:46 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
23:24:08 <bos> woo! Boyer-Moore-Horspool string search over Data.Text appears to work!
23:24:16 <copumpkin> bos: ooh
23:24:18 <dmwit> YES!
23:24:21 <ChthonLaptop> That's what I thought.  Because of that I kept hitting a problem with tracking a hp total.  I mean pretty much I was looking at keeping track of all the damage and healing done to a character or monster for the entire duration of the game.  I was looking for a way to get around that.
23:25:00 <dmwit> ChthonLaptop: Using the State monad (or StateT monad transformer) is a pretty standard solution.
23:25:08 <Cale> ChthonLaptop: Basically, you could define a datatype whose values represent the complete state of the game, then define various functions for transforming that.
23:25:25 <u_quark> don't be afraid of monads...
23:25:45 <Cale> I wouldn't immediately reach for a state monad.
23:26:05 <Cale> Of course, you'll end up using the IO monad, but that's to be expected in a game :)
23:26:07 <ChthonLaptop> I've not read that far yet, but I did see that on the agenda already.
23:26:25 <Berengal_> If you're going to do IO at every turn anyway, a State monad is a bit of a waste
23:26:58 <ChthonLaptop> u_quark: I won't touch your monads no matter how little I fear then.
23:27:16 <u_quark> lol
23:28:53 <ChthonLaptop> Right now I'm practicing my knowledge as I learn by building a combat system for the game.  I've just kinda halted at the point of tracking a hp total because I couldn't figure out how to manage it right, however I have attacks and defenses working properly together.
23:29:55 <Axman6> ChthonLaptop: you could always use IORefs or MVars
23:30:08 <ChthonLaptop> In the system a character has a base attack consisting of [(Char,Int)]  and the attack command evaluates it into [Char]
23:30:22 <Berengal_> ChthonLaptop, the standard way is to make a function 'doDamage' that takes as its input a thing and an amount of damage and returns a new thing which is the same as the old thing but with less hp
23:31:16 <ChthonLaptop> My combat system is a little different than the standard system
23:32:09 <Berengal_> The same principle applies
23:32:27 <ChthonLaptop> In my system you can do X damage, with a % chance for each point to get done.  Each point is designated either B S or P, based on the damage type, which changes how it could be defended against, and is calculated individually.
23:33:44 <ChthonLaptop> Well, lets say your attack was successful in causing BBB damage.  Each point can be defended now.  Defense is based on the same principle where you have a chance to use a point of armor (A), a point of parry (P) or a point of block (B) to stop a damage.
23:34:27 <ChthonLaptop> 1 B defense can stop 2 B damage, 2 P defense can stop only 1 B damage, and one A defense stops 1 B damage.
23:35:37 <ChthonLaptop> Likewise P damage is is weak against Parries, and strong against Armor, and S damage is weak against Armor, but strong against Block.
23:36:40 <ChthonLaptop> So Attack returns a string of successful attacks with type, and defense returns a string of successful defenses with type, then a comparason is done to determine if any damage if at all is done.
23:37:36 <Cale> ChthonLaptop: Sounds like that part shouldn't involve any state
23:37:44 <ChthonLaptop> I'm also going to be working in properties into wounds to differentiate normal wounds from heat burns, acid burns, frost bite, etc.
23:38:55 <ChthonLaptop> No, but the hp is going to be set up as [(Boolean, [Char])] so that each point can have an on or off state as well as a wound status.
23:39:42 <ChthonLaptop> If it was damaged because of a burn for example, natural healing takes a long time, and magical healing won't heal it instantly, instead it would apply a regenerating state to it where you get back one burn hp per turn.
23:40:47 <ChthonLaptop> But thanks for pointing me towards monads.  I think I'll look into them as soon as I'm done with what I can for now.
23:41:05 <ChthonLaptop> Honestly I wasn't sure what to expect when I saw that title.  I've never heard of that before.
23:41:37 <path[w]> is there an equivalent of sum for list which works on nonnumeric lists but takes a mapping function for item -> number
23:42:04 <Cale> Probably best to avoid strange monads. Obviously you'll use IO eventually, but you don't really need to know much about monads for that, and you'll only need it for actual interaction with the user. The calculations you're doing are a bunch of pure functions.
23:42:11 <Orclev> lol, I look up and see something about burns and natural verse magical healing and I'm lik WTF?
23:42:25 <blackdog1> funfoo f list = sum . map f list
23:42:28 <Cale> path[w]: sum . map f
23:42:37 <path[w]> ah I should have guessed lol
23:42:37 <Orclev> not exactly the normal fai for #haskell
23:42:39 <blackdog1> or you could make it pointfree, yeah
23:43:00 <Cale> blackdog1: that would have to be sum . map f $ list or sum $ map f list
23:43:23 <blackdog1> ah, you're right
23:43:39 <blackdog1> am trying to get in the habit of using . more, but i'm still thinking in terms of $
23:43:44 <ChthonLaptop> Wow, I must have had everyone's attention for a bit LOL  All of a sudden everyone's chatting again :)
23:44:12 <Orclev> I need to go back and ready everything you said, I missed a lot of it
23:44:22 <Orclev> but you know, I'm a sucker for videogames :P
23:45:02 <fffej> If I have a function of three argument, I know I can pass just one and the first argument is bound and I now have a function of 2 arguments.  Is there a short hand syntax where I can bind the last argument and get a function of 2 arguments?
23:45:27 <Cale> fffej: (\x y -> f x y 0)
23:45:27 <ChthonLaptop> Last night when I started actually playing with things to start my program I remember spending 3 hours wishing we didn't have a  communications blackout so that someone could tell me what I was doing wrong.  Turns out that I forgot that you have to put () around a function that takes parameters if you use it as a parameter for another function.
23:45:40 <Cale> er
23:45:51 <fffej> cale: thanks - so there's no short hand with something like f _ x y or some such?
23:46:00 <Berengal_> \z x y -> f x y z
23:46:06 <Cale> fffej: Yeah, just use lambda, that's what it's for :)
23:46:19 <dmwit> fffej: correct
23:46:24 <fffej> thanks all
23:46:31 <dmwit> fffej: There's a shorthand for two arguments (flip), but that's all.
23:46:37 <Cale> ChthonLaptop: right. Function application is left associative, so f x y z always means ((f x) y) z
23:46:39 <dmwit> :t flip . flip
23:46:41 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
23:46:44 <sjanssen> @pl \z x y -> f x y z
23:46:44 <lambdabot> flip (flip . f)
23:47:26 <dmwit> ?pl \f z x y -> f x y z
23:47:26 <lambdabot> flip . (flip .)
23:47:44 <dmwit> :t flip . (flip . (flip .))
23:47:44 <ChthonLaptop> So, Orclev, what do you think of my system from what you've heard?  I don't plan on having characters or monsters with hundreds of hp.  I feel that maybe the most powerful thing you might find may have 50 hp (kinda a tough fight)
23:47:45 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> a -> b -> a1 -> c
23:47:45 <path[w]> so far to add the odd elements of a list I have sum.map snd $ filter fst $ zip (cycle [True, False])
23:47:53 <path[w]> is there any nicer I can make it?
23:48:22 <dmwit> path[w]: looks good to me
23:48:39 <Cale> path[w]: you can change the first $ there to . as well
23:48:40 <Orclev> give me a second to look it over, I've been hoping through 3 different channels with running conversations
23:48:42 <dmwit> path[w]: Though if it's stand-alone like that, those ($) need to be (.)
23:48:51 <Trinithis> > sum . filter odd $ [1,2,3,4,5]
23:48:54 <lambdabot>   9
23:49:04 <ChthonLaptop> Cale:  I had a parameter getInverse a and another makePercent a.  I tried getInverse makePercent (insert values here) and it failed.
23:49:06 <dmwit> Trinithis: ...no, the elements with odd *index*, not odd value.
23:49:38 <Cale> sum [x | (k,x) <- zip [0..] xs, even k]
23:49:41 <ChthonLaptop> However when I finally after several hours of aggrivation later tried getInverse (makePercent (same values again)) it worked
23:50:06 <copumpkin> the ghci debugger is neat
23:50:14 <copumpkin> takes some getting used to though
23:50:33 <Cale> ChthonLaptop: right, because  getInverse makePercent 5  means you're passing makePercent and 5 as parameters to getInverse
23:50:58 * dmwit chuckles at the ]}]})}] at the end of his "show"
23:50:59 <ChthonLaptop> This was after I sat down and verified that every argument that I thought I passed to each function should have worked as I did it step by step myself (something I coldn't do in C or Java and I like a lot)
23:51:48 <ChthonLaptop> Cale:  Yeah, I figured that out eventually.  Like I said I had a communications blackout on the base I was on so I couldn't even look at any of the guides you guys had shown me.
23:52:09 <copumpkin> dmwit: wow
23:52:36 <sjanssen> sum [x | (x, True) <- zip xs (cycle [True, False])]
23:53:13 <Trinithis> instance show Dmwit where show Dmwit = "]}]})}]"
23:53:22 <dmwit> copumpkin: easily achieved at the end of a long Tree
23:53:28 <path[w]> oh the first $ can be a .?
23:53:28 <copumpkin> :)
23:53:38 <path[w]> cause its snd of filter?
23:53:52 <path[w]> ah
23:53:53 <path[w]> yeah
23:54:22 <Cale> path[w]: In general, if you have f $ g $ h $ x, it can become f . g . h $ x
23:54:25 <ChthonLaptop> Oh yeah, I also like the guards in this language.  Much easier than an if/else tree, and very much like a case statement.
23:54:57 <Orclev> ChthonLaptop: looks interesting although I think I'd have to see it in action... if I understand the intention correctly you've done to physical attacks what a lot of systems do to magical attacks, in that one kind is deliberately strong and weak against another (E.G. in a "normal" system fire damage might be strong against water type creatures)
23:56:15 <ChthonLaptop> Orclev:  Yes, and I will be adding properties to attacks, much like a burning weapon enchantment would make up to X points of damage cause a burn in addition to adding X fire damage.
23:56:17 <path[w]> ah
23:57:05 <path[w]> hmm but Im facing something wierd. I can do sum.map snd.filter fst $ zip (cycle [True, False]) xs and get the answer. But I cant do let f = sum.map snd $ filter fst $ zip (cycle [True, False])
23:57:31 <Cale> path[w]: you're missing the xs in the second one
23:57:42 <Trinithis> > sum . last . iterate (drop 2 >>= (:) . take 1) . (undefined :) $ [1,2,3,4]
23:57:43 <ChthonLaptop> Damage in combat will be less based off of what weapon you use, more off your stats.  Certain really good weapons might add a bonus damage here and there, but mostly it just determines what damage types you deal and what weapon skill you use.
23:57:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:58:10 <path[w]> but isnt that correct as a pointsfree solution?
23:58:21 <path[w]> it doesnt have xs on the left either
23:58:31 <Cale> path[w]: well, you could change all the $'s to .'s
23:58:32 <dmwit> path[w]: No, the ($) need to be (.) instead.
23:58:36 <path[w]> ah
23:58:39 <ChthonLaptop> I had that problem last ngiht too.  You're calling a recursive function in a list
23:59:15 <dmwit> Trinithis: last . iterate f === undefined
23:59:26 <Trinithis> yeah... shouldhave done a fold
23:59:29 <ChthonLaptop> Or after looking at it, I'm not sure why you're getting the same error I did...
23:59:36 <Trinithis> @pl \sum -> [x | (x, True) <- zip xs (cycle [True, False])]
23:59:37 <lambdabot> const [x | (x, True) <- zip xs (cycle [True, False])]
23:59:47 <Trinithis> lol
23:59:58 <Trinithis> o
