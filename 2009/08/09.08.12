00:00:28 <eflister> i have some functions of heterogeneous types.  there is a function i can compose with each of them that will homogenize their types so i can put them in a list.  i'd like to do the composition with map, but or course can't get the heterogeneous functions into a list.  is there a nice way to do this?
00:01:37 <c_wraith> this sounds like the sort of thing existential quantifiers are made for.
00:01:46 <c_wraith> But I don't really understand how to use them properly
00:02:25 <Deewiant> eflister: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
00:02:29 <c_wraith> I think you need a typeclass
00:03:14 <eflister> gracias
00:05:09 <soupdragon> eflister: you have like,  f :: a -> b, g :: b -> c, h :: c -> d and you want to make a 'list' of [f,g,h]?
00:07:23 <eflister> right -- the typeclass/existentials will fix it.  in your example, b, c, and d all instance a class, and a, b, and c instance another class.
00:07:49 <soupdragon> I don't know what you mean about classes
00:08:12 <Axman6> urgh, this databases course is so tedius -_-
00:08:47 <eflister> those types are in classes, those classes have methods (and applying the methods will eliminate the differences in the signatures)
00:09:20 <soupdragon> still don't understand
00:09:35 <sm> anyone using io-storage ? I do putValue "db" "key" a, then getValue "db" "key", but get Nothing
00:09:49 <eflister> let's simplify the example -- f :: a -> b, g :: a -> c
00:10:49 <eflister> where b and c have instance declarations for "dable", which has a method dize :: (dable r) => r -> d
00:11:30 <eflister> so this list is homogenously typed: [dize . f, dize . g]
00:12:02 <soupdragon> it's not just [a -> d]?
00:12:27 <int-e> sm: try giving the getValue a type signature (:: IO <type of a>)
00:12:29 <eflister> and i want to do something like  map (dize .) [f,g]
00:12:41 <soupdragon> oh right
00:13:15 <int-e> mmm
00:13:58 <soupdragon> I'd let x & ys = dize . x : ys
00:14:14 <soupdragon> then write  f & g & []  instead of  f : g : []
00:14:36 <sm> int-e: thanks, that didn't help
00:15:16 <eflister> soupdragon: that looks like it would work too
00:16:03 <eflister> but my rule is that i have to try to learn a language feature/extension when it comes up as applicable in my project.  :)
00:16:41 <eflister> tonight is transformer night (ugh)
00:16:45 <soupdragon> I think that the existential stuff is hideous and completely inapproprite but that's just me
00:17:16 <eflister> really?  it looks appealing to me cuz i believe in (java-like) interfaces.
00:17:30 <Deewiant> LHC has the nicer "exists a." syntax which means you don't have to define the intermediate data type
00:17:47 <eflister> in my case it already exists :)
00:17:52 <Deewiant> Or was it UHC
00:18:00 <Deewiant> Anyway, one of the non-GHC compilers :-P
00:18:21 <soupdragon> there's a good doc on transformers www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
00:18:26 <int-e> sm: oh, apparently you have to create a store ("db" in your case) before you can store any values. withStore "db" ( putValue "db" "key" True >> getValue "db" "key" :: IO (Maybe Bool))
00:19:10 <eflister> soupdragon: thanks :)  i am also using RWH ch 18 and cale's wiki page
00:19:33 <int-e> sm: which is probably fine for "real" programs (wrap main in a withStore "globalStore") but pretty useless for testing in ghci.
00:20:28 <mmorrow> eflister: one thing to keep in mind when comparing that to java though is that java has to do runtime checks in the cases where it can't statically determine that a downcast is valid, but since ghc erases types and goes to machcode you'd need to manually implem this with explicitly stored type info and unsafeCoerce
00:21:14 <sm> int-e: I don't get it. The store is created on first putValue, is that right ? I do that as first step
00:21:37 <sm> your example works for me but not if I change the value to an Int or my own data type
00:21:38 <int-e> sm: no. putValue doesn't create any stores. That's the point I was trying to make.
00:22:30 <Gwern-away> YOW! I feel like being garbage-collected!
00:22:35 <sm> I don't know how you make a store then
00:22:41 <sm> withStore "db" ( putValue "db1" "key" 1 >> getValue "db" "key" :: IO (Maybe Int)) gives Nothing
00:23:26 <Gwern-away> putValue db1, getValue db?
00:23:29 <int-e> sm: withStore is the only way. and withStore deletes the store when it's done.
00:23:29 <sm> withStore "db" ( putValue "db" "key" 1 >> getValue "db" "key" :: IO (Maybe Int))  , I mean
00:23:42 <int-e> sm: 1 defaults to Integer
00:23:45 <eflister> mmorrow: hm, sounds like what you're describing is hidden from the programmer tho, right?  (in both cases) -- so existential types incur a performance hit analogous to the RTTI always following you around in java?
00:23:49 <sm> wow
00:24:59 <sm> ok.. thanks for all the help. So always be inside withStore, and query for exactly the right type
00:25:04 <int-e> sm: (the library should come with a makeGlobalStore (it would be easy to add) and a slightly more friendly behaviour for withStore "foo" (... withStore "foo" (...) {- oops, the "foo" store is gone here -}).
00:25:21 <mmorrow> eflister: yeah, i meant that while you can do the same stuff in haskell, it won't be transparent to you/the programmer since the runtime/compiler isn't doing the behind-the-scenes work for you
00:25:33 <Axman6> @hoogle Mu
00:25:33 <lambdabot> package mueval
00:25:33 <lambdabot> Distribution.Simple.Command multiOption :: Name -> get -> set -> [get -> set -> OptDescr a] -> OptionField a
00:25:33 <lambdabot> Distribution.Extension MultiParamTypeClasses :: Extension
00:25:38 <Axman6> @more
00:25:43 <Axman6> @hoohle+
00:25:43 <lambdabot> Language.Haskell.Extension MultiParamTypeClasses :: Extension
00:25:43 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
00:25:43 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
00:25:47 <Axman6> @hoogle+
00:25:47 <lambdabot> Text.XHtml.Transitional multiple :: HtmlAttr
00:25:47 <lambdabot> package multiset
00:25:47 <lambdabot> Text.ParserCombinators.ReadP munch :: (Char -> Bool) -> ReadP String
00:25:53 <Axman6> fine then
00:26:16 <soupdragon> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
00:26:21 <mmorrow> eflister: and i guess maybe there'd be a performance hit, but that'd depend on how you implemented a particular whatever
00:26:24 <soupdragon> why is this called heterogeneous lists?
00:26:27 <soupdragon> it's not heterogeneous  ....
00:26:44 <eflister> mmorrow: oh, ok, thx for the heads up.  i'll have to give it a whirl, at first it looked like it would just do it.  is this "statically undeterminable downcast" what always starts the "OOP is a hack that doesn't do anything" flame war?  :)
00:26:59 <shachaf> soupdragon: Sure it is.
00:27:27 <mmorrow> eflister: heh, i'm not sure. i just mentioned that since i read it in the java spec the other day while browsing through it.
00:28:06 <mmorrow> the spec explicitly details the algorithm for downcasting
00:28:18 <soupdragon> [forall a. a] is hetrogenous?
00:28:45 <eflister> rocks and pigeons both has a flavor
00:28:50 <Axman6> [SB (), SB 5, SB True] is obviously hetrogeneous
00:28:59 <soupdragon> Axman6 not obvious to me
00:29:14 <Axman6> well they all have to be of different types no?
00:29:15 <c_wraith> :t ()
00:29:16 <lambdabot> ()
00:29:22 <Axman6> :t True
00:29:24 <lambdabot> Bool
00:29:28 <shachaf> soupdragon: It's an implementation of heterogeneity. It has elements of different types.
00:29:45 <shachaf> All you know about the elements is that they can be Shown.
00:29:47 <soupdragon> that's not [(), 5, True]
00:30:11 <shachaf> As I said, it's an implementation.
00:30:14 <c_wraith> But it's the same data constructor
00:30:21 <c_wraith> Which means it's not algebraic datatypes
00:30:37 <shachaf> [exists a. Show a => a] would be what you want.
00:30:45 <soupdragon> when I do a hetrogeneous list it's like this:
00:30:56 <soupdragon> ((), (5, (True, ())))
00:31:01 <Axman6> ew
00:31:12 <soupdragon> the type is ((), (Integer, (Bool, ())))
00:31:16 <Axman6> that's not a list for one >_>
00:31:17 <Gwern-away> soupdragon: that's not a very flexible list
00:31:17 <shachaf> That's not a list.
00:31:23 <soupdragon> yeah it is
00:31:28 <Axman6> that's a fixed type
00:31:30 <soupdragon> it's a 3 element list
00:31:41 <Axman6> you can't add anything to that list and still have it be of the same type
00:31:42 <shachaf> No, it's fixed-length. It's just a tuple.
00:31:50 <soupdragon> you can append it to another list etc etx
00:32:02 <shachaf> soupdragon: As I said, [exists a. Show a => a] is the "true" heterogenous list you want.
00:32:11 <shachaf> But unfortunately GHC doesn't support that.
00:32:16 <soupdragon> It's a list because I treat it that way, data is what data does
00:32:28 <shachaf> soupdragon: You have to know the length in advance.
00:33:04 <Axman6> :t ((), (Integer, (Bool, ())))
00:33:05 <lambdabot> Not in scope: data constructor `Integer'
00:33:05 <lambdabot> Not in scope: data constructor `Bool'
00:33:16 <Axman6> :t ((), (7, (True, ()))))
00:33:17 <lambdabot> parse error on input `)'
00:33:20 <Axman6> :t ((), (7, (True, ())))
00:33:21 <Gwern-away> ghc doesn't support that? lies! ghc has extensions for everything
00:33:21 <lambdabot> forall t. (Num t) => ((), (t, (Bool, ())))
00:33:31 <Axman6> :t (Nothing, ((), (7, (True, ()))))
00:33:32 <lambdabot> forall a t. (Num t) => (Maybe a, ((), (t, (Bool, ()))))
00:33:33 <shachaf> Gwern-away: Really? It has exists. ?
00:33:40 <Gwern-away> EVERYTHING
00:34:09 <soupdragon> UHC has exists
00:34:10 <Axman6> asm inside a pure function? sure, ghc has it!
00:34:42 <soupdragon> I just don't agree with the article but I am clearly the only one
00:34:54 <Gwern-away> ghc is the perfect compiler; it is more perfect for ghc to have an extension than to not have it; qed, ghc has it
00:35:26 <Axman6> > iterate (\x -> (1,x)) True
00:35:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = (t, a)
00:35:33 <Axman6> see, not a list
00:35:59 <shachaf> soupdragon: [ShowBox] is an implementation of [exists a. Show a => a].
00:36:16 <shachaf> It is isomorphic (am I allowed to use that word?).
00:36:27 <Axman6> no!
00:36:36 <Axman6> no maths in here!
00:36:52 <shachaf> I mean, am I horribly misusing it? :-)
00:37:05 <Axman6> possibly!
00:37:06 <Axman6> >_>
00:37:08 <Gwern-away> what is ShowBox?
00:37:16 <soupdragon> Axman, that is nothing to do with being a list or not
00:37:20 <shachaf> soupdragon: So although of course all the elements are of the same type (ShowBox), we say that it's like the "real" heterogenous list.
00:37:30 <shachaf> Gwern-away: What soupdragon linked to: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
00:38:20 <Axman6> soupdragon: you can't append to it and stiff have the same type, so i would not count it as a list
00:38:33 <soupdragon> thats wrong
00:38:35 <Axman6> lists can hold arbitrary numbers of things
00:38:38 <soupdragon> thats wrong
00:38:38 <int-e> shachaf: "isomorphic" was fine.
00:38:42 <mmorrow> [exists a. Show a => a] would just get compiled to [exists a. (a -> String, a)]
00:38:46 <Axman6> no, it's not wrong, i just showed you
00:38:53 <soupdragon> you showed nothing
00:39:16 <Gwern-away> hm. I'm a little surprised that article doesn't show a method using ADTs and then show the full existential type
00:39:22 <Gwern-away> *type solution
00:39:29 <int-e> mmorrow: same for the ShowBox thingy.
00:39:33 <Axman6> the types of (1,(2,())) and (1,(2,(3,()))) don't match
00:39:41 <mmorrow> int-e: right
00:39:42 <soupdragon> Axman6 everyone knows that
00:39:50 <int-e> mmorrow: where a -> String is a simplification of the Show dictionary.
00:39:52 <soupdragon> that's nothing to do with what a list is
00:39:54 <Axman6> so.. what's your point then?
00:40:07 <mmorrow> int-e: exactly
00:41:08 <Gwern-away> ooh, john just pushed rss support for gitit
00:41:12 <Gwern-away> wonder how well it works
00:41:43 <Axman6> bleh, structural deduction is annoying, i need more practice -_-
00:43:03 <mmorrow> int-e: (i've been using the ghc-api recently to get external-core from ghc to then compile with this interpreter that i'm working on, and it's been interesting to see how exactly ghc inserts/passes/etc dictionaries around, since they're explicit in the external-core)
00:43:46 <mmorrow> heh, also it's made me even more horrified at the though of compiling without at least -O
00:43:51 <mmorrow> *thought
00:43:55 <Gwern-away> bah, how does git have so many dependencies
00:45:09 <mmorrow> (\x -> (1::Int) + x) gets literall compile to (without at least -O) (\numDictInt x -> (+) numDictInt 1 x) e.g.
00:45:14 <mmorrow> *literally
00:46:34 <int-e> mmorrow: I've given it some thought when I used unsafeCoerce# to construct dictionaries at runtime. (basic idea: If you have a type class Foo a with a single method of type X a, then  Foo a => b is isomorphic to X a -> b. And you can indeed unsafeCoerce# betwen the two.)
00:46:46 <solrize> bah, i'm trying to cabal install encoding and ghc is looping.  anyone seen that before?
00:47:02 <mmorrow> int-e: hmm, interesting
00:58:45 <eflister> hmm, having some trouble with mapping a function over the heterogeneous list of functions.  the data constructor for the existential gets in the way.
00:58:59 <soupdragon> :/
00:59:51 <soupdragon>  data ShowBox = forall s. Show s => SB s
00:59:55 <soupdragon> why not newtype?
01:00:02 <soupdragon> newtype can't have the forall?
01:01:28 <pozic> What is f in : text "hi\nthere" `f` text "Oh,\n reallly?" => hi       Oh\nthere     really"? I didn't count the exact number of spaces required, but I just want to have one piece of text and put another piece of text besides it in an aligned way.
01:01:57 <pozic> The text function comes from Text.PrettyPrint.ANSI.Leijen
01:02:45 <mmorrow> soupdragon: not in ghc, since ghc needs to add an extra field to `SB' in "data Show Box = ..." to put the dictionary in
01:03:07 <mmorrow> soupdragon: so in the case of a newtype it'd have nowhere to stick the dict
01:03:38 <soupdragon> I see
01:03:46 <mmorrow> (without creating a new datatype that's essentially equivalent to "data ShowBox = SB (ShowDict a) a" i guess)
01:03:54 <soupdragon> soemthing like  data ShowBox = forall s. SB {Show s} s  would make more sense
01:04:02 <mmorrow> right
01:04:36 <mmorrow> hmm, i wonder if this is what ehc does (implicit creation of new datatypes to hold the dict)
01:05:11 <mmorrow> (that is if ehc uses the "dictionary passing implem" of typeclasses)
01:05:30 <mmorrow> i know jhc does something else, but i don't recall the details
01:05:45 <soupdragon> oh cool I didn't know other ways were possible
01:06:08 <mmorrow> soupdragon: iirc jhc's way is only possible with whole-program optim i think
01:06:28 <mmorrow> but i may be completely wrong
01:06:58 <dolio> jhc sort of has an open gadt that gets new constructors whenever you define a new type.
01:07:30 <dolio> And then type class constraints become arguments of that gadt, and you do case analysis.
01:07:53 <dolio> Or something along those lines.
01:08:31 <mmorrow> hmm, interesting
01:09:21 <dolio> Which you could use to implement Dynamic without unsafeCoerce.
01:10:19 <dolio> Well, provided one or two other functions, perhaps.
01:10:19 <mmorrow> of course though, that hinges on being able to determine all possible types that could flow to that program point
01:10:28 <mmorrow> (right?)
01:10:33 <dolio> You'd need a typeOf as well, for instance.
01:10:49 <soupdragon> quote ?
01:11:07 <dolio> @src cast
01:11:07 <lambdabot> Source not found. Sorry.
01:11:24 <mmorrow> istr seeing a "switch" on the type of closure in some jhc .c output actually now that i think about it
01:11:53 <pozic> Is there no way to align column with any pretty printing library?
01:12:13 <dolio> I don't think you necessarily need to do whole-program analysis to use that implementation.
01:12:19 <mmorrow> _kjwkjSDjskdnk(Whatever *closure){switch(TYPEOF(closure){case ASDF: ...; case BOOL: ...; ...}
01:12:23 <mmorrow> or some such
01:12:24 <pozic> columns*
01:12:39 <dolio> But the open GADT is unlike anything in GHC, of course.
01:13:38 <dolio> And, of course, type class instances become in some way open functions.
01:14:02 <dolio> And that probably all gets pretty weird to think about if you have separate compilation.
01:14:06 <mmorrow> hmm, you'd at least need to know all the types for which there's an instance for the particular class in question maybe?
01:14:22 <mmorrow> in order to know the types to "switch" on (?)
01:14:27 <dolio> It's kind of weird even if you think about instances only being visible in some modules and not others.
01:14:31 <mmorrow> yeah
01:15:27 <eflister> here's my existential problem (heh):  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8128
01:15:35 <dolio> Since you can have two instances for the same type, as long as they're in separate modules the 'same' open function can be different depending on what modules are in scope.
01:16:15 <soupdragon> eflister, why is it okay to write RB a few times but not toRational . ?
01:16:37 <eflister> soupdragon: yeah.  i think that's the problem mmorrow was alerting me to.
01:16:45 <eflister> is there any way to get rid of that?  :(
01:16:49 <soupdragon> huh no I was just asking
01:17:03 <soupdragon> I don't understand why you might prefer the second line
01:18:00 <eflister> well it is fewer keystrokes.  :)  and in principle it captures the abstraction, if not in practice.
01:18:05 <int-e> mmorrow: http://int-e.home.tlink.de/haskell/Configuration.hs ... if you're interested in that use of unsafeCoerce.
01:18:35 <mmorrow> int-e: ooh, cool
01:18:41 <soupdragon> eflister.just let rb x = toRational . x then, and use  rb  instead of  RB
01:19:59 * soupdragon maybe it's got to be  rb x y = toRational (x y)
01:20:28 <soupdragon> eflister, btw shouldn't you have an  unRB function??
01:22:21 <eflister> soupdragon: hm, yeah, that seems like it would fix my 'data constructor getting in the way' problem.
01:22:49 <doserj> it won't type-check, though
01:23:01 <soupdragon> what wont typecheck?
01:23:17 <doserj> unRB
01:23:34 <soupdragon> hm I think it will
01:23:51 <soupdragon> but you are making me unsure
01:27:32 <eflister> hmm if i did it right it didn't work -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8128#a8129
01:27:54 <doserj> unRB would have the type exists r . RealBox -> r, I think, which is not possible in Haskell.
01:28:07 <eflister> same error.  also can't get the 'let rb x = toRational' thing working
01:28:40 <eflister> maybe Deewiant or mmorow can take a look?  (can't remember, was it Deewiant that originally suggested existentials?)
01:29:15 <eflister> mmorrow: was having to repeat the existential constructor the thing you were warning me about ('having to do it by hand')?
01:29:17 <quicksilver> doserj is right, unRB can't be typed.
01:29:25 <soupdragon> try let rb x = toRational . x or rb x y = toRational (x y)
01:29:43 <quicksilver> existentials do suffer slightly from abstract problems.
01:29:52 <doserj> let rb x = toRational . x in  print $ zipWith ($) [rb thing1,rb thing2] $ ... should work
01:30:01 <quicksilver> for a simple example, you can't do (map RB [thing1,thing2])
01:30:12 <quicksilver> you're force to do [RB thing1,RB thing2]
01:30:24 <eflister> quicksilver: hm, does that mean one cannot use existentials to make lists of heterogeneous functions?  is there any other way?
01:30:39 <dolio> Well if you could do "map RB [thing1, thing2]" you wouldn't need RB in the first place. :)
01:31:26 <int-e> eflister: unRB can't work
01:31:38 <eflister> established.  :)
01:32:03 <soupdragon> I don't understand why you can't have unRB but you can still use RB objects
01:32:22 <soupdragon> it's simply because exists doesn't exist?
01:32:49 <quicksilver> eflister: no it means precisely the opposite
01:33:02 <mmorrow> eflister: i guess that's one way to say it, although i didn't really have any one particular thing in mind (you mentioning java in that context just made me remember that blurb in the java spec)
01:33:02 <quicksilver> eflister: you absolutely *can* use exisentialys to make lists of heterogenous functions.
01:33:14 <quicksilver> eflister: but you will always need to repeat the constructor.
01:33:28 <quicksilver> your list will always look like [X a,X b,X c,X d,...]
01:34:01 <doserj> soupdragon: RB effectively throws type-information (for r) away. unRB would have to recreate it.
01:34:21 <eflister> quicksilver: ok yeah, i forgot i'm able to make my list, it's just that RB is getting in my way of then applying those functions.
01:34:23 <mmorrow> eflister: (".. one way to say it..." @'having to do it by hand')
01:34:24 <int-e> eflister: defining   tRB (RB f) x = toRational (f x)  and using that inside that 'map' works.
01:34:55 <quicksilver> eflister: not really, no, you're just doing it wrong :P
01:35:15 <eflister> quicksilver: ok :)  which part?
01:35:44 <quicksilver> well, trying what int-e said.
01:35:51 <quicksilver> Personally I don't yet quite understand what oyu want.
01:36:14 <eflister> doing so now.  well, it turned into an exercise of seeing if i could use existential types.
01:36:19 <int-e> soupdragon: yes, that's the reason basically. you can use the runST trick to define  unRB :: RB -> (forall a . Real a => (Thing -> a) -> b) -> b
01:36:46 <soupdragon> ah I see
01:36:48 <dolio> As a side note, the type of unRB would be "RealBox -> (exists r. r)" (modulo constriants on r), which isn't quite the same thing as "exists r. RealBox -> r".
01:39:59 <eflister> ah ok, works.  i had initially read int-e's solution as not using existentials, ala soupdragon's suggestion.
01:40:16 <eflister> don't need an unRB if you can pattern match it away...
01:40:58 <soupdragon> not using existentials is a great idea
01:41:10 <eflister> what's the runST trick?  :)  is this what's discussed at the bottom of that wikibook page?
01:41:37 <eflister> yeah i'm gonna try the non-existential now.  just wanted to get an example with them working, if it was possible.
01:42:25 <soupdragon> eflister, If I were to do this with existentials I have two different ways that haven't been mentioned in that page
01:42:47 <eflister> listening...
01:49:27 <eflister> rb f = toRational . f works.  but i cannot pointfree f...
01:50:06 <Ferdirand> rb = (toRational .) --?
01:50:53 <eflister> it fights with the different function type signatures it finds in the list
01:51:37 <eflister> ah, but supplying the type fixes it.  rb :: (Real r) => (Thing -> r) -> (Thing -> Rational)
01:51:45 <quicksilver> that's just the monomorphism restriction, eflister
01:51:52 <quicksilver> widely regarded as a misfeature :)
01:52:20 <eflister> yeah usually the compiler specifically mentions that, and it didn't in this case
01:58:42 <soupdragon> eflister, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8131#a8131
02:05:16 <soupdragon> eflister and http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8131#a8132
02:05:21 <eflister> soupdragon: i like it :)  i haven't tackled GADTs yet, but they don't look too bad.  tho i don't see any reason to prefer existentials vs. gadt's in this case, do you?  (for now i'm going with your suggestion of neither :)
02:05:30 <soupdragon> that IS existentials
02:06:56 <eflister> you mean as opposed to backwards universals?  :)
02:06:59 <soupdragon> eflister, for comparison http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8131#a8133
02:07:13 <soupdragon> to me it seems clear which is best :P
02:07:40 <soupdragon> eflister, I just mean - instead of coding existentials using backwards universals I am doing it via GADTs
02:07:57 <eflister> yeah that's what i meant by 'your suggestion of neither' :)
02:08:12 <eflister> right, got it
02:08:33 <soupdragon> eflister, (A) and (B) are rather silly but (A) has adapted something important
02:08:52 <soupdragon> eflister, ExSimilarity is a bit like   data Ex f where Witness :: f a -> Ex f
02:08:55 <quicksilver> soupdragon: there is no different between GADTs and backwards universals
02:08:59 <quicksilver> soupdragon: it's just syntax.
02:09:18 <soupdragon> (just that I hard coded 'f' rather than using a function at type level)
02:27:24 <harlekin> @hoogle Integer -> Int
02:27:25 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
02:27:25 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
02:27:25 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
02:29:14 <quicksilver> harlekin: fromIntegral
02:29:25 <quicksilver> harlekin: fromIntegral is the only integral conversion you will need, it works both ways.
02:31:35 <harlekin> quicksilver, I apply (ceiling . uncurry (/) . (fromIntegral *** fromIntegral)) to (a,a) :: (MPD.Second, MPD.Seconds) which should be a type sysnonym for Integer. But ghc complains about expecting `Int' but `Integer' being inferred.
02:31:50 <harlekin> Do you have an idea why this is happening?
02:32:09 <harlekin> > 1 :: MPD.Seconds
02:32:10 <lambdabot>   Not in scope: type constructor or class `MPD.Seconds'
02:32:31 <quicksilver> :t ceiling . uncurry (/) . (fromIntegral *** fromIntegral)
02:32:33 <lambdabot> forall b b1 b'. (Integral b, Integral b1, Integral b') => (b1, b') -> b
02:32:46 <quicksilver> That looks fine.
02:32:54 <quicksilver> it should work for any integral type
02:33:03 <quicksilver> if you're right and MPD.Seconds is integral, that's fine
02:33:09 <quicksilver> maybe there is something you're not telling me :)
02:33:20 <harlekin> Seconds is type Seconds = Integer. Does this mean it isn't integral?
02:33:27 <harlekin> I thought type sysnonyms wouldn't affect this.
02:34:44 <doserj> @type (/)
02:34:45 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:35:06 <harlekin> Ah, I have made the synonym fi for fromIntegral without giving it a type signature. Now with a type signature the error is gone.
02:35:25 <harlekin> Thanks for your confirmation, quicksilver. I was looking in the wrong direction.
02:37:38 <quicksilver> harlekin: damn that monomorphism restriction.
02:46:01 <DrSyzygy> Hmmmmmm. I'm probably being stupid. And I'm trying to make laziness do things I can't seem to make it do.
02:46:10 <DrSyzygy> I have a function that computes one step in a GrÃ¶bner basis process.
02:46:27 <DrSyzygy> It takes the old GrÃ¶bner basis candidate, and the latest output of itself, and generates a new set of new additions.
02:47:10 <DrSyzygy> So I have my step function. I originally call it like > step [] generators < and then feed the output to the right argument, and the concatenation of the arguments to the left argument.
02:47:24 <DrSyzygy> I want to keep doing this until the function returns the empty list, and then I want to return everything to the user.
02:47:28 <DrSyzygy> caller.
02:47:48 <DrSyzygy> Only, these computations can become ginormous. So I want to be able to lazily consume whatever has already been computed along the way.
02:48:20 <DrSyzygy> I've currently written with an accumulator function, so:
02:49:33 <DrSyzygy> stepAcc gb [] = gb; stepAcc old new = { let gbold = old ++ new; gbnew = step old new; in stepAcc gbold gbnew }
02:50:17 <pozic> Is there a library which already contains a function which strips/trims the start and end spaces from a string?
02:50:49 <DrSyzygy> Now, if I do > take 5 $ step [] gb < I get a result within seconds. If I do > take 5 $ stepAcc [] gb < it hangs, obviously waiting for the entire computation to finish.
02:50:49 <harlekin> > "â™¬â™ª"
02:50:51 <lambdabot>   "\9836\9834"
02:51:09 <DrSyzygy> How do I make it do what I want, and still run through the iterations of step I need?
02:51:18 <pozic> A search engine for functions would be nice: search <in data structure> <out data structure> => There functions have the desired output <some output list>
02:51:31 <DrSyzygy> pozic: Try @hoogle
02:51:36 <DrSyzygy> @hoogle String -> [String]
02:51:37 <lambdabot> Prelude lines :: String -> [String]
02:51:37 <lambdabot> Prelude words :: String -> [String]
02:51:37 <lambdabot> Data.List lines :: String -> [String]
02:51:48 <pozic> DrSyzygy: that's just types. I am talking about values.
02:52:09 <DrSyzygy> pozic: How do you even imagine such a search engine working?
02:52:14 <Beelsebob> @hoogle lines
02:52:14 <lambdabot> Prelude lines :: String -> [String]
02:52:14 <lambdabot> Data.List lines :: String -> [String]
02:52:14 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
02:52:26 <pozic> DrSyzygy: apt-get install squeak and learn.
02:52:29 <Beelsebob> oh, I see what you want
02:52:35 <Beelsebob> but yeh, ... that's nuts
02:54:11 <pozic> If there are 100,000 functions in the system and you have 4 cores, then you only need to run 25000 functions concurrently on every core. Since it is a small input this will usually finish in a few seconds.
02:54:30 <quicksilver> but there are an infinite number of functions.
02:54:59 <quicksilver> for example, your suggesting space trim might, if it existed, be called (trim ' ')
02:55:14 <quicksilver> but how would the search program know which arguments to give trim?
02:55:20 <pozic> quicksilver: yes, but I am excluding that case.
02:55:21 <hkBst> DrSyzygy: I think you're trying to make it do what it already does... and breaking it in the process.
02:55:31 <quicksilver> even worse, suppose the way to call it was (trim (==' '))
02:55:39 <quicksilver> then it would have to try to generate functions.
02:55:40 <DrSyzygy> hkBst: Elaborate?
02:56:01 <pozic> quicksilver: so, just f, such that f a = b has been defined are all the candidates, where b is not a lambda.
02:56:06 <quicksilver> pozic: I think excluding that case might make it unuseful in haskell, since so many functions are parametrised or higher order and you need to pass some arguments to get the right thing.
02:56:14 <DrSyzygy> hkBst: I only get one iteration from the step function. And I want a single function call that will iterate it until it fails to produce additional output.
02:56:17 <hkBst> DrSyzygy: if your step function computes a list of 3 values and you only take the first and ignore the rest, only the first will be computed
02:56:22 <quicksilver> it might be interesting to try but I"d be really surprised if it answered many questions well.
02:56:49 <pozic> quicksilver: the data generated by this search engine can also suggest API design.
02:57:18 <Twey> > head [[1], [1 ..], [2, 4 ..]]
02:57:20 <lambdabot>   [1]
02:57:27 <DrSyzygy> hkBst: The point is that I have a step function, that works well. And I want to build a functions that gets me something like > step [] gens ++ (step gens (step [] gens)) ++ (step (gens ++ (step [] gens)) (step gens (step [] gens))) ++ ...
02:57:36 <DrSyzygy> so I can draw from THAT list lazily.
02:58:08 <DrSyzygy> At each point in the resulting list, anything I ever encounter only depends on things that happened earlier in the list, so it should be doable.
03:00:47 <harlekin> What else could cause UTF8 not being printed properly if I am already using hPutStrLn from System.IO.UTF8?
03:01:02 <blackh> DrSyzygy: Accumulators force evaluation.  If you write it without the accumulator that should do it.
03:01:15 <hkBst> DrSyzygy: step gens = gens ++ step gens newgens
03:01:35 <DrSyzygy> Ahhhhhh.
03:02:20 <quicksilver> harlekin: (a) your string is not correct unicode or (b) your terminal is not displaying it right.
03:02:28 <quicksilver> harlekin: I.e. suspect either the input or the output :)
03:03:59 <harlekin> quicksilver, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3309#a3309 this works on both my term and dzen2.
03:04:06 * DrSyzygy WOOOOOOOTS! Awesome! Thanks!
03:04:25 <harlekin> The very same string doesn't work using it in one of xmonad's loggers.
03:04:41 <harlekin> So I think a and b are correct. Both files are encoded utf-8. Is there anything else?
03:04:50 <quicksilver> I don't know much about xmonad and its loggers
03:04:51 * DrSyzygy is realizing that at some point he should probably mention #haskell in his paper acknowledgements...
03:05:19 <harlekin> quicksilver, if I am not mistaken the logger I am using just prints a string using UTF8.hPutStrLn h. :)
03:05:22 <DrSyzygy> This did itÃ–
03:05:22 <DrSyzygy> streamOperadicBuchberger maxOD gb = let
03:05:23 <DrSyzygy>     stepOnce oldgb newgb = oldgb ++ stepOnce (oldgb ++ newgb) (stepInitialOperadicBuchberger maxOD oldgb newgb)
03:05:26 <DrSyzygy>   in stepOnce [] gb
03:06:10 <quicksilver> harlekin: perhaps you are mistaken?
03:06:34 <Twey> â€˜stepInitialOperadicBuchbergerâ€™?  Argh!
03:09:10 * DrSyzygy sorries for fugly naming conventions. The code was written in a 2-week conference frenzy, and is too far outside my actual research to work sensibly with when I'm not doing coding frenzies.
03:09:18 <harlekin> quicksilver, guess so. :)
03:09:35 <Twey> It's huge :-P
03:09:59 <DrSyzygy> It's also internal. Not something you're really supposed to call from outside. Although, admittedly, streamOperadicBuchberger is not all that much better....
03:10:03 <pao> @pl \a _ -> a ++ [2]
03:10:03 <lambdabot> const . (++ [2])
03:31:03 <DrSyzygy> How are function declarations picked? First in the file that pattern matches, or most specific pattern match?
03:31:37 <koala_man> first that matches
03:32:07 <opqdonut> most specific is kinda hard
03:32:14 <Twey> Yeah, â€˜most specificâ€™ is conceptually and algorithmically tricky.
03:32:36 <opqdonut> with something like "f [] _ = 0; f _ [] = 1; x = f [] []"
03:33:17 <soupdragon> I think it takes a topological sort to implement
03:34:05 <quicksilver> I'm not sure if the reason is that most specific is tricky.
03:34:12 <quicksilver> I think the reason is that sometimes it's convenient to overlap
03:34:30 <quicksilver> and the easiest way to understand to manage to the overlaps is to just do it in file order.
03:34:37 <quicksilver> maybe that's saying the same thing.
03:34:55 <quicksilver> I think I'm saying: It's not because it would be tricky for the *compiler*. It's because it would be tricky for the *programmer* ;)
03:36:53 <DrSyzygy> How on earth should I structure a 1/2-page crash course in Haskell Concepts for readers from the field of computational algebra?
03:38:14 <quicksilver> carefully.
03:38:45 <DrSyzygy> Heh.
03:38:53 <DrSyzygy> Also - how do I cite Haskell appropriately?
03:39:24 <quicksilver> it's quite common to cite the haskell report, I think
03:45:43 <Twey> DrSyzygy: (Brackets)?  Â« French quotes Â»?  â€˜English quotesâ€™?  `Backticks`?
03:46:02 <Twey> {Braces}?
03:46:31 <DrSyzygy> Twey: If that's the level you answer at, I've already settled. BibTeX.
03:46:50 * DrSyzygy starts wondering if Twey will only ever answer me on a stylistical level.
03:47:14 <Twey> Ah.  :-P
03:47:24 <Ke> DrSyzygy: but have several bibtex styles to choose from"
03:47:26 <Ke> !
03:47:55 <Twey> It's good form to make the document a Literate Haskell file and use LaTeX \code
03:48:22 <DrSyzygy> That's not going to happen. Not with this project.
03:48:59 <DrSyzygy> I'm just going to be using very small code snippets to illustrate points, not actually write anything that will have value on its own as Literate Haskell.
03:49:18 <DrSyzygy> Ke: That's where adaptation to the publishing journal ends up overriding personal taste.
03:49:21 <Twey> You can still make them valid definitions
03:49:48 <DrSyzygy> Yeah, but it might end up requiring a lot more boilerplate than I care to write.
03:50:13 <DrSyzygy> And the lack of transparency for the lhs->tex generation is bad both for my collaboration and for arXiv submissions.
03:56:28 <Gwern-aw1y> could always write it in markdown+birdtracks and use pandoc -> tex :)
03:57:10 <lilac> could use an MS Word document and a VBA macro to extract the haskell code *ducks*
03:57:32 <quicksilver> or an inkscape document and a python script!
03:57:49 <quicksilver> I mean, if we're going to be silly, let's be properly silly.
03:58:13 <lilac> how about a whitespace and befunge quine where one program produces the document's tex source and the other produces the haskell?
03:58:19 * Gwern-aw1y doesn't think using pandoc is silly :(
03:58:28 <lilac> i don't mean quine, i mean bilingual program
03:58:32 <lilac> what's the word for that again?
03:58:36 <malcolmw> DrSyzygy: Andres LÃ¶h's lhs2TeX tool is rather marvellous
03:59:15 <lilac> polyglot?
03:59:22 <malcolmw> DrSyzygy: purely from the point of view of formatting Haskell nicely
04:03:09 <DrSyzygy> malcolmw: I know. I've used it before. And I deem it not suitable for this particular project.
04:24:12 <RayNbow> > join (:) []
04:24:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:24:16 <RayNbow> aww... :p
04:30:12 <lilac> > join (flip (:).return) 42
04:30:14 <lambdabot>   [42,42]
04:30:31 <cjs> Hey, what's that comp. sci. problem that involves doing an optimal division of things into groups of a certain size, e.g., songs of various lengths onto CDs of fixed length?
04:30:46 <soupdragon> bin packing maybe ?
04:30:48 <lilac> sounds like the 0-1 knapsack problem
04:30:57 <cjs> Knapsack, that's it. Thanks.
04:33:11 <cjs> http://xkcd.com/287/
04:35:02 <fasta> Is there any polygon library for Haskell or otherwise a C library to which I could bind which shrinks polygons? Otherwise polygon triangulation would also help.
04:35:34 <quicksilver> the only polygon triangulation I foudn for haskell was the one in GLU.
04:35:45 <quicksilver> I might have missed something though.
04:36:07 <quicksilver> the glu one works fine for rendering purposes but has poor properties if you care about "good" triangulations.
04:37:07 <fasta> quicksilver: What constitutes a "good" triangulation?
04:37:43 <nvoorhies> probably one where sides are close in length
04:38:00 <soupdragon> you awnt angles the same
04:38:11 <fasta> quicksilver: and which library are you talking about? GLUT? There is no GLU on hackage.
04:38:28 <quicksilver> fasta: GLU is part of the opengl binding
04:38:36 <quicksilver> although as C libraries they are considered separate.
04:38:51 <quicksilver> what "good" means is up to you
04:38:57 <cjs> Ooof. I just realized that a global optimization of orders to stay within my margin requirements is not only a knapsack problem, but one for which even a valuation function is going to be hard to come up with.
04:39:06 <quicksilver> but the GLU triangulator doesn't aim for any particular definition of good
04:39:14 <quicksilver> except, possibly, not too many triangles.
04:39:45 <cjs> In fact, the valuation of an order can be different depending on what other orders are on the market. (E.g., a spread on a pair of adjacent or nearly adjacent strikes can be worth much more than the individual orders alone.)
04:40:02 <cjs> I am obviously going to have a lot of fun with this over the next. year. Thank God I'm doing this in Haskell.
04:44:56 <fasta> Why is the v in triangulate :: Storable v => Tessellator Triangulation v? In particular with what instance does it do something useful?
04:49:49 <quicksilver> fasta: it's because opengl people are likely interpolating some other value along with their triangulation
04:49:54 <quicksilver> fasta: like colour, or texture coordinates.
04:50:17 <quicksilver> fasta: in the case that you the triangulator chooses to add a new point, it needs to callback something to interpolate the new value
04:50:28 <mmorrow> dolio: here's the description of jhc's typeclass implem http://repetae.net/repos/jhc/docs/jhc.mkd
04:50:28 <quicksilver> ...and that thing has to be storable because it is passed back and forth via C
04:51:01 <fasta> quicksilver: so, if you don't care about it you can just use a CInt?
04:51:32 <quicksilver> fasta: yeah. If only there was a dummy Storable instance for () :)
04:52:27 * mux ponders writing bindings flam3 for haskell and rewriting the dying electricsheep in haskell
04:52:48 <quicksilver> would that make it an electriczombiesheep?
04:56:50 <mmorrow> undeadelectriczombiesheep!
04:57:52 <JustinQ> Hello.
04:58:39 <mmorrow> data CVoid = CVoid; instance Storable CVoid where sizeOf _ = 0; peek _ = return CVoid; poke _ _ = return (); -- ?
04:59:16 <mmorrow> i wonder if anything would explode if alignment was 0
05:00:29 <quicksilver> mmorrow: why is that better than an instance for () ?
05:00:38 <quicksilver> mmorrow: but, yes, that's the kind of thing I was thinking.
05:01:16 <mmorrow> oh, hehe right.
05:01:36 <mmorrow> for some reason i thought you meant that ()'s instance *wasn't* that
05:02:00 <mmorrow> but thinking about it, i guess that's the only instance that makes sense
05:02:34 <mmorrow> oh, there is no std Storable instance for ()
05:02:48 * mmorrow now understands
05:04:19 <hallongrottan> @src foldl
05:04:20 <lambdabot> foldl f z []     = z
05:04:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:04:27 <hallongrottan> @src foldr
05:04:27 <lambdabot> foldr f z []     = z
05:04:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:10:04 <hallongrottan> @src (.)
05:10:05 <lambdabot> (f . g) x = f (g x)
05:52:11 <michaelfeathers> Lazy evaluation question: Is (++) really that bad?  Wouldn't  [1,2,3] ++ [4,5,6] reduce as (1:(2:(3 ++ [4,5,6]))).  In other words, peel items off the front until you get to the append, which at that point is essentially a cons?
05:52:57 <philed> @src (++)
05:52:58 <lambdabot> []     ++ ys = ys
05:52:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:52:58 <lambdabot> -- OR
05:52:58 <lambdabot> xs ++ ys = foldr (:) ys xs
05:52:59 <michaelfeathers> Er, I meant (1:(2:([3]++[4,5,6])))
05:53:00 <soupdragon> michaelfeathers, who said it was bad in the first place :p
05:53:12 <lilac> michaelfeathers: one use of (++) is OK. left-associative multiple uses are bad.
05:53:31 <lilac> @src concat
05:53:32 <lambdabot> concat = foldr (++) []
05:53:33 <michaelfeathers> Someone responding on a blog, but I think they were thinking strict.
05:53:35 <lilac> ^^ that's fine, for instance
05:53:49 <lilac> but foldl (++) [] is O(n^2)
05:54:19 <lilac> because you need to go through n layers of thunks to get to each element
05:54:32 <michaelfeathers> lilac: That example you posted was wild: sum . zipWith ($) (replicate y length ++ [const x]) $ terminatedLines contents
05:54:44 <quicksilver> michaelfeathers: in [1,2,3] ++ [4,5,6] you have added a one-time cost of O(1) to each of 1,2,3
05:54:53 <quicksilver> michaelfeathers: that's the 'peeling' process you're talking about.
05:55:07 <lilac> michaelfeathers: the way i was thinking about it was, we want the first y lines plus the first x characters of the next line
05:55:22 <lilac> zip has this nice property that it stops when it gets to the end of either list
05:55:24 <gwern> > 60 * 24
05:55:26 <lambdabot>   1440
05:56:41 <lilac> the similar formulation 'sum . zipWith ($) (replicate y length ++ [length . take x]) $ terminatedLines contents' has the nice property that if (x, y) is out of range, you get the length of the document
05:57:30 <michaelfeathers> lilac: Thx.
06:00:20 <lilac> michaelfeathers: are you writing a text editor?
06:01:29 <philed> I'm messing around with forall in ghc (rank-2 polymorphism?) and trying to get (\x -> x x) to typecheck when x has the type (forall a. Show a => a -> b). It seems to work when I type it directly into the toplevel after I declare all functions of type a -> b to be instances of Show, but it doesn't work when I load it from a file.
06:02:41 <quicksilver> philed: dreaded monomorphism restriction.
06:02:50 <quicksilver> probably
06:02:57 <lilac> {-# LANGUAGE NoMonomorphismRestriction #-}
06:02:59 <philed> quicksilver: That's what I assumed, but I can't figure out where it wants the extra type constraints.
06:03:02 <quicksilver> otherwise you need to give more details, preferably the file.
06:03:03 <EvilTerran> that's some pretty weird stuff to be doing
06:03:09 <philed> lilac: I'll try that.
06:03:18 <philed> EvilTerran: Purely academic. I just want to see if I can type it.
06:03:30 <EvilTerran> why the Show instance?
06:03:42 <EvilTerran> wouldn't something like Typeable be more useful?
06:04:46 <philed> EvilTerran: I just picked a random type class.
06:05:16 <EvilTerran> fair enough
06:06:41 <quicksilver> @type ((\x -> x x) :: (forall a . (a -> a)) -> (forall a . (a -> a))) id
06:06:44 <lambdabot> forall a. a -> a
06:06:59 <quicksilver> ^^ proof that \x -> x x will typecheck with an explicit rank-2 sig.
06:07:07 <quicksilver> although a simpler one than philed's.
06:07:11 <Alpounet> Hi.
06:07:29 <philed> quicksilver: Yeah I can get that to type fine. Just when I put a constraint in there it complains.
06:07:42 <lilac> > ((\x -> x x) :: (forall a. Show a => a -> b) -> b) show
06:07:44 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
06:07:44 <lambdabot>    arising from a use of `...
06:08:21 <quicksilver> philed: well then you need to tell us what the complaint is :P
06:08:35 <philed> Okay, here's the code:
06:08:37 <philed> apply :: forall b. (forall a. (Show a) => a -> b) -> b
06:08:47 <philed> apply f = f f
06:09:12 <philed> And the complaint is "    Ambiguous type variable `a' in the constraint:
06:09:12 <philed>       `Show a' arising from a use of `f' at ../test.hs:7:12
06:09:12 <philed>     Probable fix: add a type signature that fixes these type variable(s)"
06:09:37 <philed> Actually, I don't need the forall b there.
06:09:41 <lilac> philed: yeah, i'm seeing much the same in my experiments
06:09:46 <quicksilver> not having it there is the same as having it there.
06:10:08 <philed> quicksilver: But I'm happy to assume frees are universally quantified.
06:10:17 <Lemmih> philed: You have to give the inner 'f' a specific type.
06:10:19 <lilac> philed: the problem is that you can't pass that rank-2 type to itself
06:10:30 <quicksilver> whether your happy or not is less important than what GHC does :)
06:10:39 <quicksilver> and GHC assumes frees are universally quantified.
06:11:01 <lilac> f :: forall b. (forall a. (Show a) => a -> b) -> b
06:11:01 <lilac> f x = x (x :: () -> b)
06:12:15 <philed> Aha.
06:12:24 <quicksilver> philed: the point is, you've made (a -> b) Showable.
06:12:36 <philed> I still couldn't get that to work lilac, but if I choose a specific b it is okay.
06:12:36 <quicksilver> but you haven't made (forall a. (Show a) => a -> b) Showable
06:12:37 <Lemmih> It's the same problem as this 'show (undefined :: a)'.
06:12:55 <quicksilver> you can't write a show instance for "truly polymorphic" type
06:13:02 <quicksilver> only specific types can have instances.
06:13:16 <philed> quicksilver: Ah, okay that makes sense.
06:13:18 <quicksilver> [*] the instance can be polymorphic, but that means it applies to all concrete examples, not that it applies to the polymorphic one.
06:13:40 <lilac> philed: you need the forall b. and ScopedTypeVariables for that to work.
06:16:08 <philed> lilac and quicksilver: Sorry, I'm confused on that one. Why isn't there an implicit forall there?
06:16:31 <lilac> philed: ScopedTypeVariables requires the forall for b to scope over the body of f
06:16:44 <lilac> philed: otherwise the 'b' in the body and the 'b' in the type are different variables
06:16:56 <quicksilver> philed: there is an implicit forall
06:17:02 <quicksilver> philed: the ScopedTypeVariables is a hack.
06:17:14 <quicksilver> philed: for compatibility reasons it is defined to only kick in with an explicit forall
06:17:25 <quicksilver> (so that merely activating the extension doesn't break old code)
06:17:40 <quicksilver> ugly but understandable.
06:19:01 <philed> quicksilver: Okay gotcha. Thanks for your help here guys.
06:19:04 <lilac> where does the instance (Typeable a, Typeable b) => Show (a -> b) live?
06:19:18 <lilac> is that a Lambdabot Special (tm)?
06:19:32 <quicksilver> it was a lambdabot special, which someone broke.
06:19:39 <quicksilver> > ord
06:19:41 <lambdabot>   Overlapping instances for GHC.Show.Show
06:19:41 <lambdabot>                              (GHC.T...
06:19:56 <quicksilver> btu I think it made it into some obscure package or other
06:20:07 <lilac> looks like package 'show', module ShowFun
06:20:33 <Alpounet> but lambdabot doesn't load it :/
06:20:49 <quicksilver> lambda has the instance
06:20:55 <quicksilver> but it has another overlapping instance, that's all.
06:20:57 <lilac> lamdabot has both that and a quickcheck one which overlaps
06:21:02 <lilac> smallcheck rather
06:21:13 <Alpounet> ok
06:21:34 <quicksilver> which is quite unfortunate, since overlapping instances can create strange matter
06:21:42 <quicksilver> which will surely turn the universe into a grey mush.
06:21:43 <quicksilver> oh well.
06:21:59 <Alpounet> btw guys, got a question : is there a "haskell code design" document anywhere ?
06:23:45 <michaelfeathers> lilac: yes, as a learning exercise.  Close to the point when I'll throw it up on github and ask people to tell me how bad my choices were.
06:24:51 <lilac> michaelfeathers: awesome, sounds like a great project. best of luck!
06:24:53 <michaelfeathers> I know one of them is very bad, but as I said, it's a learning exercise.  A document is a string and whenever I insert a char, I split the String insert the char and then append it altogether.
06:25:23 <kfish> Alpounet, API design or coding style?
06:25:26 <michaelfeathers> What is interesting though, is that for an interactive application I don't feel much sluggishness even doing it that naive way.
06:25:26 <lilac> as long as your document type is suitably abstract, you should be able to fix that later if you want to
06:26:11 <lilac> i expect it'll get worse if you edit near the end of a long document
06:26:35 <michaelfeathers> Yes. One thing I'm having trouble with... I have the function I want to render it with but I want to keep that in a module which knows IO.  The buffer type is something I'd like to avoid exposing constructors for to make it sort of an ADT.  Hard to get that modularity.
06:27:09 <EvilTerran> michaelfeathers, would a string zipper perhaps work better?
06:27:22 <michaelfeathers> Actually, I guess it's not that bad.. I can introduce accessors but that seems odd.
06:27:35 <michaelfeathers> EvilTerran: I don't understand zippers yet.
06:27:42 <Alpounet> kfish: rather API design
06:28:22 <michaelfeathers> It's funny.. there are all sorts of edge conditions in vi's insert and command mode that I never thought of before.  (I'm emulating vi)
06:28:38 <EvilTerran> data ListZipper a = LZ { before :: [a], here :: a, after :: [a] } -- the elements before the current one being stored in reverse
06:29:12 <ziman> or maybe a Sequence?
06:29:24 <EvilTerran> makes modifications around the "current one" very straightforward
06:29:33 <quicksilver> I actually don't think michaelfeathers was *looking* for a solution to that problem though :)
06:29:36 <EvilTerran> Data.Sequence.Seq might work too...
06:29:58 * EvilTerran just saw a bit of discussion about appending lists, and thought he may as well chip in
06:30:39 <kfish> Alpounet, http://www.haskell.org/hierarchical-modules/libraries/library-design.html (basic/boring)
06:30:46 <michaelfeathers> What the hell..  here's the data structure for the editor.  Feel free to laugh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8137#a8137 :-)
06:31:00 <kfish> Alpounet, the later chapters of RWH might be useful
06:32:46 <Alpounet> kfish: ok, thanks a lot.
06:34:30 <RayNbow> @pl \xs -> xs : xs
06:34:30 <lambdabot> join (:)
06:34:37 <RayNbow> :t join (:)
06:34:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:34:41 <lambdabot>       Expected type: a -> a -> a1
06:34:41 <lambdabot>       Inferred type: a -> [a] -> [a]
06:35:20 <RayNbow> > [] : []
06:35:23 <lambdabot>   [[]]
06:35:29 <EvilTerran> ?type join ((:).In)
06:35:31 <lambdabot> [Mu []] -> [Mu []]
06:35:41 <MyCatVerbs> :t In
06:35:43 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
06:35:51 <EvilTerran> > join ((:).In) []
06:35:53 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
06:35:54 <lambdabot>    arising from a use of `M159410...
06:36:00 <EvilTerran> GRRR
06:36:02 <RayNbow> @src In
06:36:03 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:36:08 <EvilTerran> >:(
06:36:12 <RayNbow> :t join ((:).In) []
06:36:14 <lambdabot> [Mu []]
06:36:35 <quicksilver> good example of the fact that @pl is typeless
06:36:41 <quicksilver> :t \xs -> xs : xs
06:36:43 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:36:43 <lambdabot>       Expected type: [a]
06:36:43 <lambdabot>       Inferred type: a
06:36:52 <michaelfeathers> I find myself using lots of as-patterns, which leads me to believe that I have some function which are working on the wrong data structures.
06:37:23 <RayNbow> quicksilver: but sometimes @pl forces you to typemore :p
06:37:53 <MyCatVerbs> @let showMuList l = '[' : concatMap showMuList l ++ "]" in showMuList $ join ((:).In) []
06:37:54 <lambdabot>   Parse error
06:38:02 <MyCatVerbs> > let showMuList l = '[' : concatMap showMuList l ++ "]" in showMuList $ join ((:).In) []
06:38:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:38:29 <pao> @seen Saizan
06:38:30 <lambdabot> Saizan is in #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 9h 19m 29s ago.
06:39:55 <lilac> michaelfeathers: i think longer-term you'll want to separate the location (which is really part of the view) from the buffer
06:40:06 * EvilTerran considers putting together a patch for lambdabot with some useful (albeit -XUndecidable) instances for Mu
06:40:24 <lilac> also, i think you'll find zippers make it very hard to add multiple views of the same buffer
06:40:28 <EvilTerran> > In [] == In [] -- i bet there's no Eq instance either
06:40:30 <lambdabot>   No instance for (GHC.Classes.Eq (L.Mu []))
06:40:31 <lambdabot>    arising from a use of `GHC.Cl...
06:40:49 <michaelfeathers> lilac: Very possible.  On the other hand, nearly all of the logic involves the manipulation of location or it's use.
06:41:25 <EvilTerran> lilac, iirc, the n^th derivative of a type is a zipper with n "holes"
06:41:30 <EvilTerran> (although i may be wrong)
06:42:28 <lilac> EvilTerran: that sounds right to me. i still think it won't be easy (but i'd love to see code which handled that nicely)
06:42:51 <quicksilver> you don't even need multiple windows to recognise the problem
06:43:01 <quicksilver> consider a buffer which has an insertion point, but also a scrollbar
06:43:06 <EvilTerran> you'd probably have to do something pretty weird with the types to support an arbitrary number of holes
06:43:09 <quicksilver> scrolling around doesn't move the insertion point
06:43:21 <quicksilver> (i.e. like most modern GUI editors, but unlike emacs)
06:43:35 <quicksilver> then you presumably want O(1) access to the screenful of data you're looking at
06:43:43 <quicksilver> as well as O(1) access to the data near the point.
06:43:48 <EvilTerran> altho O(log n) would probably be good enough
06:43:56 <quicksilver> yup.
06:44:03 <EvilTerran> if log n is too big, you need to make your code more modular ;)
06:44:03 <quicksilver> I should have just said "fast" really.
06:44:42 <quicksilver> my first instinct is to suggest some kind of chunked structure.
06:44:51 <calder> http://www.sexy-lena.com/?uid=511413
06:44:55 <quicksilver> well, actually my first instinct is to start with the simplest, naivest thing which could possibly work
06:45:08 <quicksilver> and then observe the performance I get and see if that's good enough :)
06:45:22 <quicksilver> my second instinct is, if that's not good enough, try some kind of chunked structure.
06:46:37 <lilac> i would think a finger tree would be excellent for this
06:46:50 <quicksilver> yes, Data.Sequence should perform reasonably.
06:47:34 <quicksilver> but do you really want to index by character?
06:47:43 <quicksilver> what about by line, or by paragraph?
06:47:51 <quicksilver> quite a lot of choices in making a sensible text format
06:50:46 <lilac> quicksilver: wouldn't a full finger tree interface allow you to support all of those simultaneously through the use of multiple monoids measuring the data?
06:50:57 <lilac> i may have misremembered the details from the finger tree paper
06:51:10 <lilac> looks like Data.Sequence doesn't have the right interface for it, though
06:51:15 <quicksilver> I don't think so.
06:51:26 <quicksilver> I think whichever monoid you use, fingertree is still about accessing single elements
06:51:31 <quicksilver> not about groups of elements.
06:51:35 <quicksilver> maybe there is a trick though.
06:52:07 <lilac> i think you can efficiently split on the start of a certain line
06:52:16 <lilac> (and then split the second half on the start of the next line)
06:52:28 <lilac> if extracting a line is what you're after...
06:52:38 <Alpounet> bye.
06:53:41 <quicksilver> would be cool if you're right.
06:53:49 <quicksilver> stil, that's a solution in search of a problem.
06:53:58 <quicksilver> Seq Char might be fine :)
06:54:15 <quicksilver> could have an external IntMap from line numbers to char indices
06:54:28 <lilac> updating that when a line is deleted would be painful
06:54:28 <quicksilver> although, hmm, that would be expensive to update
06:54:40 <quicksilver> I wonder if there is a structure designed for that job
06:54:46 <quicksilver> I bet you can use a fingertree for that too :)
06:54:50 <lilac> i thought that's what a fingertree was ;-)
06:54:55 <quicksilver> yes.
06:55:05 <quicksilver> all roads lead to fingertree.
06:56:34 <lilac> Data.FingerTree looks more like the right thing than Data.Sequence i think
06:57:52 <lilac> something like "instance Measured (LineNumber, LinearPosition) Char where measure '\n' = (1, 1); measure _ = (0, 1)"
06:58:20 <lilac> ... would allow splitting on line numbers or character indices
07:01:00 <quicksilver> lilac: together, presumably, with an obvious Monoid instance which is a component-wise (+) ?
07:01:28 <lilac> yeah.
07:01:45 <lilac> the downside is that it's not a very efficient way of storing lots of Chars compared to, say, a ByteString
07:01:48 <quicksilver> lilac: ah, one of their examples is IntervalMap
07:02:08 <quicksilver> lilac: that's the right way to store my map of line-number-to-character-index, isn't it?
07:02:36 <lilac> sure, if you want it separate from the main data structure, i think that's right
07:02:41 <PeakerWork> finger tree is that tree with monoids qualifying over each sub-tree?
07:02:55 <quicksilver> which would then mean you could use a ByteString for the main structure, lilac
07:02:57 <lilac> PeakerWork: yeah
07:03:13 <quicksilver> (or some variant of bytestring intended to accomodate easier mutation)
07:03:23 <lilac> quicksilver: Data.Seq ByteString? ;-)
07:03:27 <quicksilver> perhaps, yes.
07:03:48 * lilac ponders a fingertree of (fingertree, ByteString)
07:03:48 <quicksilver> with chunks that get split up when they're edited
07:04:04 <quicksilver> and some periodic de-frag process
07:04:18 <quicksilver> which coalesces any chunks smaller than 8K
07:04:21 <LeCamarade> Compiling Yi isn't for minors. My computer has never been this pegged by a single cabal install. :-)
07:04:45 <lilac> quicksilver: this sounds like a pretty awesome data structure :)
07:05:22 <Cale> LeCamarade: How much ram do you have?
07:05:47 <dcoutts> quicksilver, lilac: Tom Harper is working on that
07:05:52 <quicksilver> lilac: well, I particularly like the fact that you could naively store undo history in a list
07:05:57 <quicksilver> lilac: and get pretty good sharing.
07:06:05 <PeakerWork> Does anyone use Haskell on the browser, via some Haskell compiler/interpreter to Javascript?
07:06:07 <dcoutts> like a rope but using a finger tree
07:06:17 <quicksilver> dcoutts: I've never actually known what a rope was
07:06:22 <quicksilver> althoguh obviously I've heard of it.
07:06:33 <dcoutts> quicksilver: it's a tree of chunks representing a big string
07:07:06 <Cale> LeCamarade: My friend has 512MB, and her computer was swapping for about 3 hours the other day. On my machine with 1GB it's not so bad, but nearly fills the 650MB free after my desktop and all the other stuff I run all the time.
07:07:11 <LeCamarade> Cale, I'm not sure how to find that out on this here SuSE Linux machinne.
07:07:17 <PeakerWork> quicksilver: I think a lazy bytestring is a rope (at least if it was mutable) -- a list of arrays, with somewhat good indexing, and somewhat good middle insertion/deletion.  I think its in between arrays and lists in performance of operations
07:07:26 <PeakerWork> oh, a tree and not a list?
07:07:32 <quicksilver> Oh. I always thought ropes were something much cleverer than that.
07:07:38 <quicksilver> how disappointing.
07:07:43 <dcoutts> quicksilver: well the devil is in the details
07:07:48 <quicksilver> reality-- # doesn't live up to expectations.
07:07:57 <Cale> LeCamarade: typing 'free' at the commandline ought to give you some numbers in kilobytes
07:08:18 <dcoutts> quicksilver: there's the balancing of the tree and the coalescing of chunks, some C impls also do some kind of lazy IO
07:09:40 <dcoutts> PeakerWork: if you look at the ICFP competition from a couple years back (the alien dna one) then you'll see that a lazy bytestring is no an appropriate representation where as a naive fingertree of Char was fine. It being a tree is critical in some situations.
07:10:03 <dcoutts> on the other hand, a balanced tree version cannot represent unbounded streams of data like a lazy list can
07:10:04 <quicksilver> http://www.sgi.com/tech/stl/Rope.html
07:10:41 <quicksilver> ^^ I note that the SGI doc for their rope implementaiton reads like a reasoned argument for the use of immutable data structures :)
07:10:53 <LeCamarade> Cale, I do a 512MB gig.
07:12:36 <MarcWeber> nominolo|uni: Which is the way to run RunTests.hs ? I'd like to add another test
07:12:37 <LeCamarade> I'll run this install when I'm away from the desk. Overnight. For now, it is just disabling.
07:37:18 <_randomwords_> jon damian
07:37:23 <_randomwords_> again ignore that
07:37:26 <_randomwords_> damn xmonad...
07:37:48 <Twey> Heh.  New to it?
07:38:04 <_randomwords_> I'm used to wmii
07:38:13 * Axman6 thinks that was quite appropriate given your nick
07:38:19 <_randomwords_> And these new bindings are not in my muscle memory
07:39:06 <_randomwords_> I should probably hack my xmonad.hs file at some point..
07:39:32 <_randomwords_> So. Is everyone having fun with Haskell today?
07:39:45 <soupdragon> yes
07:39:49 <Axman6> not today, no programming for me :(
07:39:58 <Axman6> actually, that's a lie :)
07:40:06 <soupdragon> I made a ruby goldberg machine earlier
07:40:07 <Axman6> i forgot i was working on my assignment
07:41:02 <Twey> soupdragon: A Rube Goldberg machine?
07:41:06 <soupdragon> yeah
07:41:15 <Twey> See, Ruby is already a Rube Goldberg machine
07:41:18 <Twey> That's where it got its name
07:41:38 <Twey> (kidding â€” don't hurt me, Ruby-using hordes!)
07:42:39 <lilac> ruby uses The Incredible virtual Machine
07:51:58 <Axman6> could i get someone to take a look at a proof of mine? it is for an assignment, so i don't want much help, just want to know if i've gone about things correctly
07:54:25 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8138#a8138 is the code if someone wouldn't mind
07:57:12 <Beelsebob> looks sensible to me Axman6
07:57:25 <Axman6> would you say it's proved?
07:57:30 <Beelsebob> yep
07:57:44 * Axman6 affixes the QED
07:59:03 <Axman6> that was fun, had a minute of lag -_-
08:00:08 <Axman6> hmm, i'll need to take another look at it tomorrow to make sure i've got all the inequalities and variable names correct
08:05:44 * Axman6 goes and adds all the âˆ€'s that are needed
08:06:09 <soupdragon> (-âˆ€-)w
08:07:40 <RayNbow> hmm
08:07:59 * RayNbow wonders which version is faster or more elegant... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8135
08:09:00 <soupdragon> btw
08:09:14 <soupdragon> you might let  downFrom n = [n,n-1..0]
08:09:24 <soupdragon> then i <- downFrom k
08:09:36 <soupdragon> (some people probably hate that but I find it better)
08:09:41 <RayNbow> heh
08:09:44 <Axman6> how would you add an Ord constraint to "âˆ€ (x :: a). âˆ€ (y :: a). x /= y"?
08:09:54 <Axman6> i'm just not sure where to put it
08:10:01 <RayNbow> soupdragon: I defined a down_from function for the Python version of that function :p
08:10:08 <Axman6> Ord a => âˆ€ (x :: a). âˆ€ (y :: a). x /= y?
08:10:26 <RayNbow> because I found Python's range function a bit awful to use directly
08:10:33 <soupdragon> great minds!!!
08:10:35 <ski> Axman6 : yes
08:10:42 <Axman6> ok, thaks ski :)
08:10:45 <RayNbow> (Python's range(n) == Haskell's [0..n-1])
08:10:54 <Axman6> (this isn't necessary for the assignment, but i'm having fun ;))
08:11:35 <RayNbow> hmm, the combinationsR' function seems a bit faster and to use a bit less memory (in ghci, so that doesn't say much)
08:14:08 <Axman6> @quote 4D
08:14:08 <lambdabot> lambdabot says: fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
08:14:11 <Axman6> @quote 4D
08:14:12 <lambdabot> jedivulcan says: Isn't 4D time? wasn't 4D gaming accomplished by loading screens?
08:14:15 <soupdragon> lol
08:14:56 <RayNbow> <soupdragon> great minds!!! <-- great minds use Haskell? :p
08:15:12 <RayNbow> *think in Haskell
08:15:16 <RayNbow> might be a bit more appropiate
08:16:08 <Axman6> i always feel more confortable when i'm in a lecture and i can translate something into haskell mentally
08:26:37 <tkr> ok. Ive asked this before. but I'd like to have a Haskell/OpenGL/GLUT on my Windows XP. is there an installer, or a good guide? is mingw/msys required, or whats the recommended way?
08:27:09 <tkr> on my work -debian it worked like a dream, but Id like to have a hobby at home also. :)
08:27:15 <Axman6> tkr: the haskell platform:
08:27:19 <Axman6> @where platform
08:27:19 <lambdabot> http://hackage.haskell.org/platform/
08:27:38 <tkr> ok. thanks. it should contain it all?
08:28:04 <Axman6> should do, yes
08:28:45 <tkr> thanks. trying to install right away.
08:29:30 <tkr> Im starting to fall in love with Haskell, as an old Perlist. :)
08:30:10 <Axman6> perlist?
08:30:17 <tkr> someone who really like Perl.
08:30:23 <Axman6> ot, perl-ist, i split the word incorrectly
08:30:27 <Axman6> oh*
08:30:36 <dino-> tkr: That's good to hear. I've gotten a lot of pushback from Perl co-workers over the past several years. Kind of disappointing.
08:32:29 * Axman6 wonders how true the claims were that pugs wasn't doing so well because all the perl users realised they liked haskell better than perl and did't care about finishing it
08:33:48 <Cale> Axman6: Well, it's certainly true that Haskell strongly influenced many Perl 6 features.
08:33:59 <dino-> That's exactly how I first heard about Haskell. Contributing to some of the P6 efforts.
08:35:28 * ManateeLazyCat pasted "Page and PageBuffer" at http://paste2.org/get/375221
08:35:29 <ManateeLazyCat> I have above code, class PageBuffer for abstract common function for `Page`, but i found a problem, not every instance of `PageBuffer` need all functions in class `PageBuffer`, example, the abstract fucntios in PageBuffer are almost editor command, but some instance (such as Move-Player) don't need so many editor functions, any idea to improve? Thanks!
08:35:40 <yottis> i hope it didn't contribute to the effort getting into a limbo
08:35:48 <fasta> Is there an example of a non-trivial binding to a C++ library somewhere?
08:36:32 <tkr> Axman6: needs something more. Loading package GLUT-2.1.1.2 ... <interactive>: glut32: The specified module cou
08:36:35 <tkr> ld not be found.
08:36:53 <tkr> Axman6: I just installed the Haskell Platform as suggested on my winXP
08:38:09 <ManateeLazyCat> Of course, i can make instance function empty, if instance not need that abstract function, but it's duplicate so much if PageBuffer instance don't need so many abstract functions.
08:39:10 <tkr> Axman6: I havent tried this for a very long time, maybe like couple days during a week for couple weeks. but I cant seem to get it working properly on my windows box. :/
08:39:33 <dino-> tkr: I wonder if a native library needs to be installed.
08:41:06 <tkr> dino-: this is the one with the win32 guides. http://www.nabble.com/Installing-GLUT-package-on-Win32-td12583208.html .. do you think I should combine this guide somehow with the haskell platform installation?
08:41:29 <dino-> This happens all the time with ffi stuff, like the Haskell curl needing libcurl or the ghc itself needing native gmp. But our whizzy packaging systems in *nix go hunt a lot of this down for you.
08:42:10 <ManateeLazyCat> I think i should try to define two different class interface, one for common command, another for speical command.
08:42:19 <tkr> nod. on my work debian I had almost no problems and was plotting nicely. but now again I got work to do (@work) and need to use my work desktop for programming perl or java :)
08:42:50 <tkr> but has ANYONE here succefully got haskell+opengl+glut working on a windows xp box?
08:42:58 <dino-> tkr: Huh, that looks ominously bad.
08:42:58 <CrazyAzrael> tkr: http://www.opengl.org/resources/libraries/glut/glut_downloads.php
08:43:15 <CrazyAzrael> tkr: See if you can install GLUT first, you may not have that.
08:43:32 <CrazyAzrael> (I don't think haskell packages that in the platform, as it's really not a haskell lib in any way)
08:44:29 <etpace> Hmm.. has anyone got some pointers on how I'd create a function that takes say five numbers, and another number N, and it has to output all possible ways of getting N using *, +, - etc? (ala countdown)
08:45:31 <fasta> tkr: if this is for your home machine anyway, why not install Debian? Or Ubuntu? Ubuntu can even be installed from within Windows.
08:45:35 <tkr> CrazyAzrael: ok. any other more preferred ways to drawing points to screen using haskell? Im dreaming of drawing like a grid made of points using haskell. then performing several different (complex [number]) transformations on the grid and re-ploitting the results.
08:45:46 <ski> > replicateM 3 pick' `evalAffine` "abcde"  -- RayNbow
08:45:48 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
08:45:51 <quicksilver> tkr: lots of people have got gl on windows working, I doubt it's that hard.
08:45:58 <quicksilver> it used to work out of the box on the old GHC installers
08:46:09 <quicksilver> but I can't much help you myself, never having used windows
08:46:09 <CrazyAzrael> tkr: Dunno, I've always just used GL for that.
08:46:44 <tkr> fasta: my Girlfriend is the problem. I should teach her Linux then. and also having the trouble of configuring all the audio/video devices, theater mode on my LCD in living-room etc
08:46:51 <dino-> I wonder if that glut32.dll is simply missing.
08:46:54 <tkr> fasta: it all seems like a PAIN of configuring.
08:47:11 <CrazyAzrael> dino-: This is most likely what the issue is, which is why I linked him to the GLUT installation page.
08:47:12 <fasta> tkr: but you can also install two operating systems.
08:47:21 <fasta> tkr: just boot by default into Windows and you are done.
08:47:30 <tkr> dino-: I remember seeing a guide that compiled freeglut and then copied glut32.dll to \windows\system32 ... could it be that?
08:47:41 <artagnon> I want to convert 'A'..'Z' -> 1..26 | My current solution: zip ['A'..'Z'] [1..26], lookup fst and return snd. Is there a better way?
08:48:07 <dino-> tkr: Maybe. I'm sad if there isn't a binary installer for that though.
08:48:11 <msteele_> etpace: Look into the list (aka non-determinism) monad
08:48:16 <dino-> I'
08:48:31 <fasta> artagnon: something involving ord and some arithmetic will work.
08:48:31 <Cale> artagnon: well, the lookup function ought to do nicely on its own with that list of pairs
08:48:42 <msteele_> > [(+), (-), (*)] <*> [1..3] <*> [1..3]
08:48:44 <lambdabot>   [2,3,4,3,4,5,4,5,6,0,-1,-2,1,0,-1,2,1,0,1,2,3,2,4,6,3,6,9]
08:48:45 <Cale> artagnon: But yeah, that's much slower than using chr and ord
08:48:59 <dino-> I'm kind of shocked at how there's nothing even kind of like rpm without yum on there. Or maybe not even as smart as rpm. :/
08:48:59 <artagnon> Cale: Right, lookup.
08:49:02 <pikhq> > ord 'Z' - ord 'A'
08:49:04 <tkr> dino-: I was looking at this. http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/ ... any opinions? I dont know haskell environment very well and am better with *nixes than with windowses.
08:49:04 <lambdabot>   25
08:49:23 <pikhq> > ord 'Z' - ord 'A' + 1
08:49:24 <pikhq> There.
08:49:24 <lambdabot>   26
08:49:31 <artagnon> pikhq: oh awesome :)
08:49:35 <artagnon> thanks :)
08:50:33 <Saizan> dino-, tkr: doesn't the haskell-platform contain OpenGL and GLUT?
08:51:01 * Axman6 would guess the error means OpenGL isn't installed
08:51:50 <dino-> tkr: That page sounds like it has worked for people. And some people who I recognize from here too like RayNbow, newsham.
08:53:33 <artagnon> Another quickie: Is there a more elegant way to write this? sum [(x + 1) * scoreList !! x | x <- [0 .. length(scoreList) - 1]]
08:53:43 <dino-> But I mean, forget Haskell, forget GL, just the packaging and dependency situation in Windows. It's so last-century.
08:53:56 <tkr> Saizan: seams to moan about glut32.dll missing (the haskell platform installed on my box)
08:54:11 <Axman6> :t zipWith3
08:54:12 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:54:13 <artagnon> dino-: No, it's non-existant.
08:54:20 <tkr> dino-: Ive also heard FieldTrip mentioned. but I dont really yet know which would even meet my needs.
08:54:34 <Axman6> hmm, only needs zipWith
08:54:37 <fasta> Packaging on Linux can also be done better. Some operations in Apt are really slow. I don't know whether RPM or whatever format Suse uses, does it better.
08:54:46 <SamB_XP> tkr: I somehow doubt glut32 is a Haskell library ;-P
08:54:48 <ski> s/length(scorelist)/length scorelist/
08:54:58 <artagnon> ski: Right. Fixed.
08:55:01 <artagnon> Anything else?
08:55:06 <SamB_XP> fasta: it's that huge-ass textual database
08:55:12 <ksf> zipwith (*) scorelist [1..]
08:55:16 <dino-> fasta: I've been really impressed with Arch packaging.
08:55:20 <ski> yes, zip is nicer
08:55:24 <SamB_XP> or rather, those huge-ass textuap databases
08:55:33 <ksf> nope, sum $ zipwith (*) scorelist [1..]
08:55:34 <fasta> SamB_XP: yes, but it contains only 20,000 items.
08:55:35 <artagnon> ksf: Wow, I've been an idiot :)
08:55:42 <CrazyAzrael> fasta: RPM has a whole bunch of different problems. I can't testify to the speed, but there's alot of stuff where it can get partway through installing something, fail, and leave the system in an inconsistent state.
08:55:44 <artagnon> Thanks! :D
08:55:51 <fasta> SamB_XP: that should not take as long as it does now.
08:55:58 <tkr> SamB_XP: so you thinkg I need to mingw/msys environment just to compile it to get it to my box?
08:56:18 <SamB_XP> tkr: no ... just try and find a glut32.dll
08:56:18 <ksf> well, zip cutting off the shorter list is questionable semantics.
08:56:23 <fasta> CrazyAzrael: that only happens in Debian when you use unstable stuff.
08:56:24 <ksf> but that's how it works in haskell.
08:56:24 <CrazyAzrael> fasta: e.g. upgrading libfoo, but the applications depending on it don't upgrade, and everything explodes.
08:56:43 <dino-> tkr: Maybe this http://pcsupport.about.com/od/findbyerrormessage/a/glut32-dll-not-found-missing-error.htm
08:56:46 <CrazyAzrael> fasta: (Yeah, I'm saying this is how it works for RPM)
08:56:48 <dino-> I see some links to binary things
08:56:50 <Axman6> ksf: not cutting it off would reduce the generallity no?
08:56:58 <ski> ksf : you think it would be better with run-time error, in case of length mismatch ?
08:57:04 <Axman6> well, zipWith at least
08:57:33 <Axman6> would have to be zipWith :: (a -> a -> a) -> [a] -> [a] -> [a]
08:57:34 <ksf> ... you should read "that's how it works in haskell" as "haskell lists don't come with their length in their type"
08:58:15 <ksf> furthermore, I only said questionable, not wrong. I should have said debateable, though.
09:00:08 <CrazyAzrael> Definitely true. An alternate semantics that would likely be less convenient, but seems equally valid would be for members past the end of a list to appear in the zipped form as undefined
09:00:56 <artagnon> I'm stuck in http://projecteuler.net/index.php?section=problems&id=11 -- In other languages, I'd use a 2d array. I'm kind of confused what to do in Haskell. Hint please?
09:01:09 <Asztal> http://freeglut.sourceforge.net/ <- try that?
09:01:13 <artagnon> And please, no solutions.
09:01:16 <fasta> artagnon: Haskell has read-only 2d arrays.
09:01:28 <CrazyAzrael> artagnon: Try using tuple of ints as an index for a standard array.
09:01:30 <fasta> artagnon: With an extension you also have read-write 2d arrays.
09:01:32 <soupdragon> artagnon, A function from Coordinate -> Integer
09:01:34 <badsheepy> i used a list of lists and it was fine :o
09:01:49 <soupdragon> e.g. f (0,0) = 08
09:02:03 <artagnon> soupdragon: I like the idea :)
09:02:27 <artagnon> fasta: I'm sick of Monads. I don't understand them and I don't ever intend to learn them.
09:02:37 <burp> lol
09:02:40 <CrazyAzrael> soupdragon: That's just an array without an explicit domain.
09:02:43 <artagnon> fasta: besides, soupdragon's idea is nice
09:02:59 <CrazyAzrael> (and without storage speedups)
09:03:03 <fasta> artagnon: for this problem you can use read-only 2d arrays.
09:03:10 <fasta> artagnon: so, no monads.
09:03:22 <artagnon> fasta: No Monads? ok. I'll have a look
09:03:23 <fasta> artagnon: but with lists it will also work "fast enough".
09:03:25 <artagnon> which module?
09:03:31 <fasta> Data.Array, I think.
09:03:50 <artagnon> Let me try soupdragon's solution first actually. Flat list with all the numbers
09:04:00 <soupdragon> artagnon, monadic programming is worth understaning at some point btw (but it is a very advanced technique)
09:04:01 <Cale> arrays are just functions with an efficient representation
09:04:11 <fasta> You can then just do array [(0,0), (n-1,n-1)] [((0,0),value_for_cell)]
09:04:42 <artagnon> soupdragon: It's imperative programming in an FP environment. What's the point? I already know so many imperative languages with conditionals, flow of control and loops
09:04:51 <fasta> modulo parentheses errors.
09:05:03 <soupdragon> artagnon, it doesn't have to be imperative, that's just one class of monads
09:05:04 <artagnon> Cale: Right, I figured just as much
09:05:38 <fasta> f(g(h x)) is as imperative as h;g;f, imho.
09:05:41 <Cale> artagnon: Well, I just mean in general. They're not literally function values in Haskell.
09:06:06 <sm> morning all
09:06:08 <Cale> fasta: Don't you mean f;g;h ?
09:06:09 <artagnon> soupdragon: I see.
09:06:19 <sm> there was a #haskell-web at one point, IIRC ?
09:06:21 * ski thinks of monadic programming as (controlled) imperative programming on stereoids
09:06:23 <fasta> Cale: h is done first.
09:06:24 <artagnon> soupdragon: I'll ask you more about this after finishing this problem
09:06:25 <hzap> artagnon: the list monad isn't imperative; and it could come in very useful for some projecteuler problems
09:06:28 <Cale> fasta: f is evaluated first in f (g (h x))  :)
09:06:49 <soupdragon> artagnon, for example,  nondeterministic searching  and also  parser combinators
09:06:53 <fasta> Cale: yes, evaluated, but to evaluate f, it still needs to evaluate h first.
09:07:02 <Cale> Not necessarily.
09:07:04 <fasta> Cale: not in all cases, I know.
09:07:05 <EvilTerran> monadic programming is kinda imperative, regardless of which monad you're using; it's just monads are a serious generalisation of what we mean by "side-effect" and "sequence"
09:07:19 <Cale> It starts with the body of f, and only gets to g when f uses its parameter.
09:07:22 <idnar> ski: all monads, or just IO?
09:07:39 <artagnon> hzap: Yeah? Ok, I'll have a look at the list monad then.
09:07:40 <ski> idnar : all monads, of course
09:08:35 <hzap> artagnon: it's a monad for brute force search, which works well in some of the problems
09:08:36 <ski> state, exception, output, environment, nondeterminism, continuation, et.c.
09:08:38 <idnar> I wish I could do that
09:08:59 <idnar> then maybe sequence would make more sense to me in most monads
09:09:00 <Daimonic> @src concat
09:09:00 <lambdabot> concat = foldr (++) []
09:09:41 <artagnon> hzap: Ok, I'll have a look.
09:11:20 <CrazyAzrael> Another fun one is the Q monad, but I've only managed to find it twice, and it's kind of unstable.
09:11:29 <CrazyAzrael> (It's a monad for doing simulated quantum computation)
09:11:34 <artagnon> !
09:11:47 <CrazyAzrael> Maybe it was called QIO/
09:12:04 <lilac> idnar: it's easy. monads are like pieces of string with hoops on, or space suits, or a burrito
09:12:19 <Axman6> yeah it's QIO
09:12:20 <fasta> CrazyAzrael: yes, that was a cool paper.
09:12:30 <lilac> and sequence ties the space suits to the burrito with the string.
09:12:33 <CrazyAzrael> Whee, it's the first hit on google now for QIO monad.
09:13:03 <tkr> this is very, very annoying to try to get working on a Windows box. maybe I will just give up for today.
09:13:21 <CrazyAzrael> tkr: have you tried installing the zip archives I pointed you at?
09:13:26 <tkr> tried to msys/mingw way, but it doesnt seem to install gcc for me so I could compile freeglut.
09:13:27 <CrazyAzrael> Which contain the files that your computer is missing?
09:14:22 <tkr> CrazyAzrael: can I use the windows 95 or NT version?
09:14:29 <tkr> CrazyAzrael: (no, I didnt try)
09:14:35 <CrazyAzrael> Click that link, and you'll fined it describes Windows XP as well.
09:15:10 <tkr> CrazyAzrael: this link http://www.opengl.org/resources/libraries/glut/glut_downloads.php ? Cant seem to spot XP there.
09:15:18 <SamB_XP> tkr: also, XP is an NT
09:15:36 <Axman6> ?v
09:15:36 <lambdabot> Just 'J'
09:15:38 <Axman6> ?v
09:15:38 <lambdabot> "\"#$%&'()*+,\""
09:15:40 <CrazyAzrael> On that page, click "GLUT for Microsoft..."
09:15:41 <Axman6> ?v
09:15:41 <lambdabot> "\""
09:15:45 <Axman6> o.O
09:15:45 <CrazyAzrael> This will take you down the document
09:16:02 <tkr> SamB_XP, CrazyAzrael, ok thanks. Ill try that.
09:16:06 <CrazyAzrael> You will see a section labelled "GLUT for Microsoft Windows... & XP users"
09:25:46 <RyanT5000> is there a monad that does coroutine-like behavior?
09:25:55 <RyanT5000> (is that even a sensible idea?)
09:26:24 <lilac> RyanT5000: yeah, there are monads like that
09:26:28 <fasta> RyanT5000: you can build one on top of ContT
09:26:36 <quicksilver> tkr: according to my source, GLUT32.DLL comes with the platform, just not in the right directory
09:26:38 <RyanT5000> yeah, i figured ContT might be involved
09:26:44 <lilac> you can build /any/ monad on top of Cont :)
09:26:45 <RyanT5000> is there any way to serialize continuations?
09:26:57 <quicksilver> no.
09:27:00 <RyanT5000> :(
09:27:03 <quicksilver> haskell has no support for serialising lambdas.
09:27:07 <quicksilver> (which is what continuations are)
09:27:15 <lilac> RyanT5000: if you used Arrows instead, then maybe
09:27:22 <RyanT5000> hm
09:27:22 <lilac> is 'arr' still in the Arrow type class?
09:27:33 <RyanT5000> i'm interested in making an AI agent DSL
09:27:34 <pikhq> :t arr
09:27:36 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:27:41 <lilac> hmm, yes. alas.
09:27:41 <RyanT5000> and i need to be able to serialize inactive agents
09:27:43 <pikhq> I think "yes".
09:27:45 <fasta> RyanT5000: bingo!
09:27:53 <RyanT5000> and then reconstitute them whenever they're sent a message
09:28:02 <quicksilver> RyanT5000: construct your agents as data, or from data, and its easy.
09:28:13 <quicksilver> if you want your agents to actually be functions, then it's hard.
09:28:24 <quicksilver> although people have solved the function serioalisation problem before
09:28:31 <quicksilver> at least twice in haskell IIRC
09:28:31 <RyanT5000> well, the agents will be Yampa signal functions
09:28:36 <RyanT5000> oh really?
09:28:40 <quicksilver> there's not a current solution for current haskells.
09:28:51 <quicksilver> yes, google for "glasgow distributed haskell"
09:29:00 <quicksilver> for a long-dead long-rotted proect
09:30:46 <Yrogirg> Hello, are there any ubuntu/debian repositories with always fresh GHC?
09:30:56 <RyanT5000> ah, ok
09:31:11 <RyanT5000> well, i'm interested in a solution of the ... stopgap variety :P
09:31:17 <tkr> quicksilver, SamB_XP, CrazyAzrael, and other: thanks a bunch. its finally working. I go the glut32.dll from the web page you mentioned and copied to to \windows\system32
09:31:29 <RyanT5000> basically, i want it to be easy to program stateful AIs, but i need to be able to get them out of RAM whenever they're inactive
09:31:46 <lilac> Yrogirg: i don't think so. but debian and ubuntu's bleeding edge repos both have 6.10.4 in them at the moment
09:32:42 <SamB_XP> RyanT5000: I think there was interest in doing this in YHC
09:32:48 <quicksilver> RyanT5000: design them as data.
09:32:54 <quicksilver> SamB_XP: I think YHC has it.
09:33:07 <SamB_XP> quicksilver: ah, even better
09:33:08 <quicksilver> SamB_XP: (unless it's slightly bitrotted)
09:33:11 <RyanT5000> quicksilver: yeah, i suppose i'll need to; it's just not always as intuitive
09:33:16 <SamB_XP> I wasn't sure how far/bitrotted it was
09:33:21 <iddo> how to get the first string of getArgs ?
09:33:31 <quicksilver> malcolmw__: the ability to serialise a lambda to bytecode still exists in yhc?
09:33:35 <RyanT5000> on a related topic, is there any way to retrieve the state of a yampa circuit?
09:33:43 <quicksilver> iddo: head <$> getArgs
09:33:56 <RyanT5000> the loop combinator seems to completely hide some state
09:34:05 <malcolmw__> quicksilver: it has not been removed, to my knowledge :-)
09:34:18 <malcolmw__> quicksilver: although building yhc might be an adventure
09:34:22 <quicksilver> RyanT5000: a good solution for persistance of functions would be a lovely thing to have.
09:34:36 <quicksilver> RyanT5000: although serialisation does break referential transparency of course.
09:34:44 <artagnon> My solution to this problem [ http://projecteuler.net/index.php?section=problems&id=14 ] stack overflows, even when compiled :( Can someone hint me as to why it happens? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8144#a8144
09:34:47 <RyanT5000> quicksilver: of course
09:34:48 <iddo> < iddo> > head <$> ["3", "4"]
09:34:54 <iddo> < lambdabot>   "34"
09:35:07 <iddo> shouldnt it return "3" ?
09:35:11 <RyanT5000> quicksilver: well, iPwn studios will get on that problem as soon as we have some money :P
09:35:12 <RyanT5000> (that's my game company)
09:35:27 <RyanT5000> iddo: i think it's using the list monad, there
09:35:53 <iddo> i dont understand
09:36:09 <artagnon> The GC should clean up all the unnecessary parts
09:36:17 <artagnon> I'm guessing something's not getting GC'ed
09:36:24 <artagnon> which is what's resulting in the stack overflow
09:36:30 <quicksilver> iddo: no, because getArgs isn't a list.
09:36:31 <RyanT5000> > head <$> Just ["3", "4"]
09:36:32 <iddo> why not just head ["3", "4"] ?
09:36:33 <lambdabot>   Just "3"
09:36:38 <quicksilver> :t getArgs
09:36:39 <lambdabot> Not in scope: `getArgs'
09:36:44 <quicksilver> @hoogle getArgs
09:36:45 <lambdabot> System.Environment getArgs :: IO [String]
09:36:49 <quicksilver> getArgs is an IO [String].
09:36:51 <Daimonic> @src min
09:36:52 <lambdabot> min x y = if x <= y then x else y
09:37:07 <quicksilver> if getArgs *was* just a list, then (head getArgs) would have been the right answer.
09:37:09 <msteele_> artagnon: I believe maximum is lazy.  It's building up an entire list of thunks before actually running through it to find the largest number.
09:37:09 <iddo> why is <$> needed ?
09:37:13 <quicksilver> since getArgs is an IO list, you use <$>
09:37:31 <artagnon> msteele_: OMG. That's terrible. What should I do?
09:37:44 <quicksilver> @hoogle maximum
09:37:45 <lambdabot> Prelude maximum :: Ord a => [a] -> a
09:37:45 <lambdabot> Data.ByteString maximum :: ByteString -> Word8
09:37:45 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
09:37:49 <artagnon> is there a non-lazy version of maximum?
09:37:50 <quicksilver> is there a maximum' ?
09:38:00 <Deewiant> foldl1' max
09:38:07 <Saizan> ?src maximum
09:38:07 <lambdabot> maximum [] = undefined
09:38:07 <lambdabot> maximum xs = foldl1 max xs
09:38:14 * quicksilver nods
09:38:30 <artagnon> Deewiant: One sec, let me try that.
09:38:52 <Saizan> heh, it's not a list of thunks, but a thunk of the size of the list :)
09:39:16 <artagnon> Deewiant: Where's foldl1' defined?
09:39:27 <Deewiant> ?index foldl1'
09:39:28 <lambdabot> Data.List
09:39:36 <msteele_> Saizan: Isn't each element of that list a thunk for n_series?
09:40:05 <pikhq> @src foldl1
09:40:06 <lambdabot> foldl1 f (x:xs) = foldl f x xs
09:40:06 <lambdabot> foldl1 _ []     = undefined
09:40:19 <pikhq> I wonder why maximum [] is explicitly undefined?
09:40:48 <Deewiant> So that it can say "maximum: empty list" instead of "foldl1: empty list"
09:41:07 <pikhq> Fair enough.
09:41:14 <Saizan> msteele_: but that's not what's overflowing, it overflows because it tries to follow the deep-nested chain of max calls
09:42:49 * artagnon is computing
09:43:05 <artagnon> but I don't think it'll finish under a minute :(
09:43:38 <artagnon> hey, 30 seconds :)
09:45:03 <iddo> i get "not in scope <$>" when i have: head <$> getArgs
09:45:25 <jeffwheeler> @hoogle <$>
09:45:25 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:45:32 <iddo> if i have "args <- getArgs" then it works ok with: head args
09:45:35 <artagnon> Deewiant: Thanks! :)
09:46:02 <jeffwheeler> iddo: you need to import it from Control.Applicative
09:46:31 <jeffwheeler> @users
09:46:32 <lambdabot> Maximum users seen in #haskell: 658, currently: 601 (91.3%), active: 20 (3.3%)
09:46:33 <Deewiant> Or just use fmap instead
09:46:50 <iddo> what is <$> ? how come it works ok without it when i first do args <- getArgs ?
09:47:06 <tkr> hmm.. this is very nice that it's (haskell+opengl+glut) working on my home XP box. thank you a bunch everyone.
09:47:19 <iddo> i'm trying to understand whats the correct way...
09:47:24 <Botje> iddo: <$> takes a pure function (a -> b) and an IO a, and produces an IO b
09:47:26 <jeffwheeler> iddo: <$> is just an infix function; with the first version, you're not calling that function
09:48:20 <tkr> anyone know about drawing a grid in memory, applying a transformation it and outputting before and after results? or should I just modify the surface Im plotting on and use the same co-ordinates?
09:48:40 <iddo> well i guess in need to understand haskell better before i understand what u just said:)
09:48:40 <pikhq> It takes a function of (a -> b), and results in a function from (f a -> f b), where f is a functor.
09:48:47 <pikhq> (as it just so happens, IO is a functor)
09:49:13 <SamB_XP> hey, where's a short and sweet SPL?
09:49:25 <iddo> how come it works ok without <$> when i first do args <- getArgs ?
09:49:45 <quicksilver> iddo: because "args" is now a list
09:49:50 <quicksilver> iddo: "getArgs" was an IO list
09:49:50 <pikhq> iddo: That's because you're binding a name to the result of getArgs.
09:49:53 <quicksilver> iddo: but "args" is just a list
09:50:00 <quicksilver> iddo: that's what the <- syntax does
09:50:09 <quicksilver> it 'executes' the IO part and gives you the result.
09:50:12 <iddo> ok
09:50:53 <iddo> so doing it with <$> is better? i just want to concat the first arg to another string i already have
09:50:59 <pikhq> So, "args <- getArgs; head args" is just the same as "head <$> getArgs".
09:51:09 <seydar> greetings, fellow monders
09:51:11 <iddo> ok
09:51:13 <seydar> monaders*
09:51:22 <pikhq> Doing it with <$> is *sometimes* is better.
09:51:40 <pikhq> Remove ones of those "is"s.
09:51:59 <iddo> can i import just <$> from Control.Applicative ? how ?
09:52:17 <mkaemmer> "import Control.Applicative"
09:52:28 <mkaemmer> or "import Control.Applicative (<$>)"
09:52:35 <iddo> cool
09:52:46 <pikhq> You may find the other functions in Control.Applicative useful.
09:52:59 <pikhq> (applicative functors are quite handy)
09:53:05 <iddo> there is no syntax to do something like Control.Applicative.<$> without import ?
09:53:48 <Twey> `fmap`
09:54:06 <pikhq> @src (<$>)
09:54:07 <lambdabot> f <$> a = fmap f a
09:54:28 <Twey> fmap is in the standard Prelude.
09:55:00 <iddo> u mean i can use fmap instead of <$> ?
09:55:05 <pikhq> Yeah.
09:55:06 <Twey> <$> was just defined because it's easierâ€¦ or because it makes it clear that you're dealing with an applicative functorâ€¦ or something
09:55:19 <Twey> They're equivalent in type and definition.
09:55:25 <artagnon> Ouch! I'm finding the maximum of n_series_len of the list; How do I transform this to find the element in the list that produces this maximum? HINT only, please.
09:55:27 <burp> or to confuse ;)
09:55:28 <artagnon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8144#a8148
09:55:32 <Twey> :t (fmap, (<$>))
09:55:33 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
09:55:38 <Berengal> <$> makes sense when dealing with applicative functors, and it sort of resembles the syntax in the paper...
09:55:47 <iddo> so i can just do: fmap head getArgs  ?
09:55:49 <Berengal> makes sense syntactically*
09:55:51 <Twey> iddo: Yes
09:55:57 <iddo> ok cool
09:56:00 <Twey> arg <- fmap head getArgs
09:56:11 <Twey> Or, arg <- head `fmap` getArgs
09:56:25 <artagnon> or cutting out the irrelevant parts: foldl1' (max) $ map n_series_len [2, 3 .. 1000000] -- I want to find the series in the list that produces the maximum. Hint ONLY please.
09:56:30 <Twey> Though note that head is unsafe, so that will explode if you don't have any arguments passed to the program.
09:56:35 <Berengal> Or, (arg:_) <- getArgs
09:56:43 <Twey> That works too.  :)
09:57:16 <Berengal> Pattern matching will arguably "explode less"
09:57:21 <RayNbow> :t evilAffine
09:57:22 <lambdabot> Not in scope: `evilAffine'
09:57:28 <Twey> Berengal: How so?
09:57:32 <Twey> It's a pattern match failure either way
09:57:39 <Twey> head gives you a helpful message, though.
09:57:47 <Berengal> Twey, fail, not error, which may be better
09:57:52 <RayNbow> ski, what was that evilAffine? :p
09:57:55 <poe> artagnon: foldl1' somethingelsethanmaxwichreturnsboththevalueandtheindex
09:57:56 <Twey> Ah, point
09:58:00 <iddo> i need "str" ++ fmap head getArgs
09:58:17 <Twey> iddo: And?
09:58:32 <iddo> was wondering if the last example can work?
09:58:38 <iddo> (arg:_) <- getArgs
09:58:41 <Twey> (you don't need that, by the way â€” that's concatenating a string with an IO action, which makes no sense)
09:58:47 <poe> artagnon: also no more foldl1' but you need foldl' f (0,0) $ .. or something.
09:58:51 <artagnon> poe: Yeah, I could put that in a tuple and do that.
09:58:59 <Deewiant> fmap (("str"++) . head) getArgs
09:58:59 <iddo> oh
09:59:01 <artagnon> but that's not elegant
09:59:05 <artagnon> I want a more elegant way
09:59:17 <Twey> (arg : _) <- getArgs puts the last argument in arg; from there, you can do what you like with it
09:59:23 <RayNbow> @seen ski
09:59:23 <Twey> Er, the first argument
09:59:23 <lambdabot> ski is in #haskell, #haskell.hr, ##logic and #haskell.se. I last heard ski speak 50m 47s ago.
10:00:30 <artagnon> It should be possible with a filter, no? Problem reduced: To find the list element which produces this maximum -- maximum . map (moo) $ list
10:00:31 <iddo> so how come it compiles ok when i do: "str" ++ fmap head getArgs
10:01:11 <Twey> iddo: It doesn't â€” you're doing something wrong
10:01:45 <iddo> hmm
10:02:08 <Twey> (++ only works on lists)
10:02:37 <Twey> You can fmap it into the IO action as Deewiant said, or use <- to â€˜unpackâ€™ the value of the IO action and use it on that
10:02:45 <Twey> You can also use view patterns
10:02:56 <artagnon> What I just thought of: filter (\x -> map moo x == maximum . map (moo) $ x) list -- More elegant solution possible?
10:03:13 <Twey> ((("str" ++) -> arg) : _) <- getArgs
10:03:14 <artagnon> ouch, no
10:03:38 <iddo> yes what i tried didnt work it seems
10:03:40 <mkaemmer> huh... a lot of people have been suggesting "x <- fmap f IOAction"
10:03:46 <mkaemmer> I realize it works fine
10:03:52 <poe> artagnon: maximumBy (comparing n_series_list)
10:03:59 <mkaemmer> but I usually find "x <- liftM f IOAction" more readable
10:04:01 <Twey> artagnon: I've no idea what you're trying to do and, given that it's a Euler problem, probably couldn't solve it anyway, but you don't need the brackets around moo.  ;)
10:04:15 <Twey> @src liftM
10:04:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:04:24 <artagnon> Twey: lol
10:04:37 <artagnon> poe: awesome, let me try that
10:04:50 <badsheepy> you can just make your list into a list of smaller lists..
10:04:53 <Twey> mkaemmer: Strictly, I believe, all monads ought to be applicative functors, so fmap should be the standard way of lifting a function into them
10:05:02 <iddo> (arg:_) <- getArgs  gives the first or last arg?
10:05:03 <Twey> That's unfortunately not true
10:05:12 <Twey> But still, fmap is in the Prelude and liftM isn't :)
10:05:14 <Twey> iddo: First
10:05:39 <iddo> ok cool, so i'll just use (arg:_) <- getArgs
10:05:41 <Twey> As indicated by the fact that it's on the left of the operator
10:05:54 <glguy> liftM* shouldn't exist
10:06:01 <glguy> we have fmap and liftA2+
10:06:06 <mkaemmer> Twey: true. It does have that advantage.
10:06:17 <iddo> (_:arg) <- getArgs  would give last arg?
10:06:22 <mkaemmer> okay, note to self: liftM is deprecated
10:06:25 <Berengal> Is (x:[y]) a valid pattern?
10:06:33 <Twey> Berengal: Yes
10:06:39 <Twey> Although it's prettier as [x, y]
10:06:44 <Berengal> nifty...
10:06:49 <Berengal> And yes, [x, y] is better
10:06:54 <Twey> iddo: No, it wouldn't
10:07:00 <RyanT5000> are there any Yampa experts in here?
10:07:08 <artagnon> poe: I don't know how to produce an ordering :(
10:07:08 <mkaemmer> iddo: that's all args but the first
10:07:17 <Twey> iddo: Since the list is of arbitrary length, something patterns don't handle, you'd have to call a recursive function to get the last one.
10:07:24 <Twey> Like the aptly-named â€˜lastâ€™.
10:07:29 <artagnon> a -> a -> Ordering
10:07:29 <iddo> ok
10:07:32 <Twey> (last -> arg)
10:07:34 <Berengal> (last -> arg) <- getArgs
10:07:35 <artagnon> how do I write a function that does this?
10:07:38 <Twey> Right :)
10:07:47 <Twey> artagnon: Looks like â€˜compareâ€™ to me.
10:08:05 <Twey> :t compare
10:08:06 <glguy> case xs of [x] -> x; [_,x] -> x; [_,_,x] -> x
10:08:07 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:08:07 <glguy> ...
10:08:13 <glguy> (just keep typing)
10:08:15 <Twey> glguy: *wince*
10:08:17 <Twey> Haha
10:08:20 <Berengal> I wish -> would bind tighter than <- so you could write 'foo -> x <- bar'
10:08:22 <artagnon> Twey: Right. Thanks
10:08:28 <Twey> You can also do it with that regex-pattern extension
10:08:43 <Twey> What's it called?  hregex or something?
10:08:48 <Berengal> RE patterns are a proper extension?
10:08:48 <glguy> Berengal: are you trying your hand at ASCII art?
10:08:50 <Twey> Berengal: That's visually confusing to me
10:09:01 <artagnon> poe: I have no idea how to implement your solution. Sorry :'(
10:09:11 <mkaemmer> artagnon: if 'compare' isn't flexible enough, you can write a functoin that returns "GT" or "LT" or "EQ"
10:09:17 <Twey> Berengal: I can't remember what it's calledâ€¦ the one that guy used for HSP
10:09:21 <Twey> Oh!  HaRP, that was it
10:09:21 <Berengal> Twey, you can't have enough confusion in a language. It's what allows us to express ourselves
10:09:27 <Twey> Berengal: Heh
10:09:35 <artagnon> mkaemmer: Right. Got it.
10:09:46 <Berengal> Twey, yeah, I read about it in the HSP paper. HSP is however just a preprocessor (I should really make it into a qq)
10:09:58 <Twey> Although I suppose it's pretty cool-looking if you think of it as two things acting on the variable from the pure/impure sides
10:10:01 <poe> artagnon: I think that was it.
10:10:12 <Twey> Berengal: Yeah, HaRP is a preprocessor too
10:10:16 <Berengal> :(
10:10:26 <Berengal> Still, should be qqable
10:10:26 <artagnon> poe: Not in scope: comparing
10:10:29 <Twey> But GHC allows easy insertion of preprocessors, so *shrug*
10:10:33 <bos> @seen dons
10:10:34 <lambdabot> dons is in #haskell-in-depth, #haskell, #ghc, #xmonad, #darcs, #concatenative, #arch-haskell and #yi. I last heard dons speak 12h 7m 41s ago.
10:10:36 <Twey> Berengal: I don't know
10:10:39 <twanvl> maybe view patterns should have been (pat <- fun) instead of (fun -> pat), then you could write x <- foo <- bar
10:10:40 <Twey> Can you qq to get a pattern?
10:10:44 <poe> ?index comparing
10:10:46 <lambdabot> bzzt
10:10:50 <Twey> twanvl: That'd work
10:11:15 <artagnon> Anyone can tell me how to get the list element corresponding to this maximum? -- maximum . map moo $ list
10:11:17 <poe> import Data.Ort (comparing) -- artagnon
10:11:22 <poe> *Ord
10:11:26 <artagnon> poe: Ah.
10:11:27 <Berengal> Twey, 'let [$rep| (foo,bar)*|] = assocList' ?
10:11:28 <artagnon> Let me try that
10:11:31 <Twey> @src
10:11:32 <lambdabot> src <id>. Display the implementation of a standard function
10:11:41 <Twey> Er
10:11:43 <Twey> o.@
10:11:45 <Twey> @src comparing
10:11:46 <lambdabot> Source not found. Do you think like you type?
10:11:50 <Twey> Berengal: Are you allowed to do that?
10:11:54 <Twey> @src compare
10:11:54 <mkaemmer> @type maximumBy
10:11:55 <Berengal> Twey, yes, you can use qqs in patterns. They run a different qq/parser/whatever
10:11:55 <lambdabot> compare x y | x == y    = EQ
10:11:55 <lambdabot>             | x <= y    = LT
10:11:55 <lambdabot>             | otherwise = GT
10:11:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:12:03 <Twey> Berengal: Oh, cool.
10:12:16 <Twey> Then yeah.  QQ away.  â˜º
10:12:17 <Berengal> A qq consists of one expression parser and one pattern parser
10:12:55 <poe> @type maximumBy (comparing (undefined :: Int -> Int))
10:12:57 <lambdabot> [Int] -> Int
10:13:07 <Berengal> Unfortunately, I don't really know much about TH...
10:13:15 <artagnon> poe: Sorry, maximumBy is lazy. Program segfaults. I need to use foldl1' (max)
10:13:18 <artagnon> instead
10:13:38 <mkaemmer> @src maximumBy
10:13:39 <lambdabot> Source not found. stty: unknown mode: doofus
10:14:03 <Trinithis> :t par
10:14:05 <lambdabot> forall a b. a -> b -> b
10:19:50 <artagnon> Ok, problem reduced even further: I have a list [(x, f x)] -> I need to find the x corresponding to foldl1' max of f x
10:20:21 * artagnon sighs
10:20:48 <artagnon> Why can't I get this imperative looping out of my head?!
10:21:39 <bos> @seen dcoutts
10:21:40 <soupdragon> need to find the x corresponding to foldl1' max of f x ??
10:21:40 <lambdabot> dcoutts is in #haskell-overflow, #haskell-in-depth, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-iphone and #haskell-soc. I last heard dcoutts speak 13m 23s ago.
10:21:44 <soupdragon> that doesn't make sense
10:21:51 <dcoutts> hia bos
10:21:59 <artagnon> soupdragon: It doesn't?
10:22:01 <bos> dcoutts: is there a way to ask cabal-install what dependencies it's missing for building something?
10:22:02 <Asztal> "foldl1' (maxBy (comparing snd))" then?
10:22:03 <soupdragon> to me
10:22:15 <RyanT5000> artagnon: try to think about what the thing you want *is*, not *how* to produce it
10:22:34 <dcoutts> bos: you mean in a programatic way or some kind of shell scripting kind of way?
10:22:36 <RyanT5000> (that's how i broke out of my loopy thought patterns :P)
10:22:43 <Asztal> :t max `on` snd
10:22:44 <artagnon> Asztal: Ah, finally. that's the substitute of maximumBy
10:22:44 <bos> dcoutts: from the command line
10:22:45 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> b
10:22:47 <artagnon> the non-lazy one
10:22:56 <artagnon> RyanT5000: Yeah, I'm finding it hard. Very.
10:23:10 <monochrom> You need a virtual machine for your mind :)
10:23:20 <dcoutts> bos: not in a convenient machine readable way. You can configure and see what deps it complains about, but it means greping the error message.
10:23:40 <RyanT5000> artagnon: that's how you can tell you're learning :)
10:23:48 <dcoutts> bos: or you could install --dry and see what it says it's going to (re)install
10:24:03 <dcoutts> bos: though that can also fail
10:24:05 <artagnon> soupdragon: It's like this: foldl1' max . moo operates on a list. I need to find the element in the list corresponding to the value foldl1' max . moo returns
10:24:24 <soupdragon> sorry
10:24:29 <soupdragon> maybe I am so tired
10:24:38 <artagnon> soupdragon: It still doesn't make sense?!
10:25:33 <artagnon> Ok. I'll try with a concrete example: foldl1' max . moo $ list --> 525. Which element in the list got mapped to find this maximum?
10:25:38 <msteele_> artagnon: It makes sense to me now.  I suggest zipping your list up with consecutive numbers before scanning through them.
10:25:50 <soupdragon> artagnon,
10:25:57 <soupdragon> unmoo (foldl1' max . moo $ list)
10:26:08 <soupdragon> without actually having an unmoo function?
10:26:25 <artagnon> yes!
10:26:28 <artagnon> yes!
10:26:30 <soupdragon> hehe
10:26:34 <artagnon> exactly.
10:26:43 <soupdragon> well lets simplify it
10:26:48 <soupdragon> maximum = foldl1' max
10:26:49 <artagnon> it took me SO long to describe this.
10:26:55 <artagnon> ok
10:27:04 <soupdragon> unMoo (maximum . moo $ list)
10:27:12 <dcoutts> bos: of course one could write a fairly short program to do it
10:27:17 <soupdragon> but is  moo = map moo'  ?
10:27:24 <soupdragon> for some moo'
10:27:27 <artagnon> msteele_: I wanted a more elegant solution
10:27:33 <monochrom> @type maximumBy
10:27:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:27:39 <artagnon> soupdragon: Yes
10:27:44 <soupdragon> so we have,
10:27:44 <monochrom> @type compare
10:27:47 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:27:47 <artagnon> soupdragon: It is a mapping function
10:27:51 <soupdragon> unMoo (maximum . map moo' $ list)
10:28:06 <artagnon> correct.
10:28:07 <soupdragon> that can be  maximumBy moo' list
10:28:10 <soupdragon> well
10:28:14 <soupdragon> (comparing moo')
10:28:42 <artagnon> Let's say I didn't want to maximize it. I wanted to fooify it. I want a more general solution.
10:28:56 <soupdragon> fooBy moo' list
10:29:06 <monochrom> maximumBy (\(x,y) (a,b) -> compare y b) (zip list (map moo list))
10:29:13 <artagnon> Not in context: fooBy
10:29:23 <bos> dcoutts: do you have the ability to edit the main platform page on hackage.haskell.org?
10:29:27 <soupdragon> ?
10:29:34 <monochrom> Oh I guess I can simplify it.
10:29:41 <artagnon> soupdragon: I have to define a fooBy, right?
10:29:46 <artagnon> after defining a foo
10:29:46 <soupdragon> yes
10:29:51 <dcoutts> bos: probably not, lemme check
10:29:59 <artagnon> soupdragon: Any other way?
10:30:01 <monochrom> maximumBy (\x y -> compare (moo x) (moo y)) list
10:30:06 <soupdragon> no
10:30:24 <artagnon> monochrom: Yeah, I got that. Only issue is that maximumBy is lazy.
10:30:37 <bos> dcoutts: ok, i'll nudge dons
10:30:38 <seydar> comrade`phil: argh matey
10:30:46 <artagnon> foldl1' (maxBy (comparing snd)) << correct solution
10:30:48 <dcoutts> bos: oh, looks like I can
10:30:49 <monochrom> Steal maximizeBy's source code and write a non-lazy version.
10:30:58 <artagnon> soupdragon: Damn :|
10:31:02 <bos> dcoutts: oh, cool.
10:31:05 <soupdragon> why is that bad?
10:31:06 <artagnon> monochrom: ;)
10:31:25 <monochrom> @type maxBy
10:31:28 <lambdabot> Not in scope: `maxBy'
10:31:36 <artagnon> soupdragon: Because I just wrote foo. Now I have to write fooBy also.
10:31:45 <monochrom> But I guess maxBy is easy.
10:31:47 <artagnon> oh shite. Doesn't maxBy exist?
10:32:17 <artagnon> @type maximumBy
10:32:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:32:23 <bos> dcoutts: just fired you and don an email to ask for an edit
10:32:37 <dons> bos: thanks
10:32:39 <dons> fixing now.
10:32:53 <bos> fedora is about 95% of the way to supporting the currently haskell platform release.
10:32:58 <dons> woo!
10:33:00 <bos> we just lack a couple of packages.
10:33:02 <Nafai> Nice!
10:33:10 * bos is writing up packaging requests for those right now.
10:33:19 <Nafai> I should try the latest platform release on my system sometime soon
10:33:24 <comrade`phil> [19:30] <seydar> comrade`phil: argh matey
10:33:28 <comrade`phil> Arrr, Pirates
10:33:37 <bos> yeah, we've got a better haskell hacking setup than anything other than arch linux.
10:34:18 <dcoutts> bos: ohh, sorry I misunderstood, you mean the platform page not the hackage.haskell.org top page.
10:34:20 <dons> you should write an article summarising all this
10:34:32 <dcoutts> bos: seems dons left off the g+w bit on those files
10:34:44 <dons> dcoutts: they're generated
10:34:46 <Nafai> I should help the Debian Haskell team, and thereby the Ubuntu project so we're up to date :(
10:34:59 <bos> friendly competition! :-)
10:35:04 <dons> done
10:35:10 <bos> thanks dons
10:35:19 <bos> dcoutts: shock! you mean it's not a darcs repo?
10:35:29 <dons> its a darcs repo, holding pandoc markdown files
10:35:41 <dons> but the publish mechanism is : pandoc ; scp
10:36:07 <dons> great work. the list of supported distros is filling out nicely
10:36:29 <dcoutts> dons: right, I can't do the upload bit I think due to perms. I'm in the hackage group but those files are g-w
10:36:36 <dons> ok
10:36:54 <zloog> does the block function prevent preemptive suspending in my thread?
10:37:37 <Cale> zloog: hm?
10:38:00 <dons> there's extensive documentation in Control.Exception
10:38:27 <zloog> Cale: Well im just trying to read the source for modifyMVar to see how it works. I assume it has to or else there would be a race condition between the take and the put
10:38:45 <dons> -- | Applying 'block' to a computation will
10:38:45 <dons> -- execute that computation with asynchronous exceptions
10:38:45 <dons> -- /blocked/.  That is, any thread which
10:38:45 <dons> -- attempts to raise an exception in the current thread with 'Control.Exception.throwTo' will be
10:38:49 <dons> -- blocked until asynchronous exceptions are enabled again.
10:39:37 <zloog> dons: yes but im not quote sure what an asynchronous exception is. Are they explained anywhere in the docs?
10:39:51 <Cale> zloog: It's possible to throw an exception to another thread.
10:40:15 <dons> in Control.Exception. but you are better off reading say, RWH first, before tackling how MVar works :)
10:40:20 <PeakerWork> zloog: basically anything thrown to a thread with throwTo. thread killing is an asynchronous kill exception
10:40:53 <zloog> Cale: well i guess what im trying to say is that how can modifyMVar be safe. That is, what prevents execution from being suspended between the take and the put? http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Concurrent-MVar.html#modifyMVar
10:41:23 <dons> zloog: block
10:41:48 <Cale> zloog: which will cause the thread to stop whatever it was doing and whatever exception handler is available (if any) will catch the exception, otherwise the thread dies. The block just prevents the case from happening where you throw an exception to a thread which is in the middle of modifyMVar and the take has happened but not the put.
10:41:50 <PeakerWork> dons: the block you described above?  Not a mutex?
10:42:01 <dons> modifyMVar m io =
10:42:01 <dons>   block $ do
10:42:01 <dons>     a      <- takeMVar m
10:42:01 <dons>     (a',b) <- unblock (io a) `onException` putMVar m a
10:42:01 <dons>     putMVar m a'
10:42:03 <dons>     return b
10:42:09 <zloog> dons: and this also prevents other threads from using the MVars within a block statement?
10:42:28 <Cale> zloog: No. Other threads can use the MVar.
10:42:54 <dons> no. those threads can use the MVar in the regular way.
10:42:57 <dons> i.e blocking on a full put, or blocking on an empty take
10:42:58 <zloog> Cale: so the code can be suspended within the modifyMVar function?
10:43:00 <PeakerWork> dons: so modifyMVar may block not only until there's something to take, but then also until there's emptiness to put in it
10:43:03 <Cale> zloog: yes
10:43:21 <Cale> zloog: If by suspended you mean that another thread is running concurrently.
10:43:48 <dons> yes, you can forget about exceptions in this setting. just look at the MVar semantics
10:43:50 <zloog> Cale: Ok, for some reason i thought the behavior was different. But that should be all i need to get what i want done.
10:44:00 <Cale> zloog: Other threads which try to read the MVar once it is emptied will block though.
10:44:46 <zloog> Cale: I was more concerned about writes
10:44:47 <Cale> zloog: and it's possible that modifyMVar gets to take the MVar, and then another thread fills it, and the modifyMVar ends up needing to wait until it's empty again before it can fill the MVar.
10:45:24 <Cale> If you need really precise control over things like this, you should use STM.
10:45:46 <dons> MVars are pretty easy. just remember that take blocks on empty, put blocks on full
10:46:13 <taruti> What would be the best implementation for sparse mutable bit matrixes in Haskell?
10:46:15 <zloog> Cale: Too much IO to do inside of these things. Thanks again though. I should be able to dream something up from what you've told me
10:46:25 <dons> taruti: i think there's some package on hackage
10:46:35 <Cale> zloog: Well, your STM transactions will be small
10:46:43 <artagnon> @source maximumBy
10:46:43 <dons> so s/best/you don't have much choice- see what's on hackage/
10:46:44 <lambdabot> maximumBy not available
10:46:57 <Cale> zloog: It's just that with STM, you could construct an MVar with a truly atomic modify
10:47:03 <artagnon> @src maximumBy
10:47:04 <dons> dcoutts: we need to patch the unix src tarball
10:47:04 <lambdabot> Source not found. You untyped fool!
10:47:28 <artagnon> What!? source not found?
10:47:32 * zloog is going to sit on the couch and reread the STM chapter in rwh
10:47:49 <artagnon> I need to write a maxBy corresponding to max, just lke maximumBy corresponds to maximum
10:47:58 <artagnon> @src max
10:47:59 <Cale> (In fact, you would only need to write one for TMVar)
10:48:00 <lambdabot> max x y = if x <= y then y else x
10:48:03 <dons> STM TVars are like MVars but they always suceed to put and take. Then the STM infrastructure coordinates the actual writes
10:48:19 <dons> meaning you don't have to worry about deadlock
10:48:53 <taruti> on Hackage there is hmatrix which looks very unsuitable
10:49:07 <dons> its a good dense matrix package
10:49:21 <dons> http://hackage.haskell.org/package/sparsebit ?
10:49:48 <dons> http://hackage.haskell.org/package/hmatrix-static is the high level interface to hmatrix
10:49:53 <Cale> Well, of course, in order to be atomic, the most complicated f that you could modify with would have to be (a -> STM a) rather than (a -> IO a)
10:49:53 <dcoutts> dons: I've got a patch but I've not had time to test it
10:50:05 <galdor> hi, I've a problem with monads
10:50:17 <galdor> I have a StateT monad
10:50:20 <dcoutts> dons: want me to push it now and let someone else test it properly?
10:50:25 <galdor> named Game
10:50:32 <dons> dcoutts: is it the patch that was submitted to the tracker?
10:50:41 <galdor> now in a function running in the Game monad, I'd like to run forkIO
10:50:42 <dons> i can test it, since I think I can reproduce the  problem
10:50:44 <galdor> so I use liftIO
10:50:44 <dcoutts> dons: no, one I wrote after hitting the problem
10:50:51 <galdor> but forkIO takes a IO () function
10:50:53 <dons> ok. did you see the submitted patch?
10:50:53 <taruti> sparsebit is not mutable
10:50:57 <Cale> galdor: right
10:51:01 <dcoutts> dons: I'll take a look at it
10:51:01 <galdor> is there a way to tell forkIO to take a Game () function ?
10:51:19 <galdor> I mean a function running in a monad whatever it's type
10:51:19 <taruti> and neither is hmatrix
10:51:22 <dons> taruti: http://hackage.haskell.org/package/HsJudy
10:51:25 <Cale> galdor: That almost doesn't make sense. Think about it a bit.
10:51:26 <dons> hmatrix has a mutable layer
10:51:47 <dons> taruti: it runs in the ST monad, and has both a pure and impure inteface
10:51:59 <Cale> galdor: How is it going to pass the state parameter through the new thread?
10:52:06 <dons> http://hackage.haskell.org/packages/archive/hmatrix-static/0.1/doc/html/Data-Packed-Static-ST.html taruti <-- mutable hmatrix
10:52:18 <galdor> don't know, that's why I'm asking :)
10:52:20 <dons> hsjudy has some sparse vectors, iirc
10:52:20 <Cale> galdor: It won't be able to collect the results of any state changes made in the second thread, will it?
10:52:29 <dcoutts> dons: I don't see the ticket with the patch, what # number?
10:52:33 <galdor> mhh you're quite right
10:52:38 <Cale> galdor: Besides, using StateT over IO is excessive.
10:52:38 <taruti> hmm, have to try that out.
10:52:39 <galdor> didn't event thought about his
10:52:50 <galdor> s/thought/think sorry
10:53:00 <lilac> galdor: in principle you could do it iff there's a way of 'running' Game () in the IO monad, but that means you have a function of type Game () -> IO a...
10:53:06 <Cale> galdor: IO already has IORefs which is like having infinitely many state parameters.
10:53:16 <Cale> galdor: and MVars/STM/etc.
10:53:28 <galdor> I think I understand
10:53:29 <Cale> galdor: and those all play nicely with threads
10:53:56 <galdor> but i'm stupid; my client handlers should only parse the incoming queries and queue them somewhere
10:54:04 <galdor> no need for the game state for this
10:54:07 <dons> dcoutts: http://trac.haskell.org/haskell-platform/ticket/84
10:54:36 <burp> foo has type ST s (STUArray s Int SomeData), how do I use mapArray with it.. like .. mapArray (\somedata -> somenewdata) foo ?
10:54:47 <galdor> thank you for your help!
10:54:59 <burp> or did I define foo's type wrong in first place?
10:55:07 <Cale> galdor: Usually ReaderT (IORef Foo) IO is way more convenient than StateT Foo IO
10:55:41 <galdor> aren't IORef kind of dirty, I mean they seem like a hack
10:55:55 <Cale> They're appropriate when they're appropriate.
10:56:16 <Cale> I would usually avoid them, but StateT-transforming the IO monad is no better.
10:56:18 <dons> they're a straight forward implementation of references, which are sometimes useful. I wouldn't say they are hacky.
10:56:19 <PeakerWork> Cale: why is it more convenient?
10:56:22 <dons> using them in the wrong place is hacky
10:56:27 <copumpkin> unsafeGlobalVariable = unsafePerformIO $ newIORef undefined
10:56:28 <galdor> by running the game in the Game monad and communicate with the client threads using Chan I should be ok
10:56:29 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
10:56:45 <Cale> PeakerWork: Well, there would be a clearer answer for how to lift forkIO here, for instance.
10:56:50 <PeakerWork> Cale: StateT transforming the IO monad is nicer, its still more structured than a reader of the IORef, because you can give the IORef to anyone, but the stateT's state is only manipulatable by the monadic actions
10:57:16 <PeakerWork> Cale: well, forkIO not being able to change the StateT's state is an advantage, not a disadvantage, IMO
10:57:21 <Cale> PeakerWork: That's true, but here it's what's creating the problem
10:57:25 <PeakerWork> at least, when you want that extra structure
10:57:42 <Cale> and since you're already in IO, everything is nuts anyway.
10:57:54 <PeakerWork> heh
11:00:55 <ksf> let's start a flamewar.
11:01:03 <ksf> is unicode syntax evil or a blessing?
11:01:31 <gnuvince> evil
11:01:52 <comrade`phil> I will take no part in this!
11:02:20 <CrazyAzrael> If there isn't a button for it on my keyboard, it shouldn't be used for syntax.
11:02:47 <CrazyAzrael> (Though if OLEDs become cheap enough, this will be irrelevant and I'll be all for it :P)
11:02:57 <mauke> conversely, if there is a button for it, the syntax should use it
11:03:03 <Philippa_> CrazyAzrael: even if there are available alternatives?
11:03:03 <mauke> (see also: perl)
11:03:05 <ksf> well I've given up yesterday on importing N from agda's Data.Nat.
11:03:12 <artagnon> Damn, after all this pain of writing maxBy, my program doesn't execute under 60 seconds now. Any tips to speed it up? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8150#a8150
11:03:13 <soupdragon> lol
11:03:21 <ksf> it turned out that I should've imported â„•.
11:03:23 <Philippa_> (eg you could allow both \ and an actual lambda)
11:03:28 <artagnon> ouch, sorry
11:03:39 <CrazyAzrael> Phillipa_: by available alternatives, do you mean alternative keyboards?
11:03:55 <CrazyAzrael> Phillipa_: My opinion is that the main method of coding should not require "special" gear of any sort.
11:04:03 <artagnon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8150#a8151 >> There
11:04:06 <artagnon> It's too slow
11:04:22 <Philippa_> CrazyAzrael: no, alternative lexemes
11:04:44 <Philippa_> C++ does that even within ASCII, for example
11:05:38 <ksf> btw, even though agda's library is unicode all the way down, they don't seem to have found a symbol for >> and >>=.
11:06:04 <CrazyAzrael> Philippa_: and almost every set of coding guidelines says that you aren't allowed to use them.
11:07:34 <CrazyAzrael> Phillipa_: The problem there that shows up is that everyone who does have the magical keyboard with a lambda button will be annoyed at you for using \, and the in any multi-person projects, the code either becomes nonuniform, or you end up degrading to old style.
11:08:07 <CrazyAzrael> (I really think this problem will eventually be solved by intelligent keyboard set switching, and the only real thing limiting that at the moment is that the keyboards for doing this are too expensive at the moment.)
11:08:51 <Philippa_> eh, there're still many, many symbols in use
11:09:15 <Philippa_> also: being able to type \ and have the editor or IDE change it for you would help
11:09:46 <CrazyAzrael> Philippa_: That's an option (leksah does that I think), but I don't think we have any stable IDEs at the moment.
11:12:52 <yitz> @seen Cale
11:12:53 <lambdabot> Cale is in #haskell, #haskell-overflow, #haskell-in-depth and #ghc. I last heard Cale speak 15m 10s ago.
11:13:44 * ksf just configured his vim to replace N<backspace>N with â„•
11:13:58 <ksf> but then it's a muscle memory killer.
11:14:19 <Plouj> is there a way to see who from #haskell is also in #opengl? :)
11:14:30 <mauke> using digraphs?
11:14:31 <ksf> the other option is C-K N N , but that sucks, too.
11:14:46 * mauke uses compose | N
11:15:05 <Cale> yitz: Here
11:15:18 <yitz> Hi Cale.
11:15:22 <shachaf> Plouj: Depends on your IRC client.
11:15:22 <ksf> typing "Nat" is definitely faster.
11:15:26 <shachaf> Plouj: (Yes.)
11:15:54 <ksf> actually, it's a shame we're worrying about alpha equivialent things.
11:16:16 <yitz> Cale: if your numbers are represented as lists of bits lsb first, it follows from Dirichelet's Theorem that primality cannot be tested in constant time. Even that is not completely trivial.
11:16:42 <yitz> Cale: of course, if they're msb first, it's trivial
11:16:57 <Cale> yitz: right
11:17:17 <yitz> Cale: if you assume constant-time random access to the bits, I don't immediately see how to do it.
11:17:32 <Cale> Well, same way as lsb first
11:17:42 <Cale> I think.
11:17:58 <Plouj> shachaf: if yours does that, can you give me a list?
11:18:07 <yitz> Cale: but there could be some fancy way of sampling bits to get your answer. you have to prove it's not possible.
11:18:13 <Cale> hmm
11:18:29 <yitz> and this is only to show that you can't do it in constant time.
11:18:45 <burp> haskell arrays must be a bad joke -.- so complicated
11:18:56 <copumpkin> burp: they're not that bad
11:18:58 <yitz> actually, if you represent your numbers as products of prime powers, you actually *can* do it in constant time. :)
11:19:06 <burp> so many monad tutorials but none for arrays
11:19:09 <Cale> burp: They're nicer than arrays in most other languages. At least you can index them with arbitrary types
11:19:24 <mauke_> burp: that's because everyone knows arrays are easy
11:19:27 <copumpkin> burp: the only complication is that you get these odd multiparameter typeclasses
11:19:40 <burp> copumpkin: yes thats what I mean
11:19:41 <Cale> yitz: well, sure, but the best known conversion we have is exponential time
11:19:46 <copumpkin> burp: and it's not immediately clear (at least for me, from the documentation) what the different parameters represent
11:19:51 <yitz> hmph.
11:19:59 <burp> copumpkin: this confuses me right now ;)
11:20:08 <copumpkin> burp: which array class are you looking at?
11:20:13 <copumpkin> IArray?
11:20:25 <burp> MArray
11:20:30 <burp> I want to use STUArray
11:20:44 <mauke_> oh, enjoy your bonus ST s confusion
11:20:49 <copumpkin> so that one has a parameter for the "embedding monad" (not sure what else to call it), one for the index, and one for the element type
11:21:00 <Cale> burp: Do you already understand the ST monad well?
11:21:07 <burp> Cale: nope ;)
11:21:17 <Cale> burp: Okay, so first learn to use STRefs
11:21:31 <Cale> burp: Once you have that down, start on the arrays.
11:21:31 <edwardk> The ST monad is seriously awesome =)
11:21:39 <burp> ok
11:24:56 <yitz> edwardk: well, so is the State monad. Not surprising I guess - it's easy to show that the two are semantically isomorphic (in some sense).
11:31:56 <tkr> so who's the guru with haskell + graphics + maths?
11:32:14 <jeffersonheard> uhm.  there are quite a few of us graphics ppl here
11:32:15 <copumpkin> tkr: not sure there's a single one, but dan piponi springs to mind
11:32:17 <jeffersonheard> what do you need?
11:32:33 <jeffersonheard> dan def. springs to mind yeah
11:32:48 <jeffersonheard> david duke, too, if he has a handle on #haskell
11:33:36 <tkr> jeffersonheard: I would like to draw a grid. just like (x, y) coordinate points with lines connecting them. then consider each points as a complex number. apply a (or any) transformation on them and display the results.
11:34:05 <tkr> jeffersonheard: I want to learn the basics how to combine graphs + haskell + maths.
11:34:13 <pedon> wow...this is one of the fullest irc's Ive every been on...;-)
11:34:24 <yitz> @users
11:34:25 <lambdabot> Maximum users seen in #haskell: 658, currently: 612 (93.0%), active: 21 (3.4%)
11:34:27 <pedon> cant miss a feetback here i guess
11:34:33 <pedon> pffffffff
11:34:45 <copumpkin> pedon: we hit 699 once :P
11:34:51 <copumpkin> but lambdabot is forgetful
11:35:04 <pedon> very good..thats more intelligent
11:35:29 <badsheepy> i have been in fuller channels, but not many more on topic, and none more helpful
11:35:34 <yitz> pedon: we have a bunch of side channels when there are two many threads going at once here
11:35:53 <yitz> s/two/too/
11:36:02 <yitz> @seen lambdabot
11:36:04 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
11:36:04 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
11:36:04 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
11:36:04 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
11:36:06 <tkr> jeffersonheard: think about drawing a plain grid. then applying a moböius transorm on them to make them a different formation. its nots even 3d.
11:36:10 <pedon> I though Ill refresh My Haskell after 10 years .....Somethings changed...
11:36:14 <pedon> aaa thanks..
11:36:15 <defun> on unix-like systems how do I make haskell create file foo and then write to that file string str?
11:36:29 <Cale> writeFile "foo" str
11:36:30 <jeffersonheard> ahh, that makes some sense
11:36:40 <defun> Cale: thanks.
11:37:35 <yitz> hmm. Cale, why is \bot breaking channel names on the # now?
11:37:48 <yitz> always did that?
11:38:02 <Cale> yitz: I have no idea, probably always did it
11:38:05 <soupdragon>  <lambdabot> interplanetarylazers
11:38:14 <Cale> I don't really edit lambdabot itself. I only run it.
11:38:14 <fbru02> why should I use Int instead of Integer ? i know Int is a subtype of Integer
11:38:21 <yitz> ok
11:38:38 <koeien> fbru02: using Int is more efficient in practice
11:38:39 <jeffersonheard> soI feel stupid promoting my own toolkit, but it sounds like what you might want is to use Hieroglyph to declare Complex numbers to be an instance of the Visual class...
11:38:39 <Cale> fbru02: It's not a subtype, it's completely separate. It has slightly higher performance at the cost of correctness.
11:38:48 <koeien> fbru02: but, it is bounded.
11:38:48 <deech> Hi all, I am looking to distribute a small Mac app written in Haskell that has a native GUI. Right now I'm trying to install GTK2HS and am in my second hour of installing GTK from MacPorts. With all these dependencies I am worried that distributing the app is going to be problematic. Has anyone distributed a Gtk2Hs app before?
11:39:03 <jeffersonheard> then you can just manipulate the complex numbers and directly visualize them
11:39:08 <Cale> Int gives you integers modulo 2^n for some n
11:39:22 <Cale> (which depends on the machine that your program is compiled for)
11:39:35 <koeien> > maxBound :: Int
11:39:35 <Zao> Cale: Aren't they signed?
11:39:36 <lambdabot>   9223372036854775807
11:39:40 <Cale> Zao: yes
11:39:49 <Zao> I assume the range isn't symmetrical.
11:39:53 <Cale> Zao: But they're still mod 2^n
11:39:54 <koeien> > minBound :: Int
11:39:55 <lambdabot>   -9223372036854775808
11:40:06 <yitz> deech: on tiger you need to launch X11 first before your app can run. I heard that's fixed on leopard tho
11:40:07 <fbru02> Cale, koelen thanks , what the t constructor for Int , as if I enter a number in ghci it always infers it is a Integer
11:40:14 <jeffersonheard> define a visual instance over the range of complex numbers, which would hypothetically project the Complex values into real coordinates and draw XY lines for them
11:40:18 <koeien> fbru02: ah no, that is due to defaulting
11:40:30 <Cale> fbru02: Give it an explicit type signature, or use it in a way which requires it to be an Int
11:40:37 <deech> yitz, I'm running Leopard but MacPorts is installing X anyway
11:40:38 <dcoutts> deech: I've not done it on OSX but I've done it on other platforms.
11:40:39 <Cale> fbru02: integer literals are polymorphic
11:40:42 <yitz> deech: gtk2hs guis look really weird (on tiger at least)
11:40:46 <koeien> fbru02: it has to choose *some* type to show it. you can use " 1 :: Int" to force it to be an Int
11:40:47 <jeffersonheard> If you don't want to do that, then you can use Cairo to do the graphics, as it's a low learning curve.
11:40:48 <Cale> > 5 :: Float
11:40:50 <lambdabot>   5.0
11:40:53 <Cale> > 5 :: Int
11:40:54 <lambdabot>   5
11:40:56 <Cale> > 5 :: Integer
11:40:58 <lambdabot>   5
11:41:00 <jeffersonheard> you'll jsut have to do the context creation, etc yourself.
11:41:01 <koeien> (under the hood, this is "fromInteger 5")
11:41:03 <CrazyAzrael> deech: Don't worry too much about dependencies--check it, but most dependencies are compiled into the haskell binary (dyn linking is fairly limited)
11:41:03 <Cale> > 5 :: Complex Doublw
11:41:04 <Cale> > 5 :: Complex Double
11:41:05 <lambdabot>   Not in scope: type constructor or class `Doublw'
11:41:06 <lambdabot>   5.0 :+ 0.0
11:41:19 <fbru02> hehe nice thank u guys !
11:41:31 <yitz> deech: no you need X11 from Mac OS X, macports just includes various devel libs to use for building X apps
11:41:54 <deech> yitz, dcoutts , I am not tied to the GTK  if there is a better toolkit available for Haskell.
11:42:00 <yitz> deech: oh -- hmm, in fact I had to manually install X from the XCode disc.
11:42:09 <jeffersonheard> I don't believe anyone's written a moebius transform and pubished it as a library, but it shouldn't be all that hard to write over a Uarr or a List of Data.Complex.Complex Double
11:42:44 <dcoutts> deech: Gtk is fine, the issue is OSX distribution when there's lots of C libs
11:43:13 <yitz> deech: gtk2hs is best imho, but you are right that there are some deployment issues. gtk doesn't quite feel at home yet on the mac.
11:43:20 <dcoutts> deech: if you can distribute something depending on a C lib then I expect it should be more or less the same for gtk
11:43:22 <tkr> jeffersonheard: hmm. interesting. I know some math, some programming and Haskell seems the most 'easiest' way to achieve this.
11:43:47 <yitz> dcoutts: does gtk run natively yet?
11:43:48 <dcoutts> deech: eg on Windows we just bung all the gtk .dll files into the application's bin dir and zip up the whole thing
11:44:06 <yitz> or do you still need to run it under X
11:44:07 <yitz> ?
11:44:17 <dcoutts> yitz: on osx there's two backends the x11 and a native one, the native one is newer and less mature
11:44:44 <tommd> the recent HP discussions about licenses and tool kits has left me a little disappointed that there doesn't exist any portable BSD tk.  Its tool kit X + GPL or bust, isn't it?
11:44:56 <yitz> dcoutts: is it possible to run the native backend with gtk2hs? for me, it just runs on X by default
11:45:07 <dcoutts> yitz: yes it's possible
11:45:08 <jeffersonheard> however you do mean a mobius transformation not transform, right?  transform is only defined on positive integers
11:45:17 <yitz> that would be awesome
11:45:27 <dcoutts> yitz: I've heard reports of people doing it. Don't ask me how though. I've never used OSX,
11:45:51 <jeffersonheard> yitz: there's a howto out there somewhere
11:45:52 <yitz> dcoutts: then it should be up on some wiki. very important.
11:45:54 <jeffersonheard> hold on
11:46:22 <jeffersonheard> http://www.haskell.org/haskellwiki/Gtk2Hs#Using_the_GTK.2B_OS_X_Framework
11:46:38 <McManiaC> @pl a >>= \x -> b $ c x
11:46:39 <lambdabot> b . c =<< a
11:46:39 <jeffersonheard> So in fact, it is on a wiki :-)
11:47:10 <jeffersonheard> yitz: be aware that the native GTK OSX framework does NOT do OpenGL.  That's its only limitation
11:47:11 <yitz> deech: if you can get your app to run on the native gtk backend that would be a whole new ballgame.
11:47:29 <yitz> jeffersonheard: ok. tnx!
11:48:24 <Athas> Is there a standard function like the follwing:  bound lower upper v = max lower (min upper v) ?
11:48:36 <deech> yitz, I agree. However this is my first time working on OS X and I would like to stick to something that's relatively well-documented.
11:49:10 <burp> calcStep :: (MArray (STUArray s) ParticleState (ST s)) => Int -> StateT (SimConf s) IO ()   <.. wow thats ugly ;)
11:49:21 <koeien> Athas: not that i know of. i would write it as   bound lower upper = max lower . min upper
11:50:38 <deech> On a tangential note, it seems as though the Javascript GUI frameworks are approaching the capabilites of native GUI toolkits quite fast. It would be nice to be able to use them to create single-user cross-platform apps.
11:51:12 <soupdragon> deech cant you do that already?
11:51:16 <yitz> jeffersonheard: oh - looks like you have to hardwire it into gtk2hs. so you can't have both installed at once, and you can't use the gtk2hs port on macports.
11:52:57 <deech> soupdragon, yes but it's a little cumbersome. You have to have a server running before you launch the browser. From a distribution standpoint, the user has to go through a 2-step process. But I guess that can be overcome with a simple shell script.
11:53:22 <ski> RayNbow : let evalAffine :: StateT [i] [] a -> ([i] -> [] a); ma `evalAffine` is = map fst (ma `runStateT` is)
11:53:33 <soupdragon> so the solution migth be a general purpose server
11:53:38 <yitz> deech: google has a simple workaround for that :)
11:53:46 <deech> soupdragon, I was thinking the same thing.
11:53:53 <deech> yitz, you mean chrome?
11:54:05 <yitz> i mean, everything runs off of their servers
11:54:19 <deech> I really like Prism too.
11:56:20 <deech> yitz, Google is kind of like my dad when I was growing up - I really love it and am  afraid of it all at the same time.
11:57:07 <ski> Athas : i don't think so. but there ought to be
11:57:11 <fnord123> http://www.vorpalcore.com/node/5
11:57:57 <ski> Athas : might i ask what you wanted it for ?
11:58:04 <McManiaC> *** Exception: /home/nils/.conkytoprc: openFile: resource busy (file is locked)
11:58:20 <McManiaC> what might be a reason for this?
11:58:24 <Athas> ski: bounding an integer within two border values.
11:58:35 <Athas> What else would it be useful for?
11:59:23 <ski> Athas : it could be useful as a primitive for "partial reals"
12:01:01 <jeffersonheard> yitz, that's correct
12:01:40 <McManiaC> http://ix.io/9w/hs â† can anyone see a mistake there?
12:01:41 <ski> Athas : i saw a paper somewhere that e.g. computed binary-search of zeros of functions, as an "infinite recursion", using that
12:01:58 <yitz> deech: good way of putting it
12:06:43 <Cale> McManiaC: yeah, you're writing to the file which you're lazily reading from
12:06:59 <Cale> McManiaC: Which is generally a recipe for disaster.
12:07:16 <McManiaC> ok
12:07:34 <soupdragon> what's the name for a in [a]?
12:07:37 <Athas> Is there a variant of Control.Exception that works with the MonadIO typeclass instead of plain IO?
12:07:42 <soupdragon> like the single element from a list
12:07:55 <soupdragon> it's something like digit but more general
12:08:01 <Cale> McManiaC: Solutions include using strict bytestrings to do the IO, or just writing to a separate file and then moving it over the original when finished.
12:08:25 <Cale> soupdragon: mm... that's at the value level or the type level?
12:08:29 <Cale> element?
12:08:34 <McManiaC> Cale: could a Handle do the work
12:08:36 <McManiaC> ?
12:08:47 <soupdragon> it's lik digit/token/symbol
12:08:49 <Cale> McManiaC: If you use hGetContents, you'll have the same problem
12:08:50 <soupdragon> soemthing on that line
12:08:54 <Cale> soupdragon: hmm
12:08:57 <McManiaC> ok
12:08:58 <McManiaC> :S
12:09:26 <Cale> McManiaC: Another, more hacky solution, is to ensure that the whole file is read before you start to write
12:09:49 <ski> soupdragon : is "inhabitant" bad ?
12:10:11 <soupdragon> it doesn't make sense in context
12:10:13 <Cale> McManiaC: One way to do that would be to put something like  rnf toSave `seq` writeFile file toSave
12:10:24 <Cale> McManiaC: Where rnf is from Control.Parallel.Strategies
12:10:27 <doublethink_work> Athas: http://hackage.haskell.org/packages/archive/MonadCatchIO-mtl/0.2.0.0/doc/html/Control-Monad-CatchIO.html
12:10:31 <doublethink_work> ?
12:10:34 <yitz> jeffersonheard: heads up, it looks like that procedure on the wiki is going stale.
12:10:37 <Cale> (or you can write it yourself as  foldr seq () toSave `seq` ...
12:10:40 <Cale> )
12:10:43 <Athas> doublethink_work: that looks promising, thanks.
12:11:13 * soupdragon bbl
12:12:38 <ski> (soupdragon : is it just a list, or does it have any domain-specific interpretation ?)
12:17:21 <McManiaC> Cale: but basicly, there is no easy way to change likeâ€¦ one line of a textfile in haskell?
12:19:15 <hackagebot> AC-HalfInteger 1.2.1 - Efficient half-integer type. (AndrewCoppin)
12:20:08 <tromp_> halfinteger? is that what you would use for komi in go games?
12:21:29 <Saizan> ?hackage AC-HalfInteger
12:21:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AC-HalfInteger
12:21:44 <soupdragon> just a list
12:22:35 <Athas> Doesn't Cabal install packages from Hackage?
12:23:10 <dcoutts> Athas: yes, the 'cabal' command line tool can do that
12:23:45 <Athas> Yet why does Cabal install a seemingly older version than the one with documentation on Hackage?
12:23:55 <Athas> The package in question is MonadCatchIO-mtl.
12:24:14 <dcoutts> Athas: perhaps you've not updated your package list recently
12:24:24 <dcoutts> Athas: cabal update
12:24:26 <Athas> Hmm.
12:24:34 <_-jn>  hello, has anyone worked with entrycompletion and treemodels? i can't get rows from childnodes into the completion list... anyone have any idea? (using gtk2hs)
12:24:48 <Athas> dcoutts: that was indeed the case.  Thanks!
12:25:13 * dcoutts notes the latest version of cabal-install reminds users when the package list gets more than 15 days old
12:25:43 <Athas> Perhaps my cabal-install is too old too.
12:27:32 <dcoutts> I can't remember if that feature got added in 0.6.2 or if it's only in 0.7+
12:27:46 <dcoutts> Athas: the latest released version is 0.6.2
12:29:18 <yitz> dcoutts: is there any way to mark an installed package as automatically installed and managed by a package mgr?
12:29:48 <dcoutts> yitz: what effect would that have?
12:30:07 <dcoutts> yitz: are you talking about how that might affect the behaviour of cabal-install?
12:30:31 <yitz> dcoutts: for example - when you upgrade ghc, the mgr needs to know which packages are under its control and need to be rebuilt
12:31:14 <dcoutts> yitz: a package manager knows which haskell packages it controls
12:31:41 <yitz> dcoutts: mm, not really. it could be convenient for the mgr to be able to prevent changes to the pkgs it installed by default, unless the user specifies an i-really-want-to-do-this flag.
12:31:51 <yitz> dcoutts: no. maybe the user did something in the meantime.
12:32:07 <yitz> dcoutts: on macports, for e
12:32:19 <dcoutts> yitz: it certainly knows that it installed the files. It may be that the user did a global install of a package of the same version.
12:32:31 <dcoutts> ie masking the one that the package manager registered
12:32:33 <yitz> dcoutts: and on macports, for example, there is really no way to do that without asking ghc-pkg or cabal
12:32:46 <dcoutts> yitz: gentoo manage it fine
12:32:52 <dcoutts> without asking ghc-pkg or cabal
12:33:03 <dcoutts> it knows exactly which haskell/ghc packages were installed
12:33:09 <dcoutts> and thus which need to be rebuilt
12:33:18 <yitz> ok. don't know about dpkg.
12:33:28 <dcoutts> when you upgrade ghc
12:33:29 <yitz> but there currently isn't any way to do that in macports
12:33:37 <dcoutts> yitz: I don't believe it :-)
12:33:52 <dcoutts> yitz: gentoo does it by installing an extra file in a special dir
12:33:57 <dcoutts> you can do that in macports
12:33:59 <Cale> McManiaC: Not directly in the libraries, but you can write an easy way to do it.
12:34:27 <noteventime_> I'm highly uneducated on the subject, but the prompt monad kinda feels like some kind of "monadic delegation". Any value to that? :p
12:34:38 <yitz> yeah, i guess each pkg mgr could write its own scripts to keep track. but why not let cabal and ghc-pkg do it for them?
12:34:44 <noteventime_> I'm not sure that's even a meaningful thing to say
12:35:08 <dcoutts> yitz: because each package manager wants to do different things
12:35:09 <Cale> noteventime_: It makes sense to say that considering what the Prompt monad is.
12:35:23 <yitz> with the additional benefit of making it less likely for users to mess things up accidetally with a misplaced manual cabal command
12:35:33 <Cale> (but I'm not sure it would help anyone who wasn't already familiar)
12:35:35 <yitz> dcoutts: no i think this bit is common
12:35:48 <noteventime> Cale: The thing is, I'm not familiar, which is why I asked
12:36:10 <artagnon> This is wierd. My first ever link error while compiling Haskell. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8153#a8153 << Anything wrong with the code?
12:36:16 <dcoutts> yitz: it's vaguely common between source based package managers that do not track reverse dependencies in packages
12:36:37 <noteventime> Cale: Thanks, should mean I got things somewhat right
12:36:44 <Cale> noteventime: The Prompt monad gives you something which is guaranteed to be a monad, and which has computations which correspond to the elements of an arbitrary selected datatype.
12:36:57 <yitz> dcoutts: why just them? btw macport does track reverse deps
12:37:25 <dcoutts> yitz: if it tracks reverse deps then there would be no problem here :-)
12:37:31 <Cale> noteventime: You can then run a prompt monad computation by specifying how those abstract computations are transformed into actual ones.
12:37:51 <dcoutts> yitz: it's clearly not needed for binary package managers, that much you'll agree with
12:38:11 <yitz> dcoutts: no, following those you'll rebuild zillions of huge C libraries as well.
12:38:14 <noteventime> Cale: Hmm, could you somehow do products of the type of the abstract computation to get something like t
12:38:18 <noteventime> monad transformers?
12:38:23 <yitz> dcoutts: no i think it's needed equally
12:38:41 <dcoutts> yitz: debian and fedora certainly does not need it
12:38:45 <noteventime> You'll have to excuse me if I'm abusing terminology
12:38:54 <yitz> dcoutts: i have had more troubles with this in debian than in macports actually
12:39:08 <pikhq> Portage both does and does not track reverse dependencies. The unstable release candidate build of Portage automatically tracks reverse dependencies, and the current stable version does not.
12:39:08 <Cale> noteventime: The tricky part there seems to be combining the corresponding interpreters in a meaningful way. I have a feeling that it's possible with a little work, but it's a bit tricky to sort out how to actually accomplish it.
12:39:30 <pikhq> (instead, there's a script that greps all the binaries for reverse dependencies that are broken))
12:39:42 <yitz> dcoutts: the trouble is, you'll always need to do some manual cabal work. it's so easy to get the two into a terribly inconsistent state that requires major hackery at both ends to get out of
12:39:58 <yitz> this would make that much less likely to happen
12:40:40 <dcoutts> yitz: I don't really see that it helps much, it just tells you what is messed up
12:40:42 <Cale> noteventime: Of course this stems from the same problem which inspired monad transformers in the first place: if you have two monads 'combining' them doesn't naturally make sense on its own, you have to specify exactly how the computations in one monad interact with the computations in the other.
12:41:03 <dcoutts> yitz: just because something wants to store info per-package doesn't mean it should be in the ghc package database
12:41:08 <dcoutts> that kind of thing does not scale
12:41:41 <yitz> dcoutts: it prevents users from accidentally changing the cabal-state of packages under automated control. it allows the mgr to "take over" from manual installations when requested. etc.
12:41:56 <dcoutts> yitz: having the package manager track the relationship between distro package and the fact that it provides a ghc package is not at all a hard thing for the distro to do.
12:42:15 <yitz> dcoutts: in fact, it's inherently impossible
12:42:19 <dcoutts> yitz: a better solution for that is to separate the package databases, /usr from /usr/local
12:42:47 <yitz> dcoutts: hmm, that's an idea
12:42:51 <noteventime> Cale: Indeed. I wasn't suggesting it'd be any easier, just trying to get a grip on what prompt is and isn't
12:43:03 <yitz> dcoutts: but then, how does ghc know which to use?
12:43:10 <dcoutts> yitz: a package manager can know it did register a package. That doesn't guarantee it's still registered later if the user messes stuff up. But that's ok it can cross check what it thinks with the current state and unmess things if it wants.
12:43:25 <noteventime> Maybe I'll try to look into the possibility some time, need to read more first though
12:43:31 <dcoutts> yitz: it uses both, same way it uses global and per-user db
12:43:37 <yitz> dcoutts: it has no way of knowing the right thing to do
12:43:56 <dcoutts> yitz: what is 'it' here? and what is the difficulty in knowing what to do
12:44:18 <yitz> dcoutts: cabal supports more than just the global and local dbs?
12:44:30 <dcoutts> yitz: ghc does and cabal mostly does.
12:45:10 <dcoutts> yitz: the package manager can and should always assume that if it installed the package then it has control over that package, if the user re-registers it globally then the user is stupid and the package manager can stomp over the user's changes.
12:46:27 <yitz> dcoutts: you express your opinions about what's stupid. but in practice, we don't want average users to have to open package db files in vi and hack them, or the equivalent for the pkg mgr
12:46:33 <yitz> and that happens
12:46:55 <yitz> and we can easily prevent it, if we keep track of state properly
12:47:42 <dcoutts> yitz: oh you want to prevent it by making ghc-pkg to refuse to re-register a global package by saying that "this package is managed by your package manager, hands off!"  ?
12:48:00 <yitz> right. unless the user specifies --force
12:48:03 <yitz> or something
12:48:16 <RayNbow> ski: why (map fst .) . runStateT and not evalStateT?
12:48:21 <yitz> and that info gets registered via cabal
12:48:40 <dcoutts> yitz: I see, so you record what the "registering agent" is
12:48:44 <yitz> right
12:49:06 <dcoutts> yitz: but then you need special rules to say who's allowed to pre-empt who
12:49:21 <dcoutts> like manual over cabal and vice versa
12:49:24 <yitz> dcoutts: nah, just automated or manual
12:49:33 <yitz> ah well ok
12:49:44 <dcoutts> but then I cannot manually register something I registered with cabal
12:50:03 <yitz> dcoutts: you can, if you claim to really know what you are doing
12:50:07 <dcoutts> I think a better solution is to partition the /usr package db from the /usr/local one
12:50:33 <yitz> dcoutts: isn't that platform specific
12:50:41 <dcoutts> not very
12:50:54 <dcoutts> it'd be different for windows, but it has no package manger
12:51:23 <dcoutts> it could be the same for all the other unix platforms
12:51:34 <yitz> then there's /opt/local and /opt on solaris and ...
12:52:00 <dcoutts> ghc can have a stack of package dbs and by default we register into the top one
12:52:13 <dcoutts> a system package manager can register into one lower in the stack
12:52:17 <yitz> two stacks, local and global
12:52:41 <dcoutts> if there's no sensible concept of local in an installation then there's no local one
12:52:58 <dcoutts> yitz: like your /opt example, there may be no obvious local equivalent
12:53:12 <yitz> isn't is simpler just to add one more field to the pkg registry, and a flag or two here and there to support it?
12:53:37 <dcoutts> I don't like that approach it seems ugly to me
12:53:49 <dcoutts> it's recoding ad-hoc info in the wrong "direction"
12:54:12 <yitz> funny i don't see why you don't like it. to me it seems like a clean representation of reality.
12:54:20 <mmmulani> how do you convert Int -> Integer?
12:54:26 <RayNbow> :t fromIntegral
12:54:28 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:54:56 <ksf> you just don't touch the global install without the system's package manager.
12:55:04 <bcw> RayNbow, other way around, i think
12:55:05 <ksf> I've got a user account to do everything else.
12:55:08 <yitz> dcoutts: anyway, i do believe that there is important cooperative state that we are missing here.
12:55:10 <RayNbow> :t let x = 3 :: Int       in   (fromIntegral x) :: Integer
12:55:12 <lambdabot> Integer
12:55:17 <dcoutts> yitz: if you want to add it you can do it already, you can wrap the ghc-pkg script.
12:55:44 <yitz> dcoutts: well my approach requires cabal support also
12:55:46 <RayNbow> fromIntegral can convert any Integral type (like Int and Integer) to any Num type (like Integer, Double, etc.)
12:55:46 <ksf> another idea would be a .d - hierarchy.
12:56:00 <ksf> like init.d, or profile.d (which is the better example)
12:56:00 <yitz> oh you mean your approach?
12:56:15 <dcoutts> yitz: ah but it doesn't, you can just check if the package being re-registered is managed by the system package manager and refuse in that case
12:56:35 <dcoutts> yitz: which you can check by seeing where the current package's info points to, files etc.
12:56:38 <bcw> RayNbow, oh. nm then
12:57:09 <mmmulani> hmmm, how do I redefine a function to be Integer -> Integer from Int -> Int
12:57:24 <ksf> mmmulani, change the type signature?
12:57:25 <dcoutts> yitz: if library-dirs points to /usr/lib or whatever then you reject it, unless they supply --force or something.
12:57:42 <yitz> dcoutts: if it's being called by cabal, how do I know who invoked cabal?
12:58:08 <mmmulani> ksf: this produces odd errors with list indices
12:58:13 <dcoutts> yitz: oh you mean how does the distro build script get around its own check?
12:58:20 <yitz> yeah
12:58:20 <ksf> yeah, indices are Int.
12:58:33 <dcoutts> yitz: pass --with-ghc-pkg=$the-real-one
12:58:54 <ksf> you can use fromIntegral to convert.
12:59:05 <yitz> oh i see
12:59:10 <noteventime> mmmulani: Or wrap it in "fromIntegral" on "both sides"
12:59:30 <mmmulani> hmm, I'll try liberal uses of fromIntegral
12:59:39 <burp> @hoogle Show IOArray
12:59:39 <lambdabot> Did you mean: :: Show (IOArray a a) /count=20
12:59:40 <lambdabot> No results found
12:59:47 <ksf> you could also use the generic list functions and work with Integer indices, but I highly doubt those would fit into your memory, anyway.
13:00:28 <yitz> dcoutts: now how does this stack-of-pkg-dbs thing work?
13:01:27 <dcoutts> yitz: it's not polished yet, but ghc can already handle a stack of package dbs as can ghc-pkg. Cabal can handle one extra custom one and the next release should be able to handle a full stack.
13:01:55 <yitz> ok. so that's coming
13:02:01 <dcoutts> yitz: with ghc-pkg, update actions modify the last-specified one
13:02:18 <yitz> urgh, that's not what we want
13:02:20 <dcoutts> yitz: the real change would be to have by default ghc use more than one "global" package db
13:02:32 <mmmulani> sweet, it worked out. thanks a bunch
13:03:12 <dcoutts> yitz: how is it not what you want?
13:03:52 <yitz> dcoutts: when a user invokes it with no options, it should use the db for manual installs, not whatever was last used
13:04:16 <dcoutts> yitz: that should be fine if the default is "global;local"
13:04:30 <dcoutts> yitz: or in the --user case, "global;local;user"
13:04:57 <dcoutts> perhaps system is a better name than global
13:04:57 <ski> RayNbow : no reason at all, apart from that i for some reason didn't think of it
13:05:21 <yitz> yeah
13:05:31 <dcoutts> yitz: by last-specified I mean in the order they're specified on the command line, not some temporal thing
13:06:25 <yitz> oh ok
13:06:38 <yitz> right
13:07:53 <dcoutts> yitz: btw, in ghc-6.12 we should be able to better detect when packages are mismatched against their deps, ie which registered packages are borked
13:08:11 <dcoutts> by recoding ABIs
13:08:15 <dcoutts> recording
13:08:41 <yitz> dcoutts: so the intention for this db-stack mechanism also is for the HP, I suppose, which will be yet another player in this game
13:08:51 <ksf> you could be really, really evil and support dependencies on source hashes.
13:10:00 <dcoutts> yitz: maybe
13:10:26 <yitz> dcoutts: so for example, a user could also make a mess of things by installing a different version of HP when the pkg mgr already installed it.
13:10:57 <yitz> i guess that would be a different ghc though
13:11:00 <dcoutts> yitz: that would be handled as any other local install under this scheme
13:11:15 <dcoutts> yitz: oh, with a separate ghc, then yes it'd be separate
13:11:32 <yitz> but don't worry, users will find a way to mess it up
13:12:22 <dcoutts> yitz: you might like to look at the gentoo haskell-updater tool
13:13:36 <yitz> dcoutts: how does arch do things?
13:13:44 <dcoutts> yitz: not sure
13:14:09 <dcoutts> I think they only support one version of ghc at once
13:15:14 <yitz> arch probably doesn't care if the user sometimes needs to use vi to clean up a mess.
13:16:11 <dcoutts> yitz: what gentoo does is save copies of all the package registration info so packages can be re-registered at any time
13:16:29 <dcoutts> it also uses that to work out which system packages provide which ghc packages
13:16:51 <yitz> now isn't that re-inventing the wheel?
13:17:08 <yitz> why duplicate all the pkg registry info?
13:17:18 <dcoutts> in particular if you rebuild ghc then it re-registers all your packages (the ones managed by the package manager)
13:17:54 <dcoutts> yitz: the ghc-pkg db is designed for ghc's needs not for package managers. There's nothing wrong with package managers keeping info on the things they install.
13:18:18 <yitz> i guess it does add robustness
13:18:22 <dcoutts> it duplicates it in this case because the global package db is mutable
13:18:29 <yitz> but it seems like a lot of work
13:18:37 <dcoutts> in 6.12 ghc will use a dir of package files
13:18:49 <yitz> oh, much nicer
13:19:04 <dcoutts> so gentoo may stop duplicating the info at that point
13:19:16 <yitz> and some master db or something like that probably
13:19:19 <dcoutts> it still doesn't stop users doing stupid things though
13:21:00 <yitz> users will always do stupid things. the idea is to annoy only them when they do it, not cause them to annoy the ghc, cabal, HP, and distro teams all at once to work jointly to clean up the mess.
13:25:39 <hackagebot> AC-VanillaArray 1.1.1 - Immutable arrays with plain integer indicies. (AndrewCoppin)
13:26:32 <Igloo> Does anyone have the magic for defining Storable.alignment handy?
13:29:18 <deech> Hi all, let's say I start an external process like "firefox" using System.Cmd.rawSystem, it runs the process in the background and returns "ExitSuccess". I'd like to run it in the foreground and have the thread hang until firefox is shut down. Is there a way to do this in Haskell?
13:29:51 <dcoutts> deech: rawSystem runs the process in the foreground
13:29:56 <Igloo> rawSystem does run things in the foreground, but firefox probably does magic
13:29:57 <mmorrow> deech: firefox detaches
13:30:46 <deech> But if I run it in a shell, the shell blocks until firefox is shutdown.
13:30:52 <mmorrow> not mine
13:31:18 <deech> hmmm ... mine has always done that unless I run it "firefox &"
13:31:18 <Igloo> deech: It might only detach if there is already a firefox running or something
13:31:29 <mmorrow> ah, that may be it
13:31:51 <CrazyAzrael> deech: It might be easier just to block on getting the exit status.
13:32:18 <deech> CrazyAzrael, how do I do that?
13:32:20 <dcoutts> CrazyAzrael: that doesn't help, it exits immediately
13:32:32 <Botje> deech: firefox -no-remote
13:32:54 <Botje> that starts a new instance of firefox
13:32:57 <dcoutts> CrazyAzrael: rawSystem already packages up the actions of launching and blocking 'til it exits
13:33:20 <mmorrow> Botje: that brings up a dialog saying "Firefox is already running, but is not responding. To open a new window, you must first close the existing Firefox process, or restart your system."
13:33:23 <mmorrow> on mine
13:33:33 <Botje> ba
13:33:34 <CrazyAzrael> dcoutts: My bad.
13:33:34 <Botje> h
13:33:39 <Botje> firefox-- :(
13:33:43 <deech> I just started a fresh firefox from the shell , and the shell blocks and spits out GTK messages etc. I do it using rawsystem and I immediately get an ExitSuccess.
13:33:55 <kajamd>  Please help me -  http://www.lostworlds.lv/go.php?1139723800
13:34:18 <mmorrow> $ firefox -v
13:34:18 <mmorrow> Mozilla Firefox 3.0.11, Copyright (c) 1998 - 2009 mozilla.org
13:34:21 <Botje> fuck off, spammer.
13:34:29 <badsheepy> :o
13:34:30 <Botje> (yes, i know he already quit)
13:34:45 <blackh> I'm disappointed - I thought that link was going to be some Haskell code.
13:34:52 <CrazyAzrael> Try the version in /usr/lib/firefox-*/firefox ?
13:35:01 <edwardk> hrmm. i never knew someone had gone and made a spiffy parallel bzip2: http://compression.ca/pbzip2/
13:35:06 <CrazyAzrael> err, not that
13:35:08 <CrazyAzrael> onesec
13:35:24 <deech> I just tried it with "emacs" and rawSystem blocks just like the shell. Weird.
13:37:03 <CrazyAzrael> Could be wrong, but it looks like /usr/lib/firefox-*/firefox-bin might be what you want.
13:37:41 <gfhf>  Please help me -  http://www.lostworlds.lv/go.php?1139723800
13:37:42 <mmorrow> aha
13:37:56 <Botje> again?
13:37:56 --- mode: ChanServ set +o dcoutts
13:37:59 <Botje> the same spammer, even.
13:38:00 --- kick: gfhf was kicked by dcoutts (dcoutts)
13:38:03 <mmorrow> $ file $(which firefox)
13:38:03 <mmorrow> /usr/bin/firefox: POSIX shell script text executable
13:38:40 <deech> CrazyAzrael, that worked!
13:38:46 <deech> Weird.
13:39:03 <mmorrow> there's all kinds of crap that shell wrapper is doing it looks like
13:39:31 --- mode: ChanServ set -o dcoutts
13:40:24 <deech> It *seems* as though rawSystem immediately returns the it tries to run a softlink
13:40:38 --- mode: ChanServ set +o dcoutts
13:40:43 <gfhf>  Please help me -  http://www.lostworlds.lv/go.php?1139723800
13:40:47 --- mode: dcoutts set +b gfhf!*@*
13:41:06 <yitz> dcoutts: same IP as the other nick?
13:41:18 <dcoutts> yep
13:42:33 <MarcWeber> dcoutts: Any idea why hsdns-0.0.tar.gz is in the hackage index tar file but can no longer be found on the web interface ? The .tar.gz is gone as well ?
13:43:06 <Gamer>  Please help me -  http://www.lostworlds.lv/go.php?1139723800
13:43:16 <mmorrow> pleez be klined soon
13:43:33 <Botje> dcoutts: ban *!*@87.110.231.94
13:43:47 <soupdragon> dcoutts: ban unaffiliated/dcoutts
13:43:50 * soupdragon hides
13:43:53 <Botje> :)
13:43:55 <dcoutts> :-)
13:47:15 <Cale> There are certain behaviours which should make it obvious that someone deserves a k-line without any human interaction, and joining a channel before saying one line of text and leaving again within the space of a minute or so is one of them.
13:47:39 --- mode: ChanServ set +o Cale
13:48:01 --- mode: Cale set +b *!*@87.110.231.94
13:49:52 <yitz> that IP is in Riga, Latvia
13:50:00 <michaelfeathers> Question:   length ([1..10] ++ [11]) is O(n) right?
13:50:06 <soupdragon> th website is latvian too
13:50:18 <Botje> michaelfeathers: yes
13:50:24 <yitz> soupdragon: hope you didn't go there on windows
13:50:37 <soupdragon> no just the tld .lv
13:52:27 <deech> To whom it may concern regarding softlinks, I was wrong.
13:53:08 <Cale> michaelfeathers: Well, to be a bit irritating, I could say it's constant time since that's a fixed list you're giving it ;)
13:54:11 <yitz> Cale: are you keeping your weapon drawn, or did you mean to de-op?
13:54:40 --- mode: dcoutts set -b gfhf!*@*
13:55:18 <edwardk> michaelfeathers: when in doubt, use a difference list
13:58:01 <michaelfeathers> Cale: :-)  Somebody on a blog is trying to tell me odd things about (++) but I think he is thinking strict.
13:59:16 <ray> is he saying that it has to walk the list once for ++ and another time for length? if that's it, it's still O(n), just with a bigger coefficient
14:00:30 <Saizan> it walks over [1..10] twice
14:00:42 <Saizan> unless the whole things fuses away
14:00:54 <ray> i don't know whether it does
14:01:10 <ray> just saying it's irrelevant
14:01:17 <ray> it's possible this unnamed fellow is making different claims
14:01:47 <mkaemmer> ray: it's relevant... just not with regards to the complexity
14:02:24 <Saizan> ray: sure, i was just making clear that it does
14:03:08 <ray> though i don't see what other claims you oculd make
14:05:07 <mkaemmer> ray: if you write "++" wrong, you could accidentally O(n^2)
14:05:20 <mkaemmer> luckily, this is not the case
14:07:30 <michaelfeathers> Saizan: Really?
14:07:31 <ski> mkaemmer : you mean if you loop (`O(n)' times) in the left argument of `++', yes ?
14:08:53 <yitz> @src (++)
14:08:54 <lambdabot> []     ++ ys = ys
14:08:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:08:54 <lambdabot> -- OR
14:08:54 <lambdabot> xs ++ ys = foldr (:) ys xs
14:10:24 <michaelfeathers> so length ([1..10] ++ [11]) ->  length ((1:[2..10]) ++ [11])
14:10:51 <mkaemmer> ski: right.  Bad definition: "[] ++ ys = ys; [x] ++ ys = x : ys; (x:xs) ++ ys = [x] ++ [xs] ++ ys"
14:11:01 <mkaemmer> er...
14:11:07 <mkaemmer> s/[xs]/xs/
14:12:45 <michaelfeathers> @src length
14:12:46 <lambdabot> Source not found. Sorry.
14:13:03 <michaelfeathers> @src List.length
14:13:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:13:12 <michaelfeathers> :-/
14:15:49 <ski> mkaemmer : that's not what i meant. and that definition has the same complexity as the usual one (it's slightly more strict, i suppose)
14:16:38 <mkaemmer> ski: yeah, my bad... actually, I think the definition I gave may be non-terminating.
14:17:33 <mkaemmer> depends on whether it evaluates as "([x] ++ xs) ++ ys" or "[x] ++ (xs ++ ys)"
14:17:40 <ski> mkaemmer : what i meant was `loop x | frob x = ..x.. | otherwise = loop y ++ [z] where y = ..x..; z = ..x..'
14:18:25 <Saizan> michaelfeathers: before length can see the head of the list it must be produced by (++)
14:18:36 <ski> > let [] ++ ys = ys; [x] ++ ys = x : ys; (x:xs) ++ ys = [x] ++ [xs] ++ ys in "abc" ++ "012"
14:18:37 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
14:18:39 <Saizan> michaelfeathers: which in turn has to traverse the input list
14:18:39 <michaelfeathers> So to reformulate: in this code: length (xs ++ [11]) we are not walking xs twice are we?
14:18:42 <ski> er, right
14:18:48 <ski> > let [] ++ ys = ys; [x] ++ ys = x : ys; (x:xs) ++ ys = [x] ++ xs ++ ys in "abc" ++ "012"
14:18:53 <lambdabot>   mueval-core: Prelude.read: no parse
14:18:53 <lambdabot>  mueval: ExitFailure 1
14:18:53 <Saizan> michaelfeathers: we are.
14:19:06 <michaelfeathers> Saizan: Is that something which follows from the reduction order rules?
14:19:43 <tromp_> you're walking it once, but pushing the ++[11] ahead of you every ste
14:19:47 <tromp_> step
14:19:51 <Saizan> michaelfeathers: well, we're walking once on xs and once on the result of (xs ++ [11]), it's just that the two traversal are interleaved
14:19:57 <mkaemmer> michaelfeathers: you could use rewrite rules
14:20:04 <ski> > let infixr 5 ++; [] ++ ys = ys; [x] ++ ys = x : ys; (x:xs) ++ ys = [x] ++ xs ++ ys in "abc" ++ "012"
14:20:05 <lambdabot>   "abc012"
14:20:09 <ski> lambdabot : ty
14:20:19 <Saizan> tromp_: (++) produces new cons cells that has to be traversed over
14:20:30 <mkaemmer> michaelfeathers: i.e. change "length (xs ++ ys)" to "length xs + length ys"
14:20:34 <Saizan> so you're traversing 2*length xs cons cells, so to speak
14:20:36 <michaelfeathers> I was thinking left-outermost so length expands.. to something which is picking off the head of its argument
14:20:43 <tromp_> Saizan, that's only once at the end
14:21:37 <Saizan> michaelfeathers: length argument is (1:[2..10] ++ [11]) not 1:([2..10] ++ [11])
14:21:39 <ski> (mkaemmer : so that definition "works")
14:22:33 <Saizan> michaelfeathers: the "1:" has to be pattern matched over by (++) before length can see the corresponding "1:" in its argument
14:22:51 <ski> Saizan : itym s/1:[2..10]/(1:[2..10])/
14:22:52 <Saizan> michaelfeathers: and that holds for all the nodes in that list
14:23:17 <michaelfeathers> Saizan: Okay. Considering myself enlightened.
14:23:32 <Saizan> ski: ah, right, if : doesn't have an higher precedence
14:23:39 <michaelfeathers> I wish there was a switch we could use to see the actual reductions.
14:23:50 <michaelfeathers> I'd learn faster, I think.
14:24:50 <michaelfeathers> Saizan: That's really a shame.. I can't imagine why someone couldn't consume a list before that append.
14:26:04 <dons> michaelfeathers: its a bit like the stack though. we don't really have a graph machine anymore
14:26:22 <Saizan> well, only using some knowledge about length you know that length (xs ++ ys) == length xs ++ length ys, it doesn't hold in general
14:26:50 <Saizan> michaelfeathers: however GHC has list fusion that prevents many allocations in cases like these
14:27:04 <mkaemmer> Saizan: itym "length (xs ++ ys) == length xs + length ys"
14:27:16 <michaelfeathers> dons:I keep going back to this book I have: Algorithms by Rabhi and Lapalme where they talk about reduction order to do complexity analysis.
14:27:19 <Saizan> mkaemmer: yes, thanks :)
14:30:48 <michaelfeathers> So, is there a good reference for understanding performance aside from the bits and pieces in RWH?
14:30:49 <fnord123> dons: Xdamage and Xshape bindings: http://www.vorpalcore.com/node/5
14:31:06 <fnord123> dons: as maintainer of X11, thought you'd like to know.
14:31:39 * ski accidentally botched screen
14:31:49 <ski>   infixr 5 :,++
14:31:49 <michaelfeathers> Maybe I should sit down and do some reductions by hand with the left-outermost rule.
14:31:51 <ski> Saizan : ^
14:31:55 <dons> fnord123: submit patches, i can apply them
14:32:40 <fnord123> they're separate packages. hm, I guess I could add them, but I'm not sure how to make the possible dependencies on -lxdamage in x11.cabal
14:32:45 <fnord123> I'll take a look, though
14:33:32 <dons> fnord123: hmml
14:33:37 <dons> maybe a separate package then.
14:34:06 <Saizan> michaelfeathers: there's a book and papers on the STG machine, which is what's used in GHC, then you can read about RULES and foldr/build or stream fusion
14:34:17 <ski> michaelfeathers : Chris Okasaki discusses complexity of lazy algorithms a bit in "Purely Functional Data Structures"
14:40:08 --- mode: ChanServ set -o dcoutts
14:43:48 <bcw> for a few minutes i thought the above discussion meant X11 was written in Haskell... but now I realize that would be stupid, X11 has been around far longer than Haskell
14:44:32 <codolio> The Simons went back in time to rewrite it in Haskell.
14:44:52 <MarcWeber> bcw: There is X11 client library written in python. (I don't think its mantained any longer which doesn't matter).. So its possible to some extend.
14:45:29 <bcw> codolio, heh.
14:45:47 <pikhq> bcw: If X11 were written in Haskell, it would be much, much nicer.
14:45:48 <bcw> MarcWeber, hmm.
14:46:06 <monochrom> X11 was written in Haskell. Haskell was lazily invented retrospectively when people actually looked for source code.
14:47:08 * ski str Fudgets directly talked with X
14:47:50 <bcw> pikhq, yeah, i bet it would.
14:48:20 <bcw> MarcWeber, so it's  a reimplementation of part of X11, then?
14:48:59 <fnord123> haskell probably couldn't implement the X protocol. It's been proven to have bugs in the actual protocol, from what I read. Surely a haskell compiler would flag some type errors. :)
14:49:36 <pikhq> X, IIRC, has many race conditions.
14:50:25 <bcw> what is it actually written in?
14:50:38 <fnord123> c
14:50:50 <bcw> ok, that makes sense
14:54:24 <dcoutts> MarcWeber: you asked earlier about hsdns-0.0
14:54:48 <dcoutts> MarcWeber: the problem there is that it uses a version tag
14:55:04 <dcoutts> it's actually hsdns-0.0-2006-04-08
14:55:27 <dcoutts> MarcWeber: and these tags are deprecated and most of the infrastructure does not understand them
14:55:41 <dcoutts> MarcWeber: so that's why it's not listed on the hsdns package page
14:55:58 <dcoutts> and why cabal-install gets the wrong download url
15:11:28 <Daimonic> @src dropWhile
15:11:38 <lambdabot> Source not found. I am sorry.
15:13:08 <pikhq_> @src drop
15:13:08 <lambdabot> drop n xs     | n <= 0 =  xs
15:13:08 <lambdabot> drop _ []              =  []
15:13:08 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
15:25:21 <Vulpyne> Hmm, does HDBC-MySQL not support stored procedures?
15:33:29 * shapr boings cheerfully
15:34:24 <gwern> tiggers are stornry good at boinging!
15:36:17 <fbru02> hey guys in my everlasting quest to learn haskell, i come to realize that i didnt understand well the meaning of bind, and that is the last piece in the puzzle, having written my own monads i realize now that the meaning of >>= is that given a monadic value and function from this value to a new monadic value we "unbox" the first value and then apply the function and we get another value of the same monadic type. anyone cares t
15:36:48 <gwern> fbru02: cut off after cares
15:37:11 <pikhq> fbru02: Yeah, that's pretty much it.
15:37:13 * dufflebunk runs away with the remainder of fbru02's message
15:37:24 <Zao> The truncat meo at dufflebunk
15:40:32 <fbru02_> thanks guys ! :) learning this language is a challange for me
15:40:51 <blackdog> @seen mike-burns
15:40:52 <lambdabot> mike-burns is in #haskell and #haskell-freebsd. I last heard mike-burns speak 1d 58m 3s ago.
15:41:56 <Saizan> for a sufficiently general notion of "unbox" at least
15:42:28 <monochrom> I use "pass on" rather than unbox.
15:42:54 <soupdragon> unbox :: Monad m => m a -> a
15:43:29 <Berengal> soupdragon, more like unbox :: Monad m => m a -> Maybe SegFault
15:43:42 <blackdog> mike-burns: not entirely sure Hubris is ready for screaming legions of rubyists, but thanks for the plug anyway :)
15:43:51 <monochrom> But postmodernism implies that anything you say is right.
15:43:51 <pikhq> unsafePerformMonad :: Monad m => m a -> a
15:43:51 <glguy> I like to think of it as a function that turns (a->m b)'s into m a -> m b's
15:44:03 <glguy> lifting the argument into the monad
15:44:10 <soupdragon> heh
15:44:24 <copumpkin> pikhq: or just (Copointed m, Monad m) => m a -> a
15:45:26 <ski> (glguy : *nod*)
15:46:02 <pikhq> copumpkin: Or just unsafePerformIO shootTheMissiles
15:46:10 * soupdragon think about it as taking m a -> m (m b) and then joining
15:46:43 <glguy> no no no, you either fire or launch the missles!
15:46:58 <Berengal> I think of it as a function Monad m => m a -> (a -> m b) -> m b
15:47:02 <ski> (from the ability to go from a value of type `a' to a value with type `b', while performing `m'-effects, we get the ability to first perform whatever effects needed to produce the `a', and then continue as before with more effects to produce the `b')
15:47:24 <glguy> Berengal: you've been sucked into the flip (=<<) trap!
15:47:42 <Botje> is that like the venus flip trap?
15:48:10 * ski wonders whether that explanation was too convoluted
15:48:36 <Berengal> First I used to not get monads. Then I used to think they were pretty neat magical things. Then I used to think they were neat mathematical entities. Now I think they're a neat combinator library
15:48:42 <ski> @type venus flip trap
15:48:43 <lambdabot> Not in scope: `venus'
15:48:44 <lambdabot> Not in scope: `trap'
15:50:22 <glguy> @type ?venus flip ?trap
15:50:23 <lambdabot> forall t t1 a b c. (?trap::t, ?venus::((a -> b -> c) -> b -> a -> c) -> t -> t1) => t1
15:50:53 <fbru02_>  what's venus flip trap ? :)
15:50:56 <Berengal> Heh, trap got 't' as its type variable. How humorous
15:50:57 <ski> > reverse "trap"
15:50:59 <lambdabot>   "part"
15:51:40 <pikhq> @type flip . flip .  flip . flip . id
15:51:41 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:51:59 <ski> fbru02_ : the Venus Flytrap is a carnivorous plant
15:52:12 <pikhq> Well, that's certainly the most *pointless* way to write that.
15:52:43 <fbru02_> now that i finally got it ... i think there is no more meaning in my life :P
15:52:56 <ski> @pl flip . flip . flip . flip . id
15:52:56 <lambdabot> id
15:53:06 <ski> MORE POINTLESS
15:54:09 <glguy> @pl test
15:54:09 <lambdabot> test
15:54:20 <pikhq> B... Uh...
15:54:21 <pikhq> :t id
15:54:21 <fbru02_> i want to write a simple web server, how should i parse the requests ? using parsec ?
15:54:22 <lambdabot> forall a. a -> a
15:54:22 <glguy> so we can get lambdabot to print anything letter string
15:54:27 <glguy> without hte leading space
15:54:29 <glguy> via ?pl
15:54:32 <pikhq> DARN TYPE SYSTEMS
15:54:37 * glguy ponders
15:54:38 <soupdragon> @pl 1 + "foo"
15:54:39 <pikhq> ... Oh, right.
15:54:39 <lambdabot> 1 + "foo"
15:54:52 <pikhq> :t id :: (a -> b -> c) -> a -> b -> c
15:54:54 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:55:10 <glguy> , "test"
15:55:10 <soupdragon> @pl 3 * ((\x -> fst (2 * x, "foo")) 45)
15:55:11 <lambdabot> 270
15:55:13 <lunabot>  "test"
15:56:21 <pikhq> @pl \x y z -> (z,y,z)
15:56:22 <lambdabot> const (join . flip (,,))
15:56:32 <bcw> > reverse $ words "I am the very model of a modern major general"
15:56:34 <lambdabot>   ["general","major","modern","a","of","model","very","the","am","I"]
15:57:43 <ski> > unwords . transpose . words $ "sator arepo tenet opera rotas"
15:57:44 <lambdabot>   "sator arepo tenet opera rotas"
15:58:38 <pikhq> @pl do x <- f; g; return x
15:58:39 <lambdabot> (line 1, column 10):
15:58:39 <lambdabot> unexpected ";"
15:58:39 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
15:58:58 <ski> @. pl undo do x <- f; g; return x
15:58:58 <lambdabot> (g >>) . return =<< f
15:59:10 <pikhq> Kthx
15:59:18 <ski> you forgot "bye"
16:00:17 <jcd1> did you mean: bai?
16:01:04 <ski> (ask pikhq :)
16:01:36 <bcw> dinner time. bbl.
16:05:20 <mike-burns> blackdog: Hope you don't mind me linking to it in that context; I just want more people to know that they have options.
16:13:33 <dons> blackdog: yo, what's up with the JHC dep on Hubris?
16:31:38 <Axman6> hey dons, you wouldn't be able to have a look at a proof for me would you? it is for an assignment, so i'm not after too much help, just wanted to make sure i haven't left out anything significant: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8138
16:32:20 <copumpkin> hah, I was just about to ask blackdog about the JHC dep on hubris but then saw dons had asked a few lines up
16:33:10 <mike-burns> It's because ghc doesn't produce dynamic libraries, yet.
16:33:55 <copumpkin> but it does, just not 6.10.x
16:33:59 <mike-burns> Right.
16:35:03 <mike-burns> He and I discussed this a few days ago; if he continues to work on Hubris he'll port it to work under ghc when 6.12 works.
16:35:14 <mike-burns> (He said, paraphrasing.)
16:47:32 <Axman6> xomg, xmonad is following me on twitter :o
16:49:35 <vav> And chicago hug has a facebook page. What are these modern interwebz coming to these days! When I was a young man I had to boot up through broken glass in the snow .... mumble grumble
16:49:39 <monochrom> Whoa?! software follows people?!
16:49:57 <monochrom> I hope Windows 7 won't follow you next. :)
16:50:03 <shepheb> monochrom: didn't you hear? xmonad achieved sentience a few days ago.
16:50:12 <monochrom> I didn't hear.
16:50:16 <shepheb> it's working its way through RWH now.
16:50:35 <pikhq> shepheb: Viva la singularity
16:51:04 <bcw> reminds me of this year's april fools joke on google
16:51:05 <shepheb> it's already, I think, made the obvious leap from managing windows to managing their contents, and thereby controlling our perceptions.
16:51:07 <vav> having a kid with lambdabot, too, they were thinking of Skylar, Skyne, some name like that
16:51:44 <shepheb> I for one welcome our new Haskell overlord.
16:51:45 <copumpkin> mike-burns: actually looking at hubris I don't see much beyond using dl
16:53:33 <mike-burns> copumpkin: Are you suggesting that Hubris could be done with ghc 6.10?
16:54:00 <mike-burns> 'Cause I'm pretty sure it will work with 6.12, from what I hear of 6.12.
16:54:27 <copumpkin> mike-burns: nope, just saying I don't see much code in the project yet :) it just appears to be using the dynamic linker to load a c symbol from the dynamic library and use it
16:54:56 <mike-burns> Yup, looks simple so far.
17:02:27 <blackdog> mike-burns: no, it's cool :) just a little unprepared for it
17:02:43 <blackdog> dons: Dynamic library support in ghc seems to be broken atm.
17:03:06 <blackdog> HEAD with --enable-shared wouldn't build at all on Mac, and it looped on build on my linux install
17:03:46 <blackdog> i assume that Duncan's hacking away at it madly and i'm watching blog.well-typed.com for updates, but if i can't build a dylib, i can't link from ruby.
17:04:24 <dcoutts> blackdog: we're not expecting it to work on OSX, nobody is working on it
17:04:31 <blackdog> whoops, what mike-burns said
17:04:33 <blackdog> oh, hey duncan
17:04:51 <blackdog> do you anticipate it being much work? i'm happy to look at it
17:04:52 <dcoutts> not that it should be hard, the first supported platform for ghc's shared lib stuff was OSX
17:05:05 <SamB> dcoutts: is that documented not to work ?
17:05:24 <dcoutts> SamB: no, it's not documented to work, quite different :-)
17:05:38 <SamB> specifically not documented to work?
17:05:41 <dcoutts> SamB: knowing it doesn't work would require access to an OSX box
17:06:24 <SamB> what, haskell.org can't afford OS X buildbots?
17:06:33 <blackdog> dcoutts: there are buildbots available, aren't there?
17:06:43 <blackdog> or are you just not testing with --enable-shared?
17:06:55 <dcoutts> blackdog: yes there are OSX buildbots
17:07:14 <SamB> and ... does haskell.org actually own any of them?
17:07:25 <dcoutts> blackdog: it'd be a very painful development method to switch on --enable-shared and keep checking how and why the OSX build fails
17:07:36 <dcoutts> SamB: no
17:07:41 <SamB> oh.
17:07:57 <dcoutts> haskell.org doesn't own much at all :-)
17:07:59 <SamB> well, has anyone thought of asking for a shell account on one of the buildbots or something?
17:08:05 <dcoutts> except sparky.haskell.org
17:08:19 <dcoutts> SamB: it's also lack of time and resources
17:08:20 <blackdog> dcoutts: while i've got you - what's the current status on linux?
17:08:32 <dcoutts> blackdog: it's now on by default I believe
17:08:42 <dcoutts> on x86 and x86-64
17:09:13 <dcoutts> yes, it's been enabled by default since last Friday
17:12:05 <dcoutts> SamB: so it's not that it can't be done to get an OSX account etc etc, but the IHG asked us to make it work on Linux and Windows.
17:12:29 <SamB> the who?
17:12:31 <dcoutts> and in my spare time I have higher priorities than supporting OSX :-)
17:12:50 <dcoutts> SamB: http://industry.haskell.org/
17:14:33 <mmmulani> how can I read in all available input?
17:14:36 <dcoutts> blackdog: so yes if you've got the time and inclination then it'd be great to have a go and see what needs to be done to get shared libs going on OSX now, it's likely just lots of little things here and there, bit rot and churn.
17:14:56 <dcoutts> mmmulani: getContents
17:15:02 <blackdog> dcoutts: righto. got a bit of a deadline here so i might try to get a spike of Hubris working with ghc on linux first
17:15:18 <blackdog> but ruby hackers are macheads, by and large, so i'll have to make sure it works there too
17:15:24 <mmmulani> dcoutts: does that block?
17:15:45 <dcoutts> mmmulani: yes and no
17:15:46 <Alpounet> Hi.
17:16:29 <dcoutts> mmmulani: it does lazy IO, it gives you back a String representing all the remaining input the program will ever receive. So once you demand more than has actually been given yet then yes it'll block.
17:16:54 <mmmulani> ohhh
17:16:54 <mmmulani> hmmm
17:17:07 <mmmulani> how can I get all the current received data?
17:17:15 <dcoutts> mmmulani: if you're doing an interactive terminal program then you might prefer getLine
17:17:41 <mmmulani> sadly no, I'm getting input that is not terminated
17:17:50 <mike-burns> blackdog: In a very related thing, I was thinking today about why Rubyists are so interested in testing their code, and especially TDD, and I've come to realize that this is partially due to limitations in Ruby: no static analysis, unexpected nil everywhere, mutation everywhere, all problems are run-time. Which lead me to the obvious solution: we should be writing Haskell instead.
17:18:09 <dcoutts> mike-burns: yes :-)
17:18:16 <blackdog> mike-burns: ssh, gotta keep it on the down-low
17:18:20 <mike-burns> Heh.
17:18:44 <mike-burns> Well I'm going to use that line of thought to drive my agenda.
17:19:08 <dcoutts> mmmulani: so are you looking for an equivalent of unix non-blocking read() ?
17:19:18 <mmmulani> uhhh yes
17:19:31 <mike-burns> As in it might take me longer to write because I don't know Haskell as well as I know Ruby, but less time to write because I have to write 1/10th the number of tests.
17:19:36 <mmmulani> well, I believe so
17:19:48 <dcoutts> mmmulani: see System.IO.hGetBufNonBlocking
17:20:00 <mmmulani> hmm I was looking at that
17:20:04 <mmmulani> what is the second parameter?
17:20:05 <blackdog> mike-burns: i'm giving a talk at the ruby group in sydney in september on Hubris. Hoping to Trojan-Horse a few people :)
17:20:19 <copumpkin> @hoogle hGetBufNonBlocking
17:20:20 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
17:20:41 <copumpkin> mmmulani: probably where it should read to?
17:20:42 <dcoutts> mmmulani: ok, that's a bit low level for you, try Data.ByteString.hGetNonBlocking
17:21:31 <blackdog> mike-burns: especially if you're using QuickCheck
17:21:54 <mike-burns> blackdog: Yes, totally. The abstractions are better in Haskell too.
17:21:57 <mmmulani> dcoutts: that looks wonderful
17:22:44 <maxote> what means the 3 letters JHC ?
17:22:45 <mike-burns> blackdog: I don't know any Rubyists from Sydney but I assume at least one of them reads my company's blog.
17:23:06 <copumpkin> maxote: John's Haskell Compiler ?
17:23:08 <dcoutts> maxote: I think it's John's Haskell compiler
17:23:09 <copumpkin> I think
17:23:21 <mike-burns> blackdog: I'm preparing a blog post where I talk about why we, as Rubyists, test so rigously, and what we can do about it.
17:23:44 <maxote> it's weird, what's JHC based of?
17:23:57 <copumpkin> maxote: he did it from scratch, as far as I know
17:24:10 <maxote> i will google it
17:24:19 <blackdog> maxote: John's Haskell Compiler, i think
17:24:59 <dcoutts> maxote: it's an original impl based on Grin
17:25:01 <blackdog> maxote: it's based on some work done by Urban Boquist
17:25:31 <blackdog> mike-burns: yeah, one of my mates tweeted about it, that's how i found out
17:25:43 <maxote> found, http://repetae.net/computer/jhc/
17:26:10 <dcoutts> maxote: in particular see the old page for the motivation: http://repetae.net/computer/jhc/jhc.shtml
17:28:03 <maxote> what's "Grin intermediate code"?
17:29:09 <Lemmih> maxote: GRIN is an intermediate language particularly suited for implementing lazy functional langauges.
17:29:27 <maxote> is not it G-machine?
17:29:27 <blackdog> maxote: a representation of comptutation - things like thunk updates and evaluation are explicitly represented
17:29:32 <mmmulani> dcoutts: that with hWaitForInput is working wonderfully, thanks a lot
17:29:48 <dcoutts> mmmulani: great
17:33:39 <blackdog> maxote: no. the idea was that if you explicitly represent thunk update, and compile your program as a whole, quite often you'll find opportunities to be strict and avoid buli
17:33:43 <blackdog> building the thunk in the first place
17:34:02 <maxote> ok
17:34:24 <gwern> dcoutts: you see john's latest email? he's creating a strang YAML-based format for compiling stuff ala cabal
17:34:47 <maxote> JHC says: It takes ridiculous amounts of memory and CPU.
17:34:59 <Lemmih> maxote: It opens up a whole array of optimization opportunities, even if you choose to be completely lazy.
17:35:07 <dcoutts> gwern: where do I find that?
17:35:12 <gwern> jhc ML
17:35:20 <maxote> it says: It leaks memory.
17:35:44 <gwern> well, jhc doesn't really do GC
17:35:45 <Lemmih> maxote: This is GRIN code, if you're interested: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8156#a8156
17:37:00 <Lemmih> maxote: lhc and uhc are two Haskell compilers that also use GRIN.
17:37:03 <dcoutts> gwern: I think it's probably a sign of madness, diverting off your main project and making a new generic build system. I know I must be mad. :-)
17:37:17 <gwern> dcoutts: it *does* seem to be a commonality
17:37:38 <gwern> I mean, we have john's jhc stuff, david's franchise stuff, alex's searchpath stuff...
17:37:47 * gwern is probably missing a few
17:39:17 <dcoutts> gwern: you might note on the mailing list that there's no particular reason jhc cannot support Cabal or why Cabal cannot support jhc.
17:39:29 <gwern> dcoutts: on the other hand, creating your own build system isn't too irrational a response to 'if cabal sucks so much let's see you do better'
17:39:38 <dcoutts> gwern: actually being able to build Cabal using jhc would be a good start. I've tried before.
17:39:53 <dcoutts> gwern: aye but it's such a time sink
17:40:11 <gwern> dcoutts: well, the email john is replying to says something along the lines of 'from the previous discussions I understand why jhc can't support cabal, but then what do we do?'
17:40:13 <rsnake> Hello! How can I define a class that has an optional attribute? e.g. State {name :: String, (optional) subState :: [State]}
17:40:21 <copumpkin> rsnake: use Maybe ?
17:40:30 <dcoutts> gwern: right but I don't really believe that
17:40:30 <copumpkin> :: Maybe [State]
17:40:51 <rsnake> Cool thanks!
17:41:01 <maxote> premature optimization is an evil axis
17:41:26 <dcoutts> gwern: there's some support in Cabal already, it worked once but it's mostly bit rotted I expect what with jhc changes and no working jhc to be able to test with
17:42:05 <gwern> I get the feeling john doesn't want jhc to work with cabal
17:42:06 <gwern> darn users
17:42:15 <dcoutts> gwern: yes I get that feeling too
17:42:23 <Lemmih> Me too. (:
17:42:36 <dcoutts> gwern: he certainly doesn't want to distribute jhc with Cabal
17:42:45 <dcoutts> bundled I mean
17:42:55 <dcoutts> like nhc, hugs and ghc do
17:42:55 * gwern has been thinking of redoing my drift cabalization just to spite john
17:43:34 <dcoutts> gwern: do you know if jhc actually works at the moment? If so, someone could fix the JHC module in Cabal.
17:43:47 <gwern> I think jhc works
17:43:50 <blackdog> dcoutts: jhc's been building fine
17:44:00 <dcoutts> blackdog: that's not the same thing :-)
17:44:02 <Lemmih> Does it work enough to build Cabal?
17:44:05 <blackdog> i've been using it for Hubris. Getting extra libraries to build is a bit of a pain, though
17:44:07 <maxote> i found  http://www.cs.uu.nl/wiki/UHC/WebHome  &  http://www.cs.uu.nl/wiki/Ehc/WebHome   are not these better than the incomplete JHC?
17:44:16 <dcoutts> blackdog: last time I tried, it could build itself but not most of the packages that are deps of Cabal
17:44:27 <dcoutts> like containers, directory, filepath
17:44:29 <dcoutts> basic stuff
17:44:35 <blackdog> dcoutts: containers is working now
17:44:39 <dcoutts> great
17:44:45 <Lemmih> maxote: Better is a subjective term. Personally, I like LHC the most.
17:45:04 <dcoutts> but actually you don't need to be able to build Cabal using jhc to use Cabal to build stuff using jhc
17:45:21 <dcoutts> so just a working jhc should be enough
17:45:22 <maxote> Large Hadron Collider?
17:45:22 <blackdog> still trying to get ByteString going. it's frustrating to spend so much time in basically administrative tasks, though.
17:45:32 <dcoutts> and something to test it on
17:45:38 <Lemmih> maxote: http://lhc.seize.it/
17:45:56 <Lemmih> maxote: I also very much like the Large Hadron Collider.
17:46:29 <blackdog> i've been meaning to ask, actually - is there a sensible way to mass-upgrade all the packages you have installed via cabal?
17:46:36 <blackdog> got this annoying situation of having multiple versions of the same package installed
17:46:42 <dcoutts> blackdog: so why does John say that jhc will not be able to work with ordinary .cabal files? Is he organising the standard libs in a completely different way or something?
17:47:13 <dcoutts> blackdog: you can run cabal upgrade and see what it says it's not going to upgrade because the feature is disabled :-)
17:47:15 <gwern> blackdog: cabal upgrade?
17:47:24 <blackdog> dcoutts: i think a lot of the flags don't make sense for other compilers - all the stuff with 'base' is ghc-specific, isn't it?
17:47:33 <maxote> is there any site of benchmarks of the tests's raws of GHC, JHC, UHC/EHC, LHC ?
17:47:33 <gwern> dcoutts: that's crazy talk; what's life for if not living dangerously?
17:47:43 <gwern> maxote: there used to be nobench
17:48:03 <dcoutts> blackdog: base is not ghc specific, it's shared between hugs, ghc and nhc, using some #ifdefs
17:48:22 <dcoutts> blackdog: what kind of flags? the .cabal format is designed to be compiler-agnostic
17:49:18 <dcoutts> blackdog: or did you mean Cabal command line flags, like runhaskell Setup.hs configure --blah --blah ?
17:49:23 <blackdog> dcoutts: not sure, i'm paraphrasing
17:49:26 <blackdog> the cabal flags
17:49:47 <blackdog> i don't know the history of it, i just want dynamic libs :)
17:49:53 <dcoutts> blackdog: right, there are some there to support specific compilers and have no meaning for others.
17:50:01 <dcoutts> it's not a blocker
17:50:50 <blackdog> dcoutts: i think john's argument is here : http://osdir.com/ml/jhc@haskell.org/2009-06/msg00024.html
17:51:01 <dcoutts> ta
17:51:30 <blackdog> @seen shapr
17:51:30 <lambdabot> I saw shapr leaving #scannedinavian, #haskell and #haskell-blah 23m 24s ago, and .
17:56:57 <abuiles> Hi, does it exist a function as pi, but for epsilon ?
17:57:18 <Saizan> i don't understand what they are saying about .cabal files and base, surely if you provide something that's not the base packages know about you'd have to modify the code as well as the .cabal file?
17:57:31 <Lemmih> abuiles: There's a package on hackage for that.
17:57:44 <Saizan> abuiles: exp 1
17:57:47 <Saizan> > exp 1
17:57:49 <lambdabot>   2.718281828459045
17:58:00 <Lemmih> abuiles: Can't remember its name. ieee something.
17:58:04 <dcoutts> Saizan: right, as far as I can see there's no problem with providing a package called 'base' that exports the same stuff as the shared one
17:58:25 <dcoutts> Saizan: hugs and nhc manage it and they do have wildly different impls of many things
17:58:32 <abuiles> Lemmih : Thanks
17:58:45 <abuiles> Saizan: Thanks
17:58:54 <monochrom> e is not epsilon.
17:59:08 <dcoutts> a lot of the files in base basically do ifdef HUGS; import Hugs.Blah and the rest of the module is for the GHC impl.
17:59:34 <copumpkin> abuiles: epsilon as in the smallest representable value in ieee 754?
17:59:37 <copumpkin> abuiles: or what?
18:01:09 <dcoutts> Saizan: the other thing that's wrong in that message is the issue of using hashes to avoid having to think about version numbers
18:01:16 <Saizan> the part about "jhc does it better because it hashes the interface" is quite misleading, if you consider whole-package interfaces you'd get a lot of false negatives too
18:01:34 <maxote> which these xHC compilers have JIT from?
18:01:35 <Saizan> and then comes the semantics differences
18:01:50 <copumpkin> maxote: none as far as I know
18:01:50 <dcoutts> and it only considers once you've got to the stage of having build things
18:01:56 <dcoutts> you need to decide what to build first
18:02:04 <copumpkin> maxote: given that they all compile to native code, and GHCi doesn't have a JIT
18:02:06 <dcoutts> that's what all the version numbers and deps are for
18:02:53 <Saizan> i guess it assumes that the developer will have it built and can share those hashes
18:03:10 <dcoutts> but then the developer has already chosen what versions of all the deps to use
18:03:34 <dcoutts> which is a different problem to what cabal install solves
18:03:48 <dbelange> Lazy evaluation == just-in-time
18:03:51 <dcoutts> which is selecting source packages to get a set of binary packages
18:04:11 <maxote> i think that a JIT Haskell can inline most of the code in the hottest sections, and lesser code in the coldest sections.
18:04:41 <maxote> not all the code should be inline as do almost Haskell compilers
18:05:47 <maxote> by example, the JavaScript engine V8 from Google uses part of code from Sun
18:06:12 <hackagebot> GLFW 0.4.1 - A Haskell binding for GLFW (PaulLiu)
18:06:18 <Saizan> dcoutts: i don't think it's considering giving users the option of using dependencies for which the hash doesn't match exactly, so what the developer had is what you get..
18:06:21 <maxote> and it has JIT
18:06:38 <dcoutts> Saizan: exactly
18:10:24 <sjanssen> dcoutts, Saizan: what's this thread you're discussing?
18:10:41 <Saizan> http://osdir.com/ml/jhc@haskell.org/2009-06/msg00024.html
18:11:01 <sjanssen> oh, JHC list.  Don't think I subscribe to that
18:11:27 * Saizan neither
18:13:18 <sjanssen> Saizan: I think John is biased against Cabal (a well known difference of opinion), and that causes him to make pessimistic assumptions
18:13:43 <dcoutts> sjanssen: right
18:14:29 <Saizan> about base maybe he's misunderstanding the presence of the base tarball on hackage
18:14:31 <sjanssen> packages on Hackage don't need to support jhc, jhc needs to support a base-like API
18:15:24 <mmmulani> how do I cast a Char into a Word8?
18:15:53 <copumpkin> fromInteger . ord
18:15:57 <sjanssen> fromIntegral . ord
18:16:00 <copumpkin> whoops
18:16:01 <copumpkin> yeah :P
18:16:15 <copumpkin> :t ord
18:16:16 <lambdabot> Char -> Int
18:16:27 * copumpkin is not a fan of Int there
18:16:49 <mike-burns> I don't know the history of jhc, cabal, and all this. Why is John biased against cabal?
18:16:51 <monochrom> > fromIntegral 'a' :: Integer
18:16:53 <sjanssen> mmmulani: note that Char has characters larger than \255, and this isn't exactly a "cast"
18:16:53 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
18:16:53 <lambdabot>    arising from a use of...
18:16:53 <mmmulani> oh, Word8 is 8 bits?
18:17:04 <pikhq> > length ['\0'..]
18:17:05 <lambdabot>   1114112
18:17:07 <copumpkin> mmmulani: that's what the 8 means
18:17:14 <sjanssen> mmmulani: yeah, all the WordX types are X bits wide and unsigned
18:17:16 <mmmulani> copumpkin: ahah thanks :P
18:17:17 <pikhq> > length ([0..] :: Int)
18:17:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:17:29 <pikhq> > length ([0..] :: [Int])
18:17:34 <lambdabot>   mueval-core: Prelude.read: no parse
18:17:34 <lambdabot>  mueval: ExitFailure 1
18:17:49 <monochrom> When I invent a programming language I will use Word100 to stand for 8-bit words. :)
18:17:51 <pikhq> ... Surely that's of finite length?
18:17:54 <sjanssen> copumpkin: Int is the most reasonable type in Haskell '98 to use
18:17:55 <copumpkin> > length ([minBound..maxBound] :: [Word8])
18:17:57 <lambdabot>   256
18:18:03 <mmmulani> how do you convert Word8 -> String?
18:18:04 <copumpkin> sjanssen: ah, Word isn't in h98?
18:18:11 <dcoutts> mike-burns: the basic difference comes down to how people would wish to solve the package configuration problem and the balance of powered between developer and packager which is reflected in the kind of configuration language you end up with.
18:18:40 <Lemmih> ?remember monochrom When I invent a programming language I will use Word100 to stand for 8-bit words. :)
18:18:41 <dcoutts> mike-burns: essentially it's the autoconf ./configure model vs a package management dependency model
18:18:42 <lambdabot> I will remember.
18:19:07 <pikhq> copumpkin: Note that a Char is a Unicode character. Word8 is not what you want. ;)
18:19:10 <mike-burns> dcoutts: Ah I see now. Thanks for clearing that up.
18:19:16 <copumpkin> pikhq: don't tell me :P
18:19:35 * copumpkin forwards pikhq's message to mmmulani
18:19:35 <pikhq> copumpkin: I SHALL JUST TO BE CONTRARY.
18:19:37 <pikhq> copumpkin: Note that a Char is a Unicode character. Word8 is not what you want. ;)
18:19:40 <rsnake> Is there a way to do something like [(a, b) | a <- [1..5], b = a + 2] ?
18:19:54 <dcoutts> mike-burns: it gets pretty complicated and it's not always obvious what the disagreements are over fundamentally
18:19:59 <mmmulani> rsnake: [(a, a + 2) | a <- [1..5]]
18:20:04 <mike-burns> rsnake: [(a,a+2) | a <- [1..5]]
18:20:19 <ray> stereo
18:20:19 <rsnake> Cool, thanks
18:20:23 <pikhq> rsnake: [let b = a+2 in (a,b) | a <- [1..5]]
18:20:42 <mike-burns> dcoutts: That kind of disagreement will quickly turn religious.
18:20:51 <dcoutts> mike-burns: yup :-)
18:23:34 <sjanssen> so does JHC actually work now?  Garbage Collection?  A frontend that understands most Haskell code?
18:24:46 <maxote> JHC is more centered to the code generation than the GC code, JHC doesn't care the GC.
18:25:17 <dolio> JHC is supposed to have region inference, so you don't need GC. :)
18:25:30 <dolio> But it doesn't work or something, so you use Boehm.
18:25:56 <sjanssen> dolio: yeah, it's been "supposed to" for a long time.  I just want to know if JHC is practical
18:25:58 <Lemmih> Region inference doesn't work that way. It's not really an alternative to GCs.
18:26:50 <solrize> lemmih is there some obstacle to having RI -and- a GC?
18:26:57 <solrize> i've never understood why not use both
18:27:13 <solrize> let the GC clean up the stuff that RI can't figure out
18:27:17 <dolio> That was the original lhc plan, no?
18:27:42 <Lemmih> solrize: The only way RI can be practical is in tandem with a normal GC.
18:28:56 <solrize> hmm, i thought there were a bunch of pure-RI systems
18:28:56 <Lemmih> dolio: No, RI is silly IMO.
18:29:10 <dolio> Huh.
18:29:17 <solrize> RI seems like a great idea when it works
18:29:25 <blackdog> dolio: it's a bit more iffy in lazy systems, too - things escape everywhere
18:29:38 <dolio> Yeah, I could see that.
18:29:44 <solrize> blackdog hmm yeah that makes sense
18:29:59 <maxote> a two-generation stop-world GC is efficient
18:31:15 <maxote> but mutators are required, i don't know if Haskell code can manage these mutators
18:31:27 <maxote> and write-barriers
18:32:01 <Lemmih> maxote: Mutation is fine. As long as you only mutate, say, '2+2' into '4'. (:
18:32:57 <Lemmih> maxote: That is, changing things is fine as long as they stay the same.
18:33:10 <maxote> it's not mutation, it's mutator to separate phantom allocated cells, allocated cells and unallocated celss
18:34:47 <Lemmih> maxote: I disagree. The mutator mutates the graph that is your program. How it does it is an implementation detail.
18:35:20 <Philippa_> Lemmih: I don't think RI's silly in a language that can actually talk about regions. Silly if you don't have that, though
18:35:44 <bcw> i have a question: does haskell have a modular exponentiation function?  or does (x ** y `mod` n) have some laziness/magic that avoids calculating the full exponential expression?
18:35:56 <copumpkin> bcw: unfortunately not
18:36:09 <Lemmih> Philippa_: You mean when the regions are exposed/managed by the programmer?
18:36:24 <bcw> copumpkin, it has no such function or no such laziness/magic?
18:36:38 <copumpkin> there is no such function, and there is no such laziness or magic
18:36:44 <copumpkin> so it's currently a bad idea to write that
18:36:49 <bcw> damn
18:36:53 <copumpkin> @src (^)
18:36:54 <lambdabot> x ^ 0            =  1
18:36:54 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
18:36:54 <lambdabot>   where f _ 0 y = y
18:36:54 <lambdabot>         f x n y = g x n
18:36:54 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
18:36:55 <lambdabot>                       | otherwise = f x (n-1) (x*y)
18:36:58 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
18:36:59 <solrize> gmp has a very efficient modexp.  it would be useful to expose it somehow.
18:37:06 <copumpkin> solrize: yeah, I was going to but forgot
18:37:17 <copumpkin> it could be exposed and also be a rewrite rule
18:37:22 <Philippa_> Lemmih: More or less. Programmer can add info where the inference algorithm's not figuring stuff out sensibly, that sort of thing
18:37:45 <Philippa_> Preferably, programmer has access to everything the target language can do with regions
18:38:02 <Lemmih> Philippa_: I highly doubt that RI can be used as the sole method of memory allocation. Even more so if it has to be done automatically.
18:38:30 <gwern> I was reading the retrospective on RI recently
18:38:43 <gwern> seems to be one of those nice ideas which doesn't quite work out
18:38:58 <solrize> what retrospective?
18:39:14 <gwern> solrize: the retrosepctive on region inference linked in the -cafe thread rectrnly
18:39:46 <solrize> hmm
18:40:00 <gwern> Lemmih: although the retrospective did mention that they made any number of ML programs run with RI only
18:40:20 <Lemmih> gwern: And those programs leaked memory.
18:40:21 <solrize> i remember seeing a paper at least a few years old, about RI in an ML system, maybe MLKit
18:40:24 <gwern> and that RI+GC was worse than either alone, iirc
18:41:22 <Lemmih> (Or they easily could leak memory if they weren't tuned by the authors.)
18:46:00 <BMeph> Sounds like benl needs to get back to working Disciple. :)
18:47:27 <blackdog> BMeph: think he's giving a talk on it at FP-Syd soon, so he must have something ready
18:50:16 <BMeph> blackdog: Nice! :)
18:51:19 <_randomwords_> If I have an array is there a way of performing, for example, an IO action for every element without first construcing the assocs of that array? There is a mapArray functin but this constructs a new array
18:51:47 <blackdog> BMeph: I'm particularly happy about it because I'm giving a talk on TBC, so i'll get to ride on his coat-tails :)
18:52:16 <moonpatrol> > [ n | n <- [1 .. ] ] !! 12987
18:52:18 <lambdabot>   12988
18:52:25 <moonpatrol> HA! i feel all powerful now.
18:52:44 <monochrom> > 12988
18:52:45 <lambdabot>   12988
18:52:51 <monochrom> I feel simplified.
18:53:01 <moonpatrol> you obviously never programmed in java.
18:53:15 <moonpatrol> ouch burn! :-(
18:53:16 <monochrom> > 2*2*17*191
18:53:18 <lambdabot>   12988
18:53:28 <FunctorSalad> rewrite <- inverse_inverse monochrom
18:53:34 <FunctorSalad> there, desimplified ;)
18:53:40 <mike-burns> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8158#a8158 -- I feel Web 2.0
18:54:29 <moonpatrol> hahaha
18:54:40 <moonpatrol> this is why i like you all so much...
18:54:47 <yrlnry> Please advise me on how to tidy this up:  http://pastebin.ca/1527383
18:54:52 <monochrom> I programmed in Java.
18:54:57 <yrlnry> I have a repeated expression I don't know how to get rid of.
18:55:01 <Zao> monochrom: My condolences.
18:56:38 <monochrom> I guess I don't understand emotion.
18:57:22 <maxote> remember the ElectricalFire ef from mozilla
18:57:23 <monochrom> Dunno why people would generate thrill, hatred, pain, itching, ... towards mere programming languages.
18:57:37 <maxote> now, it's not available
18:57:39 <yrlnry> How about rage?
18:57:56 <bcw> yrlnry, can't you just make a separate function that does maybeToList . f  and use that where all those expressions are?
18:57:57 <maxote> http://www.mozilla.org/projects/ef/faq.html
18:57:57 <mike-burns> yrlnry: Maybe it's because I'm not quite skilled enough in Haskell, but I don't see anything obvious. My first guess would be to change the order of the arguments to applyEverywhereExpr' and hope something falls out from that.
18:58:25 <yrlnry> bcw: How?
18:58:26 <mike-burns> monochrom: I agree with you but we may be in the minority.
18:58:49 <maxote> the idea was very simple
18:59:12 <moonpatrol> monochrom: if you've ever programmed in VB.. you would know rage against a programming language.
18:59:17 <bcw> yrlnry,   myListFn f = maybeToList . f
18:59:58 <monochrom> I have programmed in line-numbered BASIC.
19:00:11 <pikhq> So have I.
19:00:12 <Philippa_> monochrom: some people experience the discomfort of working with bad tools more strongly than others. Doubly so when they keep finding new ways to get in your way
19:00:20 <pikhq> I first programmed on an Apple II.
19:00:38 <Philippa_> the thing about line-numbered basic was that it didn't promise huge levels of ease that turned out to be a mirage the moment you tried to do anything interesting
19:00:40 <bcw> i used an Apple II in kindergarten :)
19:00:50 <bcw> not for programming, though
19:01:04 <Philippa_> VB had a habit of inverting the principle of least surprise
19:01:05 <moonpatrol> VB is far removed from the good thing that was BASIC..
19:01:22 <mike-burns> Java isn't a bad tool, though. It's just some programming language that has some great libraries.
19:01:31 <monochrom> I saw QuickBASIC. It was OK.
19:01:44 <SamB_XP> mike-burns: some bad programming language!
19:01:50 <mike-burns> Oh you guys ...
19:01:52 <yrlnry> bcw: f is an argument to applyEverywhereExpr'
19:01:57 <monochrom> I saw some early kind of Visual BASIC. It was also OK.
19:02:19 <SamB_XP> I don't remember GW BASIC being that great though
19:02:22 <bcw> yrlnry, yes, but you can make it be an argument to myListFn too
19:03:01 <yrlnry> So you're suggesting that I replace four instances of maybeToList . f   with  four instances of myListFn?
19:03:47 <mike-burns> yrlnry: Apply maybeToList to f before you call applyEverywherExpr' .
19:04:04 <mike-burns> Oh that doesn't make sense. Nevermind.
19:04:14 <bcw> yrlnry, yeah.  (i'm a relative newbie though, there may be a better way)
19:04:29 <Philippa_> mike-burns: a lot of us have had to do things with Java that it's really not suited to. If you find tedious makework painful or just aren't too good at time management and end up doing all-nighters at uni or something, that gives you some pretty strong negative stimulus
19:04:50 <yrlnry> bcw: to me, that seems totally pointless.
19:05:28 <bcw> yrlnry, ok.  hopefully someone else has a better idea then :)
19:05:31 <mike-burns> yrlnry: How about changing the signature of applyEverywhereExpr' such that f has to call maybeToList itself?
19:06:18 <yrlnry> I'm willing to change the type of applyEverywhereExpr', but I'm not willing to change the type of f.
19:06:35 <Saizan> yrlnry: http://pastebin.ca/1527391
19:06:53 <mike-burns> Ah well played.
19:07:22 <yrlnry> Saizan: thanks, that's what I was looking for.
19:07:36 <yrlnry> I couldn't figure out how to get the where clause onto all four of the parts of the main function.
19:07:56 <maxote> ElectricalFire is a Java Virtual Machine that uses JIT (Just In Time) compilation techniques to accelerate Java code execution. ElectricalFire was designed from the start to generate high-performance machine code and to be portable to many different processor architectures.
19:08:11 <maxote> now, it's dead and i wanted to get it
19:11:44 <Saizan> yrlnry: if you feel inclined: http://pastebin.ca/1527397 :)
19:12:17 <Saizan> changing some names it might be good
19:12:25 * BMeph coughs in a way that oddly sounds almost like *let-statements*
19:12:57 * edwardk wonders. Has anyone implemented idiom brackets as a quasiquoter?
19:13:02 <SamB_XP> BMeph: the what now?
19:13:10 <SamB_XP> what are these let "statements"?
19:13:38 <Saizan> edwardk: i don't think so, but she has them
19:13:54 <Saizan> however idiom brackets always looked broken to me
19:14:11 <edwardk> *nods*
19:14:20 <yrlnry> Saizan: thanks again.  I find the second one confusing.  Which do you prefer?
19:14:45 <BMeph> yrlnry: You could just use a case on the last argument instead. Hmm, let me look at the other suggestions first. :)
19:15:02 <edwardk> i'm just thinking something like many p = ps where ps = [$idiom| (:) p ps |] <|> pure []
19:15:25 <edwardk> Saizan: seems like it'd be pretty trivial to implement
19:16:00 <Saizan> edwardk: yeah, if the pure function is always a single identifier
19:16:01 <edwardk> or even sexier, if you allowed for infix application in idiom brackets: many p = ps where ps = [$idiom| p : ps |] <|> pure []
19:16:46 <Saizan> yrlnry: maybe if we had a sensible name for what's currently "go" ..
19:17:10 <edwardk> though that would probably run afoul of the fact that the precedence rules are lost to your quasiquoter =/
19:17:48 <SamB_XP> edwardk: how are idiot brackets supposed to work?
19:17:54 <SamB_XP> er. *idiom.
19:18:30 <edwardk> SamB: my recollection is they were basically just sugar for 'foo <$> bar <*> baz <*> quux'
19:18:37 <edwardk> but i might be wrong, its been a while since i read the paper
19:18:41 <yrlnry> Saizan: I called it applyToSubterms.
19:19:29 <maxote> 404 file not found -> http://www.mozilla.org/projects/ef/  ,  http://www-archive.mozilla.org/projects/ef/  , fucking Mozilla!
19:19:31 <Saizan_> edwardk: (got disconnected), reify should give you enough info
19:19:45 <edwardk> Saizan: for precedence?
19:19:48 <Saizan> reify should give you
19:20:00 <maxote> i remember the car parkings
19:20:03 <BMeph> edwardk: You got it.
19:20:17 <edwardk> bmeph: ?
19:20:33 <Saizan_> edwardk: yup, the Fixity field here http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html#t%3AInfo
19:20:34 <BMeph> edwardk: Your recollection.
19:20:44 <edwardk> BMeph: ah
19:20:52 <SamB_XP> edwardk: and what does |[ (foo bar) baz quux ]| expand to?
19:21:21 <Saizan_> heh, that's how they look broken to me :)
19:21:30 <edwardk> Saizan_: neat, now, can that be used to let haskell-src-meta actually get fixities right? =)
19:21:51 <edwardk> SamB_XP: its not my broken abstraction. i dunno ;)
19:22:34 <Saizan_> i guess that depends on how haskell-src-exts deals with fixities
19:22:45 <edwardk> as i understand it it doesn't see any of them
19:22:54 <edwardk> it'd be downright handy if it got the fixities right
19:23:13 <edwardk> basically everything winds up associated to the right
19:23:24 <yrlnry> idiom brackets?
19:23:45 <Saizan_> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.1.1/doc/html/Language-Haskell-Exts-Fixity.html#v%3AapplyFixities <- it seems it should work
19:23:59 <edwardk> oooh
19:24:07 <SamB_XP> yrlnry: yeah, maybe we should call them idiot brackets?
19:24:15 <edwardk> yrlnry: see http://www.cs.nott.ac.uk/~ctm/Idiom.pdf
19:24:18 <yrlnry> It seems like an inevitable coinage.
19:24:51 <yrlnry> Oh boy, Conor McBride.  Thanks.
19:25:29 <edwardk> Saizan_: yeah that covers applying them, but the package doesn't have a mechanism for extracting what fixities are in use in the expression
19:26:07 <Saizan_> shouldn't that doable by traversing the AST?
19:26:10 <Saizan_> *be
19:26:19 <aavogt> @wn idiom
19:26:22 <lambdabot> *** "idiom" wn "WordNet (r) 2.0"
19:26:22 <lambdabot> idiom
19:26:22 <lambdabot>      n 1: a manner of speaking that is natural to native speakers of a
19:26:22 <lambdabot>           language [syn: {parlance}]
19:26:22 <lambdabot>      2: the usage or vocabulary that is characteristic of a specific
19:26:24 <lambdabot> [8 @more lines]
19:26:42 <edwardk> Saizan_: yeah, theoretically, just sounds like a pain in the ass and something that should be available from the API. =) Whose package is it anyways?
19:27:02 <maxote> ElectricalFire has 10 years since that it was released in 1999 by Netcape
19:27:03 <edwardk> time to harass mmorrow i guess
19:27:31 <maxote> the Java JIT virtual machine in the Netscape browser
19:27:36 <Saizan_> haskell-src-exts is from nibro
19:27:50 <Saizan_> edwardk: there's an InfixApp constructor
19:27:51 <edwardk> yeah but language.haskell.meta.parse is what is used in most quasiquoters
19:28:01 <edwardk> and it uses the broberg package
19:29:20 <mmorrow> edwardk: i've been using a hacked version of http://www.cs.mu.oz.au/~bjpop/code/Infix.hs for my projects
19:29:33 <edwardk> ah cool. there is a parseHsExp that yields a haskell-src-exts
19:29:49 <Saizan_> nibro is Niklas Broberg :)
19:29:52 <edwardk> expression
19:29:55 <edwardk> Saizan_: yeah
19:30:17 <edwardk> Saizan_: i was just pointing out the package that i wanted to patch was the one that provided the nice wrapper =)
19:30:42 <edwardk> mmorrow: did you see the bit above about the Fixity information available from reify these days?
19:30:43 <Saizan_> ah, k
19:30:51 <mmorrow> edwardk: ah yeah. you may want to peek at the extensions it's enabling, since it tries to only allow those that TH supports since it's main purpose is to support the parse* where * is the TH syntax
19:31:02 <mmorrow> edwardk: ah no
19:31:09 * mmorrow reads scrollback
19:31:31 <edwardk> mmorow: that was the topic, whether or not the haskell-src-meta parser could use reify to just extract all of the unknown fixities for any fixity defined outside of the current module
19:31:58 <mmorrow> hmm.
19:32:08 <mmorrow> i think it could, yeah.
19:32:09 <edwardk> that would cover all of the prelude fixities, etc. in one fell swoop, and could just use the haskell-src-exts applyFixities operation
19:32:24 <mmorrow> edwardk: ohh, ok. i see what we're talking about now.
19:32:38 <edwardk> and then I'd be happier because kata's embedded haskell syntax would just work right rather than always being right associated =)
19:32:45 <mmorrow> hehe
19:32:50 <Saizan_> well, you'd need the parse function to be in the Q monad
19:32:59 <edwardk> Saizan_: its a quasiquoter
19:33:04 <edwardk> Saizan_: so its already there
19:33:17 <mmorrow> edwardk: oh nice
19:34:03 <mmorrow> , src ''Fixity
19:34:04 <lunabot>  luna: Ambiguous occurrence `Fixity'
19:34:09 <mmorrow> grr
19:34:19 <edwardk> i'm just looking to allow expression quotations like: [$kata | class foo public bar x y = $(x ++ y) |]
19:34:22 <mmorrow> , src ''Language.Haskell.TH.Syntax.Fixity
19:34:23 <lunabot>  luna: Not in scope:
19:34:48 <edwardk> i'm already starting to jump through hoops to bring kata variables into scope via hoas for the template haskell snippet i'll be dumping into place there anyways
19:35:43 <edwardk> having the correct precedence there would clean up the kata quasiquoter and could clean up the jmacro quasiquoter, the interpolated-perl6 and interpolated-qq quasiquoters, etc.
19:36:14 <Saizan_> ?hackage jmacro
19:36:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/jmacro
19:36:42 <edwardk> Saizan_: take a look at it, its sclv's sexy-as-hell javascript quasiquoter
19:37:06 <mmorrow> edwardk: i think this is a good idea and definitely doable, i'll try to hack it in
19:37:31 <Saizan_> edwardk: and here i was writing js by hand
19:37:49 <mmorrow> , src ''Fixity
19:37:51 <lunabot>  data Fixity = Fixity Int FixityDirection
19:37:57 <mmorrow> , src ''FixityDirection
19:37:58 <edwardk> Saizan_: uses HOAS so you can do things like [$jmacro| function (x) { return $(foo x) } |] -- where foo is a haskell function which can expand code hygienically using the variable x!
19:38:00 <lunabot>  data FixityDirection = InfixL | InfixR | InfixN
19:38:27 <edwardk> mmorrow: awesome. i'll move on to other bits and pieces needed to get anywhere close to needing that, and check back in =)
19:38:47 <blackdog_>  /nick blackdog
19:38:55 <blackdog_> oops. sorry.
19:39:07 <edwardk> er actually i believe his antiquotations look like `( ... )` but you get the idea
19:40:27 <Saizan_> edwardk: yeah, i see
19:41:28 <mmorrow> yeah the HOAS thing for var hygiene is neat
19:41:48 <mmorrow> iirc you can also do
19:41:59 <mmorrow> [$jmacro| \x -> $(foo x) |]
19:42:26 <mmorrow> as a synonym for [$jmacro| function(x){return $(foo x)}|]
19:42:33 <Saizan_> yup
19:43:01 <mmorrow> that fixes the second biggest thing that bothers me about javascript :)
19:43:08 <mmorrow> the first being no TCO
19:43:58 <dolio> Dude, just write your own trampolines!
19:45:12 <mmorrow> dolio: yay!
19:45:14 <solrize> what about having some kind of js monad that sequences typed actions that get emitted as js after type erasure?
19:46:19 <mmorrow> solrize: HJavaScript does something kind of like that via a GADT
19:46:45 <mmorrow> where type erasure := prettyprint (although iirc they use Show :(
19:47:19 * SamB_XP thought that was called uglyprint
19:47:30 <solrize> neat
19:53:03 <mmorrow> dolio: (where by "yay!" i mean "STAB me with FORKS!")
19:53:18 <dolio> Are you arguing with Guido?!
19:53:23 <mmorrow> hehe
19:57:50 * Saizan_ doesn't see where the HOAS is used in jmacro
19:58:32 <edwardk> Saizan_: look at the Language.JMacro.QQ module (or something like that) it uses HOAS only temporarily during the encoding into TH
19:58:59 <edwardk> so that the template haskell variable names created will be haskell variable names and subject to scoping, etc.
20:00:02 <edwardk> see jm2th in Language.Javascript.JMacro.QQ
20:00:37 <edwardk> and the use of jVar, jForEachIn, jForIn, jLam, and jhFromList, which are 'locally HOAS'
20:01:33 <edwardk> Saizan_: i wasn't expecting it myself, and would never have noticed the subtle trick employed had Gershom not pointed it out to me when walking me through jmacro at hac phi
20:03:24 <Saizan_> edwardk: heh, i initially thought that was a dumb conversion
20:03:38 * Saizan_ reads more carefully
20:14:57 <mmorrow> , let manyy p = let ps = [$i| (:) p ps |] +++ return [] in ps in runP (manyy (string "zomg")) "zomgzomgzmog"
20:14:59 <lunabot>  luna: No instance for (Control.Applicative.Applicative
20:15:04 <mmorrow> awww :(
20:15:11 <mmorrow> edwardk: like that?
20:15:37 <mmorrow> edwardk: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.4/doc/html/Language-Haskell-Meta-QQ-Vixey.html
20:15:57 <mmorrow> i named it that before i knew what it really was, since vixey had the idea
20:16:44 <ray> it's just a list monad quasiquoter, isn't it?
20:17:11 <ray> oh wait
20:17:14 <mmorrow> , ppDoc <$> applicateQ "(,,) 42 [0..9] (Just 12)"
20:17:16 <lunabot>  (((,,) <$> 42) <*> [0..9]) <*> Just 12
20:17:18 <ray> i must be drunk
20:17:41 <mmorrow> , ppDoc <$> applicateQ "(,,) 42 [0..9] (Just 12) fmap \"zomg\""
20:17:43 <lunabot>  (((((,,) <$> 42) <*> [0..9]) <*> Just 12) <*> fmap) <*> "zomg"
20:17:56 <mmorrow> oops
20:18:05 <mmorrow> , ppDoc <$> applicateQ "(,,,,) 42 [0..9] (Just 12) fmap \"zomg\""
20:18:07 <lunabot>  (((((,,,,) <$> 42) <*> [0..9]) <*> Just 12) <*> fmap) <*> "zomg"
20:18:08 <mmorrow> ;)
20:18:31 <mmorrow> , $(applicateQ "(,,,,) 42 [0..9] (Just 12) () \"zomg\"")
20:18:33 <lunabot>  luna: Not in scope: data constructor `GHC.Unit.(,,,,)'
20:18:41 <mmorrow> :o
20:18:58 <mmorrow> , [$i|(,,,,) 42 [0..9] (Just 12) () "zomg"|]
20:19:00 <lunabot>  luna: Couldn't match expected type `[a]'
20:19:12 <mmorrow> oh right
20:19:19 * mmorrow slaps mmorrow
20:19:23 <ray> maybe if i had been exposed to monad comprehensions since i was a little boy
20:20:07 <ray> anyway, it'll be forever known as the vixey quasiquoter now, and it's all your falt
20:20:36 <mmorrow> , [$i|(,,) "hai" [0..9] "zomg"|]
20:20:38 <lunabot>  [('h',0,'z'),('h',0,'o'),('h',0,'m'),('h',0,'g'),('h',1,'z'),('h',1,'o'),...
20:20:51 <mmorrow> ray: heh
20:21:34 <mmorrow> , let a = "oh" in [$i|(,,) a "hai" "zomg"|]
20:21:34 <SamB_XP> but didn't vixey change identities?
20:21:36 <lunabot>  [('o','h','z'),('o','h','o'),('o','h','m'),('o','h','g'),('o','a','z'),('...
20:21:52 <mmorrow> SamB_XP: yeah, as i just found out
20:21:52 <ray> this must be how kleisli triples got named
20:22:30 <SamB_XP> I wish he/she hadn't ... I can never remember his/her new one ...
20:22:47 <mmorrow> she's soupdragon
20:22:47 <ray> i have no idea what it is either, but i have an excuse
20:22:55 <SamB_XP> oh yeah
20:22:58 <SamB_XP> soupdragon
20:23:05 <SamB_XP> I can always remember when I see it ...
20:25:09 <edwardk> mmorrow: ah yeah =)
20:25:28 <edwardk> mmorrow: the documentation for that module could be a bit better to indicate that it provides idiom brackets ;)
20:25:45 <mmorrow> edwardk: good point :)
20:25:55 <edwardk> all it says is that it was Vixey's idea. =)
20:26:09 <mmorrow> but but but there's a source link! ;)
20:26:25 <edwardk> any luck with fixities =)
20:26:27 <edwardk> ?
20:26:33 * mmorrow will fix that while he's at teh fixities
20:26:43 <edwardk> w00t
20:27:18 <mmorrow> edwardk: i've got a crapload of more "utilities" scattered across a few modules too that i'll add as well
20:28:18 <mmorrow> like e.g. "find all reachable types given this Name via reify" and various stuff operating on the resulting graph, and other misc
20:28:31 <edwardk> ah nice
20:29:18 <edwardk> i'm sitting here going back through and rewriting a bunch of monoidal code monadically in order to er... make a better monoid. it is sad
20:29:20 <mmorrow> ooh, and one handay one that generates a function skeleton for a type given a Name, which is a lifesaver for types with 10+ cons
20:29:28 <mmorrow> edwardk: heh
20:29:46 <solrize> bonfire of the fixities
20:30:05 <mmorrow> edwardk: `mkFunSkel' does this currently http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2822
20:30:43 <edwardk> heh
20:30:49 <deech`> Hi folks, does anyone here use Yi for more serious Haskell programming?
20:30:53 <edwardk> nice way to make sure you caught  all of the cases
20:31:24 <dancor> deech`: i try every once in a while
20:31:33 <dancor> one of these times it will work
20:31:36 <edwardk> now just tweak that slightly to make a Compos instance or derive Traversable
20:31:37 <mmorrow> yeah, that and to not have to refer to the haddocks in order to write each case for type's you're not familiar with/are massive
20:33:49 <deech`> dancor, there's a Yi video that seems to show some pretty tantalizing features. Just don't know how to use 'em because they are not documented.
20:35:54 <dancor> deech`: ya that's a large part of the current difficulties using Yi
20:38:50 <Nafai> And the advantage of Emacs over Yi, it's a little more more discoverable
20:41:36 <mmorrow> @pl flip foldl' ([],[]) (\(xs,ys) -> either (flip (,) ys . (:xs)) ((,) xs . (:ys)))
20:41:37 <lambdabot> foldl' (uncurry (ap (ap . (either .) . flip ((.) . flip (,)) . flip (:)) ((. flip (:)) . (.) . (,)))) ([], [])
20:41:43 <mmorrow> oo
20:42:04 <SamB_XP> so ... is Yi scriptable?
20:42:49 <mmorrow> SamB: if you have a haskell interpreter and/or dynamic compiler
20:43:06 <mmorrow> (and access to it in the same address space)
20:43:14 <ray> who needs scriptable, it's in haskell
20:43:17 <pikhq> Or if you write a Haskell "eval" function.
20:43:24 <SamB_XP> mmorrow: I meant, can you script it, not can you script it dynamically
20:43:27 <mmorrow> , eval "eval \"42\""
20:43:29 <lunabot>  <<Dynamic>>
20:43:32 <mmorrow> !
20:43:37 <ray> Â¡
20:43:47 <SamB_XP> that is, can you add stuff easily without ripping the whole thing to pieces?
20:44:10 <ray> like you can with xmonad, say
20:44:25 <ray> and i think the answer is yes
20:44:37 <SamB_XP> does it have theorems like Xmonad has?
20:45:06 <mmorrow> ray: tmp files are invalid!
20:45:10 <mmorrow> :)
20:46:25 <ray> my dream addition to oeis probably requires the use of eval
20:46:40 <mmorrow> ?
20:46:53 <edwardk> @seen ddarius
20:46:54 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah and #haskell-overflow 7m 1d 22h 16m 2s ago, and .
20:47:02 <ray> it's to be able to fetch haskell code to generate the sequence and return an infinite list
20:47:15 <mmorrow> ray: ah nice
20:47:31 <ray> the oeis database already has a field for code
20:47:38 <edwardk> ,seen ddarius
20:47:39 <lunabot>  luna: Not in scope: `seen'
20:48:02 <ray> i'd just need to perform some hackery and submit a bunch of haskell code to the oeis
20:48:09 <mmorrow> ray: totally, it's stuff like this that's the killer app waiting to be possible (w/out massive overhead in multiple dimensions)
20:49:16 <mmorrow> preflex: seen ddarius
20:49:17 <preflex>  ddarius was last seen on #haskell 76 days, 2 hours, 26 minutes and 26 seconds ago, saying: parsec2 is faster and what most libraries expect.
20:49:21 <edwardk> thanks
20:49:30 <mmorrow> preflex seen rulz
20:49:31 <preflex>  Sorry, I haven't seen rulz
20:49:31 <edwardk> hrmm
20:50:03 <edwardk> i was going to try to ask him if there was a good reason why the LanguageDef's in Text.Parsec.Language were LanguageDef's rather than GenLanguageDef's
20:50:19 <dino-> I'm trying to get set up in Windows. Unable to link darcs installed via the Platform's cabal-install because of curl.h missing. Is my only recourse for this stuff getting serious with mingw and building these things?
20:50:31 <edwardk> its kind of annoying to have to completely recreate them whenever you want to work over an iteratee that isn't built over Identity, but instead is built over some other monad
20:51:02 <dino-> Also, holy crap is life sad without apt or yum or pacman, etc.
20:51:31 <edwardk> I presume they exist with the simpler type as a historical accident -- parsec 2 only had LanguageDef, and it seems when parsec3 embellished that notion, it didn't bother enriching the types of anything in this module.
20:51:31 <ray> life is sad with half of hackage having dubious dependencies on sh
20:51:37 <Nafai> dino-: That's why I don't get how developers can be productive there :)
20:52:24 <dino-> ray, Nafai: It's absurd
20:53:09 <pikhq> I think it's absurd that not all languages have sh.
20:53:15 <pikhq> Erm. OSes.
20:53:23 <ray> someday i want to see haskell work on windows
20:53:32 <aavogt> cabal install has a -fcurl flag, which lets you build darcs
20:53:43 <Zao> I'm about to embark on the Fun Ride that is consuming Haskell DLLs from C#.
20:53:53 <Nafai> Zao: Sounds dangerous!
20:53:55 <mmorrow> ray: you may have to fix windows first
20:53:59 <Axman6> http://blogs.msdn.com/oldnewthing/archive/2004/06/03/147583.aspx wow
20:54:08 <mmorrow> ray: if you can manage to get a hold of the code that is.. ;)
20:54:09 <Zao> I seem to have misplaced my carefully constructed mingw+msys setup though.
20:54:15 <ray> fortunately, i'm not anti-windows
20:54:17 <dino-> I'm working on something that will have to work on Windows. It's not really negotiable for the target user(s). So Windows in a VM.
20:54:25 <ray> so i might be able to make that dream come true one day
20:54:33 <Zao> It would be quite lovely if GHC targetted VC++, but one can always dream.
20:54:49 <Zao> As embedding it currently requires DLL pong.
20:55:06 <SamB_XP> pikhq: it is kind of bad, yeah
20:55:09 <aavogt> hmm, turns out that the flag is -f-curl http://web.mornfall.net/blog/darcs_2.3_beta_4.html
20:55:17 <SamB_XP> but who knows how much of hackage uses bashisms?
20:56:24 <pikhq> ray: Windows cannot be fixed. It can, of course, be replaced, but Windows is pretty fundamentally flawed.
20:56:35 <kingdj> might it help to try cabal from a cygwin bash prompt?
20:57:01 <dino-> aavogt: Thanks, but it's still stubbornly complaining about curl.h :(
20:57:03 <ray> pikhq: when i cry myself to sleep, i'll cry extra hard thanks to you
20:57:33 <dino-> Ya, I'm using cygwin. It's the only civilized thing to do there.
20:57:41 <ray> that might be your problem
20:57:45 <dino-> mm
20:57:49 * mmorrow hands ray a tissue, and a blue screen of death
20:57:53 <pikhq> ray: It's the huge pile of cruft that Windows has built up.
20:58:01 <pikhq> ... Amazingly, much more cruft than is in UNIX.
20:58:07 <Zao> pikhq: I call them features.
20:58:13 <ray> how do people say these things with a straight face
20:58:14 <aavogt> dino-: strange, it worked for me on a pretty vanilla winxp system.  But it isn't available now to test.
20:58:17 <pikhq> Zao: ... You call three booleans features?
20:58:17 <ray> i'm not even talking about what you said
20:58:22 <ray> i just mean the word "cruft" here
20:58:24 <pikhq> Erm. Three boolean types.
20:58:35 <ray> regarding what you said, i simply disagree
20:58:51 <pikhq> ray: Three boolean types. With different semantics.
20:59:05 <Zao> I assume you're talking about bool, BOOL and VARIANT_BOOL?
20:59:08 <pikhq> That's just a *minor* detail in the Lovecraftian horror that is Win32.
20:59:16 <pikhq> Zao: BOOLEAN, BOOL, and VARIANT_BOOL.
20:59:40 <dino-> Still failed in that fabulous cmd term. Thanks for helping. I'll beat on it more tomorrow.
20:59:52 <ray> you need to get powershell now :)
21:00:20 <mmorrow> make sure it's ultimate edition though, or else you only get 12 chars for any given cmd
21:00:26 <SamB_XP> mmorrow: where did you get the BSoD?
21:00:41 <SamB_XP> 9x, or over-adventurous kernel-intrusive hackz?
21:00:46 <mmorrow> SamB_XP: by clicking "Start"
21:00:47 <pikhq> There's also that function floating around somewhere in the API to turn off memory protection...
21:01:03 <yrlnry> Thanks again for the reference to the McBride Idioms paper.
21:01:26 <SamB_XP> pikhq: that's probably for 9x too
21:01:37 <pikhq> Oh, and the in-kernel GUI and HTTP daemons.
21:01:57 <pikhq> SamB_XP: I suspect if it still works in NT-based OSes, then it first screams very loudly.
21:02:02 <abbe> hi all
21:02:07 <SamB_XP> pikhq: that's really only slightly worse than X
21:02:13 <pikhq> Microsoft may have some bad programmers, but they're not freaking *insane*.
21:03:02 <pikhq> I don't call X a good design, either. ;)
21:03:11 <abbe> s/some/all kinds of/ and Microsoft Research != Microsoft :-D
21:03:21 <abbe> On GNU/Linux, 'withFile "/proc/cpuinfo" ReadMode (\b -> hGetContents b >>= (return . lines ))' evaluates to []
21:03:36 <abbe> any ideas, why ? /proc/cpuinfo contains lines ending with '\n'
21:04:43 <mmorrow> abbe: hGetContents returns immediately, withFile finishes and closes the Handle, then you try to read the file
21:05:16 <abbe> oh, okay lazy evaluation...
21:06:02 <mmorrow> withFile "/proc/cpuinfo" ReadMode (\b -> Data.ByteString.Char8.hGetContents b >>= (return . Data.ByteString.Char8.lines ))
21:06:19 <abbe> mmorrow, and what if I never used the handle of the file, is withFile still going to open it.
21:06:21 <abbe> ??
21:06:34 <mmorrow> hmm, probably
21:07:07 <abbe> appending $! fixed it. 'withFile "/proc/cpuinfo" ReadMode (\b -> hGetContents b >>= (return . lines $!))'
21:07:29 <abbe> thanks mmorrow
21:07:32 <mmorrow> well, it'll definitely try to close it if you demand anything of the result of the IO action you pass to withFile, so i guess that means that i *has* to also open it
21:07:37 <mmorrow> abbe: np
21:08:06 <abbe> mmorrow, but is mine a good solution or just a workaround ?
21:08:30 <mmorrow> abbe: that's the "solution" i use in a pinch too
21:08:31 <SamB_XP> pikhq: and let's not forget that they didn't exactly start with the GUI stuff in the kernel, it just sorta seemed to be necessary for performance reasons at one point ...
21:08:39 <abbe> oh, okay :)
21:08:51 <pikhq> SamB_XP: Still.
21:09:11 <SamB_XP> *and* they aren't the only ones to have done in-kernel httpd stuff
21:09:30 <pikhq> I don't defend Linux's khttpd.
21:09:45 <mmorrow> there should really be a hForcefullyRipContentsFromFilesColdDeadHands
21:09:58 <SamB_XP> does NT actually include the IIS kernelcode?
21:10:29 <pikhq> Non-"home" editions of NT OSes actually ship with IIS in its entirety.
21:10:37 <SamB_XP> oh?
21:10:47 <SamB_XP> including XP Professional?
21:10:52 <pikhq> Yeah.
21:11:04 <SamB_XP> does it get loaded by default?
21:11:16 <pikhq> I think it's a somewhat dumbed-down IIS, though.
21:11:21 <moonpatrol> if you mean by entirety you don't include limitations
21:11:24 <pikhq> No, it's not.
21:11:27 <moonpatrol> its like a 10 user limit etc...
21:11:46 <pikhq> moonpatrol: That's stupid #defines, though.
21:11:49 <SamB_XP> so the DLL probably isn't loaded in my kernelspace
21:13:24 <SamB_XP> @hoogle FilePath -> IO String
21:13:24 <lambdabot> Prelude readFile :: FilePath -> IO String
21:13:24 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
21:13:24 <lambdabot> System.IO readFile :: FilePath -> IO String
21:13:41 <SamB_XP> mmorrow: try readFile?
21:13:52 <SamB_XP> or. abbe, even
21:14:15 <mmorrow> SamB_XP: that'll fail in `withFile' as well
21:14:33 <SamB_XP> mmorrow: doesn't even take a Handle!
21:14:36 <mmorrow> err, a hypothetical hReadFile would
21:14:56 <SamB_XP> mmorrow: um, there wouldn't be one
21:15:03 <mmorrow> SamB_XP: i'm assuming abbe's using withFile for a reson
21:15:05 <mmorrow> *reason
21:15:18 <ray> former lisper maybe?
21:15:27 <Veinor> How hard would it be to write an MPD client in haskell using ncurses, as opposed to other languages? given the existence of hcurses and mpdhaskell or whatever they're called
21:15:36 <ray> probably easier
21:15:39 <abbe> mmorrow, I'm using it because I didn't notice there is readFile :-D
21:15:52 <mmorrow> abbe: well in that case.. :)
21:15:52 <SamB_XP> abbe: as I suspected!
21:15:53 <ray> the curses would be just as annoying, because these libraries are all pathologically insane by nature
21:15:57 <ray> but the rest would be easy
21:16:03 <abbe> Veinor, there is a MPD library in hackage :)
21:16:07 <SamB_XP> at least, after I was certain that there was one I did
21:16:12 <Veinor> I mean a client, not a library
21:16:27 <abbe> okay
21:16:35 <ray> if you can handle the curses, it should be easy as cake
21:16:36 <abbe> thanks, SamB_XP
21:16:43 <SamB_XP> Veinor: yeah, the curses stuff won't be any easier in Haskell if you actually use curses
21:16:55 <Veinor> SamB_XP: what do you mean?
21:17:12 <ray> curses is insane, no binding can change it
21:17:17 <SamB_XP> curses still has that fugly API no matter what language you use
21:17:28 <Veinor> true
21:17:47 <SamB_XP> though I imagine there are languages that make that look nice ;-)
21:17:55 <ray> since it's bad in any language, though, you might as well do it in haskell
21:18:00 <Veinor> haha, yeah
21:18:17 <Veinor> I'm thinking of using it as my first big project in haskell; I like mpd but I want to add a bit of functionality to it
21:18:20 <Veinor> smart playlists and such
21:18:40 <SamB_XP> what is mpd anyway?
21:18:50 <Veinor> music player daemon
21:19:04 <Veinor> you run it and send it commands over TCP, it plays music
21:19:06 <SamB_XP> dons wrote something called hmp3 that might or might not be tangentially interesting ;-)
21:19:10 <Saizan_> maybe it makes more sense to use Yi's buffers rather than cursers
21:19:25 <SamB_XP> Saizan_: quite possibly
21:19:30 <Veinor> Saizan_: ?
21:19:49 <SamB_XP> a textuality abstraction based on text certainly seems sensible
21:19:58 <Veinor> I just want to be able to make a text-based interface, if that can let me do that I'll use i
21:20:07 <Veinor> t
21:20:21 <SamB_XP> Veinor: Saizan_ is thinking of radical ideas now, I think
21:20:34 <SamB_XP> not necessarily applicable to the beginner
21:21:04 <Veinor> ah, okay
21:23:08 <mmorrow> Veinor: model the UI and the commands/whatnot with data types, then write a separate "compiler" from those datatypes to whatever horror might be waiting for you wrt a terminal ui
21:24:07 <Veinor> so basically abstract out the UI and commands
21:24:16 <mmorrow> exactly
21:24:40 <Veinor> so have a PlayCommand type, PauseCommand, etc
21:25:12 <Saizan_> those should probably be constructors of a Command type
21:25:20 <Veinor> true
21:25:42 <edwardk> the only problem with yi buffers is the GPL
21:25:58 <ray> gpl always strikes in the least convenient places
21:26:14 <mmorrow> data MPD embed = MPD {infoArea :: [InfoItem], playlist :: [MediaData], other :: embed}; data Command = ...; process :: Command -> MPD -> MPD
21:26:32 <Veinor> mmorrow: yeah, I was thinking something along those lines
21:27:06 <mmorrow> myActualProcess :: Command -> StateT MPD IO Status
21:27:14 <Veinor> Command = PauseCommand | StopCommand | PlayCommand Maybe File
21:27:43 <Veinor> among others of course
21:27:48 <mmorrow> myActualProcess cmd = do mpd <- get; let mpd' = process cmd; liftIO (updateIO mpd')
21:27:53 <mmorrow> or whatever
21:28:06 <mmorrow> err, set mpd'
21:28:10 <mmorrow> too ;)
21:28:12 <edwardk> gah! i just realize after spending half an hour working with Text.Parsec.Token that i can't actually use their charLiteral and stringLiteral stuff directly because it is wrapped in 'lexeme' =/
21:28:50 <edwardk> time to cut and paste =(
21:33:19 <Veinor> hm, I think I'm going to need something to do ID3 tag work
21:35:12 <rsnake> Phew! Finally finished! Good night #haskell!
21:35:23 <Veinor> Night
21:42:29 <Veinor> are there any good ID3 tag libraries for Haskell, or am I going to have to write my own?
21:59:12 <dancor> Veinor: i see taglib on http://hackage.haskell.org/packages/archive/pkg-list.html
22:04:41 <Saizan_> it seems there's unnecessary IO there
22:05:24 <dancor> i think that's because it's using a c library and it's lazy
22:06:11 <dancor> i think that's fine and that you can wrap it in a grabTheThingsIllWant
22:32:56 <ManateeLazyCat> I can use pattern deduce match Class with it's instance? Example, i have class: `class PageBuffer a where` and have instance for PageBuffer: instance PageBuffer StringBuffer where`, so if i got `PageBuffer` instance i can deduce it to `StringBuffer`, similar like `case pageBuffer of PageBuffer (StringBuffer a) -> ... _ -> ...`.
22:35:35 <ManateeLazyCat> @users
22:35:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 550 (83.6%), active: 3 (0.5%)
22:38:08 <copumpkin> ManateeLazyCat: hmm?
22:38:50 <copumpkin> ManateeLazyCat: no you can't do that, but you can approximate it
22:39:04 <copumpkin> ManateeLazyCat: or in another question, what would the type of pageBuffer be?
22:39:36 <ManateeLazyCat> copumpkin: Many, PageBuffer just as abstract interface.
22:39:55 <ManateeLazyCat> copumpkin: Any type that instance PageBuffer can be pageBuffer.
22:40:10 <copumpkin> you're looking for OO-style existentials
22:40:12 <copumpkin> you can write them
22:40:20 <copumpkin> but you still can't have a "typecase"
22:40:32 <copumpkin> where you explicitly pattern match against different types
22:40:40 <copumpkin> what you can do is embed the logic in the class instances
22:40:49 <copumpkin> to get the same behavior
22:41:21 * ManateeLazyCat pasted "Page and PageBuffer" at http://paste2.org/get/376073
22:41:25 <ManateeLazyCat> copumpkin: Above is my code.
22:41:34 <copumpkin> oh my...
22:41:47 <ManateeLazyCat> copumpkin: I do PageBuffer as abstract type for `data Page`.
22:42:30 <ManateeLazyCat> copumpkin: But many functions (such as pageBufferSave, pageBufferUndo...etc.) just commanders for editor.
22:42:41 <ManateeLazyCat> copumpkin: So i want split those functions from PageBuffer
22:43:04 <copumpkin> why do they need to be methods?
22:43:05 <ManateeLazyCat> copumpkin: PageBuffer just keep functions interface for common
22:43:11 <copumpkin> I get the impression you're just translating OO code to haskell
22:43:41 <ManateeLazyCat> copumpkin: In different instance of PageBuffer have different behaviour.
22:43:53 <copumpkin> and you can't factor any of that out?
22:43:54 <ManateeLazyCat> copumpkin: Even function name is same.
22:44:24 * ManateeLazyCat pasted "PageMode." at http://paste2.org/get/376074
22:44:30 <copumpkin>     pageBufferClone                     :: a -> IO a
22:44:34 <ManateeLazyCat> copumpkin: Above is PageMode interface for Page.
22:44:46 <ManateeLazyCat> copumpkin: pageBufferClone is for common
22:45:04 <copumpkin> it just feels so unlike haskell :P
22:45:28 <ManateeLazyCat> copumpkin: I want split speical commands to modeKeymap in PageMode.
22:45:42 <ManateeLazyCat> copumpkin: Then PageMode for speical command, PageBuffer for common command.
22:46:11 <ManateeLazyCat> copumpkin: In my code have many IO Monad, but it's easy way to programming with gtk2hs.
22:46:38 <ManateeLazyCat> copumpkin: If you use others style, example, State Monad, gtk2hs binding can't work.
22:47:15 <Saizan_> it's not the IO, it's the number of functions in that class that feels weird
22:47:35 <ManateeLazyCat> Saizan_: weird?
22:47:39 <copumpkin> strange
22:48:05 <Saizan_> ManateeLazyCat: however why do you wish to pattern match on the type?
22:48:21 <ksf> ...if you want oo-patterns in haskell, I'd recommend http://homepages.cwi.nl/~ralf/OOHaskell/
22:48:37 <ManateeLazyCat> ksf: No, i don't want it.
22:48:46 <copumpkin> ManateeLazyCat: since you're already being OOish about it, you can take their approach to doing your typecasing, and embed the logic of your typecase into methods of the typeclass
22:48:47 <ManateeLazyCat> ksf: I just do thing along with my feeling.
22:48:49 <Saizan_> ksf: you're so cruel
22:48:57 <ksf> well, then don't pattern match on types if you don't want to...
22:49:28 <Saizan_> copumpkin: how would that look?
22:49:39 <copumpkin> instead of case pageBuffer of a :: Moo -> f a; b :: Baa -> g b, just make a method that does f a for one of the types and g b for the other
22:49:50 <copumpkin> where I just made up that syntax :P
22:49:57 <copumpkin> since you can't actually pattern match on types
22:50:19 <ManateeLazyCat> Saizan_: Example, in PageBuffer, front 7 functions is common for any instance of PageBuffer, others is for speical instance, example, pageBufferSave, pageBufferUndo for eidtor instance of PageBuffer, so i want split those speical functions to other module
22:50:43 <copumpkin> you want inheritance...
22:50:56 <ManateeLazyCat> Saizan_: So if PageBuffer match a speical instance (such as eidtor buffer), i apply those eidtor functions with it, otherwise don't apply.
22:51:02 <Saizan_> default methods might apply?
22:52:05 <Saizan_> ManateeLazyCat: it seems like you should call the methods anyway and let the instances decide if they do something or not
22:52:08 * ManateeLazyCat pasted "PageBuffer" at http://paste2.org/get/376091
22:52:19 <ManateeLazyCat> Saizan_: Exaample, i just want keep above functions in PageBuffer.
22:52:36 <ManateeLazyCat> Saizan_: Yep.
22:52:42 <ManateeLazyCat> Saizan_: And not complete.
22:53:36 <Saizan_> you can make the methods return a value to signal if they did something or it was an error to call them etc..
22:53:54 <ManateeLazyCat> Saizan_: In PageMode, i have `modeKeymap` for keep speical action for speical instance of PageBuffer, but pattern match just avoid module apply wrong function that it shouldn't apply.
22:54:34 <ManateeLazyCat> s/module/instance
22:55:10 <Saizan_> yeah, i'd really suggest you to make the check inside the instance, rather than at the call site of the method
22:55:12 <ManateeLazyCat> copumpkin: inheritance?
22:55:23 <Saizan_> so you don't have to pattern match on types, and it's more extensible
22:55:48 <copumpkin> ManateeLazyCat: OO/subtyping/etc.
22:55:52 <copumpkin> you have a base class with those methods
22:56:00 <copumpkin> and then subclasses with the extra methods
22:56:08 <copumpkin> and existential instances of them
22:56:28 <copumpkin> I can't help feeling you're going about this the wrong way, but you know your problem better than I do :P
22:56:55 <ManateeLazyCat> copumpkin: So i have define parent-class, and sub-class?
22:57:26 <copumpkin> well, it sounds like what you want, but haskell doesn't let you do that easily
22:57:46 <ManateeLazyCat> copumpkin: Yep, and i don't like that OO style
22:57:51 <Saizan_> you could do that and have two different constructors in Page
22:57:58 <ManateeLazyCat> copumpkin: That's case i choose Haskell.
22:58:14 <Saizan_> though you're still using Haskell in a quite OO way :)
22:58:51 <Saizan_> (but OO might be a good fit for the problem)
22:59:06 <ManateeLazyCat> Saizan_: Maybe, i use Haskell with haskell style, but now my code looks like OO style event gtk2hs just works with IORef.
22:59:46 <ManateeLazyCat> Saizan_: So result is match in instance and define different constructors in Page, i need thing those solution.
23:00:22 <Saizan_> the use of IORefs or not has little to do with this, i'd think
23:00:24 <SamB_XP> yeah, GTK is OO
23:01:20 <ManateeLazyCat> SamB_XP: I just keep some pure module with Haskell style, others module that interactive with gtk2hs i will keep use IORef.
23:01:31 <Saizan_> ManateeLazyCat: in the instance you don't have to check the type, you already know it
23:02:17 <Saizan_> and more constructors in Page are needed only if you split your class in a base one and a subclass
23:02:45 <hackagebot> encoding 0.6.0 - A library for various character encodings (HenningGuenther)
23:03:10 <ManateeLazyCat> Saizan_: I don't want more constructors in Page, Page is simple enough and don't need add or other different constructors.
23:03:27 <ManateeLazyCat> Saizan_: Only different is PageBuffer and PageMode.
23:04:47 * ManateeLazyCat Many haskellers will say: "Oh, it's not Haskell style!" when i release my project someday.... :)
23:05:30 <ManateeLazyCat> Saizan_: I consider do something in instance, thanks for your suggestion! :)
23:10:47 <hydo> I have a question in the form of a github gist if anyone has a free second.  http://gist.github.com/167016
23:12:59 * Saizan_ 'd like an IDE that comments out all the type signatures in a module
23:14:06 <Saizan_> ?type bracket
23:14:07 <lambdabot> Not in scope: `bracket'
23:14:16 <Saizan_> ?type Control.Exception.bracket
23:14:17 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:15:16 <hydo> ahoy... I had no idea that existed.
23:15:16 <Saizan_> hydo: it seems a case for bracket ^^^ you'll also get cc called even if execStatement throws an exception, that way
23:16:04 <hydo> Hehe... I love haskell and its hidden nuggets of awesome.  Thanks Saizan_ !
23:16:14 <Saizan_> bracket oc cc $ \h ->
23:16:20 <Saizan_> np :)
23:17:05 <hydo> I must be getting better, however slowly.  I could actually follow that type signature.  It would have looked like witchcraft to me a month ago.
23:18:17 <SamB_XP> those things would be easier to read if the variables were color-coded ;-)
23:33:10 <ManateeLazyCat> Saizan_: I think i can't do decide in instance when i remove speical methods from PageBuffer, i just can apply method to pageBuffer instance with function: pageApplyBuffer f (Page {pageBuffer = x}) = f x , if methods not in PageBuffer, i can't apply this method with PageBuffer instance.
23:43:29 <abbe> http://lisperati.com/landoflisp/ :-)
23:45:13 <athos> man, eventually i think it was a bad idea to lift those lispers in the IRC monad ;-)
23:45:59 <abbe> :-D
23:46:03 <Makoryu> Follow the simple rules
23:46:52 <solrize> hee
23:47:07 <solrize> wow, that book is actually coming out
23:47:08 <solrize> http://nostarch.com/lisp.htm
23:49:55 <Makoryu> Yeah
23:49:58 <Makoryu> A few more months
23:50:30 <athos> \query lambdabot > let coffein = [(240, "ml"), (150, "ml")] in
23:50:34 <athos> heh!
23:51:42 <athos> > let coffein = [(240, "ml"), (150, "ml")] in foldr ((+).fst) 0 coffein
23:51:43 <lambdabot>   390
23:51:47 <athos> gotta be a good day
