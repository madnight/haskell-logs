00:00:06 <copumpkin> oh duh
00:00:15 <copumpkin> I've looked at it wrong this whole time
00:00:20 <copumpkin> I'm stupid, ignore me
00:00:50 <Saizan_> heh, it's easy to fall in that trap :)
00:01:18 <copumpkin> :)
00:07:39 <Saizan_> though, suppose you've a restricted applicative, if you write (+) <$> a <*> b you get a context like (Applicative k f, Num a, a :: k, (a -> a) :: k, (a -> a -> a) :: k)
00:08:21 <Saizan_> (where there's a mix between kind and non-kinds syntaxes, but i hope you understand :)
00:10:15 <Saizan_> or, rather, pure (+) <*> a <*> b would have that context, with <$> you don't have the (a -> a -> a) :: k i think
00:10:17 <quicksilver> koninkje: typeclasses don't infer in the way that (one might expect) kinds do?
00:10:27 <quicksilver> there is a kind of stylistic difference.
00:10:35 <quicksilver> open-world assumption is quite unlike a 'normal' kinding system.
00:12:08 <koninkje> which open-world assumption?
00:12:21 <Saizan_> the one about typeclass membership
00:13:42 <koninkje> The fact that you can have overlaps (one type of multiple typeclasses) makes it different from 'normal' kinding systems
00:14:25 <koninkje> but given that, I'm not sure why the open-world makes it that much different; it's just solving a constraint problem
00:21:42 <quicksilver> koninkje: well, you lose the principle kind property
00:21:56 <quicksilver> you can't kind-check program fragments any more
00:21:59 <quicksilver> only entire programs.
00:22:21 <quicksilver> I'm not saying it isn't a kinding system - in a sense, t obviously is.
00:22:36 <ksf> meh why is it "license-file" and not "license-files"?
00:22:37 <koninkje> Yes, you loose principal kinds if the subkind graph doesn't have a forest structure
00:22:51 <Gwern-away> ksf: why would you have more than one?
00:23:03 <Gwern-away> debian et al seem to get along fine with jusst LICENSE
00:23:08 <ksf> ...because freetype has more than one.
00:23:19 <quicksilver> I'm saying it's a rather annoying kinding system, with no principle kind property, poor compositionality, extensive subkinds, superkinds, and unrelated kinds
00:23:37 <quicksilver> which is why the context thing is so clever ;)
00:23:52 <koninkje> But there are various ways to work around that. GHC's Haskell already looses principal types and requires annotations here and there
00:24:18 <dmwit> ksf: hum, dual-licensing does seem to sort of buck the license-file thing, huh?
00:24:23 <Saizan_> it's a matter of working out how annoying it'd be :)
00:24:25 <dmwit> ksf: Perhaps you should suggest a change to dcoutts.
00:24:35 <ksf> @seen dcoutts
00:24:35 <lambdabot> dcoutts is in #haskell, #gentoo-haskell, #haskell-soc, #haskell-in-depth, #ghc, #haskell-iphone, #darcs and #haskell-overflow. I last heard dcoutts speak 10h 34m 57s ago.
00:25:00 <Saizan_> you could have a single license file that points to other files in your tarball
00:25:35 <ksf> @tell dcoutts would you consider to change license-field to license-fields? freetype comes dual-licensed, and I'd like to include both.
00:25:35 <lambdabot> Consider it noted.
00:25:36 <koninkje> It's not actually all that different from the context system, it's just making typeclasses/contexts a bit more first-class. Which would get rid of a lot of the warts in current Oleg Fu
00:25:39 <ksf> I do.
00:25:49 <quicksilver> the invention of context recovered something like principle type property for at least a large class of terms
00:26:18 <ksf> ...but I've got to extra-source-files the two actual files.
00:27:06 <Saizan_> quicksilver: so they were already using kind for this and moved to typeclasses?
00:27:45 <kbp> I need help. Assume F = VxVyVz ( P(x,y) /\ P(y,z) => P(x,z) ) and G = Vx( P(x,x) ). So does it mean  F /\ G = Vx,y,z ( (P(x,y) /\ P(y,z) => P(x,z)) /\  P(x,x) . Can I join them like that?
00:27:59 <copumpkin> wow, that's legible :P
00:28:15 <ksf> @tell dcoutts "-files" of course, not "fields". change the "licence-file" field to a "license-files" field...
00:28:15 <lambdabot> Consider it noted.
00:29:25 <quicksilver> koninkje: I'm not sure how the theory developed. "class" is just another word for "kind" though.
00:29:39 <copumpkin>  Assume F = ∀x∀y∀z ( P(x,y) ∧ P(y,z) ⇒ P(x,z) ) and G = ∀x( P(x,x) )
00:29:45 <koninkje> Saizan_: ^^
00:29:51 <Nereid_> kbp: I suspect so
00:30:46 <quicksilver> yes, that was for saizan ;) sorry.
00:30:52 <koninkje> no worries
00:30:55 <quicksilver> I can't see what I'm typing to vet my lines. GPRS ftw ;)
00:31:09 <Saizan_> kbp: using one of these you can: http://en.wikipedia.org/wiki/First-order_logic#Provable_identities
00:31:11 <quicksilver>  icmp_seq=47 ttl=43 time=103497.503 ms
00:31:27 <ksf> ...now I need to figure out how to make cabal run gcc -E on a file...
00:31:31 <quicksilver> kbp: you meant to have the P(x,x) inside the outermost ()
00:31:41 <quicksilver> kbp: but otherwise, basically, yes.
00:31:49 <kbp> Nereid_: so I can join any as long as the ∀is there right? I just cannot join when there is an Ex (E inverse symbol)
00:32:06 <copumpkin> ∃
00:32:09 <dmwit> kbp: I don't think P(x,x) = Vy. P(x,x), but other than that, that seems rather doable.
00:32:15 <ksf> exists . something
00:32:24 <kbp> copumpkin: how could you type up those symbol? which tool are you using?
00:32:31 <copumpkin> just my character map :)
00:32:52 <koninkje> dmwit: most logics should allow you to introduce unused quantifiers freely
00:33:16 <dmwit> What if there's no value of y!
00:33:40 <Nereid_> dmwit: isn't that typically forbidden?
00:33:51 <quicksilver> kbp: 'forall' is just a big /\, and /\ is commutative associative. So you can push /\ and forall around.
00:34:00 <kbp> Saizan_: thank you for your page, I'm reading it :)
00:34:04 <dmwit> Maybe so.  I mostly just use intuition for my logical insights, I don't know a lot of theory.
00:34:12 <dmwit> I'm taking a class this semester to remedy that. =)
00:34:38 <Nereid_> (at least in the version I am familiar with) an empty universe isn't allowed
00:34:54 <quicksilver> kbp: a similar remark applies to exists and \/
00:35:19 <quicksilver> in an empty universe, Vy P is vacuously true.
00:35:28 <quicksilver> so that doesn't break the identity.
00:35:32 <kbp> quicksilver: so if there is a forall and a \/, i.e. if F \/ G, I cannot join them like above? is that what you menat?
00:35:41 <kbp> quicksilver: *meant
00:35:55 <Nereid_> quicksilver: but P isn't necessarily true
00:36:04 <Nereid_> kbp: nope
00:36:41 <quicksilver> kbp: that is correct, you cannot.
00:37:46 <Nereid_> ∀x(F(x) v G(x)) is different from ∀xF(x) v ∀xGx), although the latter implies the former
00:37:54 <quicksilver> Nereid_: in an empty universe Vy P would be semantically true even if P was not true, because it's vacuous.
00:38:07 <Nereid_> quicksilver: thus breaking the ∀xP = P equivalence
00:38:36 <Nereid_> of course assuming x is not free in P
00:38:41 <quicksilver> Nereid_: but that's not a valid syntactic deduction because, of course, syntactic deductions are things which hold in all models, not just the special one which is empty.
00:38:52 <quicksilver> Nereid_: I didn't say they were equivalent. I said P => Vx P
00:38:55 <Nereid_> depends on what models you allow
00:39:23 <quicksilver> yes. and it depends what all the symbols mean and what logic we're talking about
00:39:31 <Nereid_> indeed
00:40:32 <quicksilver> I took the liberty of assuming we were talking about standard logics ;)
00:41:53 <kbp> thank you Nereid_ and quicksilver, I'm clear now.
00:41:56 <quicksilver> ;)
00:42:00 <Nereid_> :-)
00:42:08 <kbp> Thanks to dmwit & copumpkin too :)
00:42:22 * copumpkin is the master character mapper, even though I know nothing
00:42:42 <quicksilver> *if* you exclude empty models, then you get the non-standard deduction (P => Ex P) [x not occuring in P]
00:42:52 <quicksilver> but that's not a standard rule
00:42:59 <quicksilver> this can be seen as a justification for including empty models.
00:43:00 <Nereid_> depends who you ask
00:43:23 <quicksilver> Hmm. Well.
00:43:34 <Nereid_> if you ask me, I'd disagree ;)
00:43:41 <koninkje> +1
00:44:07 <opqdonut> possibly empty types have cool consequences too
00:44:07 <quicksilver> I will be surprised if you find a respected logician who believes (P => Ex P) [x not occuring in P] is a deduction rule of intuitionistic or classical logic.
00:44:23 * dmwit found a real use for data Void the other day
00:44:28 <quicksilver> that opinion has certainly never been espoused by any of the ones I know.
00:44:54 <opqdonut> dmwit: pray tell?
00:45:10 <copumpkin> dmwit: for @djinn? :P
00:45:28 <dmwit> opqdonut: I'm playing with SGF spec.  There are several game types, and each are specified differently.
00:45:41 <dmwit> In any case, there is a "ruleset" tag, which is only specified in some of the game types.
00:45:45 <dmwit> So I have a data type
00:45:53 <dmwit> data Ruleset a = Known a | Unknown String
00:46:03 <dmwit> For games where it's specified, e.g. Go, I can use the type
00:46:08 <dmwit> Ruleset GoRuleset
00:46:14 <dmwit> When it's unspecified, the type
00:46:17 <dmwit> Ruleset Void
00:46:23 <dmwit> guarantees that you can't get "Known" values. =)
00:46:40 <opqdonut> well, _|_
00:46:41 <koninkje> Known _|_
00:46:47 <opqdonut> but yeah
00:46:47 <dmwit> unimportant
00:47:20 <koninkje> dmwit: for correctness sake, you may prefer to use !a instead of a
00:47:41 <dmwit> (Unimportant, because there is also no good way to *inspect* a value of type Void.  No pattern match.)
00:49:20 <koninkje> Doesn't matter. If any code relies on a pattern (Known _) to mean there is in fact a known value, they'll be sadly mistaken
00:49:52 <dmwit> hm
00:49:55 <koninkje> Whenever possible, it's best to prohibit illegal bottoms
00:50:17 <koninkje> (to prevent you or a client from mucking things up accidentally)
00:50:23 <dmwit> Right, I agree.
00:50:28 <dmwit> I'm going to make that change right now. =)
00:51:42 <koninkje> Of course, it depends on the exact semantics you want. If the known a may need to be computed by some expensive function and you want to delay that computation, then allowing _|_ may be a good idea.
00:51:50 <koninkje> But generally that's not the case
00:51:54 <dmwit> It's verrrry unlikely.
00:52:13 <dmwit> All the rulesets are (essentially) small enums.
00:59:25 <Sam___> hey baby can i be the input set for your list comprehension's predicate? we'd make a beautiful output function together
00:59:44 <copumpkin> o.O
01:00:41 <dmwit> Oh, yeah, speak nerdy to mem.
01:01:07 <dmwit> That turns my bits on.
01:01:14 <Sam___> hot
01:01:22 * Gwern-away puts on his robe and wizard hat
01:05:01 <sheyll> \q
01:19:24 <yaxu1> spot the haskell http://news.bbc.co.uk/1/hi/technology/8221235.stm
01:20:51 <copumpkin> doesn't quite look like haskell
01:21:01 <copumpkin> looks like some combination of ruby and haskell syntax :o
01:21:44 <quicksilver> I never thought I'd see the day that an BBC News article would contain the following two "sentences"
01:21:50 <quicksilver> "A crash. Epic fail."
01:23:06 <opqdonut> i'm guessing "epic fail" will be the "ok" of the next 100 years
01:24:05 <uzytkownik> Hello. I have a problem with such code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8761#a8761 - in last function (event) there is type error. What's wrong?
01:24:58 <dmwit> yaxu1: 1:56! I found it
01:25:04 <yaxu1> :)
01:27:18 <uzytkownik> Ops. <$> vs $ ;)
01:32:46 <kbp> quicksilver: sorry it's me again, just have a quick question, assume I have VxVyVz( P(x,y,z) ) /\ ∃x ( Q(x,x) ) . So can I join them together and make them = ∃xVyVz ( P(x,y,z) /\ Q(x,x) ) ?
01:33:46 <etpace_> :t sequence [(+1), (+2)]
01:33:47 <lambdabot> forall a. (Num a) => a -> [a]
01:34:00 <opqdonut> kbp: if that weird symbol that's not showing on my screen is forall, then yes
01:34:01 <therp> kbp: I'd say that your last term is an implication of the first term
01:34:13 <therp> kbp: but they are not equivalent
01:34:20 <opqdonut> therp nailed it
01:34:25 <dmwit> opqdonut: no, it's an exists
01:34:29 <codolio> You can type ∃ but not ∀? :)
01:34:30 <opqdonut> ah, ok
01:34:40 <opqdonut> then i'll have to rethink
01:34:44 <opqdonut> yeah, implication
01:34:48 <dmwit> (Also, here it's only half of an exists.)
01:34:53 <dmwit> (the top half, in particular)
01:34:53 <kbp> opqdonut: that weird simboy is actually E (inverse)
01:35:08 <kbp> opqdonut: *symbol
01:35:23 <quicksilver> kbp: no, you cannot commute E past V
01:35:29 <opqdonut> equivalent would be "(forall x y z. P(x,y,z)) /\ exists x. Q(x,x)
01:35:32 <opqdonut> "
01:35:37 <quicksilver> kbp: ExVy is something utterly different from VyEx
01:35:59 <quicksilver> kbp: also the 'x's in your initial question were unrelated.
01:36:26 <etpace_> @hoogle sequence (-> e)
01:36:27 <lambdabot> Parse error:
01:36:27 <lambdabot>   --count=20 "sequence (-> e)"
01:36:27 <lambdabot>                           ^
01:37:06 <etpace_> so  how do I search for functions to do with that monad?
01:37:29 <quicksilver> kbp: I believe you could say : VxVyVzEw ( P(x,y,z) /\ Q(w,w) )
01:37:31 <copumpkin> ((->) e) is the actual instance
01:37:40 <dmwit> etpace_: All functions have to do with that monad.
01:37:41 <copumpkin> but what would you want to get out of that?
01:37:47 <quicksilver> kbp: althouhg I"m not promising it because I din't think my cup of cofee has sunk in.
01:37:49 <dmwit> etpace_: So... what exactly did you want to search for?
01:38:05 <copumpkin> etpace_: there's @src which gives oyu the source of methods of a typeclass for a given instance
01:38:09 <kbp> therp & quicksilver: ok the real question in the book is F = Vx,y,z( P(x,y) /\ P(y,z) => not P(x,z) ) and  G = Vx (not P(x,x)) . And it asks to prove F /\ not G is unsatisfiable. So prob the term x is constant and I cannot change to w as quicksilver just said....
01:38:09 <copumpkin> etpace_: but sequence isn't a method
01:38:17 <opqdonut> but ExVyVz (P(x,y,z) /\ Q(x,x)) is a weakening of the original
01:38:23 <opqdonut> so if that was just what you wanted
01:38:31 <etpace_> oh, is sequence built from bind and return?
01:38:36 <dmwit> etpace_: yep
01:38:39 <dmwit> ?src sequence
01:38:39 <lambdabot> sequence []     = return []
01:38:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:38:39 <lambdabot> --OR
01:38:39 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:38:40 <quicksilver> kbp: we should really take this to -blah, though. It's not about haskell.
01:38:53 <quicksilver> kbp: I can recommend a program called 'Jape' for exploring intuitionistic proof
01:38:57 <quicksilver> that's what we used to teach it.
01:41:33 <kbp> quicksilver: I bought the book The Haskell Road to Logic, Maths and Programming to learn Haskell and that's what I've learned so far :D
01:42:00 <kbp> quicksilver: it keeps talking about those formulas and drives me crazy
01:42:36 <quicksilver> heh
01:42:45 <opqdonut> hehe
01:42:49 <quicksilver> OK that brings it slightly on topic in a sense :)
01:42:49 <therp> kbp: does it have to be a formal argument? informally from not G you get: ∃x.P(x,x) quickly, and arguing that this particular x makes the condition of F true (P(x,x) and P(x,x)) making the premise true, namely not P(x,x), in contrast to G.
01:42:50 <opqdonut> kbp: have you read any online tutorials
01:43:04 <opqdonut> LYAH is pretty good and keeps to the basics
01:43:50 <kbp> opqdonut: yea, especially how to program in Haskell  :)
01:44:09 <therp> kbp: formally you'd have to instantiate F for the "x" in G, and then you have the contradiction rightaway
01:44:30 <therp> (instantiate three times actually)
01:45:34 <quicksilver> therp: that doesn't sound right.
01:45:36 <therp> I especially like the notation for predicate logic given in TTFP http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf
01:45:39 <kbp> therp: it gives a hint saying that I have to use resolution method to prove it and no formal argument
01:45:40 <quicksilver> therp: this is first order logic, not second.
01:45:58 <quicksilver> therp: you can't instantiate a term as a proposition.
01:46:07 <therp> quicksilver: where do you see second order logic in my argument?
01:46:10 <kbp> therp: never mind, I think I'm lost hehe
01:46:13 <quicksilver> kbp: "resolution" is a formal method of establishing a contradiction.
01:46:22 <quicksilver> I presume it's described in the book but I haven't read it
01:46:38 <quicksilver> therp: "instantiate F for the "x" in G" <- perhaps I misunderstood you
01:47:20 <therp> quicksilver: I meant eliminate the three forall's.
01:47:38 <therp> quicksilver: basically x would than be a "free variable"
01:48:23 <therp> quicksilver: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf page 22 (in print, PDF page 35)
01:52:35 <quicksilver> therp: it's all right, I do understand now ;) I just misread what you meant
01:55:47 <therp> kbp: I'd say a resolution method is an ultra formal way of proving things.. hm unfortunately I don't know any for first-order logic.. I guess the reason is they'd not terminate anyway..
01:56:51 <kbp> :) thank you therp & quicksilver
01:57:39 <therp> kbp: do you grasp the reason why it's unsatisfiable intuitively?
01:58:20 <kbp> therp: unfortunately, not at all  :(
01:59:21 <quicksilver> therp: Erm. You need to reread your Robinson ;) http://www.cs.nott.ac.uk/cgi-bin/bsl/reasoning.cgi?Robinson:65a
01:59:33 <quicksilver> therp: first order was included in the original resolution paper.
01:59:43 <kbp> therp: I'm still thinking how to "join" Vx,y,z /\ Ex together, otherwise it's no help using resolution
02:00:00 <therp> quicksilver: thanks interesting
02:02:00 <quicksilver> that paper really hammers home how much academic style has changed in the last 50 years
02:02:13 <quicksilver> MOAR WHITESPACE PLZ
02:03:11 <dolio> And better fonts.
02:04:12 <therp> kbp: only for your intuition: as F quantifies all its variables, we can conclude P(a,a) /\ P(a,a) -> not P(a,a)
02:04:23 <quicksilver> therp: I think the informal observation (of why it terminates) is that any concrete formula has finite size so there will be a counter-example which only has finitely many individuals.
02:04:42 <quicksilver> therp: so, finding counterexamples is semi-decidable even for first order logic.
02:04:48 <therp> kbp: that itself almost sounds like a contradiction, the only thing left to do is to proof that there is indeed an object that fulfills P(a,a). we get that from G.
02:05:05 <Saizan_> it's what prolog does, afterall, no?
02:05:26 <quicksilver> that is: the thing you need to prove is that there is a way to generate the counter examples on well-founded recursion on the structure of the proposition.
02:05:28 <therp> quicksilver: yes, but in case there are no counter examples?
02:05:34 <quicksilver> Saizan_: yes, but prolog isn't full first order
02:05:37 <quicksilver> therp: only semi-decidable.
02:05:46 <quicksilver> therp: if there are none, it may not terminate
02:06:22 <quicksilver> Saizan_: prolog is a particular fully decidable (not jsut semi-decidable) fragment
02:06:46 <therp> quicksilver: what about giving P to and not P to the resolution method and run it in parallel, to see which terminates first? :)
02:06:52 <dolio> Prolog is fully decidable?
02:07:02 <kbp> therp: I just try to make it clear, did you mean P(a,a) /\ P(a,a) = not P(a,a) ?
02:07:03 <etpace_> If I build up a computation via sequence or bind, they're not actualy executed while building right? for example getLine >>= return . reverse >>= putStrLn builds up the computation, and then main executes it?
02:07:09 <quicksilver> dolio: depends what you mean by prolog, I think
02:07:32 <dolio> Well, even if you eliminate the obvious stuff like IO...
02:07:33 <quicksilver> dolio: but there is a tradtional fragment of prolog which is provable total, isn't there?
02:07:41 <quicksilver> I may have misremembered an important step.
02:07:43 <therp> kbp: I didn't mean equality, I meant an implication, as you have given us originally in F
02:08:11 <dolio> I don't know. I'd kind of expect prolog to be Turing complete, but maybe it wasn't in its original incarnation.
02:08:28 <quicksilver> "basic" prolog is just horn clauses, and the reason for that is that makes resolution decidable
02:08:32 <quicksilver> http://en.wikipedia.org/wiki/Horn_clause
02:08:51 <quicksilver> hmm
02:08:58 <quicksilver> I can't remember any more :(
02:09:07 <quicksilver> too much time doing boring real world programming.
02:09:07 <kbp> therp: ok I sort of get your idea now :) thank you very much
02:10:02 <therp> kbp: I hope that helps to fill in the gaps in your resolution method
02:10:33 <Saizan_> that WP actually says that "Satisfiability of first-order Horn clauses is undecidable"
02:13:07 <Saizan_> though maybe that includes those with free variables (assuming that matters)
02:15:54 <quicksilver> Saizan_: that was what caused me to say "hmm, I can't remember any more :("
02:16:17 <quicksilver> Saizan_: I used to know how this all clicked together but the neurons have rotted
02:18:14 <dolio> Oh, right, at the very least, you'd have to eliminate predicates like "p(X) :- p(X+1)." But I suppose you could rule those out.
02:18:38 <quicksilver> dolio: well, that adds arithmetic
02:18:47 <quicksilver> dolio: once you put arithmetic in the game is definitely off.
02:19:02 <Saizan_> even symbolically
02:19:34 <dolio> Is "p(X) :- p(X)." any better?
02:20:14 <Saizan_> you could catch that with something like GHC's black holing
02:20:29 <dolio> Yeah.
02:21:23 <Saizan_> but p(X) :- p(f(X)). ?
02:22:25 <dolio> p(true) :- p(false). p(false) :- p(true).
02:22:37 <dolio> I don't know. Something like that.
02:23:54 <Saizan_> though you could generate the minimal herbrand model and check against that, you don't need to use a reasonable evaluation model :)
02:24:11 <dolio> :)
02:24:23 <uzytkownik> @hoogle a -> IO (ForeignPtr a)
02:24:23 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
02:24:23 <lambdabot> Foreign.ForeignPtr mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
02:24:23 <lambdabot> Data.ByteString.Internal mallocByteString :: Int -> IO (ForeignPtr a)
02:26:06 <kbp> quicksilver: I know this is a silly question but when people write (A /\ B => C), do they mean (A /\ B) => C or A /\ (B=>C) ?
02:26:30 <quicksilver> the former
02:26:55 <quicksilver> it is a widely held convention that /\ and \/ bind tighter than =>
02:27:23 <kbp> quicksilver: alright thank you so it's (A /\ B ) => C
02:27:27 <quicksilver>  /\ and \/ are sufficiently doubtful that most authors use explicit () for those though.
02:28:25 <kbp> quicksilver: but if authors dont state that then it's hard for newbies like me (I searched google for priority but couldnt find it so I needed to ask you)
02:28:50 <kbp> :)
02:29:23 <dolio> I have a book that uses its own crazy notation to eliminate parentheses.
02:29:50 <dolio> Like, it puts small black squares next to operators to indicate how things are supposed to bind.
02:30:03 <quicksilver> I'd choose /\ to be tighter than \/ if I had to choose something. But I'd rather use explicit () and be sure to correctly communicate.
02:30:34 <dolio> So "A => B []=>[] C => D" is "(A => B) => (C => D)".
02:31:49 <quicksilver> cute. well. or maybe not.
02:31:54 <dolio> Or Peirce's law is P => Q []=> P []=> P.
02:32:57 <Saizan_> the =>[] C => D makes it quite weird
02:33:30 <dolio> Yeah, well, they don't assume an associativity for => like you'd be used to for Haskell.
02:34:03 <dolio> So even to do a -> b -> c they'd write A =>[] B => C.
02:35:45 <ehamberg> I have a type constructor Foo Int Int Int and a list [1,2,3], is there an easy way of making a Foo with ints from my list?
02:36:14 <Saizan_> mkFoo [a,b,c] = Foo a b c :)
02:36:25 <Saizan_> that's the easiest
02:36:36 <ehamberg> yeah, i guess. thanks. :)
02:54:36 <medfly> @seen Cale
02:54:36 <lambdabot> I saw Cale leaving #haskell, #haskell-in-depth, #ghc and #haskell-overflow 3h 43m 20s ago, and .
02:55:22 <|Steve|> Why does ghci tell me that List.permutations is not in scope?
02:55:56 <|Steve|> Similarly with List.subsequences. Other Data.List functions seem to be in scope.
02:57:31 <doserj> List /= Data.List. also, Data.List differs a bit between ghc versions
02:58:28 <|Steve|> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Apermutations tells me that permutations is in Data.List and my prompt "Prelude Data.List>" seems to indicate that I've successfully imported the module.
02:58:34 <doserj> subsequences and partitions were introduced in base-4, I think
02:59:02 <|Steve|> I don't know what base-4 is, but I guess you mean that it's not in whichever version I'm using.
02:59:02 <doserj> |Steve|: what ghc version do you have?
02:59:06 <|Steve|> 6.8.3.
02:59:13 <RayNbow> it was introduced in 6.10
02:59:18 <|Steve|> Ah ha!
02:59:33 <|Steve|> Looks like I should update my haskell.
02:59:36 <|Steve|> er ghc
03:09:55 <|Steve|> I suppose partitions is easy enough to write. I don't know if it can be written more compactly, but partitions [] = [[]] and partitions xs = do n <- xs; rest <- partitions (delete n xs); return (n:rest).
03:10:09 <|Steve|> er, but that seems to work.
03:12:02 <uzytkownik> @hoogle (>>)
03:12:02 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:12:02 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
03:12:02 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
03:12:09 <uzytkownik> @hoogle (<<)
03:12:10 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
03:12:10 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => Html -> b -> a -> b
03:12:10 <lambdabot> Text.XHtml.Transitional (<<) :: HTML a => Html -> b -> a -> b
03:12:33 <uzytkownik> @hoogle m a -> m b -> m a
03:12:34 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
03:12:34 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
03:12:34 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:13:22 <uzytkownik> Hmm. Why there is no right to left sequence operator for monads?
03:13:52 <int-e> > Just 1 << Just 2
03:13:53 <lambdabot>   Not in scope: `<<'
03:14:45 <opqdonut> yeah that's strange
03:14:48 <opqdonut> because there is =<<
03:15:38 <mux> > Just 1 <* Just 2
03:15:39 <uzytkownik> If I use . operator in monad (such as return True << a . b =<< c) it's more natural
03:15:39 <lambdabot>   Just 1
03:16:11 <uzytkownik> @mux: In my case it'll work.
03:16:11 <lambdabot> Unknown command, try @list
03:16:13 <dibblego> Applicative ftw
03:16:49 <|Steve|> (a . b =<< c) >> return True?
03:17:03 <uzytkownik> @mux: But if you have side-effects (IO monad, parsec) then in a <* b a is run before b.
03:17:04 <lambdabot> Unknown command, try @list
03:17:05 <Saizan_> i'd use do-notation btw
03:17:27 <Saizan_> uzytkownik: don't use @, lambdabot sees it as a command if you do
03:17:45 <uzytkownik> Saizan_: Ups. Too much identica ;)
03:17:52 <mux> uzytkownik: that's precisely what you want though; if you'd want to run b first you could just have b >> a
03:18:30 <|Steve|> @type (<*)
03:18:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
03:19:15 <uzytkownik> @mux: Well - sometimes yes sometimes no. Otherwise there would be no point for:
03:19:15 <lambdabot> Unknown command, try @list
03:19:20 <uzytkownik> Sorry
03:19:43 <|Steve|> uzytkownik: No need for @. Just typing a name is enough for highlighting in most irc clients.
03:19:46 <uzytkownik> @type (^<<)
03:19:48 <lambdabot> forall c d (a :: * -> * -> *) b. (Arrow a) => (c -> d) -> a b c -> a b d
03:19:54 <uzytkownik> @type (<<^)
03:19:56 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> (b -> c) -> a b d
03:20:02 <uzytkownik> @type (^>>)
03:20:03 <lambdabot> forall b c (a :: * -> * -> *) d. (Arrow a) => (b -> c) -> a c d -> a b d
03:20:09 <uzytkownik> @type (>>^)
03:20:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> (c -> d) -> a b d
03:20:50 <lilac> (<<) = flip (>>) != (<*)
03:21:16 <uzytkownik> |Steve|: I know I know - I just type it automatically (my brain was written probably in some assembler so it's far from being bug-free).
03:22:06 <uzytkownik> lilac: Yes - I wander why there is no (<<) as flip (>>).
03:43:48 <fatal_error> hello
03:43:58 <fatal_error> i need a db solutions
03:44:04 <fatal_error> for haskell
03:44:12 <fatal_error> 200k hits an hour
03:44:19 <fatal_error> large volume of data
03:44:59 <Taejo> fatal_error: we are programmers, not PHBs. We can provide bindings, libraries, etc., not "solutions"
03:45:10 <Taejo> s/provide/point you to/
03:45:11 <fatal_error> lol
03:45:22 <Saizan_> see HDBC on hackage
03:45:27 <fatal_error> no i'm asking because it needs a haskell lib
03:45:34 <Axman6> fatal_error: there are plenty of database libraries for haskell
03:45:52 <Axman6> HDBC is the Haskell DB Connection fatal_error ;)
03:46:00 <fatal_error> what would be the best server?
03:46:02 <fatal_error> happs?
03:46:08 <Axman6> ...
03:46:20 <Axman6> happs isn't a database server...
03:46:24 <fatal_error> i know
03:46:50 <fatal_error> what haskell server to handle 200k hits an hour also
03:47:09 <Axman6> well, happstack is the biggest web app name
03:47:32 <fatal_error> will it handle the load?
03:47:39 <Axman6> sure
03:47:54 <Saizan_> > 200000 / 3600
03:47:55 <lambdabot>   55.55555555555556
03:48:54 <fatal_error> why doesn't hpaste2 use happs
03:48:57 <fatal_error> ?
03:49:21 <fatal_error> also heard that happs not developt much
03:50:19 <Axman6> yes, but happstack is
03:52:50 <quicksilver> fatal_error: 200k hits per hour is nothing
03:53:03 <quicksilver> you could handle that by hand by telephoning Axman6 each time it came in :P
03:53:11 <fatal_error> lol
03:53:20 * Axman6 is up for the job
03:53:21 <quicksilver> but seriously, that's not likely to be a big problem for any sensible server
03:53:38 <fatal_error> i got lots of calculations to do though
03:53:48 <quicksilver> it's more about hving hardware up to the task CPU / network card / firewal / load balancer
03:54:21 <quicksilver> having said that I have no experience of running serious haskell web applications - and not many people do
03:54:26 <fatal_error> also is happstack stable to hacking and ddos?
03:54:34 <quicksilver> happs is the most 'serious' but it's not that widely deployed
03:54:57 <fatal_error> its a balance between erlang and haskell
03:55:05 <Saizan_> there's at least a facebook app running in happstack :)
03:55:16 <quicksilver> you'll find the erlang solutions are more widely tested and so on
03:55:19 <fatal_error> Saizan_ which one?
03:55:20 <quicksilver> haskell is the better language though
03:55:28 <fatal_error> agreed
03:56:30 <fatal_error> erlang has mnesia db do go with it though
03:57:12 <Saizan_> would your data fit in ram?
03:57:41 <fatal_error> not all
03:57:46 <fatal_error> so no
03:58:04 <fatal_error> data in db will be flushed every 15 min
03:59:50 <Taejo> :t interact
03:59:51 <lambdabot> (String -> String) -> IO ()
03:59:59 <adh0c> hi
04:00:02 <fatal_error> i'm torn between erlang but slower calculations or haskell and faster calculations but less widley used and and unknown
04:00:38 <Axman6> haskell isn't unknown, i'd say more people know about it than erlang...
04:00:44 <fatal_error> :)
04:00:53 <fatal_error> unknown for large sites
04:00:54 <adh0c> I'm having trouble writing a function that would extract values contained in a new data type
04:01:31 <adh0c> I'm still rusty with the language, and google searches only turn up xml data extraction and such
04:01:35 <adh0c> either way
04:02:06 <adh0c> let's say I declare a new data type, data Weird = Weird Int Char
04:02:39 <adh0c> I would like to devise a function that would allow me to extract one or both of the values, without carrying "Weird" over
04:02:47 <yottis> then you use pattern matching
04:03:08 <medfly> http://en.wikibooks.org/wiki/Haskell/Type_declarations
04:04:48 <adh0c> thanks
04:05:25 <adh0c> I found the answer (makes me feel silly), but I will read the rest of the article too
04:06:16 <quicksilver> fatal_error: if you have existing erlang expertise and/or strong time constraints, follow the path well trodden
04:06:39 <quicksilver> fatal_error: if you have existing haskell expertise and are prepared to put some time into developing a good solution which may require you to write code to fill in some gaps.... use haskell.
04:07:13 <adh0c> I would suggest writing the code in whichever language is most suitable
04:07:29 <adh0c> assuming the time constraints allow it
04:07:33 <quicksilver> haskell is a slightly more suitable langauge
04:07:41 <quicksilver> but I think the problem is more available libraries/infrastructure
04:07:44 <adh0c> but again, if the language is suitable then you should save time using it
04:07:58 <quicksilver> not if you have to write your own DB layer or debug someone else's ;)
04:08:09 <quicksilver> (as opppose to using a well debugged one in some other language)
04:08:47 <adh0c> writing an OS in haskell must have been an "interesting" experience
04:09:05 <eevar2> could also flake out and use scala. there are plenty of java libs around
04:09:22 <fatal_error> lol
04:09:41 <fatal_error> quicksilver: good advice
04:09:59 <fatal_error> quicksilver: I'll stick to erlang and won't experiment
04:10:20 <adh0c> is it really noticably slower than haskell?
04:10:20 <fatal_error> quicksilver: Although would have been alot of fun to do it in haskell :)
04:10:27 <adh0c> I mean the implementation you're using
04:10:37 <fatal_error> yeah
04:10:40 <adh0c> erlang can be fun too
04:10:44 <adh0c> or so I've heard
04:10:53 <fatal_error> 40% slower
04:11:02 <adh0c> why?
04:11:13 <adh0c> that's a pretty big difference
04:11:21 <fatal_error> but i'm sure haskell can be even faster because i' not that good
04:11:43 <fatal_error> adhc: yeah haskell has a good compiler
04:12:22 <adh0c> I always laugh when I remember my teacher in high school showing us how to optimize our code
04:12:36 <adh0c> before you ask, Pascal
04:12:42 <fatal_error> lol
04:12:58 <fatal_error> brb
04:13:10 <Taejo> adh0c: where his/her optimisations very ad-h0c?
04:13:39 <adh0c> Taejo, you don't benchmark the teacher, the teacher benchmarks you!
04:13:45 <adh0c> or specifically, your code
04:13:54 <Phyx-> heh
04:14:11 <adh0c> but I felt frustrated about her (yes, her) ignoring all the advancements in compilers
04:14:21 <adh0c> Turbo Pascal all the way
04:14:31 <adh0c> blue screens, here I go
04:14:35 <Taejo> in Soviet Russia, teacher benchmarks you!
04:15:08 <adh0c> she also made some silly errors while writing the code on the whiteboard
04:15:51 <adh0c> but the language suited her perfectly, it was just as annoying
04:16:00 <fatal_error> lol
04:17:11 <Taejo> @pl \m -> modify ((M.insert v x m :). tail)
04:17:11 <lambdabot> modify . (. tail) . (:) . M.insert v x
04:17:14 <fatal_error> LOL LOL
04:17:21 <fatal_error> http://www.youtube.com/watch?v=pTUtETu09oQ
04:17:34 <fatal_error> funniest clip i seen in a while
04:18:13 <adh0c> outside of the fact that it's another fat dumb head taking youtube's server space with idiotic drama, I think I've seen that behavior somewhere
04:18:42 <fatal_error> lol
04:18:46 <adh0c> http://www.youtube.com/watch?v=aR7GUiiKEz0
04:18:58 <adh0c> maybe they're relatives
04:20:28 <fatal_error> lol
04:20:48 <fatal_error> brothers :)
04:21:14 <fatal_error> anyone gtg laters
04:21:19 <adh0c> bye
04:26:36 <jethr0> @paste
04:26:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:27:09 <Taejo> never had this issue before, but it's just happened three or four times in a row: I start vim from ghci with :e, and vim isn't responding
04:28:24 <Taejo> but about one time in three, vim runs fine
04:28:36 <Taejo> so "in a row" is not exactly accurate
04:29:47 <hackagebot> file-embed 0.0.2 - Use Template Haskell to embed file contents directly. (MichaelSnoyman)
04:31:13 <Taejo> > msum [Just 'a', Just 'b', Nothing]
04:31:14 <lambdabot>   Just 'a'
04:31:24 <Taejo> msum . map Just $ [1..]
04:31:28 <Taejo> > msum . map Just $ [1..]
04:31:29 <lambdabot>   Just 1
04:32:04 <Saizan_> > listToMaybe [1..]
04:32:06 <lambdabot>   Just 1
04:33:56 <jethr0> grr, haddock is giving me trouble
04:34:17 <jethr0> \Warning: Main: the following names could not be resolved:
04:34:19 <jethr0>     BM Tile IO BMState
04:34:30 <jethr0> even though those definitions are clearly imported in Main ;(
04:35:18 <jethr0> actually that may be my newtype monad. can't haddock handle those?
04:40:48 <greap> I'm having problems with opengl in ghci on osx. When I compile the programs run fine, but when I use runhaskell, or call main from ghci the windows render, then freeze.
04:42:11 <jethr0> i'm working with opengl under linux currently. could you paste some code?
04:42:23 <jethr0> are you using GLUT to manage the window, etc.?
04:47:49 <jethr0> @seen
04:47:51 <greap> jethr0: Yes, glut
04:48:07 <greap> 1 se
04:48:38 <jethr0> i'm not familiar with runhaskell. is that like runghc? i wonder if it could have sth to do with using ghci instead of compiling.
04:48:48 <jethr0> have you tried compiling it with "ghc --make" and run it?
04:49:30 <doofer> I'm trying to stack a state transformer on top of an ST monad, like this: type Env = StateT Objects (forall s. ST s), but I can't get it to compile (ST s is not applied to enough type arguments) ... any ideas?
04:49:45 <greap> jethr0: http://codepad.org/BcNY0zTz
04:50:04 <greap> jethr0: I think it just wraps ghci
04:50:30 <greap> jethr0: This code is taken mostly from http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
04:50:42 <jethr0> did you get the HelloWorld program to run?
04:51:20 <jethr0> @wiki OpenGLTutorial1
04:51:20 <lambdabot> http://www.haskell.org/haskellwiki/OpenGLTutorial1
04:51:27 <jethr0> this helped me a lot, at least under linux...
04:51:46 <greap> Yes, it runs fine when I build using: ghc -fglasgow-exts --make -W '%' -o gl.hs
04:51:56 <jethr0> sry, i'm currently in china. can't seem to connect to your paste server ;(
04:52:02 <greap> there are some small libs I can paste as well
04:52:19 <greap> jethr0: ah, ok. what ones work for you?
04:52:32 <jethr0> usually ghci is not so well suited for heavy IO/Library stuff. why not use runghc to execute it. it's almost as fast
04:52:36 <jethr0> "runghc Program.hs"
04:52:45 <greap> ok I'll try
04:52:50 <jethr0> 'what ones'?
04:52:59 <jethr0> @paste
04:52:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:54:40 <greap> ah, runhaskell is just a bash wrapper for runghc it seems.
04:55:03 <greap> both hang the windows that spawn
04:55:50 <jethr0> hmm... could you paste your code again? if it runs with 'ghc --make' then this is probably a ghci/runghc issue on mac os
04:56:10 <jethr0> unfortunately the channel is rather quiet right now. usually there would be dozens of mac users to the rescue ;(
04:56:29 <greap> it's about 5 files, I could put a tar somewhere if you like?
04:58:18 <mux> @pl \x y -> (x * y) `mod` m
04:58:19 <lambdabot> flip flip m . (mod .) . (*)
04:58:34 <poe> :t flip flip
04:58:36 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
04:59:21 <jethr0> greap: i'm in the middle of sth, sorry. maybe you can drop by later when the mac-crowd returns ;)
04:59:56 <jethr0> could you just paste the main calling code on a paste?
04:59:58 <jethr0> @paste
04:59:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:01:51 <greap> jethr0: no problems
05:02:13 <doofer> @check type Env = StateT Objects (forall s. ST s)
05:02:14 <lambdabot>   Parse error at "type" (column 1)
05:02:57 <jethr0> doofer: StateT has to be applied on a Monad
05:03:14 <quicksilver> I think you want newtype Env s a = StateT Objects (ST s a)
05:03:39 <jethr0> hehe, inline "forall s", is that supported?
05:03:58 <greap> modules: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8768 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8769 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8770 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8771 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8772
05:04:03 <quicksilver> you can have a nested forall but I don't believe it is what doofer wants in fact
05:05:03 <jethr0> greap: does the HelloWorld example actually work on your computer?
05:05:44 <adh0c> there must be some better graphics engine implementations than this one
05:05:52 <doofer> thanks for the replies! newtype Env s a = Env (StateT Objects (ST s a)) gives me Kind mis-match :S
05:06:07 <quicksilver> ah
05:06:08 <uzytkownik> Who is moderator of c2hs mailing list?
05:06:14 <jethr0> greap, you don't call 'getArgsAndInitialize"
05:06:15 <quicksilver> Env (StateT Objects) (ST s) a
05:06:19 <quicksilver> sorry ;)
05:06:19 <fasta> I found my first non-toy use for phantom types :)
05:06:34 <quicksilver> one more try
05:06:41 <quicksilver> Env (StateT Objects (ST s) a)
05:06:41 <opqdonut> fasta: ?
05:07:14 <doofer> quicksilver: the last one did it! thanks!
05:07:35 <fasta> opqdonut: I found a way to apply the idea of a phantom type in a real system.
05:08:02 <opqdonut> fasta: yes, that i understood. would you mind elaborating
05:09:10 <fasta> opqdonut: basically I create a record, r. This record has a Maybe foo field and a function which computes an updated record. This function has to be called before ever obtaining the foo value.
05:09:18 <greap> jethr0: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8773#a8773 This one works
05:09:24 <greap> but only when compiled
05:09:35 <fasta> opqdonut: I do that by letting the function return a value of type Record YesIReallYHaveCalledTheFunction.
05:09:38 <greap> the first example given doesn't work
05:10:23 <opqdonut> fasta: yes, i see
05:10:41 <opqdonut> fasta: i've used phantom types for similar purposes to enforce ordering of analysis phases in a compiler
05:10:54 <fasta> opqdonut: I can even improve it further by saying that the input type has to be Record NoIhaventcalledTheFunction.
05:10:57 <jethr0> greap: could you say a little more about his freezing of yours?
05:11:04 <Saizan_> fasta: have you considered using "f foo" as type of the field and go from f = Maybe to f = Identity ?
05:11:14 <opqdonut> fasta: the AST was parametrised over an annotation type, some processing steps didn't produce any real annotations so i used phantom types
05:11:23 <greap> jethr0: sure thing
05:11:43 <fasta> Saizan_: I don't parse that.
05:12:08 <quicksilver> Saizan_: I like that style but find it slightly clumsy in practice
05:12:24 <Saizan_> fasta: data Record f = R { field :: f Foo }
05:12:28 <quicksilver> Saizan_: there is also data IDontHaveAn a = HonestlyItsNotHere
05:12:35 <opqdonut> :D
05:12:40 <jethr0> do you actually get a real window with GLUT. under ubuntu i just get a windowless gl canvas
05:12:41 <quicksilver> Saizan_: (which perhaps has a more sensible name in the literature)
05:12:58 <greap> A white window is created with the title of 'ghc', cpu usage goes to ~100%, the window and menus become unresponsive and need to be killed with force-quit.
05:13:31 <fasta> Saizan_: and then encoding the constraint in f?
05:13:42 <greap> When compiled the same window is created, but is titled correctly and responds and exits correctly.
05:13:54 <fasta> Saizan_: no, but I don't see the use for that now, but maybe later when I have lots of these things.
05:14:23 <jethr0> hmm, not sure i can help. for now try compiling every time and ask one of the mac os masters
05:14:28 <fasta> Saizan_: oh, I see what you mean now.
05:14:30 <quicksilver> greap: I'm not following the conversation but are you saying 'gui apps don't work from ghci' ?
05:14:33 <Saizan_> well, depending on the f you can require that you do have a Foo or that you don't or that Maybe you've it :)
05:14:40 <quicksilver> greap: because the answer is "no they don't it sucks"
05:14:46 <greap> quicksilver: opengl gui apps
05:14:49 <quicksilver> correct
05:14:54 <quicksilver> they don't, sorry about that.
05:14:57 <fasta> Saizan_: but I don't think that would do the same.
05:14:59 <greap> I'm not sure if they're supposed to.
05:15:06 <quicksilver> it would be nice if they did
05:15:29 <quicksilver> I don't fully understand the problem but, roughly, GLUT wants to create a 'new' application context
05:15:38 <quicksilver> and GHCi is 'already' an application
05:15:41 <quicksilver> so it goes odd.
05:15:42 <greap> quicksilver: is there any commonly accepted explanation :
05:16:03 <greap> hmm, interesting
05:16:20 <greap> does that explain the cpu usage though?
05:16:26 <quicksilver> not really
05:16:33 <fasta> Saizan_: hmm, they would do the same. No, I hadn't considered that. Isn't this equavalent to phantom types always then?
05:16:37 <quicksilver> but it's probably busy-waiting for some signal which never arrives
05:16:39 <quicksilver> or something.
05:17:06 <greap> ah yeah.
05:17:20 <quicksilver> it would be nice to properly understand (and perhaps even fix)
05:17:35 <quicksilver> but my knowledge of OSX is emotional, rather than technical
05:17:43 <quicksilver> I love it and hate it but I don't understand it.
05:17:57 <greap> quicksilver: Mmm, it would make development much nicer :)
05:18:08 <Saizan_> fasta: mh, phatom types are used in many contexts
05:19:40 <fasta> Saizan_: I think doing it explicitly by naming the type is best in this particular application context.
05:20:28 <Saizan_> you mean what you had initially?
05:20:51 <gwern> hm
05:21:02 <Saizan_> i never used my suggestion in practice anyway :)
05:21:03 <gwern> has anyone else received an email from students at a 'Pune University'?
05:21:27 <gwern> (India. no surprise; he writes like an indian)
05:21:35 <Saizan_> since in my case i'd need many parameters like that, and it'd get messy
05:22:25 <gwern> wonder why he thinks I can give advice on 'linux memory management'?
05:22:57 <gwern> I once wrote a WP article on prelink which is a linux memory thing, but then it should've been mailed by way of Wikipedia...
05:24:47 <quicksilver> your reputation as a polymath is well established throughout the esteemed halls of the intertubewebs, gwern.
05:25:25 * gwern guesses?
05:25:51 <gwern> this sudden shame, the fear of being exposed as an intellectual fraud - now I know what it's like to be george w. bush!
05:26:21 <adh0c> my reputation as a polymer is still questionable
05:26:34 <Gabbie> was he ever considered to have any intellect to cause fraud?
05:27:15 <gwern> Gabbie: as texas governor there weren't any jokes
05:27:35 <gwern> I remember the videos showing various appearances over time - as he got closer to the presidency, he got less articulate and dumber
05:27:43 <Gabbie> gwern, only because he'd strap you to a chair
05:27:49 <adh0c> Texas never had any jokes either
05:27:59 <lilac> i'm looking forward to his autobiography revealing that it was all an act :-)
05:28:00 <gwern> (it was quite strange. I almost liked Governor-Bush, although President-Bush barely seemed smart enough to breath)
05:28:14 <int-e> no jokes?
05:28:17 <Taejo> @pl \ls -> (M.insert v x (head ls) :) . (tail ls)
05:28:18 <lambdabot> ap ((.) . (:) . M.insert v x . head) tail
05:28:31 <adh0c> int-e, besides the governor
05:28:31 <int-e> I have this in my quotes file: "Education in Texas has improved greatly under the George W. Bush administration.  Now, 60% of Texas 6th graders read at a higher level than the Governor.  Under Governor Ann Richards, few if any achieved these levels of literacy."
05:29:02 * gwern decides to send a straightforward helpful email. it's pretty unlikely it's a troll
05:29:18 <gwern> and there's no reason to be prejudiced against indian programmers, I suppose
05:29:24 <gwern> (even if they're taking our jobs)
05:29:26 <adh0c> plz2send code
05:29:41 <adh0c> (durr hurr OUR job durr hurr)
05:30:08 <Athas> dons: ping
05:31:42 <jethr0> somehow haddock can't seem to handle newType declarations... any ideas?
05:32:23 <fasta> gwern: The Bush genes have produced more value than most genes (unless you are a secret billionaire), so for some value of smart, Bush is smarter than most people.
05:32:37 <gwern> value?
05:32:41 <gwern> how do you figure?
05:32:49 <fasta> gwern: value as in the monetary system.
05:33:03 <lilac> the us presidency is a reasonably highly-paid job
05:33:12 <adh0c> you mean his colleagues have produced value
05:33:12 <Vanadium> Being paid does not imply producing value
05:33:15 <gwern> bernanke has produced more 'value' than anybody ever, then
05:33:27 * gwern thinks this is an economics fail by fasta 
05:33:29 <adh0c> as far as I remember, Harken Oil wasn't the industry giant
05:33:40 <quicksilver> possibly a bad choice of word but I see what fasta means
05:33:51 <quicksilver> the bush genes have made plenty of money for the bush family
05:33:52 <lilac> gwern: it's an economics fail if the president isn't rewarded in line with his contributions
05:33:56 <fasta> quicksilver: yep
05:34:12 <gwern> adh0c: no, harken oil was an utter failure that was only bailed out by middle eastern investment despite harken oil having no expertise whatsoever for the job they were supposedly hired for
05:34:13 <quicksilver> the perks of being president are worth much more than the salary, obviously
05:34:37 <Vanadium> I would rather have the salaray, tbh
05:34:39 <gwern> quicksilver: yes, but producing wealth most certainly != accumulating money
05:34:41 <fasta> Clinton gives talks for $100,000/hour.
05:34:52 <Vanadium> I would suck at giving talks
05:35:46 <fasta> I think someone who makes it to be president is either very smart, or has powerful friends and therefor is smart for having those friends.
05:36:02 <osfameron> or very privileged
05:36:06 <gwern> Vanadium: when you're a former president whose party is in power, you're allowed to suck at giving talks
05:36:06 <adh0c> have you considered the question of luck
05:36:12 <mux> I have a very different definition of smartness
05:36:57 <fasta> Sure, there might be some luck involved, but mostly it is just recklessly trying to accumulate wealth without regard for others.
05:37:11 <fasta> It's like playing Civilization on a high level ;)
05:37:24 <jethr0> anyone who used haddock seriously before?
05:37:31 <lilac> fasta: it doesn't take much in the way of smartness to try to rob a bank
05:37:32 <gwern> so... insanely destructive and violent?
05:37:33 <fasta> If you are a nice person, you don't get wealthy.
05:37:44 <gwern> no. it takes smartness to rob it successfully
05:37:47 <fasta> lilac: try to rob a bank.
05:37:51 <adh0c> define nice
05:38:09 <lilac> fasta: no thanks, i'm not interested in money to that extent
05:38:24 <gwern> 'thank you sir for your reply'
05:38:36 <gwern> mm. I was hoping for an explanation why he emailed me ~-~
05:38:56 <gwern> but at least he knows his etiquette - sir by default, a thank you for replies
05:39:03 <lilac> if ten thousand people try to rob a bank, several will get lucky and get away with it. that doesn't make them smart.
05:39:06 <gwern> more than most americans can do
05:39:07 <Lemmih> fasta: Steve Wozniak must be an evil bastard, then.
05:39:07 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
05:39:35 <adh0c> gwern, the last person who called me "sir" was some nigerian prince
05:39:37 <jethr0> lemmih!
05:39:41 <adh0c> at least by email
05:39:49 <gwern> Lemmih: steve was ridiculously good and lucky, you have to admit
05:39:57 <gwern> jobs could easily have pushed him out early on
05:39:59 <Lemmih> jethr0: I most likely forgot it.
05:40:05 <quicksilver> hmm let's take the politico-economics to haskell-blah?
05:40:05 <Taejo> Anyone for a round of golf? I think it's a fairly nice problem (from a compilers assignment): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8774#a8774
05:40:30 <gwern> (story of tons of tech companies, the techy gets pushed out with a fragment of what he could've gotten)
05:40:36 <jethr0> it's probably also a lot of work to map all those trillion key symbols
05:40:37 <fasta> Lemmih: and how many people like Wozniak are there? Gates obviously doesn't count.
05:41:00 <jethr0> Lemmih: should i write a patch or do you remember in the back of your mind the good reason why you didn't implement it?
05:41:29 <Lemmih> fasta: I'm not sure I'd count Gates as a bad guy.
05:41:48 <adh0c> I would if I were to use my definition of "bad guy"
05:42:13 <gwern> it would be nice if an economic historian were to one day total up how much damage gates' life has done the world economy
05:42:45 <Lemmih> gwern: I'm quite sure he added a lot of wealth.
05:43:00 <adh0c> I wouldn't say that
05:43:02 <adh0c> I mean
05:43:10 <adh0c> Microsoft surely did add some wealth
05:43:16 <adh0c> but Gates not so much
05:43:26 <randomwords> @hoogle later
05:43:26 <lambdabot> Distribution.Version LaterVersion :: Version -> VersionRange
05:43:26 <lambdabot> Distribution.Version orLaterVersion :: Version -> VersionRange
05:43:29 <gwern> did he? seems to me in the server space unices have always been superior, and in the consumer space, macs would've likely been better
05:43:39 <jethr0> hmm
05:43:40 <Lemmih> How can you tell what Microsoft would have been without Gates?
05:43:58 <quicksilver> it's obvious what would have been better, an OS written in haskell
05:44:01 <gwern> I can't; which is why the right assumption is to assume MS wouldn't've existed
05:44:02 <adh0c> I can't
05:44:06 <fasta> I have no Microsoft product which is only made by Microsoft.
05:44:14 <Athas> You kinda need gates for electronic computers.
05:44:16 <adh0c> but can I make a conjecture just because I can't speculate on that level?
05:44:22 <adh0c> Athas, not really no
05:44:31 <Lemmih> gwern: Exactly. And Microsoft /has/ added a lot of wealth.
05:44:35 <adh0c> vacuum tubes <3
05:44:49 <gwern> Lemmih: if MS never existed and the windows niche filled by macs and unices, how many billions a year in security costs would we be saved?
05:44:55 <Athas> Those are not microcomputers, though!  So Microsoft without gates would have been... Soft.
05:44:59 <gwern> a perpetual ongoing global drain of weatlth
05:45:03 <adh0c> the point isn't whether MS would have existed
05:45:15 <adh0c> the point is what would have filled the gap
05:45:18 <adh0c> either way, afk
05:45:37 <Lemmih> gwern: People picked Microsoft over Apple and unices. They did so for a reason.
05:45:54 <gwern> Lemmih: are you going to argue Homo Economicus and the efficient market now?
05:45:54 <fasta> Lemmih: I am pretty sure 90% never compared.
05:45:57 <Athas> What does the AnyEvent event type mean in the Xlib binding?
05:46:48 <Lemmih> fasta: That doesn't matter. I'm not saying Windows is objectively better than any Mac OS.
05:47:23 <Lemmih> The safety you get from buying Windows is definitely worth something.
05:47:32 <gwern> safety? windows?
05:48:09 <Lemmih> Yes, safety as in you are fairly sure any windows application will run on your machine.
05:48:10 <fasta> Lemmih: I am saying that people did not do it for any specific reason. They just used what their neighbors were using. MS did the marketing quite well, but that's about it.
05:48:10 <maltem> Athas, it's a constructor, not a type (according to the docs at least)
05:48:29 <Lemmih> Safety as in all Windows machines look about the same.
05:48:32 <maltem> and I suppose it means some event :)
05:48:54 <Athas> maltem: yes, but XAnyEvent in xlib is more of a C-ism to work around the C type system, and by inspecting the packages I suspect the Xlib binding has a bug.
05:49:08 <Athas> I get AnyEvent values when I'd expect FocusIn and FocusOut.
05:49:09 <Lemmih> fasta: Exactly. Using what your neighbors are using is valuable.
05:49:26 <fasta> Lemmih: no, it's just an inexpensive decision making process.
05:49:31 <fasta> Lemmih: at least on the short-term.
05:49:34 <gwern> MS took advantage of historically contingent events related to new products and licensing and mistakes by competitors; that this is true and MS won the OS wars *does not* imply in anyway that the world economy which had standardized on Windows would be wealthier than one which had standardized on Unix/Mac
05:49:47 <gwern> and we have clear reasons to believe that the latter would be wealthier
05:50:09 <Athas> Well... 80s Unix was really not very good.
05:50:12 <maltem> Athas, maybe it's used for events that aren't subsumed by any other constructor? (Or do those not exist?)
05:50:20 <maltem> oh
05:50:25 <gwern> Athas: and DOS was better?
05:50:40 <osfameron> CP/M!
05:50:42 <Athas> Do you think we'd have seen the GNU/Linux solidification if the Unix vendors had not been bloodied by Microsoft?
05:50:43 <quicksilver> gwern, Lemmih, fasta : -blah please
05:51:11 <Athas> If ever Unix shard had remained economically viable to the vendor, perhaps the situation would have remained a mess.  Then again, maybe not.
05:51:27 <lilac> Taejo: is it legal to have variables called 'beginscope', 'endscope', 'use' or 'define'? must variable names by alhpabetic? must values be numeric?
05:51:31 <fasta> Is there a generic way to build show functions for non-H98 data types?
05:51:42 <gwern> Athas: well, then you get into the issue of freebsd. I do wonder whether the world would've been better off if freebsd had come out the few months earlier necessary to cause linux to be stillborn
05:52:05 <quicksilver> fasta: a large subset of them at least
05:52:13 <gwern> it's an interesting topic, though I don't think I've ever seen any freebsders, who are more knowledgeable than I on the topic, speculate, so I dunno
05:52:19 <maltem> Athas, well focusIn isn't declared in the bindings, short of focusIn = 9, focusOut = 10 ?
05:52:30 <quicksilver> fasta: I think GHC HEAD is slightly more optimistic about applying the builtin derivings to trickier types?
05:52:44 <Athas> maltem: oh, so it's not really a bug, more of a misfeature.
05:52:46 <quicksilver> fasta: I presume you're thinking of gadts?
05:52:48 <Athas> I suppose I'll live.
05:52:56 <Athas> Or a misdesign, rather.
05:53:17 <Taejo> lilac: heh, I don't actually have the specs on me, so I'd say go with whatever answers are convenient (for me it was convenient to allow any variable names and any values as long as they don't contain whitespace)
05:53:23 <fasta> quicksilver: Basically, I want to have a show instance which is exactly the same as the H98 one, but with the existential replaced by <here there is some existential, without show>. If the existential has Show, it must of course just call that show.
05:53:36 <quicksilver> ah, existentials
05:53:38 <maltem> or maybe the best idea they had to resemble the c api
05:53:43 <quicksilver> no, i"m not aware of any generic way to do that :(
05:54:07 <Athas> maltem: no, xlib has this horrible XFocusChangeEvent.
05:54:45 <maltem> I see
05:54:56 <maltem> so it's just lacking?
05:54:57 <Lemmih> gwern: I'm arguing for free markets. The behaviour of individual actors is irrelevant to macro economic principles.
05:55:19 <Athas> Yes... but in a weird way.  The bindings are close to xlib in other ways.
05:55:33 <gwern> Lemmih: are you making some absurd efficient markets hypothesis? in the real world, markets don't always lead to pareto optimums
05:55:41 <Athas> I just don't understand why they used AnyEvent instead of specifying a FocusChangeEvent.  There's no functional difference that I can see.
05:56:27 <Lemmih> gwern: There's no such thing as absolute efficiency. I am saying, however, that free markets will /always/ be more efficent than non-free markets.
05:57:11 <gwern> windows' dominance is a clear market failure. it started off worse than macs and unices in every way; it was engineered in a poorer way so badly it had to be rewritten as windows nt; every dollar or man-hour spent polishing that turd to the point where it *might* be as good as unices or Macs at *something* was *utterly* wasted and guaranteed a suboptimal outcome. this is basic economics
05:58:15 <Phyx-> </gwern_rant>
05:58:21 <gwern> Lemmih: then you need to brush up on your economics. even the austrians admit that the free market can be met or exceeded in static situations by a socialist or other system; therefore your always is flatly incorrect
05:58:37 <EvilTerran> Phyx-, i think that was premature ;)
05:58:53 <Phyx-> EvilTerran: hehe, didn't expect there to me more :)
05:59:00 <Athas> I think you need to define "efficiency" in a nontrivial way.
05:59:08 <Athas> Or maybe use a very long time-frame.
05:59:38 <gwern> Athas: yes, it is nontrivial. but given the basic framework of utility functions and input resources, you can get a very solid definition
05:59:52 <Lemmih> gwern: I am very familiar with the Austian school of economics and I'm quite sure that is not one of their viewpoints.
06:00:00 <Lemmih> gwern: Let's continue in #haskell-blah?
06:00:35 <gwern> Lemmih: then you would be quite wrong; I take this straight from Hayek. the austrian point is that there are no static economies, and that dynamic economies are where they win
06:04:07 <Lemmih> gwern: Exactly.
06:04:18 <Lemmih> gwern: Maybe I don't get your point.
06:04:53 <lilac> Taejo: can I use Data.List.Split?
06:04:58 <gwern> my point is that a universal is disproved by a single counterexample, and that you were either wrong or being very sloppy in your language
06:05:40 <gwern> jeffheard_home: morning. so how does bigboard use pmwiki already? :)
06:06:55 <Lemmih> gwern: So Hayek says that there are no static economies and that free markets always win in dynamic economies. I say free markets always win. Seems like simple logic to me.
06:07:26 <Taejo> lilac: if you like. since I'm not awarding prizes, I'm not exactly hardcore on the rules
06:07:41 <Taejo> what are the usual rules for Haskell golf?
06:08:03 <jeffheard_home> gwern: hey.  it obviously doesn't directly call it.  It simply creates URLs and puts them in the main database (which PmWiki does not see).  Those URLs are the correct format for linking to pages in PmWiki
06:08:19 <jeffheard_home> since if a page doesn't exist in PmWiki, it is automatically created upon being referenced, that
06:08:27 <jeffheard_home> is the way that new content is created
06:09:02 <lilac> Taejo: Not sure. Anything in "base" except 'unsafe*'?
06:09:04 <gwern> Lemmih: the difference is when we consider hypotheticals. we can consider worlds in which qdos wasn't licensed to ibm, or cpm's creator didn't blow off ibm, and so dos and windows never existed versus the world in which it did
06:09:23 <gwern> Lemmih: we can think, what if some external authority forced everyone to avoid windows
06:09:35 <Taejo> lilac: I don't see why unsafe* should be forbidden. It's golf, not a beauty contest
06:09:49 <gwern> locked into a 'free markets always win!' mindset, we have to by assumption assume that Windows is the optimal wealthiest outcome
06:10:28 <gwern> jeffheard_home: oh. hm. what would be the difference between an empty page being created on a bigboard user visting that URL, and a BB user visiting the URL and seeing a 'create this page?' link?
06:10:38 <gwern> jeffheard_home: is there really that little integration?
06:11:04 <jeffheard_home> yep.  that's why I used it.  required the minimum of initialization
06:11:52 <gwern> jeffheard_home: so whats the URL schema?
06:13:43 <jeffheard_home> http://www.host.org/path-to-wiki-root/index.php?n=Title
06:14:03 <gwern> ah. that's no good then; gitit is just 'host.org/title'
06:14:26 <gwern> jeffheard_home: I suppose a config option would be needed then to switch between schemas
06:14:40 <jeffheard_home> it's already there
06:14:41 <jeffheard_home> actually
06:14:46 <jeffheard_home> in thebigboard.ini
06:14:57 <bastl> hello, I have a problem with cabal. I use import Data.Data in my sources, added syb to dependencies, but it complains that it doesnt find the module...
06:15:00 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3446
06:15:04 <roconnor> > 16 % 116
06:15:05 <lambdabot>   4 % 29
06:15:20 <jeffheard_home> assuming that gitit can manage the same lack of pre-initializatoin for a page.
06:15:23 <gwern> bastl: data.data moves around in packages based on ghc version, iirc, sure it's in your syb?
06:16:03 <ErhardtMundt> hail
06:16:06 <gwern> jeffheard_home: well as I said if you visit a non-existing page you get a normal page except where the content would be is a link saying 'create this page?' and you click on it and get an edit form
06:16:10 <bastl> i simply cabal installed syb on 6.10.3 im not sure
06:16:11 <roconnor> > 24 % 116
06:16:12 <lambdabot>   6 % 29
06:16:22 <jeffheard_home> oh, missed you saying that
06:16:33 <jeffheard_home> that'd work.
06:16:35 <gwern> jeffheard_home: it's a lot like MediaWiki that way
06:16:43 <gwern> I assume pmwiki is much the same
06:16:46 <jeffheard_home> yep
06:16:59 <gwern> if you edit the 'existing' page then the page really comes into exist
06:17:05 <jeffheard_home> so hypothetically, you could use gitit without changes to the code.  just change the ini file.
06:17:11 <gwern> since obviously it can't be storing on disk all possible page titles
06:17:21 <Saizan_> bastl: Data.Data is from base-4.*
06:17:43 <jeffheard_home> yes... is it entirely file based or is it also database based?
06:17:44 <bastl> I hate fiddling around with different versions of packages ...
06:17:46 <gwern> jeffheard_home: sounds like it, if that's the extent of integration. but I'm surprised you don't have extra features - like if you mouse over the link a little frame pops up with the first 100 characters say
06:18:05 <bastl> these things are not very stable :-/
06:18:26 <gwern> jeffheard_home: gitit delegates all of the article content to the filestore package, which currently only can work with darcs and git repos. we have a half-complete sqlite module for filestore though...
06:18:27 <hackagebot> agum 1.0 - Unification and Matching in an Abelian Group (JohnRamsdell)
06:18:39 <Saizan_> bastl: they are stable only within a major version
06:18:41 <gwern> bastl: stability is the price you pay for progress! if you want stability go use java
06:18:48 <jeffheard_home> gwern: the link in the app has its own separate text, and mousing over costs an extra frame render.
06:19:09 <jeffheard_home> which I try to avoid, because this app is one that will be used on fairly old computers
06:19:42 <gwern> hm. this extra render has to redo the entire map/enormous set of images? surprised you can't just overlay it or something
06:20:09 <jeffheard_home> that's not the render.  the render goes to the selection buffer
06:20:13 <gwern> (or maybe print to some sort of status bar at the bottom, but from the video bigboard doesn't have any such thing)
06:20:38 <bastl> gwern: so how to make progress then? When im using an experimental/unstable branch im expecting these issues, but I dont want to think about base-3 or -4 in my day-to-day work
06:21:04 <bastl> and ghc is no "research prototype" ...
06:21:18 <gwern> bastl: copy the base flags functionality from some other package's cabal file like xmonad, or just pick a ghc version and stick with it
06:21:21 <jeffheard_home> gwern, there isn't a status bar at the bottom, no - just a couple of text boxes with the current coordinates
06:21:27 <etpace_> > mappend (Sum 5) (Sum 6)
06:21:29 <lambdabot>   Sum {getSum = 11}
06:21:31 <jeffheard_home> but more text could be overlayed quite easily
06:21:57 <etpace_> :t First
06:21:59 <lambdabot> forall a. Maybe a -> First a
06:22:04 <bastl> thanks alot, gwern.
06:22:24 <gwern> bastl: that's how you're supposed to make a package work across base versions btw, using cabal flags to pick what to build=-depend on
06:22:39 <etpace_> :t Last
06:22:40 <lambdabot> forall a. Maybe a -> Last a
06:23:19 <gwern> jeffheard_home: well, it's a feature to consider. I dunno how much time you have to develop bigboard, but why not try out using it with gitit? as I said in my comment, it simplifies depolyment to have as much as possible in one language
06:23:24 <etpace_> > mconcat $ map First $ [Nothing, Just 5, Just 6]
06:23:26 <lambdabot>   First {getFirst = Just 5}
06:23:54 <jeffheard_home> gwern: I completely agree with that.  I could experiment with using gitit.
06:24:45 <jeffheard_home> I will say that the other reason I don't is that I can't run haskell on the server that the data is on.  None of our production servers will bootstrap the compiler without a good day's worth of work preparing them
06:24:55 <jeffheard_home> but I could put it on an experimental server
06:25:16 <jeffheard_home> our sysadmin puts all the production level servers on a CentOS 5 variant
06:25:31 <gwern> can't you static link gitit and copy it over?
06:25:47 <gwern> (you couldn't do that with plugins enabled, probably though because of the ghc api)
06:26:21 <jeffheard_home> well, right, and also the CentOS version of libc is a nightmare version; not even the same as its close relation Fedora
06:26:27 <jeffheard_home> if I could find one using the same libc, then yes
06:26:59 <jeffheard_home> but afaik, libc tends to be dynamically linked even if nothing else is
06:27:18 <gwern> true, I don't think you can link that in, although I might've heard of it being done once
06:27:56 <lilac> Taejo: 298 characters excluding imports
06:28:17 <Taejo> lilac: nice
06:28:19 <Taejo> paste?
06:29:12 <jeffheard_home> alright...  bbiaf.  gotta remove that _home from my login name
06:29:52 <lilac> Taejo: pasted
06:30:57 <lilac> Taejo: oops, 'xs' is a bad variable name ;-)
06:33:08 <gio123> is here anybodu from portugal?
06:39:25 <Taejo> lilac: it doesn't seem to handle scopes correctly
06:40:12 <lilac> Taejo: hmm, i've introduced a bug at some point :-/
06:40:58 <gio1234> is here anybodu from portugal?
06:41:31 <Taejo> gio1234: doesn't look like it, does it
06:46:02 <Geheimdienst> guys, i have a problem, possibly because i'm a newbie
06:46:27 <Geheimdienst> i have a cabal package. cabal install --reinstall does the right thing
06:47:30 <Geheimdienst> but when i get the tar.gz from my .cabal/packages/ + extract it + do runhaskell Setup.lhs configure, it tells me dependencies are not satified
06:48:03 <gio1234> is there wat to check authomaticaly domain of users is available here?
06:48:06 <Geheimdienst> shouldn't Setup.lhs know about all the installed cabal pkgs?
06:48:35 <Saizan_> Geheimdienst: use --user
06:49:19 <Saizan_> you can also run "cabal install" from that directory
06:53:58 <Geheimdienst> yay it works! thanks a lot
06:54:41 <sshc>  \la
06:56:54 <lilac> Taejo: 268 [inc bugfix :)]
07:09:50 <jeffersonheard> I have a hard time believing that no messages have come through in the last 12 minutes
07:09:58 <jeffersonheard> is anyone still there or am I in a ghost room?
07:10:16 <Geheimdienst> fwiw, i'm still here :-)
07:10:18 <gwern> jeffersonheard!
07:10:21 <jeffersonheard> got it
07:10:23 <jeffersonheard> cool
07:10:26 <jeffersonheard> really just quiet
07:10:27 <gwern> OOHHH I  AM YOUR FATHER
07:10:29 <gwern> AVENGE ME
07:10:42 <jeffersonheard> By Grapthar's Hammer
07:11:07 <jeffersonheard> does any one know how to get the CFile version of stdin/stdout?
07:11:29 <jeffersonheard> I need to pass it to an FFI function, but I for obv. reasons can't use a handle
07:11:51 <jeffersonheard> or rather, because I have to pass stdin to an FFI fucntion, I can't use a handle
07:13:40 <mun> for the datatype at http://haskell.pastebin.com/m583c3b1e, what are forall, lid1, sublogics1, etc. are they variables?
07:14:57 <jmcarthur_work> mun, forall is not, but everything before the . besides that are type variables
07:15:04 <jmcarthur_work> and that is one of the scariest types i've ever seen
07:15:15 <dmwit> jeffersonheard: Why can't you use a handle?
07:15:43 <jeffersonheard> dmwit: because the C function expects a FILE*
07:15:54 <dmwit> hum
07:16:35 <mun> jmcarthur_work, but lid1 appears before the . and after, so is it a type variable?
07:16:56 <jeffersonheard> Foreign.C has a CFile type, but I can't find a version of stdin/stdout that come as FILE*s in the standard library
07:17:15 <jmcarthur_work> mun, before the . is just bindings, after is actually using it
07:17:20 <Geheimdienst> jeffersonheard: don't really know, but in c you could do fdopen(filedescriptor) to get the FILE*
07:17:21 <maltem> CFile looks like a placeholder to me
07:17:29 <maltem> data CFile = CFile
07:17:32 <mun> jmcarthur_work, ok thanks
07:17:38 <jeffersonheard> maltem, I know
07:17:39 <jeffersonheard> it is
07:18:08 <jeffersonheard> fdopen, eh...  that should work, since Posix.IO has an Fd type
07:18:21 <maltem> call me dumb, but what's its use then? No data, no instances?
07:19:02 <dmwit> maltem: Only the compiler can make values of that type.
07:19:02 <jeffersonheard> maltem: because if you import the functions fopen or fclose, or functions that use FILE*, then you don't have to make up your own file type
07:19:04 <dmwit> That's the use.
07:19:51 <maltem> hm ok
07:21:38 <jeffersonheard> dmwit: stdin/stdout exist as extern values in standard C.  Is there a way to FFI import just a value, or do I have to import a function?
07:22:04 <dmwit> dunno
07:23:02 <jeffersonheard> well, I guess we'll find out.  Only reason that I don't want to use fdopen is that I don't know whether or not it exists on Windows
07:23:09 <Geheimdienst> afaik they're just integers: stdin is 0, stdout is 1, stderr is 2
07:23:14 <dmwit> I should think it's possible to import plain values (as IO types, of course, unless you use unsafePerformIO).
07:23:29 <dmwit> Did you know that Windows is POSIX?
07:23:33 <dmwit> Starting with NT 4.
07:24:02 <arw> not entirely. they don't implement all of the spec, just parts.
07:24:09 <dmwit> oh
07:24:13 <dmwit> I've been misinformed, then.
07:24:45 <arw> and later versions don't have the unix subsystem except if you pay for the more expensive 'editions' or whatever they are called.
07:24:50 <jeffersonheard> dmwit: I believe most POSIX functions on Windows use a wrapper, and depending on how they wrap things, I've heard it's an "emulation layer"
07:25:15 <dmwit> Nothing wrong with that.
07:25:22 <dmwit> Microsoft really knows how to do emulation layers.
07:25:25 <Geheimdienst> what about this: http://en.wikipedia.org/wiki/Microsoft_POSIX_subsystem
07:25:26 <dmwit> They do a *lot* of them.
07:25:42 <Geheimdienst> or you could always use cygwin i guess
07:25:54 <arw> but there are some interesting relics of their posix support. for example every syscall accepts '/' as well as '\' as path separator :)
07:25:55 <eevar2> they probably added a few custom improvements to the standard as well? ;)
07:26:36 <jeffersonheard> yeah, cygwin or msys might well do just fine
07:27:47 <arw> eevar2: no, but they don't support later standards like Xopen, so modern unix programs might be hard to port.
07:28:41 <arw> eevar2: "does POSIX" was only a checkmark they had to do for government contracts in the us.
07:28:43 <dmwit> "I first heard about this from one of the developers of the hit game SimCity, who told me that there was a critical bug in his application: it used memory right after freeing it, a major no-no that happened to work OK on DOS but would not work under Windows where memory that is freed is likely to be snatched up by another running application right away. The testers on the Windows team were going through various popular applications, testi
07:28:56 <dmwit> That's the kind of emulation layer Microsoft people are used to writing... =P
07:29:48 <doofer> using GeneralizedNewtypeDeriving, any idea why I still can't use get/put using this monad: newtype Env s a = Env (StateT (Objects s) (ST s) a) deriving (Monad, MonadState (Objects s))
07:29:56 <Geheimdienst> you forgot the tail of the story where they run the memory allocator in the special simcity mode ;)
07:30:28 <dmwit> I must have gotten cut off.
07:30:35 <dmwit> Where did my message end?
07:31:03 <fasta> Why doesn't this work with ScopedTypeVariables and Existentials enabled? data Foo = forall m. (Monad m)=>Foo (m Int);t:: (Monad m)=>Foo -> m Int;t (Foo f) = f :: m Int
07:31:11 <jmcarthur_work> dmwit, "The testers on the Windows team were going through various popular applications, test"
07:31:30 <dmwit> ...testing them to make sure they worked OK, but SimCity  kept crashing. They reported this to the Windows developers, who disassembled  SimCity, stepped through it in a debugger, found the bug, and added special code  that checked if SimCity was running, and if it did, ran the memory allocator in a  special mode in which you could still use memory after freeing it."
07:32:05 <dmwit> And now I think I've hijacked the channel quite enough for one day. =P
07:33:58 <jeffersonheard> checked... if... simcity was running??? NOOOOOOOOOOOOOOOO
07:34:41 <ray> microsoft: bitched at if they make everything compatible, bitched at if they don't
07:35:31 <maltem> fasta, isn't m bound existentially? That is, Foo means SomeMonadInt
07:35:47 <fasta> maltem: yes, it is.
07:35:58 <maltem> Then, why should it work?
07:36:37 <fasta> maltem: the intention is that some monad should be equal to whatever it is used in combination with.
07:37:10 <dmwit> doofer: Hm, really?
07:37:25 <maltem> fasta, but your definition of t says that given a Foo, you can get an (m int), where m is any monad you want
07:38:02 <doofer> dmwit: I'm wrong actually, it's the ST operations I can't use. Can I derive something for that too?
07:38:16 <dmwit> doofer: Yeah, that makes more sense.
07:38:31 <dmwit> doofer: See, you almost certainly don't want the same "s" in Objects and ST.
07:38:34 <fasta> maltem: ok, so how do I express what I want?
07:38:55 <maltem> I'm not sure what you want
07:39:27 <doofer> dmwit: I'd like the state to hold some STRefs, is this something I shouldn't do?
07:39:30 <maltem> The idea „this is (m int), where m is some monad“ is expressed by Foo
07:40:26 <fasta> maltem: so, essentially this code in uncallable?
07:40:43 <fasta> maltem: I know the solution, I think.
07:40:43 <maltem> you can then have phi :: Foo -> Foo, phi (Foo f) = Foo ((*2) <$> f)
07:41:16 <dmwit> doofer: Hm.  The problem is that the StateT restricts the STRefs to always use the same "s" type, but all the ST operations want to return things with an existentially-quantified "s"...
07:41:16 <fasta> maltem: right, but there is no way to extract a result.
07:42:04 <maltem> right - the only functions you can use are those that work with any monad
07:42:27 <fasta> maltem: and there is no unmonad operation in general, so it is stuck.
07:42:31 <fasta> maltem: thanks
07:42:36 <dmwit> doofer: So for example, my intuition is that trying to do something like store a newly allocated STRef in your Objects structure won't get past the type-checker.
07:42:40 <dmwit> (No matter what you do.)
07:42:58 <maltem> fasta, yes, and that's why the type is not terribly useful ;)
07:43:42 <fasta> maltem: I kind of wanted to avoid data Foo m
07:43:53 <lilac> where is 'instance Functor ((,) a)' defined?
07:43:55 <maltem> (unless you like unsafe coercing - but I mean, this is not Java)
07:44:14 <fasta> maltem: how would it work with unsafeCoerce?
07:44:32 <fasta> :t unsafeCoerece
07:44:33 <lambdabot> Not in scope: `unsafeCoerece'
07:44:37 <fasta> :t unsafeCoerce
07:44:38 <lambdabot> Not in scope: `unsafeCoerce'
07:45:10 <maltem> I'm not even sure it would work. I just mean, the Java way would be to dynamically check if the given value is maybe of this or that type, and then do an appropriate cast
07:45:24 <fasta> maltem: isinstance of, yes.
07:45:58 <doofer> dmwit: Ah, thanks for the explanation! Do you know if there is a way around that? (like using existential quantification for my Objects?)
07:46:06 <maltem> fasta, and unsafeCoerce is a cast operation, I don't know its exact semantics (if it has any ;)
07:46:28 <lilac> Control.Monad.Instances seems to provide it, but i'd guess it's importing it from somewhere else?
07:46:58 <dmwit> doofer: I do not know.  Anybody else here know?
07:57:08 <doofer> dmwit: okay, thanks for taking the time!
07:58:13 <Saizan_> the nearest equivalent to instanceOf is Data.Typeable, actually
08:00:38 <endojelly> zippers are awesome
08:00:42 <endojelly> exactly what I need.
08:01:23 <ray> zippers are awesome
08:02:36 <jiyunatori> hi there. I'm getting some Latin1 encoded strings from a MySQL db - how can I convert this to regular haskell strings ?
08:03:31 <quicksilver> jiyunatori: latin1 should be pretty much compatible with haskell strings anyway
08:03:49 <quicksilver> since latin1 matches unicode code points on the first 255 entries or it does very very nearly
08:04:18 <jiyunatori> well, in the end I got broken accents everywhere.
08:04:36 <roconnor> jiyunatori: how are you doing the conversion?
08:05:18 <quicksilver> you are probably having output problems, not input
08:05:27 <quicksilver> you're probably expecting it to output UTF8, which it doesn't
08:05:32 <jiyunatori> right now I have some HDBC code attacking the database, and I extract the result using the fromSql function.
08:05:34 <roconnor> quicksilver: good call
08:07:20 <Saizan_> HDBC might be assuming utf8, too
08:08:20 <jiyunatori> I guess if there's a conversion somewhere, it must be on the "fromSql" call ... actually, I said that the content of the db is in Latin1 because I putStr'ed "Sources SR3 et ant\233rieur" in a file
08:08:45 <jiyunatori> then the file command gives me : bla: ISO-8859 text
08:09:38 <Saizan_> Beginning with HDBC v2.0, interactions with a database are presumed to occur in UTF-8.
08:10:03 <Saizan_> http://hackage.haskell.org/packages/archive/HDBC/2.1.0/doc/html/Database-HDBC.html <- from UNICODE AND BYTESTRINGS
08:10:43 <jiyunatori> hmmmmmmm actually, it looks like \232 corresponds to the right character. So I guess the input is right. I'm probably messing with the output
08:11:36 <jiyunatori> like, when I write my file, I shouldn't use hPutStr, but something else right ?
08:13:00 <Saizan_> System.IO.hPutStr truncates the Char to the 8 least significant bits
08:13:06 <jeffersonheard> hey, it worked :-D
08:13:27 <jeffersonheard> we now have tools for reading and manipulating HDR photos with Haskell
08:13:30 <jeffersonheard> mwa ha ha
08:14:04 <ike_> jiyunatori: how about using Data.ByteString.Lazy.putStr instead of System.IO.hPutStr?
08:14:17 <roconnor> :)
08:14:41 <jiyunatori> ike_: ok let's try this.
08:14:42 <endojelly> so is there a "deriving Zipper" or something?
08:15:40 <quicksilver> nope
08:15:47 <quicksilver> read oleg's paper and weep.
08:16:00 <ray> tears of joy
08:16:09 <quicksilver> jiyunatori: use utf8-string
08:16:15 <quicksilver> jiyunatori: (if utf8 output is indeed what you want)
08:16:40 <ike_> ah, right
08:20:02 <hackagebot> HDRUtils 1.0.0 - Utilities for reading, manipulating, and writing HDR images (JeffersonHeard)
08:21:20 <roconnor> jeffersonheard: http://vis.renci.org/jeff/pfs -- page not found
08:23:16 <jiyunatori> it worked !! :D
08:23:36 <quicksilver> ;)
08:24:04 <ike_> jiyunatori: congrats
08:24:11 * jiyunatori carving System.IO.UTF8 on his forehead
08:24:30 <roconnor> ya, the old system string IO needs to be destroyed
08:24:43 <ezyang> Any happstack developers around?
08:25:01 <Saizan_> ezyang: you should have more luck on #happs
08:25:20 <ezyang> aha! Thanks
08:25:29 <ike_> jiyunatori: I have heard the next GHC release will support Unicode IO
08:26:20 <jiyunatori> neat ! I'm amazed by the amount of work going on with GHC
08:28:16 <jeffersonheard> roconnor, haven't created it yet
08:28:17 <jeffersonheard> I will
08:28:22 <roconnor> :)
08:28:30 <jiyunatori> ok another similar question : now I want to create a folder with unicode characters in its name.
08:28:33 <jeffersonheard> Also forgot to include haddoc docstrings
08:28:36 <jeffersonheard> fixing that :P
08:30:13 <jiyunatori> obviously, createDirectoryIfMissing is having the same limitations as System.IO when it comes to encoding
08:31:37 <EvilTerran> jiyunatori, unless there's something suitable on hackage, i think the easiest way to do that may involve finding a suitable C library function and FFIing it
08:31:51 <jiyunatori> ouch
08:32:05 <hackagebot> HDRUtils 1.0.1 - Utilities for reading, manipulating, and writing HDR images (JeffersonHeard)
08:32:18 <jeffersonheard> There, haddock strings added
08:32:25 <EvilTerran> jiyunatori, don't worry, that says more about how easy the haskell FFI is for small things like that than anything else
08:34:35 <ezyang> @seen wchogg
08:34:35 <lambdabot> Last time I saw wchogg was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
08:34:35 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
08:34:35 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 7m 17d 10h 2m 32s ago,
08:34:35 <lambdabot> and .
08:35:21 <adh0c> a propo the unicode problem
08:35:29 <adh0c> maybe you'll be able to find something here
08:35:30 <adh0c> http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
08:36:33 <EvilTerran> jiyunatori, i imagine there are C functions that take a unicode path and return a file handle, and i'm pretty sure you can convert C file handles into haskell Handles pretty easily, so it'd just be a case of importing the C function and wrapping it to work with haskell types
08:36:35 <jiyunatori> adh0c: yes, I saw that earlier, but the date is nov 2007, and it seems a few things have evolved since then ...
08:37:21 <skorpan> is there any way to derive classes for GADTs?
08:37:27 <jiyunatori> EvilTerran: hm. It could even less : a function that takes a unicode path and create a directory to this path if it is missing, that's all I need.
08:37:48 <EvilTerran> jiyunatori, ah, just making a folder? that should be even more straightforward, yeah
08:37:53 <EvilTerran> but first you'd need to find the function
08:37:57 <quicksilver> jiyunatori: what do you think a unicode path is?
08:38:14 <quicksilver> jiyunatori: what encoding do you think your OS uses for its paths?
08:38:20 <quicksilver> (that's the key question here)
08:38:27 <quicksilver> paths are just sequences of bytes
08:38:29 <jiyunatori> my os is using unicode for folders
08:38:34 <quicksilver> no it's not
08:38:37 <quicksilver> unicode isn't an encoding
08:38:42 <quicksilver> your OS is using an *encoding* for folders.
08:38:49 <quicksilver> unless you know which one, you can't get this right ;)
08:38:49 <jiyunatori> oh yeah, it is using UTF-8, sorry
08:39:05 <quicksilver> then you can use utf8-string again to encode the path
08:39:06 <EvilTerran> quicksilver, i was interpreting the question to mean functions which take suitably-encoded ByteStrings as paths
08:39:10 <quicksilver> it's a bit ugly though ;)
08:39:25 <jiyunatori> quicksilver: ok. let's try this !
08:39:37 <quicksilver> EvilTerran: the System.IO functions do take "suitably encoded strings of bytes" as paths
08:39:41 <adh0c> I just skimmed over the IRC window and thought he had problems with unicode support in haskell
08:39:42 <EvilTerran> (hence my suggestion of going for something which takes a char*)
08:39:53 <quicksilver> EvilTerran: it's just they lie about what they do, and pretend they take "String"
08:40:09 <quicksilver> EvilTerran: ...actually they take a [Word8] represented as a string
08:40:11 <EvilTerran> ah, i see. yeah, i concur with quicksilver, then. :)
08:40:17 <quicksilver> which is really a suitably encoded string of bytes
08:40:20 <adh0c> I wouldn't really call it lying
08:40:21 <quicksilver> (not a ByteString though)
08:40:33 <mmorrow> , (text . utf8enc) "\x2200"
08:40:34 <ray> yeah, Char is supposed to be a single unicode code point right? not a Word8
08:40:35 <lunabot>  ∀
08:40:36 <adh0c> not much more than types are
08:41:07 <mmorrow> , "∀"
08:41:08 <lunabot>  "\8704"
08:41:13 <mmorrow> , utf8enc "∀"
08:41:15 <lunabot>  "\226\136\128"
08:41:26 <mmorrow> , utf8enc "a"
08:41:27 <lunabot>  "a"
08:41:44 <ike_> or, using 'encoding' package on HackageDB; it has another IO functions with encoding
08:42:02 <ike_> (I've never tried to use the 'encoding' package, though)
08:42:04 <jiyunatori> quicksilver: it worked !! again !!! :D
08:42:07 <quicksilver> ;)
08:42:09 <Berengal> > text (chr (ord '') : [])
08:42:11 <lambdabot>   �
08:42:52 <mmorrow> , utf8enc "æ"
08:42:53 <lunabot>  "\195\166"
08:43:03 <mmorrow> , "æ"
08:43:04 <lunabot>  "\230"
08:43:13 <Berengal> > ""
08:43:14 <lambdabot>   "\65533"
08:43:19 <mmorrow> :o
08:43:21 <EvilTerran> uhh
08:43:24 <Berengal> :(
08:43:35 <mmorrow> , ord 'æ'
08:43:36 <lunabot>  230
08:43:56 <EvilTerran> , {-# Berengal's #-} "æ" == {-# mmorrow's #-} "æ"
08:43:57 <lunabot>  True
08:44:00 <EvilTerran> wait what
08:44:05 <adh0c> what
08:44:12 <mmorrow> who's wrong here?
08:44:16 * mmorrow checks in ghci
08:44:18 <Berengal> \b is
08:44:21 <EvilTerran> > ord 'æ'
08:44:23 <lambdabot>   230
08:44:26 <Berengal>  is 230
08:44:26 <mmorrow> ah ok
08:44:38 <EvilTerran> ^ but there lambdabot agrees with that...
08:44:39 <quicksilver> that looks like two characters on my terminal
08:44:41 <quicksilver> how does that work?
08:44:51 <adh0c> it looks like an A and a |
08:44:56 <adh0c> at least for me
08:44:59 * mmorrow gives lunabot a cookie
08:45:00 <quicksilver> it looks like "ae" on my terminal
08:45:08 <ray> that's because it's an ae ligature
08:45:08 <quicksilver> taking up two columns in this fixed width font
08:45:10 <EvilTerran> it's the ae ligature
08:45:13 <Berengal> > ord (chr (ord ''))
08:45:14 <lambdabot>   65533
08:45:19 <Berengal> > ord ''
08:45:19 <ray> quicksilver: your terminal is probably decomposing it then
08:45:20 <quicksilver> that one is one character ^^
08:45:21 <lambdabot>   65533
08:45:24 <narens> anyone familiar with GpH... I have a quick question
08:45:37 <ray> unicode has decompositions for some characters
08:45:38 <etpace_> http://www.haskell.org/all_about_monads/html/statemonad.html Can anyone help explain the State monad (again?), in the initial getOne call, g is just (\s -> (s,s)) and what use is put? if I read it right, thats the same as put g' >> return x, in which case the result of put s is just throwna away
08:45:49 <mmorrow> whoa, ok so we're using two different unicode chars here
08:45:57 <mmorrow> that happen to look the same
08:45:58 <Berengal> It would seem so...
08:46:01 <mmorrow> (to me at least)
08:46:01 <etpace_> so how do the other functions access the new state?
08:46:12 <adh0c> through the monad
08:46:13 <Berengal> They look the same to me as well, but...
08:46:30 <Berengal> > text (chr (ord '') : [])
08:46:31 <lambdabot>   �
08:46:39 <Berengal> Those don't look the same
08:46:52 <ezyang> etpace_: put
08:47:07 <mmorrow> , "�"
08:47:08 <lunabot>  "\65533"
08:47:15 <ezyang> etpace_: We temporarily lose the data from the monad, but put "puts" it back when we're done, inside of getOne
08:47:23 <mmorrow> that looks like a diamond with a question mark in my font
08:47:27 <Berengal> , text (chr (ord '') : [] )
08:47:28 <lunabot>  luna: parse error (possibly incorrect indentation)
08:47:44 <etpace_> but the new state is thrown away with >>?
08:47:53 <EvilTerran> etpace_, no!!!
08:47:58 <mmorrow> Berengal: you have to utf8enc it first for text
08:48:13 <EvilTerran> etpace_, the result of the left-hand side of >> is thrown away; the side-effects most definitely are not
08:48:14 <ezyang> etpace_: Where did that come from?
08:48:28 <Berengal> > text . utf8enc $ chr (ord '') : []
08:48:30 <lambdabot>   Not in scope: `utf8enc'
08:48:32 <adh0c> the state monad is there to emulate stateful behavior in a stateless language
08:48:37 <Berengal> , text . utf8enc $ chr (ord '') : []
08:48:38 <lunabot>  luna: parse error (possibly incorrect indentation)
08:48:38 <mmorrow> Berengal: (in lunabot)
08:48:59 <EvilTerran> (where i use "result" to mean "bit you could fake with 'return'" and "side-effect" to mean "the rest of its behaviour", informally)
08:49:03 <ezyang> It might be useful to desugar the syntax, at this point
08:49:06 <mmorrow> , chr (ord 'æ')
08:49:07 <lunabot>  '\230'
08:49:13 <mmorrow> , 'æ'
08:49:14 <lunabot>  '\230'
08:49:36 <mmorrow> , utf8enc "æ"
08:49:37 <lunabot>  "\195\166"
08:49:51 <mmorrow> , text "\195\166"
08:49:52 <lunabot>  æ
08:50:28 <mmorrow> i don't know wheretf \65533 is coming into the picture here
08:51:02 <ezyang> mmorrow: it's the standard error codepoint
08:51:12 <mmorrow> ah, i see.
08:51:34 <ray> mmorrow needs unicode lessons
08:52:03 <ike_> me too
08:52:07 <mmorrow> i think lambdabot is mangling something
08:52:15 <ezyang> http://rishida.net/scripts/uniview/uniview.php?codepoints=FFFD
08:52:15 <Berengal> could be the input...
08:52:16 <mmorrow> via text
08:52:21 <ike_> > take 1 "あいうえお"
08:52:23 <lambdabot>   "\12354"
08:52:34 <mmorrow> > text "あいうえお"
08:52:35 <lambdabot>   あいうえお
08:52:42 <Berengal> ghci agrees with me, although I think it got something wrong yesterday
08:52:57 <mmorrow> see, lambdabot is doing the utf8 encoding automatically
08:53:04 <mmorrow> lunabot doesn't
08:53:09 <mmorrow> , text "あいうえお"
08:53:10 <lunabot>  BDFHJ
08:53:16 <ray> > text $ take 1 "いろは"
08:53:18 <mmorrow> , text (utf8enc "あいうえお")
08:53:18 <lambdabot>   い
08:53:19 <etpace_> I just don't see where the new state is passed on, or rather how the sideeffects work
08:53:19 <lunabot>  あいうえお
08:53:33 <ray> the input is coming in utf8 though
08:53:34 <ezyang> etpace_: Thus my suggestion to desugar ;-)
08:53:40 <mmorrow> ray: right
08:53:45 <ike_> aha, using 'text' function!
08:54:10 <ray> "show" isn't meant for prettyprinting stuff
08:54:29 <mmorrow> lunabot decodes the input from utf8, then does nothing with the output (i.e. assumes you've taken care of that)
08:54:46 <ray> i see
08:54:46 <mmorrow> lambdabot appears to be utf8encoding the output as well
08:54:49 <Berengal> etpace_, the state is passed along by >>=, and can be read and written using the get and put primitives
08:55:02 <Berengal> etpace_, these primitives are magic, like all primitives.
08:55:12 <ray> , text $ (:[]) 'あ'
08:55:14 <lunabot>  B
08:55:14 <adh0c> not really
08:55:16 * ezyang thwap Berengal 
08:55:19 <Berengal> etpace_, and by magic I mean that they know the internals of the monad
08:55:22 <ezyang> They're not /that/ magical
08:55:26 <ezyang> ah, ok :-)
08:55:29 <medfly> :)
08:55:34 <adh0c> you're hereby forgiven
08:56:06 <ray> and by magic, you mean that they're boring ordinary functions
08:56:07 <Berengal> I like to consider primitives magic... encourages encapsulation
08:56:25 <ray> i'd like to encourage you to live in a capsule, see how you like it
08:56:53 <adh0c> I like to consider computing magic... makes me look much more elite
08:57:01 <adh0c> though it still has to get me laid
08:57:11 <adh0c> maybe magic isn't the best way to go
08:57:28 <ezyang> You're allowed to forget the details only once you know them.
08:57:43 <ray> a magician named GOB
08:57:49 <adh0c> Isn't it the same as not knowing them at all?
08:57:55 <ToRA> if I post a link to a bbc article that features haskell in a reporters video, is that old news?
08:58:11 <adh0c> post it either way
08:58:13 <ToRA> http://news.bbc.co.uk/1/hi/technology/8221235.stm
08:58:15 <Baconizer> ToRA: I haven't seen it, just post it.
08:58:16 <adh0c> like you care what we think
08:58:24 <ToRA> about 2 mins in
08:58:50 <Berengal> ezyang, I seldom bother to learn the internals of all the monads I've encountered. Most of them are simply variations of RWS anyway, at least in semantics
08:59:17 <adh0c> that there doesn't look like haskell on the screen
08:59:21 <adh0c> in the beginning
08:59:23 <jeffersonheard> page added, roconnor
08:59:52 <jeffersonheard> uhm...  why is lunabot repeating the japanese vowels?
08:59:59 <ray> omg haskell
09:01:27 <jpcooper> is it normal when accepting a connection from a socket in a different thread, which is created with forkIO, than that from which it was created, with listenOn, for there to be a bad file descriptor error?
09:01:43 <quicksilver> no
09:02:00 <jpcooper> when should there be one?
09:02:01 <quicksilver> but calling accept twice from two different threads might be an error?
09:02:06 <quicksilver> (I'm not sure, I've never tried that)
09:02:13 <quicksilver> you normally accept before you fork ;)
09:02:26 <jpcooper> all of the accepting is done in the forked thread
09:02:45 <Berengal> I've done listenOn -> forkIO -> accept before
09:02:46 <etpace_> I think its the definition of >>= for State that is throwing me, State x >>= f takes a transition function x and creates a new transition function that when given a state s, preforms x s, returning a new value a and state s', and from there the runState (f a) s' lost me
09:02:56 <jpcooper> hrmm
09:03:07 <jpcooper> I wonder what the dickens the problem is, then
09:04:42 <jiyunatori> thanks everyone for your help :) bye
09:04:46 <Saizan_> etpace_: do you know that "runState (State f) = f"?
09:05:10 <etpace_> hmm, sure
09:05:26 <etpace_> and I guess f has to return a State
09:05:30 <bos> dons: what's the magic goo that makes hackage see what a distro's packages are?
09:05:33 <Saizan_> yeah
09:05:36 <bos> @seen dons
09:05:36 <lambdabot> dons is in #haskell, #yi, #concatenative, #haskell-in-depth, #ghc, #xmonad, #darcs and #arch-haskell. I last heard dons speak 13h 48m ago.
09:05:43 <Saizan_> that's what the type of >>= says
09:07:08 <etpace_> State x >>= f creates a new state that first executes the LHS, then creates a new intermiddent state, which is applied to the resultung state of the first, but with >> f a = the RHS, so thats how the new state gets passed?
09:08:24 <Saizan_> can you rephrase?
09:08:32 <skorpan> is there any tutorial on quickcheck 2+?
09:09:08 <adh0c> etpace_, the state monad masks the emulated stateful behavior by passing the "state" behind the scenes
09:09:25 <etpace_> i'm trying to understand how it passes it adh0c
09:10:07 <quicksilver> by the definition of >>=
09:10:19 <skorpan> etpace_: look at the definition of (>>=)
09:10:22 <mmorrow> mercury^: did you ever get that fasta code sorted out?
09:10:35 <quicksilver> the definition of >>= joins together two actions by taking the output state of the left one and passing it to the input state of the right one
09:10:47 <quicksilver> it's very very much like using (.) on two functions (s -> s)
09:10:54 <etpace_> Hmm, basically for >> the intermittent state doesnt exist, so you have State x >> State y, builds a new State (\s -> y (snd (runStatae x s))?
09:11:01 <quicksilver> (it's just there is an extra return value a or b hanging around too)
09:11:10 <etpace_> runState*
09:11:21 <quicksilver> I wouldn't say "odesn't exist" but what you wrote looks right, yes.
09:12:07 <Berengal> etpace_, does it help that 'x >> y == x >>= const y'?
09:12:18 <etpace_> yeah, thats what I'm using now
09:12:38 <Berengal> This is something that's common to all monads
09:12:42 <Berengal> That follow the laws, that is
09:12:45 <Saizan_> it's the result of x that's ignored, not the returned state
09:13:20 <quicksilver> skorpan: I don't think there's a tutorial but I think there might be a paper?
09:13:30 <etpace_> yeah, for (a,s) as a result of running the state transition x, a is ignored but the state s is still passed?
09:13:36 <skorpan> quicksilver: couldn't find one on claessens's homepage
09:13:37 <adh0c>     (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s'
09:13:45 <skorpan> quicksilver: well, i found old stuff from 2004 and earlier
09:13:46 <Saizan_> etpace_: yes
09:14:18 <mmorrow> > runState (replicateM 10 (State next)) (mkStdGen 8277433)
09:14:19 <lambdabot>   ([500734682,348333582,1521634434,1036695047,1415671469,61946240,361432318,1...
09:14:26 <mmorrow> > runState (replicateM 3 (State next)) (mkStdGen 8277433)
09:14:26 <Berengal> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
09:14:27 <lambdabot> f a b c =
09:14:27 <lambdabot>     case a c of
09:14:27 <lambdabot>     (d, e) -> b d e
09:14:27 <lambdabot>   ([500734682,348333582,1521634434],1477561135 2103410263)
09:15:14 <mmorrow> > runState (replicateM 3 (State (fmap drop 1 . break (=='.'))) "127.0.0.1"
09:15:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:15:20 <mmorrow> > runState (replicateM 3 (State (fmap drop 1 . break (=='.')))) "127.0.0.1"
09:15:21 <lambdabot>   Couldn't match expected type `(a, [GHC.Types.Char])'
09:15:31 <mmorrow> > runState (replicateM 3 (State (fmap (drop 1) . break (=='.')))) "127.0.0.1"
09:15:32 <lambdabot>   (["127","0","0"],"1")
09:16:33 <Berengal> state is pretty clever that way...
09:17:40 <quicksilver> etpace_: one approach is might be helpful is to say "the State monad is just a set of combinators for building up functions (s -> (a,s)). It overloads the familiar operators >>= and >> and friends into ones which help us build up complex functions from simple ones"
09:17:48 <quicksilver> I found that helpful once, anyway.
09:19:09 <etpace_> I (think) i understood it from a high level, I was just mystified how >> passed on the state
09:19:47 <mux> a good way to get comfortable with the State monad is to reimplement it yourself :)
09:20:54 <etpace_> I think my attempt at using monads after this will be using the StateT transformer a bit, hopefully that'll help with the grokking
09:21:01 <lilac> etpace_: the type State s a is isomorphic to s -> (a, s).
09:21:29 <lilac> etpace_: therefore, a function of type "a -> State s b" is isomorphic to a -> s -> (b, s) which is (almost) isomorphic to (a,s) -> (b,s)
09:21:53 <lilac> so Kleisli arrows in the State s monad (that is, functions a -> m b) are really just functions carrying an extra value of type s.
09:21:57 <quicksilver> etpace_: one implementation of >> would be "a >> b = \s -> let (s',v) = a s in b s'"
09:22:11 <ezyang> ^^^ read that carefully
09:22:17 <quicksilver> etpace_: (here I have deliberately got rid of the State wrapper)
09:22:40 <adh0c> etpace_, take a look here
09:22:41 <adh0c> http://en.wikibooks.org/wiki/Haskell/Advanced_monads
09:22:54 <dons> bos: magic goo for hackage and distros. create a file like this: http://www.galois.com/~dons/cabalArchMap.txt
09:22:56 <mmorrow> maybe better (as in more explicit) would be
09:23:01 <dons> for your distor, (name, vers, url)
09:23:10 <mmorrow> gah, n/m
09:23:29 <dons> bos: then link to it from Ross' ticket: http://hackage.haskell.org/trac/hackage/ticket/570
09:23:42 <dons> kolmodin: ^ gentoo, too
09:23:43 <bos> dons: ok, cool.
09:23:53 <bos> we just finished off platform support for fedora.
09:23:57 <dons> sweet
09:24:04 <mmorrow> fedora++
09:24:11 <bos> nice to have that in the bag before ICFP.
09:24:53 <dons> kosmikus: ^^ you could do the same for Nix
09:25:07 <dons> we do need one for Ubuntu too, somehow.
09:25:58 <etpace_> thanks quicksilver, makes fine sense now
09:26:12 <ezyang> whoo
09:26:48 <ezyang> ok, now implement getput, which puts a value as the state and returns the previous value
09:28:04 <dons> bos: when you heading out to ICFP?
09:28:24 <bos> tuesday.
09:28:33 <dons> ok. i'll be there on monday.
09:28:40 <bos> not going for ICFP proper, which is a shame/relief.
09:28:46 <dons> fair 'nuff
09:31:32 <nlogax> dons: is there a date set for the next haskell platform release? any idea if it will include mac os 10.6 support? :)
09:31:47 <bos> given that ghc doesn't work on 10.6, probably not yet.
09:32:05 <nlogax> hmm, i thought i saw it being fixed on the bug tracker
09:32:17 <bos> not the same thing as currently-works :_)
09:32:27 <nlogax> oh :)
09:32:57 <ike_> [Ann] We. Japanese Haskell community will plan a 4-days online meeting for programming Haskell from Sep 19 until Sep 23. http://atnd.org/events/1048
09:33:27 <adh0c> so, they haven't started planning yet?
09:33:31 <bos> nice!
09:33:53 <skorpan`> is it possible to derive Show for GADTs?
09:34:12 <ksf> why can't I derive Bits if I have Enum?
09:34:36 <Saizan_> skorpan`: with HEAD you can for some gadts
09:34:51 <bos> ksf: you have to write an instance of Bits by hand
09:35:17 <ksf> ...I rather use fromEnum in this case.
09:35:17 <bos> unless you just have a newtype wrapper around an existing instance
09:35:43 <ksf> ...but I'm worried about flag sets that get longer than maxBound :: Int
09:35:56 <skorpan`> what's the difficulty in implementing deriving Show for GADTs?  i can't quite see the problem.  is it the fact that it's an extension somehow?
09:37:25 <Saizan_> skorpan`: it's not always possible to write a sensible instance, like if you're using existentials
09:37:52 <bos> it would be sweet if we could teach cabal-install how to install a distro's packages if they exist.
09:38:07 * bos wants hooks!
09:38:31 <Saizan_> i'd rather have a cabal-install lib :)
09:40:27 <dons> ike_: awesome
09:40:29 <ksf> grrr
09:40:44 <ike_> dons: thanks
09:40:47 <ksf> c2hs does't do proper enumFromTo functions
09:40:58 <dons> ike_: you should add it to http://haskell.org/haskellwiki/Template:Main/Events
09:41:31 <ike_> thank dons for your advice. I have my account.
09:41:53 <quicksilver> skorpan`: I don't think there is a difficulty for the vanilla (no contexts/quantifiers) GADT case
09:42:08 <quicksilver> skorpan`: it's just that that bit of code (the deriving bit) was very old and didn't know about the new types
09:42:18 <quicksilver> ISTR it has been fixed in GHC HEAD but I might be wrong.
09:42:29 <bos> http://hackage.haskell.org/trac/hackage/ticket/578
09:42:49 <quicksilver> skorpan`: http://hackage.haskell.org/trac/ghc/ticket/3012
09:43:29 * ezyang realizes MazesOfMonad is basically nethack... 
09:44:01 <quicksilver> firefox++ # I would never be able to find GHC trac tickets without the URL bar autocompelte
09:46:02 <ray> i can't stand nethack et al anymore
09:46:08 <ray> since i discovered fushigi no dungeon
09:49:18 <ezyang> I've tried my very best not to get sucked into it
09:49:43 <HugoDaniel> hi
09:49:57 <ezyang> yo
09:51:08 <etpace_> ezyang as in getput s = \s' -> let (v,_) = (runState get) s' in (v, s)? I wasn't really sure what you meant by previous value
09:52:13 <ike_> done editing Haskell wiki (Template) for the event
09:52:48 <ezyang> previous value = what the state being passed around was previously
09:53:16 <ezyang> I'm fairly certain you can golf that to less characters.  Does it typecheck?
09:54:14 * ksf doesn't like any of the bitmask implementations around
09:54:25 <ksf> they're all overkill.
09:55:43 <etpace_> s -> State s s seems legit
09:57:21 <ezyang> Yeah, looks like it typechecks
09:57:29 <hackagebot> HDRUtils 1.0.2 - Utilities for reading, manipulating, and writing HDR images (JeffersonHeard)
09:57:46 <etpace_> getput s = get >>= (\s' -> State $ (const (s', s))) for the original state?
09:58:33 <ezyang> don't use get/put in your reimplementation
09:59:33 <etpace_> :t getput s = State (\s'' -> (s'', s'')) >>= (\s' -> State $ (const (s', s)))
09:59:34 <lambdabot> parse error on input `='
09:59:52 <mmorrow> get = State (\s -> (s, s))
10:00:10 <mmorrow> put s = State (\_ -> ((), s))
10:00:15 <ezyang> Also, I don't think your previous impl is correct
10:00:50 <etpace_> :t (\s -> State (\s' -> (s', s')) >>= (\s' -> State $ (const (s', s))))
10:00:51 <lambdabot> forall s. s -> State s s
10:01:36 <mmorrow> etpace_: what is "getput" supposed to achieve?
10:01:52 <ezyang> mmorrow: runState (getput' 4) 3 == (3,4)
10:01:52 <sw17ch> does any one know how to narrow down which thread causes the "thread blocked indefinitely" message?
10:01:53 <sw17ch> :)
10:02:16 <copumpkin> sw17ch: you need to rewrite the program from scratch when that happens, sry :(
10:02:51 * sw17ch glares at copumpkin
10:02:56 <etpace_> Puts a new state, while returning the old as the value
10:03:45 <ezyang> Using the primitives, it would be: runState (get >>= \x -> put 4 >> return x) 3
10:04:01 <ezyang> The question is, what does it look like w/o the primitives ;-)
10:04:11 <sw17ch> copumpkin, was that more of a joke, or speaking from experience :)
10:04:29 <copumpkin> sw17ch: I was just being stupid "for a change" :)
10:04:32 <mmorrow> @type let getput a = State (\s -> (s, a)) in getput
10:04:33 <lambdabot> forall s. s -> State s s
10:04:36 <etpace_> ah, return woild have tidied it up
10:05:01 <sw17ch> lol
10:05:05 <ezyang> mmorrow: Yup, that was the impl I was fishing for
10:05:13 <ezyang> etpace_: don't look!
10:05:18 <mmorrow> oops, sry :)
10:05:55 <sw17ch> i'm trying to get my program to shutdown nicely
10:05:56 <araujo> hi there
10:06:01 <ezyang> hello
10:06:06 <etpace_> geez, forest before the trees
10:07:19 <adh0c> ok, now I got lost in the state monad thing myself
10:07:43 <adh0c> does put effectively store the new state in memory or does it overwrite the old one?
10:08:34 <ezyang> adh0c: It "overwrites" the old one
10:08:43 <sm> sw17ch: exitWith ExitSuccess ?
10:09:07 <sw17ch> sm: i need to throw the die status to several threads and have them cleanup their respective logs, sockets, and file descriptors
10:09:16 <adh0c> ezyang, so functions that operate on "state" hide the fact that they're accesing the value?
10:09:20 <sw17ch> "die status" is better said "we're finished now"
10:09:23 <sm> bracket may help here
10:09:27 <smarmy> i have to say that "getting the state monad" was one of those absolute eureka moments for me in understanding higher order functional programming
10:09:35 <adh0c> unless they demand that you provide it as one of the arguments
10:09:41 <ezyang> adh0c: It varies.  You can directly fiddle with the contents of State, or you can use the get/put primitives
10:10:11 <sw17ch> sm: i hadn't even considered bracket
10:10:14 <adh0c> what makes me wonder is how it remains pure if it overwrites a piece of memory
10:10:18 <sw17ch> sm: does that play nicely with exceptions?
10:10:29 <ezyang> adh0c: It doesn't actually overwrite memory
10:10:42 <sm> sure does
10:10:45 <ezyang> A new state/value tuple is created each time you >>=/>>
10:10:48 <mmorrow> adh0c: basically all State is is a way to hide explicit passing of the state as an argument (which is how haskell does "x++", ie you recurse with (x+1)) in >>/>>=
10:11:16 <adh0c> so does changing the state expand the memory usage of the program?
10:11:19 <sm> you can see some use of it at http://joyful.com/repos/rss2irc/rss2irc.hs
10:11:24 <adh0c> assuming values can't be updated
10:11:24 <smarmy> adh0c: a stateful computation is a chain of functions.  put is just a link in the chain that forgets the output state of the previous link and inserts a new one
10:11:43 <ezyang> adh0c: The previous states become inaccessible, and are presumably garbage collected
10:11:45 <mmorrow> adh0c: until that discarded now-unreachable old data is GC'ed, yes
10:12:15 <sm> sw17ch: also unless I misunderstand, most forked threads and their stuff will be closed when the parent thread dies
10:12:56 <mmorrow> adh0c: run any (ghc-produced) haskell program with "./Foo +RTS -B -RTS" to see how often the GC is running
10:13:00 <adh0c> what mistyfies me is how other functions that implicitly use the state know how to address the memory
10:13:06 <mmorrow> adh0c: that rings the terminal bell every gc
10:13:19 <adh0c> does the compiler translate this?
10:13:24 <mmorrow> adh0c: they're passed the state as an argument of course :)
10:13:25 <adh0c> or am I missing something?
10:13:31 <ezyang> adh0c: Yes. You are missing the monad ;-)
10:13:48 <mmorrow> adh0c: and that this is hidden is the whole point of State :)
10:14:08 <adh0c> but how does the function know which state to access then?
10:14:19 <ezyang> There is only one state
10:14:19 <adh0c> or can there be only one instance of state per runtime?
10:14:19 <mmorrow> there is only one state, the current one
10:14:32 <adh0c> oh
10:14:43 <ezyang> But since that state can be an arbitrary algebraic data type, you can in practice pack as much (or as little) as you want
10:14:45 <lilac> @type let k f a = State $ \s -> f (a, s); getput = k $ \(s, a) -> (a, s) in getput
10:14:47 <lambdabot> forall s. s -> State s s
10:14:53 * ezyang wonders what StateT on State would be 
10:15:09 <adh0c> that makes for some memory shuffling if I'm using a few state-dependant functions, doesn't it?
10:15:25 <ezyang> I dunno what GHC does internally for this case
10:16:18 <adh0c> does GHC translate the implied state references to actual memory locations during compile time?
10:16:49 <smarmy> state aware functions take the state in as the argument.  it's just normal argument passing semantics
10:17:18 <smarmy> to "run" a stateful computation is to pass in the state to the first function and then the monad threads it through the rest
10:17:26 <ezyang> I suppose adh0c is concerned about the performance implications of this threading
10:17:27 <adh0c> so it's translated as a function call with another argument during compilation?
10:17:45 <ezyang> mu
10:18:01 <mmorrow> what's the name of that newish "netbook" (not asus) that's decent (vague, i know)?
10:18:08 <smarmy> adh0c: yes.  the state monad results in a function that expects an initial state as argument
10:18:57 <smarmy> so there's no need to know about some explicit memory space which the computation goes and peers into.  it's just a pure function like any other
10:19:06 <ezyang> oh, yes!
10:19:17 <ezyang> Only the IO monad is special
10:19:55 <mmorrow> adh0c: basically, the entire reachable heap is reachable from registers
10:20:00 <roconnor> ST is special too
10:20:02 <adh0c> but the calls are translated during compile time to include the additional state value address, yes?
10:20:15 <adh0c> I mean the calls to the stateful functions
10:20:37 <mmorrow> adh0c: they get handed a pointer to the current state in a register as one of their arguments
10:20:45 <mux> just imagine >> and >>= being replaced by their implementation
10:20:47 <adh0c> oh
10:20:53 <lilac> STM is pretty special
10:21:10 <mux> (in the case of the State monad I meant)
10:21:38 <adh0c> but then, how does the compiler make sure the state-dependent functions get called in the necessary order?
10:21:41 <smarmy> i'd argue that the "additional state value address" is implicit even before compile time.  at code time, it's a function with a state argument.  it isn't being hidden from you and implicitly injected later by the compiler
10:21:55 <ezyang> adh0c: The monad is necessary and sufficient to get this
10:21:56 <lilac> adh0c: it doesn't, and it doesn't need to
10:22:04 <ezyang> (actually, technically, the applicative, but :o)
10:22:23 <lilac> adh0c: at each step of the computation where the state changes, you get a new state
10:23:13 <adh0c> but is the state stored if I discard it from the result tuple and just process the actual result?
10:23:17 <lilac> adh0c: suppose you write a computation in the State monad which does: do put computation1; return computation 2
10:23:27 <mmorrow> aspire one was the one i was thinking of
10:23:37 <lilac> if you never look at the resulting state, computation1 will not be run. if you never look at the resulting value, computation2 will not be run.
10:23:42 <mmorrow> ooh snap, lenovo has one now
10:24:02 <adh0c> I see
10:24:05 <smarmy> adh0c: a stateful function returns a tuple of the value and next state.  you _must_ return a next state, although it could be bottom
10:24:28 <adh0c> I understand that
10:24:43 <mmorrow> adh0c: the necessary order is ensured because of data-dependencies
10:24:45 <lilac> adh0c: you can think of a function "a -> State s b" as a function "(a, s) -> (b, s)". then =<< is just function composition.
10:25:18 <lilac> (well, technically, (<=<) is composition, but...)
10:25:19 <adh0c> what I was curious about is does the state get GCd if I don't use it anymore after running the necessary state-dependent computations?
10:25:32 <ezyang> adh0c: Yes.
10:25:32 <smarmy> adh0c: oh, i see what you meant by your question.  the gc collects it
10:25:37 <adh0c> let's say I generate some pseudorandom numbers
10:25:43 <adh0c> and after that I want to process them
10:25:57 <adh0c> but I don't care anymore about what was the resulting state of the generator
10:26:01 <adh0c> I just want the number
10:26:15 <adh0c> does the state get GCd then?
10:26:32 <lilac> if you have no further references to it, it gets GCd like anything else
10:26:33 <ezyang> Yes.
10:26:37 <adh0c> I see
10:26:54 <smarmy> if state is a tuple, and you call fst to discard the state and extract the value, then the state has no reference
10:26:56 <smarmy> it gets gc'd
10:27:14 <adh0c> so if I wanted to use the generator again, I'd have to reinitialize the state?
10:27:47 <lilac> adh0c: think about how you'd write that. either it's part of the same "State s" computation, and can reuse the state, or it's not, and can't
10:28:01 <Cale> adh0c: Eh? If you tried to use the generator again, then you must not have lost your last reference to it, and so it wouldn't have been garbage collected after all.
10:28:17 <Cale> adh0c: Things are garbage collected sometime after the last time you use them.
10:28:42 <lilac> things are never garbage collected if your program could possibly use them again
10:28:45 <adh0c> but what if I wanted to use the generator much much later on?
10:28:53 <jmcarthur_work> it would still be there
10:28:55 <adh0c> would that translate to not marking the memory for GC?
10:28:57 <Cale> adh0c: Then it would remain in memory waiting to be used.
10:28:58 <lilac> either you hold a reference to it and it doesn't get GCd or you recreate it
10:29:08 <adh0c> I see
10:29:17 <Cale> adh0c: Even if your program never uses it again, if it possibly could, then it must be retained.
10:29:24 <lilac> the GC has no idea what you "want". but if your code holds a reference to it, it'll stay live
10:30:03 <adh0c> so the compiler would translate the code to hold the reference if there is an oncoming use much further down the way?
10:30:04 <Cale> and the garbage collector doesn't contain a Turing oracle either, so it's not going to do complex calculations to decide if something can be thrown away. It just notices when there are no more references to things.
10:30:20 <Cale> adh0c: Values are pointers to code.
10:30:55 <adh0c> not the results of calculations?
10:31:28 <Cale> adh0c: The first time the code runs, it stores the actual result somewhere and rewrites the pointer to point at code which returns it immediately.
10:31:30 <ezyang> adh0c: What language do you come from?
10:31:31 <wolverian> I have a tree to which I'd like to add backlinks to (making it a cyclic directed graph). I'm unsure how to do this with sharing (tying the knot), given that I already have the tree in a direct recursive form and not a lookup table. any hints?
10:31:47 <adh0c> ezyang, take a deep breath
10:31:49 <adh0c> C++
10:32:07 <ezyang> ok, so no memory management
10:32:19 <wolverian> I'm not even sure it's possible without a table to keep the references in.
10:32:43 <Cale> adh0c: Basically, you'd never worry about whether something tiny like a random number generator state is being GC'd or not.
10:32:47 <smarmy> well, in C++ you've got auto_ptr's, which aren't too far off from the basic idea
10:32:52 <ray> adh0c: in that case, welcome to haskell, please chill out and don't worry
10:33:02 <ezyang> :-)
10:33:10 <ray> it's all right, you're safe now
10:33:14 <Cale> adh0c: It's only potentially-large values that you worry about whether you've really lost your last reference to them.
10:33:15 <adh0c> worry is the default behavior for C++
10:33:29 <Cale> Like lists or other collections.
10:33:37 <wolverian> I'm especially looking to Cale for help, given that I saw your name on the tying the know haskellwiki page... ;)
10:33:44 <wolverian> s,know,knot,
10:34:08 <Cale> wolverian: What are you using the cyclic graph for?
10:34:20 <Cale> wolverian: Usually that's not the most convenient representation.
10:34:21 <adh0c> Cale, but if I use the lists further in the execution, it surely won't be marked for deletion before it gets there by the resulting translated code?
10:34:29 <Cale> adh0c: Right.
10:34:31 <wolverian> Cale: Aho–Corasick matching
10:34:36 <dooof> say I have a record and a function operating on it - is there any way to make the function take a parameter saying which field in the record to use?
10:34:39 <adh0c> ok
10:34:48 <Cale> wolverian: hmm, do you have to modify the graph at any point after you create it?
10:34:52 <ezyang> adh0c: Even when you're doing manual memory management, you still need to have pointers to the memory to free it. If you lost all the pointers, the memory leaks
10:34:54 <wolverian> Cale: no.
10:35:02 <Cale> wolverian: and do you have to detect when you're in a cycle?
10:35:07 <wolverian> no.
10:35:09 <poe> dooof: pass in the accessor function
10:35:15 <mux> @pl \x -> (y,x)
10:35:15 <lambdabot> (,) y
10:35:18 <mux> ah, yeah.
10:35:22 <Cale> wolverian: Okay, then that's a reasonable candidate for tying the knot, I suppose :)
10:35:26 <mux> but I can have tuple sections now!
10:35:41 <wolverian> right. :) I just don't see how to do it without an intermediate table representation.
10:35:44 <Cale> wolverian: Personally, I usually find it more convenient to use Map Vertex (Set Vertex) or similar.
10:35:59 <dooof> poe: what about field update?
10:36:01 <wolverian> I'm thinking I should have done that...
10:36:11 <Cale> Well... the usual way is to give names to pointers using let.
10:36:44 <ezyang> dooof: Hmm... I don't think named record syntax generates settors
10:36:52 <Cale> wolverian: If you can set the structure up with pointers using recursion without modifying those pointers after their initial creation, you can do it with let in the same way.
10:37:14 <aavogt> @src showChar
10:37:15 <lambdabot> Source not found. You untyped fool!
10:37:28 <wolverian> Cale: okay. when I construct a node and recurse into its children, what do I name? currently I just pass the parent to the recursive call, since the backlinks are always computed through the parent.
10:37:43 <dooof> is there any way to work around the field update not being first class?
10:37:48 <wolverian> Cale: (but since that parent is not shared, the backlink doesn't point back to the same tree)
10:38:04 <ezyang> dooof: You could always write the function yourself
10:38:12 <roconnor> > (6%29 +16)/116
10:38:14 <lambdabot>   235 % 1682
10:38:16 <ezyang> since there is the special syntax for setting values
10:38:35 <roconnor> > (6%29*116 -16)
10:38:37 <lambdabot>   8 % 1
10:38:48 <adh0c> ok, now I've got another question
10:39:05 <dooof> ezyang: wouldn't I end up with the same limitations then?
10:39:15 <ezyang> Well, now you have a function you can pass around
10:39:27 <adh0c> why does getStdRandom (randomR (0, 100)) work but randomR (0, 100) throws an error?
10:39:28 <Cale> wolverian: You should name each node you construct (that is, the data constructor applied to some stuff) explicitly with 'let' and pass it along to further recursive steps if there are going to be backreferences to it.
10:39:44 <Cale> :t randomR (0,100)
10:39:45 <lambdabot> forall t g. (Num t, Random t, RandomGen g) => g -> (t, g)
10:39:47 <ezyang> :t getStdRandom
10:39:48 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
10:39:48 <dooof> ezyang: ah, true :)
10:39:53 <Cale> adh0c: It needs a parameter.
10:40:11 <ray> adh0c: you can't really show functions
10:40:15 <Cale> adh0c: It's not that it's actually an error, just that it needs a StdGen to get started.
10:40:31 <adh0c> but why doesn't it need it when I run it through getStdRandom?
10:40:31 <ray> so you have this function value
10:40:47 <Cale> adh0c: Because getStdRandom's job is to supply that parameter.
10:40:54 <adh0c> oh
10:41:10 <Cale> I don't use that function myself though.
10:41:10 <ezyang> Notice how nicely the type signatures fit together
10:41:13 <sw17ch> sm: (sorry for the massive rewind) this is true unless the thread is blocked in a foreign call
10:41:15 <wolverian> Cale: so I have let parent = Node { ... children = go ... parent ... } in parent?
10:41:19 <ray> getStdRandom takes a function and returns a value
10:41:23 <wolverian> Cale: that looks somehow like not enough. :)
10:41:23 <sm> sw17ch: ah, ok
10:41:27 <adh0c> so it supplies StdGen to the function it's called with?
10:41:30 <ray> yes
10:41:38 <adh0c> I see
10:41:39 <mmorrow> and the StdGen that getStdRandom is one of the few global vars
10:41:39 <ray> it supplies the standard standard generator
10:41:45 <Cale> I usually use newStdGen and just pass the parameter explicitly.
10:42:02 <adh0c> huh? global vars?
10:42:06 <mmorrow> i.e. one of the few parts of the reachable heap not necessarily reachable from registers
10:42:20 <Cale> (because I don't like the hackery in the System.Random module)
10:42:35 <mmorrow> adh0c: unsafePerformIO (newIORef ...) -- most likely
10:42:44 <ray> in other words, hackery
10:43:05 <Cale> It's not necessary to inform beginners about GHC internals like unsafePerformIO ;)
10:43:06 <jmcarthur_work> random is best used as a monad, imo
10:43:21 <ray> i'm partial to comonadic randoms
10:43:23 <mmorrow> Cale: :)
10:43:24 <adh0c> to be honest, generating pseudorandom numbers was handled much more nicely in most imperative languages I worked with
10:43:45 <wolverian> Cale: that doesn't affect the sharing at all. I'm pretty sure I'm missing something basic; I should be passing the shared parent to the children, but it depends on the children.
10:43:47 <jmcarthur_work> ray, i wrote the comonad-random package, and i'm convinced that it is not as useful as monadic random ;)
10:43:49 <adh0c> you didn't have to worry about the state itself
10:43:54 <adh0c> you just passed the range
10:44:05 <ezyang> Right. Haskell forces you to think about these things
10:44:17 <mmorrow> adh0c: the point though of having the state available is to be able to reproduce an identical sequence later
10:44:17 <ezyang> (well, Monads let you forget about them again...)
10:44:18 <ray> jmcarthur_work: i really think an infinite supply of randoms is the way to go
10:44:33 <jmcarthur_work> ray, i think that interface is useful *sometimes*
10:44:33 <smarmy> yeah, the state passing is still happening in the imperative version... it's just not explicit
10:44:41 <adh0c> I know
10:44:55 <mmorrow> adh0c: you can just use randomIO/randomRIO if you don't care about the generator
10:44:57 <ray> jmcarthur_work: if you only want a couple randoms, it's probably simpler with a monad
10:45:06 <adh0c> but the fact that it's not explicit makes the code more readable for me
10:45:08 <bos> i wonder if there's a more concise way to write this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8787#a8787
10:45:09 * ezyang still needs a small-medium sized project to hack on to get some practical Haskell experience 
10:45:10 <smarmy> haskell forces you to control state, which i've come to love
10:45:49 <smarmy> i'm amazed when i write haskell at how much i'm dealing with explicitly that i gloss over in my imperative code
10:46:00 <ray> but i'm convinced that supply comonad is the best way to deal with randoms
10:46:01 <smarmy> it's definitely made me a better programmer all around
10:46:06 <jmcarthur_work> ray, the problem with comonadic random is (1) i can't generate many values of many different types very easily from it and (2) you have to make sure you aren't using the same values in the generation of different computed values or else you introduce nonrandom patterns
10:46:24 <bos> i'm bothered that my code probably won't fuse, the way i've written it.
10:46:32 <ezyang> Any suggestions?
10:46:33 <jmcarthur_work> the latter problem meaning you have to track of what directions you travel down the tree
10:46:44 <jmcarthur_work> and have a policy of which ones you may take later
10:47:01 <jmcarthur_work> (where the tree is generated by splitting the generator)
10:47:44 <bos> i guess it's about as fusible as it can be.
10:48:08 <adh0c> ok
10:48:22 <adh0c> now I'm beginning to understand this
10:48:35 <adh0c> it's kind of an enlightening experience to be honest
10:48:41 <adh0c> thanks for your help, guys
10:49:18 <jmcarthur_work> ray, for example, if in my example code at http://hackage.haskell.org/packages/archive/comonad-random/0.1.2/doc/html/Control-Comonad-Random.html i replace "extracts left" line with "extracts next," i introduce a pattern
10:49:20 <copumpkin> bos: autocovariance?
10:49:24 <jmcarthur_work> ray, it's kind of an abstraction leak
10:49:31 <bos> copumpkin: yup.
10:49:51 <ray> yeah, it's possible i guess
10:49:59 <copumpkin> bos: hmm, I guess you can't use a regular fusible variance function for that?
10:49:59 <mmorrow> bos: i can't see any way to simplify it at first glance
10:50:18 <copumpkin> bos: (cause I wrote one for uvector that fuses nicely)
10:50:27 <ray> i guess it's another tossup between the neat freak on my right shoulder and the lazy bum on my left
10:50:33 <bos> copumpkin: you did?
10:50:35 <mmorrow> copumpkin to teh rescue
10:50:38 <ray> the bum would use a monad
10:50:38 <ksf> my first fundep!
10:50:41 <copumpkin> but it's not autocovariance :o
10:50:50 <copumpkin> never come across autocovariance :)
10:50:56 <bos> copumpkin: not necessarily a problem.
10:51:02 <ksf> and I figured out that I needed them, just from the type error, and by myself!
10:51:10 <bos> autocovariance is just the variance of a signal with a time-shifted version of itself.
10:51:32 <bos> i.e. autocovariance c = variance c (drop 10 c)
10:51:40 <copumpkin> bos: it's in http://hackage.haskell.org/package/statistics-fusion
10:52:04 <jmcarthur_work> ray, it's worse if you consider that the second half of that function could have been abstracted into a separate function, meaning i have know whether it uses left, next, or right. that's why i say it's an abstraction leak. you have to know implementation details of a function to use it properly
10:52:18 <bos> copumpkin: oh, the var function there.
10:52:19 <Cale> ray: I would expect it to be the other way around...
10:52:30 <copumpkin> bos: yeah, might not be useful for you
10:52:43 <bos> copumpkin: well, that just computes a single value. i need a vector of values over the entire input.
10:52:53 <copumpkin> yeah, that's what I thought :/
10:53:00 <bos> copumpkin: why do you use a specialised tuple in that code? why not :*:?
10:53:06 <etpace_> :t (>>=) Reader
10:53:08 <lambdabot> forall r a b. (Reader r a -> (r -> a) -> b) -> (r -> a) -> b
10:53:31 <etpace_> hmm
10:53:31 * bos now has to get from autocovariance to autocorrelation
10:53:47 <copumpkin> bos: I was just starting with haskell at the time, and based my variance code off what dons had already written for the other functions :) not sure why he did it
10:54:18 <Cale> etpace_: That's... you're applying >>= to the data constructor for Reader
10:54:24 <copumpkin> bos: might as well compute that in n log n ?
10:54:35 <Cale> etpace_: So that's the >>= for function values.
10:54:58 <etpace_> Reader r a is just (r -> a) right?
10:55:13 <Cale> etpace_: Well, a wrapper around that, yes.
10:55:16 <adh0c> why does show "asdf" >>= putStrLn fail?
10:55:26 <bos> copumpkin: ah
10:55:32 <adh0c> show "asdf" produces a String and that's what putStrLn expects
10:55:35 <bos> copumpkin: compute what?
10:55:37 <jmcarthur_work> show is not in the IO monad
10:55:37 <Cale> adh0c: Because putStrLn is not a function in the list monad, and (show "asdf") is a list
10:55:42 <copumpkin> bos: autocorrelation
10:55:45 <sw17ch> grrr, why is it just now that i start discovering all these issues with foreign calls...
10:55:51 <sw17ch> i can't be doing somethign all that unique
10:55:53 <Cale> putStrLn (show "asdf")
10:55:54 <copumpkin> (instead of n^2)
10:56:43 <etpace_> :t (>>=)
10:56:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:57:06 <bos> copumpkin: hmm. how?
10:57:27 <Cale> adh0c: If you want to restrict your view to just the IO monad rather than all monads for the time being, then you can think of (>>=) as having the type IO a -> (a -> IO b) -> IO b
10:57:55 <etpace_> :t (>>=) (Reader e)
10:57:56 <lambdabot>     Couldn't match expected type `r -> a' against inferred type `Expr'
10:57:56 <lambdabot>     In the first argument of `Reader', namely `e'
10:57:56 <lambdabot>     In the first argument of `(>>=)', namely `(Reader e)'
10:58:25 <Cale> That is, if x is an action of type IO a, and f is a function from possible results of that action, that is, values of type a, to further actions to be done of type IO b, then x >>= f is the combined action which when run will first run x, then apply f to its result and run that.
10:58:36 <sw17ch> are there any threaded RTS experts in here?  i can't tell if i have a bug or normal behavior
10:58:57 <adh0c> so is there a way for me to pass a string to putStrLn with >>=?
10:59:09 <Cale> adh0c: I don't understand why you want to use >>= here
10:59:09 <copumpkin> bos: http://hebb.mit.edu/courses/9.29/2002/readings/c13-2.pdf , but basically autocorrelation is a kind of convolution, and you can do convolution in n log n time with an FFT
10:59:11 <mauke> adh0c: no
10:59:13 <bos> sw17ch: ask away
10:59:29 <adh0c> I was just curious if it was possible
10:59:30 <Cale> adh0c: putStrLn is a function which takes a string, and gives an action for printing that string on the screen.
10:59:56 <bos> copumpkin: hmm.
11:00:05 <Cale> adh0c: So, if you have a string you want to apply it to, you just apply it like any other function.
11:00:16 <copumpkin> bos: not sure if it'll end up being too painful with all the numerical adjustment, but if you're autocorrelating large signals it might be helpful
11:00:16 <Cale> :t putStrLn
11:00:18 <lambdabot> String -> IO ()
11:00:18 <adh0c> so something must produce an IO action for me to thread it with >>=?
11:00:29 <jmcarthur_work> yes that is the purpose of >>=
11:00:58 <Cale> adh0c: (small lie), the thing on the left of >>= must be an IO action, and the thing on the right of >>= must be a function from results of that first action to further actions
11:01:30 <mauke> you can wrap a string in a no-op action, of course
11:01:36 <Cale> adh0c: The small lie is the part about it being restricted to IO -- >>= is part of a more general interface to libraries which work in this particular way: monads.
11:01:39 <mauke> something that does nothing but return that string
11:01:41 <ray> that's actually a big lie cale
11:01:44 <adh0c> isn't a result of an IO action just whether the IO action executed?
11:01:51 <ray> no
11:02:04 <Cale> adh0c: no, it's the value that the IO action constructs and returns when executed
11:02:08 <ray> it's whatever's inside the IO
11:02:10 <jmcarthur_work> :t getLine
11:02:11 <lambdabot> IO String
11:02:14 <ray> in this case, a ()
11:02:17 <mauke> ray: no
11:02:26 <ray> what, then
11:02:27 <mauke> IO doesn't contain return values
11:02:36 <adh0c> so the result of an IO action that displays a string is that string?
11:02:41 <mauke> adh0c: no
11:02:50 <jmcarthur_work> :t putStrLn
11:02:51 <lambdabot> String -> IO ()
11:02:54 <Cale> adh0c: Nope, putStrLn :: IO () -- its result is an empty tuple
11:02:59 <Cale> er
11:03:01 <Cale> silly me
11:03:03 <bos> copumpkin: all we need now is a decent FFT over uvector :-)
11:03:04 <mauke> the result of an IO action that displays a string can be anything, but in the case of putStr it's a ()
11:03:06 <Cale> adh0c: Nope, putStrLn :: String -> IO () -- its result is an empty tuple
11:03:11 <sw17ch> bos: basically what i'm looking at is a problem killing threads in a foreign call
11:03:23 <Cale> :t putStrLn "Hello"
11:03:25 <lambdabot> IO ()
11:03:27 <copumpkin> bos: yeah! I was thinking of binding the fftw code to uvector, but never got around to it :/
11:03:28 <Cale> :t getLine
11:03:29 <lambdabot> IO String
11:03:36 <ray> mauke: so what's the difference with what i said
11:03:38 <Cale> :t getLine >>= putStrLn
11:03:40 <lambdabot> IO ()
11:03:49 <Cale> ^^ try that one in ghci
11:03:52 <Vanadium> If there are zero-element tuples, and there are two-element tuples and so on, how come there are no one-element tuples? :(
11:03:56 <mauke> <ray> it's whatever's inside the IO
11:04:00 <jmcarthur_work> ray, you said "inside the IO" which isn't quite true
11:04:03 <copumpkin> Vanadium: what would be the point? :P
11:04:05 <jmcarthur_work> IO doesn't contain anything
11:04:07 <bos> copumpkin: was this wiener-khinchin theorem something you already knew about?
11:04:11 <Cale> You'll see that what getLine >>= putStrLn does is to get a line of text from the user, and then print it back out.
11:04:11 <ray> it's the type inside the IO type constructor
11:04:18 <Vanadium> copumpkin: Consistenc
11:04:18 <Vanadium> y
11:04:19 <mauke> I()O
11:04:32 <adh0c> so the only way it makes sense is to thread an IO action that produces an actual result instead of ()
11:04:45 <copumpkin> bos: nope, I just "dabble" in that kind of stuff :) never made any real concerted effort to learn it
11:04:47 <jmcarthur_work> :t getLine >>= putStrLn
11:04:49 <lambdabot> IO ()
11:04:54 <jmcarthur_work> yup :)
11:04:54 <ray> so the result of getLine is a String and getLine :: IO String
11:05:02 <copumpkin> :t readFile
11:05:03 <lambdabot> FilePath -> IO String
11:05:10 <copumpkin> :t readFile >=> putStrLn
11:05:11 <lambdabot> FilePath -> IO ()
11:05:12 <ray> do you object to that, or just to terminological confusion?
11:05:30 <adh0c> I don't object to anything
11:05:34 <jmcarthur_work> i don't understand >=> ... <=< seems so much more intuitive to me
11:05:36 <adh0c> I'm just trying to learn the language
11:05:36 <bos> copumpkin: ah
11:05:40 * copumpkin objects to adh0c's lack of objections
11:05:47 <bos> sw17ch: i'm not too surprised
11:05:57 <jmcarthur_work> applying the argument on the right instead of to the right of the thing on the left
11:06:06 <sw17ch> bos: more interestingly is that the program doesn't seem to want to die if i'm blocked on a foreign call
11:06:12 <ray> adh0c: directed to mauke et al
11:06:13 <etpace_> :t (>=>)
11:06:14 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:06:16 <lilac> jmcarthur_work: agreed. i also prefer =<< :)
11:06:18 <Cale> jmcarthur_work: I agree, (<=<) is more sensible
11:06:25 <sw17ch> bos: i'm used to the programming coming down when the main thread terminates
11:06:27 <ray> =<< is better
11:06:30 <jmcarthur_work> (>=>) makes about as much sense to me as (;) = flip (.)
11:06:40 <copumpkin> jmcarthur_work: yeah, I usually use <=< too, but if we're talking about >>=, then it's natural to move to >=>
11:06:41 <adh0c> ray, huh?
11:06:43 <sw17ch> bos: if i have a blocking call out, then the RTS hangs and spins on the 20ms "interrupt"
11:06:54 <Cale> adh0c: Basically, it was part of another discussion
11:07:03 <adh0c> oh
11:07:05 <jmcarthur_work> heh, i wish we didn't even bother teaching beginners (>>=)
11:07:24 <Cale> >>= makes sense in terms of translating do-notation though
11:07:24 <adh0c> that sounds elitist
11:07:26 <copumpkin> bos: sorry I can't be more useful :)
11:07:34 <bos> sw17ch: hmm.
11:07:40 <jmcarthur_work> adh0c, who me?
11:07:45 <adh0c> yes
11:07:51 <ray> not really elitist
11:07:57 <jmcarthur_work> adh0c, i just think >>= is sillier than =<< ;)
11:07:58 <Cale> adh0c: Well, there are many approaches to these topics, and many places to begin.
11:08:00 <ray> he'd just prefer we taught beginners things that make sense
11:08:05 <sw17ch> bos: more importantly, i'm not entirely which thread it is, because it seem to accept the "killThread" exception, but then doesn't die
11:08:15 <adh0c> which part of >>= doesn't make sense?
11:08:24 <Cale> adh0c: It's backward from normal function application
11:08:24 <adh0c> and that's not a rhetorical question
11:08:25 <etpace_> How can I remove/rename the really long *Main Long List Of Modules I've Imported> i ghci?
11:08:35 <ray> the part where it takes a function on the right
11:08:40 <ray> we apply functions like "f x"
11:08:41 <jmcarthur_work> adh0c, it's like backwards function application for monads. why must it be backwards?
11:08:45 <ray> but bind like x >>= f
11:08:52 <adh0c> I see
11:09:01 <adh0c> it's confusing, but one can get used to it
11:09:07 <Cale> But >>= does nicely reflect the order in which the effects happen
11:09:11 <adh0c> still I wouldn't say it improves readability
11:09:12 <jmcarthur_work> yes
11:09:13 <ray> yes, which is why it gets used
11:09:34 <jmcarthur_work> but so does =<< (it points in the direction of the effects)
11:09:35 <sw17ch> bos: actually, this is new. it appears that it got hung up on a final call to "threadDelay"
11:09:39 <ray> but in terms of understanding the types, =<< is more natural - it takes a function and applies it
11:09:42 <ray> but in a monadic context
11:09:46 <sw17ch> i dropped that call, and things seemed to come down
11:09:48 <Cale> jmcarthur_work: I suppose you can look at it that way
11:09:52 <jmcarthur_work> but that is *unlike* (<*) which does not
11:10:14 <Cale> jmcarthur_work: I like the fact that we actually evaluate functions from left to right too. :)
11:10:15 <mauke> etpace_: :set prompt "*> "
11:10:45 <copumpkin> :t (*>)
11:10:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
11:10:47 <Cale> evaluating f (g x) evaluates f first
11:10:47 <jmcarthur_work> Cale, heh
11:10:49 <ray> also ($) has different fixity from normal function application :)
11:11:01 <ray> er
11:11:03 <ray> associativity
11:11:05 <etpace_> thanks mauke
11:11:09 <jmcarthur_work> and fixity
11:11:16 <ray> yes, but the fixity part is useful
11:11:17 <jmcarthur_work> precedence
11:11:29 <Cale> Don't make me think about that painful thing ;)
11:11:38 <ray> actually, i've just come to doubt i know what fixity means, so i'll stop using it
11:11:46 <ray> just "associativity" and "precedence"
11:11:57 <jmcarthur_work> i don't know if it's correct, but i tend to wrap associativity and precedence both under the umbrella of "fixity"
11:12:06 <Cale> jmcarthur_work: I'd agree with that definition.
11:12:15 <mauke> infix, prefix, postfix, circumfix, postcircumfix
11:12:47 <Cale> Fixity is everything you need to know about an operator while parsing to produce a correct expression tree.
11:14:00 <|randomwords|> Is there anyway to automate the number of OS threads run in parallel by a given program. i.e. remove the need for the user to append +RTS -N
11:14:49 <sw17ch> bos: actually, it does seem to happen when i have a tailing call to threadDelay... any reason why that might e?
11:14:50 <sw17ch> be?
11:14:58 <sw17ch> ("it happens" means that the program hangs)
11:15:46 <bos> sw17ch: off the top of my head, i don't know, sorry.
11:16:01 <sw17ch> bos: alright, just checking :)
11:16:03 <Cale> |randomwords|: There is, but it's a bit hackish-seeming.
11:16:31 <Cale> |randomwords|: You define a string constant in a .c source file, and include that on your ghc commandline, iirc.
11:16:36 <|randomwords|> eww
11:16:44 <|randomwords|> but at least it's possible
11:16:45 <copumpkin> sw17ch: maybe #ghc ?
11:16:52 <sw17ch> copumpkin, good idea...
11:17:08 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
11:17:10 <ray> general hacker's confederacy
11:17:22 <mauke> |randomwords|: easier solution: write a thin wrapper program
11:18:32 <|randomwords|> Thanks Cale, mauke
11:18:52 <Cale> It would really be good if there were IO actions for dynamically adjusting the RTS parameters.
11:19:38 <SamB> what, so you could switch heap profiling modes?
11:19:47 <mmorrow> adh0c: re: the GC and "reachable" things => reachable := start at the registers, follow and pointers there, then for each of those targets, find all the pointers in those, and follow each of them, and so on recursively until you dead-end and a object that doesn't contain any pointers
11:20:12 <sw17ch> copumpkin, now that i think about it, i've never ever received a response to any question in #ghc...
11:20:19 <copumpkin> :P
11:20:23 <|randomwords|> And what's the easiest way of determining at runtime the number of available cores? There doesn't seem to be anything in System.* or in RTS --info. Do I need to cat something in /dev/?
11:20:30 <copumpkin> sw17ch: it is rather quiet sometimes ;)
11:20:33 <adh0c> mmorrow, thanks
11:20:34 <mmorrow> adh0c: so if it's even possible for you code the refer to something, it means that it's reachable from the current registers
11:20:37 <mmorrow> adh0c: np
11:20:41 <sw17ch> :)
11:21:07 <copumpkin> thoughtpolice: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8788#a8788
11:22:34 <mmorrow> |randomwords|: GHC.Conc.numCapabilities
11:23:08 <adh0c> ok last question for today
11:23:21 <|randomwords|> mmorrow: Thanks
11:23:23 <adh0c> why does randomR (0, 100) =<< newStdGen fail?
11:23:33 <jmcarthur_work> :t newStdGen
11:23:34 <lambdabot> IO StdGen
11:23:39 <jmcarthur_work> :t randomR
11:23:40 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:23:54 <jmcarthur_work> :t randomR (0, 100) =<< newStdGen
11:23:55 <lambdabot>     Couldn't match expected type `(t, a)'
11:23:55 <lambdabot>            against inferred type `IO StdGen'
11:23:55 <lambdabot>     In the second argument of `(=<<)', namely `newStdGen'
11:24:08 <jethr0> can someone tell me what "Constructor(..)" means in module exports?
11:24:19 <etpace_> For Reader, (Reader x) >>= f = \e -> f e, right? but f has a type of Reader, shouldn't I have runReader f e?
11:24:20 <jethr0> I never quite got that...
11:24:23 <mmorrow> |randomwords|: also, that shows you how many cores the current instance of the rts has available to it, not how many are physically there
11:24:56 <jmcarthur_work> adh0c, the problem is that randomR doesn't return an IO action
11:25:03 <mmorrow> |randomwords|: (e.g.  ghc -threaded --make Foo.hs; ./Foo +RTS -N7 -RTS   or   ghc --make Foo.hs; ./Foo, etc)
11:25:05 <jmcarthur_work> :t randomR (0, 100) `liftM` newStdGen
11:25:06 <lambdabot> forall t. (Num t, Random t) => IO (t, StdGen)
11:25:15 <jmcarthur_work> :t liftM
11:25:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:25:19 <|randomwords|> mmorrow: Ah, then it's not quite what I want. I was going to use that value to alter the number that I pass using RTS
11:25:20 <mauke> @src (->) (>>=)
11:25:21 <lambdabot> f >>= k = \ r -> k (f r) r
11:25:33 <mauke> @src Reader (>>=)
11:25:33 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:25:41 <jmcarthur_work> :t return . randomR (0, 100) =<< newStdGen   -- alternatively
11:25:42 <lambdabot> forall t. (Num t, Random t) => IO (t, StdGen)
11:25:43 <adh0c> jmcarthur_work, but how does that relate to my problem?
11:25:55 <mauke> etpace_: that definition looks completely wrong
11:25:57 <mmorrow> |randomwords|: ah, hmm. i guess maybe look at /proc/cpu ?
11:26:04 <jmcarthur_work> adh0c, bind requires the function to return an IO action
11:26:05 <|randomwords|> mmorrow: I imagine so
11:26:14 <adh0c> oh
11:26:39 <mauke> by types alone I set my mind in motion
11:27:42 <etpace_> hmm
11:27:43 <mauke> m >>= f = Reader (\e -> runReader (f (runReader m e)) e)
11:27:44 <mmorrow> jethr0:  module A (A(A)) where data A = A | B;    B isn't visible from outside
11:27:45 <|randomwords|> It's all very well having a program that expliots multiple cores, but unless the user knows to pass an RTS option, then it's all for nothing.
11:28:04 <mmorrow> jethr0:  module A (A(..)) where data A = A | B;    A *and* B is visible from outside
11:28:08 <mmorrow> s/is/are/
11:28:08 <etpace_>  (Reader r) >>= f = Reader $ \e -> f (r e) e
11:28:16 <jmcarthur_work> |randomwords|, use a wrapper shell script
11:28:24 <etpace_> Is what i'm reading, so its totally wrong?
11:28:29 <jmcarthur_work> or you can hack in some RTS options on the C level
11:28:37 <mauke> etpace_: where are you reading that? because it's missing a runReader
11:28:40 <EvilTerran> mmorrow, not forgetting A :P
11:28:51 <etpace_> http://www.haskell.org/all_about_monads/html/readermonad.html
11:28:56 <mmorrow> EvilTerran: ?
11:29:20 <EvilTerran> (there's two things called A being exported there, i mean)
11:29:23 <mauke> etpace_: you've found a bug
11:29:33 <mmorrow> EvilTerran: ah, right
11:29:49 <etpace_> who should I alert? ;)
11:30:19 <mmorrow> |randomwords|: you can link in a symbol  char *ghc_rts_options = "-N8"  if you really want to, but it'll be set at link-time of course
11:31:12 <jmcarthur_work> couldn't you just say -N without specifying the number?
11:31:15 <mmorrow> echo 'char *ghc_rts_options = "-N2"' > rts_opts.c && ghc ... Foo.hs rts_opts.c
11:31:18 <mmorrow> or whatever
11:31:19 <jmcarthur_work> it should default to the number of cores, right
11:31:20 <jmcarthur_work> ?
11:31:29 <mmorrow> it defaults to -N1
11:32:02 <jmcarthur_work> i thought -N on newer GHCs set to number of cores
11:32:15 <mmorrow> i don't think so
11:32:16 <jmcarthur_work> and without even -N it defaults to -N1
11:32:30 <mmorrow> (although that seems a much better default)
11:32:37 <mmorrow> oh, no idea
11:32:50 <mmorrow> i'm not sure about just "-N"
11:32:59 <mmorrow> try it with ghci
11:33:08 <jmcarthur_work> well, it has worked for me before :)
11:33:19 <jmcarthur_work> or at least apparently
11:33:42 <|randomwords|> jmcarthur_work: How new? On 6.10 -N defaults to -N1
11:33:47 <mmorrow> jmcarthur_work: it works, good to know
11:33:54 <jmcarthur_work> |randomwords|, really?!
11:34:00 * ksf fails to implement a function [b] -> a with a fundep a -> b
11:34:05 <|randomwords|> jmcarthur_work: Yes
11:34:12 <jethr0> thank you, morrow
11:34:21 <mmorrow> |randomwords|: it seems to work with ghci 6.10.1
11:34:22 <|randomwords|> 6.10.4
11:34:53 <mmorrow> ghci +RTS -N -RTS;    then forkIO a bunch of threads that do whatever, and my cpu's were pinned at 100%
11:34:59 <jmcarthur_work> |randomwords|, i thought it was:   ./myApp ==> 1 thread      ./myApp +RTS -N ==> number of cores on machine      ./myApp +RTS -Nx ==> explicitly x
11:35:26 <EvilTerran> can you put RTS options in a {-# OPTIONS ... #-}?
11:35:28 <Saizan_> mmorrow: 100% is usually one thread, no?
11:35:35 <jmcarthur_work> EvilTerran, nope :(
11:35:38 <mmorrow> Saizan_: each core was at 100%
11:35:42 <EvilTerran> aww
11:35:53 <mmorrow> Saizan_: so right, 200% :)
11:36:15 <Saizan_> calling numCapabilities would be a more direct test, i think :)
11:36:18 <|randomwords|> Well -N is giving me -N1 in 6.10.4
11:36:39 <mmorrow> Saizan_: he wants to know what to set -Nx to in the first place though
11:36:41 <jmcarthur_work> @hoogle numCapabilities
11:36:41 <lambdabot> No results found
11:37:14 <mmorrow> Saizan_: numCapabilities just tells you what x in -Nx is
11:38:01 <mmorrow> |randomwords|: you're right
11:38:09 <mmorrow> jmcarthur_work: -N means -N1
11:38:24 <jmcarthur_work> huh, yeah
11:38:27 <jmcarthur_work> i just tested too
11:38:37 <mmorrow> my test was flawed before
11:38:40 <jmcarthur_work> i could have sworn i saw in a changelog that it meant number of cores
11:38:47 <|randomwords|> jmcarthur_work: It would be a good change
11:42:03 <mmorrow> (i was at 200% on account of this other proc on another workspace that i forgot was alive :)
11:42:26 <jmcarthur_work> maybe System.Posix.Process.executeFile can be used to make a program re-execute itself with the proper RTS arguments?
11:42:37 <jmcarthur_work> after probing the system appropriately
11:42:41 <jmcarthur_work> that might make a good library
11:42:57 <mmorrow> you can also supply your own C main that
11:43:08 <jmcarthur_work> yeah but that requires C ;)
11:43:14 <mmorrow> figures it out and starts haskell main with the correct -Mx
11:43:34 <mauke> jmcarthur_work: not really, because you can't get the name of your program
11:43:44 <jmcarthur_work> wha-?
11:44:01 <doublethink_work> ghc 6.12 will automatically determine the number of cores if you just pass -N
11:44:15 <doublethink_work> (i wrote the patch for supporting that on OS X :)
11:44:48 <jmcarthur_work> doublethink_work, yay!
11:44:52 <doublethink_work> with that, you can use ghc's runtime hooks to bake RTS options into your program, so you'll just need to bake in "-N" and link with -threaded
11:45:01 <doublethink_work> and your app should automagically scale with no other tweaks :)
11:45:14 <mmorrow> GHC.Environment.getFullArgs
11:45:17 <jmcarthur_work> mauke, System.Environment.getProgName ?
11:45:22 <mauke> jmcarthur_work: broken
11:46:14 <mmorrow> ghci> getProgName
11:46:14 <mmorrow> "<interactive>"
11:46:14 <mauke> mmorrow: I bet that doesn't include argv[0]
11:46:29 <mmorrow> mauke: it doesn't, i was responding to doublethink_work
11:46:31 <ksf> I think c2hs lacks a vital feature.
11:46:33 <mauke> otherwise it would be too useful
11:46:37 <mmorrow> heh
11:46:46 <ksf> namely, custom code generators.
11:47:19 <|randomwords|> So when is ghc 6.12 coming out?
11:47:23 <ksf> I'm about to wield TH to pase a c2hs enum declaration.
11:48:13 <doublethink_work> |randomwords|: RC is on sept. 14th i think
11:48:27 <doublethink_work> 6.12.1 (final) will probably be released a little while after
11:48:44 * doublethink_work is wondering about the new backend based on hoopl, mainly...
11:49:08 <mauke> wtf Igloo
11:51:52 <ksf> there's no way to have a class method only be visible inside other class functions, is there?
11:53:35 <astrolabe> ksf: put the class in a module?
11:54:05 <ksf> uhm... I need to define instances outside of said module.
11:54:27 <ksf> ...but clients don't need the function, and it's non-total by design.
11:55:29 <ray> if that's the case, why does it need to be a method? if you're only using it to define other methods
11:55:40 <astrolabe> ksf: You can export the class and the methods you want outside of it.
11:55:49 <roconnor> ugh, why is GHCi complaining about ambiguous type variables when GHC seems happy.
11:56:17 <roconnor> strange
11:56:18 <ksf> and still define instances?
11:56:49 <astrolabe> ksf: When you define a Show, you don't hack into the prelude.
11:57:09 <ray> yeah, but showsPrec or whatever is visible..
11:57:29 <ksf> well, but Show's show is exported.
11:57:39 <astrolabe> Ah.  My memory is bad.  Perhaps there's no way to hide methods.
11:57:56 <ray> i don't think there's a way either
11:58:07 <astrolabe> Maybe wrap it in another class?
11:58:07 <ray> could be wrong, i'm not that familiar with exporting and hiding
11:58:13 <adh0c> why would you need to hide them?
11:58:21 <ray> why do you ever need to hide anything?
11:58:29 <astrolabe> hiding is good
11:58:43 <adh0c> not really
11:58:52 <ray> if you're a programmer who uses hiding, hiding typeclass methods makes perfect sense
11:58:53 <adh0c> abstracting is good in most cases
11:59:03 <astrolabe> It means that at a later date, you can change the implementation without worrying about what code uses the interface.
11:59:43 <adh0c> you're thinking about abstraction
11:59:50 <ksf> I've implemented BitSet Enum BitsNewType | BitsNewType -> Enum, and I've got flagEnum :: Bits -> Enum as well as toFlags :: Bits -> [Enum]
11:59:55 <astrolabe> adh0c: yes
12:00:03 <ksf> ...the latter uses the former, and is the client-side function.
12:00:15 <ksf> but instances define flagEnum, which is vastly non-total
12:01:11 <ksf> *and the latter is the
12:03:23 <jmcarthur_work> sure you can hide them...
12:04:05 <jmcarthur_work> oh just type class functions, not the whole type class? i dunno. n/m
12:04:32 <frostegard> hello, #haskell.. is there any obvious way to store values of different types inside of a map? of course i could define a datatype with constructors such as WrapString, WrapInt etc, but this seems like a think there should be a library/convention for
12:04:44 <ksf> Either?
12:04:48 <ksf> Typable?
12:05:06 <ksf> ...you don't want to use Typeable if you can avoid it, though.
12:05:15 <ksf> haskell degenerates into a lazy lisp, then.
12:05:51 <mauke> Dynamic!
12:06:01 <jmcarthur_work> frostegard, how would your ideal work?
12:06:05 <ksf> shhh, let him use assembly!
12:06:30 <ksf> maybe what you really want is more than one map...
12:07:09 <ksf> or a custom record with Maybe String and Maybe Int inside.
12:07:20 <ksf> there's a thousand possibilities.
12:08:15 <wdonnelly> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists might help
12:08:21 <jmcarthur_work> frostegard, let's assume we have a type agnostic map called Map' ... what should go in place of the ??? in lookup :: Map v -> v -> ???
12:08:46 <wdonnelly> in the case where you want different types that are all members of a single typeclass
12:08:49 <jmcarthur_work> uhh.... s/v/k/
12:09:26 <frostegard> i'm building a small library for cgi session persistance, indending to hide the magic behind one function for retrieval, one for setting of values.
12:09:38 <frostegard> and i hoped this would solve itself magically
12:09:51 <jmcarthur_work> so the session stored data of arbitrary type?
12:09:56 <jmcarthur_work> *stores
12:09:57 <frostegard> ideally, yes
12:10:12 <frostegard> but probably string, integer, double and bytestring would be good enough
12:10:46 <jmcarthur_work> frostegard, taking happstack for inspiration, i think the ideal would be that the session is one userdefined data type that stores records, not an API defined map from keys to values
12:10:54 <jmcarthur_work> i think that would be what you are looking for
12:11:21 <jmcarthur_work> well, happstack-state, anyway
12:11:36 <jmcarthur_work> you could have Map SessionID SessionState
12:12:08 <jmcarthur_work> i suspect that right now you expect to have type SessionState = Map String ???
12:12:16 <jmcarthur_work> but you could leave that up to the client code instead
12:12:18 <frostegard> yes, correct
12:12:53 <frostegard> that's a good idea, i'll try it out. thanks :)
12:12:56 <jmcarthur_work> np
12:16:12 <roconnor> quickcheck++
12:17:16 <bos> huh, hpaste gets caching headers wrong.
12:17:41 <bos> revise a paste, and it doesn't force the page to be reloaded.
12:17:51 <bos> autocorrelation and autocovariance: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8787#a8792
12:18:31 <mmorrow> bos: yeah, i've noticed that, sometimes you need to reload manually
12:18:59 <mmorrow> bos: how would you fix that/what is causing that?
12:19:53 <roconnor> ugh, ghci -fmonomorphism-restriction doesn't seem to override my no-monomorphism-restriction in my .ghci file :(
12:20:02 <bos> mmorrow: i haven't looked at the headers the server is setting.
12:20:42 <sshc> how do I enable the XParallellListComp extension in ghci?
12:20:55 <ksf> @hoogle a -> Dec
12:20:55 <lambdabot> Prelude id :: a -> a
12:20:55 <lambdabot> Data.Function id :: a -> a
12:20:55 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:21:12 <ksf> @hoogle a -> Language.TH.Syntax.Dec
12:21:12 <lambdabot> Parse error:
12:21:13 <lambdabot>   --count=20 "a -> Language.TH.Syntax.Dec"
12:21:13 <lambdabot>                           ^
12:21:16 <jmcarthur_work> :set -XParallellListComp, i think
12:21:31 <jmcarthur_work> i never remember such things
12:21:38 <ksf> :t FunD
12:21:39 <lambdabot> Not in scope: data constructor `FunD'
12:22:16 <bos> mmorrow: i see the client setting an if-modified-since header, so maybe sometimes the server is messing up?
12:22:26 <sshc> <interactive>:1:0: Illegal parallel list comprehension: use -XParallelListComp
12:23:24 <mmorrow> bos: hmm, ok. i'm not quite sure where to look for this, but that gives me a google search starting point
12:23:58 <bos> mmorrow: last-modified (server side) and if-modified-since (client side) are your friends
12:25:22 <ksf> I wanna take a data decl and an instance decl, pass though the data decl verbatim, and seriously mess with the instance decl
12:25:28 <ksf> ...how do I do that?
12:25:35 <ksf> all I try gives me parse errors.
12:27:17 <ksf> sshc, pass -XParallelListComp, or use {-# LANGUAGE ParallelListComp #-} as the first line of your file.
12:38:05 <jpcooper> is it possible to make GHC print each function call?
12:38:52 <burp> any comments about jhc? ;)
12:39:00 <ksf> debug.trace?
12:39:19 <ksf> there are tracers, too, but they won't give you the same results as an optimized program.
12:39:26 <Baughn> Debug.Trace.trace makes ghc print each /thunk reduction/
12:39:46 <jpcooper> thanks
12:39:48 <ksf> isn't that the same as a function call?
12:39:52 <Baughn> ..there are no function calls in haskell, as such; trace exposes implementation internals
12:40:30 <Baughn> ksf: Not.. necessarily. In practice function calls may always be thunk reductions, but in theory GHC might do otherwise
12:41:07 <ksf> well, thunk reduction as in "stuff gets done", not "a thunk gets nudged"
12:41:20 <ksf> ...also strictified traces get output.
12:41:40 <Baughn> They get de-strictified, don't you think?
12:42:05 <jpcooper> ksf, how would I optimise my programme?
12:42:07 <ksf> dunno.
12:42:10 <Baughn> trace operates via unsafePerformIO, which specifically works on dethunkings.. not once per value read, or anything
12:42:17 * Baughn has made a close study of it
12:42:26 <ksf> jpcooper, a) choose the right data structures with the right big-O
12:42:41 <Baughn> Anyhow, using unsafePerformIO (or trace, thus) /adds a new thunk/
12:42:42 <ksf> b) choose the right data structures with the right big-O
12:42:44 <jpcooper> I thought you meant optimise it in a way for debugging
12:42:47 <ksf> c) use -O2
12:42:53 <ksf> d) ...
12:42:55 <ksf> e) profit
12:42:55 <Baughn> d) call into C
12:43:08 <Baughn> f) spend profit towards improving GHC
12:43:10 <roconnor> jeffersonheard: do you use toCIEXYZ?
12:43:35 <ksf> "optimized" as in "ghc runs it"
12:43:48 <mmorrow> burp: it doesn't have a garbage collector
12:43:52 <etpace_> whats the reccomended "logger" for use with mappend and Writer?
12:43:55 <ksf> ...be it compiled or anything, it's going to behave differently from a tracer.
12:44:05 <burp> mmorrow: oh, that's a good point to mention
12:44:09 <etpace_> (monad tutorial says to shy away from strings)
12:44:11 <ksf> it's just way too smart.
12:45:08 <ksf> etpace_, [[String]], with head being the latest element?
12:45:19 <ksf> that's fast in appending.
12:45:40 <ksf> if you want fast start-to end traversal without reversing, you've got to use something else.
12:45:50 <mmorrow> burp: it uses the boehm conservative collector, and if your program behaves in such a way that that collector (which is conservative (as opposed to accurate)) is able to work close enough to an accurate collector, you're ok. but it's easy to write programs where boehm craps itself, and when that happens you'll consume all of your memory in seconds
12:46:05 <Baughn> etpace_: Data.Seq's nice, too
12:46:13 <burp> mmorrow: and it doesn't seem to use gmp for Integer?
12:46:37 <mmorrow> burp: that too, i don't think is has arbitrarily-size Integers
12:46:47 <burp> ok, seems so
12:46:49 <jmcarthur_work> etpace_, dlist
12:46:52 <jmcarthur_work> is a good one
12:47:05 <etpace_> ok, thanks
12:49:48 <mmorrow> the annoying part too about boehm is that whether or not your prog will be ok isn't necessarily correlated with anything at the haskell level
12:49:54 <mmorrow> burp: ^
12:50:12 <Baughn> That, and the whole "conservative GCs are slow" bit
12:50:22 <Baughn> They don't know what might be a pointer, so they have to scan /everything/
12:50:42 <Baughn> ..well, it works better on a 64-bit platform, though
12:53:21 <Baughn> mmorrow: Oh, and don't forget that Boehm fails if you obfuscate your pointers.
12:54:55 <mmorrow> Baughn: yeah, but only the rts could do that in the haskell case (which iirc jhc does too)
12:55:15 <Saizan_> obfuscate your pointers?
12:55:34 <mmorrow> there's a commented description of how the "rts" works in the output C file for every jhc-compiled program that explains the strategy
12:55:58 <Baughn> Saizan_: Sure. For example, using the xor trick to swap the values of two pointers..
12:56:00 <mmorrow> Saizan_: like putting tag bits in them, or splitting them up and reconstructing them later
12:56:06 <Baughn> Saizan_: What happens if a GC is triggered in the middle of that? ^-^
12:56:26 <mmorrow> Saizan_: basically mainpulating them in any way so that they're not the literal value you got from malloc
12:56:27 <path[l]_> wtf Baughn whats that smiley
12:56:32 <path[l]_> can you break it down
12:56:37 <path[l]_> with a space
12:56:42 <path[l]_> my client shows some girls face
12:56:50 <Saizan_> i'm not sure how a conservative gc is supposed to detect which bytes are pointers either, tbh
12:56:52 <Deewiant> ^ - ^
12:57:02 <adh0c> weeaboo emoticons
12:57:03 <path[l]_> ah
12:57:06 <path[l]_> ^_^
12:57:08 <path[l]_> haha
12:57:13 <path[l]_> I see a jap girls face
12:57:14 <path[l]_> nice
12:57:28 <dumael> Saizan_: a conservative gc treats anything that looks like it could be a pointer as a pointer. then runs away.
12:57:28 <idnar> heh
12:57:29 <mmorrow> Saizan_: hehe, it linearly scans the stack and tries to deduce which bytes are pointers by their values
12:57:49 <Baughn> Saizan_: If, interprted as a pointer, it points to mapped memory, then it's assumed to be a pointer.
12:57:59 <Baughn> Obviously, a conservative GC cannot move data
12:58:22 <mmorrow> Saizan_: and can miss pointers, and can mistake ints for pointers, ...
12:58:37 <Saizan_> miss too?
12:58:45 <Baughn> If the pointer doesn't look like a pointer
12:58:46 <mmorrow> Saizan_: if you've mangled them
12:59:02 <erikc> 'for encryption'
12:59:03 <Saizan_> ah, right, now it all makes sense :)
12:59:04 <Baughn> ..mind you, mangling pointers brings severe performance penalties on modern x86 CPUs. So don't. :P
12:59:27 <adh0c> flat memory model ftw
12:59:37 <mmorrow> Baughn: ghc "mangles" pointers to increase performance
12:59:47 <mmorrow> Baughn: (the tag bits)
13:00:39 <mmorrow> Baughn: do you mean modifying code?
13:00:45 <arw> Baughn: not really. most common pointer operations are quite fast and even accelerated by cache behaviour which is optimized to do so.
13:00:50 <Baughn> mmorrow: No, I meant mangling pointers
13:01:00 <mmorrow> Baughn: how could that possibly hurt performance?
13:01:45 <arw> Baughn: so the usual kind of pointer arithmetics like p * sizeof(struct...) + offsetof(member) is really quite fast.
13:01:49 <adh0c> aren't most modern cores breaking machine code down into microops which they optimize using partially trade secret algorithms anyway?
13:02:11 <Baughn> mmorrow: IIRC.. the cpu's got extra-long latency on reading pointers, on the theory that you wouldn't change them just before using them anyway, and so it can load those well in advance
13:02:37 <Baughn> mmorrow: TBH, I don't really know how it deals with the case where it /can't/. Possibly the fallback is no worse than you'd expect without that optimization.
13:02:58 <mmorrow> Baughn: that's for code, the instruction cache, pipelining, branch prediction, all that
13:03:01 <Baughn> arw: Oh sure, but that's optimized in microcode anyway
13:03:05 <arw> Baughn: what do you mean by "reading pointers"? memory operands or pointers as data?
13:03:10 <dumael> adh0c: operations are broken down into micro-ops. Intel's core 2 line can fuse test + branch into a single new micro op.
13:03:18 <Baughn> arw: Any indirect memory operations
13:03:48 <arw> Baughn: not true. as long as the operation only affects the cache its quite fast.
13:03:52 <adh0c> dumael, doesn't it also pack as many microops into one clock tick as it can?
13:03:59 <dumael> adh0c: after that they're run through and out-of-order execution engine, which is a restricted form of (possibly static) dataflow.
13:04:02 <Baughn> mmorrow: Hm. You may be right. It'd be nice if they'd explain this properly, so I didn't have to rely on rumor for optimization purposes..
13:04:05 <arw> Baughn: and every decent compiler will make sure to place data accordingly.
13:05:30 <erikc> conservative gc is a bizarre niche, your problem has to require gc, but also the kind of high perf you'll only get in an unsafe language, and the customers for such a program need to tolerate that there is no guarantee on memory reclamation
13:05:45 <erikc> the intersection of those constraints seems small
13:05:46 <dumael> adh0c: that's superscalar exection, where it tries to dispatch multiple instructions into multiple function units.
13:06:24 <Baughn> erikc: No, there is another niche.
13:06:26 <mauke> w3m uses boehmgc
13:06:31 <erikc> i suppose most uses of conservative gc arent by choice but by desperation
13:06:39 <Baughn> erikc: "Fixing memory leaks in programs that were written in low-level languages for no good reason"
13:06:43 <arw> Baughn: there are proper explanations of cpu behaviour, at least from intel (not so much from amd i'm afraid).
13:06:51 <Baughn> Eg. I've got boehm-gc running on firefox. >_<
13:06:56 <erikc> Baughn: haha, yes, desperation :)
13:07:04 <mmorrow> Baughn: this is a rather horrifying read: http://support.amd.com/us/Processor_TechDocs/25112.PDF
13:07:05 <erikc> the 'whoa, we've made a huge mistake' reason
13:07:21 <Baughn> erikc: Ha. If only they'd agree that there was a mistake.
13:07:28 <erikc> 'we've made a ten million LOC mistake...oops'
13:07:32 <arw> Baughn: the real problem is that they of course rely on the assembler code, so you need to know what a compiler makes of your high-level code.
13:07:38 <adh0c> dumael, thanks for clearing this up, the first Volume of the Intel manual wasn't as clear on that
13:07:51 <Baughn> erikc: I've seen at least one FF developer complain that the memory leaks in firefox are caused by the javascript GC
13:07:56 <Baughn> Or something
13:08:18 <Baughn> Because, see, a GC can't know when it's safe to free memory; it's not as smart as a human
13:08:27 <adh0c> um
13:08:28 <Baughn> </annoyance mode=off>
13:08:30 <erikc> :)
13:08:48 <erikc> i had a similar thing happen with a large C++/C# app, where everyone thought .NET was leaking the memory
13:08:56 <ksf> I can get a data declaration with reify $ mkName "<name>". How do I get an instance declaration?
13:09:01 <erikc> pulled out the .NET memory profiler...nope, it's all in the unmanaged heap, thank you come again
13:09:01 <badsheepy> having met a lot of humans, i disagree with that 'not as smart' statement :p
13:09:04 <Baughn> Right. Couldn't possibly be their own fault. :P
13:09:18 <mauke> valgrind++
13:09:43 <adh0c> I'm willing to bet some money that GC performs better than human coders in most cases, especially when it comes to generating memory leaks
13:10:03 <dumael> adh0c: most of the info you'll ever need for optimising for intels chips are in "Intel IA64 and IA32 Architecture - Optimization Reference Manual"
13:10:05 <mauke> I don't know, I perform pretty well at generating memory leaks
13:10:20 <dumael> intel have it on their site for free.
13:10:24 <Baughn> dumael: That manual explains what to do, but not why
13:10:27 <adh0c> dumael, thanks
13:10:28 <arw> really depends on the language. c++ makes it really hard to avoid memory leaks in certain situations. thats also why many people welcomed the java gc so much...
13:10:33 <luis> Baughn: well, does FF use reference counting for Javascript? Or is it just for the DOM?
13:10:36 <Baughn> dumael: ..I suppose I should just grin and read it.
13:10:41 <adh0c> dumael, I was just planning to read them in the order they are listed
13:10:45 <dumael> Baughn: yeah.
13:10:47 <Baughn> luis: Oh no, it uses a full-blown copying GC.
13:11:21 <Baughn> luis: ..this helps very little when some modules fail to drop references after use. :P
13:11:25 <luis> Baughn: cool. But I was under the impression that the DOM used some reference counting mechanism, or was that IE?
13:11:44 <Baughn> luis: It may have been using that earlier. I'm thinking of the 3.5 one.
13:11:55 <dumael> adh0c: you only really need to read that one. The others are more for specialized stuff. either OS or compiler work for instructions.
13:11:58 <luis> Ah, I see.
13:12:09 <elliotstern> Is there any way to get something like (map uniqueFactors [0 ..] !!) to be Integer -> Integer?  It seems like !! requires an Int instead of an Integer
13:12:35 <ksf> ...I don't even need the whole declaration, just one of its functions, but I can't figure a way to select the instance
13:12:56 <Baughn> elliotstern: Use genericIndex instead
13:13:03 <elliotstern> Thanks
13:13:05 <adh0c> dumael, but I'm interested in OS interaction too
13:14:52 <dumael> adh0c: ah. Enjoy.
13:15:10 <adh0c> I plan to, assuming I find enough time.
13:16:08 * ksf is going to hack around it.
13:16:32 <dumael> adh0c: I hope you intend to avoid PAE, segmented addressing.
13:17:06 <adh0c> I don't really like skipping pages in books I read
13:17:16 <dsouza> Is there any HTTP module available with tls support? All modules I have found only seems to support HTTP.
13:17:22 <adh0c> I worry that I might have skipped something important
13:18:14 <mmorrow> adh0c: i like starting with the interesting parts, then finding all needed info that's reachable from there
13:18:26 <mmorrow> adh0c: kind of like a copying GC ;)
13:18:37 <dcoutts> dsouza: I expect the curl bindings support https
13:19:13 <adh0c> mmorrow, I don't know, I find most topics in computing interesting, sometimes to the point of not being able to concentrate on anything else until I figured something out
13:19:34 <adh0c> which of course leads to me having around 50 open tabs in FireFox
13:19:38 <mmorrow> surely there're things in a table of context that catch your eye
13:19:52 <dsouza> dcoutts: right. I was only looking for http on hackage and missed curl module. thx
13:19:57 <mmorrow> adh0c: 50 tabs is nothing! ;)
13:20:12 <adh0c> what's your best?
13:21:09 * Baughn once had upwards of seven hundred
13:21:09 <mmorrow> adh0c: i'm not sure, but something like that :) i'm not sure if "restore previous session" is a feature or a curse
13:21:28 <adh0c> Baughn, D:
13:21:53 <adh0c> The best part about procrastination is
13:22:12 <adh0c> s/about/of/
13:22:18 <dumael> adh0c: currently i've got 180~ open.
13:22:24 <mmorrow> yeah, 50 is nothing now that i think about it
13:22:51 <adh0c> I'm just wondering how many of those do you still visit?
13:23:06 <Stinger> 180 tabs?
13:23:13 <adh0c> how many of those 180 you keep just out of sentiment, or worry that you might forget it
13:23:31 <mmorrow> adh0c: you might need one in an hour, but you don't know which
13:23:40 <Stinger> this is what bookmarks are for people
13:23:46 <adh0c> great
13:23:50 <mmorrow> :)
13:23:54 <adh0c> my bookmarks span 6+ screens
13:24:25 <Stinger> they can be ordered into a convenient heirarchical structure :P
13:24:49 <adh0c> yeah, but honestly, who has time for that?
13:24:52 <dumael> Stinger: yes, 180 tabs. Some stuff I regularly look at e.g. slashdot, reddit(s), mail, hackernews, other is stuff i've lloked up.
13:24:53 <ray> when i hear people claiming to have tons of tabs open all the time, my mind just rejects it
13:25:11 <dumael> ^looked up even.
13:25:18 <mmorrow> ray: i also have 9 desktops arranged in a 3x3 grid
13:25:19 <adh0c> outside of people who pin butterflys to boards
13:25:27 <ray> mmorrow: my mind rejects multiple desktops too
13:25:42 <adh0c> what do you mean by "rejects"?
13:25:49 <Stinger> yeah I look at things like that, ... when I'm finished I close it :P
13:25:58 <adh0c> I mean, do you look at a multidesktop environment and don't see the icons?
13:26:17 <adh0c> when someone switches to another desktop, do you see darkness, or peer into forever?
13:26:43 <ray> i mean people say "yeah i use multiple desktops" and i just think "you are such a liar"
13:26:48 <ray> even if i know they're probably not lying
13:26:58 <ray> the concept seems impossible
13:27:06 <dumael> Stinger: If i see something interesting halfway down a page, i'll open it in a new tab. This can lead to exponential tab growth.
13:27:07 <adh0c> that probably classifies as some mental disorder
13:27:14 <adh0c> reverse mythomania?
13:27:20 <mmorrow> ctrl+n to switch to desktop n
13:27:28 <ray> yes, using multiple desktops has to be a mental disorder
13:27:43 <ray> probably something dissociative :)
13:27:59 * mmorrow leaves desktop 9 now
13:28:08 <mauke> s/desktops/windows/
13:28:17 <adh0c> if I really want to screw someone over and I know that person likes to opens up new tabs, I send them to tvtropes
13:28:23 <mauke> haha
13:28:32 <mauke> I do that to myself :-[
13:28:38 <adh0c> one session usually siphons ~5 hours out of your life
13:28:43 <ray> 5 hours, sure
13:28:47 <ray> but never more than 2 tabs
13:28:48 <dumael> adh0c: c2's wikiwikiwiki
13:29:11 <jmcarthur_work> i use 9 desktops too
13:29:17 <jmcarthur_work> heck, xmonad has 9 by default
13:29:27 <adh0c> by the time you get to know why a certain character wears pink aviator glasses in a specific season, you also get to know everything about David Hasselhoff and nuclear missiles
13:29:30 <adh0c> also
13:29:36 <adh0c> Applied Phlebotinum <3
13:30:11 <dumael> jmcarthur_work: during college, I switched from 9 desktops to 12.
13:30:32 <adh0c> now you can multitask while you multitask
13:30:36 <SubStack> once I've filled up all 9 it's time to start closing shit
13:30:47 <tromp> i have 6, but each is dual screen
13:31:00 <dumael> adh0c: my mac cries when I get it to show all windows on all desktops. Mostly due to opera.
13:31:05 <mauke> ONE OF THEM IS FULL OF TERMINALS RUNNING SCREEN
13:31:09 <SubStack> although with xmonad it's easier to fill them up
13:31:21 <SubStack> mauke: only one?
13:31:26 * mauke multiplexes while multiplexing
13:31:42 <ray> running nested screens
13:31:49 <ray> apparently, people do this
13:31:58 <ray> i say apparently because i can't believe they actually do
13:32:04 <Saizan_> sometimes i'd like to flatten the xmonad+screen nesting
13:32:21 <ray> concat
13:32:22 <Saizan_> then i realize i don't have enough digits on this keyboard
13:32:30 <dumael> I can see why, but I find it really awkward to manipulate a particular screen session then.
13:32:31 <byorgey_> yo dawg, we heard you like multitasking so we put a screen in your screen so you can multiplex while you multiplex
13:32:50 <vav> ./rayWorkflow +RTS -N9 -- Error: cannot forkIO
13:32:54 <ray> just use a haskell machine where your multiplexing is lists, then concat them
13:32:56 <adh0c> how exactly did multiplexing suddenly get involved in this?
13:33:11 <leimy> Are TChan's bidirectional
13:33:11 <SubStack> ray: I do that, but rarely
13:33:11 <lambdabot> leimy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:33:11 <leimy> ?
13:33:19 <dumael> Intel®64 and IA-32
13:33:19 <dumael> Architectures
13:33:28 <dumael> whoops,
13:33:35 <adh0c> wha
13:33:42 <SubStack> a screen for ssh on the remote end also running screen is how it usually goes
13:33:52 <dumael> mauke> ONE OF THEM IS FULL OF TERMINALS RUNNING SCREEN > that's how we got on to multiplexing.
13:34:38 <Saizan_> leimy: not really, they are a single queue
13:35:59 <Berengal> What I like to do with TChans is instead of giving them directly to threads, I give them either writeTChan chan or readTChan chan
13:37:02 <SubStack> multimultiplexing
13:37:16 <SubStack> multi = plexing multi
13:37:24 <adh0c> plexing^n
13:37:29 <roconnor> is there a way to label a function in a module as depricated?
13:37:50 <Saizan_> roconnor: there's a pragma
13:38:09 <shepheb> func = undefined -- whoops
13:38:10 <roconnor> pragma sounds good
13:39:11 <elliotstern> So it turns out that trying to memoize the prime factorization of all numbers less than 40 million  is a bad idea
13:40:21 <Saizan_> maybe less so if you don't use a list to store them :)
13:40:45 <elliotstern> There's something else I'm going to try instead, though
13:41:00 <elliotstern> which hopefully won't be a similarly bad idea
13:45:26 * byorgey makes lambda haggis
13:57:46 <elliotstern> apparently it was just as bad an idea
13:58:05 <elliotstern> ]http://projecteuler.net/index.php?section=problems&id=214
13:58:06 <lunabot>  luna: parse error on input `='
13:58:37 <Nereid_> leimy: no
14:01:32 <Nereid_> elliotstern: what if you go backwards? i.e. start at 1, and see which numbers have phi^25(n) = 4
14:01:57 <Nereid_> er phi^25(n) = 1
14:01:57 <Nereid_> lol
14:02:18 <elliotstern> Well, calculating phi(n) is expensive
14:02:21 <djahandarie> @seen Vanadium
14:02:21 <lambdabot> Vanadium is in #gentoo-haskell and #haskell. I last heard Vanadium speak 2h 58m 2s ago.
14:02:28 <Nereid_> no I mean
14:02:33 <Vanadium> djahandarie: I am right here.
14:02:38 <Nereid_> if I give you a natural number n
14:02:41 <djahandarie> !
14:02:47 <Nereid_> can you find all numbers m such that phi(m) = n?
14:03:43 <elliotstern> I'm fairly sure that there's an infinite number of numbers such that phi (foo) = bar
14:03:58 <elliotstern> If I remember my number theory class well enough
14:04:26 <Nereid_> hmmmm
14:04:55 <Nereid_> the page there claims that the 8 chains listed are all the chains of length 4
14:05:15 <Nereid_> then again, things might still blow up exponentially :(
14:05:28 <elliotstern> I might just be misremembering my number theory
14:05:45 <elliotstern> I took the class last winter, so...
14:06:13 <Nereid_> you can't take the formula in http://en.wikipedia.org/wiki/Euler_phi#Computing_Euler.27s_function and use it backwards?
14:07:23 <elliotstern> I suppose
14:08:22 <elliotstern> if you start out with a unique prime factorization, you can calculate phi N for pq, p^2q, p^3q, pq^2, etc. etc.
14:09:00 <elliotstern> I'm not entirely sure what that buys me, however
14:17:33 <duaneb> sup #haskell
14:17:45 * Twey cranes his neck…
14:19:18 <byorgey> sup duaneb
14:19:53 <duaneb> anyone understand why ghc can't find my package installed by cabal? :/
14:20:10 <ksf> can I run an AppE inside the Q monad?
14:20:15 <duaneb> I use -package binary, and it spits out ld: library not found for -lHSbinary-0.5.0.1_p
14:20:16 <poe> duaneb: try --user
14:20:23 <duaneb> poe: ugh.
14:20:28 <duaneb> poe: that's disgusting.
14:20:48 <duaneb> anyway, binary was installed in /usr/local/whatever
14:21:14 <duaneb> hrm
14:21:19 <poe> does --make work?
14:21:24 <duaneb> I have no idea why it's trying to use _p
14:21:33 <duaneb> I don't have a library with the _p ending....
14:21:35 <poe> _p stands for profiling version
14:21:39 <duaneb> ah.
14:21:42 <duaneb> this explains much.
14:21:58 <poe> you can configure cabal to also build profiling version of things, check the conf file
14:22:07 <dcoutts> duaneb: sounds like you're using ghc -prof, but did not install the profiling version of the lib in question
14:22:13 <poe> s/profiling/profiling enabled/
14:22:25 <duaneb> yea, I just figured that out
14:22:30 <duaneb> I disabled profiling and it compiled fine
14:25:45 <Berengal> Is there something like multidimentional trees?
14:26:12 <Berengal> I mean, there is, but is there some theory to them?
14:26:23 <Twey> Rose trees?
14:27:11 <Azstal> Quadtrees and octrees in particular are well-researched
14:27:13 <ksf> quad/octtrees?
14:27:39 <aavogt> @type AppE
14:27:40 <lambdabot> Not in scope: data constructor `AppE'
14:27:48 <aavogt> @type Language.Haskell.TH.AppE
14:27:50 <lambdabot> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp
14:28:09 <aavogt> ksf: what's that have to do with the Q Monad?
14:28:11 <Berengal> The context I was in when I thought of this was CFGs, where there's substitution, concatenation and alternatives
14:28:23 <ksf> well, I want to get it replaced with a LitE.
14:28:43 <ksf> ...and I'm inside the Q monad.
14:28:57 <Berengal> And given a grammar, finding all representable strings is the same as reducing that to concatenation and alternatives only
14:29:32 <ksf> @hoogle AppE -> LitE
14:29:33 <lambdabot> Did you mean: Exp -> Exp /count=20
14:29:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:29:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:30:16 <EvilTerran> ksf, what's the goal of this?
14:30:43 <ksf> I want to get rid of calls to fromInteger
14:31:12 <ksf> oh wait
14:31:16 <Berengal> quadtrees don't look like what I'm thinking of. They're still two-dimensional
14:32:05 <ksf> I actually just wanted to remove a type class constraint that wasn't actually used, anyway...
14:34:00 <zzaz> is it possible to get 0.0608 to show as "0.0608" instead of "6.08e-2"?
14:34:27 <ksf> > ShowFFloat (Just 4)  0.0608
14:34:28 <lambdabot>   Not in scope: data constructor `ShowFFloat'
14:34:31 <ksf> > showFFloat (Just 4)  0.0608
14:34:32 <lambdabot>   Overlapping instances for GHC.Show.Show
14:34:32 <lambdabot>                              (GHC.B...
14:34:40 <ksf> > showFFloat (Just 4)  0.0608 ""
14:34:41 <lambdabot>   "0.0608"
14:35:38 <zzaz> what package is showFFloat in?
14:36:00 <ksf> @hoogle showFFloat
14:36:00 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
14:36:13 <ksf> :t ShowS
14:36:15 <lambdabot> Not in scope: data constructor `ShowS'
14:36:21 <zzaz> Not in scope: 'showFFloat'
14:36:22 <ksf> :k ShowS
14:36:23 <lambdabot> *
14:36:26 <ksf> huh?
14:36:27 <ksf> ah.
14:36:35 <ksf> anyway, it's String -> String
14:36:44 <jmcarthur_work> Berengal, well, there's octtrees. also k-trees
14:37:00 <zzaz> can i do that without using the Numeric library?
14:37:14 <ksf> Numeric comes with the base libraries.
14:37:19 <zzaz> or is that standard?
14:37:22 <Berengal> jmcarthur_work, I don't think the number of children is important. The number of different kinds of branches is
14:37:23 <ksf> and no, you can't do it with the prelude alone.
14:37:23 <zzaz> ok
14:37:40 <ksf> in fact, show uses showFFloat.
14:37:54 <jmcarthur_work> Berengal, k trees basically cycle through each dimension of your data for each level in the tree
14:38:00 <Berengal> jmcarthur_work, for example, grammar can be represented as 'data Symbol = Terminal | Concatenation [Symbol] | Alternative [Symbol]'
14:38:42 <jmcarthur_work> yeah i don't really follow how you plan to use it. i'm just playing association games with multidimensional trees
14:38:48 <ksf> haskell is a spawn of math nerds, so it comes with everything numeric out of the box.
14:39:19 <jmcarthur_work> hmm
14:39:33 <pr_>  what's a math nerd?
14:39:42 <Berengal> jmcarthur_work, unless I'm mistaken, a k-ary tree can be represented as 'data Tree = Leaf | Branch [Tree]'
14:39:43 <ksf> isn't that Monoid and MonadChoice?
14:39:45 <jmcarthur_work> Berengal, yeah i don't know of a formal term for that
14:40:09 <jmcarthur_work> Berengal, that looks more like a rose tree to me
14:40:22 <Berengal> s/a k-ary/any k-ary/
14:40:28 <jmcarthur_work> Berengal, oh i mean kd-tree http://en.wikipedia.org/wiki/Kd-tree
14:40:31 <jmcarthur_work> not k tree
14:40:48 <jmcarthur_work> it's not what you're after though
14:40:48 <ksf> you usally write a quadtree as data Tree = Leaf | Branch Tree Tree
14:41:39 <ksf> ...alternating x and y each time you recurse.
14:42:32 <jmcarthur_work> you are after tree of the form (assuming rose tree, not binary tree or something): data Tree = Leaf | BranchA [Tree] | BranchB [Tree] | BranchC [Tree]
14:42:33 <jmcarthur_work> right?
14:42:43 <Berengal> Right
14:43:28 <jmcarthur_work> actually, leaf is silly there
14:43:34 <ksf> and, most importantly, Leafs contain some positional information, and are thus faster accessible the less leafs there are in the branches bounding box.
14:43:42 <Berengal> Values have zero dimentions, lists have one, (regular) trees have two...
14:43:55 <jmcarthur_work> err
14:44:03 <jmcarthur_work> binary trees, you mean?
14:44:12 <jmcarthur_work> you aren't just looking for ternary and up, are you?
14:44:24 <Berengal> I'm looking for generaleties
14:44:58 <Berengal> And I'm not quite sure what I'm talking about either
14:45:29 <jmcarthur_work> data Tree (d :: Nat) = Tree (Vector d Tree) | Leaf   ?
14:45:37 <jmcarthur_work> not real haskell of course
14:46:31 <doublethink_work> @hackage she
14:46:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
14:46:35 <jmcarthur_work> :)
14:46:42 <doublethink_work> ^^ will allow you to write something eerily similar ;)
14:46:46 <johh1> In trees you can go up down and switch between the leafs?
14:46:57 <jmcarthur_work> doublethink_work, yeah, she is pretty nice
14:47:09 <Berengal> Trees have depth and width
14:47:13 <copumpkin> type errors are rather hard to interpret though
14:47:21 <Berengal> :/ thinking is hard
14:47:28 <doublethink_work> let's go shopping?
14:47:29 <jmcarthur_work> johh1, what do you mean? like a zipper?
14:47:39 * doublethink_work </barbie>
14:48:11 <johh1> i meant the depth and the with, which makes trees 2 dimensional
14:48:41 <Berengal> Squashing a tree's depth is simple, just traverse it and gather stuff into a list. Squashing the width I don't really know how to do
14:48:58 <Berengal> With grammars I know how to remove any of the dimensions, but that's because they have additional semantics
14:49:11 <jmcarthur_work> i'm still a little lost on what you want
14:49:28 <johh1> a 3 dimensional tree would allow bending a 2 dimensional tree in it and creating "wormholes" i guess
14:49:30 <Berengal> So am I :P
14:50:06 <jmcarthur_work> johh1, sounds like it's not a tree but just a directed graph
14:50:38 <Berengal> I was writing this simple program to show someone how you could use nondeterminism to find all the strings in a grammar when I realized only one of the symbols had nonterministric semantics
14:51:35 <Berengal> Terminals are easy enough, just replace them with the string they represent
14:52:13 <Berengal> Alternatives are easily expressed with the list monad. Choose one symbol, recurse
14:52:55 <Berengal> Concatenations is just mapping the reduction function on every symbol and concatenate the result (nondeterministically to preserve alternatives)
14:53:27 <Berengal> Meh. I can't make sense of this
14:53:43 * Berengal goes shopping
14:59:26 <yrlnry> Suppose I have type class Foo a b, and I want to say that (Foo a) is a Functor but only if b is a Monoid.
14:59:50 <yrlnry> Actually, that doesn't really seem to make sense.  But I'm not sure what question I want to ask.
14:59:54 <Warrigal> Is there a mathematical term for the sort of type that ADTs in Haskell can produce?
14:59:56 <Berengal> yrlnry, can't be done. Vote for context synonyms
15:00:08 <yrlnry> For example, ((,) a) is a functor whenever b is a monoid in ((,) a b).
15:00:10 <Warrigal> Maybe I should just call them ADTs.
15:00:26 <yrlnry> Berengal:  So it does make sense, but it's not expressible in Haskell?
15:00:28 <Berengal> ((,) a) is always a functor
15:00:38 <sjanssen> yrlnry: "Foo a" doesn't make sense, it isn't a type
15:00:42 <Azstal> @instances Applicative
15:00:42 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
15:01:12 <yrlnry> Yes, I have the wrong example.
15:01:20 <sclv__> yrlnry: you actually can do what you want, I think.
15:01:25 <yrlnry> ((,)a ) is an Applicative if b is a monoid.
15:01:28 <Azstal> anyway, it's applicative that has Monoid w => ((,) w), but w is the first parameter
15:01:37 <Warrigal> Is it standard to say that the topology of an ADT is that whereby a set of values is closed iff it is always possible to determine whether a value is in the set or not by looking at finitely many elements?
15:01:40 <sjanssen> yrlnry: if 'a' is a Monoid, you mean?
15:01:50 <yrlnry> I'm not sure what I mean.
15:01:57 <yrlnry> Yeah, maybe that is what I mean.
15:02:01 <sclv__> oh, wait, no you can't. you can restrict on a, but not on b.
15:02:04 <hackagebot> colorize-haskell 1.0.0 - Highligt Haskell source (IavorDiatchki)
15:02:07 <sjanssen> yrlnry: instance Monoid a => Applicative ((,) a) -- this is Haskell '98
15:02:12 <yrlnry> Monoid w => Applicative ((,) w).
15:02:22 <sclv__> right, that just works.
15:02:50 <yrlnry> Okay, I think that was where I was confusing myself.
15:02:53 <yrlnry> Thanks.
15:03:00 <copumpkin> why must it be a monoid?
15:03:08 <sjanssen> copumpkin: try to write pure
15:03:18 <copumpkin> ah, fair enough
15:03:23 <sjanssen> you've gotta come up with an 'a' from somewhere
15:03:30 <copumpkin> seems like it shouldn't have to be monoid
15:03:44 <copumpkin> "UnitalMagma" ?
15:03:45 <copumpkin> :P
15:03:48 <sclv__> it does need a zero though.
15:03:51 <Warrigal> That's kind of the Cantor set topology, I guess.
15:04:13 <sjanssen> copumpkin: you also want mappend to combine two 'a', that's the Writer Applicative/Monad
15:04:45 <copumpkin> hrm
15:04:47 <Berengal> sjanssen, could've been state...
15:04:58 <sjanssen> join (w, (x, y)) = (w `mappend` x, y)
15:04:59 <Berengal> Well, almost
15:05:01 <copumpkin> true
15:05:11 <sclv__> ((,) Maybe w) will always work tho.
15:05:31 <Berengal> Maybe is a monoid, except you need one of the newtypes
15:05:41 <sjanssen> sclv__: or ((,) (GetFirst w)) -- just a Maybe newtype :)
15:06:16 <yrlnry> Now I want to say: instance Pointed (MyAnnotated a) => Applicative (MyAnnotated a) where...
15:07:02 <Berengal> yrlnry, nothing stopping you
15:07:12 <Berengal> (Except multiple definitions of 'pure')
15:07:16 <sclv__> yrlnry: that should really be in the definition of Applicative to begin with though...
15:07:18 <yrlnry> " Non type-variable argument   in the constraint: Pointed (MyAnnotated a)"
15:07:41 <yrlnry> sclv__:  I separated Pointed (which supplies pure) and Applicative (which supplies <*>)
15:07:44 <Berengal> What was that? FlexibleContexts?
15:07:55 <yrlnry> What was what?
15:08:05 <Berengal> The extention needed to write that
15:08:13 <yrlnry> So it says.
15:08:42 <Berengal> I can never remember which extention does want. Usually when I need one of them I end up needing most of them pretty fast
15:08:52 <Berengal> s/want/what/
15:09:23 <sjanssen> yrlnry: I always turn on FlexibleInstances and FlexibleContexts when I get type class error messages
15:09:35 <yrlnry> Thanks.
15:09:36 <sjanssen> both are innocent little extensions
15:09:37 <yrlnry> Must run.
15:17:30 <luis> Hello. What's a better way to represent the fibonacci sequence? Here's how I'm doing it right now. fib = 1 : 2 : fib' 1 2 where fib' x y = z : fib' y z where z = x+y
15:18:06 <johh1> berengal:I guess, graphs are in 2d, what lists are in 1d. rose trees are a special case of graphs. The edges in graphs are only 1 dimensional, which means you have to add information to the edges to get something like a graph in 3d, which cannot be flattened out into 2d without losing information
15:18:12 <poe> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:18:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:18:14 <burp> luis: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
15:18:22 <pr> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:18:24 <opdolio> > fix $ (0:) . scanl (+) 1
15:18:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:18:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:18:29 <pr> aww, too late
15:18:36 <luis> thanks
15:18:41 <endojelly> I like the scanl one best
15:19:35 <luis> how bad is my version in terms of haskelness?
15:19:56 <dsouza> @info fix
15:19:57 <lambdabot> fix
15:20:03 <dsouza> @type fix
15:20:04 <lambdabot> forall a. (a -> a) -> a
15:20:22 <endojelly> pr, your version only works because of lazyness, right?
15:20:24 <Stinger> you probably want
15:20:25 <dsouza> what fix does?
15:20:27 <Stinger> @src fix
15:20:27 <lambdabot> fix f = let x = f x in x
15:20:43 <dsouza> Stinger: yes, thx :-)
15:21:00 <c_wraith> both versions of fibs only work because of lazyness.  It's an infinite list, and all.
15:21:10 <c_wraith> well.  non-strictness
15:21:34 <skorpan> is there a difference between non-strictness and laziness?
15:22:02 <c_wraith> yes.  lazyness is one way to implement non-strictness
15:22:04 <c_wraith> But there are others
15:22:06 <endojelly> skorpan, lazyness works with thunks and stuff
15:22:24 <Nereid_> what's the difference between "fix f = let x = f x in x" and "fix f = f (fix f)" ?
15:22:47 <pr> both represent the y-combinator i guess
15:22:50 <Nereid_> just an efficiency thing?
15:22:58 <doublethink_work> AFAIK, it has something to do with sharing - they are equivalent in functionality (and I prefer the latter)
15:23:07 <Cale> Nereid_: Yes, efficiency is the only difference
15:23:14 <doublethink_work> however, if you use vacuum and look at both expressions, they're the same from what vacuum says :/
15:23:18 <Cale> The first one is more efficient
15:23:28 <Stinger> whys that?
15:23:31 <Berengal> johh1, I don't think you can flatten any structure without losing information in general
15:23:38 <Cale> Consider something like fix (1:)
15:23:45 <Cale> The first one will produce:
15:23:50 <Cale> let x = (1:) x in x
15:24:07 <Cale> which will allocate just one cons cell in the end, that will refer to itself
15:24:08 <endojelly> > fix (1:)
15:24:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:24:23 <Cale> The second will produce  (1:) (fix (1:))
15:24:44 <Cale> a cons cell whose tail is another expression, which will allocate yet another cons cell, and so on
15:25:21 <Nereid_> so the second one will use memory linear in the length of the list being used?
15:25:25 <endojelly> > fix ((1:) . tail)
15:25:30 <lambdabot>   mueval-core: Prelude.read: no parse
15:25:30 <lambdabot>  mueval: ExitFailure 1
15:25:38 <Cale> Nereid_: well, provided that no garbage collection happens
15:25:51 <Cale> Nereid_: it will do allocation linear in the length of the portion used, anyway
15:26:00 <Nereid_> so when we use the second one we rely on the gc then
15:26:06 <Cale> yeah
15:26:07 <endojelly> > fix ("a" ++)
15:26:08 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
15:26:22 <olsner> > fix (++ "a")
15:26:28 <lambdabot>   mueval-core: Prelude.read: no parse
15:26:28 <lambdabot>  mueval: ExitFailure 1
15:26:38 <Cale> But the definition of fix which is in the libraries is the let version.
15:26:44 <olsner> eh, "no parse"?
15:26:49 <Nereid_> olsner: didn't produce output
15:26:51 <Cale> and you should probably stick with that one if you have a choice
15:26:57 <endojelly> > fix (\x -> show (length x) ++ x)
15:27:02 <lambdabot>   mueval-core: Prelude.read: no parse
15:27:02 <lambdabot>  mueval: ExitFailure 1
15:27:04 <Nereid_> lol
15:27:05 <endojelly> > fix (\x -> show (length x) ++ x)
15:27:09 <lambdabot>   mueval-core: Prelude.read: no parse
15:27:10 <lambdabot>  mueval: ExitFailure 1
15:27:19 <dm`> So what is it about the let that makes the first definition behave differently?
15:27:36 <endojelly> > fix (\x -> x ++ show (length x))
15:27:41 <lambdabot>   mueval-core: Prelude.read: no parse
15:27:41 <lambdabot>  mueval: ExitFailure 1
15:27:42 <olsner> when using fix you usually want to use sharing to "tie the knot" rather than keep tying an infinite knot, so to speak
15:28:10 <olsner> the second fix definition will never introduce any sharing, I think
15:28:21 <Cale> dm`: let allows us to recursively refer to values in memory which already exist, which at a low level turn into circular structures with pointers
15:28:34 <dm`> I always thought of fix f as just the limit of f(f(f(f(f(f(...f(undefined)))))))
15:28:42 <olsner> (otoh, I believe the compiler *is* free to rewrite one into the other since they're guaranteed (?) to produce the same value)
15:28:49 <Berengal> dm`, it is, isn't it?
15:29:05 <olsner> it's f's all the way down though :)
15:29:06 <dm`> Oh, I see.  So the point being it allocates the cell for the x at the time it sees "let x = ..."
15:29:08 <Cale> dm`: Of course, the result of both versions of fix is the same. The difference is a performance/memory issue.
15:29:12 <johh1> berengal: i guess trivial ones can, like a tree where every node has only one subnode
15:29:14 <olsner> (i.e. no undefined)
15:29:15 <Cale> dm`: right.
15:29:40 <Nereid_> olsner: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
15:30:37 <Berengal> johh1, that's not general enough. Some structures can obivously be flattened, depending on their actual structure and what they're being reduced to and whatnot. foldr (:) [] is a trivial example
15:30:49 <dm`> So the point is that function application never creates a thunk, while let and type constructors do?  Is there a writeup somewhere that would give me a more intuitive feel for when and with which language constructs laziness kicks in?
15:31:55 <Berengal> dm`, function application definitely creates a thunk.
15:32:10 <Berengal> dm`, what you want is to refer to the /same/ thunk more than once
15:32:24 <dm`> Then why is f (fix f) evaluated immediately?  Or what about it is less efficient?
15:32:29 <Berengal> Which is done by giving it a name. This is also the rule of thumb: 1 name = 1 thunk
15:32:45 <dm`> Oh, that makes sense.
15:32:59 <Cale> My rough mental model is that 'let' is the only way that things get put on the heap, and 'case' is the only thing responsible for making use of the stack.
15:33:22 <dm`> Although presumably it can't be that simple if variables get bound in to functions, as with a where clause that refers to the outer function's arguments.
15:33:24 <Berengal> Taking into account alpha conversion, of course
15:33:31 <Cale> Other than that, expression evaluation is done by transforming an expression graph successively using rules.
15:34:37 <Cale> When you evaluate the function application f (g x), you replace the expression with the body of the function f, and set each occurrence of f's parameter in the body to point at the expression g x
15:35:25 <Berengal> Cale, let, where, lambdas, case-patterns... basically everywhere you can fit a pattern you can create a thunk
15:35:45 <dm`> So the point about let being used for the heap makes sense.  Not sure I see the point about case.  Doesn't any non-tail recursion use the stack?  And does a case statement always use the stack, even if it's just to disambiguate Nothing from Just _?
15:35:47 <Cale> Well, 'let' and 'where' are the same thing, lambda and case are not
15:36:17 <johh1> Berengal: data  ThreeDTree a = Node {rootLabel :: a
15:36:17 <johh1> subForest :: Forest a}
15:36:18 <johh1> type Forest a = Tree (ThreeDTree a)
15:36:33 <Cale> case (and well, I/O) is the thing which at some level drives all evaluation
15:36:50 <Cale> The reason that you evaluate an expression is that you're trying to pattern match on it.
15:37:18 <Berengal> Yes, but when you get to a name, evaluation stops
15:37:22 <Cale> and so when you hit a case expression, and none of the patterns immediately match
15:37:52 <Cale> then the pattern match gets put on the stack, and you start evaluating the scrutinee of the case expression
15:38:34 <Cale> For simplicity, you can always imagine that patterns always match on exactly one constructor at a time, since the compiler will translate it so they do anyway (using nested cases)
15:39:27 <Nereid_> scrutinee - there's a new word :-)
15:40:31 <Berengal> I usually think more in terms of dependencies anyway...
15:40:35 <dm`> So that's why you need ~(a:b) in a case expression, but not a let expression (e.g., "let (a:b) = undefined in 0" is a legal way to say 0, but you have to say "case undefined of ~(a:b) -> 0").
15:41:21 <Nereid_> same for "(\ ~(a:b) -> 0) undefined" I guess
15:41:23 <Cale> So, in my mind, you have three components in memory: the stack, which contains all the case expressions which are waiting to pattern match in the future of the program, the heap, which consists of all let-bound variables, and the currently evaluating expression, which is some graph that is being transformed according to function definitions
15:41:47 <olsner> Berengal: pattern matching is the operation that introduces dependencies, so I think it's kind of the same thing
15:42:14 <Cale> dm`: Well, inside a let, patterns automatically have ~ tacked on to the beginning of them
15:42:21 <Berengal> olsner, not all pattern matches are obivous though. if then else, (==), (+)...
15:42:41 <Cale> This preserves the view that let expressions do not cause any evaluation to occur, only allocation.
15:42:58 <dm`> Berengal`: Can you explain how those non-obvious pattern matches are pattern matches?
15:42:59 <Nereid_> why would someone ever use something "case undefined of ~(a:b) -> 0" instead of "let (a:b) = undefined in 0" ?
15:43:01 <Nereid_> something like*
15:43:04 <Cale> Though, the bang patterns extension screws that up.
15:43:34 <Berengal> > let !(a, b) = undefined in 0
15:43:35 <lambdabot>   * Exception: Prelude.undefined
15:43:39 <Cale> (let !(x:xs) = ... in ...) is translated into a case expression
15:43:40 <Berengal> > let (!a, b) = undefined in 0
15:43:42 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
15:43:53 <copumpkin> > let (a, b) = undefined in 0
15:43:55 <lambdabot>   0
15:44:01 <olsner> > let x = (let !(a,b) = undefined in 0) in 1
15:44:03 <lambdabot>   1
15:44:06 <Phyx-> the aveage amount of users in #haskell is about ~500
15:44:09 <Cale> The manner in which bang patterns are translated is made a whole lot more complicated by that.
15:44:18 <Phyx-> yet, I always see only the same people talking
15:44:21 <Cale> Phyx-: higher than that...
15:44:33 <Berengal> ~600
15:44:40 <aavogt> @users
15:44:41 <lambdabot> Maximum users seen in #haskell: 658, currently: 581 (88.3%), active: 23 (4.0%)
15:44:47 <Phyx-> actual number isn't part of my point :P
15:44:47 <Stinger> the rest of us just idle
15:44:48 <Cale> Between 500 and 600, toward the high end, I would say.
15:44:55 <Cale> (on average)
15:45:04 <Phyx-> Stinger: lol
15:45:11 <Berengal> It used to be >600 a couple of months ago
15:45:27 * benmachine idles
15:45:27 <Cale> yeah, for a while it was consistently >700
15:45:30 <Phyx-> prolly will be again once classes start up
15:45:58 * Berengal has never seen it at 700
15:45:59 <Cale> (lambdabot has forgotten though)
15:46:06 <olsner> dm`: those non-obvious pattern matches are just functions that pattern match or syntactic sugar for pattern matching or case expressions
15:46:10 <Cale> It wasn't for very long...
15:46:27 <Cale> When the channel gets too many active users, it becomes more difficult to use.
15:46:40 <Phyx-> true
15:46:49 <Phyx-> i was just wondering what the rest did
15:46:57 <Baughn> We idle.
15:46:59 <olsner> dm`: e.g. if/then/else is just (case a of True -> b; False -> c)
15:47:12 <Berengal> I must admit I spent weeks just idling, aksing perhaps three questions in total before I joined the chat proper
15:47:17 <pragma_> Too... many... people... talking.  Duh, my... brain... too... slow.
15:47:19 <Phyx-> Baughn: lies, you talk :P
15:47:28 <Cale> A lot of people might be reading. I know that when I first came here when I was learning Haskell, I said almost nothing for the first couple months.
15:47:48 <Phyx-> Berengal: my pattern is, ask a question, is a get an answer, go to work, if not, make random idle chat
15:47:50 <Baughn> pragma_: Hey, what are /you/ doing here?
15:47:59 <dm`> Simple question on a different topic.  Is there any generic way to do logical right shifts?  I.e., to have a "lshiftR :: (Bits a) => a -> Int -> a" such that "lshiftR (complement 0) 2" works for signed as well as unsigned types?
15:48:07 <jmelesky> i keep the channel open in the background, occasionally ask, and occasionally answer questions
15:48:18 <Baughn> dm`: The Data.Bits stuff?
15:48:25 <Baughn> Oh. Er..
15:48:32 <benmachine> I'm not sure I learn anything in listening I just enjoy watching clever people be clever at each other
15:48:34 <dm`> shirtR is arithmetic shift for signed types.
15:48:50 <Warrigal> Someone in here once mentioned a language kind of similar to Haskell, in which types were topological spaces and all functions were continuous. Anyone know what language I'm thinking of?
15:48:58 <Berengal> > shiftL 16 1 :: Int
15:48:59 <lambdabot>   32
15:49:02 <dm`> s/shirt/shift.  So I don't see anything in Data.Bits that allows me to do this.
15:49:03 <pragma_> Baughn: I started to learn Haskell once.  But I don't think it's for me.  After a while, it starts to look like gibberish to me.
15:49:08 <olsner> dm`: (+) is a little bit trickier... for one, there's an instance of Num for Int, so you have something like (I# x) + (I# y) = x +# y, which will implicitly force x and y, I think because they're unboxed in the definition of Int
15:49:11 <Cale> Warrigal: That sounds like Haskell.
15:49:12 <Berengal> > shiftL 1 32 :: Int
15:49:14 <lambdabot>   4294967296
15:49:18 <Berengal> > shiftL 1 33 :: Int
15:49:20 <lambdabot>   8589934592
15:49:27 <Baughn> pragma_: Now, now. Don't give up yet.
15:49:28 <Cale> Warrigal: Well, particularly, one way of reasoning about the semantics of Haskell.
15:49:30 <Berengal> > shiftL 1 63 :: Int
15:49:32 <lambdabot>   -9223372036854775808
15:49:45 <Baughn> pragma_: Have you read the typeclassopedia?
15:50:06 <pragma_> Baughn: I bought 'Real world Haskell' or something like that.
15:50:19 <pragma_> But it's not that much fun to read.
15:50:19 <jmelesky> pragma_: the tendency to define new operators can be a bit overwhelming
15:50:45 <dm`> shirtL is obviously fine for left shifts, since arithmetic and logical left shift are the same thing.
15:50:49 <Berengal> pragma_, it was gibberish to me until I got used to it, which was a while.
15:50:57 <dm`> (I can't type shift for some reason.)
15:51:00 <Berengal> (About 6 months)
15:51:07 <Cale> Warrigal: Types are turned into directed-complete partial orders by the definedness ordering: values are incomparable unless one of them can be obtained from the other by replacing occurrences of _|_ (= undefined) with other values.
15:51:24 <Berengal> > shiftR 1 1 :: Int
15:51:25 <lambdabot>   0
15:51:30 <Berengal> > shiftR 1 2 :: Int
15:51:31 <lambdabot>   0
15:51:43 <Cale> Warrigal: That ordering induces a topology of which the definable functions are the continuous ones.
15:51:52 <Berengal> > rotateR 1 2 :: Int
15:51:53 <lambdabot>   4611686018427387904
15:51:57 <Berengal> > rotateR 1 1 :: Int
15:51:59 <lambdabot>   -9223372036854775808
15:52:13 <pragma_> Baughn: You mean this?  http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
15:52:14 <dm`> > shiftR (complement 0::Int) 0
15:52:15 <lambdabot>   -1
15:52:17 <dm`> > shiftR (complement 0::Int) 1
15:52:18 <lambdabot>   -1
15:52:19 <dm`> > shiftR (complement 0::Int) 2
15:52:21 <Baughn> pragma_: Yes
15:52:21 <lambdabot>   -1
15:52:24 <burp>  main = print $ sum [1..1000000] <- nice how jhc's output segfaults on this ;)
15:52:30 * pragma_ reading.
15:52:30 <Baughn> pragma_: It really helped me appreciate the beauty of haskell.
15:52:30 <Cale> Oh, I should say, when you can get y from x by replacing occurrences of _|_ in x with other values, then x < y.
15:52:56 <Baughn> pragma_: ..oh, and am now sleeping. Night.
15:53:28 <pragma_> I think where I am with Haskell right now is where a lot of people appear to be with Perl.  "Ew, gibberish characters!  How weird!"
15:54:17 <dm`> perl is hard to read, but haskell is hard to write.  It seems like most strings are valid perl programs, not so for haskell...
15:54:48 <arw> well, there are some pretty unreadable operators in haskell...
15:54:55 <Nereid_> fmap fmap fmap
15:54:56 <Nereid_> :-)
15:55:06 <skorpan> MY HEAD EXPLODED
15:55:15 <Berengal> At one point I found haskell harder to read than write
15:55:17 <pr> @type fmap fmap fmap
15:55:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:55:23 <Berengal> Of course, both were hard at first
15:55:26 <Berengal> @quote o_o
15:55:26 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
15:55:30 <Nereid_> @type fmap fmap fmap id id id
15:55:31 <lambdabot> forall a. a -> a
15:55:33 <Nereid_> lo
15:55:34 <Nereid_> lol
15:55:36 <Berengal> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
15:55:37 <lambdabot>   [[0.0]]
15:55:40 <arw> @type >>=
15:55:41 <lambdabot> parse error on input `>>='
15:55:48 <skorpan> :t \a b c d e f -> f e d c b a
15:55:48 <Nereid_> @ty (>>=)
15:55:49 <arw> wrong one...
15:55:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:55:50 <lambdabot> forall t t1 t2 t3 t4 t5. t -> t1 -> t2 -> t3 -> t4 -> (t4 -> t3 -> t2 -> t1 -> t -> t5) -> t5
15:55:55 <skorpan> @pl \a b c d e f -> f e d c b a
15:55:56 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
15:56:00 <Nereid_> lol
15:56:08 <Nereid_> is there an un-pl somewhere?
15:56:08 <Phyx-> :t fmap fmap fmap
15:56:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:56:18 <Berengal> @unpl fix . fmap
15:56:19 <lambdabot> (\ c -> fix (fmap c))
15:56:19 <Phyx-> Nereid_: @unpl ?
15:56:23 <Nereid_> ok
15:56:24 <Nereid_> :)
15:56:26 <Nereid_> @unpl fmap fmap fmap
15:56:27 <lambdabot> fmap fmap fmap
15:56:31 <Nereid_> :(
15:56:44 <aavogt> @. unpl pl \a b c d e f -> f e d c b a
15:56:45 <lambdabot> (\ b c f i l o -> o l i f c b)
15:56:55 <Nereid_> o_o
15:56:58 <Nereid_> interesting variable names there
15:56:59 <skorpan> @unpl flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
15:57:00 <lambdabot> (\ b c f i l o -> o l i f c b)
15:57:56 <Berengal> @. type djinn (a -> b) -> (b -> a -> c) -> (a -> c)
15:57:58 <lambdabot> parse error on input `='
15:58:01 <arw> a sufficiently determined programmer can write unreadable programs in every language :)
15:58:07 <Berengal> :/
15:58:27 <pikhq> But few can make readable programs.
15:58:59 <benmachine> @djinn (a -> b) -> (b -> a -> c) -> (a -> c)
15:59:00 <lambdabot> f a b c = b (a c) c
15:59:05 <Berengal> A sufficiently determined language can make every programmer write unreadable programs
15:59:13 <arw> i've seen perfectly obvious and readable assembler and totally unreadable python...
15:59:47 <Berengal> I've seen unreadable english, so it shouldn't come as a surprise...
16:00:17 <hackagebot> ghc-core 0.5 - Display GHC's core and assembly output in a pager (DonaldStewart)
16:00:25 <arw> english isn't my native language, so unreadable is rather normal than abnormal :)
16:03:29 <Warrigal> It seems you can make a lot of topological spaces by gluing ADTs.
16:03:52 <opqdonut> ??
16:04:59 <Warrigal> Start with 'data Continuum = Zero Continuum | One Continuum', glue Zero (fix One) to One (fix Zero), and you get the topology of a closed interval of real numbers. Take the Cantor square of that, glue the edges together in a certain way, you get a Klein bottle.
16:05:41 <copumpkin> hawt
16:05:56 <monochrom> You can make a lot of topological spaces by gluing topological spaces.
16:05:58 * copumpkin fills his klein bottle with alkeehol
16:06:07 <edwardk> copumpkin: http://comonad.com/scheme/monads/
16:06:09 <opqdonut> yah, you can go pretty much anywhere with subspaces of the cantor set
16:06:11 <edwardk> <- got bored
16:06:21 <Warrigal> Well, these are quotient spaces, not subspaces.
16:06:23 <copumpkin> edwardk: !
16:06:39 * Phyx- goes back to work on his IDE
16:06:45 <opqdonut> those too :)
16:06:46 <copumpkin> we must keep edwardk away from those scheme workshops, or look what happens!
16:07:05 <edwardk> copumpkin: because every introductory text on monads in scheme needs http://comonad.com/scheme/monads/cofree.scm ;)
16:07:32 <edwardk> sadly, the cofree comonad is much more usable in scheme than in haskell ;)
16:07:52 <monochrom> Quotient spaces are someone else's subspaces.
16:07:59 <Phyx-> has the ghc api changed much in newer 9.10.x releases if anyone knows?
16:08:13 <Phyx-> that thing's usually as unstable specs wise as lindsay lohan
16:08:16 <edwardk> Phyx-: my time machine is busted. can't check ;)
16:08:35 <Phyx-> aww
16:08:37 <Berengal> edwardk, was just wondering, is there any literature about monoid reducers apart from the source itself?
16:08:53 <edwardk> Berengal: nah, its pretty much er.. just in my head ;)
16:09:10 <Berengal> Heh. I still haven't grasped reducer properly
16:09:28 <edwardk> reducer = monoid equipped with an injection from some base type
16:09:45 <edwardk> which can optionally have optimized left to right and right to left folds in the form of snoc and cons
16:10:15 <Berengal> It feels like understanding it is on the tip of my brain's tounge analogy, and it's bugging the hell out of me
16:12:05 <edwardk> Berengal: think of a monoid for tracking the length of an input. you can define a monoid for tracking length, that just adds integers together. and a 'unit :: Char -> Length' which just ignores the character and reports '1', cons and snoc would just add 1 to the existing result.
16:12:46 <Berengal> And the reducer would be Reducer Char Int?
16:12:57 <edwardk> Berengal: or the list monoid, for which, mappend = append, unit a = [a]; and cons = (:)
16:13:17 <edwardk> well, Reducer Char Length -- where Length is a newtype of Int
16:13:23 <edwardk> but yeah
16:13:54 <edwardk> then you could just use something like 'reduceWith getLength' to extract a length from a string
16:14:15 <Berengal> Yeah
16:14:27 <Berengal> So unit is the principal function of the class, am I right?
16:14:32 <edwardk> yeah
16:14:33 <Berengal> cons and snoc are more optional
16:14:39 <edwardk> cons and snoc are purely optimizations
16:15:01 <edwardk> since they can be defined canonically: cons c m = unit c `mappend` m
16:15:24 <edwardk> and snoc m c = m `mappend` unit c
16:15:32 <Berengal> Right. So it's a sort of mapping from one type to another monoid type
16:15:55 <Berengal> With some rather nifty instances, it looks like
16:16:12 <edwardk> though the source doesn't have to be a monoid. its just an embedding into the monoid from some type you have lying around
16:16:21 <leimy> darn... Mac OS X Snow Leopard broke my GHC install :-(
16:16:49 <leimy> "suffix or operands invalid for push"
16:17:08 <edwardk> so for instance you can use the (First a) monoid as a Maybe a reducer or as an 'a' reducer, etc. and it'll just do the right thing.
16:17:18 <Berengal> I read through your slides, and while somewhat lacking in general learning they had some pretty nifty examples
16:18:05 <edwardk> the main purpose of the slides was to set up for the talk on the iteratee/parsec based monoid
16:18:34 <edwardk> and to talk further about parsimony
16:18:35 <Berengal> Yeah, I don't expect much from slides in general, appart from sparkly graphics and mind-bending one-liners :P
16:18:37 <glguy> leimy: using GHC and installing the new OS X on release day haven't historically been very compatible :)
16:18:48 <edwardk> i'm pretty light on sparkly graphics and one-liners ;)
16:18:49 <leimy> glguy: Yeah I was hopeful
16:18:55 <leimy> and I'm actually hoping to warn others :-)
16:19:21 <Berengal> Well, it's hard to get anything _but_ one-liners on slides
16:19:52 <edwardk> yeah
16:20:17 <edwardk> i do hate slides. i kind of like the tufte idea oof handing out a short technical brief beforehand and just going it without visual aids of that sort
16:20:47 <erikc> edwardk: yes
16:21:11 <erikc> i've stopped attending any and all slide meetings if i can
16:21:33 <Berengal> I'm more of a demo kind of guy myself
16:21:55 <Berengal> Preferably a bit of live coding
16:21:57 <erikc> it's just a terrible way of synthesizing technical information, and i hate presenting that way just as much
16:22:28 <edwardk> heh, i always liked teaching math for that reason, because it forced you to slow down to a pace at which information could be absorbed
16:22:41 <edwardk> and since the generation of the information on the board was part of the dialogue, it wasn't a constant distraction
16:22:46 <glguy> leimy: http://hackage.haskell.org/trac/ghc/ticket/3400
16:23:19 <leimy> glguy: I figured there'd be a way to do this.
16:24:06 <erikc> edwardk: yes, in that sense, it's much more interactive, much like a software demo
16:25:00 <Berengal> edwardk, it's a bit of the same with live coding. Present a problem, talk about what makes it a problem while exploring possible solutions, present real solution. Interactivity adds to this
16:29:13 <leimy> glguy: good that it was closed... however I don't see the fix :-)
16:29:55 <glguy> leimy: Yeah, the ticket doesn't specify which branch was fixed, a milestone for a release, etc
16:30:03 <leimy> nope
16:30:08 <leimy> but it happily closed the issue :-)
16:30:49 <glguy> This much more important ticket seems to have lots of CC attention but little development attention http://hackage.haskell.org/trac/ghc/ticket/2965
16:31:32 <leimy> The problem is that I think that we can't build GHC without GHC can we? :-)
16:31:50 <copumpkin> glguy: I've been trying to work on it, but it's harder than I thought it would be
16:31:57 <leimy> ah
16:32:23 <leimy> well That's why I'm keeping a leopard box around for building :-)
16:32:33 <glguy> copumpkin: What sorts of major differences are there between the Linux 64-bit rts and what needs to be done for 64-bit darwin?
16:32:35 <leimy> rather than upgrading all of em.
16:33:12 <copumpkin> glguy: there shouldn't really be any differences, but I've been struggling with the whole "bootstrap from .hc files" question, and I think there are a few preprocessor #ifdefs that assume that darwin == i386
16:35:10 <copumpkin> glguy: expert osx ghc hacker support is very welcome, of course :)
16:35:20 <erikc> should consider abandoning the ppc mac port
16:35:57 <ksf> can I select one overlapping instance over the other?
16:36:07 <bos> is it possible to write accessor functions when defining GADTs, the same way as for normal ADTs?
16:36:10 <erikc> x86-64 is the future, in a year from now 10.7 will be out and x86 will be considered 'legacy'
16:36:21 <erikc> apple deprecates quickly
16:36:37 <ksf> ...just a sec, I again fail to read type errors...
16:37:00 <leimy> Well on the plus side
16:37:03 <leimy> ghci still works :-)
16:37:08 <leimy> So I can run the code, just can't compile it.
16:37:09 <bos> i guess not.
16:37:23 * erikc is upgrading to 10.6 tonite
16:38:47 <glguy> erikc: they announced that PPC was on the way out 4 years ago
16:39:07 <copumpkin> bos: I think so, why not?
16:39:11 <glguy> erikc: I suspect we'll get more warning than 1 release that i686 is out as well
16:39:18 <bos> copumpkin: i don't know what the syntax would be
16:39:20 <erikc> ah, cool
16:39:36 <copumpkin> bos: you mean using record syntax?
16:39:43 <bos> copumpkin: right
16:39:44 <ksf> hmmm... do instances get re-exported automagically?
16:39:47 <glguy> erikc: especially considering that applications like iTunes and VMWare are still 32-bit today
16:39:49 <bos> ksf: yes
16:39:56 <copumpkin> bos: it's in http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
16:39:58 <ksf> that explains my bewilderment.
16:40:02 <copumpkin>   data Term a where
16:40:02 <copumpkin>       Lit    { val  :: Int }      :: Term Int
16:40:08 <copumpkin> a little odd :)
16:40:09 <erikc> glguy: i dont mean they'll pull the plug, but they will definitely start prodding
16:40:54 <ksf> ...so I'm using {-# LANGUAGE MultipleParamTypeClasses, FunctionalDependencies, FlexibleInstances, UndecidableInstances, OverlappingInstances #-}, and, against all expectations, everything works.
16:41:20 <erikc> in such a way that apps that dont go along will stick out like sore thumbs and expose themselves to competition from up-n-comers who are on the 64-bit train
16:42:37 <bos> ksf: if you're using UndecidableInstances, something is probably either broken or on the verge of breaking
16:43:03 <bos> ksf: not guaranteed to be, but somewhat likely
16:43:06 <copumpkin> unless you're positive they're decidable
16:43:28 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8799#a8799
16:43:50 <ksf> I guess it's trivial enough not to be problematic.
16:43:57 <ksf> ...but that's about all the prove I have.
16:45:01 <ksf> mmmh actually fromFlags == mconcat. that's why I wrote that instance...
16:45:48 <ksf> and, btw, no, it doesn't seem to be possible to export class members only to instance declarations.
16:48:59 <sm> is there an easy way to find out how many packages on hackage use package A ?
16:49:21 <ksf> sm, I wish.
16:49:27 <enolan> There's downloading the index and using grep.
16:49:42 <enolan> But that doesn't really qualify as easy
16:50:16 <sm> that looks easier than anything else.. thanks enolan
16:51:24 <sm> oh wait.. you mean download all .cabal files listed in that, and analyze them ?
16:51:53 <ksf> sm, time for some haskell-fu.
16:51:58 <dcoutts> sm: there's an open ticket to add this to "cabal info"
16:52:04 <enolan> there's a tarball of all the .cabals somewhere
16:52:05 <dcoutts> it's not very hard
16:52:34 <enolan> "tarball of package descriptions" on hackage.haskell.org under "getting the raw data"
16:52:38 <dcoutts> internally in cabal we have the index, so finding reverse deps is mostly a matter of deciding what it is you mean by reverse deps
16:53:07 <dcoutts> since it's not quite as straightforward as it initially looks
16:53:27 <ksf> ...a tree up to a requested depth?
16:53:57 <dcoutts> For example, do you want the reverse deps of "this package version" or "any/all versions of this package"
16:54:01 <dcoutts> the answers are different
16:54:20 <ksf> ...so, do I have #haskell's blessing on the decidability of my UndecidableInstances?
16:54:36 <sm> no time for haskell-fu right now actually. Just answering a question about vty packaging. Plan B: dear #haskell, am I right in saying mtl and parsec 2 are the standard libs, instead of monads-tf and parsec 3 ?
16:54:38 <ksf> I'm a bit lost thinking about it, they're my first, after all.
16:54:56 <dcoutts> sm: yes. Those are the ones in the Haskell Platform.
16:55:03 <sm> excellent
16:55:17 <roconnor> hi sm
16:55:29 <sm> aha, hi roconnor
16:55:29 <Berengal> > map (\(x,y)-> replicate x (['a'..'z'] !! y)) $ zip (fix ((1 :) . (1 :) . ap (zipWith (+)) tail)) [5,8,1,14,13,0,2,2,8]
16:55:31 <lambdabot>   ["f","i","bb","ooo","nnnnn","aaaaaaaa","ccccccccccccc","ccccccccccccccccccc...
16:55:48 <roconnor> sm: is hledger pure haskell or an FFI to something else?
16:56:03 <sm> pure haskell.. just a typical hackage app
16:56:16 <roconnor> and it uses curses?
16:56:49 <sm> yes, as an optional ui
16:56:58 <ksf> Berengal, you should iterate those indices.
16:56:59 <roconnor> how do you write a haskell app that uses curses?
16:57:03 <sm> roconnor: you're not Corey, are you
16:57:08 <roconnor> sm: nope
16:57:16 <sm> there are curses libs on hackage, vty is the one I'm using
16:57:28 <roconnor> oh I didn't know that
16:58:02 <roconnor> sm: I don't see vty listed as a dependency
16:58:05 <sm> yup. and Corey O'Connor is about to release vty 4 which fixes a bunch of issues.. but it has some awkward dependencies
16:58:06 <roconnor> http://hackage.haskell.org/package/hledger
16:58:34 <sm> roconnor: it's a flag in the cabal file.. I don't know how you get those to show up
16:58:39 <roconnor> oh
16:58:43 <roconnor> nifty
16:59:23 <Berengal> > sort "negation   " == sort "get a no in"
16:59:24 <lambdabot>   True
16:59:41 <sm> roconnor: cabal install -fvty hledger , testers welcome
16:59:44 <ezyang> Hey all, I've decided that I'm going to write a small membership management application in Haskell.  I was wondering what directions I should take some of the backend components: webapp or command line? Database or CSV file or some sort of state persistence engine like Macid?
16:59:58 <roconnor> sm: thanks.  I might try it out a bit later
17:00:32 <Berengal> ezyang, the easiest way is show/read persistence with command line
17:01:41 <ezyang> ok
17:01:43 <aavogt> slowest too, most likely
17:02:12 <ezyang> not a problem
17:02:12 <Berengal> Indeed
17:02:30 <Berengal> Might be a problem if you have a non-interactive command line
17:03:28 <ezyang> All I need is for it to tell me: does this person need to pay dues?
17:03:41 <ezyang> And let me update info appropriately
17:05:40 <Berengal> Start with show/read. If you need some other persistence engine later you can still reuse the same types
17:06:10 <ezyang> Alright!
17:06:27 <ezyang> I wonder how powerful Derives is
17:10:36 <dm`> What's the easiest way to convert from a Char to a Word8?   "fromInteger . toInteger . ord" is clumsy and seems like it would be kind of inefficient, so I'm sure I'm missing something stupid.
17:11:01 <Twey> :t ord
17:11:02 <lambdabot> Char -> Int
17:11:06 <Twey> Huh.
17:11:22 <aavogt> @type modifyIORef
17:11:22 <Berengal> > fromIntegral . ord $ 'a' :: Word8
17:11:24 <lambdabot> Not in scope: `modifyIORef'
17:11:24 <lambdabot>   97
17:11:38 <aavogt> @type Data.IORef.modifyIORef
17:11:39 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
17:11:51 <aavogt> was there something about modifyIORef leaking memory?
17:11:54 <dm`> :t fromIntegral
17:11:56 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:12:04 * ezyang has no clue where to start >_< 
17:12:20 <dm`> :t fromIntegral . ord
17:12:22 <lambdabot> forall b. (Num b) => Char -> b
17:12:46 * roconnor uses (toEnum . fromEmum)
17:12:59 <ezyang> I guess hello world is as good a place as any to start
17:13:00 <dm`> okay, slightly simpler.  Will that be efficient?  This is kind of something I'm doing in the inner loop.
17:13:23 <ezyang> What's the standard command line arg parser for Haskell?
17:13:27 <roconnor> I think GHC will rewrite whatever you do into something efficient.
17:13:31 * roconnor crosses his fingers
17:13:43 <Twey> ezyang: System.Console.GetOpt, I think
17:13:43 <aavogt> @hoogle getArgs
17:13:44 <lambdabot> System.Environment getArgs :: IO [String]
17:13:51 <dm`> >  toEnum . fromEnum $ 'a' :: Word8
17:13:53 <lambdabot>   97
17:13:54 <Twey> But yeah, that's pretty heavy-weight
17:14:00 <Berengal> {-# SPECIALIZE-KTHX #-} should do it
17:14:26 <roconnor> dm` be aware that Char -> Word8 is not injective
17:14:28 <Twey> Just getArgs is suitable for simple apps
17:15:05 <Berengal> for simple apps I usually do main = mapM doCommand =<< getArgs
17:15:15 <dm`> roconnor: That's fine.  I'm just dealing with ascii strings.
17:15:17 <Twey> Yeah
17:15:21 <roconnor> good
17:15:23 <ezyang> Berengal, aight, I'll do that
17:15:40 <roconnor> dm` where are the Char's coming from?
17:15:44 <Twey> If you need something complicated and find yourself writing >20 lines of code, use GetOpt.
17:15:55 <roconnor> dm` ByteStrings naturally work on Word8s
17:18:57 <dm`> Yeah, I need to base-32 encode some SHA-256 hashes.  The SHA library in hackage gives the values to me as an Integer or a String.  I was using the base-16 String, which is clearly ascii.  Maybe I should use the Integer version, but I was assuming that would be slower (lots of shifts on a very large integer).
17:19:49 <dm`> Actually, Integer is not even an instance of the Data.Bits class, so String is the best way for me to manipulate this, I think.
17:19:50 <ezyang> What's... the type signature of doCommand?
17:20:03 <Berengal> ezyang, String -> IO ()'
17:20:05 <roconnor> dm`: crypto lib?
17:20:13 <dm`> Data.Digest.Pure.SHA
17:20:32 <ezyang> ohh, get args doesn't actually do any parsing
17:20:32 <ezyang> it just gives me the split up stuff
17:20:32 <ezyang> I guess that'll work
17:20:32 <dm`> is what I'm using
17:20:35 <edwardk> Integer is an instance of Bits
17:20:52 <roconnor> dm`: ah whew.  That one isn't my fault.
17:20:54 <dm`> > complement (0::Integer)
17:20:55 <lambdabot>   -1
17:21:11 <edwardk> unfortunately Bool is not an instance of Bits =(
17:21:17 <mmorrow> dm`: gmp implements efficient bitwise ops, but ghc doesn't use them
17:21:20 <edwardk> mainly because no one wants to make the Num instance for it
17:21:20 <dm`> Is there a better crypto lib I should be using?
17:21:44 <pastorn> How does one design a program to make it possible for users to write plugins for it
17:21:45 <mmorrow> dm`: is this speed and/or security critical?
17:21:45 <roconnor> dm`: I don't know if it better, but I wrote SHA256 for: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-Digest-SHA256.html
17:21:56 <roconnor> ya
17:21:58 <pastorn> like Firefox, or World of Warcraft.
17:22:01 <roconnor> I promise no speed
17:22:03 <mmorrow> dm`: if it is i'd use C
17:22:06 <roconnor> in fact, I promise that I'm slow
17:22:09 <ksf> dm`, base32?
17:22:14 <ksf> ...you mean base64?
17:22:25 <ksf> http://www.haskell.org/crypto/doc/html/Codec-Binary-Base64.html
17:23:00 <pastorn> i guess my view of programs are that they are rather static things :/
17:23:03 <ksf> ...and you don't want to work on Char, as Char isn't 8 bit.
17:23:04 <dm`> No, base32.  Just a simple encoding I like to use.  Maps to all letters and digits except 0, 1, o, and l (as those four tend to confuse people).
17:23:38 <EvilTerran> pastorn, xmonad would be a good haskell example
17:23:45 <ksf> ...anyway, I recommend working on [Word8]
17:23:54 <ksf> ...or another sequence type of your choice.
17:24:04 <ksf> bytestring comes to mind.
17:24:14 <dm`> You are correct that I don't want to work on Char, so my first iteration through the thing I am converting it to Word8.
17:24:15 <pastorn> EvilTerran: do you mean like how people are possible to design their own windowing layouts?
17:24:18 <mmorrow> data Hash = Hash {-# UNPACK #-} Word64 {-# UNPACK #-} Word64 {-# UNPACK #-} Word64 {-# UNPACK #-} Word64
17:24:20 <mmorrow> i'd use
17:24:28 <mmorrow> (if you're on a 64bit computer)
17:24:30 <pastorn> isn't
17:24:40 <mmorrow> Word32 * 8 otherwise
17:24:42 <pastorn> that just a typeclass or something?
17:24:48 <ezyang> Berengal: Why did you use mapM?
17:24:51 * roconnor uses type Hash256 = Hash8 Word32
17:25:03 <Berengal> ezyang, should've been mapM_
17:25:05 <roconnor> data Hash8 w = Hash8 !w !w !w !w !w !w !w !w deriving (Eq, Ord)
17:25:06 <ksf> UArray i Word8
17:25:15 <mmorrow> you want to unpack them too
17:25:21 <ezyang> Berengal: Mmm, I don't understand why you'd want it at all, unfortunately
17:25:23 <roconnor> bah
17:25:33 <roconnor> -funpack-strict-fields
17:25:34 <pastorn> EvilTerran: what parts of xmonad?
17:25:35 <Berengal> > mapM Just (words "these are the args")
17:25:36 <lambdabot>   Just ["these","are","the","args"]
17:25:50 <mmorrow> unpack so they're literally a struct {uint32_t bytes[8]};
17:25:57 <roconnor> or is that unbox
17:26:01 <mmorrow> unpack
17:26:06 <mmorrow> into the constructor
17:26:07 * roconnor doesn't know about this operational nonsense :D
17:26:09 <ksf> hum no foldable instance for Arrays?
17:26:30 <edwardk> roconnor: basically the moment you go polymorphic, even if you're strict, you lose the unpacking
17:26:33 <roconnor> if someone wants to patch my code, I have no problem with that.
17:26:35 <Berengal> ezyang, it's just looping through the args, calling doCommand on each one in sequence
17:26:45 <mmorrow> roconnor: e.g., if you were to vacuum the non-unpacked version, you'd get
17:26:52 <roconnor> bah
17:26:54 <ezyang> Right, but in the case of getArgs the strings are wrapped up in the IO monad
17:26:57 <mmorrow> , vacuum (0,0,0,0,0,0,0,0)
17:27:01 <lunabot>  [(0,[1,2,3,4,5,6,7,8]),(1,[]),(2,[]),(3,[]),(4,[]),(5,[]),(6,[]),(7,[]),(...
17:27:01 <ezyang> Ohhhhh
17:27:08 <mmorrow> and the unpacked version would give you
17:27:12 <roconnor> edwardk: what about modularity ;(
17:27:14 <mmorrow> [(0,[])]
17:27:30 <ezyang> Berengal: When would that be the functionality you'd want, out of curiosity?
17:27:32 <edwardk> roconnor: out the window ;)
17:27:47 <roconnor> edwardk: I'll just assume people are using jhc then.
17:27:54 <vav> pastorn: if you want to limit what users can do, xmobar is  example http://code.haskell.org/~arossato/xmobar/#plugins -- xmonad has two packages, one stable core xmonad, one wide open for user modules xmonad-contrib -- see the latter.
17:28:00 <ezyang> Berengal: When I program a script for Python, generally I get a list of args, but I don't loop through them
17:28:06 <edwardk> or ndm's supero stuff ;)
17:28:55 <mmorrow> also, if you were doing something serious and/or sensitive with crypto you wouldn't be using a GC'ed language..
17:28:57 <Berengal> ezyang, well, do something different then. Something else I do from time to time is 'do (command:arg1:arg2:_) <- getArgs; doCommand command arg1 arg2;'
17:29:16 <roconnor> mmorrow: BTW, you want 8 Word32s for SHA-256 because that is how the hash operates.  8 Word64s for SHA-512
17:29:22 <mmorrow> your keys get scattered about
17:29:35 <mmorrow> roconnor: indeed
17:29:50 <mmorrow> roconnor: why are you mentioning this?
17:29:58 <Berengal> ezyang, called like './foo blah arg arg' that'll do 'doCommand "blah" "arg" "arg"'
17:29:59 <ezyang> Berengal: fair enough
17:30:08 <Berengal> Not much for error handling though
17:30:09 <roconnor> in reply to [20:24] <mmorrow> data Hash = Hash {-# UNPACK #-} Word64 {-# UNPACK #-} Word64 {-# UNPACK #-} Word64 {-# UNPACK #-} Word64
17:30:29 <ezyang> I'll want some sort of dispatch system
17:30:35 <mmorrow> roconnor: yes, that was in reply to <dm`> Yeah, I need to base-32 encode some SHA-256 hashes...
17:30:37 <ezyang> Since the first arg will probably indicate the command to run
17:31:08 <pastorn> vav: would you suggest looking at the xmobar source to learn how a plugin-able structure should be?
17:31:08 <ezyang> and then the second arg will be some required param
17:31:10 <ksf> ezyang, http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
17:31:14 <ezyang> Meh, ok, I'm going to use the bazooka
17:31:26 <pastorn> vav: or is it something dijkstra would not approve of?
17:31:26 <Berengal> ezyang, that's where the "doCommand" function comes in. Implement it like 'doCommand "update" = update" where "update arg1 arg2 = ..."
17:31:27 <ezyang> ksf: :-)
17:32:16 <Berengal> As an aside, can you lazily match an entire list pattern with a single ~?
17:32:32 <ksf> you quickly get into problems with different commands taking different counts of arguments
17:32:36 <Berengal> > (\~[x,y,z] = x) [1]
17:32:37 <lambdabot>   <no location info>: parse error on input `='
17:32:42 <Berengal> > (\~[x,y,z] -> x) [1]
17:32:44 <lambdabot>   <no location info>: parse error on input `->'
17:32:52 <Berengal> :/
17:33:10 <MyCatVerbs> ksf: make like argv and pass [String] instead of String, and that problem mostly goes away. ^_^
17:33:22 <vav> pastorn: xmobar has some pretty bad and weird code in it, but sorry I don't know of better examples, maybe something in gitit or happstack world?
17:33:38 <ezyang> What's the difference between "import List" and "import Data.List"?
17:33:54 <aavogt> pastorn: maybe look at lambdabot?
17:34:06 <Berengal> ksf, there are clever ways around that. The doCommand function can discard arguments the mapped function don't need for example
17:34:07 <sm> or the new dyre lib, which I assume is what xmonad uses
17:34:23 <pastorn> aavogt: can she handle my plugins?
17:34:40 <aavogt> sm: xmonad does not use it, but there was some discussion
17:34:41 <MyCatVerbs> ezyang: List is the "old" name, kept around for compatibility with the original Haskell98 standard.
17:34:52 <ezyang> Ok
17:35:00 * ezyang chants "lies lies" to the tutorial 
17:35:24 <MyCatVerbs> ezyang: Data.List is the new name for the List module. It's just so that we get a nice hierarchy, all Data.Map, Data.Set, Data.List, etc.
17:36:12 <ksf> http://www.haskell.org/haskellwiki/GetOpt is interesting
17:36:40 <MyCatVerbs> Generally it's Data.Foo for data structures, Control.Foo for things like arrows, applicatives, monads and other things that mess with control flow in interesting ways, System or Graphics or Network or whatever for other things.
17:37:09 <ezyang> Ah, ok
17:37:23 <MyCatVerbs> (Strictly speaking, we shouldn't really be differentiating between control structures and data structures in Haskell, but that's an insane view justified only by its correctness ;)
17:37:44 <MyCatVerbs> I'm, er, halfway joking there. :)
17:38:48 * Berengal wonders if LC can implement everything as efficiently as haskell
17:39:59 <zzaz> how do you take the cube root of a number?
17:40:17 <Berengal> Which one?
17:40:44 <zzaz> like cbrt 8 = 2
17:41:43 <ezyang> Berengal: hahahaha
17:41:47 <ksf> zzaz, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_thm_1.8
17:42:14 <davidL> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 !! 100 in cbrt 8
17:42:16 <lambdabot>   2.0
17:43:32 <zzaz> but you need to already have an approximation of the value?
17:43:46 <ksf> :t iterate
17:43:47 <lambdabot> forall a. (a -> a) -> a -> [a]
17:43:50 <ksf> @src iterate
17:43:51 <lambdabot> iterate f x =  x : iterate f (f x)
17:43:59 <ksf> you do. first 1, then the previous iteration.
17:44:15 <ksf> let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 in cbrt 8
17:44:18 <ksf> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 in cbrt 8
17:44:19 <lambdabot>   [1.0,3.3333333333333335,2.462222222222222,2.081341247671579,2.0031374991412...
17:44:32 <ksf> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 in drop 20 $ cbrt 8
17:44:33 <lambdabot>   [2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2....
17:44:37 <ksf> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 in drop 10 $ cbrt 8
17:44:38 <lambdabot>   [2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2....
17:44:44 <ksf> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 in drop 5 $ cbrt 8
17:44:45 <lambdabot>   [2.000004911675504,2.000000000012062,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2....
17:45:03 <davidL> > let cbrt x = iterate (\y -> (x/y^2 + 2*y)/3) 1 !! 100 in cbrt 74088
17:45:05 <lambdabot>   42.0
17:45:11 <CalJohn> Berengal: "LC"?
17:45:40 <davidL> > 74088**(1/3)
17:45:40 <mmorrow> oh shitshitshitshit "Wi-Fi must be enabled in Windows XP before installing UNR or else it is impossible to enable it."
17:45:41 <lambdabot>   41.99999999999999
17:45:52 * mmorrow kicks his cat
17:46:13 <thoughtpolice> mmorrow: if you want to talk windows problems, i have had quite horrific experiences the past few days
17:46:15 <zzaz> hmm yea (**) seems a better option
17:46:33 <mmorrow> thoughtpolice: i didn't even bother booting into windows before i wiped the disk and installed linux
17:46:49 <mmorrow> so now wireless is screwed
17:47:01 <ksf> ...until you want to take big roots.
17:47:15 <ksf> as the precision of doubles is quite limited.
17:47:29 <thoughtpolice> which lead to 1) deleting my VMware copy of XP because vmware started becoming highly unstable, 2) because of its instability I couldn't copy over any of my work stuff, 3) reinstalling OS X entirely because for some reason partitioning with boot camp fucked up, 4) installing XP and getting everything running fine, and finally 5) trying to update the boot camp drivers in XP, which for some reason totally killed both my mouse and keyboard
17:48:09 <thoughtpolice> oh, and did I mention that getting my computer set up to do work from home takes *shitloads* of time because I have to download/install/and update VS2008 TS, as well as our entire codebase over VPN?
17:48:14 <thoughtpolice> the past few days haven't been fun :(
17:48:26 <mmorrow> thoughtpolice: nice. i've been working on wireless on this piece of crap since 9am, and it's 7.45pm now here. yay!
17:49:04 <mmorrow> only to find out he has to somehow reinstall windows
17:49:07 <copumpkin> thoughtpolice: did you see my paste? ;)
17:49:08 <mmorrow> heh, me
17:49:24 * mmorrow is pissed
17:49:25 <thoughtpolice> mmorrow: I wouldn't even be dealing with it this much if my work didn't require using Windows (our product is windows/linux, no OS X,) as well as my game design course this semester
17:49:39 <ezyang> What are peoples thoughts on explicitly listing which functions you are importing from modules?
17:50:05 * ksf only uses hiding clauses and import names.
17:50:06 <Twey> Good.
17:50:19 <thoughtpolice> mmorrow: oh I was furiously pissed this morning after I updated EVERYTHING and got my Windows XP system working entirely (for both work and class,) only to find for some reason that boot camp had totally fucked up my keyboard and mouse
17:50:21 <sm> ezyang: I've got in the habit of it, except in the very beginning of playing with a new module.. saves me time and brainpower
17:50:26 * Twey only uses explicit or qualified imports.
17:50:31 <thoughtpolice> getting XP set up for that took well over 4 hours
17:50:31 <sm> -Wall tells me about them
17:50:32 <Berengal> ezyang, do it, except perhaps the few most common modules
17:50:32 <Twey> Yes
17:50:51 <Twey> Often I'll implicitly import when developing, then go back and make it explicit.
17:51:02 <thoughtpolice> copumpkin: no, I've been ranting/venting my frusterations with OS X/Windows
17:51:04 <ksf> ...do it while being stuck with a hard problem.
17:51:06 <thoughtpolice> ;P
17:51:32 <sm> soon the tools will do it
17:51:39 <Berengal> There's nothing as annoying as looking for the definition of a function hidden deep within a 4-layer deep import tree
17:51:40 <thoughtpolice> copumpkin: and now I have to totally set my computer back up the way I had it because I had to reinstall OS X to get boot camp working
17:51:51 <copumpkin> :P
17:51:56 <copumpkin> I get it, I get it
17:52:05 * ksf doesn't have 4-layer deep import trees.
17:52:07 <thoughtpolice> copumpkin: luckily I have 24/7 time machine backups over the past 4 months
17:52:08 <mmorrow> this little computer doesn't even have a cd-drive, nor did it come with a "restore" cd..
17:52:14 <thoughtpolice> copumpkin: so it's not that huge of a loss
17:52:22 <Twey> ksf: That's what *you* think.
17:52:25 <ksf> there's a maximum of one re-export.
17:52:37 <Berengal> mmorrow, shake it and pray it's like an etch-a-sketch
17:52:44 <thoughtpolice> copumpkin: although honestly I think I'm just going to hold off reinstalling windows, get snow leopard for this computer, and then do the whole thing over again
17:52:48 <ksf> tracking down instances is the real pain.
17:52:49 <mmorrow> Berengal: i already tried!!! :(
17:52:52 <thoughtpolice> but I'm not sure I'll be able to do all that this weekend
17:53:07 <EvilTerran> pastorn, sorry, wandered off for a bit there; yeah, the layouts are what i was thinking of
17:53:12 <ezyang> Ok, right now I have IO, Data.List, System.Environment and System.Console.GetOpt
17:53:43 <sm> s/IO/System.IO/
17:53:51 <Berengal> mmorrow, my only other suggestion is to burn a windows cd. If you're lucky, the bits might melt onto the harddrive
17:53:54 * EvilTerran just had it drawn to his attention that Magic: the Gathering has syntactic closures.
17:54:23 <Twey> Yerwhat?
17:54:36 <EvilTerran> er, s/syntactic//, confusing my terminology there
17:54:37 <ezyang> aha, I knew something was up with that
17:54:44 <ezyang> EvilTerran: What?
17:55:08 <EvilTerran> iirc, the rules call it "linked abilities"
17:55:15 <pastorn> EvilTerran: ok
17:55:26 <Twey> Wait, Magic the Gathering is Turing-complete?
17:55:36 <ezyang> Twey: I wouldn't be surprised by that...
17:55:41 <Twey> Haha
17:56:00 <ezyang> runghc is complaining about "import System.Console.GetOpt (Option, ReqArg)"
17:56:01 * Berengal ponders how to construct a nand gate
17:56:12 <mmorrow> Berengal: i guess i need to find a windows cd and a usb cd-drive
17:56:23 <mmorrow> neither of which i own
17:56:46 <Berengal> mmorrow, no network booting magic thingymajig?
17:56:46 <EvilTerran> the result is, a decision made when one ability happens can carry over to another ability that happens later
17:56:54 <mmorrow> Berengal: for windows?
17:56:58 <ezyang> it claims that "Option" and "ReqArg" are not exported
17:57:04 <mmorrow> Berengal: i dunno
17:57:08 <sm> ezyang: right. I have: import System.Console.GetOpt (OptDescr(Option), ArgDescr(ReqArg,NoArg), ArgOrder(Permute), getOpt, usageInfo)
17:57:13 <ezyang> Aha!
17:57:16 <EvilTerran> ie, closures :)
17:57:19 <ezyang> Right, goes data constructors are special
17:57:25 <Berengal> mmorrow, I don't know if it works, but you could try copying a windows cd onto a usb stick and boot from that...
17:57:36 <sm> you can also do OptDescr(..) for all constructors
17:57:46 <mmorrow> Berengal: hmm, seems like it's worth a try.
17:57:47 <Berengal> I've done that with linux before, but I've no idea if it work for windows
17:57:57 <mmorrow> now to find a windows cd..
17:58:48 <endojelly> Berengal, try lambda calculous
17:59:06 <Berengal> mmorrow, you might need a cracked version... perhaps some googling is in order?
17:59:41 * Berengal shrugs and is glad it's not his problem
18:00:03 <EvilTerran> Twey, i'm pretty sure you could contrive a way of encoding lambda calculus as a series of MtG spells that would resolve deterministically...
18:00:12 <ksf> last time I did it, it took me 5 days to install windoze. in the end I failed, but found an old ata disk that solved that sata problem...
18:00:42 * sm waits for #haskell to come back on topic
18:02:38 <endojelly> EvilTerran, or S and K combinators
18:02:47 <EvilTerran> endojelly, yeah, it'd probably be easier to go via that
18:03:22 <EvilTerran> if i work this out, i'll be sure to write a blog post about it
18:03:29 <endojelly> EvilTerran, let me know
18:03:32 <EvilTerran> hence geeking out in three different ways at once :D
18:03:40 <endojelly> EvilTerran, where's your blog at?
18:04:15 <endojelly> blogging about tested turing completeness of magic the gathering. yup, that's a geek trifecta right there.
18:04:15 <EvilTerran> ... i don't actually have one. well, i've got a livejournal account somewhere, but that hardly counts <.<  >.>
18:05:21 <endojelly> EvilTerran, heheh
18:05:43 <EvilTerran> i probably write enough random vaguely-haskell-related things that i could keep a blog vaguely ticking over
18:05:46 <EvilTerran> just haven't got round to it
18:12:41 <ezyang> Haskell has a weird list comma style... do I have to follow it?
18:13:17 <Stinger> weird list comma style?
18:13:23 <ezyang> where you have:
18:13:27 <ezyang> { foo = bar
18:13:32 <ezyang> , baz = boom }
18:13:32 <copumpkin> you don't have to do anything
18:13:33 <lunabot>  luna: parse error on input `='
18:13:37 <ezyang> haha
18:15:31 <Baconizer> Is there a way I can use Haskell with LEGO Mindstorms?
18:16:28 <Stinger> @faw
18:16:29 <lambdabot> The answer is: Yes! Haskell can do that.
18:16:34 <Stinger> close enough apparently
18:16:52 <Baconizer> :P
18:17:10 <Stinger> as for an easy way, I don't know
18:17:10 <amuck> How can I change what name ghc uses for gcc?
18:17:19 <edwardk> ezyang: it is mostly a convention that has been adopted because it plays nicer with source control. the choice of comma position is independent of language, but it has become the default among the community here
18:17:38 <copumpkin> amuck: snow leopard?
18:17:45 <Stinger> what does it have to do with source control?
18:17:45 <ezyang> ah, becuase Haskell doesn't allow trailing commas
18:17:54 <amuck> copumpkin: Yeah
18:18:18 <edwardk> Stinger: because adding a line in a list separated by ,'s terminally will require a patch that straddles both the last item line and the new line
18:18:23 <copumpkin> amuck: you could replace /usr/bin/gcc* with a script that does -m32 :P
18:18:35 <copumpkin> (that's what I did, in the other direction, on leopard)
18:18:43 <Stinger> thats a horrendous form of compression :)
18:18:55 <edwardk> otoh comma-initial lists will only patch one line
18:19:05 <edwardk> stinger: well, it causes spurious patch conflicts, etc. as well
18:19:17 <Baconizer> Does Snow Leopard mess something up with GHC?
18:19:24 <amuck> copumpkin: I'd prefer not to do that, but I might have to
18:19:41 <copumpkin> amuck: that's the only way I know of, without recompiling ghc
18:19:43 <amuck> Baconizer: It changes the default compiler, or at least the Xcode upgrade does
18:19:48 <edwardk> Baconizer: thats what i've been hearing
18:19:48 <Baconizer> D:
18:20:04 <amuck> copumpkin: Recompiling sounds like a good plan
18:20:24 <copumpkin> amuck: then just recopmile HEAD, which already has a fix
18:23:24 <amuck> copumpkin: Ok, thanks
18:26:01 <smarmy> haskell started me on using the prefix-comma notation in other languages
18:26:04 <smarmy> my coworkers hate me
18:26:42 <bos> @hoogle sleep
18:26:42 <lambdabot> No results found
18:26:51 <copumpkin> @hoogle threadDelay
18:26:51 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
18:26:51 <bos> @hoogle threadSleep
18:26:52 <lambdabot> No results found
18:27:07 <bos> copumpkin: thanks :-)
18:27:12 <copumpkin> :)
18:34:28 <sshc> Hi, why is GHC trying to construct an "infinite type" here?  treeToList :: (Ord a) => Tree a -> [a] <newline> treeToList EmptyTree = []  ...more pattern matchings that don't seem to affect it
18:37:09 <sshc> "data Tree a = EmptyTree | Node a (Tree a) (Tree a)"
18:37:24 <Twey> treeToList = map treeToList . subForest
18:39:09 <Draconx> sshc, there's nothing wrong with that snippet, so it must be something else.
18:39:10 <sshc> Twey: what's wrong with the code I pasted?
18:39:19 <sshc> ok.
18:41:16 <sshc> Draconx: nothing else is referring treeToList
18:41:28 <sshc> Draconx: the rest of the pattern matches are commented out
18:42:32 <Draconx> sshc, I suggest that you construct a test case.
18:46:31 * ksf decides to call set-bit "punch" and clear-bit "tape", from now on.
18:48:09 <Cale> sshc: Put that in a new file and see
18:48:30 <BMeph> sshc: Just FYI, it compiled just great for me... :)
18:48:59 * ksf can't think of a proper term for test-bit
18:49:29 <roconnor> @type set
18:49:31 <lambdabot> Not in scope: `set'
18:49:37 <roconnor> @type setBit
18:49:38 <lambdabot> forall a. (Bits a) => a -> Int -> a
18:49:45 <roconnor> :/
18:50:31 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8800#a8800
18:50:41 <Cale> sshc: ^^ there's the output on my machine
18:52:00 <Cale> sshc: Typically, infinite types arise when you try to treat the elements of a datastructure as the same type as the whole datastructure.
18:53:26 <Cale> :t let f (x:xs) = x ++ xs in f
18:53:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:53:28 <lambdabot>       Expected type: [a]
18:53:28 <lambdabot>       Inferred type: [[a]]
18:54:34 <Gracenotes> :S
18:54:54 <Cale> While there are very rare cases where programs involving infinite types would otherwise make sense, essentially all of the time it's a bug.
18:56:11 <ray> Doesn't occur check: cannot construct the finite type: a = a
18:56:31 <ray> or something :(
18:56:50 <Cale> The cases where a program involving infinite types would actually work and do something useful tend to require a lot of cleverness to construct.
18:57:42 <Cale> Like the Y combinator from traditional untyped lambda calculus.
18:57:44 <Draconx> can you define Y with infinite types?
18:57:50 <Draconx> I guess that's a yes :P
18:57:50 <Cale> yeah
18:58:13 <Cale> You can also write the same Y in Haskell if you don't mind wrapping and unwrapping a newtype.
18:58:34 <Cale> newtype Rec a = In { out :: Rec a -> a }
18:58:35 <Cale> y :: (a -> a) -> a
18:58:35 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
18:59:53 <sm> dangit.. has anyone else seen haskeline fail to print prompts in an emacs shell buffer ?
19:03:51 <ksf> sm, http://kerneltrap.org/mailarchive/git/2008/12/17/4443664
19:05:25 <ksf> ...that is, don't ever expect an emacs shell to behave in a sane way.
19:05:28 <ksf> it just doesn't.
19:06:00 <Cale> Does the emacs shell do something funny about buffering?
19:06:34 <ksf> it's just marginally more intelligent than a dot-matrix printer.
19:06:58 <ksf> ...and exactly that margin makes it unuseable.
19:07:03 <Cale> I can imagine if it was doing something dumb like line-buffering the output of the program, it would fail to print prompts...
19:07:49 <sm> it does various things, some which haskeline already deals with. But now I have seen test programs sometimes print the prompt and sometimes not and I'm wondering if any emacs user has noticed the same thing
19:09:38 <sm> I've spent a good number of hours chasing this darcs bug and now the blasted thing is working
19:12:12 <ksf> It's called "Occurs check", btw, because a binding checks its checked for occurences of free variables it is bound to. or rather types. but where's the difference.
19:12:26 <ksf> *its term
19:13:30 <ksf> ...only following type synonyms, though, not deconstructing adts or newtypes, that's why it can be tricked.
19:14:02 <SamB> ksf: it's not a trick!
19:14:25 <SamB> you're okay as long as the type terms have finite size ...
19:14:28 <ksf> nope, it's not. but you trick the occurs check.
19:14:47 <ksf> ...from that perspective, yes.
19:23:05 <monochrom> Everything is a trick.
19:23:44 <djahandarie> The cake is a lie.
19:24:07 * monochrom is a Lai
19:24:18 <copumpkin> :o
19:25:19 <defun-2> Hi guys. Des anyone here have any experience with FORTRAN? How does it compare to Haskell?
19:25:30 <copumpkin> defun-2: absolutely different
19:25:57 <defun-2> Any advanteges vs. haskell?
19:26:48 <defun-2> Though, very few langs have advantages over haskell... :)
19:27:12 <mmorrow> , 0x18
19:27:13 <lunabot>  24
19:27:29 <defun-2> 0x19
19:27:37 <defun-2> , 0x19
19:27:38 <lunabot>  25
19:27:58 <defun-2> Does haskell support hex?
19:28:44 <defun-2> > 0x19
19:28:45 <lambdabot>   25
19:28:53 <defun-2> nevermind
19:29:02 <defun-2> > 0x19 + 0x17
19:29:03 <lambdabot>   48
19:29:28 <defun-2> > 0x19 == 25
19:29:30 <lambdabot>   True
19:30:46 <nvoorhies> > 0xdefec8ed
19:30:47 <lambdabot>   3741239533
19:31:21 <aavogt> there are quite a few versions / varities of fortran, the same goes for haskell
19:32:02 <copumpkin> nvoorhies: :O
19:32:06 <copumpkin> nvoorhies: ROOD
19:32:39 <aavogt> @hoogle showHex
19:32:39 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:32:55 <aavogt> > showHex 3741239533 ""
19:32:56 <lambdabot>   "defec8ed"
19:39:23 <mmorrow> , 0xbeefface
19:39:24 <lunabot>  3203398350
19:47:28 <ksf> > 0xdeafbabe
19:47:29 <lambdabot>   3736058558
19:47:53 <ksf> does anyone feel like writing a dict bruteforcer?
19:49:04 <BMeph> , 0xdeadbeef
19:49:05 <lunabot>  3735928559
19:49:09 <ksf> ...it'd be cool if lambdabot had /usr/share/dict loaded, btw.
19:49:26 <BMeph> Cale!
19:50:44 <BMeph> mmorrow: Think you could help ksf out with his wish? ;)
19:51:32 <yrlnry> @pf \O fmap f x -> O((fmap (fmap f)) x
19:51:32 <lambdabot> Maybe you meant: bf pl
19:51:40 <yrlnry> @pl \O fmap f x -> O((fmap (fmap f)) x
19:51:40 <lambdabot> (line 1, column 35):
19:51:40 <lambdabot> unexpected end of input
19:51:40 <lambdabot> expecting variable, "(", operator or ")"
19:51:49 <yrlnry> @pl \O fmap f x -> O((fmap (fmap f)) x)
19:51:49 <lambdabot> (. join (.)) . (.) . (.)
19:52:31 <ksf> sometimes, haskell just looks like a very, very complicated joke.
19:52:34 <yrlnry> I just did:  data (O f1 f2 a) = O (f1 (f2 a))
19:52:34 <yrlnry> instance (Functor f1, Functor f2) => Functor (O f1 f2) where
19:52:34 <yrlnry>   fmap f (O x) = O ((fmap (fmap f)) x)
19:52:38 <yrlnry> Is this bizarre?
19:52:48 <MisterN_> yrlnry: no.
19:52:53 <yrlnry> Okay, thanks.
19:53:17 <yrlnry> What is bizarre?
19:54:11 * BMeph used to live about ten miles from a town named "Pe Ell"... :)
19:54:12 <ksf> exactly half of category-extras.
19:54:22 <ksf> the "co"-part
19:54:34 <copumpkin> ksf: :O
19:54:39 <copumpkin> :(
19:54:51 <copumpkin> BMeph: really? a terry brooks novel mentions that
19:55:04 <ksf> we should rename #haskell-blah to #cohaskell
19:56:35 <copumpkin> is there an "encyclopedia of algebraic structures" kind of book anyone knows about?
19:56:41 * copumpkin is in a math library and wants something like that
19:56:46 <MisterN_> yrlnry: there is a simple criterion for judging whether something in #haskell is bizarre
19:56:57 <MisterN_> yrlnry: if the author asks if it is bizarre, then it is not.
19:57:10 <Gracenotes> Wikipedia! :x
19:57:12 <MisterN_> for obvious reasons.
19:57:22 <ksf> ...if oleg comes along and says "this can be solved trivially"?
19:57:26 <yrlnry> The negation of that condition is necessary for bizarreness, but not sufficient.
19:57:28 <copumpkin> Gracenotes: I was hoping for some dead-tree-ness
19:57:33 <BMeph> If Conal MacBride comes on and asks you for details...then yeah, it's bizarre. ;)
19:57:38 <MisterN_> yrlnry: indeed.
19:57:42 <copumpkin> Conal MacBride??
19:57:45 <Gracenotes> perhaps an abstract algebra textbook? many weird structures are out there
19:57:47 <yrlnry> So what is bizarre?
19:57:50 <copumpkin> Conor McBride or Conal Elliott? :o
19:58:05 <Axman6> their kid
19:58:08 * BMeph facepalms
19:58:10 <Gracenotes> as for an encyclopedia.. hum..
19:58:16 <copumpkin> not sure they can have kids together easily
19:58:26 <Gracenotes> copumpkin: turkey baster
19:58:28 <MisterN_> yrlnry: that's much harder to answer.
19:58:29 <copumpkin> lol
19:58:32 <BMeph> s/Conal/Conor/
19:58:38 <Axman6> @faq can Conor and Conal have kids?
19:58:39 <lambdabot> The answer is: Yes! Haskell can do that.
19:58:40 <copumpkin> s/Mac/Mc/
19:58:54 <Badger> Haskell can have Conor and Conal's kids?
19:59:10 <MisterN_> Badger: no, it can _do_ that :)
19:59:22 <Badger> Oh.
19:59:25 <Gracenotes> it will have the string processing algorithm for combining their genes magically
19:59:38 <Badger> Is there a hackage package for this?
20:00:10 <ksf> oleg, btw, has always mystified me. in the tao, there is mention of a corporate eagle, which, occasionally, drops his message amidst the programmers. then there is mention of a master programmer. but there is no mention of a unison of both.
20:00:19 <mmorrow> ksf: oh man, /usr/share/dict/words is like 6MB... don't think ghc can handle that much static data
20:00:37 <ksf> well, load it at runtime?
20:00:52 <mmorrow> ksf: hmm, although i could just stick it into a char *dat[] = { }, then do the O(1) to-byteString function
20:01:00 <yrlnry> Aha, here's an example.  Conor McBride says that an example at http://www.haskell.org/pipermail/haskell/2002-February/008845.html is bizarre.
20:01:04 <Gracenotes> mmap
20:01:04 <yrlnry> And I agree, it is bizarre.
20:01:13 <ksf> mmap is a good idea.
20:01:14 <mmorrow> Gracenotes: yeah, or that
20:01:16 <ksf> bytestring-mmap
20:01:31 <mmorrow> hmm, ok i'll go with mmap
20:01:34 <ksf> ...though "lines" will be called quite often on it.
20:01:42 <mmorrow> yeah, that's what i'm worried about
20:01:49 <mmorrow> it may be unusable
20:02:08 <mmorrow> we'll see though
20:02:16 <ksf> ...but bytestring shouldn't copy, should it?
20:02:25 <MisterN_> yrlnry: it is also important to observe that bizarreness is not independent of context.
20:02:26 <Gracenotes> if not, some data structure. trie or somelike.. who knows..
20:02:32 <ksf> anyway, you can cache the line'd data, too.
20:02:35 <mmorrow> ksf: no it won't copy
20:03:17 <MisterN_> yrlnry: if this were not #haskell, most of the things talked about in here would be classified as Bizarre
20:03:27 <MisterN_> but it _is_ #haskell
20:03:44 <MisterN_> so people talk about point-free code as if it was the most normal thing to ever talk about
20:04:04 <copumpkin> you mean it isn't?
20:04:39 <MisterN_> copumpkin: it is, but only in #haskell
20:04:45 <copumpkin> really?
20:04:46 <copumpkin> damn
20:04:48 * copumpkin rubs his eyes
20:04:58 <Gracenotes> point free might not be so odd for Forth users
20:05:14 * Gracenotes involuntary imagines Forth and Atari goodness
20:05:15 <ksf> http://hackage.haskell.org/packages/archive/stringsearch/0.2.1.1/doc/html/Data-ByteString-Search-KnuthMorrisPratt.html on the raw data might still be the best idea.
20:05:48 <ksf> ...at least with lookups. enumerating is a whole different beast.
20:07:17 <Luke> is there a way to map over every element in a tuple?
20:07:21 <ksf> > matchSS "foo" "foobarfoo"
20:07:22 <lambdabot>   Not in scope: `matchSS'
20:07:23 <Berengal> > reverse (show pi)
20:07:25 <lambdabot>   "397985356295141.3"
20:07:28 <Berengal> :O
20:07:45 <ksf> > Data.ByteString.Search.KnuthMorrisPratt.matchSS "foo" "foobarfoo"
20:07:46 <lambdabot>   Not in scope: `Data.ByteString.Search.KnuthMorrisPratt.matchSS'
20:08:07 <Berengal> Luke, yes. In fact, there's one for each tuple type
20:08:17 <Luke> "each?"
20:08:28 <Luke> for an arbitrary lenght tuple?
20:08:31 <ksf> tuples are product types.
20:08:40 <Berengal> There are no arbitrary length tuples
20:08:58 <Luke> a 3x3 tuple
20:09:17 <ksf> a two-tuple already has map :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:09:33 <Luke> what about a 9-tuple?
20:09:41 <ksf> ...takes nine functions.
20:09:44 <Berengal> It too has a map, but it's different
20:09:45 <Luke> ah
20:10:14 <gwern>  @quote apfelmus
20:10:19 <gwern> @quote apfelmus
20:10:19 <lambdabot> apfelmus says: Haskell is the first programming language that really offers the possibility to specify data dependencies exactly as they are because Haskell is pure, higher order and has a powerful
20:10:19 <lambdabot> type system.
20:10:25 <Luke> i just applied a function for each one by hand. it seems bad =)
20:10:25 <gwern> @quote Apfelmus
20:10:25 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:10:46 <Berengal> "Tuple" isn't a type, it's just a common name for a group of types that sort of resemble eachother
20:10:48 <MisterN> @quote Luke
20:10:48 <lambdabot> No quotes match. :(
20:10:52 <gwern> @remember apfelmus Lambda Fu, form 72 - three way dragon zip: 'averages3 xs = zipWith3 avg xs (drop 1 xs) (drop 2 xs); where avg a b c = (a+b+c) / 3'
20:10:53 <lambdabot> I will never forget.
20:10:54 <ksf> there's of course homogenous tuples, too, where you only need to pass one function...
20:10:57 <gwern> @flush
20:11:03 <ksf> you should'nt work with tuples, btw, they're evil.
20:11:54 <copumpkin> :t let ennamap a b c d e f g h i (a1, b1, c1, d1, e1, f1, g1, h1, i1) = (a a1, b b1, c c1, d d1, e e1, f f1, g g1, h h1, i i1) in ennamap
20:11:55 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17. (t -> t1) -> (t2 -> t3) -> (t4 -> t5) -> (t6 -> t7) -> (t8 -> t9) -> (t10 -> t11) -> (t12 -> t13) -> (t14 -> t15) -> (t16 -> t17)
20:11:56 <lambdabot> -> (t, t2, t4, t6, t8, t10, t12, t14, t16) -> (t1, t3, t5, t7, t9, t11, t13, t15, t17)
20:12:24 * copumpkin dares mmorrow to write some fancy TH to do that
20:12:32 <copumpkin> scratch that
20:12:36 <twb> src/Darcs/Commands/Changes.lhs:23:41: Ambiguous occurrence `log' It could refer to either `Darcs.Commands.Changes.log', defined at src/Darcs/Commands/Changes.lhs:296:0 or `Prelude.log', imported from Prelude
20:12:39 * copumpkin DOUBLE DARES mmorrow to write some fancy TH to do that
20:12:41 <twb> How do I hide Prelude.log?
20:12:49 <copumpkin> import Prelude hiding (log)
20:13:05 <Luke> so forall can do it?
20:13:22 <twb> copumpkin: I was confused because Prelude wasn't explicitly imported at all
20:13:34 <copumpkin> twb: you get implicit prelude :)
20:13:41 <twb> Figures
20:14:11 <Gracenotes> Katamari Damacy soundtrack: hours of fun!
20:14:22 <MisterN> Gracenotes: there is no indication that #forth people talk about point-free code.
20:14:26 <twb> Gracenotes: obviously a double disc, then
20:14:46 <twb> MisterN: factor people (#concatenative?) do
20:15:22 <MisterN> twb: which gives me a valuable lesson.
20:15:24 <Gracenotes> MisterN: concatenative code is, by nature, pointfree. although it's part of the language, so not really explicit... and quite different from the LC-based Haskell way
20:15:29 <gwern> Gracenotes: hours? are you listening to, like, all of them?
20:15:38 <MisterN> be careful when saying "only in X"
20:16:10 <Gracenotes> uh. well, listening to one CD. But songs can be listened to more than once, particularly so if they are catchy!
20:16:44 <ksf> @djin (t -> t1) -> (t2 -> t3) -> (t4 -> t5) -> (t6 -> t7) -> (t8 -> t9) -> (t10 -> t11) -> (t12 -> t13) -> (t14 -> t15) -> (t16 -> t17)-> (t, t2, t4, t6, t8, t10, t12, t14, t16) -> (t1, t3, t5, t7, t9, t11, t13, t15, t17)
20:16:45 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
20:16:49 <ksf> @djinn (t -> t1) -> (t2 -> t3) -> (t4 -> t5) -> (t6 -> t7) -> (t8 -> t9) -> (t10 -> t11) -> (t12 -> t13) -> (t14 -> t15) -> (t16 -> t17)-> (t, t2, t4, t6, t8, t10, t12, t14, t16) -> (t1, t3, t5, t7, t9, t11, t13, t15, t17)
20:16:49 <lambdabot> f a b c d e f g h i (j, k, l, m, n, o, p, q, r) =
20:16:49 <lambdabot>     (a j, b k, c l, d m, e n, f o, g p, h q, i r)
20:18:45 <Gracenotes> I spy with my little eye two valid two-letter spanish words
20:19:12 <ksf> "no" and "en"?
20:19:41 <Gracenotes> hm. I was thinking of ir. but valid point, sir.
20:19:59 * ksf ne hasplas espanol
20:20:17 <MisterN> i can find a three-letter english word.
20:20:19 <Makoryu> :t (print <$>) <$> [1..10]
20:20:20 <lambdabot> forall a (f :: * -> *). (Show a, Functor f, Num (f a), Enum (f a)) => [f (IO ())]
20:20:21 <MisterN> two, actually
20:20:32 <Makoryu> :t (length <$>) <$> [1..10]
20:20:34 <lambdabot> forall a (f :: * -> *). (Functor f, Num (f [a]), Enum (f [a])) => [f Int]
20:20:35 <copumpkin> men, and fog?
20:20:37 <Makoryu> Whoops
20:20:39 <MisterN> copumpkin: yes
20:20:57 <Gracenotes> and "fab"!
20:21:03 <twb> Clearly you guys are even more bored than I am.
20:21:06 <Gracenotes> totally fab
20:21:06 <MisterN> fab is an english word?
20:21:13 <gwern> sure
20:21:17 <gwern> @wn fab
20:21:17 <copumpkin> I'm waiting for my ghc build to fail
20:21:20 <lambdabot> *** "fab" wn "WordNet (r) 2.0"
20:21:20 <lambdabot> fab
20:21:20 <lambdabot>      adj : extremely pleasing; "a fabulous vacation" [syn: {fabulous}]
20:21:32 <ksf> @wn fabbing
20:21:33 <lambdabot> No match for "fabbing".
20:21:39 <ksf> @wn fabing
20:21:39 <lambdabot> No match for "fabing".
20:21:43 <ksf> hmm
20:21:47 <MisterN> well
20:21:54 <ksf> there's "to fab".
20:21:55 <Gracenotes> "qir" sounds like it may be one of those suspicious q-without-u words
20:21:59 <MisterN> for me, fab is a word for silicone chip stuff
20:22:17 <Luke> is there a way to flatten a 3x3 tuple to a 9-tuple?
20:22:21 <ksf> also for rapid prototyping
20:22:24 <Makoryu> MisterN: For "fabricator?"
20:22:24 <MisterN> Luke: yes
20:22:35 <Luke> whats that called?
20:22:47 <Gracenotes> generally if you have that many items you should use lists or data declarations..
20:22:53 <MisterN> Makoryu: quite possibly. i only know "the new intel fab"
20:23:08 <Makoryu> @hoogle ((a,b,c),(d,e,f),(g,h,i)) -> (a,b,c,d,e,f,g,h,i)
20:23:08 <lambdabot> No results found
20:23:16 <Luke> damn =/
20:23:22 <Gracenotes> a 3x3 tuple and a 9-tuple are both distinct types, so a function must be explicit written
20:23:26 <ksf> @hoogle [[a]] -> [a]
20:23:26 <lambdabot> Prelude concat :: [[a]] -> [a]
20:23:26 <lambdabot> Data.List concat :: [[a]] -> [a]
20:23:26 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:23:31 <Gracenotes> however, "concat" can turn a 3x3 list into a single one
20:23:44 <Gracenotes> ..if needed
20:23:55 <MisterN> @djinn ((a,b,c),(d,e,f),(g,h,i)) -> (a,b,c,d,e,f,g,h,i)
20:23:55 <lambdabot> f ((a, b, c), (d, e, f), (g, h, i)) = (a, b, c, d, e, f, g, h, i)
20:24:32 <Gracenotes> darn it, I hate it when my firefox window randomly disappears
20:24:44 <ksf> @pl \((a, b, c), (d, e, f), (g, h, i)) -> (a, b, c, d, e, f, g, h, i)
20:24:45 <lambdabot> (line 1, column 8):
20:24:45 <lambdabot> unexpected ","
20:24:45 <lambdabot> expecting letter or digit, operator or ")"
20:24:45 <lambdabot> ambiguous use of a non associative operator
20:24:45 <Luke> what is djinn? it can make functions?
20:24:53 <MisterN> Gracenotes: how bizarre.
20:24:54 <ksf> @pl (\((a, b, c), (d, e, f), (g, h, i)) -> (a, b, c, d, e, f, g, h, i))
20:24:54 <lambdabot> (line 1, column 9):
20:24:55 <lambdabot> unexpected ","
20:24:55 <lambdabot> expecting letter or digit, operator or ")"
20:24:55 <lambdabot> ambiguous use of a non associative operator
20:24:58 <ksf> nah.
20:25:16 <Gracenotes> it is only skilled with 2-tuples
20:26:02 <Gracenotes> and looks like all my downloads are restarting..
20:26:04 <BMeph> BBIAB
20:28:25 <mmorrow> ksf: ok nice, it's fast enough, even with ByteString.words and then unpacking
20:28:29 <mmorrow> , [$ty| dict |]
20:28:32 <lunabot>  [] String
20:28:34 <mmorrow> , length dict
20:28:36 <lunabot>  479830
20:28:45 <mmorrow> , (take 10 . drop 10000) dict
20:28:47 <lunabot>  ["Algomic","Algona","Algonac","Algonkian","algonkian","Algonkin","Algonki...
20:29:32 <mmorrow> (couldn't import ByteString because of the name conflict with the Prelude and importing qualified is currently a pita with the ghc-api)
20:29:46 <dibblego> , any (== 'Boob') dict
20:29:47 <lunabot>  luna: Not in scope: data constructor `Boob''
20:29:55 <dibblego> , any (== "Boob") dict
20:29:57 <lunabot>  luna: out of memory (requested 1048576 bytes)
20:30:29 <mmorrow> sadly it's too massive to do much with..
20:30:45 <mmorrow> maybe if the rlimit is slightly higher
20:32:17 <Makoryu> , let over = (*1000) in drop (over 9000) dict
20:32:19 <lunabot>  []
20:35:14 <mmorrow> , any (== "Boob") dict
20:35:17 <lunabot>  False
20:35:26 <mmorrow> , any (== "zoo") dict
20:35:30 <lunabot>  True
20:35:34 <mmorrow> nice
20:35:40 <mmorrow> , any (== "boob") dict
20:35:42 <lunabot>  True
20:35:54 <mmorrow> , elemIndex "zoo" dict
20:35:57 <lunabot>  Just 479179
20:36:11 <mmorrow> s/sadly it's too massive to do much with../pfft/
20:36:13 <Gracenotes> hm.. linear search?
20:36:27 <mmorrow> linear search using linear search of each String :)(
20:36:28 <MisterN> , dict
20:36:30 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
20:36:31 <mmorrow> s/:)(//
20:36:35 <mmorrow> :)
20:36:40 <mmorrow> , length dict
20:36:42 <lunabot>  479830
20:36:51 <MisterN> , sort dict
20:36:56 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
20:37:02 <mmorrow> holy crap
20:37:28 <mmorrow> using bytestring-mmap, then ByteString.words, then fmap ByteString.unpack
20:37:54 <mmorrow> , transpose dict
20:37:56 <lunabot>  ["111111112222223333334444455566778899-AAaaaaAAaAAAaAAaAAAAAAAAAAaaaaAaAA...
20:38:03 <Gracenotes> , filter ("bob" `isInfixOf`) dict
20:38:06 <lunabot>  ["Abobra","amebobacter","Amoebobacter","Amoebobacterieae","bob","boba","b...
20:38:20 <ksf> ,length $ filter ("bob" `isInfixOf`) dic
20:38:21 <lunabot>  luna: Not in scope: `dic'
20:38:25 <ksf> ,length $ filter ("bob" `isInfixOf`) dict
20:38:28 <lunabot>  149
20:38:53 <ksf> , length $ concat dict
20:38:57 <lunabot>  4473882
20:39:00 <Gracenotes> eh
20:39:07 <mmorrow> i'm inpressed
20:39:11 <mmorrow> impressed
20:39:18 <Gracenotes> > 4473882/479830
20:39:20 <lambdabot>   9.32388971093929
20:40:14 <mmorrow> heh, the evaluator goes 300MB resident for
20:40:15 <mmorrow> , length $ concat dict
20:40:19 <lunabot>  4473882
20:40:50 <MisterN> , concat dict
20:40:52 <mmorrow> and to 180% cpu
20:40:52 <lunabot>  "108010-point10th11-point12-point16-point18-point1st220-point2,4,5-t2,4-d...
20:41:04 <MisterN> mmorrow: 180%?
20:41:06 <mmorrow> (there are 8 cores)
20:41:11 <MisterN> oh
20:41:19 <MisterN> so haskell can utilise multiple cores for that?
20:41:31 <mmorrow> ooh, just saw it top 200%
20:41:42 <MisterN> , reverse concat dict
20:41:43 <lunabot>  luna: Couldn't match expected type `[a]'
20:41:45 <mmorrow> MisterN: apparently so, which is semi-surprising
20:41:54 <mmorrow> i wonder where the parallelism is
20:42:07 <MisterN> what's for reversing strings?
20:42:08 <mmorrow> hmm, that may be from the parallel GC
20:42:19 <aavogt> , reverse $ concat dict
20:42:23 <lunabot>  "ZZZtZzzZZZsavyzzyzavyzzyznotegozzyZsymozyZmuhtyzaihtyZmehtyzksyZnayryZna...
20:42:29 <MisterN> oh, lol
20:42:33 <mmorrow> , concat . reverse $ dict
20:42:35 <lunabot>  "ZZZzZtZzZZzyzzyvaszyzzyvaZyzzogetonZyzomyszythumZythiazythemZyskZyryanZy...
20:42:40 <mmorrow> , concat . fmap reverse $ dict
20:42:42 <lunabot>  "0801tniop-01ht01tniop-11tniop-21tniop-61tniop-81ts12tniop-02t-5,4,2d-4,2...
20:42:47 <Axman6> , map (map toUpper) dict
20:42:49 <lunabot>  ["1080","10-POINT","10TH","11-POINT","12-POINT","16-POINT","18-POINT","1S...
20:42:54 <mmorrow> , concat . reverse . fmap reverse $ dict
20:42:56 <lunabot>  "ZZZtZzzZZZsavyzzyzavyzzyznotegozzyZsymozyZmuhtyzaihtyZmehtyzksyZnayryZna...
20:43:06 <Axman6> ,last $  map (map toUpper) dict
20:43:08 <lunabot>  "ZZZ"
20:43:25 <aavogt> , nub dict
20:43:27 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
20:43:35 <ksf> , length $ sort $ concat dict
20:43:35 <aavogt> , nub (concat dict)
20:43:40 <lunabot>  luna: out of memory (requested 1048576 bytes)
20:43:40 <lunabot>  Killed.
20:43:50 <mmorrow> possibly those memory pages are being retained in memory by the kernel between evaluator runs here (?)
20:43:51 <Gracenotes> target terminated
20:43:55 <mmorrow> (since it's using mmap)
20:44:10 <ksf> , sort $ concat dict
20:44:15 <lunabot>  luna: out of memory (requested 1048576 bytes)
20:44:21 <ksf> , sort $  dict
20:44:25 <mmorrow> does linux do that? (keep memory pages around after the prog that mmap'ed them has exited)
20:44:25 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
20:44:29 <mmorrow> probably not i guess
20:44:30 <Gracenotes> mmorrow: maybe rnf the entire dictionary.. although that might cancel out some benefits..
20:44:41 <mmorrow> , rnf dict `seq` ()
20:44:44 <lunabot>  ()
20:45:05 <mmorrow> Gracenotes: it mmaps "words.txt" into a ByteString, O(1)
20:45:46 <Gracenotes> , [$ty | sort ]
20:45:47 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
20:45:59 <Gracenotes> did I forgot a bar..
20:46:10 <Makoryu> , [$ty| sort |]
20:46:12 <lunabot>  forall a . Ord a => [] a -> [] a
20:46:13 <monochrom> A $ty walked into a bar ...
20:46:16 <Makoryu> Guess so!
20:46:34 <Gracenotes> hm. looks a bit offishesque either way.
20:47:14 <mmorrow> here's the module lunabot's using http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8803#a8803
20:47:25 <mmorrow> (unsafeCoerce to "convert" to a ByteString.Char8)
20:47:33 <mmorrow> (they're the same thing)
20:48:08 <MisterN> unsafe
20:48:23 <mmorrow> heh, yeah dictmmap is amusing
20:49:19 <MorkBork> http://www.nasa.gov/multimedia/nasatv/ <-- launching in a few minutes
20:49:25 <MorkBork> not many more left :P
20:49:26 <Berengal> After my success with unsafeExtendRuntime (I've seen one other person use that expression), I propose renaming unsafeCoerce to thereIsAProofButTheMarginCannotContainItCoerce
20:49:28 <MorkBork> watch one while you can
20:49:44 <Cale> http://www.theonion.com/content/video/is_using_a_minotaur_to_gore?utm_source=videoembed -- hehehe
20:49:50 <mmorrow> MorkBork: sweet!
20:49:56 <MorkBork> yea i know its OT
20:49:58 <MorkBork> but seriously
20:49:59 <MorkBork> its impressive
20:50:12 <MorkBork> and there arent many more launches before the shuttle program is terminated, you might never get to watch one again
20:50:21 <Berengal> Ooo, and happily flash works for once
20:50:35 <Gracenotes> oh, oh, fine
20:51:59 <Gracenotes> #space is the goto channel about these, btw
20:52:00 * Berengal wonders how the shuttle's computing power compares to his desktop
20:52:01 <monochrom> I guess you video linkers have never heard of #haskell-blah
20:52:26 <MorkBork> fine you know what
20:52:32 <MorkBork> when the asteroids come to destroy us
20:52:36 <MorkBork> im gonna tell nasa about you
20:52:41 --- mode: ChanServ set +o monochrom
20:52:52 --- mode: monochrom set -o monochrom
20:53:01 <MorkBork> there wasnt video linkers, there was just me
20:53:21 <MorkBork> dont be a hater
20:53:33 <MorkBork> oh, yea, that onion guy
20:53:34 <MorkBork> who cares
20:54:03 <monochrom> Your problem is you don't know when to stop. You just keep pitching your rhetoric.
20:54:05 --- mode: ChanServ set +o monochrom
20:54:07 <MorkBork> oh i see, you're canadian, and you're upset that canada doesnt have a shuttle program, now i understan
20:54:07 <Gracenotes> hush kids
20:54:09 <MorkBork> lol
20:54:12 <MorkBork> ill leave
20:54:12 <MorkBork> its fine
20:54:14 --- mode: monochrom set +b *!*@ip72-223-102-120.ph.ph.cox.net
20:54:26 --- mode: monochrom set -o monochrom
20:59:29 <ksf> , reverse $ concat dict
20:59:33 <lunabot>  "ZZZtZzzZZZsavyzzyzavyzzyznotegozzyZsymozyZmuhtyzaihtyZmehtyzksyZnayryZna...
21:00:00 <ksf> , permutations dict
21:00:02 <lunabot>  [["1080","10-point","10th","11-point","12-point","16-point","18-point","1...
21:00:14 <ksf> , permutations $ concat dict
21:00:16 <lunabot>  ["108010-point10th11-point12-point16-point18-point1st220-point2,4,5-t2,4-...
21:00:41 <ksf> , reverse $ subsequences $ concat dict
21:00:46 <lunabot>  Killed.
21:01:06 <ksf> 1000 new and exciting ways to kill lunabot.
21:02:30 <ksf> , sort $ reverse dict
21:02:34 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
21:05:58 <dmwit> ksf: sort is lazy enough that showing only the beginning of a sorted, reversed list is O(n) time.
21:06:10 <dmwit> (n the size of the list)
21:07:39 <copumpkin> since newtypes are supposed to have the same in-memory representation as the types they're "aliasing", if Const is a newtype constructor and I do map Const x, does that get translated to a nop?
21:08:44 <Cale> copumpkin: no, it's like map id
21:08:51 <copumpkin> ah, yeah
21:10:21 <ksf> mhh what about big-O analysis for haskell?
21:11:16 <ksf> ...I don't even know if it's possible to automatize, at all.
21:11:49 <ksf> probably fails due to halting.
21:13:09 <dons> copumpkin: right, its like map id
21:13:13 <dons> you'd need to write a rule
21:13:19 <copumpkin> ah :)
21:13:44 <dons> which might involved unsafeCoerce# :)
21:14:46 <monochrom> big-O analysis is just as hard for eager languages
21:15:15 * mmorrow just watched the space shuttle launch
21:22:46 <mmorrow> , (length . filter ("gni"`isPrefixOf`) . fmap reverse) dict
21:22:50 <lunabot>  23714
21:23:13 <mmorrow> , (length . filter (reverse "tion" `isPrefixOf`) . fmap reverse) dict
21:23:18 <lunabot>  7827
21:23:23 <mmorrow> , length dict
21:23:25 <lunabot>  479830
21:23:29 <dmwit> That's a lot of gerunds!
21:23:34 <mmorrow> heh
21:23:45 <copumpkin> :t isSuffixOf
21:23:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
21:23:50 <copumpkin> why not just use that?
21:23:54 <dmwit> pah
21:24:00 <dmwit> That's stupid.
21:24:17 * copumpkin drops his head in shame
21:24:17 <mmorrow> bah, Real Programmers reverse
21:24:30 <dmwit> That's stupid and ugly, and you're stupid and ugly.
21:24:37 <aavogt> @src isSuffixOf
21:24:37 * copumpkin grovels
21:24:38 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
21:24:49 <copumpkin> aavogt: I'll be sad if that's the real definition
21:25:02 <dmwit> Why?
21:25:08 <dmwit> It doesn't get much better than that, really.
21:25:09 <aavogt> copumpkin: how else would you do it?
21:25:13 <monochrom> esrever sremmargorp laer
21:25:34 <Axman6> @src isPrefixOf
21:25:35 <lambdabot> isPrefixOf [] _          = True
21:25:35 <lambdabot> isPrefixOf _  []         = False
21:25:35 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
21:25:37 <copumpkin> with an NFA!
21:25:38 <dmwit> isPrefixOf `on` reverse -- I guess
21:25:40 <copumpkin> :P
21:25:43 <Axman6> @src isInfixOf
21:25:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
21:25:51 <Axman6> heh
21:26:17 <dmwit> Okay, isInfixOf could maybe be done a bit more efficiently. =P
21:26:40 <monochrom> use the regexp "tion$"
21:26:41 <SamB> dmwit: almost certainly
21:26:54 <SamB> oh, yes, better than that anyway
21:27:06 <Axman6> it's a fairly lazy implementation though. could be worse
21:27:11 <SamB> yeah
21:27:21 <SamB> KMP still might be better though
21:27:42 <Gracenotes> I should really start packing for college
21:27:54 <Cale> There's a beautiful lazy implementation of KMP, but it's not quite a one-liner.
21:28:05 <SamB> Cale: well no duh ;-)
21:28:26 <SamB> a one liner of KMP would almost certainly be ugly, after all
21:28:42 <Axman6> Gracenotes: where are you going?
21:29:00 <Gracenotes> long island
21:29:09 <Cale> SamB: Either ugly, or sublime.
21:29:25 <mmorrow> , elemIndex "Kilimanjaro" dict
21:29:27 <lunabot>  Just 211337
21:29:32 <monochrom> losing land
21:31:25 <monochrom> > sort "long island" == sort "losing land"
21:31:26 <lambdabot>   True
21:32:04 <mmorrow> , sort "sand lilo"
21:32:05 <lunabot>  " adillnos"
21:32:06 <Gracenotes> truley. Also, in the event of nuclear NYC attack, we will probably be hit with toxic fumes very heavily
21:32:15 <mmorrow> , sort "sand lilo" == sort "long island"
21:32:16 <lunabot>  False
21:32:19 <mmorrow> grr
21:32:53 <dmwit> > sort "sand li' log" == sort "long island '"
21:32:55 <lambdabot>   False
21:32:58 <dmwit> aww
21:33:02 <Gracenotes> nil sand log
21:33:18 <mmorrow> nice
21:33:46 <defun-2> Can haskell/GHC support hot-swapping, so that code can be updated without stopping the system/program?
21:33:56 <copumpkin> no
21:34:01 <copumpkin> (not yet, anyway)
21:34:15 <dmwit> Check out what xmonad does, though, which is pretty darn neat.
21:34:15 <defun-2> copumpkin: so devs are working on it?
21:34:17 <SamB_XP> slightly less-well than C does, at the moment, I think
21:34:21 <copumpkin> defun-2: nope
21:34:38 <Gracenotes> dynamic reloading? I think there are facilities... most non-script languages don't have it
21:34:55 <copumpkin> well yeah
21:35:04 <defun-2> bummer.
21:35:05 <SamB_XP> though if you want to use a serialize-the-entire-state approach rather than a reload-bits-of-the-program approach, Haskell is probably better ;-)
21:35:15 <SamB_XP> defun-2: erlang is the king of that
21:35:26 <Gracenotes> factor seems to do it well
21:35:30 <defun-2> SamB_XP: how do I "serialize the entire state"
21:35:46 <dmwit> with Show ;-)
21:35:47 <SamB_XP> defun-2: depends!
21:36:13 <Gracenotes> with depends (TM)? sounds impractical..
21:36:22 <defun-2> SamB_XP: examples/tutorials/links would be nice :)
21:36:32 <defun-2> documentation too...
21:36:37 <SamB_XP> well, I think xmonad was offered as an example?
21:36:47 <dmwit> yi does it, too
21:36:49 <mjs22> i should have googled around to see if ghc worked on the new OSX before upgrading... :(
21:36:50 <defun-2> yeah, I wrote that down. Are there others?
21:36:55 <dmwit> There are libraries on Hackage to make it easier, as well, hold on.
21:37:12 <dmwit> ?hackage dyre
21:37:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dyre
21:37:25 <SamB_XP> mjs22: I believe there are simple hax you can do on your GCC install to make it sorta work
21:37:37 <SamB_XP> copumpkin seems to know them ;-)
21:37:51 <defun-2> thanks guys!
21:37:55 <copumpkin> mjs22: you can hack it, but it's not fun :P
21:38:00 <copumpkin> not hard either
21:38:07 <copumpkin> (not that I run snow leopard, so I don't know)
21:38:12 <copumpkin> but I see no reason for it not to work
21:38:13 <SamB_XP> you just have to hexedit some file ;-P
21:38:13 <dmwit> dyre is based on another library, but I can't for the life of me remember which one now.
21:38:24 <SamB_XP> (well, actually, a text editor would work fine too ;-)
21:38:25 <mjs22> yeah, i saw that.  i prefer to not hack up my machine.  fixes problems in one place, creates ones elsewhere
21:38:25 <copumpkin> SamB_XP: just text edit a file and move another one
21:38:28 <monochrom> Oh! lib version again?
21:38:31 <copumpkin> mjs22: not really...
21:38:37 <SamB_XP> copumpkin: I was kidding ;-)
21:38:42 <dmwit> s/based on/inspired by/, I guess
21:38:50 <copumpkin> aha :)
21:47:12 <erikc> snow leopard installed, lets see what i broke
21:47:41 <monochrom> slow neopard  <duck>
21:48:17 <copumpkin> erikc: your ghc probably won't work anymore
21:48:42 <ichigogo> anyone know anything about decompiling vb6? im willing to pay MO, paypal, check etc PM me
21:48:52 <copumpkin> ichigogo: wrong channel
21:48:57 <Gracenotes> neither will any Palm accessories you may own
21:48:57 <copumpkin> try #openrce
21:49:36 <ichigogo> k
21:55:16 <forgot> why is foldr able to handle infinite lists if infinite lists have no right end?
21:55:28 <dibblego> laziness
21:55:53 <monochrom> foldr (&&) likely is unable to handle infinite lists.
21:56:01 <SamB_XP> both foldr and foldl* start at the left
21:56:13 <SamB_XP> the difference is that foldl can't stop after eating just one
21:57:09 <forgot> in what case would you want to stop (give back a result without doing the calculation)?
21:57:53 <monochrom> foldr (&&) True [False, False, False]
21:58:10 <SamB_XP> or, say, what if you wanted to show the beginning of the result to the user?
21:58:36 <ray> this is where cale would show you some diagrams
21:58:39 <monochrom> foldr (:) [] [False, False, False]
21:59:15 <SamB_XP> anyway, it's surely useless for a fold over an infinite list to consume the entire list!
21:59:27 <forgot> so is foldr basically equivalent to foldl (reverse list)?
21:59:37 <gwern> so I have a strange error with one of my utility haskell scripts; it just exits successfully without doing anything, even though it's correct in ghci; when I fire up strace, the last lines are 'gettimeofday({1251521943, 632127}, NULL) = 0
21:59:43 <gwern> exit_group(0)                           = ?'
21:59:44 <ray> no
21:59:44 <monochrom> using a suitable "basically"
21:59:54 <gwern> I recently upgraded ubuntu and messed with /etc/group, could this be related?
22:00:00 <erikc> hehe yes indeed, that broke ghc :)
22:00:14 <ray> if it is equivalent it's by accident
22:00:28 <Makoryu> erikc: Uh-oh
22:00:36 <ray> basically, the right fold doesn't need to walk to the end of the list before it can apply f
22:00:36 <Makoryu> erikc: I didn't even consider that that might happen
22:00:48 <gwern> dmwit: dyre was based on hconf as hacked up and maiontaned by yi
22:01:13 <ray> the left fold does need to go to the end of the list before f can be applied
22:01:14 <dmwit> gwern: Ah, thanks.
22:01:28 <dmwit> defun-2: (did you catch that?)
22:01:34 <ray> > foldl (const 1) 0 [1..]
22:01:36 <lambdabot>   Add a type signature
22:01:46 <forgot> wait are you saying foldl actually goes from right to left?
22:01:47 <gwern> I can't say I really want to reinstall ghc to check whether that's the problem
22:02:04 <gwern> forgot: well, if you write left to right, then yes :)
22:02:15 <ray> > (foldl (const 1) 0 [1..]) :: Integer
22:02:16 <lambdabot>   No instance for (GHC.Num.Num (b -> GHC.Integer.Internals.Integer))
22:02:16 <lambdabot>    arisi...
22:02:26 <ray> er, i'm screwing this up somewhere
22:02:29 <forgot> so then which way does foldr go?
22:02:33 <monochrom> forgot: These over-simplifying questions will only confuse. I suggest walking through many examples of executions instead.
22:02:34 <dmwit> > foldl f z [a,b,c,d]
22:02:36 <lambdabot>   Ambiguous occurrence `f'
22:02:36 <lambdabot>  It could refer to either `L.f', defined at <local...
22:02:41 <dmwit> boo
22:02:42 <dmwit> ?undefine
22:02:45 <dmwit> > foldl f z [a,b,c,d]
22:02:47 <lambdabot>   f (f (f (f z a) b) c) d
22:02:53 <SamB_XP> gwern: and you basically have to right left to right unless you somehow mirror your text editor ;-)
22:02:54 <dmwit> > foldr f z [a,b,c,d]
22:02:55 <lambdabot>   f a (f b (f c (f d z)))
22:03:15 <ray> oh, i'm stupid
22:03:20 <dmwit> forgot: The 'l' and 'r' stand for left- and right-associative, respectively, referring to the function 'f'.
22:03:24 <ray> > foldl const 0 [1..]
22:03:30 <lambdabot>   mueval-core: Prelude.read: no parse
22:03:30 <lambdabot>  mueval: ExitFailure 1
22:03:37 <ray> > foldr const 0 [1..]
22:03:39 <lambdabot>   1
22:03:45 <forgot> > scanl1 (+) [1..10]
22:03:46 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
22:03:58 <forgot> no it goes left to right
22:03:58 <SamB_XP> actually, foldl has to traverse the list from left to right ... but it doesn't start doing anything usefull until it gets to the end of the entire list
22:03:58 <gwern> > foldl f z [1,2,3]
22:03:59 <lambdabot>   f (f (f z 1) 2) 3
22:04:20 <dibblego> forgot, foldl f k list ====> A r = k; foreach(x in list) { r = f(r, x); } return r;
22:04:35 <dmwit> Let's see, who has Cale's diagrams handy?
22:04:40 <ray> foldl doesn't apply f without hitting the end, foldr can apply f right away
22:04:43 <SamB_XP> foldl' works as it goes, but doesn't *tell* you anything unil afterwards anyway ...
22:04:55 <gwern> dmwit: isn't it just foldl.com?
22:04:56 <Draconx> dmwit, the ones on http://www.haskell.org/haskellwiki/Fold ?
22:05:01 <dmwit> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
22:05:03 <dmwit> has them
22:05:07 <SamB_XP> gwern: that's not Cale's
22:05:13 <SamB_XP> that's some dumb PHP script or something
22:05:14 <dmwit> Also the Haskell wiki, yes.
22:05:19 <ray> cale would have pulled out the diagrams long ago
22:05:23 <dmwit> forgot: You might be interested in the diagrams on the linked pages above.
22:05:41 <SamB_XP> ray: that's probably because Cale can remember where he keeps them ;-)
22:05:49 <ray> the right fold replaces all the :s with fs and the [] with z
22:05:57 <dmwit> So does the left fold.
22:06:05 <ray> the left fold sorta turns the list inside out, then does that
22:06:17 <forgot> i never thought that right fold is more natural then left fold, since i write left to right..
22:06:32 <SamB_XP> forgot: well, it is
22:06:43 <ray> keep in mind that a list is x : xs
22:06:44 <dibblego> forgot, do you know that the list [1,2,3] is syntactic sugar for 1:2:3:[] ?
22:06:53 <monochrom> I write top to bottom.
22:06:59 <SamB_XP> it's the catamorphism, and there is a large class of recursive datatypes that have them ...
22:07:06 <ray> and : associates right, so 1:(2:(3:[]))
22:07:47 <ray> and foldr applies a function in a right-associative way
22:07:52 <monochrom> What you mean is you add left to right, (1+2)+3
22:07:55 <dibblego> forgot, then the expression: foldr f k [1,2,3] is the same as 1 `f` 2 `f` 3 `f` k
22:08:14 <dibblego> (associating to the right)
22:08:29 <SamB_XP> dibblego: not the best clarification!
22:08:34 <forgot> so foldl is the same except it associates to the left..
22:08:37 <SamB_XP> add some parens for great justice
22:08:49 <dibblego> forgot, foldl is more like an imperative loop
22:09:12 <dibblego> foldl f k list ====> A r = k; foreach(x in list) { r = f(r, x); } return r;
22:09:32 <SamB_XP> of course, it works better if you use foldl' ;-)
22:10:08 <SamB_XP> in all but the strangest cases, none of which I can ever remember when this comes up :-(
22:10:14 <forgot> is reverse (foldr xs) then faster than foldl xs if foldr somehow avoids a bunch of steps?
22:10:39 <dibblego> no, reverse uses foldl'
22:10:54 <monochrom> The correct answer is "depends".
22:10:55 <SamB_XP> foldr doesn't avoid steps if you need the whole answer
22:11:01 <ray> i think you mean foldr (reverse xs)
22:11:06 <monochrom> The correct answer to all of your past and future questions is "depends".
22:11:27 <ray> usually you want either foldl' or foldr though
22:11:28 <SamB_XP> is x = x?
22:11:38 <ray> that also depends, dude
22:11:52 <SamB_XP> note that I said =, not ==.
22:11:56 <monochrom> This is really reducing Haskell to economics. "So higher demand leads to higher supply?"
22:11:58 <SamB_XP> so no going all Double on my ass.
22:12:00 <forgot> ray, oops
22:12:25 <ray> it depends on your choice of logic..
22:12:56 <SamB_XP> ray: in what logic is it not true?
22:12:56 <ray> if you're restricting it to haskell, my unsafe operations can break your referential transparency
22:13:25 <monochrom> There are logics in use where ⊥=⊥ is rejected.
22:13:29 <SamB_XP> ... and that is one reason why Haskell would make a lousy theorem prover ;-P
22:13:30 <ray> in any logic where you don't want it to be true
22:13:58 <SamB_XP> monochrom: most of the ones I use don't *allow* _|_
22:14:12 <ray> that doesn't mean those are the only logics
22:14:34 <SamB_XP> hmm.
22:14:49 <monochrom> Everyone knows most of the logics you use don't allow ⊥.
22:15:02 <SamB_XP> well, mostly I use Coq ;-P
22:15:39 <SamB_XP> and you could use ⊥ as a symbol for something -- but you aren't allowed to have non-terminating computations
22:15:55 <SamB_XP> ... it tends to make typechecking undecidable
22:15:59 <SamB_XP> or something like that
22:17:15 <gwern> monochrom: haskell is capitalism? that explains why so few wikipedians use haskell, as 'wikipedia is communism' (/digital maoism)
22:17:48 <SamB_XP> gwern: so ... I can blame the lack of spoiler warnings on China now?
22:18:25 <gwern> SamB_XP: in a harmonious work's paradise there are no spoilers! as that implies scarcity of information and hoarding, which inevitably leads to capital
22:18:27 <dm`> @src </>
22:18:27 <lambdabot> Source not found.
22:18:36 <SamB_XP> gwern: um.
22:19:18 <SamB_XP> a spoiler is a thing that might spoil (some of) a person's enjoyment of a work of fiction, such as a novel, film, or videogame.
22:19:36 <ray> i think i heard a whoosh just now
22:20:09 <gwern> ray: a whoosh? like that from the spoiler on the bourgeois muscle cars favored by the lumpenproletariat?
22:20:11 <SamB_XP> that doesn't have to do with scarcity, that has to do with allowing individuals some degree of control over the order in which they process information for recretional purposoes
22:20:22 <copumpkin> erikc: I bet you want to give x86_64 osx ghc a go ;)
22:20:46 * copumpkin tries to recruit more hackers to his cause :(
22:20:53 * copumpkin is rather sad
22:20:55 <dmwit> no no no spoilers make you go FASTER in the race!
22:20:56 <erikc> sounds like fun
22:21:15 <monochrom> What is your cause?
22:21:16 <SamB_XP> dmwit: hmm?
22:21:27 <SamB_XP> monochrom: getting GHC ported to OSX64
22:21:32 <erikc> does the native backend work on the x86_64d darwin abi?
22:21:41 <SamB_XP> erikc: nobody knows!
22:21:49 <erikc> hehe
22:21:56 <SamB_XP> he can't get the damn Makefiles to work
22:21:57 <copumpkin> the abi for x86_64 on osx is fully standard (finally)
22:22:05 <copumpkin> erikc: first things first, it seems almost impossible to even get an unregistered build going
22:22:22 <monochrom> If someone gives me the next 10 macbook pros in the next 10 years, one each year, I will join the cause.
22:22:37 * copumpkin has no money
22:22:40 <copumpkin> so that someone won't be me
22:22:44 <SamB_XP> that is, the procedure for building on a "new" architecture seems to be broken
22:22:51 <erikc> ah
22:23:09 <SamB_XP> copumpkin: have you reported bugs for the Makefile failures?
22:23:38 <copumpkin> SamB_XP: nope, because I'm not sure what's "supposed to happen" and what isn't, other than "it should fucking work"
22:24:21 <SamB_XP> copumpkin: well, you've found some .hc files that should be built and aren't and/or some .o files that aren't built
22:24:28 <copumpkin> it's a daunting process that has http://hackage.haskell.org/trac/ghc/wiki/Building/Porting written about it
22:24:38 <copumpkin> I guess I'll file a bug, since it seems hard to get anyone to notice me in #ghc
22:24:39 <SamB_XP> you can report THAT at least, as specifically-or-not as you know it
22:24:42 <copumpkin> fair enough
22:24:56 <vyom> http://www.haskell.org/haskellwiki/Prime_numbers anybody know if No. 8 IntSet has some upper limit ... if I do (sum (I.toList $ primes 1000000)) it gives me a negative value
22:25:09 <SamB_XP> I imagine those problems are rather easy to reproduce even with just *one* architecture available
22:25:10 <copumpkin> vyom: the maximum value of an int?
22:25:22 <SamB_XP> just by pretending to do a port ;-)
22:26:27 <SamB_XP> copumpkin: well, you get people to notice, but everyone who notices is too busy to work on the OS X port ;-)
22:26:35 <copumpkin> :P
22:26:44 <copumpkin> it's got an epic number of people following the trac ticket
22:26:51 <SamB_XP> however, there might concievably be people who *aren't* too busy to fix a generic problem with the Makefile
22:26:53 <monochrom> vyom: What should be the correct answer? Does the correct answer fit in 31 bits?
22:26:53 <copumpkin> you'd think if not one of the core hackers, I could get someone who cared
22:27:30 <SamB_XP> copumpkin: but who can say whether any of them have what it takes to fix the Makefiles?
22:28:01 <nego> Alright, it's go time!
22:28:14 <copumpkin> who knows, but it'd be nice to get some support from one or two of the CC'ers somehow P
22:28:19 <SamB_XP> nego: where are you going?
22:28:23 <vyom> monochrom:  will need to check that.. maybe not.. what is difference between Int and Integer
22:28:30 <SamB_XP> copumpkin: maybe if you run into any truly arch-specific issues?
22:28:46 <nego> SamB_XP: I'm finally gonna show these Haskell tutorials whos boss!
22:28:47 <vyom> Integer seems to support values higher than 31 bits
22:29:00 <monochrom> Int is machine int. Integer is unlimited internet access and airtime
22:29:05 <SamB_XP> vyom: it supports values as big as it can allocate
22:29:13 <SamB_XP> monochrom: no, no it isn't
22:29:19 <nego> No time for masterbate! Time to learn Haskell!
22:29:40 <SamB_XP> monochrom: though I must admit I'm finding it difficult to figure out how to connect it to my cellphone to prove this
22:29:54 <vyom> SamB_XP: where should I go looking some documentation for that?
22:30:21 <SamB_XP> vyom: what it IS is an arbitrarily-sized integral type
22:30:35 <SamB_XP> it can go ... really big
22:30:48 <monochrom> The Haskell98 report says so.
22:30:56 <monochrom> http://haskell.org/onlinereport/
22:31:06 <vyom> ok
22:31:17 <erikc> chuckle, emacs23 finally gets released with official cocoa support, snow leopard comes out a week later and emacs23 doesnt build anmymore :)
22:31:23 <SamB_XP> the specifics of how big are perhaps implementation-dependant in practice, but also way bigger than you need in practice ...
22:31:36 <SamB_XP> erikc: why doesn't it build?
22:31:48 <SamB_XP> undump doesn't work with -m64 ?
22:32:14 <idnar> monochrom: I'm not sure how to read "arbitrary precision integers" as "unlimited internet access and airtime"
22:32:15 <erikc> some changes in cocoa api stuff seems like
22:32:37 <monochrom> http://haskell.org/onlinereport/basic.html#sect6.4  is closer to the desired location
22:32:52 <erikc> and a huge mess of warnings about 64-bit issues (printf/scanf mismatches with type sizes)
22:33:07 <erikc> i just find the timing funny :)
22:36:38 <monochrom> If I design an online course for learning the Haskell98 report from cover to cover and charge every student CDN$1000, will you take this course?
22:37:01 <lament> twice!
22:37:17 <SamB_XP> lament: why's that?
22:37:54 <SamB_XP> you really want to give him CDN$2000 for something so likely not-all-that-usefull-after-all?
22:38:26 <purplepenguins> CDN$2000 sounds expensive
22:38:40 <monochrom> It's royally useful but it's really dry and sleep-inducing.
22:38:50 <SamB_XP> well, it depends on whether CDN is still > USD
22:39:04 <SamB_XP> but yeah, it would be expensive ...
22:39:41 <SamB_XP> hehehe, my dog is snoring again ;-)
22:39:49 * SamB_XP always finds that amusing for some reason
22:39:52 <monochrom> Your dog just tried my online course.
22:40:15 <SamB_XP> she can't dream of programming, you dummy!
22:40:18 <monochrom> I gave it unlimited internet access last night.
22:40:27 <SamB_XP> ... and airtime?
22:40:32 <monochrom> Yeah!
22:40:36 <SamB_XP> she doesn't even have a PHONE!
22:40:52 <monochrom> I installed a chip.
22:41:27 <SamB_XP> I'm sure that was pretty easy ... if it was a potato or corn chip!
22:42:19 <monochrom> Next time I will say "unlimited internet access and all-you-can-eat sushi buffet"
22:46:43 * SamB_XP finishes a piece of one of his birthday cakes, starts on a piece of the other ;-)
22:47:22 <Makoryu> So it seems the new version of OS X breaks GHC
22:47:55 <SamB_XP> Makoryu: yeah, they changed the default for gcc to -m64 instead of -m32
22:48:06 <Makoryu> Ah, that would do it, then
22:48:12 <SamB_XP> ... which isn't exactly what GHC was expecting ...
22:54:47 <Nereid_> SamB_XP: just a configuration thing though, I assume
22:54:59 <Nereid_> ghc config expects 32-bit, gcc compiles for 64-bit or something?
22:55:02 <zong_sharo> hm, i'm not shure, but probably i found a bug in vty
22:55:05 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8807#a8807
22:55:20 <SamB_XP> Nereid: yeah
22:55:24 <Nereid_> yeah
22:56:09 <zong_sharo> if last line of image uses not default attrs
22:56:31 <SamB_XP> it's probably not that hard to get it to work by either using a wrapper script or hacking a couple of the config files in a manner which copumpkin could have told you ... but he just had to leave the library he was in
22:56:34 <zong_sharo> and, when terminal window resized - all text rendered with this not default attr
22:56:54 <zong_sharo> please - anyone, try this stuff.
22:56:58 <zong_sharo> can you reproduce?
22:57:23 <SamB_XP> zong_sharo: it sounds very very believable!
22:57:37 <zong_sharo> or, maybe i just doing something wrong
22:57:41 <dibblego> my children are a testament
22:57:46 <monochrom> Not tonight, dear. I castrated myself this morning.
22:58:22 <zong_sharo> please, just run core from the paste and resize your terminal
22:59:12 <erikc> SamB_XP: digging a bit into getting emacs compiling: it seems some stuff on 32-bit side that was deprecated (e.g. NSFont widthOfString: ) simlpy doesnt exist on the 64-bit side
22:59:23 <SamB_XP> erikc: ah.
22:59:26 <SamB_XP> not too surprising
23:02:47 <Nereid_> ewwww, emacs ;)
23:07:26 <Rotaerk> @src sequence
23:07:26 <lambdabot> sequence []     = return []
23:07:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:07:26 <lambdabot> --OR
23:07:26 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:08:24 <Rotaerk> I don't understand why sequence uses foldr if it's supposed to evaluate each action left to right
23:09:04 <Rotaerk> since foldr applies liftM2 (:) from right to left
23:09:13 <SamB_XP> Rotaerk: not really
23:09:27 <SamB_XP> scroll up a bit ;-)
23:09:37 <SamB_XP> and/or check the public logs
23:09:45 <dolio> > sequence (Nothing : repeat (Just 1))
23:09:46 <lambdabot>   Nothing
23:10:37 <Rotaerk> hmm oh it's an effect of laziness
23:11:07 <monochrom> foldr does not say right-to-left anyway, despite attempts to over-simplify Haskell to business management.
23:11:11 <SamB_XP> yup!
23:11:29 <Rotaerk> sure it does
23:11:32 <Rotaerk> "foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left"
23:11:54 <monochrom> That is wrong. Is that in the official docs?
23:12:02 <Rotaerk> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr
23:12:36 <SamB_XP> monochrom: remember what obiwan said!
23:12:47 <monochrom> What did obiwan say?
23:12:57 <SamB_XP> about "a certain point of view"
23:12:58 <dolio> "Only imperial storm troopers are this precise."
23:13:10 <monochrom> haha
23:13:11 <SamB_XP> dolio: oh, yeah, that's a really funny quote
23:13:27 <SamB_XP> considering how lousy their aim usually seems to end up being
23:14:07 <monochrom> Never trust natural-language docs.
23:14:46 <monochrom> Recall that MIT teaches Python because this world is full of unreliable docs and we want to expose such reality to students!
23:15:20 <SamB_XP> monochrom: that's seriously what they put down on paper as why?
23:15:57 <monochrom> Not on paper per se. One of the SICP authors said it in a conference, then a listener wrote in on a blog.
23:17:03 <SamB_XP> but he'll admit he said that?
23:17:50 <SamB_XP> well, I gotta go to bed now ...
23:17:53 <SamB_XP> see yas!
23:18:00 <Rotaerk> hmm I get it now
23:18:07 <monochrom> The original meaning was that they use a real-world lib to play with robots, the lib has broken docs, and the lib happens to be a Python binding.
23:18:14 <Rotaerk> the docs threw me off a bit I guess
23:18:21 <idnar> http://danweinreb.org/blog/why-did-mit-switch-from-scheme-to-python
23:18:53 <gwern> SamB_XP: well keep in mind, the stormtroopers did conquer the galaxy
23:19:02 <monochrom> I just find it funny that you can describe Python itself equally well by that.
23:19:14 <gwern> so in the star wars universe maybe stormtroopers really are that good
23:19:49 <erikc> gwern: the storm trooper clones did, but at some point they musta started using humans instead...(im not sure thats actually confirmed anywhere tho)
23:19:57 <gwern> erikc: it is, in the EU
23:20:01 <idnar> erikc: why "must"?
23:20:02 <gwern> had to do a lot of retconning
23:20:28 <erikc> heh
23:20:42 <erikc> idnar: cause the stormtroopers suddenly started really sucking at their job :P
23:21:01 <gwern> idnar: well, because of episode 4, for starters, when tatooinians speak of going to the imperial academy to be, among other things, stormtroopers. tatooine wasn't settled by clones...
23:21:08 <idnar> erikc: eh, they're still pretty good when they're not going up against Jedi and other main characters
23:21:21 <idnar> gwern: oh, right
23:21:30 <gwern> not to mention the dozens and dozens of stormtrooper 1st person narratives which are not clones; and the fact that by the rebellion clones have long since been banned
23:21:55 <gwern> (although the funny thing is that if you read the EU books from before the prequels, *everyone* assumes that the clones were the bad guys trying to overthrow the old republic!)
23:22:14 <jauaor> so they changed to python because of stormtroopers?
23:22:38 * jauaor hopes he is following this conversation right
23:23:23 <monochrom> They switch to Python because the clones were the bad guys who overthrew the old Scheme.
23:24:42 <gwern> ('when we last met, you were the teacher and I the student; now *I* will school you!' 'only in destructive mutations, darth')
23:25:07 <monochrom> heh
23:25:41 <adh0c> that reminds me of that one XKCD strip that was actually pretty funny
23:25:44 <adh0c> http://xkcd.com/297/
23:25:48 <gwern> actually, the dark side describes imperative programming pretty well
23:26:08 <gwern> quick, easy, seductive, and draining
23:26:20 <jauaor> just give as assignment to the students ... to rewrite all those python libs partially to scheme... I bet they would learn a lot more :)
23:26:27 <adh0c> I wouldn't call it easy
23:26:51 <jauaor> it's mit
23:26:55 <adh0c> managing all the variables you have introduced gets pretty painful pretty quick
23:26:58 <gwern> adh0c: just drop in a few more variable updates and print statements!
23:27:13 <erikc> step through it in the debugger so you can see what it does man!
23:27:25 <gwern> as dark siders say, if your rage and hate aren't working, you aren't using enough
23:27:34 <adh0c> I actually like debuggers
23:27:46 * jauaor doesn't
23:28:35 <monochrom> Debuggers are the antithesis to code optimizations.
23:28:53 <adh0c> they're only tools
23:29:05 <adh0c> noone says you're supposed to actually optimize anything with them
23:29:29 <gwern> when your program doesn't work, fixing is optimizing
23:29:40 <erikc> debuggers are fine, but i've seen to many programmers using them as a crutch to figure out what code they wrote 5 mins ago does
23:29:57 <idnar> debuggers are the tactical nuclear warheads of software engineering
23:30:07 <adh0c> my old "good" C++ programming days...
23:30:13 <idnar> (wow, I think that's quite possibly the worst analogy I've constructed all month)
23:30:15 <adh0c> one-letter variables
23:30:43 <adh0c> to be honest, even trying to be descriptive in C++ usually fails
23:31:30 <idnar> adh0c: I always find it a bit amusing, after having "use meaningful variable names!" spewed at me over and over in the context of C++ etc.
23:31:40 <idnar> adh0c: to read Haskell code using one-letter variable names that's perfectly legible
23:32:21 <idnar> apparently, the solution to having variable names too generic for their purpose is to make their purpose more generic, not make their names less specific
23:32:51 <adh0c> if there's anything I can equate compiling C++ code to, then it is arguing with an old person
23:33:41 <adh0c> every minute detail has to be correct, and even then it might turn out something goes wrong
23:34:13 <adh0c> off-by-one are my favourite errors
23:35:38 <monochrom> No, I mean this. Code optimizations do so much rewriting of your code that it resembles nothing you wrote if you look at it through debuggers. Now, users of debuggers don't like that, they file complaints, and this translates to either shooting down some code optimizations or doing extra work to give debuggers extra information about how the optimized code relates to the original code.
23:36:20 <adh0c> why shouldn't it be changed if it is faster that way?
23:36:32 <erikc> monochrom: this was a pretty big problem when i was working at ibm on XL Fortran
23:37:00 <erikc> because of fortran's array notation, there's tons of juicy, regular loops that the optimizer can have a field day with
23:37:34 <adh0c> it's quite amazing how many fortran programs are still there
23:37:39 <erikc> unfortunately, customers try to debug the code and it makes no sense anymore (especially if you throw autoparallelization or autosimdization /w iteration peeling for alignment into the mix)
23:37:44 <adh0c> and they're running regularly
23:37:50 <idnar> > 0 ** 4
23:37:51 <lambdabot>   0.0
23:38:04 <idnar> why does the report make that undefined?
23:38:14 <adh0c> of course, they have moved from old mainframes
23:38:29 <erikc> so i wrote a program that regenerates the fortran source after high level optimization and remaps the debug information to the generated source
23:38:39 <dolio> Variables in Haskell are quite a bit smaller in scope than some variables in C++, so you can get away with shorter names a lot.
23:38:43 <erikc> it worked reasonably ok...
23:38:48 <adh0c> but the code written by someone in 1970s can still be found in a new aerodynamics simulation
23:38:56 <dolio> In C++, you might be referencing a variable that isn't even declared in the same file. :)
23:39:21 <idnar> dolio: they also tend to be a lot more general, though
23:39:27 <dolio> That too.
23:39:39 <idnar> you don't need a meaningful name for "x" in "id x = x" because it has no meaning
23:39:47 <idnar> it's just an arbitrary value
23:40:09 <erikc> adh0c: if all you need to do is number crunch over some arrays, Fortran is pretty decent, crap syntax tho
23:40:34 <erikc> the insanities of the latest Fortran standards (object-oriented fortran? really?) are unfortunate
23:40:51 <adh0c> speaking about insanities
23:41:08 <Makoryu> erikc: There's easily plenty of room today for a new array language
23:41:33 <Makoryu> Possibly even DPH, I guess
23:41:36 <adh0c> the Polish high school final exam for Computer Science demands you write your code in one of their preselected languages
23:41:42 <adh0c> and it wouldn't be that bad
23:41:54 <adh0c> if not for the fact that those are C, Pascal and C++
23:41:57 <adh0c> that's it
23:41:58 <Makoryu> adh0c: Java, C++, and... Haha
23:42:07 <adh0c> no, Makoryu
23:42:09 <Makoryu> Pascal would be all right if it wasn't so.... Pascal.
23:42:13 <adh0c> we used to have Java
23:42:31 <adh0c> unfortunately someone thought it was too innovative and it was removed
23:42:41 <dolio> The AP test for computer science used C++ (and only C++) when I took it.
23:42:51 <dolio> I think it may have been Pascal prior to that.
23:42:56 <dolio> I think they're on to Java now.
23:43:15 <Axman6> >_<
23:43:25 <adh0c> C++, the one and only
23:44:21 <Makoryu> The singular and immortal Sepples, leader of the free world
23:44:39 <adh0c> sepples to oranges
23:46:43 <dolio> I'm not sure whether I'd rather learn C++ or Java, looking back.
23:47:04 <leadnose> I'd rather never learned Java.
23:47:18 <adh0c> yeah, but comared to C++
23:47:22 <adh0c> I really don't know
23:47:28 <dolio> C++ actually has interesting stuff you can do with it. But you're unlikely to learn that in a high school course.
23:47:41 <leadnose> dolio, exactly.
23:47:56 <adh0c> I can't decide between the ultimate verbosity and must-be-oo of Java
23:48:30 <leadnose> java is just "okay, we have ints, float and objects, and you can define classes with methods and you have to write private public static final void everywhere and that's it"
23:48:46 <adh0c> and the mystifying can't-help-you-with-anything C++
23:48:48 <monochrom> I didn't mind the highschool course but I learned beyond it.
23:48:49 * jauaor has been happy coding in Objective-C lately
23:49:03 <jauaor> I think it is the closest to a proper low-level OO language
23:49:24 <Axman6> i don't like the cocoa libraries... mainly because i find them very confusing
23:49:33 <Axman6> i found Java's libraries far less confusing
23:49:45 <Makoryu> I remember when OOP was still an academic curiosity
23:49:50 <jauaor> java is a mess
23:49:56 <dolio> There's that new one...
23:50:13 <dolio> That looks vaguely like smalltalk, but beats lots of people on the shootout.
23:50:21 <jauaor> The Foundation libraries are very .... mm.. organized in my opinion , more than the java ones
23:50:23 <copumpkin> dolio: lua?
23:50:26 <Makoryu> dolio: Surely not F-Script?
23:50:32 <adh0c> looping over complex arrays and parsing read input are always headache inducing in C++
23:50:33 <dolio> Neither of those.
23:50:35 <adh0c> either way
23:50:36 <dolio> Isaac maybe?
23:50:39 <gwern> cilk?
23:50:44 <erikc> Makoryu: i think theres a good opportunity for a new array language, but the Fortran compilers are so mature that it will have to come out swinging
23:50:57 <gwern> how's Fortress been doing?
23:50:58 <jauaor> dolio: Lisaac ?
23:50:59 <dolio> Lisaac.
23:51:03 <jauaor> :)
23:51:03 <Makoryu> erikc: Then let it compile to Fortran.
23:51:15 <adh0c> I don't think there's a need for a new special-purpose language
23:51:16 <erikc> Makoryu: good thinking :)
23:51:24 <jauaor> yeah, Lisaac is a prototype based static typed language
23:51:28 <jauaor> it seems very cool
23:51:32 <jauaor> from the look
23:51:34 <adh0c> why make a new "array language"?
23:51:42 <erikc> gwern: only has an interpreter implementation so far
23:52:00 <monochrom> "prototype" and "static type" is a new combination to me.
23:52:07 * jauaor is right now writing the ultimate stack based language
23:52:21 <Makoryu> adh0c: Not a special-purpose language, and not a need, certainly... It'd just be nice to see more support for array programming, I guess
23:52:24 <jauaor> monochrom: that's Lisaac .... very interesting concept in my opinion
23:52:41 <adh0c> by writing a new language, do you mean implementing it?
23:52:42 <jauaor> monochrom: it is like a mix between Eiffel and Self
23:52:50 <jauaor> adh0c: yes
23:52:53 <jauaor> and designing
23:53:47 <jauaor> Like a mix between .... well ... _bunch_ of ideas I have had in my mind for a while ... haha :P
23:54:08 <adh0c> lisaac looks ugly
23:54:29 <jauaor> the syntax?
23:54:31 <adh0c> the amount of unnecesary language grammar reminds me of sepples
23:54:51 <dolio> Does it look uglier than its competitors, though? :)
23:54:58 <jauaor> Lisaac is supposed to be a low level language
23:55:00 <adh0c> what does it compete with?
23:55:08 <Makoryu> The name alone is gruesome... Sheesh
23:55:12 <jauaor> it is supposed to be a system language to write a pure OO operating system
23:55:16 <dolio> C, for one.
23:55:19 <jauaor> I think the syntax is very decent for such a purpose
23:55:27 <adh0c> jauaor, what the world needs is a low-level language that you can write maintainable code in
23:55:40 <jauaor> adh0c: I think Lisaac goes further there
23:55:54 <adh0c> sure, it's decent, but it's only so better than C
23:56:08 <jauaor> its sintax is pretty much a mix between Eiffel and C
23:56:14 <jauaor> not really
23:56:22 <jauaor> it resembles Eiffel too
23:56:30 <jauaor> and you have static typing
23:56:40 <Makoryu> Oh god
23:56:45 <Makoryu> http://shootout.alioth.debian.org/u32q/benchmark.php?test=fannkuch&lang=lisaac&id=1
23:56:56 <Makoryu> It reminds me of COBOL
23:57:35 <adh0c> there's some unspoken ugliness and clumsiness to languages like C++ that I can't really express precisely
23:58:49 <jauaor> I have been playing abit with objective c .... and i think it is a nice option for oop in low level
23:59:02 <adh0c> I think it's the generic lack of support for prototyping and the amount of brackets and semicolons
23:59:13 <adh0c> plus all the variables you have to worry about
23:59:24 <jauaor> objc is a mix between smalltalk and c ....... lisaac is a mix between eiffel and c
23:59:41 <Makoryu> jauaor: The Obj-C dispatch system isn't all that low level. It's basically a full-blown dynamically typed Smalltalk environment with lots and lots of inline C
