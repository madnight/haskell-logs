00:00:00 <ray> linux desktop
00:00:22 <ray> it was fun to finally play half-life 2, incidentally
00:00:24 <copumpkin> mmorrow is hiding!
00:00:29 <ray> it was just as good as everyone said
00:00:38 <mmorrow> :)
00:00:45 <edwardk> mmorrow gratz on 1.0 =)
00:01:03 <copumpkin> dammit, my package keeps failing :(
00:01:24 <hackagebot> enumerable 0.0.2 - A typeclass for enumerating all values a type (DanielPeebles)
00:01:31 <mmorrow> edwardk: thanks. i figured i was going nowhere slowly with the "0.0.XX" version scheme, so i figured i'd bump it to 1.0.0 ;)
00:01:35 <copumpkin> what am I doing wrong? :(
00:01:36 <edwardk> copumpkin: use the test upload?
00:01:45 <copumpkin> edwardk: I do, but it reports no errors
00:01:53 <copumpkin> it gives me the nice preview page
00:01:58 <edwardk> copumpkin: and open up your tar.gz and look and see if it has anything else in it
00:02:00 <copumpkin> and then I upload and cabal install, and that fails
00:03:05 <copumpkin> it doesn't appear to :/
00:03:47 <ray> wow, there's 2 copies of every file in there
00:03:53 <copumpkin> ??
00:03:56 <ray> file and ._file
00:04:10 <copumpkin> oh, it's mac os's fucking tar
00:04:25 <mmorrow> @yarrrr
00:04:26 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
00:04:38 <ray> you should sue apple
00:04:45 <ray> they made you waste two hackage version numbers
00:04:52 <copumpkin> yeah :/
00:04:56 <copumpkin> the thing is, when I untar it here
00:05:00 <copumpkin> it magically recombines the forks
00:05:03 <copumpkin> so I don't see the _ files
00:05:05 <edwardk> was that made by cabal sdist?
00:05:20 <copumpkin> nope, I was just using tar
00:05:23 <copumpkin> never tried sdist :)
00:05:26 <edwardk> use cabal sdist
00:05:36 <edwardk> see if its smart enough to do the right thing
00:05:45 <edwardk> and if not, bug duncan ;)
00:05:50 <ray> upload it somewhere else before hackage though :)
00:06:11 <copumpkin> ooh so smart
00:06:25 <mmorrow> i use "darcs dist"
00:06:34 <mmorrow> (i dunno what the difference is though)
00:06:55 <copumpkin> can someone check http://dl.getdropbox.com/u/361503/enumerable-0.0.3.tar.gz ?
00:07:00 <copumpkin> to see if it contains any evil underscores?
00:07:15 <ray> looks evil file free here
00:07:23 <edwardk> doesn't darcs dist use every file you've checked into darcs while cabal sdist uses just the files named via the .cabal file?
00:07:23 <copumpkin> thanks :)
00:07:30 <edwardk> which may include stuff not checked into darcs
00:08:01 * Axman6 is upset that his Binary [a] instance is far more wasteful in terms of memory usage than the current one :(
00:08:13 <edwardk> in memory usage? why?
00:08:26 <hackagebot> enumerable 0.0.3 - A typeclass for enumerating all values a type (DanielPeebles)
00:08:29 <Axman6> not sure, probably something tp do with the use of (++)
00:08:36 <edwardk> oh
00:08:36 <edwardk> yeah
00:08:38 <edwardk> evil
00:08:39 <copumpkin> whee!
00:08:43 <copumpkin> yay cabal sdist
00:08:45 <edwardk> try swapping to using difference lists internally
00:08:48 * copumpkin slaps himself for using tar by hand
00:08:53 <mmorrow> :)
00:09:10 <Axman6> edwardk: link?
00:10:28 <edwardk> Axman6: just replace your lists you are building up with (++) with functions of the form [a] -> [a] -- so now (++) becomes (.), etc.
00:10:40 <edwardk> then when you are all done apply the function to []
00:10:53 <edwardk> i think dons hass some DList module or other that makes it automatic
00:11:00 <edwardk> but they aren't hard to do by hand
00:11:09 <Axman6> hmm, i've seen it done before, but i can't remember how
00:11:17 <edwardk> i had written an article on them, but it got lost during a crash a year or so back
00:11:17 <Axman6> i'll check it out
00:11:22 <Axman6> :(
00:11:54 <edwardk> http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html
00:12:03 <edwardk> they append cheaply
00:12:10 <edwardk> tthey are used inside of Text.Show for that very reason
00:12:14 <edwardk> @src ShowS
00:12:14 <lambdabot> type ShowS = String -> String
00:12:21 <edwardk> @type showsPrec
00:12:23 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
00:12:33 <edwardk> @type showString
00:12:34 <lambdabot> String -> String -> String
00:12:37 <edwardk> @type showChar
00:12:38 <lambdabot> Char -> String -> String
00:12:45 <edwardk> @src showChar
00:12:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:12:53 <edwardk> @src Text.Show.showChar
00:12:53 <lambdabot> Source not found. Sorry.
00:12:57 <edwardk> gah
00:13:54 <Axman6> hmm, seems i'd need a helper function
00:13:54 <edwardk> i hate src, it rarely seems to do what i want it to do
00:13:54 <mmorrow> @src showsChar
00:13:54 <lambdabot> Source not found. Do you think like you type?
00:13:54 <mmorrow> @type showsChar
00:13:54 <lambdabot> Not in scope: `showsChar'
00:14:26 <edwardk> Axman6: not so much, it can usualy be done inline
00:15:32 <edwardk> one way to do it would be
00:15:40 <edwardk> newtype List a = List ([a] -> [a])
00:15:50 <edwardk> and just make your List type the difference list in question
00:15:52 <edwardk> then
00:16:33 <edwardk> but you'd have crappy performance for Put
00:16:36 <copumpkin> so EMGM does everything (minus functions) my class does and more, with generics
00:16:48 <edwardk> EMGM?
00:17:04 <copumpkin> http://hackage.haskell.org/package/emgm-0.3.1
00:17:14 <copumpkin> but it's buried in a module in there
00:17:27 <edwardk> heh
00:17:37 <Optimo> sup geeks
00:17:54 <copumpkin> wow, an Optimo
00:18:08 <Optimo> I can has kell?
00:18:42 <Optimo> I seem to poke my head in here right before a hangover nap
00:18:53 <Optimo> adios
00:18:55 <copumpkin> :P
00:18:58 <purplepenguins> booze and haskell go together
00:19:13 <purplepenguins> like satin and stucco
00:19:35 <BMeph> Like leather and lace? ;p
00:20:01 <purplepenguins> like horses and riding crops
00:20:12 <Optimo> like booze and haskell
00:20:13 * Axman6 likes where this is going
00:20:45 <purplepenguins> like monads and functors
00:21:18 <Axman6> :t (<$>)
00:21:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:21:29 <Axman6> :t (<*>)
00:21:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:21:36 <BMeph> Like zippers and zygohistoprepromorphisms! ;p
00:21:57 <Optimo> triple word score
00:21:59 <purplepenguins> the tale of two typeclasses
00:24:17 <copumpkin> Axman6: what's the current binary [a] instance do?
00:24:36 <copumpkin> your instance is for extra large lists by writing them in chunks, it seems?
00:25:05 <Axman6> yeah, the current one does put (length xs) >> mapM_ put xs
00:25:12 <copumpkin> ah
00:25:26 <copumpkin> yeah, that does seem iffy I guess
00:25:26 <Axman6> so, limited by the size of Int, and also forces the whole list
00:25:57 <copumpkin> I like the idea
00:26:40 <copumpkin> length will only force the spine of the list btw
00:26:51 <Axman6> i know
00:27:02 <Axman6> but it means that memory usage is terrible for large lists
00:27:09 <copumpkin> yeah
00:27:13 <Axman6> sadly, my version is much worse -_-
00:27:29 <copumpkin> Axman6: probably not an inherent property of that way of serializing the list, right? :P
00:27:42 <copumpkin> you just accidentally force something you shouldn't in your code somewhere?
00:28:52 <Axman6> i think it's the xs <- sequence (replicate num get); List ys <- get; return (List (xs ++ ys)) part, since it can't really return anything until the whole thing has been read in
00:29:04 * blackdog hums "didja ever enter a thunk, with a pointer you shouldn't have"
00:29:26 <copumpkin> why do you need btake by the way? isn't splitAt good enough?
00:29:50 <copumpkin> I guess to save yourself calculating the length of the first list after already traversing it once?
00:30:03 <Axman6> it might be, but i wanted to avoid having to then use length on the list. but now i think of it, the length will be small anyway
00:30:22 <copumpkin> shouldn't be the end of the world :)
00:30:31 <Axman6> yeah
00:30:43 <copumpkin> > splitAt 10 [1..4]
00:30:44 <lambdabot>   ([1,2,3,4],[])
00:31:57 <Axman6> yeah
00:43:27 <copumpkin> Axman6: if instead of using Word16 you serialized it as whatever-size int they do now, but never wrote more than 65536 elements
00:43:33 <copumpkin> you could stay backwards-compatible with the current binary format
00:43:44 <copumpkin> well, to a degree at least
00:43:49 <Axman6> yeah
00:44:16 <copumpkin> anyway, it'd be cool to see that make it back into Binary
00:45:39 <Axman6> shame it's no better than the current one
00:45:50 <Axman6> slightly worse in face
00:45:54 <Axman6> i fact
00:46:01 <Axman6> rawr, stupid n key
00:51:50 <erikc> #c++ is terrifying, but i cant stop looking
00:52:58 <SubStack> ##php is like that too
00:56:51 <blackdog> Axman6: nice to see you take on the binary instance for List
00:57:04 <blackdog> that bites you all over the place - Map serialisation used it too, last time i looked
00:58:43 <copumpkin> mmorrow: now I'm tempted to write an Enumerable instance for haskell syntax types :P
00:58:58 <copumpkin> then I'll magically have written all possible haskell programs
00:59:16 <Axman6> blackdog: yeah, it's a shame :(
00:59:30 <blackdog> copumpkin: preemptively claim copyright :)
00:59:37 <copumpkin> blackdog: yeah!
01:00:05 <blackdog> of course, if someone uses a haskell program to launch the missiles, you'll be morally culpable
01:00:12 <Gracenotes> -.-
01:00:12 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
01:00:31 <mreh> Is the global flag the default for "$ cabal install"
01:00:32 <copumpkin> crap, maybe I shouldn't then
01:00:39 <copumpkin> mreh: no
01:01:16 <mreh> copumpkin, thanks
01:09:40 <pardus> is there ghc for arm?
01:10:34 <erikc> pardus: it exists, but im not sure what it's release state / licensing is (it's being contributed by a group doing commercial iphone dev)
01:15:09 <tommd> pardus: You can find those guys in #haskell-iphone
01:16:13 <tommd> pardux, erikc: Oh, and last I heard they moved to BSD3 and away from the restrictive license they had before.
01:16:56 <pardus> and ghc-arm has native codegen?
01:16:57 <tommd> pardus: Do you have a device you are particularly interested in running Haskell on?
01:17:13 <tommd> pardus: You'll have to ask blackh or another member in haskell-iphone.
01:17:27 <pardus> tommd, two NAS. one is DNS-323 and the other one is Kurobox/pro
01:18:34 <tommd> pardux: Interesting - I didn't know NAS builders were smart enough to go ARM (I ran into a line of x86 based nas not long ago).  Thanks for mentioning it.
01:18:53 <tibbe> @seen bos
01:18:53 <lambdabot> I saw bos leaving #ghc, #haskell and #haskell-in-depth 1h 13m 29s ago, and .
01:19:43 <jekor> I'm getting a parse error when trying to create a cabal package: Parse of field 'license' failed. (source: License:       UnknownLicense "AGPL"). What am I doing wrong?
01:20:28 <pardus> tommd, I'm talking about devices for home use (and not about thouse iSCSI beasts)
01:42:08 <maltem> In re the module hierarchy revamping discussion, I've noticed that people tend to prefer to keep the Data/Control/... prefixes because they make the documentation easier to navigate. Couldn't this be done with by ordering documentation by package first?
01:46:38 <p_l> tommd: actually, powerpc seems quite common in NAS and other "heavier" embedded devices
01:47:37 <p_l> I haven't yet seen a x86 one, though
01:47:51 <p_l> (other than heavy-weight class like those for Windows Home Server)
01:51:04 <gwern> suppose I had something like [a, [a, a] a]; how could I print this out (what library) as a tab-indented tree and not the usual Show list?
01:57:58 <ziman> won't occurs check bite you? ([a] = a)
02:00:34 <gwern> mm. probably; sure I can hack around it
02:05:58 <mreh> can I upgrade GHC with cabal?
02:06:08 <gwern> no
02:06:21 <mreh> awww, why not?
02:06:22 <gwern> GHC is not cabalized, and may well never be
02:06:36 <gwern> too complex, and impedes bootstrapping iirc
02:06:47 <mreh> does a GHC version encompass more than the base packages?
02:07:41 <gwern> yes - the actual compiler itself...
02:08:20 <mreh> but i can still upgrade my base package?
02:08:45 <mreh> i suppose it depends
02:09:19 <gwern> yes, but you don't want to
02:09:33 <mreh> I come from the world of Java, where the language specification is changed between compiler versions
02:10:24 <mreh> I can't get OpenGL to work with base 3.0.1.0, so I kinda do need to upgrade it :(
02:10:44 <mreh> infact, I think the whole thing needs dependency of base >= 4
02:11:19 <gwern> as I said, you don't want to upgrade base without upgrading ghc; doing so is begging for trouble
02:11:38 <gwern> you'll get all sorts of link errors
02:11:56 <gwern> and I think you're guaranteed to never be able to use the GHC API again because of the diamond dependency
02:12:15 <ray> you might want to upgrade your ghc
02:12:30 <gwern> and who knows what other problems will be caused
02:13:28 <mreh> Debian never got ground to packaging 6.10, oh well...
02:13:33 <hrehf> morning
02:13:50 <mreh> afternoon
02:14:15 <gwern> some places don't have times of day, you insensitive clods!
02:14:53 <mreh> you haven't read about Time Cube!
02:14:57 <ray> don't let debian hold you back
02:15:53 <ray> i am pretty sure debian packages will still have ghc 6.8 in 5 years
02:17:12 <mreh> heh
02:17:35 <int-e> debian unstable has 6.10.4. there's some hope ;)
02:17:51 <mreh> oh
02:22:03 <mreh> I don't even remember there being a "Lenny" in toy story
02:24:17 <gwern> was he the t-rex?
02:24:17 <mreh> oh, binoculars
02:24:29 <mreh> no, the binoculars guy
02:24:37 <gwern> ah
02:24:39 <mreh> t-rex was "rex"
02:28:28 <mreh> does anyone know even how to begin upgrading ghc by hand? How do I ensure I keep my install packages?
02:29:19 <FlashGordon2000> it seems corporate fat cats are at it again
02:29:20 <FlashGordon2000> http://internetshouldbeillegal.com/
02:31:31 <mreh> NOO
02:31:39 <p_l> FlashGordon2000: wtf is with the keywords of that site? "dickroll,internetshouldbeillegal,internet should be illegal,shocksite,meatspin,rickroll,2girls1cup,tubgirl"
02:31:42 <EvilTerran> ?where ops
02:31:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
02:31:55 * p_l couldn't see the contents....
02:33:07 <EvilTerran> p_l, some stupid video that's clearly got nothing to do with "corporate fat cats". didn't watch it far enough to see what it was, but with those keywords, it almost certainly doesn't belong in this channel.
02:34:19 <p_l> EvilTerran: Yeah, I got saved from it due to flash not working xD
02:34:57 <p_l> (or more like, due to having a stupid DAC instead of a soundcard, as is common these days)
02:35:10 <Athas> What's the relationship between the 'base' library, GHC, and the Haskell standard?
02:35:51 <EvilTerran> "base" is a load of modules provided with GHC to cover the same functionality as the modules listed in the standard, albeit with heirarchical names
02:36:13 <EvilTerran> the "haskell98" package that comes with ghc has the modules as listed in the standard
02:36:51 <Athas> So base is developed together with GHC?  Are base releases synchronised with GHC releases!
02:36:58 <Athas> Err, replace the ! with a ?.
02:37:11 --- mode: ChanServ set +o mauke
02:37:21 <EvilTerran> mauke++
02:38:11 --- mode: mauke set -o mauke
02:39:16 <preflex> (?where ops)
02:39:25 <mauke> wtf
02:39:40 <mauke> oh, I'm stupid
02:59:50 <fbru02> hey all i want to do a small program that read contents of a file and prints it to screen (cat ) but I want to limit the quantity of this reads to ten per session. Should i use a ReaderT over IO ?
03:01:22 <tibbe> fbru02: 10 bytes?
03:01:46 <fbru02> tibbe : no, more like 10 reads, a user can read 10 files and that's it
03:01:46 <tibbe> fbru02: what's "session" in this case? program run?
03:01:54 <fbru02> yes, a program run
03:02:20 <tibbe> fbru02: so the user enters up to ten files on the command line?
03:02:56 <fbru02> yes, the user does that and he gets the contents displayed, it is a simple stupid program to practice what ive learnt so far
03:03:07 <tibbe> fbru02: I see
03:03:26 <tibbe> fbru02: you could pass the number of files read so far in your loop. Example:
03:03:37 <mauke> supply = replicate 10 readFile ++ repeat (const $ return "")
03:04:22 <tibbe> myLoop 0 = putStrLn "No more files for you!"; myLoop n = do file <- promptForFileName; cat file; myLoop (n - 1); main = myLoop 10
03:05:54 <fbru02> cool that seems easier that what i thought, tibbe, what's the case when a Reader is needed ?
03:06:12 <MarcWeber> nominolo|uni: Do you really think we should users ask to use vimball? Updating using a git repository will a) ensure the vim version always fits the server version b) make updating easier
03:07:08 <tibbe> fbru02: you could use a reader (using the 'local' function) but it's overkill in this case. I would use a reader when I pass around configuration data which is only used in a few places. Explicitly threading the data through all functions is annoying in this case.
03:08:01 <kkaji`>  http://www.lostworlds.lv/go.php?1139723800 NEW WEBSITE GAME,COME AND PLAY
03:08:16 <tibbe> fbru02: Reader abstracts away parameter passing. That only makes sense if most functions don't care about the parameter being abstracted away (the count in this case)
03:08:29 <tibbe> fbru02: State would have worked in this case too
03:09:01 <PeakerWork> tibbe: they have "ask" so why would they care?
03:09:20 <fbru02> tibbe : thanks i will do your implementation and the do the overkills just for learning purposes
03:09:38 <Philippa> tibbe: not true, it also makes sense if it's mostly the same thing being passed - it means you can't mess up the plumbing
03:09:40 <tibbe> PeakerWork: not sure what you mean, if every function calls 'ask' then you might as well pass the parameter explicitly
03:09:56 <tibbe> Philippa: as in confusing parameters?
03:10:18 <Philippa> tibbe: or any other way you can manage to mess up and make it typecheck, yeah
03:10:36 <tibbe> Philippa: true. A newtype might be less invasive in that case though
03:10:52 <tibbe> Philippa: and if you have to call local and change the value as in this case you could still mess it up
03:11:51 <Philippa> yeah, but at least then you've highlighted where the potential mess is. And the moment you've got two, the monad approach wins neatly because you can just throw a transformer on. Likewise if anything might want to do error-handling, even locally
03:12:56 <fbru02> Philippa so you prefer the monad approach?
03:14:34 <Philippa> fbru02: yep. It scales nicely
03:15:06 <tibbe> fbru02: try both and get a feel for the differences
03:15:40 <tibbe> Philippa: shouldn't every recursive function be a Reader then?
03:16:11 <Philippa> tibbe: FWIW, if every function calls ask then you still get a win whenever you call two different functions that care
03:16:48 <Philippa> and nah, it doesn't exactly help make map or foldr - but then, they'd be calling both ask /and/ local each round
03:17:01 <Philippa> *help make map or foldr clearer
03:18:17 <tibbe> Philippa: right, I think that was my point, this example would call ask and local each loop
03:18:20 <Philippa> (that, and their natural specification is recursive and it obscures that
03:18:27 <PeakerWork> tibbe: if you use "ask" you can use a big ReaderT newtype so you don't have to worry about changing all your code if more implicit arguments are added
03:18:44 <tibbe> PeakerWork: that's true
03:18:59 <tibbe> PeakerWork: that's a little bit like keyword arguments
03:19:29 <tibbe> PeakerWork: another way to achieve that would be to pass in a record and use a selector to get the field you care about. That way you can add fields to the record
03:19:53 <Philippa> that's less resilient to change and forces you to pick a record encoding
03:20:17 <Philippa> fbru02: technically you never need to use Reader, State etc. They're just something to use when it makes things easier
03:20:36 <PeakerWork> tibbe: Yeah, but the transformer technique also allows adding non-Reader transformers
03:20:42 <Philippa> but you'll get a feel for when Reader makes things worse. Don't use State if Reader will definitely do, either
03:20:52 <Philippa> PeakerWork: non-argument, you can do that either way
03:21:05 <tibbe> PeakerWork: true, you may need lifting however
03:21:05 <PeakerWork> Philippa: you can't add ContT to the record :)
03:21:23 <PeakerWork> tibbe: not if you use all of the transformer's layers by named lifters exported by the abstract newtype
03:21:49 <Philippa> guys? I think you're way past offering fbru02 anything useful here
03:22:01 <tibbe> Philippa: yes
03:22:34 <PeakerWork> Philippa: I didn't know this was about fbru02, I just barged in to say something in the middle of work :)
03:22:35 <tibbe> fbru02: summary: either way would work. I would experiment with both.
03:23:25 <fbru02> PeakerWork and all , this is a part that i also don't get, when is newtype { ...} deriving (Monad) useful, and when is creating a new instance of Monad and manually specifing return and bind for that monads useful?
03:23:58 <Philippa> the latter is useful when you'd write a different instance
03:24:12 <Philippa> (which, if you're comfortable with transformers, is almost never)
03:24:21 <PeakerWork> fbru02: whenever you can "deriving (Monad)" its nicer than having to specify them yourself
03:24:24 <Philippa> (at least, if you're happy trusting your compiler's optimisation abilities)
03:24:29 <PeakerWork> fbru02: when you can't, specifying it yourself is useful :)
03:25:17 <Philippa> deriving (Monad) is clearer for readers, too
03:26:27 <fbru02> ah now it makes sense, sometimes let's say you want to implement a Bayesian monad, you can do that with ReaderT and WriterT but maybe at the end it is easier to do it yourself because , it is too many layers to define the behaviour you want
03:27:17 <PeakerWork> fbru02: Defining many layers is easy, you just use "newtype" on a big transformer stack, deriving Monad, MonadTrans, etc, and then you write named lifters for the layers. Then the code which uses this monad uses the newtype and named lifters
03:27:27 <tibbe> fbru02: with a newtype you could also hide how the monad stack is composed
03:28:07 <fbru02> thanks !! ... but defining the instance may be better performance wise ? right?
03:29:06 <Philippa> fbru02: if it's too many layers, you /really/ don't want to do it manually
03:29:20 <Philippa> and... it may be, but don't worry about it unless it turns out to matter
03:29:25 <Philippa> profile first, optimise later
03:29:47 <fbru02> thank you guys i will quit now and try to figure more stuff by myself writing code
03:29:50 <Philippa> there's a big difference between how things'll behave in ghci or hugs and how they'll behave in GHC -O2 on
03:30:04 <PeakerWork> newtype MyMonadT m a = MyMonadT { runMyMonadT :: StateT GUIState (ReaderT CommandData (ContT m)) a } deriving (Monad, MonadTrans, MonadIO) ; liftGUIState = MyMonadT ; liftCommandData = MyMonadT . lift ; callCCSomething = MyMonadT . lift . lift . callCC
04:18:46 <ksf> tibbe, Reader also makes sense when passing big records.
04:19:06 <ksf> ...you can safe typing work with acessor functions and stuff.
04:19:08 <tibbe> ksf: I'm not sure how? Could you please explain?
04:37:54 <dcoutts> jekor: did you work out the license thing?
04:39:07 <mreh> waaah, I've install OpenGL 1.3, and GLFW complains it can't see it
04:39:21 <mreh> OpenGL 2.3*
04:40:18 <mreh> if I can see the module in ghc-pkg, then it's definately installed and visible (without brackets)
04:44:34 <int-e> how does it complain? do you have a user/global install problem, perhaps?
04:44:57 <mreh> Setup: At least the following dependencies are missing:
04:44:57 <mreh> OpenGL >=2.1
04:45:41 <int-e> try Setup config --user
04:46:44 <jekor> dcoutts: I switched it to OtherLicense.
04:46:59 <dcoutts> jekor: right
04:48:00 <dcoutts> jekor: the syntax would have been "license: AGPL" but sincei it's not a 'known' license you would not be able to upload that to hackage, so OtherLicense is the right choice.
04:53:10 <bremner> ugh, AGPL. For people who find GPL not enough of a pain in the ass.
04:54:21 <int-e> it still beats AllRightsReserved
04:55:21 <ksf> trac seems to be suffering from python.
04:55:45 <ksf> especially "Custom Query", which errors out with a locked database error consistently.
04:59:39 <maltem> ksf, would you prefer an issue tracker in Haskell? “Sorry, our host doesn't provide enough memory to process your query.” :P
05:00:37 <ksf> I would be able to cope with trac's sluggishness if it indeed worked, if that's what you mean...
05:01:23 * maltem hasn't yet seen an issue tracker that indeed just worked, to be honest
05:01:31 <mreh> "The SOE source code requires no installation once GLFW is installed.  Simply place the SOE code where you want it, load any module into GHCi, and hope for the best!"
05:02:00 <ksf> especially nice are those that make you create an account just to browse bugs.
05:02:03 <mreh> Wouldn't you agree it would be nice to have a single installation of one piece of software rather than having to copy it everywhere
05:03:16 <maltem> mreh, I suppose typing those instructions was less work then writing a cabal file
05:03:55 <mreh> maltem: good idea
05:05:37 <hackagebot> hake 1.3.3 - make tool. ruby : rake = haskell : hake (YoshikuniJujo)
05:10:58 <pardus> why there is not something like threadJoin in Concurrent?
05:12:03 <Lemmih> pardus: It's not necessary, I think.
05:15:29 <pardus> yep maybe. I should stop thinking in pthread primitives
06:06:00 <nainaide> I am confuse on The Error monad definition :  class (Monad m) => MonadError e m | m -> e where
06:06:49 <nainaide> why does  MonadError take two arguments
06:07:21 <mauke> so it knows which error type you want to use
06:07:23 <fbru02> nainade : i think that is call a functional dependecy
06:07:24 <Lemmih> nainaide: One for the error, one for the monad.
06:07:56 <nainaide> what does  " | -> e" means
06:08:02 <fbru02> s/call/called
06:08:17 <Lemmih> nainaide: It means that 'e' is determined by 'm'.
06:08:43 <nainaide> Lemmih, thanks
06:09:57 <nainaide> fbru02,  what do you mean about a functional dependecy?
06:10:33 <PeakerWork> nainaide: basically, MonadError is like the Either monad, with a type-class restriction on the Left to be an instance of Error
06:10:45 <PeakerWork> Left's type, that is
06:12:26 <fbru02> yeah i guess that an instance of the typeclass Error cannot be any monad but an MonadError
06:12:30 <nainaide> PeakerWork, yes
06:16:48 <nainaide> I just notice type class can have multiple arguments.
06:18:05 <nainaide> but I still dont understand " | " syntax in "MonadError e m | m -> e"
06:18:33 <nainaide> Is "|" an operator?
06:18:39 <mauke> no
06:18:55 <mauke> it's just random syntax
06:19:16 <Lemmih> nainaide: Read as: 'm' uniquely determines 'e'.
06:20:20 <nainaide> Lemmih, I see, but where can I find the "|" definition?
06:20:35 <Lemmih> nainaide: That /is/ the definition.
06:20:59 <fbru02> nainade no definition for | like no definition for ->
06:21:32 <nainaide> fbru02, Lemmih, :)
06:22:43 <nainaide> fbru02, Lemmih, I had thought I can find some description about "|" from haskell book.
06:23:06 <fbru02> nainade : there is description in chap 15 of RWH
06:23:28 * EvilTerran reads "class MonadError e m | m -> e" as "class MonadError has two parameters, e and m, where m uniquely determines e"
06:23:32 <nainaide> fbru02,  that is what I want! GREAT thanks!
06:23:43 <EvilTerran> ie, reading "|" as "where" and "->" as "uniquely determines"
06:25:39 <nainaide> EvilTerran,  got it.
06:26:39 <cdiem> hi, I' fairly new in haskell; how can I debug a simple program - defining a multiplication function
06:26:42 <cdiem> from YAHT
06:26:46 <cdiem> here's the program
06:26:52 <cdiem> module Main
06:26:52 <cdiem>     where
06:26:52 <cdiem> mult a b =
06:26:52 <cdiem> 	if b == 0
06:26:52 <cdiem> 		then a
06:26:53 <cdiem> 		else (a + (mult a (b-1)))
06:27:11 <mauke> by thinking
06:27:14 <cdiem> it gives me: mult 5 2    --> 15
06:27:17 <axzs> then 0
06:27:19 <cdiem> yeah :)
06:27:35 <mauke> 5 * 0 is not 5
06:27:38 <cdiem> oh, it was that simple
06:27:49 <cdiem> thanks, I'm used to debugers in other languages
06:27:58 <burp> you can use ghci for debugging
06:28:09 <mauke> how would a debugger have helped you with this?
06:28:17 <trofi> :t Debug.Trace.trace
06:28:18 <lambdabot> forall a. String -> a -> a
06:28:49 <cdiem> uhm, I could check the program flow in an imperative language; here I was lost; I guess being new, I'm just not used to it enough
06:29:18 <mauke> int mult(int a, int b) { return b == 0 ? a : a + mult(a, b - 1); }
06:29:18 <cdiem> thanks for the help :)
06:29:43 <cdiem> yeah, with '0' it works :)
06:29:58 <cdiem> thank you
06:30:38 <axzs> with -XEmptyDataDecls I can write data Empty. Is it possible to write the function f :: Empty -> a?
06:30:39 <Gracenotes> induction seems to come more naturally with FP. see if the base case works, see if the next case works, and convince yourself that an extra level will always work
06:30:42 <cdiem> how exactly would I use ghci in the above case?
06:31:18 <cdiem> I'll try to figure it out
06:31:39 <cdiem> thanks
06:32:25 <mauke> axzs: f _ = undefined?
06:32:41 <axzs> oh, simple. thanks
06:32:47 <mauke> f = undefined
06:32:53 <mauke> works for all types :-)
06:34:27 <cdiem> gracenotes, it was a very good advice; I haven't thought about it in such a way.
06:35:20 <mauke> axzs: data Empty has no non-bottom values. can you create such a type in Haskell98?
06:35:50 <axzs> don't know. GHC allows it only with that flag
06:36:32 <mauke> wrong "it"
06:37:30 <axzs> it could be a type which is never inhabited, like forall a. a
06:38:13 <mauke> yeah, but forall isn't in H98 either :-)
06:40:25 <pardus> cdiem, "The haskell school of expression",  Chapter 11 "Proof by induction". I think this will be a good starting point for you
06:43:36 <cdiem> pardus: thanks :)
06:44:23 <mauke> newtype Empty = E Empty
06:44:35 <axzs> it is inhabited by E (E (E ...)))
06:44:49 <axzs> or that doesn't count?
06:45:05 <mauke> that's the same as id (id (id ...)))
06:45:16 <mauke> it's a newtype; it has no structure
06:45:28 <axzs> ah, yes.
06:45:30 <mauke> it's all recursion, like fix id
06:46:09 <axzs> thanks, very interesting
06:48:03 <nainaide> I remembered.  -> is a type constructor for funtion, so, for purefuncion,  m -> e can say m unique determine e
06:49:07 <nainaide> Now I understand "class (Monad m) => MonadError e m | m -> e where  ", a little silly, :)
06:53:45 <fbru02> nainaide  it is not that difficult if you grasp it i think , it is only to say that instances of new Monads you define of MonadError , can be used as the original typeclass (MonadError)
06:55:18 <nainaide> fbru02, yes, I see. you are right!
07:04:05 <nainaide> fbru02, I thinks I also found "|" has the same meaning in the above "| m->e" , in "[a+b | (a,b) <- xs]" and even in data defination.
07:04:35 <nainaide> it is so easy to omit it until it confuse me. :)
07:05:12 <fbru02> nainaide yeah , it looks great in list comprehension but not as as great in clas definitions
07:05:41 <Berengal> I prefer type families to functional dependencies... At least aesthetically
07:06:05 <Berengal> 'class MonadError e where type Error e :: *' looks a bit nicer, and makes a bit more sense
07:07:16 <Berengal> You won't have (MonadError m e) => m a -> Either e a, but (MonadError m) => m a -> Either (Error m) a
07:08:07 <nainaide> Berengal, yes.
07:08:13 <Berengal> MPTC with functional dependencies just aren't MPTCs imho, and that confuses me
07:08:25 <fbru02> Berengal do you have a link where i can read about type families ?
07:09:45 <Berengal> fbru02, http://www.haskell.org/haskellwiki/GHC/Type_families
07:09:54 <fbru02> thanks
07:11:44 <Berengal> fbru02, also, the MemoTrie package uses them. You might gain some insights by looking at its source
07:12:10 <fbru02> Berengal perfect i will
07:27:32 <mightybyte> Anyone know how much overhead the +RTS -s option imposes?
07:28:07 <benjorino> Hello
07:28:33 <Axman6> mightybyte: well, it's only really there for debugging no?
07:28:34 <benjorino> Can anyone tell me how to convert an integer into a list of its digits in base 10 ?
07:28:51 <randomwords> mightybyte: I think it's pretty insignificant
07:28:51 <Axman6> > map digitToInt . show $ 12345
07:28:53 <lambdabot>   [1,2,3,4,5]
07:29:14 <Axman6> @index digitToInt
07:29:14 <lambdabot> Data.Char
07:29:27 <benjorino> I <3 you
07:29:36 <Axman6> i know, but shhhh
07:29:51 <mightybyte> randomwords: That was my initial observation
07:32:30 <HugoDaniel> back
07:32:38 <Raevel> wb
07:32:46 <HugoDaniel> thanks :)
07:33:39 <Lemmih> mightybyte: The data is always collected.
07:34:06 <Lemmih> mightybyte: What does your query look like? I'm sure it can be written more efficiently.
07:36:49 <mauke> potentially interesting problem: http://golf.shinh.org/p.rb?find+minimum+cyclic+parts
07:38:50 <RayNbow> mauke: hmm, so basically given a string S, we have to find the smallest string T such that S \in T* ?
07:39:13 <mauke> yeah
07:39:47 <mauke> it doesn't have to be fully generic, actually; it just has to produce the expected output for the three sample inputs given
07:45:00 <benjorino> Axman6: my first haskell program now works- solved project euler problem 20. Many thanks!
07:45:12 <Axman6> s'ok
07:49:20 <redbrain> hi i've been using haskell for a good while now for some projects but i've only started to need a gui framework so i used the GTK bindings because my stuff is for linux but what happens if i need to port this to a mac soon and no idea what gui framework works i haven't been keeping up to date on haskell :S
07:50:10 <redbrain> or does gtk work ok on a mac or is there bindings to the cocoa framework
07:51:11 <RayNbow> hmm mauke, my function is 64 characters
07:53:40 <mauke> RayNbow: 1) write program  2) submit  3) ?  4) profit!
07:54:12 <RayNbow> mauke: my program will be a bit larger though, since it would require an import and a main definition :p
07:54:16 <Saizan_> redbrain: gtk works on mac, afaik, maybe not so well natively
07:54:35 <redbrain> hmm ok maby i'll just wait untill i get the mac to dev on :P
07:54:48 <redbrain> really no idea where to start on it though :)
07:54:49 <skorpan> hm, why hasn't anyone uploaded a hackage package with all the euler project solutions yet?
07:55:05 <badsheepy> surely that would ruin the point of it :p
07:55:38 <Saizan_> skorpan: they already complained about the solutions on the wiki
07:57:12 <mauke> someone just improved the best haskell solution by one char
07:58:15 <skorpan> best == shortest?
07:58:27 <mauke> yes
07:58:35 <tomh-> lol
07:58:43 <Raevel> skorpan: there are solutions on the haskell wiki, iirc
07:59:14 <redbrain> Saizan_: thanks btw :)
07:59:17 <skorpan> i'm not looking for the solutions, i just figured since so many people have used haskell to solve them all, it's a bit surprising
08:00:07 <randomwords> skorpan: Whatever purpose the haskell code might serve, it's not best served as a hackage package
08:01:05 <randomwords> if people want to look at how a specific problem is implemented in haskell they can look on the PE forum for that probelm, or on the haskell wiki. A package of all the code would just percipitate mindless cheating
08:04:24 <RayNbow> mauke: http://golf.shinh.org/p.rb?find+minimum+cyclic+parts <-- 3rd place in the Haskell ranking
08:04:32 <mauke> RayNbow: I know :-)
08:04:51 <mauke> RayNbow: but why do you have 1 control character in your source?
08:06:24 <RayNbow> hmm?
08:06:48 <RayNbow> my source consists of two lines
08:07:11 <mauke> 1 binary, 77 alphanumeric, 19 punctuation
08:07:23 <RayNbow> hmm...
08:07:43 <RayNbow> perhaps it counts \r as binary?
08:07:50 <mauke> could be
08:09:09 <Saizan_> http://golf.shinh.org/bas.html <- it seems so
08:28:29 <RayNbow> mauke: shaved a few bytes off using shorter names, less parens, less spaces and Unix newlines
08:44:30 <mauke> RayNbow: you know you don't need a final newline, right?
08:45:24 <RayNbow> I know
08:45:25 <RayNbow> hmm
08:45:52 <RayNbow> I just noticed my function works for the sample input
08:45:55 <RayNbow> but not in the general case :p
08:46:00 <mauke> same here :-)
08:46:10 <mauke> failing input: aba
08:46:27 <RayNbow> same :p
08:46:55 <mauke> hmm, list comprehension version is the same length
08:48:52 <RayNbow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8239#a8239 <-- this is what I submitted
08:49:20 <mauke> that's almost literally my code
08:49:29 <mauke> down to variable names
08:49:57 <mauke> but mine is one character shorter, tee hee
08:50:02 <RayNbow> :p
08:50:03 <PeakerWork> why is Haskell doing so poorly over there at the golf? :)
08:50:08 <RayNbow> I'm not happy about line-ing and then unline0ing
08:50:15 <mauke> because Haskell is really verbose
08:50:16 <PeakerWork> hey, C beats it there :)
08:50:56 <RayNbow> Peaker: the Prelude lacks a short interact function that applies a given String->String function on a line-by-line basis :p
08:50:59 <PeakerWork> where's the source to see?
08:51:11 <mauke> PeakerWork: nowhere, this is a contest
08:51:16 <PeakerWork> RayNbow: unlines . map f . lines ?
08:51:24 <RayNbow> that's too long :p
08:51:25 <mauke> 13day(s) and 0:27:02 before deadline (08/30 01:06:48 JST), all source codes will be revealed after the deadline
08:51:25 <PeakerWork> mauke: ah
08:51:53 <PeakerWork> its more interesting to have a minimum number of tokens, smallest AST or something
08:52:15 <mauke> RayNbow: also, the main algorithm in my perl code takes only 11 chars AND is correct for all inputs
08:52:20 <PeakerWork> and I think you should be allowed to use any lib you want, provided you created it before the contest
08:53:04 <PeakerWork> AST size/token count may suck, but its much better than a character count
08:53:17 <mauke> it's not better, it's just different
08:53:36 <PeakerWork> well, character count measures nothing unless you count shifted chars as 2 keypresses, and then it measures keypresses :)
08:53:48 <mauke> character count measures characters
08:53:59 <PeakerWork> nothing of interest, that was
08:54:19 <mauke> er, this is a game
08:54:26 <PeakerWork> AST size is probably much closer to the conceptual size, which is more interesting
08:54:58 <mauke> I don't know if AST size even makes sense in Perl
08:55:02 <mauke> I know token count doesn't
08:55:23 <RayNbow> in before Perl cannot be statically parsed :p
08:55:45 <pikhq> RayNbow: Nor dynamically.
08:55:46 <mauke> just like Lisp and C++
08:56:01 <pikhq> perl does not parse Perl.  >:D
08:56:14 <mauke> pikhq: how do you define Perl?
08:56:23 <pikhq> mauke: Very painfully.
08:57:03 <PeakerWork> mauke: C++ cannot be statically parsed? What do you mean?
08:57:10 <PeakerWork> mauke: example?
08:57:23 <pikhq> C++ can be parsed. It just cannot be compiled.
08:57:31 <mauke> no, C++ can't be parsed
08:57:46 <EvilTerran> PeakerWork, i recall seeing something in the C++ FQAs
08:57:46 <PeakerWork> mauke: can you give an example?
08:57:54 <mauke> PeakerWork: you can encode arbitrary programs in templates
08:58:06 <PeakerWork> mauke: but how does that affect parsing?
08:58:12 <mauke> you can't tokenize C++ without resolving templates
08:58:17 <pikhq> Ah.
08:58:21 <Vanadium> mauke: Even considering the standard does not give any guarantees regarding the recursion depth in templates?
08:58:22 <mauke> X<Y>::Z(x);
08:58:23 <PeakerWork> mauke: Because of >> ?
08:58:34 <mauke> no, >> is always a right shift
08:58:41 <axzs> > >
08:58:43 <Vanadium> Not in C++0x
08:58:43 <lambdabot>   <no location info>: parse error on input `>'
08:58:50 <mauke> I'm talking about C++98
08:58:51 <PeakerWork> mauke: what are the options for X<Y>::Z(x) ?
08:58:54 <Vanadium> Okay~
08:58:59 <pikhq> PeakerWork: C++'s templates are isomorphic to lambda calculus.
08:59:12 <mauke> PeakerWork: if Z is a function, it's a function call; if Z is a type, it declares x
08:59:15 <PeakerWork> pikhq: accidentally :)
08:59:55 <PeakerWork> mauke: and X<Y>'s specialization can change what Z is?
08:59:55 <Vanadium> How about interpreting </> as operators instead of template instantiation there...
09:00:32 <mauke> bonus wtf: X<sizeof Y>::Z requires you to do class layout (taking into account (multiple) inheritance) to compute the size of Y to resolve the meaning of Z to tokenize your code
09:00:34 <Vanadium> Is this why you need to use the typename keyword there?
09:01:39 <mauke> PeakerWork: yes: template<typename T> struct X; template<> struct X<int> { void Z(int); }; template<> struct X<float> { typedef bool Z; };
09:02:29 <mauke> this works a bit like instance definitions in haskell, except there is no common class that tells them what they should look like
09:02:36 <PeakerWork> mauke: I see, interesting. thanks
09:02:55 <EvilTerran> PeakerWork, mauke, etc: http://yosefk.com/c++fqa/ctors.html#fqa-10.19
09:03:23 <mauke> there's a much cooler example of that
09:04:13 <EvilTerran> AIUI, it comes down to "is AA BB(CC); an object definition or a function declaration?"
09:04:42 <mauke> my example was AA(BB);
09:05:01 <mauke> which has the advantage of being compatible with (= ambiguous in) C :-)
09:05:09 <EvilTerran> ah
09:06:08 <mauke> argh, I don't remember the exact line
09:06:46 <mauke> it was something like vector<string> xs(iterator(string(argv[1])), iterator());
09:07:16 <mauke> the intent was to initialize a vector from an iterator range
09:07:45 <mauke> hmm, or am I confusing two things here?
09:08:29 <mauke> anyway, that line declares xs as a function taking two function pointers and returning a vector
09:09:42 * RayNbow wonders when there will be a code golfing contest about generating combinations with repetitions :p
09:10:29 <hackagebot> GLUT 2.2.1.0 - A binding for the OpenGL Utility Toolkit (SvenPanne)
09:10:29 <hackagebot> bindings-common 0.2.3 - Macros and modules to facilitate writing library (MauricioAntunes)
09:10:38 <EvilTerran> RayNbow, sth to the effect of MultiSet a -> [[a]] ?
09:10:49 <EvilTerran> (i guess Set [a] would be a more explicit output type)
09:11:29 <RayNbow> EvilTerran: hmm... more like Set a -> [MultiSet a]
09:11:33 <mauke> RayNbow: 92 bytes :-)
09:12:27 <RayNbow> or... Set a -> Set (MultiSet a)
09:12:37 <RayNbow> mauke: nice :)
09:13:05 <mauke> there's a fairly obvious way to make your program one character shorter
09:13:29 <RayNbow> EvilTerran, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8135
09:13:34 <mauke> the second character I gained by getting rid of head
09:14:02 <RayNbow> mauke: hmm, I'm interested in how you removed head
09:14:06 <RayNbow> through pattern matching?
09:14:19 <mauke> heh. it's really obvious :-)
09:14:58 <mauke> just ask any X programmer how to get the first element of an array
09:16:50 <RayNbow> mauke: bah... evil indexing :p
09:22:32 <hackagebot> nemesis 2009.8.16 - a Rake like task management tool (JinjingWang)
09:22:32 <hackagebot> hack-contrib 2009.8.16 - Hack contrib (JinjingWang)
09:22:32 <hackagebot> mps 2009.8.16 - simply oo (JinjingWang)
09:23:15 <RayNbow> mauke, any idea how to shave off the last 22 bytes?
09:23:33 <hackagebot> bamboo 2009.8.16 - A simple blog engine on Hack (JinjingWang)
09:24:11 <mauke> RayNbow: hah, no
09:24:33 <hackagebot> loli 2009.8.16 - A minimum web dev DSL in Haskell (JinjingWang)
09:25:33 <hackagebot> maid 2009.8.16 - A simple static web server (JinjingWang)
09:27:39 <Saizan_> loli, maid, so the pun _is_ intended?
09:28:51 <RayNbow> hmm
09:29:13 <RayNbow> are unicode package names allowed? :p
09:30:42 <nomeata> Hi. Has anyone seen this error before: /usr/bin/ld: cannot find -lHSrts_thr
09:30:54 <nomeata> (full build log at https://buildd.debian.org/fetch.cgi?&pkg=hlint&ver=1.6.4-1&arch=alpha&stamp=1250344879&file=log)
09:32:01 <nomeata> hmm, it seems that the threaded rts is not available on some arches.
09:33:33 <Cale> nomeata: I didn't even know GHC was supported at all on alpha.
09:33:34 <nomeata> but why does cabal try to build it with the threaded api?
09:33:54 <nomeata> Cale: not sure if it’s supported officially, but most library build fine
09:34:26 <nomeata> affects s390 and mips as well.
09:35:04 <Saizan_> nomeata: in hlint.cabal ghc-options:        -fno-warn-overlapping-patterns -threaded
09:35:19 <nomeata> Saizan_: ah, I missed that line, thx.
09:35:54 <nomeata> I guess this should be made dependant on some conditional variable that specifies whether a threaded environment is available.
09:39:55 <Luke> anyone have any good guides for getting started writing EDSLs?
09:40:11 <Luke> looking for personal recommendations not top google results =)
09:44:12 <shapr> delYsid: Dude, WASSUP?
09:45:24 --- mode: ChanServ set +o Philippa
09:45:39 --- mode: Philippa set -b *!*@amcant.demon.co.uk
09:45:52 --- mode: Philippa set -o Philippa
09:45:59 <shapr> er, why did you ban soupdragon?
09:46:16 <shapr> Oh, I see.
09:47:29 <shapr> Philippa: Well done.
09:50:59 <jfoutz> in scheme, i can add memoization to a function after that function is written... is there any way to do that in haskell?
09:51:23 <jfoutz> actually, i don't care about the memoization at all, i'm just trying to detect when a function recurses.
09:51:57 <c_wraith> technically, you can add a function that memoizes another function after the fact in *any* language.  >_>
09:52:18 <c_wraith> Oh, nevermind.  You can't. >_>
09:52:24 <c_wraith> I suck at being awake before noon
09:52:28 <jfoutz> hehehe.
09:53:25 <jfoutz> even just a peek at the stack would be good.
09:53:36 <c_wraith> the problem is that haskell doesn't really have a stack
09:53:50 <c_wraith> it works by minimally forcing thunks as necessary.
09:53:56 <shapr> Does anyone know where I can find high resolution videos of Hamming's Lectures on "The Art of Doing Science and Engineering" ?
09:54:34 <jfoutz> I was thinking about copumpkin instancing Eq for (Enumerable a, Eq b) => Eq (a -> b)
09:54:41 <copumpkin> :o
09:55:01 <copumpkin> that's on hackage now ;)
09:55:13 <copumpkin> Data.Enumerable.ControversialFunctionEquality :P
09:55:42 <jfoutz> i can play a dirty dirty trick with unsafeIO and a special datatype, build a truth table for every permutation of eq of the args... and get something simalar
09:55:55 <copumpkin> ?
09:55:58 <jfoutz> i was hoping i could detect recursive calls and do cycle detection as well.
09:56:19 <copumpkin> oh, with stable names you could
09:56:21 <c_wraith> I wonder if this is something you can do with the vacuum package
09:56:26 <shapr> You can do that just fine if you have an ADT that constructs everything instead of actually being recursive from the beginning.
09:56:26 * jfoutz grins
09:57:12 <jfoutz> but it's not my function... it's a function that's passed in.
09:57:47 <copumpkin> stable names will still help you
09:57:53 <jfoutz> hmm vacuum.
09:58:39 <jfoutz> copumpkin: i'm not sure what you mean by stable names. is that on hackage?
09:58:53 <copumpkin> jfoutz: it's a secret GHC feature :P
09:59:20 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
09:59:21 <jfoutz> ahh. i've fiddled with the GHC package a bit. i'll check that out.
09:59:51 <jfoutz> oh, wow. i don't even need the GHC bit. cool.
10:01:44 <hackagebot> nemesis 2009.8.17 - a Rake like task management tool (JinjingWang)
10:01:46 <jfoutz> copumpkin: someone more clever than me, could reconstruct functions that take Nums, and use LogicT to breadth first traverse axioms transforming the first into the second.
10:02:16 <jfoutz> i think i can get Eq though.
10:03:53 <ziman> if I replace the list monad with Control.Monad.Omega, do I get automatically BFS instead of DFS?
10:04:36 <copumpkin> almost automatically
10:04:51 <copumpkin> you need to write each in front of each list and runOmega
10:05:06 <ziman> yes, that's exactly what I've done
10:05:22 <copumpkin> then it should work I think
10:06:08 <jfoutz> wow. Omega is cool.
10:06:27 <ziman> I had already abstracted away the search strategy into class Search because I planned to write my own BFS monad. Then I accidentally googled Omega.
10:06:45 <edwardk> jfoutz: yeah, but you need to be careful, because if the order of the result is perturbed disrespecting the monad laws, so it is only a monad if you consider its output up to permutation
10:06:54 <ziman> which perfectly fits my Search class where runSearch:: Search a -> [a]; alternatives :: [a] -> Search a
10:07:18 <edwardk> ziman: note omega isn't either bfs or dfs though
10:07:53 <edwardk> because it won't fall to either infinite branching or infinite binding
10:07:54 <jfoutz> edwardk: ah, that makes sense. (which is surprising, my grasp is getting better)
10:08:37 <edwardk> as search strategies go it's a 'diagonal' traversal of the tree.
10:08:39 <ziman> I'm writing a program that derives proofs -- and I want to find one if it exists
10:08:45 <edwardk> yeah
10:08:52 <edwardk> omega is a fairly effective mechanism there
10:09:54 <edwardk> i started to derive a parser combinator set based on an omega traversal once, uu-parsinglib is based on BFS, parsec is effectively DFS, so the former can fall to infinite alternatives and the latter can fall to infinite bindings down one branch of the parse tree.
10:11:50 <ziman> interesting
10:12:19 <jfoutz> I wonder what a LogicT implementation would look like, you could interleave the longest match with the alternative search.
10:15:08 <khilan> ToRA: Heard from Spark recently?
10:15:51 <jfoutz> hrm. i guess that's why prolog parsers are so short.
10:30:14 <Dridus> dcoutts: I was wondering if the C2HS trac is kept after (e.g. is it the right place to submit bug + patch), and I have a feature that I implemented in my own copy I was hoping might be taken upstream ({#offsetof#})
10:30:29 <ManateeLazyCat> dcoutts: Are you there? I want ask you a gtk2hs question.
10:31:23 * ManateeLazyCat pasted "DiredBuffer and DiredView" at http://paste2.org/get/382111
10:31:24 <ManateeLazyCat> dcoutts: If i want inherit GObjectClass and ViewportClass, above instance code is correct?
10:32:07 <dcoutts> Dridus: yes, sure. File bugs there. You can attach bugs to the ticket or darcs send them direct to the c2hs list.
10:32:20 <ManateeLazyCat> dcoutts: I found when i use function `containerAdd` with DiredView, program will be freeze. So i guess my instance code is wrong, but i don't know how to write correct instance code. Any idea?
10:32:46 <Dridus> dcoutts: Okay, I did file it there and I attached a patch file there, I just wanted to make sure it was still the right place
10:32:57 <Dridus> dcoutts: should I submit the feature there as well? (what I already filed was a minor bug + patch)
10:34:23 <luite> how can I avoid this linker error when doing cabal install darcs on windows? dist\build\darcs\darcs-tmp\src\hscurl.o:hscurl.c:(.text+0x2b): undefined reference to `_imp__curl_multi_init'
10:34:25 <dcoutts> Dridus: if it's in the bug tracker, that's enough. Though feel free to talk about it more on the c2hs list, if there's any extra explanation that'd help.
10:34:36 <ManateeLazyCat> dcoutts: My code at http://paste2.org/get/382111
10:34:43 <dcoutts> ManateeLazyCat: so that code looks like an infinite loop to me
10:34:54 <ManateeLazyCat> dcoutts: Yep, infinite loop
10:34:58 <Dridus> dcoutts: I'm subscribed to c2hs -- I think it's straightforward, but maybe that's only to me ;-)
10:35:03 <luite> I've extracted the libcurl library to my mingw folder, and I've also tried to set CURL_STATICLIB=1, but it doesn't seem to help
10:35:05 <Dridus> dcoutts: thanks
10:35:07 <ManateeLazyCat> dcoutts: So how to fix?
10:35:11 <dcoutts> ManateeLazyCat: and I do not think it can be implemented because there is no GObject that you can sensibly return.
10:35:53 <dcoutts> ManateeLazyCat: in what sense is it a Viewport? where is the viewport widget?
10:35:59 <ManateeLazyCat> dcoutts: I can't inherit ContainerClass type in Haskell level?
10:36:14 <dcoutts> ManateeLazyCat: not without providing a widget that is a container
10:36:20 <ManateeLazyCat> Graphics.UI.Gtk.Misc.Viewport
10:36:35 <ManateeLazyCat> A Viewport is a helper widget that adds Adjustment slots to a widget
10:36:56 <luite> do I need some special libcurl to build darcs?
10:37:36 <ManateeLazyCat> dcoutts: GObject -> Object -> Widget -> Container -> Bin -> Viewport.
10:38:15 <mxc> quick question, can you use a pattern match in a one line lambda?  as in, whats the correct syntax for: let f = {\(Just y) -> y; \Nothing -> 1}
10:38:46 <Dridus> mxc: did you try let { f (Just y) = ... ; f Nothing = ... } in ...
10:39:17 <Saizan_> or f = \x -> case x of ..
10:39:18 <ziman> \x -> case x of ...
10:39:34 <dcoutts> Dridus: I don't see the bug report in the c2hs trac btw, could you point it out to me?
10:39:35 <mxc> dridus no, i'm actually trying to use it as the arg of a  call to map
10:39:53 <mxc> always do what ziman suggested, just wondering if there's a more concise way
10:40:08 <Saizan_> no
10:40:11 <copumpkin> luite: I've been wondering, what is that blue hat you're wearing in your pic on twitter?
10:40:14 <ziman> saizan was the first one :)
10:40:19 <Dridus> mxc: I'm pretty sure that you can't with lambda \, but you can with let
10:40:25 <mxc> yeah
10:40:27 <Dridus> dcoutts: sure, let me wrap up submitting the feature one
10:40:28 <copumpkin> oh wait
10:40:28 <mxc> oh well, thanks anyway
10:40:33 <luite> copumpkin: what? :)
10:40:35 <ziman> well, even if it's an argument to map, you can still give it a name and define it outside
10:40:39 <copumpkin> luite: sorry, was confused :P
10:40:49 <ziman> which often leads to a more readable code
10:40:54 <luite> I don't even have twitter :p
10:40:55 * ManateeLazyCat pasted "DiredBuffer and DiredView" at http://paste2.org/get/382121
10:40:56 <ManateeLazyCat> dcoutts: Above is my complete code for run.
10:41:11 <mxc> ziman true
10:41:17 <copumpkin> luite: whoops :)
10:41:17 <endojelly> hmm. can't install the latest haskell platform
10:41:25 <endojelly> after building, make install complains:
10:41:31 <endojelly> The mtl-1.1.0.2/Setup script does not exist or cannot be run
10:41:31 <endojelly> make: *** [install] Error 2
10:41:34 <endojelly> any ideas?
10:42:09 <ManateeLazyCat> dcoutts: I can't understand "not without providing a widget that is a container"?
10:42:54 <dcoutts> ManateeLazyCat: for it to be in GObjectClass you need toGObject to actually return an actual GObject
10:43:14 <dcoutts> ManateeLazyCat: similarly for the other classes
10:44:01 <dcoutts> ManateeLazyCat: looking at your DiredBuffer, it's clearly not a GObject since it does not contain one.
10:44:47 <ManateeLazyCat> toGObject a = GObject (ForegionPtr DiredBuffer) ?
10:44:47 <endojelly> none? :(
10:45:14 <dcoutts> ManateeLazyCat: and what pointer would that be then? There is none you can invent because there is no GObject!
10:45:56 <ManateeLazyCat> dcoutts: So i can't implement DiredBuffer with Haskell level?
10:46:05 <dcoutts> ManateeLazyCat: your DiredView can be in ContainerClass because the DiredView contains a TreeView and a TreeView is in the ContainerClass.
10:46:55 <dcoutts> ManateeLazyCat: I don't see why you want DiredBuffer to be a GObject. Where do you need to use it as one?
10:48:37 <Dridus> dcoutts: bug with superclass instance generation: http://hackage.haskell.org/trac/c2hs/ticket/21  (pardon the awful formatting, my trac-fu is weak and I don't know of a way to edit the issue body after submission)
10:48:40 <Heffalump> is there any way to workaround the fact that you can't SPECIALIZE things you import, and still keep modularity?
10:48:51 <Dridus> dcoutts: offsetof feature: http://hackage.haskell.org/trac/c2hs/ticket/22
10:49:19 <dcoutts> Dridus: ok, great
10:51:17 <dcoutts> ManateeLazyCat: I don't get why you want it in BinClass or ViewportClass either
10:51:58 <ManateeLazyCat> dcoutts: If i inherit from ViewportClass, i can make it in ScrolledWindowClass for support Scroll
10:52:15 <mightybyte> Is there a way to check whether something is of a certain constructor other than with pattern matching?
10:52:49 <mightybyte> ...so you could, for example filter a list for only items with a specified constructor.
10:52:57 <ManateeLazyCat> dcoutts: Otherwise i need write code self for support scroll.
10:53:11 <ManateeLazyCat> dcoutts: Like TextView support scroll
10:53:36 <dcoutts> ManateeLazyCat: ok, so the way gtk2hs works at the moment, you cannot do that except by providing a reference to a widget that is in the ViewportClass. In some other bindings you can make it an instance of the class by providing implementations of the inherited methods.
10:53:49 <ManateeLazyCat> mightybyte: filter (\(Constructor ...) -> ... ) list ?
10:54:17 <dcoutts> ManateeLazyCat: the gtk2hs binding does not provide any way for you to give custom implementations of the inherited methods of the ViewportClass.
10:54:37 <mauke> mightybyte: no
10:55:33 <ManateeLazyCat> dcoutts: So i just can inherit from ContainerClass and then write scroll code self?
10:55:51 <mightybyte> mauke: ok
10:55:51 <dcoutts> ManateeLazyCat: no, that's exactly what I'm saying. There is no way provided to do that.
10:56:16 <dcoutts> ManateeLazyCat: the only way Gtk2Hs lets you do it is by delegation to another widget that does implement it. This is sufficient to implement aggregations of widgets as a widget, but not sufficient to do custom implementations of inherited methods.
10:58:03 <ManateeLazyCat> dcoutts: I want implement file manager with gtk2hs, but i want this widget support split window, silimar like TextBuffer with TextView.
10:58:09 <dcoutts> ManateeLazyCat: if it were possible to do that, then the ContainerClass would have some methods for the scroll functions that you would have to implement. But there are none, just a method to provide a GObject (which is then casted back to a Viewport)
10:58:48 <ManateeLazyCat> dcoutts: I use DiredBuffer for keep share data, and use DiredView get those information and use exist widget to render it (like TreeView).
10:59:17 <dcoutts> ManateeLazyCat: then use a Viewport widget
10:59:45 <endojelly> ok I managed to install haskell platform by removing those packages that are already shipped with the latest ghc from packages/platform.packages
11:00:12 <ManateeLazyCat> dcoutts: You mean, i rewrite DiredView just use Viewport, then add TreeView in Viewport?
11:01:01 <endojelly> it seems that if a package already exists, it isn't built again during the platform build process. this makes sense. but then its install script still tried to execute all Setup scripts, which doesn't work because they, too, aren't build (and the unbuilt but preexisting package shouldn't be installed anyway)
11:01:45 <mightybyte> mauke: It seems like it would be useful to be able to get at the constructor of a piece of data.
11:02:05 <ManateeLazyCat> dcoutts: That's seen can works, thanks!
11:02:12 <mauke> mightybyte: it is!
11:02:35 <mightybyte> mauke: Otherwise if you want to do operations based on the constructor you have to add another data type to the structure that mirrors the constructors and do operations on that.
11:02:37 <dcoutts> ManateeLazyCat: actually since your DiredView is really a TreeView then you do not need a separate ViewPort, a TreeView can be added to a ScrolledWindow directly.
11:02:39 <brad_larsen> anyone have code using Data.MQueue.Heap from the queuelike package?  I can't figure it out.
11:03:14 <mauke> mightybyte: huh?
11:03:49 <mightybyte> mauke: Say you have "data Foo = A ... | B ... | C ..."
11:04:34 <mightybyte> mauke: I might want to filter a collection of Foos based on constructor type.
11:04:45 <mauke> ok?
11:05:19 <mightybyte> mauke: I think it basically would generalize to a getConstructor function.
11:05:29 <ManateeLazyCat> dcoutts: Oh, i see, thanks!
11:05:33 <mauke> mightybyte: what would be the type of getConstructor?
11:06:34 <ManateeLazyCat> dcoutts: Another question, after i finish file manager, i will add full-feature terminal in my project, so gtk2hs have binding VTE?
11:06:47 <mightybyte> mauke: Well, that would be up for debate.  The simplest approach right now might be "getConstructor :: a -> String", and a special type class constraint would probably have to be created for a.
11:07:06 <mauke> ... String⁈
11:07:07 <dcoutts> ManateeLazyCat: there's no existing VTE binding if that's what you mean, but I'm sure it'd be useful to have one.
11:07:24 <ManateeLazyCat> dcoutts: It's a hard work to binding?
11:07:29 <Phyx-> mightybyte: can't you use Data.Data and Data.Typeable then?
11:07:32 <ManateeLazyCat> dcoutts: If not, i will try to do that.
11:07:50 <dcoutts> ManateeLazyCat: there's a code gen that does much of the work, it's in the darcs repo.
11:07:57 <ManateeLazyCat> dcoutts: Because binding VTE in gtk2hs will be very useful, speical for programming.
11:08:10 <mightybyte> Phix-: Maybe.  That's why I originally asked the question. :)
11:08:43 <Phyx-> @hoogle toConstr --info
11:08:54 <Phyx-> hm, no lambda bot?
11:08:58 <lambdabot> Data.Generics.Basics toConstr :: Data a => a -> Constr
11:08:58 <lambdabot>  
11:08:58 <lambdabot> From package base, version 3.0.1.0
11:09:11 <Phyx-> @src Constr
11:09:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:10:20 <ManateeLazyCat> dcoutts: You said you have try to binding VTE before, you have old code (even it can't work) for reference? Or any useful resource about VTE with Haskell.?
11:10:53 <ManateeLazyCat> dcoutts: I will start VTE binding work at tomorrow or the day after tomorrow....
11:11:52 <Phyx-> mightybyte: you can just use (showConstr.toConstr)
11:12:00 <Phyx-> @type (showConstr.toConstr)
11:12:02 <lambdabot> forall a. (Data a) => a -> String
11:13:36 <mightybyte> Phyx-: Ahh, that looks exactly like what I want.  Thanks.
11:14:00 <dcoutts> ManateeLazyCat: I don't have anything useful, the code gen should be your greatest help.
11:14:16 <ManateeLazyCat> dcoutts: Thanks for your explain, i will ask detail in gtk2hs-user mail-list if i occur some problem.
11:14:57 <Phyx-> mightybyte: you can enable a language extension to allow you to derive Data, so that you don't have to write them by hand.
11:15:24 <mightybyte> Phyx-: I'm already doing that.  Just didn't know all that gave me.
11:15:48 <mightybyte> Phyx-: Can I get a list of all the constructors for a specific type?
11:15:50 <ManateeLazyCat> dcoutts: I don't need any customize widget anymore even i want to implement split display, i just need Viewport or other widget that support ScrolledWindowClass directly.
11:16:00 <Phyx-> mightybyte: yes, one sec
11:16:17 <mightybyte> Never mind, I just found it.
11:16:26 <mightybyte> dataTypeConstrs
11:16:38 <Phyx-> yes
11:16:46 <Phyx-> @type (dataTypeOf.dataTypeConstrs)
11:16:48 <lambdabot>     No instance for (Data Constr)
11:16:48 <lambdabot>       arising from a use of `dataTypeOf' at <interactive>:1:1-10
11:16:48 <lambdabot>     Possible fix: add an instance declaration for (Data Constr)
11:16:59 <ManateeLazyCat> dcoutts: Last question, :) What's GTK version that gtk2hs-0.10.1 binding?
11:16:59 <Phyx-> whoops
11:17:10 <Phyx-> @type (dataTypeConstrs.dataTypeOf)
11:17:12 <lambdabot> forall a. (Data a) => a -> [Constr]
11:20:45 <dcoutts> ManateeLazyCat: any version since 2.0 I think.
11:22:23 <copumpkin> > dataTypeConstrs.dataTypeOf $ True
11:22:25 <lambdabot>   [False,True]
11:22:28 <copumpkin> nice
11:22:33 <copumpkin> > dataTypeConstrs.dataTypeOf $ Nothing
11:22:35 <lambdabot>   Add a type signature
11:22:45 <copumpkin> > dataTypeConstrs.dataTypeOf $ (Nothing :: Maybe Bool)
11:22:47 <lambdabot>   [Nothing,Just]
11:23:00 <copumpkin> @type dataTypeConstrs.dataTypeOf $ (Nothing :: Maybe Bool)
11:23:02 <lambdabot> [Constr]
11:23:06 <ManateeLazyCat> dcoutts: In http://www.gtk.org/language-bindings.html , it display gtk2hs just partially support to 2.8
11:23:59 <dcoutts> ManateeLazyCat: that's correct. It works with all subsequent versions but does not provide bindings for many of the later things.
11:24:03 * ManateeLazyCat My file manager have split display fine. Sweet... 
11:25:43 <ManateeLazyCat> dcoutts: Thanks! :)
11:27:09 * ManateeLazyCat I will contribution my time for finish missing binding in current gtk2hs version when i expert every part of gtk2hs, now continue study gtk2hs...
11:28:33 <ManateeLazyCat> Bye all, night! :)
11:31:24 <copumpkin> > (+1) >> (+2) $ 5
11:31:26 <lambdabot>   7
11:31:33 <copumpkin> > (+1) >>= (+) $ 5
11:31:35 <lambdabot>   11
11:32:23 <copumpkin> > ((+) >=> (+)) 5 6
11:32:25 <lambdabot>   17
11:33:38 <mightybyte> dcoutts: Do you have any idea why gtk2hs slows down the network processing in this example?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8189
11:34:56 <mreh> @src Maybe
11:34:56 <lambdabot> data Maybe a = Nothing | Just a
11:35:15 <dcoutts> mightybyte: yes, mainGUI is a blocking call.
11:35:23 <dcoutts> mightybyte: and you're not using the -threaded rts
11:35:39 <mightybyte> dcoutts: Ahh.  How would I fix that?
11:36:08 <dcoutts> mightybyte: two ways: http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
11:38:12 <dcoutts> mightybyte: the bit on the threaded rts is true but a bit out of date, there's now a variant on initGUI for the threaded rts but check the docs.
11:38:41 <mightybyte> dcoutts: Ok, thanks.
11:41:05 <Stinger> what's the best Qt lib out there?
11:48:21 <sm> hmm, unexpected program exit while messing with printf
11:48:27 <sm> how could this happen ? http://gist.github.com/168699
11:50:02 <mauke> your non-use of "%-*s" saddens me
11:50:26 <Phyx-> hrm
11:50:40 <sm> hmm, what is %-*s ?
11:51:22 <Vanadium> * would use a parameter for the value, ie the field width, here, instead of forcing you to write it into the format string.
11:51:40 <sm> super!
11:51:44 * sm tries it instantly
11:51:54 <mauke> I see three format specifiers and four arguments
11:53:37 <sm> you do, don't you. That's odd
11:55:02 <sm> it looks like I accidentally dropped one just , thanks
11:55:11 <sm> just now. still exiting though!
11:55:30 <mauke> prepare a testcase
11:57:16 <sm> darn
11:58:34 <athos> > fmap (+1) (^2) 16
11:58:36 <lambdabot>   257
12:01:38 <randomwords> Gah, you need authorisation to upload to hackage. I was so excited..
12:01:59 <Veinor> athos: what did you expect? :o
12:02:19 <athos> Veinor: just what lambdabot evaluated it to
12:02:25 <RayNbow> mauke, made any improvements in the code golfing while I was away, or still sub-PAR?
12:02:52 <mauke> RayNbow: no improvements
12:02:58 <Phyx-> @type (^2)
12:03:00 <lambdabot> forall a. (Num a) => a -> a
12:03:05 <Phyx-> ah right
12:03:14 <Phyx-> uses monad instance (->)
12:03:25 <athos> no, functor instance (->)
12:03:35 <Phyx-> right, brainfart
12:03:38 <athos> no, functor instance (-> r) to be correct
12:03:38 <athos> :)
12:03:43 <copumpkin> nope
12:03:50 <copumpkin> functor instance ((->) r) to be correct ;)
12:03:55 <Phyx-> rofl
12:03:55 <athos> :P
12:04:38 <athos> copumpkin: here's your price: let price = Nothing in price
12:04:46 <copumpkin> :o
12:04:53 <athos> but i guess you were aware of that beforehand :)
12:05:01 <athos> it's haskells (old) motto: avoid success at all costs
12:05:05 <athos> at least i heard so ;)
12:05:26 <Phyx-> heh
12:05:35 <Phyx-> that doesn't sound like much if a motto
12:06:07 <badsheepy> its new motto is only understandable by 7 people
12:06:13 <badsheepy> but is technically applicable to all things
12:06:35 <Phyx-> and what is it's new motto?
12:07:31 <badsheepy> haskell: humour not included :p
12:07:43 <athos> :>
12:07:46 <badsheepy> but no doubt definable :p
12:08:03 <copumpkin> :o
12:10:05 <Phyx-> lol
12:10:38 <RayNbow> @src cycle
12:10:39 <lambdabot> cycle [] = undefined
12:10:39 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:11:18 <Dridus> grr why is emacs haskell-mode always insisting on lining up then/else with if in a do block
12:12:43 <sm> hm, maybe it's just a printf bad argument exception that I'm somehow not seeing because this is a subthread
12:13:14 <sm> I'm catching exceptions. Yay! no test case for me
12:13:27 <sm> thanks for the help
12:14:41 <Saizan_> @where kuribas-indentation
12:14:41 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
12:14:46 <Saizan_> Dridus: ^^^^
12:14:51 <Phyx-> sm: catching exceptions is good? low expectations? :P
12:15:13 <sm> low knowhow, back then
12:15:28 <sm> this is my chance to fix it up
12:15:40 <Phyx-> lol
12:15:47 <Phyx-> hmm what's a .el page
12:16:15 <Phyx-> oh, must be an emacs thing
12:16:16 <int-e> 'emacs lisp' typically. - it's plain text
12:16:16 <Saizan_> it's an elisp script
12:23:20 <sm> ack, jinjing was here
12:24:25 <sm> is there a way to tell ghc to not warn about a specific item in -Wall ? I'd like to leave trace available and not see warnings
12:24:56 <Saizan_> sm:  there are -fno-warn-foo flags
12:25:37 <sm> that's only for classes of warnings though ?
12:26:12 <Saizan_> ah, by item you meant piece of code?
12:26:33 <sm> right, specifically the fact that trace is imported but not being used, I don't want to see that warning
12:26:35 <mightybyte> dcoutts: Ok, I got the network working smoothly.  How do I force the chart to redraw?  I tried calling widgetQueueDraw and widgetShowAll, but they didn't work.
12:26:45 <sm> maybe I can use it with seq or something
12:26:54 <dcoutts> mightybyte: widgetQueueDraw is the thing.
12:27:23 <mightybyte> dcoutts: Do I call it on the window or the canvas?
12:27:24 <twanvl> sm: or add  don't_warn_about = trace  to the file
12:27:38 <dcoutts> mightybyte: are you paying attention to the need to use postGUIsync or postGUIasync ?
12:27:59 <mightybyte> dcoutts: Oh, no.  I missed that.
12:28:19 <dcoutts> mightybyte: that's the thing about unsafeInitGUIForThreadedRTS
12:28:31 <mightybyte> dcoutts: I'm not using unsafeInitGUIForThreadedRTS
12:28:32 <dcoutts> mightybyte: it's got such a long name to make you pay attention ;-)
12:28:45 <dcoutts> mightybyte: oh ok, so you're using the polling method
12:28:48 <mightybyte> Yeah
12:28:50 <dcoutts> ok
12:29:06 <Saizan_> twanvl: don't_warn_about needs to be reachable from the exports, or from main
12:29:14 <mightybyte> The "unsafe" scared me away for this simple app
12:29:16 <dcoutts> mightybyte: so what is this chart? how is it supposed to be drawn?
12:29:37 <dcoutts> mightybyte: I mean where is the code that does the drawing? (assuming it's custom drawn)
12:29:49 <dcoutts> mightybyte: is it in the onExpose handler?
12:30:10 <mightybyte> dcoutts: It's here http://hackage.haskell.org/package/Chart
12:30:45 <dcoutts> mightybyte: perhaps you should show me the onExpose handler for the widget you say is not getting redrawn
12:30:49 <mightybyte> dcoutts: My drawing code is updateCanvas
12:31:31 <mightybyte> dcoutts: It's in that hpaste link
12:31:57 * dcoutts tries to find said link
12:32:29 <mightybyte> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8189
12:34:44 <dcoutts> mightybyte: I don't see any call to widgetQueueDraw or any form of communication between the netowrking bits and the gui
12:35:11 <mightybyte> dcoutts: Yeah, that's not the most recent code.  One moment and I'll past the new code.
12:35:39 <mightybyte> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8242
12:36:09 <mightybyte> dcoutts: It's basically the same.  The network code modifies an MVar that the drawing code (updateCanvas) reads.
12:36:50 <mightybyte> dcoutts: Line 43 has the widgetQueueDraw code, but it's commented out right now because it was giving me "Prelude.minimum: empty list"
12:36:54 <hackagebot> bindings-common 0.2.4 - Macros and modules to facilitate writing library bindings. (MauricioAntunes)
12:38:06 <dcoutts> mightybyte: I don't see the call to widgetQueueDraw
12:38:22 <dcoutts> mightybyte: it's not going to work without it
12:38:48 <mightybyte> Line 43: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8242
12:40:12 <mightybyte> I've tried passing both the canvas and the window into serverFunc, but they both give me "empty list" runtime errors.
12:42:02 <sm> I'm a little confused about exceptions vs exit codes: my subthread calls exitWith ExitSuccess. The parent catches the exception, but which exception is it ? I need to disinguish from error exceptions, which I will print
12:43:43 <Heffalump> sm: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html#t%3AExitCode
12:43:51 <Heffalump> (I guess, I have no personal experience of catching it)
12:45:16 <sm> yes but..
12:45:19 <sm> @hoogle ExitException
12:45:30 <Heffalump> it's an instance of Exception
12:45:44 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
12:47:54 <dcoutts> mightybyte: "widgetQueueDraw" is not mentioned anywhere on that page
12:48:20 <dcoutts> mightybyte: ah, ok, cache issues
12:48:27 <mightybyte> Ahh
12:48:32 <Lemmih> mightybyte: You asked for me?
12:48:41 * dcoutts blames hpaste for not sending correct headers
12:49:23 <mightybyte> Lemmih: Ahh yeah.  CompactMap needs splitLookup in order to build a CompactIxSet.
12:49:35 <lysgaard> I'm having a problem with the modify function in Control.Monad.State. I do: funtion :: (state -> state); modify function. But the state stays the same as before the modify. Is this at all possible?
12:49:54 <Lemmih> mightybyte: You can write it using filter and lookup.
12:50:02 <dcoutts> mightybyte: oh, you're calling widgetQueueDraw on the window and not the canvas, that's excessive
12:50:12 <mightybyte> dcoutts: I've tried it both ways.
12:50:22 <dcoutts> mightybyte: and I'd have to check the docs as to whether it includes child widgets
12:50:25 <mightybyte> dcoutts: Both give me "Foo: Prelude.minimum: empty list
12:50:55 <dcoutts> mightybyte: sounds like a bug to me :-)
12:50:55 <Lemmih> mightybyte: It would be good if you could avoid it all together. CompactMap works best with a single writer.
12:50:56 <mightybyte> Lemmih: Ahh, ok.  I'll work on that.
12:51:11 <mightybyte> dcoutts: In gtk2hs or my code?
12:51:27 <dcoutts> mightybyte: my guess would be your code or the Chart package
12:51:42 <mightybyte> Ahhh
12:53:54 <sm> so I've got this http://gist.github.com/168739 code giving that error as I try to distinguish exceptions.. where am I going wrong ?
12:55:12 <sm> ExitCode is.... not an Exception, but an instance of it
12:55:20 <Lemmih> mightybyte: Keep in mind that IxSet rebuilds all indexes once per each constraint in your query.
12:55:21 <sm> hmm
12:55:39 <int-e> sm: ExitSuccess has its own type. You probably want to catch SomeException, but you have to use fromException to extract the actual exception from that.
12:56:17 <Lemmih> mightybyte: How you order your constraints is crucial.
12:56:48 <mightybyte> Lemmih: Yeah, I've kept that in the back of my mind.
12:56:58 <int-e> sm: with pattern guards,  exit e | Just ExitSuccess <- fromException e = exitWith ExitSuccess ...
12:57:00 <mightybyte> Lemmih: Although there still may be room for improvement.
12:57:25 <mightybyte> Lemmih: -c seems to be helping quite a bit.
12:58:04 <Lemmih> mightybyte: 500megs of memory to manage 8megs of data is still completely out of whack.
12:59:04 <Lemmih> mightybyte: With 90% of the CPU time going to the GC, I'm pretty confident in saying that you're doing something wrong.
12:59:24 <Lemmih> mightybyte: I wish you show us the code or at least a minimal test case.
12:59:50 <Lemmih> Remote performance tuning is frustrating. (:
13:02:15 <deech`> Hi all, I've been looking at the 'fix' function. I think I understand how it works, but I get why it is necessary. Has anyone used this ( or mfix) in their code?
13:02:46 <sshc> Hi, why isn't x matching the whole list in this small code segmant? http://pastebin.com/d4754b991
13:02:46 <sm> int-e: thank you, now I've got it
13:02:52 <Lemmih> deech`: It's sometimes handy.
13:02:55 <int-e> > fix ((0:) . scanl (+) 1)
13:02:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:03:07 * sm works on making hackagebot robust
13:03:50 <Nafai> sm: Nice!
13:03:55 <mauke> deech`: fix abstracts general recursion. recursion is also built into haskell, so it's not really required
13:04:15 <sshc> shouldn't 'x' match the entire list?
13:04:48 <sshc>    Occurs check: cannot construct the infinite type: a = [a]
13:04:48 <sshc>     When generalising the type(s) for `collatzChain'
13:05:19 <mauke> sshc: what is n supposed to be?
13:05:30 <sshc> mauke: n is the tail of the list
13:05:32 <int-e> deech`: a less contrived example would be  fix $ \loop -> do <some action binding 'abort'>; when (not abort) loop
13:05:40 <sshc> mauke: the very last element?
13:06:04 <mauke> sshc: which is it, the tail or the last element?
13:06:30 <sshc> mauke: what's the difference?
13:06:40 <deech`> But is there any performance advantage? Is there a situation a simple 'fold' function would not work?
13:06:59 <mauke> > (tail "hello", last "hello")
13:07:01 <lambdabot>   ("ello",'o')
13:07:05 <deech`> I think it is a cool concept, I'm just trying to find an application where it would be the technique of choice.
13:07:07 <mauke> > (head "hello", tail "hello", last "hello")
13:07:08 <lambdabot>   ('h',"ello",'o')
13:07:19 <sshc> mauke: oh, not tail
13:07:25 <sshc> mauke: thanks
13:07:26 <int-e> deech`: and of course 'fix' turns up a lot in point-free code.
13:08:25 <int-e> @pl f n = if n < 2 then n else f (n-1) + f (n-2)
13:08:26 <lambdabot> f = fix (ap (if' =<< (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
13:08:30 <int-e> ;-)
13:08:44 <Trinithis> The only time Ive used fix is as the Y-combinator
13:08:49 <deech`> my eyes!
13:09:37 <Trinithis> > fix (\fac n -> if n == 0 then 1 else fac (n-1)) 4
13:09:39 <lambdabot>   1
13:09:49 <Trinithis> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 4
13:09:51 <lambdabot>   24
13:10:08 <Trinithis> basically its just anonymous recursion
13:10:24 <syntaxglitch> fix is short for "fixed point"?
13:10:33 <Trinithis> least fixed point
13:10:59 <int-e> > fix show
13:11:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:11:15 <deech`> Trinithis: and least fixed-point is the same as the stop-case in recursion loop.
13:11:18 <mauke> > fix error
13:11:20 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
13:11:43 <deech`> Trinithis: If there isn't a stop-case it diverges, it there is one it converges.
13:11:44 <Trinithis> right
13:11:53 <int-e> mauke: I remember a time when that one killed lambdabot.
13:11:58 <Trinithis> and it has to advance to the stop too
13:12:42 <Trinithis> > let repeat x = fix (x :) in repeat 2
13:12:44 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
13:13:48 <Trinithis> fix show is odd
13:13:57 <mauke> @v
13:13:58 <lambdabot> "\""
13:14:11 <Trinithis> @v?
13:14:11 <lambdabot> Maybe you meant: ? v
13:14:16 <mauke> @v
13:14:16 <lambdabot> "\"#$%&'()*+,\""
13:14:38 <Trinithis> What is @v
13:14:50 <mauke> it is a mystery
13:14:54 <Trinithis> lol
13:15:51 <ziman> @p
13:15:51 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
13:15:51 <lambdabot> v
13:16:01 <ziman> @v
13:16:01 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
13:18:08 <copumpkin> @palomer
13:18:09 <lambdabot> Hrmph, looks like I killed the channel
13:18:22 <copumpkin> @protontorpedo
13:18:23 <lambdabot> I am banned from like 6 rooms
13:18:46 <ziman> @pretty
13:19:34 <copumpkin> @print-notices
13:19:35 <lambdabot> Not enough privileges
13:19:44 * copumpkin resists the temptation to have enough privileges
13:21:29 <randomwords> copumpkin: You don't want too many pirvileges
13:22:56 <randomwords> copumpkin: Did you quench your algebraic thirst?
13:23:04 <ManateeLazyCat> How to transform 3.1415926 to 3.1 ?
13:23:13 <copumpkin> randomwords: not really
13:23:14 <ManateeLazyCat> @users
13:23:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 594 (90.3%), active: 28 (4.7%)
13:24:11 <ManateeLazyCat> @hoogle Double -> Int -> Double
13:24:12 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
13:24:12 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
13:24:12 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
13:24:18 <mauke> ManateeLazyCat: const 3.1
13:24:27 <ManateeLazyCat> mauke: No
13:24:38 <mauke> (/ 10) . fromInteger . round . (* 10)
13:24:49 <mauke> printf "%.1f"
13:25:36 <randomwords> they aren't the same thought - one rounds and one truncates
13:26:21 <Trinithis> googled this http://www.i-am-bored.com/bored_link.cfm?link_id=9644
13:29:09 <ManateeLazyCat> mauke: Have exist function that type signal is: Double -> Int -> Double ? Example: foo 3.1415926 1 => 3.1, foo 3.1415926 2 => 3.14
13:31:02 <int-e> @type (^)
13:31:03 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
13:31:19 <mauke> > (\d n -> (/ 10 ^ n) . fromInteger . round . (* 10 ^ n) $ d) pi 1
13:31:21 <lambdabot>   3.1
13:31:22 <mauke> > (\d n -> (/ 10 ^ n) . fromInteger . round . (* 10 ^ n) $ d) pi 2
13:31:24 <lambdabot>   3.14
13:31:43 <Trinithis> can that give bad round errors though?
13:31:52 <Trinithis> show + read!
13:31:53 <pikhq> @type pi
13:31:55 <lambdabot> forall a. (Floating a) => a
13:32:00 <pikhq> Possibly.
13:32:55 <ray> > pi :: Cereal
13:32:57 <lambdabot>   Not in scope: type constructor or class `Cereal'
13:34:12 <hackagebot> archlinux 0.2.1 - Support for working with Arch Linux packages (DonaldStewart)
13:37:00 <chaosape> Are there any issues I need to worry about (besides performance) when deciding between ByteString and Lazy.ByteString?
13:43:45 <monochrom> I think no, chaosape.
13:44:03 <sshc> why does length return an Int?
13:44:30 <monochrom> Because it is faster and most likely sufficient.
13:44:38 <chaosape> Okay thanks!
13:44:40 <gwern> because it's not genericLength
13:44:56 <gwern> and if your list is so long that Int will wrap... odds are good that you can't actually call length on it :)
13:45:12 <monochrom> But you would not be alone if you protested it.
13:47:30 <c_wraith> :t replicate
13:47:31 <lambdabot> forall a. Int -> a -> [a]
13:47:46 <c_wraith> drat.  can't use replicate to create a list too long for length. :)
13:48:50 <gwern> c_wraith: no, you need genericReplicate
13:48:51 <absz> @hoogle genericReplicate
13:48:51 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
13:49:03 <absz> that'll do it
13:49:13 <gwern> but again, what sort of list is so long that you can evaluate the full power of genericReplicate?
13:49:21 <c_wraith> @hoogle maxbound
13:49:22 <lambdabot> Prelude maxBound :: Bounded a => a
13:49:31 <c_wraith> oh.  I fail at capitalization
13:50:04 <monochrom> Suppose I want a list of length infinity minus one.
13:50:41 <monochrom> (I'm mocking those "0.999... is not 1" people. :) )
13:50:44 <absz> monochrom: init (cycle [0])
13:50:55 <absz> :)
13:51:25 <Phyx-> monochrom: well... it isn't 1... :P
13:51:51 <monochrom> They really think like "0.<infinitely many 9's here><followed by a final 9>"!
13:51:51 <c_wraith> Personally, I like the idea of an infinite list with a last element
13:52:06 <c_wraith> > fix (0:) ++ [1]
13:52:07 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:52:22 <c_wraith> see, look!  an infinite list, followed by a different last digit!
13:52:23 <ray> you could make a new type
13:52:26 <monochrom> Or equivalently "1 - 0.999... = 0.<infinitely many 0's here>1"
13:52:49 <monochrom> But c_wraith beats me to it. :)
13:53:02 <ray> data InfiniteListWithLastElement a = Constructor [a] a
13:53:16 <ray> then you'd be able to reach it
13:53:36 <ray> fromList would diverge
13:53:43 <ray> but who cares
13:55:13 <kkaji`>  If you have some time please clikt this link, and help me -  http://www.lostworlds.lv/go.php?1139723800
13:55:20 <c_wraith> yay spam
13:55:59 <monochrom> Still no Haskell Weekly News yet!
13:56:07 <ray> time to rename it?
13:56:21 <c_wraith> Haskell Semifrequent News!
13:56:29 <monochrom> Haha there was a time I said "Haskell Seasonal News"!
13:56:46 <c_wraith> also, doesn't HSN sound official?
13:56:56 <monochrom> HSON
13:57:16 <monochrom> "Haskell Seasonal Online News"! Isn't it cute? :)
13:57:34 <c_wraith> I'm now suitably terrorized of any acronym that ends with those 3 letters
13:57:50 <monochrom> hehehe
13:58:11 --- mode: ChanServ set +o mauke
13:58:11 --- mode: mauke set +b *!n=plinka@*
13:58:11 <c_wraith> err.  terrorized by.  terrified of....  next week, on When Prepositions Attack!...
13:59:03 <ray> HON (Haskell Occasional News)
13:59:11 --- mode: mauke set -o mauke
13:59:16 <randomwords> Maybe (Haskell News)
14:02:28 <wolverian> I have a project that uses hierarchical modules. I would like to document them all using lhs. can GHC or something else spit out the appropriate hierarchy of files when run against the resulting .tex file?
14:03:00 <wolverian> I *think* Shuffle does it, but I have no idea really. the documentation isn't exactly the clearest. :)
14:05:13 <mreh> what's the syntax for constructing a record?
14:05:58 <monochrom> Constructor {field0 = 4, field1= "hello", field2 = False }
14:06:08 <mreh> monochrom: cool
14:07:02 <monochrom> Perverse example: let x = Node{ val = 10, next = x } in x
14:11:21 <copumpkin> @hackage tagged
14:11:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagged
14:13:41 <ray> @huckage destroyuniverse
14:13:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/destroyuniverse
14:20:24 <bos> @seen edwardk
14:20:24 <lambdabot> edwardk is in #haskell and #kata. I last heard edwardk speak 3h 49m 48s ago.
14:30:54 <luite> I'm trying to install gtk2hs using msys, windows, but I get this error when doing make install, /bin/sh: //c/haskell/gtk2hs-0.10.1-6.10.4/lib/gtk2hs/glib.package.conf.tmp: No such file or directory
14:31:27 <dcoutts> luite: probably something failed slightly earlier
14:31:33 <luite> any idea how to fix this? the directory contains a glib.package.conf (without .tmp)
14:31:59 <luite> dcoutts: the previous command is one huge /bin/sed command line
14:32:14 <luite> it doesn't show any errors
14:33:19 <dcoutts> luite: I'd have to look back through the build log to see the first problem
14:38:22 <luite> dcoutts: this is the output produced by make install: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8246#a8246
14:42:31 <dcoutts> luite: ohh, make install is failing. I'm not sure it can ever work. The standard practise is to make install DESTDIR=sometempdir
14:42:39 <dcoutts> then register as a separate step
14:42:52 <dcoutts> luite: see we only use make install DESTDIR= for the windows installer image
14:43:10 <luite> oh ok, thanks
14:43:21 <luite> this is why I find using haskell on windows so frustrating :p
14:45:52 <Cale> luite: Development stuff on Windows in basically any language is always annoying isn't it?
14:46:03 <dcoutts> luite: pester the gtk2hs devs to make a new installer, it's really not that hard
14:46:14 <luite> Cale: depends, if it needs mingw and all kind of gnu tools, yes
14:46:15 <dcoutts> luite: indeed you can do it too, you've got 3/4 of the way there
14:49:09 <luite> I still haven't figured out a good way to install extra libraries for mingw. I just found out an hour ago that darcs has a -f-curl option, which magically seems to work, but before that I was struggling with installing libcurl on mingw, and I still don't know the proper way to do it now
14:49:23 <luite> same goes for the regexp library
14:49:34 <luite> on linux, it just works, usually
14:50:07 <edwardk> heya bos
14:50:36 <bos> edwardk: don't forget that you owe me a bug report / RFE :-)
14:50:55 <edwardk> bos: yeah
14:52:06 <edwardk> bos: no tickets up there yet?
14:55:00 <bos> edwardk: no, the library isn't getting much use yet since i haven't declared open season on it.
14:55:17 <edwardk> ah
14:55:31 <RayNbow> Cale: actually, Python's quite reasonable on Windows
14:55:44 <RayNbow> most major packages have a nice win32 installer
14:56:16 * RayNbow tries to think of other languages/platforms that are nice to use on Windows...
14:56:30 <Berengal> RayNbow, C# I'd wager
14:56:35 <Vanadium> gasp
14:56:35 <luite> RayNbow: java perhaps, and C#
14:56:39 <RayNbow> Berengal: but that's cheating ;)
14:56:55 <Berengal> C++ too, probably
14:57:02 * RayNbow shudders
14:57:14 * RayNbow failed at compiling Boost libs :p
14:57:15 <Berengal> Although one could possibly argue that C++ isn't nice to use anywhere
14:57:19 <Makoryu> Berengal: Are you claiming that C++ is nice to use on any platform at all?
14:57:25 <Makoryu> Exactly
14:57:41 <Berengal> I wouldn't know. I don't intend to figure out
14:58:22 <nominolo> @pl (\eps -> (upd_fn eps, ()))
14:58:22 <lambdabot> flip (,) () . upd_fn
14:59:16 <leopard> good morning/day/night/other time of the day
14:59:28 <edwardk> bos: if you have time to sit and talk i have some ideas about how a safe cursor library could be implemented using some tricks i'm using for the reflection library
14:59:33 <RayNbow> the only problems I had with Python was getting OpenSSL/M2Crypto and wxPython to work... but now there are a few more installers and there are a few guides on setting things up
14:59:42 <Philonous> @tell jfoutz Turns out it is pretty straight forward to merge the constant case with the rest using an empty int-map. I've also adapted conals dlift function and scapped some boiler plate. Here's the code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3349#a3349
14:59:42 <lambdabot> Consider it noted.
14:59:54 <edwardk> bos: ticket created
15:00:02 <bos> edwardk: thanks
15:00:33 <Nafai> luite: Java ends up being a pain on Windows, especially if you have a long depdency list, it is very easy to get your CLASSPATH environment variable too long
15:00:37 <luite> RayNbow: so it's basically the same as haskell. most packages work fine with cabal-install, but there are a few extremely annoying ones, that make you want to switch to linux, once you need them :p
15:01:32 <leopard> opensource platforms tend to be far better for development
15:02:11 <Nafai> OS X was a pain for development for me as well
15:02:13 <luite> Nafai: is there a maximum length for environment variables?
15:02:36 <Axman6> Nafai: not in my experience
15:02:37 <edwardk> bos: though i suppose the easiest way to do it would be to just make the cursor API monadic. so you have a Text as the environment, and your current Cursor position as state, uncons to retrieve current value and bump the cursor position correctly for surrogate pairs, and the ability to mark to retrieve the current cursor position, and slice between two cursors or drop everything before or after a cursor, etc.
15:02:57 <RayNbow> luite: I would argue that it's the same as Haskell... with Python I don't feel I'm missing a lot of packages
15:03:23 <Nafai> luite: Yes, there is in bash as well, but it is much longer.  Part of the problem also is Windows tends to have very long pathnames because of the standard places to install things and so references to jars end up being very long
15:04:02 <Nafai> Axman6: It was for me, because I would have to compile a lot of third party libraries, or fight the conflicts between system installed ones and those installed from macports, etc
15:04:06 <RayNbow> on the Haskell side, I envy the people using all these cool packages with a breeze on Linux systems :p
15:04:09 <edwardk> a little bit of universal quantification would ensure that you can't mix cursors from different Text fragments
15:04:17 <Nafai> Axman6: Nothing never seemed as simple as apt-get install
15:04:23 <Axman6> Nafai: macports isn't hard to get right
15:05:00 <Axman6> anyway, uni time.
15:05:05 <Nafai> Perhaps I was just couldn't figure it out, but I always had problems with it.  I haven't touched it for a year, I gladly gave up the Mac Book Pro I had when I left my last job
15:05:16 <Nafai> I was happy to go back to my friendly usable Ubuntu
15:07:57 <Trinithis> is there a MonadZero class? ie: MonadPlus minus the mplus
15:08:21 <edwardk> trinithis: no =(
15:08:31 <Trinithis> fun..
15:08:45 <edwardk> unfortunately they decide in haskell 98 to make 'every monad into a monadzero' by bolting 'fail' on sideways to monad
15:08:57 <edwardk> @type fail
15:08:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:09:51 <Trinithis> still would be nice to have: mzero = fail "" :: MonadZero a
15:10:05 <Trinithis> oh well
15:10:44 <sshc> how do I cast an integer or string to a bool?
15:10:56 <edwardk> trinithis: as dons put it: http://donsbot.wordpress.com/2008/05/24/monad-fail/
15:11:06 <skorpan> sshc: that doesn't make any sense
15:11:08 <RayNbow> > show 34
15:11:10 <skorpan> > show 1
15:11:10 <lambdabot>   "34"
15:11:11 <lambdabot>   "1"
15:11:15 <skorpan> casting it to a bool?
15:11:17 <RayNbow> > 34 /= 0
15:11:19 <lambdabot>   True
15:11:21 <Trinithis> haha the image failed to load
15:11:27 <ziman> sshc, usually by testing its equality to "" or 0, respectively
15:11:33 <skorpan> > \x -> if x <= 0 then False else True
15:11:35 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
15:11:35 <lambdabot>    arising fro...
15:11:42 <skorpan> > (\x -> if x <= 0 then False else True) 0
15:11:44 <lambdabot>   False
15:12:00 <skorpan> well, that was the long version at least :)
15:12:24 <Trinithis> > not (<= 0) 0
15:12:25 <lambdabot>   The section `GHC.Classes.<= 0' takes one argument,
15:12:25 <lambdabot>  but its type `GHC.Bool....
15:12:33 <skorpan> > (> 0) 0
15:12:34 <Trinithis> right
15:12:35 <lambdabot>   False
15:12:49 <skorpan> > not . (<= 0) $ 0
15:12:50 <lambdabot>   False
15:13:24 <skorpan> @pl \x -> if x <= 0 then False else True
15:13:24 <lambdabot> flip (flip if' False . (<= 0)) True
15:13:34 <skorpan> @pl not . (>= 0)
15:13:34 <lambdabot> not . (>= 0)
15:13:38 <ziman> > null . (`replicate` liftM join undefined) $ 0
15:13:39 <lambdabot>   Add a type signature
15:13:40 <skorpan> @pl \x -> not . (>= 0) $ x
15:13:40 <lambdabot> not . (>= 0)
15:21:10 <veinor> Is there a good ID3 tagger library?
15:21:50 <comrade`phil> veinor: Yes.
15:21:59 <veinor> ... what's its name?
15:21:59 <edwardk> veinor: shapr was interested in writing one i don't know if he ever got around to it
15:22:06 <comrade`phil> Unfortunately, I've yet to find it
15:22:13 <skorpan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hpodder
15:22:22 <skorpan> that has supports for writing them at least, but it's not the main purpose
15:22:30 <veinor> let me rephrase that: is there a ID3 library for Haskell (read-only is fine)
15:22:31 <skorpan> http://hackage.haskell.org/package/taglib
15:22:38 <comrade`phil> Ah
15:23:00 <noteventime> Is there some name for a reader that takes a variable number of values? Like the type "data Reader p a = F (p -> Foo p a) | N a"?
15:23:11 <veinor> or am I going to have to write one by hand
15:23:34 <skorpan> veinor: i just gave you the link to taglib, it should do it
15:23:44 <noteventime> It could probably be more or less as well be implemented in the State monad
15:23:58 <veinor> doesn't that require the installation of an external library though?
15:24:12 <edwardk> noteventime: that looks kind of like an Iteratee., data Iteratee i o = Done o | Cont (i -> Iteratee i o)
15:24:34 <veinor> I was hoping for pure haskell
15:24:43 <skorpan> veinor: afaics, it is pure haskell
15:24:45 <noteventime> edwardk: Interesting
15:24:46 <skorpan> oops, nope
15:24:56 <skorpan> lots of FFI in there ;P
15:25:03 <veinor> the hackage package is, but taglib sure as heck isn't :P
15:25:38 <edwardk> noteventime: the nice thing with that iteratee is that it can be made into a monad
15:25:58 <noteventime> edwardk: I know :)
15:26:04 <edwardk> noteventime: heh
15:26:06 <noteventime> I wrote one a few minutes ago
15:26:09 <edwardk> ah
15:26:20 <noteventime> Which is what got me curious
15:26:27 <edwardk> i use a variant on that theme for making resumable parsec parsers
15:26:41 <noteventime> edwardk: Is it part of the Itaratee package?
15:27:08 <edwardk> noteventime: nah, its something i use for my own compiler stuff, the iteratee in the iteratee package isn't sufficient to my needs
15:27:36 <edwardk> because i need to have an iteratee that holds onto its input rather than discards it, which means i wind up using a fingertree of bytestrings, and some other craziness to make it all efficient
15:28:21 <edwardk> noteventime: i'll put up my slides after i give a talk on it in a couple of days
15:28:56 <noteventime> It feels like some kind of "reified curry" (abuse of terminology)
15:29:09 * copumpkin is about to cook some reified curry
15:29:16 <veinor> sounds delicious
15:29:23 <copumpkin> it will be
15:29:39 <noteventime> Sounds more like curry gone bad :)
15:29:41 <edwardk> upon reflection, once i reify the curry i ate earlier, i doubt i'd want to eat it
15:29:47 <copumpkin> lol
15:34:12 <monochrom> Eating is uncurrying.
15:34:54 <noteventime> Hmm, isn't reader basically an extended(?) lambda expression where p is the type of variables and a are "primitive" data?
15:35:25 <noteventime> And F being abstraction
15:35:59 <noteventime> Or am I being silly :|
15:36:15 <copumpkin> ?
15:36:49 <olsner> you mean, Reader a b is like (a -> b)?
15:36:54 <mreh> i've imported a record, but the record fields aren't in scope
15:37:01 <mreh> what have i done wrong?
15:37:23 <monochrom> import MyMod(MyRec(..))
15:37:35 <noteventime> olsner: kinda, but since it can be an arbitrary number of (a ->)s
15:37:37 <ray> Reader a b *is* (a -> b)
15:37:46 <monochrom> I mean: import MyMod(MyRecType(..))
15:37:57 <noteventime> ray: This is another reader
15:38:08 <noteventime> Was from a question from earlier
15:38:27 <mreh> monochrom: records are types, do you need to make it explicit?
15:38:37 <olsner> oh, a different reader... I didn't read any of the preceding conversation btw
15:38:43 <noteventime> "data MReader p a = F (p -> MReader p a) | N a"
15:38:51 <monochrom> No. I was just choosing a better name for my record type.
15:39:08 <noteventime> I used it as a reader which takes an unknown number of values
15:39:20 <ray> oh, you mean the iteratee thing
15:39:30 <noteventime> Yes, I was told it was an iteratee
15:39:47 <noteventime> I hadn't seen it before
15:42:43 <veinor> skorpan: for some reason I can't get taglib to work
15:42:57 <noteventime> I figured it should be good for something, I'll read some more about enumerator/iteratee
15:43:19 <skorpan> veinor: i'm sorry, i haven't ever worked with it
15:43:23 <veinor> ah :(
15:43:23 <mreh> The HGL module Graphics.HGL.Key doesn't use the type Event defined in Graphics.HGL.Window, even though Key is one of the contructors in Event
15:43:41 <veinor> well, crap. any others you know of?
15:45:16 <noteventime> Funny it should be useful for server-type applications, I was just going to try out haskells networking capabilities
15:48:23 <veinor> Hm, I might just wind up writing my own id3 parser
15:48:38 <veinor> shouldn't be terribly difficult as long as I don't care about silly things like standards compliance :D
15:49:23 <skorpan> yeah, screw standards, non-compliance is the way to go
15:49:25 <luite> dcoutts: I think I've installed gtk2hs now, with make DESTDIR install, copy tree to final location, find/replace on the *.package.conf and then ghc-pkg register each one. but there still is something wrong:
15:49:30 <luite> Loading package glib-0.10.1 ... <command line>: can't load .so/.DLL for: glib-2.0 (addDLL: could not load DLL)
15:49:35 <skorpan> look at microsoft, they make up their own standards all the time
15:49:53 <mreh> skorpan: they can afford to
15:49:55 <monochrom> non-compliance is why the real world is so difficult.
15:50:17 <veinor> well
15:50:32 <skorpan> microsoft invented xmlhttprequest, i'd bet you a dollar if someone else came up with it, they'd still go for their own variant which didn't comply
15:50:41 <hackagebot> archlinux 0.2.2 - Support for working with Arch Linux packages (DonaldStewart)
15:50:54 <veinor> I'm going to try to make it standards-compliant, and the first few versions are going to be read-only
15:51:01 <dcoutts> luite: oh, drat. That. In --enable-packager-mode on Windows I think it does some cunning sed to set the extra-ghci-libraries fields in the *.package.conf files.
15:51:39 <mreh> doesn't anyone know the answer to my HGL problem? :(
15:52:29 <luite> dcoutts: ok, I'll try that. by the way, is there some documentation about building a binary installer package for windows, for gtk2hs?
15:52:42 <monochrom> non-compliance is likely a tragedy of commons. it makes one person's life easy (inventor's life) and everyone else's difficult (all the rest of us who now have to parse his stupid non-compliance)
15:52:46 <dcoutts> luite: yes, on the gtk2hs website in the FAQ
15:53:27 <dcoutts> luite: oh, hmm, actually that doesn't mention the installer.
15:53:50 <dcoutts> luite: in the gtk2hs darcs repo in the tools/win32 dir there are a bunch of scripts for building gtk2hs and making an installer.
15:54:09 <dcoutts> it uses InnoSetup which is Free Software
15:54:40 <luite> ok
15:55:54 <suravad> This is a stupid question but I'm curious.  I create a naive Integer power function... Nice and all.  But what I don't get is if I do like pow 999999 999999 it comes back with a stack overflow... Understandable.  But it comes back within a second.  Whereas pow 10 (1024 * 384) chugs away for a few minutes and then spits out a really long number of 0s.
15:56:17 <suravad> How does it detect the stack overflow within a second or so.
15:56:26 <mreh> suravad: it happens after the first calculation
15:56:38 <suravad> mreh:  How?
15:56:49 <suravad> Prelude> let { pow' 1 t n = t * n; pow' c t n = pow' (c - 1) (t * n) n; }
15:56:49 <suravad> Prelude> let { pow n p = pow' p 1 n; }
15:57:04 <suravad> That's my naive power function.  (Don't laugh it was just an experiment) :)
15:57:24 <mreh> 99999 * 99999 is a huge number already
15:57:43 <Baughn> suravad: I'm not sure I understand your question. You're asking how it detects the stack overflow? Or why the library pow function doesn't overflow?
15:57:45 <Saizan> mreh: that doesn't cause a stack overflow per se
15:57:47 <mreh> overflows relatively quickly
15:58:02 <mreh> oh, stack overflow
15:58:27 <suravad> Baughn:  I suppose I'm asking how it detects the stack overflow.
15:58:44 <mreh> suravad, memory leaks from your stack to another place
15:58:47 <suravad> Baughn:  Only because it detects the stack overflow within a second or two.
15:58:50 <Baughn> suravad: That's out of haskell entirely and down to the machine level, then. Do you understand how the MMU works?
15:58:51 <Saizan> suravad: your function has 't' as a lazy accumulator, that's a common cause of stack overflows
15:58:53 <mreh> it tries to access memory outside of your stack place
15:59:00 <suravad> Baughn:  No, no, no...
15:59:18 <mreh> suravad, use seq
15:59:27 <monochrom> stack overflow is easy to detect by using a small stack and letting the overflow happen. small stack means short time.
15:59:28 <Baughn> suravad: Although actually, IIRC ghc stacks can be much smaller than a page, so I suppose it has to be checking using software
15:59:33 <Saizan> @hackage Stack oveflow
15:59:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Stack oveflow
15:59:47 <Saizan> @wiki Stack oveflow
15:59:48 <lambdabot> http://www.haskell.org/haskellwiki/Stack_oveflow
16:00:14 <monochrom> > 1024 * 384
16:00:14 <Saizan> suravad: read the section of foldl, it fits your case
16:00:15 <lambdabot>   393216
16:00:20 <Saizan> *on
16:00:27 <Baughn> suravad: ..the amount of stack space a function needs is known at compile time. In this case, the compiler would add a check to the start such that, if that need exceeds the allocated space, it'll reallocate or, if it goes /too/ high up, throw an exception.
16:00:31 <mreh> use foldl and duplicate
16:00:38 <monochrom> But I can't explain why 393216 doesn't stack-overflow.
16:00:49 <Saizan> mreh: can you stop saying nonsense, please?
16:01:12 <Baughn> suravad: Most languages use the hardware for that check (the MMU), but then you can't have a stack smaller than one page (have to allocate in units of a page).
16:01:40 <Baughn> That help?
16:01:43 <suravad> Baugn:  I think that makes sense... Doing this in ghci.  So the stack overflow is at compile time... Then it tries to calculate the results.  Gotcha.
16:01:53 <mreh> Saizan: no
16:02:01 <Saizan> the stack overflow _is not_ at comple time
16:02:12 <Baughn> suravad: The stack overflow doesn't happen at compile-time. THe amount of stack space /each/ invocation of a function takes is known at compile-time.
16:02:20 <mreh> even agreeing not to talk nonsense validates that i was
16:02:29 <Baughn> suravad: But either way, all it has to do is check against the allocated space every time it tries to use somme
16:02:35 --- mode: ChanServ set +o Saizan
16:02:47 <monochrom> pow 99999 99999 doesn't stack-overflow on me. Still crunching.
16:03:13 <monochrom> GHC 6.8.2. Using ghci.
16:03:13 <Berengal> Doesn't ghc use a 8Mb stack by default?
16:03:19 <suravad> monochrom Try pow 2 99999 * 99999
16:03:20 <Saizan> mreh: saying random serious sounding things confuses people who come here for help, so it's not acceptable.
16:03:24 <Baughn> Berengal: An 8MB stack /limit/
16:03:35 <Baughn> Berengal: IIRC the stack starts at something bizarre like 24 bytes
16:03:35 <mreh> the stack overflow happens because of the massive number of thunks the function calls generate, right?
16:03:48 <Berengal> Baughn, limit schmimit :P I program in haskell, not assembly
16:03:50 <Baughn> mreh: Not exactly
16:03:53 <Philonous> suravad: You function doesn't compute anything for big numbers. It just creates a lot of thunks and then crashes. If your stack is sufficiently small that can happen rather soon
16:03:55 <mreh> Saizan: hardly random
16:04:05 <Baughn> mreh: It happens because of the massive number of thunks it has to enter /at once/
16:04:10 <monochrom> pow 2 99999 * 99999  doesn't stack-overflow either.
16:04:20 <Saizan> it's actually a single thunk of massive size
16:04:29 --- mode: Saizan set -o Saizan
16:04:29 <Baughn> mreh: When forcing thunk A forces thunk B, which forces thunk C.. if that goes on far enough, you get stack overflow
16:04:38 <suravad> Sorry... thunk?
16:04:51 <Baughn> Saizan: Physically? I always figured it as a linked list of thunks.
16:04:53 <Saizan> suravad: suspended computation, because of lazyness
16:05:02 <suravad> Saizan:  Ah... OK.
16:05:12 <Baughn> Saizan: Eg. not contiguous in memory
16:05:15 <Philonous> suravad: The stock pow function uses a smarter algorithm that only needs about O(log n) multiplications, compared to to the O(n) yours needs.
16:05:15 <Saizan> Baughn: ah, yeah, in that sense they are many nested thunks
16:05:36 <suravad> Saizan:  Earlier you mentioned I'm using a lazy decriment... How would I make that non-lazy?
16:05:42 <Berengal> suravad, when you say (x * y), the result is actually not computed. It is only computed when the value is needed, for example when used in a pattern match
16:05:53 <suravad> Philonous:  This I know.  I just did it as a quick kinda test.
16:05:54 <Saizan> suravad: using seq or bang patterns
16:06:04 <mreh> Saizan: I just said that
16:06:07 <Baughn> suravad: By understanding how GHC evaluates thunks. ^_^
16:06:08 <suravad> Philonous:  Which I'm glad I did because it brought to my attention what we're discussing now.
16:06:18 <mreh> copy cat
16:06:23 <suravad> Berengal:  I understand that.
16:06:38 <Baughn> suravad: You'd end up using seq or bang-patterns, but if you don't understand how ghc works under the hood, it's basically cargo-cult programming
16:06:46 <gwern> ”That’s off by a factor of 1010^120, which is only O(1) and is therefore irrelevant.” “For years, people tried unsuccessfully to prove this sort of impossibility result was impossible.  Our result shows the impossibility of their goal.
16:06:50 <Baughn> ..sadly, I've yet to see a tutorial explaining it
16:07:05 <ray> #haskell explains it every couple days
16:07:25 <Baughn> It'd be nice not to have to. ^^;
16:07:32 <Baughn> @remember gwern "For years, people tried unsuccessfully  to prove this sort of impossibility result was impossible.  Our  result shows the impossibility of their goal
16:08:01 <lambdabot> Done.
16:08:06 <ray> i think it's very useful, it could be the standard first thing a haskeller explains to a newbie
16:08:08 <mreh> I read a good tutorial on seq somewhere on haskell.org i think
16:08:15 <Berengal> Didn't someone copy a log of Cale explaining this to someone?
16:08:19 <Saizan> suravad: basically your 't' argument never gets inspected until the end, where it's presumably become a big lazy suspended expression, you instead want to reduce it during the recursion
16:08:37 <mreh> I think Saizan will take exception to the quality of the tutorial i /did/ read
16:08:39 <Baughn> ray: That'd scare people away for sure.
16:08:53 <Baughn> But it /is/ something you need to know, so maybe the third thing
16:08:57 <ray> i mean, the first thing that person explains
16:09:03 <ray> not the first thing to teach someone new
16:09:07 <ray> like a rite of passage
16:09:10 <Saizan> suravad: e.g. pow' 1 t n = t * n; pow' c t n = t `seq` pow' (c - 1) (t * n) n;
16:09:31 <mreh> Why doesn't he just read about fold;
16:09:36 <mreh> foldl' *
16:09:58 <Saizan> suravad: this explains the same issue in the context of foldl http://www.haskell.org/haskellwiki/Stack_overflow
16:10:14 <olsner> ... someone proved the impossibility of proving the impossibility of a certain impossibility result?
16:10:29 <olsner> I think that quote blew my negation stack
16:10:31 <Baughn> ray: Do that, and you're likely to get it wrong. I never fully understood this stuff before I /had/ to learn, in order to abuse unsafePerformIO safely. :P
16:10:48 <Baughn> For "a tiny change in GHC's evaluation system will lead to disaster" values of "safely"
16:10:49 <Berengal> olsner, fix not?
16:11:16 <monochrom> Richard Bird's book "an introduction to functional programming using haskell" 2nd edition explains this laziness, stack overflow, and how to use seq to cure it. No cargo cult. Science.
16:11:21 <ray> baughn: just have cale or someone standing by to supervise them
16:11:31 <mreh> suravad: here's the page that explained it to me http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
16:11:33 <gwern> Baughn: that wasn't me, that was scott aaronson
16:11:47 <suravad> OK... So basically my stack overflow is coming from creating a lazy number (the total)...  Interesting.
16:12:07 <Baughn> gwern: We're on the internet. Nobody can prove you're /not/ Scott Ãronson.
16:12:09 <Berengal> suravad, actually, the stack overflow is coming from evaluating that number
16:12:22 <suravad> Berengal:  That's what I meant. :)
16:12:38 <gwern> Baughn: fortunately, with appropriate crypto keys we can prove either that p is in np or that I and scott aaronson are not dogs
16:12:43 <olsner> Berengal: fix not = "I give up"
16:12:45 <mreh> monochrom: are you a fan of Feynman?
16:13:15 <Baughn> gwern: You cannot possibly use crypto to prove that you're no dog.
16:13:55 <gwern> we simply have to arrange some zero-knowledge proofs of my dna with a k-federated third party tester...
16:14:25 <suravad> monochrom:  Would you recommend that book for someone familiar with programming in procedural languages (C, C++, Java, etc)?
16:14:33 <ray> i wonder if we can use crypto to prove that drong is not a cat
16:14:59 <suravad> Baughn:  If we want to get into philosophy you can only prove that you don't exist and probabilities...  Not even concrete probabilities.
16:15:08 <suravad> Err... Prove that you exist.
16:15:27 <Baughn> suravad: That's not a problem for me. I'm fine with bayesian logic.
16:15:46 <suravad> I suck at maths. :(
16:16:11 <Baughn> Philosophers get confused at not being able to gain total certainty
16:16:29 <mreh> Daniel Dennett, he's a real snoozer
16:16:31 <suravad> I get confused on which way to wipe... :)
16:16:36 <Baughn> Those of us who live in the real world redefine "true" to mean "> 99.999% probability", and use bayes' law to compute it
16:17:32 <suravad> Well since monochrom didn't answer... Baughn... Your thoughts on Richard Bird's book "An Introduction to Functional Programming Using Haskell" 2nd Edition?
16:17:42 <Baughn> suravad: Haven't read it.
16:18:02 <QP> The word "true" has rather a lot of different possible meanings...
16:18:08 <Berengal> suravad, if you're looking for books, RWH and LYAH are good
16:18:12 <Baughn> QP: No. No, it doesn't.
16:18:25 <suravad> Berengal:  RWH LYAH?
16:18:28 <Baughn> QP: It means "actually out there, in reality". No more, no less.
16:18:30 <Berengal> @where RWH
16:18:31 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
16:18:32 <Berengal> @where LYAH
16:18:32 <lambdabot> www.learnyouahaskell.com
16:18:56 <suravad> Cool... Thanks.
16:19:02 <QP> i think you'll find that's no closer to being properly defined
16:19:15 <Berengal> Baughn, yes it does. In C it means not zero, in Haskell it means True...
16:19:22 <QP> "True" has a well defined meaning... :-)
16:19:42 <suravad> QP:  I believe Berengal just proved you wrong.
16:19:43 <Baughn> I see a lot of people trying to confuse the meaning, yes. :P
16:20:09 <QP> well i can tell you at least two possible meanings
16:20:18 <Berengal> I use the word "true" to mean different things in different contexts (although probably not as much as non-programmers)
16:20:21 <Baughn> QP: http://yudkowsky.net/rational/the-simple-truth <- Have you read this?
16:20:52 <QP> firstly, the meaning you gave---99.9999% chance or whatever...
16:21:04 <Baughn> QP: Ah, that's not really "true".
16:21:04 <QP> no, i'll check it out if you want
16:21:19 <mreh> The HGL module Graphics.HGL.Key doesn't use the type Event defined in Graphics.HGL.Window, even though Event(Key) is the only useful instance of a type called "Key"
16:21:37 <Baughn> QP: True is "100% chance", but that is of course unattainable in reality. So I consider the /word/ "true" to refer to the /concept/ "almost certainly true".
16:21:45 <mreh> constructor "Key", I'm so stumped on this one
16:21:47 <Baughn> QP: And yes, please do. :)
16:22:13 <QP> so, exactly, you accept the word true has many different possible meanings?
16:22:35 <QP> which is what i said
16:22:44 <Baughn> I accept that different people can assign different meanings to the word, if that's what you mean
16:22:49 <QP> but, perhaps not a clearly
16:22:58 <QP> yeah, i guess
16:23:01 <Baughn> I do *not* accept that there actually *are* different valid concepts of truth
16:23:11 <QP> i personally use it to mean different things
16:23:34 <Berengal> I take the functional approach: Concepts are immutable (values). Words are names refering to concepts, but which concept depends on the context (variable/symbol)
16:23:44 <Saizan> there's a single concept of true, one for each formal system you use :)
16:23:54 <Berengal> Saizan, true
16:24:08 <olsner> "true" :)
16:24:46 <MyCatVerbs> Saizan: surely there are formal systems with more than one value for "true" in them?
16:25:08 <Baughn> MyCatVerbs: I don't believe such formal systems have very much to do with reality, but sure. :P
16:25:15 <olsner> wouldn't that be a single definition of true as more than one value?
16:25:37 <Saizan> MyCatVerbs: i'm intrigued, examples?
16:25:44 <Baughn> Reality appears to run on bayes' law with f(computational complexity) for a prior
16:25:49 <Berengal> In LISP every value not nil is true
16:26:00 <QP> so your single 'valid' concept of truth is mathematical truth? 2+2=4, etc... ?
16:26:11 <mreh> am I mute?
16:26:18 <Saizan> mreh: no
16:26:29 <mreh> thank god
16:26:45 <dons> for those who haven't seen monadius. http://www.reddit.com/r/programming/comments/9b7li/monadius_an_openglbased_haskell_clone_of_the_game/
16:26:48 <dons> it rocks
16:26:51 <Baughn> QP: Again, I don't believe the varying mathematical concept of truth has much to do with reality.
16:27:20 <QP> so what is your single 'valid' concept of truth then?
16:27:37 <randomwords> I've emailed the address on the hackageDB website to request an acocunt. Is there anyone else here I can bug to get one?
16:27:43 <Saizan> Baughn: reality has nothing to do with truth! you only get a reasonable confidence
16:27:43 <Baughn> Objective statements about the state of the universe
16:28:09 <Berengal> Baughn, you need to define reality first. I don't think you'll be able to convince me any definition is true
16:28:13 <dons> randomwords: you emailed ross?
16:28:38 <randomwords> dons: ross@soi.city.ac.uk, yup. Guess I'm just being impatient
16:28:40 <Baughn> Saizan: Don't you mean that we never have certain knowledge of whether a given statement is actually true?
16:28:45 <QP> Saizan: for example, in topos theory, any topos can be considered an alternative to Set in which things have more possible truth values than just true and false
16:28:48 <dons> randomwords: he'll open up the account on Monday, probably
16:28:57 <Baughn> Saizan: It either describes reality correctly, or not correctly, but we can't necessarily know which
16:28:58 <randomwords> dons: Aweomse.
16:29:11 * randomwords can't type
16:29:55 <Berengal> Reality is overrated anyway. Go formal systems!
16:30:27 <mreh> Haven't any of you heard of Godel
16:30:41 <Saizan> Baughn: i consider the probability that a given statement is 100% correct near to zero
16:31:15 <randomwords> dons: It might be worth nothing that you can't build monadius using cabal. The last OpenGl update broke it (and lots of other incorrect code).
16:31:21 <randomwords> s/nothing/noting
16:31:38 <Berengal> mreh, ooo, that reminds me I need to read GEB
16:31:56 <dons> randomwords: oh, good point. needs upper bounds.
16:32:01 <dons> the Arch Linux package is fine though
16:32:06 <QP> GEB = Awesome
16:32:15 <randomwords> dons: Anything < 2.3.0.0 should probably be OK
16:32:16 <mreh> Berengal: don't bother, read Advent of the Algorithm
16:32:20 <QP> well, until about half way
16:32:23 <Saizan> mreh: the Key constructor of the Event datatype contains a value of the Key type, which is distinct, does that clarify a bit?
16:32:41 <Baughn> Saizan: That seems incoherent. A statement is either correct or not; you can assign probabilities to your knowledge of its truth, but not to the truth itself
16:32:43 <Berengal> What's this nonsense? My work provided me with free access to 8000 computer books, but GEB isn't one of them?!
16:33:03 * Berengal is not happy having to settle for "C++ for dummies" :(
16:33:03 <randomwords> I think GEB is somewhat overrated.
16:33:13 <mreh> I think you're right
16:33:23 <QP> How do you know for sure that there really is an unknown 'real' answer?
16:33:28 <Baughn> Saizan: Eg. "I'm sitting on a chair" is either correct, or not correct. You can assign a probability to it, but that doesn't mean it's 50% true; it's either 0% true or 100% true
16:33:47 <mreh> QP: ontological undecidability
16:33:51 <mreh> you cant
16:33:57 <Saizan> Baughn: i wasn't assigning probability to the value of truth
16:34:03 <mreh> stop talking about fuzzy logic
16:34:13 <mreh> as if really means something
16:34:13 <QP> but the word 'chair' is hugely dependant on human beings to be understood...
16:34:13 <Baughn> Saizan: Then I don't understand your sentence
16:34:40 <Baughn> QP: So replace "sitting on a chair" with "there is a planet in this orbit", which isn't
16:35:00 <mreh> QP: now you're talking about Wittgenstein
16:35:09 <QP> actually, planet seems to change it's meaning quite regularly
16:35:25 <QP> oh, i remember the glory days of Pluto...
16:35:27 <monochrom> mreh: I think I am a fan of Feynman.
16:35:31 <Baughn> "Using the current definition of "planet"".
16:35:39 <Baughn> Though I'm pretty sure we'd never redefine Earth as a non-planet.
16:35:44 <Saizan> Baughn: what i meant is that scientific laws will probably always be only approximations, specific observations can be agreed upon as true, i guess
16:35:45 <Baughn> Unless we take it apart.
16:35:46 <monochrom> suravad: I recommend Bird's book to everyone.
16:36:03 <mreh> monochrom: why? because of the good thinks he did? or the nasty things he said?
16:36:14 <monochrom> A bit of both! :)
16:36:27 <Baughn> Saizan: If it comes to actual observations, you can never agree that anything is true, only probably true
16:36:45 <Baughn> Saizan: ..for one thing, as QP pointed out, the objectivist concept of reality might be /wrong/.
16:36:50 <twanvl> you can assign a probability conditional on your knowledge of the world
16:36:52 <Baughn> Seems unlikely, but it can't be fully disproven. Nothing can.
16:37:02 <monochrom> @quote monochrom Bird
16:37:02 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
16:37:02 <lambdabot> entire human race would have to be rewritten!
16:37:42 <Saizan> Baughn: yeah, in fact that's why i don't like to talk about "true" outside of a formal system
16:38:09 <monochrom> It's true.
16:38:14 <monochrom> <duck>
16:38:29 <Baughn> Saizan: You shouldn't talk about it inside one, either. You can never be sure there isn't a contradiction lurking just out of sight, and for that matter you can't be sure you don't have brain damage preventing you from noticing it either.
16:38:51 <Baughn> Stick to probabilities for real-life purposes. :P
16:39:08 <Saizan> i don't have real-life purpouses!
16:39:09 <monochrom> You can talk about "true" if you relax its strength.
16:39:17 <QP> the presence of a contradiction doesn't actually remove the concept 'True'
16:39:29 <QP> it just forces it onto every statement
16:39:42 <Baughn> It removes its usefulness.
16:39:59 <kulakowski> And your concept is useful?
16:40:03 <Saizan> you at least know how to prove something "true", if a specific proof is incorrect is another matter entirely
16:40:21 <Baughn> kulakowski: What, bayesian logic? I'd think so. It's worked very well.
16:40:25 <monochrom> Is there true Haskell?
16:40:45 <Berengal> (\x. \y. x) is true and useful, even in the presence of a paradox
16:40:55 <monochrom> (There. One single question that links existence and truth back to Haskell. :) )
16:41:03 <Baughn> Hum. I can't quite convince myself that a formal system containing contradictions would necessarily be useless, but I haven't seen any complex ones either
16:41:08 <Baughn> It would be interesting to check
16:41:39 <QP> Berengal: as is A => (B => A), which is really the same thing...
16:41:49 <twanvl> Baughn: Paraconsistent logic
16:41:50 <Saizan> however as monochrom reminds us, this is fairly off-topic
16:42:12 <Saizan> it should continue to #haskell-blah
16:42:26 <QP> is there really such a channel?
16:42:30 <Saizan> yes
16:42:34 <QP> hehe
16:42:54 <monochrom> heh
16:43:08 <QP> that is silly
16:43:22 <QP> "luscious fruits" indeed
16:43:32 <monochrom> Any more stack overflow?
16:43:59 <QP> ok, haskell question:
16:44:28 <QP> what's the canonical way of treating things that might be any of n different types?
16:44:48 <QP> is there an extension of Either to OneOfN?
16:45:07 <twanvl> QP: just define a custom data type
16:45:14 <monochrom> I first try to write one data type to contain those n cases.
16:45:52 <QP> monochrom: that's an interesting point
16:46:05 <monochrom> which is what twanvl says :)
16:46:16 <QP> twanvl?
16:46:21 <twanvl> a generic solution would become ugly, just like n-tuples (for n>2 or 3)
16:46:57 <monochrom> Too often you want to give your own names and tailor-make your own tailor-makes. A very general OneOfN is not worth the effort.
16:47:10 <QP> sorry i went temporarily nick-blind
16:47:28 <QP> ok i see now
16:47:29 <twanvl> PQ: that happens to the best of us
16:47:40 <Saizan> you could read Data Types a La Carte if you want to see a generic solution
16:48:17 <QP> has someone defined an operator like :: (a -> a) -> (b -> b) -> Either a b -> Either a b?
16:48:31 <QP> or---oh
16:48:36 <twanvl> ?type (+++)
16:48:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
16:48:39 <QP> sorry silly question
16:48:42 <monochrom> @type either
16:48:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:48:50 <pikhq> Ah, +++.
16:48:55 <monochrom> That would do it.
16:49:04 <monochrom> (Let c = Either a b)
16:49:38 <QP> ok, I need to read about Arrows
16:49:41 <monochrom> I guess +++ is even better.
16:50:16 <monochrom> For now there is little to Arrows apart from: "a b c" has a special case "b->c".
16:50:44 <QP> so thinking of -> as kind * -> * -> *?
16:50:54 <monochrom> Yah!
16:51:03 <hydo> Anyone have any luck with using ghc on the new osx?  I'm downloading the haskell platform to try that after the ghc binary package blew up.
16:51:15 <QP> why 'for now'? what will they become?
16:51:36 <Saizan> QP: that depends on the use they will get
16:52:02 <Berengal> There's also Kleisli arrows, but they're usually inlined with <=< and >=>
16:52:10 <QP> i read they were going to replace the whole "do" monadic stuff we use now...
16:52:34 <Saizan> there's special syntax for Arrow too
16:52:35 <ray> arrows are like functions as a typeclass
16:52:35 <QP> maybe that was the Kleisli arrows
16:52:49 <QP> yeah..
16:52:49 <Saizan> but it's separate from do-notation
16:52:56 <ray> functions are an instance, but so are other things like Kleisli arrows
16:53:03 <QP> i see
16:53:18 <ray> Kleisli m a b = Kleisli { runKleisli :: a -> m b }
16:53:35 <Berengal> Personally I've found applicatives to be more fun
16:53:49 <ray> you can just think of the arrow combinators as applying to functions if you want to understand them easily
16:53:52 <ray> then generalize them
16:54:20 <QP> what do arrows give you that monads don't?
16:54:27 <ray> so +++ would become (b -> c) -> (b' -> c') -> (Either b b' -> Either c c')
16:54:33 <monochrom> "for now" means I believe in a pedagogical technique of telling a special case and postponing the general picture. (There is no upper limit on generality anyway.)
16:54:38 <ray> just replacing 'a' with (->)
16:54:40 <Berengal> QP, all monads are arrows. Not all arrows are monads
16:54:42 <Saizan> AppMonad f m a b = AppMonad { AppMonad :: f (a -> m b) } is an Arrow too
16:54:55 <QP> (we are already really using the Kleisli category all the time)
16:54:55 <dmwit> QP: They let you inspect both the input and the output.
16:55:00 <ray> monochrom: yes, i think that makes the most sense for arrows
16:55:12 <QP> dmwit: ok, cool
16:55:20 <dmwit> QP: The paper on using Arrows for parsing has some great examples of static analysis that you can do with Arrow but not Monad.
16:55:32 <ray> they are very easy to understand via the special case of ordinary functions
16:55:43 <QP> dmwit: what paper is that?
16:55:47 <dmwit> um
16:55:56 <QP> i'll search for it
16:55:58 <dmwit> Give me a second to finish watching this Louis CK video and I'll link you. =)
16:57:34 <QP> is an Arrow like a combination of a monad and a comonad?
16:58:11 <QP> ordinary functions are, anyway, i think...
16:58:57 <Berengal> Ordinary functions are comonads?
16:59:04 <monochrom> Someone should really victimize a selected group of children by teaching them abstract division rings and Cayley numbers at kindergarten, then slowly progressing to quaternions, complex numbers and abstract fields, real numbers and abstract ordered fields, rational numbers, integers and rings, finally natural numbers at grad school, and write a journal paper about it proving once and for all this is fail.
16:59:23 <QP> hehe?
16:59:38 <Berengal> monochrom, why?
16:59:47 <ray> well, we do the opposite wrong thing now, which is teach them arithmetic and then stop
16:59:54 <QP> a -> b is a monad relative to b, a comonad relative to a... i believe
17:00:07 <Berengal> monochrom, it seems link you harbor some kind of hatred towards mathematics...
17:00:17 <monochrom> Because the biggest problem with this channel and elsewhere is that there is no paper, no experiment I can cite in protest when people give too much information.
17:00:34 * Lycurgus doesn't know but presumed that the arrows were supposed to be like those primitive in category theory
17:00:45 <ray> they can be
17:01:06 <Lycurgus> like, inspired by, whatever
17:01:20 <Lycurgus> an implementation of
17:01:32 <EvanR> i am using hugs for the first time, and trying to define my first haskell function such as double x = x+x, but it says unexpected '='
17:02:02 <Berengal> EvanR, 'let double x = x+x', I believe. I haven't used hugs, but it's like that in ghci anyway
17:02:08 <EvanR> oh
17:02:10 <monochrom> Write it in a file. Don't write it at the prompt.
17:02:38 <Berengal> EvanR, the interpreters are a little weird on the syntax...
17:02:43 <EvanR> i see
17:03:17 <Berengal> I mostly use ghci for evaluating expressions and inferring types, not defining things
17:04:35 <EvanR> thanks. i am using the book programming in haskell by hutton
17:05:00 <dmwit> QP: http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
17:05:06 <dmwit> QP: The sections on parsing in particular.
17:05:12 <QP> dmwit: thanks, that's great
17:05:15 <dmwit> QP: The other bits are probably good too, but I haven't read them.
17:05:37 <monochrom> I don't hate mathematics. I hate stupid methods of teaching anything.
17:06:17 <monochrom> The more I love mathematics, the more I should hate methods of misrepresenting mathematics, don't you agree?
17:06:22 <Berengal> monochrom, there's a fine difference between too much information and lying by omission. Personally I think the former is the prefered way to fail
17:06:28 <Saizan> QP: type b :<-: a = a -> b; (b :<-:) is not a comonad if that's what you meant
17:07:10 <Saizan> QP: you can define a comonad with Monoid a => (a ->) though
17:07:22 <randomwords> I agree with Berengal
17:07:52 <Saizan> QP: and you can make an arrow instance for "w a -> m b" with Comonad w, Monad m
17:08:18 <monochrom> See, this is why I want that experiment done and reported. So it will prove you wrong.
17:08:21 <Berengal> monochrom, anyway, adults have a very different capability of abstract thought than children
17:08:58 <Berengal> monochrom, you need to victimize a select group of children by not teaching them any mathematics until they're 25, then do that thing with the rings and stuff
17:09:20 <Berengal> (in addition to your proposed experiment)
17:09:40 <randomwords> monochrom: I don't disagree with you entirely. I just think when you are telling your pedagogical half truths they should come with a caveat that generalisations do exist.
17:09:59 <monochrom> Yes. I say "for now" when I do it.
17:10:14 <randomwords> Is that enough?
17:10:32 <monochrom> In addition to saying "a special case".
17:10:35 <Berengal> Far too often during my education I found that what I thought to be true was just a specialized or dumbed down version of the real truth...
17:10:49 <monochrom> <monochrom> For now there is little to Arrows apart from: "a b c" has a special case "b->c".
17:10:53 <randomwords> Berengal: Exactly
17:10:55 <monochrom> exact quote
17:11:31 <Berengal> The best teachers I had were the ones who admitted this when asked. Many of them denied it, even when they knew it was true. None of them volunteered this information
17:11:38 <randomwords> Berengal: especially when the dumbed down version is taught with such conviction.
17:12:07 <randomwords> Berengal: The ones that worry me the most are the ones who don't have the full picture themselves
17:12:53 <Berengal> randomwords, as long as they're capable of telling me they don't know something...
17:13:35 <skorpan> to ride, shoot straight and speak the truth
17:14:09 <monochrom> "the truth" is a 3.5 TB file.
17:14:14 <Berengal> My high-school math teacher was the first teacher that admitted that mathematics wasn't always true, that for example x^2 = 0 -> x = 0 doesn't have to be true
17:14:35 <joesmoe> Hey all, ran into some trouble using the Functional Graph Library (FGL).  I keep getting "Ambiguous type variable `gr' in the constraint"
17:14:46 <Berengal> Thanks to that admission, learning programming was easy
17:15:09 <skorpan> Berengal: i don't get it, where did anyone say that x^2 = 0 -> x = 0?
17:15:28 <skorpan> oh, wait, what
17:15:29 <monochrom> When you solve equations like (y+2)(y-1)=0.
17:15:29 <skorpan> never mind
17:15:58 <skorpan> i was thinking about e.g. x^2 = 16 -> x = 4
17:16:23 <monochrom> But x^2=0 and x!=0 is quite exotic.
17:16:34 <skorpan> indeed
17:16:47 <Berengal> monochrom, it's also false, usually, unless you define some new things
17:17:11 <Berengal> The point is, it depends on which axioms you've got
17:17:27 <skorpan> you were taught this in high school you say?
17:17:45 <Berengal> No, I found out about it myself (in high school)
17:18:03 <Berengal> Now I've forgotten what they were called :/
17:18:14 <skorpan> what what are called?
17:18:29 <skorpan> the "some new things"?
17:18:33 <monochrom> An example that actually happens to everyone is "x^2=-1 is unsolvable" then "x^2=-1 is solvable!"
17:18:56 <randomwords> Berengal: Zero divisiors?
17:19:02 <skorpan> monochrom: what?
17:19:05 <monochrom> An example that happens to everyone but everyone actually forgets is "2 cannot divide into 5" then "2 can divide into 5!"
17:20:07 <Berengal> monochrom, imaginary numbers came right after, and made much more sense. I actually used them in my final exam, even though they weren't in the curriculum
17:21:34 <monochrom> I guess x^2=0 and x!=0 is not that exotic. Here is a pretty common example. Use mod 4: 2*2=0.
17:21:55 <pikhq> This is just an example of math education not really saying anything accurately at all. (whether that's necessary or not is a different matter)
17:22:45 <QP> Saizan: yes, you're right. I'm not sure why I remembered working out before that (b :<-:) was a comonad. Must have misremembered, or just been really wrong!
17:22:49 <Berengal> monochrom, there are also numbers so small that multiplied by themselves they become 0, but they aren't 0 themselves
17:22:54 <pikhq> Especially annoying is when they don't admit "2+2=4 because addition is defined so that that's true".
17:23:34 <QP> Berengal: what numbers are those?
17:23:43 <EvanR> floating point ;)
17:23:44 <pikhq> QP: Floats.
17:24:02 <monochrom> infinitestimals
17:24:10 <QP> pikhq, EvanR: uuurrrggh!
17:24:12 <EvanR> but i think denormal zero is distinct from actual zero
17:24:14 <monochrom> hahaha
17:24:17 <Berengal> monochrom, infinitestimals don't have that property
17:24:42 <kulakowski> I've usually heard those called `dual numbers'.
17:24:57 <Berengal> After heavy googling: http://en.wikipedia.org/wiki/Dual_number
17:25:05 <monochrom> heh
17:25:18 <kulakowski> R[x]/(x^2)
17:25:54 <QP> oh, is that the thing were you define e*e=0, and you get a weird something, like \mathbb{C} but stranger?
17:26:14 <monochrom> Do you have an order or metric over R[x]/(x^2) so that you can say "this is smaller than that"?
17:26:45 <QP> yeah, that is pretty weird
17:26:53 <Berengal> They're interesting when it comes to derivation. If you've got dual numbers you don't need calculus
17:27:02 <QP> oh, yeah
17:27:14 <QP> derivation is multiplying by e?
17:27:30 <monochrom> This is why I mixed up infinitestimals and dual numbers. They both do derivatives.
17:27:36 <QP> I'd like that universe
17:28:00 <Berengal> I need to learn them properly at some point. My math knowledge is sadly lacking
17:28:05 * jfoutz ponders implementing the product rule with dual numbers and no calculus.
17:28:06 <lambdabot> jfoutz: You have 1 new message. '/msg lambdabot @messages' to read it.
17:28:22 <kulakowski> monochrom: You can also live in a particular topos that doesn't have excluded middle, and therefore not exclude the possibility that both x > 0 and x < 1/n for all positive integers n.
17:29:46 <QP> kulakowski: you can get numbers like that using Conway's 'surreal' numbers. but they don't have n*n=0.
17:30:36 <QP> (where my use of 'n' was apalling---make that \epsilon^2=0)
17:31:41 <QP> instead, they just get smaller and smaller...
17:32:40 <purplepenguins> transcendental, surreal, where are the pragmatic and ineffable numbers
17:33:15 <QP> i think some large cardinals are ineffable... i've never heard of pragmatic numbers... :-)
17:34:42 <QP> i like friendly numbers.... http://xkcd.com/410/
17:35:22 <leino> is there any actual definition of 'number' in terms of the language of abstract algebra?
17:35:35 <purplepenguins> the peano axioms
17:36:02 <purplepenguins> but that only defines the natural numbers
17:36:07 <leino> isn't that just for "natural numbers" though?
17:36:12 <leino> yeah
17:36:18 <kulakowski> leino: Not that I can imagine, some things feel more like 'numbers' than others
17:36:28 <monochrom> In terms of abstract algebra, every element is a "number".
17:36:35 <randomwords> You can do everything up to the reals without analysis
17:36:43 <purplepenguins> elements don't have to be numbers
17:36:54 <purplepenguins> they could be matrices, or something else
17:36:56 <leino> so you call, say, the elements of the klein 4-group "numbers"?
17:37:01 <purplepenguins> so long as it maintains the group structure
17:37:02 <monochrom> I do.
17:37:03 <QP> leino: you could say in order to count as numbers things have to form a monoid...
17:37:14 <monochrom> There is no definition.
17:37:25 <purplepenguins> you could say the group Z under addition is the integers
17:37:39 <purplepenguins> but you could maybe find some other construct with the group structure
17:37:47 <mmmulani> how could I generate the double permutations of a list using monads?
17:37:56 <Berengal> At the end of the day, mathematics is just symbol manipulation anyway
17:38:01 <dmwit> > permutations [1..5]
17:38:03 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
17:38:07 <dmwit> mmmulani: What's a double permutation?
17:38:11 <mmmulani> uhhh
17:38:15 <mmmulani> let me provide an example
17:38:53 <dmwit> Also, "how can I XXX using monads" is often a bad question.  It's better to ask "how can I XXX".
17:39:00 <dmwit> Monads aren't the best solution for everything. =)
17:39:03 <mmmulani> [[1,2],[3,4]] -> [ [[1,2],[3,4]], [[2,1],[3,4]], [[1,2],[4,3]], [[2,1],[4,3]] ]
17:39:07 <mmmulani> ahah well yes
17:39:16 <kulakowski> Berengal: while that might be true, that's not how we humans figure out to the manipulate symbols
17:39:20 <mmmulani> I think there's a nice solution with monads, just not sure how to express it
17:39:23 <idnar> Berengal: at the end of the day, symbol manipulation is just mathematics anyway :P
17:39:25 <pikhq> dmwit: "How can I implement comonads using only monads?"
17:39:43 <Berengal> idnar, fix (mathematics . symbolManipulation)
17:40:44 <dmwit> > permutations [[1,2], [3,4]] >>= \xs : xss -> permutations xs >>= \xs' -> return (xs' : xss)
17:40:45 <lambdabot>   <no location info>: parse error on input `:'
17:40:54 <Berengal> The more I learn about formal systems, the more it seems like all of them are based on the axiom 'fix turtles'
17:40:56 <dmwit> > permutations [[1,2], [3,4]] >>= \(xs : xss) -> permutations xs >>= \xs' -> return (xs' : xss)
17:40:57 <lambdabot>   [[[1,2],[3,4]],[[2,1],[3,4]],[[3,4],[1,2]],[[4,3],[1,2]]]
17:41:08 <idnar> Berengal: haha
17:41:17 <dmwit> > permutations [[1,2], [3,4]] >>= \(xs : xss) -> permutations xs >>= \xs' -> guard (xs /= xs') >> return (xs' : xss)
17:41:18 <lambdabot>   [[[2,1],[3,4]],[[4,3],[1,2]]]
17:41:23 <dmwit> mmmulani: ?
17:41:24 <mmmulani> dmwit: oh god
17:41:26 <monochrom> I am not sure why double permutation is not ([1,2],[3,4]) -> [ ([1,2],[3,4]), ([2,1],[3,4]), ([1,2],[4,3]), ([2,1],[4,3]) ]
17:41:35 <dmwit> mmmulani: It's easier to read in do notation, probably, hold on.
17:41:49 <mmmulani> monochrom: I made up the term
17:41:51 <monochrom> But I guess "sequence permutations [[1,2], [3,4]]" may do wonder.
17:42:02 <monochrom> > sequence permutations [[1,2], [3,4]]
17:42:03 <lambdabot>   Couldn't match expected type `[m a]'
17:42:15 <monochrom> Hrm, I have to study more.
17:42:15 <mmmulani> dmwit: I wrote it recursively, though the monad way is not bad
17:42:28 <Berengal> > mapM permutations [[1,2],[3,4]]
17:42:30 <lambdabot>   [[[1,2],[3,4]],[[1,2],[4,3]],[[2,1],[3,4]],[[2,1],[4,3]]]
17:42:36 <dmwit> > let dperm xss = do { (xs:xss) <- permutations xss; xs' <- permutations xs; guard (xs /= xs'); return (xs' : xss) } in dperm [[1,2], [3,4]]
17:42:37 <lambdabot>   [[[2,1],[3,4]],[[4,3],[1,2]]]
17:42:38 <monochrom> I see!
17:43:28 <BMeph> ...and Berengal WINS!!!11!1!1one
17:43:47 <dmwit> Berengal++
17:43:56 <QP> Berengal: nice
17:44:03 <Berengal> Strange, this is the first time I've come up with a decent list-monad function that doesn't use do notation
17:44:20 * Berengal gains a level
17:45:05 <dmwit> It doesn't do exactly what he wants, but then, probably mine doesn't either, if one of the lists has duplicate elements.
17:46:28 <BMeph> dmwit: How does it not "do exactly what he wants"?
17:46:40 <mmmulani> dmwit: luckily the lists are completely unique
17:46:49 <monochrom> A bit of ordering.
17:47:10 <dmwit> BMeph: Berengal's outputs [[1,2],[3,4]], but his sample output does not have that.
17:47:35 <Berengal> dmwit, yes it does
17:47:48 <dmwit> err...
17:47:48 <BMeph> " <mmmulani> [[1,2],[3,4]] -> [ [[1,2],[3,4]], [[2,1],[3,4]], [[1,2],[4,3]], [[2,1],[4,3]] ]"...
17:47:51 <athos> @hoogle a -> b
17:47:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:47:51 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:47:51 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:47:52 <dmwit> I read wrong. =(
17:47:55 * BMeph is feeling confused!
17:47:58 <dmwit> Take the guard out of my solution, then. =P
17:48:02 <QP> it does in my definition of true....
17:48:39 <hackagebot> hfractal 0.1.0 - OpenGL fractal renderer (ChrisHoldsworth)
17:49:44 <QP> @hoogle mapM
17:49:44 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:49:44 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:49:44 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:49:55 <athos> considering the possible implementations for a function of type a -> b, i think it's not like we should ask ourselves "are types sexy". the question really is "are types like sex?"
17:50:04 <BMeph> @src mapM
17:50:04 <lambdabot> mapM f as = sequence (map f as)
17:51:39 <monochrom> Consider a more elementary solution: do { x<-permutations [1,2]; y<-permutations [3,4]; return [x,y] }
17:52:20 <monochrom> If you understand it, then all sequence/mapM comes down to is a canned version of that.
17:53:28 <mmmulani> monochrom: yeah, I was dealing with lengths of an arbitrary size
17:53:34 <mmmulani> it now makes sense why mapM works
17:53:49 <QP> > mapM permutations [[1,2],[3,4],[5,6]]
17:53:50 <lambdabot>   [[[1,2],[3,4],[5,6]],[[1,2],[3,4],[6,5]],[[1,2],[4,3],[5,6]],[[1,2],[4,3],[...
17:54:55 <Berengal> monochrom, I like to think in terms on nondeterminism.
17:55:20 <Berengal> of*
18:03:46 <monochrom> I like to, too.
18:05:19 <hackagebot> hfractal 0.1.0.1 - OpenGL fractal renderer (ChrisHoldsworth)
18:11:55 <randomwords> If anyone fancies trying hfractal / giving me some feedback that would be great.
18:14:14 <ManateeLazyCat> @hoogle mime
18:14:14 <lambdabot> package mime
18:14:15 <lambdabot> package mime-string
18:15:34 <ManateeLazyCat> Have an exist function that return MIME-type string describe for given file?
18:41:27 <copumpkin> zomg avoid recursion! http://spinroot.com/p10/
18:42:08 <Phyx-> hmm anyone got an idea how to make this more efficient? http://phyx.pastebin.com/d155c6536
18:42:11 <randomwords> Don't NASA ban recursion - or something like that
18:44:15 <monochrom> Since NASA is big and consists of so many departments, each doing its own thing, any statement of the form "NASA does ___" is highly probably false.
18:44:41 <randomwords> highly probably
18:44:42 <monochrom> One department uses Lisp and formal methods.
18:45:08 <pikhq> Another uses magnetic core memory.
18:45:11 <Makoryu> randomwords: On embedded code that runs stuff like the space shuttle, NASA actually uses (or at least has used) languages that do not permit recursion or dynamic allocation
18:45:20 <Makoryu> In other words, they're not Turing-complete
18:45:26 * Makoryu almost typed "touring complete"
18:46:09 <Phyx-> "tourist complete"
18:46:39 <randomwords> Are you sure they aren't turing complete?
18:48:13 <syntaxglitch> Phyx-, "tourist complete" sounds challenging
18:48:19 <randomwords> you only need something like subtract and branch to be turing complete.
18:48:32 <randomwords> I guess if you also dissalow jumps
18:48:43 <Phyx-> syntaxglitch: hehehe
18:48:55 <monochrom> tourist-proof
18:48:59 <bremner> well, all real computers are finite state machines, so regular expressions are more than enough.
18:49:13 <monochrom> Dijkstra called his van "touring machine"
18:49:19 <syntaxglitch> Hahaha
18:49:25 <Phyx-> syntaxglitch: instead of testing for bugs you test for "survival"
18:50:04 <syntaxglitch> survival = False -- Do you want your possessions identified?
18:50:17 <randomwords> n
18:50:22 <monochrom> If you pick a literal constant bound for every loop, you give up Turing-completeness.
19:03:17 <solrize_> randomwords, you might like http://www.jucs.org/jucs_10_7/total_functional_programming
19:18:53 <syntaxglitch> nQiDeTh6
19:18:59 <syntaxglitch> argh
19:19:12 <syntaxglitch> sorry
19:19:16 <syntaxglitch> wrong window focus :(
19:19:41 <Petrosian> syntaxglitch: If you did what I think you just did, I've managed to do that myself a few times now
19:19:46 <Axman6> rough. change that password! :P
19:19:57 * syntaxglitch grumbles
19:20:04 <randomwords> or get everyone to /clear
19:20:41 <syntaxglitch> fortunately it's just some of my home systems
19:21:10 <randomwords> at least it's nice and strong
19:21:20 <randomwords> ish
19:21:28 <syntaxglitch> strong enough for most purposes
19:21:30 <syntaxglitch> not that that helps now!
19:22:36 <zeno_> can haskell execute arbitrary windows programs?
19:22:50 <Axman6> probably
19:23:00 * syntaxglitch changes the password on the only public-facing system with that password
19:25:16 <zeno_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Win32
19:25:17 <zeno_> ah
19:25:57 <Phyx-> Axman6: lol @ Probably
19:25:58 <zeno_> and it can compile to an executible, so they don't have to install ghc, correct?
19:26:40 <Axman6> well, i avoid windows where possible, so i didn't know for sure :)
19:27:09 <zeno_> Axman6: me either! this is for a friend
19:27:16 <Phyx-> Axman6: i know, that's why i laughed
19:27:31 <Axman6> zeno_: just like the condoms? :P
19:27:31 * Phyx- knows he's in the minority group of windows haskell users
19:27:36 * Phyx- gets read to get shunned
19:28:24 <Axman6> actually, there's a very large number of haskell users on windows
19:28:40 <Phyx-> but most of then never visit #haskell
19:28:55 <Phyx-> or never talk much, the bunch of you that talk are usually on a mac
19:29:21 <DarthArachides> I wonder why is that.
19:29:49 <zeno_> Phyx-: do things generally work well?  this will be a medium sized app
19:30:50 <sm> Axman6: interesting.. how many, and what makes you say so ?
19:30:54 <luite> dcoutts: do you know what goese wrong here? I'm trying to build an installer using the tools\win32 from gtk2hs darcs, and I've installed all downloaded dependencies: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8251
19:31:08 <sm> how can there be haskell users who don't come here ?
19:31:17 <Axman6> sm: ask dons, he's got all the stats (check his blog maybe)
19:31:19 <Phyx-> zeno_: i've never executed applications from haskell
19:31:24 <sm> oh the downloads
19:31:55 <Phyx-> zeno_: but FFI is pretty stable, so if there isn't a package, you could always just use FFI to call ShellExecuteEx
19:32:08 <zeno_> ok, thanks :)
19:32:10 <sm> haskell doesn't shun windows users, I think it works pretty hard to make them equal players
19:32:20 <Saizan> System.Process works fine on windows
19:32:21 <Phyx-> sm: i dissagree
19:32:34 <sm> I submit: Haskell Platform
19:32:38 <zeno_> also, the user doenst need GHC, correct?
19:32:41 <zeno_> if its compiled
19:32:44 <Saizan> zeno_: correct
19:32:57 <Phyx-> sm: alot of packages *don't* work on windows and most people don't really care. but if it doesn't work on a linux/mac box, usually fits are thrown
19:33:02 <zeno_> ok! gets to coding
19:33:08 <sm> cabal install now works on windows. That's a pretty damn awesome step forward
19:33:24 <Saizan> zeno_: you need to compile from a windows machine though, since ghc doesn't support cross-compiling (yet at least)
19:33:27 <zeno_> Phyx-: networking stuff works, right
19:33:40 <Phyx-> yes
19:34:13 <luite> sm: if it works for the particular package you need, yes
19:34:21 <Phyx-> most mainstream packages will work on windows
19:34:25 <Phyx-> *most*
19:34:48 <Saizan> the problems are usually with bindings to some C library
19:35:16 <Saizan> in that case you often need msys to build them
19:35:37 <Phyx-> zeno_: btw, check out the System.Process package to do what you asked earlier
19:35:40 <Saizan> unless the sources of the C library are shipped inside the package, like zlib does
19:36:08 <Phyx-> @where process
19:36:09 <lambdabot> I know nothing about process.
19:36:14 <Phyx-> @package process
19:36:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/process
19:36:16 <luite> Saizan: and then you have new  problem... finding out how to build the library in the poorly documented jungle of all kinds of different packages that msys is
19:36:37 <Saizan> luite: heh, i know :)
19:37:15 <luite> in the meantime, anyone care to look at my gtk2sh (win32) build problem? :p http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8251#a8251
19:37:19 <luite> gtk2hs
19:37:23 <Saizan> so, it's more a matter of solving the packaging problem of C libraries on windows, rather than haskell ones :)
19:37:48 <zeno_> Phyx-: nice, thanks a ton!
19:37:58 <Phyx-> np
19:38:43 <zeno_> also, since you guys seem to know alot about the api is there a good networking package like twisted from python?
19:38:53 <zeno_> or people normally use sockets
19:40:20 <Phyx-> zeno_: i've always just used sockets, but if it's for http there are a plethora of packages out there for it, and some other protocols like irc etc i think
19:41:58 <m3ga> It seems that if you want to do C# then windows is the platform of choice, but for Haskell, Ocaml, Erlang, Python, Ruby either Linux or Mac is a better choice.
19:43:29 <Phyx-> m3ga: for haskell in particulair, i don't think it has anything to do with the language, just your platform of choice
19:43:45 <Phyx-> there are equally compentent tools for both platforms imho
19:43:48 <Phyx-> .win 6
19:43:50 <Phyx-> oops
19:44:27 <zeno_> m3ga: c# can be decompiled tho, and this is a no-go for my client
19:45:22 <Phyx-> zeno_: anything can be decompiled...
19:45:46 <zeno_> Phyx-: well tho, so that the classes etc can be seen
19:45:52 <m3ga> zeno_: i was *not* advocating C# :-)
19:46:16 <zeno_> Phyx-: im pretty sure you won't get anything intelligible from the assembly ghc puts out
19:46:17 <Phyx-> zeno_: obfuscation actually helps alot in that case
19:46:29 <zeno_> ah, probably
19:46:35 <zeno_> but id rather use haskell anyhow
19:46:39 <Phyx-> you'd still get the structure
19:46:45 <Phyx-> but the code would be hard to understand
19:46:56 <m3ga> Phyx-: any language which binds to C libraries is going to be in trouble on windows
19:46:57 <Phyx-> you'd have to make a significant investment in order to read it
19:47:19 <Phyx-> m3ga: only if the binaries were compiled on msys or cygwin
19:47:55 <Phyx-> .win 6
19:47:57 <Phyx-> args
19:48:03 <Phyx-> damn . is too close to the /
19:48:04 <Axman6> Phyx-: lrn2/
19:48:24 <Phyx-> Axman6: i'm trying.... :P
19:50:04 <Axman6> Phyx-: irssi?
19:50:12 <Phyx-> Axman6: yup
19:50:15 <Phyx-> i <3 it
19:50:21 <m3ga> Phyx-: only if the library and the compiler were compiled with different compilers. The Ocaml compiler is compiled with Mingw. A C library compiled with VS makes things very difficult.
19:53:08 <Phyx-> m3ga: but the code produced by the ocaml compiler doesn't have any dependencies on mingw, aslong as ocaml supports stdcall it should be fine
19:53:26 <Axman6> Phyx-: well, lrn2ctrl-<win#> (or esc-<win#>)
19:54:58 <Phyx-> Axman6: i usually have alot fo windows open, don't feel like ctrl+N till i reach em
19:55:27 <Axman6> it spills onto q-p
19:55:43 <Phyx-> so 36 windows max
19:55:52 <Phyx-> ok, i'm usually winthin that range
19:56:05 <Phyx-> oh, q-p?
19:56:07 <Phyx-> not a-z?
19:57:27 * Phyx- always gets strange looks running irssi on windows
19:57:43 <Phyx-> been doing it since before they offered an official build
19:57:56 <Phyx-> ever since xchat started charging for their windows builds
20:00:09 <zeno_> Phyx-: even without a windows build you could ssh into a linux box and run it!
20:02:10 <Phyx-> zeno_: i generally don't own any linux boxes... except for what the university provides me
20:03:48 <zeno_> Phyx-: ah! why not?
20:03:53 <zeno_> big gamer?
20:04:27 <Axman6> my MBP is the closest to a windows box i have
20:04:31 <Phyx-> i own consoles for gaming, i Do use linux and macs, mostly to keep up and not be ignorant, i have linux installs in VMs
20:04:40 <Phyx-> but, my platform of choice is windows
20:04:41 <Axman6> and i only boot into windows about once a week, or less, to play games
20:04:44 <Phyx-> mostly because i know it well
20:04:56 <Phyx-> I actually invest alot of time, reading and learning about it
20:05:47 <Phyx-> how it works on a low level,etc. I have a ton of window internals books etc, It just works for me i suppose
20:06:02 <Axman6> you poor thing >_>
20:06:08 <Phyx-> -.-
20:06:46 <Phyx-> Axman6: now why do you say that, :P
20:07:01 <zeno_> Phyx-: does the non open source thing ever get in the way, when figuring out the internals?
20:07:08 <zeno_> or customizing
20:08:01 <Phyx-> zeno_: not at all
20:08:11 <Phyx-> since, you could actually view much of it
20:08:17 <Phyx-> using microsoft provided tools
20:08:38 <Phyx-> like windbg, livekd etc and the windows symbols
20:09:15 <fbru02_> hey guys ! the idea is not to  use too much IORef when doing Haskell right?
20:09:26 <Makoryu> fbru02_: Uh-oh
20:09:43 <randomwords> fbru02_: Sometimes it's unavoidable
20:10:14 <Phyx-> i don't think IORef in itself is that bad.. depending on how you use it
20:10:51 <fbru02_> im thinking that u should only use it when asking from input from the user or in the ST monad?
20:12:09 <Phyx-> why would you need it to ask for user input?
20:13:10 <fbru02_> you know .. maybe the normal greetings user-name test program
20:13:19 <fbru02_> something like that
20:13:41 <zeno_> Phyx-: neat, didnt know that
20:13:57 <Makoryu> fbru02_: I'd like to see how you would use IORef in such a simple program....
20:14:33 <zeno_> fbru02_: i think the idea is to not use state when possible, but im not too experienced
20:14:37 <Makoryu> fbru02_: Please paste some code on http://moonpatio.com
20:14:54 <Phyx-> fbru02_: You've come from an imperative background right? references aren't used that often in functional languages if i'm not mistaken
20:15:57 <fbru02_> Makoryu: this is not my code , but this is what i was reading when i started asking about ioref
20:16:09 <fbru02_> Phyx-: yes, as almost everyone , i started programming imperative :(
20:16:15 <Phyx-> zeno_: for the most part, what are really closed are the api calls, e.g. the system dlls it provides, however those aren't really that interesting, since their primary job is just translation into a set of instructions the kernel understand, since you can spy on the kernel, you can observ the input/output and figure out the implementation in the dll, most of the time
20:16:25 <fbru02_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3350#a3350
20:16:55 <pikhq> fbru02_: For the most part, IORef usage is considered a sign that you need to do it more functionally. :P
20:17:07 <pikhq> Or at least use the State monad...
20:17:16 <Makoryu> fbru02_: HAHAHAHAHAHAHAHA
20:17:35 <Makoryu> fbru02_: Sorry. That's my program :p
20:17:38 <pikhq> Oh, HQ9+. :)
20:17:40 <Makoryu> That's why I laughed >_>
20:17:46 <fbru02_> Makoryu: nice ! i forgot it was yours !
20:17:51 <Phyx-> Makoryu: LOL
20:18:13 <pikhq> For the heck of it, I shall past mine.
20:18:34 <Makoryu> fbru02_: HQ9+ specifies that the "+" instruction "increments the current register," but does not mention what "the current register" is actually for.
20:19:08 <pikhq> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3351#a3351
20:19:15 <Makoryu> Note that that IORef is never used elsewhere in the code
20:19:17 <pikhq> Erm. Paste, not past.
20:19:44 <zeno_> fbru02_: http://99-bottles-of-beer.net/language-haskell-1613.html
20:20:09 <fbru02_> zeno_:  says no permission to access the site
20:20:56 <zeno_> fbru02_: were you translating from another language?
20:21:02 <pikhq> Makoryu: BTW, flip mapM_ is forM_.
20:21:22 <Makoryu> pikhq: I didn't feel like adding another import line :p
20:21:24 <fbru02_> zeno_:  nop
20:21:41 <pikhq> I used one in mine.
20:22:03 <Makoryu> I said *another* import line. I already have a few
20:22:13 <Makoryu> (Probably more than I need...)
20:22:16 <pikhq> You used far too many.
20:22:34 <pikhq> I only need System.Environment because I parse the arguments instead of just reading stdio.
20:22:39 <pikhq> ;)
20:22:44 <Makoryu> Yeah, I overengineered mine in the hopes that anyone looking at it would get a chuckle or two
20:22:59 <pikhq> Incidentally, needs less do notation.
20:23:04 <Makoryu> Little did I know that would be me in a few more days...
20:23:17 <fbru02_> http://paste.lisp.org/display/33254
20:23:46 <fbru02_> the guy who wrote overdid ioref also i guess
20:25:15 <pikhq> Yeah, that could be done with sticking the result of getLine in the argument to mainLoop.
20:26:03 <Makoryu> (I still don't recall why the hell I imported Data.Char...)
20:28:05 <fbru02_> thanks guys see you tommorrow , time to sleep !
20:28:12 <Makoryu> Peace
20:29:29 <Phyx-> hmm
20:29:34 <Phyx-> why am i up.. at 5.29am
20:29:56 <randomwords> Phyx-: Early rise or late to bed?
20:31:08 <Phyx-> randomwords: i'm free tomorow, summer vacation is still on
20:31:10 <Makoryu> Some freshman Java programmer on reddit asked for a "quick runthrough" of what Haskell is all about
20:31:12 <Phyx-> i just.. can't sleep
20:31:20 <Makoryu> I'm tempted to give it a shot....
20:32:32 <pikhq> Makoryu: Link?
20:33:08 <monochrom> RWH has a section "why functional programming, why haskell" and I think it's suitable.
20:33:59 <Makoryu> monochrom: He wasn't asking "why"... He was asking "how"
20:34:23 <monochrom> But the section is all about what haskell is all about.
20:34:50 <monochrom> Titles mean nothing. Don't take "why" seriously.
20:34:55 <Makoryu> Ah... I skipped that section, so....
20:35:03 * Makoryu digs out his copy of RWH
20:35:15 <medfly> hehe, it'd be funny if you wrote the shortest possible description of it.
20:35:21 <monochrom> Hell, his exact wording means nothing too.
20:35:21 <medfly> "A programming language".
20:35:38 <monochrom> hahaha
20:35:52 * Phyx- thinks yahoo answers is quite depressing
20:35:56 <Makoryu> http://www.reddit.com/r/programming/comments/9b81o/ask_proggit_what_should_my_next_language_be/ <- This guy. Looks like he's getting downvoted into oblivion
20:36:11 <Makoryu> (The actual comment is... in the comments)
20:36:12 <monochrom> Poor guy.
20:36:19 <medfly> I use google to find answers to things, and sometimes I see decent responses on yahoo answers.
20:37:45 <Phyx-> medfly: i reply with decent responses on yahoo answers
20:38:05 <Phyx-> only so that someone else posts a fluff bs, and get the "best answer" vote
20:38:07 <Phyx-> *sigh*
20:38:18 <monochrom> If I answer in yahoo I give decent answers.
20:38:25 <monochrom> I don't answer in yahoo.
20:38:32 <monochrom> Therefore I haven't lied. :)
20:38:33 * medfly pats Phyx- on the head
20:38:40 <medfly> it's okay.
20:38:58 <Phyx-> i remember one time
20:39:03 <medfly> monochrom, your answers on yahoo answers are always horrible!
20:39:04 <Phyx-> on a C# forum
20:39:08 <Phyx-> some guy was asking something
20:39:15 <Phyx-> and i was feeling particulairly generous
20:39:20 <Phyx-> so i wrote the whole class he asked for
20:39:27 <Phyx-> didn't get so much as a thank you :(
20:40:10 <medfly> well, I can point out people occasionally google things and end up finding yahoo answers messages with decent answers and they appreciate it.
20:40:35 <monochrom> I have been in efnet #math and freenode #math. I observed this phenomenon: people are great at recognizing good answers as "bad" and bad answers as "good".
20:40:46 <Phyx-> i also make it a point to always post my sources in yahoo answer
20:40:50 <monochrom> They really do so reliably!
20:40:57 <Phyx-> so my answers can be fact checked
20:41:11 <Phyx-> monochrom: i have been on #math in efnet
20:41:15 <Phyx-> and was instantly banned
20:41:17 <Phyx-> :|
20:41:23 <wgsilkie> Phyx-: What happened?
20:41:24 <Phyx-> they set abnormally wide ban masks
20:41:34 <Phyx-> like 19?.*
20:41:43 <Phyx-> etc
20:41:58 <Phyx-> i've seen them block whole countries
20:41:58 <medfly> that's pretty wide.
20:41:59 <Phyx-> *.pl
20:42:00 <Phyx-> etc
20:42:04 <purplepenguins> efnet is awful
20:42:09 <medfly> I only hung out at #math here.
20:42:11 <purplepenguins> in my recollection
20:42:25 <monochrom> I have a part in it. We have to fight very diligent trolls.
20:42:39 <monochrom> But not like 19?.* or *.pl.
20:42:47 <wgsilkie> freenode seems to be on of the few nice networks.
20:42:52 <Phyx-> purplepenguins: imho, it is
20:42:59 <medfly> freenode is awesome. I love you guys.
20:43:01 * medfly hugs
20:43:04 <Phyx-> efnet seems to be filled with jerks
20:43:14 <Phyx-> generally i find freenode people to much more helpfull
20:43:24 <Phyx-> and nicer...
20:43:29 <wgsilkie> I tried efnet and whatever the other huge one is, and I didn't know what to do.
20:43:37 <medfly> dalnet?
20:43:41 <purplepenguins> freenode is generally nicer
20:43:42 <wgsilkie> oftc was the other one
20:43:48 <purplepenguins> thugh not always
20:43:54 <wgsilkie> They seemed a bit pointless.
20:43:58 <purplepenguins> #haskell is great
20:44:05 <wgsilkie> freenode has some stated purpose.
20:44:16 <medfly> guys, will it be cool to ask a highly irrelevant question... ?
20:44:21 <monochrom> Yes!
20:44:22 <dilinger> wgsilkie: oftc was started due to freenode issues..
20:44:34 <purplepenguins> the one thing about freenode is that sometimes people are all "freenode is SRS BSNS"
20:44:35 <Phyx-> monochrom: i've encountered numerous channels on efnet with such wide bans, and when asked, i usually get the same rational. "we got spammed from some of those ips, so we blocked them all"
20:45:01 <purplepenguins> how is oftc anyway
20:45:01 <wgsilkie> dilinger: Did I read the right way round?!  *freenode* issues?!
20:45:09 <Phyx-> imho, i think if you have a big channel, with a general name like #math, that you're obligated to find less destructive measures to stop spam
20:45:18 <wgsilkie> purplepenguins: What's "SRS BSNS"?
20:45:19 <dilinger> wgsilkie: in general, a lot of people prefer oftc due to things like freenode's channel limit, and the you-must-be-registered-in-order-to-privmsg-people rule
20:45:29 <purplepenguins> serious business
20:45:35 <wgsilkie> Ah.
20:45:42 <Phyx-> like, modderating the channel, and voicing only after 5secs of waiting, then you could just revoke voice on spamming ips instead of banning
20:45:43 <medfly> see, I've been wanting to study in university, and I will do that, and I've had this perception that engineering is a lot like programming. can the skills be moved around, or am I wrong here?
20:45:45 <monochrom> There is no less destructive measure.
20:45:54 <dilinger> wgsilkie: freenode was started by a sociopath (lilo)
20:46:06 <medfly> sociopath? he seemed rather cute on the global messages
20:46:48 <Phyx-> monochrom: i dissagree, banning seems like a past time on efnet instead of a last resort
20:46:56 <wgsilkie> dilinger: Lilo?
20:47:10 <medfly> hmm.
20:47:12 <Phyx-> monochrom: i've been killed and klined for having arguments with opers there
20:47:19 <medfly> looks like my question is too irrelevant :)
20:47:20 <Phyx-> you prove them wrong. *wack*
20:47:43 <monochrom> We already do moderating and devoicing. This works to a great extent, but there is a troll who goes beyond that by simply doing a larger scale.
20:47:45 <Phyx-> medfly: i'm a SE student, don't know about other engineering majors
20:47:46 <dilinger> wgsilkie: ie, Rob Levin
20:47:53 <medfly> what is SE?
20:48:01 <Phyx-> medfly: software engineering
20:48:01 <glguy> software engineering?
20:48:04 <medfly> oh, okay.
20:48:35 <medfly> well, I in particular hope to study mechanical engineering.
20:48:52 <dilinger> you could google for things like "freenode lilo fraud", for example
20:48:56 <medfly> I guess software engineering is pretty darn useful for programming... hehe
20:49:05 <Phyx-> monochrom: i can understand that, but there *has* to be a way around that. You could atleast except people who are banned by such wide ranges if they ask nicely, like i always do
20:49:25 <medfly> it looks like some people don't like him.
20:49:25 <monochrom> We do excepts/exempts too.
20:49:29 <medfly> isn't the guy dead anyway?
20:49:35 <dilinger> and there were plenty of instances of lilo kicking people and entire channels off the network for inexplicable reasons (some were personal issues, others.. i don't really know)
20:49:43 <Phyx-> medfly: some places do give SE/ME double majors
20:49:55 <Phyx-> i was doing a Math/CS major in my bachelor, dropped math, found it too boring
20:50:11 <dilinger> but those are harder to find since lilo's death, since google seems to return results related to his death first
20:50:26 <Phyx-> monochrom: i was basically just laughed at when i asked in #math, or rather, by pming the person who set the ban
20:50:30 <medfly> ...
20:50:30 <monochrom> Programming limitations of efnet (such as banlist size) also limit our options.
20:50:48 <medfly> dilinger, I thought you were going to say, "they're harder to find because THEY DON'T HAPPEN ANY MORE... HE DIED..."
20:51:11 <Phyx-> who's lilo?
20:51:26 <Phyx-> for a second there, i thought lindsay lohan :|
20:51:39 <dilinger> medfly: he used to spend lots of time begging people/companies for money, threatening them, and so on.  it's not really relevant, since he's no longer around.  however, there are still people that harbor resentment against freenode because of that
20:51:43 <purplepenguins> lilo is a bootloader
20:51:50 <pikhq> Phyx-: Lilo, founder of Freenode.
20:52:25 <medfly> I did find it kind of dubious that he's raising money so he can live off of it, though.
20:53:00 <Phyx-> :|
20:53:22 <dilinger> medfly: these days, the more annoying aspects of freenode are what i already described.  lilo was actively attempting to turn freenode into something that wasn't irc (one example included dropping irc.freenode.net dns records, and instead requiring people to use chat.freenode.net)
20:53:49 <dilinger> but those who have replaced him seem to have put irc.freenode.net back, and aren't attempting to change things around so much
20:53:50 <Phyx-> @pl zip i (map (fromBase b) i)
20:53:51 <lambdabot> zip i (map (fromBase b) i)
20:53:55 <Phyx-> heh
20:54:00 <veinor> what's @pl?
20:54:05 <Phyx-> pointless
20:54:11 <veinor> which does
20:54:11 <Phyx-> @pl \x->x
20:54:12 <veinor> oh
20:54:12 <lambdabot> id
20:54:17 <medfly> well, in any case, the guy isn't around any more.
20:54:28 <Phyx-> converts an expression to a pointfree version veinor
20:54:29 <dilinger> so that's why oftc exists :)
20:54:59 <Phyx-> @pl \i b->zip i (map (fromBase b) i)
20:55:00 <lambdabot> liftM2 (.) zip (flip (map . fromBase))
20:55:13 <Phyx-> hrm, not exactly more readable
20:55:20 <veinor> did it just use . as a prefix
20:55:25 <veinor> because that's pretty funny
20:55:42 <Phyx-> it used it as a function argument
20:55:49 <Phyx-> @type liftM2 (.)
20:55:51 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
20:56:02 <veinor> ah
20:56:11 <veinor> oh, missed liftM2. derp.
20:56:17 <Phyx-> i commonly use it as
20:56:21 <Phyx-> foldl (.) id
20:56:22 <Phyx-> though
20:56:22 <Phyx-> lol
20:57:00 <copumpkin> liftA2 is cuter
20:57:20 <Phyx-> does the same?
20:57:27 <Phyx-> :t liftA2
20:57:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:57:32 <glguy> I'd be nice to have a base package replacement that had some of the less invasive fixes
20:57:46 <glguy> like Functor => Applicative => Monad superclass fixes
20:57:59 <glguy> no more liftM2 or replicateM (moving things that only need applicative)
20:58:12 <Phyx-> copumpkin: heh, cuter, but not needed, i could also sue fmap in this case then
20:58:13 <copumpkin> no more liftM or liftA even?
20:58:16 <glguy> in the way that haskell98 can be used in place of base
20:58:22 <copumpkin> Phyx-: not for two arguments
20:58:37 <veinor> @unpl liftM2 (.) zip (flip (map . fromBase))
20:58:37 <lambdabot> (zip >>= \ b -> (\ j k -> map (fromBase k) j) >>= \ a -> return (\ h -> b (a h)))
20:58:42 <veinor> well that's readable!
20:58:43 <copumpkin> unless you had ap too
21:00:31 <Phyx-> copumpkin: right, sorry bout that, at 6am, my brain is throwing undefines, i had an example using a foldl above but just now when i said that, i had map in my head
21:00:59 <Phyx-> copumpkin: just out of curiosity, how would you get fmap and ap to give that type?
21:01:19 <copumpkin> @type \f a b -> f `fmap` a `ap` b
21:01:21 <lambdabot> forall a a1 b (m :: * -> *). (Functor m, Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
21:01:30 <Phyx-> ah
21:01:32 <Phyx-> like that
21:01:48 <Phyx-> @pl  \f a b -> f `fmap` a `ap` b
21:01:49 <lambdabot> liftM2
21:01:51 <copumpkin> <$> = fmap and <*> = ap
21:01:55 <Phyx-> LOL
21:02:18 <pikhq> And ap = S -- YAY
21:02:29 <Phyx-> eh?
21:02:39 <pikhq> It's the S combinator.
21:02:39 <Phyx-> @type S
21:02:40 <lambdabot> Not in scope: data constructor `S'
21:02:44 <Phyx-> oh, like that
21:02:50 <pikhq> Well, it is on the functions.
21:03:02 <Phyx-> i was reading up on that the other day
21:03:06 <pikhq> @pl \x y z->x z (y z) -- See?
21:03:07 <lambdabot> ap
21:03:29 <Phyx-> aha
21:03:33 <Phyx-> @src ap
21:03:34 <lambdabot> ap = liftM2 id
21:03:44 <Phyx-> @src liftM2
21:03:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:05:22 <glguy> callCC . (>>=) -- is a fun little function. I'm using it to run the effects below my ContT but roll back the ones stacked on top of the ContT (all the top can do is decide to be mzero)
21:06:17 <Phyx-> @elemIndex
21:06:17 <lambdabot> Unknown command, try @list
21:06:21 <Phyx-> @t elemIndex
21:06:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:06:27 <Phyx-> @ty elemIndex
21:06:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
21:06:39 <Saizan> ?type  callCC . (>>=)
21:06:41 <lambdabot> forall a (m :: * -> *). (MonadCont m) => m a -> m a
21:07:04 <Phyx-> what's the difference between the ? and @ commands?
21:07:13 <Saizan> nothing
21:07:22 <Phyx-> lol, ok
21:08:22 <glguy> Prelude MonadLib> let fun = callCC . (>>=) in runContT return $ runStateT 0 $ fun (inBase (print 1) >> sets_ (+2) >> return 3)
21:08:24 <glguy> 1
21:08:26 <glguy> (3,0)
21:09:01 <hackagebot> accelerate 0.4.0 - An embedded language for accelerated array processing (ManuelChakravarty)
21:09:33 <veinor> hmm, okay; so a ID3 title frame is the string TIT2, followed by the four bytes that determine the length of the title, two flag bytes, and then the title
21:09:46 <veinor> given a String containing the file contents, how do I extract the title?
21:10:14 <veinor> example: TIT2\00\00\00\04\00\00Test
21:11:32 <Saizan> glguy: monadLib, right?
21:11:36 <c_wraith> is  that framing seriously it?  Couldn't the byte sequence TIT2 appear in the compressed mpeg data?
21:11:40 <glguy> Saizan: is there any other? ;)
21:12:29 <veinor> c_wraith: yes, and the ID3 tag does specify the length of the ID3 section
21:12:31 <Saizan> veinor: i'd use Data.Binary.Get
21:13:34 <tingi> Can anyone help me with finding maximal even palindromes (consecutive) substring in a long string (5*10^4). I'm not looking for suffix trees
21:13:41 <artagnon> This is odd. My program can be interpreted, but cannot be compiled: ld error. It's too slow when interpreted. What could be the issue? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8253#a8253
21:13:59 <veinor> hm
21:15:03 <mauke> altmattr: ghc --make euler47.hs
21:15:13 <hackagebot> compose-trans 0.0 - Composable monad transformers (MiguelMitrofanov)
21:15:35 <Saizan> ?hackage compose-trans
21:15:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/compose-trans
21:15:54 <veinor> c_wraith: I'm counting on TIT2 not appearing in mpeg data; I still have yet to figure out what's up with the ID3 header's size bytes
21:16:18 <BMeph> artagnon: I think mauke meant that for you... ;
21:16:24 <BMeph> )
21:16:32 <mauke> argh
21:16:36 <mauke> sorry
21:16:37 <altmattr> mauke: ??
21:16:51 <mauke> altmattr: I mistabbed
21:17:02 <altmattr> mauke: sounds like fun anyway - perhaps I will give it a go :)
21:17:13 <artagnon> ghc: One sec
21:17:18 <copumpkin> tingi: it's a string of digits?
21:17:22 <Phyx-> @pl (\a b-> a >>= (\i -> fmap (+i) b))
21:17:23 <lambdabot> liftM2 (+)
21:17:28 <Phyx-> ah
21:17:33 * copumpkin hugs @pl
21:17:36 <altmattr> mauke: better than being the target of a mis-stabbing
21:17:41 <tingi> copumpkin, nope ascii chars
21:17:41 * Phyx- hugs it aswell
21:17:55 <artagnon> mauke: Ah! Thanks! :)
21:17:58 <copumpkin> tingi: oh, even palindromes = palindromes of even length?
21:18:06 <tingi> copumpkin, yes
21:18:31 <tingi> copumpkin, i know a O(n^2) algo but it is too slow
21:19:38 <veinor> is there a way to get elements between certain indices in a list, like python's foo[2:6]?
21:19:48 <copumpkin> veinor: drop . take :P
21:19:50 <copumpkin> or rather
21:19:59 <copumpkin> take n . drop m
21:20:40 <Axman6> > let section (a,b) = take (b-a) . drop a in section (2,6) "hello world"
21:20:42 <lambdabot>   "llo "
21:20:48 <veinor> thanks :D
21:21:00 <Axman6> not sure if that's quite right
21:21:19 <veinor> close enough that I can figure out what is right
21:22:21 <Phyx-> ok, is there some magic functions that takes a [(String,Maybe Int)] -> [(String,Int)] (I can dream can't I?)
21:22:46 <Heffalump> Phyx-: what would it do? I'm sure there are several such functions.
21:23:00 <glguy> :t mapMaybe
21:23:02 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
21:23:08 <Heffalump> @type map (id *** fromJust)
21:23:09 <lambdabot> forall b a. [(b, Maybe a)] -> [(b, a)]
21:23:17 <BMeph> I prefer drop m . take n; it "takes" more than needed, but you don't have that "extra" subtraction in it. :)
21:23:22 <copumpkin> not sure you want fromJust :P
21:23:22 <Phyx-> Heffalump: i want to from the first list, only keep the elements that are a Just and remove the just from the kept elements and return them
21:23:32 <Phyx-> Heffalump: ah, perfect
21:23:39 <Heffalump> no it's not, it errors on Nothing
21:23:45 <glguy> :t mapMaybe (\(a,b) -> fmap ( (,) a ) b )
21:23:45 <Phyx-> oh
21:23:45 <Heffalump> I was just pointing out a simple example
21:23:46 <lambdabot> forall t a. [(t, Maybe a)] -> [(t, a)]
21:23:54 <Heffalump> @type map (id *** fromJust) . filter (isJust . snd)
21:23:56 <lambdabot> forall b a. [(b, Maybe a)] -> [(b, a)]
21:23:58 <Heffalump> try that
21:24:06 <Heffalump> or use a list comprehension:
21:24:16 <aavogt> @pl \a b -> fmap ((,) a) b
21:24:16 <lambdabot> fmap . (,)
21:24:18 <copumpkin> @pl mapMaybe (\(a,b) -> fmap ( (,) a ) b )
21:24:19 <lambdabot> mapMaybe (uncurry (fmap . (,)))
21:24:20 <Heffalump> @type \xs -> [(a, b) | (a, Just b) <- xs]
21:24:22 <lambdabot> forall t t1. [(t, Maybe t1)] -> [(t, t1)]
21:24:26 <Phyx-> actually, glguy's worked
21:24:27 <copumpkin> fmap . (,) is just strength
21:24:27 <Phyx-> :)
21:24:33 <glguy> Phyx-: surprise?
21:24:39 <copumpkin> mapMaybe (uncurry strength) ?
21:24:45 <Phyx-> glguy: nah, just never seen mapMaybe before
21:25:11 <aavogt> :t catMaybes
21:25:12 <lambdabot> forall a. [Maybe a] -> [a]
21:25:25 <Phyx-> yeah, i just recently discovered that one too
21:25:42 <Phyx-> @type mapMaybe (uncurry strength)
21:25:43 <lambdabot> forall a a1. [(a, Maybe a1)] -> [(a, a1)]
21:25:47 <BMeph> :t (catMaybes.)
21:25:48 <Phyx-> :O
21:25:48 <lambdabot> forall a a1. (a1 -> [Maybe a]) -> a1 -> [a]
21:26:00 <Phyx-> @type strength
21:26:01 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
21:26:03 <Axman6> MIT moved to using python right? (for their comp courses)
21:26:13 <glguy> ?index strength
21:26:14 <lambdabot> bzzt
21:26:24 <glguy> is that a ?let defined function?
21:26:27 <Phyx-> @src strength
21:26:28 <lambdabot> Source not found. My pet ferret can type better than you!
21:26:36 <copumpkin> it's in category-extras
21:26:39 <copumpkin> not sure if someone @let it
21:26:42 <Phyx-> @hoogle strength --info
21:26:43 <lambdabot> No results found
21:26:46 <kulakowski> Axman6: for their intro class yes
21:26:47 <Phyx-> hrm
21:27:06 <aavogt> copumpkin: seriously? Have you any idea why it is named that?
21:27:21 <Phyx-> hm
21:27:38 <BMeph> :t filter (isJust . snd)
21:27:40 <lambdabot> forall a a1. [(a1, Maybe a)] -> [(a1, Maybe a)]
21:27:46 <glguy> copumpkin: Do you know what module it is in?
21:27:49 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Strong.html
21:28:08 <Phyx-> oh, an external package?
21:28:38 <glguy> preflex: seen edwardk
21:28:38 <preflex>  edwardk was last seen on #haskell 5 hours, 58 minutes and 57 seconds ago, saying: upon reflection, once i reify the curry i ate earlier, i doubt i'd want to eat it
21:29:03 <Phyx->  i suppose i'll use the more verbose one
21:29:18 <Phyx-> don't want to tack on an extra library just for a one time thing
21:29:19 <Phyx-> lol
21:30:56 <copumpkin> Phyx-: it's a very handy function for some reason
21:31:05 <copumpkin> I end up using it in a bunch of unrelated things
21:31:11 <veinor> @pl \m n x -> drop m (take (n+1) x)
21:31:11 <lambdabot> (. (take . (1 +))) . (.) . drop
21:31:12 <Phyx-> copumpkin: what else is a common use for it?
21:31:19 <veinor> well that sure is readable
21:31:23 <BMeph> copumpkin: How about Monoidal? :)
21:31:29 <copumpkin> BMeph: ?
21:31:38 <Phyx-> @pl \c i->mapMaybe (\(a,b) -> fmap ( (,) a ) b ) $ zip i (fmap (fromBase c) i)
21:31:39 <lambdabot> (mapMaybe (uncurry (fmap . (,))) .) . ap zip . fmap . fromBase
21:31:48 <copumpkin> Phyx-: any time you have a key-value pair and want to "flatten it out"
21:31:59 <veinor> damned if it doesn't work though
21:32:02 * Phyx- is wondering which one is better, both seem pretty unreadable
21:32:13 <copumpkin> > uncurry strength (5, [1,2,3])
21:32:15 <lambdabot>   [(5,1),(5,2),(5,3)]
21:32:17 <Phyx-> @type (. (take . (1 +))) . (.) . drop
21:32:18 <lambdabot> forall a. Int -> Int -> [a] -> [a]
21:32:22 <copumpkin> > uncurry strength (5, Maybe 7)
21:32:24 <lambdabot>   Not in scope: data constructor `Maybe'
21:32:27 <Phyx-> veinor: it should
21:32:28 <copumpkin> > uncurry strength (5, Just 7)
21:32:29 <copumpkin> meh
21:32:30 <lambdabot>   Just (5,7)
21:33:02 <aavogt> @type (.) . (,)
21:33:03 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> (a1, b)
21:33:32 <Axman6> :t strength
21:33:34 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
21:33:58 <Axman6> > strength 1 "hello"
21:34:00 <lambdabot>   [(1,'h'),(1,'e'),(1,'l'),(1,'l'),(1,'o')]
21:34:09 <Phyx-> @pl mapMaybe (\(a,b) -> fmap ( (,) a ) b )
21:34:09 <lambdabot> mapMaybe (uncurry (fmap . (,)))
21:34:19 <BMeph> > (fmap . fmap) fromJust . filter (isJust . snd) [(11,Just 'a'),(7,Just 'b'),(5,Nothing),(3,Just 'd')]
21:34:21 <lambdabot>   Couldn't match expected type `a -> f (f1 (Data.Maybe.Maybe a1))'
21:34:38 <BMeph> > (fmap . fmap) fromJust . filter (isJust . snd) $ [(11,Just 'a'),(7,Just 'b'),(5,Nothing),(3,Just 'd')]
21:34:40 <lambdabot>   [(11,'a'),(7,'b'),(3,'d')]
21:34:46 <BMeph> @bo
21:34:47 <lambdabot> :)
21:34:58 <Phyx-> rather inefficient
21:35:00 <Phyx-> but it works
21:35:17 <glguy> > strength 1 (+2) 3
21:35:19 <lambdabot>   (1,5)
21:36:01 <copumpkin> I don't know what a strong functor is in CT thoug
21:36:02 <copumpkin> h
21:36:06 <Phyx-> copumpkin: http://phyx.pastebin.com/d46eab59 how i used it
21:36:07 <Phyx-> lol
21:36:09 <copumpkin> it just happens to be a handy function for me :)
21:36:22 <copumpkin> I'm sure it's very profound and I look forward to learning about it ;)
21:36:27 <Saizan>  ?type strength
21:36:29 <Saizan> ?type strength
21:36:31 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
21:36:44 <BMeph> copumpkin: Monoidal is mentioned in one of the Applicative papers, it just has f () and f a -> f b -> f (a, b) definitions.
21:36:58 <copumpkin> I tend to use uncurry strength more than strength
21:37:04 <copumpkin> hmm
21:37:20 <copumpkin> the latter just looks like liftA2 (,)
21:37:27 <Saizan> uncurry strength is how it appears in CT i bet
21:37:38 <Saizan> copumpkin: it is
21:37:41 <BMeph> copumpkin: It's Iso to Applicative, but it only needs tensorial cat, not the full-blown CCC. Or something like that; I'm still really shaky on CT ground. :)
21:38:04 * copumpkin is still a CT noob :) I know a lot of the definitions but that's about it :P
21:38:40 <veinor> hm, how do I find the index of a certain sublist within a list
21:38:59 <veinor> eg myFunc "abcdefg" "cd" = 2
21:39:03 <aavogt> @type tails
21:39:04 <lambdabot> forall a. [a] -> [[a]]
21:40:04 <copumpkin> @type indexOf
21:40:06 <lambdabot> Not in scope: `indexOf'
21:40:38 <aavogt> :t \x -> elemIndex x . map (take (length x)) . tails
21:40:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
21:40:48 <Saizan> > fmap fst . find (isPrefixOf "cd" . snd) . zip [0..] . tails $ "abcdefg"
21:40:49 <glguy> :t findIndex
21:40:50 <lambdabot>   Just 2
21:40:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
21:40:57 <copumpkin> > findIndex (isPrefixOf "cd") . tails $ "avcdefgh"
21:40:59 <lambdabot>   Just 2
21:41:01 <glguy> findIndex . isPrefixOf
21:41:12 <glguy> ah, right, still needed tails
21:41:35 <veinor> aavogt: that works, thanks
21:41:45 <aavogt> ah, I didn't know findIndex
21:41:59 <glguy> there are more efficient algorithms for this search if you need it for something non-trivial
21:42:04 <copumpkin> @pl \needle haystack -> findIndex (isPrefixOf needle) . tails $ haystack
21:42:05 <lambdabot> (. tails) . findIndex . isPrefixOf
21:42:13 <copumpkin> aw that's cute
21:42:33 <veinor> i'm searching for stuff within MP3 files, so it'll probably be within 4MB or so
21:42:43 <copumpkin> you don't want to be using strings then
21:42:51 <copumpkin> and my mp3 files are big
21:42:56 <veinor> true
21:43:00 <ray> aww, so cute
21:43:03 <copumpkin> ByteStrings
21:43:22 <aavogt> isn't there some specification that requires tags to be at the begining of mp3 files?
21:43:32 <veinor> aavogt: nope
21:43:38 <veinor> they can come at the end of them
21:43:42 <ray> aavogt: try concatenating two mp3s and see if it works
21:43:52 <ray> two mp3s with tags even
21:43:57 <veinor> not sure why you'd put ID3 tags at the end, but you can do so
21:44:44 <glguy> you put them at the end so you can add them to an existing file
21:44:52 <glguy> without having to insert a bunch of data to the beginning
21:44:58 <veinor> eh, I guess
21:44:59 <glguy> and rewrite the file
21:45:13 <veinor> also does make it easier to parse for them; you can drop everything that comes before the ID3 header :D
21:45:36 <ray> id3v2 appears at the beginning and id3v1 appears at the end
21:45:41 <ray> those are not rules, just observations
21:46:06 <veinor> the v2 specs say that appearing at the beginning is a preference but not necessary
21:46:13 <veinor> haven't read v1
21:46:36 <ray> <ray> those are not rules, just observations
21:46:41 <veinor> right
21:46:41 <ray> so don't go dragging specs into this :)
21:47:04 <ray> interrupting their teatime
21:47:33 <veinor> haha
21:47:57 <copumpkin> is there some profound relationship between liftA2 (,) and zip ?
21:48:03 <copumpkin> categorically or something
21:48:09 <ray> in practice you can stick them anywhere
21:48:15 <aavogt> copumpkin: ZipListS?
21:48:16 <ray> players will cope
21:48:43 <ray> copumpkin: yes, they are the same thing
21:48:53 <ray> i think we call that a somethingmorphism
21:48:57 <copumpkin> only with ZipList
21:49:17 <aavogt> > liftA2 (,) "hello" "zxc"
21:49:18 <lambdabot>   [('h','z'),('h','x'),('h','c'),('e','z'),('e','x'),('e','c'),('l','z'),('l'...
21:49:20 <ray> one just has a more general type, that's all
21:49:31 <ray> ziplist is just a wrapper
21:49:35 <copumpkin> yeah
21:49:36 <aavogt> > zip "hello" "zxc"
21:49:37 <lambdabot>   [('h','z'),('e','x'),('l','c')]
21:49:39 <ray> because we prefer the monad version
21:49:44 <veinor> homomorphism? isomorphism? I'm just guessing based off of my math knowledge :v
21:49:47 <BMeph> But it's a Harc-Core wrapper! ;p
21:49:54 <copumpkin> heteromorphism
21:50:04 <veinor> heteronormative
21:50:05 <ray> > liftA2 (,) (ZipList "hello") (ZipList "there")
21:50:07 <lambdabot>   No instance for (GHC.Show.Show
21:50:07 <lambdabot>                     (Control.Applicative.Zip...
21:50:12 <ray> gsdaklghasdkljg
21:50:12 <BMeph> ...dumb lack-of-typing-skills. Meh.
21:50:17 <mgsloan> metromorphism
21:50:20 <copumpkin> @src ZipList
21:50:21 <lambdabot> Source not found. :(
21:50:32 <copumpkin> @hoogle ZipList a -> [a]
21:50:33 <ray> > getZipList $ liftA2 (,) (ZipList "hello") (ZipList "there")
21:50:33 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
21:50:33 <lambdabot> Prelude repeat :: a -> [a]
21:50:33 <lambdabot> Data.List repeat :: a -> [a]
21:50:35 <lambdabot>   [('h','t'),('e','h'),('l','e'),('l','r'),('o','e')]
21:51:19 <copumpkin> > transpose ["hello", "there"]
21:51:21 <lambdabot>   ["ht","eh","le","lr","oe"]
21:51:23 <Saizan> copumpkin: if zip is supposed to have and unzip-like inverse then i don't think so
21:51:39 <ray> so anyway, that's just a diversion
21:51:49 <ray> i say they're identical
21:51:57 <ray> (in that one case)
21:52:08 <ray> obviously one is more general
21:52:43 <Saizan> in that one case they are, that doesn't mean generalizing zip to other structures should go in the direction of liftA2
21:53:19 <ray> all i need is a travelling category theorist to tell me the correct name
21:53:53 <ray> i see zipping as binary lifting
21:54:22 * copumpkin east some truffle cream corn
21:54:37 <ray> i can't afford food :(
21:54:45 <ray> it's like a fading memory
21:55:26 <copumpkin> you should eat drong
21:55:32 <copumpkin> if he's not a cat, there should be a fair amount of meat on him
22:02:52 <BMeph> UR OIN IT DRONG! ;p
22:18:26 <inforichland> anybody know how I can fix this?
22:18:27 <inforichland> Loading package llvm-0.6.7.0 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
22:18:36 <inforichland> ghc 6.10.3
22:18:39 <inforichland> x86 linux
22:19:29 <blackh2> Try installing a package called libstdc++6 (if it's Debian or Ubuntu)
22:20:11 <Saizan> if you already have it make sure it's not a linker script
22:22:01 <copumpkin> ooh, easy composable monad transformers
22:22:32 <edwardk> glguy: whats up?
22:23:12 * BMeph wants a monad inverter, so his AC monads can use a DC supply!
22:25:12 <glguy> edwardk: What's the categorical meaning behind "strengthen"
22:25:26 <glguy> err
22:25:28 <glguy> strength
22:26:12 <edwardk> glguy: i wrote a blog post on it at one point
22:26:32 <edwardk> http://comonad.com/reader/2008/deriving-strength-from-laziness/
22:26:54 <copumpkin> ooh
22:28:13 <copumpkin> edwardk: wouldn't that suggest strength = uncurry (fmap . (,)) instead of just fmap . (,) ?
22:29:17 <edwardk> glguy: its just the existence of a family of morphisms, forall a b. (f a, b) -> f (a, b)
22:29:35 <edwardk> though, in haskell, as i recall it works a little better if you flip the product around
22:29:51 <edwardk> (a, f b) -> f (a, b)
22:29:54 <edwardk> and curry
22:30:11 <edwardk> a -> f b -> f (a, b) -- because then fmap . (,) -- is a valid definition for strength
22:30:17 <edwardk> showing that all functors over Hask are strong
22:30:20 <glguy> edwardk: Is there significance to your double \\ lambdas?
22:30:40 <edwardk> glguy: no, just that i changed syntax highlighters at some point and the previous one required it ;)
22:32:22 <edwardk> anyways strength is one of those areas where the value oriented nature of Haskell introduces an asymmetry between the power of monads and comonads. we get strength for free, but can only have costrength for traversables
22:35:25 <edwardk> one consequence of this is that when conor talks about applicatives as a strong lax monoidal functor, the 'strong' there is redundant, every functor in Hask is strong. ;) and he is already making assumptions about the existence of exponentials in the category anyways, so its kind of pointless to qualify that but not the latter.
22:37:08 <Saizan> the string lax monoidal functor definition uses exponentials too?
22:37:21 <Saizan> *strong
22:38:23 <edwardk> no. the strong lax definition is fine as given, but the fact that the definition for applicative and the lax monoidal functor he specifies are only equivalent if you have arbitrary exponentials =)
22:38:45 <edwardk> er s/the fact that/
22:39:28 <edwardk> that and applicative (as specified) is only a superclass of monad for a category with exponentials, though you could have a lax monoidal functor superclass for monad
22:43:28 <veinor> @pl \x y -> x * 256 + fromEnum y
22:43:29 <lambdabot> (. fromEnum) . (+) . (256 *)
22:47:22 <copumpkin> @pl \y x -> x * 256 + fromEnum y
22:47:23 <lambdabot> (. (256 *)) . (+) . fromEnum
22:47:41 <copumpkin> @pl \y x -> 256 * x + fromEnum y
22:47:42 <lambdabot> (. (256 *)) . (+) . fromEnum
22:49:09 <veinor> I still think the lambda is more readable
22:49:35 <copumpkin> probably :)
22:49:55 <aavogt> @type \x -> ((x*256)+) . fromEnum
22:49:56 <lambdabot> forall a. (Enum a) => Int -> a -> Int
22:51:38 <aavogt> you don't have to go fully @pl ;)
22:51:55 <aavogt> @type (x*256 +)
22:51:56 <lambdabot> Expr -> Expr
22:52:02 <aavogt> (x*256 +)
22:52:10 <aavogt> > (x*256 +)
22:52:11 <lambdabot>   Overlapping instances for GHC.Show.Show
22:52:11 <lambdabot>                              (Simpl...
22:52:21 <aavogt> > \y -> (x*256 +) y
22:52:22 <lambdabot>   Overlapping instances for GHC.Show.Show
22:52:22 <lambdabot>                              (Simpl...
22:52:29 <veinor> blah, I can't figure out what's wrong with this code
22:52:36 <veinor> I know I'm making some obvious mistake
22:52:44 <aavogt> veinor: is there much?
22:53:03 <veinor> four lines
22:53:16 <veinor> or so
22:53:51 <aavogt> @paste it veinor?
22:53:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:54:25 <veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8254#a8254
22:54:50 <veinor> keeps telling me tagStart isn't in scope
22:55:32 <Saizan> you've to indent the where more
22:55:56 <Saizan> otherwise it attaches to the getTag definition rather than the Just case
22:56:21 <aavogt> and it would probably be clearer to use fmap, instead of the case...
22:56:43 <veinor> trhm
22:57:11 <veinor> I indented it more but how it's saying 'parse error on input '='' on the dataFinish line
22:58:08 <aavogt> can foldl really be convinced to take 5 arguments?
22:58:26 <veinor> ... this is what happens when I try programming at 2am
22:58:44 <copumpkin> lol
22:58:51 <copumpkin> it can if the output is a function
22:58:58 <copumpkin> although that doesn't really count
22:59:06 <aavogt> yes it does
22:59:19 <copumpkin> I'd say that isn't really foldl taking the arguments though
22:59:24 <copumpkin> it's foldl's output
22:59:33 <veinor> fixed it
22:59:35 <aavogt> @type foldl
22:59:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:59:58 <veinor> now let's see if it works like I hope it does
23:01:52 <BMeph> So why is it that a function that ends up indexing a list run faster when the index is omitted from the definition?
23:02:13 <copumpkin> ?
23:03:13 <BMeph> "rootT = genericIndex (map rootedT [0..])" runs faster than "rootT n = genericIndex (map rootedT [0..]) n"
23:03:49 <Cale> BMeph: are you sure?
23:04:24 <BMeph> Cale: Well, there may be some other reason why it runs slower, but that's the only change I make to the function.
23:04:37 <copumpkin> how much slower?
23:04:39 <Axman6> anyone have any thoughts on http://www.bugfree.dk/blog/2009/08/15/why-not-to-comment-code/ ? i can't decide if i agree or not
23:04:45 <Cale> Does it have an explicit type signature? Make sure the inferred type is the same.
23:05:08 <Cale> If the MR is on, then the first might be defaulting to a monomorphic definition.
23:05:27 <edwardk> axman6 i agree that ghostdoc is evil
23:05:52 <olsner> Axman6: please agree, he's right :P
23:06:37 <Axman6> well, i don't think there's anything wrong with writing API documentation along with the code
23:06:52 <olsner> API documentation is a different thing, but comments are the first way of saying "ok, I give up, I can't write this code understandably"
23:07:10 <copumpkin> Axman6: that article says api documentation is fine
23:07:13 <Axman6> but i am a strong believer in making code readable, and self explanatory
23:07:34 <Cale> I don't understand why using automatic tools to generate documentation from code+comments would be bad.
23:07:37 <edwardk> Axman6: in general he mostly seems to be advocating for not using api doc autogenerators like ghostdoc, that give the kind of crap 'undocumentation' you find when you try to say lookup how to use a sharepoint api.
23:07:41 <Axman6> copumpkin: well, it's been like 3 hours since i read the article, so my memory of it is probably pretty rooted ;)
23:08:21 <edwardk> cale: ghostdoc itself isn't any worse than haddock, the problem is that in general you find that 90% of the teams using ghostdoc don't actually document... they push out the blank ghostdoc and call it documentation
23:08:23 <copumpkin> Cale: combined with real people and time constraints, you get a bunch of "docs" which might be worse than nothing :P
23:09:14 <edwardk> copumpkin: and worse, since it is now 'documented' its your fault for not understanding the 'documentation'
23:09:18 <Cale> Haddock documentation is normally so much better than the average non-Haddock documentation I run across. It's linked to the source, it's uniform, and it usually is reasonably up to date with the actual code.
23:09:20 <copumpkin> yeah
23:09:47 <copumpkin> having types already helps a good amount
23:11:03 <BMeph> Without the type signature, it "defaults" to Integer -> Integer. Time: 0.03 sec.
23:11:17 <olsner> types are kinda like documentation that's guaranteed correct by the compiler :)
23:11:42 <BMeph> With the type signature, it's Integral i => i -> i. Time: 0.03 sec.
23:12:39 <copumpkin> zomg, 0.00 seconds slower
23:12:43 <BMeph> Without the type signature, and the argument specified... it's been a minute, and it's still running. =8*O
23:13:03 <copumpkin> add a {-# SPECIALIZE
23:13:17 <Cale> BMeph: I wonder if the eta-reduced version is having the list that you're indexing into lifted to the top-level.
23:13:54 <BMeph> Cale: So, compile it and profile? :)
23:13:58 <Cale> BMeph: If that list is expensive to compute, and you don't care about the memory usage, you should ensure that its elements are computed at most once by defining it as a constant
23:14:06 <edwardk> copumpkin: that feels almost like one of those ' 2 + 2 = 5 for extremely large values of 2' kind of comment
23:14:08 <edwardk> er comments
23:14:11 <olsner> BMeph: what's the type when you write it without type signature and argument?
23:14:18 <copumpkin> :P
23:14:21 <BMeph> Without the type signature, it "defaults" to Integer -> Integer. Time: 0.03 sec.
23:15:27 <olsner> i.e. what's the type of this one? "<BMeph> Without the type signature, and the argument specified... it's been a minute, and it's still running. =8*O"
23:16:15 <olsner> is that also Integer -> Integer?
23:16:55 <Cale> I'm betting that ghc is turning  rootT = genericIndex (map rootedT [0..])  into   foo = map rootedT [0..]; rootT = genericIndex foo, and it's not doing that for the function, for some reason.
23:18:03 <veinor> all right, it actually works :D
23:18:04 <BMeph> No, I think the genericIndex is forcing the Integral context, and no further.
23:18:10 <olsner> oh, and isn't that equivalent to rootT = rootedT?
23:18:32 <olsner> since (map f [0..] !! n) = f n
23:18:34 <Cale> olsner: apart from being slower, yes
23:18:59 <Cale> That is, unless GHC decides to lift the constant out.
23:19:08 <BMeph> Maybe that's it - with the eta-expanded version, it simplifies it too much...
23:19:09 <Cale> (which it probably is doing in the cases where it's fast)
23:19:23 <Cale> The eta-reduced version, you mean?
23:20:01 <BMeph> Cale: No, the eta-expanded. It simplifies it so that the list isn't populated, so it recalculates every time.
23:20:03 <Ford_Perfect> Hi, one question, when i try to install binary version of GHC with "./configure --prefix=/usr/local/test"   i get error "checking for path to top of build tree... pwd: timer_create: Operation not supported"   and after   "configure: error: cannot determine current directory" , any advice?
23:20:05 <Cale> BMeph: Try explicitly factoring out the constant.
23:20:24 <Cale> Ford_Perfect: What platform?
23:20:44 <Ford_Perfect> linux x86  2.4.21-15.ELsmp
23:20:54 <BMeph> Anyway, here's the relevant fragment - http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8255#a8255
23:21:02 <Cale> Oh, whoa, a 2.4 kernel...
23:21:12 <Ford_Perfect> well company policy
23:21:46 * BMeph clears his throat in a way that sounds suspiciously like "VirtuaBox!"...
23:24:00 <Cale> It seems like a lot of people have problems running GHC-compiled things on older kernels. Even some of the older 2.6.x kernels appear to have that issue.
23:25:01 <Cale> Sufficiently old GHCs will apparently work though... I found a mailing list message that says someone having that problem was able to get ghc-6.4.1 to work.
23:25:17 <thoughtpolice> L
23:25:23 <thoughtpolice> shit, wrong terminal :)
23:26:07 <olsner> can 6.10 be built directly with 6.4, or does it require bootstrapping with an intermediate version?
23:26:21 <opqdonut> Cale: interesting
23:26:50 <Ford_Perfect> well does not sound so good for me i guess ;)
23:27:17 <Cale> There's some noise that timer_create was possibly broken in older kernels.
23:27:39 <Ford_Perfect> Download Happstack ghc 6.8.3 or 6.10.1, and cabal >= 1.6 are required.
23:28:11 <koala_man> it is. I have timer_create issues in 2.6.9
23:28:26 <Ford_Perfect> how did you solve it koala_man ?
23:28:30 <koala_man> I didn't
23:28:36 <Cale> http://hackage.haskell.org/trac/ghc/ticket/850 -- this was the bug whose fix involved the introduction of timer_create
23:29:30 <olsner> why does ghc include a compiled binary in the sources? can't you just use plain pwd?
23:29:54 <Cale> Ideally, I think you'd drop the policy of using a years-out-of-date kernel :P
23:30:29 <Ford_Perfect> well company that still uses windows XP cliants is same using 2.4 kernel ;)
23:30:36 <copumpkin> olsner: it doesn't does it?
23:30:39 <Ford_Perfect> hint hint ^^
23:33:40 <olsner> copumpkin: hmm, perhaps it's actually built locally... that would cause the same problem anyway, since the RTS uses timer_create
23:34:13 <olsner> http://www.nabble.com/Error-in-configure-script-for-GHC-td18156149.html <-- here's a reference to someone who got a binary (for a different architecture) in the source dist
23:34:31 <olsner> but that might have been a temporary error in the distribution
23:35:26 <veinor> when haskell is doing its whitespace-sensitive stuff, how many spaces are in a tab?
23:36:27 <BMeph> veinor: pi * e
23:36:45 <Ford_Perfect> LOL@ BMeph
23:36:50 <veinor> haha
23:37:10 <copumpkin> veinor: it doesn't care about tabs
23:37:17 <copumpkin> veinor: it actually tries to line things up
23:37:24 <copumpkin> oh well actually
23:37:34 <copumpkin> I think it does map the tab character to 8 spaces or something silly
23:37:41 <veinor> yeah, that's what I meant
23:37:43 <copumpkin> but just use soft tabs and you should be good
23:37:46 <edwardk> veinor: 8
23:37:51 <copumpkin> tab characters are evil anyway
23:37:55 <veinor> I always use soft tabs, was just curious
23:38:21 <veinor> hm, if I'm writing a function that extracts ID3 tags from an MP3, I'm guessing it should be String -> String -> Maybe String
23:39:03 <Cale> veinor: What are the first two strings?
23:39:24 <edwardk> veinor: http://www.haskell.org/onlinereport/syntax-iso.html#layout mentions the fact that layout is done with 8 character tabstops
23:39:43 <veinor> tag identifier, TIT2/TRCK/TPOS etc and the MP3 file to be searching
23:39:50 <veinor> as a string (well eventually ByteString)
23:40:02 <olsner> so, a tab maps to 8 - (column `mod` 8) spaces?
23:40:11 <veinor> but my point is I shouldn't pass a handle into it
23:40:36 <Cale> olsner: yeah, but you should not allow any tab characters into your haskell source files ever for any reason. ;)
23:41:10 <edwardk> i wonder how much work it'd be to add a warning for when layout depends on the width of non-space characters (including tabs) there -fwarn-tabs or something but i mean we don't all use a fixed width font =)
23:41:31 <veinor> Cale: remove the word haskell and htis is still true
23:41:33 <veinor> *this
23:41:34 <edwardk> and when you start using unicode symbols, many tend to be represented double-wide even in a fixed width font
23:41:39 <edwardk> olsner: yeah
23:41:55 <Cale> edwardk: I think the ascii tab character occurring anywhere in the file should cause a lexical error, not even a warning.
23:42:15 <copumpkin> a tab character should be a valid operator ;)
23:42:43 <Cale> copumpkin: You'd like dc ;)
23:42:58 <copumpkin> is that a language?
23:43:20 <edwardk> Cale: with kata i've been playing with the notion that if you put something on the same line as preceding text (tabs included!) it'd be illegal to use a virtual semicolon, that would let the oneliner examples for lambdabot liek stuff to be done, but avoid brittle layouts
23:43:25 <Cale> yeah, it's probably the most widely distributed esoteric programming language
23:43:30 <copumpkin> ah
23:43:39 <Cale> copumpkin: If you have a unix-like machine, type dc at the prompt :)
23:43:55 <copumpkin> oh
23:43:58 <copumpkin> that dc
23:44:03 * BMeph would like to see a dc interpreter in Haskell...that way, he can stop planning to fail half-way through coding one himself!
23:44:05 <aleator> Eh. What is a bus error, and why does it only happen when I compile (with ghc) my ugly horrible program, and not with ghci?
23:44:19 <veinor> aleator: when you don't have exact change for your bus ride
23:44:29 <copumpkin> aleator: it happens during compilation??
23:44:40 <copumpkin> aleator: or in the compiled program (less ?? but still pretty ??)
23:44:41 <aleator> copumpkin: No, running the program
23:44:46 <copumpkin> are you doing FFI stuff?
23:44:56 <copumpkin> it's when you try to do stuff with nonexistent memory
23:45:53 <copumpkin> or unaligned according to wikipedia
23:45:54 <aleator> copumpkin: Right.. Hmm.. I am loading bad jpgs, so it might be opencv that borks.
23:45:55 <olsner> Cale: is it really esoteric if it's widely distributed?
23:46:42 <aleator> Hmm.. Also. When doing similar stuff with ghci it doesn't seem to ever release memory like compiled program. Is that normal?
23:47:49 <copumpkin> ghc never releases memory to the OS
23:47:58 <copumpkin> doesn't mean it's leaking for your program
23:49:04 <aleator> copumpkin: Well, it is leaking :) Not sure how, since compiled one isn't..
23:49:32 <aleator> Probably me being stupid in some unexpected way
23:49:37 <edwardk> aleator: note that the interpreter probably isn't doing all the strictness analysis etc that the compiled version does, so its probably being too lazy
23:52:40 <Cale> olsner: Well, it's basically impossible to avoid having your programs look like line noise.
23:53:07 <olsner> Cale: ah, so it's a perl dialect? :P
23:53:11 <Cale> olsner: also, it has stacks named after each possible byte
23:53:13 <BMeph> Cale: That reminds me of the whole K/Q system. :)
23:53:22 <Cale> Including newline and space
23:53:47 <BMeph> Cale: Well, not the register stack-thing, the "line noise" quote. :)
23:56:03 <Cale> dc -e '?[q]sQ[d1=Qd1-lFx*]dsFxp'  -- compute the factorial of a number read from stdin
23:57:04 <BMeph> Awesome! :D
23:58:04 <Cale> another one from the wikipedia article on dc:
23:58:15 <Cale> dc -e '[[Enter a number (metres), or 0 to exit]psj]sh[q]sz[lhx?d0=z10k39.370079*.5+0k12~1/rn[ feet ]Pn[ inches]P10Pdx]dx'
23:58:31 <olsner> sweet
23:59:27 <Cale> dc -e '??[dSarLa%d0<a]dsax+p' -- gcd of two integers
23:59:36 <copumpkin> nice
23:59:46 <copumpkin> looks like APL without the odd characters
