00:00:14 <copumpkin> yeah
00:00:19 <copumpkin> that's what I've been experimenting with recently
00:00:20 <mmorrow> copumpkin: whether that would end up being really ugly i'm not sure :)
00:00:30 <copumpkin> the pain is that not only do you need to pass around the dictionaries
00:00:38 <copumpkin> but you need to pass them to the "record accessors"
00:01:07 <mmorrow> copumpkin: right, that part gets really annoying for sure
00:01:33 <Saizan> record accessors?
00:01:55 <mmorrow> Saizan: that or just pattern match on the dicts
00:02:05 <mmorrow> but that can get verbose
00:02:06 <copumpkin> mmorrow: yeah, both ugly
00:02:31 <copumpkin> Saizan: data Num a = Num { (+) :: a -> a -> a ... }
00:02:36 <copumpkin> Saizan: that kind of thing
00:02:51 <Saizan> ah, so the comment was that you need to route them down to the methods, rather than just accepting them as arguments for your polymorphic function?
00:03:01 <copumpkin> yeah
00:03:17 <copumpkin> it makes every method call more painful
00:03:30 <mmorrow> yeah, that's the huge convenience of typeclasses
00:03:31 <copumpkin> which is part of the reason I tried (very unsuccessfully) to petition for an "open" keyword :P
00:03:47 <copumpkin> but everyone said "oh, but you can apply hack X and it works"
00:04:03 <copumpkin> even though I listed the hacks they suggested in my original email as things I didn't like
00:04:14 * copumpkin pouts
00:04:14 <mmorrow> the huge inconvenience being that if what you need to do doesn't isn't compatible with how instances are selected, you're screwed
00:04:25 <mmorrow> s/doesn't//
00:04:27 <copumpkin> yeah, which was my problem
00:04:32 <Saizan> don't record puns give you something like where Num{..} = numDict that brings all the fields of numDict into scope?
00:04:45 <copumpkin> really?
00:04:51 <mmorrow> :o
00:05:04 <Saizan> it works for setting, so i think it should work for accessing
00:05:22 <Saizan> (or maybe that was a custom ghc?)
00:05:30 <copumpkin> I see
00:06:04 <copumpkin> seems slightly neater at least
00:07:03 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards <-
00:07:41 <copumpkin> aha
00:07:44 <copumpkin> yeah, just playing with that now
00:07:53 <copumpkin> that will make my life a lot easier, thanks :)
00:08:09 <copumpkin> (but I still do want an explicit typeclass instance selection syntax)
00:08:35 <Saizan> it's so weird, i've known of that extension for a long time, but never connected it with opening a record..
00:08:53 <copumpkin> it'll make my homebrew typeclasses a lot more pleasant to use I think
00:08:54 <tymmym> #lisp
00:12:23 <copumpkin> implicit parameters + record wildcards could be an interesting combination :P
00:12:35 <copumpkin> that would look almost like typeclasses
00:12:39 <mmorrow> yeah totally
00:13:04 <copumpkin> except I'm not sure how you could do the Constructor{..} thing for the implciit parameter
00:13:13 <copumpkin> without an explicit case
00:13:19 <mmorrow> case ?x ^W^W
00:13:21 <mmorrow> :)
00:13:28 <copumpkin> :P
00:14:03 <mmorrow> yeah hmm, i guess there's no way to make it transparent
00:17:56 <mmorrow> copumpkin: i bet with -pgmF (whatever the preproc one is) + haskell-src-exts you could make a super-lightweight preprocessor that just does "f x1 .. xn = e" ==> "f x1 .. xn = case ?dFoo of Foo{..} -> e"
00:17:58 <harlekin> Can one use hpaste for everything or is it for Haskell only?
00:18:09 <copumpkin> mmorrow: that's true
00:18:22 <copumpkin> harlekin: definitely seen people use it for random things like cobol :P
00:18:24 <mmorrow> harlekin: anything. it has highlighting options for a ton of langs
00:18:35 <copumpkin> mmorrow: that could be quite nice actually
00:18:47 <mmorrow> copumpkin: totally
00:19:01 <copumpkin> but the problem with haskell-src-exts is that I can't really add any syntax
00:19:14 <mmorrow> copumpkin: what do you mean?
00:19:14 <copumpkin> I could steal a function name and give it a special meaning
00:19:41 <copumpkin> oh, you mean parsing out my special syntax first, and then feeding the rest to haskell-src-exts?
00:20:01 <copumpkin> say I wanted to add a keyword to open a particular instance of a typeclass
00:20:16 <quicksilver> copumpkin: you do realise that explicit typeclass instance selection breaks everything important about typeclasses and makes them useless, right?
00:20:16 <copumpkin> or some form of syntax that I have not yet decided on
00:20:26 <copumpkin> quicksilver: how so?
00:20:37 <copumpkin> that seems pretty evil of me
00:20:39 <quicksilver> the globalness of typeclasses is what makes them useful.
00:20:46 <mmorrow> copumpkin: just pattern match on the Decls in (Module ... [Decl]), find the FunDecls, look if the type has a "(?dFoo::Foo) =>" context, and if so just wrap the entire function body in "case ?dFoo of Foo{..} -> body"
00:20:51 <quicksilver> the uniqueness of instances is used to guarantee invariants.
00:21:02 <mmorrow> copumpkin: or that's my initial thought at least
00:21:05 <quicksilver> Ord in Data.Map is the most obvious example but there are plenty more subtle ones.
00:21:41 <copumpkin> quicksilver: my main issue is that I have a situation where a MPTC seems appropriate but fundeps are not, and I have multiple valid instances that it makes sense to select explicitly
00:21:49 <copumpkin> doing it with dummy arguments or newtypes is ugly
00:22:00 <harlekin> @pl (\ps s -> take ((length ps) - (length s)) ps ++ s
00:22:00 <lambdabot> (line 1, column 50):
00:22:00 <lambdabot> unexpected end of input
00:22:00 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++", "<+>" or ")"
00:22:02 <harlekin> @pl (\ps s -> take ((length ps) - (length s)) ps ++ s)
00:22:03 <lambdabot> join . ((++) .) . (flip =<< (take .) . (. length) . (-) . length)
00:22:08 <copumpkin> but the alternative of fundeps is overly restrictive
00:22:27 <copumpkin> mmorrow: hmm, I see
00:22:31 <mmorrow> quicksilver: right, but that doesn't mean that a different construct that's similar to typeclasses that would somehow allow that wouldn't be useful
00:22:40 <quicksilver> copumpkin: I can't quite picture the case where explicit instance selection would be more convenient than just passing a dictionary.
00:22:43 <quicksilver> mmorrow: sure.
00:22:59 <quicksilver> mmorrow: but I don't understand in what ways that would be different to explicit higher order function passing.
00:23:01 <copumpkin> quicksilver: explicitly passing a dictionary suffers from the issues we've been talking about
00:23:13 <copumpkin> namely, it's a real pain in the ass :P
00:23:59 <copumpkin> less so with the RecordWildCards extension
00:24:02 <copumpkin> but still :P
00:24:24 <copumpkin> I don't quite see why adding the option of explciit instance selection would destroy the very foundation upon which all typeclasses are built
00:24:25 <copumpkin> or whatever
00:24:35 <mmorrow> quicksilver: oh, right. well, one interesting possibility (actually this is my entire motivation (wrt concrete things)) is to have a module that's like an ML functor, that takes (via whatever mechanism) the intended instances of the classes it uses, then at compile-time all dictionary passing would be eliminated
00:24:58 <copumpkin> it's not a common scenario but given that it's very easy to write utterly useless MPTCs right now, it seems like something at least is missing
00:26:05 <mmorrow> copumpkin: yeah, also syntactic sugar could go a long way
00:26:15 <mmorrow> (wrt explicit dict passing)
00:26:42 <quicksilver> well you can use Applicative or Monad techniques to make the dictionary passing vanish
00:26:51 <quicksilver> (at the cost of having to use Applicative or Monad syntax)
00:26:53 <copumpkin> yeah, I've thought of a reader-like thing
00:26:57 <copumpkin> but yeah
00:27:19 <copumpkin> it's a kludge, and I still don't really see what's so fundamentally wrong with being able to say "yes, I can see this is ambiguous, let me just tell you what I mean"
00:27:41 <copumpkin> in a way that doesn't involve undefined :: Int or whatever
00:28:18 <mmorrow> quicksilver: right, so this hypothetical ML-functor module wouldn't have to assume any contexts or anything like that, *and* it can assume that it _knows_ the instance of FooClass that's being used, but doesn't have to concretely know it. just that it exists
00:28:41 <quicksilver> you can always do it with either an explicit annotation or a carefully typed `asTypeOf` style function. Possibly with phantoms.
00:29:07 <quicksilver> newtype Const a b = MkConst a is a useful trick occasionally.
00:29:10 <mmorrow> and then you'd apply that module/functor to "args" (args := instances) at compile-time
00:29:25 <copumpkin> quicksilver: really? my situation is vaguely putting phantom types in the instance... I have a class like: class Moo a b where baa : a -> a
00:29:43 <copumpkin> quicksilver: my issue is that there's absolutely no trick in the world that seems to make baa possible to call
00:29:49 <quicksilver> yes, you could make that baa : (Const a b) -> a
00:29:53 <quicksilver> or a -> Const a b
00:30:00 <copumpkin> yeah, that's what I consider a kludge :P
00:30:04 <quicksilver> sure.
00:30:24 <copumpkin> there are a bunch of tricks, but all involve putting a b into the type of baa that seems unnecessary
00:30:31 <quicksilver> the thing is, it sounds like you're talking about implicit parameters at the type level
00:30:37 <quicksilver> and I really don't like implicit parameters.
00:30:49 <quicksilver> they reduce the ease with which subexpressions can be seen to stand alone
00:30:59 <quicksilver> if they depend somehow on their context in a subtle way
00:31:09 <mmorrow> quicksilver: like class contexts! ;)
00:31:14 <quicksilver> which makes refactoring and equational reasoning hard.
00:31:28 <copumpkin> my goal with this was quite the opposite actually
00:31:33 <quicksilver> mmorrow: yes, btu class contexts are a strikingly elegant solution to this tension.
00:31:48 <mmorrow> quicksilver: yeah, they are
00:31:50 <copumpkin> well, my application here is to make a fully general algebra library where structure operations are parametrized by "phantom" types representing the operations on the structure
00:32:10 <quicksilver> mmorrow: because they make the context dependence visible in the type of the whole expression whilst maintaining the fact that every subexpression has a consistent principal type
00:32:14 <mmorrow> quicksilver: (but implicit params induce a context too)
00:32:32 <quicksilver> true.
00:32:58 <mmorrow> @type let foo x = let (y,z) = ?f x in y (fmap ?g z)
00:32:59 <lambdabot> on the commandline:
00:32:59 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
00:32:59 <lambdabot> <no location info>:
00:33:01 <mmorrow> @type let foo x = let (y,z) = ?f x in y (fmap ?g z) in foo
00:33:03 <lambdabot> forall a b (f :: * -> *) t t1. (Functor f, ?g::a -> b, ?f::t -> (f b -> t1, f a)) => t -> t1
00:34:16 <copumpkin> quicksilver: so I wanted to build things like
00:34:16 <copumpkin> class (CommutativeMonoid plus a, Monoid times a, Distributive plus times a) => Semiring plus times a where
00:34:52 <quicksilver> copumpkin: "all involve putting a "b" in to the type of baa that seems unnecessary"
00:35:12 <quicksilver> copumpkin: so, obviously, you need another mechanism for the compiler to deduce which 'b'.
00:35:19 <copumpkin> yes
00:35:20 <quicksilver> what mechanism are you proposing?
00:35:30 <copumpkin> an "open" keyword, or equivalent
00:35:32 <copumpkin> to just tell it :P
00:35:39 <quicksilver> (explicit instance selection isn't going to do this)
00:35:50 <quicksilver> you're talking more about something like explicit fundep choice.
00:36:18 <copumpkin> well in my example above, there are no meaningful fundeps between the set the semiring is on and either of its operations
00:36:25 <quicksilver> after all, the existance of an instance of Moo is a property of pairs of types (a,b) not just types a.
00:36:33 <quicksilver> so you're not "choosing an instance for a given a"
00:36:36 <quicksilver> (that odesn't make sense)
00:36:49 <copumpkin> no, I wasn't suggesting that
00:37:01 <copumpkin> I mean to explicitly say that I am operating on Moo for Int and Double
00:37:12 <copumpkin> such that it can go dig up the appropriate dictionary
00:37:48 <quicksilver> yes, but from the type of 'baa' it's only going to see Int
00:37:51 <quicksilver> so what you *are* saying is
00:37:56 <copumpkin> or in the other example, that I would like the Semiring for Plus and Times on Double (the set itself may be inferred)
00:38:00 <quicksilver> "when you only see Int, I did also mean Double"
00:38:10 <quicksilver> that's what I mean by it being like a local fundep.
00:38:14 <copumpkin> ah yes
00:38:19 <quicksilver> "in this scope, Int -> Double, for Moo a b"
00:38:21 <copumpkin> it would definitely have a scope
00:38:26 <copumpkin> yep
00:38:40 <quicksilver> so, it's not explicit instance selection. It's explicit fundep selection.
00:38:47 <copumpkin> fair enough
00:38:52 <quicksilver> explicit instance selection would be when there are two instances of Moo Int Doble
00:38:56 <quicksilver> and you're trying to choose one of them.
00:39:08 <copumpkin> yeah, I don't need that :)
00:39:16 <quicksilver> ok, well that is what breaks the universe.
00:39:36 <quicksilver> this is something more like a temporary fundep, which I hadn't thought of before.
00:39:39 * quicksilver ponders it.
00:40:23 <copumpkin> it's mostly just to make my algebra library less of a pain to use :P not sure what other legitimate uses there are for such a thing
00:41:08 <copumpkin> -XScopedFunctionalDependencies ? :P
00:42:19 <greap> Any idea why this [http://pastebin.com/m472f37f1] is returning [Couldn't match expected type `Int' against inferred type `b']?
00:42:53 <copumpkin> greap: on what line?
00:43:04 <greap> 3
00:43:55 <greap> I was under the impression that you could make a type more specific, but this seems to think that the variable type 'a' has to remain variable... Or not?
00:44:53 <greap> btw, working from [http://www.haskell.org/haskellwiki/Memoization]
00:45:16 <copumpkin> greap: nope
00:45:35 <copumpkin> you can make it more specific in other contexts
00:45:38 <quicksilver> greap: memoFix promises to work for ALL a and b
00:45:41 <copumpkin> but there it's actually forall a b.
00:45:54 <quicksilver> greap: you can't define it in terms of memoize which only works for Int.
00:46:28 <copumpkin> you could define it in terms of Enum, which can convert anything to an Int (in ugly ways, often)
00:46:48 <copumpkin> I'm not sure why your memoize is restricting the type of memoizeInt
00:47:04 <greap> But as far as I could tell, the examples were saying that you needed a datastructure that mapped a specific type to an arbitrary type, so how would you create a memoize that worked generally?
00:47:43 <quicksilver> greap: you can't, basically.
00:47:53 <greap> :/
00:48:04 <quicksilver> because you can't turn an arbitrary type into a piece of data
00:48:23 <copumpkin> greap: if you could write a memoize that worked using Ints on a Real type, our world would collapse!
00:48:38 <greap> So the memoize example should not to be considered something that you can actually use.
00:48:41 <copumpkin> of course, you can't write a Real type, so I think we're safe for now anyway
00:48:57 <quicksilver> canonically, you can't turn a function into data
00:49:24 <quicksilver> so you can't memoize something which takes arguments of type function.
00:49:39 <quicksilver> another type you can't turn into data is IO ().
00:49:59 <quicksilver> You could make a general memoize work over a large class of values, given a data representation.
00:50:06 <quicksilver> Show would be enough (if a bit slow)
00:50:21 <copumpkin> instance Copointed IO where extract = unsafePerformIO
00:50:21 <quicksilver> you could use tries over the strings produced by Show
00:50:22 * copumpkin whistles
00:50:47 <quicksilver> copumpkin: yes, but that makes (putStrLn "hi") the same key as (return ())
00:50:56 <quicksilver> copumpkin: so, it's pretty badly broken.
00:51:02 <copumpkin> :P
00:51:25 <copumpkin> (it wasn't intended as a serious suggestions)
00:51:44 <greap> quicksilver: makes sense. :)
00:52:32 <greap> Do you think the wiki should mention that there is no way to implement the general case that it proposes?
00:53:38 <quicksilver> greap: perhaps. Which wiki page are you looking at?
00:54:12 <quicksilver> it does say you will need a type class
00:54:18 <quicksilver> Memoizable
00:58:34 <greap> quicksilver: http://www.haskell.org/haskellwiki/Memoization
00:58:50 <quicksilver> greap: yes, I found it. It does say you will need a type class.
00:58:57 <greap> Ah
00:58:57 <kyagrd> Another call for lambdabot help.
00:58:57 <quicksilver> maybe it's not clear enough
00:59:39 <kyagrd> I compiled lambdabot myself and ran it.  Then I typed > 1+1 but it just says "Terminated" whatever I run.
00:59:58 <greap> quicksilver: It seems clear in hindsight.
01:00:01 <kyagrd> Do I have to do some setting for lambdabot to call ghc properly?
01:03:00 <quicksilver> kyagrd: the group of people who have managed to compile and run lambdabot is small and exclusive. I'm afraid I'm not a member :(
01:03:37 <kyagrd> quicksilver: It's not at all hard to compile. All you need to do is cabal install lambdabot :)
01:04:02 <kyagrd> > 1+1
01:04:03 <lambdabot>   2
01:04:29 <quicksilver> kyagrd: well, by 'compile' I mean 'compile and get working'
01:04:31 <quicksilver> ;)
01:05:22 <kyagrd> Yeah hoogle doesn't work either ...
01:05:42 <quicksilver> hoogle will require a local hoogle DB
01:05:48 <quicksilver> it's not a web service
01:05:51 <kyagrd> But very interestingly @type work
01:05:53 <quicksilver> it builds a local DB file and uses it.
01:05:58 <Saizan> copumpkin, quicksilver: to make "foo :: forall a b. C a b => a -> a" callable one could just add (optional) explicit instantiation like in System F
01:06:08 <kyagrd> But not > 1+1 :(
01:06:15 <quicksilver> I'm quite surprised @type works and not @run
01:06:32 <quicksilver> maybe @type uses ghc-api now but @run forks a ghc process?
01:06:33 <kyagrd> That is the case
01:06:38 * quicksilver doesn't really know.
01:06:49 <quicksilver> Saizan: sure, but in general explicit instantion is what I'm trying to avoid.
01:06:56 <kyagrd> I mean I don't know whether it forks but that is what's happening
01:07:06 <quicksilver> Saizan: because it breaks the notion of using typeclasses for invariants which is pretty important to me.
01:07:13 <quicksilver> kyagrd: It might be the resource limit stuff
01:08:13 <Saizan> quicksilver: why? you still have only one typeclass for each pair of types, the only thing you gain is to be able to specify which 'b' you want
01:08:36 <quicksilver> Saizan: oh, I misunderstood you.
01:08:45 <copumpkin> I think he's afraid of two overlapping Moo Int Double instances
01:08:46 <Saizan> by explicit instantiation i mean type application
01:08:50 <quicksilver> Saizan: yes, that would fix it.
01:09:00 <copumpkin> and somehow being able to explicitly select between them?
01:09:00 <quicksilver> Saizan: but would involve the kind of boilerplate copumpkin is tring to avoid :)
01:09:18 <quicksilver> Saizan: after all you can just use data Const a b = MkConst a
01:09:24 <quicksilver> Saizan: as a way to select 'b' with a type annotation
01:09:33 <Saizan> quicksilver: or a Proxy b
01:09:36 <quicksilver> Saizan: but copumpkin doesn't like the noise.
01:09:40 <quicksilver> Saizan: or, indeed, that.
01:09:41 <Saizan> but those are quite uglier, imo
01:09:44 <copumpkin> :)
01:10:08 <Saizan> copumpkin: would you like foo [Double] [Int] a ? :)
01:10:33 <copumpkin> Saizan: in the context of my more extended example, nope :P
01:10:42 <quicksilver> I gues the pain with explicit type application would be, once you've started presumably you have to use it for all type parameters.
01:10:55 <jkff> @seen mmorrow
01:10:55 <lambdabot> mmorrow is in #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard mmorrow speak 37m 54s ago.
01:11:08 <mmorrow> jkff: hi
01:11:19 <jkff> Just wanted to thank for the yesterday's explanation :)
01:11:25 <Saizan> there should be a way to put blanks to be filled by the type checker
01:11:28 <copumpkin> Saizan: the context being the huge mess that is http://gist.github.com/166119 and making it a little less painful to use
01:11:29 <mmorrow> jkff: :) no problem
01:12:12 <Saizan> but yeah, a way to declare which 'b' you want at a block level would be the only convenient choice
01:12:40 <Saizan> but explicit instantiation at least let you do it without cluttering foo's type
01:14:37 <hackagebot> timeit 1.0.0.0 - <i>Added by LennartAugustsson, Fri Aug 14 08:10:44 UTC 2009.</i><p>Time a computation
01:15:00 <Saizan> copumpkin: so you'd like op :: Magma op a => a -> a -> a ?
01:15:30 <copumpkin> Saizan: yup, ideally :P not sure if my tastes in that regard match those of others though
01:15:52 <copumpkin> where op is a poor man's version of being able to pass a function value as a type
01:16:24 <Saizan> heh, you want singleton types :)
01:17:30 <jkff> copumpkin: The "huge mess" looks cool!
01:17:42 <kyagrd> Oh, i think got it: lambdabot needs mueval to @run
01:17:52 <Saizan> kyagrd: right
01:17:54 <copumpkin> jkff: it looks less cool than it did before, in my opinion, cause I had a bunch of "uncallable functions" :P
01:17:56 <copumpkin> but thanks :)
01:18:05 <kyagrd> But  .... my lambdabot says Could not find module `Data.Number.Symbolic': :( :(
01:18:14 <Saizan> cabal install numbers
01:18:25 <kyagrd> Saizan: Thanks
01:18:37 <quicksilver> copumpkin: all those functor and applicative instances can be derived
01:19:08 <copumpkin> quicksilver: oh, I thought the generalized newtype deriving thing could only pass on existing instances for the contained types
01:19:24 <copumpkin> well, that gets rid of a little bit of the boilerplate at least :)
01:19:27 <quicksilver> copumpkin: yes, not with newtype deriving, with an experiment new GHC Functor deriving thing
01:19:30 <copumpkin> but 99% of that code is boilerplate
01:19:33 <quicksilver> but I don't know how you select which you want.
01:19:35 <copumpkin> oh, cool
01:21:11 <copumpkin> *Enumerable> length (enumerate :: [(Int8, Word16)])
01:21:11 <copumpkin> 16777216
01:21:23 <jkff> I have a small dream to write an easy to use algebra-style library in Java, with generally-useful classes like Monoid, MonoidMap (one that aggregates values for a key), PartialOrder, Lattice etc., and show people that this stuff is not so theoretical.
01:21:26 <kyagrd> @hoogle Control.Monad.Logic
01:21:29 <lambdabot> package logict
01:21:46 <jkff> For now, I've got Monoid and MonoidMap, but noone uses them except for me :(
01:21:51 <copumpkin> aw
01:21:56 <Axman6> @hackage logic
01:21:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logic
01:22:15 <Axman6> :(
01:22:22 <kyagrd> @hoogle pure
01:22:23 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
01:22:23 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
01:22:23 <lambdabot> package pureMD5
01:22:40 <kyagrd> @hoogle Control.Applicative
01:22:40 <lambdabot> module Control.Applicative
01:22:40 <lambdabot> Control.Applicative class Functor f => Applicative f
01:22:40 <lambdabot> package applicative-extras
01:22:57 <Saizan> Control.Applicative should be in base
01:23:07 <Saizan> if you've a recent enough ghc
01:23:41 <kyagrd> Well lambdabot has problems :(
01:23:54 * Axman6 always finds it odd when people you've like that
01:23:55 <kyagrd> L.hs:3:29: Module `Control.Arrow' does not export `pure'L.hs:3:29: Module `Control.Arrow' does not export `pure'
01:24:06 <mmorrow> jkff: keep at it!
01:24:08 <copumpkin> instance (Enumerable a, Eq b) => Eq (a -> b) where
01:24:08 <copumpkin>   f == g = all (liftA2 (==) f g) enumerate
01:25:02 <jkff> btw, the interesting thing is that mutation can be used to model some things, such as monoid actions for example. You model a monoid action of M on S by a mutation procedure void mutate(M m, S s)
01:26:41 <jkff> Same applies to lattices: one can introduce, apart from min/max, also x.descendTo(y) and x.ascendTo(y)
01:27:26 <Saizan> kyagrd: edit ~/.cabal/share/lambdabot-$ver/State/L.hs removing "hiding (pure)"
01:27:37 <drwho> how would I get more information about these functions you are stating jkff?
01:27:58 <jkff> drwho: Which information?
01:28:41 <kyagrd> Saizan: Thanks, ... (wondering why that was there in the first place)
01:28:45 <drwho> information about the mutate, descendTo, and ascento functions
01:28:53 <jkff> For now, I just once tried to express the lattices and orders, but I came up with crap, so I erased it until I'd have more time to do it right.
01:29:16 <jkff> Which information about them? They don't exist, I'm just suggesting what they might do
01:29:29 <drwho> oh I see I was just checking
01:29:46 <mmorrow> jkff: you should put this stuff in a publicly available repo
01:30:15 <jkff> It's on my todo list :) However, not as the top item.
01:31:22 <copumpkin> should Eq be total?
01:31:29 <kyagrd> @hoogle pure
01:31:29 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
01:31:29 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
01:31:29 <lambdabot> package pureMD5
01:32:01 <jkff> copumpkin: I think it should correspond to the mathematical concept of equality, which is total
01:32:21 <jkff> Oh, I'm wrong. Equality does not have to be decidable
01:32:45 <Saizan> kyagrd: as you see older versions of base (like the one that hoogle database uses) had pure in the Arrow class too
01:33:19 <jkff> So the question is, if it is undecidable, whether one should attempt to define an approximation to it.
01:34:12 <copumpkin> :P
01:35:26 <jkff> I think one shouldn't, since it probably won't be obvious to the client as to how when the approximation works and when it doesn't
01:35:41 <jkff> s/how//
01:35:45 <kyagrd> Ah, I've commented out hiding(pure) but still the same message ... weired ...
01:36:49 <vav> kyagrd: it may be in your ~/.lambdabot/State/L.hs
01:37:16 <kyagrd> vav: Yes it is!!
01:37:55 <drwho> (\x -> x + x)
01:38:03 <drwho> oppes
01:38:13 <drwho> sorry pasted it here
01:38:24 <kyagrd> vav: copumpkin: Saizan: FInally @run works thanks all
01:39:30 <quicksilver> kyagrd: what fixed the 'Terminated' problem?
01:39:47 <quicksilver> ah, lack of mueval.
01:39:53 <quicksilver> is that a missing dep on the cabal package perhaps?
01:40:01 * copumpkin needs a lazy sequence
01:40:04 <copumpkin> does such a thing exist?
01:40:10 <kyagrd> quicksilver: Yup
01:40:12 <copumpkin> it's just for a list
01:40:25 <quicksilver> copumpkin: [a] ?
01:40:46 <vav> kyagrd: what all was missing? logict arrows mueval numbers
01:40:50 <copumpkin> [[a]] I guess :)
01:41:03 <quicksilver> copumpkin: perhaps. Im not sure what you're asking for.
01:41:19 <mmorrow> copumpkin: do you as in the Monad `sequence' ?
01:41:24 <copumpkin> mmorrow: yup
01:41:41 <quicksilver> copumpkin: Oh. well that doesn't reall make sense.
01:41:47 <quicksilver> :t sequence
01:41:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:41:56 <copumpkin> > sequence [[1,2],[1,2]]
01:41:58 <lambdabot>   [[1,1],[1,2],[2,1],[2,2]]
01:42:02 <copumpkin> > sequence [[1,2],[1,2],[1,2]]
01:42:03 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
01:42:04 <quicksilver> by the time you've got the [a] out of "m [a]", all the effects must have been done
01:42:08 <quicksilver> that's the whole point!
01:42:20 <quicksilver> if you want to do the effects bit by bit, then use [m a] directly.
01:42:55 <copumpkin> well, I'm really just trying to cheat and use it to get all sets (fine, lists) containing the given elements
01:43:05 <kyagrd> vav: yeah I installed them all
01:43:36 <mmorrow> data Step m a = None | Step a (m (Step m a))
01:43:51 <copumpkin> so really I'd like f (repeat xs) to be all lists containing elements in xs
01:44:00 <copumpkin> where f is almost sequence, but not quite
01:44:21 <mmorrow> step :: m (Step m a) -> m (a, m (Step m a))
01:44:45 <jkff> copumpkin: f(repeat xs) can't terminate, since it has to at least test each of repeat xs for emptiness
01:45:54 <copumpkin> what I have right now is
01:45:54 <copumpkin>   enumerate = concatMap (\n -> sequence $ replicate n enumerate) [0..]
01:45:58 <copumpkin> but that's not very pretty
01:46:25 <mmorrow> oh you want combinations indep of order
01:46:31 <copumpkin> @pl enumerate = concatMap (\n -> sequence $ replicate n enumerate) [0..]
01:46:32 <lambdabot> enumerate = fix (([0..] >>=) . (sequence .) . flip replicate)
01:46:33 <mmorrow> (since [] := Set here)
01:46:38 <copumpkin> yeah
01:46:40 <copumpkin> basically
01:46:58 <Saizan> cosmetic: replicateM
01:47:13 <copumpkin> oh yeah, good idea
01:47:34 <Deewiant> ?pl enumerate = concatMap (flip replicateM enumerate) [0..]
01:47:34 <lambdabot> enumerate = fix (([0..] >>=) . flip replicateM)
01:47:59 <quicksilver> > [0..] >>= flip replicateM "abc"
01:48:02 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
01:48:05 <quicksilver> (for example)
01:48:29 <mmorrow> , let combs n xs = foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs) in combs 2 "abc"
01:48:30 <lunabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
01:49:05 <pozic> There is a library which solves the same problem already.
01:49:11 <copumpkin> Omega?
01:49:59 <mmorrow> , permutations "abc"
01:50:00 <lunabot>  ["abc","bac","cba","bca","cab","acb"]
01:51:18 <mmorrow> , let combs n xs = foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs) in fmap (flip combs "abc") [0..]
01:51:19 <lunabot>  [[""],["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa"...
01:51:23 <mmorrow> err
01:53:08 <mmorrow> , fmap nub . flip replicateM "abc" =<< [0..]
01:53:09 <lunabot>  ["","a","b","c","a","ab","ac","ba","b","bc","ca","cb","c","a","ab","ac","...
01:53:18 <mmorrow> , nub . fmap nub . flip replicateM "abc" =<< [0..]
01:53:23 <lunabot>  Killed.
01:53:24 <mmorrow> crap
01:53:30 <mmorrow> , nub (fmap nub . flip replicateM "abc" =<< [0..])
01:53:36 <lunabot>  Killed.
01:53:49 <mmorrow> > nub (fmap nub . flip replicateM "abc" =<< [0..])
01:53:55 <lambdabot>   mueval-core: Prelude.read: no parse
01:53:55 <lambdabot>  mueval: ExitFailure 1
01:53:58 <mmorrow> wut
01:54:18 <mmorrow> @type fmap nub . flip replicateM "abc" =<< [0..]
01:54:19 <lambdabot> [[Char]]
01:54:48 <mmorrow> , nub [0..]
01:54:49 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
01:55:11 * mmorrow doesn't get it
01:55:48 <mmorrow> > (nub . take 20) (fmap nub . flip replicateM "abc" =<< [0..])
01:55:49 <lambdabot>   ["","a","b","c","ab","ac","ba","bc","ca","cb","abc"]
01:55:59 <mmorrow> ohh
01:56:08 <mmorrow> err
01:56:14 <quicksilver> > nub (cycle [1,2])
01:56:19 <lambdabot>   mueval-core: Prelude.read: no parse
01:56:19 <lambdabot>  mueval: ExitFailure 1
01:56:21 <mmorrow> @src nub
01:56:22 <lambdabot> nub = nubBy (==)
01:56:25 <mmorrow> @src nubBy
01:56:25 <lambdabot> nubBy eq []             =  []
01:56:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:56:26 <quicksilver> mmorrow: produces two elements lazily but then waits forever
01:56:41 <quicksilver> mmorrow: it doesn't knoe if it will ever find a new element
01:56:50 <mmorrow> but you don't at least get those 2 elems?
01:56:54 <quicksilver> mmorrow: and lambdabot doesn't try to print the maximal amount
01:56:56 <quicksilver> that's just LB
01:56:57 <mmorrow> ah
01:56:59 <quicksilver> in ghci you sould
01:57:08 <quicksilver> ghci tries harder to print available stuff
01:57:16 <mmorrow> ok that's what i didn't understand
01:57:20 <Saizan> it should actually manage..
01:57:30 <quicksilver> it's just a LB bug
01:57:33 <copumpkin> > permutations [1..]
01:57:33 <quicksilver> it waits for 78 chars
01:57:34 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:57:38 <quicksilver> (or normal termination)
01:57:53 <Saizan> > take 3 $ show $ nub (cycle [1,2])
01:57:54 <lambdabot>   "[1,"
01:58:00 <mmorrow> , nub (fmap (`mod` 7) [0..])
01:58:01 <Saizan> quicksilver: 78?
01:58:06 <lunabot>  Killed.
01:58:10 <quicksilver> Saizan: 78 or 77 or something yes.
01:58:14 <quicksilver> Saizan: after than it prints ...
01:58:20 <quicksilver> maybe it's 76.
01:58:32 <copumpkin> I suppose trying to enumerate a powerset of an enumerable set is a bad idea
01:58:33 <quicksilver> or normal termination, of course
01:58:34 <Deewiant> > map (const (replicate 78 'x')) $ nub (cycle [1,2])
01:58:36 * copumpkin tries anyway
01:58:39 <lambdabot>   mueval-core: Prelude.read: no parse
01:58:40 <lambdabot>  mueval: ExitFailure 1
01:59:05 <Saizan> ah, no, the ... happens inside lambdabot, but here you're seeing mueval error out
01:59:16 <Deewiant> > take 2 $ map (const (replicate 78 'x')) $ nub (cycle [1,2])
01:59:17 <lambdabot>   ["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
01:59:41 <quicksilver> Saizan: but that doesn't mean that mueval errors out without producing any output.
02:00:12 <quicksilver> Saizan: it just means that, because mueval errored out before producing 78 chars, LB prints the error not the output.
02:00:52 <Saizan> yeah, it makes sense
02:02:04 <pozic> Which HaXml binary do I need to call to get an XML file pretty printed?
02:02:39 <pozic> "pretty-printers for XML and HTML." from the Ubuntu package description
02:02:59 <mmorrow> , let nubia [] = []; nubia xs = let n = length [a | a@(_,[]) <- vacuum xs] in take (length xs) (nub xs) in nubia (cycle [1,2])
02:03:05 <lunabot>  Killed.
02:03:16 <mmorrow> gr
02:04:25 <Saizan> > replicate 600 'c' ++ show (nub (cycle [1,2])) -- it's stricter than that, maybe because of buffering
02:04:30 <lambdabot>   mueval-core: Prelude.read: no parse
02:04:31 <lambdabot>  mueval: ExitFailure 1
02:04:31 <mmorrow> gah! stupid error
02:04:38 <mmorrow> , let nubia [] = []; nubia xs = let n = length [a | a@(_,[]) <- vacuum xs] in take n (nub xs) in nubia (cycle [1,2])
02:04:40 <lunabot>  [1,2]
02:04:51 <mmorrow> take that nub!
02:04:57 <mmorrow> :)
02:05:28 <Deewiant> > concat (replicate 600 "c\n") ++ show (nub (cycle [1,2]))
02:05:30 <lambdabot>   "c\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\nc\...
02:06:01 <quicksilver> mmorrow: you're a bad man. People should tell you this often.
02:06:13 <Deewiant> > concat (replicate 600 "c") ++ show (nub (cycle [1,2]))
02:06:17 <mmorrow> quicksilver: hah, fairly often yes
02:06:18 <lambdabot>   mueval-core: Prelude.read: no parse
02:06:19 <lambdabot>  mueval: ExitFailure 1
02:06:23 <Deewiant> > concat (replicate 600 "cc") ++ show (nub (cycle [1,2]))
02:06:30 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
02:07:31 <Saizan> Deewiant: 1024 is the limit at which mueval truncates output itself
02:07:45 <Deewiant> Ah, heh.
02:08:01 <mmorrow> , concat (replicate 2047 "c") ++ show (nub (cycle [1,2]))
02:08:02 <lunabot>  "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
02:08:13 <mmorrow> , concat (replicate 2048 "c") ++ show (nub (cycle [1,2]))
02:08:14 <lunabot>  "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
02:09:19 <Deewiant> > replicate 1018 'c' ++ show (nub (cycle [1,2]))
02:09:25 <lambdabot>   mueval-core: Prelude.read: no parse
02:09:25 <lambdabot>  mueval: ExitFailure 1
02:09:26 <Deewiant> > replicate 1019 'c' ++ show (nub (cycle [1,2]))
02:09:28 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
02:09:33 <Deewiant> Lovely.
02:10:01 <mmorrow> , concat (replicate 2043 "c") ++ show (nub (cycle [1,2]))
02:10:02 <lunabot>  "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
02:10:04 <mmorrow> , concat (replicate 2042 "c") ++ show (nub (cycle [1,2]))
02:10:11 <lunabot>  Killed.
02:10:19 <Deewiant> >_<
02:10:28 <mmorrow> , 2048 - length " \"..."
02:10:29 <lunabot>  2043
02:11:20 <malcolmw> pozic: try Canonicalise
02:21:53 <copumpkin> @pl   enumerate = zipWith (\x ys z -> fromJust . lookup z $ strength x ys) enumerate (repeat enumerate)
02:21:54 <lambdabot> enumerate = fix (ap (zipWith ((flip ((fromJust .) . lookup) .) . strength)) repeat)
02:22:00 <copumpkin> okay, no
02:22:33 <copumpkin> dammit, it's wrong
02:26:29 <Axman6> :t zipWith (\x ys z -> fromJust . lookup z $ strength x ys)
02:26:31 <lambdabot> Not in scope: `strength'
02:26:39 <Axman6> bah
02:26:48 <copumpkin> @let strength = fmap . (,)
02:26:50 <lambdabot>  Defined.
02:26:51 <Deewiant> zipWith's argument type is (a -> b -> c) so that wouldn't work anyway
02:26:59 <Axman6> :t zipWith (\x ys z -> fromJust . lookup z $ strength x ys)
02:27:01 <lambdabot> forall a a1. (Eq a) => [a] -> [[a1]] -> [a -> a1]
02:27:05 <copumpkin> Deewiant: unless you wanted a list of functions
02:27:07 <solidsnack> Can anyone help me to see why these instances are taken to be overlapping?
02:27:08 <Deewiant> Oh, right
02:27:08 <solidsnack> http://gist.github.com/167734
02:27:09 <Deewiant> Heh
02:27:12 <copumpkin> Deewiant: which is what I wanted :P
02:28:00 <Deewiant> solidsnack: The part before the => isn't looked at to determine overlappingness
02:28:11 <solidsnack> Wow.
02:28:26 <solidsnack> Would these be incoherent instances?
02:29:09 <copumpkin> dammit, my enumerable functions are hard
02:29:49 <Deewiant> solidsnack: No, I think they're just plain overlapping instances
02:29:58 <Deewiant> But I'm not sure, I'm not very familiar with incoherent instances
02:30:10 <solidsnack> Hmm
02:30:24 <Deewiant> Ah: "The -XIncoherentInstances flag implies the -XOverlappingInstances flag, but not vice versa."
02:30:35 <solidsnack> In fact, when I add that extension it changes [overlap ok] to [incoherent]
02:31:34 <pozic> Ran out of memory for input buffer at /usr/lib/perl5/XML/Parser/Expat.pm line 46, ok, so let's give Haskell a chance.
02:32:16 <pozic> malcolmw: you might want to make --help work for all your released commands.
02:32:31 <malcolmw> pozic: noted
02:32:34 <solidsnack> So I guess the idea is, a type could be both a RealFrac and a Bounded, Integral
02:33:00 <solidsnack> I know that's not possible -- but the compiler can't tell.
02:33:00 <pozic> Canonicalise: Parse error: unexpected EOF
02:33:09 <malcolmw> pozic: there are lazy variants of some of the binaries, which might be useful if you are otherwise running out of memory, e.g. CanonicaliseLazy
02:33:14 <pozic> malcolmw: it might also be the file, but I doubt that.
02:33:58 <malcolmw> the lazy version would also parse as far as it can get before seeing the error, which would help identify what it is complaining about
02:34:24 <Axman6> how should pseq be thought of? i still don't understand exactly how it's supposed to be used and where to use it
02:34:28 <malcolmw> pozic: I mean, it would generate output as far as it hadd managed to parse
02:34:45 <copumpkin> Axman6: like a lazy seq :P
02:34:55 <Axman6> >_<
02:35:07 <Axman6> what's it do with its arguments?
02:35:18 <Axman6> i know it returns the second, but what aqbout the first?
02:35:25 <malcolmw> Axman6: pseq is what you would expect seq to mean.  a`pseq`b evaluates a before returning b
02:35:41 <Axman6> so why it it needed?
02:36:00 <malcolmw> Axman6: because, bizarrely, seq does not mean that
02:36:17 <malcolmw> in a`seq`b, the compiler is free to cause b to be evaluated first
02:36:17 <Axman6> it doesn't? o.O
02:36:42 <solidsnack> I often find myself thinking of instances like a case statement; but that's not right.
02:36:45 <Axman6> but, it happens not to?
02:37:04 <malcolmw> Axman6: no, ghc really does that
02:37:16 <copumpkin> Axman6: well most of the time you just care that a is forced at some point
02:37:28 <Axman6> hmmm
02:37:34 <copumpkin> but with parallel stuff, when it happens actually matters
02:37:45 <Axman6> my whole life is a sham now XO
02:37:51 <Axman6> >_>
02:38:17 <pozic> malcolmw: I also think the output of xml_pp is better than Canonicalise
02:38:18 <Axman6> so, what's the point of seq then?
02:38:46 <pozic> malcolmw: what exactly is Canonicalise supposed to do?
02:38:46 <malcolmw> pozic: the pretty-printing in HaXml is pretty  ugly, I agree
02:39:12 <copumpkin> Axman6: I guess the compiler gets some benefit from being able to reorder evaluation when you don't need the actual order (most of the time)
02:39:21 <malcolmw> pozic: Canonicalise is just (pretty . parse)
02:39:33 <copumpkin> or maybe it was because they didn't have the lazy function back in the day
02:39:43 <copumpkin> Axman6: I certainly don't know :)
02:39:48 * Axman6 is rather confused and decides to go back to thinking about seq as he previously did
02:39:59 <copumpkin> how did you think of it?
02:40:04 <malcolmw> pozic: is was never really intended as a real command-line tool, just a minimal demo of how to use the API calls in HaXml
02:40:15 <Axman6> that it evaluated a before b in a `seq` b
02:40:35 <malcolmw> Axman6: up until Haskell'98, that is exactly what seq meant
02:41:01 <Axman6> well, haskell'98++ then ;)
02:41:08 * malcolmw thinks it was a editorial oversight that changed seq`s meaning, not a deliberate decision
02:41:50 <Axman6> fair enough
02:42:10 <copumpkin> is the subtlety now that a is evaluated before the caller gets b back?
02:42:15 <copumpkin> instead of before b
02:42:22 <Axman6> ha, i proposed exactly this earlier today: http://hackage.haskell.org/packages/archive/semaphore-plus/0.1/doc/html/Control-Concurrent-Util.html
02:42:38 <Axman6> except, i had it as withQSem :: QSem -> IO a -> IO a
02:43:33 <malcolmw> copumpkin: no, a`seq`b is now defined purely denotationally, so that _|_`seq`b = _|_
02:44:23 <malcolmw> copumpkin: if the compiler can see that a will be evaluated in a bottom-preserving fashion _at_some_point_, then it can re-order the computation any way it likes
02:44:58 <copumpkin> but the difference from the previous definition is that the compiler could evaluate b, save the result, evalute a, and then return b, assuming a was not bottom
02:45:12 <copumpkin> ?
02:45:15 <malcolmw> in particular, it can fully evaluate b first, then touch a, yes
02:45:37 <copumpkin> cool, thanks :)
02:45:48 * malcolmw does not think it is a useful behvaiour
02:46:18 <malcolmw> it can make it harder to fix space-leaks
02:46:26 <copumpkin> ah
02:50:05 <quicksilver> copumpkin: in particular if it knows that a is not bottom, it can ignore a completely.
02:50:28 <quicksilver> copumpkin: it does not have to reduce a to whnf - as long as it knows it's not bottom.
02:50:53 <quicksilver> it might seem that the only way to tell if a is _|_, in general, is to try to evaluate to whnf.
02:51:05 <quicksilver> and whilst that is, in a sense, the only *general* way
02:51:18 <quicksilver> it doesn't exclude that for some particular a you may simply know it's not _|_.
02:51:25 <quicksilver> because of some strictness property you've proved, for example.
03:04:54 <Taejo> is there a more elegant way to write | day (ps@(p:ps')) = [ps, p:day ps'] | (perhaps using the list monad)
03:05:29 <Taejo> oh, nevermind, that function is wrong
03:07:10 <Taejo> I want a function that drops each element: e.g., f "abc" = ["ab", "ac", "bc"]
03:07:23 <Taejo> or possibly the reverse of that
03:12:25 <lilac> in an expression involving a number of seq's, the compiler is entirely at liberty to perform all the forcing only after it's computed the result, correct?
03:13:54 <zipMe_> Hello, I am trying to write a Haskell program that reads stdin byte per byte, but because of lazy IO nothing happens, I've tried adding `seq` here and there to no avail. How do one do this ? Thanks
03:15:53 <poe_> ?docs System.IO
03:15:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
03:16:06 <poe_> zipMe_ - check out BufferMode
03:16:12 <dschoepe> @type hSetBuffering
03:16:13 <lambdabot> Not in scope: `hSetBuffering'
03:16:27 <zipMe_> @poe: yeah I tried line and no buffering
03:16:28 <lambdabot> Unknown command, try @list
03:17:14 <poe_> might also be interesting to try 'intract' ?
03:17:51 <blueonyx> :t intract
03:17:53 <lambdabot> Not in scope: `intract'
03:17:58 <blueonyx> :t interact
03:17:59 <lambdabot> (String -> String) -> IO ()
03:18:44 <zipMe_> here what I had : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8181#a8181
03:19:45 <Saizan> hGet doesn't use lazy IO
03:20:45 <Saizan> zipMe_: what are you seeing, and what are you expecting?
03:22:27 <zipMe_> @Saizan : I am feeding a big PSD file to the haskell binary, it should run for at least 2 seconds on my machine (C timings), and write the data to another file, but it runs in close to 0 seconds, clearly laziness is trumping me here
03:22:27 <lambdabot> Unknown command, try @list
03:23:12 <lilac> zipMe_: you read data iff stdin is at EOF
03:23:28 <lilac> swap over the branches of your if and you might get further
03:23:29 <mmorrow> lilac: the definition technically implies that this would be a valid implem for seq:
03:24:14 <zipMe_> @Saizan: $ ghc --make -o read_stdin_hs read_stdin.hs
03:24:15 <zipMe_> [1 of 1] Compiling Main             ( read_stdin.hs, read_stdin.o )
03:24:15 <lambdabot> Unknown command, try @list
03:24:15 <zipMe_> Linking read_stdin_hs ...
03:24:15 <zipMe_> $ time cat test.psd | ./read_stdin_hs
03:24:15 <zipMe_> "DONE"
03:24:16 <zipMe_> real	0m0.005s
03:24:17 <zipMe_> user	0m0.001s
03:24:19 <zipMe_> sys	0m0.005s
03:24:32 <mmorrow> seq a b = magicEvalThis b `magicDoBefore` if (magicCheckIfUndefined b) then b else a
03:25:20 <lilac> zipMe_: also, you'd be better off if you produced the list forwards rather than in reverse
03:25:28 <zipMe_> @lilac: ooopsy, looks like the ticket, thanks
03:25:28 <lilac> (that way you could start printing it before you finished reading it in)
03:25:28 <lambdabot> Unknown command, try @list
03:26:14 <mmorrow> so you could actually evaluate `b', *then* check if `a' is undefined
03:26:16 <mmorrow> (and this evaluation is happening at the point where something tries to evaluate `b')
03:26:40 <mmorrow> "The function seq is defined by the equations: seq _|_b = _|_; seq a b = b, if a /=_|_"
03:27:00 <zipMe_> @lilac: what do you suggest ?
03:27:00 <lambdabot> Unknown command, try @list
03:27:18 <vav> Taejo: if that select from earlier was in Data.List then day could be 'map snd . select'
03:27:20 <lilac> zipMe_: something like: loop = do eof <- isEOF; if eof then return [] else do { head <- hGet stdin 1; tail <- loop; return (head : tail) }
03:27:25 <vav> >  let day = let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in map snd . select in day "abc"
03:27:26 <lambdabot>   ["bc","ac","ab"]
03:27:39 <zipMe_> lilac: ok , thanks, I'llgive that a whirl
03:27:40 <Saizan> lilac: that won't start printing any sooner
03:27:43 <lilac> zipMe_: or hGetContents or similar
03:27:52 <vav> Taejo: but that's not the elegant you were after methinks
03:27:58 <lilac> Saizan: oops, right you are :)
03:28:02 <Saizan> (unless you do use lazy IO there)
03:28:17 <doserj> > let f [] = []; f (x:xs) = xs:map (x:) (f xs) in f "abcd"
03:28:19 <lambdabot>   ["bcd","acd","abd","abc"]
03:28:31 <Taejo> vav: not particularly
03:28:35 <vav> hehe
03:28:37 <Taejo> what is select?
03:28:43 <Taejo> oh, right
03:28:58 <Taejo> doserj: that's exactly what I have :)
03:29:08 <doserj> I guessed so :)
03:29:09 <zipMe_> Saizan: so how do I copy that data byte per byte without loading it all in memory
03:29:53 <lilac> mmorrow: it could be even worst than that, i think. it could say: seq a b = unsafePerformIO (pushOntoSeqList a >> return b), and then IO contexts which evaluate pure values could say "pushAllOnSeqList" afterwards
03:30:14 <lilac> mmorrow: that is, the actions of 'seq' can be arbitrarily delayed
03:30:33 <Saizan> zipMe_: you write them out in the same loop in which you read them
03:30:43 <Saizan> zipMe_: however, why byte per byte?
03:31:01 <zipMe_> Saizan: oh no good reason, just curiosity
03:31:54 <Saizan> another option is to use threads and a Chan, but a writeChan for every byte seems like too much overhead
03:32:12 <Saizan> in chunks it should be sane
03:33:04 <zipMe_> Saizan: yes it's a lots faster :)
03:35:11 <zipMe_> Saizan: yep reading and writing in the same loop is a lot better thanks!
03:35:53 <Saizan> zipMe_: np :)
03:37:43 <mmorrow> zipMe_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8182#a8182
03:38:40 <zipMe_> mmorrow: thanks, I'll give it a whirl too, will let you know if it's faster than mine :)
03:38:53 <mmorrow> zipMe_: you can match cat (by 99%) if you just foreign import malloc/read/write, but not sure if you want to go there :)
03:39:22 <mmorrow> i have a version of that too somewhere floating around
03:39:57 <mmorrow> (and you'd using fd's too instead of Handles)
03:40:03 <zipMe_> mmorrow: my FFI-fu is weak... but if someone post it, I'll definitely take a look
03:42:17 <Saizan> Data.ByteString.Lazy.writeFile "foo" =<< Data.ByteString.Lazy.getContents <- probably quite fast.
03:45:07 <zipMe_> mmorrow: yes your version is reaaly fast, but copying 4K blocks rather than bytes
03:45:29 <zipMe_> Saizan: I'll try that too !! :)
03:45:46 <mmorrow> zipMe_: this one's probably effectively as fast as the ffi one (also, i can't seem to find the ffi one at the moment :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8182#a8183
03:46:24 <mmorrow> zipMe_: oh, it you're copying bytes, you probably definitely want to use the mutable buffer version
03:46:27 <mmorrow> s/it/if/
03:46:43 <mmorrow> like in that prev paste
03:46:53 <mmorrow> (and that one takes the bufsize as a param too)
03:47:14 <mmorrow> and the nice thing is it still uses HAndle
03:47:17 <zipMe_> mmorrow: ok great, I'll try that then, thanks a lot guys
03:47:22 <mmorrow> np
03:48:07 <mmorrow> zipMe_: why are you copying a byte at a time (out of curiosity)
03:48:09 <mmorrow> ?
03:48:40 <zipMe_> mmorrow: just idle curiosity, to compare IO in different languages
03:49:17 <zipMe_> mmorrow: I mean to compare IO speed
03:49:26 <mmorrow> zipMe_: ah, as i suspected! :) i think that's going to be a skewed comparison with C and Haskell copying only a single byte at a time
03:50:55 <zipMe_> mmorrow: yes my version is 4 times slower, gambit schme is really close to C on that one, I'll try your mutable buffer snippet though
03:51:09 <mmorrow> since with C, there's literally no allocation overhead per char (well, in your code that is, maybe in FILE, (unless you're using an fd) but not counting that), whereas the haskell version i'd bet allocates at least one byte per loop, most probably a lot more
03:51:26 <dibblego> is there a radians to degrees?
03:52:22 <mmorrow> zipMe_: so you'd probably be testing the overhead of calling the C functions your C version is using from haskell with the haskell version
03:52:56 <HugoDaniel> im trying to call an update callback in glut, that runs inside my monad (the display callback is IO(), and my monad is M (StateT s IO)
03:52:56 <mmorrow> (which is an interesting test)
03:52:58 <HugoDaniel> how do i do it ?
03:53:08 <mmorrow> but i'm not sure what it says about IO speed
03:53:24 <doserj> dibblego: (*(180/pi)) ?
03:53:28 <zipMe_> mmorrow: yes I don't expect Haskell to beat C, I mean it's a pretty dumb experiment really :)
03:54:11 <zipMe_> mmorrow: but I've already learnt a few things
03:54:12 <Saizan> HugoDaniel: monadic tunneling
03:54:19 <mmorrow> zipMe_: :) (also i'm not defending haskell or anything, just mentioning that it may be a flawed benchmark depending what you're after (and i could be dead wrong too :))
03:54:29 <Saizan> HugoDaniel: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
03:54:52 <zipMe_> mmorrow: you don't need to defend Haskell, otherwise I wouldn't be here :)
03:55:07 <HugoDaniel> thanks saizan :D
03:55:16 <mmorrow> bad word choice on my part, but yeah :)
03:55:17 <zipMe_> mmorrow: I'm just doing this to learn
03:55:19 <HugoDaniel> ill read it, and post my doubts here ehehehe :)
03:55:23 <mmorrow> zipMe_: cool
03:58:00 <mmorrow> zipMe_: err, i forgot to remove one of those "Int"s from the typesig of copy.
03:58:02 <mmorrow> .
03:58:52 <zipMe_> mmorow: spotted, thanks, I'm trying it now
04:02:01 <Taejo_> any ideas why I'm getting "unknown package: cairo-0.9.12.1" when trying to load diagrams? I have "Loading package cairo-0.9.13 ... linking ... done." and "Loading package diagrams-0.2 ... linking ... done."
04:02:03 <Taejo_> cairo-0.9.13 is the only version of cairo install
04:02:03 <Taejo_> *installed
04:02:41 <Taejo_> never mind, had to do cabal clean in diagrams directory
04:04:06 <mmorrow> zipMe_: in case you tried `copy', it didn't typecheck, fixed http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8182#a8184
04:06:29 <zipMe_> mmorrow: in copy sz hi ho, sz in the number of bytes, right ?
04:06:39 <mmorrow> yeah
04:07:21 <mmorrow> (although Handle's buffering seems to interfere with "./Squirt < /usr/share/dict/words > /dev/null" even with NoBuffering)
04:08:07 <mmorrow> iirc Handle doesn't actually do no buffering with NoBuffering, just line buffering still (or something along these lines)
04:08:08 <shapr> bos: you called?
04:08:52 <zipMe_> mmorrow: it's twice faster than my orginal one and only twice slower than C, pretty good :)
04:09:02 <mmorrow> zipMe_: nice
04:09:22 <zipMe_> mmorrow: I could never have written copy myslef though, so I'm going to peek into it, thanks again :)
04:09:43 <mmorrow> it matches cat with a buffer size of (16*4086)
04:10:06 <mmorrow> and gets somewhat close with (8*4096)
04:10:24 <zipMe_> mmorrow: good enough for me !
04:23:25 <fbru02> morning ! im having trouble with pattern matching i think , im encountering this in RWH let ((d, _): _) = readHex [a,b] , the meaning of that is that d will get the first value (of the tuple) of the head of the list which will be given by readHex [a,b]?
04:24:46 <Beelseboab> that's correct
04:25:38 <Beelseboab> @type readHex
04:25:39 <lambdabot> forall a. (Num a) => String -> [(a, String)]
04:26:10 <Beelseboab> oh, it's a reads type
04:26:49 <Taejo_> in diagrams, is it possible to scale a shape to fit a certain rect, rather than by a certain factor (equivalently, to find the width and height of a diagram)
04:26:53 <Beelseboab> if you want to read the value of the whole string (and exect it all to be hex), use [(d,[])] = ...
04:31:36 <fbru02> Beelseboab thanks !!!
04:37:18 <hackagebot> MonadCatchIO-transformers 0.0.1.0 - Monad-transformer version of the Control.Exception module (AriePeterson)
04:52:16 <maxote> the Haskell grammar is very complicated
04:57:03 <louzer> how does one write an empty list using s, k and i combinators?
04:59:04 <lament> louzer: http://www.madore.org/~david/programs/unlambda/#howto_lists
05:13:24 <Fairweather> if there is anyone here who has read RWH recently, I would like to ask them a question
05:14:39 <abbe> louzer: hi
05:14:49 <louzer> hi
05:14:53 <abbe> louzer: haskelling :-)
05:15:01 <louzer> no :(
05:15:37 <louzer> scheme still feels more writable than haskell
05:15:43 <abbe> okay.
05:15:49 <abbe> but, scheme is not pure.
05:22:57 <louzer> lament: thanks. but still puzzled.. with the unlambda authors suggestions.
05:26:11 <louzer> brb
05:30:33 <harlekin> @pl (foo >>= \a -> bar >>= \b -> return (a:[b]))
05:30:33 <lambdabot> (`fmap` bar) . (. return) . (:) =<< foo
05:32:06 <ksf> Fairweather, just ask
05:32:53 <ksf> unlambda is impure you shoult try http://homepages.cwi.nl/~tromp/cl/lazy-k.html ...
05:34:11 <Fairweather> thanks, ksf; i'm trying to figure out the barcode chapter and there is something th
05:34:21 <Fairweather> *that looks like an error
05:34:59 <harlekin> @t let a = undefined :: IO (IO (Maybe String)) in map join [a,a,a]
05:35:00 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:35:12 <harlekin> @t map join
05:35:12 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:35:18 <harlekin> Ah. Sorry. ^^
05:35:22 <harlekin> @type map join
05:35:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (m a)] -> [m a]
05:35:32 <ksf> Fairweather, what part? rwh has been throughly cross-read, so I'm a bit doubtful...
05:35:40 <Fairweather> we're given the bit sequence which is supposed to represent a part of a barcode but it doesn't make any sense
05:36:05 <harlekin> @type [,,]
05:36:07 <lambdabot> parse error on input `,'
05:36:12 <harlekin> @type []
05:36:13 <lambdabot> forall a. [a]
05:36:16 <harlekin> @type (:)
05:36:17 <lambdabot> forall a. a -> [a] -> [a]
05:36:32 <Fairweather> if you go to the book's page you can find it by looking for "runLenth bits"
05:36:39 <Fairweather> "runLength bits"
05:37:46 <Fairweather> but anyway, if noone else has read the chapter recently, I'll just send a bug report
05:38:05 <ksf> isn't that just an example?
05:38:11 <harlekin> @hoogle [m (t a)] -> m [t a]
05:38:12 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
05:38:12 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
05:38:12 <lambdabot> Distribution.Simple.Utils wrapLine :: Int -> [String] -> [[String]]
05:38:26 <harlekin> @src join
05:38:27 <lambdabot> join x =  x >>= id
05:39:03 <Deewiant> ?ty sequence
05:39:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:39:09 <Fairweather> well yes, but it's a bad example to get wrong
05:39:13 <harlekin> Uh, thank you, Deewiant.
05:39:25 <Deewiant> No problem
05:41:50 <ksf> Fairweather, 7 is 0101111 , not 0111011
05:41:55 <ksf> still, something's fishy.
05:43:09 <Fairweather> it is 0111011 according to both wikipedia and the book (p. 271)
05:43:44 <ksf> well but that's the 8th index in the list...
05:44:11 * ksf should start to count at 0.
05:45:01 <Fairweather> :P
05:45:22 <pozic> I thought 7 was 0000000000000111.
05:45:40 <pozic> But you can map 7 to 1010101 to, if you want.
05:46:08 <Fairweather> thank you, pozic
05:46:45 <Valodim> by counting the total amount of 0s and 1s in the number?
05:46:58 <pozic> 2^0 + 2^1 + 2^2 = 7
06:18:13 <DrSyzygy> How do I know which version of base I'm working with?
06:18:36 * DrSyzygy is trying to upload a Cabal package to Hackage...
06:20:39 <stianhj> DrSyzygy: cabal info base .. ?
06:21:24 <stianhj> worked for me
06:23:28 <DrSyzygy> ahhhh
06:23:38 <DrSyzygy> Nope.
06:23:43 <DrSyzygy> My version of cabal doesn't implement info.
06:24:17 <ksf> ghc-pkg list
06:25:22 <hackagebot> Operads 1.0 - Groebner basis computation for Operads. (MikaelVejdemoJohansson)
06:25:53 <DrSyzygy> Hah!
06:26:38 <jpcooper> hello
06:27:08 <jpcooper> I've been trying to write a chat server in Haskell, but I get the constant idea that I'm "doing it wrong". Could anyone direct me to some guides on server design with functional languages?
06:27:34 <quicksilver> jpcooper: you're doing it wrong.
06:27:41 <jpcooper> damn it
06:28:34 <jpcooper> no but seriously
06:28:44 <quicksilver> :)
06:28:50 <quicksilver> no. I don't know of any such guids.
06:29:28 <jkff> However, googling for "server in haskell" will lead you to some very interesting papers about building fast servers in haskell.
06:29:41 <jpcooper> thanks
06:29:42 <quicksilver> I don't really think it's a general functional programming
06:29:56 <quicksilver> the specifics of building servers in haskell is more about haskell's thread model
06:30:02 <quicksilver> fork two threads per socket
06:30:03 <jpcooper> well I'm fine with Haskell
06:30:06 <jkff> This paper is cool http://www.cis.upenn.edu/~stevez/papers/LZ07.ps
06:30:06 <kynky> sessions plugin allows a fixed well defined communication protocol to be used
06:30:09 <quicksilver> communicate with chans
06:30:16 <quicksilver> (or mvars, or stm)
06:30:17 <mux> yeah, it's more about being able to forkIO and use forever :-)
06:30:24 <dcoutts> DrSyzygy: cabal install cabal-install  :-)
06:30:47 <DrSyzygy> dcoutts: Yeah yeah...
06:30:49 <DrSyzygy> :-)
06:31:00 <ksf> well, there's always happs.
06:31:01 <jpcooper> quicksilver, why two threads?
06:31:18 <philed> Anyone had any luck using the Sexpr library? I've cabal installed it but it's telling me that there are files missing in the package and it failed to load interface for Codec.Sexpr.Parser.
06:31:26 <ksf> dunno what the happstack guys did, but last time I looked, it used the same base types for a web- and mailserver.
06:31:42 <ksf> ("mailsevrver" being a send-only mta)
06:32:01 <dcoutts> philed: are you sure that module is provided by that package? ghc-pkg describe Sexpr  should list it
06:33:32 <jpcooper> I might just look at how servers are made generally
06:33:48 <ksf> http://ertos.nicta.com.au/publications/papers/Klein_EHACDEEKNSTW_09.pdf  hell freezes over.
06:33:52 <jpcooper> I don't know why I'm so reluctant to read people's code as opposed to reading books about coding
06:34:41 <jpcooper> ksf, that's so like yesterday
06:35:09 <ksf> posted on ltu 2009-08-14 01:20
06:35:15 <ksf> ...dunno what timezone, though.
06:35:55 <quicksilver> jpcooper: one to read, one to write.
06:36:17 <quicksilver> jpcooper: otherwise you get caught out by IO buffering and deadlock
06:36:20 <quicksilver> (schoolboy error)
06:36:45 <quicksilver> you will find that "how servers are made generally" will tend to talk about select() or epoll() or suchlike.
06:37:03 <quicksilver> haskell is unusual in that it recommend threads (and uses select() behind the scenes to implement efficient thread IO)
06:37:08 <ksf> sendfile!
06:37:08 <philed> dcoutts: It says it can't find it.
06:37:26 <quicksilver> sendfile is a good answer for a particular question yes.
06:37:30 <quicksilver> I doubt it's a good answer to a chat server.
06:37:39 <dcoutts> philed: ok so the package isn't registered at all
06:37:55 <jpcooper> oh so I shouldn't use a single thread for both?
06:37:56 <philed> Sorry, it's supposed to be all lower case.
06:37:57 <dcoutts> philed: try installing again and look out for any error messages that indicate it failed
06:38:03 <dcoutts> philed: ah yes
06:38:13 <philed> The exposed module is Codec.SExpr
06:38:15 <jpcooper> I guess I should make two channels for each as well
06:38:21 <ksf> jpcooper, one thread per connection, at least.
06:38:24 <jpcooper> I mean one channel for each thread
06:38:46 <ksf> splitting that into read/write again could generate headaches...
06:38:49 <philed> dcouts: But then it says when I try to import Codec.Sexpr that it failed to load the interface for Codec.Sexpr.Parser
06:38:58 <philed> dcouts: There were no errors on installation.
06:39:05 <jpcooper> ksf, how come?
06:39:07 <ksf> but then the net is async, anyways.
06:39:10 <dcoutts> philed: ahh ok, that does sound like a but in the package description
06:39:42 <dcoutts> philed: you can fix it, do cabal unpack $pkgname; cd $pkgname-ver/;
06:39:45 <ksf> that is, there are protocols with more and protocols with less synchronisation points.
06:40:00 <dcoutts> philed: then edit the .cabal file, and add Codec.Sexpr.Parser to the list of 'other-modules: '
06:40:28 <dcoutts> philed: then do "cabal install" and it'll build & install that locally modified version
06:40:39 <philed> dcouts: It's already there.
06:41:10 <dcoutts> philed: it's already listed in other-modules? hmm, that is odd
06:43:04 <dcoutts> philed: sounds like somehow a file didn't get installed, I'd try installing again with detailed logging output and see if it is or is not copying Codec/Sexpr/Parser.hi to the target dir
06:52:50 * ksf hopes that there are enough l4-fanboys that realise that it'd be a good idea to provide an interface to eat linux drivers to make using their kernels feasible in practice.
06:54:06 <philed> dcoutts: Okay, I fixed it. There was a directory and three .hi files missing. Thanks for your help!
06:54:40 <dcoutts> philed: do you know what was going wrong in the first place? did re-installing the package fix it?
06:55:20 <kfish> ksf, like l4linux perhaps?
06:55:28 <philed> dcouts: It appears that it fails to copy over a directory from build to .cabal/lib/sexpr/ghc*
06:55:45 <ksf> 50 years after hurd 1.0 has become a running gag, I think it's about time for microkernels.
06:55:54 <dcoutts> philed: does it do that consistently?
06:56:04 <philed> dcoutts: Yes. I've reinstalled several times now.
06:56:34 <kfish> ksf, hurd was never in the running :-)
06:57:14 <dcoutts> philed: what versions does cabal --version report? and what version of sexpr, I'll try and reproduce it
06:57:47 <philed> 1.6.0.3 for the Cabal library. 0.6.2 for cabal-install.
06:58:30 <philed> I'm going to try bootstrapping cabal-install.
07:00:56 <philed> dcoutts: I should be completely up to date, but it's still failing to copy those directories.
07:01:20 <dcoutts> philed: it'd also be interesting to try runghc Setup configure --user; runghc Setup build; runghc Setup install -v3
07:03:24 <kfish> ksf, btw http://wiki.ok-labs.com/FAQ (speaking of linux support etc)
07:03:52 <dcoutts> philed: sexpr-0.2.1 right?
07:04:47 <philed> dcoutts: Yeah.
07:05:07 <philed> dcoutts: Even after a manual install it's not working.
07:06:27 <ksf> well I'm more worried about the large numbers of existing linux device drivers than the linux api
07:07:00 <philed> dcoutts: Unfortunately, I'm not familiar with cabal's configure scripts at the moment.
07:07:07 <ksf> (which is quite much the same as any unix, anyway)
07:08:45 <ksf> True Programmers only need open, close, mmap and exit, anyways.
07:11:02 <philed> dcoutts: Hmm...it's still not working. Copying those .hi files just meant it could read the interfaces. It still won't load the package though.
07:12:14 <Twey> *Real* Programmers only need SUBNEG
07:12:25 <dcoutts> philed: there also needs to be the libHSsexpr-0.2.1.a for ghc --make and HSsexpr-0.2.1.o for ghci
07:12:45 <philed> dcoutts: Yeah, I've got both.
07:13:00 <quicksilver> *REAL* programmers just need a butterfl
07:13:01 <quicksilver> y
07:13:24 <dcoutts> philed: ahh!
07:13:30 <ksf> *Real* Programmers taught oleg.
07:13:33 <dcoutts> philed: I can reproduce it but I can also see the problem.
07:14:05 <dcoutts> philed: the other modules are not listed for the *library* (though they are listed for the 'sexpr-test' exe)
07:14:30 <philed> dcoutts: Ah yeah.
07:15:31 <dcoutts> philed: so someone should ping the maintainer. There's also an open Cabal ticket on it not detecting this mistake (but it's a little hard to fix).
07:16:01 <mightybyte> Is there any particular reason gtk2hs isn't in hackage?
07:16:12 <dcoutts> mightybyte: it doesn't build using Cabal yet
07:17:54 <mightybyte> dcoutts: Ok thanks.  Just curious.
07:18:47 <dcoutts> mightybyte: there are various details why it's not cabalised yet, but it's mostly time and effort to improve cabal and change various things in gtk2hs and how it builds
07:18:57 <philed> dcoutts: Awesome! It works. Now that I think about it, last time I was browsing how to write cabal build files, I remember them mentioning something like this as a common mistake.
07:19:13 <mightybyte> dcoutts: Ahh, interesting.
07:19:25 <dcoutts> philed: aye, I'm just thinking about a quick-and-dirty check
07:19:37 <dcoutts> like parsing the output of ghc -M
07:27:33 <mightybyte> Is it just me or has the traffic here in #haskell decreased recently?
07:27:47 <dcoutts> mightybyte: holidays?
07:28:40 <mightybyte> No idea.  I don't know if it's reality or some inconsistency in my perception.
07:28:57 <ksf> dcoutts, shouldn't that increase traffic?
07:29:10 <ksf> ...and aren't there always holidays, somewhere?
07:29:12 <jpcooper> I thought holidays meant more opportunity to waste time on computers
07:29:13 <dcoutts> not if they're away
07:29:19 <Igloo> ksf: Not if uni students create most of the traffic
07:29:20 <quicksilver> well, lots of people in here regularly are IRCing from work or from a university
07:29:49 <edwardk> mightybyte: if it'll make you feel better i can start rambling on about kata or category theory
07:30:06 <pikhq> ... You mean most university students don't sit in IRC during the summer?
07:30:17 <jpcooper> <---
07:30:23 <mightybyte> edwardk: lol
07:30:29 <quicksilver> @losers
07:30:30 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 15 (2.6%)
07:30:32 <pikhq> jpcooper: ^5
07:30:35 <quicksilver> pikhq: they still sit here, mostly.
07:30:38 <quicksilver> pikhq: but they talk less.
07:30:48 <pikhq> quicksilver: Bu...But I talk more!
07:30:50 <quicksilver> the actual channel size is only down 10% or so.
07:30:58 <jpcooper> actually I have found a great occupation for my summer
07:30:59 <pikhq> Less distraction from "friends" and "classes".
07:31:04 <hzap> just say something and hope people will notice and start talking
07:31:05 <jpcooper> host strangers in my house with couch surfing
07:31:11 * Igloo fails to find any live traffic graphs
07:31:18 <pikhq> Well, I'm distractred from "work", so.
07:33:18 <quicksilver> Igloo: there's don's IRC stats thing
07:33:25 <quicksilver> Igloo: but it doesn't quite have a graph of that form.
07:33:27 <fbru02> jpcooper how is the couch surfing thing going on ? is it fun , anyone interesting ?
07:34:08 <jpcooper> fbru02, yes, rather. I've had a couple of interesting people over. One was a maths lecturer from Uruguay over in Scotland to give a talk on graph theory
07:34:34 <fbru02> from Uruguay ? Im from Uruguay ! :)
07:34:46 <quicksilver> Igloo: looks like it's only yearly not monthly
07:34:46 <jpcooper> ahah
07:35:14 <fbru02> we Uruguayans are invading the field !
07:35:37 <jpcooper> evidently
07:36:47 <fbru02> jpcooper nice , if i put my house in couch surfin maybe SPJ will come :P
07:36:59 <jpcooper> one can only wish
07:37:18 <jpcooper> you might like to try for a PhD at Microsoft Research in Cambridge
07:38:00 <fbru02> jpcooper you know graduate college is not my thing
07:57:54 <gwern> as far as channel traffic goes, I've noticed an apparent concurrent drop in the length of the HWN
07:58:07 <gwern> which says the drop is also in the MLs and hackage and blogosphere
07:58:25 <gwern> end of summer blues?
07:58:54 <edwardk> gwern: people getting ready for icfp, end of summer, no new batch of students yet, general ennui, etc.
08:03:35 <burp> @hoogle when
08:03:36 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:05:39 <jpcooper> I wish the ICFP workshops weren't so bloody expensive for students
08:18:36 <jmcarthur_work> it's nice to see formal methods getting a slightly higher than normal amount of attention these last couple days
08:19:00 <Axman6> NICTA++
08:41:36 <ksf> jmcarthur_work, you mean people read the abstract and conclusion of papers even though their title mentions "formal"?
08:51:07 <galdor> am I the only one for whom vacuum-opengl and vacuum-cairo fail to install?
08:51:49 <galdor> vacuum-opengl yield compilation errors while vacuum-cairo tells it requires "It requires cairo -any, gtk -any
08:51:55 <galdor> and svgcairo -any" and it can't find them
08:53:11 <dcoutts> galdor: you need gtk2hs
08:53:40 <galdor> ok, but since I'm using cabal install, why can't it install it as dependency ?
08:54:03 <lilac> it's not packaged appropriately (yet)
08:54:32 <galdor> so I got to install it manually ?
08:55:12 <glguy_> or via your package manager
08:55:52 <galdor> that's a pity, I'll wait until it gets cabalized
08:55:55 <galdor> thank you anyway :)
08:56:11 <Axman6> could be some time
08:56:46 <galdor> I was just curious about vacuum, that's all
08:56:51 <galdor> I dont need it
08:58:27 <mmorrow> what system are you on?
08:58:28 <ksf> gtk2hs has always been an odd ball, mostly due to the fact that all that gtk oo-stuff is vastly non-trivial.
08:58:32 <mmorrow> galdor: OS
08:59:12 <dcoutts> ksf: and it's an old and large project which had to make its own complex build system a few years prior to the development of cabal
08:59:58 <galdor> mmorrow: OS? what do you mean?
09:00:06 <mmorrow> galdor: what operating system?
09:00:10 <mmorrow> (are you on?)
09:00:34 <galdor> oh, archlinux
09:00:37 <mmorrow> galdor: if you happen to be on linux
09:01:11 <mmorrow> galdor: nice, i have an alternate vacuum-gl that should (hopefully) work for you then
09:01:13 <galdor> it's packaged but I'm not sure I want to mix cabal-installed packages with pacman-installed packages
09:01:18 <dino-> http://aur.archlinux.org/packages.php?ID=14890
09:01:26 <dino-> yeah, I just found it in AUR
09:01:48 <dino-> I think it's ok to do that.
09:01:50 <mmorrow> galdor: it's not on hackage though, but you can get the darcs repo
09:01:54 <mmorrow> galdor: http://moonpatio.com/repos/vacuum-gl/
09:02:01 <dino-> use pacman or yaourt when you can
09:02:16 <galdor> mmorrow: ok, gonna give it a try
09:02:24 <galdor> dino-: I had problems in the past by mixing...
09:02:34 <dino-> galdor: oh really? What happened?
09:02:55 * ksf uses emerge for ghc, cabal-install and gtk2hs and cabal for the rest.
09:03:03 <galdor> ghc freaked out about packages it didn't know, something like this
09:03:08 <dino-> I figure how much trouble can you get in considering that anything you do with pacman can be removed cleanly.
09:03:12 <galdor> so now it's ghc+cabal-install, then cabal only
09:03:35 <dino-> hm, that smells like bad packaging. It's supposed to register with ghc
09:03:54 <galdor> mmorrow: Setup.lhs: At least the following dependencies are missing:
09:03:55 <galdor> GLUT -any, OpenGL -any, vacuum >=0.0.95
09:04:00 <mmorrow> galdor: (that pkg assumes you have graphviz-devel or whatever that C pkg may be called)
09:04:10 <mmorrow> galdor: you don't have opengl?
09:04:25 <galdor> and yes these packages are installed
09:04:37 <mmorrow> galdor: how are you trying to build/install?
09:04:45 <galdor> juste configure :)
09:04:58 <mmorrow> ./Setup configure # ?
09:05:18 <galdor> [galdor@valhala ~/src/vacuum-gl] 3411 % runghc Setup.lhs configure
09:05:18 <galdor> Configuring vacuum-gl-0.0.4...
09:05:18 <galdor> Setup.lhs: At least the following dependencies are missing:
09:05:19 <galdor> GLUT -any, OpenGL -any, vacuum >=0.0.95
09:05:27 <mmorrow> you'll probably need to tell cabal where you have those pkgs then
09:05:34 <ksf> uhm try cabal configure
09:05:34 * dcoutts suggests --user
09:05:36 <galdor> they were installed with cabal...
09:05:47 <ksf> ...because of exactly what dcoutts said
09:05:50 <galdor> mhh works with --user
09:05:51 <galdor> thank you
09:05:53 <mmorrow> yay
09:05:59 <dcoutts> galdor: http://haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
09:06:12 <galdor> it's funny cabal doesn't search in both system and user locations
09:06:23 <dcoutts> galdor: see the FAQ for the explanation
09:06:29 <ksf> galdor, it does, if you tell it to install on a user level.
09:06:49 <ksf> Setup.lhs by defaults tries to install globaly, so it can't use packages that are installed as a user.
09:06:54 <ksf> ...even if it knows about them.
09:07:29 <galdor> ok ok
09:07:39 <mmorrow> galdor: and the interface (unless you want to hax) is just
09:07:41 <galdor> vacuum-opengl built and installed
09:07:49 <mmorrow> ghci> :m + System.Vacuum.OpenGL
09:07:49 <mmorrow> ghci> view (Data.Function.fix (\x -> Data.Tree.Node () [x,x]))
09:07:52 <ksf> cabal should probably say "the following dependencies are in your user database, but not available globally"
09:07:53 <mmorrow> ge.g.
09:07:54 <dcoutts> galdor: runghc Setup is the old command line interface, cabal is the new. We cannot really change the default behaviour of the old one without breaking lots of stuff (like distro build scripts)
09:07:56 <galdor> Loading package vacuum-gl-0.0.4 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
09:07:56 <mmorrow> *e.g.
09:08:07 <dcoutts> ksf: we'd accept a patch along those lines
09:08:12 <mmorrow> galdor: argh! it's a linker script and ghci doesn't understand them
09:08:15 <hackagebot> boxes 0.1 - 2D text pretty-printing library (BrentYorgey)
09:08:24 <mmorrow> galdor: i made a symlink to sidestep that
09:08:41 <mmorrow> galdor: cat /usr/lib/pthread.so
09:08:41 <galdor> I got this problem with a ncurses binding some time ago
09:09:10 <galdor> yeah it's a linker script
09:09:25 <galdor> the real lib is /lib/libpthread.so.0
09:10:18 <galdor> it's a pity having to rely on a C library via a FFI :/
09:10:20 <galdor> so many problems
09:11:31 <ksf> that should be gl depending on pthreads, afaik nothing haskelly uses them.
09:12:36 <lilac> mmorrow: is it possible to make a lazy vacuum (that doesn't rnf the value)?
09:14:26 <galdor> it works perfectly with a symlink, thank you guys :)
09:14:30 <mmorrow> lilac: yes, there's actually a working version in the darcs repo for some time now, i'm just too lazy to upload it
09:14:36 <ksf> heh. "rely on a c library"... with an example program, the only thing that needs pthreads is librt, which is glibc.
09:14:36 <mmorrow> galdor: woot! nice
09:14:58 <mmorrow> ksf: that's me using pthread.h
09:15:45 <mmorrow> ksf: since i'm also using gvc.h from graphviz, and i need to get this BMP parser and the graphviz functions to talk over a pipe and they both use FILE*
09:15:47 <ksf> http://refspecs.freestandards.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/app-librt.html
09:16:14 <mmorrow> and since i'm only in a single process, i had to use pthread_create to hack my way through the problem
09:16:58 <ksf> well, that makes sense.
09:17:54 <mmorrow> ksf: the relevant code is halfway through http://moonpatio.com/repos/vacuum-gl/c/mm-gv.c
09:18:44 <ksf> I see, haskell-style commas are conquering the world
09:19:07 <ksf> (foo\n,bar\n,baz\n) , that is.
09:19:43 <mmorrow> ksf: heh, totally
09:20:06 <ksf> I should try to do it with block {;}'s, too.
09:20:14 <lilac> ksf: i've seen microsoft headers saying 'class CFoo\n: public IBar\n, public IBaz\n, public IQuux'
09:22:01 <quicksilver> I don't think it's really haskell-style
09:22:05 <quicksilver> I think it's been a common ML convention for years
09:22:11 * mux thinks it's weird :)
09:22:15 <quicksilver> in particular, with ;s
09:22:50 <ksf> it's just so obvious to do it with = and |  .
09:23:26 <ksf> it has always been done with && and || even in the c world, though.
09:24:42 <mux> I cut after binary operators in C
09:24:46 <quicksilver> I generally put operators at the ends of lines
09:24:53 <quicksilver> things like + and ++, for example
09:25:07 <mux> I know it's at least the recommended style in FreeBSD
09:25:59 <ksf> well I expect function names to be at the beginning of a line, so I also put operators there.
09:26:30 <ksf> not to mention that it's nice to have stuff line up.
09:27:35 <ksf> but then I also write foo= bar( baz );
09:27:43 <ksf> people have flamed me for it.
09:28:07 <Elly> *you're* that person?
09:28:23 <Elly> someone who worked on my current codebase used that parenthesization style and it has driven all the other hackers batty
09:28:32 <ksf> I even dare to use K&R-brace style!
09:28:39 <skorpan> foo= bar( baz ); must be the ugliest convention i've seen
09:28:40 <mux> ugh. :-)
09:28:50 <ksf> it's the most readable.
09:28:51 <Elly> I agree with skorpan on this
09:28:56 <mux> I hate people who do that with a passion
09:29:26 * Elly uses: foo = bar(baz), which she thinks of as the 'standard' style
09:29:39 * mux nods
09:29:47 <ksf> that's just no proper zen.
09:29:48 <mmorrow> space inside the parens like that makes me crazy too :)
09:29:55 <ksf> the balance of void (spaces) is just way off.
09:30:05 <mux> I always thought of putting space inside parens as GNU style somehow
09:30:17 <mux> I may be wrong, but they have some freaky coding styles anyhow
09:30:28 <ksf> gnu style is that atrocious \n<halfindent>{
09:30:36 <pikhq> GNU-style is: foo = bar (baz);
09:30:43 <mux> oh, newlines before { drive me crazy too.
09:30:55 <mux> like }\nelse\n{
09:30:58 <mux> this is sick
09:31:00 <Elly> mux: agh
09:31:06 <Elly> mux: waste of vertical real estate
09:31:07 <mmorrow> mux: the default settings for "indent" are the official GNU format style iirc
09:31:10 <pikhq> Oh, and GNU style is basically "Good Lisp coding style, applied to C. Poorly."
09:31:16 <mux> Elly: fully agreed
09:31:29 <mmorrow> indent turns 1000-lines files into like 4000 lines
09:31:38 <mux> I suggest starting a holy war for C coding style - let's burn them all
09:31:40 <Cromulent> Elly: vertical real estate is limitless - why make it harder to read by putting it all on one line?
09:31:55 * mmorrow gets his pitchfork and overalls on
09:31:56 <int-e_> mmorrow: being paid by lines of code must be fun :)
09:31:57 <ksf> as if } else { is hard to read.
09:31:58 <pikhq> The GNU coding style guide is quite reasonable when you ignore the indentation stuff, though.
09:32:00 <mux> Cromulent: it definitely doesn't seem harder to read to me, I'd it's easier
09:32:00 <Elly> Cromulent: I don't buy that '} else {' is harder to read than '}\nelse\n{'
09:32:16 <Elly> Cromulent: and vertical real estate is *not* limitless; in my case, my monitor is like 12 inches tall
09:32:16 <mux> because then you can only have like 5 lines of real code per terminal screen :-)
09:32:30 <pikhq> Though, granted, the GNU coding style aside from that is essentially a list of best practices in C.
09:32:31 <int-e_> Elly: it's a matter of habit.
09:32:33 <mmorrow> int-e: too bad `indent's indempotent
09:32:41 <Elly> some people have the wrong habits :P
09:32:43 <Cromulent> Elly and mux: different strokes for different folks I guess - but it is the number one reason why I hate reading Java programs
09:32:47 * mux goes for FreeBSD's style(9) all the way
09:33:04 <ksf> a thing that works is }\nelse { and }\nelse if {
09:33:11 <pikhq> mux: Reasonable coding style.
09:33:12 <mux> which goes into some subtle details, such as sorting variables depending on sizes, etc :)
09:33:16 <glguy_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8186#a8186
09:33:16 <ksf> ...as it lines up properly with the starting if {
09:33:16 <int-e_> Elly: mind you, I'm with the  } else {  crowd.
09:33:23 <pikhq> I tend to go with straight K&R, though.
09:34:34 <Cromulent> generally speaking putting more than one brace on the same line results in hard to read code due to the fact that you can't just line the braces up to see which block is which - plus copy and pasting a particular block is made unnecessarily difficult
09:34:54 <int-e_> Cromulent: that's what indentation is for.
09:35:03 <Elly> don't copy and paste code, and use an editor that understands braces :P
09:35:20 <ksf> there's also people that don't do for(i=0;++i<20;) foo(i);
09:35:45 <int-e_> Cromulent: you don't have to match the } with the preceding {, you just look for /something/ that's indented to the same level (and isn't a label).
09:35:46 * mux puts spaces around binary operators, and one space after ; in for loops statements
09:35:46 * mmorrow likes for(i=0; i<n; i++)
09:35:59 <mux> for (i = 0; i < n; i++)
09:36:03 <Elly> I would write that as: for (i = 0; i < 20; i++)
09:36:06 <int-e_> ksf: the foo(i); goes on an extra line for me
09:36:07 <Zao> ksf: Depends on if you want your first iteration to be 0 or 1.
09:36:09 * mux hearts Elly 
09:36:10 <Elly> ==mux, yeah
09:36:14 <ksf> int-e_, yeah.
09:36:23 <mux> Elly: I could read your code without crying, it seems.
09:36:27 <Zao> As the predicate is evaluated before all iterations.
09:36:34 * mux tends to cry a lot when reading code.
09:36:38 <Zao> Elly: Your rewrite just introduced a bug.
09:36:42 <ksf> well, usually I use downwards loop anyway, out of nostalgia.
09:36:43 <int-e_> ksf: oh, ++foo < ... - yeah I wouldn't normally do that either.
09:36:46 <Cromulent> int-e_: unnecessary work if you ask me - much easier just to identify one character than it is too look for a specific area of indentation when you need to take in the context of surrounding code
09:36:54 <Elly> Zao: compared to ksf's?
09:37:09 <Elly> so it did
09:37:16 <mux> I actually don't like for() loops much, I often rewrite them to while loops
09:37:19 <byorgey> so I'm on vacation and go to a library just to get online for a few minutes, and I come to #haskell for a dose of fun, and people are talking about... where to put spaces in C code!?
09:37:27 <Zao> I would personally shun ksf for that loop.
09:37:30 <mmorrow> mux: me too
09:37:36 <Zao> It's highly non-idiomatic and will trip people over a lot.
09:37:51 <ksf> Zao, well, I use for(;;) and a case switch to emulate gotos in java, too.
09:38:03 <mux> for() is unnecessary bloat only useful for writing for (;;) because it's nicer than while (1) because C lacks real booleans :-P
09:38:03 <mmorrow> int i=-1; while(++i<n){.....}; i've started to like lately
09:38:21 <mux> well, C99 has bools though.
09:38:25 <ksf> labled blocks are a nice thing.
09:38:50 <Axman6> mmorrow: now you're just being silly
09:39:22 <mux> Axman6: I don't think he is, but I do think you're being a bit rude.
09:39:25 <mmorrow> Axman6: nuh uh!
09:39:32 <lilac> i heart c++0x: for (auto i : range(1,19)) { ... }
09:39:37 * Axman6 is starting to like 6["yo yo yo dawg"] as a way fo accessing array elements, in a sadistic kind of way
09:39:49 <mmorrow> Axman6: i'm dead serious
09:40:06 <ksf> ... for i in {1..19}; do ... done;
09:40:07 <mux> when it's about an i variable iterating, I still use for - for most other things I use while
09:40:09 <int-e_> Oh why are we having a bikeshed discussion about indenting C code anyway?
09:40:19 <mux> because we're bored, I guess
09:40:22 <quicksilver> lilac: you only think it's good because of the train wreck it replaced.
09:40:23 <Zao> int-e_: We ran out of Haskell.
09:40:29 <Zao> Time for Haskell'.
09:40:31 <lilac> quicksilver: yes :)
09:40:33 <Axman6> mux: how was i being at all rude?
09:40:48 <mux> Axman6: the word silly comes to mind :-)
09:40:49 <quicksilver> lilac: C++0x is good in the same way that sawdust is good food, if previously you have only eaten broken glass.
09:41:05 <quicksilver> it doesn't cut your mouth any more and it might even soak up the blood!
09:41:05 <Axman6> how is silly rude?
09:41:08 <mux> quicksilver: hahaha
09:41:09 <ksf> because it's hard to bikeshed haskell brace style as pontfree code is unreadable no matter how you format it.
09:41:09 <Cromulent> quicksilver: haha
09:41:20 <Axman6> it's quite a tame, lighthearted word
09:41:24 <lilac> quicksilver: since they removed concepts, c++0x is more like sawdust with termites living in it
09:41:36 <quicksilver> mmm protein.
09:41:42 * mux coughs
09:42:03 <lilac> quicksilver: oh, and in c++0x your mouth is made of wood.
09:42:11 <HugoDaniel> hmm
09:42:23 <HugoDaniel> ive been looking at this interleavableIO monad wrapper
09:42:32 <HugoDaniel> doesn't this adds a lot of overhead ?
09:42:36 <ksf> haskell' should finally come with a typechecker that mails your type errors to oleg so he can tell you whether you made a mistake or need a more powerful type system.
09:42:47 <Axman6> mux: i meant it in a pythoneqsue way, i'm sorry if you didn't get it
09:42:52 <HugoDaniel> i mean, the glut display callback should be called every other 16ms :/
09:42:53 <mux> ksf: hahaha
09:42:54 <Berengal> I'm tired of all these imperative languages messing up my mojo. Today I had to nest four for loops and three ifs with a labeled break and two labeled continues...
09:43:05 <mux> GHC: the impossible happened... send bug report to Oleg? (y/n)
09:43:11 <pikhq> [](){}(); // Valid C++0x.
09:43:15 <HugoDaniel> and interleavableIO threads the stateT (and possibly others) before calling it
09:43:32 <HugoDaniel> so, if i have a huge state, it will be adding lots of overhead to the callback
09:43:39 <Axman6> pikhq: does it actually mean anything?
09:43:39 <HugoDaniel> does ghc optimizes these kind of operations ?
09:43:43 <lilac> pikhq: (\_->())[] -- Valid haskell
09:43:44 <mux> Axman6: nevermind, I may have overreacted due to you picking on me a few days ago :-P
09:43:44 <ksf> the most important feature of h' will be that tabs are outlawed.
09:44:07 <Berengal> http://www.example.com <- valid java
09:44:15 <lilac> Axman6: it's a no-op lambda, created and called
09:44:15 <mux> ksf: and all those extensions we're constantly using shamelessly :-)
09:44:18 <pikhq> Axman6: It creates a lambda without any variables in its closure, that takes no arguments, that does nothing, and then calls it.
09:44:21 <Axman6> mux: i ony 'picked' on you because we can't have people who are wrong on the internet! :P
09:44:43 <Berengal> http://www.example.com \u000A <- invalid java
09:44:56 <lilac> pikhq: once you know what [] means, that example is pretty readable and obvious
09:45:03 <mux> it's much harder to write invalid perl
09:45:07 <Axman6> so what would that look like with variables? just out of curiosity
09:45:08 <pikhq> The lambda in question will only be deconstructed when it goes out of scope, because C++ has no garbage collection.
09:45:12 <quicksilver> HugoDaniel: the callback is not what you think.
09:45:16 <quicksilver> HugoDaniel: sorry, the overhead
09:45:20 <quicksilver> HugoDaniel: the state is only a pointer.
09:45:25 <pikhq> Axman6: Reference to variables or copy of them?
09:45:30 <quicksilver> HugoDaniel: saving one pointer for the callback is trivial compared to the overhead of an FFI call.
09:45:34 <lilac> pikhq: that's a step up from std::vector<int> foo(std::istream_iterator<int>(std::cin), std::istream_iterator<>());
09:45:40 <Axman6> pikhq: i mean how do you use the [] stuff
09:45:52 <int-e_> > (\(?)@(){}->[])$(!)
09:45:55 <HugoDaniel> quicksilver: ah, so it doesn't copy the state over, it just adjusts the pointer, smart :D
09:45:56 <lambdabot>   Couldn't match expected type `()'
09:45:57 <quicksilver> HugoDaniel: however 'huge' your state is, it's still only one pointer :)
09:46:02 <quicksilver> HugoDaniel: everything in haskell is a pointer.
09:46:06 <pikhq> [=](){} is a lambda that has a *copy* of all the variables in scope in its closure.
09:46:06 <HugoDaniel> ah nice
09:46:08 <quicksilver> HugoDaniel: nothing is really ever copied.
09:46:09 <lilac> pikhq: it's a temp, so it's destructed at the end of the full-expression
09:46:10 <int-e_> > (\(?)@(){}->[])$() -- aww
09:46:11 <lambdabot>   []
09:46:15 <HugoDaniel> thats good to know :D
09:46:15 <pikhq> And [&](){} has a reference to all of them.
09:46:15 <quicksilver> HugoDaniel: that's the advantage of immutability.
09:46:24 <quicksilver> HugoDaniel: if you know it won't change, there is no reason to copy it.
09:46:27 <pikhq> lilac: Ah, right.
09:46:31 <HugoDaniel> i have this strong desire to look at ghc code whenever i find the time to it...
09:46:50 <pikhq> [a,b,&c](){} has a copy of a and b, and a reference to c.
09:47:02 <Axman6> ah ha
09:47:05 <lilac> pikhq: but in practice i think it'll occupy zero stack space anyway, so...
09:47:08 <HugoDaniel> i just dont have the time right now :/
09:47:12 <Axman6> shit, i need to get to sleep. night all
09:47:17 <ksf> > (\(--)@(){}->[])$()
09:47:17 <mmorrow> HugoDaniel: http://moonpatio.com/vacuum/gallery/transpose.html
09:47:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:47:27 <ksf> hey that should work.
09:47:28 <EvilTerran> ksf, -- begins a comment
09:47:37 <ksf> ...unless it's an operator.
09:47:38 <Axman6> --<space> does
09:47:41 <HugoDaniel> also, monad tunneling is a very smart and simple idea that works very well in my case i guess
09:48:09 <EvilTerran> Axman6, i thought it was -- as a token on its own
09:48:10 <Axman6> you'll notice that ghc bitches if you try and use --| as a comment
09:48:25 <quicksilver> HugoDaniel: thank you. I think the boilerplate is a bit heavy, but I think it can be reduced.
09:48:31 <EvilTerran> (ie without an operator character immediately on either side)
09:48:43 * Axman6 &
09:48:45 <quicksilver> HugoDaniel: I've never actually used it, I just wrote the mail based on a week or two thinking about it :)
09:48:48 <lilac> it'd be really nice if c++0x's lambdas could specify 'please allocate this block's "stack" on the heap, and use a smart pointer to it for your closure'
09:49:04 <EvilTerran> > () --& not a comment
09:49:06 <lambdabot>   Not in scope: `comment'Not in scope: `--&'
09:49:11 <lilac> but instead we get an fundamentally broken design :(
09:49:12 <pikhq> mmorrow: WTC is that?
09:49:19 <EvilTerran> > (--) a comment
09:49:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:49:24 <HugoDaniel> quicksilver: so you are marco tlio ?
09:49:26 <pikhq> Internal representation of thunks and such?
09:49:28 <mmorrow> , replicate 3 [0..3]
09:49:29 <lunabot>  [[0,1,2,3],[0,1,2,3],[0,1,2,3]]
09:49:37 <mmorrow> pikhq: it's that ^^^^^6
09:49:46 <mux> the vim syntax file for haskell needs to be patched then
09:49:47 <quicksilver> HugoDaniel: no, I'm Jules Bean. I wrote the email he based that package on.
09:49:54 <mux> it thinks -- alone starts a comment
09:49:57 <HugoDaniel> ah ok ok :D
09:49:59 <HugoDaniel> ive seen
09:50:03 <HugoDaniel> nice, great thinking :)
09:50:04 <pikhq> mmorrow: So, it's the graph of the data structure.
09:50:20 <Berengal> > let x --| y = x + y in 5 --| 6
09:50:21 <lambdabot>   11
09:50:34 <mmorrow> pikhq: right, that's the graph formed by ptrs to closures that contain ptrs to closures
09:50:35 <mux> that's pretty cool
09:50:42 <mux> it allows to have nice --> operators :)
09:50:48 <quicksilver> pikhq: it's the graph of the representation of the data structure
09:50:49 * lilac thinks that people will start writing "auto closure = shared_ptr_new([]{ int foo; int bar; auto baz = [=closure]() { ... } });" to work around c++0x's brokenness
09:50:55 <quicksilver> pikhq: (as opposed to the denotation of it)
09:50:57 <pikhq> quicksilver: Well. Yeah.
09:50:58 <mmorrow> pikhq: http://moonpatio.com/vacuum/gallery/sequence.html
09:51:12 <quicksilver> pikhq: so it shows the sharing, which is invisible to the denotation.
09:51:15 <quicksilver> which makes it more interesting.
09:53:14 <ksf> http://moonpatio.com/vacuum/gallery/transpose.html   is much clearer imo
09:53:23 <mmorrow> pikhq: for instance, fix (0:) is just 2 ptrs + and Int
09:53:32 <mmorrow> s/and/an/
09:53:45 <mmorrow> ksf: yeah, that's my favorite one
09:54:16 <mmorrow> quicksilver's idea of using transpose
09:55:30 <quicksilver> yeah, I'm the ideas man.
09:55:35 <quicksilver> mmorrow actually does stuff.
09:55:36 <quicksilver> ;)
09:55:38 <mmorrow> heh
09:55:47 <quicksilver> evil stuff, generally.
09:55:51 <quicksilver> but clever evil.
09:56:39 * mmorrow throws a few more babies into his cauldron
10:01:04 <ksf> what does (transpose . transpose) $ replicate 4 [0..3] look like?
10:01:33 <ksf> ...I'd look myself, but vacuum-opengl fails to compile, and I didn't build gtk2hs for 6.10.4 yet.
10:03:08 <quicksilver> mmorrow: your current quote on http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html is eerily characteristic ;)
10:03:39 <hackagebot> elerea-examples 1.0.1 - Example applications for Elerea (GergelyPatai)
10:03:52 <mmorrow> uh oh
10:03:55 * mmorrow looks
10:04:13 <mmorrow> quicksilver: haha
10:06:23 <gwern> 'ski has quite a potty mouth. 0.0% words were foul language.
10:06:24 <gwern> lambdabot also makes sailors blush, 0.0% of the time.'
10:06:26 <gwern> -_-
10:07:21 <ziman> :D
10:07:41 <quicksilver> yeah, this channel is eerily polite
10:07:54 <quicksilver> this is a very uncharacteristic IRC channel in all sorts of ways.
10:07:54 <athos> i know why
10:07:57 <ManateeLazyCat> Integrate Typeable and class to solve "generic methods and speical functions for different class instance", sweet.
10:08:04 <athos> @where unsafeBadWord
10:08:08 <quicksilver> ;)
10:08:11 <lambdabot> I know nothing about unsafebadword.
10:08:14 <athos> see?
10:08:17 <athos> :)
10:08:20 <ManateeLazyCat> And simple enough and better than OOP solution.
10:08:33 <quicksilver> @remember athos  @where unsafeBadWord < lambdabot> I know nothing about unsafebadword.
10:08:34 <lambdabot> Done.
10:08:38 <Berengal> Of the ten most used words, the three non-trivial ones are haskell, think and function
10:08:51 <quicksilver> Berengal: I like the fact that 'think' is up there.
10:09:04 <Berengal> quicksilver, indeed
10:09:30 <Berengal> Although it might be semi-trivial. "I don't think[...]" etc.
10:09:36 <quicksilver> true. Still.
10:09:41 <ManateeLazyCat> copumpkin: Are there?
10:09:55 <ManateeLazyCat> @seen copumpkin
10:09:55 <lambdabot> copumpkin is in #kata, #concatenative, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah. I last heard copumpkin speak 4m 11s ago.
10:10:11 <copumpkin> yup
10:10:32 <ManateeLazyCat> copumpkin: I use Typeable integrate with class to fix my problem.
10:10:44 <ManateeLazyCat> copumpkin: And pretty.
10:10:58 <ziman> edwardk wrote the longest lines, averaging 81.2 letters per line.
10:11:13 <ziman> long and dense lines ;)
10:11:56 <Berengal> And with an average of 51 letters per line, the rest aren't bad either
10:12:17 * ManateeLazyCat pasted "Example code" at http://paste2.org/get/379560
10:12:18 <ManateeLazyCat> copumpkin: Above is example code.
10:13:46 <ManateeLazyCat> copumpkin: Now i can define speical functions for different PageBuffer instance (such as StringBuffer) and keep generic methods in PageBuffer.
10:14:07 <copumpkin> sounds good :)
10:14:11 <copumpkin> glad you figured it out
10:14:14 <ManateeLazyCat> copumpkin: And never use sub-class that inherit from PageBuffer.
10:14:30 <ManateeLazyCat> copumpkin: Thanks you and Saizan for help! :)
10:16:07 <Beelsebob> this could be interesting...
10:16:13 <Beelsebob> Haskell on 10.6
10:16:30 <ManateeLazyCat> copumpkin: If i use super-class and sub-class module, i need make declare Page like this data Page = PageType1 | PageType2 | ... | PageTypeN, then generate too many unnecessary code and make logic too complicated.
10:16:30 <Beelsebob> hope ghc doesn't moan about 64 bit libraries
10:17:07 <quicksilver> does 10.6 still ship the 32 bit versions?
10:17:14 <Beelsebob> nope
10:17:21 <Beelsebob> half of mac ports is broken for that reason
10:17:22 <quicksilver> then I thik you're SOL.
10:17:22 <ManateeLazyCat> copumpkin: If i use Typeable, i just change "class PageBuffer a where" to "class Typeable a => PageBuffer a where", then deriving Typeable in PageBuffer instance, that's so simple.
10:17:36 <quicksilver> GHC doesn't support 64-bit compilation on OSX
10:17:42 <quicksilver> although, I think, it's not too far off
10:17:43 <Beelsebob> ohhhhh fun
10:17:46 <quicksilver> people have been working on it.
10:17:52 <Beelsebob> hope they work fast
10:17:54 <Beelsebob> :)
10:17:56 <quicksilver> it's not badly broken, there are some "trivial" problems with it.
10:18:13 <copumpkin> Beelsebob: ask doublethink_work about it ;)
10:18:18 <ManateeLazyCat> copumpkin: If i need define speical functions for class instance, i just need "cast pageBuffer" to "Maybe StringBuffer".
10:18:23 <Beelsebob> well, I'm downloading the Haskell platform, we shall see what explodes when I try it
10:20:11 <athos> @hoogle isInfixOf
10:20:12 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
10:20:12 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
10:20:12 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
10:20:55 <dons> dcoutts: http://github.com/copiousfreetime/rabal/tree/master
10:20:58 <dons> rabal == Ruby Cabal.
10:23:46 <waern> dons: hah! :-)
10:24:01 <glguy_> dons: I wonder if they pronounce it "rubble"
10:24:15 <c_wraith> "rabble" would be amusing too
10:24:17 <ksf> using vacuum-cairo, I occasionally get ghci crashes that say ghc: xcb_lock.c:77: _XGetXCBBuffer: Assertion `((int) ((xcb_req) - (dpy->request)) >= 0)' failed.
10:24:22 <ziman> Ruby Architecture for Building Applications and Libraries
10:24:45 <wolverian> rabal seems more like mkcabal
10:24:50 <wolverian> than Cabal
10:24:58 <glguy_> codolio: you there?
10:25:02 <dons> reminds me to fix mkcabal
10:26:23 <dons> and this vih business makes me want to re-release yi 0.1
10:26:49 <ManateeLazyCat> dons: re-release yi 0.1 ?
10:26:57 <ManateeLazyCat> dons: rewrite?
10:27:53 <dons> release
10:28:09 <dons> yi with no emacs
10:28:15 <dons> http://www.cse.unsw.edu.au/~dons/yi.html <--
10:28:21 <dons> circa 2005.
10:29:06 <ManateeLazyCat> dons: I know yi, and it have release 0.6, and why "yi with no emacs"?
10:29:16 <ManateeLazyCat> dons: "yi with pure vi"?
10:29:28 <Nafai> No Emacs :(
10:29:33 <HugoDaniel> yi architecture is quite nice
10:30:18 <ManateeLazyCat> dons: Why yi need so many foreground? Why not just GTK?
10:31:06 <dons> the original yi was a curses-only vi clone :)
10:31:19 <dons> its really a separate system to the current yi, which is /much/ more sophisticated
10:31:38 <Nafai> What's vih?
10:31:49 <waern> http://blog.objectmentor.com/articles/2009/08/14/vih
10:32:03 * Nafai reads
10:32:06 <Nafai> Oh
10:32:08 <ManateeLazyCat> dons: I will release editor module that pure Emacs like, but not clone. :)
10:32:31 <ManateeLazyCat> dons: I will add some-feature that Emacs not.
10:32:39 <ManateeLazyCat> s/not/haven't
10:34:03 <ManateeLazyCat> dons: I think Yi project will better if it just dedicated GTK, then less limit....
10:35:37 <ManateeLazyCat> @hackage dyre
10:35:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dyre
10:36:47 <copumpkin> *Enumerable> length (enumerate :: [Ordering -> Bool])
10:36:47 <copumpkin> 8
10:36:51 <ManateeLazyCat> Have any website that post picture temporary?
10:37:21 <copumpkin> *Enumerable> length (enumerate :: [Word8 -> Bool])
10:37:23 <copumpkin> not smart :P
10:39:04 <bremner> ManateeLazyCat: http://picpaste.com
10:39:12 <Beelsebob> quicksilver: yep,      error: CPU you selected does not support x86-64 instruction set
10:39:22 <comrade`phil> o.o
10:39:24 <Beelsebob> epic fail
10:39:29 <comrade`phil> What the christ are you using?
10:39:33 <comrade`phil> a Cyrix?
10:39:39 <Beelsebob> the CPU does support it
10:39:41 <Beelsebob> GHC doesn't
10:39:45 <comrade`phil> Oh
10:39:53 <comrade`phil> Which reminds me, actually
10:39:58 <Beelsebob> OS X 10.6 doesn't have 32 bit libraries
10:40:02 <quicksilver> Beelsebob: can't quite explain that error message ;) interesting.
10:40:05 <comrade`phil> I still need to make my perpetual computation machine
10:40:06 <Beelsebob> so it appears ghc is broken atm
10:40:13 <Beelsebob> quicksilver: yeh, it's an interesting one
10:40:23 <comrade`phil> Basically you grab a cyrix, you stick a boiler on top of it as a heat sink
10:40:29 <copumpkin> Beelsebob: it's a common mac os issue :P
10:40:31 <comrade`phil> and the steam from the boiler drives a turbine
10:40:39 <comrade`phil> which generates power for the cyrix
10:40:41 <copumpkin> Beelsebob: it's basically passing -arch x86 and -m64
10:40:45 <copumpkin> or something along those lines
10:40:58 <ManateeLazyCat> bremner: How to upload picture?
10:41:15 <copumpkin> (that is, not -arch x86_64)
10:41:19 <Beelsebob> copumpkin: that could be it  the m64 will be added by default probably because 32 bit compiles are gone now
10:41:23 <MyCatVerbs> Correct me if I'm totally out of whack on this one, but I thought Data.ByteString.Lazy.concat was supposed to be, ah, coinductive?
10:41:27 <copumpkin> Beelsebob: yeah
10:41:36 <copumpkin> Beelsebob: I remember seeing a patch on cvs-ghc recently for that
10:41:41 <copumpkin> passing -m32 explicitly
10:41:48 <ManateeLazyCat> bremner: In fact, i can use my yaoddmuse.el upload picture to emacswiki.org automatically, but i don't upload my project sreenshot to emacswiki.org. :)
10:41:51 * Beelsebob grabs latest ghc-head
10:41:58 <copumpkin> like in the past couple of days
10:41:58 <Beelsebob> wait fail...
10:42:00 <Beelsebob> I need working ghc for that
10:42:04 <Beelsebob> >.<
10:42:06 <copumpkin> lol
10:43:16 <copumpkin> http://gist.github.com/167980
10:43:40 <copumpkin> whoops, not sure why I included strength
10:44:00 <MyCatVerbs> Strangely enough though, (foldr BSL.append BSL.empty) takes quadratic time in the number of input strings that I pass it. (Where BSL = Data.ByteString.Lazy).
10:44:03 <ManateeLazyCat> bremner: How to accept rule in that website?
10:44:37 * glguy_ eyes burn at yet another "How to ...?"
10:44:55 <copumpkin> glguy_: where?
10:45:07 <bremner> ManateeLazyCat: sorry don't know, just got if from the debian bot
10:45:09 <MyCatVerbs> I thought that that was supposed to be linear? Like, as in that was part of the point of using ByteString.Lazy instead of strict ByteStrings.
10:45:30 <ManateeLazyCat> bremner: I want upload my project screenshot to haskeller.
10:46:02 <ManateeLazyCat> bremner: But don't emacswiki.org even i can, if then i will accept attack from crazy emacser like me.
10:46:05 <ManateeLazyCat> :)
10:46:27 <bremner> ManateeLazyCat: put it on haskell wiki?
10:47:15 <ManateeLazyCat> I haven't register haskell.org account.
10:47:33 <bremner> life is suffering
10:48:12 <MyCatVerbs> Resultingly, right now my program runs faster with String than ByteString.Lazy. >_<
10:48:31 <quicksilver> MyCatVerbs: compiling with -O2?
10:49:14 <quicksilver> in fact, even without optimisation that should be linear in the number of input strings.
10:49:19 <quicksilver> most odd.
10:49:23 <ManateeLazyCat> bremner: I can upload picture base64-encode-string to paste2.org, then restore picture in Emacs.
10:49:50 <MyCatVerbs> quicksilver: Aye. This is what's wigging me out.
10:50:04 <MyCatVerbs> Maybe it's an optimizer bug? I should try it with -O0.
10:52:47 <MyCatVerbs> Ah, it's a bug. -O0 makes the ByteString version linear again.
10:53:13 * MyCatVerbs snocs "file bug report" onto the end of his todo list.
10:53:20 <ManateeLazyCat> http://www.flickr.com/photos/40611950@N03/3821227364/
10:53:51 <ManateeLazyCat> Above is screenshot of my project, it just editor module.
10:54:43 <ManateeLazyCat> Powerful than gedit, and have long way to exceed Emacs.
10:55:51 <MyCatVerbs> ManateeLazyCat: can't see it, permission denied. You might want to loosen that up a little. :)
10:57:02 <ManateeLazyCat> MyCatVerbs: permission denied, i never use flickr before.
10:58:19 <ManateeLazyCat> MyCatVerbs: Wait, i paste url.
10:58:35 <MyCatVerbs> ManateeLazyCat: hrmn? You pasted the URL and said it was a screenshot of your project.
10:59:06 <MyCatVerbs> I believe it was reasonable to assume that you meant for the people to whom you gave the URL to be able to see it. :)
10:59:19 <ManateeLazyCat> MyCatVerbs: http://farm3.static.flickr.com/2676/3821227364_e739332f63_o.png
10:59:44 <ManateeLazyCat> MyCatVerbs: Now?
11:00:07 <Cale> ManateeLazyCat: Don't you find that using a proportional font makes it impossible to line things up properly?
11:00:09 <ManateeLazyCat> See it?
11:00:12 <MyCatVerbs> Yep, thank you. Looks reasonably pretty.
11:00:23 <Beelsebob> wow, that's a new scale of ugly
11:00:34 <MyCatVerbs> Still. a) how the Hell can you stand to use a non-monotype font?
11:00:49 <MyCatVerbs> b) how come your CPUs are all at completely different temperatures?
11:00:58 <MyCatVerbs> c) OS X there in GNOME? Ewwwww.
11:01:12 <Beelsebob> hint for people pretending to do OS X: OS X looks good because it's pixel perfect  not because of a few simple theme bits
11:01:20 <ManateeLazyCat> MyCatVerbs: Now, in framework time, haven't handle detail
11:01:43 <MyCatVerbs> The overall effect is that of a fairly vanilla tabbed text editor with way too many windows open and the menu bars missing. :)
11:01:49 * glguy_ suspects that people that use OS X themes in GNOME have never used OS X
11:01:56 <Beelsebob> glguy: quite
11:02:10 <MyCatVerbs> Beelsebob: I have a nagging suspicion that maybe Xmonad appeals for roughly the same reason. :)
11:02:13 <Nafai> And those of us that have used OS X and jumped back to Gnome avoid OS X themes
11:02:23 <ManateeLazyCat> MyCatVerbs: That's case is in my developing plan.
11:02:24 <Nafai> I don't *want* my system to look like OS X
11:02:37 <MyCatVerbs> OS X isn't all that ugly.
11:02:46 <MyCatVerbs> Can't stand Apple's hardware's aesthetics, though.
11:02:53 <ManateeLazyCat> MyCatVerbs: So i know how to fix it, just limit min height and width that window arrowed
11:02:57 <Beelsebob> OS X is very beautiful
11:03:11 <Nafai> Beelsebob: For some.
11:03:12 <Beelsebob> but... it's beautiful because it's pixel perfect
11:03:16 <ManateeLazyCat> Now OS X, just OS-X theme
11:03:23 <Beelsebob> not because of a few gradients
11:03:31 <MyCatVerbs> Beelsebob: subpixel perfect. Welcome to antialiasing, yo. ;)
11:03:36 <Beelsebob> MyCatVerbs: indeed
11:04:06 * bremner averts his eyes while the OS X people fawn
11:04:27 <Twey> MyCatVerbs: Aye, I did that with my xmonad.  It's nice to be able to visually combine a bunch of applications into one big control panel.
11:04:36 <ManateeLazyCat> bremner: I have another theme that is black, in fact i like it, choose OS-X theme just for test.
11:05:05 <ManateeLazyCat> OS-X theme flash eye but handy for test.
11:07:05 * ManateeLazyCat Looks have so many Mac fans in this channel.... :)
11:07:15 <trofi> I want to implement some sort of hackish(least code-intrusive) cache in '-> IO a' function. Is *IORef good solution for that?
11:09:17 <copumpkin> trofi: you can make an ugly global variable and use it inside there, but it's not ideal
11:10:19 <trofi> sure. the best solution is StateT?
11:11:43 <trofi> copumpkin: and about 'variable', what exactly do you mean? *Var a?
11:12:02 <ManateeLazyCat> trofi: Just style, sometimes you just can use IORef.
11:12:02 <copumpkin> myUglyGlobal = unsafePerformIO $ newIORef 0
11:12:12 <ManateeLazyCat> trofi: No copy.
11:12:35 <ManateeLazyCat> copumpkin: No, don't show unsafePerformIO . :)
11:12:46 <trofi> no need for unsafePerformIO
11:13:05 <trofi> the cache i need is used only in (-> IO a) stuff
11:13:12 <copumpkin> *Enumerable> (+(1 :: Word8)) == ((+2) . (subtract 1))
11:13:12 <copumpkin> True
11:13:54 * ManateeLazyCat I use IORef in my project everywhere when gtk2hs just accept IORef.
11:14:28 <trofi> 'd like to hold an [(key, value)] IORef'ed.
11:14:41 <trofi> is it common practice?
11:14:54 <copumpkin> avoid it if possible
11:15:03 <copumpkin> but the world won't end
11:15:54 <ManateeLazyCat> trofi: Try use others solution instead IORef if you can.
11:17:14 <ManateeLazyCat> trofi: If you want write some algorithm [(key, value)] (you can use Map instead it), first write pure functions, then use IORef wrap it.
11:18:04 * ManateeLazyCat pasted "Unique.hs" at http://paste2.org/get/379652
11:18:05 <ManateeLazyCat> A example that handle [(key, value)]
11:18:20 <ManateeLazyCat> @type Data.Map.fromList
11:18:21 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
11:18:56 <ManateeLazyCat> trofi: You can use Data.Map.fromList transform [(key, value)] to Map, then use Map functions handle it.
11:19:20 <trofi> there will be usually 2-3 entries in map :]
11:19:47 <ManateeLazyCat> Yep.
11:20:04 <ManateeLazyCat> Data.Map.from*
11:20:16 * trofi will use IORef for the first time in his haskell life
11:21:10 <ManateeLazyCat> trofi: If you use IORef, try transform IORef as argument to function, and don't use unsafePerformIO
11:22:27 <MyCatVerbs> trofi: the most principled way to do it using IORef is to change your (a -> IO b) to (IORef (Data.Map a b) -> a -> IO b).
11:23:21 <MyCatVerbs> Er, Data.Map.Map, or just Map if you import it unqualified. :)
11:23:36 <ManateeLazyCat> import Data.Map (Map)
11:23:48 <ManateeLazyCat> import qualified Data.Map as M
11:23:55 <trofi> aha, thanks
11:23:59 <MyCatVerbs> So instead of writing result <- slowCalculation input; you'd write: cache <- newIORef empty; result <- wrap cache slowCalculation input;
11:24:15 <jmcarthur_work> IORef wtf
11:24:40 <MyCatVerbs> trofi: but if you're going to all that trouble, you may as well just pass that Map around explicitly. No real need for an IORef.
11:25:03 <MyCatVerbs> StateT is the cleanest way of doing this.
11:25:18 <trofi> but it will force me to rewrite whole program
11:25:41 <trofi> i'll try to do it right after hack w/IORef
11:25:43 <jmcarthur_work> probably not as much as you think unless your whole program is in IO
11:25:49 <glguy_> IO, IO, its off to work we go...
11:25:54 <trofi> the whole
11:26:00 <trofi> it's an X11 app
11:26:07 <MyCatVerbs> You're already working inside the IO monad, right? Switching to from some monad (m) to (StateT m) isn't actually that disruptive.
11:26:10 <ManateeLazyCat> trofi: Try to keep function pure, then use modifyIORef modified value.
11:26:18 <ManateeLazyCat> @type modifyIORef
11:26:19 <lambdabot> Not in scope: `modifyIORef'
11:26:21 <jmcarthur_work> i still doubt it's as big of a change as you are suspecting
11:26:31 <ManateeLazyCat> @type Data.IORef.modifyIORef
11:26:32 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
11:26:35 <Twey> MyCatVerbs: Eh?  It involves sprinkling a bunch of lifts throughout one's code.
11:26:47 <trofi> yep :[
11:27:02 <jmcarthur_work> liftIO should be the only lift you ever have to explicitly use, IMO
11:27:14 <Twey> But there's still at least one for every function
11:27:16 <jmcarthur_work> and even that would best be abstracted out
11:27:45 <mightybyte> Can anyone give me a hand with real-time GUI updates? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8187
11:28:03 <jmcarthur_work> people always think they need a StateT s IO, but really they just need a Foo that provides a very limited subset of the functionality of StateT s IO
11:28:27 <monochrom> Often they just need ReaderT s IO
11:28:27 <mightybyte> I'm trying to update a GTK chart with data coming in from the network in real-time.  What approach should I take?
11:28:31 <jmcarthur_work> lifting is just a symptom of exposing too many details
11:28:47 <Twey> Not always
11:28:56 <dons> Cale: around?
11:28:56 <mightybyte> Make the chart function run in a state monad?  Use an MVar or some other mutable type?
11:29:12 <Twey> There are genuine cases where some information needs to be passed to practically every function
11:29:25 <ManateeLazyCat> mightybyte: IORef
11:29:33 <jmcarthur_work> and more to the point, you rarely need StateT s IO since you can usually get away with (MonadIO m, MonadState s m) => m a
11:29:35 <Cale> dons: yep
11:29:38 <ManateeLazyCat> mightybyte: IORef or MVar.
11:29:58 <mightybyte> ManateeLazyCat: Ok, I've never used either of them.  <...goes to read docs>
11:30:08 <MyCatVerbs> Cale: your +o is showing, by the way. I only remark because you usually leave it off.
11:30:11 <ManateeLazyCat> mightybyte: Never use StateT wrap your keyPress handler, otherwise it can't work
11:30:16 --- mode: Cale set -o Cale
11:30:37 <dons> Cale: i want to have a bucket of 1 inch badges/buttons to hand out at ICFP :) I need a couple of svg haskell logo/image designs?
11:30:42 <dons> thoughts?
11:30:46 <mightybyte> ManateeLazyCat: Ok, I had a feeling that a State monad would have problems.
11:31:04 <Lemmih> dons: Do you know why single element unboxed tuples exist?
11:31:14 <ManateeLazyCat> mightybyte: Because gtk2hs just binding key event functions with IORef, StateT can't work with those functions (such as onKeyPress, onKeyRelease)
11:31:17 <dons> Lemmih: huh. (# x #) }
11:31:18 <dons> ?
11:31:22 <Lemmih> dons: Yes.
11:31:52 <dons> Cale: so would you be able to point to a couple of nice svg logos to use to represent haskell suitable for going on say, these: http://www.oneinchround.com/#2
11:31:56 <dcoutts> single place unboxed tupled :-)
11:32:00 <dons> Lemmih: hmm. what's the operational interpretation?
11:32:03 <dcoutts> they're occasionally useful
11:32:09 <dons> stack allocation of the thingy
11:32:17 <dcoutts> dons: eg you can return a -> (# x #)
11:32:24 <dcoutts> and not necessarily evaluate it
11:32:26 <dons> yeahn
11:32:36 <dcoutts> like for array ! index
11:32:46 <mightybyte> ManateeLazyCat: So anything stateful like this with gtk2hs needs to be done at the IO level?
11:32:48 <Lemmih> Hm.
11:32:50 <ManateeLazyCat> mightybyte: I write my gtk2hs with StateT, but last i rewrite all code with IORef.
11:33:08 <mightybyte> ManateeLazyCat: Ahh, interesting.
11:33:51 <jmcarthur_work> mightybyte, i am not familiar with gtk. is this an IO callback function?
11:33:52 <ManateeLazyCat> mightybyte: If you have multi-thread for common variable, try use MVar instead IORef.
11:33:58 <sm> morning all
11:34:12 <nathanic> does anyone know if there is a vector version of this one out in the wilds?  http://upload.wikimedia.org/wikipedia/commons/4/43/Haskell-Logo-Variation.png
11:34:18 <mightybyte> ManateeLazyCat: What's the difference between MVar and IORef
11:34:51 <jmcarthur_work> mightybyte, when i have used IO callbacks in haskell in the past i would have the callback function set a new function to be called the next time it's invoked each time
11:34:52 <ManateeLazyCat> mightybyte: MVar safer than IORef when concurrent
11:34:59 <mightybyte> Ahh, got it
11:35:01 <jmcarthur_work> that way state is just a part of the closure
11:35:06 <dons> http://haskell.org/haskellwiki/Thompson-Wheeler_logo
11:35:09 <Cale> dons: Hmm... I can manage encapsulated postscript, I think... what size do you need?
11:35:39 <ManateeLazyCat> jmcarthur_work: gtk2hs will failed with some functions if you use StateT wrap argument.
11:35:48 <jmcarthur_work> ManateeLazyCat, i'm not talking about State or StateT
11:35:49 <mightybyte> jmcarthur_work: Hmmm, not sure if that will work here or not.
11:36:01 <dons> Cale: i can scale things. i just need a couple of nice badge-worthy logos. so perhaps the cabal/batteries one, and the new haskell logo? or some custom variants?
11:36:25 <ManateeLazyCat> mightybyte: gtk2hs have many demo code in `demo` sub-directory.
11:36:48 <ManateeLazyCat> mightybyte: And gtk2hs API is good resource too.
11:37:11 <mightybyte> ManateeLazyCat: Ok.  I've been looking at the API, but I wasn't sure how to manage this state.
11:37:12 <nathanic> Cale: The one I linked is a pretty variation (IMHO); I wish I could find the original inkscape file it's from.
11:37:12 <jmcarthur_work> main = setCallback (foo 0) >> blah blah blah     ...    foo x = doStuff >> setCallback (foo (x+1))
11:37:15 <MyCatVerbs> dons: I thought the new Haskell logo was in .svg?
11:37:50 <ManateeLazyCat> mightybyte: http://farm3.static.flickr.com/2676/3821227364_e739332f63_o.png my gtk2hs project screenshot. :)
11:37:53 <mrsolo> are there some workable haskell web framework available?
11:37:54 <MyCatVerbs> It's a pity that an ICBM with unsafePerformIO written on the side is so hard to depict on a badge.
11:38:04 <MyCatVerbs> mrsolo: look into HAppstack.
11:38:35 <MyCatVerbs> mrsolo: http://happstack.com/ <- it's warm and fuzzy.
11:38:55 <ManateeLazyCat> mightybyte: I see your code, you use draw canvas self?
11:39:04 <monochrom> But you can depict a crossed-out ICBM, connoting safety and peace.
11:39:28 <ManateeLazyCat> mightybyte: You develop IRC-client?
11:40:29 <mrsolo> ..The Happstack project needs you!.. ok that does not project warm and fuzzy
11:41:05 <dons> hmm. maybe i'm ok then with the two logos.
11:41:17 <dons> Cale: what do you think? just use the batteries and thompson-wheeler logo?
11:42:32 <Cale> Yeah, I think so. I suppose the tricky part will be getting them into the format these guys want...
11:42:39 <Cale> They want CMYK
11:42:54 <monochrom> Heh, the railway logo :)
11:42:57 <Cale> Does someone have a machine with Photoshop or Illustrator to do that?
11:43:11 <ManateeLazyCat> mightybyte: You can use TextView or SourceView for draw your chat window, that's easier.
11:43:26 <ManateeLazyCat> Cale: Do what?
11:43:37 <ManateeLazyCat> Cale: I have Photoshop.
11:43:39 <Cale> ManateeLazyCat: Put the graphics into CMYK colour mode.
11:44:00 <mightybyte> ManateeLazyCat: No, not a chat client.  It's just a dynamically displayed chart.
11:44:20 <ManateeLazyCat> mightybyte: I see.
11:44:59 <ManateeLazyCat> mightybyte: You can use Cairo to draw canvas self.
11:45:16 <ManateeLazyCat> Cale: CMYK, just transform picture mode?
11:45:25 <vav> is \def i -> fromMaybe def . listToMaybe . drop i a sensible indexer when i my not make sense sometimes
11:45:48 <ManateeLazyCat> Cale: I think it like transform picture .format
11:45:57 <ManateeLazyCat> Cale: Right?
11:46:06 <jmcarthur_work> :t \def i -> fromMaybe def . listToMaybe . drop i
11:46:08 <lambdabot> forall a. a -> Int -> [a] -> a
11:46:15 <Cale> ManateeLazyCat: and I guess make sure that it's done sanely with respect to the black channel, I suppose
11:46:46 <ManateeLazyCat> Cale: How many picture need to handle?
11:46:50 <monochrom> > drop 10 []
11:46:51 <lambdabot>   []
11:46:59 <monochrom> I think so, vav.
11:47:14 <jmcarthur_work> yeah it looks reasonable
11:47:19 <monochrom> Took me a minute to decode "def" as "default".
11:47:28 <RayNbow> > drop (length [1..]) []
11:47:33 <lambdabot>   mueval-core: Prelude.read: no parse
11:47:33 <lambdabot>  mueval: ExitFailure 1
11:47:35 <RayNbow> hmm
11:47:46 <RayNbow> drop is strict in its first argument?
11:47:54 <jmcarthur_work> @src drop
11:47:55 <lambdabot> drop n xs     | n <= 0 =  xs
11:47:55 <lambdabot> drop _ []              =  []
11:47:55 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
11:48:07 <ManateeLazyCat> Cale: I can help you handle those picture if it's too profession
11:48:09 <monochrom> I support drop being strict in its first argument.
11:48:15 <jmcarthur_work> ah, it's that way so that it can be lazy in the second
11:48:15 <Cale> ManateeLazyCat: talk to dons :)
11:48:23 <dcoutts> dons: so you're going to get 100 haskell logo buttons printed and sell then at ICFP ? :-)
11:48:28 <jmcarthur_work> in the case that the number is negative
11:48:28 <dcoutts> then/them
11:48:29 <copumpkin> > drop undefined []
11:48:30 <lambdabot>   * Exception: Prelude.undefined
11:48:31 <vav> thanks monochrom, may as well spell it out
11:48:36 <dons> dcoutts: give 'em away :)
11:48:40 <Cale> ManateeLazyCat: If he wants to submit graphics to this button-making site, they have particular standards for the image formats they want :)
11:48:46 <monochrom> "default" is a keyword. can't use. :)
11:48:52 <dons> dcoutts: just leave them on the table for people to take.
11:49:17 <ManateeLazyCat> Cale: I'm a Game Developer before.
11:49:41 <kolmodin> oo, oo! I want one :D
11:49:42 <ManateeLazyCat> Cale: But i'm not artist for Game Graphics. :)
11:49:53 <dcoutts> dons: though maybe charging 50p makes them even more desirable :-)
11:50:00 <vav> monochrom: right, but it's actually a defaultWellDefinedType, so can defaultR
11:50:20 <dons> dcoutts: hehe. ok. beer money
11:51:20 <monochrom> Run an auction. Use the "pay the second highest bidder's bid" scheme.
11:51:24 <ManateeLazyCat> dons: Cale said you need Photoshop handle some picture, i can help?
11:51:38 <dons> we'll see. I'll have a play around on the weekend.
11:52:33 <monochrom> I expect these buttons to be offered on eBay just several hours after you give/sell them. :)
11:52:53 <ManateeLazyCat> dons: Just call me if you any help. :) I install Photoshop in my another PC.
11:53:21 <ezyang> Hey all, I was trying to install cabal-install with GHC version 6.10.3 and got a panic
11:53:25 <ManateeLazyCat> s/you/you need/
11:54:03 <ezyang> I got: http://haskell.pastebin.com/m4bc77423
11:54:38 <ezyang> Any ideas?
11:57:09 * ManateeLazyCat Bye all night!
11:59:24 <noteventime_> ezyang: Some x86_64 vs. x86 issue?
11:59:38 <ezyang> I'm running x86
11:59:56 <ezyang> I have some 64-bit libraries hanging around, but they shouldn't interfere?
12:00:36 <noteventime_> I don't see why, just figured since you had the Int64 truncation warning before the error
12:01:00 <ezyang> Yeah.
12:01:09 <ezyang> I'm bumping up my GHC version and seeing if that helps
12:01:13 <stianhj> ezyang: how about upgrading to 6.10.4? couldn't hurt?
12:01:28 <ezyang> stianhg: long download time ;-)
12:01:49 <stianhj> download the Haskell Platform
12:02:22 <stianhj> http://hackage.haskell.org/platform/
12:02:37 <ezyang> Ah, so I should just say no to PPAs?
12:02:53 <ezyang> Oh, no, I am using someone561's PPA
12:03:36 <stianhj> follow this tutorial: http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
12:03:46 <ezyang> Gotcha
12:03:50 <ezyang> Hackage is suuuch a mess
12:03:56 <stianhj> it uses someone561's ppa
12:03:58 <ezyang> All I wanted to do was install Hoogle locally :-/
12:05:18 <sshc> Hi, I'm learning Haskell.  I wrote a function to get xth element of a list: "get id list = head (drop id - 1 list)".  Is there a better way to do this?  And if I did use that function, which typeclass should I use?
12:05:58 <ezyang> sshc: !!
12:05:59 <dqd> @src (!!)
12:06:00 <lambdabot> xs     !! n | n < 0 = undefined
12:06:00 <lambdabot> []     !! _         = undefined
12:06:00 <lambdabot> (x:_)  !! 0         = x
12:06:00 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:06:01 <tommd> sshc: You can use (!!) if you are sure list is of the needed length
12:06:26 <ezyang> sshc: See also Hoogle
12:06:48 <ezyang> Ok, downloading the platform whee
12:07:03 <sshc> thanks
12:07:19 <ezyang> Oh, I have another, unrelated question.
12:07:46 <ezyang> I was reading Typeclassopedia, and noticed that there were repeated references to ((->) e).  However, the expression didn't seem to compile on my ghci...
12:08:20 <noteventime_> :k ((->) e)
12:08:22 <lambdabot> Not in scope: type variable `e'
12:08:41 <noteventime_> Do I put a forall there?
12:08:46 <noteventime_> Or how does lambdabot work
12:10:20 <noteventime_> ezyang: You realise ((->) e) has kind "* -> *"?
12:10:51 <noteventime_> Or am I being dumb? :s
12:11:21 <ezyang> noteventime_: I don't understand what * -> * means, unfortunately :-(
12:11:37 <noteventime_> ezyang: It's a type constructor, not a type
12:11:40 <jmcarthur_work> ezyang, ((->) e) is the type constructor for the function monad
12:11:51 <noteventime_> ezyang: think of ((->) e) as (e -> )
12:12:14 <ezyang> Ok, so does that mean I can do ((->) e) a?
12:12:17 <noteventime_> So (e -> a) == ((->) e a) == ((->) e) a basically
12:12:20 <noteventime_> ezyang: Yes
12:12:37 <ezyang> Ok... hm, so can I make a typeclass for ((->) e)?
12:13:00 <noteventime_> Hmm? You mean an instance of some type class?
12:13:04 <ezyang> Yes.
12:13:24 <noteventime_> Depends
12:13:34 <noteventime_> If the type class is over (* -> *)
12:13:35 <ezyang> Specifically, I wanted to define Functor for ((->) e)
12:13:40 <noteventime_> Yes
12:14:00 <noteventime_> You can define a Functor instance for ((->) e)
12:14:08 <ezyang> Huh. Really!
12:14:17 <ezyang> What version of GHC was support for this added?
12:14:33 <ezyang> I seem to recall having to make a newtype when I was doing it
12:15:13 <noteventime_> ezyang: Dunno, works without problems here :|
12:15:22 <ezyang> hmm, k
12:15:37 <ezyang> Whoo, done downloading
12:16:34 <ezyang> making
12:16:59 <noteventime_> "instance Functor ((->) e) where fmap f g = f . g" works
12:18:05 <ezyang> Yup, looks like it works here too
12:18:18 <ezyang> I guess it was a new GHC thing
12:18:47 <ezyang> Hmm... that was not the functor instance I derived...
12:19:04 <noteventime_> Just threw something together to test if it worked :)
12:19:14 <ezyang> ahahah, ok
12:19:37 <Berengal> @type fmap
12:19:38 <dino-> Apple is ridiculous.
12:19:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:19:51 <dino-> Sorry my friends, mischannel.
12:20:00 <Berengal> @djinn (a -> b) -> (e -> a) -> (e -> b)
12:20:01 <lambdabot> f a b c = a (b c)
12:20:19 <ezyang> Berengal: what... did that do?
12:20:33 <Berengal> ezyang, derive fmap for the function functor
12:20:58 <pikhq> ezyang: Djinn takes a type signature and tries to derive a sensible function to match.
12:22:01 <ezyang> Berengal: Ok, that's different from what :t fmap gives me
12:22:21 <ezyang> The version I derived was: fmap g (R f) = R $ \a -> g (f a)
12:22:29 <Berengal> ezyang, the forall part? That's because lambdabot has some extensions enabled
12:22:32 <ezyang> (with R being R { runReader :: e -> a })
12:22:37 <ezyang> Berengal: Ahh
12:22:53 <Berengal> You'll get them with ghci too
12:22:57 <ezyang> ooh, they are equivalent
12:23:06 <pikhq> @src ((->) e) fmap
12:23:07 <ezyang> (my version just looks dirtier)
12:23:07 <lambdabot> Source not found. Do you think like you type?
12:23:18 <ezyang> Berengal: Not by default, I don't think?
12:23:32 <Berengal> ezyang, no, you need the extensions
12:23:39 <ezyang> ok
12:23:40 <Berengal> ExistentialQuantification, I believe
12:23:46 <Berengal> Although I'm not certain
12:23:54 <ezyang> /me's head 'splodes
12:24:05 <jmcarthur_work> would it be one of the Rank2Types or RankNTypes extensions or something?
12:24:25 <ezyang> whoo, platform done compiling
12:24:25 <Berengal> jmcarthur_work, don't those turn on EQ as well implicitly?
12:24:34 <jmcarthur_work> don't think so
12:24:54 <jmcarthur_work> could be wrong
12:25:15 <noteventime_> I don't get the foralls for either EQuantifiaction, Rank2 or RankN :|
12:25:29 <ezyang> ok, so I think I parse that line as "for all types a, b and f where f is a type constructor with signature * -> *: ..."
12:26:19 <dino-> I see a lot of things duplicated between the mtl package and the transformers package. Is one of those slowly replacing the other?
12:26:47 <ezyang> I don't... really see how that is quite useful?
12:27:06 <noteventime_> ezyang: It's equivalent to what you "usually" see, the thing is
12:27:19 <noteventime_> With the extensions, you can move the foralls deeper into the signature
12:27:31 <jmcarthur_work> :t runST
12:27:33 <lambdabot> forall a. (forall s. ST s a) -> a
12:27:38 <ezyang> whoa
12:28:12 <monochrom> Eh? You don't need "forall" or RankNTypes for making ((->) e) a Functor.
12:28:22 <jmcarthur_work> nope
12:28:27 <ezyang> monochrom: We got a little sidetracked ^_^
12:28:31 <noteventime_> monochrom: Why would you?
12:28:53 <Berengal> > let f :: ([a] -> [a]) -> (String, [Int]); f g = (g "hello", g [1,2,3]) in f reverse
12:28:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:28:59 <Berengal> > let f :: (forall a. [a] -> [a]) -> (String, [Int]); f g = (g "hello", g [1,2,3]) in f reverse
12:29:01 <lambdabot>   ("olleh",[3,2,1])
12:29:35 <ezyang> umm
12:29:41 * ezyang attempts to parse that mentally 
12:29:50 <monochrom> But Berengal's is a great example of what RankNType buys you as extra.
12:30:38 <ezyang> > f g = (g "hello", g [1,2,3]) in f reverse
12:30:39 <lambdabot>   <no location info>: parse error on input `='
12:31:09 <ezyang> > f reverse where f g = (g "hello", g [1,2,3])
12:31:10 <lambdabot>   <no location info>: parse error on input `where'
12:31:13 <monochrom> "in" wants a matching "let"
12:31:14 <ezyang> um
12:31:30 <monochrom> "information" wants to be "free"
12:31:31 <jmcarthur_work> > let f g = (g "hello", g [1,2,3]) in f reverse
12:31:33 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:31:33 <lambdabot>    arising from the literal `1...
12:31:46 <pikhq> Hmm. When I first saw "forall", I just assumed it was something going on behind the scenes in Haskell, simply because I saw no reason for it *not* to be in Haskell...
12:31:54 <ezyang> hmm, I have to run
12:32:00 <ezyang> I will think about this some more.
12:32:00 * alip is feeling groovy
12:32:17 <jmcarthur_work> :t \a -> (f "hello", f [1,2,3])
12:32:19 <lambdabot> forall t t1 t2. (SimpleReflect.FromExpr t1, SimpleReflect.FromExpr t2) => t -> (t1, t2)
12:32:22 <jmcarthur_work> :t \f -> (f "hello", f [1,2,3])
12:32:23 <lambdabot>     No instance for (Num Char)
12:32:24 <lambdabot>       arising from the literal `1' at <interactive>:1:21
12:32:24 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
12:33:29 <pikhq> :t let f :: (forall a. [a] -> [a]) -> (String, [Int]); f g = (g "hello", g [1,2,3]) in f
12:33:31 <lambdabot> (forall a. [a] -> [a]) -> (String, [Int])
12:33:47 <pikhq> Type signatures are important things.
12:34:41 <Berengal> This is one of the examples of HM type-inference coming up short, isn't it?
12:34:54 <pikhq> I'd imagine so.
12:35:38 <Philippa_> pikhq: type inference for rank-n polymorphism's probably undecidable, and it took active research to allow it with annotations
12:36:10 <pikhq> Philippa_: You should know that, when it comes to languages, I am very demanding.
12:36:18 <pikhq> For instance, I demand a halting oracle.
12:36:34 <monochrom> I demand two.
12:36:41 <Berengal> I have one
12:36:44 <Berengal> I call it timeout
12:37:01 <monochrom> (It makes a difference how many times an algorithm consults an oracle!)
12:37:57 <Saizan_> "You get only 3 questions, Don't ask to ask."
12:38:59 <monochrom> Actually, I demand a nonhalting oracle. It's more powerful, but I have forgotten how to explain why.
12:39:54 <roconnor> I see your oracle and raise you one halting oracle for machines with your oracle.
12:40:37 <pikhq> roconnor: I run fix on that statement.
12:40:44 <Berengal> I fold
12:41:21 <roconnor> pikhq: I take a successor to your ordinal oracle.
12:41:26 <monochrom> I mfix
12:41:32 <sm> how come in ghci, I get Loading package download-0.3 ... linking ... <interactive>: /home/simon/.cabal/lib/download-0.3/ghc-6.10.3/HSdownload-0.3.o: unknown symbol `stat64' ? The package builds fine
12:42:28 <dcoutts> sm: do you get the same if you use the package with ghc --make rather than ghci?
12:42:41 <sm> dcoutts: no, that works
12:43:12 <dcoutts> sm: what OS?
12:43:41 <sm> ubuntu intrepid on xen on x86_64
12:43:44 <pikhq> > fix (+1) 1 -- Like that?
12:43:46 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
12:43:46 <lambdabot>    arising from the literal `1' at <...
12:43:56 <hackagebot> hp2any-manager 0.4.2 - A utility to visialise and compare heap profiles. (GergelyPatai)
12:43:56 <hackagebot> hp2any-graph 0.5.1 - Real-time heap graphing utility and profile stream server with a reusable graphing module. (GergelyPatai)
12:43:56 <hackagebot> hp2any-core 0.10.0 - Heap profiling helper library (GergelyPatai)
12:44:09 <pikhq> > fix (+1) x -- Like that?
12:44:10 <lambdabot>   No instance for (GHC.Num.Num (SimpleReflect.Expr -> a))
12:44:10 <lambdabot>    arising from the...
12:44:18 <pikhq> Apparently no
12:44:37 <Trinithis> :t fix (+1)
12:44:39 <lambdabot> forall a. (Num a) => a
12:44:41 * pikhq is dumb, and that was wrong
12:44:52 <pikhq> I was thinking fold for some reason.
12:44:56 <pikhq> > fix (+x)
12:45:02 <lambdabot>   mueval-core: Prelude.read: no parse
12:45:02 <lambdabot>  mueval: ExitFailure 1
12:45:08 <Trinithis> > fix (+1)
12:45:12 <pikhq> There we go.
12:45:13 <lambdabot>   mueval-core: Prelude.read: no parse
12:45:13 <lambdabot>  mueval: ExitFailure 1
12:45:28 <tommd> > 1
12:45:29 <lambdabot>   1
12:45:43 <tommd> > fix error
12:45:45 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:50:57 <sm> and while I'm askin': how come it's so hard to exit ghci in emacs, especially a remote one, these days ? C-d, C-q C-d, C-q C-z.. I have to kill it from another shell
12:51:22 <monochrom> C-c C-d
12:51:25 <monochrom> :quit
12:51:31 <ksf> oh, hear the wisdom of vi: :q
12:52:36 <sm> monochrom: C-c C-d works for me only in ghci-6.10.8. But :quit does the trick, thank you
12:53:01 <sm> ack, s/ghci-6.10.8/ghci-6.8/
12:53:03 <ksf> well C-d as in EOF
12:53:35 <ksf> you can do C-\, too, if you're feeling brave.
12:54:09 <sm> that just detaches my dtach session
12:54:13 <monochrom> generally, pretend C-c to all of those.
12:54:25 <monochrom> err, s/pretend/prepend/
12:54:35 <ksf> shouldn't be nescessary with C-\
12:54:38 <sm> basically I think eof isn't recognised properly in ghci 6.10
12:54:51 <ksf> wait it gets caught
13:18:28 <athos> @query lambdabot
13:18:28 <lambdabot> Unknown command, try @list
13:18:31 <athos> heh
13:18:40 <athos> my bad
13:23:32 <sshc> how do I call an infix function as a prefix function?
13:24:02 <dino-> sshc: Wrap it in ( )
13:24:11 <dino-> > (+) 2 2
13:24:13 <lambdabot>   4
13:25:29 <mightybyte> Anyone know why enabling the GUI screws up processing of the network messages? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8187#a8189
13:26:30 <Makoryu> > let plus = (+) in 2 `plus` 2
13:26:32 <lambdabot>   4
13:28:24 <dino-> mightybyte: I wonder if it's just quite busy with the UI event looping.
13:28:41 <ray> > let 2 + 2 = 5 in 2 + 2
13:28:43 <lambdabot>   5
13:29:07 <Makoryu> > let 2 + 2 = 5 in 1 + 1 -- whoops
13:29:08 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
13:30:05 <mightybyte> dino-: I put a print statement in the chart update and that doesn't get executed too often.
13:30:12 <mightybyte> Only on window actions.
13:32:56 <dino-> I've seen people get into kind of the reverse trouble with Java UI stuff for years. i.e. making the main thread real busy and then wondering why nothing paints for a while, nothing responds.
13:35:50 <Vanadium> oh look i said {-# LANGUAGE -XPatternGuards #-} by accident and ghc paniced on me
13:36:31 <mightybyte> dino-: Yeah, that's certainly a possibility, but there's so little going on that it's a problem if that thread is monopolizing resources.
13:37:24 <dino-> mightybyte: I'm not that famaliar with some of this yet. Is that just blocking somewhere around hGetLine ?
13:38:41 <mightybyte> dino-: I guess it might block if there is data, but not a whole line's worth.
13:38:52 <mightybyte> Seems like it shouldn't matter.
13:44:44 <dino-> I was working on something recently with unix domain sockets where it blocks on the accept action and then forks after each connection is accepted so it can go back to waiting for more. This is kind of a multicast thing where many clients may connect simultaneously.
13:46:32 <dino-> It was actually more complicated than that even, I had to put the connection listener itself in its own thread so that a signal handler is free as well to respond to kill or sigint, yada.
13:51:51 <dino-> With Network.Socket and STM to coordinate
13:55:13 <dino-> mightybyte: I don't know if it's applicable, but this helped a lot with what I was up to: http://www.haskell.org/haskellwiki/Background_thread_example
13:57:11 <bos> @seen dons
13:57:12 <lambdabot> dons is in #haskell-in-depth, #haskell, #ghc, #xmonad, #darcs, #concatenative, #arch-haskell and #yi. I last heard dons speak 58m 40s ago.
13:57:38 * bos headdesk
13:58:14 <bos> there is no description of whether -fhpc is a source-level or a link-time flag in the ghc docs.
14:00:53 <doubleth1nk_work> bos: I believe it's both, since it has to instrument the compiled program and it also has to link in the hpc library
14:01:03 <bos> doubleth1nk_work: yeah, you're right
14:01:12 <bos> the documentation is not good though :-(
14:06:05 <dons> bos
14:06:13 <dons> compile time
14:06:14 <mightybyte> dino-: It doesn't seem like I would need that, but then since it's not working I don't know what it needs.
14:06:20 <bos> dons: nemmind, after enough scrabbling around i found the answer
14:06:39 <bos> dons: what do you do to get hpc coverage for bytestring? mangulate things by hand?
14:07:01 <bos> i want to see how much of the text library is covered by tests.
14:13:18 <dons> bos: i have a Makefile in the tests/ directory for most projects that builds with -fhpc --make
14:17:58 <sm> me too, I also archive old reports.. see the prof and heap targets in http://joyful.com/repos/hledger/Makefile
14:18:02 <bos> dons: i see
14:30:52 <QP> what is the idiomatic way of using read safely?
14:31:07 <QP> catch?
14:31:33 <sm> no, I think it is to use a safe version, there is a lib on hackage
14:32:06 <Berengal> There's readIO isn't there?
14:32:23 <QP> @hoogle readIO
14:32:23 <lambdabot> Prelude readIO :: Read a => String -> IO a
14:32:23 <lambdabot> System.IO readIO :: Read a => String -> IO a
14:32:23 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
14:32:27 <Berengal> and reads
14:32:30 <Berengal> @type reads
14:32:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:32:47 <Berengal> > reads "asdf" :: [(Int, String)]
14:32:49 <lambdabot>   []
14:33:12 <QP> doesn't reads produce lots of extra cases that make it inefficient?
14:33:20 <tommd> > reads "10 asdf" :: [(Int, String)]
14:33:21 <lambdabot>   [(10," asdf")]
14:33:39 <QP> ok, i see
14:33:45 <Berengal> QP, it'll only produce the extra cases if you need them. The wonders of lazy evaluation
14:33:47 <tommd> QP: Well, if you are looking for efficiency you probably don't want to use String in the first place.
14:34:17 <Berengal> @src read
14:34:18 <lambdabot> read s = either error id (readEither s)
14:34:25 <tommd> I've used String for some damn large sets (800MB of logs, for example), but it took 20 minutes to parse.  Didn't matter as it was a one time thing, but still.
14:34:33 <QP> > reads "-23 34 -2 eir" :: [(Int,String)]
14:34:34 <lambdabot>   [(-23," 34 -2 eir")]
14:34:44 <QP> hmmm, not bad...
14:34:55 <Berengal> @src readEither
14:34:56 <lambdabot> Source not found. :(
14:35:03 <QP> yeah, i think that will o
14:35:04 <QP> do
14:35:15 <Berengal> @type readEither
14:35:17 <lambdabot> Not in scope: `readEither'
14:35:32 <QP> another quick question---
14:35:37 <QP> i'm using linux
14:35:49 <QP> can i get GHC to compile for windows
14:35:50 <QP> ?
14:36:02 <tommd> Yes, but probably not on Linux if that is what you are saying.
14:36:12 <QP> ok...
14:36:14 <tommd> Is there a reason the Windows packages online won't do?
14:36:27 <tommd> Oh, sorry, you want to use GHC to compile a program (that is not GHC) to run on Windows?
14:36:29 <tommd> Now I get it.
14:36:34 <tommd> No, you can't.
14:36:41 <QP> yeah, that's what i meant
14:36:43 <QP> why not?
14:36:47 <tommd> Yeah, I'm just slow ;-)
14:37:04 <tommd> Well, GHC doesn't do any cross compiling (be it for architecture or OS).
14:37:13 <QP> you mean i have to run ghc on a windows machine to get a windows .exe?
14:37:14 <tommd> There are some modified version of GHC that do.
14:37:22 <tommd> Yes, that is what I am saying.
14:37:30 <tommd> s/version/versions./
14:37:37 <QP> hmmm... that's a bit annoying
14:37:40 <glguy_> QP: that's how much compilation processes work. what you are looking for is a cross-compiler
14:37:47 <glguy_> most*
14:38:07 <QP> ok, i guess i'm new to the whole different OSs thing
14:38:07 <tommd> Yes - cross compiling would be a great plus for GHC.  Sadly the team is small for their current efforts let alone more.
14:40:35 <QP> tommd, Berengal, glguy_: well thanks for all your help
14:41:13 <wolverian> guh. I have MTL installed, so the haskell platform installer doesn't build it -- but at 'make install', it tries to install it anyway.
14:41:42 <tommd> I certainly would call that a bug - care to submit a ticket?
14:41:56 <wolverian> sure, where's that?
14:42:08 <magthe> what are the options for doing synchronoues IO multiplexing (select) nowadays?
14:42:40 <tommd> wolverian: http://trac.haskell.org/haskell-platform/newticket?summary=%3CProblem%3E&description=%3CDescribe%20the%20problem%3E&component=Platform
14:42:49 <wolverian> thanks
14:43:20 <c_wraith> magthe : call forkIO and let the underlying runtime handle it?
14:43:31 <c_wraith> (forkIO rarely actually forks)
14:44:03 <glguy_> forkIO (listenHere >>= putMVar v) >> forkIO (listenThere >>= putMVar v) >> takeMVar v
14:44:24 <glguy_> (for a trivial example)
14:44:33 <tommd> I love having lots of Haskell threads and using channels for most these types of taskes.
14:44:43 <tommd> Though STM is often fun too.
14:44:58 <glguy_> yeah, sometimes you program is running too fast
14:45:04 <glguy_> and STM is an easy solution
14:45:06 <glguy_> ;)
14:45:12 <tommd> Or if you know something is low contention
14:45:53 <tommd> I hear you guys ditched my heavy reliance on STM
14:46:14 <magthe> c_wraith: that's one of the options... but I wanted to know what _other_ options there were... and synchronous multiplexing seems to come up quickly in discussions
14:46:45 <magthe> there used to be a wrapper for select, hSelect, but that seems to be gone in recent versions of GHC
14:48:21 <c_wraith> @hoogle hSelect
14:48:21 <lambdabot> No results found
14:48:34 <c_wraith> hm
14:48:39 <wolverian> tommd: http://trac.haskell.org/haskell-platform/ticket/92 done, thanks.
14:48:46 <tommd> Thank you!
14:49:14 <magthe> c_wraith: yeah, the docs I found was for GHC 6.4... so farily ancient
14:59:41 <jmcarthur> @pl \f -> f ()
14:59:42 <lambdabot> ($ ())
14:59:54 <jmcarthur> okay, works here, not in the pointfree package
15:04:51 <HugoDaniel> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html#v%3AexitWith
15:04:53 <HugoDaniel> this is wronge
15:04:55 <HugoDaniel> wrong
15:04:56 <HugoDaniel> right ?
15:05:10 <HugoDaniel> i mean, exitWith does NOT throw ExitException anymore
15:05:18 <HugoDaniel> at least thats my reading from the code :/
15:05:37 <HugoDaniel> it throws ExitCode
15:06:09 <HugoDaniel> can someone please confirm that ?
15:06:10 <Makoryu> ExitCode is the argument you pass to it
15:06:30 <HugoDaniel> which is also what is thrown by exitWith
15:06:38 <Makoryu> Hmmm
15:06:40 <HugoDaniel> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-Exit.html#exitWith
15:07:01 <HugoDaniel> the comment (and hence, the documentation) is wrong
15:08:18 <HugoDaniel> if im right, this must break lots of libs
15:08:26 <HugoDaniel> it certainly breaks my code :/
15:08:37 <^boscop> hey, anyone wants to play the wolf game at ##jswolfbot ?
15:09:01 <HugoDaniel> i get this error in ghc: Not in scope: data constructor `ExitException'
15:10:17 <tommd> HugoDaniel: I don't understand the issue - it throws an exception for me.
15:10:58 <HugoDaniel> yes, the wrong one :)
15:11:16 <HugoDaniel> the documentation says "Computation exitWith code throws ExitException code. "
15:12:30 <copumpkin> moo
15:12:42 <HugoDaniel> and it doesn't throw ExitException anymore, now it seems to be called "ExitCode"
15:12:48 <copumpkin> anyone know if psykotic on reddit hangs out here?
15:12:57 <HugoDaniel> that was older versions
15:13:29 <HugoDaniel> aren't there any of the ghc leets around ?
15:13:31 <tommd> It throws "SomeException" with the new extensible exceptions ;-)
15:13:47 <Twey> HugoDaniel: #ghc
15:14:36 <copumpkin> I was interested in the matrix zipper stuff he posted on reddit a few days ago
15:16:24 <doubleth1nk_work> copumpkin: i don't think he IRCs
15:16:31 <copumpkin> ah
15:36:54 <HugoDaniel> bye
15:39:32 * copumpkin wonders if there's a good way to write the various structure traversal functions once, instead of once for "pure" values and another time for monadic traversal
15:40:00 <copumpkin> other than using the Identity monad and writing only the monadic version
15:40:01 <TomMD> Well, you could wrap a monadic write via the Id monad for the pure code...
15:40:04 <TomMD> oh, damn
15:40:05 <copumpkin> :P
15:40:12 <Saizan> copumpkin: CPS?
15:40:14 <Twey> Isn't that Traversible?
15:40:56 <Saizan> i guess a cps transform is not optimal for the pure ones
15:41:06 <copumpkin> Twey: well, yeah, but I meant more along the lines of "I have (a -> b) -> f a -> f b and want (a -> m b) -> f a -> m (f b)
15:41:59 <Twey> Hmn
15:41:59 <copumpkin> I was just thinking about the almost magical (to me at least) transformation of withCString in Cale's email to withCStrings
15:42:16 <copumpkin> in my example I guess a sequence could just do it
15:42:22 <copumpkin> but that doesn't always work
15:43:41 <copumpkin> this is the email I was talking about: http://www.mail-archive.com/haskell-cafe@haskell.org/msg37171.html
15:44:05 <copumpkin> one of the more awesome things I've seen :P
15:46:36 <pikhq> :t (f :: (Monad m) => (a -> m b)) `fmap` (y :: (Functor f) => f a)
15:46:38 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
15:46:38 <lambdabot>     In the second argument of `fmap', namely
15:46:38 <lambdabot>         `(y :: (Functor f) => f a)'
15:46:56 <pikhq> :t (f :: (Monad m) => (a -> m b)) `fmap` [y]
15:46:57 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr (m b))
15:46:57 <lambdabot>       from the context (Monad m)
15:46:57 <lambdabot>       arising from a use of `f' at <interactive>:1:1
15:47:03 <pikhq> F this.
15:47:05 <copumpkin> undefined ?
15:47:31 <copumpkin> :t (undefined :: (Monad m) => (a -> m b)) `fmap` [y]
15:47:33 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b]
15:47:51 <pikhq> Not at all what I was thinking.
15:48:02 <hackagebot> archlinux 0.1 - Support for working with Arch Linux packages (DonaldStewart)
15:48:03 <copumpkin> :t (?f :: (Monad m) => (a -> m b)) `fmap` [y]
15:48:04 <lambdabot>     Could not deduce (?f::a -> m b) from the context (Monad m)
15:48:04 <lambdabot>       arising from a use of implicit parameter `?f'
15:48:04 <lambdabot>                    at <interactive>:1:1-2
15:48:11 <Saizan> copumpkin: and the follow up! http://www.mail-archive.com/haskell-cafe@haskell.org/msg37213.html
15:48:25 <copumpkin> Saizan: yeah, that whole thread is awesome :P
15:54:47 <msteele_> I've been playing with this function for quite awhile.  I've got types "ErrorT String IO Something", "Either IOError String", and "Either String Something" all working together so it seems like there should be a way to compact it a little bit: http://pastebin.com/d3428626b
15:55:22 <msteele_> Am I missing something obvious here?
16:02:17 <Saizan> msteele_: i'd start with writing a function :: MonadError e m => Either e a -> m a
16:02:59 <msteele_> I'll see where that takes me.
16:03:06 <Saizan> and one :: (e1 -> e2) -> ErrorT e1 m a -> ErrorT e2 m a
16:03:20 <msteele_> that I've got
16:03:25 <copumpkin> we need a saizanbot
16:04:48 <copumpkin> @saizan I have problem X, how should I solve it? ===> saizanbot: you should write a function ((a -> b) -> (b -> a) -> (a -> a -> (c -> b) -> a)) -> a -> a -> a -> c -> a
16:04:48 <lambdabot> Unknown command, try @list
16:05:23 <copumpkin> types are a very cool way of providing hints on solving problems without giving away the answer (unless the type is the answer :P)
16:05:25 <Saizan> fourth order, it's a whole other order?
16:05:34 <copumpkin> I wonder if that random type is even realizable
16:05:41 <Saizan> (than the third)
16:05:44 <copumpkin> @djinn ((a -> b) -> (b -> a) -> (a -> a -> (c -> b) -> a)) -> a -> a -> a -> c -> a
16:05:44 <lambdabot> f _ _ _ a _ = a
16:05:46 <copumpkin> lol
16:06:10 <Saizan> heh, quite easily :)
16:06:19 <copumpkin> I guess :P
16:06:23 <copumpkin> but I think there's a more interesting one
16:06:36 <copumpkin> probably has lots of redundant stuff though
16:11:01 <Saizan> msteele_: if it typechecks: http://pastebin.com/m2ec28d17
16:11:15 <Trinithis> @djinn (Functor f) => (a -> b) -> (f a -> f b)
16:11:15 <lambdabot> Error: Class not found: Functor
16:11:35 <Trinithis> @djinn (Monad f) => (a -> b) -> (f a -> f b)
16:11:36 <lambdabot> Error: Class not found: Monad
16:11:38 <copumpkin> all it could write is fmap
16:11:39 <copumpkin> or liftM
16:11:53 <Trinithis> I was wondering if djinn could do typeclass stuff
16:12:04 <Saizan> it can, but not constructor classes, iirc
16:12:20 <Saizan> things like Eq and Monoid should work
16:12:34 <Trinithis> What are constructor classes?
16:13:15 <Petrosian`> Trinithis: Higher kinded classes
16:13:19 <Saizan> ones for which the argument is a type of a kind different from *
16:13:34 <Petrosian`> By higher, I mean not `*' that is.
16:13:39 <Trinithis> k
16:13:49 <Trinithis> err
16:13:55 <Saizan> :k Maybe
16:13:57 <lambdabot> * -> *
16:14:00 <Saizan> :k IO
16:14:01 <lambdabot> * -> *
16:14:02 <msteele_> Saizan: It doesn't typecheck, but this will give me something to stare at and maybe make sense of.  Thanks.
16:14:04 <Trinithis> oh i see
16:14:13 <Saizan> :k Int
16:14:14 <Petrosian`> Trinithis: Monad or Functor, for example
16:14:14 <lambdabot> *
16:14:54 <Phyx-> ? is the superclass of ?? isn't it? or was it the other way around....
16:15:03 <Saizan> msteele_: i spotted "toError e = either throwError return", should be "toError e = either throwError return e"
16:15:21 <Saizan> superkind
16:15:26 <Saizan> but i don't remember..
16:15:48 * Phyx- takes a peek at the haskell wiki
16:19:49 <msteele_> @type either throwError return
16:19:51 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
16:21:12 <blackdog> ok, a philosophical question: I have a typeclass Rubyable, standing for a haskell term that can be translated back into Ruby. Some things like RB_TRUE can be trivially translated, but some things need proper marshalling. an example would be Rubyable a => Rubyable [a] - i need to convert the list into a Ruby native array. now, obviously this is changing the state of the world, in some sense - the ruby vm is "out there". In another sense, though, it's just
16:21:39 <copumpkin> you got truncated :)
16:21:43 * blackdog writes novels. 
16:21:44 <shachaf> blackdog: Cut off after "it's just".
16:21:44 <copumpkin> " sense, though, it's just"
16:21:45 <blackdog> sorry
16:22:05 <blackdog>  In another sense, though, it's just allocating a new object, just as you would in the  haskell environment. Should I make it an IO action to convert it?
16:22:06 <shachaf> Are you sure linked lists should be translated into arrays?
16:22:15 <blackdog> shachaf: no:)
16:22:25 <blackdog> but it's the most sensible mapping i can come up with at the moment
16:22:54 <pikhq> blackdog: Is it referentially transparent? If no, then make it in the IO monad.
16:23:19 <blackdog> i'm anticipating the mapping stage being relatively heavyweight - you won't be passing haskell terms around in ruby very much
16:23:45 <blackdog> pikhq: hm. i guess at the source level it's referentially transparent - it has the side effect of allocating some memory in the ruby vm, but it won't change existing things
16:24:26 <copumpkin> what's the output type of the rubify function?
16:24:32 <copumpkin> or rather the method that that class contains?
16:24:45 <copumpkin> (just wondering because some ruby values are immutable and others are not)
16:25:01 <Phyx-> is there anyway to get ghc to dump out some c code instead of the binaries? I'd like to see the code it's generating for the FFI stuff and maybe track down my bug.. or do i have to dive into the core language?
16:25:25 <mauke> you could use -fvia-C
16:25:29 <copumpkin> Phyx-: you can ask it to compile via C but don't expect to read it
16:25:31 <blackdog> copumpkin: sorry, not sure i really undestand...
16:25:33 <pikhq> -C
16:25:47 <blackdog> class Rubyable a where toRuby :: a -> RValue fromRuby :: RValue -> a
16:25:52 <blackdog> is the typeclass
16:25:56 <copumpkin> blackdog: ah
16:26:10 <Phyx-> ah ok, will try that mauke , pikhq
16:26:24 <copumpkin> blackdog: well I was just wondering if I did x = toRuby [1..10] and then passed that into ruby, which then proceded to modify the Array on its side
16:26:29 <msteele_> Saizan: This seems to do the job.  The original seems more readable, but I'll see what happens when I add special handling for whatever IOError 'readFile' might throw: http://pastebin.com/d71e934c8
16:26:30 <Makoryu> Phyx-: The C code is generated with approximately zero regard for readability. Don't get your hopes up.
16:26:33 <pikhq> And keep in mind that the assembly resulting from compiling that C gets munged to remove most of the manipulation of the C stack.
16:26:36 <copumpkin> blackdog: would my x have changed?
16:26:39 <Makoryu> Phyx-: It would be more productive to look at the Core
16:26:52 <mauke> Phyx-: how big is your testcase?
16:26:58 <blackdog> copumpkin: haven't actually thought much about calling ruby from haskell
16:27:04 <blackdog> there doesn't seem much point
16:27:10 <copumpkin> oh, I see
16:27:14 <Phyx-> Makoryu: i'm interested in the way it handles pointers, or Ptr values, as my heap gets corrupted when reading certain values
16:27:14 <pikhq> (the munging script, BTW, is written in Literate Perl. Have "fun" figuring that out)
16:27:41 <Phyx-> mauke: it's pretty small, 1 - 2 lines
16:27:46 <Phyx-> of haskell code
16:27:53 <blackdog> but i might do something like call func:: blah -> [a]
16:28:09 <blackdog> in ruby code, and it'd return an array to the ruby
16:28:30 <Saizan> msteele_: what's the type of resultToEither?
16:28:32 <blackdog> copumpkin: just trying to make the interface a bit more seamless - atm you have to dick around with a bunch of unpackaging
16:28:40 <copumpkin> yeah, makes sense
16:28:49 <copumpkin> in that case it seems safe to not put it in IO
16:29:02 <copumpkin> if it's the kind of thing you'll only ever return
16:29:03 <msteele_> Saizan: resultToEither :: Result a -> Either String a
16:29:04 <copumpkin> and then not touch again
16:29:09 <msteele_> Saizan: It's part of the JSON library
16:31:04 <msteele_> Saizan: I'll continue to think about this.  I'm basically trying to combine the error handling of IO exceptions and parsing errors into one construct.
16:31:54 <Makoryu> pikhq: So *that's* why GHC has Perl as a build dependency?
16:32:28 <Saizan> msteele_: yeah, maybe you want to decide which should be the proper error type to use first
16:32:41 <pikhq> Makoryu: Yup.
16:32:47 <Saizan> msteele_: and then write two different versions of toError, one for IO and one for Either
16:34:19 <Saizan> msteele_: though i'd try to keep IO as separate as i can from parsing
16:45:46 <msteele_> Saizan: Okay, I've got something I'm happy with now.
16:45:49 <msteele_> Saizan: http://pastebin.com/d3651664c
16:46:02 <msteele_> Saizan: I want my error type to be ErrorT String IO a
16:46:38 <msteele_> Saizan: For all other functions that return errors in some form I make a fromBlahBlah :: Yadda yadda a -> ErrorT String IO a
16:49:24 <mightybyte> Does the +RTS -s runtime option impose significant memory/CPU overhead?
16:49:49 <Saizan> msteele_: why not "fromIO msg = ErrorT . fmap (either (const $ throwError msg) return) . try"
16:50:05 <Saizan> msteele_: fromIO :: String -> IO a -> ErrorT String IO a
16:50:38 <jfoutz> wow.
16:51:19 <Saizan> msteele_: hah, that doesn't typecheck :)
16:51:28 <msteele_> Saizan: I get the point, though.
16:51:30 <Saizan> fromIO msg = ErrorT . fmap (either (const $ Left msg) return) . try
16:51:55 <Saizan> ?type  ErrorT . fmap (either (const $ Left msg) return) . Control.Exception.try
16:51:57 <lambdabot> Not in scope: `msg'
16:52:00 <Phyx-> @type fromIO msg = ErrorT . fmap (either (const $ Left msg) return) . try
16:52:02 <lambdabot> parse error on input `='
16:52:06 <Saizan> ?type  \msg -> ErrorT . fmap (either (const $ Left msg) return) . Control.Exception.try
16:52:08 <lambdabot>     Ambiguous type variable `b' in the constraint:
16:52:08 <lambdabot>       `GHC.Exception.Exception b'
16:52:08 <lambdabot>         arising from a use of `Control.Exception.Base.try'
16:52:16 <Saizan> ?type  \msg -> ErrorT . fmap (either (const $ Left msg) return) . Control.OldException.try
16:52:18 <lambdabot> forall a b. (Error a) => a -> IO b -> ErrorT a IO b
16:53:22 <Saizan> ?type Control.Exception.try
16:53:24 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
16:53:27 <Saizan> ?type Control.OldException.try
16:53:28 <lambdabot> forall a. IO a -> IO (Either Control.OldException.Exception a)
16:53:55 <jfoutz> I that one liner better form?
16:54:06 <jfoutz> er Is that one liner better form?
16:54:41 <Saizan> better than what?
16:54:54 <jfoutz> the fromIOError in the paste.
16:56:05 <Saizan> well, i've kind of composed fromIOError with try and inlined its definition, so it's naturally a bit more complex
16:56:13 <msteele_> Saizan: I'll actually need to look at those IOError objects to decide what 'msg' should be.  Perhaps I should have one function called load :: FilePath -> ErrorT String IO String that simply pulls in the contents of the file.
16:56:41 <msteele_> Saizan: ... and another function, parseDoc :: String -> ErrorT String IO (Document Name) that handles the parsing
16:56:52 <Saizan> msteele_: perhaps, or have a fromIO that takes a function (IOError -> String)
16:57:21 <msteele_> Saizan: Ah! yes that would be better.
16:58:07 <Saizan> msteele_: it all depends on how often you've situations like these i guess
16:58:47 <msteele_> Saizan: Well the only two situations where I'll have to deal with IOErrors that I know of are when I load and save my datafile.
16:59:29 <Saizan> jfoutz: fromIO f m = fromIOError f =<< liftIO (try m) -- alternative definition
17:01:19 <jfoutz> yeah... i'm starting to get comfortable with the syntax, but have a little trouble with where to actually break up code. I see moving the try means you could decouple the source... read from a file or maybe a socket if you change your mind later.
17:01:49 <Saizan> msteele_: i'd still write fromIO probably
17:01:56 <jfoutz> reading code and seeing people suggest improvements seems like a good way to think about what might be wrong with my code. :)
17:02:31 <jfoutz> (sorry to interrupt)
17:03:33 <Saizan> well if you don't want to have two levels of error handling wrapping your IO actions in try seems natural
17:06:26 <msteele_> Yes, and what would be nice is if I could wrap all calls to IO that way and just forget about the possibility of some exception popping up and crashing my application.
17:09:11 <Saizan> mh, you could write your own ErrorT monad with a different MonadIO instance
17:09:56 <msteele_> hmm.. I like that idea.
17:10:01 <sm> I'm polling a 100-item craigslist feed using download/feed/xml. Each time I do, it uses a chunk of heap and seems to keep growing
17:10:13 <jfoutz> it seems like you could be sneaky and define a fromM a -> ErrorT String m (Document Name) as well as a fromIO, and be able to swap out fromIO with the fromM... just use a string right in your source for testing, and swich to IO at the end. the try seems to let you split along sources, you could make load take a (IO String) and pass in either a (readFile "myfilepath") or (readSocket ... whatever)
17:10:20 <sm> I have profiled some and if I had to guess I'd say it's growing in the xml parsing
17:10:21 <jfoutz> wich is just what you said.
17:10:25 <msteele_> I'll have to think about how to supply these 'msg' variables, though.
17:10:40 <sm> what's a more efficient way I could fetch a feed ?
17:10:48 <sm> (and parse ?)
17:11:03 <jfoutz> Saizan: it seems like your changed pushed it much more naturaly to a combinator sort of structure. that's neat.
17:11:41 <msteele_> When I'm loading files I need to check for isDoesNotExistError, isAlreadyInUseError etc. and create a friendly string for each case.
17:12:33 <msteele_> ... so if there's a clever MonadIO instance I'll have to find some way to deal with that.
17:13:30 <sm> my bloaty feed-fetching code: http://gist.github.com/168167
17:13:41 <msteele_> Saizan: I need to go now, but will probably work on this a bit more in a few hours.  Thanks for all your suggestions.
17:13:51 <Saizan> msteele_: cheers :)
17:14:25 <msteele_> Saizan: If you're curious, this is all going into GUI.hs at http://github.com/mikesteele81/Phone-Directory/tree/master
17:31:44 <kpreid> What's the currently popular and/or good choice for creating GUI applications in Haskell?
17:31:52 <drwho> hi I need some help with type definitions
17:32:01 <Makoryu> kpreid: GTK2
17:32:08 <Nafai> kpreid: Yeah, gtk2hs is great
17:32:12 <Makoryu> It's popular but I don't know that it's necessarily good
17:32:29 <Makoryu> It would be nice if it was less obnoxious to install on OS X
17:32:52 <blackdog> hey, are there any ruby hackers in here? just had a weird epiphany about the relationship between monkeypatching and typeclasses... trying to work out if it's completely facile or not.
17:33:22 * blackdog figures he has a better chance of finding a ruby hacker in #haskell than a haskell hacker in #ruby...
17:33:30 <Makoryu> blackdog: I used to be into Ruby, but I haven't written much of anything since last year
17:33:48 <blackdog> Makoryu: seduced by the monoidal side of the force?
17:33:51 <Makoryu> Yup
17:34:01 <drwho> ah wait nevermind
17:34:32 <Phyx-> i never could get into ruby...
17:34:40 <blackdog> anyway, i was just thinking - that whole "yay freedom i can add a .whoFarted() method to Strings" thing is basically just typeclasses without any type rigor...
17:34:45 <shachaf> Not wxHaskell?
17:35:18 <mrsolo> blackdog: because it is monkeypatching, not typeclasses
17:35:29 <mrsolo> i don't think you can compare those two
17:35:33 <Phyx-> shachaf: wxHaskell isn't that actively maintained i think, or wasn't for some time, gtk2hs atm is more usable i'd say
17:35:39 <blackdog> mrsolo: ok, so what are the differences?
17:35:51 <blackdog> the intent is the same, right? all about keeping open-world assumptions?
17:36:08 <mrsolo> well language paradigm is totally different for one
17:36:24 <Makoryu> blackdog: Yeah, the moment I realized OOP was (more or less) obsolete was the moment I mentally compared open classes to Haskell typeclasses
17:36:24 <mrsolo> one is adding method to a class or an object under ruby
17:36:59 <blackdog> mrsolo: loosen the categories a bit. sure, they're implemented different ways, but they have the same goal under two different systems.
17:37:11 <Makoryu> Now if we could just convince the Python people to do it that way...
17:37:35 <blackdog> might see if i can work it into the talk i'm giving to the RoR group
17:37:46 <mrsolo> blackdog: you can say all programming langauges basically achieve the same goal if you follow that type of logic
17:37:52 <blackdog> have a slide titled "Provably Safe Monkeypatching" or something equally provocative
17:38:11 <blackdog> mrsolo: ok, so a little less loose than that :)
17:38:23 <blackdog> i'm talking about overriding principles here
17:38:53 <blackdog> the major difference i can see is that monkeypatching isn't typesafe, and that's more or less a consequence of being in a dynamically typed language
17:39:03 <mrsolo> blackdog:  nothing new there..few people make some aregument about typeclasse is just some light weight oo classe
17:39:25 <blackdog> mrsolo: sorry, not following.
17:40:16 <mrsolo> one can argue that haskell type is no more than say java class
17:40:18 <blackdog> i'm certainly not trying to say you can reduce typeclasses to OO discipline, just that the intent is to provide extensibility and pluggability
17:40:35 <mrsolo> or 'closure' is just another way to do ..method
17:41:09 <sshc> how do I get the "decimal part" of a floating point number?
17:41:24 <blackdog> sshc: truncate and subtract?
17:41:34 <mrsolo> beside monkeypatching is the product of ruby class/object isn't 'closed' hmm doesn't C#/java have that kind of feature now?
17:41:37 <sshc> blackdog: truncate?
17:41:44 <blackdog> floor, actually
17:41:49 <sshc> oh
17:41:59 <blackdog> sorry, brainfart :)
17:42:17 <mauke> :t snd. properFraction
17:42:18 <lambdabot> forall b. (RealFrac b) => b -> b
17:42:25 <mauke> > snd . properFraction $ pi
17:42:27 <lambdabot>   0.14159265358979312
17:42:55 <pikhq> :t snd
17:42:57 <lambdabot> forall a b. (a, b) -> b
17:43:03 <pikhq> Thought so.
17:45:27 <blackdog> mrsolo: I'm not sure, I haven't played with java for a while. C# never.
17:47:28 <mrsolo> ya look like C# 3.0 can do duck typing now
17:47:28 <mrsolo> http://weblogs.asp.net/scottgu/archive/2007/03/13/new-orcas-language-feature-extension-methods.aspx
17:47:38 <dibblego> is this the Java/C# interfaces are in some way similar to type classes myth again?
17:48:10 <mike-burns> Pretty sure SimonPJ started that "myth".
17:48:15 <mike-burns> (I still don't believe it's a myth.)
17:48:26 <dibblego> mike-burns, link?
17:48:27 <mrsolo> or rather C# 4.0
17:48:33 <dibblego> (it's not a matter of belief)
17:48:37 <blackdog> dibblego: urm. I started at monkeypatching in ruby, and noted that it's somewhat similar to typeclasses, in that it's about having open-world assumptions
17:49:07 <blackdog> at some extremely loose sort of level of comparison - ie, some of the things that are done with monkeypatching could be easily translated into typeclasses
17:49:11 <mike-burns> dibblego: You might be able to find this faster than I: it's an overview of Haskell presentation he (I think it was SimonPJ) gave at a non-Haskell conference.
17:49:30 <dibblego> mike-burns, I remain extremely sceptical
17:49:41 <dibblego> (since I doubt he would make that mistake)
17:49:54 <mike-burns> Ah I can't discuss this now; bad timing. Later, I promise!
17:49:58 <dibblego> bye
17:50:41 <blackdog> dibblego: i don't know enough about java interfaces to make a comment either way
17:52:11 <dibblego> blackdog, once it is recognised that the essential part of type classes is the implicit selection based on type, then any comparison to Java interfaces is only useful to the extent that they are both language features -- the similarites stop there
17:56:11 <blackdog> dibblego: you may have the arrow the wrong way around in this case - I'm not trying to suggest monkeypatching is more capable than typeclasses, or even that they're equivalent: just that in many of the cases where monkeypatching is used, a typeclass could be used to good effect.
17:56:32 <dibblego> blackdog, there is no arrow
17:57:38 <Saizan_> there are some similarities
17:57:46 <blackdog> perhaps we're arguing different things.
17:59:00 <dibblego> I only argue that any similarities are much weaker than is often made out to be
17:59:40 <dibblego> also, since this has come up before, is to tell newcomers that OO interfaces and type classes are similar is unsatisfactory
18:00:28 <Saizan_> the discussion here was quite different though :)
18:00:42 <dibblego> that's why I asked :)
18:01:03 <Peaker> I like saying that type-classes are more powerful, more correctly done than OO interfaces :) They can generally do everything OO interfaces do, and more
18:01:23 <moonpatrol> how did all you guys learn so much?
18:01:48 <blackdog> ok, we're definitely arguing different things, then. I'm not talking about the standard OO interface stuff, i'm talking about the Ruby pattern of adding special behaviour for class B in the file for class A.
18:01:49 <Peaker> moonpatrol, read, experiment, sit in #haskell, repeat :-)
18:02:25 <dibblego> blackdog, yes that requires significant head bending too, to the extent that it is also somewhat misleading
18:02:27 <Peaker> blackdog, that's kind of like creating instances separately from the types, except less structures
18:02:40 <blackdog> Peaker: yeah, exactly.
18:02:43 <Saizan_> blackdog: yeah, the ability to extend the interface of a type with more methods from outside the definition of that type is quite similar
18:02:51 <Peaker> less structured, that is
18:02:57 <blackdog> the crucial part of it is the open world assumption
18:06:21 <Saizan_> mh, why is monkeypatching so horrible though? bad encapsulation? mutation?
18:06:44 <Saizan_> (by horrible i mean that i hear horror stories about it, never really used ruby)
18:07:00 <blackdog> Saizan_: it does make debugging pretty tricky sometimes
18:07:03 <dibblego> we used RoR once, mutation + monkeypatching was probably the biggest failure
18:07:09 <Makoryu> Saizan_: Part of it is the arcane ways in which monkeypatchers compensate for Ruby's single dispatch system
18:07:17 <dino->  Is this monkeybusiness at all like aspect-oriented?
18:07:19 <blackdog> you'll get an error message for some class, but the actual method will be somewhere else entirely
18:07:40 <Makoryu> And also the fact that any modification to a class gets the same scope as that class
18:07:54 <michaelfeathers> Saizan: It's nicer to have designed extension points.  Monkeypatching can be useful, but it can make the source code a lie.
18:08:00 <Makoryu> If you alter a class in module A, then you might disrupt behavior in (completely unrelated) module B
18:09:14 <Makoryu> Haskell instead allows you to confine an instance to its module
18:09:32 <Saizan_> well, not really
18:09:40 <Saizan_> the idea is that instances should be global
18:09:53 <Saizan_> though it also doesn't allow you to modify a method
18:09:53 <Makoryu> Saizan_: At least, you can confine the methods.
18:09:57 <Saizan_> only adding a new one
18:10:01 <michaelfeathers> I kind of wish there was an idea of local instances.
18:10:01 <Phyx-> I do however wish that instances aren't always exported
18:10:05 <dibblego> Saizan_, it's the mutation part that raises issues
18:10:55 <michaelfeathers> Maybe I'm not doing it right, but they'd be handy in QuickCheck.. local instances of Arbitrary
18:11:12 <dibblego> michaelfeathers, e.g.?
18:11:45 <Saizan_> well, you can use newtypes or forAll
18:11:59 <michaelfeathers> Like I said, I may not be doing it right, but it would be nice to have more than one generator for a type.  I know you can do the newtype thing.
18:12:00 <dibblego> @type (==>)
18:12:02 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
18:12:04 <Saizan_> though i agree it feels like something is lacking
18:12:18 <dibblego> michaelfeathers, yeah, you use either newtype, ==> or forAll
18:33:28 <roconnor> > let enumerateInterleaved = 0 : init (concat [[-x, x] | x <- [-1,-2..]]) in enumerateInterleaved :: [Int8]
18:33:30 <lambdabot>   [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13...
18:33:39 <roconnor> > let enumerateInterleaved = 0 : init (concat [[-x, x] | x <- [-1,-2..]]) in length (enumerateInterleaved :: [Int8])
18:33:40 <lambdabot>   256
18:34:01 <roconnor> > let enumerateInterleaved = 0 : init (concat [[-x, x] | x <- [-1,-2..]]) in drop 251 (enumerateInterleaved :: [Int8])
18:34:03 <lambdabot>   [126,-126,127,-127,-128]
18:34:38 <roconnor> ah, init
18:35:29 <glguy> @seen dolio
18:35:29 <lambdabot> dolio is in #ghc, #haskell-in-depth, #haskell-blah and #haskell. I don't know when dolio last spoke.
18:35:39 <mauke> preflex: seen dolio
18:35:40 <preflex>  dolio was last seen on #haskell-blah 48 minutes and 55 seconds ago, saying: The icon looked a bit sexier.
18:35:42 <copumpkin> hmm
18:37:35 <copumpkin> roconnor: playing with that enumerable code I posted earlier?
18:38:29 <roconnor> copumpkin: I thought there was a bug
18:38:36 <copumpkin> ah
18:38:47 <copumpkin> I haven't exactly tested the code much, so it's quite possible :)
18:38:51 <roconnor> instead it is just system dependent
18:39:12 <copumpkin> how so?
18:39:16 <copumpkin> oh
18:39:18 <roconnor> only works for systems that uses 2's complement
18:39:21 <copumpkin> yeah
18:39:23 <roconnor> :P
18:39:49 <copumpkin> yeah, it was a quick hack really
18:41:06 <copumpkin> roconnor: why is Enumerable wrong? I was asking yesterday whether (==) should be decidable
18:41:20 <copumpkin> a couple of people said no, so I dropped the necessity for finiteness
18:41:41 <roconnor> . . .
18:43:45 <edwardk> copumpkin: enumerable?
18:43:58 <copumpkin> edwardk: a silly module I threw together last night
18:44:02 <copumpkin> http://www.reddit.com/r/haskell/comments/9arws/a_real_enumerable_class_any_suggestions/
18:44:44 <BMeph> Finitude, dude. ;)
18:45:05 <roconnor> copumpkin: did a couple of people consist of the singletion set { jkff } ?
18:45:14 <copumpkin> roconnor: maybe :P
18:45:19 <copumpkin> roconnor: I thought it was more than one
18:45:25 <copumpkin> but maybe I was just lonely and hearing voices
18:46:02 <roconnor> I interpret what he said as a partial (==) is better than a wrong (==)
18:47:51 <edwardk> i just realized that i was typing my entries in this conversation on two channels ;)
18:48:27 <copumpkin> roconnor: I can still return false for Integer domains
18:48:40 <copumpkin> (for equality)
18:48:46 <edwardk> copumpkin: ick
18:48:48 <copumpkin> :P
18:48:51 <edwardk> then you lose reflexivity
18:48:58 <roconnor> copumpkin: how?
18:49:12 <edwardk> you can cheat and ask for a stable name and compare that perhaps =)
18:49:33 <copumpkin> *Enumerable> (+(1 :: Integer)) == (+2)
18:49:33 <copumpkin> False
18:49:56 <edwardk> @seen dolio
18:49:56 <lambdabot> dolio is in #ghc, #haskell-in-depth, #haskell-blah and #haskell. I don't know when dolio last spoke.
18:50:03 <copumpkin> *Enumerable> (even :: Integer -> Bool) == odd
18:50:03 <copumpkin> False
18:50:12 <roconnor> copumpkin: why does that work?
18:50:35 <roconnor> oh
18:50:36 <roconnor> right
18:50:40 <roconnor> but it can never return True
18:50:44 <copumpkin> yeah
18:50:52 <edwardk> hence why i advocated for the stable name =)
18:51:14 <copumpkin> I'm not a fan of that :P
18:51:18 <edwardk> heh
18:51:28 <Rotaerk> hmm
18:51:30 <copumpkin> being able to say something is not equal is better than saying nothing at all, it seems
18:51:33 <roconnor> I suggest sticking with instance (Compact a, Eq b) => Eq (a -> b)
18:51:38 <edwardk> yeah
18:51:43 <edwardk> i'm with roconnor on this
18:51:44 <roconnor> copumpkin: I think saying nothing at all is better.
18:51:46 <Rotaerk> @type sum . map read . words
18:51:48 <lambdabot> forall a. (Num a, Read a) => String -> a
18:51:52 <copumpkin> :(
18:52:00 <edwardk> Eq should define an equivalence relation, and you can't have that without reflexivity.
18:52:16 <roconnor> roconnor: in my Few Digits implemenation of exact reals, I have a partial equality like you have.  But only because Num forced me. :(
18:52:26 <copumpkin> > (0 / 0.0) == (0 / 0)
18:52:27 <lambdabot>   False
18:52:46 <pikhq> Well, if you just get a halting oracle, you can result in True, too.
18:52:47 <roconnor> edwardk: I think Eq might actually be a PER
18:52:58 <roconnor> given it's behaviour on NaN
18:52:59 <copumpkin> edwardk: like that equivalence relation? :P
18:53:01 <roconnor> its
18:53:32 <edwardk> roconnor: yeah, NaN's behavior is my main problem with Eq =)
18:54:00 <Rotaerk> > let sumFile = sum . map read . words
18:54:01 <edwardk> copumpkin: just because the ieee 754 committee smoked crack doesn't mean you should take up the habit ;)
18:54:01 <lambdabot>   not an expression: `let sumFile = sum . map read . words'
18:54:07 <dolio> What up?
18:54:09 <Rotaerk> > sumFile = sum . map read . words
18:54:10 <lambdabot>   <no location info>: parse error on input `='
18:54:22 <edwardk> dolio: not much, started using bytestring-show the other day
18:54:24 <copumpkin> edwardk: well, the code isn't wrong, it just can't terminate on some functions
18:54:29 <dolio> Oh yeah? Find any bugs?
18:54:56 <edwardk> dolio: nah, just found it funny that you capitalize Ascii with the initial cap and UTF with all caps ;)
18:54:59 <Rotaerk> why does this automatically become String -> Integer:  sumFile = sum . map read . words?
18:55:10 <Rotaerk> i.e. why does it pick Integer over the other numerics
18:55:29 <copumpkin> roconnor: where's this Compact class come from? I can't see it in the linked page
18:55:40 <dolio> Yeah, I guess that's inconsistent.
18:55:49 <copumpkin> roconnor: and is Integer an instance of it?
18:56:13 <dolio> I guess my brain thinks of "Ascii" like it thinks of "Lisp" now.
18:56:18 <edwardk> also would an Ascii and UTF8 typeclass make more sense so putAscii and putUTF8 could put both Strings and Chars?
18:56:46 <edwardk> dolio: heh, sok, i adopted the same convention to avoid having to think about which API i was calling. ;)
18:57:20 <edwardk> then one could, in a pathological sense also add Ascii and UTF8 instances for Data.Text.Text ;)
18:58:47 <dolio> Well, you could do that. But they're mainly around as building blocks, like showChar.
18:58:48 <edwardk> the only other issue that came to mind was that the module had somewhat unclear intentions as to whether it should be imported qualified or unqualified. By naming the main class 'Show' you force it to be imported qualified or for the user to hide that class on import, but all of the other methods (except show) in that module look like they are engineered for unqualified import
18:59:49 <edwardk> in any event, switching to your code let me throw out a module worth of mine, so its all good ;)
19:00:13 <dolio> And then putAscii/UTFStr are like showString.
19:00:50 <moonpatrol> does anyone here actually use hugs/winhugs ?
19:00:52 <dolio> Or, I suppose more accurately, they're like putFoo from the binary package.
19:01:07 <copumpkin> moonpatrol: not many people if any
19:01:30 <dolio> They're for implementing show(p) stuff, which is what you're actually supposed to use, not putFoo directly.
19:01:35 <edwardk> yeah. I kind of figured. i mostly just use it to define a method for 'unlex'ing partially lexed input for error checking, so its no big deal for me
19:01:36 <moonpatrol> so does the majority use.. ghc i think?
19:02:02 <edwardk> dolio: in my case i'm using this inside of a utf8 bytestring based pretty printer, so i'm not using any of your machinery for its stated purpose ;)
19:02:08 <copumpkin> moonpatrol: yup
19:02:33 <edwardk> i just recognized when i was done writing all of my code that your code was basically alpha equivalent to it
19:02:35 <moonpatrol> ahh okay, thanks
19:04:18 <dolio> Well, the put* stuff doesn't necessarily even belong to the same functionality as the Show stuff. It's more like stuff that could go in the Binary package that I need to implement the latter.
19:04:36 <edwardk> yeah
19:04:50 <edwardk> though, like Text.Show you need something to build your show instances out of
19:05:14 <edwardk> and Data.Binary is focused on using that monad for a very different purpose
19:05:28 <edwardk> the only thing i really had to do was switch my code around to work with Put rather than with Builder
19:05:36 <edwardk> since I was just using the Builder monoid instead
19:06:08 <dolio> Yeah. I didn't really look at that. How well supported is using that directly?
19:06:58 <edwardk> Builder.fromLazyByteString ... `mappend` fromUTF8 "Hello\x7fff' `mappend` ...
19:07:19 <edwardk> since i had made my own builder i was able to make Reducer instances for Char, String, Lazy and Strict Bytestrings, etc.
19:07:29 <edwardk> but they lacked the optimization for the ASCII case
19:07:32 <edwardk> which is what won me over
19:07:45 <edwardk> since upon reflection most of my code was ascii
19:07:47 <dolio> Anyhow, I probably won't switch it out, even though I could. At this point I'd say bytestring-show is kind of legacy.
19:07:59 <dolio> Since text is what you should be using anyway.
19:08:29 <dolio> And it has (or should have) its own Text -> ByteString for when you actually want to output something.
19:08:53 <edwardk> bytestrings fit my purposes better at the moment, because data.text can't be efficiently sliced
19:09:26 <edwardk> because they have to deal with surrogate pairs and they don't expose their internal workings through any module you can get at if you aren't bos.
19:09:45 <edwardk> bytestrings at least provide data.bytestring.internal
19:09:46 <copumpkin> Data.Text.InternalDontUseThisUnlessYoureBosKthx
19:09:46 <dolio> Heh.
19:10:31 <edwardk> in my case i need to build up fingertrees of bytestrings and occasionally slice out a sub-bytestring, which 99% of the time will be entirely taken from one of the bytestrings and can be done with no copying
19:10:42 <edwardk> but i can't perform that operation on Text =(
19:11:05 <copumpkin> have you asked bos for a nice interface to the back-end?
19:11:08 <Saizan_> Rotaerk: the Monomorphism Restriction and defaulting
19:11:08 <edwardk> my first pass tried to use Text, but i got no sharing, even though i was going to have to keep the text fragments around indefinitely anyways
19:11:29 <Rotaerk> ah thanks
19:11:37 <edwardk> copumpkin: well, the other thing comes down to how i use it,. if i have to pay for expensive indexing because of surrogate pairs anyways, what does data.text really offer me?
19:11:58 <edwardk> all it does it double my memory consumption for the common case
19:12:22 <copumpkin> what if I'm japanese?
19:12:27 <edwardk> the main thing is you can argue that letting it stride along can fuse beter than i can when striding along a utf8 encoded bytestring
19:12:54 <edwardk> copumpkin: thats fine, but you aren't my common case then ;) that and your keywords will still be drawn from my small pool of ascii chars anyways ;)
19:16:20 <edwardk> in general utf16 is a pain in the ass because all byte combinations can occur in the source. if i'm going to pay for all the nonsense, i wonder if an SCSU based Text-like module would make more sense =)
19:16:57 <roconnor> copumpkin: Integer is not compact.  I don't know how to define the Compact class:  http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/ might have some clues.
19:17:31 <copumpkin> roconnor: so because == can't return true, it shouldn't even try to return false?
19:18:42 <edwardk> copumpkin: correct
19:18:44 <copumpkin> I've read that post and it's interesting, but I'm not really sure how to apply it here
19:19:12 <copumpkin> edwardk: hmm
19:21:14 <copumpkin> so maybe Eq is the wrong place to put it
19:21:18 <edwardk> your existing instance makes me wince a little but i could compare it to the instance of Eq on [a] -- which is partial in that you can't apply it to an infinite list, but your integer case only forms a semialgorithm in that it can never yield a positive result for equality, which makes it worse than the [a] case, which you can just blame on data vs. codata
19:22:38 <copumpkin> hrm
19:23:42 <copumpkin> so an algorithm of that nature simply should not be written?
19:24:18 <roconnor> lest people be tempted to use it
19:25:14 <copumpkin> I could write one with a maximum search depth that returns Just False or Nothing :P
19:25:45 <edwardk> you could make a partiality monad that lets people run it and obtain a request for more time that they can choose to resume =)
19:25:55 <copumpkin> lol
19:26:23 <SubStack> sounds like a challenge
19:26:44 <copumpkin> SubStack: feel free to write a full Eq instance for Eq a => Integer -> a
19:27:12 <edwardk> substack its not too bad. data Partial a = Return a | Cont (Partial a)
19:27:16 <copumpkin> they be hatin' cause I can never return True
19:28:45 * Saizan_ is tempted to blame this on data vs. codata
19:28:58 <copumpkin> edwardk said I couldn't even do that :(
19:29:01 <copumpkin> he just be hatin :(
19:29:14 <copumpkin> :P
19:29:15 <edwardk> saizan: nah its deeper than that, because if it was data vs. codata he could get some partial positives
19:29:33 * copumpkin hardcodes a special case for stable names
19:29:35 <edwardk> its just decidability vs. semidecidability
19:29:38 <copumpkin> so that I can return True occasionally
19:29:42 <copumpkin> to satisfy edwinb
19:29:45 <copumpkin> edwardk even
19:29:47 <Saizan_> (->) is too general, we want an inductive one for finite functions :P
19:29:47 <edwardk> copumpkin: heh
19:29:58 * SubStack can't decide enough as it is
19:29:59 <roconnor> aaaaaaaaaaaaaaaaaaaaaahhhhhhhhh
19:30:07 <copumpkin> lol
19:30:22 <copumpkin> roconnor: what's up?
19:30:30 <edwardk> copumpkin: with the stablenames i might actually use it. i'll feel guilty.. i'll feel dirty, but i might use it ;)
19:31:02 <copumpkin> edwardk: I'd still want to return Nothing if the stable names didn't match
19:31:11 <copumpkin> Just True if they do, and Just False if the search false
19:31:19 <edwardk> if the stablenames don't match then you fall back on semidecision ;)
19:31:24 <copumpkin> yeah :P
19:32:24 * copumpkin wonders if the stable names were enough to send roconnor round the bend
19:33:15 <copumpkin> edwardk: feel free to add that to the gist :P
19:33:31 <copumpkin> edwardk: pity (==) must return Bool :/
19:34:15 <edwardk> newtype Stable a = Stable a deriving (Show,Read,Data,Typeable); instance Eq (Stable a) where (==) = unsafeDupablePerformIO $ liftM2 (==) makeStableName makeStableName
19:34:44 <Saizan_> not even with seq?
19:34:52 <edwardk> Saizan_: living on the edge ;)
19:34:55 <copumpkin> lol
19:35:07 <edwardk> newtype ReallyStable a = ReallyStable a ...
19:35:21 <copumpkin> edwardk: any ideas on the other thing I wanted to do with Enumerable?
19:35:35 <copumpkin> of a regex/grammar library that would make it possible for me to enumerate the strings in the languages
19:36:22 <edwardk> well, generate your regex, then reify it as a type and call that Enumerable
19:37:10 <copumpkin> ah I guess I would need to do that
19:37:13 <copumpkin> grr
19:37:46 <edwardk> go 'reflection' module ;)
19:38:03 * copumpkin fails
19:38:09 <edwardk> btw- i'm thinking i might take that Lambda newtype and rewrite reflection with it based on the reply you got on -cafe.
19:38:28 <copumpkin> yeah, that was a nice idea
19:38:47 <copumpkin> I haven't played with reflection
19:43:16 <roconnor> what is reflection?
19:44:27 <edwardk> roconnor: reifies a term as a type, protected by universal quantification, so you can reflect it back down and rely on unification to ensure that its shared consistently.
19:44:46 <edwardk> roconnor: think like how ST s uses universal quanitification to keep little imperative universes apart
19:44:58 <roconnor> what sorts of terms?
19:44:59 <edwardk> reflection does the same thing with an arbitrary piece of data
19:45:42 <edwardk> anything. it cheats and gets a stable pointer to it, then marshals the stable pointer once as a type, then turns it back into the original term, and does so in such a way that you only pay that cost once, and after that the thunk is shared
19:46:31 <edwardk> so basically it starts with reifying integers, then lists of integers, then uses that to reify storables, and since stable pointers are storable it can reify anything
19:46:49 <copumpkin> :o
19:48:03 <edwardk> so you can say reify 2 (\a -> reflect a + reflect a) -- and get 4 -- but more interestingly you can pass that type around like an implicit configuration for things like say a modular arithmetic ring that shares the same modulus safely, etc.
19:48:33 <jbender> anyone have a quick and dirty explanation of why partial application is "the tits"
19:48:48 <copumpkin> jbender: not sure I've heard it put that way before
19:48:54 <copumpkin> > map (+1) [1..10]
19:48:55 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:49:27 <jbender> copumpkin: I made a parse transform for erlang to support partial application and I'm posting it on my blog
19:49:38 <jbender> just trying to fill out the "who you should care" bit
19:49:48 <edwardk> roconnor: http://www.mail-archive.com/haskell-cafe@haskell.org/msg57747.html is an example of using it to dynamically construct a Monoid out of a value and a binary operation
19:49:54 <copumpkin> > map (2^) [1..10]
19:49:55 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
19:49:56 <jbender> ?* "why you should care"
19:49:56 <lambdabot> Maybe you meant: . ? @ v
19:50:59 <roconnor> edwardk: I don't know much about stable pointers.  They sound unsafe. :)
19:51:09 <edwardk> roconnor: its done safely.
19:51:27 <edwardk> roconnor: a stable pointer just makes up a pointer that won't change until its freed, so you can hand it off to c
19:51:29 <roconnor> dynamically constructing a Monoid instance does sound useful.
19:51:58 <jbender> copumpkin: eff it, I'm not here to convince people of why things are awesome
19:52:18 <copumpkin> jbender: my examples were meant to show why it's awesome
19:52:22 <edwardk> all i (well, original oleg and cc shan) do is make it last long enough to turn it into a type, get a thunk for 'reflect' and get the value at that stable pointer, and free it so i don't leak resources.
19:52:26 <copumpkin> jbender: but there are probably more compelling examples :)
19:52:35 <edwardk> er originally
19:55:20 <roconnor> @wn redux
19:55:32 <lambdabot> *** "redux" wn "WordNet (r) 2.0"
19:55:32 <lambdabot> redux
19:55:32 <lambdabot>      adj : brought back; "the Victorian era redux"; "`Rabbit Redux' by
19:55:32 <lambdabot>            John Updike" [syn: {redux(ip)}]
19:56:01 <Cale> @wn redex
19:56:02 <lambdabot> No match for "redex".
19:56:09 <Cale> @wn redox
19:56:10 <lambdabot> *** "redox" wn "WordNet (r) 2.0"
19:56:10 <lambdabot> redox
19:56:10 <lambdabot>      n : a reversible chemical reaction in which one reaction is an
19:56:10 <lambdabot>          oxidation and the reverse is a reduction [syn: {oxidation-reduction},
19:56:10 <lambdabot>           {oxidoreduction}]
19:57:03 <Cale> @foldoc redex
19:57:03 <lambdabot> *** "redex" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:57:04 <lambdabot> redex
19:57:04 <lambdabot>  
19:57:04 <lambdabot>         Reducible Expression.  An expression matching the left hand
19:57:04 <lambdabot>         side of a {reduction rule} or definition.
19:57:05 <lambdabot>  
19:57:13 <BMeph> Is there a paper that explains how GHC represents types?
19:57:57 <edwardk> BMeph: its scattered over a bunch of papers by now
19:58:14 <edwardk> BMeph: but look up the system Fc stuff by ChilliX and spj and company
20:00:55 <roconnor> GHC represents types?
20:12:25 <mike-burns> dibblego: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf - slide 41: Haskell "class" ~ OO "interface"
20:12:39 <copumpkin> lol
20:12:50 <copumpkin> is this in reference to the conversation from several days ago?
20:12:54 <mike-burns> Yes.
20:13:20 <mike-burns> It was actually several hours ago. I had to run but looked that up as soon as I got back.
20:13:21 <SubStack> what's an interface
20:13:31 <copumpkin> oh
20:13:35 <SubStack> oh, it's like a haskell class, I see
20:13:47 <dibblego> I can't reach research.microsoft.com for some reason, but that's a real shame
20:13:48 <mike-burns> It, er. SubStack: That's not entirely true.
20:13:58 <SubStack> but the slide!
20:14:07 <SubStack> it had a tilde and everything!
20:14:11 <mike-burns> Haha.
20:14:11 <copumpkin> lol
20:14:30 <mike-burns> Can't argue with a tilde!
20:15:15 <SubStack> There is a haskell the cat! Most excellent!
20:15:27 <dibblego> no amount of tildes will make a false statement true ergo ~p = p
20:16:29 <mike-burns> That typeclasses are used for different things than OO interfaces, and are more powerful than OO interfaces, does not necessarily mean that there is no similarity.
20:16:42 <roconnor> I like the hackage success chart
20:16:50 <dibblego> you will continue to repeat that, even though it is false, so I give up
20:16:52 <roconnor> makes me feel like a monad
20:16:53 <roconnor> er
20:17:00 <roconnor> makes me feel warm and fuzzy inside
20:17:07 <SubStack> I like how there is a screenshot of firefox in that slide hosted at microsoft research
20:17:08 <copumpkin> lol
20:17:21 <copumpkin> SubStack: MSR is quite different from MS
20:18:11 <jfoutz> what can you get from a type class that you can't get from an interface? is it more than a set of operations on a datatype?
20:18:27 <copumpkin> type constraints on your methods
20:18:47 <copumpkin> and MPTC are quite different, relating multiple types
20:19:05 <dibblego> the most important thing of all, which makes it completely dissimilar to interfaces, which is implicit dictionary passing
20:19:19 <dibblego> if an interface were to map to anything, it is the data keyword
20:19:29 <copumpkin> jfoutz: by type constraints on your methods, I meant a lot more flexible type constraints than those you could do in most OO interfaces
20:19:34 <mike-burns> dibblego: I will agree with you, without a doubt, that teaching by saying that typeclasses are similar to OO interfaces will lead to confusion.
20:19:50 * jfoutz ponders those comments.
20:19:59 <dibblego> mike-burns, only because it is untrue -- you may as well say that interfaces are similar to any other arbitrary language feature
20:20:01 <vav> what f would give [(0,'a'), (2,'c')] for ` f [Just 0, Nothing, Just 2]  "abc" '?
20:20:38 <copumpkin> > zipWith (\x y -> liftA2 (,)) [Just 0, Nothing, Just 2] "abc"
20:20:39 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f b -> f (a, b))
20:20:39 <lambdabot>    arising...
20:20:44 <copumpkin> oh whoops
20:20:53 <copumpkin> > catMaybes $ zipWith (liftA2 (,)) [Just 0, Nothing, Just 2] "abc"
20:20:54 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
20:21:00 <copumpkin> meh, I fail :)
20:21:14 <Saizan> you've the monad only on one side
20:21:18 <vav> copumpkin: at least I was on the right track, looks like
20:21:20 <mike-burns> dibblego: They're similar in that they both say "by being an instance of this {typeclass,interface} you must implement these {functions,methods}". After that they're quite different.
20:21:26 <jmcarthur> > [(x, y) | Just x <- [Just 0, Nothing, Just 2], y <- "abc"]
20:21:28 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(2,'a'),(2,'b'),(2,'c')]
20:21:32 <jmcarthur> woops
20:21:34 <copumpkin> Saizan: oh yeah :)
20:21:36 <jmcarthur> wrong monad
20:21:39 <mauke> > zipWith (\x y -> fmap (flip (,) y) x) [Just 0, Nothing, Just 2]  "abc"
20:21:41 <lambdabot>   [Just (0,'a'),Nothing,Just (2,'c')]
20:21:42 <jmcarthur> and the other isn't a monad
20:21:49 <mauke> > catMaybes $ zipWith (\x y -> fmap (flip (,) y) x) [Just 0, Nothing, Just 2]  "abc"
20:21:49 <mike-burns> dibblego: And that similarity isn't even that important bit about typeclasses.
20:21:50 <jmcarthur> > [(x, y) | Just x <- [Just 0, Nothing, Just 2] | y <- "abc"]
20:21:50 <dibblego> mike-burns, so not very similar at all, except for when you project a little bias on it
20:21:51 <lambdabot>   [(0,'a'),(2,'c')]
20:21:52 <lambdabot>   [(0,'a'),(2,'b')]
20:21:54 <jmcarthur> works!
20:22:05 <dibblego> mike-burns, right, not only is it not that important, it is totally unimportant
20:22:16 <mauke> jmcarthur: not really
20:22:21 <jmcarthur> oh
20:22:23 <vav> thanks folks, now to chew, digest and 'comprehend'
20:22:24 <jmcarthur> crap you're right
20:22:41 <mike-burns> dibblego: I'm not sure that "bias" is the right word; maybe "wrong perspective"? But yes.
20:22:44 <jmcarthur> > [(x, y) | y <- "abc" | Just x <- [Just 0, Nothing, Just 2]]
20:22:46 <lambdabot>   [(0,'a'),(2,'b')]
20:22:51 <mauke> vav: no, this is where the @pl'ing starts
20:22:52 <jmcarthur> okay i give
20:22:58 <dibblego> mike-burns, are interfaces related to the let/in keywords because they share characters? no, completely irrelevant
20:23:03 <jmcarthur> no comprehension
20:23:10 <vav> mauke: and getting rid of the flip
20:23:33 <moonpatrol> you know... haskell helped me learn python.
20:23:59 <copumpkin> f = (catMaybes .) . zipWith ((. pure) . liftA2 (,))
20:24:00 <mauke> > catMaybes $ zipWith (flip (.) (flip (,)) . flip fmap) [Just 0, Nothing, Just 2] "abc"
20:24:01 <lambdabot>   [(0,'a'),(2,'c')]
20:24:02 <Saizan> dibblego: your position looks like trying to correct one exaggeration with another
20:24:02 <copumpkin> there!
20:24:03 <copumpkin> :P
20:24:13 <mike-burns> dibblego: I'm pretty sure we actually agree that interfaces and typeclasses are dissimilar. It's just that you believe them to have absolutely 0 similarities while I believe that, if you look at typeclasses in an odd way, they can have a useless similarity.
20:24:27 <dibblego> Saizan, I disagree -- the irrelevance is absolute in each case
20:24:37 <copumpkin> dibblego is so extreme!
20:24:38 <mauke> :t (catMaybes .) . zipWith (flip fmap (flip (,)) . flip fmap)
20:24:40 <lambdabot> forall a b. [Maybe a] -> [b] -> [(a, b)]
20:24:50 <dibblego> mike-burns, if you look at let/in in an odd way, you have a useless similarity as well
20:25:09 <dibblego> mike-burns, so we agree, it's arbitrary and a useless thing to say -- so let's stop saying it?
20:25:18 <mike-burns> dibblego: Okay, let's stop.
20:25:25 <mauke> I'll continue for you
20:25:26 * dibblego yays
20:25:31 <copumpkin> if it were truly an irrelevant meaningless comparison, why does it keep coming up?
20:25:35 <mike-burns> Now we just need to get that slideshow updated ...
20:25:37 <Saizan> how can it be irrelevant? they are both mechanisms for overloading and polymorphism over some methods
20:25:48 <dibblego> copumpkin, because of an appealing projection bias
20:25:50 <Saizan> and they often are used to solve the same problems
20:26:01 <copumpkin> sure, the similarities may be misleading, but to say none exist whatsoever seems a little excessive
20:26:01 <jfoutz> copumpkin: i see. i think you can simulate most of that with interface inheritance (in java or a language like that) and class inheritance (in pretty much anything like allows class inheritance)
20:26:32 <copumpkin> jfoutz: how would you specify class X a where op :: a -> a -> a in java interfaces?
20:26:37 <copumpkin> you could do it with generics
20:26:43 <dibblego> you can't
20:26:49 <mike-burns> Haha.
20:26:56 <dibblego> however, you can so data X a = X (a -> a -> a
20:26:57 <dibblego> )
20:27:12 <dibblego> s/so/do
20:27:22 <mike-burns> dibblego: How are you sure that you're not the one biased and that everyone else is looking at typeclasses correctly?
20:27:28 <Saizan> X was an haskell class there.
20:27:38 <dibblego> mike-burns, because it's not "everyone else" and because you have no compelling evidence
20:28:00 <dibblego> Saizan, right, you cannot write class X but you can wrote data X (using interfaces)
20:28:00 <copumpkin> jfoutz: or how about class Functor f where fmap :: (a -> b) -> f a -> f b ? :P
20:28:14 <dibblego> copumpkin, no higher-kinds and nothing similar to type-classes makes this impossible
20:28:21 <copumpkin> I know :)
20:28:28 <copumpkin> I'm just giving jfouts examples of that
20:28:32 <dibblego> oh, I thought "everyone else" didn't :)
20:28:55 <Saizan> ...
20:28:59 <pikhq> Or class Monad m where (>>=) :: (a -> m b) -> (b -> m c) -> m c; return :: a -> m a ? ;)
20:29:07 <Saizan> you're deliberating misunderstanding the arguments :)
20:29:18 <Saizan> *deliberately
20:29:22 * copumpkin is hungry
20:29:33 <dibblego> no, I'm deliberately pointing out that they are absurd
20:29:41 <mauke> they aren't absurd
20:29:42 <dibblego> you cannot emulate class X
20:29:47 <mauke> classes are interfaces
20:29:52 <dibblego> if this is wrong, go right ahead and show it so
20:29:55 <Saizan> i'm not saying you can emulate one with the other
20:30:12 <dibblego> data X is significantly more similar to interfaces than class X
20:30:14 <copumpkin> epic #haskell discussion
20:30:29 <dibblego> in which case "data is like OO interfaces" is a true statement
20:30:38 <Saizan> i'm saying that they are two different language mechanisms to provide very similar higher-level features
20:30:52 <Saizan> like overloading and polymorphism over a set of methods
20:31:05 <dibblego> data provides that more than class does
20:31:28 <Saizan> no, data doesn't provide overloading at all
20:31:33 <dibblego> when Java has implicit arguments, I'll consider this no longer true
20:31:50 <dibblego> interfaces don't provide implicit dictionary passing at all
20:31:59 <mauke> dibblego: how would you write interface Stringable { String toString(); } in Haskell?
20:32:15 <dibblego> newtype Stringable = S String
20:32:30 <Saizan> except that we've Show
20:32:40 <Saizan> which is a class
20:32:41 <dibblego> right, which is something else altogether
20:32:42 <mauke> dibblego: that's wrong
20:33:11 <Saizan> dibblego: we're not asking about mapping the semantics perfectly, we're asking "how would you solve the same problem in haskell?"
20:33:16 <dibblego> mauke, or if you insist, newtype Stringable a = S (a -> String)
20:33:31 <Saizan> and you'd find that in many places you'd go with classes
20:33:33 <dibblego> Saizan, more accruately if you forced me to, by using data keyword
20:33:51 <mauke> dibblego: so you're building a method dictionary by hand?
20:33:59 <mauke> that sounds a lot like type classes
20:34:53 <roconnor> What is variance
20:34:56 <dibblego> I am not doing anything like type-classes, since this is not possible
20:35:02 <roconnor> a la slide 53 ?
20:35:06 <dibblego> but I might be wrong, in which case, show me how
20:35:40 <mike-burns> mauke: It may be helpful to discuss what high-level feature you want written in Haskell that is provided by the Java interface.
20:35:43 <Saizan> roconnor: slide 53 of?
20:36:53 <roconnor> of http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf
20:37:07 <mauke> data Stringable a = S { toString :: a -> String }; dict_StringableInt = S { toString = showInt }  <=> class Stringable a where { toString :: a -> String }; instance Stringable Int where { toString = showInt }
20:37:44 <dibblego> mauke, I hope you mean equivalence in <=>
20:38:23 <mauke> so we've established that interfaces are like typeclasses
20:38:36 <dibblego> where?
20:38:48 <mauke> ^ there
20:38:50 <Saizan> roconnor: oh, how the subtype relation should recursively propagate to subparts of the type
20:39:06 <roconnor> ah
20:39:07 <dibblego> if I scribble out <=> and put <=/=> will that negate it?
20:39:48 <SubStack> it's the spaceship operator!
20:39:48 <mauke> sort of, but it would be wrong
20:39:57 * dibblego plays proof by assertion
20:40:33 <jfoutz> copumpkin: interface Op<A,B> { B op(A arg); } interface Container<A>{} interface Functor <A,B> { Container<B> fmap(Op<A,B> f, Container<A> a } ?
20:40:48 <dibblego> jfoutz, it's not possible without higher kinds
20:41:13 <copumpkin> jfoutz: fwiw, I also disallowed generics :P
20:41:19 <jfoutz> oh.
20:41:24 <copumpkin> but you can approximate some uses of typeclasses
20:41:26 <roconnor> > let a =>+>~~~[**] b = a + b in 2 +>=>~~~[**] 2
20:41:28 <lambdabot>   <no location info>: parse error on input `]'
20:41:30 <copumpkin> but it's nowhere near as flexible
20:41:31 <dibblego> I wonder why we have type-classes then, if they are equivalent to data types
20:41:44 <jfoutz> sorry, thinking about how i would do it rather than reading to closely :)
20:41:48 <copumpkin> convenience
20:41:53 <SubStack> dibblego: that shapeship is not spaceworthy
20:41:56 <dibblego> jfoutz, it's possible using Scala
20:41:58 <jfoutz> but yes, it's hideous and cumbersome.
20:42:15 <copumpkin> besides it'd probably be called Mappable or something
20:42:24 <copumpkin> :P
20:42:40 <dibblego> http://scalaz.googlecode.com/svn/trunk/src/main/scala/scalaz/Functor.scala
20:43:02 <jfoutz> AbstractFactoryTransformForGenericContainer :p
20:43:03 <copumpkin> oh my
20:43:53 <dibblego> (notice that Scala has something similar to type-classes unlike OO interfaces)
20:44:23 <mike-burns> I'm not very good at reading Scala. What does it have that's similar to typeclasses?
20:44:34 <copumpkin> trait?
20:44:41 <dibblego> implicit
20:44:54 <mike-burns> What does `implicit' do?
20:45:02 <dibblego> (the essential part of a type-class which you will never get out of OO interfaces)
20:45:34 <dibblego> if we take the class X declared earlier then transform it in a way that you erroneously think is similar: interface X<A> { A f(A a1, A a2); }
20:46:01 <dibblego> then we pass an instance of X<T> to a method, then have that argument selected "implicitly" based on type, then you have something similar to type-classes
20:46:20 <dibblego> but if it passed explicitly, you have something more similar to data X a = X (a -> a -> a)
20:47:49 <mike-burns> dibblego: How is this `implicit' thing different from typeclasses? [I'm also still trying to find docs online that will quickly tell me more about `implicit'.]
20:48:07 <dibblego> mike-burns, it's not -- you're free to say "it is similar"
20:48:21 <mike-burns> I'd say that's "the same".
20:48:21 <dibblego> mike-burns, notice though, that OO interfaces are never passed implicitly, ever
20:48:32 <dibblego> then you'd be wrong :)
20:48:39 <dibblego> (there are some differences)
20:49:06 <mike-burns> Oh.
20:49:18 <dibblego> the differences are relatively minor
20:49:19 <mike-burns> I'm slightly confused by your language, but I'll stick with "it's similar".
20:50:19 <mike-burns> dibblego: Say you wanted the first argument to a function to have the function `show' defined on it, in Haskell. How would you do this?
20:50:43 <dibblego> depends if I wanted implicit or explicit passing
20:50:57 <mike-burns> Okay, both answers are fine.
20:51:02 <dibblego> if I wanted explicit (which you are forced to use in OO interface languages), I'd use the data keyword
20:51:24 <copumpkin> f :: ShowDictionary a -> a -> b
20:51:28 <dibblego> if I wanted implicit (which you cannot use in OO interface languages since there is no similarity), I'd use the class keyword
20:51:54 <mike-burns> dibblego: The implicit example is where they have a similarity, if you ignore what you said in parens because I didn't really understand it.
20:52:04 <mike-burns> dibblego: it's a very high level thing.
20:52:11 <dibblego> so high as to be arbitrary
20:52:19 <mike-burns> I don't know what that means.
20:52:28 <dibblego> it means you may as well say any two things are similar
20:52:33 <mike-burns> I don't follow.
20:52:49 <mike-burns> I'll state my point more clearly I think.
20:53:36 <dibblego> I will entertain your assertion that type-classes are similar to OO interfaces, so long as you also accept that data types are even more similar to OO interfaces
20:53:47 <mike-burns> dibblego: Agreed.
20:54:03 <dibblego> I think that is silly, useless and arbitrary :)
20:54:48 <mike-burns> We already agreed there earlier; I just wanted to join in on the "convince dibblego that there can be a similarity" thing. :)
20:55:02 <dibblego> sure, it's a projection bias
20:55:11 <dibblego> like I said, let/in has a similarity to interfaces as well
20:55:21 <mike-burns> What's the similarity there?
20:55:35 <dibblego> 'e' 't' 'i' 'n' all appear in the word 'interface'
20:55:42 <monochrom> hahaha
20:55:44 <copumpkin> lol
20:55:45 <mike-burns> Ah yes, that is confusing.
20:55:47 <dibblego> the 'l' is an anomly
20:55:55 <dibblego> confusing or silly, useless and arbitrary? :)
20:55:56 <jfoutz> ok, i *think* that with generics, i can get the java type checker to simulate fmap, but i have to explicitly map interfaces to classes, and provide implementations that extend existing stuff, like List and my introduced interfaces. haskells typechecker is powerfull enough to eliminate the need for the support interfaces and classes i need... does haskell buy me more than that? i think i'm missing something.
20:56:19 <mike-burns> jfoutz: Nicer syntax. :)
20:56:26 <jfoutz> well, yes :)
20:57:06 <dibblego> jfoutz, you can't get the Java type checker to simulate fmap
20:57:44 <jfoutz> i'm totally willing to accept that.
20:58:13 <dibblego> jfoutz, more specifically, you cannot abstract on a type constructor
20:59:19 <jfoutz> ahhhh.
20:59:20 <copumpkin> what's missing from haskell's type system to allow real type lambdas or partially applied type constructors? if I wanted (-> a)
20:59:53 <jfoutz> i'm required to provide an implementation of (what i called Op) for every possible class to class map.
21:00:14 <dibblego> jfoutz, http://functionaljava.org/
21:01:04 <Saizan> jfoutz: another big difference is that the method need not to be chosen based on the first argument, it can even depend on the result
21:01:09 <Saizan> jfoutz: like return
21:01:49 <Saizan> (without talking about multiparameter typeclasses)
21:06:04 <jfoutz> so... i have a pretty solid scheme background, and i'd always considered a closures equivalent to an anonymous java object with one method called run(...). i'm just trying to get my head around how much work haskell is saving. I follow the mutiple dispach argument (and get annoyed at how tedious it is to do a visitor to get around that) just trying to get... precicely how much the typechecker is getting me.
21:06:55 <jfoutz> i think the type constructor is the biggie.
21:07:39 <jfoutz> without that i have to implement the cross product of Op(A,B) for every class. which sucks.
21:08:19 <dibblego> jfoutz, higher kinds and type-classes are two big things that Haskell has over languages like Java in my commercial work
21:08:41 <copumpkin> dibblego: if given the choice, would you program more in haskell or scala?
21:08:49 <dibblego> copumpkin, Haskell of course
21:09:07 <copumpkin> but scala makes the jvm more pleasant? I've never really tried it, just curious
21:09:38 <dibblego> copumpkin, using Scala allows me to easily disengage certain arguments -- that's the main reason I use it
21:09:55 <copumpkin> how so?
21:09:58 <jfoutz> i'd stuck it in the "like ocaml" bucket without really trying it.
21:10:45 <dibblego> copumpkin, because some people insist on the JVM, are under the illusion that Java has useful libraries and so on (lots of arguments that I have no desire to engage)
21:10:53 <copumpkin> ah
21:11:44 <jfoutz> dibblego, copumpkin: thanks. not sure i'm catching all the implications but that was real helpful.
21:11:50 <dibblego> np
21:12:19 <copumpkin> jfoutz: I'm just learning too, but I'm pleased to try to help if you have any more questions :)
21:14:00 <BMeph> jfoutz: I'd say your reaction is fair. After all, how many times have you run into people that see no difference between, say, Scheme and CL? ;)
21:14:25 <mike-burns> BMeph: But they both have parentheses---they can't possibly be different!
21:14:52 <jfoutz> BMeph: that's a holy war for sure.
21:16:01 <sshc> what's wrong with this code?
21:16:03 <BMeph> mike-burns: Haha!
21:16:15 <BMeph> sshc: UR DOIN IT RONG! ;p
21:16:18 <sshc> http://dpaste.com/80801/
21:16:41 <sshc> errors: http://dpaste.com/80802/
21:17:03 <mauke> sshc: show only takes one argument, not three
21:17:08 <Cale> sshc: You're passing too many parameters to show
21:17:38 <Cale> (specifically, you're passing fst, simplify, and decimalFraction as parameters)
21:17:46 * copumpkin thinks that those spammers who post mysluttygirlfriend.com/?15672567 would have much better luck posting a tinyurl version of that with "this code doesn't typecheck, what's wrong?"
21:17:56 <mike-burns> copumpkin: Haha.
21:18:12 <copumpkin> then they'd easily get 100 hits every time :P
21:18:28 <Cale> copumpkin: That would require them to tailor their spamming to the individual channel. I don't think they think that hard about it.
21:18:43 <BMeph> copumpkin: Cute: tinyurl = Sex Panther! ;p
21:18:43 <mauke> "this code doesn't compile, what's wrong?" -- more channel agnostic
21:19:06 <jfoutz> copumpkin: i guess i just didn't soak up enough CS theory about computibility. I (think) i get the limits of a regular expression vs a full language. What do you read to get the java typechecker can't do X?
21:19:12 <copumpkin> or even without programming-specific text: "wow, will they stop at nothing? this is patently ridiculous"
21:19:19 <sshc> Cale: thanks.
21:19:37 <sshc> Cale: although I thought fst would be called before show
21:20:07 <Cale> In fact, even if you write show (fst (simplify decimalFraction)), it's show which is called first.
21:20:07 <dino-> But I think then the subsequent system attacks will mostly fail against the many many non-Windows systems here.
21:20:44 <Cale> (with the parameter fst (simplify decimalFraction))
21:20:55 <copumpkin> jfoutz: well type systems can be reduced (and vice versa) to logical systems, so it might be possible to say that some logical statements cannot be made in some type systems. Not sure though, and definitely don't know what java's type system corresponds to
21:21:00 <sshc> Cale: doesn't the call to fst need to be avaluated before show is called?
21:21:11 <Cale> sshc: nope
21:21:21 <sshc> Cale: otherwise how does show know what to show? :P
21:21:29 <Cale> sshc: It'll only be evaluated when show pattern matches on it (which it will)
21:22:11 <BMeph> sshc: Here's a hint to how Haskell works; it won't call fst, because it doesn't know what show wants. So, it "has" to call show first.
21:22:15 <pikhq> sshc: It doesn't until it evaluates its argument.
21:22:28 <jfoutz> copumpkin: the thing that seems so tricky to me is how systems (like the java type checker) seem to just tack on features that seem handy, and its sooooo hard to tell when one of those features introduces huge amounts of power.
21:23:05 <Cale> Another way to put it is that lazy evaluation is outermost-first (with an additional rule that says when you have a parameter to a function that occurs more than once in the body, it's evaluated at most once, and shared between the copies)
21:23:17 <jfoutz> copumpkin: not a fan of xml, but they have this whole substitution language and were very careful to exlude lots of things that can get you ... power.
21:26:34 <jfoutz> i guess i should have paid more attention when they talked about if you have one stack you can do x, if you have two you are turing complete.
21:27:00 <pikhq> jfoutz: With two stacks you can emulate a tape.
21:27:12 <jfoutz> yeah.
21:27:33 <pikhq> With one stack, you (generally) cannot.
21:28:11 <mike-burns> With three stacks and some tape you can stand high enough to tape those cables along the edge of your ceiling.
21:28:27 <pikhq> (if you can access arbitrary positions in the stack you may be able get away with a single stack)
21:28:36 <jfoutz> i vaguely recall if you have a register and an infinite stack you can pretend you have 2 stacks... but maybe you need more. and i don't really understand how that maps to the haskell typechecker.
21:28:55 <jfoutz> yeah :)
21:29:22 <jfoutz> mike-burns: with 5 stacks you won't worry about your insurance
21:29:29 <pikhq> jfoutz: Well, we're discussing computability right now.
21:29:34 <monochrom> This is getting silly.
21:29:40 <pikhq> Computability manages to apply in weird and silly ways.
21:29:48 <mike-burns> monochrom: Sorry my fault.
21:29:53 <monochrom> With 100 stacks you solve the expression problem. :)
21:30:12 <monochrom> Please continue. :)
21:31:07 <jfoutz> pikhq: so... what field of study does type checking fall under? how do you decide if one typechecker is more powerful than another?
21:31:27 <monochrom> "type systems"
21:34:19 <sbahra> http://ertos.nicta.com.au/research/sel4/
21:34:40 <pikhq> jfoutz: Depends on how you define "power".
21:35:05 <jfoutz> fair enough.
21:35:17 <pikhq> If you define "power" as "problems that can be computed by it", then C++ has the most powerful type system.
21:35:44 <pikhq> (it is a particularly verbose notation for lambda calculus)
21:35:45 <jfoutz> because of partial template specialization.
21:36:11 <jfoutz> i guess because of several features that interact in a complicated way.
21:36:16 <shepheb> isn't the (sufficiently extended) Haskell type system also Turing-complete?
21:36:21 <Elly> agda has the most powerful type system!
21:36:31 <pikhq> I'm not sure what other notions of "power of a typechecker" could be said as formally as that, sadly.
21:36:48 <pikhq> Elly: It has a halting oracle?
21:36:56 <Elly> pikhq: probably!
21:37:16 <pikhq> Then it is either nonexistant or not Turing-complete.
21:37:19 <pikhq> Meaning: fail. :P
21:37:28 <jfoutz> pikhq: well, copumpkin was able to say pretty definitively that the java type system couldn't represent kinds. i'm not able to say that.
21:37:50 <jfoutz> i mean... i've got a glimmer of understanding that they're different
21:38:00 <pikhq> jfoutz: I am not sure how you would go about proving that, but I'm willing to accept it.
21:38:17 <jfoutz> ah, ok.
21:38:22 <pikhq> (note: I don't know Java, so that's why I'm not sure how to go about proving it. ;))
21:38:46 <jfoutz> ahhh. yeah i have the other problem :)
21:39:00 <jfoutz> is that a dual?
21:39:09 <pikhq> Yes, knowing Java is quite a problem.
21:39:28 <shepheb> Java has some higher-kinded types, doesn't it? generics and all. but those are only the relatively boring * -> * -> ... -> * kinds.
21:39:38 <dibblego> shepheb, no
21:39:41 <shepheb> and not the interesting * -> (* -> *) -> * kinds or whatever.
21:39:48 <dibblego> not even * -> *
21:39:57 <pikhq> Can't even do a monad?
21:40:00 <dibblego> no
21:40:00 <shepheb> hm, I wonder what I'm misunderstanding then
21:40:01 <pikhq> Lame!
21:40:12 <dibblego> Java and Lame are "similar" :)
21:40:19 <sshc> How do I "add an instance declaration for (Integral Double)?  To fix http://dpaste.com/80806/ and http://dpaste.com/80807/
21:40:23 <pikhq> dibblego: :D
21:40:30 <jfoutz> dibblego: if i understood, it you could get * -> a and that was about it.
21:40:31 <shepheb> isn't a List<E> a * -> *?
21:40:48 <dibblego> shepheb, List :: * -> *
21:40:53 <dibblego> List<E> :: *
21:41:00 <shepheb> er, right
21:41:47 <shepheb> you can have multiple generic parameters (I don't know the right term for E there) and that gets arbitrary * -> * -> ... -> *, unless that counts as a single, tupled type.
21:42:15 <shepheb> plus didn't someone implement monads in Java?
21:42:17 <jfoutz> sshc: change the 2 to a 2.0 in the second one.
21:42:32 <Trinithis> :k MaybeT
21:42:34 <lambdabot> Not in scope: type constructor or class `MaybeT'
21:42:40 <Trinithis> :k ListT
21:42:41 <lambdabot> Not in scope: type constructor or class `ListT'
21:43:04 <shepheb> ListT isn't always a monad, and MaybeT gets no love.
21:43:05 <dibblego> shepheb, no, you cannot abstract on any type constructor of any kind and nobody has done monads using Java's type system (it's not possible)
21:43:20 <shepheb> :k StateT
21:43:21 <lambdabot> * -> (* -> *) -> * -> *
21:43:23 <Trinithis> is the kind *->*->*
21:43:26 <Trinithis> for maybet
21:43:42 <jfoutz> sshc: sorry i totally misread that code. that's wrong.
21:43:47 <pikhq> :k Arrow
21:43:47 <Cale> sshc: length unfortunately returns an Int rather than any more arbitrary type of number. You can use fromIntegral to convert that Int into anything else though.
21:43:48 <lambdabot> Class `Arrow' used as a type
21:44:03 <dibblego> :k (->)
21:44:04 <shepheb> (* -> *) -> *
21:44:04 <lambdabot> ?? -> ? -> *
21:44:08 <pikhq> Thar.
21:44:47 <BMeph> sshc: Or alternately, use genericLength instead. :)
21:45:05 <shepheb> dibblego: ah, I see where I was misunderstanding. List :: * -> *, but you can't make a Queue<List>.
21:45:19 <dibblego> shepheb, right
21:47:43 <sshc> Cale, jfoutz, BMeph, thanks for helping me fix this
21:48:01 <sshc> it compiles with ghci fine now!
21:48:15 <shepheb> does anyone know why I can't get the setHeader or redirect functions to work in Network.CGI? perhaps lighttpd is to blame, not letting CGI scripts change the headers?
21:49:20 <aempirei> lol
21:49:40 <bos> ooh, test-framework is NICE.
21:54:05 <copumpkin> is there a nice elegant way of stating that two datastructures are isomorphic and getting functions for converting between them?
21:55:09 <Saizan>  a pair of the two functions?
21:55:25 <copumpkin> I guess :)
21:58:29 <Trinithis> why even use isomorphic data structures?
21:59:28 <jfoutz> ... not sure about the context but you aren't guaranteeing isomorphic with just the two functions. ([a]->Maybe a, Maybe a -> [a]) will forget stuff.
21:59:36 <copumpkin> some are more efficient for some operations than others
22:00:12 <jmcarthur> class Isomorphic b a => Isomorphic a b where iso :: a -> b  -- ?
22:00:31 <copumpkin> whoa, is that allowed?
22:00:37 <jmcarthur> dunno, but it seems nice
22:00:56 <copumpkin> how would you go about defining an instance of that? :P
22:01:05 <Saizan> you define two?
22:01:11 <Trinithis> iso . iso = iso too
22:01:14 <jmcarthur> should be able to define mutually recursive instances, shouldn't you?
22:01:18 <Trinithis> err
22:01:21 <jmcarthur> id
22:01:25 <Trinithis> iso.iso.iso = iso
22:01:28 <Saizan> jmcarthur: yes, you can
22:01:35 <jfoutz> the reverse test :)
22:03:40 <copumpkin> that's neat :)
22:05:55 <jmcarthur> huh, doesn't seem to work
22:05:58 <jmcarthur> "Cycle in class declarations (via superclasses)"
22:06:10 <copumpkin> onoes
22:06:20 <Saizan> hah
22:06:30 <Trinithis> why not just  Isomorphic a b where iso :: a -> b
22:06:36 <Trinithis> and declare te opposite too
22:06:58 <copumpkin> the other one would force you to declare the opposite
22:07:07 <copumpkin> if it weren't disallowed :P
22:07:25 <Saizan> you'd need (Isomorphic X Y, Isomorphic Y X) => as context
22:07:31 <Saizan> and it'd look silly :)
22:11:06 <copumpkin> :(
22:12:12 <jmcarthur> could have something like  iso :: a -> b ; coiso :: b -> a
22:12:14 <jfoutz> monid? is that the right one? monid a b, monid b a => isomorphic?
22:12:31 <jmcarthur> which is gross
22:16:32 <copumpkin> monid?
22:17:12 <jmcarthur> class Morphism a b where morph :: a -> b ; class (Morphism a b, Morphism b a) => Isomorphism a b where iso :: a -> b ; iso = morph
22:17:15 <jmcarthur> not as nice
22:17:17 <jmcarthur> but works
22:17:56 <jmcarthur> type system doesn't require two instances of Isomorphism, but at least it requires there to be two morphisms
22:22:39 <jmcarthur> oh here's a gross one:
22:22:51 <jmcarthur> class Isomorphism a b where iso :: Isomorphism b a => a -> b
22:23:14 <copumpkin> :o
22:23:31 <copumpkin> that one's allowed?
22:23:43 <jmcarthur> it is
22:23:49 <jmcarthur> but it won't complain until you try to use iso
22:23:58 <jmcarthur> just having one instance defined won't make it complain
22:24:56 <jmcarthur> and so the final type for iso is:   iso :: (Isomorphism a b, Isomorphism b a) => a -> b
22:25:49 <copumpkin> the forall requirement to bring type vars into scope for scoped type variables seems a little random
22:25:58 <copumpkin> I keep forgetting to do it
22:26:16 <copumpkin> @hackage vacuum
22:26:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum
22:26:26 <jmcarthur> i like that it requires that. makes me aware that i am using bound type variables
22:26:43 <jmcarthur> otherwise i could accidentally use a bound one without realizing
22:27:05 <jmcarthur> and more backward compatible that way, too
22:27:09 <jmcarthur> for the same reason
22:27:13 <copumpkin> I guess :)
22:28:36 <jmcarthur> i think the solution i labeled as gross is growing on me now
22:32:02 * copumpkin loves how vacuum happily vacuums up undefined as well
22:39:50 <ray> vrmmmmmmmm
22:53:35 <copumpkin> > let (>) = (+) in 5 > 6 -- :o
22:53:36 <lambdabot>   11
22:54:52 * copumpkin is being knotty
22:59:40 * copumpkin is finally getting somewhere with the sum-product algorith implementation
22:59:49 <copumpkin> maybe it'll even be elegant at this rate
23:00:41 <AlienLanez> hi
23:01:44 <Saizan_> hi
23:01:45 <BMeph> AlienLanez: Hello. State the nature of the programming emergency. ;)
23:02:15 <akatsuki> hi
23:02:28 <AlienLanez> sorry, i have no idea where i am. first time to use irc using opera
23:02:39 <copumpkin> AlienLanez: it magically joined you to #haskell? :P
23:02:47 <copumpkin> AlienLanez: it's a sign!
23:02:54 <copumpkin> you must learn the language for great justice
23:03:35 <BMeph> You must submit. All your skills are belong to Haskell.
23:03:59 <AlienLanez> what's a haskell?
23:04:01 <copumpkin> somebody may have set up you the bomb, and that's why you joined
23:04:11 <copumpkin> AlienLanez: not sure, but we know a site that can learn you one
23:04:14 <akatsuki> BMeph: *All your skills belong to haskell
23:04:25 <akatsuki> AlienLanez: Yo moma.
23:04:39 <akatsuki> copumpkin: Learn me a haskell . com ?
23:04:51 <copumpkin> http://learnyouahaskell.com/
23:04:56 <copumpkin> but almost :)
23:05:01 <akatsuki> lies.
23:05:22 <copumpkin> lol
23:05:27 <akatsuki> copumpkin: I thought Real World Haskell was preferred
23:05:29 <akatsuki> lol
23:05:40 <copumpkin> akatsuki: both are quite good, from what I hear
23:05:49 <akatsuki> Aha, ok
23:06:01 <akatsuki> copumpkin: What did u read?
23:06:07 <copumpkin> this channel
23:06:15 * akatsuki tr0tz.
23:06:20 <akatsuki> Aha, ok
23:06:27 <copumpkin> :)
23:06:34 <akatsuki> This channel is your official documentation to the haskell language?
23:06:34 <copumpkin> best learning tool ever
23:06:48 <copumpkin> akatsuki: well, once I understood it, the documentation and source worked fine :)
23:06:59 <akatsuki> mmmmk
23:07:22 <Saizan> except when he wants to transform me into a bot :P
23:07:27 <copumpkin> lol
23:07:30 <copumpkin> yeah
23:07:33 * akatsuki whispers "weirdo"
23:07:44 <copumpkin> well, I feel reasonably comfortable in haskell now, but I'm definitely not an expert :P
23:07:59 <copumpkin> so occasionally I use Saizan's (and others') master skillz0rz
23:08:01 <akatsuki> copumpkin: What were you before a haskeller?
23:08:15 <akatsuki> How to acquire skillz0r?
23:08:20 <copumpkin> akatsuki: various things, but my language of choice was ruby for most things :P
23:08:36 <akatsuki> rewwwwwwwwwwwwwwwwwbe
23:08:43 <copumpkin> something like that :)
23:08:44 <akatsuki> I hear that's like lisp
23:08:55 <copumpkin> hmm not sure about that :P
23:09:18 <akatsuki> for i in |foo| read my |bar| cuz |i| said |so|
23:09:28 <copumpkin> :o
23:09:31 <akatsuki> or something
23:09:48 <copumpkin> doesn't look like ruby to me :P
23:10:08 <akatsuki> Still do ruby?
23:10:17 <copumpkin> rarely
23:10:46 <copumpkin> I mostly used it because I wanted a high-level language for easy abstraction
23:10:55 <copumpkin> and haskell does that so much  better
23:10:59 <copumpkin> and more quickly
23:11:21 <copumpkin> there are still a few things I use ruby for, but haskell has mostly replaced it
23:11:44 <pardus> copumpkin, what are those ruby-specific things you still do?
23:12:05 <akatsuki> is #haskell your fight-club?
23:12:33 <copumpkin> quick log processing mostly :P and translating extremely imperative algorithms to something decent before I write them in haskell
23:14:11 <copumpkin> I'm still not at the point where I can replace my regexen with haskell parser combinators
23:14:24 <copumpkin> so having the built-in regex syntax in ruby helps me for simple text processing
23:19:07 <pardus> (un)fortunately I don't know ruby so I'm playing with text/logs/etc with haskell
23:19:51 <akatsuki> pardus: Does that make you cxz?
23:20:13 <pardus> makes me what?
23:20:24 <sjanssen> what are these logs people process?  It always comes up when talking about these scripting languages, but I don't think I've needed to process a log in my life
23:21:16 <copumpkin> sjanssen: I've used it to build some simple stats of things I care about in some http logs, and stats for an iphone app I'm selling
23:21:30 <copumpkin> http access logs for a website, that is
23:22:19 <pardus> sjanssen, various traces, memory dumps and so on.
23:22:54 <pardus> processing memory dump log and generating .hex
23:28:14 * Saizan wonders what the app is
23:28:32 <copumpkin> mine? it's only available on jailbroken phones :P
23:29:28 <Saizan> i've no iphone anyway, but what does it do?
23:30:15 <copumpkin> it's a plugin for the existing youtube app that lets you download youtube vids and watch them offline, so you don't have to wait for them to download each time
23:30:34 <copumpkin> sounds pretty unlikely but it's been quite successful so far
23:33:34 <pardus> is it frontend to youtube-dl script?
23:35:03 <copumpkin> nope
23:35:26 <copumpkin> it hooks into the frameworks apple uses to download the videos in the apps
23:35:35 <copumpkin> it just happens to save it to disk too
23:43:15 <Phyx-_> hmmm "Orphan" wasn't a bad movie...
