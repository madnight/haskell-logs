00:00:08 <dmwit> Oh, it might be commutative after all.
00:00:34 * dmwit is wrong a lot tonight
00:00:38 <Apocalisp> Suppose Haskell had first-class modules.
00:00:57 * dmwit adds it to his suppository
00:00:57 <ski> Suppose Haskell had first-class continuations.
00:01:05 <Apocalisp> And you wanted to write a generic FingerTree module.
00:01:22 <dmwit> Isn't there one already?
00:01:23 <Apocalisp> Such that you could parameterise it with a monoid.
00:01:44 <Apocalisp> Is there? I know only of Seq
00:01:47 <ski> you mean like ML functors ?
00:02:00 <dmwit> Poke ekmett.  He claimed to use such a thing for his monoidal parsing library.
00:02:24 <ski> s/ekmett/edwardk/ ?
00:02:29 <dmwit> ...maybe
00:02:38 <dmwit> Almost certainly, yes.
00:02:43 <ski> ircname  : Edward Kmett
00:03:02 <maxote> > cos(1 `div` 0)
00:03:03 <lambdabot>   Add a type signature
00:03:21 <maxote> > cos(fromIntegral (1 `div` 0))
00:03:22 <lambdabot>   * Exception: divide by zero
00:03:44 <maxote> > fromIntegral (1 `div` 0) + sin (0/0)
00:03:45 <lambdabot>   * Exception: divide by zero
00:03:50 <ski> is there any confusion ?
00:03:54 <maxote> > sin (0/0) + fromIntegral (1 `div` 0)
00:03:56 <lambdabot>   * Exception: divide by zero
00:04:03 <maxote> ski, still not.
00:04:24 <maxote> err, yes, what's NaN + DivZero's Exception
00:04:45 <dmwit> NaN is not an exception.
00:04:51 <ski> it's the exception, since `(+)' is strict in both arguments
00:04:51 <dmwit> So any exception in other parts of the computation will override it.
00:05:31 <dmwit> > 0/0
00:05:32 <lambdabot>   NaN
00:05:48 <dmwit> > let nan = 0/0 in (nan, nan + nan/0)
00:05:49 <lambdabot>   (NaN,NaN)
00:05:57 <dmwit> *blink*
00:06:02 <ski> > 0 / 0 == 0
00:06:03 <lambdabot>   False
00:06:04 <dmwit> > let nan = 0/0 in nan/0
00:06:06 <lambdabot>   NaN
00:06:07 <ski> > 0 / 0 /= 0
00:06:08 <lambdabot>   True
00:06:10 <dmwit> Oh, okay. =)
00:06:14 <dmwit> > let nan = 0/0 in (nan, nan + 1/0)
00:06:15 <lambdabot>   (NaN,NaN)
00:06:20 <maxote> > 1 + NaN
00:06:21 <dmwit> gah
00:06:21 <lambdabot>   Not in scope: data constructor `NaN'
00:06:38 <jbauman> > 0 / 0 == 0 / 0
00:06:39 <maxote> > let nan = 0/0 in 1 + nan
00:06:39 <lambdabot>   False
00:06:40 <lambdabot>   NaN
00:06:49 <ski> > 1 + read "NaN" :: Double
00:06:50 <lambdabot>   NaN
00:07:11 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in nan + divzero
00:07:12 <lambdabot>   * Exception: divide by zero
00:07:23 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in divzero + nan
00:07:25 <lambdabot>   * Exception: divide by zero
00:07:29 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in nan + nan
00:07:30 <lambdabot>   NaN
00:07:36 <dmwit> > 1/0
00:07:37 <lambdabot>   Infinity
00:07:37 <Stinger> I wonder if the compiler is smart enough to optimize away read "NaN" :)
00:07:43 <dmwit> oh
00:07:44 <dmwit> Okay!
00:07:56 <dmwit> So (1/0) isn't an exception... I feel sane again.
00:08:12 <Stinger> > 1/(negate 0)
00:08:12 <maxote> i think NaN should be a sensitive reserved word
00:08:13 <lambdabot>   -Infinity
00:08:15 <edwardk> dwmit: whats up?
00:08:40 <dmwit> edwardk: Apocalisp was asking about parameterizing finger trees by the monoid used.
00:08:43 <ski> edwardk : Apocalisp wanted a generic FingerTree module
00:08:53 <dmwit> Is the library you used for that publically available?
00:09:00 <edwardk> dmwit: ah. i have/had a WithReducer in monoids
00:09:02 <dmwit> (Do I remember correctly that you used such a library?)
00:09:10 <Apocalisp> I was more just wondering how such a thing is expressed.
00:09:13 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in nan = nan
00:09:13 <edwardk> i don't remember if its in the current packaged version, because i cut a bunch out
00:09:14 <lambdabot>   <no location info>: parse error on input `='
00:09:23 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in nan == nan
00:09:24 <lambdabot>   False
00:09:36 <maxote> why?
00:09:42 <ski> because IEEE says so
00:09:50 <Stinger> NaN never equals NaN
00:10:07 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in divzero == divzero
00:10:09 <lambdabot>   * Exception: divide by zero
00:10:34 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Reducer-With.html
00:10:53 <ski> because giving the wrong answer is ok, if you're following the standard
00:11:07 <maxote> > 10^10^10
00:11:12 <lambdabot>   mueval-core: Prelude.read: no parse
00:11:12 <lambdabot>  mueval: ExitFailure 1
00:11:18 <maxote> > 10^10
00:11:20 <lambdabot>   10000000000
00:11:24 <jbauman> it's not necessarily wrong...
00:11:25 <edwardk> you can make a FingerTree m (c `WithReducer m) -- for any c `Reducer` m.
00:11:32 <maxote> > (10^10)^10
00:11:34 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
00:11:35 <jbauman> the nans could be two different non-numbers
00:11:40 <maxote> > 10^(10^10)
00:11:45 <lambdabot>   mueval-core: Prelude.read: no parse
00:11:46 <lambdabot>  mueval: ExitFailure 1
00:11:47 <edwardk> er FingerTree m (c `WithReducer` m) that is
00:11:52 <ski> `(==)' ought to be an equivalence relation
00:11:56 <ski> (or at least a PER)
00:12:09 <edwardk> i should put that one back in 0.2
00:12:17 <edwardk> i pruned everything so i could drop dependencies
00:12:22 <maxote> > 1/0
00:12:23 <lambdabot>   Infinity
00:12:33 <edwardk> but fingertrees are pretty fundamental as far as monoids go
00:12:56 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf + nan
00:12:57 <lambdabot>   NaN
00:13:08 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in nan + inf
00:13:09 <lambdabot>   NaN
00:13:17 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf / inf
00:13:18 <lambdabot>   NaN
00:13:19 <edwardk> ski: the other problem is that fingertrees only memoize the result at the nodes, not in the fingers, so there is an implicit assumption that the monoid is cheap, which doesn't always hold
00:13:37 <edwardk> since it may have to be applied to up to 4 values over and over to get the fingers
00:13:51 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf + divzero
00:13:52 <lambdabot>   * Exception: divide by zero
00:14:01 <ski> @let nan,posInf,negInf :: Fractional a => a; nan = 0/0; posInf = 1/0; negInf = (-1)/0
00:14:03 <lambdabot>  Defined.
00:14:06 <ski> maxote : there you are ^
00:14:12 <Apocalisp> edwardk: In the Finger Tree, I would very much like to parameterise with, say, a measure of size and the addition monoid on Int, to get a Seq. However, the measure depends on both the monoid and the element type (since it's a function from the latter to the former). How do you reconcile this?
00:14:34 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf + inf
00:14:35 <lambdabot>   Infinity
00:14:41 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf == inf
00:14:42 <lambdabot>   True
00:14:44 <edwardk> Apocalisp: thats what WithReducer is for
00:15:00 <Apocalisp> OK, looking at it now. Thanks.
00:15:03 <maxote> what does IEEE say about Infinity == Infinity?
00:15:09 <ski> edwardk : hehe, i only have a vague idea of what fingertrees are
00:15:40 <edwardk> Apocalisp: FingerTree (Sum Int, Count) (ByteString `WithReducer` (Sum Int, Count)) -- where Count is defined as a monoid and a reducer with unit _ = 1
00:15:56 <edwardk> er
00:15:59 <dmwit> Stinger: It seems the optimizer is not smart enough to evaluate (read "NaN") at compile-time.
00:16:06 <edwardk> actually Sum Int won't count length so you need to define both monoids
00:16:12 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in let inf2 = 2*inf in inf2 == inf
00:16:13 <lambdabot>   True
00:16:19 <maxote> wrong!!!
00:16:21 <edwardk> the other way is to make a newtype wrapper of your own around the fingertree contents
00:16:35 <ski> > 2 * posInf == posInf
00:16:37 <lambdabot>   True
00:16:40 <edwardk> Apocalisp: i did that in my modified iteratee, which uses fingertrees
00:16:46 <edwardk> Apocalisp: one sec i can find slides
00:16:52 <ski> @kind Sum Int
00:16:53 <lambdabot> *
00:17:13 <Stinger> oh well
00:17:19 <maxote> > let nan = 0/0 in let divzero = fromIntegral(1 `div` 0) in let inf = 1/0 in inf * 0
00:17:21 <lambdabot>   NaN
00:17:27 * ski sighs
00:18:11 <edwardk> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf slides 16 and 17
00:19:16 <edwardk> ski: a fingertree is basically an optimized functional data structure that you can pretend is a tree with the end points 'lifted up' to give fast access to either end. it is built in such a fashion that it stores the prefix sum over some monoid for each node in the fingertree very efficiently
00:19:57 <Apocalisp> it's also the coolest thing, like, ever
00:20:13 <Apocalisp> (says Haskell Barbie)
00:20:15 <uzytkownik> Is using fix/mfix for recursion a good programming style or not?
00:20:19 <edwardk> ski: so you can ask it to split on a monotonic function from the monoid -> Bool in O (log (min (n,m-n))) time where m is the size of the fingertree and n is the offset where it changes, index the end points in O(1), index anywhere within it with the O (log (min (n,m-n))) bounds, etc.
00:20:31 <ski> (s/functional/persistent/)
00:20:44 <edwardk> uzytkownik: use mfix when necessary, but fix is generally less readable than using recursion directly
00:20:52 <ski> uzytkownik : it's not bad per se. it depends
00:21:03 <edwardk> mfix is necessary because it does special things for some monads
00:21:26 <ski> isn't `mfix' expressible using `mdo'
00:21:28 <ski> ?
00:21:32 <edwardk> ski: mdo = mfix
00:21:37 <edwardk> mdo is mfix sugar
00:21:55 <ski> (or rather, every use of `mfix' being simply expressible with a use of `mdo')
00:22:12 <ski> that's what istr
00:23:35 <edwardk> mdo x <- foo x; y <- baz; return y = mfix (\(x,y) -> do x' <- foo x; y' <- baz; return (x',y')) >>= \(x,y) -> return y -- which then gets shrunk to move the baz out of the mfix as well
00:24:02 <edwardk> ski: mdo desugars to a call to mfix
00:24:15 <ski> edwardk : the end-points being `O(1)' access, is that an effect of the basic finger-tree structure, or is it an "afterthought" (like accessing the minimum of a heap in `O(1)') ?
00:24:18 <edwardk> if you aren't an instance of MonadFix you can't mdo =)
00:24:25 <ski> yes, i know
00:24:55 <edwardk> ski: thats the goal of the fingertree structure. is an efficiently concatenable tree structure with efficient, snoc, cons, head, tail, init, last, etc.
00:25:18 <edwardk> the monoid provides for efficient splits, and lets it be used as a sort of functional swiss army knife
00:26:29 <ski> (i just wondered whether there's things you can express with `mfix' that you can't with `mdo' .. because you saying "mfix is necessary because it does special things for some monads" made me wonder if you were claiming `mfix' was more expressive than `mdo')
00:26:33 <edwardk> index !i!t= S.index a $ getCursor(i-measure l) where (l,r) = F.split(> i) t; Chunk a:< _ = F.viewlr -- lets me look up a position in a fingertree of bytestrings, then index the bytestring all in one tiny little line
00:26:34 <maxote> is there any possibility of curryfication or uncurryfication of some tuples/functions in Haskell?
00:26:59 <fasta> maxote: curry and uncurry
00:27:24 <edwardk> ski: no, i was saying that mfix was necessary to tie the knot over certain monads otherwise you might get bad behavior, space leaks, etc. over say using a manually tied knot ala fix
00:27:29 <uzytkownik> I have as a result shorter, clearer recursion code (although part with join & co. is less clearer): http://paste2.org/p/387937
00:27:51 <uzytkownik> (PS. Yes - I know about gtk2hs)
00:28:04 <ski> the "otherwise" being ?
00:28:13 <edwardk> why mfix (return . re) ?
00:28:25 <maxote> > src curry
00:28:26 <lambdabot>   Not in scope: `src'
00:28:30 <maxote> @src curry
00:28:30 <lambdabot> curry f x y = f (x, y)
00:28:35 <maxote> @src ucurry
00:28:36 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:28:41 <maxote> @src uncurry
00:28:41 <lambdabot> uncurry f p = f (fst p) (snd p)
00:28:59 <maxote> > uncurry ( 1 , 2 )
00:29:01 <lambdabot>   Couldn't match expected type `a -> b -> c'
00:29:06 <edwardk> that seems like a pretty complicated recursion, can't it be factored out into the pure part and the lift into your monad/applicative?
00:29:27 <maxote> > uncurry f ( a , b )
00:29:28 <lambdabot>   Add a type signature
00:30:10 <ski> > map (uncurry (+)) ([0,1,2] `zip` [3,4,5])
00:30:10 <maxote> > uncurry + ( 1 , b )
00:30:12 <lambdabot>   [3,5,7]
00:30:12 <lambdabot>   Couldn't match expected type `(a -> b -> c) -> (a, b) -> c'
00:30:16 <edwardk> uzytkownik: return . re implies that re looks like a -> b, which means you can just fix it rather than mfix it. which means it could be written without fix at all ;)
00:30:56 <ski> isn't `mfix (return . f) = return (fix f)' a `MonadFix' law ?
00:31:08 <edwardk> yeah
00:31:19 <maxote> > map (+) ([0,1,2] `zip` [3,4,5])
00:31:19 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
00:31:19 <lambdabot>    arising from a use of `GHC.Num.+' ...
00:32:17 <copumpkin> > map (uncurry (+) $ [0,1,2] `zip` [3,4,5]
00:32:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:32:21 <copumpkin> > map (uncurry (+)) $ [0,1,2] `zip` [3,4,5]
00:32:23 <lambdabot>   [3,5,7]
00:32:26 <copumpkin> aka zipWith :P
00:32:33 <uzytkownik> Thanks. It's much simpler now...
00:32:45 <copumpkin> > zipWith (+) [0,1,2] [3,4,5]
00:32:47 <lambdabot>   [3,5,7]
00:33:24 <copumpkin> (maxote)
00:33:38 <maxote> ski, copumpkin, thanks
00:33:51 <ski> uzytkownik : `mfix' is useful when you want to run a function with effects, and pass the monadic result back to itself (but still running the effects only once)
00:34:56 <ski> @type fix . (>=>)  -- this runs the effects over and over again
00:34:58 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
00:35:01 <maxote> > map (uncurry (+)) [(0,3),(1,4),(2,5)]
00:35:03 <lambdabot>   [3,5,7]
00:35:15 <maxote> > map (uncurry (+)) [(0,3,6),(1,4,7),(2,5,8)]
00:35:17 <lambdabot>   Couldn't match expected type `(a, a)'
00:35:49 <quicksilver> edwardk: a remarkable kind of swiss army knife which allows you to cut fast and accurately without damaging the uncut whole ;)
00:36:32 <copumpkin> maxote: n-tuples where n /= 2 are more painful in haskell :P
00:36:49 <edwardk> i admit fingertrees are kind of my default data structure these days... maybe because almost everything i'm using now is a monoid ;)
00:37:06 <ski> edwardk : `Chunk a:< _ = F.viewlr' ?
00:37:23 <quicksilver> edwardk: as the old saying goes, if all you've got is a fingertree everything looks like a monoid?
00:37:40 <maxote> > fst (a,b,c)
00:37:41 <edwardk> F.viewl r
00:37:41 <lambdabot>   Couldn't match expected type `(a, b)'
00:37:47 <edwardk> space got eaten =)
00:37:48 <maxote> > fst ('a','b','c')
00:37:50 <lambdabot>   Couldn't match expected type `(a, b)'
00:38:03 <edwardk> ski: basically 'head'
00:38:08 <maxote> > fst ('a','b')
00:38:13 <edwardk> Chunk there is how i'm wrapping bytestrings
00:38:29 <maxote> @src fst
00:38:47 <edwardk> ski: see the slides i linked to above for details ;)
00:39:32 <maxote> lambdabot is not answering to my questions
00:39:38 <copumpkin> @botsmack
00:39:38 <lunabot>  :)
00:39:44 <copumpkin> it went on strike
00:39:45 <ski> (ok, i was suspecting missing argument)
00:40:14 <Stinger> isnt it
00:40:17 <Stinger> @botsnack
00:40:18 <lunabot>  :)
00:40:47 <lambdabot> fst (x,_) =  x
00:40:47 <lambdabot>   'a'
00:40:49 <lambdabot> :)
00:40:53 <lambdabot> :)
00:40:59 <maxote> > fst ('a','b')
00:41:00 <Stinger> heh
00:41:01 <lambdabot>   'a'
00:41:04 <maxote> > fst ('a','b','c')
00:41:06 <lambdabot>   Couldn't match expected type `(a, b)'
00:41:11 <maxote> @src fst
00:41:11 <lambdabot> fst (x,_) =  x
00:41:43 <copumpkin> > let x = fst undefined in 5
00:41:46 <lambdabot>   5
00:42:08 <maxote> > fst (_,_)
00:42:10 <ski> > let () = fst undefined in 5
00:42:10 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
00:42:10 <copumpkin> > let x = fst undefined in x 5
00:42:12 <lambdabot>   5
00:42:12 <lambdabot>   * Exception: Prelude.undefined
00:42:37 <copumpkin> yeah, that was silly :)
00:42:52 <ski> "Pattern syntax .." hehe
00:43:19 <maxote> > snd (_,_)
00:43:21 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
00:43:24 <ski> GHC parses patterns and expressions with the same parser, iirc
00:43:50 <ski> > let ((),False) = (fst undefined,True) in 5
00:43:50 <quicksilver> yes, it does.
00:43:51 <lambdabot>   5
00:43:56 <ski> interesting
00:44:16 <ski> > let ((),Just x) = (fst undefined,Just 5) in x
00:44:18 <lambdabot>   * Exception: Prelude.undefined
00:44:24 <ski> > let (~(),Just x) = (fst undefined,Just 5) in x
00:44:26 <lambdabot>   5
00:44:30 <ski> *nod*
00:44:46 <edwardk> ski: odd
00:44:48 <fasta> Is 6.11.* source compatible with 6.10.2?
00:44:54 <quicksilver> I thought there was a case where doing that avoids backtracking but off hand I can't think of one.
00:45:10 <edwardk> quicksilver:
00:45:21 <edwardk> yeah, i wound up having to do the same thing for the kata parser as well
00:45:33 <ski> edwardk : what's odd ?
00:45:50 <edwardk> ski: the let ((),Just x) = (fst undefined, True) in 5 -- example
00:46:04 <quicksilver> let bindings are always lazy
00:46:16 <edwardk> true
00:46:23 <maxote> @src toList
00:46:23 <lambdabot> Source not found. Do you think like you type?
00:46:25 <edwardk> i realize that
00:46:32 <edwardk> it just jarred me for a sec =)
00:47:09 <ski> edwardk : yes, imo patterns and expressions should be as similar as possible .. this is why i'm a bit anxious about `e -> p' patterns, as well as suggestions of `_' expressions for `undefined' (or an assertFalse)
00:48:03 <maxote> @src third
00:48:03 <lambdabot> Source not found. Take a stress pill and think things over.
00:48:05 <edwardk> well _ expressions just fill a hole in the expression grammar that is already being parsed. i could live with that
00:48:06 <ski> as far as possible, one should be able to read the defining equations as equalities
00:48:19 <quicksilver> if you don't touch any of the names they introduce they're completely iharmless
00:48:20 <quicksilver> (although still type-checked, of course)
00:48:20 <quicksilver> s
00:48:35 <edwardk> as for -> in patterns. in kata i adopted a raw -> as lambda without the preceding \ explicitly to narrow the number of cases to parse ;)
00:49:08 <edwardk> (x -> x + 1) -- which means more backtracking if parsed conventionally but works for my style of parser nicely
00:49:14 <ski> `_' is the unit to the binary operation `@'
00:49:19 <edwardk> heh
00:49:41 <maxote> are there n-th constructions (e.g. fst, snd, third, fourth, .. nth num) for anonymous tuples and named tuples?
00:49:43 <ski> similarly, there should be a unit `^' (say), to the binary operation `|'
00:49:47 <edwardk> maxote: nope
00:49:53 <quicksilver> strangely, @ isn't binary.
00:50:00 <quicksilver> you can't put a pattern on the left, only a single name
00:50:03 <ski> quicksilver : i know, but it should be
00:50:05 <fasta> edwardk: there are.
00:50:08 <fasta> maxote: yes
00:50:13 <quicksilver> (Left x)@(Right y) is illegal.
00:50:20 <edwardk> fasta: in the prelude?
00:50:30 <fasta> edwardk: no, but who cares about the prelude?
00:50:50 <ski> in dependently typed languages, one can use such a `^' on the rhs of equations where the pattern-matches on the lhs implies inconsistency
00:51:00 <mercury^> Oh, nice. They seem to have removed a lot of the stupid benchmarks from the shootout. It's back to being somewhat meaningful.
00:51:04 <edwardk> fasta: i know i've seen ones for triples, but not ones that work on arbitrary k-tuples
00:51:16 <ski> (Agda2 writes `foo ... ()' iirc)
00:51:59 <fasta> edwardk: oh, my bad.
00:53:28 <fasta> edwardk: there is a TH implementation on the wiki, though, but not on HackageDB.
00:54:12 <edwardk> ah nice, url?
00:54:20 <maxote> i wanted to uncurry a n-fields named tuple based in uncurry f name(x1,x2,x3,..,xn) = (f name) x1 x2 x3 .. xn
00:54:42 <ski>   index : {A : Set} -> (n : Nat) -> Finite n -> Vector n A -> A
00:54:43 <ski>   index Zero ()
00:54:45 <ski>   ...
00:54:48 <ski> something like that
00:55:02 <ski> that should imo be
00:55:04 <edwardk> maxote: there is a fragment of template haskell for that
00:55:11 <ski>   index Zero _ _ = ^
00:55:24 <ski> or maybe
00:55:27 <ski>   index Zero ^ _ = ^
00:55:35 <ski> (.. hm, yes)
00:55:56 <fasta> edwardk: http://www.haskell.org/haskellwiki/Template_Haskell#Select_from_a_tuple
00:56:12 <fasta> edwardk: list -> tuple conversion is a paragraph below that
00:56:34 <ski> `_' is the pattern that matches anything, `^' is the pattern that matches nothing
00:57:16 <edwardk> fasta: ah, i remember that one. i wonder what it would take to make a nice fragment that generated a bunch of functions named first, second, third, fourth,fifth .. , nintynineth, hundredth ;)
00:57:42 <edwardk> aside from the instance explosion that is
00:57:59 <fasta> edwardk: too much. In Lisp it would be trivial, to do code-generation like that, though.
00:58:19 <ski> the name-generation would be irritating, still
00:58:46 <maxote> i wanted to separate them, uncurry for anonymous tuples and nuncurry (named uncurry) for named tuples & anon. tuples
00:58:58 <fasta> What I find irritating is that I cannot just do deriving Zipper.
00:59:07 <maxote> nuncurry f (x1,x2,x3,..,xn) = (f AnonTuple) x1 x2 x3 .. xn
00:59:18 <ski> maxote : "named tuples" ? do you mean "records" ?
00:59:28 <maxote> ski, yes
01:00:45 <ski> i'm not sure "anonymous tuples" is that good a name
01:02:17 <ski> (i'm not sure either what would be better terminology)
01:02:30 <maxote> ski, tuples and records have the same meaning in many mathematical and non-mathematical books.
01:02:36 <ski> sometimes i've been calling "tuples" "positional records"
01:02:50 <ski> yes
01:03:00 <ski> (to be able to call the dual "positional variants")
01:03:29 <maxote> the opposite of named thing is anonymous thing
01:03:48 <maxote> the opposite of named functions is anonymous functions
01:04:09 <ski> tuples are like records, where instead of using names for identifying the fields, we use the position
01:04:37 <ski> functions are values, any value may have a name (or several, or none)
01:05:12 <ski>   id = \x -> x
01:05:27 <ski> `\x -> x' is (an expression evaluating to) a function
01:05:45 <ski> `id' is a name here used to refer to that function value
01:07:02 <ski> do you disagree ?
01:07:15 <maxote> now, i need a function construction for function f doesn't take the 1st value, and starts to take the 2nd and sucessive values. I need it for nuncurry f applied to named tuples, f doesn't take the name's parameter.
01:07:53 <maxote> @src id
01:07:53 <lambdabot> id x = x
01:08:02 <ski> @type uncurry
01:08:02 <maxote> @src lambda
01:08:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:08:04 <lambdabot> Source not found. :(
01:08:34 <ski>   nuncurry :: (a0 -> a1 -> ... -> b) -> ((a0,a1,...) -> b)  -- is this what you're after ?
01:09:19 <ski> hm .. no
01:09:22 <maxote> ski, no
01:09:56 <maxote> nuncurry is a complicated internal construction but powerful
01:10:12 <ski>   nuncurry l :: (a -> (| r) -> b) -> ((l : a | r) -> b)  -- ?
01:10:40 <ski> (er, should probably insert two `Rec's there, too)
01:11:05 <ski> i.e.
01:11:24 <ski>   nuncurry l :: l \ r => (a -> Rec (| r) -> b) -> (Rec (l : a | r) -> b)
01:12:19 <ski> where `Rec (l : a | r)' is the type of records with a field `l' with value of type `a', and the rest of the fields and types given by the row `r'
01:12:40 <Saizan_> "named tuples" sounds like records like that don't apply
01:12:44 <ski> (and `l \ r' is the constraint expressing that the row `r' lacks the `l' field)
01:13:13 <maxote> so, i will have the related 4 functions curry, uncurry, nuncurry and ignfst (ignore first for using with nuncurry applied to named tuples) to cover my needs.
01:13:35 <roconnor> w00t, I just got to listen to Dana Scott explain domain theory.
01:13:47 <ski> roconnor : cool
01:14:05 <ski> maxote : so can you try to say what types you want for these functions ?
01:14:16 <roconnor> he didn't even say the words DCPO or CPO
01:14:19 <maxote> ski, polymorphic types
01:14:27 <ski> yes, but *which* types ?
01:14:28 <roconnor> it was all about algebraic (sup-)lattices
01:14:53 <roconnor> he uses the lattice of propositional logic as a universal domain
01:15:00 <roconnor> in this presentation
01:15:00 <ski> maxote : it's ok if you start with specific instances of them, for 3-tuples, records with labels `x',`y',`z', et.c.
01:16:24 <ski> roconnor : "universal domain" meaing it's a "universe set" to work in, but in this case a domain instead of a set ?
01:16:54 <roconnor> all domains are embedable in the universal domain.
01:17:06 <roconnor> including (of course) its own function space
01:17:14 <ski> with a canonical monomorphism ?
01:17:16 <roconnor> There might be a qualifier on this statement
01:17:36 <roconnor> well, there are of course many different ways of embedding
01:18:09 <roconnor> but he gave nice concrete examples of creating the product and sum and function spaces.
01:18:16 <roconnor> rather
01:19:10 <roconnor> given 2 sub-domains of the universal domain, how to construct a representative of the product and sum and function domains of these two domains.
01:19:44 <roconnor> since our universal domain is propositional logic
01:20:17 <roconnor> for example, the sums were created by something like doubling the index of the propositional variables used in one lattice
01:20:37 <roconnor> and doubling plus 1 the propositional variables in the other lattice
01:20:57 <int-e> Is there a way to put a haskell line comment in a code block inside a .cabal file's description field?
01:21:04 <roconnor> basically moving each domain to an isomorphic copy to give more room in the universal domain to perform the operation.
01:21:08 <ski> ok, so you have natural many propositional variables, then ?
01:21:12 <roconnor> yes
01:21:28 <roconnor> this is only one possible universal domain
01:21:42 <roconnor> but it is a relatively easy model for young CS students to grasp.
01:22:25 <int-e> (the problem is that Cabal also treats lines starting with -- as comments)
01:22:40 <roconnor> he is teaching a first year course on domain theory at Berkeley apparently
01:22:43 <roconnor> or taught
01:23:12 <ski> roconnor : would the product of those two sub-domains be the categorical product ?
01:23:18 <roconnor> int-e: add a where clause for a string :P
01:23:39 <roconnor> ski: I presume so, but it wasn't very clear to me.
01:24:02 <roconnor> there were two different products and two different sums
01:24:08 <ski> isomorphic ?
01:24:14 <roconnor> I assume the product and sum without the subscripts were the categorical ones
01:24:24 <roconnor> and the ones with the subscripts were modified ones
01:24:37 <roconnor> but I'm just presuming
01:24:59 <roconnor> the different product was the smach product
01:25:03 <roconnor> smash product
01:25:11 <ski> ok
01:25:15 <roconnor> where (undefined,a) = undefined = (a,undefined)
01:25:20 <ski> yes
01:25:48 <ski> no product with only `(undefined,undefined) = undefined' ?
01:26:06 <fasta> Oh, my, there are also virtual subkinds now...
01:26:13 <Saizan> (what are the elements and the order in the lattice of propositional logic?)
01:26:15 <roconnor> the regular product had (undefined,undefined) = undefined
01:26:16 <ski> fasta : ?
01:26:27 <ski> ah, good
01:26:40 <roconnor> the alternative sum operation had Left undefined = undefined = Right undefined
01:26:47 <ski> *nod*
01:26:50 <roconnor> and the normal sum operation had a "new" bottom element
01:27:14 <ski> hm
01:27:52 * ski ponders whether any of those would be the categorical coproduct
01:28:21 <roconnor> not sure
01:28:29 <ski> (A0 >-> B,A1 >-> B) <=> (A0 + A1 >-> B)
01:28:41 <roconnor> I presumed the sum with a "new" bottom was the categorical coproduct
01:28:50 <roconnor> since he used the + symbol
01:29:07 <roconnor> granted this isn't all that strong evidence
01:29:08 <roconnor> :)
01:30:00 <fasta> ski: what is a subkind? I know what a kind is, but AFAIK, a kind is just a concrete type, which cannot decomposed further other than in values.
01:30:19 <ski> so e.g. `\a01 -> _|_' would correspond to `(\a0 -> _|_,\a1 -> _|_)', going back, we get `\a01 -> case a01 of Left a0 -> _|_; Right a1 -> _|_'
01:30:22 <ski> so
01:30:30 <ski>   \a01 -> _|_  =  \a01 -> case a01 of Left a0 -> _|_; Right a1 -> _|_
01:30:38 <ski> in the categorical coproduct one
01:31:03 * ski wonders if that's leading anywhere
01:32:09 <ski> fasta : a kind is not a type, a kind is a "type of types", in the same sense that a type is "a type of values"
01:32:14 <roconnor> I didn't quite understand that
01:32:45 <fasta> ski: yes, I meant the type of concrete types.
01:33:02 <fasta> ski: sorry, for being unclear.
01:33:07 <ski> roconnor : no conclusion yet. i'm trying to see if i'm on the wrong trail
01:33:34 <fasta> ski: in particular kind *.
01:33:49 <ski> fasta :  value : type  ::  type : kind
01:33:52 <ski> also
01:34:05 <ski>   sub-type : type  ::  sub-kind : kind
01:34:21 <quicksilver> fasta: in GHC, for example, the kind of unboxed types is a subkind of the kind of all concrete types.
01:34:32 <quicksilver> fasta: richer kind systems may have more examples.
01:34:40 <ski> e.g. row kinds
01:35:00 <fasta> Can you also say that in Coq terms?
01:35:09 <ski> (s/row kinds/the row kind/)
01:35:38 <roconnor> fasta: presumably type_3 is a subkind of type_4
01:35:56 <ski> (`foo : bar  ::  baz : quux' means "`foo' is to `bar' as `baz' is to `quux'")
01:36:22 <ski> roconnor : s/subkind/subsort/, no ?
01:36:41 * ski is not sure on the terminology in Coq
01:36:46 <roconnor> in coq types and kinds aren't really as distinct as in Haskell
01:37:06 <fasta> Type_0 is just a type in Coq, IIRC.
01:37:29 <ski> yes, i was thinking in `v : t : k : ...' all the `t',`k',... would be sorts, but only `k' a kind
01:37:52 <ski> but maybe they call all those simply types ?
01:37:57 <roconnor> I should say that type_3 is a `subkind` of type_4 not because type_3 : type_4 but rather because a : type_3 implies a : type_4
01:38:20 <fasta> roconnor: right
01:38:52 <mattam> We use "sort" for Prop/Set/Type_i, and sorts are types. LF people use kinds for the same thing (plus some Pi kinds).
01:39:09 <ski> roconnor : yes, only that the question then is whether `type_3' and `type_4' are kinds
01:39:32 <ski> mattam : ah, ty
01:39:52 <roconnor> in that type_2, type_3 etc have types as members, they are kinds
01:40:37 <fasta> Summarizing, a kind correspond to some set of elements, which are concrete types and a sub-kind is then just a sub-set of this set.
01:40:56 <fasta> corresponds*
01:42:00 <roconnor> that is my understanding
01:42:06 <ski> (`Gamma |- e : sigma  ==>  Gamma |- e : tau' means `sigma' is a sub-type of `tau' .. all this while `sigma' and `tau' are types)
01:42:48 <ski> (hence `type_3' could be a sub-kind of `type-4' only if both are kinds)
01:43:24 <cjs> What's the cannonical way to enable and disable servers in Ubuntu?
01:43:44 <roconnor> cjs: /etc/init.d/foo start
01:43:47 <roconnor> cjs: /etc/init.d/foo stop
01:43:58 <ski> restart
01:43:58 <roconnor> there is probably a UI app somewhere
01:44:09 <roconnor> which is the "right" way of doing this
01:44:15 <cjs> By "enable" and "disable" I mean, "when it's disabled, don't start it up on boot."
01:44:23 <roconnor> ah
01:44:24 <cjs> I am on the wrong freaking channel again.
01:44:27 <roconnor> yes
01:44:30 <cjs> Grrr, I hate this IRC client.
01:44:35 * Zao pets the invoke-rc.d script.
01:46:01 <ski> roconnor : ah, now i see what i did wrong
01:46:11 <maxote> uncurry f x = nuncurry (ignfst f) x where f is a function, x is either an anonymous tuple or named tuple, and ignfst is a predefined stateful function inside of a context (when 1st value is ignored).
01:46:42 <ski> so e.g. `\a01 -> ()' would correspond to `(\a0 -> (),\a1 -> ())', going back, we get `\a01 -> case a01 of Left a0 -> (); Right a1 -> ()'
01:46:49 <ski> i.e.
01:46:57 <ski>   \a01 -> ()  =  \a01 -> case a01 of Left a0 -> (); Right a1 -> ()
01:46:58 <fasta> Is a type family then simply a Type_2?
01:48:00 <ski> roconnor : what happens if we feed the lhs and rhs with `_|_' ?
01:49:00 <ski> roconnor : hrm, i should probably ask if there's any non-strict morphisms is this category of domains
01:49:12 <Saizan> fasta: a type family is a function on types like type constructors are, the only difference is that type constructors don't reduce
01:49:15 <roconnor> I didn't fully understand the function domain
01:49:21 <roconnor> but presumably they were lazy.
01:49:35 <ski>   A0 + A1 >-> 1
01:50:00 <ski> (or more or less `1' anyway .. haskell's `()')
01:50:09 <fasta> Oh, right, the Type_2 doesn't really make sense.
01:52:02 * ski is not sure any of those sum types would be categorical coproducts ..
01:52:13 <maxote> If x is an anonymous tuple then uncurry agrees the specification. If x is a named tuple then uncurry does as if the it's an anonymous tuple.
01:53:47 <ski> maxote : any example eludicating what that means ?
01:54:06 <Saizan> is it possible to write an IsVar a bool typeclass? which should work like var/1 in prolog?
01:54:32 <ski>   class IsVar a where var :: a -> Bool
01:54:32 <ski> ?
01:55:08 <ski> (if so, what should it do ?)
01:55:10 <Saizan> no, it should be a typelevel boolean
01:55:17 <maxote> uncurry f (x1,x2,x3) = f x1 x2 x3  ;  uncurry f AnonTuple(x1,x2,x3) = f x1 x2 x3  ;  uncurry f name(x1,x2,x3) = f x1 x2 x3  ;  AnonTuple(x1,x2,x3) == (x1,x2,x3) returns true .
01:55:43 <Saizan> and instantiate bool to HTrue only if a is not instantiated
01:55:54 <ski> i'd hope that's not possible
01:55:58 <ski> (and i don't think it is)
01:56:32 <quicksilver> the concept of something 'being' a variable is not really defined is it?
01:56:44 <ski> indeed
01:57:00 <Saizan> yeah, it'd be quite hacky
01:57:23 <Saizan> though since there's a Typeable for polymorphic types maybe this is possible too
01:57:45 <quicksilver> first class polymorphism still isn't quite the same thing as variable.
01:57:50 <quicksilver> (forall a . a) isn't the variable a.
01:57:52 <ski> maxote : i don't know what this `AnonTuple' is good for; and the `name' example seems equally useless
01:58:40 <ski> Saizan : s/polymorphic types/parametric types/ (it's not the same thing)
01:59:18 <ski> (or maybe s/parametric/parameterized/ ..)
01:59:19 <Saizan> well, it just gives a partial answer if you've a typeclass context :)
01:59:44 <ski> "it" being ?
02:00:43 <Saizan> http://hackage.haskell.org/package/polytypeable
02:00:57 <maxote> my OO diagram is simple, the superclass is AbstractNamedTuple that has the field nameOfTuple, their children classes are AnonTuple and the NamedTuple, AnonTuple's nameOfTuple is AnonTuple, NamedTuple's nameOfTuple is the value that is given by the user in the code.
02:01:37 * Zao sets nameOfTuple to AnonTuple on his NamedTuples.
02:01:44 <ski> Saizan : .. hm
02:01:50 <Saizan> Prelude Data.PolyTypeable> polyTypeOf show
02:01:51 <Saizan> a1 -> [Char]
02:02:08 <Zao> maxote: Any particular reason why you don't just let the name be empty for an anon one?
02:02:20 <quicksilver> maxote: you diagram is simple, but what's the *point*
02:02:26 <quicksilver> maxote: what problem are you actually trying to solve?
02:02:51 <maxote> yes, (f AnonTuple) does f recognizes that it's an AnonTuple instead of named tuple.
02:03:21 * ski isn't sure that any OO diagram is simple
02:03:41 <maxote> (f Just) a does f recognizes that it's a named tuple Just(a) of kind Maybe
02:04:00 <maxote> (f Nothing) does f recognizes that it's a named tuple Nothing of kind Maybe
02:04:17 <ski> what is "it", here ?
02:04:52 <maxote> ski, it = the 1st parameter
02:05:01 <quicksilver> maxote: your terminology is all wrong.
02:05:15 <quicksilver> maxote: Just a is a not a "named tuple of kind Maybe"
02:05:25 <quicksilver> Just is a constructor - or alternative - of *type* Maybe.
02:05:25 <maxote> @src Maybe
02:05:25 <lambdabot> data Maybe a = Nothing | Just a
02:05:29 <ski> `Nothing' doesn't have kind `Maybe', it has *type* `Maybe a' (for any type `a' (of kind `*') you like)
02:05:51 <quicksilver> maxote: but I think you're trying to do some generic type traversal
02:05:55 <quicksilver> mind you I still don't understand why.
02:06:07 <quicksilver> generic type traversal in general rather defeats the points of typeful programming.
02:06:22 <quicksilver> in some cases it can be very useful, though - and there are haskell libraries for it.
02:06:24 * ski was thinking maxote wanted to do some abstraction pertaining to both tuples and records
02:07:23 <maxote> maybe  e.g. data MyTree a = Leaf a | InternalSubTree of (a, MyTree a, MyTree a)
02:08:19 <ski> .. maybe your `uncurry' is meant to be a general `case'er ?
02:08:39 <ski>   uncurry Maybe :: (r) -> (a -> r) -> (Maybe a -> r)  -- ?
02:08:54 <ski>   uncurry (,) :: (a -> r) -> (b -> r) -> ((a,b) -> r)  -- ?
02:09:08 <ski>   uncurry [] :: (r) -> (a -> [a] -> r) -> ([a] -> r)  -- ?
02:09:31 <maxote> i said that it's an easier construction in Haskell
02:10:07 <ski> (er, obviously that `(,)' should be `Either' ..
02:10:17 <ski>   uncurry (,) :: (a -> b -> r) -> ((a,b) -> r)  -- corrected
02:10:19 <ski> )
02:10:46 * ski is still trying to guess what maxote is after
02:10:51 <maxote>  err, /it's an/it's not/
02:11:16 <maxote> i doesn't know how Haskell can manipulate the tuples
02:12:04 <ski> i think it would still be more helpful if you gave more (concrete) examples of what you want
02:12:09 <quicksilver> haskell tuples are independent types.
02:12:23 <quicksilver> there are no functions which are generic over them because, as far as the type system is concerned, they are unrelated.
02:12:33 <quicksilver> it is possible to devise type-class schemes which relate them
02:12:38 <quicksilver> if you do that, you get HList
02:12:44 <quicksilver> ...which is jolly clever stuff.
02:12:48 <ski> i.e., give examples for pairs, triples, quadruples, records with fields `x',`y',`z', et.c.
02:12:51 <quicksilver> But it's not needed in typical programming tasks.
02:13:05 <maxote> even could exist the empty tuple
02:13:12 <ski> @kind ()
02:13:14 <lambdabot> *
02:13:16 <ski> @type ()
02:13:18 <lambdabot> ()
02:13:33 <ski> that's the empty tuple (and its kind)
02:13:37 <ski> (er, type)
02:14:11 * ski goes in search of nutrition ..
02:15:59 <maxote> ncurry f name x1 x2 .. xn = f name(x1,x2,..,xn)  ;  ncurry f AnonTuple x1 x2 .. xn = f AnonTuple(x1,x2,..,xn) = f (x1,x2,..,xn)
02:16:29 <ski> what is `name' meant to be here ?
02:16:33 <quicksilver> that still doesn't make sense, maxote.
02:16:34 <ski> a (data) constructor ?
02:16:39 <maxote> curry f x = ncurry f AnonTuple x
02:17:07 <Saizan> hah, you can write IsVar with O(n) instances where n = #types of kind * you want to support
02:17:09 <ski> possible instance : `ncurry f Just x1 = f (Just x1)' ?
02:17:35 <ski> another instance : `ncurry f (,) x1 x2 = f ((,) x1 x2)' ?
02:19:03 <ski> maxote : maybe you're unaware that the constructor of pairs is `(,)' ?
02:19:13 <ski> > (,) 1 'a'
02:19:14 <lambdabot>   (1,'a')
02:19:44 <maxote> > (,) 'a' 2 3.0
02:19:46 <lambdabot>   Couldn't match expected type `t1 -> t'
02:19:53 <ski> > (,,) 'a' 2 3.0
02:19:55 <lambdabot>   ('a',2,3.0)
02:20:10 <maxote> ski, in your code appears (,) instead of (,,)
02:20:28 <ski> yes, `(,,)' is the constructor of triples
02:20:47 <ski> yet another instance : `ncurry f (,,) x1 x2 x3 = f ((,,) x1 x2 x3)' ?
02:21:15 <maxote> i want a general construction, not many particular/specific constructions
02:22:09 <ski> if you want one without changing haskell, then `name' has to be allowed to be any expression, not just an identifier (data constructor or whatever)
02:22:35 <quicksilver> maxote: you can't have it, because what you want isn't well-typed.
02:22:43 <ski> also, you want an induction over the number of `->' down the right spine of the type of `name'
02:23:24 <ski> possibly it can be done with overlapping instances .. hm
02:24:15 <ski> (btw, i've made the obvious modification of maxote's proposal to `ncurry f name x1 x2 .. xn = f (name x1 x2 .. xn)')
02:27:03 <harblcat> in the haskell platform, are GLUT and OpenGL 'good' for use in making things that need to be responsive?
02:27:49 <quicksilver> sure.
02:28:01 <ski>   class NCurry b c as_b as_c
02:28:08 <ski>     where
02:28:14 <ski>     ncurry :: (b -> c) -> as_b -> as_c
02:28:21 <maxote> initially, every tuples (named & anon.) are abstracted named tuples, the optimizer can omit the nameOfTuple field to the anonymous tuples from the code in the last stages of the optimization.
02:28:24 <ski>   instance NCurry b c as_b as_c => NCurry b c (a -> as_b) (a -> as_c)
02:28:26 <ski>     where
02:28:34 <ski>     ncurry bc a_as_b a = ncurry bc (a_asb a)
02:28:41 <ski>   instance NCurry b c b c
02:28:43 <ski>     where
02:28:47 <ski>     ncurry bc b = bc b
02:28:51 <ski> maxote : try that
02:29:18 <ski> (with `{-# LANGUAGE OverlappingInstances #-}' iirc)
02:30:08 <ski> (or does it need inconsistent instances ?)
02:30:37 <quicksilver> harblcat: although opengl isn't the easiest api to learn.
02:31:05 <maxote> ncurry () Just 2
02:31:07 <maxote> > ncurry () Just 2
02:31:08 <lambdabot>   Not in scope: `ncurry'
02:31:29 <ski> maxote : put it in a `hs' file on your machine and run GHCi
02:31:35 <augustss_> ski: the tuple package on hackage has CurryN
02:31:49 <ski> augustss_ : i'm not surprised
02:32:00 <ski> :)
02:32:42 <nvoorhies_> opengl's considerably better than a lot of the alternatives
02:32:46 <augustss_> It also has some other handy functions, like sel2 to select the second component in a tuple
02:32:53 <ski> @hackage tuple
02:32:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tuple
02:33:15 <maxote> remember, ncurry & nuncurry don't mean curry/uncurry to n-fields tuples, they mean curry/uncurry to named tuples (n-fields too).
02:33:48 <augustss_> oh, ok
02:33:56 <augustss_> I see
02:34:18 <ski>   ncurry f (,) a b = f (a,b)
02:34:26 <ski>   ncurry f Just a = f (Just a)
02:34:33 <maxote> i wanted a 1-field anon tuple with named tuple Just inside, it's  ( Just(2) )
02:35:18 <ski> there is no 1-tuples
02:35:28 <augustss_> there's a package :)
02:35:35 <maxote> @src ()
02:35:35 <lambdabot> data () = ()
02:35:40 <ski> (you can make a type that you call "1-tuple" if you like, though, but no standard such)
02:35:53 <ski> @src (,)
02:35:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:36:02 <ski>   data (a,b) = (,) a b
02:36:41 <ski> maxote : so, does the `ncurry' above fit your needs ?
02:37:24 <maxote> i've a problem, Haskell is a full of particular constructions that don't meet my requirements.
02:37:39 <Saizan> augustss_: shouldn't Data.PolyTypeable allow the user to make new BASE instances?
02:38:05 <ski> any specific such particular construction you have in mind ?
02:38:07 <augustss_> Saizan: I'm sure it should :)
02:38:47 <maxote> the Haskell's primitives of tuples are too particular instead of general.
02:39:04 <ski> i agree with that
02:39:08 <augustss_> Saizan: I don't think PolyTypeable is usuable in practice, but it's an incredibly clever Oleg hack
02:39:37 <harblcat> Apparently, the OpenGL and GLUT in the haskell platform need a bit of work on Windows, in order to work?
02:39:53 <fasta> augustss_: how do you write your zippers? By hand/automatic/..?
02:39:56 <quicksilver> harblcat: you need to at least move GLUT32.DLL to the right place, I believe.
02:40:21 <quicksilver> harblcat: never have used windows I'm not familiar with the details. C:\Windows\System or something?
02:40:26 <Saizan> augustss_: heh, i remembered about it when trying to type-case on wheter a variable is instantiated or not
02:41:01 <quicksilver> maxote: that's a subjective judgement. I find them fine.
02:41:07 <augustss_> fasta: by hand
02:41:08 <ski> Saizan : i'm a bit too tired to follow the source of that atm, but i think i'll probably stand corrected
02:41:37 <quicksilver> maxote: I don't know what *actual* *genuine* *problem* you're trying to solve.
02:41:46 <quicksilver> if I did I might be able to suggest solutions.
02:41:48 <ski> Saizan : do you happen to know if it uses a variant of the `\+ X \= chalk,\+ X \= cheese' trick ?
02:41:57 <maxote> in many mathematical books, the tuples are defined for arities from 0 to finite natural N
02:42:26 <augustss_> maxote: very sensibly so
02:42:52 <maxote> Haskell has particular operations for 2-tuples, some subsets for 3-tuples, none for 0-tuples, none for 1-tuple, etc.
02:42:58 <quicksilver> the tuple package augustss_ pointed you towards does solve some of the problems you've discussed.
02:42:59 * ski prefers up-to (but not including) a finite natural
02:43:06 <quicksilver> but even so, I find them non-problems.
02:43:24 <quicksilver> I don't find being generic over tuples a common requirement when writing real code.
02:43:27 <maxote>  /subsets/subsets of operations/
02:44:08 <Saizan> ski: it's simpler than that, instance IsVar () HFalse, instance IsVar Bool HFalse, ... instance IsVar a HTrue, the last instance matches when 'a' is not instantiated too
02:44:31 <augustss_> maxote: tuples in Haskell are not really made to be operated on.  Not much, at least
02:44:36 <ski> maxote : you want names for `const ()',`flip const ()' ?
02:44:37 <Saizan> or when 'a' is instantiated to some type that doesn't match the other ones
02:45:09 <maxote> so, i can't write a general construction when Haskell supports only many particular primitives and lacks some of them.
02:45:15 <Saizan> though i don't understand how it generically deals with higher-kinded type constructors
02:45:22 <Saizan> (yet)
02:45:29 <augustss_> maxote: when Haskell was designed the type system didn't allow tuples to be as flexible as one would have wanted.
02:45:31 <ski> Saizan : with a fundep ?
02:45:47 <maxote> thanks augustss_ for the acknowledgement.
02:46:04 <Saizan> ski: ah, yes
02:46:06 <augustss_> maxote: the basic problem is that tuples are not inductively defined
02:46:52 <augustss_> maxote: but these days you can get what you want, so you could define your own tuples, with slightly different syntax.
02:46:57 <maxote> augustss_, and are the lists inductively defined?
02:47:06 <augustss_> maxote: yes
02:47:09 <ski>   data [a] = [] | a : [a]
02:47:20 <sohum> hm. if I have data Foo = A Int | B Int | C Int, can I write a f :: (Foo -> Int) -> Foo -> Int, which is called like f A (A 2) = 2 ?
02:47:53 <Saizan> no
02:47:54 <augustss_> sohum: yes, but not easily
02:47:57 <sohum> without pattern matching?
02:48:01 <ski> sohum : you can only match on fully-applied constructors
02:48:13 <quicksilver> sohum: patterns are not really first-clas.
02:48:22 <ski> also, `A : Int -> Foo', not the other way around
02:48:27 <ski> s/:/::/
02:48:31 <sohum> ski: ah, yes, my bad
02:48:45 <sohum> augustss_: so what's the not easily way of doing it?
02:49:14 <Saizan> you could derive Data and get the name of the constructor with one of the methods
02:49:27 <augustss_> sohum: you'd have to derive Data or Show, and then you can analyze the arguments using reflection
02:49:54 <sohum> Saizan, augustss_: ah. ok then, thankee.
02:50:00 <augustss_> The SYB papers have an example of this.
02:51:37 <augustss_> > take 4 $ show $ Just (undefined::Int)
02:51:39 <lambdabot>   "Just"
02:51:57 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/syb/src/Data-Generics-Twins.html#geq
02:52:01 <fasta> sohum: why can't you just use fields?
02:52:21 <sohum> fasta: good question. thank you.
02:52:29 <ski> fields ?
02:52:36 <augustss_> sohum: so by applying the first argument to undefined, and then showing it and looking very carefully at the string you can figure out which constructor it is
02:52:39 <fasta> ski: named record fields.
02:52:53 <ski> fasta : how does it apply here ?
02:52:53 <Saizan> ah, the problem was extracting the number, not checking the constructor was the same?
02:53:02 <augustss_> sohum: but I'd try something totally different before going down this route
02:53:34 <ski> fasta : oh .. maybe you mean `data Foo = F ABC Int; data ABC = A | B | C' ?
02:53:35 <fasta> ski: A {int::Int}|B {int::Int} ... and then f c k = int k
02:53:58 <sohum> augustss_: heh, yep.
02:54:16 <ski> fasta : oh .. i was assuming sohum wanted a failure in the `f B (A 2)' case
02:54:16 <fasta> ski: of course the the c argument is useless.
02:54:40 <fasta> ski: oh, I didn't know he wanted that. Didn't follow the whole discussion.
02:54:41 <augustss_> Saizan: I was first solving the problem of figuring out what to extract :)
02:54:51 <ski> fasta : i'm not sure. i just assumed it
02:55:27 <fasta> Does using a download accelerator help on haskell.org?
02:57:58 * ski assumed "download accelerators" was mostly adware/spyware
02:58:46 <fasta> On dial-up (a long time ago) they did work and the concept can work if the server doesn't check for multiple connections from the same address.
02:59:22 <ski> so how is the transfer accelerated ?
02:59:59 <fasta> ski: by saying: get me bith 1..n/2 and n/2+1..n in parallel.
03:00:10 <fasta> ski: you can of course do that with as many threads as you want.
03:00:18 <fasta> bit*
03:00:59 <ski> the idea being that packages need not arrive in order ?
03:01:15 <fasta> ski: you mean packets?
03:01:20 <ski> er, sorry, yes
03:01:24 <fasta> ski: I don't think it works at that level.
03:01:39 <quicksilver> no, it's two separate HTTP requests
03:01:43 <quicksilver> (or whatever)
03:01:52 <fasta> ski: I think it basicaly says: hi server, I already have these bits already, please send me the rest.
03:02:00 <quicksilver> I think it's likely to make the haskell.org admins pretty peeved at you.
03:02:02 <fasta> ski: and the client would be lying initially then.
03:02:26 <ski> i'm not sure i see why it would help
03:02:43 <fasta> ski: because haskell.org is bandwidth limited per slot.
03:03:23 <ski> oh, so it's a way to steal more bandwidth (out from haskell.org) ?
03:03:37 <fasta> Well, I wouldn't call it stealing, but yes.
03:03:54 <fasta> >50MB files should simply be torrents then.
03:04:02 <fasta> If they don't have enough bandwidth.
03:04:10 <roconnor> ski: I think I can prove the sum is categorical.
03:04:23 <ski> roconnor : which of them ?
03:04:31 <roconnor> the one with the new bottom
03:04:41 <roconnor> and definitely not the other
03:05:44 <roconnor> Definitely no the other because given f = const 1 and g = const 2, f +c g would have to send bottom to both 1 and 2.
03:06:23 <ski>   \a01 -> ()  =  \a01 -> case a01 of Left a0 -> (); Right a1 -> ()  -- so this holds with the former sum ?
03:06:47 <roconnor> given the sum with the new bottom and given f : A -> C and g : B -> C, then f + g is clearly defined on everything but the new bottom
03:06:52 <roconnor> and uniquely so
03:07:04 <roconnor> so we only have to figure out where (f + g) of bottom goes.
03:07:15 <opqdonut> bottom is a good choice
03:07:17 <opqdonut> works always
03:07:22 <roconnor> but (I think) it has to make this choice idependently of f and g?
03:07:31 <opqdonut> generally, yes
03:07:33 <roconnor> and the only choice that will work for all f and g is the new bottom
03:07:39 <roconnor> um
03:07:49 <roconnor> but if the choice can depend on f and g, then this argument doesn't work
03:07:54 <ski> `(A,B) >-> (C,C)' should be naturally iso to `A + B >-> C'
03:08:39 <roconnor> ski:  how do I interpret () in your comment above
03:08:50 <ski> the empty tuple
03:08:50 <roconnor> is it the two element domain (Sperpinski space)?
03:08:55 <ski> yes
03:09:15 <ski> (s/Sperpinski/Sierpinski/)
03:09:26 <roconnor> ski:  that equality should hold since the two functions are extensionally equal
03:09:35 <roconnor> ski: thanks
03:09:53 <ski> the left one maps `_|_' to `()', what does the right one map `_|_' to ?
03:09:57 <roconnor> ski: oh right
03:10:04 <roconnor> hmm
03:10:24 <ski> (well, the left one maps `_|_' iff there is non-strict morphisms .. otherwise it obviously maps to `_|_')
03:10:38 <roconnor> ski:  then they appear to be different.
03:10:43 <ski> (s/iff/to `()' iff/)
03:10:45 <roconnor> yes, I think they are different
03:11:50 <ski> that equation was just derived from composing the two directions of the adjunction inference together
03:12:13 <roconnor> ski: are you saying that they ought to be equal?
03:12:27 <ski> if it is supposed to be a categorical coproduct, yes
03:12:32 <roconnor> oh
03:12:42 <roconnor> how does that reasoning go?
03:13:21 <ski>   (A,B) >-> Delta C
03:13:25 <roconnor> (maybe the choice of (f + g)(_|_) can depend on f and g).
03:13:26 <ski>   =================
03:13:27 <ski>   A + B >-> c
03:13:36 <ski> is the adjunction (bi-)inference
03:13:45 <ski> (s/c/C/)
03:13:55 <roconnor> ok
03:13:59 <ski> that characterizes `+'
03:14:02 <roconnor> right
03:14:25 <roconnor> we are taking C to be ()
03:14:31 <ski> i instantiated the lower part with `\a01 -> ()', then went up and down argain
03:14:34 <ski> s/argain/again/
03:14:41 <roconnor> oh
03:14:44 <roconnor> ah
03:14:45 <ski> yes, `C' is `Sierpinski'
03:14:50 <roconnor> compelling argument
03:15:10 <roconnor> ok
03:15:34 <roconnor> it is pretty clear because (f + g)(_|_) is always (_|_)
03:15:37 <ski> (it relies on the bi-inference not only being a biimplication, but actually an isomorphism)
03:15:47 <roconnor> however not every function on (A + B) sends bottom to bottom.
03:16:01 <roconnor> so I guess it isn't categorical
03:16:04 <ski> yes, hence `Sierpinski' and `()'
03:16:33 <roconnor> okay
03:16:39 <ski> it might be categorical in a category where every morphism is strict ..
03:16:50 <roconnor> later I will try to ask Dana if his sums and products are categorical.
03:16:54 <roconnor> see what he says.
03:17:15 <roconnor> I think making morphisms strict would be a very bad thing to do in domain theory.
03:17:20 <ski> please report back with the anwers :)
03:17:42 <ski> (yes, it seems strange .. it was a thought)
03:17:51 <roconnor> understood
03:19:14 <ski> (in case the function space is not an exponential, maybe the above argument doesn't hold .. due to mixing-up of function values and morphisms)
03:19:40 <roconnor> oh
03:19:42 <ski> hm .. maybe that sum might still be a weak coproduct
03:20:00 * ski tries to recall the definition of that
03:20:01 <roconnor> you are saying that the category might not be CCC?
03:20:10 <ski> i don't know
03:20:24 * ski hasn't really read any domain theory
03:20:30 <roconnor> CCC means that functions are morphisms?
03:20:37 <roconnor> or rather closed means this?
03:20:45 <ski> (apart from bits and pieces in a few papers, that is)
03:21:21 <quicksilver> closed just means there is a correspondance between certain morphisms and certain other morphisms.
03:21:22 <ski> `Cartesian' is all finite products (or was it finite limits ?)
03:21:49 <quicksilver> you need 'cartesian' to interpret one of those sets of morphisms as functions.
03:21:56 <ski> closed is `(A *) |- (A ->)'
03:21:57 <quicksilver> (and hence, both of them)
03:22:03 <quicksilver> and then functions become morphisms.
03:22:05 <ski> er, s/|-/--|/
03:23:11 <roconnor> ski: Cartesian has coproducts too?
03:23:22 <ski> no
03:23:24 <roconnor> oh
03:23:36 <ski> cartesian closed implies having coproducts, though
03:23:42 <roconnor> interesting
03:38:38 <nominolo> @unpl (flip (.))
03:38:39 <lambdabot> (\ b c f -> c (b f))
03:41:52 <roconnor> > exp 1 :: CReal
03:41:55 <lambdabot>   2.7182818284590452353602874713526624977572
03:43:01 <ski> > log (-1) :: Complex CReal
03:43:03 <lambdabot>   0.0 :+ 3.1415926535897932384626433832795028841972
03:43:14 <roconnor> > let bar f x = 0.5*f (0.5*x) in bar sin (bar cos (bar sin (bar exp 1))) :: CReal
03:43:17 <lambdabot>   0.1230949776875652679587490311834787769252
03:44:03 <roconnor> I'm thinking of defining integration for lambdabot, but I'm worried the default show will request too many digits
03:44:30 <ski> integration, how ?
03:44:35 <quicksilver> roconnor: and make it too slow?
03:44:36 <ski> something AD-like ?
03:45:01 <roconnor> quicksilver: ya, too slow to get a result before lambdabot times out
03:45:32 <ski> @type showCReal
03:45:33 <roconnor> ski: using martin's seemingly impossible function, one should be able to compute the modulus of continuity of any real function.
03:45:34 <lambdabot> Int -> CReal -> String
03:45:50 <roconnor> ski: with the modulus, one can integrate without difficulty.
03:45:52 <ski> roconnor : escardo's ?
03:45:55 <roconnor> yes
03:46:11 * ski has only seen such on streams
03:46:37 <roconnor> it works on essentially any compact space
03:46:48 <roconnor> I think
03:46:51 <roconnor> anyhow
03:46:57 <ski> and you have an `instance Compact CReal' ?
03:47:01 <roconnor> since stream real numbers are isomorphic to CReal real numbers
03:47:09 <roconnor> one could always just factor through the isomorphism
03:47:25 <roconnor> Of course, one would want to rewrite this naive solution to make it more efficent.
03:47:46 <roconnor> actually, stream real numbers are only [-1,1]
03:47:51 <roconnor> (more clearly compact)
03:48:08 * ski is not sure what `stream real numbers' are
03:48:08 <roconnor> ah
03:48:13 <roconnor> hm
03:48:36 <roconnor> perhaps we can only integrate bounded functions.
03:48:42 <roconnor> with a known explicit bound.
03:49:15 <roconnor> (explicit bound on the domain of integeration)
03:49:19 <ski> not any with compactly domained ?
03:49:37 <roconnor> hm?
03:49:44 <roconnor> isn't integration always on a compact domain
03:50:21 <ski> sorry, i just wondered if compact domain was not sufficient
03:50:42 <roconnor> oh ya
03:50:47 <roconnor> I'm not sure if more is needed or not
03:50:51 <quicksilver> continuous functions on compact domain *are* bounded.
03:51:02 <maxote> my conclusion is that Haskell lacks the "inductive definition of the tuples" although this language has higher-kinded data constructors.
03:51:18 <roconnor> quicksilver: yes, right.  But is the bound effective?
03:51:21 <roconnor> quite possibly.
03:51:23 <quicksilver> maxote: you can define tuples inductively, though. See HList.
03:51:35 <quicksilver> maxote: or, just use nested 2-tuples, always
03:51:40 <quicksilver> which is effectively what HList does.
03:51:52 <quicksilver> ((((a,b),c),d),e)
03:52:02 <quicksilver> (((((),b),c),d),e) more like
03:52:08 <ski> i was assuming the domain being bounded meant that there exists `a',`b' such that the domain is `{x | a =< x =< b}'
03:52:29 <roconnor> ski: boundedness refers to the range
03:52:36 <roconnor> sorry, I probably muddled that up a bit
03:52:37 <ski> oh
03:52:56 <ski> ok
03:56:12 <hackagebot> ministg 0.1 - an interpreter for an operational semantics for the STG machine. (BerniePope)
03:56:35 <Vanadium> How would I go about writing a function with type Show a => a -> String that is id when a is String and show otherwise?
03:56:46 <roconnor> quicksilver: ah, we can probably find an upper bound by searching all natural numbers asking if the forall x \in [0,1], is f(x) <= n.
03:56:55 <ski> Vanadium : with care
03:56:59 <roconnor> or whatever range you integrate over
03:57:05 <roconnor> or whatever domain you integrate over
03:57:09 <roconnor> I mean
03:57:10 <ski> Vanadium : in this case, with overlapping-instances
03:57:28 <Vanadium> All right, thanks.
03:58:04 <roconnor> and since [0,1] is compact the question is  forall x \in [0,1], is approx(1, f(x)) <= n. is decidable.
03:58:19 <roconnor> where approx(1, f(x)) returns a rational number within 1 of f(x)
03:58:27 <roconnor> ugh, I've muddled this a bit
03:58:31 <ski> Vanadium : note that it won't use `id' on the `String' part of `(String,Int)', though
03:58:32 <roconnor> but I'm convinced. :)
03:58:52 <Vanadium> ski: Would not expect it to, yeah
04:00:01 <ski> roconnor : which rational number ?
04:00:22 <roconnor> any
04:00:28 <roconnor> whatever it wants
04:00:42 <roconnor> for example, the one that show prints.
04:00:43 <ski> is it uniquely determined (i.e. same for any representant of the same real number) ?
04:00:50 <roconnor> no
04:01:05 <roconnor> but we are just searching for some upper bound
04:01:13 <hackagebot> ministg 0.2 - an interpreter for an operational semantics for the STG machine. (BerniePope)
04:01:25 <ski> (so it's an "operation" in the Bishop sense ?)
04:01:32 <roconnor> ski:
04:01:43 <roconnor> ski: yes. ... not that I like his termonology
04:02:00 <ski> ok. which do you prefer ?
04:02:17 <roconnor> I call his operations functions
04:02:33 <roconnor> and I call his functions either morphisms or more specifically respectful functions.
04:02:40 <ski> ok
04:02:46 <roconnor> but that is just me :)
04:02:54 <roconnor> me and my thesis
04:03:41 <ski> and `forall x \in A. g(x) =< n' is decidable even if `g' is not respectful (for a compact `A') ?
04:04:51 * ski imagines a merry song named "Me and my Thesis" ..
04:06:37 * tibbe feels that the Haddock "index" at the top of every Haddock page isn't very useful.
04:06:43 <quicksilver> Vanadium: don't do that.
04:07:00 <quicksilver> Vanadium: overlapping instances are a poor idea, and non-composable.
04:07:27 * ski agrees
04:09:25 <ski> When I'm working all day long / When the answers all turn out wrong / When I'd rather be playing Pong / When I'm singing this silly song - It's me and my thesis !
04:10:18 * ski refrains from any further artistic atrocities
04:15:01 <maxote> given function `f' and a tuple (anon. or named) `x' represented by either name(x1,x2,..,xn) or AnonTuple(x1,x2,..,xn) or (x1,x2,..,xn), it agrees  ncurry (nuncurry f x) = f ;  (nuncurry (ncurry f name x1 x2 .. xn)) = f name x1 x2 .. xn ; (nuncurry (ncurry f AnonTuple x1 x2 .. xn)) = f AnonTuple x1 x2 .. xn ;
04:15:05 <waern_> tibbe: it can be useful if you don't have any other index to go to, like hayoo or hoogle
04:16:48 <waern_> tibbe: but perhaps it should just be replaced with hoogle
04:16:50 <ski> maxote : where does the `x' go in `ncurry (nuncurry f x) = f' ?
04:17:51 <Vanadium> quicksilver: Do not worry, I could not get it to work anyway.
04:18:10 <maxote> err. there is an error
04:20:22 <maxote> ncurry (nuncurry f x) = f x ;   corrected
04:21:35 <EvilTerran> maxote, do you mean ncurry (nuncurry f) = f, perhaps?
04:21:45 <ski> `(nuncurry (ncurry f name x1 x2 .. xn)) = f name x1 x2 .. xn' looks ill-typed
04:22:09 <maxote> they're polymorphic
04:22:30 <maxote> f :: 'a -> 'b
04:22:42 <ski>      nuncurry (ncurry f name x1 x2 .. xn)
04:22:45 <maxote> 'b maybe either a value or a function again
04:22:47 <ski>   =  nuncurry (f (name x1 x2 .. xn))
04:22:48 <ski>  =?= f name x1 x2 .. xn
04:24:40 <maxote> remembering to the above definitions,  nuncurry f name(x1,x2,..,xn) = f name x1 x2 .. xn  ;  ncurry f name x1 x2 .. xn = f name(x1,x2,..,xn)  ;
04:25:23 <maxote> EvilTerran, i'm not sure because it's a complicated higher order composition
04:25:42 <ski> yes, i was using your `ncurry f name x1 x2 .. xn = f name(x1,x2,..,xn)' (fixing the obvious mistakes into `ncurry f name x1 x2 .. xn = f (name x1 x2 .. xn)')
04:26:18 <ski> > curry (uncurry (+)) 1 2
04:26:19 <lambdabot>   3
04:26:46 <maxote> and remembering that  AnonTuple(x1,x2,..,xn) == (x1,x2,..,xn) returns true, they're equivalent.
04:27:50 <ski> does that mean that you believe `AnonTuple (AnonTuple (x1,x2,..,xn)) = (x1,x2,..,xn)' ?
04:28:56 <maxote> it returns false because left is anon 1-tuple with anon 1-tuple inside, and right is anon 1-tuple.
04:29:35 <maxote> AnonTuple (AnonTuple (x1,x2,..,xn)) = AnonTuple ((x1,x2,..,xn)) = ((x1,x2,..,xn)) != (x1,x2,..,xn) q.e.d.
04:29:59 * ski wonders whether there is a variant of doxastic logic in which `Gamma |-_x A' implies `Gamma |-_x []_x A'
04:30:04 <maxote> unless that the language spec. says the contrario.
04:30:39 <ski> (where `Gamma |-_x A' means that `x' believes that `A' follows from `Gamma')
04:31:10 <maxote>   err /1-tuple inside/n-tuple inside/
04:31:32 <maxote>  /right is anon 1-tuple/right is anon n-tuple/
04:31:38 <opqdonut> ski: and []_x means?
04:31:50 <opqdonut> (can't remember all these modal logics)
04:32:16 <ski> `[]_x A' is the object formula with the intended interpretation that the agent `x' believes the formula `A'
04:33:16 <ski> hm
04:33:42 <ski> well, maybe we have that rule, if we remove `Gamma'
04:34:04 <jperret> @type map
04:34:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:34:17 <ski> (since istr that's one of the most basic rules which most(?) modal logics have)
04:34:35 <opqdonut> ski: yes
04:35:00 <jperret> @pl \f g -> (\a b d) -> f (g a b) d
04:35:00 <lambdabot> (line 1, column 16):
04:35:00 <lambdabot> unexpected ")"
04:35:00 <lambdabot> expecting pattern or "->"
04:35:19 <jperret> @pl \f g -> (\a b d -> f (g a b) d)
04:35:20 <lambdabot> (.) . (.)
04:35:32 <ski> (to be clearer, i wanted to express the internal truth of "if it is true(in my belief), then i believe it is true(in my belief)")
04:35:45 <jperret> aah i see :)
04:36:37 <ski> (so that each agent may reflect his/her "truths" (actually beliefs) into "beliefs" (belief in self-belief))
04:36:59 <jperret> @pl \x -> (-) . (x/)
04:37:00 <lambdabot> ((-) .) . (/)
04:37:07 <ski> @type curry
04:37:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:37:10 <ski> @type uncurry
04:37:10 <uncommons> Hi.  HLint has the option to suggest the replacement of a $ b $ c with a . b $ c  - It's not enabled by default, but the manual says it's popular here.  It's not obvious to me why the second form is "better".  Can anyone expand on the pros/cons?
04:37:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:37:51 <jperret> @pl a $ b $ c
04:37:52 <lambdabot> a (b c)
04:38:15 <ski>   ncurry :: (b -> c) -> (a0 -> ... -> b) -> (a0 -> ... -> c)
04:38:36 <jperret> uncommons: I would hazard that a. b $ is closer to pointfree ?
04:38:47 <ski>   \f -> ncurry f (,...) :: ((a0,...) -> c) -> (a0 -> ... -> c)
04:39:11 <ski>   \f -> nuncurry f ? :: (a0 -> ... -> c) -> ((a0,...) -> c)
04:39:24 <jperret> @pl \c -> a $ b $ c
04:39:24 <quicksilver> uncommons: the composition operator (.) is associative. We liek associative operators.
04:39:24 <lambdabot> a . b
04:39:38 <quicksilver> uncommons: they give more valid subexpressions - more ways to compose code.
04:40:07 <quicksilver> uncommons: in (a . b . c . d . e $ x), (b.c) and (b.c.d) are both valid subexpressions.
04:40:21 <quicksilver> uncommons: ...which represent useful parts of the pipeline.
04:41:16 <quicksilver> uncommons: whereas, in (a $ b $ c $ d $ e $ x), (b $ c) is not a valid subexpression
04:41:22 <quicksilver> it's (almost certainly) not even type correct.
04:41:46 <uncommons> quicksilver: Thanks.  I think I can see what you're getting at.
04:41:53 <ray> composition is an important concept
04:41:57 <jperret> @pl \x y -> y . (`f`x)
04:41:57 <lambdabot> flip (.) . flip f
04:42:34 <uncommons> Any downsides?
04:42:47 <maxote> uncurry/curry are like nuncurry/ncurry but erased the word `name' in the code
04:43:05 <EvilTerran> uncommons, only that (.) is higher precedence than $, so you may occasionally need more parentheses
04:43:12 <quicksilver> uncommons: you have to use $ when you have a form like "withFoo $ \f -> withBar $ \b -> blah"
04:43:34 <quicksilver> which is a not-unheard-of idiom.
04:44:32 <ray> consider thatn you can define something like processingFunction = a . b . c . d . e
04:44:34 <ski> @type let nuncurry :: as_c -> (b -> as_c -> c) -> (b -> c); nuncurry as_c b_as_c_c b = b_as_c_c b as_c in \f -> nuncurry f (\(a,b) k -> k a b)
04:44:35 <lambdabot> forall t t1 c. (t -> t1 -> c) -> (t, t1) -> c
04:44:37 <ski> @type \k (a,b) -> k a b
04:44:38 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
04:44:43 <ski> mhm
04:44:43 <ray> because as he already said, it's a valid expression
04:45:35 <maxote> uncurry f (x1,x2,..,xn) = f x1 x2 .. xn  ;  curry f x1 x2 .. xn = f (x1,x2,..,xn)  ;  curry (uncurry f x) = f x  ;  uncurry (curry f x1 x2 .. xn) = f x1 x2 .. xn  ;
04:45:56 <EvilTerran> > uncurry (+) $ (+1) &&& (*2) $ x -- works
04:45:57 <lambdabot>   x + 1 + x * 2
04:46:07 <EvilTerran> > uncurry (+) . (+1) &&& (*2) $ x -- needs more parentheses
04:46:08 <lambdabot>   Couldn't match expected type `(a, a)'
04:46:15 <EvilTerran> > uncurry (+) . ((+1) &&& (*2)) $ x -- like so
04:46:17 <lambdabot>   x + 1 + x * 2
04:46:24 <jperret> @src &&&
04:46:25 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
04:46:40 <ray> uncommons: also if cale takes over the world, $ will become infixl and a $ b $ c $ x will become equivalent to ((a b) c) x
04:46:44 <EvilTerran> jperret, in this context, (f &&& g) x = (f x, g x)
04:46:49 <ski> ray :)
04:47:00 <jperret> EvilTerran, thanks, the source did hurt a bit
04:47:10 <ray> hedge against a cale takeover today!
04:47:14 <EvilTerran> the source is generalised to Arrows
04:47:34 <uncommons> OK, thanks everyone.
04:47:40 <maxote> note: f in uncurry/curry is not the same to f in nuncurry/ncurry because nuncurry/ncurry's f takes 1st the name of the tuple, and later, the 2nd field and successive is the 1st field and successive of tuple of uncurry/curry's f.
04:47:51 <EvilTerran> (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> c) -> (a ~> (b,c))
04:48:06 <jperret> EvilTerran: ok
04:48:24 <hackagebot> BirdPP 1.0 - A preprocessor for Bird-style Literate Haskell comments with Haddock markup. (SeanMcLaughlin)
04:48:27 <ray> Arrows are like functions as a typeclass
04:48:34 <jperret> @type (&&&)
04:48:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:48:38 <EvilTerran> i find you can get a pretty good intuition for how the Arrow functions work by primarily thinking about just the "instance Arrow (->)"
04:48:43 <ray> yes
04:48:53 <ray> if you pretend arrows are just functions, they're easy to understand
04:48:59 <ray> and you can think about kleisli arrows etc later
04:49:13 <EvilTerran> (in which they all have one natural definition)
04:50:01 <ski> EvilTerran : it would be nice if the precedence of `.' was weaker than the one of `&&&' (and similar operators)
04:50:38 <jperret> @pl (x + x)
04:50:39 <lambdabot> x + x
04:50:47 <ski> @pl \x -> x + x
04:50:48 <lambdabot> join (+)
04:50:50 <opqdonut> @pl \x -> x + x
04:50:50 <lambdabot> join (+)
04:50:51 <opqdonut> gah
04:50:59 <opqdonut> also:
04:51:01 <jperret> ah ok :)
04:51:01 <ski> :-P
04:51:08 <opqdonut> @pl \(+) -> x + x
04:51:08 <lambdabot> (line 1, column 3):
04:51:09 <lambdabot> unexpected "+"
04:51:09 <lambdabot> expecting pattern
04:51:14 <opqdonut> pah!
04:51:21 <maxote> for better comprension, it's as in pascal, uncurry/curry is for records, and nuncurry/ncurry is for records with unions that some point of the code "checks the condition variant of the union's record". This check is realized in 1st parameter (name of tuple) passed to nuncurry/ncurry's f.
04:51:26 <jperret> @pl \f -> f x x
04:51:27 <lambdabot> flip ($ x) x
04:51:34 <ray> @pl \o -> x `o` x
04:51:35 <lambdabot> flip ($ x) x
04:51:37 <jperret> @pl \f x -> f x x
04:51:38 <lambdabot> join
04:52:07 <EvilTerran> ski, indeed
04:52:30 <maxote>  /union (in C)/case variant (in Pascal)/
04:53:01 * EvilTerran would write \x -> x+x as (*2)
04:53:16 <ray> haskell data types are tagged unions
04:53:16 <jperret> :)
04:54:16 <ski> maxote : could you give an example of calling `nuncurry' ?
04:58:23 <maxote> let isNothing x = if (x == Nothing) then (1 +) else (-1 +) in nuncurry isNothing Nothing 0   --> it should return -1
04:58:31 <maxote> err, return +1
04:59:44 <maxote> nuncurry isNothing Nothing 0 = (nuncurry isNothing Nothing) 0 = (isNothing Nothing) 0 = ((1 +)) 0 = 1
05:00:23 <arw> nuncurry. somehow that reminds me of http://whyfiles.org/164cannibal/images/pquote1.gif
05:00:26 <maxote> let isNothing x = if (x == Nothing) then (1 +) else (-1 +) in nuncurry isNothing Just(_) 0   --> it should return -1
05:00:58 <maxote> nuncurry isNothing Just(_) 0 = (nuncurry isNothing Just(_)) 0 = (isNothing Just(_)) 0 = ((-1 +)) 0 = -1
05:01:21 <maxote> err
05:01:32 <mreh_> anyone know a graphics library that can render Real number co-ordinates with alpha blending?
05:01:43 <maxote> nuncurry isNothing Just(_) 0 = (nuncurry isNothing Just(_)) 0 = (isNothing Just   (_)) 0 = ((-1 +)) 0 = -1  ; corrected
05:02:04 <EvilTerran> arw, mmm, nun curry.
05:02:04 <ski> > let nuncurry t m x = t m x in let isNothing x = if (x == Nothing) then (1 +) else (-1 +) in nuncurry isNothing (Just 42) 0
05:02:06 <lambdabot>   -1
05:02:12 <ski> happy ?
05:02:52 <maxote> > let nuncurry t m x = t m x in let isNothing x = if (x == Nothing) then (1 +) else (-1 +) in nuncurry isNothing (Nothing) 0
05:02:54 <lambdabot>   1
05:03:12 <ski> if you wish, you can define `nuncurry = id'
05:04:51 <Vanadium> I am having trouble parsing 'instance context1 => C Int a     where ...' from http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
05:05:08 <Vanadium> It vaguely looks as if we are making "Int a" an instance of C but that does not appear to make too much sense
05:05:33 <EvilTerran> Vanadium, C has two parameters
05:05:45 <maxote> n(un)curry is very useful for (un)currying with named tuples of complex data that otherwise is impossible using conventional (un)curry.
05:06:15 <Vanadium> EvilTerran: Oh. Huh. Okay.
05:06:26 <ski> @type maybe
05:06:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:06:28 <ski> @type either
05:06:30 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:06:40 <ski> maxote : have you seen those functions yet ?
05:07:10 <ski>   list :: b -> (a -> [a] -> b) -> [a] -> b  -- a similar function, for lists
05:07:20 <EvilTerran> Vanadium, if C had one parameter, and we were trying to make "Int a" that parameter, that'd look like "instance context1 => C (Int a) where ..."
05:07:55 <ski> > maybe 1 (-1 +) Nothing
05:07:56 <lambdabot>   1
05:08:07 <Vanadium> I did not realise type classes could have more than one parameter.
05:08:07 <ski> > maybe 1 (-1 +) (Just 0)
05:08:07 <lambdabot>   -1
05:08:36 <Vanadium> I mean, I utterly misunderstood the point of the multiparametertypeclasses extension.
05:08:45 <ski> Vanadium : the point is the same if you everywhere replace `C x y' with `C (x,y)', for any `x' and `y'
05:09:36 <EvilTerran> ski, well, except you can't write "class C (x,y) where ..."
05:10:18 <ski> sorry, yes. i should have said "everywhere in instances and constraints" instead of "everywhere"
05:11:23 <maxote> ski, not yet, i will go to lunch, i will see later them, i'm sorry.
05:11:23 <ski> (and probably there's some potential interaction with FDs i'm ignoring)
05:11:29 <ski> np
05:11:53 <MrSaints> Ugh I need help.
05:12:03 <Vanadium> I suspect I am more confused about the type system than I am aware of.
05:12:32 <MrSaints> http://maplev74.frozonenetworks.com/ is that site accessible?
05:12:59 <MrSaints> Nevermind fixed it.
05:13:01 <Plouj> bah, idiot me for clicking on that
05:13:08 <ski> MrSaints : i see no code snippet there. are you sure you're not a troll ?
05:13:17 <Plouj> ski: it was some snuff site
05:13:33 * ski pats w3m
05:13:56 <ray> look at you, you've now said more lines about that link than he used to post it
05:14:09 * ski bows head in shame
05:16:16 <ray> why doesn't reddit have a way to, like, spend all your karma for a hundred downvotes on one thing
05:16:23 <ray> a wave motion downvote if you will
05:16:33 <Plouj> haha
05:16:45 <Plouj> that'd be nice, I agree
05:17:22 <Gracenotes> hubba hubba :x
05:20:34 <mreh> :t (,)
05:20:36 <lambdabot> forall a b. a -> b -> (a, b)
05:25:46 --- mode: irc.freenode.net set +o ChanServ
05:28:55 <EvilTerran> boing... boing...
05:29:08 <leopard> ouch.
05:31:19 <Plouj> since when is Perl a functional programming language?
05:31:39 <Itkovian> Any idea why the amd64 tarball for freebsd refuses to configure? It says "Unrecognised platform: amd64-unknown-freebsd7.2". Seems like that should be okay, no?
05:31:40 <Phyx-> morning
05:31:44 <EvilTerran> it's got closures, so in that regard, it's functional
05:32:24 <EvilTerran> it's not a pure functional language, in that it has unconstrained side-effects, but the same is true of clisp, *ml, etc
05:32:41 <Philippa> yeah, but for example, does the library support a functional style well?
05:32:48 <Philippa> *ML's generally does
05:32:52 <Vanadium> there is map and filter and stuff
05:33:07 <EvilTerran> i've no doubt there's extensive support for the functional style on CPAN
05:33:11 <Vanadium> Also if you take "the library" to be CPAN, there sure is plenty of-- yeah
05:33:44 <EvilTerran> the main downside i can see of using perl5 as a functional language is the slightly broken parameter handling mechanism
05:34:06 <EvilTerran> having to faff around with @_ or shift
05:35:23 <Vanadium> Having a my ($a, $b, $c, ...) = @_ line approximates parameters closely enough, I think, and you can always do the thing where you declare fancy prototypes. :/
05:41:13 <Rdtsc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8341#a8341  can anybody help me with compiling this thing?
05:42:15 <Rdtsc> It compiles well without -optl-static
05:43:02 <mreh> what's the accepted way to distribute files over this channel?
05:43:12 <mreh> source files
05:43:14 <gwern> as tarballs on hackage...
05:43:26 <mreh> can I upload my own games on there?
05:43:39 <gwern> why not? I stole and uploaded other people's games
05:43:45 <gwern> I should think you could upload your own
05:43:51 <mreh> you'll be getting another asteroids clone :D
05:44:34 <Phyx-> gwern: LOL
05:44:44 <roconnor> ski: Dana says the sum is not a coproduct, and the category has no coproducts
05:44:51 <gwern> 4 or 5 asteroids clones, and hardly any tetris. it's kind of sad
05:45:02 <roconnor> but the sum still has many nice properties
05:45:08 <Phyx-> what.. no pong?
05:45:15 <roconnor> @seen ski
05:45:16 <lambdabot> ski is in #haskell, #haskell.se, ##logic and #haskell.hr. I don't know when ski last spoke.
05:45:37 <ski>  
05:45:49 <Phyx-> -.-
05:46:01 <ski> roconnor : i suspected that
05:48:11 <ski> roconnor : which properties ?
05:48:30 <ski> commutative. not associative
05:48:43 <ski> one-way distribution ?
05:49:15 <roconnor> bi-functorality
05:49:29 <roconnor> well functorial in both arguments
05:49:30 <ski> heh, i took that for granted :)
05:49:33 <roconnor> :)
05:50:11 <roconnor> ski: I have slides if you want
05:50:19 <roconnor> not sure how well they work without the talk
05:50:25 <ski> i can look
05:50:52 <roconnor> ski: shall I ddc or dcc or whatever them to you?
05:51:32 <ski> if you have a global link to them, that would be simplest
05:51:51 <roconnor> I don't, but maybe I can make one
05:51:54 <ski> (i don't know what `ddc' is. dcc would only work if you have the appropriate ports open, iirc)
05:57:35 <roconnor> ski: http://r6.ca/temp/ScottCCA09.pdf
05:57:55 <roconnor> ski:  let me know when you have it
06:03:15 <ski> roconnor : got it
06:03:43 <ski> (for some reason the first viewer i tried didn't want to start up)
06:03:48 <roconnor> ah
06:03:57 <roconnor> Dana said to use Adobe for some reason
06:04:03 <roconnor> some font issue apparently
06:04:17 <ski> hrm
06:05:29 <roconnor> kpdf appears to work fine for me
06:05:56 <ski> (it appears some symbols are missing from page five, using gpdf)
06:05:59 * ski tried kpdf
06:06:19 <roconnor> hmm
06:06:32 <roconnor> kpdf says Error: Unknown character collection 'Adobe-Japan1'
06:06:47 <ski> s/tried/tries/
06:07:43 <roconnor> I don't see anything missing though
06:07:59 <ski> (*sigh* same things appear to be missing with kpdf)
06:08:14 <roconnor> what are you missing
06:08:34 <roconnor> le meet and join symbols?
06:08:43 * lilac is imagining Dana is an AI implemented by luqui
06:08:48 <roconnor> maybe implication symbols
06:08:55 <ski> on page 5, all except the heading, the red named by the side, and the `0',`1',`=<' symbols
06:09:06 <roconnor> :(
06:09:27 <roconnor> ski: I wonder if it is really a system font issue.
06:09:38 <roconnor> Dana needs to use more embedded fonts
06:09:43 <roconnor> I wonder if I can do that.
06:09:51 <ski> Error: Unknown character collection 'Adobe-Japan1'
06:09:57 <roconnor> I have that too
06:10:05 <roconnor> but I see the slide (almost?) fine
06:10:06 <ski> Error: Unknown font tag 'F9.1'
06:10:06 <ski> Error (8468): No font in show
06:10:14 <roconnor> I don't have those errors
06:10:20 <ski> got a few hundreds of lines like that
06:10:30 <roconnor> I only got 3 Japan errors
06:10:54 <ski> (maybe only a dozen of the `Adobe-Japan1' ones)
06:12:05 <roconnor> pdftk's documentation doesn't seem to indicate a way to embed fonts
06:12:27 <roconnor> ski: what distribution are you running?
06:12:48 <ski> Debian GNU/Linux
06:16:00 <skorpan> is there any haskell library for "dealing with" wireless connections?
06:16:14 <skorpan> i.e. scanning for them, connecting to them, encryption, etc
06:16:24 <roconnor> ski: strange, kpdf claims all the fonts are embedded
06:16:24 <skorpan> (i guess not, but why not)
06:16:45 <roconnor> skorpan: not enough haskell developers?
06:16:50 <fbru02> hey guys is going to the IFL any good for beginner haskell programmers ?
06:16:54 <fasta> skorpan: what is a good C library for that?
06:16:59 <skorpan> fasta: i have no idea
06:17:23 <skorpan> i was thinking of writing a little program which lets the user set up rules to connect to different networks depending on different circumstances.  kind of like wicd, but not buggy.
06:17:25 <roconnor> I just installed wicd for my wireless
06:17:39 <roconnor> this is the first time I've actually used a decent wireless program in linux at all.
06:17:54 <skorpan> roconnor: wicd is nice, but it too often bugs out on me and refuses to connect
06:17:58 <roconnor> ah
06:18:02 * Phyx- could never get WPA to work in linux...
06:18:04 <roconnor> rewrite it in haskell!
06:18:07 <skorpan> this happens almost every time i resume from suspend
06:18:27 <roconnor> Phyx-: using wicd is the first time I've successfully got WPA working
06:18:39 <skorpan> i was thinking of doing something much simpler than wicd as well, not having a daemon at all
06:19:03 <roconnor> skorpan: doesn't reconnecting after being dropped require a daemon?
06:19:08 <skorpan> i'm not too familiar with wireless network and dhcp and stuff like that, so maybe i shouldn't even try... it would be nice to have something i can understand though.
06:19:15 <skorpan> roconnor: yes, that's the problem
06:19:17 <skorpan> :)
06:19:38 <gwern> Phyx-: there's probably a pong somewhere in the many FRP packages
06:19:42 <skorpan> the wicd monitor is just 400 LOC
06:19:52 <gwern> it's like the simplest possible game; if FRP will work for anything, it should work for frp
06:19:53 <roconnor> you want to do something requiring a daemon without a daemon?
06:20:03 <roconnor> oh
06:20:14 <roconnor> reusing the existing daemon?
06:20:36 <Phyx-> roconnor: last time i tried, i had to load some kernel modules etc, for the intel chipsets, finally got it detecting and searching, but it would never connect
06:20:40 <skorpan> roconnor: no actually i was thinking about doing exactly that.. a daemon without a daemon. after some thought, i realise now that this is probably not feasible. :)
06:20:49 <Phyx-> gwern: ah, i'll go look, pong is a great time waster
06:20:58 <roconnor> skorpan: what were you thinking?
06:20:59 <skorpan> Phyx-: wicd worked out of the box for me (3945)
06:21:08 <skorpan> roconnor: to be honest, i don't know
06:21:22 <skorpan> i just want wireless to be easy
06:21:37 * Phyx- will try that next time i'm on linux
06:21:41 <Twey> Wireless is never easy
06:21:45 <Twey> :(
06:21:50 <skorpan> wicd doesn't seem to have stuff like "if X is available with >75% signal strength, connect to that, but if Y exists, X must have >80% to be connected to"
06:21:56 <Phyx-> Twey: it's 1 click here :P
06:21:58 <Philippa> fbru02: IFL's not really that kind of event. It's got its own value, and there's usually some cool stuff to follow
06:22:14 <skorpan> i find that with windows *wireless* and *sound* are always easy
06:22:18 <skorpan> with linux always hard
06:22:28 <Twey> Phyx-: Sure, sure, but how do you debug it when, to take a random example, your laptop randomly disconnects every hour or so?
06:22:29 <Philippa> but it sorta depends on what you're looking for, and you might not find it worth the money, depending
06:22:44 <ski> What is a Lattice? : `0 =< x =< 1' Bounded' ; `x =< x',`x =< y /\ y =< z => x =< z',`x =< y /\ y =< x => x = y' Partially Ordered Set ; `x0 \-/ x1 =< y <=> x0 =< y /\ x1 =< y ',`x =< y0 /-\ y1 <=> x =< y0 /\ x =< y1' With sups & With infs
06:22:45 <therp> skorpan: sorry linux got infected with alsa :(
06:22:48 <Twey> There are just too many variables
06:22:53 <fasta> Twey: which chip do you have?
06:22:59 <Twey> OSS4 is making a comeback, though :)
06:23:05 <Twey> fasta: Mm *checks*
06:23:11 <osfameron> skorpan: wireless seems almost functional these days - my linux bugbears are sound and power management :-(
06:23:12 <ski> What is a Semilattice? : `0 =< x =< 1' Bounded' ; `x =< x',`x =< y /\ y =< z => x =< z',`x =< y /\ y =< x => x = y' Partially Ordered Set ; `x0 \-/ x1 =< y <=> x0 =< y /\ x1 =< y ' With sups
06:23:26 <Phyx-> Twey: livekd, or so i assume i should be able to theoretically
06:23:46 <fbru02> Phillipa : thanks , i will be near NJ that time and i wonder (being from Uruguay and not having this kind of opportunities) if i should assist ... but i dont know , i really like the application part , but the implementation of compilers etc , doesnt interest me that much
06:24:09 <skorpan> i think i'd need to understand dbus to get this shit working, so maybe i should just deal with wicd
06:24:40 * ski tries to guess what the `I' stands for in the `Complete Semilattice' ..
06:25:11 <roconnor> ski: any index set
06:25:24 <Twey> fasta: It's an Intel 3945ABG, using iwlwifi
06:26:03 <skorpan> Twey: why are you using iwlwifi?
06:26:17 <Twey> As opposed to what?
06:26:19 <skorpan> oh, i am too... :|
06:26:20 <ski> (i only see `I' and `=<' in those formulae, but i think i can guess what the rest is .. with a little thought)
06:26:22 <skorpan> i thought i was using something else
06:26:28 <Phyx-> lool
06:26:32 <Twey> I was ipw3945 until it got deprecated for iwlwifi.
06:26:35 <roconnor> ski: this is an awful way to read the slides
06:26:43 <fasta> Twey: ok, then I don't know. I just bought a laptop which contained a chip that was "the best".
06:26:51 <Twey> Heh
06:27:00 <fasta> Twey: Atheros - based
06:27:28 <Twey> Yeah, I've got a madwifi-based chip on this desktop, and it works great
06:27:45 <ski> What is a Complete Semilattice?(typo) : `(Inf i : I. x_i) =< y <=> forall i : I. x_i =< y'  -- ?
06:27:49 <Twey> But there are just too many variables involved in wifi for it ever to be simple
06:27:56 <gwern> did anyone here call for some... NETWORK-ENABLED SVG IMAGES???!!!! http://www.w3.org/TR/2004/WD-SVG12-20040510/#network-data
06:28:06 <Twey> gwern: Bahaha
06:28:22 <profmakx> "
06:28:30 <Twey> Oh dear oh dear
06:28:31 <gwern> because there's nothing I want to do more in my vector graphs than download some youtube videos in it!
06:28:58 <Twey> I suppose this is the next stage in the supplant Flash scheme
06:29:13 <ski> (also, iirc, "A complete semilattice *is* a complete lattice" only holds for objects, not morphisms)
06:29:15 <fasta> Twey: then there is also the law, of course, which makes it even more complicated.
06:29:17 <Twey> But they're kind of making all the same mistakes Flash did
06:29:20 <gwern> I like the security remarks in it especially
06:29:22 <Twey> fasta: Haha, aye.
06:29:34 <lilac> gwern: "Note that these interfaces expose possible security concerns"
06:29:40 <roconnor> ski: what would it mean to hold for morphisms?
06:29:55 <lilac> gwern: that seems like an understatement
06:29:56 <ski> that the two categories were equivalent
06:29:56 <gwern> lilac: future versions will instruct useragents how best to restrict this functionality
06:30:01 <roconnor> you mean the morphisms of a SL might not preserve infs?
06:30:04 <fasta> Twey: I am not joking.
06:30:25 <Twey> fasta: Yet it is something of a joke, nevertheless
06:30:50 <roconnor> ski: wait, since inf is defined as a sup, and SL's preserve sups, shouldn't it also preserve infs?
06:30:54 <ski> roconnor : iirc, morphisms of complete (sup-)semi-lattices need not preserve infimums, yes
06:31:12 <ski> i may be recalling wrong. this is just what my dim memory tells me
06:31:17 <lilac> so people will be able to make SVG progress bars which beautifully display the percentage of my personal information they've uploaded to an evil server?
06:31:37 <roconnor> it looks to me like it ought to preserve infs.
06:31:40 * ski fetches "Topology Via Logic"
06:38:26 <Philippa> fbru02: the implementation stuff often has some nice make-you-think bits and pieces in there, and it sure gives you a better feel for How Stuff Works. Being in town anyway helps, of course
06:38:43 <ski> roconnor : *nod*, now i see what i was confusing it with
06:39:13 <fbru02> Philippa: thanks i will think about it , i think i will learn something so i might go
06:40:03 <ski> (in Vickers's terminology) "A frame is a complete Heyting algebra, but a frame homomorphism need not be a cHa homomorphism" (slightly reworded)
06:40:46 <ski> roconnor : so you're probably right
06:41:33 <Philippa> fbru02: I guess the deciding factor is how much it actually costs you? I felt a bit awkward about last year's because the opportunity cost was pretty big for me. To be fair, that was as much because some major disruptive stuff hit me shortly afterwards. OTOH, I generally find multi-day events tough going
06:41:49 <absentia> morn'
06:44:01 <fbru02> Philippa: i guess until the schedule gets released and see if i really like the talks , i wish also that they made those events shorter/less expenesive but well
06:45:25 <roconnor> @djinn (((a -> r) -> a) -> r) -> (a -> r) -> a
06:45:26 <lambdabot> -- f cannot be realized.
06:46:22 <roconnor> aww
06:46:36 <roconnor> oh oops
06:46:38 <roconnor> wrong function type
06:46:57 <roconnor> @djinn ((((a -> r) -> a) -> r) -> (a -> r) -> a) -> (a -> r) -> a
06:46:58 <lambdabot> f a b = a (\ c -> b (c b)) b
06:47:28 <roconnor> @seen edwardk
06:47:29 <lambdabot> I saw edwardk leaving #haskell 4h 55m 43s ago, and .
06:48:21 <ski> @djinn ((a -> o) -> ((q -> q) -> p)) -> ((a -> o) -> p)
06:48:22 <lambdabot> f a b = a b (\ c -> c)
06:48:37 <ski> @djinn ((a -> ((o -> r) -> r)) -> ((q -> q) -> p)) -> ((a -> o) -> p)
06:48:38 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
06:49:22 <roconnor> @type \a b -> a (\ c -> b (c b)) b
06:49:25 <lambdabot> forall t t1 t2. ((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2
06:50:41 <Philippa> fbru02: international events tend to be multi-day because most people're paying travel costs too and a single day wouldn't be worth it
06:50:42 <Vq> useful functions?
06:51:04 <roconnor> Vq: the join operation for the J monad
06:51:20 <Vq> J?
06:51:21 <roconnor> newtype J r a = (a -> r) -> a
06:53:19 <jozilla> Hi everyone! Can anyone please tell me how the standard solution for Problem 19 in 99 Haskell problems works? http://www.haskell.org/haskellwiki/99_questions/11_to_20#Problem_19
06:53:26 <EvilTerran> ?src Cont
06:53:31 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
06:53:38 <EvilTerran> roconnor, hm... it's not quite Cont; what is it?
06:54:01 <ski> , [$ty|\a -> MkContT2 (\b -> a (MkContT2 (\c -> b (c b))) `unContT2` b)|]
06:54:03 <lunabot>  forall a b b c . (ContT2 b b c (c b -> c b) ->
06:54:03 <lunabot>                    ContT2 b a c (c b)) ->
06:54:03 <lunabot>                   ContT2 b a c (c b)
06:54:10 <jozilla> I don't understand why the third pattern only applies to positive numbers, and why negative numbers fall through to the fourth and final pattern? http://www.haskell.org/haskellwiki/99_questions/11_to_20#Problem_19
06:54:16 <ski> roconnor : is that roughly what you had in mind ?
06:54:22 <hackagebot> HSH 2.0.3 - Library to mix shell scripting with Haskell programs (JohnGoerzen)
06:55:00 <ski> hm
06:55:13 <EvilTerran> jozilla, because that's how (n+k) patterns work. it's not very clear, really; (n+k) patterns aren't universally liked.
06:55:21 <ski> (.. right)
06:55:30 <roconnor> EvilTerran: I don't know what it is
06:55:47 <EvilTerran> jozilla, "Matching an n+k pattern (where n is a variable and k is a positive integer literal) against a value v succeeds if x >= k, resulting in the binding of n to x - k, and fails otherwise. Again, the functions >= and - are overloaded, depending on the type of the pattern. The match diverges if the comparison diverges."
06:55:51 <roconnor> ski: I didn' follow you.
06:56:01 <Phyx-> An almost-consistent 5 percent of respondents each year argued that the Internet had worsened their job performance "a lot" or "somewhat."
06:56:04 <ski> (i'm not sure why that has `c b' in the monadic results, though ..)
06:56:18 <jozilla> EvilTerran: thanks! That seems complicated :) I find it really strange that (n+1) means that n > 0
06:56:39 <mmorrow> ski: lunabot tries to rename the ids it gets back from ghc, but doesn't use any heuristics
06:56:45 <Vq> jozilla: thats why we should never use it
06:56:47 <ski> > let f (x+0) = x in f 4
06:56:49 <lambdabot>   4
06:56:50 <mmorrow> ski: this is what it has to work with:
06:57:07 <mmorrow> , [$ty|
06:57:08 <lunabot>  luna: lexical error in string/character literal at end of input
06:57:08 <EvilTerran> jozilla, incidentally, i'm quoting #8 on http://haskell.org/onlinereport/exps.html#sect3.17.2 there
06:57:23 <ski> mmorrow : unless it does inconsistent renaming, that should be no problem, here
06:57:55 <jozilla> EvilTerran: Thanks for the reference! My solution used guards, which seemed a lot more clear to me
06:58:01 <ski> (mmorrow : i was wondering why i got `c b' instead of a plain type-variable in the result)
06:58:11 <mmorrow> ski: oh, also there's some weird bug in asking the ghc-api for the type with this one function that i'm using, and i have no idea what's happening
06:58:22 <jozilla> Vq: Isn't it strange that it's still mentioned as a standard solution on the Haskell Wiki then?
06:58:25 <ray> evilterran: it would be more accurate to say that n+k patterns aren't universally disliked
06:58:29 <mmorrow> ski: i'm 90% it's not me messing it up, but it could be
06:58:42 <mmorrow> , [$ty| either Right Left |]
06:58:45 <lunabot>  forall a a . Either a a -> Either a a
06:58:47 <mmorrow> ^^^
06:58:47 <ray> "aren't universally liked" implies that a minority dislikes them
06:58:49 <EvilTerran> jozilla, yeah, guarding is probably clearer. i think the idea is that (n+k) patterns are meant to be used for functions expecting natural number parameters
06:59:00 <ski> mmorrow : i see
06:59:05 <EvilTerran> f 0 = ...; f (n+1) = ... -- kinda thing
06:59:11 <mmorrow> , typ "either Right Left"
06:59:14 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
06:59:19 <Vq> jozilla: i would call it strange
06:59:27 <ski> ray : no, it only implies that there is someone that dislikes them
06:59:48 <EvilTerran> jozilla, and, in those cases, the pattern-match error that would result from calling "f (-1)" is what you want
07:00:07 <EvilTerran> but using them for functions where the parameter isn't expected to always be positive strikes me as obfuscation
07:00:14 * ski infers the type of it by hand, instead ..
07:00:18 <mmorrow> , typ "(\\a b c -> c (flip b a)) 9 (\\f -> flip f)"
07:00:21 <lunabot>  "forall b t_aa1D a c.\n(GHC.Num.Num b) =>\n(((a -> b -> c) -> a -> c) -> ...
07:00:25 <ski> (or rather, translates it)
07:00:35 <jozilla> EvilTerran: Oh OK I see. Indeed, that might be a better use case for (n+k) patterns. Otherwise, you're obfuscating your code indeed :)
07:00:40 * Vq would prefer the cycle version but with 'zipWith const'
07:00:44 <mmorrow> , typ "flip . flip"
07:00:46 <lunabot>  "forall a b c. (b -> a -> c) -> b -> a -> c"
07:00:59 <mmorrow> gah, i can't remember how to trigger the cray ids
07:00:59 <ski> @type \a b -> a (\ c -> b (c b)) b
07:01:03 <lambdabot> forall t t1 t2. ((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2
07:01:08 <jozilla> All right, EvilTerran and Vq you really helped me a lot! Thanks for your quick responses!
07:01:24 <mmorrow> , text (typ "\a b -> a (\ c -> b (c b)) b")
07:01:25 <lunabot>  luna: lexical error in string/character literal at character ' '
07:01:31 <EvilTerran> no worries, it's much more interesting than what i'm meant to be doing :P
07:01:34 <mmorrow> , text (typ "\\a b -> a (\\ c -> b (c b)) b")
07:01:36 <lunabot>  forall t_aa3m t_aa3n t_aa3o.
07:01:36 <lunabot>  ((((t_aa3m -> t_aa3n) -> t_aa3m) -> t_aa3n)
07:01:36 <lunabot>   -> (t_aa3m -> t_aa3n)
07:01:49 <mmorrow> that's the un-renamed version :)
07:02:11 <jozilla> EvilTerran: hehe, ok :-) Good luck with your other work, and thanks again!
07:02:35 * jozilla is waving goodbye!
07:02:36 <EvilTerran> , [$ty| \a b -> a (\ c -> b (c b)) b |]
07:02:38 <lunabot>  forall a b c . ((((c -> b) -> c) -> b) -> (c -> b) -> a) ->
07:02:38 <lunabot>                 (c -> b) -> a
07:02:54 <ski> roconnor : `(ContT2 o p m (o -> p) -> ContT2 p q m t) -> ContT2 p q m o'
07:03:11 <ski> (ignore the `m's if you like, they're only for the transformer variant)
07:03:25 <ski> er, s/t/o/
07:03:34 <ski>   (ContT2 o p m (o -> p) -> ContT2 p q m o) -> ContT2 p q m o
07:03:34 <mmorrow> , src ''ContT2
07:03:37 <lunabot>  newtype ContT2 o p m a = MkContT2 {unContT2 :: ((a -> m o) -> m p)}
07:03:56 <roconnor> I don't know what ContT2 is
07:04:03 <roconnor> oh
07:04:15 <mmorrow> roconnor: ski made it up
07:04:39 <ski> it's basically an indexed continuation monad transform
07:05:09 <roconnor> the ContT2 form doesn't really look much like a join
07:05:22 <ski> it's useful for some operations one want to do with `shift' and `reset', that `ContT' doesn't allow
07:05:27 <roconnor> J (J a) -> J a
07:05:48 * ski thought it was supposed to be a `shift' variant
07:06:14 <roconnor> oh wait
07:06:16 <roconnor> I'm confused
07:06:35 <roconnor> : `(ContT2 o p m (o -> p) -> ContT2 p q m t) -> ContT2 p q m o'
07:06:35 * EvilTerran briefly tries to work out in his head what join would do in the Cont monad
07:06:39 * EvilTerran 's brain melts
07:06:42 <roconnor> what is this and what does it have to do with what I wrote?
07:07:19 <roconnor> @djinn ((((a -> r) -> r) -> r) -> r)
07:07:19 <lambdabot> -- f cannot be realized.
07:07:21 <ski> roconnor : i took your expression, inserted a few `MkContT2's and `unContT2's at strategic places, and got the type of that
07:07:26 <roconnor> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
07:07:26 <lambdabot> f a b = a (\ c -> c b)
07:07:53 <ski> (or rather, used isomorphisms to rewrite the type directly, but it amounts to the same thing)
07:08:38 <mreh> is there an if then else if then else pattern?
07:08:54 <lilac> mreh: i'd use guards for that sort of thing
07:08:58 <roconnor> ski: your type appears to be even more complex than my type.
07:09:05 <ski> @type \mma k -> ma (\ma -> ma k)
07:09:07 <lambdabot> Not in scope: `ma'
07:09:11 <ski> @type \mma k -> mma (\ma -> ma k)
07:09:13 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
07:09:30 <ski> @type \mma k -> mma (\ma -> ma (\a -> k a))
07:09:31 <lambdabot> forall t t1 t2 t3. ((((t -> t1) -> t2) -> t2) -> t3) -> (t -> t1) -> t3
07:10:10 <ski>   ContT2 p q m (ContT2 o p m a) -> ContT2 o q m a  -- that's `join'
07:10:14 <mreh> :t otherwise
07:10:15 <lambdabot> Bool
07:10:25 <mreh> > otherwise
07:10:27 <lambdabot>   True
07:10:34 <mmorrow> @src otherwise
07:10:34 <lambdabot> otherwise = True
07:10:39 <mreh> :D
07:11:02 <ski> roconnor : the type i gave is basically the same as your `((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2' (modulo the `m's, which you can ignore)
07:11:49 <ski> now, i'm not sure what your `newtype J r a = (a -> r) -> a' is meant for
07:11:50 <roconnor> ((((t -> t1) -> t2) -> t2) -> t3) -> (t -> t1) -> t3  =?= ((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2
07:11:58 <roconnor> those types don't look the same to me
07:12:18 <mreh> > let one = | 1 = "One" | otherwise = "not one" in one 1
07:12:20 <lambdabot>   <no location info>: parse error on input `|'
07:12:34 <mreh> uhhh
07:12:40 <roconnor> ski: (J r) is a monad
07:12:45 <mreh> not sure what i was trying to do then
07:13:03 <HugoDaniel> hi
07:13:14 <ski> roconnor : sorry, the `((((t -> t1) -> t2) -> t2) -> t3) -> (t -> t1) -> t3' was another thing (the `join' for `ContT2')
07:13:19 <mreh> i'm trying to use guards in a function with no args
07:13:30 <ski> @djinn ((((a -> r) -> a) -> r) -> (a -> r) -> a) -> (a -> r) -> a
07:13:30 <lambdabot> f a b = a (\ c -> b (c b)) b
07:13:31 <ski> @type \a b -> a (\ c -> b (c b)) b
07:13:33 <lambdabot> forall t t1 t2. ((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2
07:13:39 <roconnor> ski: your join doesn't look like my join
07:13:59 <ski> that type was basically the same as `(ContT2 o p m (o -> p) -> ContT2 p q m o) -> ContT2 p q m o'
07:14:14 <ski> roconnor : right .. i'm not convinced yet your `J' is even a monad
07:14:21 <mmorrow> , either undefined (ppDoc.(\(t',_,_)->t').renameT [] myNames) (parseType "((((t -> t1) -> t2) -> t2) -> t3) -> (t -> t1) -> t3")
07:14:22 <lunabot>  ((((a -> b) -> c) -> c) -> d) -> (a -> b) -> d
07:14:30 <lilac> > foo | 42 > 41 = "Consistent!" | otherwise = "The universe confuses and scares me" in foo --mreh
07:14:32 <lambdabot>   <no location info>: parse error on input `|'
07:14:48 <lilac> > let foo | 42 > 41 = "Consistent!" | otherwise = "The universe confuses and scares me" in foo
07:14:50 <lambdabot>   "Consistent!"
07:14:53 <mreh> lilac: cheers
07:15:29 <quicksilver> mreh: if it's got no args it is quite likely not a function :)
07:15:29 <fasta> Is there a show version command in ghci or something similar so that I can see which version of ghci is running inside Emacs?
07:15:37 <quicksilver> mreh: but that's OK, you can use guards anyway.
07:15:50 <roconnor> `ContT2 o p m (o -> p) -> ContT2 p q m o) -> ContT2 p q m o' = ((((o -> p) -> o) -> p) -> ((o -> p) -> q)) -> (o -> p) -> q)
07:15:50 <mreh> quicksilver you're telling me x = 3 is not a function?
07:15:53 <roconnor> okay
07:15:57 <roconnor> ski: I see this now
07:16:00 <quicksilver> if you scroll right to the top of the buffer there should be a version number fasta :)
07:16:12 <quicksilver> mreh: yes, I am.
07:16:22 <ski> (roconnor : to clarify, my `join' was not meant to be like your, i only mentioned it because you mentioned `((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r')
07:16:31 <quicksilver> mreh: x = 3 is a value. Or a constant. or an integer.
07:16:34 <fasta> quicksilver: I started this one in non-verbose mode ;)
07:16:34 <quicksilver> mreh: it's not a function.
07:16:40 <fasta> quicksilver: so, there isn't.
07:16:44 <roconnor> ski: that was for EvilTerran's benefit :)
07:17:42 <quicksilver> fasta: I dotn' think so, no. Seems a curious omission.
07:18:04 <quicksilver> mreh: a function is something of type (a -> b).
07:18:20 <quicksilver> mreh: (or, a function is a relation between two sets satisfying a certain criterion)
07:18:28 <ski> roconnor : so the two questions then are : (a) is `J r' even a monad ? ; (b) what did you want to do with `(((o -> p) -> o) -> p) -> ((o -> p) -> q)) -> (o -> p) -> q' ?
07:19:05 <roconnor> ski: Presumably the answer to (a) is yes
07:19:19 <ski>   instance Monad (J r)
07:19:22 <ski>     where
07:19:33 <ski>     return a = J (\ar -> a)  -- ?
07:19:34 <roconnor> (b) is just the most general type for join.  Join for the monad requires q = p
07:19:47 <ski> `join' for what ?
07:19:48 <roconnor> ski: yes
07:20:00 <roconnor> retrun a = J (const a)
07:20:02 <ski> for `J r' ?
07:21:31 <ski>      J r (J r a) -> J r a
07:21:32 <ski>   =  ((((a -> r) -> a) -> r) -> ((a -> r) -> a)) -> ((a -> r) -> a)
07:21:53 <roconnor> yes
07:21:57 <ski> hm, i see
07:22:18 <twanvl> don't forget fmap
07:22:19 <roconnor> @djinn (a -> b) -> ((a -> r) -> a) -> ((b -> r) -> b)
07:22:20 <lambdabot> f a b c = a (b (\ d -> c (a d)))
07:22:56 <ski> interesting
07:24:11 <ski> @djinn ((a -> r) -> a) -> (a -> ((b -> r) -> b)) -> ((b -> r) -> b)
07:24:12 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
07:24:22 <roconnor> bind
07:25:14 <ski> have you attempted the laws ?
07:25:34 <roconnor> ski: no
07:25:45 <roconnor> I was told it was a monad
07:25:55 <ski> ok
07:26:10 <roconnor> exercise for #haskell
07:26:11 <ski> (it reminds me of something ..)
07:26:37 <roconnor> I only presume the function generated by djinn is join
07:27:37 <ski> (it would be nice if one could ask for alternative solutions)
07:27:47 <roconnor> ya, the real version does that I think
07:33:52 <ski> the unit laws appear to hold
07:34:00 <jpcooper> if I create a new thread with forkIO in a function anywhere other than in "main", then if the function returns something, will the thread keep running?
07:35:48 <ski> (i don't see how it should matter whether the thread is created in `main' or not)
07:36:28 <jpcooper> I thought that there was an exception for main
07:37:01 <mmorrow> jpcooper: if you return from main, all forkIO'ed threads will die
07:37:05 <jpcooper> okay
07:37:15 <ski> possibly there was something different with the "main *thread*" (which is something different from the `main' action)
07:42:19 <Philonous1> How come "let f x = x*x in [derive 1 f, (derive 1 ( derive 1 f))] " type checks but "let f x = x*x; g = derive 1 f in [g, derive 1 g]" doesn't? Does let-binding a function make it less polymorphic?
07:42:54 <ski> probably DMR
07:43:37 <Philonous1> ski: Was that in response to my question?
07:43:39 <roconnor> I don't think it is the MR
07:43:53 <ski> try eta-expanding the definition of `g' (if it is a function), or add a type signature for `g' ?
07:44:38 <roconnor> in [g, derive 1 g]  we have that g is a differentiable function but derive 1 g is just a function.
07:44:40 <Philonous1> eta-expanding it works
07:44:54 <roconnor> basically g and derive 1 g have different types
07:45:02 <roconnor> @type (derive 1)
07:45:04 <lambdabot> Not in scope: `derive'
07:45:27 <ski> then it was probably the DMR
07:45:34 <Philonous1> roconnor: If that is true, why does (derive 1 f, derive 1 (derive 1 f)] type check?
07:46:00 <ski> because the left `derive 1 f' and the inner right `derive 1 f' can be type-checked separatedly
07:46:12 <roconnor> hmm
07:46:14 <ski> (and given different, though structurally equal, types)
07:46:29 <roconnor> okay, it is a monomorphism restriction problem
07:46:35 <roconnor> my bad
07:46:55 <roconnor> ski is right, eta expand the definition of g.
07:47:11 <roconnor> or do nomonomorphismrestriction
07:47:17 <Philonous1> That's too bad because that means I can't use derive in concert with iterate :-(
07:47:45 <mmorrow> why not?
07:48:00 <Philonous1> @src iterate
07:48:00 <lambdabot> iterate f x =  x : iterate f (f x)
07:48:06 <roconnor> Philonous1: which AD package are you using?
07:48:10 <mmorrow> why not? :)
07:48:11 <Philonous1> My own
07:48:16 <ski> Philonous1> :t derive
07:48:26 <roconnor> Philonous1: you need to make an "infinite" deriviate type
07:48:35 <roconnor> which can be done by making a new recrusive type
07:48:53 <Philonous1> derive 1 :: (Fractional t) => (Diff t -> Diff t) -> t -> t
07:48:56 <roconnor> at the moment you presumably can only express that a function has a finite number of derivatives
07:49:05 <Philonous1> data Diff a = D a (IM.IntMap (Diff a)) deriving (Eq,Ord)
07:49:15 <roconnor> oh
07:49:18 <roconnor> IntMap?
07:49:37 <roconnor> why doesn't derive return a (Diff t -> Diff t) ?
07:49:40 <Philonous1> Yes, for multivariadic differntiation (soo jfoutz' post)
07:49:52 <ski> oh
07:49:53 <Philonous1> see*
07:50:13 <ski> Philonous1 : link ?
07:51:18 <Philonous1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8358#a8358
07:52:09 <mmorrow> Philonous1: cool
07:53:17 <NEEDMOAR> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8359#a8359 -> how can I get ride of the function getme?
07:54:24 <ski>   typeme (_ :: [a]) = "[" ++ typeme (undefined :: a) ++ "]"
07:54:33 <roconnor> Philonous1: why doesn't derive return a (Diff t -> Diff t) ?
07:54:54 <Philonous1> roconnor: Because it derives functions, not towers
07:54:55 <Deewiant> typeme x = "[" ++ typeme (undefined `asTypeOf` head x) ++ "]"
07:55:09 <Philonous1> roconnor: like in (derive 1 (\x -> x^^2))
07:55:16 <maxote> hi guys, i'm back :)
07:55:17 <Deewiant> (ski's needs -XScopedTypeVariables)
07:55:30 <ski> Deewiant : or just s/undefined `asTypeOf` head x/head x/ :)
07:55:50 <path[l]> hi Im just learning haskell, could someone tell me why this doesnt work -> swap = (snd,fst)
07:55:52 <ski> (assuming `typeme' is nice and doesn't look at its argument)
07:55:53 <Philonous1> roconnor: the first argument is the parameter that it derives
07:55:54 <Deewiant> Oh, right, typeme ignores the argument :-P
07:56:02 <NEEDMOAR> I've tried what ski said, using XPatternSignatures and it didn't work.
07:56:06 <roconnor> Philonous1: but your type suggests you have infinite deriviates
07:56:11 <maxote> i said <maxote> ... the 2nd field and successive is the 1st field and successive of tuple of uncurry/curry's f.   <-- correct me, /2nd field and successive/2nd parameter and successive/
07:56:13 <dmwit> path[l]: That works fine, it just doesn't do what you might want. =)
07:56:17 <dmwit> :t (snd, fst)
07:56:19 <lambdabot> forall a b a1 b1. ((a, b) -> b, (a1, b1) -> a1)
07:56:26 <ski> path[l] : `swap = snd &&& fst'
07:56:34 <ski> @type snd &&& fst
07:56:35 <lambdabot> forall a c. (a, c) -> (c, a)
07:56:37 <dmwit> path[l]: Try giving "swap" and argument, and see if you can work out how that's different.
07:56:43 <dmwit> s/and/an/
07:56:44 <path[l]> hmm
07:56:56 <path[l]> I got an error that I didnt understand
07:57:15 <Philonous1> here's jfoutz' post: http://metavar.blogspot.com/2008/02/higher-order-multivariate-automatic.html
07:57:23 <roconnor> Philonous1: I'm pretty sure you return (Diff t -> Diff t) ?
07:57:25 <path[l]> I can see that snd &&& fst seems to do the right thing, but I dont even know why
07:57:25 <dmwit> path[l]: Think about what (snd, fst) means: it is a tuple that contains two functions.
07:57:32 <path[l]> oooh
07:57:33 <Philonous1> roconnor: No, I don't
07:57:33 <path[l]> rigt
07:57:35 <path[l]> right
07:57:38 <dmwit> path[l]: You probably wanted a function which takes a tuple and returns a tuple instead.
07:57:42 <path[l]> yes
07:57:51 <dmwit> path[l]: So see if you can work out how to do that. =)
07:57:58 <path[l]> so should I have done ((snd x),(fst x)) ?
07:58:05 <maxote> i said <maxote> let isNothing x = if (x == Nothing) then (1 +) else (-1 +) in nuncurry isNothing Nothing 0   --> it should return 1   <--- correct me, /(x == Nothing)/(nameOfTuple(x) == Nothing)/
07:58:16 <dmwit> path[l]: Exactly!  (Provided (x) is the argument to swap, of course.)
07:58:21 <path[l]> right
07:58:25 <path[l]> awesome
07:58:27 <dmwit> path[l]: Note that your parens are unnecessary.
07:58:28 <Philonous1> roconnor: I abstracted away the Diff. That's the whole point of this code, you don't have to create towers by hand.
07:58:33 <path[l]> why does &&& work?
07:58:34 <dmwit> path[l]: swap x = (snd x, fst x) -- also fine
07:58:38 <path[l]> oh ok
07:58:44 <path[l]> whats &&& ?
07:58:55 <dmwit> path[l]: (&&&) is a function which takes two functions and returns both of their results in a tuple.
07:59:01 <path[l]> haha
07:59:04 <path[l]> awesome
07:59:05 <path[l]> thanks
07:59:05 <maxote> dmwit path[l]: swap (left,right) = (right, left)
07:59:12 <roconnor> Philonous1: that's your choice.  But you cannot iterate because of your choice.
07:59:15 <Phyx-> @type (&&&)
07:59:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:59:30 <ski>   (&&&) :: (a -> b0) -> (a -> b1) -> (a -> (b0,b1))  -- here
07:59:35 <Phyx-> @type ((-1) &&& (+1))
07:59:37 <lambdabot> forall b c. (Num (b -> c), Num b) => b -> (c, b)
07:59:41 <Phyx-> nice
07:59:45 <dmwit> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
07:59:49 <Phyx-> @type ((-1) &&& (+1)) 8
07:59:51 <lambdabot> forall b c. (Num (b -> c), Num b) => (c, b)
07:59:58 <Phyx-> ((-1) &&& (+1)) 8
08:00:00 <path[l]> hmm
08:00:06 <dmwit> :type (subtract 1 &&& (+1))
08:00:07 <Phyx-> > ((-1) &&& (+1)) 8
08:00:09 <lambdabot>   No instance for (GHC.Num.Num (b -> c))
08:00:09 <lambdabot>    arising from a use of syntactic n...
08:00:10 <dmwit> :t (subtract 1 &&& (+1))
08:00:11 <LeoD> Num (b -> c) huh?
08:00:12 <lambdabot> forall t. (Num t) => t -> (t, t)
08:00:20 <ski> path[l] : you do know you can define `swap ~(x,y) = (y,x)' right ?
08:00:21 <dmwit> Phyx-: Remember the weird things about unary -...
08:00:32 <path[l]> no I didnt know I could do that
08:00:33 <path[l]> :o
08:00:35 <Phyx-> > ((subtract 1) &&& (+1)) 8
08:00:37 <lambdabot>   (7,9)
08:00:45 <path[l]> but whats ~?
08:00:46 <Phyx-> dmwit: i keep forgetting that
08:00:56 <dmwit> path[l]: ~ makes a pattern match "lazy".
08:01:13 <ski> (path[l] : the `~' was just for getting exactly the same as `swap p = (snd p,fst p)')
08:01:17 <Phyx-> dmwit: is that actually usabled in a .hs file?
08:01:19 <dmwit> path[l]: It says to the compiler: "I *know* I'm using the right constructor here, so don't bother destructing this value until you really, really need to."
08:01:29 <dmwit> Phyx-: Is what actually usable?
08:01:41 <Phyx-> ~, ghc would always balk at me when i use it
08:01:49 <path[l]> huh ... yeah I think Im still too noob to understand that. Just reached chapter 5 of RWH
08:01:51 <dmwit> Phyx-: Only at the front of patterns.
08:02:08 <maxote> ski, i've these functions, they aren't truely correct because almost of them are using 2-tuples instead of using inductive definitions of tuples that doesn't provide Haskell although it provides HList package but it requires a different sugared syntax.
08:02:08 <path[l]> hey can I define swap to only work on tuples where (a,b) are the same type?
08:02:10 <dmwit> path[l]: Then don't worry.  There are other, more important things to bend your mind around for now. =)
08:02:13 <Phyx-> dmwit: alright
08:02:19 <dmwit> path[l]: Of course.
08:02:24 <dmwit> path[l]: Just give an explicit type signature.
08:02:26 <maxote>  /i've/i've seen/
08:02:30 <path[l]> cause I have an array of (a,b) and I want to make it an array of (a,b) and (b,a) all together
08:02:38 <path[l]> and Im guessing the typechecker wont like it
08:02:43 <ski> (path[l] : the difference is that with `swap (x,y) = (y,x)' `case swap (error "help !") of (_,_) -> 42' will raise the error, but with `swap ~(x,y) = (y,x)' (or `swap = snd &&& fst'), it will return `42')
08:02:43 <Phyx-> :t (***_
08:02:45 <lambdabot> parse error (possibly incorrect indentation)
08:02:46 <Phyx-> :t (***)
08:02:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:02:50 <path[l]> Im doing all this just to use Map.fromlistiwithkey lol
08:03:02 <Phyx-> :t ((+1) *** id)
08:03:02 <Philonous1> roconnor: Hmm, maybe I can fix that without loosing the auto-creation of towers. Thanks for the hint.
08:03:03 <lambdabot> forall b b'. (Num b) => (b, b') -> (b, b')
08:03:11 <dmwit> path[l]: But note that you can use the general swap function on pairs where both elements have the same type, and nothing will go wrong with that.
08:03:29 <Phyx-> :t ((+1) *** id).((subtract 1) &&& (+1))
08:03:30 <lambdabot> forall b. (Num b) => b -> (b, b)
08:03:42 <Phyx-> ((+1) *** id).((subtract 1) &&& (+1)) 0
08:03:44 <path[l]> dmwit : yeah but I want to define a function that gets a list of pairs and concats it with the list of swapped pairs
08:03:54 <Phyx-> > ((+1) *** id).((subtract 1) &&& (+1)) 0
08:03:56 <lambdabot>   Couldn't match expected type `a -> (b, b')'
08:04:06 <path[l]> will the compiler be smart enough to say that swap now only works on pairs with the same type?
08:04:06 <dmwit> path[l]: As long as the pairs start out with the same type in each slot, that's fine.
08:04:11 <path[l]> ah
08:04:13 <dmwit> path[l]: Absolutely!
08:04:19 <path[l]> ah awesome
08:04:20 <ski> maxote : i'm not sure what you're saying
08:04:21 <Phyx-> hrm
08:04:26 <Phyx-> why did that fail..
08:04:32 <Phyx-> :t ((+1) *** id).((subtract 1) &&& (+1)) 0
08:04:33 <lambdabot>     Couldn't match expected type `a -> (b, b')'
08:04:33 <lambdabot>            against inferred type `(t, t)'
08:04:33 <lambdabot>     In the second argument of `(.)', namely
08:04:39 <Phyx-> oh
08:04:43 <dmwit> Phyx-: needs more $
08:04:47 <Phyx-> > (((+1) *** id).((subtract 1) &&& (+1))) 0
08:04:49 <lambdabot>   (0,1)
08:04:54 <dmwit> right
08:04:54 <path[l]> hey mind if I quickly run you through my strategy of a solution and you can tell me if I missing a really simple haskell trick? Ive thought up a 4/5 line solution
08:05:00 <Phyx-> dmwit: yeah, figured that out, lol
08:05:36 <dmwit> path[l]: Put your solution on hpaste and we'll happily rip you apart. ;-)
08:05:43 <path[l]> ah
08:05:44 <path[l]> ok
08:05:45 <Phyx-> lol
08:05:47 <ski> @paste
08:05:47 <path[l]> so let me get it working
08:05:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:05:50 <path[l]> and then do it
08:05:51 <path[l]> :)
08:05:57 <path[l]> I still need to work through syntax
08:05:58 <path[l]> lol
08:06:00 * Phyx- would like his code ripped apart too
08:06:27 <maxote> @src nuncurry   -- see it, ski
08:06:28 <lambdabot> Source not found. :(
08:06:48 <dmwit> Phyx-: The more advanced your code is, the less happy we are about ripping it apart...
08:07:16 <Phyx-> dmwit: awww
08:07:34 <maxote> ski, i've said me that my definitions are ill-typed, i will try to type them.
08:07:35 <Phyx-> btw, why isn't there an unfoldl?
08:07:52 <path[l]> :t concatmap
08:07:54 <lambdabot> Not in scope: `concatmap'
08:07:57 <ski> what would it do ?
08:08:00 <Phyx-> :t concatMap
08:08:01 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:08:04 <path[l]> ah right
08:08:07 <ski> generate the list backwards ?
08:08:23 <quicksilver> ski: build the list rom the last element first, I suppose
08:08:37 <path[l]> hmm using concatMap I cant use the points free syntax can I?
08:08:44 <path[l]> cause a doesnt show up on the right side
08:08:46 <Phyx-> ski: currently, i have to call reverse at the end, which seems rather inefficient
08:08:56 <dmwit> path[l]: That question is way too vague to answer.
08:08:57 <quicksilver> path[l]: everything can be made pointfree but some things look horrible.
08:08:58 <ski> path[l] : `flip concatMap' ?
08:09:13 <dmwit> path[l]: In short, everything can be pointfree... but often that's undesirable, as quicksilver says.
08:09:17 <ski> @type flip concatMap
08:09:19 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
08:09:25 <path[l]> hmm I guess I should just finish the solution and then come here
08:09:26 <path[l]> lol
08:09:34 <path[l]> ok let me work this through
08:09:44 <ski> instead of `flip concatMap' you can use `(>>=)' (if you dare ;)
08:10:03 <Phyx-> for instance http://phyx.pastebin.com/d372ab22e, it would be nice to do without the reverse... for the record, the function just takes a numebr and onverts it to a list of it's elements, eg, 123 gets made into [1,2,3]
08:10:24 <ski> @type ContT . (>>=)
08:10:26 <lambdabot> forall a (m :: * -> *) r. (Monad m) => m a -> ContT r m a
08:10:26 <path[l]> btw whats that haskell-in-depth channel. Do they do stuff like sessions or something?
08:10:38 <quicksilver> well, all your types need projections of course, so you have a way to pointfree the constructors.
08:10:44 <path[l]> actually I wonder if anyone has done video tutorial sessions of haskell
08:11:36 <quicksilver> @pl \(Left a) -> a
08:11:36 <lambdabot> (line 1, column 8):
08:11:36 <lambdabot> unexpected "a"
08:11:36 <lambdabot> expecting operator or ")"
08:11:46 <quicksilver> unfortunately @pl can't cope with some types ;)
08:11:55 <quicksilver> [the answer is "either id undefined"]
08:11:59 <Phyx-> > let { toDec 0 = [0]; toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 10 in if a == 0 then Nothing else Just (b,(a-b) `div` 10)))) x}
08:12:00 <lambdabot>   not an expression: `let { toDec 0 = [0]; toDec x = (reverse.(unfoldr (\a-> ...
08:12:00 <path[l]> hmm my ghci doesn't like &&&
08:12:06 <dmwit> path[l]: h-i-d was meant to be a channel for experienced Haskellers to use to avoid cluttering this channel.
08:12:11 <path[l]> Not in scope: `&&&'
08:12:14 <path[l]> ah ok
08:12:14 <quicksilver> path[l]: :m+ Control.Arrow
08:12:16 <Phyx-> path[l]: import Control.Arrow
08:12:22 <path[l]> oh ok
08:12:28 <fasta> dcoutts: what was the solution to a package needing both quickcheck 1 and quickcheck 2 again?
08:12:33 <Phyx-> > let toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 10 in if a == 0 then Nothing else Just (b,(a-b) `div` 10)))) x
08:12:35 <lambdabot>   not an expression: `let toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 1...
08:12:41 <Phyx-> hm?
08:12:51 <dmwit> eww
08:12:53 <quicksilver> well, it isn't an expression.
08:13:04 <ski> , [$ty|MkContT2 . forM_|]
08:13:06 <ski> , [$ty|MkContT2 . forM|]
08:13:07 <lunabot>  forall a b c . Monad b => [] c -> ContT2 a () b c
08:13:07 <Phyx-> dmwit: hahahah that made me laugh
08:13:07 <quicksilver> expressions look like "let foo = bar in baz"
08:13:08 <lunabot>  forall a b c . Monad b => [] c -> ContT2 a ([] a) b c
08:13:10 <dcoutts> fasta: you mean an individual package directly needing both? or indirectly via dependencies?
08:13:15 <fasta> dcoutts: yes
08:13:21 <dmwit> > let toDec = map (`mod` 10) . iterate (`div` 10) in toDec 1024
08:13:22 <lambdabot>   [4,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:13:24 <dcoutts> fasta: that was an "or" question
08:13:37 <dmwit> :t unfoldr
08:13:38 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:13:43 <fasta> dcoutts: the latter
08:13:45 <Phyx-> > def { toDec 0 = [0]; toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 10 in if a == 0 then Nothing else Just (b,(a-b) `div` 10)))) x}
08:13:47 <lambdabot>   <no location info>: parse error on input `0'
08:14:01 <quicksilver> Phyx-: now that's just something you made up :P
08:14:03 <Phyx-> dmwit: anyway, just saying, unfoldl would be nice
08:14:04 <path[l]> I still get an error that goes
08:14:08 <quicksilver> Phyx-: > is an expression evaluator.
08:14:09 <Phyx-> quicksilver: hehehe :P
08:14:09 <path[l]> mmadness.hs:8:0: parse error (possibly incorrect indentation)
08:14:10 <path[l]> Failed, modules loaded: none
08:14:17 <dmwit> > let toDec = unfoldr (\x -> if x == 0 then Nothing else Just (x `divMod` 10)) in toDec 1024
08:14:19 <lambdabot>   [102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:14:20 <quicksilver> Phyx-: @let adds new definitions to the context.
08:14:26 <dmwit> whoops
08:14:26 <dmwit> heh
08:14:36 <Phyx-> @let { toDec 0 = [0]; toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 10 in if a == 0 then Nothing else Just (b,(a-b) `div` 10)))) x}
08:14:36 <dcoutts> fasta: ok, the workaround is to get the deps installed and then cabal configure, and ignore the warning. You'll also need to cabal install --only to avoid re-planning the deps.
08:14:37 <lambdabot>  <local>:8:0: parse error on input `{'
08:14:43 <path[l]> line 8 simply says swap = snd &&& fst
08:14:47 <Phyx-> @let toDec x = (reverse.(unfoldr (\a-> let b = a `mod` 10 in if a == 0 then Nothing else Just (b,(a-b) `div` 10)))) x
08:14:49 <lambdabot>  Defined.
08:14:56 <Phyx-> toDec 1024
08:15:00 <Phyx-> > toDec 1024
08:15:02 <lambdabot>   [1,0,2,4]
08:15:03 <quicksilver> path[l]: maybe it is incorrectly indented?
08:15:09 <dcoutts> fasta: and obviously build in between the configure and install --only steps.
08:15:15 <quicksilver> path[l]: or maybe your previous definition isn't properly terminated?
08:15:20 <dmwit> > let toDec = unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10) in toDec 1024
08:15:20 <path[l]> hmm
08:15:22 <Phyx-> how do you do multiline @let ?
08:15:22 <quicksilver> path[l]: ( hpaste it! )
08:15:22 <lambdabot>   <no location info>: parse error on input `in'
08:15:33 <dmwit> > let toDec = unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)) in toDec 1024
08:15:34 <lambdabot>   [4,2,0,1]
08:15:38 <path[l]> no that worked. My previous line was wrong
08:15:39 <path[l]> thanks
08:15:42 <dmwit> > let toDec = reverse . unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)) in toDec 1024
08:15:44 <lambdabot>   [1,0,2,4]
08:15:59 <ski> @type divMod
08:16:00 <dmwit> > let toDec = map digitToInt . show in toDec 1024 -- better!
08:16:01 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:16:01 <Phyx-> dmwit: hm that is alot shorter...
08:16:02 <lambdabot>   [1,0,2,4]
08:16:38 <Phyx-> dmwit: but slower no?
08:16:51 <Phyx-> @type guard
08:16:52 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:16:57 <dmwit> If you have toDec on a critical path, you are Doing Something Wrong.
08:17:20 <path[l]> :t show
08:17:22 <lambdabot> forall a. (Show a) => a -> String
08:17:24 <Phyx-> lol, i'm just saying
08:17:26 <path[l]> huh
08:17:28 <path[l]> hmm
08:17:37 <path[l]> so it's like a to string function eh
08:17:39 <path[l]> wierd
08:17:50 <Phyx-> why?
08:17:57 <dmwit> It's not so weird.  Almost every language has one. =)
08:18:35 <path[l]> yeah no I was looking through the data.map example
08:18:35 <path[l]> for fromlistwithkey
08:18:35 <path[l]> and they use it
08:18:51 <Phyx-> @type when
08:18:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:18:51 <path[l]> it sounded like a print statement or something
08:18:51 <Phyx-> ah
08:18:59 <path[l]> its to convert a char to a string
08:19:05 <fasta> dcoutts: why is this limitation there to begin with? What does --only do exactly? It's not in the --help
08:19:11 <dmwit> It is much like a print statement, in the following precise way:
08:19:32 <dcoutts> fasta: it's not supposed to be necessary
08:19:32 <dmwit> ?src print
08:19:32 <lambdabot> print x = putStrLn (show x)
08:19:50 <dcoutts> fasta: the limitation that there is at most one version of each package is a deliberate feature.
08:21:03 <fasta> dcoutts: do you still think it is a realistic assumption?
08:21:47 <dcoutts> fasta: it's an overly conservative assumption, but we do not have enough information at the moment to make a more accurate one
08:22:03 <dcoutts> fasta: if we lifted the restriction completely then things would break constantly
08:23:05 <fasta> dcoutts: I installed the offending dependency, did cabal configure. cabal install --only, but it said that I had to run cabal configure first.
08:23:29 <dcoutts> fasta: and you built in between?
08:23:36 <fasta> dcoutts: cabal build?
08:23:39 <dcoutts> yes
08:23:46 <EvilTerran> pickDependencies :: Map Package (Set Version) -> Map Package Version -- ?
08:23:57 <fasta> dcoutts: yes, I tried that, but it says, run configure first.
08:24:14 <dcoutts> fasta: was configure not successful?
08:24:44 <fasta> dcoutts: lots of packages are missing, but those are all on Hackage. I thought the entire point of cabal install was to automatically install dependencies.
08:24:51 <path[l]> :t fromListWithKey
08:24:53 <lambdabot> Not in scope: `fromListWithKey'
08:25:01 <dcoutts> fasta: yes, that's what "cabal install" does
08:25:02 <path[l]> :t Map.fromListWithKey
08:25:04 <lambdabot> Couldn't find qualified module.
08:25:18 <dcoutts> fasta: but that requires the thing about one version of each package
08:25:44 <dcoutts> fasta: as I said, the workaound is to get all the deps installed (using cabal install) and then use configure
08:26:08 <path[l]> how do I look up fromLitWithKey on lambdabot?
08:26:11 <fasta> dcoutts: ok, so another script to write for me. Ok, thanks.
08:26:52 <dcoutts> fasta: since at that point it doesn't have to make any kind of dependency plan, it just picks the highest (or given) versions of the dependencies, even if that violates the restriction of at most one version of each package
08:27:40 <dcoutts> fasta: you see, you can present a plan and it'll just warn, but it cannot construct a plan on its own that violates the restriction, that's the difference
08:28:09 <fasta> dcoutts: I don't like that design decision, if that's what you call it. But, it's your tool.
08:28:11 <dcoutts> because it's designed not to and there are far too many alternative "solutions" that violate the restriction
08:28:36 <dcoutts> fasta: so there would be no sensible way to pick
08:29:13 <dcoutts> fasta: do you understand the reason for the restriction in general?
08:29:32 <fasta> dcoutts: not for the case that I have here.
08:29:47 <fasta> dcoutts: all the packages have their dependencies perfectly well specified.
08:29:58 <dcoutts> fasta: sure, in the case you've got there it would work, we just do not have enough info to know that it could work
08:30:21 <fasta> dcoutts: all I would expect from cabal install would be to recursively install all of the dependencies.
08:30:32 <dcoutts> fasta: you make it sound like that's easy :-)
08:30:37 <fasta> If you can install one package, installing it recursively would be trivial.
08:30:40 <dcoutts> hah
08:30:45 <EvilTerran> path[l], ?hoogle, ?index, or ?type could be useful
08:30:49 <EvilTerran> ?hoogle fromListWithKey
08:30:49 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
08:30:49 <lambdabot> Data.Map fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
08:30:54 <dcoutts> fasta: it's actually a NP-complete problem
08:30:54 <EvilTerran> ?index fromListWithKey
08:30:55 <lambdabot> Data.IntMap, Data.Map
08:31:01 <fasta> So, apparently there is something which I am missing here.
08:31:09 <EvilTerran> ?type fromListWithKey
08:31:11 <lambdabot> Not in scope: `fromListWithKey'
08:31:15 <EvilTerran> hm.
08:31:18 <fasta> dcoutts: the case I have here is not.
08:32:09 <dcoutts> fasta: see http://blog.well-typed.com/2008/04/the-dreaded-diamond-dependency-problem/
08:32:10 <fasta> dcoutts: what exactly is the 'solve the dependencies'-problem?
08:32:13 <path[l]> hmmm
08:32:18 <fasta> dcoutts: ok
08:32:28 <path[l]> whats an IntMap as opposed to a Map?
08:32:45 <dcoutts> fasta: and on solving the problem see http://blog.well-typed.com/2008/08/solving-the-diamond-dependency-problem/
08:32:54 <path[l]> http://phyx.pastebin.com/m35906fb9 <--- can someone tell me how to get this compiling please? IT seemed simple enough ....
08:33:31 <node808> azing time last nite, I rode him till he came and then he rode me right after while it dripped out on my tummy....are you going to be with him tonite? I was thinking we could all get together and maybe invite Samuel too...just have a real run at it!  Sound good?
08:34:00 <node808> oh shit
08:34:02 <EvilTerran> path[l], "IntMap a" is analogous to "Map Int a", just (potentially) more efficient
08:34:19 <path[l]> oj
08:34:22 <path[l]> oh*
08:34:26 <path[l]> so integer keys?
08:34:47 <Phyx-> > toDec (-293)
08:34:50 <EvilTerran> fixed-length integer keys
08:34:53 <lambdabot>   mueval-core: Prelude.read: no parse
08:34:53 <lambdabot>  mueval: ExitFailure 1
08:35:03 <EvilTerran> (ie, specifically Int, not Integer)
08:35:15 <path[l]> ah right
08:35:17 <path[l]> thanks
08:35:31 <ski> path[l] : `charHash = fromListWithKey combine . revLinks' ?
08:35:32 <Phyx-> > toDec 1020394746783783783
08:35:34 <lambdabot>   [1,0,2,0,3,9,4,7,4,6,7,8,3,7,8,3,7,8,3]
08:35:57 <path[l]> it needs a . ?
08:36:10 <path[l]> f.g = f(g(x)) ?
08:36:16 <ski> well, `revLinks' is not a list, is it ?
08:36:20 <path[l]> yeah
08:36:21 <ski> @src (.)
08:36:21 <lambdabot> (f . g) x = f (g x)
08:36:30 <path[l]> ah
08:36:33 <path[l]> thanks
08:36:45 <ski> also, s/pair:[swap pair]/[pair,swap pair]/
08:36:52 <path[l]> hmm new error though
08:37:01 <path[l]> oh ok
08:37:08 <path[l]> why though?
08:37:15 <ski> what error ?
08:37:27 <path[l]> Ambiguous type variable `a' in the constraint:
08:37:28 <path[l]>       `Ord a'
08:37:28 <path[l]>         arising from a use of `fromListWithKey' at mmadness.hs:9:11-33
08:37:28 <path[l]>     Possible cause: the monomorphism restriction applied to the following:
08:37:28 <path[l]>       charHash :: [([a], [a])] -> Map [a] [a] (bound at mmadness.hs:9:0)
08:37:53 <ski> (the `[pair,swap pair]' is more standard-looking than the other, which is also fine, btw)
08:37:55 <EvilTerran> @check \x y -> [x :: Int, y] == x:[y] && x:[y] == x:y:[]
08:37:56 <lambdabot>   "OK, passed 500 tests."
08:38:01 <fasta> dcoutts: I don't see there what the problem is exactly (and thus that it is NP-Complete) immediately. Also, this story is not applicable to installing new packages. Those have to be compiled anyway.
08:38:03 <dcoutts> fasta: so the point is, we do not have enough info to distinguish your QC case from the example bytestring case. We'd need something like knowing the deps are "private" that stuff does not "leak" into the package interface. It should be possible to try solving for partial coherence (where you specify what you're prepared to tolerate -- ie tolerate two versions of QC but not two versions of bytestring) but that's probably quite hard.
08:38:29 <path[l]> hmm
08:39:10 <EvilTerran> path[l], writing foo:[bar] is an odd mixture of explicit lists (foo:bar:[]) and sugared lists ([foo,bar]). nothing wrong with it, it just looks slightly odd
08:39:20 <path[l]> ah ok
08:39:21 <ski> path[l] : disable DMR, or eta-expand `charHash', or give it a type signature
08:40:01 <ski> eta-expansion being `charHash list = fromListWithKey combine (revLinks list)'
08:40:18 <etpace_> is there such things as improper lists in haskell like erlang and scheme?
08:40:33 <ski> no, because of well-typedness
08:40:35 <path[l]> what does eta-expand mean?
08:40:44 <ski> (unless you could cyclic and infinite lists as improper ones)
08:40:57 <EvilTerran> path[l], eta-equivalence is the idea that (\x -> f x) = f
08:41:13 <EvilTerran> eta-reduction being replacing (\x -> f x) with f, and eta-expansion being the reverse
08:41:18 <path[l]> ah ok
08:41:19 <ski> path[l] : generally, eta-expanding a definition `foo x y = ..x..y..' gives you `foo x y z = (..x..y..) z'
08:41:29 <path[l]>  ool
08:41:32 <ski> what EvilTerran said, for expressions
08:41:52 <EvilTerran> (or, in this case, going from "foo ... x = (...) x" to "foo ... = ..."
08:41:53 <dcoutts> fasta: it applies to picking the versions of new and existing packages
08:42:05 <ski> (`foo x y z = (..x..y..) z' is equivalent to `foo x y = \z -> (..x..y..) z')
08:42:35 <fasta> dcoutts: ok, and another thing: where does cabal look for the ghc compiler to use and thus ghc-pkg and all that?
08:42:49 <dcoutts> fasta: I'm not saying it's something we can never solve, it needs more info and a more sophisticated solver.
08:42:56 <ski> path[l] : the simplest might be to disable DMR, though (if your implementation supports that)
08:43:11 <dcoutts> fasta: on the path, you can use --with-ghc=
08:43:34 <dcoutts> fasta: it finds ghc-pkg based on where it finds ghc, but you can override it with --with-ghc-pkg=
08:43:40 <etpace_> whats a cyclic list ski?
08:43:43 <fasta> dcoutts: ok
08:43:51 <ski> > let ones = 1 : ones in ones
08:43:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:43:56 <ski> etpace_ : ^
08:43:59 <etpace_> aha, thanks
08:44:05 <absentia> nice
08:44:31 <ski> (s/could/count/)
08:44:52 <EvilTerran> etpace_, the only ways lists in haskell can lack a [] is if they're either semantically infinite (cyclic lists fall into this category) or partial (1:2:3:4:5:undefined, say)
08:44:53 <burp> > cycle [1]
08:44:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:45:39 <etpace_> What's i'd like to be able to do, is be able to partially build a list say 1:2:3, and then at a later time cons that onto 4:[], or something
08:45:44 <ski> @src repeat
08:45:44 <lambdabot> repeat x = xs where xs = x : xs
08:45:57 <EvilTerran> etpace_, sounds like difference lists may do what you want
08:46:05 <ski> etpace_ : `\xs -> 1:2:3:xs' ?
08:46:23 <EvilTerran> ie, representing a list xs as a function (xs++)
08:46:44 <etpace_> hmm, good ideas
08:47:11 <EvilTerran> you can't look at a difference list 'til you give it a tail, but they offer some nice speed-ups if you're concatenating a lot without needing to look at the intermediate lists
08:47:37 <Berengal> difference lists are nice for Writer
08:47:40 <EvilTerran> (for instance, in a list sorting algorithm)
08:47:50 <ski> it's basically the same as passing around a list accumulator and consing onto that
08:47:56 <EvilTerran> Berengal, Writer (Endo [a]) ?
08:48:18 <Berengal> EvilTerran, what's Endo?
08:48:23 <ski> @src Endo
08:48:24 <lambdabot> Source not found. Just try something else.
08:48:37 <ski>   newtype Endo a = Endo {runEndo :: a -> a}
08:48:38 <EvilTerran> newtype Endo a = Endo { appEndo :: a -> a }
08:48:45 <Berengal> Ah, yes
08:48:45 <ski> ok, `appEndo' :)
08:48:49 <EvilTerran> :P
08:49:09 <maltem> Why is it called Endo - what's the structure where it is an endomorphism?
08:49:15 <EvilTerran> Berengal, it's in Data.Monoid, iirc, so comes with a mappend = (.), mempty = id
08:49:30 <ski> a morphism is an endomorphism iff the domain and the codomain is the same object
08:49:48 <Berengal> EvilTerran, should've figured. Makes sense. And yes, that's a pretty decent writer
08:50:10 <Berengal> Better than [a] anyway
08:50:24 <EvilTerran> i'd imagine it's more efficient in a lot of circumstances, at least
08:50:26 <maltem> ski, I tought every endomorphism were a homomorphism. is that different in CT?
08:50:31 <ziman> endomorphisms over a given (co)domain form a monoid with respect to id and composition
08:50:36 <Berengal> Perhaps slightly less efficient to use...
08:50:43 <ski> Berengal : hm, it's lazy i hope ?
08:51:07 <Berengal> ski, assuming lazy implementations of lists, yes
08:51:15 <ski> maltem : every endomorphism is a morphism, but not every morphism is an endomorphism
08:52:07 <maltem> ski, right, I was asking about homo-
08:52:09 <arw> uh, a subset...
08:52:22 <Phyx-> eh..
08:52:30 <ski> Berengal : i was meaning how `tell xs >> foo' doesn't need to complete `foo' to provide the elements in `xs' .. but i think using `Endo [a]', that would still hold
08:52:38 <dmwit> homomorphism is just a long-form for morphism
08:52:40 <dmwit> ;-)
08:53:04 <ski> maltem : afaik, `homomorphism' is (sometimes) used for `morphism' in "algebraic" categories
08:53:11 <maltem> oh, well, then...
08:53:32 <maltem> back to the question, in what structure does the Endo type denote a morphism?
08:53:45 <dmwit> monoid
08:53:51 <ski> @kind Endo
08:53:52 <lambdabot> * -> *
08:53:57 <Phyx-> @src (***)
08:53:57 <lambdabot> f *** g = first f >>> second g
08:54:05 <dmwit> Or any other category that only has endomorphisms, I guess. =)
08:54:13 <Phyx-> @ty (>>>)
08:54:14 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:54:19 <Phyx-> heh
08:54:20 <dmwit> i.e. with only morphisms from objects to themselves.
08:54:24 <maltem> dmwit, ah I see
08:55:13 <ski> i don't see how `Endo' itself can be a morphism, except maybe in some sub-category of `Cat' (or something similar)
08:55:46 <maltem> and I realize I missed ziman's answer, sry
08:56:02 <maxote> in pseudocode, nuncurry f::(symbol s -> b) {{name::(symbol s)}(x1::a1,x2::a2,..,xn::an) :: named tuple s(a1,a2,..,an)} = (((f::(symbol s -> b)  name::(symbol s)) x1::a1) x2::a2) .. xn::an) = (symbol s -> (a1->a2->..->an)) -> (symbol s) -> a1 -> a2 -> .. -> an  where b was a1->a2->...->an
08:56:14 <dmwit> ack
08:56:15 <maltem> ski, riiight... I did mean Endo a
08:56:41 <maxote> sorry for my unafortunated power outage
08:57:03 <ski> maltem : and maybe you meant that `Endo a' should denote a *type* of morphisms ?
08:57:04 <dmwit> maxote: Have you looked at HList?
08:57:24 <maxote> yes dmwit
08:57:38 <maltem> ski, right too
08:58:13 <maxote> removing b by a1->a2->...->an, the typed definition is
08:59:17 <maxote> nuncurry f::(symbol s -> (a1->a2->..->an)) {{name::(symbol s)}(x1::a1,x2::a2,..,xn::an) :: named tuple s(a1,a2,..,an)} = (((f::(symbol s -> (a1->a2->..->an))  name::(symbol s)) x1::a1) x2::a2) .. xn::an) = (symbol s -> (a1->a2->..->an)) -> (symbol s) -> a1 -> a2 -> .. -> an
08:59:26 <maltem> I'm used to saying the name of a type when I mean the values or terms of that type, or the semantics of that type. I realize that's ambiguous when there are statements at the level of the type system to be made.
09:00:02 <ziman> Endo is kind of a "tag" for the compiler and an assurance that the enclosed morphism is an endo-; "Endo a" can then be regarded as "a" itself (forming a monoidal structure, thanks to the assurance)
09:00:33 <ski> @type Endo reverse
09:00:34 <lambdabot> forall a. Endo [a]
09:02:39 * ski . o O ( .. where to start ? )
09:04:29 <maxote> i forgot to put (..(( to it   (..(((((f::(symbol ....
09:06:15 <sm> Cale, gwern: any plans to split off some irc libs from lambdabot ?
09:06:24 <sm> I'm looking for bits to use in rss2irc
09:06:35 <dmwit> I suggest these bits: 01
09:06:41 <dmwit> ;-)
09:09:43 <ski> hrm
09:10:07 <ski> maxote : could you give an example use of `nuncurry' (with expected result) ?
09:11:44 <maxote> ski, i'm writing all in pseudocode, i'm getting difficults of how to manage Haskell's tuples and/or HList w/ syntax, and i've not idea how to get nameOfTuple(named tuple)->symbol.
09:12:01 <ski> btw, sometimes it would be nice to check that the type of an expression was *no*more* general as a given type
09:12:25 <ski> maxote : forget `HList' for now
09:12:30 <skorpan> are you still on ncurry?
09:12:39 <maxote> skorpan, soon
09:12:42 <ski> skorpan : unfortunately, yes
09:13:08 <ski> (oh, i thought you said `nuncurry')
09:13:17 <skorpan> ncurry, nuncurry, nunchucks, all the same
09:13:49 * ski wrote something like `ncurry' above, but maxote hasn't said yet whether it was satisfactory or not
09:14:19 <ski> @hoogle nunchunks
09:14:20 <lambdabot> No results found
09:15:55 <augustss> we don't have any nunchucks?
09:16:11 <quicksilver> cowabunga :(
09:16:22 <sm> oops, lambdabot is GPL so perhaps I can't
09:18:22 <quicksilver> maxote: symbol is not a type in haskell.
09:18:29 <quicksilver> maxote: having symbol as a type breaks alphaconversion.
09:18:45 <sm> Things like IRCBase and Plugins/IRC would be great to have available for irc-aware haskell apps
09:19:22 <maxote> quicksilver, symbol is a restriction of type 's, it's like to say 's is a symbol.
09:19:45 * ski might be able to conjure something similar to `nuncurry', if he could first understand what `nuncurry' is supposed to do
09:20:26 <maxote> symbol isn't string, symbol is a string-like in the code, as in Lisp or Prolog.
09:20:56 * ski still waits for the example
09:21:13 <quicksilver> maxote symbol, in the sense of lisp or prolog, cannot exist in haskell.
09:21:13 <maxote> that is translated internally to unique pointer or unique enum.
09:21:27 <quicksilver> maxote: there is no notion of 'identity' like that.
09:21:31 <quicksilver> haskell is value-based, not slot-based.
09:21:55 <maxote> the strings are ' or " quoted, the symbols not.
09:22:18 <quicksilver> in the expression "let x = 5;y=5 in ..... expression using x and y...."
09:22:24 <quicksilver> there is no difference between x and y
09:22:32 <quicksilver> there can be no function which tells them apart
09:22:39 <quicksilver> (which there would be if you could compare their symbols)
09:22:48 <quicksilver> they are both just names for the number 5.
09:22:58 <augustss> maxote: sounds like you're trying to do something in a non-haskell way
09:24:04 <maxote> augustss, pseudocode because Haskell doesn't support inductive definition of tuples and nameOfSymbol: tuple -> symbol
09:24:26 <mmorrow> augustss: is "42" a deliberate choice in:
09:24:35 <maxote> err /nameOfSymbol: tuple -> symbol/nameOfTuple: tuple -> symbol/
09:24:47 <mmorrow> > (1e-42::CReal)==0 -- :) ?
09:24:48 <lambdabot>   True
09:24:56 <mmorrow> > (1e-41::CReal)==0
09:24:58 <lambdabot>   False
09:25:44 <augustss> mmorrow: you'd have to ask David Lester :)
09:26:19 <augustss> There cannot be a total == for CReal, so it does something that is not really equality
09:26:40 <mmorrow> augustss: ahh, so then it's not "underflowing" (fsvo of that)?
09:26:55 <maxote> i assume that all tuples in the pseudocode are named tuples with its name AnonTuple, removing this unneeded field AnonTuple in some code parts is thing of the optimizer.
09:27:23 <mmorrow> augustss: i wasn't sure if that's expected behavior or not
09:27:40 * ski sighs
09:27:43 <Phyx-> @hoogle cpuTimePrecision --info
09:27:44 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
09:27:44 <lambdabot>  
09:27:44 <lambdabot> The cpuTimePrecision constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.
09:27:59 <Phyx-> > cpuTimePrecision
09:28:00 <lambdabot>   Not in scope: `cpuTimePrecision'
09:28:26 <augustss> Perhaps I should just replace the current comparisons on CReal eith a call to error
09:28:45 <Rdtsc> what's wrong with odbc package in static linking? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8341#a8341
09:28:51 <mmorrow> augustss: heh
09:29:02 <quicksilver> > (0 - 1e42) < 0
09:29:03 <lambdabot>   True
09:29:13 <quicksilver> > (0 - 1e45) < 0
09:29:14 <maxote> ncurry f::(named tuple s(a1,a2,..,an) -> b)  name::(symbol s)  x1::a1  x2::a2 .. xn::an = f::(named tuple s(a1,a2,..,an) -> b) -> {{name::(symbol s)}(x1::a1,x2::a2,..,xn::an) :: named tuple s(a1,a2,..,an)}) -> b
09:29:14 <lambdabot>   True
09:29:15 <mmorrow> > (1e-42::Double)==0
09:29:17 <lambdabot>   False
09:29:21 <ski> augustss : well, `(/=)' is semi-decidable
09:29:24 <quicksilver> augustss: how does <- work then?
09:29:30 <augustss> maxote: so what's the purpose of nuncurry?
09:29:30 <quicksilver> augustss: sorry (<) I mean
09:29:49 <maltem> > 3 - (3e-45 :: CReal) == 3
09:29:50 <lambdabot>   True
09:30:06 <hackagebot> parsimony 1 - Monadic parser combinators derived from Parsec (IavorDiatchki)
09:30:09 <quicksilver> > 3 - (3e-45 :: CReal) < 3
09:30:12 <lambdabot>   False
09:30:13 <quicksilver> ah.
09:30:15 * quicksilver nods
09:30:22 <augustss> ski: so is ==
09:30:24 <ski> (or, if you like, `x == y' is an refutative proposition, while `x /= y' is an assertative proposition)
09:30:35 <mmorrow> maltem, quicksilver: my suspicion was that there was something odd happening near 0
09:30:45 <maxote> augustss, the purpose of nuncurry/ncurry is very simple, see below
09:31:10 <ski> augustss : the point being that in cases two real numbers are different, it might be nice if `(==)' said so
09:31:59 <augustss> ski: we can certainly have comparisons that sometimes give the correct answer and sometimes loop.  but i'm not sure that's any better
09:32:52 <mmorrow> arg, what's the hackage pkg that CReal's in again?
09:32:52 <ski> we already have such, e.g. for `Eq a => Eq [a]'
09:33:23 <augustss> ski: true
09:33:36 <maxote> in pseudocode, map (nuncurry (winner)) $ [Peter(3 points), John(6 points)] `zip` [George(2 points), John(6 points)]
09:33:42 <maxote> err
09:34:08 <augustss> maxote: that code makes no sense to me
09:34:10 <mmorrow> ah got it
09:34:28 <maxote> augustss, there is a typographical damn keyboard error
09:34:30 <mmorrow> @where+ CReal http://www.augustsson.net/Darcs/CReal/
09:34:30 <lambdabot> Done.
09:35:02 <augustss> mmorrow: don't get the package from there.  the one on hackage is newer
09:35:10 <quicksilver> ski: perhaps the difference is that it's easier to understand in which cases Eq a => Eq [a] will not terminate?
09:35:25 <mmorrow> augustss: what's the pkg name on hackage?
09:35:40 <augustss> mmorrow: numbers (or is it number?)
09:35:48 * mmorrow looks
09:36:02 <mmorrow> ah git it
09:36:04 <mmorrow> *got
09:36:06 <maxote> in pseudocode, map (nuncurry (winner)) $ [Peter(3 points), John(6 points)] `zip` [George(2 points), Charles(9 points)]  should return [Peter(3 points), Charles(9 points)]   ; where data Players =  Peter (Int points) | John (Int points) | George (Int points) | Charles (Int points) ;
09:36:07 <ski> quicksilver : afaiu `x == y' will terminate iff `x' is apart from `y'
09:36:15 <mmorrow> @where+ CReal http://hackage.haskell.org/package/numbers
09:36:15 <lambdabot> It is stored.
09:36:56 <mmorrow> maxote: zipWith max -- ??
09:37:20 <augustss> maxote: and what do you have against regular uncurry?
09:37:24 <ski> (rather `zipWith (uncurry max)')
09:37:24 <maxote> and winner is a function that returns higher score player of the competition one vs one.
09:37:30 <mmorrow> ski: right
09:38:01 * mmorrow doesn't get what maxote wants
09:38:34 <mmorrow> ski: err, no zipWith max, right?
09:38:57 <ski> er .. yes, you're right
09:39:04 * ski was still thinking of the `map'
09:39:53 <ski> mmorrow : i defined an `ncurry' s.t. `ncurry f name x0 x1 .. = f (name x0 x1 ..)', e.g. `ncurry f (,) x y = f (x,y)' and `ncurry f Just x = f (Just x)'
09:40:11 <maxote> still i've not a more developed example that uses nuncurry/ncurry.
09:40:15 <augustss> so, map (uncurry winner) $ [Peter 3, John 6] `zip` [George 2, Charles 9]
09:40:23 <ski> mmorrow : i imagine `nuncurry' is meant to be the inverse of `ncurry', in some sense, but i'm not quite sure how
09:41:22 <augustss> maxote: and, btw, that's a terrible type for representing players with scores
09:42:01 * ski thinks maxote wants `winner :: (Int,Int) -> Int'
09:42:46 <maxote> the purpose of nuncurry/ncurry is the ability of managing named tuples from data constructor like the purpose of uncurry/curry is managing anon. tuples.
09:43:32 <augustss> maxote: but your example did not have records with named fields
09:43:51 <maxote> wait, i don't like `zip'
09:43:51 <augustss> maxote: your example was not Haskell at all :)
09:44:12 <augustss> maxote: neither do I :)
09:44:54 <mmorrow> > showCReal 1000 (1e-42::CReal)
09:44:56 <lambdabot>   "0.000000000000000000000000000000000000000001"
09:45:00 <mmorrow> ahh
09:45:00 <ski> (augustss : it's been non-haskell from the start. the trick is to make it haskell)
09:45:16 <mmorrow> > showCReal 1000 (1e-100::CReal)
09:45:18 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
09:45:42 <augustss> maxote: if you told us what the problem is that you are actually trying to solve we'd be able to help you better
09:45:51 <mmorrow> x == y = s' (digitsToBits digits) == 0 where (CR s') = x-y
09:45:52 <mmorrow> where
09:45:52 <ski> > drop 90 (showCReal 1000 (1e-100::CReal))
09:45:54 <lambdabot>   "000000000001"
09:46:12 <mmorrow> digits = 40; digitsToBits d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4
09:47:02 <mmorrow> (and data CReal = CR (Int -> Integer))
09:47:20 <Phyx-> > foo
09:47:21 <lambdabot>   Not in scope: `foo'
09:47:34 <maxote> nuncurry canSeePorn [Person("Peter", age 10), Person("John", age 50), Person("George", age 20), Dog("Rambo", 3), Person("Charles", 15)]   should return [Person("John", age 50), Person("George", age 20), Dog("Rambo", 3)]    where canSeePorn is a function that does a traversal list of named tuples, concatenates it and returns a sublist.
09:47:41 <Phyx-> o.O
09:48:11 <Phyx-> ? id
09:49:01 <Phyx-> @check \x->toDec x==[]
09:49:02 <lambdabot>   Not in scope: `toDec'
09:49:17 <Phyx-> @check \x->return x==[x]
09:49:18 <lambdabot>   "OK, passed 500 tests."
09:50:00 <Phyx-> i'm bored
09:50:27 <Berengal> @check \x y -> x == y
09:50:29 <lambdabot>   "OK, passed 500 tests."
09:50:32 <ski> Phyx- : check that `J r' is a monad
09:50:43 <maxote> the canSeePorn's implementation is still complicated, but `map' outside is not possible, 'fold' outside is not possible, so that nuncurry could help me.
09:51:17 <copumpkin> Berengal: zomg
09:51:28 <Phyx-> ski: think i'm gonna go outside, see the sky,smell some flowers etc
09:51:39 <ski>   newtype J r a = MkJ ((a -> r) -> a)
09:51:49 <ski> Phyx- : ok, do that
09:52:05 <Phyx-> Berengal: hrm, how did that pass....
09:52:21 <augustss> maxote: I don't understand.  What's the type of canSeePorn?
09:52:27 <Berengal> Phyx-, because "\forall x y: x = y"
09:52:45 <Berengal> Trivially proven by quickcheck
09:53:01 <noteventime> Phyx-: Isn't it because it defaults to ()?
09:53:28 <ski> Phyx- : because `exists unique x :: (). x == ()' (modulo undefinedness)
09:53:32 <Phyx-> noteventime: ah ok, that would make sense
09:54:06 * Berengal fails at combining existentialism and logic
09:54:09 <Phyx-> modulo undefinedness...
09:54:09 <Phyx-> lol
09:54:24 <ski> (well, even taking `_|_' into account, actually)
09:54:49 <maxote> augustss, it's complicated, i've not read well the pseudocode
09:54:49 <ski> Berengal : "existentialism" always makes me think of logic :)
09:55:19 <augustss> maxote: the type of canSeePorn can't be complicated
09:55:34 <maxote> canSeePorn: Person|Dog -> (string -> age)
09:55:47 <augustss> maxote: that's not Haskell
09:56:51 <augustss> maxote: but PersonOrDot -> String -> Age, might be the Haskell type you want
09:56:52 * ski . o O ( canSeePorn :: Players -> (String -> Int -> o) -> o  -- would be haskell, though )
09:57:27 <Phyx->  @check \x y -> x > 0 && x == y
09:57:28 <augustss> that looks more plausible
09:57:36 <Phyx-> @check \x y -> x > 0 && x == y
09:57:37 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n"
09:57:47 * ski assumes maxote wants `canSeePorn' to deconstruct its first argument
09:57:57 <Phyx-> so.. \n0\n0\n fails huh
09:58:21 <maxote> canSeePorn Person(name,age) = if (age >= 18) then Person(name,age);
09:58:27 <Phyx-> @check \x y -> trivial (x==0)  x == y
09:58:28 <lambdabot>   Not in scope: `trivial'
09:58:32 <ski> > let (x,y) = (0,0) in x > 0 && x == y
09:58:34 <lambdabot>   False
09:58:34 <maxote> canSeePorn Dog(name,age) = if (age >= 2) then Dog(name,age);
09:59:03 <ski> maxote : and if not ?
09:59:03 <maxote> err, i forgot uncurry the return.
09:59:40 <ski> `canSeePorn :: Players -> (String -> Int -> o) -> Maybe o' ?
10:00:27 <augustss> maxote: yeah, perhaps you want a Maybe type so you have something to return for those who can't watch porn
10:01:29 <maxote> ski, canSeePorn :: Players -> (('a -> String -> Int) -> 'b )      where 'a is initially the empty list, and 'b is the final sublist
10:01:55 * ski thinks that doesn't make sense
10:02:10 * ski also suspects maxote has been using SML or OCaml
10:02:22 <augustss> maxote: what's wrong with   let  canSeePorn (Person(_,age)) = age >= 18; canSeePorn (Dog(_,age)) = age >= 2 in filter canSeePorn [...]
10:03:43 * therp .oO("why would a dog watch porn?!")
10:04:17 <ski> (presumably maxote knows)
10:04:17 <Berengal> therp, irrelevant. The question is if he can or not, not if he wants to
10:04:22 <maxote> augustss, not wrong, but i did bad my soon example that uses nuncurry.
10:07:57 <dilinger> therp: maybe there's nothing else on?
10:08:40 <maxote> nuncurry exchangeMoney [GreenBill(3),RedBill(5),BlueBill(2)]  where GreenBill=$10, RedBill=$50, BlueBill=$200, it should return 3*$10+5*$50+2*$200 = $30+$250+$400=$680 = 3*$200+1*$50+3*$10, it's [GreenBill(3),RedBill(1),BlueBill(3)]
10:09:03 <Phyx-> therp: dogs have needs too?
10:09:35 <maxote> augustss, filter can't with it above.
10:10:05 <Phyx-> 19:04 < Berengal> therp, irrelevant. The question is if he can or not, not if he wants to
10:10:12 <Phyx->  <-- hahaah you guys are awesome
10:10:46 <andrewsw> I'm having trouble with an exercise in "Write ... Scheme in 48 hours", namely, convert:
10:10:48 <augustss> maxote: and what's the type of exchangeMoney?
10:10:50 <andrewsw> parseNumber = liftM (Number . read) $ many1 digit
10:10:57 <andrewsw> to use (>>=)
10:11:39 <maxote> augustss, i will reformulate the example better
10:12:34 <maxote> nuncurry exchangeMoney ColoredBills(3,5,2) should return ColoredBills(3,1,3)
10:13:18 <maxote> 1st field is Green worth $10, 2nd field is Red worth $50, and 3rd field is Blue worth $200.
10:14:00 <augustss> maxote: and what's the type of exchangeMoney?
10:14:37 <maxote> it's a function, exchangeMoney: symbol s -> Int -> Int -> Int
10:15:22 <augustss> What's symbol s?
10:15:55 <maxote> the symbol s is ColoredBills
10:16:28 <andrewsw> istm that I should be able to do:
10:16:45 <andrewsw> (many1 digit) >>= (liftM Number) . read, but it fails
10:16:53 <andrewsw> :(
10:17:03 <augustss> maxote: I give up.  I have no idea what you're trying to do.  Someone with more patience might be able to help you. :)
10:18:13 <ski> andrewsw : define `liftM' in terms of `(>>=)' (and something more), then expand using that definition
10:18:33 <andrewsw> ski: thanks, I'll try that.
10:19:15 <Gracenotes> Good news, everyone! I've used Haskell and graphviz to create a graph illustrating the components of over 250 kanji!
10:19:18 <Gracenotes> ..it's just unreadably cluttered
10:19:52 <maxote> i've reread my typed pseudocode if i did a mistake or not, grrrr.
10:19:52 <Baughn> ..just like the kanji, then.
10:19:54 * Baughn hides
10:20:14 <Gracenotes> -.-
10:20:20 <mmorrow> Gracenotes: generate 250 graphs, one for each, each with an N-node neighborhood
10:20:29 <mmorrow> fsvo N
10:20:32 <maxote> but my last example is more factible.
10:20:54 <mmorrow> Gracenotes: also, you can group subgraphs in boxes
10:21:15 <Baughn> Gracenotes: I've been doing pretty well at (somewhat accidentally) learning /spoken/ japanese, but the writing? Hm. No. Sorry.
10:21:43 <Gracenotes> mmorrow: since it does form a DAG, I really only plan on having specific subgraphs shown at a time
10:22:24 <Baughn> chr1s_: Chris Smith?
10:22:26 <Gracenotes> if it were a pretty tree, the whole thing would like palatable. I think the main problem is that the ranks are too close
10:22:38 <Gracenotes> it's going to be complicated, but the lines are just way to close together as it stands -.-
10:22:56 <maxote> the another named tuple could be ColoredCreditCards
10:27:42 <mmorrow> Gracenotes: (you'll see why the tiny url when you open it :) http://tinyurl.com/kqzvyj
10:28:06 <mmorrow> Gracenotes: subgraph clusterXXX + [complex=true]  is really nice
10:29:01 <Gracenotes> neat, I'll have to play with that
10:29:37 <mmorrow> Gracenotes: the different radion buttons are for using the different graphviz progs
10:29:58 <mmorrow> dot,neato,fdp,circo,twopi
10:30:50 <Gracenotes> mmorrow, Baughn: okay, I've configured it just with rank separation at a high value, nothing else special: http://gracenotes.freehostia.com/d.svg
10:31:05 <Gracenotes> (250 nodes, she's a beauty... er, YMMV)
10:31:36 <Gracenotes> I thought dot might be best for it, although I haven't use the other ones too much
10:32:21 <Baughn> Gracenotes: I do not have a sufficiently large screen to display this. ;_;
10:32:29 <mmorrow> Gracenotes: i think running that through "tred" would work wonders
10:32:37 <Gracenotes> me neither; you have to scroll around to appreciate it
10:32:38 <mmorrow> cat d.dot | tred | dot -T...
10:32:44 <Baughn> Gracenotes: Though it'd be nice if it came with some explanations.. I have no idea what it means. :P
10:32:58 <arcatan> what tred does?
10:33:28 <Gracenotes> heh, yes, I suppose it's if you already know them, see the relationships. Still, pretty pictures
10:33:29 <mmorrow> transitive reduction
10:33:42 <mmorrow> although looking at that, maybe it's already transitively reduced..
10:34:36 <mmorrow> Gracenotes: also, try s/dot/fdp/ on that, i bet that'd look nice
10:35:04 <Gracenotes> it's not transitively reduced, but it shouldn't be either... sometimes a component will appear twice in different ways
10:35:21 <Gracenotes> each node was hand-crafted >_>
10:36:07 <Gracenotes> lemme try..
10:36:25 <mmorrow> ah, yeah sometimes tred messes with meaning
10:36:37 <mmorrow> depending on what the graph represents
10:36:54 <andrewsw> ski: parseNumber = (many1 digit) >>= \x -> return (Number $ read x)
10:37:18 <burp> @hoogle silc
10:37:18 <lambdabot> No results found
10:37:31 <andrewsw> but I'm not a fan of using the lambda there as 1) it hasn't been introduced inthe text yet, and 2) I feel like I'm missing something.
10:38:00 <Gracenotes> mmorrow: whoa, anarchy :)
10:38:20 <mmorrow> Gracenotes: fdp?
10:38:33 <Gracenotes> yeah. is there a way for the lines not to cross through the nodes, I wonder?
10:38:54 <mmorrow> Gracenotes: hmm, not sure. is the .dot accessible?
10:39:26 <inaeternum> ----- i keep trying to install the haskell platform on ubuntu (following the instructions from the webpage). ./configure and make work like a charm, but on "sudo checkinstall -y" i get:"The mtl-1.1.0.2/Setup script does not exist or cannot be run"
10:39:39 <mmorrow> Gracenotes: another cool thing is that you can have graphviz generate (image,html-imagemap) pairs
10:40:01 <pikhq> andrewsw: Why, that looks like: many1 digit >>= return . Number . read
10:40:11 <maxote> i did mistake the above pseudocode of nuncurry/ncurry, the correct pseudocode is below
10:40:16 <Gracenotes> file is here.. http://gracenotes.freehostia.com/kanji.dot freehostia doesn't think it's text though
10:40:31 <andrewsw> pikhq: why, yes it does! d'oh!
10:40:32 <mmorrow> Gracenotes: so e.g. in a particular imagemap, the link at each node might link to the page where that particular node is the root
10:40:34 <mmorrow> or something
10:40:48 * mmorrow has wanted to do something like that for a while
10:40:58 <andrewsw> pikhq: ski: thanks both for pointers
10:41:04 <pikhq> (which itself looks like: Number . read <$> many1 digit -- :P)
10:41:07 <Gracenotes> mmorrow: I've seen that before online. what's the -T argument..?
10:41:11 <maxote> type nuncurry = forall a1 a2 .. an b . ( symbol -> a1 -> a2 -> ... -> an -> b ) -> (a1,a2,..,an) -> b
10:41:20 <mmorrow> Gracenotes: for a list do  dot -Tkslkdskjkm
10:41:30 <mmorrow> -Tcmapx iirc
10:41:43 <Gracenotes> -Tqwertyasdfgh
10:41:52 <mmorrow> jkl;
10:42:14 <maxote> type ncurry = forall a1 a2 .. an b . ( symbol(a1,a2,..,an) -> b ) -> a1 -> a2 -> ... -> an -> b
10:42:37 <quicksilver> augustss: glad you chimed in on that seq thread. I was despairing that nobody apart from me saw how horrific it was to depend on seq for your basic semantics
10:43:08 <mmorrow> Gracenotes: you probably need to rtfm though for the imagemaps, there's a particular way you have to attach links to nodes/edges/edge-{tails,heads}/etc
10:43:27 <augustss> quicksilver: Don't worry, many people know. :)
10:43:48 <Gracenotes> in case you haven't done fdp, http://gracenotes.freehostia.com/f.svg
10:44:26 <mmorrow> Gracenotes: add  [splines=true]   to the top-level graph attributes
10:45:31 <maxote> err, correct is it: type ncurry = forall a1 a2 .. an b . ( symbol(a1,a2,..,an) -> b ) -> symbol -> a1 -> a2 -> ... -> an -> b
10:46:20 <mmorrow> Gracenotes: gah, i botched the kanji.dot download and didn't get it in time
10:47:23 <maxote> type nuncurry = forall a1 a2 .. an b . ( symbol -> a1 -> a2 -> ... -> an -> b ) -> symbol(a1,a2,..,an) -> b
10:47:32 <Gracenotes> okay.. try again
10:47:51 <mmorrow> thx
10:48:47 <Gracenotes> heh, fdp seems to be thinking quite hard about the splines...
10:49:30 <mmorrow> whoa, my fdp+splines just finished
10:49:43 <mmorrow> pretty friggin cool :)
10:49:52 <augustss> maxote: those are not valid haskell types, and i don't know what they mean
10:50:24 <mmorrow> Gracenotes: oh, also "node [shape=none]" cleans it up a bunch
10:51:21 <dolio> What is "symbol"?
10:52:13 <dolio> It looks like it's supposed to have two different kinds.
10:52:19 <augustss> exactly
10:55:36 <maxote> dolio, symbol is the name of the tuple in the code
10:57:45 <maxote> and for curry/uncurry, symbol is removed
10:57:50 <maxote> type curry = forall a1 a2 .. an b . ( (a1,a2,..,an) -> b ) -> a1 -> a2 -> ... -> an -> b
10:58:17 <maxote> type uncurry = forall a1 a2 .. an b . ( a1 -> a2 -> ... -> an -> b ) -> (a1,a2,..,an) -> b
10:59:53 <maxote> GHC Haskell has defined curry and uncurry for n=2 only.
11:00:10 <mmorrow> Gracenotes: http://moonpatio.com/images/gracenotes_kanji_0.svg
11:00:17 <maxote> @type curry
11:00:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:00:26 <maxote> @type uncurry
11:00:28 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:00:44 <dolio> Yes. Defining a single function that works for many sizes takes a little fanciness.
11:00:55 <lilac> maxote: what do you mean "symbol is the name of the tuple in the code"?
11:01:06 <mmorrow> Gracenotes: (that used "graph [splines=true,complex=true]; node [shape=none,fontcolor=blue]; edge [color=black,style=dotted]; ranksep = 5;")
11:01:07 <dolio> And you can't really use the built-in tuples easily.
11:01:11 <Gracenotes> pretty
11:01:15 <opqdonut> :t (uncurry . uncurry . uncurry) (\a b c d -> a + b + c + d)
11:01:17 <lambdabot> forall b. (Num b) => (((b, b), b), b) -> b
11:01:28 <maxote> lilac, Nothing and Just are the symbols of the data Maybe = Nothing | Just(a) ;
11:01:41 <opqdonut> repeated uncurry corresponds to repeated zip:
11:01:47 <lilac> maxote: ok, so symbol is a data constructor?
11:01:53 <opqdonut> :t zip [1,2,3] (zip [1,2,3] [1,2,3])
11:01:53 <maxote> the 1st is named 0-tuple and the 2nd is named 1-tuple.
11:01:55 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => [(t, (t1, t2))]
11:02:08 <opqdonut> oh, sorry, should associate zips to the right
11:02:15 <opqdonut> or left, rather
11:02:52 <lilac> maxote: it seems like you're trying to use data constructors as if they're types
11:03:22 <maxote> lilac, yes, in pseudocode.
11:03:53 <dolio> I had an implementation of n-ary zip on the old hpaste, but it's gone now...
11:04:25 <maxote> damn split!
11:04:34 <dolio> Oh, I still have the file, though.
11:05:33 <mmorrow> dolio: this is a backup of most of the old hpaste http://moonpatio.com/hpaste.org/hpaste.org/
11:05:44 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8360#a8360
11:06:15 <dolio> Well, I deleted the old link when the old hpaste disappeared, so I don't know what number it was.
11:07:05 <glguy> edwardk_: you could update monoids to support text 0.4 so I can unisntall 0.3 :-D
11:07:17 <mmorrow> dolio: http://moonpatio.com/hpaste.org/hpaste.org_20080827.tar.bz2
11:07:20 <edwardk_> glguy: hah, sure
11:07:33 <edwardk_> glguy: i need to re-add the WithReducer stuff anyways
11:08:07 <Gracenotes> mmorrow: do the paste numbers directly correspond?
11:08:07 <edwardk_> glguy: did you see the new slides?
11:08:12 <glguy> edwardk_: I did not
11:08:20 <edwardk_> http://comonad.com/
11:08:24 * lilac would like a 'class Tuple t where type Head t :: *; type Tail t :: *; fst :: t -> Head t; rest :: t -> Tail t'
11:08:28 <edwardk_> posted an hour or so ago
11:08:30 <Gracenotes> oh, August 2008, that's why it's not there..
11:09:18 <lilac> hmm, i'd need a termination condition there too :-/
11:09:28 <glguy> edwardk_: Are both PDFs new?
11:09:43 <maxote> lilac, i don't use fst and snd, i use the own unification of variables in the LHS and RHS of the definition.
11:09:55 <edwardk_> glguy: the former is mostly the contents of the previous talk, reformatted with a couple of slides tacked on the end
11:10:03 <edwardk_> glguy: the latter is entirely new
11:10:08 <maxote>  /unification of variables/binding of variables/
11:10:32 <sclv> edwardk: scooped? :-( http://hackage.haskell.org/package/parsimony-1
11:10:40 <mmorrow> Gracenotes: what do the (->) in that graph mean?
11:10:49 <maxote>  e.g. i use   swap (a,b) = (b,a)  instead of swap x = ((fst x),(snd x))
11:11:05 <maxote> err, /
11:11:06 <Gracenotes> it's intended to mean "is a component of"
11:11:23 <maxote> swap x = ((snd x),(fst x))
11:11:25 <mmorrow> @type flip (uncurry (,))
11:11:27 <lambdabot>     Couldn't match expected type `b -> c'
11:11:27 <lambdabot>            against inferred type `(a, b1)'
11:11:27 <lambdabot>     In the first argument of `flip', namely `(uncurry (,))'
11:11:34 <glguy> edwardk_: I'm going to be excited if you brought Oleg's Iterees stuff into something packaged and useable :-)
11:11:37 <mmorrow> @type uncurry (flip (,))
11:11:38 <lambdabot> forall b a. (a, b) -> (b, a)
11:11:58 <aavogt> @hoogle [Either a b] -> ([a],[b])
11:11:58 <lambdabot> No results found
11:12:06 <glguy> edwardk_: It appears that you and Iavor are competing for "parsimony"
11:12:13 <Gracenotes> (in some cases, a->b means b is a modified form of a used in other kanji..)
11:12:15 <mmorrow> , 'partitionEithers
11:12:16 <lunabot>  Data.Either.partitionEithers
11:12:18 <edwardk_> glguy: i haven't packaged it yet, because i'm still using it 'behind closed doors' but i did describe the changes needed to make it capable of driving Parsec 3 =)
11:12:37 <dolio> @hoogle lefts
11:12:37 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
11:12:38 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
11:12:38 <sclv> you can always rename it to parsimonious
11:12:38 <edwardk_> glguy: and i figure that much makes them usable
11:12:39 <aavogt> mmorrow: thanks!
11:12:43 <pikhq> :t ((fst,snd) <*>)
11:12:45 <lambdabot> forall a b a1 b1. (Monoid a) => ((a, b) -> a, (a1, b1)) -> ((a, b) -> a, b1)
11:13:03 <edwardk_> glguy: the rest was about wrapping that in a monoid so i can go farther and make incremental/parallel parsers out of them
11:13:04 <Gracenotes> mmorrow: just wondering, since you are more familiar than me, how well do you think dot would scale on a server?
11:13:06 <pikhq> So... Not at all what I thought it would be. Darn.
11:13:55 <Gracenotes> delivering a number of requests per second, for graphs with about 10-15 nodes
11:13:59 <mmorrow> Gracenotes: if you keep the image size of the generated images (or use svg i guess), that'd help
11:14:22 <maxote> how can i write higher-kinded code to remove the GHC's limitation of n=2 (2-tuples only) in curry/uncurry types?
11:14:40 <mmorrow> Gracenotes: as far as scale goes, what kind of scale? (if it was "big", i'd probably use the graphviz C api directly)
11:15:09 <mmorrow> Gracenotes: *..of the generated images small...
11:15:16 <glguy> edwardk_: slide 11 of "A Parsing Trifecta", Did "Return" get renamed to "Done"?
11:15:42 <edwardk_> glguy: er yeah. because i wanted to match Oleg, I spoke to that fact but didn't note it in the slides
11:15:47 <Gracenotes> mm, good point. but, I just realized, the kanji data is mostly static, so that takes care of a large percentage of the graphs.
11:16:02 <edwardk_> to me I find making the return-like constructor 'Return' makes the monad-laws easy to see ;)
11:16:25 <edwardk_> but once you move to Iteratees they contain more than just returns, since you might have an EOF as your stream contents
11:16:48 <Gracenotes> I wonder if there is a good way to represent simple (linear) graph edges with HTML... although it's more of a tangent here. maybe canvas could help.
11:17:04 <Gracenotes> tangent, no pun intended >_>
11:17:22 <edwardk_> interestingly you can use all of that to show that Iteratees are 'ideal monads' (and for that matter so is the monad of partiality) so they have arbitrary ideal monad coproducts
11:17:33 <edwardk_> meaning that they layer nicely
11:17:39 <glguy> edwardk_: Return a (Chunk e) >>= f | null e = k
11:17:41 <glguy> what is k?
11:17:47 * Gracenotes continues coding, anyway
11:17:48 <edwardk_> heh f a
11:17:54 <edwardk_> i apparently missed that on more than one slide
11:21:01 <glguy> edwardk_: how similar is your Buffer to a "rope"?
11:21:27 <edwardk_> glguy: more or less identical
11:21:52 <edwardk_> glguy: most ropes don't bother with the fingertree representation, but it works well here being functional and all
11:22:46 <glguy> That along with a fleshed out string-like interface seems like something that ought to be its own little package
11:22:55 <edwardk_> buffers are ropes which are optimized for appending bytestrings and other buffers and indexing to a char really cheaply
11:23:21 <edwardk_> glguy: except for the fact that i need to use several different monoids depending on how i'm using it ;)
11:23:34 <edwardk_> and i happened to only need to use it for two calls in my entire package ;)
11:24:45 <mreh> i've got some head scratching mathematics here
11:24:55 <mreh> how to impose a speed limit on my asteroid ship
11:25:07 <edwardk_> c
11:25:08 <edwardk_> ;)
11:25:27 <mmorrow> Gracenotes: ahh, twopi is a really nice choice for kanji.dot too
11:25:34 <edwardk_>  299 792 458 m / s -- its not just a good idea, its the law
11:25:39 <c_wraith> just define c = 1 screen/frame, and then apply special relativity.  :)
11:26:03 <Gracenotes> that's the one with circles for really connected nodes?
11:26:26 <mreh> my spaceship is entirely newtonian
11:26:38 <edwardk_> then it shouldn't need a speed limit ;)
11:26:48 <edwardk_> just limit their fuel ;)
11:27:02 <c_wraith> yes.  You have to give up on newtonian physics to apply a speed limit.
11:27:10 <edwardk_> with bounded delta-v you don't have to worry too much
11:27:16 <Gracenotes> mmorrow: that was quick to generate.. looks neat too, following the arrows around
11:27:24 <glguy> You could limit speed by attacking the player with asteroids if they move too fast
11:27:28 <mreh> stop teasing me, it's a game
11:27:58 <edwardk_> mreh: sure, but its dumb physics in games that lead to things like only half of republicans believing in plate tectonics ;)
11:28:03 <c_wraith> You can just scale their delta-v down as they exceed some velocity threshold
11:28:25 <edwardk_> and hell asteroids had open acceleration ;)
11:28:35 <c_wraith> Well.  scale it down in the component that's not normal to the direction of acceleration
11:28:35 <edwardk_> for the most part
11:28:48 <mreh> edwardk_, did it?!
11:28:51 <c_wraith> yes.
11:28:58 <c_wraith> If you didn't hit an asteroid, you could go FAST
11:29:04 <c_wraith> But then you always hit an asteroid.
11:29:17 <glguy> like I said :)
11:29:21 <mreh> hyperspace was infinite velocity i seem to remember, so not that fast
11:29:48 <edwardk_> lol: http://playthisthing.com/relativistic-asteroids
11:29:52 <andrewsw> yeah, for just a few more
11:29:58 <andrewsw> oops, wrong channel
11:30:52 <mreh> Like many games of its time, Asteroids contains several bugs that were mostly the result of the original programmers underestimating the game's popularity or the skill of its players. The maximum possible score in this game is 99,990 points, after which it "rolls over" back to zero. Also, an oversight in the small saucer's programming gave rise to a popular strategy known as "lurking"  because the saucer could only shoot d
11:30:52 <mreh> irectly at the player's position on the screen, the player could "hide" at the opposite end of the screen and shoot across the screen boundary, while remaining relatively safe. This led to experienced players being able to play indefinitely on a single credit.[4] This oversight was addressed in the game's sequel, Asteroids Deluxe, and led to significant changes in the way game developers designed and tested their games in the
11:30:52 <mreh>  future.
11:31:00 <mreh> oops
11:31:30 <glguy> edwardk_: Do you use Codec.Binary.UTF8.Generic.uncons in your Char supply?
11:31:38 <glguy> or did you create your own?
11:31:44 <mreh> those are some pretty large bugs
11:31:46 <edwardk_> glguy: go to the next slide ;)
11:32:04 <glguy> edwardk_: bah :-p
11:34:39 <edwardk_> glguy: the slicing stuff on the next few slides is to drastically increase sharing with the source
11:35:53 <dino-> Do functions like isLeft, isRight :: Either a b -> Bool exist only in my dreams? I can't find them.
11:35:57 <mreh> I love haskell, because it allows me to waste my time more productively
11:36:01 <copumpkin> dino-: Data.Either ?
11:36:05 <copumpkin> @hoogle isLeft
11:36:05 <lambdabot> No results found
11:36:08 <copumpkin> hmm, maybe not
11:36:17 <copumpkin> dino-: chances are there's a better way to do it than going through Bool, anyway ;)
11:36:22 <edwardk_> > let isLeft = either True False in isLeft (Left "hi!")
11:36:24 <lambdabot>   Couldn't match expected type `a -> c'
11:36:29 <edwardk_> er
11:36:40 <edwardk_> > let isLeft = either (const True) (const False) in isLeft (Left "hi")
11:36:42 <lambdabot>   True
11:36:43 <dino-> Well, I've got a list of somethings where one and only one is the correct one..
11:36:46 <andrewsw> I'd love some help.
11:36:54 <dino-> So I packed them as a [Either thing thing]
11:36:59 <dino-> And the Right one is the right one
11:37:02 <edwardk_> either id undefined [Left "Hello
11:37:02 <andrewsw> crap, wrong channel again, sorry folk :(
11:37:04 <copumpkin> > (either `on` const) True False
11:37:05 <lambdabot>   Overlapping instances for GHC.Show.Show
11:37:05 <lambdabot>                              (Data....
11:37:09 <copumpkin> :P
11:37:16 <edwardk_> copumpkin: heh
11:37:20 <copumpkin> > (either `on` const) True False $ isLeft (Left "hi")
11:37:22 <lambdabot>   Not in scope: `isLeft'
11:37:25 <copumpkin> bah :P
11:37:29 <copumpkin> > (either `on` const) True False $ Left "hi"
11:37:31 <lambdabot>   True
11:38:12 <tomh-> what is the recommended way to get ghc 6.10.4 on ubuntu?
11:38:18 <tomh-> (or even better the platform)
11:38:20 <Phyx-> @type on
11:38:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:38:44 <Phyx-> @type on (+) id
11:38:45 <lambdabot> forall a. (Num a) => a -> a -> a
11:38:47 <dino-> Anyway, thanks guys!
11:38:51 <Phyx-> @type on (+) id 8 1
11:38:53 <lambdabot> forall a. (Num a) => a
11:38:59 <Phyx-> > on (+) id 8 1
11:39:00 <lambdabot>   9
11:39:06 <copumpkin> Phyx-: people typically write it infix
11:39:27 <Phyx-> copumpkin: i'm trying to figure out it's uses :P
11:39:35 <Phyx-> @hoogle on --info
11:39:36 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:39:36 <lambdabot>  
11:39:36 <lambdabot> (*) `on` f = \x y -> f x * f y.
11:39:47 <Phyx-> ah
11:40:11 <Phyx-> > on (+) (*2) 8 1
11:40:13 <lambdabot>   18
11:40:40 <dino-> I'm learning simple web development for basically the first time ever this past few days, using Network.CGI  The web.. is kind of a pain in the ass.
11:41:02 <c_wraith> The web is horrible.  Wait 'til you get to sophisticated web development, and all the hacks it requires.
11:41:10 <dino-> c_wraith: nooo!
11:41:25 <Rotaerk> just encapsulate the hacks and pretend they're not there
11:41:45 <tomh-> or use something like GWT with a haskell backend
11:41:50 <c_wraith> The hard part is discovering the hacks
11:41:59 <dino-> I want to stay like craig's. Party with the web like it's 1996
11:42:13 <c_wraith> "X doesn't work on that browser?  Why not?  Oh, god, this is going to be a headache"
11:43:14 <Cale> I think it stems from the fact that most programmers with good taste can't stand to do very much web development. So most of the web-related stuff is done by people who don't really know how to program very well.
11:43:16 <c_wraith> I've used GWT.  It can only do so much.  One thing it's useless for is dealing with broken CSS engines.  At some point, we gave up on opera, because it just doesn't render things the same way as any other browser.
11:43:51 <c_wraith> Also, if one of your mandatory targets is IE6, you will be in pain.  Often.
11:44:01 <Rotaerk> I'm employed to do web development in asp.net
11:44:16 <Rotaerk> it's not bad
11:44:37 <Rotaerk> never tried haskell driven web dev though
11:44:40 <pikhq> c_wraith: I suspect it would be easiest to implement a proper HTML renderer in Javascript.
11:44:54 <c_wraith> Not on IE6. :)
11:45:15 <Rotaerk> well you get information about the browser being used, in the web request, I believe
11:45:34 <c_wraith> If you use that, you're setting yourself up for failure.
11:45:38 <Rotaerk> in the server side code, you could in theory, output different html dependent on the browser
11:45:49 <Cale> I think Haskell could be a good language in which to write the libraries to abstract web development enough to make it tolerable :)
11:45:59 <Rotaerk> never done that before, but it doesn't seem like a bad idea
11:46:08 <mauke> Rotaerk: don't believe anything the browser tells you
11:46:38 <Rotaerk> if they make the browser give me false information, and the webpage renders funky for them, it's their fault.
11:46:44 <Rotaerk> not my problem
11:46:46 <pikhq> c_wraith: Well, IE6 Javascript does at least have lambda.
11:46:53 <pikhq> You can define everything you need from that.
11:46:57 <pikhq> ;)
11:47:23 <c_wraith> Many people have *no* clue what their web browser is doing.  It's entirely your fault the page is broken, regardless of what plugins they've added or settings they've twiddled.
11:47:25 <mauke> pop quiz: how many browsers claim to be "mozilla"?
11:47:31 <c_wraith> all of them
11:48:22 <c_wraith> And if a page is broken, especially if it's the user's own fault, they will do everything they can to make you miserable.
11:48:22 <dino-> Cale: I think it would too. There are so many web dev frameworks out there and apparently so much trouble with many of them.
11:48:50 <c_wraith> In the end, it's better to not let users shoot themselves in the foot.
11:49:18 <djahandarie> Trying to do anything too functional fancy with Javascript usually doesn't end up well.
11:49:20 <jcreigh> mauke: virtually all of them.
11:49:22 <c_wraith> (to the extent possible.  users can always find new and exciting ways to shoot themselves in both feet and blame you for it)
11:49:47 <Rotaerk> hrm, IE doesn't claim to be mozilla
11:49:51 <dino-> I suspect already that I'm going to have a deep hatred for the Back button with this thing I'm working on.
11:49:59 <pikhq> Rotaerk: It claims to be Mozilla.
11:50:03 <c_wraith> yes, the back button is evil.  find the hacks to work around it!
11:50:07 <mauke> Rotaerk: of course it does
11:50:26 <Rotaerk> nope, I'm getting Request.Browser.Browser = "IE" in ASP.NET
11:50:41 <Rotaerk> so it has to be able to make the distinction in order to determine that
11:50:42 <mauke> that doesn't look like a valid User-Agent header
11:50:53 <pikhq> That's because ASP is doing heuristics on the User-Agent.
11:50:55 <jfoutz> Rotaerk: For historical reasons, Internet Explorer identifies itself as a Mozilla 4.0 browser.
11:50:59 <pikhq> Not returning the user agent.
11:51:04 <Rotaerk> jfoutz, I'm aware
11:51:07 <jfoutz> Rotaerk: from http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
11:51:29 <c_wraith> Every browser says it's mozilla.  Most of them lie.
11:51:30 <Rotaerk> it doesn't matter what the browser *claims*, you can still determine which browser it is based on the info it does give you
11:51:40 <Rotaerk> (apparently)
11:51:46 <pikhq> Yes, but we were saying that it claims to be Mozilla.
11:51:49 <jfoutz> Rotaerk: oh. i see.
11:52:05 <c_wraith> Or, you can just find hacks that render properly in every browser (except opera).  They exist.  But they're real pain.
11:52:11 <Rotaerk> pikhq, but that's irrelevant to the fact that you can still generate HTML dependent on the browser
11:52:21 <Rotaerk> since there *is* a way to determine which browser it is
11:52:33 <pikhq> Rotaerk: And *that's* irrelevant to what we were talking about.
11:52:50 <Cale> Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2.0.50727)
11:52:57 <Rotaerk> pikhq, howso?
11:53:00 <Cale> (pulled from my server log)
11:53:05 <pikhq> 13:47 < mauke> pop quiz: how many browsers claim to be "mozilla"?
11:53:31 <Cale> It does end up telling you that it's IE, but only in the midst of lying that it's Mozilla :)
11:55:48 <pikhq> Incidentally, Opera does not lie.
11:56:08 <mauke> didn't Opera used to claim it was IE?
11:56:26 <jmcarthur> you can make opera claim whatever you want
11:56:34 <jmcarthur> it's like a right click or two away
11:56:36 <mauke> I mean default settings
11:56:38 <pikhq> mauke: Once upon a time.
11:56:46 <jmcarthur> oh i didn't know that
11:56:49 <dino-> Well, some people have fucking work to do.
11:56:51 <pikhq> Now it claims to be "Opera 9.0 (OS info here)"
11:56:56 <Makoryu> Hey, what's the nicest HTTP DSL you guys have seen?
11:57:03 <dino-> ha, sorry, mischannel
11:57:03 <jmcarthur> dino-: porn industry?
11:57:04 <QP> I'm having a problem with haddock... can someone help?
11:57:12 <dino-> That was for the grumpy-hate-my-job channel
11:57:13 <idnar> heh
11:57:20 * mauke stares at QP 
11:57:32 <QP> it says "the following names cannot be resolved:"
11:57:47 <lysgaard_> what's the simplest way to get a seed for getStdGen? Id like to use time, but then I'd need atleast millisecond granulation
11:57:49 <QP> and then a list of really common things like Int, State, etc.
11:58:13 <jmcarthur> lysgaard_: the simplest is mkStdGen ;)
11:58:17 <QP> and also my friend keeps fish slapping me...
11:58:18 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8363#a8363 -- user agent strings from my server log if anyone's interested :)
11:58:26 <mauke> lysgaard_: huh?
11:58:50 <Cale> (just the most recent one, I didn't bother to decompress all the old ones)
11:59:00 <jmcarthur> lysgaard_: you shouldn't ever have to get more than one seed in one run of the program, IMO
11:59:40 <QP> the StdGen type is designed to be reusable :-)
12:00:22 <lysgaard_> jmcarthur: Hehe, my problems is that i will have thousands of instances running at the same time, started and shut down asyncrounsly, and none of them should contain the same generator.
12:00:38 <jmcarthur> lysgaard_: time+pid?
12:01:03 <lysgaard_> jmcarthur: Good idea, how do i get my pid :S
12:01:25 <jmcarthur> somewhere hidden in the System stuff. i dunno off the top of my head
12:01:35 <lysgaard_> jmcarthur: I'll go digging
12:02:49 <jfoutz> System.Posix.Process.getProcessID
12:02:53 <lysgaard_> @hoogle pid
12:02:53 <lambdabot> System.Posix.Internals c_getpid :: IO CPid
12:02:54 <lambdabot> System.Posix.Types data CPid
12:02:54 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
12:03:03 <tomh-> anyone had seen this bug before when installing haskell platform: make: *** [build.stamp] Error 2 for the  happy package?
12:05:09 <QP> can anyone explain why haddock is complaining about me using "Int", "IO", "Show", "Eq" and such in my source code?
12:07:30 <dino-> QP: That does sound really strange.
12:07:35 <maxote> nuncurry exchangeMoney ColoredBills(3,5,2) should return ColoredBills(3,1,3) where ColoredBills(green: units*$10,red: units*$50,blue: units*$200) ;   type exchangeMoney = symbol -> Int green -> Int red -> Int blue -> b  where  b = ColoredBills(Int green,Int red,Int blue) ;
12:09:44 <QP> I think it is sorted actually
12:10:17 <QP> the error wasn't really an error
12:11:51 <paolino> QP, probably it cannot hyperlink those names to the std docs, or something like
12:12:51 <dino-> Ah, so you did get docs for your stuff. Not failed.
12:13:27 <paolino> need to pass it an url to them on the command line iirc
12:13:52 <QP> well, I have now---i was missing the -h tag, and thought it hadn't worked because of this 'error'
12:13:52 <maxote> exchangeMoney ColoredBills greenunits redunits blueunits = let total = greenunits*10 + redunits*50 + blueunits*200 in let bluetotal = total `div` 200 in let nonbluetotal = total `mod` 200 let redtotal = nonbluetotal `div` 50 in let greentotal = nonbluetotal `mod` 50 in ColoredBills(greentotal,redtotal,bluetotal) ;  eureka!
12:14:00 <QP> it's worked now
12:14:29 <tomh-> anyone knows what causes this: Configuring the happy-1.18.4 package failed ?
12:15:00 <doublethink_work> tomh-: run cabal with -v to get verbose output?
12:15:07 <doublethink_work> tomh-: you may be missing a necessary executable or something
12:15:11 <tomh-> its with the platform
12:15:19 <tomh-> haskell platform
12:15:19 <doublethink_work> oh :(
12:15:21 <Lenny222> i am struggling to xor a Word16 with a Word8. can anyone give me a hint?
12:15:35 <maxote> if the optimize nuncurrifies all the code then it can inline massively the code, lol.
12:15:40 <Lenny222> shiftL (fromIntegral (xor x w1) :: Word16) 8) .|.  (xor x w2)
12:15:43 <Lenny222> does not work :(
12:15:52 <mauke> Lenny222: convert the Word8 to Word16 first
12:15:55 <maxote>  /optimize/optimizer/
12:15:59 <mauke> wait, what
12:16:51 <Lenny222> make: i tried, but it does not work in one line of code
12:16:58 <Lenny222> mauke that is
12:17:24 <Lenny222> wait, maybe i am thinking to complicated
12:17:30 <mauke> what are the types of x, w1 and w2?
12:18:24 <Lenny222> x is the Word8, w1, w1 are Word8 too. i tried to read the word16 in two pieces
12:18:38 <Lenny222> and then apply xor separately
12:19:05 <Lenny222> and glue them bacl together using a shift and or
12:19:38 <Lenny222> the code lives within a Get monad
12:19:53 <Lenny222> i could either read a Word16 or two Word8. i tried the latter
12:19:54 <mauke> (fromIntegral (x `xor` w1) `shiftL` 8) .|. fromIntegral (x `xor` w2) :: Word16
12:21:28 <lysgaard_> @hoogle String -> hostAddress
12:21:28 <lambdabot> Prelude error :: String -> a
12:21:28 <lambdabot> Debug.Trace trace :: String -> a -> a
12:21:28 <lambdabot> Distribution.ReadE readEOrFail :: ReadE a -> String -> a
12:21:48 <Lenny222> mauke: thanks, trying...
12:22:41 <maxote> it's possible to generate code zero tupleness.
12:23:08 <Lenny222> compiles, being Haskell code that means, it works too )
12:23:13 <Lenny222> :)
12:23:39 <Phyx-> > dataTypeOf ()
12:23:40 <lambdabot>   DataType {tycon = "Prelude.()", datarep = AlgRep [()]}
12:23:55 <lysgaard_> @hoogle Word8 -> Word8 -> Word8 -> Word8 -> Word32
12:23:55 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
12:23:55 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
12:23:55 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
12:24:10 <Phyx-> > dataTypeOf _|_
12:24:12 <lambdabot>   <no location info>: parse error on input `|'
12:24:24 <maxote> converting every named and anon tuples to higher order functions only of the form   symbolOfTuple -> a1 -> a2 -> .. -> an
12:24:37 <jkff> :t dataTypeOf
12:24:38 <lambdabot> forall a. (Data a) => a -> DataType
12:24:43 <Phyx-> > isBottom undefined
12:24:44 <lambdabot>   Not in scope: `isBottom'
12:24:45 <jkff> > dataTypeOf undefined
12:24:46 <lambdabot>   Add a type signature
12:24:54 <lysgaard_> Is it possible to concat 4 Word8 into one Word32?
12:25:01 <Phyx-> > dataTypeOf undefined :: Int
12:25:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:25:06 <jkff> lysgaard_: Yes, use Data.Bits
12:25:11 <Phyx-> > dataTypeOf (undefined :: Int)
12:25:12 <lambdabot>   DataType {tycon = "Prelude.Int", datarep = IntRep}
12:25:14 <copumpkin> lysgaard: you need to manually shift them
12:25:30 <Phyx-> i always found this one confusing
12:25:35 <Phyx-> > dataTypeOf (undefined :: Char)
12:25:36 <lambdabot>   DataType {tycon = "Prelude.Char", datarep = StringRep}
12:25:44 <jkff> :t datarep
12:25:45 <lambdabot> Not in scope: `datarep'
12:26:41 <copumpkin> Phyx-: why?
12:26:44 <lysgaard_> jkff: How, i only see xor, and shiftl etc, no concatlike function
12:26:55 <deech> Is there a rule in Haskell that all if statement must have an else?
12:26:57 <copumpkin> > dataTypeOf (undefined :: [String])
12:26:58 <lambdabot>   DataType {tycon = "Prelude.[]", datarep = AlgRep [[],(:)]}
12:27:04 <copumpkin> deech: yes, because everything is an expression
12:27:05 <jkff> lysgaard_: xor, shiftl etc. are just enough to build a concatlike function yourself :)
12:27:08 <maxote> and the conversion to tuples only is required to write the final results.
12:27:25 <jkff> deech: yes, because otherwise what would be the value of "if False then 1"?
12:27:42 <Phyx-> copumpkin: that it's dataRep is a StingRep
12:27:46 <raimo_> how can I get local hostname with Network module
12:27:49 <Phyx-> > dataTypeOf (undefined :: String)
12:27:51 <lambdabot>   DataType {tycon = "Prelude.[]", datarep = AlgRep [[],(:)]}
12:27:56 <lysgaard_> jkff: Hm.. True. I'm being spoiled by Prelude
12:28:18 <copumpkin> Phyx-: yeah, it has a couple of primitive representations, and everything else is an ADT and gets AlgRep
12:28:35 <deech> copumpkin, jkff: Hmmm ... ok how do I represent a no-op other that to use 'undefined'?
12:28:39 <tomh-> anyone know how this is possible: unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'
12:28:41 <raimo_> do I have to lower down to Network.Socket to connect with socket to get the local hostname
12:28:46 <copumpkin> deech: you're doing it wrong :P
12:28:49 <jkff> deech: What do you mean, 'no-op'?
12:28:59 <copumpkin> deech: are you in IO or a monad of some sort?
12:29:10 <Phyx-> copumpkin: that i know, however, i sould have though "CharRep" would have been a bettr name
12:29:48 <copumpkin> deech: if you are, you can use the when and unless functions
12:29:57 <deech> So something like 'if (something is not null) then (some action)' implying that 'if (something is null) (skip it)'
12:29:58 <copumpkin> deech: if you aren't, the concept of a no-op makes no sense
12:30:10 <copumpkin> ah, you're talking about actions, so
12:30:12 <copumpkin> :t when
12:30:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:30:26 <maxote> my objetive is simple: functions everywhere, arrows everywhere, algebraic transformations everywhere.
12:30:39 <deech> in this case action is sticking something in a map.
12:30:51 <copumpkin> deech: then your no-op is returning the map unchanged
12:30:58 <jkff> in a what kind of map?
12:30:59 <copumpkin> since sticking something into it is returning a new map, not changing the existing one
12:31:07 <jkff> You can't stick anything in a Data.Map, for example
12:31:25 <jkff> However, if you're talking about Data.Hashtable, then you're in the IO monad
12:31:31 <copumpkin> ah yeah
12:31:37 <deech> jfkk : using a Data.Map.insertWith (++) I can mutate the map.
12:31:37 <copumpkin> (but don't use that, it's slow and ugly)
12:31:41 <copumpkin> deech: no you can't
12:31:50 <copumpkin> deech: you get a new map back
12:31:54 <jkff> :t Data.Map.insertWith (++)
12:31:55 <lambdabot> forall a k. (Ord k) => k -> [a] -> M.Map k [a] -> M.Map k [a]
12:32:10 <copumpkin> deech: you can't mutate anything unless you're in IO or ST
12:32:17 <jkff> See, it returns a new map
12:32:36 <jkff> That differs from the old one by insertingWith(++) the given element
12:32:58 <deech> right, that's what I meant. That insertWith will transform a value referred to by a certain key.
12:33:10 <copumpkin> yeah, so the no-op transformation is simply the identity function
12:33:10 <wuncidunci> /quit/
12:33:31 <copumpkin> if x then insertWith (++) blah myMap else myMap
12:33:53 <jkff> let newMap = if x then insertWith (++) blah myMap else myMap
12:34:29 <mxc> am I misunderstanding somehting here:  http://www.mail-archive.com/haskell-cafe@haskell.org/msg61252.html
12:34:33 <deech> Cool, I guess that forcing an else statement makes things clearer. I just didn't know that was required.
12:34:55 <mxc> is dons saying that modifyIORef, and by extention atomicModifyIORef will always make you leak?
12:34:56 <copumpkin> deech: it's not an aesthetic choice
12:35:20 <deech> copumpkin: I realize that now!
12:35:22 <LeoD> it's more than that deech... somefunc x = if x then 5 -- what is the value of somefunc False?
12:35:23 <copumpkin> :)
12:35:39 <edwardk_> @seen glguy
12:35:40 <lambdabot> glguy is in #haskell. I last heard glguy speak 1h 3m 34s ago.
12:36:25 <jkff> LeoD: It could be an "error: non-exhaustive patterns" like in the case with "somefunc x | x = 5"
12:36:36 <LeoD> true
12:37:22 <QP> i'm using darcs for the first time---to upgrade my version of haddock---and i'm not sure it has worked
12:37:37 <QP> do i have to compile the files after i 'get' them?
12:38:13 <maxote> SRC: source code w/ (named & anon) tuples, lists and higher order functions.
12:38:13 <maxote> INTERM: optimized target code w/ lists and higher order functions.
12:38:14 <maxote> DST: more aditional code as above w/ tuples for writing the results.
12:38:14 <maxote> SRC -> INTERM -> DST
12:40:37 <path[l]> hi could someone help me understand why my code doesnt do what I think it should?
12:40:38 <path[l]> http://phyx.pastebin.com/m35906fb9
12:40:49 <Phyx-> lol
12:40:52 <path[l]> I have a comment there explaining what I expect
12:40:53 <path[l]> :/
12:40:55 <Phyx-> used my pastebin address
12:41:00 <path[l]> lol
12:41:05 <tomh-> anyone here who knows who might be able to help me with installing haskell platform?
12:41:34 <dqd> Just tell us about your problem.
12:41:40 <tomh-> i did
12:41:47 <dqd> Oh.
12:41:54 <Saizan_> path[l]: what are you getting instead?
12:42:05 <path[l]> fromList [("A","B"),("B","A"),("C","D"),("D","C")]
12:42:09 <path[l]> is the output I got
12:42:34 <path[l]> for input revLinks [("A","B"),("C","D")]
12:42:57 <Phyx-> path[l]: which is correct
12:42:58 <path[l]> but I expected something like fromList [("A","AB"),("B","AB"),("C","CD"),("D","CD")]
12:43:05 <Heffalump> tomh-: do you have cabal installed?
12:43:07 <mxc> is htere a way to fully force a thunk if the type isn't an instance of NFData?
12:43:09 <path[l]> sorry not revlinks
12:43:29 <Heffalump> or are you just using the generic platform unix tarball?
12:43:44 <tomh-> im using the generic linux tarball
12:43:49 <tomh-> but i got cabal installed somewhere
12:43:52 <Phyx-> path[l]: which then?
12:43:58 <path[l]> the input was charHash ("A","B"),("C","D")]
12:44:08 <Heffalump> do you get some actual error before it reports as failing to configure?
12:44:26 <path[l]> so I expected it to give me fromList [("A","AB"),("B","AB"),("C","CD"),("D","CD")] I guess
12:44:47 <maxote> ( tuples, lists & hofuns ) --> looping almost time ( lists & hofuns ) --> writing results ( tuples, lists & hofuns ) --> sometimes go to looping --> sucess exit.
12:44:53 <nlogax> hmm, trying to install cabal on a vps with limited memory, ghc --make Setup fails because of that. any secret tricks that might help a noob out?
12:44:54 <Saizan_> ?type Data.Map.fromListWithKey
12:44:56 <lambdabot> forall k a. (Ord k) => (k -> a -> a -> a) -> [(k, a)] -> M.Map k a
12:45:17 <tomh-> heffalump: http://mibbit.com/pb/ZXWUtq
12:45:22 <paolino> mxc: I think NFData is the only way
12:45:28 <maxote> i assume that i'm ignoring the monads.
12:45:32 <Saizan_> path[l]: are you sure you've pasted the correct code, that definition of charHash doen't look like it typechecks
12:45:59 <path[l]> oh shit I didnt paste the modified code
12:46:01 <path[l]> ok one sec
12:46:16 <Phyx-> ?type Data.Map.fromListWithKey ((\a b c->a++b++c))
12:46:16 <Baughn> Are any of you by any chance familiar with epidemic protocols? Specifically, probability functions as to the spread time?
12:46:18 <lambdabot> forall a. (Ord a) => [([a], [a])] -> M.Map [a] [a]
12:46:37 <path[l]> http://phyx.pastebin.com/m7ae36c56
12:46:43 <Phyx-> ?type Data.Map.fromListWithKey ((\a b c->a++b++c)) [("A","B"),("B","A")]
12:46:44 <Saizan_> > M.fromListWithKey ((\a b c->a++b++c)) [("A","B"),("C","D")]
12:46:45 <lambdabot> M.Map [Char] [Char]
12:46:46 <lambdabot>   fromList [("A","B"),("C","D")]
12:46:52 <Heffalump> tomh-: hmm. I don't understand that. What version of ghc is /usr/local/bin/ghc ?
12:46:55 <Phyx-> > Data.Map.fromListWithKey ((\a b c->a++b++c)) [("A","B"),("B","A")]
12:46:57 <lambdabot>   Not in scope: `Data.Map.fromListWithKey'
12:47:06 <tomh-> heffalump 6.10.4
12:47:07 <mxc> paolino > not what I wanted to hear, but thanks
12:47:14 <Phyx-> > M.fromListWithKey ((\a b c->a++b++c)) [("A","B"),("B","A")]
12:47:15 <lambdabot>   fromList [("A","B"),("B","A")]
12:47:56 <Saizan_> path[l]: there are no duplicates in [("A","B"),("B","A")] so the combining function is never used
12:48:09 <Phyx-> @hoogle fromListWithKey --info
12:48:09 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
12:48:09 <lambdabot>  
12:48:09 <lambdabot> O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'.
12:48:10 <path[l]> but for the first time
12:48:16 <path[l]> shouldnt it use the key ?
12:48:21 <path[l]> key + item
12:48:25 <path[l]> + nil
12:48:25 <Phyx-> > M.fromListWithKey ((\a b c->a++b++c)) [("A","B"),("A","A")]
12:48:26 <path[l]> or something
12:48:27 <lambdabot>   fromList [("A","AAB")]
12:48:27 <Saizan_> ?let revLinks = concatMap (\pair -> [pair, swap pair])
12:48:28 <lambdabot>  <local>:9:38: Not in scope: `swap'
12:48:44 <Saizan_> ?let revLinks = concatMap (\pair -> [pair, (snd &&& fst) pair])
12:48:47 <lambdabot>  Defined.
12:48:49 <Phyx-> path[l]: as Saizan_ mentioned, the keys are never duplicate
12:48:53 <path[l]> hmm
12:49:00 <path[l]> oh well, that explains it :/
12:49:01 <Saizan_> > M.fromListWithKey ((\a b c->a++b++c)) (revLinks [("A","B"),("C","D")])
12:49:04 <path[l]> thanks
12:49:05 <lambdabot>   fromList [("A","B"),("B","A"),("C","D"),("D","C")]
12:49:16 <path[l]> ((\a b c->a++b++c)) <--- btw why 2 nested brackets?
12:49:37 <Saizan_> path[l]: no, the combining function takes 2 'a', so there needs to be 2 of them :)
12:49:40 <Phyx-> path[l]: you don't
12:49:57 <Phyx-> > M.fromListWithKey (\a b c->a++b++c) [("A","B"),("A","A")]
12:49:59 <lambdabot>   fromList [("A","AAB")]
12:50:02 <Saizan_> path[l]: no reason for the extra parens
12:50:08 <path[l]> oh ok
12:50:16 <Baughn> Okay. Alternately, is there a nice channel for language-agnostically discussing algorithms?
12:50:35 <raimo_> how do I declare types in ghci?
12:50:35 <Baughn> Mainly network protocols - PAXOS, etc.
12:50:44 <path[l]> thanks
12:50:51 <Baughn> raimo_: You don't, but you can create a scratch.hs and (re)load it as you go
12:51:06 <raimo_> ok
12:51:08 <raimo_> thanks
12:51:10 <tomh-> heffalump: any idea? :(
12:52:44 <paolino> raimo_:http://www.unsafecoerce.com/fastcgi/hpaste.fcgi/raw?id=2087 is a ghci "extension"
12:52:49 <dons> ?pl f x y = - (f x y)
12:52:50 <lambdabot> (line 1, column 7):
12:52:50 <lambdabot> unexpected "="
12:52:50 <lambdabot> expecting variable, "(", operator or end of input
12:52:52 <dons> ?pl let f x y = - (f x y)
12:52:52 <lambdabot> (line 1, column 13):
12:52:53 <lambdabot> unexpected "-"
12:52:53 <lambdabot> expecting lambda abstraction or expression
12:52:54 <dons> ?pl let f x y = - (f x y)  in f
12:52:55 <lambdabot> (line 1, column 13):
12:52:55 <lambdabot> unexpected "-"
12:52:58 <lambdabot> expecting lambda abstraction or expression
12:52:59 <dons> sigh
12:54:51 <mauke> ?pl let f x y = negate (f x y)  in f
12:54:51 <lambdabot> fix ((negate .) .)
12:57:07 <sjanssen> dons: it's not terribly surprising that pl gets unary - wrong
12:57:13 <sjanssen> dumbest syntax evar
12:57:23 <path[l]> :t subsequences
12:57:26 <lambdabot> forall a. [a] -> [[a]]
12:57:31 <path[l]> hmm
12:57:48 <path[l]> any idea why Id get this error -> Not in scope: `subsequences'
12:57:50 <sjanssen> @src subsequences
12:57:51 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:58:02 <sjanssen> path[l]: I think it's in Data.List, and only new versions of that module
12:58:19 <path[l]> ah
12:58:20 <arcatan> i'm going to take some courses in rocket science
12:58:37 <Heffalump> tomh-: no, sorry. dons might?
12:58:42 <arcatan> then i'm going to be like "this is not exactly rocket science.. oh wait!"
12:58:45 <Phyx-> > subsequence [1,2]
12:58:46 <lambdabot>   Not in scope: `subsequence'
12:58:53 <Phyx-> > subsequences [1,2]
12:58:55 <lambdabot>   [[],[1],[2],[1,2]]
12:58:57 <Heffalump> http://mibbit.com/pb/ZXWUtq
12:59:05 <Saizan_> tomh-: try commenting out line 82 in scripts/build.sh
12:59:43 <tomh-> ok, im trying one more thing myself then i try that thanks
13:00:25 <path[l]> how can I see the apis supported in ghci 6.6.1
13:01:50 <tommd> Fe-fi-fo-fum, I smell the blood of a OO programmer.
13:02:38 <djahandarie> It'd be cool if libnotify had a Haskell binding
13:03:01 <Nafai> djahandarie: Well, depending on how mature the d-bus bindings are, you could just use the d-bus interface to libnotify
13:03:07 <Nafai> djahandarie: But I agree, that would be useful
13:04:33 <tomh-> Saizan_: thanks, it worked if i commented out that particular section
13:05:47 <dino-> path[l]: You should be able to see what libraries are registered with $ ghc-pkg list
13:06:03 <path[l]> a
13:06:36 <Saizan_> tomh-: though i'm not sure when that section is triggered.. you're not in a clean tree, right?
13:06:43 <path[l]> hmm
13:07:19 <tomh-> just installed all required ubuntu stuff
13:07:30 <tomh-> now i got a new error
13:07:37 <tomh-> http://mibbit.com/pb/Vcksxt
13:08:15 <tomh-> funny, because installing that by hand works properly
13:08:38 <Saizan_> it picks different versions for the dependencies, evidently
13:09:20 <sjanssen> path[l]: http://www.haskell.org/ghc/docs/6.6.1/html/libraries/index.html
13:09:42 <sjanssen> path[l]: 6.6.1 is rather old by the way, you might consider upgrading if you're doing serious Haskell work
13:09:45 <tomh-> Saizan_: any idea how i can resolve?
13:10:30 <tomh-> i think its because i manually installed http 4000.8
13:10:36 <tomh-> and it looks for 4000.6
13:11:13 <Saizan_> that might be it
13:11:23 <tomh-> how can i remove it?
13:11:51 <Saizan_> tomh-: ghc-pkg unregister
13:12:37 <tomh-> ok thanks
13:12:42 <artagnon> Can I get a hint on how to improve this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8368#a8368
13:12:51 <artagnon> It works fine, but looks VERY ugly
13:13:23 <artagnon> bascially I wanted to find the number of ways to create 2 pounds using certain given denominations of pennies.
13:13:43 <path[l]> ssjansen : unfortunately its for a code submission on another site, which only seems to support 6.6.1
13:14:10 <path[l]> now I need to figure out how to implement subsequences by myself lol
13:14:25 <path[l]> thanks for the docs though
13:14:32 <artagnon> I can think of an iterative solution which involves passing variables from one loop to another, but I need some help to think this through in Haskell.
13:14:47 <Heffalump> artagnon: abstract out the behaviour of each stage of the list comprehension into a function
13:14:48 <EvilTerran> artagnon, i'd suggest generalising it to take a (sorted) list of denominations
13:15:00 * sjanssen is slower than Heffalump and EvilTerran 
13:15:29 <path[l]> lol 6.6.1 is so old, there is no binary for mas oc 10.5 >.<
13:15:42 <artagnon> Heffalump: Right, I'll try that out first.
13:15:57 <artagnon> EvilTerran: Yeah, that IS my final objective. But how do I go about doing it?
13:16:13 <Heffalump> you'll need to switch from a tuple to a list of results, too (which is roughly what EvilTerran suggests)
13:16:21 <Phyx-> path[l]: source is at http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#subsequences
13:16:23 <Saizan_> tomh-: did you install cabal-install manually from the packages/ directory before running make? otherwise i'm not sure how the --with-cabal-install error might be triggered
13:16:26 <artagnon> Heffalump: the file will still contain the same number of lines then, just a function after the <- instead of an ugly Texas Range.
13:16:38 <EvilTerran> artagnon, well, can you reason about it recursively?
13:16:39 <path[l]> ooh thanks phyx
13:16:48 <Heffalump> artagnon: sort of, in the end there should just be one function that gets called recursively
13:16:48 <tomh-> Saizan_: i downloaded it from the website and installed it yeah
13:17:11 <Heffalump> I meant abstract out the operation of each stage of the list comprehension, not just the bit on the right hand side of <-
13:17:19 <EvilTerran> ie, given a set of parameters for your change-making function, can you work out how to express the result in terms of structurally smaller parameters?
13:17:26 <Saizan_> tomh-: using the directory inside the haskell-platform tarball or another?
13:17:30 <artagnon> EvilTerran && Heffalump: Oh damn. No, but I'll try simplifying it stage by stage until I "get" the recursion.
13:17:43 <EvilTerran> if you can do that, and a base case, then you can just write the inductive "maths-y" definition pretty directly in haskell
13:17:53 <Heffalump> artagnon: a good first step would be to abstract out the list of coins into a parameter
13:17:57 <Heffalump> then switch from tuples to lists
13:18:05 <Heffalump> then see if you can decompose it
13:18:14 <tomh-> Saizan_:  from haskell.org/cabal
13:18:15 <artagnon> Heffalump: The result? How does it matter?
13:18:21 <artagnon> I'm only counting the length of the result.
13:18:44 <Phyx-> path[l]: for reference, every haddock page/function on haskell.org has a "source" button :P (or most do)
13:19:03 <EvilTerran> artagnon, the result could probably just be (), really; it just can't be a tuple of numbers of each coin if you've got a variable number of coins, as tuples are fixed-length
13:19:04 <path[l]> hehe ok
13:19:09 <path[l]> I llike it
13:20:09 <Saizan_> tomh-: then i don't see why you had a binary at packages/cabal-install-0.6.2/dist/build/cabal/cabal at that point
13:20:11 <artagnon> EvilTerran: Right, got it. The recursive function has to use the result from the previous recursion.
13:20:33 <artagnon> EvilTerran: Which means I have to pass something sensible to the next stage of recursion. Some useful information.
13:20:44 <tomh-> Saizan_: yeah me neither :)
13:21:06 <artagnon> Heffalump && EvilTerran: Thanks for your wonderful hints! I'll get back when I have some better code.
13:21:33 <artagnon> Oh, it's 2 am. I might not be awake to thank you after completing it. So thanks in advance :)
13:21:48 <Heffalump> :-)
13:22:00 <EvilTerran> no worries :)
13:22:29 <path[l]> its foldr that can work on infinite lists right?
13:22:37 <Heffalump> actually, it could be done with nested tuples, but perhaps polymorphic recursion is a bit advanced for now.
13:23:17 <EvilTerran> Heffalump, and there's really no need, altho there'd be something satisfying about encoding the fact that the list of denominations and the lists of coin counts in the result are the same length
13:23:43 <EvilTerran> path[l], yes. are you interested in an intuitive explanation as to why that's the case?
13:23:57 <path[l]> yes please
13:24:13 <path[l]> it makes sense to me that you're folding right, so you know where to start
13:24:20 <path[l]> whereas foldl starts at infinity
13:24:26 <path[l]> but not more than that
13:24:31 <Heffalump> EvilTerran: rght.
13:25:17 <EvilTerran> ?src foldr
13:25:18 <lambdabot> foldr f z []     = z
13:25:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:25:21 <EvilTerran> ?src foldl
13:25:21 <lambdabot> foldl f z []     = z
13:25:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:25:48 <EvilTerran> path[l], in the source of foldr, you can see that the recursive call to "f" is taking the recursive call to "foldr" as a parameter
13:25:54 <EvilTerran> and vice-versa in the source of foldl
13:26:25 <path[l]> hmm
13:27:12 <path[l]> yeah I see
13:27:33 <EvilTerran> to briefly conflate non-strict semantics with outermost-first evaluation, this means that, in foldr, that call to "f" can start being evaluated before recursion need be evaluated at all
13:28:02 <EvilTerran> while, in foldl, the recursive call to foldl is outermost, so will be evaluated first
13:28:25 <path[l]> yeah
13:28:28 <EvilTerran> and the same applies for the recursive call to foldl within that one, and so on, until you get to the end of the list
13:29:16 <path[l]> I get it :)
13:30:02 <EvilTerran> path[l], while the evaluation order isn't strictly fixed by the haskell report, that's the order the main compilers evaluate things in, anyway
13:30:08 <Saizan> tomh-: did you use make -jN where N > 1?
13:30:15 <path[l]> hmm
13:30:33 <EvilTerran> lazy (ie outermost-first) evaluation being the obvious implementation of non-strict semantics
13:31:06 <EvilTerran> i believe the authors wanted to leave room for implicit parallelism, heuristic evaluation, etc
13:32:33 <path[l]> ah
13:32:44 <jpcooper> does anyone know of a guide outlining exceptional circumstances in Network's sockets such as the other end closing a connection
13:32:47 <jpcooper> +?
13:33:54 <EvilTerran> path[l], but a standards-compliant implementation will evaluate in a way that's semantically indistinguishable from lazy evaluation anyway, so lazy evaluation makes a perfectly good mental model
13:34:20 <path[l]> ah ok, a bit of that went over my head, but I kinda get it ;)
13:35:00 <EvilTerran> "any haskell implementation will look like it's evaluating lazily to the haskell it's running, even if it's actually doing something else"
13:35:56 <tomh-> Saizan: no
13:44:17 <mxc> so, to turn on profiling, i need to rebuild all the dependent libraries with -prof.. will that slow down code then compile later w/out the prof flag?
13:44:28 <mxc> or does ghc essentially create two libraries?
13:46:07 <Nafai> mxc: It compiles 2 libraries.
13:46:46 <mxc> ty
13:46:56 <Nafai> And then links to the appropriate one when you have profiling on or off
13:48:56 <tomh-> Saizan: The mtl-1.1.0.2/Setup script does not exist or cannot be run < any idea?
13:50:11 <artagnon> damn, I'm thinking in terms of a for loop AGAIN! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8369#a8369 -- a <- currentRange to call the function recursively that many times.
13:50:53 <Saizan> tomh-: make clean ? :)
13:51:37 <artagnon> EvilTerran && Heffalump: I got this far. I'm sure I can finish it off with a bit of thought, but I need a hint to do it fast. I often get stuck in this situation. for loop :(
13:52:06 <tomh-> lemme try
13:52:57 <artagnon> sorry, I made a mistake
13:52:59 <artagnon> that's first, not head.
13:53:23 <artagnon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8369#a8370
13:54:40 <c_wraith> yet another dynamic programming problem in project euler. :)
13:55:00 <artagnon> *nod*
13:55:03 <artagnon> PE is quite awesome
13:55:12 <c_wraith> have you seen this page?  http://www.haskell.org/haskellwiki/Dynamic_programming_example
13:55:23 <artagnon> No.
13:55:24 * artagnon looks
13:57:21 <theunixgeek> What's the Dutch channel?
13:58:21 <artagnon> I guess I could always write that as [a:.. | a <- [0..]] and finally flatten the resulting list
13:58:25 <artagnon> would be really ugly though
13:58:43 <edwardk_> theunixgeek: dunno, but if you're willing to make up half the name someone will probably go Dutch with you on it.
13:58:47 <mauke> I don't know what you're doing, but flattening can be done in a list comprehension
13:59:03 <artagnon> mauke: hmm?
13:59:06 <artagnon> could you elaborate?
13:59:31 <dschoepe> theunixgeek: #haskell.dut
13:59:36 <mauke> > [y | x <- ["foo", "bar", "baz"], y <- x]
13:59:37 <c_wraith> artagnon, that first example on the page I linked to is actually very close to the problem you're trying to solve.
13:59:38 <theunixgeek> dschoepe: thanks
13:59:38 <artagnon> mauke: see the code. I'm trying to call that list line with a: ... for a <- currentRange
13:59:38 <lambdabot>   "foobarbaz"
14:00:06 <c_wraith> Except you want a count, rather than a boolean.
14:00:15 <artagnon> c_wraith: Right, just saw it.
14:01:39 <LeoD> hm, wasn't there a function doing x `mod` y == 0 predefined somewhere?
14:01:54 <tomh-> Saizan: didnt work, it seems it can't handle packages already installed, so had to remove a bunch of packages from packages.list
14:02:01 <tomh-> i mean platform.packages
14:02:07 <artagnon> LeoD: hm...? mod is defined in Prelude
14:02:25 <dschoepe> @hoogle Integral a => a -> a -> Bool
14:02:26 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
14:02:26 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
14:02:26 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
14:02:29 <LeoD> hm
14:03:43 <artagnon> c_wraith: He's using ||!
14:04:07 <c_wraith> That's because he's working with booleans.
14:04:13 <c_wraith> You'd replace those with +
14:04:14 <c_wraith> :)
14:04:24 <Apocalisp> Do you ever find that you want Either3 and Either4?
14:04:53 <Saizan> tomh-: ah, so that they don't get installed by the platform?
14:05:12 <copumpkin> Left a | MiddleLeft b | MiddleRight c | Right c ?
14:05:14 <copumpkin> Left a | Up b | Down c | Right d
14:05:45 <artagnon> c_wraith: Right, thanks for that! I'll be off to finish off euler31 now.
14:05:49 <c_wraith> wait, we're playing ddr now? :)
14:06:26 <tomh-> Saizan: yeah, so it cant find a bunch of files which were supposed to be generated i guess
14:06:55 <copumpkin> Apocalisp: I don't actually use Either much, the constructor names feel too generic and I don't like its instances
14:08:14 <Apocalisp> copumpkin: I suppose it's a cheap substitute for pattern matching, now that I think about it.
14:08:43 <edwardk_> copumpkin: the Monad makes me feel dirty
14:08:52 <copumpkin> yeah, same here
14:09:39 <Apocalisp> copumpkin: Was it you who was in here the other day talking about comonad comprehensions?
14:10:23 <copumpkin> Apocalisp: don't think so
14:10:29 <msteele_> edwardk_: copumpkin: What do you use for error handling, then?
14:10:33 <edwardk_> fib = 1 `fby` 1 `fby` codo x:y:_ <- fib; x + y
14:10:40 <copumpkin> msteele_: I don't make errors ;)
14:11:20 <mmorrow> Segmentation fault
14:11:29 <edwardk_> msteele_: i use Either when needed, but the Error e requirement on its left hand side is kind of annoying in that it breaks symmetry with (,) and prevents certain combinators from being used.
14:11:32 <copumpkin> if Either is going to be used for Either String a all the time for errors, it seems reasonable to just call it the Error type and give it a monad instance
14:12:11 <edwardk_> with nice constructors ala Erlang like Error e | OK a
14:12:16 <copumpkin> yeah
14:12:32 <copumpkin> first of all, I'm left-handed, and don't like the implication that Left is inferior
14:12:42 <msteele_> Last week I discovered the ErrorT monad and have been running with it.  That's why I ask.
14:12:44 <copumpkin> actually, that's bullshit, but it's still silly :P
14:12:48 <pikhq> copumpkin: But it's sinister!
14:12:49 <pikhq> ;)
14:12:58 * copumpkin is sinister and proud of it
14:15:12 <edwardk_> I do wish Error would just get out of my Either monad and leave me alone
14:17:56 <blackh> copumpkin: Left/right symbolism is very ancient, and left is the hidden and feminine, right is the visible.  So left is only /apparently/ evil. :)
14:18:07 <copumpkin> :P
14:18:16 <copumpkin> I know it's ancient, but we should get it out of our monads
14:18:23 <copumpkin> :)
14:18:48 <blackh> Well, I'd be very confused if it were the other way around. :)
14:19:29 * Apocalisp is ambisinistrous
14:20:44 * mmorrow thinks the moral here is to rename Either to Error e outayerloop = ApparentlyEvil e | VISIBLE outayerloop?
14:21:19 <blackh> Either a b = Yin a | Yang b
14:23:04 <mmorrow> , vaccum (fix (\ ~[l,r]->[Node()[l,r],Node()[r,l]])
14:23:05 <lunabot>  luna: parse error (possibly incorrect indentation)
14:23:08 <mmorrow> , vaccum (fix (\ ~[l,r]->[Node()[l,r],Node()[r,l]]))
14:23:09 <lunabot>  luna: Not in scope: `vaccum'
14:23:11 <QP> i'm having huge difficulty compiling haddock. I'm afraid I've no experience of compiling stuff like this, as everything I've wanted to get so far has been contained in repositories as binaries. So can someone basically explain how to do this? I've got the haddock source code, but I can't seem to compile it...
14:23:13 <mmorrow> , vacuum (fix (\ ~[l,r]->[Node()[l,r],Node()[r,l]]))
14:23:15 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[6,7]),(3,[]),(4,[1,5]),(5,[6,7]),(6,[3,8]),(7,[]...
14:23:55 <mmorrow> , filter (not . null . snd) $ vacuum (fix (\ ~[l,r]->[Node()[l,r],Node()[r,l]]))
14:23:57 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[6,7]),(4,[1,5]),(5,[6,7]),(6,[3,8]),(8,[6,9]),(9...
14:24:01 <QP> i've tried ghc --make Main.hs and that han
14:24:06 <QP> hasn't worked
14:24:08 <Badger> @hoogle vacuum
14:24:08 <lambdabot> No results found
14:24:39 <mmorrow> , filter (\(i,ps) -> any (< i) ps) . filter (not . null . snd) $ vacuum (fix (\ ~[l,r]->[Node()[l,r],Node()[r,l]]))
14:24:41 <lunabot>  [(4,[1,5]),(6,[3,8]),(8,[6,9]),(9,[1,7])]
14:24:53 <mmorrow> loops!
14:25:10 <CalJohn> QP: are you using cabal?
14:25:15 <QP> no
14:25:16 <copumpkin> mmorrow is the master janitor!
14:25:23 <CalJohn> why aren't you?
14:25:23 <QP> should i be?
14:25:29 <CalJohn> yes
14:25:52 <QP> well i don't know what i should be doing
14:25:53 <mmorrow> copumpkin: i've gotta clean up some vomit in room 301, bbiab
14:26:02 <CalJohn> QP: http://www.haskell.org/haskellwiki/Cabal-Install
14:26:08 <QP> i thought I downloaded the source and then compiled it with ghc
14:26:16 <CalJohn> QP: cabal install is basically a package manager for haskell
14:26:33 <QP> i thought darcs was the package manager for haskell
14:26:43 <CalJohn> QP: if you have ghc and cabal, it will do everything else if you type "cabal install haddock"
14:26:53 <QP> ok
14:26:53 <dschoepe> QP: darcs is a VCS, like git or svn
14:26:56 <fbru02> hey guys im trying to make a rpn calculator , is this how you would make the push and pop methods http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3376#a3376 ?
14:26:57 <CalJohn> darcs is version control that it typically used with haskell
14:26:58 <mmorrow> QP: s/package manager/version control system/
14:27:26 <QP> version control system?
14:27:28 <CalJohn> QP: sorry you've struggled, you were unlucky not to hear of cabal before now :)
14:27:44 <CalJohn> QP: like CVS
14:27:50 <QP> well i had heard of it, but i didn't know what it was
14:28:09 <CalJohn> @wiki Version Control System
14:28:09 <lambdabot> http://www.haskell.org/haskellwiki/Version_Control_System
14:28:12 <mmorrow> pfffft, Real Programmers use RCS.
14:28:27 <CalJohn> that is an unhelpful page
14:28:32 <CalJohn> i thought it would be wikipedia
14:28:41 <QP> well thanks for your help
14:28:41 <mmorrow> i wonder if anyone actually uses rcs still
14:28:44 <dschoepe> @go version control system
14:28:45 <lambdabot> http://en.wikipedia.org/wiki/Revision_control
14:28:45 <lambdabot> Title: Revision control - Wikipedia, the free encyclopedia
14:29:03 <jfoutz> meh. foo.c & foo.c.bak
14:29:14 <mmorrow> it's always amusing to see random RCS tags dated from 1991 at the top of source files
14:29:20 <QP> sorry my questions are always boring techno type ones---i'm a math student, so its the computer science stuff i don't get!
14:29:50 <dumael> mmorrow: you seen some of GHC's source?
14:29:53 <QP> or don't have the background knowledge on
14:30:56 <seydar> what's something cool that haskell has like literate programming
14:31:10 <seydar> as in, not directly tied to the language
14:31:20 <mauke> pointless code
14:32:16 <dschoepe> seydar: monads
14:32:41 <aavogt> @quote wadler
14:32:41 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
14:33:08 <aavogt> @quote wadler monad
14:33:08 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
14:33:20 <seydar> i suppose i'm going for more of tools
14:33:33 <seydar> like the ability to parse .lhs files, etc.
14:33:33 <pragma_> you're a tool
14:33:38 <mauke> @quote monad.*time
14:33:39 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
14:33:44 <seydar> pragma_ that's not helping!
14:34:30 <jfoutz> fbru02: that will work. It's kind of heavy handed. I appreciate the desire to put the stack in the state monad, but you might want to just pass the list around.
14:35:08 <Cale> seydar: Perhaps have a look at the code coverage and profiling tools in GHC?
14:35:15 <Cale> seydar: They're pretty cool.
14:35:23 <seydar> ooh, there's code coverage tools?
14:35:27 <seydar>  I've been looking for those
14:35:33 <mmorrow> dumael: heh
14:35:35 <seydar> thank you, cale! no thank you, pragma_
14:35:41 <seydar> you meanie, you
14:35:43 * seydar fades
14:36:20 <dumael> mmorrow: I've got a line proclaiming "VERY MAGIC CONSTANTS"
14:36:40 <copumpkin> dammit, the discrepancies between IntMap and Map are annoying
14:37:29 <copumpkin> why isn't there a mapKeys :: (Int -> Int) -> IntMap a -> IntMap a and a mapKeysMonotonic :: (Int -> Int) -> IntMap a -> IntMap a
14:37:32 <fbru02> jfoutz: thanks ! i just want to get user input in my program, how can i put the runNextState function inside the do-block in my main method ?
14:39:03 <jfoutz> :t interact
14:39:11 <lambdabot> (String -> String) -> IO ()
14:40:43 <mauke> perl -pe 's/^>//||!/\S/||s/^/-- /'  # I really should write this down somewhere
14:41:15 <jfoutz> fbru02: maybe have main call nextState right away, nextState stack = do { v <- get; let newstack = runCmd v stack; nextState newstack}
14:43:28 <Twey> dumael: Not MORE MAGIC CONSTANTS?
14:44:02 <jfoutz> fbru02: there's a lot of games you could play. you could make a datatype for the various operations, have your runCmd take that type as an argument.
14:44:29 <pastah> does naming a function _f do something special with it?
14:45:03 <pastah> i know prepending '_' is something done a lot when compiling, but what about if i write it like that?
14:45:21 <mauke> no
14:45:42 <pastah> ok, cool, it's done in "making a choice from a list", the VTY guide :)
14:46:21 <aavogt> pastah: _f doesn't get warned as an unused function when you use -Wall, while f does (say nothing exported from the module uses that function)
14:46:43 <aavogt> same for variables you define when pattern matching
14:46:58 <Makoryu> @pl \w b -> map (take w) b
14:46:59 <lambdabot> map . take
14:47:02 <jfoutz> fbru02: the whole tutorial is good, but this part is particularly helpful for what your're doing http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Building_a_REPL
14:47:58 <copumpkin> I wonder if the scheme guys have a "write yourself a haskell in 48 hours" tutorial
14:48:20 <idnar> haha
14:48:24 <jfoutz> they do, but you only get Bool.
14:48:24 <noteventime> copumpkin: Could make an interesting competition
14:48:24 <ksf> I'd like "write yourself a typechecker in 10 minutes"
14:48:44 <copumpkin> ksf: I think luke palmer had something like that for a dependent typechecker
14:49:04 <ksf> the gadt wiki page has three of them iirc
14:49:24 <jfoutz> write yourself a C++0x in 4 years
14:49:44 <fbru02> jfoutz: thanks that was pretty sweet code, how would you do the runCmd take the type as an argument with a newtype constructor ? also i was asking that i cannot call runNextState from main because i get couldnt mactch expected type IO b against ingerred [Int] -> b1
14:49:47 <Makoryu> s/4/40/
14:49:53 <noteventime> jfoutz: Does write yourself a C++0x even terminate?
14:50:02 <fbru02> jfoutz: i will check that part of the tutorial :)
14:50:02 <jfoutz> noteventime: probably not.
14:51:10 <jfoutz> fbru02: it takes a while to get the types to match up. try writing your type first, then the function.
14:51:10 <Scriptor> hey everyone, I've got a question about the explanation of laziness in learnyouahaskell
14:51:35 <Vanadium> Yeah?
14:51:39 <copumpkin> Scriptor: let's hear it :)
14:51:47 <Scriptor> I can't figure out the difference between the imperative and lazy approach to doubleMe(doubleMe(doubleMe(xs)))
14:52:22 <seydar> Scriptor: think of it this way
14:52:42 <seydar> Scriptor: the imperative approach is that kid in the class who always ruins grade curves
14:52:44 <copumpkin> zomg it's a seydar. you missed the boston haskell meetup!
14:52:45 <ksf> Scriptor, try it with an infinite list.
14:52:46 <Makoryu> Scriptor: Don't think "imperative vs. lazy"... Think "strict vs. lazy"
14:53:05 <seydar> Scriptor: so he sees that and says "well i'm a super nerd so i'm gonna solve it right away!"
14:53:13 <copumpkin> lol
14:53:17 <seydar> Scriptor: now HASKELL, on the other hand, gets all the babes
14:53:18 * dqd thinks that better is strict vs. non-strict.
14:53:31 <fbru02> jfoutz: i havent thought of that ! maybe i should try with some of the liftM function to wrap the Int runNextState returns into IO ?
14:53:43 <seydar> Scriptor: so he sees that and is like "psssh math is for neeeeeeeeeerds. i'll only solve it when someone actually needs it"
14:53:52 <seydar> Scriptor: haskell uses what's known as the "
14:53:58 <seydar> "wally week" for all computations
14:54:12 <Makoryu> dqd: Yeah, technically Haskell is specified in the standard as being non-strict, rather than specifically lazy
14:54:13 <Scriptor> ok, my guess is that dbl(dbl(dbl(xs))) !! 1 would only have it so that the 2nd element is doubled
14:54:24 <ksf> yep why do your homework if you're not actually sure the teacher will control it.
14:54:39 <dqd> Makoryu: Exactly.
14:56:16 <jfoutz> fbru02: yeah, i think you could liftM in main, or you could do runNextState = return $ runstate $ push 3, or you could just say let result = runNextState ..blah..
14:57:53 <seydar> Scriptor: it would actually double the first two
14:58:05 <fbru02> jfoutz: cool previously of pasting the code i used return runstante $ push 3 but that didn't satisfy the types, now i see that using $ helps , thanks again
14:58:16 <Saizan> how is dbl defined?
14:58:20 <seydar> Scriptor: because in order to access the second element, it needs the first one, which it gets by doing that dumb nerdy stuff
14:58:33 <jfoutz> fbru02: sure. have fun :)
14:58:38 <mauke> dbl x = x + x
14:58:45 <Scriptor> Saizan: I was just shorthanding the doubleMe function from learnyouahaskell
14:58:46 * mauke crawls away
14:58:52 <copumpkin> dbl = join (+)
14:59:24 <Scriptor> seydar: if the compiler knows only the second element is needed, why doesn't it simply skip the first element and double the 2nd element every time?
14:59:50 <Saizan> if doubleMe x = x + x then dbl(dbl(dbl(xs))) !! 1 can't typecheck, or do you have a Num [a] instance?
14:59:57 <seydar> Scriptor: i defer to someone else
15:00:32 <Scriptor> Saizan, it's actually defined as a function that doubles every element in a list
15:00:33 <copumpkin> > let dbl = join (+) in map (dbl . dbl . dbl) [undefined, undefined, 0xbabe, undefined, undefined] !! 2
15:00:35 <Saizan> s/doubleMe/dbl/
15:00:35 <lambdabot>   382448
15:00:49 <copumpkin> mmmminefield list
15:00:55 <Makoryu> Scriptor: It never actually doubles the first element unless you try to compare its value or perform arithmetic on it
15:01:09 <mauke> dbl [] = []; dbl (x : xs) = (x + x) : dbl xs ?
15:01:32 <Saizan> Scriptor: in that case to access the second element it doesn't need to compute the first
15:01:38 <jfoutz> > let dbl = join (+) in map (dbl . dbl . dbl) [undefined,  undefined, 0xbabe, undefined, undefined] !! 1
15:01:39 <lambdabot>   * Exception: Prelude.undefined
15:01:42 <Saizan> Scriptor: it only has to compute the first cons cell
15:01:47 <bcw> hi.  i know most people here are not lawyers (and neither am i), but is it okay to use the code for Haskell's exponentiation operator (a small part of GHC.Real) to make a modular exponentiation function, and then release it under GPL?  article is here: http://bcwells.net/node/2
15:02:06 <copumpkin> bcw: most haskell code is bsd, afaik
15:02:10 <copumpkin> which would imply yes
15:02:21 <copumpkin> but why gpl?
15:02:24 <copumpkin> O:-)
15:02:31 <Axman6> GPL--
15:02:35 <jfoutz> yes. bsd to gpl is allowed.
15:02:43 <Saizan> Scriptor: the point is that there's no data dependency between the two elements in this case
15:02:48 <bcw> ok, thanks.
15:02:52 <copumpkin> bcw: people in the haskell community aren't big fans of GPL'd software, and tend to avoid it if possible
15:03:06 <copumpkin> (avoid using anything GPL'd)
15:03:07 <sjanssen> bcw: you do need to note the code's original copyright
15:03:07 * mauke likes the LGPL
15:03:20 <sjanssen> GPL++
15:03:23 <Saizan> GPL++
15:03:26 <bcw> sjanssen, ok, i'll add a note
15:03:28 <copumpkin> GPL--
15:03:32 <aavogt> @karma GPL
15:03:32 <lambdabot> GPL has a karma of -1
15:03:36 <copumpkin> muahahahah
15:03:41 <Vanadium> GPL++
15:03:42 <msteele_> GPL++
15:03:43 <Vanadium> There >:[
15:03:47 <Axman6> GPL--
15:03:49 <copumpkin> > text "GPL--"
15:03:50 <lambdabot>   GPL--
15:03:52 <sjanssen> GPL is good, Haskell just has practical issues with it
15:04:03 <Vanadium> Really?
15:04:13 <jfoutz> , text "GPL--"
15:04:13 <Saizan> GHC in particular
15:04:14 <lunabot>  GPL--
15:04:18 <sjanssen> Vanadium: yeah, we have no dynamic linking which is an issue
15:04:20 <copumpkin> the static linking issue will soon be resolved
15:04:33 <seydar> i must flee
15:04:38 <seydar> copumpkin: cogood bye
15:04:41 * copumpkin chases seydar
15:05:21 <Makoryu> In any case, the least of our worries is having someone swipe GHC code (written in Haskell...) for use in a proprietary app of some kind
15:06:01 <Saizan> considering the whole readline vs. editline issue i think that's already happening :)
15:08:49 <QP> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8374#a8374 ::: Can anyone explain why my haddock comments won't display in the html file?
15:09:43 <vav> must define ghci fixity in files, right, there's no on the fly ' let infixl 3 (%!) = ...', right?
15:10:01 <Saizan> QP: you need -- ^ instead of -- | for constructors
15:10:13 <QP> ok...
15:10:19 <QP> i'll try that, thanks
15:10:42 <Saizan> vav: the fixity declaration is separate from the definition
15:10:56 <vav> Saizan: or doesn't it need to be record to use -- ^ on constructors?
15:11:08 <Saizan> let infixl 3 %!; (%!) = ..
15:11:24 <Saizan> vav: maybe so
15:12:02 <vav> Saizan: awesome, thanks. trying to work out fewest parens for weird little bunch of fns and that will help much
15:12:25 <Makoryu> vav: An "infixl n op" line can go anywhere an operator declaration can go. However, IIRC you have to define the operator in the same definition block
15:13:27 <QP> Saizan: I'm afraid it still isn't working. I'll upload the new source.
15:14:08 <Saizan> QP: i'm not an expert of haddock syntax though :)
15:18:57 * copumpkin can type  on his keyboard, how useful
15:19:28 <bcw> sjanssen, i've added two notes, both where i talk about the GHC.Real function and in my source.
15:19:35 <bcw> does it look okay now?
15:19:49 <olsner> copumpkin: ooh! how?
15:19:52 <copumpkin> > let x  y = abs (x - y) < 3 in 5  7
15:19:55 <lambdabot>   True
15:20:02 <copumpkin> olsner: option+x on mac os
15:20:24 <olsner> hmm, this computer has neither option key nor mac os, so I guess I'm screwed :(
15:20:31 * Apocalisp can type " heyri Psi djflasng ma r uxakv og b Ts" on his keyboard.
15:20:46 <copumpkin> Apocalisp: icelandic?
15:20:47 <ziman> what language is that?
15:20:56 <Apocalisp> copumpkin: J!
15:21:04 <copumpkin> cool :)
15:21:12 <olsner> "then heard ... devilsong ... and be quiet"?
15:22:14 <pastah> aavogt: cool, thanks :)
15:22:23 <olsner> "Ts" should be a name since it's capitalized though
15:22:35 <QP> ok, i've figured it out---you have to include the constructors explicitly in the module header
15:22:37 <Apocalisp> then Peter heard devil song sounding from the ox pen and the home of the god of war.
15:22:42 <copumpkin> :o
15:22:43 <bcw> copumpkin, to answer your earlier question, i don't have any particular reason for using GPL in this case.  it's just what i always use for my stuff, since i want my software to stay free.  i guess i could also let it be used under BSD in this case.
15:23:01 <copumpkin> bcw: well it's obviously your choice :)
15:23:16 <Apocalisp> olsner: It's like "the quick brown fox..."
15:23:34 <olsner> it contains the full icelandic alphabet?
15:23:39 <Apocalisp> right
15:24:40 <copumpkin> > map head . group . sort " heyri Psi djflasng ma r uxakv og b Ts"
15:24:42 <lambdabot>   Couldn't match expected type `a -> [a1]'
15:24:46 <copumpkin> > map head . group . sort $ " heyri Psi djflasng ma r uxakv og b Ts"
15:24:48 <lambdabot>   " PTabdefghijklmnorsuvxy\222\225\230\233\237\240\243\246\250\253"
15:24:53 <copumpkin> dammit
15:25:10 <copumpkin> , map head . group . sort $ " heyri Psi djflasng ma r uxakv og b Ts"
15:25:12 <lunabot>  " PTabdefghijklmnorsuvxy\222\225\230\233\237\240\243\246\250\253"
15:25:29 <copumpkin> > text . map head . group . sort $ " heyri Psi djflasng ma r uxakv og b Ts"
15:25:31 <lambdabot>    PTabdefghijklmnorsuvxy
15:25:31 <Makoryu> > text .  map head . group . sort $ " heyri Psi djflasng ma r uxakv og b Ts"
15:25:33 <lambdabot>    PTabdefghijklmnorsuvxy
15:25:33 <Makoryu> Hahaha
15:25:48 <copumpkin> :)
15:26:11 <Apocalisp> > text . sort . map head . group . sort $ " heyri Psi djflasng ma r uxakv og b Ts"
15:26:12 <copumpkin> does icelandic have no Z?
15:26:13 <lambdabot>    PTabdefghijklmnorsuvxy
15:26:30 <copumpkin> or W I guess
15:26:56 * copumpkin listens to some sigur ros
15:27:13 * Apocalisp er starlfur
15:30:27 <copumpkin> :t mapM ((map ((chr .) . (. ord) . ($0) . flip) [setBit, clearBit] <*>) . pure)
15:30:29 <lambdabot> [Char] -> [[Char]]
15:30:41 <copumpkin> that actually serves a purpose!
15:30:53 <aavogt> @type setBit
15:30:54 <lambdabot> forall a. (Bits a) => a -> Int -> a
15:31:15 <copumpkin> @instances Bits
15:31:16 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
15:31:26 <copumpkin> > setBit 'a' 0
15:31:28 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
15:31:28 <lambdabot>    arising from a use of `D...
15:31:31 <copumpkin> damn :)
15:32:19 <copumpkin> > mystery "ohai"
15:32:22 <lambdabot>   ["oiai","oiah","oi`i","oi`h","ohai","ohah","oh`i","oh`h","niai","niah","ni`...
15:32:46 <copumpkin> I guess it isn't much of a mystery anymore :)
15:33:18 <Badger> ohio?
15:34:13 <aavogt> traverse is the new mapM
15:34:24 <aavogt> maybe?
15:35:04 <LeoD> @hoogle [a] -> (a -> Bool) -> Int
15:35:05 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
15:35:05 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
15:35:05 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:35:10 <copumpkin> sure
15:35:39 <LeoD> hm, how'd you count for how many elements of a list some predicate returns true?
15:35:43 <mreh> given a velocity of an object going through a liquid, how do you find the friction?
15:36:02 <aavogt> :t (length .) . filter
15:36:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
15:36:23 <aavogt> :t (. filter) . length
15:36:24 <lambdabot>     Couldn't match expected type `([a] -> [a]) -> c'
15:36:24 <lambdabot>            against inferred type `Int'
15:36:24 <lambdabot>     In the second argument of `(.)', namely `length'
15:36:33 <EvilTerran> mreh, you need to know a lot more about the object than its velocity
15:36:36 <LeoD> sweet
15:36:45 <LeoD> thanks aavogt
15:37:07 <mreh> EvilTerran: is it roughly linear in proportion to the velocity though?
15:37:16 <copumpkin> nope
15:37:19 <copumpkin> quadratic
15:37:20 <mreh> it's for my asteroids
15:37:33 <EvilTerran> its size, shape, rigidity and surface texture will also affect the friction, as will the viscosity of the fluid
15:37:58 <copumpkin> http://en.wikipedia.org/wiki/Drag_(physics)
15:38:21 <arw> mreh: there are many possibilities. there is the simple stokes-formula, which applies to a sphere in a non-turbulent, laminar fluid.
15:38:22 <EvilTerran> mreh, traditional Asteroids doesn't have any friction, does it?
15:38:28 <aavogt> moving asteroids don't spend much time in dense fluids... or will they?
15:38:39 <mreh> EvilTerran: yeah
15:38:41 <EvilTerran> what with it being, er, in space
15:38:43 <mreh> for the space ship
15:38:50 <mreh> i know, but it just did
15:38:55 <arw> mreh: and then there are non-simple forms and non-laminar motions, which you have to simulate numerically for accurate results...
15:39:04 <copumpkin> mreh: but anyway, it's quadratic in the speed of your asteroid
15:39:05 <mreh> i put it down to dust particles hitting the ship
15:39:12 <copumpkin> mreh: but there are a lot more factors, of course
15:39:40 <EvilTerran> i'd be more inclined to look up the math used in the original game than to try to simulate some approximation of reality, tbh
15:40:05 <mreh> EvilTerran: how would I do that?
15:40:13 <mreh> break open an arcade box
15:40:33 <EvilTerran> hope someone's already worked it out from a ROM and written about it on the internet?
15:40:50 <mreh> and written a paper on it
15:42:10 <copumpkin> http://games.atari.com/arcade.php?game=asteroids
15:42:18 <copumpkin> that's atari's official port
15:43:02 <mreh> http://playthisthing.com/relativistic-asteroids
15:43:14 <mreh> unbelievable
15:43:17 <copumpkin> http://cloningtheclassics.com/classic-arcade-games/player-movement-in-classic-asteroids-arcade-game/
15:43:22 <copumpkin> there you go
15:44:44 <mreh> good jon
15:44:47 <mreh> job
15:46:45 <mreh> all the clones I've played have a capped velocity, and a loss of momentum applied to the ship
15:47:03 <mreh> which sort of points to a constant co-efficient of friction, doesn't it
15:48:26 <Beelsebob> all the clones I've ever played have been like the original
15:48:31 <Beelsebob> no friction, no capped velocity
15:48:46 <Beelsebob> which actually is a much more interesting game to play
15:48:56 <mreh> you're mistaken, i can supply a counter example
15:49:04 <Beelsebob> if you can rely on friction slowing you down, things are much less exciting
15:49:06 <mreh> infact wikipedia says the ship lost momentum
15:49:19 <idnar> Beelsebob: friction? in space?
15:49:26 <Beelsebob> idnar: exactly  silly
15:49:27 <ksf> c2hs and dlopen, anyone?
15:49:41 <idnar> Beelsebob: retrothrusters!
15:49:57 <EvilTerran> idnar, ah, that makes more sense
15:50:10 <mreh> have you all forgotten that it's a game not a realistic flight simulator to train pilots in the event of an asteroid storm
15:50:41 <Beelsebob> mreh: no, in fact all my comments have been directed at what makes an interesting game, not what makes it accurate
15:51:19 <mreh> games sold by Beelsebob: 0
15:51:46 <Beelsebob> what's your point?
15:52:20 <mreh> I am choosing not to observe your opinion
15:52:23 <EvilTerran> mreh, quit yer whining, you're in a channel full of academics and other such thinkers. of course things get over-analysed, that's what we do for fun
15:52:27 <Beelsebob> that I haven't sold any games and thus can't know what I enjoy when playing a game?
15:52:57 <mreh> i'm not making the game for you
15:53:06 <mreh> end of discussion
15:53:20 <Beelsebob> fair enough  make it for you then  why did you start the discussion?
15:53:35 <mreh> anyway
15:54:04 <copumpkin> wow o.O
15:54:19 * EvilTerran felt the discussion was never "what mreh should do", anyway; it was more "what might be interesting, and the merits of different tacks"
15:54:33 * Beelsebob nods
15:54:53 <copumpkin> mreh: call it hemorrhoids and have the player be in a sea of blood, then you can justify drag :)
15:54:55 <EvilTerran> being what this channel is usually about, in between the helping people out
15:55:16 * dmwit dons his flame-retardant suit
15:55:17 * mreh grins
15:55:24 <Beelsebob> copumpkin: one of the many clones I've played was actually called hemorrhoids
15:55:25 <Beelsebob> >.>
15:55:29 <copumpkin> lol
15:55:49 <copumpkin> sounds like fun :)
15:56:05 <copumpkin> oh my, the wikipedia page on the subject has a picture
15:56:12 <Beelsebob> hehe
15:56:16 <EvilTerran> :C
15:56:34 <copumpkin> lots of other fun pictures on wikipedia these days
15:56:50 <copumpkin> auto****atio for example has a real photo :) but sorry for the offtopic
15:58:01 <EvilTerran> copumpkin, i'm surprised they don't go for clinical-style line drawings for that sort of thing, really
15:58:11 <copumpkin> I'm not
15:58:17 <copumpkin> I find it quite refreshing
15:58:48 <EvilTerran> i don't mind it particularly, i just find it surprising
15:59:11 <idnar> copumpkin: oh, awesome
15:59:23 <copumpkin> :)
15:59:26 <mreh> doesn't cumshot have a line drawing on wikipedia?
16:00:00 <mreh> as if the real thing were any worse
16:00:05 <idnar> it's more than a line drawing
16:00:10 <copumpkin> there are some amusing drawings, not photos
16:00:14 <copumpkin> not too sure why
16:00:16 <mreh> water colour
16:00:22 <copumpkin> maybe this should move to #haskell-blah though :)
16:00:27 * EvilTerran feels this conversation may be closer to on-topic in #wikipedia ;)
16:04:20 <mreh> asteroids, or Borg cubes?
16:04:47 <Beelsebob> borg cubes... obviously
16:06:12 <mreh> do many people here collaborate online with haskell
16:06:18 <mreh> for money
16:06:29 <mreh> it seems like a good way with such limited resources
16:06:49 <Beelsebob> everyone here pretty much collaborates online with haskell
16:06:58 <Beelsebob> but most do it for love of haskell
16:07:04 <Beelsebob> not for money
16:08:10 <mreh> I don't want to sound starry eyed and innocent, but there's so much for the taking!
16:08:14 <Vanadium> I tried collaborating with haskell
16:08:18 <Vanadium> but he is a huge jerk >:[
16:08:29 <_roconnor> @type \a b -> a (\ c -> b (c b)) b
16:08:30 <lambdabot> forall t t1 t2. ((((t -> t1) -> t) -> t1) -> (t -> t1) -> t2) -> (t -> t1) -> t2
16:08:48 <Beelsebob> lol Vanadium
16:10:45 <_roconnor> @djinn ((a -> r) -> a) -> (a -> (b -> r) -> b) -> (b -> r) -> b
16:10:46 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
16:11:43 <copumpkin> djinn is quite impressive
16:13:17 <c_wraith> :t on
16:13:19 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:13:22 * copumpkin has actually started writing some of the more crazy @pl things without using @pl, is that bad?
16:13:34 <c_wraith> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
16:13:34 <lambdabot> f a b c _ = a (b c) (b c)
16:13:44 <c_wraith> so close, djinn!
16:13:49 <c_wraith> :)
16:13:49 <ksf> copumpkin, you're beyond all hope since you started to be a dual.
16:13:51 <EvilTerran> copumpkin, as in, <*> as the S combinator, kinda thing?
16:14:01 <copumpkin> @djinn n -> p Z -> (forall x. p x -> p (S x)) -> p n
16:14:02 <lambdabot> Error: Undefined type Z
16:14:07 <copumpkin> EvilTerran: yeah
16:14:34 <copumpkin> djinn may be smart, but not smart enough!
16:15:00 <Vanadium> @djinn Haskell -> Money
16:15:00 <lambdabot> Error: Undefined type Haskell
16:15:02 <Vanadium> :\
16:15:12 <EvilTerran> Vanadium, surely Haskell -> IO Money?
16:15:27 <aavogt> pure money!
16:15:27 <dmwit> galois, janeStreet :: Haskell -> Money
16:15:54 <dmwit> Oh, yeah, and creditSuisse
16:16:03 <dschoepe> dmwit: Are they using unsafeMakeMoney or why are they not in the IO monad? =)
16:16:07 <Saizan> janeStreet i thought was ocaml
16:16:14 <EvilTerran> Writer Haskell -> Supply Money
16:16:23 <copumpkin> :t recip
16:16:25 <lambdabot> forall a. (Fractional a) => a -> a
16:16:30 <Beelsebob> IO :$ Supply Money
16:16:39 <EvilTerran> Beelsebob, (:$)?
16:16:45 <dmwit> `O`
16:16:57 <Beelsebob> type (:$) a b = a b
16:17:00 <EvilTerran> ah
16:17:31 <arw> unsafeMakeMoney sometimes throws you into the Jail monad for no apparent reason...
16:17:43 <Beelsebob> heh
16:18:05 <Beelsebob> I found it sometimes throws you into the "oh fuck, bankrupt company" monad
16:18:26 <arw> and return doesn't work there, except after some years of trying...
16:18:33 <jfoutz> 19:18 < Beelsebob> I found it sometimes throws you into the "oh fuck, bankrupt
16:18:54 <jfoutz> grr. stupid mouse paste. sorry.
16:19:27 <copumpkin> mousse paste
16:20:16 <Beelsebob> monad Jail where return = threadDelay 1000000000000; join (Jail (Jail x)) = MaximumSecurity x; join (MaximumSecurity _) = error "lethal injection"; join (Jail (MaximumSecurity _)) = error "electric chair"?
16:20:34 <ksf> please, please tell me that someone already did all that dlopen plumbing.
16:21:01 <copumpkin> hsplugins?
16:21:04 <copumpkin> or whatever the new one is
16:21:11 <mreh> whai duz Random number generation involve the IO monad
16:21:12 <Beelsebob> ghc-api
16:21:13 <_roconnor> copumpkin: http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/
16:21:24 <mreh> :t getStdGen
16:21:26 <lambdabot> IO StdGen
16:21:33 <ksf> erm no I want to dlopen a c lib.
16:21:38 <Beelsebob> mreh: can you think of a function that always returns the same value, but who's result is random?
16:21:43 <ksf> that is, link during runtime.
16:21:49 <ksf> ...not link time.
16:21:53 <aavogt> :t randoms
16:21:54 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:22:20 <jfoutz> i think you need to construct the generator in IO, but you can use it wherever.
16:22:22 <copumpkin> _roconnor: is that a generalization of the withCString -> withCStrings trick?
16:22:29 <_roconnor> @djinn a -> ((a -> r) -> a)
16:22:30 <lambdabot> f a _ = a
16:22:43 <_roconnor> copumpkin: I don't know what that trick is
16:22:48 <mreh> okay, thanks
16:22:49 <copumpkin> I guess the types don't fit anyway :)
16:25:46 <copumpkin> _roconnor: trying to figure out what it's up to :P
16:25:59 <_roconnor> good luck with that :D
16:26:08 <_roconnor> this isn't something I made up
16:26:15 <_roconnor> it is a "well-known" monad
16:26:25 <copumpkin> :o
16:26:27 <_roconnor> only that I've never heard it discussed in #haskell-blah
16:26:29 <_roconnor> er
16:26:31 <_roconnor> only that I've never heard it discussed in #haskell
16:26:35 <Saizan> _roconnor: i wonder if it's a specialization of oleg's "genuine shift-reset" monad
16:26:44 * _roconnor decides to poke the question in in-depth
16:26:51 <Saizan> so it's known among CTers?
16:27:01 <copumpkin> it's sort of like ContT but with the type backwards
16:27:03 <_roconnor> Saizan: ski seemed to think something like that
16:27:13 <_roconnor> when we talked about it earlier today
16:27:28 <_roconnor> but AFAIK he never really made sense of it
16:28:26 <roconnor_> Saizan: it is know amoungst a few constructive logicians
16:28:32 <roconnor_> I hear about it for the second time in my life today
16:28:40 <roconnor_> second time I remember at least
16:28:41 * copumpkin tries playing with J fix
16:29:40 <augustss> roconnor_: what's this monad?
16:29:55 <roconnor_> augustss: I don't really know.
16:30:01 <augustss> oh
16:30:59 <roconnor_> In the context I heard about it today, it was being used to embed some logic into constructive logic
16:31:08 <roconnor_> I didn't really follow the details.
16:31:21 <roconnor_> since the people talking seemed quite familiar with J
16:31:25 <augustss> an embedding that was not double negation
16:31:27 <augustss> ?
16:31:30 <roconnor_> ya
16:31:32 <roconnor_> something like that
16:31:41 <roconnor_> but not quite right
16:31:45 <roconnor_> sorry
16:31:58 <roconnor_> It is hard to repeat something one didn't understand
16:32:12 <augustss> yup
16:32:17 <roconnor_> it was more like double negatation is to Cont r as foo is to J r
16:32:43 <Saizan> but then it's J a = Not a -> a?
16:33:00 <augustss> what's J?
16:33:17 <roconnor_> augustss: http://www.reddit.com/r/haskell/comments/9clsr/wanted_applications_of_the_j_monad/ ?
16:33:31 <roconnor_> newtype J r a = J {unJ :: ((a -> r) -> a)}
16:33:48 <Saizan> i was going with negation = -> r
16:34:00 <augustss> that's a bizarre type
16:34:01 <roconnor_> Saizan: I think that is the wrong way to look at the analogy :)
16:34:12 <roconnor_> augustss: is (a -> r) -> r a bizarre type?
16:34:27 <augustss> no
16:34:29 <Saizan> roconnor_: i guess so, it doesn't make much sense :)
16:35:21 <roconnor_> hmm
16:35:43 <roconnor_> I wonder if the idea is to use fix to get out at the end, like using ($ id) to get out of Cont r
16:35:53 * roconnor_ is just guessing
16:36:03 <copumpkin> yeah, I've been playing with it and fix
16:36:06 <Saizan> ?djinn-add J r a = (a -> r) -> a
16:36:07 <lambdabot> Cannot parse command
16:36:10 <copumpkin> but that would limit the usefulness of it it seems
16:36:14 <augustss> using fix seems to lose any connection to logic
16:36:15 <Saizan> ?djinn-add type J r a = (a -> r) -> a
16:36:31 * roconnor_ tries to remember more that conversation
16:36:32 <copumpkin> augustss: not sure what else you could do with such a type though?
16:36:50 <augustss> @djinn J r a -> (a -> J r b) -> J r b
16:36:50 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
16:36:55 <Saizan> ?djinn J r (Either a (a -> r))
16:36:56 <lambdabot> f a = Right (\ b -> a (Left b))
16:37:04 <roconnor_> did it have something to do with bar recursion?
16:37:11 <roconnor_> or was that a totally different part of the conversatin
16:37:49 <augustss> hmm, so it has some excluded middle property, that's cool
16:38:04 <roconnor_> ah
16:38:16 <roconnor_> so maybe it was embedding classical logic in constructive logic
16:38:20 <roconnor_> in a different way
16:38:32 <roconnor_> I was going to say that
16:38:42 <roconnor_> but I hesitated because it didn't feel possible
16:38:52 <roconnor_> so I figured I didn't remember properly
16:39:28 <roconnor_> @djinn J r ((a -> r) -> r)
16:39:29 <lambdabot> -- f cannot be realized.
16:39:37 <roconnor_> @djinn J r (((a -> r) -> r) -> a)
16:39:38 <lambdabot> -- f cannot be realized.
16:40:04 <roconnor_> another key point is that J b a is the hypothesis of Pierce's law
16:40:16 <roconnor_> @djinn J r (((a -> r) -> a) -> a)
16:40:17 <lambdabot> f a b = b (\ c -> a (\ _ -> c))
16:40:36 <roconnor_> and J realizes Pierce's law
16:40:48 <augustss> yes
16:41:13 <augustss> i'm trying to figure out how J could be computationally interesting
16:41:36 <roconnor_> but none of this logic stuff gave me very much insight into its potential computational usefulness
16:41:38 <roconnor_> ya
16:42:00 <augustss> For any particular choice of r it seem to degenerate
16:42:14 <augustss> I mean, ((a->Bool)->a), what's that?
16:42:41 <roconnor_> augustss: it is the type of escardo's find function when a is compact
16:42:55 <roconnor_> which I mention because escardo was the one talking about this monad.
16:43:02 <augustss> ah
16:43:11 <roconnor_> not that it is necessarily related
16:43:51 <roconnor_> ah yes
16:43:57 <augustss> it must be related
16:44:07 <roconnor_> we were also talking about "find" functions for different quantifiers
16:44:11 <roconnor_> not just forall and exists.
16:44:19 <roconnor_> before talking about J
16:45:20 <augustss> @djinn-add DJ r a = DJ ((a->r)->a)
16:45:20 <lambdabot> Cannot parse command
16:45:22 <roconnor_> we wanted to "find" someone in a bar who drinks when everyone drinks
16:45:35 <copumpkin> need a type before DJ
16:45:35 <augustss> @djinn-add data DJ r a = DJ ((a->r)->a)
16:45:38 <copumpkin> or that
16:45:58 <roconnor_> and other varients of that
16:46:04 <augustss> @djinn DJ r a -> (a -> DJ r b) -> DJ r b
16:46:04 <lambdabot> f a b =
16:46:04 <lambdabot>     case a of
16:46:04 <lambdabot>     DJ c -> DJ (\ d ->
16:46:04 <lambdabot>                 case b (c (\ e ->
16:46:04 <lambdabot>                            case b e of
16:46:07 <lambdabot>                            DJ f -> d (f d))) of
16:46:08 <lambdabot>                 DJ g -> g d)
16:46:30 <roconnor_> like finding a man and a woman who love each other if and only if every man loves every woman ... or something like that.
16:46:35 <roconnor_> I forget exactly
16:46:45 <augustss> hmm, ok
16:47:07 <roconnor_> still the entire converstation was logical
16:47:11 <roconnor_> as in about logic
16:47:18 <roconnor_> and not computational
16:47:26 <roconnor_> anyhow, I need to sleep now
16:47:43 <roconnor_> maybe the reddit faries will answer my question in the morning
16:48:15 <augustss> or downvote it :)
16:48:19 * roconnor_ (roconnor -> sleep) -> roconnor
16:49:26 <jfoutz> :t callCC
16:49:29 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:51:44 * ksf decides to forget about c2hs for the time being
16:53:42 <ksf> seriously, those dynamic foreign imports are awkward.
16:54:11 <ksf> what about unsafeCastFunPtr :: FunPtr a -> a ?
16:54:23 <RyanT5000> is there any way to determine all the uses of a variable better than deleting it and looking for errors?
16:55:12 <ksf> grep?
16:55:40 <RyanT5000> ksf: grep doesn't know about shadowing :-/
16:55:49 <ksf> leksah?
16:55:55 <RyanT5000> oooh, right
16:55:58 <ksf> (wild guess)
16:56:01 <RyanT5000> i think i might have even gotten that working recently
16:57:20 <hackagebot> bindings-libusb 0.0.6 - Check bindings-common package for directions. (MauricioAntunes)
17:05:02 <ksf> boilerplate alert.
17:05:28 <ksf> please take cover now, ksf is about to explode.
17:07:46 <dolio> @djinn ((a -> J r b) -> J r a) -> J r a
17:07:46 <lambdabot> -- f cannot be realized.
17:09:57 <lilac> dolio: there's no way to create a 'b', so no way to create a 'J r b', so no way to create an 'a -> J r b'
17:10:30 <lilac> f g = g undefined? :)
17:13:29 <ksf> about the best chance I got is grouping the functions into their types and processing them chunkwise.
17:13:45 <ksf> ...hoping that there are a lot of common types.
17:13:52 <ksf> ...which there aren't.
17:22:14 <dolio> J Void a = Not a -> a
17:25:46 <Near> sem frescura. lol
17:27:16 <Near> tanta gente e ninguem fala nada. ._.
17:32:26 <jfoutz> :t Void
17:32:28 <lambdabot> Not in scope: data constructor `Void'
17:32:52 <jfoutz> :k Void
17:32:53 <lambdabot> Not in scope: type constructor or class `Void'
17:33:06 <jfoutz> hrm.
17:33:10 <EvilTerran> jfoutz, "data Void;"
17:33:10 <dolio> data Void
17:33:43 <jfoutz> oh. i see.
17:34:10 <EvilTerran> type with no non-bottom values
17:34:42 <EvilTerran> analogous to False in the curry-howard correspondence, iirc
17:35:52 <EvilTerran> the existence of a total function :: T -> Void implies that T is also empty, and the existence of a proof of P -> False implies that P is also false
17:36:07 <EvilTerran> (i i got that right)
17:36:20 <EvilTerran> *if i
17:37:18 <jfoutz> hmm. J seems like the thing that ignores it's second argument. like a const monad.
17:37:36 <dolio> As long as you have a type theory that doesn't let you just make up proofs of false, like Haskell.
17:37:41 <jfoutz> > (unJ $ return 1 >>= \x -> return (x+1) >>= \x-> return (x+1) ) (const 5)
17:37:42 <lambdabot>   Not in scope: `unJ'
17:38:02 <dolio> Or, perhaps that comma shouldn't be there. You can make up proofs of false in Haskell is what i mean.
17:38:11 <jfoutz> hehehe.
17:38:49 <EvilTerran> dolio, that's why i specified "total function"
17:39:54 <dolio> Oh yeah.
17:40:14 <EvilTerran> not that "total" *entirely* makes sense in the context of a function with empty codomain <.<  >.>
17:40:24 * jfoutz wishes he had more math.
17:40:39 <dolio> Although, you can't really write the kinds of functions that you'd normally write for "P -> False" in Haskell.
17:41:02 <EvilTerran> MATH! MATH! MATH!
17:41:09 <EvilTerran> Math makes you strong!
17:41:10 <dolio> You have to write "pf _ = undefined" instead of something like "pf p = case p of {}".
17:42:40 <jfoutz> EvilTerran: yeah. yeah it does.
17:43:46 <Pseudonym> @pl \z -> (\k -> (z (\l -> k (const l) k)))
17:43:46 <lambdabot> (. (flip =<< (. const)))
17:43:58 <Pseudonym> :t (. (flip =<< (. const)))
17:43:59 <lambdabot>     Occurs check: cannot construct the infinite type:
17:43:59 <lambdabot>       c = ((b -> a) -> c) -> c1
17:43:59 <lambdabot>     Probable cause: `.' is applied to too many arguments
17:44:14 <Saizan> EvilTerran: sure it makes sense! f is total if forall x \in D. exists y \in C. f x = y, if C is empty so must be D :)
17:45:30 <ksf> huh? does wrapping IO into a ReaderT bend stdout/sterr?
17:45:59 <jfoutz> no.
17:46:46 <EvilTerran> Saizan, ok, it makes sense in that it works in the theory; i meant only that i find it mildly unintuitive
17:47:20 <ksf> heh. yeah, my fault. I didn't initialize the .so, so I couldn't see the output it didn't produce.
17:47:28 <jfoutz> :)
17:47:47 <ksf> but then, it's not my fault that it didn't just segfault.
17:48:27 <BMeph> That "J monad" looks suspiciously like Martin Escardo's Cantor space search functions. See: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
17:48:56 <dolio> Yeah, roconnor said that's who brough up J.
17:49:03 <dolio> Brought up, even.
17:49:30 <ksf> ok, next question: how _do_ I bend stdout?
17:49:38 <dmwit> "bend"?
17:49:44 <ksf> redirect.
17:50:41 <jfoutz> in think the system.io stuff will help. the stdout handle is there.
17:50:42 <Pseudonym> So where did it actually come from?
17:50:45 <Pseudonym> J, that is.
17:50:53 <BMeph> It's funny, I remember commenting on a blog where he (Escardo) wrote about those, saying that it looked like a monad. Then I saw roconnor's reddit post, and laughed out loud. :)
17:50:58 <Pseudonym> I've been mucking with it for a few minuites.
17:51:24 <Pseudonym> Has anyone verified that it satisfies the Monad laws?
17:51:47 <dolio> roconnor said he was talking with Martin Escardo (I think), and it was brought up as an alternative way to encode classical logic in constructive logic, or something.
17:52:18 <dolio> Although I don't know how, exactly.
17:52:28 <Pseudonym> So why did roconnor ask reddit instead of Martin Escardo?
17:52:50 <dolio> I don't know.
17:53:17 <Pseudonym> That's kind of like asking Yahoo Answers or YouTube commenters, isn't it?
17:53:18 <Saizan> i think it was more like a talk he didn't understand completely
17:53:43 <BMeph> Pseudonym: I'll check the blog; maybe Dr. Escardo pointed out a counter-case to it's being a monad.
17:54:01 <Pseudonym> Right.
17:54:18 <Pseudonym> I'm currently trying to verify if join . fmap join = join . join or not.
17:54:44 <Pseudonym> In Haskell, the easy cases are easy because they're free theorems.
17:56:09 <BMeph> Well, Dr. E's example specifically works with r :: Bool, and he makes it a Monad. I'm not sure how generally it applies, though.
17:56:31 <Pseudonym> Right.
17:56:46 <Pseudonym> Then it's likely to be a real Monad.
17:57:17 <Pseudonym> Oh, of course, Duh.
17:57:30 <Pseudonym> a is only in positive positions.
17:57:35 <Pseudonym> So yes, it's a Monad.
17:57:44 <BMeph> instance J Functor where fmap f xs = J(\q -> f(unJ xs (\x -> q(f x))))
17:59:26 <BMeph> Hold on, J has two arguments; let me figure out how that converts to the "r :: Bool" version...
17:59:58 <jfoutz> it ignores it. always
18:00:11 <BMeph> Well, first of all, I messed up the instance declaration.
18:00:35 <jfoutz> > (unJ $ return 1 >>= \x -> return (x+1) >>= \x-> return (x+1) ) (const False)
18:00:37 <lambdabot>   Not in scope: `unJ'
18:00:40 <Saizan> ?djinn (a -> b) -> J r a -> J r b
18:00:40 <lambdabot> f a b c = a (b (\ d -> c (a d)))
18:01:17 <jfoutz> oh, r is the used one and a is the ignored one. *blush*
18:01:18 <Saizan> which is the same as what you wrote above
18:03:41 <Saizan> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ <- here the (a -> r) is used as a predicate to search for a suitable 'a'
18:03:47 <Saizan> right?
18:04:06 <dolio> Yes.
18:04:07 <BMeph> Saizan: Right.
18:05:41 <copumpkin> damn netsplit
18:06:33 * ksf is unable to find anything useful with google
18:06:56 <ksf> I want to redirect stdout/sterr for a library I'm dlopening.
18:07:40 <ksf> that is, I need the true C stdout to be bend, don't care much what happens to haskell's notion of stdout, but _don't_ want to have a second process.
18:08:18 <Vanadium> That is dup2?
18:08:27 <Saizan> maybe there's something in System.Posix?
18:08:38 <Vanadium> FFI'ing it in should not be too much hassle
18:10:18 <copumpkin> damn, I'm not sure GHC is smart enough
18:11:26 <Saizan> to?
18:11:46 <Vanadium> ksf: Does http://book.realworldhaskell.org/read/systems-programming-in-haskell.html#systems.piping.theory help?
18:11:50 <Saizan> (did you prove that lemma in the end?)
18:12:30 <copumpkin> Saizan: I proved the lemma but couldn't get the commutativity thing to accept it :/
18:13:01 <Saizan> ah, weird, maybe some problem with instantiation?
18:13:42 <ksf> erm no not really.
18:13:52 <copumpkin> Saizan: yeah :/
18:13:59 <copumpkin> now I'm playing with other somewhat related stuff
18:14:19 <Vanadium> ksf: Then I misunderstood what you are after.
18:14:20 <copumpkin> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8383#a8383
18:14:24 <Saizan> do you have the code handy?
18:14:48 <copumpkin> Saizan: oh, the original code, sure
18:15:43 <ksf> I want to listen on that redirected stdout, have it disappear on the original stdout, but still want to do my own output (possibly on another handle)
18:16:12 <copumpkin> Saizan: here's the relevant parts (there's a lot more surrounding shit that isn't interesting) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8384#a8384
18:16:33 <blackh> ksf: You can do all that kind of stuff with dup2
18:16:40 <Vanadium> ksf: Huh, I thought that was pretty much what that section was going on about.
18:16:49 <copumpkin> Saizan: I called the lemma reverseS (as it was sort of the obvious type family with the arguments reversed)
18:17:00 <Vanadium> I mean, you would skip the whole fork/exec shenanigans
18:17:32 <copumpkin> I can do
18:17:33 <copumpkin> id :: Replicate (S Z) ((->) Int) Int
18:17:35 <copumpkin> and it'll work
18:17:42 <ksf> but that dup2 trick depends on fork
18:17:47 <ksf> ...afaiu.
18:18:45 <copumpkin> am I misunderstanding something or is the type system not expressive enough to do what I'm trying to do
18:19:11 <copumpkin> AnyFunction (id :: Replicate (S Z) ((->) Int) Int)
18:19:15 <copumpkin> is what I'm trying
18:19:33 <blackh> ksf: I am not paying attention so I may have missed something, but dup2 is quite separate from fork.
18:19:44 <Elly> I appear to have forgotten why alpha-varying during substitution is necessary
18:19:49 <Elly> can someone refresh my memory?
18:20:25 <ksf> ...dup2 copies, it doesn't redirect.
18:20:34 <dolio> (\x y -> x y) y?
18:20:48 <ksf> so, to make it redirect, I'd have to have a second process, which I don't.
18:21:28 <blackh> ksf: You could use a pipe, but you would need something (another thread would be fine) to empty the pipe so the caller doesn't block indefinitely.
18:21:32 <Saizan> copumpkin: does that typecheck? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8384#a8385
18:21:35 <ksf> as afaik you can only have one handle named 0 in a process.
18:21:45 <blackh> ksf: A pipe from the pipe() function, that is.
18:22:11 <Vanadium> ksf: I hacked together http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8386#a8386 -- not sure whether I am using the System.Posix stuff correctly, but it seems to do what you described
18:22:13 <blackh> ksf: You can use dup2() to make stdout write to any file handle you like (but you don't need a pipe for that).
18:22:24 <copumpkin> Saizan: zomg, it does
18:22:34 <copumpkin> Saizan: why do I need to add the parameters to reverseS?
18:23:19 <Vanadium> ksf: dup copies, but dupTo lets you copy over an existing file descriptor, overwriting it, and effectively redirecting output to the overwritten file descriptor towards whatever you overwrote it with.
18:23:36 <Saizan> copumpkin: otherwise there's no way for ghc to instantiate the 'x' and 'y' variables in the type of reverseS with the 'z' and 'y' of induct
18:23:45 <copumpkin> hmm
18:24:02 <copumpkin> oh, I was hoping I could just cast it with scoped type variables
18:24:05 <copumpkin> that's what I was trying before
18:24:15 <copumpkin> not cast, but annotate its type
18:24:24 <Saizan> since 'x' and 'y' appeared only as arguments to type synonyms you couldn't use annotations
18:24:24 <dolio> Type family checking is a little weird.
18:24:34 <copumpkin> ah
18:24:48 <Saizan> since type synonym families are not guaranteed to be injective
18:24:56 <copumpkin> ah
18:25:05 <copumpkin> that may be my problem with the function of n arguments too?
18:25:25 <copumpkin> or is that just fundamentally impossible? :P
18:25:46 <Saizan> maybe so, yeah :)
18:25:54 <ksf> my brain is going to need some time to accustom itself to that evilness.
18:25:56 <dolio> Function of n arguments?
18:26:03 <Saizan> the problem is that AnyFunction (id :: Replicate (S Z) ((->) Int) Int) doesn't typecheck?
18:26:08 <copumpkin> this works though
18:26:11 <EvilTerran> i think you can do "function of n arguments" with type families
18:26:11 <copumpkin> Saizan: yeah
18:26:12 <copumpkin> *Main> (id :: Replicate (S Z) ((->) Int) Int) 5
18:26:12 <copumpkin> 5
18:26:15 <copumpkin> that works fine though
18:27:09 <EvilTerran> altho it'd need some type equality constraints that may well need -XUndecidableInstances, if they work at all, to be able to infer n from the environment as well
18:27:12 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8383#a8388 <- well, it doesn't resolve the variables
18:27:19 <copumpkin> EvilTerran: that's what I'm doing
18:27:30 <EvilTerran> so i see
18:27:45 * EvilTerran wandered in in the middle of the conversation, and became instantly intrigued by Saizan's previous paste
18:28:02 <Saizan> copumpkin: if you want to infer 'n' you need a type family that calculates it from the type of the function, i think
18:28:02 <Vanadium> Funny that the posix file descriptor based IO functions take only strings and not arrays or bytestrings or whatever :|
18:28:07 <copumpkin> EvilTerran: my problem is with "hiding" the n arguments behind an existential
18:28:41 <copumpkin> Saizan: hmm
18:29:18 <dolio> The problem is that "Replicate (S Z) ((->) Int) Int" reduces to "Int -> Int", and it can't deduce the unreduced version due to lack of injectivity.
18:29:23 <copumpkin> Saizan: so I'd need an inverse to the Replicate function basically?
18:29:49 <dolio> At least, that's my guess.
18:29:53 <copumpkin> to show GHC that it's injective and allow it to figure out n given a replicated version
18:30:54 <dolio> What if you make "AnyFunction :: n -> Function n a b -> AnyFunction a b"?
18:31:11 <copumpkin> ooh, good idea
18:31:28 <copumpkin> that does work
18:31:51 <copumpkin> so I guess that shows that GHC just doesn't know how to invert my not-necessarily-injective type function, unsurprisingly
18:32:19 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8383#a8389 <- heh i just pasted that :)
18:32:28 <dolio> Yeah. Explicitly dealing with foralled parameters gets somewhat attractive doing this stuff.
18:32:47 <copumpkin> :)
18:33:00 * copumpkin tries to see if he can coax inference out of GHC
18:33:11 <Saizan> that's why i want explicit instantiation since type families came out :) i should make a serious proposal one day :)
18:33:27 <copumpkin> what would it look like?
18:33:29 <copumpkin> (yeah!)
18:33:55 <dolio> It looks kind of like "foo@T" in the core.
18:34:26 <copumpkin> alright, Unreplicate is proving rather more difficult than I predicted
18:34:31 <Saizan> like AnyFunction@(S Z) rather than AnyFunction (undefined :: S Z)
18:35:05 <Saizan> (but @ might not be the best syntax)
18:36:06 <dolio> It's already reserved, at least, although the way its reserved might conflict with ways you'd want to use it in the type applications.
18:36:43 <BMeph> :=, maybe? :)
18:37:10 <copumpkin> I'm starting to feel that Unreplicate is impossible to write
18:39:31 <Saizan> i'm not sure what you'll able to do with an AnyFunction though
18:39:44 <Saizan> "be able"
18:39:49 <copumpkin> :P
18:40:13 <copumpkin> haven't quite decided
18:40:22 <copumpkin> it's just me experimenting with all the crazy stuff
18:40:36 <Cale> Are you abling to do it? ;)
18:41:10 <dolio> If you have a GADT "Nat n" indexed by the type-level naturals, and store it in the AnyFunction, you'll be able to recover the original function.
18:41:35 <copumpkin> dolio: I have something similar but not in a GADT
18:42:00 <EvilTerran> .oO(  = 1 :: Peano )
18:43:19 <Saizan>  ?
18:46:57 <copumpkin> > dataTypeName . dataTypeOf $ (id :: Int -> Int)
18:46:58 <lambdabot>   "Prelude.(->)"
18:52:46 <copumpkin> *Main> map showAnyFunction [x, y]
18:52:46 <copumpkin> ["Moo -> Baa","Moo -> Moo -> Baa"]
18:53:10 <copumpkin> not sure how much use that is
18:53:48 <copumpkin> hmm
18:54:25 <copumpkin> dataTypeName (dataTypeOf (undefined :: a)) isn't allowed, with scoped tyvars and a an instance of Data?
18:54:40 <copumpkin>     Ambiguous type variable `a' in the constraint:
18:55:26 <aavogt> Cale: in #xmonad I have a second lambdabot that fails to import xmonad modules qualified with as XYZ
18:55:55 <copumpkin> oh duh
18:55:59 <copumpkin> I forgot my forall, as usual
18:56:23 <aavogt> this puzzles me, since I've done the same kind of import in State/imports.h as happens for Data.Map
18:57:16 <aavogt> @type P.head -- shouldn't this work properly?
18:57:17 <lambdabot> Couldn't find qualified module.
18:58:05 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8390#a8390
18:59:32 <Cale> aavogt: It's really complicated and silly. There's a module in mueval which has its own list of the packages to be imported. I'm not 100% sure why it's necessary, but it seems to be.
19:01:51 <aavogt> Cale: I can bring stuff into scope by adding the imports to that State/imports.h... so its only messing up the 'as W' options
19:01:59 <aavogt> without messing with mueval
19:05:30 <Rotaerk> is there an IO () that simply does nothing
19:05:35 <aavogt> return ()
19:05:46 <Rotaerk> ah cool
19:05:46 <copumpkin> magick!
19:06:28 <path[l]> anyone know if there is a variant of List.subsequences that gives the subsequences to me in order of size
19:06:56 <path[l]> important thing being, Id like the items with more elements to be calculated lazily
19:07:08 <pikhq> sortBy (comparing length) . subsequences -- ?
19:07:24 <aavogt> @type subsequences
19:07:26 <lambdabot> forall a. [a] -> [[a]]
19:07:41 <jfoutz> > subsequences "hello"
19:07:41 <aavogt> @index subsequences
19:07:41 <lambdabot> bzzt
19:07:43 <lambdabot>   ["","h","e","he","l","hl","el","hel","l","hl","el","hel","ll","hll","ell","...
19:07:56 <pikhq> @src subsequences
19:07:56 <lambdabot> Source not found. :(
19:08:03 <ksf> forkIO does some really strange things to stdout.
19:08:05 <path[l]> the code is present, it sorta does a foldr for performance reasons I guess. So it could technically work on infinite lists
19:08:24 <path[l]> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#subsequences
19:08:38 <vinicius> wat
19:10:04 <path[l]> hmm maybe I could think of it as a function which takes a parameter limiting the size of the subsequences to that length? Kinda like the ruby variant "combinations"
19:11:42 <canvon> ksf: maybe forkOS would help?
19:16:16 <ksf> nah I'm confused by the fact that I can save stdout, fork a thread and reassign stdout, and then restore the original stdout in the original thread.
19:24:20 <Saizan> aavogt: solved? i think you have to add the imports to ~/.lambdabot/State/L.hs actually
19:26:35 <aavogt> Saizan: that works!
19:26:35 <ksf> no I can't.
19:26:37 <aavogt> thanks
19:26:44 <ksf> it's just a timing thing.
19:27:09 <ksf> ...forkOS has a better timing, but a simple threadDelay destroys the illusion.
19:27:47 <ksf> and, frankly, messing around with another thread's stdout handle is more than messy.
19:28:17 <ksf> it'd be evil, if there was any use in doing such a thing.
19:34:31 <ksf> that dinosaur of an api called posix just isn't meant to run multiple threads in one process.
19:39:35 <mxc> are there haddock docs anywhere online for ghc 6.12 or do you need to download and build yourself?
19:48:05 <shapr> yay?
19:49:03 <Nafai> Hey shapr
19:50:31 <Axman6> 
19:50:46 <Axman6>  -- correct inversion
20:36:15 <fbru02> @src getStdRandom
20:36:15 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:37:46 <drwho> anyone know the name of a haskell disassembler?
20:37:55 <drwho> someone suggested me one in here before
20:38:07 <copumpkin> haskell disassembler?
20:38:19 <copumpkin> haskell is compiled to native code
20:38:34 <copumpkin> and its bytecode for ghci isn't ever saved to disk
20:38:49 <drwho> no not for disassembling haskell
20:38:58 <copumpkin> oh, harpy
20:39:02 <drwho> yes
20:39:03 <copumpkin> @hackage harpy
20:39:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy
20:39:09 <copumpkin> not a huge fan of its api though
20:39:15 <copumpkin> for disassembling
20:39:19 <copumpkin> but it does it
20:39:25 <drwho> thank you
20:39:33 <drwho> I was thinking of making one for x86-64
20:39:50 <copumpkin> oh yeah
20:40:45 <drwho> yeah I am interested in how haskell would handle dissassembly
20:41:05 <drwho> the computer I develope on is an AMD64 though
20:41:10 <copumpkin> me too :) I've written most of a disassembler for ARM but it's not in a workable state right now
20:41:31 <drwho> interesting
20:41:44 <drwho> I haven't worked with ARM much
20:43:01 <copumpkin> data Orange
20:43:03 <copumpkin> data Apple
20:55:14 <mmorrow> @bot
20:55:14 <lunabot>  :)
20:55:27 <lambdabot> :)
20:55:59 <copumpkin> @boot
20:55:59 <lambdabot> Unknown command, try @list
21:01:23 <moonpatrol> @list
21:01:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:02:16 <moonpatrol> @vixen
21:02:17 <lambdabot> what is pron?
21:02:24 <moonpatrol> O_o
21:02:47 <moonpatrol> @elite
21:02:48 <lambdabot> Say again?
21:02:59 <moonpatrol> @slap #haskell
21:03:00 * lambdabot hits #haskell with an assortment of kitchen utensils
21:03:29 <moonpatrol> well that brought some life to the room
21:03:58 <mmorrow> i think i just made djinn loop
21:04:00 <mmorrow> @djinn DJ (DJ a o) a -> DJ (DJ o a) (DJ (DJ o a) a)
21:04:15 <lambdabot> No output from Djinn; installed?
21:04:17 <mmorrow> @djinn a -> a
21:04:17 <lambdabot> f a = a
21:08:12 <drwho> ah seems I need to get some packages to run harpy
21:08:37 <drwho> I'm going to go sleep and do that later
21:08:41 <drwho> thanks again
21:12:40 * mmorrow apologizes in advance for what he's about to do
21:12:44 <mmorrow> @djinn DJ (DJ o a) (DJ (DJ o a) a) -> DJ (DJ a (DJ o a)) a
21:12:47 <lambdabot> f a =
21:12:47 <lambdabot>     case a of
21:12:47 <lambdabot>     DJ b -> DJ (\ c ->
21:12:47 <lambdabot>                 case b (\ d ->
21:12:47 <lambdabot>                         case d of
21:12:49 <lambdabot>                         DJ e -> DJ (\ _ -> e (\ f -> DJ (\ _ -> f)))) of
21:12:51 <lambdabot>                 DJ g -> g (\ h ->
21:12:53 <lambdabot>                            case c h of
21:12:55 <lambdabot>                            DJ i -> DJ (\ j ->
21:12:58 <lambdabot>                                        case i (\ _ -> h) of
21:13:00 <lambdabot> Plugin `djinn' failed with: thread killed
21:13:18 <mmorrow>                                         DJ k -> k (\ _ -> j h))))
21:13:29 <moonpatrol> ha
21:13:43 <moonpatrol> @vixen
21:13:44 <lambdabot> ?
21:16:05 <mmorrow> @djinn DJ o (DJ o a) -> DJ o a
21:16:06 <lambdabot> f a =
21:16:06 <lambdabot>     case a of
21:16:06 <lambdabot>     DJ b -> DJ (\ c ->
21:16:06 <lambdabot>                 case b (\ d ->
21:16:06 <lambdabot>                         case d of
21:16:08 <lambdabot>                         DJ e -> c (e c)) of
21:16:10 <lambdabot>                 DJ f -> f c)
21:16:33 <mmorrow> djinn would totally be useful to autogen monad instances
21:16:46 <mmorrow> djinn + TH == win
21:17:35 <mmorrow> @djinn DJ (DJ a o) a -> DJ o a
21:17:36 <lambdabot> f a =
21:17:36 <lambdabot>     case a of
21:17:36 <lambdabot>     DJ b -> DJ (\ c -> b (\ d -> DJ (\ _ -> c d)))
21:19:30 <mmorrow> @djinn (a -> ((o->a)->o)) -> a) -> ((a->o)->a)
21:19:30 <lambdabot> Cannot parse command
21:19:38 <mmorrow> @djinn ((a -> ((o->a)->o)) -> a) -> ((a->o)->a)
21:19:38 <lambdabot> f a b = a (\ c _ -> b c)
21:22:39 <mmorrow> , let expand o a = parens (a <+> text "->" <+> o) <+> text "->" <+> a; [o,a] = fmap text ["o","a"] in expand (expand o a) (expand (expand o a) a) <+> text "->" <+> expand (expand a (expand o a)) a
21:22:41 <lunabot>  ((a -> (a -> o) -> a) -> a -> (a -> o) -> a) -> (a -> (a -> o) -> a) -> a...
21:23:37 <hackagebot> bytestringparser-temporary 0.0.0 - Combinator parsing with Data.ByteString.Lazy (JasonDusek)
21:25:11 <mmorrow> this is that massive above nested case, but without the datatype noise
21:25:12 <mmorrow> @djinn ((((a)->(((a)->(o))->(a)))->(a))->(((a)->(o))->(a)))->(((a)->(((a)->(o))->(a)))->(a))->((a)->(((((a)->(o))->(a))->(a))->(((a)->(o))->(a))))->(a)
21:25:12 <lambdabot> f _ a b = a (\ c d -> b c (\ _ -> c) (\ _ -> d c))
21:25:39 <mmorrow> @. pl djinn ((((a)->(((a)->(o))->(a)))->(a))->(((a)->(o))->(a)))->(((a)->(((a)->(o))->(a)))->(a))->((a)->(((((a)->(o))->(a))->(a))->(((a)->(o))->(a))))->(a)
21:25:40 <lambdabot> f = const (. flip (ap . ((.) .) . (`ap` const)) ((const .) . flip id))
21:26:07 <drwho> djinn is crazy
21:26:14 <pikhq> Well, that is well-typed, so I know it does *something*.
21:26:20 <pikhq> But is it even vaguely useful?
21:26:52 <pikhq> (also, that's the nice thing about Haskell: if it types, it does something. :))
21:27:39 <mmorrow> @djinn ((((a->o)->o) -> ((b->o)->o)) -> ((a->o)->o)) -> ((a->o)->o)
21:27:40 <lambdabot> f a b = a (\ c _ -> c b) b
21:27:44 <mmorrow> is callCC unrwapped
21:28:01 <mmorrow> @src Cont callCC
21:28:01 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
21:28:13 <dolio> @djinn-add type Cont r a = (a -> r) -> r
21:28:33 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
21:28:33 <lambdabot> f a b = a (\ c _ -> b c) b
21:28:44 <mmorrow> oops
21:28:55 <mmorrow> err
21:29:12 <mmorrow> oh right
21:29:35 <mmorrow> s/((a->o)->o)/a/
21:32:12 <chowmeined> how would one go about handling async socket messages? if one was using threads and channels for example, where the thread reads from the socket (blocking), doesnt that block writes then? should there be two threads per socket?
21:52:49 <blackh> chowmeined: Yes, you need two threads per socket. Remember that GHC has very light-weight threads, so it doesn't suffer from the usual scalability problems due to too many threads.
21:55:46 <chowmeined> blackh, ok, thanks
22:39:38 <roconnor_> @djinn DJ r (Either a (a -> r))
22:39:39 <lambdabot> f = DJ (\ a -> Right (\ b -> a (Left b)))
22:41:19 <roconnor_> @djinn DJ r (((a -> r) -> a) -> a)
22:41:20 <lambdabot> f = DJ (\ a b -> b (\ c -> a (\ _ -> c)))
22:41:25 <copumpkin> roconnor_: any revelations in your sleep?
22:41:30 <copumpkin> now I'm curious too
22:41:39 <copumpkin> not much on the reddit thread yet
22:41:39 <roconnor_> nope
22:41:50 <roconnor_> just adding the logical functions to the post
22:42:21 <roconnor_> @djinn DJ r a -> Cont r a
22:42:21 <lambdabot> f a b =
22:42:22 <lambdabot>     case a of
22:42:22 <lambdabot>     DJ c -> b (c b)
22:42:37 <dibblego> @hoogle mod
22:42:38 <lambdabot> Prelude mod :: Integral a => a -> a -> a
22:42:38 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
22:42:38 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
22:42:51 <dibblego> can I get 2.3 `mod` 2 = 0.3 ?
22:43:34 <copumpkin> :t mod'
22:43:37 <lambdabot> forall a. (Real a) => a -> a -> a
22:43:42 <dibblego> ah
22:43:44 <copumpkin> > 2.3 `mod'` 2
22:43:46 <lambdabot>   0.2999999999999998
22:43:50 <copumpkin> lol
22:44:26 <copumpkin> > 2.3 `mod'` 1.3
22:44:28 <lambdabot>   0.9999999999999998
22:44:53 <d4> so I'm not experienced enough with monads to know, but I have this intuition
22:45:27 <d4> has anyone seen Prolog-style code written monadically in Haskell
22:45:28 <d4> ?
22:46:28 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2004-August/006698.html
22:46:42 <copumpkin> http://www.haskell.org/haskellwiki/Logic_programming_example
22:47:02 <roconnor_> @index mod'
22:47:03 <lambdabot> bzzt
22:47:10 <copumpkin> Data.Fixed
22:47:17 <d4> thx copumpkin
22:47:21 <copumpkin> seems like an odd place to put it
22:47:50 <d4> let me see how those pages look in my console browser
22:51:11 <d4> pretty good actually
22:51:32 <d4> ...funny, it was the list monad that gave me this intuition in the first place
22:52:18 <roconnor_> copumpkin: ah, escardo's search monad is J bool
22:52:51 <copumpkin> roconnor_: J Cantor Bool ?
22:53:01 <roconnor_> no
22:53:11 <roconnor_> J Bool Cantor
22:53:13 <copumpkin> oh J Bool Cantor
22:53:13 <copumpkin> yeah
22:53:30 <roconnor_> *sigh*
22:53:35 <roconnor_> If only I had read further down.
22:53:41 <roconnor_> before posting
22:54:20 <BMeph> What's up - y'all're still hashing out that J monad thing? :)
22:54:33 <copumpkin> but it's still interesting to think of what it measn to not be J Bool
22:54:35 <roconnor_> BMeph: I woke up
22:55:03 <BMeph> roconnor: Oh, well that's allowed... ;p
22:55:41 <copumpkin> his coding style is interesting
22:56:52 <roconnor_> copumpkin: how do you mean?
22:57:00 <BMeph> I think it was 'migmit' in the second blog comments who observed that Dr. E's S monad worked more generally in form as your J monad is typed. I wonder, though, if it doesn't somehow rely on some monoidal properties of r...
22:57:31 <copumpkin> f(...) instead of f (...) or f $ ...
22:58:28 <BMeph> I think http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/#comment-11075 is the one in question.
22:59:02 <copumpkin> or by the comment above that, I meant that J is more general than his S monad... which makes me wonder whether there's an interesting interpretation for J (something that isn't Bool)
22:59:16 <copumpkin> oh ok
22:59:34 <copumpkin> I guess that's exactly J then
23:01:44 <BMeph> Now the interesting thing is...how oleg's take on it changes things - it's on my short read-list, but I haven't done it yet.
23:06:58 <BMeph> FYI: oleg's take on it is: http://okmij.org/ftp/Algorithms.html#total-sp
23:08:03 <roconnor_> copumpkin: huh, is J somehow the same as J Bool?
23:08:12 <copumpkin> ?
23:08:24 <copumpkin> no, I meant the comment that BMeph mentioned
23:08:26 <roconnor_> [01:59] <copumpkin> I guess that's exactly J then
23:08:27 <BMeph> S is J Bool. :)
23:08:43 <roconnor_> that being 'S' and 'S' being 'J Bool'
23:08:59 <copumpkin> in that comment he linked to, someone suggests generalizing it beyond Bool
23:09:06 <roconnor_> ah
23:09:09 <roconnor_> right
23:09:10 <BMeph> roconnor_: [__:58] <BMeph> I think http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/#comment-11075 is the one in question.
23:09:28 <c_wraith> @hoogle set
23:09:29 <lambdabot> module Data.Set
23:09:29 <lambdabot> Data.Set data Set a
23:09:29 <lambdabot> System.Posix.Internals set_console_buffering :: CInt -> CInt -> IO CInt
23:09:44 <c_wraith> :t Set
23:09:45 <lambdabot> Not in scope: data constructor `Set'
23:09:55 <c_wraith> Boo.
23:10:22 <dibblego> @pl \a b -> (f a b, g a b)
23:10:23 <lambdabot> ap (ap . ((,) .) . f) g
23:10:27 <dibblego> bleh
23:10:33 <BMeph> @src Data.Set.Set
23:10:33 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:10:55 <c_wraith> I just want to know what the constraint on the type of a is.
23:11:14 <c_wraith> I suppose I can look at the docs. :)
23:11:14 <BMeph> Ord a, I believe.
23:11:18 <copumpkin> dibblego: seems there should be something prettier than that
23:11:27 <dibblego> copumpkin, indeed (&&&) perhaps
23:11:49 <BMeph> More like (&&&).(&&&), or some-such. :)
23:12:07 <copumpkin> :t (&&&).(&&&)
23:12:09 <lambdabot> forall c' (a :: * -> * -> *) b c c'1. (Arrow a) => a b c -> (a b c'1 -> c') -> a b c'1 -> (a b (c, c'1), c')
23:12:14 <c_wraith> yeah, it's Ord
23:12:16 <c_wraith> hmm
23:12:19 <c_wraith> @instances Ord
23:12:19 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:12:31 <copumpkin> c_wraith: makes sense :P
23:12:49 <c_wraith> Only if the implementation is efficient. :)
23:12:53 <copumpkin> :t uncurry
23:12:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:13:25 * roconnor_ needs to go to breakfast
23:13:47 <copumpkin> @type \f g -> curry (uncurry f &&& uncurry g)
23:13:48 <lambdabot> forall a b c c1. (a -> b -> c) -> (a -> b -> c1) -> a -> b -> (c, c1)
23:14:03 <copumpkin> dibblego: is that it?
23:14:13 <dibblego> yeah pretty much
23:14:14 <c_wraith> No Array instance for Ord.  I think this should tell me I'm trying to solve this problem wrong
23:14:18 <copumpkin> or to golf even more
23:14:29 <copumpkin> @type \f g -> curry ((&&&) `on` uncurry)
23:14:31 <lambdabot>     Couldn't match expected type `(a, b)'
23:14:31 <lambdabot>            against inferred type `a1 -> b1 -> c'
23:14:31 <lambdabot>     In the second argument of `on', namely `uncurry'
23:14:34 <copumpkin> dammit :P
23:14:45 <copumpkin> @type \f g -> curry (((&&&) `on` uncurry) f g)
23:14:47 <lambdabot> forall c a b. (a -> b -> c) -> (a -> b -> c) -> a -> b -> (c, c)
23:14:57 <copumpkin> @pl \f g -> curry (((&&&) `on` uncurry) f g)
23:14:58 <lambdabot> (curry .) . ((&&&) `on` uncurry)
23:15:02 <copumpkin> lol
23:16:24 <BMeph> Technically, shouldn't Set's constraint just be Eq a, but we use Ord a because of our implementation? :\
23:16:49 <copumpkin> BMeph: yeah, but such are the realities of computer science :P
23:17:00 <Berengal> Set isn't a set, it's a tree
23:17:20 <copumpkin> you're abstracted from that though
23:17:33 <copumpkin> it's something that behaves like a set if you have an ordering on your elements
23:17:39 <Berengal> Not entirely, due to the Ord constraints
23:17:48 <Berengal> But as you said, that's the realities of computer science
23:18:08 * copumpkin writes an Ord instance for functions
23:18:18 <copumpkin> the world's slowest ord instance
23:18:52 <BMeph> copumpkin: Doesn't Ord a need Eq a? ;)
23:18:53 <Saizan> copumpkin: that'd be handy!
23:19:04 <copumpkin> BMeph: I already have that though
23:19:15 <copumpkin> Saizan: :D
23:19:28 <copumpkin> it's the world's slowest Eq instance
23:19:34 <BMeph> copumpkin: Now, THAT would be handy...! :)
23:19:34 <Berengal> How is ordering defined on functions anyway?
23:19:37 <copumpkin> but it'll look fast compared to my Ord instance
23:19:46 <copumpkin> Berengal: the order I enumerate them in ;)
23:20:04 <copumpkin> x < y if x appears before y in the big list of all functions
23:20:14 <Berengal> copumpkin, I don't think that's too useful
23:20:19 <copumpkin> lol
23:20:22 <copumpkin> why not??
23:20:42 <Berengal> Because the domain is conceptually unordered
23:20:51 <Berengal> You need to reinvent mathematics
23:20:58 <copumpkin> why?
23:21:14 <copumpkin> just because nobody's defined an ordering on it doesn't mean that doing so would break anything else
23:21:21 <Berengal> Well, not all of it, obviously, only the parts that say the domain is a set
23:21:21 <BMeph> I've always wondered how you can get an unordered structure on something, when your "implementation medium" is inherently ordered...
23:22:58 <Berengal> In general, I use the phrase "You need to reinvent mathematics!" whenever I want to write something that would be consistent, but violates normal assumptions
23:23:41 <BMeph> Berengal: Interesting; I use "UR DOIN IT RONG!" for the same purpose. :)
23:23:49 <c_wraith> You can order implementations of functions easily enough
23:23:54 <Berengal> BMeph, we should concatenate
23:24:00 <copumpkin> hey, whatever it takes to stick functions into a Set!
23:24:16 <BMeph> Berengal: "U need 2 do it rong"? ;p
23:24:31 <copumpkin> of course, given the rather slow instance, it might be faster sticking functions into a list and using lookup than sticking them into a set :P
23:24:40 <Berengal> > "You need to reinvent mathematics!" ++ "UR DOIN IT RONG!"
23:24:42 <lambdabot>   "You need to reinvent mathematics!UR DOIN IT RONG!"
23:25:27 <Berengal> copumpkin, you'll most likely want to perform a schwartzian transform before putting them in a set...
23:25:36 <c_wraith> [1, 2].second
23:25:40 <c_wraith> > [1, 2].second
23:25:42 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
23:25:47 <copumpkin> Berengal: well even a single call to < would take a long long time
23:26:19 <BMeph> Berengal: Now that I think on it, I also use that phrase when someone else is being inconsistent, but not violating normal assumptions. Hmm, that's kind of confusing. ;)
23:26:21 <copumpkin> > [1..].fourteenthousandfourhundredandfiftsecond
23:26:23 <lambdabot>   Not in scope: `fourteenthousandfourhundredandfiftsecond'
23:26:58 <c_wraith> @hoogle [a] -> Int -> a -> [a]
23:26:59 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
23:26:59 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
23:26:59 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
23:27:16 <Berengal> Work, time to go
23:27:33 <copumpkin> c_wraith: what will that do?
23:27:42 <copumpkin> insert the element into the specified location?
23:27:43 <BMeph> > let second = (!!1) in second [1,2]
23:27:45 <lambdabot>   2
23:27:55 <c_wraith> I was actually looking for replacing the element at the location
23:28:09 <c_wraith> I really want to use arrays
23:28:16 <copumpkin> why not then?
23:28:19 <c_wraith> But I don't want to implement Ord for arrays
23:28:20 <c_wraith> :)
23:28:28 <BMeph> > let fourteenthousandfourhundredandfiftsecond = (!!14451) in fourteenthousandfourhundredandfiftsecond [1..]
23:28:30 <lambdabot>   14452
23:30:32 <copumpkin> c_wraith: it wouldn't really be very hard
23:30:34 <c_wraith> Hmm.  Arrays almost have an Ord instance
23:30:46 <c_wraith> :t cmpArray
23:30:47 <lambdabot> Not in scope: `cmpArray'
23:30:55 <c_wraith> :t Data.Array.cmpArray
23:30:56 <lambdabot> Not in scope: `Data.Array.cmpArray'
23:31:15 <c_wraith> cmpArray :: (Ix i, Ord e) => Array i e -> Array i e -> Ordering
23:31:27 <copumpkin> there you go!
23:31:35 <c_wraith> I guess, given that, an instance for the particular array I'm using would be trivial
23:31:58 <copumpkin> well, it's not polymorphic
23:32:13 <copumpkin> if you're using a mutable one or an unboxed one, it won't work
23:32:17 <copumpkin> but you can steal its source code
23:32:29 <copumpkin> eww
23:32:29 <copumpkin> cmpArray arr1 arr2 = compare (assocs arr1) (assocs arr2)
23:32:31 <copumpkin> :P
23:33:03 <c_wraith> I clearly need a new strategy for solving this problem.  sets of arrays isn't going to do the job.
23:33:12 <copumpkin> what's the problem?
23:33:23 <c_wraith> I mean, it would solve it...  But suboptimally
23:33:32 <c_wraith> project euler 31
23:33:47 <c_wraith> Really, I should attack it combinatorially, rather than via dynamc programming
23:34:00 <copumpkin> oh :)
23:34:16 <copumpkin> I can't even remember how I did that one, but I had one very slow solution
23:34:19 <copumpkin> and one that took almost no time at all
23:34:53 <c_wraith> I currently have a DP solution that gets permutations, rather than combinations.  That's an amazingly huge number
23:34:54 <copumpkin> ah yes
23:36:28 <c_wraith> maybe I'll go play nethack instead
23:36:29 <c_wraith> :)
23:37:09 <BMeph> I think I used a list comprehension for that one somehow... :)
23:37:26 <copumpkin> it can be very concise
23:37:47 <copumpkin> I wonder if it's possible to use the list monad instance for it though
23:37:58 <copumpkin> at the time I was too clueless to know anything about monads or stuff
23:39:41 <BMeph> copumpkin: I may have done that, too, (just using 'guard' for the useful predicates). Now if only I remember where I put the thing...
23:40:26 <copumpkin> :)
23:40:30 <copumpkin> anyway, bedtime
23:40:30 <copumpkin> ciao
