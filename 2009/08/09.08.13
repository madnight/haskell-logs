01:04:26 <PetRat> @type
01:04:27 <lambdabot> on the commandline:
01:04:27 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
01:04:27 <lambdabot> <no location info>: not an expression: `'
01:04:33 <PetRat> @type lift
01:04:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:04:44 <PetRat> @type liftM
01:04:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:05:27 <PetRat> @type liftIO
01:05:29 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:21:15 <kkaji`>  Please help me -  http://www.lostworlds.lv/go.php?1139723800
01:42:52 <fasta> Is the author of hp2any-graph in this channel?
02:14:14 <jre2> anyone running ubuntu have a suggested ppa for haskell packages?
02:20:45 <fasta> jre2: no, but cabal install works fine for most packages.
02:28:39 <pao> hi all!
02:28:56 <pao> is the User's Guide for Cabal sufficiently up to date?
02:29:56 <dcoutts> pao: it's accurate
02:30:03 <dcoutts> what it says is still true
02:30:03 <pao> dcoutts: thanks
02:30:30 <dcoutts> pao: it doesn't document the cabal-install package, but there's a large common subset
02:31:12 <pao> dcoutts: well, if I stand correct it contains everything is needed for writing .cabal files, right?
02:31:30 <dcoutts> pao: yep
02:31:37 <pao> dcoutts: perfect, thanks
02:33:38 <pao> dcoutts: do you have any plan for the next release of cabal-install?
02:34:11 <mmorrow> preflex: zenv $dShow
02:34:16 <mmorrow> preflex: zenc $dShow
02:34:16 <preflex>  zddShow
02:34:36 <dcoutts> pao: do you mean features or ETA ?
02:34:43 <pao> dcoutts: ETA
02:34:56 <dcoutts> pao: not at the moment
02:35:12 <dcoutts> pao: there's an update in the 0.6.x series we could release
02:35:19 <dcoutts> but I don't have the time to do the testing
02:35:31 <dcoutts> if someone else wants to do it, that'd be cool :-)
02:36:48 <pao> dcoutts: don't want to make promises I cannot fullfil ... let's see if in septemer I'll be able to help out
02:37:16 <dcoutts> pao: the main thing is to run a regression test using hackage
02:37:50 <pao> dcoutts: is there some click and run script for the job?
02:38:42 <dcoutts> pao: almost: http://blog.well-typed.com/2009/03/regression-testing-with-hackage/
02:39:43 * pao is reading the blog article...
02:42:04 <mmorrow> @type
02:42:06 <lambdabot> on the commandline:
02:42:06 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
02:42:06 <lambdabot> <no location info>: not an expression: `'
02:42:35 <mmorrow> @type Language.Haskell.TH.Syntax.runIO
02:42:37 <lambdabot> forall a. IO a -> Language.Haskell.TH.Syntax.Q a
02:42:47 <mmorrow> @type $(Language.Haskell.TH.Syntax.runIO (readFile "/etc/password") >>= Language.Haskell.TH.Lib.conT . Language.Haskell.TH.Syntax.mkName)
02:42:49 <lambdabot> parse error on input `$'
02:42:51 <mmorrow> aww
02:42:53 <mmorrow> :)
02:43:32 <mmorrow> @type Unsafe.Coerce.unsafeCoerce
02:43:34 <lambdabot> forall a b. a -> b
02:47:34 <pao> dcoutts: how much would it cost to install every single hackage package with it's "ideal" dependency and restart from a scratch db every time rather than installing the biggest set as you are proposing?
02:49:32 <pao> dcoutts: ... ops... Isolated builds... you're writing about it...
02:49:43 <dcoutts> pao: you'd not want to start completely from scratch, there'd be a lot of rebuilding
02:50:06 <dcoutts> pao: but Igloo has another suggestion for how to build everything, by rolling back whenever you get conflicts
02:50:21 <dcoutts> pao: that's not automated yet though I think
02:50:46 <dcoutts> I'm quite satisfied with this approach as a regression test of cabal-install
02:50:58 <dcoutts> we don't need to build all packages for it to be a reasonable test
02:51:10 <dcoutts> and doing tricky dep solving is part of the test
02:52:08 <quicksilver> by comparison, the debian autobuilders always do revert to scratch between builds.
02:52:22 <quicksilver> but then installing binary packages (and removing them) is cheaper
02:55:34 <pao> dcoutts: I think that having the best set of libraries/dependencies for each binary could be really better that finding a shared common/compatible subset of dependencies that are maybe suboptimal with respect to the single binary... I guess I would need to try to write down some advocacy for it...
02:56:15 <dcoutts> pao: in theory there's nothing sub-optimal, it's either ok or it's not
02:57:17 <pao> dcoutts: well, not ok (not installable) is definitely suboptimal :-)
02:58:37 <pao> dcoutts: anyway... you definitely have more evidence than me ... I should really try out ...
02:58:40 <dcoutts> pao: it depends on the goal, if we want to test all the packages then yes that's true. If we want to test cabal-install then it doesn't matter so much.
02:59:38 <pao> dcoutts: yep
03:06:10 <pao> dcoutts: is there a simple explanation for ghc --abi-hash not being stable?
03:06:38 <dcoutts> pao: I'm not clear on it, you'll have to ask JaffaCake when he's back
03:07:04 <pao> dcoutts: JaffaCake is Simon Marlow?
03:07:09 <dcoutts> yep
03:07:13 <pao> ok
03:07:24 <DarkUnicorn> .oO(mmhhhh cakes)
03:38:55 <blueonyx>  is there some haskell on planar graphs?
04:45:52 <Itkovian> Haskell platform built on Ubuntu 9.04. Installing is teh fail though.
04:46:54 <Itkovian> mtl seems not to have been made. will gladly accept pointers.
04:49:04 <RayNbow> I don't have Ubuntu, but might this help http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/ ?
04:56:50 <Itkovian> RayNbow: thx. Manually building the unbuilt packages
05:13:52 <eflister> i'm in a function that has a stack MyWriterT (MyReaderT IO) ().  i want to call a function that is just a MyWriterT IO ().  so to get the type right, i have to insert MyReaderT into the middle of the stack.  is there a way to do this?  it seems like i could use mapWriterT...
05:15:29 <dschoepe> eflister: You probably want lift from Control.Monad.Trans
05:15:31 <dschoepe> @type lift
05:15:33 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:16:08 <eflister> as far as i can tell, lift doesn't let me insert stuff into the middle of the stack...
05:17:15 <Beelsebob> hey cool
05:17:20 <Beelsebob> a proper functional kernel
05:17:25 <Beelsebob> and formally proved correct!
05:17:30 <opqdonut> ???
05:17:35 <Beelsebob> http://tech.slashdot.org/story/09/08/13/0827231/Worlds-First-Formally-Proven-OS-Kernel?from=rss
05:18:06 <EvilTerran> ?type lift
05:18:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:18:24 <Axman6> Beelsebob: is it L4.Verified?
05:18:28 <EvilTerran> ?type return . lift
05:18:30 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t, Monad m1) => m1 a -> m (t m1 a)
05:18:37 * Axman6 waits for link to load slowly
05:18:38 <EvilTerran> mmm... close.
05:19:01 <eflister> yeah that's looking good
05:19:52 <Beelsebob> Axman6: I'll give you a hint... it's called seL4
05:20:15 <Axman6> ah i thought it would be NICTA :)
05:20:31 <Axman6> that's work done at my uni, and UNSW i think
05:20:39 <Beelsebob> cool :)
05:20:44 <EvilTerran> ?type WriterT . lift . runWriterT -- eflister
05:20:46 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) w a. (MonadTrans t, Monad m) => WriterT w m a -> WriterT w (t m) a
05:20:46 <Axman6> NICTA is the comercial IT arm of ANU and UNSW i think
05:22:17 <eflister> EvilTerran: yeah that did it!  thx!
05:22:20 <EvilTerran> :)
05:22:44 <Axman6> they recently came out with some insanely powerful, very cheap, short range wireless communications chip, that had a bandwidth of something like 5Gbps. perfect for wireless HD TV's and Blu-Ray players
05:23:02 <eflister> EvilTerran: except that's almost the src of mapWriterT -- any way to use it?
05:23:12 <eflister> @src mapWriterT
05:23:13 <lambdabot> Source not found. Wrong!  You cheating scum!
05:23:14 <EvilTerran> ?type mapWriterT
05:23:16 <lambdabot> forall (m :: * -> *) a w (n :: * -> *) b w'. (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
05:23:22 <EvilTerran> ?type mapWriterT lift
05:23:24 <lambdabot> forall (m :: * -> *) a w (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => WriterT w m a -> WriterT w (t m) a
05:23:32 <EvilTerran> huzzah!
05:23:34 <eflister> ah
05:23:46 <eflister> i apparently do not get this lifting stuff like i thought i did
05:24:01 <eflister> back to the woodshed!
05:24:02 <Beelsebob> Axman6: that's a good plan
05:24:24 <Axman6> Beelsebob: they're like $10 each too, and something like 5mmx5mm
05:25:42 <jix> would a transformer version of the ST monad work without problems?
05:27:47 <mux> I stopped reading the seL4 article when I read this "Not only that, the inherent nature of a kernel is much more complex than that of software."
05:28:19 <mux> this is just impressively, terribly, extraordinarily wrong.
05:30:09 <Ferdirand> obviously, kernel is not software then
05:30:14 <lilac> so there's now an OS written in C which has been proven equivalent to a Haskell 'specification'. did they just compile it with GHC with -fvia-C?
05:30:15 <Ferdirand> what could it be ?
05:30:22 <lilac> s/OS/kernel/
05:31:11 <Beelsebob> mux: heh
05:31:14 <lilac> Ferdirand: kernel is what you make popcorn out of
05:31:54 <Axman6> lilac: they wrote it in haskell, then translated that to C and verified it
05:32:06 <lilac> what's the news here? finally researchers prove that it's possible to write C code as correct as equivalent Haskell code?
05:32:36 <Axman6> mux: how so? a hardware must work with hardware, so ...
05:32:41 <Axman6> uh, a kernel
05:33:06 <Axman6> lilac: the news is that they have proven the kernel will not crash, except from hardware failure
05:33:21 <Axman6> you cannon cause it to panic
05:33:24 <mux> Axman6: if you've done kernel programming in the past, you know that it is not any more complex than userland software, and you also know that it is software as well :-)
05:33:43 <mux> plus the guy dares saying that kernel is less structured than other software, which is also blatantly wrong
05:33:46 <lilac> Axman6: they've not proven that the haskell program was 'correct'. the kernel could hang.
05:33:58 <mux> Axman6: kernel programming is more technical, certainly not more complex
05:34:14 <Axman6> urgh
05:34:19 <lilac> Axman6: what behaviour is the C program allowed to have if the haskell program bottoms out?
05:34:24 <mux> it's actually quite often /simpler/
05:34:27 <EvilTerran> jix, i vaguely recall seeing a pure implementation of ST that was slower, but allowed an STT.
05:34:30 <Axman6> these guys aren't just some two bit company, they do know what they're on about
05:34:41 <mux> Axman6: it's very clear that the guy they interviewed doesn't though
05:34:43 <Axman6> lilac: how would i know?
05:34:45 <EvilTerran> jix, the standard implementation of ST uses mutable memory though.
05:35:12 <EvilTerran> (which makes it unsuitable for writing as a transformer)
05:35:13 <mux> Axman6: also, this article lacks any technical detail necessary to appreciate whether this is really an achievement or not
05:35:22 <Axman6> mux: well read the stuff on their site. do you always choose the right words when talking?
05:35:26 <Axman6> _always_
05:35:39 <Axman6> humans have not been proven correct, do not expect them to be ;)
05:35:44 <lilac> Axman6: if _|_ is translated to just 'undefined behaviour' then the kernel can still panic.
05:35:50 <mux> Axman6: this is besides the point, you won't see an article about some work I've done on this website
05:36:38 <mux> however, considering the website is called "computerworld, the voice of IT management", I'm not surprised
05:37:07 <Axman6> it's not an article for people like you and me
05:37:17 <mux> clearly! :-)
05:37:24 <lilac> if they'd started with a total kernel written in epigram or similar, then i'd be more impressed
05:37:31 <mux> lilac: same here
05:37:39 <Axman6> now go read http://www.ertos.nicta.com.au/research/sel4/ and quit bitching
05:38:03 <lilac> but then they'd be saying something /weaker/ than 'we have a provably-correct compiler'
05:38:20 <mux> jesus christ, I'm not "bitching", nor am I bitching about the company, I'm displeased with the article, that's it
05:38:20 <Philippa_> lilac: it's possible they wrote it in a form that avoids general recursion, and made sure all the patterns had full coverage
05:38:33 <mux> do you have NICTA's shares or something? what heppened to courtesy in this channel?
05:38:42 <Axman6> mux: all i'm hearing is bitching about the article
05:39:12 <mux> Axman6: I'm willing to agree with you if you at least call it constructive bitching, or maybe substantiated bitching.
05:39:13 <lilac> Philippa_: right. that'd be really cool. but i'd hope they'd point that out in the slashdot article if it were the case :)
05:39:24 <Axman6> no, i don't, but they are somewhere i would like to work one day, because they do good stuff, in areas i'm interested in. they're the commercial arm of IT for my university, one of the most highly regarded in the world
05:39:43 <Philippa_> lilac: yeah, but it's slashdot
05:39:48 <mux> Axman6: that doesn't mean you need to jump at my throat because I dislike one article about what they've done.
05:39:55 <lilac> Philippa_: true :)
05:40:19 <Axman6> yeah, but you're getting the facts wrong, because the article sucks. i'm trying to tell you about the product, you're complaining about the article
05:40:55 <mux> oh christ! let's leave it at that.
05:41:42 <Axman6> have you read the stuff on the nicta site?
05:42:23 <lilac> i'd be interested in seeing which linux vulnerabilities have been in areas which would be part of the L4 microkernel, and which vulns would be in what L4 would consider to be driver code
05:43:38 <mux> lilac: I guess at least 90% of those would belong to a microkernel service (or driver, or whatever)
05:43:49 <jix> EvilTerran: is there some easy example to see why mutable memory isn't usable for a transformer?
05:45:48 <quicksilver> jix: simply the fact that it is primitive
05:45:59 <quicksilver> jix: you could *fake* mutable memory and use that as a transformer.
05:46:06 <quicksilver> although some parts of ST are harder to fake than we'd like.
05:47:19 <lilac> STM does something a lot like faking mutable memory and allowing such changes to be undone
05:48:09 <eflister> what if one does forkIO in a WriterT, and tell's from both threads?  should one make a dummy MVar to protect the log?
05:49:27 <lilac> you can't forkIO a WriterT w IO (), only an IO ()
05:49:52 <eflister> i seem to have been able to liftIO it
05:50:21 <quicksilver> lilac: except, does so by using real mutable memory :)
05:50:35 <quicksilver> eflister: sure, but the thing you forked was only a IO
05:50:50 <quicksilver> you can call liftIO . forkIO $ subaction from withing WriterT
05:50:56 <quicksilver> but subacton has type IO ()
05:51:01 <quicksilver> not WriterT anything
05:51:25 <quicksilver> if you want them to share the log you're going to have quite a bit of work to do.
05:51:27 <lilac> liftIO . forkIO :: (MonadIO m) => IO () -> m ThreadId
05:51:46 <quicksilver> something like:
05:52:17 <quicksilver> newtype ForkableWriter w m a = ReaderT (MVar w) m a
05:52:34 <quicksilver> and a clever 'tell' instance which does the tell inside modifyMVar
05:53:01 <quicksilver> instance Monad w => MonadWriter (ForkableWriter w)
05:53:11 <dino-> This makes me think of using a TChan to communicate between these threads.
05:53:12 <eflister> ah ok, i was confusing myself -- i thought my two threads were clobbering the log, but it was actually one thread exiting and its parent putStr'ing the log, and fighting with the other thread putStr'ing
05:53:17 <lilac> quicksilver: i guess the problem with STT using real mutable memory is that you can have multiple bits of an STT computation running simultaneously on the same state
05:53:56 <quicksilver> where tell x = do mv <- ask; modifyMVar mv (mappend x)
05:53:58 <quicksilver> I think.
05:54:00 <quicksilver> lilac: No.
05:54:53 <quicksilver> lilac: the problem is that, in the monad STT m
05:55:29 <quicksilver> lilac: the 'm' part can, for example, require that changes are rolled-back (like with Either or Mayber) or that the whole mutable state arena is duplicated/checkpointed (like in [] and Cont)
05:56:09 <lilac> quicksilver: neither of those actually prevents using mutable memory (but it'd make the checkpoint and roll-back operations harder), though, right?
05:56:30 <lilac> quicksilver: if you have STT s [], isn't it possible to run two ST computations in parallel?
05:56:41 <quicksilver> ignoring everything we know about haskell, then, yes you're absolutely right
05:56:52 <quicksilver> it's "just an engineering problem" and it has a solution.
05:57:02 <quicksilver> in the haskell context you will find purity makes it difficult to express.
05:57:06 <quicksilver> if I'm not mistaken.
05:57:39 <lilac> i think you're probably right. implementing it without compiler support would be highly nontrivial, i think
05:57:55 <quicksilver> I think, probably impossible without any compiler support.
05:58:02 <quicksilver> but it's quite likely that unsafePerformIO is 'enough'
05:58:14 <quicksilver> unsafePerformIO is the gateway to many circles of hell.
05:58:14 <lilac> right. but this is ST we're talking about, so compiler support is not unreasonable
05:58:19 <quicksilver> agreed.
05:59:46 <lilac> I'm still concerned about the case where, in STT s m, m is a nondeterministic choice monad which tries its possibilities in parallel
06:00:37 <lilac> i'd intuitively think that'd give us multiple operations modifying the same set of STRefs in parallel
06:00:59 <lilac> but i'm being stupid aren't i? they wouldn't be operating on the same state :)
06:01:46 <lilac> so i guess the conclusion is that STT is probably semantically sound, but hard to implement efficiently
06:03:30 <quicksilver> I think 'STT m' is semantically sound for each monad m.
06:03:48 <quicksilver> I'm *not* sure that "STT :: (* -> *) -> (* -> *)" actually exists as a monad transformer.
06:04:04 <quicksilver> I'm not sure you can implement it in a way which is polymorphic in 'm'
06:04:09 <quicksilver> (which is what a monad transformer must do)
06:09:03 <EvilTerran> quicksilver, i think you might be able to do it with unsafeCoerce
06:11:10 <iddo> how to do  (arg:_) <- getArgs  so that arg contains null string if no cmd line args were given?
06:11:44 <Beelsebob> iddo: x <- getArgs; case x of [] -> ...; (arg:_) -> ...
06:13:25 <ksf> there's no way to rationalize sqrt :: Ratio -> [Ratio] by counting how many times you hit to the left/right of the actual sqrt, is there?
06:13:57 <iddo> i tried with if else and got some errors
06:14:02 <iddo> shouldnt i use catch ?
06:14:06 <quicksilver> no.
06:14:38 <ksf> is there a way to tell whether the list is finite for a given input?
06:14:38 <quicksilver> if you tried with if/else you probably had an indentation error
06:15:11 <Raevel> ksf: generally, no
06:15:17 <iddo> why not use catch?
06:15:23 <quicksilver> ksf: well, yes, it's computable whether a rational has a rational square.
06:15:34 <Raevel> oh sorry, missed what you were talking about
06:15:35 <quicksilver> iddo: pattern match errors are not intended to be caught.
06:15:46 <ksf> erm every rational has a rational square
06:15:51 <quicksilver> ksf: ..root :)
06:15:55 <ksf> ah.
06:16:08 <quicksilver> ksf: however I'm not aware of a clever algorithm which works on the approximations.
06:16:23 <quicksilver> I'm only aware of the brute-force approach of prime-factorising numerator and denominator.
06:16:39 <quicksilver> mind you, I suck at number theory :)
06:16:47 <ksf> way less than me.
06:16:49 <quicksilver> iddo: it's just a style thing, really.
06:17:20 <quicksilver> iddo: you could also have:
06:17:41 <quicksilver> firstarg <- (\aa -> if null aa then "" else head aa) <$> getArgs
06:17:51 <quicksilver> as one of many many possible ways to do what you ask for.
06:18:16 <Axman6> iddo: because it's not an exception
06:18:52 <iddo> ok hmm
06:19:12 <iddo> (x:_) <- getArgs  doesnt generate exception if no cmd line args?
06:19:19 <Axman6> we don't do the whole java 'wrap everything i try/catch' thing
06:19:24 <quicksilver> it's a matter of pedantic defintions, iddo
06:19:28 <Axman6> it will, that's why you don't use that
06:19:32 <quicksilver> some people would call that an 'error' not an 'exception'
06:19:40 <quicksilver> it's not intended to be caught, anyhow.
06:19:58 <iddo> ok
06:19:59 <Axman6> you use args <- getArgs; case args of [] -> ...; (arg:_) -> ...;
06:20:03 <ksf> don't we have anything getopt-like?
06:20:30 <Raevel> there are at least two command line options parser packages
06:24:34 <Axman6> :t listToMaybe <$>
06:24:35 <lambdabot> parse error (possibly incorrect indentation)
06:24:46 <Axman6> :t (<$>) listToMaybe
06:24:47 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f (Maybe a)
06:24:54 <Axman6> :t listToMaybe <$> getArgs
06:24:56 <lambdabot> Not in scope: `getArgs'
06:25:01 <Axman6> :t listToMaybe <$> getLine
06:25:02 <lambdabot> IO (Maybe Char)
06:26:27 <Axman6> :t listToMaybe <$> (f :: IO [String])
06:26:28 <lambdabot>     No instance for (SimpleReflect.FromExpr (IO [String]))
06:26:29 <lambdabot>       arising from a use of `f' at <interactive>:1:17
06:26:29 <lambdabot>     Possible fix:
06:26:33 <Axman6> -_-
06:26:39 <Axman6> :t listToMaybe <$> (undefined :: IO [String])
06:26:41 <lambdabot> IO (Maybe String)
06:27:39 <iddo> quicksilver: with your firstarg example i get parse error on input <$>
06:27:50 <iddo> i mean the example with if/else
06:28:21 <iddo> i did import Control.Applicative
06:29:00 <iddo> no wait
06:29:20 <quicksilver> probably missed getArgs off the end of the line?
06:29:51 <iddo> hmm it works with import Control.Applicative but not import Control.Applicative (<$>)  ?
06:29:58 <quicksilver> ((<$>))
06:30:05 <iddo> ahhh
06:30:29 <quicksilver> @type listToMaybe <$> System.getArgs
06:30:31 <lambdabot> IO (Maybe String)
06:30:34 <quicksilver> Axman6: that's what you wanted.
06:30:42 <quicksilver> @type fromMaybe "" . listToMaybe <$> System.getArgs
06:30:44 <lambdabot> IO [Char]
06:30:44 <Axman6> ah, ta
06:30:51 <quicksilver> that's yet *another* solution to iddo's question.
06:30:53 <quicksilver> so many ways ;)
06:31:34 <iddo> what is this solution?
06:32:24 <quicksilver> firstarg <- fromMaybe "" . listToMaybe <$> System.getArgs
06:32:45 <quicksilver> listToMaybe converts empty Lists to 'Nothing' and non-empty lists to 'Just <first item here>'
06:32:57 <quicksilver> then, fromMaybe "" converts 'Nothing' to "", and 'Just s' to s.
06:33:13 <iddo> what should i import?
06:34:01 <quicksilver> Data.Maybe and Data.List as far as I remember
06:34:06 <quicksilver> @index fromMaybe
06:34:07 <lambdabot> Data.Maybe
06:34:10 <quicksilver> @index listToMaybe
06:34:11 <lambdabot> Data.Maybe
06:34:17 <quicksilver> ah, just Data.Maybe :)
06:34:52 <iddo> all of these solutions do the same thing internally? or some do extra work?
06:35:12 <quicksilver> that one does a little more work, in principle.
06:35:22 <quicksilver> in practice the optimising compiler probaby makes it mostly the same
06:36:13 <iddo> ok it works after i changed system.getArgs to getArgs
06:36:52 <iddo> can i use system.getArgs without importing anything?
06:37:07 <iddo> doesnt seem to work
06:37:21 <Axman6> System.Environment
06:38:06 <iddo> so can i do  System.Environment.getArgs ? doesnt seem to work without importing
06:38:35 <Axman6> import System.Environment
06:38:58 <quicksilver> doing stuff without importing is a ghci extension
06:39:05 <quicksilver> ghci, in a sense "imports everything"
06:39:08 <quicksilver> (although qualified)
06:39:11 <iddo> yes then it works, but why specify System.Environment.getArgs instead of just getArgs if i import anyway?
06:39:14 <quicksilver> lambdabot likewise.
06:39:20 <quicksilver> that's why I used it with lambdabot.
06:39:33 <quicksilver> I would just import it, and use the short form, myself :)
06:39:38 <Axman6> iddo: you don't
06:40:00 <Axman6> he was just using it with lambdabot because that's the only way to get it working
06:40:10 <iddo> ok
06:41:35 <lilac> (head . (++[""])) <$> System.getArgs
06:41:53 * EvilTerran tries to work out why his attept to use "State (Int, Map Int GHC.Prim.Any) a" and GHC.Prim.unsafeCoerce# to make an ST-alike is freezing
06:43:02 <Axman6> here's a question, could getArgs be considered pure? every time it is invoked in a program, i should give the same result, but not between different invocations of the program
06:43:26 <EvilTerran> Axman6, i believe there's a system call to change the result (on at least some OSs)
06:43:36 <EvilTerran> or something weird like that
06:43:41 <Axman6> hmm, ok
06:43:47 <mux> it's not really a syscall but it can indeed change
06:43:50 <EvilTerran> for passing parameters to something you exec() or what-have-you)
06:43:55 <cjs>  setargs().
06:43:56 <mux> that's how setproctitle() works
06:44:03 <Axman6> guess that's a probable no then ;)
06:44:14 <cjs> Be definite. Certainly no!
06:46:49 <iddo> lilac: whats that? even simpler solution?
06:48:16 <iddo> < lilac> (head . (++[""])) <$> System.getArgs
06:48:31 <iddo> this seems better because there's no branching ?
06:48:43 <iddo> it appears to work fine
06:52:31 <iddo> i wonder if it's internally the same as if/else null check
06:52:46 <quicksilver> Axman6: in my opinion between different invocations is enough to consider it impure.
06:52:56 <quicksilver> iddo: yes it is. There is a check for null in the source for ++
06:52:57 <SamB_XP> it depends on whether or not it gets stream-optimized
06:52:59 <Axman6> yeah, i would too
06:53:16 <quicksilver> Axman6: (which means some other stuff in the base library is broken, like System.Info.OS or whatever it's called)
06:53:20 <iddo> ok
06:53:32 <Axman6> broken how?
06:53:43 <quicksilver> Axman6: broken by having a type which claims it's pure when it isn't.
06:53:58 <Axman6> oh really?
06:54:19 <Makoryu> Why aren't ! and ? allowed at the ends of identifiers?
06:54:31 <quicksilver> Makoryu: arbirtrary decision.
06:54:40 <SamB_XP> quicksilver: worse, it expects to continue running on the same CPU architecture throughout the lifetime of the program invocation!
06:55:03 <SamB_XP> Makoryu: aren't they?
06:55:11 <SamB_XP> ! is an identifier, after all!
06:55:15 <quicksilver> Makoryu: they decided to keep the lexical syntax symbol.
06:55:28 <quicksilver> Makoryu: some characters are operators, some are identifiers.
06:55:48 <SamB_XP> # is both with MagicHash
06:55:57 <SamB_XP> ... at the end
06:56:03 <Axman6> WICHCRAFT!
06:56:04 <SamB_XP> I think ' is too?
06:56:25 <SamB_XP> > let (+') = (+) in 1 +' 2
06:56:27 <lambdabot>   <no location info>:
06:56:27 <lambdabot>      lexical error in string/character literal at chara...
06:56:30 <SamB_XP> aw.
06:56:32 <SamB_XP> maybe not.
06:57:03 <quicksilver> SamB_XP: in the terminology of the report, ! is not an identifier, it's a symbol.
06:57:17 <quicksilver> varsym, not varid.
06:57:35 <SamB_XP> quicksilver: in the terminology of an implementation, though ...
06:58:07 <quicksilver> which implementation?
06:58:23 <Makoryu> > let (?) :: (a -> Bool) -> a -> Bool; (?) = ($) in map (null?) $ lines ("a\nbc\n\npizza") -- I suppose I can always get away with this
06:58:24 <lambdabot>   [False,False,True,False]
07:02:22 <soupdragon> Makoryu ugh no,  let nullp = null
07:02:43 <Makoryu> soupdragon: Nope, my evil scheme is already settled
07:03:33 <mmorrow> heh
07:04:02 <quicksilver> > let (?) :: (a -> Bool) -> a -> Bool; (?) = id in map (null?) $ lines ("a\nbc\n\npizza")
07:04:04 <lambdabot>   [False,False,True,False]
07:04:08 * quicksilver saves one character
07:04:25 <Makoryu> I always thought that "pred?" was far more distinctive than "predp"
07:05:02 <quicksilver> it certainly is.
07:05:16 <quicksilver> but the simple rule about operators/identifiers has its advantages too.
07:05:43 <liyang> Chuck the rulebook out.
07:05:54 <Makoryu> quicksilver: Yeah, I didn't really want to break that... A (?) operator is a nice way to split the difference
07:06:11 <liyang> Use Agda -- it makes no distinction between operator and normal identifier names.
07:06:15 <SamB_XP> liyang: which rulebook?
07:06:29 <SamB_XP> personally, I think pred is a clear enough name
07:06:34 <SamB_XP> without a p or ?
07:06:38 <SamB_XP> ;-P
07:06:56 <liyang> SamB_XP: the arbitrary decision that said anything non-alphanumeric is an operator, except for _, which is a letter.
07:07:19 <liyang> (I mean, it made sense at the time, but once you chuck Unicode in, it's far too restrictive.)
07:07:28 <SamB_XP> liyang: really?
07:07:40 <liyang> SamB_XP: really what?
07:07:40 <eevar2> go with "predp?" ;)
07:07:50 <SamB_XP> what's worse is that you need to start an identifier with a cased letter!
07:08:04 <liyang> SamB_XP: that too. Again, Agda. =)
07:08:08 <SamB_XP> so you can't start an operator with a japanese letter ;-P
07:08:08 <quicksilver> liyang: personally I think with unicode it become more tolerable, not less.
07:08:10 <SamB_XP> re.
07:08:11 <SamB_XP> er.
07:08:14 <SamB_XP> identfier
07:08:16 <pikhq> liyang: How's about we make ASCII non-alphanumeric and Unicode operators into operators.
07:08:34 <quicksilver> liyang: the main shortcoming of the existing system is paucity of operator chars.
07:08:38 <quicksilver> and unicode gives you lots more.
07:08:39 <liyang> quicksilver: are you on the anti-unicode brigade?
07:08:46 <quicksilver> pikhq: unicode operators are operators.
07:08:54 <liyang> quicksilver: *nod* Precisely.
07:08:55 <quicksilver> liyang: on the contrary, I think unicode works well with this system.
07:09:10 <quicksilver> what are your misgivings?
07:09:12 <liyang> oh, I think our signal wires got crossed somewhere.
07:09:54 <quicksilver> I mean I think agda's approach is also interesting.
07:10:01 <quicksilver> btu I can see the advantages in a clear lexical distinction.
07:10:05 <liyang> or rather, I was kind of against making a syntactic/lexicographic distinction for names and operators.
07:10:28 <quicksilver> it's quite nice to be able to look at a # b and know how to parse that
07:10:30 <liyang> There are advantages to a lexical distinction, yes.
07:10:33 <quicksilver> without first knowing what # is.
07:10:39 <quicksilver> (or, indeed, a and b)
07:10:53 <quicksilver> and I think unicode lessens the pain of the distinction
07:11:01 <quicksilver> by givig you a whole lot more choices in both camps.
07:11:13 <liyang> Unless it's part of a larger expression and you don't know the fixity of the # operator. :3
07:11:29 <quicksilver> right, you still can't correctly parse multiple infixes in detail
07:11:34 <quicksilver> but you can get a general notion.
07:11:57 <quicksilver> ((a # b) ~ c) and (a # (b ~ c)) are "less different" subjectively
07:12:14 <liyang> You could make the same argument for a good choice of names in the first place, in the absence of a lexical distinction.
07:12:22 <quicksilver> than (a #) `b` (~ c) and (((a #) b) ~) c)
07:12:40 <quicksilver> good choices of alphanumeric names is fine
07:12:49 <quicksilver> but 'good choices' of symbolic names is hard.
07:12:54 <quicksilver> ##! <- infix or prefix?
07:13:17 <liyang> With Unicode, you're freer to use symbols that have extrinsic meaning outside of your program. :3
07:13:31 <liyang> I mean, intrinsic. ¬_¬
07:13:41 <liyang> You know what I mean.
07:17:25 * liyang still would like to be able to use actual Greek letters instead of spelling them out though.
07:22:10 <dino-> Has anyone here gotten curl to build and install using Haskell Platform in Windows? I'm having problems getting the native curl to be properly available even following this: http://haskell.forkio.com/Home/curl-win32
07:23:39 <kpreid> Is there something like an automated checker that a Haskell function is in fact total (is not bottom for any argument)?
07:23:55 <quicksilver> halting problem alert :)
07:24:18 <pikhq> kpreid: That is a halting oracle.
07:24:32 <pikhq> GHC has one! :P
07:24:33 <kpreid> Let's say with the assistance of some hints.
07:24:42 <kpreid> i.e. a proof
07:24:50 <pikhq> Yeah, kpreid... That's still the halting problem.
07:25:05 <kpreid> Huh, it is?
07:25:16 <pikhq> That is to say, it is impossible in the general case.
07:25:43 <Makoryu> kpreid: You might be able to get away with it if you excluded recursive types (like lists) from consideration
07:25:58 <Philippa_> pikhq: if you're allowed to request extra info, it's not the halting problem
07:26:26 <pikhq> Philippa_: Sure it is. It's just the halting problem with an odd, non-deterministic oracle.
07:26:26 <Philippa_> unless your 'general case' happens to include the one where no such info is forthcoming
07:26:29 <kpreid> Makoryu: I had a recursive type in mind: peano numbers
07:26:36 <Makoryu> kpreid: Yep, you're hosed
07:26:58 <Makoryu> kpreid: Well. Maybe you're hosed.
07:27:08 <kpreid> I have the feeling I've underspecified my problem.
07:27:13 <Philippa_> pikhq: I suggest you try telling that to those who've worked out the relevant general proof techniques. Finding the proof, that's not decidable, sure...
07:27:40 <pikhq> Philippa_: If it isn't entirely automatable, it's not worth doing!
07:27:52 <pikhq> ... Now if you'll excuse me, I need to stop talking on IRC. :P
07:28:13 <Philippa_> you have funny ideas about 'worth doing'
07:28:23 <pikhq> Yes, yes I do.
07:28:59 <Axman6> sex is automatable, to an extent
07:30:11 <Berengal> Is automating automatable?
07:30:41 * pikhq replaces me with a small shell script
07:32:19 * Berengal ponders the feasability of a haskell database implementation
07:32:46 <Axman6> Berengal: i've suggested that before
07:33:04 <Berengal> Something not neccessarily relational
07:33:20 <Axman6> CouchDBesque?
07:33:30 <Berengal> Graphs perhaps? But then how do you preserve sharing?
07:40:03 <quicksilver> Berengal: you can optimistically restore sharing just by comparing bytes
07:40:12 <quicksilver> (of data directly, or of some hash of data)
07:40:18 <quicksilver> other projects have used that technique.
07:40:29 <Berengal> quicksilver, I was thinking something like that as well
07:40:34 <quicksilver> It has the side-effect of actually creating maximum sharing even if that wasn't present originally
07:40:43 <quicksilver> which is, quite often, rather cool, but very occasionally a space leak.
07:40:47 <Berengal> I mean, values are values. None of this object-oriented identity nonsense...
07:41:06 <Berengal> How is it a space leak?
07:41:09 <quicksilver> in the context of persistence it's very unlikely to be a space leak IMO.
07:41:14 <Berengal> Pointers everywhere?
07:41:27 <quicksilver> Berengal: well you might have two copies of the same list andyou're hoping they'll be GCed as you go along
07:41:36 <Berengal> Oh, like that.
07:41:36 <quicksilver> but they wont' be, because there are two references to the top not just one.
07:41:43 <quicksilver> (because it's really one)
07:42:00 <quicksilver> I don't think that's a very common problem in the kind of value-persistance arena you're talking about though.
07:42:07 <Berengal> Yeah, but since a db stores /structure/ I don't think that'll be a problem
07:43:14 <Berengal> I need to figure out a nice API...
07:43:39 <quicksilver> there is quite a lot of prior art around.
07:43:47 <quicksilver> don't necessarly let that put you off.
07:43:58 <quicksilver> happs's state thing is probably the most complete.
07:44:12 <Berengal> Yeah, I'll have to browse around a bit...
07:45:53 <Berengal> Also, my work paid for RWH today
07:45:55 <Berengal> -ish
07:46:43 <dino-> At my last job I was seriously considering buying a copy and leaving it there forever, like a donation. Please read this, somebody, I'm begging here.
07:47:45 <quicksilver> I bought a copy and leave it on my desk in the hope it will intrigue people.
07:47:48 <dino-> I've thought about that too, using the happstack persistence stuff as a general data store, not in a web app.
07:48:01 <quicksilver> I do actually rather like relational stores myself.
07:48:13 <dino-> You can also use sqlite.
07:48:14 <quicksilver> but the point is - a relational store is for when you want/need the ability to write a variety of queries.
07:48:24 <gwern> dino-: just use read/show and serialize to files in filestore :)
07:48:37 <quicksilver> dino-: I'd rather poke my eyes out with a wooden spoon soaked in TCP whilst someone plays James Blunt on a loop tape.
07:48:43 <dino-> gwern: That's what I do most of the time. It's very powerful, that low-budget serialization.
07:48:49 <dino-> quicksilver: heh
07:49:09 <quicksilver> when you need the services of the query optimiser - e.g. to write complex/powerful aggregates and reports - then having used a relational system pays off.
07:49:13 <Berengal> sqlite is available as a library, which is nice
07:49:22 <quicksilver> for many ordinary persistence tasks you don't need anything like that.
07:49:27 <Berengal> You can't just link in oracle...
07:49:36 <quicksilver> true. That's a flaw in oracle IMO.
07:49:43 <quicksilver> A good database engine should be linkable.
07:49:47 <quicksilver> (sqlite is linkable, but not good)
07:50:09 <Berengal> sqlite is passable when you need a db for a standalone app
07:51:36 <dino-> Interesting thing about Read/Show for serialization, I had a co-worker at a Perl job be really really surprised to see it. Saying that he didn't really realize that the ease of things like eval-ing blocks of code existed outside of scripting languages.
07:51:40 <jkff> dino-: I've bought 3 copies of SICP for the same intent: I'm giving them away to different people in the hope that someone will actually read them
07:51:47 <jcreigh> the most frustrating thing about sqlite is the table alteration commands are very limited...for most complex things you have to drop+recreate
07:52:11 <jkff> For now, with no noticeable success :(
07:52:27 * jcreigh has a copy of SICP that he has not read
07:52:32 <dino-> jkff: Kind of disappointed that I haven't read that yet. I have the PDF. :(
07:52:35 <jcreigh> I hope I don't get ejected from the channel....
07:52:45 <Makoryu> Is there a nice compact paperback edition of SICP?
07:53:44 <gwern> Makoryu: kinkos provides one
07:53:44 <jkff> dino-: Buy a copy :) I've read mine 3 times and read a course based on it 2 times :)
07:54:01 <jkff> read=taught
07:54:10 <gwern> crazy european lingos!
07:54:52 <gwern> dino-: the thing to do, I think, is to go the SICP tutor website, and do the problem sets a little bit a day. each one is at most 20 minutes to solve, so it's not at all procrastination-inducing demanding
07:54:58 <Makoryu> gwern: Yes, I expect I could print it and put it in a spiral binding, thus defeating the whole purpose of a compact paperback in the first place.... :p
07:55:30 <gwern> Makoryu: its backs would be made of paper! I is not seeing problem?
07:56:47 <dino-> I can put it on my book reader. But PDFs kind of suck on it. That may be worth converting to epub. But sheesh, it takes a lot of time to do a good job of that.
07:57:42 <gwern> the key is just to start
07:57:57 <gwern> the little online multiple-choice or code-snippet questions are a great way to start
07:58:01 <dino-> gwern: I don't see the tutor thing at the mitpress sicp site. Got a url for this tutor site?
07:58:20 <gwern> http://icampustutor.csail.mit.edu/6.001-public/
07:58:29 <gwern> @where+ sicp-tutor http://icampustutor.csail.mit.edu/6.001-public/
07:58:30 <lambdabot> Done.
07:58:44 <dino-> Is this the course they cut recently that people were talking about?
07:58:45 <gwern> dino-: it's free of course. very easy registration
07:59:10 <gwern> iirc, SICP wasn't cut entirely, just made an advanced & maybe optional course and not the default CS 100 course
07:59:38 <dino-> I vaguely remember something repulsive involving starting people out with Python instead. :(
07:59:47 <gwern> robots
08:00:06 <Berengal> Python is better than java though. Easier to focus on the algorithms and whatnot
08:00:11 <Berengal> Although Scheme is still better...
08:00:28 <soupdragon> wrong
08:00:30 <Berengal> (And by java I mean basically every c-like)
08:00:58 <Berengal> ((except c, but that belongs in a systems course, not an intro course))
08:01:00 <Vq> soupdragon: but not that wrong
08:01:10 <soupdragon> 100% wrong
08:01:30 <quicksilver> java gives you the tools to program with a fair amount of type-safety
08:01:37 <quicksilver> at the cost, unfortunately, of hideous verbosity.
08:01:46 <quicksilver> python leaves you in a typeless wilderness
08:01:55 <quicksilver> but at least a fairly concise and expressive one.
08:02:04 <quicksilver> I think I prefer python, but both are big disadvantages
08:02:11 <dino-> gwern: Thanks for that link
08:02:12 <kynky> whatabout ruby ?
08:02:12 <osfameron> java's type safety comes at a fairly heavy cost
08:02:15 <gwern> so far the most annoying thing about SICP is having to solve things with primitive recursion and the basic operators; eg my current tutor problem is write an enumFromTo x y function, and I want to write [1..y] :)
08:02:16 <Berengal> I wouldn't call java's typesystem a proper typesystem, or even a 'fair' one
08:02:37 <quicksilver> Berengal: I don't think I did call it that.
08:02:40 <soupdragon> it is Berengal
08:02:47 <soupdragon> you should learn some basic things instead of talking shit
08:02:51 <quicksilver> Berengal: but that's pretty productive
08:02:59 <quicksilver> soupdragon: please moderate your tone.
08:03:03 <quicksilver> Berengal: subjective, I meant to say.
08:03:04 <soupdragon> no
08:03:05 <gwern> dino-: between the PDF, the tutor, the videos, Dr.Scheme, and the various blogs going through SICP (and the IRC channel ##sicp and the sicp wiki), there's realy no reason to not do SICP :)
08:03:30 <gwern> at this point, I'm not sure there's much value to actually doing SICP at MIT
08:03:33 <quicksilver> Berengal: but the java typesystem is expressive enough to program quite safely.
08:03:38 <Berengal> In python you can at least pretend you have a decent typesystem. It won't complain if you violate things, but it won't force one you don't like on you either
08:03:39 <osfameron> Perl+Moose gives you /some/ fairly nice aspects of type-safety in a dynamic language
08:04:04 <Vq> Berengal: there is things that can force types in Python
08:04:05 <quicksilver> Berengal: complaining if you violate things is the *point* though.
08:04:07 --- mode: ChanServ set +o Philippa_
08:04:13 <Philippa_> soupdragon: moderate your tone
08:04:13 <quicksilver> that's what you want from a type system.
08:04:20 <soupdragon> shut up phillipa
08:04:23 <Vq> Berengal: high-level Zope3 for example
08:04:35 <gwern> soupdragon: that wasn't the right answer
08:04:38 --- mode: Philippa_ set +b *!*@amcant.demon.co.uk
08:04:42 <Vq> Berengal: (run-time though)
08:04:53 <osfameron> quicksilver: I found the java typesystem quite horrible (admittedly I wasn't a fan of strongly typed when I tried)  It seemed to require a lot of faffing about with casting to get anything done... (ok, this was pre generics)
08:04:53 --- kick: soupdragon was kicked by Philippa_ (funnily enough, I'm the one with authority on that one)
08:04:59 <Berengal> Vq, compile-time complaining is the point though, indeed
08:05:03 --- mode: ChanServ set -o Philippa_
08:05:11 <quicksilver> osfameron: that's what I mean by hideous verbosity.
08:05:19 <gwern> (goodness. I can't remember the last time I saw someone get kicked here)
08:05:20 <quicksilver> osfameron: but the *power* is there. The language is capable of the safety.
08:05:33 <Vq> Berengal: testrun time is almost as good :o)
08:05:37 <quicksilver> osfameron: it's just the amount of chars you have to type for some of it.
08:06:03 <Philippa_> gwern: this's one with ongoing history, unfortunately
08:06:04 <quicksilver> osfameron: ...and, culturally, that verbosity infects lots of java library code even when more concise alternatives are possible :(
08:06:04 <osfameron> quicksilver: typing return values was very weak, iirc
08:06:11 <Vq> Berengal: if you use a framework that forces types and you have a good testing philosophy you can get pretty far
08:06:20 <Vq> Berengal: im not saying that it competes with static typing
08:06:25 <Berengal> Python gives you dependent types or whatever other fancy type theory feature you want, provided you're willing to prove it yourself :P
08:06:33 <Philippa_> soupdragon knows what's going on
08:06:38 <quicksilver> osfameron: it's surprisingly how much cultural effects change how a language appears in practice.
08:06:42 <osfameron> actually, I can't remember enough detail to remember what it was I didn't like about Java.  I *did* like how it encouraged me to structure my code though.
08:06:46 <quicksilver> osfameron: (witness the culture of CPAN, for good and for bad)
08:07:24 <Berengal> What neither gives you is type-driven coding. You can't have typeclasses in either language
08:07:24 <Vq> Berengal: it's just that there are ways to develop Python applications in a "fairly" safe manner
08:07:25 <pikhq> osfameron: Java suffers a lot from the idea that if a few objects are good, a lot of objects must be great.
08:07:55 <gwern> pikhq: so smalltalk is even worse then?
08:08:05 <dino-> pikhq: Java: Great language or greatest language?
08:08:08 <osfameron> Berengal: why's that?  There's a project in Perl to implement typeclassy behaviour using Moose roles, for example.
08:08:12 <Twey> Whereas Haskell benefits from the idea that if a few functions are good, a lot of functions must be great.  ;)
08:08:14 <dino-> (with apologies to Colbert)
08:08:38 <gwern> imperative programming: threat or menace?
08:08:48 <Berengal> osfameron, can you do generic monad programming in it?
08:08:57 <Berengal> If you can, then great
08:09:02 <pikhq> gwern: I'm refering to stupid shit like having factories for everything and using absurdly verbose objects where just a simple lambda would do. (or even a callback!)
08:09:23 <osfameron> Berengal: you can do monads with plain old classes...
08:09:35 <Berengal> osfameron, how would you define return?
08:09:37 <osfameron> oh, *generic*
08:09:38 <osfameron> hmm
08:09:44 <osfameron> I'm hacking around that in Acme::Monads
08:10:00 <osfameron> by either a) passing in "this is the monad that stuff applies to" or b) checking who called me, and using that
08:10:07 <Berengal> Well, return is one of the basic functions... mapM is a better example
08:10:09 <osfameron> but I think it's possible to do something more elegant
08:10:30 <osfameron> I'm hoping to dedicate more time to it, now that said commodity is more copious ;-)
08:10:56 <dons> ?yow
08:10:56 <lambdabot> Yow!  Maybe I should have asked for my Neutron Bomb in PAISLEY --
08:11:53 <Philippa_> heh. Worryingly appropriate
08:12:18 <gwern> @users
08:12:19 <lambdabot> Maximum users seen in #haskell: 658, currently: 576 (87.5%), active: 20 (3.5%)
08:29:24 <dino-> Wow, this is terrible. Finally got curl and darcs to cabal-install in Windows and the darcs binary does absolutely nothing when I run it with any args I've tried so far.
08:29:41 <dons> ask in #darcs
08:29:42 <dino-> It's a Windisaster. :(
08:30:40 <dino-> Very exciting to see the cabal-install doing its thing there, though. It's a lifesaver, especially in the package-challenged Windows world.
08:31:23 <quicksilver> if only you could 'cabal install ubuntu' to get a virtual machine running ubuntu with all the necessary ghc packages :)
08:31:25 <dons> yep. haskell platform + cabal-install: haskell is first class everywhere.
08:32:42 <dons> seL4 is a massive coup for the Haskell community, imo. A world first in large scale verification, via Haskell.
08:34:21 <dino-> I remember simon asking if anybody felt like making a bootable Live Linux set up with the platform. But I wonder if it would be more useful to have a VirtualBox VM image.
08:34:44 <dons> making vmware images is pretty easy, or qemu bootable livecds
08:35:57 <quicksilver> vmware's payware though isn't it? Is there a FOSS emulator good enough to run linux in windows?
08:36:03 * quicksilver doesn't really follow this stuff.
08:36:16 <pikhq> quicksilver: Qemu.
08:36:30 <pikhq> Also, VMware Player is freeware.
08:36:32 <CrazyAzrael> quicksilver: If you don't need all the monitoring craziness, vmware is free, but better to ship qemu
08:36:33 <dons> there is a free vmware player, but it isn't open source of course.
08:36:36 <pikhq> As is VMware Server.
08:36:37 <kulakowski>  You can get free (no monetary cost) vmware
08:36:46 <Philippa_> virtualbox
08:36:52 <dino-> And VirtualBox is quasi. I think free for non-commercial or something. And in some distros they build their own open edition.
08:40:58 <msteele_> The free for any use version of VirtualBox lacks a few features like USB support.
08:41:00 <jix> also there is colinux
08:41:09 <jix> which is a port of linux to windows userspace AFAIK
08:41:25 <p_l> jix: not userspace, kernelspace
08:41:26 <kynky> virtualbox free supports usb for me
08:41:35 <pikhq> jix: It's a patch to Linux that makes it run alongside the NT kernel.
08:41:38 <jix> p_l: ah ok
08:41:40 <pikhq> Coöperatively.
08:41:58 <jix> haven't had a look at it just knew about it from people using it
08:42:00 <pikhq> dino-: VirtualBox has a subset of its code released under the GPL.
08:42:04 <msteele_> kynky: There are two versions.  One is free for any use commercial or non-commercial.  The other is free for non-commercial use only.
08:42:11 <p_l> jix: it loads itself as a NT driver :-)
08:42:43 <athos> hi!
08:43:13 <ttmrichter> Umm....  Hi!
08:59:28 <J11> where is if' defined?
08:59:57 <J11> @pl if f then x else y
08:59:57 <lambdabot> if' f x y
09:00:02 <athos> @where if'
09:00:03 <lambdabot> I know nothing about if'.
09:00:35 <pikhq> J11: By people doing @let here.
09:00:47 <pikhq> @let if' f x y = if f then x else y
09:00:48 <lambdabot>  Defined.
09:00:54 <jeffersonheard> looking for an idiom...
09:01:52 <J11> so there is no library that has this defined?
09:02:00 <jeffersonheard> I have a list of strings.  I want a list of CStrings.  I want them to exist for all of a single function call.  Is there a way to curry up withCString so that I can fold it over my list, or do I need to do a mapM newCString followed by the funcall followed by mapM free?
09:02:48 <copumpkin> jeffersonheard: interesting, hmm
09:04:13 <Botje> wasn't there a cool way involving sequence and Cont ?
09:04:24 <copumpkin> seems hard
09:04:55 <Botje> http://www.mail-archive.com/haskell-cafe@haskell.org/msg37171.html
09:05:01 <Botje> do you want something like that?
09:05:09 <Botje> (yay, google)
09:05:17 <copumpkin> oh nice
09:05:37 <jeffersonheard> oooo
09:05:40 <Botje> Cale++ # abuse of Cont
09:05:46 <jeffersonheard> that is a shiny piece of haskell
09:06:22 <copumpkin> that is pretty
09:07:06 <Botje> now, is there an intro to the cont monad somewhere?
09:07:13 <Botje> I'm still lacking a gut feeling :)
09:08:31 <dcoutts> Botje: my advice is to ignore the callCC bit, everything else is quite comprehensible
09:09:06 * dcoutts has implemented a few cont monads and has never needed callCC
09:10:01 <copumpkin> http://www.mail-archive.com/haskell-cafe@haskell.org/msg37217.html
09:10:28 * jeffersonheard has always thought call/cc was an abuse of continuations meant to confuse undergraduates.
09:11:09 <tkr> Botje, mauke, integral, whoever are here. howcome someone told perl people dont like Haskell? Im just a very beginner and seem to love it more and more (for it's mathematical possibilities compared to perl)
09:11:44 <Botje> i think it's the other way round
09:11:50 <integral> that's a surprising thing to say, lots of perl people seem to like Haskell
09:11:50 <Botje> some haskell people don't like perl, because they don't know it
09:12:03 <dcoutts> jeffersonheard: I think it's one of these things where if you want to go for a single primitive in which to implement everything else, then you pick callcc
09:12:11 <Botje> and some perl people haven't played with haskell yet, so think static typing is icky
09:12:30 <dino-> tkr: I think I may have said something about that a couple days ago. I didn't mean to make an inappropriate generalization. I have personally had a lot of friction with Perl co-workers trying to get them excited about Haskell at a couple of jobs so far.
09:12:37 <integral> static typing?   I use Data.Dynamic :-P
09:12:38 <dcoutts> jeffersonheard: but all the directly useful things you can do with continuations can be done rather more directly I think
09:12:41 <jeffersonheard> dcoutts: which I suppose is why it's included in [RxRS | x <- [0..]]
09:12:45 <Botje> integral: it's always the red bit's fault!
09:13:14 <jeffersonheard> Integral: It's always the evil bit's fault
09:13:18 <dino-> Botje: Yes, I think there's a mistrust of static typing.
09:13:24 <dcoutts> jeffersonheard: right, since there they're presumably implementing callCC as a primitive in an interpreter / rts
09:13:37 <dino-> I blame things like C++, Java for it.
09:13:38 <jeffersonheard> http://www.faqs.org/rfcs/rfc3514.html
09:13:46 <integral> Perl's got plenty of static typing though
09:13:46 <pikhq> Botje: I dislike Perl, but grudgingly admit that it has its uses.
09:14:01 <Botje> pikhq: I really love the expressivity you get from contexts
09:14:07 <dcoutts> jeffersonheard: so they can then implement the useful and less confusing stuff in terms of the primitive
09:14:23 <CrazyAzrael> pikhq: I've found that almost anywhere I would use perl before, python is nicer.
09:14:23 <jeffersonheard> Botje: I'm a python fan myself.  Never been a perl fan
09:14:34 <pikhq> Basically my dislike of Perl comes largely from it feeling very, very hacked together.
09:14:46 <integral> they're [perl & python] not that dissimilar really
09:14:52 <jeffersonheard> i never liked Perl because of its nesting-via-references syntax
09:15:00 <jeffersonheard> requirement rather
09:15:00 <pikhq> Which is, of course, one of its defining characteristics.
09:15:03 <Botje> pikhq: look at modern perl code :)
09:15:15 <pikhq> Botje: Still feels hacked-together.
09:15:21 <pikhq> Just... Less so.
09:15:31 <pikhq> Unless by "modern" you mean Perl 6?
09:15:35 <pikhq> That's just *weird*.
09:15:37 <CrazyAzrael> Python feels like it has a lot less special cases, and this makes it feel alot nicer.
09:15:40 <jeffersonheard> they're not that different on the face of it, no, but python's more consistent to the core (excluding the horror that is len())
09:15:52 <integral> no, Perl 6 is nothing to do with Perl.
09:16:01 <pikhq> "You got monads in my imperative code! You got imperative code in my monads!"
09:16:21 <jeffersonheard> python 3.x inherits a lot from smalltalk.  Absolutely everything is a message to an object, which I like.
09:17:13 <CrazyAzrael> For doing things that don't involve processes (Popen is SO NICE), I've always meant to learn ruby better though.
09:17:50 <jeffersonheard> python, for example can do the old (and somewhat frightening) "becomes" concept from Smalltalk
09:17:54 <CrazyAzrael> jeffersonheard: Random question--do you still need to inherit from (object) in 3.x, or since everything is a newstyle class, is this done implicitly?
09:18:08 <integral> TBH I don't think these scripting languages are really that different from each other.  they're all got similar object models, syntax for regexps, a like of top-level code, dynamic/runtime typing etc
09:18:20 <jeffersonheard> CrazyAzrael: I don't know...  Haven't not typed (object) for so long that I didn't even think to try
09:18:47 <pikhq> integral: You want different? Tcl. Now *that's* different.
09:18:59 <integral> mmm.  yeah it's great fun
09:19:14 <pikhq> Mmm, metaprogramming.
09:19:16 <integral> even Awk isn't that different from Perl 4 *sigh*
09:19:20 <jeffersonheard> I do love the fact that by changing the __type__ slots and exchanging __dict__ slots, I can effectively change the type
09:19:39 <integral> (in perl you *can* just change the type, with bless)
09:20:09 <jeffersonheard> okay...  dropping out of this before I'm guilty of starting a holy war on languages that are technically offtopic ;-)
09:20:17 <copumpkin> lol
09:20:30 <jeffersonheard> back to wrapping OpenCL
09:20:32 <integral> #haskell++ # I don't think I've actually seen a lgnaueg flamewar here
09:20:41 <endojelly> wait we should start a discussion on weather we prefer static or dynamic typing
09:20:55 <jeffersonheard> XTC vs. Adam Ant
09:20:56 <fasta> integral: I thought that was all we talked about. :p
09:21:21 <glguy> endojelly: I prefer static typing during storms
09:21:54 <endojelly> I prefer static typing during breakfast
09:21:58 <endojelly> I guess that's enough.
09:22:12 <glguy> breakfast isn't a "weather" phenomenon ;)
09:22:26 <jeffersonheard> I prefer using fabric softener to eliminate the static in my typing
09:22:38 <endojelly> glguy, but it's a state of mind!
09:22:49 <jkff> Dear #haskell, can >>= be defined in terms of Kleisli composition and return?
09:22:59 <glguy> but I suppose I do have about a 50% chance of breakfast on any given day
09:23:13 <jeffersonheard> @ask can >>= be defined in terms of Kleisli composition and return?
09:23:13 <lambdabot> Consider it noted.
09:23:21 <jeffersonheard> oh shoot
09:23:28 <glguy> poor can, he'll never know what you meant
09:23:35 <jeffersonheard> lambdabot, you're supposed to say, "Yes, Haskell can do that!"
09:23:59 <jkff> Hmm, maybe djinn can do that?
09:24:09 <jkff> @djinn (a, a -> b) -> b
09:24:09 <glguy> :t \ m f -> (const m >=> f) ()
09:24:10 <lambdabot> f (a, b) = b a
09:24:10 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
09:24:14 <pikhq> jkff: I'm pretty sure monads can be defined in terms of that. So, yes. ;)
09:24:28 <jkff> pikhq: I've just broken my brain trying to do so, that's why I'm asking :)
09:24:39 <glguy> jkff: is that what you wanted?
09:24:45 <blackdog> eesh. just failed to define the purpose of a monad crisply in a job interview with an OCaml guy. The shame is unbearable.
09:24:50 <jkff> @djinn (a -> m a, (a -> m b) -> (b -> m c) -> (a -> m c)) -> m a -> (a -> m b) -> m b
09:24:51 <lambdabot> -- f cannot be realized.
09:25:03 <jkff> Does that mean that djinn does not know or that it really cannot?
09:25:40 <copumpkin> probably not as a total function
09:25:42 <Deewiant> In this case both
09:25:52 <jkff> Deewiant: Why?
09:25:52 <Deewiant> Since you didn't give m
09:26:12 <Deewiant> @djinn Monad m => (a -> m a, (a -> m b) -> (b -> m c) -> (a -> m c)) -> m a -> (a -> m b) -> m b
09:26:13 <lambdabot> Error: Class not found: Monad
09:26:16 <jkff> Why doesn't there exist a way to do that without knowing m?
09:26:18 <Deewiant> Meh
09:26:33 <jkff> That's the point: I want to make a monad out of return and kleisli composition
09:26:50 <jkff> Intuitively, that seems possible, but practically I can't think of a way
09:26:59 <Deewiant> jkff: My point was that it doesn't know m is a Monad unless you tell it "Monad m =>"
09:26:59 <copumpkin> make a monad?
09:27:07 <jkff> Yes
09:27:31 <glguy> jkff: if you are asking how to define >>= in terms of >=>, I already showed yoyu
09:27:56 <jkff> Oh, I missed that! Thanks!
09:28:02 <jkff> glguy++
09:28:05 <glguy> :t (id >=>)
09:28:06 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> m c) -> m b -> m c
09:28:15 <glguy> err, flipped :)
09:28:35 <jkff> Your type-fu is better than my type-fu.
09:28:53 <jkff> :t (>=> id)
09:28:54 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m (m c)) -> a -> m c
09:28:57 <jkff> Ouch
09:29:01 <glguy> :t flip (id >=>)
09:29:02 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
09:29:06 <glguy> :t (>>=)
09:29:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:29:09 <jkff> Yep
09:31:06 <jkff> :t id >=> id
09:31:08 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
09:31:13 <jkff> Wow!
09:31:27 <jkff> So, it suffices to have >=> to define both return and bind
09:31:41 <glguy> well, id >=> id  is join
09:31:45 <jkff> Yes
09:31:59 <Asztal> :t (>=>) >=> (>=>)
09:32:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> (b -> m b) -> a -> m b
09:32:13 <EvilTerran> err
09:32:37 <glguy> err?
09:32:40 * EvilTerran suspects at least one of those >=>s is flip (.)
09:32:52 <glguy> *** Exception: user error (err)
09:33:01 <EvilTerran> or whatever it works out as for the instance Monad (e ->)
09:33:24 <copumpkin> is there a reason we can't write -> sections?
09:33:43 <copumpkin> ((->) e) would be a lot clearer as one, I think
09:33:49 <Asztal> EvilTerran: yes, ((>=>) (>=>) (>=>)) :: (Monad m, Monad ((->) (b -> m b))) => (a -> m b) -> (b -> m b) -> a -> m b
09:34:23 <EvilTerran> copumpkin, well, (-> a) wouldn't work
09:34:33 * jkff thinks how to define return
09:34:40 <copumpkin> EvilTerran: at least the other direction, then :P
09:34:54 <EvilTerran> seems... inconsistent
09:34:56 <copumpkin> if you do (-> a) it'll say "noes, use newtype kthx"
09:34:59 <glguy> jkff: in terms of which primitives?
09:35:12 <jkff> In terms of >=> and the join and >>= that we've made of it.
09:35:26 <glguy> you can't define return in terms of >>= or join
09:35:34 <jkff> Even with the help of >=> ?
09:36:01 <copumpkin> you can derive that from the other two
09:36:08 <jkff> Ah yes.
09:36:24 <jkff> Fair enough.
09:36:24 <copumpkin> in fact, just from >>=
09:36:45 <jkff> So, {return, >=>} ~ {return, >>=}
09:37:48 <jkff> I've been just now explaining monads to a guy on the example of parsers (I failed), and it turned out that he's been actually using >=> and that's why he didn't understand why one needs >>=
09:37:52 <fasta> Which library can be used to replace all attributes of all nodes <bar> by something which is based on the current value of the attribute (in an XML document)?
09:38:27 <jkff> Actually, he didn't use >=>, he used OCaml or C++, but he used the concept.
09:39:45 <jkff> fasta: HXT?
09:39:49 <pikhq> jkff: So, "why do I need monads? I've got monads!"
09:40:10 <jkff> pikhq: It was more like "Why do I need to give this thing a name?"
09:40:19 <pikhq> XD
09:41:42 <jkff> That was a difficult case: a super-professional C++ developer who's generally very smart, open-minded and actively learning functional programing, but he can't grasp monads however hard he tries. He's tried like 10 times or so.
09:42:11 <jkff> He's shattered my belief that I can explain monads :)
09:42:54 <jeffersonheard> ow.  I just unsafeForeignPtrToPtr on a ByteString. I feel itchy
09:42:55 <copumpkin> did you try the functor -> (pointed) -> applicative -> monad approach?
09:43:41 <jkff> copumpkin: I'm afraid I'm not familiar with that approach, and with Applicative in general (I don't grasp its usefulness intuitively).
09:43:46 <fasta> jkff: the documentation for HXT is still horrible, imho. Have you actually used it?
09:43:57 <jmcarthur_work> i think >>= is the worst thing ever
09:44:08 <jkff> fasta: I've used it once as an experiment, I extracted links from some HTML or so.
09:44:25 <fasta> jkff: extracting is not modifying.
09:44:45 <jkff> fasta: Yes :) But it seemed to me that there were some cool examples of HXT in action in haskellwiki, maybe.
09:44:50 <jkff> With modification.
09:45:02 <jmcarthur_work> fmap :: (a -> b) -> (f a -> f b) ; point :: a -> f a ; ap :: f (a -> b) -> (f a -> f b) ; bind :: (a -> f b) -> (f a -> f b)
09:45:11 <osfameron> copumpkin: where's the best example of that tutorial (I still don't really get applicative... or see how functors help with understanding monads)
09:45:26 <glguy> jmcarthur_work: hear hear!
09:46:02 <jkff> Oh well, need to do some work. Thanks for the discussion :)
09:46:40 <Asztal> fasta: http://hackage.haskell.org/packages/archive/hxt/8.3.0/doc/html/Text-XML-HXT-Arrow-XmlArrow.html#v%3AprocessAttrl should do it
09:46:49 <Trinithis> >=> is cool. I was going to write my obligatory monad tutorial teaching monads through them instead of bind
09:46:53 <Asztal> multi (hasName "bar") >>> processAttrl (....)
09:46:58 <jmcarthur_work> Trinithis, definitely a good idea :)
09:47:06 <jmcarthur_work> Trinithis, <=< is even better though
09:47:09 <Raevel> @type (>=>)
09:47:10 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:47:12 <Trinithis> oh yuea
09:47:28 <Trinithis> the turorial would only need knowledge of .
09:47:35 <copumpkin> osfameron: not sure, I've heard people refer to it as a way of teaching monads (and the other classes) but I've never really read anything about it. I typically just start from functor, explaining why it's a useful abstraction and giving some examples. Then go to pointed and explain that although we do not have an explicit class for it (except in category-extras) it's still a useful thing, that gets incorporated into applicative. I 
09:47:37 <fasta> Asztal: "process the attributes of an element node with an arrow " Does that tell you what that function does?
09:47:47 <Trinithis> and monad law 3 would be readable with >=>
09:48:04 <jmcarthur_work> Trinithis, http://www.mail-archive.com/haskell-cafe@haskell.org/msg61193.html
09:48:13 <michaelfeathers_> Someone mentioned that I could structure this with a state t io monad the other day.  Not quite sure how to do that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8164#a8164
09:48:50 <fasta> HXT wants to say "arrows are the best, arrows are the best, arrows are the best!... oh, and with some luck you can do some XML transformations".
09:49:05 <jmcarthur_work> Trinithis, not a monad tutorial, but i think a good demonstration of the relationship between <=< and =<<
09:49:13 <michaelfeathers_> I just need to be able to call the same function over and over again with a different buffer each time.
09:49:27 <jmcarthur_work> and between <=< and .
09:49:31 <Trinithis> heh
09:50:25 <mkaemmer> michaelfeathers_: I suppose the idea was to write it as StateT EditMode IO()
09:50:27 <Trinithis> My idea is inspired by http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html.... but that's written for more advenced users
09:50:47 <Asztal> fasta: I have to agree, really: the fact that XML attributes are even stored and processed as an XML tree seems really silly
09:50:52 <michaelfeathers_> mkaemmer: whoever it was mentioned 'forever'
09:51:29 <SamB_XP> Asztal: you mean as children of the elements?
09:51:33 <mkaemmer> yeah, essentially your main loop would be "forever $ do {..}"
09:51:44 <SamB_XP> Asztal: it's actually a pretty common way of doing things ...
09:52:00 <mkaemmer> michaelfeathers_: instead of explicitly calling itself
09:52:06 <Asztal> SamB_XP: yeah, but as the same data type? data XNode = XText String | XAttr QName | XTag QName XmlTrees | ... <- this doesn't really help to catch errors
09:52:20 <SamB_XP> Asztal: mmm.
09:52:21 <Asztal> you could even have XAttrs in the content of the document
09:52:36 <yrlrnry> Is there a standard name for   foo f [] b = [] ; foo f (a:as) b = (f a b) ++ foo f as b ?
09:52:42 <michaelfeathers_> So, I would still be passing the buffer and EditMode around in functions called in do, eh?
09:52:49 <SamB_XP> Asztal: indeed, that's bad ...
09:52:59 <yrlrnry> That is, it turns a->b->c into [a]->b->[c] by calculating f a b for all the as, and concatenating the results.
09:53:17 <lilac> yrlrnry: that's a special case of map
09:53:27 <yrlrnry> It seems like there ought to be a short pointfree definition.
09:53:38 <yrlrnry> Oh, I just need to section f over b.
09:53:51 <lilac> f <$> as <*> pure b
09:54:06 <lilac> @type ?f <$> ?as <*> pure ?b
09:54:06 <mkaemmer> michaelfeathers_: you wouldn't have to.  You could instead treat the mode as a global var.  Access it with "mode <- get", change it with "put newMode"
09:54:08 <lambdabot> forall a a1 b (f :: * -> *). (?f::a -> a1 -> b, ?as::f a, Applicative f, ?b::a1) => f b
09:54:10 <yrlrnry>  \f as b -> map (`f` b) as
09:54:23 <yrlrnry> Thanks.
09:54:53 <mkaemmer> michaelfeathers_: that way it doesn't have to show up as an argument to any of your "StateT EditMode a" actions
09:54:58 <michaelfeathers_> mkkaemmer: is that what they call an IORef?
09:55:49 <mkaemmer> michaelfeathers_: Not in this case.  The state is a pure value that gets threaded by >>= for you (so that you don't have to explicitly pass it)
09:56:29 <michaelfeathers_> mkaemmer: Ah, k, like every other 'local var' in IO monad examples
09:58:27 <yrlrnry> The pointfree version is   flip . (map .) . flip, which I do not find very enlightening.
09:58:54 <mkaemmer> michaelfeathers_: yeah.  The nice part about the State monad, though, is that the state never has to interact with the outside world
09:59:29 <mkaemmer> michaelfeathers_: which is why it's often nicer to deal with StateT s IO() instead of just IO() using IORefs
09:59:41 <copumpkin> :t \f as b -> map (`f` b) as
09:59:43 <lambdabot> forall t a b. (a -> t -> b) -> [a] -> t -> [b]
09:59:50 <michaelfeathers_> mkaemmer: Know of an good online examples?
10:00:51 <yrlrnry> @djinn  (a -> t -> b) -> [a] -> t -> [b]
10:00:51 <lambdabot> Error: Undefined type []
10:00:56 <yrlrnry> Waaah!
10:00:58 <mkaemmer> I found this to be useful: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8164#a8164
10:01:10 <yrlrnry> @djinn  (a -> t -> b) -> m a -> t -> m b
10:01:10 <lambdabot> -- f cannot be realized.
10:01:11 <mkaemmer> er... nvm
10:01:12 <mkaemmer> http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
10:01:17 * yrlrnry scratches his head
10:01:17 <copumpkin> yrlrnry: can't think of a nicer way, but I'd typically do it with applicative
10:01:19 <mkaemmer> wrong copy buffer
10:01:36 <michaelfeathers_> mkaemmer: Much thanks.
10:01:56 <yrlrnry> copumpkin: Why would you us Applicative in preference to just  \f as b -> map (`f` b) as  ?
10:02:24 <copumpkin> yrlrnry: more general, I guess, not restricted to just lists
10:02:34 <shachaf> copumpkin: Not just Functor?
10:03:00 <yrlrnry> Mm.
10:03:03 <glguy> copumpkin: Applicative or Traversable?
10:03:13 <copumpkin> hmm
10:03:33 * glguy tries to find the beginning of this thread
10:03:44 <copumpkin> probably just functor really
10:05:15 <copumpkin> yrlrnry: if you reordered your arguments it'd be a bit easier to express succinctly
10:05:25 <yrlrnry> Yes, it would get rid of the flips.
10:09:41 <jmcarthur_work> :t \f m -> liftA2 f m . pure
10:09:43 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> b -> f c
10:09:51 <jmcarthur_work> @pl \f m -> liftA2 f m . pure
10:09:52 <lambdabot> flip flip pure . ((.) .) . liftA2
10:09:54 <jmcarthur_work> ew
10:15:02 <lilac> @type ?f <$> ?as <*> pure ?b :: (?f :: a -> b -> c, ?as :: [a], ?b ::b) => [c]
10:15:04 <lambdabot> forall a b c. (?b::b, ?as::[a], ?f::a -> b -> c) => [c]
10:17:03 <zxvf> how can I turn a Tree Int into a Tree String so I can use drawTree on it?
10:20:06 <Trinithis> out of curiosity, are there any nice lexing libraries that use regexes?
10:20:15 <Trinithis> for haskell
10:20:27 <Trinithis> in haskell*
10:20:31 <arjanb> zxvf: you can use fmap for that
10:21:15 <jeffersonheard> zxvf: fmap show myTree
10:21:25 <zxvf> aha, thanks
10:30:48 <mornfall> Is there a way to, from Foo :: * -> * -> * -> * -> *, get a Foo' :: * -> * -> * with the *last* two parameters substituted?
10:31:09 <copumpkin> not without a newtype
10:31:12 <copumpkin> as far as I know
10:31:13 <mornfall> Or simpler, Foo :: * -> * -> * to Foo' :: * -> * with its second parameter applied?
10:31:27 <mornfall> That sucks.
10:31:34 <copumpkin> well, or a type synonym
10:31:43 <mornfall> Type synonym would be fine. But.
10:32:40 <mornfall>     Type synonym `FlippedPairC' should have 4 arguments, but has been given 2
10:32:57 <mornfall> So I'm at a loss here...
10:33:20 <mornfall> Using type FlippedPairC a b c d = PairC c d a b
10:33:51 <copumpkin> yeah, you can't "curry" type synonyms afaik
10:34:03 <mornfall> Bwah.
10:34:07 <Saizan_> you can't partially apply them, rather
10:34:21 <mornfall> Is there a LANGUAGE incantation that will let me? : - )
10:34:37 <copumpkin> not that I know of
10:34:40 <mornfall> : - (
10:34:43 <copumpkin> although I certainly would like to see one
10:34:47 <Saizan_> no, higher order unification has not been implemented :)
10:34:50 <mornfall> I wouldn't mind, my LANGUAGE pragma is already 3 lines.
10:35:28 <mornfall> Well, I don't know. It does work for data...
10:36:03 <Saizan_> because data introduces a different type
10:36:12 <Saizan_> it doesn't "reduce"
10:38:30 <mornfall> Well, I really just need a multiparameter associated type synonym.
10:38:47 <mornfall> Like, class Foo a where type Bar a b c :: *.
10:39:15 <mornfall> (It would be probably even better than partially applied type synonym for my usecase...)
10:39:28 <mornfall> Hm, or no.
10:39:31 <mornfall> Or yes?
10:39:35 <mornfall> Oh dear... :)
10:39:48 * tibbe is having an unproductive day
10:39:58 <tibbe> anyone here familiar with Python's PEP process?
10:40:01 <mornfall> Well, bassoon time, anyway. Thanks for help so far (this type family thing is still somewhat over my head...)
10:41:06 <lilac> tibbe: no, but i'm curious what feature you're suggesting :)
10:41:40 <EnglishGent> hello :)
10:41:44 <tibbe> lilac: Actually I want to suggest that a similar process be used for adding packages to the Haskell Platform in order to improve library quality.
10:42:33 <EnglishGent> tibbe - what process is that? (curious!)
10:42:48 * EnglishGent interested in the general problem of library design / quality
10:42:59 <tibbe> EnglishGent: http://www.python.org/dev/peps/ - In particular PEP 1 & 2
10:43:06 <EnglishGent> ty :)
10:43:22 <EnglishGent> btw .. a couple of questions for the whole channel (trying to deepen my knowledge of Haskell)
10:43:48 <EnglishGent> 1) I know that you _can_ do dynamic programming in Haskell - but that's all I know - can someone link me to any papers / articles on how it's done?
10:44:19 <lilac> do you mean Dynamic Programming (tm) or do you mean dynamic typing?
10:44:32 <EnglishGent> 2) can anyone provide me with examples or a link giving examples of multi-parameter type classes which do _not_ use functional dependencies, but are still useful
10:44:57 <EnglishGent> I mean things like toDynamic, fromDynamic (I've seen references to them) - but I know nothing about them :|
10:45:09 <lilac> functional languages are generally great for DP, and haskell is no exception. for dynamic typing, there's Data.Dynamic
10:45:40 <EnglishGent> okay - what do you consider Dynamic Programming to be? I know nothing about Data.Dynamic beyond it's existence
10:45:47 <EnglishGent> I'm trying to find out more about it :)
10:46:05 <c_wraith> Dynamic Programming is a way of optimizing redundant recursion
10:46:12 <c_wraith> It's not in any way related to dynamic typing
10:46:43 <lilac> EnglishGent: there's some vaguely related stuff here: http://www.cs.vu.nl/boilerplate/
10:46:49 <HugoDaniel> hi
10:47:08 <EnglishGent> ty all :)
10:47:09 <EnglishGent> hi HugoDaniel :)
10:48:16 <lilac> there's probably a better introduction to Dynamic than the SYB stuff somewhere, but i don't know where
10:48:38 <EnglishGent> well I have to start somewhere
10:48:54 <glguy> Typically if you are using Data.Dynamic you are "doing it wrong"
10:49:10 <EnglishGent> yes I get that glguy - but I'd like to understand it anyway
10:49:21 <glguy> it is just a generic wrapper for a value
10:49:29 <glguy> and when you try to unwrap it, you pick a type
10:49:34 <EnglishGent> I've been reading through the paper on strongly typed hetrogenous collections - and I want to understand all the concepts it references
10:49:36 <glguy> and if you picked the wrong type, you get a nothing
10:49:40 <glguy> the right type, a Just value
10:49:55 <lilac> the technique used by Data.Dynamic -- an existential wrapper around a value in a type-class -- is a useful one in general, even if Data.Dynamic is usually too dynamic for most purposes
10:50:22 <glguy> > fromDynamic (toDyn 'a') :: Maybe Char
10:50:23 <lambdabot>   Just 'a'
10:50:24 <glguy> > fromDynamic (toDyn 'a') :: Maybe Int
10:50:25 <lambdabot>   Nothing
10:50:30 <glguy> > toDyn 'a'
10:50:31 <lambdabot>   <<Char>>
10:50:35 <glguy> :t toDyn 'a'
10:50:36 <lambdabot> Dynamic
10:50:49 * EnglishGent is trying to work up to groking the CoddFish library in depth - i.e. all the concepts it referes to & all the concepts in the papers explaining those concepts refer to .. and so on recursively
10:50:56 <glguy> > map fromDynamic [toDyn 'a', toDyn 10] :: [Maybe Int]
10:50:57 <lambdabot>   [Nothing,Nothing]
10:51:02 <glguy> > map fromDynamic [toDyn 'a', toDyn (10::Int)] :: [Maybe Int]
10:51:03 <lambdabot>   [Nothing,Just 10]
10:51:34 <EnglishGent> it bugs me when I read a paper and one paragraph effectivley reads (from my view point) "wibble wibble blah blah"
10:51:51 <EnglishGent> even if I think that paragraph isnt significant... if I dont know what it means - how can I be sure? :|
10:52:17 <lilac> EnglishGent: re MPTCs, an easy example is: class Isomorphic a b where convert :: a -> b; convert' :: b -> a
10:53:15 <EnglishGent> that's the only one I know that *doesnt* use functional dependencies lilac :)
10:53:42 <EnglishGent> I'm assuming there must be more for the concept to have been explored in the first place
10:54:01 <copumpkin> > toDyn id
10:54:03 <lambdabot>   Add a type signature
10:54:13 <copumpkin> > toDyn (id :: Int -> Int)
10:54:15 <lambdabot>   <<Int -> Int>>
10:54:22 <copumpkin> magick!
10:54:26 <lilac> MPTCs without functional dependencies, associated types or similar aren't all that useful
10:54:40 <EnglishGent> associated types? what are those?
10:55:20 <lilac> they're a (more powerful) alternative to functional dependencies, which (amongst other things) solve the same problem
10:55:29 <copumpkin> how are they more powerful?
10:55:35 <EnglishGent> got a link? never heard of them!
10:55:42 <copumpkin> they seem more pleasant to use in many cases
10:56:01 <lilac> copumpkin: the ~ type equality adds power you can't get with fundeps, afaics
10:56:17 <glguy> example?
10:56:18 <lilac> admittedly that's a side benefit, but it's the same language extension :)
10:56:45 <copumpkin> lilac: it seems that any situation you have with a ~ F b, you can do with X a b
10:56:45 <Saizan_> isn't that Oleg's TypeEq class?
10:56:51 <copumpkin> lilac: but maybe not?
10:57:32 <lilac> you can do GADTs with ~: data Foo a b = (b ~ [a]) => Bar b | (b ~ Maybe a) => Baz b
10:57:51 <lilac> (that also needs ExistentialQuantification, but not GADTs)
10:57:57 <EnglishGent> has anyone come across Chameleon btw? (programming language)
10:58:01 <EnglishGent> if so - thoughts? :)
10:58:37 <lilac> if you can do GADTs with TypeEq then maybe they're the same :)
10:58:49 <Rotaerk> it must have camouflaged itself when I was about to notice it
10:58:55 <EnglishGent> lol!
10:59:17 <lilac> EnglishGent: this is a pretty good introduction: http://www.haskell.org/haskellwiki/GHC/Type_families
10:59:26 <EnglishGent> Rotaerk -- http://taichi.ddns.comp.nus.edu.sg/taichiwiki/ChameleonHomePage
10:59:27 <EnglishGent> :)
10:59:31 <EnglishGent> thanks lilac :)
11:00:16 <Saizan_> lilac: you need to apply the coercion yourself with TypeEq, and you can't cheat wrt decomposition, so i guess ~ is more powerful :)
11:00:18 * glguy found a MPTC without *a* fundep in his work src directory
11:00:28 <glguy> oops, emphasized the wrong 'a'
11:00:29 <EnglishGent> I dont get GADTs properly yet either .. but like I said I've started by setting a goal of working up to the Coddfish stuff (becuase I love the idea of ditching dynamic SQL generation for something actually typesafe!)
11:00:51 <EnglishGent> glguy - could you provide the example? :)
11:01:49 <glguy> EnglishGent: it was used in a heterogeneous set type
11:02:18 <glguy> the code isn't mine to share
11:02:24 <EnglishGent> okay - np
11:03:26 <EnglishGent> I'd just like to collect a few more examples that's all - partly for tuition purposes (I have a personal heuristic - if you cant give a class on something - you dont understand it well enough)
11:03:27 <EnglishGent> :)
11:05:34 <lilac> EnglishGent: IArray and MArray have no fundeps
11:06:11 <lilac> though they achieve that by forcing the array type to have kind * -> * -> *, which is kinda unfortunate
11:06:12 <EnglishGent> thanks lilac :)
11:07:08 <lilac> From the Haskell' wiki: "MultiParamTypeClasses are very useful, but mostly in the context of FunctionalDependencies."
11:07:40 <edwardk_> they are occasionally insanely useful, even without the fundeps
11:07:53 <EnglishGent> I've already noted that nearly all the practical examples involve a fundep - but if I was going to teach the concept I'd want to give motivating examples *without* fundeps
11:08:01 <EnglishGent> and then move on to fundeps
11:08:16 <edwardk_> I avoid fundeps for my monoidal reducers
11:08:33 <edwardk_> and then i provide combinators that help work around the inference issues
11:09:18 <EnglishGent> edwardk - could you explain that in more detail? I dont really follow you :|
11:09:48 <EnglishGent> (I do get monads)
11:11:08 <edwardk_> EnglishGent: i have a class that looks like: class Monoid m => Reducer c m where unit :: c -> m
11:11:26 <edwardk_> where the Reducer class is meant to be read infix as a "c `Reducer`"
11:12:51 <Baughn> ChthonLaptop: So you are.
11:13:05 <ChthonLaptop> Or am I?
11:13:13 <EnglishGent> hmm .. I know what a monoid is (dimly) - thing from abstract math right? not sure what a reducer is
11:13:14 <Baughn> You definitely are.
11:13:25 <ChthonLaptop> Hello all, you have been recommended to me by the honorable Baughn.
11:13:40 <EnglishGent> hello ChthonLaptop
11:13:56 <Baughn> ChthonLaptop: http://hackage.haskell.org/platform/ <- While I'm at it, have a haskell. Possibly for great justice.
11:13:57 <ChthonLaptop> Hello :)
11:14:23 <blackh> Hello!
11:14:25 <edwardk_> EnglishGent: the idea of a Monoid is just an 'associative operation that has a unit' -- in otherwords: a `mappend` (b `mappend` c) = (a `mappend` b) `mappend` c -- and a `mappend` mempty = mempty `mappend` a = a
11:15:44 * copumpkin thinks the verbose and inappropriately-named mappend detracts from that explanation :P
11:15:54 <edwardk_> EnglishGent: the notion of a 'reducer' in this sense is that you want to allow your particular monoid to 'reduce' values of another type. i.e. if you have a 'Length' monoid that measures string length you might have mempty = Length 0, Length a `mappend` Length b = Length (a + b) -- and define
11:16:06 <edwardk_> instance Reducer Char Length where unit _ = 1
11:16:20 <edwardk_> instance Reducer String Length where unit = Length . length
11:16:35 <edwardk_> instance Reducer Strict.ByteString Length where unit = Length . Strict.length
11:16:37 <edwardk_> etc.
11:16:38 <yrlrnry> examples of monoids:  (a) Integers with addition; unit is 0;  (b) non-negative integers with addition; unit is 0;  (c) positive integers with multiplication; unit is 1;  (d) strings over some alphabet, with concatenation; unit is "";  (e) lists over some type, with list appending (++); unit is [].
11:17:11 <edwardk_> copumpkin: yeah =(
11:17:17 <Baughn> ChthonLaptop: ..see what I mean? Don't worry, though. We don't bite, and you don't /have/ to understand all the jargon just to use haskell.
11:17:17 <EnglishGent> okay - monoids make complete sense to me, still not sure about reducers :)
11:17:32 <edwardk_> EnglishGent: heh i have slides, one sec =)
11:17:38 <jmcarthur_work> (f) monads, with return as unit and <=< as the operation   :)
11:17:49 <edwardk_> EnglishGent: http://comonad.com/reader/2009/hac-phi-slides/
11:17:56 <EnglishGent> thanks :)
11:18:10 <yrlrnry> (g) functions a->a, with function composition; unit is identity function
11:18:38 <copumpkin> how about this?
11:18:41 <copumpkin> @instances Monoid
11:18:41 <ray> <=< is really more an Arrow thing though
11:18:42 <ChthonLaptop> I definately have to turn off emoticons in here LOL
11:18:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:18:50 <EnglishGent> you know the Haskell wiki could really do with a 'jargon' section
11:18:52 <yrlrnry> edwardk:  I was really sorry to miss hac-phi.  I live in Philadelphia but was on a business trip to San Francisco the previous week so couldn't come.  I wish I had been able to meet you.
11:18:55 <edwardk_> EnglishGent: http://hackage.haskell.org/package/monoids-0.2.0.1 has a bunch more
11:19:18 <EnglishGent> thanks again all :)
11:19:18 <edwardk_> yrlrnry: ah well, you could always come out to Boston for the next BHUG meeting on the 18th ;)
11:19:19 <jmcarthur_work> ray, yeah, you're right. there is another (more correct) sense in which monads are monoids though
11:19:21 <yrlrnry> How is (a, b) a monoid?
11:19:36 <edwardk_> yrlrnry: instance (Monoid a, Monoid b) => Monoid (a,b)
11:19:40 <jmcarthur_work> yrlrnry, (Monoid a, Monoid b) => Monoid (a, b)
11:19:41 <yrlrnry> Oh, okay.
11:19:46 <edwardk_> mempty = (mempty,mempty); etc
11:19:51 <yrlrnry> Sure, that's obvious.
11:20:00 <ChthonLaptop> Baughn:  I read WoW mods just fine even though I haven't learned the language yet too, I get the gist of what's going on without the icons.
11:20:18 <yrlrnry> But it's different from a->a because a->a  can be made a monoid in a canonical way regardless of whether a itself is a monoid.
11:20:25 <edwardk_> monoid products are always defined, just like applicative products (which makes sense because a monoid is 'an applicative without an argument' =)
11:20:31 <glguy> What's an example use of Control.Applicative.many (other than "many empty") that isn't _|_?
11:20:37 <Baughn> ChthonLaptop: You may find that that won't quite work here, but good luck. It's an interesting language.
11:20:44 <jmcarthur_work> @src many
11:20:45 <lambdabot> Source not found. :(
11:20:50 <jmcarthur_work> @src Control.Applicative.many
11:20:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:20:54 <glguy> many :: Alternative f => f a -> f [a]
11:20:57 <glguy> many v = many_v
11:20:59 <glguy>   where many_v = some_v <|> pure []
11:21:01 <glguy>         some_v = (:) <$> v <*> many_v
11:21:05 <edwardk_> yrlrnry: yeah, a -> a is the monoid of endomorphisms on any object a category
11:21:06 <jmcarthur_work> oh that
11:21:19 <jmcarthur_work> glguy, i think Parsec has an example
11:21:25 <EnglishGent> I get the impression it depends on how great a depth of understanding one wants, you can use the language without needing to know category theory for example
11:21:48 <EnglishGent> but if you want to really _understand_ it - knowing the maths / jargon is a definite requirement
11:21:55 * copumpkin wants to rnf Haskell
11:22:00 <yrlrnry> It's kind of a shame that so much of the terminology comes from category theory.  I don't think it helps anyone that Functor is called Functor.
11:22:13 <edwardk_> EnglishGent: knowing the category-theoretic lingo helps, but mostly just because i never bother to clarify what i mean =)
11:22:20 <copumpkin> yrlrnry: I think it's a good thing
11:22:23 <ray> what would you prefer to call it? NewbieFriendlyFunClass?
11:22:24 <yrlrnry> Why so?
11:22:24 <jmcarthur_work> yrlrnry, what would it better be called with the same level of genericity?
11:22:31 <EnglishGent> in that respect it's unlike (say) Lisp - you dont *really* need to know Lambda calculus to read most stuff on Lisp
11:22:38 <edwardk_> yrlrnry: category theory gives us a lot of tools we wouldn't otherwise know we had
11:22:42 <ray> except then newbies would get all confused by the word functor if they ever encountered it in the future
11:22:49 <yrlrnry> Do I have to produce an alternative in order to criticize the existing name?
11:22:56 <EnglishGent> Haskell does seem (in my experience anyway) as a _language_ less newbie friendly
11:22:59 <yrlrnry> I am not at all criticizing category theory.
11:23:03 <EnglishGent> though I conceed this channel helps a lot! :)
11:23:11 <ray> it's called Functor because it is a functor, so there's a good reason for that name
11:23:23 <jix_> has anyone learned haskell as first programming language?
11:23:32 <yrlrnry> I did not say there was no good reason for the name, and I knew what a functor wa slong before I programmed in Haskell.
11:23:34 <edwardk_> yrlrnry: for instance I can lean on 57 years of category theoretic proofs, terminology and background knowledge. 57 years ago the only thing on the scene that we still actively use was the beginnings of LISP. How many other ideas in comp sci have been around that long or are as well studied?
11:23:34 <jeffersonheard> woo hoo!  OpenCL Raw builds!
11:23:40 <jeffersonheard> Now to do some testing of it
11:23:42 <ray> you could call it Mappable and sacrifice that, or you could just mention in your haskell tutorial that "Functors are types that can be mapped over"
11:23:45 <ray> i prefer the latter
11:23:51 <jmcarthur_work> jix_, my wife has learned a little bit. doesn't seem to be any harder for her than imperative languages were for me
11:24:00 <ChthonLaptop> Well WoW uses a reduced for of Lua for their interface mods, and that is pretty straightforward for me to read.
11:24:02 <edwardk_> yrlrnry: its like getting 50+ years of documentation for free =)
11:24:20 <jix_> jmcarthur_work: yeah that's what i would have guessed
11:24:27 <yrlrnry> Yeah, it's probably not that important.  Programmers swallow much more awful terminological enormities all the time.
11:24:37 <EnglishGent> I know some people who've are learning it as their second (after scheme) - I dont know anyone who's done it as their first though
11:24:50 <yrlrnry> If people can deal with "car" and "cdr", they shouldn't have any trouble with Functor.
11:24:53 <edwardk_> ray: but then you've just constructed an adhoc notion that requires all of the properties to be proven from scratch. by saying it is a functor, the functor laws come along for free, and give us the desiderata of what a mappable thing _should_ provide.
11:24:56 <dino-> Otherwise, some of it is just labels. After the first few weeks I stopped caring that return is called return and the strangeness of it vs imperative return statements. The important thing is knowing what it's for and how to use it.
11:24:57 <ChthonLaptop> After scheme?
11:25:05 <ray> edwardk_: yes
11:25:10 <EnglishGent> yes ChthonLaptop (the people I know anyway) :)
11:25:17 <jix_> i just noticed that i's very difficuilt to teach haskell to people who can't stop to think in an imperative way
11:25:19 <ray> the abstract nonsense comes in handy
11:25:21 <ChthonLaptop> I mean what does that mean?
11:25:25 <edwardk_> ray: fmap f . fmap g = fmap (f . g) and fmap id = id -- are downright useful laws, Mappable carries none of those connotations
11:25:29 <yrlrnry> edwardk:  Oh, you're saying that by calling it Functor, that suggests to people that it will satisfy (map f) . (map g) = map (f . g)?
11:25:29 <jix_> but i guess if people haven't programmed before that shouldn't be a problem
11:25:39 <yrlrnry> yeah, I'll buy that.
11:25:48 <EnglishGent> though I conceed that's partly becuase I'm teaching them - and I already know Scheme well (and I'm used to thinking in a functional way - I hardly ever write Scheme code with state for example)
11:26:02 <jmcarthur_work> ChthonLaptop, maybe we aren't aware of the programming language called Scheme>
11:26:03 <jmcarthur_work> ?
11:26:10 <jmcarthur_work> *maybe you
11:26:24 <ChthonLaptop> Nope, wasn't, picked it up that it was one after EnglishGent's last comment though
11:26:40 <edwardk_> yrlrnry: and Monad carries along with it the theoretical notion of the monad laws. You could dumb it down and call it a Workflow or whatever the f# guys did, but take a look at the monstrosity that results. Workflows have terrible semantics, no one knows what they mean.
11:26:41 <yrlrnry> On the other hand, maybe one could make an argument that it should not be called Functor since the language doesn't give you any way to enforce that it actually is a functor.
11:26:55 <jmcarthur_work> ChthonLaptop, it's a cute lisp, some swear by it, but i like haskell more ;)
11:26:56 <EnglishGent> I came across 'the Haskell road to Logic, Math & Programming' - that seems to be a good text
11:26:58 <glguy> yrlrnry: by that logic you wouldn't call something quicksort
11:27:04 <glguy> as it might be const []
11:27:04 <jix_> yrlrnry: wouldn't that be the case with monads too
11:27:09 <edwardk_> yrlrnry: actually the only property you have to force extra-linguistically is fmap id = id the rest comes as a free theorem given that
11:27:12 <yrlrnry> glguy:  Okay.
11:27:12 <ray> if you start going down that path, you can't give typeclasses names becaouse you could theoretically define all their methods with error
11:27:38 <yrlrnry> Yes, i withdraw the argument.
11:27:42 <jix_> afaik there are even some monads in base that violate monad laws
11:27:52 * yrlrnry is shocked.
11:27:59 <jmcarthur_work> there are Monads everywhere that aren't monads :(
11:28:07 <ray> something like quickcheck can help avoid accidental violations
11:28:16 <edwardk_> yrlrnry: but in general typeclasses have unenforceable constraints. you _choose_ the applicative to be the right one for your purposes, you choose that Show provides valid source code, etc.
11:28:32 <yrlrnry> Hm, I have a 2:30 meeting.  Thanks.
11:29:05 <edwardk_> hey dualio
11:29:41 <EnglishGent> Cthulhon - have you come across the 'A taste of Haskell' videos?
11:29:46 * jmcarthur_work sighs and wonders if he should adopt the "co" prefix as well...
11:29:56 <EnglishGent> they are good for getting started if your already a programmer
11:30:00 <glguy> that probably depends on how trendy you are
11:30:24 <edwardk_> EnglishGent: anyways regarding the original topic, i used an MPTC without a fundep to allow one monoid to reduce multiple input types. i.e. Length can reduce Char, ByteString, String, etc.
11:30:48 <jmcarthur_work> glguy, it's trendy not to be trendy
11:31:05 <glguy> Then you might be stuck
11:31:27 <edwardk_> EnglishGent: or newtype Sum a = Sum a; instance Num a => Monoid (Sum a) where ....; can have instance Num a => Reducer a (Sum a) where unit = Sum
11:31:29 <_|_> i'm stuck!
11:31:55 <EnglishGent> stuck at the bottom I guess?
11:31:57 <EnglishGent> (sorry) :)
11:32:08 <edwardk_> EnglishGent:: newtype Endo a = Endo (a -> a); instance Monoid (Endo a) where mempty = Endo id; ... can have instance Reducer (a -> a) (Endo a) where unit = Endo; ...
11:32:27 <ChthonLaptop> EnglishGent: First I've got nothing to do with the pop culture horror deity known as Cthulhu.  Chthon refers to the ancient greek style gods and heroes that did not live on olympus, who lived amongst mortals.  second no I haven't yet.  If you give me links though I'll look at them at work tomorrow.
11:32:27 <Saizan_> edwardk_: those two would work with fundeps too, i think
11:32:52 <Saizan_> edwardk_: if the fundep is Reducer c m | m -> c
11:33:14 <EnglishGent> links to the vidoes & slides Cthulhon|WORK -- http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/index.htm
11:33:15 <EnglishGent> :)
11:33:18 <ChthonLaptop> edwardk_:  If Sum a = Sum a, does Sumus a = Sumus a when there's more than one A?
11:33:27 <edwardk_> Saizan_: sure, but newtype Action m = Action { getAction :: m () }; instance Reducer (m a) (Action m) -- cannot
11:33:39 <J11> Anyone ever got: No instance for (Monad ((->) Int)) ?
11:33:47 <edwardk_> instance Reducer a () where unit _ = () -- cannot
11:33:57 <quicksilver> J11: import Control.Monad.Instances, if you really do want that instance
11:33:57 <_|_> J11, Control.Monad.Instances or something, i think
11:34:06 <quicksilver> J11: but maybe you don't, maybe it was a mistake
11:34:06 <EnglishGent> I found them to be very useful
11:34:43 <Baughn> @seen lambdabot
11:34:44 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
11:34:44 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
11:34:44 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
11:34:44 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
11:35:11 <edwardk_> Saizan_: and there are other cases that are downright convenient, for instance, providing both: instance Reducer (Maybe a) (First a) instance Reducer a (First a)
11:35:24 <EnglishGent> also there's O'Reilly book available free online : http://book.realworldhaskell.org/
11:35:43 * benmachine wonders if some oddity of @seen is causing channels from being broken between messages incorrectly
11:35:49 <benmachine> er
11:35:56 <benmachine> preventing
11:35:58 * Baughn wonders if we really need that many channels
11:36:08 <EnglishGent> I can recommend some stuff I found useful on learning category theory, etc as well if you pm me - I dont want to start spamming the channel with links
11:36:19 <ChthonLaptop> Oh yeah, when I get done with my deployment I"m getting out of the army.  Anyone know of a good school to go to finish my Comp Sci Degree that I can afford with the GI Bill?
11:36:30 <benmachine> probably not, Baughn, but they are cheap so why not
11:36:37 <EnglishGent> especially as I'm pretty sure most of the people here already know them
11:36:42 <yrlnry> I didn't know that RWH was available online.   That's excellent.
11:37:12 * EnglishGent is trying, but is still very much a Haskell newbie :|
11:37:24 <benmachine> hi5
11:37:36 <EnglishGent> yrlnry - 'the Haskell Road' is available online as well for those wanting a more comp-scish introduction :)
11:37:43 <EnglishGent> (in case you didnt know) :)
11:38:12 <Saizan_> edwardk_: i see, i was misunderstanding the purpouse of the earlier examples :)
11:38:16 <yrlnry> I took that out of the library a few months back, but it did not make a good impression on me.
11:38:55 <edwardk_> Saizan_: no problem. =) EnglishGent was looking for an example of MPTCs that didn't use fundeps
11:40:08 <glguy> edwardk_: do you envision those newtypes being used like:  getApp . foldMap App ?
11:40:29 <edwardk_> glguy: http://hackage.haskell.org/packages/archive/monoids/0.2.0.1/doc/html/Data-Generator-Combinators.html =)
11:40:35 <edwardk_> view source ;)
11:41:31 <J11> Well, I was trying out one of @pl 's suggestions (but they sometimes look uglier than the original. But my code has still the same infinite loop as the original with certain input.
11:41:34 <glguy> edwardk_: so,  reduceWith getApp ?
11:41:37 <edwardk_> glguy: the reduce operations there are defined in Data.Generator in the same module
11:41:38 <edwardk_> yeah
11:41:42 <edwardk_> er same package
11:42:12 <edwardk_> reduceWith uses the unit to embed into the monoid implicitly.
11:42:40 <glguy> So you've solved picking type classes with more typeclasses, eh? :)
11:42:44 <c_wraith> @instances Monoid
11:42:44 <edwardk_> yeah =)
11:42:45 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:42:48 <edwardk_> well
11:42:50 <edwardk_> in this case
11:43:12 <c_wraith> @src Monoid (->)
11:43:13 <lambdabot> Source not found. It can only be attributed to human error.
11:43:13 <edwardk_> the Generator exists explicitly to choose a left to right or right to left biased (or parallel) reduction based on the container
11:43:17 <quicksilver> J11: yes, @pl uses the monad (->) instance.
11:43:36 <quicksilver> c_wraith: it's "(f `mappend` g) x = f x `mappend` g x
11:43:49 <quicksilver> c_wraith: what the mathematicians would call "defined pointwise"
11:43:57 <edwardk_> glguy: so for instance it can stride through lazy bytestrings, handling each chunk left to right, and basically just foldMap over the chunks
11:44:16 <c_wraith> Ah.  So it only works if (f x) and (g x) are monoids?
11:44:48 <edwardk_> c_waith: yeah
11:45:11 <glguy> edwardk_: Is the advantage of Generator over Foldable that Generator makes no claim on the structure of the type c
11:45:22 <glguy> edwardk_: while Foldable demands a *->* kind?
11:45:32 <edwardk_> glguy: Generator works on ByteStrings basically ;)
11:45:33 <edwardk_> yeah
11:45:38 <EnglishGent> @src AE35
11:45:38 <lambdabot> Source not found. Do you think like you type?
11:46:05 <edwardk_> basically all of the monoidal reduction operations there are perfectly well defined over monotypic containers.
11:46:31 <yrlnry> @instances Monad
11:46:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:47:01 <edwardk_> glguy: i use it to make FingerTrees into a Generator for instance, Lazy ByteStrings, unboxed arrays, etc.
11:47:42 <jeffersonheard> How would I represent the following floating point number (written in C float-hex notation) in Haskell?  0x1.fffffep127f
11:48:38 <EnglishGent> ok - gotta go - rl
11:48:41 <EnglishGent> thanks again all! :)
11:49:34 <glguy> edwardk_: did make a Traversable replacement?
11:50:27 <edwardk_> glguy: nah, mainly because it can't do much when it is monotypic
11:50:43 <quicksilver> jeffersonheard: what's that 'p' mean?
11:51:21 <edwardk_> glguy: think about sequenceA :: (Traversable t, Applicative f )=> t (f a) -> f (t a)
11:51:32 <copumpkin> probably separating the exponent from the significand?
11:51:35 <edwardk_> glguy: all methods in traversable require you to have a polytypic container to start with basically
11:52:02 <edwardk_> traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) -- might be salvaged
11:52:16 <copumpkin> edwardk_: isn't that what you call Dist or something similar in category-extras?
11:53:00 <edwardk_> traverse' :: (RecursiveGenerator t, Applicative f) => (Elem t -> f (Elem t)) -> t -> f t
11:53:05 <edwardk_> or something like that
11:53:46 <quicksilver> >  0x1fffffe / 0x1000000 * (2^127)
11:53:48 <lambdabot>   3.4028234663852886e38
11:53:51 <quicksilver> jeffersonheard: ^^ like that, I assume.
11:54:03 <quicksilver> jeffersonheard: if it means what I guess it means.
11:54:12 <jeffersonheard> p is the exponent signifier
11:54:17 <quicksilver> yes, I googled it.
11:54:48 <jeffersonheard> sorry, forgot to pay attn. to the window after I typed the question
11:54:50 <edwardk_> where class Generator t => RecursiveGenerator t  where traverse' :: Applicative f => (Elem t -> f (Elem t)) -> t -> f t -- which looks almost like the bastard child of Compos and Traversable
11:55:50 <jeffersonheard> quicksilver, are doubles the same format, or do I need to put the 1 at the left of 8 bytes?
11:56:15 <jeffersonheard> that is, the stuff on the right
11:56:23 <edwardk_> glguy: if i think about it and a nice name comes to me i might drop that into monoids
11:56:33 <jeffersonheard> sorry - I may not be making sense.  ppl are distracting me all of a sudden
11:56:58 <glguy> I'll keep an eye out for it ;)
11:58:14 <yrlnry> What is the likelihood that Haskell-prime will have a true natural number type?
11:59:00 <ray> at the rate it's going, haskell prime will come out in 2015 and be h98 with hierarchical modules and no monomorphism restriction
11:59:10 <edwardk_> glguy: just give me a name ;)
11:59:13 <tkr> yrlnry: 0.0028%
11:59:34 <jeffersonheard> >  0x1fffffe / 0x10000000 * (2^127)
11:59:35 <lambdabot>   2.1267646664908054e37
11:59:44 <yrlnry> Oh, so the promise on the web site of a late 2009 release is unlikely to be fulfilled?
11:59:46 <jeffersonheard> >  0x1fffffe / 0x10000000 * (2^127) :: CFloat
11:59:47 <lambdabot>   Not in scope: type constructor or class `CFloat'
11:59:50 <jeffersonheard> >  0x1fffffe / 0x10000000 * (2^127) :: Float
11:59:51 <lambdabot>   2.1267647e37
11:59:57 <copumpkin> CReal?
12:00:01 <jeffersonheard> >  0x1fffffe / 0x10000000 * (2^127) :: Double
12:00:02 <lambdabot>   2.1267646664908054e37
12:00:10 <edwardk_> glguy: Recursive, Passable,Refillable...
12:00:11 <copumpkin> >  0x1fffffe / 0x10000000 * (2^127) :: CReal
12:00:13 <lambdabot>   21267646664908053738231511467782307840.0
12:00:14 <jix_> isn't everyone using lots of extensions everywhere anyway?
12:00:21 <edwardk_> glguy: nothing quite sounds right
12:00:25 <edwardk_> <- stickler for names
12:01:53 <edwardk_> the biggest problem with something traversable is the potential for state killing parallelization opportunities
12:08:29 <glguy> edwardk_: the type-inference issues are pretty rough in Data.Generator
12:08:31 <burp> why don't haskell arrays have foldl and similar functions?
12:08:40 <burp> I guess there is a reason ;)
12:09:10 <copumpkin> aren't they Foldable instances?
12:09:15 <glguy> mapReduceWith getAlt (pure :: a -> [a]) [1,2,3,4::Int] :: [Int]
12:09:19 <_|_> they should be
12:09:24 <burp> uh, let me check
12:09:30 <glguy> I'm not sure that any of those type annotations was unneccesary
12:09:43 <burp> at least I don't see it
12:09:55 <_|_> @instances Foldable
12:09:56 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
12:10:05 <_|_> @instances-importing Data.Foldable Foldable
12:10:07 <lambdabot> Maybe, []
12:10:13 * glguy lunches
12:10:21 <copumpkin> instance Ix i => Foldable (Array i)
12:10:35 <burp> ah
12:10:42 <copumpkin> also traversable and functor
12:10:43 <_|_> yup
12:10:45 <_|_> Traversable, even
12:10:48 <edwardk_> glguy: the problem there is the defaulting, etc.
12:10:49 <burp> oh.. great :>
12:10:53 <burp> that's good to know ;-)
12:11:02 <copumpkin> why not applicative?!?!!?
12:11:02 <copumpkin> :P
12:11:47 <_|_> yeah i guess ZipList semantics would make sense
12:12:10 <copumpkin> or even regular list ones?
12:12:12 <edwardk_> glguy: Data.Generator.Combinators.asum [1,2,3,4] :: [Int]
12:12:31 <edwardk_> glguy: the goal was to be able to use it to mimic the Foldable API
12:12:38 <_|_> sure, i suppose
12:12:40 <edwardk_> hence the .Combinators module
12:15:00 <edwardk_> copumpkin: define the applicative instance
12:15:09 <edwardk_> copumpkin: how do you combine the indexes?
12:15:40 <copumpkin> cartesianishly?
12:15:44 <copumpkin> :P
12:15:48 <edwardk_> copumpkin: type signature fail =)
12:15:59 <copumpkin> really?
12:16:02 <copumpkin> oh
12:16:29 <copumpkin> yeah, that's annoying then
12:16:41 <edwardk_> copumpkin: you might be able to say that you want arrays with natural indexes to combine by multiplying the cell count, etc.
12:16:51 <copumpkin> yeah, that's what I meant
12:16:57 <copumpkin> but the indices would get lost along the way
12:17:10 <edwardk_> i.e. a 6 element array * a 5 element array is a 30 element array, but that requires you to have a well defined start index
12:17:15 <burp> um, just for Array right?
12:17:18 <burp> not for UArray, etc.
12:17:57 <edwardk_> burp: UArray can't work because you don't have the polymorphism required for Applicative
12:18:14 <edwardk_> they aren't parametric in their contents
12:18:33 <edwardk_> burp: so, yeah
12:19:16 <burp> so "getElems :: (MArray a e m, Ix i) => a i e -> m [e]" this is the way?
12:19:22 <copumpkin> but Functor should work
12:19:22 <copumpkin> or not?
12:19:22 <copumpkin> it doesn't have an instance at least
12:19:28 <burp> or look at http://hackage.haskell.org/packages/archive/uvector/0.1.0.4/doc/html/Data-Array-Vector.html
12:19:39 <edwardk_> copumpkin: you could, i suppose cheat and try to calculate out a new range using some horrible hack assuming that Num behaves like the integers, etc. ;)
12:19:51 <edwardk_> burp: yeah
12:20:09 <burp> uvector looks very promising to me
12:20:47 <copumpkin> burp: it's a little rough still
12:20:54 <copumpkin> burp: but very nice anyway :P
12:21:01 <edwardk_> burp: but no applicative in sight there either, due to the lack of parametricity
12:21:29 <burp> but it has fold and other nice functions
12:22:21 <edwardk_> hrmm there also doesn't seem to be a uvector cartesian product
12:23:24 <copumpkin> burp: yeah, it's pretty nice
12:23:25 <edwardk_> something like: cross :: (UA a, UA b, UA c) => (a -> b -> c) -> UArr a -> UArr b -> UArr c
12:23:43 <copumpkin> yeah :/
12:23:48 <edwardk_> that is, one that isn't zip
12:24:00 <edwardk_> the MUArr should be allocatable for the result, trivially
12:24:01 <copumpkin> that wouldn't fuse very well
12:24:19 <edwardk_> well, it'd fuse over the inner loop at least
12:25:07 <edwardk_> zip and cross-join like operations rarely fuse well though
12:26:56 <copumpkin> yeah
12:35:00 <flippeh_> How do I get an "empty" IO Handle?
12:35:16 <flippeh_> I have a data type that includes a field that's a Handle type
12:35:26 <flippeh_> Yet it cannot be set initially
12:35:41 <flippeh_> For use with StateT
12:35:58 <flippeh_> Means I first create the data before actually knowing that handle
12:35:59 <copumpkin> hmm?
12:35:59 <copumpkin> Maybe Handle ?
12:36:44 <Baughn> flippeh_: "undefiend"?
12:36:51 <Baughn> Er. undefined. Though..
12:36:52 <flippeh_> Mhhh bad
12:36:59 <copumpkin> haskell's "null"
12:37:57 <flippeh_> > null []
12:37:59 <lambdabot>   True
12:38:00 <flippeh_> > null [1, 2]
12:38:01 <lambdabot>   False
12:38:09 <flippeh_> I'll go for maybe
12:38:14 <c_wraith> un-de-fiend?  Does that mean putting back the removed fiend?  ...  That sounds appropriate.
12:38:39 <Baughn> I'm antidisestablishfiend.
12:41:14 <dino-> I would probably lean towards using Maybe in this case. I hadn't really thought of using undefined this way though. Interesting.
12:42:26 <copumpkin> it seems like we mention null-able types in other languages as a minus, but all our (boxed) types are inhabited by undefined too, which could be used like null if you were feeling evil. Maybe is the better solution but it doesn't seem like undefined is too different from null otherwise
12:43:55 <dino-> I think it's a minus, like contamination with null. But that said, you can get yourself in trouble here if you fromJust on that bad boy before it's filled with a (Just validhandle)
12:43:58 <Baughn> The main difference with undefined is that you can't /check/ for it, which eliminates a major pattern
12:44:05 <copumpkin> true
12:44:10 <Baughn> I don't every single type to implicitly be Maybe
12:44:17 <Baughn> *don't want
12:44:52 <kkaji`>  If you have some time, please just click on this link -  http://www.lostworlds.lv/go.php?1139723800  Thanks ;)
12:45:11 <dino-> Didn't these guys' IP get blocked yesterday?
12:45:11 <copumpkin> except if you go impure, I guess
12:45:15 <copumpkin> we should have a page on haskellwiki on all the most unhaskellish things to do in haskell :P
12:45:29 <copumpkin> *sigh*
12:45:38 <Philippa> copumpkin: ending with "your mum"? :-)
12:45:46 <Baughn> copumpkin: Even in IO, there's no way to check for undefined
12:45:58 <copumpkin> Baughn: there isn't?
12:46:02 <Baughn> Well, except..
12:46:06 <Philippa> Baughn: I thought it had its own exception
12:46:12 <copumpkin> it does in 6.10 afaik
12:46:15 <Baughn> I suppose you could use evaluate and catch the exception, but that'd be evil. ;_;
12:46:21 <copumpkin> yeah, that's what I meant :P
12:51:39 <dino-> 'your mum' ha
12:53:05 <jkff> Hi. Is it true that Haskell uses self-modifying code for implementing laziness?
12:54:57 <copumpkin> nope
12:55:11 <copumpkin> well, some implementations might
12:55:15 <Draconxx> Haskell is a language, it doesn't implement anything.
12:55:23 <jkff> Well, GHC
12:55:28 <jkff> Then what happens after a thunk gets forced?
12:55:30 <copumpkin> but I'm pretty sure GHC doesn't
12:57:36 <jkff> I'd be much surprised if it turned out that there's a "if(!evaluated) value = evaluate()" in the generated code
12:59:56 <copumpkin> jkff: I think that's more or less how it works
13:00:29 <Saizan_> after evaluation the thunk gets updated so that it gives back its value
13:00:39 <jkff> The report from 1996 says:
13:00:39 <jkff> When the thunk's evaluation is complete the thunk itself is updated (i.e. overwritten) with the now-computed value. If it needs the value of v again, the heap object now contains its value instead of the suspended computation.
13:00:56 <copumpkin> yeah, but that doesn't imply self-modifying code
13:01:48 <jkff> Does that not imply replacing a call instruction with a ret instruction?
13:01:58 <jkff> Saizan, could you clarify please?
13:02:27 <Saizan_> jkff: i don't know the lowlevel details myself
13:03:05 <erikc> jkff: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
13:03:17 <jkff> Oh cool, thanks!
13:04:26 <copumpkin> http://darcs.haskell.org/ghc/includes/rts/storage/Closures.h
13:05:26 <mmorrow> jkff: the thunk's info pointer (which identifies that piece of memory as being a thunk) gets overwritten with the info ptr and indirection node would have, and the ptr in the thunk gets overwritten with a new pointer to the result
13:05:34 <vigalchin> I want to (carefully) install ghc 6.10 on my Ubuntu system ... is the preferred means to compile from scratch?
13:05:36 <erikc> at least, i thought that was where the info was, there is a page somewhere that shows how thunks are laid out in memory and managed
13:05:43 <mmorrow> jkff: so all then gets updated is two ptrs fields
13:06:48 <roconnor_> yesterday I learnt that species are analytic functors!
13:07:18 <dino-> vigalchin: I'm assuming that what's in apt isn't 6.10 yet, in Debian in the past I have used the generic *nix binary at the GHC site.
13:07:22 <copumpkin> jkff: the problem with modifying code is that modern operating systems make it a real pain to modify code. They often won't allow memory to be both writable and executable
13:07:25 <dino-> But compiling from scratch, no.
13:07:33 <copumpkin> so you need to make it writable, write to it, then make it executable, then jump into it
13:08:30 <dino-> vigalchin: http://haskell.org/ghc/download_ghc_6_10_4.html#x86linux
13:08:39 <jkff> mmorrow, copumpkin: Thanks, that all clarifies things. So, even an evaluated thunk is a jump or call.
13:08:57 <mmorrow> x86 and x86_64 don't even require an instruction cache flush
13:08:57 <mmorrow> you can literally overwrite the next instruction, and you'll see it
13:09:06 <copumpkin> hm?
13:09:19 * mmorrow just read yesterday that that's actually a guarantee given by x86(_64)
13:09:36 <jkff> mmorrow: I can overwrite the next instruction and see what?
13:09:50 <copumpkin> jkff: an evaluated thunk is a jump or call?
13:11:19 <erikc> mmorrow: so they flush when a write to an addressed in the cached window happens?
13:11:25 <erikc> s/addressed/address
13:11:35 <jkff> copumpkin: I don't know, I haven't read enough about STG :)
13:13:42 <mmorrow> copumpkin, erikc: amusingly this overwrites the next instruction with "movq $42, %rax" and exits with "42" instead of "99" http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3321
13:14:07 <copumpkin> fun
13:14:16 <copumpkin> but ghc actually modifies the thunk code?
13:14:26 <mmorrow> erikc: i'm not sure actually
13:14:29 <copumpkin> or just changes the closure so it points at the value?
13:14:39 <mmorrow> copumpkin: oh no, just two ptrs get updated
13:14:44 <mmorrow> (for thunks)
13:14:50 <copumpkin> yeah, that's what I thought, cool
13:15:30 <jkff> So, the problem is that to use self-modifying code one would have to spend time switching memory mode (executable/writable)?
13:15:59 <mmorrow> copumpkin: one being the info ptr of the closure, which serves to turn the thunk into an indirection (from the pov of code inspecting that closure (e.g. the GC, unpackClosure#, evaluation itself, etc.))
13:16:35 <mmorrow> so it relies on the struct layout for a THUNK and an IND to be overlappable
13:16:46 <jkff> (Oh no, I have to go and read the discussion tomorrow :( )
13:17:18 <mmorrow> (and an AP too)
13:19:28 <erikc> jkff: you need to change the exec/write bits on the virtual memory pages, and you also need to flush the icache (on some architectures) to make sure the instruction fetcher sees the new instructions
13:19:54 <Saizan_> mmorrow: so a THUNK becomes just an indirection it doesn't store the result? are those indirections removed by GC?
13:20:07 <erikc> some security-minded platforms dont give developers access to setting the exec bit on pages
13:20:51 <mmorrow> Saizan_: yes, they get removed as a side-effect of a copying gc
13:21:22 <mmorrow> Saizan_: so after the first GC an IND hits, it's gone
13:21:35 <Saizan_> i see
13:21:56 <mmorrow> Saizan_: have you ever run a ghc-produced binary with +RTS -B -RTS ?
13:22:07 <mmorrow> Saizan_: it's pretty amusing
13:22:11 <copumpkin> isn't that the painful one?
13:22:15 <doublethink_work> bell!
13:22:18 <mmorrow> heh
13:22:18 <doublethink_work> :)
13:26:02 <jkff> ...So, the GC modifies the code? Whoa. /me goes to sleep
13:26:13 <copumpkin> not really
13:29:54 <mmorrow> jkff: there's no executable code in the closures, it's all in the info tables that closures are associated with via the ptr that every closure has as its first field
13:32:20 <mmorrow> and the only way that anyone (GC,you,etc) knows what a closure is is by following the info ptr and looking at the tag field that every info table type has in common
13:32:23 <mmorrow> so by changing what the info ptr in a thunk points to (overwriting it to point to *the* info table that all indirections point to) effectively turns it into an indirection
13:33:52 <mmorrow> and because the layout of an indirection struct is such that you can overlay it over a thunk struct and not segfault because they're compatible by design, everything works
13:34:45 <mmorrow> (segfault by e.g. mistaking some random double for a ptr and dereferencing it or something)
13:41:12 <glguy> edwardk: You there?
13:43:00 <tommd> glguy: Does Lee sit near you?
13:43:14 <glguy> near enough :)
13:43:27 <tommd> Could you hit him over the head and tell him to give a Tech talk on Atom?
13:52:07 <DekuNut> Learning haskell, this is my first functional language but I think I'm getting the hang of it so far. Except for one thing
13:52:19 <DekuNut> I'm looking at paramterised types now, and I'm confused
13:52:49 <DekuNut> Oh wait, snapped. Just understood it, sorry
13:53:27 <jix_> hehe
13:53:30 <DekuNut> Ok wait, sorry rofl
13:53:37 <DekuNut> I understand it now but, I'm curious as to why the change works
13:54:46 <Petrosian> DekuNut: Paste what you don't understand? we might be able to explain it
13:54:58 <DekuNut> I'm look at this: data Maybe a = Just a | Nothing
13:54:58 <DekuNut> Which I understand, the a acts as a type holder, but in data isn't Maybe a data type that's constructed by a type constructor
13:54:58 <DekuNut> So if Maybe = TypeConstructor, then how does it know a already? Why does it treat it that way?
13:55:16 <DekuNut> Ok
13:56:00 <DekuNut> http://nopaste.com/p/acbHbkQThb
13:56:17 <dschoepe> DekuNut: Well, Maybe constructs a type for any given type a, so it doesn't really know anything in advance.
13:56:43 <DekuNut> No but a represents any type, so how can Just 12 by of type Maybe a if...
13:56:44 <DekuNut> Oh
13:56:48 <Petrosian> Hmm, not sure I follow you problem here. The `a' in `Maybe a' simply means that it can be of any type
13:56:55 * copumpkin keeps looking at http://www.mail-archive.com/haskell-cafe@haskell.org/msg37171.html and being impressed
13:56:59 <DekuNut> Oh right it's a seperate type, so Maybe 12 is of type Maybe Int right? Not of type 'Maybe' alone
13:57:12 <copumpkin> DekuNut: it'd be Just 12
13:57:13 <jix_> DekuNut: Just 12 ... but yeah
13:57:15 <dschoepe> DekuNut: that are two different things: Just and Nothing are data constructors, Maybe is a type constructor
13:57:19 <DekuNut> Just 12 even
13:57:21 <copumpkin> it's actually not Maybe Int
13:57:26 <copumpkin> it's (Num a) => Maybe a
13:57:37 <copumpkin> :t Just 12
13:57:39 <Petrosian> DekuNut: Just 'a' would be `Maybe Char'
13:57:39 <lambdabot> forall t. (Num t) => Maybe t
13:57:55 <athos> @type unsafeCoerce
13:57:57 <lambdabot> Not in scope: `unsafeCoerce'
13:58:01 <jix_> DekuNut: Just 12 isn't Maybe Int because 12 could be any numeric data type
13:58:04 <DekuNut> Ok, I'm pretty sure I get it now
13:58:17 <benmachine> @type Unsafe.Coerce.unsafeCoerce
13:58:25 <lambdabot> forall a b. a -> b
13:58:57 <DekuNut> Wait so, would would Nothing be
13:59:13 <Petrosian> @ty Nothing
13:59:14 <lambdabot> forall a. Maybe a
13:59:34 <Petrosian> @ty Nothing :: Maybe Int
13:59:35 <DekuNut> Then what's a there? I'm confused again D:
13:59:36 <lambdabot> Maybe Int
13:59:44 <Petrosian> `a' *could* be any type
13:59:49 <dschoepe> DekuNut: a can be anything, depending on the context
13:59:52 <benmachine> Nothing can be whatever Maybe you like
13:59:52 <DekuNut> But Nothing provides no type
13:59:54 <Petrosian> It's parametrically polymorphic in `a'
14:00:27 <DekuNut> Ok
14:00:56 <DekuNut> Going to hang around if that's alright, functional isn't as easy as I want it to be D:
14:00:58 <dschoepe> DekuNut: It's just like Just 12, but without the Num constraint.
14:02:19 <jix_> DekuNut: you might want to use the :t command of ghci if you don't know the type of something
14:02:54 <DekuNut> Yeah I just tried it :type Nothing
14:02:57 <DekuNut> Nothing :: Maybe a
14:03:07 <DekuNut> I'm still not 100% sure I understand what the a is there
14:03:21 <Petrosian> DekuNut: Anything you like
14:03:37 <dschoepe> DekuNut: it isn't one specific type, it's polymorphic, i.e. it can be any other type
14:03:54 <DekuNut> But it can never be made anything, There's no Nothing a, just Nothing.
14:04:10 <dschoepe> :t (Nothing :: Maybe Int)
14:04:12 <jix_> DekuNut: it can ... from the context
14:04:12 <lambdabot> Maybe Int
14:04:16 <Petrosian> The type checker will determine the `a' from its context
14:04:32 <Petrosian> Assuming its context contrains it to a monomorphic type
14:04:33 <DekuNut> But if you just do like, a = Nothing
14:04:38 <DekuNut> How will it know what context it is
14:04:48 <Petrosian> Its context is polymorphic
14:05:02 <dschoepe> > (+1) `fmap` Nothing
14:05:02 <Petrosian> Hence the type of your function would be polymorphic
14:05:04 <lambdabot>   Nothing
14:05:05 <dschoepe> :t (+1) `fmap` Nothing
14:05:07 <lambdabot> forall a. (Num a) => Maybe a
14:05:09 <jix_> DekuNut: example: fromMaybe 'a' Nothing
14:05:13 <DekuNut> So polymorphic IS a type of its own?
14:05:17 <Petrosian> @ty let x = Nothing in x
14:05:19 <lambdabot> forall a. Maybe a
14:05:33 <jix_> DekuNut: if you look at the type of fromMaybe
14:05:38 <jix_> @ty Data.Maybe.fromMaybe
14:05:39 <lambdabot> forall a. a -> Maybe a -> a
14:05:44 <dschoepe> DekuNut: no, it's an attribute, polymorphic, literally translated means something like "many forms"
14:06:29 <jix_> DekuNut: all a's in there have to be the same type
14:06:31 <dschoepe> DekuNut: Imagine the whole thing like templates from C++ or generics from Java
14:06:44 <dschoepe> just a lot less noisy and more flexible
14:06:50 <Petrosian> Yes. Imagine something along the lines of `List<A>'
14:06:53 <jix_> DekuNut: so because we know the first a is a Char (from the Char literal)
14:06:54 <copumpkin> I think haskell should jump on the newfangled NoSQL database bandwagon and come up with a <insert dumb/offensive name here>DB
14:07:03 <DekuNut> Alright, give me a second to try and apply this with C++ templates
14:07:25 <flippeh_> Any examples for multithreaded TCP servers?
14:07:25 <DekuNut> C++ templates apply the type given to it throughout, so template <typename T> would replace all T's with whatever you put right
14:07:36 <flippeh_> I don't want it to freeze while waiting for a client
14:07:46 <jix_> c++ isn't a good example to show type inference i'd say
14:07:54 <DekuNut> So, Maybe a = Just a | Nothing would be Just 12 where a is replaced, but that's where I'm lost
14:07:59 <DekuNut> If you use Nothing, a isn't replaced with anything
14:08:05 <DekuNut> It's just there
14:08:13 <jix_> DekuNut: no but if you use Nothing in a context that requires Maybe Char
14:08:14 <DekuNut> How can that be valid?
14:08:16 <Petrosian> DekuNut: I wouldn't try and make a literal translation, rather think of what a template in C++ represents
14:08:22 <jix_> DekuNut: haskell deduces that the Nothing must be a Maybe Char
14:08:45 <Petrosian> DekuNut: You could make a template class over some type A, but never use A in the class
14:08:55 <Makoryu> DekuNut: How can a pointer to an arbitrary type have the value NULL in C and C++?
14:08:58 <dino-> :t [ Nothing, Nothing, Just 42, Nothing ]
14:08:59 <lambdabot> forall a. (Num a) => [Maybe a]
14:09:15 <Petrosian> DekuNut: In the same fashion, Nothing is of `Maybe a', but it just never makes use of any values of `a'
14:09:26 <copumpkin> mmorrow: around?
14:09:41 <mauke> struct Nullish { template<typename T> operator T *() const { return 0; } };
14:09:45 <mauke> Nullish null;
14:09:53 <jmcarthur_work> :t Nothing :: Maybe Int
14:09:55 <lambdabot> Maybe Int
14:09:55 <jmcarthur_work> :t Nothing :: Maybe String
14:09:56 <mauke> int *pi = null; double *pd = null;
14:09:57 <jix_> if i get him right, type inference is the thing he doesn't understand
14:09:57 <lambdabot> Maybe String
14:10:01 <copumpkin> @tell mmorrow they just released a demo version of IDA 5.5, thought you might be interested: http://www.hex-rays.com/idapro/idadowndemo.htm
14:10:02 <lambdabot> Consider it noted.
14:10:05 <jmcarthur_work> :t Nothing
14:10:07 <lambdabot> forall a. Maybe a
14:10:26 <DekuNut> Let me try and think this through
14:10:36 <DekuNut> Without trying to keep up with so many messages D:
14:10:42 <DekuNut> Sorry
14:11:30 <DekuNut> Ok
14:11:37 <jix_> i think the c++ comparision doesn't work because there you have to specify the type inside < and > (IIRC)
14:11:44 <jix_> even if it isn't used
14:12:21 <DekuNut> You don't have to, the compiler can figure it out generally but, ok.
14:12:23 <DekuNut> <Petrosian> DekuNut: In the same fashion, Nothing is of `Maybe a', but it just never makes use of any values of `a'
14:12:40 <DekuNut> That's where I'm confused
14:12:42 <DekuNut> <jix_> DekuNut: no but if you use Nothing in a context that requires Maybe Char
14:13:00 <DekuNut> That makes sense, because a is set, even if it's not really used
14:13:03 <Petrosian> DekuNut: Think of `Nothing' and `Just' as functions
14:13:07 <DekuNut> What I don't get is how something can exist NOT using a
14:13:15 <_-jn> whats a good approach if I want to search a Gtk treestore to see if it holds a certain value? i.e. some nice deph-first traversal? I can't seem to get it right...
14:13:21 <mauke> DekuNut: it just does
14:13:29 <benmachine> DekuNut: a complete program will probably end up using it
14:13:35 <glguy> DekuNut: do empty lists make sense?
14:13:39 <Makoryu> DekuNut: Consider the empty list
14:13:43 <jix_> DekuNut: if it doesn't uses a... it's no problem that it doesn't know the type
14:13:49 <dschoepe> DekuNut: since it does not use a, why should it place any constraints on what a is?
14:13:57 <DekuNut> Then what does a become?
14:13:58 <jix_> DekuNut: because it will never need to know anything about a value of a because there is no value of a
14:14:05 <dino-> Petrosian: Actually they really are functions. Constructors.
14:14:08 <benmachine> DekuNut: welcome to #haskell, where every question has six answers ;)
14:14:08 <mauke> a stays a
14:14:08 <dino-> :t Just
14:14:10 <lambdabot> forall a. a -> Maybe a
14:14:15 <glguy> > (sum :: [Int] -> Int) ([] :: [Int])
14:14:16 <Petrosian> dino-: I'm aware of that, thanks.
14:14:17 <lambdabot>   0
14:14:37 <mauke> constructors aren't functions
14:14:37 <glguy> > (sum :: [Int] -> Int) []
14:14:38 <lambdabot>   0
14:14:39 <DekuNut> Yes, that's what I'm confused about. How can [] be used, if [] counts as a valid type
14:14:45 <DekuNut> What is a, it's nothing
14:14:48 <copumpkin> [] is more confusing
14:14:53 <DekuNut> 1:[] makes sense because a becomes Int
14:14:54 <copumpkin> because the syntax is used both for the type and the value
14:15:01 <copumpkin> but it's the same idea
14:15:06 <jix_> DekuNut: in c++ you can have pointers to undefined classes as long as you don't use them right?
14:15:13 <benmachine> [] isn't a type is it?
14:15:19 <jix_> benmachine: [a] is a type
14:15:20 <copumpkin> :k []
14:15:21 <DekuNut> Yes jix_
14:15:22 <lambdabot> * -> *
14:15:22 <benmachine> yeah
14:15:26 <glguy> [] is a type constructor
14:15:30 <DekuNut> It's a pointer to something that may exist
14:15:39 <jix_> DekuNut: yeah but if you don't use it at all
14:15:42 <copumpkin> [a] is just sugar for [] a
14:15:44 <jix_> DekuNut: you never have to define the class
14:15:48 <glguy> DekuNut: Haskell has defaulting
14:16:13 <jix_> DekuNut: so if you never use a value of a type... you don't have to know the type
14:16:19 <glguy> on its own,   1 doesn't have a type
14:16:24 <glguy> it is any Num instance
14:16:27 <mauke> meh, all this talk about inference and defaulting and whatever is irrelevant
14:16:37 <mauke> haskell has polymorphic values. the end.
14:16:57 <DekuNut> It just does?
14:17:07 <copumpkin> :t 1
14:17:09 <lambdabot> forall t. (Num t) => t
14:17:15 <jix_> :t undefined
14:17:16 <lambdabot> forall a. a
14:17:17 <benmachine> well that isn't a problem is it
14:17:25 <copumpkin> 1 could be an Int, an Integer, a Double, etc.
14:17:29 <c_wraith> :t t::Integer
14:17:31 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Expr'
14:17:31 <lambdabot>     In the expression: t :: Integer
14:17:35 <c_wraith> :t 1::Integer
14:17:37 <lambdabot> Integer
14:17:40 <c_wraith> stupid typo
14:17:46 <DekuNut> Yeah, a could be anything, but what is a then in x = Nothing
14:17:50 <DekuNut> I don't understand how it can just be a
14:17:52 <DekuNut> It just doesn't make sense
14:17:56 <benmachine> why doesn't it make sense?
14:17:57 <noteventime> Any particular situations where 't' is for type variables as opposed to, for example, 'a'?
14:18:03 <Makoryu> :t (0 :: Float, 0 :: Int, 0 :: Integer, 0 :: Ratio)
14:18:04 <lambdabot>     `Ratio' is not applied to enough type arguments
14:18:04 <lambdabot>     Expected kind `?', but `Ratio' has kind `* -> *'
14:18:04 <lambdabot>     In an expression type signature:
14:18:07 <Makoryu> Whoops
14:18:10 <Makoryu> :t (0 :: Float, 0 :: Int, 0 :: Integer, 0 :: Rational)
14:18:11 <lambdabot> (Float, Int, Integer, Rational)
14:18:15 <c_wraith> DekuNut:  It's no different than what a is in []
14:18:23 <DekuNut> I don't understand what a is in [] either
14:18:26 <DekuNut> If it's nothing
14:18:28 <benmachine> noteventime: I think that where possible, ghci uses the type variable that was originally used in the definition, but they are all the same
14:18:30 <DekuNut> How can it be valid
14:18:32 <mauke> DekuNut: it's not nothing, it's a type variable
14:18:44 <glguy> > let a = Nothing in (fromMaybe 'a' a, fromMaybe 1 a)
14:18:47 <mauke> DekuNut: how could it be invalid?
14:18:47 <benmachine> (using the one originally used in the definition might give clues about what it is for, for example)
14:18:49 <jix_> DekuNut: it could be anything... but it doesn't matter what it is
14:18:49 <lambdabot>   ('a',1)
14:18:51 <dino-> mauke: Are constructors really not functions? How do they differ?
14:18:59 <Makoryu> DekuNut: The type information is there, even though it's not visible in the syntax for the literal.
14:19:06 <mauke> dino-: not all constructors take arguments
14:19:07 <dschoepe> DekuNut: That's what polymorphism means: It can be multiple things.
14:19:10 <c_wraith> The type variable happens to be unused in the data contained by the expression, but that doesn't mean it's not present.
14:19:13 <noteventime> benmachine: So there's nothing idiomatic about using t for types with certain constraints or anything like that?
14:19:24 <dino-> mm, like our friend Nothing here. ok
14:19:32 <benmachine> noteventime: I don't know about idiomatic; I imagine it's all the same to the compiler
14:19:39 <noteventime> I know that :)
14:19:44 <DekuNut> Ok, let me read for a while I'm sure it'll come to me
14:19:45 <benmachine> oh
14:19:52 <benmachine> well then I don't know anything that you don't
14:20:09 <mauke> :t []
14:20:10 <noteventime> I doubt that's the case ;)
14:20:11 <lambdabot> forall a. [a]
14:20:12 <mauke> :t length
14:20:14 <lambdabot> forall a. [a] -> Int
14:20:16 <mauke> > length []
14:20:18 <lambdabot>   0
14:20:24 <mauke> GOD IS GOD
14:20:25 <benmachine> @quote benmachine
14:20:26 <lambdabot> benmachine says: wait why am I giving advice I don't know anything
14:20:30 <benmachine> <_<
14:20:42 * benmachine forgets that sometimes
14:21:02 <Makoryu> > 0 : ""
14:21:04 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:21:04 <lambdabot>    arising from the literal `0...
14:23:54 <copumpkin> WAVYBANANAMAN: having fun?
14:23:57 <flippeh_> I have a TCP server that accepts incoming connections, and I want to keep a list of current open connections. Do I have to use StateT or is there another good way?
14:24:00 <jix_> is there some elegant way (monad) to keep track of multiple named state variables?
14:24:26 <EvalSplappy> copumpkin: indeed. beonmoarfunchannelskthx :P
14:24:30 <copumpkin> jix_: you could pass a record along in your state
14:24:50 <jix_> copumpkin: but then doing partial updates isn't very nice and elegant imho
14:24:55 <sm> I don't know if it's elegant, but if you're in IO there's io-storage
14:25:03 <jix_> sm: i'm not in IO
14:25:17 <noteventime> jix_: I take it it's not ST you're interested in?
14:25:23 <jix_> noteventime: right
14:25:38 <jix_> i'd like to have the state itself in the type of the monad
14:25:50 <jix_> like the State monad
14:25:53 <noteventime> Ok
14:26:02 <jix_> i'd also use a State monad if there would be a nicer way to do partial updates
14:26:06 <c_wraith> What's wrong with State with a record type?  Updates are pretty easy.  \s -> s { foo = "bar" }
14:27:14 <jix_> c_wraith: well i coded some opengl stuff before and using $= seemed to be so much nicer
14:27:20 <Petrosian> Also, gets is handy with record state
14:27:33 <jix_> so i was searching for an alternative to that syntax
14:28:46 <jix_> if { foo = "bar" } alone would be a function it would be nicer because i wouldn't have to use an extra lambda
14:30:20 <dschoepe> jix_: well you could provide functions for the most updated values: modifyFoo f x = x { foo = f (foo x) }
14:30:38 <jix_> dschoepe: yeah... but i'd have to do that a lot then
14:30:53 <jix_> but it seems there are no other solutions
14:31:01 <jeffwheeler> > replicate 100 "abc"
14:31:02 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","a...
14:31:04 <jix_> (at least i myself have found none)
14:31:28 <jeffwheeler> > concat $ replicate 100 "abc"
14:31:30 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
14:31:46 <dschoepe> jix_: you could use a lot of tuples and use conal's idea of "semantic editor combinators", but that would be a bad design imo
14:31:48 <noteventime> jix_: What about something like "($=) setter x = modify (\s -> setter s x)"
14:31:50 <glguy> > replicateM 10 "ab"
14:31:51 <lambdabot>   ["aaaaaaaaaa","aaaaaaaaab","aaaaaaaaba","aaaaaaaabb","aaaaaaabaa","aaaaaaab...
14:32:08 <jeffwheeler> > replicateM 2 "ab"
14:32:10 <lambdabot>   ["aa","ab","ba","bb"]
14:32:17 <jix_> noteventime: i still have to define an extra setter for each field then
14:32:18 <noteventime> You'd still have to define a function for setting each value in the data
14:32:25 <noteventime> Yea
14:32:40 <c_wraith> jix_:  How about using a Map String String as your state?
14:33:01 <c_wraith> It'd be less safe and less efficient...  But easier!
14:33:12 <noteventime> jix_: But that could be done with template haskell
14:33:14 <glguy> In general you don't want to use the raw State monad with the get and set operations
14:33:18 <glguy> you use those to build up your own monad
14:33:25 <glguy> which the specific combinators you need
14:33:48 <jix_> glguy: hmm yeah..
14:33:57 <c_wraith> I suppose that only works if your values are homogeneous
14:34:11 <jix_> i probably overestimated the times i have to write \s -> s{ field = value }
14:34:31 <jix_> c_wraith: i have a few different state types for different things
14:34:39 <jix_> c_wraith: but all in all yeah
14:34:55 <dschoepe> c_wraith: or using Map String Dynamic that would include other nuisances much worse than some extra lambdas
14:35:06 <jix_> oh wait
14:35:32 <c_wraith> In other words, Map String x is probably a bad idea. :)
14:35:37 <jix_> hehe got something wrong here... so c_wraith no they aren't homogeneous
14:36:07 <jix_> i experimented a bit with some type hackery using types as names and type families to associate value types
14:36:16 <jix_> but the results didn't really satisfy me
14:38:10 <dschoepe> jix_: hmm actually you could use something like Yi uses in Yi.Dynamic that figures out which value to update by it's type representation. So you'd have Map String Dynamic, where the string is show $ typeOf x
14:38:40 <dschoepe> but you'd need a lot of new data type declarations instead of field names.
14:38:45 <augustss> oops, my macbook just fell about 1m onto a stone floor
14:38:45 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
14:39:03 <jix_> dschoepe: yeah that's probably similar to what i did
14:39:10 <jix_> dschoepe: except that i didn't use a Map of Strings
14:39:24 <jix_> dschoepe: but built a linked list out of pair like type
14:39:26 <augustss> a good thing the body is tooled from a single piece of aluminium
14:40:06 <jix_> dschoepe: basically i had type family NValue a; and NVar name chain = NVar (NValue name) chain
14:40:07 <HugoDaniel> how do i convert from Int to Data.Int.Int32 ?
14:40:20 <kkaji`>  Just click on this link ;) - http://www.lostworlds.lv/go.php?1139723800
14:40:21 <jix_> dschoepe: and used some classes to do the lookup into the chain type
14:40:26 <dschoepe> HugoDaniel: fromIntegral
14:40:32 <HugoDaniel> thanks dschoepe
14:40:37 <c_wraith> > (fromIntegral (5::Int))::Int32
14:40:39 <lambdabot>   5
14:40:41 <jix_> but that needs like 80% of the haskell extensions
14:41:15 <jix_> and i have no idea how the performance would be
14:41:40 <shapr> @yow !
14:41:40 <lambdabot> Go on, EMOTE!  I was RAISED on thought balloons!!
14:41:45 <jix_> but now when i think about it... i might finish it and just try it...
14:41:55 <c_wraith> yow quotes zippy? >_>
14:43:00 <naoto`> test
14:43:11 <shapr> naoto`: hi!
14:43:15 <shapr> konichiwa!
14:44:21 <c_wraith> こんにちは？
14:44:33 <c_wraith> Hey, look, I spelled it right for once.
14:44:43 <c_wraith> Silly triple-n requirement
14:48:42 <olsner> kinda like pressing ^ twice to get ^
14:49:31 <Twey> Bit more regular
14:49:42 <Twey> Seeing as all the other kana are two strokes each
14:49:58 <Twey> (except combined kana)
14:50:09 <bcw> the Wikibooks page http://en.wikibooks.org/wiki/Haskell/Understanding_monads has been edited by an anonymous (IP address-only) user, just while i was studying it.  could someone take a look at it now and see if it describes monads reasonably (for a beginner)?
14:51:22 <Twey> I think it's reasonable, but probably not as clear as it could be
14:51:29 <Twey> I'll probably always recommend http://haskell.org/haskellwiki/Monads_as_computation
14:51:52 <bcw> Twey, ok. i'll read that too, thanks.
14:55:11 <medfly> what is it with Japanese and this channel?
14:55:31 <Makoryu> medfly: ¯\O_o/¯ i dunno lol
14:55:36 <c_wraith> people speak japanese sometimes?
14:55:42 <medfly> they do!
14:56:21 <c_wraith> 日本語をすはなす。すこし。
14:57:45 <c_wraith> twey, it's just that if you're typing ん before any kana that doesn't begin with n, then you don't need to double-enter it.
14:57:54 <Twey> Aye.
14:58:03 <davidL> where might I be able to find a clique finding algorithm implemented in haskell?
14:58:03 <Twey> I just get into the habit of always typing it twice
14:58:04 <c_wraith> So I get used to doing it that way
14:58:07 <Twey> It's easier
14:58:14 <c_wraith> That does make more sense, probably
14:58:48 <Twey> Or following it with an apostrophe, if you prefer not to double-tap keys
14:59:07 <Twey> I keep meaning to learn a kana layout, but I've not gotten around to it yet.
14:59:42 <c_wraith> also, did I spell "a little" anywhere near correctly? >__>
15:00:04 <Twey> Yep
15:00:07 <Twey> 少し
15:00:18 <Twey> But what is すはなす?
15:00:28 <c_wraith> haha.  a typo. :)
15:00:34 <Twey> Oh, right.  :)
15:00:42 <c_wraith> ignore the "su"
15:00:48 <skorpan> ,t8 jp en すはなす
15:00:49 <lunabot>  luna: Not in scope: `t8'
15:00:58 <skorpan> oops, wrong channel again
15:01:00 <Twey> The kanzi for はなす is 話す
15:01:09 <skorpan> hm, that's not japanese?
15:01:18 <copumpkin> what isn't?
15:01:19 <c_wraith> everything so far is japanese
15:01:20 <Megant> it is?
15:01:37 <Twey> skorpan: It is, it's just typo'd Japanese.  :)
15:01:54 <c_wraith> I typed something.  Then forgot to hit backspace. :)
15:02:05 <c_wraith> Made gibberish result.
15:02:55 <c_wraith> And even though I could have guessed that that would be the kanji for "speak", given the similarity to "language", I don't like to guess when I might guess it wrong. :)
15:03:15 <Twey> Ah, but now you know. ☻
15:04:30 <c_wraith> what's the stroke order on 少?
15:04:43 <Twey> Centre, left, right, bottom
15:04:52 <c_wraith> Ok, I would have guessed that right.
15:05:38 <Twey> Stroke orders are usually as you'd expect :)
15:05:55 <c_wraith> Eh.  It's been a long time.  I don't remember all the rules for stroke order, anymore.
15:06:26 <HugoDaniel> the glut displaycallback function gets an IO (), is there any way to pass it a function that works in my own monad ?
15:07:08 <HugoDaniel> my own monad is M (StateT s IO)
15:09:45 <HugoDaniel> :/
15:12:12 <HugoDaniel> isn't () a monad ?
15:12:36 <skorpan> i'd be surprised if it could fulfill the monad laws
15:12:48 <HugoDaniel> i dont see why not :)
15:13:04 <noteventime> HugoDaniel: I don't think you can per-se, but you could pass it an IO-ref to update which you could use later to change your state
15:13:24 <noteventime> :k ()
15:13:26 <lambdabot> *
15:13:35 <noteventime> HugoDaniel: Wrong kind
15:13:46 <noteventime> Unless I'm being dumb
15:14:06 <HugoDaniel> noteventime: IO-ref ?
15:14:31 <Makoryu> HugoDaniel: "Kind" here refers to the arity of a type.
15:14:31 <noteventime> HugoDaniel: Basically mutable variables for the IO monad
15:14:35 <Makoryu> :k []
15:14:37 <lambdabot> * -> *
15:14:56 <Makoryu> :k (,)
15:14:57 <lambdabot> * -> * -> *
15:15:04 <Makoryu> :k IO
15:15:05 <HugoDaniel> ill have to read on that
15:15:05 <lambdabot> * -> *
15:15:37 <HugoDaniel> how come a mutable reference will help me ?
15:15:50 <HugoDaniel> can i leave out of the IO monad to an "upper" monad that wraps it ?
15:16:05 <noteventime> HugoDaniel: I
15:16:08 <HugoDaniel> im getting quite some trouble trying to mentally visualize it :/
15:16:16 <noteventime> 'm not sure why you need the callback to be in another monad
15:16:24 <noteventime> I'm having trouble seeing how that would make sense
15:16:29 <HugoDaniel> hmm
15:16:36 <noteventime> But if all you need is for the callback to be able to change some state
15:16:54 <noteventime> You may get away with passing it an IORef
15:16:57 <noteventime> Which it can update
15:16:59 <HugoDaniel> well, ill have my own M monad, that will send update/render messages to all the objects on the scene
15:17:27 <HugoDaniel> i want these to remain pure
15:17:33 <HugoDaniel> hence the messages
15:23:12 <HugoDaniel> oh well
15:23:14 <HugoDaniel> cheesy
15:25:11 <noteventime> HugoDaniel: What you'd like would be the callback to be "MonadIO m => m ()"?
15:25:15 <hackagebot> cabal2arch 0.6 - Create Arch Linux packages from Cabal packages (DonaldStewart)
15:25:32 <noteventime> Actually
15:25:49 <HugoDaniel> noteventime: yes :)
15:25:54 <noteventime> HugoDaniel: Your Monad "contains" the IO monad, doesn't it?
15:25:58 <HugoDaniel> yes
15:26:00 <HugoDaniel> its the inner one
15:26:08 <HugoDaniel> so i guess that type would work fine
15:26:22 <noteventime> Well
15:26:36 <noteventime> Can't you just do something like liftIO for your monadic function?
15:27:07 <HugoDaniel> i wouldn't want to :/
15:27:16 <noteventime> How come?
15:27:32 <HugoDaniel> that would be breaking the render abstraction
15:27:40 <HugoDaniel> opengl stuff are only done through messages
15:28:47 <HugoDaniel> i cant think very well
15:29:03 <noteventime> HugoDaniel: There is a MonadIO instance for (MonadIO M) => StateT s m
15:29:09 <noteventime> And obviously a MonadIO IO
15:29:31 <noteventime> I don't see how that'd change your code?
15:29:35 <pastah> I want to get information out from a HTML file
15:29:51 <pastah> what library should i use?
15:30:04 <noteventime> HugoDaniel: All it'd do would make it possible for GLUT to callback to your code, wouldn't it?
15:30:34 <HugoDaniel> i want glut to do callbacks inside my monad
15:30:41 <HugoDaniel> display callbacks and update callbacks
15:31:19 <HugoDaniel> ill try to write a wrapper on top of it tomorrow, but its too much work for a simple task :/
15:32:03 <jix_> pastah: there seem to be multiple libraries for that on hackage ... tagsoup and tagchup
15:32:58 <noteventime> What's the RWS monad, something with stochastics? O_o
15:32:59 <skorpan> pastah: python
15:33:32 <jix_> noteventime: reader writer state afaik
15:33:35 <jix_> combined
15:33:47 <noteventime> Ohh
15:34:41 <HugoDaniel> noteventime: where would i put the liftIO ?
15:34:45 <poe> pastah: http://www.haskell.org/haskellwiki/HXT
15:34:49 <HugoDaniel> inside the callback ?
15:35:07 <glguy> liftIO makes IO a's into YourMonad a's
15:35:11 <HugoDaniel> yes
15:35:17 <glguy> it won't make your monad fit into an IO a parameter
15:35:21 <HugoDaniel> so its useless for a callback in IO() :/
15:35:28 <jix_> poe: does it cope with malformed documents?
15:35:38 <pastah> poe: is that the one called libghc6-xml-dev?
15:35:50 <noteventime> HugoDaniel: Ohh, my bad, I missread the type signature
15:36:22 <HugoDaniel> np
15:36:41 <davidL> no one knows a clique finding algorithm implementation in haskell?
15:36:55 <noteventime> HugoDaniel: I figured it did seem a little too magical :)
15:37:13 <HugoDaniel> i can't see how to solve this without wrapping glut, which doesnt make much sense :/
15:37:21 <pastah> poe, jix_, skorpan: yay! the tagsoup package is included in ubuntus package system :D
15:40:57 <poe> jix_: Text.XML.HXT.Parser.HtmlParsec "tries to interprete everything as HTML no errors are emitted during parsing. If something looks weird, warning messages are inserted in the document tree."
15:41:39 <jix_> ah
15:42:43 <HugoDaniel> bed time, thanks for the help guys ;)
15:43:32 <edwardk> HugoDaniel: there is some magic for getting parameters (and whole monadic wrappers) back in callbacks
15:43:36 <edwardk> oh, he's gone
15:45:33 <mmmulani> is there a decent matrix library for haskell?
15:49:15 <burp> mmmulani: http://hackage.haskell.org/package/hmatrix-0.5.2.2
15:49:56 <vav> davidL: iirc graphalyze package on hackage has clique, but hackage seems to be down atm, can't check my horrible memory
15:50:05 <burp> at least for numerical stuff
15:50:14 <pastah> where are the docs placed on ubuntu?
15:51:10 <mmmulani> hmmm, that's what I was planning on using
15:51:20 <mmmulani> I couldn't find a way to replace an element without working on a vector though
15:51:25 <davidL> vav: cool. thank you
15:51:44 <mmmulani> also, hackage appears down right now :S
15:51:58 <burp> yes, its slow
15:52:04 <burp> writeMatrix / modifyMatrix?
15:52:09 <othercriteria> Saw this on reddit the other day: http://www.reddit.com/r/haskell/comments/9907w/literate_haskell_matrix_zippers_feedback/
15:52:12 <burp> seems to do the right thing
15:52:18 <burp> writeMatrix :: Storable t => STMatrix s t -> Int -> Int -> t -> ST s ()
15:52:23 <burp> modifyMatrix :: Storable t => STMatrix s t -> Int -> Int -> (t -> t) -> ST s ()
15:52:48 <mmmulani> oh, didn't see those
15:53:00 <burp> http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.2/doc/html/Data-Packed-ST.html
15:53:10 <mmmulani> hmmm, is there a pure version?
15:53:26 <mmmulani> oh sweet, hackage is fast again
15:58:53 <noteventime> Hunner: btw, why not use something more usable than GLUT?
15:59:31 <pastah> openURL :: String -> IO String
15:59:32 <leithaus> does anyone know of work on coherence conditions for structures supporting both monadic and comonadic views?
15:59:37 <pastah> FUCK YEAH!
16:01:02 * glguy bats pastah on the nose with a newspaper
16:01:34 <Hunner> noteventime: bad tab complete?
16:02:14 <noteventime> Hunner: Ohh, yes, sorry
16:02:31 <pastah> glguy: sorry, but i found my perfect function, that is cause for exaltation, is it not?
16:02:53 <noteventime> Hunner: Seems the person I wanted to tab to left and I had join/part messages turned off
16:03:40 <glguy> The development version of weechat has a neat feature where you can filter only the join/part messages of people that ahve been idle for some time
16:03:54 <glguy> and then you can toggle their visibility with Alt-=
16:04:16 <noteventime> Neat :)
16:05:04 <dschoepe> a nice feature would be to have the user provide "fallbacks" when addressing people who just left(e.g. using lambdabot's @tell)
16:06:20 <noteventime> >_> Or I just learn to be a little perceptive and keep an eye on what I'm writing
16:07:22 <dschoepe> noteventime: you shouldn't try to find social solutions for technical problems.. err wait, that was the other way around =)
16:08:42 * benmachine wonders if he should give weechat a try as a replacement for irssi
16:19:24 <noteventime> dschoepe: Social solutions sounds somewhat oxymoron-ic somehow
16:19:52 * noteventime turns join/part messages back off
16:27:13 <drwho> has there been any disassemblers written in haskell?
16:27:47 <copumpkin> drwho: harpy
16:27:49 <copumpkin> @hackage harpy
16:27:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy
16:27:56 <drwho> thanks
16:27:57 <copumpkin> it has a disassembler, but I wasn't a big fan of it
16:28:08 <drwho> I am thinking of making one in this language
16:28:54 <copumpkin> for what architecture?
16:32:12 <drwho> x86-64
16:32:44 <copumpkin> you could expand harpy to support it
16:33:07 <drwho> I'll take a look at it
16:50:50 <pastah> anyone here experienced with tagsoup?
16:51:51 <pastah> i want to drop my html header
16:51:57 <pastah> or not header
16:53:22 <pastah> well, everything before the HTML begins
16:57:18 <mmmulani> how do you use :trace on main?
17:23:09 <laynor_> hi, I'm having some problems with haskell indentation in emacs: http://paste.lisp.org/display/85355 Any idea how to solve this issue?
17:24:09 <Saizan_> @where kuribas
17:24:09 <lambdabot> I know nothing about kuribas.
17:24:16 <ManateeLazyCat> laynor_: indent then or else after `if`
17:24:16 <Saizan_> @where kuribas-indentation
17:24:16 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
17:24:38 <Saizan_> laynor_: use that to replace the one in haskell-mode ^^
17:30:38 <RayNbow> http://translationparty.com/#1363670 <-- Japanese version of Haskell's unofficial slogan? :X
17:31:15 <Acteum> what is haskell's unofficial slogan?
17:31:47 <RayNbow> Avoid success at all costs
17:32:40 <Acteum> i don't get it
17:33:32 <RayNbow> it's what Simon Peyton Jones once mentioned during a talk
17:34:21 <ManateeLazyCat> Saizan_: I can't understand "Check in instance of PageBuffer" you told me yesterday.
17:34:34 <ManateeLazyCat> Saizan_: Some speical functions just works with speical instance of PageBuffer and not all PageBuffer when i remove those speical functions from calss PageBuffer.
17:34:45 <benmachine> :k (->) t
17:34:47 <lambdabot> Not in scope: type variable `t'
17:34:50 <benmachine> erm
17:34:53 <benmachine> :k (->)
17:34:54 <lambdabot> ?? -> ? -> *
17:35:03 <benmachine> ^ can anyone explain to me what these ??s are about
17:35:39 <Saizan_> ManateeLazyCat: in the instances where those operations are not supported you implement the method such that it retuns some value that indicates that
17:35:56 <Saizan_> ManateeLazyCat: so the caller just needs to check the value to see if something happened
17:36:28 <Petrosian> benmachine: The kind of either `?' might be either `*' or `? -> ?'
17:36:39 <ManateeLazyCat> Saizan_: When i got those special instance in Page (such as StringBuffer), it's type is (PageBuffer a) and not StringBuffer, so it will failed when i apply StringBuffer methods to (PageBuffer a) when i compile it.
17:37:06 <Petrosian> benmachine: Presummably, they're the kind equivalent of type variables
17:37:22 <Saizan_> ManateeLazyCat: but inside the instance declaration for StringBuffer you know you've a StringBuffer
17:37:30 <ManateeLazyCat> Saizan_: Yep.
17:37:33 <Saizan_> Petrosian: no
17:37:55 <Saizan_> Petrosian: ?? and ? are GHC-specific, and are there to come with unboxed types
17:38:03 <Petrosian> Oh.
17:38:04 <Saizan_> Petrosian: GHC has kind subtyping
17:38:08 <Petrosian> I was miles off there then.
17:38:55 <fbru02> Saizan : what is ??  type
17:38:56 <fbru02> ?
17:39:10 <ManateeLazyCat> Saizan_: "pageApplyBuffer f (Page {pageBuffer = x}) = f x" if i want apply some function to PageBuffer instance in Page, i just can apply through function `pageApplyBuffer`, but it just accept (PageBuffer a) event i know instance is StringBuffer
17:39:33 <ManateeLazyCat> Saizan_: Or other idea?
17:40:10 <benmachine> Petrosian: well, thanks for listening anyway :P
17:40:34 <Petrosian> benmachine: Ye, I must've been thinking of something else. Got my wires crossed.
17:41:02 <Saizan> ?? is the superkind of # and *, ? also contains unboxed tuples, iirc
17:41:03 <lambdabot> Plugin `compose' failed with: Unknown command: ""
17:41:40 <ManateeLazyCat> Saizan_: The key is how to i check a PageBuffer instance is not StringBuffer? Catch exception?
17:41:57 <benmachine> Saizan: thanks
17:42:07 <Saizan> ManateeLazyCat: why do you have to check that?
17:42:38 <ManateeLazyCat> Saizan: If that PageBuffer instance is not StringBuffer, then don't apply methods just for StringBuffer.
17:43:13 <ManateeLazyCat> Saizan: Or i misunderstand your solution?
17:43:18 <Saizan> ManateeLazyCat: my idea was "apply the methods anyway, the methods will know if they should do something or not"
17:44:07 <Saizan> and they can also report if they effectively did something or not, if you need to know that
17:48:08 <ManateeLazyCat> Saizan: "the methods will know if they should do something or not", that's i don't understand, how?
17:49:23 <ManateeLazyCat> Saizan: Methods is for speical PageBuffer instance, the thereunder of "they should do something or not" is check instance is whether StringBuffer, right?
17:49:52 <ManateeLazyCat> Or other thereunder that i don't know?
17:50:31 * ManateeLazyCat pasted "StringBuffer methods" at http://paste2.org/get/377981
17:50:32 <ManateeLazyCat> Saizan: Example above is speical method for StringBuffer.
17:51:29 <Saizan> ManateeLazyCat: are those also part of the class or not?
17:51:43 <ManateeLazyCat> Saizan: No
17:51:47 <Saizan> ManateeLazyCat: when i say "method" i mean something that's part of the class
17:52:27 <Saizan> ah, your problem looked totally different yesterday :)
17:52:28 <ManateeLazyCat> Saizan: They're part of class ever, now i pick those speical methods out of class.
17:52:49 <ManateeLazyCat> Saizan: It's my fault, we misunderstand each other. :)
17:53:13 <ManateeLazyCat> Saizan: This problem block me all day.
17:54:26 <ManateeLazyCat> Saizan: Now i understand what your mean, you mean right all functions interface in class, and don't care common or speical, yes, that can work, but i plan add so many instance for PageBuffer, if i write all speical methods in class, it's huge.
17:54:42 <ManateeLazyCat> That's why i need pick up those speical functions out of class.
17:55:05 <ManateeLazyCat> s/right/write
17:55:22 <Saizan> ManateeLazyCat: one thing you could do is to add Typeable as superclass of PageBuffer, so you can use Data.Typeable.cast to try to downcast the value to e.g. StringBuffer
17:55:56 <ManateeLazyCat> Saizan: And it maybe throw exception?
17:56:06 <ManateeLazyCat> If i cast wrong type.
17:56:10 <Saizan> ?type cast
17:56:11 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
17:56:17 <Saizan> ManateeLazyCat: it returns Nothing
17:56:19 <ManateeLazyCat> Ah, maybe.
17:56:39 <ManateeLazyCat> Saizan: Thanks so much, i just need know how to cast.
17:56:51 <ManateeLazyCat> Saizan: I think cast is i want.
17:57:26 <Ford_Perfect> Hi I am trying to build high performance webserver application main function of which is caching requests to other servers (simiar to lighthttpd) and AJAX, since im new to Haskell (I used Erlang before) can you tell me what options for making web server app are there, and what are advantages/disadvantages of each?
17:57:52 <Ford_Perfect> I found out about Happs and HWS on google
17:58:19 <Saizan> there's also hyena
17:58:30 <Saizan> though i don't know if it has ever been released
17:59:12 <Ford_Perfect> it is on github it seems
17:59:18 <Ford_Perfect> (Hyena)
17:59:32 <Saizan> right
18:00:24 <Ford_Perfect> what are advantages of each of them?  and what would i use to get max performance (number of requests per second)
18:05:57 <Saizan> happs is more a webframework than just a webserver, hyena is the most focused on performance i think, however i'm not aware of any comparative benchmarks
18:07:03 <Ford_Perfect> any personal experience?
18:13:33 <benmachine> so how do people like to order things in their source files? I once used to define things with no dependencies first and build up on them, but recently I've started considering the merits of doing it in exactly the opposite way
18:14:29 <benmachine> i.e. main/module exports at the top, and then "explanations" of the names in them
18:14:57 <skorpan> i code first and divide later
18:15:11 <benmachine> well yes but eventually you finish coding
18:15:19 <skorpan> no, i divide later
18:15:31 <skorpan> but first i code
18:15:40 <skorpan> </troll>
18:15:46 * benmachine blinks
18:16:52 <Saizan> benmachine: i tend to keep types at the top, then exports and the rest afterwards
18:17:08 <Saizan> (even if the types are not exposed)
18:17:16 <codolio> Same here.
18:17:23 <benmachine> mm that makes sense
18:17:46 <codolio> Although in something with a 'main' I usually put it last.
18:18:15 <benmachine> but then you have to look down to see what is going on!
18:18:21 <benmachine> but then, you pretty much have to do that anyway
18:18:32 <Saizan> mh, sometimes i might put some accessors functions together with their type
18:21:36 <EvilTerran> i tend to have a type, its accessors, then its instances
18:21:38 <EvilTerran> (repeat)
18:21:44 <EvilTerran> then other functions
18:22:07 <mike-burns> When do you decide to split it into a separate module?
18:22:48 <EvilTerran> when finding things in the single module becomes too annoying
18:23:24 <Saizan> or when i anticipate reusing some part without caring about the rest
18:23:57 <Saizan> uhm, that's a bad way to put it
18:23:57 <EvilTerran> indeed. or if i want to enforce the modularity of something in particular
18:24:28 <mike-burns> I feel like we keep our functions small but modules long. Is that an accurate assessment?
18:24:55 <EvilTerran> for instance, an abstract type and its manipulator functions would get their own module, to ensure there's no mucking around in the internals
18:25:13 <mike-burns> Indeed, that makes sense.
18:28:17 <benmachine> if I make heavy use of an external library then I sometimes put the code that does in a separate file
18:28:29 <benmachine> so that I can keep the code that does and does not use the library distinct
18:28:57 <benmachine> although maybe that is just a special-case of what was being said about elements that may be reusable
18:29:18 * benmachine is thinking of his hscurses renderer
18:32:48 <laynor_> Saizan: what do you mean by "use that to replace the one in haskell-mode"? (sorry for delay, I was getting rid of some spiders in the house ^^;)
18:33:19 <blackdog> in the FFI, i suppose getting access to #defined values in a header file is impossible, barring writing explicit wrappers in C?
18:33:56 <Saizan> laynor_: seen the .el file lambdabot linked?
18:34:04 <Saizan> ?where kuribas-indentation
18:34:04 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
18:34:34 <laynor_> ahhh, thanks :)
18:35:55 <Saizan> blackdog: you could #include the header, if you do it via c2hs it should remove the c-specific parts too
18:36:25 <Saizan> keeping only the defines, iirc
18:36:55 <blackdog> Saizan: ah, cheers, i'll check that out
18:38:28 <kulakowski> I remember hearing somewhere that kuribas's version was going to be included in the next version of the haskell emacs mode, or did I make that up?
18:39:40 <andrei> Is there something special one must to do get the arguments of a reply (sendWithReplyAndBlock). I keep getting an empty array back
18:39:52 <Saizan> kulakowski: i remember something like that too
18:39:56 <andrei> The function returns a non-empty array
18:40:04 <blackdog> ah, bugger. looks like c2hs doesn't help me much with #defined constants. Boo-hiss to Matz for not using proper enums.
18:40:58 <Saizan> andrei: what library is that from?
18:41:19 <andrei> Saizan: hackage dbus (hdbus)
18:44:07 <Nehal> i'm having trouble understanding function composition: "(and .) . map" i know this is '(.) (and .) map" , but i'm confused about the composition operator inside the parentheses, can someone explain it to me please?
18:44:48 <mike-burns> :t (and .) . map
18:44:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:45:00 <Nehal> yes i looked at that too :)
18:45:10 <edwardk> Nehal: read that as (.) ((.) and) map -- perhaps
18:45:33 <mike-burns> @unpl (and .) . map
18:45:33 <lambdabot> (\ d g -> and (map d g))
18:46:07 <Nehal> edwardk: hmm, i didn't of that, it helps a bit
18:46:07 <ray> is it bad that i find the pointless one easier to read?
18:46:14 <edwardk> pointless notation gets ugly the moment you try to plumb a second argument through
18:46:35 <ray> do i need to take a sabbatical from haskell or something?
18:46:46 <Saizan> (.) ((.) and) map = \x -> ((.) and) (map x) = \x -> (.) and (map x) = \x -> \y -> and ((map x) y)
18:46:49 <edwardk> when there is one argument that needs to be plumbed through to the last function in a call chain it looks beautiful
18:47:23 <Saizan> \f -> and . map f
18:47:50 <Makoryu> @pl (f .) . (. g)
18:47:50 <lambdabot> (f .) . (. g)
18:48:01 <edwardk> i kind of wish there was a nice symmetric notation for 'pass two arguments' that resonated with . somehow like '..' (even though that isn't legal haskell), or three ..., etc.
18:48:03 <ray> @unpl (f .) . (. g)
18:48:03 <lambdabot> (\ e j -> f (e (g j)))
18:48:11 <Makoryu> :t (f .) . (. g)
18:48:12 <lambdabot> forall c a b c1. (Show c1, SimpleReflect.FromExpr c, Show a, SimpleReflect.FromExpr b) => (b -> c1) -> a -> c
18:48:18 <Makoryu> Whoops
18:49:04 <edwardk> personally i find it more useful to just start replacing (.)'s with fmaps or <$>'s, which tells me that i have a very warped idea of what is easy in haskell
18:49:05 <ray> not long ago i was confusing @pl with @unpl.. just goes to show that haskell is easy
18:49:17 <ray> edwardk: if only (.) were fmap
18:49:28 <edwardk> @type fmap and <$> map
18:49:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:49:47 <ray> see, that is easier to read :/
18:49:53 <edwardk> yeah
18:50:08 <Makoryu> :t (<$>)
18:50:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:50:17 <edwardk> Makoryu: its just infix fmap
18:50:17 <ray> <$> is infix fmap
18:50:22 <Makoryu> Ah
18:50:25 <ray> because some jerks won't make . infix fmap
18:50:38 <ray> and because it looks like <*>
18:50:52 <Makoryu> :t (<.>)
18:50:53 <lambdabot> Not in scope: `<.>'
18:51:16 <edwardk> Ray: meh, i'm of two minds on the . as fmap, the ad hoc 'hey its neat that this seems to always successfully typecheck' guy in me loves it. the category theory lover in me thinks its a horrible hack ;)
18:51:43 <ray> it really depends on whether you want to generalize . to fmap or to composition of something bigger than functions
18:51:53 <ray> i could go either way
18:52:01 <edwardk> arguably there are more functors running around in Haskell these days than categories
18:52:23 <ray> that's just these days though
18:52:33 <edwardk> which is an argument in favor of the generalization that cale loves to espouse
18:52:35 <edwardk> yeah
18:53:09 <ray> i know i want things generalized, i'm just not totally decided on how to do it
18:53:19 <ray> i don't have enough information yet
18:53:40 <gwern> @remember ndm I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
18:53:41 <lambdabot> Nice!
18:54:20 <ray> i'm currently biased towards functors etc since i use those, but that could change
18:56:46 <ray> it feels weird saying i "use" things like that, i have to glance around for an industry programmer waiting in the shadows to pounce on me
18:56:55 <copumpkin> if I want to embed an ST-something in my complex datastructure, I need to put the s parameter into my type constructor, right?
18:56:58 <copumpkin> at the end of the type parameters
18:57:00 <copumpkin> I can't do a forall s. existential within the constructor, right?
18:57:46 <andrei> Is there a recommended haskell dbus library? (the one on hackage seems rather broken)
19:00:10 <Saizan> copumpkin: right
19:05:11 <laynor_> Saizan: that indentation algorithm seems to work much better :)
19:07:08 <monochrom> Is the glasgow-haskell-users mailing list quiet these few days?
19:17:12 <vav> andrei: http://uhsure.com/xmonad-log-applet.html -- in this use of DBus he notes that must retry tryGetName repeatedly to get name
19:18:19 <andrei> vav: I get a reply, it just doesn't extract the full result, only part of it. I did try it repeatedly as well
19:19:21 <karlw> Where may I find a good HGL tutorial or reference?
19:21:12 <fooltron> permutations :: (Eq a) => [a] -> [a]
19:21:13 <fooltron> permutations [] = []
19:21:13 <fooltron> permutations x = [a:(permutations (filter (/=a) x))|a<-x]
19:21:21 <fooltron> oops
19:21:23 <fooltron> sorry
19:21:47 <fooltron> well, while it's there ...
19:22:11 <fooltron> can anyone tell me why that doesn't work?
19:22:12 <mike-burns> @src permutations
19:22:12 <lambdabot> Source not found. Are you on drugs?
19:22:23 <mike-burns> @src Data.List.permutations
19:22:23 <lambdabot> Source not found. Wrong!  You cheating scum!
19:22:36 <mike-burns> Anyway, it's already defined in Data.List if you just want to use it.
19:22:37 <fooltron> eek sorry lambdabot
19:22:56 <fooltron> yeah, I kinda guessed it'd be somewhere
19:23:27 <fooltron> but I'm still kinda wondering why it doesn't work
19:23:42 <mike-burns> Shouldn't that be  [a] -> [[a]]  ?
19:24:33 <fooltron> ahh!!
19:24:35 <fooltron> ahahah!
19:25:43 <fooltron> aww :(
19:25:51 <fooltron> didn't work :(
19:26:07 <mike-burns> Well now you have to re-think your function.
19:26:22 <mike-burns> The [] case should produce [[]] .
19:26:51 <fooltron> oh, yep
19:26:52 <Acteum> :t []
19:26:53 <lambdabot> forall a. [a]
19:26:53 <fooltron> I see
19:27:15 <fooltron> and have to fix up the a: ... bit
19:27:19 <mike-burns> Yup.
19:30:30 <fooltron> hmm ...
19:31:00 <fooltron> so changed it to permutations x = [map (a:) (permutations (filter (/=a) x))|a<-x]
19:31:27 <fooltron> and permutations [] = [[]]
19:31:41 <fooltron> but it seems to be bugging out on the permutations [] = [[]]
19:32:30 <fooltron> Occurs check: cannot construct the infinite type: a = [a]
19:32:31 <fooltron>     When generalising the type(s) for `permutations'
19:32:49 <mike-burns> Oh man my Haskell is rusty.
19:33:02 <mike-burns> We know the [] case is correct, so there's something wrong with your recurive case.
19:33:45 <Cale> That's an odd strategy for permutations...
19:34:09 <Cale> You shouldn't have to compare elements of a list for equality in order to construct permutations of the list.
19:35:09 <fooltron> probably shouldn't have to, but it's the first thing that came to me ...
19:35:23 <roconnor> @free permutations
19:35:25 <lambdabot> $map ($map f) . permutations = permutations . $map f
19:35:26 <Cale> fooltron: Anyway, permutations (filter (/= a) x) ought to be a list of lists, right?
19:35:29 <kniu> @pl (do v' <- apply v x; putPat e p x >>= eval t v')
19:35:30 <lambdabot> (line 1, column 20):
19:35:30 <lambdabot> unexpected ";"
19:35:30 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
19:35:38 <kniu> @pl do {v' <- apply v x; putPat e p x >>= eval t v'}
19:35:38 <lambdabot> (line 1, column 4):
19:35:38 <lambdabot> unexpected "{"
19:35:38 <lambdabot> expecting variable, "(", operator or end of input
19:35:38 <Cale> So map (a:) (permutations ...) will be a list of lists too
19:35:43 <kniu> hurm.
19:36:01 <Cale> and then those lists of lists are the elements of the list constructed by your list comprehension
19:36:02 <fooltron> aha
19:36:11 <Cale> So the whole comprehension is a list of lists of lists
19:36:19 <Cale> which is the wrong type
19:36:55 <kniu> is there a function mapply2 :: (a -> b -> m c) -> m a -> m b -> m c
19:37:20 <fooltron> cool cool. Ok I'll keep looking at it ...
19:37:34 <Saizan> kniu: no
19:37:48 <Cale> The way I would usually start to write a permutations function is to write a function  select :: [a] -> [(a,[a])]  which takes a list of values and constructs pairs consisting of one of the elements of the list, and the rest of the elements in the list
19:37:53 <kniu> very well.
19:38:06 <Cale> (it should not make use of equality testing, as suggested by its type signature)
19:38:12 <Saizan> @. pl undo  do {v' <- apply v x; putPat e p x >>= eval t v'}
19:38:13 <lambdabot> (putPat e p x >>=) . eval t =<< apply v x
19:39:08 <fooltron> yeah the equality thing is a nasty hack - for one thing, it can't handle lists with repeated elements
19:44:09 <fooltron> Cale: are you Koen C?
19:44:28 <Cale> fooltron: No, I'm Cale Gibbard
19:44:31 <Makoryu> fooltron: So sort the list and remove duplicates before permuting it
19:45:13 <Cale> Makoryu: That'll use equality testing too.
19:45:25 <Makoryu> Oh
19:45:27 <fooltron> oh ok, just found a haskell mailing list post with "I often find myself using the following function:    selections :: [a] -> [(a,[a])]"
19:45:42 * Makoryu kicks self
19:45:46 <Cale> Yes, everyone wants that function in Data.List
19:45:48 <fooltron> was so similar I thought it might be you :)
19:45:54 <Cale> I'm not sure why it's not there.
19:46:05 <Cale> I'm sure I've posted a similar message to that list too.
19:48:44 <pikhq> > let select [] = []; select (x:xs) = (x, xs) : select xs in select [1..10]
19:48:46 <lambdabot>   [(1,[2,3,4,5,6,7,8,9,10]),(2,[3,4,5,6,7,8,9,10]),(3,[4,5,6,7,8,9,10]),(4,[5...
19:49:05 <Cale> bzzt ;)
19:49:21 <Cale> But it's close
19:49:58 <pikhq> Ah. I see what you mean. That's slightly harder to write.
19:56:26 <codolio> > let select [] = [] ; select (x:xs) = (x, xs) : second (map (x:)) select xs in select [1..10]
19:56:28 <lambdabot>   Couldn't match expected type `[t] -> [a]'
19:56:46 <codolio> Oops.
19:57:00 <codolio> > let select [] = [] ; select (x:xs) = (x, xs) : map (second (x:)) select xs in select [1..10]
19:57:01 <lambdabot>   Couldn't match expected type `[(d, [t])]'
19:57:25 <codolio> > let select [] = [] ; select (x:xs) = (x, xs) : map (second (x:)) (select xs) in select [1..10]
19:57:27 <lambdabot>   [(1,[2,3,4,5,6,7,8,9,10]),(2,[1,3,4,5,6,7,8,9,10]),(3,[1,2,4,5,6,7,8,9,10])...
20:00:08 <andrei> By the way, if anyone is having issues with DBus-0.4 from hackage, http://haskell.pastebin.com/m278f443c fixes a bug with arrays
20:01:56 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1..10]
20:01:59 <lambdabot>   [(1,[2,3,4,5,6,7,8,9,10]),(2,[1,3,4,5,6,7,8,9,10]),(3,[1,2,4,5,6,7,8,9,10])...
20:02:36 <copumpkin> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1..]
20:02:37 <lambdabot>   [(1,[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:02:40 <aavogt> > tails [1..10]
20:02:41 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
20:03:44 <aavogt> > let f = zipWith (++) in inits [1..10] `f` tails [2..10]
20:03:45 <lambdabot>   [[2,3,4,5,6,7,8,9,10],[1,3,4,5,6,7,8,9,10],[1,2,4,5,6,7,8,9,10],[1,2,3,5,6,...
20:04:44 <fooltron> man, so which twisted, evil brain contrived that awesome select function
20:05:11 <vav> @seen God
20:05:12 <lambdabot> I haven't seen God.
20:05:13 <BMeph> kniu: Why not use liftM2 and join? :)
20:05:19 <aavogt> @src transpose
20:05:20 <lambdabot> transpose []             = []
20:05:20 <lambdabot> transpose ([]   : xss)   = transpose xss
20:05:20 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:05:31 <BMeph> @seen smart-people
20:05:31 <lambdabot> I haven't seen smart-people.
20:05:35 <vav> fooltron: it's built into Universe
20:05:37 <fooltron> or is this how I must truly twist my mind around on itself to get the zen of haskell
20:05:46 <BMeph> I hear ya' l-bot, I hear ya. ;p
20:05:56 <aavogt> @seen you
20:05:56 <lambdabot> I haven't seen you.
20:06:03 <Cale> fooltron: which version?
20:06:16 <Cale> fooltron: Or are you referring to the actual function itself?
20:06:42 <fooltron> just referring to the function
20:06:47 <fooltron> it's awesome
20:06:57 <Cale> fooltron: It's a fairly natural thing to want to have, since inside a list comprehension or in the list monad, it gives you a way to make selections without repetition.
20:07:10 <fooltron> I'm just not entirely sure that one can understand it AND maintain sanity
20:07:26 <Cale> hmm, I don't think it's too complicated...
20:07:33 <fooltron> is for me ...
20:07:38 <fooltron> but I'm new to all this
20:07:54 <aavogt> have there been any efforts to put select into Data.List?
20:08:03 * copumpkin votes +1
20:08:24 <Cale> aavogt: I recommended it at the same time permutations was going in, but apparently my recommendation was ignored ;)
20:08:37 <Cale> > permutations [1..5]
20:08:38 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
20:08:38 <monochrom> When I was a kid, I thought "university is impossible, grad school is insane". Now I am in grad school and think it's quite easy.
20:09:06 <monochrom> Moral: Do not underestimate your potent insanity.
20:09:08 <copumpkin> :)
20:09:36 <monochrom> err perhaps s/potent/latent/
20:10:12 <Cale> fooltron: One thing which might help is to think of the outer list as being a list of possibilities
20:10:22 <o-regalia> monochrom: grad school for what?
20:10:47 <Cale> fooltron: So you're getting something like a 'superposition' of all possible ways of selecting one element from the list, along with the remainder of the list.
20:10:57 <monochrom> When I was a kid I did not know that grad school for CS existed. (I did not know that CS existed.) Now I am in CS.
20:11:54 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:11:55 <lambdabot>  <local>:11:0:
20:11:55 <lambdabot>      Multiple declarations of `L.select'
20:11:55 <lambdabot>      Declared at: <lo...
20:11:57 <Cale> er
20:12:00 <Cale> @undefine
20:12:02 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:12:04 <lambdabot>  Defined.
20:12:16 <pikhq> When I was a kid I thought that Microsoft was the epitomy of programming.
20:12:46 <Cale> > [(x,y,z) | (x,xs) <- select [1..5], (y,ys) <- select xs, (z,zs) <- select ys]
20:12:48 <lambdabot>   [(1,2,3),(1,2,4),(1,2,5),(1,3,2),(1,3,4),(1,3,5),(1,4,2),(1,4,3),(1,4,5),(1...
20:12:58 <pikhq> Now, I realise that most programmers suck.
20:13:20 <fooltron> When I was a kid, I rode my trike into a pole and cracked my head on the pole and then I blacked out and then I had to get 11 stitches
20:13:23 <monochrom> hehe
20:14:30 <fooltron> so maybe that's my problem
20:14:37 <aavogt> Cale: unfortunate that select didn't make it
20:27:56 <bos> @seen shapr
20:27:57 <lambdabot> shapr is in #kata, #haskell, #haskell-blah and #scannedinavian. I last heard shapr speak 38m 37s ago.
20:28:03 <dancor> http://hackage.haskell.org/package/WordNet doesn't work with WordNet-3.0
20:28:17 <dancor> which makes you wonder about the wisdom of reinventing that c library in haskell.
20:36:38 <copumpkin> hmm
20:36:51 <copumpkin> http://en.wikipedia.org/wiki/Unital says something is Unital if it's got a "multiplicative" identity
20:37:10 <copumpkin> that seems a little vague
20:37:31 <kyagrd> Has anyone run lambdabot in other servers or channels?
20:37:45 <copumpkin> I have my own instance that I run occasionally
20:37:50 <copumpkin> it's not in very good shape though
20:38:23 <kyagrd> I was able to compile the lambdabot but didn't figure out how to make it log in and stick to the channel.  Does it need some external script?
20:45:13 <kyagrd> I tried running lambdabot with online mode "lambdabot --online" as it is documented in http://code.haskell.org/lambdabot/COMMENTARY but I get a mesage "Usage: lambdabot [-e 'cmd']*"
20:45:41 <jmcarthur> heh, the pi calculus is extremely easy to implement as a dsl, apparently. even easier than i at first thought it would be
20:46:59 <kyagrd> jmcarthur: Wow, then upload it on hackage!!!
20:47:08 <copumpkin> kyagrd: take its online2.rc and pipe it in
20:47:26 <kyagrd> copumpkin: thanks, I'll try that.
20:47:28 <jmcarthur> kyagrd: i'm not sure how useful it could possibly be
20:47:56 <jmcarthur> i wrote a solution to the dining philosophers problem, woop-dee-doo ;)
20:48:06 <kyagrd> jmcarthur: Ah, I even uploaded my toy like memscript.  Nobody would blame you.
20:48:22 <jmcarthur> may it would make an interesting enough blog post or something
20:48:25 <jmcarthur> *maybe
20:48:31 <jmcarthur> nothing groundbreaking though
20:48:39 <lament> does it involve calling the waitress for more chopsticks?
20:48:44 <jmcarthur> i think i might see if i can make it prettier
20:48:59 <jmcarthur> lament: nah, i uses fork numbering
20:49:02 <jmcarthur> *it
20:49:36 <jmcarthur> i guess chopstick numbering in your version
20:50:39 <lament> i didn't realize there was a version with forks
20:51:04 <lament> surely, you need one fork to eat
20:51:13 <jmcarthur> i dunno, i mostly just remember the problem at hand, not the specifics
20:51:28 <jmcarthur> although i am pretty sure most of the stories i've heard involved forks
20:51:34 <jmcarthur> chopsticks makes more sense, i admit
20:53:13 <Trinithis> for building ghc, what is the configure option that allows you to use arrowkeys and delete in ghci?
20:54:05 <kniu> @pl (\f x y -> join (liftM2 f x y))
20:54:06 <lambdabot> ((join .) .) . liftM2
20:57:12 <Makoryu> Trinithis: That's the editline library. I don't remember if the Haskeline replacement is standard yet in stable versions
20:57:58 <Trinithis> I remember compiling ghc with it before. I just forget the --option to do so
20:58:28 <Trinithis> --enable-editline ?
21:09:56 <jekor> How can I tell which library GHC is linking against? I'm trying to find out if GHC is using the built-in xhtml library or if it's using the cabal-installed one.
21:10:10 <jekor> (I made modifications to the latter.)
21:12:34 <Saizan> jekor: ghc --make defaults to the latest version available on the system, giving precedence to the user database
21:13:12 <jekor> OK. So I probably need to patch the latest then. Thanks.
21:13:17 <Saizan> jekor: you can pass it "-package $pkgname-$version" to specify a specific version
21:13:30 <jekor> Excellent. Might need that too.
21:14:57 <Baconizer> >let barg x = x * 2
21:15:01 <Baconizer> > let barg x = x * 2
21:15:03 <lambdabot>   not an expression: `let barg x = x * 2'
21:15:14 <Baconizer> > 2 * 2
21:15:16 <lambdabot>   4
21:15:18 <Baconizer> ok
21:15:52 <jekor> Hmm...hackage down?
21:16:09 <Baconizer> > sqrt -1
21:16:10 <Baconizer> >_>
21:16:10 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
21:16:11 <lambdabot>    arising from the literal `1' at <...
21:16:15 <Baconizer> aww
21:16:50 <pikhq> > let (*) = (+); (+) = (*) in 2 + 2
21:16:56 <lambdabot>   mueval-core: Prelude.read: no parse
21:16:56 <lambdabot>  mueval: ExitFailure 1
21:17:20 <Baconizer> > sqrt 5
21:17:22 <lambdabot>   2.23606797749979
21:17:23 <Baconizer> Hai guys
21:17:51 <Baconizer> > -5 - -5
21:17:53 <lambdabot>   Precedence parsing error
21:17:53 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
21:20:31 <Makoryu> > (-5) - (-5)
21:20:32 <lambdabot>   0
21:20:52 <Makoryu> > negate 5 - negate 5
21:20:53 <lambdabot>   0
21:21:35 <Baconizer> Emacs has an IRC client?
21:21:39 <Baconizer> Good heavens.
21:21:45 <Makoryu> It would be nice if that unary minus was part of the numeric literal
21:22:11 <pikhq> Emacs has quite a bit.
21:22:18 <impl> Emacs has at least four IRC clients
21:22:31 <Makoryu> Baconizer: Hell, I'm pretty sure Emacs has spreadsheet and tax return apps
21:22:33 <pikhq> Emacs also has a shell.
21:22:35 <hydo> Baconizer: yea... erc in particular is pretty nice.  I'm using it now.
21:22:41 <pikhq> And a terminal emulator.
21:22:45 <hydo> and a ...
21:22:48 <hydo> etc.
21:22:57 <impl> XEmacs has a window manager.
21:23:10 * Baconizer wonders how soon until Emacs just gives up pretending and releases it's OS
21:23:16 <pikhq> And a PDF reader.
21:23:30 <Makoryu> Baconizer: Someone at Google should work on that.....
21:23:44 <Makoryu> It might go in eldritch and terrifying directions.
21:24:00 <pikhq> Baconizer: About when Stallman gives up on the Hurd.
21:24:36 <hydo> Don't hold your breath on that.
21:26:43 <Axman6> would append x xs = foldr (:) [x] xs be any more efficient than append x xs = xs ++ [x]? (possibly some fusion there?)
21:27:30 <Saizan> Axman6: i think there's a RULE to rewrite the latter into the former
21:27:36 <Saizan> but it might not be firing
21:29:26 <Axman6> makes sense, thanks
21:29:40 <Axman6> i'm quite proud that i figured that versio out on my own actually
21:30:11 <Saizan> it's not limited to the [x] case, btw
21:31:47 <Axman6> yeah, (++) = flip (foldr (:)) right?
21:31:53 <Axman6> :t flip (foldr (:))
21:31:55 <lambdabot> forall a. [a] -> [a] -> [a]
21:32:09 <Axman6> > flip (foldr (:)) [1,2,3] [6,7,8]
21:32:11 <lambdabot>   [1,2,3,6,7,8]
21:32:15 <Axman6> :)
21:32:26 <pikhq> @src (++)
21:32:27 <lambdabot> []     ++ ys = ys
21:32:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:32:27 <lambdabot> -- OR
21:32:27 <lambdabot> xs ++ ys = foldr (:) ys xs
21:32:35 * Axman6 wins
21:32:58 <Axman6> i never thought folds like these would come so naturally to me, i'm quite happy
21:33:06 <Axman6> all while sitting in a lecture
21:35:47 <copumpkin> is enabling impredicative types scary?
21:37:06 <Saizan> it should just make the type inference more capable
21:37:24 * Axman6 thinks that Control.concurrent.QSem should have a function withQSem :: QSem -> IO a -> IO a
21:38:09 <Saizan> has anyone used twelf?
21:53:52 * Axman6 notes that using semaphores in C makes it look even more like obfuscating simple code
21:56:45 * copumpkin is still having great difficulty translating a very imperative algorithm to haskell
22:02:03 <glguy> to Haskell or to "Idiomatic Haskell"?
22:02:23 <copumpkin> I'd much prefer the latter, but even the former is quite difficult
22:18:06 <Saizan> copumpkin: wrestling with ST?
22:18:38 <copumpkin> wrestling with an epicly stateful algorithm on graphs :P I started implementing it with ST because it seemed easiest but got lost
22:18:40 <copumpkin> so I got rid of it all
22:18:55 <glguy> which algorithm?
22:18:55 <mmorrow> which algo?
22:18:56 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:19:18 <copumpkin> mmorrow: the same one I've been working on, on and off, for a month or so now :P http://www.psi.toronto.edu/pubs/2001/frey2001factor.pdf
22:19:28 <copumpkin> sum-product/belief propagation
22:19:39 <mmorrow> copumpkin: oh cool, i'll check that demo ide out
22:19:49 <mmorrow> ida
22:20:01 <copumpkin> ah yeah :) was confused for a moment, then I remembered :P
22:22:11 <resistor> are there versions of the Data.Bits functions that work on the Data.Int types anywhere?
22:22:19 <resistor> i need to rotate an Int64, for instance
22:22:38 <mmorrow> , 1 `shiftL` 12 :: Int32
22:22:40 <lunabot>  4096
22:22:52 <mmorrow> , 1 `shiftL` 12 :: Word64
22:22:53 <lunabot>  4096
22:23:04 <mmorrow> , 1 `shiftL` 12 :: Int
22:23:05 <lunabot>  4096
22:23:11 <copumpkin> :t shiftL
22:23:12 <lambdabot> forall a. (Bits a) => a -> Int -> a
22:23:25 <copumpkin> @instances Bits
22:23:26 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
22:23:59 <copumpkin> resistor: did you try? Data.Bits seems to contain everything
22:24:03 <mmorrow> @let (.<<.)=shiftL
22:24:05 <lambdabot>  Defined.
22:24:08 <mmorrow> @let (.>>.)=shiftR
22:24:10 <lambdabot>  Defined.
22:25:15 <mmorrow> resistor: it's kind of annoying in ghci, since you have to put a type annotations on everything with bit ops
22:25:38 <mmorrow> resistor: or you can just define you own specialized version
22:25:54 <Saizan> @type (.>>.)
22:25:55 <mmorrow> (.<<.) :: Int64 -> Int -> Int64; (.<<) = shiftL
22:25:56 <lambdabot> forall a. (Bits a) => a -> Int -> a
22:26:07 <Saizan> (oh, MR must be off)
22:26:09 <resistor> ah, i was misinterpreting the ghc error message
22:26:14 <resistor> sorry for the noise :-)
22:26:20 <copumpkin> :)
22:30:15 <resistor> vaguely relatedly, what's the best to convert between an array of bytes and an array of (little-endian) Word64's?
22:33:18 <resistor> preferably without duplicating the array
22:34:05 <mmorrow> resistor: what type do you have the array of bytes as?
22:34:20 <copumpkin> unsafeCoerce the array :P
22:34:31 <copumpkin> if it's a UArray
22:34:49 <mmorrow> (Ptr Word8), [Word8], ByteString, Array Int Word8, STUArray s Word8, ...
22:35:33 <ray> UArray just stands for UnsafeArray anyway
22:36:24 <mmorrow> resistor: also see Data.Binary
22:36:42 <Saizan> ray: Unboxed :P
22:37:03 <ray> unboxed, unsafe, unsound!
22:37:36 <mmorrow> resistor: if you don't want to copy and already have it as a Ptr, you can just peek/poke
22:37:54 <resistor> mmorrow: thanks for the pointers, i'll read up on those
22:39:11 <mmorrow> np
22:45:45 <Axman6> hmm, i'd never thought of using Data.Binary for transformations like that. they wouldn;t be safe, but they should work
22:46:04 <mmorrow> safe?
22:47:08 <Axman6> well, it totally relies on the implementation of the get and put methods
22:47:33 <mmorrow> getWord16le, getWord16be, ..
22:47:48 <mmorrow> putWord64be
22:47:56 <Axman6> no, i mean how the larger datatypes are put/get
22:48:21 <mmorrow> i never use the Binary defaults personally
22:48:34 <Axman6> well in that case, you'd be fine
22:59:26 <Axman6> http://perlmonks.org/?node_id=663393& heh
22:59:43 <matsuura> How can I make haskell useful in the DOS environment?
23:01:39 <mmorrow> forM_ (iterate (`plusPtr`1) (nullPtr::PtrWord8)) (flip poke 0) -- ?
23:01:45 <mmorrow> :)
23:02:35 <olsner> DOS can be used as a boot loader to start a real operating system, from which you can use haskell :)
23:02:37 <Axman6> "Kennedy's Lemma: If you can parse Perl, you can solve the Halting Problem."
23:02:41 <Saizan> = giveMeSomeSegfaults -- ?
23:03:07 <mmorrow> Saizan: overwrite the memory of all currently loaded programs with 0
23:03:08 <mmorrow> oops
23:03:17 <mmorrow> forM_ (iterate (`plusPtr`1) (nullPtr`plusPtr`1::PtrWord8)) (flip poke 0) -- ?
23:03:41 * mmorrow note to self, start at 0x1 not 0x0
23:04:20 <Axman6> why?
23:04:46 <mmorrow> Axman6: i thought "useful" := "to eradicate every trace of DOS from memory" ?
23:05:15 <Axman6> why start at 0x0 though?
23:05:27 <mmorrow> well, you can't because you'd segfault
23:05:50 <olsner> you can't segfault :)
23:05:50 <matsuura> olsner: that's boring
23:06:01 <mmorrow> olsner: lol
23:06:24 <mmorrow> olsner: can you write to 0 though?
23:06:44 <olsner> you can write whatever you want but you won't segfault since there is no access control of memory and the whole address space is mapped
23:07:17 <mmorrow> what happens when you write to a memory address that doesn't exist?
23:07:19 <mmorrow> oh
23:07:27 <olsner> doesn't exist doesn't exist :)
23:07:32 <mmorrow> the whole address space as in 0..maxBound?
23:07:33 <mmorrow> heh
23:08:21 <Saizan> that's scary
23:08:36 * mmorrow wants to install freedos in his vmware to play
23:08:40 <olsner> well, it does depend on the representation of pointers in this hypothetical DOS haskell
23:08:57 <matsuura> can haskell turn me into a great programmer/mathematician?
23:09:04 <Axman6> yes
23:09:11 <matsuura> Can you give me an example?
23:09:22 <Trinithis> sure
23:09:24 <olsner> @faq can haskell turn matsuura into a great programmer/mathematician?
23:09:24 <lambdabot> The answer is: Yes! Haskell can do that.
23:09:26 <Trinithis> > 0
23:09:29 <lambdabot>   0
23:09:36 <mmorrow> @faq can haskell fix error?
23:09:37 <lambdabot> The answer is: Yes! Haskell can do that.
23:09:39 <mmorrow> > fix error
23:09:41 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:09:52 <olsner> sweet
23:09:52 <Trinithis> see... im mathy enough to understnad the concept of 0,,, i can program it too
23:09:56 <matsuura> err... I asked for an example.
23:10:03 <Saizan> , fix error
23:10:09 <lunabot>  Killed.
23:10:17 <mmorrow> Saizan: i've been meaning to look at your code to do that
23:11:27 <olsner> mmorrow: that code could potentially just zero out the random section of 65536 bytes in memory that the data segment happens to currently be pointing at
23:11:56 <matsuura> please, show me an example!
23:12:28 <mmorrow> olsner: ahh, right. i forgot about segments
23:12:50 <Trinithis> matsuura: not sure what you are looking for... are you new to haskel;/?
23:13:23 <matsuura> why yes.. yes I am... Thank you for asking :)
23:13:34 <Saizan> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8179#a8179 <- then print out the Stream as you please
23:13:49 <olsner> of course, the haskell runtime could be using a dos extender or set up unreal or protected mode for itself
23:14:06 <Trinithis> Learning haskell gave me new appreciation for function composition
23:14:23 <Trinithis> also things like fix
23:14:27 <Trinithis> and monads..
23:14:30 <Trinithis> and much more
23:14:44 <olsner> 'fix' is awesome :)
23:15:02 <Trinithis> fix is the so called Y combinator
23:15:19 <Saizan> too bad we only have the least fixed point combinator
23:15:37 <Trinithis> can we implement others in haskell?
23:16:04 <matsuura> no
23:16:27 <Saizan> no, they wouldn't make much sense i guess :)
23:17:30 <copumpkin> why doesn't this work?
23:17:30 <copumpkin> type family a :-> b :: *
23:17:31 <copumpkin> type instance Int :-> b = IM.IntMap b
23:17:31 <copumpkin> type instance a   :-> b = M.Map a b
23:17:40 <copumpkin> it says     Conflicting family instance declarations:
23:17:45 <copumpkin> but it seems like it should be legal
23:17:56 <Saizan> ..but they overlap!
23:18:10 <copumpkin> I guess it doesn't care which came first :/
23:18:18 <Saizan> no
23:18:52 <dolio> Type families aren't allowed to overlap.
23:18:53 <copumpkin> and adding the Ord a constraint which should be on the second one doesn't help either
23:19:23 <copumpkin> hmm, so there's no easy way to give IntMap and Map a consistent interface?
23:19:36 <c_wraith> Turn on OverlappingInstances?
23:19:49 <Saizan> doesn't apply to type families
23:19:56 <mmorrow> Saizan: heh, that reimnds me vaguely of the function vacuum uses to vacuum undefined
23:20:00 <mmorrow> defined a = grab (return $! a) (return . unsafeCoerce#)
23:20:02 <dolio> Not like that. You need to list out every instance you want to use Map for.
23:20:10 <copumpkin> ugh
23:20:11 <copumpkin> :P
23:20:17 <mmorrow> where (grab :: IO a -> (SomeException -> IO a) -> IO a; grab = catch)
23:20:31 <mmorrow> copumpkin: :)
23:20:35 <dolio> You could do something like that with total type families, if they ever implement those.
23:20:38 <copumpkin> type instance (a ~/~ Int) => a :-> b = M.Map a b
23:20:39 <copumpkin> :P
23:20:48 <dolio> But they're closed.
23:20:50 <copumpkin> there, no overlap~
23:25:04 <Saizan> OverlappingInstances let you pick different instances in different modules, here you'd have different types which is probably worse
23:25:22 <drwho> what is the ':=' operand?
23:25:31 <drwho> is it just an '='?
23:25:49 <copumpkin> > let (:=) = (+) in 5 := 7
23:25:51 <lambdabot>   Constructor `Control.Parallel.Strategies.:=' should have 2 arguments, but h...
23:25:57 <copumpkin> lame
23:26:09 <copumpkin> I guess I can't do that cause it's "uppercase"
23:26:12 <Saizan> it starts with :, so it's a constructor
23:26:20 <drwho> ah I see
23:26:28 <drwho> that makes sense okay thanks
23:28:05 <Saizan> , src ''Assoc
23:28:09 <lunabot>  data Assoc a b = a `(:=)` b
23:29:02 <blackdog> is there a darcs command for reverting to the state of a remote repo, blowing away all local changes?
23:29:23 <c_wraith> you can use a combo of revert and unpull
23:29:45 <c_wraith> or just get a new copy
23:30:36 <BMeph> Heh-heh, I was gonna say 'get'. ;)
23:30:42 <Saizan> or darcs get --context=lastPatchFromTheRemoteRep local-repo
23:30:49 <Saizan> if you don't want to redownload
23:31:50 * copumpkin keeps wanting dependent types and then keeps remembering they aren't magical
23:31:56 <blackdog> ah, fair enough
23:32:04 <blackdog> used to the git "i'm an idiot" command :)
23:32:12 <blackdog> reset hard or whatever it is...
23:42:04 <kkaji`>  Please help me - http://www.lostworlds.lv/go.php?1139723800
23:45:37 --- mode: ChanServ set +o quicksilver
23:45:53 --- mode: quicksilver set +b plinka!*@*
23:46:05 --- mode: quicksilver set -o quicksilver
23:52:24 <copumpkin> one of the things I've found about haskell
23:52:59 <copumpkin> is that it's almost more frustrating to have loved and lost than to never have loved at all
23:53:04 <copumpkin> or something along those lines :P
23:53:21 <copumpkin> the type system is good enough that it frustrates me to no end when the properties I care about can't be expressed in it
23:55:00 <copumpkin> like, for this graph problem I'm working on, certain nodes have functions associated with them, such that the number of arguments of the function is the number of neighboring nodes
23:57:36 <mmorrow> copumpkin: this is kind of interesting, it's a prettyprint of a module in the "cps" stage of my interp, using the ghc-api=>ext-core frontend that i've got decently communicating with ghc. so the interesting part is that you can see exactly how ghc implements typeclasses by the code it generates (well, this has gone through a bunch of stages since the ext-core that ghc spit out, but that just changes the shape of stuff, not what's happeni
23:57:36 <mmorrow> ng) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3326
23:58:12 <mmorrow> e.g., notice how the Map instance for M.Map is passed the Ord dict for Data.Map.Map
23:58:27 <mmorrow> (which is $f1($dOrdaMn))
23:58:43 <copumpkin> ah
23:59:59 <mmorrow> so all typeclasses really give you is the convenience of not having to pass the record of functions around (granted, this is definitely a huge convenience, but i just mean that if you need to do something classes can't do you could always just pass around explicit dicts)
