00:00:18 <mmorrow> data Exp f b = .... | LetE [(b, f b)] (f b) | ...
00:00:56 <edwardk> ah, i guess i could replace the newtype with a type, and then its exactly the same
00:02:12 <edwardk> ah neat that worked
00:03:11 <mmorrow> one minorly annoying thing is that you need UndecidableInstances to derive Eq,Ord,Read,Show for Ann
00:03:21 <edwardk> yeah
00:03:22 <edwardk> thats fine
00:03:28 <mmorrow> (and you need to do it with standalone deriving on account of the need for the context)
00:03:29 <mmorrow> yeah
00:03:31 <edwardk> i need it for all sorts of recursive structures like that
00:03:42 <mmorrow> deriving instance (Show a, Show (f (Ann f a) b)) => Show (Ann f a b)
00:03:55 <edwardk> what i'm looking for is a clean reformulation of my syntax ADTs because they are fairly massive and i just want to get it right =)
00:04:21 <edwardk> yeah Show goes away pretty badly for me, fortunately I have unlex which comes for free for the cases I care about
00:04:31 <edwardk> (due to how these get constructed)
00:04:58 <mmorrow> edwardk: totally, that's *exactly* what i wanted to do too. a way to annotate them and at the same time disturbing existing code that uses those types as little as possible
00:05:02 <edwardk> since the annotation i am attaching is for the most part the stream of lexemes that generated the structure in the first place
00:05:25 <edwardk> to later be replaced with lots of other fiddly bits
00:05:33 <mmorrow> hmm, interesting
00:06:27 <edwardk> i'm currently parsing all this stuff monoidally, and generating most of my parse tree that way, but i chunk the normal notion of holding ontoa source location in the process, so everything needs to know its delta position so i can recalculate source position whenever i need an error
00:06:39 <edwardk> (where delta position due to line directives might actually be basically an absolute position)
00:06:56 <edwardk> er chuck the normal notion
00:07:51 <edwardk> but one of the applications of the big fat syntax tree i've built up is a refactoring browser or similar construction
00:08:12 <edwardk> and for that i want to be able to make local edits to the syntax tree and derive the new output source file
00:08:20 <edwardk> all of the stages of my lexer prior to syntax tree construction are reversible
00:08:54 <edwardk> so i just want to add the minimal extensions to make it so i can store the entire subtree of lexemes needed for a given syntax node as an f-algebra of the node that i construct incrementally
00:09:30 <edwardk> so mutating it will update the algebraic reduction, and i'll cheat and just keep the attached list of lexemes rather than tear it down and reconstruct when i'm dealing with code that came from an actual lex.
00:09:36 <mmorrow> ooh that's really nice. yeah, reversibility is one thing that's totally missing from haskell parsers (that parse haskell)
00:09:42 <edwardk> yeah
00:09:54 <edwardk> niklas broberg is wanting to add it to haskell-src-exts
00:09:58 <edwardk> and that got me thinking about this
00:10:19 <edwardk> though ndm wound up as his mentor this summer and not me, i'm still thinking about the problem, because i face it for kata
00:10:53 <edwardk> and its a shame that i have this beautiful reversible lexer for the rest of the parser right up to syntax tree construction
00:11:13 <edwardk> since it was a pain in the butt to debug up until i made it so i could ask every stage of the lexer to undo itself and give me the source back
00:11:38 <edwardk> so i.e. the layout parser can be unlexed and provide the original input.
00:11:58 <mmorrow> cool
00:12:08 <edwardk> (modulo some quibbling differences, like it'll have expanded any tab that it knows the length of (i.e. knows exactly where it occurred on the line)
00:12:17 <edwardk> and it'll have eaten space at the end of the line
00:12:34 * mmorrow hates trailing spaces!!! :)
00:12:37 <edwardk> and the line directive may occur closer to the next lexeme, etc.
00:12:47 <mmorrow> (tabs too)
00:13:04 <edwardk> but the net effect is that at least lex . unlex . lex = lex if nothing else
00:13:16 <mmorrow> then again, this is mostly on account of the fact that i make them visible..
00:14:16 <edwardk> oh, so as for comments, they get attached by virtue of the fact that later in the lexer i merge any comments into the surrounding space token, so they come along for the ride
00:15:04 <edwardk> (as do line directives)
00:15:10 <Peaker> I wonder if ghc's C parts can be replaced by a code generation combinator, in which that code can be written instead, so ghc is pure Haskell
00:18:01 <edwardk> hrmm
00:18:13 <edwardk> so there is one hideous consequence of all of that noise above though
00:18:18 <edwardk> i need Data and Typeable instances =(
00:18:32 <edwardk> that sounds like a whole lot of suck since they'd need to be explicit
00:19:47 <edwardk>     Can't make a derived instance of `Typeable (Exp f)'      (`Exp' has arguments of kind other than `*')
00:19:50 <edwardk> blech
00:22:58 <edwardk> oh doh
00:23:05 <edwardk> i just understood your deriving comment =)
00:23:13 <edwardk> thats exactly what i was just googling for =)
00:36:25 <wgsilkie> What would be the best way to get the largest item from a list of numbers?
00:36:33 <wgsilkie> Or smallest.
00:43:42 <badsheepy> > maximum [1..10]
00:43:44 <lambdabot>   10
00:48:03 <Notes_d-agrement> may encounter problems with very large lists
00:48:23 <Notes_d-agrement> due to laziness
00:48:35 <Notes_d-agrement> but unless you have a million elements or something, no need to worry
00:49:21 <Notes_d-agrement> @src maximum
00:49:21 <lambdabot> maximum [] = undefined
00:49:21 <lambdabot> maximum xs = foldl1 max xs
00:51:25 <Notes_d-agrement> or.. eh.. alternatively, maximum [] = undefined; maximum (x:xs) = maxHelper x xs
00:51:32 <Notes_d-agrement> maxHelper acc (x:xs) = maxHelper (max x acc) (maximum xs);   maxHelper acc [] = acc
00:51:36 <edwardk> mmorrow: hrmm this seems to give rise to a fairly perverse notion of an f-algebra at best
00:51:52 <edwardk> class Algebra e m where phi :: e (Base m) -> m -- where newtype Base a e = Base a
00:52:12 <edwardk> from that i can define my incremental folds, etc.
01:05:57 <edwardk> this seems somewhat at odds with the Data/Typeable instances i need though, so i'll have to figure out how to dump by SYB stuff
01:06:16 <edwardk> Typeable dislikes some of the kinds floating around
01:06:24 <edwardk> er dump my
01:30:34 <stanv> ?src curry
01:30:35 <lambdabot> curry f x y = f (x, y)
02:10:09 <mmorrow_> edwardk: heh, yeah the Typeable fail for this (general pattern of) type is a pita
02:13:09 <Yrogirg> Hello! I got "Error in array index". Can I somehow obtain more details? Which one array for example?
02:13:55 <Axman6> i don't believe you can.
02:14:30 <Beelsebob> Yrogirg: write wrapper functions for the unsafe array operations
02:14:36 <Beelsebob> that take strings to identify the call site
02:14:45 <Beelsebob> and throw more meaningful errors
02:14:46 <dufflebunk> Yrogirg: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:14:48 <dmwit> ?pl \h g (p, u) -> consume h p u id g
02:14:48 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (flip .) . flip flip id . (flip .) . consume
02:14:55 <dmwit> yummy
02:15:32 <maltem> Yrogirg, there's some way to get profiling print more specific errors, and there's the ghci debugger.
02:15:33 <c_wraith> pointless is sometimes not an improvement :)
02:16:32 <Axman6> s/sometimes/usually
02:17:34 <dufflebunk> If I have: foo >>= return . (filter (== 2)), and foo :: [IO a], will it have to evaluate all of foo before it can start applying the filter to the elements?
02:18:39 <c_wraith> No.  Just each element as filter needs it
02:18:48 <dufflebunk> oops, I mean: foo >>= sequence >>= return . (filter (==2)) .
02:19:04 <dufflebunk> oh, nm, my first one was right
02:19:19 <Beelsebob> dufflebunk: that looks like filter (==2) <$> foo to me
02:19:45 <Beelsebob> and no, lazyness is unaffected by monads
02:20:00 <Beelsebob> some specific monads do go out of their way to strictify things though
02:20:42 <Beelsebob> although if foo :: [IO a] you probably did want the sequence in there
02:20:43 <Beelsebob> ;)
02:20:53 * dufflebunk looks up <$>
02:20:53 <Beelsebob> filter (==2) <$> sequence =<< foo
02:20:57 <Beelsebob> dufflebunk: fmap
02:21:37 <Beelsebob> finally though
02:21:46 <Beelsebob> that's a mapM
02:21:58 <Beelsebob> mapM (filter (==2)) foo
02:22:52 <Beelsebob> oh, no it's not quite
02:22:58 <Beelsebob> ignore that last stmt
02:23:09 <Beelsebob> no idea what I was thinking
02:23:22 <dufflebunk> sequence foo >>= return . (filter (==2))  is what I want.
02:23:40 <Beelsebob> yes, right
02:23:42 <Beelsebob> but that's a fmap
02:23:44 <Beelsebob> filter (==2) <$> sequence foo
02:23:57 <dufflebunk> foo is basically reading stuff from a file, so it's returning [IO a]
02:24:04 <Beelsebob> x >>= return . f is equal to f <$> x
02:24:21 <Beelsebob> why would reading from a file return [IO a]?
02:24:26 <Beelsebob> @type hGetContents
02:24:28 <lambdabot> Not in scope: `hGetContents'
02:24:32 <Beelsebob> bah
02:24:35 <Beelsebob> @type getContents
02:24:37 <lambdabot> IO String
02:25:25 <dufflebunk> It's reading chunks out and parsing the chunks.
02:25:32 <Beelsebob> why?
02:25:49 <Beelsebob> (filter (==2) . parseFile) <$> getContents "file"
02:26:21 <dufflebunk> It's really getting the data from a FFI. The FFI is given a handle and it returns more data.
02:26:35 <Beelsebob> ah, k
02:26:51 <Beelsebob> then yeh, (filter (==2) . parseStuff) <$> sequence readStuffFromFFI
02:27:47 <dufflebunk> :t <$>
02:27:49 <lambdabot> parse error on input `<$>'
02:27:55 <Beelsebob> @type (<$>)
02:27:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:28:49 <dufflebunk> I don't quite see how that matches what I was doing. Is guess IO is a functor...
02:28:59 <Beelsebob> all monads are functors
02:28:59 <dufflebunk> ah, ok, I see.
02:29:06 <Beelsebob> (or should be rather)
02:29:19 <Beelsebob> fmap applies a function "inside" a constructor
02:29:24 <Beelsebob> in this case, inside the IO magic
02:29:53 <Beelsebob> so you give it an (a -> b), and an IO a, and it does the computation inside the IO type and gives you back an IO b
02:30:26 <maltem> dufflebunk, for monads, (fmap f x) = (x >>= return . f) (if the monad is behaving)
02:30:33 <Beelsebob> quite
02:30:47 <elbar> @instances Functor
02:30:47 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:31:18 <dufflebunk> Yeah, still working on learning all the monad related functions. I was also introduced to &&& today.
02:32:09 <Beelsebob> for a slight generalisation... (f <$> a1 <*> a2 <*> ... <*> an) = (a1 >>= \ra1 -> a2 >>= \ra2 -> ... an >>= \ran -> return (f ra1 ra2 ... ran)
02:32:32 <Beelsebob> &&& is from Arrows, which is an entirely new and exciting hierarchy of abstraction
02:32:59 <SubStack> it's true
02:33:08 <SubStack> arrows are the bee's knees
02:33:16 <Beelsebob> not sure I agree with that statement
02:33:22 <Beelsebob> but they're certainly useful on occasion
02:33:38 <dufflebunk> Yeah, it was.
02:33:47 * ppavelV6 not sure he understands the meaning of the phrase "bee's knees" at all
02:33:49 <SubStack> they seem to be a big part of idiomatic haskell in my experience
02:34:03 <SubStack> if only here and there
02:34:08 <Beelsebob> I'm not sure I or anyone else knows what idiomatic haskell is
02:34:16 <Beelsebob> there are so many idioms I've seen people write in
02:35:07 <SubStack> well, there is certainly "more" and "less" idiomatic code
02:35:44 <sjanssen> SubStack: arrows see very little use in my experience
02:35:57 <Beelsebob> &&& and *** are the two things I use a lot from arrows
02:36:01 <Beelsebob> where by a lot I mean "at all"
02:36:44 <sjanssen> they're mostly used for the pair convenience functions, and they're almost always used on (->)
02:36:51 <Beelsebob> yep
02:36:57 <Beelsebob> that's certainly how I use them
02:37:35 <sjanssen> and even then, those functions are only used when code golfing, for the most part
02:37:42 * dufflebunk isn't sure how bee's knees could ever be part of idiomatic haskell
02:37:47 * Beelsebob is not sure what code golfing is
02:38:16 <Beelsebob> dufflebunk: when you use the functions /+ and +\ they're known as bees knees
02:38:16 <Beelsebob> >.>
02:38:26 <dufflebunk> *L
02:38:28 <dufflebunk> *
02:38:29 <SubStack> pfft
02:40:02 <sjanssen> Beelsebob: you've never heard the term?  In regular golf, the fewest strokes wins.  In code golf the fewest characters or lines of code wins
02:40:11 <Beelsebob> ah k
02:40:22 <Beelsebob> dunno, I tend to find using &&& makes code longer
02:40:28 <Beelsebob> but saves an annoying lambda
02:40:33 * Baconizer hopes that learning Haskell doesn't get tedious
02:40:38 <Beelsebob> and makes things more readable
02:40:52 <Baconizer> So far it's come a lot more smoothly than trying to learn other languages (which I've only tried a little)
02:40:55 <Baconizer> :D
02:41:12 <Beelsebob> :)
02:41:16 <sjanssen> Baconizer: I don't think Haskell ever gets tedious, there will always be some cool new thing to learn
02:41:59 <PeakerWork> Beelsebob: you don't use "first" and "second" for SECing?
02:42:09 <Beelsebob> Peaker: oh, you're right, I do
02:44:08 <ski> ("SECing" ?)
02:46:10 <SubStack> likewise @ ski
02:46:26 <Beelsebob> ditto
02:46:35 * Beelsebob has no idea what Peaker meant by that part
02:51:18 <ski> hm
02:51:32 <ski> S?? Editor Combinators ?
02:52:04 <Rembane> Recursion is slow! *whine*
02:52:04 <ski> Semantic
02:52:15 <Rembane> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3132#a3132 <- Slow! :(
02:52:40 <Rembane> Err... I mean, is there a way to make that code faster?
02:53:14 <ski> cache / memoize the values ?
02:53:25 <Axman6> there sure is (that's basically _the_ most unefficient way to write a fibonacci function)
02:53:41 <ski> evaluating that naïvely is exponential
02:54:34 <Axman6> > let fib n | n < 2 = 1; | otherwise = fib' n 1 1 where fib' 0 x y = x; fib' n x y = fib' (n-1) y (x+y) in fib 1000
02:54:35 <lambdabot>   <no location info>: parse error on input `|'
02:54:41 <pstickne> I like the fib function that implicitly uses the stack :p
02:54:46 <Axman6> > let fib n | n < 2 = 1 | otherwise = fib' n 1 1 where fib' 0 x y = x; fib' n x y = fib' (n-1) y (x+y) in fib 1000
02:54:47 <lambdabot>   703303677114228158218352548771835497701812698363587327426049050871545371181...
02:55:21 <Rembane> Axman6: Cool.
02:55:24 <Rembane> ski: Indeed.
02:55:24 * sjanssen prefers the O(log n) multiplications Fibonacci
02:55:38 <Axman6> Rembane: that version is O(n)
02:55:47 <Rembane> Axman6: Awesome! Thank you
02:55:48 <Axman6> instead of something like O(n^n)
02:55:58 <sjanssen> Axman6: be careful, it is only O(n) multiplications, not necessarily O(n)
02:56:06 <Axman6> yeah
02:56:10 <Axman6> sjanssen: additions maybe?
02:56:18 <sjanssen> Axman6: oh yeah, I mean additions
02:56:29 * sjanssen was still thinking about the matrix fib
02:56:49 <maltem> What do you mean, not necessarily O(n)?
02:56:55 <Axman6> [[1,1][1,0]]*[1,1]?
02:57:03 * mmorrow_ is always baffled when people choose to do fib n = fib (n-1) + fib (n-2)
02:57:14 <Axman6> maltem: i think additions of Integers are log n
02:57:19 <Axman6> or something
02:57:27 <Rembane> mmorrow_: It looks like the mathematic formula. :)
02:57:28 <maltem> ah right
02:57:28 <sjanssen> maltem: fib grows exponentially, and (+) and (*) don't take constant time
02:58:12 * maltem is not used to attributing arithmetics non-constant cost
02:58:15 <mmorrow_> , let fib m n = m : fib n (m+n) in (fib 0 1) !! 1000000
02:58:20 <lunabot>  luna: out of memory (requested 1048576 bytes)
02:58:24 <maltem> stupid arbitraray-size Integers :P
02:58:25 <mmorrow_> , let fib !m n = m : fib n (m+n) in (fib 0 1) !! 1000000
02:58:27 <lunabot>  luna: out of memory (requested 1048576 bytes)
02:58:35 <mmorrow_> , let fib !m n = m : fib n (m+n) in (fib 0 1) !! 100000
02:58:36 <lunabot>  2597406934722172416615503402127591541488048538651769658472477070395253454...
02:58:44 <PeakerWork> mmorrow_: could be cool if silly recursions like that were re-written to bottom-up computations automatically
02:58:54 <ski> > fix ((0 :) . fix . ((1 :) .) . zipWith (+))
02:58:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:58:57 <mmorrow_> PeakerWork: that would be interesting
02:59:10 <mmorrow_> , fix ((0:) . scanl (+) 1)
02:59:11 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
02:59:13 <sjanssen> Axman6: [[1, 1], [1, 0]] ^ n = [[f_{n+1}, f_n], [f_n, f_{n-1}]]
02:59:26 <Axman6> right
02:59:46 <PeakerWork> mmorrow_: memoize the recursion could do it, except it wouldn't know to dump old memoized results when it could
03:00:27 <sjanssen> so what sort of rewriting would we need to get that?
03:00:30 <mmorrow_> PeakerWork: yeah, i think it would need to be a transformation of a rep of the code itself (if it's possible at all)
03:01:02 <PeakerWork> mmorrow_: I don't think it is possible in the general case, except for the memoization method (which leaks space)
03:01:27 <PeakerWork> intuitively, it feels like automatically converting a general recursion to a structural one
03:01:35 <ski> (.. maybe in more restricted cases ..)
03:01:48 <mmorrow_> PeakerWork, sjanssen: that's be interesting to extrapolate from the fib example to some class of functions you could do this for (and an algorithm that does so)
03:01:54 <mmorrow_> *that'd
03:02:43 <mmorrow_> it almost seems somewhat analogous to the kind of things done by compilers to optimize loops
03:03:01 <maltem> couldn't one way to transform the memoized version into a space-efficient? Somehow by observing that computing element n doesn't refer to elements smaller than n-2
03:03:12 <maltem> s/one way/one find a way/
03:03:48 <mmorrow_> maltem: you'd need to be constantly deleting values from your memo table to enable them to be GC'ed
03:03:51 <ski> maybe we should consider course-of-values recursion on other types ..
03:04:10 <PeakerWork> mmorrow_: that's not problematic in the fib case, the memo size is 2
03:04:34 <ski> PeakerWork : yes, but how does the transformation determine that ?
03:05:03 <PeakerWork> ski: assuming maltem's way somehow works, then that way :)
03:05:16 <mmorrow_> PeakerWork: if you're looking at it that way, then you can consider the bottom-up version to be using such a memo-table, but in the opposite direction
03:06:13 <ski> method of solving problems : (a) assume problem is solved (b) deduct what the solution is (/ could be, or an inconsistency)
03:06:42 <ski> mmorrow_ : the bottom-up version referring to ?
03:06:54 <PeakerWork> in the fib case, the recursive pattern is not at all determined by the values, so you could "run" the recursion once to figure out the dependencies, then run it bottom up, discarding stuff your dependency analysis understands aren't necessary
03:07:00 <mmorrow_> , let fib !m n = m : fib n (m+n) in fib 0 1
03:07:01 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
03:07:42 <ski> ok
03:07:45 <mmorrow_> that's optimal for fib in both time and space
03:08:11 <maltem> I mean, given a high-level description of a bottom-up algorithm building up a huge table, wouldn't it even be *easy* to derive an algorithm of smaller memo size?
03:09:31 <maltem> And deriving the bottom-up algorithm from the recursive formula is easy too, since larger values depend on smaller values only
03:10:39 <mmorrow_> say we restrict ourselves to numeric sequences... so i think the situation would roughly be that of converting a description of the sequence using a recurrence to a generative description of that sequence
03:10:47 <sjanssen> f (n+2) = f n + f (n+1) -- n + k patterns make it obvious
03:11:53 <Axman6> apparently they're slated to be removed in Haskell'
03:11:56 <maltem> mmorrow_, right
03:13:34 <PeakerWork> Pattern matches using Eq for Num instances and matching data constructors everywhere else is already bad enough, IMO
03:13:43 <PeakerWork> (No need to add weird n+k patterns)
03:15:41 <sjanssen> PeakerWork: some argue that we ought to add n*k patterns
03:16:04 <maltem> PeakerWork, I guess the obvious remedy would be class IntegralLiteral where fromInteger ...; matchInteger ...; -- ?
03:16:17 <PeakerWork> sjanssen: I think its silly to add lots of specific cases.. Generalize the idea and add that IMO
03:16:51 <sjanssen> maltem: how is that better than Eq and fromInteger?
03:16:54 <PeakerWork> maltem: match integer is Eq, pretty much, but then pattern-matches should work for anything with Eq to be consistent
03:17:23 <PeakerWork> but maybe it could just use a different syntax
03:17:40 <PeakerWork> we already have ~ and ! on patterns, we can have @ for == comparison
03:17:45 <maltem> sjanssen, probably in no way. Just it doesn't involve Num
03:17:46 <PeakerWork> f @0 = 1
03:17:47 <sjanssen> @ is used
03:17:53 <PeakerWork> what's @?
03:18:02 <skorpan> x@(Hello _)
03:18:04 <Deewiant> f x@(_:_) =  x
03:18:19 <PeakerWork> oh, that, of course :)
03:18:33 <PeakerWork> amazing how the brain can have one-way lookup tables :)
03:18:44 <Deewiant> Still available as prefix, of course
03:18:57 <Deewiant> f @x is a syntax error currently
03:19:02 <PeakerWork> Well, # is used for ghc hackery... $ is available in patterns, I guess?
03:19:30 <maltem> $ is used by TH, if that counts
03:19:44 <sjanssen> PeakerWork: I don't see the current situation as so bad.  There are only two cases where this happens, and they're both straightforward
03:19:44 <Axman6> ^?
03:19:51 <maltem> my keyboard suggests Â§ :P
03:20:04 <PeakerWork> sjanssen: Ad-hoc'ish
03:20:39 <sjanssen> Axman6: all of the characters you've suggested are legal operator characters (ie. will add more ad-hoc exceptions to the grammar)
03:21:03 <Axman6> i've only suggested one character...
03:21:17 <Axman6> so technically, all of them... but still
03:22:02 <maltem> f (= 0) = 1
03:22:07 <sjanssen> oh, got confused by everybody talking at once.  To be more specific: $ and ^ are operator characters
03:22:28 <sjanssen> maltem: (== 0) would make more sense
03:22:43 <maltem> sjanssen, but == is a valid operator
03:22:47 <Deewiant> ViewPatterns: f ((== 0) -> True) = 1
03:23:13 <sjanssen> maltem: it's applied in a section, so there aren't any ambiguities
03:23:37 <sjanssen> Deewiant: yay views!
03:24:16 <maltem> hm right
03:24:35 <sjanssen> PeakerWork: I think this special syntax makes Haskell more pleasant to program in
03:25:06 <PeakerWork> sjanssen: I agree, I just would like it to be generalized if possible
03:25:11 <maltem> hey, f \0 = 1
03:25:18 <sjanssen> same with lots of non-general syntactic sugar: list syntax, string syntax
03:25:28 <sjanssen> PeakerWork: how do you feel about non-pattern numeric literals?
03:28:18 <PeakerWork> sjanssen: fromInteger is great for literals, I think
03:28:25 <PeakerWork> sjanssen: could be nice if string literals were fromString too
03:28:41 <PeakerWork> sjanssen: Perhaps even lambda literals were fromFunction :-)
03:28:54 <sjanssen> PeakerWork: right, but I mean in the sense that they're not general
03:29:27 <PeakerWork> sjanssen: Now that you mention it, the "generalization" of having all Haskell literals go through  from*  functions would make it significantly nicer, and save a lot of "ord" calls for me :)
03:29:45 <PeakerWork> so its not that nice now, but it certainly is more general/nicer than having int literals be ints
03:31:04 <sjanssen> PeakerWork: wait, you want 'a' to also be syntax for 97?
03:31:48 <PeakerWork> sjanssen: sure, why not?
03:32:21 <ski> butbut .. what about EBCDIC ?
03:32:29 <sjanssen> PeakerWork: feels like C :(
03:32:47 <PeakerWork> I guess encoding issues suggest it might not be a good idea...
03:32:49 <ski> (not to talk about unicode)
03:33:05 <PeakerWork> but it should let me have an Ascii numeric type that 'a' translates to which is (Ascii 97)
03:33:09 <sjanssen> Haskell does endorse Unicode specifically
03:34:28 <ski> (afaiu, there's no single best "character" type in unicode)
03:47:06 <abbe> hi all
03:47:34 <Axman6> o/
03:50:20 <abbe> hi Axman6
03:50:27 <Axman6> how are you abbe?
03:50:29 <abbe> I'm trying to populate a Map using state monads as pasted in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7812#a7812, but I'm having problems using State monad for this.
03:50:38 <abbe> trying to understand monads.
03:51:35 <Axman6> you're not recursing over the list, are you supposed to?
03:51:54 <abbe> Axman6: actually I'm just trying to debug the code
03:52:00 * Axman6 doesn't understand how to use the State monad still
03:52:26 <abbe> The basic code is not working yet.
03:53:04 <skorpan> M.insert isn't monadic
03:53:05 <skorpan> oh wait
03:53:06 <skorpan> no, it's not monadic
03:55:01 <skorpan> get >>= M.insert x (length x) >>= put
03:55:01 <skorpan> something like that maybe
03:55:55 <abbe> okay, I tried that already.
03:57:19 <maltem> abbe: Note that when you're writing M.insert x (length x), all you're saying is that you want to create a new Map where x points to (length x), but you're not saying what Map to update, or where to put the new one
03:58:08 <abbe> maltem: runState (populateMap array) M.empty, I guess an empty map is passed to the populateMap function
03:58:50 <abbe> maltem: 'M.insert x (length x)' should get the passed empty Map
03:59:05 <maltem> abbe: yeah, that's what skorpan's code expresses
03:59:17 <ski> > covr (const 0 : const 1 : repeat (\(a0:a1:_) -> a0 + a1))
03:59:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:59:21 <maltem> alternatively, modify (M.insert x (length x))
04:01:00 <ski> (sjanssen,maltem : imo, either of `f (= 0) = ...' or `f (== 0) = ..' would be bad)
04:05:07 <PeakerWork> Language.C is tough to use :(
04:05:18 <gwern> C is tough to use :(
04:05:18 <PeakerWork> Annoying lack of Show instances
04:05:25 <PeakerWork> I guess you're not supposed to unpack the constructors on your own
04:05:36 <PeakerWork> I want to build a better cscope with Language.C, but I guess it'll wait
04:05:39 <abbe> > :t (M.insert "A" 1) >> return ()
04:05:40 <lambdabot>   <no location info>: parse error on input `:'
04:05:46 <abbe> > :t (Data.Map.insert "A" 1) >> return ()
04:05:48 <lambdabot>   <no location info>: parse error on input `:'
04:05:48 <PeakerWork> cscope sucks -- I want to be able to browse code quickly
04:06:00 <PeakerWork> and do real C lookups, not heuristic approximations
04:06:01 <gwern> @hoogle Data.Map.insert
04:06:02 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
04:06:02 <lambdabot> Data.Map insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
04:06:02 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
04:06:11 <gwern> abbe: aren't you missing an arg to insert?
04:06:35 <abbe> >:t (M.insert "A" 1) >> return ()
04:06:42 <maltem> abbe: no > before :t when using lambdabot
04:06:51 <abbe> :t (M.insert "A" 1) >> return ()
04:06:52 <lambdabot> forall t. (Num t) => M.Map [Char] t -> ()
04:07:54 <maltem> abbe: also, what gwern said (and what we said earlier)
04:07:58 <gwern> interesting. didn't know you could combine partial application with bind like that
04:08:35 <abbe> maltem: as you can see, my State monad is also (M.Map String Int) -> (), where is the problem ?
04:08:46 <maltem> gwern: actually - what monad is this?
04:08:54 * gwern shrugs
04:08:55 <maltem> ah
04:09:20 <maltem> of course, the (->) e monad
04:09:50 <gwern> oh, of course
04:10:05 <gwern> how could've I forgotten about the (->) e monad
04:10:12 <maltem> abbe: no problem so far :)
04:11:22 <abbe> maltem: I mean in my code, populateMap :: [String] -> State (M.Map String Int) () ; populateMap (x:xs) = (M.insert x (length x)) >> return () ; populateMap []     = return ()
04:11:43 <maltem> abbe: well in your code, you said you wanted to use the state monad
04:11:58 <ski> > covr' ((curry (const 0) : repeat (const (succ . head))) /\/ (curry (const 1) : repeat (\(_:n:m:_) -> const (m + n))))
04:11:59 <lambdabot>   [0,1,2,1,4,3,8,7,16,15,32,31,64,63,128,127,256,255,512,511,1024,1023,2048,2...
04:12:02 <maltem> and also, you wanted your code to do something specific
04:12:09 <abbe> yes
04:12:19 <abbe> i want to solve the problem using monads
04:12:30 <maltem> for which we told you the solution, using get/put or using modify
04:14:40 <abbe> maltem: is modify some function ?
04:14:42 <abbe> :t modify
04:14:43 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
04:14:53 <abbe> lol
04:15:08 <abbe> i thought you asked me to modify the code..
04:15:18 <maltem> oh
04:15:26 <maltem> yes, I mean the function :)
04:16:39 <ski> @hoogle State s a -> m a
04:16:39 <lambdabot> Text.Parsec.Prim stateUser :: State s u -> u
04:16:39 <lambdabot> Text.ParserCombinators.Parsec.Prim stateUser :: State s u -> u
04:16:39 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
04:17:03 <ski> @hoogle (s -> (a,s)) -> m a
04:17:03 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
04:17:03 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
04:18:35 <O_4> Have any of you had luck using the Haskell SDL bindings on OS X?
04:32:38 <Beelsebob> does anyone know why cabal isn't respecting the library path option here? http://paste.lisp.org/display/84616
04:35:59 <Yrogirg> Hello! Why do files "arr" and "arr'" have different sizes (524 and 284 B)?
04:35:59 <Yrogirg> arr  = listArray (1,20) [1..20] :: UArray Int Double
04:35:59 <Yrogirg> arr' = listArray (1,20)  [0..0] :: UArray Int Double
04:35:59 <Yrogirg> encodeFile "arr " arr
04:35:59 <Yrogirg> encodeFile "arr'" arr'
04:36:49 <ski> > listArray (1,20) [0..0]
04:36:50 <lambdabot>   array (1,20) [(1,0),(2,* Exception: (Array.!): undefined array element
04:37:27 <ski> (.. maybe you meant `replicate 20 0' instead of `[0..0]' ?)
04:37:49 <maltem> > listArray (1,20) [0..0] :: UArray Int Double -- the elements should be undefined in the C sense, rather?
04:37:50 <lambdabot>   Not in scope: type constructor or class `UArray'
04:37:57 <maltem> bah
04:38:46 <maltem> ok, ghc initializes them to 0
04:38:51 * ski suspects `encodeFile' raised an exception after having only partially written an array encoding
04:39:01 <abbe> :t return Data.Map.size empty
04:39:03 <lambdabot>     Ambiguous occurrence `empty'
04:39:03 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
04:39:03 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at /home/cale/.lambdabot/State/L.hs:56:0-22
04:39:08 <abbe> :t return Data.Map.size Data.Map.empty
04:39:09 <lambdabot> forall k a. M.Map k a -> Int
04:39:17 <abbe> > return $ Data.Map.size $ Data.Map.empty
04:39:18 <lambdabot>   Not in scope: `Data.Map.size'Not in scope: `Data.Map.empty'
04:39:36 <abbe> :t return $ Data.Map.size $ Data.Map.empty
04:39:38 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
04:39:45 <Deewiant> > M.size M.empty
04:39:46 <lambdabot>   0
04:40:17 <abbe> any ideas why there are different types for above statements ?
04:40:37 <Deewiant> The latter is return (size empty), the former is (return size) empty
04:41:14 <abbe> But what different does that makes ?
04:41:25 <abbe> :t return Data.Map.size
04:41:27 <lambdabot> forall k a (m :: * -> *). (Monad m) => m (M.Map k a -> Int)
04:42:00 <Deewiant> It's like the difference between 1 * 2 - 3 and 1 * (2 - 3), i.e. they're completely different things :-P
04:42:20 <Deewiant> In the former case, you're applying return to an integer
04:42:31 <Deewiant> So you get an integer in an arbitrary monad
04:42:35 <abbe> oh, okay
04:42:49 <Deewiant> In the latter case, you apply return to a function, then apply the result of that to Data.Map.empty
04:42:55 <abbe> got it, thanks :-)
04:43:32 <Yrogirg> so what's the problem? I didn't get :-(
04:44:09 <Deewiant> Well, applying (return size) to empty means that (return size) has to be a function
04:44:20 <Botje> > [0..0]
04:44:21 <lambdabot>   [0]
04:44:45 <Deewiant> Given that return is of type Monad a => a -> m a, that constrains the m to the reader monad i.e. (->) x
04:44:49 <Deewiant> So we get
04:45:09 <Deewiant> ?ty return Data.Map.size :: a -> Data.Map.Map k v -> Int
04:45:11 <lambdabot> forall a k v. a -> M.Map k v -> Int
04:45:46 <Deewiant> I.e. a function which ignores its first parameter, always returning the function Data.Map.size
04:45:59 <Deewiant> Then you apply that to Data.Map.empty, which gets ignored
04:46:07 <Deewiant> And you're left with Data.Map.size
04:46:15 <Deewiant> ?ty return Data.Map.size Data.Map.empty
04:46:16 <lambdabot> forall k a. M.Map k a -> Int
04:46:19 <Deewiant> ?ty return Data.Map.size "foobar"
04:46:21 <lambdabot> forall k a. M.Map k a -> Int
04:47:38 <MiniCow> > 1:+ 0
04:47:39 <lambdabot>   1.0 :+ 0.0
04:47:50 <Deewiant> Yrogirg: Hopefully that cleared it up a bit?
04:47:50 <Yrogirg> What are you talking about? I really can't understand. I need a file with an array of zeroes to be the same size as any other nonzero array file.
04:48:03 <MiniCow> > (1:+0) ** 2
04:48:05 <lambdabot>   1.0 :+ 0.0
04:48:05 <Yrogirg> lol, no :(
04:48:07 <Deewiant> Oh, you were talking about a different issue, oops :-)
04:48:19 <Axman6> > (1:+1) ** 2
04:48:20 <lambdabot>   1.2246467991473532e-16 :+ 2.0
04:48:21 <abbe> Deewiant: I'm still confused
04:48:22 <MiniCow> > (0:+0) ** 2
04:48:24 <lambdabot>   NaN :+ NaN
04:48:32 <Deewiant> Yrogirg: In your case, the problem is that [0..0] is not twenty zeroes
04:48:34 <Deewiant> > [0..0]
04:48:35 <lambdabot>   [0]
04:49:02 <Deewiant> So your listArray call isn't writing the same amount of data as the one where you give it [0..20]
04:49:12 <MiniCow> Anybody got an idea why (0+0i) raised to a general power is nans?
04:49:35 <Deewiant> > (0 :+ 0) ^^ 2
04:49:36 <lambdabot>   0.0 :+ 0.0
04:49:46 <Axman6> > (1:+1) ** 2.5
04:49:47 <lambdabot>   (-0.9101797211244547) :+ 2.19736822693562
04:50:01 <Beelsebob> ugh
04:50:10 * Beelsebob wonders what the hell is going on with cabal
04:50:11 <Axman6> > (0:+1) ** 2.5
04:50:11 <Beelsebob> :(
04:50:12 <lambdabot>   (-0.7071067811865477) :+ (-0.7071067811865475)
04:50:16 <MiniCow> It just seems to be 0:+0 and only with (**)
04:50:18 <Deewiant> MiniCow: A bug? :-/
04:50:27 <dmwit> > (0 :+ 0) ^ (-1)
04:50:28 <Yrogirg> Deewiant: well, but the
04:50:28 <Yrogirg> listArray (1,20) [0..0] :: UArray Int Double
04:50:28 <Yrogirg> gives me exactly array with 20 zeroes. Anyway, how to construct an array with 20 zeroes?
04:50:29 <lambdabot>   * Exception: Negative exponent
04:50:47 <MiniCow> Deewiant: You need ^^ for that
04:50:52 <ski> <ski> (.. maybe you meant `replicate 20 0' instead of `[0..0]' ?)
04:50:52 <Deewiant> Hmm, maybe listArray works differently than I thought
04:51:04 <Deewiant> Yrogirg: See what ski said
04:51:09 <Axman6> > [0,0..]
04:51:10 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:51:50 <ski> > replicate (range (1,20)) 0
04:51:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:51:53 <maltem> Deewiant, I think UArray initializes non-specified elements to 0
04:52:04 <abbe> Deewiant: :t size => Map k a -> Int, :t return size => m (Map k a -> Int).  Data.Map.size :: a -> Data.Map.Map k v -> Int, from where does 'a' come from ?
04:52:13 <maltem> Deewiant, but I'm not sure if that is something one can rely on
04:52:27 <Deewiant> maltem: If it does, it still doesn't explain his problem
04:52:32 <maltem> true, true
04:52:36 <Deewiant> abbe: Data.Map.size :: Map k a -> Int
04:52:39 <Yrogirg> arr' = listArray (1,20) $ take 20 [0..]
04:52:39 <Yrogirg> is it ok?
04:53:20 <Deewiant> abbe: Your type for 'return size' is the generic one: for any Monad m, m (Map k a -> Int).
04:53:21 <abbe> Deewiant: true, but you said size :: a -> Map k v -> Int
04:53:25 <ski> > replicate (rangeSize (1,20)) 0
04:53:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
04:53:29 <Deewiant> abbe: No, I said return size :: a -> Map k v -> Int
04:53:33 <ski> (that's what i was after)
04:53:36 <dmwit> Yrogirg: It's okay, as long as you want your array to have increasing values.
04:53:41 <dmwit> > [0..]
04:53:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:54:02 <dmwit> > map (const 0) (range (1, 20))
04:54:04 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
04:54:04 <Deewiant> abbe: In the context in which return size was used, it was applied to empty: return size empty, i.e. (return size) empty
04:54:12 <abbe> Deewiant: okay, so when 'm (x -> y)' gets evaluated as 'a -> x -> y' ?
04:54:18 <dmwit> umm
04:54:19 <abbe> s/when //
04:54:20 <dmwit> :t listArray
04:54:21 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
04:54:24 <Deewiant> abbe: To apply any x to anything, x has to be a function
04:54:35 <dmwit> > listArray (1, 20) [0]
04:54:37 <lambdabot>   array (1,20) [(1,0),(2,* Exception: (Array.!): undefined array element
04:54:42 <ski> dmwit : `rangeSize'
04:54:44 <dmwit> heh
04:54:46 <Deewiant> abbe: In this case, x is return size, of type m (Map k a -> Int)
04:54:49 <Yrogirg> ski: I've tried arr' = listArray (1,20) $ replicate 20 0 :: UArray Int Double and the sizes still vary 2 times
04:54:57 <dmwit> ski: hmm?
04:55:03 <ski> @type rangeSize
04:55:04 <lambdabot> forall a. (Ix a) => (a, a) -> Int
04:55:17 <dmwit> But I don't want to use rangeSize.
04:55:18 <Deewiant> abbe: So GHC checks and finds that there is an instance of Monad for functions
04:55:34 <abbe> Deewiant: so m (Map k a -> Int) gets expanded to a -> Map k v -> Int
04:55:35 <Deewiant> abbe: And replaces m with (->) x
04:55:40 <Deewiant> abbe: Yes.
04:55:55 <dmwit> Yrogirg: What do you mean by "the sizes vary 2 times"?
04:55:59 <abbe> Deewiant: oh, okay, where is this mentioned in docs, any ideas ?
04:56:04 <dmwit> Yrogirg: i.e. what do you observe, and what were you expecting?
04:56:16 <abbe> doc of Monad class ?
04:56:29 <ski> abbe : `Control.Monad.Reader' probably
04:56:37 <Deewiant> abbe: Well, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html#t%3AMonad shows the instance Monad ((->) r)
04:56:57 <abbe> Deewiant: so (->) is an operator ?
04:57:00 <Deewiant> Beyond that, you just have to know how type classes work
04:57:08 <dmwit> abbe: No, (->) is a type constructor.
04:57:09 <Deewiant> (->) is the function arrow
04:57:09 <ski> `(->)' is a type
04:57:13 <Deewiant> Like in a -> b
04:57:22 <ski> a -> b  =  (->) a b
04:57:28 <Deewiant> ski: Not a type, a type constructor
04:57:48 <dmwit> Pah.  Types are just nullary type constructors.
04:57:53 <Deewiant> :-P
04:58:03 <Yrogirg> dmwit: I thought they must be the same size for UArray of doubles. But for [1..20] it is 512 B and for replicate 20 0 it is 284 B
04:58:14 <ski> Deewiant : i have a habit of calling every expression on that level a type, not just those which have kind `*'
04:58:27 <dmwit> Yrogirg: Oh no!  Lists and arrays are represented very differently in memory.
04:58:47 <maltem> dmwit: no, he's serializing two arrays
04:58:55 <ski> (Deewiant : because imo `Maybe' is a type constructor, while `Writer Int' is not)
04:59:13 <maltem> or she. Yrogirg anyways ;)
04:59:25 <ski> (i'm open for any better naming suggestion)
04:59:28 <abbe> okay, so when we say ((->) a) is a monad we mean, what ?
04:59:34 <dmwit> Serializing just happens to be another way to represent things in memory.
04:59:48 <Deewiant> ski: Well, Writer Int still isn't a type: you can't have a value with that type
04:59:48 <dmwit> If you start with a different representation, you're not likely to spontaneously converge just because you serialized it.
05:00:03 <ski> abbe : the same as when we say e.g. `Writer Int' is a monad
05:00:20 <dmwit> s/a different representation/different representations/ and s/serialized it/serialized them/, I guess
05:00:21 <abbe> ski: what about functionalities of >>=, return ?
05:00:33 <ski> Deewiant : exactly .. so what do you propose we call it (except "type") ?
05:00:41 <ski> @src (->) return
05:00:41 <lambdabot> return = const
05:00:45 <ski> @src (->) (>>=)
05:00:45 <lambdabot> f >>= k = \ r -> k (f r) r
05:00:54 <Deewiant> ski: Well, I'd still call it a type constructor rather than a type :-P
05:01:31 <Deewiant> I suppose you can qualify it somehow, like "partially applied type constructor"
05:01:33 <ski> `Writer' is a type constructor, `Int' is also one, but `Writer Int' is the application of the former to the latter, not a type constructor
05:01:39 <ski> (all imho)
05:01:42 <maltem> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7813 -- this is indeed funny
05:02:06 <ski> Deewiant : also, what about e.g. `f (Mu f)' ?
05:02:44 <Deewiant> IMO it just depends on the kind
05:02:45 <ski> (abbe : yell if you need elaboration)
05:03:33 <abbe> that'll be better, can you explain me this w.r.t. some example functions, like add x y = x + y, sub x y = x - y ?
05:03:43 <maltem> Yrogirg, wait, this is easy to explain
05:04:13 <Yrogirg> maltem: It will be nice
05:04:20 <maltem> Yrogirg, the serialized representation of (0::Double) is smaller than other Doubles
05:04:32 <Yrogirg> I guess so.
05:04:38 <ski>   return size empty  =  const size empty  =  size
05:04:40 <maltem> > Data.Binary.encode (0::Double)
05:04:41 <lambdabot>   Not in scope: `Data.Binary.encode'
05:04:46 <maltem> fail
05:04:53 <Yrogirg> Can I enforce it to be larger?
05:04:56 <EvilTerran> Deewiant, i'd say "type expression" to mean "combination of type variables and type constructors with any kind", and "type" to mean "combination of type variables and type constructors with kind *"
05:05:17 <Deewiant> That's an option
05:05:19 <abbe> > let add x y = x + y; sub x y = x - y
05:05:20 <lambdabot>   not an expression: `let add x y = x + y; sub x y = x - y'
05:05:28 <abbe> >let add x y = x + y; sub x y = x - y
05:05:49 <abbe> :t (add 20 >>= sub) 100
05:05:49 <ski> Deewiant : imo, it is a bit confusing to use the term "constructor" on the type level for something completely different than what we use it on the value level for
05:05:50 <lambdabot> Not in scope: `add'
05:05:50 <lambdabot> Not in scope: `sub'
05:06:14 <ski> @let add = (+); sub = (-)
05:06:15 <lambdabot>  Defined.
05:06:19 <maltem> Yrogirg, you could write your own Binary instance for a newtype'd Double
05:06:20 <Deewiant> I suppose you have a point
05:06:29 <Deewiant> I guess I wouldn't call (,) 1 a constructor
05:07:24 <abbe> (add 20 >>= sub) 100 => sub (add 20 100) 100
05:07:36 <Yrogirg> maltem: Any other ideas? I'd better use 10^-10 instead of zeroes.
05:07:38 <ski> (but yes, it would be quite nice to have good terms for this .. but i don't think "type constructor" is good)
05:08:42 <ski> abbe : in any case, `(r ->)' is basically the same as `Reader r', except the latter has wrapping constructor and unwrapping deconstructor
05:10:20 <EvilTerran> ski, does "type expression" appeal to you?
05:10:36 <EvilTerran> ski, or are you looking for a word for type expressions specifically not of kind *?
05:10:46 <maltem> Yrogirg, what's your usecase? do you need a specific representation?
05:10:49 <ski> (for the latter, no)
05:11:17 <ski> yes, "type expression" works for the syntactic object
05:12:14 <ski> i've been using "type" for the corresponding semantic objects .. which is what some people wanted restricted to only those with kind `*'
05:12:32 <maltem> Yrogirg, the Binary instance apparently decomposes the floating-point number into x*10^(significand bits + 1) and a (scaled) exponent
05:13:32 <Yrogirg> maltem: I need to write lots of  arrays and read them back. The constants size is just for easier reading the data back.
05:14:25 <maltem> yeah I think you really have to do the encoding yourself then
05:18:09 * Beelsebob ponders if dcoutts is anywhere about
05:34:06 <PeakerWork> I wish Language.C had some example uses
05:51:57 <mmorrow> could anyone that's on osx possibly paste the output of "cpp -dM /dev/null" for me? :)
05:54:11 <Beelsebob> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7814#a7814
05:54:34 <Beelsebob> __APPLE__ is the standard way of spotting OS X if that's what you're after
05:54:41 <mmorrow> Beelsebob: thanks! :)
05:54:50 <mmorrow> Beelsebob: ah nice, that's one of the things, yes.
05:55:31 <a_coder> when i declare data ... deriving (Show) where do i put the implementation for show?
05:55:42 <Beelsebob> you don't
05:55:49 <EvilTerran> a_coder, the point of deriving is you don't need to specify an implementation
05:55:51 <Beelsebob> deriving (Show) means "write my show implementation for me"
05:56:01 <Beelsebob> if you want to write you own, write:
05:56:03 <Beelsebob> data ...
05:56:10 <Beelsebob> instance Show ... where
05:56:10 <Beelsebob>   show =
05:56:45 <a_coder> how does it know how to implement show for me?
05:56:53 <dmwit> I thought showsPrec was totally inscrutable until I started writing my own Show instances and trying to get parentheses right.
05:56:59 <dmwit> Then I came up with showsPrec on my own. =)
05:57:39 <dmwit> a_coder: The "Show" instance that GHC derives is basically a pretty-print of the Haskell AST.
05:58:03 <Beelsebob> not very pretty
05:58:03 <dmwit> You can drop the output of a derived Show instance straight into a Haskell file and expect it to work.
05:58:11 <Beelsebob> (in that it doesn't take into account terminal width obviously)
05:58:32 <dmwit> ...hard to take terminal width into account with show's type.
05:58:33 <Beelsebob> dmwit: I was under the impression that even if you wrote your own, that was meant to be a constraint on it
05:58:36 <Beelsebob> indeed
05:58:47 <a_coder> how does deriving work in haskell?
05:58:52 <dmwit> Beelsebob: Not necessarily.  Several notable libraries break that; Parsec comes to mind.
05:59:01 <Beelsebob> a_coder: the compiler looks at your type and tries to figure out a sensible definition
05:59:07 <idnar> a_coder: hardcoded into the compiler, pretty much
05:59:24 <Beelsebob> for Show, it just outputs the AST as it would be in the the source as dmwit said
05:59:27 <idnar> you can only use "deriving" with a handful of classes like Show and Eq
05:59:33 <Beelsebob> for Eq it does a recursive comparison
05:59:42 <idnar> although there's newtype deriving, which works for anything the wrapped type has an instance for
05:59:44 <Beelsebob> for Ord it uses the order of the definition of constructors
06:00:02 <a_coder> what else, Show, Eq, Ord
06:00:16 <Beelsebob> Enum numbers them in order of constructor definition
06:00:16 <mmorrow> Beelsebob: hmm, do you get a different set of defines via "gcc -m64" ?
06:00:21 <Beelsebob> Read reads what Show outputs
06:00:21 <Deewiant> Enum, Read
06:00:26 <dmwit> Show, Read, Eq, Ord, Enum, Bounded, Ix, hmm... Typeable, Data?
06:00:38 <Deewiant> With DeriveDataTypeable, Typeable+Data
06:00:47 <dmwit> I'm sure there's a section in the GHC manual.
06:00:49 <Deewiant> With GeneralizedNewtypeDeriving, just about anything for newtypes
06:00:54 <Beelsebob> mmorrow: I get input too small with that
06:01:04 <mmorrow> Beelsebob: :o
06:01:05 <a_coder> so outside of these can you declare your own derivables?
06:01:11 <Deewiant> Nope
06:01:17 <mmorrow> Beelsebob: with what?
06:01:20 <Beelsebob> mmorrow: oh, sorry, I'm being a noob -- I was running gcc
06:01:20 <Beelsebob> >.<
06:01:21 <Beelsebob> sec
06:01:25 <mmorrow> Beelsebob: heh
06:01:41 <Saizan> a_coder: there's the derive package on hackage that does that via TH
06:01:51 <momrouy> Hello, I have just started reading a book (Algorithms: a functional programming approach) that uses Haskell 98 as defined in 1999. Is it outdated? would it be adviable for a beginner to go ahead anyway?
06:02:02 <Beelsebob> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7814#a7815 <-- the second one is your 64 bit version
06:02:08 <dmwit> momrouy: Yes, H98 is totally doable.
06:02:11 <mmorrow> Beelsebob: thanks much
06:02:17 <hackagebot> clientsession 0.0.1 - Store session data in a cookie. (MichaelSnoyman)
06:02:32 <dmwit> momrouy: When you get comfortable with H98, the extensions will be a welcome relief from its shortcomings, nothing more.
06:02:33 <momrouy> dmwit, alright. thanks
06:02:38 <Beelsebob> momrouy: current Haskell is Haskell 98 with a bunch of extensions -- very few of which break anything in H98
06:02:40 <Beelsebob> so it's a great thing to learn
06:03:38 <Beelsebob> oh yay!
06:03:42 <Beelsebob> star naming works :)
06:04:05 <maltem> momrouy, you may tip on some library functions defined elsewhere, but since the APIs are searcheable, there shouldn't be a problem in following the text
06:04:38 <maltem> s/defined elsewhere/moved to a different module/
06:07:49 <ski> there's also : Chapter 7. GHC Language Features - 7.16. Generic classes <http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html>
06:27:46 <|zzz|> in 'data Foo a = Elem a' what does Elem do and where's it defined?
06:28:19 <kpreid> that defines it
06:28:22 <Taejo> |zzz|: that declaration defines Elem. It's a constructor: so (Elem 3) :: (Foo Int)
06:28:26 <kpreid> Elem is the value constructor
06:28:52 <|zzz|> is Elem part of the Prelude or a keyword?
06:29:06 <Taejo> |zzz|: neither
06:29:20 <Taejo> it's a newly-defined data constructor
06:30:43 <|zzz|> why am i able to do, data Foo a = ThisIsntDefinedAnywhere a?
06:31:09 <Taejo> |zzz|: why do you think you shouldn't be able to do that?
06:31:53 <|zzz|> because it's not defined anywhere?
06:31:59 <Megant> you can define it that way
06:32:50 <Taejo> |zzz|: what resource are you learning Haskell from? Maybe I can point you to the relevant section
06:33:45 <|zzz|> oh i'm using learnyouahaskell
06:34:17 <ray> you are defining it there
06:34:37 <ray> it's like me writing "this sentence was never typed into an irc client"
06:34:42 <ray> but i just typed it into an irc client
06:35:03 <|zzz|> oh i get it
06:35:51 <kpreid> I wonder if |zzz|'s confusion was contributed to by that Elem is on the *right side of an equals sign*
06:36:16 <Taejo> yeah, I'm looking at that section of LYAH, and I agree it could be clearer
06:36:46 <Taejo> BONUS: maybe you should clarify that "data" declares not only the type, but also the constructors
06:38:15 <Taejo> lambdabot: tell BONUS the LYAH section on ADTs could possibly clarify that "data" declares not only the type, but also the constructors (the fact that the constructors appears to the right of the equals sign might be part of the confusion)
06:41:36 <ski> @help tell
06:41:36 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
06:41:54 <ski> lambdabot: arr
06:41:59 <ski> lambdabot: @arr
06:41:59 <lambdabot> Aye
06:42:04 <ski> Taejo : ^
06:42:21 <Taejo> ski: yeah, I realised. I did the right thing in a privmsg to avoid spamming
06:42:31 <ski> ic
06:44:14 <gwern> the creator of QI is abandoning computers and going to India
06:44:32 <gwern> dude, the 20th century called. it wants its hippy stereotypes back
06:45:04 <gwern> http://groups.google.com/group/Qilang/browse_thread/thread/592773c562017d87?pli=1
06:45:10 <Taejo> gwern: Stephen Fry?
06:45:45 <Taejo> gwern: ah, you mean Qi
06:50:40 <gwern> I wonder why a 'wandering Taoist' as he describes himself would go to India, and not China
06:51:43 <malosh> Hi. I'm playing with Text.Parsec. I have a stack as the parser "state", and I'd like a heap too, but I'd dont want to implement my GC, so I'd like to use STRef-like things. Anyone ever done this ?
06:52:53 <gwern> (hm. means he's also abandoing his ars programma idea; I guess he's lowered his aims from saving the computing world to saving himself)
06:57:22 <Saizan> malosh: you should be able to do that with ParsecT over the ST monad
06:59:01 <Axman6> > undefined == undefined
06:59:04 <lambdabot>   * Exception: Prelude.undefined
06:59:13 <Axman6> > undefined == (undefined :: ())
06:59:14 <lambdabot>   * Exception: Prelude.undefined
06:59:16 <Axman6> lame
06:59:23 <Axman6> @src () (==)
06:59:24 <lambdabot> () == () = True
06:59:48 * Axman6 thinks it should be _ == _ = True for funsies
07:00:24 <Axman6> > let (==) :: () -> () -> Bool; _ == _ = True in undefined == (undefined :: ())
07:00:25 <lambdabot>   True
07:00:30 <malosh> Salzan : I think so, but I don't manage to include my newSTRef in a parser
07:02:44 <kpreid> malosh: lift newSTRef
07:02:52 <malosh> ok, thanks
07:05:12 <Geheimdienst> hey guys ... i got into some trouble with cabal today
07:05:32 <Geheimdienst> i tried to cabal install missingh, and this is what happened: http://pastebin.com/m9214a44
07:05:58 <truthair> If I get it right a function that does IO and returns a value always returns "IO type" (such as "IO [Int]" in my case)?
07:07:32 <Axman6> themroc-: yup
07:07:37 <Axman6> uh, truthair
07:07:38 <Beelsebob> Geheimdienst: you need ghc 6.10
07:07:41 <lysgaard> Hi, I just read about the Haskell Platform, but there was no real explenation of what it is, just the tecnical stuff. What is the purpose of it really?
07:08:14 <Axman6> lysgaard: to have a bunch of pre packages libraries that lots of people need (like cabal-install, OpenGL etc)
07:08:22 <ski> Axman6 : "funsies" ?
07:08:51 <themroc-> yup :p
07:09:40 <Geheimdienst> beelsebob: ok i'm looking into that ... my ubuntu seems to come with 6.8.2
07:10:10 <ski> Axman6 : if you consider `()' as if defined by `data () = ()', then it should be `() == () = True'
07:10:21 <lysgaard> Axman6: Does this mean that i can replace many of my manually installed packages with this big one? I'm on Arch
07:10:35 <Axman6> lysgaard: possibly
07:11:10 <lysgaard> Axman6: Cool.
07:11:15 <truthair> I was going over Yet Another Haskell Tutorial. One of the exercises is reading in a list of numbers and printing out the sum (and some more stuff, but once I figure out sum I'll manage that). My current attempt is at http://paste.pocoo.org/show/132177/ but it A) doesn't work and B) is horrificly ugly. So any help solving those problems is welcome.
07:11:39 <ski> (if you consider `()' to be a coinductive type, then effectively `_ == _ = True' would be more appropriate, though)
07:11:47 <ray> axman6: so you want () to be == to _|_? eeeeeeeeeeeeeeeeeeeeeeeeeeewwwwwwwwwwwwwwwwwwwwwwwwww
07:11:55 <lysgaard> Btw, is there any way to use cabal install to remove packages. And if not, how do i completely remove them by hand, so GHC doesn't complain about missing files?
07:11:56 <ray> more 'e's and 'w's are available on request
07:12:21 <Axman6> ray: of course!
07:12:36 <ski> (for pairs, that would be `p0 == p1 = fst p0 == fst p1 && snd p0 == snd p1')
07:13:05 <ski> (or `~(a0,b0) == ~(a1,b1) = a0 == a1 && b0 == b1', if you will)
07:13:07 <ray> > repeat 'e' ++ repeat 'w'
07:13:09 <lambdabot>   "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
07:13:23 <ski> (i.e. `~() == ~() = True' for the `()' case)
07:13:44 <Axman6> so, here's a question: is last (repear 'e' ++ repeat 'w') == 'w'?
07:13:48 <ski> > repeat 'w' /\/ repeat 'o'
07:13:51 <lambdabot>   "wowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowowo...
07:13:55 <ray> axman6: no, it's _|_
07:14:08 <Axman6> bah
07:14:11 <Axman6> that's o fun
07:14:13 <Axman6> no*
07:14:16 <kublar> truthair: main = do nums <- askForNum; stuff nums
07:14:18 * Axman6 hates _|_
07:14:23 <lysgaard> truthair: I think i can help you. Do you have a link to the exercise?
07:14:24 <ray> axman6: also, if i were changing == like that, i'd much prefer it to be strict in both arguments always
07:14:44 <ski> ray : for `()' ?
07:14:49 <ski> or for every type ?
07:14:54 <ray> every type
07:15:18 <truthair> lysgaard: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf page 45
07:15:22 <ski> > (0:undefined) == []
07:15:23 <lambdabot>   False
07:15:32 <ski> ray : so you'd want that to be bottom ?
07:15:46 <ray> i'd prefer that being bottom to [] == undefined being True
07:15:50 <ski> (or maybe you only meant top constructor ?)
07:16:26 <ski> ray : say again ?
07:16:49 <ray> it's preferable to _ == _ = ...
07:16:56 <ski> "it" being ?
07:17:04 <ray> needlessly strict ==
07:17:38 <ski> why needlessly ?
07:17:43 <soupdragon> > [] == undefined
07:17:45 <lambdabot>   * Exception: Prelude.undefined
07:17:46 <soupdragon> it's not true
07:17:50 <ray> i don't think we're talking about the same thing
07:17:55 * ski is not sure what ray is trying to say
07:18:28 <soupdragon>  I think he means == should be symmetric
07:18:38 <ray> no no no
07:19:01 <ray> a! == b! = ... is preferable, for any type including (), to _ == _ = ...
07:19:28 <soupdragon> what
07:19:37 <ray> that is, needless strictness is better than needless non-strictness
07:19:40 <ski> even for a terminal type ?
07:19:42 <ray> i'm not saying needless strictness is good
07:19:50 <soupdragon> > undefined == undefined
07:19:51 <lambdabot>   * Exception: Prelude.undefined
07:19:56 <soupdragon> > undefined == (undefined :: ())
07:19:58 <lambdabot>   * Exception: Prelude.undefined
07:20:05 <soupdragon> > () == (undefined :: ())
07:20:07 <lambdabot>   * Exception: Prelude.undefined
07:20:11 <soupdragon> > undefined == (() :: ())
07:20:12 <lambdabot>   * Exception: Prelude.undefined
07:20:19 <soupdragon> this already happens though?
07:21:26 <ray> undefined == (undefined :: ()) -- if this were True, it would be bad
07:21:31 <ray> that's all i'm saying!
07:21:40 <soupdragon> why
07:22:04 <truthair> How do I print elements in a list one by one? The obvious idea in my mind is mapping my print function on the list, but since that returns an error I'm assuming that's not gonna work...
07:22:17 * ski also wonders why ..
07:22:19 <ray> well, for one, because == should be strict in at least one argument if it claims to compare values
07:22:22 <Lemmih> truthair: mapM_ print list.
07:22:30 <jmcarthur> ray: it wouldn't be bad, it would just not be haskell
07:22:34 <ray> for another, because () and _|_ are not the same
07:22:38 <ski> (.. i'm however not claiming that you are right or wrong .. just wondering about your argument)
07:22:59 <ray> it is a valid == that would compile, but it is a wrong ==
07:23:09 <ray> it doesn't compare anything
07:23:19 <ski> ray : why should `(==)' be strict in at least one argument ?
07:23:31 <ski> also, what about `Void'
07:23:43 <ray> _ == _ = undefined
07:24:30 <truthair> Lemmih: Right, thanks
07:24:33 <ray> == for Void can be non-strict
07:24:47 <ski> hm
07:24:50 <ray> because it's the same as if it were strict :)
07:24:52 <jmcarthur> ray: http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious/
07:25:07 <ski> i'd say for `Void', `(==)' should be
07:25:08 <jmcarthur> i am one of those who conal was criticizing in that post, and i have come to agree with what he says
07:25:15 <ski>   v0 == v1 = case v0 of {}
07:25:15 <ray> are you trying to call me a stick in the mud?!
07:25:21 <ski> .. only that seems assymetric
07:25:26 <ski> hm
07:25:35 <jmcarthur> ray: who me?
07:26:08 <jmcarthur> ray: it's relevant because it is over exactly this topic
07:26:45 <ski>   v0 == v1 = case (# v0 , v1 #) of {}  -- this doesn't seem right, either :/
07:26:57 <ski> (or is it ?)
07:27:06 <ray> hmm
07:28:16 <ray> it's probably right
07:28:44 <ray> i say ... = undefined, but i don't mean it's actually undefined, i mean it's defined but _|_
07:28:46 <Saizan> how do you write it in adga?
07:28:55 <ray> it's just a quick way to denote _|_
07:29:35 <jpcooper> what happens if two threads try to simultaneously print to a thread?
07:29:39 <jpcooper> sorry, a handle
07:30:01 <jmcarthur> ray: the thread in question, in case you haven't looked it up yet http://www.mail-archive.com/haskell-cafe@haskell.org/msg52400.html
07:30:05 <jpcooper> what I really want to know is whether hPutStrLns can be mixed together
07:30:29 <jmcarthur> i do think it's interesting to consider both sides
07:30:33 <ski> imo there's at least two options : (a) `()' is an inductive type, so `() == () = True' is the correct definition; (b) `()' is a coinductive type, so efffectively `~() == ~() = True' is the correct definition
07:30:42 <ski> s/fff/ff/
07:31:00 <vegai> jpcooper: you could try it out, couldn't ya...
07:31:06 <|zzz|> hi i can't figure out with this function: http://pastebin.com/m17117919
07:31:08 <jpcooper> I could
07:31:19 <ski> (similar arguments can be made for other tuple types)
07:31:33 <vegai> jpcooper: I suppose you should get an arbitrarily interleaved output
07:31:41 <jmcarthur> @src second (->)
07:31:41 <lambdabot> Source not found. My brain just exploded
07:31:46 <jmcarthur> @src (->) second
07:31:47 <lambdabot> second f = id *** f
07:31:58 <jmcarthur> bleh, nevermind
07:32:15 <Saizan> jpcooper: it may depend on the buffering settings on that handle
07:32:16 <jmcarthur> @src (->) (***)
07:32:17 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
07:32:20 <Taejo> |zzz|: what are you trying to figure out about it?
07:32:26 <|zzz|> what's wrong with it
07:32:27 <jmcarthur> is the lazy pattern match bad?
07:32:30 <jpcooper> line buffering
07:32:36 <jpcooper> I'll just use mvars for safety
07:32:43 <ray> ski: maybe you need a different one for each :(
07:32:52 <|zzz|> Cannot justify constraints in explicitly typed binding
07:33:02 <Axman6> :S
07:33:05 <ski> ray : a different what for what ?
07:33:05 <Axman6> looks fine to me
07:33:08 <Lemmih> |zzz|: The type signature is wrong.
07:33:13 * ski might be a little slow today
07:33:18 <Saizan> jpcooper: sometimes it's nicer to have a single thread really writing on the handle, and the other threads send messages to that via a Chan
07:33:21 <Taejo> |zzz|: ah, yeah, you need to add an Eq constraint
07:33:23 <Axman6> oh yeah, needs an Eq constraint doesn't it
07:33:31 <EvilTerran> for the (==x), yeah
07:33:32 <Lemmih> |zzz|: It can't really take a list of everything. It can only take a list of objects that can be compared.
07:33:34 <jpcooper> okay
07:33:40 <|zzz|> it's supposed to be for #9 of 99 haskell problems
07:33:42 <Taejo> |zzz|: pack :: Eq a => [a] -> [[a]]
07:33:45 <Axman6> |zzz|: pack :: Eq a => [a] -> [[a]]
07:33:48 <Axman6> bah
07:33:52 <|zzz|> oic
07:33:52 <ray> ski: maybe it makes sense to treat it both ways, i mean
07:34:03 <ski> jmcarthur : yes, the `~' there suggests that (something like) a coinductive type is what is wanted there ..
07:34:18 <ski> ray : i'm not sure what "it" is
07:34:22 <jmcarthur> so coinductive types are bad?
07:34:24 <ray> the type ()
07:34:25 <Taejo> which means pack works on any type 'a', as long as it's a member of the class Eq (i.e., (==) is defined for that type)
07:34:30 <ski> jmcarthur : who says ?
07:34:35 <|zzz|> thanks it works now
07:34:51 <EvilTerran> |zzz|, although this does look suspiciously like the function in Data.List called "group"
07:35:02 <|zzz|> i know
07:35:05 <jmcarthur> ski: the question i asked was whether that example was bad, to which you replied: yes, because it's coinductive-like
07:35:06 <EvilTerran> > group "aaaaaabbbabc"
07:35:07 <lambdabot>   ["aaaaaa","bbb","a","b","c"]
07:35:08 <|zzz|> http://www.haskell.org/haskellwiki/99_questions/1_to_10
07:35:26 <jmcarthur> err, whether that was an example of something bad, that is
07:35:52 <ski> jmcarthur : oh, sorry, i missed your question .. i think that in many cases, we definitely want the lazy pattern match there (.. or at least the semantics of it)
07:35:59 <EvilTerran> |zzz|, ah, you're meant to reimplement it. i see, well, that looks good then :)
07:36:08 <jmcarthur> ski: i agree, i was really looking for ray's opinion
07:36:23 <jmcarthur> but i see now that he favors different types for inductive and coinductive
07:36:42 <jmcarthur> which i think would be a reasonable solution for disambiguating this
07:37:14 <ray> i can't see it, it's buried under a lot of text
07:37:28 <Geheimdienst> beelsebob: i added a new repo + key and upgraded and now it works. (i hate ubuntu and their ancient packages policy ...) thanks, man
07:37:38 <ray> but yeah, it seems like different types to me
07:37:46 <ski> ray : it might be nice if there was a type like `(a,b)' where a match against `(<p0>,<p1>)' wouldn't "force" the pair .. basically `foo (<p0>,<p1>) = ...' would have the current semantics of `foo p = ... where <p0> = fst p; <p1> = snd p' (except that match failures would still drop into the next equation)
07:38:43 <jmcarthur> how would it fall through without forcing it?
07:38:50 <ski> i.e. like `foo ~(<p0>,<p1>) = ...' except any matches with constructors inside `<p0>' and `<p1>' would not be delayed
07:38:57 <jmcarthur> you mean it doesn't force it if the choice is unambiguous, right?
07:39:04 <ski>   foo (x,y) = ()
07:39:08 <jmcarthur> wrong word
07:39:10 <ski> would not force the input
07:39:20 <ray> ski: a syntax i'd like is something the same but with different bracket characters instead of parens
07:39:20 <ski>   foo (x,Nothing) = ()
07:39:25 <ski> would force the input
07:39:30 <jmcarthur> *you mean it doesn't force it if there is only one choice, right?
07:39:30 <ray> i think all the bracket characters are clobbered though
07:40:04 <ski> i.e. instead of thinking of pairs as an inductive type defined by `data (a,b) = (a,b)'
07:40:25 <ski> we think of it as a coinductive type defined by `codata (a,b) = fst :: a & snd :: b'
07:40:52 <jmcarthur> ray: yeah, probably an infix notation would be the clearest way that is not clobbered already
07:41:10 <ski> with expression `(<e0>,<e1>)' as syntactic sugar for `let fst p = <e0>; snd p = <e1> in p'
07:41:22 <ski> (s/p/this/, if you prefer)
07:42:05 <ski> ray : ok .. i was only talking about semantics here, though (and maybe abstract syntax .. not concrete syntax anyway)
07:42:49 <ray> well, i don't have anything against the coinductive version, i just think regular haskell tuples aren't it
07:42:54 <ray> even if that's arbitrary
07:42:57 <ski> ray,jmcarthur : and yes, i would opt for different types if we find we want both kinds of behaviours often enough
07:43:22 <ski> (and i suspect we will find that)
07:45:03 <ski> jmcarthur : i mean it only forces when it matches on a *constructor* .. and `(,)' would not be a constructor under this regime
07:46:07 <Geheimdienst> guys, i have a newbie problem: 2 lines of code work when i have them in main, but when i stick them in another function, the exact same lines fail
07:46:12 <Geheimdienst> i'm stumped
07:46:23 <ski> @paste
07:46:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:46:26 <Geheimdienst> here's the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7819#a7819
07:46:43 <Geheimdienst> yes, already pastebinned it :-)
07:47:11 <ski> you need to do
07:47:21 <ray> you can't putStrLn an IO whatever
07:47:23 <ski>   main = do
07:47:28 <ski>       x <- f
07:47:34 <ski>       putStrLn x
07:47:44 <ski>   f = do
07:47:50 <ski>       state <- ...
07:47:58 <ski>        let ...
07:48:01 <benmachine> <- isn't assignment
07:48:05 <ski>       return result
07:48:11 <ski> (s/ let/let/)
07:48:20 <benmachine> i.e. foo <- bar doesn't make foo = bar
07:48:46 <ski> Geheimdienst : i.e. `f' is an *action* that *when*run* (by `x <- f') returns `result' (into `x' here)
07:48:54 <Geheimdienst> benmachine: i understand what <- does is "unpack" an IO (something)
07:49:02 <ski> and you need to use `return result' inside `f' to "return" it
07:49:39 <mike-burns> :t forceEither
07:49:42 <lambdabot> Not in scope: `forceEither'
07:50:03 <Geheimdienst> wohoo, it works :-)
07:50:05 <Geheimdienst> thanks guys
07:50:39 <ski> (what `return result' does is create an "empty" `IO'-action that does nothing at all except yield value `result' .. and the result of the last action in a `do'-block becomes the result of the whole `do'-block, whenever it is run)
07:50:42 <Geheimdienst> mike-burns: that
07:50:49 <Geheimdienst> 's from missingH
07:50:54 <mike-burns> Ah.
07:53:41 <ski> *sigh* concrete syntax
07:53:57 <soupdragon> whats the best progamming language
07:54:29 <araujo> Haskell
07:54:38 <ski> Contagion
07:54:38 <mike-burns> The one that pays the most.
07:54:59 <ray> imaginary haskell freed of every flaww
07:54:59 <penguin-power> Malbolge
07:55:01 <ray> flaw
07:55:39 <Geheimdienst> and, are you okay with that code stylistically? i'm wondering about the double forceEither and so on ... it looks a little ugly to me
07:55:39 <penguin-power> ironic typo
07:55:59 <ski> Geheimdienst> :t forceEither
07:56:37 <mike-burns> forceEither :: (Show e) => Either e a -> a
07:56:51 <ski> it uses `error' ?
07:57:17 <mike-burns> :t readfile
07:57:18 <lambdabot> Not in scope: `readfile'
07:57:28 <ski> @type readFile
07:57:30 <lambdabot> FilePath -> IO String
07:57:43 <Geheimdienst> readfile is from import Data.ConfigFile
07:57:45 <ski> .. oh
07:57:54 <mike-burns> readfile :: MonadError CPError m => ConfigParser -> FilePath -> IO (m ConfigParser)
07:58:02 <Geheimdienst> ski: i don't know, i got this from the docs on Data.ConfigFile
07:58:18 <Geheimdienst> i cobbled this together from example code
07:59:05 <mike-burns> get :: MonadError CPError m => ConfigParser -> SectionSpec -> OptionSpec -> m a
08:02:01 <ski>   forceEither (state >>= \s -> get s "" "charging state")
08:02:14 <ski> maybe somewhat better
08:03:30 <ray> lol
08:03:57 <ray> ski, you're named after the combinators and not the winter sport, right?
08:04:56 <Geheimdienst> whoa, how did you do that?
08:05:06 <ski> (obviously it would be nicer here if the first argument of `get' was the last one .. but maybe the last one really usually varies most)
08:05:09 <Geheimdienst> the >>= does the job of the second forceeither?
08:05:19 <ski> ray : yessir
08:05:20 <mike-burns> :t (>>=)
08:05:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:05:43 <mike-burns>  >>= is what `do' expands to.
08:05:48 <ski> Geheimdienst : no, it will merge the two `Either's into one, so that you only need one `forceEither'
08:06:48 <mike-burns> Geheimdienst: It sounds like you should skim through a monad tutorial.
08:07:05 <ray> :t join
08:07:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:08:38 <Geheimdienst> mike-burns: absolutely right. i've looked at a few, but monads havent "clicked" for me yet
08:09:27 <mike-burns> Geheimdienst: The core thing to understand is that there are two very important functions (yes, there are more): `return' and `>>='.
08:09:29 <mike-burns> :t return
08:09:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:09:32 <mike-burns> :t (>>=)
08:09:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:09:56 <mike-burns> Geheimdienst: And `do' notation is just syntax over `return' and `>>='
08:10:32 <mike-burns> @undo do { x <- readfile; return x }
08:10:32 <lambdabot> readfile >>= \ x -> return x
08:10:43 <mike-burns> Like that.
08:10:44 <ray> the elavater with only 2 butins, return and >>=, which one do you push
08:10:52 <ski> (actually not over `return')
08:10:56 <Baughn> Geheimdienst: The second core thing to understand is that that's pretty much all there is to understand about monads. They aren't "computations". They /are/ containers, mind you.
08:11:12 <Baughn> Geheimdienst: Everything else happens for a particular monad, not all of them
08:11:54 * ski thinks monads describe "computations"
08:12:05 <ray> in particular, IO has a lot of its own weirdness, but IO is an outlier among monads, not a typical one
08:12:16 <Geheimdienst> hm, okay
08:12:33 <ski> .. but i then i think `[]',`Expression' and `Parser' are notions of computation :)
08:12:36 <BONUS> i think "computations" is really vague a term, i'd say monadic values are values with some more context
08:12:36 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
08:12:37 <Baughn> ski: Does a Functor describe a computation?
08:12:49 <Baughn> ski: How about an applicative?
08:12:50 <ski> not every functor is a monad
08:12:54 <Baughn> No
08:13:07 <Baughn> But I can't see how the addition of "join" suddenly makes a container into a computation
08:13:11 <ski> for applicative functors, i'm not sure
08:13:14 <Geheimdienst> if i need 2 monads simultaneously, is there a clean way for that or does it get messy?
08:13:21 <ray> monad transformers
08:13:21 <Geheimdienst> because i was wondering about this here:
08:13:22 <Baughn> Geheimdienst: Monad transformers
08:13:23 <Geheimdienst> http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html#12
08:13:33 <ray> you apply a monad transformer to a monad, and you get a combined monad
08:13:47 <Geheimdienst> he's muddling with the IO moand and Error monad (which is an Either)
08:14:01 <Gertm> does realworldhaskell explain monads properly?
08:14:07 <Geheimdienst> to me that looks just like a huge mess, compared to (say) the equivalent python code
08:14:11 <ray> ErrorT IO
08:14:15 <ski> Baughn : basically my definition of "computation" is "any monad", except i'm open to the possibility of there being non-monadic notions of computation
08:14:29 <pejo> Gertm, the book is available online, so you can check if you're happy with it before purchasing.
08:14:42 <ski> (and when i say "computation" here, i don't mean as in "computability")
08:14:42 <mike-burns> Gertm: Nothing explains monads properly.
08:14:56 <Baughn> ski: Hm. We might just have different notions of "computation"
08:14:57 <Gertm> pejo: I was asking if the explanation of monads in the book was any good before reading it :)
08:15:26 <kublar> explaining monads is pointless
08:15:28 <ray> warning: you may already understand monads!
08:15:35 <Baughn> ski: The only special thing about monads is join, which just allows the code using them to tie knots in their structure..
08:15:49 <mike-burns> Gertm: The issue with explaining monads is that it's a very easy concept with a frightening name and a lot of hype, and by even explaining it you're playing up to the hype.
08:15:55 <Baughn> ski: Still, if computation comes in anywhere, it has to be ap, eg. in applicative functors.
08:16:02 <soupdragon> Baughn: synergy of {fmap, join, return}
08:16:13 <Baughn> soupdragon: ..don't forget ap
08:16:18 <Gertm> mike-burns: so how did you learn to grok them?
08:16:23 <soupdragon> I didn't want to put ap in there
08:16:26 <ray> join gives you ap for free
08:16:34 <ski> Baughn : but yes, it's all rather vague .. i just find it useful (and fun) to regard anything which allows a `do'-like syntax (or even side-effectful syntax, as in imperative languages) as a notion of computation
08:16:39 <mike-burns> Gertm: I read the types for (>>=) and `return' and just use them like normal functions.
08:16:47 <Baughn> ray: Sort of, but monad is a subclass of applicative, so..
08:16:54 <Gertm> mike-burns: I'll keep that in mind thanks
08:17:26 <ray> i prefer having both applicative and monad subclasses of pointed
08:17:34 <ray> it can really go either way
08:18:07 <ski> Baughn : `ap' allows side-effectful application. `join'/`(>>=)' allows side-effectful local computation
08:18:45 <Baughn> ski: What's the difference between application and computation?
08:19:50 <ski> by "application" here i mean the syntactic construct of applying a function (expression) to an argument (expression)
08:20:50 <ski> there is something a bit similar to the CPS translation, which translates expressions from a side-effectful language into a pure language with monads
08:21:43 <ski> more accurately : if we want to translate from (side-effectful) expressions, then the target language needs `ap'
08:22:24 <ski> if we want to translate from (side-effectful) local computation (i.e. basically `let <x> = <e0> in <e1>'), then we need `join' or `(>>=)'
08:22:36 <ski> (assuming we already have `fmap' in the `join' case)
08:23:05 <Berengal> I might be completely wrong, but I don't think applicative is enough for turing completeness
08:23:35 <soupdragon> turing completeness doesn't matter
08:23:59 <ray> tarpit completeness
08:24:16 <Berengal> Yes it does. If you have a monad you can do anything, not so for applicatives
08:24:22 <ski> (note that i've said that the "notion of computation" i'm talking about here doesn't really have anything to do with computability theory)
08:25:00 <ski> i.e. i would consider monads over other interesting categories in math to be "notions of computation" in this generalized sense
08:25:00 <Berengal> The difference between applicatives and monads is that applicative computations are fixed
08:25:21 <ski> .. maybe it is that this is not that good terminology .. but i'm not sure what would be better
08:25:27 <dschoepe> Berengal: Well, aren't pure functions already turing complete, therefore applicatives are too?
08:25:55 <Berengal> dschoepe: pure functions are also monads
08:26:11 <soupdragon> -_-
08:26:20 <soupdragon> this is why I say "turing completeness doesn't matter"
08:27:11 <EvilTerran> turing-completeness may be a helpful concept in this context
08:27:24 <ski> (as for the difference between application and computation : they are not comparable)
08:27:33 <EvilTerran> but it'd need a clever definition of "input" and "output
08:27:52 <EvilTerran> (perhaps considering the sequence of "side-effects" to be output, say)
08:27:55 <Berengal> soupdragon: If you were given ZipLists and a few pure functions without the ability to define new ones, turing completeness becomes relevant again
08:28:03 <soupdragon> no it doesn't
08:28:10 <Berengal> The thing is, since pure functions are monads, it's hard to restrict yourself to an applicative subset
08:28:18 <Saizan> it is true that the monad interface is more expressive than the applicative one, i'm not sure if you can put this in terms of turing-completeness without fixing a particular instance for the class though
08:28:44 <vav> Gertm: RWH monad discussion is nice in that you use them in several ways before looking at what they are and how they work, but on the other hand that spreads the discussion over many chapters. Not like the focused compressed definition based explanations. Depends how you like to learn.
08:28:57 <hackagebot> derive 2.0.0 - A program and library to derive instances for data types (NeilMitchell)
08:29:04 <Baughn> The ap implementation is just a pure function, so it certainly can do turing-complete computations if it feels like it
08:29:28 <EvilTerran> i see the distinction as "in a monadic computation, the sequence of future side-effects can be dependent on the results of past side-effects"
08:29:29 <Modius> I have the RB-tree functional insert code from Okasaki's book.  Does anyone have code for the deletion case?
08:29:34 * ski is not sure what we're discussing atm
08:29:36 <EvilTerran> (and, in an Applicative, this is not the case)
08:29:57 <EvilTerran> (using "side-effects" as an intuitive term)
08:30:11 <ski> yes
08:30:12 <Baughn> Modius: http://hackage.haskell.org/package/EdisonCore <-- THis?
08:30:17 <Baughn> Modius: Note the author.
08:30:33 <ski> (e.g. angelic non-determinism as in `[]' is a side-effect)
08:30:41 <Berengal> EvilTerran: Not just the sequence, but which effects are applied as well, but that's nitpicking...
08:31:01 <Modius> Braughn:  What do I do to see the actual code?
08:31:02 <ski> (s/side-// i should say .. *sigh*)
08:31:40 <Modius> Braughn:  And by terminology, which one of these is the RB tree?
08:31:57 <Saizan> ski: btw, do you have a reference for that transformation from side-effecting expressions to monads you mentioned above?
08:32:52 <Baughn> Modius: THere's a "source" link inside each module.
08:33:01 <Baughn> Modius: ..well, one per function
08:33:06 <Saizan> there's also a link to the tarball
08:33:10 <EvilTerran> Berengal, that's what i mean by "the sequence of effects"
08:33:12 <Saizan> http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1.3/EdisonCore-1.2.1.3.tar.gz
08:33:12 <Modius> Which one is the RB tree?
08:34:12 <EvilTerran> as in, in Applicative, the matter of which effects are included in the sequence is independent of the results of other effects
08:34:19 <ski> Saizan : not off the top of my head .. but i think possibly one can find one by searching for "monadic style" or maybe "A-normal form"
08:34:43 <Modius> Can anyone tell me which Edison container has the most pure representation of the RB tree?
08:35:19 <ski> A New One-Pass Transformation into Monadic Normal Form <http://www.springerlink.com/index/5Q1RPDB365UPAVNJ.pdf>
08:35:44 <ski> Saizan : ^ that looks like it might at least be on topic .. (haven't read it)
08:36:27 <Saizan> ski: thanks
08:38:29 <MachinShin> http://www.sdtimes.com/blog/post/2009/07/27/Everyonee28099s-talking-about-Haskell.aspx  <== sentence #2, lambda calculus == reliable programs? wtf?
08:40:14 <ppavelV6> "A New One-Pass Transformation into Monadic Normal Form" for $25? nice....
08:40:15 <Geheimdienst> machinshin: maybe that's supposed to mean that pure (side-effect-free) functions are easier to reason about?
08:40:20 <soupdragon> probably someone clueless trying to dumb it down
08:40:24 <Geheimdienst> or something like that
08:40:47 <Berengal> The article looks somewhat dumbed down, yeah
08:43:06 <ski> A New One-Pass Transformation into Monadic Normal Form <http://www.brics.dk/RS/02/52/BRICS-RS-02-52.ps.gz>
08:43:28 <ski> ppavelV6 : .. oh .. bah!
08:44:03 <ski> Saizan : ^ in case you didn't find that yet yourself
08:46:34 <MachinShin> Geheimdienst: i suppose that's possible, but the article isn't (appearing to) claim abour purity, but the lambda calculus.. you might be right about it being dumbed down, which i find offensive in an mag for 'software developers
08:47:12 <mike-burns> Software developers can be dumb too.
08:47:55 <truthair> s/can be/often are/
08:47:59 <vegai> I'm afraid I could be the only one in our company who knows lambda calculus
08:48:14 <mike-burns> s/often are/are/
08:48:20 <mike-burns> We're just people, really.
08:48:21 <vegai> and perhaps in a small group of people who have ever heard of it
08:49:13 <Berengal> I'm surprised at how little some of my fellow programers really know. One of them asked me "when an exception is thrown, why doesn't the rest of the code run?"
08:49:47 <mike-burns> I'm going to step up and say that it's not fair to laugh at people who don't know things that we know.
08:50:31 <Berengal> mike-burns: Is it fair to laugh at people who don't know things about what they should know?
08:50:49 <mike-burns> Just teach them without laughing.
08:51:03 <Berengal> ... I do that, but I laugh on the inside ...
08:51:04 <soupdragon> mike who is laughing
08:51:29 <vegai> I'm not laughing either
08:51:36 <vegai> nor being sarcastically sad or anything
08:51:52 <vegai> also, I could be totally wrong
08:52:02 <vegai> lambda calculus never pops up in daily work, after all
08:52:59 <truthair> Most of my fellow students pretend lambda calculus is a bad dream
08:53:22 <vegai> I learned it because I had to teach it :P
08:53:54 <ray> i pretend industry programming is a bad dream
08:54:02 <truthair> Introduction to Theoretical Computer Science is mandatory in second year here, so I had to :p
08:54:04 <Berengal> lambda calculus is horrible, but given a little bit of sugar and it turns into a pretty nice language
08:54:04 <pikhq> I learned it because I am found of esoteric programming languages.
08:54:21 <ray> why would anyone ever get a job in such a soul crushing field
08:54:29 <pikhq> Berengal: Basically, it's horrible straight. Quite nice to build off of.
08:54:35 <vegai> ray: to get money
08:54:41 * ski learned it because it seemed fun :)
08:54:49 <vegai> besides, I found that I get much more done in the industry
08:54:50 <mike-burns> ray: Not all industry programming is Java.
08:54:52 <pikhq> ski: And it is fun. :)
08:54:53 <michaelfeathers> Silly question, but if I have the same expression twice in a function, I expect that the second evaluation will be optimized away but does the same thing happen when the duplication is across functions (say one bit is in funct a and the other is in funct b which is called by a)?
08:55:01 <ray> you are probably better off selling your soul directly to the devil
08:55:07 <ray> cut out the middleman
08:55:09 <Berengal> pikhq: Indeed. Even just let bindings makes it rather nifty
08:55:13 <Axman6> i've got some friends doing a course with lambda calculus. i see them doing a lot of things like (\x -> x x x) (\x -> x x x) and having things die
08:55:51 <pikhq> Axman6: Well, duh. That's screwy code.
08:55:52 <truthair> Axman6: Don't remind me of the classes implementing booleans in lambda calculus...
08:56:20 <ski> michaelfeathers : i think generally you can't expect CSE in all cases, even within a single defining equation
08:56:24 <Berengal> michaelfeathers: short answer: no (and it won't always happen in the same function either
08:56:50 <mike-burns> ray: That's an overly bleak view of "the industry". It may be that your idea of the industry is different from mine, but my years in it have been rewarding, challenging, and fun.
08:56:53 <Axman6> pikhq: yes, but the thing they were using was expanding it nontheless
08:57:01 <pikhq> michaelfeathers: I think so, but don't expect it to -- you're not supposed to be predicting the behavior of the optimising pass. ;)
08:57:19 <ray> my years as a bum have been rewarding, challenging and fun :)
08:57:34 <mike-burns> I don't doubt that.
08:57:47 <pikhq> mike-burns: The industry gave us C, C++, and Java. Any further questions?
08:57:50 <michaelfeathers> ski, Berengal: that's a shame.. In the same function it seems like such an easy optimization..  When I read about normal evaluation years ago it seem to imply that that's just the way things happen.
08:57:51 * ray gets hit by a night train
08:58:09 <ski> michaelfeathers : in some cases you don't want the extra sharing
08:58:25 <michaelfeathers> ski: If it's pure code, why not?
08:58:29 <Berengal> michaelfeathers: Who knows what the compiler does? But basically, if you want two values to be the same, give them the same name
08:58:33 <athos> @src fix
08:58:34 <lambdabot> fix f = let x = f x in x
08:58:41 <vegai> pikhq: erlang?
08:59:07 <athos> fix f = f (fix f), so fix is basically the y combinator?
08:59:07 <mike-burns> pikhq: The non-industry gave us XFree86, Perl, and YAML. So what?
08:59:08 <Berengal> michaelfeathers: And by same name I mean put it in a let/where
08:59:10 <ski> michaelfeathers : it can cause values to be held onto longer than necessary .. aka space leaks
08:59:21 <pikhq> vegai: Eeeeew.
08:59:26 <michaelfeathers> Berengal: If the code is the same the values will be the same.  The only question is whether the runtime has to do the same work twice.
08:59:49 <ray> athos: it's a fixed point combinator
08:59:52 <ray> and so is Y
08:59:53 <pikhq> mike-burns: We're at least not proud of such sins. :P
08:59:56 <michaelfeathers> ski: Ah, k.
08:59:57 <ray> but i don't think they are considered the same
09:00:17 <Berengal> michaelfeathers: Sometimes it's better to just store a thunk than the evaluated value
09:00:19 <athos> ray: well, Y's definition in a lazy evaluating language is Y f = f (Y f)
09:00:22 <athos> isn't it?
09:00:30 <mike-burns> pikhq: Nor is the industry proud of C++, etc. But like I suggested above, we may mean different things when we say "the industry".
09:00:31 <Berengal> If you want sharing, make it explicit by using lets
09:00:47 <ski> there's a Turing fixed-point, and an Ackerman fixed-point, iirc
09:00:49 <ray> athos: i think Y is the strict fixed-point combinator
09:00:58 <ski> those being specific implementations
09:00:58 <athos> oh ok
09:01:28 <pikhq> ray: It's the same combinator.
09:02:19 <ski> pikhq : didn't GLS give us Java ?
09:02:41 <ray> if google labs had given us java, google would be exposed for the great satan that it is
09:04:18 <bos> michaelfeathers: in a lazy language, common subexpression elimination is not a safe optimisation
09:06:09 <michaelfeathers> bos: Ah, k, I see that now.
09:07:02 <bos> michaelfeathers: in addition, code that actually benefits from CSE is surprisingly rare in haskell in-the-wild.
09:08:30 <michaelfeathers> bos: That's no coincidence, I bet.
09:10:01 <michaelfeathers> It is weird, though.  I remember reading about graph reduction in Rabhi and Lapalme's 'Algorithms' book where they talk about efficiency.
09:11:39 <michaelfeathers> Ah.. found it:  double (5 * 4) => add (5 * 4) (5 * 4) =>  (5*4) + (5*4) => 20 + 20 => 40
09:12:11 <ski> yes, but that happens in GHC, too
09:12:16 <michaelfeathers> They seemed to imply that it was more than just a semantic for understanding evaluation.
09:12:34 <ski> (barring some other optimization which might decide not to do that)
09:12:56 <ski> (s/some/possibly some/)
09:13:25 <ski>     double (5 * 4)
09:13:57 <ski>   = let x = 5 * 4 in double x
09:13:59 <EvilTerran> michaelfeathers, when you pass "5*4" to "double", you give it a name, though
09:14:04 <ski>   = let x = 5 * 4 in add x x
09:14:11 <ski>   = let x = 5 * 4 in x + x
09:14:19 <ski>   = let x = 20 in 20 + x
09:14:25 <ski>   = 20 + 20
09:14:28 <ski>   = 40
09:14:30 <EvilTerran> (the local name of double's parameter)
09:14:37 <ski> assuming
09:14:43 <ski>   double x = add x x
09:15:26 <ski> even in cases like
09:15:29 <benmachine> if a function is given constant parameters, is it (could it be) evaluated at compile time?
09:15:29 <michaelfeathers> EvilTerran: so you're saying that it is pretty much only guaranteed because there was a common name (in this case provided by the runtime)?
09:15:31 <ski>   foo (x,y) = ...
09:15:37 <tingi> in a bipartite graph, i find the maximum matching , how do i find the minimum vertex cover ?
09:16:05 <ski> if you say `foo <expr>', then effectively `<expr>' is "given a name", i.e. it is cached against the match to `(x,y)'
09:16:08 <EvilTerran> michaelfeathers, well, under most circumstances, you can assume that things will share memory in haskell iff the same name is used
09:16:44 <EvilTerran> michaelfeathers, the name would be provided by whoever wrote the definition of "double"
09:17:02 <ski> > fix (\xs -> 1 : map (2*) xs)  -- benmachine ?
09:17:03 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:18:04 <jeff_s_> :t fix
09:18:06 <lambdabot> forall a. (a -> a) -> a
09:18:11 <benmachine> ski: hm, fair enough
09:18:19 <michaelfeathers> EvilTerrans:  The thing is: double (5 + 4) is not really a name, it is an expression.
09:19:04 <ski> michaelfeathers : but when `5 * 4' is recieved at the other end of `double', it is effectively "given a name"
09:20:05 <ski> ("effectively" since as the `foo (x,y) = ...' example shows, it needn't actually be a name even in the source on the other end)
09:20:44 <michaelfeathers> ski:  so you're saying then that all bets are off in code like this because they could be (possibly different names):  h (f (5+6) + g (5 + 6))
09:20:51 <ski> if you want, you can think of it as function argument automatically being cached (within a single call / activition)
09:21:34 <ski> (and think of `let <x0> = <e0> in <e1>' as being syntactic sugar for `(\<x0> -> <e1>) <e0>' .. which isn't completely true)
09:22:02 <ski> michaelfeathers : yes, even in code like `h (f (5+6) + f (5+6))'
09:22:47 <michaelfeathers> ski: thx.
09:23:01 <ski> if you want to ensure sharing, then the best bet is `let x = 5 + 6 in h (f x + f x)'
09:23:09 <hackagebot> hlint 1.6.5 - Source code suggestions (NeilMitchell)
09:23:48 <ski> (i can't think of any reason why a Haskell implementation would not give you the effect of sharing in that case .. there might still be some i can't think of, though)
09:24:26 <EvilTerran> there may exist, at some point, some kind of heuristic optimiser that would decide not to "cache"
09:25:30 <EvilTerran> but, if you're using one of those, you're probably best to forget about hand-optimisation :P
09:26:02 <ski> yes .. e.g. it might "unshare", and then unfold one of the expressions, simplifying it that way (possibly still sharing parts of the expression)
09:26:04 <michaelfeathers> Funny... I thought one of the points of being side-effect free was that this sort of optimization would be easier to detect and act upon.
09:26:13 <ski> (but that wasn't what i was talking about)
09:27:20 <pikhq> michaelfeathers: Actually, one of the major points of being free of side effects is that it makes programming easier.
09:27:24 <pikhq> ;)
09:28:15 <ski> turning `let x = <e0> : <e1> in f (g x) (h x)' into `let y = <e0>; z = <e1> in f (g (y : z)) (h z)' maybe
09:29:38 <ski> (er, s/h z/h2 z/)
09:30:30 <ski> (both the fact that `x' is a cons and that `h (_ : z) = h2 z' possibly dependent on previous program specialization)
09:31:50 <Baughn> michaelfeathers: FTR, GHC can't use CSE in the common case because it'd conflict with the GC
09:32:54 <Baughn> michaelfeathers: Eg. if you say "f [1..] [1..]", you'd think it could use the same [1..] value for both, right?
09:33:20 <stanv> what is mean: amalgamate [p] = p  I see such notation ([p] on left side) first time :(
09:33:49 <Baughn> michaelfeathers: But if f proceeds to construct five million list elements from the first list, discarding them as it goes, then CSE would turn that into a memory leak since the second parameter might be used later on, and would maintain a reference to the head of the list
09:33:56 <Botje> it's a pattern match
09:34:02 <mike-burns> stanv: A list with one element.
09:34:04 <ski> stanv : it means that whenever you call `amalgamate' on a list with exactly one element in it, then that element will be returned
09:34:33 <stanv> mike-burns: ski - thanks
09:34:42 <ski> > let amalgamate [p] = p; amalgamate _ = "fnord" in amalgamate ["foo"]
09:34:43 <lambdabot>   "foo"
09:34:46 <ski> > let amalgamate [p] = p; amalgamate _ = "fnord" in amalgamate ["foo","bar"]
09:34:47 <lambdabot>   "fnord"
09:34:55 <ski> > let amalgamate [p] = p; amalgamate _ = "fnord" in amalgamate (tail ["foo","bar"])
09:34:57 <lambdabot>   "bar"
09:37:42 <ski> stanv : you can also put `[p,q]' et.c. on left hand side, as well as `[[a,b],[c]]' if you like .. but not `[a,b] ++ c' or `a ++ [b,c]' (for the former, use `a:b:c' instead)
09:38:22 <stanv> [a,b,c] - any list with exactly three elements, right ?
09:38:28 <ski> yes
09:38:31 <stanv> ok
09:38:45 <ski> (the elements will be called `a',`b',`c' by that pattern)
09:39:13 <benmachine> > length [undefined]
09:39:15 <lambdabot>   1
09:39:17 <ski> `a0:a1:as' is any list with at least two elements ..
09:39:40 <ski> (the first two elements will be called `a0',`a1', the list of any possible more elements will be called `as')
09:39:43 <benmachine> you need to put the pattern in brackets though
09:39:49 <dubhrosa> newbie question here, hope someone can help out - I want to write a program that reads an integer from stdin, prints the average of all integers read so far, and repeats until 0 is entered, I guess I need to use the state monad but I'm struggling with getting the basic structure in place, any help appreciated
09:39:51 <benmachine> f (a0:a1:as)
09:40:23 <ski> (otherwise it would be the same as `(f a0):a1:as = ...' which is not what you want there)
09:40:59 <ski> dubhrosa : you don't really need the state monad
09:41:28 <ski> you can write a recursive action with the "current" sum and count as arguments
09:41:50 <ski> if you really want to, you can use the state monad, though
09:42:01 <benmachine> :t (/)
09:42:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:42:09 <michaelfeathers> Baughn: How is that a leak?  The second [1..] only needs to be held as long as the evaluation of f.  Afterward it can go away.
09:42:31 <Baughn> michaelfeathers: The evaluation of f can take an arbitrarily long time
09:42:31 <ski> michaelfeathers : the evaluation of `f' might last as long as a server is running, e.g.
09:42:49 <dubhrosa> thanks ski, I'm at the stage where I'd like to do it the way you suggest and then try implementing it with the state monad for practise
09:43:21 <michaelfeathers> ski: As a matter of semantics then, that is less 'a leak' and more 'holding a bit more memory than you would otherwise need.'
09:43:22 * SamB wonders why spybot's eggtimer keeps asking him about the *same* registry changes on every reboot ...
09:43:46 <ski> dubhrosa : have you implemented a function that computes the average of all elements in a given list, yet ?
09:44:11 <michaelfeathers> ski: Unless lazyiness is the bench-mark.  That's it, isn't it?
09:45:02 <SamB> michaelfeathers: Haskell programs don't leak the same way C programs do ;-)
09:45:10 <ski> michaelfeathers : afaik, this kind of situation is also included in the term "space leak" (at least in the context of lazy programming languages)
09:45:11 <SamB> that is, we use the term differently
09:45:21 <dubhrosa> yep, I'm reasonably proficient in writing pure functions, handling lists, maps, folds etc is fine, I guess what I'm looking for is the simplest possible example of using the state monad, the one in RWH is obfuscated by the random gen api
09:45:39 <SamB> because the GC takes care of 99% of the cases where a C program could leak ...
09:45:46 <ski> (hm .. probably i should have said "languages with GC" instead of "lazy programming languages" ..)
09:46:11 <SamB> that is, it takes care of the primary meaning of "leak" in the C world
09:46:12 <Cale> dubhrosa: I like the example of relabelling a binary tree with numbers from 1 up to the number of nodes, such that the inorder traversal will be [1..n]
09:46:17 <ski> dubhrosa : could you show a pure function for computing average of a list of numbers ?
09:46:37 <ski> Cale : you like it for showing off the state monad ?
09:46:41 <Cale> ski: yeah
09:47:01 <michaelfeathers> I'm not assuming the C world.  The def you are supplying seems a bit different from space leaks in other GCed langs.
09:47:04 <SamB> so instead of using leak to refer to losing references to memory without deallocating it, we use it to refer to keeping references to memory we really don't need any more
09:47:11 <SamB> or shouldn't need anymore
09:47:28 <Cale> It's annoying as a plain recursion, since you're forced to keep track of the remaining integers using lots of pairs
09:47:51 <ski> (one could do a CPS version too, i suppose)
09:48:00 <ski> (to avoid pairs, i mean)
09:48:32 <Cale> Well, it's not really the pairs in memory, but the syntactic overhead of threading the extra parameters
09:48:43 <ski> (yes, i know)
09:50:52 <ski> Cale : another fun variation of that is normalizing by subtracting the mean from every tree element
09:53:15 * ski wonders whether it would be nice to have a phantom type for the cases where you want to pass a type to a function, but not really any value
09:53:31 <ski> (like where we pass `undefined :: Foo' currently)
10:00:51 <dubhrosa> ski:  ave l = (fromIntegral(sum l)::Double) / (fromIntegral (length l) ::Double)
10:01:46 <benmachine> you could type-annotate the whole expression instead of each parameter
10:02:02 <benmachine> since / forces its parameters to be of the same type
10:02:20 <ski> yes, that's one way
10:02:31 <benmachine> (or the whole function, indeed)
10:02:43 <ski> you could let your `IO'-action collect numbers into a list, and then use something like that
10:03:23 <ski> or, you could rewrite `ave' to do what `sum' and `length' does itself, but in an accumulating style
10:03:44 <ski> and that would then be quite close to the accumulating style of writing the `IO'-action
10:04:14 <ski> dubhrosa : ok ?
10:05:36 <dubhrosa> ski: yeah, thanks, will take a look
10:29:04 <dubhrosa> ski, this is what I've come up with; it's so ugly that it can't be the right way to do this... calc l = putStrLn("avg:"++(show(ave l))) >> getLine >>= (\v -> (calc ((read(v)::Double):l)) >> return () )
10:29:55 <soupdragon> dubhrosa: There are places that you don't have to use ()
10:30:03 <soupdragon> for example:
10:30:05 <soupdragon> putStrLn("avg:"++(show(ave l))) >> ...
10:30:09 <soupdragon> you can write as
10:30:19 <soupdragon> putStrLn ("avg:"++ show (ave l)) >> ...
10:30:38 <soupdragon> also
10:30:39 <soupdragon> >>= (\v -> (calc ((read(v)::Double):l)) >> return () )
10:30:40 <soupdragon> as
10:30:41 <Beelsebob> I was thinking putStrLn . ("avg: " ++) . show . ave $ l
10:31:02 <soupdragon> >>=  \v -> calc ((read v::Double):l) >> return ()
10:31:03 <tingi> in a bipartite graph, when i find the minimum path cover, how do i find the minimum vertex set ?
10:31:27 <ray> haskell function application is just "f x"
10:31:36 <ray> not "f(x)"
10:31:58 <Beelsebob> dubhrosa: return () <* calc . (:l) . read=<< getLine <* putStrLn . ("avg: " ++) . show . ave $ l
10:31:59 <soupdragon> dubhrosa: once you have fixed that there is more you can do to make it readable too
10:32:01 <Beelsebob> that's what I get to
10:32:09 <dubhrosa> thanks, still getting used to precedence + have a tendency to bracket stuff "Just in case"
10:32:19 <Beelsebob> dubhrosa: having said that -- you appear to have no base case
10:32:39 <dubhrosa> main = calc []
10:32:40 <Beelsebob> and if you did, you appear to be getting further from it
10:32:42 <Beelsebob> not closer to it
10:32:44 <Beelsebob> (assuming the base case would involve the empty list)
10:32:56 <Beelsebob> dubhrosa: so this program is intended to run infinitely getting new lines?
10:33:09 <dubhrosa> yep, it's just an exercise
10:33:15 <Beelsebob> no need for the final return () then
10:33:23 <Beelsebob> calc . (:l) . read=<< getLine <* putStrLn . ("avg: " ++) . show . ave $ l
10:33:26 <ski> dubhrosa : you should probably use `do'-notation, here
10:33:26 <dubhrosa> yeah, that was my next question to you guys
10:33:45 * Beelsebob doesn't think this one needs do notation
10:33:52 <Beelsebob> calc l = calc . (:l) . read =<< getLine <* putStrLn . ("avg: " ++) . show . ave $ l -- works for me
10:34:11 <soupdragon> nobobdy but you can read that man
10:34:13 <ski> Beelsebob : no .. but i think it will be more readable that way
10:34:27 * Beelsebob finds that much more readable than do notation
10:34:31 <Beelsebob> it's much closer to idiomatic haskell
10:34:37 <soupdragon> no it's not
10:34:55 <pikhq> Idiomatic Haskell uses do notation quite often.
10:34:57 <Beelsebob> results flowing right to left down the chain of (.)s ($)s, (<$>)s, (=<<)s and (<=<)s
10:35:01 <dubhrosa> for the purpose of the exercise I was going to do both....
10:35:04 <pikhq> I don't actually see <* a lot. ;)
10:35:30 <dubhrosa> it's very helpful to see the code desugared for me
10:35:32 <ski> Beelsebob : in this case it would be more natural with a branched tree than a linear pipe-line, imo
10:35:48 <dubhrosa> Beelsebob, what does <* do?
10:35:58 <Beelsebob> dubhrosa: it's (*>) the other way round
10:35:59 <pikhq> Also,
10:36:05 <Cale> Beelsebob really likes the funny applicative operators :)
10:36:07 <Beelsebob> and (*>) is aka (>>)
10:36:26 <Beelsebob> <* is to =<< as >> is to >>=
10:36:30 <Cale> They can be good
10:36:39 <dubhrosa> cool, thanks
10:36:43 <pikhq> dubhrosa: Why do you use parens so much? It's not like this is Lisp. ;)
10:36:43 <soupdragon> << is to =<< as >> is to >>=
10:36:50 <Beelsebob> soupdragon: << doesn't exist
10:36:50 <pikhq> @src <*
10:36:50 <lambdabot> (<*) = liftA2 const
10:36:59 <pikhq> That's clear enough.
10:37:04 <soupdragon> @let (<<) = flip (>>)
10:37:04 <soupdragon> asr
10:37:05 <lambdabot>  Defined.
10:37:16 <Beelsebob> soupdragon: I don't like defining that in every single file I wrote
10:37:18 <Beelsebob> write*
10:37:24 <dubhrosa> pikhq: I promise I'm quitting...
10:37:24 <ski>   calc l = do
10:37:28 <ski>     putStrLn ("avg:" ++ show (ave l))
10:37:32 <ski>     n <- readIO :: IO Double
10:37:32 <ski>     calc (n:l)
10:37:39 <ski> dubhrosa : something like that
10:37:40 <Beelsebob> so I just use (<*) and (*>) everywhere
10:37:52 <Beelsebob> ah yeh, readIO
10:38:07 <Beelsebob> so calc . (:l) =<< readIO <* putStrLn . ("avg: " ++) . show . ave $ l
10:39:30 <ski> dubhrosa : naturally you need to add a conditional for when to stop, though
10:40:02 * Beelsebob guesses ^C
10:40:13 <dubhrosa> sure, thanks for the help
10:40:33 <ski> (Beelsebob : dubhrosa wanted to end when reading a zero ..)
10:40:42 <Beelsebob> oh did he?
10:41:11 <Beelsebob> so if' (==0) (return ()) (calc . (:l)) =<< readIO <* putStrLn . ("avg: " ++) . show . ave $ l
10:42:27 <ski> <dubhrosa> newbie question here, hope someone can help out - I want to write a program that reads an integer from stdin, prints the average of all integers read so far, and repeats until 0 is entered, I guess I need to use the state monad but I'm struggling with getting the basic structure in place, any help appreciated
10:42:27 <pikhq> Beelsebob: You have a very odd notion of what "idiomatic Haskell" (and "readable code") means. ;)
10:42:55 <Beelsebob> pikhq: personally, I find what people do with IO very odd â they seem to have a completely different way of writing code that involves IO to pure code
10:42:59 <Beelsebob> strange
10:43:30 <pikhq> Beelsebob: That's because it is significantly nicer-looking to just use do notation.
10:43:42 * Beelsebob doesn't agree
10:43:47 <ski> Beelsebob : yes, something like a reflective syntax could be nicer still .. in this case i prefer the `do'-version to the pointless one, though
10:43:49 <Beelsebob> it's nicer looking when you're working left to right and have to add lambdas everywhere
10:44:12 <pikhq> How the hell is that more readable than:
10:44:24 <soupdragon> with reflective syntax you must have specified evaluation order though, don't you?
10:44:47 <pikhq> do putStrLn ("avg:" ++ show (ave l)); n <- readIO :: IO Double; if n == 0 then return () else calc (n:l)
10:44:57 <ski> soupdragon : either that or use `let' in case of ambiguity
10:45:05 <soupdragon> pikhq, different people write differently
10:45:27 <soupdragon> what's bizarre is that some think everyone should do it their way
10:45:43 <Beelsebob> pikhq: the same reason as sort (x:xs) = sort (filter (<=x)) xs ++ sort (filter (>x) xs) is more readable than a block of C code doing things in sequence
10:45:48 <ski> (soupdragon : but the specified evalaution order of application follows directly from `ap' .. you could swap it easily with a `instance Applicative i => Applicative (Dual i)' ..)
10:45:53 <pikhq> soupdragon: I don't think everyone should do it my way. I think everyone should do it in a way that is readable.
10:45:55 <Beelsebob> soupdragon: indeed, that is odd
10:46:04 <Beelsebob> pikhq: exactly -- your way
10:46:07 <Beelsebob> because readability is subjective
10:46:22 <pikhq> Beelsebob: Inherently sequential code should be written that way.
10:46:50 <ski>   <calc l> = <<putStrLn ("avg:" ++ show (ave l))> `then` calc (:l)>
10:46:53 <ski> er
10:46:53 <Beelsebob> pikhq: I don't see this code as particularly inherantly sequential -- the only ordering that *must* be guarenteed is that getting the line must happen after putting the line
10:47:00 <Saizan> Beelsebob: most of the time when you're dealing with IO things _are_ done in a sequence though, the sequence is a big part of the semantic
10:47:04 <Beelsebob> but as we all know -- do is not meant to tell us about order
10:47:08 <ski>   <calc l> = <<putStrLn ("avg:" ++ show (ave l))> `then` calc ((<readIO> :: Double):l)>
10:47:10 <Beelsebob> so I see no reason why do is more readable
10:47:30 <ski> hm .. no, not quite
10:47:48 <Beelsebob> ski: I have no reason to prefer the word "then" over the word "after"
10:47:51 <ski>   <calc l> = <putStrLn ("avg:" ++ show (ave l))>
10:47:52 <ski>        `then` calc ((<readIO> :: Double):l)
10:47:59 <Saizan> do is clearly suggestive of sequence, so when the sequence is really there it seems a good fit
10:48:07 <Beelsebob> in fact, in Haskell I'm used to "after"
10:48:12 <Beelsebob> (.) gets used rather a lot after all
10:48:29 <ski> Beelsebob : `after' sounds like `(<<)'
10:48:35 <Beelsebob> Saizan: on many occasions I've been told here that do has nothing to do with sequencing, and should never be read as such
10:48:45 <Beelsebob> so I have no reason to start reading it as such now ;)
10:48:54 <ski>   _ `then` x = x  -- if it wasn't clear
10:49:08 <Beelsebob> ski: I certainly pronounce (.) as after
10:49:42 <ski> Beelsebob : are you talking about the `.' in your version ?
10:49:42 <pikhq> Beelsebob: Your code is like writing "while(*i++=*j++);" instead of "while(*i) {*i = *j; i++; j++;}", basically. :P
10:49:43 <Beelsebob> I guess I would pronounce (<=<) as monadic after
10:49:59 <Saizan> that's quite silly, it's true that the meaning might not be associated with sequencing for other monads, but the notation is clearly about things happening in an order
10:50:09 <pikhq> (only less idiomatic)
10:50:11 <soupdragon> pikhq: Are they really equal?
10:50:15 <Beelsebob> pikhq: I see no similarity between the two
10:50:31 <pikhq> soupdragon: No, that was a crap example.
10:50:34 <soupdragon> okay
10:50:54 <soupdragon> I got what you meant just curious about the ++ thing
10:50:55 <pikhq> Unless you mean "are the two bits of C equal".
10:51:03 <Beelsebob> Saizan: yes -- but seperating the meaning of your code when reading it, and the type of your code is a good thing -- you can't depend on the user going "ah, this is IO code is it, so do should be read as sequencing"
10:51:15 <ski> Beelsebob : i would say there's (at least) two senses of "sequencing" here
10:51:21 <Beelsebob> ski: indeed
10:51:34 <Saizan> there's always the sense of >>= sequencing
10:51:36 <Beelsebob> which is why I don't like to polute the waters by adding do, suggesting one or other form of sequence
10:51:39 <Saizan> which is valid for any monad
10:51:52 <ski> Beelsebob : (a) low-level operational sequencing .. which `do' (more specifically `(>>=)' or `join') isn't much related to
10:51:58 <Beelsebob> Saizan: yes, and =<< gives us the same amount of information
10:52:10 <ski> Beelsebob : (b) a high-level data-flow sense of sequencing
10:52:12 <Beelsebob> that one has to happen after the other
10:52:18 <Beelsebob> ski: *nod*
10:52:36 <Saizan> Beelsebob: right, but lines one after the other is quite more terse and has a nicer layout overall then a lot of =<<
10:52:38 <ski> take e.g. `do a <- as; b <- bs; f a b' in the list monad
10:52:40 <Beelsebob> and I don't see how do makes either of these clearer
10:52:42 <Beelsebob> in fact, it muddies the first one
10:52:44 <Beelsebob> it suggests that the first one is enforced
10:52:46 <Beelsebob> when it's not at all
10:52:57 <ski> in the (a) sense, the `a <- as' and `b <- bs' are interleaved
10:53:08 <ski> in the (b) sense, the `a <- as' occurs before `b <- bs'
10:53:17 <Beelsebob> Saizan: I don't think so, the same thing can be done with =<< as is commonly done with (.) when lines get too long -- break lines at apropriate places to group things nicely
10:54:20 <Saizan> Beelsebob: that works only when you've a nice pipeline, otherwise you get something like the output of @pl
10:54:28 <Beelsebob> Saizan: indeed
10:54:32 <Beelsebob> point free style is sometimes nice
10:54:39 <Beelsebob> sometimes it's a giant pile of steeming poops
10:54:41 <pikhq> Beelsebob: Basically, what you wrote there looks to me like the output of @pl.
10:54:42 <Saizan> and =<< is quite more heavyweight than .
10:54:55 <ski> Beelsebob : i don't see how using `do' suggests that (a) is implied/enforced .. unless you're too confu^Wused with imperative languages ;)
10:54:57 <Beelsebob> Saizan: indeed, it would be nice if it were rather shorter
10:55:23 <Beelsebob> ski: I firmly believe that the word "do" was specifically used to fool newbies into thinking that they were using an imperative language
10:55:36 <soupdragon> it's not fooling anyone
10:56:01 <ski> Beelsebob : that may or may not be the case .. i'm suggesting hijac^Wgeneralizing it to the (b) sense
10:56:26 <SamB> Beelsebob: who's fooling who?
10:56:29 <Beelsebob> ski: yeh, and I'm suggesting that all that leads to is confusing newbies, while not gaining anything over using =<<
10:56:52 <Beelsebob> SamB: the people who came up with the verb "do" are fooling people new to the laungage into thinking it's a nice fuzzy imperative setting for IO
10:57:02 <ski> Beelsebob : obviously newbies will have to learn, but they have to do that anyway
10:57:14 <Gertm> I'll have to learn ? Oh noes! :(
10:57:31 <SamB> imperative languages aren't as bad as they're made out to be -- it's just that we've all gotten confused into thinking that there is only one notion of action
10:57:40 <Beelsebob> ski: yeh, it'd be rather nice if we didn't add to what they had to unlearn along the way though
10:57:42 <Beelsebob> they have enough to unlearn already
10:57:47 <ski> `do' is a nice fuzzy imperative setting for `IO' .. as well as for `[]', `Expression', `Parser', `Cont', et.c.
10:57:53 <Saizan> Beelsebob: here you've "if' (==0) (return ()) (calc . (:l)) =<< readIO <* putStrLn . ("avg: " ++) . show . ave $ l", the most ugly part is the use of <*, if the rest of the pipeline doesn't use a value from before i don't see a reason to consider that a pipeline
10:58:29 <mike-burns> SamB: But imperative is evil! And anything that isn't Haskell is imperative!
10:58:37 <ski> SamB : that, *and* not being able to state that certain effects *doesn't* occur when some function is called
10:58:43 <SamB> mike-burns: imperative is nice
10:58:49 <SamB> it's just not nice to have only one kind
10:58:50 <mike-burns> SamB: (I was being sarcastic.)
10:58:51 <Beelsebob> Saizan: I have no reason not to consider it a pipeline -- in the same way as people think of 'putStrLn "jam" >> x <- getLine' as a pipeline
10:59:05 <SamB> or have to use *any* kind at all times
10:59:07 <Beelsebob> (binding x with real syntax ofc)
10:59:24 <Saizan> Beelsebob: what?
10:59:51 <Beelsebob> Saizan: essentially what I'm saying is that there's no reason to consider it any uglier than using >>
11:00:02 <Beelsebob> in fact, it's prettier, because the flow keeps going in the same direction all the time
11:00:11 <Saizan> Beelsebob: i'd find >> as ugly as that, in fact :)
11:00:11 <SamB> Beelsebob: you do realize that isn't syntactically valid ?
11:00:28 <ski> s/isn't/is/
11:00:36 <SamB> it ... is?
11:00:38 <SamB> how?
11:00:54 <Beelsebob> Saizan: I find x >> y no uglier than do x; y
11:00:57 * SamB didn't think function calls were allowed in patterns
11:01:03 <Beelsebob> and y <* x no uglier still
11:01:07 <ski> the `<-' is not expected after `putStrLn "jam" >> x'
11:01:07 <Beelsebob> slightly prettier in fact
11:01:08 <Saizan> Beelsebob: i find do x\n y much nicer
11:01:22 <Beelsebob> Saizan: I find that no better at all
11:01:28 <SamB> ski: precisely1
11:01:33 <Beelsebob> Saizan: having said that, I probably would chose <* as the place to break my line
11:01:36 <pikhq> Beelsebob: Your suggestions look like a bunch of Perl code.
11:01:37 <SamB> s/1/!/
11:01:47 <pikhq> You are writing Perl in Haskell.
11:01:53 <Beelsebob> pikhq: thank you, yours looks like a bunch of C code
11:01:56 <Beelsebob> you're writing C in Haskell
11:01:57 <SamB> is that called Paskell?
11:02:03 <Beelsebob> SamB: lol
11:02:05 <ski> SamB : .. oh, sorry .. i misread that "valid" as "invalid"
11:02:10 * ski hangs head in shame
11:02:12 <mike-burns> I wonder if Beelsebob's code would look more readable if there were line breaks?
11:02:20 <SamB> ski: that was what I thought must have happened
11:02:29 <SamB> especially after you gave a reason for it to be invalid!
11:02:35 <pikhq> Beelsebob: And for this, C-esque code is perfect.
11:02:44 <Beelsebob> pikhq: as is Perl-esque code
11:02:53 <Beelsebob> I prefer the "perl-esque" one
11:03:10 <pikhq> And not the huge mess that abstracts away exactly what the code is doing with a bunch of executable line noise.
11:03:10 <SamB> perl has too many different ways to do it
11:03:13 <ski> maybe we should agree to disagree over personal preferences ?
11:03:14 <mike-burns> So we have "Perl" code and "C" code, but what is the "Haskell way" to write this?
11:03:17 <Saizan> ok, so we can declare you prefer things that most find unreadable :)
11:03:23 <SamB> TATMWTDI
11:03:26 <Beelsebob> mike-burns: I would have said mine is the most haskellish
11:03:35 <Beelsebob> pikhq thinks it's perlesque though
11:03:36 <mike-burns> SamB: It seems that Haskell has too many different ways to do it!
11:04:00 <SamB> well, I mean, too many different syntactual forms to use for it
11:04:01 <mike-burns> Maybe calling something "Perl-ish" or "C-ish" isn't getting us anywhere.
11:04:12 <pikhq> The Haskell way to do it involves not using the IO monad. :P
11:04:22 <ski> mike-burns : why, it's using reflective syntax, of course ;)
11:04:27 <Beelsebob> mike-burns: I think I agree -- that's why I parodied pikhq's statement
11:04:32 <mike-burns> Ah.
11:04:34 <Beelsebob> pikhq: heh, yeh, you have a point there
11:04:50 <Beelsebob> the haskell way to do this would be to write a pure (String -> String) function
11:04:57 <Saizan> mike-burns: given the widespread of do-notation the current Haskell style is to use it in cases like these
11:05:09 <Beelsebob> and ignore (or use interact to) connect it to the outside world
11:05:24 <Saizan> except if you need an interctive program
11:05:31 <Saizan> for which intercat is really bad at
11:05:38 <Saizan> *interact
11:05:39 <Beelsebob> huh?
11:05:41 <mike-burns> Is there an `interact' that works for interactive programs?
11:05:49 <Beelsebob> interact is *excellent* for interactive programs
11:05:52 <pikhq> Beelsebob: Quite true. Makes the do notation and/or the Perl go away, and you instead get a nice set of function evaluations.
11:06:02 <Beelsebob> pikhq: *nod*
11:06:10 <ski> mike-burns : `Cont Dialogue'
11:06:13 <dons> kolmodin: is there a different link i should use on the platform home page to point to gentoo support?
11:06:28 <Saizan> Beelsebob: you need to add stricness annotations to force the printing to happen at the right time, and not before
11:07:06 <ski> Saizan : also, it's easy to force the input too much too soon
11:07:12 <Beelsebob> Saizan: I've never found that, though I can imagine that there are points where you specifically want to delay producing a small amount of string
11:07:17 <dubhrosa> ski: in your suggestion, the line "    n <- readIO :: IO Double" confuses me - what exactly does it do? I don't see where it should get its input string from...?
11:07:34 <mike-burns> :t readIO
11:07:36 <lambdabot> forall a. (Read a) => String -> IO a
11:07:40 <Beelsebob> @src readIO
11:07:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:07:42 * Beelsebob pokes lambdabot
11:08:03 <Saizan> Beelsebob: write me a program that prints the reversed string every time the user inputs one
11:08:28 <ski> dubhrosa : `readIO' calls `getLine' and `read's the string into the result (giving an exception if there's parse error, iirc)
11:08:48 <Beelsebob> Saizan: interact (unlines . map reverse . lines)
11:08:54 * Beelsebob tries to think why that might go wrong
11:09:02 <Beelsebob> because you obviously chose it for a reason
11:10:09 <Saizan> Beelsebob: no, i choose the wrong example :)
11:10:18 <Beelsebob> hehe
11:10:30 <Saizan> Beelsebob: the uppercased line, not reversed! reverse is strict enough :)
11:10:39 <Beelsebob> hehe
11:10:46 <mike-burns> How would we re-write the original program in OP's question using `interact'?
11:11:24 <Beelsebob> yep, I see your problem then â Saizan having said that, the functions you usually want to stick in there are usually complex enough that they're strict in their argument
11:11:36 <ski> mike-burns : composably or not ?
11:12:11 <mike-burns> Doesn't matter to me; just has to use a function called `interact' somewhere.
11:12:18 <Beelsebob> mike-burns: interact (show . ave . takeWhile (/=0) . map read . lines)
11:12:38 <ski> (Beelsebob : that's not composable ..)
11:12:40 <Beelsebob> that seems rather nicer than any of the others in fact
11:12:52 <mike-burns> I think that's the "Haskell-ish" way.
11:12:55 <Beelsebob> ski: what kind of composibility would you like?
11:13:02 <Saizan> that doesn't do the same thing, does it?
11:13:03 <Beelsebob> being able to carry on reading more lines?
11:13:19 <Beelsebob> Saizan: assuming the intention was to read until you get a 0 and then print the average
11:13:34 <Saizan> wasn't it supposed to print the current average after every number read?
11:13:40 <Beelsebob> oh, was it?
11:13:49 <Saizan> i guess it's not much different
11:13:57 <dubhrosa> ski: sorry if I'm being really dumb, but I don't see that readIO calls getLine; from the prelude docs: The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program.
11:13:57 <ski> Beelsebob : i want to be able to, externally to this part of the program (with exception of `interact' itself), being able to run another interactive program after the first .. e.g. run it twice
11:14:05 <Beelsebob> ski: interact (unlines . map (show . ave) . heads . takeWhile (/=0) . map read . lines)
11:14:35 <Beelsebob> ski: *nod* you don't easily get that kind of composibility from interact
11:14:39 <ski> Beelsebob : so, yes .. being able to pass on the rest of the lines to whatever we later decide to do afterwards
11:14:42 <Beelsebob> it needs a "switcher" type function from FRP
11:15:00 <ski> Beelsebob : right .. that's what `Cont Dialogue' was invented for
11:15:20 <Saizan> ?type readLn
11:15:21 <lambdabot> forall a. (Read a) => IO a
11:15:25 <ski>   type Dialogue = [Intput] -> [Output]
11:15:34 <Beelsebob> takeWhile would need to be replaced with until which takes a predicate, something to do before it returns True, and something to do after it returns True
11:15:37 <Saizan> dubhrosa: that does use getLine, iirc ^^^
11:15:39 <ski> (`Input' and `Output' being `Char' in this case)
11:16:12 <Beelsebob> ski: the other big problem being that you can't easily do work with more than one channel at once
11:16:31 <dubhrosa> Saizan: yes, I should have spotted that, it's the next line down in the doc...do'h
11:16:55 <ski> dubhrosa : sorry, mea culpa .. i should have said `readLn', not `readIO'
11:17:13 <ski> @src readLn
11:17:14 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
11:17:43 <Beelsebob> that one's a prime candidate
11:17:44 * ski notices Saizan already mentioned it
11:17:57 <Beelsebob> readLn = readIO =<< getLine
11:18:09 <ski> Beelsebob : in this case i agree that is clearee
11:18:14 <ski> s/ee/er/
11:18:14 <mike-burns> I agree with Beelsebob here.
11:18:30 <ski> (for the experiences haskeller, at least)
11:18:50 <skorpan> i never got used to =<< and feel like it's way more intuitive with >>= for some reason
11:19:38 <byorgey> skorpan: probably because we usually read left-to-right, but with =<< the data flows right-to-left
11:19:51 <byorgey> it's the same reason that I often use >>> instead of (.) when making big composition chains
11:19:54 <skorpan> byorgey: yep, but it seems that so many like =<< for its similarities with (.)
11:20:00 <byorgey> right.
11:20:06 <Beelsebob> skorpan: that and (<=<)
11:20:12 <Beelsebob> which is the real monadic equiv of (.)
11:20:16 <ski> skorpan : `bar . foo >>= baz' reads worse than `baz =<< bar . foo'
11:20:39 <Beelsebob> and finally =<< has a much nicer type
11:20:46 <ski> skorpan : also cf. `x <- bar >>= foo' vs. `x <- foo =<< bar'
11:20:49 <byorgey> @type (=<<)
11:20:50 <Beelsebob> maps one function type into another similar function type
11:20:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:21:06 <ski> @type Cont . (>>=)
11:21:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> Cont (m b) a
11:21:22 <byorgey> ah, true, it's easier to see the similarity to things like fmap and (<*>)
11:21:28 <Beelsebob> indeed
11:21:30 <skorpan> ski: i'm not sure what you're saying... i like "bar . foo >>= baz"
11:21:55 <Beelsebob> skorpan: that has to be read in part left to right
11:21:58 <Beelsebob> and in part right to left
11:22:03 <Beelsebob> and it's unclear which bit ends where
11:22:06 <byorgey> that's horrible... data flows into foo, then bar, then finally to baz.
11:22:14 <copumpkin> ew
11:22:14 <skorpan> to each his own
11:22:22 <Beelsebob> baz =<< bar . foo is much clearer
11:22:24 <ski> skorpan : um .. sorry, that first example should have been `foo >>= baz . bar' vs. `baz . bar =<< foo'
11:22:26 <copumpkin> skorpan: can you imagine a larger chain of those?
11:22:39 <copumpkin> and reversing direction every time you hit a (.) or a (>>=)
11:22:41 <skorpan> copumpkin: then i'd probably use do-notation anyways
11:22:42 <Beelsebob> data goes right to left all the way
11:22:51 <Gertm> how does one translate '->' in English anyway? *newb alert*
11:22:58 <copumpkin> right arrow
11:22:59 <copumpkin> :P
11:22:59 <skorpan> Gertm: "to" i usually say
11:23:10 * Beelsebob pulls out if' (==0) (return ()) (calc . (:l)) =<< readIO <* putStrLn . ("avg: " ++) . show . ave $ l from earlier
11:23:13 <ski> Gertm : context ?  lambda expression ? type ? `case' ?
11:23:16 <Beelsebob> to demonstrate to skorpan
11:23:42 <skorpan> Beelsebob: you won't convince me with unreadable examples
11:24:02 <skorpan> and i don't know what <* does in this case
11:24:07 <copumpkin> why flip reading direction when there's an option not to?
11:24:10 <Beelsebob> skorpan: it's >> but backwards
11:24:17 <Beelsebob> i.e. to keep reading right to left
11:24:20 <copumpkin> almost
11:24:21 <ski> Gertm : like `\x -> x*2' or `length :: [a] -> Int' or `case xs of [] -> 0; x:xs -> foo xs'
11:24:30 <skorpan> copumpkin: i don't see the data-flow the same way you guys seem to.  i see "f . g" as a single function in my head.
11:24:57 * copumpkin shrugs
11:24:58 <Beelsebob> skorpan: right, just like I see f <=< g as a single action in my head
11:25:01 <ski> Gertm : so .. which of those cases are you asking about ?
11:25:13 <Beelsebob> and f =<< x as a single application resulting an an action in my head
11:25:19 <byorgey> skorpan: that view doesn't scale easily to longer chains though, does it?
11:25:31 <QP> Does anyone know: is there an easy way to change one parameter (in record syntax) without having to get all the other ones, and then put them back?
11:25:49 <ski> one man's atom is another man's composite
11:25:50 <byorgey> QP: yes, you can say  foo { bar = x }
11:25:57 <byorgey> QP: to only change the 'bar' field of 'foo'
11:26:06 <QP> oh, cool!
11:26:13 <Beelsebob> not very
11:26:15 <skorpan> byorgey: i don't know, i don't deal with longer chains that much
11:26:23 * Beelsebob spends his time writing getters and setters for them
11:26:28 <skorpan> i don't do a lot of haskell at all to be honest
11:26:38 <QP> > 2*2
11:26:40 <lambdabot>   4
11:27:09 <copumpkin> :o
11:27:40 <QP> just checking!
11:27:45 <pikhq> Beelsebob: Well, yeah. Getters and setters tend to be nicer to read. ;)
11:28:02 <ski> the record update syntax would be nicer if there was a sensible way to update inside nexted records
11:28:05 <Beelsebob> pikhq: shame I have to write the boilerplate though :(
11:28:11 <pikhq> True.
11:28:45 <skorpan> we recently started using .net at work... we have a consultant who sat all day writing 500 lines of almost complete boilerplate code for database access.
11:28:47 <ski> (something like lenses / functional references appears to be one way of improving this)
11:28:52 <stanv> add ch [] = [[ch]]; add ch (x:xs) = (ch:x):xs; is there are standard function for such action ?
11:28:56 <Beelsebob> ski: indeed, you almost want data X = X{foo :: String} to generate foo :: X -> String, setFoo :: String -> X -> X and inFoo :: (String -> String) -> X -> X
11:29:08 <mike-burns> skorpan: But isn't there an ORM lib that does that for you?
11:29:19 <skorpan> mike-burns: there is, but apparently we needed this crap
11:29:19 <ski> Beelsebob : or `foo :: Lens X String' ..
11:29:28 <Beelsebob> ski: *nod*
11:29:29 <mike-burns> skorpan: Ouch, that sucks.
11:29:43 <skorpan> mike-burns: the worst part is that he seemed to be proud of his accomplishment.
11:30:09 <byorgey> Beelsebob: there are packages to write the boilerplate for you though, like data-accessor
11:31:32 <Beelsebob> byorgey: ohhh, shiny, I hadn't seen that
11:31:45 <mike-burns> stanv: Isn't that (:) ?
11:32:04 * ski should take one critical real look at data-accessor one of these days ..
11:32:29 <copumpkin> zomg the Cs and Ts
11:32:36 <copumpkin> my eyes!
11:33:21 <Saizan> heh
11:33:43 <copumpkin> oh my, he actualls has some classes that aren't called C in this
11:34:10 <Beelsebob> enjoy your boilerplate copumpkin
11:34:11 <Beelsebob> >.>
11:34:17 * Beelsebob goes to enjoy beer
11:34:34 <copumpkin> Beelsebob: I'll just take his source code and modify it to name its types and classes :P
11:34:35 * pikhq goes to enjoy root beer
11:34:38 <copumpkin> lol
11:34:52 <ski> (pikhq : MI ?)
11:35:13 <Beelsebob> copumpkin: resharper hanging about handy for that?
11:35:21 <copumpkin> ?
11:35:32 <pikhq> ski: ?
11:36:05 <ski> pikhq : ok, probably not then ("root beer" was featured in "The Secret of Monkey Island")
11:36:46 <pikhq> ski: Actual root beer, man.
11:36:54 <pikhq> Also, MOTO DESU KURE.
11:36:54 <Beelsebob> copumpkin: resharper is a C# refactorer
11:36:59 <Beelsebob> easy class renaming
11:37:01 <copumpkin> :o
11:37:05 <Beelsebob> (amongst many other things)
11:37:10 <copumpkin> pikhq: :o
11:37:16 <copumpkin> aha
11:37:17 <Beelsebob> there's a demo available somewhere on t'internet)
11:37:32 <desu> WAT
11:37:40 <pikhq> desu: MOTO DESU.
11:37:45 <copumpkin> o.O
11:38:21 <desu> D:
11:38:23 <pikhq> copumpkin: Correct response.
11:38:28 <desu> moonspeak D:
11:38:35 <pikhq> desu: "more desu".
11:38:43 <desu> o
11:38:45 <desu> needs moar
11:38:50 <copumpkin> motto?
11:38:50 <pikhq> Yup.
11:38:51 * ski is reminded of minion
11:39:04 <pikhq> copumpkin: I may have screwed it up; it's been a year.
11:39:21 <copumpkin> motto irimasu?
11:42:11 <kolmodin> dons: I'll make a proper haskell platform page on the wiki. I'll let you know of the url once it's online
11:44:32 <kolmodin> dons: we've recently built a gentoo specific tool to rebuild packages when upgrading ghc on your box. I successfully rebuilt my 132 packages (not 2gb, but still :D) without a hitch
11:45:13 <kolmodin> dons: http://www.haskell.org/haskellwiki/Gentoo#haskell-updater
11:46:49 <QP> Can anyone explain the difference between 'newtype' and 'data'?
11:48:01 <soupdragon> QP they don't have any difference in practice
11:48:06 <dons> kolmodin: oh, that looks very useful
11:48:10 <QP> I thought so
11:48:21 <QP> do they have any difference in theory?
11:48:27 <soupdragon> QP in the implementation the newtype consructor doesn't exist
11:48:29 <dons> QP: they are different in practice
11:48:48 <dons> the wiki has a good article
11:48:49 <soupdragon> so like F 3 is the same as 3 if F was a newtype
11:48:56 <dons> http://haskell.org/haskellwiki/Newtype
11:49:03 <dons> QP: ^^^
11:49:38 <QP> so i should say 'newtype' if i'm never actually going to explicitly write the constructor?
11:49:45 <soupdragon> no
11:50:14 <dons> no, you'd use newtype when you want to treat an existing type differently in the type system
11:50:19 <dons> i.e. by writing different instances for it
11:50:34 <dons> i.e. newtype T = T Int -- now i can write a different Show for T than for Int
11:50:43 <dons> and you get a guaranteee of no runtime overhead for the tag
11:50:52 <QP> ok, so 'type' carries instances accross, 'newtype' doesn't?
11:51:29 <dons> type just sets up an alias. a new name
11:51:41 <dons> newtype creates a distinct, new type for the type checker to think about
11:52:00 <QP> type T = Int will still be an instance of Integral...
11:52:24 <QP> but newtype T = T Int is not automatically an instance of anything?
11:52:36 <RayNbow`> indeed
11:52:46 <RayNbow`> but you could use newtype deriving
11:52:52 <QP> thank you, that is very useful indeed!
11:53:03 <byorgey> right.  but you can say  newtype T = T Int  deriving (Foo, Bar)  if you want T to inherit Int's instances of Foo and Bar
11:53:12 <byorgey> (using -XGeneralizedNewtypeDeriving)
11:54:34 <QP> ok, i'll try to remember that too
11:54:49 <ski> QP : with `data' you can have as many constructors as you like, each with as many arguments as you like
11:55:24 <ski> QP : with `newtype' you must have exactly one constructor with exactly one argument (in some sense to mimic `type' to some extent)
11:55:57 <QP> so why would you use newtype with record syntax (like in the definition of State s m)?
11:56:15 <ski> QP : with `data T = MkT Int', `MkT _|_' is not the same as `_|_' .. had it been `newtype' instead would they have been the same
11:57:01 <ski> QP : because it is sometimes useful with a deconstructor function, and then nice to have it constructed automatically for you .. i.e. not really the record syntax per se
11:57:10 <QP> > :t State s m
11:57:12 <lambdabot>   <no location info>: parse error on input `:'
11:57:29 <QP> > @type State s m
11:57:31 <lambdabot>   <no location info>: parse error on input `@'
11:57:44 <QP> @type State s m
11:57:46 <lambdabot>     Couldn't match expected type `s -> (a, s)'
11:57:46 <lambdabot>            against inferred type `Expr'
11:57:46 <lambdabot>     In the first argument of `State', namely `s'
11:57:54 <ski> @kind State s m
11:57:56 <lambdabot> Not in scope: type variable `s'
11:57:56 <lambdabot> Not in scope: type variable `m'
11:58:01 <ski> @kind forall s m. State s m
11:58:02 <copumpkin> @kind State
11:58:03 <lambdabot> *
11:58:04 <lambdabot> * -> * -> *
11:58:06 <QP> @type State s a m
11:58:08 <lambdabot>     Couldn't match expected type `s -> (a, s)'
11:58:08 <lambdabot>            against inferred type `Expr'
11:58:08 <lambdabot>     In the first argument of `State', namely `s'
11:58:43 <ski> QP : what're you fer ?
11:59:22 <QP> ok, i'll try:
11:59:30 <QP> @type State Int Bool
11:59:31 <lambdabot> Not in scope: data constructor `Int'
11:59:31 <lambdabot> Not in scope: data constructor `Bool'
12:00:51 <ski> QP : again, what are you trying to do ?
12:01:25 <QP> Ah, i'm very confused. I see i should try...
12:01:33 <QP> @type State 2 True
12:01:35 <lambdabot>     Couldn't match expected type `Bool -> t'
12:01:35 <lambdabot>            against inferred type `State s a'
12:01:35 <lambdabot>     In the expression: State 2 True
12:01:45 <QP> no! then...
12:02:09 <QP> @type State (\n -> (n, True))
12:02:11 <lambdabot> State Bool Bool
12:02:18 <ski> QP : you shouldn't confuse the type constructor `State' with the data constructor `State'
12:02:28 * ski would prefer if the latter was called `MkState'
12:02:30 <QP> yes, i see that's what i was doing
12:02:42 <ski> @src State
12:02:43 <lambdabot> Source not found. You untyped fool!
12:03:02 <ski>   newtype State s a = State {runState :: s -> (a,s)}
12:03:55 <QP> so do I not actually need to use runState?
12:04:10 <ski>   runState (State f) = f
12:04:32 <ski> you can always match on the `State' data constructor yourself, instead of using `runState'
12:04:45 <QP> i can write a :: State Int Int, a 2 = runState a 2?
12:04:57 <benmachine> wait, why is State (\n -> (n, True)) Bool Bool? I'd expect it to be Bool a
12:05:00 <ski> (or use some other function which either matches on `State' or calls `runState' .. such as `evalState' and `execState')
12:05:21 <soupdragon> :t State (\n -> (True, n))
12:05:23 <lambdabot> forall s. State s Bool
12:05:26 <copumpkin> edwardk: I have a kata question
12:06:13 <ski> benmachine : because it's `s -> (a,s)' instead of `s -> (s,a)' (as it ought to be ..)
12:06:15 <soupdragon> benmachine, s = a because n is in both places
12:06:50 <ski> QP : no, that's not type correct
12:07:27 <benmachine> oh right
12:08:27 <ski> > let a :: State Int Int; a 2 = runState a 2 in ()
12:08:28 <lambdabot>   The equation(s) for `a' have one argument,
12:08:28 <lambdabot>  but its type `Control.Monad.Sta...
12:08:56 <QP> ski: so wouldn't it be easier to write State s a = s -> (a, s)
12:09:03 <QP> instead of using record notation?
12:09:47 <QP> and then use a 2 instead of runState a 2?
12:10:46 <ski> QP : (a) then you couldn't make it an instance of the class `Monad', (b) it would be easier to make errors which weren't caught as early (and with more confusing error messages)
12:11:25 <ski> (the (b) point applies to `Reader' and `Writer' as well, even if the (a) point doesn't)
12:11:48 <QP> ok, i sort of see.
12:12:18 <ski> (that said, in some cases the light-weightness that you get in this way could be preferable, even with the risk of (b))
12:12:20 <QP> anyway, I now understand how to use newtype
12:12:23 <Athas> @hoogle (a -> Bool) -> [a] -> [[a]]
12:12:23 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
12:12:23 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
12:12:23 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
12:12:44 <Athas> Distribution.Simple.Utils?  That sounds... weird.
12:12:53 <Athas> Is this really not a standard function?
12:13:20 <ski> QP : if you have `data T = MkT Int', then `MkT x' will actually wrap the (unevaluated) `x' value in a "box" ..
12:14:27 <ski> QP : if you have `newtype T = MkT Int' instead, then, at run-time, the `MkT' constructor is basically removed .. i.e. it corresponds to zero operations to perform .. `MkT x' is represented in exactly the same way as `x' itself
12:14:46 <ski> Athas : which ?
12:15:15 <Athas> ski: a function for splitting a list into sublists separated by any element a predicate returns true for.
12:15:28 <Athas> ski: like Data.ByteString.split, but for lists.
12:15:35 <stanv> ?src lines
12:15:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:15:44 <stanv> :(
12:15:45 <Athas> I can easily write my own, of course.
12:17:13 <QP> ski: ok, so it's much more efficient? I take it type T = Int also works just as efficiently?
12:17:47 <ski> QP : it should be similar to `type' in this respect, yes
12:17:52 <kolmodin> dons: initial version of gentoo's haskell platform page: http://www.haskell.org/haskellwiki/Gentoo/HaskellPlatform
12:18:11 <QP> ok, this is all useful stuff to know! thanks much.
12:18:36 <ski> (i.e. it in some sense mimics `type' in this respect .. which explains why it must have exactly one constructor with exactly one argument)
12:18:41 <stanv> > lines "1\n2"
12:18:43 <lambdabot>   ["1","2"]
12:19:00 <stanv> why lambdabot can't find source for lines ?
12:19:26 <Rotaerk> lambdabot, y r u so dum LOL
12:20:10 <Rotaerk> wonder how many brain cells I just killed, in total
12:20:22 <pikhq> All of theme.
12:22:48 <ski> stanv : `src' doesn't search any code repository .. only some things are manually included
12:24:08 <stanv> i want to see the source for `lines' function :)
12:24:29 <mike-burns> stanv: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#lines
12:24:52 <ski> @index lines
12:24:52 <lambdabot> Data.List, Prelude
12:24:58 <ski> @source Data.List
12:24:59 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:26:27 <stanv> hmm
12:26:49 <ski> @docs Data.List
12:26:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
12:37:23 <michaelfeathers> > let terminatedLines = map (++ "\n") . lines
12:37:24 <lambdabot>   not an expression: `let terminatedLines = map (++ "\n") . lines'
12:44:11 <copumpkin> :o
12:49:05 <michaelfeathers> Is this clean or goofy? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7826#a7826
12:50:01 <shapr> michaelfeathers: Did you join Ward's Wiki a decade ago?
12:50:16 <michaelfeathers> I suppose I could do terminatedLines from scratch to avoid the appends.
12:50:25 <Nafai> Hi shapr!
12:50:26 <michaelfeathers> shapr: Yup, that's me.
12:50:35 <shapr> michaelfeathers: Nice to meet you in realtime, I'm ShaeErisson!
12:50:37 <shapr> Nafai: Hiya!
12:50:47 <shapr> aka shapr on twitter and elsewhere
12:50:59 <michaelfeathers> shapr: Great to meet you too.  I remember your handle.
12:51:03 <Nafai> michaelfeathers: Seeing you here reminds me I keep meaning to get your book :)
12:52:00 <michaelfeathers> Nafai Heh.  It's good if your day job is in one of the C derived languages: Java, C++, C#.
12:52:35 <Nafai> Python at the moment, but I'm quite experienced with Java and C++, so it seems it would help.
12:52:39 <Nafai> So you're learning Haskell?
12:53:39 <michaelfeathers> Nafai: I've been learning it on and off for years.  Re-dedicating myself to it, though.  Going to ICFP this year.  Hammering away at a personal project.. a vi-clone in Haskell.
12:53:52 <Nafai> Awesome.
12:53:56 <shapr> cool!
12:53:59 <shapr> michaelfeathers: Have you seen Yi?
12:54:06 <Nafai> I wish I could afford to go to ICFP :)
12:54:26 <michaelfeathers> I know that Yi exists, I just want to build something complete from scratch.
12:54:30 <shapr> Ah, ok
12:55:17 <michaelfeathers> I found Yi's code mesmerizing.  I'm not quite there on my Haskell reading skills yet.
12:55:47 <shapr> If you like to practice above your skill level you could read some of edwardk's code.
12:56:04 <Nafai> shapr: I don't know if I'll ever be at edwardk's level :)
12:56:13 <shapr> Yeah, I feel the same way.
12:56:34 <Nafai> Partly because I haven't allowed myself the time to devote to Haskell
12:56:35 <michaelfeathers> Where's it at?
12:56:53 <shapr> category-extras is a good example of edwardk's code.
12:57:01 <shapr> Or his blog @ comonad.com
12:57:44 <shapr> His recent passion is (among other things) monoidal parsing, which is 'transparently' parallel.
12:58:02 <shapr> Or maybe just monoids in general.
12:58:09 <michaelfeathers> Thx.  I just started picking Brent Yorgey's blog the other day.
12:58:19 <shapr> Oh yeah, combinatoric species.
12:58:26 <Berengal1> Monoids are a bit too fun
12:58:27 <shapr> Oh did you see the pix from Hac phi?
12:58:29 <Berengal1> And everywhere
12:59:06 <michaelfeathers> So, I understand monads.. but I have no idea what a co-monad is.
13:00:03 <shapr> I vaguely understand comonads, but I doubt I can explain it well to others.
13:00:43 <michaelfeathers> I have this book on category theory I keep meaning to get back to.  Too much to do, too little time.
13:00:47 <shapr> A monad lifts something into a chunk, a comonad pulls something out of a chunk.
13:00:54 <shapr> That's my understanding.
13:01:26 <michaelfeathers> yeah, I'll have to dig into that.
13:02:58 <michaelfeathers> At times, I watch that guy on Channel 9 who tries to explain monoids etc to the .NET world.  I forget his name.
13:06:32 <athos> michaelfeathers:
13:06:34 <athos> brain beckman?
13:06:45 <michaelfeathers> athos: Yes,that's him.
13:06:47 <athos> "dont fear the monads"
13:06:54 <athos> he also did a series on the state monad
13:07:18 <michaelfeathers> I think I saw a bit of that.  He coded it in C# too.  Ouch.
13:07:51 <athos> well
13:08:17 <athos> c# is adapting more and more concepts from the functional world
13:08:48 <athos> SPJ likes to explain that by his Useful/Useless vs. Unsafe/Safe chart ;-)
13:08:50 <Twey> Chanel 9?
13:08:54 <michaelfeathers> True.  It has some nice things.
13:09:14 <michaelfeathers> http://channel9.msdn.com/
13:10:12 <Twey> http://www.youtube.com/watch?v=ctaszjeaDK0
13:10:19 <Twey> But oho
13:13:23 <michaelfeathers> Seems like there was one hell of a push in MS toward that direction.  I remember reading about the research projects: C-Omega. I've heard all sorts of war stories from people inside of MS about how they pushed for various things across the whole suite of languages.
13:13:26 <vav> Athas: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitWhen -- there's whole library for different splits, not in std lib though
13:15:25 <etpace> If I have something like, foo = (f 1) + (f 1), where f returns some int after a good deal of recursion, is f calculated twice and then added together, or is it calculated once, "memo-ised"(?) for the second f called and then added
13:15:57 <Athas> vav: thanks, I'll keep it in mind.  I'll rather just maintain this three-line function for now, though.
13:16:24 <Ke> etpace: unless your compiler really, really sucks that's a constant expression
13:16:36 <Ke> etpace: so no function calls are made
13:16:56 <Berengal1> etpace: It might do CSE on it, or it might not. To be certain it does you should put it in a let
13:17:18 <etpace> ok, thanks
13:18:14 <michaelfeathers> Didn't Hugs  or ghci have some flag once which allowed you to see the reductions during evaluation?
13:22:12 <Ke> hmm I'm talking silly again
13:22:38 <Cale> etpace: GHC won't do CSE on that.
13:27:26 <Guest383> hu
13:37:52 <copumpkin> do F-algebras fit in at all with algebras over fields and rings?
13:38:07 <copumpkin> or is "algebra" just a massively overloaded term?
13:38:49 <hackagebot> derive 2.0.1 - A program and library to derive instances for data types (NeilMitchell)
13:52:19 <Cale> copumpkin: Pretty much the latter.
13:53:14 <Cale> copumpkin: Though it would not surprise me if there was some connection, for an appropriately selected F.
13:53:31 <Cale> (and choice of category)
13:58:57 <Modius> Can anyone point me to specific code for functional RB tree deletion?
13:59:15 <Modius> I mean the actual algorithm that works at the node level.
14:02:04 <Cale> http://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
14:02:12 <BMeph> http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps
14:02:13 <Modius> Haha just found :  http://www.cse.unsw.edu.au/~dons/data/RedBlackTree.html
14:03:41 <copumpkin> Cale: ah, I see
14:06:19 <copumpkin> Modius: wow, the balance function on that page makes me glad we have pattern matching :P I remember writing it back in the day and it was painful
14:06:45 <copumpkin> not that it's particularly easy to glean the structure changes in that version either
14:07:33 <Cale> Well, you can rather easily draw it from each line
14:10:12 <copumpkin> yeah
14:10:18 <copumpkin> it's definitely easier than without pattern matching
14:13:03 <Cale> Sort of clever how the pattern matching was arranged so that the result would be the same in all but the last fall-through case.
14:13:24 <Cale> (in balance)
14:14:05 <copumpkin> yeah
14:14:26 <copumpkin> I might have lined up the patterns so that left and right subtrees had their own "column"
14:14:53 <copumpkin> although nested patterns make that a little harder
14:16:38 <dons> ?seen TomMD
14:16:38 <lambdabot> I saw TomMD leaving #haskell, #haskell-in-depth, #haskell-blah, #xmonad and #ghc 1d 22h 51m 8s ago, and .
14:16:45 <Athas> Man, I get excited every time I use the Maybe monad.
14:16:48 <dons> hehe
14:16:53 <dons> we should put it on tshirts
14:16:57 <Athas> That's some pretty nifty stuff, in all its simplicity.
14:17:11 <copumpkin> Athas: you should get even more excited with the Maybe Applicative and maybe MonadPlus!
14:17:23 <copumpkin> Monads are so last year
14:17:33 <Athas> I know both of those!  But they are complicated, while I can keep Maybe in a single neuron.
14:17:34 <skorpan> hey, let me get a grip on them first
14:18:06 <SamB> skorpan: do you mean "get to grips with [them]"?
14:18:18 <skorpan> yeah, probably
14:38:49 <edwardk> my brain just asploded putting together a funny recursive typeable instance, but it seems to work =)
14:39:29 <edwardk> now to write the template haskell to generate dozens of these
14:40:31 <dons> jj/win 9
14:40:58 <edwardk> newtype Var (f :: * -> *) = V String; instance Typeable1 f => Typeable (Var f) where typeOf vf = mkTyConApp varTyCon [typeOf1 (undefined `unfolded` vf)] where unfolded :: f (Var f) -> Var f -> f (Var f); unfolded = const
14:41:10 <edwardk> it seems to make a standalone deriving for Data happy and everything
14:42:02 <edwardk> (most of the time i'm applying these through a weird fixpoint, but i need to be able to have data/typeable instances so i can automatically generate template haskell from a quasiquoter that generates these
14:42:47 <copumpkin> :o
14:43:14 <edwardk> its how i'm attaching annotations to the kata syntax tree
14:43:27 <edwardk> as of bout 5 minutes ago when i got it to work ;)
14:44:34 <copumpkin> :P
14:45:06 <copumpkin> by the way, I was wondering how you plan on specifying which algebraic structure to work on in kata
14:45:26 <edwardk> how do you mean? since i have no typeclasses?
14:46:15 <copumpkin> well, which pair of binary operations you want to use over which set for a particular ring operation, for example
14:46:20 <edwardk> you make up modules for each, and inherit most of their properties from the module signatures. you inherit. module signatures work like classes (infact you use the class keyword to define them) and you make up new modules (with new)
14:47:21 <edwardk> myring = new ring with { (+) = ...; (*) = ...; 0 = ...; 1 = ...; ... }; foo = open myring : ring in a + b - 1
14:47:51 <edwardk> or you can say foo = a +_myring b -_myring myring.1 -- but that gets old fast
14:48:03 <copumpkin> how's the scoping working on those operations?
14:48:09 <copumpkin> and I'm assuming the 1 is overloaded too?
14:48:47 <edwardk> open takes an expression and a class description to use as a signature, the signature specifies the names that come into scope
14:49:16 <edwardk> so if you open some big scary class with all sorts of methods as a monad only the basic monad operations come into scope from the class, so lexical scoping is well known at compile time
14:49:24 <Alertas> http://riteriai.draugas.lt/?recruit=3H2649
14:49:29 <copumpkin> I see
14:49:45 <Alertas> http://riteriai.draugas.lt/?recruit=3H2649  look that
14:49:48 <copumpkin> Alertas: in soviet lituania, game plays you!
14:49:49 <planka> how do i join quakenet instead of freenode?
14:49:52 <edwardk> yeah, and through regex bindings you can bind whole families of things like numbers or all variable names, etc.
14:50:10 <copumpkin> edwardk: ooh neat
14:50:47 <copumpkin> @where ops
14:50:47 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:50:47 <lambdabot> mauke
14:50:51 <Alertas> but is intrested game
14:51:02 --- mode: ChanServ set +o arjanb
14:51:05 <SamB> planka: check on the quakenet webpage
14:51:06 <copumpkin> Alertas: no, it's a game that's trying to get its users to advertise it for free
14:51:15 <edwardk> int = new lots-of-class-names public /([0-9]*)/ i = parseInt i; (+) = ...
14:51:22 <dons> ?
14:51:27 --- kick: Alertas was kicked by arjanb (no spamming)
14:51:33 <dons> thanks
14:51:34 --- mode: arjanb set -o arjanb
14:52:17 <edwardk> regex bindings let me punt all of the literal syntax issues of how to handle floats, etc. out of the parser, and provided me with a nice mechanism for generic proxying, etc.
14:52:44 <copumpkin> sounds neat
14:52:48 <copumpkin> will this be interpreted?
14:53:07 <edwardk> yes and no, the first release will likely be the interpreter
14:53:13 <edwardk> but its designed for compilation
14:53:16 <SamB> edwardk: that actually sounds kinda dumb ;-)
14:53:43 <edwardk> samb: the regex thing? its just extending the shape of possible contexts. i hated the idea when i first had it but it grew on me
14:55:31 <edwardk> samb: you can check which regular expressions that is in scope matches a variable name just like you can handle normal scope resolution.
14:55:51 <wgsilkie> I wrote a function that returns a list of integers, and now I need to find the largest value in the list.  Since I don't need it sorted, what would be a good way to do this?
14:56:03 <copumpkin> :t maximum
14:56:05 <lambdabot> forall a. (Ord a) => [a] -> a
14:56:08 <edwardk> and it only matches the legal lexemes to begin with, but lets me bind names like 1, 4e-10, etc.
14:56:32 <wgsilkie> @src maximum
14:56:32 <lambdabot> maximum [] = undefined
14:56:32 <lambdabot> maximum xs = foldl1 max xs
14:56:47 <wgsilkie> @src foldl1
14:56:47 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:56:47 <lambdabot> foldl1 _ []     = undefined
14:56:56 <copumpkin> not sure why maximum explicitly catches the []
14:57:02 <copumpkin> and then does exactly what foldl1 does with it
14:57:12 <wgsilkie> I can't tell what foldl1 does.
14:57:19 <copumpkin> @src foldl1
14:57:20 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:57:20 <lambdabot> foldl1 _ []     = undefined
14:57:42 <copumpkin> http://cale.yi.org/index.php/Fold_Diagrams might help
14:57:55 <copumpkin> > foldl1 f [a,b,c,d,e]
14:57:57 <lambdabot>   f (f (f (f a b) c) d) e
14:58:01 <wgsilkie> Thanks, copumpkin!
14:58:03 <copumpkin> > foldr1 f [a,b,c,d,e]
14:58:04 <lambdabot>   f a (f b (f c (f d e)))
14:58:11 <copumpkin> wgsilkie: that's Cale's work :)
14:59:07 <copumpkin> > [a..e]
14:59:09 <lambdabot>   * Exception: not a number
14:59:17 <Cale> heh
14:59:19 <Cale> odd
14:59:24 <copumpkin> damn, we need a nice Enum instance for those ;)
14:59:28 <Cale> > [a..e] :: [Expr]
14:59:30 <lambdabot>   * Exception: not a number
14:59:33 <Cale> ah, of course
14:59:54 <Cale> > [a,b,c,d,e]
14:59:56 <lambdabot>   [a,b,c,d,e]
15:00:02 <Cale> Somehow that started to work
15:00:17 <ni|> hi
15:01:02 <Cale> hi
15:01:16 <djahandarie> hi
15:01:23 <benmachine> hi
15:01:38 <wgsilkie> > ['a'..'e']
15:01:40 <lambdabot>   "abcde"
15:01:50 <djahandarie> > 'hi'
15:01:51 <lambdabot>   <no location info>:
15:01:51 <lambdabot>      lexical error in string/character literal at chara...
15:01:53 <djahandarie> fuck
15:01:55 <djahandarie> -_-
15:02:00 <djahandarie> > "hi"
15:02:01 <lambdabot>   "hi"
15:02:54 <copumpkin> :t var
15:02:56 <lambdabot> forall a. String -> Sym a
15:03:14 <copumpkin> > foldr1 f . map var $ ['a'..'e']
15:03:16 <lambdabot>   Ambiguous occurrence `var'
15:03:16 <lambdabot>  It could refer to either `Data.Number.Symbolic....
15:08:44 <xenoblitz> quick question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7829#a7829 Why can't I do away with the extra brackets for the m () input of the when/unless functions here? I mean is there something I am not understanding or... sorry if its a silly question but its confusing me.
15:09:26 <Philonous> @hoogle IO Bool -> IO a -> IO ()
15:09:26 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
15:09:26 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
15:09:26 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
15:09:48 <Philonous> @hoogle Monad m => m Bool -> m a -> m ()
15:09:48 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
15:09:48 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
15:09:48 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
15:09:57 <Lemmih> xenoblitz: You could use '$'.
15:10:11 <mike-burns> :t when
15:10:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:10:20 <xenoblitz> Lemmih: but why is it needed in the first place... doesn't the do provide the "context" ?
15:10:32 <Philonous> mike-burns: Almost, I'm looking for a monadic while
15:11:09 <Philonous> I.E. while the first action return true, invoke the second action
15:11:17 <Lemmih> xenoblitz: No.
15:12:27 <xenoblitz> Lemmih: ok, thanks sorry for taking your time, monadic syntax confuses me sometimes
15:12:51 <tibbe> dons: will there be a hackathon at icfp?
15:13:05 <Lemmih> xenoblitz: No problem. It takes a while to get used to.
15:13:06 <tibbe> dons: I heard something about one before the conference but I won't be in until sunday
15:13:07 <dons> on the day before icfp, i think
15:13:13 <dons> check it on haskell.org
15:13:33 <xenoblitz> Lemmih: the $ operator cleans it up nicely :)
15:14:28 <vav> xenoblitz: when binds tighter than (==).  `(when key) == chrString' is no good, of course. (just to make sure that's clear)
15:16:15 <xenoblitz> vav: yes, thanks, for some strange reason I somehow assumed that the do provided the ( ) needed by the when
15:16:39 <vav> ah right, now I see what you were getting at
15:17:15 <xenoblitz> vav: thanks though
15:20:56 <benmachine> > let while p a = p >>= flip when (a >> while p a) in while (return False) (return ())
15:20:57 <lambdabot>   No instance for (GHC.Show.Show (m ()))
15:20:57 <lambdabot>    arising from a use of `M251691677...
15:21:31 <mike-burns> I wish you could search Hoogle for a function matching a definition. But, of course, that wouldn't work at all.
15:22:08 <mike-burns> But it'd be great to ask it "where is this `while' defined, and what did the author name it?".
15:22:15 <edwardk> aww i can't seem to find standalone deriving in template haskell
15:23:13 <benmachine> mike-burns: all you have to do is acquire an encyclopaedic knowledge of the entire content of hackage
15:23:19 <benmachine> et voila
15:23:23 <mike-burns> I'm working on it ...
15:24:25 <vav> mike-burns: wouldn't be surprised if hayoo-12.0.4 does that. ;-)
15:25:20 <mike-burns> Ha yeah, but it'd use some convoluted AJAX-based thing instead of a straight-forward Web form or IRC bot.
15:30:56 <ashumz> can someone tell me why init is named init
15:31:01 <ashumz> im having a hard time with that one
15:31:29 <benmachine> the initial bit of the list
15:31:52 <ashumz> but its not the initial really, its like, everything but the last
15:31:59 <ashumz> thats like everythingbut
15:32:41 <SamB> well, liat was considered too obscure
15:32:43 <benmachine> init [1,2,3,4] is the initial 3 elements of the list
15:32:48 <mike-burns> When they wrote the original list functions (and other functions) they were really into short, short names, to the point of meaninglessness.
15:33:00 <ashumz> hahah
15:33:07 <benmachine> I think that's reasonable
15:33:14 <mike-burns> I think it's reasonable too.
15:33:14 <benmachine> with something that you're going to be using often
15:33:25 <ashumz> yeah maybe if it was like init3 but then youre just getting to the take thing
15:33:37 <ashumz> that makes sense though
15:33:39 <ashumz> mike
15:34:37 <ashumz> what languages do most people come from when becoming interested in haskell, generally?
15:34:47 <soupdragon> none
15:35:01 <dons> soupdragon: that's not helpful.
15:35:06 <dons> ashumz: hmm, all sorts.
15:35:09 <ashumz> most people dont program at all before they try haskell? lol
15:35:20 <ashumz> i find that hard to believe :)
15:35:24 <dons> other FP languages, ex-Python people, Java programmers, etc.
15:35:32 <dons> I don't think there's a particular type
15:35:41 <mike-burns> I haven't noticed any strong pattern either.
15:35:46 <ashumz> cool
15:35:50 <mike-burns> There is a large minority of C# programmers.
15:36:07 <dons> I've noticed a few F# programmers
15:36:18 <benmachine> my most recent language before haskell was python
15:36:19 <ashumz> i saw a presentation that talked about the learn you a haskell deal
15:36:24 <soupdragon> I am rigth
15:36:29 <soupdragon> none = no patter
15:36:30 <benmachine> before that, mostly C (with bits of grudging perl/php)
15:36:34 <ashumz> and i found that has some assumed knowledge involved even though it said it was "beginner" or whatever
15:36:38 <dons> soupdragon: ah, you weren't clear.
15:36:43 * RayNbow` was mainly using Java when he encountered Haskell @ university
15:37:20 <ashumz> how popular is haskell and what is it mainly used for
15:37:21 <RayNbow`> but I didn't really get interested in Haskell until I decided to use it to solve puzzles :p
15:37:30 <ashumz> when im learning new things, i have a hard time figuring out their practical applications
15:37:42 <ashumz> thats cool :D
15:37:53 <dons> ashumz: http://www.sdtimes.com/blog/post/2009/07/27/Everyonee28099s-talking-about-Haskell.aspx
15:38:00 <dons> there's a fairly good summary for the outsider
15:38:06 <ashumz> thanks!
15:38:22 <dons> ashumz: you'll want to play with multicore parallelism, persistant structures, maybe EDSLs.
15:38:46 <mike-burns> ashumz: But in addition to Haskell's strengths it's also good at "normal programming".
15:39:24 <djahandarie> Could someone help me with this? http://pastebin.ca/1516103
15:39:33 <djahandarie> It's a really simple concept, I just can't seem to do it correctly
15:40:00 <soupdragon> djahandarie: you need ()'s like  putStrLn (time*full*complete)
15:40:50 <djahandarie> soupdragon, I tried that, but it gives me even more crazy stuff
15:40:59 <djahandarie> I think it's because I'm trying to change a String to a Num
15:40:59 <mike-burns> :t getArgs
15:41:00 <djahandarie> Or something
15:41:00 <lambdabot> Not in scope: `getArgs'
15:41:16 <soupdragon> djahandarie: this is one thing you have to do to fix the code
15:41:17 <benmachine> djahandarie: the (time:full:complete) pattern makes time and full strings, and complete a [String]
15:41:38 <benmachine> i.e. list of strings
15:41:49 <djahandarie> benmachine, Tjat
15:41:56 <djahandarie> That's what I figured
15:42:07 <djahandarie> How do I change it to a number that I can do operations on?
15:42:12 <benmachine> if you want to match a list of three strings, you do [time, full, complete]
15:42:23 <benmachine> making strings into numbers is done with read
15:42:32 <benmachine> > read "3" :: Int
15:42:33 <lambdabot>   3
15:44:35 <djahandarie> It seems to still think they are Strings rather than Ints
15:45:00 <djahandarie> Ah, no, it was putStrLn expecting a string
15:45:04 <djahandarie> How do I convert back?
15:45:12 <Suttonian> show
15:45:12 <djahandarie> > read 3 :: String
15:45:12 <benmachine> > show 3
15:45:15 <lambdabot>   "3"
15:45:15 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
15:45:15 <lambdabot>    arising from the literal `...
15:45:23 <benmachine> @type read
15:45:24 <lambdabot> forall a. (Read a) => String -> a
15:45:27 <benmachine> @type show
15:45:27 <djahandarie> Ah okay
15:45:28 <lambdabot> forall a. (Show a) => a -> String
15:45:33 <RayNbow`> @src print
15:45:33 <lambdabot> print x = putStrLn (show x)
15:45:34 <djahandarie> That makes sense
15:45:40 <djahandarie> Ooh, that's even nice
15:45:41 <djahandarie> r
15:46:20 <djahandarie> Yeay, it works now. :D
15:46:57 <djahandarie> Is there a better way to do [time, full, complete] -> mycheck (read time :: Int) (read full :: Int) (read complete :: Int)
15:47:06 <djahandarie> Like can I fold it or something
15:47:23 <benmachine> do
15:47:28 <benmachine> hm
15:48:20 <benmachine> you can do mycheck (read time) (read full) (read complete), and then use the typesig for mycheck to force the types
15:49:01 <benmachine> you could do something contrived like let [tn, fn, cn] = map read [time, full, complete] but I don't think that's worth the effort tbh
15:49:30 <benmachine> wait why am I giving advice I don't know anything
15:49:39 * benmachine goes back to whatever it was he was doing
15:50:11 <mike-burns> You could change the type of `mycheck' to :: [a] -> IO(), then pass it (map read args)
15:50:19 <mike-burns> Er, [Int] -> IO ()
15:50:29 <djahandarie> Ooh, yeah, that seems good
15:51:06 <mike-burns> I'd probably push the putStrLn out of the functions and back into `main'.
15:52:06 <mike-burns> `putStrLn usage', then `usage = unlines ["Usage", "whatever, etc"]'
15:53:14 <djahandarie> And then mycheck :: [Int] -> String
15:53:15 <djahandarie> ?
15:53:35 <mike-burns> Yes, or mycheck :: [Int] -> Int
15:53:51 <mike-burns> And use `print' in `main' to run `show' on the result.
15:54:30 <djahandarie> Yeay, it worked. :D
15:54:39 <djahandarie> This looks a lot nicer than before
15:56:17 <QP> @hoogle liftIO
15:56:18 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
15:57:53 <gwern> @remember benmachine wait why am I giving advice I don't know anything
15:57:53 <lambdabot> I will never forget.
15:57:59 <gwern> @quote ben
15:58:00 <lambdabot> lispy says: glguy: some of us just like to get bent
15:58:08 <djahandarie> -_-
15:58:12 <gwern> @quote ben
15:58:13 <lambdabot> Cale says: Oleg can bend spoons with his mind, in the type system, in Haskell 98.
15:58:21 <gwern> @quote ben
15:58:22 <lambdabot> Cale says: Oleg can bend spoons with his mind, in the type system, in Haskell 98.
15:58:31 <gwern> @flush
15:58:46 <gwern> that lispy quote was probably more funny in context
15:59:01 <benmachine> @help flush
15:59:01 <lambdabot> flush. flush state to disk
15:59:05 <benmachine> oic
16:06:02 <dons> gwern: http://haskell.org/haskellwiki/WikipediaArticleDesign
16:06:14 <dons> peoples: comment, thoughts on design of a better wikipedia article for Haskell.
16:06:59 <mmorrow> preflex: zdec Z2T
16:06:59 <preflex>  Z2T
16:07:21 <mmorrow> preflex: zdec ZLz2cUZR
16:07:21 <preflex>  (,)
16:07:33 <mmorrow> hrm
16:07:56 <dons> Cale: http://haskell.org/haskellwiki/WikipediaArticleDesign comments?
16:10:43 <brad_larsen> cabal-install is broken for me w/ ghc 6.10.4
16:10:51 <dons> how?
16:11:08 <brad_larsen> $ cabal -v3 update
16:11:10 <brad_larsen> cabal: K: openFile: does not exist (No such file or directory)
16:11:21 <dons> oh, I think that means your cabal-install needs to be rebuilt
16:11:29 <brad_larsen> hmmm, tried that
16:11:33 <dons> against 6.10.4?
16:11:34 <brad_larsen> and blew away my ~/.cabal dir
16:11:35 <brad_larsen> yes
16:11:49 <dons> try installing the Haskell Platform?
16:11:52 <brad_larsen> cabal-install-0.6.2
16:11:54 <brad_larsen> yes :-(
16:11:57 <brad_larsen> same thing
16:12:06 <dons> did you update Cabal first?
16:12:18 <dons> i've seen a couple of other people get into this state,
16:12:23 <dons> dcoutts, what's the issue?
16:12:23 <brad_larsen> hmm
16:12:28 <brad_larsen> i didn't update cabal
16:12:56 <brad_larsen> i installed ghc 6.10.4 from the generic linux binary distro the other day
16:13:30 <brad_larsen> then installed the haskell platform 2009.2.0.1, which seemed to work fine
16:13:37 <brad_larsen> except cabal-install was busted
16:13:59 <brad_larsen> googled, found someone saying to blow away ~/.cabal/config
16:14:07 <gwern> dons: you want comments here or on the talk apge?
16:14:18 <brad_larsen> did that, fixed some immediate errors from cabal, and i thought it was fixed
16:14:26 <dons> the talk page on haskell.org would be good
16:14:38 <brad_larsen> but then trying `cabal list' or `cabal install PACKAGE' gave me that error I pasted above
16:15:02 <brad_larsen> so I just got the latest haskell-platform, which doesn't build on my system
16:16:01 <sioraiocht> anyone have experience with HaXR, the XML-RPC lib?
16:16:20 <stevan> i ran into the exact same problems with both .1 and .2 brad_larsen
16:16:51 <brad_larsen> network-2.2.1.4 fails to build, saying it can't find Text.ParserCombinators.Parsec (which ghc-pkg says is registered)
16:16:56 <brad_larsen> stevan: any fix for it?
16:18:44 <stevan> not that i know off, i ended up ditching the platform and installed cabal-install alone, that worked.
16:19:07 <dons> brad_larsen: ah, that's to do with having no profiling libs for parsec 3
16:19:23 <dons> and the unix tarball has a bug: it picks up versions of parsec et al already installed
16:19:33 <brad_larsen> oh dear
16:19:34 <dons> wheras it sort of needs to build in a chroot
16:20:02 <dons> if you remove the offending previously-installed libs, you'll be ok
16:20:16 <brad_larsen> ghc-pkg unregister?
16:20:17 <dons> gwern: i'd also welcome general comments, thoughts here.
16:20:19 <dons> yeah.
16:20:40 <dons> gwern: and thoughts on how to gain consensus for the article design
16:24:00 <gwern> dons: http://haskell.org/haskellwiki/Talk:WikipediaArticleDesign
16:24:59 <dons> gwern: could you make those edits? looks great, thanks!
16:25:11 <dons> exceptions is about async exceptions.
16:25:11 * gwern is doing french
16:25:21 <dons> meaning I should do it? :)
16:25:32 <dons> k.
16:26:12 <dons> gwern: re. licensing, haskell was born as an open source, unencumbered response to Miranda.
16:26:28 <gwern> thought it was to unify the research community
16:26:29 <dons> the miranda issue was an important early motivator.
16:26:38 <dons> quite so. that's also part of it.
16:36:36 <dons> gwern: thanks,applied those changes.
16:43:38 <QP> how important is it to close all the running threads before the program ends?
16:45:15 <sjanssen> QP: do you care about the work they're doing?
16:45:43 <QP> not by the time the program is closing
16:45:50 <dons> "      In a standalone GHC program, only the main thread is
16:45:50 <dons>       required to terminate in order for the process to terminate.
16:45:50 <dons>       Thus all other forked threads will simply terminate at the same
16:45:50 <dons>       time as the main thread (the terminology for this kind of
16:45:50 <dons>       behaviour is \"daemonic threads\").
16:45:53 <dons> "
16:46:14 <QP> i'm just wondering if it's considered bad practice?
16:46:18 <dons> nope
16:46:21 <dons> you can rely on it
16:46:34 <brad_larsen> well, I blew away my old ghc 6.10.4 installation, reinstalled that, sans haskell-platform.  installed cabal-install manually; all is well once more.
16:46:36 <QP> ok, cool, that is one less thing to worry about!
16:46:41 <dons> brad_larsen: ok
16:47:35 <brad_larsen> dons: I'll wait for a later release of haskell-platform to try it again :-)
16:47:53 <dons> what distro are you on, btw?
16:51:38 <brad_larsen> dons:  ubuntu 9.04 x86_64
16:51:46 <dons> ok. thanks.
16:52:03 <dons> with debian pushing along, i'm hopeful for Ubuntu binaries for the platform within 12 months
16:52:37 <zsol> brad_larsen: what was the problem exactly?
16:52:37 <lambdabot> zsol: You have 1 new message. '/msg lambdabot @messages' to read it.
16:52:59 <brad_larsen> yeah, would make my life easier.  but ubuntu (and I guess debian) lag behind the latest releases on many packages.  They are still packaging ghc 6.8.2, iirc
16:53:06 <brad_larsen> and emacs 22
16:53:47 <brad_larsen> so I end up installing some programs from source/generic linux binary
17:13:44 <glguy> brad_larsen: didn't emacs just release about last week?
17:14:09 <brad_larsen> glguy: I don't know.  I just grabbed 23.1 tonight
17:14:09 <zsol> yeah and they have some experimental repo set up for ubuntu
17:14:22 <brad_larsen> zsol: do tell
17:14:34 <brad_larsen> zsol: one with newer packages?
17:14:53 <zsol> one for emacs "bleeding edge"
17:15:00 <zsol> apart from the karmic repos
17:15:50 <zsol> deb http://ppa.launchpad.net/ubuntu-elisp/ppa/ubuntu jaunty main
17:16:18 <zsol> I have ii  emacs-snapshot               1:20090730-1~jaunty1         The GNU Emacs editor (development snapshot)
17:16:30 <zsol> that's decently recent
17:17:15 <brad_larsen> hmm.  thanks.
17:17:22 <zsol> no problem :]
17:17:50 <pikhq> zsol: That's like, the day before Emacs 23 came out. XD
17:17:55 <zsol> also there's some tool if you like to install a lot of packages locally from source, which helps you manage them
17:18:12 <zsol> pikhq: it says GNU Emacs 23.1.50.1
17:18:32 <pikhq> So, it's Emacs 23.1.
17:18:43 <zsol> yeah
17:18:44 <pikhq> (for most intents and purposes)
17:19:03 <zsol> yeah for us lowly mortals
17:19:47 <refold> zsol: checkinstall?
17:20:42 <zsol> refold: thanks, that's the one, name's escaped me
17:27:14 <gwern> dons: what is an unlifted type?
17:27:53 <dons> see "unboxed values as first class citizens"
17:28:08 <dons> ghc and lhc allow unboxed types (and the # kind) to be used relatively freely.
17:29:26 <dons> man, i keep getting markdown, mediawiki and trac syntax mixed up
17:29:33 <dons> where is the one true markup!
17:29:58 <gwern> pandoc
17:30:18 <dons> ah, pandoc's extn. of markdown?
17:30:26 <gwern> indeed
17:30:58 <QP> Can anyone explain why haskell doesn't like this: first i say 'type A x = ReaderT Something IO x'
17:31:21 <QP> then i say 'type B x = ReaderT SomethingElse A x'
17:31:45 <dons> mm. cryptol has a new "theorem" keyword
17:31:49 <QP> it's comlaining that in the second def. A hasn't got enough arguments
17:31:54 <dons> allowing properties to be checked along side code
17:31:58 <dons> that'd be useful in haskell :)
17:32:19 <dons> QP: 'type' synomyms can't be partially applied
17:32:39 <dons> so you've got the wrong number of type arguments there somewhere
17:32:44 <dons> check the kind of ReaderT
17:32:52 <dons> :k ReaderT
17:32:54 <lambdabot> * -> (* -> *) -> * -> *
17:33:04 <dons> it takes 3 type arguments
17:33:19 <dons> you should paste the code and full error message on hpaste.org
17:33:21 <QP> yes, and :k A is * -> *, so it should work
17:36:43 <Gracenotes> :k
17:36:47 <Gracenotes> :o
17:38:16 <QP> dons: its on hpaste
17:39:06 <dons> link?
17:40:55 <QP> hpaste.org/fastcgi/hpaste.fcgi/view?id=7831
17:41:05 <sjanssen> QP: you're not allowed to partially apply type synonyms in Haskell
17:41:45 <QP> what does that mean exactly? my type synonyms must be applied as concrete types?
17:41:47 <sjanssen> this restriction is required for decidability of type checking
17:42:25 <sjanssen> QP: type synonyms must be fully saturated in all cases
17:42:30 <QP> surely a few parentheses make it decidable?
17:42:38 <soupdragon> no
17:43:05 <QP> its ReaderT X Inter a, not ReaderT X (Inter a)
17:43:46 <sjanssen> QP: rewrite the first line to 'type Inter = ReaderT Interface IO'
17:44:17 <QP> so i do all my monadic types pointless style?
17:44:23 <QP> ooooo....
17:48:44 <QP> @hoogle hPutStrLn
17:48:44 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
17:48:44 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
17:48:44 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
17:52:16 <zsol> @tell ivanm I think I've found some inconsistency in graphviz' instance Show Label.
17:52:17 <lambdabot> Consider it noted.
17:59:50 <QP> @hoogle liftIO
17:59:51 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
18:00:50 <QP> @hoogle forkIO
18:00:50 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
18:03:17 <hackagebot> yst 0.2.1 - Builds a static website from templates and data in YAML or (JohnMacFarlane)
18:07:07 <Modius> Just out of interest, what editor do hardcore haskellers use?  Is that liksah on your radar?
18:07:53 <soupdragon> anything that syntax colors is fine
18:08:00 <dons> vim and  emacs mostly. yi and leksah are gaining ground (from a small foothold)
18:08:28 <kynky> emacs has good haskell support with haskell plugin
18:09:02 <QP> @hoogle listenOn
18:09:02 <lambdabot> No results found
18:09:31 <QP> i use vim :-)
18:09:50 <QP> not that i'm very hardcore...
18:09:52 <Modius> Is leksah scoped to be powerful enough or is it a newbie toy?
18:10:15 <Modius> I mean is it something you use until you "graduate to emacs" or a plausible endpoint?
18:10:49 <bremner> it depends on what you like better, IDEs or text editors
18:10:57 <kynky> leksah is the future
18:11:14 <kynky> eclipse has good haskell support too i think
18:11:17 <gwern> yi is dying. netcraft confirms it.
18:11:25 <ManateeLazyCat> Have an exist function that match "isDirectory :: FilePath -> Bool" ?
18:11:26 <kynky> but emaca and vim seemmost popular
18:11:32 * bremner has said before he has the idea of using one editor per language bizarre
18:12:12 <kynky> introspection of ide can be handy
18:12:29 <blackdog> Modius: i imagine there are very few haskell hackers who only use haskell. maybe the IDE path makes more sense when you're mainly using one language, like java...
18:12:35 <Botje> @hoogle FilePath -> Bool
18:12:35 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
18:12:35 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
18:12:35 <lambdabot> System.FilePath.Posix hasExtension :: FilePath -> Bool
18:12:40 <Botje> hmm
18:12:45 <Botje> i'd check the system.filepath library, then
18:13:31 <gwern> @hoogle directory
18:13:32 <lambdabot> package directory
18:13:32 <lambdabot> module System.Directory
18:13:32 <lambdabot> System.Posix.Internals Directory :: FDType
18:13:46 <gwern> System.Directory doesDirectoryExist :: FilePath -> IO Bool
18:13:57 <Modius> Maybe a good starting point for all us DevStudio users.
18:14:07 <ManateeLazyCat> gwern: Thanks a lot! :)
18:14:32 <gwern> if you are truly thankful, BRING ME THE HEAD OF WILLY THE MAILBOY
18:14:45 <blackdog> Modius: there are also a lot of libraries that make hacking haskell in emacs more pleasant - i'm using flymake religiously now
18:14:54 <ManateeLazyCat> I'm developing a new Haskell dynamic environment, now editor module have finish.....
18:15:18 <QP> goodnight everybody!
18:15:45 <ManateeLazyCat> blackdog: emacser?
18:15:58 <blackdog> ManateeLazyCat: am i? yes
18:17:20 <ManateeLazyCat> blackdog: My homepage (http://www.emacswiki.org/emacs/AndyStewart), maybe have some code you like.
18:17:55 <ManateeLazyCat> blackdog: Join #emacs if you want talk about Emacs. :)
18:19:36 <gwern> @wn latent
18:19:40 <lambdabot> *** "latent" wn "WordNet (r) 2.0"
18:19:40 <lambdabot> latent
18:19:40 <lambdabot>      adj 1: potentially existing but not presently evident or realized;
18:19:40 <lambdabot>             "a latent fingerprint"; "latent talent"
18:19:40 <lambdabot>      2: not presently active; "latent infection"; "latent diabetes"
18:21:24 <dons> ManateeLazyCat: a dynamic environment? like ghci?
18:21:35 <dons> or an IDE-ish thing?
18:22:43 <ManateeLazyCat> dons: My plan is develop "Dynamic Core" like Yi or XMonad don't need reboot.
18:22:54 <ManateeLazyCat> dons: Then i hacking any Haskell module in it.
18:23:16 <ManateeLazyCat> dons: Example, i have develop finish Editor (gtk2hs) module.
18:23:53 <gwern> I wonder if that xmonad technique works with gtk2hs
18:23:57 <ManateeLazyCat> dons: It not just IDE, it is anything.
18:24:07 <ray> the xmonad technique? passing state on the command lien?
18:24:16 <ray> line.
18:24:33 <gwern> yeah. gtk2hs is fragile
18:24:47 <dons> "just" an IDE:)
18:25:00 <dons> can't be more fragile than the X server
18:25:15 <ray> i will never know what gtk2hs is like :(
18:25:30 <ManateeLazyCat> dons: I will add music-player, IDE, file-manager, IRC-client, mail-client. in it.
18:25:43 <Nafai> ManateeLazyCat is writing Emacs it sounds :)
18:25:44 <ManateeLazyCat> dons: Now just finish editor (like Emaca)
18:25:57 <ManateeLazyCat> Nafai: But powerful than Emacs.
18:26:06 <gwern> how so?
18:26:07 <ray> yeah, the editor was the first part of emacs too
18:26:12 <ManateeLazyCat> Nafai: Emacs do everything with TEXT world.
18:26:22 <lispy> It's not hard to be more powerful than emacs
18:26:26 <ManateeLazyCat> Nafai: In my project, it support multi-media embed.
18:26:39 <ManateeLazyCat> Nafai: So i can develop complete browser in it.
18:26:41 <impl> Emacs has a file manager
18:26:43 <lispy> The question is: Why bother? :)
18:26:44 <impl> a Web browser
18:26:46 <impl> a mail client
18:26:47 <impl> an IRC client
18:26:51 <impl> an MP3 player
18:26:53 <impl> Tetris
18:26:54 <impl> Chess
18:27:00 <ManateeLazyCat> impl: Just in TEXT!
18:27:03 <impl> no
18:27:05 <impl> it does pictures too
18:27:09 <impl> type M-x tetris
18:27:10 <ManateeLazyCat> impl: So
18:27:19 <ManateeLazyCat> impl: Just Text and Static Picture
18:27:33 <impl> well it's not like you need opengl to render tetris.
18:27:34 <ManateeLazyCat> impl: It's not implement problem, it's a DESIGN problem.
18:28:11 <ManateeLazyCat> impl: I try to perfect Emacs before, but i choose create my own last.
18:28:20 <ManateeLazyCat> impl: I use Emacs do everything.
18:28:25 <impl> Emacs is perfect.
18:28:32 <ManateeLazyCat> impl: No
18:28:39 <ManateeLazyCat> impl: Emacs haven't reach perfect.
18:28:51 <ManateeLazyCat> impl: Emacs just perfect in TEXT world.
18:29:16 <impl> I bet emacs can do opengl
18:29:19 <impl> I'm just not sure how yet.
18:29:23 <ni|> lol
18:29:30 <ManateeLazyCat> impl: That's not time problem.
18:29:33 <ni|> emacs ftl, sam ftw
18:29:56 <bremner> emacs is getting faster, but ftl is an exageration
18:30:10 <ManateeLazyCat> impl: Everyone said Emacs can do this, can do that. I ask, how difficult?
18:30:30 <ManateeLazyCat> impl: And the key is "this is DESIGN problem"
18:30:38 <impl> I don't think you make any sense
18:30:46 <ManateeLazyCat> impl: How difficult add multi-thread support in Emacs?
18:31:00 <bremner> ManateeLazyCat: will your editor be as good at text as emacs?
18:31:05 <ManateeLazyCat> impl: http://www.emacswiki.org/emacs/AndyStewart
18:31:06 <malikH> #haskell-hacphi
18:31:22 <ManateeLazyCat> bremner: Yep, i try.
18:31:36 <bremner> ManateeLazyCat: good for you. I wish you luck.
18:32:06 <ManateeLazyCat> impl: http://www.emacswiki.org/emacs/AndyStewart that's my try.
18:32:08 <resistor> hello
18:32:23 <malikH> hi everybody
18:33:18 <malouin> I could swear I remember a haskell library that would check proofs of equivalence of haskell code or something similar, but now I can't find it.  Was I hallucinating, or is there something like that out there?
18:33:45 <impl> ManateeLazyCat: Looks okay to me?
18:33:52 <ray> maybe check the theorem prover category on hackage
18:33:52 <malikH> can anybody explain to me what is functional transformation is, I came across a bunch of papers but can't quite understand?
18:34:44 <dons> malikH: proofs?
18:34:51 <dons> malouin:
18:34:58 <dons> proofs of equivalence for haskell programs?
18:34:58 <ManateeLazyCat> impl: Okay for what?
18:35:01 <copumpkin> malikH: ?
18:35:16 <resistor> so, i'm reading the Building a Bloom Filter chapter in Real World Haskell, and I can't figure out how one of the less-described examples reads
18:35:22 <impl> ManateeLazyCat: for an emacs configuration
18:35:24 <malikH> I mean libraries like strafunski and tabaluga
18:35:44 <resistor> the function is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3133#a3133
18:35:51 <resistor> from here: http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html#id680590
18:35:57 <ManateeLazyCat> impl: I try everything in Emacs before like you said.
18:36:14 <ManateeLazyCat> impl: But i choose leave it last.
18:36:16 <resistor> i'm not understanding what the liftM is doing in there
18:36:40 <ManateeLazyCat> impl: Enough Emacs talk, talk with me at #emacs
18:36:45 <impl> ManateeLazyCat: I don't see why you want an editor that can do everything under the sun
18:36:54 <impl> it's so very anti-UNIX :P
18:37:03 <malouin> dons: this is a really vague memory of something I think I saw about six months ago, but it was a something like quickcheck or compatible with quickcheck that allowed you to specify some rudimentary properties of functions along with proofs that the functions had these properties, and it would check the proofs, something like proof-based unit testing.
18:37:13 <malouin> dons: that is close to your research area anyway, isn't it?
18:37:17 <ManateeLazyCat> impl: Go #emacs ?
18:37:44 <impl> ManateeLazyCat: sorry, I've got some work to do. I don't really want to turn this into a big debate
18:38:18 <malouin> ...something from not-yet-really-usable research project land.
18:38:31 <ManateeLazyCat> impl: Okay.
18:38:39 <resistor> anyone?
18:39:16 <gwern> as esr says, the choice emascers faced was to put everything into emacs, or emacs into everything; and the former was easier
18:39:57 <malouin> oh god, hackage has an Acme namespace now...
18:40:32 <bjorkintosh> have any of you guys here tried atom?
18:40:38 <impl> malouin: \o/ Perl
18:40:49 * malouin originates from perl-land.
18:40:51 * bremner is pretty sure he is made out of atoms
18:40:51 <bjorkintosh> Atom : a domain specific language for hard realtime applications
18:42:07 <ray> malouin: watch for unsafeDestroyUniverse coming soon
18:42:13 <gwern> bjorkintosh: it's a pretty specialized dsl
18:42:43 <gwern> how many #haskellers have need of hard realtime embedded apps? not terribly many
18:42:43 <Baughn> ray: Ack. I just watched that happen.
18:42:51 <bjorkintosh> gwern, have you used it yet?
18:42:52 <bjorkintosh> okay.
18:43:01 * gwern does not... yeah
18:43:08 <Baughn> ray: Fortunately it appears to have been in an unsafeInterleaveIO thunk, and nobody is looking..
18:43:19 <ManateeLazyCat> System.IO.HVFS just a interface?
18:43:33 <ManateeLazyCat> I haven't saw any implement code in it.
18:44:01 <Axman6> ok, logic time. i'm having trouble remembering what (P -> Q) means, could someone give me some haskell, using guards, to explain it? (i think it's something like p `implies` q | q = p | otherwise = True)
18:44:02 <ray> baughn: the problem with destroying the universe is that it requires specialized hardware like a USB hadron collider or something
18:44:27 <Baughn> ray: You don't think a USB chainsaw would do?
18:44:44 <dufflebunk> or just use Clean
18:45:02 <bjorkintosh> clean?
18:45:03 <ray> well, you have to chainsaw so much
18:45:11 <bjorkintosh> it's obsolete.
18:45:12 <ray> it's easier in that case to just terminate the program
18:45:22 <dufflebunk> bjorkintosh: yeah, Clean has a World state thing
18:45:33 <ray> which is what i do if there's no universe destruction implementation handy
18:45:43 <Baughn> ray: Yes, but this is #haskell. We're about /right/, not "easy".
18:45:52 <soupdragon> heh since when
18:46:04 <ray> yeah, but these are *hardware issues*
18:46:07 <ray> icky
18:46:10 <Baughn> soupdragon: ..why do you think there STILL isn't a better record system in?
18:46:18 <Axman6> no one? no haskell translation of (P -> Q)?
18:46:19 <Baughn> soupdragon: It sure isn't for lack of suggestions. ^^;
18:46:39 * Axman6 is disappointed that this sort of talk is always going on in here, until he needs it :(
18:46:46 <soupdragon> False -> _ = True ; _ -> p = p
18:47:07 <soupdragon> False -> _ = True ; True -> p = p
18:47:20 <Axman6> i can handle that, thanks soupdragon
18:47:31 <malouin> :)
18:47:32 <dzlk> Axman6: I'm not sure what you mean by Haskell "translation". Implication could be understood as "if p then q". I'd have to know more about what you're hoping to learn before I know if the answer is "right".
18:48:16 * Axman6 rewrites that into guards in haskell as: p `imp` q | p -> q | otherwise = True
18:48:56 <Baughn> Axman6: ..aagh. Without newlines, that looks /weird/.
18:49:10 <Axman6> yes indeed :)
18:49:12 <lispy> I think it has a typo
18:49:18 <lispy> | p = q ?
18:49:20 <Axman6> uh yes
18:49:28 <Axman6> mixing case and guards
18:49:52 <Baughn> > let x = unsafePerformIO (unsafeDestroyWorld >> return ()) in t <- forkIO (print [x]) >>= killThread
18:49:53 <lambdabot>   <no location info>: Parse error in pattern
18:50:12 <Baughn> Oh. Oops.
18:50:19 <Baughn> ..well, it was probably a bit too dangerous to try anyway
18:57:43 <Baughn> "Strictly speaking, the compiler is allowed to evaluate it if it exists, anywhere." <-- Is this true?
18:58:04 <Baughn> Wait.. the /compiler/?
18:58:09 <lispy> what is it?
18:58:16 <pitufin> buenas
18:58:17 <pitufin> necesito
18:58:26 <pitufin> q me den el comando para poner ircops
18:58:30 <pitufin> porfavor
18:58:35 <Baughn> lispy: I typed 'let x = unsafePerformIO (unsafeDestroyWorld >> return ()) in forkIO (print [x]) >>= killThread' into another channel.
18:58:51 <Baughn> lispy: bd_ responded "You may have already destroyed the world". ;_;
18:58:59 <cangri> melo dan
18:59:00 <cangri> porfa
18:59:27 <Baughn> cangri: ..I'm guessing, but.. /join #freenode
19:09:49 <gwern> man. why is reddit such fail lately?
19:09:57 <gwern> is it just me? is reddit working fien for everyone else?
19:10:45 <ray> technical or spiritual fail?
19:10:48 <ray> it's both for me
19:12:21 <soupdragon> epic fail
19:12:56 <bjorkintosh> gwern, there're numerous subreddits.
19:13:04 <bjorkintosh> are those failing for you as well?
19:13:08 <soupdragon> awesome.reddit.com
19:13:11 <gwern> yeah, and they're all borken
19:13:14 <gwern> can't log in
19:13:41 <ray> instead, you get this blank white page with an error, right?
19:14:41 <Axman6> working fine for me
19:14:43 <gwern> sometimes
19:14:52 <gwern> other times I get an active page, but logging in just hangs
19:14:58 <gwern> or other times I get admin errors
19:15:11 <Gracenotes> hm. nothing wrong here
19:16:15 <ray> gwern, if you are able to renew your internet connection and get a new ip address, it might start working
19:16:41 <gwern> well, I guess I'll find out in a few hours when I switch to wifi
19:16:53 <ManateeLazyCat> Have an exist function that match "filterAndSplitM :: monad m => (a -> m Bool) -> [a] -> m ([a], [a])" ? Thanks!
19:16:55 <ray> that's what i did, based on some internet searching
19:17:17 <ray> it could just be superstition
19:17:47 <ManateeLazyCat> @hoogle "monad m => (a -> m Bool) -> [a] -> m ([a], [a])"
19:17:47 <lambdabot> Parse error:
19:17:47 <lambdabot>   --count=20 ""monad m => (a -> m Bool) -> [a] -> m ([a], [a])""
19:17:47 <lambdabot>              ^
19:18:03 <ManateeLazyCat> @hoogle monad m => (a -> m Bool) -> [a] -> m ([a], [a])
19:18:03 <lambdabot> Did you mean: Monad m => a -> m Bool -> [a] -> m ([a], [a]) /count=20
19:18:03 <lambdabot> No results found
19:18:13 <Axman6> Monad, not monad
19:18:22 <Axman6> it's not case insentitive
19:18:34 <ManateeLazyCat> @hoogle Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
19:18:34 <lambdabot> No results found
19:18:38 <gwern> ManateeLazyCat: did you try lifting filter, and using data.split?
19:20:50 * ManateeLazyCat Looks haven't match function, code self.
19:22:12 <Axman6> > 600000/3000000000
19:22:13 <lambdabot>   2.0e-4
19:22:29 <Axman6> > 600000/3000000000 :: CReal
19:22:31 <lambdabot>   0.0002
19:22:39 <idnar> @type filterM
19:22:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
19:22:53 <idnar> @src filterM
19:22:54 <lambdabot> Source not found. Sorry.
19:22:59 <ray> which package has CReal again?
19:24:22 <Axman6> Numeric i think
19:24:27 <Axman6> @index CReal
19:24:27 <lambdabot> bzzt
19:24:30 <Axman6> bah
19:24:44 <idnar> @hoogle CReal
19:24:45 <lambdabot> No results found
19:24:51 <idnar> it doesn't exist!
19:25:02 <idnar> oh noes!
19:25:03 <gwern> @quote CReal
19:25:04 <lambdabot> <pumpkin> says: we should throw it [CReal] in with Foreign.C.Types to confuse people
19:25:10 <gwern> @quote CReal
19:25:11 <lambdabot> gwern says: *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
19:27:53 <idnar> haha
19:28:02 <ray> @hackage numbers
19:28:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
19:28:07 <ray> looks like it's in there
19:29:38 <ManateeLazyCat> @hoogle ([a], [a]) -> ([a], [a]) -> ([a], [a])
19:29:38 <lambdabot> No results found
19:30:02 <Axman6> is
19:30:04 <Axman6> id*
19:31:38 <Gracenotes> @type (zip &&& zip)
19:31:40 <lambdabot> forall a b b1. [a] -> ([b] -> [(a, b)], [b1] -> [(a, b1)])
19:31:44 <Gracenotes> D:
19:31:59 <Gracenotes> @type (zip *** zip)
19:32:01 <lambdabot> forall a b a1 b1. ([a], [a1]) -> ([b] -> [(a, b)], [b1] -> [(a1, b1)])
19:32:06 <ManateeLazyCat> Have an exist function that match "concatTuple :: ([a], [a]) -> ([a], [a]) -> ([a], [a])" ?
19:32:11 <Gracenotes> wrong idea!
19:32:52 <Gracenotes> > ([1,2], [1,2,3]) `mappend` ([3,4,5], [4,5])
19:32:54 <lambdabot>   ([1,2,3,4,5],[1,2,3,4,5])
19:33:09 <Gracenotes> is this what you had in mind
19:33:32 <ManateeLazyCat> Gracenotes: Thanks! mapppend is i want.
19:34:25 <Gracenotes> and mconcat is [([a], [a])] -> ([a], [a]) here
19:36:31 <Axman6> :t (uncurry zip *** uncurry zip)
19:36:32 <lambdabot> forall a b a1 b1. (([a], [b]), ([a1], [b1])) -> ([(a, b)], [(a1, b1)])
19:36:42 <Axman6> :t (uncurry zip &&& uncurry zip)
19:36:43 <lambdabot> forall a b. ([a], [b]) -> ([(a, b)], [(a, b)])
19:36:57 <Axman6> :t (***)
19:36:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:37:06 <Axman6> :t (&&&)
19:37:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:38:42 <soupdragon> > ([11,22], [1,2,3]) `mappend` ([3,4,5], [44,55])
19:38:43 <lambdabot>   ([11,22,3,4,5],[1,2,3,44,55])
19:39:06 <soupdragon> > (([11,22], [1,2,3]), ([11,22], [1,2,3])) `mappend` (([3,4,5], [44,55]), ([3,4,5], [44,55]))
19:39:08 <lambdabot>   (([11,22,3,4,5],[1,2,3,44,55]),([11,22,3,4,5],[1,2,3,44,55]))
19:39:25 <|zzz|> do lists in haskell have to contain all of the same type?
19:39:32 <Axman6> yes
19:39:36 <Axman6> @src []
19:39:36 <lambdabot> data [] a = [] | a : [a]
19:39:52 <Axman6> all elements must be of the same type 'a'
19:40:31 <|zzz|> i can have [1, 3.14] but not [1, "haskell"]?
19:40:32 <Axman6> |zzz|: you should stick around. you keep coming in, asking questions, and leaving. we're quite happy to keep helping you along the way
19:40:38 <Axman6> correct
19:40:50 <Axman6> (1 would be read as 1.0)
19:41:18 <|zzz|> Axman6: oh are you already fed up with my noobiness? :P
19:41:32 <Axman6> not at all, we welcome it here ;)
19:41:39 <|zzz|> ok
19:41:47 <Axman6> so stick around and keep asking questions. that's what we're here for
19:42:20 <Gracenotes> not sure if you've gotten to typeclasses, but any type that's in the Num typeclass can be translated from a literal, like 22
19:42:58 <SamB> at least, as far as Haskell knows it can
19:43:11 <SamB> though it doesn't tend to work too well with Galois Fields etc. ...
19:43:16 <Gracenotes> for example, Double, Integer, and Complex Double are all instances of the Num typeclass. so "2" has a meaning in all of them
19:44:02 <Gracenotes> for Double, it would be translated to 2.0. For Integer, it would be just 2. for Complex Double, it would be 2.0 + 0.0i. So 1 can be in the same list as 3.14 because both are floating numbers
19:44:56 <Axman6> > read "3.141592" :: Complex Double
19:44:57 <lambdabot>   * Exception: Prelude.read: no parse
19:45:01 <Gracenotes> although... if you type in 10+10 in GHC, it will tell you the answer by assuming they are Integers, since it has to go with a specific type
19:45:01 <Axman6> :(
19:45:09 <Axman6> > read "3.141592 :+ 0" :: Complex Double
19:45:10 <lambdabot>   3.141592 :+ 0.0
19:45:34 <Gracenotes> > pi :: Complex Double
19:45:35 <lambdabot>   3.141592653589793 :+ 0.0
19:48:21 <|zzz|> do types in haskell extend from one superclass (like Object in java) so you can make one function deal with both strings and integers?
19:48:29 <gwern> @quote Galois
19:48:29 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
19:48:42 <Gracenotes> heh
19:48:47 <gwern> |zzz|: generally you design your functions and types differently
19:48:50 <gwern> than in java
19:49:47 <|zzz|> so no?
19:49:49 <Gracenotes> to make a function deal with more than one type, you can use various kinds of polymorphism. But it's different from Java.
19:49:51 <sjanssen> |zzz|: Haskell has polymorphism, but in a different way from Java
19:49:54 <gwern> |zzz|: for example, if you want to make one function dealing withe either strings or integers, then maybe you would use something like foo :: Either String Integer -> SomethingElse
19:50:02 <sjanssen> |zzz|: it has no universal type like Object
19:50:09 <gwern> and then your case expression would dispatch
19:50:39 <edwardk1> gah what i hate about template haskell is that by the time you get done the code doesn't resemble the agony it took to generate
19:51:05 <sjanssen> edwardk1: what I hate about TH are all the arbitrary restrictions that aren't documented anywhere
19:51:06 <gwern> really? I hate its general bugginess and sharp edges
19:51:15 <edwardk1> gwern: that too
19:51:37 <edwardk1> i'musing template haskell to generate typeable instances so i'm generally playing with two kinds of fire at the same time ;)
19:52:00 <Gracenotes> |zzz|: to make a "combine" function that both adds numbers and appends strings, you might make a typeclass with it. class Combine where combine :: a -> a -> a.
19:52:02 <gwern> like that one time I tried to evaluate a Map at compile time for xmonad - oops, turns out you can't use, in a TH expression, something defined elsewhere in the same bloody module!
19:52:17 <Gracenotes> to make it work with strings, instance Combine String where combine a b = a ++ b
19:52:23 <edwardk> (i needed typeable instances for some higher order types, and its been an all day adventure to get it right)
19:52:37 <Gracenotes> or numbers, instance Num a => Combine a where combine a b = a + b
19:52:49 <edwardk> gwern: yeah well that particular feature is well documented
19:52:50 <edwardk> =)
19:52:54 <Gracenotes> .... nooooooooooooooo
19:53:04 <gwern> which makes it awwwwrriiiiiggght
19:53:44 <edwardk> gwern: well, to be fair, i have trouble coming up with a world in which it can work ;) since you'd basically have to take some sort of fixed point of the template haskell expansion process
19:54:29 <edwardk> since you'd want TH definitions in the module to see other TH definitions in the module, etc. but since you can reify, you get all sorts of russell's paradox like things you can do
19:55:05 <gwern> we're running code at compile-time; of course we're exposing ourselves to danger
19:55:20 <gwern> (sometimes I think we ought to just have untyped scheme-like macros)
19:55:23 <sjanssen> gwern: danger and sanity are two different things
19:55:32 <ray> there's a man who lives a life of danger
19:55:44 <ray> (template haskell man)
19:55:48 <edwardk> gwern: yes, but there are places where the semantics of what certain things would mean is completely crazy once you remove the staging. i accept the fact that they had to come up with some set of limitations to make it work
19:56:03 <SamB> sjanssen: so are danger and safety ;-)
20:07:15 * ManateeLazyCat pasted "My code" at http://paste2.org/get/357511
20:07:16 <ManateeLazyCat> Above code have two functions that filter and split array. Enjoy! :)
20:08:50 * ManateeLazyCat pasted "Utils.hs" at http://paste2.org/get/357512
20:08:51 <ManateeLazyCat> Above is utils functions for my project, hope have some help. Enjoy! :)
20:13:45 <sjanssen> ManateeLazyCat: minor nit: you're splitting lists, not arrays
20:14:07 <ManateeLazyCat> sjanssen: Oh, typo. :)
20:14:18 <ManateeLazyCat> should be list.
20:14:18 <sjanssen> ManateeLazyCat: filterSplit is Data.List.partition
20:14:35 <sjanssen> but I don't think there's a partitionM
20:14:57 <ManateeLazyCat> sjanssen: Oh, i create partition again.
20:15:16 <ManateeLazyCat> sjanssen: I should ask in IRC before i create it.
20:16:17 <wgsilkie> Why would anyone want to use Hugs over GHCi?
20:16:31 <gwern> wgsilkie: windows integration?
20:16:54 <sjanssen> wgsilkie: Hugs is smaller in terms of disk used.  It supposedly loads source files more quickly as well
20:18:06 <wgsilkie> Ah.
20:19:02 <[zzz]> also i find hugs's error messages more helpful than ghci's
20:20:17 <ray> @ghc
20:20:18 <lambdabot> ghc says: Data constructor does not return its parent type
20:20:40 <ray> ah, those crazy ghc error messages
20:23:05 <sjanssen> Hugs error messages are generally more simple, but GHC's contain more detail
20:23:18 <sjanssen> you have to practice at interpreting GHC's errors
20:24:42 <SamB> and it's anyone's guess which one will report an error like the one you meant ;-)
20:29:20 <jonzim> ehh
20:29:23 <jonzim> hello?
20:29:32 <sjanssen> hello?
20:29:38 <jonzim> oh hi
20:30:04 <jonzim> I have no idea how to use IRC, hooray
20:30:21 <SamB> hooray!
20:30:25 * SamB licks lips
20:31:30 <Axman6> 'lo jonzim
20:31:39 <jonzim> oh hello
20:32:17 <Axman6> got haskell questions for us?
20:32:23 <jonzim> I just tried installing cabal on my computer (ubuntu) and that went boom, although I probably shouldn't have tried because I had no idea how to do that either
20:32:44 <jonzim> :D being clueless is fun
20:33:07 <Axman6> cabal-install? yeah, that can be fun
20:33:26 <Axman6> i suggest you go and get the haskell platform: http://hackage.haskell.org/platform/
20:34:31 <jonzim> ooh
20:35:52 <wgsilkie> How can I make a list of one-digit integers from the digits of a multiple-digit integer?
20:36:18 <Axman6> > map digitToInt . show $ 1234
20:36:19 <lambdabot>   [1,2,3,4]
20:36:28 <Axman6> > map digitToInt . show $ (-1234)
20:36:29 <lambdabot>   [* Exception: Char.digitToInt: not a digit '-'
20:36:31 <Axman6> :(
20:36:36 <wgsilkie> @digitToInt
20:36:37 <lambdabot> Unknown command, try @list
20:36:45 <jonzim> thank you, hopefully that works better than the instructions on http://www.haskell.org/haskellwiki/Cabal-Install did for me
20:37:06 <wgsilkie> Thanks, Axman6.
20:37:47 <ray> > let f n = (,) (map digitToInt . show $ abs n) (signum n) in f (-1234)
20:37:48 <lambdabot>   ([1,2,3,4],-1)
20:38:01 <ray> in case you neeeeeeeeeeeeeeeeeeeeeeeeeeeeed sign information
20:38:18 <Axman6> :)
20:42:04 <erikc> Qi abandoned, another Lisp bites the dust
20:47:26 <[zzz]> here: http://www.haskell.org/haskellwiki/99_questions/11_to_20 what's the difference between problem 11 and 13?
20:54:32 <mmorrow> > 0 == (1e-42 :: CReal)
20:54:33 <lambdabot>   True
20:54:38 <mmorrow> underflow!
20:54:49 <mmorrow> > 0 == (1e-42 :: Double)
20:54:51 <lambdabot>   False
21:00:11 <wgsilkie> Can someone explain this error from GHCi to me? <http://paste.cluenet.org/2412>
21:00:40 <kpreid> type mismatch between two parts of your program
21:01:10 <blackdog> assuming you need to call haskell from C: if you don't want to use ghc to do linking, is there a magic incantation to let gcc build and link all the files itself?
21:01:14 <Axman6> you want (sum . take n) (probably)
21:01:31 <kpreid> I can never remember which is what; my solution is generally to add type signatures (constraining where the inference will occur) until the conflict is obvious
21:01:46 <dufflebunk> blackdog: just include the .o files on the ghc command line
21:01:58 <wgsilkie> I'm not using it with C.
21:02:06 <dufflebunk> and also and -l and -L you'd normally have with gcc
21:02:23 <blackdog> dufflebunk: that's what i'm trying to avoid. I want to ship a .o file that can be linked with normal C programs by gcc
21:02:52 <dufflebunk> Oh, you want to use haskell as a module in C. I've never done that, sorry.
21:03:07 <blackdog> yeah. i'll keep digging, thanks.
21:03:35 <dufflebunk> I'm pretty sure I've come across docs about that though
21:04:07 <blackdog> it gets a fair way along, it's just missing ghc-specific symbols.
21:04:23 <wgsilkie> I'm *NOT* using C.  Just Haskell.
21:04:36 <Axman6> wgsilkie: no one it talking to you about C
21:04:50 <Axman6> there are other people in here, talking about other things
21:06:14 <wgsilkie> Oh, I got lost.
21:06:15 <wgsilkie> Sorry.
21:07:19 <Axman6> wgsilkie: you want to use map (sum . take n) i think
21:07:22 <wgsilkie> I've seen people highlight the person their talking to, after someone starts a conversation or asks a question, to avoid confusion.
21:07:28 <wgsilkie> I got it.
21:48:10 <hackagebot> hack-handler-evhttp 2009.8.2 - Hack EvHTTP (libevent) Handler (BrandonBickford)
21:49:45 <copumpkin> heh
21:49:58 <copumpkin> @hackage hack-handler-evhttp
21:49:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hack-handler-evhttp
22:20:42 <hydo> Using record syntax types, is there a way to have two or more types that use the same named parameters or is this a sign that I need to rethink the design?  Example: data SMsg { "name" :: String, ...}  data RMsg { "name" :: String, ... } throws a warning.
22:22:26 <dibblego> class Nameable n where name :: n -> String
22:23:19 <copumpkin> hydo: you wouldn't have quotes there, by the way
22:23:47 <copumpkin> hydo: what dibblego said is the only real way to do that, and by using that technique you lose the easy record update syntax
22:23:57 <hydo> copumpkin: oh yea, right... was going from memory. :)
22:25:12 <hydo> Time to think harder, apparently.
22:25:30 <copumpkin> well, you could approximate the update syntax too in the typeclass
22:25:51 <copumpkin> http://hackage.haskell.org/package/data-accessor is supposed to be quite good
22:26:19 <hydo> One last question: I keep looking over the various howtos, tutorials, etc. and I don't see the answer: Is there a way to use these types but not initialize every element without throwing a warning?
22:26:29 <hydo> copumpkin: hrm... looking.
22:26:31 <copumpkin> how do you mean?
22:26:36 <copumpkin> not initialize?
22:27:20 <hydo> copumpkin: data Fx { name :: String, password :: String } then create an Fx without giving a value to password.
22:27:33 <copumpkin> not really
22:27:39 <copumpkin> unless you consider undefined
22:28:00 <copumpkin> you probably want to use Maybe String instead of String
22:28:11 <copumpkin> which explicitly indicates the possible absence of the value
22:28:21 <copumpkin> @src Maybe
22:28:22 <lambdabot> data Maybe a = Nothing | Just a
22:29:27 <hydo> copumpkin: I thought about that, but then I'd be tempted to, instead of case-ing every dereference, doing fromJust on the names and that seems even more sloppy.  I have to keep my laziness in check sometimes.  Perl tainted me :)
22:29:40 <copumpkin> well
22:29:43 <hydo> unless there is a more elegant solution...
22:29:53 <copumpkin> Maybe has a lot of useful instances that save you from doing that
22:29:57 <copumpkin> :t maybe
22:29:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:29:59 <copumpkin> :t fromJust
22:30:01 <lambdabot> forall a. Maybe a -> a
22:30:12 <copumpkin> Maybe is also an instance of Functor, Applicative, Monad, and MonadPlus
22:30:36 <copumpkin> which means you can easily operate on it
22:30:47 <copumpkin> > fmap (+1) $ Just 5
22:30:48 <lambdabot>   Just 6
22:31:00 <copumpkin> > liftA2 (+) (Just 5) (Just 7)
22:31:01 <lambdabot>   Just 12
22:31:07 <copumpkin> > liftA2 (+) Nothing (Just 7)
22:31:08 <lambdabot>   Nothing
22:31:11 <hydo> Heh, Haskell really is a lot like chess.  You can learn the rules in a matter of hours/minutes, but mastery will take you far longer.
22:32:07 <copumpkin> yeah :)
22:32:22 <copumpkin> but you can do all sorts of fun things with the various instances
22:32:44 <copumpkin> which means that it's not really that burdensome to pass Maybes through your program
22:34:10 <hydo> Ok, I'm going to make coffee and commit a few hours to really congeal monads/functors/etc. in my head.  That seems to be my biggest limitation in haskell at the moment.
22:36:23 <copumpkin> hydo: I'd start with Functors and move up
22:39:17 <Berengal1> Applicative is where the magic's at
22:39:40 <Peaker> hydo: most minimalistic languages are like chess in that sense :)
22:39:46 <Berengal1> Or perhaps applicatives just held the missing pieces I needed to grok monads...
22:39:49 <Peaker> C takes years to master, too
22:43:10 <pikhq> Programming takes years to master.
22:43:22 <vegai> decades
22:43:39 <vegai> for me, centuries ;/
22:43:59 <pikhq> vegai: I've rather recently started my second decade of programming.
22:44:00 <pikhq> So.
22:44:28 <vegai> what do you regard as the starting point?
22:44:41 <vegai> first professional gig... or first line of code?
22:44:53 <pikhq> First line of code.
22:45:00 <vegai> ok
22:45:10 <copumpkin> I've been programming for ages but I was a pretty shitty programmer for most of that
22:45:30 <vegai> I guess I'm on my second as well then
22:45:30 <vegai> or third
22:45:34 <Peaker> vegai: "professional gig" means little, IMO. People can do "professional" work at home, and non-professional work at work
22:45:52 <pikhq> copumpkin: You can't expect much from a 10 year old. :P
22:46:03 <copumpkin> :)
22:46:11 <Peaker> I guess almost any language takes days to learn, and years to master.  But C is surprisingly so, being so minimalistic
22:56:57 <erikc> i think mastery comes from underlying the picture 1-2 levels lower than what you are mastering
22:57:55 <erikc> understanding the under...
22:58:20 <erikc> in C's case, understanding how it maps to assembly language
22:58:34 <erikc> and therefore understanding how hardware works
22:58:56 <BMeph> erikc: s/hardware/a PDP-11 emulator/ ;)
22:59:09 <erikc> sure
23:00:07 <erikc> otherwise you get burned in odd ways you dont understand
23:00:26 <copumpkin> like in BURN NOTICE!!
23:01:36 <mmorrow_> copumpkin: heh, good show
23:01:47 <mmorrow_> copumpkin: especially since bruce campbell's in it
23:01:56 <copumpkin> which one is that?
23:02:01 * BMeph approves of any TV show featuring "The Chin"...
23:02:05 <Peaker> damnit. C doesn't complain when you have { int blah; { int blah = blah; ... } } -- you just get the wrong value!   I had this because a macro used:  #define BLAH(_name) do { int name = (_name); /* Avoid double referring to _name */ .. }   talk about mastering C ...
23:02:09 <Peaker> just got burned :-P
23:02:11 <mmorrow_> .. and the army of darkness!
23:02:18 <copumpkin> :o
23:02:22 * mmorrow_ finds a link immediately
23:02:43 <Peaker> BLAH(name) expanded to:   int name = name; /* actually I had a pointer, and it got a random value */
23:03:06 * mmorrow_ waits while his firefox garbage collects
23:03:19 <Saizan> is there some way to tell which type "readsPrec_abou" from a .prof file belongs to?
23:03:39 * BMeph has an autographed copy of "If Chins Could Kill", Bruce's autobiography
23:03:39 <mmorrow_> copumpkin: http://www.imdb.com/title/tt0106308/
23:04:17 <Axman6> anyone know who's responsible for leksah? the OS X binary doesn't work
23:04:46 <mmorrow_> copumpkin: basically, it goes like this... he works at a walmart, goes back in time to the middle ages, has a shotgun and chainsaw, his hand gets hacked off iirc, he attaches the chainsaw to his hand, and then the army of darkness attack
23:04:59 <copumpkin> :o
23:05:02 <mmorrow_> great movie
23:05:08 <copumpkin> oh I've seen that
23:05:12 <mmorrow_> totally
23:05:12 <BMeph> Even better - the show: http://www.hulu.com/show/105
23:05:15 <copumpkin> it's awesome
23:05:48 <erikc> mmorrow_: his hand is hacked off in Evil Dead 2, technically
23:05:52 <BMeph> "This is my BOOM-STICK!" ;)
23:06:26 <mmorrow_> haha
23:06:33 <c_wraith> Eh.  Does anyone remember anything but Army of Darkness, really?
23:06:56 <copumpkin> I don't remember much
23:06:57 <erikc> evil dead 2 was good
23:07:00 <copumpkin> beyond the general idea
