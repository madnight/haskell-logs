00:14:00 <sjanssen> damajah: Cabal is the only Haskell build system with any market share
00:14:25 <damajah> i will check it out thanks
00:15:37 <dons> please use cabal.
00:15:44 <dons> there's tshirts
00:17:55 <dons> literally, http://www.spreadshirt.com/us/US/-/Detail-3376/Marketplace/Products/detail/article/3612542 :)
00:19:26 <mxc> so you can put designs up and then get a cut of revenue or something?
00:22:55 <mxc> thats actually pretty cool
00:23:55 <Beelsebob> "tailored fit" :(
00:24:02 <Beelsebob> (means, shows off bob's moobs)
00:24:08 <dons> no, there's no cut.
00:24:22 <dons> Beelsebob: you can stick the design on any tshirt in their catalogue though
00:24:37 <dons> i picked the same style shirt as the (famous??) xmonad tshirt
00:24:44 <Beelsebob> :)
00:24:56 * dons hopes to be pimping some cabal threads at icfp
00:28:17 <mxc> i wonder what a bamboo shirt feels like
00:28:35 <dons> oh hmm
00:28:45 <dons> i wanted to get haskell badges to hand out at icfp
00:29:01 <dons> you can get a box full for a few $
00:29:10 <dons> better order those.
00:29:17 <mxc> can hand out dog t-shirts
00:29:37 <Beelsebob> what would be better would be military insignias for people's sleve
00:29:46 <Beelsebob> "hi, I'm a haskell sargent"
00:29:47 <Beelsebob> >.>
00:29:55 <Beelsebob> (sp)
00:29:56 <dons> hehe
00:31:02 <mxc> hm
00:31:34 <mxc> messenger bags would be cool, probably pricey though
00:31:39 <coRayNbow> dons: why handing out Haskell badges?
00:31:51 <coRayNbow> you should be selling SPJ Action Figures instead! :p
00:32:43 <damajah> is spj simon peyton jones?
00:33:22 <artagnon> I need some help implementing an algorithm... just hints, NOT the solution. I want to find out all the primes b/w 1 and 200000: For this, I'll construct a list that contains all the numbers, and filter out primes... after filtering each prime, I want to further reduce the list by removing all the multiples of that prime, and then proceed to find the next prime. I've tried  http://pastebin.com/d183dd482 -- But I think I need to 
00:33:35 <coRayNbow> damajah: yes
00:33:47 <damajah> hes a legend, does he chat here?
00:34:21 <artagnon> Asserting whether or not a number is prime is an expensive operation
00:34:35 <artagnon> so I want to reduce the cost by not checking multiples of primes I've found already
00:35:11 <artagnon> In an imperative language, I'd call the list by a variable, and then destructively reduce it using simple operations. I want to know "The Haskell Way" of doing it.
00:35:13 <coRayNbow> damajah: as far as I know, no
00:35:15 <erikc> or berets!
00:35:24 <artagnon> er, I meant I'd bind the list to a variable
00:36:04 <artagnon> In http://pastebin.com/d183dd482 -- filter has no effect, because the list itself will contain just primes
00:36:26 <artagnon> b'cos of the assertPrime clause
00:36:52 <ManateeLazyCat> How do you use Arrow? Any practice tips or superstar functions?
00:41:05 <mxc> artagnon - i dont do much with list comprehensions, and not sure if this would work, but might be able to use something like
00:41:41 <mxc> [(p * k) | k <- [2..], p <- primes] to calcuate a lazy list of all the multiples
00:42:34 <mxc> it wont be sorted though so naively checking each number against that list would blow up
00:42:45 <artagnon> mxc: But to find primes, I need to go through the whole list anyway... which is what I want to avoid in the first place.
00:43:00 <mxc> you said you didn't want an answer, just a hint :)
00:43:11 <artagnon> oh :)
00:43:18 <mxc> and i'm no sure if it would work anyway, jsut an idea
00:43:47 <artagnon> so I have to find primes using some trick
00:43:52 <artagnon> damn, Haskell can be hard
00:44:09 <mxc> since you can have something like let {mults = [(p * k) | k <- [2..], p <- primes]; primes = f mults}
00:44:29 <mxc> so you essentially have 2 mutually recursive, lazy functions
00:44:55 <ManateeLazyCat> @let firstMap = map . first
00:44:56 <lambdabot>  Defined.
00:45:00 <ManateeLazyCat> :t firstMap
00:45:00 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
00:45:23 <mxc> artagnon lookup memoization with lazy maps, might give you an idea
00:45:41 <artagnon> I think I have a clearcut imperative idea. Define l=[1..] then find that y=2 is prime in l then filter(\x -> x `mod` 2 /= 0) l then find that y = 3 is prime in l then filter(\x -> x `mod` 3 /= 0) l and so on
00:45:50 <artagnon> mxc:
00:45:52 <artagnon> I see
00:46:04 * artagnon looks up memoization
00:46:19 <ManateeLazyCat> @src proc
00:46:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:46:22 <artagnon> Any recommended reading/ exercises? I want to learn The Haskell Way.
00:47:44 <mxc> maybe something like foldr (\s n -> (filter (\x -> x `mod` n /= 0) . s) [2..]
00:48:20 <ManateeLazyCat> @let idA = proc a -> returnA -< a
00:48:20 <lambdabot>   Parse error
00:48:37 * artagnon stares hard at the example mxc gave
00:49:04 <mxc> @let mkFilter n = foldr (\s n -> (filter (\x -> x `mod` n /= 0) . s)  id [2..]
00:49:04 <lambdabot>   Parse error
00:49:17 <mxc> @let mkFilter n = foldr (\s n -> (filter (\x -> x `mod` n /= 0) . s))  id [2..]
00:49:18 <lambdabot>  <local>:9:29:
00:49:18 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -...
00:50:32 <artagnon> The problem with the earlier example is that I don't really want to apply f to mults... I want to apply it on non-mults :|
00:50:43 <ManateeLazyCat> @keyword
00:50:43 <lambdabot> Unknown command, try @list
00:50:49 <ManateeLazyCat> @list
00:50:49 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:51:07 <dons> coRayNbow: i just think it would be cool to have haskell badges at ICFP :)
00:51:08 <dons> great win
00:53:21 <ManateeLazyCat> :t (-<)
00:53:23 <lambdabot> Not in scope: `-<'
00:53:45 <ManateeLazyCat> @type proc
00:53:46 <lambdabot> Not in scope: `proc'
00:53:57 <ManateeLazyCat> @src proc
00:53:57 <lambdabot> Source not found. That's something I cannot allow to happen.
00:54:04 <ManateeLazyCat> @type (-<)
00:54:06 <lambdabot> Not in scope: `-<'
01:00:06 <mxc> artagnon - i got it..
01:00:12 <mxc> i was wrong about the folds
01:00:19 <mxc> but, i was right about composing the filter function
01:00:29 <mxc> just think about a way to recur and composing functions
01:00:35 <mxc> also, ghci is your friend in this case
01:03:09 <ulfdoz> 10:00 da war ich doch noch gar nicht hier.
01:03:21 <ulfdoz> ewin, sorry, good morning.
01:04:55 * ManateeLazyCat Research Arrow, it very interesting...
01:15:44 <stanv> Hello. There is Exercise 10.35: Show that the function `flip' satisfies: flip . flip = id. Hint: to show this you might want to prove that for any f: flip (flip not) = f.   I think there are inaccuracy: for any f that take exactly two arguments, right ?
01:16:05 <stanv> flip (flip f) = f
01:17:06 <dibblego> stanv, all Haskell functions take one argument
01:17:42 <dibblego> stanv, a function :: a -> b -> c is actually :: a -> (b -> c)
01:19:47 <stanv> dibblego: but, ghci doesn't know even type of expression: Prelude> :t (flip . flip) not
01:19:55 <stanv> Couldn't match expected type `a -> c' against inferred type `Bool'
01:21:05 <dibblego> stanv, right but it does know the type of the expression (flip . flip) (+)
01:22:32 <gwern> :t (flip . flip) (+)
01:22:34 <lambdabot> forall a. (Num a) => a -> a -> a
01:22:35 <stanv> I don't know how to prove flip . flip = id for `not'
01:22:47 <dons> mmm
01:23:11 <dibblego> stanv, sorry, I didn't see 'not' in your original question -- that sounds wrong
01:23:29 <gwern> @check \x -> (flip . flip) x == x
01:23:30 <matsuura> I will laugh at your dead corpse!
01:23:31 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> c)
01:23:31 <lambdabot>    arising from a use...
01:24:59 <Ke> > ((flip . flip) (+)) 1 1
01:25:00 <lambdabot>   2
01:25:10 <Ke> > ((flip . flip) not) True
01:25:11 <lambdabot>   Couldn't match expected type `a -> c'
01:25:13 <Ke> !
01:25:16 <ManateeLazyCat> @let ifA x f g h = if (arr f x) then g else h
01:25:17 <lambdabot>  Defined.
01:25:33 <ManateeLazyCat> > ifA "a" (return True) "True" "False"
01:25:35 <lambdabot>   "True"
01:25:42 <ManateeLazyCat> > ifA "a" (return False) "True" "False"
01:25:43 <lambdabot>   "False"
01:25:48 <gwern> > ((flip . flip $ not) True
01:25:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:25:56 <Ke> stanv: so I think you can just write out the result and check that it matches for all cases
01:25:59 <gwern> > ((flip . flip) $ not) True
01:26:00 <lambdabot>   Couldn't match expected type `a -> c'
01:26:41 <gwern> oh, duh. not is monadic, flip expects a dyadic or higher function
01:26:41 <stanv> In exercise stated : "...for any f...". I think author mean : "for any f that takes two arguments"
01:26:43 * gwern feels stupid
01:27:38 <stanv> i don't know how to prove this :(
01:28:10 <Ke> stanv: probably 2 or more
01:28:16 * coRayNbow kicks ghc-pkg
01:30:05 <stanv> Ke: right: two or more: :t (flip . flip) zip5 works as expected.
01:31:32 <stanv> ..but... flip rotate only first two arguments: (flip) zip5 :: [b] -> [a] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
01:33:52 * coRayNbow doesn't get it... ghc cannot find XMonad.Hooks...
01:36:17 <adu> did you add it to the cabal file? or command options?
01:39:36 * coRayNbow used makepkg on the PKGBUILD file in Arch
01:48:11 <stanv> one more: Prove that: curry . uncurry = id. I can give many examples where this equation fail.
01:54:18 <mmorrow> @unpl (curry . uncurry)
01:54:18 <lambdabot> (\ c -> curry (uncurry c))
01:55:14 <gwern> @hoogle a-> [a] -> [(Int,a)]
01:55:15 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
01:55:15 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
01:55:15 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
01:55:40 <gwern> @hoogle a-> [a] -> Int
01:55:41 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
01:55:41 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
01:55:41 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:55:57 <gwern> hm.
01:56:59 <mmorrow> @type \a -> filter ((==a) . snd) . zip [0..]
01:57:01 <lambdabot> forall a b. (Eq b, Num a, Enum a) => b -> [b] -> [(a, b)]
01:57:05 <mmorrow> ?
01:57:21 <mmorrow> @type \a -> filter ((==a) . snd) . zip [(0::Int)..]
01:57:23 <lambdabot> forall b. (Eq b) => b -> [b] -> [(Int, b)]
01:57:40 <gwern> > let getFrequency str = let str' = sort $ words str in map (λx →  (length $ elemIndices x str', x)) str' in getFrequency "foo foo bar bar bar bar baz"
01:57:42 <lambdabot>   Pattern syntax in expression context:
01:57:42 <lambdabot>      λx -> (length $ elemIndices x s...
01:57:50 <gwern> > let getFrequency str = let str' = sort $ words str in map (\x →  (length $ elemIndices x str', x)) str' in getFrequency "foo foo bar bar bar bar baz"
01:57:52 <lambdabot>   [(4,"bar"),(4,"bar"),(4,"bar"),(4,"bar"),(1,"baz"),(2,"foo"),(2,"foo")]
01:58:14 <gwern> > let getFrequency str = let str' = sort $ words str in map (\x →  (length $ elemIndices x str', x)) $ nub str' in getFrequency "foo foo bar bar bar bar baz"
01:58:16 <lambdabot>   [(4,"bar"),(1,"baz"),(2,"foo")]
01:58:36 <mmorrow> @type M.toList . foldl' (\m a -> M.insertWith' (+) a 1 m) mempty
01:58:38 <lambdabot> forall b a. (Num a, Ord b) => [b] -> [(b, a)]
01:58:46 <gwern> you and your monoids
01:58:57 <mmorrow> wee
01:59:15 <adu> hi gwern
01:59:55 <gwern> hi adu
02:00:20 <mmorrow> @let histo = M.toList . (\m -> let n = fromIntegral(M.size m)::Double in fmap ((/n).fromIntegral) m) . foldl' (\m a -> M.insertWith' (+) a 1 m) mempty
02:00:21 <lambdabot>  Defined.
02:00:44 <mmorrow> > histo (take 100000 . randomRs ('a','e') $ mkStdGen 98279874)
02:00:46 <lambdabot>   [('a',3965.4),('b',4001.4),('c',4016.2),('d',4052.4),('e',3964.6)]
02:00:56 <mmorrow> gah! i botched histo
02:01:51 <gwern> looks like it
02:02:04 <gwern> maybe put a words in front to operate on the word level and not character
02:02:11 <mmorrow> @let hist = M.toList . (\m -> let n = fromIntegral(M.fold (+) 0 m)::Double in fmap ((/n).fromIntegral) m) . foldl' (\m a -> M.insertWith' (+) a 1 m) mempty
02:02:12 <lambdabot>  Defined.
02:02:14 <mmorrow> > histo (take 100000 . randomRs ('a','e') $ mkStdGen 98279874)
02:02:16 <lambdabot>   [('a',3965.4),('b',4001.4),('c',4016.2),('d',4052.4),('e',3964.6)]
02:02:17 <mmorrow> > hist (take 100000 . randomRs ('a','e') $ mkStdGen 98279874)
02:02:19 <lambdabot>   [('a',0.19827),('b',0.20007),('c',0.20081),('d',0.20262),('e',0.19823)]
02:02:22 <mmorrow> there
02:02:53 * gwern wonders why # of occurrences, an obvious Int, is being done by a Double producing function
02:03:05 <mmorrow> i'm normalizing the distribution
02:03:18 <mmorrow> > sum . fmap snd $ hist (take 100000 . randomRs ('a','e') $ mkStdGen 98279874)
02:03:20 <lambdabot>   1.0
02:03:56 <gwern> why would you normalize it?
02:04:13 <mmorrow> because that's the definition of histogram ;)
02:04:29 <mmorrow> say you want to plot a bunch of these
02:05:09 * gwern doesn't, but go on
02:05:40 <mmorrow> then you can compare the relative frequencies of elements between histograms, no matter the actual number of each element in different histograms
02:05:59 <mmorrow> > hist ['a','b']
02:06:01 <lambdabot>   [('a',0.5),('b',0.5)]
02:06:10 <mmorrow> > hist (take 100000 (cycle ['a','b']))
02:06:12 <lambdabot>   [('a',0.5),('b',0.5)]
02:06:42 <mmorrow> but yeah, you don't have to normalize
02:07:57 <mmorrow> well, depending what you're after you either should or shouldn't.
02:12:30 <mmorrow> , vacuum (cycle ['a','b'])
02:12:33 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,0]),(3,[])]
02:13:31 <mmorrow> , vacuum ((concat . repeat) ['a','b'])
02:13:37 <lunabot>  Killed.
02:14:09 <mmorrow> > hist (take 100000 ((concat . repeat) ['a','b']))
02:14:11 <lambdabot>   [('a',0.5),('b',0.5)]
02:14:15 <mmorrow> > hist (take 1000000 ((concat . repeat) ['a','b']))
02:14:17 <lambdabot>   [('a',0.5),('b',0.5)]
02:14:21 <mmorrow> > hist (take 10000000 ((concat . repeat) ['a','b']))
02:14:27 <lambdabot>   mueval-core: Prelude.read: no parse
02:14:27 <lambdabot>  mueval: ExitFailure 1
02:14:34 <mmorrow> > hist (take 10000000 (cycle ['a','b']))
02:14:40 <lambdabot>   mueval-core: Prelude.read: no parse
02:14:40 <lambdabot>  mueval: ExitFailure 1
02:14:45 <mmorrow> goo
02:15:04 <mmorrow> i wonder what the time/whatever diff is between those
02:19:02 * coRayNbow still doesn't get it why ghc cannot find XMonad.Hooks and other modules of xmonad-contrib...
02:21:00 <mmorrow> nice, with ghc -O2 they're essentially the same
02:21:06 <coRayNbow> 'ghc-pkg describe xmonad-contrib' shows the importdir is '/usr/lib/ghc-6.10.4/site-local/xmonad-contrib-0.8.1', which exists...
02:22:48 <coRayNbow> but 'ghc-pkg find-module XMonad.Hooks' shows no hits...
02:23:08 <coRayNbow> yet 'XMonad.Hooks' is definitely in the package.conf...
02:23:15 <mmorrow> coRayNbow: maybe you need to tell it which package.conf to look in
02:24:29 <coRayNbow> mmorrow: ghc-pkg find-module looks in the system-wide conf as well in the user conf
02:25:36 <mmorrow> well there must be some other pkg conf hiding somewhere, or possibly your package.conf is corrupted
02:26:29 <mmorrow> what does `find /usr/lib/ghc* | grep -E "package\.conf$"' say?
02:26:46 <mmorrow> (and "which ghc-pkg" too)
02:27:51 <coRayNbow> h/usr/lib/ghc-6.10.4/package.conf
02:27:58 <coRayNbow> without the h
02:28:18 <coRayNbow> which ghc-pkg: /usr/bin/ghc-pkg
02:28:29 <mmorrow> coRayNbow: also, are you sure the xmonad-contrib .cabal has XMonad.Hooks in exposed-modules: ?
02:28:42 <adu> i like goo
02:29:00 <coRayNbow> mmorrow: .cabal?
02:29:01 <adu> i should rewrite my goo in haskell
02:29:25 <mmorrow> coRayNbow: where did you install xmonad-contrib from?
02:29:50 <coRayNbow> using the PKGBUILD from aur.archlinux.org
02:30:14 <coRayNbow> (which uses darcs)
02:30:18 <mmorrow> coRayNbow: are you sure the package.conf knows about packages installed into /usr/lib/ghc-6.10.4/site-local/
02:30:30 <mmorrow> *the package.conf in /usr/lib/ghc-6.10.4/
02:30:51 <mmorrow> i dunno any details about this site-local stuff
02:32:03 <mmorrow> coRayNbow: just do "ghc-pkg dump" and maybe look at the entry for xmonad-contrib
02:32:10 <mmorrow> s/maybe//
02:35:36 <coRayNbow> http://pastebin.ca/1521702
02:36:16 <coRayNbow> xmonad and xmonad-contrib are at the bottom
02:36:50 <adu> do you want to see my goo?
02:37:20 <adu> http://tetration.itgo.com/up/goo.png
02:37:31 <mmorrow> i don't see XMonad.Hooks in the exposed-modules list
02:37:33 <Beelsebob> looks... gooey
02:37:44 <Beelsebob> but in need of antialiassing
02:38:00 <adu> and Beziering
02:38:22 <mmorrow> yeah, that'd make it gooier for sure
02:38:46 <adu> that demo was to get the point handling good, curves and shine can come later :)
02:39:02 <adu> are there any screen savers written in haskell?
02:39:27 <coRayNbow> mmorrow: oh... right...
02:39:31 * coRayNbow facepalms
02:39:37 <mmorrow> doh!
02:39:42 * coRayNbow tries mod+Q
02:40:15 <coRayNbow> which always makes my xmobar disappear until I switch desktop or change focus :p
02:42:05 <voker57> adu: there's remake of ./configure && make, called "cabal build"
02:42:55 <adu> do you mean thats a target?
02:43:05 <adu> or calling "cabal" with the target "build"?
02:43:16 <adu> or ./setup cabal build
02:43:43 <voker57> ./setup build == cabal build iirc
02:44:37 <adu> i usually run into problems, so i like the old fasioned way :)
02:45:01 <coRayNbow> mmorrow: anyway, thx for the help :)
02:45:05 <coRayNbow> @karma mmorrow
02:45:06 <lambdabot> mmorrow has a karma of 3
02:45:13 <coRayNbow> mmorrow++
02:45:34 <mmorrow> coRayNbow: :) no problem
02:46:39 <adu> Beelsebob: if you wanted to see the goo in action: http://tetration.itgo.com/up/goo-0.7.tgz
02:47:19 <Beelsebob> doesn't play nice on OS X by default
02:48:01 <stanv> :)
02:48:10 <adu> Beelsebob: just do "easy_install PyOpenGL ; chmod a+x goo ; ./goo"
02:48:25 <adu> Beelsebob: I'm planning on rewriting it in Haskell... really
02:48:27 <stanv> No instance for (Num (a, b)). Please give me example of Num (a, b) type :)
02:48:53 <adu> Beelsebob: I'm on OSX, so it plays eventually
02:49:00 <Beelsebob> yay, I have goo
02:49:15 <ppavelV6> stanv: implement arithmetic element-wise %) not sure about the reason for doing so :)
02:49:21 <adu> Beelsebob: secret feature: press F
02:49:45 <Beelsebob> the collision detection could do with a bit of work >.>
02:50:06 <adu> yeah... they collide with walls :)
02:52:48 <gwern>  goo in action?
02:55:21 <malosh> Hi. Is it a bug or a feature that x *## 2.0## **## 16.0## is not equal to x *## (2.0## **## 16.0##) in GHC 6.10.3 ?
02:56:15 <adu> do *## and **## have the same precedence?
02:56:17 <Beelsebob> what are the *## operators that you're using?
02:56:37 <adu> Beelsebob: i'm assuming they're related to int and float versions of the standard ops
02:56:54 <artagnon> mxc: Still around?
02:57:01 <artagnon> to share your revelation?
02:57:25 <mxc> artagnon - caught me just as i'm going away for a sec
02:57:27 <mxc> be back in 10 min
02:58:06 <adu> malosh: in other words, do they have lines like "infixr 5 (*##), (**##)" or something?
02:58:44 <malosh> I just don't know
02:59:00 <malosh> maybe
02:59:45 <malosh> Or at least, I guess that they must have the same precedence, because I don't imagine that *## has a greater precedence than **##
02:59:54 <artagnon> mxc: sure, np
03:00:02 <artagnon> I was away for almost a couple of hours myself
03:00:52 <adu> malosh: if they do have the same precedence, then i think it would group as (x *## 2.0##) **## 16.0##
03:01:14 <Beelsebob> depends if they're marked infixr or infixl
03:01:28 <adu> or maybe thats only for infixl, i dunno
03:01:35 <malosh> Beelsebob : look at GHC.Prim. These are operations on machine values, for instance if you don't want that fromIntegral transforms your int into an integer, then the integer into a double, that's what you use. This solution needs memory management, and it is merely two or three CPU cycles with primitive types
03:01:41 <adu> Beelsebob: expert to the rescure
03:04:51 * adu gets sleepy
03:07:01 <mxc> artagnon - this runs slow, there's probably a better way, but i'm pretty sure this implements the sieve of erasthones as you asked:
03:07:03 <mxc> let fn n = filter (\x -> x `mod` n /= 0)
03:07:09 <mxc> is the first part
03:07:39 <mxc> now, do you just want the flat answer or a hint?
03:12:39 <dmwit> The sieve of eratosthenes is quite difficult indeed in Haskell.
03:13:09 <dmwit> To get the real thing, you need to basically go back to imperative world (for example, via ST and its STArrays).
03:17:01 <mxc> well
03:17:02 <mxc> i gotta run
03:17:04 <mxc> here's the rest
03:17:08 <mxc> dont look if you dontw ant the answer
03:17:17 <mxc> let filterF fxn (h:t) = let newFxn = ((fn h) . fxn) in h : (filterF newFxn $ newFxn t)
03:17:17 <mxc> let primes n = take n $ filterF (fn 2) [2..]
03:17:33 <mxc> i'm sure it could be done better and more efficiently, but that seems to work
03:17:33 <thomastc> @seen nominolo
03:17:33 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc, #haskell-in-depth and #haskell 1d 16h 56m 21s ago, and .
03:21:22 <Berengal> dmwit: Or the sieve of O'Neill
03:34:04 <RayNbow> dmwit, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8000#a8000 <-- slight variation of last night :)
03:41:56 <dmwit> cheers
04:07:42 <ManateeLazyCat> What's mean keyword `infixr` ?
04:08:00 <Peaker> ManateeLazyCat: it declares an infix operator to be right-associative, with some precedence
04:09:21 <ManateeLazyCat> Peaker: So in "infixr 5 <+>" and "infixr 3 ***", which operator has higher precedence?
04:09:53 <Peaker> ManateeLazyCat: (+)
04:09:58 <Peaker> oops, (<+>)
04:10:09 <Peaker> ManateeLazyCat: higher number = higher precedence = applied first
04:10:16 <Peaker> ($) is precedence 0
04:10:27 <mmorrow> here's my sieve http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8003
04:13:39 <ManateeLazyCat> Peaker: I see, thanks! :)
04:14:28 <Berengal> mmorrow: Using a map to mark multiples?
04:14:45 <mmorrow> Berengal: yeah
04:15:41 <mmorrow> so you trade O(lg n) lookup for the ability to have an infinite list of primes
04:16:02 <mmorrow> err, i said that wrong but you know what i mean
04:16:10 <Berengal> Here is my sieve http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8004#a8004
04:16:16 <mmorrow> *so you trade O(1) lookup for ...
04:17:42 <mmorrow> Berengal: ah nice, that should be a good one for some gcc -S inspection
04:18:19 <mmorrow> ooh, are you on x86? (the long long probably hurts..)
04:18:28 <Berengal> No, 64
04:18:32 <mmorrow> ah
04:18:49 <mmorrow> so is that 128 on x86_64?
04:18:58 <Berengal> No, I think it's still 64 bits
04:19:04 <mmorrow> ah, ok
04:19:14 <Berengal> I actually wrote it eariler today just to remind myself that I need to learn c :P
04:20:21 <mmorrow> i bet you can eliminate that second "if(! skipMarking)" somehow
04:20:53 <Berengal> Possibly. I originally used sqrt, but the linker failed somehow :/
04:21:06 <mmorrow> -lm
04:21:20 <Berengal> I knew I was forgetting something
04:21:23 <mmorrow> :)
04:21:37 <Berengal> --make is all I've ever needed :P
04:36:08 <ManateeLazyCat> @hackage fudgets
04:36:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fudgets
04:36:20 <ManateeLazyCat> @hackage Fudgets
04:36:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Fudgets
04:41:01 <voker57> @hackage foobarwtf
04:41:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/foobarwtf
04:41:05 <voker57> nice!
04:41:21 <voker57> that reminds me of @faq
04:44:23 <artagnon> mxc: OMG! It looks awfully complicated!
04:44:30 <artagnon> Thanks a million
04:44:40 <artagnon> What should I read to get to that level?
04:45:20 <gwern> voker57: @hackage does no checking. patches welcome...
04:49:45 <ManateeLazyCat> @let duplicate x = (x,x)
04:49:46 <lambdabot>  Defined.
04:49:49 <ManateeLazyCat> :t duplicate
04:49:50 <artagnon> mxc: Implemented here FYI: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity_and_implementation
04:49:51 <lambdabot> forall t. t -> (t, t)
04:49:52 <artagnon> the solution
04:49:56 <artagnon> I gave up :(
04:49:57 <esap> http://www.kotiposti.net/epulkkin/Satisfiability.txt
04:50:04 <artagnon> I'm tying to understand the example instead
04:54:47 <opqdonut> esap: have you had a look at http://pauillac.inria.fr/~maranget/enum/index.html
04:55:44 <esap> opqdonut: not really
04:56:05 <opqdonut> well it's a good read
04:56:55 <esap> I did similar thing with CNF though
04:57:39 <esap> I doubt I can get any performance improvements from that though
05:02:55 <Botje> hey, there's an .io TLD.
05:03:05 <Botje> perhaps someone should register unsafeperform.io or donotuse.io :)
05:03:26 <wjt> @hoogle Char -> Word8
05:03:26 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
05:03:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:03:27 <lambdabot> Prelude read :: Read a => String -> a
05:03:50 <wjt> there must be something better than (fromIntegral . fromEnum)
05:11:12 <voker57> Prelude Unsafe.Coerce> unsafeCoerce 1 2
05:11:13 <voker57> zsh: segmentation fault  ghci
05:11:15 <voker57> real unsafe
05:11:21 <Berengal> Ooo, the ghc runtime has a -B option
05:12:37 <Berengal> And hooks, this is nice
05:13:19 * Berengal should probably read through the GHC manual in entirety some day
05:18:55 <EvilTerran> wjt, toEnum.fromEnum or toEnum.ord ?
05:19:29 <wjt> EvilTerran: Guess so. It'd be nice to have b'' and b"" notation akin to Python 3
05:20:01 <Berengal> There's IsString
05:20:08 <Berengal> And -XOverloadedStrings
05:20:32 <EvilTerran> or -XQuasiQuotes
05:20:34 <wjt> which are great for making ByteStrings but not Word8s :)
05:20:59 <Berengal> Can't you just write your own instance?
05:21:02 <EvilTerran> [$w8|A|]
05:22:26 <artagnon> This clever code in Haskell [ http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3216#a3216 ] is MUCH slower than this dumb code in C++ [ http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3218#a3218 ] ... why?
05:22:42 <artagnon> To find 10001st prime
05:23:30 <Berengal> artagnon: The haskell code is even dumber than the c++ code'
05:23:53 <artagnon> Berengal: ! I racked my brains to come up with it
05:23:55 <Botje> artagnon: for starters, use sieve 2:[3,5..]
05:24:05 <artagnon> It's Ertosthenes' sieve
05:24:14 <artagnon> The C++ code is brute-force nonsense
05:24:14 <Botje> that way you don't check every even number.
05:24:18 <Berengal> artagnon: Oh, it's "clever", but it is a crappy algorithm
05:24:24 <mauke> 'register int i'? you're fired
05:24:42 <artagnon> Botje: Uh... what does that do?
05:24:48 <artagnon> Berengal: Why so?
05:24:57 <Botje> artagnon: [2..] is [2,3,4,5,...]
05:25:07 <Botje> but even numbers are never prime (with the exception of 2)
05:25:08 <mauke> also, out of bounds access in line 15
05:25:09 <artagnon> I always though that the most elegant solution was the best
05:25:20 <Botje> so 2:[3,5..] is [2,3,5,7,9,...]
05:25:36 <artagnon> Botje: ofcourse. But my first sieve will eliminate the even numbers anyway, no?
05:25:54 <Berengal> artagnon: your sieve is simply doing trial division. It divides every prime with every previous prime to see if the remainder is zero
05:25:58 <artagnon> mauke: Is it only because of the register variable? Can I match it?
05:26:00 <Botje> artagnon: yes, but it's better not to generate them in the first place
05:26:16 <mauke> what do you mean by "match it"?
05:26:18 <Botje> artagnon: your C++ codes does i += 2 as well, doesn't it?
05:26:21 <artagnon> Berengal: Correct. So what's the C++ program doing?
05:26:46 <Berengal> artagnon: Well, it skips even numbers for one...
05:26:52 <artagnon> Botje: Yes, but that's because there's no way to remove 6, 9, 12, 15 as well etc.
05:27:00 <artagnon> the best I could do was to remove the even numbers
05:27:25 <Botje> artagnon: yep, so the equivalent for haskell is 2:[3,5..]
05:27:33 <Berengal> artagnon: And it doesn't bother checking numbers larger than the sqrt of the current prime candidate
05:27:35 <artagnon> Berengal: The C++ version is doing so many more divisions
05:27:42 <Botje> which makes the list jump by 2 instead of one
05:27:52 <artagnon> Botje: Right, essentially halving
05:27:55 <artagnon> I'll change taht
05:27:56 <Berengal> artagnon: No it doesn't. Your version will divide every number at least once
05:28:42 <artagnon> Berengal: ok fine, I'll divide by primes until sqrt(n)... won't bother checking with the other primes
05:29:05 <artagnon> Berengal: It'll be better than the C++ program then, right?
05:29:10 <Tobsan> The c++ version could easily be transformed so that it doesnt use division at all.
05:29:16 <Berengal> artagnon: It'll be equally good
05:29:19 <artagnon> Tobsan: How?
05:29:40 <Tobsan> artagnon: for each prime, cross out all numbers that are multiples of that number
05:29:44 <artagnon> Berengal: The C++ version is also dividing by composites. I'm dividing only by primes
05:29:58 <mauke> (psst, the C++ version writes to array elements that don't exist)
05:29:58 <opqdonut> Tobsan: i.e. the real erastothenes
05:30:13 <Tobsan> opqdonut: yes, exactly. That is a LOT faster.
05:30:17 <artagnon> Tobsan: For finding "multiples", I need to do division, yes?
05:30:17 <Berengal> artagnon: No, the c++ program only divides by primes as well
05:30:33 <Tobsan> artagnon: why do you think so? 2*p is a multiple of p
05:30:35 <artagnon> Berengal: yeah, sorry
05:30:37 <Tobsan> as is 3*p
05:30:58 <artagnon> Tobsan: Ah. Hm.
05:31:07 <artagnon> The algorithm will be awfully complicated then I guess
05:31:47 <Tobsan> Well...no. I had one written in java once. I'll see if I can find it.
05:32:10 <artagnon> ok
05:32:11 * artagnon waits
05:32:23 <Berengal> didn't I just post one?
05:32:29 * Berengal looks through the logs
05:32:34 * artagnon looks
05:32:35 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8004#a8004
05:32:56 <opqdonut> and even that's overly complicated
05:33:05 <opqdonut> uses bitfiddling and whatnot
05:33:13 <Berengal> Yeah, mine uses bitvectors
05:33:23 <Berengal> I felt like some bittwidling...
05:33:27 <Tobsan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8007#a8007
05:33:34 <opqdonut> the haskell equivalent would merge the lazy streams [p,2*p,3*p..]
05:33:50 <opqdonut> to get the monotonic list of all composites
05:33:57 <artagnon> Berengal: WTF!? Some crazy hack
05:34:06 <Tobsan> opqdonut: yes, I think that is available on the wiki even.
05:34:33 <artagnon> Tobsan: Nice. An array of Bools
05:34:41 <artagnon> I want a more elegant solution though
05:35:09 <opqdonut> no that's not it
05:35:27 <Cale> Strangeness... I was disconnected several times last night for excess flood while I was asleep and not using my computer.
05:35:27 <artagnon> opqdonut: ?
05:35:28 <Berengal> artagnon: Not really, it's just a bit complicated because I'm using bits instead of bytes to store primality
05:35:45 <Berengal> artagnon: Which essentially amounts to an array of bools
05:35:50 <Tobsan> opqdonut: the "Implicit Heap" is the one you think about, right? http://www.haskell.org/haskellwiki/Prime_numbers
05:35:53 <artagnon> Berengal: I see.
05:36:14 <opqdonut> Tobsan: yes, exactly
05:36:20 <opqdonut> artagnon: see what Tobsan pasted, section 5
05:38:13 * artagnon looks
05:38:31 <artagnon> Ok, is there a way to limit p in my solution? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8008#a8008
05:38:38 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8009#a8009
05:38:46 <artagnon> limit p only until sqrt(x)
05:40:00 <Berengal> [x | let sqr = ceiling . sqrt . fromInteger $ p, x <- xs, x > sqr || x `mod` p > 0]
05:41:26 <artagnon> Berengal: Your program takes a few seconds to find 10001st prime. The C++ version takes 52ms.
05:41:42 <artagnon> Berengal: Ok, that was awesome (!)
05:41:46 <artagnon> limiting p ie.
05:42:36 <Berengal> Yeah, my program is no match for c++, but it does provide more functionality (lazy infinite primes, isPrime and factorize functions)
05:44:50 <Cale> Uh, really, a few seconds? Are you compiling it?
05:45:14 <Cale> Here Berengal's program takes 0.128s
05:45:14 <Cale> (to get primes !! 10000)
05:46:28 <artagnon> Cale: Yeah, I am. GHC. From within Emacs using the Haskell inferior though
05:46:54 <Berengal> That just runs ghci, it doesn't compile
05:47:39 <artagnon> Oh.
05:47:42 * artagnon feels stupid
05:48:03 <artagnon> It says: [1 of 1] Compiling Main ( /home/artagnon/dev/project-euler/euler.hs, interpreted ) -- Ah, interpreted
05:48:40 <Berengal> In fact, previous testing has shown that my program is rather slow when interpreting, slower than many other similar programs people have thrown my way, but it's always come out the fastest when compiled
05:48:50 <Berengal> Not taking into account proper prime finding programs, of course...
05:49:04 <Cale> I have a similar program which is ever so slightly faster.
05:49:16 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8009#a8010
05:49:20 <Cale> But essentially the same
05:49:43 <Cale> (actually, factors is dead code there, I just included it for contrast)
05:50:25 <Berengal> Cale: I think you might improve speed by using sqrt. p*p in the inner loop quickly overtakes sqrt in the outer one
05:51:11 <Berengal> takeWhile (let root = floor $ sqrt $ fromInteger n) in \p -> p <= root)
05:51:12 <Cale> Perhaps, though I'd need an efficient integer square root for that
05:51:29 <Cale> Using floating point square root is ugly...
05:51:36 <Cale> I'm not even sure if it's correct.
05:51:55 <Berengal> It's correct with ceiling at least, but it might take too many
05:52:20 <Berengal> And I think I had to give primes 2:3:5, or it'd hang in an infinite loop
05:56:04 <artagnon> Damn. Now why isn't this [ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8011#a8011 ] compiling?
05:56:30 <Cale> primes = (sieve 2) : [3,5..]
05:56:42 <mauke> dunno, ask your compiler
05:56:43 <Cale> Is another way to write what you wrote :)
05:57:05 <artagnon> damn!
05:57:07 <artagnon> :(
05:57:14 <artagnon> I hate precedence rules :|
05:57:27 <Berengal> I love parenthesis :)
05:57:29 <Cale> Function application *always* binds more tightly than any operator
05:57:44 <Cale> That's the main rule to burn into your brain :)
05:57:51 <artagnon> hm. No. It still doesn't work.
05:58:01 <Cale> What's the error/new code?
05:58:07 <artagnon> Cale: Right I have to keep that in mind.
05:58:19 <artagnon> Cale: Same error. I put () around 2:[3,5..]
05:58:29 <artagnon> Couldn't match expected type `a' against inferred type `Integer'
05:58:33 <Cale> Oh
05:58:39 <artagnon> on the primes !! 10001 line
05:58:50 <Cale> delete the type signature on euler7_sieve
05:58:57 <Cale> and check the inferred type.
05:59:40 * Cale is betting on Integer ;)
05:59:58 <Cale> I think it may be the MR
06:00:04 <artagnon> Hm, it works without the type signature
06:00:08 <artagnon> atleast it compiles
06:00:08 <Cale> primes = sieve (2:[3,5..])
06:00:10 <mauke> can't be MR
06:00:12 <Cale> is a pattern binding
06:00:20 <mauke> it's the fromInteger
06:00:29 <artagnon> ah, I see
06:00:30 <Cale> oh, that's a good point too :)
06:00:35 <Cale> fromIntegral
06:00:44 <artagnon> Integer -> a
06:00:51 <artagnon> but mine's Integral
06:00:52 <Cale> But even with fromIntegral, I think the MR might call you on that primes list
06:00:55 <artagnon> so that's the problem, right?
06:02:03 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8009#a8012
06:02:07 <mauke> compiles with fromIntegral
06:04:22 <burp> anyone has examples for Control.Monad.Writer Control.Monad.RWS monads? I wonder what these are used for
06:05:04 <Cale> RWS is silly
06:05:11 <Cale> Writer is useful though
06:06:13 <artagnon> Hm. Something's wrong. It seems to be working blazingly fast, but it gives the wrong answer :/
06:06:57 <ManateeLazyCat> What's mean keyword `proc` ? Like lambda for Arrow?
06:07:14 <Cale> ManateeLazyCat: sort of, yes
06:07:18 <ksf> iirc more like "do"
06:07:34 <artagnon> ah, it's malfunctioning. Berengal: There's something wrong with that limiting code... don't worry though, I'll fix it.
06:07:39 <ksf> but then I never got around using arrows.
06:08:21 <ManateeLazyCat> Cale: (-<) like <- for Monad, just (-<) for Arrow?
06:08:39 <Cale> ManateeLazyCat: In arrow-notation, there's both <- and -<
06:08:40 <ManateeLazyCat> ksf: Arrow is cool
06:09:07 <ManateeLazyCat> Cale: What's mean (-<), i can't use hoogle find it.
06:09:08 <Cale> result <- arrow-computation -< input
06:09:35 <Cale> It's syntax and not an actual operator, iirc.
06:11:04 * ksf thinks http://www.cse.unsw.edu.au/~chak/papers/PLKC08.html should be more prominent on the dph wiki page
06:11:13 <ksf> in fact, it should replace the nepal paper.
06:11:27 <ManateeLazyCat> Cale: proc x -> do result <- arrow-computation -< input; returnA -< otherInput ?
06:12:39 <ManateeLazyCat> Cale: I think i understand -< now.
06:12:56 <ksf> most importantly, it includes a single, good example _and_ explains the implementation.
06:13:34 <Cale> ManateeLazyCat: yeah
06:13:45 * ksf begins to wonder whether anyone would still be confused by monads if spj wrote a paper about them.
06:13:55 <Cale> ManateeLazyCat: The actual translation in terms of the arrow combinators is complicated, but the idea is simple.
06:14:16 <ManateeLazyCat> Cale: Yep, Arrow is beautiful more than Monad.
06:14:29 <Cale> I'm not sure I'd say that :)
06:15:04 <ManateeLazyCat> Cale: I deeply read Arrow resource, and try use Arrow replace Monad.... Just idea... :)
06:15:39 <ksf> well, every monad is a kleisli arrow, so that's kind of straight forward.
06:15:50 <Cale> Usually if I had a choice between being able to use a monadic interface and an Arrow one, I would pick the monadic one.
06:16:27 <Berengal> Arrows might be nicer in some cases... I don't really know, I just use them for obfuscation :P
06:16:53 <ManateeLazyCat> Cale: Monadic interface is more ripe and wider use?
06:17:06 <ManateeLazyCat> Cale: Just from idea, i like Arrow factor.
06:17:52 <ksf> I've had a look at both yampa and grapefruit, which use arrows, and must say that I really, really prefer reactive's applicative interface.
06:17:58 <twanvl> monads are simpler than arrows
06:18:11 <Cale> Well, Arrow is more general, in that more libraries might fit into that framework, but because of that, there are fewer useful functions which work with arbitrary Arrows.
06:18:50 <ksf> it's like the applicative interface for parsec: having less power at your hands might actually be beneficial.
06:18:55 <Berengal> What arrows are there except Kleisli and function anyway?
06:19:47 <Cale> Berengal: Cokleisli, Signal transformers (which can involve things like efficient integration in a natural way)
06:19:58 <Cale> Berengal: parsing arrows
06:20:18 <twanvl> Berengal: XML tree transformation
06:20:22 <Berengal> Cale: Links/google terms?
06:20:39 <Cale> You might look up Yampa for the signal transformer stuff
06:21:04 <Cale> I forget what the Arrow parsing libraries were called. They're not all that pretty.
06:21:14 <Cale> HXT for the XML stuff
06:21:37 <Berengal> The XML stuff might be interesting. XML has unfortunately become a bigger part of my programming life recently...
06:22:15 <pejo> Berengal, there's a PADL-paper (2003?) by the yale-group that is a good summary about yampa.
06:22:24 <ManateeLazyCat> Cale: If Arrow have huge function to support arbitrary Arrows like Monadic library, which choose? Monadic or Arrow?
06:22:49 * ksf likes haxml
06:23:04 <ksf> ...at least if you have a dtd, you should give it a try.
06:23:17 <Cale> ManateeLazyCat: The problem is that because Arrow is more general, there are not as many functions -- many of the functions which work in an arbitrary monad can't be written to work in an arbitrary arrow.
06:23:32 <pejo> Berengal, and Sculthorpe and Nilsson have a paper for ICFP this year about using Agda to guarantee things statically, that one probably has some background about yampa as well.
06:23:51 <Berengal> pejo: Nice, thanks
06:24:09 <ksf> ha! agda is just an excuse to use unsafeCoerce... :)
06:24:12 <Cale> ManateeLazyCat: But still, I think I would choose monad, simply because it's simpler to wire up monadic computations than it is to work out exactly how you're going to build an Arrow computation.
06:24:50 <Cale> Writing Arrow computations sort of turns into something a bit like circuit design.
06:25:19 <ksf> bindings/applications form a similar graph, though.
06:26:10 <ManateeLazyCat> Cale: Indeed, just beginning, Arrow's type signature confusing me a bit.
06:29:23 <ManateeLazyCat> Cale: The idea i want explore Arrow is write function that accept dynamic number argument parse, even don't know how to do it. In Monad, i need give argument number explicit.
06:29:36 <stianhj> what's the difference between Int and Integer?
06:29:37 <ManateeLazyCat> Cale: Example, ifM :: Monad m => (a -> m Bool) -> a -> m c -> m c -> m c
06:29:41 <ManateeLazyCat> ifM2 :: Monad m => (a -> b -> m Bool) -> a -> b -> m c -> m c -> m c
06:29:42 <ManateeLazyCat>  
06:29:46 <mauke> stianhj: Int has a fixed size
06:29:52 <ManateeLazyCat> ifM3 :: Monad m => (a -> b -> c -> m Bool) -> a -> b -> c -> m d -> m d -> m d
06:29:53 <ManateeLazyCat>  
06:29:58 <Berengal> stianhj: Integer is bignum
06:30:00 <mauke> > maxBound :: Int
06:30:01 <lambdabot>   9223372036854775807
06:30:08 <ManateeLazyCat> Cale: And those ifM, ifM2, ifM3 is endless.
06:30:11 <ksf> > maxBound :: Integer
06:30:13 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
06:30:13 <lambdabot>    arising...
06:30:20 <Berengal> , maxBount :: Int
06:30:21 <lunabot>  luna: Not in scope: `maxBount'
06:30:25 <ksf> :t maxBound :: Int + 1
06:30:27 <lambdabot>     Could not deduce (Bounded ((+) Int Unit)) from the context ()
06:30:27 <lambdabot>       arising from a use of `maxBound' at <interactive>:1:0-7
06:30:27 <lambdabot>     Possible fix:
06:30:33 <Berengal> , maxBound :: Int
06:30:34 <lunabot>  2147483647
06:30:35 <ksf> :t (maxBound :: Int) + 1
06:30:36 <lambdabot> Int
06:30:59 <stianhj> i'm getting an error saying "Couldn't match expected type 'Integer' against inferred type 'Int'"
06:31:10 <stianhj> when is Int infferred instead of Integer?
06:31:14 <ksf> > (fromIntegral (maxBound :: Int)) * 2
06:31:16 <lambdabot>   18446744073709551614
06:31:24 <ksf> :t (fromIntegral (maxBound :: Int)) * 2
06:31:26 <lambdabot> forall b. (Num b) => b
06:31:30 <ksf> hum.
06:31:34 <ksf> that's not Integer...
06:31:56 <Berengal> stianhj: Code?
06:32:17 <ksf> stianhj, your code fixes the type to Int, somewhere.
06:32:31 <ksf> ...either locate that, or use fromIntegral.
06:32:37 <ksf> :t length
06:32:38 <lambdabot> forall a. [a] -> Int
06:32:44 <twanvl> ManateeLazyCat: instead of ifM3 p a b c, why not just write if (p a b c)?
06:32:46 <ksf> such things, for example.
06:34:20 <ManateeLazyCat> twanvl: I have write ifA, in this case, Arrow handy than Monad
06:35:23 * ManateeLazyCat Explore Arrow.... brb
06:49:58 <stianhj> what is the opposite of filter?
06:51:08 <mauke> wat
06:51:41 <Saizan_> opposite in what sense?
06:51:46 <stianhj> filter f list, removes elements from the list if f on that element is true, right?
06:51:54 <Saizan_> no
06:51:54 <arjanb> filter (not . p) xs
06:51:57 <Saizan_> keeps them
06:52:00 <koeien> > filter even [1..10]
06:52:01 <mauke> so you want to add elements to the list for which f returns true?
06:52:02 <lambdabot>   [2,4,6,8,10]
06:52:13 <stianhj> i want to remove elements
06:52:16 <mauke> or do you want to add elements for which f is false
06:52:28 <mauke> filter already removes elements; you said "opposite"
06:52:39 <mike-burns> `filter (not . p)'. I don't know if there's a shorter name for that.
06:52:51 <mike-burns> @hoogle reject
06:52:51 <lambdabot> No results found
06:53:05 <stianhj> opposite in the sense of f returning true removes
06:53:21 <mauke> ok, that's filter
06:53:22 <Saizan_> then use not to negate your predicate
06:53:30 <stianhj> opposite in the sense of f returning false removes then :P
06:53:48 <Saizan_> f returning False already removes them.
06:53:51 <Saizan_> > even 1
06:53:52 <lambdabot>   False
06:53:57 <Saizan_> > filter even [1]
06:53:58 <lambdabot>   []
06:55:39 <stianhj> ok ok.. i thought mauke said it was the other way around..
06:59:42 <ksf> vgrepping through all those dph papers, I'm still lacking one crucial bit of information: what's the status of backend support?
06:59:56 <ksf> that is, does it only support multicore, or also simd?
07:09:04 <dumael> ksf: afaik it doesn't support SIMD yet. I could well be wrong though.
07:09:37 <Axman6> ChilliX: hey you around man?
07:13:36 <ksf> hmmm. the HEAD docs just point to the dph wiki page.
07:13:50 <ksf> guess I've got to download 6.11 and try for myself.
07:17:59 <ksf> in fact, I'm quite surprised that it isn't done, yet.
07:18:07 <ChilliX> Axman6: hey
07:18:32 <Axman6> did you get that forwarded email via dons about LLVM for ghc?
07:18:48 <ksf> otoh, all those guys doing the work are most likely not stuck with a single-core non-cuda machine.
07:18:51 <ChilliX> when? today?
07:18:55 <Axman6> yeah
07:19:34 <ChilliX> Axman6: haven't looked at email today yet - just distracts from coding - but let me have a look
07:19:35 <Axman6> i sent it to -cafe and ghc-users as well
07:19:48 <pejo> ksf, it's still a very big task in the first place.
07:21:04 <ksf> well, but then we've got mmx now for how long, 10 years?
07:21:40 <ksf> unrolling is another thing, too.
07:22:02 <ChilliX> Axman6: interesting
07:22:29 <ChilliX> Axman6: the student who works on an LLVM backend for GHC here did actually talk to Chris Lattner
07:22:45 <ChilliX> (well not directly, but on the LLVM mailing lists)
07:23:35 <pejo> ksf, there aren't that many people doing the work, naturally they will run out of time.
07:23:36 <Axman6> well, another developer said he'd be happy to try and implement the features that are missing. do you happen to remember any of the problems with using LLVM?
07:23:37 <ChilliX> Axman6: one feature that LLVM does not support (despite clang docs wrongly claiming so) are pinned registers
07:24:05 <ChilliX> Axman6: from the discussion on the llvm lists it seemed that adding pinned registers wouldn't be that easy
07:24:41 <Axman6> hmm, i see
07:24:51 <ChilliX> so, david tries to define a special purpose calling convention now
07:25:10 <ChilliX> that has the advantage of more registers avail in inner loops
07:25:25 <ChilliX> but otherwise may lead to more data movement
07:25:33 <ChilliX> we'll see what the cost/benefit is
07:25:50 <Axman6> you wouldn't like to join #auroraux would you?
07:26:01 <ChilliX> the other issue is that you can't tell llvm to put data blocks next to code
07:26:22 <Axman6> i've always wondered why that's necessary
07:26:32 <ChilliX> why it is necessary in GHC?
07:26:56 <Axman6> i mean, this isn't an area i'm at all familliar with, i've been asking questions on behalf of others
07:27:00 <ChilliX> representation of closures needs to point to the code that evals a closure and to metadata (containing, eg, GC info)
07:27:29 <ChilliX> instead of two pointers in the closure, we only want one
07:27:53 <ChilliX> but if that is to the metadata, which then has a poiinter to the code, you need to follow a double indirection during evaluation
07:28:08 <Axman6> hmm
07:28:09 <ChilliX> hence, the idea to point to the code and have the metadata at negative offsets of that same pointer
07:28:28 <ChilliX> strictly speaking, I am the wrong person to talk to anyway
07:28:43 <Axman6> fair enough
07:29:06 <ChilliX> I'll email you the email address of the student who does the work (and did discuss on the llvm list) - wrt to the discussion on the list, I am just repeating what he told me
07:29:39 <Axman6> ok, thanks
07:30:15 <Axman6> sounds like something i'd like to work on in a few years, but at the moment, i don't have any of the skills i'd need
07:31:30 <ChilliX> I am all for trying to get this working somehow
07:31:41 <ChilliX> be nice to tap into all the hard work of the llvm people
07:31:53 <Axman6> indeed
07:31:57 <pejo> Axman, a good way to get into ghc-hacking is to find some self-contained project where you don't have to know all of ghc to get things done.
07:32:36 <Axman6> pejo: well, this would also require LLVM knowledge (and possible C/C++ knowledge), which i don't really have time for at the moment
07:35:42 <ChilliX> Axman6: it's not really an easy project to get started on, I agree
07:36:10 <Axman6> yeah, being a second year Eng/IT student, it's a little beyond me ;)
07:36:40 <ChilliX> Anyway, I am sure there'll be plenty of improvements left to be done by the time out project is done and then there is a basis to work one
07:37:50 <ChilliX> Axman6: btw, iirc I saw your name pop up in connection with the Haskell mode for textmate
07:37:54 <Axman6> yeah, sounds excellent :)
07:38:18 <Axman6> indeed. though it wasn't my work. haskell's not an easy language to parse with textmate :\
07:39:15 <ChilliX> I was playing around with textmate and was starting to think of ways to imrpove the mode
07:39:35 <ChilliX> yeah, haskell syntax is very dense
07:39:44 <ChilliX> makes it hard to parse .. for machines ;)
07:39:50 <Axman6> well, the textmate guys are always happy to accept patches to bundles
07:40:31 <ChilliX> do you know whether anybody is still working at that bundle or is it just somthing somebody wrote at some point and then it didn't change much anymore?
07:41:46 <Axman6> i can find out
07:42:19 <ChilliX> only if it si not much trouble
07:42:20 <pejo> ChilliX, saw you own a bug with "Iface type variable out of scope". Do you know why it occurs?
07:43:15 <ChilliX> it'll be a while before I produce something useful (being tied up with other stuff and not knowing textmate well), but some stuff is starting to annoy me; so, I gues at some point I am going to sufficiently fed up to fix it
07:43:40 <ChilliX> pejo: do I?
07:43:43 <ChilliX> let me see
07:44:01 <pejo> Chillix, now that I'm trying to find it I might have been hallucinating.
07:44:31 <randomwords> I recently updated *something* and now any code that uses openGL is spitting out errors like  "No instance for (ColorComponent Double)". It seems openGL is now missing instances for many datatypes. Any idea what's going on?
07:45:30 <ChilliX> pejo: the title doesn't mention iface, but I guess you mean #3409
07:45:41 <ChilliX> it's a pretty new one, I didn't look into it yet
07:45:50 <ChilliX> but as the ticket says, it seems like a w/w issue
07:46:03 <pejo> ChilliX, ah, yeah, that's the one I was thinking of.
07:46:30 <ChilliX> signatures with equality constraints are tricky as equality constraints turn into universally quantified type variables with a special kind in Core
07:46:50 <ChilliX> so my guess is that one of these gets manged during w/w
07:47:12 <ChilliX> mangled*
07:47:41 <pejo> ChilliX, seems reasonable.
07:48:32 <ChilliX> alternatively, I know of a problem where wanted equality constraints can go bad when being turned into given one (ie, included ina signature during type inference)
07:48:53 <ChilliX> this only happens in some special circumstances and might possibly lead to such a problem, too
07:49:10 <ChilliX> but I don't understand fully when it exactly happens yet :/
07:49:30 <ChilliX> sorry, all not very definitive...
07:49:41 <ChilliX> do you have a similar problem?
07:49:49 <pejo> ChilliX, sorry, wasn't trying to push you down the path of fixing the bug immediately. Was hoping you had the same sort of error that I have, but I've broken things in a different way.
07:52:52 <ChilliX> pejo: ic .. in the type checker?
07:54:35 <Axman6> ChilliX: i'll try and get in touch with ozy` over the next few days if you like, regarding the textmate thing
07:55:00 <Deewiant> randomwords: IIRC the instances were switched to the C types CDouble, CInt, etc. You're supposed to use the GLDouble-style (or whatever they're called) type synonyms
07:55:29 <pejo> ChilliX, well, I have interface id's out of scope instead, but it's something I've broken all by myself. :-)
07:55:49 <ChilliX> Axman6: ta
07:56:17 <ChilliX> pejo: but did you break it by changing the type checker?
07:57:03 <pejo> ChilliX, oh, no, changing tidyPgm to stop stripping all the unfoldings.
07:58:25 <ChilliX> pejo: the thing is, I think it is a bit starnge that the problem occurs when reading an iface and not already during the compiler run where the iface was *written* (given at least in #3409) this was done with Core Lint enabled
07:58:41 <ChilliX> so *maybe* we also have an issue in the iface reader/writer
07:58:51 <ChilliX> and that may get you, too
07:59:33 <pejo> ChilliX, well, maybe, but I'm probably just violating some assumption that I'm unaware of.
07:59:38 <ChilliX> what I would suggest is to run a DEBUG compiler with core lint and dump all unfoldings and all signatures while creating the pffending iface
07:59:56 <ChilliX> then use --show-iface on that iface
08:00:04 <pejo> ChilliX, hm. My problem appears when the files are being writing though.
08:00:07 <Axman6> ChilliX: doesn't look like much has changed since i posted that post (all the more reason to submit changes though ;))
08:00:28 <ChilliX> Axman6: hehe - true
08:00:51 <ChilliX> pejo: ha, your compiler bombs on writing the iface?
08:01:08 <Axman6> and i know I for one would appreciate and improvements. Ben L probably would too, i hear he uses textmate
08:01:28 <pejo> ChilliX, bombs is a bit of a strong word, it writes the iface but spits out:
08:01:36 <pejo> Declaration for hsPatType
08:01:36 <pejo> Unfolding of TcHsSyn.hsPatType:
08:01:37 <pejo>   Iface id out of scope:  lvl6
08:02:05 <randomwords> Deewiant: Thanks, is this info in some release notes somewhere?
08:02:21 <ChilliX> and when you dump the unfoldings with the corresponding -ddump option
08:02:29 <Deewiant> Beats me, I just recall somebody running into the same problem on the mailing list
08:02:32 <ChilliX> maybe even with -dppr-debug
08:02:39 <ChilliX> does that unfolding look funny?
08:03:35 <ChilliX> pejo: ah, wait
08:03:43 <ChilliX> you got an out of scope id
08:03:46 <ChilliX> I cot a tyvar
08:03:50 <ChilliX> got*
08:03:54 <ChilliX> different beats
08:04:14 <ChilliX> pejo: core lint does not complain?
08:04:18 <pejo> ChilliX, yes, sorry about dragging you along this line.
08:04:19 <ChilliX> on the same file?
08:04:28 <ChilliX> that is very weird
08:05:17 <ChilliX> core lint ought to complain about out of scope ids
08:05:27 <pejo> ChilliX, checking.
08:05:52 <randomwords> Deewiant: This http://www.nabble.com/Re:--Haskell--ANNOUNCE:-OpenGL-2.3.0.0-td24769487.html seems to shed some light
08:06:09 <Deewiant> Yep
08:07:09 <ChilliX> pejo: I gotta go
08:07:09 <randomwords> Fixing my own code should be OK, but it's annoying as some libraries in cabal are now broken.
08:07:17 <ChilliX> but check that core lint doesn't choke on the thing
08:07:25 <pejo> ChilliX, thanks for your help. Have a starting point now.
08:07:27 <ChilliX> and aybe it gives you better info about what's wrong
08:07:47 <Deewiant> randomwords: They were broken anyway if they didn't specify that they depend on OpenGL < 2.3
08:07:57 <ChilliX> then use  the various optiosn to dump intermediate stages of core to see in which ohase the id diappears
08:08:09 <ChilliX> phase*
08:08:18 <randomwords> Deewiant: good point, but it's still a hassle
08:08:53 <Deewiant> Broken packages tend to be :-P
08:17:12 <Axman6> ChilliX: if you have things you want added to textmate, just drop by ##textmate and let them know. Allan or someone else will probably submit them for you
08:47:34 <Axman6> @srrn ozy`
08:47:34 <lambdabot> Maybe you meant: arr run seen src
08:47:37 <Axman6> @seen ozy`
08:47:37 <lambdabot> Last time I saw ozy` was when I left ##logic, #haskell and #haskell-overflow 6m 25d 10h 31m 47s ago, and .
08:47:45 <Axman6> hmmm...
08:51:54 <hackagebot> press 0.1.2 - Text template library targeted at the web / HTML generation (BrandonBickford)
08:55:31 <malosh> Hi. Why do I get a stack overflow with an STUArray s Int Fixed with data Fixed=Fixed# Int# ?
08:56:01 <malosh> I have defined the instance of STUArray exactly like the one for I# in Data.Array.MArray
09:00:25 <mmorrow> pejo: ah nice, i wasn't looking for that in particular, but i was wondering where that stuff was (re: constant folding)
09:01:14 <mmorrow> malosh: you'd need to paste the context
09:01:55 <pejo> mmorrow, took me a while to locate it myself when I was looking for it the first time.
09:01:59 <mmorrow> malosh: are you not forcing an accumulator as you fold along the array possibly?
09:02:23 <malosh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8015#a8015
09:03:32 <mmorrow> pejo: one thing i've found really handy (and should re-generate actually since mine's getting old) is the hoogle dict for ghc (by running ./Setup haddock --hoogle in compiler/)
09:04:15 <mmorrow> also the hyperlinked and HsColoured haddocks for ghc is nice too (which i also need to regenerate)
09:04:19 <mmorrow> http://moonpatio.com/docs/ghc/
09:04:24 <byorgey> malosh: note that STRefs are lazy
09:04:25 <mmorrow> is HEAD from january
09:04:33 <mmorrow> and the corresponding hoogle file is
09:04:40 <mmorrow> http://moonpatio.com/docs/ghc/ghc.txt
09:04:41 <byorgey> malosh: so those writeSTRef stc $ c + 1  and so on are building up massive thunks
09:05:01 <byorgey> try using  writeSTRef stc $! c + 1  and so on, instead
09:05:15 <mmorrow> (hoogle --convert=ghc.txt; hoogle --data=ghc.hoo ModGuts)
09:11:17 <mmorrow> malosh: also there's Control.Monad.ST.Strict
09:11:31 <mmorrow> malosh: (Control.Monad.ST just re-exports Control.Monad.ST.Lazy)
09:12:52 <delopart> hey
09:12:53 <delopart> http://www.pastebin.org/7460
09:12:58 <delopart> how can i fix this error
09:13:34 <mmorrow> malosh: also, if you do  (data Fixed = Fixed {-# UNPACK #-} !Int) and {-# OPTIONS_GHC -funbox-strict-fields #-} you'll get the exact same data rep, but with the convenience of being able to pretend it's an Int in a Fixed
09:14:25 <koeien> delopart: were did you get ghc from? repository of debian/ubuntu?
09:14:37 <delopart> ubuntu
09:14:38 <koeien> if so-- install libghc6-mtl-dev
09:15:30 <malosh> mmorrow : the (fromIntegral op)-139 was the problem. Just a `seq` did it. I'll try the unpack too. sounds cool
09:17:14 <delopart> You will now have the cabal binary in $HOME/.cabal/bin. You should also add this directory to your $PATH.  i dont understand that must i add this to my .bachrc
09:17:29 <koeien> you do not HAVE to , but it is more convenient for you
09:17:51 <delopart> like export PATH blah ..
09:17:58 <koeien> otherwise you have to remember to enter "~/.cabal/bin/cabal install foo" every time instead of "cabal install foo"
09:19:03 <mmorrow> malosh: for instance, with {-# UNPACK #-}, a list of 4 Vec64 cons from the Vec type in the second paste produces the asm in the first paste http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3134
09:19:55 <delopart> koeien, export PATH=/home/delopart/.cabal/bin:$PATH
09:19:56 <delopart>  like that
09:20:11 <koeien> should do the trick
09:20:37 <mmorrow> so you literally get 128 machine doubles inside the constructor that you can pattern match on (but you'd only want to do something like this if every time you constructed a Vec64 you were doing it from scratch, since if you just change one field the entire thing needs to be copied)
09:21:17 <delopart> error again
09:21:22 <mmorrow> so it'd be nice for e.g. binding all 64 C's in a pattern match at once, then computing something
09:21:34 <koeien> delopart: which one?
09:21:48 <delopart> http://www.pastebin.org/7463
09:21:49 <delopart> look
09:22:39 <koeien> you probably installed a newer version of HTTP, why do you need the older one?
09:24:52 <delopart> i jus fallow a link
09:25:04 <delopart> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
09:25:16 <delopart> http://www.haskell.org/haskellwiki/Leksah_Installation#Install_cabal-install_from_CabalInstall
09:26:39 <delopart> koeien,  http://www.pastebin.org/7464
09:27:12 <delopart> i have to build that from source ?
09:27:24 <Saizan_> delopart: you need a newer ghc, and to install gtk2hs
09:28:04 <delopart> jaunty doesnt have new ghc
09:28:38 <Saizan_> you can install it from a generic binary tarball
09:28:43 <Saizan_> www.haskell.org/ghc
09:29:08 <delopart> how can i use prelude in ubuntu
09:29:16 <delopart> command line prompt
09:29:29 <Saizan_> you mean ghci?
09:29:52 <delopart> yeah okey
09:30:10 <Axman6> the Prelude is just a library of functions provided by default to you
09:33:02 <delopart> can someone suggest begginner tutorial for haskell i dont know anything about haskell
09:33:09 <delopart> i actually read plai book
09:33:22 <delopart> and this books teels laziness with haskell
09:34:56 <a_guest> In gtk2hs: I have noticed that the callback for destroyEvent for a window is not always called. Why?
09:36:45 <Axman6> delopart: try lyah:
09:36:47 <Axman6> @where lyah
09:36:48 <lambdabot> www.learnyouahaskell.com
09:36:54 <Axman6> or real world haskell:
09:36:58 <Axman6> @where rwh
09:36:58 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
09:42:00 <Gertm> lyah is great! Too bad it isn't finished yet.
09:42:07 <Gertm> but it's awesome
09:50:01 <meanburrito920_> I would actually suggest Write yourself a scheme in 48 hours. its on Wikibooks.org
09:50:04 <meanburrito920_> its quite good
09:50:11 <meanburrito920_> @where wyas
09:50:11 <lambdabot> I know nothing about wyas.
09:50:15 <meanburrito920_> dammit :)
09:50:26 <meanburrito920_> @where wyas48h
09:50:26 <lambdabot> I know nothing about wyas48h.
09:50:30 <meanburrito920_> :(
09:50:35 <meanburrito920_> @info
09:50:36 <lambdabot> ()
09:50:38 <meanburrito920_> @help
09:50:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:50:43 <meanburrito920_> @list
09:50:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:51:41 <meanburrito920_> @help where
09:51:41 <lambdabot> where <key>. Return element associated with key
09:51:51 <meanburrito920_> hm. i wonder how you set a new @WHERE
09:52:02 <Axman6>  @where+
09:52:42 <meanburrito920_> ah thanks
09:53:11 <meanburrito920_> @where+ wyas http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:53:12 <lambdabot> I will never forget.
09:53:16 <meanburrito920_> @where wyas
09:53:17 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:53:20 <meanburrito920_> awesome
09:53:36 <meanburrito920_> is there a way to get it to list all the links it currently has?
10:07:31 <shapr> hei Boxo
10:07:51 <shapr> hyvää huomenta!
10:09:10 <burp> > [(x,y) | x <- [1,2,3,4], y <- [1,2,3,4], x /= y]
10:09:11 <lambdabot>   [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
10:09:12 <Boxo> moi, tunnenko sut
10:09:21 <burp> > [(x,y) | x <- [1,2,3,4], y <- [1,2,3,4], x /= y, y> x]
10:09:22 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:09:49 <burp> hm, I want the last result but for any data type
10:09:55 <burp> so I don't need to use y > x
10:10:50 <burp> should I build a data type and instance Eq where (a,b) == (b,a)
10:11:00 <burp> or are there any other ideas?
10:14:44 <burp> hm, maybe I can do something with tails  and inits
10:16:14 <|randomwords|> > [ (x,y) | x <- [1 .. 4], y <- [(x+1) .. 4] ]
10:16:15 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:18:13 <burp> ah yes, this is the idea
10:19:46 <burp> I need to generalize it for any type
10:20:22 <burp> so when it takes the i. element from x, y <- drop i x
10:21:12 <|randomwords|> Will x and y always come from an identical list?
10:21:20 <burp> yes
10:22:38 <burp> > [(x,y) | i <- [1..3], x <- ['a', 'b', 'c', 'd'], y <- (drop (i) ['a', 'b', 'c', 'd'])]
10:22:39 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','b'),('b','c'),('b','d'),('c','b'),('c'...
10:22:45 <burp> hm, something like this
10:23:44 <burp> but without (x,x) elements
10:26:02 <|randomwords|> let f [] = []; f (x:xs) = map ((,) x) xs ++ f xs in f [1 .. 4]
10:26:19 <|randomwords|> > let f [] = []; f (x:xs) = map ((,) x) xs ++ f xs in f [1 .. 4]
10:26:21 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:26:31 <burp> um yes :-)
10:27:06 <burp> thanks
10:27:19 <burp> simple and clean solution
10:27:46 <|randomwords|> Not very efficient though I think
10:28:54 <burp> hm, looks fine for me
10:29:03 <burp> but this thing will be called very often on a list of ~100 elements
10:29:51 <|randomwords|> I think it will be fine in pracise, but the complexity could probably be improved by getting rid of (++)
10:32:50 <|randomwords|> No - I'm being stupid, it should be fine
10:34:24 <burp> the imperative program I'm translating uses a double for for this, i=1..n-1, j=i+1..n
10:35:01 <burp> ok
10:35:29 <aconbere> how does one hiding !! for example import Prelude hiding (!!)
10:36:53 <gwern> aconbere: ((!!))
10:36:58 <aconbere> aha!
10:36:59 <aconbere> of course
10:37:00 <aconbere> :)
10:37:14 <gwern> since it's hiding (foo), but to specify any operator you need (foo), so it's ((foo))
10:37:33 <gwern> imagine trying to 'import Prelude hiding (!!, length)
10:38:28 <aconbere> cool :)
10:38:33 <aconbere> thanks (now I've gotta run)
10:39:03 <gwern> jyp: what brings you here? isn't it an odd hour over there?
10:39:27 <jyp> 7:39
10:39:28 <lambdabot> jyp: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:29 <jyp> pm
10:39:56 * gwern figured it was ~midnight since your hours always seemed opposite mine
10:41:07 <jyp> gwern: I'm working rather intensively on Yi, so I thought I might hang about here in case any question pops up
10:41:22 <gwern> jyp: the dyred changes eh
10:41:52 <jyp> gwern: That and other things; I'm fixing memory leaks at the moment
10:42:03 <Berengal> Yay, memory leaks :)
10:42:05 <jyp> which should improve performance
10:42:13 <jyp> time-wise
10:42:16 <gwern> those darn memory leaks. I'm always amazed at how there seems to be another one
10:42:32 <gwern> (dons is always so sanguine about memory leaks, but the reality isn't so nice)
10:42:55 <bos> after a while, you get used to finding and squishing them fairly fast.
10:43:09 <bos> the ones that are in library code that you don't grok are the bad ones.
10:43:13 <Berengal> I've got a 12 hour old yi process that's only using 100mb now though, so it's improved
10:43:15 <burp> > map (\e -> [(x,y) | x <- [head e], y <- tail e]) $ init $ init $ tails [1,2,3,4]
10:43:16 <lambdabot>   [[(1,2),(1,3),(1,4)],[(2,3),(2,4)],[(3,4)]]
10:43:21 <jyp> Actually I found a simple piece of code that produces a leak, and I found a fix, but I can't figure out why it's happening in the first place
10:43:35 <burp> > concat $ map (\e -> [(x,y) | x <- [head e], y <- tail e]) $ init $ init $ tails [1,2,3,4]
10:43:36 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:43:37 <jmcarthur> i haven't too many problems with memory leaks ever since i got a fair grasp on what's happening
10:43:44 <burp> |randomwords|: what about this one ;)
10:44:10 <jmcarthur> most of the time it's because you didn't make a function/data structure with the correct strictness/laziness in the first place
10:44:23 <jmcarthur> as long as you take that into account when you write the function you shouldn't have a problem
10:44:29 * Berengal has a keyboard shortcut to kill the most memory intensive program on his system
10:44:45 <jyp> jmcarthur: Indeed, but that means for example that you can't use Data.Map
10:44:48 <jyp> annoying
10:45:03 <jmcarthur> jyp: because it's strict?
10:45:05 <bos> hm?
10:45:13 <jyp> jmcarthur: it's lazy in its values
10:45:16 <bos> why can you not use Data.Map?
10:45:17 <jmcarthur> right
10:45:20 <|randomwords|> burp: it looks similar but uglier
10:45:24 <jmcarthur> as it should be... i thought
10:45:27 <burp> yes its ugly :(
10:45:39 <bos> really, collections should be strict in their values by default.
10:45:52 <bos> it's much easier to add laziness than to add strictness.
10:45:52 <jmcarthur> bos: what is your reasoning?
10:45:56 <jmcarthur> ah
10:45:57 <jyp> jmcarthur: The "state" of the editor should be hyperstrict I think
10:46:10 <jmcarthur> okay i see that
10:46:28 <bos> but if you look at the Data.Map API, there are a few places where you really want to have control over strictness but simply can't get it.
10:46:34 <sjanssen> bos: but if all of our collections are strict, what's the point of having laziness at all?
10:46:56 <jmcarthur> data Lazy a = Lazy a  -- easy lazy data for strict collections
10:46:58 <sjanssen> I know "data Thunk a = Thunk a", but that's not particularly fun to use
10:47:06 <jmcarthur> heh
10:47:49 <jmcarthur> sjanssen: i thought the point of having laziness, even with strict collections, is for codata
10:47:50 <bos> sjanssen: i can't tell you what the point of having laziness in collections is, because i almost never seem to want it in practice.
10:48:35 <jmcarthur> i would rather have a lazy spine than lazy elements i guess
10:48:37 <sjanssen> I suppose collections being WHNF strict wouldn't be so bad
10:49:31 <jmcarthur> indeed, i do typically write my structures that way
10:50:10 <sjanssen> I agree there are strictness problems with Map, but it seems like making it strict is a lame solution
10:50:49 <jmcarthur> lazy, balancing trees just don't make intuitive sense to me, but perhaps that is because i have chosen to just not think about it
10:51:12 <sjanssen> Map is spine strict
10:51:16 <jmcarthur> right
10:51:25 <jmcarthur> and i think the balancing thing is why
10:51:50 <sjanssen> but laziness in the values is genuinely useful in some situations
10:52:24 <jmcarthur> i am undecided on the strict/lazy elements by default thing
10:52:37 <jmcarthur> i see bos's point about it being easier to add laziness later than to add strictness later
10:53:29 <Berengal> I tend to prefer lazyness by default, but then again I haven't really run into any memory leaks I couldn't just C-c
10:54:04 <jmcarthur> it does kind of suck when you don't realize you have a memory leak until linux starts randomly killing processes (who decided *that* was a good policy, anyway?)
10:54:35 <jmcarthur> well, i guess that's if you don't use swap
10:54:43 <|randomwords|> > concatMap (\(x:xs) -> map ((,) x) xs) $ (init . tails) [1,2,3,4]
10:54:45 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:54:53 <jmcarthur> if you do, then you just get into this situation where you can't really kill anything because it's too busy with IO
10:54:53 <Berengal> I've got 5Gb of swap. I usually start killing random processes long before linux gets a chance to
10:55:02 <|randomwords|> burp: If that's more the style you're after
10:56:18 <burp> I'm looking for performance
10:56:30 <jmcarthur> it is my opinion that in this day and age when 4GB or 8GB of RAM is becoming common you shouldn't really have to have swap anymore (besides Linux's stupid process-killing policy when you make a bug)
10:56:31 <burp> but I appreciate style solutions too :>
10:57:13 <mike-burns> Swap is used for kernel dumps for debugging.
10:59:49 <wzrd> as
11:00:33 <wzrd> hi
11:00:49 <BMeph> > concatMap (\(x:xs) -> map ((,) x) xs) . tails $ [1,2,3,4]
11:00:51 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)* Exception: <interactive>:1:160-184: N...
11:01:05 <BMeph> Whoo-HOO! :P
11:05:31 <|randomwords|> > let a = tails [1,2,3,4] in concat $ zipWith (zip) a (tail a)
11:05:33 <lambdabot>   [(1,2),(2,3),(3,4),(2,3),(3,4),(3,4)]
11:05:48 <|randomwords|> blugh
11:06:06 <burp> nice
11:06:10 <|randomwords|> it's wrong
11:06:17 <burp> oh yes it is
11:06:19 <ksf> uhm... how does Graphics.Rendering.OpenGL handle extensions?
11:06:38 <ksf> I wanna do render to texture.
11:07:48 <twanvl> > [(x,y) | (x:xs) <- tails [1,2,3,4], y <- xs]
11:07:49 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
11:08:04 <burp> wow
11:08:07 <||Zero||> hello
11:08:11 <||Zero||> i need help
11:08:17 <||Zero||> with my code
11:08:22 <||Zero||> yesterday i was here
11:08:27 <burp> thats sleek :>
11:08:43 <ksf> you're here today, too.
11:08:51 <||Zero||> i installed hugs with libraries
11:09:22 <||Zero||> but when i run my code it can recognize the opengl library
11:09:28 <||Zero||> cant
11:09:35 <||Zero||> give me an error
11:09:40 <ksf> well, just use ghci.
11:10:07 <ksf> if you want to do 3d programming, hugs is too slow, anyway, and I'm 100% positive that gl works under ghc.
11:10:31 <ksf> (...at least if you run linux, that is, dunno about other platforms)
11:10:38 <||Zero||> but i need to do in hugs
11:12:03 <|randomwords|> > concatMap ((uncurry $ liftM2 (,)) . splitAt 1) $ tails [1,2,3,4]
11:12:05 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
11:12:24 <|randomwords|> But I think twanvl has won
11:12:40 <burp> hehe
11:13:02 <ksf> ...what's the error message, anyway? hpaste.org
11:13:41 <pikhq> > tails [1,2,3,4] >>= splitAt 1 >>= uncurry $ liftM2 (.)
11:13:42 <lambdabot>   Couldn't match expected type `a -> a1'
11:13:45 <pikhq> ... Typo.
11:13:46 <pikhq> > tails [1,2,3,4] >>= splitAt 1 >>= uncurry $ liftM2 (,)
11:13:47 <lambdabot>   Couldn't match expected type `a -> a1'
11:13:57 <pikhq> Not to mention thinko.
11:15:23 <||Zero||> wait me ill paste my code error
11:15:56 <|randomwords|> But code golf is fun.
11:18:22 <twanvl> > filter ((==2) . length) . subsequences $ [1,2,3,4]
11:18:24 <lambdabot>   [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]]
11:18:42 <ksf> ...Graphics.Rendering.OpenGL.GL.Framebuffer has drawBuffer, but I can't find anything to bind a texture to a buffer...
11:20:14 <burp> ah subsequences.. nice
11:20:26 <burp> but I guess your previous solution is faster
11:20:33 <Milo-> bah, I've been reading a guide about fold and scan for few days now and I still can't use those functions, or see what they are good for :C
11:21:02 <gwern> well, scan is relatively unusual, but fold is common enough
11:21:07 <ksf> > foldr (*) [1..10]
11:21:09 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
11:21:09 <lambdabot>    arising from a us...
11:21:16 <ksf> > foldr (*) 1 [1..10]
11:21:18 <lambdabot>   3628800
11:21:22 <ksf> see?
11:21:24 <ksf> it's simlpe.
11:21:34 <Milo->  yes but what is the use for it?
11:21:45 <burp> > length $ subsequences [1..20]
11:21:46 <gwern> Milo-: when map just doesn't cut it
11:21:47 <lambdabot>   1048576
11:21:50 <ksf> dunno. one doesn't need factorials that often.
11:21:54 <burp> I will be using lists of ~100 entries
11:21:59 <michaelfeathers> I was wondering, is there some nice way to compose maps to pull pieces out of nested lists?  Seems like this would be an operation which would come up from time to time: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8017#a8017
11:22:12 <Milo-> don't see the point for map either, heh. I'm slightly confused about haskell in general
11:22:22 <Milo-> I'm not cabable of doing anything smartly
11:22:28 <gwern> specifically, you use map when you need to do something on a bunch of things, but this something is independent; however, when that something is not independent, then you need a fold
11:22:35 <gwern> > foldr x [1..10]
11:22:36 <lambdabot>   Couldn't match expected type `a -> b -> b'
11:22:40 <gwern> > foldr1 x [1..10]
11:22:41 <lambdabot>   Couldn't match expected type `a -> a -> a'
11:22:48 <ksf> > map (*2) [1..]
11:22:48 <gwern> oh come on simplereflect -_-
11:22:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
11:23:31 <twanvl> michaelfeathers: integer indices are very uncommon in haskell
11:23:41 <Milo-> how long will it take for me to learn the functional way, after been programming C and such for ages.
11:23:43 <twanvl> > foldr f x [1..10]
11:23:45 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 x)))))))))
11:23:52 <gwern> > foldr f z [1,2,3]
11:23:53 <lambdabot>   f 1 (f 2 (f 3 z))
11:24:13 <gwern> the examples in augustss' blog post work fine, but it breaks everytime I try something a little bit different :(
11:24:17 <ksf> Milo-, simply speaking, map applies a function to every element of a structure (e.g. a list), preserving the structure, "changing" the value.
11:24:32 <ksf> folds collapse the structure.
11:24:56 <ksf> ...so if you want to build a map out of a fold, you have to build the structure again.
11:25:09 <ksf> ...which is your assignment for now: implement map in terms of fold.
11:25:27 <gwern> ksf: meany
11:25:41 <mike-burns> Milo-: Think of `foldr' as one of Haskell's most primitive looping construct. It's used to define `sum', `length', etc.
11:26:09 <Milo-> heh ok
11:26:17 <gwern> mike-burns: perhaps Milo- just needs experience with primitie recursion, then he'll understand how fold is an abstraction of the commonplace pattern
11:26:26 <mike-burns> gwern: Agreed.
11:26:41 <Milo-> I need to forget everything I have ever known about coding in sequences :P
11:26:52 <mike-burns> I just remembered that what gwern said is both how I was taught it and how I taught it to others.
11:26:58 <gwern> once you've written enough variants on 'foo x = 1 + foo (tail x)', you start to aprpeciate fold
11:27:13 <ksf> I learned my folds out of sicp.
11:27:20 <Milo-> In C-like languages, you write a sequence that executes as you want it to do, but in haskell, I'm not really sure what gets evaluated.
11:27:29 <gwern> ksf: not a bad palce. certainly it makes you write enough primitive recursion...
11:27:40 <ksf> ...and, in fact, already thought of for loops as maps before that.
11:27:41 <shapr> @quote
11:27:42 <lambdabot> poetix says: < poetix_>: In ancient Athens, they used to punish adulterers by forcing radishes up their rectums < boegel>: poetix_: sounds like fun !
11:27:53 <shapr> um
11:28:00 <mike-burns> Milo-: Sorta. In C you talk about looping some number of times, whereas in Haskell you talk about applying a function to the data in a list.
11:28:00 <shapr> @quote haskell
11:28:00 <lambdabot> DuncanCoutts says: I’m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
11:28:00 <ksf> for loops are folds, too, of course.
11:28:06 <shapr> hiya mike-burns!
11:28:08 <shapr> How's code?
11:28:10 <mike-burns> shapr: Hello!
11:28:11 * gwern has never seen that radish qoute
11:28:27 <mike-burns> shapr: The code is slowed only by the complexities of GTK.
11:28:42 <shapr> Ah, sounds exciting. Making progress on your tagger?
11:28:45 <ksf> for (int i = length; --i>=0;) acc += arr[i]; is a fold.
11:28:46 <Milo-> Takes time to get used to this stuff.
11:28:52 <mmorrow> for(i=0; i<n; i++){x[i] = foo(i);} ===> map foo [0..n-1]
11:29:02 <mike-burns> shapr: Barely. I've been banging my head against drag-and-drop for the past two days.
11:29:02 <Milo-> I'm afraid to write anything more complex than few lines, because I have no idea what it does :/
11:29:05 <shapr> mmorrow: The second choice looks simpler.
11:29:07 <ksf> for (int i = length; --i>=0;) arr2[i] = arr[i] + 2; is a map.
11:29:07 <gwern> Milo-: certainly, but that's what great resources like SICP or RWH are for
11:29:36 <mmorrow> shapr: very
11:29:47 <shapr> mike-burns: Oh, I've never done drag'n'drop with gtk, you're saying it's complicated?
11:30:16 <Milo-> "royal women's hospital"? :p
11:30:27 <gwern> @where RWH
11:30:28 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
11:30:42 <Milo-> realworldhaskell :P
11:30:43 <mike-burns> shapr: It's poorly documented. I've been going over the code for HaskellFM (the filemanager written in Haskell) but that sadly doesn't illuminate.
11:30:46 <Milo-> sounds better than hospital :P
11:30:48 <gwern> yes. the hospital is the best place to lern haskell. it is realworld
11:30:57 <gwern> mike-burns: haskellfm?
11:31:20 <gwern> that's a new one on me, and I thought I'd heard of/uploaded to hackage most haskell projects
11:31:34 <mike-burns> gwern: http://www.mickinator.com/wordpress/
11:31:38 <mmorrow> for(i=0; i<n; i++){ys[i] = foo(xs[i],i);} ===> zipWith foo xs [0..n-1]
11:32:17 <gwern> hm, how can you claim it is released if it's not on hackage?
11:32:24 <gwern> @quote hackage.*exist
11:32:25 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
11:32:35 <mike-burns> Heh.
11:32:40 <Milo-> @where sicp
11:32:40 <lambdabot> http://mitpress.mit.edu/sicp/
11:33:15 <michaelfeathers> Can anyone who's interested tell me if I said something stupid here? http://snurl.com/pgad3  I'm sure the code is embarrassing.
11:34:00 <mike-burns> What I really want is a higher level of abstraction than comes with gtk2hs; I want to make a file manager window and tell it which files to show, letting it handle thumbnailing, drag-and-drop, etc.
11:34:53 <gwern> ah, you want to chase the pipe dream of frp
11:35:00 <shapr> michaelfeathers: I liked your post on functional refactoring.
11:35:11 <michaelfeathers> shapr: Thx.
11:35:14 <mike-burns> gwern: Well yes, that too.
11:35:25 * shapr reads the new post
11:35:35 <michaelfeathers> I like feeling like a newb again.
11:36:23 <shapr> michaelfeathers: Stylistically, I'd suggest using hscolour on your Haskell sources.
11:36:52 <ksf> hmmm  http://hackage.haskell.org/packages/archive/OpenGLRaw/1.0.1.0/doc/html/Graphics-Rendering-OpenGL-Raw-EXT-FramebufferObject.html
11:37:12 <ksf> ...which doesn't bring me any closer to a function to call to render to a texture.
11:37:51 <Berengal> michaelfeathers: Nice point. It's actually what I think is the most important about lazy evaluation
11:38:24 <mike-burns> michaelfeathers: No critcisms about that blog post; it looks good. I like the example you've used.
11:39:48 <shapr> michaelfeathers: Yeah, same here. Laziness allows for more compositional logic.
11:40:18 <Nafai> What's the URL to michaelfeathers' blog?
11:40:26 <shapr> http://blog.objectmentor.com/articles/2009/08/08/imposing-the-edges-later
11:40:38 <Nafai> Ah, thanks
11:40:43 <ksf> ...instead of calculating what you need, specify the whole universe, then grep interesting bits out of it.
11:41:04 <michaelfeathers> Thx.  It is such an odd thing.. I like to write about cool things I'm learning about functional for a mainstream audience, but immediately you hit the syntax barrier.  I wonder if someone who doesn't have a bit of Haskell under their belt really gets that, but the idea of coding something like that in a more mainstream language is a bit terrifying.
11:41:44 <ksf> well, people have to understand thunking.
11:41:53 <Berengal> thunking is hard
11:42:05 <ksf> ...without closures, certainly.
11:42:13 <shachaf> They also have to understand thinking.
11:42:16 <shachaf> Which is even harder.
11:42:42 <ksf> in java it's quite straight-forward, though, if you don't want to scare people with scheme.
11:43:29 <ksf> also, if (pred1() && pred2()) is lazy.
11:43:34 <Berengal> When programming in strict languages, I find myself thinking "I have to decide this /now/?" all the time, then start writing some horribly ad hoc and complex thunking mechanism :(
11:43:40 <ksf> ...pred2() isn't evaluated eagerly.
11:44:12 <Berengal> ksf: I've actually abused that a bit too much
11:44:28 <ksf> that's been my first lazyness error, btw, using getc() at the rhs of a &&.
11:45:14 <michaelfeathers> ksf: In Java with some lazy list abstraction?  Sort of like Scheme's scheme?
11:46:40 <ksf> see http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2
11:47:40 <ksf> in some sense, j2se already comes with thunks.
11:47:55 <ksf> they're called threads, you only get stuff done if you call .run().
11:48:03 <|randomwords|> burp: I image the fastest is the original recursive one
11:49:12 <michaelfeathers> ksf: Yeah, that's what I was thinking of.
11:49:40 <burp> |randomwords|: ok, I'll benchmark once this whole thing is ready
11:50:17 <ksf> lisp is horribly easy to implement in java, anyway, as you're given usable closures and a garbage collector.
11:50:36 <ksf> but the syntax is of course atrocious.
11:51:13 <mike-burns> How about something lighter than Java? Ruby, Python, etc.
11:51:37 * ksf doesn't feel like spending another hour googling for haskell's non-existent render to texture support.
11:51:49 <ksf> ruby and python are heavier than java.
11:51:56 <ksf> ...just look at the benchmarks.
11:52:00 <mike-burns> I meant syntactically lighter.
11:52:08 <Berengal> They're lighter on the syntax and the masochism
11:52:29 <mike-burns> Right. It's a blog post; the size of the binary isn't important there, but the syntax is.
11:52:34 <sjanssen> Python and Ruby are so hilarious in their own ways
11:52:36 <inimino> and the memory
11:52:36 <ksf> they don't come with GCs, do they?
11:53:01 <Berengal> They don't come with malloc/free either
11:53:04 <mike-burns> ksf: I ... don't understand. Are you asking if you have to malloc() and free() in Ruby and Python?
11:53:07 <sjanssen> global interpreter locks, monkey patching, pathetic GC algorithms, etc.
11:53:32 <Berengal> Monkey patching is absolutely hillarious
11:53:32 <mike-burns> I'm only talking about syntax here. This is a blog post, not a program my bank is running.
11:53:49 <mike-burns> Its only point is to communicate effectively.
11:54:26 <ksf> ah, now I get it: they use refcounting, don't they?
11:54:40 <ksf> I don't call those beasts garbage collectors.
11:54:43 <Berengal> ksf: Python does at least
11:54:43 <sjanssen> ksf: refcounting with cycle detections
11:54:51 <Berengal> I don't know what ruby does
11:55:02 <Berengal> Or yarv
11:55:09 <sjanssen> ksf: I'd say it still counts as GC, even though it's a crappy GC
11:55:21 <Berengal> jython uses the java gc, naturally
11:55:21 <mike-burns> I seriously didn't intend to start a language war. I was only suggesting an alternative syntax for this.
11:55:46 <Berengal> mike-burns: The only real alternative is another lazy language, which probably won't help
11:55:53 <ksf> mike-burns, you might try using something less terse than comprehensions.
11:56:09 <ksf> ...although pythonistas might be fine with it.
11:56:10 <Berengal> Porting the code to python/java or any other strict language will only serve to confuse the issue
11:56:11 <|randomwords|> burp: Playing around in ghci (so unoptimised) it seems that (let f [] = []; f (x:xs) = map ((,) x) xs ++ f xs) and (concatMap ((uncurry $ liftM2 (,)) . splitAt 1) $ tails) are the fastest solutions. This may change under -O2 though
11:56:36 <mike-burns> ksf: I didn't use any comprehsensions?
11:56:47 <jmcarthur> i'm sure somebody has wanted something like this before: class Foo a where bar :: Int
11:56:53 <jmcarthur> of course that won't work
11:56:55 <ksf> using list monads directly is an idea, too.
11:57:03 <jmcarthur> what are some ways to do something similar?
11:57:04 <|randomwords|> sorry not (concatMap ((uncurry $ liftM2 (,)) . splitAt 1) $ tails) but (concatMap (\(x:xs) -> map ((,) x) xs) $ (init . tails))
11:57:24 <ksf> jmcarthur, where data Bar = Bar Int?
11:57:35 <burp> |randomwords|: thanks
11:57:36 <Berengal> jmcarthur: bar :: a -> Int
11:57:36 <ksf> ...don't know the precise syntax.
11:57:44 <jmcarthur> ksf: it needs to always be Int
11:57:59 <jmcarthur> Berengal: yeah, i thought about that. passing undefined is ugly though :(
11:58:19 <ksf> ...that's why you need a data definition, not a function.
11:58:29 <ksf> hmm.
11:58:30 <jmcarthur> ksf: you mean outside of the type class?
11:58:34 <ksf> inside.
11:58:37 <jmcarthur> not an associated type
11:58:53 <jmcarthur> inside means the type can be different for different instances
11:58:59 <jmcarthur> but it needs to always be Int
11:59:04 <jmcarthur> (in my case)
11:59:23 <ksf> does () -> Int work?
11:59:37 <jmcarthur> ksf: that type doesn't have 'a' in it
11:59:47 <hackagebot> EnumMap 0.0.1 - More general IntMap replacement. (JohnVanEnk)
12:00:11 <jmcarthur> i suppose i could define: data Bar a = Bar Int somewhere outside the class, but that just moves the problem somewhere else
12:00:17 <Berengal> type Bar a :: *; bar :: Bar a; instance Foo Baz where type Bar Baz = Int; bar = 5
12:00:17 <jmcarthur> will still require a type annotation to use it
12:01:19 <jmcarthur> and then every instance will have to have an overrideable associated type :(
12:01:23 <jmcarthur> ^^ Berengal
12:01:31 <ksf> jmcarthur, you're either going to need a type sig or some existing value of that type.
12:01:36 <jmcarthur> yeah
12:01:42 <ksf> everything else would mean ghc has a crystal ball.
12:01:42 <jmcarthur> i was just wondering if there was a pretty way
12:01:50 <jmcarthur> the bar :: a -> Int way is probably best
12:01:54 <sjanssen> jmcarthur: the standard workaround is class Foo a where bar :: a -> Int -- ^ the argument is never used
12:02:02 <jmcarthur> sjanssen: yeah :\
12:02:04 <Berengal> jmcarthur: I know, but it might decrease the amount of signatures you have to write. ScopedTypeVariables might bring it down even more
12:02:23 <jmcarthur> i'll just make it accept a bogus parameter
12:03:29 <jmcarthur> thanks
12:04:14 <ksf> mike-burns, I meant those comprehensions in http://blog.objectmentor.com/articles/2009/08/08/imposing-the-edges-later , not shure what you were talking about.
12:04:53 <mike-burns> Ah okay.
12:05:25 <sjanssen> maybe we should standardize on a type: newtype Witness a b = Witness {unwitness :: b}?
12:05:45 <sjanssen> class Storable a where sizeOf :: Witness a Int
12:06:01 <c_wraith> Err.  What's the a in Witness for?
12:06:29 <ksf> instance Storable Word32 where sizeOf :: Witness 4
12:06:37 <ksf> uh s/::/=
12:06:52 <sjanssen> c_wraith: we can use it to tell the type system which instance we want
12:06:54 <ksf> ...to capture the "Word32"
12:07:34 <ksf> type hackery currently feels like template programming.
12:07:37 <sjanssen> or maybe data Witness a; class Storable a where sizeOf :: Witness a -> Int -- is better?
12:08:51 <jmcarthur> sjanssen: that at least seems to have the advantage that sizeOf can't examine its argument (over just a -> Int)
12:09:03 <sjanssen> with helpers: witnessAsTypeOf :: a -> Witness a
12:09:11 <ksf> my guess is that h' isn't taking up speed 'cos everyone involved is too embarrassed to work on something without full-fledged dependent types
12:09:25 <jmcarthur> i dunno. i think there's gonna be a fair bit of boilerplate no matter which way we do it
12:10:25 <ksf> I guess passing a witness is syntacically less burdensome than unpacking a value.
12:11:21 <ksf> ...you could end up fmapping unwitness.
12:11:34 <jmcarthur> ugh, with the (a -> Int) version i already ran into a situation that requires scoped types
12:12:00 <sjanssen> jmcarthur: with cleverness, scoped types are very rarely required
12:13:09 <jmcarthur> okay, well, not required here i guess, but the workaround isn't pretty either
12:17:14 <jmcarthur> instance Foo a => Foo (Maybe a) where bar m = 1 + bar (fromJust m)   -- yuck :(
12:17:45 <jmcarthur> and that trick won't work if there isn't a function of type f a -> a
12:19:45 <wgsilkie> > 1:[2,3,4]:5
12:19:47 <lambdabot>   No instance for (GHC.Num.Num [[t]])
12:19:47 <lambdabot>    arising from the literal `5' at <int...
12:20:01 <wgsilkie> Why doesn't that work?
12:20:02 <jmcarthur> > 1:[2,3,4]++[5]
12:20:04 <lambdabot>   [1,2,3,4,5]
12:20:08 <mike-burns> :t (:)
12:20:09 <jmcarthur> :t (:)
12:20:09 <lambdabot> forall a. a -> [a] -> [a]
12:20:10 <lambdabot> forall a. a -> [a] -> [a]
12:20:15 <Berengal> > [2,3,4]:[]
12:20:15 <jmcarthur> :t (++)
12:20:16 <ksf> http://code.haskell.org/~bkomuves/
12:20:16 <lambdabot>   [[2,3,4]]
12:20:17 <ksf> ha!
12:20:17 <lambdabot> forall a. [a] -> [a] -> [a]
12:20:19 <ksf> got it.
12:20:56 <c_wraith> wgsilkie:  Because the second argument of (:) needs to be a list.
12:20:58 <wgsilkie> :t ++
12:21:00 <lambdabot> parse error on input `++'
12:21:12 <jmcarthur> wgsilkie: try :t (++)
12:21:12 <wgsilkie> :t (++)
12:21:14 <lambdabot> forall a. [a] -> [a] -> [a]
12:21:24 <wgsilkie> @src forall
12:21:24 <lambdabot> Source not found. My mind is going. I can feel it.
12:21:30 <wgsilkie> :t forall
12:21:31 <lambdabot> Not in scope: `forall'
12:21:39 <c_wraith> forall is an extension that just is part of typesw
12:21:51 <wgsilkie> Oh.
12:22:09 <wgsilkie> What is forall for?
12:22:27 <Berengal> "for all"
12:23:06 <Berengal> "forall a. [a] -> [a] -> [a]" means "For all types 'a', list of 'a' to list of 'a' to list of 'a'"
12:23:24 <wgsilkie> Oh, I see.
12:23:29 <wgsilkie> Thanks!
12:24:18 <Berengal> They only become magic once they start appearing in the middle of type signatures
12:27:14 <ksf> does anyone know what format http://code.haskell.org/~bkomuves/hopengl_2009-03-13.patch has? patch doesn't eat it.
12:28:59 <shachaf> ksf: Looks darcsy, no?
12:30:06 <Berengal> Yeah, looks darcs-ish
12:30:25 <ksf> wtf so I need to download a darcs version instead of just patching the tarball?
12:32:02 <ksf> according to darcs' man page it doesn't support not caring about history.
12:33:43 <ksf> for aeons, people have used diff/patch.
12:34:27 <ksf> newfangled knick-knack.
12:35:02 <c_wraith> darcs is a pretty good system.  If it was less buggy, it'd be a *really* good system
12:35:03 <mornfall> Does GHC inline across modules by default?
12:35:22 <mornfall> c_wraith: (We are working on it. Sorry for the inconvenience.)
12:35:39 <Lemmih> mornfall: Yes.
12:36:19 <mornfall> Is there something I could read about how it decides to (not) inline?
12:36:36 <c_wraith> I've ended up in strange situations where conflicts just don't go away.  I record a resolution patch, then do a darcs resolve, and the same conflict appears.  It's baffling.
12:36:39 <mornfall> My experience is, that sprinkling a few INLINE pragmas around modules *usually* helps.
12:36:45 <mornfall> With performance, that is.
12:37:04 <||Zero||> Can't find imported module "Graphics.UI.GLUT"
12:37:09 <||Zero||> why i receive that error
12:37:21 <Berengal> mornfall: The ghc manual probably does, so RTFM?
12:37:34 <wgsilkie> > let x = 5 in x*y where y = 3
12:37:35 <lambdabot>   <no location info>: parse error on input `where'
12:37:40 <wgsilkie> > let x = 5 in x*y
12:37:40 <ksf> Merging us 47/50 ... if it stays like that longer than it takes me to finish my cappuchino...
12:37:41 <lambdabot>   5 * y
12:37:47 <wgsilkie> > let x = 5 in x*3
12:37:49 <lambdabot>   15
12:38:06 <wgsilkie> 5*y where y = 3
12:38:16 <wgsilkie> > 5*y where y = 3
12:38:17 <lambdabot>   <no location info>: parse error on input `where'
12:38:46 <Lemmih> mornfall: The inliner uses some pretty dark magic.
12:38:47 <Berengal> mornfall: Actually, a quick search only reveals that the pragmas exist, not the general behaviour
12:39:01 <ksf> where only works in function definitions, and lambdabot takes statements like do, just the same as ghci.
12:39:15 <wgsilkie> How does where work?
12:39:20 <wgsilkie> > 5*y where y = 3
12:39:21 <lambdabot>   <no location info>: parse error on input `where'
12:39:25 <Berengal> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#inline-noinline-pragma
12:39:34 <ksf> it's a syntactic thingie.
12:39:46 <Berengal> wgsilkie: It only works in files
12:39:58 <ksf> funname = body where fundefs
12:40:12 <wgsilkie> Oh...
12:40:15 <Lemmih> mornfall: Inserting INLINE pragmas without looking at the core is swinging a bat blindfolded.
12:40:52 <ksf> ...so, what should I do if dacrs won't apply a patch in acceptable time?
12:40:55 <mornfall> Berengal: I have found an explanation in manual.
12:41:59 <mornfall> But it basically says that simplifier does black magic to decide what to inline and when. :)
12:42:23 <mornfall> (And it also says that the pragma will make it inline the thing, very likely.)
12:42:54 <mornfall> But that still doesn't tell me what would get inlined automagically. (Okey, I'll try some core-reading, but it's not on the list of my strong points.)
12:44:03 <Berengal> mornfall: Do you really have to know what happens automatically though?
12:46:20 <Lemmih> mornfall: GHC does a fine job more often than not.
12:48:10 <ksf> I've converted the repo to darcs-2, and now darcs apply only prints the patch.
12:48:18 <ksf> I could've used cat to do that.
12:49:21 <ksf> I guess I'm going to fire up vi and apply the patch manually...
12:49:41 <mornfall> Well, I'm fighting for milliseconds.
12:49:59 <holmak> momfall: writing a raytracer?
12:50:18 <mornfall> Nah. Darcs.
12:50:39 <holmak> Why are you fighting for milliseconds in version control?
12:50:47 <Lemmih> mornfall: Then you have to look at the core. Inlining may not be the best thing to do.
12:50:50 <mornfall> Because git.
12:52:20 <brian6> ksf: complain, complain, complain, complain, complain, complain, complain, complain. piss/moan. WOE IS ME. etc.
12:52:44 <Berengal> Manually applying patches is so 60s
12:52:56 <mornfall> xlate64 = id ... takes 2.3% of my runtime! Those bastards. (At least the profiler thinks so.)
12:54:00 <Lemmih> mornfall: The profiling overhead is huge on such small functions.
12:54:10 <mornfall> Lemmih: Yes, I guess so. :)
12:54:30 <mornfall> What worries me more is   %GC time      50.5%  (51.9% elapsed)
12:54:55 <luite> is there a guide somewhere for installing extra C libraries for the haskell-platform distribution (for regex-posix)?
12:55:00 <Lemmih> mornfall: Paste the code. I'm just #haskell wants to play as well.
12:55:11 <mornfall> Uh. :)
12:55:20 <Lemmih> *I'm sure
12:55:21 <luite> oh, on windows :)
12:55:57 <artagnon> I'm attempting to maximize the number of recursive calls (or length of n_series in my code) using different series_init values, but I seem to be stuck. Can I get a small hint? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8018#a8018
12:56:31 <mornfall> Lemmih: http://web.mornfall.net/stuff/Index.hs -- the rest of the library is current in darcs get http://repos.mornfall.net/hashed-storage, haddocks at http://repos.mornfall.net/hashed-storage/dist/doc/html/hashed-storage/
12:56:54 <ksf> I'm still accepting hints on how to make darcs apply that patch.
12:57:15 <mornfall> I guess one could do something to the data structures that are passed around.
12:58:05 <artagnon> ofcourse the code is hopelessly incomplete. I want to find different n_series lists for different values of series_init, and measure their lengths and maximize that.
12:58:09 <Lemmih> artagnon: That doesn't look like valid Haskell.
12:58:19 <artagnon> Lemmih: it doesn't?
12:58:35 <artagnon> I've tried using guards within the list. Maybe it's wrong
12:58:52 <Lemmih> artagnon: Yeah, guards don't work that way.
12:58:58 <artagnon> hm.
12:59:10 <mornfall> http://web.mornfall.net/stuff/darcs.prof should be a profile.
12:59:21 <artagnon> What should I do then?
13:00:22 <mornfall> (You can probably disregard most of the INLINE nonsense, it doesn't help anyway.)
13:01:47 <mornfall> I can shave of 0.04s by passing -H100m
13:02:23 <mornfall> But either way, with non-profiling binary, I get 78-80% GC time. (Wow.)
13:02:23 <Lemmih> mornfall: Can hashed-storage be tested independently?
13:02:38 <mornfall> Lemmih: For performance, not really, unfortunately.
13:03:27 <mornfall> Lemmih: It would take a relatively simple program though, I guess.
13:03:40 <luite> which libary do I need to install anyway, to get the required regex.h file on windows?
13:04:28 <mornfall> It does need a 60k files to run for .3 seconds though.
13:04:36 <mornfall> +repo
13:07:03 <mornfall> Let's beef up the repo with some extra files.
13:07:17 <brian6> luite: did you install mingw, msys, etc?
13:07:23 <mornfall> But I guess the problem really is just that it GCs too much.
13:08:23 <Lemmih> mornfall: Generating less garbage is usually an easy way to optimize a Haskell program.
13:08:58 <luite> brian6: yes, I don't have a regex.h though
13:09:20 <mornfall> Lemmih: Is it? :)
13:09:25 <mornfall> How would I go about doing that?
13:10:12 <artagnon> WIll the guards work now? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8018#a8019
13:10:18 <brian6> luite: there are some regex related files on http://sourceforge.net/projects/mingw/files/ .
13:10:23 <brian6> luite: maybe they have the headers.
13:10:26 <mornfall> Oh gosh!
13:11:25 <luite> brian6: ah thanks
13:11:28 <artagnon> but ofcourse, I can't keep redifining n within n itself.
13:11:43 <artagnon> I need to define it as some kind of infinite list
13:12:43 <Lemmih> artagnon: What should the first three elements of the list be?
13:13:28 <Lemmih> mornfall: It's usually something simple like removing some unnecessary boxing/unboxing in an inner loop.
13:14:24 <artagnon> Lemmih: er, not first three elements. I need one init value. After that, the next number is either n/2 or 3n+1, depending on whether n is even or odd.
13:16:34 <Ytinasni> > let next a = if a `mod` 2 == 1 then a `div` 2 else 3*a+1 in iterate next 100
13:16:35 <lambdabot>   [100,301,150,451,225,112,337,168,505,252,757,378,1135,567,283,141,70,211,10...
13:17:27 <artagnon> Ytinasni: Nice! :)
13:17:34 <artagnon> I should learn to do it myself soon
13:17:45 <artagnon> I keep coming back here when I get such a problem :/
13:17:58 <Lemmih> artagnon: Try doing the recursion yourself.
13:18:10 <mornfall> Lemmih: So I should go by the alloc% numbers in the profile?
13:18:15 <artagnon> Ytinasni: is there a more elegant solution? Without using if-else ie.
13:18:16 <artagnon> ?
13:18:30 <Lemmih> mornfall: Yes. It'll give you some good starting points.
13:18:41 <artagnon> Lemmih: ok.
13:18:48 <Ytinasni> you could replace `if` with gaurds, though i don't think it's any cleaner.
13:18:51 <Lemmih> mornfall: If some function is too hard to improve, move on to the next.
13:19:06 * artagnon likes guards :)
13:19:25 <Ytinasni> > let next a = if a `mod` 2 == 0 then a `div` 2 else 3*a+1 in iterate next 100
13:19:26 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,...
13:19:38 * RayNbow wonders why Java (or more fairly, a Java programmer) needs 58 lines of code to produce all combinations with repetitions...
13:19:44 <roconnor> > 0.0**2.0
13:19:46 <lambdabot>   0.0
13:20:01 <roconnor> > (0.0 :+ 0.0)**(2.0 :+ 0.0)
13:20:02 <lambdabot>   NaN :+ NaN
13:20:02 <RayNbow> (while Haskell only needs about 8-10 lines)
13:20:16 <mike-burns> RayNbow: Because Java comes with different libraries.
13:20:17 <Cale> > 0^0
13:20:19 <lambdabot>   1
13:20:25 <Cale> > 0**0
13:20:26 <lambdabot>   1.0
13:20:32 <Cale> > (0:+1)**0
13:20:34 <lambdabot>   1.0 :+ 0.0
13:20:44 <malosh> mike-burns : you mean for instance java 1.1, java 1.2 etc ?
13:20:49 <RayNbow> mike-burns: but still...
13:21:11 <dmwit> > let next a = if even a then a `div` 2 else 3 * a + 1 in iterate next 100 -- fix a bug, plus don't use `mod` 2 when there's a perfectly good "even" or "odd" function ;-)
13:21:11 <RayNbow> http://gathering.tweakers.net/forum/view_message/32381543 <-- I don't even want to read this Java code :p
13:21:12 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,...
13:21:30 <RayNbow> (language note: the accompanying text is in Dutch)
13:21:45 <Ytinasni> @src even
13:21:45 <lambdabot> even n = n `rem` 2 == 0
13:21:55 <RayNbow> @src odd
13:21:55 <lambdabot> odd = not . even
13:22:24 <artagnon> dmwit: Right, thanks :)
13:24:16 <byorgey> > 0 `mod` 2
13:24:17 <lambdabot>   0
13:24:24 <byorgey> dmwit: what bug?
13:24:46 <roconnor> > (0.0 :+ 0.0)**(2.0 :+ 0.0) :: Complex CReal
13:24:51 <lambdabot>   mueval-core: Prelude.read: no parse
13:24:51 <lambdabot>  mueval: ExitFailure 1
13:24:54 <roconnor> :)
13:25:08 <dmwit> byorgey: Um, I was actually reading the one way back that had a `mod` 2 == 1, which I now see Ytinasni later fixed himself.
13:25:11 <dmwit> whoops
13:25:25 <byorgey> > shredded ^ wheat :: Breakfast CReal
13:25:26 <lambdabot>   Not in scope: type constructor or class `Breakfast'Not in scope: `shredded'...
13:25:37 <dmwit> cute =)
13:25:47 <byorgey> just being silly =)
13:26:10 <luite> is there a way to find out which packages depend on one particular package, with cabal, when doing an installation with lots of dependencies? (in my case, I'd like to see which packages need 'unix', at the lowest level)
13:26:13 <RayNbow> @hoogle (^)
13:26:13 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
13:26:13 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
13:26:13 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
13:26:38 <RayNbow> hmm... integral wheat...
13:27:41 <Berengal> luite: I think you'll just have to check all of them...
13:29:49 <roconnor> @quote CReal
13:29:50 <lambdabot> <pumpkin> says: we should throw it [CReal] in with Foreign.C.Types to confuse people
13:30:08 <mornfall> Lemmih: Hmm. Improving the function with most allocations (and time, incidentally) led to further decrease of productivity (although runtime dropped too a little, it seems).
13:30:39 <dmwit> Haskell: Where productivity is a bad thing.
13:30:43 <mornfall> I have now seen numbers as low as 10% (90% GC time...).
13:31:16 <Cale> mike-burns: The libraries which are needed to solve that problem in one line of Haskell take at most 10 lines of code.
13:31:43 <mornfall> Or did I get the terms backwards? Oh well, whatever. The 90% GC time is the important figure. :)
13:32:03 <mornfall> Well, it floats around 80, depending on the GC options I shove in.
13:32:17 <mike-burns> Cale: That's a fair point; Haskell is a more compact language. But the reason it's so gigantic in Java is because the functionality comes with Haskell but not with Java. It'd still be large in Java using a library though.
13:34:02 <burp> @hoogle when
13:34:03 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:34:18 <Berengal> Even something as simple as sorting a list of objects on a property of the objects is ~10 lines in java
13:34:35 <RayNbow> @google haskell pocketpc
13:34:36 <lambdabot> No Result Found.
13:34:43 <RayNbow> @google haskell windows mobile
13:34:43 <lambdabot> No Result Found.
13:34:51 * RayNbow blinks
13:35:22 <luite> Berengal: hm, I think I've checked them all, and there is just one. FileManip depends on unix, but I patched it to depend on unix-compat (the only required function not provided by unix-compat is easily replaced by System.IO.openTempFile)
13:35:40 <luite> but it wants to reinstall FileManip with the unix dependency
13:35:53 <artagnon> How do I quite iterate? ie. I want a rule for stopping the variable generation
13:36:03 <artagnon> s/quite/quit
13:36:11 <dmwit> RayNbow: ?google has been broken for a while now
13:36:24 <Berengal> artagnon: You can't
13:36:24 <RayNbow> dmwit: ah k
13:36:30 <artagnon> let f n = n - 1 in iterate n 100 say... but I want to stop at 40
13:36:35 <Lemmih> artagnon: That's not the right way to think about it.
13:36:36 <wgsilkie> What's wrong with this function? <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3222>
13:36:36 <Berengal> use takeWhile
13:36:41 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8021#a8021 ;)
13:36:45 <mike-burns> artagnon: `take' or `takeWhile'.
13:36:59 <artagnon> Berengal: But I want to stop when I get the term 40
13:37:06 <artagnon> takeWhile
13:37:07 <artagnon> got it
13:37:29 <Cale> wgsilkie: primeFactors takes an Int, and you're passing it a list
13:37:54 <luite> how can I find out why cabal-install wants to do this: FileManip-0.3.2 (reinstall) changes: unix-2.3.2.0 added, unix-compat-0.1.2.1
13:38:01 <dmwit> :t until
13:38:01 <wgsilkie> Oh, right... duh.
13:38:02 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:38:10 <Saizan_> luite: when you patch a package like that you want to give it a different version
13:38:12 <dmwit> artagnon: Is that one helpful?
13:38:18 <luite> Saizan_: ah
13:38:23 <Berengal> luite: The only thing I can think of is to force a dependecy collision and see which packages are involved
13:38:24 <Saizan_> luite: later version
13:38:44 <luite> ok, thanks
13:38:51 <Saizan_> luite: also, which version of cabal-install are you using?
13:39:00 <RayNbow> Cale: hmm... does that import only those two functions from the Prelude?
13:39:01 <luite> never needed such hacks on linux :)
13:39:01 <wgsilkie> Cale: Can you suggest a way to get it to work?
13:39:05 <dmwit> Oh, while we're on the topic of cabal-install, I have a question.
13:39:27 <luite> Saizan_: 0.6.2, using 1.6.0.3 of the Cabal library
13:39:30 <dmwit> I can "cabal build", but when I "cabal install", it tries (and fails) to rebuild a dependency (with different flags).
13:39:35 <dmwit> Is there a way to tell it not to do that?
13:39:41 <wgsilkie> I'm trying to eliminate numbers from the beginning of the list.
13:39:44 <Cale> RayNbow: yes
13:40:02 <Saizan_> dmwit: cabal install --only does what runghc Setup.hs install does and no more
13:40:12 <dmwit> Thanks!
13:40:51 * Berengal read that as (cabal install) (--only does what runghc Setup.hs install does and no more)
13:41:06 <RayNbow> Cale: so users have to define their own arithmetic functions? :p
13:41:38 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8021#a8022 -- squished one line out
13:42:18 * RayNbow highlights the import change :p
13:42:42 <RayNbow> *important
13:43:58 <artagnon> Ok, fixed. I'm getting some Type error now (as usual) :( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8018#a8023
13:44:46 <mornfall> RayNbow: You could probably get away with using if on a single line in replicate...
13:44:50 <mornfall> *hides*
13:45:03 <mornfall> Oh, nevermind. That'd need ==.
13:45:03 <RayNbow> mornfall: tell Cale, not me :p
13:45:07 <stanv> I found one interesting fact about haskell: it's impossible to write specifications that return various types, but have same type. For example:
13:45:10 <stanv> foo :: Int -> Int -> Int -> Int
13:45:13 <stanv> foo 2 y z = 2
13:45:15 <stanv> foo x = (\ _ _ -> 2*x)
13:45:18 <dmwit> replicate n x = map (const x) [1..n]
13:45:23 <dmwit> RayNbow: ^^
13:45:31 <mornfall> : - )
13:45:37 <RayNbow> artagnon: it would be nice if you included the type error in the hpaste (or mention it here)
13:45:40 <dmwit> oh
13:45:50 <dmwit> Well, (\_ -> x), since you don't have const.
13:45:54 <Cale> stanv: Yeah, pattern matching is required to be uniform.
13:45:57 <mornfall> dmwit: You don't have const tho. But (\_ -> x) would work.
13:46:03 <artagnon> TypeError: Couldn't match expected type `a' against inferred type `Int'
13:46:07 <Berengal> stanv: They have very slightly differnt semantics
13:46:09 <dmwit> mornfall: too slow =)
13:46:10 <mornfall> Or a comprehension.
13:46:11 <artagnon> RayNbow: ^^
13:46:25 <dmwit> > ['a' | [1..3]]
13:46:26 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:46:27 <byorgey> dmwit: but you don't have enumFromTo either, do you?  or is that implicit?
13:46:31 <idnar> stanv: foo x _ _ = 2*x works fine in that scenario, though
13:46:33 <dmwit> > ['a' | x <- [1..3]]
13:46:34 <lambdabot>   "aaa"
13:46:35 <RayNbow> ah
13:46:43 <RayNbow> :t length -- artagnon
13:46:44 <dmwit> byorgey: mmm, well, he's got ['a'..'e'] later, so...
13:46:44 <lambdabot> forall a. [a] -> Int
13:46:50 <RayNbow> :t genericLength -- artagnon
13:46:51 <lambdabot> forall b i. (Num i) => [b] -> i
13:46:51 <byorgey> ah, true, I guess that does work
13:46:56 <RayNbow> that's probably why you get the type error
13:47:11 <stanv> this two definition are correct, but can't be togather :(
13:47:15 <artagnon> RayNbow: Right, got it! Thanks :D
13:47:17 <soupdragon> why is nobody talking in agda
13:47:21 <artagnon> Type is damn annoying :(
13:47:24 <byorgey> stanv: yes, all the clauses of a definition must use the same number of patterns.  I forget why.
13:47:33 <soupdragon> it must be haskell is better than agda
13:48:01 <byorgey> soupdragon: it is for now.
13:48:07 <pikhq> stanv: I think it's got something to do with trying not to make the type inference have to work *too* hard. :P
13:48:10 <artagnon> RayNbow: I removed the type signature for the function and it's fixed. But I want to know: What type signature should the function have instead?
13:48:10 <dmwit> s/better/more popular/
13:48:29 <Berengal> byorgey: Let lifting, thunks, lamdas... something that has those words in it anyway
13:48:41 <byorgey> Berengal: yes, probably =)
13:48:58 <mornfall> Oh wow! +RTS -N2 actually speeds darcs whatsnew up (due to parallel GC I bet).
13:48:59 <dmwit> You know what I bet it is?
13:49:01 <RayNbow> artagnon: length causes the result to be Int (monomorphic), rather than Integral (polymorphic)
13:49:03 <dmwit> I bet it's the MR.
13:49:05 <Cale> http://www.youtube.com/watch?v=tYVCk10AzS0 -- haha
13:49:07 <stanv> so much finesses :(
13:49:12 <artagnon> RayNbow: I can't make it Integral a to Int a -- error: Type constructor `Int' used as a class
13:49:17 <byorgey> dmwit: that's why Haskell is more popular than Agda?
13:49:25 <artagnon> RayNbow: Right, got it.
13:49:29 <dmwit> byorgey: I bet if you manually change the equations with extra arguments to lambda expressions, you get different monomorphism restrictions.
13:49:32 <artagnon> So what can I do about it?
13:49:35 <pikhq> stanv: I highly doubt {#- UndecidableInstances -#} would change that. ;)
13:49:40 <byorgey> dmwit: eek!
13:49:45 <artagnon> apart from removing my function type signature ie.
13:49:48 <pikhq> Erm. dmwit.
13:49:58 <pikhq> artagnon: genericLenght
13:49:59 <RayNbow> artagnon: you could use genericLength
13:50:07 <dmwit> pikhq: eh?
13:50:14 <pikhq> dmwit: ... Thinko.
13:50:24 <pikhq> I should not discuss pragmas.
13:50:45 <dmwit> byorgey: From the MR page on haskellwiki, "f x = show x -- allowed; f = \x -> show x -- not allowed"
13:50:49 <Rotaerk> hmm what's the difference between the Array module, Data.Array, and GHC.Arr
13:51:04 <dmwit> (also @stanv)
13:51:06 <artagnon> > :t genericLength
13:51:07 <lambdabot>   <no location info>: parse error on input `:'
13:51:10 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8024#a8024
13:51:40 <RayNbow> artagnon: :t is a different lambdabot command than >
13:51:51 <RayNbow> :t genericLength -- look, no <
13:51:52 <lambdabot> forall b i. (Num i) => [b] -> i
13:51:55 <RayNbow> err
13:51:56 <RayNbow> * >
13:52:01 <RayNbow> not <
13:52:12 <artagnon> oh, ok
13:52:31 <artagnon> Ouch, my function went on overdrive and ran for several seconds before I killed it
13:52:39 <dmwit> Berengal: Ah, yes, that's interesting, too.
13:53:02 <dmwit> aaah yes
13:53:02 <artagnon> now, it looks like the GC didn't finish its job. My OS slowed down! :'(
13:53:55 <mornfall> Goodnight folks! (I guess I'm happy for today...)
13:55:02 <Saizan_> artagnon: you'll have to close ghci to make it release the memory to the os
13:55:13 <mornfall> Lemmih: (And thanks for the tips.)
13:57:20 <luite> any idea how to fix this one? ghc.exe: C:\Program Files (x86)\Haskell\regex-posix-0.94.1.1\ghc-6.10.4\HSregex-posix-0.94.1.o: unknown symbol `_regerror'
13:57:51 <RayNbow> luite: which compiler(s) did you use?
13:58:43 <luite> RayNbow: mingw, using the default gcc from the haskell platform, 2009.2.0.2, I've installed regex.h in c:\MingW\include, and the libraries in c:\MingW\lib. after that, regex-posix compiled without errors
13:59:17 <luite> I've also tried to specify regex in extra-libraries, and the dir in extra-lib-dirs
14:01:03 <byorgey> Berengal, dmwit: hmm, why are those not the same?  I'm not seeing it atm
14:04:48 <monochrom> Finally, HWN instalment!
14:05:45 <soupdragon> @where hwn
14:05:46 <lambdabot> http://sequence.complete.org/
14:07:36 <Berengal> byorgey: The example could've been better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8024#a8027
14:07:37 <stanv> pikhq: {#- UndecidableInstances -#}
14:07:49 <Berengal> crap, wrong button
14:08:04 <stanv> pikhq: what you mean ?
14:08:11 <Berengal> No, just crappy caching
14:08:34 <pikhq> stanv: Stuff. And stuff.
14:08:59 <Berengal> byorgey: The first definition of foo will do 'f x' for each element of the list, the second will only do it once
14:09:42 <byorgey> Berengal: oh, ok, I see.  I was thinking they gave different *results* and I was confused.  you're just saying they have different operational semantics.
14:10:01 <Berengal> byorgey: Yeah, that's what it amounts to
14:10:07 <byorgey> that doesn't seem like a very good reason to disallow different numbers of patterns in definition clauses.
14:10:38 <voker57> how to embed code into literate haskell (for LaTeX to display it as code block) but it shouldn't be run by ghc?
14:10:59 <voker57> \begin{code} is detected by ghc
14:11:05 <RayNbow> Berengal: 'f x' for each element in the list? really?
14:11:05 <byorgey> stanv: pikhq meant to address that to dmwit, I think.  I wouldn't worry about UndecidableInstances just yet if I were you =)
14:11:36 <Berengal> byorgey: Perhaps not... There are other reasons as well
14:11:43 <Berengal> RayNbow: Really!
14:11:55 <byorgey> Berengal: I believe it.  I just don't know what they are =)
14:12:07 <RayNbow> Berengal: but why?
14:12:57 <voker57> never mind, found out
14:12:57 <Berengal> byorgey: Strictness annotations? morphisms?
14:13:34 <Berengal> RayNbow: Imagine if z was hueg like xbox but cheap to calculate, and you hung on to the 'foo x' for a long time
14:14:16 <byorgey> Berengal: record syntax? functional dependencies?  ;)
14:15:15 <Berengal> byorgey: Lazy implementers? Backus said not to?
14:15:28 <RayNbow> Berengal: I was under the impression that if you assign a name to an expression (z = f x), that expression will be computed at most once?
14:16:30 <Berengal> RayNbow: In the context of the expression it closes around. After all, x isn't always the same (but in this case it is)
14:17:05 <stanv> I put: {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}, but result the same. quations for `foo' have different numbers of arguments
14:17:53 <BMeph> I've noticed, that one reason why people don't like Haskell is because many of the tests they'd normally write are already taken care of with types. Then they complain that when they rewrite their program, they have to change the types...
14:18:19 <byorgey> stanv: no language extensions are going to fix it, equations with different numbers of patterns are simply not allowed.
14:18:20 <Berengal> RayNbow: 'foo x' expands to (\y -> let z = f x in < + y). You wouldn't expect z to only be calculated once in total then, but once per function call
14:19:30 <soupdragon> stanv, what did you want to write?
14:20:19 <byorgey> stanv: I agree it can be a little annoying now and then, but in my experience, for the most part it's not a big deal, and you get used to it.
14:20:29 <RayNbow> Berengal: ah... wait... now I see
14:20:38 <stanv> soupdragon: nothing :) I just noticed this strange fact at my experiments :)
14:20:44 <soupdragon> okay
14:21:05 <RayNbow> the two are different in case of partial application
14:21:28 <RayNbow> Berengal++
14:21:34 <RayNbow> @karma Berengal
14:21:34 <lambdabot> Berengal has a karma of 3
14:21:40 <Berengal> \o/
14:29:24 <luite> RayNbow: I've also tried with the mingw32 library libgnurx, but I still get the unknown symbol `_regerror' error. I have set the include path and library path. I also noticedt that the 'Keep in sync with regex-posix.cabal' versionBranch is outdated, but that doesn't seem to be the problem
14:29:29 <Milo-> what is required from terminal, to allow 'backspaces' and 'deletes' from user input in haskell?
14:30:09 <luite> some user has posted the same problem on haskell-cafe, but no-one answered it: http://www.mail-archive.com/haskell-cafe@haskell.org/msg51787.html
14:30:31 <Milo-> mainly "var <- getLine" or "var <- readLn" and if I make a typo there, I should be able to backspace back, but I can't, instead I  get some garbage that usually won't be able to be parsed
14:32:16 <RayNbow> luite: it's a link error, right?
14:32:22 <luite> RayNbow: yes
14:34:24 <RayNbow> luite: good luck solving those :p
14:35:40 <luite> these are the last lines: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8028#a8028
14:35:42 <Berengal> Milo-: Setting buffering to line-buffering allows me to delete stuff from a line I'm writing (and C-d). With no buffering, all of those are received as input
14:36:13 <luite> (regex-posix-0.94.1.1 is my own patched version, with some changes in the .cabal file and a fixed version number in Posix.hs)
14:36:23 <Berengal> Milo-: Exactly what happens with line buffering on depends on the actual terminal/shell you're running on
14:37:04 <Milo-> thought so, need to figure out how to get that to work in konsole||bash
14:37:50 <Berengal> Milo-: You mean you're getting garbage input with line buffering in konsole?
14:37:57 <Milo-> yes indeed
14:38:28 <Berengal> Milo-: Have you tried in a non-x terminal?
14:38:42 * Berengal is right back, trying stuff in a non-x terminal
14:38:53 <Milo-> heh, nope, haven't.
14:39:29 <Berengal> Milo-: Works the same for me
14:39:46 <Milo-> nope, it didn't print the garbage, but they're there in the actual result
14:39:49 <Berengal> That is, deleting deletes characters
14:39:57 <Milo-> '\DEL\DEL\DEL\DEL'
14:40:03 <luite> is there a way to find it what _exact_ environment was used to build the haskell platform on mingw?
14:40:14 <luite> all libraries, all versions, etc?
14:44:36 <Berengal> Milo-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8029#a8029
14:45:30 <Milo-> lots of newlines there
14:45:42 <Berengal> Yeah, they somehow got added when I saved..
14:45:49 <Berengal> Just ignore every even line :P
14:45:52 <Milo-> windows \n
14:46:09 <Milo-> well, \r\n actually
14:47:04 <Milo-> Berengal thanks, that works :)
14:47:15 <Milo-> got to remember that
14:55:39 <moonpatrol> i like you guys
14:55:53 <Milo-> you like guys
14:56:03 <Twey> And we like you too.
14:56:33 <Milo-> aw, I have joined in a loving community
14:57:51 <dons> ?users
14:57:52 <lambdabot> Maximum users seen in #haskell: 658, currently: 575 (87.4%), active: 12 (2.1%)
14:58:01 <skorpan> i hate you
14:58:09 <Milo-> in C-community they're often rude and such :(
14:58:35 * medfly hugs skorpan 
14:58:52 * Berengal ghc skorpan
14:58:53 <sbahra> Who wants to be my wife?
14:59:07 <skorpan> the C community has too many know-it-alls, in haskell no one really knows anything... that's why we like eachother, we are all equally ignorant.
14:59:09 * benmachine giggles at Berengal 
14:59:33 <moonpatrol> the C community is like a truck driver who told me my college education is useless in the real world
14:59:35 <dons> its an open frontier we're exploring
15:00:08 * BMeph thinks Berengal meant GHCi
15:00:15 <medfly> moonpatrol, what kind of college education is it?
15:00:16 <Twey> There's no other kind worth exploring :)
15:00:23 <tommd> moonpatrol: Would you feel better hearing that from more than one source?
15:00:38 <moonpatrol> tommd: as long as its not a highschool drop out, yes.
15:00:48 <Milo-> skorpan that kind of sounds like php-community
15:01:01 <skorpan> Milo-: php is a mix... they're know-it-alls, but don't know shit.
15:01:06 <Milo-> though, in php-community everyone thinks they know it all
15:01:11 <Milo-> exactly
15:01:12 <Milo-> :P
15:01:14 <skorpan> :)
15:01:24 <moonpatrol> :-)
15:01:26 <tommd> moonpatrol: Ok then.  Your college education is worth less (space intentional) in the real world.
15:01:27 <soupdragon> when you say "C community" you mean ##C
15:01:34 <medfly> haha. I have a PHP assignment so I hang out at ##php, but I didn't get to see any nasty attitudes yet.
15:01:53 <Milo-> when I say C community, I mean C-people in all kinds of C-channels
15:02:06 <medfly> (I have to justify being there. :))
15:02:42 <medfly> moonpatrol, it really depends what kind of college education.
15:02:44 * benmachine is kind of a C people
15:02:56 <Milo-> I'm a C-person
15:03:10 <medfly> is it okay to chat a lot here, or are we all just ignoring the rules?
15:03:22 <moonpatrol> hey, my free love started it all.
15:03:29 <tommd> medfly: If there is actual Haskell talk then chat in #haskell-blah
15:03:45 <medfly> OK.
15:03:46 <skorpan> when discussing a statically typed language, you have to break some rules sometimes to not go crazy
15:04:03 <ksf> the haskell community is split into two parts: those that think they might, one day, understand haskell, and those who read at least one paper by oleg.
15:04:06 <tommd> Some types were ment to be polymorphic.
15:04:08 <dons> ah, much learning ahead, my young skorpan
15:04:11 <Milo-> I'm just reading rwh's chapter about types.
15:04:29 <moonpatrol> rwh?
15:04:31 <medfly> I don't get why Haskell is seen as so hard.
15:04:34 <tommd> @where rwh
15:04:35 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
15:04:39 <dons> good point, medfly
15:04:42 <medfly> isn't it just a language? *protects body*
15:04:48 <Milo-> medfly :c
15:04:52 <moonpatrol> ahh, i've been doing the craft of functional programming
15:04:59 <Milo-> it's nothing `like` C
15:05:05 <ksf> medfly, did you ever read one of olegs papers?
15:05:07 <Milo-> that's the problem :P
15:05:13 <medfly> but... it's sort of my first language :-p
15:05:15 <Twey> ksf: Hahaha.
15:05:17 <Milo-> but then again, neither is ASM :)
15:05:26 <Twey> medfly++
15:05:32 <medfly> Twey likes me :)
15:05:35 <tommd> medfly: Having talked with a couple people who learned Haskell as their first language, I don't think its any harder than C - but if you come from a C world there are obvious reasons it is harder than, say, python or Java.
15:05:55 <Twey> ‘Different’ should not be confused with ‘hard’, I feel
15:05:59 <soupdragon> haskell is hard because it uses = and oh god I am not good at math help
15:06:09 <Milo-> I know C, C++ and Java, and of course bash, perl and php..
15:06:10 <Twey> Haha
15:06:19 <Twey> Milo-: Oh dear
15:06:23 <medfly> I like Haskell.
15:06:24 <skorpan> tommd: i was pretty much taught haskell as my first language, but i still think it's pretty hard... i mean, i can *do* stuff in it, but the code is nearly always lacking the elegance i think i see in "pro haskell code"
15:06:33 * medfly preaches to the choir.
15:06:38 <Milo-> but they are all relatively similiar to C. so it's easy
15:06:41 <Twey> medfly: :-D
15:06:54 <Milo-> oh and I also know tcl/tk
15:06:56 <Twey> Nobody sensible doesn't!  :-P
15:06:57 <ksf> haskell is hard because it calls ';' '>>'
15:06:58 <tommd> skorpan: Damn, your single counter example completely destroys my generalization! ;-)
15:06:58 <Milo-> but those are lame
15:07:08 <Twey> ksf: Lies!
15:07:23 <Milo-> Twey "oh dear" ? :(
15:07:24 <skorpan> tommd: i'm not trying to tell you otherwise, i'm merely making conversation :P
15:07:27 <Twey> ksf: Haskell calls a semicolon a semicolon :-P
15:07:27 <BMeph> ksf: Did you mean 'those who have read at least one paper", or "those who read at least one paper per month"? ;)
15:07:37 <medfly> tommd, he didn't say "in comparison" :)
15:07:44 <ksf> ...at least one paper.
15:07:51 <Twey> Milo-: Yes, I was being sympathetic :-P
15:08:00 <tommd> I know, so I had to poke fun.  If you could see my facial expression without turning to stone then you would have laughed.
15:08:06 <Milo-> to which part? :C
15:08:08 <dons> its interesting. maybe the language is sufficiently rich that there is a real curve between beginner and advanced haskell. all those idioms and intuitions.
15:08:20 <ski> tommd : you're a gorgon ?
15:08:24 <Milo-> having 'strong' C-like background or knowing something as bad as perl?
15:08:26 <Twey> Milo-: To your language selection!
15:08:30 <ksf> the creepiest thing is the ease that sloshes out of them.
15:08:31 <Milo-> hah :P
15:08:48 <Twey> Even amongst C-likes, you've picked a bad bunch :-P
15:08:51 <medfly> I didn't really read a whole lot of Haskell yet, fancy or not
15:09:13 <BMeph> Personally, I dislike the tendency for languages to have such similar syntax; it makes identifying the different semantics tougher.
15:09:17 <Twey> medfly: http://okmij.org/ftp/Haskell/
15:09:32 <moonpatrol> perl is like cartoon characters cursing
15:09:39 <Milo-> I like writing simple scripts to make my daily tasks easier, which is why bash and perl have been good fun, but then again, I like doing something real, which is where C and java kicks in
15:09:45 <Twey> moonpatrol: Hehe
15:09:50 <tommd> dons: Do you know if anyone got around to benchmarking the various containers as you previously suggested?
15:09:56 * ksf recommends http://homepages.cwi.nl/~ralf/OOHaskell/ as oleg primer.
15:10:01 <dons> we had some numbers, tommd
15:10:01 <medfly> what is that, Twey?
15:10:01 <shapr> Milo-: I like writing code that works, that's where Haskell kicks in.
15:10:07 <dons> check on libraries@
15:10:09 <Milo-> :D
15:10:11 <dons> bytestring-trie did pretty good
15:10:11 <tommd> ok
15:10:15 <Berengal> I used to think there were lots of different languages. After learning haskell I've started to think there's actually just two; haskell and not haskell (the latter having many different superficial syntaxes to choose from)
15:10:19 <Milo-> shapr code that work is so over-rated
15:10:27 <shapr> Yeah, that's what my manager keeps saying.
15:10:30 <medfly> haha.
15:10:40 <Milo-> it must be over-rated, why else would microsoft lead the operating system business?
15:10:41 <Twey> I like writing code that doesn't take a hundred lines to sort a list.  That's where Haskell kicks in.
15:10:43 <shapr> He's like "You're going down a rathole, we just want something that gives business value to the customer."
15:10:56 <Berengal> Twey: Java only requires about ten
15:11:03 <shapr> Which translates in my head to "just write something that vaguely works, if it has bugs, the customers will tell us about them."
15:11:18 * BMeph is currently reading the "Functional Pearl: Implicit Configurations" paper
15:11:26 <dons> shapr: yeah, haskell isn't the business. features, reliability etc is.
15:11:33 <Berengal> shapr: That is a problem. How do you put bugs in a haskell program?
15:11:36 <Twey> Berengal: I don't know; I tend to class Lisp, Forth, and possibly Lua apart from the others
15:11:46 <shapr> Berengal: I don't know.
15:11:51 <Twey> Hahaha.
15:11:53 <Milo-> Twey hm, my multipurpose quicksort was about 50 lines in C
15:11:54 <ksf> shapr, what use are well-designed, easily maintainable programs if you don't have to maintein them because they're so well-designed?
15:11:55 <medfly> Berengal, bugs can be GUI things, too :)
15:12:01 <ksf> it's all empty and meaningless.
15:12:12 <Milo-> Haskell kind of dropped that to 3 lines :(
15:12:32 <Milo-> multipurpose quicksort in 3 lines. annoyingly cool
15:12:36 <shapr> ksf: I actually asked someone about this recently. My hypothetical question was "What if Windows libraries didn't really have bugs?" They said "80% of the IT industry would be out of a job."
15:12:41 <ksf> ...that quicksort example is slow.
15:12:52 <Twey> Milo-: Two lines.
15:12:52 <Milo-> and readability was way better than doing the same in C
15:12:53 <ksf> quicksort needs a mutable data structure.
15:12:55 <Twey> Excluding type signature.
15:13:00 <soupdragon> out of a job --> into a new one
15:13:02 <ksf> there's a cool mergesort around though.
15:13:12 <BMeph> Microsoft excels at producing code for people who use computers, but aren't very interested in them.
15:13:17 <medfly> I don't know shapr. idiots can create bugs where there aren't. (I've been reading customer support quotes for a while)
15:13:19 <mike-burns> Sort is a poor example because very few people actually need to implement a sorting algorithm in any language.
15:13:24 <shapr> soupdragon: That's what I said.. these people without jobs could then spend their time actually CREATING something instead of munging interfaces as they do now.
15:13:26 <Berengal> Twey: I'm not entirely there yet, but except erlang every language I've started learning since haskell very quickly feels like blub
15:13:28 <ski> Twey : and Prolog ..
15:13:30 <soupdragon> yes
15:13:43 <Twey> And Prolog, aye
15:13:49 <Berengal> Perhaps I should include prolog as well...
15:13:49 <Milo-> Twey I had "quickSort _ [] and quickSort _ [x] + the actual one
15:14:04 <Twey> Berengal: Have you tried a Lisp?
15:14:05 <medfly> haha.
15:14:06 <Milo-> and I forgot to close my string literal.
15:14:26 <Berengal> Twey: Yes, I tried CL a few months back
15:14:38 <ksf> lisp has become quite boring since I know haskell, were it not for macros.
15:14:46 <Twey> You don't think the macro metaprogramming is relatively unique?
15:14:53 <Twey> Yeah, Lisp is all about the macros.
15:14:59 <soupdragon> and sexps
15:15:02 <shapr> I think I'm still not convinced that Windows has an advantage past "people being used to the interface."
15:15:14 <Twey> shapr: I concur
15:15:22 <Berengal> Macros are nifty, I must admitt, but TH is also nifty
15:15:29 <Twey> And the wide range of applications available for it
15:15:31 <ksf> ...but I think TH could rock, too, iff it were designed by someone who isn't a masochist.
15:15:33 <dons> i'd like people to complete more useful and popular apps in haskell too. too much stuff in the top apps list is by < 5 people
15:15:36 <shapr> Twey: But then, I've been programming for 25+ years, so I may not be qualified to judge.
15:15:37 <Twey> Berengal: Yeah, but TH is relatively ugly
15:15:45 <Twey> (due to the complexity of Haskell syntax)
15:15:50 <medfly> :)
15:15:53 <Berengal> Twey: Needs more qqs!
15:15:58 <shapr> dons: Is there a good gtk2hs tutorial that works with the latest version?
15:16:00 <Twey> shapr: My mother seems to get on well enough with GNOME
15:16:06 <Twey> She's not tech-savvy at all
15:16:20 <Twey> And she does like at least some of the extra features
15:16:23 <shapr> Twey: Yeah, my brother was perfectly happy with Ubuntu until his college class required MSIE for some online homework.
15:16:33 <Twey> Yeah.
15:16:38 <shapr> And my brother was totally anti-tech at the time.
15:16:41 <medfly> I've tried to educate my grandma to use the computer, I somehow think that would have worked out better with Ubuntu because I could get it to do a lot of things automatically for them.
15:16:45 <Twey> *nod*
15:16:46 <soupdragon> well when you need to use MS .. you can just like do it in the 'labs'
15:16:48 <mike-burns> dons: I'm working on completing apps! I swear!
15:16:53 <mike-burns> Give me time ...
15:16:58 <luite> shapr: your brother probably didn't like full-screen flash video's ;)
15:16:58 <BMeph> "Is there a good gtk2hs tutorial"? ;)
15:17:03 <dibblego> shapr, when I set up Windows addicts with Ubuntu I always give them a fresh Windows XP vmware
15:17:13 <medfly> shapr, I had that problem too. I got ies4linux.
15:17:18 <shapr> luite: True, my brother just wanted to complete his degree.
15:17:25 <Twey> My mother has one of those because she's taking a course in MS Office
15:17:39 <moonpatrol> AH TONY MORRIS
15:17:42 <shapr> medfly: Yeah, I thought about that, but I didn't really have time to fix it for him. And part of the experiment was to see whether a fresh install of Ubuntu would "just work".
15:18:09 <shapr> The funniest result of the experiment was that my brother would keep forgetting his password, so he'd just reinstall Ubuntu.
15:18:16 <medfly> haha.
15:18:19 <dibblego> moonpatrol?
15:18:27 <luite> I recently switched from ubuntu 9.04 to windows 7... my main problem is getting haskell to work properly
15:18:28 <moonpatrol> hidyho
15:18:41 * Berengal considers switching back to arch
15:18:51 <shapr> luite: I totally agree. I installed Haskell goodies on my work laptop, and lots of stuff is flakey.
15:19:15 <shapr> test-framework has problems with the test runner, something to do with the console bindings.
15:19:34 <luite> shapr: I actually switched to linux because of this mess
15:19:51 <luite> but linux has other problems
15:19:57 <luite> at least, for me :p
15:20:02 <medfly> what problems, luite
15:20:09 <luite> missing (adobe) programs mainly
15:20:15 <medfly> hehe
15:20:36 <medfly> I wonder how hard it is to emulate a mac program :)
15:21:14 <osfameron> *cough* power management *cough*
15:21:45 <mike-burns> The biggest issue with any OS is that it doesn't run programs for another OS.
15:21:50 * osfameron is seriously considering getting an MBP and then running a usable OS in a virtualbox on it, just for the power management
15:21:57 <Berengal> Hehe, 'In the language of the "Algol 68 Report", Input/output facilities were collectively called the "Transput".'
15:22:37 <Twey> Berengal: Nice :-P
15:23:10 <Berengal> It logically makes much sense, but it still sounds funny
15:23:43 * BMeph always wondered why it wasn't "input" and "outget"...
15:24:10 <Twey> I'd've thought it would be the other way around
15:24:13 <Twey> Inget and output
15:24:15 <Berengal> How does "outget" make sense?
15:25:22 <stianhj> put something in, get something out
15:26:04 <Berengal> Almost like INTERCAL's WRITE IN and READ OUT...
15:28:24 <ski> osfameron : "MBP" ?
15:28:41 <mike-burns> MacBook Pro.
15:34:14 <ksf> does someone feel like writing "The Agda road to Logic"?
15:36:03 <brian6> is there a cabal dev around who can weigh in on the wxhaskell-users list about a cabal installation issue?
15:38:52 <soupdragon> ksf, yes
15:39:03 <soupdragon> why arent you in the agda channel
15:39:04 <ksf> cool, 'cos I feel like reading it.
15:39:37 <soupdragon> nobody talks about agda in agda it is getting me down
15:42:26 <dufflebunk> What does agda stand for? Active Guppies for Declaritive Action?
15:43:11 <dufflebunk> Alternative Green Diagnostic Achievements
15:43:57 <dufflebunk> Advanced Generic Data Arrows
15:44:08 <brian6> i use it because i got sick of the regular achievements.
15:44:41 <dufflebunk> Abstract Generic Data Algebras? oo, that one might actually be right
15:44:59 <erikc> how do you do non-terminating programs in agda
15:45:27 <ksf> ...you pass a compiler flag to bribe the typechecker.
15:45:32 <dmwit> > ':':':':':':':':':':':':":"
15:45:33 <lambdabot>   ":::::::"
15:45:34 <erikc> heh
15:45:37 <ksf> or, of course, use corecursion.
15:45:57 <soupdragon> ????
15:46:16 <ksf> ...that is, work on potentially infinite data.
15:46:27 <Badger> dufflebunk: take your hands off of my algebras!
15:46:27 <dmwit> Potentially?
15:46:31 <ksf> like, for example, stdin.
15:46:37 <erikc> ah
15:46:42 <dmwit> I thought codata was guaranteed infinite.
15:46:45 <soupdragon> no
15:46:50 <dmwit> No, of course not.
15:46:53 <dmwit> Why did I think that?
15:47:13 <soupdragon> stream a = a : stream  is infinite
15:47:16 <dmwit> I guess the standard example of codata is Stream.
15:47:16 <ksf> nothing's infinite, unless you happen to be a formalist.
15:47:17 <dmwit> yeah
15:49:02 <seanmcl> Hi.  Say I generally want to use a ghc warning, -fwarn-missing-signatures for example, but in a particular file I don't.  The documentation seems to suggest that you can write {-# OPTIONS_GHC -fno-warn-missing-signatures #-} at the top of the file and it will turn that option off.  This doesn't work for me.  Am I doing something wrong?  Thanks!
15:49:02 <seanmcl>  
15:49:53 <dmwit> Sounds right; are you sure there's no typo in the option?
15:49:59 <ksf> my quick guess is that pragmas are "inserted into the command line" before the actual command line.
15:50:22 <ksf> that is, ghc sees "-f-no-warn-missing-signatures -Wall" or something.
15:50:28 <seanmcl> so I should be able to write ghc --make -fwarn-missing-signatures, and use that pragma in a file to turn it off for that particular file?
15:51:11 <dmwit> If you can't, it certainly seems like a reasonable feature request. =)
15:51:18 <dmwit> What version of GHC are you on, just out of curiosity?
15:51:29 <seanmcl> 6.10.4
15:51:34 <ksf> does cabal do per-file options?
15:52:48 <dufflebunk> ksf: Usually you can just add the {# } directives to files if you want that
15:52:53 <brian6> seanmcl: {-# OPTIONS_GHC -fno-warn-missing-signatures #-} is working for me here.
15:53:38 <seanmcl> hi brian6.  Could you send me your commandline call?
15:54:36 <brian6> seanmcl: i tested by putting function f = "x" in test.hs and doing ghci -Wall test.hs. i got the warning. after adding the pragma, it didn't warn anymore.
15:54:40 <brian6> j
15:54:44 <brian6> sorry @ j.
15:57:35 <randomwords> I think parListChunk (and therefore parList) in Control.Parallel.Strategies are causing space leaks in my code. Has anyone else had this happen?
15:58:12 <seanmcl> brian6: would you try it with a literate haskell file?
15:58:27 <brian6> seanmcl: ok, sec.
15:58:33 <seanmcl> Mine works with basic haskell (.hs) but not with (.lhs)
15:58:44 <dmwit> seanmcl: do you have "> {-# ... #-}", note the birdtracks?
15:58:52 <seanmcl> aaaahhhhh
15:59:02 <dmwit> dunno if that's right or even legal
15:59:07 <dmwit> But it's something to try. =)
16:00:03 <brian6> seanmcl: yeah, that's the issue.
16:00:10 <brian6> seanmcl: just need >
16:00:22 <seanmcl> great, thanks a lot!
16:00:26 <brian6> np.
16:05:36 <sjanssen> randomwords: par and strategies are well known to be space leak prone
16:09:02 <medfly> I have spotted a challenge somewhere, and it is asking me to do stuff without using pattern matching. this may suggest I am incapable of solving the challenge, but what is pattern matching, what _can_ I use?
16:09:09 <medfly> :D
16:09:26 <Badger> @src words
16:09:27 <lambdabot> words s = case dropWhile isSpace s of
16:09:27 <lambdabot>     "" -> []
16:09:27 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:09:34 <Badger> er
16:09:44 <Badger> no that's case
16:09:50 <Badger> which one has...
16:09:54 <mike-burns> @src foldr
16:09:54 <lambdabot> foldr f z []     = z
16:09:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:10:05 <Badger> ahha
16:10:54 <soupdragon> medfly, the only data you can use without pattern matching (or using functions defined by pattern matching) is (->)
16:11:09 <medfly> !
16:11:13 <randomwords> sjanssen: It seems that way. It's quite a massive leak though: I have a function (say f) which computes a list is parallel (using strategies), but if I do for example (putStrln (f 1); putStrln (f 2); ...) it appears none of the lists are free'd even though they are not referred to again.
16:11:43 <soupdragon> on the other hand you can do everything with untyped (->), with types you can't build recursive data
16:12:22 <dmwit> medfly: Probably the challenge is referring to using Prelude functions instead, which do the pattern matching for you.
16:12:41 <dmwit> Or whatever library you like, I guess.
16:12:48 <ray> pointlessness
16:13:06 <sjanssen> soupdragon: well, Haskell has various tools to help us cheat
16:13:22 <dmwit> medfly: Pattern matching is any clause on the left-hand side of an =, <-, or -> that has a constructor in it.
16:13:40 <dmwit> medfly: Constructors are functions that start with an upper-case letter or a ':'. =)
16:13:42 <sjanssen> eg. newtype Fix f = Fix {unfix :: f (Fix f)}
16:13:55 <luite> if I use a binary haskell distribution (haskell-platform), and I need an extra C library, should I put the .h in c:\mingw\include or c:\progra~1\haskell-platform\2009.2.0.2\include ? (cabal seems to accept both by default)
16:14:28 * medfly tries to make sense out of this.
16:14:29 <medfly> thanks!
16:14:42 <ray> luite: probably the first
16:15:10 <luite> ray: even if the mingw compiler may be a different version than the gcc shipped with haskell platform?
16:15:54 <ray> well, i'm assuming that you might want it to work with mingw too
16:16:20 <soupdragon> why is -> special, and couldn't be defined as all the other data is?
16:16:22 <luite> possibly, but only if it doesn't conflict with haskell
16:16:44 <ray> if you want different versions and stuff installed, it's different
16:16:51 <soupdragon> \ as the constructor, ($) as pattern match
16:17:12 <luite> I haven't compiled haskell-platform myself and I probably can't replicate the build environment exactly
16:19:14 <dmwit> soupdragon: Consider a value of type (a -> Maybe a).
16:19:32 <dmwit> soupdragon: It's undecidable whether that function should match the pattern (\x -> Just x).
16:19:40 <dmwit> or even
16:19:51 <dmwit> (\x -> Just _), to avoid the double-name problem there
16:20:05 <opqdonut> unless a is tractable?
16:20:24 <dmwit> There was an implicit "in general" after the word undecidable, yes.
16:20:28 <opqdonut> :)
16:21:04 <dmwit> ...no
16:21:16 <dmwit> I meant exactly the type I said.
16:21:21 <soupdragon> how does that relate to what I said?
16:21:33 <dmwit> soupdragon: You asked why functions couldn't have \ as a constructor.
16:21:36 <dmwit> I'm telling you why.
16:21:54 <soupdragon> \ does construct a function
16:22:17 <dmwit> opqdonut: Consider the function (\x -> if functionPHalts then Just x else Nothing), which has exactly the type I said.
16:22:24 <soupdragon> undecidable doesn't matter anyway
16:22:44 <soupdragon> if you have  case haltingProblem of True -> .. ; False -> ...   the computer tries anyway
16:22:46 <dmwit> soupdragon: Constructors don't just construct; they also have to participate in pattern matches.
16:23:49 <dmwit> soupdragon: ...what I'm trying to say is that for the pattern (\x -> Just _), it's not just undecidable whether it matches, you simply *can't know* whether it matches until you know x.
16:24:24 <soupdragon> I don't understand what you mean here
16:24:42 <opqdonut> dmwit: well, we can just make pattern-matching on a non-total function diverge
16:25:02 <opqdonut> dmwit: i mean, when a is tractable the pattern match is _computable_
16:25:08 <opqdonut> but it might not halt
16:25:09 <soupdragon> here is an example of pattern matching on a function:
16:25:14 <dmwit> opqdonut: I don't think so.
16:25:18 <soupdragon> (\x -> x + 1) $ 3 ~~> 4
16:25:30 <dmwit> soupdragon: That is not an example of pattern matching, no.
16:25:34 <soupdragon> yes it is
16:25:39 <dmwit> !
16:25:46 <dmwit> What do you mean by pattern matching, then?
16:26:31 <dmwit> When I say pattern matching, I mean something that desugars to a "case" with multiple non-overlapping branches.
16:26:40 <opqdonut> dmwit: let's assume a is finite. if f::a->Maybe a is total, we merely need to calculate f x for all x::a, which is doable. otherwise we start calculating f x for all x::a anyway, but the computation diverges
16:26:49 <dmwit> Actually, I don't require multiple, but it can't be a simple variable match. =)
16:27:03 <soupdragon> you can construct a number by going n = S (S (S O)) and deconstuct it by taking case n of S _ -> .. ; _ -> ..,  same with functions, you construct it using f = \x -> x + 1 and deconstruct with case f $ 3 of 4 -> ...
16:27:08 <dmwit> opqdonut: Right.  And what do we do when some inputs give Nothing and some give Just?
16:27:14 <dmwit> opqdonut: Does (\x -> Just _) match?
16:27:25 <opqdonut> dmwit: of course not
16:27:47 <opqdonut> just as (Just x,Just y) doesn't match (Just 1,Nothing)
16:27:54 <soupdragon> actually 'case' is just confusing,  a better example is   maybe 3 id Nothing   and   ($) f x
16:28:06 <soupdragon> ($) is the catamorph for ->, just as maybe is for Maybe
16:28:06 <opqdonut> (and as it happens, (Maybe a,Maybe a)~Bool->Maybe a
16:28:06 <dmwit> But the only two patterns available are (\x -> Just _) and (\x -> Nothing), so no pattern matches that function!
16:28:07 <opqdonut> )
16:28:09 <dmwit> That's bad.
16:28:17 <soupdragon> that is the relation with pattern matching
16:28:32 <opqdonut> dmwit: sure
16:28:52 <opqdonut> what i'm saying is just that it is possible to give sensible semantics
16:29:06 <dmwit> That's not sensible!
16:29:19 <dmwit> Values with no matching pattern are not sensible.
16:29:51 <dmwit> The alternative is to let \ be the only constructor, so the only pattern you can match is (\x -> _), which seems kind of pointless.
16:29:57 <dmwit> You know by its type that it will match that.
16:30:00 <soupdragon> dmwit
16:30:07 <soupdragon> I have explained my self
16:30:16 <soupdragon> did you see what I meant now
16:30:22 <dmwit> Right, you backed down from pattern matching. =)
16:30:46 <dmwit> At which point I'm fine with your suggestion, and we can (and do) already do it... =)
16:41:36 <astrobunny> hmm
16:41:46 <astrobunny> i saw an internet meme that reminded me of fmap
16:42:33 <ray> functorcat iz liftin ur functions
16:42:41 <astrobunny> yeah
16:43:09 <astrobunny> yo dawg i heard you like lolis so i put a loli in your loli so you can lick a loli while you lick your loli
16:43:42 <astrobunny> lick :: loli -> lickedloli
16:43:54 <astrobunny> to
16:43:56 <soupdragon> why don't you say odd things somewhere else
16:44:01 <astrobunny> lol
16:44:06 <astrobunny> sorry
16:44:07 <astrobunny> i had to
16:44:10 <astrobunny> it made me laugh
16:45:26 <Lemmih> Hot comonads and bifunctors. fmap fmap fmap.
16:45:59 * Lemmih will go back in the corner.
16:47:08 * sciolizer wonders what the conditions on a are for (a a a) to be well typed
16:47:56 <ray> :t id id id
16:47:58 <lambdabot> forall a. a -> a
16:48:27 <sciolizer> mix mix mix
16:48:31 <lpsmith> :t id id id
16:48:32 <lambdabot> forall a. a -> a
16:48:39 <ray> sciolizer: just to be able to be applied twice to something polymorphic enough to be itself
16:48:43 <ray> :t fmap fmap fmap
16:48:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:49:01 <twanvl> :t const const const
16:49:02 <lambdabot> forall a b. a -> b -> a
16:49:47 <ray> fmap's first argument is an (a -> b), that can be any function at all
16:49:47 <twanvl> :t flip flip flip
16:49:49 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
16:49:52 <ray> id takes an a which can be anything at all
16:51:54 <sciolizer> :t ($) $ ($)
16:51:55 <lambdabot> forall a b. (a -> b) -> a -> b
16:52:38 <dmwit> The constraint (according to my hand-unification) is exists A, B, C. a :: A -> B && a :: C -> A && a :: C
16:53:45 <twanvl> (id id) = id,  (const const const) = const,  not sure what identities you can get for fmap/(.) or flip
16:54:11 <sciolizer> :t (\a -> a a a)
16:54:12 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
16:54:12 <lambdabot>     Probable cause: `a' is applied to too many arguments
16:54:12 <lambdabot>     In the expression: a a a
16:55:32 <dmwit> :t let a = undefined in ?a ?a ?a
16:55:33 <lambdabot> on the commandline:
16:55:33 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
16:55:34 <lambdabot> Top level:
16:55:39 <moonpatrol> whats the \a thing mean?
16:55:44 <dmwit> moonpatrol: lambda
16:55:50 <moonpatrol> ooooooooo i see thanks
16:55:52 <dmwit> moonpatrol: It's an anonymous function, with "a" as an argument.
16:55:59 <burp> @let owl = ((.)$(.))
16:55:59 <lambdabot>   Parse error
16:56:22 <dmwit> usually owl = (.).(.)
16:57:07 <dmwit> It's odd that that should be a parse, error, though.
16:57:24 <ray> parse, error
16:57:31 <dmwit> :t (.)$(.)
16:57:32 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
16:58:18 <dmwit> > let owl = ((.)$(.)) in owl (+) 3 read "4"
16:58:19 <lambdabot>   7
16:58:31 <dmwit> Yeah, it shouldn't be a parse error.  I don't get it.
16:59:11 <dmwit> :t flip ap
16:59:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
16:59:22 <dmwit> no...
16:59:24 <dmwit> :t flip . ap
16:59:25 <lambdabot> forall b c a. (b -> a -> c) -> b -> (b -> a) -> c
17:01:02 <Alpounet> where can we see Haskell GSoC progress ?
17:03:21 <sciolizer> @google Haskell weekly news
17:03:22 <lambdabot> http://sequence.complete.org/hwn
17:03:22 <lambdabot> Title: Haskell Weekly News | The Haskell Sequence
17:04:03 <Alpounet> oh, okay :)
17:04:17 <Alpounet> I was more thinking of a dedicated page
17:04:57 <sciolizer> hmm. I only see updates for 2008. ;)
17:05:13 <kniu> does haskell have a gensym in the IO monad?
17:05:34 <sciolizer> Alpounet: http://hackage.haskell.org/trac/summer-of-code/wiki/progress2008
17:08:30 <Alpounet> yeah, 2008 :/
17:08:57 <dmwit> kniu: no
17:09:09 <dmwit> kniu: But we have a Supply comonad. =)
17:09:21 <kniu> aw, dang.
17:09:38 <twanvl> if you just want unique values, there is Data.Unique
17:09:50 <dmwit> kniu: It should be pretty easy to roll your own with IORef.
17:10:01 <Saizan_> there's a newName in the Q monad
17:10:04 <dmwit> source = newIORef 0
17:10:07 <opqdonut> Unique is cool
17:10:38 <dmwit> genSym source = readIORef source <* modifyIORef succ source
17:10:40 <kniu> hm.
17:10:56 <kniu> I might have to resort to unsafePerformIO
17:11:11 <dmwit> !
17:11:19 <dmwit> Didn't you say you wanted it in the IO monad anyway?
17:11:46 <kniu> here, lemme explain my problem.
17:11:47 <opqdonut> but w/o unsafePerformIO he has to manually pass the ioref (or equivalent) around
17:11:59 <opqdonut> the classic global state problem
17:12:06 <kniu> Because I think there must be a sane way to do this, but I really can't think of one.
17:12:47 <kniu> I'm passing an environment around, with type [(String, Value)].
17:12:56 <kniu> seemed good enough to me.
17:13:25 <kniu> But the thing is, some values have to be guaranteed unique.
17:13:44 <kniu> Even if the environment changes so that they are no longer reachable by their name.
17:14:23 <Berengal> What constitutes a unique value?
17:15:08 <Berengal> Without context, it doesn't make much sense in haskell
17:16:38 <ray> did somebody say supply comonad?!
17:17:26 <soupdragon> supply comonad uses unsafePerformIO
17:17:45 <twanvl> kniu: depending on what you need, you could try the uniqueid package, which gives you a supply that can be split
17:17:58 <soupdragon> I don't know what is wrong with making a Gensym based on State
17:18:05 <kniu> doesn't matter what the unique value is.
17:18:10 <kniu> an integer, a string,
17:18:17 <kniu> I just need something to use as a tag.
17:18:29 <kniu> thing is, I can't just do it based on State.
17:18:34 <soupdragon> why?
17:18:43 <dobblego> kniu, do you have a function :: [(String, Value)] -> (t, [(String, Value)]) ?
17:18:57 <kniu> you know how environments are like trees?
17:19:10 <soupdragon> no I don't
17:19:37 <kniu> inside a function, the environment is local.
17:19:48 <byorgey> @seen jeffersonheard
17:19:48 <lambdabot> jeffersonheard is in #haskell. I don't know when jeffersonheard last spoke.
17:19:51 <kniu> you can find names in it or in the bigger enclosing environment.
17:19:59 <byorgey> has anyone had success getting Hieroglyph to build?
17:20:06 <dmwit> :t local
17:20:07 <kniu> But say I create a unique value inside a function, and then return in.
17:20:08 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
17:20:09 <kniu> *it.
17:20:31 <kniu> the State monad OUTSIDE that function does not hold a record of the creation,
17:20:51 <soupdragon> why not
17:20:55 <kniu> so when I do another creation after, it is not guaranteed to NOT be the same as the one created inside that function previous.
17:21:02 <soupdragon> you couldn't just make it happen?
17:21:26 <kniu> "make it happen"?
17:21:39 <soupdragon> using monadic programming
17:22:44 <kpreid> kniu: http://www.haskell.org/haskellwiki/New_monads/MonadSupply
17:22:55 <kpreid> I think this is just the thing for you
17:23:40 <ray> i really think supply is more comonadic than monadic
17:23:50 <soupdragon> ray I don't
17:23:55 <soupdragon> why do you think that
17:24:29 <ray> you have a supply, and you can get values out of it
17:24:46 <soupdragon> oh, S a -> a
17:25:13 <ray> yeah
17:25:18 <soupdragon> and splitting up the generator into parts,  S a -> S (S a)
17:25:36 <ray> right
17:27:13 <soupdragon> okay
17:27:56 <soupdragon> with monadic then extract has an effect and splitting is implicit
17:28:31 <soupdragon> or maybe splitting is not
17:30:29 <ray> i don't quite get that monadic supply, but it seems based on StateT, so i think splitting would be implicit
17:31:05 <opqdonut> monadic supply can guarantee global uniqueness but comonadic can't?
17:31:15 <Saizan_> the monadic supply is almost like parsers
17:31:33 <soupdragon> comonadic can too
17:31:34 <opqdonut> i mean because newSupply :: a -> (a -> a) -> IO (Supply a), one can't really split a Supply into two nonoverlapping ones
17:31:47 <opqdonut> or hmm, even and odd?
17:32:34 <twanvl> if the type only provides Eq, then using unsafePerformIO tricks is also safe
17:34:05 <soupdragon> twanvl, do you have a proof of that just wondering
17:35:20 <twanvl> that is what the uniqueid package does
17:36:27 <byorgey> @remember DanWeston Bottom has only one value, not two.  Otherwise bottom would have been called buttocks.
17:36:27 <lambdabot> Nice!
17:36:33 <soupdragon> yeah I've seen the code and seen it in JFP too
17:36:38 <soupdragon> not proofs thougth
17:36:49 <soupdragon> I am not sure what assumptions are made
17:36:49 <kniu> @src runState
17:36:49 <lambdabot> Source not found. :(
17:37:11 <soupdragon> in JFP they didn't use unsafe.. they did inline assembly :p
17:37:25 <kniu> lemme get something straight
17:38:07 <kniu> State describes computations as "s -> (s, a)", right?
17:38:43 <sciolizer> yes
17:38:45 <sciolizer> :t runState
17:38:46 <lambdabot> forall s a. State s a -> s -> (a, s)
17:39:12 <kniu> It seems that I was thinking about it wrong.
17:42:34 <hackagebot> cabal-query 0.1 - Helpers for quering .cabal files or hackageDB's 00-index.tar (MaxDesyatov)
18:12:43 <kniu> I just got another crazy idea.
18:13:48 <kniu> You know how functions like (\x : T. e : U) have type (Pi x : T. U)?
18:14:03 <kniu> Those two things look extremely alike.
18:14:31 <kniu> Also, note that type-level functions are "types", but are inhabited by no values.
18:14:46 <kniu> WHAT IF
18:15:12 <kniu> the type of an abstraction is itself an abstraction?
18:15:28 <kniu> Surely that would create problems, right?
18:15:51 <Saizan_> i've often wondered the same
18:15:57 <Saizan_> but i guess so
18:16:06 <kniu> Can you type theorists think of one?
18:16:28 <Saizan_> a simple one is that you'd need something like kind polymorphism
18:16:55 <Saizan_> since a typelevel abstraction will have a function kind
18:17:00 <kniu> kind polymorphism, is that like normal polymorphism, but at the level of kinds?
18:17:11 <Saizan_> yes
18:17:19 <kniu> because that's taken care of if we're talking about a pure type system.
18:18:16 <Saizan_> so, if you have value of types with function kinds, then Pi must admit such types for the result of functions
18:18:34 <Saizan_> well, it depends on the axioms you use i guess
18:19:10 <kniu> I'm going to implement this system and see what falls out.
18:19:11 <Saizan_> though i think there's probably a more compelling reason
18:21:30 <kniu> I should ask someone with a Ph.D.
18:21:47 <Saizan_> maybe haskell-cafe :)
18:22:02 <kniu> the mailing list?
18:22:17 <Saizan_> yeah
18:22:21 <kniu> hm.
18:24:34 <mattam> kniu: It's quite important to distinguish types from values in the end. You can certainly think of Pi as a combinator that takes a lambda abstraction, but you have to check that this returns a type itself not a value.
18:25:35 <mattam> E.g [Pi x : nat, x] is "meaningless".
18:26:02 <kniu> not necessarily, methinks.
18:26:04 <mightybyte> @pl (\f g -> f g >> (return True))
18:26:05 <lambdabot> flip flip (return True) . ((>>) .)
18:26:15 <kniu> what if we let the "tower" of types go both ways?
18:26:58 <kniu> hell, make it so that every term is both a value AND potentially a type for some other values.
18:27:01 <soupdragon> :/
18:27:04 <mightybyte> @pl foo f = maybe (return False) (\g -> f g >> (return True))
18:27:08 <soupdragon> why don't you just watch yellow submarine
18:27:10 <lambdabot> foo = maybe (return False) . flip flip (return True) . ((>>) .)
18:27:11 <mattam> Meaning interpreting a value as a singleton type?
18:27:34 <kniu> aye.
18:27:56 <kniu> like empty data declarations.
18:27:58 <mattam> So that would translate my example to [Pi x : nat, { n : nat | n = x }] more or less?
18:28:21 <Baconizer> ohaider. I keep getting errors about indentation. I play around with the indentation and it still gives the same error. I hate to ask for something probably so simple, but what is the issue? D: http://pastebin.com/m6f4d98f7
18:28:40 <Baconizer> dangit, wrong thing
18:28:40 <Baconizer> >_>
18:28:43 <kniu> mattam, sure, I think.
18:28:46 <Baconizer> oh well
18:28:53 <Baconizer> Same issue :P
18:29:12 <Saizan_> Baconizer: you lack a do
18:29:23 <Saizan_> and the case must be aligned with the let
18:29:30 <kyagrd> Is that Haskell?
18:29:33 <Saizan_> but you also lack a print
18:29:56 <kyagrd> well it would be haskell but I see four variable patterns and a wildcard pattern.
18:29:56 <kyagrd> only first one will always match
18:30:01 <mattam> Hmm, that's an interesting view. So if the abstraction returns a value, we consider that it is a type denoting this single value. Not sure you would gain much from that.
18:30:03 <Baconizer> It's _ -> print "lolwut" right?
18:30:12 <mightybyte> @pl (\f g -> (return True) =<< f g)
18:30:12 <lambdabot> ((return True =<<) .)
18:30:12 <Saizan_> oh, wait
18:30:14 <Saizan_> no
18:30:25 <Baconizer> I thought I didn't need a print for case :/
18:30:28 <gwern> yeesh. the output of tagsoup on a Wiktionary page is dismayingly long
18:30:36 <Saizan_> the case is inside the let, right?
18:30:41 <Saizan_> to define oodles
18:30:57 <gwern> why couldn't the show instance for tagsoup's [String] be a nice tree? :(
18:30:57 <Baconizer> Yeah
18:31:08 <mattam> kniu: You can probably make a kind of generalized PTS from that :)
18:31:10 <kniu> mattam, more like the abstraction from X to Y is the type of the abstraction from X to (Z of type Y)
18:31:20 <mightybyte> @pl foo f = maybe (return False) (\g -> (return True) << f g)
18:31:21 <lambdabot> foo = maybe (return False) . ((return True <<) .)
18:31:45 <Saizan_> Baconizer: ok, there are a couple of problems there
18:31:59 <mattam> kniu: What about  [Pi x : nat, 2], what are the values categorized by it?
18:32:09 <Saizan_> Baconizer: the indentation one is that you lack an "in ..." for your let
18:32:27 <Baconizer> wat D:
18:32:28 <Saizan_> Baconizer: and probably that the case must be indented more
18:32:33 <benmachine> you don't need a "in ..." for do-blocks
18:32:39 <Saizan_> right
18:32:42 <benmachine> but you're not in a do-block
18:32:50 <benmachine> so it really depends on what exactly you are trying to do
18:33:04 <kniu> (\x : Nat. Y where (Y : 2))
18:33:06 <benmachine> it seems once you have defined oodles you don't do anything with it?
18:33:30 <Saizan_> you can't have only a let in a do-block though
18:33:46 <Baconizer> I was trying to test 'case'
18:33:53 <benmachine> ah
18:33:58 <Saizan_> also, your patterns in the case are all variables, so it won't work
18:34:03 <Baconizer> I just want it to print something corresponding to whatever I chose
18:34:15 <benmachine> how do you choose whatever you chose
18:34:35 <Baconizer> I thought I would run oodles with an argument of "ch"
18:34:37 <Alpounet>  choice function
18:34:56 <soupdragon> knui why???
18:34:58 <mattam> kniu: So you could have a judgment [Y : 2] or is that just hypothetical?
18:35:03 <Baconizer> If I ran "./casetest ohai" it would print out "lolwut"
18:35:04 <Saizan_> Baconizer: your case expressions won't work like that though
18:35:08 <Baconizer> :(
18:35:22 <Baconizer> I use if-then-else?
18:35:22 <kniu> mattam, what's a judgment?
18:35:26 <Saizan_> > case "a" of c -> 1; a -> 2; b -> 3
18:35:28 <lambdabot>   1
18:35:39 <Saizan_> Baconizer: no, you just need to use patterns in your case
18:35:53 <Baconizer> Hi.
18:36:00 <Saizan_> Baconizer: instead of variables
18:36:08 <Saizan_> > case "a" of "c" -> 1; "a" -> 2; "b" -> 3
18:36:10 <lambdabot>   2
18:36:13 <mattam> kniu: a typing judgment, formed by typing rules like [x : A |- x : A] which says if you have x : A in your context you can derive [x : A].
18:36:23 <Baconizer> Put things in quotes?
18:36:25 <gwern> ...emacs-mode sucks at indentation. running on the list generated by tagsoup, it will hang for a minute to indent one entry
18:36:56 <kniu> mattam, in that case, yes, you can have a judgment [|- Y : 2]
18:36:59 <Saizan_> Baconizer: in quotes you've string
18:37:18 <Saizan_> Baconizer: otherwise they are identifier names, like oodles is
18:37:28 <mattam> Like [ |- 2 : 2] ? What are the inhabitants of the type [2]
18:37:38 <Baconizer> Saizan_: ok
18:37:56 <kniu> mattam, something the user of the language has defined.
18:37:57 <Saizan_> Baconizer: i suggest you to define oodles outside of main
18:38:02 <kniu> 2 : 2 doesn't make sense.
18:38:07 <kniu> you can't have a value be its own type.
18:38:14 <Saizan_> Baconizer: and just load your file in ghci, so you can play with it at the prompt
18:38:56 <kniu> The programmer SAYS that "in this environment, let there be a constructor Y that creates a value of type 2"
18:39:33 <Baconizer> Saizan_: thanks for your help so far :D
18:40:01 <mattam> Interesting. What can you do with Y from then on? Pass it to functions of type [Pi X : 2, Y]?
18:40:13 <Baconizer> Saizan_: I'm an absolute newbie though, I don't understand completely :/
18:40:47 <kniu> mattam, yes.
18:41:57 <mattam> kniu: I don't know exactly where you're going with that, but good luck exploring.
18:41:58 <kniu> but note that 'Y' would not be a reachable name in that other function, so it's just (\ x : 2. x) : [Pi X : 2. 2]
18:42:47 <mattam> Oh sorry, alpha-convert it.
18:43:02 <mattam> functions of type [Pi X : 2, Z].
18:43:41 <soupdragon> it's lunacy
18:46:27 <lpsmith> kniu,  mattam,  what is Pi?
18:46:58 <Saizan_> Baconizer: what book/guide are you following? LYAH is generally recommended
18:47:30 <lpsmith> Pi as in pi-calculus?
18:47:50 <moonpatrol> <3 learn you a haskell
18:48:03 <kniu> lpsmith, Pi denotes the dependent product in systems with dependent types.
18:48:09 <Saizan_> Pi can be seen as a generalization of ->
18:48:12 <kniu> has nothing to do with the pi-calculus.
18:48:14 <Saizan_> and forall
18:48:37 <Saizan_> as we have them in haskell
18:48:55 <Saizan_> it's basically forall where the variable doesn't need to be a type-variabel
18:49:19 <Baconizer> Saizan_: I was just sort of fiddling
18:49:33 <Saizan_> so, a type like Bool -> Int can be written as Pi x:Bool, Int
18:49:35 <Baconizer> I have the cheatsheet thingy next to me, which is where I got the case stuff from.
18:49:45 <Baconizer> Saizan_: I have a pdf of LYAHFGG though
18:49:48 <Baconizer> I'll work on that
18:49:51 <Baconizer> Thanks :D
18:49:59 <Saizan_> np :)
18:51:45 <Saizan_> and forall a:*. T a can be written as Pi a:*, T a, though with Pi you can also have a type like Pi n:Nat, Vec n A
18:52:16 <lpsmith> So what systems allow this notation?
18:52:18 <Saizan_> which is a function from natural numbers to vectors of the size of that natural number
18:52:23 <lpsmith> Agda, Coq?
18:52:26 <Saizan_> yes
18:52:53 <Saizan_> though in Agda you don't write Pi out
18:57:43 <dons> note well: why we do youtube videos/blog posts: "Pretty awesome. I didn't think that Haskell's GUI capabilities were this good. Also, this guys is actually pretty good at the game itself."
18:57:48 <dons> gwern:
18:58:43 <Nafai> dons: What video is that a comment for?
18:58:49 <dons> http://lambdacolyte.wordpress.com/2009/08/06/tetris-in-haskell/
18:59:26 <blackdog> dons: that's some nice marketing :)
19:00:13 <dons> this is another good one, http://www.youtube.com/watch?v=AJQZg3Po-Ag
19:00:45 <randomwords> It's a shame he hasn't released the code yet
19:01:54 <chadz> seems i suck about reasoning with fusion/memory usage
19:02:11 <michaelfeathers> Those are nice vids.
19:03:26 <chadz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8032
19:03:30 <dons> there's a trend for writing small games in haskell. that's great. i wish people would write other things too though
19:03:52 <chadz> it's essentially csv parsing, and i'm throwing some results into a map... however, it doesn't scale at all
19:04:12 <Alpounet> dons, like ?
19:04:21 <jmcarthur> like BIG games?
19:04:25 <chadz> i'm guessing fusion's not as smart as i'd like, and, i'm feeding the gc to death
19:04:44 <dons> Alpounet: things that are useful to you
19:04:51 <chadz> like a game library?
19:04:57 <dons> heh
19:05:01 <michaelfeathers> dons: I've been thinking about writing a GUI twitter client with Gtk2HS.  Don't know if my skills are up to it yet.
19:05:19 <chadz> michaelfeathers: those are called web browsers ;)
19:05:27 <Nafai> gtk2hs is pretty nice
19:05:33 <dons> a binding to webkit might be good
19:05:40 <dons> yes, gtk2hs on top of say, twidge
19:05:40 <michaelfeathers> chadz: Way simpler than web browser :)
19:05:51 <dons> twidge is already most of what you need for twitter. it works well
19:05:53 <dons> just add a gui
19:06:06 <chadz> if anyoen could take a look at my hpaste post and try and spot obvious inefficienies i'd be happy
19:06:13 <michaelfeathers> Yeah, I looked a the source for twidge a bit.
19:06:30 <chadz> before writing a twitter program, ask  yourself why you use twitter
19:06:39 <michaelfeathers> Maybe next week, I'll have time to dig into Gtk2HS.  Haven't dealt with it yet.
19:06:39 <chadz> if you're still encouraged, good luck :)
19:07:15 <michaelfeathers> chadz: My twitter use has fallen off.  Was better before they changed the semantics of reply.  It's all silos now.
19:07:19 <blackdog>  chadz: it's an interesting lingua franca, in a way
19:07:54 <blackdog> if you want to include all your code commits on your website, for instance, setting up a twitter account is pretty easy, and a lot of blog software can incorporate tweets
19:08:02 <Saizan> chadz: i'd throw some bang patterns at that update function
19:08:05 <blackdog> suddenly there's a chunk of code you don't have to wirtte
19:08:34 <chadz> Saizan: haven't really ever messed with strictness in haskell. i tried to throw some bangs on the Ints but it yelled at me
19:08:55 <shapr> whee!
19:08:56 <chadz> blackdog: but isn't that what code revision systems arleady give you?
19:09:07 <Saizan> chadz: did you add {-# LANGUAGE BangPatterns #-} to your file?
19:09:24 <shapr> Is there an up to date gtk2hs tutorial?
19:09:30 <blackdog> chadz: i'm talking about ambient information, not actually using the code itself
19:09:36 <chadz> Saizan: naw, let me try.
19:10:08 <blackdog> chadz: the point is that you get to avoid writing all the combinations of "i'd like to read from X and write to Y"
19:11:47 <chadz> yell at your developers and have them write nicer descriptions? :)
19:11:47 <blackdog> shapr: did you have a chance to look at TBC for me?
19:12:20 <blackdog> chadz: given that my developer is me, i derive little satisfaction from the exercise :)
19:13:18 <shapr> wah
19:13:20 <shapr> He's gone!
19:13:38 <shapr> blackdog: Sorry, I gave in to female attention instead.
19:13:44 * shapr grabs tbc
19:17:26 <TimMcD> I'm interested in learning Haskell. Is 'book.realworldhaskell.org' a good resource?
19:17:48 <Alpounet> Yeah.
19:17:59 <Alpounet> It uses a very practical approach.
19:18:09 <TimMcD> Ok, thanks! ^_^
19:18:18 <mauke> preflex: ? lyah
19:18:19 <preflex>  http://learnyouahaskell.com/
19:18:54 <Axman6> TimMcD: i recommend lyah for absolute beginners
19:19:28 <dons> those are the two resources i think we recommend these days.
19:19:29 <TimMcD> Axman6, mauke: Hmm, mmk.
19:19:55 <TimMcD> I do have experience with functional languages tho, just not haskell.
19:20:24 <dons> TimMcD: what's your FP background?
19:20:25 <Axman6> @where+ beginners Learn you a haskell for great good: http://learnyouahaskell.com/ and Real world haskell: http://book.realworldhaskell.org/
19:20:26 <lambdabot> Nice!
19:20:30 <Axman6> @where beginners
19:20:31 <lambdabot> Learn you a haskell for great good: http://learnyouahaskell.com/ and Real world haskell: http://book.realworldhaskell.org/
19:20:37 <mauke> or you could ask dons to inject haskell DIRECTLY IN YOUR BRAIN
19:20:42 <Axman6> @flush
19:20:42 <lambdabot> Not enough privileges
19:20:46 <Axman6> dang
19:20:47 <dons> i have mad skillz
19:21:06 <Axman6> dons: still planning on coming back to Aus later in the year?
19:21:10 <TimMcD> dons: inject me a haskell for great good!
19:21:12 <TimMcD> Hurry, hurry!
19:21:16 <dons> yep. November probably, Axman6
19:21:19 <pikhq> mauke: I'm afraid that LYAH is quite a bit less painful.
19:21:33 <chadz> Saizan: so, would you add the bang to all the variables in the update function?
19:21:33 <Axman6> excellent. you could come give a talk on my birthday :P
19:21:54 <kingdj> if you know other FP well, "A Gentle Introduction to Haskell" (http://www.haskell.org/tutorial) would be good to look at after the other suggestions.
19:21:59 <pikhq> TimMcD: Start with arrows and work backwards!
19:22:04 <TimMcD> any big differences between GHC 6.10.3 and the one used in lyah?
19:22:15 <Axman6> which one is used in lyah?
19:22:25 <Axman6> there shouldn't be a difference though
19:22:27 <pikhq> GHC 6.8, IIRC.
19:22:37 <dons> TimMcD: use the haskell platform version (or whatever you have installed)
19:22:40 <mauke> argh, why does the @admin command tell me "user error (@admin: invalid usage)"?
19:22:42 <TimMcD> doesn't seem to specify
19:22:45 <dons> they all implement the same core language, to a newbie
19:22:48 <kingdj> lyah seemed to work pretty well for me with 6.10.4
19:22:52 <dons> ?where haskell-platform
19:22:52 <lambdabot> I know nothing about haskell-platform.
19:22:53 <matsuura> calendega
19:23:02 <dons> ?where+ hp http://hackage.haskell.org/platform
19:23:03 <lambdabot> Done.
19:23:12 <Axman6> @where platform
19:23:12 <lambdabot> http://hackage.haskell.org/platform/
19:23:35 <Saizan> chadz: in all the patterns, yeah
19:23:55 <TimMcD> Sadly, I'm on a Mac running Leopard, but has a G4 processor (ppc)
19:23:58 <dons> ah good
19:24:00 <TimMcD> so I had to build myself, not using the platform
19:24:05 <chadz> is there a way to add to the type declaration so I don't have to dirty my code with a million !s?
19:24:06 <dons> ah, ppc
19:24:11 <Axman6> TimMcD: i believe there's a PPC binary release
19:24:15 <dons> TimMcD: you have a working ghc on ppc/leopard?
19:24:16 <Axman6> could be wrong
19:24:28 <TimMcD> dons, yes.
19:24:32 <dons> excellent.
19:24:45 <Axman6> TimMcD: http://www.haskell.org/ghc/download_ghc_6_10_4.html#macosxppc
19:24:46 <Saizan> chadz: they are only four not millions, however you could define yourself a strict tuple type
19:24:51 <TimMcD> Axman6, Hmm I didn't see. The link on hackage.haskell.org/platform/ says Leopard/x86
19:25:06 <Axman6> it's a community supported release
19:25:06 <TimMcD> Axman6, ah yeah thats what I used
19:25:08 <dons> right. the platform is the full distribution (compiler, tools, libraries)
19:25:13 <TimMcD> Axman6 I didn't use the platform tho.
19:25:19 <Saizan> chadz: like data a :*: b = !a :*: !b
19:25:20 <dons> the ghc release itself is just the compiler, but is in binary form on more systems
19:25:22 <Axman6> that's not the platform
19:25:32 <Axman6> that's just a binary release of GHC
19:25:35 <TimMcD> Yeah
19:25:37 <TimMcD> Thats what I used
19:25:46 <Axman6> so you've got 6.10.4?
19:25:58 <TimMcD> What I was saying is that, there is no platform release for ppc/leopard
19:26:00 <chadz> Saizan: hmm, seems to be only marginally better. doesn't scale linearly at all, and, a 600 meg file causes a stack overflow :(
19:26:04 <dons> TimMcD: that's right
19:26:13 <TimMcD> Axman6, yes. 6.10.4
19:26:18 <dons> TimMcD: we need someone to coordinate with gcollions (the platform/mac guy) to produce one
19:26:25 <Axman6> TimMcD: ou can compile the platform quite easily
19:26:46 <pikhq> Just GHC and some libraries.
19:26:51 <TimMcD> Hmm
19:26:52 <pikhq> (and some tools...)
19:26:59 <TimMcD> Yeah
19:27:11 <Saizan> chadz: welll, you're doing a sort so it won't scale linearly
19:27:34 <TimMcD> Sadly, most of building/compiling knowledge resided in './configure --a couple of flags && make && sudo make install'
19:27:35 <TimMcD> If I get an error, I complain on IRC >:P lol
19:27:38 <Saizan> chadz: though the stack oveflow means that's something wrong
19:27:46 <chadz> Saizan: the size of the list in teh sort is constant regardless of size of input though.
19:28:21 <chadz> Saizan: im pretty i'm somehow holding onto a reference and not able to perform gc on something... not sure how to track it down though
19:28:54 <pikhq> TimMcD: Most of it's Cabalised. Which means that it's "cabal install" instead. ;)
19:29:18 <TimMcD> pikhq, dons, Axman6: I'd be willing to help out ^_^ Drop me a line: tmcdowell@gmail.com
19:29:27 <randomwords> Is there anything written about when and why par/strategies can cause space leaks?
19:29:28 <TimMcD> I've also got an x86/tiger mac mini over here.
19:29:45 <dons> randomwords: yes, the best reference is Simon Marlow's recent paper
19:29:48 <pikhq> TimMcD: Eh, I don't touch Macs much myself.
19:29:56 <pikhq> Not enough UNIX; too much graphics.
19:30:01 <TimMcD> Mm
19:30:02 <Saizan> chadz: that'd cause an heap overflow, not a stack one
19:30:06 <dons> randomwords: http://www.haskell.org/~simonmar/bib/bib.html
19:30:07 * Axman6 's more interested in a 64bit leopard release for Snow Leopard
19:30:16 <chadz> Saizan: hm, true.
19:30:19 <TimMcD> I can't wait for  Snow Leopard...
19:30:35 <Axman6> yeah. should be good
19:30:46 <TimMcD> $29 was it? And you actually save space on the PowerBook. $100+ for Vista tho, right? ^_^
19:31:00 <TimMcD> *meant save space on the install over leopard
19:31:10 <TimMcD> Was reading the little logo on my laptop as I was typing >_>
19:31:16 * Nafai reads the backlog
19:31:17 <Axman6> win& is supposed to be a lot cheaper, but not as cheap as snow leopard
19:31:36 <Axman6> win7*
19:31:47 <TimMcD> mm
19:31:51 <Nafai> dons: A binding to webkit making a Haskell extended browser (much in the spirit of Yi or Xmonad) would be awesome, methinks
19:31:56 <Saizan> chadz: are you compiling with -O2 , btw?
19:31:59 <TimMcD> I dont know much of anything about win7. Vista either, tho. So I should be quiet.
19:32:02 <erikc`> is it $29 only if you are upgrading from leopard thuogh?
19:32:03 <chadz> Saizan: yeah.
19:32:13 <TimMcD> eikc`: I think so
19:32:18 <TimMcD> I g2g for now guys, thanks for the help
19:32:20 <chadz> erm wait, my last one left it out. let me try again
19:32:22 <Axman6> o/
19:32:41 <erikc`> yea, win7 really should have been in the same ballpark if you're a vista customer
19:32:58 <Axman6> Nafai: yeah, i'd love a nice Xmonesque browser, which i could configure using haskell
19:33:09 <Axman6> basically, uzbl written in haskell
19:33:13 <Nafai> Yeah
19:33:22 <Nafai> That's my thought too
19:33:22 <dons> Nafai: yeah, like LLVM bindings, a foundation for killer apps
19:33:23 <Axman6> Xmonadesque*
19:33:32 <dons> please do it
19:33:36 <Nafai> Doh.
19:33:41 <Nafai> I'm just the idea man :)
19:33:47 <Saizan> chadz: heap profiling can help to spot if there's a big thunk somewhere btw
19:33:51 <chadz> Saizan: good catch
19:33:54 <Nafai> I wonder how hard that would be to pull off though
19:34:03 * Axman6 doesn't know anything about webkit programatically
19:34:16 <Nafai> Perhaps utilizing webkit-gtk?
19:34:55 <chadz> Saizan: the bang patterns seem to be the key. after adding them i dropped the -O2 . with both it's far nicer.
19:35:05 <Nafai> Otherwise, I'm not sure how one would go about it, given that webkit is C++
19:35:25 * Nafai runs "cabal install tetris"
19:35:26 <erikc`> Step 1. Wrap webkit with a C interface. Step 2. Write Haskell binding to C interface.
19:35:37 * Nafai nods
19:36:04 <pikhq> erikc`: webkit-gtk has step 1.
19:36:04 <pikhq> :)
19:36:10 <erikc`> booya
19:36:16 <chadz> Saizan: thanks.
19:36:54 <Twey> Or, Step 1. Write Haskell wrapper for C++.  Step 2. Write Haskell binding to Webkit.
19:37:06 <Nafai> Twey: Step 1 would be useful
19:37:13 <dons> Call the C interface, ala qtHaskell
19:37:28 <Twey> Nafai: Aye.
19:38:07 <Nafai> There are many C++ libraries I would like to use
19:38:20 * Axman6 qould like something that avoided gtk and such, but doesn't know if that's feasable
19:39:20 <Nafai> Axman6: Don't like gtk or are on the Mac?
19:39:30 <Axman6> bit of both
19:39:55 <Nafai> I'm a fan of gtk; but then again, I'm on Linux so it works wonderfully to me.
19:40:09 <Nafai> And I would prefer Gtk-webkit to QtWebkit, not a fan of Qt myself
19:41:32 <Axman6> i'd lik to know how easy it would be to write something that just produces a window, with a webkit frame in it, and if it's possible to avoid both Qt and Gtk
19:42:36 <jaredj_> Axman6: there's something that does that...
19:42:42 <jaredj_> Axman6: it matches the regex ..bl
19:42:52 <jaredj_> ah - uzbl
19:43:01 <Axman6> is it haskell? ;)
19:43:03 <jaredj_> no
19:43:05 <jaredj_> c
19:43:06 <jaredj_> i think
19:43:32 <jaredj_> 2841 lines of c
19:44:12 <Axman6> well, being able to use haskell would be excellent.
19:45:02 <Saizan> jaredj_: so it call C++ directly? or there's a wrapper ?
19:45:27 <Saizan> a sufficiently standalone wrapper i mean
19:45:53 <jaredj_> Saizan: it says it's based on the Gtk-Webkit example code
19:46:25 <jaredj_> looks like it's calling webkit from c
19:46:40 <jaredj_> function calls to webkit_*, include of webkit/webkit.h
19:47:52 <Nafai> jaredj_: What gui toolkit, if any, does uzbl use?
19:48:13 <jaredj_> gtk
19:48:17 <jaredj_> 2.0
19:50:47 <jaredj_> uzbl.org
20:11:08 <frevidar> I know this is probably a vague question, but whats the best way to make a network link between two haskell applications transparent
20:11:11 <frevidar> ?
20:11:48 <frevidar> so I can treat it as close to as if it was one program
20:12:21 <frevidar> for example, is there something that lets you easily perserve laziness over a network link?
20:12:42 <dmwit> not really
20:12:55 <dons> frevidar: 'ports' are a good abstraction
20:13:10 <dons> there are other ways of having values arrive over the network seamlessly
20:13:16 <dons> but no, you can't serialize thunks easily
20:13:27 <dons> so you want to do distributed haskell, rather than parallel haskell?
20:14:06 <frevidar> dons: I just want a simple server/client situation
20:14:42 <frevidar> dons: which seamlessly converts datatypes into bytes and back again at the other end
20:14:58 <frevidar> well, haskell data into bytes I should maybe say
20:15:00 <dons>  oh, use Data.Binary
20:15:11 <dons> encode x -- converts haskell value x into a stream of bytes
20:15:16 <dons> decode x -- reads it back
20:15:38 <frevidar> ah, is there anything that packages that with a network link?
20:15:38 <dons> there's a nice socket IPC package on hackage
20:15:54 <dons> i think the ipc package will be easy to tweak
20:15:58 <dons> if it doesn't do what you need already
20:18:47 <frevidar> dons: so with Data.Binary do I have to say how its converted to and from bytes?
20:19:26 <mauke> yes, with instance declarations
20:20:35 <Saizan> frevidar: the instances can be automatically generated with Data.Derive
20:46:26 <TimMcD> =D
20:46:35 <TimMcD> |_P Making a pot, anyone in need?
20:46:46 <Makoryu> A pot of... tea?
20:46:52 <Makoryu> ... A pot of pot?
20:46:56 <TimMcD> |_P <-- coffee!
20:47:13 <TimMcD> こふぇ
20:47:15 <SubStack> delicious side effects
20:47:22 <TimMcD> |_0 hrm
20:47:26 <TimMcD> that doesn't work.
20:47:28 <SubStack> caffeine is especially monadic
20:47:29 <TimMcD> |_O
20:47:36 <Makoryu> TimMcD: Shouldn't that be in katakana?
20:47:51 <Cale> コーヒー
20:48:04 <SubStack> C[-]
20:48:13 <TimMcD> Makoryu: Most likely. I'm too lazy to switch between all three. I just have hirigana and standard english hotkey'd on my mac ^_^
20:48:34 <TimMcD> すめません、えごがわかりまsか？
20:48:40 <TimMcD> hrm
20:48:41 <Makoryu> TimMcD: Try typing in all caps
20:49:19 <Makoryu> It comes out as katakana
20:49:22 <TimMcD> すめません、えごがわかりますか？
20:49:24 <TimMcD> Hrm, not for me
20:49:25 <TimMcD> Anyway
20:49:27 <Cale> Where don't you live?
20:49:31 <TimMcD> 'ego' is english?
20:49:36 <TimMcD> Cale: Ireland.
20:49:40 <Cale> えいご
20:49:41 <TimMcD> I don't live in Ireland.
20:49:54 <Cale> 英語
20:50:02 <Makoryu> 英語
20:50:06 <Makoryu> Yeah
20:50:07 <Makoryu> That
20:50:11 <TimMcD> means?
20:50:18 <TimMcD> I'm learning japanese, can't read it it.
20:50:22 <TimMcD> *can't read it yet
20:50:26 <TimMcD> can speak a teeny bit
20:50:42 <TimMcD> ん  I can recognize that is 'n' tho >:P
20:52:00 <jaredj_> hunter1
20:52:06 <Hunner> TimMcD: eigo
20:52:07 <jaredj_> what's that say?
20:52:18 <Hunner> it doesn't say hunter2
20:52:31 <jaredj_> doh
20:53:03 <TimMcD> Hunner: Mm, thanks, so:　えいごがわかりますか? is basically asking if you speak english?
20:53:17 <TimMcD> eigogawakarimasuka?
20:53:23 <shapr> wah
20:53:37 <TimMcD> Btw, I should have realized eigo couldn't be ego. Thanks for that ^_^
20:53:52 <Cale> TimMcD: yes, if you understand it
20:53:58 <Hunner> TimMcD: "wakarimasu" is 'understand' not 'speak', but essentially
20:54:26 <TimMcD> Hunner: Groovy, thanks!
20:55:28 <Hunner> if you tried to use the word for 'speak' in replacement then you end up asking if they ever do speak it, rather than the intended meaning of asking if they *can* speak it
20:56:07 <shapr> What's up with Thomas Jaeger these days?
20:57:05 <TimMcD> おとこのこわたべています。that's saying that a child (boy) is heating, right? otokonoko wa tabiteimasu.
20:57:12 <TimMcD> Hunner: Whats the 'technical' meaning of
20:57:17 <TimMcD> 'imasu'?
20:57:45 * Axman6 has a feeling this discussion is a prime candidate to move to #haskell-blah 
20:57:52 <TimMcD> Sorry :(
20:58:18 * TimMcD is a japanese-fanboy.
20:58:40 * Rotaerk is a human fanboy.
20:58:46 <shapr> Haskell sure is fun.
20:59:05 <Rotaerk> someone once told me they'd give up sex before haskell -_-
20:59:16 <Axman6> heh
20:59:19 <dons> hmm
20:59:28 <shapr> Must not have been me.
20:59:29 <Axman6> yeah i can see myself saying that
20:59:31 <Cale> います is the polite form of いる which means to be/to exist
20:59:37 <Axman6> my girlfriend would not be happy
20:59:44 <Cale> (for animate things)
20:59:46 <shapr> I wonder if I have a girlfriend.
20:59:47 * shapr checks
20:59:57 <medfly> well, there are Japanese related channel and I know at least 2/3 of the people discussing Japanese are in them
21:00:00 <shapr> She says no :-(
21:00:26 <TimMcD> Cale: The first one is imasu, the second one in... ah crap I forgot the word. Japanese words written in english... anyway, whats that second one?
21:00:35 <Cale> iru
21:00:45 <TimMcD> mm
21:00:46 <TimMcD> Ty
21:01:10 <TimMcD> medfly: Suggest a good learners japanese channel?
21:01:16 <Cale> It's really a good idea to learn kana as soon as possible. Writing Japanese using the Roman alphabet is strange :)
21:01:16 <Axman6> shapr: you've still got haskell right?
21:01:18 <TimMcD> So I can take my spam elswherE? ^_^
21:01:30 <Cale> TimMcD: There's ##Japanese and #nihongo
21:01:38 <medfly> imasu is the formal iru
21:01:39 * Hunner wonders why japanese seems to come up *so* often here anyway...
21:01:44 <TimMcD> Cale: Thanks ^_^
21:01:54 <medfly> Hunner, there's a Cale and a Twey and apparently a bunch of other people
21:01:58 <TimMcD> Hunner: Cuz Japanese is, like, totally ftw! Duh!
21:01:59 <TimMcD> xD
21:02:07 <p_l> lol
21:02:08 <Twey> Hehe
21:02:17 <Twey> I don't mention it!  It's all Cale!  Honest!
21:02:18 <TimMcD> [/teenspeak]
21:02:21 <p_l> still, I found japanese grammar easier than german :D
21:02:25 <matsuura> lol
21:02:29 <Saizan_> is it a functional language?:)
21:02:31 <Gracenotes> habla el nihongo?
21:02:43 <TimMcD> Gracenote:No :(
21:02:49 <matsuura> chinese grammer is much easier than japanese grammer
21:02:51 <matsuura> haha
21:02:58 <matsuura> it's just tougher to write everything
21:02:59 <matsuura> D:
21:03:00 <p_l> Gracenotes: barely, I still remember more Japanese than German, though :P
21:03:02 <Gracenotes> -.- although srsly, Japanese and Spanish share many phonemes
21:03:09 <SamB> anime!
21:03:10 <matsuura> Gracenotes: agreed!
21:03:25 * Hunner 's brother is named Cale, so when he sees Cale go all uberhaskell/mathematical in here it's a bit weird
21:03:39 <Cale> Hehe
21:03:40 <leo_> p_l, btw, what's your native language?
21:03:47 <medfly> #Japaneseに日本語を言うことをいます
21:03:52 <medfly> thank you :d
21:03:56 <p_l> leo_: polish
21:04:19 <TimMcD> I just can't see myself actually speaking japanese in america. I'd be ridiculed beyond relief (I can hear my friends saying: "I bet you watch the japanese power-rangers!")
21:04:25 <Twey> medfly: In #Japanese there is a person who is an event of speaking Japanese?
21:04:32 <matsuura> Twey: it's tough
21:04:33 <medfly> :(
21:04:35 <matsuura> I can tell you that much
21:04:40 <matsuura> err, TimMcD *
21:04:40 <SamB> TimMcD: they still *have* power rangers?
21:04:42 * medfly slaps Twey 
21:04:49 <Twey> Ouch!  :<
21:04:51 <Gracenotes> medfly: you could say が, methinks..
21:04:56 <matsuura> TimMcD: it's weird practicing it too
21:05:20 <Gracenotes> and I think the act of speaking Japanese isn't sentient :(
21:05:25 <p_l> SamB: Sentai is quite popular genre, iirc
21:05:25 <Twey> medfly: います is for animate beings; あります is for everything else
21:05:35 <TimMcD> matsuura: Hehe, I use Rosetta Stone. The rest of my family has to deal ;)
21:05:37 <medfly> just do your talking in #Japanese
21:05:48 <matsuura> medfly: that's typing
21:05:49 <p_l> SamB: I'm not sure, but iirc american Power Rangers were a mashup of several series or something like that
21:05:50 <matsuura> lol
21:05:52 <Twey> Oh, ‘an event of saying Japanese’ even.  You probably wanted 話す.
21:06:01 <SamB> p_l: mashup?
21:06:04 * Axman6 guesses he was wrong about his #haskell-blah suggestion
21:06:08 <Twey> medfly: But you're not *in* ##japanese.  :-P
21:06:11 * Gracenotes recognizes 買う because, well, it's essentially the only う verb I know
21:06:22 <p_l> SamB: Took several series and made one
21:06:25 <ray> nobody speaks japanese in #haskell-blah
21:06:37 <nimbler> They don't want to go to #Japanese - the people there are all talking about haskell
21:06:48 <TimMcD> lol
21:06:51 <SamB> lol
21:06:52 <medfly> ##Japaneseに日本語の話をいる
21:06:55 <medfly> hahahaha
21:07:04 <medfly> how about that?
21:07:13 <TimMcD> Incorrect. The people in Japanese are just talking about how crazy and partially insane we are.
21:07:20 <Gracenotes> don't forget to nominalize, also I think が is used more than を for that, no?
21:07:30 <SamB> TimMcD: really?
21:07:30 <bd_> いる is for animate nouns
21:07:35 <ray> "man, those haskell guys are nuts" is common all over irc
21:07:37 <bd_> 日本語の話 isn't animate :)
21:07:38 <TimMcD> SamB, nah, quiet channel.
21:07:44 <medfly> it's moving
21:07:50 <bd_> ##Japaneseでは、日本語で会話することがある。 <-- perhaps you mean this?
21:07:52 <TimMcD> ray, I'm used to "Man, that ruby guy is slow!"
21:07:56 <Gracenotes> it moves when you prod it
21:07:56 <Twey> medfly: Mmm… ‘I am being of Japanese chat in ##japanese’ perhaps
21:08:06 <bd_> (also isn't this a bit offtopic for #haskell?)
21:08:09 <Twey> Haha
21:08:14 <medfly> no kidding
21:08:22 <SamB> bd_: that was mentioned already ;-)
21:08:25 <TimMcD> Oh! TIme to show off.
21:08:27 <matsuura> what is prod?
21:08:29 <bd_> SamB: Oh, okay. Just checking.
21:08:30 <TimMcD> <-- 103 WPM typing speed.
21:08:31 <mike-burns> Oh I didn't realize something could be offtopic in here.
21:08:33 <TimMcD> ^_^
21:08:39 <Hunner> TimMcD: OT again. Fail
21:08:43 <SamB> I think that's why #japanese, ##japanese, and #haskell-blah were mentioned
21:08:46 <medfly> Haskell is everything
21:09:01 <matsuura> Everything is not haskell though
21:09:02 <Gracenotes> the boundaries of #haskell and #haskell.jp have been lost somewhere in the fabric space-time. Please be patient as we attempt to reconstruct it.
21:09:05 <TimMcD> Hunner: It's better to talk about typing speeds in #haskell than japanese, right?
21:09:13 <SamB> Gracenotes: lazily!
21:09:14 <TimMcD> Hunner: It has more do with programming than japanese xD
21:09:27 <bd_> TimMcD: You can talk about typing speeds in #japanese as long as you do so in Japanese :)
21:09:43 <TimMcD> bd_: I wish. :'(
21:09:45 <medfly> bd_, talk about a motivation to improve
21:09:59 <TimMcD> bd_: Those snooty Japanese keep farting in my general direction.
21:09:59 <TimMcD> No wait, thats the german...
21:10:03 <medfly> who is this Oleg guy, Twey
21:10:18 <SamB> @quote oleg
21:10:18 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:10:27 <SamB> @quote oleg
21:10:28 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:10:31 * TimMcD corrects himself. It's the Jamaicans who are so snooty.
21:10:34 <SamB> @quote m.*oleg
21:10:34 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
21:10:37 <medfly> maybe there's only one.
21:10:44 <ray> http://okmij.org/ftp/
21:10:45 <SamB> @quote m.*oleg
21:10:45 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
21:10:49 <SamB> @quote m.*oleg
21:10:49 <lambdabot> Pseudonym says: Telling dons that something has been added to the shootout is the new telling Oleg that it can't be done in the type system.
21:10:52 <Cale> medfly: Oleg is a very smart person who posts on the Haskell mailing lists regularly.
21:10:57 <medfly> I know ray, thanks. Twey linked me to that.
21:10:59 <SamB> @quote .*oleg
21:10:59 <lambdabot> stepcut says: <Saizan> in HList you can have what oleg calls a Type Indexed Coproduct <stepcut> in HList you can have what I call a headache
21:11:03 <medfly> that is why I'm asking.
21:11:12 <medfly> thank you Cale!
21:11:18 <Cale> http://okmij.org/ftp/ -- this is his website
21:11:21 <ray> oleg is a living meme who posts to the haskell mailing lists
21:11:25 <SamB> @go oleg cat
21:11:26 <lambdabot> No Result Found.
21:11:29 <Twey> medfly: Oleg is a god.
21:11:36 <Cale> He writes a lot of stuff
21:11:55 <Twey> He's awesome.  In the old sense meaning ‘terrifying’.
21:12:02 <bd_> Oleg is also a standard unit of typeclass hackery. One milli-oleg is calibrated to be just sufficient to implement lisp at compile time in the Haskell type system.
21:12:23 <ray> like farads, microolegs are the more common unit
21:12:27 <TimMcD> !!!Gah you people!!!
21:12:27 <TimMcD> Stop being so distracting, with talks about Oleg-Gods and Japanese. Let me learn Haskell in pieces!
21:12:37 <TimMcD> Peace, too.
21:12:38 <TimMcD> >:P
21:12:41 <medfly> TimMcD, Oleg is apparently Haskell related.
21:12:54 <bd_> ray: Micro-olegs are plenty dangerous - anything over a pico-oleg or so requires special protective equipment.
21:12:57 <ray> it would be more accurate to say that haskell is oleg-related
21:13:08 <Gracenotes> at least have him learn Haskell in WHNF
21:13:12 <SamB> http://arcanux.org/lambdacats_3.html#entry4
21:13:12 <TimMcD> relate is oleg-haskell!
21:13:49 <SamB> @quote .*oleg
21:13:49 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
21:13:54 <SamB> @quote .*oleg
21:13:55 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
21:14:03 <SamB> @quote .*oleg
21:14:03 <lambdabot> Pseudonym says: Telling dons that something has been added to the shootout is the new telling Oleg that it can't be done in the type system.
21:14:06 <SamB> @quote .*oleg
21:14:07 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
21:14:12 <Twey> Haha, that one (edwinb) needs context
21:14:30 <ray> did it actually happen?
21:14:36 <dufflebunk> I'm having a problem with getting cabal to run. I built a version of ghc for RH4, and now: runhaskell Setup.lhs configure; )
21:14:37 <tommd> @quote functor
21:14:37 <lambdabot> byorgey says: Every day that Functor is not a superclass of Monad... one more baby seal dies.
21:14:39 <dufflebunk> Configuring haskellrme-0.0...
21:14:42 <dufflebunk> Setup.lhs: ghc version >=6.4 is required but the version of
21:14:43 <SamB> medfly: did you look at the cat?
21:14:44 <dufflebunk> /home/pmahon/opt/ghc-6.10.4/bin/ghc could not be determined.
21:14:50 <medfly> Sam___, the cat?
21:14:54 <SamB> oleg cat!
21:14:57 <SamB> the one I linked
21:14:59 <dufflebunk> ghc --versio nreports the correct version. Anyone have any ideas?
21:16:08 <tommd> dufflebunk: I could think of a couple work arounds, but no idea what is actually wrong (unless you installed from git and thus have some ghc-YYYYMMDD type version number getting spat out somewhere.
21:16:09 <medfly> funny :)
21:16:20 <tommd> err, installed from darcs, not git.
21:16:25 <SamB> medfly: that's actually an accurate portrayel
21:16:31 <dufflebunk> tommd: It's from the src tarball on the ghc site
21:16:46 <SamB> I mean, he doesn't look like that, but that's *exactly* how he makes most of the rest of us feel ;-)
21:17:10 <Saizan_> tommd: what does ghc --version says exactly?
21:17:34 <tommd> Saizan_: I think you want to talk to dufflebunk.
21:17:39 <dufflebunk> ]$ ghc --version
21:17:41 <lunabot>  luna: parse error (possibly incorrect indentation)
21:17:41 <dufflebunk> The Glorious Glasgow Haskell Compilation System, version 6.10.4
21:18:23 <mmorrow> , compare "6.4" "6.10"
21:18:24 <lunabot>  GT
21:18:29 <mmorrow> is my guess
21:18:38 <Saizan_> nah
21:18:48 <mmorrow> what else could it be?
21:18:56 <Twey> We should have natural-order sorts in the standard library, IMO
21:19:13 <mmorrow> dufflebunk: what's doing the version checking?
21:19:22 <Saizan_> cabal checks the version of your ghc every single time, a bug like that couldn't go unchecked
21:19:23 <mmorrow> oh
21:19:27 <mmorrow> Setup.lhs is
21:19:27 <ray> , compare 6.4 6.10
21:19:28 <lunabot>  GT
21:19:51 <Saizan_> dufflebunk: which ghc matches the path reported by cabal?
21:20:26 <dufflebunk> That's the ghc I built, and the only one on the path. 6.10.4
21:20:35 <mmorrow> what is haskell-rme?
21:20:47 <tommd> I think it's just a matter of GGHC becoming even more self absorbed; it now demands to be called The Supreme Glorious Glasgow Haskell Comilation System, version forem.
21:20:50 <dufflebunk> it's a FFI library I'm working on.
21:20:56 <mmorrow> ah
21:20:58 <tommd> dufflebunk: So ghc-pkg agrees with the ghc version?
21:21:51 <mmorrow> dufflebunk: what about "which cabal" ?
21:22:03 <dufflebunk> Yes, ghc-pkg --versio nreports the same version
21:22:21 <mmorrow> weird
21:22:29 <dufflebunk> mmorrow: there's no cabal apparently
21:22:46 <Saizan_> dufflebunk: try running runghc Setup configure -v3 and paste the output on a pastebin?
21:23:19 <dufflebunk> Saizan_: you mean runghc Setup.lhs ?
21:23:36 <Saizan_> dufflebunk: yeah
21:23:44 <Saizan_> dufflebunk: the extension can be omitted
21:25:22 <mmorrow> dufflebunk: maybe try building Setup.lhs also. e.g. sometimes if you need to do sudo for "./Setup install" and a different version of ghc is in the PATH under sudo
21:25:47 <dufflebunk> Saizan_: http://haskell.pastebin.com/m686daeff
21:26:14 <dufflebunk> mmorrow: there's no other ghc installed on the system
21:26:21 <mmorrow> ah
21:27:08 <dufflebunk> mmorrow: well, there's another in ~/opt/ghc-6.6, but it's not on the path so I don't expect it's involved in any problems
21:27:23 <Saizan_> export LD_ASSUME_KERNEL=2.4.1; /home/pmahon/opt/ghc-6.10.4/bin/ghc --numeric-version ?
21:28:05 * Saizan_ is not sure how export works here
21:28:07 <dufflebunk> Saizan_: the export is for http://hackage.haskell.org/trac/ghc/ticket/3179
21:28:27 <dufflebunk> it's justting an env var so the system uses the correct linuxthread libraries
21:29:23 <dufflebunk> I only needed it once until I close my shell.
21:29:31 <Saizan_> it's weird, it seems Cabal can't spawn the ghc process correctly
21:29:38 <mmorrow> dufflebunk: maybe try a shellscript wrapper that intercepts --numeric-version and see if that works?
21:29:40 <TimMcD> Am I going to need an advanced grasp on math to be able to do much with Haskell?
21:29:51 <TimMcD> Because, y'know, I'm only 14 :'(
21:30:18 <p_l> TimMcD: obvious solution - learn math outside of school?
21:30:33 <Saizan_> no, you don't need the math, although some logic can help for understanding the type system
21:30:37 * p_l will have to organize himself some "remedial" classes
21:30:40 <dufflebunk> TimMcD: heck no
21:31:01 <TimMcD> lol, good. I'm not al lthat worried, it's not like I can't learn or dont understand remedial things.
21:31:26 <TimMcD> It's just I keep hearing people talk about how heavy haskell is mathematically. "You won't get far if you dont have a PhD in statistics!" xD
21:31:36 <mmorrow> statistics?!?
21:31:43 <TimMcD> I have strange friends.
21:31:49 <ray> statistics!?!
21:32:03 <TimMcD> ı
21:32:05 <p_l> TimMcD: Statistics can be useful for some tasks, but definitely aren't required
21:32:23 <dufflebunk> TimMcD: I just read through that stuff on here like charlie brown comic adults
21:32:28 <p_l> TimMcD: good grasp on algebra and calculus, now that could probably help. I lack the second, so I'm not sure :P
21:32:49 <Axman6> TimMcD: maths in general more than stats
21:32:50 <dufflebunk> Saizan_: The shell has no trouble getting the output of ghc from stdout.
21:32:52 <kapil> calculus?
21:33:18 <dufflebunk> Saizan_: I did run the test suite and got two unexpected failures... I've no idea if they could be related
21:33:18 <TimMcD> dufflebunk: Thats the way I hear everyone talk.
21:33:22 <p_l> kapil: preferably lambda? :P
21:33:35 <mike-burns> A solid understanding of how computers work, combined with very basic algebra. That should be all you need.
21:33:40 <ray> or SKI combinator calculus
21:34:23 <p_l> yeah, understanding how computer works is definitely important. Too many people in CS courses don't (or so it seems in my class)
21:34:28 <TimMcD> Yeah, like I said, I'm not that worried. A few people I know have these thoughts that Haskell is so math-oriented that I'll just sit there trying to figure my away around different formulae instead of having fun and programming
21:34:48 <ray> i don't think people know what math means anyway
21:34:51 <TimMcD> On a side note: http://etherpad.com/esolangideas to be a reality someday, even if it has to be done in Ruby.
21:35:48 <TimMcD> On a side, side note: etherpad.com , fun to mess with.
21:36:24 <Saizan_> dufflebunk: i'd make a little script that runs this http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple-Program.html#v%3AfindProgramVersion to check what's going on, and if it fails i'd copy the implementation to try to reduce it to a minimal bug
21:36:29 <dufflebunk> Saizan_: This is really weird, I havne't changed /anything/ but now that runghc command is doing something useful
21:36:32 <Saizan_> s/bug/test case/
21:36:39 <Saizan_> oh.
21:37:35 <dufflebunk> now it's teling me I'm missing regex-tdfa
21:38:04 <Saizan> that's progress :)
21:38:09 <dufflebunk> hmm, if I run it it gets different ways through the message... I think the spawned process finishes too fast or too slow?
21:39:49 <TimMcD> [2, 4..10] == [2, 4, 6, 8, 10]
21:39:49 <TimMcD> [2, 4, 5..10] == [2, 4, 5, 7, 9, 10] ?
21:40:06 <mmorrow> > [2, 4, 5..10] == [2, 4, 5, 7, 9, 10]
21:40:08 <lambdabot>   <no location info>: parse error on input `..'
21:40:16 <dufflebunk> Saizan: http://haskell.pastebin.com/d6aa0b61d
21:40:21 <TimMcD> :(
21:40:27 <mmorrow> > 2:[4, 5..10] == [2, 4, 5, 7, 9, 10]
21:40:28 <lambdabot>   False
21:40:30 <Axman6> [x,y..z] = enumFromThenTo x y z
21:41:32 <Saizan> dufflebunk: yeah, something is broken when dealing with spawned processes
21:41:34 <dufflebunk> Saizan: without the -v3 it fails to get the ghc version every time.
21:42:03 <TimMcD> ghc, gcc, gcs... I'm already confused.
21:42:04 <TimMcD> ^_^
21:42:09 * dufflebunk kicks RH for producing an OS with two non-compatible threading schemes
21:42:18 <mmorrow> dufflebunk: try compiling Setup.lhs
21:42:25 <kapil> TimMcD:
21:42:35 <TimMcD> kapil:
21:42:49 <mmorrow> dufflebunk: (and if that still fails, try building it with -threaded)
21:43:18 <dufflebunk> mmorrow: I think I need to install cabal, I get missing symbols like: Cabalzm1zi6zi0zi3_DistributionziSimple_defaultMain_closure
21:43:27 <mmorrow> :o
21:43:30 <kapil> TimMcD: sorry lost my link! learning maths and programming side by side is good at least up to a certain point. in haskell that point is further than in other languages.
21:43:36 <mmorrow> ghc -O2 --make Setup.lhs # ?
21:44:12 <mmorrow> dufflebunk: you get those errors even with "--make" ?
21:44:49 <dufflebunk> mmorrow: of course... nope, no errors with that
21:44:54 <TimMcD> kapil: Ah, yeah, thanks.
21:45:04 <mmorrow> dufflebunk: hehe
21:45:29 <TimMcD> Kapil: In the end, I wish to get into game development. I was reading up on game physics a bit ago.
21:45:40 <dufflebunk> mmorrow: that seems to always work and produce the correct error about regex-tdfa
21:46:00 <mmorrow> dufflebunk: nice. maybe runghc is borked on your setup
21:48:00 <dufflebunk> mmorrow: could be. RH4 is retarded and old. But if I want my company to be willing to accept development with haskell I need tobe able that it can work on our main platforms,
21:48:12 <dufflebunk> This should be good enough.
21:49:06 <mmorrow> for sure. runghc.hs is just a trivial prog anyways
21:49:31 <mmorrow> http://darcs.haskell.org/ghc/utils/runghc/runghc.hs
21:50:28 <Saizan> you should do some test on ghci too, probably
21:50:37 <TimMcD> ghci> [x*2 | x <- [1..10]]
21:50:37 <TimMcD> So this sets x to be [1..10], and then doubles it? x*2?
21:50:37 <TimMcD> Basically is the same as let x = [1..10]*2 then, right?
21:50:38 <TimMcD> But how come 'let a = [1, 2, 3]' then 'a*2' gives me errors?
21:51:04 <mike-burns> :t (*)
21:51:05 <lambdabot> forall a. (Num a) => a -> a -> a
21:51:15 <Saizan> TimMcD: those are not the same
21:51:37 <Cale> TimMcD: It constructs the list of values x*2 where x is selected from the list [1..10]
21:51:50 <Saizan> TimMcD: in  [x*2 | x <- [1..10]]  'x' is each of the elements of [1..10] one at a time
21:51:51 <mike-burns> TimMcD: `[x*2 | x <- [1..10]]' is like `map (*2) [1..10]'
21:52:13 <TimMcD> Ah, thanks guys!
21:52:30 <TimMcD> Like map (like mike-burns said) or a foreach/each =D
21:52:33 <TimMcD> I understand now ^_^
21:52:39 <Saizan> yup
21:53:03 <dufflebunk> Saizan: it should be enough just to be able to produce binaries for rh4. I don't expect anyone will want to actually debug on it. Besides, the library I'm working doesn't have a .so version so you can't use ghci with it.
21:53:28 <dufflebunk> not on rh4 anyways. It does on newer systems
21:54:11 <TimMcD> mike-burns: Because of haskell's laziness, 'map (*2) [1..10]' works right? It doesn't try to evaluate the (*2), but instead it waits. If I removed the parens however, it would try to eval it and give errors. I'm on the right track there, right?
21:54:50 <Saizan> that has nothing to do with laziness
21:54:56 <mike-burns> TimMcD: That's currying.
21:55:19 <mike-burns> Named after Schonfinkel, as we all know.
21:55:28 <ray> no, laziness means map (*2) [1..] works
21:55:28 <mike-burns> > map (*2) [1..10]
21:55:30 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:55:36 <ray> > map (*2) [1..]
21:55:37 <mike-burns> :t (*2)
21:55:38 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
21:55:39 <lambdabot> forall a. (Num a) => a -> a
21:55:46 <Saizan> (*2) is a shorthand for (\x -> x * 2) if you know lambdas
21:55:52 <TimMcD> mike-burns: Mmk, I'll read on that. I'm interested in writing a few little esolangs along the road, so this sort of thing is important =D
21:56:07 <ray> haskell is boring, not esoteric
21:56:16 <ray> you want forth
21:56:27 <dolio> Forth is esoteric?
21:56:34 <mike-burns> It's both boring AND esoteric!
21:56:40 <TimMcD> ray: I don't want to use an esoteric language. I want to make one, eventually, as a side project. Not my main reason for learning haskell =D
21:56:48 <dolio> It's not befunge.
21:56:59 <dolio> No befunge, even.
21:57:00 <TimMcD> Liek that: http://etherpad.com/esolangideas
21:57:28 <Saizan> TimMcD: the expression "map * 2 [1..10]" would get parsed as "(map *) (2 [1..10])" so it won't typecheck for various reasons (like you're trying to use 2 as it is a function), but that all happens before evaluation
21:57:39 <TimMcD> Saizan: Ah I see, thanks. Er, wait. \x. Whats that mean? I suppose I'll learn later on in lyah...
21:58:25 <mike-burns> TimMcD: `\x -> x * 2' is a function that mutliplies its argument by 2.
21:58:33 <mike-burns> > (\x -> x * 2) 5
21:58:34 <lambdabot>   10
21:58:36 <Saizan> TimMcD: the "\x -> .." syntax let you define an anonymous function on the spot
21:58:40 <dolio> If we're talking Haskell, "map * 2 [1..10]" parses as "(map) * (2 [1..10])"
21:58:42 <TimMcD> mike-burns Yeah, but can't that alxo be written without the \x?
21:58:48 <TimMcD> > (x -> x * 2) 5
21:58:50 <lambdabot>   Pattern syntax in expression context: x -> x * 2
21:58:51 <Saizan> where 'x' is the variable name
21:58:56 <mike-burns> TimMcD: Yes, using currying.
21:59:10 <mike-burns> > (*2) 5
21:59:11 <lambdabot>   10
21:59:12 <Saizan> TimMcD: you need the "\"
21:59:22 <TimMcD> Saizan, Ok thanks.
21:59:27 <TimMcD> Thanks for putting up with me, guys! ^_^
21:59:29 <dolio> Oh, I suppose that's technically the same as "(map *) ..." since that's a section.
21:59:31 <dufflebunk> OMFG!  It worked, my package built and runs on RH4!
21:59:37 <Axman6> whoot
21:59:38 <dufflebunk> Thanks for your help Saizan and mmorrow
21:59:43 <TimMcD> > (\x -> x - (x - 1)) 5
21:59:45 <lambdabot>   1
21:59:48 <mmorrow> dufflebunk: yay! np
22:00:03 <TimMcD> Oh I see now! \x is for making up functions/whatevers on the spot
22:00:04 <TimMcD> where as
22:00:17 <TimMcD> > doubleMe x = x + x
22:00:18 <lambdabot>   <no location info>: parse error on input `='
22:00:24 <TimMcD> rr well liek that
22:00:31 <TimMcD> is for reoccuring functions basically
22:00:31 <ray> that is a definition, not an expression
22:00:34 <TimMcD> Yeah
22:00:36 <TimMcD> ^_^
22:00:44 <Saizan> > let doubleMe x = x + x in doubleMe (doubleMe 1)
22:00:45 <lambdabot>   4
22:00:53 <mike-burns> TimMcD: `doubleMe x = x + x' is the same as `doubleMe = \x -> x + x'
22:01:04 <Saizan> mike-burns: almost :)
22:01:28 <TimMcD> > let doubleMe = \x -> x + x in doubleMe (doubleMe 1)
22:01:30 <lambdabot>   4
22:01:39 <TimMcD> mike-burns, Saizan: Thanks mates. =D
22:02:27 <Saizan> np :)
22:02:53 <matsuura> http://www.youtube.com/watch?v=YJc9JKYhta4&feature=related
22:03:04 <Makoryu> @pl \x -> x + x
22:03:05 <lambdabot> join (+)
22:03:33 <raceRider> Looking for examples of connecting to ODBC sources through HDBC
22:04:06 <alc> @src join
22:04:06 <lambdabot> join x =  x >>= id
22:09:51 <alc> :t \x -> x + x
22:09:53 <lambdabot> forall a. (Num a) => a -> a
22:09:59 <alc> :t join (+)
22:10:01 <lambdabot> forall a. (Num a) => a -> a
22:10:21 <alc> > join (+) 1
22:10:22 <lambdabot>   2
22:10:32 <alc> , join (+) 1
22:10:33 <lunabot>  2
22:10:59 <Makoryu> :t \f x -> f x x
22:11:01 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
22:11:52 <Makoryu> > "pizza"
22:11:54 <lambdabot>   "pizza"
22:12:07 <Makoryu> > "I broke lambdabot"
22:12:08 <lambdabot>   "I broke lambdabot"
22:12:53 <Trinithis> :t (map *)
22:12:54 <lambdabot> forall a b. (Num ((a -> b) -> [a] -> [b])) => ((a -> b) -> [a] -> [b]) -> (a -> b) -> [a] -> [b]
22:13:01 <Gracenotes> o.o
22:13:11 <Trinithis> never knew that was possible
22:13:27 <Trinithis> guess it makes sense
22:13:27 <shachaf> Trinithis: It's not unless you have a very weird Num instance.
22:13:46 <Gracenotes> well, x * y = z... in this case, x is map, which has the type (a -> b) -> [a] -> [b]... and it also must be a number
22:14:06 <Makoryu> :t (map * map)
22:14:07 <Trinithis> yea
22:14:08 <lambdabot> forall a b. (Num ((a -> b) -> [a] -> [b])) => (a -> b) -> [a] -> [b]
22:14:26 <Trinithis> function math!
22:14:29 <Gracenotes> so Haskell assumes it can be :X
22:14:30 <copumpkin> :t (fmap * fmap)
22:14:31 <lambdabot> forall a b (f :: * -> *). (Functor f, Num ((a -> b) -> f a -> f b)) => (a -> b) -> f a -> f b
22:14:36 <copumpkin> :t (fmap * map)
22:14:38 <lambdabot> forall a b. (Num ((a -> b) -> [a] -> [b])) => (a -> b) -> [a] -> [b]
22:15:01 <Gracenotes> (*), the new `asTypeOf`!
22:15:06 <Trinithis> hah. what if people used * as .
22:15:17 <shachaf> As fmap, you mean?
22:15:27 <Trinithis> for functions
22:15:39 <Yrogirg> Hello! Why does runList lead to Stack space overflow, but not runNumb?
22:15:39 <Yrogirg> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3238#a3238
22:15:42 <Trinithis> then you can square functions
22:16:06 <copumpkin> > let square = join (.) in square (+5) 4
22:16:07 <lambdabot>   14
22:16:08 <Gracenotes> to an extent, join sort of squares functions
22:16:37 <Gracenotes> not just doubling with (.), but also generally collapsing two arguments into one...
22:16:44 <Trinithis> I meant by doing: (f ^ 2) bar
22:17:14 <Trinithis> sorta like iterate
22:17:16 <Trinithis> :t iterate
22:17:17 <lambdabot> forall a. (a -> a) -> a -> [a]
22:18:00 <Gracenotes> er
22:18:08 * shachaf wishes join (.) (:[]) could work.
22:19:18 <Gracenotes> on the other hand, it looks more amusing to have them chasing each other, (:[]).(:[]).(:[]).(:[]).(:[]).(:[]).(:[]).(:[]).(:[]).(:[]).(:[])
22:19:30 <ray> gobble gobble gobble
22:20:02 <mmorrow> , nesty $(nat 18) (:[]) 42
22:20:06 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
22:20:06 <shachaf> (:[(:[(:[(:[(:[(:[(:[])])])])])])])])
22:20:11 <Trinithis> > ((:[]).(:[])) 5 == [[5]]
22:20:12 <lambdabot>   True
22:20:14 <mmorrow> , $(nat 18)
22:20:16 <lunabot>  N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N Z)))))))))))))))))
22:20:34 <mmorrow> , nesty (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N Z)))))))))))))))))) (:[]) 42
22:20:36 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
22:20:47 <alc> w00t
22:20:50 <mmorrow> you can do it with a type family
22:20:59 <Trinithis> :t nesty
22:21:00 <lambdabot> Not in scope: `nesty'
22:21:08 <mmorrow> that uses the GADT N
22:21:12 <alc> hmm this is too much for me -- cant understand this join thing..
22:21:13 <mmorrow> to compute the type
22:21:35 <ray> :t join
22:21:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:21:42 <shachaf> alc: Look at the types instead of the implementations.
22:21:49 <Trinithis> GADT N some special thing different than GADT?
22:21:53 <shachaf> (r ->) is a monad (so "m a" means "r -> a").
22:21:54 <Trinithis> using naturals?
22:22:03 <mmorrow> here's nest http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166
22:22:17 <mmorrow> no i just meant the GADT's name in this case is `N'
22:22:35 <Trinithis> k
22:22:46 <mmorrow> the TH for `nat' is just for convenience
22:22:49 <mmorrow> it's not essential
22:22:56 <mmorrow> , $(nat 100)
22:22:59 <lunabot>  N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N (N...
22:23:06 <mmorrow> , toInt ($(nat 100))
22:23:09 <lunabot>  100
22:24:24 <alc> shachaf: got a bit
22:24:27 <Trinithis> cool code
22:24:37 <shachaf> alc: join :: m (m a) -> m a, which is (r -> (r -> a)) -> (r -> a)
22:25:14 <mmorrow> Trinithis: dolio's agda version is neat since you can do everything with just functions
22:25:30 <Trinithis> link?
22:25:43 <mmorrow> Trinithis: it's in the paste below the haskell Nest one
22:25:45 <alc> how can i make it work in ghci?
22:26:02 <Trinithis> ah
22:26:04 <alc> :m Monad then then 'join (+) 1' shows 'No instance for (Monad ((->) a))..'
22:26:17 <dmwit> Control.Monad.Reader or Control.Monad.Instances
22:26:28 <alc> o i c, thanks
22:26:29 <Trinithis> heh, you can use math symbols
22:27:59 <easy4> is there a way to get ghc to print out the inferred types of a source file and exit?
22:29:04 <Trinithis> if nat were not templated, and you hard coded (nat 100), would ghc expand it?
22:32:31 <dmwit> easy4: Maybe -fwarn-implicit-typesignatures or whatever the name of that warning is?
22:32:43 <dmwit> together with -Werror to prevent any further stages...
22:33:36 <dmwit> -fwarn-missing-signatures
22:47:28 <Yrogirg> Hello! Why does runList lead to Stack space overflow, but not runNumb?
22:47:28 <Yrogirg> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3238#a3238
22:52:06 <dmwit> ($!) on lists is kind of dumb.
22:52:15 <dmwit> It only evaluates far enough to see whether it's an empty list or not.
22:52:20 <dmwit> Which is very short indeed.
22:52:37 <dmwit> So, you're making a thunk 1000000 calls deep.  Welcome to stack overflow.
22:53:10 <dmwit> But the method you use for sumList is... really strange.
22:53:49 <dmwit> I would expect something like...
22:54:05 <Yrogirg> it's just straight implementation of the way used for summing numbers
22:56:03 <dmwit> sumList i list = take 5 . zipWith ((sum .) . (:)) list . chunk i . randoms . mkStdGen $ 0
22:56:45 <dmwit> :t (sum .) . (:) -- did I get that one right?
22:56:47 <lambdabot> forall a. (Num a) => a -> [a] -> a
22:58:48 <Yrogirg> What is the module for chunk?
22:59:06 <dmwit> Data.List.Split
22:59:11 <dmwit> hackage package "split"
22:59:14 <dmwit> ?hackage split
22:59:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
23:11:58 <ManateeLazyCat> @let concatM = liftM (++)
23:12:00 <lambdabot>  Defined.
23:12:31 <ManateeLazyCat> :t concatM
23:12:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a] -> m ([a] -> [a])
23:12:40 <leo_> @ty mconcat
23:12:41 <lambdabot> forall a. (Monoid a) => [a] -> a
23:13:40 <ManateeLazyCat> > mconcat [1..10]
23:13:41 <lambdabot>   Add a type signature
23:13:55 <dmwit> > mconcat [1..10] :: Sum Int
23:13:56 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
23:13:57 <lambdabot>    arising fr...
23:15:55 <ManateeLazyCat> > mconcat (return [1..10])
23:15:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:18:58 <ManateeLazyCat> > mconcat $ mapM (return . succ) [1..10]
23:19:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
23:31:18 <Saizan> ?type liftM2 (++)
23:31:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
23:33:20 <blueonyx> > mapM (return . succ) [1..10]
23:33:21 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
23:33:21 <lambdabot>    arising from a use of `M64980605...
23:40:27 <elbar> ?hoogle mconcat
23:40:28 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
23:40:43 <elbar> ?type mconcat $ return []
23:40:44 <lambdabot> forall a. [a]
23:53:18 <leo_> > mconcat $ [1..10] >>= return  .  Sum
23:53:20 <lambdabot>   Sum {getSum = 55}
23:57:52 <Axman6> > [1..10] >>= return  .  Sum
23:57:53 <lambdabot>   [Sum {getSum = 1},Sum {getSum = 2},Sum {getSum = 3},Sum {getSum = 4},Sum {g...
23:59:46 <Axman6> @src Sum (>>=)
23:59:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
