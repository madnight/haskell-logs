00:13:54 <zeno__> when building the haskell platfrom or network or tons of other stuff I get exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found.  i have ONLY ghc-6.10.4 installed and hsc2hs is installed too!!!!
00:20:01 <Cale> zeno__: What steps are you taking to install it?
00:20:03 <SubStack> go go gadget cabal upgrade
00:34:21 <MorkBork> can anyone answer a simple question for me? im reading http://www.haskell.org/~pairwise/intro/section1.html and the author states "There is also a reason that the first example used ':=' and the second example used '='."
00:34:32 <MorkBork> whats the signficance of the :=?
00:34:49 <harlekin> MorkBork, := does not exist in Haskell.
00:34:59 <MorkBork> i didnt think it existed in C either
00:35:02 <MorkBork> thats what confuses me
00:35:11 <harlekin> It probably should just denote that its an imperative language.
00:35:17 <MorkBork> ahh
00:35:21 <harlekin> Delphi for instances uses := to assign things. := is used in Mathematics, too.
00:35:26 <MorkBork> i thought i was missing something thats all
00:35:37 <MorkBork> i couldnt move to the next chapter without getting that off my chest
00:35:37 <MorkBork> hah
00:35:45 <Saizan> it's explained in the rest of the paragraph
00:35:59 <MorkBork> well i understand the lesson
00:36:16 <MorkBork> i just didnt understand that syntax he used in the first snippet
00:36:36 <MorkBork> it seems that its irrelevant really, i thought i was supposed to see some significance to it compared to C
00:37:23 <MorkBork> i have a feeling my head is going to explode
00:37:31 <copumpkin> that's pretty common in here :)
00:38:09 <Saizan> MorkBork: it's to stress that "=" in haskell really means equal, rather than assignment
00:38:45 <Saizan> and ":=" is used by some imperative languages to mean assignment
00:39:11 <MorkBork> im not trying to become a haskell master, or even be able to use it
00:39:16 <MorkBork> just trying to understand it incase i come across it
00:39:20 <Axman6_> like Ada
00:39:26 <copumpkin> let's hope you get drawn in like the rest of us
00:39:27 <MorkBork> since im seeing the most random things written in haskell these days
00:39:29 <copumpkin> and can't let go :P
00:39:48 <copumpkin> I mean, get away while you still can!
00:39:52 <copumpkin> it's a bottomless pit!!
00:40:02 <MorkBork> yea next thing you know
00:40:06 <MorkBork> ill be washing the dishes before dinner
00:40:07 <harlekin> Yeah. Started to learn Haskell just to configure xmonad...
00:40:18 <MorkBork> putting the pan in the oven without the cake mix
00:40:28 <MorkBork> eating the eggs then putting a hair dryer on my tummy
00:40:42 <copumpkin> MorkBork: I made the mistake of looking over my girlfriend's shoulder when she was taking a haskell course, and now I do nothing but haskell
00:41:14 <cjs> MorkBork: Heck, even the compiler's head explodes from time to time.
00:41:18 <MorkBork> the most interesting thing about it is how different it is from every other language i know
00:41:28 <copumpkin> @ghc
00:41:29 <lambdabot> ghc says: scavenge_stack: weird activation record found on stack
00:41:46 <MorkBork> yea i dont actually have any haskell tools installed yet
00:41:51 <copumpkin> :)
00:42:01 <copumpkin> MorkBork: our bot can even write your code for you!
00:42:18 <copumpkin> just tell it what type you want, and it'll write the code ;)
00:42:40 <copumpkin> @djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:42:41 <lambdabot> f a b (c, d) = (a c, b d)
00:43:07 <dibblego> @type bimap
00:43:08 <MorkBork> i think you can really screw yourself with haskell
00:43:09 <lambdabot> Not in scope: `bimap'
00:43:10 <MorkBork> the more i read
00:43:14 <copumpkin> type ***
00:43:17 <Saizan> a variation on <.> that doesn't look too much like an smiley? i.e. not >.< >.> or <.<
00:43:25 <MorkBork> you can make operators like <&&&&&&&&&&>
00:43:26 <cjs> MorkBork: In what sense?
00:43:30 <cjs> Oh, that's fun!
00:43:35 <MorkBork> hah
00:43:43 <copumpkin> MorkBork: sure, but people still want readable code, msot of the time, like in other languages :)
00:43:43 <MorkBork> i found some guys blog where he kept a list of his favorites
00:43:54 <cjs> Actually, I've written  ### and #### for formatting numbers; the former does an Int and the latter does an Integer.
00:43:59 <MorkBork> yea i realize everyone who writes perl doesnt do it all in 1 line
00:44:04 <MorkBork> its just fun sometimes
00:44:08 <copumpkin> oh definitely
00:44:18 <copumpkin> we'll spend hours in here playing with lambdabot golfing code down
00:44:46 <MorkBork> see ive always thought of it as a math language
00:44:48 <Axman6> MorkBork: the thing is, random looking things like &&& and *** are actually rather well used, and naming functions like that is fairly rare
00:45:01 <MorkBork> but now im seeing the weirdest tools being written in it
00:45:05 <Axman6> MorkBork: all languages are maths languages. they just don't know it
00:45:13 <MorkBork> like himerge for gentoo
00:45:25 <copumpkin> it's a math language in the broadest possible sense of math (the one that most people don't use)
00:46:20 <zeno__> Cale: its when i try to build just about any haskell package.  i have this problem with either 6.8.2 or 6.10.4
00:46:34 <zeno__> the problem -> when building the haskell platfrom or network or tons of other stuff I get exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found.  i have ONLY ghc-6.10.4 installed and hsc2hs is installed too!!!!
00:46:44 <Saizan> zeno__: can you paste a complete log of what you're doing?
00:46:50 <Saizan> zeno__: also, cabal --version
00:47:09 <zeno__> Saizan: cant build a cabal dependency
00:47:32 <Saizan> zeno__: ok, so you're using runghc Setup ?
00:47:33 <zeno__> hold on will pastebin
00:49:45 <zeno__> Saizan: Cale
00:49:54 <zeno__> http://pastebin.ca/1542894
00:51:41 <Saizan> zeno__: can you paste "cat /usr/local/bin/hsc2hs" too?
00:53:08 <Saizan> i suspect that it's still the old one
00:53:27 <zeno__> Saizan: ah heres the problem not sure how to fix : exec /usr/local/lib/ghc-6.10.1/hsc2hs $tflag $HSC2HS_EXTRA ${1+"$@"}
00:53:50 <Saizan> zeno__: do you have an hsc2hs in /usr/bin/ too?
00:54:06 <zeno__> http://pastebin.ca/1542900
00:54:44 <zeno__> Saizan: yes and that one uses the correct version
00:54:59 <Saizan> zeno__: rm /usr/local/bin/hsc2hs, then
00:55:57 <zeno__> Saizan: did.  now i get Setup: Cannot find the program 'hsc2hs' at '/usr/local/bin/hsc2hs' or on the though.  should i cp /usr/bin/hsc2hs /usr/local/bin/hsc2hs?
00:56:24 <zeno__> or on the path was the finish to that error
00:56:24 <Saizan> zeno__: no, i think you should "make clean" and restart
00:56:55 <zeno__> Saizan: my computer or the ./configure build process?
00:58:15 <Saizan> zeno__: the latter
01:02:28 <fynn> hey, who is this guy?
01:02:29 <fynn> http://muaddibspace.blogspot.com/
01:02:44 <fynn> this blog is pretty win.
01:03:10 <mux> yeah, it's mostly Agda though, isn't it?
01:03:34 <Saizan> and Coq
01:04:18 <Saizan> fynn: the nick is soupdragon, lately
01:05:02 <fynn> Saizan: yeah, just curious whether he has written some fuller texts
01:05:05 <fynn> e.g. books etc.
01:05:39 <dolio> copumpkin: The java thread is up to 1455 comments. You'd better get reading.
01:05:58 <Saizan> which java thread?
01:06:12 <dolio> "Why does everyone hate Java" on reddit.
01:07:03 <Saizan> ugh
01:07:11 <Saizan> anything interesting in there?
01:07:18 <quicksilver> goes back to Prince Diponegoro in the 19th century, I believe
01:07:35 <quicksilver> although I think most modern historians think those wounds are almost healed now.
01:07:38 <dolio> I don't know. I try not to read the programming reddit.
01:07:48 <dolio> But copumpkin claimed to earlier.
01:07:57 <dolio> And slashdot. And hacker news.
01:11:57 <fynn> quicksilver: hehe
01:21:43 <stanv> how to write multiply comments {: ?
01:22:49 <blackh> {- multi-line comments -}
01:25:18 <quicksilver> although with editor support I have a tendency to use the -- style even for multi-line
01:25:21 <quicksilver> I think it looks nicer :)
01:28:39 <bastl> hello could someone help with this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3422#a3422
01:29:24 <etpace_> What are the "primatives" of Haskell? as I've seen you can pretty much everything in terms of something else, but what about the few things you can't? is it only function application?
01:29:32 <bastl> ghc says the parse function is ambiguous, and i should add the signature at the parse function
01:29:40 <bastl> how can I ?
01:31:21 <quicksilver> etpace_: function application, let, case.
01:31:33 <quicksilver> bastl: ::
01:32:03 <quicksilver> etpace_: data definitions
01:32:30 <etpace_> where does pattern matching fit in
01:32:32 <bastl> yeah, but i have to fix a type variable ... you mean (parse s)::(Parseable a) ?? But that looks like java agaibn
01:32:45 <quicksilver> bastl: it might be something like that.
01:32:48 <quicksilver> I can't guess
01:32:52 <quicksilver> without seeing your code
01:33:06 <quicksilver> the answer will be (something :: ANiceTypeForSomething)
01:33:22 <bastl> see the paste above ...
01:33:38 <bastl> and the highlighted line
01:34:02 <doserj> bastl: parse s :: Either SomeNiceType ParseError
01:34:15 <quicksilver> hmm I didn't see the paste :)
01:34:28 <doserj> etpace_: pattern matching is case
01:34:40 <bastl> but SomeNiceTZype is just an "a" which should be in a specific typeclass
01:34:49 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3422#a3422
01:35:14 <quicksilver> you can't right that function.
01:35:16 <quicksilver> write.
01:35:23 <quicksilver> because the compiler needs to know what 'a' is.
01:35:34 <quicksilver> but the signature of buildTree contains nothing to fasten onto.
01:35:55 <quicksilver> you'd need to add a phantom parameter to buildTree to fix the type.
01:36:00 <quicksilver> so it knows what to parse as.
01:36:16 <bastl> ah, that sounds reasonable ...
01:37:53 <bastl> then I would write (parse s)::MyPhantomType ?
01:38:15 <bastl> (never did that)
01:38:33 <quicksilver> parse s :: (Either myphantomtype ParseError)
01:38:46 <bastl> of course
01:39:03 <quicksilver> or could annotate (ast :: myphantomtype) instead if you liked
01:39:22 <quicksilver> only need to fix the type in one place for the compiler to know what's going on
01:39:24 <pr> hi
01:40:14 <Saizan> unless bastl wants "parse" to decide the type for him
01:40:35 <quicksilver> pretty sure he doesn't.
01:40:42 <quicksilver> parse is supposed to be polymorphich in its return type
01:41:01 <bastl> Hmm, i never understood typeinference in depth ... I want to add more instances of Parseable later ....
01:41:11 <quicksilver> bastl: FYI, the problem occurs because you have two functons, one polymorphic in return type (parse) and one polymorphic in what it accepts (data2tree)
01:41:21 <quicksilver> bastl: and there is nothing to fix the 'type in the middle'
01:41:30 <bastl> ok
01:41:31 <quicksilver> you get exactly the same problem if you write "show . read"
01:41:39 <quicksilver> > show . read $ "1234"
01:41:41 <lambdabot>   "* Exception: Prelude.read: no parse
01:41:52 <Saizan> extended defaulting :)
01:41:53 <quicksilver> ^^ well, lambdabot is broken and defaults the type to ()
01:42:01 <quicksilver> that should be an ambiguity error like the one you gave.
01:42:28 <quicksilver> is there any advantage to having extended defaulting on in LB?
01:43:26 <bastl> So I could split the function in two, and fix the types explicitly ?
01:44:03 <Saizan> bastl: you can just give a type annotation to ast
01:44:32 <Saizan> but yeah, you could do that too
01:45:07 <bastl> but i only know that ast is in the Data type-class
01:45:18 <quicksilver> you must know more than that.
01:45:22 <Saizan> but i've the feeling that you want buildTree to be able to cope with any instance of Parseable that String will happen to contain
01:45:27 <bastl> yep
01:45:35 <quicksilver> if you want that you have to write the code yourself
01:45:48 <quicksilver> you have to either (a) write code which examines the string and works out which instance of parse to use
01:45:59 <quicksilver> or (b) write code which just tries all the possibilities one by one until one works
01:46:03 <quicksilver> the compiler can't do that for you.
01:48:35 <bastl> im confused now
01:49:39 <chrisbrown> bastl: do you understand why the compiler can't work out which version of parse to use in buildTree?
01:49:47 <Saizan> i.e. you won't get Java's Serialize for free :)
01:50:06 <etpace_> :t (>=>)
01:50:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:50:09 <quicksilver> bastl: all you want to give it is a string
01:50:29 <quicksilver> bastl: how do you expect to know whether to parse it as an HsModule or a Program ?
01:50:39 <bastl> its the same as read "123"::Int
01:50:44 <bastl> right ?
01:50:48 <quicksilver> bastl: (...or any other instance of Parseable)
01:50:55 <bastl> i see that
01:50:56 <quicksilver> exactl.
01:50:58 <fasta> The more complicated loops I write, the more I think that using runStateT for all of them is a good idea from a maintenance point of view. Does anybody else think differently?
01:51:20 <chrisbrown> bastl: so you need to help the compiler here
01:51:42 <bastl> i see that.
01:52:01 <Saizan> fasta: can you elaborate?
01:52:01 <chrisbrown> you need to either: scrutinize the string in buildTree and from that which version of parse to call, or try every version, until one suceeds
01:52:26 <quicksilver> or allow the caller to choose
01:52:31 <quicksilver> (by adding a phantom parameter)
01:52:35 <bastl> What I want is: Parser-Builders implement "my" Typeclass, and myprogram will work for for their language.
01:52:51 <chrisbrown> adding the phatom param might be the easiest option in this case
01:53:08 <bastl> quicksilver: how would htat looklike for the read example?
01:53:15 <etpace_> :t (>>>)
01:53:17 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
01:53:33 <fasta> Saizan: it seems that over time, the number of arguments to the traditional loop or go function only increases. Passing all those parameters all the time inflates the source code by having to repeat those names all the time. Especially, when the function uses non-trivial structural recursion.
01:55:12 <fasta> Which brings us to the point of using Haskell in the first place. If 90% of loops becomes "complicated" to warrant the use of StateT, why not introduce syntax for loops? At that point you basically have an imperative language.
01:55:14 <Saizan> fasta: ah, i don't write that many and that large explicit loops
01:56:35 <etpace_> (+1) >>> (*2) $ 5
01:56:37 <fasta> Saizan: recursion patterns are all slightly different. In case it is possible to do stuff lazily, explicit loops are not needed as much.
01:56:42 <etpace_> > (+1) >>> (*2) $ 5
01:56:50 <lambdabot>   12
01:57:01 <etpace_> > (+1) <<< (*2) $ 5
01:57:08 <lambdabot>   11
01:58:51 <bastl> where can I find an example for a function using Phantom Types ?
01:59:47 <fasta> data Foo a = Bar; zork :: Foo Int -> Bar;zork _ = Bar
02:01:07 <Saizan> bastl: btw, maybe you don't want a typeclass at all, but we'd need to know more about your design
02:01:28 <chrisbrown> bastl: what exactly are you trying to do?
02:01:41 <quicksilver> chrisbrown: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3422#a3422
02:01:51 <chrisbrown> aha!!!
02:01:57 <chrisbrown> oh I see
02:02:10 <quicksilver> bastl: change "buildTree"'s type to Parseable a => String -> a -> Tree String
02:02:13 <chrisbrown> so you are trying to build a generic interface to both the Haskell and the Pascal compiler?
02:02:34 <chrisbrown> I mean parser
02:02:46 <quicksilver> call the second parameter 'dummy'
02:02:48 <bastl> the idea is to let other ppl add their parsers somehow. later and without touching the program
02:02:54 <quicksilver> and then use (ast `asTypeOf` dummy)
02:03:23 <bastl> gonna try that ...
02:03:39 <Saizan> by program you mean a compiled binary?
02:03:59 <Saizan> or a library?
02:04:23 <bastl> something I can ship :-)
02:04:48 <bastl> preferably compiled binary, but thats probably not possible
02:04:52 <etpace_> Can anyone give en example of an instance of Arrows that's not -> or Kleisli? I'm not sure I really understand them
02:05:01 <Saizan> well, s/compiled binary/executable/ is what i meant
02:05:09 <chrisbrown> bastl: but won't people still have to edit the code to be able to add their own parsers?
02:05:24 <fasta> Type-classes for domains which are complicated are hard to make complete. In fact, any encoding of a non-trivial domain will sooner or later warrant some kind of extension. A simple example is restricting your type-class to only non-monadic functions.
02:05:31 <bastl> i thought about using hint, to let users register parsers, but im still experimenting with clear design in the first place ...
02:05:33 <Saizan> because if you want an executable you'd need to use the ghc-api to make it load the code of the parser at runtime
02:05:34 <quicksilver> etpace_: there are very few good ones.
02:05:50 <quicksilver> etpace_: swierstra-duponcheel parsers is the only good one I know.
02:06:02 <bastl> chrisbrown: when the runtime can **somehow** infer what to do, it shpuld work
02:06:14 <bastl> the question is how to implement **somehow**
02:06:26 <quicksilver> bastl: typeclasses /= runtime
02:06:38 <quicksilver> typeclasses are for when the *compiler* can infer what to do, at compile time
02:07:36 <bastl> Saizan: exactly: i thought of using hint to load the all instances that are registered as possible parsers
02:08:11 <bastl> (but since im not abled to implement it staticaly by now, the dynamic registering is far away ... ;-) )
02:08:58 <etpace_> > print &&& (print . mapM (+1)) $ [1,2,3]
02:08:59 <lambdabot>   No instance for (GHC.Num.Num (m b))
02:09:00 <lambdabot>    arising from the literal `1' at <int...
02:09:17 <etpace_> > print &&& (print . map (+1)) $ [1,2,3]
02:09:18 <lambdabot>   (<IO ()>,<IO ()>)
02:09:33 <etpace_> :t (&&&)
02:09:34 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:09:36 <Saizan> it seems that you want a record of functions, rather than a typeclass (or an existential, which is in-between)
02:09:43 <etpace_> :t (***)
02:09:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:10:03 <quicksilver> "Typeclasses are not a general abstraction mechanism"
02:17:07 <bastl> quicksilver: where is that quote from ?
02:17:17 <dolio> Himself, probably.
02:19:46 <quicksilver> it wasn't a quotation, it was a motto.
02:19:50 <quicksilver> but yes, it's my motto.
02:20:10 <quicksilver> quicksilver's first rule: if you think the solution to a problem is defining your own typeclass, you're wrong. Think again.
02:20:20 <doserj> I thought it was "type-classes are overrated" :)
02:21:07 <bastl> its one of the hardest things for me coming from java: type-classes feel like interfaces but they are different. but still havent learned how to *design* such things properly in haskell.
02:22:56 <quicksilver> yes, it's best not to think of type-classes as interfaces.
02:23:01 <quicksilver> typeclasses are for overloading.
02:23:06 <quicksilver> Num and Monad are great examples
02:23:11 <quicksilver> Num is to overload (+) and (*).
02:23:13 <etpace_> > let f = left (+1) in (f (Left 5), f (Right 5))
02:23:15 <lambdabot>   (Left 6,Right 5)
02:23:27 <quicksilver> Monad is to overload (>>=) and by extension, 'do' notation and mapM and so on.
02:23:57 <quicksilver> to the extent they're defined by a collection of values (normally functions) they do obviously have a structural similarity to interfaces.
02:23:58 <etpace_> :t (>>=)
02:24:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:24:57 <pozic> Is there a function f g x = foldM (\e -> g e) x [1..] somewhere in the libraries?
02:25:35 <dschoepe> @pl \g x -> foldM g x [1..]
02:25:36 <lambdabot> flip flip [1..] . foldM
02:25:37 <matsuura> what is fold?
02:25:41 <quicksilver> pozic: (\e -> g e) == g ?
02:25:53 <matsuura> :t (<<=)
02:25:54 <lambdabot> Not in scope: `<<='
02:25:56 <matsuura> :(
02:25:58 <quicksilver> :t \g x -> foldM g x [1..]
02:26:00 <lambdabot> forall a b (m :: * -> *). (Num b, Enum b, Monad m) => (a -> b -> m a) -> a -> m a
02:26:01 <pozic> quicksilver: yes, it is. I noticed that later already.
02:26:12 <matsuura> :t (>>=)
02:26:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:26:17 <quicksilver> I'm not sure why that merits a better name than foldM g x [1..]
02:26:26 <quicksilver> "foldM g x [1..]" is alread a pretty short name.
02:26:38 <etpace_> > (Just 5) >>= return . (+1)
02:26:39 <matsuura> what is a fold?
02:26:40 <pozic> quicksilver: yes, but the [1..] is basically a bogus part.
02:26:40 <lambdabot>   Just 6
02:26:53 <etpace_> > Nothing >>= return . (+1)
02:26:55 <lambdabot>   Nothing
02:27:01 <dschoepe> matsuura: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
02:27:05 <pozic> matsuura: fold is what you get when you replace the constructors of the list type by some compatible function.
02:27:23 <pozic> matsuura: for non-list types, folds also exists and they are the generalisation.
02:27:37 <quicksilver> :t foldM
02:27:38 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:27:43 <pozic> matsuura: in mathematics they have fancy names for that, like catamorphisms.
02:27:54 <quicksilver> pozic: how is it bogus? It's the second parameter to 'g'
02:28:07 <quicksilver> pozic: maybe your intention is that g ignores its second parameter?
02:28:18 <pozic> quicksilver: oops, I forgot an argument there.
02:28:23 <pozic> quicksilver: yes, that was the intention.
02:28:26 <quicksilver> maybe you mean \g x -> foldM (\e _ -> g e) [1..]
02:28:31 <matsuura> Thank you guys
02:28:38 <matsuura> I feel more educated now :)
02:28:39 <pozic> quicksilver: yes
02:28:55 <etpace_> What's >>= for the Maybe Monad? join . fmap?
02:29:02 <quicksilver> so, you want to iterate a (a -> m a) until it stops of its own accord?
02:29:18 <pozic> quicksilver: right, I thought for a moment it was mfix, but it isn't.
02:29:38 <etpace_> :t join . fmap :: Maybe
02:29:40 <lambdabot>     `Maybe' is not applied to enough type arguments
02:29:40 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
02:29:40 <lambdabot>     In an expression type signature:
02:29:40 <quicksilver> no, mfix is when you pass (a -> m a) to itself
02:29:47 <etpace_> :t join . fmap
02:29:49 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
02:29:49 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
02:29:49 <lambdabot>     In the second argument of `(.)', namely `fmap'
02:29:50 <quicksilver> you are providing the initial parameter explicitly.
02:30:07 <pozic> quicksilver: right, which would be possible if the initial parameter would be set in the monad.
02:30:08 <quicksilver> this only terminates in 'short-circuit' monads
02:30:29 <quicksilver> no, I don't think there is a name for it :)
02:38:32 <path_> I have this program where I can get it to complete with a very large input in 2 seconds when I wrote it in ruby and 30 seconds when in Haskell. I cant figure out what I've done wrong :/
02:41:51 <quicksilver> using String, probably
02:44:16 <fasta> path_: I will have a look in my crystal ball.
02:46:35 <fasta> path_: paste the Ruby code, paste the Haskell code and we can take a look.
02:47:32 <path_> ok will do. Ill paste the haskell code first,. Need to get the ruby code onto this machine
02:47:43 <MyCatVerbs> etpace_: (\m f -> join (fmap f m)) is (>>=) for the Maybe monad, yes.
02:48:01 <MyCatVerbs> etpace_: coincidentally enough, it happens to be (>>=) for every other monad, too. :)
02:48:18 <path_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3423#a3423
02:48:40 <hackagebot> bytestringparser-temporary 0.4.0 - Combinator parsing with Data.ByteString.Lazy (JasonDusek)
02:48:53 <quicksilver> MyCatVerbs: freaky. Can that really be a coincidence? :)
02:50:24 <MyCatVerbs> etpace_: congratulations on rediscovering the punchline of what is IMO the best of the "monad tutorials". =)
02:50:37 <quicksilver> path_: hmm. first glance that code looks OK
02:50:45 <quicksilver> path_: you did compile with optimisations I hope?
02:51:42 <path_> yeah O2
02:51:52 <path_> Im wondering if I should try profiling it
02:51:57 <path_> but Im wondering how
02:52:09 <path_> but wow running via ghc is 10x slower
02:52:11 <path_> err
02:52:12 <path_> ghci
02:52:40 <quicksilver> yes.
02:52:40 <path_> its only 5 seconds, but still slower than ruby. I expected it to be like 10x faster than ruby
02:52:56 <quicksilver> ah, 5 seconds not 30 now?
02:53:01 <quicksilver> so you weren'te compiling before?
02:53:01 <path_> yeah
02:53:03 <path_> yeah
02:53:17 <fasta> path_: you should profile it. If it is a flat profile, it would be a good compiler test case.
02:53:37 <path_> but it still fails the test (Im submitting it to an online site that has a cutoff time)
02:53:43 <fasta> path_: but I doubt you are using the same algorithm as you use in Ruby, since these results are pretty much impossible then.
02:53:49 <path_> most of the submissions that passed are in C/C++
02:53:54 <quicksilver> as a starting point, run it as +RTS -sstderr
02:54:07 <path_> it is the same algorithm to me, but the thing is I might be using the wrong data structures
02:54:07 <quicksilver> that will tell if you if time is spent working (MUT) or in garbage colleciton (GC)
02:54:25 <path_> quicksilver:  is that a compiler option? or via ghci
02:54:27 <fasta> Ruby has a lot more indirections than Haskell, so it should always be possible to get the Haskell version faster.
02:54:42 <quicksilver> path_: it's a runtime option
02:54:46 <quicksilver> to your compiled app
02:54:52 <path_> oh ok
02:54:52 <quicksilver> ./mytest +RTS -sstderr
02:55:23 <path_> 3.79S MUT
02:55:33 <path_> 4.85 total
02:55:38 <quicksilver> OK, that's not too stupid.
02:55:59 <path_> yeah lol, atleast I guess the data strcuture isnt bad
02:56:13 <etpace_> What would app be for Arrowapply (Kleisli m)? app (f, x) = runKleisli f x? app seems quite an.. simple function
02:56:20 <path_> my time with ruby is 2.39 seconds
02:56:45 <quicksilver> yeah I think you will have to profile path_
02:56:53 <path_> fasta : also ruby is pretty slow in general, so Im quite suprised
02:57:04 <path_> quicksilver: is there a how to on profiling with ghc?
02:57:26 <fasta> path_: the manual is quite good. I recommend just trying all options if you are a new user, to see what is possible.
02:57:29 <path_> hmm I should ask the people on the site what compiler flags they use. Besides they use 6.6.1 :/
02:57:38 <path_> ok
02:57:47 <quicksilver> you don't seem to be making the really obvious mistakes.
02:57:57 <bastl> hmmm, I get linker errors. "unknown symbol". I simply installed a cabal-package i did myself. how can linker errors appear (in ghci) ???
02:58:01 <quicksilver> You're heavily using an immutable array, which is nice and fast.
02:58:06 <quicksilver> You're using IntMap which is also very fast.
02:58:17 <quicksilver> I don't see any stupid uses of !! or suchlike
02:58:54 <fasta> If Ruby is faster on this problem than Haskell, I guess I will have to switch language ;)
02:59:22 <fasta> But I still haven't seen the Ruby code.
02:59:22 <mux> this just can't be :-)
02:59:35 <mux> there must be improvements to be made on the haskell version
02:59:42 <path_> -prof  -auto_all ?
02:59:44 <Axman6> fasta: what program?
02:59:59 <fasta> Axman6: the one path_ is talking about.
03:00:07 <path_> ok let me get a usb drive to post the usb code. Just so people can test it for themselves :)
03:00:09 <path_> err
03:00:11 <path_> the ruby code
03:01:03 <etpace_> I remember when I first looked at haskell and asked why you dont just overload + to append lists (like python) and was told overloading isnt very good -- but going through all these typeclasses that are made for overloading, what's the difference? I usually hear of overloading as a negative point, is it because there are `laws' so that while functions are overloaded, they should still work as expected?
03:01:53 <Baughn> etpace_: Pretty much. Each function embodies one concept or another; for +, it's addition, which is among other things supposed to be commutative.
03:02:30 <Baughn> etpace_: Concatenating strings is not commutative. The appropriate typeclass for that would be Monoid.
03:02:48 <Baughn> (And except for hysterical raisins, ++ would be mconcat)
03:03:09 <etpace_> i thought you could commute applicatives?
03:03:16 <doserj> mappend, not mconcat
03:03:33 <Baughn> etpace_: That's beside the point
03:04:02 <etpace_> i guess it is
03:04:31 <Saizan> bastl: maybe you forgot to fill the other-modules field?
03:04:55 <Baughn> etpace_: Think about fmap. It does different things on different types, but when you see it, you always have a pretty good idea what it does without looking up the implementation.
03:05:05 <Baughn> etpace_: Overloading + to concatenate strings would /not/ do that.
03:05:22 <bastl> Saizan: thanks, i think that's it
03:06:26 <etpace_> is there anything stopping somebody implementing a `bad' fmap? the laws are not actually restricted by the compiler right?
03:06:41 <Baughn> Correct. They could.
03:07:03 <Baughn> But if they do, we'll send a specially trained squadron of ninja bats to suck out their blood.
03:07:14 <etpace_> heh
03:07:44 <int-e> Won't that taint our image of having a friendly and open community?
03:07:59 <fasta> int-e: it's an underground operation.
03:08:01 <Baughn> No, they're /ninja/ bats. There's no way to trace them back to us.
03:08:27 <int-e> until one of them goes rogue and sells out to the enemy.
03:08:41 <Baughn> They wouldn't. I've got their dirt.
03:08:57 <quicksilver> Baughn: 'guano' it's called
03:08:58 <int-e> Guana? Do you sell it?
03:09:01 <int-e> oh
03:09:11 <Baughn> quicksilver: I was thinking of the grave dirt
03:09:25 <quicksilver> int-e: guana's an island in the virgin islands
03:10:30 <Saizan> don't confuse it with java
03:10:34 <Baughn> Well, I've got that dirt too!
03:10:51 <Baughn> ..how did this devolve into a discussion of bat feces, anyway?
03:11:17 <int-e> I blame you and your ninjas.
03:11:32 <int-e> I tried to tell you it was a bad idea ;)
03:12:25 <Baughn> We need /some/ way to enforce the monad laws. ;_;
03:12:32 <Baughn> Maybe we could lobby congress
03:16:47 <hackagebot> hsmtpclient 1.0 - Simple SMTP Client (MassimoZaniboni)
03:42:39 <zeno__> found a bug in ghc http://pastebin.ca/1543015
03:42:49 <zeno__> ghc: panic! (the 'impossible' happened) lol
03:43:04 <paper_cc> @quote ghc
03:43:04 <lambdabot> ghc says: absApply: Duff function
03:43:46 <Twey> > chr $ negate 1
03:43:48 <lambdabot>   * Exception: Prelude.chr: bad argument
03:45:55 <zeno__> not finding any fixes via google
03:46:02 <fasta> zero__: isn't that just a miscompiled GHC?
03:46:13 <fasta> zeno__: *
03:46:16 <zeno__> fasta: i installed ghc from the package manager..
03:46:27 <zeno__> fasta: other stuff compile
03:46:28 <zeno__> s
03:46:47 <fasta> zeno__: other people can make mistakes too.
03:47:02 <zeno__> fasta: ok.  so what would you do in this situation?
03:47:19 <fasta> zeno__: I had a similar issue when I compiled GHC from darcs. The problem was some remaining .hi file.
03:47:45 <fasta> zeno__: I would try to see whether the darcs version of GHC has the same problem.
03:47:58 <fasta> zeno__: if it does, report a bug.
03:48:34 <zeno__> ok.  in the meantime how do i compile libraries with profiling enabled?
03:49:05 <zeno__> which do i change, configure or build
03:49:27 <nlogax> what would be a nice way to find "gaps" in a list? if i have [1,2,3,5,6,8] and would like to get [4,7] for example
03:49:46 <fasta> zeno__: with a cabal package it is --enable-profiling
03:50:14 <zeno__> thanks! on build or configure?
03:50:21 <quicksilver> > [1..8] // [1,2,3,5,6,8]
03:50:22 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
03:50:26 <quicksilver> > [1..8] \\ [1,2,3,5,6,8]
03:50:28 <lambdabot>   [4,7]
03:50:28 <fasta> nlogax: difference <your list> [1..]
03:50:36 <fasta> nlogax: also a very slow way
03:50:40 <quicksilver> nlogax: that works although it's not precisely what you asked for
03:50:55 <quicksilver> it doesn't take advantage of the fact that it's sorted, so it's O(n^2) not O(n)
03:50:59 <zeno__> getting unrecognized option on both
03:51:21 <fasta> That infinite list thing is not going to work, btw.
03:51:27 <fasta> But something very similar would.
03:51:29 <nlogax> thanks quicksilver and fasta, \\ was the function i couldn't remember :)
03:52:08 <Pistahh> > 2+3
03:52:09 <lambdabot>   5
03:52:13 <fasta> nlogax: please don't put that line into an actual application :)
03:52:33 <nlogax> fasta: i won't :)
04:01:09 <iabal> @src show
04:01:10 <lambdabot> show x = shows x ""
04:01:16 <iabal> @src shows
04:01:17 <lambdabot> Source not found.
04:04:39 <Axman6> @src Show
04:04:39 <lambdabot> class  Show a  where
04:04:40 <lambdabot>     showsPrec :: Int -> a -> ShowS
04:04:40 <lambdabot>     show      :: a   -> String
04:04:40 <lambdabot>     showList  :: [a] -> ShowS
04:04:46 <Axman6> hmm
04:09:57 <lilac> it would be good to have library with union, intersection, difference, symmetric difference, etc. for sorted lists on hackage.
04:10:06 <lilac> i certainly find i use them quite a lot
04:10:53 <zeno__> http://hackage.haskell.org/trac/ghc/ticket/3463#preview
04:16:48 <etpace_> > let foo xss = snd $ foldl (\(c, xs) x -> if c /= x then (x+1, [c..(x-1)] ++ xs) else (x+1, xs)) (head xss, []) in foo [1,2,3,5,6,8]
04:16:50 <lambdabot>   Couldn't match expected type `(a, b)'
04:17:03 <zeno__> @hoogle bracket
04:17:04 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
04:17:04 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
04:17:04 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
04:17:11 <etpace_> > snd $ foldl (\(c, xs) x -> if c /= x then (x+1, [c..(x-1)] ++ xs) else (x+1, xs)) (1, []) [1,2,3,5,6,8]
04:17:12 <lambdabot>   [7,4]
04:17:12 <sinelaw> can anyone explain how victim cache's improve performance?
04:17:20 <sinelaw> *caches
04:17:33 <etpace_> any tips on tidying that up? I guess a state monad or something?
04:17:40 <Axman6> victime caches?
04:18:22 <Axman6> -e
04:19:02 <voker57> is it possible to compile cabal-install on 256 mb of RAM? Doing so leads me to lockup
04:19:36 <sinelaw> Axman6, it's a mechanism that stores a small number of discarded cache lines
04:22:14 <Saizan> voker57: it's the linking phase that goes out of memory?
04:22:24 <voker57> Saizan: yes
04:22:33 <Saizan> voker57: you could try with the gold linker, it should use less memory
04:22:36 <zeno__> trying to use the code at http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot but when i try it it gives `Exception b' arising from a use of `catch' at Irc.hs:29:17-61.  im not sure what type to assign it though
04:22:42 <sinelaw> and a different, very basic thing i fail to understand: how does having cache blocks increase performance vs. bus-sized fetches only? if the cache needs to fetch a ton of data on a miss, how is that different than many separate small misses?
04:23:09 <Saizan> voker57: and/or recompile ghc disabling split objects
04:23:26 <zeno__> the bad line is loop st    = catch (runReaderT run st) (const $ return ())
04:23:54 <Saizan> zeno__: catch (runReaderT run st) (\(SomeException _) -> return ())
04:24:15 <zeno__> Saizan: ah, thanks
04:24:58 <zeno__> Saizan: is that the monomorphism restriction?
04:26:24 <Saizan> zeno__: no, in this case you've to pick a concrete type there for the code to make sense, because the variable won't appear in the type of the expression
04:26:59 <doserj> zeno__: it's a change in the Control.Exception API from base-3 to base-4
04:28:50 <mun> i have a basic question: what does the : mean in Just (libItem' : libItems', dg1', libenv1', newLG)?
04:29:35 <Saizan> (x:xs) is a list with first element x and xs as the rest of it
04:29:42 <Saizan> > 1 : [2,3]
04:29:44 <lambdabot>   [1,2,3]
04:29:55 <mun> ooh!
04:29:56 <mun> thanks
04:30:16 <Axman6> @src []
04:30:16 <lambdabot> data [] a = [] | a : [a]
04:30:55 <Axman6> ^^^^ says: a list is either an empty list ([]) or an a cons'd on the front of a list of a's (a : [a])
04:32:16 <mun> Axman6, thanks
04:33:12 <mun> so for the function at http://haskell.pastebin.com/m64b5b7b2 how do i print out the value libenv1' takes on line 29? where can i add a print statement?
04:42:16 <path_> if anyone is still around, regarding the ruby vs haskell thing
04:42:17 <path_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424
04:42:28 <path_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425
04:43:04 <path_> the haskell code is the same as far as I can see and is slower. Just maybe slightly faster when compiled with O2. Shouldnt it be a lot faster?
04:46:38 <Guest75475> a (probably) stupid and FAQ....: Why does GHCI not accept a function def like this : fac 0 = 1
04:46:51 <Guest75475> it gives me this error - :1:6: parse error on input `='
04:47:07 <int-e> Guest75475: ghci mimics a 'do' block - try  let fac 0 = 1; fac n = fac (n-1) * n
04:47:37 <int-e> Guest75475: or put the definition into a goo.hs file and load it using :load foo.hs
04:47:38 <bastl> Saizan, quicksilver: Wanna look at my TestInterpreter to load Parsers at Runtime ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3426#a3426 Phantom-Types work quite well until now.
04:48:18 <Guest75475> int-e: got it. thanks.
04:48:55 <quicksilver> nice
04:49:14 <bastl> but doesnt work :-)
04:49:46 <bastl> THe Interpreter says "NotAllowed "These modules are not interpreted:\nParserRegistration\n""
04:50:13 <bastl> anyone used hint ?
04:57:07 <int-e> bastl: mueval does, so lambdabot does, and we use that all the time. does that count?
04:58:07 <bastl> if someone of these can explain the error mesg, yes.
04:58:39 <bastl> it depends on our understanding of "use".
04:58:47 <kbp> could anyone please  type the symbol <=> and =>  on here so I can copy & paste to the word document ? thank you very much. I cant find them from the symbol table (MSWord 2007)
05:01:31 <int-e> @google unicode arrows
05:01:32 <lambdabot> http://www.alanwood.net/unicode/arrows.html
05:01:32 <lambdabot> Title: Arrows – Test for Unicode support in Web browsers
05:02:16 <kbp> thank you int-e
05:09:36 <mun> so for the function at http://haskell.pastebin.com/m64b5b7b2 how do i print out the value libenv1' takes on line 29? where can i add a print statement?
05:12:35 <etpace_> iirc there is a trace function
05:12:42 <etpace_> @hoogle trace
05:12:42 <lambdabot> Debug.Trace trace :: String -> a -> a
05:12:42 <lambdabot> module Debug.Trace
05:12:42 <lambdabot> package traced
05:12:59 <Baughn> @src trace
05:12:59 <lambdabot> trace string expr = unsafePerformIO $ do
05:12:59 <lambdabot>     hPutStrLn stderr string
05:12:59 <lambdabot>     return expr
05:13:26 <ray> @botsnack
05:13:26 <lunabot>  :)
05:13:27 <lambdabot> :)
05:13:29 <blackh> mun: e.g. Just (libItem', dg1', libenv1') -> trace ("libenv1'="++show libenv1') $ Just (libItem' : libItems', dg1', libenv1', newLG)
05:13:48 <mun> aah
05:13:49 <mun> thanks
05:13:53 <int-e> mun: for debugging purposes, you can use Debug.Trace (trace or traceShow). If the value should be printed in the final version, either print it from the following code or turn mRes into an IO action.
05:14:03 <ray> "i'm doing something cool" `trace` somethingCool
05:14:25 <etpace_> what does unsafePreformIO do? do IO without having an IO type?
05:14:34 <ray> yes
05:14:36 <blackh> For trace, you've got to make sure it gets evaluated, so you would typically put it first.
05:14:36 <ray> hence unsafe
05:14:56 <etpace_> @src unsafePreformIO
05:14:57 <lambdabot> Source not found. Do you think like you type?
05:15:02 <mun> why does trace take in two arguments?
05:15:30 <etpace_> the string to print and the function to execute afterwards
05:15:35 <Axman6> you can define: debug x = trace (show x) x if you like
05:15:40 <dschoepe> or rahter the value to return
05:15:43 <mun> ah okay
05:16:15 <blackh> etpace_: unsafePerformIO is normally used when you want to import a foreign function that you know has no side effects.
05:16:44 <Baughn> Or when you want to extend the runtime..
05:17:00 <Baughn> unsafePerformIO allows you to run arbitrary code when some thunk is dethunked
05:17:02 <int-e> or when you want to crash your program :)
05:17:10 <Baughn> (Unfortunately, this use is not very well documented)
05:17:29 <mun> does Debug come in the default installation?
05:17:29 <Baughn> int-e: Hey! That was a GHC bug..s! :P
05:17:51 <Baughn> Anyhow, unsafePerformIO should not be capable of causing actual crashes
05:18:16 <int-e> well, you /can/ implement unsafeCoerce with unsafePerformIO.
05:18:27 <Baughn> Only due to a hole in the type system
05:18:32 <roconnor> int-e: in GHC
05:18:51 <mun> oh nevermind :)
05:18:52 <roconnor> int-e: it doesn't work in yhc IIRC
05:18:57 <eevar2> http://pastebin.com/d70c56c89 -- any obvious issue with how I'm using parMap? I'd expect this to scale linearly, but going from one to two cores only lowers the runtime from 30 to 20 sec
05:19:16 <ray> ghc already has unsafeCoerce though
05:19:45 <mun> how do you pipe the output from trace to a file?
05:19:57 <ray> 2>file
05:20:14 <dcoutts> Baughn: the "hole in the type system" is unsafePerformIO
05:20:29 <mun> ray, thanks
05:20:36 <blackh> mun: If you want to do that, you can write your own version of trace.  Take a look at the source for trace.
05:20:41 <dcoutts> Baughn: I don't see why you think it should be safe and incapable of causing segfaults
05:21:05 <ray> blackh: stderr is a different file descriptor for exactly this reason :)
05:21:29 <mun> what if i don't want a function to execute after calling trace? what should i give as the second argument?
05:21:32 <nominolo> dcoutts: I guess ignoring memory corruption
05:21:35 <Baughn> dcoutts: Arguably, you're right
05:21:45 <blackh> mun: Every expression has to return something.
05:22:14 <Baughn> My claim was supposed to be that IO code which would not cause a crash outside unsafePerformIO, would not suddenly cause one when executed inside it
05:22:18 <nominolo> dcoutts: every ffi function can cause crashes
05:22:20 <roconnor> dcoutts: isn't the hole in the type system the fact that polymorphic functions like newIOref should treat its type parameter like a function does?
05:22:21 <mun> blackh, hmm ok. so should i just give it a dummy function?
05:22:24 <Baughn> ..barring GHC bugs, of which I've run into a few
05:22:27 <ray> mun: depends on your type
05:22:48 <blackh> mun: No - you have to give it a non-dummy value for the second argument to trace.
05:23:07 <blackh> mun: If you don't believe me, then try giving it 'undefined' and see what happens.
05:23:10 <mun> ah okay
05:23:14 <mun> it's good now.
05:24:12 <nominolo> roconnor: how does a function treat its type parameter?
05:24:26 <dcoutts> roconnor: newIO/STref is perfectly safe in the monadic context
05:24:33 <nominolo> do you mean variance?
05:24:42 <blackh> Baughn: I had some code that worked outside unsafePerformIO that crashed inside it.  I discovered that atomicModifyIORef is not re-entrant. :)
05:24:49 <lilac> roconnor: the problem (iirc) is that polymorphic update functions aren't safe "by default"
05:25:10 <Baughn> blackh: To be fair, it warns about that in the documentation
05:25:19 <nominolo> blackh: you mean atomicModifyIORef within atomicModifyIORef?
05:25:33 <roconnor> nominolo: differently in GHC and YHC.
05:25:38 <nominolo> blackh: that doesn't surprise me
05:25:38 <blackh> nominolo: That's it - only possible with unsafePerformIO
05:26:06 <lilac> roconnor: if i can create a 'forall a. Ref a', write to it with 'Ref a -> a -> IO ()' and read from it with 'Ref a -> IO a' then i have a problem
05:26:50 <nominolo> blackh: Right, you get a dependency loop I thikn
05:26:51 <roconnor> lilac: in YHC (and ocaml) you cannot create a "forall a. Ref a", or rather you can, but it is a function.
05:27:02 <blackh> eevar2: Your parMap code looks correct.  How many CPU cores are you using?
05:27:23 <nominolo> blackh: because atomicModifyIORef works due to laziness
05:27:28 <roconnor> lilac: it makes no sense to write to it.  You have to make an instance first by passing a type parameter.  Each time you pass a type parameter (even if it is the same function) you create a new Ref.
05:27:42 <blackh> nominolo: Some of us have to learn why unsafePerformIO is bad the hard way. :)
05:27:56 <roconnor> lilac: in the end what happens in YHC is that you read and write from different instances of the Ref.
05:28:06 <roconnor> lilac: and you get no segfault.
05:28:19 <nominolo> blackh: well, I did use unsafePerformIO inside atomicMIORef, but my use was safe (I think)
05:28:52 <lilac> roconnor: so if you write at one type and read at another, how many mutable variables did newIORef create?
05:28:56 <blackh> eevar2: Oh you said - two cores. Well, it can be difficult to get an improvement on two cores.  It works better with a "real" problem.
05:29:03 <roconnor> lilac: 2
05:29:33 <roconnor> lilac: even if they are the same time, they are still 2, so long as you have a polymorhic signature for the reference.
05:30:32 <blackh> eevar2: There is meant to be a performance issue with Linux on two cores (in case you are using Linux).  Also, anything that allocates memory tends to parallelize less well in ghc 6.10.x.
05:30:43 <eevar2> blackh: ok. just a tad discouraging, as I see linear scaling with certain other languages
05:30:52 <roconnor> sorry, I just hate this idea that unsafePerformIO can be used to write unsafeCoerce.  This is very specific to how GHC handles polymorphism.
05:30:57 <eevar2> os x
05:31:10 <lilac> roconnor: ok, so the number (and size) of mutable areas newIORef creates varies (dynamically) depending on the actual types at which it's used
05:31:21 <lilac> and it could be an unbounded number of refs
05:31:24 <blackh> eevar2: You might want to try ghc 6.11.x. Apparently much work has been done on this.
05:31:25 <roconnor> lilac: it varies based on the number of times it is called.
05:31:42 <eevar2> the again, micro benchmarks like this one are probably silly
05:31:48 <blackh> eevar2: So I heard... I have not tested it myself.
05:31:52 <lilac> roconnor: if it's used at the same type, it's got to be the same ref, or it's not all that useful as a mutable reference, right?
05:31:59 <roconnor> lilac: and it certainly must be called multiple times if you are going to pass different type parameters.  Because forall a. Foo a is a function type.
05:32:39 <roconnor> lilac: it will be a different ref if it is called twice, even with the same parameter.
05:32:42 <int-e> roconnor: but if you don't treat it like ghc does, won't that force you to treat  Left () :: Either () a  as a function as well, i.e. allocate it whenever you use it with an unused type?
05:32:56 <roconnor> lilac: you'd have to store the result of the ref allocation in a let expression to reuse it.
05:33:07 <int-e> *unknown type
05:33:09 <roconnor> lilac: and this stored result would not have a polymorphic type.
05:33:21 <Axman6> eevar2: going from 30 seconds to 20 seconds may well be a linear scaling. you'd need more cores to know though ;)
05:33:37 <jethr0> @paste
05:33:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:33:40 <lilac> roconnor: if i have: do (x :: forall a. IORef a) <- newIORef; writeIORef a (42 :: Int); readIORef a :: IO Int, does it return 42 or not?
05:34:02 <thaldyron> Weird: When compiling with "ghc --make lazy.hs" everything works, but  "ghc --make lazy.hs -prof" yields "/usr/bin/ld: cannot find -lHSsyb-0.1.0.1_p".
05:34:16 <int-e> eevar2: have you checked the GC times? (say, +RTS -sstderr -RTS)
05:34:23 <roconnor> int-e: maybe.  What does ocaml do when you deal with Left (print "hello") ?
05:34:24 <gwern> thaldyron: you installed syb with profiling?
05:34:31 <eevar2> Axman6: good point i guess
05:34:43 <roconnor> lilac: doesn't newIORef take a parameter?
05:34:54 <thaldyron> gwern: ah! forgot about that...
05:35:27 <jethr0> can anyone give me a hand with newtype monad deriving: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8618#a8618
05:35:32 <lilac> roconnor: ok. imagine i passed it 'undefined'. the details aren't relevant unless the example i'm trying to construct is actually impossible to construct.
05:35:57 <jethr0> i'm trying to nest two stateT monads around a MonadIO, but am getting "functional depency" errors...
05:36:06 <roconnor> lilac: then I think it ought to return undefined (assuming you can convince newIORef to return a polymorhpic value), and I think YHC would do this.
05:36:09 <int-e> try newEmptyMVar instead, no undefined required.
05:36:39 <roconnor> int-e: then whatever happens when you read an empty var.
05:36:44 <int-e> it blocks
05:36:55 <thaldyron> gwern: how do I install syb with profiling support; I didn't find any flag in the cabal file?
05:36:59 <jethr0> does anyone have experience with derived monad transformers?
05:37:09 <gwern> check the configure opts
05:37:11 <dcoutts> thaldyron: see cabal install --help
05:37:13 <lilac> roconnor: interesting. i personally think it should be a type error :)
05:37:20 <dcoutts> thaldyron: or cabal configure --help
05:37:26 <roconnor> lilac:  (x :: forall a. IORef a) <- newIORef creats a new function called "x" that given a type creates a new undefined IORef.
05:37:55 <lilac> roconnor: operationally, perhaps. but denotationally i don't see that's necessarily the case.
05:38:09 <roconnor> lilac: writeIORef x (42 :: Int) -- this calls x with Int, creating a new undefined IORef and writes 42 into it.
05:38:26 <voker57> can i compile stuff with GHC for another architecture (on x86 for x86-64)?
05:38:40 <Axman6> i'm not sure you can
05:38:45 <roconnor> lilac: readIORef x :: IO Int -- calls x with Int, creating a second new undefined IORef and reads from it.
05:38:46 <lilac> roconnor: that's another thing which disturbs me. forcing the result (in pure code) at a particular type performs an IO action
05:39:00 <roconnor> lilac: ah oops
05:39:02 <EvilRanter> jethr0, would newtype BM a = BM {
05:39:02 <EvilRanter>  runBM :: StateT (World, Meta) IO a } be workable for you?
05:39:03 <roconnor> you are right
05:39:06 <blackh> voker57: Generally, no, but I know how to do it.
05:39:08 <thaldyron> dcoutts: thanks that did the trick.
05:39:11 <roconnor> lilac: you will get a type error
05:39:22 <voker57> blackh: via compiling to C?
05:39:35 <roconnor> lilac: because forall a. IO a is not the same as IO (forall a. a).
05:39:54 <lilac> roconnor: hooray! :)
05:39:56 <jethr0> evilranter, I thought about it. problem is that I kinda need meta state to initialize world state. but i guess nested transfomers don't aleviate that problem at all
05:40:02 <EvilRanter> jethr0, nested WhateverTs don't tend to work, unfortunately, but you can usually represent them as a single WhateverT with a little ingenuity
05:40:09 <lilac> roconnor: that also neatly explains why DDC has trouble with this
05:40:13 <blackh> voker57: It is not quite as simple as that, because you need to compile the runtime system too.
05:40:18 <roconnor> lilac: (x :: forall a. IORef a) <- newIORef  is a type error, because newIORef doesn't return an IO (forall a. IORef a).
05:40:19 <lilac> (along with SML etc)
05:40:50 <EvilTerran> jethr0, how about StateT (Maybe World, Meta) IO, in that case?
05:40:51 <jethr0> ah, and there I thought I was just too stupid. so it's a limitation that you can often not nest two identical transfomers?
05:41:01 <EvilTerran> indeed
05:41:03 <fasta> jethr0: you can nest them.
05:41:08 <EvilTerran> the fundeps break things
05:41:12 <roconnor> lilac: interesting observation about DDC
05:41:26 <fasta> jethr0: you just have to lift stuff explicitly then.
05:41:31 <lilac> DDC has closure typing to deal with this, but i don't really understand the details
05:41:32 <jethr0> evilterran: you are speaking my thoughts. but then i will have to deal with the annoying Maybe for the rest of my life, just for this initialization "workaround". hmmmmmmm
05:41:40 <int-e> what is DDC in this context?
05:41:46 <EvilTerran> ah, fasta has a point
05:41:48 <fasta> jethr0: the common way to solve this is to introduce newtypes.
05:41:50 <opqdonut> int-e: the language
05:41:54 <jethr0> yep, no newtype deriving then
05:42:00 <fasta> jethr0: or "solve" if you prefer.
05:42:02 <opqdonut> int-e: disciplined disciple compiler
05:42:02 <lilac> int-e: the Disciplined Disciple Compiler
05:42:10 <roconnor> lilac: so if you throw in some unsafePerformIOs and use lets instead of do notation, then it "ought" to do what I said, but GHC doesn't.
05:42:11 <jethr0> or rather newtype the inner type and do the outer one manually
05:42:14 <EvilTerran> it's not that you can't nest StateTs, it's that you can't use MonadState if you do
05:42:17 <opqdonut> gah, typing that name takes almost a minute :D
05:42:26 <lilac> int-e: the language is called Disciple, but it's evolving fast and basically defined by what DDC accepts ;-)
05:42:39 <roconnor> lilac: but I forgive GHC, because I don't expect unsafePerformIO to be safe anyways.
05:42:51 <jethr0> so, if I leave out one of the MonadState derivations then I can do everything naturally with explicit lifts?
05:43:21 <int-e> thanks
05:43:49 <lilac> roconnor: ok, i see now. i think you're saying "unsafePerformIO (x :: forall a. IO (F a)) :: forall a. F a" in GHC, but not in YHC?
05:44:07 <jethr0> i'll probably make my datatype sanely initializable, i guess. maybe with a "data World = Empty
05:44:12 <lilac> (presumably in YHC it has to be applied at a ground type?)
05:44:13 <jethr0>  | World ..."
05:45:33 <roconnor> lilac: I don't think that is what I'm saying, but I'm not certain. :D
05:45:45 <int-e> lilac: I'm not sure. I think roconnor is saying that to use  forall a . F a, you need a type argument (as does System F, I think), and unlike GHC the compiler isn't free to drop it. Not sure either, of course.
05:46:17 <lilac> it seems pretty subtle, in any case :)
05:46:21 <roconnor> lilac: I'm saying unsafePerformIO (newIORef undefined) :: forall a. IORef a in both GHC and YHC
05:46:39 <roconnor> lilac: but in YHC  forall a. IORef a is a function, while in GHC it is a value.
05:46:49 <roconnor> lilac: and YHC is more right.
05:47:04 <int-e> but possibly less efficient, and ghc is right for pure code.
05:47:12 <roconnor> lilac: which is made clear by the fact the YHC won't segfault (here).
05:47:13 <jethr0> thx guys
05:47:21 <hackagebot> type-equality 0.1.0 - Type equality, coercion/cast and other operations. (ErikHesselink)
05:47:25 <roconnor> int-e: right.
05:47:47 <mux> I sometimes wish that there was a special syntax in Haskell to do explicit type application for polymorphic functions, so that you don't have to use the ugly phantom type trick (undefined :: SomeType)
05:47:49 <lilac> roconnor: it won't segfault, but it also won't work if used safely, AFAICS
05:47:49 <int-e> and we can blame unsafePerformIO for breaking the justification that ghc has for treating that value as a constant.
05:48:05 <int-e> hmm. blame shifting.
05:48:07 <roconnor> lilac: well, you cannot write unsafeCoerce this way in YHC.
05:48:32 <lilac> roconnor: sure, but it seems like it also rules out a useful class of safe programs
05:49:00 <roconnor> lilac: that's kinda like saying not allowing unsafePerformIO rules out a useful class of safe programs.
05:49:09 <lilac> roconnor: yes, it's just like that.
05:49:10 <int-e> roconnor: does the   foo = unsafePerformIO (newIORef blah)   idiom still work, if the type argument is constant and known at compile time?
05:49:15 <roconnor> lilac: or having a type system rules out a useful class of safe programs.
05:49:49 <int-e> (not that I like it)
05:49:52 <roconnor> int-e: if foo ends up as a non-polymorphic type, then GHC and YHC will agree.
05:49:58 <lilac> roconnor: yes. but... "unsafePerformIO" is the go-to guy for "i want to escape the bondage and discipline and do something dodgy". yhc is preventing that.
05:50:16 <lilac> or at least putting up an additional barrier
05:50:40 <zeno__> is something like this possible? foo ("bar" ++ x) = x;foo y = y
05:50:42 <int-e> lilac: so unsafeCoerce all the polymorphic types to () :-)
05:50:46 <roconnor> lilac: I don't think unsafePerformIO is designed to subvert the type system.  YHC's implementation is exactly how OCaml's polymorphic references work.
05:50:57 <roconnor> lilac: Ocaml still needs ObjMagic to subvert the type system.
05:51:21 <roconnor> lilac: if anything YHC gives more discrete levels of safety.
05:51:26 <zeno__> where foo "bar9" =9 and foo "baz"=baz
05:51:43 <doserj> zeno__: only like this: foo ('b':'a':'r':x) = x;foo y = y
05:52:02 <zeno__> doserj: thanks
05:52:25 <lilac> roconnor: i see :) unsafePerformIO to subvert the effects system, unsafeCoerce to subvert the type system. it's quite elengant, actually :)
05:52:25 <roconnor> zeno__: something like what you wrote can be kinda done with using the views extension.
05:52:30 <quicksilver> int-e, lilac, roconnor : isn't the problem that IORef a is somehow non-parametric in a?
05:52:32 <lilac> roconnor: ok, i'm sold :)
05:52:38 <quicksilver> (or is it newIORef that's non-parametric)
05:52:57 <roconnor> zeno__: but probably not worth it in this case.
05:52:58 <quicksilver> it seems to me that ghc's approach is sound when appropriate parametricity conditions hold
05:53:03 <quicksilver> and something breaks them
05:53:13 <lilac> quicksilver: IO (IORef a) is parametric. and you shouldn't be able to get at an IORef outside IO.
05:53:17 <quicksilver> whether you put the blame at newIORef, or unsafePerformIO, or IORef itself.
05:53:30 <roconnor> quicksilver: YHC's approach is always sound.
05:53:35 <quicksilver> I know.
05:54:28 <roconnor> Although I am saying YHC is more right than GHC, really it is all outside the scope of Haskell so there is no really correct answer.
05:54:37 <roconnor> these programs are just all wrong :D
05:55:04 <lilac> quicksilver: i think it's like asking, if we had 'runST :: (ST s a) -> a', then our system would be impure. is that runST's fault or ST's fault or STRef's fault?
05:55:34 <quicksilver> lilac: well you can be impure without being unsound
05:55:39 <quicksilver> but I think I follow the analogy.
05:56:17 <roconnor> my prominent point is that you cannot in general write unsafeCoerce with unsafePerformIO.  This is GHC specific.
05:56:53 <quicksilver> unsafePerformIO "leaks" some extra semantics out of IO.
05:57:10 <quicksilver> there are IO semantics which are natural and unarguable and shared between correct implementation.
05:57:20 <quicksilver> but unsafePerformIO leaks some internal details
05:57:23 <roconnor> right
05:57:28 <quicksilver> ..which then become extra semantics
05:57:32 <quicksilver> and, in those, GHC and YHC differ.
05:57:36 <int-e> roconnor: fair enough
05:57:38 <lilac> right.
05:57:46 <mlesniak> Hi, does some kind of Hashmap with O(1) (can be in the IO monad) checking for elements exist? Data.Map provides only O(log n). ... pretty sure there is something. Bloom filters are, due to false positives, not good enough ;)
05:58:18 <opqdonut> how large is n?
05:58:19 <quicksilver> mlesniak: Data.Hashtable is generally worse than Data.Map in practice.
05:58:25 <lilac> one program can work in YHC and crash in GHC, another can work in GHC and do the wrong thing in YHC. roconnor's argument is that not crashing is more valuable.
05:58:28 <opqdonut> because for all practical purposes O(log n) is fast enough
05:58:39 <quicksilver> try Data.IntMap and see if it's good ebough?
05:58:44 <mux> given that the O(log n) is real and O(1) for hash tables is just if you have absolutely no collisions, Map is good enough
05:58:47 <mux> or eve nfaster
05:58:54 <lilac> (and the GHC behaviour can be recovered with unsafeCoerce in YHC I think)
05:58:59 <mlesniak> mux, good argument
05:59:07 <mlesniak> quicksilver, Hmm, ok, thanks
05:59:14 <quicksilver> mux: O(1) for hashtables is only if you have a O(1) hash function
05:59:15 <int-e> lilac: now we need a useful program that works in ghc that yhc won't accept.
05:59:22 <quicksilver> mux: I strongly suspect most hash functions are O(log n)
05:59:25 <mux> quicksilver: yes, a perfect hash function with no collisions
05:59:25 <Baughn> mlesniak: Besides, the O(1) figure for hash tables is incorrect
05:59:29 <quicksilver> (although, perhaps, very fast nonetheless)
05:59:30 <roconnor> lilac: I cannot promise that all behaviour can be recovered, but certainly all that I know can be recovered (which is just unsafeCoerce).
05:59:37 <lilac> hash tables aren't O(1) in GHC, due to the extra O(n) GC cost in GHC
05:59:41 <mux> quicksilver: and then again, computing the hash itself may be significant time-wise
05:59:47 <quicksilver> that's what I meant, yes
05:59:52 <Baughn> lilac: Sorry?
06:00:00 <quicksilver> that's what I was referring to by the speed of the hash function.
06:00:08 <quicksilver> most naive string hash functions are O(log n), for example
06:00:16 <mux> now if you know the set of the keys in advance, you can get a perfect hashing functions with gperf, but that's not the common case
06:00:17 <quicksilver> ...they're O(key length) and key length is O(log n)
06:00:20 <koala_man> but that's a different n
06:00:24 <mux> yes
06:00:32 <etpace_> > extract (Just 5)
06:00:33 <lambdabot>   Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
06:00:34 <mux> that's a much smaller n, if everything works correctly
06:00:43 <Baughn> koala_man: You might say that hash tables are O(log (maximum possible number of values in table))
06:00:50 <lilac> Baughn: a mutable array of N elements imposes an O(N) GC cost, due to GHC a runtime bug (which i think isn't fixed in 6.10)
06:00:57 <Baughn> While Data.Map is O(log (actual number of elements in map))
06:01:04 <lilac> (on the first GC after each update)
06:01:22 <Baughn> lilac: I see. That's not nice.
06:01:22 <etpace_> shouldnt that work? Maybe is a functor and itd be (Maybe a) -> a
06:01:36 <Axman6> :t extract
06:01:37 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
06:01:37 <mux> mlesniak: anyways, I have very often been positively surprised by the speed of Map
06:02:15 <lilac> Baughn: http://hackage.haskell.org/trac/ghc/ticket/650
06:02:35 <int-e> lilac: well it's not simply a bug; you need card marking or something like that, i.e. a non-trivial amount of extra code and effort into designing it.
06:02:37 <lilac> upshot: Hashtable is actually O(n), Map is O(log n)
06:02:38 <koala_man> Baughn: they are O(1) for a good O(1) hash function, at O(n) memory usage
06:02:39 <etpace_> hmm, the one in the typeclopedia is for a copointed f, extract :: f a -> a
06:02:51 <etpace_> are they two different extracts?
06:03:05 <Badger> @hoogle extract
06:03:06 <lambdabot> No results found
06:03:09 <Baughn> koala_man: Sure, but hash functions generally aren't O(1)
06:03:14 <mux> mlesniak: if I remember correctly, perl hashes are actually implemented with 2-3 finger trees and thus are O(log n) access
06:03:27 <Athas> What's the recommended way to deal with command-line parameters in Haskell?
06:03:35 <Baughn> @index getArgs
06:03:35 <lambdabot> System.Environment
06:03:37 <lilac> int-e: definition of "bug" aside, it certainly doesn't match naive expectations that a mutable array update is O(n)
06:03:39 <mux> there's a getOpt thing
06:03:43 <mux> I don't like it much though
06:03:55 <koala_man> Baughn: ah ok, I get it
06:04:30 <mux> haskell's getOpt is more like GNU getopt than like POSIX getopt, which is definitely a disadvantage in my book
06:04:50 <mux> I should write my own getopt thing some day
06:05:58 <Athas> Well, I prefer GNU getopt, so that pleases me fine.
06:06:26 <ray> another gnu embrace and extend manouver succeeds
06:06:55 <mux> everything would be fine if haskell's getOpt wouldn't force you into GNU territory
06:06:59 <mux> this is no always desirable
06:07:17 <ksf> getOpt isn't implemented in haskell?
06:07:24 * mux stands by the SUSv3 utility guidelines.
06:07:29 <ray> i think it is, it's just gnu'd up
06:07:29 <mux> ksf: yes it is
06:08:28 <ray> gnu getopt is annoying as hell
06:08:40 <ray> mainly the "options after real arguments works" thing
06:08:52 <mux> exactly, that's the most annoying bit, because it can definitely leave you stuck
06:09:00 <koala_man> hah, yes
06:09:07 <Baughn> Now, now. That's what -- is for.
06:09:15 <mux> Baughn: no it's not
06:09:46 <mux> -- is to signal the end of options, so that you can have parameters starting with a '-'; it has nothing to do with options after parameters
06:09:59 <mux> that is a bad, bad GNU extension
06:10:08 <Baughn> In what way do those annoy you, then?
06:10:30 <ksf> https://www.mirbsd.org/htman/i386/man3/getopt.htm
06:10:43 <mux> Baughn: it means I cannot, for instance, implement, say wc(1) according to the POSIX specs using haskell's getOpt because there will be subtle differences
06:10:58 <mux> POSIX (as in SUSv3) doesn't allow GNU-like options
06:11:37 <mux> and I really see no reason why haskell's getOpt should force me into this scheme
06:11:50 <mux> but I promise some day I'll stop complaining and will rewrite it :-)
06:11:56 <Baughn> Variety is the spice of life?
06:12:11 <mlesniak> mux, ok, then I'll hope for the best ;)
06:12:15 <mux> Baughn: I really hope that wasn't a serious argument ;-)
06:12:49 <zeno__> is there a way to send email from a haskell program (that works in windows)?
06:12:53 <Baughn> mux: Nah, I've got a better one
06:12:54 <mun> if i have a variable of type LibEnv, where LibEnv = Map.Map LIB_NAME DGraph, how do i get the DGraph part of it?
06:12:57 <koala_man> the real problem is globbing. why on earth should rm * ever mean anything except "delete all files"
06:13:02 <Baughn> Embrace & Extend will bring victory to linux?
06:13:10 * int-e wonders whether mux would put  rm -f / -r  into a shell script to spite GNU users.
06:13:11 <mux> Baughn: ugh. :-)
06:13:22 <ksf> zeno__, open a socket, write HELO <youradress>\r\n ... and so on.
06:13:31 <mux> int-e: heh, I hadn't thought of that. pretty cunning :-)
06:13:43 <ksf> I think HappStack has a module for that.
06:14:12 <zeno__> ksf: thanks
06:14:27 <lilac> int-e: or better, create a file in . called -r and to rm -f / *
06:15:28 * lilac notices koala_man made the same point ;-)
06:15:29 * Baughn makes a mental note not to run lilac's code as root
06:15:38 * ksf wonders whether any of you complainees is already coding up a fully-typed haskell shell
06:15:55 <koala_man> aren't there several already?
06:16:39 <ksf> iirc all existing use vanilla posix semantics for automagic backward compability
06:17:13 <ray> yeah, if you're just reimplementing UNIAX there's no point
06:17:25 <ray> you need haskell machine
06:17:31 <lilac> outside of shell scripts i find zsh's warnings re "are you sure you want to delete all these files?" are enough
06:17:52 <lilac> inside shell scripts i (try to) always use rm -- * :-/
06:17:56 <ksf> some day, we will have gitfs.
06:18:03 <EvilTerran> zeno__, there's a few packages on hackage that may do what you want
06:18:22 <ray> there are already versioning filesystems, it's just that whiny losers whine because they're losers
06:18:37 <int-e> lilac: hehe. that 'always' was ambiguous.
06:18:38 <zeno__> EvilTerran: looking at that happsstack one! sure is a pain to use hackage with cabal not working tho :\
06:19:30 <dcoutts> zeno__: what's not working?
06:19:39 <dcoutts> zeno__: you were having problems with hsc2hs, right?
06:19:47 <ksf> the traditional way, btw, is to call sendmail.
06:19:51 <EvilTerran> zeno__, http://hackage.haskell.org/package/HaskellNet might do it, too
06:19:59 <EvilTerran> ksf, <zeno__> is there a way to send email from a haskell program (that works in windows)?
06:20:03 <zeno__> dcoutts: fixed that, but now ive run into a ghc bug
06:20:21 <zeno__> dcoutts: http://hackage.haskell.org/trac/ghc/ticket/3463#preview
06:21:46 <ksf> ouch.
06:21:48 <dcoutts> zeno__: looks like you've got some installed package that's messed up
06:21:49 <lilac> int-e: every shell script i write, that's the very first line ;-)
06:22:18 <dcoutts> zeno__: not obvious which one however
06:22:59 <zeno__> dcoutts: ya :( sort of gave up cause couldnt figure it out
06:23:04 <int-e> > chr 1114112
06:23:06 <lambdabot>   * Exception: Prelude.chr: bad argument
06:23:29 <zeno__> been trying to get cabal install working for days
06:23:54 <ksf> me still recommends http://www.gentoo.org/doc/en/handbook/ , section "Installing gentoo"
06:23:58 <dcoutts> zeno__: that's pretty bad, it's usually pretty straightforward
06:24:19 <int-e> zeno__: the Binary error would worry me - maybe the stream gets out of sync and a Char (stored as Int32?) is read from the wrong position?
06:24:35 <dcoutts> zeno__: are there any lessons we can learn? any bugs that need reporting (beyond the ghc .hi one you've just reported)
06:24:39 <int-e> in which case the question is, what is ghc trying to read? a .hi file?
06:24:59 <zeno__> dcoutts: hmm not that i can detail anymore
06:25:07 <dcoutts> int-e: yes, my guess is it's an .hi file that's messed up beyond ghc's usual capabilities to detect it
06:25:20 <zeno__> int-e: the systems a bit hot, dont know if that would do it?
06:25:57 <dcoutts> zeno__: if you're concerned about that then try running memcheck
06:25:58 <zeno__> ksf: reinstalling my os / everything else seems a bit of overkill to get haskell owrking :\
06:26:11 <zeno__> k good idea
06:26:19 <ksf> installing gentoo is never overkill.
06:26:21 <int-e> zeno__: I'd try the bootstrap script step by step, adding verbosity flags. the report doesn't give a lot of information.
06:26:39 <zeno__> step by step?
06:26:45 <mun> if i have a variable of type LibEnv, where LibEnv = Map.Map LIB_NAME DGraph, how do i get the DGraph part of it?
06:26:46 <ksf> some day you're going to have to update your ubunto to a distribution, anyway.
06:27:26 <ksf> zeno__, sh -x bootstrap.sh
06:27:27 <djahandarie> ksf, meh, I'm not a big Gentoo fan. I ran it for a year, but then I realized, "wow, everything would have been like 200x easier if I was just on Debian". -_-
06:27:35 <ksf> ...prints out commands as they are executed
06:27:36 <endojelly> djahandarie, same here
06:28:07 <ksf> ...until you want to do something debian doesn't want you to do and it becomes 10000x harder.
06:29:01 <ksf> It's not like I wasn't using debian before gentoo.
06:29:12 <zeno__> ksf: same error
06:29:23 <ksf> yeah, but you should have more information, now.
06:29:39 <int-e> namely, the command that was failing.
06:30:00 <zeno__> ksf: http://pastebin.ca/1543199
06:30:38 <zeno__> i think the failing one was + ghc --make Setup -o Setup
06:30:42 <ksf> yep
06:30:49 <ksf> change it to ghc -v
06:31:03 <ksf> (or just run ghc -v --make Setup -o Setup manually)
06:31:36 <jethr0> man o man, still having trouble with liftIO...
06:31:53 <jethr0> i'd like to call some opengl calls with a StateT monad transformer.
06:32:08 <zeno__> ksf: int-e http://pastebin.ca/1543201
06:32:26 <jethr0> can't i take a function "func :: IO Int; func = do ..." and simply change it to "func = liftIO $ do ..."?
06:32:30 <ksf> (the battery of my mouse just died, give me a minute)
06:33:13 <ksf> jethr0, nope, because its type then changes to (in your case) func :: StateT (IO Int)
06:33:25 <ksf> ...you can do liftIO $ func, though.
06:33:40 <int-e> zeno__: remove the dist directory
06:33:51 <int-e> hmm. wait, no.
06:34:05 <int-e> zeno__: are there .hi files in the cabal-install tree?
06:34:39 <ksf> should be Setup.hi
06:35:28 <zeno__> int-e: int-e http://pastebin.ca/1543204
06:37:00 <int-e> zeno__: try removing Setup.hi.
06:37:15 <ksf> ...rather moving it.
06:37:23 <ksf> if it's really the culprit, it's evidence.
06:37:30 <int-e> zeno__: (let's hope the other dist directories are fresh)
06:37:32 <int-e> good point
06:38:52 <int-e> is it possible that the file got copied over from another computer?
06:39:02 <zeno__> int-e: rm wich one? ./Setup.hi, ./Cabal-1.6.0.2/dist/build/Distribution/Simple/Setup.hi, ./Cabal-1.6.0.2/Setup.hi, or ./Cabal-1.6.0.2/Distribution/Simple/Setup.hi?
06:39:07 <int-e> the one in .
06:40:13 <zeno__> int-e: nope havnt used haskell on another comp even
06:40:20 <zeno__> hurray works now
06:40:22 <zeno__> :)
06:40:30 <ksf> well it might have been included in the tarball
06:40:38 <ksf> ...but that's a long shot.
06:42:19 <int-e> Well a 64bit/32bit mismatch seems the easiest explanation. I guess you could get that with a single computer, as well.
06:42:42 <int-e> if you try hard enough.
06:46:10 <ksf> zeno__, could it be that your ubuntu and your platform ghc have different bytesizes?
06:46:58 <int-e> (ghc +RTS --info)
06:47:55 <zeno__> "Host platform", "i386-unknown-linux" ,("Word size", "32")
06:48:08 <zeno__> looks right
06:48:47 <int-e> I think ksf believes that there may be two different ghcs installed.
06:49:06 <ksf> ...and what you're looking for should be "Target platform"
06:49:08 <zeno__> nope there WAS 6.8.2 but i rmed it
06:49:24 <zeno__>  ,("Target platform", "i386-unknown-linux")
06:49:58 * ksf thought you might have used that one to try bootstrapping cabal-install, before
06:53:32 <fasta> Why doesn't this work? let inf = singleton 1 >< inf in Data.Sequence.take 4 inf
06:53:48 <ksf> :t (><)
06:53:50 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
06:54:04 <fasta> That's the sequence concatenate operator.
06:54:22 <fasta> It seems that it is not lazy.
06:54:28 <ksf> > let inf = singleton 1 >< inf in Data.Sequence.take 4 inf
06:54:29 <lambdabot>   Not in scope: `singleton'Not in scope: `><'
06:54:32 <int-e> fasta: Data.Sequence is strict.
06:54:44 <fasta> int-e: is there also a lazy version?
06:54:52 <quicksilver> fingertrees can't be lazy
06:54:57 <quicksilver> well not without a very very clever monoid
06:55:08 <quicksilver> they have to store the partial monoid sums at every branch
06:55:12 <int-e> fasta: it's called a list ;-) ... how would the lazy version work?
06:56:09 <fasta> quicksilver: what do you mean by partial monoid sums? Is that the same as using difference functions in data structures?
06:56:24 <fasta> quicksilver: it's the partial that's confusing.
06:56:32 <int-e> I guess you could have a fingertree based listlike structure that supports O(log n) concatenation from one end, with an open end on the other side. In fact it can be modeled by Seq (Either a [a]) with the restriction that all elements but the last one are Lefts.
06:58:58 <quicksilver> fasta: I mean, the sum of the substructure below that point
06:59:21 <fasta> quicksilver: that's not _that_ fancy.
06:59:32 <fasta> If only file systems did that.
06:59:54 <quicksilver> it's not the fancy no, but it does forbid infinite sequences
07:00:07 <quicksilver> and several limit the possibilities for lazily evaluated sequences.
07:00:56 <fasta> I see the issue.
07:04:30 <int-e> > Data.Sequence.length $ iterate (\x -> x Data.Sequence.>< x) (Data.Sequence.singleton 1) !! 63 -- :-(
07:04:32 <lambdabot>   -9223372036854775808
07:05:10 <quicksilver> int-e: haha :)
07:05:39 <quicksilver> int-e: quite impressive, though, that you can construct a sequence that long so quickly.
07:05:43 <quicksilver> good sharing.
07:06:26 <quicksilver> I'd never previously thought of recommending a Sequence as a structure for very long strings which have many,many shared substrings.
07:06:29 <quicksilver> that's quite clever
07:06:34 <quicksilver> (as long as you construct it right)
07:07:08 <int-e> quicksilver: yes. It's almost a good match for project euler problem 220 - all you'd need to finish would be custom measurements.
07:07:28 <mux> that reminds me I need to work on problem 131 some more. :-)
07:07:37 <mux> int-e: how many problems have you solved?
07:08:00 <int-e> 226
07:08:23 <mux> wow. I'm only at 127
07:08:31 <int-e> (which was 100% at some point early this year)
07:08:38 <mux> yeah, there are 252 problems now
07:08:52 <medfly> does it get more interesting later?
07:09:22 <mux> I'm still satisfied because I'm the first in my country to use Haskell (or at least, to have set haskell as its preferred language in my profile)
07:09:33 <mux> medfly: where are you at? I find PE to be very very interesting
07:09:41 <Axman6> int-e: you're a nut o.O
07:09:51 <medfly> well, I kind of got bored with it at some point.
07:10:07 <Axman6> yeah, i got bored of PE
07:10:09 <medfly> mux, where are you?
07:10:22 <medfly> well, I also don't have much time for things like that at the moment.
07:10:22 <int-e> medfly: yes, it gets more intesting again, once you're over the 4th pell-fermat equation or so.
07:10:25 <mux> there are periods where I don't do PE for a couple of months, and then I get to it again
07:10:39 <medfly> I'm not a mathematician, though
07:10:46 <mux> medfly: as I said, 127 out of 252
07:10:58 <medfly> mux, no, which country?
07:11:05 <mux> oh, france
07:11:54 <medfly> oh. it'd be pretty strange if there were no other Haskell users in France.
07:12:28 <mux> there definitely are, I meant that I'm ranked first in my country among the people who have set haskell as their preferred language
07:12:38 <medfly> oh!
07:13:45 <mux> I'm only the 40th french otherwise (and that doesn't account for people with a higher score than me, but who have gone idle, I guess there are many)
07:14:12 <medfly> there are scores/
07:14:13 <medfly> ?
07:14:32 <mux> score as in number of problems solved
07:14:37 <medfly> I see.
07:15:51 <medfly> might be more off-topic than the previous discussion, but I want to do some kind of task, adding to something which already exists. the thing that is around uses MySQL, so I thought it'd be nice to use it too. however, I don't know any SQL or that. should I learn, or is it too much effort?
07:16:00 <medfly> use my mighty Haskell skills to overcome this
07:16:26 <mux> SQL really isn't hard to learn
07:16:49 <mux> what's annoying are the various incompatibilities between Oracle, MySQL, PostgreSQL, etc
07:17:57 <medfly> okay, thanks
07:22:17 <etpace_> there was a guy at my university interview who was 100% on PE, i was quite intimidated
07:23:17 <Twey> Portable Executables?
07:23:32 <ray> position endipendint code
07:24:07 <Twey> Ohh.
07:24:12 <mux> project euler?
07:24:23 <Twey> Well, I can certainly see why you'd be intimidated.
07:24:30 <mux> PIE is position independant executable, PIC is position independent code and those are different
07:24:59 <ray> i didn't say either of those things, now did i
07:25:21 <mux> that's what was worrying me, maybe wrongly :-)
07:25:26 <etpace_> yes, project ruler
07:25:29 <maxote> Oracle as M$ have closed mind, remember it.
07:25:31 <etpace_> euler, even
07:25:34 <mux> hah, project ruler sounds fun
07:26:10 <mux> funny how the wikipedia page on PIC gets it wronbg
07:26:37 <ray> it's almost like wikipedia is unreliable
07:26:49 <mux> that just can't be! :D
07:27:21 <quicksilver> reality is unreliable
07:27:27 <quicksilver> wikipedia is absolute truth
07:27:37 <mux> wikipedia actually /defines/ truth
07:27:57 <absentia> -1 for using wikipedia as a reference
07:28:34 <Axman6> wikipedia is an excellent reference, especially to find better references. but it also does quite often have very informative articles
07:28:47 <maxote> wikipedia is 85% truth, 10% non-truth, and 5% fuzz.
07:29:43 <absentia> ax: exactly.. I use it as part of many... but I always double check things.  like, I wrote a base64 c++ from the description of the algorithm in wikipedia.. and it seems to work.
07:29:58 * ksf thinks he's re-inventing smalltalk.
07:30:03 <ksf> ...this time statically typed.
07:30:19 <ksf> the funny thing is that I don't know anything about smalltalk, at all.
07:30:41 <int-e> if it's prototype based you might be reinventing Self ;)
07:31:23 <jmcarthur_work> self is worth reinventing
07:31:34 <ksf> well I'd be using either hand-coded objects, or, I guess quickly after I hit a few extensibility (through inheritance) bumps, oohaskell.
07:31:37 <EvilTerran> maxote, s/%/% [citation needed]/g :P
07:32:28 <Axman6> heh
07:32:34 <ksf> I guess it's quite hard to go more oo than oohaskell, anyway.
07:32:44 <maxote> EvilTerran, the citation is fuzz
07:32:45 <ksf> It's the single most powerful system I've come across.
07:33:31 <lilac> ksf: afair it doesn't allow O(1) destructive updates of deeply-nested object members, which is a pity
07:33:51 <ksf> ...which I don't want to allow, anyway.
07:34:03 <ksf> each object gets an STM interface and its own thread.
07:34:09 <absentia> was a joke.. I think with 1 second, the ttl would expire by the time it was regrieved.. so it would never be valid...  (unless you ignored ttl, like aol)
07:34:17 <maxote> i can't get the citation of who invented 1+1=2
07:34:18 <lilac> ksf: hmm, that sounds quite interesting :)
07:34:49 <mux> maxote: you don't need to, it's defined as is, not invented
07:35:41 <quicksilver> ksf: but implementation inheritance is nasty, although functional composition is nice.
07:35:47 <maxote> mux, new definitions maybe invented by humans, not animals.
07:36:04 <ksf> it's interface combination I'm worried about.
07:36:49 <maxote> it's as to say, Einstein didn't the equation E=m*c^2
07:37:18 <jfoutz> i've got a few equally valid implementations for MonadSum, and i want all of them. Is there a standard way to do that?
07:37:25 <mux> well yeah, he didn't invent it, he discovered it (assuming the word you omitted is actually "invented")
07:37:47 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8621#a8621
07:37:52 <jfoutz> or do i make a new class for each version, and instance them all?
07:38:02 <ksf> I actually thought of it because I needed to synchronize code.
07:38:35 <ksf> (and Gtk doesn't provide an STM interface)
07:38:41 <quicksilver> jfoutz: make newtypes?
07:38:57 <quicksilver> mux: HELP I ACCIDENTALLY THE WHOLE E=MC2
07:39:04 <mux> hahaha
07:39:22 <pastorn> i'm in a bit of trouble, i need some syntax help
07:39:28 <pastorn> data CString = forall a. (Attribute a) => CS [a] String
07:39:30 <Axman6> ask/post away
07:39:41 <pastorn> this is for coloured strings in terminals
07:39:50 <int-e> jfoutz: You can wrap your actions in some newtype (similar to Sum and Product from Data.Monoid)
07:39:55 <ksf> hmmm.
07:40:16 <ksf> why am I not using plain and simple typeclasses to get multiple inheritance?
07:40:42 <mux> noone actually wants multiple inheritance anyways; they've been tricked into thinking they need it, while all they want is mixins
07:40:44 <int-e> Oh, quicksilver said that already.
07:40:48 <maxote> the relativity theory, is it invented or discovered?
07:40:54 <jfoutz> ahhh. thanks!
07:41:06 <quicksilver> mux: what they want is composable behaviour.
07:41:12 <mux> maxote: it makes no sense to say it is invented, since it accurately describes Nature; it's been discovered
07:41:15 <ksf> "multiple inheritance" as in "1 is both a Num and an Integral"
07:41:17 <quicksilver> mux: there are lots of nice ways to get composable behaviour - like monoids, for example
07:41:25 <mux> quicksilver: right, I was limiting my reasoning to OO-world
07:41:37 <quicksilver> mux: I was puncturing the OO world and watching all the gas seep out
07:41:44 <mux> (where I'm much happier with mixins than with MI)
07:41:46 <ksf> or "my thread is both Pausable and Drawable"
07:41:49 <mux> hahah
07:42:23 <int-e> class Gun implements Drawable?
07:42:36 <ksf> oo is a model, so it has been invented.
07:42:46 <ksf> the same goes' for newton's theory of gravity.
07:42:54 <ksf> ...that doesn't mean he invented gravity, though.
07:43:03 <ksf> and neither did he discover it.
07:43:11 <ezyang> mux: Well, you're not /sure/ it's not just a really good model
07:43:14 <ksf> (well, at least not at an age > 1 month)
07:43:29 <maxote> many texts appears that it uses "invented" instead of "discovered", so, nobody can claim me that i've to use "discovered" instead of "invented".
07:43:42 <int-e> the apple may have discovered the sensation of lack of gravity. :)
07:43:54 <mux> I cannot prove it, sure, I was pointing out that "discovered" sounds much more appropriate to me
07:43:58 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8623#a8623
07:44:04 <pastorn> Axman6: ^^ at the bottom
07:44:40 <Axman6> should it maybe be (forall a. Attribute a) ...?
07:44:42 * quicksilver rules the discussion/invention topic to be off, erm, topic. And recommends discussions continue down the haskell/programming semantics line.
07:45:07 <mercury^> Are things allocated with Foreign.Marshal reclaimed when you drop the pointers?
07:45:08 <ksf> I'm a bit worried about the inter-object semantics, though.
07:45:10 <pastorn> GundisCol.hs:39:24: malformed class assertion
07:45:19 <pastorn> Axman6: coolest error, evar
07:45:26 <quicksilver> mercury^: only foreignptrs are hooked into the gc
07:45:30 <ksf> seems like it's not hard enough by default to deadlock their worker threads against each other.
07:45:34 <quicksilver> mercury^: the malloc stuff you have to free manually
07:45:44 <mercury^> quicksilver: is there a way to request GC on a Ptr then?
07:45:46 <quicksilver> ..or use the 'a' versions which are a bracket-like lexical free
07:45:54 <quicksilver> mercury^: just call 'free' on it.
07:46:06 <mercury^> Hmm, ok.
07:46:06 <quicksilver> but only if it was allocated by haskell :)
07:46:08 <ksf> otoh, as all communication is staged (or at least should be), things should be perfectly clean.
07:46:16 <quicksilver> if it was allocated by C, you should let C free() it.
07:46:22 <Axman6> "I once thought I found a bug in SQLite, but it turned out reality was wrong."
07:46:33 <ksf> (I guess that clearly describes the extend of muddiness in my brain)
07:46:53 <mercury^> How good is the GC? Any noticably improvement when you know how much memory you need and implement a pool?
07:47:03 <pastorn> Axman6: didn't work... have any other ideas? i'm in the dark here :/
07:47:26 <Axman6> nope, those are the sort of annotations i stay away from :P
07:47:29 <quicksilver> mercury^: the GC is much better than any manual allocation scheme, I'm sure.
07:48:18 <mux> mercury^: it has been proved in the past that GC-enabled code can actually outperform manual allocation
07:48:19 <ksf> what's certainly nescessary is to pair up "clear" and "append" into one separate interface, so I can pass that to one object, and modify to multiple.
07:48:36 <mux> GC /= slow
07:48:46 <ksf> ...as appending something if you don't know what's already in it does'nt make sense, and is racy, anyway.
07:48:47 <mercury^> quicksilver: Well, if I have on producer that constantly allocates, passes pointers to a consumer that can deallocate it right after usage, that's not better?
07:48:54 <quicksilver> mercury^: no, it is not.
07:49:04 <quicksilver> mercury^: in that exact pattern, GC is much better :)
07:49:16 <quicksilver> mercury^: GC once is much fast than (say) 10'000 manual deallocations.
07:53:45 <ksf> so the general idea of design is to push data and methods to request further data, and push requests.
07:55:28 <ksf> ...where, in my current app, a request would just mean that generating the data is priorized, not that not requesting it wouldn't have the worker thread generate it some time later, anyway.
07:56:25 <ksf> like, imagine 10000 files that each contain 10000000 integers and a gui list that shows their respective sums.
07:59:49 <path[l]> hi
08:00:15 <ksf> basically, I'm just fed up with all FRP libraries and their unpredictalble and/or thrashing runtime behaviour.
08:00:50 <quicksilver> designing a new object model seems a strange way to fix that :)
08:00:55 <quicksilver> but whatever works for you.
08:01:07 <path[l]> I had to leave earlier, but yeah Im a little concerned that I ported this code from ruby to haskell and it actually performs worse and just a little better when compiled with optimisation. When I was expecting a significant improvement.
08:01:32 <jmcarthur_work> path[l], paste?
08:01:54 <path[l]> yup, just accessing moonpatio :)
08:01:57 <ksf> well, the key is that I need to save objects in a structure and work on them but still wire them internally in a way that doesn't correspond at all to their layout in the structure.
08:01:58 <jmcarthur_work> kk
08:02:45 <path[l]>  http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424 http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425
08:02:59 <path[l]> now the only guess I have is that Im using the wrong data structure in haskell
08:03:09 <ksf> ...so the main driver loop can call a button's mousePressed, while another object may change its label.
08:03:13 <path[l]> but I wasnt able to get much from running the profiler :/
08:03:19 <Rotaerk> hmm to allow entities to reference one another, my state type is sort of resembling a database at this point...i.e. a set of Map SomethingID Something
08:03:39 <Rotaerk> and then a SomethingA type can hold a SomethingBID
08:03:41 <ezyang> path[l]: that seems likely.
08:04:46 <path[l]> yeah well I started with 2 lists, then I moved to an Array and an IntMap
08:04:51 <path[l]> which did help a bit
08:04:55 <path[l]> but still not enough
08:05:13 <jmcarthur_work> what exactly does this do?
08:05:21 <quicksilver> Rotaerk: yeah, I've had to do that occasionally
08:05:43 <Rotaerk> hmm cool
08:06:07 <Rotaerk> I was concerned that maybe there was some more fundamental mechanism I should be using for that kind of thing
08:06:30 <quicksilver> occasionally something more structured than a somethingID makes sense
08:06:40 <quicksilver> something more like a "path" into a structure
08:06:49 <quicksilver> but mostly a somethingID is the answer.
08:06:56 <Rotaerk> ah true
08:07:18 <jmcarthur_work> path[l], not sure if you saw my question. what exactly does this do?
08:07:58 <Rotaerk> I'm used to directly referencing objects, as is possible in mutable languages where value/object address/reference *is* the entity's identity
08:08:20 * quicksilver nods
08:08:35 <quicksilver> the haskell way separates the immutable value from the immutable id.
08:08:37 <Saizan> you could use IORefs :)
08:08:46 <quicksilver> and the "mutation" suddenly becomes possible by changing the Map
08:08:56 <quicksilver> it is one more indirection
08:08:59 <quicksilver> but the payback is worth it.
08:09:02 <endojelly> "all my code is inside IO, why?" 8)
08:09:13 <quicksilver> IdontknO
08:09:51 <SamB_XP> endojelly: because you keep trying to print ;-P
08:10:31 <endojelly> SamB_XP, I sometimes do, for debugging purposes, but I prefer the highly impure und diabolical Debug.Trace 8)
08:10:32 <quicksilver> Rotaerk: in principle you can then write a monad within which you can use a SomethingID "as if" it was a Something
08:10:46 <Rotaerk> hmm was wondering that
08:10:50 <quicksilver> Rotaerk: and you get back to something rather like the mutable language situation.
08:10:58 <quicksilver> I've never actually found that worth doing
08:11:01 <quicksilver> but it is possible.
08:11:02 <SamB_XP> endojelly: yes, very diabolical of ... augustss, wasn't it?
08:11:06 <Rotaerk> heh
08:11:16 <quicksilver> don't be fooled by his innocent face
08:11:23 <quicksilver> there is evil deep within
08:11:27 <mercury^> Can I easily construct a fusing function that takes takes n elements from list1, then m elements from list2, then n elements from list1 again... ?
08:11:28 <fasta> Do you agree that the Haskell standard libraries are a mess? Case in point, random versions of the Prelude have been generalized.
08:11:34 <endojelly> SamB_XP, don't know where it's coming from :( but it's a great help
08:11:48 <fasta> versions of functions in the Prelude*
08:12:16 <lilac> path[l]: i guess part of the problem is keeping converting back and forth between IntMap Int and [(Int,Int)]
08:12:31 <fasta> One can zip lists, but one cannot just zip arbitrary things together, even if they are the same.
08:12:42 <etpace_> "We parameterise Kleisli over the IO monad because the same idea can be use dwith any other one" <- Can anyone decrypt this sentance for me?
08:13:12 <lilac> etpace_: not without context :)
08:13:20 <Saizan> "used with any other monad"
08:13:24 <SamB_XP> etpace_: where'd you read that?
08:13:47 <etpace_> Programming with Arrows by John Hughes
08:14:06 <fasta> Wasn't the idea of Kleisli that Monads could be converted into arrows?
08:14:10 <Saizan> i assume it had Kleisli a b = a -> IO b, and then Kleisli m a b = a -> m b
08:14:22 <etpace_> He's just introduced data Kleisli m a b = a -> m b, but I didnt really understand that function
08:14:27 <Jedai> fasta: You're right, there are both pedagogical and historical reasons for that lack of generalization though
08:14:28 <fasta> I only used runKleisli once.
08:14:47 <fasta> Jedai: yes, I think I know those "reasons".
08:15:19 <quicksilver> hysterical raisins ftw
08:15:29 <SamB_XP> I want them ftl
08:15:29 <Jedai> fasta: Didn't say I agree with them though :)
08:15:33 <quicksilver> although progress does sometimes get made
08:15:35 <fasta> First year students must be able to comprehend it and "oh, wow, type-classes are really new, let's not use them".
08:15:40 <SamB_XP> and, heck, ftnix
08:15:42 <quicksilver> Foldable and Traversable are moderately new.
08:16:04 <fasta> I think zip should be varargs, by default.
08:16:24 <SamB_XP> fasta: okay, now you're getting a bit carried away with the typeclasses!
08:16:55 <SamB_XP> fasta: *I* would find the types from that hard to read ...
08:17:40 <jmcarthur_work> fasta, ZipList?
08:17:48 <fasta> jmcarthur_work: not the same.
08:17:50 <quicksilver> or just `zapp`
08:18:03 <SamB_XP> quicksilver: yeah, or that
08:18:07 <etpace_> :t zapp
08:18:09 <lambdabot> Not in scope: `zapp'
08:18:10 <lilac> > let zap = zipWith ($) in (+) `map` [1,2,3] `zap` [4,5,6]
08:18:11 <ezyang> Just looked like it. ewww
08:18:11 <lambdabot>   [5,7,9]
08:18:16 <ezyang> *looked at it
08:18:18 <SamB_XP> zapp = zipWith ($)
08:18:25 <path[l]> sorry
08:18:26 <path[l]> Im back
08:19:03 <fasta> What I really want is to be able to say zip s1 s2 s3 s4 and get a new sequence. This should of course also work for arrays and so on.
08:19:10 <SamB_XP> I mean, that's not how it's done in the paper but I don't like to write that much in my notebook so I shortened it ;-P
08:19:20 <fasta> So, basically, crazy overloading. :)
08:19:23 <lilac> fasta: varargs functions and haskell don't really mix.
08:19:48 <path[l]> ok so first jmcarthur_work well it's a problem from a website. But the idea is to take a list of numbers, split it into 2 equal sized lists (or if the original is odd, sizes differ by one), where the sum of each is as close to the other as possible
08:19:50 <jmcarthur_work> liftA4 (,,,) s1 s2 s3 s4
08:19:52 <path[l]> which is the partition problem
08:19:52 <SamB_XP> fasta: like I said, going overboard with the typeclasses you are!
08:19:56 <lilac> fasta: what's wrong with (,,,) `map` s1 `zap` s2 `zap` s3 `zap` s4
08:19:57 <fasta> lilac: by not mix, you mean that they already work and that it is a hack?
08:20:03 <SamB_XP> fasta: though I'd like to see if you can implement that!
08:20:17 <fasta> lilac: it is line-noise.
08:20:19 <path[l]> one restriction given is that each number varies between 1 and 450
08:20:28 <lilac> fasta: yes, you can do it (with overlapping and possibly incoherent instances, MPTCs and fundeps/type families)
08:20:45 <lilac> fasta: that list of language extensions should at least give a hint of how much it's a hack :)
08:21:24 <fasta> Maybe the language should be changed, such that these things are not hacks. People don't like to specify things more than once.
08:21:26 <SamB_XP> and let's not forget Oleg Cat
08:21:28 <lilac> fasta: why would you even want /want/ to zip four lists?
08:21:37 <SamB_XP> I wish those ?$?%^ things had permalinks ...
08:21:51 <lilac> fasta: 4-or-more-tuples usually indicate you're Doing Something Wrong
08:21:57 <jmcarthur_work> path[l], and could you briefly explain the algorithm you are using on a high level so i can follow the code?
08:21:58 <ezyang> ==lilac
08:22:07 <path[l]> lilac: I suppose. But given that haskell has immutable datastructures does it matter? Earlier each generation of [(Int, Int)] went to the IntMap Int .... but I couldnt get rid of duplicates
08:22:10 <fasta> lilac: 4/5/6/7 is rather arbitrary.
08:23:15 <jmcarthur_work> i keep thinking fasta's scenario doesn't sound very common to me
08:23:20 <SamB_XP> fasta: have you seeen the "iI f x1 ... xn Ii" exercise in the Idioms paper?
08:23:25 <lilac> path[l]: each time round 'solve' you convert the map to the list and back. that might hurt your performance, but i don't see the algorithm yet, so it's hard to be sure
08:23:28 <fasta> lilac: The reason for zipping in the first place is to get the separated data close to each other again.
08:23:42 <fasta> SamB_XP: I remember seeing it and not liking it :)
08:23:48 <lilac> fasta: do you have a concrete example where this comes up in practice?
08:24:04 <jmcarthur_work> fasta, what about she? you example would look like  (| (,,,) s1 s2 s3 s4 |)
08:24:06 <SamB_XP> fasta: you'd be doing something roughly as evil !
08:24:34 <lilac> jmcarthur_work: that'd be the Wrong Applicative, wouldn't it?
08:24:47 <jmcarthur_work> lilac, not if the lists are the correct type
08:24:58 <path[l]> jmcarthur_work: sure, so the idea is I try and construct a list of the given size (total size by 2). The way I do it is by constructing all possible lists of the given size. So I start from the left and pick all possible candidates for the first element (which means it cannot be too far to the end since there wont be enough elements left to complete the given list). Then I recurse and pick the second element etc. Every iteration I eleminate all lists where th
08:24:58 <path[l]> current total + the largest it can become or the smallest it can become are worse than a simple greedy heuristic solution to the problem. (sort list in order and pick every alternate element)
08:25:16 <fasta> lilac: I have a Seq (a,b,c) and a Seq d and I want to create a Seq (a,b,c,d).
08:25:28 <quicksilver> I like the she solution because it is more amenable to static type checking.
08:25:29 <lilac> jmcarthur_work: why would they be, though? if they've come from Joe Random Function, they'll be [a] not ZipList a, most likely, i would think
08:25:30 <fasta> lilac: how these values are created is not important.
08:25:45 <path[l]> my (Int,Int) structure stores a tuple of 1) the current list total 2) the last index used from the original list
08:26:10 <SamB_XP> fasta: answer: fixed-width tuple types are evil!
08:26:10 <lilac> fasta: ok, that's just a Seq.zipWith (\(a,b,c) d -> (a,b,c,d)), assuming such a zipWith exists.
08:26:15 <SamB_XP> let's go shopping
08:26:18 * EvilTerran proposes "data x :* xs = x :* !xs" and (a,b,c) as sugar for (a :* b :* c :* ())
08:26:20 <ezyang> @whats she
08:26:21 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
08:26:24 <lilac> fasta: but you still haven't explained why you want a 4-tubple
08:26:41 <sauf_> hi, everyone
08:26:44 <fasta> lilac: yes, but such a zipWith doesn't exist.
08:26:54 <SamB_XP> EvilTerran: I was just thinking about that ... but then I realized that would result in a lot more heap objects :-(
08:27:08 <fasta> lilac: ok, so, in this case I chose a solution which was biased by the code which I had at hand.
08:27:15 <path[l]> so for example if I have [9,5,4,4,1] I first pick as candidates for the first element (9,1), (5,2), (4,3), (4,4) (but not 1). I merge (4,3) and (4,4) as (4,3) using a map
08:27:24 <sauf_> i have a program that prints strings on stdin
08:27:32 <ezyang> hmmm... which feature of she is (| |) ?
08:27:41 <sauf_> how can i read them with  haskell ?
08:27:43 <Saizan> idiom brackets
08:27:50 <path[l]> on the second iteration I get (9+5,2) (9+4,3) (9+4,4) (9+1,5), (5+4,3) ...
08:28:03 <Saizan> sauf_: getLine ?
08:28:07 <ezyang> aha
08:28:32 <EvilTerran> SamB_XP, what about "data x :* xs = x :* {-# UNPACK #-} !xs"?
08:28:34 <path[l]> so eventually I should end up with (9+1) since its closest to (5+4+4) where the lists are almost the same size
08:28:35 <sauf_> Saizan: getLine needs a user, no ?
08:28:40 <lilac> fasta: as it happens, i don't think zipWith can be implemented more efficiently for Data.Seq than converting to/from []. it should be trivial to write the code to do that...
08:28:42 <ezyang> jmcarthur_work: Wouldn't the s's have to be ziplists?
08:28:44 <Saizan> sauf_: no
08:28:50 <SamB_XP> EvilTerran: I'm fairly certain that won't work either :-(
08:28:54 <EvilTerran> aww =/
08:29:27 <jmcarthur_work> lilac, ezyang: i don't think it's unreasonable to assume that the arguments are of the type with the desired behavior...
08:29:27 <SamB_XP> EvilTerran: GHC can't know what it would have to know in order to actually pull that off
08:29:41 <sauf_> Saizan: something like line <- getLine >> system "./a.out" ?
08:30:01 <path[l]> lilac:  Im confused. Everytime I take an IntMap and I construct a new [(Int,Int)] ... I have to construct a new structure anyway since haskell structures are immutable. Then this structure becomes an IntMap .... I guess I could try creating an IntMap directly .... let me think about that
08:30:02 <lilac> jmcarthur_work: i've explained why i think that's unreasonable. if you disagree, i don't think we'll reach consensus.
08:30:11 <Saizan> sauf_: uhm, maybe i misunderstood you
08:30:19 <jmcarthur_work> lilac, perhaps i missed where you said that
08:30:22 * jmcarthur_work reads up
08:30:39 <path[l]> jmcarthur_work: sorry was I clear or was that all gobbledygook. Im not sure if Ive done a good job : x
08:30:51 <jmcarthur_work> path[l], i am attempting to understand it
08:31:10 <Saizan> sauf_: if you want to run a program from within haskell and get its stdout as a String look at System.Process
08:31:11 <sauf_> Saizan: haskell has to launch the program, I should have mentioned
08:31:12 <lilac> jmcarthur_work: why would some arbitrary code produce a ZipList rather than []? that's a function of how you want to use it, not how someone else creates it
08:31:18 <path[l]> ok :)
08:31:34 <lilac> jmcarthur_work: so you /will/ have to convert it yourself if you want a ZipList.
08:31:37 <sauf_> Saizan: ok, thanks
08:31:44 <jmcarthur_work> lilac, i'm not talking about arbitrary code. you are the one calling the function expecting a ziplist, you wrap it
08:31:45 <etpace_> "lifting" is doing return right? lifting an `a' results in `f a', but whats the opposite of lifting?
08:31:59 <lilac> jmcarthur_work: right. you still need to write that wrapping, though.
08:32:03 <ezyang> jmcarthur_work: whoo, type signatures to the rescue
08:32:06 <EvilTerran> SamB_XP, i guess there'd be a risk of someone writing Mu ((:*) x) and breaking the unboxing or something...
08:32:28 <lilac> which means you're writing unZipList (| (,,,) (ZipList a) (ZipList b) (ZipList c) (ZipList d) |)
08:32:38 <jmcarthur_work> not necessarily
08:32:49 <lilac> and that's /much/ worse than (,,,) `map` a `zap` b `zap` c `zap` d
08:32:56 <mun> if i have a variable of type LibEnv, where LibEnv = Map.Map LIB_NAME DGraph, how do i get the DGraph part of it?
08:33:16 <lilac> jmcarthur_work: you have to put the ZipList somewhere, and in the place where you're doing the zipping seems like the most obvious and cleanest place
08:33:40 <lilac> in general, you may want the lists for something else, and if you do, you will want a real list which has useful operations, not a ZipList
08:34:24 <ezyang> lilac, fausta: I lost the subtelty when you started talking about a zipWith implementation in Seq. What was going on there?
08:35:02 <path[l]> lilac: if I try never to work with [(Int,Int)] (since the other method is guaranteed to fail), is there a way to map one IntMap to another IntMap where each element of the 1st map can lead to multiple elements in the second?
08:35:14 <path[l]> essentially a concatMap like thing
08:35:53 <lilac> ezyang: i'm not sure. fasta wants variadic zip, or zip for Data.Seq, or both?
08:36:02 <quicksilver> lilac: he wants both.
08:36:14 <aavogt> @hoogle Maybe (a,b) -> (Maybe a,Maybe b)
08:36:15 <fasta> lilac: both in one function. A nice programming exercise.
08:36:15 <lambdabot> No results found
08:36:20 <quicksilver> lilac: he wants to zip to work for all conceivably zippable things, and be variadic into the bargai
08:36:35 <quicksilver> well, zip for Data.Seq is on the wiki under the name zipwithTF
08:36:38 <aavogt> @hoogle m (a,b) -> (m a, m b)
08:36:38 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:36:38 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:36:59 <quicksilver> making variadic is trivial but ugly.
08:37:01 <fasta> quicksilver: yes, I am already using that, and I can implement zip3, and so on manually using that.
08:37:03 * aavogt wants an unzipMaybe
08:37:50 <ezyang> zip2, zip3, zip4 seems like a fairly common solution in Haskellworld
08:38:08 <lilac> a zip in terms of Foldable would be possible, I think?
08:38:18 <ezyang> hmmm
08:38:29 <aavogt> @type maybe (Nothing,Nothing) (Just *** Just)
08:38:31 <lambdabot> forall a a1. Maybe (a, a1) -> (Maybe a, Maybe a1)
08:38:33 <quicksilver> lilac: look at my function on the wiki ;)
08:38:41 <quicksilver> lilac: you need traversable on one side and foldable on the other.
08:38:43 <path[l]> whats a Seq as opposed to a list?
08:38:44 <lilac> i'm still of the opinion that an infix "zip some more" operator is the "right thing"
08:39:23 <ksf> lilac, if your Foldable is a Monoid, as opposed to the a of Foldable being a monoid, yes.
08:39:35 <jmcarthur_work> path[l], i'm attempting my own version of your algorithm to make sure i understand it
08:39:47 <ksf> Traversable is the right interface, as you don't have to go via hylo there.
08:40:04 <path[l]> ok :), Im sure there's a lot of stuff where Ive missed sensible shortcuts. So that would be very useful
08:44:41 <lilac> quicksilver: ok, i see how to do it with Traversable and Foldable, and why Foldable alone isn't enough. thanks! :)
08:45:21 <lilac> ksf: right, that makes sense
08:45:27 <quicksilver> lilac: yes, it was an interesting exercise, I thought.
08:45:53 <quicksilver> lilac: -- on the person who thought it was better to use a State monad than a 'self-defined' supply monad
08:46:00 <quicksilver> I was making an important point by using the supply monad.
08:46:14 <mun> if i have a variable of type T, where T = Map.Map A B, how do i get the B part of it?
08:46:14 <path[l]> hmm I see a Map.map but no Map.concatMap :/
08:46:45 <cjs> Gah. Two days until I leave for ICFP, and I've barely even started my presentation.
08:47:05 <ksf> mun, lookup?
08:47:05 <ezyang> mun: (!)
08:47:12 <jmcarthur_work> @hoogle concatMap
08:47:12 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
08:47:12 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
08:47:12 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
08:47:18 <jmcarthur_work> :t Data.Foldable.concatMap
08:47:19 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> [b]) -> t a -> [b]
08:47:22 <quicksilver> cjs: write it on the train/plane/night before
08:47:25 <jmcarthur_work> @instances Foldable
08:47:25 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
08:47:27 <ezyang> lookup is safer
08:47:28 <ksf> (!) is evil
08:47:29 <quicksilver> cjs: everyone else does
08:47:31 <jmcarthur_work> @instances Data.Foldable.Foldable
08:47:31 <lambdabot> Maybe, []
08:47:38 <jmcarthur_work> fine then
08:47:41 <c_wraith> quicksilver: that seems early.
08:47:45 <cjs> quicksilver: :-)
08:47:57 <path[l]> ah I see, this is some typeclass thing? I havent gotten to that chapter yet :o
08:48:02 <cjs> But how does one cite an IRC channel?
08:48:03 <jmcarthur_work> path[l], what would Map.concatMap do?
08:48:04 <quicksilver> cjs: although actually I always think it's very rude when presenters don't go to other people's talks because they haven't written their own yet.
08:48:11 <quicksilver> cjs: I'm old-fashioned.
08:48:24 <ksf> path[l], yes, it's easy:
08:48:28 <mun> thanks
08:48:30 <ksf> no, not at all.
08:48:38 <path[l]> jmcarthur_work: well something like every key, value pair provides a map of key, values pairs and then it merges them into a single map
08:48:38 <cjs> Actually, I'm doing my "rehearsal presentation" tomorrow night, so I've got to have the basics done by then.
08:48:41 <ksf> wait, I'm confusing mun and path[l]
08:48:54 <path[l]> but I guess it would need the function that says what happens if 2 keys have 1 value
08:48:56 * ezyang remembers when he first used Map, and got sat down for the "Monad Talk" 
08:49:05 <cjs> quicksilver: And yeah, I agree with that.
08:49:09 <SamB_XP> I'm not going to any of your presentations!
08:49:27 <ksf> Maps are isomorph to total functions.
08:49:28 <jmcarthur_work> ezyang, you make it sound like the birds and the bees
08:49:29 * cjs thinks, Poor SamB_XP!
08:49:29 <path[l]> ooops I mean if 2 values have the same key
08:49:36 <jmcarthur_work> path[l], right
08:49:39 <ksf> you pass in a value, you get a value, in finite time.
08:49:52 <lilac> jmcarthur_work: perhaps Map.concatMap :: (a -> b -> [c]) -> Map a b -> [c]?
08:50:11 <path[l]> well no I want a new map, not a list
08:50:13 <ksf> path[l], then you need to have the value type be a list
08:50:36 <ksf> ...then you want Map k (Map k v)
08:50:48 <mun> ksf, ooh
08:50:49 <path[l]> so like Map a b -> (a b -> Map a b) -> (a -> b -> b -> b) -> Map a b
08:50:49 <ksf> ...or the same with distinct ks.
08:51:11 <DekuNut> I'm sure you guys are getting sick of me now. But I'm losing my mind over this, I just can't understand concrete types in typeclasses
08:51:13 <jmcarthur_work> (a b -> Map a b) is not valid
08:51:21 <DekuNut> http://nopaste.org/p/atjuQcvg0
08:51:30 <ezyang> (a -> b -> b -> b)?
08:51:34 <path[l]> really? Why not?
08:51:34 * ezyang raises eyebrow 
08:51:35 <DekuNut> I can understand why it's 'Maybe' in the second one, 'Maybe a a' wouldn't make any sense
08:51:35 <cjs> quicksilver: So what do I really want to say of interest to that crowd in the ten minutes or so I'm given? I can't assume that they've read the paper (if previous ICFP publishing schedules are anything to go by), but I can assume they will glance at it later, drunk in their hotel rooms, if my presentation is interesting enough to remember.
08:51:50 <DekuNut> But why not just make the first one class YesNo f where yesno :: f a -> Bool
08:51:57 <DekuNut> And then instead of (Maybe a) it can be just Maybe too
08:52:04 <jmcarthur_work> DekuNut, how would you make Int and instance of YesNo that way?
08:52:07 <jmcarthur_work> *an instance
08:52:20 <DekuNut> Oh... you couldn't
08:52:27 <DekuNut> Wait, is that the ONLY reason behind it?
08:52:31 <ksf> DekuNut, that's because the "f" in Functor takes an argument.
08:52:39 <DekuNut> But you pass it 'Just 200'
08:52:40 <ksf> ...and "Maybe" takes an argument.
08:52:42 <jmcarthur_work> Int :: *      Maybe :: * -> *
08:52:42 <DekuNut> Which is a concrete type?
08:53:21 <DekuNut> I don't get it...
08:53:25 <jmcarthur_work> Maybe Int :: *
08:53:34 <jmcarthur_work> YesNo wants something of kind *
08:53:35 <ksf> :k Funktor
08:53:36 <lambdabot>     Not in scope: type constructor or class `Funktor'
08:53:39 <ksf> :k Functor
08:53:40 <DekuNut> Yeah I
08:53:41 <lambdabot> Class `Functor' used as a type
08:53:41 <jmcarthur_work> Functor wants something of kind * -> *
08:53:47 <DekuNut> Can kindof understand why one is 'Maybe' and the other is Maybe a
08:53:51 <path[l]> ok Im bad at writing types but Im think say I have the map with (1 : 2, 3: 4) -> I have a function that given 1 2 gives me (1 : 3, 3: 4) and given 3 4 gives me (3 : 2, 3 : 4), so it merges them. And for the case where 2 maps have the key 3 it calls (a -> b -> b -> b) to let me decide what value should be with 3
08:53:53 <DekuNut> If I replace the fs mentally and such
08:54:01 <DekuNut> What I don't get is, why not just change functor to like
08:54:20 <DekuNut> instance Functor (Maybe a) and fmap :: (a -> b) -> a -> b or something
08:54:32 <jmcarthur_work> would would the b be?
08:54:35 <jmcarthur_work> *what would
08:54:41 <DekuNut> Don't know, just giving an example here. That's wrong I'm sure
08:54:44 <EvilTerran> DekuNut, do you know kinds?
08:54:46 <ezyang> then your function def is wrong
08:54:50 <DekuNut> Kinds?
08:54:56 <EvilTerran> like types for types
08:54:59 <DekuNut> No
08:55:00 <EvilTerran> ?kind Int
08:55:01 <lambdabot> *
08:55:03 <jmcarthur_work> you would have (Maybe a -> b) -> (Maybe a -> b), which is not fmap
08:55:04 <ksf> DekuNut, that wouldn't be fmap anymore, that'd be id.
08:55:05 <ezyang> because, if you substitute in the Maybe, you get: fmap :: (Maybe a -> Maybe b) -> Maybe a -> Maybe b
08:55:11 <jmcarthur_work> or something
08:55:16 <jmcarthur_work> not really sure what you intended there
08:55:18 <ezyang> ==ksf
08:55:22 <EvilTerran> DekuNut, any type expression that can actually be the type of a value has kind *
08:55:37 <DekuNut> Meaning like, any concrete type right?
08:55:42 <DekuNut> I assume you mean, Int, Maybe Int, etc?
08:55:43 <EvilTerran> DekuNut, for instance, Int, (Maybe Bool), [Either Int Char], etc
08:55:50 <jmcarthur_work> * is the kind of a concrete type, yes
08:55:50 <DekuNut> Ok
08:56:06 <ksf> DekuNut, yes, exactly the same difference as between a function and a value.
08:56:11 <DekuNut> What's the point of it?
08:56:12 <ksf> one takes arugents, the other doesn't.
08:56:27 <EvilTerran> DekuNut, and a type constructor with kind (k -> l), where k and l are kinds, takes a type of kind k, and results in a type of kind l.
08:56:36 <jmcarthur_work> you just can't apply Int to an argument, just like you can't use Maybe by itself
08:56:37 <EvilTerran> ?kind Maybe -- for instance
08:56:39 <lambdabot> * -> *
08:56:59 <EvilTerran> ?kind StateT -- sometimes, they can get pretty complicated
08:57:01 <lambdabot> * -> (* -> *) -> * -> *
08:57:01 <DekuNut> So...
08:57:04 <DekuNut> Maybe takes a type
08:57:06 <jmcarthur_work> you also can't apply Maybe Int to an argument
08:57:08 <DekuNut> And returns a type
08:57:10 <DekuNut> Both concrete
08:57:12 <EvilTerran> yep
08:57:13 <jmcarthur_work> but you can apply Maybe to one
08:57:17 <path[l]> actually there are 2 functions in Map which would work I guess. There is map and there is unionsWith
08:57:22 <EvilTerran> DekuNut, the same applies for every Functor
08:57:28 <path[l]> let me try using them and getting rid of [(Int,Int)]
08:57:33 <DekuNut> Well, here's where I'm confused. I understand that you can't have like
08:57:41 <DekuNut> fmap :: (a -> b) Maybe a a -> Maybe a b
08:57:47 <jmcarthur_work> path[l], i have given it up for now, btw. i need to work. sorry
08:57:49 <DekuNut> But
08:57:55 <path[l]> ok, np
08:57:56 <DekuNut> When you use fmap, you use 'Just 200'
08:57:59 <DekuNut> Isn't that already a concrete type?
08:58:03 <DekuNut> Wouldn't that mean it's like...
08:58:05 <DekuNut> Maybe Just 200
08:58:07 <EvilTerran> it's not a type at all
08:58:08 <path[l]> thanks :)
08:58:09 <jmcarthur_work> that's not a type, it's a value
08:58:10 <DekuNut> Huh?
08:58:11 <EvilTerran> Just 100 is a value
08:58:11 <ray> you're confusing types and values
08:58:16 <ray> values have types
08:58:19 <ray> types have kinds
08:58:24 <EvilTerran> > Just 100 :: Maybe Int
08:58:25 <lambdabot>   Just 100
08:58:29 <ksf> "Just 200" is a value of type Num a => Mabybe a
08:58:29 <ray> kinds have something i forget the name of that is well outside the scope of this discussion
08:58:36 <ksf> :t Just 100
08:58:37 <lambdabot> forall t. (Num t) => Maybe t
08:58:42 <ezyang> ray: what! :-)
08:58:54 <DekuNut> Wait then...
08:59:01 <EvilTerran> ray, if you need to go beyond types and kinds, i think the norm is to just call them all sorts
08:59:03 <jmcarthur_work> in some type theories there is an infinite number of universes above types
08:59:05 <DekuNut> Ok. Correct me here because I'm sure I'm wrong
08:59:17 <ksf> but notice the "forall": "t" is already bound in that type expression, so the whole doesn't take any more arguments.
08:59:17 <DekuNut> The only reason then that I can see for using Maybe a, and not Maybe
08:59:21 <DekuNut> Is that, if you use 'Maybe'
08:59:28 <DekuNut> You can have, Maybe a, Maybe b etc, several types of Maybe
08:59:34 <jmcarthur_work> exactly!
08:59:34 <path[l]> jmcarthur_work: Ill update moonpatio with everything so far, hopefully that helps next time someone has some spare time to look at this :)
08:59:37 <ray> evilterran: that's boring
08:59:46 <DekuNut> But if you do instance Eq (Maybe a)
08:59:48 <ray> the derivative of acceleration has a name, why can't the type of kinds?
08:59:49 <quicksilver> cjs: be incisive and emphatic.
08:59:51 <DekuNut> You could only have Maybes of type a throughout?
08:59:52 <ksf> "Maybe a" by itself is already multiple types.
09:00:03 <quicksilver> cjs: explain the best things, and the worst things, of trying to use haskell for real work
09:00:07 <EvilTerran> ray, it gets kinda confusing when reading a paper that talks about "simply sorted lambda calculus" or something
09:00:19 <DekuNut> Wait, I'm confused now
09:00:21 <ezyang> ray: It's like it's turtles all the way down
09:00:24 <ray> instance Class (Maybe a) really means "for all types a, Maybe a is an instance of Class"
09:00:30 <quicksilver> EvilTerran: the word variety is sometimes used.
09:00:30 <DekuNut> jmcarthur_work, was that at me? If so then, ksf... what am I getting wrong here D:
09:00:32 <DekuNut> Oh
09:00:34 <ezyang> I find jerk amusing
09:00:35 <jmcarthur_work> DekuNut, if you pass in just Maybe it can be applied to multiple types. if you pass in Maybe Int, it cannot be
09:00:46 <jmcarthur_work> DekuNut, ksf is being a little nitpicky i think
09:00:51 <DekuNut> But (Just 200) is Maybe Int
09:01:00 <jmcarthur_work> and Maybe Int is *
09:01:10 <DekuNut> but the instance is instance Functor Maybe
09:01:10 <ezyang> well, technically, Num a => Maybe a
09:01:13 <cjs> quicksilver: I think I did most of that in my paper. I want to figure out how, in a few hundred spoken words, I can connect with this audience.
09:01:15 <DekuNut> Wouldn't it not match?
09:01:17 <jmcarthur_work> but Just 200 is not *
09:01:23 <ksf> ...and you can't do Functor (Maybe Int), for the same reason as you can't do Functor (Maybe a)
09:01:28 <ray> the Functor instance is the "f" in the type of fmap
09:01:30 <ray> not the "f a"
09:01:32 <EvilTerran> DekuNut, the parameter to Functor is given a parameter itself in the type of fmap
09:01:38 <ksf> ...Functor expects kind * -> *, not *
09:01:46 <jmcarthur_work> DekuNut, they are different levels in the type system. we have a value level, a type level, and a kind level. they do not mix
09:01:47 <DekuNut> Just it's type right?
09:01:58 <ezyang> nope
09:02:02 <EvilTerran> DekuNut, yeah, i'm talking type parameters here
09:02:05 <ezyang> Just is a constructor
09:02:09 <EvilTerran> (and/or parameterised types)
09:02:14 <jmcarthur_work> Maybe is a *type* constructor
09:02:20 <DekuNut> No ez I didn't mean Just is a type
09:02:24 <DekuNut> I meant, Just it's type is used
09:02:25 <jedediah> I have an infinite sequence that's strictly increasing, is there a function that will tell me if a given number is a member of the sequence?
09:02:26 <ezyang> ah, ok :-)
09:02:41 <Stinger> its btw
09:02:44 <EvilTerran> jedediah, (==x).head.dropWhile(<x)
09:02:49 <DekuNut> But that's what I'm confused about then, let me just er
09:02:50 <jedediah> EvilTerran: thanks
09:02:58 <DekuNut> Is I do (Just 200), Maybe Int is used right?
09:03:10 <jmcarthur_work> the type of Just 200 is Maybe Int
09:03:16 <DekuNut> But if f ( (a -> b) takes a Char and Returns I don't know... a Bool, then wouldn't the f a end up being
09:03:19 <DekuNut> Maybe Char
09:03:21 <jmcarthur_work> it doesn't mean you are using Functor (Maybe Int)
09:03:23 <DekuNut> And Maybe Int does what...
09:03:31 <EvilTerran> DekuNut, then you would get a type error.
09:03:40 <jmcarthur_work> it means you are using fmap :: (Int -> b) -> (Maybe Int -> b)
09:03:43 <EvilTerran> :t isAlpha
09:03:44 <lambdabot> Char -> Bool
09:03:47 <ray> :t fmap isAlpha
09:03:48 <EvilTerran> :t fmap isAlpha
09:03:49 <lambdabot> forall (f :: * -> *). (Functor f) => f Char -> f Bool
09:03:49 <lambdabot> forall (f :: * -> *). (Functor f) => f Char -> f Bool
09:03:57 <ray> :t stereo
09:03:58 <lambdabot> Not in scope: `stereo'
09:04:03 <ray> AND THANK GOD FOR THAT
09:04:12 <EvilTerran> stereo = join (,) ?
09:04:17 <quicksilver> cjs: well, if you can be funny, that's a bonus
09:04:17 <ray> lol
09:04:18 <DekuNut> Er...
09:04:27 <SamB_XP> > join (,) "hi!"
09:04:28 <lambdabot>   ("hi!","hi!")
09:04:33 <quicksilver> cjs: if you can find a way to connect with the frustrations that have (presumably) had with industrial programming
09:04:39 <Stinger> no thats just cheap mono reproduction
09:04:43 <quicksilver> cjs: laughing at java is normally pretty safe in an audience like that :)
09:04:59 <ksf> quicksilver, am I ignoring cjs or are you talking to yourself?
09:05:07 <ezyang> Laughing at Java... IN STEREO
09:05:09 <ray> @let stereo = join (,)
09:05:11 <lambdabot>  Defined.
09:05:13 <quicksilver> ksf: we're having a very long-latency conversation.
09:05:22 <quicksilver> ksf: you'll find his last remark addressed to me 4 mintues ago
09:05:44 <cjs> quicksilver: Not really, given that those damn Java guys have won the programming contest two years in a row....
09:05:48 <ray> it's not all that high latency for irc, just a lower latency one is going on at the same time
09:05:59 <cjs> ksf: I'm just a bit quiet.
09:06:02 <DekuNut> Ok wait, this question I hope will just answer it all for me
09:06:03 <path[l]> hmm lilac  I just cant see how to prevent the transformations :/
09:06:16 <DekuNut> jmcarthur_work, you said Maybe Int doesn't mean Maybe Int is used in Functor
09:06:19 <DekuNut> What is used then?
09:06:23 <jmcarthur_work> Maybe
09:06:34 <DekuNut> So the Int comes from somewhere else, being the first function?
09:06:38 <ray> yes
09:06:40 <ksf> ...Functor fills in Maybe's "a" later.
09:06:43 <ezyang> DekuNut: Do you understand what a Functor is?
09:06:46 <DekuNut> There, now it makes sense
09:06:54 <cjs> Anyway, I've got to go home and sleep on this. Ta!
09:06:55 <jmcarthur_work> yay!
09:06:57 <ksf> that is, as soon as fmap is used, but not before.
09:06:58 <ezyang> :-)
09:07:00 <etpace_> what's the difference between newtype and data
09:07:03 <ray> the "a" comes from the type of the argument to fmap
09:07:11 <ksf> etpace_, packing.
09:07:14 <jfoutz> cjs: i'm a java guy, where is your paper?
09:07:21 <ksf> also, whether or not you can have alternatives.
09:07:22 <ray> :t fmap id
09:07:23 <jfoutz> too slow.
09:07:23 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
09:07:26 <DekuNut> Got it, thanks. I was just seeing it all wrong
09:07:27 <ray> er
09:07:29 <jmcarthur_work> to be more precise, it is fmap that cares about the Int
09:07:31 <jmcarthur_work> not Functor
09:07:35 <DekuNut> Ok
09:07:48 <DekuNut> So all that Kinds business was just
09:07:57 <DekuNut> The kind of what Functor produces afterwards... in a way
09:08:10 <jmcarthur_work> it's the kind that Functor expects
09:08:11 <DekuNut> Or what it 'is' even
09:08:16 <DekuNut> Ok
09:08:20 <jmcarthur_work> it's only eligible to be a Functor if it has kind * -> *
09:08:30 <DekuNut> Ok, yeah I see now
09:08:31 <ray> classes expect a certain kind
09:09:05 <ray> Num wants *, Functor wants * -> *, Arrow wants * -> * -> *
09:09:06 <ksf> a newtype is a middle thing between a data declaration, which introduces a variadic struct (spoken in c terms), and a type definition, which just sets a name. with a newtype, you get a constructor so that you can't interchange your types like you can do with [Char] and String, but you don't get the runtime overhead data types imply.
09:09:07 <DekuNut> I'll read more about kinds now then
09:09:29 <etpace_> ksf: so SF a b = SF { runSF :: [a] -> [b] }, so does that just mean that the type SF has a constructor SF, which takes a ([a] -> [b]), and defines a function runSF that's (SF a b -> ([a] -> [b]))?
09:09:39 <mercury^> Huh? Is unsafeNewArray_ defined recursively (in terms of newArray, which is defined in terms of unsafeNewArray_) in Data.Array.Base or am I missing something?
09:09:58 <ezyang> etpace_: that seems to be correct
09:10:00 <ksf> yep, exactly, it works just like records.
09:10:17 <ksf> the semantics are the same as for data types, modulo "|"
09:10:30 <etpace_> ok, thanks
09:10:31 <ezyang> Note that you don't need the trailing parens
09:10:40 <ezyang> erm, the parens in your latter type signature
09:11:05 <ray> mercury^: i don't know if it is, but there's no problem with mutual recursion
09:11:32 <ksf> also, newtypes are uboxed by default iirc.
09:11:35 <mercury^> ray: if it doesn't reduce, there is.
09:11:43 <ksf> that is , SF undefined == undefined.
09:11:49 <jmcarthur_work> ksf, you mean they do not create thunks
09:11:53 <quicksilver> unboxed isn't quite the right word
09:12:02 <ksf> yes.
09:12:05 <ray> yeah, but i'm guessing it gets smaller each call
09:12:07 <quicksilver> but yes, newtypes are erased, they don't add a layer
09:12:19 <ksf> there's nothing that could box things in the first place, after all.
09:12:35 <SamB_XP> the report says that the intention is that newtypes be represented identically to the underlying types, yes ;-)
09:13:02 <ray> that's why they make good wrapper types
09:13:38 <SamB_XP> however, the report doesn't define any kinds besides *, so H98 newtypes are always boxed
09:13:48 <deniska91281> test
09:13:50 <ksf> the reason I said "unboxed" is that if you match on (SF a), as soon as SF succeeds, a does too, like with unboxed tyes.
09:14:09 <ksf> ...and if a fails, SF does, too.
09:14:12 <SamB_XP> but yeah, the newtype isn't supposed to add a box
09:14:29 <SamB_XP> if it does, that's an inefficiency of a specific implementation
09:14:52 <SamB_XP> it is roughly the same as a violation of a SHOULD directive in an RFC
09:15:35 <ksf> newtypes in combination with missing classes can be annoying.
09:15:39 <ezyang> I'm still fuzzy on data/newtype/type... so I usually just go lookup some examples
09:15:45 <SamB_XP> ksf: missing classes?
09:15:55 <ksf> e.g. bytestring-trie with newtype Foo = Foo BytesString
09:16:55 <SamB_XP> ezyang: well, newtype X a b c ... = X (...) is semantically the same as data X a b c ... = X !(...)
09:16:58 <ksf> ...with all functions taking a class TrieKey a where key :: a -> Bytestring that wouldn't happen.
09:17:29 <SamB_XP> ezyang: and type just defines a (probably shorter) alias name for a type
09:17:59 * ksf thinks it would be worthwile for h' to support making such fixes on the callee side, without writing 10000 wrappers.
09:18:06 <guruperl> Hi, guru of Haskell
09:18:10 <ezyang> Oh... there's a !() built-in?
09:18:15 <Saizan> SamB_XP: not really
09:18:34 <guruperl> Maybe somebody can help me?
09:18:43 <ksf> that is, import a module with all functions automagically wrapped in fromType and toType functions.
09:18:59 <ray> ezyang: types you can consider to be macros that get expanded
09:19:00 <EvilTerran> ezyang, ! there is a strictness annotation
09:19:13 <SamB_XP> Saizan: how so?
09:19:33 <deniska91281> hi all. any users of xmobar here?
09:19:35 <SamB_XP> Saizan: I said semantically, you know!
09:19:40 * ezyang raises hand 
09:19:43 <SamB_XP> deniska91281: was #xmonad empty?
09:19:48 <ksf> deniska91281, there are, and even more in #xmonad
09:20:12 <Saizan> SamB_XP: data D = D !X => case undefined of D _ -> () == undefined; newtype N = N X => case undefined of N _ -> () == ()
09:20:42 <SamB_XP> Saizan: oh.
09:20:46 <copumpkin> dolio: thanks for the suggestion, I'll get going on it
09:20:48 <SamB_XP> eww
09:21:01 <SamB_XP> Saizan: are you ... sure?
09:21:06 <Saizan> it's as if all the patterns were irrefutable with newtype
09:21:10 <Saizan> yeah, i'm sure :)
09:21:18 <SamB_XP> that's disgusting!
09:21:29 <Saizan> it's pretty natural that the patterns are irrefutable, the constructor isn't there!
09:21:37 <SamB_XP> yeah, yeah ...
09:21:48 <guruperl> Maybe somebody can help me with Haskell?
09:21:53 <SamB_XP> guruperl: maybe!
09:22:03 <Saizan> guruperl: only if you explain your problem
09:22:18 <guruperl> thanks!
09:22:18 <guruperl> exist plugin: http://gorgias.mine.nu/repos/xmobar/Plugins/Monitors/Net.hs
09:22:37 <guruperl> but it with a little bug:
09:22:38 <guruperl> http://code.google.com/p/xmobar/issues/detail?id=9
09:23:24 <guruperl> in this plugin exist function
09:23:24 <guruperl> -- > splitAtChar ':' ["lo:31174097","31174097"]
09:23:24 <guruperl> -- -- will become ["lo","31174097","31174097"]
09:23:55 <guruperl> BUT, when string have a space after :, this function not correctly
09:24:25 <guruperl> ["lo: 31174097","31174097"]  - not works
09:24:25 <guruperl> ["lo:  31174097","31174097"] - not works
09:24:25 <guruperl> ["lo:31174097","31174097"]  - works
09:25:06 <guruperl> so, I simple want to know, how can I fix this bug? Maybe how I can replace ":   " to ":"
09:25:54 <guruperl> or maybe other solution...
09:25:55 <guruperl> with Perl I can write one string whis regexp
09:26:12 <ksf> > read " 234" :: Int
09:26:13 <guruperl> but it's not Perl, and I don't know Haskel :(
09:26:13 <lambdabot>   234
09:26:17 <ksf> should work.
09:26:36 <Saizan> guruperl: have you tested that function?
09:26:38 <ksf> the parser is a mess, tbh.
09:26:51 <Saizan> it doesn't look like it does what you say
09:27:58 <guruperl> yes, I have test this plugin, it gets info from /proc/net/dev and show traffic & speed
09:28:02 <SamB_XP> guruperl: you've been talking to yourself a lot there ... by which I mean, writing a lot of lines in a row (our stats script calls that "talking to yourself" ;-)
09:28:11 <SamB_XP> guruperl: considered a pastebin?
09:28:12 <ezyang> What's the parse error here: h x y = x >>= (x' -> y >>= (y' -> return (x' + y'))) ?
09:28:23 <SamB_XP> @hpaste
09:28:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:28:27 <SamB_XP> @go codepad
09:28:27 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
09:28:31 <SamB_XP> !
09:28:34 <quicksilver> ezyang: -> without \
09:28:34 <Saizan> guruperl: i meant the splitAtChar function in isolation
09:28:41 <ezyang> Oh ho ho ho, gotcha
09:29:18 <guruperl> splitAtChar :: Char ->  [String] -> [String]
09:29:19 <guruperl> splitAtChar c xs =
09:29:19 <guruperl> first : (rest xs)
09:29:19 <guruperl> where rest = map $ \x -> if (c `elem` x) then (tail $ dropWhile (/= c) x) else x
09:29:19 <guruperl> first = head $ map (takeWhile (/= c)) . filter (\x -> (c `elem` x)) $ xs
09:29:30 <SamB_XP> or haskell.pastebin.com ...
09:30:13 <jfoutz> > (map $ \x -> if (c `elem` x) then (tail $  dropWhile (/= c) x) else x
09:30:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:30:25 * jfoutz sighs
09:30:44 <SamB_XP> interesting ... people submit pastebins to reddit now?
09:30:47 <zeno__> how do i get a RandomGen thats seeded based on the CPU time or whatever, not a static number like 42
09:31:05 <SamB_XP> @go IO RandomGen
09:31:06 <lambdabot> http://www.haskell.org/onlinereport/random.html
09:31:06 <lambdabot> Title: The Haskell 98 Library Report: Random Numbers
09:31:08 <SamB_XP> @hoogle IO RandomGen
09:31:08 <lambdabot> Did you mean: :: IO RandomGen /count=20
09:31:08 <lambdabot> No results found
09:31:19 <Saizan> SamB_XP: RandomGen is a class
09:31:20 <SamB_XP> @hoogle RandomGen
09:31:20 <lambdabot> System.Random class RandomGen g
09:31:25 <SamB_XP> @instances RandomGen
09:31:26 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
09:31:31 <SamB_XP> Saizan: I suspected it ...
09:31:31 <Saizan> zeno__: newStdGen
09:31:43 <Saizan> ?hoogle newStdgen
09:31:43 <lambdabot> System.Random newStdGen :: IO StdGen
09:31:43 <SamB_XP> @instances-importing RandomGen System.Random
09:31:44 <lambdabot> Couldn't find class `System.Random'. Try @instances-importing
09:31:56 <SamB_XP> @instances-importing System.Random RandomGen
09:31:57 <lambdabot> StdGen
09:32:12 <SamB_XP> hmm, I wonder if there are any other instances?
09:32:15 <ezyang> How ugly is this: g x y = y >>= return.(x+)
09:32:37 <ksf> > let splitAtChar = concat . partition (== ':') in splitAtChar ["lo: 31174097","31174097"]
09:32:38 <lambdabot>   Couldn't match expected type `[[a]]'
09:32:46 <ezyang> (I know, should use liftM2...)
09:32:59 <ksf> > let splitAtChar = concat . map (partition (== ':')) in splitAtChar ["lo: 31174097","31174097"]
09:33:00 <lambdabot>   Couldn't match expected type `[a]'
09:33:06 <ksf> > let splitAtChar = map (partition (== ':')) in splitAtChar ["lo: 31174097","31174097"]
09:33:07 <lambdabot>   [(":","lo 31174097"),("","31174097")]
09:33:22 <ksf> urks.
09:34:05 <copumpkin> ezyang: or just fmap
09:34:06 <ksf> > let splitAtChar = span (partition (== ':')) in splitAtChar ["lo: 31174097","31174097"]
09:34:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:34:16 <ksf> > let splitAtChar = map .span (== ':') in splitAtChar ["lo: 31174097","31174097"]
09:34:16 <guruperl> let splitAtChar = map (partition (== ':')) in splitAtChar ["lo:31174097","31174097"]
09:34:17 <lambdabot>   Couldn't match expected type `a -> b'
09:34:20 <jfoutz> ksf: it's the spaces
09:34:24 <ksf> > let splitAtChar = span (== ':') in splitAtChar ["lo: 31174097","31174097"]
09:34:25 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:34:43 <ezyang> oh yes, an fmap would work in this case
09:35:39 <guruperl> -- split a list of strings returning a list with:
09:35:39 <guruperl> 1. the first part of the split;
09:35:39 <guruperl> 2. the second part of the split without the Char;
09:35:39 <guruperl> 3. the rest of the list.
09:35:39 <guruperl> For instance: splitAtChar ':' ["lo:31174097","31174097"]  will become ["lo","31174097","31174097"]
09:36:20 <zeno__> Saizan: thanks
09:36:34 <zeno__> say whats the syntax for this i forgot [2,6,10...200]
09:36:44 <zeno__> counting up by 4s
09:36:47 <guruperl> but, if "lo:  3444543" - with space(s) - not works :(
09:36:48 <guruperl> splitAtChar :: Char ->  [String] -> [String]
09:36:48 <guruperl> splitAtChar c xs =
09:36:48 <guruperl> first : (rest xs)
09:36:48 <guruperl> where rest = map $ \x -> if (c `elem` x) then (tail $ dropWhile (/= c) x) else x
09:36:48 <guruperl> first = head $ map (takeWhile (/= c)) . filter (\x -> (c `elem` x)) $ xs
09:36:54 <Saizan> > [2,6 .. 200]
09:36:55 <lambdabot>   [2,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,1...
09:37:04 <zeno__> thanks
09:37:09 <Saizan> guruperl: stop pasting in channel, please
09:37:51 <Saizan> guruperl: that function does split the strings accurately, do you want to also trim the whitespace?
09:38:02 <Saizan> *Main> splitAtChar ':' ["lo:  31174097","31174097"]
09:38:03 <Saizan> ["lo","  31174097","31174097"]
09:38:08 <jfoutz> > read " 123" :: Int
09:38:10 <lambdabot>   123
09:39:21 <guruperl> yes, I want trim whitespace after :
09:40:46 <Saizan> > map (dropWhile isSpace) ["lo","  31174097","31174097"]
09:40:47 <lambdabot>   ["lo","31174097","31174097"]
09:41:11 <Saizan> that'll remove the whitespace on the front of each string
09:41:14 <ksf> read doesn't care about leading whitespace.
09:41:19 <ksf> so you don't have to do that.
09:41:25 <jfoutz> maybe it used to?
09:41:32 <Saizan> nah
09:41:42 <ksf> > read " 234"
09:41:43 <lambdabot>   * Exception: Prelude.read: no parse
09:41:46 <Saizan> so the problem is probably somewhere else
09:41:51 <ksf> > read " 234" ::Int
09:41:52 <lambdabot>   234
09:41:56 <jfoutz> ahhh.
09:42:14 <burp> > read " 345" :: Int
09:42:15 <lambdabot>   345
09:42:15 <guruperl> > map (dropWhile isSpace) ["lo:  31174097","31174097"]
09:42:17 <lambdabot>   ["lo:  31174097","31174097"]
09:42:57 <jfoutz> read " 345" :: Float
09:43:05 <jfoutz> > read " 345" :: Float
09:43:06 <lambdabot>   345.0
09:43:12 <ezyang> > map (filter $ not.isSpace) ["lo:  31174097","31174097"]
09:43:13 <lambdabot>   ["lo:31174097","31174097"]
09:43:23 <guruperl> !
09:43:29 <guruperl> looks good
09:43:50 <lilac> > read $ filter isDigit "lo:  31174097" :: Int
09:43:51 <lambdabot>   31174097
09:43:59 <ezyang> :-)
09:44:09 <ezyang> One ought to be careful with this though
09:44:20 <ezyang> > read $ filter isDigit "1234, 3423, 1232"
09:44:21 <lambdabot>   * Exception: Prelude.read: no parse
09:44:38 <ezyang> read $ filter isDigit "1234, 3423, 1232" :: Int
09:44:52 <ezyang> bah
09:44:55 <ezyang> > read $ filter isDigit "1234, 3423, 1232" :: Int
09:44:55 <lambdabot>   123434231232
09:44:57 <guruperl> ezyang, can you tell me, where I need to add this map (filter $ not.isSpace)  at splitAtChar function?
09:45:18 <ksf> you don't need to, read is already ignoring the spaces.
09:45:36 <ksf> > read " 234" ::Float
09:45:38 <lambdabot>   234.0
09:45:40 <burp> lol
09:45:43 <burp> for the 4th time
09:45:50 <ksf> ...yes, it is, even with the given type.
09:46:09 <path[l]> ok Ive dropped to 1.6 seconds which is about 30% improvement from the ruby solver. But it feels like the haskell code should be 100s of times faster or 10 times faster. Being statically typed and with no references. I dunno why its  not
09:46:37 <jmcarthur_work> i love optimization problems. i wish i had some time
09:46:38 * ezyang shrugs 
09:46:57 <ezyang> path[l]: It seems like your code is fairly algorithm-oriented, which means that static typing doesn't buy you as much
09:47:12 <path[l]> jmcarthur_work well this is gonna be on my mind for a while, so whenever you feel free is good =p
09:47:20 <jmcarthur_work> path[l], alright
09:47:49 <ksf> guruperl, fire up Net.hs in ghci and try the functions online.
09:48:17 <path[l]> ezyang: really? I assumed that the code being compiled and running at the machine level and the sheer amount of data Im moving around would mean static typing would give me an improvement. The only thing Im wondering is if the immutable type system of haskell is hurting me since I keep reallocating space
09:48:39 <ksf> ...do memory profiling
09:48:43 <jmcarthur_work> the trick is to understand that you just want to move less data around ;)
09:48:56 <ezyang> It'll shave some time off, but at some point the algorithm is the bottleneck, not your type system
09:49:26 <path[l]> jmcarthur_work: yeah, I was trying to think of ways to do that hehe
09:50:10 <path[l]> ezyang: yeah I understand I just meant, if its the same algorithm written in C and ruby, Id expect the C version to run 10 times faster. Because its the same steps
09:50:28 <path[l]> ksf:  I ran it with the profiler, but Im not quite sure what to lood for : x
09:50:52 <path[l]> GC time is 30%
09:50:58 <ksf> that's a lot.
09:51:07 <path[l]> aj
09:51:10 <path[l]> ah*
09:51:51 <yitz> @seen bos
09:51:51 <lambdabot> I saw bos leaving #ghc, #haskell and #haskell-in-depth 10h 21m 36s ago, and .
09:52:03 <guruperl> try add, and get an error:
09:52:03 <guruperl> plitAtChar :: Char ->  [String] -> [String]
09:52:03 <guruperl> splitAtChar c xs =
09:52:03 <guruperl>     map (filter $ not.isSpace)
09:52:03 <guruperl>     first : (rest xs)
09:52:04 <guruperl>         where rest = map $ \x -> if (c `elem` x) then (tail $ dropWhile (/= c) x) else x
09:52:05 <ksf> you can do all kind of memory breakdowns, so you can see how much memory a specific Type takes up over time etc.
09:52:06 <guruperl>               first = head $ map (takeWhile (/= c)) . filter (\x -> (c `elem` x)) $ xs
09:52:08 <guruperl> Plugins/Monitors/Net.hs:51:23: Not in scope: `isSpace'
09:52:26 <Berengal> path[l], do you have a problem description and a dataset?
09:52:39 <ksf> @hoogle isSpace
09:52:39 <yitz> @index isSpace
09:52:39 <lambdabot> Data.Char isSpace :: Char -> Bool
09:52:39 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
09:52:39 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
09:52:40 <lambdabot> Data.Char
09:53:49 <ksf> ...and it's map (filter $ not.isSpace) (first : rest xs)
09:55:08 <path[l]> sure
09:55:36 <path[l]> http://www.codechef.com/problems/TEAMSEL <-- Im solving that problem
09:55:55 <ksf> if in doubt, get your program added as a shootout benchmark and thus have dons hack away on it.
09:55:56 <path[l]> the haskell submissions are by me
09:55:59 * Berengal takes a gander
09:56:15 <copumpkin> Berengal: you gonna eat it?
09:56:26 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425 <--- the sample dataset I generated is here
09:56:29 <jfoutz> ksf: hahaha
09:56:30 <copumpkin> I could do with some roast goose
09:56:42 <skorpan> i read that as "root goatse"
09:56:46 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424 <--- this is the ruby thing I wrote first
09:56:48 <path[l]> lol skorpan
09:56:55 <copumpkin> skorpan: go scrub your mind out with soap!
09:57:12 <path[l]> ksf: ok let me try and look at that over dinner :)
09:57:22 <guruperl> splitAtChar c xs =
09:57:22 <guruperl>         map (filter $ not.isSpace) (first : rest xs)
09:57:22 <guruperl>         where rest = map $ \x -> if (c `elem` x) then (tail $ dropWhile (/= c) x) else x
09:57:22 <guruperl>               first = head $ map (takeWhile (/= c)) . filter (\x -> (c `elem` x)) $ xs
09:57:22 <guruperl> Plugins/Monitors/Net.hs:51:26: Not in scope: `isSpace'
09:57:25 <path[l]> shootout benchmark huh? heh
09:57:36 <Berengal> @paste
09:57:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:57:40 <Berengal> guruperl, ↑
09:57:47 <c_wraith> guruperl: please stop pasting multiple lines of code into this channel
09:58:07 <guruperl> ok, sorry
09:58:29 <burp> guruperl: import Data.Char
10:04:37 <jfoutz> path[l]: the sample seems broken.
10:05:13 <jfoutz> > (sum [3,90,200,100]) == (sum [190,200])
10:05:14 <lambdabot>   False
10:05:31 <jfoutz> oh, nevermind
10:05:39 * jfoutz reads more closely
10:07:40 <path[l]> heh
10:08:08 <path[l]> btw Im gonna make a quick update to that. Ill put up all the test cases I built for the ruby case (all the traps I fell into )
10:08:19 <path[l]> and the optimisation I did to the haskell code to get it to improve a bit
10:08:53 <c_wraith> So, this is a pretty straight-forward branch & bound problem?
10:09:00 <path[l]> yeah
10:09:18 <c_wraith> I should learn the "right" way of doing that sort of thing in haskell, too. :)
10:09:29 <path[l]> Im not really from a CS background, so I think it is =p
10:09:51 <c_wraith> Well, it sure seems like the knapsack problem, give or take.
10:09:53 <jmcarthur_work> no, it's =np  :P
10:10:07 <path[l]> haha
10:10:08 <c_wraith> meaning we don't know an approach significantly better than "check everything"
10:10:10 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424#a3427 <---- loads of test cases
10:10:35 <Berengal> I <3 the list monad for making np problems as easy as p problems...
10:10:39 <Berengal> Nondeterminism ftw
10:10:42 <path[l]> yeah but Im told its not. It's supposed to be like the partition problem, but smaller because it limits the size of the partitions
10:10:46 <copumpkin> many p problems are np problems :P
10:11:03 <copumpkin> in fact, all of them are!
10:11:03 <copumpkin> zomg
10:11:20 <Berengal> copumpkin, zomg!
10:11:28 <path[l]> yeah I was thinking whether I should start looking at the list monad way of solving this problem =p. Atleast if I understand correctly, it should move less data around
10:11:39 <ezyang> Obviously you should just turn it into SAT
10:11:49 <mdmkolbe> What is the "right" way to uninstall a package that I've installed with "cabal install"?
10:11:56 <c_wraith> I think all problems should be solved by reduction to the halting problem
10:12:02 <burp> mdmkolbe: there is none
10:12:14 <Berengal> mdmkolbe, delete it from .cabal and ghc-pkg unregister
10:12:21 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425#a3428 <--- and an improvement I made to my haskell solution
10:12:34 <burp> Berengal: why is cabal missing an uninstall command?
10:12:48 <dcoutts> burp: because you've not sent us the patches yet! :-)
10:12:49 <Berengal> burp, because it's stupid that way... I don't know, really
10:12:54 <Baughn> burp: Nobody has shown sufficient interest yet
10:12:59 <burp> ok =)
10:13:09 <Baughn> burp: It's also missing an upgrade command, for that matter..
10:13:20 * Baughn doesn't quite see why it's so /humongous/, either. ^^;
10:13:22 <c_wraith> at least you can fake that, with --reinstall
10:13:25 <roconnor> Baughn: I have sufficient interest, just not time and knowledge.
10:13:29 <Berengal> Baughn, no it's not. It's missing upgrade /functionality/
10:13:44 <Baughn> Berengal: Aheh. Right you are. ^^;
10:13:45 <dcoutts> if we had more volunteer time then cabal would be cooler and less annoying :-)
10:14:13 <roconnor> Credit Suisse needs to start chiping in.
10:14:14 <Berengal> Baughn, to be honest, that could probably be fixed in a one-line bash script...
10:14:39 <Berengal> cabal install $(cabal upgrade | grep magic-regex)
10:15:02 <dcoutts> Berengal: that's what cabal upgrade used to to, we disabled it because that's not really what you want
10:15:16 <dcoutts> too many people were shooting themselves in the foot
10:15:35 <Baughn> What we /want/ is for it to automatically recompile any dependees, too
10:15:38 <dcoutts> the more sensible behaviour is yet another TODO on a long list of TODOs
10:15:55 <Berengal> dcoutts, it's what I've done so far. It's worked well enough... not that I do it too often
10:16:09 <Baughn> What I don't get is why it's so large. I've got a functional distributed filesystem with fewer lines of code than cabal. ?_/
10:16:17 <Berengal> What was a pain was when I turned on library profiling...
10:16:29 <Baughn> ..this is probably because I haven't studied it very intently
10:16:31 <dcoutts> Baughn: it's probably a less messy problem
10:16:54 <Baughn> Hm. Could be.
10:16:55 <dcoutts> Baughn: and the Cabal code was evolved from a design that is not ideal
10:17:14 <dcoutts> but refactoring also costs volunteer time
10:17:17 <mdmkolbe> I wonder if the "functional OS" stuff at ICFP'08 (or was it '07) might be a better model for Cabal
10:17:29 <dcoutts> mdmkolbe: you mean Nix ?
10:17:35 <mdmkolbe> dcoutts: yeah
10:17:35 <Baughn> I wonder how long it'll be before we get someone who's /paid/ to deal with this stuff
10:17:43 <Baughn> It's bound to happen, if we fail badly enough
10:18:00 <dcoutts> mdmkolbe: there are many similarities and we're gradually stealing ideas from Nix, but the problems do not overlap completely
10:18:17 <dcoutts> mdmkolbe: there are things Cabal does that Nix does not, like discovering install plans using constraint solving
10:18:17 <Berengal> Baughn, aren't some people paid to work on public haskell library at work?
10:18:29 <Berengal> I'd imagine the galois people at least are
10:18:40 <Baughn> Berengal: I'm pretty sure so, yes, just apparently not core functionality like cabal
10:19:12 <Berengal> Baughn, not in a main-project fashion anyway...
10:19:13 <dcoutts> Berengal: yes, I am, via the Industrial Haskell Group, but you have to persuade commercial users that these are important problems for their business.
10:19:40 <dcoutts> mdmkolbe: with Nix you have to decide yourself exactly which versions of deps to use, cabal can work out reasonable choices automatically
10:20:02 <skorpan> someone actually uses nix?
10:20:17 <dcoutts> mdmkolbe: the way Nix stores installed packages is clearly sensible and is what cabal-install should do
10:20:24 <mun> what makes an inferred type Maybe A rather than A?
10:20:25 <Phillemann> Problems with HXT: Shouldn't "(arr (\_ -> [])) `guards` foobar" always return none?
10:20:42 <copumpkin> mun: something you're doing is causing it to think it needs a Maybe
10:20:57 <mun> copumpkin, right, have you got any example?
10:21:12 <p_l> Nix is an interesting system. The funny thing is that the only other system that uses the same principles is Windows :D
10:21:13 <skorpan> mun: i think it's better if you have an example
10:21:15 <copumpkin> mun: case x of Just y -> 5; Nothing -> 4
10:21:27 <aavogt> > (+1) $ lookup 'a' [(a,1)]
10:21:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:21:29 <copumpkin> x is inferred to be (Num a) => Maybe a
10:21:43 <mdmkolbe> dcoutts: agreed.  it would make uninstall easier (e.g. desciding which packages are no longer needed. the root-set for the GC would be those packages *explicitly* installed by the user)
10:21:50 <mun> i simply have let istate = i_state $ intState state; libenv = i_libEnv istate
10:21:53 <jmcarthur_work> :t lookup
10:21:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:21:56 <mun> it's complaining about the second line
10:22:13 <jmcarthur_work>  > (+1) <$> lookup 'a' [(a,1)]
10:22:17 <jmcarthur_work> > (+1) <$> lookup 'a' [(a,1)]
10:22:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:22:36 <dcoutts> mdmkolbe: it'd also have the nice property that you can install new packages (even additional instances of existing versions) without breaking anything
10:22:46 <mun> how do i make something that is of Maybe A to A?
10:22:48 <mun> explicitly
10:22:55 <jmcarthur_work>  > (+1) <$> lookup 'a' [('a',1)]
10:22:58 <dcoutts> mdmkolbe: ie the cabal upgrade problem goes away, you do not have to rebuild everything against the new deps
10:23:02 <jmcarthur_work> > (+1) <$> lookup 'a' [('a',1)]  -- ugh
10:23:03 <lambdabot>   Just 2
10:23:07 <Berengal> mun, maybe, or fromMaybe
10:23:09 <Berengal> @type maybe
10:23:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:23:14 <Berengal> @type fromMaybe
10:23:15 <lambdabot> forall a. a -> Maybe a -> a
10:23:16 <dcoutts> mdmkolbe: and if you do, and it breaks half way through then you still do not end up in limbo
10:23:32 <mun> thanks
10:23:35 <dcoutts> mdmkolbe: that's the Nix purity/persistence property
10:25:43 <EnglishGent> hello
10:28:12 <ksf> what happens to a thread that's waiting on a TChan which doesn't have any other writable references left?
10:28:29 <ksf> does it get killed and collected, or is it going to stay around as zombie?
10:30:12 <Berengal> ksf, "it depends" I think is the right answer, but I also think I've seen it get killed
10:31:40 <mun> hi
10:32:11 <mun> does anyone know why i'm getting a parse error on line 5 (with <-)?
10:32:30 <ezyang> copypasta?
10:32:38 <mun> oops http://haskell.pastebin.com/m6ecd78b7
10:33:23 <ezyang> ungh, I don't think you can actually do that. Have you tried converting it to desugared form?
10:33:56 <c_wraith> you can't do that in a let
10:34:02 <c_wraith> But if you just de-indent it
10:34:04 <c_wraith> it should work
10:34:06 <mun> hmm
10:34:08 <Berengal> mun, you're still inside the let there. You need to dedent to the level of the let
10:34:14 <ezyang> oh, good catch c_wraith
10:34:19 <mun> but do i not want it inside a let?
10:34:32 <Berengal> mun, you can't do that inside a let.
10:34:34 <ksf> why do you want <- to be inside a let?
10:34:35 <c_wraith> The <- operator assigns to a local name
10:34:44 <c_wraith> Isn't that the same thing the let operator is for?
10:34:57 <mun> ah ok
10:35:11 <EvilTerran> c_wraith, <- doesn't assign directly
10:35:16 <ksf> not really, the rhs of <- is monadic, its lhs is "inside" the monad.
10:35:21 <EvilTerran> it binds the result of a monadic action
10:35:22 <Lemmih> #
10:35:22 <Lemmih> #
10:35:22 <Lemmih>                  state {#
10:35:22 <Lemmih> #
10:35:30 <c_wraith> Well, no.  But it has the same effect, in many cases. :)
10:35:38 <Lemmih> Sorry.
10:35:46 <EvilTerran> Lemmih, nice work dude, you dropped the hash everywhere
10:35:47 <EvilTerran> :P
10:36:39 <EnglishGent> um... I'm confused about the module system
10:36:39 <etpace_> What function is Applicative f => (f a) -> a, as in, the opposite of return?
10:36:46 * EnglishGent just got the HList package working
10:36:52 <c_wraith> There isn't a generic one, etpace_
10:36:55 <ezyang> etpace_: no such thing
10:37:04 <ezyang> (also, it's pure in Applicative-land)
10:37:06 <EnglishGent> why is it "import HList" that works - and not "import Data.HList" ?
10:37:18 <EnglishGent> given that the code says "module Data.HList"
10:37:49 <c_wraith> And if you look at the examples of [] and Maybe, you can see why...  which value would it return from a long list?  What value would it return from Nothing?
10:37:52 <Lemmih> EnglishGent: You must be reading the wrong code.
10:37:55 <etpace_> :t (>>=)
10:37:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:38:01 <EvilTerran> , [$ty| extract |] {- etpace_ -}
10:38:04 <lunabot>  forall a b . Copointed b => b a -> a
10:38:33 <ezyang> nyeh heh heh
10:38:42 <EvilTerran> (don't ask me which module (or even which package) that's in, i have no idea)
10:38:57 <ezyang> I wonder if that's in the tcopedia
10:39:15 <EvilTerran> ?hoogle extract
10:39:15 <lambdabot> No results found
10:39:29 <ksf> that should be category-extras
10:39:32 <etpace_> so is do x <- foo, domore the same as: foo >>= (\x -> domore)
10:39:42 <ksf> etpace_, exactly
10:39:49 <EvilTerran> etpace_, that comma should be a semicolon, but yes
10:40:09 <etpace_> ok, thanks
10:40:19 <ezyang> Control.Functor.Pointed
10:40:44 <EvilTerran> etpace_, see http://haskell.org/onlinereport/exps.html#sect3.14
10:41:13 <EnglishGent> Lemmih - well unless HList is packaged with GHC (& I dont think it is) - then I'm looking from the code I fetched & set up
10:41:23 <codebliss> Can I define my own unary operator?
10:41:30 <etpace_> :t (>>)
10:41:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:41:35 * EnglishGent confesses that this is his first serious attempt to set up a Hackage package though
10:41:46 <EnglishGent> looking at*
10:42:07 <EvilTerran> codebliss, negation (-x) is a special case, i'm afraid
10:42:26 <codebliss> So I can't do not True = False; not False = True, (~) = not?
10:42:39 <c_wraith> You...  kind of can.  In some versions of GHC
10:42:40 <ezyang> You'll need to call ~ with (~)
10:42:52 <Lemmih> EnglishGent: Well, if the compiled code doesn't match the source, you /must/ be looking at the wrong source.
10:42:59 <mmorrow> , 'extract
10:43:00 <lunabot>  Control.Functor.Pointed.extract
10:43:18 <c_wraith> But only if it's a unary postfix operator
10:43:57 <c_wraith> > let (!) n = product [1..n] in (5!)
10:43:58 <lambdabot>   120
10:44:16 <c_wraith> Also, the parens are necessary :)
10:45:22 <EnglishGent> is there a way to ask ghc where it thinks the code for some package is?
10:45:46 <mmorrow> EnglishGent: what do you mean "where"? in the filesystem?
10:45:54 <EnglishGent> yes mmorrow :)
10:46:01 <EnglishGent> oh - as in what directory?
10:46:17 <EnglishGent> i.e. when I say 'import Blah' & it goes 'okay' - where did it get it from?
10:46:19 <yitz> @type let (!) n = product [2..n] in (!)
10:46:21 <lambdabot> forall t. (Enum t, Num t) => t -> t
10:46:33 <EvilTerran> codebliss, also, you can't use ~, because it's a reserved symbol
10:46:53 <EvilTerran> (not that that's particularly relevant, i guess)
10:47:00 <mmorrow> EnglishGent: maybe '$ ls $(dirname $(which ghc))/../lib/'
10:47:31 <Lemmih> mmorrow: He wants the Haskell source.
10:47:33 <codebliss> EvilTerran: Thanks!  =)
10:47:43 <mmorrow> Lemmih: oh
10:48:51 <Lemmih> EnglishGent: Look at the package. Does it mention HList in the exposed modules?
10:49:17 <Lemmih> EnglishGent: If so, look in the source directories for that file.
10:50:06 <EnglishGent> ty :)
10:50:48 <ksf> last time I tried, the hlist cabalisation was a bit dodgy
10:51:02 <ksf> that is, it didn't work out of the box with oohaskell
10:51:24 <ksf> ...most likely because whoever cabalised it couldn't be bothered to grok oleg.
10:52:03 <Lemmih> Yeah, you pretty much want to avoid HList altogether if you're not fairly experienced.
10:52:16 <path[l]> so ummm c
10:52:31 <path[l]> c_wraith, Berengal  any thoughts on that thing ? :)
10:52:32 <EnglishGent> ah... okay... I'll try some other stuff first
10:53:01 <c_wraith> Sorry, path[l].  Too busy getting stuff done at work to think about it much.
10:53:06 <path[l]> oh ok
10:53:07 <EnglishGent> only - I'm particularly interested in some of the ideas the HList paper introduces :|
10:58:41 <sauf_> it works, thanks Saizan
11:01:11 <sauf_> RWH saved me [why has it desappeared from the header ?]
11:02:10 <skorpan> it got mainstream
11:03:14 <sauf_> skorpan: no more new Haskellers awaited ?
11:03:20 <skorpan> heh, i'm kidding
11:03:56 <sauf_> skorpan: :)
11:04:08 <path[l]> :t fmap
11:04:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:04:40 <skorpan> it's too bad there weren't any good haskell tutorials when i started learning it... i feel like i had the wrong general idea of haskell for too long to ever be good at it now.
11:05:33 <path[l]> when fmap says f a -> f b, does that mean that given a function of a it can give you a function on b? or given a function that WILL take aa it will give you a function that will take a b
11:05:37 <sauf_> skorpan: don't say that, you can always progress
11:06:12 <ezyang> sort of.
11:06:28 <jmcarthur_work> path[l], it says given a container parameterized with a it gives you a container parameterized with b ;)
11:06:47 <path[l]> ah ok hmmm
11:06:58 <jmcarthur_work> where "container" is perhaps a bit more loosely defined than in most languages
11:07:00 <ezyang> There are two common ways of thinking of fmap
11:07:15 <ezyang> one is that it lifts (a -> b) into the f container, (f a -> f b)
11:07:47 <ezyang> Or that it applies (a -> b) to all of the a in f a, without changing the structure of f
11:08:13 <jmcarthur_work> i like the lifting viewpoint. it encourages functional style more nicely, in my opinion
11:08:14 <Paks> path[l]: "(Functor f) => ..." means that the "f" in "f a | f b" is a Functor not a function.
11:09:12 <sauf_> skorpan: it took me six months for my first real program but now I feel more and more confident [even though it was a very modest program]
11:09:28 <jmcarthur_work> it leads to a nice progression through Functor -> Applicative -> Monad... fmap :: (a -> b) -> (f a -> f b) ; (<*>) :: f (a -> b) -> (f a -> f b) ; (=<<) :: (a -> f b) -> (f a -> f b)
11:09:31 <ezyang> jmcarthur_work: Yeah, I think of it as the "one true viewpoint".  But from a practical standpoint if I'm trying to find out the nitty gritty of what something inside a functor is doing, the latter is useful
11:10:00 <ezyang> in other news
11:10:05 * ezyang doesn't understand at all http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/ 
11:10:31 <path[l]> so when you say lifts (a -> b) into the f container its the same as saying, it applies the function on every element in the container?
11:10:42 <jmcarthur_work> path[l], if it is that sort of container
11:10:42 <path[l]> I guess I dont understand "lift" yet
11:10:49 <sauf_> skorpan: when did you start learning Haskell ?
11:11:10 <skorpan> sauf_: 2004 at my university
11:11:29 <skorpan> we have great professors, but i guess i didn't pay enough attention at the lectures
11:11:43 <ezyang> It's kind of abstract.  I don't claim to understand it in general, just in a bunch of specific cases
11:12:08 <path[l]> hmmm
11:13:03 <ziman> > fix (const 5)
11:13:04 <lambdabot>   5
11:13:41 <sauf_> skorpan: I started seven month ago and I read a lot things but the actual confidence came from the reading of Learn you a Haskell and of TypeClassOPedia
11:13:56 <path[l]> the more I look at using the list monad for backtracking the more it looks like it's not some magical solution to my problem, but pretty much what I was doing already
11:14:08 <path[l]> I hope I havent understood it right =p
11:14:11 <babusrini> For e.g., if you have a Tree structure where each node is a String, you can use fmap to convert it to another Tree where each node is an integer with value equal to the length of the String at that node.
11:14:17 <skorpan> sauf_: i read them both, but i have trouble realising when to apply what i've read to actual code
11:14:46 <path[l]> babusrini:  yeah I get that example, thanks :). Seeing f there confused me
11:15:14 <sauf_> skorpan: do you write programs or do you just read in an abstract way ?
11:15:33 <ezyang> Functors that are more like traditional containers are a good example that are relatively easy to understand.
11:15:48 <ezyang> Functions as functors I've always found kind of tricky
11:16:02 <copumpkin> how so?
11:16:04 <skorpan> sauf_: i took a "self insight test" (that's what they called it) at a conference with my company the other day and apparently i was better at learning by examples than abstract thinking...  if the test is right, i guess that's my problem.
11:16:32 <EvilTerran> path[l], have you seen "you could have invented monads"?
11:16:37 <EvilTerran> ?go you could have invented monads
11:16:38 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:16:38 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
11:16:49 <path[l]> not yet, its in my list :)
11:17:08 <ezyang> copumpkin: Because the usual intuition with containers breaks horribly for me, and I have to do a gear shift to think of it in another way
11:17:38 <copumpkin> ezyang: break away from your container-walled prison!
11:17:45 <ezyang> :-)
11:17:54 <mauke> ezyang: I just think of functions as containers
11:18:00 <mauke> PROBLEM SOLVED
11:18:04 <ezyang> Right. That intuition actually works ok for fmap
11:18:22 <ezyang> bind knots me up though
11:18:31 <jmillikin> Does anybody know of a good introduction to using Coq for proving Haskell code? I read a dons post on Reddit about XMonad containing a proof of correctness for StackSet, but am having some trouble figuring out how to build such a proof for my own code.
11:18:31 <ksf> so, containers are functions, where's the problem?
11:18:33 <sauf_> skorpan: I'm like you : you should try some of the problems of Project Euler with any language and read the Haskell solutions after in the comments
11:18:38 <copumpkin> it's a container whose value depends on what you stick into it :P
11:18:45 <mauke> bind is just join .: fmap
11:18:55 <mauke> copumpkin: i.e. a map
11:19:08 <ezyang> :t (.:)
11:19:09 <lambdabot> Not in scope: `.:'
11:19:18 <copumpkin> mauke: zomg
11:19:19 <mauke> (.:) = (.) . (.)
11:19:40 <mauke> ezyang: bind f m = join (fmap f m)
11:19:54 <ezyang> and...
11:20:08 * EvilTerran likes "containers are concrete functions"
11:20:21 <ezyang> I believe join in the function context is just evaluating the outer function with the unwrapped m?
11:20:32 <ezyang> erm, no
11:20:51 <ezyang> evaluating the outer function with the variable that it's indexed by, or whatever that's called
11:21:07 <ezyang> maybe some vocabulary would help here
11:21:16 <copumpkin> join f x = f x x
11:21:17 <mauke> f (m x) x
11:21:30 <ziman> i like this (not that i understand it fully):
11:21:35 <ziman> @pl \x -> x * x + x
11:21:35 <lambdabot> (+) =<< join (*)
11:21:38 <etpace_> :t (>>=)
11:21:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:22:10 <c_wraith> no one's DOSing lambdabot today?
11:22:45 <PeakerWork> @type (^2) >>= (+)
11:22:46 <lambdabot> forall a. (Num a) => a -> a
11:22:55 <ksf> its not "in the function context" but "in the application context"
11:23:19 <mauke> > (g >>= f) x
11:23:20 <lambdabot>   Add a type signature
11:23:24 <mauke> > (g >>= f) x :: Expr
11:23:25 <lambdabot>   Add a type signature
11:24:17 <mauke> > (g >>= (f :: Expr -> Expr -> Expr)) x
11:24:18 <lambdabot>   f (g x) x
11:24:31 <PeakerWork> so you need:  (a -> a) -> (a -> a -> a) -> a -> a
11:24:37 <PeakerWork> which matches (>>=) for functions
11:24:44 <tibbe> what's Yitz handle?
11:24:56 <ksf> > (g >> (f :: Expr -> Expr)) x
11:24:57 <lambdabot>   Add a type signature
11:24:59 <PeakerWork> (for the    join (*) >>= (+)   which is really   (^2) >>= (+) )
11:25:03 <ksf> > (g >> (f :: Expr -> Expr -> Expr)) x
11:25:05 <lambdabot>   Add a type signature
11:25:12 <ksf> > (g >> (f :: Expr -> Expr )) x :: Expr
11:25:14 <lambdabot>   Add a type signature
11:25:19 <mauke> ksf: g is underspecified
11:25:30 * ezyang is pleasantly lost 
11:25:48 * ksf too
11:25:56 <Deewiant> > ((g :: Expr -> Expr) >> f) x :: Expr
11:25:58 <lambdabot>   f x
11:26:22 <ksf> ...so do-notation doesn't make any sense, at all.
11:26:29 <mauke> haha
11:27:13 <mauke> > do { let {f' = f :: Expr -> Expr -> Expr}; y <- g; f' y } x
11:27:14 <lambdabot>   <no location info>: parse error on input `x'
11:27:18 <mauke> > do { let {f' = f :: Expr -> Expr -> Expr}; y <- g; f' y } $ x
11:27:20 <lambdabot>   f (g x) x
11:27:29 <ezyang> uggggh
11:27:58 <ezyang> actually, no, that's not too bad
11:28:09 <ezyang> since you've managed to get rid of the x
11:28:14 <EvilTerran> ksf, do-notation does make sense, it's just commands with no <- that serve no purpose
11:28:36 <mauke> y is the hypothetical result of g
11:29:05 <mauke> f' y is the hypothetical result of applying f to y
11:29:12 <ezyang> yep
11:29:48 * ksf still doesn't get why Monad (->) could be useful except for pointless style.
11:30:00 <ksf> Functor (->) has a lot of uses.
11:30:31 <ksf> ...in point-free style, that is, as opposed to pointless.
11:30:47 <mauke> Functor (->) is just (.)
11:31:13 <ksf> yep, but you don't want to write ((.).(.).(.).(.))
11:32:00 <ksf> ...escpecially if not all your Functors are (->)s
11:32:46 <SamB> wierd ... someone made a type-inferred imperative language with ADTs ...
11:32:48 <ezyang> hmmm... what is the equivalent of (.).(.).(.).(.) with functors?
11:32:57 <ksf> ...the last one is commonly a list or either or maybe, maybe wrapped in a monad
11:33:01 <ray> fmap fmap fmap fmap fmap fmap fmap fmap?
11:33:03 <therp> EHC/UHC is really beautiful inside.
11:33:03 <ksf> (fmap.fmap.fmap)
11:33:12 <Stinger> @ty (.).(.).(.).(.)
11:33:13 <lambdabot> forall a a1 a2 b c a3. (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
11:33:15 <ezyang> ehh, not actually helpful ;-)
11:33:18 <ksf> peter has written a quick tutorial about it.
11:33:20 <ray> fmap `fmap` fmap `fmap` fmap
11:33:23 <ray> :D
11:33:29 <ezyang> s/helpful/less verbose/
11:33:31 <mauke> :t [ fmap fmap fmap fmap fmap fmap fmap , (.).(.).(.).(.) ]
11:33:32 <lambdabot>     Occurs check: cannot construct the infinite type:
11:33:32 <lambdabot>       b = a -> a1 -> a2 -> a3 -> b
11:33:32 <lambdabot>     Probable cause: `.' is applied to too few arguments
11:33:35 <SamB> :t (`fmap`)`fmap`(`fmap`)`fmap`(`fmap`)`fmap`(`fmap`)
11:33:36 <lambdabot> parse error on input `)'
11:33:49 <mauke> :t [ fmap fmap (fmap fmap (fmap fmap fmap)) , (.).(.).(.).(.) ]
11:33:51 <lambdabot> forall a a1 a2 b c a3. [(b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c]
11:34:11 <SamB> :t fmap `fmap` fmap `fmap` fmap` fmap` fmap
11:34:12 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
11:34:58 <SamB> :t [fmap `fmap` fmap `fmap` fmap` fmap` fmap, (.).(.).(.).(.) ]
11:35:00 <lambdabot> forall a a1 a2 b c a3. [(b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c]
11:35:09 <Toxaris> ksf: since -> is isomorphic to Control.Monad.Reader, it should have the same uses, shouldn't it?
11:35:20 <SamB> :t fmap . fmap . fmap . fmap
11:35:21 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
11:35:31 <ksf> but Reader as ask
11:35:42 <Toxaris> ksf: -> has ask too
11:35:47 <SamB> @pl fmap `fmap` fmap `fmap` fmap` fmap` fmap
11:35:48 <lambdabot> (line 1, column 29):
11:35:48 <lambdabot> unexpected "`"
11:35:48 <lambdabot> expecting letter or digit, variable, "(", letter, digit, "!!", ".", operator or end of input
11:35:55 <ksf> ...its reader instance, yes.
11:36:02 <ezyang> $
11:36:04 <ezyang> ?
11:36:11 <SamB> @pl fmap `fmap` fmap `fmap` fmap `fmap` fmap
11:36:12 <lambdabot> fmap `fmap` fmap `fmap` fmap `fmap` fmap
11:36:14 <mauke> ezyang: ($) = id
11:36:36 <ksf> @src ($)
11:36:36 <lambdabot> f $ x = f x
11:36:38 <ksf> @src id
11:36:38 <lambdabot> id x = x
11:36:42 <ksf> nope.
11:37:12 <ezyang> @type ask
11:37:13 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
11:37:17 <mauke> modulo bottom
11:37:19 <opqdonut> :t fmap `fmap` fmap `fmap` fmap `fmap` fmap
11:37:20 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
11:37:21 <ray> > f `id` x
11:37:22 <lambdabot>   Add a type signature
11:37:31 <ray> > f `id` x :: Expr
11:37:32 <lambdabot>   f x
11:37:35 <ray> WELL
11:37:58 <ezyang> what
11:38:17 <mauke> @check \a b -> id a b == ($) a b
11:38:19 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a)
11:38:19 <lambdabot>    arising from a use of ...
11:38:29 <mauke> aww
11:38:47 <ezyang> I'm not even sure what the question is anymore
11:38:55 <ray> what question
11:39:05 <ezyang> Exactly.
11:39:05 <mauke> 42
11:39:06 <monochrom> There is no question.
11:39:16 <ray> fmap fmap
11:39:24 <ray> doo doo  doo doo doo
11:40:03 <monochrom> pi pi pi
11:40:56 <monochrom> pi and id are almost 180-degree rotations of each other.
11:42:05 <opqdonut> p! id
11:42:08 <ksf> @check 2 * pi * pi == id
11:42:09 <lambdabot>   No instance for (GHC.Float.Floating (a -> a))
11:42:09 <lambdabot>    arising from a use of `GHC...
11:42:16 <opqdonut> ksf: ... :D
11:42:21 <monochrom> heh
11:43:26 <bavardage> how would I swap two elements of a list
11:43:42 <bavardage> swap [1,2,3,4] 1 2  = [1,3,2,4]
11:43:56 <ksf> heh I once did that.
11:44:10 <bavardage> my attempt is getting uglier and uglier
11:44:26 <mauke> it's an ugly problem
11:44:42 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3886
11:45:33 <bavardage> ksf: move?
11:45:42 <ksf> yep
11:46:22 <bavardage> hmm
11:46:32 <Lemmih> bavardage: I'd write 'deleteAt' and 'insertAt'.
11:46:34 <bavardage>  No instance for (Functor ((,) [Integer]))
11:46:51 <mauke> missing import?
11:46:55 <bavardage> quite likely
11:47:05 <bavardage> yeah, I'll think I'll make a listSlice function
11:47:06 <ksf> move is composed out of those
11:47:08 <bavardage> and kinda do that
11:47:31 <bavardage> just ensuring there's not a really clever way to do it
11:47:42 <mauke> the clever way is not to use lists for this
11:49:12 <bavardage> heh
11:49:15 <bavardage> what should be used instead?
11:49:29 <EvilTerran> Seq?
11:50:21 <mauke> maybe an array or a map
11:50:53 <ksf> arrays aren't much better.
11:50:58 <EvilTerran> you may be able to do something sneaky with a fingertree
11:51:08 <ziman> IntMap?
11:51:52 <ksf> in the numberedMV case, the problem with a map is that it's supposed to collapse numbers.
11:52:35 <ksf> anyway, if you're doing another thing as list, you're quickly introducing an index into your semantics which wasn't there before.
11:53:08 <ksf> ...and IntMaps have the property of likely being sparse.
11:57:28 <PeakerWork> > let replace i new xs = before ++ [new] ++ after where (before, _:after) = splitAt i xs ; swap xs i1 i2 = replace i1 (xs!!v2) . replace i2 (xs!!v1) in swap [1,2,3,4] 1 2
11:57:29 <lambdabot>   Not in scope: `v2'Not in scope: `v1'Not in scope: `swap'
11:57:42 <PeakerWork> > let replace i new xs = before ++ [new] ++ after where (before, _:after) = splitAt i xs ; swap xs i1 i2 = replace i1 (xs!!i2) . replace i2 (xs!!i1) in swap [1,2,3,4] 1 2
11:57:43 <lambdabot>   Not in scope: `swap'
11:57:46 <pr> @type join (+)
11:57:48 <lambdabot> forall a. (Num a) => a -> a
11:57:55 <pr> > join (+) 10
11:57:56 <lambdabot>   20
11:58:11 <PeakerWork> > let replace i new xs = before ++ [new] ++ after where { (before, _:after) = splitAt i xs } ; swap xs i1 i2 = replace i1 (xs!!i2) . replace i2 (xs!!i1) in swap [1,2,3,4] 1 2
11:58:12 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
11:58:12 <lambdabot>    arising from a use ...
11:58:29 <PeakerWork> > let replace i new xs = before ++ [new] ++ after where { (before, _:after) = splitAt i xs } ; swap xs i1 i2 = replace i1 (xs!!i2) . replace i2 (xs!!i1) $ xs in swap [1,2,3,4] 1 2
11:58:30 <lambdabot>   [1,3,2,4]
11:58:37 <PeakerWork> bavardage: here it is
11:58:56 <pastorn> can i make a typeclass for e.g. Functors holding Ints?
11:59:01 <etpace_> how does that work pr? isnt join Monad m => m m a -> m a?
11:59:10 <pr> @type join
11:59:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:59:13 <PeakerWork> pastorn: Functors holding Nums, you mean?
11:59:28 <pastorn> PeakerWork: no, i wanna drop the 'a'
11:59:33 <PeakerWork> pastorn: Why not use types like:  Functor f => f Int ...
12:00:02 <pastorn> PeakerWork: i'm making a gridbased game, trying out different implementations, for performance
12:00:04 <byorgey> etpace_: m (m a), not m m a
12:00:05 <pr> etpace_: well, actually functions form a monad, too :)
12:00:23 <byorgey> etpace_: and the  m  in question in pr's example is  (Int ->)
12:00:32 <pr> etpace_: e.g. fmap is just function application = (.)
12:00:32 <pastorn> so i'm making typeclasses so that i don't have to change the implementation of the actual game later
12:00:33 <etpace_> (e -> e -> a) -> (e -> a)
12:00:34 <pr> IIRC
12:01:26 <etpace_> so join f = (\x -> f x x)?
12:01:37 <byorgey> etpace_: exactly.
12:02:05 <pastorn> PeakerWork: so i have a Grid-class and have an instance of it for "data L a = L { lGrid :: [[a]], size :: (Int,Int) , ...}", but now i want to have class for (Grid g) => g MyGamePanelType
12:02:18 <zeno__> trying to use the example at
12:02:37 <zeno__> http://hackage.haskell.org/packages/archive/happstack-util/0.3.2/doc/html/Happstack-Util-Mail.html but it hangs forever
12:02:59 <pastorn> is what i'm trying to do possible?
12:04:23 <Lemmih> zeno__: Do you have access to a smarthost which can relay all your mail?
12:04:33 <PeakerWork> pastorn: how is a Grid class defined?
12:04:42 <dschoepe> Can someone give me another hint on how to solve the exercise from(just hint please, not a full solution): http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Least_Fixed_Point
12:05:10 <zeno__> Lemmih: theres no mailserver, i want to send mail from a haskell program without
12:05:38 <Lemmih> zeno__: That's not an easy thing to do.
12:06:40 <zeno__> Lemmih: can it jsut open a socket and send or something?
12:06:40 <pastorn> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8617
12:07:50 <nlogax> any idea if the next release of the haskell platform will support mac os 10.6?
12:07:57 <Lemmih> zeno__: Not really.
12:08:20 <monochrom> dschoepe: Each g(g(...g(x0)...)) ⊑ any fixed point. Then sup ⊑ any fixed point too.
12:08:26 <zeno__> Lemmih: ah ok.  would http://hackage.haskell.org/packages/archive/SMTPClient/1.0.1/doc/html/Network-SMTP-Client.html work then?
12:08:26 <sm> nlogax: seems unlikely it wouldn't.. doesn't the current one ?
12:08:56 <nlogax> sm: no, there's some problem with the 64 bitness, iirc.
12:09:02 <zeno__> or do i need a smtp SERVER?
12:09:04 <sm> ack
12:09:06 <nlogax> or maybe it's already fixed? :o
12:09:19 <Lemmih> zeno__: It'll do what it's supposed to do. Doubt it is what you want.
12:09:44 <sm> nlogax: probably worth checking the tracker/reporting
12:09:59 <dschoepe> monochrom: Isn't that what I have to prove? that g(g(g(g(..)))))) ⊑ any other fixed point.
12:10:10 <pastorn> PeakerWork: does that seem allright?
12:10:12 <sm> or pinging.. who is it.. jeffersonheard ?
12:10:35 <PeakerWork> pastorn: sorry, I'm a bit busy at work, will look at it when I get a chance
12:11:08 <nlogax> http://hackage.haskell.org/trac/ghc/ticket/3400#comment:1 a-ha
12:11:09 <monochrom> No. I mean this. x0 ⊑ blah. g(x0) ⊑ blah. g(g(x0)) ⊑ blah. And so on. Prove all of them.
12:11:36 <monochrom> This is why "..." is not math.
12:11:54 <pastorn> PeakerWork: cool, you're an angel
12:12:15 <zeno__> Lemmih: what would be a way to send email even if the user doenst have a mail server installed?
12:12:22 <sm> nlogax: I meant gregory collins
12:12:28 <sm> mac osx platform packager
12:12:41 <monochrom> Define x0=⊥, x(n+1)=g(xn). Prove ∀n. xn ⊑ blah.
12:12:42 <sm> yay
12:13:10 <PeakerWork> pastorn: I looked.. First, I'd   type Cursor = (Int, Int)  or such.  Second, I don't see why the Grid class has a cursor, it seems unrelated to what it's doing, and perhaps should be in another class, perhaps HasCursor or such.  Also, maybe the cursor/size types can be associated, rather than hard-coded to (Int, Int).   Also, seems like the size implementation can have a default in the class..
12:13:20 <Lemmih> zeno__: Invoke 'sendmail' and prey they have configured it properly.
12:13:30 <PeakerWork> pastorn: do you know type families?
12:13:40 <zeno__> Lemmih: hmm, i need this to work on windows though
12:13:51 <pastorn> PeakerWork: not really
12:13:55 <monochrom> The least fixed point is not "g(g(g(g(..))))))" anyway.
12:14:02 <Lemmih> zeno__: Then you're boned.
12:14:20 <dschoepe> monochrom: yes, it the sup ⊑ of that, right?
12:14:39 <PeakerWork> pastorn: in a class Matrix m, for example, you can use "type Index m", and then each instance defines what the Index type for that Matrix instance is.  So for example [[a]]'s index type can be an (Int, Int)
12:14:52 <monochrom> "it the sup"?
12:15:14 <pastorn> oh, cool
12:15:34 <PeakerWork> pastorn: I think a multi-dimensional matrix type could be more generic and nicer than a specifically 2d-grid, and with associated types, just as efficient when concrete types are used, maybe
12:15:49 <PeakerWork> pastorn: And again, I'd take the "focus" thing out of there
12:16:03 <pastorn> PeakerWork: that is for future stuff
12:16:23 <PeakerWork> pastorn: I understand, but it seems unrelated, it should either be in a sub-class, or just completely separate
12:16:31 <dschoepe> monochrom: hmm, just to make sure I understand correctly what I have to do: I have to show that sup_⊑ { x0 ⊑ g(x0) ⊑ g(g(x0)) .. } is the least fixed point right?
12:16:35 <pastorn> ok
12:16:46 <pastorn> where can i find this matrix type/class?
12:17:07 <monochrom> No. You have to show sup_⊑ { x0 ⊑ g(x0) ⊑ g(g(x0)) .. } ⊑ any fixed point.
12:17:19 <PeakerWork> pastorn: also, if you have a mutate-grid there its likely that you want to do it in some monad, for some mutable array, the pure type: g a       -> ((Int,Int), a) -> g a       seems to force inefficiency in many cases.   Also, its nicer to have (g a -> g a) as the end type, because you get a "Grid transformer" that way after partially applying the other args
12:17:25 <PeakerWork> pastorn: I don't know if one exists :)
12:17:29 <PeakerWork> pastorn: but probably stuff on hackage
12:17:39 <dschoepe> monochrom: isn't that the same as saying it's the _least_ fixed point?
12:17:56 <monochrom> No. You are not asked to show that it is a fixed point.
12:18:37 <pastorn> PeakerWork: you mean i should write my stuff as State (MyGrideType) a?
12:18:49 <monochrom> And do not think that you could kill two birds with one stone. All known proofs have to kill the two birds separately.
12:18:57 <PeakerWork> pastorn: do you know MArray?
12:19:01 <dschoepe> monochrom: ah, okay.
12:19:06 <PeakerWork> pastorn: There's a class for mutable arrays and operations on those
12:19:18 <PeakerWork> pastorn: allowing you to get efficient array mutations in monads/arrays that support them
12:20:13 <pastorn> PeakerWork: actually i don't think i'll be manipulating anything in my grid :0
12:20:14 <pastorn> :)
12:20:28 <pastorn> PeakerWork: have you tried LightBot (flashgame)
12:20:28 <PeakerWork> pastorn: then you probably shouldn't have (!!=) ... :)
12:20:35 <PeakerWork> nope
12:21:05 <pastorn> well, in an 8x8 grid, i will manipulate 5 panels, tops, per session
12:21:10 <PeakerWork> pastorn: oh, I did
12:21:16 <EvilTerran> hm... simply-kinded types?
12:21:21 <PeakerWork> pastorn: why do you need a type-class?
12:21:29 <PeakerWork> pastorn: if you have a single concrete type you're using?
12:21:32 <pastorn> so i was thinking, as the ultimate solution, an Array with a list of lit up panels
12:21:52 <PeakerWork> pastorn: I like Map's
12:21:59 <PeakerWork> pastorn: cheap to manipulate, cheap to look up, easy to work with
12:22:08 <PeakerWork> pastorn: a Data.Map of lights to their state, for example
12:22:14 <pastorn> PeakerWork: because hacking that very fast array type is gonna be loads of work, so i'd rather wait as long as possible
12:22:32 <PeakerWork> pastorn: why not a Data.Map?
12:22:43 <pastorn> Not fast enough
12:22:45 <pastorn> :p
12:23:25 <pastorn> and i want to leard how to use the array types
12:23:27 <tkr> what does $=  mean in haskell?
12:23:35 <trofi> :t ($=)
12:23:37 <lambdabot> Not in scope: `$='
12:23:41 <pastorn> @hoogle ($=)
12:23:41 <lambdabot> No results found
12:23:44 <jmcarthur_work> nothing without a library that defines it
12:23:46 <Taejo> tkr: it's specific to HOpenGL
12:23:49 <tkr> ahh.
12:23:50 <pastorn> @google ($=) haskell
12:23:51 <lambdabot> http://www.haskell.org/
12:23:51 <lambdabot> Title: Haskell - HaskellWiki
12:23:54 <ziman> tkr, AFAIk it's a custom operator used in some GL libs
12:23:56 <tkr> it was from opengl example
12:24:03 <jmcarthur_work> it's in its own library now, i think
12:24:08 <jmcarthur_work> not in opengl proper
12:24:18 <Taejo> ohk
12:24:18 <dschoepe> monochrom: Thanks a lot, I think I got it: x0 ⊑ f is the base case of the induction and with g being monotone, I show that g(x_n) = x_n+1 ⊑ g(f). (And since f is a fixed point, as shown before, g(f) = f). Is that correct?
12:24:33 <zeno__> Lemmih: so should the installer for my program also install http://www.softstack.com/freesmtp.html ?
12:24:46 <tkr> thanks Taejo, ziman  :)
12:24:51 <jmcarthur_work> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
12:24:56 <jmcarthur_work> tkr, ^^
12:25:19 <Lemmih> zeno__: You don't need an SMTP server.
12:25:21 <zeno__> oh wait happs has one!
12:25:25 <monochrom> dschoepe: Yes
12:25:30 <zeno__> Lemmih: hmm? they how do i send mail?
12:25:40 <zeno__> in windows from a haskell program
12:25:50 <Lemmih> zeno__: You don't, sorry.
12:25:51 <pastorn> PeakerWork: i will take all you said into consideration and get cracking
12:25:57 <PeakerWork> pastorn: what do you need the speed for?
12:26:02 <PeakerWork> pastorn: Lightbot?
12:26:03 <tkr> jmcarthur_work: ah. excellent! thanks a bunch. :)
12:26:25 <pastorn> PeakerWork: drawing, lookups of panels
12:26:34 <dschoepe> monochrom: Okay, so I guess I learned "get rid of any '...' before attempting any proof" from this :)
12:26:36 <tkr> jmcarthur_work: I thought they had something to do with monads, because I dont know monads yet. :)
12:26:47 <PeakerWork> pastorn: you draw hundreds, maybe thousands of pixels for each map lookup, I doubt the speed is an issue
12:26:52 <etpace_> :t (.&.)
12:26:53 <PeakerWork> pastorn: map lookup is pretty quick, too
12:26:53 <lambdabot>     Ambiguous occurrence `.&.'
12:26:54 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
12:26:54 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
12:26:56 <zeno__> Lemmih: i really doubt its impossible.
12:27:05 <pastorn> PeakerWork: pixels? niggah plz
12:27:13 <pastorn> VTY is my only true love
12:27:13 <zeno__> i can just have them run happs
12:27:15 <PeakerWork> pastorn: what do you do per-panel?
12:27:36 <pastorn> 5x3 characters
12:27:37 <PeakerWork> pastorn: and how many times do you do it? I can't imagine how a game like lightbot will have performance issues
12:27:51 <pastorn> PeakerWork: no, that's what i'm making sure
12:28:01 <pastorn> this is just some premature optimizations
12:28:08 <PeakerWork> pastorn: use Data.Map, it will be faster than arrays if you actually update it
12:28:21 <PeakerWork> pastorn: Data.Map is really easy, even easier than a [[a]] for this purpose
12:28:40 <pastorn> yeah, i know, i've used it lots of times, so it's a bit boring
12:28:45 <jmcarthur_work> tkr, you don't know what something is  ==>  it must be a monad?  ;)
12:29:08 <PeakerWork> tkr: ($=) does create a monadic action
12:29:14 <PeakerWork> (in GL)
12:29:24 <pastorn> i wanna learn new stuff, hence, if i later find out that my way is the wrong way, my cool typeclass hackings will make it way to easy to go to a Map-based structure :)
12:29:47 <jmcarthur_work> i jest, of course
12:30:05 <PeakerWork> pastorn: the purpose of type-classes isn't to make it easier to change your representation :)  You can use an abstract data type for that
12:30:10 <Lemmih> zeno__: Well, the best of luck them.
12:30:14 <Lemmih> *then
12:30:37 <pastorn> PeakerWork: purpose/use, what's the difference?
12:30:59 <PeakerWork> zeno__: what do you mean by "send mail"? Connect to an SMTP server/etc?
12:31:14 <tkr> jmcarthur_work: not that way exactly. :) Im not that far in the tutorials and it appearead in the myInit :: IO () section. that was the main hint :D
12:31:22 <pastorn> i'm using it because my design choices aren't final, so if i find out later i did shitty choices i won't be in as much shit
12:31:33 <jmcarthur_work> pastorn, i think he means a type class doesn't hide an implementation
12:31:42 <PeakerWork> pastorn: type-classes have disadvantages. When you have a single concrete type at hand, its probably better to use a concrete type.. You don't know yet in what dimension/direction to generalize into a type-class yet
12:32:01 <PeakerWork> pastorn: If you want to make sure the code is easy to update later, abstract away the representation of your concrete type
12:32:14 <jmcarthur_work> pastorn, polymorphism in haskell is usually a bit of a lie. the concrete type is known at compile time in most cases
12:32:32 <PeakerWork> pastorn: that's a good intuition you have there -- and it should lead you to abstract data types, not type-classes in this cawse
12:33:07 <PeakerWork> pastorn: expose your data type as:   data Blah (and associated functions),  not  data Blah = <implementation exposed here>          that will allow you to later change "Blah" to a different representation
12:33:17 <pastorn> PeakerWork: but i don't want to rewrite all the type signatures everywhere later!
12:33:30 <PeakerWork> pastorn: put it in a module that only exports the Blah type, but not its constructors, and the functions you want to expose
12:33:42 <PeakerWork> pastorn: then indirect the types with type aliases and such
12:33:54 <PeakerWork> pastorn: Type-classes are not the mechanism for this
12:34:00 <pastorn> PeakerWork: exactly as i intended to do, but only exposing the typeclass functions i had defined
12:34:58 <PeakerWork> pastorn: Lets look at it differently -- if tomorrow they choose to change the representation of Data.Map to use an Array, does everyone using Map need to change their type signatures?
12:35:15 <pastorn> no
12:35:17 <sjanssen> yes
12:35:24 <PeakerWork> sjanssen: why?
12:35:33 <sjanssen> Array requires an Ix constraint, Map uses Ord
12:35:37 <pastorn> the arrays would be the internal representation of the Map type
12:35:52 <pastorn> sjanssen: it's ok, i'll overlook that
12:36:01 <roconnor> @src sequence
12:36:02 <lambdabot> sequence []     = return []
12:36:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:36:02 <lambdabot> --OR
12:36:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:36:18 <PeakerWork> sjanssen: An Array internally, with its own index type
12:36:26 <zeno__> PeakerWork: have my haskell program send someone an email any way that will work without them having to install some mailserver (in windows)
12:36:32 <PeakerWork> sjanssen: for example, implement a "tree-over-array" with int indices
12:36:38 <PeakerWork> sjanssen: like heaps often are
12:36:47 <pastorn> PeakerWork: i feel i have to say i actually HAVE used typeclasses meaningfully
12:36:51 <pastorn> before
12:36:53 <sjanssen> PeakerWork: I get your point anyway, just being ornery
12:37:06 <PeakerWork> zeno__: to send email, you need to know who to talk to
12:37:25 <etpace_> :t liftM2
12:37:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:37:47 <etpace_> two functoned fmap?
12:37:50 <PeakerWork> pastorn: no problem, I just believe this particular use may be less fitting than a simple abstract type
12:37:54 <etpace_> two parameter*
12:38:03 <mauke> etpace_: yes
12:38:19 <zeno__> PeakerWork: could my server run a mailserver they could send to someone using?
12:38:27 <zeno__> no nvm that doesnt work
12:38:38 <zeno__> for me
12:38:39 <PeakerWork> etpace_: yeah, but note how it has to "combine" two Functors now, and Functors cannot combine. So it combines the "effects" of the Functors left-to-right
12:39:29 <PeakerWork> zeno__: when you configure a mail client, you have to tell it what mail server to use. You can't send mail without knowing where to send it to, unless you use some sort of open mail proxies on the internet, which are likely to be blacklisted by mostly everyone (as open mail servers on the internet are a source of spam)
12:39:43 <sm> zeno__: I think you either have to find out an smtp server that will talk to you, or look for various platform-specific mail-sending tools which may already have that configured (no guarantee)
12:40:09 <pastorn> waern: hej hej
12:40:13 <sm> but if you can find a way to make this just work automatically, you'll be a hero
12:40:41 <PeakerWork> etpace_: liftM2 is actually defined for "Applicative Functors", and indeed, for Applicative Functors, fmap is aliased to liftA, then you have liftA2, liftA3, etc.  Applicative Functors just add the ability to "combine" functors that way, such that the effects are sequenced left-to-right, and the values combined by any pure function you want
12:41:09 <sm> or a super-villain, I'm not sure which :)
12:41:29 <PeakerWork> @type liftA
12:41:30 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
12:41:34 <PeakerWork> @type liftA2
12:41:34 <ray> :t f <$> x <*> y
12:41:35 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:41:36 <PeakerWork> @type liftA3
12:41:36 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
12:41:36 <lambdabot>     In the second argument of `(<$>)', namely `x'
12:41:36 <lambdabot>     In the first argument of `(<*>)', namely `f <$> x'
12:41:37 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:41:46 <ray> :(
12:41:53 <waern> pastorn: tja
12:42:04 <PeakerWork> :t \f x y -> f <$> x <*> y
12:42:05 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
12:42:24 <ray> yes, that
12:42:33 <etpace_> I was going to say that looked like <*>, do they do the same thing?
12:42:34 <PeakerWork> etpace_: followed that explanation?
12:42:34 <ray> i don't know why i thought Expr would do it
12:42:40 <sm> zeno__: ps, the darcs project probably is the best example to look at
12:42:40 <ray> <$> is just fmap
12:42:41 <pastorn> PeakerWork: when i use typeclasses properly: http://paste.lisp.org/display/86088
12:42:44 <mauke> :t ?f <$> ?x <*> ?y
12:42:44 <sm> they have the same need
12:42:45 <lambdabot> forall a a1 b (f :: * -> *). (?f::a -> a1 -> b, ?x::f a, Applicative f, ?y::f a1) => f b
12:42:48 <mdmkolbe> containers directory filepath haddock2.3->2.5 hpc network
12:42:48 <mdmkolbe> old-time parallel parsec processregex-base
12:42:48 <mdmkolbe> regex-compat
12:42:48 <mdmkolbe> regex-posix
12:42:48 <mdmkolbe> syb
12:42:49 <mdmkolbe> template-haskell
12:42:51 <mdmkolbe> time
12:42:53 <mdmkolbe> unix
12:43:02 <ray> <*> is f (a -> b) -> f a -> f b
12:43:05 <mdmkolbe> sorry I didn't mean to send that, please ingore it
12:43:13 <PeakerWork> etpace_:  liftA2 = liftM2 .       <*> and liftA2 are very similar indeed.   (<*>) = liftA2 ($)      and    liftA2 f x y = f <$> x <*> y
12:43:23 <ray> :t fmap (+)
12:43:24 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
12:43:34 <ray> see that f (a -> a) on the right there?
12:43:39 <pastorn> ( PeakerWork: as proof that i'm not a daft nutter )
12:44:12 <ray> :t (fmap (+) Just 1) <*> Just 2
12:44:14 <lambdabot>     Couldn't match expected type `a -> b'
12:44:14 <lambdabot>            against inferred type `Maybe a1'
12:44:14 <lambdabot>     In the second argument of `fmap', namely `Just'
12:44:23 <ray> i am missing some parentheses there
12:44:29 <ray> but i'm probably just making it even more confusing anyway
12:44:38 <hackagebot> hSimpleDB 0.2 - Interface to Amazon's SimpleDB service. (DavidHimmelstrup)
12:44:49 <mauke> :t fmap (+) (Just 1) <*> Just 2
12:44:51 <lambdabot> forall a. (Num a) => Maybe a
12:44:56 <PeakerWork> pastorn: type-classes are great for type-hackery :)
12:45:23 <ray> just note that when you fmap a binary function, you go from (a -> (b -> c)) to f a -> f (b -> c)
12:45:38 <ray> <*> takes that f (b -> c) and an f b and gives you an f c
12:45:38 <PeakerWork> > (+) `fmap` [1] <*> [2]
12:45:39 <lambdabot>   [3]
12:45:49 <ray> and that's how you do n-ary lifting
12:46:01 * EvilTerran sees an advert for "stateless menswear" on facebook. i wonder if that's got anything to do with me listing haskell as a hobby...
12:46:06 <etpace_> almost like magic
12:46:18 <pastorn> PeakerWork: yeah, GADTs + typeclasses = WIN
12:46:25 <PeakerWork> pastorn: I've never used GADTs yet
12:46:36 <ray> spineless tagless underwear
12:46:40 <pastorn> haha, well, what i did there is a good way to use them :)
12:46:43 <roconnor> @hoogle approx
12:46:44 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
12:47:04 <pastorn> if you're ever writing an interprenter something :)
12:47:20 <pastorn> *for something*
12:47:21 <etpace_> > What does the left-to-right mean PeakerWork, is it just that in f <*> g, f's effects are 'actioned' before g?
12:47:22 <lambdabot>   <no location info>: parse error on input `,'
12:47:31 <PeakerWork> etpace_: exactly
12:48:19 <PeakerWork> etpace_: f <*> g      -- both f and g have effects AND potentially values.    so   f <*> g    creates a value that too has an effect (which is sequencing f's effect and then g's) and a value (which is the pure result of applying f's value to g's value)
12:49:16 <etpace_> > (,,) <$> Just 1 <*> Nothing <*> Just 3
12:49:17 <lambdabot>   Nothing
12:49:41 <PeakerWork> etpace_: the effect of Nothing is to terminate the computation, like raising an exception
12:50:01 <PeakerWork> > (,,) <$> [1,2] <*> [3] <*> [4]
12:50:02 <lambdabot>   [(1,3,4),(2,3,4)]
12:50:41 <PeakerWork> the "effect" of a list is to split the computation at that point
12:50:59 <etpace_> How does Nothing adsorb everything after it?
12:51:11 <PeakerWork> etpace_: by the fact that   Nothing <*> _ = Nothing
12:51:26 <PeakerWork> @src (<*>) Maybe
12:51:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:51:33 <PeakerWork> @src Maybe (<*>)
12:51:33 <lambdabot> (<*>) = ap
12:51:41 <etpace_> :t ap
12:51:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:51:50 <PeakerWork> etpace_: ap is just <*>
12:51:56 <ray> ap is the monad version is all
12:52:07 <ray> in Applicative, it's one of the methods
12:52:10 <PeakerWork> etpace_: but for Monads, due to the unfortunate accident of the way Monads duplicate everything Applicatives have
12:52:30 <Phillemann> Why does :t myfunction say "myfunction :: [(String, [Char])] -> ...? Why does it replace one [Char] by String but not the other?
12:52:31 <etpace_> and Nothing is of type m a, so it can keep going on fine
12:52:46 <PeakerWork> etpace_: basically, everything that Functors and Applicatives have, Monads have a duplicate of, because when Monads were first defined as a class, people didn't realize the relationship between Monads and Functor (and the not yet existent Applicative)
12:53:06 <etpace_> even though it doesnt actualy hold a function it can still be type m (a -> b -> c) or whatever..
12:53:24 <etpace_> How long ago was that PeakerWork?
12:53:25 <PeakerWork> etpace_: also, _ <*> Nothing = Nothing, btw
12:53:51 <monochrom> Phillemann: Sometimes if your file has explicit type signatures saying "String", :t goes with that.
12:54:00 <PeakerWork> etpace_: not sure, I think Applicatives were discovered after 2001, but I am not sure
12:54:27 <PeakerWork> I'm tired enough to repeat stuff :)
12:54:37 <Phillemann> monochrom: My program doesn't have type signatures at all, but I hide most of the stuff in Prelude (excluding String).
12:54:43 <Phillemann> That could be it.
12:54:57 <monochrom> Yes, some other explicit type annotation gets propagated.
12:55:51 <PeakerWork> etpace_: so a mapping from Functor/Applicative stuff to the Monad duplicate:   fmap -> liftM   pure -> return    <*> -> ap    liftA2 -> liftM2   sequenceA -> sequence    and so on
12:56:26 <etpace_> I've gone through the typeclopedia and I understand the concepts ok bar transformers and arrows, I'm looking through some papers on those topics, but even then, while I think I understand all the monoids etc, I still have to consult :t and so on, I guess itll come with time
12:56:37 <PeakerWork> etpace_: if Monad subclassed Applicative, then we wouldn't need all those duplicates, but since it doesn't, using liftM is preferable to fmap when you want a (Monad m) context rather than a (Monad m, Functor m) context
12:56:52 <etpace_> :t sequenceA
12:56:53 <lambdabot> Not in scope: `sequenceA'
12:56:57 <monochrom> Not magicman|come ?
12:56:58 <PeakerWork> @hoogle sequenceA
12:56:58 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:56:59 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
12:57:08 <PeakerWork> @type sequence
12:57:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:57:23 <PeakerWork> etpace_: sequenceA is also more general than lists
12:58:02 <etpace_> hmm... so it takes a 'container' of actions, and returns an action of a container of results or something?
12:58:22 <jmcarthur_work> essentially
12:58:28 <PeakerWork> etpace_: I see Arrows as a generalization of functions.   Instead of (a->b) which can be spelled ((->) a b)   you have (someArrow a b)  and someArrow can be (->) or other types that signify (can take a and give b)
12:59:14 <EvilTerran> etpace_, it takes a container of actions, where each action returns something of type a; and it converts that container into a single action that returns a container
12:59:16 <PeakerWork> etpace_: the main thing that confused me at first about arrows was syntax
12:59:42 <PeakerWork> etpace_: the syntax (a b c)  is very unclear. Its easier to understand if you see that  a  can be (->)
12:59:59 <EvilTerran> ?type (&&&)
13:00:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:00:23 <etpace_> How do you know the action returns something of type a EvilTerran? what about t (f (a -> b)), it has a type a but returns a b?
13:00:33 <EvilTerran> (&&&) :: Arrow to => (a `to` b) -> (a `to` c) -> (a `to` (b,c))
13:00:44 <PeakerWork> Lets say   a = (->)   then:   (&&&) :: (->) b c -> (->) b c' -> (->) b (c, c')      or:   (&&&) :: (b->c) -> (b->c') -> (b -> (c, c'))
13:00:59 <monochrom> It is now fashionable to say "b ~> c" for "a b c"
13:01:03 <etpace_> yeah PeakerWork, i'm looking at apaper that gives examples of arrows as well, as I cant really think of them outside of functions
13:01:11 <EvilTerran> etpace_, there's an important distinction between the value returned by an action and the value of a function
13:01:11 <monochrom> It is as easy as "b ~> c"
13:01:28 <etpace_> lol monochrom
13:01:43 <PeakerWork> etpace_: Well, I think there was a huge mistake in the Arrow class, which makes them very rarely useful
13:01:52 <EvilTerran> etpace_, i prefer to not think of "foo x" as *returning* a value, i prefer to think of it as *having* a value
13:02:21 <roconnor> ah, my first successful use of Data.Searchable.Set.
13:02:36 <roconnor> finally got things lazy enough to not stack overflow
13:02:46 <zeno__> can i run a proxy server from haskell?
13:02:52 <PeakerWork> etpace_: To understand Arrow, lets look at Arrow's new super-class, Control.Category
13:02:52 <EvilTerran> etpace_, in that "returning" suggests some kind of discrete event when a value is produced, but the evaluation of "foo x" needn't happen all at once
13:03:23 <copumpkin> zeno__: sure
13:03:24 <EvilTerran> etpace_, so i use the word "return" only in the context of the result of running a monadic (or applicative, i guess) action
13:03:29 <etpace_> does sequence preform anything on its container of actions, or does it just 'rearrange' them
13:03:35 <jmcarthur_work> PeakerWork, what do you think that mistake is?
13:03:39 <pikhq> "Return values" only have much meaning in sequential languages, where you can do "if foo then return x else do stuff;return y".
13:03:49 <zeno__> copumpkin: what libraries should i look at
13:03:59 <copumpkin> zeno__: none in particular :P
13:04:01 <PeakerWork> etpace_: it "sequences" all of the actions together into a single big action. It takes all the values from all these actions and puts them in a container inside the result of the big action
13:04:17 <zeno__> copumpkin: so id just have to write a socks proxy from scratch?
13:04:31 <monochrom> I don't have that much sequential, event semantics attached to "return".
13:04:34 <etpace_> as in, will sequence [putStrLn "foo"] put out "foo", or will I have to action the result to see "foo"?
13:04:37 <copumpkin> zeno__: probably :)
13:04:43 <EvilTerran> etpace_, it arranges the results in its result container the same way the actions themselves were arranged in the parameter container
13:05:28 <EvilTerran> etpace_, ah; no, IO actions are only "run" when they're threaded into the "main" IO action
13:06:19 <EvilTerran> etpace_, it might help to think of monadic actions as lists of instructions for whatever's evaluating the monad to follow
13:06:43 <PeakerWork> etpace_: TWEW = That When Executed Will      [putStrLn "foo"] is a list with an action TWEW print foo and result in ().  So sequence [putStrLn "foo"] results in an action TWEW print "foo" (just like the one in the list), and have a result of [()]
13:06:59 <etpace_> > sequence [Just (\x -> 5), Just (\x -> 6)]
13:07:01 <lambdabot>   Overlapping instances for GHC.Show.Show (t1 -> t)
13:07:01 <lambdabot>    arising from a use of ...
13:07:32 <PeakerWork> etpace_: the action/effect associated with the putStrLn result is the exact same one associated with the result of   sequence [putStrLn "foo"]    nothing is ever executed, only todo lists are being combined into bigger todo lists
13:08:01 <etpace_> > fmap (map (\x -> x ())) sequence [Just (\x -> 5), Just (\x -> 6)]
13:08:02 <lambdabot>   Couldn't match expected type `() -> b' against inferred type `[a]'
13:08:12 <PeakerWork> etpace_: putStrLn "foo"  is a TODO list, and the result of sequence [putStrLn "foo"] is a TODO list with the same TODO's but a different result
13:08:51 <jmcarthur_work> you know, lately i've been thinking more and more that the Writer monad might be one of the best ones to explain monads to beginners with
13:08:59 <etpace_> > fmap (map ($1) sequence [Just (\x -> 5), Just (\x -> 6)]
13:09:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:09:12 <etpace_> > fmap (map ($1)) sequence [Just (\x -> 5), Just (\x -> 6)]
13:09:13 <jmcarthur_work> for example, this question about sequence would probably have a fairly simple explanation in terms of Writer
13:09:14 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
13:09:19 <etpace_> ok I get it PeakerWork
13:09:38 <jmcarthur_work> even more clear with the Monoid o => (,) o monoid (unwrapped Writer)
13:09:43 <jmcarthur_work> s/monoid/monad/
13:09:52 <etpace_> as for the cat category, is cat to arrow as functor is to applicative?
13:09:52 <PeakerWork> etpace_: great! :)
13:10:32 <PeakerWork> etpace_: yep
13:11:17 <PeakerWork> Category is like Arrow, but has less power,  only  id and (.)
13:11:52 <jmcarthur_work> if we had instance Monoid o => Monad ((,) o) in the standard libraries, sequence [("foo", 1), ("bar", 2), ("baz", 3)] == ("foobarbaz", [1, 2, 3])
13:13:06 <PeakerWork> etpace_: class Category (~>) where id :: a ~> a ; (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
13:13:49 <leimy> Is there a good place to read about the changes in from Control.OldException to Control.Exception
13:13:55 <PeakerWork> etpace_: its a generalization of id and (.) for functions, to any type of kind *->*->*  that can be composed that way. I think the only law is that it is a Monoid, i.e: that (.) is associative and that (.id) and (id.) have no effect
13:13:59 <leimy> I'm not sure why I'd want to use anything but OldException at the moment.
13:14:28 <PeakerWork> leimy: I like the way you catch stuff (I think it wasn't that way in OldException):   ... `catch` (\QuitException -> ...)
13:14:54 <leimy> oh... i'm using bracket
13:14:59 <roconnor> @type until
13:15:01 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
13:15:01 <leimy> and the new version of bracket doesn't work the same way.
13:15:36 <etpace_> What does one gain from taking regular code and turning it into an instance of Arrow (or Category)?
13:15:53 <yitz> leimy: because then your code won't work with almost anything recent in the libraries (base >= 4.0)?
13:16:12 <leimy> I can use "Control.OldException" and it works fine :-)
13:16:18 <PeakerWork> etpace_: if you use Category's id and (.) instead of Prelude's, you get more general code
13:16:26 <yitz> oh, you mean what is supplied in the new base, I see
13:16:34 <leimy> yeah
13:16:42 <leimy> Just looking for what's new or why I should care? :-)
13:16:50 <yitz> JaffaCake was talking about deprecating that, but people screamed
13:16:51 <leimy> other than to move on and not use something called OldException
13:16:51 <PeakerWork> etpace_: for example, an interesting Category instance is the type of reversible computations:  data ReversibleComputation a b = RC (a -> b) (b -> a)
13:17:04 <mmorrow> leimy: i don't think OldException's going to be around forever
13:17:19 <PeakerWork> etpace_: you can define   id = RC id id          and     (.) = RC (.) (flip (.))
13:17:40 <PeakerWork> etpace_: then, code that uses (.) and id  from Category will work not only on composing normal functions but also when composing reversible computations
13:17:59 <ispirto__> hey, can i ask you why do you use haskell
13:18:13 <leimy> mmorrow: right and that's the one motivating reason to move :-)
13:18:31 <copumpkin> ispirto__: because it's a good language :)
13:18:49 <ispirto__> copumpkin, i believe so, but why?
13:19:00 <ispirto__> lazy evolution and functional?
13:19:05 <copumpkin> evaluation
13:19:11 <etpace_> so now all our functions that just relied on . and id, now work for RC?
13:19:18 <copumpkin> static typing with a good type system
13:19:20 <Phillemann> Hm, why does HXT's "readString" function return an IOStateArrow? I need neither IO nor state. :/
13:19:23 <EvilTerran> type inference!
13:19:27 <roconnor> how much time does lambdabot have?
13:19:30 <roconnor> to eval
13:19:31 <PeakerWork> etpace_: exactly
13:19:34 <mauke> @help run
13:19:34 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:19:48 <copumpkin> it's more than 3 seconds I thought
13:19:56 <Stinger> thats just lag
13:19:57 <roconnor> ugh
13:20:04 <roconnor> my integral for CReal is slow
13:20:10 <roconnor> so so slow
13:20:16 <copumpkin> aw
13:20:28 <copumpkin> no tricks like automatic differentiation for integrals?
13:20:31 <roconnor> integrating (200*) takes 14 seconds, and I'm not done implementing it
13:20:35 <roconnor> it always returns 7 :D
13:20:38 <copumpkin> :o
13:20:52 <roconnor> copumpkin: tricks like seraching infinite space in finite time
13:20:55 <EvilTerran> copumpkin, integration is undecidable, iirc
13:21:00 <roconnor> oh
13:21:06 <roconnor> but I'm not compiled yet
13:21:07 <roconnor> that might help
13:21:22 <EvilTerran> (well, algebraic integration is)
13:21:38 <roconnor> EvilTerran: elementary integration is decidable.
13:21:53 <c_wraith> integrating polynomials always works. :)
13:22:07 <c_wraith> ... for some definition that may include "infinite" :)
13:22:10 <etpace_> jmcarthur_work: so in your example it's a Monad (,) String, so sequence :: [(String, a)] -> (String, [a])?
13:22:14 <EvilTerran> well, yeah. depending on how many primatives you allow, it may or may not be decidable
13:22:15 <dschoepe> Why is the ():[] in the red ellipse more defined than the other ():[] connected with ⊥:⊥ in the following graph? http://upload.wikimedia.org/wikibooks/en/8/88/List-graph.png
13:22:17 <roconnor> c_wraith: yep
13:22:47 <mmorrow> roconnor: why does (200*) take 14 seconds (and why do you even need CReal for that?)?
13:23:24 <copumpkin> > sequence [("ohai", 5), ("obai", 7)]
13:23:25 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
13:23:25 <lambdabot>    arising from a u...
13:23:34 <dolio> dschoepe: It isn't.
13:23:46 <ivant> I'm trying to compile cabal-install from darcs repo, can anyone explain why it doesn't compile: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8632#a8632 ?
13:23:49 <dolio> dschoepe: That picture is questionable, though.
13:23:54 <mmorrow> roconnor: it might be worth it to first see if you can symbolically integrate it exactly, before you resort to a numerical approximation
13:24:01 <roconnor> mmorrow: (200*) is just a test (continuous) function from CReal -> CReal.
13:24:05 <jmcarthur_work> etpace_, yup
13:24:08 <dschoepe> dolio: Ah, okay. So the graph is wrong wrt to that?
13:24:19 <dolio> ():_|_ is not more defined than ():[], for instance, so I'm not sure why there's a line going up from the latter to the former.
13:24:19 <roconnor> mmorrow: how do I get access to the symbols when all I have is a black box?
13:24:29 <mmorrow> roconnor: don't use black boxes :)
13:24:42 <roconnor> mmorrow: okay you do that
13:24:54 <etpace_> its quite smart how sequence knows how to operate on that, but I guess thats what Monads (and the rest) are about
13:25:12 <dschoepe> dolio: That's comforting, I was quite confused by the graph.
13:25:30 <dolio> dschoepe: Height on that image doesn't necessarily represent how defined something is, I imagine. It's just how it fits in the space available.
13:25:48 <PeakerWork> etpace_: Its the Applicative or Monad instance of ((,) a) which uses mappend on the values of a, and treats the right side of the tuple as a simple result
13:25:54 <dschoepe> dolio: Hmm, the article should mention that, since all the preceding graphs worked that way
13:26:38 <PeakerWork> etpace_: pure x = (mempty, x)          (a, af) <*> (b, bx) = (a `mappend` b, af bx)
13:26:43 <dolio> _|_:[] > _|_:_|_ and ():[] > _|_:[]. And also ():[] > _|_:_|_. But ():[] = ():[], obviously, since it's the same value.
13:27:03 <roconnor> mmorrow: persumably there are already packages on hackage that do integration of analytic functions.
13:27:28 <dschoepe> dolio: Okay, thanks. Then I understand it correctly. I'll add a note on the wiki page.
13:27:35 <mmorrow> roconnor: what problem are you trying to solve?
13:27:43 <dolio> But, as I said, ():[] > ():_|_, so I don't know why there's an erroneous link there. And also ():(_|_:_|_) and ():[] are incomparable, so there shouldn't be an edge there, either.
13:28:09 <roconnor> mmorrow: allow lambdabot to do exact real integration.
13:28:46 <mmorrow> roconnor: what if the function you get passed isn't even continuous?
13:28:59 <dolio> dschoepe: Oh, I think I figured it out. They got that one ():_|_ and ():[] (the non-red one) mixed up. If you switch their places it makes more sense.
13:29:08 <roconnor> mmorrow: it'll probably hang.
13:29:09 <dolio> dschoepe: Except then there's nothing above ():[].
13:29:15 <mmorrow> roconnor: heh
13:29:57 <etpace_> so how did it build the list of integers if it was calling ("foo" `mappend` "bar",
13:30:02 <etpace_> 1 2)
13:30:14 <dschoepe> dolio: So the moved non-read ():[] should actually have the red ellipse?
13:30:21 <etpace_> (damn enter key being next to spacebar..)
13:30:37 <jmcarthur_work> etpace_, that is part of the implementation of sequence
13:30:42 <jmcarthur_work> @src sequence
13:30:42 <lambdabot> sequence []     = return []
13:30:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:30:42 <lambdabot> --OR
13:30:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:30:59 <dolio> dschoepe: Probably, if red means that there are no edges to go out of that node.
13:31:20 <dschoepe> dolio: Yes, that's what they are supposed to mean.
13:31:40 <etpace_> @src (>>=) (,)
13:31:40 <lambdabot> Source not found.
13:31:43 <dolio> dschoepe: But it's still somewhat misleading to say that going up makes particular values more defined when they aren't on the same path.
13:31:57 <jmcarthur_work> unfortunately, that instance isn't actually in the standard libraries :(
13:32:12 <jmcarthur_work> etpace_, but you could look at Writer
13:32:14 <dolio> dschoepe: For instance, _|_:(_|_:_|_) and _|_:[] aren't equally defined. They're just incomparable by the ordering.
13:33:00 <dschoepe> dolio: hmm actually the article only said that edges denoted being more defined, so apart from the other mistake, it seems to be correct.
13:33:09 <dolio> Okay.
13:33:36 <ivant> @help
13:33:37 <dschoepe> (I'm talking about that one by the way: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics )
13:35:16 * monochrom joins the "winning" side of the split. :)
13:37:42 <PeakerWork> etpace_: (a, ax) >>= f  =  let (b, bx) = f ax  in  (a `mappend` b,  bx)
13:38:03 <zeno> is there any library to run a proxy server in haskell?
13:38:45 <PeakerWork> zeno: a proxy of what?
13:39:11 <PeakerWork> zeno: if its about the mail server, you're either going to have to assume that localhost runs a mail server, or accept an SMTP configuration information about what server to connect to
13:40:13 <mmorrow> zeno: yes! Network.Socket ;)
13:40:26 <copumpkin> lol
13:41:00 <monochrom> I am not sure of the semantics of quests like "how to implement this already widely available appliance in haskell".
13:41:17 <etpace_> :t (>>=)
13:41:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:41:35 <dons> zeno: look on hackage.haskell.org
13:41:43 <monochrom> All possible semantics I can think of are bunk.
13:42:24 <monochrom> One possible semantics: "I do this project to learn."  For the overwhelming majority, this project is too large for learning anything.
13:43:09 <inimino> s/semantics/motivation/, I think
13:43:12 <mmorrow> zeno: also, the FFI is very nice
13:43:14 <monochrom> Another possible semantics: "I need the appliance."  The existing implementations of that appliance work just fine, even though not written in Haskell.
13:44:23 <PeakerWork> monochrom: "work fine" but probably not composable, if they're not in Haskell :)
13:44:54 <kniu> hey guys i wanna learn haskel how 2 write halo plz help
13:44:56 <monochrom> How composable would you like a proxy server to be?
13:45:04 <elliotstern> In general, what's the deepest recursion will go before you stack overflow?  I've been working on some project euler problems and I'
13:45:18 <elliotstern> *I've been running into some stack overflow problems
13:45:37 <kniu> elliotstern, have you tried increasing the stack size?
13:45:51 <elliotstern> no, not yet
13:45:53 <leimy> Hmmm the implicit "catch" in "bracket" is causing me a type error in the Control.Exception module that doesn't exist in Control.OldException
13:45:55 <PeakerWork> monochrom: it depends on what I want to do with it. I might want to compose the proxy with a filter or such
13:46:01 <copumpkin> elliotstern: you might be doing something wrong if you're getting a stack overflow :)
13:46:27 <jmcarthur_work> elliotstern, typically you should not get a stack overflow if you are paying attention to laziness/strictness
13:46:48 <jmcarthur_work> stack overflow usually means a buildup of unevaluated thunks
13:46:50 <kniu> throw some `seq`s in there, see whether that helps.
13:47:18 <elliotstern> Will do.  How do you increase the stack size, out of curiosity?
13:47:22 <leimy> ah, the type of "catch" changed.
13:48:22 <kniu> when running the executable, do "./a.out +RTS -K{stacksize}"
13:48:25 <olsner> btw, did anyone ever find a (useful) use for the reverse state monad?
13:48:27 <leimy> I need to throw an ::IOException in there somewhere but I've no idea where :-)
13:48:28 <kniu> I think.
13:48:31 <yitz> @seen bos
13:48:32 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
13:52:32 <monochrom> The infinite descent to "more composable" in FP is equivalent to the infinite descent to "more extensible" in OOP.
13:52:54 <jmcarthur_work> monochrom, is this a quote or a personal observation?
13:52:59 <leimy> ah... figured it out.  I see what's going on.  It's about allowing other exceptions than IOExceptions :-)
13:53:14 <leimy> seems reasonable.
13:54:15 <monochrom> quotes are equivalent to personal observations.
13:54:32 <monochrom> @quote monochrom syntax rule
13:54:33 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
13:54:44 <monochrom> @quote monochrom fugue
13:54:44 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
13:54:54 <monochrom> They are personal observations and quotes.
13:55:26 <Baughn> @quote monochrom
13:55:27 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
13:55:27 <lambdabot> godawful construct?
13:56:16 <yitz> @quote Baughn
13:56:17 <lambdabot> Baughn says: I think I'm beginning to understand this language. I just defined 1+1=3.
13:56:20 <Baughn> ..I consider this conclusive evidence we have no contact with aliens.
13:56:55 <monochrom> Perhaps you're interested in personal observations aka quotes from people who make good observations. But you can see I have a track record of making good observations.
13:57:02 <c_wraith> > let (+) x y = 3 in 1 + 1
13:57:03 <lambdabot>   3
13:57:10 <dons> http://www.infoq.com/news/2009/08/haskell-ruby-hubris
13:57:15 <dons> huh, infoq on the ruby bridge.
13:57:19 <dons> people love bridges.
13:57:23 <Baughn> c_wraith: More or less, but I at least pattern-matched 1 and 1
13:57:41 <jmcarthur_work> monochrom, wow, i really just was wondering who originally said it...
13:57:49 <monochrom> There is no royal road to mathematics. There is no ruby road to programming.  <duck>
13:57:51 <Baughn> @quote despair
13:57:51 <lambdabot> No quotes match.
13:58:02 <monochrom> I originally said it.
13:58:15 <c_wraith> ruby kind of tries to be lisp.  But with funny syntax
13:58:36 <c_wraith> ...  And a giant helping of questionable ideas.
13:58:42 <jmcarthur_work> i don't think it tries at all
13:58:44 <Baughn> ..without the macro.
13:58:48 <c_wraith> It has symbols!
13:58:57 <Baughn> So does C!
13:59:06 <arw> "those who don't remember lisp are bound to reinvent it. badly..."
13:59:11 <elliotstern> heh
13:59:13 <c_wraith> I thought only the preprocessor had symbols in C
13:59:24 <Baughn> The preprocessor is part of the C standard
13:59:32 <Baughn> Anyway, CPP is the /real/ language
13:59:36 <c_wraith> haha
13:59:43 <Baughn> The post-CPP stuff is just an IO monad
13:59:48 <jmcarthur_work> C is a purely functional language!
13:59:52 <elliotstern> how do you increase the stack size?
13:59:55 <jmcarthur_work> CPP, i mean
14:00:12 <c_wraith> elliotstern: haskell doesn't have a stack.  >_>
14:00:16 <Baughn> elliotstern: I could answer that, but I won't. If you have to, you're doing something wrong.
14:00:23 <Baughn> c_wraith: ..no, but the runtime system sure does
14:00:36 <jmcarthur_work> c_wraith, not a traditional stack, but GHC does have one
14:00:38 <Baughn> The stack is used only when evaluating nested thunks
14:00:50 <EvilTerran> it doesn't go up and down the same way a stack in an eager language would, but it's still a stack
14:01:05 <Baughn> Nested thunks that are sufficiently large as to overrun the 8MB default stack limit means you're doing something wrong. :P
14:01:23 <Baughn> elliotstern: So, what /are/ you doing?
14:01:25 <elliotstern> I'm working on http://projecteuler.net/index.php?section=problems&id=14
14:02:00 <yitz> Baughn: so use CPP to neaten up your m4 code
14:02:31 <elliotstern> Basically, it wants you to figure out which number under 1000000 has the longest sequence, given 2 rules to generate a chain for the sequence
14:02:32 <Baughn> yitz: Sure, that way I can write a sub-thousand line sendmail.cf.cpp!
14:02:46 <yitz> heh
14:02:56 <Baughn> elliotstern: First off, try compiling with -O2 if you haven't already
14:02:57 <Cale> elliotstern: Better to avoid making excessive use of the stack, but you can increase the size with +RTS -K<size>
14:03:07 <Cale> the default size is 8M
14:03:28 <Baughn> The default /limit/ is 8M. In practice, the stack rarely grows beyond a few hundred bytes
14:03:32 <Cale> yeah
14:03:36 <elliotstern> I have a list of the sequences, and I'm finding the longest one.  It breaks down a little over 100000.
14:03:58 <Cale> elliotstern: What are you using to compute the maximum of the list of lengths?
14:04:18 <Baughn> elliotstern: Yeah, you're probably creating a Big Chain o' Thunks. It's fixable by introducing appropriate strictness, but not at random. ;)
14:04:19 <c_wraith> Looks like I solved that one, in haskell..  And never ran into a problem with the stack.  >_>
14:04:26 <elliotstern> A simple recursive functiom
14:04:31 <elliotstern> maxListLen :: [[a]] -> [a]
14:04:32 <Stinger> :)
14:04:33 <elliotstern> maxListLen [] = []
14:04:34 <bos> yitz: hm?
14:04:35 <elliotstern> maxListLen (x : xs) = if length x > length prevmax then x else prevmax
14:04:36 <elliotstern> 		where prevmax = maxListLen xs
14:05:03 * Berengal must admitt he's used -K256M a couple of times
14:05:04 <Cale> elliotstern: Oh, better to pair each element with its length and use maximum.
14:05:08 <yitz> hi bos. are you aware of the current thread on the darcs list about you?
14:05:17 <opqdonut> link?
14:05:20 <bos> my ears are not burning.
14:05:27 <Cale> elliotstern: This way, you'll end up recomputing the lengths of the lists over and over.
14:05:48 <Baughn> elliotstern: Although it wouldn't fix your problem, you could also simplify that code by using Data.List's maximumBy
14:05:58 <c_wraith> as with all problems, the solution is to use an IntMap!  :)
14:06:09 <jmcarthur_work> not really...
14:06:13 <Baughn> elliotstern: (by compare `on` length, in this case)
14:06:18 <elliotstern> Will maximum [(foo, bar)] return the pair with the largest foo value?
14:06:21 <c_wraith> (yes, that was a joke)
14:06:26 <Cale> You could also do a great job of this using MemoCombinators.
14:06:31 <jmcarthur_work> s/:)/;)/
14:06:36 <Cale> (but that's something else)
14:06:39 <Berengal> MemoTrie makes #14 far too easy
14:06:43 <fnord123> elliotstern:  generate the sequence like mySequence = firstNum : funcForNextNum -- then foldr myComparisonFunc firstNum (takeWhile (<1000000) mySequence)
14:06:48 <Baughn> > (1,2) > (2,1)
14:06:49 <lambdabot>   False
14:06:52 <Berengal> I wrote my own trie instead and loebed it, for fancyness
14:06:53 <Cale> elliotstern: Yeah, and if there are multiple with the same foo, the largest bar after
14:06:58 <yitz> bos: let's just say that they don't agree with what you wrote about darcs in the queue article
14:07:07 <elliotstern> Ah, that makes things much easier
14:07:32 <Stinger> hmm lexical ordering default for tuples?
14:07:34 <Cale> > maximum [(length xs, xs) | xs <- ...]
14:07:35 <lambdabot>   <no location info>: parse error on input `...'
14:07:38 <Cale> er...
14:07:38 <EvilTerran> fnord123, this sequence isn't really structured like that
14:07:39 <monochrom> queue article? darcs makes it to ACM Queue?!
14:07:49 <Cale> didn't mean to put >, hehe
14:08:01 <bos> yitz: colour me shocked.
14:08:15 <yitz> monochrom: http://queue.acm.org/detail.cfm?id=1595636
14:08:26 <Baughn> > (1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8) > (2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8)
14:08:28 <lambdabot>   No instance for (GHC.Classes.Ord
14:08:28 <lambdabot>                     (t,
14:08:28 <lambdabot>                   ...
14:08:28 <fnord123> EvilTerran:  I've seen code to generate a prime sequence like that. so it will be a tough sequence to not implement like this. :)
14:08:28 <bos> i did ask kowey for comments before i finished it.
14:08:32 <monochrom> ZOMG is all I can say!
14:08:49 <monochrom> Oh, and: maybe some years later monads will make it to ACM Queue too! XD
14:09:13 <EvilTerran> fnord123, ok, much as you *could* generate the collatz sequence that way, it really wouldn't be very efficient
14:09:52 <EvilTerran> fnord123, in that you can't elegantly express one element of it in terms of the preceding elements only
14:09:59 <fnord123> oh ok. i didnt look at the problem yet since im implementing the projecteuclid problems in haskell as well and dont want spoilers :)
14:10:27 <yitz> bos: ok, i'm not expressing any opinion. just thought you'd like to hear about the thread.
14:10:39 <bos> yitz: ok.
14:11:10 <yitz> bos: congrats on the article btw
14:11:25 <bos> thanks
14:11:38 <monochrom> And ZOMG from me, again. :)
14:12:15 <monochrom> (So, when will you submit some ContT stuff to Queue too? <duck>)
14:12:44 <monochrom> (Oh actually type families stuff may be both cooler and more useful.)
14:13:07 <Baughn> @quote zombies
14:13:07 <lambdabot> No quotes match. You untyped fool!
14:13:13 <monochrom> (You know, ContT is so yesteryear among Haskell people already :) )
14:14:14 <Stinger> god ghc takes a while to build
14:14:56 <Berengal> There's a /. story about it as well
14:15:03 <Berengal> (I thought I had read this before)
14:15:06 <byorgey> Stinger: yep.  I suggest finding an alcoholic beverage and coming back later.
14:15:21 <Berengal> http://tech.slashdot.org/story/09/08/25/2126251/Making-Sense-of-Revision-Control-Systems
14:16:36 <monochrom> I suggest watching a movie while waiting for GHC to build.
14:16:45 <Stinger> game of nethack
14:16:50 <monochrom> An an opera while waiting for Haskell Platform to build.
14:16:55 <Stinger> though that will probably take too long
14:17:02 <Berengal> HP builds faster than ghc for me
14:17:13 <monochrom> Domingo starring in the First Emperor is pretty interesting.
14:17:17 <Berengal> Stinger, my nethack games usually last 5 minutes :(
14:17:28 <pr_> well, either watching a movie or you just pipe the compiler output to /dev/dsp
14:17:42 <Stinger> heh yeah same actually
14:17:52 <erikc> make -j 16
14:17:53 <Stinger> just the one I just died in had taken me a few days
14:18:10 <monochrom> "5 minutes to win, days to die"?
14:18:51 <gwern> http://github.com/explicitcall/graphtype/tree/master <-- any github users know how I file a bug/
14:19:32 * osfameron never figured out how to live long enough in nethack for it to actually be fun :-(
14:19:42 <Berengal> Two worst nethack games I can remember: 1 turn, rock to the head, and 50 turns, two wands of wishing, dragon scale mail, aethewhatsitsname, amulet of life, the woiks. Killed by arrow trap
14:20:25 <osfameron> I think I usually die after getting curious and eating a slime mold, which turns out to be poisoned, then I wonder around for a bit, and get attacked by the ghost of my dog
14:20:48 <Stinger> hah ghost of your dog ey haven't seen that one
14:20:52 <etpace_> Does anyone have any recommendations for beginner projects to write to get used to using Monads (and other typeclasses), while I'm sort of comfortable with the ideas behind them, they're not really cemented until i've actually used them
14:21:09 <Berengal> etpace_, write a parser
14:21:28 <monochrom> I wrote a parser as a monad. I followed a paper describing one.
14:22:09 <monochrom> I then wrote a theorem prover (or rather, a small part of) as a monad.
14:22:24 <Berengal> I wrote it without any paper describing anything. I then read the paper and saw that mine was a bit crappy, but I groked monads at least
14:22:38 <etpace_> one modeling a FSA or something Berengal?
14:22:53 <monochrom> Do recursive descent.
14:23:03 <etpace_> *whoosh*
14:23:12 <Berengal> etpace_, no, just a parser capable of repeatedly eating a string and spitting out arbitrary values
14:23:41 <Berengal> You only need like four functions. The rest can be built on top of those
14:24:07 <Berengal> Maybe five...
14:24:08 <Cale> etpace_: data Parser a = P (String -> [(String,a)])
14:24:37 <Berengal> parse, char, orElse, return, bind
14:24:45 <yitz> etpace_: write a solver for your favorite puzzle. See the sudoku page on the wiki for many different ideas.
14:25:25 <Cale> (that is, it takes a string to a list of possible depleted strings along with the resulting parsed values)
14:25:57 <monochrom> Here is the intention. A parser takes a string, consumes part of it, and the result is the pair of: unconsumed part, the result of parsing/converting the consumed part. But it's a list because you may like to allow and handle ambiguous parses that way. If you don't like that, Maybe (String,a) to indicate parser error by Nothing.
14:26:14 <yitz> Cale: why (String,a) and not (a,String)?
14:26:22 <|zzz|> how do you get the ASCII code for a character?
14:26:26 <opqdonut> :t ord
14:26:28 <lambdabot> Char -> Int
14:26:30 <Berengal> > ord 'a'
14:26:32 <lambdabot>   97
14:26:34 <Cale> yitz: better fmap
14:26:35 <opqdonut> that gives ascii codes for things that have them
14:26:36 <mauke> |zzz|: import Data.Char; ord
14:26:37 <Berengal> > fromEnum 'a'
14:26:39 <lambdabot>   97
14:26:40 <opqdonut> and some other codes for other letters
14:26:41 <yitz> > fromEnum 'a'
14:26:42 <ksf> nah, that gives you a unicode codepoint.
14:26:42 <lambdabot>   97
14:26:51 <opqdonut> ksf: you did not contradict me
14:26:55 <Cale> yitz: Not that it really matters.
14:26:59 <yitz> right
14:27:19 <|zzz|> ok
14:27:48 <Berengal> fmap = result fmap?
14:27:57 <monochrom> Perhaps "ASCII code for a character" comes with the promise that the character is from the ASCII subset of Unicode. Then same thing.
14:28:09 <Cale> Berengal: a few more I think :)
14:28:25 <Cale> Berengal: well, depends on what 'result' is
14:28:48 <Cale> If result = fmap, then you'll need to map over the list structure as well
14:29:03 <Berengal> Cale, taking it to be (.) (or fmap), then yes, a few more...
14:29:09 <Berengal> fmap = fmap (fmap fmap)
14:29:19 <Cale> hehe
14:29:21 <Berengal> (or is that fmap . fmap fmap?
14:29:35 <Berengal> @type fmap `fmap` fmap fmap
14:29:37 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
14:29:43 <monochrom> Or perhaps "ASCII code" means Unicode codepoint to some people, like "Xerox" means photocopying to some people, even though now it's all Canon and Konica and HP.
14:29:44 <Cale> fmap . fmap . fmap
14:29:52 <Cale> perhaps
14:30:09 <yitz> @type fmap . fmap . fmap
14:30:10 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:30:11 <Cale> Then you have to deal with the data constructor
14:30:42 <Cale> f = (->) String, f1 = [], f2 = (,) String
14:30:49 <Berengal> @type let fmap f ((x, y:r) = (x, f y):fmap f r in fmap
14:30:50 <lambdabot> parse error on input `='
14:31:00 <monochrom> And oh, "dashboard" has long lost its dashness and boardness.
14:31:08 <Berengal> @type let fmap f ((x, y):r) = (x, f y):fmap f r in fmap
14:31:10 <lambdabot> forall t t1 t2. (t -> t1) -> [(t2, t)] -> [(t2, t1)]
14:31:25 <Berengal> hrm
14:31:48 <Cale> :t let f :: (t -> t1) -> [(t2, t)] -> [(t2, t1)]; f = fmap . fmap . fmap in f
14:31:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = f t
14:31:50 <lambdabot>     When generalising the type(s) for `f'
14:31:50 <lambdabot>     In the expression:
14:31:54 <Cale> oh, hmm
14:32:18 <elliotstern> Is there any reason why making a list would work, but finding the maximum value immediatly stack overflows?
14:32:19 <Cale> er, right... wrong type ;)
14:32:31 <Berengal> @type let fmap f p = (\s -> let ((x, y):r) = p s in (x, f y):fmap f r) in fmap
14:32:32 <lambdabot>     Couldn't match expected type `[(t, t1)]'
14:32:32 <lambdabot>            against inferred type `t2 -> [(t, t1)]'
14:32:32 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
14:32:33 <Cale> :t let f :: (t -> t1) -> (t2 -> [(t2, t)]) -> (t2 -> [(t2, t1)]); f = fmap . fmap . fmap in f
14:32:34 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> [(t2, t)]) -> t2 -> [(t2, t1)]
14:32:54 <Cale> :t let f :: (a -> b) -> (String -> [(String, a)]) -> (String -> [(String, b)]); f = fmap . fmap . fmap in f
14:32:56 <lambdabot> forall a b. (a -> b) -> (String -> [(String, a)]) -> String -> [(String, b)]
14:33:31 <Berengal> Where do you fit the deconstructor in?
14:33:31 <kbp> I'm not sure if this is a right place to ask. But could anyone please tell me is this expression simplifiable? (P <=> R) /\ ((P /\Q) => R). I have been working on this quest for 3 days and still have no solution.
14:33:47 <elliotstern> maximum (take 1000000 seqlist)
14:33:48 <elliotstern> *** Exception: stack overflow
14:33:50 <elliotstern> but yet take 1000000 seqlist prints the list out as it generates it over 15 minutes or so
14:34:02 <monochrom> Making a list by a suitable method does not create a huge expression to evaluate. Finding maximum by a suitable method creates a huge expression to evalute. I also know how to cause overflow by making a list, and consume little memory by finding maximum.
14:34:37 <MyCatVerbs> elliotstern: import Data.List (foldl'), and try (foldl' max (take 1000000 seqlist)).
14:34:45 <etpace_> What part of the parser is a monad, is it the collection of all parsers, like Cales description: instance Monad Parser where return x = (\[] -> ([], x))? I'm not really sure what return would be in this context, what would the simplest data structure be?
14:34:59 <elliotstern> Thanks
14:35:25 <MyCatVerbs> elliotstern: the problem in the latter case is that maximum's default definition is too lazy, and builds up a huge thunk of (e1 `maximum` (e2 `maximum` (e3 `maximum` (e4...
14:35:26 <monochrom> "return x" is a parser that doesn't consume the string. return x = \s -> (s,x)
14:35:47 <elliotstern> ah
14:35:50 <PeakerWork> MyCatVerbs: s/maximum/max
14:36:00 <MyCatVerbs> PeakerWork: oops, thank you.
14:36:10 <PeakerWork> @type max
14:36:11 <lambdabot> forall a. (Ord a) => a -> a -> a
14:36:15 <monochrom> He said "maximum" to make it huger. :)
14:36:25 <Berengal> etpace_, in this context, a parser is a function that takes a string and returns a (possibly list of) parsed value and the remaining string. Return should obivously return a parser that takes a string and return that string and the provided value
14:36:25 <Cale> data Parser a = P { runParser :: String -> [(String, a)] }
14:36:25 <Cale> instance Functor Parser where
14:36:25 <Cale>   fmap = (P .) . (. runParser) . fmap . fmap . fmap
14:36:28 <MyCatVerbs> elliotstern: And the runtime overflows its stack while recursing into that expression to evaluate. The fix is to use a strict looping primitive, that will force the value at every step. That's where foldl' comes in. :)
14:36:33 <etpace_> ah of course, the id law monochrom?
14:36:46 <monochrom> Oh oops, \s -> [(s,x)]
14:37:01 <Cale> You lift 3 times, then stick a runParser on the end, and P on the beginning.
14:37:15 <MyCatVerbs> elliotstern: foldl' does the same thing as foldl, except that it forces the accumulator with `seq` at every stage of the game. ^_^
14:37:25 <Cale> (or the other way, depending on how you think of it)
14:37:28 <monochrom> I guess I also missed P.
14:37:33 <MyCatVerbs> Er, at every element as it consumes the list.
14:37:54 <Cale> (import Control.Monad.Instances and that'll compile)
14:38:17 <Berengal> Cale, we must now translate all occurences of (.) to fmap
14:38:22 <Cale> ehehe
14:38:26 <MyCatVerbs> Berengal: nnnno.
14:38:38 <MyCatVerbs> Better to write Caleskell, and redefine (.) as fmap. :)
14:38:48 <pikhq> Mmm, Caleskell.
14:38:55 <Berengal> fmap = (fmap P) `fmap`(`fmap` runParser) `fmap` fmap `fmap` fmap `fmap` fmap
14:38:56 <monochrom> I suggest a compromise. define (...) as fmap.
14:39:32 <etpace_> why three times Cale? and as parser is just a function, isnt fmap (.)?
14:39:39 <MyCatVerbs> > let (.) = fmap in (+5) . (*2) . [1..4]
14:39:40 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
14:39:40 <pikhq> (.) = (P .) . (. runParser) . (.) . (.) . (.) . -- That is quite amusing. :)
14:39:46 <monochrom> (...) = (... P) ... (... runParser) ... (...) ... (...) ... (...)
14:40:02 <MyCatVerbs> > let (.) = fmap in ((+5) . (*2)) . [1..4]
14:40:04 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
14:40:10 <Cale> etpace_: Well, once for the pairs, once for the list, and once for the function.
14:40:12 <Berengal> or, fmap = fmap (fmap P) (fmap (flip fmap runParser) (fmap fmap (fmap fmap fmap))).... I think
14:40:59 <monochrom> I prefer a language made of spaces and dots.
14:41:06 <Alpounet> Hi.
14:42:10 <Cale> fmap (fmap (fmap (fmap (fmap P) (flip fmap runParser)) fmap) fmap) fmap
14:42:21 <Berengal> @type fmap (fmap Just) (fmap (flip fmap fromJust) (fmap fmap (fmap fmap fmap)))
14:42:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> Maybe (f (f1 (f2 a))) -> Maybe (f (f1 (f2 b)))
14:43:07 <Berengal> Preliminary inspection tells me mine's correct
14:43:21 <Berengal> But not symetrical like Cale's
14:43:24 <Cale> Mine compiles
14:43:33 <etpace_> but isnt fmap f g = f . g when g is of type (e ->)?
14:43:41 <Cale> etpace_: yes, we're playing games now
14:43:51 <ray> cogolfing
14:44:01 <monochrom> fmapping
14:44:06 <Cale> fmap = (P .) . (. runParser) . (.) . fmap . fmap
14:44:07 <etpace_> ok, I didn't really follow since thre treble fmaps ;)
14:44:14 <pikhq> etpace_: Yes, that's why we want f . g = fmap :P
14:44:14 <ray> *fmap fmap fmap*
14:44:16 <MyCatVerbs> ray: Hah! I lol'd. :)
14:44:29 <Cale> fmap = (P .) . (. runParser) . (.) . map . second
14:44:35 <MyCatVerbs> ray: (at "cogolfing", not "fmap fmap fmap". The former was funny. ^~)
14:44:37 <Cale> If you want to specialise each of the fmaps
14:44:38 <kw317> hello
14:44:40 <ray> yes
14:44:58 <Cale> But I think it's actually *less* clear like that
14:45:14 <ray> cogolfing is harder to define, though, because you can always add junk that reduces to id
14:45:19 <ray> the trick is doing it interestingly
14:45:36 <monochrom> Perhaps you should co-define.
14:45:50 <MyCatVerbs> cogolfing isn't making your programs shorter.
14:45:55 <mauke> I code fine!
14:45:57 <Berengal> Whenever I see a bunch of fmaps I immediately think "something's doing something deep in a type". At that point, the type signature is all you need to know to see what's going on
14:46:00 <MyCatVerbs> cogolfing isn't making your programs more specific.
14:46:18 <Berengal> cogolfing is looking for the turtles in the code
14:46:29 <monochrom> cogolfing is supposed to be observed, not described.
14:46:41 <EvilTerran> MyCatVerbs, it's making your programs more creative ;)
14:46:52 <ray> no, it's creating more program
14:47:18 <MyCatVerbs> EvilTerran: argh, no! You just tried to define it! We're supposed to be codefining it! :)
14:47:48 <Apocalisp> cosupposed to
14:47:51 <ray> if a definition tells you the meaning of a term, codefining should tell you the term of a meaning
14:48:22 <Berengal> All these terms are nfusing me...
14:48:25 <ray> it's the process by which i would look at fmap craziness and say "that's cogolfing"
14:48:47 <ziman> a cogolfed program consists of an obfuscation layer above a cogolfed program
14:48:59 <Cale> ray: There actually is something to that, sort of.
14:49:02 <MyCatVerbs> EvilTerran: you have a point though, it does seem to involve making your programs more interesting from a purely Lovecraftian perspective. =)
14:49:04 <Vanadium> Does "module X ( module Y ) where" make X re-export all of Y?
14:49:13 <Cale> Though I suspect it works out better with adjoints :)
14:49:17 <MyCatVerbs> I'm quite fond of the physical analogy that it presents, too.
14:49:31 <monochrom> Yes Vanadium
14:49:42 <Cale> Vanadium: yeah (...or was it all the stuff you imported from Y?)
14:49:52 <MyCatVerbs> IRL golfing is the process of getting a ball into a small hole that is far away from you in as few strokes as possible.
14:50:23 <ray> cogolfing is the process of taking as long as possible to get a ball out of a hole?
14:50:30 <MyCatVerbs> cogolfing would hence be the process of fitting a small hole around a ball that is far away from you in as few strokes as possible. =D
14:51:03 <Berengal> cogolfing must then be the coprocess of getting a coball out of a large cohole that is as cofar close to you in as many costrokes as copossible
14:51:06 <Cale> Yeah, it's re-exporting everything (qualified and unqualified) that you imported from Y. If imported qualified, it's exported with no additional qualification.
14:52:01 <Cale> It's kind of unfortunate that you can't re-export things exactly as you imported them.
14:52:30 <mauke> <tybalt89> so cogolfing is: start with code, then define the smallest problem it solves?
14:53:24 <yitz> kw317: hi. sorry, we were in the middle of something. :)
14:56:08 <Cale> Syntax and semantics are adjoint in a peculiar sense.
14:56:34 <Cale> If you form a category C whose objects are sets of axioms and where the arrows denote logical entailment, and form a category D as the power set of the set of all mathematical structures (which might satisfy those axioms), with a unique arrow X -> Y if X is a subset of Y.
14:57:41 <Cale> Let F be the functor C -> D which sends a theory to the set of structures which satisfy it, and G: D -> C send a collection of structures to a minimal axiomatization.
14:57:46 <monochrom> The Aristotle duality between properties and examples.
14:58:04 <monochrom> In fact you just need Galois connection.
14:58:09 <Cale> Then F(T) is a subset of S if and only if T logically implies G(S).
14:58:21 <Cale> Yeah, since these are both preorder categories.
14:58:27 <Cale> Poset categories even.
15:00:43 <MyCatVerbs> Cale: that actually made sense, confusingly enough. But what does adjointness have to do with it?
15:00:58 <Cale> MyCatVerbs: Well, I suppose it's not exactly a *dual* as such.
15:01:06 <Cale> But it's close.
15:01:22 <MyCatVerbs> Lemme rephrase the question.
15:01:42 <Cale> F and G are adjoint functors
15:01:49 <monochrom> This duality drives the funny phenomenon of: should you describe {1,2} as "1 and 2" or "1 or 2"?
15:01:50 <Cale> (if that's what you're asking)
15:02:01 <MyCatVerbs> That actually makes perfect sense; is therer a good example of what adjointness is in there, please?
15:02:42 <MyCatVerbs> My issue is that I didn't get far into cat theory before my neurons gave up, last time I tried.
15:03:14 <Cale> Well... this is an example of a pair of adjoint functors, though a bit of a strange one.
15:03:29 <monochrom> It is "1 and 2" because "the set has 1 and the set has 2". It is "1 or 2" because "the set has x means x=1 or x=2".
15:04:27 <monochrom> "duality" doesn't always mean opposite categories. it also means adjoints.
15:04:46 <Cale> Adjointness is this correspondence that F(T) -> S if and only if T -> G(S)
15:05:18 <Cale> monochrom: But as far as I know, the 'co-' prefix is normally only used for opposites.
15:05:46 <Cale> When I saw 'codefinition' I started to think of what that might be.
15:05:49 * copumpkin is definitely pumpkin's opposite
15:06:15 <MyCatVerbs> Cale: so it's the property that the two functors are (structure-preserving) inverses?
15:06:18 <Cale> So in this case, I guess a codefinition is an exhaustive set of examples.
15:06:46 <Cale> MyCatVerbs: Not inverses exactly
15:07:18 <Cale> MyCatVerbs: and their composites might not even be isomorphic to the identity
15:07:36 <Cale> MyCatVerbs: But there's a natural map FG -> 1 and a natural map 1 -> GF
15:08:07 <Cale> (that's another way to define adjunctions)
15:08:20 <Cale> (well, there are some laws too)
15:08:54 <Cale> I'm not sure that's the clearest view for this example though.
15:09:16 <MyCatVerbs> Mmm, I'm short a few more terms. I'll go read s'more at some point.
15:09:34 <Cale> natural map = natural transformation
15:09:46 <monochrom> Adjunction is a pretty lengthy definition.
15:10:05 <Cale> You might do well to watch the Catsters videos
15:10:19 <Cale> (on YouTube)
15:10:32 <Cale> they do a bunch on adjunctions
15:11:11 <MyCatVerbs> Ooooh, neat! Thank you!
15:11:51 <monochrom> One day you will like categorty theory so much you call yourself MyCatMorphs
15:13:05 <MyCatVerbs> monochrom: No need. I'm already fully polymorphic in the verb, and besides.
15:13:29 <MyCatVerbs> I've covered cat theory with the noun alone.
15:19:51 <ksf> % cat README
15:19:51 <ksf> T.B.D.
15:19:55 <ksf> ...oleg.
15:20:01 <shapr> hah
15:20:14 <monochrom> Perhaps there is really nothing to say.
15:20:24 <shepheb> could be worse. "This space intentionally left blank."
15:21:09 <monochrom> This blank extentionally fills space.
15:21:23 <centrinia> It could also be recursive, "Please refer to the README."
15:21:39 <yitz> fix README
15:21:55 <monochrom> ln -s README README
15:22:07 <mauke> ELOOP
15:22:24 <monochrom> ln -s -f -f -f -f -f README README
15:22:46 <centrinia> ln -s -f foo bar; ln -s -f bar foo
15:23:45 <_-jn> Hello, is there an easy way to convert a list [1 .. 5] to a list of lists, whith each list containing only the element of the first list, like [[1] .. [5]] ?
15:23:46 <monochrom> In fact "ln -s x x" works fine, I have just tried.
15:24:23 <yitz> _-jn: map (:[])
15:24:45 <yitz> > map (:[]) [1..5]
15:24:46 <lambdabot>   [[1],[2],[3],[4],[5]]
15:24:59 <_-jn> ok, great, thank you!
15:25:08 <ksf> cat: x: Too many levels of symbolic links
15:25:13 <Berengal> [berengal@superabacus ~]$ file foo
15:25:13 <Berengal> foo: symbolic link in a loop
15:25:26 <centrinia> :t map return [1..5] :: [[Int]]
15:25:27 <lambdabot> [[Int]]
15:25:30 <centrinia> > map return [1..5] :: [[Int]]
15:25:31 <lambdabot>   [[1],[2],[3],[4],[5]]
15:25:35 <monochrom> Yes, those will be errors.
15:25:40 <ksf> hmmm % file x
15:25:41 <ksf> x: broken symbolic link to `x'
15:26:05 <monochrom> Heh super abascus.
15:26:25 <Berengal> My laptop's miniabacus
15:26:33 <monochrom> Perhaps my next computer should be superstone. Then the next superstoned.
15:26:40 <monochrom> Haha neat.
15:27:29 <monochrom> Do you have an iPod or iPhone or handheld thing?
15:27:41 <Berengal> Not anymore
15:27:47 * ksf has a palm m105
15:27:50 <Berengal> Think I'll get a new one soon though
15:27:57 <ksf> it's just too sexy to throw away.
15:28:05 <monochrom> microabacus? pocketabacus?
15:28:23 <poe> muabacus
15:28:24 <monochrom> abacusnano? :)
15:28:37 <Berengal> http://en.wikipedia.org/wiki/Nokia_N900, see if I can get ghc to run on it
15:28:44 <Berengal> abacuslet
15:29:00 <Berengal> Oh, no, ABACUSTRON
15:29:08 <monochrom> haha
15:31:57 <SamB> Cale: do you know anything about proving that the set of functions of type Π(x:A)->B x is finite, given finite A and ∀x, finite (B x) ?
15:32:09 <ksf> there's lisp and forth for palm
15:32:44 <ksf> I wouldn't ever buy a handheld without keyboard again, though.
15:33:11 <ksf> http://www.openpandora.org/
15:33:32 <Berengal> I find it a little discouraging that it took the iPhone for handhelds to lose their outer buttons
15:33:34 <Kim> Yargh… came up with the idea that I’d write a function that reads input from the user and returns the result as either “Just float” or “Nothing”… but it’s not going very well, any nudge would be helpful (code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3429#a3430)
15:33:39 <Berengal> (slide-out qwerty is a must though)
15:33:43 <centrinia> What does  Π(x:A) mean?
15:34:36 <ksf> Kim, you can't do side effects.
15:34:47 <SamB> centrinia: well, it means the function takes an argument x of type A, and x will be bound in the rest of the type
15:34:59 <ksf> ...you can make a function that returns an IO (Maybe Float), though, and later execute that.
15:35:29 <monochrom> Kim: readIO input `catch` ...
15:35:34 <monochrom> @type readIO
15:35:35 <lambdabot> forall a. (Read a) => String -> IO a
15:35:51 <mmorrow> Kim: write a function that takes a String as a param, and that returns (Maybe Float)
15:35:58 <monochrom> It will throw the wanted exception right there.
15:36:04 <Berengal> :t readList
15:36:05 <lambdabot> forall a. (Read a) => String -> [([a], String)]
15:36:18 <dolio> centrinia: pi (x:A) T is like A -> T, except x (which is the value of type A) is allowed to appear in T.
15:36:18 <Kim> Hmm
15:36:26 <Kim> *tries*
15:36:30 <mmorrow> Kim: then however you want to supply that String, do it externally in a wrapper function, that calls the wrapped function
15:36:31 <Berengal> Some fancy dressing, and readList is a nice Maybe Read function
15:36:38 <centrinia> dolio, is that a dependent type?
15:36:42 <dolio> Yes.
15:38:30 <dolio> So you could write: foo : Pi(b:Bool) (if b then Int else Char) ; foo True = 1 ; foo False = 'c'
15:38:37 <ksf> :t getLine >>= catMaybes . readFloat
15:38:38 <lambdabot>     Couldn't match expected type `Maybe a'
15:38:38 <lambdabot>            against inferred type `(a1, String)'
15:38:38 <lambdabot>       Expected type: [Maybe a]
15:38:50 <ksf> :t getLine >>= catMaybes . fmap fst. readFloat
15:38:52 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[a]'
15:38:52 <lambdabot>     In the second argument of `(>>=)', namely
15:38:52 <lambdabot>         `catMaybes . fmap fst . readFloat'
15:38:59 <ksf> :t catMaybes . fmap fst. readFloat
15:39:00 <lambdabot> forall a. (RealFrac (Maybe a)) => String -> [a]
15:39:06 <dolio> Pi reduces to normal functions when T makes no mention of the value. A -> B = Pi (_:A) B.
15:39:06 <mmorrow> @type let wrapper f = return . f =<< getLine in wrapper
15:39:07 <lambdabot> forall b. (String -> b) -> IO b
15:39:15 <mmorrow> @type let wrapper f = f <$> getLine in wrapper
15:39:16 <lambdabot> forall b. (String -> b) -> IO b
15:39:21 <centrinia> SamB, are functions of type Π(x:A)->B x related to functions from A to the union of all { B x | x in A } ?
15:39:23 <mmorrow> @type let wrapper f = f `fmap` getLine in wrapper
15:39:24 <lambdabot> forall b. (String -> b) -> IO b
15:39:29 <mmorrow> @type let wrapper f = f `liftM` getLine in wrapper
15:39:30 <lambdabot> forall r. (String -> r) -> IO r
15:39:56 <SamB> centrinia: well, not very closely ...
15:39:59 <ksf> d'oh
15:40:05 <ksf> :t listToMaybe . fmap fst. readFloat
15:40:07 <lambdabot> forall a. (RealFrac a) => String -> Maybe a
15:40:14 <SamB> the latter doesn't make much sense type-theoretically, I don't think
15:40:15 <ksf> :t readLine >>= listToMaybe . fmap fst. readFloat
15:40:17 <lambdabot> Not in scope: `readLine'
15:40:22 <ksf> :t getLine >>= listToMaybe . fmap fst. readFloat
15:40:23 <lambdabot>     Couldn't match expected type `IO b' against inferred type `Maybe a'
15:40:24 <lambdabot>     In the second argument of `(>>=)', namely
15:40:24 <lambdabot>         `listToMaybe . fmap fst . readFloat'
15:40:42 <ksf> :t listToMaybe . fmap fst. readFloat <$> getLine
15:40:44 <lambdabot> forall a. (RealFrac a) => IO (Maybe a)
15:41:07 <mmorrow> ksf: he never explicitly said that the input string was a float rep, justs that it returns a Maybe Float ;)
15:41:34 <ksf> :t listToMaybe . toFractional . fmap fst. read <$> getLine
15:41:35 <lambdabot> Not in scope: `toFractional'
15:41:39 <Cale> SamB: You can do better than just show they're finite, you can count them. It's product over x in A of card (B x)
15:41:41 <ksf> :t listToMaybe . toRealFrac . fmap fst. read <$> getLine
15:41:43 <lambdabot> Not in scope: `toRealFrac'
15:41:45 <ksf> er whatever.
15:42:18 <Cale> SamB: Because for each x in A, you're picking something from B x, yeah?
15:42:49 <SamB> Cale: well, actually I wanted to make a list of them all
15:43:13 <SamB> Cale: given that I can get a list of the elements of any type that I know to be finite
15:43:17 <aavogt> @src readIO
15:43:18 <lambdabot> Source not found. Just try something else.
15:43:25 <dolio> SamB: Σx:a (B x) is kind of that type.
15:44:00 <SamB> Cale: what kind of product did you say it was ?
15:44:14 <Cale> SamB: just the normal product of naturals
15:44:38 <Cale> Product over x:A of the number of members of B x
15:44:45 <Cale> Isn't it?
15:45:15 <mmorrow> this one paper rwbarton linked me too at one point was interesting, it shows that PI(x:A)->B is actually an arrow  B -> A
15:46:07 <mmorrow> "x : A ⊢ B(x) : type. Such a judgment is interpreted as an arrow f : B -> A, the usual categorical treatment of indexed families."
15:46:22 <mmorrow> *following the usual...
15:46:31 <mmorrow> pdf copy/paste fail
15:46:59 <mmorrow> i've got a copy here, don't know where i originally got it http://moonpatio.com/papers/homotopy_theoretic_models_of_identity_types.pdf
15:47:05 <Cale> It's possible that I'm misinterpreting things. My understanding of pi-types is quite shaky.
15:47:47 <mmorrow> Cale: this paper is nice in that it explains the lingo from more of a mathy standpoint
15:49:44 <mmorrow> "The meaning of type dependence is that, when A is a given type, it is possible for a family (B_x)_x:A of types to occur indexed by A. The theory also allows families of types which are themselves indexed by families of types, and so forth."
15:50:49 <hackagebot> scion 0.1 - Haskell IDE library (ThomasSchilling)
15:52:46 <SamB> gah, can't understand the CT
15:53:16 <copumpkin> SamB: embrace it into your soul (and nick) like I did!
15:53:25 <copumpkin> understand yourself by becoming your own dual!
15:53:50 <copumpkin> <deep voice>...come to the dual side</deep voice>
15:54:09 <dons> scion!!
15:54:17 <Nafai> Yay scion!
15:54:33 <copumpkin> @hackage scion
15:54:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/scion
15:54:45 <copumpkin> yay
15:54:56 <wolverian> so, I guess data Foo = Bar { foo :: Baz } | Quux is a bad idea, given that foo only works on one variant. le sigh. and I can't define the other case after the fact?
15:55:21 <Cale> wolverian: Right, just write the function properly if you want to define it completely
15:55:39 <nominolo> oops, apparently slashes in the description field are not so safe
15:55:50 <wolverian> I have a non-trivial amount of pattern matches to refractor from record syntax then :(
15:56:42 <Cale> wolverian: Your type has a nontrivial number of cases?
15:58:16 <Cale> wolverian: If the number of cases in your type grows beyond the number of basic operations on it, it may be worth storing a record of the operations instead.
15:59:34 <wolverian> Cale: I meant I have a nontrivial amount of functions that use record syntax pattern matches on the type
15:59:38 <mmorrow> SamB: the first 3 pages alone are pretty useful
16:00:00 <Cale> For instance if the purpose of the type is to describe possible objects for a game, and the operations consist of updating the object for a handful of circumstances, and drawing it on the screen, then it's almost certainly better to define a type with only one case that consists of functions describing how to do each of those, and implement many values of that type.
16:00:04 <Cale> ah
16:02:50 <mun> does anyone know how the 'expected type' and 'inferred type' computed differently?
16:03:04 <Smokey`> does GHC still force one to embedd the runtime into the output binary? (eg: there's still no shared library for the ghc runtime, correct?)
16:03:26 <SamB> Smokey`: ... probably ...
16:03:33 <ksf> ...also the "expected type" is inferred, it's just that both can't be unified.
16:03:45 <byorgey> mun: the 'inferred type' of an expression is the type that the expression has in and of itself.
16:03:55 <ksf> both are computed in the same way.
16:03:59 <byorgey> mun: the 'expected type' is the type is ought to have, given the context in which it occurs.
16:04:14 <mmorrow> mun: the expected type is the one that's implied by the surrounding code context, and the inferred type is the one implied by that expression without considering the surrounding context
16:04:32 * sjanssen can remember which is which.  Is there better language than "inferred" and "expected"
16:04:42 <mun> i see. thanks
16:04:56 <SamB> both of them can be a bit arbitrary in the presence of even slighltly recursive stuff, can't they?
16:05:36 <Smokey`> mmm, well that is a pitty.
16:06:06 <sjanssen> Smokey`: the runtime really isn't that large
16:06:06 <dons> great HWN
16:06:08 <dons> http://www.reddit.com/r/programming/comments/9ehdj/haskell_weekly_news_haskell_jobs/
16:06:12 <dons> so much stuff going down.
16:06:13 <SamB> Smokey`: it is at least being worked on
16:06:21 <Smokey`> SamB: I was told that 4 years ago...
16:06:29 <Smokey`> sjanssen: it used to be ~400kb...
16:06:35 <SamB> Smokey`: I mean, I think it even works in the HEAD
16:06:42 <SamB> depending on OS
16:06:57 <sjanssen> Smokey`: you usually don't need to sweat about 400 kb in this, the year 2009
16:07:27 <mmorrow> [m@monire ~]$ ls /usr/local/ghc/ghc-HEAD/lib/ghc-6.11.20090807/libHSrts-ghc6.11.20090807.so
16:07:27 <mmorrow> /usr/local/ghc/ghc-HEAD/lib/ghc-6.11.20090807/libHSrts-ghc6.11.20090807.so
16:07:40 <Smokey`> 400kb * 20-odd shared libraries is 8mb...
16:07:55 <sjanssen> Smokey`: no, the RTS is only linked into executables
16:07:55 <Smokey`> 20 shared libraries isn't exactly too many either
16:08:00 <Smokey`> sjanssen: oh?
16:08:03 <sjanssen> once per executable
16:08:47 <copumpkin> seems like it'd be needed for foreign export 'ing libraries too
16:09:24 <sjanssen> now, the lack of shared Haskell libraries is a bit of a problem from a code bloat perspective
16:09:39 <sjanssen> copumpkin: yeah, shared objects callable from C need the RTS too
16:09:47 <sjanssen> but who actually does that?
16:10:18 <Smokey`> oh dear, I never realised to call Haskell code from C, you actually have to generate C files from your haskell code, to compile into your app... that is horrible :(
16:10:40 <Smokey`> I didn't recall that being the case :\
16:10:51 <SamB> Smokey`: hmm?
16:10:58 <Smokey`> oh well, so much for taking haskell up again
16:11:06 <sjanssen> Smokey`: what are you going on about?
16:11:19 <copumpkin> Smokey`: it generates c stubs for you to call
16:11:22 <copumpkin> and a header
16:11:44 <copumpkin> it doesn't pass the entire library through c
16:11:46 <Stinger> how else is C going to know about your functions?
16:12:56 <Smokey`> hmm you're right, the wiki is just a little misleading at first glance - it works as I recall, though 3-4 years ago you didn't have the stub generation crap
16:13:26 <sjanssen> Smokey`: I think that's been around for a while
16:13:41 <PeakerWork> Smokey`: what's wrong with automatic stub generation?
16:13:48 <Stinger> how did C know about your functions then? manual header generation? :P
16:13:49 <Smokey`> PeakerWork: nothing at all
16:13:56 <Smokey`> Stinger: yes, acutally.
16:14:10 <Smokey`> I had to hand write it, and bug dons a lot for tips :P
16:14:11 <Stinger> so you're complaining cause you have to do less work? ;)
16:14:13 <sjanssen> Smokey`: GHC 6.4's user guide talks about generating stubs as well
16:15:08 <Smokey`> Stinger: no, I was complaining because I misinterpreted the wiki page on the subject
16:15:08 <Kim> A-ha! Solved it using “reads”: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3429#a3431
16:16:10 <mun> can anyone see why libenv on line 5 http://haskell.pastebin.com/m596c1dd has the expected type CMDL_State->CMDL_State rather than DGraph?
16:20:33 <leithaus> Hey -- anybody have a pet regexp for matching URLs?
16:21:07 <dons> you could just use the url parsing library?
16:21:21 <Lemmih> mun: Did you mean 'return $ i_libEnv s'?
16:21:33 <dons> importURL :: String -> Maybe URL
16:21:39 <dons> leithaus: ^^ better than a regex :)
16:21:46 <dons> import Network.URL
16:21:53 <dons> http://hackage.haskell.org/package/url
16:22:01 <mun> Lemmih, which line are you referring to?
16:22:11 <Lemmih> mun: Line 7.
16:22:16 <dons> nominolo: http://hackage.haskell.org/package/scion-0.1 (note the distributions line :)
16:22:34 <dancor> > importURL "a b"
16:22:35 <lambdabot>   Not in scope: `importURL'
16:22:48 <dancor> anyway, it thinks that is a url, isn't that bad?
16:22:49 <dons> cabal install url
16:23:02 <nominolo> dons: heh.  I'd be more interested in testers
16:23:04 <Lemmih> mun: And why did you think it should have type DGraph?
16:23:19 <mun> Lemmih, hmm i don't think so. libenv isn't monadic
16:23:46 <mun> Lemmih, because ana_VIEW_DEFN's 3rd argument is of type DGraph
16:23:47 * sm tests scion emacs support
16:24:20 <nominolo> dons: how does this work, btw?
16:24:21 <leithaus> i'm working in a specific context of nesting parsers
16:24:22 <mun> Lemmih, dg should have the type DGraph
16:24:33 <dancor> maybe if you filter ((/= PathRelative) . url_type it is more realistic..
16:24:38 <Lemmih> mun: Using it as a DGraph doesn't make it a DGraph.
16:25:00 <Lemmih> mun: You're using 'i_libEnv' as a monadic action on line 7.
16:25:15 <leithaus> a parser at level n is a lexer for level n+1
16:25:34 <copumpkin> oh nice, almost 1700 comments on the java thread on reddit
16:25:42 <mun> Lemmih, well, sorry. libenv should be of type LibEnv rather than the expected Map.Map LIB_NAME (CMDL_State -> CMDL_State)
16:25:43 <dancor> anyway there are a bunch of url regexes on google
16:25:50 <Lemmih> mun: 'dg' is a 'Maybe DGraph', libenv is a 'LibEnv'.
16:26:05 <leithaus> yeah... i looked at them but they seem to not be well vetted
16:26:17 <sjanssen> copumpkin: that's about 1600 too many for any reddit post
16:26:17 <Lemmih> mun: Look at line 7. Tell me what you think it says.
16:26:18 <leithaus> i thought maybe someone here had a go at one
16:26:27 <copumpkin> sjanssen: yeah, but lots of people hate java :D
16:26:59 <sjanssen> Java gets so much hate, I feel sorry for it
16:27:01 <dancor> leithaus: also do you want to require the schema part (http://)
16:27:42 <dancor> searching for bare domains leads to many false positives
16:28:04 <sm> if we ever fail completely to avoid success, I suppose Haskell will get it too
16:28:08 <mun> Lemmih, it assigns libenv to the value of i_libEnv of s, so that should give it the type LibEnv
16:28:10 <leithaus> i need the scheme part
16:28:11 <mun> Lemmih, right?
16:28:26 <Lemmih> mun: No, that is incorrect.
16:28:33 * sm makes a note to be elsewhere by then
16:28:40 <Lemmih> mun: 'x <- y' is very different from 'let x = y'.
16:28:59 <Lemmih> mun: You're doing 'libenv <- i_libEnv s' which makes no sense.
16:29:27 <dancor> do you want to allow general schemas or just (f|ht)tps?  etc
16:29:48 <leithaus> i need a few more
16:29:55 <mun> Lemmih, ooh i get what yo umean
16:30:25 <leithaus> here's an example of something that has no vetting and would take quite a while to vet
16:30:26 <leithaus> http://internet.ls-la.net/folklore/url-regexpr.html
16:30:29 <mun> Lemmih, i should have it as an assignment rather than a monadic action
16:30:40 <aavogt> nominolo: when I run WriteSampleConfigScion, I get this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8641#a8641  should I have defined g:scion_result somewhere?
16:31:20 <nominolo> aavogt: no.  Hm, which python version is that?
16:31:22 <dancor> leithaus: what about http://www.osix.net/modules/article/?id=586
16:31:41 <nominolo> aavogt: ah, 2.6
16:32:14 <aavogt> nominolo: 2.6.1 (r261:67515, Dec  7 2008, 18:56:39) [GCC 4.3.2]
16:32:17 <sm> nominolo: thanks for scion, it sounds rather cool. I've just successfully installed it and emacs integration and reloaded a hs file, I can see the Scion minor mode. Next I tried C-c C-x C-l, it prompts me for Load Component: which does not complete and won't let me control-g out :/
16:32:41 <dancor> it's not clear to me why that long one needs separate parts for http and ftp
16:33:02 <nominolo> sm: Oh.   That's a problem with the completion function.
16:33:18 <nominolo> sm: lemme check
16:34:49 <nominolo> sm: try M-: (defun aquamacs-p () t)
16:34:57 <nominolo> then try again
16:35:01 <Trinithis> I'm taking a graphics algorithms course, and I was wondering if Haskell has good library support for graphics (so I can use it instead of C++)
16:35:02 <sm> worse, hitting enter doesn't get it to process the input
16:35:45 <nominolo> aavogt: Hm. You should be able to use it without the config file
16:36:09 <aavogt> ok, I'll try that
16:36:12 * sm kills his beloved emacs
16:36:23 <nominolo> aavogt: in any case, could you please file a report at http://code.google.com/p/scion-lib/issues/list
16:36:30 <nominolo> sm: I'm so sorry
16:37:39 <Alpounet> it is possible to use ghci in emacs, right ?
16:37:50 <Alpounet> if yes, what's the shortcut/command to do so ?
16:37:56 <Alpounet> C-c C-b doesn't work
16:38:28 <nominolo> Alpounet: C-c C-l
16:39:11 <nominolo> sm: which version of emacs are you using?
16:39:36 <sm> nominolo: that fixed it. I'm using 23.0.60.1 on ubuntu
16:40:26 <nominolo> sm: Ok, I'll prepare a fix.  Weird, I'm using 23.0.91.1 (emacs-snapshot-gtk)
16:40:55 <leithaus> dancor: that looks promising. Thx!
16:43:51 <sm> the typecheck on save works beautifully. It didn't pop up the compiler notes buffer, I had to C-c C-n for that
16:44:34 <sm> much faster than using searchpath's auto-compile on save. Great
16:44:36 <Alpounet> nominolo: it says : Symbol's function definition is void: inferior-haskell-load-file
16:45:33 <nominolo> Alpounet: then most likely your haskell-mode is not properly set up
16:45:49 <Alpounet> I installed it via apt... weird.
16:46:04 <nominolo> Alpounet: does M-x haskell-mode work?
16:46:50 <Alpounet> what is it supposed to do ?
16:47:23 <Alpounet> (I have Haskell coloration, standard function's type in the mini-buffer, etc)
16:47:34 <sm> nominolo: unfortunately it seems my macbook doesn't pass C-c C-. to emacs
16:47:36 <nominolo> ah, hm.
16:47:43 <sm> (in a terminal window)
16:48:19 <nominolo> ah, it probably intercepts C-c or C-.?
16:48:44 <nominolo> sm: you can change the bindings in the preferences
16:49:07 <Alpounet> Hi back.
16:49:15 <sm> thx
16:49:27 <sm> C-. is the problem key
16:49:36 <Alpounet> I even have the hoogle command working, but it doesn't want to launch ghci.
16:49:47 <Alpounet> However, is it correctly installed.
16:50:06 <gOcOOl> is the haskell-platform available for ubuntu via apt or is our option still pretty much the source installation?
16:50:30 <dons> there's details for ubuntu on the haskell platform page
16:50:35 <dons> its not in apt for ubuntu yet
16:50:57 <gOcOOl> dons: ah ok, thanks
16:52:55 <Axman6> does ubuntu even have 6.10 yet
16:52:57 <Axman6> ?
16:53:02 <c_wraith> no
16:53:10 <aavogt> dons: haskell-scion doesn't install in arch, but cabal-install manages because it has some magic to guess base means base<4, which seems to be missing when the Setup.lhs is used instead...
16:53:10 <Axman6> yeah, stuff ubuntu
16:53:34 <aavogt> hopefully they'll get it by the time 6.12 comes out
16:54:57 <nominolo> sm: I personally use "C-c i l" a lot
16:56:53 <mun> can anyone see why libenv on line 5 http://haskell.pastebin.com/m1672e3b1 has the expected type Map.Map LIB_NAME (CMDL_State -> CMDL_State) rather than LibEnv?
16:57:45 <dancor> why do people bother to treat reserved words in the lexing step
16:58:08 <copumpkin> "AnyComorphism"
16:58:27 <dancor> if the result after lexing is (TokReserved, "for") or TokFor instead of (TokIdentifier, "for"), seems like the parsing logic is going to be similar
16:58:40 <dancor> is it about optimization in some way?
16:58:54 <dancor> maybe i could believe that having TokFor ends up being faster
16:59:11 <Lemmih> mun: 'return' gives you a monadic action.
16:59:22 <c_wraith> Um.  In many languages, specific reserved words have different syntax than arbitrary identifiers.  Haskell is one such language
17:00:18 <dons> aavogt: hmm. i just installed haskell-scion
17:00:20 <dancor> c_wraith: but in your parsing, your statement node or whatever is going to have a for-possibility and it's going to expect like TokFor + whitespace + literal "(" + ...
17:00:22 <ziman> there are certain places where reserved words cannot occur; it would be tedious to forbid them individually as [Tok "for", Tok "if", Tok "case", ...]
17:00:38 <dons> aavogt: double checking.
17:00:40 <sm> nominolo: I seem to get Error in process filter: (end-of-file) quite a bit, for some things that seem implemented, like scion-goto-definition on a locally-defined function (where C-c C-t works)
17:00:46 <Lemmih> mun: Perhaps you want 'fromJust'.
17:00:52 <dancor> c_wraith: and it seems similar to instead expect (TokIdentifier, "for") + whitespace + ...
17:01:01 <dancor> ziman: maybe that's it
17:01:04 <arw> does the haskell platform include a recent ghc or do i need to get ghc 6.10.4 separately?
17:01:06 <nominolo> sm: right, I think you can just ignore it.
17:01:12 <mun> Lemmih, hmm right. can i not use a case statement there?
17:01:20 <dancor> ziman: just to catch errors like for = 4; earlier
17:01:23 <dons> aavogt: definitely builds here via yaourt.
17:01:24 <nominolo> sm: I suspect a bug in the json lib, but I'm not sure
17:01:31 <c_wraith> Right.  The point isn't the use of the reserved word.  It's that a reserved word isn't an identifier.  It's syntactically different.
17:01:38 <dons> aavogt: it is possilbe you have an old haskell-multiset in your cache?
17:01:39 <Lemmih> mun: You can, but all branches must have the same type.
17:01:41 <dons> it needed updating.
17:01:41 <mjs22> dancor: separating identifiers from reserved words lets silly mistakes like "x = for" from making it very far before they are rejected
17:01:57 <dancor> mjs22: ya ok
17:01:58 <sm> it doesn't go to the definition, in that case
17:02:01 <nominolo> aavogt: does scion work apart from the WriteConfig stuff?
17:02:06 <nominolo> sm: oh, hm
17:02:17 <dons> lispy: around?
17:02:32 <dons> damn, it takes a while to link
17:02:35 <aavogt> dons: yeah, old multiset pkgbuild
17:02:36 <mun> Lemmih, i see. so in my case, that's not the case because the Nothing branch gives a monadic type, right? sorry i'm very new.
17:02:46 <ziman> you might argue that we can treat them as regular identifiers in that case but that would mess up the grammar completely as you'd need to parse "for = 4", for example, as you pointed out
17:02:47 <Lemmih> mun: You will be better off with 'fromJust' until you get more familiar with Haskell.
17:03:03 <Lemmih> mun: Right.
17:03:32 <aavogt> I rm -r /tmp/yaourt-tmp-*, and now it looks like it will work
17:03:57 <ziman> or admit that some syntactical constructs are unavailable with identifiers that coincide with reserved words
17:04:02 <mun> Lemmih, but if I use fromJust, I wouldn't be able to trigger an error message in a similar manner to what i'm doing now, right?
17:04:15 <Lemmih> mun: Right.
17:04:39 <copumpkin> :t fromMaybe (error "DAMMIT I GOT A NOTHING")
17:04:40 <lambdabot> forall a. Maybe a -> a
17:05:22 <mun> Lemmih, ok thanks
17:06:18 <zzaz> is there any haskell algorithms that can count primes from 2..10^7 in reasonable time and space (everything in the prime page is too slow)
17:06:39 <copumpkin> zzaz: project euler?
17:06:43 <c_wraith> The paper on functional primes is handy.
17:06:45 <mmorrow> , 10^7
17:06:48 <lunabot>  10000000
17:06:54 <copumpkin> that's a pretty small number
17:07:01 <zzaz> no, actually this: http://www.cstutoringcenter.com/problems/problems.php?id=9
17:07:31 <mjs22> ls
17:07:32 <zzaz> i wrote a c program that could do it in about a second, nothing in the prime page can do it
17:07:53 <copumpkin> this won't give you the exact number, but you could brute force the area around it ;) http://en.wikipedia.org/wiki/Prime_number_theorem
17:07:58 <dons> aavogt: yeah
17:08:11 <copumpkin> zzaz: did you try the oneill prime generator?
17:08:31 <hackagebot> scion 0.1.0.1 - Haskell IDE library (ThomasSchilling)
17:08:32 <c_wraith> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf <-- efficient primes in haskell
17:08:52 <c_wraith> and there's an implementation of it on haskell:  http://hackage.haskell.org/package/primes
17:08:57 <c_wraith> err, on hackage
17:08:57 <zzaz> implicit heap ran out of memory
17:10:32 <nominolo> sm: ok, I fixed your problem in 0.1.0.1
17:11:11 <mmorrow> this does it in 40 seconds
17:11:13 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8643#a8643
17:11:22 <mmorrow> with very little memory use
17:11:31 <zzaz> ok
17:11:58 <mmorrow> since you know the number of primes ahead of time, you could optimize by using an array
17:12:08 <copumpkin> for a number that small you could even use an IntMap
17:12:22 <sm> nominolo: great
17:12:26 <mmorrow> yeah, that too. that paste uses Map on account of Integer
17:13:46 <zzaz> what.. but i thought haskell does pretty well against c in the benchmarks
17:14:32 <copumpkin> you can write slow haskell and you can write fast haskell
17:14:34 <mmorrow> zzaz: that program is using a search tree instead of an array
17:14:38 <arw> zzaz: it does, but many algorithms need careful optimisation.
17:14:39 <sjanssen> zzaz: are you using the right algorithm?
17:15:01 <arw> zzaz: unfortunately sometimes the most aesthetic solution is one of the slowest.
17:15:06 <zzaz> both my C and haskell version use the sieve of erasthethenes algorithm
17:15:24 <c_wraith> Using the haskell package I linked to..
17:15:24 <mmorrow> zzaz: can you paste your haskell version?
17:15:36 <aavogt> nominolo: I still have python errors :(
17:15:55 <c_wraith> foldl1' (+) $ takeWhile (<10^7) primes
17:16:00 <c_wraith> takes much less than a second
17:16:12 <zzaz> ok i'll check it out
17:16:16 <c_wraith> (printing them takes quite a lot longer, but that's because my terminal is slow)
17:16:49 <copumpkin> zzaz: there's a very concise snippet of haskell going around pretending to be the sieve of eratosthenes, but really isn't
17:16:50 <Lemmih> Hah, say 'Haskell is slow' and everyone jumps to interject.
17:16:58 <copumpkin> zzaz: make sure you aren't using that one ;)
17:17:08 <copumpkin> Lemmih: everyone jumps to everything anyone says in here, all the time :P
17:17:15 <c_wraith> See the paper I linked to first.  It is a very good explanation for why that code isn't the seive
17:17:34 <zzaz> hmm i can't figure out how to get the source code..
17:17:59 <c_wraith> http://hackage.haskell.org/packages/archive/primes/0.1.1/doc/html/src/Data-Numbers-Primes.html
17:18:03 <c_wraith> that page is the source
17:18:10 <c_wraith> syntax-highlighted, even. :)
17:18:15 <zzaz> ok
17:19:04 <dons> Lemmih: did someone say haskell was slow??!!!
17:19:07 * dons gets his -O2 gun
17:19:11 <mmorrow> copumpkin: the version of that paste with IntMap is 7 seconds faster with IntMap
17:19:24 <copumpkin> out of 40?
17:19:27 <mmorrow> yeah
17:19:31 <copumpkin> hm
17:19:33 <zzaz> c_wraith: ran out of memory
17:19:42 <c_wraith> let me guess...
17:19:54 <c_wraith> You're using a non-strict function?
17:20:06 <c_wraith> like "sum", perhaps?
17:20:07 <copumpkin> zzaz: how are you running this?
17:20:21 <zzaz> hugs, length $ takeWhile (<10^7) primes
17:20:26 <copumpkin> zzaz: ghci?
17:20:32 <copumpkin> oh hugs
17:20:34 <copumpkin> crap :P
17:20:35 <mmorrow> heh
17:20:36 <zzaz> hmm i don't have that installed
17:20:44 <dons> hugs??
17:20:46 <copumpkin> zzaz: haskell does well in the benchmarks because of ghc
17:20:51 <copumpkin> (and smart coders)
17:20:55 <dons> hugs is on average 30x slower than ghc.
17:20:59 <dons> its a non-optimizing interpreter
17:21:07 <dons> compared to a state-of-the-art optimizing native code compiler
17:21:26 <zzaz> should i run it with ghc then
17:21:34 <dons> yes
17:21:35 <dons> 100%
17:21:39 <copumpkin> zzaz: do yourself a favor and get http://hackage.haskell.org/platform/
17:21:40 <copumpkin> :P
17:21:47 <copumpkin> you'll enjoy your haskell experience a lot more
17:21:52 <nominolo> aavogt: ok, you could try going to your vim_runtime_path/autoload/haskellcomplete.vim and grep for popen2 and remove that import
17:21:59 <dancor> is the proof technique of modus ponens really separate from the definition of consequence (->)?
17:22:13 <zzaz> ok i'll try that
17:23:11 <EvilTerran> dancor, i recall seeing modus ponens as "a, (a -> b) |- b" - ie, it eliminates a ->
17:23:30 <dancor> i guess it's worth naming that transformation
17:24:05 <EvilTerran> i guess it can be glossed over if you're working with denotational semantics
17:24:46 <copumpkin> modus ponens = uncurry (flip ($)) ?
17:25:18 <EvilTerran> but, if your logic is defined in purely in terms of relations on expressions, say, then it has no concept of implication until you single something out as being special
17:25:19 <centrinia> :t uncurry (flip ($))
17:25:21 <lambdabot> forall a b. (a, a -> b) -> b
17:25:27 <centrinia> :t uncurry (flip (id))
17:25:29 <lambdabot> forall a c. (a, a -> c) -> c
17:25:39 <EvilTerran> either "|-", in which case you need MP, or just flagging "->" as special if you're being a little less formal
17:25:55 <nominolo> sm: ah, I think found the problem for the eof error
17:25:59 <EvilTerran> copumpkin, well, we can ignore isomorphisms, so let's just go for modus ponens = ($) :)
17:25:59 <leithaus> does anyone know if bnf converter code is being maintained?
17:26:12 <copumpkin> EvilTerran: but it's cuter as a tuple
17:26:15 <copumpkin> :(
17:26:17 <c_wraith> Hmm.  Why is sum implemented with foldl instead of foldl' in ghc?
17:26:24 <leithaus> i've taken a critical dependency on this package
17:26:28 <copumpkin> leithaus: ?
17:26:42 <c_wraith> Are there any instances of Num where lazy semantics are appropriate?
17:26:47 <EvilTerran> peano numerals
17:26:56 <mmorrow> c_wraith: [a]
17:26:57 <copumpkin> > genericLength [1..] > (3 :: Natural)
17:26:58 <lambdabot>   True
17:27:06 <leithaus> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
17:27:08 <centrinia> Okay, which functions prove modus tollens?
17:27:08 <c_wraith> @Instances Num
17:27:09 <lambdabot> Double, Float, Int, Integer
17:27:09 <copumpkin> > foldr1 (+) [1..] > (3 :: Natural)
17:27:11 <lambdabot>   True
17:27:20 <copumpkin> c_wraith: ^^
17:27:31 <mmorrow> c_wraith: most lazy numbers are just [()] in the end, with fancy Ord/Eq instances
17:27:43 <EvilTerran> mmorrow, i prefer to call it Mu Maybe :P
17:27:51 <copumpkin> moo
17:27:56 <leithaus> i thought that since it has wormed its way into some of the linux distribs it was a safe bet
17:28:03 <EvilTerran> centrinia, iirc, hindley-milner corresponds to intuitionistic logic, so there is no modus tollens
17:28:11 <centrinia> Bummer.
17:28:25 <mmorrow> , Mu (Just (Mu (Just (Mu Nothing))))
17:28:28 <lunabot>  Mu (Just (Mu (Just (Mu Nothing))))
17:28:35 <aavogt> nominolo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8646#a8646 when using :LoadComponentScion xmobar.cabal
17:28:38 <dolio> @djinn (a -> b) -> Not b -> Not a
17:28:38 <lambdabot> f a b c = b (a c)
17:28:50 <aavogt> after removing the popen2 import
17:29:14 <leithaus> show "phred"
17:29:41 <monochrom> Heh Mu Mu ...
17:29:42 <copumpkin> dolio: what does Not correpond to? a -> Void ?
17:29:47 <mmorrow> , fix (("pred" ++) . show)
17:29:48 <dolio> Yes.
17:29:49 <lunabot>  "pred\"pred\\\"pred\\\\\\\"pred\\\\\\\\\\\\\\\"pred\\\\\\\\\\\\\\\\\\\\\\...
17:29:57 <vyom> i cant get a simple function from scheme working in Haskell : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3432#a3432 pls help what am I doing wrong
17:30:02 <nominolo> aavogt: ok, zo wmaw di eb
17:30:08 <nominolo> uargs
17:30:25 <nominolo> aavogt: ok, so that fixed the warning, but not the real problem
17:30:33 <aavogt> yeah
17:30:37 <Stinger> anyone happen to know what catchDyn belongs to?
17:30:46 <nominolo> aavogt: what does `which scion-server` say?
17:30:47 <EvilTerran> ?hoogle catchDyn
17:30:47 <lambdabot> Control.Exception catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
17:30:47 <mmorrow> Control.OldException
17:31:13 <Stinger> hmm it was on hoogle
17:31:18 <mmorrow> i don't know why that got dropped
17:31:26 <mmorrow> (from Exception)
17:31:31 <Stinger> I tried Hayoo and figured that would be a superset
17:31:42 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8647#a8647
17:33:08 <dolio> @djinn (Not b -> Not a) -> a -> b
17:33:09 <lambdabot> -- f cannot be realized.
17:33:33 <vyom> anybody? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3432#a3432 what am I doing wrong?
17:33:36 <aavogt> nominolo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8647#a8648
17:34:13 <copumpkin> what fallacy is that?
17:34:13 <nominolo> aavogt: ah, sorry, i meant without the ` `
17:34:31 <centrinia> vyom: sum_ f (a + (dx/2)) (\x -> x + dx) b * dx
17:34:36 <aavogt> nominolo: /usr/bin/scion-server
17:34:44 <nominolo> aavogt: ah, that is the problem
17:34:55 <dolio> copumpkin: There's no Not (Not a) -> a in intuitionistic logic, if that's what you mean.
17:34:58 <nominolo> aavogt: your .vimrc says ~/.cabal/bin/scion-server
17:35:09 <aavogt> but I also have one in ~/.cabal/bin/scion-server
17:35:13 <dolio> @djinn (Not b -> Not a) -> a -> Not (Not b)
17:35:13 <lambdabot> f a b c = void (a c b)
17:35:22 <copumpkin> ah
17:35:41 <nominolo> aavogt: ok, then try specifying the full path, i.e., no ~
17:35:48 <copumpkin> (it wasn't, but I'll leave it at that :P)
17:36:03 <centrinia> @let sum_ term a next b | a>b=0 |  otherwise = (term a) + (sum_ term (next a) next b)
17:36:05 <lambdabot>  Defined.
17:36:16 <centrinia> @let  integral f a b dx = sum_ f (a + (dx/2)) (\x -> x + dx) b * dx
17:36:17 <lambdabot>  Defined.
17:36:28 <centrinia> > integral (\x -> x^2) 0 1 0.01
17:36:30 <lambdabot>   0.33332500000000054
17:36:34 <centrinia> > integral (\x -> x^3) 0 1 0.01
17:36:35 <lambdabot>   0.24998750000000042
17:37:07 <aavogt> nominolo: looks like it's doing something... is there support for Paths_ modules?
17:37:18 <centrinia> > integral (\x -> exp x) 0 1 0.01
17:37:20 <lambdabot>   1.7182746689723096
17:37:30 <nominolo> aavogt: Theoretically yes
17:37:30 <vyom> centrinia: ok so the mistake was in the syntax and the f was getting evaluated instead of being passed into the function. Right?
17:37:32 <zzaz> compiling with GHC gives me an undefined reference to __stginit_ZCMain, help?
17:37:39 <Gracenotes> symbolic integration! ... as a Haskell one-liner! ...
17:37:44 <copumpkin> zzaz: pass --make
17:37:55 <copumpkin> Gracenotes: not quite symbolic :P
17:38:11 <Gracenotes> I mean, do it! ...
17:38:15 <zzaz> GHC produces a .hi and .o file
17:38:15 <copumpkin> oh
17:38:17 <copumpkin> :P
17:38:23 <centrinia> vyom: The mistake was with the syntax. You were trying to apply f to (a+(dx/2)) and then apply that function to (\x -> x+dx) and then aply that function to b :p
17:38:31 <copumpkin> zzaz: and an executable file?
17:38:39 <zzaz> no executable
17:38:43 <vyom> centrinia:  thanks
17:38:45 <copumpkin> o.O
17:38:48 <mmorrow> @djinn Not (Not a) -> Interior (Closure a)
17:38:48 <lambdabot> Error: Undefined type Interior
17:38:51 <copumpkin> zzaz: how did you compile?
17:38:53 <centrinia> @type \ f a b dx -> sum_ (f (a + (dx/2)) (\x -> x + dx) b) * dx -- :p
17:38:54 <lambdabot> forall t a a1. (Fractional (a -> (a -> a) -> a -> a1), Ord a, Num a1) => ((a -> (a -> a) -> a -> a1) -> ((a -> (a -> a) -> a -> a1) -> a -> (a -> a) -> a -> a1) -> t -> a -> a1) -> (a -> (a -> a) ->
17:38:54 <lambdabot> a -> a1) -> t -> (a -> (a -> a) -> a -> a1) -> a -> (a -> a) -> a -> a1
17:39:00 <zzaz> ghc --make foo.hs
17:39:07 <centrinia> @type \ f a b dx -> sum_ f (a + (dx/2)) (\x -> x + dx) b * dx -- =)
17:39:08 <lambdabot> forall a. (Fractional a, Ord a) => (a -> a) -> a -> a -> a -> a
17:39:14 <copumpkin> zzaz: does foo contain a main function?
17:39:22 <zzaz> yes
17:39:27 <copumpkin> zzaz: and is the module called Main?
17:39:35 <copumpkin> or no module name at all?
17:39:55 <aavogt> nominolo: what do you mean by theoretically? Does scion call the appropriate cabal things to generate the Paths_projectname module?
17:40:01 <zzaz> the module is not main, should i change it to Main?
17:40:04 <elliotstern> I'm having a type error I can't quite figure out:
17:40:05 <elliotstern> divisible :: Integer -> Integer -> Bool
17:40:07 <elliotstern> divisible n x = n `mod` x == 0
17:40:08 <elliotstern> prob5test n = foldr (and) x xs
17:40:10 <elliotstern> 	where (x:xs) = (map (divisible n) [1..20])
17:40:12 <elliotstern> Couldn't match expected type `b -> b' against inferred type `Bool'
17:40:13 <elliotstern>     In the first argument of `foldr', namely `(and)'
17:40:19 <nominolo> aavogt: it does.  I just don't know whether they are in the path, by default
17:40:47 <nominolo> aavogt: I used it with .y and .x files
17:41:58 <zzaz> copumpkin: ok i fixed it, deleted the module declaration
17:42:21 <aavogt> nominolo: ah, I guess there must be some way to add  dist/build/autogen/Paths_xmobar.hs  to the path
17:43:39 <zzaz> is GHCI (no -O2) faster than hugs?
17:43:45 <c_wraith> yes
17:44:06 <nominolo> aavogt: ok, so it should work, because I just set the flags that Cabal tells mo to
17:44:12 <nominolo> s/mo/me
17:45:16 <aavogt> hmm, should I upgrade to scion-0.1.0.1, or was that just for emacs?
17:45:26 <mmorrow> @djinn Not(Not(Not a)) -> Not a
17:45:26 <lambdabot> f a b = void (a (\ c -> c b))
17:45:36 <mmorrow> @djinn Not a -> Not(Not(Not a))
17:45:36 <lambdabot> f a b = void (b a)
17:46:02 <roconnor> > 40*logBase 2 10
17:46:03 <lambdabot>   132.8771237954945
17:46:04 <monochrom> Yay! Haskell Weekly News!!!111onethousandonehundredandeleven
17:46:05 <lilac> @djinn Not a -> Not (Not a)
17:46:06 <lambdabot> -- f cannot be realized.
17:47:30 <dolio> @yow!
17:47:30 <lambdabot> OMNIVERSAL AWARENESS??  Oh, YEH!!  First you need four GALLONS of JELL-O
17:47:31 <lambdabot> and a BIG WRENCH!! ... I think you drop th'WRENCH in the JELL-O as if
17:47:31 <lambdabot> it was a FLAVOR, or an INGREDIENT ... ... or ... I ... um ... WHERE'S
17:47:31 <lambdabot> the WASHING MACHINES?
17:47:45 <zzaz> huh
17:48:10 <roconnor> gah, integral so slow
17:49:13 <mmorrow> roconnor: you can always write a quasiquoter, then parse the function and symbolically integrate it (if possible)
17:49:25 <roconnor> bah!
17:49:27 <roconnor> bah I say
17:49:28 <roconnor> :)
17:49:29 <mmorrow> [$int| \x -> x |]
17:49:49 <roconnor> stupid exponential algorithm
17:50:09 <copumpkin> roconnor: aw, don't be hatin dem exponents
17:51:27 <roconnor> @type showCReal
17:51:28 <lambdabot> Int -> CReal -> String
17:51:30 <mmorrow> @. pl djinn Not(Not(Not a)) -> Not a
17:51:30 <lambdabot> f = (void .) . (. flip id)
17:51:37 <mmorrow> @. pl djinn Not a -> Not(Not(Not a))
17:51:37 <lambdabot> f = (void .) . flip id
17:52:19 <dolio> copumpkin: So, have you read all 1695 comments about why people hate Java yet?
17:52:42 <elliotstern> Not all of them, but most
17:52:49 <copumpkin> dolio: they got a little boring after a while, and my work won :/
17:52:54 <dolio> :)
17:53:02 <copumpkin> bad procrastination aid :(
17:53:03 <zazz> does main in GHC _have_ to be IO ()? because none of the programs I wrote in Hugs work anymore ;(
17:53:17 <copumpkin> zazz: what would your program do otherwise?
17:53:20 <gwern> I think it's actually IO a
17:53:31 <dolio> Yeah, IO a should work, I think.
17:53:32 <copumpkin> main = 5 + 10
17:53:34 <gwern> since I recall writing some scripts which turned out to be main :: IO (IO ())
17:53:39 <copumpkin> what would the program do if you ran it?
17:53:57 <zazz> load it in ghci and type main to run it?
17:54:07 <copumpkin> that will work
17:54:24 <pr> no
17:54:27 <copumpkin> zazz: but compiling (ghc -O2) will make it a lot faster
17:54:30 <zazz> so i have main = foo 1 2 3 instead of main = print $ foo 1 2 3
17:54:43 <pr>     No instance for (Num (IO t))
17:55:15 <copumpkin> ah true
17:55:29 <copumpkin> zazz: anyway, you only need main if you're compiling
17:55:30 * roconnor tries to integerate (^2)
17:55:31 <Phyx-> evening folks
17:55:37 <copumpkin> otherwise jjust say "yo = 5 + 10"
17:55:39 <copumpkin> open ghci
17:55:40 <copumpkin> and type yo
17:55:43 <zazz> can i have GHCI accept main?
17:55:47 <Phyx-> yo?
17:55:52 <pr> yo dawg
17:55:55 <zazz> so i don't have to change everything
17:55:56 <copumpkin> hey, first thing that came to mind :P
17:55:56 <Phyx-> lol
17:55:59 <Phyx-> > yo
17:56:00 <lambdabot>   Not in scope: `yo'
17:56:04 <Phyx-> aww
17:56:04 <copumpkin> zazz: it's one word...
17:56:17 <mmorrow> zazz: sure, but it's just a coincidence that that function is called "main" of course (if it's not (main :: IO ()))
17:56:30 <mmorrow> main :: IO a
17:56:31 <mmorrow> i mean
17:57:33 <roconnor> come on, the answer is 1/3
17:58:09 <copumpkin> roconnor: can you work on Rational?
17:58:14 <copumpkin> might be a lot faster
17:58:22 <copumpkin> (than CReal)
17:58:30 <roconnor> copumpkin: nah, rational numbers are probably slower
17:58:36 <copumpkin> really?
17:58:55 <roconnor> well, maybe if you through some approxRationals, then it'd be okay
17:59:02 <roconnor> but then you might as well be using CReal
17:59:49 <roconnor> and, of course, you cannot compute the modulus of continuity for an arbitrary Rational -> Rational
18:00:00 <copumpkin> clearly ;)
18:00:01 <mmorrow> > (1e-42)==(0::CReal) {- confidence inspiring -}
18:00:02 <lambdabot>   True
18:00:10 <SamB_XP_> roconnor: the what?
18:00:10 <roconnor> mmorrow: that isn't my idea
18:00:23 <roconnor> SamB_XP_: the modulus of continuity
18:00:34 <copumpkin> SamB_XP_: YOU MEAN YOU DON'T KNOW WHAT THAT IS??
18:00:40 <mmorrow> roconnor: ? i was just pointing that out in general
18:00:40 <copumpkin> pfft
18:00:46 <roconnor> or the inverse of the modulus of continuity, depending on how you define it.
18:01:19 <mmorrow> wtf is the modulus of continuity?
18:01:42 <roconnor> mmorrow: for a continuous function on a compact set, it is the function from epsilon to delta
18:01:43 <copumpkin> http://en.wikipedia.org/wiki/Modulus_of_continuity apparently
18:02:03 <roconnor> (although some people use a function from delta to epsilon for some reason)
18:02:03 <mmorrow> hehe, "It is used as a delicate tool in mathematical analysis.."
18:02:11 <copumpkin> :P
18:02:17 <copumpkin> epsilon is awfully small
18:02:23 <copumpkin> you gotta be careful, cause it's delicate
18:02:34 <mmorrow> DONT BREAK IT!
18:02:38 <copumpkin> :)
18:02:40 * copumpkin sneaks away
18:02:44 <roconnor> mmorrow: what I mean is the inverse of that.
18:02:49 <ray> it is the 30-lb battleaxe of mathematical analysis..
18:02:53 <Phyx-> > :t foldr
18:02:54 <lambdabot>   <no location info>: parse error on input `:'
18:02:57 <Phyx-> :t foldr
18:02:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:03:05 <Phyx-> :t foldr gmapT
18:03:06 <lambdabot> forall b. (Data b) => b -> [forall b1. (Data b1) => b1 -> b1] -> b
18:03:18 <Phyx-> :t foldr gmapT undefined
18:03:20 <lambdabot> forall b. (Data b) => [forall b1. (Data b1) => b1 -> b1] -> b
18:03:28 <roconnor> mmorrow: the modulus plays a prominant role in constructive/computable analysis.
18:03:40 <mmorrow> roconnor: ah, i see
18:04:03 <roconnor> it says how much the input needs to be approximated to approximate the output.
18:04:08 <Phyx-> :t foldr gmapT undefined [id]
18:04:09 <lambdabot> forall b. (Data b) => b
18:04:13 <Phyx-> heh
18:04:20 <Phyx-> > foldr gmapT undefined [id] :: Int
18:04:22 <lambdabot>   * Exception: Prelude.undefined
18:04:24 <Phyx-> aww
18:04:30 <ray> am i the only person who can't install a package off hackage without ld eating all his memory and crashing his system?
18:04:37 <ray> because that's what just happened to me
18:04:41 <ray> and it is not the first time
18:05:37 <Phyx-> > foldr gmapT id [id] :: Int
18:05:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:05:44 <Phyx-> > foldr gmapT 9 [id] :: Int
18:05:46 <lambdabot>   9
18:05:50 <Phyx-> did i just make
18:05:56 <Phyx-> a very complicated
18:05:57 <Phyx-> id
18:05:58 <Phyx-> lol
18:06:14 <roconnor> lambdabot will not like this integral :(
18:06:33 <roconnor> I can't even compute 40 digits of integral01 id
18:07:00 <roconnor> so many little rectangles need to be summed.
18:07:08 <Phyx-> > foldr gmapT 9 [(+1),(+2)] :: Int
18:07:09 <lambdabot>   Could not deduce (GHC.Num.Num b)
18:07:09 <lambdabot>    from the context (Data.Data.Data b)
18:07:09 <lambdabot>    ...
18:07:11 <dolio> "ndm: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function."
18:07:14 <roconnor> > 10^40
18:07:16 <lambdabot>   10000000000000000000000000000000000000000
18:07:16 <dolio> Was that quote made this week?
18:07:30 <Phyx-> > foldr gmapT 9 [(+1)::Int->Int,(+2)] :: Int
18:07:31 <dolio> It sounds like something from that sorting thread on the mailing list years ago.
18:07:31 <lambdabot>   Couldn't match expected type `b'
18:07:43 * Phyx- thinks lambdabot is smoking crack
18:08:05 <gwern> dolio: it's the same
18:08:13 <gwern> we still don't have yhc's smarter sort
18:08:19 <dolio> Yeah, I know.
18:08:33 * gwern intends to do something about it. eventually.
18:08:43 <dolio> I think we had this conversation already. :)
18:08:49 <gwern> on reddit perhaps
18:08:53 <dolio> Yeah.
18:09:56 <gwern> a conversation about sorting begins, and blows through #haskell; this is not the first conversation, nor the last - for there are no limits to GHC inertia - but it is *a* conversation
18:10:35 <ray> that should be the weekly news quote, i think
18:10:56 <SamB_XP_> how many years has this been ?
18:11:22 <gwern> ray: it'd be hard to come up with an exact good parody for the HWN. jordan's originals are pretty tight and rhythmic
18:11:57 <dolio> ndm has a blog post about it from over a year ago...
18:12:02 <lilac> ray: i see that too, but only on a quite memory-restricted box
18:12:18 <ray> i'm not exactly swimming in memory here, but this is totally ridiculous
18:12:26 <ray> it's linking the cabal setup thing, not even the actual package
18:12:45 <dolio> I guess the mailing list thread is about that old, too. So... a year and a half.
18:12:51 <ray> for the ones where it does get to the actual package it just swallows up even more memory
18:13:46 <dcoutts> ray: is it ld that it taking so much or ghc?
18:14:03 <ray> it is ld
18:14:17 <lilac> i vaguely recall an ld switch which is supposed to help (at the expense of slower links)
18:14:33 <lilac> --no-keep-memory
18:14:36 <dcoutts> ray: I know that ghc's split-objs feature makes ld sweat a bit, especially older binutils
18:14:45 <ray> yes, i found a way to pass it through cabal and ghc to ld
18:14:58 <ray> but it does not stop ld from using unreasonable amounts of memory
18:15:07 <roconnor> Prelude Integration> showCReal 1 (diag (integral01 (^2)))
18:15:08 <roconnor> "0.3"
18:15:10 <ray> they are noticably less unreasonable, but that doesn't help if it wants to eat everything and more
18:15:11 <roconnor> good enough. :D
18:15:26 <dcoutts> ray: are you using a distro package or your own ghc build?
18:15:43 <ray> it's the generic ghc binary
18:15:59 <gwern> @quote good.news
18:15:59 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
18:16:11 <dcoutts> ray: I hesitate to say that you can build it yourself and turn off the split objs feature, but it should make ld less upset
18:16:29 <dcoutts> ray: see, ld is not designed for .a files containing 10,000s of tiny .o files
18:16:44 <ray> ah, is that what it's getting?
18:16:57 <lilac> shouldn't that be "... so you can compile your interpreter's compiler while you interpret'? :)
18:17:17 <dcoutts> $ ar t /usr/lib/ghc-6.10.4/base-4.1.0.0/libHSbase-4.1.0.0.a | wc -l
18:17:17 <dcoutts> 10666
18:17:21 <dcoutts> ray: ^^
18:17:28 <gwern> lilac: truthfully, I have a hard time following the futamura projections, so I'm not sure
18:18:09 <roconnor> Prelude Integration> showCReal 2 (diag (integral01 (^2)))
18:18:10 <dcoutts> ray: if you rebuild ghc without split objs then you get a reasonable number. On the other hand, your final executables will be much larger.
18:18:11 <roconnor> "0.33"
18:18:13 <roconnor> any more is too much
18:18:25 <ray> what does it do, split every function?
18:18:30 <mmorrow> might as well be using Double ;)
18:18:32 <copumpkin> :o
18:18:37 <mle> clearly we should just implement a haskell-native libbfd and binutils.  and maybe world peace.
18:18:46 <Phyx-> o.O
18:18:56 <inimino> ray: I abandonded Haskell for a project in the past because of that very reason, the hassle of building on a VPS with limited memory
18:19:02 * mmorrow seconds mle
18:19:13 <dcoutts> ray: for some reason ld is no good at only pulling in the necessary bits, when it comes to Haskell code. Splitting each function into its own .o file makes it to a better job on that front.
18:19:31 <ray> i mean, i have 256MB, which isn't that big but not exactly what you think of as "linker crashes the system" small
18:19:56 <inimino> I think that's about what I had on the VPS in question :-)
18:20:03 <dcoutts> ray: on Gentoo, we used to turn off the split objs feature for any machine with less than 512Mb
18:20:39 <lilac> gwern: IIRC 1) specializer interpreter program == compiled program. 2) specializer specializer interpreter == compiler. 3) specializer specializer specializer == (\interpreter -> compiler for same language)
18:20:44 <dcoutts> ray: and the other thing is you want to make sure you've got binutils 2.17 or later, earlier ones are even worse on the many small .o file front
18:21:17 <ray> yeah, i have 2.18 or something
18:21:35 <dcoutts> ray: well I can assure you it use to be ~5x worse ;-)
18:21:47 <dcoutts> until I sent in patch
18:23:02 <lilac> ray: i have 234MB ram on my problematic box, so think yourself lucky :)
18:23:30 <SamB_XP_> dcoutts: I bet it's because those Haskell modules are always so interwingled ...
18:23:43 <dcoutts> ray: so if you're doing serious development then I'd recommend rebuilding without split objs. The downside is building ghc is something you'll want to leave running overnight.
18:23:53 <nominolo> GHC uses less memory if you use it in one-shot mode
18:24:03 <nominolo> i.e., not using --make
18:24:17 <SamB_XP_> nominolo: but ld is the real RAM-eater ...
18:24:23 <ray> well, as long as ld doesn't explode when linking ghc..
18:24:26 <SamB_XP_> and --make doesn't make that better or worse
18:24:34 <dcoutts> SamB_XP_: I think it's probably just that ld has some heuristic for working out which bits are needed but that it only works well for C code, when the heuristic criteria doesn't match then it just sucks in the whole .o
18:24:37 <nominolo> SamB_XP_: ah, I see.  fair enough
18:24:51 <hackagebot> scion 0.1.0.2 - Haskell IDE library (ThomasSchilling)
18:25:02 <SamB_XP_> dcoutts: oh, you mean it's supposed to be able to use bits and pieces of a .o?
18:25:14 <ray> yeah
18:25:18 <SamB_XP_> ... I didn't think they had sufficient information for that to work!
18:25:40 <ray> well, his point is they don't for what ghc emits (but presumably do for what gcc emits)
18:25:48 <SamB_XP_> I thought .os usually had hard-coded relative offsets galore
18:26:06 <nominolo> sm: 0.1.0.2 should fix the error in process filter stuff
18:26:08 <dcoutts> ray: see http://hackage.haskell.org/trac/ghc/wiki/Building, the main thing is to add SplitObjs=NO to mk/build.mk
18:26:17 <sm> thanks nominolo
18:26:25 <sm> will try later
18:26:37 <nominolo> yeah, I'm going to bed now
18:26:42 <sm> g'night
18:29:19 <mmorrow> lilac: what are the missing for/of/by-means-of/with/etc words in your description of the futamura projections?
18:30:04 <mmorrow> <lilac> gwern: IIRC 1) specializer interpreter program == compiled program. 2) specializer specializer interpreter == compiler. 3) specializer specializer specializer == (\interpreter -> compiler for same language)
18:30:42 <mmorrow> i don't understand what "a b c" means
18:31:10 <mmorrow> application? intercalate "of" ?
18:37:56 <inimino> mmorrow: looks like application
18:39:04 <lilac> mmorrow: application. specializer, interpreter :: Program -> Input -> Output
18:39:25 <mmorrow> i'm reading the wikipedia page now
18:40:11 <mmorrow> partial-evaluator applied to an (interpreter applied to a program) ==> compiler
18:41:04 <mmorrow> err
18:41:24 <mmorrow> (\program -> partial-evaluator applied to an (interpreter applied to a program)) ==> compiler
18:42:29 <lilac> partial evaluator applied to an interpreter and a program == compiled form of that program
18:42:39 <mmorrow> right
18:42:58 <mmorrow> and partial evalutator applied to an interpreter with itself as input ==> compiler-generator
18:42:59 <lilac> partial evaluator applied to a partial evaluator and an interpreter == compiler
18:43:17 <lilac> (for the language the interpreter interprets)
18:44:30 <lilac> and partially evaluating what a partial evaluator would do when given a partial evaluator as its first argument gives a program which takes interpreters and produces compilers,
18:44:37 <mmorrow> hmm, i need to write this all down to be rigorous about it
18:44:58 <lilac> these are all 2-argument functions
18:45:51 <mmorrow> ah, ok
18:46:53 <lilac> perhaps specializer :: Program (Program (a -> b -> c) -> a -> Program (b -> c))
18:47:35 <mmorrow> oh yay, http://www.brics.dk/~hosc/local/HOSC-12-4-pp381-391.pdf
18:47:52 <lilac> @type let specializer :: Maybe (Maybe (a -> b -> c) -> a -> Maybe (b -> c)); specializer = undefined in fromJust specializer specializer specializer
18:47:53 <lambdabot> forall b b1 c. Maybe (Maybe (b -> b1 -> c) -> Maybe (b -> Maybe (b1 -> c)))
18:49:16 <lilac> ^^ a program (interpreter-to-compiler-converter) which takes a program of 2 arguments (an interpreter taking code and input) and returns a program (a compiler) which takes the code and returns a compiled program (input -> output)
18:49:35 <nominolo> mmorrow: ah, the Futurama paper
18:49:36 <mmorrow> lilac: right, that's exactly what i'm trying to do (start with an empty data decl "data Program static input output", and go from there)
18:51:07 <mmorrow> nominolo: heh
18:51:47 <lilac> (in the above, interpreter :: Program (a -> b -> c), and Program represents a binary executable of some sort)
19:00:58 <roconnor> Prelude Integration> showCReal 3 (diag (integral01 (^2)))
19:00:59 <roconnor> "0.333"
19:01:01 <roconnor> (1700.32 secs, 406044251268 bytes)
19:01:06 <copumpkin> oh wow
19:01:14 <copumpkin> congratulations though!
19:01:21 <roconnor> \o/
19:01:27 <copumpkin> what's the diag doing?
19:01:44 <roconnor> ya, that should be baked into the definition of integral
19:01:50 <path[l]> hey Berengal you around?
19:01:56 <path[l]> or jmcarthur
19:02:10 <roconnor> integral01 is currently returning an Int -> CReal ~~ Int -> (Int -> Integer)
19:02:55 <roconnor> basically it is returning a real number that uses real number approximations instead of integer approximations
19:03:14 <roconnor> so diag "diagonalizes" this to get a proper CReal
19:04:02 <roconnor> there is some nifty trick going on here to get enough laziness for the integral to process.  I just don't know how to isolate it.
19:04:49 <copumpkin> :o
19:05:02 <roconnor> Escardo uses signed digit {-1, 0, 1}
19:05:15 <roconnor> but at one point you need something a digit set closed under averaging
19:05:33 <roconnor> one solution is to use diadic rationals as a huge signed digit set
19:06:01 <roconnor> but what actually works better for Escardo is to use a digit set formed from real numbers in [-1, 1]
19:06:15 <roconnor> which are convenently laying around.
19:22:56 <vyom> I cannot this to compile : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3433#a3433 How can I fix it using type declarations?
19:24:26 <roconnor> vyom: add type annotations ?
19:24:39 <path[l]> my gues is the "next b"
19:24:44 <path[l]> needs brackets
19:24:49 <path[l]> or like $ next b
19:25:01 <vyom> roconnor:  I need help adding type annotations.. I tried simpson :: (Num a) => (a -> a) -> a -> a -> a -> a   but that doesnt help ofcourse
19:25:30 <vyom> then i tried simpson :: (Fractional f) => (f -> f) -> f -> f -> f -> f
19:25:36 <vyom> that doesnt help either
19:26:13 <roconnor> what happens when you add the fractional signature?
19:26:14 <vyom> how do i go about pinpointing where the ambiguity is
19:26:48 <babusrini> How can I get a pseudo-random sequence of integers in the range of (0,2^32-1) that is guaranteed not to repeat for say 10 or 20 million. I am getting a few repetitions in well under a million sequences. I am using System.Random.
19:27:41 <roconnor> vyom: step 1 is to add type signatures to every (or most) top level functions
19:27:43 <vyom> roconnor:  It says " Could not deduce (Integral f) from the context (Fractional f) in even"
19:27:50 <path[l]> well if all of them have type signatures, you should atleast know which of those doesnt match it?
19:28:42 <roconnor> vyom: then add some type signatures to possibly relevent where clauses
19:29:03 <roconnor> oh wait
19:29:09 <badsheepy> guaranteed not to repeat isnt random at all
19:29:10 <roconnor> damn, that doesn't always work.
19:29:34 <roconnor> vyom: where is even called?
19:29:41 <roconnor> ah there
19:29:42 <roconnor> @type even
19:29:44 <lambdabot> forall a. (Integral a) => a -> Bool
19:30:47 <roconnor> vyom: you need to use fromIntegral to convert from integral types to fractional types
19:31:03 <roconnor> vyom: for example :                         y k  = f (a + (fromIntegral k)*h)
19:31:19 <vyom> roconnor:  ok will try that.. thanks
19:31:35 <mjs22> or say:  even (round k)
19:31:55 <mjs22> and use this signature: simpson :: RealFrac a => (a -> a) -> a -> a -> a -> a
19:32:00 <mmorrow> babusrini: the mersenne-twister algo is more random and much faster than System.Random, but wrt no repeats i'm not sure if it guarantees that. you can always discard repeats until you get 10million unique elements though
19:32:14 <roconnor> yes, round will convert from fractional to integral types, but usually you don't want to do this.
19:32:23 <mmorrow> babusrini: there're two mt pkgs on hackage
19:34:05 <mjs22> roconnor: true.
19:35:02 <Gracenotes> ugh... if the monomorphism restriction is a problem, ghci should say that it's the monomorphism restriction, not that there's no instance :/
19:35:43 <veinor> but don't you expect to get reptitions in on the order of 2^16?
19:36:39 <roconnor> I need to add nomonomorphismsrestriction to my .ghci file.
19:37:15 <veinor> yeah, math works out that you have a good chance of getting collisions in a n-bit range after generating 2^n/2 numbers
19:37:35 <mmorrow> veinor: i think he just needs a bunch of unique random numbers
19:37:47 <veinor> but if they're constrained to be unique, are they truly random?
19:38:05 <mmorrow> decreasingly so
19:38:28 <aavogt> :t randoms
19:38:30 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
19:38:31 <mmorrow> but if Int is 64 bits and you only need 10million
19:38:41 <aavogt> :t nub . randoms
19:38:43 <lambdabot> forall a a1. (Eq a, Random a, RandomGen a1) => a1 -> [a]
19:39:20 <veinor> yeah, you wouldn't be colliding then
19:39:30 <mmorrow> veinor: but if you view the sequence of numbers as a whole..
19:39:57 <veinor> hm?
19:39:59 <mmorrow> and not incrementally by one-after-one getting the next element revealed to you
19:40:26 <veinor> I mean, if you're generating a few million 64-bit Ints, your collision odds are vanishingly small
19:40:28 <mmorrow> i.e. a function  generateASetOfTenMillionInts
19:40:40 <mmorrow> where Set := no repeats
19:41:59 <Gracenotes> hm.. immutable data structures might be fine for modeling graphs, but they're starting to become a bit cumbersome for ordering nodes and doing horizontal coordinate assignment.
19:42:02 <Trinithis> > 2 ^ 64
19:42:03 <lambdabot>   18446744073709551616
19:42:08 <roconnor> possibly your nub function would be more likely to fail due to a cosmic ray than a collision
19:42:26 <veinor> heh, math says that the odds of not getting repeats in a million-long sequence of ints between 0 and 2^32 is about 1-e^230
19:42:31 <veinor> er, odds of getting repeats
19:42:43 <veinor> and that's e^-230
19:42:43 <copumpkin> really?
19:42:51 <roconnor> > exp (-230)
19:42:52 <lambdabot>   1.2949981925089835e-100
19:42:58 <Gracenotes> for most algorithms, there's really a choice between O(n) preprocessed information or O(n^2) run time... the choice is obvious though.. :/
19:42:58 <roconnor> > exp (-230) :: CReal
19:43:00 <lambdabot>   0.0
19:43:02 <roconnor> :D
19:43:03 <mmorrow> gah! i've been running "let xs = take 10000000 . nub $ randoms g" (using mersenne pure64) for over five minutes (in ghci)
19:43:14 <mmorrow> maybe s/nub/something mo betta/
19:43:27 <veinor> copumpkin: yeah, it's basically a 32-bit hash collision
19:43:28 <copumpkin> mo betta is mo betta
19:43:47 <Gracenotes> copumpkin: let's not get objectivism involved now
19:43:58 <veinor> which you can find in an average of 2^16=65536 numbers
19:44:01 <vyom> roconnor: It works with calls to fromIntegral in a couple of places. I removed all my annotations and it still works. Thanks
19:44:40 <veinor> so finding collisions was just System.Random being truly random :P
19:44:58 <roconnor> vyom: horray
19:45:33 <vyom> roconnor: I never knew something called fromIntegral existed.. anyway..
19:45:57 <roconnor> vyom: it is a very important function
19:48:16 <mmorrow> veinor: what i meant with the "view the sequence as a whole" was that if you're generating sets of 10million elements as the basic unit-of-generation, then you'd be  considering the chances of generating two identical 10million-item sets rather than a single set with two duplicate elements, since sets can't have duplicate elements by definition
19:48:28 <veinor> Ahh
19:49:05 <veinor> Well, yeah. Your odds of repeats there are just the odds of you getting the same seed.
19:49:08 <babusrini> badsheepy: there is difference between random and pseudo-random numbers. Unless you use data from radioactive decay or thermal noise or something similar you cannot generate random numbers.
19:50:14 <babusrini> mmorrow, I will try the mersenne-twister
19:50:37 <badsheepy> uhm, well indeed
19:51:15 <badsheepy> pseudo or not, its not random if it guarantees no collisions
19:51:19 <mmorrow> what was that one website that provides random data gotten from some sort of electron/something detector?
19:51:34 <veinor> random.org?
19:51:35 <mmorrow> that is literally random
19:51:42 <mmorrow> heh, probably
19:51:48 <veinor> babusrini: you said you were finding repeats within million-long sequences in [0,2^32-1]?
19:51:53 <mmorrow> haha, good name
19:53:11 <mun> given newtype ResultT m a = ResultT { runResultT :: m (Result a) } what would runResultT A do?
19:53:25 <mun> runResultT a rather
19:53:27 <mmorrow> data A = A {runA :: Int}
19:53:35 <mmorrow> runA :: A -> Int
19:53:52 <mmorrow> data A = A Int; runA (A a) = a
19:53:57 <mmorrow> are the same thing
19:54:25 <mun> i see. but why is the first style used instea dof the second?
19:54:36 <mmorrow> no reason in particular
19:54:36 <copumpkin> except that one allows { runA = x }  and the other doesn't
19:54:43 <mmorrow> yeah, that's true
19:54:46 <Gracenotes> probably to establish an instance as some typeclass
19:54:55 <copumpkin> and autogenerated show/read instances are difference
19:54:57 <copumpkin> different
19:55:59 <Gracenotes> for a:: ResultT IO String, you could say a = ResultT getLine, and then runResultT .. again, it's probably for some monad-related typeclass...
19:56:00 <mun> what's { runA = x } for?
19:56:04 <mmorrow> the last thing i expected to see on random.org ==> "## Win an iPod! ← new!"
19:56:22 <gwern> seems pretty random to me
19:56:26 <mmorrow> hehe
19:56:35 <gwern> @quote random
19:56:35 <lambdabot> kaol says: it's not perl. I can't just pipe urandom to the parser.
19:56:44 <gwern> see?
19:56:53 <mun> thanks
19:56:54 <Gracenotes> they should include "Lose an iPod" in advertisements for gyms
19:57:05 <Gracenotes> :X
19:57:11 <mmorrow> heh
19:57:23 <Gracenotes> { a = b } is for replacing individual items in records..
19:57:58 <veinor> gwern: haha
19:57:59 <Gracenotes> changing the value of the attribute "a" to "b", whereas it was previously some other value....
19:58:03 <gwern> so I upgraded to karmic ubuntu today; now I have to run mplayer as root
19:58:07 <gwern> so I can't recommend it
19:58:10 <copumpkin> lol
19:58:12 <veinor> gwern: what? why would you?
19:58:12 <Gracenotes> ick.
19:58:21 <gwern> veinor: SHINY
19:58:30 <veinor> I mean why would mplayer require root
19:58:31 <Gracenotes> hope they get it ironed out
19:58:54 <Gracenotes> the ubuntu team always has large amounts of shiny in a reserve to motivate people to upgrade
19:59:01 <veinor> indeed
19:59:09 <veinor> what's the shiny for karmic going to be compared to intrepid?
19:59:09 <gwern> veinor: something to do with either the capability for realtime, or with output to something in /dev
19:59:19 <gwern> veinor: revamped boot
19:59:22 <gwern> seriously fast!
19:59:26 <veinor> neat
20:00:14 <mmorrow> maybe related.. while changing an selinux setting the other day i noticed there was a setting: "Allow mplayer executable stack"
20:00:18 <mmorrow> maybe related?
20:00:37 * gwern shrugs. I thought ubuntu didn't even use selinux, but apparmor
20:01:32 <mmorrow> but i mean, maybe you can only get an executable stack as root (which seems counter-intuitive now that i think about it) due to some ubuntu-specific whatever
20:02:07 <glguy> You can set the SELinux context on a file to give it executable stack
20:02:27 <glguy> err, execmem
20:02:31 <mun> for the function at http://haskell.pastebin.com/m5d4948b7 wouldn't anaSourceFile return IO (Result (LIB_NAME,LibEnv)) instead of ResultT IO (LIB_NAME,LibEnv)? doesn't runResultT give the first type?
20:03:12 <mmorrow> glguy: he doesn't have selinux though, his mention of mplayer only functioning as root made me remember randomly seeing an "Allow mplayer executable stack" policy/whatever
20:03:45 <gwern> well, for all I know, I do have selinux - maybe selinux and apparmor are 2 bad tastes that go great together
20:03:52 <mmorrow> glguy: but while on topic, what's the syntax to do that again? :)
20:04:01 <gwern> (ubuntu installs a lot of things, after all)
20:04:09 <babusrini> It is useful to be able to generate a repeatable pseudo-random sequence of numbers that satisty statistical criteria for randomness. Several years back they even published a book of 'random' numbers, just for this purpose. If I am generating 1 million random numbers, storing them and checking for duplicates is cumbersome; also will increase the time taken to get them.
20:04:23 <glguy> chcon -t execmem_exec_t
20:04:26 <gwern> babusrini: really? I thought that book was published just to get hilarious reviews
20:04:29 <glguy> chcon -t execmem_exec_t /path/to/bin
20:04:34 <mmorrow> gwern: "$ selinuxenabled; echo $?"
20:04:45 <mmorrow> glguy: thanks
20:04:55 <gwern> 'The program 'selinuxenabled' is currently not installed.  You can install it by typing:
20:04:59 <gwern> sudo apt-get install selinux-utils
20:05:06 <glguy> getenforce
20:05:08 * gwern doesn't know whether that feature is annoying or awesome
20:05:10 <glguy> will tell you if SELinux is enforcing
20:05:32 <mmorrow> ooh, good to know
20:05:32 <gwern> nah, I only have a 'getent'
20:05:44 <gwern> so then I suppose it can't be selinux's fault
20:06:01 <glguy> For me, getenforce is in libselinux-utils-2.0.80-1.fc11.i586
20:06:11 <mmorrow> gwern: what happens when you try to run mplayer not as root?
20:06:49 <gwern> mmorrow: bombs out with [AO_ALSA] alsa-lib: pcm_dmix.c:975:(snd_pcm_dmix_open) unable to create IPC semaphore
20:06:50 <glguy> In Fedora, if SELinux was the culprit, you would see record of that in /var/log/audit/audit.log
20:06:52 <gwern> [AO_ALSA] Playback open error: Permission denied
20:07:16 <glguy> gwern: maybe you just don't have permission to access the audio device
20:07:33 <gwern> glguy: but why would the upgrade have removed me from the audio group?
20:07:44 <monochrom> Hi, why are we talking about random numbers and audio drivers?
20:07:53 <glguy> gwern: maybe you get permissions to the audio device from policykit or something similar
20:07:53 <babusrini> gwern, you asked "maybe, but what good would that be" and so I guess you don't know why a pseudo-random sequence is useful.
20:08:00 <glguy> and that mechanism changed in the upgrade
20:08:17 <gwern> hm. I'm already in 'pulse' and 'pulse-access'
20:08:26 <glguy> gwern: mplayer is going via ALSA
20:08:31 <glguy> not pluse, according to what you pasted
20:08:56 <monochrom> Eh? We're troubleshooting someone's computer?
20:09:03 <veinor> indeed
20:09:34 <gwern> glguy: alsa isn't listed in e/tc/group, but pulse is in audio
20:10:08 <gwern> monochrom: well, I wasn't intending to trouble shoot it tonight, I just was making my usual smalltalk in this case about how ubuntu's karmic had bugs
20:11:29 <monochrom> What we really need is inclusion of Haskell Platform in karmic.
20:11:51 <gwern> probably way too late
20:19:07 <Lycurgus> is there an IDE of choice these days?
20:19:30 <copumpkin> I've heard people like leksah
20:19:35 <copumpkin> I just use a text editor myself :)
20:19:48 <Lycurgus> checking ...
20:21:03 <Lycurgus> Ok, yeah had that bookmarked, will now "play" with it.
20:21:40 <gwern> but leksah is so young! o.0
20:21:46 * gwern reports Lycurgus 
20:22:09 <Lycurgus> yeah, I beginning to see why I did play with it first time
20:22:14 <Lycurgus> *I'm
20:23:11 <copumpkin> oh my: http://us.php.net/manual/en/function.abs.php#58508
20:23:30 <matsuura> o_o
20:23:53 <matsuura> is this what our kids are being taught?
20:24:08 <copumpkin> did you read the full set of comments?
20:24:13 <copumpkin> they make me want to cry
20:24:15 <matsuura> all of them
20:24:59 <monochrom> This is what our kids are doing without being taught.
20:25:04 <matsuura> :(
20:25:06 <Lycurgus> I couldn't see past the fact that it was php.
20:25:12 <monochrom> Think of it as cogolfing.
20:25:18 <copumpkin> Lycurgus: lucky you
20:25:21 <copumpkin> lol
20:25:23 <matsuura> monochrom: I think we need to be having sexy with our kids more often..
20:25:28 <copumpkin> I love how coabs = negate
20:26:05 <dolio> Why does (-2) - (-2) *2 = 6?
20:26:11 <dolio> Or is he just wrong?
20:26:30 <copumpkin> it's all so wrong on so many levels
20:26:39 <dolio> Well, that's true.
20:26:44 <Lycurgus> lissen with literally millions and millions of what used to be called programmers and given prevailing social conditions, most of em gotta be mugglefuggles
20:26:45 <dolio> But PHP may also be wrong.
20:27:00 <copumpkin> no, another comment says it's unable to reproduce his "error"
20:27:14 <matsuura> lol
20:27:14 <gwern> '...you just need to do $num *= -1;' <-- sanity, thank god!
20:27:20 <dolio> I must say, n - n*2 is pretty good.
20:27:27 <dolio> I certainly wouldn't have come up with that solution.
20:28:01 <dolio> Heh, "numberic".
20:28:31 <Lycurgus> fortunately the attrition rate is or was taking care of most them within 5-10 years
20:28:36 <copumpkin> concordia, you seem to be overcomplicating matters.  If you want to do the reverse of the abs function, the only code required is:
20:28:41 <copumpkin>     return ($num > 0) ? $num * -1 : $num;
20:28:46 <copumpkin> he calls it n_abs :'(
20:29:23 <copumpkin> anyway :)
20:29:31 <copumpkin> sorry for the brief off-topic
20:29:41 <dolio> How did you find this?
20:29:54 <copumpkin> it's on reddit :P
20:30:04 <dolio> Ah, I suppose I should have guessed that.
20:30:20 * copumpkin is a webwhore
20:30:38 <monochrom> I should have applied my experiment on you.
20:30:41 <dolio> Oh man. "I'm sure there's probably a more elegant way to do this using regex"
20:31:02 <monochrom> "It's horrible, and you know it, so why are you inflicting it on us?"
20:31:26 <dolio> He was the one who caused you to initially mention that, too.
20:31:36 <Apocalisp> Gah! Some things on the internet you can never unsee.
20:31:39 <Lycurgus> yeah, leksah looks misconcieved as well as being in awkward English
20:32:00 <monochrom> How is leksah misconceived?
20:32:01 <Lycurgus> <- political incorrectness personified
20:32:02 <dolio> With his video of a steam roller drift racing two men in loin cloths holding stone-age wheels.
20:32:38 <copumpkin> Lycurgus: why? and why is that politically incorrect? it's just awkward to say something like that without a strong justification, given the way the community is structured
20:32:40 <glguy> dolio: I saw that one :)
20:32:57 <Lycurgus> in that it is does not leverage of of existing tools and evidences classic reinvent the wheel syndrome
20:33:06 <Lycurgus> *off of
20:33:06 <monochrom> Ha! I didn't watch that video. I didn't follow that video link at all. In this Internet age, it's safe to bet that a URL takes you to a horrible page.
20:33:07 <glguy> dolio: do you have the URL handy?
20:33:27 * copumpkin has way more horrible pages for monochrom to not visit
20:33:43 * copumpkin also enjoys split infinitives
20:34:08 <Lycurgus> s/it is/it/
20:34:59 <monochrom> There is quite a bit of reinventing existing tools in some Haskell people.
20:35:08 <Lycurgus> "reinvent the wheel"/"not invented here"
20:35:36 <dino-> Isn't it sort of misnaming it to say it's the "reverse of abs". I can't get go back from this: abs(2) without knowing that the original value wasn't negative. Information has been discarded.
20:36:00 <monochrom> English is equivalent to misnaming.
20:36:09 <copumpkin> php.net is equivalent to everything bad
20:36:14 <TimMc> So, I'm trying to learn me a Haskell, and I got to the part on list comprehensions... wtf @ [0.1, 0.3 .. 1]
20:36:28 <copumpkin> not a list comprehension
20:36:35 <copumpkin> > [0.1,0.3 .. 1]
20:36:36 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
20:36:43 <copumpkin> or is it wtf at the imprecision?
20:36:46 <monochrom> A better example:
20:36:54 <monochrom> > [1, 3 .. 10]
20:36:55 <lambdabot>   [1,3,5,7,9]
20:36:59 <TimMc> copumpkin: Erm, yes, not a comprehension. That was the title of the next section, so it got stuck in my head.
20:37:17 <copumpkin> that's just syntactic sugar for enumFrom(Then)(To)
20:37:26 <copumpkin> > enumFromThenTo 1 3 10
20:37:27 <lambdabot>   [1,3,5,7,9]
20:37:35 <monochrom> If you say [1..10] you get [1,2,3,4,5,6,7,8,9,10]. But sometimes you want an increment more than 1.
20:37:42 <TimMc> copumpkin: WTF @ the tail (1.1) definitely being > 1.0
20:37:51 <copumpkin> oh, that is wtf-worthy :P
20:37:52 <monochrom> Generally you can get any arithmetic sequence.
20:38:12 <copumpkin> TimMc: a bug that crept into the standard, I think :)
20:38:12 <monochrom> Floating point is not quite suitable for this.
20:38:35 <TimMc> The author notes that ranges with floating point are touchy, but I would consider it a serious bug.
20:38:47 <monochrom> > [0.1 , 0.3 .. 1] :: [CReal]
20:38:48 <lambdabot>   [0.1,0.3,0.5,0.7,0.9]
20:38:57 <copumpkin> don't worry, after more than a decade, we might finally get a new standard :P
20:39:10 <monochrom> @quote ray h98
20:39:10 <lambdabot> No quotes match. stty: unknown mode: doofus
20:39:21 <copumpkin> @quote ray haskell'
20:39:21 <lambdabot> No quotes match. Where did you learn to type?
20:39:42 <copumpkin> ray: haskell' will come out in 2020 and be h98 with hierarchical
20:39:42 <copumpkin>       modules
20:39:45 <monochrom> Yeah, I just saw it on HWN
20:40:01 <copumpkin> @remember ray haskell' will come out in 2020 and be h98 with hierarchical modules
20:40:01 <lambdabot> It is forever etched in my memory.
20:40:04 <monochrom> Oh, lambdabot probably suffered a crash today.
20:40:06 <copumpkin> @flush
20:40:06 <lambdabot> Not enough privileges
20:40:23 * copumpkin giggles evilly
20:40:30 <monochrom> And yeah, wtf is with @flush needing any privilege at all?
20:40:33 <TheHunter> @flush
20:40:46 <monochrom> Is that a flushbot?!!
20:40:50 * copumpkin puts on sunglasses
20:40:53 <gwern> monochrom: DoS considerations maybe
20:40:54 * copumpkin whistles
20:41:12 <SamB_XP_> gwern: throttling is *that* hard?
20:41:34 <gwern> SamB_XP_: apparently?
20:41:38 <monochrom> Unix and linux still have "sync" and no one seems to worry.
20:41:46 <gwern> as Eris said, 'I dunno man I wasn't there'
20:41:53 <SamB_XP_> anyway, wouldn't there be more issues with @let ?
20:42:01 <copumpkin> lambdabot's security is pretty hot
20:42:21 <gwern> SamB_XP_: covered by the eval mechanisms, I should think
20:42:22 <sjanssen> sync is lame
20:42:28 <copumpkin> requiring a /nick TheHunter before performing privileged commands is a good security mechanism
20:42:34 <copumpkin> oh crap
20:42:39 <SamB_XP_> gwern: doesn't it write the bindings to a file ?
20:42:47 <gwern>  lambdabot: 2 years without a remote IO a!
20:42:47 <SamB_XP_> ... immediately?
20:42:48 <monochrom> Hahaha
20:42:53 <sjanssen> copumpkin: don't make me remove TheHunter from admin!
20:43:01 <gwern> SamB_XP_: probably
20:43:05 <SamB_XP_> gwern: it was two years ago that we last read /etc/passwd with it ?
20:43:05 <copumpkin> sjanssen: oh no!
20:43:33 <gwern> sjanssen: ah, it doesn't matter. lambdabot never gets updated so even if you push a patch removing thehunter...
20:43:38 <SamB_XP_> copumpkin: it would work great if he didn't ever disconnect...
20:43:44 <monochrom> hahahahaha
20:43:48 <copumpkin> SamB_XP_: and none of the other admins disconnected ever :P
20:43:50 <dolio> > [0.1 , 0.4 .. 1.2] :: CReal
20:43:51 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
20:43:56 <sjanssen> gwern: clearly we need to find Cale in Canada and make him update
20:43:56 <dolio> > [0.1 , 0.4 .. 1.2] :: [CReal]
20:43:57 <lambdabot>   [0.1,0.4,0.7,1.0]
20:44:07 <SamB_XP_> sjanssen: what if he's at ICFP?
20:44:08 <copumpkin> Calehunt!
20:44:15 <monochrom> CReal seems to do well.
20:44:25 <gwern> sjanssen: but how can we bribe him? he exists up in the ethereal realm of Caleskell
20:44:38 <copumpkin> you must speak to anonycale, he knows how to get to the real Cale
20:44:49 <copumpkin> but anonycale only meets you in dark alleys
20:44:57 <dolio> > [0.1 , 0.4 .. 1.2]
20:44:58 <lambdabot>   [0.1,0.4,0.7000000000000001,1.0,1.2999999999999998]
20:45:02 <sjanssen> gwern: we just need to find his house
20:45:17 <sjanssen> can't be that many guys named Cale around :)
20:45:21 <SamB_XP_> yeah, how many houses could there be in some noplace like canada!
20:45:32 <Cale> what?
20:45:35 <sjanssen> I heard about 19 houses
20:45:37 <copumpkin> lol
20:45:38 <monochrom> Hahaha
20:45:42 <gwern> I'll admit, I'm not sure I've ever met anyone named Cale before
20:45:54 <TimMc> gwern: One can never be quite sure.
20:46:11 <gwern> (of course, strictly speaking, I've never met any Cales. but you know what I mean)
20:46:28 <Cale> It turns out that everyone in gwern's life is named Cale and they're all using fake identities.
20:46:36 <sjanssen> Cale: nothing really, we're just being goofy :)
20:46:51 <gwern> Cale: I wonder how they keep it straight
20:46:51 <monochrom> You can modify @flush to keep flushing at least 10 minutes apart.
20:47:00 <monochrom> err
20:47:07 <copumpkin> @quote ray h98
20:47:07 <lambdabot> ray says: haskell' will come out in 2020 and be h98 with hierarchical modules
20:47:08 <monochrom> You can modify @flush to keep consecutive flushings at least 10 minutes apart.
20:47:09 <lambdabot>  @flush
20:47:29 <copumpkin> lambdabot gives itself commands?
20:47:33 <SamB_XP_> ray: what? they're taking out FFI?
20:47:35 <sjanssen> whoa, @msg has been changed
20:47:38 <monochrom> @quote ray h98
20:47:38 <lambdabot> ray says: haskell' will come out in 2020 and be h98 with hierarchical modules
20:47:39 <Warrigal> It tries to, but it has selective mutism.
20:47:55 <gwern> copumpkin: it's our strategy for giving lambdabot sentience; we think if we can get recursion going on, it'll start thinking
20:47:59 <sjanssen> copumpkin: I typed this: /msg lambdabot @msg #haskell @flush
20:48:05 <copumpkin> lol
20:48:30 <sjanssen> monochrom: the funny part about that quote is how true it is
20:48:32 <SamB_XP_> monochrom: I was thinking more like ~20 seconds
20:49:04 <lambdabot> omgwtfbbq
20:49:11 <SamB_XP_> well, I think H2010 is supposed to be H98+heirarchical-modules+FFI
20:49:22 <copumpkin> I sure hope not
20:49:30 <SamB_XP_> +maybe-other-stuff
20:49:32 <Warrigal> @pf \f x -> f x x
20:49:32 <lambdabot> Maybe you meant: bf pl
20:49:36 <Warrigal> @pl \f x -> f x x
20:49:36 <lambdabot> join
20:49:45 <Warrigal> > join (++) "> join (++)"
20:49:46 <SamB_XP_> but only if everyone can agree on it and get it written up in time ...
20:49:47 <lambdabot>   "> join (++)> join (++)"
20:49:49 <monochrom> Better yet, why doesn't lambdabot do its own periodic flush?
20:50:14 <gwern> monochrom: christ, there's a lot of changes it'd be nice to make to lambdabot
20:50:19 <gwern> {{sofixit}}
20:50:23 <Warrigal> @pl \x -> x ++ show x
20:50:23 <lambdabot> ap (++) show
20:50:38 <Warrigal> > ap (++) show "> ap (++) show "
20:50:39 <lambdabot>   "> ap (++) show \"> ap (++) show \""
20:50:48 <monochrom> Fine.
20:50:51 <SamB_XP_> monochrom: with our luck, we'd do it just the wrong way for the kernel/FS in question and lambdabot would lose everything to a power outage ...
20:50:56 <sjanssen> monochrom: are you familiar with the term 'cruft'?  lambdabot = replicateM 9000 cruft
20:51:05 <lambdabot> > text "please fix me!"
20:51:12 <SamB_XP_> sjanssen: huh
20:51:19 <SamB_XP_> how does this cruft :: IO () function work?
20:51:26 <Warrigal> Now all you need to do is prepend (drop 3 "") to it, append (tail "") to it, and put (tail "") before every quotation mark.
20:51:44 <lambdabot> > text "you know, the spaces are there to prevent exactly the loops you're trying"
20:51:44 <monochrom> > drop 3 ""
20:51:45 <sjanssen> SamB_XP_: exercise for the reader
20:51:46 <lambdabot>   ""
20:52:03 <copumpkin> lambdabot: I think you also don't listen to yourself
20:52:43 <Warrigal> SamB_XP_: sjanssen nailed it. It publishes a book, declares the implementation of cruft to be an exercise for the reader, retreives all the answers it can from Google, runs all of them, and takes the median of the results.
20:53:13 <monochrom> SamB_XP_: I am not sure why periodic flush can be any worse than @flush.
20:53:14 <SamB_XP_> how do you take the median of a cumulative effect?
20:53:15 <copumpkin> the results must be Ord instances?
20:53:23 <copumpkin> to take the median of them
20:53:34 <Warrigal> Also, since drop 3 "" doesn't do what I thought it would, I guess we'll have to use (tail $ tail $ tail $ "") instead.
20:53:35 <SamB_XP_> monochrom: they'd be much more likely to have occured too recently before the power outage ...
20:53:40 <Warrigal> SamB_XP_: using lots of cruft.
20:54:01 <Cale> Warrigal: you want it to die?
20:54:07 <dibblego> tail . tail . tail $ ""(== undefined)
20:54:17 <monochrom> SamB_XP_: I'm thinking just one periodic flush every hour. Is that better?
20:54:19 <Cale> Warrigal: also, (.) is better than ($) whenever possible
20:54:26 <Warrigal> If you say so.
20:54:33 <SamB_XP_> monochrom: probably fine
20:54:46 <SamB_XP_> though might want to do it at, oh, 17 after
20:54:47 <monochrom> Even just once a day.
20:54:48 <Cale> This is because if you have something like f . g . h $ x, then, for example, g . h is meaningful
20:54:58 <Warrigal> Indeed.
20:55:01 <SamB_XP_> to avoid failures due to cron jobs ;-P
20:55:02 <Cale> But if you have f $ g $ h $ x, then g $ h doesn't mean anything
20:55:11 <Lycurgus> "standing on each others feet (instead of 'the shoulders of giants')" was the third cognate of "reinventing the wheel" and "not invented here" I couldn't think of earlier
20:55:14 <SamB_XP_> that is, some systems are so unstable that a cronjob can cause them to reboot ;-P
20:55:24 <SamB_XP_> hardware problem, I think
20:55:26 <Warrigal> g $ h cannot be treated as a subexpression of f $ g $ h $ x.
20:55:42 <Cale> right
20:55:50 <Lycurgus> (quote due to Parnas, Gries, somebody like that)
20:56:00 <medfly> hi Cale :)
20:56:15 <SamB_XP_> don't forget "standing in the footprints of giants"
20:56:16 <Cale> hello
20:56:25 <SamB_XP_> not exactly the same thing, but
20:56:47 <Lycurgus> slight different connotation
20:57:04 <monochrom> http://www.historyoftheuniverse.com/giantsho.html  suggests Brian Reid.  (Who is Brian Reid?)
20:57:05 <SamB_XP_> I mean, that's more like getting stuck in a rut
20:57:44 <monochrom> Ah, found Brian Reid on wikipedia.
20:59:23 <copumpkin> @seen rwbarton
20:59:24 <lambdabot> Last time I saw rwbarton was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
20:59:24 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
20:59:24 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 7m 15d 22h 27m 22s ago,
20:59:24 <lambdabot> and .
20:59:42 <medfly> ouch.
21:00:06 <copumpkin> that's clearly reliable
21:00:18 <TimMc> lambdabot: I'm glad you remembered to include the .
21:00:41 <TimMc> Bots who forget the  are clearly not to be trusted.
21:00:43 <Cale> and .
21:01:06 <lambdabot> Yeah, I've got a pretty good memory, except when it comes to quotes.
21:01:18 <Cale> I should really turn off the seen plugin altogether
21:01:21 <SamB_XP_> lambdabot: ... right.
21:01:28 <copumpkin> preflex does a pretty good job
21:01:33 <copumpkin> preflex: seen rwbarton
21:01:34 <preflex>  Sorry, I haven't seen rwbarton
21:01:38 <Cale> It does nothing but cause trouble when the state gets corrupted and I have to replace it with an old version.
21:01:40 <copumpkin> oh, guess not :P
21:01:43 <monochrom> Hahahaha good job!
21:01:54 <copumpkin> preflex: help
21:01:54 <preflex>  try 'help help' or see 'list' for available commands
21:02:04 <copumpkin> halp
21:02:08 <Cale> preflex: what
21:02:28 <SamB_XP_> preflex: help help
21:02:29 <preflex>  help COMMAND - show help for a command
21:02:33 <SamB_XP_> preflex: help list
21:02:33 <preflex>  list - show available plugins
21:02:36 <SamB_XP_> preflex: list
21:02:36 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
21:02:38 <Cale> Aw, thought that might do something... isn't it mauke's?
21:02:44 <Cale> Or am I misremembering?
21:02:48 <SamB_XP_> preflex: version
21:02:48 <preflex>  3.961
21:02:53 <SamB_XP_> preflex: author
21:02:53 <copumpkin> Cale: yeah, it is
21:03:00 <SamB_XP_> preflex: moo
21:03:07 <SamB_XP_> lambdabot: moo
21:03:11 <SamB_XP_> @moo
21:03:12 <lambdabot> Maybe you meant: map more msg todo yow
21:03:12 <copumpkin> preflex: rot13 this is really useful
21:03:12 <preflex>  guvf vf ernyyl hfrshy
21:03:21 <Cale> preflex: help 6st
21:03:21 <preflex>  6st NUMBER[...] - ordinalify
21:03:27 <TimMc> OK, I'll bite.
21:03:28 <copumpkin> lol
21:03:29 <Cale> preflex: 6st 475
21:03:29 <preflex>  475th
21:03:31 <TimMc> lambdabot: yow
21:03:34 <Cale> preflex: 6st 2
21:03:34 <preflex>  2rd
21:03:37 <Cale> heh
21:03:46 <SamB_XP_> would be cooler if it spelled it all out
21:03:47 <Cale> preflex: 6st 1
21:03:48 <preflex>  1st
21:03:50 <Cale> preflex: 6st 3
21:03:50 <preflex>  3th
21:03:54 <Cale> preflex: 6st 4
21:03:54 <preflex>  4th
21:03:56 <Cale> preflex: 6st 5
21:03:56 <preflex>  5th
21:03:58 <Cale> preflex: 6st 6
21:03:58 <preflex>  6st
21:04:01 <Cale> heh
21:04:01 * copumpkin finds that incredibly funny for some reason
21:04:05 <copumpkin> and can't stop laughing
21:04:11 <monochrom> I wonder about 0.
21:04:15 <Cale> preflex: 6st 0
21:04:15 <preflex>  0th
21:04:19 <Cale> preflex: 6st -1
21:04:19 <preflex>  -1th
21:04:22 <Cale> preflex: 6st -6
21:04:22 <preflex>  -6th
21:04:35 <TimMc> preflex: 6st NaN
21:04:35 <preflex>  0th
21:04:40 <TimMc> >_<
21:04:48 <Cale> preflex: 6st foo
21:04:48 <preflex>  0th
21:04:57 <copumpkin> preflex 6st 6.24 + 0.1i
21:04:57 <preflex>  0th 0th 0th
21:05:06 <monochrom> (Did you know there are numbers bigger than NaN?)
21:05:20 <TimMc> Hay guyz I think I see a pattern!
21:05:29 <copumpkin> > nan > nan
21:05:30 <lambdabot>   False
21:05:39 <copumpkin> > 0 > nan
21:05:40 <lambdabot>   False
21:05:42 <TimMc> monochrom: Naw, NaN + 1 is still NaN
21:06:04 <copumpkin> > infinity > nan
21:06:06 <lambdabot>   Ambiguous occurrence `infinity'
21:06:06 <lambdabot>  It could refer to either `L.infinity', def...
21:06:12 <copumpkin> > L.infinity > nan
21:06:13 <lambdabot>   False
21:08:01 <Cale> preflex: 6st 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
21:08:01 <preflex>  0th 1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th 11st 12rd 13th 14th 15th 16st 17rd 18th 19th 20th
21:08:34 <monochrom> Haha, I see now.
21:08:55 <Cale> It's like some kind of weird modulo 5 thing
21:09:04 <TimMc> preflex: 6st 21
21:09:04 <preflex>  21st
21:09:26 <TimMc> Doesn't explain the 2rd.
21:09:43 <TimMc> preflex: source
21:09:58 <Cale> Well, it just repeats th st rd th th
21:10:24 <copumpkin> mauke++
21:10:41 <TimMc> copumpkin: Is that who is to blame?
21:10:50 <copumpkin> yup
21:10:56 <copumpkin> s/blame/thank/
21:11:34 <Cale> @let st n = show n ++ th !! (n `mod` 5) where th = words "th st rd th th"
21:11:35 <lambdabot>  Defined.
21:11:45 <Cale> > map st [0..20]
21:11:46 <lambdabot>   ["0th","1st","2rd","3th","4th","5th","6st","7rd","8th","9th","10th","11st",...
21:11:58 <Cale> > unwords . map st $ [0..20]
21:12:00 <lambdabot>   "0th 1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th 11st 12rd 13th 14th 15th 16st...
21:12:23 <Makoryu> 6st? 7rd?
21:12:33 <Makoryu> I think not.
21:12:40 <Cale> Makoryu: I'm just copying the strange broken behaviour given by the bot.
21:12:49 <Makoryu> Ah
21:12:53 <Cale> I think that's part of the idea, that it's broken.
21:13:47 <Twey> 12rd?  Heh
21:13:53 <Twey> Nice
21:14:28 <copumpkin> Makoryu: the name of his plugin is 6st...
21:14:52 <Gracenotes> hm.. what are the software origins of RedHat again...
21:15:01 <SamB_XP_> Gracenotes: hmm?
21:15:06 <SamB_XP_> they had software origins?
21:15:10 <copumpkin> eleventy-two years ago
21:15:31 <SamB_XP_> maybe you're referring to cygnus solutions which they bought a while back?
21:15:53 <SamB_XP_> does a lot of GCC work, you know ;-)
21:16:01 <SamB_XP_> I think it's now called sourceware.org
21:16:17 <Gracenotes> I am researching. it's linux, anyway -_-
21:18:57 <Gwern-away> oh noes
21:19:02 <Gwern-away> where is jefferson heard?
21:19:12 <Gwern-away> altenrately, does https://svn.renci.org/bigboard work for anyone?
21:20:11 <dino-> Gwern-away: Forbidden for me
21:20:16 <Gwern-away> figures
21:20:40 <Gwern-away> huh. the snapshot is a lot smaller than I expected
21:20:58 <Gwern-away> but the bigboard.cabal is terrible!
21:21:04 <dino-> http://downforeveryoneorjustme.com/svn.renci.org
21:21:05 * Gwern-away itches to remove all those superfluous fields
21:27:11 <mun> if foo :: String -> A, bar :: B -> [String] how do i use the first element returned by bar b as the argument to foo?
21:29:17 <Makoryu> :t head -- For mun
21:29:18 <lambdabot> forall a. [a] -> a
21:29:44 <mun> Makoryu, i see. but how about for the 2nd, 3rd.. nth element?
21:29:57 <Makoryu> mun: Maybe you want map
21:30:23 <Makoryu> > map show [1..10]
21:30:24 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
21:30:48 <mun> Makoryu, but how does map help me retrieve the nth element?
21:31:05 <Makoryu> mun: The indexing operator is (!!)
21:31:16 <Makoryu> > [1..10] !! 3
21:31:17 <lambdabot>   4
21:31:33 <Makoryu> > "the tiger" !! 5
21:31:34 <lambdabot>   'i'
21:31:35 <mun> Makoryu, aah.. so i won't need map then, right?
21:31:45 <Makoryu> mun: It really depends on what you're doing.
21:32:13 <Makoryu> mun: If you want to apply foo to every element in a list and then make a list of all the results... that's exactly what map does
21:32:49 <mun> Makoryu, i see. well, !! seems to serve my needs better. thanks
21:51:36 <Gwern-away> oh wow this is so awesome
21:51:57 <Gwern-away> you can make gitit serve its git/darcs repo by simply doing a ln ../_darcs inside its static/ directory
21:52:09 <Gwern-away> and then you do darcs get 127.0.0.1:5001 or whatever
21:52:28 <Gwern-away> no need to set up a separate apache forwarder or anything
21:54:33 <Gwern-away> neato
21:54:39 <Gwern-away> anyone want to do a 'darcs get http://wiki.darcs.net/'?
21:57:28 <Trinithis> > alignment (undefined :: Ptr CInt)
21:57:29 <lambdabot>   Not in scope: `alignment'Not in scope: type constructor or class `Ptr'Not i...
22:02:07 <path[l]> I thought darcs was scrapped or something because it had some performance issues?
22:02:40 <Gwern-away> lies!
22:02:49 <Gwern-away> we are ideologically committed to remaining pure
22:02:59 <c_wraith> The performance issues aren't lies. :)
22:03:07 <c_wraith> But I still use it
22:03:18 <Gwern-away> the major performance issue with wiki.darcs.net is really ghc or gitit's fault anyway
22:03:22 <SamB_XP_> the lies are about it being scrapped
22:03:30 <path[l]> ah ok hehe
22:03:41 <Gwern-away> stupid won't-return-memory-to-the-OS bug
22:03:55 <Gwern-away> obviously the GHC devs don't care about black peop^W^Wservers
22:04:28 <SamB_XP_> Gwern-away: remember, GHC HQ is probably in the UK ...
22:04:36 <path[l]> speaking of performance issues, I was having some trouble yesterday. I ported some ruby code to haskell. In ghci it runs like three times as slow. Compiled with O2 it runs in 60% the time
22:04:41 <Gwern-away> of course. that explains it
22:04:46 <path[l]> but its still not a significant improvement
22:04:49 <Gwern-away> path[l]: what do you expect of an interpreter?
22:05:01 <path[l]> when I profiled it, I found 30% of the time being spent in the GC
22:05:14 <path[l]> well Im just surprised because ruby is interpreted too =p
22:05:16 <SamB_XP_> Gwern-away: I was under the impression the UK had less black/white tension ?
22:05:32 <Gwern-away> SamB_XP_: makes it easier for them to be racist, you mean
22:05:41 <Gwern-away> sure, there's less tension because there's less of'em
22:06:21 <path[l]> anyway Im not so worried about the ghci, but Id love to know how to speed this up more and avoid the gc time too
22:06:28 <path[l]> so if anyone is free, I have the 2 pasties
22:07:11 <Gwern-away> mmm... pasty
22:07:17 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424 and http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425
22:07:21 <path[l]> lol Gwern-away
22:13:42 <copumpkin> preflex: help 6st
22:13:43 <preflex>  6st NUMBER[...] - ordinalify
22:14:08 <copumpkin> preflex: 6st 2
22:14:08 <preflex>  2rd
22:14:55 <copumpkin> preflex: 6st 3
22:14:55 <preflex>  3th
22:18:24 <mun> what is a good way to tokenise a string containing spaces by using space as delimiter?
22:18:38 <copumpkin> words
22:18:55 <copumpkin> > words "  look what happens if I pass in    a    sentence   "
22:18:56 <lambdabot>   ["look","what","happens","if","I","pass","in","a","sentence"]
22:19:27 <copumpkin> > words "  look what happens if I pass in  \t  a    sentence   "
22:19:28 <lambdabot>   ["look","what","happens","if","I","pass","in","a","sentence"]
22:19:28 <Gwern-away> or Data.Split if words can't handle yer needs
22:19:44 <copumpkin> Gwern doesn't appear to be away to me
22:19:44 <mun> thanks
22:19:55 <path[l]> looks like words also deletes empty arrays
22:20:40 <Lycurgus> > words "  look what happens if I pass in  'this thing' in  a    sentence   "
22:20:42 <lambdabot>   ["look","what","happens","if","I","pass","in","'this","thing'","in","a","se...
22:21:03 <copumpkin> Lycurgus: it doesn't know what you mean by sentence :P
22:21:31 <Lycurgus> > words "  look what happens if I pass in  \"this thing\" in  a fragment  "
22:21:33 <lambdabot>   ["look","what","happens","if","I","pass","in","\"this","thing\"","in","a","...
22:25:07 <Gwern-away> copumpkin: I am away from my computer, not IRC
22:28:32 <copumpkin> ah
22:37:14 <Cale> http://www.longestpoemintheworld.com/ -- this is a clever idea
22:39:16 <MorkBork> wow cale
22:39:17 <MorkBork> http://twitter.com/getlikejames/
22:39:21 <MorkBork> that dude has his line on the poem
22:39:34 <MorkBork> what a nutjiob
22:41:31 <copumpkin> Cale: you should sign up for twitter and try to get a line in ;)
22:41:37 <copumpkin> ...about CT
22:42:32 <mun> does System.Console.Shell allow commands to take in multiple arguments?
22:50:30 <Cale> whaaat... a livejournal password for an account that I didn't make is in my inbox... is this some very indirect sort of spam?
22:51:05 <Cale> It also doesn't appear to work.
22:51:09 <Cale> huh.
22:59:35 <Cale> ah, haha, missed another message where someone apparently used my email address to create their livejournal account...
23:02:05 <path[l]> bah
23:02:06 <path[l]> hmm
23:02:26 <path[l]> did anyone have a chance to look at that ruby vs haskell thing? :o
23:03:23 <opqdonut> which one
23:04:08 <opqdonut> ah, got it
23:04:19 <pikhq> Link?
23:04:49 <Gwern-away> man, my laptop is so screwed up!
23:05:24 <opqdonut> pikhq: scroll up, path[l] posted two links to the moonpatio pastebin
23:07:00 <Gwern-away> ok, since no one is going to ask *how* screwed up, I'll just mention that the javascript on the HWN freezes my laptop, that's how screwed up my laptop is
23:07:11 <Gwern-away> @quote accurate.*Perl
23:07:12 <lambdabot> No quotes match. Do you think like you type?
23:07:24 <Gwern-away> @quote accurate
23:07:24 <lambdabot> wadler says: If your map's not accurate and people get lost, it'll act as a filter
23:07:30 <Gwern-away> @quote bos
23:07:30 <lambdabot> bos says: The last couple of times I've wanted a book like that, I wrote the book myself. It's a very effective way to get the book you want, compared to wishing.
23:07:33 <Gwern-away> @quote bos
23:07:33 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
23:07:36 <Gwern-away> @quote bos
23:07:36 <lambdabot> bos says: imperative languages only go up to ten
23:07:44 <Gwern-away> @remember bos You don't get accurate answers from Perl. It just lies to you to keep you happy.
23:07:45 <lambdabot> Done.
23:07:53 <Gwern-away> @quote hierarchical
23:07:53 <lambdabot> mauke says: trees are hierarchical
23:07:59 <Gwern-away> @quote hierarchical.modules
23:08:00 <lambdabot> ray says: haskell' will come out in 2020 and be h98 with hierarchical modules
23:08:07 <Gwern-away> @quote ladies
23:08:07 <lambdabot> ray says: enlarge your kleisli arrow, please the category ladies
23:08:16 <Gwern-away> @quote painful
23:08:17 <lambdabot> quicksilver says: making the compiler writer's job painful is one of the main duties of a language designer.
23:08:24 <Gwern-away> @quote wheelchair
23:08:24 <lambdabot> gwern says: as a plugin, yes, but that's like being so out of shape that a guy in a wheelchair can outrace you - yes, he needs a tool, but you should still be ashamed of yourself
23:08:36 <Gwern-away> @quote fish
23:08:37 <lambdabot> Cale's says: Lemma: Any sufficiently long string of operator symbols looks like a fish.
23:08:48 <Gwern-away> @quote wasteland
23:08:49 <lambdabot> randomwords says: How "complete" does an application before it's OK to upload to hackage? <ray> there are no standards <randomwords> lawless wasteland. Got it.
23:08:57 <Gwern-away> I particularly liked that one
23:09:06 <Gwern-away> @quote weekend
23:09:07 <lambdabot> ndm says: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
23:09:17 <Gwern-away> that one was pretty good too, though not from #haskell
23:09:28 <Gwern-away> @quote zip13
23:09:29 <lambdabot> michaelfeathers says: I did a parody post to Haskell Cafe last year where I had some code that was calling (nub . nub) zip12 and asked if there was a zip13 and no one called it out as a joke.
23:09:45 <mun> does anyone know if System.Console.Shell allow commands to take in multiple arguments?
23:11:39 * BMeph is SOOOOO tempted to Tweet about how "run-on sentences make me weep"... >;)
23:12:39 <Gwern-away> @remember michaelfeathers I did a parody post to Haskell Cafe last year where I had some code that was calling (nub . nub) zip12 and asked if there was a zip13 and no one called it out as a joke.
23:12:39 <Gwern-away> @flush
23:12:39 <Gwern-away> @flush
23:12:39 <Gwern-away> @flush
23:12:39 <Gwern-away> @flush -- just to make *really* sure
23:12:40 <lambdabot> It is stored.
23:12:40 <lambdabot> Not enough privileges
23:12:40 <lambdabot> Not enough privileges
23:12:40 <lambdabot> Not enough privileges
23:12:40 <lambdabot> Not enough privileges
23:13:08 <Gwern-away> @quote michaelfeathers
23:13:08 <lambdabot> michaelfeathers says: I did a parody post to Haskell Cafe last year where I had some code that was calling (nub . nub) zip12 and asked if there was a zip13 and no one called it out as a joke.
23:13:19 <Gwern-away> hm. did I put in a dupe?
23:15:46 <path[l]> lol
23:21:04 <opqdonut> heh, nub.nub
23:22:55 <BMeph> path[1]: Suggestion1: Instead of sorting ascending, and reversing, just sort descending (e.g., sortBy (flip compare)). :)
23:24:29 <BMeph> path[1]: Suggestion 2 - NEED MOAR CURRY PLZ KTHXBAI!
23:27:52 <mun> does anyone know how i can customise a command for System.Console.Shell to take in multiple arguments? i'm using cmd to create my command, but i can't see where i can tell it how many args it takes. it seems by default, everything after the command name is regarded as the argument.
23:36:07 <mmorrow> mun: where is System.Console.Shell from?
23:36:27 <mun> mmorrow, it's from Shellac
23:36:33 <mmorrow> ah
23:36:38 <mmorrow> (i'm not sure)
23:37:02 <mun> is Shellac the best framework to create shell environments?
23:37:34 <Warrigal> @src nub
23:37:35 <lambdabot> nub = nubBy (==)
23:37:41 <mmorrow> i'm not sure. i usually just use System.Process
23:38:07 <mmorrow> well, actually s/usually/all i've ever used is System.Process/
23:38:15 <mmorrow> so i'm not sure
23:38:48 <idnar> @type nub.nub
23:38:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
23:38:54 <mun> oh right
23:39:00 <idnar> heh
23:39:48 <Warrigal> @help flush
23:39:48 <lambdabot> flush. flush state to disk
23:40:27 <Gwern-away> it's never lupus :(
23:40:33 <Warrigal> @pl \x -> x ++ show x
23:40:34 <lambdabot> ap (++) show
23:41:18 <Warrigal> > ap (,) length $ nub "I bet this sentence doesn't contain any of the letters J, X, Q and Z in lowercase."
23:41:19 <lambdabot>   ("I bethisncdo'ayflrJ,XQZw.",25)
23:43:42 <mmorrow> mun: ohhhhh. Shellac is for making repl's
23:43:53 <mmorrow> (i just looked at the hackage page)
23:44:51 <mmorrow> mun: i use something that's similar to Shellac that wrote at one point, but Shellac looks like it has a bunch of features
23:45:53 <mmorrow> mun: that Shellac supports completion is a huge plus
23:46:46 <mmorrow> arg, that it isn't just plain IO but has its own monad is a minus for me (personally)
23:49:07 <copumpkin> mmorrow: it isn't a MonadIO or something?
23:49:18 <mmorrow> probably
23:49:42 <bastl> Hi, I'm stuck with my little program http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3426 . It shall load a "registration" at runtime, that loads some instances and a record-function for later use. This registration ought to be modified by users later on without touching the original program.
23:49:54 <Gwern-away> Shellac is pretty nice for repls
23:50:06 <Gwern-away> I was thinking of writing a shell using it
23:50:22 <Gwern-away> but I found my day-to-day sh stuff just wouldn't benefit much from haskell
23:50:44 <bastl> Is there a conceptual problem in the idea?
23:50:51 <mmorrow> copumpkin: actually, yeah i guess it's not really an issue there
23:52:14 <Gwern-away> on the other hand, I wouldn't've said that xmonad could be much of an improvement on ratpoison/stumpwm, so maybe I'm wrong about haskell shells
23:52:32 <mmorrow> bastl: i'm not sure i understand exactly what you mean by "registration", but i'm sure whatever it is can be done somehow
23:52:59 <bastl> i want to "register" instances of a type-class at runtime ...
23:53:05 <copumpkin> :o
23:53:09 <mmorrow> bastl: o
23:53:23 <mmorrow> bastl: that may be a problem
23:53:28 <bastl> :o)
23:53:36 <copumpkin> voodoo warning!
23:54:06 <mmorrow> bastl: "register" these instances so that what code can see/use them?
23:54:25 <mmorrow> bastl: code that you're dynamically loading/compiling by some means as well?
23:54:37 <bastl> a parser :: (Parseable a) => String -> a
23:54:38 <mmorrow> bastl: or code in the original program
23:54:50 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3426
23:55:22 <mmorrow> where is import Language.Haskell.Interpreter from?
23:55:28 <mmorrow> is that hint?
23:55:57 <copumpkin> whoa
23:55:57 <copumpkin> parseHaskell :: String -> Either HsModule ParseError
23:56:01 <bastl> yes
23:56:17 <copumpkin> bastl: if you're going to use Either in a nonconventional order, you might as well just define your own Error type or something :)
23:56:29 <copumpkin> *unconventional
23:56:56 <bastl> oh, so right doesnt miean just the opposite of left ?
23:57:05 <bastl> but also "correct"... i see
23:57:09 <bastl> :-)
23:57:10 <copumpkin> > fmap (+1) (Right 4)
23:57:11 <lambdabot>   Right 5
23:57:14 <copumpkin> > fmap (+1) (Left 4)
23:57:16 <lambdabot>   Left 4
23:57:42 <copumpkin> all the useful instances for Either privilege Right because its parameter comes last in the Either type constructor
23:57:58 <BMeph> bastl: Why, yes, that's ... er, you got it. ;)
23:58:30 <vav> @src ErrorT
23:58:30 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
23:58:45 <bastl> ok. thanks. but we are getting OT. the error i get from hint for that code is: NotAllowed "These modules are not interpreted:\nParserRegistration\n"
23:58:56 <mmorrow> bastl: ok. so in order to get a polymorphic function back through the rabbit-hole, you'll almost certainly need to use unsafeCoerce
23:59:39 <mmorrow> hmm, but you're loading an entire module at a time, right?
23:59:55 <vav> also, not super familiar with hint, but does it need its import modules registered with ghc, or is a path to source enough?
