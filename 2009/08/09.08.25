00:05:15 <aleator_> Can someone enlighten me on ghc gc specifics? What triggers the gc, running out of general memory, or heap? How are non-heap objects handled? (google fails me)
00:17:48 <tingi> opqdonut, thanks
00:43:30 <opqdonut> copumpkin: ok, how about: we need to have two vectors whose dot product is <0 :)
00:50:09 <tingi> opqdonut, What if we have points like (1,2) ,(3,4) and (5,-6) , their angle is greater than 180" but i don't think we can form linear combination because x components will increase.
00:53:38 <opqdonut> angle can't be greater than 180 because they all lie in the same halfplane
00:55:04 <opqdonut> but anyway, i don't know if i can be of any more help as i haven't managed to prove that the angle being >180 is sufficient for a solution to exist
01:13:51 <basvandijk> Hello, is there a HSC construct like #const but for float constants? So that I'm able to bind for example: "#define LM_INIT_MU 1E-03"
01:37:15 <etpace_> > [1] <|> [2]
01:37:16 <lambdabot>   [1,2]
01:37:42 <etpace_> > Just 1 <|> Just 2
01:37:43 <lambdabot>   Just 1
01:38:05 <etpace_> > Just 1 <|> Nothing
01:38:07 <lambdabot>   Just 1
01:38:08 <lars9> hi, is there anyone using Haskell in your own dev/research?
01:39:16 <etpace_> > mzero :: Maybe
01:39:18 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
01:39:18 <lambdabot>  Expected kind `...
01:39:33 <etpace_> > mzero :: Maybe Int
01:39:34 <lambdabot>   Nothing
01:39:58 <etpace_> > [1] `mplus` [] `mplus` [2]
01:40:00 <lambdabot>   [1,2]
01:40:25 <bastl> hello. IIRC, there is a package that works as a GHC-API Wrapper. (hint?) Can I use that to get a list of all types that are instances of a specific type-class ?
01:43:44 <chrisbrown> lars9: I used Haskell for research during my PhD, but now only a little for my current development work...
01:43:55 <etpace_> :t foldMap
01:43:57 <lambdabot> Not in scope: `foldMap'
01:44:51 <ziman> lars9, many people are, for example I write my programs (data mining, network video streaming) in Haskell; see also http://haskell.org/haskellwiki/Haskell_in_industry
01:45:48 <chrisbrown> ziman: I'm interested in your network video streaming: does that wrap an exisiting decoding library such as libavcodec?
01:46:14 <lars9> chrisbrown, ziman: i now can program some simple algorithms in haskell, but always dunno how to use it to do real things
01:46:33 <etpace_> > mconcat [First Nothing, First (Just 3), First (Just 5)]
01:46:38 <lambdabot>   First {getFirst = Just 3}
01:46:58 <chrisbrown> lars9: are you learning Haskell for fun?
01:47:10 <ziman> chrisbrown, no, I just take mpeg4/jpeg frames as they are and wrap/unwrap them in/from protocols (rtsp, http); no decoding takes place
01:47:23 <chrisbrown> ziman: oh, shame :(
01:47:35 <quicksilver> bastl: well, you can see the docs here : http://hackage.haskell.org/package/hint
01:47:40 <quicksilver> bastl: I think the answer is no.
01:48:08 <lars9> chrisbrown: yeah, just because of curiosity
01:48:17 <etpace_> [] is a monoid right, not [a]?
01:48:42 <chrisbrown> lars9: are you following a text book? I always find if you give yourself an application to implement in Haskell, it helps the learning process
01:48:45 <quicksilver> [a] is a monoid (for all a, uniformly)
01:49:07 <quicksilver> [] is a mon*a*d
01:49:23 <etpace_> aha, thanks
01:50:31 <etpace_> so foldMap for lists would have a type (a -> [b]) -> t a -> [b], where t is any constructor?
01:50:35 <lars9> chrisbrown: followed yaht. did you program a lot in other languags before you learn haskell? it seems normal languages can become obstacles of learing haskell
01:51:33 <chrisbrown> lars9: I was, unfortunately, exposed to lots of imperative and OO programming before I came to Haskell...
01:51:55 <dibblego> foldMap :: (Foldable t) => (a -> [b]) -> t a -> [b]
01:52:00 <dibblego> (for the [a] Monoid)
01:52:15 <etpace_> what is t, just a type constructor?
01:52:26 <dibblego> etpace_, yes (one for which there is a Foldable)
01:52:36 <chrisbrown> lars9: I had to re-write my brain a little! But with some persistance the step from imperative to functional was well worth the effort
01:53:17 <dibblego> I think abnormal languages are those that become obstacles to learning Haskell
01:53:24 <ziman> i do not see my imperative background as an obstacle when learning; i'd say it makes me really appreciate haskell instead
01:53:30 <etpace_> thanks
01:53:44 <quicksilver> I think if you are an inexperienced programmer, an imperative background is an obstacle.
01:53:50 <quicksilver> at least for a while.
01:53:58 <quicksilver> if you are a more experience programmer less so.
01:54:26 <lars9> chrisbrown: thanks, you are the example im looking for to give myself hope:) it's really annoying when the 1st thing come to my mind is the implementation in c data structures and program flows
01:54:32 <dibblego> I have taught a medical professional and an electrician what "monad" means in less than five minutes
01:54:52 <path[l]> :o
01:55:48 <path[l]> dibblego, can I sign up for this class. Ive been reading up on it, I know the axioms and part of the analogies ... but I still dont have an intuitive feel for it
01:56:35 <dibblego> ha, I have actually run a class on it before too
01:57:01 <quicksilver> maybe we should have a #haskell-seminars or something
01:57:06 * wmealing_ cheers
01:57:08 <quicksilver> I'm not volunteering to organise tho ;)
01:57:55 <etpace_> -seminars would be great
02:00:44 <chrisbrown> lars9: just persist! I found Thompson's Haskell text invaluable to learning Haskell
02:01:09 <ziman> lars9, at the beginning I thought Haskell was somewhat impractical (albeit charming) but I learned to use it for real-world things; just pick some simple programs you'd need to write (in a different language) -- like reading from a file, crunching the data and writing it somewhere -- and implement them in haskell
02:02:36 <chrisbrown> lars9: I completely agree with ziman here. I found I really saw the light when I wrote my first simple little parser in Haskell
02:02:40 <ziman> you'll gain experience and it'll be easier each time
02:03:10 <lars9> chrisbrown, ziman: thanks for sharing your experience
02:03:15 <chrisbrown> lars9: and if you get stuck there is a community here willing to help and guide you through  where you get stuck
02:03:48 <lars9> chrisbrown: do you mean this one: The Craft of Functional Programming?
02:04:08 <chrisbrown> lars9: yes!
02:10:22 <path[l]> is there an existing library that does permutations and combinations etc
02:11:19 <dibblego> http://hackage.haskell.org/package/permutation
02:11:25 <quicksilver> there are bits of it in data.list, too
02:11:48 <path[l]> ah
02:12:31 <path[l]> hmm I wanted something that came with ghc, so I cant use Data.Choose
02:12:44 <path[l]> but the ghc version Im limited to doesnt have sequences and permutations lol
02:14:30 <path[l]> oh well I guess Ill try Data.Choose then, no choice =[
02:14:32 <path[l]> =p*
02:22:34 <path[l]> hmm how do I "add an instance declaration for fractional int"
02:23:17 <ziman> you probably don't want to. Use "div" for integral division instead.
02:23:30 <Axman6> :t (/)
02:23:32 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:23:34 <ziman> (/) operates on fractional arguments and Int is not Fractional
02:23:43 <Axman6> @instances Fractional
02:23:45 <lambdabot> Double, Float
02:24:05 <ziman> path[l], or if you need a Fractional result, use fromIntegral to convert the Int's to something else
02:24:18 <path[l]> no I expect a frational result
02:24:20 <path[l]> ok
02:24:33 <path[l]> so if I have a/b and a and b are integers
02:25:09 <path[l]> I can do (fromIntegral a)/(fromIntegral b)
02:25:35 <Athas> Is there a monad that is like ErrorT, but does not have the connotation of "error"?  Or should I not care about this?
02:25:39 <ziman> exactly. Note that the parentheses are not needed because function application bids tighter than any operator
02:25:46 <ziman> *binds
02:25:54 <Athas> I really just want a monad that can, you could say, stop prematurely.
02:26:21 <path[l]> ah ok
02:26:27 <path[l]> thanks
02:26:54 <ziman> Athas, how about Maybe?
02:27:35 <Athas> ziman: oh right, of course, I think that is perfectly acceptable for my needs.
02:29:57 <Athas> Hmm, there is no Maybe monad transformer?
02:30:30 <int-e> there is, in Control.Monad.Maybe
02:30:48 <Athas> Oh sorry, I wonder why Hoogle didn't pick it up.
02:31:01 <Saizan_> @hackage MaybeT
02:31:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
02:31:02 <int-e> oh, which is in the MaybeT package.
02:39:22 <PetRat> I have an issue with putting a type signature on a function defined within a function. here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8552#a8553
02:40:49 <Taejo> PetRat: looks like you want the ScopedTypeVariables extension
02:41:17 <Taejo> what's happening here is that GHC doesn't consider the k in the type of f to be the same variable as the k in the type of toDescList2
02:41:27 <PetRat> Taejo: thanks. so basically you are saying what I want to do does make sense from the right point of view... we just need to convince the compiler of that?
02:41:48 <Taejo> yeah
02:42:00 <Taejo> though I have examined the code too carefully
02:42:21 <Taejo> try putting {-# LANGUAGE ScopedTypeVariables #-} at the top of the module
02:42:52 <quicksilver> and add a forall k . before the first type sig
02:42:59 <quicksilver> which is what tells GHC to scope the type variables.
02:43:18 <Taejo> oh, I didn't know you had to do that
02:44:00 <zeno> Saizan_: THANKS
02:45:22 <zeno> on cabal install i keep getting ec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found, buti  have 6.8.2
02:45:42 <zeno> --with-ghc=ghc-6.8.2 does nothing to help
02:46:22 <PetRat> Still isn't quite right. Is this the right place to put forall k ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8552#a8554
02:47:22 <doserj> try "forall k a ."
02:47:45 <quicksilver> good point
02:49:19 <path[l]> if Im working with Integers and I want to call take or drop. How do I downcast to Int
02:49:27 <PetRat> That got me closer but I also had to remove the Ord constraint on the declaration of the internal function. It was telling me some error about all type variables mentioned in the constraint were already in scope.
02:49:28 <Axman6> fromIntegral
02:49:34 <path[l]> or am I actually asking the wrong question
02:49:45 <zeno> on cabal install i keep getting ec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found, buti  have 6.8.2.  ideas?
02:49:45 <Axman6> :t fromIntegral
02:49:47 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:49:59 <path[l]> oh ok, sorry about the silly question then :x
02:50:26 <PetRat> Which command infers a function definition?
02:50:32 <Axman6> path[l]: the Num class requires all numbers to be converted to from integral values (Integer and Int mainly)
02:50:43 <path[l]> ah
02:51:09 <Axman6> @src Num
02:51:09 <lambdabot> class  (Eq a, Show a) => Num a  where
02:51:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:51:10 <lambdabot>     negate, abs, signum     :: a -> a
02:51:10 <lambdabot>     fromInteger             :: Integer -> a
02:51:31 <Axman6> :t div
02:51:32 <lambdabot> forall a. (Integral a) => a -> a -> a
02:51:39 <Axman6> @src Integral
02:51:40 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:51:40 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:51:40 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:51:40 <lambdabot>     toInteger           :: a -> Integer
02:52:00 <MoxJet> @pl \f l -> zipWith (\x y -> (x + y) `mod` length l) [0..] l
02:52:00 <lambdabot> const (flip zipWith [0..] =<< flip (flip . (mod .) . (+)) . length)
02:52:06 <MoxJet> ew...
02:53:02 <MoxJet> @pl \l -> zipWith (\x y -> (x + y) `mod` length l) l [0..]
02:53:03 <lambdabot> flip (zipWith =<< flip (flip . (mod .) . (+)) . length) [0..]
02:54:39 <MoxJet> @pl \l -> map (`mod` length l) $ zipWith (+) [0..] l
02:54:39 <lambdabot> ap (map . flip mod . length) (zipWith (+) [0..])
02:54:53 <PetRat> I'm going to be working with Maps a lot, using them to describe a musical score. I'm assuming map is a good data structure because I need to do lots of lookup and modification. I haven't studied the Traversable class yet, but I'm wondering what kinds of things it will do for me.
02:58:54 <mc__> is there any tutorial on how to get hopengl running under windows?
02:59:25 <mc__> eh I meant os x, google failed me
02:59:43 <quicksilver> hopengl works out of the box on OSX
02:59:47 <quicksilver> in my experience.
02:59:52 <quicksilver> although not in ghci.
03:00:23 <mc__> oh, alight I'll try
03:01:10 <Axman6> yeah, OpenGL on OS X seems to require compilation
03:11:27 <mc__> well cabal says the GL libarary is missing, but I cant find an OpenGL library for os x, think it comes pre-installed
03:11:43 <Axman6> it does
03:13:58 <MoxJet> The (->) monad is really cool.
03:15:04 <dibblego> just to be picky, it's the ((->) t) monad (since (->) has the wrong kind)
03:15:34 <MoxJet> True :) But obviously you do kind interference "better" than the typechecker ;)
03:15:52 <lilac> i'd also say it's the ((->) r) applicative that's cool. the ((->) r) monad is really just the same thing plus flip
03:16:37 <lilac> @type [(<*>) . flip, (=<<)]
03:16:38 <lambdabot> forall a b b1. [(a -> b1 -> b) -> (b1 -> a) -> b1 -> b]
03:16:54 <paulvisschers> are there MonadIO versions of functions like bracket and bracketOnError?
03:17:21 <MoxJet> ah, interesting. thanks lilac
03:19:10 <lilac> @hoogle bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
03:19:11 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
03:19:11 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
03:19:16 <lilac> ^^ those don't look right to me at all :-/
03:19:34 <paulvisschers> No some parentheses are missing
03:20:23 <paulvisschers> They seem to be implemented using block and unblock, but those functions seem to be part of the GHC core, so I can't rewrite those to use MonadIO instead of IO
03:20:47 <MoxJet> How do I make haddock emit the "source" link as well?
03:20:47 <MoxJet> And how do I make italic text in haddock, so I can write O(n^2) italiced?
03:21:22 <paulvisschers> MoxJet: /italic/, just a guess though
03:21:44 <lilac> paulvisschers: in general, it's not possible to convert MonadIO m => m a into IO a for use by a callback (though quicksilver i think had an interesting post on haskell-cafe for those times when it is possible)
03:22:15 <Axman6> MoxJet: i think it's /O(n^2)/
03:22:40 <MoxJet> paulvisschers: Axman6: thanks, forward slashes it is :)
03:23:35 <paulvisschers> lilac: yeah I know, but in this case there is really no way to reimplement it :(
03:25:41 <lilac> paulvisschers: what monad are you working in? can you convert the thing you're passing to bracket into IO a?
03:26:06 <quicksilver> well you have to make some decisions
03:26:18 <quicksilver> like, suppose it was StateT, are you trying to save the state at the point of the exception?
03:26:28 <quicksilver> or the state before the rollbacked portion executed
03:26:34 <quicksilver> how do you delimit the rollbacks?
03:26:36 <quicksilver> etc.
03:26:43 <paulvisschers> I'm trying to keep it general, (MonadReaderT Something m, MonadIO m)
03:26:50 <quicksilver> you can't keep it general.
03:26:54 <quicksilver> the questions are specific.
03:27:08 <quicksilver> there isn't a general answer.
03:27:18 <quicksilver> you coul duse a typeclass to lay out a family of specific answers
03:27:20 <lilac> quicksilver's post to the -cafe is here: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
03:27:42 <quicksilver> MonadCatchLikePaulWants m =>
03:27:50 <quicksilver> instance MonadCatchLikePaulWants (StateT ....)
03:27:56 <quicksilver> but you can't avoid answering the questions.
03:29:42 <paulvisschers> I'm basically trying to reimplement this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8555#a8555, but with the handles in a reader
03:30:27 <quicksilver> MonadReader is, actually, easy
03:30:36 <quicksilver> as long as you ignore 'local'
03:35:57 <indra_00769> xgnxfnxngxfn
03:37:02 <quicksilver> interesting.
03:45:11 <paulvisschers> quicksilver: Did you make a library for this monad threading?
03:46:14 <pozic> Is there a library defining mapAccumLM?
03:49:15 <quicksilver> paulvisschers: no, but someone else did.
03:49:36 <quicksilver> paulvisschers: what I wrote was just an idea sketch really
03:49:45 <quicksilver> I never fleshed it out in the context of a real program.
03:51:46 <paulvisschers> quicksilver: do you know where I can  find that library?
03:53:36 <quicksilver> http://hackage.haskell.org/package/interleavableIO
03:59:01 <paulvisschers> quicksilver: thanks, I'll try that one
04:25:36 <dcoutts> zeno: did you work out your problem with hsc2hs?
04:30:21 <paulvisschers> quicksilver: I have a small question: given that interleavableIO library, how would you embed onException :: IO a -> IO b -> IO a?
04:33:26 <DekuNut> Hey, I'm a bit confuse with typeclasses
04:33:53 <DekuNut> http://nopaste.org/p/a4EQLg8Lc
04:34:09 <DekuNut> I'm a bit confused as
04:35:06 <poe> :t fmap
04:35:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:35:07 <int-e> what are you confused about?
04:35:21 <Axman6> > fmap show [1..10]
04:35:22 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
04:35:23 <Jedai> DekuNut: what's the confusion all about
04:35:34 <Axman6> > fmap show (Just True"
04:35:35 <lambdabot>   <no location info>:
04:35:35 <lambdabot>      lexical error in string/character literal at end o...
04:35:37 <Axman6> > fmap show (Just True)
04:35:39 <lambdabot>   Just "True"
04:35:41 <DekuNut> I'm just reading for a second, sorry. I want to make sure I absolutely have no idea what I'm talking about before I ask :p
04:35:50 <Axman6> heh
04:36:31 <quicksilver> paulvisschers: with some thought required ;)
04:37:06 <uzytkownik> Hello. How to load Haskell library from ghci (library is in dist/build)?
04:37:29 <etpace_> > getSum . foldMap (const (Sum 1)) $ Just 5
04:37:31 <lambdabot>   Not in scope: `foldMap'
04:37:33 <paulvisschers> uzytkownik: :m + Control.Monad
04:37:54 <etpace_> hmmm, where are foldables?
04:38:15 <Axman6> uzytkownik: :load <path to file>
04:38:29 <int-e> uzytkownik: maybe :set -idist/build works?
04:39:45 <uzytkownik> Axman6: Which file? Source is in c2hs so ghci refueses to load it and neither .o nor .a can be loaded.
04:39:54 <Saizan> you need to register the library before you can use it
04:39:56 <uzytkownik> int-e: No :(
04:40:13 <Saizan> you can register --inplace if you don't want to install it
04:41:27 <DekuNut> Ok so, here's what I'm confused about
04:41:42 <DekuNut> http://nopaste.org/p/aUOQ5sE3C
04:42:24 <DekuNut> In the first example, class Eq a where, things like (==) :: a -> a -> Bool make sense, it expects two things of type a right?
04:42:34 <Lemmih> Right.
04:43:09 <DekuNut> So, Instance Eq TrafficLight just defines those, like Red == Red are TrafficLight
04:43:20 <Lemmih> DekuNut: Your Eq instance for Maybe is wrong, btw.
04:43:33 <DekuNut> Yeah sorry er
04:43:34 <Axman6> > Nothing == Nothing
04:43:35 <lambdabot>   True
04:43:55 <DekuNut> instance (Eq m) => Eq (Maybe m) where
04:43:57 <DekuNut> Better?
04:44:02 <Lemmih> Yep.
04:44:08 <DekuNut> Ok so yeah
04:44:15 <DekuNut> Just x and Nothing are both of type Maybe m
04:44:27 <DekuNut> And Maybe m has a class constraint so it has to be an equatable
04:44:40 <DekuNut> The functor is where it loses me
04:45:07 <Axman6> what's your problem with it?
04:45:14 <DekuNut> fmap expects a function taking a type and returning another type, and ....
04:45:15 <DekuNut> Oh
04:45:37 <Axman6> it's just map, but for more than lists
04:45:41 <Axman6> :t map
04:45:42 <DekuNut> Oh it just hit me
04:45:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:45:48 <DekuNut> I was wondering how it could be Maybe Just x
04:45:54 <DekuNut> Thinking f would be Maybe
04:46:03 <DekuNut> But that's obviously wrong
04:46:06 <Axman6> well, f is Maybe
04:46:08 <sw17ch> fmap f (Just x) = Just $ f x
04:46:12 <sw17ch> fmap f Nothing = Nothing
04:46:18 <sw17ch> i'm sure that's been typed
04:46:26 <dschoepe> DekuNut: f is Maybe, but Just is part of the value, not the type
04:46:33 <Axman6> yeah
04:46:38 <DekuNut> Wait, what. Now I'm definately confused
04:46:45 <DekuNut> So
04:46:48 <Lemmih> 'f' is used twice here.
04:46:49 <DekuNut>  fmap f (Just x) = Just (f x)
04:46:49 <Axman6> Just is a data constructor, Maybe is a type constructor
04:46:52 <DekuNut> f is Maybe in there?
04:47:11 <sw17ch> f :: a -> b
04:47:15 <Axman6> fmap g (Just x) = Just (g x) -- that help?
04:47:40 <dschoepe> DekuNut: the f in "(a -> b) -> f a -> f b" is Maybe
04:47:52 <DekuNut> Yeah, but er
04:47:59 <DekuNut> Wait
04:47:59 <Axman6> the f in fmap f .. is a function of type a -
04:48:00 <Axman6> > b
04:48:02 <lambdabot>   b
04:48:03 <Axman6> bleh
04:48:11 <Axman6> a -> b*
04:48:20 <DekuNut> Yeah, not 'Maybe' itself right? Because eitherwise my understanding of types has gone to hell
04:48:37 <Axman6> :t fmap (+2)
04:48:38 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
04:48:49 <Axman6> :t fmap show
04:48:51 <Lemmih> DekuNut: The two 'f's aren't related. They occupy different namespaces.
04:48:51 <lambdabot> forall a (f :: * -> *). (Show a, Functor f) => f a -> f String
04:49:00 <DekuNut> Thanks Lemmih that's what I was confused about
04:49:15 <DekuNut> I guess I just fried my brain there
04:49:22 <Axman6> DekuNut: so you understand what Functors are now?
04:49:41 <DekuNut> Roughly, it was more the typeclasses I was more interested in understanding
04:49:42 <Lemmih> Axman6: I think he did all along.
04:49:55 <DekuNut> The tutorial went over mapping a while ago
04:59:10 <dcoutts> Lemmih: you'll be glad to know that the latest jhc release breaks Cabal. Cabal cannot build .hl libs with jhc because there is no longer a command line flag to construct .hl libs.
04:59:34 <dcoutts> jhc --build-hl now requires a .cabal file as input!
05:00:43 <Lemmih> Huh, did jhc work with Cabal before?
05:00:51 <dcoutts> Lemmih: it did once
05:01:17 <dcoutts> Cabal would invoke jhc --build-hl -o foo-1.0.hl Foo.Bar
05:01:34 <dcoutts> to make a foo-1.0.hl consisting of the modules Foo.Bar
05:02:09 <Lemmih> It didn't work when I forked the project. Guess now it works even less.
05:02:58 <dcoutts> Lemmih: there was some bitrot in between when jhc wasn't really usable/buildable
05:03:48 <Lemmih> dcoutts: Have you seen the preliminary GHC vs. JHC vs. LHC vs. UHC benchmark: http://darcs.haskell.org/~lemmih/nobench/x86_64/results.html ?
05:05:01 <dcoutts> Lemmih: interesting
05:06:01 <Lemmih> GHC and UHC are using GMP. JHC doesn't support Integers, and LHC uses a Haskell Integer implementation.
05:06:44 <Lemmih> UHC kicks LHC's butt in pidigits because of that.
05:06:59 <Igloo> Lemmih: Have you got a link to LHC's Integer impl handy?
05:07:02 * roconnor worries about the benchmarks that all compilers fail on
05:08:02 <Igloo> roconnor: Looks like just package dependency problems, based on a sample of 2
05:08:18 <Lemmih> Igloo: http://code.haskell.org/lhc/lib/integer-native/src/GHC/Integer/
05:08:32 <Igloo> Lemmih: ta
05:09:03 <roconnor> Does LHC have FFT multiplication?
05:09:25 <Lemmih> (It has to be under GHC.Integer since we're using the ghc-api for type-checking and desugaring.)
05:09:26 <Igloo> Ah, right, Isaac Dupree's
05:10:14 <Igloo> Hmm, the pidigits link is a 404. What does that benchmark actually do?
05:11:40 <Lemmih> Igloo: It calculates pi to 3000 digits.
05:11:54 <Igloo> But what Integer ops does it use?
05:12:06 <Igloo> And how big are the Integers?
05:12:28 <Lemmih> http://nobench.seize.it/imaginary/pidigits/
05:13:42 <Igloo> Hmm, interesting
05:19:00 <oklopol> how do i check if a list is empty, isn't there like an empty function?
05:19:07 <Lemmih> > null []
05:19:09 <lambdabot>   True
05:19:13 <oklopol> oh lol it was null
05:19:15 <oklopol> thanks
05:19:42 <oklopol> couldn't do x == [] because the contents aren't Eq, but i guess that'd be stupid anyway
05:20:16 <ray> it's just null [] = True; null _ = False anyway
05:21:11 <oklopol> well yeah, sure
05:21:27 <oklopol> doesn't change anything
05:23:13 <yitz> roconnor: it's just karatsuba, no FFT
05:23:20 <yitz> from the above link
05:23:27 <roconnor> that's a good start
05:23:53 <yitz> python does fine with it
05:24:08 <roconnor> really?
05:24:10 <roconnor> woah
05:25:04 <yitz> karatsuba is great for a general Integer. If you need *really* big ones, use a lib.
05:25:52 <oklopol> is there like a range for where each multiplication is best on wp
05:26:11 <oklopol> i mean list of ranges
05:26:21 <yitz> oklopol: the gmp web site links to papers about that. i'm sure it's implementation specific tho.
05:27:00 <oklopol> sure, but you can probably say thing liks like "karatsuba is best near about 10^30"
05:27:58 <oklopol> O() is usually the way to get around implementation specificity, and the list would be rather boring with it, "use fft"
05:28:03 <yitz> oklopol: I think the python implementation uses naive up to about 2^1000, then karatsuba
05:28:43 <yitz> oklopol: FFT is bad unless you are using really really big numbers
05:28:58 <oklopol> i know, that was kinda my point
05:29:06 <yitz> ok
05:29:09 <endojelly> fast fourier transform?
05:29:11 <endojelly> ?!
05:29:11 <lambdabot> Maybe you meant: . ? @ v
05:29:21 <yitz> yeah
05:29:27 <endojelly> lambdabot, actually, I meant your mother.
05:29:28 <oklopol> endojelly: yes, you can think of numbers as polynomials, use the base as x
05:29:42 <endojelly> oklopol, wow, didn't know that's efficient
05:29:43 <yitz> @vixen actually, I meant your mother
05:29:44 <lambdabot> enough of this!
05:29:50 <int-e> @vixen tell me about your mother.
05:29:51 <lambdabot> what about me?
05:29:58 <oklopol> endojelly: it's O(n lg n), so very much so
05:30:14 <etpace_> Are monads applicatives as well?
05:30:27 <yitz> yes
05:30:27 <endojelly> oklopol, but I guess it really only makes sense with very huge numbers, no?
05:31:00 <oklopol> endojelly: incredibly huge, karatsuba is much slower, asymptotically, but as yitz just said even that's only useful at huge numbers
05:31:23 <endojelly> ah, karatsuba, I know that one. or at least I did 8)
05:31:25 <yitz> there are other methods intermediate to the two
05:31:25 <oklopol> for most numbers you'll meet, the elementary school method is the fastest way
05:31:29 <etpace_> so is sequence = sequenceA? as sequenceA seems to be the more general version?
05:31:29 <oklopol> yes, probably
05:31:50 <oklopol> yitz: is naive the basic O(n^2) multiplication, or am i talking out of my ass?
05:31:53 <endojelly> :t sequenceA
05:31:54 <lambdabot> Not in scope: `sequenceA'
05:32:02 <endojelly> :t Control.Applicative.sequenceA
05:32:03 <lambdabot> Not in scope: `Control.Applicative.sequenceA'
05:32:16 <yitz> yes it is. no you're not.
05:32:28 <endojelly> etpace_, hmm. anyway, it's presumably the same, just as liftA is the more general version of liftM
05:32:40 <yitz> @hoogle sequenceA
05:32:41 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:32:41 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
05:32:53 <oklopol> okay good, also if you wanna link the in-between, would be interesting, i haven't bumped into those on wp
05:32:56 <quicksilver> sequenceA is sequence generalise in two directions at once
05:33:08 <quicksilver> List -> Foldable; Monad -> Applicative
05:33:17 <etpace_> and mapM = sequenceA . fmap?
05:33:23 <yitz> quicksilver: Traversable
05:33:30 <quicksilver> sorry, Traversable
05:33:34 <cjs> Which of these definitions is better code, and why? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8572#a8572
05:34:06 <etpace_> @src mapM Transversable
05:34:06 <lambdabot> Source not found. Maybe you made a typo?
05:34:44 <quicksilver> etpace_: @src is not a good way to browse the libraries
05:34:46 <endojelly> cjs, since it's more concise but still very clear, I'd say the former
05:34:55 <quicksilver> etpace_: it only has a very small selection of core functions.
05:35:16 <yitz> oklopol: yeah, they're linked there. I think gmp uses thom-3 in between.
05:35:27 <yitz> used to anyway
05:35:27 <EvilTerran> cjs, how does that differ from just "when"?
05:35:32 <cjs> I sometimes find that things such as the former are quite clear when I make them up, but then when I come back to them a month later, I have to sit down and work them out.
05:35:39 <EvilTerran> oh, i see, the monadic boolean
05:35:45 <cjs> EvilTerran: right.
05:35:49 <endojelly> :t when
05:35:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:36:04 <cjs> I'm always wanting that, so I finally wrote the damn thing.
05:36:05 <etpace_> whats the best way quicksilver?
05:36:26 <ray> haddocks
05:36:28 <ray> probably
05:36:28 <path[l]> when Im calling a function and I know it will ignore a certain value, is there an "anything" I can pass it, to satisfy the type parameter
05:36:36 <quicksilver> etpace_: the web pages, I would say
05:36:49 <ray> start by hoogling for stuff
05:36:51 <quicksilver> etpace_: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
05:37:12 <etpace_> thanls
05:37:15 <etpace_> thanks
05:37:36 <ray> @hoogle mapM
05:37:37 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:37:37 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:37:37 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:37:46 <cjs> path[l]: "undefined"
05:37:52 <path[l]> ah
05:37:55 <ray> except if you use the actual hoogle website, you can click on those function names to go straight to the docs
05:38:37 <cjs> path[l]: Though often I pass it error, instead, e.g., 'error "MyModule.foo: parameter x should not be dereferenced."'
05:38:46 <EvilTerran> cjs, there's also the comprimise option, "whenM mp s = do p <- mp; when p s"
05:39:08 <quicksilver> (error "halp halp my brain asplode")
05:39:09 <path[l]> ah ok. thanks :)
05:39:13 <path[l]> haha
05:39:21 <quicksilver> cjs has a more practical approach though
05:39:28 <ray> error (fix error)
05:39:48 <cjs> EvilTerran: I like that one the best. Concise, yet obvious.
05:40:24 <cjs> I far to often in Haskell find myself getting clever with point-free style and the like, and producing stuff that is damn hard to decode later.
05:41:03 <cjs> quicksilver: Also, yours is rather to close to a GHC compiler error message for comfort. :-)
05:41:22 <ray> can't be, since it's at runtime
05:41:50 <yitz> @type ap $ fmap when
05:41:52 <lambdabot> forall a (m :: * -> *). (Monad m) => ((a -> Bool) -> a) -> (a -> Bool) -> m () -> m ()
05:42:28 <endojelly> :t join . liftM when
05:42:29 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
05:42:33 <endojelly> :D
05:44:12 * EvilTerran suspects the (e->) monad is getting involved somewhere
05:44:26 <path[l]> Im calling a function from ghci and Id like to know how long it takes to evaluate. Is there a way I can wrap it in a function that gets time now, time afterwards and shows the diff?
05:45:09 <yitz> path[l]: :set +t
05:45:35 <path[l]> isnt that type?
05:45:47 <yitz> path[l]: and :unset +t turns it off :)
05:46:22 <path[l]> that only tells me the type of the last thing I called
05:46:24 <yitz> oh sorry, +s for timings, right
05:46:30 <path[l]> ah lol ok
05:46:36 <burp> ah, good to know
05:46:51 <path[l]> thanks that worked
05:47:16 <etpace_> so while all monads are applicatives, because of the monad type decleration, i have to use WrapMonad and unwrapMonad to use monads for functions that require applicatives?
05:47:31 <yitz> etpace_: unfortunately
05:47:43 <opqdonut> unless the monad you are using has an applicative instance
05:48:01 <opqdonut> what's the status of the class system hierarchy rework btw?
05:48:52 <doserj> there will probably be no rework until someone implements sth like class aliases
05:49:35 <ray> if there's no applicative instance you can write instance Applicative T where pure = return; (<*>) = ap
05:50:03 <ray> it'll overlap if the maintainer eventually writes an instance, though
05:54:31 <yitz> ray. yes, I really wish there were a way to control export/import of instances like other symbols.
05:54:41 <yitz> but quicksilver won't allow it.
05:54:50 <ray> haha, yeah
05:55:00 <ray> it breaks the technobabble or something :P
05:55:48 <yitz> ray: it breaks a lot of things, sometimes. but other times you really need it.
05:56:35 <etpace_> How do we change a list of trees into a tree of lists?
05:57:18 <yitz> etpace_: are you guaranteed that all the trees have the same shape?
05:57:25 <yitz> otherwise, I'm not sure what you mean.
05:58:24 <path[l]> ugh ok,  if I have a function calling itself recusively, can I make haskell evaluate it strictly and use tail recursion?
05:58:33 <ray> you cannae change the laws of physics
05:58:38 <etpace_> I'm not sure, it was posed in the typeclopedia, and it's to show that you can commute two functors
05:58:56 <ray> what if there were some kind of alpha-conversion for class names?
05:59:06 <ray> now i think i'm just babbling :(
06:00:18 <ray> etpace_: your tree of lists will be a single tree where each node contains a list containing all the elements that were at that position in one of the trees in your original list of trees
06:00:47 <ray> so if in your list of trees the root nodes were 2, 2, 3, 7, and 9, your tree of lists will have at its root [2,2,3,7,9]
06:00:58 <ray> implementation left as an exercise
06:03:00 <etpace_> :t Tree
06:03:02 <lambdabot> Not in scope: data constructor `Tree'
06:03:16 <ray> :k Tree
06:03:17 <lambdabot> * -> *
06:03:47 <ray> :t Node
06:03:49 <lambdabot> forall a. a -> Forest a -> Tree a
06:05:26 <ray> you can probably do it by defining something like data Tree a = Nil | Node a (Tree a) (Tree a)
06:06:27 <yitz> path[l]: not really. what are you trying to do?
06:06:58 <path[l]> well something is taking a very long time, its a recusive call. I assume Im running into an issue because of the lazyness issue
06:07:07 <path[l]> so Im wondering how to force evaluation
06:07:15 <path[l]> I just read something about a $! operation
06:07:22 <yitz> @type seq
06:07:24 <lambdabot> forall a t. a -> t -> t
06:07:46 <yitz> a `seq` b forces a to be evaluated, then returns b
06:07:51 <yitz> @src ($!)
06:07:52 <lambdabot> f $! x = x `seq` f x
06:08:19 <yitz> path[l]: but I'm not sure that's the first thing to try here
06:08:40 <Lanjiao_> > (+) 3 4
06:08:41 <lambdabot>   7
06:09:17 <path[l]> ah
06:09:27 <ray> > const 4 5
06:09:29 <lambdabot>   4
06:09:32 <etpace_> > (++) <$> Leaf [1] <*> Leaf [2] <*> Leaf [3]
06:09:33 <lambdabot>   Not in scope: data constructor `Leaf'Not in scope: data constructor `Leaf'N...
06:09:36 <ray> > const 4 undefined
06:09:37 <yitz> path[l]: if it's really infinite recursion, none of those things will help (in any language), you've got to discover the loop.
06:09:37 <lambdabot>   4
06:09:38 <path[l]> :t ($!)
06:09:39 <lambdabot> forall a b. (a -> b) -> a -> b
06:09:44 <path[l]> no its not infinite
06:09:45 <ray> > const 4 $! undefined
06:09:46 <path[l]> its just large
06:09:47 <lambdabot>   * Exception: Prelude.undefined
06:09:56 <yitz> whatever
06:10:21 <path[l]> well I can get it to run under 2 minutes in ruby =p, so if Ive ported the logic write ...
06:10:26 <path[l]> then this is my guess for whats wrong
06:10:28 <path[l]> lol
06:10:30 <yitz> const 4 (length [1..1000000000])
06:10:38 <roconnor> 4
06:10:43 <yitz> > const 4 $ length [1..1000000000]
06:10:44 <lambdabot>   4
06:10:57 <ray> const 4 $! length [1..1000000000]
06:10:59 <yitz> > const 4 $! length [1..1000000000]
06:11:01 <ray> would kill it
06:11:04 <lambdabot>   mueval-core: Prelude.read: no parse
06:11:04 <lambdabot>  mueval: ExitFailure 1
06:11:05 <path[l]> heh
06:11:06 <roconnor> 4
06:11:09 <path[l]> ah
06:11:25 <roconnor> in your face lambdabot
06:11:28 <etpace_> > data Tree a = Leaf a | Branch (Tree a) (Tree a)
06:11:29 <lambdabot>   <no location info>: parse error on input `data'
06:11:35 <etpace_> ah
06:11:37 <ray> roconnor: you cheated
06:11:50 <roconnor> ray: I have some rewrite rules
06:11:52 <path[l]> hmm putting in a $! gave me a type mistmatch
06:11:53 <path[l]> thats odd
06:11:53 <ray> you either didn't evaluate length [1..1000000000]
06:11:59 <ray> or you did but you didn't walk the whole list
06:12:04 <opqdonut> as he said
06:12:05 <yitz> roconnor> fix show
06:12:07 <Makoryu> http://pastebin.ws/fqnoa <- What d'you guys think? Good or bad for newbies?
06:12:09 <opqdonut> he has some good rewrite rules
06:12:18 <ray> more like bad rewrite rules
06:12:38 <opqdonut> hehe, that fix show did him in
06:12:38 <gwern> http://www.reddit.com/r/pics/comments/9dqhs/m/c0cdlh8 <-- I love reddit, its novelty accounts and puns
06:12:42 <yitz> haha I knocked him out!
06:12:59 <ray> makoryu: well, you'll make cale mad with your chains of $
06:13:00 <_roconnor> damn you yitz
06:13:06 <yitz> _roconnor: haha
06:13:09 <Makoryu> ray: Yep
06:14:51 <ray> gwern: what a great guy
06:14:58 * gwern is, thanks
06:15:36 <ray> if i were talking about you and not at you, i'd say "gwern: a great guy"
06:15:46 <ray> and it'd be at the top of a comic strip
06:15:47 <therp> applying church encoding idea for conditionals (generalized to arbitrary data structures) seems to fail for the recursive data structures. any ideas? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8574#a8574
06:16:15 <path[l]> ok hmm I think Ill need help using $! correctly. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3416#a3416
06:16:15 <gwern> ray: 'gwern: what a great guy' and 'gwern: a great guy' are the same, just the latter has less emphasis
06:16:28 <yitz> gwern+
06:16:36 <yitz> @karma gwern
06:16:37 <lambdabot> gwern has a karma of 2
06:16:41 <ray> 2.5
06:16:42 <yitz> @karma+ gwern
06:16:43 <lambdabot> gwern's karma raised to 3.
06:16:59 <gwern> karma apparently only comes in integers
06:17:03 <ray> @komma
06:17:04 <lambdabot> You have a karma of 2
06:17:12 <ray> @comma is too far away :(
06:17:12 <lambdabot> Unknown command, try @list
06:17:13 <Makoryu> gwern: I could have sworn it came in cubes
06:17:15 <_roconnor> therp: what is the supposed type of dataToFunctions?
06:17:22 <ski> therp : you need equi-recursive types
06:17:29 <gwern> Makoryu: well, you'd be wrong
06:17:31 <ski> (i think ..)
06:17:43 <ray> karma should come in Rationals
06:18:09 <therp> roconnor: good question. I fail to write it in finite space. :)
06:18:10 <opqdonut> therp: write out the type of dataToFunctions
06:18:25 <gwern> patches accepted... but then, what would + do that wouldn't be equivalent to ints?
06:18:45 <roconnor> therp: you probably need to use a new data type to capture that type like ski mentioned
06:19:04 <therp> ski: hm, iirc the equiv/iso recursive difference is additional tags.
06:19:12 <roconnor> therp: http://r6.ca/blog/20060919T084800Z.html  might be relevent
06:19:34 <therp> my main intention was to remove any data types from the code
06:19:51 <roconnor> therp: I don't think that can be entirely done
06:19:51 <yitz> ray: Complex, because often it's imaginary
06:19:55 <ray> gwern: @karma+ 1%2 maybe
06:19:55 <therp> (to make code rewriting easier for another function using the lambda structures)
06:20:16 <roconnor> therp: you can probably reduce the number of data types to a small handful.  Maybe even one.
06:20:41 <ray> @karma+ 0 :+ 1%2
06:20:42 <lambdabot> 0's karma raised to 1.
06:21:05 <ski> therp : actually ..
06:21:08 <yitz> @karma- 0
06:21:09 <lambdabot> 0's karma lowered to 0.
06:21:25 <ray> if 0's karma is 0, then how do we construct the naturals?!
06:21:38 <yitz> > let 0 = 1 in 5 + 0
06:21:40 <lambdabot>   5
06:21:49 <roconnor> @karma []
06:21:49 <lambdabot> [] has a karma of -1
06:21:54 <therp> roconnor: sounds plausible.
06:22:01 <ski> therp : try passing `absFn',`appFn',`varFn' to the three recursive calls
06:22:16 <ray> > let 0+0 = 1; 5+1=6 in 5 + (0+0)
06:22:18 <lambdabot>   6
06:22:24 <ray> having to include 5+1=6 is unsightly :(
06:23:28 <therp> ski: you mean like in the first case "absFn var (rec body absFn appFn varFn)"? hm that's not intended.
06:23:30 <gwern> silly roconnor, karma is obviously a set - all we care about is its cardinality, not an ordering
06:23:39 <Makoryu> > 0.000000000000001 :: Rational
06:23:40 <lambdabot>   1 % 1000000000000000
06:23:47 <ski> therp : or, equivalently, lift the `\absFn appFn varFn -> ' out of the `fix (\rec -> ...)'
06:24:26 <therp> probably the approach is wrong.
06:24:51 <ski> therp : maybe i should ask what the intended translation of `\x. \y. y x' should be
06:24:56 <therp> hm, no I guess that's the right idea..
06:25:24 <yitz> path[l]: where's your recursion problem?
06:25:31 <path[l]> sec let me repaste it
06:25:36 * ski was thinking you wanted `\abs app var -> abs "x" (abs "y" (app (var "y") (var "x")))'
06:26:19 <ski> but maybe you wanted `\abs app var -> abs "x" (\abs app var -> abs "y" (\abs app var -> app (\abs app var -> var "y") (\abs app var -> var "x")))' ?
06:26:55 <therp> ski: dataToFunction (Abs "x" (Abs "y" (App (Var "y") (Var "x"))) = (\f1 _ _ -> f1 "x" (\f2 _ _ -> "y" (\_ f3 _ -> f3 (\_ _ f4 -> "y") (\_ _ f5 -> "x"))))
06:27:14 <ski> aye
06:29:05 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3416#a3417 <--- its horridly ugly, but there it is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3416#a3418
06:29:13 <ski>   mu r. forall o. (Id -> r -> o) -> (r -> r -> o) -> (Id -> o) -> o
06:29:17 <path[l]> Ive also pasted the comparison times running in ruby
06:29:27 <ski> therp : maybe that ^ is the type you want, then ?
06:29:33 <yitz> path[l]: are you worried about solve?
06:29:37 <path[l]> yes
06:29:52 <path[l]> now I know its bad haskell code, so any suggestions would be good too =p
06:29:57 <therp> ski: yes!
06:30:16 <ski> (or maybe lifting the `forall o. ' outside the `mu r. ' .. not sure)
06:30:24 <therp> ski: but I guess I can't express that without using datatype tags somewhere
06:30:31 <ski> indeed
06:30:36 <yitz> path[l]: could be the teams list is growing explosively
06:30:42 <ski> (you could with `ocaml -rectypes')
06:30:47 <yitz> path[l]: that would sure bog you down
06:31:23 <path[l]> yeah it probably is, but Im running pretty much the same algorithm in ruby. So either Im using the wrong data structure in haskell or I have too many unresolved thunks
06:32:10 <yitz> path[l]: looks kind of schemy to me
06:32:21 <ski>   newtype Lambda = MkL (forall o. (Id -> Lambda -> o) -> (Lambda -> Lambda -> o) -> (Id -> o) -> o)
06:32:50 <shapr1> So I heard that Haskell is functional. What does that mean? Like, algebra or something?
06:33:09 <quicksilver> shapr1: it means it works.
06:33:18 <int-e> @quote functional
06:33:19 <lambdabot> ghc says: Functional dependencies conflict between instance declarations
06:33:24 <node808> I went to a party last nite and this morning my bum is all sore and itcy
06:33:26 <shapr1> Oh, so it's not dysfunctional?
06:33:32 <int-e> @quote functional
06:33:33 <lambdabot> dons says: Ooh, functional programmers are so hot!
06:33:39 <shapr1> node808: Were you coding Haskell at the party?
06:33:40 <ski> @quote shapr
06:33:40 <lambdabot> shapr says: <shapr> Oleg will do something terrifying like implementing type checking in tcp/ip checksums on the router level through someemergent property of BGP and he'll do it all with HSP!
06:33:54 <shapr1> ski: I think you blew my cover.
06:33:59 <node808> shapr1: No but it was a haskell party
06:34:01 * ski bows
06:34:04 <shapr1> ski: hah
06:34:12 <shapr1> node808: Really? What did you code?
06:34:29 <yrlnry> Why does quickCheck not define Instance Arbitrary Char ?
06:34:48 <int-e> @quote yrlnry2
06:34:48 <lambdabot> yrlnry2 says: #haskell is the most functional channel I've ever seen.
06:35:11 <shapr1> yrlnry: I think qc2 has such instances. Also, it's handy to not have a Char instance of Arb by default, it allows you to create your own.
06:35:20 <quicksilver> shapr1: straw man
06:35:33 <yrlnry> shapr1: Thanks.
06:35:35 <quicksilver> shapr1: there is already a combinator for using your own generator if you don't like the default one
06:35:56 <yrlnry> @quote yrlnry
06:35:56 <lambdabot> No quotes match. Are you on drugs?
06:36:07 <yrlnry> Ah.
06:36:16 <therp> ski: I will try to lift your Mu r.Forall o.(...) type to http://r6.ca/blog/20060919T084800Z.html after lunch (yes I should try to eat earlier)
06:36:27 <therp> thanks for the link roconnor
06:36:27 <int-e> @quote int-e
06:36:28 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
06:36:45 <shapr1> quicksilver: which combinator?
06:36:45 <int-e> oh.
06:36:47 <path[l]> yitz heh I dunno
06:37:05 <quicksilver> shapr1: not sure. "forall" is it called?
06:37:08 <shapr1> oh
06:37:55 <quicksilver> forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
06:38:02 <path[l]> so yitz, how should I use seq or $! there? Im running into syntax issues : X
06:38:13 <path[l]> I even tried ($! (n-1)) but it complained
06:38:14 <quicksilver> shapr1: I only know because I once trolled "quickcheck sucks because it abuses typeclasses"
06:38:18 <shapr1> haha
06:38:28 <quicksilver> shapr1: and someone was smart enough to point out to me the solution.
06:38:28 <therp> ski: but I wonder why the type system doesn't complain about the type of fix? Shouldn't (a -> a) -> a fail likewise at the occurs check?
06:38:37 <shapr1> I've actually used that before, but not recently.
06:38:53 <yrlnry> quickcheck sucks because it didn't work after I poured frappe in my laptop.
06:39:21 <quicksilver> shapr1: althoug I'm not sure what you do if you don't like a Coarbitrary instance
06:39:30 <shapr1> suck it up!
06:40:00 <path[l]> > const [4,5,6]
06:40:03 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [t])
06:40:03 <lambdabot>    arising from a use of...
06:40:04 <quicksilver> or, for that matter, if you want to override shrink.
06:40:10 <quicksilver> so maybe I should revert to my original thesis.
06:40:18 <quicksilver> "Quickcheck sucks because it abuses typeclasses"
06:40:28 <path[l]> > const 4 5
06:40:30 <lambdabot>   4
06:40:39 <path[l]> > const 4 5 6
06:40:40 <lambdabot>   Add a type signature
06:40:41 <shapr1> Aren't shrink and coarb intertwined somewhat?
06:41:03 <shapr1> Oh nevermind, I remember the typeclass 'Shrinkable'.
06:41:06 <path[l]> hmm thats not how its done clearly
06:41:32 <Axman6> :t const
06:41:34 <lambdabot> forall a b. a -> b -> a
06:41:47 <chrisbrown> ping Beelsebob
06:41:54 <shapr1> I think const is const x y = x maybe?
06:41:56 <shapr1> @src const
06:41:56 <lambdabot> const x _ = x
06:41:59 <path[l]> yeah
06:42:00 <shapr1> ah, close enough.
06:42:11 <quicksilver> shapr1: shrink and arb are intertwined, in the qc2 I'm looking at.
06:42:25 <ski> therp : no .. however, you would get similar errors for `fix = \f -> (\t -> t t) (\g -> f (g g))' or `fix = (\t -> t t) (\g f -> f (g g f))'
06:42:33 <shapr1> Oh, because coarb is about sizing?
06:42:40 <shapr1> I don't have qc2 source handy.
06:42:41 <path[l]> Im trying to find out how make unlazy  some evaluation of the 2nd parameter of a 3 param function
06:42:58 <opqdonut> use bang patterns
06:42:59 <yitz> path[l]: it's kind of hard for me to follow what you're doing, with all those nested function defs
06:43:06 <opqdonut> f x !y z =
06:43:16 <yitz> path[l]: how about if you make the type of solve:
06:43:18 <ski> (therp : but inserting `Roll' or `unroll' at appropriate places will fix that, in a similar way)
06:43:40 <path[l]> yitz: yeah I know, its very badly coded : x, it was coded in an imperative language where I could abstract stuff away in state
06:43:57 <path[l]> I dont know to build good abstractions here
06:44:21 <yitz> step :: (Team, Int, Int) -> (Team, Int, Int)
06:44:55 <yitz> then solve searches down (iterate step) for when it finishes.
06:44:59 <quicksilver> shapr1: it's only a click away ;) http://hackage.haskell.org/package/QuickCheck
06:45:10 <path[l]> hmm
06:45:16 <yitz> then you could easily see what is happening by examining the list (iterate step)
06:45:36 <path[l]> I dont think I understood the suggestion yitz
06:45:57 <path[l]> well I know whats happening personally, if that helps :)
06:46:08 <path[l]> but do you mean for other people to be able to read it?
06:46:10 <yitz> path[l]: the only things that really change are the list of teams, and n, right?
06:46:18 <path[l]> thats right
06:47:05 <path[l]> so its really a loop from n to 1, where I change the list of teams
06:47:11 <yitz> path[l]: so instead of the hard-coded recursion, create an infinite list of (teams, n) that evolves towards the solution
06:47:42 <yitz> path[l]: then, it is really easy to examine various parts of that list to see what is happening
06:48:01 <path[l]> I try and built all combinations of size n teams and eliminate at each step teams that are worse than my heuristic solutio
06:48:35 <yitz> ok, so do that as a list of step results
06:49:04 <path[l]> I dont fully follow, every recursive call to solve, the teams is the step result
06:49:21 <Berengal> @type iterate
06:49:22 <lambdabot> forall a. (a -> a) -> a -> [a]
06:49:26 <Berengal> path[l], ↑
06:49:46 <ray> > iterate id 0
06:49:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:49:52 <path[l]> ah
06:49:58 <yitz> path[l]: right. so instead of recursing, just write a function that takes the last step and computes the next step from it
06:50:00 <ray> > iterate (+1) 0
06:50:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:50:21 <yitz> path[l]: then use the iterate function to get a list containing the entire process of evolving steps
06:50:32 <path[l]> hmm
06:50:34 <ray> basically iterate f x = [x, f x, f (f x)...
06:50:37 <Berengal> Note that iterate produces an infinite list
06:50:49 <yitz> path[l]: then you search down to the end of the list to get the answer - or just parts of the list to debug
06:51:17 <path[l]> right ok, let me think about how to do that. But note the solution right now is correct functionally. It's too slow
06:51:18 <yitz> path[l]: (not the end of the list, it's infinite, but the place where you've reached the end of your calculation)
06:51:22 <path[l]> so thats my real problem
06:51:58 <yitz> path[l]: ok, i'm just giving you a different style that's gives you more flexibility to investigate
06:52:09 <path[l]> ok :)
06:52:25 <ray> in the future, computer science will be a single course under the haskell major
06:52:33 <ray> it'll basically be about optimising your programs
06:52:41 <path[l]> but I just wanna spike out this idea of forcing the creation of teams and evaluation of (n-1) to be done automatically
06:52:45 <path[l]> before the recursive call
06:52:52 <path[l]> I just dunno how to do it =p
06:53:03 <Berengal> ray, and the haskell major automatically qualifies you for a math PhD
06:53:14 <ray> math is also a single course under a haskell major
06:53:23 <ray> it's mostly categories
06:53:38 <ray> maybe 2 courses if it's a good school
06:53:59 <yitz> path[l]: the problem is that teams itself is a list of pairs. so it could be there are various levels of forcing you need to do.
06:54:00 * shapr1 boings cheerfully
06:54:05 <Berengal> theoretical schools drop teaching the IO monad...
06:54:18 <yitz> path[l]: so i'm suggesting exploiting laziness, rather than fighting it
06:54:21 <ray> we'll be using reactive haskell machines
06:54:25 <gwern> ray: the first course will be about the AIXI formalism, and then all the rest will be about computable approximations thereof...
06:54:39 <gwern> (since every program is an AI program of some sort)
06:54:41 <path[l]> hmm
06:54:49 <ziman> > iterate f x
06:54:49 <Berengal> @quote intel.*runtime
06:54:50 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
06:54:50 <lambdabot> simonmar says: Wondering how popular Haskell needs to become for intel to optimize their processors for my runtime, rather than the other way around.
06:55:36 <yitz> heh, I wasn't sure which was the quote
06:56:10 <gwern> iterate randomly quotes simons?
06:56:34 <Berengal> gwern, they're found at the end of the lists
06:56:35 <yitz> path[l]: I've got to run, good luck. cute algo!
06:56:43 <path[l]> lol ok thanks
06:57:49 <ray> if lambdabot forgot the quote i @remembered what's the socially acceptable delay before doing it again
06:58:02 <opqdonut> 1day
06:58:03 <ray> or gwern-acceptable at least
06:58:12 <shapr1> heh, gwern is the quotemaster?
06:58:22 <ray> i'm just guessing
06:59:27 <gwern> the socially acceptable thing is to @remember it when lambdabot has clearly forgotten it, and then supplicate me for an @flush
06:59:57 * gwern points out that I wrote 'supplicate', not 'fellate'. just so we're clear guys!
07:00:21 <opqdonut> 8]
07:00:30 * quicksilver thinks there was no confusion in anyone's mind but gwern's.
07:01:19 <ray> @remember thermoplyae <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
07:01:20 <lambdabot> Done.
07:01:26 <ray> oh gwern, i supplicate thee
07:01:43 <roconnor> @quote haiku
07:01:43 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
07:01:43 <lambdabot> read
07:02:30 <Saizan> and that's not even the same monoid!
07:02:32 <gwern> @flush -- supplication satisfactory
07:02:47 <Saizan> ..or is it?
07:02:50 <lilac> gwern: i read that as supplication suppository :-/
07:02:58 * lilac washes eyes out
07:03:15 <lilac> > fix error
07:03:21 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:03:57 <gwern> @quote PhilipWadler
07:03:58 <blackdog> damn, and it looks like it should work :)
07:04:00 <gwern> quicksilver: and you thought such confusions were only in my head! I present lilac as an exception
07:04:08 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
07:04:34 <Berengal> In a year, people are going to think Wadler was the originator of the original quote...
07:04:50 <roconnor> Berengal: likely
07:05:03 <yrlnry> I'm getting a type check failure I don't understand.  Can anyone help?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8578#a8578
07:05:05 <blackdog> @vixen are you still there?
07:05:16 <yrlnry> The function defintion type checks just fine when I enter it as a lambda expression with :t.
07:05:17 <lambdabot> yes, still here
07:05:37 <blackdog> hm, shapr said it'd been turned off. oh well.
07:05:45 <lilac> yrlnry: without looking at the code, i'd guess MR
07:06:15 <yrlnry> That was my first guess too, but I put -fno-monomorphism-restriction and got the same result.
07:06:29 <yrlnry> (I'm learning to look under the lamppost first.)
07:06:32 <lilac> ... = App (f a) ...
07:06:42 <jfoutz> astcgi/hpaste.fcgi/view?id=8578#a8578
07:06:56 <jfoutz> mispaste.
07:07:02 <lilac> yrlnry: the 'right' code is wrong too; the type should be (a -> b) -> (Term a -> Term b)
07:07:09 <yrlnry> Oh, whoops.
07:07:14 <yrlnry> That was dumb, thanks.
07:08:06 <roconnor> :D
07:08:12 <roconnor> App (f a) $ ...
07:08:26 <roconnor> typechecking++
07:09:25 <iabal> hello, there is some way to put a type annotation like this: foo :: a -> b -> a; foo = ... (x::a) ... ?
07:09:45 <dschoepe> iabal: -XScopedTypeVariables
07:10:01 <dschoepe> then you can write foo :: forall a. a -> b -> a and use a in the body
07:10:35 <EvilTerran> iabal, it shouldn't be necessary under most circumstances (inference should be able to do it for you), but, as dschoepe says, you need an extension - either by passing -XScopedTypeVariables on the command-line, or {-# LANGUAGE ScopedTypeVariables #-} at the top of the file
07:11:14 <quicksilver> EvilTerran: a fortiori, it is *never* necessary.
07:11:21 <yrlnry> Okay, fixed.
07:11:27 <quicksilver> EvilTerran: but it is a lot more convenient than the alternative, in some cases
07:11:34 <yrlnry> I knew I should have made it App a [Term b] instead of App a [Term a].
07:11:54 <yrlnry> Thanks lilac and roconnor.
07:12:00 <iabal> EvilTerran: yep, but in this case I need it to choose the correct instance of a type-class
07:12:22 <yrlnry> :set -fno-monomorphism-restriction is the ghci command to turn on the NMR, correct?
07:12:24 <iabal> GHC seems to choose one, but not the correct
07:13:08 <pao> @paste
07:13:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:14:28 <pao> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8579#a8579
07:14:31 <pao> hi all :-)
07:14:35 <EvilTerran> quicksilver, yeah, that's kinda what i meant. i wasn't going to muddy the waters by going off on a babble about asTypeOf etc
07:14:44 <pao> has anyone a more idiomatic version for the paste?
07:15:04 <EvilTerran> pao, i suggest a list comprehension
07:15:12 <quicksilver> pao: extract xs = [ v | VarDef v _ <- xs]
07:15:18 <EvilTerran> ^
07:15:25 <pao> EvilTerran: quicksilver  thanks!
07:16:03 <yrlnry> I need to write more comprehensions.
07:16:37 <EvilTerran> ?src catMaybes
07:16:37 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:16:42 <EvilTerran> ^ suspiciously similar
07:16:55 <pao> EvilTerran: :-)
07:17:15 <pao> I could have looked myself...
07:17:42 <quicksilver> it's a slightly obscure, but very convenient, trick that faiing pattern matches cause [] in a list comp
07:17:59 <quicksilver> ...which is generalised to failing patter matches causing 'fail' in a do block.
07:18:24 <pao> quicksilver: convenient indeed
07:18:46 <pao> quicksilver: list comp are always desugared to monads?
07:18:48 <quicksilver> it's very convenient when you're doing a selection *and* a projection at the same time.
07:19:02 <quicksilver> i.e. you're selecting VarDefs, and projecting on the first field.
07:19:03 <pao> quicksilver: ... and that is exactly my case
07:19:11 <pao> yep
07:19:12 <quicksilver> also you can add an abitrary restriction:
07:19:24 <quicksilver> [ v | VarDef v _ <- xs, length v == 7]
07:19:32 <quicksilver> probably not very useful in your case, but that kind of thing.
07:19:37 <pao> yep
07:19:43 <pao> thanks again for the reminder
07:19:50 <quicksilver> pao: no, lisp comps aren't technically desugared to monads, in GHC, but that's for boring implementation reasons
07:19:58 <quicksilver> semantically they might as well be.
07:20:23 <pao> clear
07:22:53 <shapr1> blackdog: well, it was turned off at some point.
07:25:21 <pozic> Is writing let a = X in (a,a) as efficient at run-time as writing (X,X), assuming no compiler optimizations?
07:26:38 <pozic> It was my understanding that of every 0-ary constructor there exists only one instance in the system, so they should be the same.
07:26:58 <opqdonut> pozic: yeah i'd guess so
07:28:36 <jfoutz> i got that wrong the other day.
07:29:52 <jfoutz> let a = x+1 in (a,a) is better than (x+1,x+1)
07:30:37 <quicksilver> pozic: I don't think "of every 0-ary constructor there exists only one instance" is either portably true, or necessarily true without optimisations.
07:30:42 <quicksilver> it's certainly true of GHC though.
07:30:52 <int-e> But  let a = X in (a,a)  might be worse than  (X,X).
07:31:00 <pao> @pl (,) <$> length <*> head
07:31:00 <lambdabot> (,) <$> length <*> head
07:31:10 <jfoutz> because of the thunk?
07:31:15 <int-e> yes
07:40:30 <etpace_> :t <*>
07:40:31 <lambdabot> parse error on input `<*>'
07:40:43 <etpace_> :t Maybe <*>
07:40:43 <Raevel> :t (<*>)
07:40:45 <lambdabot> parse error (possibly incorrect indentation)
07:40:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:44:47 <EvilTerran> ?src Maybe (<*>)
07:44:48 <lambdabot> (<*>) = ap
07:44:56 <EvilTerran> ...
07:45:03 <EvilTerran> geez, what a cop-out
07:46:04 <quicksilver> mf <*> mx = case (mf,mx) of (Just f,Just x) -> Just (f x); _ -> Nothing
07:46:25 <EvilTerran> quicksilver, or just "Just f <*> Just x = Just (f x); _ <*> _ = Nothing"
07:46:37 <quicksilver> indeed.
07:46:56 <EvilTerran> something that actually tells you something about what <*> does for Maybe, anyway
07:47:25 <EvilTerran> ?src ap
07:47:25 <lambdabot> ap = liftM2 id
07:47:28 <EvilTerran> ?src liftM2
07:47:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:47:48 <EvilTerran> ... and so on and so on... seems like a bit of a wild goose chase for something that's expressible in two lines :P
07:47:54 <etpace_> Hmm... for Tree a = Leaf a | Branch a (Tree a) (Tree a), <*> can have two behaviours right? I can either have (Leaf f) <*> t = fmap f (as well as changing leaf for Branch f _ _), or where <*> takes two identically shaped trees and applies the function to the value in the same `place', but which one is corrct? is one of the applicative laws fmap pure . id = id or something?
07:48:39 <quicksilver> etpace_: Yes.
07:49:00 <quicksilver> etpace_: there is always this choice for shaped structures.
07:49:10 <quicksilver> assume same shape and do pointwise composition
07:49:20 <quicksilver> or "multiply" one shape into the leaves of the other
07:51:50 <etpace_> I guess ill go with pointwise
07:53:37 <quicksilver> in general, I wouldn't
07:53:47 <quicksilver> it's annoying to have things which only work when shapes are precisely the same
07:53:59 <quicksilver> but you have to ask yourself what you're trying to acheive by writing these instances.
07:55:39 <EvilTerran> if the answer is "practice writing applicative instances", write both! :)
07:57:17 <EvilTerran> quicksilver, do you know of a convincing use case for either, offhand?
07:58:03 <quicksilver> for a tree?
07:58:16 <EvilTerran> a binary tree used as an applicative (or monad)
07:58:24 <lilac> the pointwise way presumably needs to return something whose structure is the intersection of the two given structires
07:58:42 <lilac> (and pure presumably needs to provide an infinite structure for the laws to work out)
07:58:43 <quicksilver> the pointwise way has a problem with 'pure'
07:58:47 <quicksilver> yes
07:58:54 <quicksilver> or you fix a concrete structure
07:58:59 <quicksilver> like 'lists of length 7'
07:59:10 <EvilTerran> pure = replicate 7
07:59:33 <lilac> if your type happens to be 'lists of length 7' then the pointwise way is the /only/ legal applicative instance, isnt' it?
07:59:40 <quicksilver> EvilTerran: sure. Position trees of games
07:59:57 <EvilTerran> ... i guess i can see how that could be useful
08:00:11 * EvilTerran 's never been able to come up with a use for a tree monad on his own :P
08:00:12 <quicksilver> it's much the same as the list interpretation
08:00:16 <quicksilver> just with a bit more strucutre on the list
08:00:28 <quicksilver> the basic idea is still the same - exploring a state space non-deterministically
08:00:44 <quicksilver> just your non-deterministic choices are no longer arranged in a list.
08:00:45 <int-e> the list monad can be construed as a depth-first traversal of such a tree.
08:00:56 <lilac> EvilTerran: tree reduction for call-by-name evaluation?
08:01:14 <quicksilver> int-e: right, and you need to keep to the tree monad if depth-first traversal is too lossy for you
08:01:26 <quicksilver> that is, if you care more about the relative positions of elements than just their depth-first order
08:01:49 * lilac wonders what uses the ziptree applicative might have
08:01:52 * EvilTerran sees - i think i needed a few examples of how you'd use it, before i could see intuitively "what it does"
08:01:57 <int-e> quicksilver: right
08:02:11 <jfoutz> EvilTerran: i've just started a tree for layouts. msum for gluing stuff on the left, mprod for gluing stuff on the bottom
08:02:47 <quicksilver> jfoutz: then the monad instance is substitution.
08:02:50 <quicksilver> but I'm not sure how useful that is.
08:03:05 <quicksilver> a layout of layouts is a layout.
08:03:09 <quicksilver> (join)
08:04:02 <node808> there's something on my back that looks like I rolled over a glazed donut last nite
08:04:14 <bastl> what does this mean: "The class method `parse' mentions none of the type variables of the class Parseable a" I did too much java recently ...
08:04:16 <node808> but it isnt sweet
08:04:23 <bastl> is class method the function i declare in the type class?
08:04:27 <pozic> Why does runContT take a second argument? Is it just bad design?
08:04:33 <bastl> i dont use that function by now...
08:04:36 <Berengal> In the container-centric view of monads, what should sequence be called?
08:05:03 <quicksilver> bastl: yes, a class method is a function or value in a class definition
08:05:09 <pozic> > sequence [Just 1, Just 2, Just 3]
08:05:11 <lambdabot>   Just [1,2,3]
08:05:21 <quicksilver> bastl: if you don't mention the type variables it's a bit hard for the compiler to pick the right one.
08:05:51 <pozic> > sequence [[1], [2], [3,4,5]]
08:05:52 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5]]
08:05:55 <bastl> i see
08:06:04 <jfoutz> quicksilver: i'm not sure what you mean "the monad instance is substitution"?
08:06:06 <bastl> thanks, gtg.
08:06:07 <yrlnry> Is there a tool that integrates the gchi single-step debugger with Emacs?
08:06:08 <pozic> Berengal: I don't think there is one name which fits all behaviours.
08:06:28 <Berengal> pozic, in all cases it turns [m a] into m [a]
08:06:51 <Berengal> listCommute?
08:06:55 <jfoutz> > sequence [Just 1, Just 2]
08:06:56 <lambdabot>   Just [1,2]
08:07:10 <quicksilver> jfoutz: it lets you substitute entire layouts for single atoms in your layout
08:07:18 <ray> > sequence [getChar]
08:07:19 <lambdabot>   <IO [Char]>
08:07:24 <quicksilver> jfoutz: (and then collapse the result into a single layout)
08:07:30 <mercury^> Hmm, I cannot seem to use primops with ghc 6.10.4
08:07:39 <saml> in category theory, is there a term for an object that has only incoming arrows?
08:07:40 <quicksilver> jfoutz: this is like substitution in expressions in a programming language, which is why I chose the word.
08:08:02 <jfoutz> quicksilver: ahh, join. m m text -> m text
08:08:07 <mercury^> It parses the # as infix operator.
08:08:08 <quicksilver> jfoutz: nod
08:08:15 <quicksilver> mercury^: you need -XMagicHash
08:08:21 <quicksilver> or LANGUAGE MagicHash
08:08:41 <quicksilver> saml: I don't think so.
08:08:44 <jfoutz> quicksilver: yeah. not sure if join is going to be particularly useful. i think return & pure will be handy though. fmap might be interesting as well.
08:08:48 <quicksilver> saml: a "top" object maybe?
08:08:55 <saml> quicksilver, thank you
08:09:12 <mercury^> quicksilver: thank you!
08:12:38 <node808> Ohhh my farter hurts
08:13:31 <hackagebot> Hieroglyph 3.88 - Purely functional 2D graphics for visualization. (JeffersonHeard)
08:13:56 <EvilTerran> pozic, i think the type would need an existential otherwise
08:14:07 <EvilTerran> ?src Cont
08:14:07 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
08:14:45 <quicksilver> :t runContT
08:14:46 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
08:14:53 <EvilTerran> ?src ContT
08:14:53 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
08:16:33 <EvilTerran> pozic, well, the internal workings of Cont(T) need the "(a -> r) -> r" arrangement, as that's how the continuations do their thing, as i understand it
08:16:35 <yrlnry> quicksilver:  wouldn't an object with only incoming arrows be a "bottom" object?
08:17:11 <EvilTerran> ?type flip runCont id -- pozic, you could have this instead of runCont, but runCont's more fundamental, as it's the newtype deconstructor
08:17:13 <lambdabot> forall a. Cont a a -> a
08:18:14 <quicksilver> yrlnry: I think it's just slightly more common to read "a < b" as an arrow from a to b
08:18:19 <quicksilver> yrlnry: but either is obviously possible.
08:19:42 <EvilTerran> yrlnry, well, if there's exactly one incoming arrow from each object in the category, it's a terminal object
08:20:26 <yrlnry> EvilTerran:  yes, but presumably that wasn't the question.
08:20:48 <yrlnry> I also decided it wouldn't be helpful to point out that there is (strictly speaking) no such thing as an object with only incoming arrows.
08:21:02 <yrlnry> <saml> in category theory, is there a term for an object that has only incoming arrows?
08:21:31 <EvilTerran> indeed; there's always the identity arrow
08:21:34 <ray> "lol identity" isn't helpful, yes
08:21:44 <yrlnry> ray: well put
08:22:04 <quicksilver> it wasn't the question, no.
08:22:11 <quicksilver> in general terminal objects have plenty of outgoing arrows.
08:22:36 <quicksilver> indeed, the outgoing arrows of terminal objects take on a special significance in some categories.
08:22:49 <quicksilver> this question was about objects with no outgoing arrows.
08:23:10 <ray> i'd call them bottom objects,but that's subjective
08:23:48 <EvilTerran> true. it just struck me as potentially still relevant; seeing as (as we've determined) there's never any such object, slightly-tangential answers are the best we can do
08:24:26 <yrlnry> This is my problem with #math.
08:24:28 <lilac> rephrase as "an object which has no arrows to any other objects", perhaps?
08:24:36 <yrlnry> For whatever reason, they always want to say "lol identity".
08:24:41 <ray> i don't think we need to be so pedantic
08:25:05 <quicksilver> yrlnry: lol #math
08:25:19 <ray> i mean, you can say "every directed graph forms a category" even though not every directed graph has an edge from every node to itself
08:25:43 <ray> each node even
08:25:52 <quicksilver> ray: lol identity
08:26:05 <ray> exactly
08:26:07 <quicksilver> yrlnry: I can see why, now. It's more fun than I expected.
08:26:16 <quicksilver>   /topic lol identity
08:26:33 <ray> no!if you stuck it in the topic it would be redundant to actually say it
08:27:38 * quicksilver notes that directed graphs don't have composition either
08:27:38 <ray> anyway, the lesson is to always assume competence in questioners unless proven (proven, not suggested) otherwise
08:27:52 <quicksilver> the point is that *paths* in directed graphs form a category
08:28:00 <quicksilver> and since that includes zero-length paths
08:28:05 <quicksilver> we get our lulz for free.
08:28:49 <quicksilver> ray: for good help channels, it's only a little better to over-estimate the questioner than under-estimate him.
08:29:00 <nlogax>  like how you went from directed graphs forming a category to free lulz in three lines
08:29:01 <quicksilver> ray: a good answer requires an accurate assessment of the questioner's level.
08:29:03 <nlogax> +i
08:29:16 <ray> quicksilver: you're allowed to ask probing questions to determine that
08:29:20 <quicksilver> nlogax: pure math degree. I did it for the lulz.
08:29:26 <nlogax> :D
08:29:40 <quicksilver> ray: of course I am. But it saves my time, and everyone else's, if I guess correctly without asking too many questions ;)
08:29:55 <quicksilver> ray: hard though it is to believe sometimes, I am actually a busy man ;)
08:30:07 <ray> start from an assumption of competence and adjust downward as needed
08:30:10 <ray> lol
08:30:18 <endojelly> what's a hylomorphism? and should I care?
08:30:18 <ray> i'm not a busy man :(
08:30:47 <fasta> endojelly: only if your name starts with endo. /the only correct answer
08:31:06 * EvilTerran doesn't start with any assumptions; I just try to answer a question if I think it makes sense and can provide a useful answer
08:31:07 <endojelly> 8)
08:31:08 <yrlnry> endojelly:  you might want to read the bananas and lenses paper that invented them
08:31:21 <ray> hylo is cata . ana isn't it?
08:31:33 <ray> i suck at remembering
08:31:45 <EvilTerran> and otherwise go for "did you mean <potentially-related question>? if so, <answer to that one>"
08:31:47 <ziman> like factorial
08:31:49 <ziman> http://comonad.com/reader/2009/recursion-schemes/
08:31:58 <EvilTerran> well, unless i have no idea what people are talking about, in which case i stay quiet :P
08:32:04 <yrlnry> endojelly:  a catamorphism is a sort of generalization of a fold function; an anamorphism is the opposite of that, and a hylomorphism is what you get when you put them together.
08:32:39 <Berengal> hylomorphism = foldr . unfoldr
08:32:44 <Berengal> in haskell-speak
08:33:07 <endojelly> ah. so let's assume I have something which creates a list of consecutive integers. that's an anamorphism, right?
08:33:19 <fasta> > :t foldr . unfoldr
08:33:21 <lambdabot>   <no location info>: parse error on input `:'
08:33:35 <ray> :t foldr . unfoldr
08:33:37 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[a]'
08:33:37 <lambdabot>     In the second argument of `(.)', namely `unfoldr'
08:33:37 <lambdabot>     In the expression: foldr . unfoldr
08:33:43 <ray> lol
08:34:03 <endojelly> oh fuck. OH FUCK.
08:34:11 <fasta> So, I doubt that is the definition of a hylomorphism ;)
08:34:32 <endojelly> I was just about to construct an example with creating a list of integers, multiplying them together and then asking if the faculty function would be a hylomorphism
08:34:32 <mercury^> How do I construct IO () from State#?
08:34:41 <endojelly> and then I scroll down on wikipedia and read:
08:34:41 <berengal-wavy-ha> gah!
08:34:45 <endojelly> "One example of a commonly encountered hylomorphism is the canonical factorial function."
08:34:51 <EvilTerran> ?type \down base up -> foldr down base . unfoldr up
08:34:52 <lambdabot> forall a b a1. (a -> b -> b) -> b -> (a1 -> Maybe (a, a1)) -> a1 -> b
08:34:56 <endojelly> so I guess I *did* understand oO
08:35:26 <ray> yeah, you start with a number, build a list by counting down, then fold it up by multiplication
08:35:27 * beren-wavy-hand neesd to learn max-nick-lengths
08:35:59 <yrlnry> <oiahsdf> trwbw: i don't know of many non-abelian infinite groups other than the quaternions.
08:36:03 <yrlnry> *boggle*
08:36:11 <fasta> Is there any use in naming something which is a combination of two useful things?
08:36:25 <EvilTerran> > let f = foldr (*) 1 . unfoldr (\x -> do guard (x>0); return (x,x-1)) in map f [0..]
08:36:27 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
08:36:54 <fasta> I mean lookHasNoMathematicalName = (a + b) * c, for example.
08:37:02 <fasta> Why make the exception for hylo?
08:37:26 <endojelly> let me generalize that!
08:37:27 <EvilTerran> i think it may've something to do with being able to eliminate the intermediate structure
08:37:30 <endojelly> don't say anything
08:37:30 <beren-wavy-hand> fasta, that's called a factorization
08:37:57 <fasta> beren-wavy-hand: no, changing a term to do that is.
08:38:20 <beren-wavy-hand> fasta, that's nouning verbs
08:38:22 <EvilTerran> which you can't do in general with just anas and catas
08:38:25 <quicksilver> mercury^: you just stick an IO constructor in front.
08:38:42 <quicksilver> mercury^: but I fear you may be indulging in deep evil.
08:38:44 <endojelly> :t unfoldr
08:38:45 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:38:50 <quicksilver> mercury^: Yellow dwarf's soul is in danger.
08:39:42 <Axman6> mercury^: the State# part of IO is an implementation detail, and probably shouldn't be played with
08:40:01 <endojelly> hm, no, that's too straigthforward anyway.
08:40:12 <endojelly> h s f g p = foldr f s . unfoldr ...
08:40:34 <fasta> Berengal: what do  you mean?
08:40:38 <mercury^> quicksilver: I want to construct something of type RawBuffer -> Int -> Word8 -> IO () from writeWord8Array#.
08:41:04 <Berengal> fasta, "changing a term to do that" is factorizing, not a factorization
08:41:23 <fasta> Berengal: according to wikipedia it must be a decomposition. But in this case, there is no decomposition, just a scalar.
08:41:24 <darq> Hello i'm really really new to haskell and i was doing some benchmarking i know that the c version (of some stupid example) would be faster but not that much .. i didnt think that the java version would be too faster so much... so if anyone got time and could give some advice in haskell.... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8587#a8587
08:41:33 <mercury^> Having the correct imports would be a great start I think. At the moment I'm missing primitive Tuples and the constructor for Word8 from Word#.
08:41:43 <endojelly> so what else is there? endomorphisms, anamorphisms, catamorphisms, hylomorphisms...?
08:41:46 <fasta> Berengal: http://en.wikipedia.org/wiki/Factorization
08:42:26 <leimy> So I'm needing to do some stuff with "expect like" behaviors, but I have a lot of parsing to do behind that code.  I'm thinking I want to write a program in Haskell using Parsec and perhaps even a little DSL to do the interaction with a device that speaks serial.
08:42:32 <Axman6> darq: interesting functions :)
08:42:36 <fasta> Berengal: this is just a composite number.
08:42:47 <Berengal> fasta, there's your name then
08:42:49 <fasta> Berengal: assuming integers.
08:43:06 <fasta> Berengal: then id would also be called composite.
08:43:24 <Berengal> fasta, we can have more than one name for something
08:43:48 <EvilTerran> darq, have you compiled with optimisations (ghc -O2) ?
08:43:49 <Axman6> darq: first thing you'll want to do though is rewrite that factorial function to be tail recursive: factorial n = factorial' n 1 where factorial ' 1 x = x; factorial' n x = factorial' (n-1) (n*x)
08:43:53 <fasta> Berengal: unless you come up with a real mathematical name for the operation f a b c = (a+b)*c, I don't think hylo deserves a name.
08:43:56 <darq> Axman6: :D i know :) the code is to slow the C version runs in 0.343s and the haskell version in 9.824s both with optimisations
08:44:01 <quicksilver> mercury^: I don't think you need to mess with State# just to mess with the underlying bytearray types.
08:44:07 <EvilTerran> fasta, i really don't follow your reasoning
08:44:17 <Axman6> darq: because you haven't written it to be fast ;)
08:44:17 <darq> C version with -O3 and th haskell -O2
08:44:34 <fasta> EvilTerran: the reasoning is that hylo is a trivial combination of two things, so, is this.
08:44:41 <EvilTerran> fasta, <EvilTerran> i think it may've something to do with being able to eliminate the intermediate structure <EvilTerran> which you can't do in general with just anas and catas
08:45:00 <mercury^> quicksilver: Well, in Handle.hs, they define a writeCharIntoBuffer, which is the same thing I want to have for Chars, and they mess with State# there.
08:45:01 <fasta> EvilTerran: how sure are you of that?
08:45:59 <fasta> EvilTerran: I would like to see proof of that first, since at first sight, it seems absurd.
08:46:13 <etpace_> How would I fold though a list like [a,b,c] and generate the computation f <$> a <*> b <*> c, foldl (<*>) (f <$>) wont seem to cut it
08:46:40 <Berengal> etpace_, you can't do that in general
08:46:47 <etpace_> hmm
08:46:48 <Berengal> etpace_, you have to decompose the list
08:47:03 <Axman6> darq: i found this post by dons to be excellent in finding out how to produce fast haskell code: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
08:47:21 <Berengal> etpace_, which makes sense, because lists can have variable length, but functions don't take variable arguments
08:47:36 <etpace_> indeed it does
08:47:47 * Axman6 goes to bed
08:47:50 <Axman6> night all
08:47:53 <darq> thnx
08:49:27 <mercury^> Does anyone know what I need to import to be able to use (# #)?
08:49:41 <hackagebot> gitit 0.6.1 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
08:49:49 <Axman6> -XMagicHash
08:49:57 <Axman6> don't do it though
08:49:58 <Lemmih> mercury^: And -XUnboxedTuples
08:50:07 <Lemmih> Yes, and don't do it.
08:50:52 <mercury^> Lemmih: well, if you can tell me how else I can create a writeCharIntoBuffer equivalent for Word8, I'm happy to use that.
08:50:54 <lilac> etpace_: you can do that with typeclass hackery
08:51:31 <harlekin> > (0,0) `(+) *** (+)` (1,1)
08:51:32 <lambdabot>   <no location info>: parse error on input `('
08:51:36 <doublethink_work> unboxed tuples can be used, but they're extra special in terms of magic because they put results in registers
08:51:40 <Lemmih> mercury^: Change the Word8 to a Char?
08:51:45 <harlekin> > ((+) *** (+)) $ (0,0) (1,1)
08:51:46 <lambdabot>   Couldn't match expected type `t -> (b, b')'
08:51:56 <harlekin> @ty ((+) *** (+))
08:51:57 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
08:52:18 <harlekin> @ty ((+) *** (+) $ (0,0))
08:52:19 <lambdabot> forall b b'. (Num b, Num b') => (b -> b, b' -> b')
08:52:30 <mercury^> Lemmih: the whole idea behind this is to be faster than Standard Library IO.
08:52:48 <lilac> etpace_: but it's a runtime error if the list is not the same length as the number of arguments of 'f' and you need overlapping instances
08:53:24 <EvilTerran> ?type let ana f = In . fmap (ana f) . f in ana
08:53:26 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
08:53:29 <EvilTerran> ?type let cata f = f . fmap (cata f) . out in cata
08:53:31 <lambdabot> forall (f :: * -> *) c. (Functor f) => (f c -> c) -> Mu f -> c
08:53:32 <Berengal> lilac, you also need existentials
08:54:11 <quicksilver> mercury^: do you have reason to believe the standard library IO is slow?
08:54:13 <EvilTerran> ... do those look like correct definitions of anamorphism and catamorphism?
08:54:17 <Lemmih> mercury^: Perhaps you could use ByteStrings?
08:54:20 <quicksilver> mercury^: it's actually one of the components which beats C most often ;)
08:54:39 <quicksilver> (as long as you manage to bypass Char/[Char] unpacking costs)
08:54:41 <mercury^> Lemmih: I have, and I think I can be faster than that.
08:55:02 * EvilTerran would try them out, but that'd involve lots of faff with newtypes and Functor instances thereof
08:55:14 <Lemmih> mercury^: Well, the best of luck to you.
08:55:15 <lilac> Berengal: i don't think you do, i'm working on a proof-of-concept
08:55:17 <fasta> EvilTerran: who claims that hylo based code can run faster than combinations of foldr and unfoldr?
08:55:21 <mercury^> Lemmih: thanks.
08:55:24 <EvilTerran> fasta, I don't recall
08:55:32 <Berengal> lilac, you don't for functions, but I think you do for functors
08:55:54 <Berengal> s/functors/applicatives/
08:56:00 <Berengal> (still true for functors)
08:56:20 <fasta> EvilTerran: have you thought about it? Since, do you really think that computing hylo from foldr .. unfoldr in some source tree is incomputable?
08:56:29 <EvilTerran> fasta, although i note the bananas/lenses/etc paper says "a hylomorphism corresponds to the composition of an anamorphism ... and a catamorphism"
08:57:09 <mercury^> Lemmih: do you happen to know the constructor for Word8 from Word# and where I find it?
08:57:26 <quicksilver> I suspect Word# is 32-or-64 bit depending on your CPU
08:57:31 <quicksilver> whereas Word8 is 8 bit
08:57:40 <quicksilver> but I'm not familiar with the internals.
08:57:49 <quicksilver> mercury^: I suggest you get a copy of the GHC source tree and grep.
08:57:59 <EvilTerran> (http://citeseer.ist.psu.edu/cachedpage/214108/5)
08:58:04 <Lemmih> mercury^: GHCi can tell you.
08:58:15 <mercury^> Lemmih: cool. What's the command?
08:58:36 <Lemmih> mercury^: :i Word8
08:58:56 <mercury^> Lemmih: thanks a lot!
09:02:12 <EvilTerran> fasta, that link (and a little on the previous page) describes a hylomorphism on lists with no mention of the list constructors
09:02:43 <etpace_> > ((.) ((++) . pure)) $ 1 $ ((++) . pure) $ 2 $ []
09:02:45 <lambdabot>   No instance for (GHC.Num.Num ([a] -> b))
09:02:45 <lambdabot>    arising from the literal `2' at...
09:03:24 <etpace_> > ((.) ((mappend) . pure)) $ 1 $ ((mappend) . pure) $ 2 $ []
09:03:26 <lambdabot>   No instance for (Data.Monoid.Monoid (f b))
09:03:26 <lambdabot>    arising from a use of `Data.M...
09:03:48 <etpace_> any tips? i'd like it to build [1] ++ [2] ++ []
09:03:57 <fasta> EvilTerran: that still doesn't mean that it deserves its own name, but well, opinions differ.
09:04:36 <fasta> In the Forth world it is an anti-pattern :P
09:04:45 <jfoutz> darq: not recalculating factorial every time will help a lot.
09:04:46 <ray> etpace_: you really want to be building 1:2:[]
09:04:49 <jfoutz> >               http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8587#a8587
09:04:50 <lambdabot>   <no location info>: parse error on input `='
09:04:54 <jfoutz> grr.
09:04:56 <etpace_> hmm probably
09:05:07 <fasta> E.g. OPEN LEFT DOOR is better than OPEN_LEFT_DOOR, because of the combinatorial explosion of names.
09:05:08 <jfoutz> > filter (\(_,x) -> and(map ((0==).(x`mod`)) [7,5,23,29]))  (let fact = 1 : (zipWith (*) [1..] fact) in zip fact [1..10000])
09:05:09 <lambdabot>   []
09:05:16 <ray> this was in edwardk's slides i think
09:05:47 <EvilTerran> ?type let refold cons nil uncons = go where go x = case uncons x of Just (y,x') -> y `cons` go x'; Nothing -> nil in refold -- list hylomorphism with no (:)s or []s
09:05:48 <lambdabot> forall t t1 t2. (t -> t1 -> t1) -> t1 -> (t2 -> Maybe (t, t2)) -> t2 -> t1
09:05:59 <etpace_> I dont think i can use : as 1: isnt a function?
09:06:09 <ray> (1:) is
09:06:10 <jfoutz> > filter (\(_,x) -> and(map ((0==).(x`mod`)) [7,5,23,29]))  (let fact = 1 : (zipWith (*) [1..] fact) in zip fact [1..10000000])
09:06:12 <lambdabot>   [(1248540552963449331639187335894060280520081838383319699731444071112783005...
09:06:21 <etpace_> oh, ok, thanls
09:06:23 <etpace_> ks
09:06:26 <ray> > fix (1:)
09:06:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:06:43 <etpace_> :t (1:)
09:06:44 <lambdabot> forall t. (Num t) => [t] -> [t]
09:06:51 <ray> and of course
09:06:53 <ray> > fix ((0:) . scanl (+) 1)
09:06:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:07:08 <etpace_> *whoosh*
09:07:43 <deech> Hi all, is there someway to determine if a string is a number before calling 'read'?
09:07:47 <etpace_> > (.) (1:) (2:) $ []
09:07:49 <lambdabot>   [1,2]
09:07:58 <quicksilver> > all isDigit "1234"
09:07:59 <lambdabot>   True
09:08:10 <lilac> suppose i have "instance Foo (a -> b) a b" and i need "Foo (a -> a) a Int", why won't GHC pick my instance? (it says "No instance for (Foo (a -> a) a Int)")
09:08:17 <deech> quicksilver: thanks!
09:08:18 <quicksilver> deech: like that, perhaps. Although you might just call "reads" and handle the empyt list result.
09:08:29 <deech> @t reads
09:08:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:08:38 <deech> @type reads
09:08:39 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:09:05 <quicksilver> lilac: you have Foo (Int -> Int) Int Int
09:09:14 <quicksilver> lilac: you have Foo (a -> Int) a Int
09:09:22 <quicksilver> lilac: but you do not have Foo (a -> a) a Int.
09:10:10 <ksf> I want to fork a thread, and fork another thread, and pass both thread's id to the resp. other thread.
09:10:27 <ksf> can I do that without resorting to MVars?
09:10:28 <quicksilver> ksf: myThreadId
09:10:46 <quicksilver> child can get parent's ID if the parent calls myThreadId
09:10:49 <ksf> nah, they are supposed to know each other, not only themselves.
09:10:54 <quicksilver> parent can get childs cos that's what forkIO returns.
09:11:02 <ksf> well they're siblings.
09:11:27 <quicksilver> siblings you need mdo ;)
09:11:34 <lilac> quicksilver: so the problem is that it doesn't know what 'a' is?
09:11:39 <quicksilver> (or mvars or iorefs or IVars)
09:11:49 <CalJohn> I have a multi-equation function, and I would like a where clause to extend over at least two clauses.  Is there some way to do that, or should I use a toplevel definition?
09:11:58 <quicksilver> lilac: the problem is that the instance you have does not unify with the one GHC is looking for ;)
09:12:29 <ksf> @faq Can Haskell extensions save me from using TVars?
09:12:29 <lambdabot> The answer is: Yes! Haskell can do that.
09:12:34 <quicksilver> lilac: the one GHC is looking has the first parameter being an endofunction on free 'a', and the third parameter being Int
09:13:00 <quicksilver> lilac: the instance you gave requires the result of the function that is the first parameter (b) to match the third parameter.
09:13:31 <lilac> quicksilver: oh, i see, it's because picking a type-class /instance/ isn't allowed to restrict the type of the thing using the typeclass
09:13:55 <quicksilver> that is certainly true.
09:14:07 <quicksilver> if that's the key insight you need to see why it doesn't work, then good :)
09:14:09 <lilac> put another way, my instance is not general enough to cover what ghc wants. which is why adding type annotations makes it work
09:14:18 <quicksilver> right.
09:14:24 <quicksilver> general code wants general instances
09:14:37 <lilac> and ghc doesn't know that i don't want general code :)
09:14:39 <quicksilver> if you annotate the code -- make it more specific -- you may bring it into the range of some specific instances instead.
09:14:48 <quicksilver> ghc infers the most general type
09:15:00 <quicksilver> and then looks for instances that satisfy those (most general) constraints.
09:15:07 <lilac> i wonder if i can fix this with an extra fundep ;)
09:15:08 <quicksilver> it never backtracks to try a more specific type.
09:15:25 <Berengal> lilac, use type families!
09:15:42 <Berengal> fundeps are ugly. Classes shouldn't take parameters they don't depend on
09:15:50 <lilac> Berengal: the code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8591#a8591 -- add type families if you like ;-)
09:16:14 <Berengal> lilac, well, there aren't any fundeps to translate
09:16:29 <lilac> my previous formulation (using incoherent instances) i don't think can be done with type families
09:16:49 <lilac> or at least, i'm not aware of any way to write incoherent type family instances
09:16:54 <Berengal> Am I wrong in thinking that fundeps is a subset of type families?
09:16:59 <ski> (Berengal : what about `class C a b | a -> b , b -> a' ?)
09:17:10 <lilac> Berengal: most people seem to claim they're equivalent
09:17:36 <quicksilver> lilac: it's against my religion to read code which uses OverlappingInstances
09:17:38 <Berengal> ski, wouldn't that be a data family?
09:17:50 <quicksilver> lilac: with OverlappingInstances enabled, ghc is no better than php.
09:17:53 <quicksilver> ;)
09:18:41 <ski> Berengal : how do you express the two FDs simultaneously with type/data families ?
09:18:48 <lilac> quicksilver: that sounds quite ... extreme :)
09:19:01 <ksf> do I really have to read the mdo-paper, as the ghc manual suggests, or is my usage simple enough not to?
09:19:02 <etpace_> hmmm fmap wants a type (a -> b) -> Tree a -> Tree b, but i want to do: (a -> (a -> [a])) -> Tree a -> Tree (a -> [a]), which seems fine, but ghci has a problem?
09:19:09 <darq> any suggestions hot to make that function faster :   sub3 n = if n > 12 then sub3 (n - 3) else n
09:19:20 <vav> CalJohn: I usually use a helper function for the multi def, so it and other bits can be in a single where, but I'm not skilled, may be better way. like http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=3419#a3419
09:19:20 <Berengal> ski, class C a where data B a :: *
09:19:30 <etpace_> Couldn't match expected type [a] against inferred type a2 -> [a1]
09:19:42 <ski> Berengal : that expresses `a -> b', yes. what about the `b -> a' FD, then ?
09:19:43 <Berengal> ski, since data families aren't injective, | B a -> a
09:19:48 <Alpounet> Hi. I get this error while trying to build a minimal documentation using haddock : Can't find package.conf as ./inplace-datadir/package.conf -- any clue ?
09:19:49 <lilac> quicksilver: they lose the property that removing some declarations from a program either makes it fail to compile, or results in an equivalent program
09:19:52 <etpace_> :t (\x -> ((x:) . ))
09:19:53 <lambdabot> forall a a1. a -> (a1 -> [a]) -> a1 -> [a]
09:19:58 <Berengal> are*
09:20:04 <lilac> quicksilver: but i vaguely recall a case where the monomorphism restriction has that effect too
09:20:27 * lilac ponders
09:20:44 <etpace_> How can I change that a1 into an a?
09:20:55 <lilac> overlapping instances plus different instances visible in different scopes could be problematic :-/
09:21:11 <Berengal> etpace_, add a type signature
09:21:15 <ski> Berengal : so it's impossible to do `instance C Int where B Int = String; instance C Bool where B Bool = String' ?
09:21:30 <etpace_> :t (\x -> ((x:) . )) :: x :: Int
09:21:33 <lambdabot> parse error on input `::'
09:21:33 <Berengal> ski, yes
09:21:47 <Berengal> ski, because it's a data family, you have to declare a new datatype, not just a type synonym
09:21:48 <etpace_> :t (\x -> ((x:) . ))  x :: Int
09:21:51 <lambdabot>     Couldn't match expected type `Int'
09:21:51 <lambdabot>            against inferred type `(a -> [a1]) -> a -> [a1]'
09:21:51 <lambdabot>     In the expression: ((x :) .)
09:22:02 <ski> Berengal : oh, right. ok
09:22:14 <harlekin> @hoogle a -> [a]
09:22:14 <lambdabot> Prelude repeat :: a -> [a]
09:22:14 <lambdabot> Data.List repeat :: a -> [a]
09:22:14 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
09:22:26 <CalJohn> vav: oh, good idea.  I decided to go and research using pattern guards, which are probably what I really want anyway
09:22:26 <Berengal> ski, with simple type families, B a ~ B b might be true, but not with data families, since it's two different type declarations
09:22:39 <ski> etpace_ : why do you want to change it ?
09:23:00 <harlekin> @hoogle Int -> [a] -> [[a]]
09:23:00 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
09:23:00 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:23:00 <lambdabot> Prelude take :: Int -> [a] -> [a]
09:23:08 <CalJohn> Speaking of which, which should the pragma look like for pattern guards?
09:23:26 <Berengal> CalJohn, PatternGuards
09:23:26 <CalJohn> {-# LANGAUGE PatternGuards #-} does not seem to work
09:23:29 <Berengal> No?
09:23:51 <CalJohn> ghci complains about not recognising it
09:24:05 <Berengal> CalJohn, just remove the pragma. GHC understands it and compiles anyway, but you'll get a warning
09:24:05 <Berengal> telling you which one to use
09:25:03 <etpace_> hmm
09:26:04 <quicksilver> lilac: it's worse than that.
09:26:06 <ski> etpace_ : i think you need to give more context
09:26:19 <quicksilver> lilac: bringing another module into scope can change the behaviour of code entirely.
09:26:20 <etpace_> sure, ill put a snippet shortly
09:26:23 <ray> if you spelled it LANGAUGE and not LANGUAGE, that would be why
09:26:29 <quicksilver> lilac: you lose 'compositionality of modules' in a nasty way.
09:26:35 <ski> etpace_ : do you want to combine two `Tree a's with `a -> a -> [a]' into a `Tree [a]' ?
09:26:53 <quicksilver> lilac: so, module A can compile correctly in either the presence or absence of module B, but with different semantics.
09:27:14 <etpace_> I'm not really sure, ive confused myself, hang on!
09:27:19 <quicksilver> lilac: similarly, code copy-pasted from A to some other place (which, for example, differs in its visibility of other modules) can have different semantics.
09:27:41 <lilac> quicksilver: that's what i meant by my first comment. i agree, it's nasty
09:28:05 <ski> @type \(a,b) -> elem (a,b)
09:28:06 <lambdabot> forall t t1. (Eq t, Eq t1) => (t, t1) -> [(t, t1)] -> Bool
09:28:56 <lilac> overlapping instances breaks the "instances are global, but it's a compile error if you forget to make them visible" property
09:30:09 <etpace_> > ((.) (1:)) $ (\x -> [x]) $ 2
09:30:11 <lambdabot>   Couldn't match expected type `a -> [t]'
09:30:12 <lilac> is this worse than having multiple instances with the same instance head in modules which don't import each other?
09:30:15 * Berengal ponders if instance synonyms would be a good idea...
09:30:31 * Berengal thinks not
09:30:38 <etpace_> Whats wrong with that?
09:30:47 <Berengal> Dumb idea. Let's just have proper context synonyms
09:31:03 <ski> > ((.) (1:)) (\x -> [x]) 2
09:31:05 <lambdabot>   [1,2]
09:31:07 <quicksilver> lilac: that's illegal haskell.
09:31:25 <quicksilver> lilac: (it's illegal for those modules to ever appear in one complete program, even if they never import each other)
09:31:26 <etpace_> hmm
09:31:40 <quicksilver> lilac: it's a known GHC bug that it doesn't report such errors unless it happens to spot the conflict.
09:32:01 <quicksilver> Berengal: context synonyms would be nice.
09:32:03 <ski> `$' happens to be right-associative (it might make sense to have it left-associative instead)
09:32:13 <lilac> quicksilver: it seems sane to me that it should be illegal to use a class with overlapping instances with not all instances visible
09:32:29 <Berengal> quicksilver, arguably, a complete program consists only of the parts of modules it actually uses, so if there's no conflict, there's no instance either
09:32:51 <lilac> quicksilver: or to say, if making more instances visible could change the chosen instance, the program is ill-formed
09:33:00 <quicksilver> Berengal: right, but you can easily have a program which has two disparate parts which use different instances in ways which never connect
09:33:10 <quicksilver> Berengal: GHC will compile such code, but it is not legal haskell.
09:33:13 <quicksilver> Berengal: it is a bug in GHC.
09:33:37 <Berengal> quicksilver, how can it choose from two different instances if they've both got the same head?
09:33:49 <Berengal> import voodoo?
09:33:51 <quicksilver> Berengal: different parts of the program have different ones in scope.
09:33:59 <ski> CalJohn : unfortunately not
09:34:01 <Berengal> Ah, that is a bug
09:34:04 <quicksilver> right.
09:34:22 <ski> (CalJohn : in SML there is `local ... in ... end' for this)
09:35:06 <ski> CalJohn : maybe using a `case' would be ok, in your case ?
09:36:21 <Alpounet> Hi. I get this error while trying to build a minimal documentation using haddock : Can't find package.conf as ./inplace-datadir/package.conf -- any clue ?
09:37:12 <ski> @type let f (a,bc) | Left b <- bc = Left (a,b) | Right c <- bc = Right (a,c) in f
09:37:13 <lambdabot> forall t t1 t2. (t, Either t1 t2) -> Either (t, t1) (t, t2)
09:39:37 <jpcooper> @pl pathInfo >>= ($ state) . fun
09:39:38 <lambdabot> flip fun state =<< pathInfo
09:39:47 <jpcooper> yeah yeah I knew that
09:39:53 <copumpkin> ski: that reminds me of strength
09:40:36 * ski just noticed that was a strange way of "`case'ing"
09:40:37 <jpcooper> I didn't know that (a -> (b -> c)) could be flipped as (a -> b -> c) could
09:40:47 <copumpkin> jpcooper: they're the same thing
09:40:59 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8594#a8594 -- listToTree doesnt really match my function decleration until the very end so ghci doesnt like it, any tips?
09:40:59 <jpcooper> evidently so
09:41:01 <copumpkin> a -> b -> c -> d === a -> (b -> (c -> d))
09:41:13 <jpcooper> right
09:41:24 <CalJohn> ski: pattern guards worked fine for me :)
09:41:26 <jpcooper> I am now connecting this with the fact that Haskell is curried
09:41:36 <Berengal> ski, better than case () of () |
09:41:59 <ski> Berengal : i've used that, at times :)
09:42:35 <Berengal> ski, I found out about the let way when I first needed it and thought there had to be a better way
09:43:02 <Makoryu> Berengal: I used that yesterday, and then changed it to a function and a list of tuples :\
09:43:33 <ski> Berengal : the correct solution here would of course be to introduce something like SMLs `local'
09:43:36 <etpace_> the <*> are supposed to build up a tree of ([a] -> [a]) and at the end the [x] is finally given, so the types dont really work until t:[], so I guess my approach is incorrect?
09:44:23 <Berengal> I like wheres too. 'where Left err = foo; Right val = foo'
09:46:00 <ski> (`... where ~(Left err) @ ~(Right val) = foo' ?)
09:46:27 <yrlnry> What's the magic GHC incantation that tells it to allow  instance Functor (Term a)      when Term has kind * -> * -> * ?
09:46:42 <Berengal> ski, that is dangerously close to magic
09:46:57 <ray> ski: i'm scared
09:47:07 <Makoryu> ski: We conjure the spirits of the computer with our spells...
09:47:18 <ski> yrlnry : i don't see why that should be allowed
09:47:21 <Berengal> Almost looks like perl in a way...
09:47:44 <ski> Berengal,ray,(Makoryu) : why ?
09:47:59 <ray> irrefutable Left and Right together mainly
09:48:17 <Berengal> ski, I just think it's less clear, but it's subjective opinion
09:48:23 <ski> yrlnry : sorry, i misread. that should be ok, i think
09:48:35 <Berengal> ray, same goes for my separate definitions
09:48:47 <ray> i didn't see yours
09:49:04 <ski> Berengal : they should be the same, yes. matter of taste
09:50:37 <yrlnry> ski:      `Term a' is not applied to enough type arguments
09:50:37 <yrlnry>     Expected kind `*', but `Term a' has kind `* -> *'
09:51:11 <yrlnry> And as I recall last time this happened I asked about it here and someone said, oh you need to enable -fPartialTypeConstructorApplicationsInInstanceDeclarations
09:51:12 <Berengal> > let foo bar@baz = (bar, baz) in foo 5
09:51:14 <lambdabot>   (5,5)
09:51:32 <yrlnry> But I can't recognize the magic incantation from the list in the GHC user docs.
09:51:38 <ski> yrlnry : oh, `Term a b' is a type-synonym ?
09:52:57 <yrlnry> No, it's a data type.
09:53:58 <Berengal> yrlnry, works just fine for me
09:54:20 <path[l]> guys if I have f = f a b c and b is a computation with a lot of data. How can I force b to evaluate before f calls itself?
09:54:27 * EvilTerran notes, in the style of "ana f = In . fmap (ana f) . f; cata f = f . fmap (cata f) . out", we also have "hylo dn up = dn . fmap (hylo dn up) . up"
09:54:29 <yrlnry> Okay, I'll try to work up a simple example.  Thanks.
09:54:39 <EvilTerran> also, hooray for standalone deriving
09:54:45 <yrlnry> path: f a b c = b `seq` f a b c
09:54:53 <path[l]> oh b appears twice?
09:54:55 <path[l]> as a term
09:55:12 <EvilTerran> "newtype Mu f = In (f (Mu f)) deriving Show" doesn't work. "deriving instance Show (f (Mu f)) => Show (Mu f)", however, does! :)
09:55:20 <ski> etpace_ : remove the middle equation, and replace `(\x -> ((.) (x:)))' with `(:)' (which is the same as `(\x -> (x:))')
09:55:30 <Berengal> path[l], {-# LANGUAGE BangPatterns #-} f a !b c = f a b c
09:56:12 <Berengal> EvilTerran, does it show?
09:56:15 <etpace_> hmm
09:56:21 <EvilTerran> (well, with -XUndecidableInstances, too)
09:56:28 <EvilTerran> Berengal, yep
09:56:48 <ski> (etpace_ : `listToTree t1' was a type error, as well as `fmap (\x -> ((.) (x:))) t <*> ...')
09:57:19 <etpace_> Yeah I solved it by splitting it into two functions, which isnt the best approach
09:57:28 <path[l]> berengal can you explain what that does please :)
09:57:32 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8594#a8596 (in the revision)
09:57:47 <EvilTerran> *Main> iterate (In . Just) (In Nothing) !! 3
09:57:48 <EvilTerran> In (Just (In (Just (In (Just (In Nothing))))))
09:57:50 <EvilTerran> Berengal, ^
09:58:06 <ski> etpace_ : argh, no `last' needed
09:58:41 <ski> etpace_ : your original approach was all right, you only had a few type errors in the details
10:00:16 <etpace_> hmm
10:00:45 <EvilTerran> Berengal, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8599 is the file i've been playing with, if you're interested
10:01:09 <ski>   Tree a  >->  Tree [a]
10:01:13 <yrlnry> I did ":set -XFlexibleInstances" in GHCI, but I'm still getting an error that includes "Use -XFlexibleInstances if you want to disable this."   Did I screw up the :set somehow?
10:01:41 <ski>   (Tree a,[Tree a])  >->  (Tree ([a] -> [a]),Tree [a])  >-> Tree [a]
10:01:49 <etpace_> aha, vhanging it to (:) and cleaning up the rest sems to have done the trick
10:01:51 <etpace_> what's
10:01:56 <ski> those are the two cases
10:01:59 <etpace_>  `>->'
10:02:07 <ski> "maps-to"
10:02:30 * EvilTerran notes he could re-write "up" as "up x = if x > 0 then x `cons` (x-1) else nil"
10:02:35 <ski> (or s/to/into/, i suppose)
10:02:39 <etpace_> listToTree (t:[]) = fmap (\x -> [x]) t
10:02:41 <etpace_> listToTree (t:ts) = fmap (:) t <*> listToTree ts
10:02:47 <etpace_> seems to do the trick
10:02:59 <ski> `(\x -> [x])' could be written `(:[])'
10:03:03 <EvilTerran> etpace_, what about listToTree [] ?
10:03:11 <ski> EvilTerran : not defined
10:03:11 <etpace_> hmm
10:03:13 <EvilTerran> ah
10:03:36 <ski> (all trees are assumed to have the same shape, and there must be at least one tree)
10:03:42 <yrlnry> Heh.  GHC defines a show instance for (a, ..., o) but not (a, ..., p).
10:04:44 <ski> (someone mentioned almost the exact same thing the other day ..)
10:04:44 * EvilTerran got a chuckle out of writing "O Nothing" repeatedly in his code there :)
10:05:09 <etpace_> thanks ski
10:05:15 <ski> np
10:05:22 * EvilTerran wanders off
10:05:31 <etpace_> (:) made it a lot easier to digest as well
10:05:42 <Twey> Hehehe
10:05:46 <glguy> /topic
10:05:48 <glguy> :-/
10:05:54 <Twey> Heh
10:06:05 <hackagebot> Hieroglyph 3.89 - Purely functional 2D graphics for visualization. (JeffersonHeard)
10:07:23 <quicksilver> ski: ~(Left a) @ ~(Right b) is not legal, btw - probably you knew that
10:07:30 <ski> yes
10:07:41 <quicksilver> ski: it's not <pat> @ <pat>, it's <name> @ <pat>
10:07:46 <path[l]> if I do b `seq` f a b c, does it not evaluate the second b again because it already did the first time?
10:07:46 <ski> this was yet another argument why it should be legal :)
10:07:50 <quicksilver> right.
10:08:12 <quicksilver> true views are another reason you want it
10:08:12 <path[l]> how complex can the expression for b be?
10:08:27 <ski> quicksilver : *nod*
10:08:27 <quicksilver> but -XPatternGuards is some way short of true views
10:08:38 <quicksilver> path[l]: arbitrarily complex.
10:08:50 <ski> path[l] : it should be a variable if you want a sharing guarantee
10:08:55 <quicksilver> path[l]: (actually that's not quite what seq means but you're close enough for what you want)
10:09:00 <path[l]> hmm
10:09:08 <path[l]> so I could push it into a where clause
10:09:12 <quicksilver> ah, yes it has to literally be the name same
10:09:17 <path[l]> ok
10:09:52 <quicksilver> ski: (h <: tl) @ (lt :> y) ftw ;)
10:10:03 * ski grins
10:10:14 <yrlnry> Berengal:, ski: It works just fine for me too.  Thanks.
10:10:27 <ski> yw
10:10:37 <quicksilver> but, to  be honest, I suspect true views are another layer which make it even hard to reason about time/space usage.
10:10:49 <quicksilver> constructors are one of the few anchor points in haskell.
10:13:12 <path[l]> oh can I also do a `seq` b `seq` f a b c ?
10:13:41 <ski> @src $!
10:13:42 <lambdabot> f $! x = x `seq` f x
10:14:12 <ski>   ((f $! a) $! b) c
10:14:32 <ski> (`$!' ought to associate in the other way ..)
10:15:33 <path[l]> hmm somehow I had trouble with $!, but eitherway looks like I was wrong. The thunks werent the source of my troubles :/
10:22:10 <yrlnry> If Term has kind *->*->*, I can instance Functor (Term a); is there a way to instance Functor (flip Term a)?
10:22:43 <ski>   newtype Flip f b a = MkFlip (f a b)
10:23:46 <yrlnry> Hmm.  I'm not sure what I actually wanted.
10:23:49 <Cale_> yrlnry: Not really.
10:23:59 <Cale_> (It's not really possible)
10:24:28 <Cale> This is why it's important to consider the order of the parameters to type constructors very carefully.
10:24:34 <yrlnry> understood, thanks.
10:25:01 * roconnor tries to find an order to make (->) a functor and a cofunctor
10:26:10 <ski> s/cofunctor/contravariant functor/
10:26:52 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Contra.html
10:27:05 <copumpkin> that already has a flipped -> contrafunctor instance through a newtype
10:27:55 <path[l]> well I can try one more thing. After that Ill need expert help :/
10:30:36 <yrlnry> Hee hee.  I got confused writing a term unifier for my complicated expression type, so I wrote a unifier for a simpler, more uniform type, and a converter to convert the complicated type to the uniform type and then convert the results back.
10:31:20 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8601#a8601 whats a better treeToList? pref one that doesnt use a helper function
10:32:56 <path[l]> :t fromList [(1,2)]
10:32:58 <lambdabot> Not in scope: `fromList'
10:33:05 <path[l]> huh
10:33:07 <ski> etpace_ : all element lists has the same length ?
10:33:21 <path[l]> :t Data.Map.fromList [(1,2)]
10:33:22 <lambdabot> forall t t1. (Num t, Num t1, Ord t) => M.Map t t1
10:33:44 <etpace_> I assume so ski
10:33:56 <quicksilver> you could just check if the top item is null
10:34:02 <quicksilver> instead of checking its length
10:34:09 <quicksilver> but it's not a very elegant function whatever you do
10:34:17 <quicksilver> since it will fail badly if the element lists aren't the same length
10:36:36 <ski>   treeToList t = if null (root t) then [] else fmap head : treeToList (fmap tail t)
10:36:55 <Phillemann> Hmmm, is the Prelude being completely moved to other modules? I often see two identical functions in different modules.
10:37:19 <path[l]> whats a good random access structure to use instead of List?
10:37:26 <ski> (assuming, instead of checking, that element lists are of same length)
10:37:40 <etpace_> thanks again
10:37:59 <mux> path[l]: depending on the usage pattern, you could use Seq, Set, Map, Array and others still
10:38:15 <path[l]> ah ok
10:38:22 <mux> path[l]: Array gives you O(1) random access, but is immutable
10:38:27 <arw> they are all good, for their respective purpose.
10:38:28 <Berengal> Phillemann, ideally, the Prelude should should reexport functions from other modules
10:38:29 <path[l]> ok
10:38:29 <mux> there are other mutable arrays
10:38:35 <Berengal> should just*
10:38:41 <path[l]> Array sounds good, but whats Seq
10:38:53 <Berengal> @src Seq
10:38:54 <lambdabot> Source not found. Do you think like you type?
10:38:56 <mux> Set and Map give you amortized random access
10:39:06 <mux> O(ln n)
10:39:12 <Phillemann> Hmmm, can I completely hide the Prelude then? So I can import exactly what I want and from the specific modules?
10:39:27 <Berengal> Phillemann, NoImplicitPrelude
10:39:39 <Berengal> or "import Prelude ()"
10:39:45 <Berengal> (They're a little different I think)
10:39:49 <mux> Seq is the closest to a list
10:40:14 <mux> but it's not lazy as lists, and it's implemtented using 2-3 finger trees
10:40:20 <Phillemann> Berengal: Ah, okay, thanks
10:40:28 <shepheb> import Prelude () gives you instances, I think.
10:40:59 <mux> Seq gives O(log(min(i,n-1))) random access at index i (just copy-pasted that from the docs)
10:41:02 <Berengal> import Prelude () gives you instances, and also defines the functions used in do notation, [..] etc.
10:41:19 <Phillemann> [..]?
10:41:22 <Cale> mux: Did you really copy-paste it? That's incorrect...
10:41:25 <Berengal> NoImplicitPrelude allows you to override the desugared functions for some sugar
10:41:34 <Cale> mux: It's O(log(min(i,n-i)))
10:41:46 <mux> oops, I rewrote, and badly
10:42:11 <mux> n-1 wouldn't make any sense here :)
10:44:31 <path[l]> ok Array it is
10:45:27 <hackagebot> pureMD5 1.0.0.1 - MD5 implementations that should become part of a ByteString Crypto package. (ThomasDuBuisson)
10:46:32 <Alpounet> Hi. I get this error while trying to build a minimal documentation using haddock : Can't find package.conf as ./inplace-datadir/package.conf -- any clue ?
10:46:33 <path[l]> hey whats that site that has the apis?
10:46:45 <lilac> @docs Data.Array
10:46:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
10:47:08 <mux> Cale: mmm, wouldn't it be possible to have the strictness analyzer determine that since some functions using lists are strict, it would be better to switch to Seq automagically?
10:47:40 <mux> or have a type system with strictness anotations and strictness-indexed types
10:47:56 <lilac> bad lambdabot. it's here: http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
10:50:00 <path[l]> thanks
10:51:03 <Cale> mux: Hmm... there are cases where even if the list's usage is strict, the access pattern is such that a plain list does better than Data.Sequence
10:51:09 <arw> somebody asked me something like "what is so nice about haskell?". is there some good webpage/paper/whatever that explains haskells strong points?
10:51:35 <Apocalisp> anamorphism => unfold, catamorphism => fold, hylomorphism => ?
10:51:36 <SamB_XP> @go why functional programming
10:51:38 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
10:51:38 <lambdabot> Title: Why Functional Programming Matters
10:51:54 <endojelly> Apocalisp, an unfold followed by a fold
10:51:56 <SamB_XP> ... arw: is that any good?
10:52:01 <endojelly> Apocalisp, or: folding an unfold.
10:52:11 <Cale> whyfp is a classic, but it's more useful to those who already understand at least a bit why functional programming matters
10:52:17 <endojelly> Apocalisp, factorial is a nice example.
10:52:26 <Apocalisp> "refold"?
10:52:34 <endojelly> Apocalisp, heh, why not
10:53:16 <Apocalisp> factorial = hylo (\n -> (n, n-1)) (==0) 1 (*)
10:53:26 <Apocalisp> Very nice.
10:53:33 <endojelly> yes!
10:54:02 <endojelly> if you see a pattern like fold .. [..] then it's likely to be a hylomorphism
10:54:03 <Apocalisp> Haskell's strong points right here ^^
10:54:28 <Apocalisp> OK, thanks.
10:54:40 <Apocalisp> Working my way up to understanding dynamorphism.
10:55:01 <endojelly> Apocalisp, I learned about hylomorphisms (and ana- and catamorphisms) some hours ago :D
10:55:06 <arw> SamB_XP: yes, thats great. but is there also something more haskell-specific? like "yes, functional programming is nice, but why haskell and not scheme, miranda, ..."?
10:55:13 <endojelly> Apocalisp, what are dynamorphisms? and what are you learning from?
10:55:22 <Apocalisp> endojelly: Learning from Comonad.Reader
10:55:26 <SamB_XP> arw: what's miranda again?
10:55:40 <endojelly> Apocalisp, ah, skimmed over that blog, too
10:55:41 <Makoryu> SamB_XP: Miranda is the language Haskell got most of its syntax from
10:55:50 <SamB_XP> hint: was being facetious
10:56:02 <Makoryu> Shutting up >.>
10:56:24 <arw> :)
10:56:32 <Apocalisp> Dynamorphisms are a recursion pattern where previously calculated subproblems are retained. Applies to solving dynamic programming problems in a functional style.
10:56:34 <Makoryu> arw: Haskell is easily one of the most mature platforms for functional programming right now.
10:57:09 <arw> Makoryu: _I_ know that and i like it. but i'm no writer, so i'm looking for advice how to explain that to somebody else :)
10:57:24 <SamB_XP> anyway, who wants to use the proprietary cousin of a more popular open-source system?
10:57:35 <Makoryu> arw: ¯\O_o/¯
10:57:42 <mux> it is at least definitely the most mature platform for non-strict functional programmin
10:58:11 <SamB_XP> @google why types
10:58:12 <lambdabot> http://www.allacademic.com/meta/p69752_index.html
10:58:12 <lambdabot> Title: Representing Alterity: Why Types (ideal or otherwise) Still Matter in IR Theory
10:58:16 <arw> mux: well, everything is definitely the most mature platform of its very narrowly defined niche :)
10:58:22 <SamB_XP> @google why types matter
10:58:24 <lambdabot> http://www.meta-synthesis.com/webbook/31_matter/matter.html
10:58:24 <lambdabot> Title: Types of Matter
10:58:28 <SamB_XP> no...
10:58:34 <Berengal> I wish people hadn't decided that programming isn't part of mathematics...
10:58:40 <Berengal> Or CS even
10:58:53 <SamB_XP> Berengal: hmm?
10:59:13 <Berengal> SamB_XP, I'm tired of coworkers staring dumbly at me for mentioning "cartesian product"
10:59:46 <mux> arw: weren't you somehow trying to define that very niche though? :-)
11:00:15 <grampaj0e> Math should be required for anyone who needs to do anything quickly
11:00:24 <Berengal> "That's an attribute, not a relation" "Huh?" "A simple corecursive routive should fit nicely here" "Wha?"
11:00:37 <badsheepy> if they get stuff done
11:00:42 <badsheepy> isnt that the ultimate point :p
11:00:47 <shapr1> I just realized I'd like to see a weekly hackage spotlight, where someone describes and demonstrates a hackage library that may not be well known.
11:00:56 <Nafai> Hi shapr1!
11:00:58 <shapr1> Has anyone heard of such a thing?
11:01:00 <Berengal> badsheepy, the problem is, they don't. Not if it requires math...
11:01:01 <shapr1> hiya Nafai!
11:01:06 <arw> mux: yes, in a way. but the bigger the niche, the more impressive :)
11:01:07 <Berengal> Programming frequently does
11:01:25 <badsheepy> im not convinced normal tasks require much math unless you are using haskell :p
11:01:36 <shapr1> I agree.
11:01:53 <shapr1> but require and benefit from are two different levels of programming
11:02:00 <badsheepy> oh indeed
11:02:02 <Berengal> shapr1, that'd be nice. I'd like to see something like that if anyone could contribute
11:02:17 <shapr1> Berengal: Yeah, sounds like the next iteration of The Monad.Reader
11:02:30 <shapr1> which was originally a wiki based publication, until I got bored with it.
11:02:36 <shapr1> So, what do I call this next one?
11:02:41 <hackagebot> hmpfr 0.2.1 - Haskell binding to MPFR library (AlesBizjak)
11:02:44 <shapr1> It should of course be gitit based so you can grab the repo
11:02:44 <mux> arw: I find it really hard to anser your question though; when I try to talk about Haskell to others, I usually end up thinking about a huge list of features, but the average programmer has never heard of 90% of them
11:02:46 <arw> badsheepy: normal tasks are often possible without math. but mostly, the math-less solution is not aesthetic, nice, robust or fast.
11:02:57 <Berengal> badsheepy, I'm tempted to say "maybe not require, but...", but I think that it does. Everything about programming is math, but much of it is very ad-hoc
11:03:04 <badsheepy> if you count the progreammer time taken to learn math properly
11:03:05 <arw> mux: that is exactly my problem, too.
11:03:20 <shapr1> I haven't learned math properly, that really trips me up sometimes.
11:03:21 <badsheepy> then math learners are at a net loss until they make something quite complex imo
11:03:23 <Berengal> badsheepy, one of the reasons I like haskell is because it doesn't try to reinvent mathematics.
11:03:41 <mux> arw: laziness, curried functions, referential transparency, ADTs and GADTs, type classes, list comprehensions, monads...
11:03:59 <grampaj0e> It doesn't take very long to learn math properly compared to the time you'll save throughout a career by applying it
11:04:04 <Berengal> badsheepy, I'm a math learner. Monoids have paid for themselves several times already. In addition, a mathematical mindset helps immensely in the face of complexity
11:04:10 <badsheepy> if you happen to use it in your career :)
11:04:16 <mux> arw: so I often take the problem sideways and try to explain how purity helps with concurrent programming :-)
11:04:19 <badsheepy> and anyhow, im here to learn math and haskell, i mostly agree
11:04:30 <arw> mux: listing features is not the problem. the problem is the question "but why should I care about feature X?"
11:04:32 <mux> concurrency is really a killer selling point these dyas
11:04:40 <badsheepy> but its a tradeoff, learning new things:)
11:05:38 <shapr1> arw: Yeah, I agree with mux. Multicore is now, but C#, Java, etc do not support parallelism well.
11:05:40 <Berengal> badsheepy, haskell has made me a much better programmer overall, even if I've only written ten lines of it at work
11:05:47 <mux> I also often talk about how parametric polymorphism is greaat for abstraction, and that's easily understood to most programmers (especially those who did Java Generics or C++ templates, etc)
11:05:57 <badsheepy> yes, but then you put a lot of work into learning it
11:06:00 <badsheepy> which is the tradeoff...
11:06:39 <yrlnry> How?
11:06:41 <mux> if they _have_ used C++ templates, showing them the syntax in Haskell vs C++, they /must/ be interested :-)
11:06:42 <Berengal> badsheepy, I could've put the work into learning more of java. I don't think I'd be as successful that way
11:06:50 <Makoryu> arw: The really killer feature of Haskell is the combination of its egregious VHLL-ness and GHC's very nice optimizations.
11:06:53 <badsheepy> im not sure java is all that complicated :p
11:07:00 <Berengal> Not to mention the pain to my soul...
11:07:14 <Makoryu> arw: Having either one without the other would make it only mediocre, rather than great
11:07:17 <Berengal> Java is much more complicated than haskell
11:07:26 * badsheepy dies on the spot
11:07:31 <badsheepy> thats just not true :P
11:07:46 <shapr1> java has a bunch of special cases, that makes it more complicated to me.
11:07:51 <Berengal> Haskell is very simple in constrast
11:08:10 <shapr1> Admittedly, I got paid to write Java years before I got paid to write Haskell
11:08:23 <badsheepy> tell that to the millions of java programmers who are inept but can get by
11:08:24 <Berengal> It's just a few simple principles, everything else is built on top of that
11:08:28 <badsheepy> i bet they couldnt get by in haskell :)
11:10:01 <mux> arw: of course, a little speech on safety is due too; how the very strong type system helps prevent many runtime errors
11:10:07 <Berengal> badsheepy, sure they're not just inept because they only know java?
11:11:07 <Berengal> Anyway, I don't think they would be unable to use haskell. If haskell was the most used language, there'd be plenty of inept haskellers as well. Dumb people are simply too lazy to learn than just what they need
11:11:19 <Berengal> more than*
11:11:30 <badsheepy> surely the fact haskell isnt the most used language is a testament to its difficulty
11:11:51 <mauke> non sequitur
11:11:52 <yrlnry> sometimes pointfree style wins.  Sometimes it loses.  This is the biggest lose I've ever seen:   (`ap` snd) . (. fst) . flip ((.) . (,))
11:11:52 <Vanadium> It is a testament to not being C#
11:12:04 <mauke> @unpl (`ap` snd) . (. fst) . flip ((.) . (,))
11:12:05 <lambdabot> (\ k -> (\ t h -> ((,)) (fst t) (k h)) >>= \ v -> snd >>= \ u -> return (v u))
11:12:16 <badsheepy> c# is friendly and warm :)
11:12:20 <mauke> :t (`ap` snd) . (. fst) . flip ((.) . (,))
11:12:21 <lambdabot> forall a b a1. (a1 -> b) -> (a, a1) -> (a, b)
11:12:24 <Berengal> badsheepy, I've found haskell easier than java, and I learned both rather early in my programming career
11:12:25 <yrlnry> @pl \f (a, d) -> (a, f d)
11:12:25 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
11:12:26 <badsheepy> haskell stabs you with triangles and punctuation :d
11:12:27 <badsheepy> hehe
11:12:41 <mauke> yrlnry: fmap
11:13:17 <badsheepy> perhaps im mildly indoctrinated
11:13:21 <Berengal> badsheepy, sure, haskell is also what I've had the most trouble with, because of some seriously heavy topics, but in return I can now code in circles around most java programmers I've seen
11:13:22 <yrlnry> mauke:  I was defining ((,) a) as an instance of Functor as an exercise, so using fmap would be cheating.  :)
11:13:24 <badsheepy> or perhaps you just knew more maths to begin with :)
11:13:30 <copumpkin> > strength (5, Right 5)
11:13:31 <mauke> yrlnry: second
11:13:32 <lambdabot>   Right (5,5)
11:14:30 <yrlnry>  \f (a, d) -> (a, f d)  was sufficient.  I was just amused by the catastrophe produced by @pl.
11:15:00 <Berengal> badsheepy, I barely knew calculus
11:15:01 <mauke> @pl \a b c d -> d b d c b a c d a
11:15:03 <lambdabot> flip =<< ((flip . (flip .)) .) . flip flip id . ((flip . (ap .)) .) . flip flip id . (liftM2 flip .) . flip (flip . (flip .) . (flip =<< (flip .) . flip . join . flip id))
11:15:04 <copumpkin> :t fmap
11:15:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:15:13 <copumpkin> :t strength
11:15:15 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
11:15:36 <copumpkin> > strength (5, Left 8) -- :(
11:15:37 <lambdabot>   Left 8
11:15:44 <mauke> :t fmap . (,)
11:15:45 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
11:16:36 <copumpkin> :t (|||)
11:16:37 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
11:16:42 <yrlnry> mauke: Have you seen the exercise in Barendregt that asks to prove that (L L) is a fixed point combinator, where L = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r))))))))))))))))))))))))) ?
11:16:52 <copumpkin> ugh
11:17:00 <mauke> oh god
11:17:08 <ksf> is there a howto on how to implement a thingie that implements a gtk object interface?
11:17:18 <ksf> ...if it's possible to do so in gtk2hs, anyway?
11:17:25 <jmcarthur_work> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r)))))))))))))))))))))))))
11:17:31 <copumpkin> noooooooooo
11:17:39 <mauke> yrlnry: I have now :-)
11:17:40 <jmcarthur_work> i regret it already
11:17:49 <SamB_XP> ksf: I am not aware of any way to do that that doesn't involve writing it in C ...
11:18:07 <yrlnry> SamB:  I like that as an answer to the Barendregt exercise.
11:18:18 <jmcarthur_work> @botsnack
11:18:18 <lunabot>  :)
11:18:23 <dcoutts> ksf: the only way is to have another GObject
11:18:34 <ksf> well, the point is to directly implement TreeModel instead of duplicating data into a TreeStore
11:18:35 <jmcarthur_work> lambdabot? :(
11:18:44 <dcoutts> ksf: oh you can do that, yes.
11:19:03 <dcoutts> ksf: see the existing two models implemented in Haskell
11:19:13 <ksf> oh.
11:19:39 <ksf> I assumed they were objects written in C shipped with gtk
11:20:12 <dcoutts> ksf: there's a generic C stub implemented by gtk2hs that delegates everything to a Haskell interface that you can implement
11:20:28 <copumpkin> cute: http://twofoos.org/content/java-type-system-holes/
11:20:32 <dcoutts> ksf: it's not quite as nice as you might like, it's a bit imperative
11:20:35 * ksf needs to download the source
11:20:50 <ksf> ...my whole program is mostly imperative.
11:21:01 <etpace_> Whats the best way to take a list of functions say [a,b,c] and an initial input x, and form a a (b (c x)), foldr (\x acc -> acc . x) id?
11:21:15 <dcoutts> ksf: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-ModelView-CustomStore.html
11:21:41 <mauke> foldr (.) id
11:22:02 <copumpkin> or flip (.)
11:22:10 <copumpkin> depending on how you want to compose them
11:22:43 <ezyang> 'lo all
11:22:50 <SamB_XP> arw: well, http://www.cs.nott.ac.uk/~gmh/faq.html#functional-languages seems a bit striking ...
11:22:55 <SamB_XP> I mean, just look at those examples
11:23:05 <mauke> > foldr (.) id [f, g, h] x
11:23:07 <lambdabot>   f (g (h x))
11:23:39 <SamB_XP> ... and I don't think they're even trying to sell Haskell there :-)
11:24:12 <ksf> heh. index by Word Word Word. Welcome in C land.
11:25:08 <dcoutts> ksf: yeah :-( you get 96 bits to play with
11:25:28 <SamB_XP> hmm?
11:25:39 <dcoutts> ksf: it's all passed by value in C so you cannot use things like Haskell StablePtr since it cannot be freed
11:26:07 <dcoutts> I mean, since it's passed by value in C, we do not get notified when they're discarded, so you cannot store anything that needs cleaning up
11:26:26 <ksf> that should be more than nescessary, each top-level node has about 3 or 4 children.
11:27:09 <ksf> ...the only reason I'm doing a tree, after all, is visual compactness and avoiding to pull too much data in.
11:27:24 <dcoutts> ksf: the TreeStore is more fun :-) it uses a compat bit encoding of paths in the tree
11:28:07 <therp> is there any implementation of the (untyped) lambda calculus that is meant to be used as fast compiler backend? GHC core minus types.
11:28:50 <dcoutts> therp: grin is untyped
11:29:08 <Phillemann> Is there any thorough explanation of the different -morphisms (catamorphism, anamorphism, ...)?
11:29:15 <dcoutts> therp: it's not exactly lambda calculus though
11:29:40 <therp> dcoutts: ah that reminds me of the GRIN paper in my have-to-read shelf. thanks
11:30:38 <ezyang> Phillemann: I had this page bookmarked: http://comonad.com/reader/2009/recursion-schemes/
11:30:57 <therp> unfortunately I haven't found a way to get my http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8574#a8574 `data definition desugaring' going without insulting the type system
11:31:03 <ksf> Phillemann, the meaning of the words may even change with context.
11:31:28 <ksf> that is, a category-theory isomorphism is a different kind of beast (more general) than a vanilla isomorphism.
11:31:57 <Phillemann> ksf: But we're only working in the category of Haskell types, don't we? :)
11:32:12 <ksf> In the end, I settled on learning that bit of greek required to understand the words...
11:32:26 <ksf> e.g. "cata" -> collapse, as in "catastrope".
11:32:35 <ksf> therefore, folds and stuff.
11:33:14 <Berengal> I've always though of cata as out and ana as in
11:33:30 <ksf> ana -> to build up, like in "anabolica"
11:33:37 <ksf> therefore, unfolds.
11:34:33 <Berengal> What about hylo?
11:34:34 <grampaj0e> Where can I find a gentle-ish introduction to the concept of monads? Trying to learn things recursively from Wikipedia is taking forever
11:34:56 <ezyang> grampaj0e: I did it with RWH + Typeclassopedia
11:35:01 <mauke> @quote monad.*time
11:35:23 <therp> grampaj0e: I liked http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
11:35:33 <ksf> er, hylo == wood.
11:35:51 <dino-> And All About Monads was very clear to me.
11:36:02 <grampaj0e> Alright, thanks
11:36:07 <ksf> so, obvioulsy, it has something to do with deforestation.
11:36:09 <dino-> How do you get lamby to give us the url for that?
11:36:15 <canvon> grampaj0e: this explains the underlying concepts, with runnable haskell code, but without touching haskell type classes: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
11:36:15 <mauke> as in hylophone?
11:36:16 <dino-> I always forget lambcommands
11:36:27 <ksf> or, rather, planting trees.
11:36:33 <Berengal> ksf, also, 'matter'
11:36:35 <ksf> ...and burning them afterwards.
11:37:31 <ksf> so, a hylomorphism is a combination of an anamorphism that plants trees and a catamorphism burning them again.
11:37:40 <dino-> grampaj0e: http://www.haskell.org/all_about_monads/html/index.html
11:38:05 <ksf> it's a higher-order term, anyway.
11:38:12 <Berengal> ksf, 'matter transformation' might be another translation
11:38:21 <Berengal> of hylomorphism
11:38:31 <ksf> yeah, but I like the forest metaphor.
11:38:38 <ksf> in that it's composed of ana and cata.
11:38:57 <Berengal> katanamorphism
11:42:21 <dsouza> w
11:51:09 <yrlnry> Is there a natural way to express zip as a list comprehension?
11:51:30 <ziman> there are parallel list comprehensions
11:51:33 <poe> you need parallel list comprehensions [(x,y) | x <- .. | y <- ..]
11:51:35 <ziman> but they are ghc extensions
11:51:35 <mauke> not in H98
11:51:54 <shepheb> quadrophonic stereo.
11:52:04 <ziman> @quote contrapun
11:52:13 <ziman> ah.
11:53:39 <djahandarie> Whoa, I didn't know that existed
11:54:16 <ksf> hmmm TreeView doesn't support different numbers of colums in parents vs. childs...
11:54:55 <zeno__> whenever i try to cabal install anything i get depends on old-time-1.0.0.0 which failed to install.
11:55:59 <zeno__> because exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found
11:56:12 <zeno__> im using 6.8.2
11:57:25 <ksf> zeno__, cabal install hsc2hs
11:57:30 <ksf> ...then retry.
11:57:45 <ksf> cabal doesn't (yet) track dependencies on programs
11:58:14 <zeno__> ksf Could not find module `System.Process': it is a member of package process-1.0.0.0, which is hidden
11:58:15 <ksf> or wait.
11:58:40 <ksf> does old-time work with 6.8.2, anyway?
11:58:46 <zeno__> no idea
11:59:14 <zeno__> thats the error i get when i try to cabal install hsc2hs
12:00:06 <zeno__> ksf: i tried installing a newer ghc from linux binary but kept getting errors
12:00:10 <ksf> you could try an older version of hsc2hs or update to 6.10... or wait for cabal gurus to speak up.
12:00:39 <zeno__> ksf: how to update?
12:00:49 <ezyang> MACID seems like a bad idea to me.  Can someone convince me that it's not a bad idea?
12:00:52 <ksf> depends on your distribution.
12:01:01 <zeno__> ksf: ubuntu, but its latest
12:01:06 <ksf> ezyang, some particular implementation or the guarantees?
12:01:24 <zeno__> binary install wasnt working
12:01:41 <ezyang> ksf: The HAppstack impl
12:02:19 <ksf> zeno__, http://209.85.129.132/search?q=cache:zPGuuZBSxcwJ:www.kuliniewicz.org/blog/archives/2009/03/24/installing-ghc-610-on-ubuntu-intrepid/+ubuntu+ghc+6.10+repository&cd=1&hl=de&ct=clnk&gl=de&client=firefox-a
12:02:33 <ksf> I'm on gentoo, so I won't be of much help.
12:02:45 <zeno__> ksf: thanks
12:02:51 <ksf> ezyang, you can argue that it's too memory-bound, yes.
12:03:50 <ezyang> I mean, I haven't even looked at it closely, it's just that: 1. Databases are hard, and 2. MACID is a database replacement, therefore, 3. Problems
12:04:17 <ray> ksf: but people these days run that memcached thing to get their databases more memory-bound
12:04:41 <ezyang> ray: True, but memcache is strictly a cache, not your end-all-be-all datastore
12:04:46 <ksf> 4. quickcheck, therefore, 5, no problems.
12:05:21 <ezyang> hahahahahahahaha
12:05:30 <ray> that's not relevant, the point is that the "too memory-bound" objection seems to be the opposite of the conditions in practice
12:05:30 <ksf> happsstacks' macid only does the storage, you have to do your data model yourself...
12:06:07 <ksf> ...so if you want to save by sparse keys, don't bleeding use a table, but a map.
12:06:44 <ray> as i understand macid, it's just "persist this piece of haskell data"
12:06:45 <ezyang> Does macid implement indexes, or do you have to do those yourself?
12:06:54 <ezyang> ah, ok. Then my question has an obvious answer
12:06:56 <ray> so you just define a data type the normal haskell way
12:07:10 <hackagebot> moe 2009.8.26 - html with style (JinjingWang)
12:07:23 <ksf> most database hardness is figuring out how to accellerate acesses to tables onto which you cramp your real data structures...
12:08:12 <ksf> application-specific data structures are bound to be faster, easily, and with the macid module you get the same guarantees that you normally use a db for
12:08:30 <ray> if all you have is a silver hammer, you'll still think it's your silver hammer after it fails to get your screw in
12:08:36 <ray> because you paid a lot of money for that silver dammit
12:09:02 <ray> acid isn't stupid, database schemas often are
12:09:06 <icee_> Sure, faster, but do I really want to do all the work to implement efficient data structures that keep the data normalized?
12:09:22 <ray> icee_: luckily they have probably already been implemented
12:09:33 <ray> Map or whatever
12:09:36 <icee_> really, is there a nice query planner?
12:09:42 <ksf> ...if in doubt, use bytestring-trie.
12:09:44 <arw> well, guarantees arent the only reason for a database, shared access to the same database by different applications is also a huge reason.
12:09:50 <icee_> That can figure out the right way to join some information?  What to join against what?
12:10:06 <icee_> That changes as data sets change.
12:10:23 <ray> arw: that still falls under ACID though
12:10:33 <icee_> RDBMS's are often used stupidly, and are almost never the most performant solution
12:10:41 <ray> it depends in no way on the relational table model or any of that baggage
12:10:44 <icee_> However, machine time is cheap compared to engineering time
12:11:02 <ezyang> I'm attempting to keep an open mind here, but... I am having difficulty buying these arguments.
12:11:22 <ray> what, specifically, is causing your head to melt
12:11:45 <ksf> ...the $1mio you spend on an oracle licese?
12:12:12 <arw> well. only idiots and companies with too much money buy oracle...
12:12:20 <ray> if so, just confuse your brain by saying to yourself "if it's so good, why does it cost a million bucks?"
12:12:39 <ray> this is the principle of zen koans
12:12:46 <ksf> if they're our brothers, how come we can't eat them?
12:12:48 <ezyang> ok, so here are a few questions:
12:12:59 <ezyang> How does MACID decide what goes on disk and what stays in memory?
12:13:12 <ksf> everything goes to disk.
12:13:12 <icee_> ksf: Consider postgresql-- there's a lot in there, and it's pretty performant, provides ACID guarantees, is a proven implementation
12:13:34 <ezyang> Ok.
12:13:35 <ksf> ...the whole log, every single transaction.
12:13:41 <dino-> and is in mem at the same time. Both.
12:13:52 <icee_> and more so, it will be -reasonably- performant and allow arbitrary manipulation and joining of the information
12:13:54 <ksf> then, occasionally, snapshots are done to acellerate re-loading (on restart of the app)
12:14:13 <ezyang> ok, so you have a primary journal based system, with snapshots for speed
12:14:27 <ezyang> *primarily
12:14:34 <icee_> It also means when you add a feature, you usually don't need to manipulate a bunch of data storage code-- just add some indexes
12:14:48 <ksf> and that's, basically, all. the rest is your haskell data structure.
12:15:23 <ksf> icee_, you can add fields to records without changing much, too.
12:15:42 <ezyang> Ok. How is old data purged from the transaction logs?
12:15:51 <ksf> the question is whether you want to write your app in sql or haskell.
12:15:59 <ksf> by snapshotting.
12:16:14 <ezyang> Ok, so when we take a snapshot we throw away the old transaction logs. Fair enough.
12:16:47 <ksf> both the log and the snapshot are only meant to denote the most current version of the data set.
12:17:10 <DekuNug> Was here earlier, and was confused about type classes. I realised I'm not 100% sure, just looking at the functor typeclass and
12:17:18 <ksf> ...that they are different from each other is an implementation detail for performance reasons.
12:17:27 <DekuNug> class Functor a where / instance Functor Maybe where
12:17:44 <ksf> ...means that Maybe is a functor.
12:17:47 <DekuNug> When using fmap, you do fmap (+3) (Just 12)
12:17:53 <DekuNug> Yeah I know but
12:18:06 <DekuNug> Isn't (Just 12) a concrete type? Why isn't it like
12:18:10 <DekuNug> instance Functor (Maybe a) where
12:18:36 <ray> because you want to fill in the "f" in the type of fmap
12:18:50 <ksf> :t fmap
12:18:50 <harlekin> DekuNug, f has the kind * -> *.
12:18:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:19:03 <harlekin> Just 12 has the kind *.
12:19:03 <ksf> :k Maybe
12:19:05 <lambdabot> * -> *
12:19:08 <DekuNug> Kind?
12:19:13 <DekuNug> I don't think I've done that yet
12:19:16 <mauke> Just 12 has no kind
12:19:24 <ksf> arity of the type.
12:19:25 <mauke> DekuNug: a kind is the type of a type
12:19:32 <ksf> Maybe takes an argument, Int doesn't.
12:19:33 <ray> Just 12's type has kind *
12:19:46 <mauke> any value's type has kind *
12:19:50 <ksf> ...because it's (Maybe Int)
12:19:52 <DekuNug> Sorry, brb. I'll be back in a minute, neet to answer the door
12:20:00 <ezyang> ok. So MACID expects me to implement indexes by hand.  Does the Happstack framework give me precanned implementations of these things?
12:20:13 <ksf> haskell does.
12:20:25 <ksf> for all kind of data structures and access patterns.
12:20:35 <ezyang> ok.
12:20:43 <ksf> if you want to go fast, use Maps and Arrays.
12:21:20 <mercury^> How can I create take n [f a, f $ f a, ...] in a way that is consumed by foldr?
12:21:47 <ray> > iterate f x
12:21:49 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
12:21:59 <ezyang> Next question: Can multiple Happstack instances access the same _local datastore/keep their memory models coherent?
12:22:12 <mercury^> ray: that isn't consumed by foldr though, is it?
12:22:14 <ksf> answer: multimaster.
12:22:21 <ksf> dunno much about its state, though.
12:22:46 <ksf> though, of course...
12:22:48 <ray> mercury^: what do you mean
12:22:59 <ray> you can use foldr on that list just like any list
12:23:04 <ksf> you don't want local state. you want global macid state and unsynchronised local state.
12:23:15 <hackagebot> gitit 0.6.2 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
12:23:16 <mercury^> ray: I was asking whether they are fused.
12:23:22 <zeno__> ksf: ok getting the new ghc didnt fix the base problem, when tyring to install hsc2hs i get     Could not find module `System.Process': it is a member of the hidden package `process-1.0.1.1'
12:23:41 <Lemmih> ezyang: Use a different directory for the state.
12:23:43 <mercury^> ray: but it actually seems they are.
12:23:48 <ksf> zeno__, but now you should have hsc2hs anyway
12:24:37 <zeno__> ksf: nope
12:24:43 <ray> > scanr (*) 1 (iterate (+1) 0)
12:24:46 <lambdabot>   [* Exception: stack overflow
12:24:52 <ray> hrm
12:25:00 <Lemmih> ezyang: Oh, I misunderstood.
12:25:10 <ray> > scanl (*) 1 (iterate (+1) 0)
12:25:12 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:25:22 <ray> > scanl (*) 1 (iterate (+1) 1)
12:25:25 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
12:25:43 <ksf> strange. my ghc 6.10.4 came with hsc2hs
12:25:47 <zeno__> ksf: same exact erorr (when building network) exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found
12:26:02 <shapr1> yup
12:26:11 * shapr1 boings
12:26:11 <ksf> ...it's in /usr/bin, though.
12:26:16 <Lemmih> ezyang: Multimaster can do that but the code isn't supported anymore.
12:26:23 * shapr1 hugs Lemmih
12:26:51 <RayNbow> hmm, does the J in JHC stand for something?
12:26:56 <shapr1> John
12:27:03 <ezyang> Lemmih: maintainer abandoned it?
12:27:07 <zeno__> ksf: why is it looking in the wrong place
12:27:14 <mercury^> ezyang: it is called LHC.
12:27:20 <ksf> % ls /usr/lib/ghc-6.10.4/hsc2hs
12:27:20 <ksf> /usr/lib/ghc-6.10.4/hsc2hs
12:27:23 <shapr1> RayNbow: john meacham at repetae.net last I checked.
12:27:27 <doubleth1nk_work> RayNbow: 'john' i would assume, since it's johns compiler :)
12:27:34 <RayNbow> ah
12:27:49 <Lemmih> ezyang: They're working on implementing the same feature in a different way.
12:27:54 <zeno__> ksf: ya its there
12:28:02 <zeno__> but ghc is looking in /usr/local/lib/ghc-6.10.1/hsc2hs
12:28:16 <ezyang> (things that are not the same: lhc and large hadron collider)
12:28:29 <ray> that's a shame, too
12:28:35 <ray> or i could implement destroyUniverse properly
12:28:36 <ksf> is your cabal up to date?
12:28:37 <dolio> mercury^: Both take and iterate are rewritten into fusible forms.
12:28:40 * tibbe notes that it's surprisingly difficult to design a good I/O layer
12:28:47 <zeno__> ksf: i need network to install cabal install
12:28:59 <doubleth1nk_work> tibbe: indeed, you've been at it for a while now, no?
12:29:11 <zeno__> ksf: i cant build network because ghc doesnt know where hsc2hs is
12:29:12 <ksf> no, cabal, the library, not cabal the executable which is cabal-install.
12:29:12 <tibbe> doubleth1nk_work: yes, in various forms
12:29:15 <mercury^> dolio: ok. Can I also use last on the (take n (iterate ...)) and it will all be properly fused together?
12:29:17 <Lemmih> shapr1: Hiya. IRCing from work?
12:29:23 <dolio> mercury^: Yes.
12:29:26 <zeno__> ksf: ah nope
12:29:33 <tibbe> doubleth1nk_work: even designing a basic API for byte/text streams that are buffered/unbuffered is tricky
12:29:36 <zeno__> but thats not reqd for network
12:29:44 <zeno__> which is what i need
12:29:45 <tibbe> doubleth1nk_work: also add blocking/nonblocking
12:30:02 <ksf> but maybe for cabal to properly locate hsc2hs. dunno.
12:30:05 <doubleth1nk_work> tibbe: sounds like fun. :) is this the 'nio' work you were talking about?
12:30:11 <dolio> mercury^: Barring problems with how the rewrite rules are laid out.
12:30:19 <zeno__> ksf: so install cabal and try again?
12:30:22 <tibbe> doubleth1nk_work: actually it's related to lot of my work, both on nio and sockets
12:30:33 * ksf would switch to gentoo.
12:30:39 <doubleth1nk_work> tibbe: ah right, you're trying to consolodate network-*
12:30:44 <doubleth1nk_work> iirc?\
12:30:49 <tibbe> doubleth1nk_work: yes
12:31:09 <ksf> failing that, download the haskell platform and install it in $HOME, not caring about ubuntu.
12:31:23 <tibbe> doubleth1nk_work: the bigger picture is that the data types for bytes and unicode are almost in place (Data.ByteString/Text) but the IO subsystem still needs som elove
12:31:42 <ksf> ...or wait for some of the cabal gurus to speak up.
12:33:21 <ksf> tibbe, I recommend indulging in having a really, really close look at iteratees and then abandoning the idea of using them.
12:33:31 <ksf> after that, _all_ IO seems simple.
12:33:42 <tibbe> ksf: heh
12:34:08 <tibbe> ksf: I've spent a lot of time on Iteratees, they seem to pop up frequently in different guises when you want to avoid lazy IO
12:34:39 * ksf is currently implementing lazy IO with STM
12:35:16 <tibbe> ksf: I've decided to try to deal with the basic IO layer first
12:35:18 <ksf> though you need a fully-threaded model to signal to the requestor that the value it didn't get the first time is now available.
12:35:29 <tibbe> ksf: there's stuff to be done there and things are more clear
12:36:26 <zeno__> ksf: how do i put it in the home dir?
12:36:50 <ksf> ...and, most likely, you need to use gtk to have the idea of coding _that_ imperatively, anyway.
12:38:09 <ksf> zeno__, use ./configure --prefix=/home/zeno/haskell
12:38:41 <fffej> is there a standard function to break a list into a list of lists?  e.g. partition 3 [1,2,3,4,5,6,7,8,9] => http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2,3],[4,5,6],[7,8,9 - all the ones I see take a predicate and I'm unsure how to make them take into account the number
12:38:56 <ksf> I'm quite surprised that there's not a generic binary tar.gz...
12:39:15 <zeno__> ok great! lets hope this wokrs!
12:40:08 * ski sighs
12:40:22 <vladbr> GOGOGO fight now on  http://armyofdead231.mybrute.com   and win a 5+ bonus levels!!! GOGOGO just now!!!
12:40:28 <oklopol> so cool!*
12:40:31 <ksf> compiling your first ghc is like configuring your first kernel, so cherish the moment...
12:40:32 <oklopol> *-*
12:40:53 <ray> *_* to you too
12:40:56 <zeno__> ksf: failure :(     Could not find module `Control.Monad': Perhaps you haven't installed the profiling libraries for package `base'?
12:41:13 <ski> > (\n -> unfoldr (\xs -> guard (not (null xs)) >> return (splitAt n xs))) 3 [1,2,3,4,5,6,7,8,9]
12:41:15 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
12:41:28 <ray> perhaps you haven't installed the profiling libraries for package 'base'
12:41:41 <ezyang> ski: not so much built-in ;-)
12:41:42 <ray> (i'm sorry)
12:41:50 <fffej> ski: thanks - now to work out what all of that means:)
12:41:50 <arw> ksf: ghc has not enough switches to twiddle, compared to the kernel ;)
12:41:54 <ksf> wth does it enable profiling, anyway?
12:41:55 <ski> ezyang : hence the `sigh'
12:42:03 <zeno__> ray: i did sudo apt-get install ghc6 ghc6-prof ghc6-doc haddock
12:42:14 <ksf> try ./configure --help and see if you can disable it.
12:42:30 <ray> there's your problem, you did sudo apt-get install
12:42:31 --- mode: ChanServ set +o mauke
12:42:31 --- mode: mauke set +b *!*@82.77.109.132
12:43:07 <zeno__> ray ?
12:43:17 <zeno__> http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
12:43:26 <zeno__> its what the directsions said to do
12:43:31 --- mode: mauke set -o mauke
12:44:25 <ray> i've had bad experiences with those OS packages
12:44:30 <ray> you don't have to listen to me about it though
12:45:09 <monochrom> Welcome to the axiom of choice.
12:45:30 <ray> there's a choice function? too bad you can't construct it
12:45:35 * ezyang still attempting to grok ski's line 
12:46:03 <ray> @do (\n -> unfoldr (\xs -> guard (not (null xs)) >> return (splitAt n xs)))
12:46:11 <monochrom> I can't construct it but it is given by God.
12:46:26 * ray knocks on lambdabot's side panel
12:46:38 <ppavelV6> we lost him!
12:46:51 <monochrom> What is @do ?
12:46:52 <mauke> killed by a fixed point combinator
12:47:10 <ray> monochrom: it turns some things into do notation
12:48:40 <zeno__> ksf: ok when building the haskell platfrom i AGAIN get exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found
12:48:45 <ski> > (\n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs))) 3 [1,2,3,4,5,6,7,8,9]
12:48:47 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
12:48:55 <etpace_> can anyone give me an example of traversable? I dont really understand it
12:49:03 <ski> (ppavelV6 : s/him/her/)
12:49:18 <ezyang> Oh, /much/ easier to understand
12:49:22 <ski> ray : `redo' ?
12:49:24 <ppavelV6> ski, oh, my fault
12:49:31 <etpace_> :t traversable
12:49:33 <lambdabot> Not in scope: `traversable'
12:49:44 <ray> @redo
12:49:46 <ezyang> although you're not being monadic anymore ;-)
12:49:49 <jfoutz> :t traverse
12:49:49 <etpace_> :t traverse
12:49:51 <lambdabot> Not in scope: `traverse'
12:49:51 <ski> maybe you mean `Data.Traversable' ?
12:49:52 <lambdabot> Not in scope: `traverse'
12:50:00 <ski> @type Data.Traversable.traverse
12:50:09 <ray> :t guard
12:50:12 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:50:14 <ezyang> aha, I see it
12:50:25 <ski> @type Data.Traversable.traverse
12:50:31 <ski> ...
12:50:35 <ezyang> For a moment I was confused whether or not we were using the List monad or the Maybe monad
12:50:35 * ksf is seriously considering using expanders inside a vbox instead of treeview to display stuff
12:50:39 <etpace_> I mean traverse of a traversable, i understand mapM because there are sideffects, but without sideffects, whats the point?
12:50:39 <ski> <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:50:44 <mauke> :t Data.Traversable.traverse
12:50:47 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:50:53 <ski> (.. is what lambdabot's afraid to tell in public)
12:50:58 <mauke> huhu
12:51:10 <ski> hm
12:51:13 <ski> @type ()
12:51:30 <ray> @vixen hello
12:51:37 <ski> it appears `type' is broken in public
12:51:47 <ski> (and maybe other things, as well)
12:51:47 <ray> clearly we're operating on emergency power here
12:51:49 <zeno__> ksf: ok when building the haskell platfrom or network or tons of other stuff I get exec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found.  i have ONLY ghc-6.10.4 installed and hsc2hs is installed too!!!!
12:52:03 <zeno__> er that wasnt directed at just ksf
12:52:07 <zeno__> gerneral thing
12:53:06 <dino-> yay!
12:53:09 <ski> etpace_ : s/sideeffects/effects/
12:53:21 <etpace_> hmm
12:53:27 <ezyang> HAppStack tutorial is broken for me...
12:53:30 <ski> etpace_ : `Applicative' provides (a weak form of) effects
12:53:43 <ezyang> Couldn't match expected type `String' against inferred type `Bool'
12:53:49 <etpace_> It actions using the f, and then collects the results but..hmm
12:53:50 <ezyang> :-(
12:54:40 <etpace_> > traverse (\x -> Just x+1) [2,5,8]
12:54:42 <lambdabot>   Not in scope: `traverse'
12:55:02 <etpace_> > Data.traversable.traverse (\x -> Just x+1) [2,5,8]
12:55:04 <lambdabot>   Not in scope: `Data.traversable'Not in scope: `traverse'
12:55:25 <ski> etpace_ : in any case, for types `m' which are instances of both `Monad' and `Applicative' (such as `IO', if i'm not badly mistaken), `traverse' (when the `t' above is `[]') should be equivalent to `mapM'
12:55:39 <ezyang> > Data.Traversable.traverse (\x -> Just x+1) [2,5,8]
12:55:41 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
12:55:41 <lambdabot>    arising from the lite...
12:55:45 <ski> etpace_ : the `t' not having to be `[]' is a datastructure generalization
12:56:15 <ski> > Data.Traversable.traverse (\x -> Just (x+1)) [2,5,8]
12:56:17 <lambdabot>   Just [3,6,9]
12:56:44 <etpace_> hmm
12:56:56 <ski> > Data.Traversable.traverse (\x -> if x >= 9 then Nothing else Just (x+1)) [2,5,9,8]
12:56:58 <lambdabot>   Nothing
12:57:02 <ski> > Data.Traversable.traverse (\x -> if x >= 9 then Nothing else Just (x+1)) [2,5,3,8]
12:57:04 <lambdabot>   Just [3,6,4,9]
12:57:47 <etpace_> it seems im getting a lot of tools for my toolbox, but I guess itll take awhile for me to recognise when to use them
12:57:54 <vav> > Data.Traversable.traverse (fmap (*10)) (Just ([],2))
12:57:56 <lambdabot>   ([],Just 20)
12:59:01 <aavogt> @type maybe mempty
12:59:04 <etpace_> ([1], Sum 5) <*> ([5], Sum 9)
12:59:13 <etpace_> > ([1], Sum 5) <*> ([5], Sum 9)
12:59:15 <lambdabot>   Couldn't match expected type `a -> b'
12:59:35 <etpace_> > ([1], Sum 5) `mappend` ([5], Sum 9)
12:59:36 * ezyang is getting confused again 
12:59:38 <lambdabot>   ([1,5],Sum {getSum = 14})
13:00:56 <ski> > let mean = sum / count; (result,(sum,count)) = Data.Traversable.mapM (\x -> State $ \(sum,count) -> (x - mean,(sum + x,succ count))) [2,5,3,8] `runState` (0,0) in result
13:00:58 <lambdabot>   [-2.5,0.5,-1.5,3.5]
13:02:44 <ski> aavogt : Monoid b => (a -> b) -> (Maybe a -> b)
13:06:06 <ezyang> vav: In the traverse fmap you posted earlier, why was 2 put into Maybe context by the lifted (*10)?
13:07:54 <vav> ezyang: traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) -- (,) is the f, Maybe the t
13:07:58 <ezyang> does the 2-tuple have an applicative instance that I'm being stupid about?
13:08:10 <vav> meh... vice versa
13:08:48 <ski>   instance Monoid w => Applicative ((,) w)
13:09:39 <ezyang> oh, right, the applicative instance for (,) treats the right-hand-side as the wrapped data
13:10:55 <jmcarthur_work> ezyang, right, and the left one is a monoid
13:11:09 <jmcarthur_work> oh, i didn't see that the instance is shown right above
13:12:03 <ezyang> how do I look up the source of the traversable instance for (,)?
13:12:15 <dolio> @type let f k (Left a) = Left (return a) ; f k (Right b) = k b in \t -> callCC (\k -> traverse (f k) t)
13:13:48 <roconnor> @djinn (((J r a -> b) -> J r a) -> J r a)
13:13:54 <ezyang> hm, that didn't help.
13:14:35 <hikingpete> Hey, I'm having trouble with IO. I've made a simple program (which doesn't work) in trying to figure out what I'm doing wrong. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8603#a8603
13:14:45 <vav> ezyang: no, I was being stupid, it's not the vice versa, (,) is the applicative, Maybe is the traversable. Don't think there's Traversable (,) instance.
13:15:14 <ezyang> ahhhh
13:15:18 <ezyang> ok
13:15:24 <roconnor> hikingpete: return (x:y)
13:16:06 <hikingpete> roconnor: thanks - hopefully that's the extent of my other problems.
13:16:34 <roconnor> I guess return $ x:y would also work
13:16:47 <hikingpete> I feel kinda silly that it was something so simple
13:17:01 <roconnor> meh, type error messages can be very tricky
13:17:35 <roconnor> hikingpete: adding top level type annotations (and sometimes more) can help
13:18:10 <ezyang> vav: wait, if fmap (*10) :: f a -> f a, and it's passed as the parameter which has type (a1 -> f b1), then doesn't that imply a1 is f a and b1 is a?
13:19:14 <ezyang> (and that f is the Applicative...)
13:19:32 <ezyang> (attempting to follow le types)
13:20:32 <Vanadium> > mapM (return . id) [1..]
13:20:34 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
13:20:34 <lambdabot>    arising from a use of `M47927043...
13:20:46 <Vanadium> > unsafePerformIO $ mapM (return . id) [1..]
13:20:48 <lambdabot>   Not in scope: `unsafePerformIO'
13:20:54 <rovar> are there currently any libs that offer storing/loading for a graph or graph-like structure?
13:21:03 <dolio> return . id = return
13:21:10 <Vanadium> Good point!
13:21:27 <DekuNut> Alright, back home. Sorry about disappearing earlier
13:21:37 <DekuNut> Would someone mind helping me understand these typeclasses. I feel so damn stupid D:
13:21:46 <Vanadium> basically I wanted to see whether lambdabot would give me the beginning of the list before it finishes evaluating
13:22:33 * ezyang gnashes teeth 
13:22:50 <lispy> > [1..]
13:22:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:22:55 <lispy> Vanadium: like that?
13:22:59 <Makoryu> DekuNut: Which typeclasses? Or do you mean typeclasses in general?
13:23:00 <Vanadium> Yeah, except with IO around it
13:23:08 <DekuNut> typeclasses in general
13:23:11 <lispy> > undefined :: IO ()
13:23:13 <lambdabot>   <IO ()>
13:23:14 <DekuNut> I'm putting a pastebin together so I can show where my confusion is
13:23:30 <lispy> Vanadium: lambdabot won't actually run IO for you
13:23:33 <ezyang> does (,) have a functor class?
13:23:36 <Vanadium> Yeah, I figured.
13:23:44 <lispy> ?instances Functor
13:24:02 <ksf> wth.
13:24:10 <lispy> > do x <- return (); return x
13:24:11 <DekuNut> Ok, so
13:24:12 <lambdabot>   No instance for (GHC.Show.Show (m ()))
13:24:12 <lambdabot>    arising from a use of `M412704467...
13:24:13 <Toxaris_> > fmap succ ('x', 41)
13:24:15 <lambdabot>   ('x',42)
13:24:17 <DekuNut> I'm confused mostly with instances: http://nopaste.org/p/aNWKAWfMy
13:24:19 <lispy> > do x <- return (); return x :: IO ()
13:24:21 <lambdabot>   <IO ()>
13:24:25 <Vanadium> Does not appear to do so
13:24:28 <ksf> can't gtk just provide cellrenderers that draw a simple, plain, widget?
13:24:34 <DekuNut> Why isn't the second one defined as instance Functor (Maybe a) where
13:24:41 <DekuNut> Yet you pass 'Just x' exactly the same?
13:24:43 <ezyang> ok, looks like lambdabot has it
13:24:53 <Vanadium> ghci> mapM return [1..] >>= take 10
13:24:53 <Vanadium> *** Exception: stack overflow
13:24:54 <Toxaris_> ezyang: the fmap for (,) works on the second argument, i.e. fmap = second
13:24:56 <ezyang> Which module is the class defined in?
13:25:10 <lispy> Vanadium: well, mapM needs the result
13:25:17 <Toxaris_> ezyang: maybe it is in Control.Monad.Instances?
13:25:23 <Vanadium> I suspect I do not understand what it needs the result for
13:25:33 <Makoryu> :k Functor
13:25:35 <lambdabot> Class `Functor' used as a type
13:25:38 <Makoryu> :k Maybe
13:25:40 <lambdabot> * -> *
13:25:42 <ezyang> yup, that was it
13:26:07 <lispy> ?src mapM
13:26:13 <lispy> lambdabot: hello?
13:26:17 <pr> @src mapM
13:26:20 <DekuNut> Was that aimed at me Makoryu?
13:26:21 <lispy> @src mapM
13:26:21 <mauke> when will you learn
13:26:25 <pr> it's sequence . map
13:26:27 <Vanadium> sequence . map I believe?
13:26:32 <mauke> (sequence .) . map
13:26:46 <Vanadium> So, yeah, map the first ten entries, sequence them and show me something? :\
13:26:53 <Phyx-> evening
13:27:21 <pr> hi Phyx-
13:27:29 <lispy> Vanadium: I'm not sure why, but I think mapM wants to see the last computation before it goes on?
13:27:44 <Toxaris_> DekuNut: The second one is a so called "constructor class"
13:27:51 <ezyang> Vanadium: because it's monadic, each of the computations could have side effects
13:27:53 <lispy> > mapM return [1..] >> take 10 :: [Int]
13:27:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
13:28:00 <lispy> > mapM return [1..] >>= take 10 :: [Int]
13:28:03 <Toxaris_> DekuNut: so the first one is a class of types, and the second one is a class of type constructors
13:28:03 <lambdabot>   * Exception: stack overflow
13:28:05 <ezyang> whereas,
13:28:24 <ezyang> > take 10 [1..]
13:28:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:28:33 <DekuNut> So why can't they both just be Maybe? Or both just be Maybe a?
13:28:35 <Makoryu> DekuNut: Sort of. Partly for my own curiosity. I don't quite understand myself exactly how typeclass parameters work
13:28:36 <lispy> > (mapM return [1..] :: [[Int]]) >>= take 10 :: [Int]
13:28:41 <lambdabot>   * Exception: stack overflow
13:28:45 <DekuNut> Mmm
13:28:52 <Toxaris_> DekuNut: the first one works with types like Bool which do not take arguments
13:29:01 <lispy> Even if the monad is [] it still overflows
13:29:04 <lispy> I don't really get that
13:29:05 <Toxaris_> DekuNut: the second one does not allow to give different instances for (Maybe Int) and (Maybe Bool) etc
13:29:07 <ksf> not being able to easily write custom widget seriously impairs gui development.
13:29:20 <DekuNut> Why not? I'm trying to understand exactly WHY that is?
13:29:21 <DekuNut> I can't see it
13:29:24 <Toxaris_> DekuNut: you only give one instance for Maybe and thats it
13:29:45 <DekuNut> The syntax is identical, I can't understand the difference...
13:29:49 <Toxaris_> DekuNut: furthermore, note that in the type of fmap in the second one, the Maybe is used with two different types, Maybe a and Maybe b
13:30:31 <Toxaris_> DekuNut: to see which is which, you have to look at the class definitions
13:30:42 <DekuNut> I'll re-read the section on typeclasses I guess, and see if I understand after that
13:30:56 <Makoryu> DekuNut: Depending on how a typeclass is defined, all its instances will expect the same kind of type. Note that "kind" here is jargon for the parameterized-ness of a type
13:31:26 <Toxaris_> DekuNut: the syntax is the same, but type inference (or kind inference, rather) will figure out wether the variables in the class head are for types, or constructors
13:32:03 <olsner> 1. cabal install xmonad 2. <wait a minute> 3. done
13:32:05 <olsner> awesome! :)
13:32:07 <DekuNut> Yeah I'm completely lost, I'll reread the section first
13:32:13 <Toxaris_> DekuNut: e.g. consider class YesNo a where yesno :: a -> Bool. Here, a is used as a type, so you have to instantiate it to a type in a instance declaration
13:33:26 <DekuNut> Ok yeah, I'm with you there
13:33:29 <Toxaris_> DekuNut: otoh, consider class Functor f where fmap :: (a -> b) -> (f a -> f b). Here, (f a) is used as a type, so f is not a type by itself, but something which gives a type when applied to some other type. So you have to instantiate f by a type constructor like Maybe.
13:33:44 <ksf> maybe I should go back to my roots as game developer and do it The Right Way: implement a tk from scratch.
13:34:06 <jmcarthur_work> it's key to note that it is illegal to attempt to write: yesno :: Maybe -> Bool
13:34:16 <Toxaris_> DekuNut: if f is Maybe, like in your instance, you have the following type of that specific fmap: fmap :: (a -> b) -> (Maybe a -> Maybe b). Here, f is just replaced by Maybe. (like when calling a function)
13:34:44 <jmcarthur_work> just as it is illegal to attempt:  fmap :: (a -> b) -> (Maybe Bool a -> Maybe Bool b)
13:35:00 <DekuNut> Well, what's the point in using (Maybe a) then in the other class
13:35:37 <jmcarthur_work> DekuNut, in YesNow, using Maybe a means you have yesno :: Maybe a -> Bool
13:35:43 <Toxaris_> DekuNut: There you replace the a from the class definition with an (Maybe a) from the instance definition
13:36:13 <jmcarthur_work> DekuNut, but in Functor, using Maybe a would mean you have fmap :: (a' -> b') -> (Maybe a a' -> Maybe a b')
13:36:21 <jmcarthur_work> which isn't correct
13:36:54 <jmcarthur_work> which is why you just use Maybe, not Maybe a
13:36:58 <etpace_> What does newtype do again?
13:37:07 <DekuNut> Yeah I haven't even the slightest clue what you mean, I'll read the section again. And try and figure it out by looking at each example in depth again
13:37:10 <jmcarthur_work> etpace_, it creates a new type out of an existing one
13:37:23 <Jedai> etpace_: it creates a newtype which is the same as an existing one
13:38:11 <Jedai> etpace_: but this type has an existence by itself (not like a _type_ synonym) which allows to instance it differently from its original type
13:38:14 <ezyang> etpace_: it creates a new type, and hides the original definition
13:38:17 <etpace_> so newtype Kleisli m a b means that if something is Kleisli -> Kleisli, its m a b -> m a b?
13:38:19 <jmcarthur_work> etpace_, it has some semantic differences from data. for example, pattern matching on a newtype doesn't force the "wrapped" thunk
13:38:55 <Toxaris_> etpace_: most of the time, newtype is like data
13:38:59 <jmcarthur_work> etpace_, it's not like a type synonym, so something of type Kleisli m a b is not the same as something of type a -> m b
13:39:09 <jmcarthur_work> they are only the same internally
13:39:28 <jmcarthur_work> that is, their types are different
13:39:49 <jmcarthur_work> @src Kleisli
13:39:53 <Jedai> etpace_: your "newtype Kleisli m a b" lack the part after the "=", the original type
13:39:59 <Phyx-> hi pr sorry, was afk
13:41:59 <Jedai> etpace_: taking a simple example "newtype Meters = M Int", here Meters is a real type, it's not a synonym of Int like it would be in "type Meters = Int"
13:42:02 <etpace_> so what does `newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }' mean?
13:42:10 <rovar> is there someone that is familiar with the build process on linux able to help me in a side channel?  I'm trying to install the amd64 6.10.4 binary in my home dir
13:42:13 <etpace_> hmm
13:42:31 --- mode: ChanServ set +o mauke
13:42:31 --- mode: mauke set -b *!*@82.77.109.132
13:42:39 <Jedai> etpace_: You can write an instance of Num for Meters and so on, you can't just add an Int and a Meters, it wouldn't type check
13:43:08 <etpace_> How can a type take a parameter, but a constructor doesnst?
13:43:31 --- mode: mauke set -o mauke
13:43:47 <Jedai> etpace_: I'm not sure what you're talking about there.... a "type" constructor, a "data" constructor ???
13:43:49 <etpace_> Or have I confused up record syntax?
13:44:18 <mauke> newtype Kleisli m a b = Kleisli (a -> m b); runKleisli (Kleisli f) = f
13:45:03 <Jedai> etpace_: your newtype Kleisli use record syntax but that's just syntax sugar, you could write "newtype Kleisli m a b = Kleisli (a -> m b)" and "runKleisli (Kleisli f) = f" and have almost the same thing
13:45:17 <Jedai> mauke: Right
13:45:22 <etpace_> well, data Maybe a = Nothing | Just a; Maybe has a kind * -> * and it finds its `a' from the Just,
13:45:33 <etpace_> but where does Kleisli find its m a b?
13:45:45 <etpace_> Ohh, doh
13:45:47 <Jedai> etpace_: from the parameter of Kleisli ?
13:46:07 <etpace_> I understand now that mauke desugared it
13:46:19 <etpace_> I originally though Kleisli took no parameters,
13:46:33 <etpace_> like Nothing, so I got a tad confused
13:46:43 <Jedai> etpace_: record syntax is nifty but confusing the first few times
13:46:53 <Jedai> IMHO ;)
13:48:21 <path[l]> is this a valid function lhs ? solve players (M.fromList [(0,0)]) _ _ =
13:48:25 <path[l]> I get a parse error
13:48:35 <Jedai> path[l]: nope
13:49:00 <Jedai> path[l]: the M.fromList ... part is not a pattern, so you can't use it on the lhs
13:49:06 <path[l]> oh
13:49:21 <lispy> path[l]: you can't pattern match against functions
13:49:23 <glguy> path[l]: This doesn't help you directly, but you can use: M.singleton 0 0
13:49:30 <glguy> path[l]: assuming M is Data.Map
13:49:36 <path[l]> its Data.IntMap
13:49:44 <path[l]> I wanna match against a map with just 0 0 though
13:49:54 <Jedai> lispy: he isn't trying to, he is trying to pattern match against Data.Map (and you can't)
13:50:05 <lispy> Jedai: ah
13:50:12 <lispy> So you needs a guard I guess
13:50:13 <glguy> path[l]: singleton exists in IntMap too, but you'll have to do that test outside of the argument list
13:50:18 <glguy> in a guard
13:50:34 <path[l]> ah
13:50:38 <Jedai> path[l]: you can't, not really (though the "view pattern" extension could do it but I would advise looking at the extension later on)
13:50:45 <kobox> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
13:50:56 <path[l]> wait even singleton cant be used in the pattern is it
13:51:00 <path[l]> its for a guard only
13:51:08 <path[l]> hmm ok
13:51:25 <Jedai> path[l]: You need a guard; since IntMap is completely abstract (you don't know its representation)
13:51:37 <dons> hackage now supports distro maps
13:51:39 <dons> e.g. http://hackage.haskell.org/package/gitit-0.6.2
13:51:46 <dons> links to the Arch Linux package for gitit
13:51:53 <nyingen> Is there an idiom for iterating over each line of a file till EOF? I can't use hGetContents in this situation
13:52:30 <Jedai> path[l]: the view patterns allows you to do "pattern matching" against abstract data type, but I would let this for when you know the basics better
13:52:31 <glguy> mapM_ f . lines =<< hGetContents h
13:52:47 <mauke> nyingen: why not?
13:52:52 <glguy> or do you specifically not want hGetContents
13:52:56 <path[l]> no thats fine, I can use a guard. But its 1 part of a 3 part function definition
13:52:58 <andrewsw> run a psql command and pipe the output to another psql command?
13:53:02 <olsner> nyingen: if you really can't, perhaps hGetLine?
13:53:03 <path[l]> Im wondering if a guard is the best thing to use
13:53:04 <andrewsw> oops
13:53:04 <nyingen> I need the handle position at each line
13:53:13 <path[l]> the thing is I dont even care whats passed there
13:53:19 <path[l]> Id love to pass undefined and match against it
13:53:20 <path[l]> lol
13:53:30 <path[l]> it recursively calls itself with the right value
13:53:31 <nyingen> hGetLine is fine, but how do I sequence it over the file until EOF?
13:53:37 <glguy> hIsOEF
13:53:42 <nyingen> yes, yes
13:53:52 <Jedai> path[l]: I'm not sure I understand, couldn't you use "_" or a named pattern in this case ?
13:54:09 <nyingen> but how do I combine these into a function that iterates over the lines :)
13:54:23 <glguy> you make one
13:54:36 <nyingen> mapM over infinite list of [(hGetLine h)..] ?
13:54:56 <path[l]> a named pattern?
13:55:01 <path[l]> Im not sure what that is
13:55:10 <lispy> :t hGetConents <$> zip [1..]
13:55:11 <lambdabot> Not in scope: `hGetConents'
13:55:21 <Jedai> path[l]: just a variable, like "map f xs =
13:55:44 <glguy> go h f = do eof <- hIsEOF h  ; unless eof ( (f =<< hGetLine h) >> go h f)
13:55:46 <Jedai> f and xs are what I would call "named pattern"
13:55:47 <glguy> something like that
13:55:53 <lispy> :t hGetContents >>= \contents -> zip [1..] (lines contents)
13:55:55 <lambdabot> Not in scope: `hGetContents'
13:56:03 <jmcarthur_work> path[l], wait, you are recalling the function with correct parameters when calling it with incorrect parameters?
13:56:09 <path[l]> yeah
13:56:11 <jmcarthur_work> path[l], nested functions are your friend
13:56:14 <jmcarthur_work> s
13:56:28 <lispy> ?hoogle hGetContents
13:56:35 <jmcarthur_work> foo x y = foo' x y z where foo' = ...
13:56:36 <path[l]> hmm
13:56:45 <etpace_> :t (>=>)
13:56:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:56:51 <path[l]> ah I see
13:58:34 <ezyang> "tree of lists" -> "list of trees"; does this question constrain the lists to all be the same length?
13:59:41 <jmcarthur_work> ezyang, what question?
13:59:50 <Badger> @src unzip
14:00:12 <Badger> @botsnack
14:00:12 <lunabot>  :)
14:00:36 <Jedai> Badger: unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
14:00:45 <Badger> oh thanks :P
14:00:51 <Jedai> @src unzip
14:00:52 <ezyang> In typeclassopedia, Brent poses the question when can a tree of lists be turned into a list of trees
14:00:57 <ezyang> for Traversable
14:01:21 * ezyang had much difficulty understanding the code, so he's going back to the basics 
14:01:42 <jmcarthur_work> oh i doubt the lists in the original tree have to all be the same length
14:01:50 <ezyang> ok
14:02:20 <jmcarthur_work> you could just have each tree in the resulting list possible get smaller and smaller as lists from the original run out or elements
14:02:24 <ezyang> The silly solution I came up with, then, was something like take the first element of all the trees and put that in one tree, then do the second element, and so forth
14:02:42 <jmcarthur_work> *of all the lists       i assume you mean
14:02:45 <ezyang> right, I'm trying to work out the details of that
14:02:51 <ezyang> jmcarthur: yep
14:03:19 <ezyang> and then the next question is, what's the second method
14:03:38 <mercury^> You cannot have where clauses before the last guard?
14:03:39 <Toxaris_> ezyang: maybe it helps to make up same example inputs, and figure out what the corresponding outputs would be, and ht
14:03:53 <Toxaris_> ezyang: and then consider whether the examples can be generalized
14:04:02 <byorgey> ezyang: hint: it's similar to the difference between lists and ZipLists.
14:04:13 <byorgey> what you just said corresponds to ZipList.
14:04:17 <ezyang> ooh, that's a big hint
14:04:26 <byorgey> yes, I guess it is a rather big hint =)
14:05:58 <eevar__> is it possible to make ghc-produced binaries use multiple cores by default? without having to add +RTS -Nx arguments, that is
14:06:32 <MyCatVerbs> eevar__: yeah, IIRC you can hardcode RTS options into the executable. Buggered if I can remember how, though.
14:06:38 <jmcarthur_work> eevar__, i don't think so, but note that on newer version of GHC you can just say +RTS -N    without having to specify the number explicitly
14:06:44 <SamB_XP> I think you need to create a C variable
14:06:56 <SamB_XP> that contains the RTS options you want, somehow
14:07:05 <SamB_XP> check the GHC manual for details
14:07:11 <jmcarthur_work> ah, yeah, probably on the C level you can do it
14:07:23 <copumpkin> in HEAD yup
14:07:31 <MyCatVerbs> eevar__: the easier thing to do by far is to provide a shell script that invokes your Haskell program. That'll probably be more useful than hardcoding it into the executable, as people will be able to change the number of OS threads just by poking that script.
14:08:05 <Toxaris_> shell script does not sound very portable to a windows person...
14:08:19 <mauke> batch file
14:08:23 <eevar__> ok, thanks guys
14:08:39 <etpace_> ezyang: I did that a few hours ago
14:08:59 <ketil> @seen dons
14:09:05 <Toxaris_> mauke: well, batch file does not sound very portable to a non-windows person :)
14:09:14 <MyCatVerbs> eevar__: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks <- is the way to hardcode it into the executable.
14:09:18 <mauke> preflex: seen dons
14:09:18 <preflex>  dons was last seen on #haskell 17 minutes and 32 seconds ago, saying: links to the Arch Linux package for gitit
14:09:31 <eevar__> MyCatVerbs: thank you
14:10:01 <mux> @src catMaybe
14:10:23 <MyCatVerbs> eevar__: but I would recommend that you provide a short shell script instead. Or one -really- nice thing you can do is set it from an environment variable instead. http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-optinos-environment
14:10:28 <ketil> thanks.
14:10:29 <mauke> lambdabot is half dead; stop bothering it
14:10:49 <MyCatVerbs> eevar__: then you could stick that in your .profile, and all Haskell programs would make use of it. :)
14:11:07 <ezyang> still waffling.  I think the crucial problem is that I haven't thought of an appropriate "operator" yet
14:11:11 <MyCatVerbs> Toxaris_: meh. cmd.exe is Windows' shell, and "batch files" are scripts for it. :)
14:11:38 <Elench> Bash is available for windows
14:11:47 <SamB_XP> MyCatVerbs: but that would mean providing two scripts ...
14:11:58 <MyCatVerbs> SamB_XP: oh the pain, however will we cope?
14:12:19 <SamB_XP> and I don't think cabal has any features for that sort of thing at all, even with just the one ...
14:12:35 <MyCatVerbs> SamB_XP: oh, that would be a valid problem. :/
14:13:00 <SamB_XP> MyCatVerbs: well, mostly I was just thinking that having two sounds like it would complicate the install process ;-P
14:14:19 <MyCatVerbs> SamB_XP: six of one, half a dozen into the other. Having to link an object file containing char* ghc_rts_opts = "-N 2"; complicates the build process. ;P
14:15:43 <SamB_XP> MyCatVerbs: but it can be done uniformly across all platforms, unlike the other
14:16:41 <harlekin> @src unfoldr
14:17:06 <harlekin> @ty unfoldr
14:17:27 <MyCatVerbs> SamB_XP: fair 'nuff. I'm still partial to the provide-two-shellscripts approach just because it works so well for all the myriad Java projects that do it. And, heck, it works for GHC.
14:17:45 <ksf> what do you guys think of buster?
14:17:52 <roconnor> what is buster?
14:18:08 <MyCatVerbs> SamB_XP: on the other gripping appendage, I don't write software with Cabal at the moment. :/
14:18:11 <ksf> http://vis.renci.org/jeff/buster/
14:18:21 <ksf> hieroglyphs semi-frp thingie.
14:18:25 <SamB_XP> MyCatVerbs: yeah.
14:20:35 * ksf thinks such things as number of os threads should be configurable at run-time by the program.
14:21:29 <tommd> ksf: It would be nice but it isn't easy to do!
14:21:49 <tommd> ... unless you want to count manually forking via forkOS - which is fairly obvious.
14:22:17 <ksf> as my experience goes, hardcoding nothing and making everything configurable on-the-fly is a practice that results in code design that can deal with it easily.
14:22:31 <sshc> Hi, would anybody recommend a book to learn haskell?
14:22:37 <ezyang> sshc: RWH
14:22:37 <Twey> Real World Haskell
14:22:43 <Twey> http://book.realworldhaskell.org/
14:22:44 <Vanadium> lyah
14:22:45 <tommd> @where RWH
14:22:54 <tommd> What happened to Lambda pet?
14:22:57 <sshc> thanks, I was considering reading that
14:23:05 <ezyang> Ok, so I did more thinking, and I guess it should be reasonable assume that the ZipList style implementation requires all of the lists to be the same size
14:23:09 <ksf> nah, I think forkOS shouldn't cont to "os thread" in that sense. the number of threads that are used by forkIO threads.
14:23:10 <tommd> @where lambdabot
14:23:32 <MyCatVerbs> sshc: http://learnyouahaskell.com/
14:23:35 <mauke> preflex: ? lyah
14:23:35 <preflex>  http://learnyouahaskell.com/
14:23:37 <tommd> ksf: Feel free to discuss it in #ghc (assuming you are talking about ghc) and write a patch!
14:23:52 <ksf> erm I'd rather not.
14:24:02 <ezyang> still thinking about the probabilistic style computation
14:24:10 <ksf> I want to spend the next two years with other things than diving into ghc
14:25:22 <ksf> @snack
14:25:55 <ksf> @quote
14:26:04 <ksf> she's just not listening.
14:26:13 <ksf> you have to talk to her in private.
14:27:15 <ezyang> drawing a blank, despite Brent's excellent hint
14:28:48 <Badger> She also works in other channels.
14:28:52 * edwardk1 waves hello.
14:29:00 <ezyang> I think to a large part because I think of ZipList/probabilistic lists in the /opposite/ direction
14:29:31 <byorgey> ezyang: the ZipList style one doesn't require all the lists to be the same size necessarily, for example you can imagine truncating all the lists to the length of the shortest one first
14:29:54 <ezyang> ok, sure.
14:30:23 <byorgey> ezyang: but fundamentally you're right.
14:30:42 <ezyang> > (,) <$> [1,2,3] <$> [4,5,6]
14:30:44 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
14:30:53 <ezyang> > (,) <$> [1,2,3] <*> [4,5,6]
14:30:55 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:31:12 <ezyang> right, so I am failing to see this in the traversable case
14:31:16 * ezyang thinks some more 
14:31:48 <byorgey> ezyang: note that you can think of that operation as converting a pair of lists into a list of pairs.
14:31:59 <ezyang> good call
14:32:13 <byorgey> ezyang: how would you describe in English what that code does?
14:32:50 <byorgey> and then see if you can generalize to trees instead of pairs
14:33:19 * byorgey waves back at edwardk1 
14:33:29 <ezyang> First, it partially applies (,) with 1, 2, 3 (a fmap), and then for each of the resulting functions, it applies each to each value of the second list.
14:33:35 <sanders_> anyone know where there might be some good Template Haskell documentation ?
14:33:47 <sanders_> or at least of good guide on the subject
14:34:38 <ezyang> (cartesian product)
14:34:45 <ezyang> is that looking at it from the right direction?
14:34:50 <byorgey> ezyang: yes.
14:34:56 <ezyang> ok
14:34:59 * ezyang thinks some more 
14:35:29 * tibbe is working on too many projects at once, needs to learn how to focus.
14:36:27 <MyCatVerbs> tibbe: lenses.
14:36:37 <tibbe> MyCatVerbs: what's that? :)
14:36:59 <byorgey> a formalism for bidirectional computation.
14:37:02 <Twey> Hahaha
14:37:10 <MyCatVerbs> tibbe: No, I mean lenses. Shaped pieces of smoothly ground glass. =)
14:37:20 <tibbe> MyCatVerbs: hehe
14:37:44 <ezyang> hmm, I think I've got something
14:38:01 * monochrom re-interprets "shaped", "smooth", "ground", "glass" in terms of CS
14:39:13 <ezyang> Suppose I start with root [1,2], with leaves [4,0] and [3,5].  Then, I convert this into a list of trees, the tress are (using notation Root Left Right) 1 4 3, 1 4 5, 1 0 3, 1 0 5, 2 4 3 and so forth
14:39:17 <ezyang> Is that it?
14:40:49 * edwardk now has to go and implement a bunch of monads and comonads in scheme.
14:41:33 * ezyang anxiously awaits a "yay" or "nay" 
14:43:16 <Alpounet> edwardk, good luck.
14:44:50 <ezyang> I believe this is correct, because it corresponds to collapsing the tree into a list, and then running the cartesian product of all of its members.
14:45:09 <edwardk> Alpounet: spent the morning going over various monads and comonads for dan friedman, now he wants a rogues' gallery ;)
14:45:23 <ezyang> and I think the list <-> tree is isomorphic
14:47:16 <Alpounet> edwardk, thus you're gonna rewrite your whole bunch of haskell monad/comonad libraries in scheme ?!
14:47:27 <camio> I'm looking for some FRP help. I'm trying to come up with a function tail :: Double -> Event () -> Behavior Bool. The resultant behavior is True whenever the event occurs and s seconds afterwards and False otherwise.
14:48:10 <edwardk> Alpounet: nah, just enough for him to be able to get his head around them. though he did like some fairly non-standard ones that work nicely in scheme, i.e. cps'd state, the free monad, cofree comonad, etc.
14:48:54 <Alpounet> edwardk, Hoho. Can you show us what a monad or a comonad has to look like in scheme ?
14:50:22 <edwardk> Alpounet: well, monomorphically? (define unit (lambda (x) x)); (define star (lambda (f) (lambda (x) (f x))) and then some define-syntax for do, etc.
14:51:51 <Alpounet> Okay.
14:52:12 <Alpounet> It looks rather annoying to do for many (co)monads
14:52:17 <edwardk> yeah
14:52:33 <etpace_> Can anyone help with Arrows? I really don't `get it' (i've only seen kleisli as an example)
14:52:36 <edwardk> but we blitzed through defining things like the cofree comonad of a functor, etc.
14:53:18 <edwardk> etpace_: if you think of a monad as shoving everything interesting to the right hand side of the ->, and a comonad as shoving everything interesting to the left, an arrow is where you don't bother shoving and can have stuff straddling both sides.
14:54:00 <camio> etpace_: Have you checked out the "typeclassopedia"?
14:54:22 <byorgey> ezyang: exactly.  sorry I didn't respond earlier, I was looking at something else.
14:54:28 <etpace_> thats where im reading them from camio I've been fine with everything till arrows
14:54:39 <byorgey> ezyang: just use my nick if you want to ping me =)
14:54:57 <edwardk> i.e. a -> (s -> (b,s)) -- is a state monadic kleisli arrow. but (a,s) -> (b,s) is the state "arrow" used in modified fashion as an arrow transformer
14:55:19 <ksf> wow. after half an hour, I made hieroglyph produce an application window.
14:55:22 <camio> ezyang: The original Arrow paper has a ton of examples.
14:55:31 <camio> ezyang: lemme look up the name...
14:55:33 <ezyang> whoo, awesome!
14:55:37 <ksf> now I need to figure out how to display "Hello World" and I'm done...
14:55:41 <Twey> Someone in the #haskell IRC channel used (***), and when I asked lambd-
14:55:41 <Twey> abot to tell me its type, it printed out scary gobbledygook that didn’t even fit
14:55:44 <Twey> on one line! Then someone used fmap fmap fmap and my brain exploded.
14:55:47 <Twey> Bahahaha
14:55:53 <ezyang> camio: do you mean etpace_?
14:56:34 <ksf> :t (***)
14:56:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:56:42 <c_wraith> that's one line for me. >_>
14:56:56 <ksf> that's half a screenwidth.
14:57:19 <byorgey> etpace_: check out the bibliography listed at http://www.haskell.org/arrows/biblio.html
14:57:32 <camio> Yeah, etpace_. Programming with arrows is hte name of the paper.
14:57:42 <byorgey> etpace_: the papers under "arrows in general" are all good.
14:57:42 <camio> etpace_: That's how I learned them.
14:58:11 <etpace_> > (+1) (***) (++"foo") $ (3, "bar")
14:58:13 <lambdabot>   Couldn't match expected type `b' -> c''
14:58:19 <ezyang> bye all!
14:58:55 <etpace_> :t (++"foo")
14:58:57 <lambdabot> [Char] -> [Char]
14:59:59 <etpace_> What's wrong with that, -> is an arrow right? so (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
15:00:24 <c_wraith> that's one instance of what it does
15:00:37 <c_wraith> There are other instances, for other arrows.
15:00:49 <etpace_> so what was wrong with my test?
15:01:08 <c_wraith> you used (***) instead of ***
15:01:12 <c_wraith> so you weren't using it infix
15:01:14 <etpace_> oh, doh
15:01:46 <monochrom> Too many parentheses are bad for your health!
15:02:07 <etpace_> > (+1) &&& show $ 5
15:02:09 <lambdabot>   (6,"5")
15:03:31 <c_wraith> > ((+1) &&& show) >>> ((*2) *** ("foo "++)) 5
15:03:33 <lambdabot>   Couldn't match expected type `(a, GHC.Base.String) -> c'
15:03:54 <etpace_> and thanks for the pointers byorgey camio, i'll look into them tomorrow
15:04:30 <camio> etpace_: good luck
15:04:37 <etpace_> > ((+1), show) `mappend` (5, 5)
15:04:39 <lambdabot>   No instance for (GHC.Num.Num (a1 -> GHC.Base.String))
15:04:39 <lambdabot>    arising from the l...
15:04:41 <byorgey> > ((+1) &&& show) >>> ((*2) *** ("foo "++)) $ 5
15:04:43 <lambdabot>   (12,"foo 5")
15:05:36 <c_wraith> wait, is the only thing you changed adding the $ ?
15:05:46 <Alpounet> yes.
15:06:01 <etpace_> :t >>>
15:06:03 <lambdabot> parse error on input `>>>'
15:06:06 <c_wraith> Oh, d'oh
15:06:09 <etpace_> :t (>>>)
15:06:11 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:06:19 <c_wraith> I totally forgot how many parens I'd used
15:06:24 <c_wraith> No wonder I got it wrong.
15:06:52 <c_wraith> For functions, >>> is the same as flip (.)
15:08:34 <etpace_> whats the difference between cat and arrows? cat just requires id and ., while arrows are a subset of cat and also require arr and first?
15:10:14 <MyCatVerbs> etpace_: yep.
15:10:20 <skorpan> so i guess that's the difference then!
15:11:55 <MyCatVerbs> etpace_: cat's an encoding of categories, which are a really really really weak notion. (Which is handy for mathematicians, because it means that category theory can be applied to just about everything).
15:13:38 <etpace_> ok
15:17:14 <ksf> I displayed a circle!
15:18:50 <byorgey> ksf: congratulations!
15:18:58 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8607#a8607
15:19:11 <ksf> ...in case someone is in need of an hello world.
15:19:32 <ksf> in fact, I started out trying to display "Hello, World", but didn't figure out how to position a string yet.
15:19:44 <ksf> ...arcs come with a position.
15:20:20 <ksf> and I wasn't sure whether or not buster knows that I want to draw geometry.
15:20:42 <Makoryu> Aw crud, it depends on GTK and such
15:21:06 <ksf> what's definitely missing from the output is the blue fill.
15:21:18 <ksf> it depends on cairo, not the rest.
15:21:28 <ksf> ...stuff like image loading.
15:22:38 <ksf> I'm fooling around with it as I decided that gtk is unusable in haskell.
15:22:56 <Makoryu> ksf: GTK is listed as a dependency
15:23:16 <ksf> coding up a gui without being able to easily define widgets is worse than starting out with no widgets at all
15:23:26 <ksf> Makoryu, that's because gtk includes cairo
15:24:12 <ksf> ...non-trivial guis, that is, or, rather, gui's with non-trivial data displays.
15:24:45 <dcoutts> ksf: you can define custom widgets with weird and crazy data displays with gtk (+cairo)
15:25:50 <copumpkin> mmmdonuts:
15:25:54 <ksf> ...what I wanted to do is display frames with a cellRenderer. which I wanted to do because TreeView fails because it only displays tables.
15:26:08 <ksf> ...that is, parents and childs can't have different column widths.
15:26:40 <dcoutts> ksf: ah, re-using the cellRenderer drawing and interaction methods in custom widgets is rather harder
15:27:08 <ksf> the other idea is to use expandables in a vbox, but that's visually unintuitive if it's actually a list of stuff I'm displaying.
15:27:20 <ksf> also, no sort interface whatsoever.
15:27:59 <copumpkin> GHC.Dotnet :o
15:28:20 <dcoutts> ksf: you're talking about the TreeView stuff right? There is a sorting thing for that, I'm not sure if it's bound in Haskell.
15:28:29 <ksf> it's bound.
15:28:40 <dcoutts> oh ok, wasn't last time I played with it :-)
15:29:05 <dcoutts> which admittedly was well over a year ago
15:30:36 <Kim_> Is there a difference between using guards and a “where” clause compared to using the “let/in” keywords? Reading the last chapter at http://en.wikibooks.org/wiki/Haskell/Next_steps
15:30:50 <dcoutts> ksf: so looks like you'd need to bind gtk_cell_renderer_render
15:30:57 <Twey> Kim_: Yes, it's prettier :)
15:31:10 <Kim_> Twey: So it's all up to style? :d
15:31:13 <ziman> Kim_, definitions in the where block are accessible withing guards
15:31:18 <ziman> *within
15:31:23 <Twey> Guards, where, and separate patterns are just sugar for let and case
15:31:36 <dcoutts> ksf: to get 'CellRenderer's to draw in your custom widget, some similar stuff to use their editing facilities
15:31:42 <ksf> mmmh ok. seems like I should'nt draw circles with gl. the fill is a moire pattern.
15:31:52 <dcoutts> ksf: so maybe not as hard as I imagined
15:31:54 <Kim_> zizman: But the definitions in “let” are accessible within the “in”-block, no?
15:32:01 <ksf> erm no I wanted a cellRenderer to draw a widget.
15:33:29 <Kim_> Twey: Ah, answered my second (and third, and so on) question too, thanks
15:33:36 <monochrom> ziman means this: "f (x:xs) | x/=5 = let y=x in y | otherwise = ... here you can't use y"
15:33:37 <dcoutts> ksf: yes, exactly
15:34:11 <Kim_> monochrom: Oh, I see
15:34:11 <dcoutts> ksf: you use a cell renderer to draw into the drawing area of your custom widget
15:34:37 <dcoutts> ksf: and you can also use them to edit
15:34:50 <dcoutts> ksf: they are not widgets on their own as such
15:35:42 <dcoutts> ksf: see the gtk+ C docs for an explanation of how they work: http://library.gnome.org/devel/gtk/stable/GtkCellRenderer.html
15:38:29 <ksf> dcoutts, see http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/51478
15:38:38 <Kim_> How’s haskell with different character encodings? I'm having trouble with certain characters (“カタカナ, 片仮名 for example”) ending up as questionmarks in GHCI O_o
15:39:57 <ksf> you also have problems inputting them into your irc client.
15:40:01 <Kim_> Heh
15:40:02 <dcoutts> ksf: sure, depends on your goals, something with beautiful concepts and code, or something that works now where you would not be embarrassed to show the GUI to someone else
15:40:19 <dcoutts> there's room for both
15:40:43 <ksf> well, I _thought_ vanilla gtk was powerfull enough for my app.
15:40:53 <Kim_> Those characters were kanji, taken from the wikipedia article with the same name (http://en.wikipedia.org/wiki/Kanji)
15:41:27 <ksf> どう
15:41:49 <ksf> mhhh they displayed fine while there were in the input field
15:41:58 <Kim_> They display fine here :)
15:41:58 <dsouza> they display fine for me too
15:42:03 <copumpkin> どうもくん？
15:42:09 <monochrom> Later versions of GHC will fix it. Meanwhile be assured that GHC actually does Unicode correctly inside, it just doesn't I/O them correctly. Use one of those utf-8 I/O libraries to work around.
15:42:10 <ksf> ah, font fail.
15:42:42 * ksf wonders why he's using a fixed font
15:42:46 <skorpan> again with the CJK... dammit #haskell
15:43:12 <monochrom> Most IRC clients default to fixed fonts as a relic of the 1980's.
15:43:24 <Kim_> Oooh, utf8 libraries
15:44:23 <ksf> xchat fails to fallback to unicode fonts, too.
15:46:46 <monochrom> xchat default is "hybrid of latin1 and utf8" recently.
15:47:13 <monochrom> IMO it's a confusing hybrid.
15:47:24 <ksf> well it's transfering just fine, it's just failing to use a font that includes the nescessary glyphs.
15:48:22 <MyCatVerbs> monochrom: fixed fonts are fine. gnome-terminal (and I believe GNU screen too) just use double-boxes for the characters that copumpkin posted. :)
15:49:59 <mercury^> dolio: I fear it didn't fuse after all.
15:50:50 <mercury^> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8608#a8608
15:51:06 <monochrom> fixed fonts for IRC are for people with a fetish with ascii art.
15:51:39 <ziman> unless you run irc in terminal
15:51:40 <c_wraith> some of us just really dislike variable-width fonts
15:52:49 <Cale> monochrom: Or code...
15:53:11 <MyCatVerbs> monochrom: I dissent! There does exist some really, really spectacular ASCII art that takes advantage of proportional fonts, too.
15:53:18 <Cale> It's impossible to align things properly without a fixed width font.
15:53:32 <monochrom> Use a pastebin already.
15:54:04 <monochrom> I mean: use a pastebin already for code. ascii arts are fine, just fetish.
15:55:06 <MyCatVerbs> ASCII art doesn't count as a "fetish" until you start repeatedly sending copies of "Meriday in the Morning" to lpr.
15:55:41 <monochrom> Now someone will remind me they are still doing IRC through a physical VT100 console and can't browse a web page.
15:56:26 <copumpkin> but I'm running a 486 dx2 66 mhz, with 8 MB of ram
15:56:43 <copumpkin> not my fault!
15:56:45 <monochrom> My 486 dx2 had 16MB of ram.
15:56:47 <skorpan> monochrom: fortunately, rms isn't into haskell
15:57:04 <copumpkin> extra fortunately, because he'd want the name GHC for gnu haskell compiler
15:57:29 <skorpan> fortunately, he doesn't really have a say in much these days
15:59:33 <MyCatVerbs> copumpkin: Nahhhh... GHC is 3BSD licensed and I'm sure he'd take offense to that. ;P
15:59:50 <monochrom> I'm fed to teeth with all those "some people are still using xterm" "some people are still using DOS 6" "some people are still using PDP-11" backward compatibility arguments. They follow the exact same logic as "all future Haskell specs should keep the n+k pattern and keep a distinction between fmap and (.)"
15:59:51 <sjanssen> monochrom: I think fixed width for IRC is defensible, Haskell code is utterly unreadable in Arial or whatnot
16:00:13 <copumpkin> arial ftl
16:00:18 <ksf> so, should we send a gpl'ed copy of ghc to the gnu guys on every release?
16:00:55 <lambdabot> Plugin `pl' failed with: thread killed
16:01:06 <ksf> @bot
16:01:06 <lunabot>  :)
16:01:07 <lambdabot> :)
16:01:12 <ksf> omfg
16:01:17 <Eelis> sjanssen: i write all my Haskell code in Helvetica. no problem at all.
16:01:20 <ksf> jesus motherfucking christ.
16:01:29 <ksf> she really blocked all that time.
16:01:36 <copumpkin> ?
16:01:39 <ziman> wow
16:01:45 <copumpkin> oh
16:01:46 <ziman> now that's cool! :)
16:02:06 <copumpkin> that's extreme
16:02:19 <sjanssen> Eelis: now I have to find an application on my computer that doesn't have fixed width fonts so I can figure out if you're nuts
16:03:45 <monochrom> If space (U+0020) doesn't change width depending on context, Haskell indented code isn't that unreadable.
16:04:02 <ziman> 20:17:27 < jmcarthur_work> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r)))))))))))))))))))))))))
16:04:13 <ziman> ksf, you mean this one, don't you?
16:04:17 <ksf> yep
16:04:27 <ziman> almost five hours :)
16:04:29 <Twey> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r)))))))))))))))))))))))))
16:04:41 <Eelis> monochrom: yeah, as long as space is some constant width, pretty much everything is fine. there are still some vertical alignment constructs that some people like that won't work, but they're few.
16:04:43 <Twey> *shrug*
16:04:46 <ksf> @bot
16:04:46 <sjanssen> monochrom: and you always line break when starting a new indentation group
16:04:47 <lunabot>  :)
16:05:00 <sjanssen> monochrom: and you don't worry about lining up "=" and the like
16:05:42 * ziman facepalms
16:06:14 <monochrom> I satisfy all those conditions, in fact.
16:06:24 <sjanssen> monochrom: many people don't
16:09:02 <mercury^> Anyone has suggestions how I can make this fuse? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8608#a8608
16:09:19 <c_wraith> @pl \a -> a * a + a
16:09:34 <ziman> λ-bot is out of order for the next 5 hours :)
16:09:53 <c_wraith> well, other functions work.  Just pl is dead, I think
16:10:01 <c_wraith> > 1 + 1
16:10:03 <lambdabot>   2
16:10:09 <sjanssen> mercury^: not using primitive recursion is a start
16:10:11 <c_wraith> yeah.  Just @pl
16:10:13 <ksf> no, just #haskell @ input is dead.
16:10:15 <ksf> @quote
16:10:15 <ziman> i see
16:10:28 <ksf> you can message her, though.
16:11:23 <mercury^> sjanssen: How does that affect fusion of iterate?
16:11:41 <sjanssen> mercury^: well, which bit do you want to fuse?
16:11:56 <mercury^> iterate, listArray and last
16:12:03 <sjanssen> "take count $ iterate next state"?  The problem there is giving it a name and using it twice
16:12:28 <sjanssen> using it multiple times ensures no fusion -- 'states' must be kept
16:13:19 <mercury^> sjanssen: So, how do I resolve it?
16:14:13 <sjanssen> mercury^: well, instead of using last, you could just look up the last element of your array
16:14:56 <mercury^> Ok, that works in this case. Is there a general solution for something like this?
16:17:11 <sjanssen> I think the solution will vary in cases like this
16:17:39 <mercury^> I hope the future fusion system will handle cases like this.
16:19:50 <mercury^> Actually, in the second case I cannot use the array solution because I incorrectly used count for the array length there instead of the length of the list.
16:20:05 <mercury^> So the same problem with last is there again with length.
16:20:30 <hackagebot> Haschoo 0.0 - Minimalist R5RS Scheme interpreter (MattiNiemenmaa)
16:22:11 <sjanssen> mercury^: wait, you're using 'length' on a list?
16:22:31 <sjanssen> seems like you can avoid that.  You know the length because the list is produced from an infinite list by take
16:22:46 <jeffheard_home> I've never been able to avoid a segfault on OSX using the OpenGL version of Hieroglyph...
16:22:53 <jeffheard_home> I've been trying to debug it
16:22:56 <jeffheard_home> switched to GLUT
16:22:58 <jeffheard_home> didn't help
16:23:00 <mercury^> sjanssen: I have to use takeWhile instead of take there.
16:23:14 <sjanssen> mercury^: ah
16:23:24 <mercury^> sjanssen: and then know how many elements I took so that I can create the array of proper size.
16:23:28 <jeffheard_home> Tried freeglut first and that gave me a specific error, but the regular OSX glut is still erroring out.  Segfault.  Bus Error.  Whatever...
16:23:36 <jeffheard_home> coredump is suitably unhelpful
16:23:42 <mercury^> But if using length on the list precludes any further fusion, the listArray won't fuse.
16:23:45 <sjanssen> mercury^: there's no way to do this conveniently with the array library
16:23:53 <jeffheard_home> is there some other tool I can try to figure out what the problem is?  I've tried GDB, but that's no help
16:24:07 <mercury^> sjanssen: with which library could I do it conveniently?
16:24:22 <sjanssen> mercury^: I don't know if it exists
16:24:42 <sjanssen> mercury^: uvector, maybe.  I'm not sure if it requires knowing the length of the array up front
16:25:11 <jeffheard_home> uvector supposedly calculates length in O(1) time
16:25:38 <jeffheard_home> only algorithms I can think of to do that would make it fusible
16:25:39 <mercury^> sjanssen: it does in fact.
16:25:50 <sjanssen> jeffheard_home: we don't need to calculate length, we need to create a vector without knowing the length before making it
16:25:51 <jeffheard_home> oh
16:25:55 <mercury^> sjanssen: but uvector lacks the hPut I suppose.
16:25:55 <jeffheard_home> gotcha
16:26:06 <mercury^> So I'll have to add that I guess.
16:26:07 <sjanssen> mercury^: so what exactly are you doing?
16:26:22 <sm> what's this obsession with yahoo-like naming
16:26:49 <mercury^> sjanssen: I'm building arrays of a buffersize so that I can parBuf $ amap them.
16:26:54 <sm> and what has it to do with scheme
16:26:56 <mercury^> And later output them.
16:27:03 <Cale> sm: Yahoo-like?
16:27:16 <sm> hayoo.. now haschoo
16:27:50 <Cale> hayoo is because it's a Haskell search engine
16:27:57 <sjanssen> mercury^: does the state really only support 'next', or could it support some sort of forward seek?
16:28:13 <Cale> Also, there is hoogle
16:28:16 <mmorrow> , [$pl| \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r))))))))))))))))))))))))) |]
16:28:25 <lunabot>  Killed.
16:28:51 <ksf> I just made buster thrash my disk.
16:29:00 <sm> yes. Hoogle is a fine name. Hayoo, ok fine, better if it were an easier url but fine. It's this new one I'm griping about
16:29:08 <mercury^> sjanssen: I could calculate the length easier than it is to step through all the states if that's what you mean.
16:29:44 <mercury^> But it feels so silly to add another calculation when all the data is in place and the compiler just doesn't see how to build that nice loop from it.
16:29:49 <sjanssen> mercury^: yeah, that might be good
16:30:20 <sjanssen> mercury^: what is the condition on 'takeWhile'?  It stops when there is no next state?
16:31:00 <mercury^> It stops when stCount reaches 0.
16:31:08 <mercury^> But that isn't reduced linearly.
16:31:43 <ksf> heck I can't even print keyboard and mouse events without having buster thrash.
16:31:45 <sjanssen> I suppose you could use STUArrays here
16:32:25 * ksf think apps should either loop or run fine, but not leak
16:32:55 <mercury^> What other array libraries are there and how do they relate btw? I can think of UVector, PArr only atm.
16:33:08 <mercury^> And I'm not sure whether using UVector or PArr is better.
16:33:20 <sjanssen> mercury^: there's a fixed maximum size for your buffers, yeah?
16:33:33 <hackagebot> Haschoo 0.1 - Minimalist R5RS Scheme interpreter (MattiNiemenmaa)
16:33:49 <mercury^> I arbitrarily set a size, but for the last chunk the idea was to just size it up as needed.
16:33:53 <sjanssen> mercury^: the array library is the only stable and usable one last I checked.  PArr might be okay know
16:33:55 <mercury^> It will only be a few percent.
16:34:21 * mmorrow likes the peek/poke/castPtr/peek/omg-don't-poke-there/poke array lib
16:35:05 <mercury^> That's even more incomplete though, not having a fromList at all.
16:35:39 <mmorrow> \p -> zipWithM [0..] (peek p)
16:35:53 <mmorrow> :)
16:36:00 <mmorrow> err
16:36:08 <mmorrow> \p -> zipWithM [0..] (peekElemOff p)
16:36:21 <mmorrow> poke!
16:36:28 * mmorrow blew it
16:37:20 <mmorrow> heh, too used to forM for that too
16:37:26 * mmorrow starts over
16:37:29 <mercury^> mmorrow: and an unsafePerformIO somewhere.
16:37:33 <mmorrow> \p -> zipWithM (pokeElemOff p) [0..]
16:37:35 <mercury^> If you want to use it in pure code.
16:37:48 <mmorrow> mercury^: or inlinePerformIO
16:39:08 <mmorrow> \p -> inlinePerformIO . zipWithM_ (pokeElemOff p) [0..] {- /me hides from the lynch mob -}
16:39:55 <mmorrow> make sure you force the () !
16:41:09 <dolio> Needs more unsafeCoerce.
16:41:16 <dolio> Try coercing to an Any and back.
16:44:11 <mmorrow> \f -> f . foldr (.) unsafeCoerce (replicate maxBound unsafeCoerce)
16:45:12 <Cale> ...
16:45:40 <sjanssen> mmorrow: inline the definition of inlinePerformIO for more speed!
16:45:54 <mmorrow> sjanssen: zmog!
16:46:43 <octopusWitHarms> i'm trying to find an article
16:46:51 <octopusWitHarms> it's like the "evolution of a programmer" thing, but it's not a joke
16:47:43 <dolio> It's a non-joke article on how to write factorial in 30 different ways?
16:47:49 <octopusWitHarms> not factorials
16:47:53 <octopusWitHarms> statements about programming styles
16:47:53 <dolio> :)
16:48:26 <gwern> @remember bos You don't get accurate answers from Perl. It just lies to you to keep you happy.
16:48:29 <gwern> @flush
16:48:36 <octopusWitHarms> it had uh...declarative, OOp and functional
16:48:42 <octopusWitHarms> does this sound familiar to anyone
16:49:32 <centrinia> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:49:50 <octopusWitHarms> no, not that one!
16:49:59 <octopusWitHarms> it's neither "evolution of a programmer" nor "evolution of a haskell programmer"
16:51:00 <octopusWitHarms> :t snd
16:51:02 <lambdabot> forall a b. (a, b) -> b
16:51:23 <octopusWitHarms> :t until
16:51:25 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:51:44 <octopusWitHarms> aha
16:52:05 <octopusWitHarms> brb
16:52:10 * octopusWitHarms sets the room on fire and leaves
16:57:53 <ksf> hell hieroglyph's GLUT interface produces mouse events if keys are pressed and key events when the mouse is clicked
16:58:00 <ksf> can't have gone through much testing.
17:00:49 <andrewsw> yeah
17:01:30 <ksf> ...and then I'm utterly perplexed by the fact that bindMouseKeyboardWidget "Foo" produces events with source "Hieroglyph.KeyboardMouseWidget", not "Foo.KeyboardMouseWidget
17:01:30 <ksf> " ,like it should, according to the source.
17:05:47 <luite> is there a way to find reverse dependencies on hackage.haskell.org?
17:05:54 <ksf> I wish.
17:07:38 <pgavin> hello
17:07:55 <pgavin> anyone know if I this will work as expected:
17:08:06 <pgavin> class Someclass a where
17:08:15 <pgavin>    type Sometype a = Int
17:08:27 <pgavin> then instances can override the type?
17:08:38 <Saizan> luite: in ~/.cabal/packages/hackage.haskell.org/00-index.tar.gz cabal-install saves the .cabal files of all the packages, you can parse those with the Cabal lib
17:08:50 <glguy> pgavin: What happened when you tried?
17:08:58 <pgavin> I dunno, I haven't tried
17:09:05 <pgavin> just thought I'd ask first :)
17:09:27 <pgavin> basically I want the analog of the default method implementation, but for types
17:09:37 <pgavin> actually, not types, but data
17:09:42 <pgavin> I don't think it matters though
17:09:46 <pgavin> I will try it now
17:09:53 <luite> Saizan: and then submit a patch for the cabal-install tool? ;)
17:10:58 <Saizan> luite: a patch that splits cabal-install into a library and an executable would be appreciated, i think :)
17:12:31 <Saizan> since what you really want is Distribution.Client.getAvailablePackages
17:15:46 <glguy> pgavin: As far as I can see, that functionality is still on the TODO list http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
17:16:12 <pgavin> glguy: ok, I can do without it
17:17:01 <pgavin> glguy: thx, btw
17:17:38 <heatsink> According to that page, the typecheker performs something called "zonking."
17:17:39 <heatsink> Type checking is weird.
17:17:52 <pgavin> heatsink: yes, it is
17:23:06 <sshc> how do I get the handle of standard input?
17:23:30 <RayNbow> @hoogle hStdin
17:23:37 <sshc> thakns
17:23:41 * RayNbow pokes lambdabot
17:23:46 <heatsink> @hoogle stdin
17:23:48 <RayNbow> @botsmack
17:23:48 <lunabot>  :)
17:23:52 <Axman6> @src putStrLn
17:23:59 <Axman6> lambdabot!
17:24:31 * RayNbow goes off to arrange lambdabot's periodic funeral
17:24:47 <sshc> > "eat"
17:24:49 <lambdabot>   "eat"
17:25:01 <RayNbow> wait... it's half-alive?
17:25:07 <heatsink> :t stdin
17:25:09 <Axman6> o.O
17:25:10 <sshc> it needs food
17:25:10 <lambdabot> Not in scope: `stdin'
17:25:11 <Axman6> @src putStrLn
17:25:21 <RayNbow> :t System.IO.hStdIn
17:25:23 <lambdabot> Not in scope: `System.IO.hStdIn'
17:25:28 <heatsink> @quote
17:25:38 <heatsink> \msg lambdabot @quote
17:26:16 * heatsink wishes for a standardized / key location
17:26:21 <Axman6> Cale: you aroud? lambdabot needs some kicking
17:26:25 <ksf> she's grinding a @pl
17:26:42 <ksf> last time, it took five hours.
17:26:52 <RayNbow> :t System.IO.stdin
17:26:54 <lambdabot> GHC.IOBase.Handle
17:27:00 <RayNbow> there we go :p
17:27:02 <heatsink> At-commands still work in private messages.
17:28:18 * ksf doesn't know whether or not to be glad about the fact that the "updated" attribute isn't ever read in hieroglyph.
17:29:19 <octopusWitHarms> magicman?
17:30:33 <mun> hi
17:30:43 <octopusWitHarms> wtf
17:31:02 <octopusWitHarms> zach is that you
17:31:03 <mun> in the function http://haskell.pastebin.com/m5cb1848e how can i print out the value of libenv' on line 7? sorry i know it should be quite trivial.
17:31:46 <Axman6> mun: that function is _masssssive_
17:32:28 <mun> Axman6, yeah i know. well i only want to see what value libenv' on line 7 takes
17:32:41 <Jaak> tried liftIO (print libenv')?
17:32:43 <heatsink> mun: if libenv' is showable, you should be able to put "print libenv'" after line 8
17:32:45 <Saizan> "print libenv'" before return?
17:32:54 <heatsink> oh right.  liftIO
17:33:24 <ksf> ...or maybe just lift.
17:33:25 <heatsink> If ResultT is a MonadTrans, then just lift.
17:33:47 <mun> Axman6, yeah i know. well i only want to see what value libenv' on line 7 takes
17:33:49 <ksf> line 5 says so.
17:33:50 <mun> i see
17:33:50 <mun> thanks
17:44:53 <ichor> What is the nicest way to ensure that a data type is a functor with respect to both it's arguments?
17:47:01 <heatsink> You mean to define it as an instance of functor for both arguments?
17:47:29 <koninkje> ichor: ensure that both arguments are parametrically polymorphic
17:48:02 <ichor> heatsink, yes. But I need to use them both at same time.
17:48:28 <koninkje> ichor: no can do. The closest you can get is to use a newtype wrapper for one of them
17:48:29 <ichor> koninkje, well, i know that it is a functor. I'm just having trouble finding a nice way to use it.
17:49:24 <ichor> koninkje, Hmm, that's not going to work for me. I should maybe just write my own class for it then. Bifunctor? or is that something else?
17:49:39 <koninkje> e.g. > data Foo a b = Foo a b ; newtype Flip f a b = Flip { unFlip :: f b a } ; instance Functor (Foo a) where... ; instance Functor (Flip Foo b) where...
17:50:13 <koninkje> If you write a bifunctor class then you'll still need to distinguish which half of the bifunctor you're using
17:50:41 <ichor> koninkje, yes, but I find that prettier than wrapping in and out the whole thing.
17:51:04 <ichor> koninkje, I will try both, and see what comes out the best.
17:51:09 <koninkje> If you take a look at the category-extras package I believe Kmett has: class Bifunctor f where gmap :: (a -> b) -> f a -> f b
17:52:20 <koninkje> if you're really making use of both parts, then using fmap/gmap is probably prettier than the newtype; if you're mostly using only one, then the newtype could be nicer
17:52:30 <copumpkin> I think his Bifunctor class has bimap
17:52:34 <copumpkin> that takes two functions
17:52:53 <koninkje> Maybe it was a different package of his...
17:53:33 <ichor> I'll check out category extras.
17:57:02 <ichor> The category-extra bifunctor class seems a bit overkill (depending on other instances). I'll just write one with gmap and fmap. Thanks for the help.
17:57:31 <copumpkin> well given its bimap, you can write fmap and gmap using id on either side
17:58:10 <koninkje> You may want your Bifunctor class to just have gmap, and use the regular Functor class for fmap (to improve interoperability with other code)
17:58:17 <ksf> one should draw a distinction between layout and graphic semantics.
17:58:21 <ichor> But what is QFunctor and PFunctor?
17:58:46 <ksf> laybout as in "layouting", that is, not in "specify a position"
17:59:10 <octopusWitHarms> that is what layouting is
17:59:11 <dibblego> afaik, Bifunctor is bimap :: f a b -> (a -> c) -> (b -> d) -> f c d, which sounds like what you want
17:59:12 <koninkje> PFunctor is a different kinding on Functor, and QFunctor is the same for Bifunctor ...IIRC
17:59:13 <octopusWitHarms> also it's not a verb
18:00:10 <ksf> nope. layouting is a set of contstraints... many, many rubber bands influencing each other. so that given a specific window size, everything gets painted at sane values.
18:01:44 <ksf> that is, hieroglyph having a "position" attribute in its arc primitive is semantically unclean.
18:02:38 <ksf> you can't just, as a button, say "draw me into the right-top corner of the screen". you are to be painted where layout thinks you are.
18:03:54 <dons> jeffheard_home: Graphics/Rendering/Hieroglyph/GLUT.hs:155:88: Not in scope: data constructor `GLUT.WithSamplesPerPixel'
18:05:06 <ichor> Ah, now I got it. PFunctor and QFunctor is typed more like they do in Control.Arrow. So that my arrows dont have to be functions.
18:05:17 <koninkje> exactly
18:06:47 <byorgey> dons: probably because GLUT changed again?  try constraining GLUT to an older version.
18:06:49 * ksf is going to have to google for tex's layout algorithm
18:07:01 <byorgey> dons: I ran into trouble building Hieroglyph a few weeks ago and that's what caused it.
18:07:58 <ksf> I've built it successfully today
18:08:39 <byorgey> hmm, no, it seems Hieroglyph now specifies an upper bound on the GLUT version
18:08:45 <byorgey> so that can't be it
18:09:25 * ksf uses glut 2.2.0.0
18:09:50 <byorgey> ksf: which version of Hieroglyph did you build?
18:10:21 <ksf> 3.89
18:10:26 <byorgey> but the latest version says it requires GLUT < 2.2.0.0
18:10:34 <byorgey> maybe you also have an older version of GLUT installed?
18:11:00 <ksf> yep, 2.1.2.1
18:16:07 <hackagebot> archlinux 0.2.3 - Support for working with Arch Linux packages (DonaldStewart)
18:24:11 <Gracenotes> huh. I don't recal Eclipse was so huge.
18:24:27 <Gracenotes> *recal, it being so large, MB-wise..
18:24:33 <Gracenotes> recall
18:26:26 <whoppix> Gracenotes, it's pretty large
18:44:52 <EvilTerran> ?seen fasta
18:45:10 <EvilTerran> ?bot
18:45:37 <EvilTerran> @bot
18:45:37 <lunabot>  :)
18:45:45 <EvilTerran> huh.
18:49:18 <path[l]> is there a minBy
18:49:58 <ray> > "are you still on emergency power lambdabot?"
18:50:00 <lambdabot>   "are you still on emergency power lambdabot?"
18:50:04 <monochrom> Probably not. What is minBy?
18:50:10 <ray> minimumBy?
18:50:25 <path[l]> no I wanted something like min
18:50:26 <path[l]> lol
18:50:34 <monochrom> Please specify.
18:50:45 <glguy> minBy f x y = minimumBy f [x,y] :)
18:51:23 <path[l]> hmm yeah maybe Im being silly.
18:51:51 <heatsink> minBy :: (a -> a -> Ordering) -> a -> a -> a?
18:52:27 <path[l]> oh wait it exists?
18:53:28 <copumpkin> :t let minBy f = min `on` f in minBy
18:53:30 <lambdabot> forall a b. (Ord b) => (a -> b) -> a -> a -> b
18:53:32 <heatsink> not in the standard library.
18:53:34 <copumpkin> or that?
18:53:36 <copumpkin> that's more like minOn
18:59:54 <path[l]> hmm
19:00:13 <path[l]> how do I ask lambdabot where to import it from
19:00:28 <path[l]> I actually I dunno how to produce an ordering
19:01:28 <oklopol> i read "i dunno how to produce an offspring", for a second there i though i could help you.
19:01:43 * oklopol considers sleeping
19:01:55 <path[l]> hahaha
19:02:26 <path[l]> ok this sounds really silly but I have 2 tuples a and b and I wanna return whichever one has the small second element
19:02:34 <path[l]> how is that done? : x
19:03:01 <dibblego> @type minBy
19:03:18 <EvilTerran> , (min `on` snd) ("three", 3) ("two", 2)
19:03:19 <lunabot>  2
19:03:20 <monochrom> you can use @hoogle to ask which module has stuff
19:03:54 <path[l]> ah I see
19:04:04 <path[l]> @hoogle minBy
19:04:19 <Saizan> minBy doesn't exist in the standard libs
19:04:21 <dibblego> I don't think minBy exists in the stdlib
19:04:23 <path[l]> oh ok
19:04:47 <path[l]> min on looks like min.f ?
19:05:09 <Saizan> you can use (min `on` snd) if you don't care about the first field
19:05:16 <ksf>  no you can't do @hoogle.
19:05:19 <BMeph> 'minimumBy' IS in libs, though. :)
19:05:20 <BMeph> @hoogle minimumBy
19:05:23 <ksf> lambdabot is on vacation.
19:05:29 <Saizan> min `on` f = \x y -> min (f x) (f y)
19:05:43 <EvilTerran> lambdabot's still replying to /msg for me
19:05:56 <BMeph>  <BMeph> @hoogle minimumBy
19:05:56 <BMeph> [19:05] <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
19:05:56 <BMeph> [19:05] <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
19:06:05 <ksf> yeah, but she isn't picking up the #haskell line.
19:06:12 <path[l]> no I do care though. I want (x,y) if when I take (x,y) and (a,b) y is < b
19:06:18 <path[l]> else I want (a,b)
19:06:19 <BMeph> @join #haskell
19:06:35 <ksf> she's gone lambda-fishing in the pointless-lake.
19:06:39 <BMeph> "Not enough privileges." :(
19:06:48 <path[l]> putting it in a list to use minimumBy sounds like overkill lol
19:06:48 <ksf> she's listening.
19:07:02 <Saizan> path[l]: you've to write it out explicitly then
19:07:03 <ksf> she's just ignoring you. as I said, she wants to fish some lambdas.
19:07:34 <path[l]> yeah which is why I feel silly, cause I dunno how do to that. It feels like ternary operator stuff
19:07:36 <Saizan> but the pointless-lake has no lambdas!
19:07:43 <gwern> @botsnack
19:07:43 <lunabot>  :)
19:08:07 <ksf> yeah, but she won't know that until one of her threads hit its bottom .
19:08:11 <gwern> @botsnack
19:08:11 <lunabot>  :)
19:08:16 <Saizan> path[l]: \(x,a) (y,b) -> if a <= b then (x,a) else (y,b)
19:08:28 <gwern> @botsnack
19:08:28 <lunabot>  :)
19:08:35 <gwern> hm
19:08:37 <ksf> actually, not threads, but fishing lines, of course.
19:08:38 <path[l]> ah there's an if statement then thanks :)
19:08:53 <ksf> gwern, she's busy for about 4 hours.
19:08:57 <Saizan> path[l]: if is just sugar for case
19:09:02 <ksf> (dunno since when exactly, though)
19:09:05 <path[l]> heh I see
19:09:19 <ksf> then she's going to say "command pl failed with: thread killed"
19:09:27 <Saizan> path[l]: if b then x else y = case b of True -> x; False -> y
19:09:40 <gwern> ksf: no, privmsgs work fine
19:09:41 <path[l]> ah I see
19:09:50 <gwern> and threads shouldn't be able to take this long
19:10:08 <ksf> gwern, try @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t (h (i (s (i (s (a (f (i (x (e (d (p (o (i (n (t (c (o (m (b (i (n (a (t (o r)))))))))))))))))))))))))
19:10:20 <illissius> howdy.
19:10:42 <cloudhead> hello, is there a way to pattern match a range?
19:10:50 <ksf> nope
19:10:57 <ksf> you can use a guard, though.
19:11:21 <cloudhead> hmmm ok
19:11:23 <cloudhead> thanks
19:12:19 <illissius> am i thinking correctly that you can define a seemingly-infinitely-recursive data structure like 'data Tree a = Foo (Tree a) (Tree a)', but that's ok because that means there's no way to instantiate it?
19:12:29 <illissius> or have i been away from haskell for too long and am i not thinking straight
19:12:50 <gwern> ksf: hm. can @pl be non-terminating?
19:13:00 <Twey> illissius: Huh?
19:13:05 <Twey> Of course you can instantiate it.
19:13:33 <monochrom> funnytree = Foo funnytree (Foo funnytree funnytree)
19:13:39 <Twey> Precisely
19:13:55 <Twey> It's not instantiation that's a problem, it's termination
19:14:05 <Twey> And thanks to laziness, we don't really need to terminate if we don't want to.
19:14:07 <ksf> gwern, dunno, I didn't write it.
19:14:12 <monochrom> Welcome to unlearning eager assumptions.
19:14:20 <ksf> it could just take ages, too.
19:14:22 <illissius> ah ok
19:14:52 <illissius> i've definitely been away from haskell for too long :) (and even then i didn't entirely understand this stuff)
19:15:24 <Twey> illissius: Just remember that nothing's evaluated until it needs to be
19:15:36 <Twey> We could also have said funnytree = Foo undefined undefined
19:15:40 <dibblego> lambdabot is responding in #scala
19:15:43 <dibblego> > 7
19:15:45 <ksf> nah that's not the same.
19:15:46 <lambdabot>   7
19:15:53 <dibblego> @type 7
19:15:59 <Twey> And you'd have a perfectly valid Tree, although it would error if you evaluated it.
19:16:01 <ksf> :t 7
19:16:04 <lambdabot> forall t. (Num t) => t
19:16:12 <gwern> @quote
19:16:13 <illissius> yeah i (think i) get laziness
19:16:24 <illissius> it's the algebraic types which are difficult
19:16:27 <gwern> @botsnack
19:16:27 <lunabot>  :)
19:16:27 <ksf> you can pattern match on as (finitely) many Foo's as you wish.
19:16:38 <gwern> dibblego: only to somethings, I see
19:17:15 <monochrom> Consider co-algebraic types instead. funnytree is better understood as such.
19:17:27 * Twey laughs.
19:17:51 * ksf instead nsiders algebraic types.
19:18:04 <Twey> *groan*
19:18:25 <Saizan> yeah, if you interpret Tree as an inductive type it's empty
19:21:01 * EvilTerran fails fails to express paramorphisms
19:21:07 <EvilTerran> er, only one fails
19:21:54 <Twey> Also to express ‘fails’ ;)
19:22:10 <babusrini> ghc 6.10.3 on windows: Why "+RTS -N2 -RTS" option is not supported?
19:23:16 <gwern> babusrini: compile it with -threaded?
19:23:49 <EvilTerran> Twey, hm... fails = iterate fail?
19:23:56 <EvilTerran> :P
19:24:14 <Twey> I was thinking more along the lines of fix fail
19:25:30 <EvilTerran> , iterate fail "boom!"
19:25:31 <lunabot>  ["boom!","","","","","","","","","","","","","","","","","","","","","","...
19:25:50 <ksf> , mfix fail
19:25:51 <lunabot>  luna: No instance for (GHC.Show.Show (m GHC.Base.String))
19:26:07 <Twey> > fix fail
19:26:09 <lambdabot>   ""
19:26:21 <Twey> Nice default
19:26:27 <ksf> erm yes but fail is monadic
19:26:36 <Twey> … defaults
19:26:36 <EvilTerran> ?type fix fail
19:26:42 <ksf> and to err is imperative.
19:26:47 <Twey> Hehehe
19:26:52 <ray> fail :: String -> m a
19:27:00 <EvilTerran> in this case, m = [], a = Char
19:27:03 <ray> the only way that can be unified with a -> a is String -> String
19:27:15 <Twey> Ah, aye
19:27:17 <ray> so it's not really a default
19:27:53 <ray> and since [] has a monadic zero, fail _ = mzero = []
19:28:03 <monochrom> fail :: String -> [a] is const []
19:28:38 <monochrom> Then apply the fundamental theorem of fixed points: fix (const x) = x
19:29:05 * EvilTerran seems to be getting stuck at "para f = f . fmap (\x -> (x, para f x)) . out"
19:29:10 <ksf> , runState (mfix fail) ()
19:29:12 <lunabot>  luna: Couldn't match expected type `MonadLib.Monads.State
19:29:12 <monochrom> I made up the name "fundamental theorem of fixed points" to add fluff. :)
19:29:33 <EvilTerran> which looks mostly right, but there's something unsatisfying about para :: (Functor f) => (f (Mu f, c) -> c) -> Mu f -> c
19:29:45 <ksf> , head (mfix fail)
19:29:46 <lunabot>  luna: Prelude.head: empty list
19:31:07 <EvilTerran> (it's defined in the paper as "para f . in = f . fmap (id &&& para f)")
19:31:12 <babusrini> gwern: Thanks. I forgot. I compiled with -threaded and it works now.
19:31:41 <juhp> how to get a distro added to hackage?
19:34:03 <Saizan> EvilTerran: why unsatisfying?
19:34:37 <roconnor> juhp: you first cabalize it, then ask for a hackage account
19:34:38 <BMeph> juhp: 1) Package it right; 2) Put it online where gwern can see it (and gnash his teeth at it not being on Hackage); 3) ????
19:35:06 <BMeph> ... 4) PROFIT!! ;p
19:35:08 <juhp> Linux distro? :)
19:35:08 <EvilTerran> Saizan, the "f (Mu f" looks like it shouldn't be there, to my mind; likewise the tuple
19:35:20 <juhp> (other than Arch ;)
19:35:41 <juhp> not asking how to upload a hackage :)
19:35:47 <EvilTerran> Saizan, compared to "ana :: Functor f => (a -> f a) -> a -> Mu f", "cata :: Functor f => (f a -> a) -> Mu f -> a", and "hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b", it just looks too complicated
19:35:53 <Saizan> you don't add distros to hackage, you fetch packages from hackage to put into your distro
19:35:56 <dolio> EvilTerran: That type is right.
19:36:16 <Saizan> EvilTerran: it's more complicated because the semantics are
19:36:29 <EvilTerran> ah, that's good to know
19:36:35 <roconnor> ooh, the arch distribution says what packages use my lib
19:36:36 <juhp> BMeph: so I should to gwern?
19:36:36 <roconnor> nice
19:36:46 <juhp> ask
19:36:53 <EvilTerran> i thought i was missing something that would've put it on a similar level of complexity to the others
19:36:56 <Saizan> juhp: of which distro are we talking about?
19:36:59 <juhp> fedora
19:37:04 <sjanssen> juhp: ask dons, maybe?
19:37:10 <dolio> @type let para f z [] = z ; para f z (x:xs) = f x xs (para f z xs) in para
19:37:16 <juhp> yeah that what I thought
19:37:18 <juhp> sjanssen: thanks
19:37:27 <dolio> Still gone, eh?
19:37:28 <Saizan> juhp: bos is one of the haskell maintainers for fedora i think
19:37:29 <sjanssen> "20:11  dons$ each distro generates a file, and gives a link to that file to Ross." from #xmonad
19:37:37 <juhp> Saizan: hehe and me
19:37:40 * gwern doesn't know how this distro stuff works, other than what dons wrote in #xmonad and that bug report
19:37:41 <dolio> @type [$ty| let para f z [] = z ; para f z (x:xs) = f x xs (para f z xs) in para |]
19:37:45 <BMeph> juhp: "It's dangerous to go alone. Here, take this!"
19:37:45 <sjanssen> 20:12  dons$ the file format is specified here:  http://hackage.haskell.org/trac/hackage/ticket/570#comment:1
19:37:46 <gwern> I just work on individual packages, not distros
19:37:50 <dolio> , [$ty| let para f z [] = z ; para f z (x:xs) = f x xs (para f z xs) in para |]
19:37:52 <lunabot>  forall a b . (b -> [] b -> a -> a) -> a -> [] b -> a
19:37:55 * BMeph gives juhp a silver lambda
19:38:04 <sjanssen> juhp: oh, that link has just about everything you need I think
19:38:05 <juhp> :)
19:39:05 <EvilTerran> so i can't simplify the type with a strategically placed "In" or "out" or something... oh well...
19:39:12 * EvilTerran takes that as a sign to go to bed
19:39:56 <dolio> All the simple ones take 'f result -> result'. para also gets the original structure at that point. Hence 'f (original, result) -> result'.
19:41:06 * BMeph wonders how many TDD devotees crash and burn because they never test their test code...
19:41:12 <babusrini> Why is ghc 6.10.3 binary on windows not built with -threaded option. Would it speed up compiles on a multi-core machine?
19:41:28 <gwern> don't think so
19:41:38 <Makoryu> Wasn't there an issue with the threaded runtime breaking in Windows?
19:41:51 <Saizan> no, it wouldn't
19:42:01 <gwern> threaded compilation is usually a feature of the build system, not the compiler
19:42:13 <gwern> speaking of which, when is that going to be put into cabal? >.<
19:42:27 <Makoryu> gwern: GHC? On Hackage?
19:42:32 <Makoryu> It's less likely than you think.
19:42:32 <gwern> no
19:42:35 <nroot7> I am new to haskell though not to functional programming (I have made some projects in erlang). Can anyone suggest some resource with small to medium sized projects for haskell ?
19:42:37 <dolio> Or, 'seed -> f seed' I guess. And you'd dually-to-para expect 'seed -> f (Either whole seed)', I think.
19:42:44 <babusrini> The compiler is written in haskell and so can't it be compiled with -threaded option?
19:42:55 <Makoryu> nroot7: Try the "Scheme in 48 hours" tutorial
19:43:01 <gwern> babusrini: maybe, but what good would that be?
19:43:07 <Makoryu> nroot7: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
19:43:07 <EvilTerran> dolio, gotcha
19:43:18 <dolio> Which is... apo? zygo? I forget.
19:43:22 <EvilTerran> dolio++ Saizan++
19:43:30 <EvilTerran> sleep++ :)
19:43:33 <sjanssen> babusrini: -threaded doesn't automatically parallelize your code, you need to explicitly write code to take advantage of parallelism
19:43:40 <gwern> with calls to forkIO etc
19:44:12 <sjanssen> babusrini: one of the early threaded RTS papers claimed there was a fork of GHC that was multi-threaded, but I heard it wasn't stable enough for inclusion
19:44:28 <dolio> It's apo, apparently.
19:44:31 <nroot7> Thanks guys
19:45:27 <sjanssen> GHC might benefit from the parallel GC?  I wonder if the GHC guys tried that
19:45:32 <BMeph> Haskell: Where reflective programmers are told to go fork(IO) themselves. With a straight face. And a friendly tone. :)
19:46:55 <roconnor> @quote zygohistomorphic
19:48:27 <babusrini> I am using forkIO in my app. Regarding the compiler, I was thinking that the compiler might take advantage of multi-core and perform independent tasks on separate cores. Doesn't the compiler use forkIO?
19:48:49 <sjanssen> babusrini: I believe the compiler is mostly sequential and single threaded
19:53:52 <ksf> I doubt anyone has ever thought much about parallelizing compiling, in general.
19:54:21 <ksf> ...except of course compiling multiple files at the same time, if their dependencies are already compiled.
20:18:50 <ksf> guide on how to write good documentation, rule 1: don't let the programmer do it.
20:20:42 <SamB_XP> ksf: is that why hardly anything on hackage has decent docs!
20:22:09 <ozten> howdy, I need some help with understanding a compilation problem
20:22:16 <ozten> http://haskell.pastebin.com/m63e196d7
20:22:42 <ozten> top half of pastebin is the Haskell program and the bottom half is runhaskell's output
20:23:04 <ozten> I'm trying to learn Haskell, by using Happstack and HDBC
20:23:32 <ksf> you need to lift "currentStat conn" into the IO monad.
20:23:46 <ksf> ...or, actually, into ServerPartT
20:24:10 <ksf> (depends on your direction of thinking)
20:24:13 <ozten> so should I look for a function that lifts into ServerPartT
20:24:26 <ozten> or could I use liftM
20:24:38 <ksf> ...I recommend liftIO
20:24:47 <ozten> thanks ksf: I'll give it a shot
20:24:53 <ksf> ServerPartT should have a MonadIO instance
20:25:00 <ozten> so >>= is saying that isn't a monad
20:25:27 <ksf> erm wait
20:25:38 <ksf> wth does showStats take an io action?
20:25:45 <ksf> you can't pass that to show.
20:28:12 <ksf> currentStat conn >>= return . show >>= toResponse
20:28:28 <ksf> ...or an equivalent fmap thing or just a plain, old do-block.
20:29:00 <ksf> gnrarg no toResponse appears to be pure.
20:29:14 <ksf> so it's currentStat conn >>= return . toResponse . show
20:29:32 <ksf> which is fmap (toResponse . show) currentStat conn
20:29:44 <ozten> ksf: yes IO Stats was a mistake
20:29:53 <Twey> toResponse . show `fmap` currentStat conn
20:29:55 <Twey> *hides*
20:29:56 <ozten> should be showStats :: Stats -> ServerPartT IO Response
20:30:07 <ksf> `fmap` is heresy.
20:30:11 <ksf> it's called <$>
20:30:19 <Twey> toResponse . show <$> currentStat conn
20:30:29 <Twey> But that requires a whole other import.
20:30:44 <ksf> Applicative should be in every import list.
20:30:52 <ksf> in fact, <$> should be in the Prelude.
20:31:10 <ksf> ...not disguised as (.) and needlessly monomorphic, though.
20:31:17 <Twey> Heheh.
20:31:26 <Twey> Agreed.
20:31:30 <Twey> But I want (??) in there too.
20:31:43 <ozten> What is the most basic way to structure it (for me as a newbie)
20:32:08 <ozten> Just trying to understand Types and how to plug Monads together
20:32:20 <Twey> do { stat <- currentStat conn; return (toResponse (show stat)) }
20:32:26 <ksf> do {stats <- currentStat conn ; return $ show $ toResponse stats }
20:32:27 <Twey> Probably
20:32:52 <ozten> thanks ksf and Twey, I'll study all these suggestions :)
20:32:54 <ksf> ozten, read the typeclassopedia.
20:33:16 <ksf> in fact, fmap is waaaaaay easier than using monads.
20:33:24 <Twey> True
20:35:53 * ozten likes "The goal of this article is to serve as a starting point for the student of Haskell wishing to gain a firm grasp of its standard type classes."
20:36:49 <ksf> beware, it's trying to teach you category theory without having you notice.
20:37:00 <ksf> it's very, very subversive.
20:37:15 <Twey> Hehe
20:37:28 <SamB_XP> ksf: ... I'm sitting here thinking "in what possible way could that be considered bad?"
20:38:32 <ksf> you could wake up one day, wondering whether you're a dual dreaming you're a dual, or a dual dreaming you're a dual.
20:38:53 <SamB_XP> hmm, as long as I don't dream that I'm my own cocoa
20:39:59 <copumpkin> ooh bos' article made slashdot front page
20:40:25 <SamB_XP> copumpkin: hmm?
20:40:34 <copumpkin> the revision control paper
20:40:38 <bos> yay me!
20:40:55 <copumpkin> congrats :)
20:41:19 <SamB_XP> huh, slashdot.net isn't it
20:41:36 <copumpkin> .org
20:41:48 <copumpkin> SamB_XP: bad geek!
20:43:14 <dolio> Who reads slashdot anymore?
20:43:37 <SamB_XP> dolio: clearly not me!
20:44:30 <dolio> I mean, people started reading reddit because slashdot was too much of a waste of web space.
20:44:38 <dolio> And now reddit is too much of a waste of web space. :)
20:44:42 <copumpkin> hacker news!
20:44:59 * copumpkin maximizes his procrastination by reading slashdot, reddit, and HN!
20:45:12 <dolio> Wow. You're a glutton for punishment.
20:45:23 <SamB_XP> we're going to have to come up with a domain name so obscure, the wasters' brains will explode if they see it
20:46:32 <copumpkin> :)
20:48:04 <dolio> Have you read all 1323 comments about why people hate java?
20:48:39 <Cale> ahahaha
20:49:00 <copumpkin> dolio: I read the thread when it was younger, but wow, that's a lot of comments
20:49:07 <copumpkin> if I'm being to productive tomorrow I'll take a look
20:49:26 <Cale> http://imgur.com/HWpBI.png
20:49:58 <copumpkin> hah, I remember that
20:51:01 <dolio> Yeah. Surprisingly, "Poor reasons for rejecting C++" got a mere 116 comments.
20:51:24 <Twey> Cale: Hahaha
20:52:53 <ksf> why choose any poor ones when there are plenty of good ones to choose from?
20:53:02 <dolio> Zing!
20:53:17 <SamB_XP> ksf: yeah, probably that's why there are so few comments on that one ;-P
20:53:37 <dolio> The article pretains to embedded systems, so I guess C++ is legitimately less disputed there.
20:53:42 <dolio> Pertains, even.
20:54:53 <dolio> The "C is it for embedded systems; C++ is too whatever" crowd probably isn't very large on reddit.
20:55:58 <Makoryu> Isn't it?
20:56:07 <dolio> Not according to the article.
20:56:41 <Makoryu> Ah, wait, I interpreted your comment as talking about people who *like* C
20:56:45 <SamB_XP> bos: since when does subversion not require you to be committing a change based on the most recent version of a file?
20:56:48 <dolio> But most people on reddit don't care about that, I suspect, because they'd never use either for any project they'd consider doing.
20:56:49 <hackagebot> hoauth 0.0.4 - A Haskell implementation of OAuth 1.0 protocol. (DiegoSouza)
20:56:50 <Trinithis> @ty undefined :: k a
20:57:13 <maxote> @hoogle STG
20:57:34 <Makoryu> 'Cause the non-C-obsessed people on reddit seem to really like Python
20:57:38 <bos> SamB_XP: i never said it did. i was making the argument about a directory, not a file.
20:57:41 <ksf> http://defoe.sourceforge.net/folio/knuth-plass.html
20:58:07 <SamB_XP> bos: wasn't terribly clear!
20:58:16 <bos> SamB_XP: bummer. oh well.
20:58:30 <SamB_XP> In fact, the risks are even subtler: suppose that Alice's changes do not textually conflict with Bob's; she will not be forced to check out Bob's changes before she commits, so she can commit her changes to the server unimpeded, resulting in a new tree state that no human has ever seen or tested.
20:58:55 <SamB_XP> "do not textually conflict" sounds like they're in different parts of the same file to me ...
20:59:02 <bos> Yeah, you're right.
20:59:11 <dolio> There was one 'embedded systems require Forth' comment. That's respectable.
20:59:18 <bos> Well, now you have the special knowledge of what I really meant.
20:59:24 <bos> Go forth and spread it.
20:59:37 <SamB_XP> bos: you can't print a retraction or something ?
20:59:54 <bos> SamB_XP: I could probably get it corrected.
21:00:25 <ksf> language-aware rcs, anyone?
21:00:29 * bos wishes we had a decent benchmarking framework for haskell, instead of 5 mickey mouse libraries.
21:00:53 <maxote> i'm looking many extensions to system Fw , with recursion, union, gadts, typed-dependently, etc. I don't know a framework to compute this extended system. Can anyone say anything?
21:01:27 <ksf> a first shot would be to allow for arbitrary alpha-conversions without having to commit or create conflicts.
21:02:33 <ksf> so if you want your code to say color, but the official repository uses the proper spelling, you can still be happy.
21:04:08 <copumpkin> bos: I started working on a quickbench but left it alone for a while
21:04:27 <copumpkin> doesn't help you much :)
21:04:42 <bos> yeah, it's a fair bit of work to do all the rerunning and statistical reaming necessary for the framework to be truly useful.
21:05:15 <copumpkin> yeah
21:05:23 <copumpkin> I'd like to finish it but don't have much time
21:08:13 <trez> ahahahahah
21:12:21 <blackh> Hi yall. Would some kind person remind me what the <<loop>> exception is caused by?
21:12:51 <dolio> It happens when you write an infinite loop that GHC can detect.
21:14:05 <blackh> dolio: Thanks.
21:14:14 <mmmulani> how do I convert Num -> Integral?
21:15:11 <aavogt> @hoogle readS_to_P
21:15:32 <dolio> Those are classes, so you'll have to clarify what you mean.
21:15:55 <dolio> If you have something of type 'forall n. Num n => n', then you can just use it as any particular Integral type.
21:16:21 <dolio> If you wan to convert some particular Num type into some other Integral type, that'd depend on what the types are.
21:16:46 <mmmulani> hmm, I'm using floor righ now
21:16:48 <mmmulani> seems to work
21:17:20 <copumpkin> :t floor
21:17:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:19:31 <ksf> such things as total fit should be on every cs curriculum.
21:24:28 <Makoryu> I just had the most spectacularly bad idea
21:24:32 <Makoryu> http://gist.github.com/175314
21:26:51 <ksf> you won't believe it, but I once had the same Idea, as people were arguing about if then else and layout problems.
21:26:53 <Makoryu> I guess return could be (otherwise ?)
21:27:41 <ksf> my soltion was to introduce MonadBool that gets its boolean set by if, and read by then and else.
21:28:26 <ksf> so you could actually have multiple thens and multiple elses for one if, which fits monads quite well.
21:28:38 <Makoryu> Ahhh
21:28:40 <Makoryu> Clever
21:30:07 <ksf> ...and, as a side effect, all branches can have different "a"s in MonadBool a => m a
21:30:26 <ksf> er MonadBool m
21:34:21 <ksf> I think "Eq b => MonadCase b a" would be the name for a thing that carries any Eq type, and supports mCase :: b -> m a
21:34:31 <ksf> ...which is a generalized MonadBool.
21:38:10 <lispy> what is MonadBool?
21:38:31 * Makoryu bangs his head against this instance declaration
21:38:40 <ksf> <ksf> my soltion was to introduce MonadBool that gets its boolean set by if, and read by then and else.
21:38:42 <Makoryu> I can't think of a way to make these types work
21:39:01 <ksf> keep at it, it's a very good exercise.
21:39:18 <ksf> in fact, you should follow the types, not make them work.
21:39:36 <ksf> code follows type as form follows function
21:40:31 <Makoryu> Well, before I had caseM :: [(Bool,IO())] -> IO ()
21:40:49 <Makoryu> Hrm
21:40:57 <copumpkin> why
21:41:00 <copumpkin> why IO?
21:41:13 <copumpkin> caseIO would be a better name for it then?
21:41:22 <Makoryu> copumpkin: Generalizing it, it would be [(Bool,t)] -> t
21:41:30 <Makoryu> copumpkin: That's just the only time I used it.
21:41:35 <copumpkin> ah
21:41:47 <ksf> it will look somewhat like caseM :: MonadBool m => m a -> m a
21:42:05 <SamB_XP> wouldn't cond be a better name for that ?
21:42:10 <ksf> or actually m a -> m ()
21:42:19 <Makoryu> SamB_XP: I was feeling egregious
21:42:20 <copumpkin> :t (fromJust .) . find
21:42:22 <lambdabot> forall a. (a -> Bool) -> [a] -> a
21:42:39 <copumpkin> :t (fromJust .) . find . snd
21:42:41 <lambdabot> forall a a1. (a1, a -> Bool) -> [a] -> a
21:42:47 <copumpkin> whoops
21:43:16 <Makoryu> :t (fromJust .) . find fst
21:43:19 <lambdabot>     Couldn't match expected type `a1 -> Maybe a'
21:43:19 <lambdabot>            against inferred type `Maybe (Bool, b)'
21:43:19 <lambdabot>     In the second argument of `(.)', namely `find fst'
21:43:29 <Makoryu> :t (fromJust .) . find . fst
21:43:31 <lambdabot> forall a b. (a -> Bool, b) -> [a] -> a
21:43:36 <Makoryu> Huh
21:43:47 <SamB_XP> :t find
21:43:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:44:08 <Makoryu> :t find . fst
21:44:10 <lambdabot> forall a b. (a -> Bool, b) -> [a] -> Maybe a
21:44:16 <SamB_XP> :t find fst
21:44:16 <Makoryu> Haha
21:44:18 <lambdabot> forall b. [(Bool, b)] -> Maybe (Bool, b)
21:44:35 <SamB_XP> :t snd . fromJust . find fst
21:44:37 <lambdabot> forall b. [(Bool, b)] -> b
21:45:02 <SamB_XP> ... some of us like to see what we're doing ;-)
21:45:53 <aavogt> @hoogle (a -> Bool) -> [(a,b)] -> [b]
21:46:42 <aavogt> :t filter . fst
21:46:44 <Makoryu> @hoogle [(Bool, b)] -> b
21:46:44 <lambdabot> forall a b. (a -> Bool, b) -> [a] -> [a]
21:46:59 <aavogt> :t filter . (. fst)
21:47:01 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> [(a, b)]
21:47:09 <aavogt> :t map snd . filter . (. fst)
21:47:11 <lambdabot>     Couldn't match expected type `[(a, b)]'
21:47:11 <lambdabot>            against inferred type `[(a1, b1)] -> [(a1, b1)]'
21:47:11 <lambdabot>     In the second argument of `(.)', namely `filter . (. fst)'
21:47:24 <aavogt> :t (map snd .) . filter . (. fst)
21:47:26 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> [b]
21:47:31 <SamB_XP> :t filter fst
21:47:33 <lambdabot> forall b. [(Bool, b)] -> [(Bool, b)]
21:47:34 <copumpkin> any enterprising ghc users on osx in here who care about getting ghc to generate x86_64 on osx by the way? :)
21:47:56 * SamB_XP has something to share ...
21:48:20 <copumpkin> ?
21:50:23 <sshc> how do I "getChar" from stdin without waiting for enter to be pressed?  "hSetBuffering stdin $ BlockBuffering $ Just 1" has no effect
21:50:49 <SamB_XP> taking a bit for me to find the URL :-(
21:51:20 <Twey> Typeclassopedia++
21:51:39 <Twey> sshc: Try NoBuffering
21:53:20 <Makoryu> ... If there were just some sort of layout syntax for constructing lists....
21:53:42 <Badger> eek, double $
21:54:40 <Saizan> Makoryu: use "Writer (Bool,a)" as monad?
21:54:48 <aavogt> :t ((($)$)$)
21:54:50 <lambdabot> forall a b. (a -> b) -> a -> b
21:54:51 <Makoryu> Saizan: Hmmm
21:55:03 <Saizan> ops
21:55:26 <Saizan> Writer [(Bool,a)] maybe
21:55:29 <ksf> a byte is too short a buffer, your os will just ignore that and use $PAGESIZE
21:55:29 <aavogt> :t (((((($)$)$)$)$)$)
21:55:31 <lambdabot> forall a b. (a -> b) -> a -> b
21:56:19 <copumpkin> aavogt: that looks useful
21:56:21 <ksf> :t $$
21:56:24 <lambdabot> parse error on input `$$'
21:56:25 <ksf> :t $ $
21:56:26 <copumpkin> I'll make a point of using that pattern in my code more often
21:56:28 <lambdabot> parse error on input `$'
21:56:49 <ksf> :t ($) $ ($) $ ($)
21:56:51 <lambdabot> forall a b. (a -> b) -> a -> b
21:57:08 <ksf> :t ($) $ ($) $ ($) $ ($) $ ($)
21:57:10 <lambdabot> forall a b. (a -> b) -> a -> b
21:57:31 <aavogt> :t foldr ($) ($) $ repeat ($)
21:57:33 <lambdabot> forall a b. (a -> b) -> a -> b
21:57:34 <ksf> :t (($($))
21:57:36 <lambdabot> parse error (possibly incorrect indentation)
21:57:43 <ksf> :t ($($))
21:57:45 <lambdabot> forall b a b1. (((a -> b1) -> a -> b1) -> b) -> b
21:58:06 <aavogt> :t foldl ($) ($) $ repeat ($)
21:58:08 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
21:58:08 <lambdabot>     Probable cause: `$' is applied to too many arguments
21:58:08 <lambdabot>     In the first argument of `foldl', namely `($)'
21:59:19 <aavogt> copumpkin: (==True) is probably more useful =)
21:59:45 <copumpkin> aavogt: I prefer (== (True == True)) myself
21:59:54 <copumpkin> gotta be extra sure
22:01:08 * ksf prefers (== (False == False)) and (== (True /= True))
22:01:55 <aavogt> @check \x -> (False==x) == not x
22:02:29 <aavogt> > sum [1..]
22:02:34 <lambdabot>   mueval-core: Prelude.read: no parse
22:02:34 <lambdabot>  mueval: ExitFailure 1
22:02:55 <copumpkin> > sum [one..] > 10
22:03:00 <lambdabot>   mueval-core: Prelude.read: no parse
22:03:01 <lambdabot>  mueval: ExitFailure 1
22:03:06 <aavogt> > one
22:03:08 <lambdabot>   1
22:03:20 <aavogt> > two
22:03:20 <copumpkin> > foldr (+) 0 [one..] > 10
22:03:24 <lambdabot>   Not in scope: `two'
22:03:24 <lambdabot>   True
22:03:31 <copumpkin> damn sum definition
22:03:57 <copumpkin> > foldr (+) 0 [one..] > 100
22:03:59 <lambdabot>   True
22:04:28 <ksf> > foldr (+) 0 [one..] == foldr (+) 0 [one..]
22:04:34 <lambdabot>   mueval-core: Prelude.read: no parse
22:04:34 <lambdabot>  mueval: ExitFailure 1
22:04:48 <ksf> > foldr (+) 0 [one..] == foldr (+) 1 [one..]
22:04:54 <lambdabot>   mueval-core: Prelude.read: no parse
22:04:54 <lambdabot>  mueval: ExitFailure 1
22:05:01 <ksf> > foldr (+) 0 [one..] == []
22:05:03 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
22:05:14 <ksf> ah that's my internal type error.
22:05:30 <ksf> > foldr (+) 0 [one..] < foldr (+) 1 [one..]
22:05:35 <lambdabot>   mueval-core: Prelude.read: no parse
22:05:36 <lambdabot>  mueval: ExitFailure 1
22:10:42 <SamB_XP> copumpkin, Makoryu, aavogt: *sigh*, just look at http://www.google.com/reader/shared/naesten -- second cat from the top, can't miss it!
22:10:59 <copumpkin> lol
22:11:04 <Trinithis> > Nothing >>= undefined
22:11:06 <lambdabot>   Nothing
22:11:15 <copumpkin> SamB_XP: they're also on the original lambdacats page
22:11:22 <SamB_XP> copumpkin: I know!
22:11:44 <SamB_XP> but I was hoping to come up with a *stable* anchored reference
22:12:15 <SamB_XP> the lambdacats website is sorely lacking in permalinks
22:12:40 <Trinithis> > sequence (repeat Nothing)
22:12:44 <lambdabot>   Nothing
22:38:03 <Trinithis> > Just () >>= foldl1 (<=<) (repeat $ const Nothing)
22:38:08 <lambdabot>   mueval-core: Prelude.read: no parse
22:38:08 <lambdabot>  mueval: ExitFailure 1
22:38:16 * SamB_XP wonders if http://www.drmaciver.com/2009/02/spam/ is supposed to be sci-fi, or what?
22:44:48 <Makoryu> Oh god
22:47:16 <Makoryu> I'm completely lost as to how to use the Writer monad
22:48:15 <Saizan> > runWriter $ tell [1] >> tell [2]
22:48:17 <lambdabot>   ((),[1,2])
22:49:14 <copumpkin> Makoryu: do you understand monoids?
22:49:44 <c_wraith> > runWriter $ tell [1] >> tell [2] >> Just 3
22:49:46 <lambdabot>   Couldn't match expected type `Control.Monad.Writer.Lazy.Writer w a'
22:49:57 <c_wraith> hehe.
22:50:02 <c_wraith> :t runWriter
22:50:04 <lambdabot> forall w a. Writer w a -> (a, w)
22:52:34 <path[l]> I was wondering. When I use ghci with +s, if my code ends with it saying 4176619812 bytes. does that mean I actually used up 4 gigs?
22:53:44 <copumpkin> path[l]: nope
22:54:05 <path[l]> oh ok, good lol
22:54:09 <copumpkin> it means that much memory was allocated by ghc total, but not necessarily at the same time
22:54:17 <path[l]> ah
22:54:22 <copumpkin> and not necessarily by calling malloc
22:54:29 <path[l]> hmm
22:55:22 <path[l]> I really should look into changing my backtracking solver to use the list monad. If I understand correctly, I should reduce drastically the space I waste by continually recreating lists
22:56:00 <lambdabot> Plugin `pl' failed with: thread killed
22:58:17 <Saizan> that thread took a lot of time to die!
22:58:42 <Saizan> @botsnack -- back?
22:58:42 <lunabot>  :)
22:58:42 <lambdabot> :)
23:01:48 <Phyx-> hmmm
23:02:08 <path[l]> how do I print strings so that they do not show up in quotes
23:02:32 <Saizan> putStrLn
23:02:35 <path[l]> ah
23:02:39 <path[l]> right
23:02:42 <path[l]> I was doing print
23:02:43 <path[l]> lol
23:05:23 <int-e> How boring. Define a  newtype Bare = Bare String  with a Show instance,  instance Show Bare where showsPrec _ (Bare s) = (s ++)   ;-) *runs*
23:06:56 <copumpkin> print . Bare
23:06:58 <copumpkin> :o
23:08:12 <skorpan> show (Bare []) = ""; show (Bare (x:xs)) = x:(show Bare xs)
23:08:22 <skorpan> WARNING -> !!!UNTESTED!!! <- WARNING
23:08:50 <int-e> Oh, this calls for all sorts of abuse actually. How about  newtype Append a = Append a; instance Show a => Show (Append a) where showsPrec _ (Append a) = (++ show a)?
23:09:55 <int-e> *Main> print (Append 1, 1)
23:09:55 <int-e> (,1)1
