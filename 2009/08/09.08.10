00:00:41 <Axman6> ut i was doing cabal install --reinstall darcs, and it wasn't working. i just did it again, and it's compiling fine
00:00:45 <Axman6> b*
00:02:57 <Axman6> mornfall: i'm getting this from the successful build: darcs failed:  Codec.Compression.Zlib: incompatible zlib version
00:04:42 <Axman6> (when running darcs what on one of my repos)
00:04:57 <mornfall> Wow.
00:05:12 <mornfall> I have never seen that.
00:05:19 <mornfall> What system are you on?
00:05:31 <Axman6> OS X
00:05:45 <mornfall> Hm. Could it be that hackage zlib is broken for you?
00:06:28 <mornfall> You could try with -f-zlib (darcs install), but it is something you should definitely report to Duncan.
00:06:29 <Axman6> i'm trying reinstalling zlib then reinstalling darcs
00:07:01 <Axman6> dcoutts duncan?
00:07:55 <Axman6> ok, that worked fine. nothing to worry about
00:11:51 <mornfall> Well, I'd be a little worried for your system, if nothing else. : - P
00:20:15 <sbahra> @slap araujo
00:20:15 * lambdabot pokes araujo in the eye
00:20:51 <araujo> sbahra, ?
00:57:51 <sbahra> araujo, wow.
00:58:22 <sbahra> araujo, you know I have been a regular of ##C for years, yes? :-)
01:00:01 <sbahra> araujo, you ban me because I (and about everyone else) believe you are wrong? I am entitled to as many cheap shots as you dish out. If you choose to abuse your operator status, that is your loss.
01:00:30 <araujo> sbahra, first this got nothing to do with Haskell, second ... you were wrong, third, i told you not to make it personal
01:00:32 <araujo> so move on now
01:01:04 <sbahra> It has nothing to do with Haskell, but I'm just letting #Haskell know that you're an asshole. :-)
01:01:08 <ayi> can you prove the wrongness?
01:01:21 <sbahra> araujo, I already did, but it is off-topic.
01:01:39 <sbahra> araujo, #haskell-blah or ask for logs from someone in ##C.
01:02:08 <araujo> sbahra, I don't mind to be considered like that from insulting people like you :)
01:02:54 <sbahra> araujo, you see, I never once insulted you. You started with the condescending tone and I reciprocated... :-)
01:03:09 <sbahra> araujo, anyways, this is off-topic and some other operator will remove my ban :-)
01:03:26 <araujo> sbahra, you did, and I warned you several times ... but it seems like you just don't listen :)
01:05:13 <sbahra> This will be my final word. You did not "warn me" at all, it is not your place to "warn me" when I reciprocate your tone to begin with. You asked me "not to make it personal", and trust me, I did not. I was picking on the fact that you actually think you have grounding in C because you've read the ancient K&R (and seem to defer the C99 standard as the authority).
01:05:20 <sbahra> If you wish to continue, please take it to #haskell-blah.
01:06:14 <ayi> sbraha 9 araujo 4 (boring lines
01:06:24 <ayi> that Fudgets WWWBrowser source exist online anywhere?
01:07:08 <ayi> i just tossed a k&R v2 into my 'trash' pile, since the only physical used bookstore in cambridge disappeared
01:07:13 <ayi> im contemplating keeping it, but i donno
01:07:16 <ayi> i cant imagine ever needing it :|
01:07:39 <ayi> i was gonna toss it on the steps of this MIT frat in brookline, but i moved out of brookline too
01:08:36 * liyang would in fact love it, if GHC could target an AVR microcontroller.
01:08:37 <ayi> and that book, seriously wtf
01:08:49 <ayi> it spent like 200 pages discussing ways you can increment pointers, at the exclusion of all else
01:08:53 <sbahra> ayi, really, off-topic. Logs will clearly show his intentions were not for correctness. :-)
01:08:57 <sbahra> ayi, please take it to #haskell-blah.
01:09:04 <ayi> sbahra: fuck off
01:09:04 <sbahra> ayi, it is a fine book but it is not the C standard. :-)
01:09:13 <sbahra> haha
01:15:45 <Ke> I bet ghc doesn't even support inline assembler =oP
01:16:21 <opqdonut> http://hackage.haskell.org/package/harpy
01:16:23 <opqdonut> almost :)
01:16:43 <Ke> heh
01:17:32 <Ke> still the dynamic linking would be nice ;o)
01:17:46 <koala_man> that's pretty awesome
01:21:44 <maxote> is there anyone who knows when will be 6.12 released + or - ?
01:22:04 <Ke> was it september
01:22:18 <maxote> ok, the next month
01:22:22 <Ke> source: unsubstantiated rumours
01:23:29 <Ke> bibtex from uncyclopedia.org ;o)
01:23:43 <Saizan> after icfp as usual
01:42:06 <murmmjau>  http://www.lostworlds.lv/go.php?1139723800 NEW WEBSITE GAME,COME AND PLAY.
01:43:10 <quicksilver> I thought I'd banned plinka@*
01:43:16 <quicksilver> not that ther eis much point.
01:44:39 <lament> go.php? They're playing go??
01:44:57 <Gabbie> lament, quickley click on it and find out!
01:45:52 <maxote> the Haskell committee did the best works, now it only needs a good maintainance doing more perfections to the language and to the libraries to reduce to the minimum the number of broken projects (with backward and forward compatibility), the OCaml committee is going stuck now that can't do ocaml faster than haskell unless it does a reconversion to metaocaml committee, :)
01:46:09 <lament> quicksilver: there he goes again, maybe ban after all?
01:53:20 <murmmjau>  http://www.lostworlds.lv/go.php?1139723800 New website browser game,come and play
01:59:31 <madhadron> Does anyone know how to pass a Haskell function as a function pointer to a C function?
02:00:57 <LeCamarade> gnuvince, ping
02:02:47 <maxote> http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1 ; http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1 ; http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1 ;  http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1 ; in these 4 modern machines, GHC-6.10.3 scores better than OCaml-3.11.0 . http://shootout.alioth
02:02:47 <maxote> .debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml&box=1in Pentium4, GHC-6.8.2 doesn't score better than OCaml-3.10.2 .
02:04:02 <int-e> madhadron: that's what the foreign import "wrapper" is for.
02:04:40 <madhadron> int-e, Thanks.
02:04:48 <madhadron> I found it in the docs just as you said that.
02:05:15 <madhadron> And I think I am in a state of deep sin, having just used 'nullPtr' in my code.
02:14:56 <maxote> i hope that 6.12 supresses all slowness of ghc against ocaml in shootout
02:23:51 <Botje> maxote: to be honest, most shootout code is little more than C written in haskell
02:30:13 <ksf> we still got slack in the shootout.
02:30:21 <ksf> unrolling, for example.
02:30:26 <ksf> proper simd usage.
02:30:35 <ksf> ...better parellelisation.
02:31:33 <ksf> last, but not least, and people are going to hate us for it, we could use the gpu of those machines.
02:36:05 <maxote> ksf, small step to small step, cpu is more general purpose than gpu, so that on cpu, it will be an easier implementation.
02:36:30 <maxote> gpu = as an array of cpus
02:37:18 <MyCatVerbs> ksf: are the shootout programs even allowed to do that?
02:38:02 <maxote> ksf, CUDA is propietary, i can't know more about GPU's implementations
02:46:10 <MyCatVerbs> CUDA or no, nothing actually stops you from writing your programs directly in GLSL/HLSL and schlepping data on and off the card manually through the graphics APIs. Except for the difficulty, tedium and error-proneness of that approac. :)
02:48:24 <maxote> haskell teams wanna try these enormeous difficulties using either propietary CUDA or graphics APIs.
02:49:21 <maxote> direct access to assembler from CPU or GPU is required
02:50:13 <Axman6> wait for OpenCL
03:01:46 <maxote> award prize 2009 for GHC this year, i'm sure :D
03:04:34 <ksf>  MyCatVerbs, guess what I'm planning to do today.
03:04:46 <ksf> after all, my nvidia can't do cuda.
03:05:21 <ksf> ...and hopengl doesn't play nice with all those render-to-texture tricks, so I'm going to write my own c wrappers around gl.
03:05:42 <ksf> the fun thing, however, is generating glsl programs on the fly.
03:06:34 <ksf> I don't think there's going to be much openness in gpu assembly.
03:07:06 <ksf> even worse, you'd have to write your own device driver.
03:07:26 <maxote> haskell teams won't write their own device drivers
03:08:29 <maxote> many modern gpgpus lack features are double floating points, long integers, etc.
03:08:30 <ksf> glsl is basically c, anyway, and c makes for a decent cross-platform assembler
03:08:43 <maxote>  /are/that are/
03:08:51 <ksf> you don't have to do stack stuff and so on anyway, as your kernels are scheduled by the hardware.
03:09:27 <ksf> I'm not even shure whether my gpu can do anything else but 32bit not-really-ieee floats
03:10:04 <maxote> gpu is very good paralellism but very very limited to their used types
03:10:35 <maxote> i think that gpu doesn't manage pointers
03:10:36 <ksf> well, that's what they're supposed to be good at.
03:10:57 <ksf> not really, though you can do many, many adressing tricks with vertex shaders.
03:12:02 <maxote> the heap in gpu is weird, it's as many TLS mini-heaps, it requires complicated lockings, etc.
03:12:27 <ksf> afaik gpu's just don't lock.
03:12:41 <ksf> you just copy your data, there's no concurrent r/w access.
03:13:13 <maxote> ksf, then how to share data?
03:13:37 <ksf> by swapping buffers and changing programs.
03:14:08 <ksf> you can ping-pong from one texture back to another, but you're going to have to tell the gpu to switch textures.
03:14:15 <maxote> do you believe that the haskell runtime can do these overcomplicated things?
03:14:37 <ksf> as long as the shaders are running, you can't do that.
03:14:43 <ksf> I've got no idea.
03:14:55 <ksf> but generating glsl with haskell seems like a good idea.
03:15:58 <maxote> it's better to wait the GPGPU implementations until that it's fully open (with direct access to its assembler) and fully typed registers (doubles, longs and ieee).
03:16:27 <ksf> then what am I supposed to hack on today?
03:16:56 <maxote> now, it's a convenience to experiment software technologies with existent CPU's SIMD registers and exploiting the parallelism in multicores and multicomputers.
03:17:15 <ksf> It's the only parallel piece of hardware that i've got, and I want to get to terms with data parallelism.
03:19:49 <maxote> it's easier and more viable than starting long-term GPGPU implementations
03:21:02 <maxote> the scope of Haskell should be on CPU, not invading the scope of GPGPU but can use the GPGPU's APIs for 3D shaders
03:21:30 <ksf> dph should fit gpu's quite well
03:21:49 <ksf> ...but that's not what I'm worrying about now.
03:21:52 <maxote> ksf, i don't think so it.
03:22:04 <Ke> anyone could implement haskell to run on GPU ?
03:23:05 <ksf> It's just plain folly to try to do things like standard folds with their piecewise data-dependencies on gpus, cpus will always be faster at that.
03:23:34 <ksf> if you want to map (+1) over an array, though, gpu's are exacty what you want to do
03:23:46 <Deewiant> This is what Data Parallel Haskell is for
03:23:53 <ksf> (modulo memory bandwidth, that is, the mapped function has to be complex enough)
03:24:31 <ksf> I don't think any other community is taking nested data parallelism seriously, either.
03:25:07 <ksf> It's just cool not to have to parallelize e.g. divide and conquer by hand.
03:26:07 <maxote> in GPGPU, the recursion doesn't exist, hahahaha
03:26:58 <ksf> well no, you just spawn a "thread" for every function body that will be called and let the hardware do the rest.
03:27:01 <maxote> it's possible that GPGPU wastes much time reloading code
03:27:30 <ksf> shoving textures from/to the graphic ram is the bottleneck afaik.
03:27:58 <ksf> so you should be fine if your problem size fits into graphics ram.
03:28:08 <yowgi> hello. I have a question about handle: how can I make my program portable with GHC 6.8 and 6.10, the interface has changed: http://groups.google.com/group/real-world-haskell-book-club/browse_thread/thread/2ad0d4761ad2f482?pli=1
03:28:34 <maxote> all these known bottlenecks are failures of the own fabricans, either Nvidia or ATI.
03:28:40 <yowgi> is there something like #ifdef? I don't like it so much but I'm kinda lost as to what to do now.
03:28:58 <ksf> nah it's just agp bandwidth.
03:29:00 <Deewiant> yowgi: Did you read Don's response in that link?
03:29:05 <yowgi> yes
03:29:06 <Deewiant> He gives two options
03:29:26 <yowgi> but Control.Exception doesn't exist in 6.8 and I'm not using cabal
03:29:42 <Deewiant> Oh right, you want both 6.8 and 6.10 to work
03:29:45 <yowgi> yes
03:29:49 <Deewiant> For that there's the extensible-exceptions package
03:30:00 <Deewiant> http://hackage.haskell.org/package/extensible-exceptions
03:30:15 <maxote> the GPGPUs are for 3D games, not for another task.
03:30:16 <yowgi> thank you! I'll try it
03:30:17 <Deewiant> Which gives you the new-style exceptions for both
03:30:28 <Deewiant> If you want the old-style exceptions for both, I think you need to use #ifdef.
03:30:36 <ksf> ...yeah, and sex is for reproduction only.
03:33:25 <maxote> i think that the haskell roadmap would be: 2009-2011: SIMD's, multicores's and multicomputers's parallelism, 2011-2013: PlayStation4s's parallelism (many Cells), 2013-2015: GPGPU2 parallelism.
03:34:07 <ksf> 6.12 already does multicore
03:34:18 <maxote> ksf, is it released? xD
03:34:30 <ksf> well, you can download 6.11 snapshots.
03:34:42 <yowgi> thanks Deewiant, it works fine now.
03:36:15 <maxote> during this roadmap, new software technologies will be discovered.
03:37:58 <maxote> at the time that the powers from the computers and applications provide you more answers and shorter times in jobs & developments.
03:38:41 <Ke> ksf: on what level multicore?
03:38:52 <ksf> shared memory
03:38:58 <Ke> ksf: tranparently with no io calls?
03:39:06 <ksf> yep.
03:39:10 <Ke> yays
03:39:22 <ksf> slightly different api though, as lists are quite unusable.
03:39:38 <ksf> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
03:39:41 <Ke> o_O
03:39:47 <quicksilver> well you can play with the strategies and the list chunking stuff
03:39:48 <Ke> wait and see then
03:39:55 <quicksilver> it's just hard to get it right
03:40:10 <Ke> ksf: I thought rather like parallelizing independent function calls
03:40:16 <int-e> quicksilver: and it doesn't work for cheap operations, because chunking lists is expensive.
03:40:29 <ksf> ...and slightly different strictness semantics, as parallel arrays are always fully evaluated if you force one element.
03:40:40 <ksf> they're unboxed by default, so to speak.
03:40:49 <int-e> quicksilver: (as opposed to chunking arrays, which is quite cheap)
03:40:58 <maxote> in Haskell, developers have not to program how to parallelize the data, it's the Great Philosophy!
03:41:20 <ksf> Ke, the idea of data paralellism is to have every core do the same thing to different data.
03:41:45 <ksf> if you want to thread stuff without using IO, we've got par.
03:41:50 <maxote>  err, s/parallelize the data/parallelize the code/
03:42:48 <maxote> it takes a very good advantage for the developers don't wasting time parallelizing the code.
03:43:20 <Ke> hmm I fail to see the adavantage to openmp yet
03:43:32 <Ke> but then I am just a beginner here
03:43:43 <maxote> and lesser bugs that came from the parallelization of the non-haskell developers.
03:43:48 <ksf> you're still going to have to keep your data dependencies clean, there is no free lunch.
03:44:07 <int-e> Heh, we are parallelizing developers now?
03:44:37 <maxote> it's planning of the great committe that is becoming a beast
03:46:05 <maxote> int-e, desaffortunately, the developers aren't sequential-to-parallel convertable
03:46:37 <maxote> it's impossible to recognize the data dependencies of the developers
03:47:07 <Ke> well there is theoretical possibility of automatically parallelizing independent function calls
03:47:38 <int-e> yes, and purity means that we have a lot of those
03:47:45 <Ke> yes
03:47:47 <maxote> unless there are check points that are the specifications of implementation-use
03:47:52 <int-e> getting the granularity right is an open problem though
03:47:57 <Ke> yes
03:48:39 <maxote> each team will do their implementations of particular related-technologies
03:57:08 <harlekin> @pl [f '\'' v, f '"' v, v]
03:57:08 <lambdabot> [f '\'' v, f '"' v, v]
03:57:11 <maxote> e.g. team T1 will do parser improvements, team T2 will do specifications refinements, T3 will type system improvements, T4 future logic inferences, T5 algebraic transformations, T6 extensions to attributed grammars, T7 tunning the garbage collections, etc.
03:57:40 <maxote> T8 testsuites
03:58:10 <maxote> are not they easy to parallelize the developers?
03:59:27 <lilac> the realization that (a `seq` b) == (b `seq` a `seq` b) has made me realize that many of my space leak 'fixes' don't actually work in general :(
04:02:05 <maxote> i hope that next weeks, there is a jump of hundred of haskell developers to many dozens of thousands of haskell developers in the GHC project driven by the Haskell committe, the Haskell committe has much work to fight to this new age.
04:05:35 <maxote> i think that it should be a Haskell committee directing the many Haskell subcommittees
04:06:10 <kynky> thought the new age was haskell
04:06:12 <maxote> before: committee of teams, after: committee of organizations of teams
04:06:59 <maxote> even organizations can share teams
04:07:37 <Ke> most advanced bureacracy in free software world
04:08:46 <maxote> the more incredible is that the teams are scientists, mathematicians, physicians, statisticals's economists, biologists, etc.
04:09:17 <quicksilver> where do you imagine you will find dozens of thousands of people to work on GHC?
04:09:27 <quicksilver> I doubt any compiler has ever had dozens of thousands of people working on it.
04:13:00 <randomwords> lilac: My most effective space leak fix so far has been to give up and go and weep in the corner...
04:13:17 <maxote> GHC needs an optimizer, optimizer requires local optimization, local optimization requires A.I. techniques and another scientist techniques.
04:13:23 <lilac> randomwords: yeah, i find sometimes the best way to stop a program leaking space is to not run it :)
04:13:34 <quicksilver> I generally don't find space leaks hard to fix, once correctly identified.
04:13:40 <quicksilver> correctly identifying them is harder though.
04:15:01 <lilac> quicksilver: i find much the same
04:15:25 <quicksilver> it does depend how abstract the code is, though. Space leaks in my reactive implementation I find harder to find
04:15:33 <quicksilver> because they're buried behind abstraction layers.
04:15:41 <quicksilver> spaces leaks in more "ordinary" haskell code, not such a big problem.
04:19:39 <EvilTerran> lilac, (a `seq` b) and (b `seq` a `seq` b) will have different evaluation orders (in ghc), even though they're semantically indistinguishable
04:19:57 <EvilTerran> so going from one to t'other may fix some space leaks
04:20:33 <Igloo> EvilTerran: They /may/ have different evaluation orders
04:20:54 <maxote> does ghc short-circuit optimization? xD
04:21:01 <EvilTerran> Igloo, hm? i did specify "in ghc"
04:21:19 <Igloo> EvilTerran: Yes, even in gh
04:21:27 <EvilTerran> although i guess, given optimisations, any aspect of evaluation order is up for grabs
04:22:07 <EvilTerran> Igloo, do you have a specific case in mind?
04:22:36 <Igloo> EvilTerran: Well, one example would be where a is already known to be strict, and b isn't
04:22:49 <Igloo> Then you may be in a worker that takes a strict a and lazy b
04:23:11 <EvilTerran> then a would be forced first, either way?
04:23:40 <Igloo> a has already been forced, yes. So all your seq would be doing is forcing b (which is actually a no-op, as b is being demanded anyway)
04:23:52 <EvilTerran> ah, already been forced. i see.
04:24:11 <EvilTerran> would my statement be better with s/evaluation order/forcing order/?
04:24:29 <Igloo> I don't know if even that is true
04:24:30 <EvilTerran> (where forcing an already forced expression does nothing but confirm it's been forced)
04:25:09 <ksf> > True || undefined
04:25:10 <lambdabot>   True
04:25:17 <ksf> yes, it does short circruit.
04:25:42 <maxote> for short-circuit optimization, the compiler should detect the "shortest" circuit for an expression where the order doesn't matter, it requires the use of the AND-subsumption if the operator is AND and OR-subsumption if the operator is OR.
04:26:22 <ksf> or unamb and a few cores.
04:27:08 <maxote> it's similar to commented in the Aho's Dragon Book but that it's in the ordered sense.
04:27:32 <ksf> the "throw hardware at it" opimisation is considerably underrated.
04:28:06 <Yacoby> Beginner question. I need a function to take a list and return the list with a specific index changed. Is there a function to do this or is it a sign I am approaching a problem incorrectly?
04:28:26 <jkff> Yacoby: Why do you want to index the list at all?
04:28:35 <ksf> Yacoby, there isn't a function for if iirc.
04:28:47 <ksf> you want do have a look at drop, take and ++, though.
04:29:30 <jkff> Hmm.. Is haskell.org down?
04:29:54 <benmachine> > let changeAt 0 y (x:xs) = y:xs; changeAt n y (x:xs) = x:changeAt (n-1) y xs in changeAt 1 'u' "hello"
04:29:56 <lambdabot>   "hullo"
04:29:56 <maxote> but there are issues, e.g. depending of the order evaluation of these expressions, the program can raise exception or not.
04:29:57 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3886
04:30:11 <ksf> there's a generic move one element of a list to another position in there.
04:30:39 <jkff> ..Oh, it isn't, but it is dead slow.
04:31:13 <Yacoby> thanks
04:31:35 <benmachine> (my function doesn't handle the changeAt n y [] case)
04:32:05 <benmachine> (also, some might prefer changeAt to take a function instead of a replacement value)
04:32:59 <jkff> Is haskell.org extremely slow for anyone else?
04:33:39 <ksf> seems like I solved the wrong problem, yet again.
04:34:19 <benmachine> jkff: yeah seems so
04:34:40 <jkff> benmachine: Thanks
04:42:44 <ChilliX> haskell.org ...... is ........ very ........ slow ........
04:43:29 <randomwords> you're not wrong
04:44:40 <Vanadium> I would like to use my lacking Haskell abilities to manipulate the X root window. Is this in the scope of gtk2hs or the opengl bindings, or where could I look for some guidance?
04:45:17 <dcoutts> Vanadium: try the X11 package
04:46:23 <maxote> there are 10 developers, there are 10 PCs, can't use the developers these 10 PCs to run Haskell Parallel Code on demand?
04:47:04 <dcoutts> ChilliX: mm
04:47:13 <Vanadium> Hm, I suppose I will, thank you.
04:47:37 <dcoutts> 47.147.77.124.broad.xw.sh.dynamic.163data.com.cn is downloading the ghc windows exe about 30 times simultaniously
04:48:10 <dcoutts> so almost all 50 download slots are tied up
04:48:32 <Deewiant> Limit the per-host slot usage?
04:48:39 <randomwords> Kill him?
04:48:58 <badsheepy> and all his associates
04:49:04 <themroc-> its maybe a school :p
04:49:20 <themroc-> 1st day: how to install and run ghc :p
04:49:47 <dcoutts> Deewiant: afaik, our apache is too old to do that
04:50:03 <Deewiant> That sucks
04:50:05 <dcoutts> themroc-: seems unlikely with that dns name
04:50:12 <themroc-> hmm true
04:50:19 <dcoutts> so, time for iptables?
04:50:37 <Axman6> hey is youtube really slow for everyone else?
04:51:05 <themroc-> Bell-Northern Research
04:51:13 <themroc-> could be
04:51:31 <leo_> dcoutts, I suggest to wait about 15 minutes and then ban that ip
04:51:38 <themroc-> hmm they have whole 47.* range
04:51:48 <dcoutts> leo_: it's been going on longer than 15 min
04:52:15 <ChilliX> 30x the same exe?
04:54:49 <doserj> themroc-: try the reverse ip...
04:55:00 <themroc-> huh indeed
04:55:16 <themroc-> :p
04:57:14 <dcoutts> ChilliX: I've blocked the ip
04:58:56 <ChilliX> dcoutts: ta
05:11:38 <lilac> the nice thing about blocking chinese ip addresses is you can always blame the chinese government
05:12:08 <quicksilver> lilac: Aha! I've long suspected that dcoutts worked for the chineses government.
05:12:22 <dcoutts> hah hah
05:13:07 <Deewiant> A traceroute will typically tell you whether it's blocked inside or outside your country :-P
05:13:24 <quicksilver> dcoutts on his way to work this morning : http://tonova.typepad.com/photos/uncategorized/2007/05/28/oddjob.jpg
05:14:09 <dcoutts> quicksilver: yes, that's me walking from my living room to my office in the next room :-)
05:14:58 * dcoutts always dresses smartly for the office
05:15:33 <lilac> nice hat. looks dangerous.
05:16:25 <dcoutts> it's annoying when I accidentally embed it in the wall, the landlord really doesn't like it
05:19:04 <Arthur_Rainbow> Hi
05:19:11 <benmachine> hi
05:19:52 <Arthur_Rainbow> I would have a question, does anyone now article about compilation of matching in haskell? I can't find anything, and if I can avoid to go look to source, it would be great since my c is not really good
05:20:18 <abbe> Arthur_Rainbow, compilation of matching ?
05:20:25 <Arthur_Rainbow> yes
05:20:27 <abbe> compiling Regular Expressions ?
05:20:28 <cjs> Is that done in C? I would have thought that it was all Haskell.
05:20:31 <Arthur_Rainbow> well, efficient compilation
05:20:35 <cjs> I think he means pattern matching.
05:20:42 <Arthur_Rainbow> Sorry, Pattern matching
05:21:02 <Botje> Arthur_Rainbow: the book "implementation of functional programming languages" by Simon Peyton-Jones has a _REAL_ good explanation of that.
05:21:08 <Botje> it's freely downloadable, too
05:21:11 <abbe> oh, okay, i'm a new haskell programmer, pattern matching still means regexp patter matching for me :P
05:21:23 <cjs> BTW, there was a good paper on optimization of pattern matching at the ML Workshop at last year's ICFP.
05:21:30 <Arthur_Rainbow> Thanks a lot Botje
05:21:31 <Botje> Arthur_Rainbow: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
05:21:44 <lilac> denotationally, this looks like a correct foldl': "foldl' f a xs = go a xs [] where go a [] ys = foldr seq a ys; go a (x:xs) ys = let a' = f a x in go a' xs (a':ys)"
05:21:55 <Cale> Arthur_Rainbow: The basics of ... I was just going to make Botje's suggestion, but he already made it ;)
05:22:15 <Botje> i'm not sure if the state of the art has advanced much, but that's the basic idea
05:23:10 <Cale> Yeah, the low-level details of it have changed a bit. You might want to read the STG machine paper, and if you're really interested, there's a paper on adding pointer tagging
05:23:40 <Arthur_Rainbow> I work on automated proof, so I don't really now what are good book on compilation. I just know that we use matching, and it seems a good idea to have a look at how matching is done on compiler
05:23:46 <Arthur_Rainbow> in haskell's compiler
05:24:06 <Cale> But the high level details of how to factor complicated patterns into a bunch of simple patterns (where you match one constructor at a time), I don't think have changed.
05:24:11 <lilac> what guarantees does GHC make about the operational semantics of programs? i understand that lazy evaluation is not even guaranteed for parallel programs...
05:25:16 <Cale> lilac: Well... the operational semantics is something which implements the denotational one?
05:26:03 <Cale> I suspect you can't say much more than that really. Strictness analysis means that it's hard to tell ahead of time what order things get evaluated in.
05:26:13 <Cale> It's mostly lazy evaluation, but not entirely.
05:27:47 <gwern> speaking of lazy evaluation, suppose I wanted to lazily do an ascending sort of [1..], so I could do take 1 and get 1; how would I do that?
05:27:57 <gwern> regular Prelude.sort doesn't seem to be lazy enough
05:27:58 <lilac> yeah, that's pretty much what i thought. it's a pity because in my foldl' example it clearly matters a lot
05:28:14 <gwern> (I'm guessing I'd have to do some sort of type-level hackery?)
05:28:29 <lilac> gwern: that list is already sorted, so that sort = id
05:28:50 <gwern> lilac: har har; if if I give it '
05:28:54 <gwern> 4 : [1..]?
05:28:55 <lilac> and if the list isn't sorted, you can't do it, since the least element could be arbitrarily far through the list
05:29:26 <lilac> suppose it were [1..n] ++ [0]
05:29:31 <Cale> gwern: There's no way to tell that there isn't a 0 in that list.
05:29:39 <Cale> gwern: (at runtime)
05:30:08 <lilac> put another way, finding the minimum of n items is an O(n) operation in general
05:30:20 <lilac> if n is not finite, you're in trouble
05:30:31 <Cale> and that's the best lazy behaviour you can hope for in a sort.
05:30:53 <gwern> hm. maybe haskell is too weak as proof language to be as intelligent as a human in saying 'obviously the answer is 1'
05:31:27 <lilac> yeah, if the type of your list included the fact that it's increasing then you're ok
05:31:45 <Cale> gwern: Well, your input is too simple. With a different infinite list, the problem becomes much too hard for humans as well.
05:32:01 <lilac> one could imagine a type of increasing lists, and a ++ which merged such things. but then there's no sort.
05:32:11 <gwern> Cale: why couldn't we expect the language to do as well as the humans?
05:32:13 <lilac> (no sort necessary)
05:32:32 <gwern> (more is unrealistic in general - gravy - but less is bad)
05:32:47 <lilac> gwern: getting a non-_|_ result from that after optimization would indicate a broken optimizer
05:33:02 <lilac> that is, it'd have to be something expressed in the program rather than something done by the compiler
05:33:09 <Cale> gwern: Because humans are willing to apply arbitrary amounts of creativity to the problem, and usually the programs generated by compilers aren't so clever.
05:34:07 <Cale> (The program isn't going to stop what it's doing and be so introspective about its own functioning)
05:35:38 <Cale> Consider the infinite list whose nth element is 1 if iterating the Collatz function on n eventually gives 1, and 0 if it finds another cycle. Sort that list for me, will you?
05:36:16 <lilac> what's the minimum element of [1..n] ++ [0], where n is a lazy Natural?
05:36:18 <gwern> lazy functions can be _|_; that's no surprise
05:36:37 <Cale> No _|_ here.
05:36:54 <Arthur_Rainbow1> cjs, were you speaking of "Compiling Pattern Matching to good Decisions Trees" from Luc Maranger? Or something  else?
05:37:03 <lilac> in particular (in my example), if n = fix succ, both 1 and 0 are reasonable answers
05:37:17 <lilac> (fsvo reasonable)
05:37:31 <Cale> Either the list is equal to repeat 1, or it consists of some finite number of 0's followed by repeat 1, or it's repeat 0.
05:37:43 <Cale> But it's very hard to tell which ;)
05:38:15 <Cale> If you can sort infinite lists, you can solve arbitrary mathematical problems.
05:38:39 <gwern> hm. this funshine deleted the comment I was replying to in between the time I started my reply and submitted it
05:38:42 <gwern> :(
05:38:59 <Cale> (even if you can only access the first element of the sorted infinite list)
05:39:04 <lilac> Cale: i can sort that list. but only into reverse order :)
05:39:09 <Cale> lilac: hehe
05:40:06 <doserj> Cale: that's a bit misleading, I guess. your problem is already difficult for finite n. How about the following: sort the list produced by collatz(n), for some arbitrary n.
05:40:32 <lilac> if you know how the list is constructed, you can sometimes generate something which you can claim is a sorted form of a list.
05:40:54 <cjs> Arthur_Rainbow1: Yes, that's the one.
05:41:25 <Cale> doserj: That's entirely tractable.
05:41:48 <lilac> uh-oh, here comes the spam
05:41:50 <Cale> doserj: You mean sorting take n of the infinite list I described?
05:42:17 <doserj> Cale: no.
05:43:46 <Cale> doserj: Oh, you're allowed to disregard the situation where there's no cycle and the iteration tends to infinity.
05:43:57 <kajamd>  http://www.lostworlds.lv/go.php?1139723800 Helo everybody, this is a new game,come and check
05:44:03 <doserj> Cale: are you?
05:44:14 <Botje> sigh.
05:44:34 <Botje> i wonder if freenode has the resources to introduce a k-line at the repeated mention of a lostworlds.lv link
05:45:12 <Cale> doserj: Yeah, assume that there are none of those :)
05:45:29 <Cale> doserj: If there happens to be one, then I'll let you give _|_ as the result :)
05:45:36 <gwern> Botje: freenode has the resources to kline you for the DCC SEND bug
05:45:42 <gwern> so I rather assume they could do that
05:45:49 <doserj> Cale: :)
05:46:00 <Botje> i've never seen people get klined for that
05:46:21 <gwern> Botje: I know freenode autoklines for that because it happened to me
05:46:38 <Botje> really? wow.
05:46:41 <Arthur_Rainbow1> cjs: Ok, I already new this one, (one of my advisor was in the comitee, and the other was a speacher)
05:46:50 <Botje> did that happen recently?
05:46:57 <gwern> yes; january
05:47:04 <Arthur_Rainbow1> well, thanks a lot, I guess the ook will be really helpfull
05:47:17 <Botje> hmm
05:47:20 <Botje> freenode++, i guess
05:47:31 * gwern hasn't tried since; one 3-week enforced break from IRC taught the lesson quite well - thou shalt not do the dcc send exploit even if you are curious what it looks like
05:48:00 <Botje> now if only they instituted some kind of spammer trap
05:48:58 <Botje> exponentially increase the delay between joining channels for new clients, for example :)
05:49:29 <benmachine> sounds contrived
05:49:51 <Botje> another would be to have a bot sit in some big channels
05:50:13 <Botje> and kline anyone who pastes the same url within a minute more than a certain amount of times
05:51:47 <gwern> that would be a little restrictive, unless it was pasting in multiple channels
05:51:56 <gwern> think of a pastebin bot announcing to #lisp and #scheme, for example
05:52:20 <eevar2> are unregistered nicks allowed to talk here, btw?
05:52:31 <benmachine> whatever you do you're going to run the risk of causing problems for innocents
05:52:50 <benmachine> if you ask me, the problem just isn't large enough to worry about at present
05:53:00 <gwern> benmachine: but it's easy to do way too much damage to innocents
05:53:09 <gwern> eevar2: sure
05:53:21 <benmachine> gwern: it's even easier to do nothing at all :)
05:53:21 <Botje> you could set it in motion only during the holidays
05:53:25 <gwern> no privmsg sessions with lambdabot but that's no surprise
05:53:28 <Botje> when all the idiot spammer kiddies / trolls come out to play
05:53:49 <eevar2> i guess forcing registration wouldn't help. bots can do that as well
05:54:59 <benmachine> what I think would work well is a usermode that censored messages from very new accounts
05:55:39 <benmachine> so high-risk or impatient people can keep things clean while those of us who don't get hit so much can just deal with it
05:57:18 <ksf> people should be k-lined for musing about spam protection when there aren't spammers around.
05:57:29 <benmachine> heh
05:58:18 <gwern> that's a bit harsh. freenode's klines are long, and their tech team vengeful
05:58:24 <mike-burns> The bot should try to detect spam and tell the spammer to take it to #haskell-blah
05:58:42 <Taejo> we could have the channel moderated and everybody gets voice after staying in the channel for a few minutes
05:58:48 <benmachine> no that is insane
05:58:55 <gwern> that's real freidnly...
05:59:08 <Taejo> or they can ask the bot to voice them
05:59:20 <benmachine> also not in the spirit of a support channel
05:59:46 <Taejo> I assumed since everybody was talking about the issue, we were having a major problem
05:59:52 <benmachine> heh
05:59:55 <Taejo> if not, then I agree it's extreme
06:00:08 <benmachine> I don't think the problem is major
06:00:14 <benmachine> in fact I think it's barely a problem
06:00:29 <benmachine> but there's nothing really to stop it becoming so, which I think is what worries people
06:00:38 <leo_> it's possible to use captchas like those at http://random.irb.hr/signup.php
06:01:28 * benmachine giggles
06:01:36 <Taejo> I'd rather ask the bot to voice me than have to use some random captcha site
06:01:54 <benmachine> I'd rather not do any of those
06:02:43 <leo_> a bot could say captcha to you in TeX
06:03:24 <leo_> simple equation or whatever
06:04:04 <leo_> j/k
06:37:57 <zachk> does anyone have any experience getting opengl/glut working with ghc 6.10.x on windows? I have mingw/msys gcc everything is installed it compiles it links, then i get runtime user error dealing with glut. help plz :-/
06:40:13 <sdschulze> An exact description of the error is usually more helpful.
06:42:09 <quicksilver> zachk: I expect you don't have glut itself installed.
06:42:16 <yairchu> zachk: doesn't it come with the Haskell Platform?
06:42:17 <quicksilver> you need something called glut.dll or glut32.dll or something like that.
06:42:23 <maxote> sdschulze, zachk is uncapable of giving you more detailed error, hahaha
06:42:33 <quicksilver> maxote: hush.
06:42:41 <zachk> i have glut installed
06:42:55 <quicksilver> what is the error?
06:42:58 <zachk> ill check out the haskell platform
06:43:07 <quicksilver> could be a freeglut-only message
06:43:19 <quicksilver> some of the stuff haskell glut supports is only, in fact, possible with freeglut
06:43:51 <zachk> Entry Point Not Found: The procedure entry point glutAddMenuEntry@8 could not be located in the dynamic library glut32.dll
06:44:08 <zachk> i tried freeglut i get a similar error message
06:44:33 <quicksilver> that seems very peculiar
06:44:35 <maxote> it's version mismatch
06:44:42 <quicksilver> glutAddMenuEntry is standard - not freeglut only
07:03:40 <benmachine> what's a good way of representing a graph that is essentially a bunch of nodes linked to each other with no overarching pattern or structure
07:04:07 <benmachine> well that is basically a graph I suppose
07:04:31 <benmachine> well it is the London Underground
07:04:33 <quicksilver> it's generally accepted that there is no one best way of representing a graph
07:04:39 <quicksilver> ah well, that's a very small graph
07:04:43 <quicksilver> represent it anyway you want :)
07:04:45 <benmachine> is it?
07:04:55 <benmachine> looks pretty big when I go on it :(
07:05:02 <benmachine> anyway I don't have any good ideas
07:05:02 <quicksilver> in computing terms, yes.
07:05:13 <quicksilver> adjacency lists?
07:05:24 <quicksilver> Data.Map Node [Node]
07:05:29 <quicksilver> map from nodes to lists of neighbours.
07:06:07 <quicksilver> Alternatively, a set of nodes and a set of edges: Data.Set Node, Data.Set (Node,Node)
07:06:21 <benmachine> both good ideas
07:08:48 <randomwords> Could anyone help me try and find the space leak in the following code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3271
07:10:38 <quicksilver> randomwords: what does it show up as on the heap profiles?
07:10:49 <quicksilver> how have you observed the leak? what have you deduce so far?
07:11:16 <randomwords> Sure
07:11:32 <randomwords> the heap profiles basically show that none of lists are being released after they are computed
07:11:42 <jkff> randomwords: Does it GC like crazy, or does it exit with an out-of-memory error?
07:11:47 <randomwords> i.e. in main, after 1 is printed that list is not released
07:12:03 <randomwords> Does that make sense?
07:12:33 <randomwords> it's clearly never used again
07:12:54 <jkff> Probably it is not freed because there's no need to free it, t.i. no memory pressure
07:13:03 <randomwords> if I compile without the "`using`  parListChunk chunksize rnf" then there isn't a leak
07:13:15 <randomwords> jkff GC
07:13:19 <randomwords> I think
07:13:43 <quicksilver> that sounds almost like some sparks are getting sparked and keeping things live and never getting GCed correctly
07:13:44 <jkff> Does running with +RTS -s reveal a large GC time?
07:13:48 <quicksilver> which would be a bug, if true
07:14:04 <randomwords> jkff: yess
07:14:21 <randomwords> jkff: But if I compute lots of these lists then it just crashes my system
07:14:29 <randomwords> so I don't think it's being GC'd correctly
07:14:50 <jkff> What influence does changing chunkSize have on the program behavior?
07:14:57 <jkff> That should reveal a lot
07:15:00 <quicksilver> your instance of NFData for CDouble looks wrong, by the way
07:15:05 <quicksilver> but that would crash, if it mattered.
07:15:27 <gwern> quicksilver: there's an existing ghc bug about sparks not getting gced
07:15:30 <gwern> I ran into it recently
07:15:37 <pozic> jkff: in theory bigger should be better, but in practice it doesn't work.
07:15:51 <quicksilver> gwern: interesting. Could be that. Do you have a trac?
07:16:06 <gwern> I'm sure it's somewhere on the trac
07:16:21 <gwern> but I'm going to bed now so you'll have to find it yourself
07:16:44 <randomwords> quicksilver: changing the instance for NFData won't affect this I believe, but could you explain how it's wrong, I just chucked it on there due to the recent OpenGL changes
07:17:45 <quicksilver> randomwords: what you have written is equivalent to instance NFData CDouble where rnf = error "help help my head asplode"
07:17:51 <quicksilver> randomwords: I don't think that's what you meant :)
07:18:12 <quicksilver> Could your original space leak bug be this: http://hackage.haskell.org/trac/ghc/ticket/2185 ?
07:18:26 <randomwords> quicksilver: Oh - I just sort of assumed that CDouble was primitive enough to already by in some sort of nf
07:19:23 <quicksilver> randomwords: Nope.
07:19:31 <quicksilver> randomwords: instance NFData Double where rnf = seq
07:19:44 <randomwords> jkff: Chaing the chunk size does nothing really - any gain/loss is overshadowed by this bug
07:19:44 <quicksilver> randomwords: even if it *was* already in nf, you'd want "where rnf = id"
07:19:53 <randomwords> quicksilver: Hmm - yeah
07:20:05 <quicksilver> randomwords: you really don't want "where rng = error "asploding head""
07:21:27 <randomwords> It looks like that ticket could be my bug
07:21:36 <randomwords> doesn't give me much hope of fixing it
07:21:52 <quicksilver> no. You could try to collar JaffaCake1 to discuss your issue with him sometime
07:21:56 <quicksilver> he might know what the workaround is
07:22:35 <randomwords> it's not urgent
07:24:20 <randomwords> just irritating
07:25:05 <LeCamarade> I have a worrying wee behaviour. On FreeBSD, Network.connecTo doesn't work! :-o
07:26:15 <galdor> does someone here know HDBC ?
07:26:33 <galdor> I'm trying to use Binary.encode to encode some data and put them in a BLOB field using HDBC
07:26:58 <galdor> but the SqlByteString constructor takes a strict ByteString, while Binary.encode yields a lazy one
07:27:21 <galdor> is there a way to pass from on to another ?
07:28:01 <galdor> I saw the Data.ByteString.Lazy.toChunks function but it yields a list of strict bytestrings
07:28:08 <galdor> I only want a single one
07:28:41 <quicksilver> concat it then.
07:29:07 <galdor> I'm not sure it does what I want
07:29:21 <quicksilver> it does
07:29:25 <quicksilver> well, it does what I think you want.
07:29:34 <galdor> ok, gonna try it
07:29:52 <koeien> S.concat . L.toChunks  :)
07:49:14 <galdor> ok didn't read that HDBC already handles lazy bytestring with toSql
07:49:18 <galdor> thank you anyway :)
07:50:39 <randomwords> quicksilver: In the source of strategies the instances for NFData of all the atomic types are just "instance NFData T". So what do I want the rnf for a Ctype to be?
07:51:49 <quicksilver> randomwords: hmm really, thats odd
07:52:23 <quicksilver> randomwords: OH!
07:52:31 <quicksilver> randomwords: it has a default :)
07:52:39 <quicksilver> it defaults to seq.
07:52:43 <quicksilver> well, rwhnf
07:53:00 <jeffersonheard> so I note that StorableArray says that it's slower than IOUArray (but compatible with C).  How much slower is slower?  If I'm doing multiple operations on a 10.8 megapixel RGB96 image does it make sense to copy it out first into an immutable unboxed array?
07:53:00 <randomwords> and whnf = nf for atomic types
07:53:00 <lambdabot> jeffersonheard: You have 1 new message. '/msg lambdabot @messages' to read it.
07:53:32 <randomwords> Ah Ok - I'm there now.
07:54:24 <randomwords> Any idea if whnf = nf for Ctypes?
07:54:40 <xkkc> Hi. Has anyone had any luck getting SciTe to work with Haskell?
07:54:44 <EvilTerran> yeah
07:54:58 <quicksilver> randomwords: yes, it does.
07:55:04 <EvilTerran> i think there's a highlighting file for haskell on scintilla.org
07:58:15 <randomwords> hmpff. Bring on 6.12 then
08:01:51 <QP> hmmmm... i have a question about polymorphic functions...
08:02:01 <QP> if I write this:
08:02:38 <QP> foo :: (Num a) => (a -> b) -> String -> b
08:02:42 <copumpkin> :o
08:02:43 <QP> what does it mean?
08:03:08 <copumpkin> foo f xs = f (genericLength xs)?
08:03:34 <copumpkin> it means if you give a function that takes any Num instance and returns a b value, and a string, it'll give you a b value
08:04:13 <QP> so foo f xs will work for any fuction f that works on all Nums?
08:04:20 <randomwords> Interesting - I don't seem to get the same error if I use parList instead of parListChunk
08:04:34 <pikhq> QP: Right.
08:05:38 <QP> ok, that's good
08:05:56 <copumpkin> QP: note that the b there could also be another function
08:06:04 <QP> yeah
08:06:15 <QP> for some reason i thought it meant something else
08:06:32 <copumpkin> even the a there could be a function, but it's very unlikely for it to be :P
08:07:04 <QP> could make a Num instance for (Int -> Int)
08:07:19 <pikhq> @src Num
08:07:20 <lambdabot> class  (Eq a, Show a) => Num a  where
08:07:20 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:07:20 <lambdabot>     negate, abs, signum     :: a -> a
08:07:20 <lambdabot>     fromInteger             :: Integer -> a
08:07:35 <pikhq> Could you make all of those functions make sense for (Int -> Int)?
08:07:38 <copumpkin> you could make an easy Num instance for (a -> Int)
08:07:41 <QP> hmmm, abs and signum are always a problem
08:07:53 <PeakerWork> QP: How do you implement Eq for (a -> Int) ?
08:07:59 <PeakerWork> copumpkin: ^^
08:08:07 <randomwords> quicksilver: parList won't cause a leak, but parListChunk will cause a leak even with a chunksize as low as 2 (even with chunksize = 1)
08:08:07 <QP> I don't think you can!
08:08:22 <QP> PeakerWork: good point!
08:08:24 <copumpkin> PeakerWork: you pass () to both things and see if the output is equal
08:08:49 <QP> what?
08:08:51 <copumpkin> :t const (5 :: Int)
08:08:53 <lambdabot> forall b. b -> Int
08:09:00 <copumpkin> :t const (5 :: Int) 7
08:09:02 <lambdabot> Int
08:09:03 <Quantumplation> Ello.  Is there any way to construct a list comprehension to produce a [(Int,Int)] where the second number is always the first plus 17?
08:09:14 <EvilTerran> Quantumplation, yes
08:09:41 <QP> quantumplate it a bit, and it will come to you :-)
08:09:41 <Raevel> > [(x,x+17) | x <- [1..10]]
08:09:42 <copumpkin> instance (Num a) => Num (b -> a)
08:09:43 <lambdabot>   [(1,18),(2,19),(3,20),(4,21),(5,22),(6,23),(7,24),(8,25),(9,26),(10,27)]
08:10:11 <PeakerWork> copumpkin: what if b=Void? that's forall b. not an exists b. no?
08:10:12 <EvilTerran> > [undefined | False] -- pathological example
08:10:13 <Quantumplation> ah ^^ x+17.  Was trying to do y, y<-[x+17] or some such hehe.
08:10:14 <lambdabot>   []
08:10:36 <copumpkin> PeakerWork: I thought you couldn't have a real Void in haskell
08:10:49 <PeakerWork> copumpkin: newtype Void = Void Void   ? :-)
08:10:59 <copumpkin> Peaker: that's inhabited by one value
08:11:02 <copumpkin> which I could just pass in and ignore
08:11:21 <EvilTerran> "data Void" is inhabited by one value, too
08:11:26 <PeakerWork> copumpkin: yeah, you can pass bottom in, but that's not very interesting..
08:11:30 <copumpkin> yup
08:11:31 <EvilTerran> (bottom, in both cases)
08:11:32 <copumpkin> bbl
08:11:41 <copumpkin> actually
08:11:45 <quicksilver> is it a value though?
08:11:54 <copumpkin> all I meant is that you could define meaningful instances for a -> Int :P
08:12:00 <EvilTerran> quicksilver, well, that depends entirely on how you define "value" :P
08:12:02 <copumpkin> because it's essentially isomorphic to Int
08:12:14 <quicksilver> EvilTerran: indeed.
08:12:26 <QP> why is it isomorphic to Int?
08:12:53 <copumpkin> instance (Eq b) => Eq (a -> b) where f == g = f () == g ()
08:13:03 <EvilTerran> copumpkin, that wouldn't work
08:13:04 <QP> surely (a -> Int) is like, a proper class, while Int is countable!
08:13:09 <EvilTerran> surely
08:13:14 <copumpkin> EvilTerran: undefined, then
08:13:18 <copumpkin> :P
08:13:35 <EvilTerran> it'd work for "instance Eq n => Eq (forall a. a -> n)"
08:13:39 <Plouj> yo
08:13:49 <Plouj> does anyone of you use Haskell in their job/career?
08:13:58 <copumpkin> ah yeah, I thought the foralls were implicit there, since the a didn't come from anywhere else
08:14:15 <copumpkin> I am assuming that the function is total, I guess
08:14:19 <Dib> Plouj, I'm just /now/ trying to learn how to use it.
08:14:32 <arsenm> hi. I'm having trouble figuring out how to use Data.Map.map in parallel
08:14:36 <EvilTerran> copumpkin, i think there's a contravariance hiding somewhere
08:14:50 <copumpkin> hm
08:15:06 <copumpkin> anyway, will bbiab :)
08:15:14 <EvilTerran> copumpkin, in that, in the body an instance forall a, you've got an existental a.
08:15:20 <EvilTerran> *the body of an
08:18:07 <QP> copumpkin: isn't your Eq instance a bit of a cheat, because you could have f == g but f 1 /= g 1, for example
08:18:18 <QP> ?
08:18:48 <QP> of course, it's then impossible to create a 'real' Eq instance
08:31:11 <EvilTerran> QP, but if (f undefined == g undefined) is defined, then either f and g are non-strict in their parameter, or (==) is
08:31:37 <EvilTerran> in the first case, f undefined == f 1, likewise g
08:32:11 <hackagebot> Hieroglyph 3.85 - Purely functional 2D graphics for visualization. (JeffersonHeard)
08:32:29 <EvilTerran> and i'd expect (==) to be at least partially strict in its parameter, so i'll ignore the second case :P
08:32:33 <randomwords> quicksilver: Sorry to pester you again - any ideas why parList works, but parListChunk doesn't
08:33:20 <quicksilver> randomwords: your radiator is full of jam
08:34:08 <randomwords> I.. see..
08:34:15 <quicksilver> randomwords: no, I have no idea.
08:34:51 <randomwords> OK - I'll consult the ouija board
08:37:59 <jeffersonheard> newest update to Hieroglyph just changes dependencies so that they're clean.  Sven's latest GL update broke Hieroglyph
08:38:37 <QP> EvilTerran: why is copumpkin defining (==) in terms of something undefined, isn't that even more of a cheat?
08:38:52 <copumpkin> well apparently what I wrote doesn't even work
08:38:58 <copumpkin> but yeah, it was meant to be a cheat in the first place :P
08:39:24 <copumpkin> my thinking was that the only meaningful functions a -> Int were of the form const (x :: Int)
08:39:27 <randomwords> jeffersonheard: It broke a lot of packages apparently
08:39:29 <copumpkin> that is, they had to ignore their first arguments
08:39:48 <copumpkin> but seq breaks that for example
08:40:05 <ksf> uhm, how?
08:40:20 <ksf> ...without using any dirty impurities, that is.
08:40:22 <QP> ah, so an element of type (a -> Int) is a function defined on absolutely everything, returning an Int
08:40:43 <copumpkin> moo x = x `seq` (1 :: Int)
08:40:47 <QP> so that's why you said it was basically isomorphic too Int
08:41:00 <copumpkin> yeah, except it isn't if you introduce dirtiness :P
08:41:00 <ksf> that's not a -> Int, that's Int -> Int
08:41:15 <ksf> oh wait
08:41:16 <copumpkin> :t let moo x = x `seq` (1 :: Int) in moo
08:41:16 <quicksilver> :t \x -> x `seq` (1::Int)
08:41:18 <lambdabot> forall a. a -> Int
08:41:19 <lambdabot> forall a. a -> Int
08:42:03 <ksf> still, denotationally, it's const.
08:42:13 <QP> so seq is an impure function
08:42:16 <copumpkin> except for undefined
08:42:28 <copumpkin> > let moo x = x `seq` (1 :: Int) in moo undefined
08:42:30 <lambdabot>   * Exception: Prelude.undefined
08:43:23 <ksf> only pure up to bottoms, yes.
08:43:39 * copumpkin always keeps his bottoms pure
08:43:40 <jeffersonheard> randomwords: I think it's a good update nonetheless.  Just has a few kinks to work out.  Turns out that Double is no longer a valid GL ComponentType
08:43:45 <QP> but if you beleive in a sufficiently powerful axiom of choice you have to consider the existence of non-trivial (forall.a -> Int)
08:44:00 <copumpkin> how so?
08:44:25 <jeffersonheard> What's the recommended boxed immutable array package?  Data.Array.Diff, or... ?
08:44:26 <QP> what is the cardinality of the set of all possible haskell values?
08:44:39 <jeffersonheard> if I want an array of colours, for example
08:44:50 <jeffersonheard> Data.Colour.Colour Float, rather
08:45:17 <ksf> jeffersonheard, [: Float :] ?
08:46:03 <ksf> ...ah you said boxed.
08:46:25 <jeffersonheard> ksf: I specifically want to use the Data.Colour package for everything...  I suppose I could use Data.Bijection over unboxed float arrays, parallel or otherwise, but I was thinking of actually using Data.Colour.AlphaColour on the backedn
08:46:38 <copumpkin> where's Data.Bijection?
08:46:46 <jeffersonheard> copumpkin: TypeCompose
08:46:51 <copumpkin> thanks :)
08:48:30 <deech> Hi all,
08:48:30 <jeffersonheard> I suppose the question would be what are the tradeoffs in terms of speed and complexity in terms of using the boxed representation as opposed to four unboxed C-Compatible float arrays
08:49:00 <jeffersonheard> and give a "public" interface to the underlying collection via the Bijection between the underlying type and Data.Colour.AlphaColour
08:50:12 <deech> I am building a Haskell app for the Mac. It requires a GUI and I wondering if GTK2hs was still the preferred binding. Also once it is built, can I just pack it up into a statically compiled binary and distribute it without the client having the C++ libs?
08:50:45 <PeakerWork> what's C++ about gtk/gtk2hs?
08:51:26 <dcoutts> deech: it's typical to distribute the Gtk+ C shared libs, rather than statically linked. It's much easier to comply with the LGPL that way.
08:51:37 <deech> PeakerWork, I meant the .so libs.
08:51:50 <PeakerWork> deech: I think they're C
08:52:04 <deech> dcoutts, so include it in the same tar archive as my binary?
08:52:20 <copumpkin> deech: if you're making a mac app
08:52:22 <dcoutts> deech: yes (or installer)
08:52:27 <copumpkin> it's much more common to include the libraries in your .app bundle
08:52:36 <jeffersonheard> deech: what of the extensions are you planning on using?
08:52:42 <Nafai> dcoutts: How hard would it be to wrap webkit-gtk?  And is that something the falls under gtk2hs?
08:52:53 <jeffersonheard> I would warn against Gtk2Hs only if  you're planning on using OpenGL
08:53:20 <dcoutts> jeffersonheard: really? it works with GL nicely for me. Or is there an OSX-specific issue?
08:53:28 <jeffersonheard> OSX specific
08:53:56 <dcoutts> Nafai: in principle it's doable and you could start with the gtk2hs code gen. Ideally we'll make gtk2hs less monolithic so you can depend on gtk package without having to bundle it in gtk2hs.
08:54:00 <jeffersonheard> dcoutts: the native Gtk toolkit doesn't support the GL extension, and the X11-based toolkit doesn't support it well
08:54:08 <deech> jeffersonheard, ummm, if you mean languague pragmas, none that know of. Are there extensions I shouldn't be using?
08:54:10 <dcoutts> jeffersonheard: ah, that's a shame
08:54:20 <randomwords> jeffersonheard: What would you use instead?
08:54:26 <dcoutts> it works nicely on linux and windows
08:54:48 <Nafai> dcoutts: Good to know.  It's just an idea that's bouncing around the back of my head
08:54:56 <jeffersonheard> dcoutts: totally not the fault of Gtk2Hs, either -- it seems to be a Gtk problem.  it works wonderfully on Linux and Windows.  I just can't support The Big Boad on OSX.
08:54:57 <Nafai> But my next project will involve Cairo
08:55:19 <jeffersonheard> Nafai, what are you planning on doing in Cairo?
08:55:40 <copumpkin> visiting the pyramids
08:55:47 <jeffersonheard> randomwords: That's just it, I don't know any good alternatives.  Gtk2Hs is the most well-documented and mature toolkit for GUIs on Haskell
08:56:26 <jeffersonheard> The only problem with it on all platforms is its lack of support for threaded application models (which can be worked around, but it's not a lot of fun, esp. if you're using dialogs)
08:57:11 <jeffersonheard> randomwords: if I was going to use GL, I'd do the GL part of the GUI using GLUT and skip the Gtk GL extension.  Means you can't have the whole app in a single window, but that's not a horrible tradeoff
08:57:49 <quicksilver> wx is a possible alternative as a GUI library which supports opengl
08:57:55 <quicksilver> and works on all three platforms
08:59:26 <deech> quicksilver, have you used wxHaskell for a project?
09:01:21 <quicksilver> deech: only a very small experiement.
09:01:23 <quicksilver> it seemed OK.
09:03:12 <Nafai> jeffersonheard: I'm wanting to make a graphical shell for GHCI
09:03:29 <deech> quicksilver, I was a little turned off when the Haskell wiki characterized installing wxWidgets as "a developers nightmare".
09:03:43 <quicksilver> deech: weird.
09:04:06 <quicksilver> deech: if typing configure;make;make install is a nightmare then maybe software development isn't for you :)
09:04:14 <quicksilver> it seemed pretty easy to me, as far as I can remember
09:04:18 <quicksilver> (was a while ago)
09:05:17 <deech> quicksilver, not really afraid of getting it to work, more afraid of distributing the app to macs I have no control over.
09:06:19 <copumpkin> mac apps are typically self-contained .app files which can bundle their own dependencies with them
09:06:36 <copumpkin> folders, really
09:07:55 <quicksilver> deech: I don't really know how to build .app bundles but AFAIK you just shove all the wx stuff inside my.app/Content and bob is your mother's brother.
09:08:10 <quicksilver> there might be some details about getting paths right but I doubt it's too stressful.
09:08:17 <jeffersonheard> Nafai: Sounds like Gtk2Hs is the way to go, then...
09:09:13 <Nafai> jeffersonheard: Yeah, and I'm on Linux so gtk2hs works well.  It's sad that it doesn't work better on OS X :(
09:16:58 <jeffersonheard> does anyone know if the wxcore/wx packages are threadsafe?
09:20:24 <jeffersonheard> hrm..  well, since it depends on stm, I'd say it must be
09:27:27 <quicksilver> jeffersonheard: I doubt you can call GUI calls from multiple threads, if that's what you mean.
09:27:39 <quicksilver> jeffersonheard: hardly any GUI library supports that :)
09:31:21 <ksf> agar does.
09:31:31 <ksf> at least the devs claim it to be completely threadsafe.
09:31:55 <ksf> they're also saying that they never test it 'cos its an insane thing to do, though.
09:33:29 <quicksilver> that's cool.
09:33:38 <quicksilver> you can do it naively by mutexing the entire GUI core, of course.
09:34:05 <quicksilver> but you still have to think carefully about callbacks and re-entrance.
09:34:08 <ksf> nah they've implemented an object system in c, which includes fine-grained locking.
09:34:30 <quicksilver> the semantics of re-entrance are so unclear that I personally think it's saner to mandate single-threaded GUI calls
09:34:32 <jeffersonheard> I don't know why people think it's an insane thing to do -- it's really not at all.  I mean, Java's supported it since forever, and really if you look at GUIs as reactive models, reactive models are pretty much all natively concurrent
09:34:58 <quicksilver> but it would be nice if the type system enforced it.
09:34:59 <pikhq_> jeffersonheard: It's because people are used to languages with terrible threading primitives.
09:35:08 <ksf> iirc correctly agar only re-enters from one main thread, ever, passing messages internally.
09:35:32 <pikhq> jeffersonheard: Namely, most languages. ;)
09:35:38 <quicksilver> jeffersonheard: the list of bugs in the java gui toolkit(s) caused by it not being threadsafe even though it was claimed to be is so long that if you started reading it now, you'd still be reading at christmas.
09:35:45 <quicksilver> jeffersonheard: java's thread system was very nearly a train wreck.
09:36:04 <ksf> i've given up on agar as soon as I realized that it makes absolutely no sense to bind to a library which has functionality like interpreting a byte as 8 radio buttons.
09:36:05 <jeffersonheard> quicksilver: yeah, well... *looks around shiftily*
09:36:31 <quicksilver> jeffersonheard: to be fair, that's FUD. I don't really know how long the list is.
09:36:31 <pikhq> ksf: I, uh. Wow.
09:36:46 <pikhq> I suspect the bindings would be about as long as the library itself?
09:36:54 <quicksilver> but java's thread system was what introduced a whoel generation of programmers to the notion that "Easy threading" isn't.
09:37:00 <ksf> but then, if you're doing a gui for something embedded, it's the perfect choice.
09:37:04 <jeffersonheard> quicksilver: you're right to a degree. The core of Swing is pretty threadsafe.  But only the core
09:37:28 <quicksilver> what you need, for a thread system, is for almost everything to be immutable.
09:37:32 <quicksilver> (and thus safe to share)
09:37:34 <quicksilver> haskell ftw.
09:38:18 <jeffersonheard> quicksilver: I totally agree with you there.  Java.Object.wait and yield methods alone are a nightmare
09:38:19 <pikhq> quicksilver: That's not the holy grail, but it sure seems like it to anyone's that tried doing threads in C.
09:39:06 <periodic> quicksilver: you still need stuff like STM and critial blocks, because even if the language looks immutable, the underlying hardware isn't treating it that way.
09:39:31 <quicksilver> pikhq: it's might not be the holy grail, but it is at least the bridge over the hellespont
09:39:34 <quicksilver> pikhq: so to speak :)
09:39:36 <jeffersonheard> quicksilver: Smalltalk and Self's GUI models were fully asynchonous to the core years ago. It just afaik requires a thread-safe message queue
09:39:38 <pikhq> quicksilver: :)
09:40:11 <pikhq> jeffersonheard: Yeah, but that's Smalltalk. The language that did OO right. ;)
09:40:15 <ksf> well, it seems we're all still waiting for conal to get reactive done.
09:40:15 <quicksilver> jeffersonheard: I don't think that asynchrony saves you from the serious invariance bugs cause by re-entrance.
09:40:26 <periodic> Threading is a bridge into hell, as far as I've been taught...
09:40:43 <pikhq> periodic: foo `pseq` bar -- What's so hard about that?
09:40:45 <pikhq> >:D
09:41:06 <quicksilver> jeffersonheard: if you call a piece of code frmo a place where you have temporarily violated an object invariant... and that code causes a callback so some of your other code runs while the object is in inconsistent state
09:41:10 <quicksilver> *bang*
09:41:29 <quicksilver> so you need a way to make sure that all potentially re-entering calls are never made when any object is in invariant state
09:41:34 <jeffersonheard> quicksilver: if you implement GUIs using callbacks as opposed to message passing
09:42:23 <jeffersonheard> if the GUI runs in a single thread and only communicates with the rest of the program via "mailboxes" a la erlang or smalltalk, then I would think that sufficient to ensure such bugs never happen.
09:42:48 <periodic> I'd say that data invariance makes _reasoning_ about threading easier, but the same tricks need to be applied.
09:42:52 <Nafai> jeffersonheard: Are "mailboxes" some kind of message queue?
09:43:01 <doublethink_work> yay!
09:43:14 * doublethink_work is thoroughly happy that he can just 'cabal install darcs' these days, even on windows
09:43:19 <jeffersonheard> Nafai: I forget which language introduced them with that particular name, but that's the idea.
09:43:33 <ksf> jeffersonheard, tell that X, firefox, xmonad and those other programs fightening for focus occasionally.
09:43:39 <ray> doublethink_work: but still no gtk :(
09:43:55 <doublethink_work> ray: true :(
09:44:08 <Nafai> Interesting.  This would be something that would have to be supported directly by the toolkit, or is this something you could abstract away and use with gtk2hs, for example?
09:44:13 <jeffersonheard> quicksilver: am I missing something, or are we talking past each other?
09:44:16 <ray> speaking of that, how do i manually register gtk2hs with the ghc from haskell platform
09:44:22 <doublethink_work> ray: in particular I wanted to give the pango-version of yi a spin, but it seems like gtk2hs has been compiled against 6.10.3, not 6.10.4, which comes with the latest haskell-platform :(
09:44:39 <ray> it wouldn't even work with the last platform, but i just don't know how to register it
09:44:40 <ksf> I thought threading was managable, until I found myself debugging race conditions between my code and the X server...
09:44:51 <jeffersonheard> ksf...  ow.
09:44:51 <ray> i suppose i could try building it
09:45:05 <Nafai> Building gtk2hs isn't too difficult
09:45:06 <doublethink_work> ray: i'm not sure what the steps are for building on windows
09:45:11 <doublethink_work> ray: you probably need msys at the very least
09:45:15 <Nafai> At least on Linux :)
09:45:22 <doublethink_work> Nafai: precisely :)
09:45:37 <ray> i don't want to cripple my computer just to get simpler build processes though :)
09:45:44 <jeffersonheard> ray: use ghc-pkg register
09:45:56 <jeffersonheard> you should find the file to work on in the directory where gtk2hs was installed.
09:46:09 <ksf> I guess it's the same as writing a network layer: I've heard that the authors of the linux one tried it out with a couple of boxes at home, observed it to be flawless, moved a machine into the university net and saw it crashing immediately.
09:46:13 <jeffersonheard> incidentally, if you want to install Gtk2Hs with the Haskell Platform on Windows, you have to do this right now
09:46:30 <jeffersonheard> because Gtk2Hs will not find GHC where the Haskell Platform installer puts it
09:46:31 <Nafai> The one thing that always bugs me about GUI programming is that it just doesn't feel elegant, there is always a ton of boilerplate feeling code
09:46:36 <Nafai> Even in Haskell
09:46:40 <ray> what file am i looking for, this .lib stuff?
09:46:49 <doublethink_work> Nafai: which is why we're all waiting for reactive :)
09:46:50 <ray> yeah, gui libraries are annoying like that.. but then again, so is curses
09:47:22 <Nafai> doublethink_work: Indeed.  Though I admit I haven't yet fully groked reactive stuffs
09:47:26 <ray> reactive-curses would be cool
09:47:35 <jeffersonheard> Nafai: yes, that's true.   Grapefruit seems to do a nice job if the only reactive part of your program is the GUI
09:47:37 <Nafai> I haven't yet used a GUI framework that feels comfortable.
09:47:48 <ray> it's a common problem
09:47:51 <jeffersonheard> I use Buster, but then again I wrote it.
09:47:53 <Nafai> And I've used OWL, VCL, gtk, Swing, SWT
09:47:57 <ray> i mean even network sockets are like that in C :)
09:48:02 <Nafai> jeffersonheard: URL for Buster?
09:48:07 <doublethink_work> @hackage buster
09:48:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/buster
09:48:14 <jeffersonheard> Buster is just the reactive toolset, though
09:48:18 <Nafai> I like the event based model for sockets like what is in Twisted for Python
09:48:24 <jeffersonheard> it's not got a GUI in it natively
09:48:27 <doublethink_work> hm, @hackage should probably be updated to use the new shorter URLs
09:48:29 <ray> event based? is it anything like reactive?
09:48:35 <doublethink_work> e.g. http://hackage.haskell.org/package/buster
09:48:35 <jeffersonheard> I interface it like Gtk.
09:49:05 * Nafai reads about Buster
09:49:11 <jeffersonheard> It's a bit like it in the idea that it's continuous-time based and that there's a global message space
09:50:25 <jeffersonheard> but it's also IO based and uses a "real" time value as opposed to some virtual continuous time.  I wrote it to orchestrate The Big Board, which is the largest GUI app I've written with Haskell to date
09:51:16 <jeffersonheard> Honestly, I tend to like Conal's toolkit better in terms of its purity, but I find that mine is faster to write code for.
09:53:26 <Nafai> What's "The Big Board"?
09:53:38 <Nafai> I'm going to be doing some GUI programming again soonish in Haskell so I'm curious about this stuff
09:53:40 <burp> http://paste.railsbox.eu/show/J3Nc3FIt8gPqR5rWVJiV/ <- why does this take excessive memory when used with a huge list (~20MB of data)
09:53:50 <burp> I'm already using foldl'
09:54:16 <jeffersonheard> Nafai: quick Buster example at http://vis.renci.org/jeff/2009/07/09/a-quick-buster-example/.  also go to the previous post which explains what the application is
09:54:26 <jeffersonheard> oh, and the big board is something I'm giving a talk on at CUFP
09:55:09 <Nafai> Cool.  Too bad I can't go to CUFP
09:55:22 <jeffersonheard> It's a sort of teleconferencing system for maps.  There's a shared map between people in the same conference room, and
09:55:40 <jeffersonheard> on the backend, a wiki
09:56:07 <jeffersonheard> participants in the conference room can add content by drawing on the map and then linking the drawings to wiki pages (in a single keystroke)
09:56:28 <jeffersonheard> or to the greater web
09:56:48 <jeffersonheard> and can add web-services that serve up content in WKT format.
09:57:09 <ray> and you can't let anyone see it
09:57:24 <Nafai> Cool
09:57:42 <jeffersonheard> I can, actually.  I'm about ready to.  I have a production server with 87/100 counties up and running, and I have the code debugged except for a race condition to do with dialogs
09:57:53 <Nafai> At a previous job I did a bit with map related stuff.  It was fun, though it was with Java.
09:58:05 <jeffersonheard> as soon as the race condition is fixed and I get the okay from my boss, I'll release the app to the public.
09:58:34 <jeffersonheard> I'll be showing it off at CUFP
09:59:10 <Nafai> I hope there are videos, I'll be interested in seeing it
10:00:37 <burp> 141,172,016 bytes maximum residency for 500k values :|
10:06:09 <copumpkin> maximum residency?
10:06:24 <copumpkin> burp: you mean the output from :set +s in ghci?
10:06:38 <burp> yes
10:07:11 <copumpkin> is ghci using that much memory?
10:07:22 <copumpkin> because I didn't think that's what the memory measurement meant
10:07:22 <burp> um sorry, it's from +RTS -s
10:07:34 <copumpkin> I've had it spit out impossibly large numbers
10:07:44 <copumpkin> I assumed it was the total allocation amount
10:07:53 <burp> I think I'm having a problem with lazyness http://paste.railsbox.eu/show/J3Nc3FIt8gPqR5rWVJiV/
10:08:48 <skorpan> why fromIntegral on length?
10:08:52 <skorpan> :t length
10:08:53 <lambdabot> forall a. [a] -> Int
10:09:05 <cwraith> grr Int
10:09:13 * cwraith growls at it some more
10:09:44 <burp> I need it as double in std
10:09:44 <burp> and in "std" there is the problem ;)
10:09:58 <skorpan> burp: not that this is your problem, but you should really factor out "sqrt ..." into a separate function
10:10:11 <skorpan> i'm guessing this is the standard deviation?
10:10:14 <burp> yes
10:11:35 <skorpan> burp: did you try it using stddev?
10:11:44 <skorpan> which is also in Math.Statistics
10:11:45 <burp> from http://hackage.haskell.org/packages/archive/hstats/0.3/doc/html/Math-Statistics.html ? yes
10:11:53 <burp> it has the same problem of excessive memory usage
10:12:28 <c_wraith> from a stddev calculation?  That's unusual.
10:12:42 <burp> I can give you my sample file if you want ;)
10:13:07 <jeffersonheard> is there a decent tutorial out there for how to use the ST monad?
10:13:41 <copumpkin> burp: are you sure you're interpreting the memory consumption correctly?
10:13:42 <c_wraith> I'm assuming it's a few million entries, burp?
10:13:58 <jeffersonheard> Really the only one left I really can't wrap my head around.
10:14:04 <burp> copumpkin: absolutely
10:14:06 <copumpkin> burp: have you actualy verified that the process uses that much memory?
10:14:07 <burp> c_wraith: yes
10:14:13 <copumpkin> ok
10:14:23 <burp> yup, top says the same
10:14:25 <burp> http://tobias-neumann.eu/tmp/vx_16k.gz
10:15:44 <c_wraith> I can't see anything wrong with the algorithm in the statistics package that'd cause it to hold on to memory
10:16:54 <c_wraith> though it's not capable of being lazy
10:17:14 <c_wraith> does GHC optimize tail recursion properly?
10:17:25 <burp> I used -O2
10:17:50 <c_wraith> Oh.
10:17:55 <burp> but same without
10:18:02 <c_wraith> because of the length call, it has to keep the entire list in memory
10:18:11 <burp> its not that
10:18:19 <c_wraith> how big does it get?
10:18:19 <burp>     let vals = take (10^6) $ map (read) (lines f) :: [Double]
10:18:19 <burp>     print $ stddev vals
10:18:23 <burp> try just these two lines
10:18:28 <burp> 390,759,048 bytes maximum residency
10:18:34 <burp> Stack space overflow: current size 8388608 bytes.
10:18:41 <burp> it can't even finish the whole vx_16k file
10:19:04 <burp> you can remove the take (10^6) ;)
10:19:24 <jeffersonheard> um...  well, there's no reason in the world a standard deviation should require mosre than virtually constant space.
10:20:22 <Philippa> non-strict accumulators'll do it :-(
10:20:24 <Makoryu> @pl \(t, l) n -> (t + n, l + 1)
10:20:24 <lambdabot> uncurry ((. (1 +)) . flip . ((,) .) . (+))
10:20:49 <jeffersonheard> there's a post out there somewhere called "beautiful folding" that describes a composable folding monad.  It would let you calculate arbitrary collection statistics and collect them all as a single-pass function
10:21:06 <jeffersonheard> collect them all into a single-pass function, rather
10:21:27 <c_wraith> the algorithm in the statistics package is dual-pass, unfortunately.
10:21:46 <jeffersonheard> guess it's roll-your-own time :-/
10:21:48 <burp> I tried to use foldl'
10:22:44 <c_wraith> so, almost 2 million double entries...
10:23:28 <burp> yes
10:24:03 <c_wraith> I don't know how big things in memory for haskell are, but a double is at least 8 bytes, and a cons cell is at least 4 (on a 32-bit machine)
10:24:18 <c_wraith> But that's still rather short of 800 megs
10:24:37 <burp> it uses more than 800megs ;)
10:24:41 <jeffersonheard> burp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8074#a8074
10:25:10 <burp> um, some tricky stuff?
10:25:22 <jeffersonheard> that should use constant space and be fast.  Faster even if you use Data.Vector UArrs instead of lists, but that's an exercise for another time
10:25:39 <jeffersonheard> calculates mimimax, mean, variance, stddev, and length all in one pass
10:25:54 <burp> ah nice
10:26:29 <jeffersonheard> that doesn't use the Beautiful Folding code, which I'm also quite fond of, but ... eh.
10:26:39 <jeffersonheard> it's short and easy to understand
10:27:11 <FunctorSalad_> wasn't there some framework to combine several folds into one pass (or one "down" and one "up" for tree-like stuff)?
10:27:12 <ski> jeffersonheard : <http://squing.blogspot.com/2008/11/beautiful-folding.html> ?
10:28:01 <Makoryu> @hoogle (a -> a, a -> a) -> a -> (a, a)
10:28:02 <lambdabot> No results found
10:28:05 <copumpkin> edwardk further abstracted the beautiful folding
10:28:15 <jeffersonheard> FunctorSalad_ yes, there was.  I thought it was just edwardk's blogpost, though that got fleshed out a little more.  Saw it on reddit a couple of weeks ago.
10:28:18 <Makoryu> @hoogle (a -> b, a -> c) -> a -> (b, c)
10:28:18 <lambdabot> No results found
10:28:30 <jeffersonheard> right, what ski posted
10:28:40 * sclv_ recommends using knuth's stable mean anyway
10:28:51 <ski> @type uncurry (&&&)  -- Makoryu ?
10:28:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
10:29:02 <sclv_> stable stdev too for that matter.
10:29:06 <ski> @type \(f,g) -> f &&& g
10:29:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
10:29:51 <lilac> @type (*** (+1)) . (+)
10:29:53 <lambdabot> forall c b'. (Num b', Num c) => c -> (c, b') -> (c, b')
10:30:23 <Makoryu> @type flip $ (*** (+ 1)) . (+)
10:30:23 <sclv_> http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
10:30:24 <lambdabot> forall c b'. (Num b', Num c) => (c, b') -> c -> (c, b')
10:30:26 <lilac> > flip ((*** (+1)) . (+)) (t, l) n
10:30:27 <lambdabot>   (n + t,l + 1)
10:30:49 <sclv_> I think stats is using that actually? but its being silly about calculating length seperately.
10:31:03 <sclv_> in either case, it should be.
10:31:25 <lilac> Makoryu: to be honest, i think it'd be more readable to write "\n -> (+n) *** (+1)" if you're ok with the arguments that way round
10:32:23 <copumpkin> there's a uvector statistics package too
10:32:36 <jeffersonheard> sclv_: true, for the number of values he's calculating, it makes sense
10:32:42 <Makoryu> lilac: I had the arguments that way so as to use it in a foldl
10:32:59 <burp> I think my compiler is broken ;)
10:33:06 <jeffersonheard> copumpkin: I had a question about that.  the uvector package claims that indexing is an O(N) operation, but the length operation is O(1)?
10:33:11 <burp> Stack space overflow: current size 8388608 bytes.
10:33:15 <lilac> Makoryu: that's what i was afraid of :)
10:33:18 <copumpkin> jeffersonheard: I may have made a mistake there :P
10:33:22 <burp> from your stats function ;)
10:33:31 <ski> copumpkin : somewhere on <http://comonad.com> ?
10:33:31 <copumpkin> jeffersonheard: it really depends on whether something fuses or not
10:33:32 <burp> after some constant 1.1GB memory usage
10:33:42 * jeffersonheard *blinks*
10:33:43 <copumpkin> ski: http://comonad.com/haskell/Origami.hs
10:34:38 <jeffersonheard> burp: how are you getting data into the application?
10:34:47 <hackagebot> dyre 0.7.2 - Dynamic reconfiguration in Haskell (WillDonnelly)
10:34:52 <copumpkin> jeffersonheard: it's kinda hard to reason about :P but for indexing and length, fusing can work against you, but for most other things it helps
10:35:06 <burp> with f <- readfile and then map read (lines f)
10:35:30 <jeffersonheard> oh gosh.  yeah.
10:35:35 <jeffersonheard> that'd be your problem
10:35:42 <burp> but that should be no problem, when I'm using mean from math.statistics
10:35:48 <burp> it has a maximum memory usage of 3MB
10:36:25 <jeffersonheard> hrm.  well, still, you should probably use Data.Lazy.ByteString.Char8 to read your file
10:36:53 <jeffersonheard> will be much faster in any case by the sound of how much data you're crunching.
10:37:17 <jeffersonheard> and do you have missing values or no?
10:37:30 <burp> missing values?
10:37:47 <burp> lines without valid data?
10:37:51 <jeffersonheard> yes
10:37:53 <burp> no
10:38:10 <jeffersonheard> which is why I use the just/nothing pairs
10:38:33 <burp> ah ok I wondered ;)
10:38:45 <jeffersonheard> quite a lot of stats have data that are missing
10:38:52 <jeffersonheard> like say dealing with sensor data
10:38:59 <jeffersonheard> where the sensor doesn't report occasionally
10:39:10 <burp> makes sense
10:39:23 <jeffersonheard> the N is still the same, but the number of values is lower.  you make adjustments accordingly, because it affects the error, etc.
10:39:55 <jeffersonheard> hold on a sec.  I have a program that uses the naive version of the code to calculate the stats for a list
10:39:59 <jeffersonheard> got an email address?
10:40:05 <jeffersonheard> or I could just hPaste it again
10:40:14 <burp> ok
10:44:45 <ksf> waaagh spaghetti-code! global variables!
10:45:04 <jeffersonheard> ksf... wha?
10:45:10 <ksf> back in school, my tutor would have quartered and skinned me for that stuff.
10:46:06 <ksf> that kind of "procedural abstraction" where "procedural abstraction" means "write many procedures accessing global variables and call them from the main program"
10:46:20 <ksf> "optimally, in a different order than they are defined in"
10:46:56 <ksf> there's just no bleeding excuse for using global variables.
10:47:13 <ksf> if you really need them, make a struct and pretend your app is an object.
10:48:32 <ksf> 1000 lines of code, 9 functions taking no arguments.
10:48:43 <jeffersonheard> burp: now I'm getting the same problem.  10-million line file of ones borks on stack space overflow.  shouldn't...
10:48:58 <ksf> ...and not a single one without side-effects.
10:49:28 <burp> jeffersonheard: good that it's not just me ;)
10:49:38 <mxc>  /away
10:49:41 <doublethink_work> 'functions which have a return type of void or take no arguments are only showing that they work entirely through side-effects' - one of my professors
10:49:51 <mxc> oops, sry
10:51:15 <Infamous_Cow> ghc uses gmp mp for the Integer type correct?
10:51:45 <ksf> Infamous_Cow, nope, gmp is too slow :)
10:51:47 <Lemmih> Infamous_Cow: Yes, at least for now.
10:52:22 <mxc> jeffersonheard: i thought it was impossible to exactly calculate stddev or variance in one pass unless you already know the mean
10:52:41 <Infamous_Cow> Cause it seems like GMP is a lot faster in C than it is in ghc for the same size numbers I'm testing
10:53:16 <jeffersonheard> mxc, http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance  as indicated by sclv_
10:53:23 <mxc> (trying to catch up with the conversation now)
10:54:10 <jeffersonheard> and actually, if you do some algebra, since the mean is subtracted from every item, you can factor things out so that the individual items needed to calculate the final product can be done in a single pass
10:54:14 <copumpkin> I added one of those algorithms to the uvector stats package
10:54:17 <copumpkin> for variance
10:54:29 <copumpkin> can't remember which one
10:54:38 <mxc> oh, so you're using hte online approximation?
10:54:41 <ksf> Infamous_Cow, did you enable optimisations? -fvia-C?
10:55:12 <Infamous_Cow> ksf: no. will that solve my problems?
10:55:39 <burp> @faq is haskell unable to calculate stddev for large sample sizes? ;)
10:55:40 <lambdabot> The answer is: Yes! Haskell can do that.
10:55:40 <ksf> Infamous_Cow, if you don't tell ghc to optimize, it's optimizing for compile time.
10:55:43 <jeffersonheard> mxc: nah, I did a simple unstable version; but it still shouldn't bork out at a million elements.  it didn't used to
10:55:53 <mxc> oh ok
10:56:44 <ksf> there's a hell a lot that's being enabled with -O2 that will speed up any haskell program, not only related to C calls.
10:57:18 <ksf> (I'm still trying to figure out where I read that comment about ghc not using gmp. I think it had something to do with shootout entries and ghc being the only one _not_ using gmp)
10:57:46 <QP> Is there a way of writing higher order functions that take a polymorphic function and then use it on several different types in the same function?
10:57:56 <copumpkin> ksf: it definitely uses gmp unless you ask it not to during compilation
10:58:01 <copumpkin> there's integer-simple as an alternative
10:58:03 <copumpkin> in pure haskell
10:58:04 <doublethink_work> ghc has always used gmp to implement Integer, only now with 6.12 it will be optional
10:58:07 <Lemmih> QP: Yes.
10:58:22 <QP> Lammih: that's good.
10:58:26 <dons> has anyone thought of porting Hugs implementation of Integer?
10:58:36 <QP> Lemmih: how?
10:58:56 <doublethink_work> hi Lemmih!
10:58:57 <ksf> QP, type classes.
10:59:01 * doublethink_work = thoughtpolice
10:59:13 <Lemmih> QP: The answer to that question is left as an exercise to the reader.
10:59:21 <ksf> ...you have to give some restraint, otherwise you can't do anything to a value but force it and shove it through id.
10:59:25 <doublethink_work> Lemmih: I spent some time yesterday getting a 64bit debian + 64bit ghc working, and with it I can finally use LHC for real now!
11:00:07 <ksf> also, I've heard about forbidden arcane magic going by the name of "existential quantification"
11:00:45 <Lemmih> QP: It's something like: fn :: (forall a. a -> Int) -> Int; fn g = g False + g ()
11:00:48 <doublethink_work> ksf: in his case wouldn't he need rank-n types?
11:01:15 <ksf> depending on how you read it, I think he could be content with type classes alone.
11:01:20 <QP> So you have to use forall?
11:01:37 <ksf> QP, what do you want to do, exactly?
11:01:42 <QP> and what if a has to be of a particular class?
11:01:57 <copumpkin> add the class constraint
11:02:04 <copumpkin> foall a. (Class a) => a -> Int
11:02:05 <ksf> fn :: Num a => a -> Int ?
11:02:08 <Lemmih> QP: fn :: (forall a. Show a => a -> Int) -> Int
11:02:21 <QP> ok, thanks
11:02:32 <QP> i think i was just getting the syntax wrong
11:02:35 <ksf> "show" is a good example, you can take length on that.
11:02:55 <Lemmih> > let fn :: (forall a. Show a => a -> Int) -> Int; fn g = g True + g () in fn (length . show)
11:02:56 <lambdabot>   6
11:02:59 <QP> i was doing something vaguely like that, but GHC was complaining
11:03:20 <copumpkin> you need to enable an extension
11:03:28 <QP> cool: my first ever use of forall!
11:03:35 <copumpkin> RankNTypes or Rank2Type
11:03:35 <copumpkin> s
11:03:45 <Lemmih> doublethink_work: Excellent.
11:04:09 <Lemmih> doublethink_work: I've been trying to do some work on LHC myself.
11:04:38 <doublethink_work> Lemmih: sounds good - when I ran the testsuite yesterday everything passed perfectly fine and the C code generation works like a charm :)
11:05:06 <Arthur_Rainbow> Hi. I would like to know if anyone know a paper speaking of pattern matching of haskell. I use lazy evaluation, and I only found article about efficient pattern matching when we already know the value. (I don't program in Haskell, but I know the semantic of your pattern matching, and that there is some cool things about matchinf of non computed value)
11:08:04 <sm> morning all. What's the best way to get haddock for all my installed packages ?
11:09:01 <ksf> ...enable building documentation in your cabal config?
11:09:11 <ksf> ...and re-installing everything, of course.
11:09:17 <sm> aha
11:09:29 <Cale> Arthur_Rainbow: In order to pattern match against a refutable pattern, you *must* evaluate the value into weak head-normal form
11:09:49 <Cale> Arthur_Rainbow: Otherwise, you obviously can't tell which constructor matches.
11:10:06 <yrlnry> What is a good place to discuss term rewriting and unification?
11:10:26 <ksf> yrlnry, you can try here, or #haskell-in-depth.
11:10:32 <yrlnry> I fantasize about some internet term-rewriting community with a million people and a bulleting board.
11:10:55 <yrlnry> Really?   The stuff I want to talk about is not related to Haskell.
11:11:06 <Arthur_Rainbow> Ah ok, that's surpised me, I guess I've misunderstood what I read about (non)-refutable pattern
11:11:13 <yrlnry> So I asked an off-topic metaquestion instead of an off-topic question.  :)
11:11:15 <ksf> we've already patented that, ghc's typechecker works by mailing the types to oleg, who does them on his blackboard.
11:11:41 <Berengal> Haskellers usually have broad interest within CS
11:12:06 <Berengal> +s
11:12:53 <ksf> that is, unless some revolution happened, haskell channels have the highest density of ltu lurkers+regulars on the whole of freenode.
11:14:14 <yrlnry> Well, I am writing a bunch of stuff for doing term rewriting and unification and such.  And although I've been doing this kind of thing on and off for many years, I had somehow never noticed that there are two  slightly different kinds of unification.
11:14:33 <yrlnry> One kind is symmetric, and given terms X and Y it finds substitutions sx and sy such that sx X = sy Y.,
11:14:49 <yrlnry> The other is asymmetric, and given term X finds substituion sx such that sx X = Y.
11:14:53 <Arthur_Rainbow> Cale: what I meant was, I know that, in oCaml compiler, when matching a multipattern, the order will be choosen by heuristic. (Like, if you match an integer and a boolean, the boolean will be checked first, even if he is on the second part of the multi-pattern) So I thought that they may also be some kind of heuristic to avoir evaluation when it is possible. Now if you tell me there is nothing who don't evaluate, then I guess wha
11:14:58 <yrlnry> Obviously, this is a special case of the former.
11:15:44 <yrlnry> So insofar as I have a question, I guess I want to know if there is some standard jargon for this.
11:16:17 <ksf> afaik haskell checks patterns from top to bottom, outside to inside. I don't know whether left- to right is specified.
11:16:44 <ksf> ...sum types are messy, anyway.
11:18:21 <yrlnry> So for example my usual notion of "unification" is the symmetric kind, where if you try to unify (x * 1) with (1 * y) you get the term (1*1) which is an instance of both.  But if you have a rewrite rule like (x * 1) -> x, you do not want to conclude that (1 * y) has the correct form to apply the rule; you want the asymmetric version of unification instead.
11:18:23 <soupdragon> left- to right vs right to left would just be efficiency though, it couldn't change which match is taken could it?
11:19:09 <ksf> soupdragon, it could lead to different kinds of bottom.
11:19:27 <Arthur_Rainbow> yrlnry: if you don't know it, I guess you can find some good things to read about the asymmetric case, in the chapter "term indexing" of the "automated handbook of automated reasonning". Since in automated reasoning, i need to do a lot of "matching". (We call "matching" what you call "asymetric unification"
11:19:40 <ksf> ...a passed bottom vs. a pattern match bottom, to be precise.
11:19:56 <ksf> pattern matching can't recurse luckily, so we won't have loops.
11:20:08 <soupdragon> yrlnry: I like term rewriting too
11:21:33 <ksf> and if you're concerned about what gets evaluated when, your best bet is to introduce foo a b | b `seq` a `seq` False, anyway.
11:22:01 <yrlnry> I'm going to get the book' Term Rewriting and All That" from the library once they persuade themselves that I do not have to pay them $110 for a book that I returned.,
11:22:20 <lilac> soupdragon: consider "let f [] (x:xs) = x; f (x:xs) _ = x in f "hello" undefined". left-to-right, the answer is 'h', right-to-left it's _|_
11:22:29 <burp> jeffersonheard: but you were right with bytestring.lazy.char8 .. reading the data is very fast with that
11:23:01 <jeffersonheard> burp: yeah..  I'm still looking into the stats thing
11:23:06 <lilac> > let f [] (x:xs) = x; f (x:xs) _ = x in f "hello" undefined
11:23:06 <jeffersonheard> got one that handled a million now
11:23:08 <lambdabot>   'h'
11:23:13 <jeffersonheard> going to see what the actual profile of it is
11:24:57 <benmachine> > let f (x:xs) [] = x; f _ (x:xs) = x in f undefined "hello"
11:24:59 <lambdabot>   * Exception: Prelude.undefined
11:25:07 <benmachine> :o
11:25:12 <benmachine> surely that is not right
11:29:52 <Asztal> it has to evaluate it a bit to find out whether it's a (:) or a not
11:30:30 <benmachine> well it doesn't really because the second argument doesn't match
11:30:52 <benmachine> but I suppose it doesn't know that until it is too late, as it were
11:31:03 <ray> > let f ~(x:xs) [] = x; f _ (x:xs) = x in f undefined "hello"
11:31:05 <lambdabot>   'h'
11:31:28 <ray> the ~ makes it irrefutable, deferring the pattern match error to when you actually try to use x or xs
11:31:51 <benmachine> ray: but that function will fail with [] []
11:32:11 <benmachine> err, it would anyway
11:32:15 <benmachine> but that's not the point :P
11:32:22 <ray> yes
11:34:45 <jeffersonheard> burp: the following code stats 10 million numbers form file in 1 min 49 seconds on my machine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8074#a8081
11:35:01 <burp> m, lets try :D
11:35:41 <jeffersonheard> compile with -fbang-patterns -O2
11:35:55 <jeffersonheard> howevre, this *cannot* be as fast as we can egt, because that's only a 20 megabyte file of numbers
11:35:58 <jeffersonheard> I'm doing something wrong
11:36:55 <ray> benmachine: i also hear they're doing great things with unamb
11:37:42 <jeffersonheard> and it's not the time it takes to calculate the statistics.  a stats [0::Double,1..10000000] takes 3.385 seconds on my machine.
11:37:55 <jeffersonheard> so why is reading doubles from file taking so long...?
11:40:04 <burp> reading 2 million is fast for me
11:40:13 <burp> with:
11:41:14 <burp> bs <- C.readFile $ args !! 0
11:41:19 <burp> let vals = map (\x -> let (n,r) = fromJust $ readDouble x in n) $ C.lines bs
11:43:17 <jeffersonheard> what version of GHC?
11:43:28 <burp> 6.10.4
11:44:17 <jeffersonheard> hrm.  same here.  2 million numbers takes how long and on what kind of processor, may I ask?
11:44:29 <soupdragon> Haskell isn't only about brainy high teck geeky subjects. Haskell is about expanding your mind to think in new/different ways. The ordinary isn't always ordinary
11:44:32 <burp> with mean from math.statistics just 2s
11:44:47 <burp> 1.72 million on core2duo 1.83GHz
11:45:07 <hackagebot> executable-path 0.0.1 - Finding out the full path of the executable. (BalazsKomuves)
11:45:30 <Rotaerk> soupdragon, that's what I'd *expect* a geek to say!
11:47:45 <jeffersonheard> burp: pulling readDouble from where?
11:48:12 <burp> oh Data.ByteString.Lex.Lazy.Double
11:48:19 <burp> http://hackage.haskell.org/package/bytestring-lexing
11:50:03 <sbahra> :(
11:50:06 * sbahra needs to write more Haskell
11:51:11 <jeffersonheard> burp: that'd be my problem I bet.  the parse is def. taking 99.9% of the time
11:51:45 <burp> I will try your code as soon as haskell finds Text.Parsec ;)
11:52:42 <QP> hpaste.org/fastcgi/hpaste.fcgi/view?id=8083#a8083 --- can anyone explain this error message?
11:52:58 <soupdragon> http://
11:53:52 <Rotaerk> qp, what error message
11:54:13 <QP> the parse error on input '=>' one
11:54:26 <skorpan> fixed http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8083#a8083
11:54:39 <jeffersonheard> ah wow.  yeah.  that's better.  now 2.480 seconds for 2 million
11:55:13 <Botje> QP: i think you need a GHC extension for that
11:55:17 <skorpan> damn
11:55:21 <skorpan> i was just about to say that
11:55:21 <Botje> could it be Rank2Types?
11:55:25 <skorpan> yes, i think so
11:55:25 <soupdragon> QP, you could do  map (fmap f) [a,b,c]
11:55:45 <skorpan> yes, that was it, Rank2Types
11:55:57 <QP> no, a b and c are all different types
11:56:07 <soupdragon> why have you got forall a ?
11:56:21 <burp> jeffersonheard: perfect
11:56:39 <QP> because f needs to work on different types in the same function
11:56:45 <burp> that's what I call fast ;-)
11:57:11 <soupdragon> QP what happens if you try it without the type signature?
11:57:17 <QP> how does one include Rank2Types?
11:57:25 <QP> with no type sig at all?
11:57:34 <QP> that's an interesting idea!
11:57:34 <soupdragon> delete line 1
11:57:44 <Botje> skorpan: your time to shine! :)
11:57:55 <skorpan> {-# LANGUAGE Rank2Types #-}
11:58:06 <QP> soupdragon: it works!!
11:58:09 <skorpan> ...
11:58:13 <skorpan> i never win at this game
11:58:21 <soupdragon> okay :)
11:58:22 <Rotaerk> QP, and its type is?
11:58:35 <QP> why... but there must be a way of writing its type...
11:58:50 <Rotaerk> load that function int GHCi and :type it
11:58:52 <skorpan> you wrote it, you just need an extension
11:59:29 * ksf is confused by "parse error at =>"
11:59:36 <ksf> you should actually get an error like
11:59:42 <ksf>     Illegal polymorphic or qualified type: (Show a) => a -> Int
11:59:42 <ksf>     Perhaps you intended to use -XRankNTypes or -XRank2Types
11:59:54 <QP> it's just (a -> b) -> GeneralObject -> Maybe b
12:00:15 <QP> without any constraints at all!
12:00:41 <QP> i'm confused
12:01:00 <ksf> shouldn't "Object" be "Functor"?
12:01:15 <soupdragon> no
12:01:16 <ksf> uhm...
12:01:21 <jeffersonheard> :t (***)
12:01:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:01:24 <kyagrd> @hoogle zipN
12:01:25 <lambdabot> No results found
12:01:36 <jeffersonheard> :t second
12:01:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
12:01:43 <ksf> no, of course not.
12:01:48 <jeffersonheard> :t second (BS.tail)
12:01:49 <lambdabot> forall d. (d, BSC.ByteString) -> (d, BSC.ByteString)
12:01:59 <ksf> GeneralObject's members are functors.
12:02:04 <burp> jeffersonheard: the last but one entry should be standard deviance?  it is 1852.816633820649 for my file
12:02:08 <burp> but that can't be true ;)
12:02:21 <QP> so what should I do---remove the class constraint, or add the Rank2Types pragma?
12:02:33 <burp> all entries are ranging from -5 to 5
12:02:53 <ksf> aaaah.
12:03:05 <ksf> it's not choking on =>, but on the forall.
12:03:23 <kyagrd> is there a TH library that has generic liftM which can generate liftM, liftM2, liftM3, ... and so on?
12:03:27 <bjorkintosh> last statement in 'do' must be an expression...
12:03:28 <ksf> ...which is a syntax extension enabled by some other extensions.
12:03:31 <jeffersonheard> one sec, burp...
12:03:37 <ksf> ...like e.g RankNTypes.
12:03:42 <bjorkintosh> i've retyped the example numerous times and i still get that error.
12:03:59 <ksf> so, yes, use -XRank[2|N]Types or a pragma.
12:04:01 <kyagrd> There is a zipN example in the original paper and I believe someone already have wrtten this
12:04:02 <Botje> bjorkintosh: carefully check your indentation.
12:04:14 <Botje> bjorkintosh: tabs vs spaces can confuse GHC
12:04:20 <bjorkintosh> oh it's sensitive to indentations?
12:04:25 <Rotaerk> yep
12:04:26 <Botje> yes :)
12:04:29 <bjorkintosh> gaaaa!
12:04:35 <Baughn> kyagrd: But note, infix <$> and <*> can achieve the ssame thin in non-pointless style
12:04:36 <bjorkintosh> i thought that was a pythonism.
12:04:46 <kyagrd> Baughn: ???
12:04:52 <Botje> bjorkintosh: if you don't like it, you can use {} and ; too.
12:05:15 <Botje> > let { a = 1; b = 5 * a } in { 4 * b }
12:05:17 <lambdabot>   <no location info>: parse error on input `{'
12:05:19 <bjorkintosh> to terminate the statements?
12:05:35 <Botje> to ignore the layout engine and format the code like you want to
12:05:43 <Baughn> kyagrd: As in "ThreeParameterConstructor <$> newMVar 2 <*> newEmptyMVar <*> getLine"
12:05:45 <Botje> although the layout in haskell isn't as strict as python's
12:06:04 <Rotaerk> F# also has indentation-sensitive scoping
12:06:04 <Baughn> kyagrd: Well, it's not liftM3, but it's often good enough
12:06:19 <Rotaerk> and ML I think
12:06:27 <kyagrd> Baughn: No, I need template haskell code that generates it.
12:06:37 <kyagrd> for arbitrary N
12:07:58 <Baughn> kyagrd: That should, of course, be trivial. Bearing in mind that I know almost zero TH, adding a lambda to the top of the n*(<*>) expression would do it nicely
12:08:29 <bjorkintosh> does hugs suffer the same problem?
12:08:59 <Botje> it's a feature, not a problem :)
12:09:03 <yitz> bjorkintosh: even though you can write Haskell without indentation, almost no one does that. because once you try it, indentation is great.
12:09:12 <bjorkintosh> i like indentation
12:09:21 <bjorkintosh> but i can't tell what precisely is not properly matched.
12:09:39 <Rotaerk> bjorkintosh, make sure only to use spaces... have tabs convert to spaces
12:09:51 <bjorkintosh> oh it doesn't like tabs?
12:09:57 <yitz> bjorkintosh: use an editor that does it for you automatically
12:10:06 <bjorkintosh> i'm using vim.
12:10:11 <Baughn> bjorkintosh: There is a defined number of spaces per tab. The compiler converts.
12:10:23 <Baughn> bjorkintosh: Unfortunately, chances are your editor disagrees. A tab ought to be an error, really.
12:10:23 <ray> and it's 8
12:10:33 <yitz> tabs are an error in Python
12:10:38 <ray> tabs are 8 in python
12:10:39 <bjorkintosh> mine's set to ts=2
12:10:42 <ray> why
12:10:58 <bjorkintosh> why not?
12:11:12 <ray> if i had more time, i'd do an extensive psychological study of people who set tab stops like that
12:11:18 <ray> i don't, so i can only ask why :(
12:11:31 <bjorkintosh> what should it be?
12:11:56 <jeffersonheard> burp: you should still get the same speed if you switch to the on-line algorithms mentioned in wikipedia.  rather than figure out where I dropped a term here, why don't you just use those
12:11:57 <ray> the old school unix meaning is "advance until the column is divisible by 8"
12:12:09 <yitz> hmm, no they aren't. my memory fails me. well, I know there something very strict about tabs they did in python which essentially means, just don't use them.
12:12:22 <jeffersonheard> they just drop in place where the va / stdev are calculated now
12:12:24 <ray> they are equal to 8 spaces
12:12:29 <ray> same as in haskell
12:12:32 <burp> jeffersonheard: ok
12:12:48 <ray> you are free to use them if you realise they are equivalent to 8 spaces, but i don't know why you would :)
12:12:56 <ray> that applies to python and haskell
12:13:06 <jeffersonheard> and they're stable as opposed to the source for the one I hpasted
12:13:11 <bjorkintosh> 1 tab = 8spaces? i didn't know that.
12:13:17 <Baughn> ray: Obfuscated Haskell Code Contest
12:13:39 <ray> i think the 8 spaces rule is used because it's close to the classical meaning but much easier
12:13:53 <jeffersonheard> btw, you don't have to use map and discard the bytestring that readDouble uses.  you can use unfoldr with a slightly modified readDouble
12:13:53 <ray> most people start tabbing from the first column anyway
12:14:25 <jeffersonheard> readDouble' k =  second C.tail <$> readDouble k
12:14:44 <ray> the thing is, haskell layout is a bit more complicated than python
12:14:46 * ksf is still in favour of outlawing tabs alltogether.
12:14:47 <jeffersonheard> then vals = stats . unfoldr readDouble' <$> C.readFile f
12:14:51 <bjorkintosh> why must it be so?
12:15:03 <ray> if you tell your editor to display tabs as something weird and you write python using tabs, you can get away without noticing it
12:15:07 <bjorkintosh> what's the benefit of making an already hard task even more nuanced and more painful?
12:15:07 <ksf> the key on the keyboard is fine, but tab characters don't belong into files.
12:15:23 <yitz> oh, I see. In python, tab is 8 spaces, but if you use a tab, then every line in that indentation group must use a tab in that position and not 8 spaces.
12:15:47 <ray> python's basically "indented X levels"
12:15:54 <ray> in haskell layout, stuff has to line up
12:16:19 <SamB> yitz: I didn't know you were still allowed to use tabs to indent python!
12:16:29 <ray> i think getting one's opinions wholesale from websites should be outlawed
12:16:37 <burp> jeffersonheard: I see
12:16:37 <ray> samb: you're not, by the syntax cops
12:16:43 <yitz> SamB: yeah, I also thought it was totally outlawed.
12:16:53 <SamB> ray: I meant, I thought even the implementation forbade it by now
12:17:10 <ray> that seems like the kind of dick move python would pull, but i haven't heard of it
12:17:32 <SamB> which really makes a lot of sense, considering how hard it is to tell whether prefix x indents more than prefix y if you allow variable-width tabs ...
12:17:39 <SamB> ray: it's not dick
12:17:50 <ray> well, the real problem here is people with bizarre editor configurations
12:17:56 <ray> and possibly the editor authors that allow them :)
12:18:03 <SamB> yes, that is part of it too
12:18:04 <bjorkintosh> what's the preferred way of editing a .hs file?
12:18:12 <kulakows1i> bjorkintosh: M-x butterfly
12:18:14 <ray> any text editor
12:18:21 <ray> just don't use tab characters, that's all
12:18:36 <ray> you do need to make stuff line up to arbitrary columns sometimes
12:19:08 <ray> someFunction = do b <- something
12:19:18 <ray> and now your next line has to align with that 'b'
12:19:19 <yitz> SamB: well, basically, it looks like in python you must always indent with the same sequence of whitespace chars. The equation tab = 8 spaces only affects what message you get in your IndentationErro.
12:19:23 <yitz> *Error
12:19:23 <QP> bjorkintosh: i just use gedit these days
12:19:39 <ray> note that the column 'b' is in is not a multiple of 8
12:19:41 <ray> tabs will FAIL YOU here
12:19:55 <bjorkintosh> alright, i'm setting expandtab in vim
12:19:55 <SamB> yitz: ah, so they do allow tabs as long as you are unambigous?
12:19:59 <bjorkintosh> hopefully, that should do the trick.
12:20:04 <ray> i think that's the setting
12:20:08 <yitz> bjorkintosh: if you like vim, there is pretty good haskell support there
12:20:11 <ray> well, don't set it in general though
12:20:14 <SamB> ray: what, does Haskell define all tabs to be 8 spaces wide?
12:20:16 <ray> just for haskell files
12:20:17 <ray> samb: yes
12:20:20 <SamB> not just to the next multiple of 8?
12:20:23 <SamB> that's arguably a bug
12:20:27 <ray> samb: arguably, yes
12:20:31 <ray> but it's simpler to do
12:20:43 <ray> bjorkintosh: if you set it globally, you'll ruin the next makefile you edit, for example
12:20:54 <bjorkintosh> okay.
12:20:56 <SamB> I would notify the Haskell 98 correction editor and report it on the GHC trac, personally
12:20:57 <ray> vim might be smart and unset it for makefiles, but you can't take that chance
12:21:16 * ksf set it globally iirc, and my makefiles aren't messed up.
12:21:16 <bjorkintosh> i'll leave it in my haskell101 directory then.
12:21:36 <ray> next to the lambdacats
12:21:52 <SamB> yeah, major text editors tend to be pretty good about not screwing up the tabs in Makefiles
12:22:06 <ksf> yeah, vim switches to noet automagically.
12:22:09 <ray> you're just lucky vim saved you there!
12:22:15 <SamB> mostly regardless of configuration variable values
12:22:42 <ray> @where lambdacats
12:22:43 <lambdabot> http://arcanux.org/lambdacats.html
12:22:44 <SamB> ray: it's not just vim that is smart like that ...
12:23:00 <ray> it's any editor that's smart enough to handle filetypes pretty much
12:23:15 <ray> of course, i don't always use editors that smart
12:23:42 <ray> infurd type
12:23:49 <ksf> bjorkintosh, http://projects.haskell.org/haskellmode-vim/
12:23:57 <bjorkintosh> thanks ksf
12:23:59 <bjorkintosh> looking at it now
12:24:09 <Daimonic> hey, I want to make my data type foo = A | B | C with the data type Eq. However, I don't know which functions to implement when I just try instance (Eq foo) it compiles... ??
12:24:24 <dino-> I'm having some parsec confusion. Specifically, I'd like to be able to parse something like this "foo bar\nbaz\n  \n"
12:24:25 <ray> data Foo = A | B | C deriving Eq
12:24:32 <Daimonic> no, I want to define Eq myself
12:24:33 <randomwords> Will yi be able to use vim-plugins eventually? (Can it now?)
12:24:43 <dino-> Where that "\n  \n" could be 0 or more spaces. Basically an idiot blank line that may have meaningless whitespace in it.
12:24:45 <ray> instance Eq Foo where
12:24:51 <ray>  A == A = True
12:24:53 <ray> etc
12:25:00 <Daimonic> ok, that's all? thanks man
12:25:24 <dino-> And get all the text up to that "\n.*\n"
12:25:49 <dino-> er, \n\s*\n
12:25:56 <ksf> bjorkintosh, you might be interested in http://haskell.org/haskellwiki/Yi ,too.
12:27:31 <jeffersonheard> burp:  this is the fastest so far and correct:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8086#a8086
12:29:02 <yitz> SamB: if this is true, and H98 has to be fixed anyway, then just get rid of tabs.
12:30:00 <yitz> SamB: or define indentation level as a fixed string of whitespace instead of a number of columns
12:30:05 <erikc> http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
12:30:20 <erikc> tim sweeney dropping the pure functional and software transactinoal memory approach bombs
12:30:20 <burp> jeffersonheard: jup, thanks
12:30:25 * erikc excited
12:30:51 <SamB> yitz: the latter doesn't work, does it?
12:30:58 <yitz> why not?
12:31:13 <SamB> because some of the indentation in the first line of a block might be non-whitespace
12:31:48 <SamB> e.g:
12:31:50 <SamB> do foo
12:31:52 <SamB>    bar
12:31:55 <yitz> SamB: ah right. so forget it, just dump tabs
12:32:19 <SamB> of course, you also have to properly handle things like... hmm.
12:32:29 <SamB> where's a JIS-to-Unicode map when you need one
12:32:51 <yitz> @google JIS to Unicode
12:32:52 <lambdabot> http://support.microsoft.com/kb/170559
12:33:17 <SamB> hmm, I seem to remember some sort of controversy surrounding some character or other...
12:34:03 <ski> (some whitspace, like form feed, should probably not be counted for indentation level ..)
12:35:48 <burp> jeffersonheard: the mean is wrong ;)
12:36:08 <SamB> ski: or newline, yes
12:36:22 <burp> I guess thats just an estimator?
12:36:23 <SamB> form-feed is, aiui, supposed to start a new line
12:36:32 <SamB> ;-P
12:36:37 * ski uses form feed occasionally
12:37:10 <SamB> ski: I'm just saying, if that doesn't work, you've got *another* bug
12:37:34 <ski> (if form feed doesn't work ?)
12:37:39 <SamB> yeah.
12:37:45 <burp> but it's a good estimator
12:37:47 <SamB> well, assuming it displays as starting a new line ...
12:37:49 <mkaemmer> erikc: wow, awesome.
12:39:02 <ski> Emacs displays it as `^L' .. but i can jump to them with `C-x [' and `C-x ]'
12:39:38 <ski> (presumably printers would start printing on a new page, when reaching it .. i haven't tried, that i can recall)
12:40:24 <mkaemmer> erikc: I used to be disappointed by the fact that graphics/game programming tended to demand disgusting multi-threaded C++ code
12:40:58 <ski> (those commands are called `backward-page' and `forward-page', respectively)
12:40:58 <mkaemmer> erikc: seems like multi-core has been a boon to FP/pure code.
12:41:17 <SamB> hmm, actually, it doesn't get a free newline in emacs ...
12:41:34 <ray> tim sweeney announces unreal 2010 engine to be written in haskell
12:41:45 <ray> (i can dream)
12:42:08 <mkaemmer> ray: someday :)
12:42:11 <SamB> ray: I thought he had some particular reasons that he had said he wasn't going to do that?
12:42:21 <SamB> which is a heck of a lot better than not thinking about it at all!
12:42:46 <erikc> SamB: he basically lifted all the good ideas from haskell and applying them in c++
12:43:27 <SamB> hmm, what about not having mysterious crashes because you forgot to write one line somewhere?
12:43:43 <erikc> you still have that problem :\
12:43:57 <lilac> what about having mysterious space leaks because you forgot to write a ! somewhere?
12:44:06 <ksf> early ut2004 versions crashed regularly.
12:44:35 <ray> samb: yes
12:44:50 <ray> i don't remember what they are, but he likes the important stuff like the type system
12:44:55 <ray> and pure functionalism
12:45:25 <mkaemmer> erikc: I still see that as progress.  Eventually, functional purity will be a common enough convention that people will migrate to languages that enforce it.
12:45:29 <erikc> im sure unrealscript in unreal4 will have a lot of it builtin
12:45:30 <ksf> lilac, what about having misterious space leaks because you have to implement memory management yourself?
12:45:45 <lilac> ksf: those aren't mysterious, i have great tools to track them down
12:46:00 <lilac> plus they're really not all that common in my experience
12:46:17 <ksf> ...the same goes for haskell's space leaks.
12:46:17 <erikc> mkaemmer: it's huge progress
12:46:23 <lilac> (but my experience is coloured by 'idiomatic' c++ using smart pointers)
12:47:04 <mkaemmer> lilac: malloc errors are common enough that most companies choose gc'd languages nowadays
12:47:06 <lilac> ksf: i've never written a haskell program of more than 100 lines without a space leak, to my knowledge. i've written equivalent (admittedly 1000 line) c++ programs with no memory leaks
12:47:17 <lilac> mkaemmer: if you're using malloc, you're doing C++ wrong :)
12:47:55 <lilac> my job is 100% c++, and i often go for weeks without writing 'new'.
12:49:01 <ivant> guys, is there some hostel in Edinburgh where a lot of people going to ICFP are staying?
12:57:59 <jeffersonheard> ivant: hold on I might be able to help you there
12:58:25 <lilac> does anyone have a good Haskell implementation of the VM from the ICFP 2006 programming contest?
12:58:35 <Plouj> erikc: you wanna work at Epic Megagames, don't you?
12:59:14 <sinelaw> does God visit here often?
12:59:32 <jeffersonheard> nah, God hangs out in #perl
12:59:40 <skorpan> xkcd joke detected
12:59:55 <jeffersonheard> ivant, I believe we're staying in the lantern the night or two before my talk
13:00:10 <jeffersonheard> otherwise, there's hostelworld.com and search for edinburgh.  they have lots of reviews
13:00:25 <mkaemmer> @seen God
13:00:25 <lambdabot> I haven't seen God.
13:00:34 <mkaemmer> sinelaw: there you have it
13:01:05 <sinelaw> k, thanks. just needed an explanation on a paper he wrote
13:01:05 <erikc> Plouj: i've interviewed there, didnt get an offer
13:03:52 <jeffersonheard> burp...  how far off is the mean?  I probably forgot to account for the first element
13:04:41 <burp> O(10^-6)
13:04:58 <burp> well.. exact 1.37*10^-6 and yours 1.81*10^-6
13:05:17 <jeffersonheard> ah yeah... change to stats (x:xs) = finish . foldl' stats'' (x,x,0,0,0) $ (x:xs)
13:05:24 <jeffersonheard> and keep in mind that not all means are equal
13:05:32 <jeffersonheard> there's population vs. sample mean
13:05:50 <sinelaw> would be cool to have a program like kts with functional language for operating on the data
13:06:41 <mkaemmer> kts?
13:06:42 <burp> jeffersonheard: yup, thats it
13:07:04 <sinelaw> mkaemmer, something for easily visualizing statistical data
13:07:20 <sinelaw> kst
13:07:21 <sinelaw> oops
13:07:34 <mkaemmer> sinelaw: does it de-acronym to something meaningful?
13:07:35 <sinelaw> http://kst.kde.org
13:07:50 <sinelaw> I guess "kde statistics" or something
13:07:55 <mkaemmer> oic
13:07:56 <Ke> isn't R functional
13:08:04 <soupdragon> no
13:08:09 <jeffersonheard> sinelaw: R = functional language for stats
13:08:12 <jeffersonheard> not pure functional
13:08:15 <jeffersonheard> and not well-designed
13:08:21 <jeffersonheard> but it's lispish
13:08:25 <sinelaw> its performance is quite good, was designed for huge data sets and huge files
13:08:35 <Plouj> erikc: aaw :(
13:08:38 <sinelaw> and it includes easy UI for graphics
13:08:48 <Lycurgus> well it's not designed as such, it's a clone of "S"
13:08:58 <Plouj> can anyone think of a field other than game development where one would work with parallel computing and graphics at the same time?
13:09:05 <jeffersonheard> yes
13:09:07 <sinelaw> Plouj, robotics
13:09:08 <jeffersonheard> visualization
13:09:11 <jeffersonheard> robotics
13:09:13 <jeffersonheard> computer vision
13:09:19 <Ke> only now I think R is more popular than S
13:09:21 <jeffersonheard> image processing
13:09:23 <Ke> unlike octave
13:09:26 <Lycurgus> medical imaging
13:09:28 <sinelaw> computer vision is a classic
13:09:33 <Lycurgus> military applications
13:09:40 <erikc> Plouj: i didnt know anything about fp at the time i applied, and hadnt worked in the games industry yet :), so i was lucky to get interviewed at all
13:09:54 <Plouj> I see
13:10:16 <Lycurgus> meteorology, and many others
13:11:12 <jeffersonheard> Plouj, basically anything where you can think of your data domain as a dense matrix of 1D-4D floating point values or vectors
13:16:28 <navaati> hello \o
13:17:32 <navaati> hum... I've a problem with ErrorT and IO
13:19:05 <navaati> I don't succeed in throwing errors (I mean Left errors, not IOError) when I am within the lifted IO monad :/
13:20:09 <navaati> does anybody know how to do that ? (I can paste a source code if it's not clear)
13:38:28 <stanv> hello :)
13:38:39 <stanv> > [2,1..2]
13:38:41 <lambdabot>   [2]
13:38:53 <stanv> > [2,1..3]
13:38:55 <lambdabot>   []
13:39:20 <stanv> strange behaviour :)
13:40:37 <c_wraith> not that strange...
13:41:09 <c_wraith> It examines the first two elements to find a pattern, then lists everything between the start and the finish points
13:42:54 <kajamd>  Check new web site - http://www.lostworlds.lv/go.php?1139723800
13:43:22 * SamB wonders why tengwar and cirth are in the unicode roadmap but klingon isn't ...
13:43:54 <randomwords> The spammers could at least have the courtesy to use proper grammar.
13:46:16 <mkaemmer> c_wraith: interesting... is there a concise way to describe what ".." desugars to?
13:47:01 <c_wraith> I was wondering that myself
13:47:04 <ksf> mkaemmer, have a look at enumFromTo
13:47:11 <ksf> @hoogle enumFromTo
13:47:12 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
13:47:12 <lambdabot> Language.Haskell.Syntax HsEnumFromTo :: HsExp -> HsExp -> HsExp
13:47:17 <mkaemmer> @source enumFromTo
13:47:18 <lambdabot> enumFromTo not available
13:47:21 <mkaemmer> :(
13:47:30 <ksf> there's got to be a version that includes step, too.
13:47:41 <ksf> > enumFrom 1
13:47:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:47:49 <ksf> > [1..]
13:47:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:48:08 <ksf> @hoogle+
13:48:11 <c_wraith> > ['a'..'f']
13:48:13 <lambdabot>   "abcdef"
13:48:14 <ksf> hmm.
13:48:32 <ksf> > ['a','b'..'z']
13:48:34 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:48:39 <ksf> > ['a','c'..'z']
13:48:41 <lambdabot>   "acegikmoqsuwy"
13:49:06 <ksf> > ['a','d'..'z']
13:49:08 <lambdabot>   "adgjmpsvy"
13:49:24 <ksf> > ['a','f'..'z']
13:49:25 <lambdabot>   "afkpuz"
13:49:38 <ksf> hey, that's at least pronouncable.
13:50:02 <ksf> "afk" is away from keyboard, now we have to figure out what "puz" means.
13:51:01 <ksf> it'll be the first acronym that has an abbreviation.
13:51:14 <J11> > enumFromThenTo 1 3 20
13:51:15 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
13:52:14 <mkaemmer> @source Data.Ord.enumFromThenTo
13:52:15 <lambdabot> Data.Ord.enumFromThenTo not available
13:52:54 <ksf> hmmm. actually, one could argue that enumFromTo 1.0 2.0 should make a list of every representable float|double|whatever between 1 and 2
13:55:43 <ksf> > map Unsafe.Coerce.unsafeCoerce ((enumFromTo 10000 10010) :: [Data.Word.Word32]) :: [Float]
13:55:45 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
13:55:49 <ksf> bastard.
13:55:57 <mkaemmer> yeah... I suspect some sort of dark magic is involved in enumFromThenTo
13:56:42 <ksf> there's minBound and maxBound, and (+).
13:56:45 <ksf> that's all you need.
13:56:52 <ksf> oh, and fromInteger.
13:56:58 <J11> The sequence enumFromThenTo e1 e2 e3 is the list [e1,e1+i,e1+2i,...e3], where the increment, i, is e2-e1. If the increment is positive or zero, the list terminates when the next element would be greater than e3; the list is empty if e1 > e3. If the increment is negative, the list terminates when the next element would be less than e3; the list is empty if e1 < e3
13:57:24 <benmachine> > enumFromTo 1.0 1.5
13:57:26 <lambdabot>   [1.0,2.0]
13:57:43 <ksf> Prelude> map Unsafe.Coerce.unsafeCoerce ((enumFromTo 10000 10010) :: [Data.Word.Word32]) :: [Float]
13:57:43 <ksf> [1.4013e-41,1.4014e-41,1.4016e-41,1.4017e-41,1.4019e-41,1.402e-41,1.4021e-41,1.4023e-41,1.4024e-41,1.4026e-41,1.4027e-41]
13:57:46 <benmachine> :t fromEnum
13:57:49 <lambdabot> forall a. (Enum a) => a -> Int
13:58:01 <benmachine> > fromEnum 1.0
13:58:03 <lambdabot>   1
13:58:05 <benmachine> > fromEnum 1.5
13:58:07 <lambdabot>   1
13:58:11 <benmachine> hrm.
13:58:21 <benmachine> toEnum . fromEnum /= id?
13:58:31 <ksf> depening on types, no.
13:58:37 <mkaemmer> J11: understood, but subtraction isn't defined on the enum typeclass
13:58:43 <benmachine> > succ 1.5
13:58:45 <lambdabot>   2.5
13:58:53 <ksf> floats may form a set, but haskell doesn't know that.
13:58:55 <mkaemmer> J11: so "e2-e1" doesn't really mean anything
13:59:01 * benmachine thinks the enum instance for floats is altogether fishy
13:59:02 <ksf> ...so it's breaking the bijection.
13:59:28 <benmachine> floats aren't really an enum
13:59:33 <mkaemmer> J11: you could repeatedly apply "succ" or "pred" to find the interval, but you diverge if you go in the wrong direction
13:59:42 <benmachine> they're not discrete, there is no concept of adjacence
13:59:52 <ksf> benmachine, shure they're discrete.
13:59:58 <benmachine> well
14:00:02 <benmachine> okay
14:00:08 <benmachine> but there's no real adjacence
14:00:21 <ksf> they're even enumerable.
14:00:29 <ksf> ...look at the unsafeCoerce trick above.
14:00:41 <benmachine> okay
14:00:52 <benmachine> but that's not the enumeration that we actually use
14:00:58 <benmachine> nor is it a particularly useful one
14:01:20 <ksf> but the only one that would obey toEnum . fromEnum == id.
14:01:42 <benmachine> well, except for arbitrary reordering
14:01:45 <benmachine> @src Enum
14:01:46 <lambdabot> class  Enum a   where
14:01:46 <lambdabot>     succ                     :: a -> a
14:01:46 <lambdabot>     pred                     :: a -> a
14:01:46 <lambdabot>     toEnum                   :: Int -> a
14:01:46 <lambdabot>     fromEnum                 :: a -> Int
14:01:48 <lambdabot> [3 @more lines]
14:02:02 <ksf> @more
14:02:03 <lambdabot>     enumFrom                 :: a -> [a]
14:02:03 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
14:02:03 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
14:09:57 <erikc> is there a strict language with typeclasses?
14:10:25 <ksf>  timber?
14:10:32 <ksf> there's also a strict haskell.
14:10:37 <sinelaw> bitc
14:10:42 <erikc> ksf: there is?
14:10:52 <copumpkin> just stick seq everywhere!
14:10:54 <copumpkin> :P
14:11:04 <copumpkin> I mean rnf
14:11:06 <ksf> http://www.timber-lang.org/haskell.html
14:11:06 <copumpkin> just to be double sure
14:25:19 <dino-> ugh, I need some serious Parsec tutorials
14:26:05 <Nebasuke> if you want some examples you could use my bachelor paper
14:26:17 <Nebasuke> http://referaat.cs.utwente.nl/new/paper.php?paperID=504
14:26:31 <Nebasuke> it's parsec 2 though
14:26:33 <pikhq> dino-: But there's no need for serious Parsec tutorials.
14:26:43 <pikhq> It's the single most simple parser library I know of.
14:26:57 <dino-> Nebasuke: ok, thanks
14:27:00 <stanv> Is it possible to see source of `[]' ?
14:27:22 <shachaf> @src []
14:27:22 <lambdabot> data [] a = [] | a : [a]
14:27:27 <dino-> pikhq: I have tremendous difficulty every time I work with it. I just don't get it yet I think.
14:28:09 <Nebasuke> have you read the parsec manual yet?
14:28:19 <dino-> Nebasuke: Yes, lots
14:28:47 <dino-> I can't relate my task to anything I'm reading.
14:29:01 <dino-> I'll put some of the data on paste in a little bit.
14:29:12 <stanv> i need rules how list is constructs: [2,2..5] == [2,2,2,... [2,2..1] == []
14:30:02 <copumpkin> > [1,1..2]
14:30:03 <Nebasuke> dino-: okay
14:30:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:30:17 <copumpkin> stanv: it's just desugared to the enumFrom* functions
14:30:33 <Nebasuke> dino-: You can find the parser code examples here btw: http://wwwhome.cs.utwente.nl/~michaelw/projects/vgijzel/
14:31:07 <Nebasuke> I also had some troubles in the beginning with parsec because the manual's examples don't immediately work
14:31:19 <J11> Is there easy way to rename data constructors?(not its type)
14:31:23 <dino-> Nebasuke: Ok, thanks
14:31:56 <arsenm> how would I create an equivalent parMap for Data.Map.map?
14:32:24 <shachaf> > [1.7,1.9..2]
14:32:26 <lambdabot>   [1.7,1.9,2.0999999999999996]
14:33:41 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:41 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:41 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:41 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:42 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:44 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:33:46 <Guest47975> http://www.sexy-lena.com/?uid=500413
14:34:05 <Vulpyne> Got to love it when a problem solves itself.
14:34:32 <dino-> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8089#a8089
14:34:45 <dino-> Ok, so it's records of data that consist of questions and multiple choice answers.
14:35:03 <dino-> The questions and answers may or may not continue past newlines to additional lines.
14:35:14 <dino-> Blank lines very often (but not always) contain junk whitespace.
14:35:54 <kpreid> dino-: I would consider the whitespace insignificant and look for the n] and a} markers.
14:36:02 <Nebasuke> indeed
14:36:05 <dino-> This is raw data that comes from the FCC for exam study. It comes just like this, a total sloppy ass disaster.
14:36:24 <kajamd>  Check new web site - http://www.lostworlds.lv/go.php?1139723800
14:36:46 <dino-> kpreid: Including all the newlines?
14:36:55 <kpreid> sure. there's no reason to use it
14:37:34 <dino-> The @@ is the indicator of the correct answer, but I can process that out later in a non-Parsec step.
14:38:03 <stanv>     enumFromThenTo x1 x2 y = map toEnum [fromEnum x1, fromEnum x2 .. fromEnum y]
14:38:06 <stanv> :))
14:38:51 <stanv> it seems that rules for enumFromThenTo deep hardcoded is haskell sources
14:39:07 <Raevel> wow a lot of spam bots tonight
14:39:44 <kpreid> sanders: enumFromThenTo is a method of Enum
14:40:33 <kpreid> er, stanv
14:40:49 <stanv> :))
14:40:57 <dino-> kpreid: I was trying something like that but got bogged down with the parser consuming too much. I think lack of understanding of how to use try.
14:41:19 <Nebasuke> dino-: do you have a code example?
14:41:31 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8090#a8090
14:42:06 <stanv> my solution is imperative-based :(
14:43:21 <dino-> Not of the last time I tried to read it all in in a big stream without watching for newlines, no. I've been at this for days and have deleted much code over time. :/
14:47:27 <Nebasuke> dino-: hmm, let's see. I think matching on new lines would be the best. Every question is followed by 2 newlines. And the last answer always ends in 2 newlines. (ignoring spaces)
14:47:46 <Nebasuke> the tricky part would be differentiating between the next answer and a split answer
14:47:58 <Nebasuke> but that could be solved with a try and a match for }
14:50:26 <dino-> Thanks for the help. I'll go try to read the docs and things some more.
14:50:48 <brian6> can i get cabal to compile c-sources with g++?
14:51:21 <Nebasuke> dino-: watch out with using isSpace btw. it also matches for newlines
14:52:00 <tommd> brian6: If you can I think it would be a cludge.  Perhaps cabal configure --with-gcc=g++
14:52:13 <brian6> tommd: thanks, worth a try.
14:52:28 <dcoutts> brian6, tommd: that should work
14:52:50 <dcoutts> of course you cannot force all users to do that
14:53:06 <dcoutts> but you can of course do it locally
14:53:15 <brian6> dcoutts: ok, thanks.
14:53:20 <Nebasuke> dino-: I would recommend defining a new combinator like this: isSpace' = satisfy (== ' ')
14:54:14 <tommd> I can't force all users to do that?  I just need is enough law enforcement to monitor all users - that shouldn't be an issue these days.
14:54:20 <dcoutts> The cabal --with-$PROG= flags are just a shortcut, afterall you could add a 'gcc' to the $PATH that's actually a shell script or symlink
14:54:41 <dcoutts> so adding the --with-$PROG flags doesn't let people do anything they cannot do already
14:54:46 <tommd> There isn't any way to specify this in the .cabal is what you're saying, right?
14:55:10 <dino-> Nebasuke: But those double blanks are often full of spaces. It's highly irregular.
14:55:14 <dcoutts> tommd: yes, by design.
14:55:31 <dino-> Looks like some person edits this who imagines they're sitting at a typewriter.
14:55:48 <dino-> They perhaps need to be hit with the XML stick very hard.
14:56:26 <dcoutts> tommd: you can require a 'g++' program but you should not tell users where it must live.
14:57:10 <dcoutts> you can add extra programs in the Setup.hs and you can require them as "build-tools: blah" in the .cabal file.
14:57:11 <Nebasuke> dino-: you could now define skipSpace = skipMany isSpace'
14:57:27 <Nebasuke> and call that when appropriate
14:59:03 <dcoutts> tommd: the point is that there's a division between things that rightly should be controlled by the package author vs by the package builder. Sometimes these are slightly in conflict.
14:59:31 <dcoutts> tommd: the builder is always in control of their environment, the author knows the requirements, the rest is a compromise
14:59:50 <Apocalisp> Did I come across a Set class somewhere?
15:00:15 <Raevel> Data.Set
15:00:19 <Raevel> oh wait... class?
15:00:49 <Apocalisp> Could have sworn there was a class in the libraries.
15:01:44 <dschoepe> Apocalisp: Why do you need a class instead of a data type for a Set?
15:02:40 <Apocalisp> dschoepe: I'm designing a data type that is a set of sets, and I want to express the constraint that the type parameter must be a Set type.
15:04:00 <dschoepe> Apocalisp: What set-specific operations are you using in that datatype maybe classes like Traversable or Foldable provide what you need
15:04:34 <Vulpyne> dino-: I annotated your hpaste. Kinda hacked together, but it seemed to work.
15:05:23 <Vulpyne> It assumes that ] and } couldn't be in the question/answer text.p
15:06:04 <dino-> Vulpyne: I really hope they're not. But I do not really know for sure. I have files with thousands of these questions.
15:06:26 <Vulpyne> dino: I think this might be easier to parse without parsec.
15:07:02 <dino-> I felt dirty thinking it, but was wondering if I should just do it line by line with StateT babysitting if we're appending to a Q or an A or whatever.
15:07:08 <Apocalisp> Actually, the constraint I really need is that I can map every set to a natural number.
15:07:22 <Vulpyne> You could just use a fold.
15:07:28 <dino-> Plus some regexp
15:07:45 <dschoepe> Apocalisp: Enum?
15:08:20 <dschoepe> but I don't think that Data.Set.Set is even an instance of that
15:08:33 <Apocalisp> and the function has to be injective.
15:11:04 <bakesz> hi guys!maybe this is a stupid question,but is it possible to define the factorial function as "n!" just in math,or just the "fact n" form is possible?Thank you,and sorry for my english
15:11:43 <Apocalisp> Can I express that somehow in Haskell? The type I want is like... F[A] such that there exists an injective map between A and the natural numbers.
15:11:45 <dino-> Vulpyne: Thanks for that code. It helps to see the constructions with the notFollowedBy in use like this.
15:11:56 <Berengal> bakesz, you mean the notation?
15:12:07 <Apocalisp> Looking at enum
15:12:08 <Vulpyne> dino: Sure. First time I used that.
15:12:16 <bakesz> Berengal:yes
15:12:36 <dschoepe> Apocalisp: enum might be too strong, but maybe Hashable is an option although hashes can theoretically collide.
15:12:58 <Apocalisp> Enum maps to Int, so it's not quite general enough.
15:13:21 <Apocalisp> Hashing's no good, since I need a total order.
15:13:56 <Berengal> bakesz, there's -XPostfixOperators, but they're generally a bad idea
15:14:18 <Peaker> Apocalisp: you want a: Set -> Int  that preserves "total order" of what?
15:14:42 <Berengal> bakesz, they make the syntax hard to understand
15:15:15 <bakesz> Berengal:thank you.then i will use the classic "fact n" notation
15:15:38 <Apocalisp> Peaker: That imposes a total order on permutations.
15:15:41 * Berengal just confused himself utterly by trying it out for five lines in ghci
15:16:13 <Peaker> Apocalisp: The set is unordered, isn't it?
15:16:13 * djahandarie is always confused
15:16:44 <Apocalisp> Peaker: The set is unordered, but I want a total order over all possible sets.
15:17:36 <dschoepe> Apocalisp: By what should they be ordered then?
15:19:50 <Apocalisp> Doesn't matter, as long as there's some order. For example, given the domain T = {A, B, C}, there should exist a function Set[T] -> Nat, so that if I sort some List[Set[T]], I will always get the sets in the same order.
15:21:40 <Apocalisp> Actually, that's just T -> Nat.
15:21:45 <Apocalisp> isn't it? Yes.
15:24:11 <Vulpyne> dino: I annotated with a fold version. It just turns the questions/answers into a stream, but you can detect which it is pretty easily.
15:24:45 <Apocalisp> I guess the best I can do is ask the user to supply a (t -> Integer) and warn that it doesn't work properly if that function is surjective.
15:26:06 <dino-> Vulpyne: I see. Breaks them up on these boundaries of qnum, qtext
15:26:28 <SamB> hmm, we should apparently be talking about C
15:26:31 <Vulpyne> Seems more straightforward than the parsec version.
15:26:44 <Vulpyne> Possibly someone more experienced with parsec could do it better though.
15:27:27 <skorpan> i wish parsec 3 had a nice tutorial
15:27:38 <dino-> It's less code. I would like to be more proficient at Parsec. It reminds me of being new to regexp.
15:27:41 <dino-> Hard at first
15:27:44 <skorpan> and parsec 2 for that matter, the only straight-forward tutorial i could find was from 2001 or something
15:28:26 <Vulpyne> It's a lot like using regular expressions.
15:28:55 <maradydd> Oh, cool, people talking about parsec. I'm looking at how to build an attribute grammar in Haskell, and trying to decide between parsec and happy.
15:29:19 <doublethink_work> maradydd: maybe you would like uuagc?
15:29:19 <skorpan> attribute grammar?
15:29:19 <Vulpyne> You know what's pretty sweet about parsec? You can parse stuff other than characters.
15:29:21 <doublethink_work> @hackage uuagc
15:29:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuagc
15:29:32 <Vulpyne> Like like a XML tag stream from TagSoup.
15:30:05 <maradydd> skorpan: Basically a context-free grammar decorated with semantic information -- though in a way that makes it computationally equivalent to a context-sensitive grammar. Knuth came up with them back in the sixties.
15:30:12 * maradydd checks out uuagc
15:30:33 <Peaker> Yay, Haskell is catching up with the 60's
15:30:41 <Peaker> Most languages are stuck in the 50's
15:30:45 <SamB> hehe
15:31:20 <maradydd> There really aren't any proper attribute grammar generators out there. You can fake it in yacc, so naturally you could do so in happy as well, but it'd be nice to have an idiom that's closer to the original idea.
15:31:45 <dino-> Thanks for the assistance with this parsing.
15:32:09 <SamB> maradydd: so ... what's this: http://www.haskell.org/happy/doc/html/sec-AttributeGrammar.html
15:33:11 <maradydd> doublethink_work: Yep, that may very well be exactly what I need.
15:33:43 * maradydd boggles. Truly there is nothing this language cannot do.
15:33:50 <maradydd> well, apart from solving halting or something like that.
15:34:01 <Peaker> @faq can Haskell solve the Halting problem?
15:34:02 <lambdabot> The answer is: Yes! Haskell can do that.
15:34:07 <Peaker> well, what do you know
15:34:40 <maradydd> This is what I get for hopping on irc before I'd worked my way through the whole manual :P
15:34:53 <SamB> maradydd: not, mind you, that I've any clue how to actually use that
15:34:55 <waern> could someone re-paste the link to Tim Sweeney's slides from HPG? Had to reboot and now I can't find it
15:37:21 <jix_> are there any usable irc libs for haskell?
15:38:08 <shepheb> jix_: rip the necessary bits out of lambdabot? I think they're well modularized.
15:38:33 <jix_> shepheb: but it uses templatehaskell with some lambdabot specifc stuff i don't understand
15:39:03 <Cale> http://hackage.haskell.org/package/irc
15:39:35 <doublethink_work> waern: hold on
15:39:48 <doublethink_work> waern: http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
15:39:51 <jix_> Cale: that's only msg parsing / composing.. network stuff isn't handled
15:39:53 <doublethink_work> waern: i was showing it to a coworker earlier :)
15:40:04 <jix_> Cale: but i think i'll stick to that if i don't find something more complete
15:40:05 <SamB> http://graphics.cs.williams.edu/archive/SweeneyHPG2009/ too
15:40:17 <Cale> jix_: The network stuff you can handle with the network package.
15:40:40 <jix_> Cale: but then i still have to handle stuff like replying to the stuff the sever sends to me and expects a reply to
15:40:51 <jix_> what i'm searching is something more highlevel but i guess that doesn't exist yet
15:41:27 <Cale> Like what? Pings?
15:41:36 <waern> doublethink_work: thanks!
15:42:02 <smebjev> Hi! Do the you all think 'Write Yourself a Scheme in 48 Hours' (http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours) is an adequate source of learning Haskell in addition to a good book? I've already read "Programming Haskell" by Graham Hutton, so I'm at that 'level' now.
15:42:33 <jrockway> it is a good resource
15:42:38 <jrockway> i liked Real World Haskell, however
15:43:10 <jrockway> reading that gave me what I needed to go from "summing a list" to "writing an application"
15:43:13 <jrockway> ymmv.
15:43:19 <doublethink_work> jrockway: indeed, RWH is good
15:43:22 <smebjev> jrockway: That's what I waas looking for.
15:43:24 <jix_> Cale: i'd like to have it join a channel being ready to respond to msg in that channel in 3 to 5 lines haskell
15:43:31 <soupdragon> a list summing application?
15:43:32 <jix_> that's the level of abstraction i'd wish for for an irc library
15:43:46 <doublethink_work> smebjev: http://www.realworldhaskell.org
15:43:56 <jrockway> soupdragon: nope :)
15:44:14 <smebjev> smebjev: This whole time I've been thinking "I can create a really cool factorial function, but I don't know how I'd use this"
15:44:18 <Peaker> I have another example of why Lazy IO sucks
15:44:27 <doublethink_work> Peaker: ORLY?
15:44:41 <smebjev> doublethink_work: That was the book I was going through in addition to "Write yourself a scheme"
15:44:44 <Peaker> it doesn't allow you to compose stuff/refactor it denotationally as you would compose every other thing
15:45:04 <smebjev> Are those two combined adequate? How much does RWH talk about monads?
15:45:22 <maradydd> aw, hell, NewBinary breaks under ghc-6.10 :(
15:45:23 <jrockway> it discusses them, although not for a while
15:45:27 <jrockway> chapter 7 or so?
15:45:47 <smebjev> Ah, okay.
15:46:01 <smebjev> reading the TOC now
15:46:02 <doublethink_work> maradydd: can you not just use the binary package?
15:46:06 <doublethink_work> @hackage binary
15:46:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
15:46:53 <maradydd> doublethink_work: It's a dependency for the ASN.1 module.
15:46:59 <stanv> Is there anybody who uses livejournal ? I want to paste part of haskell source, but LJ currup it :(
15:48:07 <doublethink_work> Peaker: truth
15:48:20 <doublethink_work> Peaker: lazy IO is something of a can of worms in general
15:48:36 <doublethink_work> maradydd: ah. perhaps contact the maintainer to help get it updated for GHC 6.10 then?
15:48:46 <Peaker> doublethink_work: Iteratee is good, but ugly IMO.  I have a "replace Iteratee with something nicer" on my TODO list
15:49:11 <doublethink_work> Peaker: iteratees are a nice compromise for a lot of situations
15:49:27 <maradydd> doublethink_work: yep, added to my stack. Won't be able to get to it this week but I'd like to help fix it.
15:49:31 <RyanT5000> is there a good library for dealing with signals? e.g.: filtering audio/images/video, Fourier transforms, etc.?
15:49:34 <Peaker> doublethink_work: I don't think the ad-hoc-ness of them
15:49:52 <doublethink_work> Peaker: they don't compose as well as most would like though
15:49:58 <doublethink_work> which would be really nice
15:51:12 <Peaker> doublethink_work: I think renaming Iteratee Consumer, and Enumerator Producer, and getting rid of the EOF message would be nice first steps.  Then replacing Producer from Iteratee->Iteratee  to be a ListT (which doesn't expose the data constructors) and Consumer with ConsumerT which is basically a StateT that goes over the ListT, would be a nice way
15:51:41 <Peaker> doublethink_work: yairchu and I did some work on that, but then yairchu developed it into a different kind of thing, focusing more on a full ListT and list classes
15:52:53 <doublethink_work> Peaker: neat
15:53:06 * doublethink_work begins to leave work...
15:53:28 <yairchu> doublethink_work: I found that using ListT's is fine for me. I don't need the protection from forking the list that Peaker would want.
15:55:48 <Peaker> yairchu: btw, another problem we had with this approach is that unlike Iteratee, our Producers can't have a cleanup in the end that always runs, iirc
15:56:10 <Peaker> (e.g: a file close)
15:57:08 <yairchu> Peaker: files get closed when the GC later runs
15:57:34 <yairchu> if they are ForeignPtr s with finalizers
15:57:47 <Peaker> yairchu: that's not good enough because GC doesn't know to run when file descriptors are missing
15:58:01 <brian6> dcoutts: in a Custom build, what's a good way to inform cabal about the -I, -D, -l etc options i get from library helper programs like blah-config --libs? do i do that in a preConf hook and somehow pass the info back in LocalBuildInfo?
15:58:14 <Peaker> yairchu: also, if your resource cleanup is semantically meaningful, its nicer to have an exact semantic definition of when its cleaned up
15:58:21 <yairchu> Peaker: I know. but still just making your statement more accurate
15:58:23 <Peaker> yairchu: rather than "whenever GC does"
15:58:38 <Peaker> yairchu: well, Producers still can't -- ForeignPtrs can
15:58:47 <jrockway> btw, anyone using Graphics.Vty?
15:59:16 <ski> (Peaker : why doesn't it compose ?)
15:59:16 <jrockway> the version in hackagedb segfaults, and 4.0.0 from darcs does not seem to load correctly ("There are files missing in the `vty-4.0.0' package")
15:59:21 <yairchu> Peaker: but anything requiring "extra" cleanup is foreign. thus ForeignPtr+Producer gives you want you need
15:59:31 <Peaker> yairchu: anyway, I think an Iteratee replacement that guarantees these things is more important than ListT in general, because perhaps it could get rid of lazy I/O altogether
16:00:21 <Peaker> ski: example:  yairchu just showed me code that does a readFile, action, then a writeFile.  I wanted to have something that does:  replaceFile name data = do x <- readFile name ; writeFile name data ; return x  -- but I can't because it doesn't compose this way
16:00:25 <yairchu> Peaker: in lazy IO you don't know when the resource will get freed as well. So ListT can replace it. Maybe not replace all IO, just lazy IO
16:00:50 <Peaker> yairchu: Yeah, and it will solve some of the problems of lazy I/O, but not all of them
16:01:03 <yairchu> Peaker (about your response to ski): that has nothing to do with ListT. that's about lazy IO
16:01:23 <Peaker> yairchu: indeed, ski asked why Lazy I/O doesn't compose
16:01:37 <yairchu> I thought he asked about ListT. my bad
16:01:42 <luite> how can I make a read'::String -> Maybe a  from a regular read, that doesn't throw exceptions?
16:02:06 <pikhq_> @hoogle String -> Maybe a
16:02:07 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
16:02:07 <lambdabot> Prelude fail :: Monad m => String -> m a
16:02:07 <lambdabot> Control.Monad fail :: Monad m => String -> m a
16:02:16 <Peaker> yairchu: ListT does compose, and doesn't put side effects in evaluation.  two big pluses. But it still doesn't allow for producers to control resources of the production
16:02:19 <pikhq_> HOOGLE, YOU HAVE FAILED ME
16:02:29 <yairchu> luite: utility-ht : Text.Read.HT.maybeRead
16:02:33 <luite> I know fail, but don't know how to use it in this case
16:03:01 <Peaker> yairchu: doh! ht == his initials!
16:03:05 <yairchu> luite: look at its source and then you'll know how to make it :)
16:03:35 <Peaker> luite: you can make it from reads, not from a regular read
16:03:36 <luite> yairchu: that's what I'm doing, thanks
16:03:36 <pikhq> luite: Fail is... Most definitely not what you want. ;)
16:03:42 <Saizan> there's also the safe package
16:03:45 <ski> Peaker : as i understand it, that doesn't work because lazy i/o isn't properly implemented. if it was implemented so that `readFile' got a snapshot of the file at the time of call (possibly using copy-on-write barriers), and similar for `writeFile', wouldn't it work ?
16:04:04 <Peaker> ski: how could it snapshot stuff?
16:04:08 <luite> hmm
16:04:18 <yairchu> Peaker: read all of it :)
16:04:36 <Peaker> having all operations be aware of the relationships to each other is pretty insane
16:04:52 <ski> yairchu : or read it as soon as someone else tries to change
16:04:53 <Peaker> ski: if you have a snapshotting readFile, you need to avoid using any lower-level operation
16:05:02 <ski> (or at least cache the changed parts)
16:05:52 <Peaker> ski: I think the snapshotting approach is wrong. I think perhaps a higher-level file access declarative library should be used instead
16:05:56 <ski> (Peaker : but maybe your argument is that implementing such semantics correctly is hard/impossible/inefficient ?)
16:06:13 <Peaker> ski: yeah, it is.
16:06:44 <Peaker> ski: I doubt such a thing would ever be implemented, as there are better alternatives (Explicit read there, Iteratees or ListT's)
16:06:47 <ski> why would snapshot semantics be wrong ?
16:07:43 <Peaker> ski: because its so difficult, and cannot know which parts of the data you actually intend to use (which are worth snapshotting), which a more declarative library could
16:07:56 <Berengal> What does MVar really stand for?
16:08:01 <ski> (it's similar to an atomic access to a concurrent database, i think)
16:08:02 <Peaker> ski: also, a more declarative library could be more explicit about which kinds of write operations it could withstand without corrupting your read
16:08:09 <Peaker> Berengal: Mutable perhaps?
16:08:14 <SamB> Peaker: how is a lazy snapshotting readFile worse than a strict one?
16:08:31 <Peaker> SamB: false negative identification of writes to that file
16:08:39 <Peaker> SamB: no way to comprehensively detect writes
16:08:49 <Berengal> Peaker, but so's IORef. I'd guess Mutex or something like that first... but I really have no idea
16:08:57 <SamB> Peaker: I think the idea was that you'd have snapshotting that worked!
16:09:12 <Peaker> SamB: what if another process written in C writes to the file?
16:09:15 <Berengal> I've always known what they are, but now I need to know how to say what they are as well...
16:09:16 <Peaker> later?
16:09:25 <SamB> I didn't think it was a serious proposal of what could realistically be done with current OS primitives ...
16:09:42 <jix_> are there file systems with lazy cp?
16:09:52 <ski> Peaker : the OS would trigger the copy-on-write
16:10:19 <Peaker> ski: ah, OS-level snapshots at every read sounds potentially extremely expensive
16:10:45 <SamB> Peaker: not at every read
16:10:53 <SamB> just somehow
16:10:58 <ski> at writes with a non-snapshotted read before
16:11:09 <Peaker> ski: and again, you may call readFile to later use take 5 on it -- and don't need the rest of the bytes, which it cannot know.  if it was more declarative it would encourage you to be explicit about it
16:11:31 <Peaker> ski: At writes on an area it knows has a "pending read". I call this "pending read" a snapshot
16:11:57 <ski> a lazy snapshot
16:12:26 <Peaker> storage systems generally implement snapshots lazily, with cOW
16:12:37 <Peaker> so each read creates an OS-level snapshot, expensive
16:12:43 <ski> you may be right about space leaks ..
16:12:44 <Peaker> (Just the COW metadata is expensive)
16:12:48 <SamB> Peaker: anyway, hReadFile reads the *whole* file, so it's not really a very complicated snapshot facility that you need ...
16:13:18 <SamB> might be bad for performance, sure
16:13:34 <Peaker> not sure why go through these insane hoops to support a broken model of sticking side effects inside evaluation :-)
16:13:35 <ski> yes, it probably is not a panacea
16:13:53 <Peaker> just kill lazy I/O and replace it with Iteratee or something better
16:14:09 * ski still doesn't see how it's "sticking side-effects inside evaluation"
16:14:22 <SamB> unsafeInterleaveIO
16:14:48 <Peaker> ski: if you use an OS-level mmapSnapshot rather than an actual data-copying read, then you could say it isn't doing that
16:14:51 <ski> that's concurrency, from `IO'
16:14:56 <Peaker> but I don't know of any OS's that provide that
16:15:06 <Peaker> ski: concurrency driven by evaluation
16:15:25 <Saizan> ski: saying that it's concurrency is a lie, you can control the scheduler via seq
16:15:26 <Peaker> ski: evaluation order suddenly matters
16:15:44 <ski> no, it's like other concurrency, in that order is not defined
16:16:05 <Peaker> ski: if the order is not defined, without snapshots "readFile" is useless
16:16:21 <ski> that the order can actually be determined in some cases, by examining forcing order just lessens the unpredicability, somewhat
16:16:36 <SamB> well, it's not undefined
16:16:40 <SamB> just indeterminate
16:17:03 <SamB> you can tell that it will happen before you reach a case branch that depends on the result
16:17:08 <ski> conceptually, it's as interdeterminate as `forkIO'
16:17:18 <Peaker> ski: I can detect evaluation order with unsafeInterleaveIO and reading from some pipes/sockets
16:17:25 <Peaker> (of pure values)
16:17:40 <Peaker> I can break referential transparency
16:17:51 <Peaker> (I think)
16:18:00 <Saizan> not sure ifyou can break ref. transparency
16:18:18 <ski> Saizan : you can control the order of thread scheduling with synchronizing, too .. what's the difference ?
16:18:47 <Saizan> ski: that evaluation is not in IO :)
16:19:02 <Berengal> I've found out that MVars got their name from M-structures (from the Id language), but what the M means google completely fails to tell me
16:19:24 <Saizan> it's subtle, you probably can't break any major thing with unsafeInterleaveIO, without a proper semantics for IO at least
16:19:51 <ski> Berengal : "Mutable", iirc
16:19:53 <Saizan> but it does feel like something is wrong
16:20:50 <Peaker> x <- hGetContents someSocket1 ; y <- hGetContents someSocket2 ; order of evaluating x,y is exposed to sockets, can this be used to break referential transparency?
16:21:03 <ski> (Berengal : and the "I-structures" could be "instantiated" only once, if my memory serves ("I" for "Immutable" ?))
16:21:05 <hydo> Saizan: any idea if your awesome patch to cabal-install is ever going to be applied?  I keep watching the mail list but I never see a mention of it.
16:21:28 <Saizan> hydo: i think it has been applied
16:21:46 <Berengal> ski, thanks. Now I need to figure out how to translate that into buzzwords :/
16:22:21 <hydo> Saizan: Oh, really?  sweet!  I must have missed that.  Time to update/upgrade.
16:22:43 <Saizan> hydo: i don't think there has been a new release since then
16:22:51 <Saizan> hydo: but the repo should have it
16:22:59 <hydo> Saizan: ah, ok... i'll grab it from darcs then.
16:23:01 <hydo> hehe
16:23:06 <Peaker> what does the patch do?
16:23:12 <Saizan> you'll need darcs cabal too
16:23:21 <ski> (for clarity, i'm using "concurrency" here in the wide sense that includes sequential evaluation, as well as reorderings due to optimizations)
16:23:27 <hydo> Saizan: yea, makes sense.
16:23:56 <Peaker> Saizan: maybe cabal-install can have "darcs-X" or "git-Y" as an alternative to a version number, and then cabal-install could figure dependencies of that similarly, and darcs/git get those
16:24:12 <Saizan> Peaker: it keeps a per-user index of haddock docs of your installed packages
16:24:24 <Peaker> cool! :-)
16:25:02 <Saizan> (except for the hidden ones)
16:29:53 * liyang is getting #reactive. Lots of #push​ing and #pull​ing, but his #futures are definitely #improving, #continuous​ly and  #unamb​iguously…
16:30:02 <liyang> (sorry, had to share. :3)
16:30:33 <soupdragon> what is this !!
16:30:36 <RayNbow> hmm
16:30:53 <soupdragon> RT @liyang is getting #reactive. Lots of #push​ing and #pull​ing, but his #futures are definitely #improving, #continuous​ly and  #unamb​iguously…
16:30:54 <RayNbow> I can no longer paste in ghci 6.10.3 under Windows?
16:31:10 <liyang> Peaker: no, only Chuck Norris can break referential transparency.
16:31:37 * RayNbow also notices that Ctrl+Z (EOF in Windows) also no longer works
16:31:58 <skorpan> iirc, they changed from readline to editline or the other way around
16:31:58 <liyang> soupdragon: I've wondered about a Twitter to IRC gateway. They must exist...
16:32:19 <Saizan> RayNbow: mh, try ghci-haskeline
16:32:59 <comrade`phil> GRAAAR
16:33:15 <Raevel> RayNbow: i noticed a missing shortcuts on os x as well => posted a ticket about it => ghc devs said they wanted to know if any other bindings had been lost
16:33:32 <ivant>  does anyone know some contact person for ICFP conference in Edinburgh? I need the contact to get the UK visa
16:34:39 <liyang> Raevel: link? When did they switch to haskeline? And has it anything to do with Ctrl-W not doing what I'd expect it to do?
16:35:06 <Raevel> .3, iirc
16:35:29 <Raevel> i'll see if i can find my ticket
16:37:17 <Raevel> liyang: http://hackage.haskell.org/trac/ghc/ticket/3338
16:37:20 <liyang> Raevel: might be a different issue then. I'm currently trying to upgrade from 6.10.1, and I've noticed that for some time that Ctrl-W deletes to the beginning of the line rather than the previous space. Which is incredibly annoying.
16:37:40 <RayNbow> Saizan: ghci-haskeline?
16:38:43 * RayNbow cabal installs...
16:39:35 <RayNbow> Saizan: pasting works in ghci-haskeline
16:39:50 <RayNbow> Ctrl+Z doesn't
16:40:07 <Raevel> liyang: if you're using haskeline you can rebind it easily
16:40:29 <Raevel> i notice that C-w deletes the whole line for me too
16:40:36 <Axman6> gotta love twitter spam accounts: "Jenna Mann (HennaJenna) is now following your tweets on Twitter. <picture of attractive blonde with fake boobs>, 185 followers, 15 tweets, following 1114 people
16:40:55 <Raevel> oh, ooops, no it didnt
16:40:56 <liyang> Raevel: I'm not sure if their goal is to have a drop-in replacement for readline, in which case the behaviour I expected would be nice to have as the default.
16:41:17 <liyang> soupdragon: are you on Twitter? :3
16:41:18 <Raevel> it only deletes to the last space
16:41:28 <soupdragon> no
16:41:39 <soupdragon> I don't know what to twit
16:41:54 <Axman6> soupdragon: i mainly follow haskel people
16:42:03 <Axman6> rarely do i 'tweet'
16:42:28 <liyang> soupdragon: in-jokes, obscure references. Confuse and confound your friends.
16:43:22 * liyang is sure a GHC build from MacPorts isn't supposed to take this long...
16:43:38 <Saizan> longer?
16:43:38 <Axman6> ghc always takes forever
16:43:50 <Axman6> it's like PHP
16:43:55 <liyang> At least an hour, if not two now.
16:44:11 <Axman6> sounds about right
16:44:26 <Saizan> poor mac os users..
16:44:27 <liyang> I've finished reading all I care to read about Reactive, and am itching to put some of it into practice. >_>
16:47:50 <Sargun_Screen> Can someone tell me is this is haskell: http://pastebin.com/d71c74faa
16:48:34 <arsenm> Sargun_Screen: no
16:48:54 <Raevel> it looks like...
16:49:21 <Raevel> a little like pascal?
16:49:34 <Sargun_Screen> It's supposed to be psuedocode
16:49:41 <Raevel> oh :-)
16:49:56 <Sargun_Screen> but I'm having a hard time understanding N.
16:53:38 <Sargun_Screen> maybe N is a finite number
16:53:45 <Axman6> zomg it's not a memoryless system!
16:54:55 <liyang> Sargun_Screen: it's an IIR filter -- http://en.wikipedia.org/wiki/Infinite_impulse_response
16:56:15 <liyang> `n' is indeed a finite number.
16:56:20 <liyang> What are you trying to do with it?
16:57:26 <Sargun_Screen> Bandpass filter
16:57:39 <Sargun_Screen> I'm trying to build an equalizer.
16:58:24 <liyang> Sargun_Screen: no amount of staring at pseudocode is going to help you unless you learn yourself some digital filter theory. :3
16:59:14 <Sargun_Screen> liyang: where would you recommend I go for that
16:59:38 <liyang> Sargun_Screen: a library. :-/
17:00:00 <liyang> I don't know about your background so I'm not sure where to start.
17:00:45 <Sargun_Screen> Math wise? Basic calculus.
17:05:01 <randomwords> I asked this earlier but noone had any answers: The following has a strategies space leak http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3271. Profiles show that when the lists are not freed when they are supposed to be (i.e. after printing), one idea was that sparks are not dieing properly. The leak doesn't occur is parList is used (but does occur with parListChunk, even with a chunk size of 1)
17:05:14 <liyang> Some introductory digital signal processing book, perhaps. (I only dabble in the area so can't recommend specifics.) That's only if you want to understand your implementation. Though I highly recommend that. (Understanding, I mean.)
17:08:45 <erikc> understanding is nice
17:22:03 <monochrom> Oh, QP just left, just when I was reading his funny quote:
17:22:18 <monochrom> @quote QP I drink
17:22:18 <lambdabot> QP says: i drink i'm two thunk for this... i'm seeing (Double, Double)
17:37:53 <McManiaC> hey, one question:
17:38:04 <McManiaC> how would you realise a simple "global" counter in haskell?
17:38:25 <soupdragon> McManiaC: lol
17:38:49 <monochrom> I don't. I would avoid it. I would re-factor.
17:38:51 <soupdragon> McManiaC: I would make two haskell program that talk via networking... one is the counter
17:38:52 <McManiaC> soupdragon: tell me :) imo its not as simple as it sounds
17:38:54 <sundaymorning> you can use IORef
17:38:58 <blackdog> is there a combinator for the pattern where, given an initial state, an updater function and a test for when to stop, it'll iterate until the predicate fires?
17:39:14 <shapr> until?
17:39:30 <Lemmih> McManiaC: http://haskell.org/haskellwiki/Top_level_mutable_state
17:39:31 <monochrom> But I know how to use unix signals to simulate it.
17:39:44 <blackdog> shapr: you are my favourite person in the world and i want to have twenty of your babies. thank you.
17:39:47 <sundaymorning> you'll be trapped inside an IORef monad I think, but it may work for you
17:39:48 <shapr> hah
17:39:53 <McManiaC>  ah thank you Lemmih !
17:39:54 <sundaymorning> also, check state monad
17:40:19 <monochrom> And oh, a simpler way is to use environment variables.
17:40:40 <McManiaC> environment?
17:41:35 <medfly> that wiki is entertaining.
17:41:48 <monochrom> as in http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Env.html
17:41:52 <Cale> McManiaC: The best way is to avoid it altogether.
17:42:07 <medfly> Cale, I hate you
17:42:41 <monochrom> Why would anyone want 20 of shapr's babies? What for? To eat?
17:42:54 <Cale> McManiaC: But an easy enough way is to pass an IORef parameter to whatever functions need to access that counter.
17:42:55 <shapr> Because I'm awesome!
17:42:57 <shapr> and modest!
17:43:00 * Berengal wonders if he even has 20 babies
17:43:34 <medfly> "I want to have your babies" is like a very blunt way of praising someone
17:43:56 <shapr> ghc-pkg list|wc -l gives 269! w00!
17:44:42 <Berengal> medfly, or it could be litterally true, relying on the other definition for hiding in plain sight
17:45:05 <shapr> I don't have any babies :-(
17:45:41 <medfly> it might be more common in my language if you're unfamiliar with it :-)
17:46:13 <Berengal> I might also be lacking sleep and should've gone to bed several hours ago
17:46:41 <gwern> medfly: I always liked 'marry me!'
17:46:50 <gwern> because everyone can use it
17:47:00 <sbahra> wow
17:47:05 <sbahra> Oh, this isn't #haskell-blah.
17:47:10 <medfly> well, I have seen males use it too.
17:47:20 <medfly> well, he seemed confused about it. goodnight, yairchu :-)
17:47:30 <gwern> (and if the recipient objects that you're both of the same gender, then you can retort, 'for you I'd be gay!'; so a double-win)
17:47:57 <yairchu> medfly:)
17:48:36 <monochrom> I want 20 of shapr's packages.
17:48:47 <blackdog> medfly: blunt? you wound me...
17:49:03 <shapr> Hey, my package is my own.
17:49:20 <medfly> I didn't realise blunt is an offensive word. sorry.
17:49:21 <shapr> ghc-pkg list|tr ',' '\'n|sort|uniq|wc -l returns 919
17:49:46 <gwern> shapr: sharing your package is the haskell way!
17:49:57 <gwern> be Free with your haskell junk
17:50:30 <chaosape> I can ensure referential transparency in a function with side effects just by inputing an unused parameter that is always unique right?  That is totally an awful thing to do right?
17:51:04 <gwern> isn't that how the IO monad works, with RealWorld#?
17:51:26 <pikhq> gwern: That is one possible way of implementing it.
17:51:33 <pikhq> (that's how GHC does it, IIRC)
17:51:33 <gwern> in ghc, I mean
17:51:41 <gwern> who cares how else one could do it
17:51:49 <pikhq> chaosape: That's totally an awful thing to do in Haskell.
17:52:32 <pikhq> chaosape: However, other languages use that for their side effect functions. (the type system ensures uniqueness -- this is called "uniqueness types")
17:53:30 <chaosape> pikhq : okay (thanks! -- uniqueness type == learninging stuff ) ... under the hood though is that how alot of IO monads are implemented?
17:54:16 <blackdog> medfly: heh. mock-offended only.
17:54:25 <pikhq> chaosape: Not quite.
17:54:41 <pikhq> chaosape: I think for now, it is best to assume that the IO monad is implemented using magic and fairy dust.
17:54:55 <pikhq> (and monads)
17:55:36 <Berengal> Actually, I think GHC uses something not too far from uniqueness types to implement IO under the hood
17:55:44 <blackdog> chaosape: you program to the spec, right? any given haskell implementation might implement it differently
17:55:53 <shapr> gwern: haha
17:57:26 <chaosape> blackdog: i am pretty much a newbie ... so i program to compile  ... ;^)
17:57:49 <blackh> chaosape: Here's another answer that might be useful: GHC uses passes RealWorld in one side of an IO action and takes a modified RealWorld out the other side.  However, this is really special stuff, and you can't assume that any other function will work like that.  The short answer is:  If you want to use side effects, use the IO monad.
17:58:56 <liyang> (Or at least, any stack of monads with IO at the bottom.)
17:59:02 <liyang> *transformers
18:00:43 <chaosape> blackh: ack! ... i am trying to understand IO in the context of lazyness ... is there a set of guidelines somewhere to implement a backend library that is sanctioned "safe" for lazy evaluation.
18:02:01 <badsheepy> i gave ghc the world and all i got was this damn type error
18:02:06 <shapr> badsheepy: haha
18:02:11 <shapr> badsheepy: Should be the World
18:02:13 <blackh> chaosape: It *is* legitimate to do things like this: Define a FFI wrapper to the C 'sin' function and then (because you know 'sin' is referentially transparent) make your library export a function that calls it with unsafePerformIO.
18:02:16 <shapr> Or World#
18:02:20 <badsheepy> :)
18:03:12 <monochrom> "understand IO in the context of lazyness" sounds misguided. IO actions aren't lazy, for the most part.
18:04:43 <liyang> IO actions are first-class values.
18:05:14 <monochrom> I mean IO actions are executed by the runtime system unlazyly
18:05:15 <gwern> Oh, the majesty of the Haskell laws, which forbids pure and side-effecting functions alike to steal bread, to sleep under brideges!
18:06:39 <blackh> chaosape: Or to put it another way, essentially when using unsafePerformIO, your function must either really be referentially transparent, or have effects that don't matter, for example Debug.Trace.trace.  Otherwise your program will break sooner or later.
18:06:43 <chaosape> monochrome: hmm ... so i am thinking i have a stream of data that is being read from somewhere and there is no reasion to read the nth chunk until i want it ... maybe that is a bad way for me to think about it.
18:07:33 <chaosape> blackh: okay ...so unsafe* doesnt mean "dirty" (e.g hack ) ... it means "be careful" ...
18:07:34 <monochrom> Some IO actions do that. Like getContents. But not the norm.
18:07:48 <liyang> chaosape: So rather than think of the program-writing process as ``okay, I'll make the computer do x, then do y'', rather think of it as ``the program I want consists of the action x followed by the action y'', if that makes any sense.
18:08:51 <liyang> Possibly not. GHC's taken three hours to compile, and my lap is getting exceedingly warm. -_-;;
18:09:19 <monochrom> main = do { x <- getLine; putStrLn "hi"; print (length x) }  These actions are executed in that order. None of "oh x is used later so let's print hi before reading input".
18:11:06 <liyang> no, but the ``print (length x)'' action may be evaluated before the ``putStrLn "hi"'' action...
18:11:49 <liyang> (Sorry, am not helping. ;)
18:12:41 <blackh> chaosape: That's right. There is such a thing as lazy I/O (such as getContents) which is really the only grey area. You do need to approach the whole question with perhaps a bit more caution that you might realize. It is a tricky one, because the benefits of lazy I/O can be huge. But remember that Haskell is so powerful that it's actually possible to write some very clever monadic code that gives you the same advantages without the unsafety
18:12:57 <pikhq> liyang: Evaluated but not performed. :)
18:13:02 <monochrom> Your evaluation is probably not my execution. Your evaluation is probably unobservable religion. My execution is observable science.
18:13:17 <mike-burns> That's deep.
18:13:51 <blackh> chaosape: For example, "co-routines" are very easy to write in Haskell using all sorts of different techniques.
18:14:14 <chaosape> monochrom: got it! ... though if getline and putstrln are using different file descriptors ... lazy evaluation would be ok ... so lazy IO is based on the semantics of the backend machinery right?
18:14:30 <liyang> pikhq: I mean what I say, and I say what I mean. #philosophy #deep
18:15:06 <liyang> chaosape: I'd just avoid trying to understand lazy IO for now.
18:15:57 <gwern> lazy IO should basically be confined to use of 'interact'
18:16:09 <gwern> and getcontents
18:16:16 <chaosape> blackh: ack! i think i am bit more knowledgable than i was 20 minutes ago, thanks!
18:16:18 <gwern> dealing with stdin, it's much harder to hurt yourself
18:16:18 <soupdragon> lazy IO SUX
18:16:33 <gwern> and lazy IO + stdin = scripting win
18:16:34 <liyang> Certainly, you won't be writing any lazy IO code in the sense of hGetContents. (At least I've managed to avoid it so far.)
18:16:53 <chaosape> liyang: working with a stream of packets and I really want to put it into a list comprehension ;^)
18:17:43 <liyang> chaosape: don't get me started on lists. It's the lowest common denominator when it comes to picking the right data structure.
18:17:53 <mike-burns> Will that work? unsafePerformIO and a list comprehension?
18:18:30 <chaosape> mike-burns: i have a test case of it working (i think)... seems like it would work in concept ...
18:18:32 <liyang> Sometimes, lists are the right choice. Oftentimes, they're not.
18:19:11 <mike-burns> chaosape: Sounds, well ... unsafe.
18:19:22 <chaosape> liyang: oh? ... is there something to read along those lines ... i dont want to use the wrong stuff!
18:19:48 <gwern> chaosape: not really. there's no typeclassopedia for haskell datastructures
18:19:50 <mike-burns> chaosape: What really matters is the operations you're performing on the data structure.
18:20:40 <shapr> How are NMUs handled with Hackage?
18:21:53 <gwern> shapr: last I tried they weren't blocked
18:22:02 <chaosape> hrm ... i seem to hearing that if i want to perform lazy IO ... i am probably thinking about the problem wrong ... i geuss that is good though!
18:22:14 <shapr> My mass hackage building has found a few bugs...
18:22:18 <shapr> gwern: Good to know, thanks.
18:22:49 <gwern> shapr: on the other hand, a lot of things I did with hackage have since been banned...
18:23:03 <shapr> heh
18:23:18 <gwern> (but my love for hackage was pure! it's society which condemns us as unnatural and crimes against programming)
18:23:26 <shapr> :-)
18:23:34 <liyang> chaosape: what mike-burns said. Knowing what the ones in the standard GHC distro are capable of, is generally a good idea. (e.g. Data.{Map,Set,Sequence}) More specialised ones on Hackage.
18:24:24 <monochrom> "The road to Hell is paved with good intentions and pure love."
18:24:35 <chaosape> liyang: thanks!!  thats helpful ... i am going to spend some time building a typoclassopedia in my head!
18:24:51 <monochrom> But consider lazy I/O an advanced technique.
18:29:26 * shapr slowly grinds away at the bugs...
18:30:08 <chaosape> monochrom: ack! i am a systems guy so my first instinct is to understand the device and then make it do what i want ... but this is helpful ... i am going to go do some more reading ...
18:30:54 <mike-burns> It's kinda impossible to tell someone to deal with a topic later and have them listen.
18:31:07 <shapr> yup
18:31:20 <mike-burns> It only encourages them more, really.
18:32:12 <mike-burns> chaosape: The fastest route to both understanding and implementing is to do it without lazy IO then with, and to compare the two techniques that way.
18:34:19 <chaosape> mike-burns: got it! that make sense ... the only real benefit i currently see with lazy IO is performance ... and you folks have reminded me that premature optimization is evil
18:34:34 <mike-burns> Excellent.
18:36:57 <monochrom> Consider Iteratee an advanced technique.
19:00:31 <shapr> hiya michaelfeathers
19:00:53 <michaelfeathers> shapr: Hey, how's it going?
19:01:09 <shapr> Having fun finding bugs on hackage at the moment, how's it going with you?
19:02:08 <michaelfeathers> Working on a vim clone in Haskell.
19:02:23 <michaelfeathers> It's really naive, but I'm having fun.
19:02:26 <shapr> I'm enjoying your blog posts.
19:02:32 <michaelfeathers> Thx.
19:03:47 <trez> :D
19:04:15 <shapr> hej trez
19:04:32 <Nafai> Hi shapr!
19:04:33 <shapr> god morgon!
19:04:36 <shapr> hiya Nafai, how's code?
19:04:41 <michaelfeathers> I kinda wish I had a stack trace when I get an exception on !!
19:05:04 <shapr> I think ndm wrote something .. Catch? that handles that sort of thing.
19:05:18 <Nafai> Oh, not too bad, I haven't written much lately.  About to start diving in though!
19:05:23 <Nafai> You?
19:05:25 <shapr> But it may be more for finding incomplete pattern matches, I'm not sure.
19:05:52 <shapr> Nafai: I'm polishing hackage. Last night I ran a script to install everything, now I'm checking out the build failures.
19:06:30 <blackdog> michaelfeathers: using partial functions leaves you in a state of sin :)
19:06:47 <dino-> shapr: Does hackage build the haddock as well?
19:07:00 <shapr> dino-: I don't know, haven't checked.
19:07:02 <michaelfeathers> It would be nice if total and partial functions were marked as such.
19:07:51 <roconnor>  partiality monad!
19:07:56 <Nafai> shapr: Awesome!
19:08:08 <shapr> I sometimes put in a final case: x = error "$FUNCTIONNAME did not handle " ++ show x
19:08:53 <Nafai> I'm going to be learning the GHC-API soon
19:09:00 <shapr> Of course, that assumes the function takes an instance of Show.
19:09:24 <blackdog> michaelfeathers: yeah, true. historical accident, i guess... most modern libraries return Maybe if there's a chance of it going wrong
19:09:24 <shapr> Cool, I haven't played with the ghc-api yet.
19:09:29 <michaelfeathers> I read someplace that APL-ish langs tend to make all functions total so you always run to completion.. if you made a mistake you should be able to tell from the wild results.
19:09:31 <dino-> shapr: mm, looks like it tries. I put a bug in recently for MissingH haddock gen failure. I see it in Hackage's log too.
19:10:04 <mike-burns> michaelfeathers: It must be impossible to track down a bug like that.
19:10:06 <dino-> I'm kind of nuts about having local docs for everything I build/install.
19:10:17 <blackdog> depends what you mean by total, i guess. standard in haskell is to wrap it explicitly in Maybe, so it won't compile if you don't handle the Nothing case
19:10:24 <blackdog> (or at least complain strenuously)
19:10:35 * shapr builds bamboo
19:10:42 <michaelfeathers> mike-burns: rewards people who understand what their program is supposed to do, I think.
19:11:40 <michaelfeathers> shapr: Is $FUNCTIONNAME a macro?
19:11:58 <michaelfeathers> language construct?
19:12:13 <blackdog> hey, i was thinking about some testing stuff recently... I know we have a buildbot for GHC, but basically nothing else. It'd be really nice to have continuous integration servers running on hackage packages... I know it's expensive to run servers, but surely for Haskell there must be a heap of unis around that could afford a few darcs checkouts+compiles. Any ideas?
19:12:22 <blackdog> michaelfeathers: he's slipping into perl
19:12:52 <michaelfeathers> blackdog: ;-)
19:12:54 <shapr> michaelfeathers: Nah, it was just "whatever this function is actually called"
19:13:09 <mike-burns> blackdog: We discussed last night the idea of cabal-install sending build reports back to Hackage.
19:13:12 <shapr> blackdog: I have an 8 core x86 blade.
19:13:24 <shapr> and a bunch of other hardware
19:13:24 <michaelfeathers> shapr: k.. I would be neat though.
19:13:37 <shapr> michaelfeathers: You could do it with Template Haskell, I think.
19:13:48 <blackdog> shapr: well, i didn't want to volunteer you without you saying something first ;)
19:13:52 <shapr> :-P
19:14:02 <blackdog> the only problem is that testing in cabal is a bit fragmented, i think
19:14:08 <shapr> So, that's the place to start?
19:14:16 <blackdog> pete gammie took a look at the testing hook, and it's not really adequate
19:14:21 <blackdog> yeah, that's what we were doing in TBC
19:14:25 <shapr> I haven't tried tbc yet, it didn't build.
19:14:31 <blackdog> oh noes! what happened?
19:14:38 <michaelfeathers> I haven't looked at Template Haskell yet... the idea seems so odd as the sort of parametric polymorphism that Haskell has natively is the sort of thing people often introduce templates/generics to introduce.
19:14:42 <blackdog> (parenthetically, this is why we need buildbots:)
19:14:48 <shapr> It requires cabal 1.7+ and I have 1.6
19:15:30 <shapr> michaelfeathers: Yeah, but Haskell still requires zip, zip3, zip4, etc
19:15:36 <blackdog> ah, fair enough. i think that was in there for some important reason, but i'll have to have a look.
19:15:39 <shapr> TH can do zipN
19:16:03 <soupdragon> can do zipN with GADTs and type families ?
19:16:04 <blackdog> michaelfeathers: the other nice thing is more about moving computation to compile-time, although the process in TH is occasionally a bit fraught
19:16:08 <michaelfeathers> shapr:  Yeah.. It always seems that strongly typed languages have those sorts of edges.
19:16:52 <soupdragon> infact no GADT
19:16:54 <soupdragon> just families
19:16:58 * shapr installs BASIC
19:17:08 <shapr> soupdragon: Can you? How so?
19:17:14 <shapr> I haven't played with type families yet.
19:17:59 <soupdragon> I imagine having a number 'n' and compute the types (a -> b -> ...) -> ([a]) -> [b] -> ...) working
19:18:01 <michaelfeathers> I did a parody post to Haskell Cafe last year where I had some code that was calling (nub . nub) zip12 and asked if there was a zip13 and no one called it out as a joke.
19:18:30 <shapr> hahah
19:19:09 <shapr> @remember michaelfeathers I did a parody post to Haskell Cafe last year where I had some code that was calling (nub . nub) zip12 and asked if there was a zip13 and no one called it out as a joke.
19:19:10 <lambdabot> Done.
19:19:47 <Saizan> hah
19:20:03 <Saizan> but (nub . nub) zip12 doesn't typecheck!
19:20:28 <michaelfeathers> http://www.haskell.org//pipermail/haskell-cafe/2008-July/044956.html
19:20:59 <mike-burns> "Sorry to distract from your issue, but I note that (nub . nub) can be replaced with just 'nub'"
19:21:07 <mike-burns> Microrefactorings all over the place.
19:22:02 <michaelfeathers> mike-burn: That's part of the joke.
19:22:22 <mike-burns> Yes, but the fact that someone went for that is excellent.
19:22:28 <blackdog> don's point was gently made, i thought :)
19:23:10 <shapr> There's also a lot of "You're the user, you know what you're doing, we'll answer your question even if we don't understand why you want to do something that way." in this community.
19:23:16 <dobblego> it's a common question, so I wouldn't expect anyone to think it out of place
19:23:54 <QtPlaty[HireMe]> Seems to be the oppisit attitute in the Perl community.
19:24:10 <shapr> I very much agree.
19:24:25 <shapr> In fact, the #perl community was the inspiration for that attitude.
19:24:26 <mike-burns> It's part of our extremely friendly/extremely helpful reputation.
19:24:27 <michaelfeathers> It does seem like a very friendly community.. that's nice.
19:24:36 <Saizan> sometimes we do ask "what are you trying to do at an higher-level?"
19:24:52 <soupdragon> that's what I ask
19:25:34 <michaelfeathers> And of course, the answer is air traffic control with Microsoft H# running  under Visual Studio surrounded with SQL errors.
19:25:56 * shapr grins
19:26:24 <QtPlaty[HireMe]> Meany people seem to think that its rude to ask the higher leval questions when people get this.
19:27:15 <mike-burns> But especially on a mailing list, some people don't have time to ask the important questions and instead give quick refactorings.
19:27:17 <soupdragon> yes
19:27:31 <Saizan> i do that mostly when it looks like the user is trying to port some technique from other paradigms that won't apply here
19:28:32 <Saizan> and you do need to phrase it so it doesn't sound like "you're stupid for doing everything wrong!"
19:29:04 <shapr> Yeah, very much so.
19:29:12 <soupdragon> I wish people didn't read it that awy
19:29:55 <soupdragon> it's difficult any irritating when manners and politeness protocol get in the way with accurate technical discussion
19:30:10 <mike-burns> Sure, but that's life.
19:30:19 <Saizan> you've to deal with that :)
19:30:27 <shapr> Also, people don't usually choose language/platform/etc for technical reasons.
19:30:35 <monochrom> I only keep those parts of manners and protocols that don't interfere.
19:30:38 <shapr> They choose it for emotional reasons, and community is the biggest part of that.
19:30:46 <mike-burns> The nihilists are showing their true colors ...
19:30:49 <michaelfeathers> It's like debugging.. when people tell me what they've seen, I saw "show me."  That doesn't mean I don't believe you, it means we're all human.
19:30:49 <soupdragon> well not me
19:30:56 <soupdragon> I do not care abou the commnuity :p
19:31:16 <soupdragon> and I hate when I read "This software/language is dead"
19:31:18 <shapr> You gotta care about the community man!
19:31:44 <soupdragon> I like haskell community but I don't use haskell..
19:32:00 <mike-burns> I hate when people hate "this _ is dead". It has a meaning even thought it's not nearly close to what it looks like it means.
19:32:11 <monochrom> Oh, people should really learn the scientific method. Divulge enough information to easily reproducible result. Publish or perish. Detail or die.
19:32:11 <soupdragon> (not for a long time)
19:32:17 <shapr> Right, much like "_ sucks" often means "That got me really frustrated."
19:32:31 <mike-burns> Right.
19:32:42 <mike-burns> Words don't really mean things anymore; you have to pick through the sentence for the emotions underneath.
19:32:53 <shapr> I think it's always been that way.
19:32:59 <mike-burns> Probably.
19:33:36 <soupdragon> another ridiculous politeness protocol is: You may say something "positive" without any justification or backing up, but you may not say something negative without making it 'constructive' by backing it up
19:33:42 <monochrom> I have also learned enough to detect the provoke-challenge tactic, i.e., some people say "you suck" hoping to provoke you to help because you want to prove you don't suck. I ignore when I see such tactic.
19:34:09 <soupdragon> I don't want to polarize everything I say into + and -, I consider it rude to force other people to do so
19:34:35 <mike-burns> soupdragon: Would you prefer everything be backed up, or prefer it be okay to say a negative without citations?
19:34:46 <soupdragon> but I am not some ogre that doesn't care about stamping on peoples toes so I play the game
19:35:09 <ray> unqualified negatives would be nice
19:35:12 <soupdragon> mike-burns, what I would prefer is not being asked "what is your favorite film"
19:35:14 <ray> stupid political correctness
19:35:56 <monochrom> It is impractical to justify everything said. But should be ready to be asked to justify.
19:36:34 <ray> well, you shouldn't have to be prepared, because your assertion should come from sound reasoning in the first place
19:36:39 <mike-burns> You sound smarter if you can justify things. The justification can be (and probably is best) made up on the spot.
19:38:39 <mike-burns> soupdragon: The reason I want to hear someone's justification for a negative is sheer curiousity. I don't hear negatives with good justification enough and I'm always searching.
19:38:53 <mike-burns> It took me a long, long time to hear something negative about Haskell from someone who knows it.
19:39:08 <ray> i don't believe that, people bitch about haskell all the time in here
19:39:39 <monochrom> He means negative with good justification
19:39:45 <mike-burns> Yeah.
19:40:08 <mike-burns> I tried searching the Web and only found people saying that it's a useless language, without any real justification either.
19:40:21 <shapr> You can also be critical without being negative at all.
19:40:24 <mike-burns> Coming in here did help, but it took maybe three days for it to surface.
19:40:30 <soupdragon> shapr yes that is just what I mean
19:40:43 <mike-burns> Hm, that's a good point.
19:40:47 <soupdragon> this negative positive thing is an abhorration
19:41:01 <Nafai> It's the great people here in #haskell that have kept me wanting to master the language, even though I've been trying off and on for 2 1/2 years now
19:41:34 <SamB> so, if Haskell died, would you still come here?
19:41:49 <soupdragon> what does haskell died mean
19:41:50 * shapr shrugs
19:41:58 <SamB> soupdragon: that's not the point!
19:42:01 <monochrom> depends on how funny the other people here are. :)
19:42:13 <mike-burns> Nah. I'd go to the other channel you guys create.
19:42:16 <shapr> Nothing lasts forever. If #haskell or Haskell falls over, you still have the connections you've built with the smart people you've met here.
19:42:20 <shapr> mike-burns: exactly!
19:42:36 <SamB> I guess I was just wondering if we'd keep using this cannel or not
19:42:43 <ray> probably #haskell-blah :)
19:42:46 <shapr> haha
19:42:48 <SamB> but then, I guess if we did, we'd still be making somethign called Haskell
19:42:51 <SamB> ray: lol
19:42:57 <mike-burns> Haha, finally #haskell-blah would get some use!
19:43:03 <monochrom> hahaha
19:43:41 <shapr> Well, 86 people in #haskell-blah :-)
19:44:50 <liyang> shapr: you can do zipN with e.g. let (<@>) = zipWith ($) in (,,) `map` [1,2,3] <@> [2,3,4] <@> [4,5,6] -- the problem is that the Applicative you got from the [] monad is not the one you want, unfortunately. A more realistic use case for quasiquoting / TH is e.g. EDSLs with special syntax requirements.
19:45:20 <shapr> Good point.
19:45:23 <Saizan> soupdragon: it's a matter of being able to convey what you're trying to say effectively, if you use harsh or very strong terms you're very likely to be misunderstood
19:45:26 <shapr> I like quasiquoting, kata is using that.
19:45:42 <ray> @quasiquote
19:45:43 <lambdabot> Unknown command, try @list
19:45:53 * liyang curses. Screw you GHC. I'm going to bed.
19:45:55 <shapr> Yeah, emotionally charged terms polarize a discussion, and people start defending themselves, and stop discussing what they've learned.
19:46:21 <SamB> shapr: what if they are charged with the emotion known as "funny"?
19:46:41 <monochrom> They start partying. :)
19:46:48 <liyang> funny is subjective. Though I'm happy as long as it makes me giggle.
19:47:18 <blackdog> SamB: i don't think that's an emotion, or at least not the emotion you're thinking of. if i say "i feel funny..." i don't mean i'm about to bust out some hilarious improv
19:47:34 <shapr> I think humans integrate their tools into their self image. When you attack their tools, they think you attack them.
19:47:49 <SamB> blackdog: well, there is an emotion that is associated with laughing hysterically!
19:47:51 <monochrom> Stupid humans. Exterminate.
19:48:10 <ray> screw you! hammers are the best and screws are just a special case of nails
19:48:29 <SamB> shapr: yeah, that's why we want to be drawn tool-in-hand
19:48:31 <monochrom> But shouldn't attack anyway. Criticize, suggest improvements. Don't attack.
19:48:39 <shapr> SamB: Interesting observation.
19:48:40 <SamB> like why lambdabot is drawn with a headset on ;-)
19:48:56 <monochrom> "screw you"? not "nail you"?
19:49:08 <liyang> shapr: TBH, that's mostly a problem with men. Let's not go down the equipment as an extension of one's anatomy discussion.
19:49:08 <mike-burns> I don't know where this conversation went.
19:49:10 <ray> i didn't consider that angle until after pressing enter
19:49:16 <monochrom> "put your mouth where your mouth is!"
19:49:17 * shapr snickers
19:49:20 <Saizan> (monochrom is a dalek?)
19:49:26 <monochrom> (yes)
19:49:44 <SamB> ever tried to see things through the other man's shoes?
19:49:45 <shapr> liyang: Yeah, I haven't had any tool oriented 'arguments' with females.
19:49:58 <shapr> But then, I think the testosterone level in programming tends to filter out females.
19:50:13 <comrade`phil> o.o
19:50:16 <comrade`phil> innuendo
19:50:18 <comrade`phil> I think
19:50:20 <comrade`phil> wait
19:50:22 <shapr> ?
19:50:22 <SamB> shapr: you mean there are too many men already?
19:50:24 <ray> the opposite of innuendo
19:50:32 <comrade`phil> [04:49] <shapr> liyang: Yeah, I haven't had any tool oriented 'arguments' with females.
19:50:35 <SamB> and we stink too much because we need to take more showers?
19:50:42 <shapr> SamB: No, I mean the cultural attitude tends to exclude females for whatever reason.
19:50:50 <ray> i don'
19:50:51 <SamB> shapr: oh, that
19:50:59 <ray> i don't need to take more showers, i need to take less
19:51:02 <Saizan> and then Philippa dropped..
19:51:07 <SamB> I think it's mostly just ... same-old, same-old
19:51:08 <monochrom> indeed
19:51:17 <SamB> Saizan: hmm?
19:51:26 <shapr> Anyway...
19:51:28 <ray> nah, she's been dropping all evening
19:51:29 <liyang> Or perhaps, the lack of women has turned software engineering into one giant homoerotic testosterone-fuelled orgy.
19:51:33 <monochrom> Her computer is smart enough to disconnect on her behalf!
19:51:40 <SamB> you expecting phillipa to say something about sex at this point ?
19:51:51 <Saizan> SamB: Philippa just got disconnected at this point
19:51:56 <mike-burns> [22:51:48] shapr | Anyway...
19:51:59 <Axman6> eh
19:52:00 <ray> some people ignore quit messages, i think
19:52:03 <Axman6> heh*
19:52:07 <Saizan> while you were talking about no women in programming
19:52:17 * liyang goes back to sleep under his bridge.
19:52:19 <SamB> Saizan: pretty sure that was a ghost
19:52:20 <shapr> For contrast, the MAKE community has lots of creative women. I think we're doing something wrong.
19:52:26 <SamB> 'cause Philippa_ had come in a bit before that
19:52:41 <Saizan> it has dramatic effect anyway :)
19:52:42 <SamB> shapr: MAKE?
19:52:49 <SamB> as in maker fair?
19:52:52 <shapr> Yeah, MAKE magazine and all that.
19:53:04 <soupdragon> I thuogth you meant GNU/make
19:53:08 <Nafai> I went to the Maker Faire in Austin a few years ago and that was fun
19:53:11 <SamB> I didn't know there was a magazine
19:53:17 <deech> I've been told by a woman that there are tons of women in the Perl community.
19:53:20 <blackdog> weirdly, there are more women involved in the hardware groups i'm in than the software ones
19:53:34 <mike-burns> I attended some "women in programming talking about women in programming" panel where we basically agreed that we had no idea why more women weren't programming.
19:53:41 <blackdog> deech: and they're still tougher than men who program in other languages.
19:53:48 <shapr> mike-burns: If you find out, let me know.
19:53:50 <liyang> deech: you misheard. She'd told you there were *tens* of women in the Perl community.
19:53:56 <SamB> mike-burns: I think it's because not enough of their friends are into it ;-P
19:54:01 <ray> tens is tons if they're active
19:54:07 <mike-burns> SamB: That's the most popular theory.
19:54:16 <shapr> No network effect?
19:54:16 <Axman6> liyang: heh
19:54:18 <SamB> and/or idols
19:54:35 <SamB> shapr: there *is* a network effect
19:54:40 <SamB> and it's drawing them away!
19:54:44 <shapr> huh
19:54:58 <mike-burns> I taught a summar class for high school students with the idea that we would market it strongly to high school females, getting a 50% ratio. We ended up with 2 females and 28 males instead.
19:55:04 <shapr> I taught some of my girlfriends lambda calculus. They were really good at it, just not very interested.
19:55:04 <monochrom> Ada and Grace didn't invite enough friends to join.
19:55:15 <shapr> mike-burns: Any idea why?
19:55:19 <SamB> so, obviously we must all torture our children by teaching them bussiness as children ;-P
19:55:23 * Axman6 is programming Ada right now >_>
19:55:32 <mike-burns> We read the studies on the topic like crazy and concluded that we had no idea why.
19:55:36 <shapr> haha
19:55:43 <Axman6> or, should be at least. i finished out tute 75 minutes early
19:55:50 <mike-burns> The best we can figure is, maybe, the network effect?
19:56:05 <mike-burns> Wish I knew.
19:56:07 <shapr> Perhaps programming doesn't have any direct benefits?
19:56:20 <SamB> shapr: sure it does!
19:56:27 <SamB> it provides an outlet for unwanted hair and energy
19:56:31 <mike-burns> Lots of freshmen females leave CS for multimedia. Not sure why.
19:56:39 <monochrom> I thought we already torture children by teaching them "words mean nothing, you have to read between the lines, second guess motives"
19:56:48 <shapr> For example, I've met plenty of secretaries who wrote monster vbscripts for useful spreadsheets with no prior experience. They were doing something that had a direct benefit to the people at their job.
19:57:01 <ray> there are plenty of ways we torture children already
19:57:03 <SamB> monochrom: well, I figure if we torture them with bussiness, they'll drop out and do engineering!
19:57:09 <shapr> mike-burns: That's curious.
19:57:13 <mike-burns> shapr: Yes, totally. And accountants who write awesome Excel macros.
19:57:16 <shapr> mike-burns: We should discuss this more next time we meet.
19:57:20 <mike-burns> shapr: Agreed.
19:57:25 <shapr> What are you doing this weekend?
19:57:41 <shapr> You like like, five blocks from me?
19:57:46 <shapr> er, "live like"
19:57:52 <mike-burns> I'm doing nothing, according to my calendar.
19:57:54 <SamB> likelike!
19:57:56 <SamB> ohno!
19:57:56 <mike-burns> I'm downtown, near Park St.
19:57:58 <deech> mike-burns, maybe cause most CS and EE depts treat their undergraduates like it's boot camp. I don't think women respond well to that treatment.
19:58:03 <shapr> Oh right, across from the office.
19:58:03 * SamB hides his shield
19:58:28 <SamB> deech: boot camp is THIS boring?
19:58:46 <mike-burns> deech: Possibly. I know quite a few who stuck to it just to prove that they could make it through.
19:58:57 <Axman6> deech: not mine
19:59:40 <shapr> I think if programming were as obviously useful as excel scripting, many women would do it.
20:00:02 <mike-burns> Not just women; more people would do it.
20:00:13 <shapr> Perhaps programming is still something you have to do for itself, perhaps it hasn't reached the point of being a tool that's easily accessible?
20:00:15 <Saizan> i had a fun first year at CS, lots of PL theory and logic most of us weren't prepared for
20:00:20 <deech> mike-burns, yes but repelling women to hold onto the rebellious ones is not a good way of changing the stereotype
20:00:27 <djahandarie> Computer science sucks
20:00:45 <mike-burns> On no you didn'!
20:00:49 <shapr> haha
20:00:52 <SamB> shapr: but why don't women want it for itself?
20:01:06 <Nafai> It was interesting, we had a ACM Women's group at our CS department because we had a couple of women professors.  A woman friend of mine that attended said that many of the students (especially those from outside of the US) that attended said they were in CS merely because their fathers wanted them to
20:01:20 <shapr> huh
20:01:34 <SamB> Nafai: these were males?
20:01:51 <shapr> SamB: I think most women have a more direct view of life than I do. They look for how something can benefit their immediate goals in life. I just do stuff that's fun.
20:02:06 <mike-burns> I know some current CS undergrads, male and female. Many of them decided to do it because they use their computer all day to talk with friends on AIM so they might as well learn how it works.
20:02:06 <monochrom> Programming is a very formidable skill. Still, you choose between useful and detached when you present it.
20:02:10 <djahandarie> I think a big problem is that no one has any idea what the hell "Computer Science" is...
20:02:15 <Nafai> SamB: No, women, it was the ACM Women's group
20:02:26 <araujo> shapr, haha, same here
20:02:38 <blackdog> shapr: that's an interesting point, actually. I tried to teach an old girlfriend programming for a CS class and she was deeply, deeply uninterested. Now, she's writing VB on big, customer-sensitive access apps, and she's really good at it, just because it matters...
20:02:40 <djahandarie> It's about as vague as "magic"
20:02:47 <djahandarie> Just wave your wand and shit happens
20:02:47 <djahandarie> :P
20:02:48 <SamB> Nafai: oh, got confused
20:03:05 <SamB> Nafai: thought it was a female teacher talking about students ...
20:03:21 <soupdragon> djahandarie: yeah more people should realize that and see that it shouldn't and needn't be that way
20:03:27 <shapr> djahandarie: Nah, CS is like physics, but for data.
20:03:32 <mike-burns> But then there's the whole crowd of "professional programmers"---those who "hate CS and academia". These people are also mostly male.
20:03:43 <shapr> Yeah, those people make my life difficult.
20:03:56 <ray> i hate cs and academia for not being ivory-tower enough
20:03:59 * araujo remembers the SICP lecturers about CS being neither about Computers nor a Science ......
20:04:06 <djahandarie> mike-burns, I agree. I don't think "application" vs. "academia" corrlates with gender
20:04:08 <mike-burns> Heh. It just takes a special, mind-bending skill to talk with such people.
20:04:09 <djahandarie> shapr, lol
20:04:12 <shapr> araujo: Good point
20:04:33 <blackdog> was it dijkstra who pointed out that we don't call astronomy "telescope science"?
20:04:39 <shapr> yup
20:04:44 <djahandarie> shapr, either way, CS encompasses a bunch of stuff, but frankly no one really understands what it is
20:04:48 <monochrom> knife science!
20:04:58 <monochrom> @slap monochrom
20:04:58 * lambdabot smashes a lamp on monochrom's head
20:05:07 <monochrom> @slap monochrom
20:05:07 * lambdabot hits monochrom with a hammer, so they breaks into a thousand pieces
20:05:20 <djahandarie> Even the intro "computer science" courses in high school usually don't clear things up. They help a little because it introduces the concept of "tell the computer how to do this in a really stupid way and it will understand".
20:05:33 <monochrom> Oh well. I thought I could get her to chop me, demonstrating her knife-science skills.
20:05:34 <djahandarie> But it really doesn't show the roots of any theory or anything.
20:05:53 <monochrom> I guess it's hammer science day for her today.
20:06:01 <djahandarie> So no one really knows what they're going in the major for unless someone else tells them to, or they have gotten experience elsewhere.
20:06:02 <ray> hammers win again
20:06:02 <mike-burns> Yeah; in the USA "CS1" is Pascal and "CS2" is Java.
20:06:32 <mike-burns> The TeachScheme! agenda is trying to change CS1 to Scheme.
20:06:35 <djahandarie> Then again I shouldn't be arguing about computer science in colleges... haven't even gotten there yet. :P
20:06:35 <shapr> Occasionally someone asks me to explain computers to them. Even less frequently they really want to know. Once or twice someone sat there long enough for me to explain things down to the boolean logic and the electron.
20:06:45 <nkpart>  /part
20:06:49 <shapr> bye nkpart!
20:07:02 <deech> When I was starting out the problem was that you had to follow so many levels of indirection to get something to happen, I didn't really feel confident/in control.
20:07:04 <mike-burns> shapr: The last person to sit down long enough for an explaination was a female.
20:07:09 <ray> sometimes i explain the von neumann bottleneck to people
20:07:09 <shapr> yes!
20:07:19 <sw17ch> shapr: i was explaining it to a friend who studies philosophy--i got really sick of hearing "but how" or "but why"
20:07:30 <sw17ch> but she has a good understanding of it now
20:07:40 <Saizan> ray: bottleneck?
20:07:43 <sw17ch> and was apt enough to understand that "the information needs to come from somewhere"
20:07:50 <shapr> deech: I don't think that's gotten any easier.
20:08:01 <monochrom> You can always reply "historical development". It's also true.
20:08:02 <ray> saizan: look up the von neumann bottleneck
20:08:14 <ray> basically, memory is slow
20:08:26 <ray> i'm sure you know it already
20:08:50 <araujo> shapr, do you actually get to the part of explaining boolean logic and electrons? ... that's further I have ever gone explaining this to someone :P
20:08:57 <deech> shapr, and looking back I don't know how my profs could have done things differently.
20:09:06 <shapr> Sure, I bounce around like a rubber ball so they don't get distracted.
20:09:13 <djahandarie> TBH, I think any computer science program should start directly with FSMs etc. Explain from the ground up
20:09:19 <deech> Having TA's that could speak English would have been nice though.
20:09:20 <monochrom> . o O ( There are still a few levels between boolean logic and electrons... )
20:09:25 <djahandarie> deech, yes. lol
20:09:25 <Saizan> ray: ah, yeah, just not the name
20:09:30 <BMeph> What? No NAND to Tetris examples? ;)
20:09:39 <shapr> BMeph: Yeah, that's totally my style.
20:09:53 <shapr> "You can do all of this computer stuff with just the NOT operation in boolean logic."
20:09:53 <mike-burns> djahandarie: That's totally my style.
20:10:10 <djahandarie> I think another problem is all this crazy symbol crap that litters all the theory
20:10:20 <ray> saizan: usually it makes sense in context, like when i'm explaining that more gigglehertz doesn't necessarily mean a faster computer
20:10:20 <mike-burns> ... and Haskell.
20:10:24 <djahandarie> But that's a problem with Math too, so, I guess it's not *really* a problem. :P
20:10:28 <araujo> djahandarie, what symbols?, hey, I like symbols :P
20:10:40 <djahandarie> araujo, I like them too once I understand what the hell they do haha
20:10:44 <djahandarie> Makes me feel important :P
20:10:45 <ray> obtuse notation just makes it hard to skip ahead
20:10:51 <araujo> hah, they are fun
20:10:54 <djahandarie> ray, I love skipping ahead!
20:11:06 <djahandarie> If it wasn't for that I wouldn't even get involved in computer science. :P
20:11:19 <djahandarie> But that doesn't mean the actually teaching of it should be such a mess
20:11:20 <ray> you'll land in the obtuse notation deep end and have to find out what it means
20:11:22 <araujo> but right, one thing is symbols, and the other is obfuscated symbols notation .....
20:11:28 <deech> I don't have a problem with symbols so long as there are copious examples.
20:11:30 <monochrom> <*> is the best symbol ever!
20:11:43 <BMeph> As a side project, I'm thinking on how to do a similar path, but using Fredkin gates. Thus, my "obsession" with swap. ;)
20:11:51 <ray> as i think monochrom is implying, reading haskell can be a bit like that
20:12:10 <monochrom> No, I'm implying we should get back to topic.
20:12:10 <djahandarie> I remember a few months ago I had no idea what the hell anything was in terms of math or any computer theory etc
20:12:13 <bjorkintosh> is anyone else reading 'the haskell school of expression?' the examples don't seem to be working at all.
20:12:21 <djahandarie> And when I tried to learn stuff, all I hit was a wall of shite I didn't know
20:12:27 <ray> bjorkintosh: do you have the soe graphics library installed?
20:12:30 <djahandarie> There was literally no structure
20:12:41 <bjorkintosh> i think i do. graphics.soe
20:12:52 <monochrom> But since you raised it, I actually think it's fair game for a new language to use new symbols! I mean, by definition of new language, what do you expect?
20:12:55 <mike-burns> bjorkintosh: What errors are you getting?
20:12:58 <bjorkintosh> it's no longer SOEGraphics...
20:13:15 * araujo been writing a new stack language recently 
20:13:18 <araujo> with plenty of symbols :)
20:13:23 <bjorkintosh> mike-burns, the same ones from this morning: do needs an expression at the end. or something.
20:13:25 <djahandarie> monochrom, well, I'm not denying if it's useful or not, I'm just saying that's a major problem with learning anything new.
20:13:28 <Nafai> araujo: Cool, in Haskell?
20:13:34 <araujo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7563#a7563
20:13:37 <djahandarie> It's the difference between learning French from English vs learning Arabic from English.
20:13:39 <araujo> some examples lines
20:13:48 <araujo> Nafai, no, not really, objc
20:13:48 <bjorkintosh> araujo, why, because it's a rather new area?
20:13:51 <mike-burns> bjorkintosh: I haven't actually read the book. Can you paste the code you're running?
20:14:06 <araujo> bjorkintosh, just trying some ideas I have had around for a while floating in my mind
20:14:08 <ray> monochrom: yes, it just looks obtuse to the uninitiated, like a paper on stable homotopy or something
20:14:16 <djahandarie> monochrom, the symbols should be defined well, and without introducing more symbols in the process. :P
20:14:17 <monochrom> I.e., http://www.vex.net/~trebla/weblog/intuitive.html , i.e., if you want it truly new, why would you also want it intuitive?  Oxymoron.
20:15:00 <blackdog> monochrom: you can make something new that uses familiar metaphors.
20:15:03 <Nafai> araujo: So, like Factor and Forth, the things in [ ] are quotations?
20:15:10 <monochrom> Yes of course, good pedagogy is assumed.
20:15:12 <ray> monochrom: so it scares people off even though it's not scary, just new
20:15:16 <araujo> Nafai, no, they are more like Smalltalk blocks
20:15:18 <ray> except new is scary, but i mean besides that
20:15:33 <djahandarie> monochrom, I understand the need for symbols, but I found they are one of the major blocks in learning anything. And they are rarely ever explained well in math/computer science.
20:15:33 * shapr builds more of hackage
20:15:35 <araujo> Nafai, well, similar to factor and forth, but think about them more like closures
20:15:42 <djahandarie> At least not without a really good course in it.
20:15:52 <djahandarie> Which I haven't had. :P
20:16:06 <ray> at least obtuse haskell operators can be :td
20:16:22 <Nafai> araujo: Cool
20:16:27 <bjorkintosh> mike-burns, http://pastebin.com/d5bb8b157
20:16:35 <araujo> Nafai, i still don't upload anything, soon I will :)
20:16:53 <djahandarie> I feel like it should have just been a lot easier. Learning a bunch of different programming languages was easy, yet learning the symbols involved in theory was hard and tedious. Yet, I enjoy computer science much more than any programming.
20:16:54 <Nafai> araujo: Why obj-c?
20:17:13 <Saizan> bjorkintosh: you need to align the lines after "w <- .." with the w
20:17:14 <araujo> Nafai, the language has OOP properties , I am using the dynamic dispatch of objc
20:17:14 <BMeph> I prefer math/CS symbols to linguistic ones. At least, the former expect unfamiliarity, and stop to explain things.
20:17:16 <djahandarie> That made me draw the conclusion that there is something wrong with the process... but oh well, I could be long.
20:17:18 <araujo> that's the main reason
20:17:24 <djahandarie> wrong*
20:17:38 <djahandarie> I should probably stop ranting off-topic anyways. :P
20:17:47 <ray> bmeph: linguistics is totally a clique
20:18:24 <BMeph> ray: Amen, Brother,preach it! ;p
20:18:53 <bjorkintosh> Saizan, i've moved them around as many ways as i could think of to no avail.
20:18:55 <mike-burns> bjorkintosh: Did Saizan's solution fix it?
20:18:58 <mike-burns> Ah.
20:19:13 <monochrom> bjorkintosh: eliminate tabs, use pure spaces.
20:19:34 <monochrom> (I haven't read your paste. I'm just guessing. It's a common problem.)
20:19:46 <bjorkintosh> monochrom, i have :se expandtab in my .vimrc
20:19:46 <Saizan> yeah, with only spaces this should work http://pastebin.com/m2c0e3fc6
20:19:48 <mike-burns> Looks like spaces in the paste.
20:19:49 <bjorkintosh> that didn't do it either.
20:20:05 <Saizan> or at least not give that error
20:20:14 <SamB> try codepad.org ;-P
20:20:15 <mike-burns> bjorkintosh: Which line number is it complaining about?
20:20:33 <Saizan> we can work on the other errors it'll give, if any :)
20:20:59 <bjorkintosh> sierpinski.hs:26:5:    The last statement in a 'do' construct must be an expression
20:21:05 <bjorkintosh> i'm using ghc.
20:21:18 <Saizan> have you tried with my paste?
20:22:19 <bjorkintosh> which one is your paste, Saizan?
20:22:23 <liyang> Saizan: stay off the sauce man, it's bad for you.
20:22:29 <Saizan> http://pastebin.com/m2c0e3fc6
20:22:37 <Saizan> bjorkintosh: that ^^
20:23:26 <sw17ch> sometimes pointfree notation is really nice
20:23:35 <mike-burns> Yes.
20:25:00 <roconnor> > product [25..20] / product [5..1]
20:25:02 <lambdabot>   1.0
20:25:12 <roconnor> > product [20..25] / product [1..5]
20:25:14 <lambdabot>   1062600.0
20:25:20 <monochrom> oh hahaha
20:25:33 <roconnor> > product [20..25] `div` product [1..5]
20:25:35 <lambdabot>   1062600
20:25:42 <bjorkintosh> good god, it hates me.
20:25:50 <bjorkintosh> suddenly getkey is not in scope etc.
20:26:04 <monochrom> sunspot activity
20:26:13 <bjorkintosh> forget it.
20:26:18 <bjorkintosh> i'll come back to the silly book later.
20:26:42 <monochrom> is it getkey or getKey?
20:27:04 <Saizan> in http://www.haskell.org/gtk2hs/docs/current/Graphics-SOE-Gtk.html it's getKey
20:27:13 <Saizan> identifiers are case sensitive
20:27:22 <monochrom> Haha, computers hate you!
20:27:35 <bjorkintosh> getKey
20:27:36 <Saizan> and generally follow the camel-case convention
20:28:09 <Saizan> you had getkey in your paste, so easy to fix :)
20:28:10 <pikhq> The camelCase convention, you mean.
20:28:20 <monochrom> camel'case
20:28:30 <Saizan> camel_case
20:28:32 <monochrom> (That's Oleg case.)
20:28:42 <mike-burns> Ah goodnight.
20:28:53 <mike-burns> Good luck bjorkintosh. Don't quit so easily.
20:29:06 <mike-burns> It'll get harder. :)
20:29:12 <monochrom> hahahaha
20:29:39 <monochrom> "Don't quite so easily! You haven't even seen the Functor Monster!"
20:29:43 <gwern> @quote explod
20:29:44 <lambdabot> ghc says: My brain just exploded.
20:29:46 <vav> bjorkintosh: in this zip file most of the code is in lhs files under SOE/src -- can save you some typing and agony http://www.cs.yale.edu/homes/hl293/download/SOE-20071003.zip
20:29:50 <gwern> @quote explod
20:29:50 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
20:29:50 <lambdabot> everyone inside.
20:30:07 <bjorkintosh> thanks vav
20:30:51 <monochrom> That joke backfires, as the automobile industry collapses now.
20:31:14 <bjorkintosh> hahah
20:31:16 <ray> the industry does, but the cars don't explode yet
20:31:23 <bjorkintosh> they used to...
20:31:37 <SubStack> the computer industry collapses now and then too
20:31:50 <ray> i know, i'm ralph nader
20:31:56 <ray> i mean, i voted for ralph nader
20:32:22 <SubStack> but when you slice apart one monster two smaller ones just take its place
20:32:46 <ray> unless you got the white sword from the waterfall cave
20:33:25 <bjorkintosh> *sigh*
20:33:35 <bjorkintosh> i'll use the haskell road to logic as my intro.
20:33:54 <bjorkintosh> the damned hudak book is being a royal PITA
20:34:00 <shapr> Have you tried Real World Haskell?
20:34:02 <ray> there's this tutorial with bad grammar that  everyone loves tehse days
20:34:05 <ray> and real world haskell too
20:34:29 <monochrom> Is that "learn yourself a haskell"?
20:34:39 <SamB> ray: I don't think it counts as bad grammar when you do it on purpose for humour
20:34:42 <SubStack> needs more illustrations
20:34:54 <ray> something about learning oneself an haskell for excellency in all endeavours
20:35:03 <SubStack> both big and small
20:35:27 <bjorkintosh> shapr, i have it, but i haven't used it yet... i wasn't sure i'd get the essence of haskell from it's real world applications.
20:35:32 <Axman6> oh god, SQL is awful
20:35:42 <SubStack> Axman6: it's true
20:35:42 <shapr> bjorkintosh: I think it'll do fine.
20:35:59 <shapr> bjorkintosh: I started with Hudak and Thompson's books, but I really wish I'd had RWH instead.
20:36:04 <SubStack> it doesn't even have any monoids
20:36:12 <Makoryu> My recommendation: Learn Scheme however you want. Then follow any short-ish Haskell tutorial and just retype all the code samples by hand, without worrying about what they mean. Then read RWH and find yourself with a great understanding of Haskell.
20:36:30 <ray> or skip the first two steps
20:37:03 <bjorkintosh> scheme huh?
20:37:03 <monochrom> Or just have a usb port somewhere on your head and I'll plug in and copy.
20:37:07 <Axman6> SELECT prodID, description, SUM(quantity) as summed FROM orderItem NATURAL JOIN product WHERE quantity = (SELECT MAX(totals) FROM (SELECT SUM(quantity) as totals FROM orderItem NATURAL JOIN product GROUP BY prodId, description) as temp) GROUP BY prodID, description ORDER BY summed DESC; >>>>>>_<<<<<<
20:37:10 <Makoryu> ray: People who go straight to RWH often complain that it seems geared towards people who have already tried to learn with other tutorials.
20:37:18 <SubStack> or just meditate long enough on the matter until you invent haskell yourself independently
20:37:19 <shapr> Scheme is cool. Haskell is cool. You should make sure to learn both of them.
20:37:28 <bjorkintosh> how's it possible that a perfectly good language needs an OTHER language for an intro?
20:37:37 <shapr> bjorkintosh: Well, not everyone thinks that.
20:37:39 <ray> yeah, scheme is pretty cool
20:37:40 <monochrom> bootstrapping!
20:37:51 <shapr> But both languages do have good points that make them worth learning.
20:37:56 <shapr> So do some other languages too :-)
20:38:08 <MononcQc> Erlang <3
20:38:08 <Makoryu> bjorkintosh: Not so much as an intro to Haskell but an intro to functional programming, because if you don't get FP then you'll have a tougher time trying to wrap your head around FP and Haskell simultaneously.
20:38:24 <shapr> Bah, I disagree!
20:38:29 <ray> i don't even find haskell that functional
20:38:30 <shapr> I went from Python to Haskell.
20:38:34 <shapr> I loved it!
20:38:40 <bjorkintosh> Makoryu, but isn't the functional notation already introduced via math?
20:38:41 <monochrom> I booted Haskell from two other stages.
20:38:44 <Makoryu> ray: Sheesh, what *is* functional if Haskell isn't....?
20:38:44 <ray> i mean, it is, but that's like an afterthought because you're too busy doing the real cool things
20:38:44 <bjorkintosh> or isn't that the point of it anymore?
20:38:56 <SubStack> python seems so empty after learning haskell
20:39:00 <Makoryu> bjorkintosh: FP isn't about notation. It's about semantics.
20:39:01 <ray> yeah functions are first class HOW BORING LET'S MAKE SOME TYPES
20:39:06 <roconnor> > product [21..25] `div` product [1..5]
20:39:07 <Makoryu> SubStack: Most imperative languages do....
20:39:08 <lambdabot>   53130
20:39:21 <shapr> Makoryu: Hey, were you at the most recent Boston Area Haskell User's Group?
20:39:22 <SamB> ray: apparantly that's not what FP is about
20:39:22 <Makoryu> monochrom: Such as?
20:39:29 <Makoryu> shapr: Nope. When was it?
20:39:30 <SamB> ray: at least, not pure FP!
20:39:30 <monochrom> Lisp then SML.
20:39:34 <SubStack> perl still amuses me, especially perl6
20:39:44 <shapr> Makoryu: Well, come to the next one! It's in .. a week or two, I forget exactly.
20:39:48 <shapr> But I'm giving a talk on emacs' haskell-mode
20:39:49 <ray> samb: well, everything else follows from cackling and making types in your mad haskell lab
20:39:57 <ray> some of them are function types
20:40:10 <Makoryu> shapr: Right, I asked before but nobody knew when it would be, so I went to do something else
20:40:28 <shapr> Are you on the google group?
20:40:37 <Makoryu> shapr: Nope
20:40:43 <Makoryu> I just come here occasionally.
20:40:50 <ray> how to learn haskell: 1) get a lab coat and goggles 2) get haskell platform 3) keep a reference handy and do mad haskell
20:40:56 <shapr> http://groups.google.com/group/bostonhaskell
20:41:07 <SamB> ray: step 1 is actually for chemistry
20:41:09 <deech> shapr, has haskell-mode still active? The last release was a while ago. Also aside from the wiki page are there any tutorials for it?
20:41:16 <ray> samb: it's for any mad science
20:41:26 <shapr> deech: I don't know, but if I end up with decent slides I'll post 'em
20:41:27 <raceRider> Is there a function to replace the nth element of a list?
20:41:32 <ray> even mad sociology requires a lab coat and goggles
20:41:37 <shapr> I've done some elisp hacking, so I know my way around haskell-mode.
20:41:45 <monochrom> raceRider: No, but you can write it yourself.
20:41:48 <Makoryu> raceRider: You could write one very easily.
20:41:57 <blackdog> raceRider: so long as you don't expect the underlying list to change
20:42:12 <shapr> My first thought was (//) but that's not it.
20:42:13 <monochrom> (Are we playing "assume you know what you're doing" now?)
20:42:17 <raceRider> I want to build a new list from a CSV line
20:42:43 <dons> raceRider: maybe just use the csv package?
20:42:48 <shapr> hi dons!
20:42:52 <Makoryu> Here, I'll do it right now: \n xs newx -> take (n - 1) xs ++ [newx] ++ drop (n + 1) xs
20:42:54 <dons> shapr!!
20:42:55 <Makoryu> Will that do?
20:42:57 <shapr> Wassup?
20:42:58 <Makoryu> @raceRider
20:42:59 <lambdabot> Unknown command, try @list
20:42:59 <pikhq> raceRider: Or perhaps use Parsec to write a simple parser?
20:43:14 <dons> mmm. trying to get new packages into the haskell platform. planning icfp trip
20:43:21 <raceRider> dons: too complicated to just replace an element of list from hex to dec value and save the line back
20:43:33 <dons> raceRider: 'relace' ?
20:43:39 <dons> replace? you want to mutate the list?
20:43:52 <shapr> I bet relace would unzip and then zip.
20:43:53 <raceRider> dons: yes
20:44:03 <monochrom> hahaha shapr
20:44:19 <dons> how about : use readCSV from the csv package. filter each list (from each line) to map hex to dec. then print it back
20:44:35 <liyang> raceRider: what I said earlier -- a list is most certainly the wrong data type for what you're trying to do...
20:44:37 <dons> there's no string mutation in haskell. but you can use map and filter
20:44:51 <ray> shapr: boston haskell user group sounds cool, but i don't see anything there about a meeting in august
20:45:02 <Axman6> we really do need a nice string manipulation package don't we
20:45:15 <dons> http://hackage.haskell.org/package/csv
20:45:22 <monochrom> (Never play "assume you know what you're doing" again. Perhaps I mean "assume you have a reason to do it this way".)
20:45:50 <dons> parseCSVFromFile :: FilePath -> IO (Either ParseError CSV)
20:45:52 <shapr> ray: There really is one.. Ravi told me about it.
20:46:00 <dons> printCSV :: CSV -> String
20:46:02 <ray> i believe you, someone else mentioned it to me too
20:46:03 <shapr> I'm giving a talk!
20:46:08 <ray> i just don't see anything there
20:46:13 <shapr> ray: Have I met you before?
20:46:15 <ray> no
20:46:20 <shapr> Ok, just curious.
20:46:24 <shapr> I figured I'd remember you.
20:46:38 <raceRider> dons: thx
20:46:38 <ray> probably, i always wear a tie
20:46:46 <bjorkintosh> why ray?
20:46:50 <ray> because i like them
20:46:51 <bjorkintosh> a bow tie?
20:46:57 <ray> no, i'm not cool enough for a bow tie
20:47:03 <bjorkintosh> or a cow boy's bow tie?
20:47:04 <monochrom> because of uniqueness
20:47:13 <bjorkintosh> if you can shovel bull shit, you can wear a cow boy's bow tie.
20:47:17 <monochrom> ray is a uniqueness type  <duck>
20:47:29 <Axman6> i will wear a bow tie one day
20:47:33 <liyang> uniqueness tie-pes?
20:47:42 <ray> oops, this isn't #clean
20:47:53 <dons> tiepes eh?
20:47:57 <dons> ties with System F on them?
20:48:06 <dons> works for me.
20:48:51 <dons> http://www.galois.com/~dons/images/fc-tr.png print on silk. done.
20:49:18 <ray> i'd wear it
20:49:27 <shapr> Me too
20:49:36 <shapr> But how will you fit it onto a tie?
20:49:56 <monochrom> microfiche
20:49:59 <liyang> design a DSL for weaving your own tie fabrics from scratch.
20:50:02 <dons> mmm maybe dual tie / underpants set
20:50:03 <Axman6> dons: what's that (a proof of)?
20:50:15 <liyang> programming comes full-circle.
20:50:19 <ray> that is a type system
20:50:31 <Saizan> it's the type system of GHC's core language
20:50:31 <dons> Axman6: GHC's type system (with type families)
20:50:31 <monochrom> Woah?! Tie says "to see the rest, see underpant"??!!!
20:50:37 <ray> lol
20:50:42 <Axman6> how nice
20:50:42 <dons> monochrom: makes sense
20:50:48 <ray> arguably, that's what ties implicitly say anyway
20:50:59 <monochrom> Is that a very obvious way to get a date?!
20:51:07 <Axman6> monochrom: can you think of a better way to get laid by a haskell laydeh?
20:51:18 <monochrom> "Hi! Look at my tie! Do you want to see the rest?" ??!!!
20:51:25 <Axman6> exactly
20:51:29 <monochrom> You are perverse.
20:51:36 <dons> there's a full proof. in my pants.
20:51:46 <dons> dear oh dear
20:51:50 <SamB_XP> dons: what are your pants doing in the pudding?!??!?!
20:51:56 <Axman6> "oh, i think some of your proof's missing" "yeah, i had to put it on my penis as a tatoo" "oh... well... i need to know if it's proven!"
20:51:57 * shapr laughs
20:52:03 <dons> i don't think formal methods works like this
20:52:16 <shapr> Man, I gotta sleep... this is getting too silly for even ME!
20:52:19 <dons> heheh
20:52:23 <Axman6> we're turning them into informal methods of getting laid
20:53:03 <Axman6> "formal methods of software construction: getting CS students laid since 2009" they'll all say
20:54:31 <liyang> well if anyone asks me what I do I tell them I'm a mathematician. Much sexier than a computer scientist.
20:54:53 <dons> proof engineer, liyang
20:55:04 <ray> "i solve problems"
20:55:13 <Axman6> argh, just decided to look into the pthreads manpage, and i'm not sure if i'm more worried that you need to use function pointers, or that i can understand that the arguments are function pointers >_<
20:55:19 <roconnor> ray: :D
20:55:21 <liyang> dons: ewww... you said the e word.
20:55:21 <SamB_XP> ray: ah. an engineer!
20:55:33 <SamB_XP> a *real* one
20:55:51 <liyang> that's downright dirty talk.
20:56:16 <liyang> certainly not something I'd start a conversation with.
20:56:28 <monochrom> "hai I'm an indentation engineer"
20:56:43 <SamB_XP> monochrom: you program in whitespace?
20:56:50 <SamB_XP> just don't backup your code on paper!
20:56:55 <monochrom> I fix other people's do-notation.
20:57:21 <Axman6> dons: http://www.galois.com/~dons/images/Portland.svg :o
20:57:31 <Axman6> seems rather massive...
20:57:49 <ray> zomg how many gigglebites
20:57:55 <liyang> monochrom: there's a Soviet Russia joke in there somewhere
20:57:58 <monochrom> everyone is downloading it now!
20:58:06 <dons> oh boy
20:58:12 <dons> svg ftw
21:00:02 <Axman6> 13MB
21:00:24 <Axman6> or 14 according to wget and apacge
21:00:25 <dons> pdx bike map in browser "friendly" svg
21:00:26 <Axman6> che*
21:00:57 * Axman6 must be off
21:00:58 <Axman6> later all
21:01:09 <monochrom> good time to disappear.
21:02:57 <Makoryu> dons: There's a garden path sentence if I have really been far even as decided to use even go want to do look more like
21:04:16 * hydo tries yi out... Maybe yi + hlint will be the magic bullet to pry me from emacs + flymake...
21:05:25 <SamB_XP> Makoryu: are you a MegaHAL?
21:05:49 <SamB_XP> or maybe just a kiloHAL?
21:06:04 <Makoryu> SamB_XP: Nah, just a normal human secretly addicted to trolling
21:06:39 * liyang resists the temptation to descend into 'your mon' jokes.
21:06:47 <liyang> *mom
21:07:01 <deech> hydo, what is your workflow using flymake?
21:07:07 <hydo> ya mon, dontcha bee makin no jokes about me
21:07:09 <soupdragon> you're only second mon!
21:07:16 <soupdragon> I am fifth mon
21:07:27 * sw17ch stops working on EnumMap for the night and goes to bed
21:07:28 <sw17ch> gnight all
21:07:55 <tommd> later
21:07:56 <hydo> deech: write a function, wait 1/2 a second... if it turns red, that means I messed up somewhere. eheh
21:08:16 <liyang> is sw1 7ch a UK postcode?
21:09:12 <hydo> deech: the problem is that if I am working on a project of any real size (ie. more than one source file) flymake doesn't know how to handle it and all of my attempts to coerce it into loading it's dependencies from ./src have failed.
21:10:23 <deech> hmmm, that's what was keeping me from installing it.
21:11:10 <kyagrd> Is there a script to run ghci with .cabal project file settings?
21:11:27 <hydo> Gonna find and watch that video on yi that was all fancy crazy.  I'll see if that will get me jazzed up to learn it.
21:12:44 <Saizan> kyagrd: no, there's a ticket on the cabal trac with a tentative patch that needs some love though
21:15:23 <deech>  hydo, there's a vid on Yi? I'd like to watch it.
21:15:35 <hydo> deech: http://video.google.com/videoplay?docid=4183423992181607417
21:16:25 <kyagrd> Oh, the haskell symposium one.
21:16:49 <hydo> damn... apparently preMakefile is deprecated in the darcs version of cabal?  Or maybe I need to upgrade to 6.10.4
21:16:52 <deech> aargh, I'm blind and about to have an epileptic fit
21:18:19 <kyagrd> (long long ago in Greek, symposium originally meant a drinking party ... says wikipedia)
21:23:58 <luite> suppose I have an x, which is either an instance of Show, or IO a, but I don't know which one. in the first case I want to do 'print x', in the second case 'id'. Is it possible to do this, with a type class or something else?
21:24:35 <luite> oh sorry, the second case can be IO ()
21:28:39 <shachaf> luite: Well, you can certainly use a type class for it.
21:28:41 <sjanssen> luite: it can be done with typeclasses, with several caveats
21:29:07 <sjanssen> luite: but this sort of ad-hoc overloading is generally best avoided
21:29:08 <luite> I already tried something, but that required UndecideableInstances
21:29:40 <sjanssen> luite: yes, you'll need undecidable and overlapping classes
21:30:29 <shachaf> luite: How are you planning to use this?
21:30:33 <luite> I'd rather avoid it, but this is for some automatically generated haskell code, for which I don't know the type in advance
21:31:59 <Saizan> at all?
21:32:15 <Saizan> can you also generate an instance for your type in the same code?
21:33:25 <Draconx> luite, you might be able to use existentials, e.g. data Thing = forall a . Show a => ShowThing a | IOThing (IO ()).
21:33:45 <Saizan> that too
21:34:18 <hydo> What's the best way to upgrade minor ghc releases on osx?  I'm assuming it's probably best to use the Uninstaller in the tools directory and then install the new .pkg?  Deleting, of course, ~/.cabal and ~/.ghc
21:34:48 <Saizan> hydo: you don't _need_ to delete those
21:35:22 <Saizan> hydo: you might save some space by deleting the installed packages under ~/.cabal/lib/ though
21:35:33 <hydo> Saizan: Oh, I thought I remembered reading about how all of the cabal packages needed to be rebuilt on an upgraded installation...
21:35:43 <hydo> ah, ok, that makes sense.
21:36:00 <luite> Saizan: it's something that evaluates haskell functions, but also IO (think lambdabot but a lot unsafer ;) ), the 'main' function can either be pure or IO
21:36:14 <sjanssen> hydo: they do need to be rebuilt, but GHC knows which libraries are incompatible and won't use them
21:36:41 <hydo> sjanssen: oh, awesome.  Ok, thanks!
21:36:48 <srush> does haskell have something similar to python StringIO
21:37:09 <srush> an in-memory object with a file buffer interface
21:37:12 <pikhq> srush: What, exactly, does that do?
21:37:14 <pikhq> Ah.
21:37:17 <sjanssen> srush: no
21:37:22 <pikhq> No, because that would be silly.
21:37:26 <srush> figured
21:37:45 <srush> should I just use bytestring?
21:37:51 <Saizan> luite: well, you could typecheck the code and choose the right path, instead of doing it in the language
21:38:04 <sjanssen> srush: are you reading or writing?
21:38:08 <srush> writing
21:38:10 <Saizan> luite: i.e. read ghci's source :)
21:38:33 <sjanssen> srush: you should not use ByteString directly for writing, check out Data.Binary's Put and Builder
21:38:35 <luite> Saizan: that's true, it's the more correct way, but that's a lot of work, figuring out an unstable API
21:39:06 <luite> and probably have it break the next ghc release
21:39:21 <sjanssen> luite: you could try compiling "main = expression" and "main = print expression", and take whichever succeeds :)
21:41:16 <srush> thanks sjanssen that was exactly what I needed
21:41:29 <srush> didn't think I should look in binary though
21:41:43 <luite> sjanssen: hmm, that might actually work :) (although I have to change a lot of code for this)
21:44:14 <Saizan> ?hoogle runStmt
21:44:15 <lambdabot> No results found
21:44:25 <Saizan> luite: what are you using currently for evaluation?
21:47:09 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/ghc/InteractiveEval.html#v%3ArunStmt <- if you're using the ghc-api at all, ghci is just calling this to handle the whole thing
21:48:00 <Saizan> after setting up a correct environment, but the checks for print/no-print are already inside that function, it seems
21:49:26 <luite> Saizan: I currently only have source code (generated by a php script), which is compiled by ghc
21:50:09 <luite> so no ghci-api yet
21:52:33 <luite> the actual compiling is done by a happstack program, which just executes the ghc process, but that program has no idea where this pure/IO thing is in the code
22:22:32 <kniu> hey guys
22:22:56 <Makoryu> Yo
22:23:30 <kniu> what's the standard library function for when you're looking through a list, getting the first element that matches a condition, and applying a function to that element?
22:23:40 <kniu> @src lookup
22:23:41 <lambdabot> lookup _key []          =  Nothing
22:23:41 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
22:23:41 <lambdabot>                         | otherwise = lookup key xys
22:24:03 <Makoryu> @src filter
22:24:04 <lambdabot> filter _ []     = []
22:24:04 <lambdabot> filter p (x:xs)
22:24:04 <lambdabot>     | p x       = x : filter p xs
22:24:04 <lambdabot>     | otherwise = filter p xs
22:24:10 <mauke> :t (. ((head .) . filter))
22:24:11 <kniu> ah.
22:24:13 <lambdabot> forall c a. (([a] -> a) -> c) -> (a -> Bool) -> c
22:24:17 <mauke> hmm, no
22:24:44 <Saizan_> \f p -> fmap f . find p
22:24:48 <Saizan_> :t \f p -> fmap f . find p
22:24:49 <lambdabot> forall a b. (a -> b) -> (a -> Bool) -> [a] -> Maybe b
22:24:55 <Makoryu> :t find
22:24:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
22:25:20 <Makoryu> @pl \f p -> fmap f . find p
22:25:21 <lambdabot> (. find) . (.) . fmap
22:25:31 <Makoryu> I guess I should have seen that coming.
22:26:23 <aavogt> :t (fmap . fst) =<< (find . snd)
22:26:24 <lambdabot>     Couldn't match expected type `((a -> Bool) -> b, b1)'
22:26:24 <lambdabot>            against inferred type `[a] -> Maybe a'
22:26:24 <lambdabot>     In the second argument of `(=<<)', namely `(find . snd)'
22:28:16 <aavogt> :t \x -> fmap (snd x) . find (fst x)
22:28:17 <lambdabot> forall a b. (a -> Bool, a -> b) -> [a] -> Maybe b
22:29:25 <aavogt> :t (\x f -> fmap (fst f) x) =<< (find . snd)
22:29:26 <lambdabot> forall b a. (Maybe a -> b, a -> Bool) -> [a] -> b
22:29:49 <aavogt> :t flip fmap . fst =<< (find . snd)
22:29:50 <lambdabot>     Couldn't match expected type `a -> b'
22:29:50 <lambdabot>            against inferred type `(a1, b1)'
22:29:50 <lambdabot>     In the second argument of `(.)', namely `snd'
22:30:06 <aavogt> @pl (\x f -> fmap (fst f) x)
22:30:06 <lambdabot> flip (fmap . fst)
22:30:10 <aavogt> ah
22:30:22 <aavogt> :t flip (fmap . fst) =<< (find . snd)
22:30:23 <lambdabot> forall b a. (Maybe a -> b, a -> Bool) -> [a] -> b
22:30:33 <aavogt> :t uncurry $ flip (fmap . fst) =<< (find . snd)
22:30:34 <lambdabot> forall b a. ((Maybe a -> b, a -> Bool), [a]) -> b
22:30:42 <aavogt> :t curry $ flip (fmap . fst) =<< (find . snd)
22:30:43 <lambdabot> forall b a. (Maybe a -> b) -> (a -> Bool) -> [a] -> b
22:31:54 <aavogt> hmm, that's not the right type...
22:33:30 <Saizan_> :t curry $ (fmap . fst) =<< (find . snd)
22:33:31 <lambdabot>     Couldn't match expected type `((a -> Bool) -> b, b1)'
22:33:31 <lambdabot>            against inferred type `[a] -> Maybe a'
22:33:31 <lambdabot>     In the second argument of `(=<<)', namely `(find . snd)'
22:35:11 <Saizan_> ?type (=<< (find . snd))
22:35:12 <lambdabot> forall b a a1. (([a] -> Maybe a) -> (a1, a -> Bool) -> b) -> (a1, a -> Bool) -> b
22:35:22 <aavogt> :t curry $ flip ((fmap.fmap) . fst) =<< (find . snd)
22:35:23 <lambdabot> forall b a. (a -> b) -> (a -> Bool) -> [a] -> Maybe b
22:35:51 <aavogt> :t curry $ flip ((fmap .) . fst) =<< (find . snd)
22:35:52 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (([a1] -> Maybe a1) -> a -> b) -> (a1 -> Bool) -> f a -> f b
22:37:28 <aavogt> :t curry $ flip ((fmap.fmap) . fst) =<< find . snd
22:37:30 <lambdabot> forall b a. (a -> b) -> (a -> Bool) -> [a] -> Maybe b
22:37:58 <aavogt> :t (fmap . fmap) . fst
22:37:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => (a -> b, b1) -> f (f1 a) -> f (f1 b)
22:39:21 <Saizan_> :t curry $ flip (((.).fmap) . fst) =<< (find . snd)
22:39:22 <lambdabot> forall b a. (a -> b) -> (a -> Bool) -> [a] -> Maybe b
22:40:17 <Saizan_> :t curry $ flip (((.fmap).) . fst) =<< (find . snd)
22:40:17 <lambdabot> forall c a b (f :: * -> *) a1. (Functor f) => (([a1] -> Maybe a1) -> (f a -> f b) -> c) -> (a1 -> Bool) -> (a -> b) -> c
22:41:35 <Saizan> @bot
22:41:35 <lunabot>  :)
22:41:35 <lambdabot> :)
22:42:11 <abbe> @fortune
22:42:11 <lambdabot> It is well known that *things* from undesirable universes are always seeking
22:42:12 <lambdabot> an entrance into this one, which is the psychic equivalent of handy for the
22:42:12 <lambdabot> buses and closer to the shops.
22:42:12 <lambdabot> 		-- Terry Pratchett, "The Light Fantastic"
22:46:24 <SamB_XP> @fortune
22:46:25 <lambdabot> What, still alive at twenty-two,
22:46:25 <lambdabot> A clean upstanding chap like you?
22:46:25 <lambdabot> Sure, if your throat 'tis hard to slit,
22:46:25 <lambdabot> Slit your girl's, and swing for it.
22:46:25 <lambdabot> Like enough, you won't be glad,
22:46:27 <lambdabot> [8 @more lines]
22:46:36 <SamB_XP> @more
22:46:36 <lambdabot> When they come to hang you, lad:
22:46:36 <lambdabot> But bacon's not the only thing
22:46:36 <lambdabot> That's cured by hanging from a string.
22:46:36 <lambdabot> So, when the spilt ink of the night
22:46:37 <lambdabot> Spreads o'er the blotting pad of light,
22:46:39 <lambdabot> [3 @more lines]
22:46:42 <SamB_XP> @more
22:46:42 <lambdabot> Lads whose job is still to do
22:46:43 <lambdabot> Shall whet their knives, and think of you.
22:46:45 <lambdabot> 		-- Hugh Kingsmill
22:47:41 <SamB_XP> @fortune
22:47:41 <lambdabot> There is no act of treachery or mean-ness of which a political party
22:47:41 <lambdabot> is not capable; for in politics there is no honour.
22:47:41 <lambdabot> 		-- Benjamin Disraeli, "Vivian Grey"
22:47:55 <SamB_XP> @devils honour
22:47:57 <lambdabot> No match for "honour".
22:47:59 <SamB_XP> @devils honor
22:48:01 <lambdabot> No match for "honor".
22:48:05 <SamB_XP> @devils good
22:48:05 <lambdabot> *** "GOOD" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
22:48:06 <lambdabot> GOOD, adj.  Sensible, madam, to the worth of this present writer.
22:48:06 <lambdabot> Alive, sir, to the advantages of letting him alone.
22:48:06 <lambdabot>  
22:48:27 <SamB_XP> @devils grey
22:48:28 <lambdabot> No match for "grey".
22:48:30 <SamB_XP> @devils black
22:48:31 <lambdabot> No match for "black".
23:02:22 <kniu> @pl \x y -> (Arr (Ign x) y)
23:02:22 <lambdabot> Arr . Ign
23:06:02 <mae> whats up everybody
23:06:57 <BMeph> Come what mae... ;)
23:09:23 <int-e> lookup "up" [("left","window"), ("ahead", "wall"), ("right", "door"), ("behind", "wall"), ("up", "ceiling"), ("down", "floor")]
23:09:50 <ray> >
23:10:28 <Deewiant> Just "ceiling"
23:10:38 <Deewiant> (har, har)
23:10:47 <ray>   thread killed
23:50:45 <Trinithis> Is there a nice way to get sublists of a list in order of smallest to largest without sorting something like filterM (const [True, False]) ?
23:53:18 <Gilly> Trinithis: smaller = shorter?
23:53:30 <Trinithis> shorter
23:53:46 <Trinithis> by length
23:54:02 <Gilly> well, maybe you could start by taking sublists of length 1, then recurse on those to get lists of length 2 and so on
23:54:22 <Gilly> you have to do it breadth first
23:54:51 <Trinithis> ah
23:55:30 <Trinithis> probably use permutations
23:55:41 <Trinithis> on concating subs of len 1
23:57:52 <Gilly> this works: sublists (x:xs) = [[x]] ++ sublists xs ++ map (x:) (sublists xs)
23:58:36 <Gilly> oops no
23:58:37 <Trinithis> blew up on [1..3]
23:58:46 <Gilly> i know :) silly me
