00:00:29 <PetRat> Is it true that by default everything in a module is exported but the data constructors?
00:00:33 <bastl>  a path to source is enough for the module to load. im not sure about dependent modules
00:02:00 <mmorrow> bastl: what i'm unclear on is whether you're intending to use the parser function you've dynamically loaded *in the code that dynamically loaded it* or just in the dynamically loaded code itself
00:02:25 <bastl> i will make a minimal example including the same constructs ...
00:03:46 <bast_away> hmm. what does use mean? i load a function that calls the parsers at runtime. This function is called by the main (compiled)  program.
00:04:50 <bast_away> gtg now, teaching :-/
00:04:54 <SColes> I'm in ghci and I'm trying to use the Char.digitToInt function and I get a module not loaded error.  I'm new at this but I thought prelude included that?
00:07:21 <mmorrow> bast_away: i'm not familiar with hint, but this is how you'd dynamically compile a polymorphic function and use it in the code that compiled it (here using some code that lunabot uses, which is just a very light wrapper over the ghc-api)
00:07:24 <mmorrow> ghci> hval <- compileE env "(\\a -> (a,a)) :: a -> (a,a)"
00:07:24 <mmorrow> ghci> let f = unsafeCoerce hval :: a -> (a,a)
00:07:24 <mmorrow> ghci> f 42
00:07:24 <mmorrow> (42,42)
00:08:11 <mmorrow> so compileE is compileExp (or something like that) from the ghc-api, that has type :: <ghc-api-state> -> String -> IO HValue
00:08:30 <mmorrow> so you need to coerce the HValue into what you know that it is
00:09:17 <mmorrow> if the type that it really is is monomorphic (and Typeable), you can use the dynamicCompileExp (or called something similar to this), which is what lunabot uses for its `eval' e.g.
00:09:19 <mmorrow> , eval "42"
00:09:24 <lunabot>  <<Integer>>
00:09:31 <mmorrow> , eval "(\\a->(a,a))::a->(a,a)"
00:09:34 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
00:09:40 <mmorrow> , eval "(\\a->(a,a))"
00:09:42 <lunabot>  luna: Ambiguous type variable `t' in the constraint:
00:10:11 <mmorrow> , eval "(\\a->(a,a))::Int->(Int,Int)"
00:10:13 <lunabot>  <<Int -> (Int,Int)>>
00:11:59 <mmorrow> bast_away: so how i'd go about it is to find the equivalent compileExp function in hint, that goes to an HValue or whatever, then decide some way to make sure that the String of code your compiling has the type you think it does, compile it, then coerce to (String -> a) or whatnot
00:13:49 <mmorrow> i'm not sure off-hand how you'd compile a module that contains an instance of a type class that's defined *in the module that's doing the compiling*, and then be able to somehow "extract" that instance though
00:13:58 <mmorrow> not to say it can't be done of course
00:14:27 <Gwern-away> TH maybe
00:14:29 <mmorrow> but i'd guess it'll require more than no trickery
00:17:42 <mmorrow> bast_away: hmm, i think what i'd do is instead of having a class
00:17:48 <mmorrow> class (Data a) => Parseable a where parse :: String -> Either a ParseError
00:17:56 <mmorrow> instead have a record
00:18:52 <mmorrow> data Parseable a = Parseable {parse :: String -> Either a ParseError} (unfortunately you can't enforce the (Data a) constraint (???))
00:19:44 <mmorrow> err, actually
00:19:52 <kw317> I am playing with Control.Parallel and can't really get any speedup by using it
00:20:22 <mmorrow> how do you even know that that `a' is?
00:20:38 <kw317> I've got this trivial function, evaluating naiive fib of 41 and 42 and adding them together and it works faster when executed with one thread than two (on a two core machine)
00:20:40 * mmorrow is stumped
00:23:44 * mmorrow is procrastinating because he doesn't want to do the tedious task that he currently has to do
00:23:52 * mmorrow sucks it up, disappears
00:23:56 <erikc> which task is that
00:24:03 <erikc> ...the dishes
00:24:14 <mmorrow> organizing a bunch of code/packages into a single organized package
00:24:23 <erikc> ah hehe
00:24:44 <erikc> so it is the dishes
00:25:17 <PetRat> If you have a container C, and you want to write a function [C a] -> C [a], what typeclasses are available that represent this?
00:26:03 <Saizan> is C a Monad or an Applicative?
00:26:12 <erikc> PetRat: sequence if C is a monad
00:26:24 <Saizan> if so there's sequence or sequenceA
00:26:36 <PetRat> C is weaker than Monad or Applicative I believe. It is a context that supplied a single contextual value and has no meaningful default value.
00:27:29 <Saizan> PetRat: what should that function return if the input list is empty?
00:27:52 <PetRat> I don't think it's Applicative because there's no meaningful way to write "pure" ... Saizan, you have hit the nail on the head, there is no meaning in that case.
00:28:31 <mmorrow> erikc: heh, worse than dishes
00:28:48 <Saizan> PetRat: heh
00:29:07 <PetRat> Saizan: heh?
00:29:45 <PetRat> I guess I don't have a meaningful abstraction here. I just starting to figure out what some of these abstractions are useful for.
00:30:47 <Saizan> i don't think it fits in any of the common classes
00:30:52 <Saizan> maybe it's a comonad?
00:31:18 <dolio> I doubt you'll find many abstractions where it's considered okay to just fail on a well-typed input.
00:31:29 <dolio> fail in monad being the one I can think of.
00:31:32 <dibblego> [C a] -> C [a] looks like traverse id
00:31:35 <dolio> And that shouldn't be there.
00:32:04 <Saizan> dibblego: yeah, it'd be sequenceA if C was applicative, but apparently there's no pure
00:32:11 <dibblego> ah
00:33:04 <erikc> is fail in monad generally considered a mistake?
00:33:08 <Saizan> yes
00:33:26 <DrSyzygy> :t fail
00:33:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
00:34:03 <copumpkin> yet it was explicitly added :/
00:34:05 <copumpkin> fail = epic fail
00:34:11 <copumpkin> :t let fail = ?epic fail in fail
00:34:12 <lambdabot> forall t. (?epic::t -> t) => t
00:34:29 <Saizan> the point is that there are monads like State, Reader, Writer .. for which fail has no meaning
00:35:08 <copumpkin> yeah, so it's just error most of the time
01:06:33 <MarcWeber> nominolo:  You can use let g:foo = expand('$HOME').'/path/to/scion'
01:12:02 <MarcWeber> nominolo: Also you should have checked my repo. I added the set filetype plugin on stuff to README.markdown. Should add a note that I maintain the vim stuff ?
01:30:44 <etpace_> :t catchError
01:30:46 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
01:46:07 <quicksilver> nominolo++ # releasing scion
01:49:51 <chrisbrown> does anyone here have experience of using nondeterminism in Haskell to keep track of state?
01:50:48 <Taejo> > splitAt 1 "abc"
01:50:49 <lambdabot>   ("a","bc")
01:52:11 <andrewz> is there a proxy server written in haskell?
01:53:37 <andrewz> or should i just write one from scratch with network
01:54:05 <Taejo> > init [1..]
01:54:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:54:20 <Taejo> why do the docs for init say the list must be finite?
01:55:32 <quicksilver> Taejo: looks like a doc bug to me.
01:55:50 <Taejo> quicksilver: where should I report it?
01:56:08 <quicksilver> libraries@haskell.org I believe
01:56:37 <quicksilver> I think the GHC trac can be used for base library bugs too.
01:56:53 <kaol> @src init
01:56:53 <lambdabot> init [x]    = []
01:56:53 <lambdabot> init (x:xs) = x : init xs
01:56:53 <lambdabot> init []     = undefined
01:57:17 <etpace_> Can anyone explain how readerT works? it seems to be ok until local, how does it know what to give back when `ask'd, especially as the monad getting localised doesnt know that it has been?
01:57:42 <quicksilver> readerT just works by passing a parameter
01:57:49 <quicksilver> local just passes a different parameter to the bit inside, no?
01:58:06 <Taejo> kaol: one *could* write a version of init that gave _|_ on infinite lists, but Haskell is supposed to be lazy by default
01:58:26 <int-e> newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}
01:58:55 <int-e> local just changes the value passed in for 'r'. and  ask  is just  ReaderT return.
01:59:14 <quicksilver> Taejo: and it would be needlessly expensive too
01:59:22 <Taejo> yeah
01:59:31 <viator_sg> there is any way to install a package with cabal environment without 'cabal isntall'? like a manual cabal install? (the package that I was trying install is broken)
01:59:46 <quicksilver> init (x:xs) = let ys = init xs in ys `seq` x : ys
01:59:47 <quicksilver> I think
02:00:00 <kaol> > (reverse . tail . reverse) [1..]
02:00:01 <etpace_> does it? the monad for local (const (newEnv)) (do stuff) doesnt take a parameter after stuff. so how does it know what to ask
02:00:05 <lambdabot>   mueval-core: Prelude.read: no parse
02:00:05 <lambdabot>  mueval: ExitFailure 1
02:00:43 <dcoutts> viator_sg: you can run the individual steps of a "cabal install"
02:01:14 <etpace_> bad example, should be dostuff here,
02:01:18 <int-e> viator_sg: the package should come with a Setup.(l)hs file; you can run Setup configure, Setup build, and Setup install. But you can still use the cabal tool, running "cabal install" in the unpacked source directory, after patching any bugs.
02:01:19 <etpace_> not the actual do
02:02:59 <quicksilver> etpace_: not really sure what you mean "the monad for local"
02:03:34 <quicksilver> local f m = ReaderT $ \r -> runReaderT m (f r)
02:04:00 <quicksilver> ^^ the implementation of local calls runReaderT on the action, but provides it with the environment "f r" instead of "r"
02:04:24 <andrewz> any advice on writing a socks proxy in haskell?
02:04:31 <etpace_> What does runReaderT do?
02:04:31 <viator_sg> Thanks int-e, dcoutts :)
02:04:32 <int-e> hmm maybe etpace_ is confused about the scope of 'local'?
02:05:07 <quicksilver> etpace_: runReaderT runs a ReaderT action with a given environment.
02:06:52 <etpace_> yeah, im not sure how the things inside local get a different result to asks, as they're not "given" a special asks function
02:07:21 <quicksilver> a ReaderT action is a function
02:07:24 <Taejo> @src asks
02:07:24 <lambdabot> asks f = do
02:07:25 <lambdabot>     r <- ask
02:07:25 <lambdabot>     return (f r)
02:07:25 <quicksilver> it's waiting for a parameter
02:07:29 <quicksilver> (the environment)
02:07:32 <Taejo> @src local
02:07:32 <lambdabot> Source not found. You type like i drive.
02:07:48 <quicksilver> Taejo: not helpful. Thanks.
02:07:54 * quicksilver renews his lobby for @src to be removed.
02:08:07 <quicksilver> etpace_: a ReaderT action is just a function waiting for a parameter.
02:08:17 <quicksilver> etpace_: you 'run' it by providing a parameter
02:08:27 <quicksilver> etpace_: local 'runs' the subaction with a different parameter
02:08:58 <etpace_> :t ReaderT
02:09:01 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
02:10:00 <quicksilver> as int-e remarked a while ago, "ReaderT r m a" is really just (r -> m a)
02:10:05 <quicksilver> it's a function, waiting for the parameter r.
02:11:28 <etpace_> I guess the next question is how does ReaderT work? it receives a function that takes an enviroment, but how does the `m' finds ask, somebody said something about return, so does it create a new constructor for each `local' and then return sorts out what's needed?
02:11:51 <quicksilver> ask is a class method.
02:12:11 <quicksilver> so there is an instance for it - there is an ask implementation for ReaderT, in the MonadReader instance for ReaderT
02:12:23 <quicksilver> you can read the code here : http://www.haskell.org/ghc/dist/current/docs/libraries/mtl/src/Control-Monad-Reader.html
02:12:35 <quicksilver> search for "MonadReader r (ReaderT r m)"
02:12:50 <quicksilver> the ask instance is very simple though :)
02:12:55 <quicksilver> implementation, I mean.
02:14:21 <int-e> etpace_: one important thing to realize is that all this happens outside of the m monad. (and in fact to use m actions, you typically have to use 'lift')
02:17:36 <int-e> (For some monads you don't have to do that, but that's because they put their actions into type classes that have instances for ReaderT m as well, because ReaderT has a MonadTrans instance.)
02:18:00 <etpace_> :t runReaderT
02:18:02 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
02:18:39 <doserj> newtype ReaderT r m a = ReaderT {runReaderT :: r -> m a}
02:18:54 <int-e> that is, ReaderT r m a -> (r -> m a) -- the  r -> m a  should look familiar by now.
02:21:15 <etpace_> :t Map.empty
02:21:16 <lambdabot> Couldn't find qualified module.
02:21:27 <etpace_> :t Data.Map.empty
02:21:28 <lambdabot> forall k a. M.Map k a
02:23:31 <etpace_> so the m in local is also a ReaderT, and just gets passed a new enviroment?
02:26:37 <quicksilver> etpace_: right.
02:27:09 <quicksilver> etpace_: local takes two parameters; an action to run and a function to apply to the environment
02:27:16 <quicksilver> that action is in the 'same monad you're in now'
02:27:24 <quicksilver> so, in the case of ReaderT, that action is also a ReaderT.
02:29:05 <path[l]> jmcarthur: hi you around?
02:29:10 <etpace_> It's the initial call throwing me now, it seems that it 'builds' all the code, and then gets given an initial enviroment?
02:34:11 <chrisf> hi #haskell, i'm writing a C preprocessor to teach myself Haskell and Parsec... i've got punctuators working, although I was told that "try" should be avoided. here's my code: http://haskell.pastebin.com/m2acab974. any suggestions?
02:34:15 <etpace_> and I have env <- ask; ask = ReaderT return, so env = return = ReaderT (\_ -> return a), now what return is that? is that for Reader?
02:34:22 <quicksilver> etpace_: the nature of monads in general is that you 'build' a great bit action and then you somehow 'run' it.
02:34:31 <quicksilver> etpace_: great "big" action sorry
02:34:41 <quicksilver> etpace_: in the case of reader, running is just providing the environment.
02:34:55 <quicksilver> but you're right to imagine the building as happening 'first' and then the environment is provided when you want to run it.
02:34:58 <etpace_> makes sense
02:35:06 <quicksilver> you can, for example, build the action and then run it twice, with different environments.
02:35:19 <quicksilver> etpace_: that return was for the 'inner' monad
02:35:22 <kaol> let's rename main as runIO
02:35:22 <fasta> How can I undo ghc hide <package>?
02:35:30 <quicksilver> whatever ReaderT was being applied to
02:35:40 <fasta> Never mind
02:36:01 <etpace_> How can you tell quicksilver?
02:36:25 <quicksilver> etpace_: by the type of the constructor 'ReaderT'
02:36:32 <dolio> kaol: That doesn't really make sense considering its type is IO a.
02:36:37 <quicksilver> etpace_: ReaderT takes an argument of type 'r -> m a'
02:36:41 <kaol> I know.
02:36:47 <quicksilver> etpace_: where 'm' is the inner monad
02:36:50 <dolio> It'd be more like theIOThatIsRun.
02:37:10 <dolio> That's a pretty good Java name.
02:38:07 <doserj> publicStaticVoidMain
02:38:54 <jkff> Hi people. I wonder: is it possible to efficiently compare two binary search trees for set equality without allocating on the heap?
02:39:17 <jkff> T.i. without a toList
02:39:32 <chrisf> if you can walk them in-order, sure.
02:40:12 <jkff> How can I simultaneously walk them in-order without allocating on the heap?
02:40:19 <jkff> That sounds easy, but I'm stuck :)
02:40:29 <quicksilver> you can't do *anything* in haskell without allocating on the heap.
02:40:38 <jkff> Honestly, I'm doing it in Java ;)
02:41:15 <quicksilver> it's just tree recursion
02:41:45 <jkff> But it's a merge-like tree recursion on two trees with different structure simultaneously
02:42:02 <quicksilver> oh I see what you mean
02:42:29 <quicksilver> you need a tree iterator which knows where it is an which way it's going
02:42:44 <fasta> jkff: you use Oleg's generic zipper based on delimited continuations twice and you are done.
02:42:48 <quicksilver> and you need parent pointers in your structur
02:42:48 <jkff> Yes, that's exactly what I find hard to do without allocation and without making the trees threaded
02:43:00 <quicksilver> yes, you need either parent pointers or an explicit stack.
02:43:08 <quicksilver> or schorr-waite
02:43:16 <quicksilver> (abuse child pointers as parent pointers)
02:43:22 <chrisf> actually, does java have generators yet?
02:43:25 <jkff> I can't have parent pointers or schorr-waite because, although I'm in Java, that's my home-brewn immutable red-black set
02:43:31 <jkff> chrisf: unfortunately not
02:43:37 <quicksilver> tehn you will need an explicit stack, IMO.
02:43:40 <jkff> fasta: yes, what's simpler than delimited continuations in Java ;)
02:43:53 <fasta> jkff: everything?
02:44:01 <jkff> fasta: Sounds right.
02:44:19 <fasta> jkff: so, in Java, you can also build zippers.
02:44:29 <chrisf> so yeah... explicit stack. why can't you have any heap allocation?
02:44:32 <quicksilver> a zipper is also an explicit stack.
02:44:39 <fasta> quicksilver: yes, it's all the same thing.
02:44:39 <quicksilver> (it's a slightly more implicit explicit stack :P)
02:44:49 <jkff> chrisf: because I need things to be *very* fast
02:45:07 <fasta> jkff: if it has to be very fast, why are you writing it in Java?
02:45:20 <chrisf> heap alloc in java ought to just be bump-the-pointer, if you're running with a decent GC.
02:45:28 <jkff> fasta: because everything else is written in Java, and I don't think that rewriting this part in C would help
02:45:47 <jkff> chrisf: yes, but not doing any heap allocation at all is even faster :)
02:45:58 <jkff> Oh well, I'll try out an explicit stack and see what happens
02:46:16 <chrisf> the fastest code is the code that uh.. can't exist?
02:46:27 <jkff> Exactly :)
02:46:33 <quicksilver> you can design structures which are optimised for comparison
02:46:43 <quicksilver> for example, B*-trees or similar
02:46:54 <quicksilver> then you can just compare along the 'leaf' level like arrays
02:47:02 <quicksilver> (just an extra ++ to skip missing elements)
02:47:10 <jkff> quicksilver: I have already. My immutable trees store their hash/max/min and showing that two trees are *not* equal is rather fast.
02:47:24 <fasta> Has anyone managed to install hp2any-manager? It seems GSoC projects never work on my machine.
02:47:45 <jkff> I am actually experiencing problems with memory overhead of those intermediate on-heap structures and GC overhead on their collection
02:48:14 <chrisf> uh, ok. how big is this?
02:48:16 <jkff> Well, so I'm doing a stack. I've looked at what I am doing now in the code, and a stack will surely do a lot fewer allocations
02:48:20 <fasta> jkff: but then you don't solve the exact same problem, do you?
02:48:50 <chrisf> if you know the height of the trees, you can of course prealloc the stacks
02:48:52 <fasta> jkff: there is always a chance that your comparison returns the wrong answer.
02:48:57 <jkff> chrisf: I don't :)
02:49:16 <chrisf> you know a good bound on it, if you're preserving the RB property.
02:49:28 <Baughn> jkff: Use a good enough hash, and showing that they /are/ equal is also quite fast
02:49:41 <jkff> Baughn: Clarify please?
02:49:55 <Baughn> jkff: I suppose you're using some kind of incremental hash algorithm now?
02:49:58 <jkff> chrisf: Thanks for the idea, now I am also storing a height field :)
02:50:14 <jkff> Baughn: An XOR of hashes of items in sorted order
02:50:37 <jkff> So that it does not change with rebalancing and is incremental
02:50:48 <Baughn> jkff: Right.. hm, actually, I don't think there are any secure hashes that are also incremental. :/
02:50:56 <Baughn> It would be nice, though!
02:54:31 <chrisf> so I've got this big mess of all the punctuators in the C language (type: [String]) and i'm trying to automatically construct a parsec parser from it
02:55:45 <Baughn> I'm going to assume something's not working.
02:55:52 <chrisf> punctuator = (foldl1 (<|>) punctParsers
02:55:52 <chrisf>   where punctParsers = map (try . string) (( reverse . sort ) [ "[", "]", ... many more ... ]
02:56:14 <chrisf> it works, but it does so inefficiently.
02:56:33 <Baughn> Why don't you use choose instead?
02:57:04 <Baughn> And, also - yes, using try indisriminately is slow.
02:57:29 <Baughn> Ideally you'd only allow the punctuation that would actulaly be legal at any given spot, too
02:57:31 <chrisf> *choice
02:57:49 <chrisf> ok, that is better :)
02:58:29 <chrisf> ideally, i'd have that feedback available from the later parts of the parser
02:58:52 <chrisf> but this is tokenizing on the frontend of the preprocessor
02:59:02 <Baughn> Ah..
02:59:04 <quicksilver> you shouldn't need try if you sort the data appropriately
02:59:17 <quicksilver> erm
02:59:21 <quicksilver> that's not true :)
02:59:43 <quicksilver> you could left-factor it by hand, though
02:59:44 <mercury^> Weird, GHC unrolls a loop of unknown size by one.
02:59:53 <chrisf> "i shouldnt need *as much* try if i build a tree"
02:59:59 <quicksilver> if you care about speed
03:00:08 <chrisf> yes, i could left-factor it by hand, but that's *work*.
03:00:14 <quicksilver> no, I mean left-factor it automatically
03:00:28 <Taejo> mercury^: that could be the result of constructor specialisation or something similar
03:00:28 <chrisf> i'm willing to go through all kinds of contortions to left-factor it automatically.
03:00:29 <quicksilver> lexicographic sort and then group by common prefix.
03:01:00 <chrisf> String's Ord instance gives lexicographic sort, yes?
03:01:02 <mercury^> Taejo: it loops through an array and returns the first element that satisfies a criterion (more or less)
03:01:15 <Baughn> chrisf: The appropriate contortion to go through may be to not use parsec. ^^;
03:01:24 <Taejo> mercury^: hmm
03:01:28 <Baughn> Its niceness seems to be highly dependent on the grammar
03:01:35 <Taejo> doesn't sound like constructor specialisation
03:01:57 <chrisf> suggest something else?
03:02:45 <chrisf> quicksilver: can you sketch a 'group by common prefix'? i'm new at this :(
03:03:02 <mercury^> Taejo: as far as I can tell it really gives no benefit at all here.
03:03:03 <Phyx-> :)
03:03:31 <mercury^> More likely to be counterproductive because of code caching and branch prediction.
03:03:42 <quicksilver> > groupBy ((==) `on` head) . sort $ ["+","-","/","*","=","<",">","**","<<",">>","=~","=="]
03:03:43 <lambdabot>   [["*","**"],["+"],["-"],["/"],["<","<<"],["=","==","=~"],[">",">>"]]
03:03:51 <quicksilver> chrisf: well that's the beginning of a sketch :)
03:04:59 <Baughn> chrisf: Something else.. oh, right. happy.
03:06:09 <chrisf> > groupBy ((==) `on` head) . sort $ [">>=",">>", ">=", ">"]
03:06:11 <lambdabot>   [[">",">=",">>",">>="]]
03:06:53 <quicksilver> yes, you'd have to repeat it again inside the sublists
03:07:02 <quicksilver> to find the 2-length prefixes
03:07:04 <chrisf> i'm going to have to do this recursively and build a complete tree, i think. just because C has these damn 3-char punctuators
03:07:09 <mercury^> Does GHC do list unrolling for small lists known at compile time though? That would be a nice feature.
03:07:22 <quicksilver> what 3-char punctuators does C have?
03:07:23 <Taejo> > sequence [Just 'a', Just 'b']
03:07:24 <lambdabot>   Just "ab"
03:07:29 <Taejo> > sequence [Just 'a', None]
03:07:30 <lambdabot>   Not in scope: data constructor `None'
03:07:34 <Baughn> quicksilver: The rigrams?
03:07:34 <Taejo> > sequence [Just 'a', Nothing]
03:07:35 <lambdabot>   Nothing
03:07:36 <Baughn> *trigrams
03:07:44 <chrisf> >>= <<= &&= ||=
03:08:20 <Baughn> Admittedly, I'd probably shoot someone who used them.
03:08:48 <dolio> Trigraphs.
03:08:54 <chrisf> apparently some people have keyboards that suck.. but i have no intention of supporting trigraphs.
03:09:00 <quicksilver> chrisf: ah, right.
03:09:35 <mercury^> chrisf: what are you writing?
03:09:45 <chrisf> C compiler
03:10:03 <chrisf> in literate haskell, embedded in the latest C draft std
03:10:18 <mercury^> If it's more than a personal toy you should try to at least compile all valid programs correctly.
03:11:01 <chrisf> trigraph replacement is meant to happen pre-tokenization anyway, so it doesnt affect this.
03:11:17 <quicksilver> yeah, you can have a trigraph preprocessor
03:12:03 <chrisf> in the std, trigraph replacement is done as part of the initial mapping to the source charset (phase 1 of translation)
03:13:03 <chrisf> I know you can merge quite a few of those phases, but since this is being written within the std text itself, i'm finding it more useful to not try to be too clever :)
03:14:12 <chrisf> so, i build a tree of the punctuator characters by grouping on common prefixes.. and then assemble that into a parsec parser via some hax..
03:14:32 <quicksilver> s/hax/elegant combinator manipulation/
03:14:57 <mercury^> chrisf: Will the output be efficient in any way or is it meant as an explanation of the std?
03:15:25 <chrisf> i see no reason why i can't do some decent optimizations
03:15:41 <chrisf> but that doesnt concern the frontend much at all :)
03:16:22 <chrisf> yes... elegant combinator manipulation :)
03:17:49 <mercury^> What does [ALWAYS Just L] in core mean?
03:20:06 <chrisf> sorry, ||= &&= dont actually exist :)
03:21:43 <mercury^> && and || are pretty useless anyway imo
03:21:57 <mercury^> (for assignment)
03:22:21 <dolio> Ruby's got them. But I guess they're a little less trivial there.
03:23:02 <mercury^> In C you can always use &= and |= with no different semantics.
03:23:30 <chrisf> except `true` is `nonzero`, not `1`
03:23:31 <mercury^> Unless you really need a 1 and wouldn't get one otherwise, which shouldn't happen.
03:23:33 <dolio> Not really.
03:23:43 <quicksilver> perl's got them too
03:23:51 <quicksilver> but it has to really, because they look like line noise
03:23:54 * medfly wonders why there's a huge discussion about C here.
03:23:57 <dolio> At least, it would depend on what they meant.
03:23:59 <mercury^> chrisf: you don't need the lazy semantics of && and || if the left side is a variable.
03:24:03 <quicksilver> all line noise MUST be executable by a conformant perl interpreter.
03:24:15 <quicksilver> medfly: chrisf is writing a C compiler in haskell :)
03:24:19 <chrisf> qft
03:24:20 <quicksilver> medfly: it is ontopic, honest ;)
03:24:23 <medfly> oh.
03:24:34 <dolio> If '1 ||= f(x)' didn't evaluate f(x), and f(x) has side effects, then they're not semantically the same.
03:24:34 <medfly> I was wondering, not pointing out it's off-topic.
03:24:47 <chrisf> we'll just keep quiet about the random java question before, eh? ;)
03:30:38 * chrisf hacks around trying to avoid `try` completely
03:31:13 * Taejo is looking at http://www.longestpoemintheworld.com/ and trying to think of good ways to generate infinite poems with more interesting rhyme schemes
03:31:23 <chrisf> btw, there's one 4-ch punctuator in the C std.
03:31:32 <chrisf> %:%: :(
03:31:38 <Twey> O.O
03:31:42 <Twey> What does it do?
03:31:54 <mercury^> What keeps GHC from unboxing a strict field when -funbox-strict-fields is used?
03:31:57 <chrisf> it's a double-digraph form of something else :)
03:32:49 <Twey> The â€˜longest poem in the worldâ€™ reads more like a rap
03:32:57 <bastl> > (printf "%d%d" 3)::String
03:32:59 <lambdabot>   "3* Exception: Printf.printf: argument list ended prematurely
03:32:59 <Twey> chrisf: And what is that?
03:33:05 <chrisf> ##, of course :)
03:33:10 <fasta> What is the option to tell ghc to warn me when I have forgotten to handle a pattern in a case statement?
03:33:16 <bastl> how do i use printf ?
03:33:18 <Twey> o.@
03:33:25 <Twey> bastl: Pass it all its arguments?  ;)
03:33:39 <Twey> > printf "%d%d" 3 4 :: String
03:33:40 <lambdabot>   "34"
03:33:42 <fasta> -fwarn-incomplete-patterns, never mind.
03:33:54 <Twey> fasta: Isn't that on by default?
03:34:16 <fasta> Twey: I don't think so.
03:34:32 <Twey> I'm fairly sure it is.
03:35:05 <Twey> Hm, maybe I'm thinking of overlapping patterns.  Never mind.
03:35:08 <chrisf> Twey: # isnt present on quite a few keyboards (or indeed, in some character sets where C is still needed)
03:35:22 <Twey> chrisf: Weird
03:35:42 <chrisf> the things you only learn when you implement the language spec, eh :)
03:35:59 <Twey> Aye.
03:36:22 <fasta> chrisf: and then there are the dialects...
03:36:32 <fasta> chrisf: which C are you implementing?
03:36:44 <chrisf> latest 201x draft
03:37:03 <fasta> chrisf: are you on the committee or something?
03:37:09 <mercury^> chrisf: What are the interesting new features?
03:37:23 <mercury^> I only read some design goal document a long time back.
03:37:28 <mercury^> Which didn't really say much.
03:39:19 <chrisf> mercury^: here's the c1x charter: http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1250.pdf
03:40:12 <chrisf> i agree, it's a fairly useless document.
03:41:34 <mercury^> chrisf: yeah, it's the one I read.
03:41:47 <mercury^> So, now that you read a draft, what's new? =)
03:45:20 <chrisf> not a lot :)
03:47:20 <chrisf> fasta: no, i'm not on the committee. i'm doing this as an experiment in writing a compiler alongside the language spec. haskell turns out to be an ideal language for that.
03:47:51 <fasta> chrisf: but why are you doing that?
03:48:14 <chrisf> because it's something that i havent seen done before.
03:48:54 <chrisf> well, you could count the TeX book, actually.
03:49:01 <fasta> chrisf: SRFIs do that all the time.
03:49:12 <Phyx-> oh, there's a new C draft?
03:50:51 <chrisf> Phyx: here: http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1362.pdf
03:51:27 <Phyx-> chrisf: thanks, i'll take a look
03:51:35 <maxote> C89 -> C99 -> C09 is it true?
03:51:54 <chrisf> ok, so Scheme people do it too :) i haven't seen it done for a *mainstream* language, better?
03:52:06 <chrisf> well, it will be C1x.
03:52:52 <mercury^> C0a
03:53:07 <chrisf> well, hopefully it wont be > C0f
03:54:14 <chrisf> hey what are people's opinions on c++0x losing its concepts?
03:54:23 <mercury^> Didn't hear yet.
03:54:25 <chrisf> while we're busy not talking about haskell at all.
03:54:28 <mercury^> Quite a disappointment.
03:54:41 <mercury^> Was the best addition by far.
03:54:47 <mercury^> Why did they drop it?
03:55:04 <chrisf> the proposal still had issues.
03:55:34 <mercury^> The people who worked on ConceptGCC must be rather frustrated now.
03:56:26 <chrisf> here's Herb Sutter's take on it: http://herbsutter.wordpress.com/2009/07/21/trip-report/
03:56:40 <chrisf> well, ConceptGCC is an interesting... proof of concept.
03:56:44 <bastl> hmm, "ghc --help" refers to a broken link on haskell.org: http://www.haskell.org/ghc/documentation.html (6.10.3)
03:56:56 <chrisf> i wouldnt call it usable.
03:57:24 <chrisf> no, the concepts stuff will probably make it into the next revision of the standard (probably ~2015)
03:57:48 <chrisf> better to drop it now and make sure its right, than cock up the language even more :)
04:00:01 <Phyx-> bastl: report it on http://hackage.haskell.org/trac/ghc/
04:00:04 <chrisf> that language already has its share of badly-designed features :)
04:06:01 <Phyx-> hmmmm i think the FSF has been smoking some crack
04:07:12 <EvilTerran> Phyx-, at least it's open-source crack!
04:07:40 <Phyx-> EvilTerran: made by someone in their basement, no thanks, i rather have "professionals" make my crack
04:07:48 <Phyx-> :P
04:08:25 <quicksilver> chrisf: HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH "Templates are still king of the genericity hill"
04:08:32 <quicksilver> chrisf: HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA
04:08:42 <quicksilver> chrisf: and that guy works in language design?
04:08:58 <Phyx-> hmm.. never seen you laugh like that quicksilver
04:09:06 <Phyx-> i've always found templates kinda evil..
04:09:17 <Phyx-> in some of it's uses i've seen :|
04:09:30 <chrisf> most of the fun things you can do with templates are evil :)
04:09:58 <quicksilver> Phyx-: It's hard, in IRC, to express the emotion I feel reading that.
04:10:07 <quicksilver> Phyx-: that was the only way I felt got remotely close :)
04:10:43 <quicksilver> Templates are, in fact, the ugly goblin that lives in a cramped tunnel at the bottom of the genericity hill covered in boils which hurt when he comes out into the light.
04:10:45 <Phyx-> quicksilver: hahhaha
04:12:21 <etpace_> :t return
04:12:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:12:27 <chrisf> that's a fair description, yes :)
04:12:33 <etpace_> WIth return/pure, how do I know what applicative/monads return/pure I'm using?
04:12:52 <quicksilver> etpace_: by running type inference on the program.
04:13:10 <quicksilver> > [Nothing,return 5]
04:13:12 <lambdabot>   [Nothing,Just 5]
04:13:16 <quicksilver> > [[],return 5]
04:13:17 <lambdabot>   [[],[5]]
04:13:36 <quicksilver> notice how return 5 "becomes" the right monad for the context.
04:14:53 <etpace_> so return becomes whatever is correct?
04:15:26 <etpace_> > [return 1]
04:15:28 <lambdabot>   No instance for (GHC.Show.Show (m t))
04:15:28 <lambdabot>    arising from a use of `M3047826623...
04:15:35 <etpace_> :t [return 1]
04:15:37 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => [m t]
04:16:08 <ray> > [return 1] :: Either Bool Integer
04:16:09 <lambdabot>   Couldn't match expected type `Data.Either.Either
04:16:15 <etpace_> > fromJust <$> [return 1]
04:16:17 <lambdabot>   [1]
04:16:51 <ray> > [return 1] :: [Either Bool Integer] -- even
04:16:52 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Bool.Bool)
04:16:52 <lambdabot>    arising ...
04:16:54 <Phyx-> reqamst: you're missing the monad
04:17:12 <Phyx-> it can't infer the correct monad instance from [return 1]
04:17:16 <Phyx-> because it's the only element
04:17:35 <chrisf> there isnt a monad instance for Either, is there?
04:17:49 <Phyx-> etspace_ notice how quicksilver used, Nothing or [] to give it addictional information about which monad it's using
04:18:04 <Phyx-> chrisf: don't think so, been looking for one myself
04:18:12 <Phyx-> or rather, i usually write one myself
04:18:25 <chrisf> > [Right 2, pure 3]
04:18:26 <lambdabot>   No instance for (Control.Applicative.Applicative
04:18:26 <lambdabot>                     (Data....
04:18:41 <chrisf> it's not Applicative either.
04:19:38 <quicksilver> chrisf, Phyx- yes, it's in Control.Monad.Error
04:19:38 <chrisf> Phyx: is there some universal way of interpreting Either as a monad, that I'm missing?
04:19:47 <chrisf> oh, right.
04:19:55 <quicksilver> it adds a constraint of Error e => on the Left part which many find annoying.
04:20:05 <reqamst> Phyx-: huh?
04:20:06 <quicksilver> although it's not hard to set up a spurious Error instance for the type of your choice
04:20:24 <ray> Monoid might be a better constrait
04:20:32 <Phyx-> reqamst: sorry, tab-complete mishap
04:20:47 <reqamst> Phyx-: ah, no problem ^^
04:21:33 <ray> > pure 2 :: ZipList Integer
04:21:34 <lambdabot>   No instance for (GHC.Show.Show
04:21:34 <lambdabot>                     (Control.Applicative.Zip...
04:21:40 <quicksilver> ray: Monoid is a very interesting constraint but gets you a totally differant applicative
04:21:46 <ray> > getZipList $ pure 2 :: ZipList Integer
04:21:47 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
04:21:47 <quicksilver> ray: (and *that* Applicative does not generalise to a Monad)
04:22:22 <ray> hm, because it would lose Left information?
04:22:43 <doserj> > [return 1] :: [Either String Integer]
04:22:44 <lambdabot>   [Right 1]
04:22:49 <ray> > getZipList $ (pure 2 :: ZipList Integer) -- i haven't had my coffee
04:22:50 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
04:23:19 <quicksilver> ray: the whole point of that applicative is that you can evaluate a later effect even if the earlier one failed
04:23:27 <quicksilver> ray: (and try to collect more failure messages)
04:23:42 <quicksilver> ray: monads can never do that because they are allowed to have dependencies between effects
04:23:50 <quicksilver> ray: this is the essence of the difference between monad + applicative
04:23:51 <Saizan> how broken would you consider a type for which ap and <*> have different semantics, like you could do in this case?
04:24:39 <ray> you just need a newtype wrapper around one instance or something
04:25:32 <Saizan> i mean that maybe it's not so bad if <*> "optimizes"
04:25:56 <quicksilver> Saizan: I'd consider it broken.
04:25:59 <ray> quicksilver: ah, you're going to add Lefts?
04:26:09 <quicksilver> ray: Yes, isn't that what you meant? :)
04:26:10 <doserj> Saizan: ap /= <*> would also imply liftAn /= liftMn, right?
04:26:16 <quicksilver> Maybe we were at cross purposes all along.
04:26:19 <ray> i was just going to zero them all and have it degenerate to Maybe
04:26:44 <quicksilver> Saizan: I'd like Applicative to coincide with Monad where both exist
04:26:49 <quicksilver> ray: right. Yes. You can do that.
04:27:00 <quicksilver> Morally that's just a "Zero e" => constraint
04:27:10 <quicksilver> which is, to be honest, pretty much what Error e is.
04:27:23 <quicksilver> Error e is like ZeroButWithOptionalStringDescriptionOfTheZero
04:27:44 <ray> ah, like fail in monads
04:28:00 <quicksilver> anyhow, this adding together of errors is one of the very, very few examples I have of an interesting applicative which doesn't generate a monad.
04:28:06 <quicksilver> (it comes from the applicative paper)
04:28:28 <quicksilver> ray: yes, it's raison d'etre is to be able to give a sensible definition of 'fail' in the formed monad.
04:29:33 <Saizan> i get some form of staging by composing applicatives instead of monads
04:29:37 <ray> yeah, morally it is Zero, i just uncharacteristically restrained myself to classes we have
04:30:57 <Saizan> doserj: yeah
04:31:00 <path[l]> aww nothing for me the whole day :(. Bmeph had a suggestion, I can try that. Seems minor though
04:37:54 <ray> that applicative paper is pretty art deco
04:38:49 <quicksilver> Yes, it goes nicely with my coffee table.
04:39:35 <ray> they should publish papers in coffee table book form with big glossy illustrations
04:39:48 <ray> the applicative paper could have pictures of rockefeller center
04:42:52 <pr> can you provide a link to that very paper?
04:43:53 <ray> http://strictlypositive.org/IdiomLite.pdf
04:50:44 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8721#a8721 -- where, apart from the return, does this allocate?
05:02:59 <EvilTerran> mercury^, er... is that Core?
05:03:22 <mercury^> EvilTerran: yes.
05:06:26 <Axman6> mercury^: ... that first function has an insane number of arguments...
05:07:58 <mercury^> There is only one function there.
05:12:45 <mun> if i have a list containing 3 elements, what's a good way to assign each to a different variable? a:b:c = list?
05:13:10 <mercury^> [a,b,c] = list
05:14:18 <Twey> Or (a : b : c : _) = list if you don't want it to fail if you have more than three
05:14:21 <mun> ah ok
05:14:28 <mun> thanks
05:14:50 <Twey> (the idea you were going for was (a : b : c : []) = list, with a null on the end)
05:15:02 <Twey> (that's just the same as saying [a, b, c])
05:17:34 <badkins> Very newbie question, but I'm having trouble finding a sort function in the standard library.
05:17:43 <badkins> I'm looking for something analogous to the following in Ruby:
05:17:43 <Twey> Data.List.sort
05:17:43 <badkins> [[:a,10],[:b,7],[:c,11]].sort {|a,b| a[1] <=> b[1]}
05:17:48 <badkins> thanks!
05:17:56 <Twey> FWIW, lambdabot has a handy function
05:18:00 <Twey> @index sort
05:18:01 <lambdabot> Data.List
05:18:21 <Twey> Also, if you know or can figure out the type of a function you want, but don't know its name:
05:18:32 <Saizan> ?type sortBy (comparing fst)
05:18:33 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
05:18:36 <Twey> @hoogle Ord a => [a] -> [a]
05:18:37 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
05:18:37 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
05:18:37 <lambdabot> Prelude cycle :: [a] -> [a]
05:18:55 <quicksilver> badkins: the direct translation of that is sortBy (comparing fst) or sortBy (compare `on` fst)
05:19:07 <Twey> Oh, aye, missed that, sorry
05:19:33 <badkins> I think you mean 'second' instead of 'first', but thanks.
05:19:42 <quicksilver> I probably do.
05:19:53 <Twey> [a, b] is a tuple in Ruby?
05:20:00 <Twey> If it's a list, it's more like (!! 1)
05:20:08 <badkins> it's a list
05:20:18 <badkins> yes, (!! 1) seems right
05:20:21 <Twey> (but you probably should be using tuples here)
05:20:23 <quicksilver> but that would be un-idiomatic
05:20:25 <Twey> (in Haskell)
05:20:33 <quicksilver> you should use tuples if they're all the same length
05:20:38 <Twey> And the same type
05:20:38 <quicksilver> which your example strongly suggests.
05:20:43 <dmwit> (lists are 0-indexed)
05:20:46 <badkins> yes, in Haskell. Ruby has no tuples :)
05:21:06 <Twey> I mean, each the same type overall; types of elements can differ in tuples (but not in lists)
05:22:11 <badkins> Trying to translate a Ruby function to take the n largest items from a list in order of appearance: http://www.pastie.org/596554
05:23:14 <badkins> seems perfect for Haskell
05:23:26 <dmwit> take n . sort?
05:23:36 <badkins> in order of appearance ?
05:23:40 <dmwit> take n . sortBy f, I guess
05:23:44 <dmwit> "order of appearance"?
05:23:50 <badkins> order in the list
05:23:53 <dmwit> (Sorry, I don't speak Ruby, so your paste doesn't mean much to me.)
05:23:54 <int-e> badkins: yes, sort is a stable sort.
05:24:16 <int-e> oh.
05:24:21 * int-e gets it.
05:24:27 <badkins> :)
05:24:46 * dmwit still doesn't
05:24:48 <fasta> mercury^: what was the solution to your previous problem?
05:24:49 <int-e> the two largest elements of [2,3,4,1] should be [3,4]
05:24:55 <int-e> not [4,3]
05:24:56 <mercury^> fasta: which one?
05:25:00 <dmwit> int-e: ...ah
05:25:04 <fasta> mercury^: allocation problem
05:25:10 <mercury^> It has no solution yet.
05:25:31 <fasta> mercury^: ok, I did look at the bug already before I asked, it would just seem that this is the exact same problem.
05:25:37 <dmwit> Ah, now the Ruby code makes sense.
05:25:48 <mercury^> fasta: yeah.
05:25:49 <dmwit> And it should be quite straightforward indeed to translate exactly that code into Haskell. =)
05:25:59 <badkins> once I figure out the types :)
05:26:02 <fasta> Should I already switch to Ruby?
05:26:16 <int-e> @type map snd . sortBy (`on` fst) . take n . sortBy (`on` snd) . zip [1..]
05:26:17 <dmwit> badkins: Well, yeah, straightforward for a Haskell guru. ;-)
05:26:17 <lambdabot>     Couldn't match expected type `b -> b -> c'
05:26:17 <lambdabot>            against inferred type `(a, b1)'
05:26:17 <lambdabot>     In the second argument of `on', namely `fst'
05:26:31 <dmwit> int-e: s/`on`/comparing/g
05:26:39 <int-e> @type map snd . sortBy (compare `on` fst) . take ?n . sortBy (compare `on` snd) . zip [1..]
05:26:40 <lambdabot> forall b. (?n::Int, Ord b) => [b] -> [b]
05:26:51 <dmwit> comparing = on compare
05:28:11 <badkins> I like zip [1..] much nicer than my mapping an incrementing variable
05:28:22 <int-e> > let f n = map snd . sortBy (compare `on` fst) . take n . sortBy (flip compare `on` snd) . zip [1..] in f 4 $ [1,3..7]++[2,4..]
05:28:27 <lambdabot>   mueval-core: Prelude.read: no parse
05:28:27 <lambdabot>  mueval: ExitFailure 1
05:28:33 <bastl> why cant I derive a Data instance like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3434 ??
05:28:46 <etpace_> :t on
05:28:48 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:29:19 <mux> > let isanagram = (==) `on` sort in isanagram "RACE" "CARE"
05:29:20 <lambdabot>   True
05:29:21 <int-e> oops.
05:29:27 <int-e> > let f n = map snd . sortBy (compare `on` fst) . take n . sortBy (flip compare `on` snd) . zip [1..] in f 4 $ [1,3..7]++[2,4..8]
05:29:28 <mux> my favourite use of on so far
05:29:29 <lambdabot>   [5,7,6,8]
05:29:49 <etpace_> on f g x y = f (g x) (g y)?
05:30:05 <mux> etpace_: yes
05:30:06 <badkins> int-e: nice!
05:30:18 <int-e> etpace_: yep. or, prettier, on (?) g x y = g x ? g y
05:30:20 <gwern> @src on
05:30:20 <lambdabot> (*) `on` f = \x y -> f x * f y
05:30:25 <mux> int-e: comparing == (compare `on`)
05:30:37 <badkins> 'on' is in neither of my Haskell books :(
05:30:44 <etpace_> aha
05:30:50 <int-e> mux: I know. I don't really care though, `on` is more useful to teach than comparing.
05:31:02 <mux> alright alright :)
05:31:21 <dmwit> bastl: Are you aware that you are trying to do tricky existentially-bound-variable stuff there?
05:31:50 <bastl> dmwir: not really ..
05:31:50 <gwern> badkins: well, they can't cover every little variant on lambda functions
05:31:51 <dmwit> bastl: If you are aware, then you should be aware why you can't derive things; if you aren't aware, then perhaps you'd like to add that "a" to the left-hand-side of your data equation...
05:32:21 <dmwit> data Parser a = Parser { name :: ..., parse :: String -> a } deriving (Data, Typeable)
05:32:41 <dmwit> bastl: (It's considered good form to put contexts on functions only, and not on data types.)
05:32:56 <int-e> badkins: `on` is a rather recent addition to the base library.
05:32:59 <int-e> @index on
05:32:59 <lambdabot> bzzt
05:33:06 <mux> it's in Data.Function
05:33:08 <int-e> hehe.
05:33:12 <mux> and also Data.Ord unfortunately
05:33:17 <mux> (I thinkà)
05:33:22 <bastl> dmwit: hmm
05:33:31 <int-e> I thought lambdabot would know.
05:33:35 <int-e> @version
05:33:35 <lambdabot> lambdabot 4.2.2
05:33:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
05:33:54 <dmwit> I don't think the ?index database has been updated in a while.
05:34:21 * int-e never looked at how @index works.
05:34:48 * int-e fetches lambdabot sources to have a look :)
05:34:59 <gwern> dmwit: none of the lb state files have been updated in a while...
05:35:13 <int-e> @quote
05:35:13 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
05:35:19 <int-e> @seen gwern
05:35:19 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 20s ago.
05:48:49 <zzaz> what's the best way to extract a sublist of a list (sublist [1,2,3,4] 1 3 = [2,3])?
05:49:17 <byorgey> zzaz: compose 'take' and 'drop' in an appropriate way.
05:49:24 <quicksilver> > take 2 . drop 1 $ [1,2,3,4]
05:49:26 <lambdabot>   [2,3]
05:49:41 <Axman6> > let section a b = take (b-a) . drop a in section 1 3 [1..4]
05:49:42 <lambdabot>   [2,3]
05:49:48 <quicksilver> I was just typing that ;)
05:50:01 <Axman6> :)
05:50:10 <Axman6> you've trained me well master
05:50:12 * EvilTerran watches the answers go from "subtle hint" to "complete answer" over the space of a few seconds
05:50:39 <zzaz> ok
05:50:51 * byorgey watches the same thing with dismay.
05:50:55 * EvilTerran prefers to try to get people who ask questions to see the answer for themselves...
05:52:06 <quicksilver> me too, in general, but this one seemed too simple for that treatment.
05:52:35 <Phyx-> lol
05:52:38 <quicksilver> I think there is quite a lot you can learn from "take 2 . drop 1 $ .."; it's a great simple example of composition.
05:52:49 <Axman6> plus it's something that's built into a number of languages, so i felt people should know how to do it
05:53:10 <Phyx-> > cook
05:53:11 <lambdabot>   Not in scope: `cook'
05:53:23 <Phyx-> booo
05:53:26 <Phyx-> someone implement that
05:53:38 <fasta> Oh, I just love those: (Array.!): undefined array element
05:53:45 <byorgey> > cook
05:53:47 <lambdabot>   sizzle sizzle
05:53:51 <Phyx-> lol
05:53:55 <Axman6> heh
05:54:20 <Phyx-> fasta: i hate the use of fail and error in general, as they're usually not usefull in tracing the error
05:54:46 <Phyx-> i wish ghc would altleast show "a" possible trace to the error, namely the one it took
05:55:09 <fasta> Phyx-: GHC can sortof show that, if you run it with the -p option, IIRC.
05:55:18 <quicksilver> Phyx-: unless profiling is on, ghc doesn't have that trace.
05:55:29 <SamB_XP_> fasta: -xc as well
05:55:30 <quicksilver> Phyx-: lazy evaluation means your stack no longer exists, in general.
05:55:33 <SamB_XP_> +RTS -xc
05:55:33 <Phyx-> fasta: ah, i'll try that
05:55:43 <fasta> SamB_XP_: you are right
05:55:55 <SamB_XP_> you pass that to the program
05:55:57 <Phyx-> quicksilver: i can understand that, but the line that failed would be usefull too
05:56:12 <quicksilver> that would definitel be useful, yes :)
05:56:26 <Phyx-> quicksilver: what about ghci? generally an interpreter does have more information available than the compiled program no?
05:56:30 <fasta> Phyx-: what I do is defining CPP macros for head and other partial functions.
05:56:34 <SamB_XP_> Phyx-: that's why you just rig it so's you get a pattern match failure
05:56:44 <quicksilver> Phyx-: no, the interpreter has the same issue
05:56:54 <quicksilver> Phyx-: the stack may have been garbage collected.
05:57:07 <quicksilver> the solution is to artificially instrument the stack - which is what profiling does.
05:57:15 <fasta> But CPP macros have the disadvantage of also rewriting Foo.head to Foo.(\x -> ...)
05:57:17 <quicksilver> it's a non-trivial cost but obviously it's worth it if it helps you find that bug.
05:57:22 <Phyx-> SamB_XP_: can that be done for all errors?
05:57:34 <SamB_XP_> well, okay, no
05:57:41 <fasta> Arrays are a special case.
05:57:42 <Phyx-> quicksilver: ah ok, i see, so what i was getting at is what profiling would do ok
05:57:57 <quicksilver> right.
05:58:06 <fasta> One should first evaluate all elements to create an Array of type InspectedArray.
05:58:16 <SamB_XP_> but there is that __FILE__ / __LINE__ stuff, still ...
05:58:21 <fasta> And then one should use InspectedArray in the rest of the program.
05:59:09 <fasta> Is it possible to write a program in Coq, which does not prove what it computing completely?
05:59:16 <fasta> it is*
06:00:10 * gwern wonders what that means
06:00:10 <EvilTerran> fasta, i imagine you can use more general types than necessary, although you may end up having to deal with lots of potential partiality
06:00:17 <nominolo> fasta: there's Axiom
06:00:24 <nominolo> And Accept.
06:00:48 <fasta> Ok, so that's basically the undefined of Coq.
06:01:13 <nominolo> fasta: sorry, no it's called "Accept."
06:01:19 <nominolo> yeah, sort of
06:01:52 <fasta> Is it also possible to use Coq for problems which are sort of unclear, as opposed to well-specified semantics for everything known in advance?
06:02:09 <fasta> By possible, I mean not a very bad idea.
06:02:13 <byorgey> nominolo: I think you mean "Admitted." ?
06:02:35 <nominolo> byorgey: gah, yes
06:02:57 <nominolo> that was an anti-correction
06:02:58 <saml> @faq Is it also possible to use Coq for problems which are sort of unclear, as opposed to well-specified semantics for everything known in advance?
06:02:58 <lambdabot> The answer is: Yes! Haskell can do that.
06:03:09 <byorgey> hehe
06:03:44 <byorgey> fasta: your question is also sort of unclear.  can you give an example of the kind of thing you mean?
06:03:54 <RayNbow> hmm, CosmicRay managed to get his nick back? :)
06:04:22 <fasta> byorgey: I mean a domain in which specifications change every few weeks.
06:05:18 <SamB_XP_> fasta: depends how radically they change!
06:05:24 <byorgey> fasta: sure, why not?
06:05:25 <SamB_XP_> and how big
06:05:38 <byorgey> there's nothing inherent in Coq that would make it any harder to use in such a situation than any other language.
06:06:00 <SamB_XP_> coq could even guide some changes to specifications, I think ...
06:06:44 <EvilTerran> , $(let flail = do Loc file _ _ (line,col) _ <- location; [| error $ file ++ ":" ++ show line ++ ":" ++ show col ++ ": flail" |] in flail)
06:06:45 <lunabot>  luna: <interactive>:1:52: flail
06:06:49 <fasta> byorgey: It is often said that formal tools don't work well in these kinds of environments, but Ynot claimed that with Ynot this was possible, which was new for me. I am not sure whether it is Coq that makes that possible or Ynot.
06:07:35 <EvilTerran> (if it were defined elsewhere, that'd just be $flail. which'd be quite nice, imo.)
06:07:56 <byorgey> I don't see what Ynot would have to do with that.  But I'd have to read the actual claim they made, since I'm still not clear on exactly what they are claiming.
06:07:58 <SamB_XP_> fasta: well, if you use robust enough Ltacs, it tends to be less of an issue than it would otherwise be ...
06:08:09 <edwardk> fasta: ynot has been somewhat ... interesting ... to watch unfold. chlipala's tactics have made it almost usable, but they seem to have quite a ways to go before it'll be practical for more than the toy examples they have run through it so far
06:08:11 <byorgey> fasta: where did you read this claim?
06:08:37 <fasta> byorgey: in one of the Ynot papers a few months ago.
06:08:59 <fasta> byorgey: or are you referring to the claim of formal tools not working in that environment?
06:09:01 <EvilTerran> .oO (y not = undefined, surely?)
06:09:10 <EvilTerran> (= _|_, rather)
06:09:25 <edwardk> i mean the fact that they can confirm the absence of side channels in a toy little web app that uses a toy little flat list based database is cute, and i appreciate that they got it done, but maybe it is just me but i mostly fell asleep during the presentation ;)
06:09:44 <SamB_XP_> EvilTerran: It's forbidden in Coq ;-PP
06:10:08 <SamB_XP_> edwardk: how did they prove that ... what about timing?
06:10:09 <EvilTerran> SamB_XP_, so Coq => not (y not) :D
06:10:29 <SamB_XP_> EvilTerran: you can't write y ...
06:10:37 <byorgey> EvilTerran: hehe
06:10:48 <EvilTerran> SamB_XP_, i'm just making silly, tenuous puns. don't worry about it. :P
06:12:14 <EvilTerran> ( {-# LANGUAGE EvilTerranPuns #-} ...)
06:13:00 <RayNbow> EvilTerran: will that extension be available in the next major GHC release? :p
06:13:40 <SamB_XP_> EvilTerran: shouldn't that be "Set EvilTerran Puns."?
06:14:56 <dmwit> > ((==) `on` sort) "evilterran" "irrelevant"
06:14:58 <lambdabot>   True
06:16:37 <Phyx-> hmm does anyone know a build system which supports haskell and svn?
06:16:45 <Phyx-> i want to reject all non-compiling code to the main branch
06:19:51 <EvilTerran> dmwit, :)
06:20:50 <Phyx-> google said "Did you mean: dimwit"
06:23:03 <SamB_XP_> Phyx-: dmwit is the guy who just said that evilterran is irrelevant
06:23:40 <Phyx-> oh
06:24:11 <RayNbow> hmm, is there a good resource on what reflection and reification are precisely?
06:24:31 <SamB_XP_> RayNbow: I think they aren't precisely
06:25:26 <etpace_> > mconcat [Just 5, Nothing, Just 10]
06:25:27 <lambdabot>   Add a type signature
06:25:29 <Plouj> hi
06:25:32 <SamB_XP_> RayNbow: what's the context?
06:25:46 <etpace_> > mconcat [Just 5, Nothing, Just 10] :: Maybe Int
06:25:47 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
06:25:47 <lambdabot>    arising from a use of...
06:25:50 <etpace_> hmm
06:26:07 <etpace_> > const <$> Just 5 <*> Nothing <*> Just 10
06:26:09 <lambdabot>   Add a type signature
06:26:13 <Plouj> in ghci, how do I set a variable with let to just the Handle returned by openFile?
06:26:28 <SamB_XP_> Plouj: you don't use let
06:26:29 <SamB_XP_> you use <-
06:26:34 <Plouj> oh, just like that, eh
06:26:53 <SamB_XP_> handle <- openFile "/etc/passwd"
06:27:12 <RayNbow> SamB_XP_: well, in one of Oleg's paper (the one about runtime configs), reflection/reification is used for type->value and value->type
06:27:55 <RayNbow> ( http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf )
06:28:03 <etpace_> :t mconcat
06:28:05 <lambdabot> forall a. (Monoid a) => [a] -> a
06:28:19 <etpace_> :t Maybe mappend
06:28:20 <lambdabot> Not in scope: data constructor `Maybe'
06:28:48 <Saizan> etpace_: the instance is Monoid a => Monoid (Maybe a)
06:28:53 <RayNbow> @src Maybe mappend
06:28:53 <lambdabot> Source not found. My pet ferret can type better than you!
06:29:00 <etpace_> > Just (Sum 5) `mappend` Just (Sum 6)
06:29:02 <lambdabot>   Just (Sum {getSum = 11})
06:29:11 <RayNbow> oh wait
06:29:12 <etpace_> aha
06:29:18 <RayNbow> @src First mappend
06:29:18 <lambdabot> Source not found. My brain just exploded
06:29:22 <RayNbow> hmm
06:29:29 <Saizan> RayNbow: in which sense do you want more precision?
06:29:48 <etpace_> > mconcat [Just [1], Nothing, Just [3,4]]
06:29:50 <lambdabot>   Just [1,3,4]
06:30:04 <gwern> hm. 'Programmers, haddock! the life you save may be your own'
06:30:10 <etpace_> I thought a Nothing cancelled everything?
06:30:23 <Jaak> that's for sequence
06:30:37 <gwern> 'Haskellers, haddock! the life you save may be your own' <-- ah, that's better
06:30:57 <Saizan> Nothing is the identity element, it can't cancel
06:31:10 <etpace_> ah ofcourse
06:31:11 <Jaak> > sequence [Just 1, Just 2]
06:31:12 <lambdabot>   Just [1,2]
06:31:17 <Jaak> > sequence [Just 1, Nothing]
06:31:18 <lambdabot>   Nothing
06:31:19 <etpace_> thats ohne of the laws isnt it?
06:31:36 <Plouj> > contents <- openFile "path" ReadMode >> >> Data.ByteString.Lazy.hGetContents
06:31:37 <lambdabot>   <no location info>: parse error on input `>>'
06:31:41 <etpace_> mzero being an identity?
06:31:44 <Saizan> yes, mempty `mappend` x = x = x `mappend` mempty
06:31:45 <Plouj> > contents <- openFile "path" ReadMode >> Data.ByteString.Lazy.hGetContents
06:31:47 <lambdabot>   not an expression: `contents <- openFile "path" ReadMode >> Data.ByteString...
06:31:49 <Plouj> what am I doing wrong there?
06:32:13 <Saizan> etpace_: mzero is from MonadPlus, however that's an identity for mplus, too
06:32:30 <Saizan> Plouj: s/>>/>>=/
06:33:21 <quicksilver> etpace_: Nothing is a canceller for (>>)
06:33:35 <Plouj> oh, ok...
06:33:37 <quicksilver> etpace_: but an identity for `mplus` / mconcat
06:33:56 <Saizan> *mappend
06:34:00 <Plouj> thanks
06:34:25 <quicksilver> > Nothing `mplus` Just 3
06:34:27 <lambdabot>   Just 3
06:34:47 <quicksilver> Saizan: not sure what your *mappend was about.
06:35:48 <byorgey> quicksilver: you said `mplus` / mconcat, did you mean `mplus` / `mappend` ?
06:35:58 <byorgey> mconcat is for folding mappend over a list.
06:36:09 <quicksilver> no I meant mplus / msum ;)
06:36:21 <byorgey> oh, hehe, I see =)
06:36:29 <quicksilver> but thanks for explaining and pointing out where I went wrong
06:39:56 <RayNbow> Saizan: hmm, well... do I have it right if I think reification is the act of making something available as a first class citizen?  (this seems to be the definition of reification used in http://bracha.org/mirrors.pdf )
06:43:21 <byorgey> 'reification' is rather broad but usually refers to turning something into some sort of concrete representation as data.
06:43:28 * roconnor uses case for the first time in a long time
06:43:31 <byorgey> 'reflection' is the inverse.
06:44:05 <Saizan_> amusingly the concrete representation here is a type :)
06:44:24 <Twey> It's all relative
06:47:23 <quicksilver> reflection, to my mind, is giving access to some aspect of language structure from within the program
06:47:35 <quicksilver> you are *reflecting* the language (or part of it) *into* the language
06:48:04 <Leviathan> http://darktanis.mondozoo.com everything is in there
06:48:54 <quicksilver> reification, I would have said, is when you have something which doesn't exist in the language per se, and you construct a representative of it?
06:48:59 <quicksilver> but I'm less happy with the latter
06:49:29 * RayNbow scrolls up to read the messages he has missed
06:50:31 <byorgey> quicksilver: I think that's a different use of the term 'reflection'.
06:50:40 <quicksilver> Oh.
06:50:55 <byorgey> 'reflect' when used as the inverse of 'reify' isn't the same as a language's reflection capabilities.
06:51:08 <byorgey> poor terminology, IMO.
06:51:09 <quicksilver> right.
06:51:12 * quicksilver understand now.
06:54:22 <edwardk> reification is taking an abstract concept and making it manifest.the name comes from the fallacy of treating an abstraction as if it were a real thing.
06:54:51 <MarcWeber> dcoutts: Can a cabal package depend on different versions of bytestring ? Eg if executable 1 lists bytestring-1.0 but executable 2 lists bytestring-2.0 ?
06:56:13 <RayNbow> edwardk: what would be the abstract concept in Oleg's paper? A dictionary of a type being an instance of a certain class?
06:58:14 <edwardk> RayNbow: my first reading of the terms in that paper made me feel like its terminology was flipped around. that we should be reflecting a term into a type and reifying that abstraction back down into the term level.
06:59:16 <hackagebot> fclabels 0.2.0 - First class record labels (SebastiaanVisser)
07:00:01 <edwardk> later i started to see it as reifying a term into a type, by taking a previous quanitified concept (type variable) and choosing a particular representation, and exploiting the fact that you can always reflect downwards in the type tower.
07:00:02 <dcoutts> MarcWeber: no, each component in a package has to be built using the same versions, so those constraints ==1.0 && ==2.0 have no solution.
07:01:23 <MarcWeber> dcoutts: That's a nice simplification.. :-) Thank you very much for putting in that constraint.
07:01:26 <edwardk> ultimately i went with their terminology when putting together the reflection library because ken shan is probably smarter than I am and I figured they had a good reason. ;)
07:07:18 <hackagebot> jail 0.0.1 - Jailed IO monad. (SebastiaanVisser)
07:09:02 <Phyx-> i should lock down my network.. have my wifi on open atm, since the router reseted
07:09:49 <dmwit> Just set your ESSID to j32keylogger.exe or something. ;-)
07:10:14 <Twey> Hahaha
07:13:36 <Phyx-> dmwit: lol
07:21:30 <Phyx-> http://www.gamasutra.com/view/feature/4111/dirty_coding_tricks.php?print=1 hehehe
07:22:07 <dmwit> Brilliant, I think I've just shown that P = NP!
07:22:14 <quicksilver> good work
07:22:15 <dmwit> NP problems take exponential time.
07:22:25 <quicksilver> get to a safe location before you're assassinated
07:22:25 <dmwit> Computers are getting faster at an exponential rate.
07:22:32 <centrinia> I am 100% certain that P != NP
07:22:38 <quicksilver> record the proof on a microfiche and bury it under some persons skin.
07:22:57 <dmwit> Therefore, to solve an NP-complete problem, wait a constant multiple of the size of the input, then brute-force it on the new and improved computers.
07:23:01 <dmwit> DONE!
07:23:19 <dmwit> This algorithm has O(n) execution time.
07:23:38 <Tobsan> :-D
07:23:59 <Phyx-> but... you can't guarantee that computers will continue getting faster at an exponential rate.. moore's law is not really a law....
07:24:26 <centrinia> It is more of a heuristic...
07:24:54 <dmwit> Phyx-: Moore's law is SCIENCE!
07:25:07 <SamB_XP_> dmwit: so are newton's laws!
07:25:13 <SamB_XP_> doesn't mean they always work ...
07:25:57 <dmwit> I'm impressed that nobody has objected that the usual definition of NP-completeness refers to O(n) *operations*, not O(n) *time*.
07:26:08 <dmwit> must be early ;-)
07:26:24 <Phyx-> i'm just hungry
07:26:39 <Phyx-> on that note, i need to go buy a corkscrew.. or i won't be able to cook the chicken
07:26:47 <fasta> centrinia: based on what do you say that?
07:26:53 <SamB_XP_> dmwit: who cares about that detail?
07:27:02 <jfoutz> dmwit: i thought it was # of transistors per area?
07:27:03 <ksf> operations == time, it's only about scale, never about concrete times or number of operations.
07:27:25 <SamB_XP_> dmwit: anyway, even if the CPU speeds could hack it, what about storage?
07:27:37 <ksf> after all, O(1) doesn't mean "one operation that takes 1 year"
07:27:57 <mux> dmwit: that's what makes the notation useful, actually
07:27:59 <dmwit> Luckily, more transistors means more memory, too, at the same exponential rate (just with a different base).
07:28:04 <fasta> ksf: operations ?= time, because of physics.
07:28:21 <ksf> physics are irrelevant for big-O
07:28:30 <fasta> ksf: blackhole computing (etc. ) of which some people think it is impossible.
07:28:31 <ksf> it's a measure of complexity.
07:28:41 <SamB_XP_> dmwit: uh
07:28:43 <dmwit> ksf: operations != time, because the rate of operations could increase as the computation happens (as in this example)
07:28:50 <fasta> ksf: I wasn't saying anything about Big Oh.
07:28:58 <SamB_XP_> dmwit: but the memory -- does it's latency scale with the CPU speed?
07:29:07 <SamB_XP_> inversely
07:29:09 <ksf> ...and I was saying operations == time in the context of big O.
07:29:13 <SamB_XP_> ?
07:29:15 <ksf> ...both are irrelevant.
07:29:34 <dmwit> SamB_XP_: latency isn't important, only bandwidth
07:29:36 <fasta> ksf: that makes no sense.
07:29:45 <ksf> dmwit> I'm impressed that nobody has objected that the usual definition of NP-completeness refers to O(n) *operations*, not O(n) *time*.
07:29:47 <SamB_XP_> dmwit: it usually is
07:29:51 <SamB_XP_> but that too ;-)
07:29:58 <dmwit> SamB_XP_: deeper pipelining ;-)
07:30:11 <dmwit> (but yeah, I'm aware there are many, many problems with this proof =)
07:30:23 <SamB_XP_> you can only figure out what you want to read so soon before you need to read it!
07:30:36 <ksf> time as seen from the viewpoint of a certain electron or the northbridge?
07:30:40 <dmwit> ksf: I stand by that claim, too.  It's *wrong* to define big-O in terms of time.
07:31:10 <dmwit> err
07:31:21 <dmwit> It's wrong to use big-Oh analysis on time, rather.
07:31:32 <ksf> it's a measure of complexity.
07:31:34 <SamB_XP_> ksf: now you're going to go all relativistic oun our asses?
07:31:51 <SamB_XP_> big-oh can be used for any function
07:32:05 <dmwit> Yeah, hence my correction.
07:32:07 <SamB_XP_> well, any realish function
07:32:15 <dmwit> You don't talk about any units when defining big-O itself. =)
07:32:23 <SamB_XP_> and I don't see why you can't use big-oh analysis on time ...
07:32:40 <SamB_XP_> there's a heck of a lot of applications for big-oh!
07:33:12 <SamB_XP_> not *all* of them relate to computer science
07:33:30 <fasta> Yes, you could analyze an algorithm and say that the number of sweat-drops used to analyze the algorithm is O(1).
07:33:56 <sohum> is it possible to get cabal to install different versions of a package side by side?
07:34:02 <fasta> But most of the time, people refer to either space or time, but yes, the notation itself does not state whether it is about time or space or whatever.
07:34:24 <ksf> you could also analyse a pin and say that O(2^observers) angels dance on it
07:34:26 <byorgey> sohum: sure.  just  'cabal install package-4.3.6' or whatever.
07:35:10 <maltem> #haskell discovered real-valued functions :o
07:35:30 <sohum> in fact, though the notation is commonly used for worst case asymptotic behaviour, that's not a necessity either.
07:35:38 <sohum> byorgey: aah, thanks!
07:36:12 <ksf> if you're serious, you're listing worst case, best case, and average case seperately, anyway.
07:36:16 <int-e> fasta: it also occurs in calculus with a different implicit limit. (namely, in truncated power series: ln(1+x) = x + O(x^2))
07:36:41 <fasta> int-e: I know, that's something which Knuth popularized, not?
07:37:02 <ksf> ...I don't mean average case. I mean thinking about how often you need the worst case, and how often the best case.
07:37:30 <quicksilver> int-e: and in approximate solutions to systems of differential equations
07:37:39 <quicksilver> int-e: so, therefore in most branches of applied mathematics
07:37:39 <dmwit> maltem: Oh, go on, we've had CReal for a while!
07:37:43 <dmwit> > pi :: CReal
07:37:43 <fasta> For all those that believe P!=NP, please disprove: http://www.merlins-world.de/
07:37:44 <lambdabot>   3.1415926535897932384626433832795028841972
07:38:09 <fasta> (and contact me when you find the flaw)
07:38:52 <opqdonut> "NP-complete problems are known to require an exponential number of computational steps"
07:38:55 <lilac> fasta: it's easy. exactly solving an LP is in NP
07:38:57 <opqdonut> there's one flaw :)
07:38:59 <lilac> fasta: but it's not in P
07:39:08 <fasta> lilac: you did not read the paper.
07:39:18 <fasta> lilac: the guy who wrote it is not stupid.
07:39:22 <EvilTerran> some LPs can be solved in P
07:39:28 <EvilTerran> *families of LPs
07:39:31 <fasta> ILP cannot.
07:39:33 <fasta> LP can.
07:39:44 <lilac> fasta: yes i did, a few months ago
07:39:49 <fasta> Well, that's the current assumption.
07:39:54 <mux> fasta: there's one paper like this every year, at the very least
07:40:01 <lilac> LP can be solved in a polynomial number of steps, where each step is an exact real operation
07:40:15 <EvilTerran> lilac, i sense a "gotcha" in that "where"
07:40:16 <fasta> lilac: ok, so, then I am interested. Continue :)
07:40:43 <opqdonut> ah, he's avoiding integer constraints to some degree
07:40:47 <opqdonut> clever
07:40:56 * EvilTerran thought it was "exact rational operation", but is probably wrong
07:41:11 <fasta> lilac: ?
07:41:11 <lilac> EvilTerran: right, that suffices if your problem only involves rations
07:41:14 <lilac> *rationals
07:42:14 <EvilTerran> ah, of course, if there's irrationals in the spec, rational operations clearly aren't gonna work
07:42:21 <lilac> suppose you're working in rationals. you can construct a class of problems where the magnitude of the denominator of the optimum grows superlinearly in the size of the problem
07:42:58 <lilac> i've yet to see a proof that LP is in P which addresses this
07:43:17 <fasta> lilac: and why would his numbers have to be possibly irrational? I know he doesn't explicitly prove that they are not, but who says that's a fundamental problem with this approach?
07:43:21 <lilac> but there are several P=NP "proofs" which show that LP is NP-complete
07:44:11 <lilac> fasta: nothing has to be irrational.
07:44:35 * EvilTerran 's linear programming lecturer claimed that LP was in P. somehow, i didn't trust him on that.
07:44:36 <fasta> lilac: ok, so then what do LP algorithms solve in polynomial time?
07:44:43 <fasta> EvilTerran: mine too.
07:44:43 <lilac> fasta: but the LP has to be solved /exactly/, not approximately, as is done in current LP implementations
07:45:02 <EvilTerran> lilac's "class of problems where the magnitude of the denominator of the optimum grows superlinearly in the size of the problem" seems to explain my doubts perfectly
07:45:29 <SamB_XP_> what's LP here?
07:45:34 <opqdonut> linear programming
07:45:38 <opqdonut> aka linear optimization
07:45:38 <SamB_XP_> okay
07:45:54 <fasta> lilac: I must admit that what you say makes sense.
07:45:55 <EvilTerran> fasta, i think it's that you can solve rational LPs approximately in polynomial time, or exactly in a polynomial number of rational operations
07:46:04 <SamB_XP_> that, and lineprinter, are my usual expansions of that ...
07:46:14 <lilac> EvilTerran: yes, that's exactly my theory.
07:46:46 <lilac> and either I'm right that LP is not in P, or the /constructive/ reduction of TSP to LP doesn't work (which seems unlikely), or P = NP
07:46:47 <fasta> lilac: so, the author makes the same "mistake" as us. By assuming LP is in P.
07:47:02 <EvilTerran> (the latter implying the former, i guess, given the existence of fixed-length approximation representations of rationals)
07:47:06 <lilac> fasta: right
07:47:08 <fasta> lilac: how much time did you spend on analyzing the paper?
07:47:31 <lilac> fasta: i spent a couple of hours reading it through, trying to understand it, and checking it was sound
07:47:41 <lilac> as far as i can tell it seems to be a correct reduction.
07:48:02 <fasta> lilac: I would say I am reasonably sure of the assertion that LP in P => P = NP. I spend significantly more time on it to understand it, but that was because some of the concepts, like superpositions were not known to me.
07:48:39 <lilac> i'm not certain the paper is right, but the fact that it's been implemented and actually works helps my confidence ;-)
07:49:04 <fasta> I read large of garbage on P vs NP, but this was quality work. Too bad about the LP in P issue. I should investigate that more later.
07:49:20 <fasta> lots of*
07:49:41 <quicksilver> what lilac says makes sense to me, but I haven't thought about it hard. I'm surprised this is not more well-known/discussed.
07:50:28 <fasta> O(n4L) arithmetic operations on numbers with O(L) digits.
07:50:35 <fasta> So, there we have the catch.
07:51:29 <fasta> From http://en.wikipedia.org/wiki/Linear_programming, actually that's not true.
07:51:57 <fasta> lilac: he doesn't say that he needs to create very large numbers anywhere, does he?
07:52:15 <fasta> Because L is the number of input bits, not those of the final answer.
07:52:29 <quicksilver> http://scholar.google.com/scholar?cluster=11499465048427845142&hl=en
07:52:33 <quicksilver> ^^ another rebuttal, I think
07:52:38 <quicksilver> on diferent grounds.
07:52:38 <EvilTerran> fasta, pathological cases have a knack of hiding where you least expect them
07:54:02 <fasta> EvilTerran: that might be true, but either those algorithm have wrong time-complexity analyses or the P=NP paper is wrong or P=NP. Certainly, interesting to find out which one is true.
07:54:15 <EvilTerran> indeed, it's definitely interesting
07:55:38 <jfoutz> if you take rational arithmetic as O(1) i bet it's true, but that makes fib(n) O(1) as well dosen't it?
07:56:16 <quicksilver> you can encode an awful lot into rational arithmetic :)
07:56:43 <quicksilver> I have a suspicion if you take rational arithmetic to be O(1) you can reduce all of P to O(n)
07:57:07 <lilac> quicksilver: it looks like that paper is a more rigorous statement of essentially the same thing
07:57:37 <jfoutz> i only vaguely recall godel, but didn't he embed arbitrary functions in polynomials?
07:58:20 <fasta> quicksilver: interesting link
07:58:23 <lilac> specifically, that LP cannot be solved /exactly/ in polynomial space (with the observation that it doesn't need to be solved exactly for LP to be considered in P, but does need to be solved exactly in order to use its results in MERLIN i think)
07:59:08 <quicksilver> fasta: it doesn't seem to be peer reviewed or published anywhere notable though
07:59:33 <fasta> quicksilver: I haven't read it yet, to determine the actual value. I just skimmed the first page.
07:59:51 <fasta> quicksilver: I think he has produced more debunking of P=NP that were valid.
08:00:18 * quicksilver fails to parse fasta's last comment.
08:00:26 <quicksilver> I skimmed the first page and read the conclusion.
08:00:44 <quicksilver> but I can't vouch for it ;)
08:01:08 <fasta> quicksilver: The author of that paper wrote more debunkings of articles "proving" P=NP.
08:02:58 <jfoutz> fasta: are you implying that the author goes looking for P=NP claims, and found one that while false, produces a useful approximation?
08:03:56 <fasta> jfoutz: no, I just recall a guy who went over this papers and wrote papers showing counter examples. I think this is the same guy, I could be wrong.
08:03:59 <nominolo> @seen tibbe
08:03:59 <lambdabot> I saw tibbe leaving #haskell, #ghc and #haskell-in-depth 1h 10m 22s ago, and .
08:04:23 <jfoutz> i see.
08:04:34 <Phyx-> are you guys still on about that crackpot P=NP theory?? :P
08:05:09 <fasta> Phyx-: it's not crackpot when it's not obvious were the problem is.
08:05:14 <fasta> where*
08:05:20 <sohum> hm. inf-haskell breaks because it's running from ~/.cabal instead of the current directory. what's the best solution for this?
08:09:46 <int-e> sohum: use the generated Paths_inf_haskell module to find out the installation location?
08:09:53 <Taejo> @where catMaybes
08:09:54 <lambdabot> I know nothing about catmaybes.
08:09:57 <Taejo> @where catMaybe
08:09:58 <lambdabot> I know nothing about catmaybe.
08:10:02 <Taejo> @hoogle catMaybe
08:10:03 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:10:37 <sohum> int-e: is there documentation on this somewhere?
08:10:48 <quicksilver> sohum: it's a silly bug in inf-haskell
08:10:57 <quicksilver> sohum: it climbs up the directory tree looking for a .cabal file
08:11:05 <int-e> oh wait, inf-haskell is some emacs thing.
08:11:06 <int-e> nm
08:11:20 <quicksilver> either disable the (mis)feature, or touch a foo.cabal file in the root dir of your project
08:12:02 <sohum> quicksilver: aaah, cool, fair enough
08:12:07 <sohum> int-e: heh, np
08:12:14 <quicksilver> inferior-haskell-find-project-root
08:12:22 <quicksilver> customise it to nil (instead of t)
08:12:49 <Phyx-_> fasta: i call your theory crackpot and my inet drops me
08:13:13 <fasta> Phyx-: I have powerful friends.
08:13:24 <Phyx-> heheh
08:13:51 <Phyx-> good to have friends in high places
08:13:57 <quicksilver> low places?
08:15:12 <sohum> quicksilver: hm, touching bla.cabal didn't work, but disabling the feature did. I'm happy with that, thanks!
08:19:54 <andrewz> how involved is writing a socks proxy ?
08:25:39 <andrewz> or just something that relays arbitrary tcp traffic
08:26:43 <Twey> Not so hard, I would think
08:30:01 <nominolo> sohum: what is inf-haskell?
08:30:29 <jfoutz> nominolo: inferior haskell mode in emacs
08:30:35 <andrewz> maybe something like this?
08:30:36 <andrewz> http://sequence.complete.org/node/258
08:30:58 <nominolo> jfoutz: ah, the bug is that ~/.cabal is a cabal file
08:31:19 <nominolo> the search regexp in find-project-root is wrong
08:31:32 <dcoutts> have they still not fixed that?
08:31:40 <nominolo> er, *that it thinks that ~/.cabal is a cabal file
08:31:45 <dcoutts> it's been well over a year now
08:31:55 <quicksilver> I think it has been fixed, dcoutts
08:32:00 <nominolo> dcoutts: well, it's a CVS repo
08:32:04 <quicksilver> but the questioner is using an old version.
08:32:09 <nominolo> makes contributing annoying
08:34:04 <jfoutz> andrewz: that's not really a proxy, it's a good start at a server though. are you trying to do something special?
08:34:33 <PupenoG> Hello.
08:35:19 <PupenoG> Is there some Haskell interpreter on the web that I could use?
08:35:29 <Twey> > "Yes"
08:35:30 <lambdabot>   "Yes"
08:35:32 <Taejo> :q
08:35:37 <pr> :)
08:35:39 <Taejo> sorry, wrong window
08:35:43 <quicksilver> you can use lambdabot here (e.g. in personal messages)
08:35:48 <quicksilver> or you can use codepad.org
08:35:49 <PupenoG> thanks
08:36:01 <Berengal> > text "\msg me for a good time"
08:36:03 <lambdabot>   <no location info>:
08:36:03 <lambdabot>      lexical error in string/character literal at chara...
08:36:07 <Berengal> :(
08:36:13 <jmelesky> lambdabot is ghc-based, right?
08:36:20 <Taejo> jmelesky: yes
08:36:24 <pr> > text "/mesg me for a good time"
08:36:25 <lambdabot>   /mesg me for a good time
08:36:32 <pr> typo :(
08:36:33 <quicksilver> http://codepad.org/lKbDfolh
08:36:47 <quicksilver> jmelesky: yes.
08:37:00 <andrewz> jfoutz: yes, write a proxy server that runs on another computer that i can forward traffic through
08:37:07 <Twey> pr: 1) /msg is a client command; the IRC command would be PRIVMSG pr :me for a good time
08:37:13 <andrewz> specifically emails
08:37:14 <jmelesky> codepad is hugs-based, fwiw
08:37:20 <pr> Twey: i know that.
08:37:25 <Twey> Oh, okay.  :)
08:41:51 <jfoutz> andrewz: it's easy to make a relay for a specific thing, like irc. implementing a socks proxy looks hard to me, but may not be a big deal for you. you might think about an iptunnel between the two machines if you want to forward everything, or large fractons of your network traffic.
08:43:32 <quicksilver> jmelesky: really? that seems surprising.
08:43:34 <Phyx-> does anyone know a build system, CI system for haskell? with svn as a backend?
08:43:34 <quicksilver> jmelesky: I wonder why.
08:45:29 <jmelesky> quicksilver: don't know offhand. maybe easier to get working in the vm?
08:45:37 <etpace_> > foldl (>>=) (return 0) $ map const [Just 5, Just 6, Nothing, Just 7]
08:45:38 <lambdabot>   Nothing
08:46:03 <etpace_> > sequence [Just 5, Just 6, Nothing, Just 7]
08:46:05 <lambdabot>   Nothing
08:46:11 <jmelesky> it's also using the "-98" flag to ensure only Haskell 98-compliant stuff works
08:46:41 <nominolo> isn't +98 haskell98?
08:46:43 <andrewz> quicksilver: jfoutz http://en.wikipedia.org/wiki/SOCKS#SOCKS_4_protocol ya looks tough :\
08:46:48 <andrewz> thanks for the ip tunnel thing
08:46:54 <nominolo> and -98 is beyound haskell'98?
08:47:09 <fasta> Hugs without flags is 98.
08:47:13 <jmelesky> hm
08:47:34 <jmelesky> my bad, you're right
08:47:53 <quicksilver> it's nto really a VM, is it?
08:47:55 <jmelesky> so it's allowing hugs-specific code
08:47:59 <quicksilver> it's a chrooted ptraced wotsit
08:48:38 <jmelesky> from the 'about' page: "The supervisor processes run on virtual machines, which are firewalled such that they are incapable of making outgoing connections."
08:49:08 <dsdeiz> what does '<-' means?
08:49:29 <jmelesky> the site seems to be approaching the problem with an appropriate level of paranoia for arbitrary code execution
08:49:38 <quicksilver> jmelesky: they're running *inside* VMs, sure
08:49:49 <quicksilver> but the actual clever bit - geordi - is not a VM
08:49:58 <Trinithis> What do I do when multiple (already installed) packages conflict? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8733#a8733
08:49:58 <quicksilver> it's a clever sandboxing trick
08:50:17 <jmelesky> hm. again, you're right: "Compilers and final executables are both executed in a chroot jail, with strict resource limits."
08:50:28 * jmelesky fails at facts today
08:50:48 <dsdeiz> anyone? :D
08:51:01 <Trinithis> It extracts a value from a monad
08:51:12 <lilac> dsdeiz: it's syntax, and its meaning is context-dependent.
08:51:13 <Trinithis> x <- m === m >>= \x ->
08:51:25 <Trinithis> when in  a do block
08:51:40 <lilac> it means roughly the same thing in a list comprehension, too
08:51:56 <lilac> but the translation is slightly less straightforward
08:52:13 <roconnor> very very very losely  x <- foo is kinda vaguely like x := foo
08:52:15 <quicksilver> jmelesky: it's cleverer than that. It intercepts all syscalls
08:52:23 <quicksilver> jmelesky: and only permits the ones that are safe.
08:52:32 <quicksilver> jmelesky: it was written to make it possible to write a C++ evaluator.
08:52:47 <quicksilver> jmelesky: by Eelis who you can spot sitting in a corner of the channel not saying anything.
08:52:52 <quicksilver> jmelesky: it's written in haskell, of course :)
08:53:06 <jmelesky> but the webapp is written in python...
08:53:28 <quicksilver> right.
08:53:36 <quicksilver> codepad was I think written by someone else entirely.
08:53:45 <quicksilver> but it uses the underlying technology of geordi to work.
08:53:56 <Twey> quicksilver: Sorry, what's your country of origin / native language/dialect?
08:54:06 <roconnor> when foo is a Kleisli function
08:54:10 <quicksilver> UK/english/as spoken by the queen, sir!
08:54:16 <Twey> Huh
08:54:21 <quicksilver> Twey: did I say something strange?
08:54:24 <lilac> dsdeiz: it's used in pattern guards (a GHC extension) too: "foo x | Just y <- lookup x xs = ..." means "foo x | isJust (lookup x xs) = let Just y = lookup x xs in ..." only with the two calls to lookup shared
08:54:35 <quicksilver> wouldn't be that surprising, my thinking and typing are both suspect.
08:54:39 <Twey> No, I'm just interested as to the prevalence of the use of â€˜whoâ€™ in the place of â€˜whomâ€™.
08:54:49 <Twey> I have a minor disagreement with Cale over it.
08:55:05 <Trinithis> Isn't who a direct object, while whom isnt?
08:55:11 <Twey> Trinithis: Other way around
08:55:14 <quicksilver> you're right. "...whom you can spot"
08:55:15 <Trinithis> right
08:55:19 * quicksilver apologises.
08:55:26 <Badger> Twey: "whom you can spot"?
08:55:33 <Badger> oops
08:55:38 <Badger> beaten to it
08:55:42 <Badger> that seems odd though
08:55:46 <Twey> Trinithis: Or rather, in the objective case.  English uses objective for just about everything except subjects and complements.
08:56:19 <Trinithis> Where I come from, whom is almost never used
08:56:20 <Twey> Anyway, I've drawn the channel off a nice, relevant, and productive subject.  Sorry.  Carry on.  â˜»
08:56:24 <Trinithis> I only use it in writing
08:56:38 <lilac> i think i say whomsoever more than whom ;-)
08:56:54 <ezyang> IRC? Productive? No way...
08:56:59 <andrewz> jfoutz: hmmm maybe ill translate this.  unless tehres an easier way jsut for email http://softlayer.dl.sourceforge.net/project/ssspl/ssspl/sss.pl%20v0.1/sss.pl
08:57:06 <Berengal> whom cares...
08:57:10 <Trinithis> lol
08:59:13 <andrewz> is there some way to use perl code via a api?
08:59:48 <Berengal> Googling for CReal is not very productive...
09:00:02 <quicksilver> Berengal: the package is called 'number' or 'numbers'
09:00:06 <quicksilver> Berengal: if that's what you wanted to know
09:00:16 <dsdeiz> heh, too advanced for me. i'll start with the basics again.. ^_^
09:00:18 <Berengal> CReal numeric isn't either, and for some reason brings up ice cream a lot...
09:00:42 <Trinithis> cereal
09:00:45 <Berengal> CReal numeric floating brings up "C for dummies" as its first hit, but the excerpts are again about ice cream
09:00:56 <Berengal> quicksilver, I'm just googling for random terms
09:01:00 <Twey> Hahaha
09:01:04 <Twey> Ice-creamâ€¦
09:01:13 * Phyx- just figured out how a corkscrew opener works... this thing was even more complicated than learning monads
09:01:30 <Twey> Hahaha
09:02:15 <Berengal> Phyx-, corkscrew openers are easy. They're like nuclear missiles with a twist: You can launch them, but they have to land in the ocean unless your apples will turn into burritos
09:02:25 <quicksilver> Berengal++
09:02:30 <Berengal> woopwoopwoop!
09:03:26 <Phyx-> Berengal: hehehe
09:04:55 <jmelesky> andrewz: not to my knowledge, though there is a bridge like that for ocaml. it might be translatable
09:05:18 <andrewz> what about pugs?
09:07:40 <dons> andrewz: there's a perl5 binding library
09:07:53 <dons> look on hackage.haskell.org
09:08:04 <andrewz> dons: this one http://hackage.haskell.org/package/HsPerl5 ?
09:08:23 <dons> I think so.
09:08:32 <dons> you need to call some Perl module from Haskell?
09:08:38 <jfoutz> andrewz: if you're doing it because it's intersting implementing socks would be cool. if you're doing it because you need to get something working, you should check out the standard vpn stuff.
09:10:07 <andrewz> dons: thanks.  how well does it work from your knowledge?  i need to use something like http://softlayer.dl.sourceforge.net/project/ssspl/ssspl/sss.pl%20v0.1/sss.pl (or if you know a socks thing in haskell thatd be cool too)
09:10:44 <andrewz> jfoutz: ok ill look at that thanks
09:12:22 <jfoutz> andrewz: http://www.stunnel.org/examples/
09:13:21 <jfoutz> but if it's for fun, and learning about haskell networking you should totally check out dons's http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:13:27 <jfoutz> cause it's neato.
09:14:27 <Berengal> Network programming is fun
09:14:28 <andrewz> awesome ok
09:14:30 <Berengal> Especially with STM
09:14:31 <jfoutz> and maybe this, http://www.haskell.org/haskellwiki/Implement_a_chat_server
09:17:53 <jfoutz> those two have all the parts you'd need to implement a telnet server and client. figure out ssl, and you have ssh. it's not to much more work to start implementing real protocols on top of those, so you could make, say, an imap server and a mail client.
09:19:43 * maltem always wanted to write the mail client that sucks even less, but merely recognized how difficult that would be
09:20:27 <andrewz> jfoutz: neat ill try that.  then my haskell program could send mail without them having some sort of speparate mailserver installed?
09:22:39 <jfoutz> andrewz: that's possible. gmail provides free smtp and pop/imap accounts. if you modify that irc bot to speak smtp and pop/imap instead of irc, you'd be all set.
09:23:14 <quicksilver> you *can* speak SMTP directly and send mail yourself.
09:23:25 <quicksilver> it's not advisable for several reasons
09:23:35 <doublethink_work> sanity? :p
09:23:39 <quicksilver> (1) you might get a temporary failure and you might not be aroudn in 4 hours to resend
09:23:49 <quicksilver> (2) you are significantly more likely to be treated as spam
09:24:02 <quicksilver> (3) well, yes, implementing SMTP fully and correctly isn't that easy
09:24:23 * jfoutz browses haskell.org with telnet and a lot of GET http:// cut and pasting.
09:24:28 <andrewz> quicksilver: ok thanks alot for the info
09:25:32 <andrewz> quicksilver: although happs says it has a smtp server, could i jsut use that?
09:25:38 <quicksilver> undoubtedly.
09:25:50 <quicksilver> but you would need an 'always-on, always-on-the-net' computer for it to be a useful mail server
09:26:02 <quicksilver> and if you have one of those, it might be easier just to run a real mail server
09:26:07 <quicksilver> (postfix? exim? they're both free)
09:26:20 <andrewz> quicksilver: ya i do :) i would preferr it run from the haskell program tho
09:26:22 <andrewz> for what im doing
09:26:27 <andrewz> sweet! ill use that
09:29:54 <hackagebot> TrieMap 0.0.1.1 - An implementation of generalized tries with sophisticated map type inference. (LouisWasserman)
09:30:03 <dons> nominolo: do you know why scion takes such an effort to link?
09:30:15 <nominolo> dons: ghc api
09:30:24 <dons> ah yes. that would do it :)
09:30:39 <nominolo> I guess dynamic libs would help
09:30:59 <dons> shrug
09:31:27 <mercury^> dons: You are quite familiar with low level optimising, right? Could you have a look at this please and say where, apart from the return, it allocates: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8721
09:31:43 <nominolo> dons: ok, OTOH, the ghc api exposes almost all of GHC.  This might hurt performance quite a bit.
09:32:08 <dons> mercury^: have you profiled?
09:32:29 <mercury^> dons: I know that it does a lot of unneeded allocation if that's what you mean, yes.
09:32:42 <mercury^> dons: but I don't know why and I cannot tell from the core either.
09:32:47 <dons> well, no, i mean, if you profile, it will tell you what it is allocating
09:32:58 <dons> all those boxed Ints are allocated.
09:33:12 <dons> its allocating return values
09:33:21 <nominolo> mercury^: every constructor is an allocation
09:33:25 <mercury^> The return is marginal.
09:33:28 <dons> and booleans
09:33:54 <mercury^> Huh, the Booleans from something like GHC.Prim.==# are allocated?
09:34:02 <dons> it doesn't look too bad though. but note there's quite a few non-strict input arguments
09:34:15 <mercury^> dons: none of the non-strict arguments is used.
09:34:23 <mercury^> I don't know why GHC put them there.
09:34:48 <nominolo> mercury^: no, this is an allocation GHC.Types.I# sc6_s2Y0
09:35:21 <mercury^> nominolo: that's the return.
09:35:22 <dons> right. you'll want to massage the source until those I# disappear
09:35:33 <dons> typically by making the use strict
09:35:47 <nominolo> mercury^: that too: (# s2#_a2pW, (GHC.Word.W32# sc5_s2XZ, GHC.Types.I# sc17_s2ZD) #) ?
09:35:58 <dons> what's the general problem though? is it not fast enough? or allocates too much?
09:36:17 <mercury^> dons: well, it shouldn't allocate at all (except for the return maybe), but it does.
09:36:40 <mercury^> And all that allocation sums up to 4.6 GB in total, which I would like to avoid if possible.
09:36:49 <dons> right, those constructors as you see. there's a few I# and W#
09:36:58 <dons> that seems excessive.
09:37:13 * quicksilver imagines mercury^ is calling the function more than once :)
09:37:34 <mercury^> Yep, it's the innermost loop.
09:37:49 <mercury^> It's for a shootout submission btw.
09:37:53 <dons> you can always rewrite bits of that core directly in your haskell source
09:37:59 <dons> then see if it makes any difference
09:38:08 <dons> but generally a bang here or there will help knock out those allocations
09:38:13 <nominolo> mercury^: you can use +RTS -hT to see which constructors take most of the heap.  Doesn't require profiling to be turned on
09:38:52 <nominolo> you'll get a .hp file and can use hp2ps on that
09:39:27 <quicksilver> of course -hT shows you more about *retained* constructors
09:39:40 <quicksilver> whilst mercury^ is, I think, concerned more with the ephemeral ones
09:39:45 <quicksilver> it might be a clue, though.
09:39:49 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8739#a8739 -- this is the source
09:40:31 <mercury^> Changing (t,br) <- to (!t,!br) <- didn't get rid of the return constructors.
09:40:36 <nominolo> quicksilver: oh, true.  good point
09:40:39 <mercury^> But they are not *that* important anyway.
09:40:47 <nominolo> mercury^: use strict tuples
09:40:50 <mercury^> There must be a lot of allocation apart from the return.
09:41:13 <nominolo> i.e., roll a custom one: data Pair a b = Pair !a !b
09:41:25 <dons> and make it monomorphic
09:41:33 <copumpkin> or (# , #) tuples :P
09:41:33 <nominolo> or better specialise and use {-# UNPACK #-} and -funbox-strict-fields
09:41:48 <andrewz> anyone know where i could find an example of happstack being used as a mailserver?
09:41:52 <nominolo> copumpkin: yeah.  Though that cannot be tested in GHCi
09:41:59 <copumpkin> ah
09:42:03 <copumpkin> never tried those things in ghci
09:42:22 <nominolo> copumpkin: I just noticed that when trying to load ghci using scion
09:42:25 <nominolo> er, GHC
09:46:09 <copumpkin> ah
09:46:34 <andrewz> im not seeing happs-smtp here! :( http://happstack.com/docs/0.2/
09:47:09 <copumpkin> why would there be?
09:48:07 <andrewz> copumpkin: its on the front page of happstacks site
09:48:13 <andrewz> that there is happs-smtp
09:48:28 <andrewz> looking for where to download/docs or examples
09:49:01 <andrewz> OH Happstack, has already cut out things like the SMTP & DNS packages.
09:49:03 <andrewz> thats why
09:49:15 <andrewz> so is it separate now or orphaned?
09:49:40 <copumpkin> I guess you could still grab it from the happs darcs repo
09:51:38 <mercury^> nominolo: well, using {-# UNPACK #-} got rid of the constructors there, but that accounted for less than 1% of the allocation done by that action.
09:51:47 <mercury^> I don't see where the rest is happening.
09:52:29 <copumpkin> add cost centers?
09:52:45 <mercury^> copumpkin: where do you suggest one?
09:53:22 <bos> mercury^: it would be easier to read the haskell than the core ;-)
09:53:25 <copumpkin> no clue :)
09:53:29 <quicksilver> bos: he posted the haskell too
09:53:36 <quicksilver> bos: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8739#a8739
09:54:15 <dons> mercury^: so you've profiled now?
09:54:18 <dons> done the heap profiling?
09:54:43 <mercury^> What would that tell me?
09:54:51 <dons> which and where the allocations are
09:54:59 <dons> we have tools for solving this problem :)
09:55:00 <path[l]_> hi
09:55:16 <copumpkin> there's also that live profiling project, but I'm not sure what stage that's at
09:55:45 <bos> I think the live profiling stuff just reads heap profile files incrementally.
09:55:45 <mercury^> dons: -hy?
09:56:11 <path[l]_> heh other people with performance issues huh
09:56:36 <jmcarthur_work> path[l], still on the partition problem thing?
09:59:07 <mercury^> dons: ok, it seems ARR_WORDS is the problem.
09:59:11 <mercury^> Whatever that is...
09:59:46 <mmorrow> that's what those UArrays are using
10:00:00 <mmorrow> ByteArray#
10:00:42 <mmorrow> MutableByteArray# i guess
10:01:29 <mercury^> So writeWord8Array does allocations?
10:01:29 <path[l]_> jmcarthur  yep
10:01:41 <mercury^> I don't understand why and what for...
10:01:51 <path[l]_> jmcarthur: so far all i got was that I spent 30% of my time in gc
10:01:52 <mmorrow> mercury^: what do you mean that ARR_WORDS is the problem?
10:02:10 <mercury^> mmorrow: well, it fills the graph created with -hy.
10:02:26 <mercury^> dons said that would identify what is causing the allocations.
10:03:02 <hackagebot> irc 0.4.4.2 - A small library for parsing IRC messages. (TrevorElliott)
10:03:12 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8740#a8740
10:03:24 <ksf> ...someone link that somewhere where people will find it.
10:03:25 <path[l]_> Im guessing haskells immutable data structures are my problem. But even with that 30% I guess ... I always thought like a compiled statically typed language would be 10 times faster than ruby. Since ruby1.9 has been calibrated as 20 times slower than C
10:03:56 <kynky> well ruby has vms now yarv etc
10:04:47 <kynky> also depends on the benchmark i guess, haskell damn quick for creating threads
10:04:49 <james_britt> kynky: Ruby has the JVM, too, via JRuby
10:05:20 <ksf> immutable data isn't the problem.
10:05:36 <ksf> it's holding in to old data although you don't need to.
10:05:42 <ksf> *on to
10:05:46 <sm> hey.. irc
10:06:45 <ksf> is trevor conal's brother?
10:07:13 <path[l]_> ksf : Im not holding onto data, but I mean I keep allocating new space
10:07:18 <path[l]_> instead of reusing it
10:07:25 <ksf> ...then you're holding on to it.
10:07:31 <path[l]_> so the allocate destroy cycle might be hurting me
10:07:45 <ksf> as ghc would re-use stuff if it's out of usage fast enough.
10:07:48 <mercury^> Oh, nvm. That heap profile is pretty useless I just realised.
10:07:51 <ksf> that's all black magic, though.
10:07:56 <path[l]_> oh really? I didnt know that
10:07:57 <path[l]_> hmm
10:08:09 <path[l]_> I forced my call to be tail recursive and strict
10:08:10 <SamB> ksf: not stuff -- it copies *everything* into a new space ...
10:08:14 <mercury^> It only says how much data was in use at any moment, that doesn't really tell me what type was allocated a lot.
10:08:38 <ksf> ...where "new space" might be just the space that was just freed.
10:08:46 <SamB> mercury^: yeah, you probably want to at least profile by info pointer ;-)
10:08:51 <ksf> some of ghc's tight loops are really, really impressive.
10:09:29 <SamB> ksf: just freed?
10:09:32 <path[l]_> is anyone here interested in taking a quick look at the code to see if there are any obvious improvements?
10:09:55 <SamB> ksf: it can't free anything until it copies *everything* out of the old space!
10:09:56 <ksf> path[l]_, I suggest waiting for dons to show up and apply for an initiation into the order of black-art haskell0rz.
10:10:03 <path[l]_> lol
10:10:04 <SamB> and I'm under the impression that it still does not actually free it
10:10:06 <path[l]_> when do they show up
10:10:14 <path[l]_> I always seem to be asleep or at work when they do
10:10:32 <ksf> SamB, it's hard to copy something from a register to itself...
10:11:06 <SamB> ksf: oh
10:11:11 <SamB> I thought you meant actual objects
10:11:20 <ksf> well yes I do mean them.
10:11:32 <ksf> they get crunched down drastically during compilation, though.
10:11:44 <SamB> ksf: only when it can unbox them
10:11:47 <ksf> ...preserving semantics, getting rid of actual copying.
10:11:52 <mercury^> SamB: you mean I messed up the instructions?
10:12:18 <ksf> ...which asks the question: path[l]_, how do you like the core ghc produces?
10:12:26 <SamB> wait, since when does write*Array involve allocation?
10:12:28 <mercury^> I profiled with both -hT and -hy, but I cannot see how either is relevant.
10:12:31 <ksf> strictness and lazyness are spelled out there.
10:12:35 <path[l]_> huh? the core?
10:12:40 <mercury^> SamB: well, that's what I'm asking myself.
10:12:42 <ksf> cabal install ghc-core
10:13:02 <path[l]_> I dunno what that does =p. I installed the ghc mac binary or something
10:13:05 <dons> path[l]_: your ghc -O2 haskell should be between 10 and 1000x faster than your ruby, fwiw
10:13:08 <mercury^> The whole action only writes to arrays, reads from arrays and adds/multiplies/rems the values.
10:13:09 <SamB> mercury^: did you build with profiling?
10:13:14 <mercury^> SamB: yes.
10:13:15 <SamB> okay.
10:13:23 <dons> mercury^: are you allocating the array multiple times?
10:13:28 <mercury^> dons: no.
10:13:34 <dons> so you are updating in place in ST?
10:13:43 <SamB> I asked because I can't remember which 1 or 2 heap profiling mode(s) work even without a profiling build
10:13:47 <mercury^> dons: You can see the whole core I posted before.
10:13:48 <dons> or in the IO monad?
10:13:49 <path[l]_> dons: would you be able to take a quick look and tell me why I dont seem to be seeing that? I have both posted on pastebin
10:13:54 <mercury^> dons: the allocation is happening in there.
10:13:56 <SamB> mercury^: did you make sure to get sensible cost centers?
10:13:56 <dons> mercury^: why don't you post the original source?
10:13:57 <copumpkin> if you use very little actual ruby in ruby code, it can be pretty fast (i.e., just using regex matching and hashtables)
10:13:57 <mercury^> dons: it's IO.
10:14:01 <mercury^> dons: I did.
10:14:08 <ksf> waagh ghc-core fails to install.
10:14:12 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8739#a8739
10:14:32 <mercury^> dons: gen and the (inlined) pick are where I took the core from
10:14:35 <ksf>     Module
10:14:35 <ksf>     `Language.Haskell.HsColour.Options'
10:14:35 <ksf>     does not export
10:14:35 <ksf>     `Literate(..)'
10:14:36 <mercury^> and it's where the allocation happens
10:15:41 <dons> sorry,  i don't have time to review the code at the moment. there are people in here who do though, i think.
10:15:44 <path[l]_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424 <--- ruby, haskell -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425
10:16:45 <mercury^> I'm rather certain it's a compiler bug anyway. There are only primops left now, but it still allocates a lot.
10:17:02 <dons> path[l]_: so what's the issue?
10:17:23 <dons> mercury^: seems unlikely to be a compiler bug, honestly.
10:17:40 <dons> mercury^: so you observe in top 4G allocated?
10:17:41 <path[l]_> well the haskell version is only slightly faster. With O2. Im expecting a lot more. I moved it to haskell because my ruby version was too slow
10:17:54 <path[l]_> a 30% improvement isnt much
10:17:54 <dons> path[l]_: you're using boxed arrays and linked lists in the haskell version
10:17:56 <mercury^> dons: no, -p says 4.6GB are allocated there.
10:18:00 <dons> what data structures do you use in the ruby version?
10:18:14 <dons> mercury^: total over the lifetime, or maximum at a single point?
10:18:15 <mercury^> dons: that's why heap profiling is rather useless.
10:18:21 <mercury^> total
10:18:26 <mercury^> But it shouldn't allocate.
10:18:29 <path[l]_> I used an array and a hash
10:18:36 <mercury^> It only reads and writes mutable unboxed arrays.
10:18:41 <dons> mercury^: what's the maximum live heap though?
10:19:07 <dons> mercury^: you allocate on the way out of the function. and you call it a lot. maybe 4G total over the lifetime of your program is sensible?
10:19:35 <dons> path[l]_: perhaps use an unboxed array in your haskell then, too. UArray instead of Array
10:20:01 <path[l]_> wait an unboxed array is faster?
10:20:05 <mercury^> dons: no, as I already said, using a {-# UNPACK #-} got rid of that.
10:20:16 <path[l]_> Initially my haskell implementation just used lists and an IntMap
10:20:21 <mercury^> That improved it by about 4 megs.
10:20:33 <mercury^> Still 4.6 GB to go.
10:20:38 <path[l]_> now its using the Array and IntMap (though intermediately it still uses list)
10:20:45 <Cale> path[l]_: Just as long as you don't use Data.HashTable ;)
10:20:46 <dons> mercury^: where's your cost centre .prof file?
10:21:05 <Cale> (and IntMap is not a hash)
10:21:11 <mercury^> gen                            Main                  70.1   86.5
10:21:12 <mercury^> pick                           Main                  26.9   13.5
10:21:26 <dons> what's the maximum heap allocated?
10:21:34 <mercury^> About 25k
10:21:45 <dons> so it runs in constant space?
10:21:46 <path[l]_> yeah I dont need a hash, I really need a structure that helps me find duplicate keys. Ultimately I dont do a find operation, I just do a sweep over the entire collection
10:21:49 <mercury^> Yes.
10:22:11 <dons> you just feel that gen should do no heap allocations, whatsoever?
10:22:13 <path[l]_> I create a list and move it to a map to get rid of duplicates
10:22:14 <dons> or pick?
10:22:19 <mercury^> dons: correct.
10:22:38 <path[l]_> Cale: I used a hash in ruby though, simply because its a common convenient structure for that operation
10:23:20 <dons> ok. that's a hard property to guarantee. y can make it so by using only unboxed values and tuples to ensure stack and register only allocations. otherwise, look at the core, and eliminate constructors.
10:23:27 <Cale> path[l]_: Is there a description of the problem being solved somewhere?
10:23:36 <path[l]_> sure, sec
10:23:43 <mercury^> dons: well, that's what I did all the time.
10:23:45 <path[l]_> http://www.codechef.com/problems/TEAMSEL
10:23:47 <dons> note also that profiling *introduces allocations*
10:24:12 <dons> so if you see no constructors in the core, then the optimized, non-profiling version may well not allocate
10:24:16 <mercury^> dons: the simple -sstderr when not doing a profile build?
10:24:27 <jmcarthur_work> Cale, path[l] is doing the partition problem. it's a NP algorithm that seems a lot like knapsack to me
10:24:30 <dons> right, that will report total allocs in the entire program
10:24:41 <dons> it doesn't modify the source, so it will be accurate
10:24:43 <path[l]_> I submitted there in ruby first and failed. 9.5 seconds instead of whatever their new cutoff is (the old one seems to have accepted stuff like 30 seconds). I moved to haskell and it still reported 9.4ish
10:24:44 <mercury^> So if I deduced allocations using that, it is happening, right?
10:24:49 <dons> yes
10:24:50 <path[l]_> they use ghc 6.6.1 is all I know
10:24:54 <mercury^> Ok, so code with no constructors allocates according to that.
10:25:00 <c_wraith> ewwww.  Why would they do that? :(
10:25:09 <dons> how do you know which function is allocating, though?
10:25:14 <path[l]_> good question, I posted on the forums, no response
10:25:17 <ksf> dons, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8743#a8743
10:25:22 <path[l]_> I also asked if they're compiling with O2
10:25:29 <ksf> ...please update ghc-core's hackage entry.
10:25:29 <mercury^> Because I modified it to call itself fewer times, and that reduced the allocated space linearly.
10:26:02 <Phyx-> path[l]_: are you using spoj by any chance?
10:26:15 <dons> ok. could you then post your current program, its core, and the observed allocations, along with what you believe it should be doing, to the mailing list?
10:26:15 <path[l]_> ummm no, I dunno what that is
10:26:33 <Phyx-> lol, nvm then
10:26:39 <c_wraith> for the curious, this is the problem path[l] is working on:  http://www.codechef.com/problems/TEAMSEL
10:26:47 <dons> my guess is there's a boxed return somewhere, that is allocated on the heap. call that enough andyou'll make billions of small, short-lived allocs
10:26:55 <path[l]_> lol I posted that half a page ago =p
10:26:57 <mercury^> dons: haskell-cafe?
10:27:02 <dons> mercury^: that would be a good place
10:27:03 <log0ut> What causes 'Could not find module `Control.Monad.State':
10:27:03 <log0ut>   it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2' to happen?
10:27:48 <Phyx-> path[l]_: ah, spoj is a similair site
10:27:52 <Phyx-> also uses 6.6.1
10:27:53 <dons> mercury^: you should also motivate why, when it runs in constant space, you want to guarantee no heap allocations. e.g. additional performance or ...?
10:27:58 <Phyx-> i don't think they ever upgrade
10:28:06 <path[l]_> haha
10:28:10 <ksf> log0ut, it's caused by Control.Monad.State" being in muliple packages.
10:28:32 <ksf> you have to hide one, or, preferrably, make a .cabal file and make cabal do that for you.
10:28:35 <Phyx-> log0ut: hide one of the packaged by the build
10:29:00 <log0ut> ksf: I am just wondering how I got more than one package with the state monad in it.
10:29:08 <mercury^> dons: can I post to the list without subscribing somehow?
10:29:24 <ksf> if hackage had reverse dependencies, that would be easy to figure out.
10:29:33 <Makoryu> Hay guise
10:29:36 <dons> mmm. i don't think so. i'd encourage you to subscribe, since you'll get detailed help if all the aspects of your problem are presented in one place
10:29:53 <Makoryu> I would like to get a new shell account, but I want to be able to run Haskell programs on it
10:29:57 <ksf> mercury^, gmane.
10:30:01 <jmcarthur_work> just out of curiosity, are you screwed if module A is in package A and package B, you want module A from package A, but you also want module B from package B?
10:30:26 <Makoryu> Anyone have recommendations?
10:30:38 <ksf> gmane drastically reduces my overall internet traffic.
10:30:42 <quicksilver> jmcarthur_work: I believe you can make that work if you're prepared to write a small package C to export A from A.
10:30:51 <quicksilver> jmcarthur_work: I'm not 100% sure that will, in fact, work.
10:31:03 <jmcarthur_work> ah! that sounds reasonable at least
10:31:11 <quicksilver> (under a different name I mean)
10:31:14 <ksf> Noone could possibly read all the messages on all the mailing lists I'm subscribed to...
10:31:17 <lilac> jmcarthur_work: can't you say import "A" A?
10:31:25 <quicksilver> oh does that work?
10:31:31 <quicksilver> lilac++ if it does
10:31:39 <jmcarthur_work> wha-?
10:31:53 <lilac> quicksilver: it works for importing Control.Monad.Trans from mtl or transformers (or indeed both if you want)
10:32:11 <Phyx-> path[l]_: heh, does that prolem, not have any constraint on the running time or memory usage?
10:32:15 <jmcarthur_work> which A is the package?
10:32:18 <Phyx-> testing 218.9M 23.92 JAVA
10:32:20 <log0ut> So, say I installed a package with cabal, and that also has say, the State monad in it.  Now everywhere I've typed import Control.Monad.State in past source, it won't work unless now I track down and hide this other package?
10:32:23 <lilac> the A in quotes is the package
10:32:26 <Phyx-> compared to Denis 1.5M 0.34 C
10:32:28 <jmcarthur_work> huh
10:32:28 <Phyx-> is a ton
10:32:33 <jmcarthur_work> lilac++
10:32:38 <mmorrow> mercury^: also try using type signatures, you have dictionaries for MArray and Monad all over the place
10:32:58 <mmorrow> (in gen, probably elsewhere too)
10:33:05 <Lemmih> Makoryu: I like gandi.net
10:33:15 <dons> mmorrow: that's a good point.
10:33:23 <Phyx-> log0ut: if the other package you installed is only used in 1 project, i'd tell ghc-pkg to always hide it, unless explicitly unhidden in the project you need it in
10:33:26 <dons> dictionaries allocate if not statically resolved
10:33:47 <lilac> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8116
10:33:50 <Phyx-> log0ut: you can do that with, ghc-pkg hide <id>
10:33:57 <dcoutts> log0ut: you can 'ghc-pkg hide' the package that provides the alternative Control.Monad.State
10:34:00 <dons> mmorrow: so make sure you have non-polymorphic type signatures on your key functions, to help ghc resolve all type classes statically
10:34:43 <log0ut> Phyx-:  So between monads-fd-0.0.0.1 and mtl-1.1.0.2, the one I probably want to hide is the mtl one?
10:35:06 <Phyx-> i'd say the monads-fd
10:35:09 <ksf> log0ut, most likely, yes.
10:35:16 <Phyx-> as the mtl ships with the compiler no?
10:35:22 <log0ut> Phyx-:  I don't actually know which one ships with ghci
10:35:27 <ksf> mtl
10:35:29 <log0ut> ok
10:35:37 <Phyx-> so yeah i'd hide monads-fd
10:35:47 <log0ut> Thanks very much you guys.
10:36:00 <ksf> ah, _hide_ the mtl one, not use...
10:36:06 <ksf> ...so invert all bools I said.
10:36:13 <Makoryu> Lemmih: That looks like a neat service, but it also seems like overkill
10:36:40 <Lemmih> Makoryu: It's quite cheap.
10:36:50 <quicksilver> lilac: awesome.
10:37:50 <log0ut> ksf & Phyx: ok what?
10:37:51 <path[l]_> Phyx-: it has a constraint on both. I lost out on running time twice in a row
10:37:59 <ksf> does that actually work or is it h' design by wishful thinking?
10:38:08 <mercury^> mmorrow: they are not even touched though, and adding signatures didn't improve anything.
10:38:08 * Phyx- can't wait for summer holliday to be over, i've head enough free time for a while
10:38:18 <ksf> log0ut, hide fd, use mtl
10:38:25 <log0ut> ksf: ok
10:38:29 <ksf> if it doesn't work, do the reverse.
10:38:32 <log0ut> heh
10:38:37 <Phyx-> log0ut: well, i'd hide monad-fd, because mtl comes with ghc, and other programs might depend on it being unhidden
10:38:44 <copumpkin> Phyx-: give me some please!
10:39:09 <Phyx-> log0ut: and then in the project you do need monad-fd, consider using cabal, and then you can specify which packages you need
10:39:23 <Phyx-> copumpkin: gladly, i've had more than 2 months worth already
10:39:44 <mercury^> mmorrow: Hmm, adding a signature for gen didn't get rid of any parameters actually.
10:39:53 <Phyx-> i'm sitting here, twiddling my thumbs everyday, with no external motivator, i can't code :|
10:40:09 <quicksilver> lilca++ # knowing stuff
10:40:28 <quicksilver> hmm
10:40:34 <copumpkin> Phyx-: internal motivators ftw
10:40:37 <quicksilver> quicksilver-- # typo in a 5 letter nickname
10:40:44 <quicksilver> lilac++ # knowing stuff
10:40:51 <Athas> Hmm, the Xlib binding doesn't really make it easy to implement good error handling, does it?
10:40:53 <dv_> whats the name for the map operation in haskell?
10:40:54 <ksf> Control.Motivator.Internal
10:41:01 <Phyx-> copumpkin: what are there internal motivators?
10:41:17 <Makoryu> dv_: Erm, over lists?
10:41:25 <dv_> oh it is called map :)
10:42:12 <Phyx-> > map id [9..]
10:42:14 <lambdabot>   [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,...
10:42:15 <ksf> as motivation, haskell was declared to be female, so you can play around with her.
10:42:42 <Phyx-> which means, i have about a day before ghc moves on from me..
10:42:50 <Phyx-> :P
10:43:18 <ksf> Phyx-, see http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
10:43:21 <SamB> hmm, can someone get http://haskell.org/definition/haskell-report-1.2.ps.gz served as application/postscript with a gzip encoding ... or is it supposed to be served as application/gzip ?
10:44:47 <mercury^> quicksilver: you type nicknames out?
10:45:26 <Phyx-> hahhahaha thanks for that ksf , i needed a laugh :P
10:46:49 <ksf> my systems opens that fine, in gv.
10:47:15 <SamB> ksf: when you click on it?
10:47:23 <ksf> (which is another story alltogether, I like okular more)
10:47:40 <ksf> er, when I paste it into my location bar and hit enter, then click "open"
10:48:04 <SamB> eww, this is bad:
10:48:06 <SamB> Content-Type: application/x-gzip
10:48:06 <SamB> Content-Encoding: x-gzip
10:48:12 <ksf> firefox 3.5.2, didn't do anything special to my file associations
10:56:30 <Phyx-> @where haskell theme song
10:56:30 <lambdabot> http://haskell.org
10:56:40 <Phyx-> @google haskell theme song
10:56:43 <lambdabot> http://www.haskell.org/haskellwiki/Humor/Hackage_Theme_Song
10:56:43 <lambdabot> Title: Humor/Hackage Theme Song - HaskellWiki
10:57:33 <roconnor> @seen augustuss
10:57:33 <lambdabot> I haven't seen augustuss.
10:58:22 <ksf> argh hieroglyph fails
10:58:44 <roconnor> ksf: noooo!
10:59:01 <ksf> ...I need access to a string's dimensions when rendered.
10:59:15 <roconnor> ah
10:59:24 <roconnor> that seems to be really hard to find out for some reason.
10:59:35 <roconnor> I had that problem with cairo
11:00:15 <ksf> it's not entirely trivial with non-proportional fonts, and even less if there's decent kerning support and stuff.
11:01:14 <ksf> the _real_ problem is to get the dimensions without going via io, as construction of stuff should be pure.
11:01:40 <roconnor> yes, it is a big problem
11:01:41 <dsouza> question about hackage: is it a common practive to announce every single new version which is uploaded?
11:01:57 <roconnor> when I write my own cairo replacement, all problems will be solved!
11:02:09 <roconnor> dsouza: I don't
11:02:16 <ksf> also, you usually can't just do sum [textWidth "Hello,", textWidth " ", textWidth "World!"] and have it equal textWidth "Hello, World!"
11:02:23 <roconnor> dsouza: I'd restrict myself to major revisions or fewer
11:03:01 <roconnor> ksf: I guess that makes sense.
11:03:01 <ksf> paragraph layout is a very, very fun topic.
11:03:09 <dsouza> roconnor: I fell likewise. Good to know, thx
11:03:45 <ksf> ...but then, I should be working word-wise, anyway, like tex.
11:03:55 <ksf> (modulo hyphentisation)
11:04:23 <roconnor> ``Writing to sockets, deleting files
11:04:25 <roconnor> or even launching missiles
11:04:36 <hackagebot> jail 0.0.1.1 - Jailed IO monad. (SebastiaanVisser)
11:04:37 <roconnor> ksf: a moderately large modulo
11:04:53 <ksf> it's not actually that complex.
11:04:58 <roconnor> dsouza: hackagebot announces everything, but I forgive it.
11:05:09 <ksf> let me grep my history....
11:05:19 <roconnor> ksf: plz explain it in Haskell :P
11:05:32 <ksf> http://defoe.sourceforge.net/folio/knuth-plass.html
11:05:44 <roconnor> bah, english
11:05:58 <ksf> ...do you prefer pascal?
11:06:14 <roconnor> I prefer Haskell
11:06:19 <roconnor> so I don't have to write it :)
11:06:29 <ksf> but then... I must admit that, on first sight, haskell's syntax reminded me of pascal.
11:06:45 <roconnor> oh right, Pascal
11:06:49 <roconnor> I see now
11:06:52 <dsouza> roconnor: i think it probably depends on the library. I like to do things very incrementally, so annoncing everytime, I feel, would just add unecessary noise.
11:07:00 <roconnor> I suppose english is better than Pascal for me.
11:07:11 * juhp is having sdist troubles...
11:07:26 <juhp> why does it only pick up Main.hs from my package
11:07:38 <roconnor> dsouza: I think a key thing might be to write a blurb in the haskell communities report each year.
11:07:46 <juhp> must be mssing something obvious I guess...
11:07:54 <roconnor> dsouza: depending on what sort of thing you are doing
11:08:04 <juhp> suppose I can just list all the modules, but do I have to?
11:08:12 <ksf> it's actually a quite simple left-fold over the words in a paragraph.
11:08:27 <ksf> wait no right-fold
11:08:31 <ksf> @src foldr
11:08:31 <lambdabot> foldr f z []     = z
11:08:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:08:42 <ksf> @src foldl
11:08:43 <lambdabot> foldl f z []     = z
11:08:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:09:04 <roconnor> a left fold is a right fold
11:09:31 <idnar> rift fold
11:10:14 * ksf enters the long, dark tea-time of the stomach
11:11:03 <ksf> that time of day where you're just hungry enough to eat a bit, not hungry enough to eat more than a few cookies to your tea, and wise enough not to eat cookies so you get more hungry faster so you can have a proper meal.
11:11:28 * Lycurgus raises a pinky
11:11:36 * copumpkin bites it off
11:11:46 <Lycurgus> ouch!
11:12:51 <copumpkin> you have another one, you'll be fine
11:13:12 <dsouza> roconnor: agreed. currently i'm working on /nothing important/. Just practicing and studying ... so i'll stick with the "announce only major achievements" to avoid generating noise
11:13:25 <ksf> a gui library with proper text layout would be teh win.
11:14:06 <ksf> although kerning wrecks havoc on layout semantics.
11:14:59 <copumpkin> and ligatures, and contextual substitutions, etc.
11:15:16 <copumpkin> I guess the former are an example of the latter
11:15:39 <ksf> ...especially ligatures that you insert or remove depending on how much you want to stretch a line.
11:15:52 <sm> dsouza: yes, hackagebot announces everything in the hackage rss feed
11:16:23 <ksf> ...firefox doesn't even use total-fit for each single paragraph.
11:16:36 <ksf> otherwise, the lines would be much more even, even if unjustified.
11:16:56 <copumpkin> text is hard!
11:17:01 <copumpkin> (let's go shopping)
11:17:16 <ksf> actually, I want to render the text of a button.
11:17:26 <yitz> let's go back to monospace 7-bit ascii
11:17:36 <copumpkin> LTR only
11:17:42 <ksf> ...and have the comparatively simple problem of getting the text-width of "OK" and "Cancel" in a pure fashion.
11:17:47 <copumpkin> cause RTL/LTR interaction is complicated
11:17:59 <copumpkin> especially if you want to allow selection for copy/paste
11:18:07 <ksf> which should'nt actually be a problem because those functions _are_ pure.
11:18:12 <yitz> copumpkin: not with 7-bit ascii
11:18:14 * ezyang wonders if you want to port TeX to Haskell :-) 
11:18:25 <Cale> Heh, XChat does such hilarious things when you try to select Hebrew text.
11:18:29 <ksf> copumpkin, compare that with up/down...
11:18:34 <copumpkin> even TeX doesn't deal nicely with internationalization issues
11:18:38 <Cale> (especially when it's mixed in with English)
11:18:39 <hackagebot> hoauth 0.1.0 - A Haskell implementation of OAuth 1.0 protocol. (DiegoSouza)
11:18:42 <copumpkin> you need XeTeX!
11:18:50 <ksf> tex isn't supposed to.
11:19:05 <ksf> luatex, does, too, and soon it'll be the tex to obsolete them all.
11:19:15 <Cale> I've seen some beautiful Chinese characters from TeX-related things though.
11:19:17 <ksf> xetex doesn't handle microtypography.
11:19:27 <copumpkin> microtypography?
11:19:46 <copumpkin> there's a cjk package for regular (La)TeX
11:19:46 <mercury^> Cale: shouldn't it handle all text uniformly and not care for languages? Or does it non-ASCII weird in general?
11:19:54 <copumpkin> but it isn't very pleasant
11:19:57 <ksf> to do such things as having a line ending in "-" protude just a little more than a line ending in "d"
11:20:11 <ksf> ...so that justification is even more justified, visually, that is.
11:20:13 <yitz> copumpkin: the whole bidi approach of Unicode is wrong imo. but too late now. it's been too late ever since MS hired away an engineer from Kivun in the 90's and stole their misguided bidi algo.
11:20:15 <dsouza> sm: right. I think it vary from pkg to pkg. So keeping it low profile is probably ok.
11:20:46 <copumpkin> yitz: yeah, but it's hard to define what is correct when you bring two things together that aren't normally together like that :P
11:20:46 <Cale> mercury^: Well... it's not like all languages are exactly the same with regard to typesetting rules...
11:21:39 <ksf> if you had ever typeset a text in german, you'd know how much work hyphentisation can be.
11:21:54 <yitz> copumpkin: actually the bidi algo is fine, but it should be part of the input method in apps, not part of the definition of glyphs.
11:22:06 <ksf> there's dictionary support, alright, but germans tend to make up words on the fly.
11:22:31 <copumpkin> yitz: that makes sense
11:22:35 * copumpkin has to run!
11:22:47 <yitz> that's good exercise
11:24:34 <path[l]_> back, anyone got anything for me
11:24:58 * byorgey hands path[l]_ a golden lambda
11:27:13 <ksf> but then, doing text layout is a good exercise of getting gui layout just right.
11:28:41 <ksf> as "ffi" might be either 'f':'f':'i':[] or 'f':'fi':[] or 'ffi':[] , we already need [(Box,Width)], that is, semantically identical choices.
11:29:47 <ksf> ...which, in gui, might be useful to do magic things as hiding icons as soon as there are too many tabs.
11:30:58 <path[l]_> lol
11:31:20 <ksf> I'm still wondering whether paragraph-style layout, that is, linebreaking, has any application whatsoever regarding gui elements.
11:31:38 <ksf> oh, well, tab headers, again.
11:32:31 <pr> > 'fi'
11:32:32 <lambdabot>   <no location info>:
11:32:32 <lambdabot>      lexical error in string/character literal at chara...
11:33:25 <ksf> > 'ï¬'
11:33:26 <lambdabot>   '\64257'
11:33:46 <pr> now that's cheating!
11:33:51 <ksf> > 'ï¬ƒ'
11:33:52 <lambdabot>   '\64259'
11:34:08 <Berengal> wtf
11:34:22 <ksf> ...it's the same as
11:34:22 <pr> > '\64257'
11:34:23 <lambdabot>   '\64257'
11:34:24 <EvilTerran> pr, not really, in the context of dealing with ligatures
11:34:27 <ksf> > 'æ'
11:34:28 <lambdabot>   '\65533'
11:34:43 <Berengal> > 'æ'
11:34:44 <lambdabot>   '\65533'
11:34:48 <c_wraith> what is the ffi glyph for?
11:34:48 <Berengal> Huh
11:34:57 <ksf> it's a ligature.
11:35:11 <c_wraith> hmm.  I guess not in this font.
11:35:29 <ksf> ...note that the bars of the f's are one, and the dot of the i is missing.
11:35:37 <c_wraith> Not in this font. :)
11:35:52 <c_wraith> the fi one is rendered as a ligature
11:35:55 <c_wraith> but ffi is not
11:36:06 * EvilTerran 's font doesn't display the 'ffi' character at all, and the 'fi' is two distinct letters
11:36:14 <EvilTerran> ah, the rustic simplicity of courier new :P
11:36:28 <ksf> "fi" is two glyphs, "ï¬" one.
11:36:50 <c_wraith> you are correct.  I'm just talking about how my font chooses to handle those ligatures.
11:36:51 <ksf> ...should select as one, too.
11:37:58 <Berengal> > text (chr 230 : [])
11:37:59 <lambdabot>   Ã¦
11:38:13 * Berengal wonders about the logic behind haskell's Char
11:38:26 <ksf> Char is a unicode codepoint.
11:38:29 <Berengal> > ord (chr 230) == 230
11:38:30 <lambdabot>   True
11:38:32 <etpace_> :t text
11:38:33 <lambdabot> String -> Doc
11:38:35 <dons> maxBound :: Char
11:38:38 <dons> > maxBound :: Char
11:38:39 <etpace_> Doc?
11:38:39 <lambdabot>   '\1114111'
11:38:43 <EvilTerran> (i've tried a variety of free fonts; either their unicode coverage sucks in the ranges that i want, or the glyphs strain my eyes, in every one that i've found)
11:38:53 <ksf> that's Text.PrettyPrint.HughesPJ
11:39:10 <ksf> charis, libertine
11:39:27 <ksf> ...well, charis has everything that's remotely latin or similar.
11:39:44 <ksf> you'll find fonts for other scripts at SIL, too.
11:40:12 <EvilTerran> ksf, oh, sorry, i forgot my other requirement: monospaced.
11:40:18 <ksf> ugh.
11:40:25 <ksf> monospaced is always problematic.
11:40:35 <pr> EvilTerran: what about consolas?
11:40:44 <pr> it's at least free as in free beer
11:40:53 <c_wraith> When I was using OSX, I used Monaco.  It seemed to work pretty well.
11:41:01 <c_wraith> But it might be an apple-owned font
11:41:05 <pr> consolas is even prettier than monac
11:41:07 <pr> *monaco
11:41:18 <c_wraith> Hmm.  I suppose that's worth checking out.
11:41:22 <c_wraith> got a link, pr?
11:41:30 <pr> just a sec :)
11:41:53 <pr> c_wraith: http://embraceubuntu.com/2007/09/16/installing-vista-fonts-in-ubuntu/
11:41:58 <pr> (i suppose you are on some *nix machine)
11:42:11 <c_wraith> ubuntu, in fact :)
11:42:29 <pr> oh, i'm sorry, i've to correct myself here:
11:42:31 <pr> "Looks like the use of these fonts are restricted to only Microsoft Windows/Vista operating systems according to the terms of the license. "
11:42:42 <pr> so if you got a problem with that, it can't be helped i guess
11:42:51 <ksf> heck it can't be that hard to get pure truetype primitives.
11:42:58 <mmorrow> fix (1:) {- and [0..] -} in C: http://codepad.org/4IUFN5l5
11:43:36 <mmorrow> (clearly that memory isn't being collected, but it could be)
11:43:49 <juhp> nm I found http://hackage.haskell.org/trac/hackage/ticket/15
11:44:30 * EvilTerran got used to text on BBC Micros, initially; i still find a lot of modern fonts illegibly narrow
11:44:52 <Berengal> > text $ chr (ord 'æ') : []
11:44:53 <lambdabot>   ï¿½
11:45:07 <pr> EvilTerran: i was wondering if there's any chance your nickname is related to starcraft?
11:45:15 <EvilTerran> vaguely
11:45:21 <EvilTerran> lots of scifi has terrans
11:45:25 <pr> i see :
11:45:26 <pr> :)
11:45:29 <EvilTerran> > sort "irrelevant" == sort "evilterran" -- and this
11:45:30 <lambdabot>   True
11:45:36 <pr> hah
11:45:38 <ksf> hmmm freetype seems to be pure, on first sight.
11:45:56 <ksf> ...and it's pure c.
11:46:09 <ksf> which makes me wonder why there aren't any bindings, yet.
11:46:59 <mmorrow> oops, s/sizeof(Ind*)/sizeof(Ind)/ ;)
11:47:12 <mmorrow> love those errors
11:47:32 <yitz> mmorrow: could not construct infinite type...
11:48:17 <mmorrow> heh
11:51:47 <yitz> pr: the pcworld reviewer of snow leopard says he always used consolas instead of monaco, but the new font on snow leopard is even nicer
11:52:07 <pr> oh that's interesting
11:52:21 <yitz> we'll see
11:52:34 <pr> thanks for the info :) i actually never used monaco, just saw a comparison between monaco and consolas
11:52:42 <pr> and i instantly chose consolas
12:04:16 <Berengal> "So what could be so useful about depression? 'Depressed people often think intensely about their problems,' write the authors."
12:07:26 <Phyx-> Berengal: unfortunately they tend to think about what makes them depressed
12:08:21 <RayNbow> @where recursion schemes
12:08:21 <lambdabot> ?where recursion
12:08:25 <Berengal> Phyx-, according to the /. summary, thinking about stuff is also what makes them depressed
12:08:27 <RayNbow> @where recursion
12:08:27 <lambdabot> ?where recursion
12:08:30 <RayNbow> ah
12:08:34 <RayNbow> ?where recursion schemes
12:08:34 <lambdabot> ?where recursion
12:08:52 <RayNbow> @botsmack
12:08:52 <lambdabot> :)
12:08:53 <lunabot>  :)
12:11:25 <Phyx-> Berengal: yeah, but the author's tried to make it sound likea  good thing
12:12:48 <Berengal> Phyx-, taken slightly out of context, the author quote sounds like an obvious tautology
12:24:43 <uzytkownik> Hello. How should I add finalizer to object?
12:25:12 <copumpkin> to a ForeignPtr?
12:25:16 <copumpkin> @hoogle finalizer
12:25:16 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
12:25:16 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
12:25:16 <lambdabot> Foreign.ForeignPtr type FinalizerPtr a = FunPtr (Ptr a -> IO ())
12:25:24 <copumpkin> @hoogle+
12:25:24 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
12:25:25 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
12:25:25 <lambdabot> Foreign.ForeignPtr addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
12:27:46 <paper_cc> @hoogle addMVarFinalizer
12:27:47 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
12:27:52 <paper_cc> @hoogle mkWeakIORef
12:27:53 <lambdabot> Data.IORef mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))
12:28:32 <uzytkownik> Weak have in documentation that I should not use it for resource controll and I should use 'finalizers'
12:29:08 <copumpkin> uzytkownik: can you expand on what you're trying to do?
12:43:11 * ksf despairs
12:43:41 <ksf> where do I get both the dimensions of a text, and a way to render said text, both in a pure fashion?
12:45:10 <Twey> dimensions :: Font -> String -> (Integer, Integer); render :: Font -> String -> Canvas -> Canvas
12:45:14 <Twey> No?
12:45:15 <Twey> What's impure about it/
12:45:17 <Twey> ?**
12:45:18 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
12:45:25 <Twey> lambdabot: Hush you
12:45:40 <ray> @botlack
12:45:40 <lunabot>  :)
12:45:40 <lambdabot> :)
12:45:52 <Twey> Hehe
12:45:56 <ksf> Twey, now where do I find these miraculous functions?
12:46:11 <Twey> Oh, I was presuming you were going to write them.  :Ã¾
12:46:43 <ray> aren't they trivial given the types? (like all haskell functions?) :)
12:47:25 <Twey> If you want to get the system to do it, I think you're going to have to go with <toolkit of choice> and unsafePerformIO.
12:47:32 <ray> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
12:47:39 <hikingpete> I gotta say, the types are what I spend all my time trying to figure out - the code is easy.
12:47:49 <ray> the big no is at the toolkit part, btw, not so much the unsafe part
12:47:50 <ray> :)
12:47:59 <Twey> Haha
12:48:11 * ksf wonders whether freetype would mind to use it in a pure fashion
12:48:21 <ksf> doesn't seem to be state-based.
12:48:32 <ksf> ...at least if you look at all those references you pass around.
12:48:45 <Twey> Even state-based things should work in a context that you can wrap up and sell as pure
12:48:53 <Twey> I know Qt and Swing do
12:49:12 <ksf> ...non-monadic, that is.
12:49:31 <Twey> So did I
12:49:41 <Twey> Well, there might be an unsafePerformIO in there somewhere, butâ€¦
12:49:46 <ksf> huh?
12:50:09 <ksf> if the library is using state, you have to mind the order of calls into it, which means you can't go pure.
12:50:38 <Twey> ksf: Not if it's context-based
12:50:48 <juhp_> hmm
12:50:48 <ksf> the ffi is luckily quite agnostic about pure vs. impure
12:50:53 <Twey> In a typical toolkit, you have a â€˜painting contextâ€™
12:51:30 <ksf> in freetype, I've got a "Library". and from that "Library", I can get a "Font", and from that "Font", I can get a "Glyph".
12:51:30 <Twey> You get this context, associate it with a canvas, set its font, colour, et cetera, and then use it to render
12:51:54 <Twey> Within the context it's impure, but you can treat the entirety of the operation as pure
12:51:56 <juhp_> why with 6.10.4 is Cabal complaining that my .cabal file changed... sigh
12:52:00 <Twey> Oh, well, that sounds much purer :)
12:52:19 <ksf> I dunno how much evil state-based caching and stuff it's doing though.
12:52:32 <ksf> and it could be that it's going to get utterly confused.
12:52:40 <uzytkownik> copumpkin: I try to understend FRP by implementing one. I implement on top on register-based system and I want to unregister a signal when all references to signal from circuit are dropped.
12:52:49 <ksf> otoh, that confusion might simply be true bugs, then.
12:52:49 <dcoutts> juhp_: it's always complained if your .cabal file has changed since you last ran cabal configure
12:52:53 <copumpkin> uzytkownik: ah
12:53:05 <ksf> uzytkownik, ForeignPtr.
12:53:30 <ksf> or, rather FinalizerPtr.
12:53:39 <juhp_> dcoutts: yeah but... it is doing it repeatedly ... hmm maybe it is some fedora rawhide breakage?
12:54:48 <dcoutts> juhp_: you mean you run configure and it still says you need to reconfigure?
12:55:07 <leimy> we're losing
12:55:08 <leimy> http://www.googlefight.com/index.php?lang=en_GB&word1=haskell&word2=erlang
12:55:11 <leimy> the googlefight
12:55:14 <juhp_> hmm I haven't had time to play with 6.10.4 - or my package is broken - seems ok with 6.10.3 on f11
12:55:19 <juhp_> dcoutts: right
12:55:28 <dcoutts> juhp_: ok, that's broken then :-)
12:55:35 <juhp_> yeah...
12:55:50 <aavogt> juhp_: do you have timestamps in the future?
12:55:51 <juhp_> or maybe it is encouraging me to get some sleep ;)
12:55:57 <juhp_> let me see
12:56:00 <dcoutts> juhp_: it could be that configure fails without saying why, so does not update the saved config
12:56:02 <juhp_> that's possible
12:56:24 <dcoutts> juhp_: run with -v
12:56:25 <Twey> leimy: Ehwhat?
12:56:51 <Twey> leimy: Haskell: 1,500,000; Erlang: 658,000
12:57:04 <juhp_> dcoutts: thanks!
12:57:08 <Twey> We're some three times ahead :Ã¾
12:57:11 <Twey> Er
12:57:18 <Twey> As popular
12:57:42 <ksf> nah it's impure, after all.
12:57:56 <ksf> there are loads of functions that mutate stuff you pass in.
12:59:07 <leimy> Twey: the flash is messed up... it made the smaller results the bigger bar on my machine.
12:59:39 <elliotstern> What would be the haskelly version of -p?  that is to say, if in Lisp I have a oddp or capturedp predicate, what should I call it in haskell?
13:00:14 <ksf> isFoo
13:00:23 <ksf> or just foo
13:00:27 <ksf> that is,
13:00:30 <ksf> > odd 1
13:00:34 <lambdabot>   True
13:01:10 <ray> since you're obviously using scheme, your predicates actually have names like odd?
13:01:11 <ksf> with "odd" its, easy, as you can't meaningfully verb it. it's always adjectivised.
13:02:42 <hikingpete> I'm trying to write a CGI program that does some work with files. I'm not sure what questions to ask. I don't know how to mix CGI stuff with stuff that does IO. I also don't know how to separate them.
13:02:52 <hikingpete> *mix
13:03:17 <Lemmih> hikingpete: do cgiStuff; liftIO ioStuff; moreCGIStuff
13:03:19 <Jedai> hikingpete: you can use IO in MonadCGI with liftIO
13:03:25 <Makoryu> elliotstern: If the function takes two arguments, it's customary to call it as an infix operator (eg. "pi" `isPrefixOf` "pizza") and name it accordingly
13:03:49 <hikingpete> Is there a guide to understanding what liftIO does / how it works?
13:04:36 <juhp_> ah OldException
13:04:38 <ksf> mmmh it seems that by carefully choosing how you use freetype, you can make it pure.
13:04:43 <Jedai> Makoryu: well, not always, there's plenty of two arg functions that aren't really used as infix, it's really more a "does it sound better" situation
13:04:44 <juhp_> that helps
13:04:48 <elliotstern> In this case, it's just a function of one argument, a predicate of if a number is in a class of numbers.  I've been working through project Euler a bit recently
13:05:07 <hikingpete> Anyway, thanks; that should be enough of a start.
13:05:14 <ksf> the first step would be to lift it out of the IO monad into a couple of monads, each for every pointer type.
13:05:30 <Makoryu> Jedai: Yeah, it's hardly a universal. I've mainly just seen it in functions of type t -> t' -> Bool
13:06:54 <Jedai> hikingpete: Probably some of the monad transformers tutorial around there... But liftIO doesn't do anything transcendent except taking an IO operation and lifting it into MonadIO (which is a typeclass for Monads that supports liftIO, that is Monads that allow unrestricted side effect in addition to their own stuff)
13:07:32 <ksf> but then, It's of vital importance that I prepare spaghetti, now.
13:08:40 <Twey> leimy: How odd.
13:08:48 <leimy> indeed
13:08:49 <hikingpete> Just when I feel I'm getting comfortable with Monads, I begin to discover there's this whole realm of 'monad transformers' that I need to understand.
13:09:05 <leimy> The monads can be derived from monad transformers :-)
13:09:11 <Twey> hikingpete: Monad transformers are just monads with another monad inside them.
13:09:27 <ksf> isn't that exactly what ST is for?
13:09:44 <Twey> What, monad transformations?  o.@
13:10:01 <ksf> no, things like threading stuff isomorphic to RealWorld#
13:10:16 <andrewz> after a program is compiled users can run it WITHOUT having ghc or w/e libs i used (crypto) right?
13:10:58 <Twey> andrewz: You need the libraries, unless it was linked statically.
13:11:02 <hikingpete> So, does that mean that CGI has the IO Monad in it, and liftIO provides transforms the function to work with the inner Monad?
13:11:02 <ksf> ...so you can do "do openFont >> setSize >> return $ 12" and get an immutable font at size 12
13:11:02 <dcoutts> andrewz: yep
13:11:10 <Twey> You don't need GHC.
13:11:16 <ksf> er setSize 12 >> return self
13:11:22 <dcoutts> Twey: ghc does static linking at the moment
13:11:25 <andrewz> Twey: staticly linking is possible though so they ownt need em right
13:11:27 <Twey> Oh really?  Huh.
13:11:34 <dcoutts> for Haskell code
13:11:37 <Twey> andrewz: Yes, apparently it's also the default.
13:11:37 <dcoutts> not C libs
13:11:49 <Philonous> hikingpete: Monad tranformers are really cool. You can just plug together whatever functionality you need and get a new monad. Like list monads with Error handling. Or State with logging. liftIO is just a convenient way of invoking an IO action and leaving the rest alone, so you save yourself some typing.
13:11:49 <Twey> dcoutts: No wonder people complain about Haskell binaries being fatâ€¦
13:11:58 <dcoutts> Twey: support for shared libs isn't in any released ghc version yet
13:12:14 <Vanadium> If only there was a ST monad transformer
13:12:15 <Twey> Is it in development?
13:12:26 <ksf> it's actually done.
13:12:27 <dcoutts> Twey: yes, it's turned on in ghc head
13:12:28 <ksf> or was.
13:12:33 <Twey> Ah, good.
13:12:51 <ksf> ...was, even before, but kept breaking?
13:13:29 <hikingpete> philonous, twey, jedai, lemmih: thanks for the infos.
13:13:36 <andrewz> Twey: thanks
13:14:05 <andrewz> dcoutts: is there a way to tell if it needs c libs?
13:14:16 <dcoutts> andrewz: ldd
13:14:20 <ksf> urks. allocating and peeking pointers outside of the IO monad.
13:14:36 <dcoutts> andrewz: they always need some C libs, like libc etc
13:14:40 <ksf> now I know why IO turns out to be the universial sin bin.
13:16:05 <ksf> I don't know whether or not I should be glad not to have any experience with impure caching.
13:17:29 <andrewz> dcoutts: so how do i compile without the user needing to download some c libraries?
13:18:06 <dcoutts> andrewz: what C libs does it need?
13:18:44 <Jedai> andrewz: Well you can link it statically
13:19:01 <Jedai> andrewz: it's in the option of GHC
13:19:04 <dcoutts> fully static linking is not recommended on any platform these days
13:19:14 <dcoutts> not Windows, not OSX and not Linux/glibc
13:19:18 <Jedai> andrewz: there's a switch for it
13:19:26 <Jedai> dcoutts: why ? bugs ?
13:19:32 <andrewz> dcoutts: the only non-standard lib im using is http://hackage.haskell.org/packages/archive/RSA/1.0.2/doc/html/Codec-Crypto-RSA.html
13:20:33 <dcoutts> andrewz: so there's no special C libs then, I would leave it as is then, don't bother trying to make a fully static binary
13:20:52 <dcoutts> Jedai: no, because of compatibility, and some features need dynamic libs
13:21:39 <Jedai> andrewz: this library is pure Haskell AFAIK
13:21:57 <dcoutts> Jedai: Windows has never let you make static exes, they always link dynamically to various win32 libs. OSX I think is dropping support for static binaries. Glibc docs say it's a bad idea because various things stop working, like name resolution.
13:22:19 <andrewz> dcoutts: Jedai thanks!  so as long as the libraries i use are pure haskell i can compile and not worry about them needing to download libs right
13:22:22 <Jedai> andrewz: your only dependency would be to things that are on the system anyway (or the OS don't work at all)
13:22:26 * juhp needs to try shared libs again :)
13:22:44 * bos wants to work on benchmarking
13:22:47 <andrewz> awesome!
13:22:57 <leimy> hmmm
13:22:59 <dcoutts> andrewz: it'll depend on libgmp, but most systems have that or can install it easily
13:23:11 <leimy> I just created a DSL for a minimal subset of "Expect" almost by accident
13:23:13 <leimy> yay monads!
13:23:15 <Jedai> dcoutts: Well the future is shared libraries anyway ! ^^
13:23:31 <dcoutts> @arr!
13:23:32 <lambdabot> Ahoy mateys
13:24:00 <hircules> meep
13:24:03 <leimy> I actually don't like shared libraries
13:24:13 <leimy> I find that they are all about broken promises
13:24:40 <Athas> dons: ping
13:24:45 <leimy> symbol versioning, different versions of libraries that need to coexist on the system, it starts to make the operating system namespace be an issue.
13:24:48 <leimy> it just complicates things.
13:24:57 <dcoutts> leimy: rpath is good for that
13:25:09 <dcoutts> allows isolated use of shared libs
13:25:30 <bos> dcoutts: do you have any magic tricks for benchmarking pure haskell code?
13:25:43 <hircules> leimy: main pros are smaller binaries and security I guess
13:25:44 <dcoutts> bos: Control.Exception.evaluate
13:25:46 <leimy> dcoutts: sure, or you could set the LD_LIBRARY_PATH or DYLD_LIBRARY_PATH before you start your code.
13:25:53 <dcoutts> leimy: except that's evil :-)
13:26:05 <leimy> dcoutts: how is rpath not evil? :-)
13:26:12 <andrewz> dcoutts: this is mostly for windows users will they have libgmp ?
13:26:13 <dcoutts> leimy: because it's perfectly sensible
13:26:14 <leimy> I actualy rather like the plan 9 philosophy :-)
13:26:16 <mmorrow_> LD_PRELOAD is clearly The Right Way
13:26:19 <tingi> how do i get a matrix in this form http://mathworld.wolfram.com/EigenDecomposition.html , P D P^-1, i've a matrix of size 110x110
13:26:20 <leimy> heh
13:26:24 <andrewz> id really them rather not have to install anything else
13:26:28 <dcoutts> andrewz: ohh, on windows it links libgmp statically
13:26:36 <andrewz> automaticly?
13:26:38 <leimy> because each process has a private and mutable namespace, you don't need any path environment variables of any kind
13:26:48 <andrewz> dcoutts: thanks for all the help
13:26:49 <leimy> and everything can very easily be "jailed"
13:27:05 <dcoutts> leimy: right, nix emulates the same within a shared namespace
13:27:10 <leimy> they also don't use shared libs on Plan 9, except in the case  of the linux emulator :-)
13:27:15 <dcoutts> leimy: and that scheme is compatible with rpath
13:27:17 <jmcarthur_work> i don't like file systems. it's bad enough that unix supposedly treats everything as a file. i haven't used plan 9, but from what i hear, it's even more that way than unix
13:27:28 <jmcarthur_work> surely more elegantly
13:27:33 <dcoutts> jmcarthur_work: right
13:27:38 <bos> dcoutts: does evaluate prevent an expression from being thunked if i want to time repeated uses of it? i'd be surprised.
13:27:53 <dcoutts> bos: no
13:27:55 <leimy> yeah as a result plan 9 has fewer system calls than linux by a ton.
13:28:00 <jmcarthur_work> kind of like how i don't like OO all that much, but i prefer OO languages that are turtles all the way down over OO languages that aren't
13:28:04 <leimy> also you configure everything through the filesystem.
13:28:08 <mmorrow_> bos: maybe a (() -> ...) ?
13:28:22 <leimy> baud rates.
13:28:22 <dcoutts> bos: it's not magic. You get a thunk if you bind the value to a name.
13:28:24 <leimy> tcp connections.
13:28:25 <leimy> etc.
13:28:28 <bos> dcoutts: yeah.
13:28:38 <jmcarthur_work> yeah, doesn't sound like my cup of tea
13:28:48 <leimy> Also when everything is a file any new functionality as a filesystem is instanly plugged into anything that can talk to files.
13:28:53 <leimy> so you don't really need shared libs
13:28:57 <leimy> you just make little services :-)
13:29:03 <leimy> and have them all talk amongst themselves.
13:29:08 <leimy> kind of a microkernely idea
13:29:14 <jmcarthur_work> i love unified interfaces, just not file systems ;)
13:29:23 <dcoutts> leimy: some people say rpath is evil but I don't think the arguments make any sense, except for the case of distros that like to put everything in /usr/lib
13:29:26 <leimy> jmcarthur_w: yeah.
13:29:39 <leimy> dcoutts: I think it boils down to preferences... everything has a pro or a con to it :-)
13:30:07 <dcoutts> leimy: rpath lets one make completely isolated, relocatable sets of binaries and shared libs.
13:30:11 <leimy> Someone on the 9fans list just used the linux emulator to rebuild his linux kernel so he could have linux v9fs hooked up, and then play movies hosted on the plan 9 host through the emulator.
13:30:13 <leimy> kind of neat!
13:30:14 <mmorrow_> as long as dlopen works on the haskell .so's i'll be happy
13:30:37 <leimy> dcoutts: There's other ways to do that on Mac OS X
13:30:44 <dcoutts> mmorrow: right, we're one step away from that
13:30:47 <leimy> there's a 2 level shared library namespace on Mac OS X.
13:30:49 <sshc> is it possible to declare two functions with the same name in haskell?  For example, if I want to convert between an Int and String, could I define one convert as "Int -> String" and the other as "String -> Int"?
13:30:54 <jmcarthur_work> my main beef with file systems is the idea of "location," which i don't think makes much logical sense for computing
13:30:58 <leimy> you can change the path part to a library separately from the library link.
13:31:02 <jmcarthur_work> paths, working directories, etc.
13:31:06 <leimy> that was done to make Frameworks work.
13:31:20 <leimy> but Frameworks make shared libs about as useful as static linking.
13:31:31 <leimy> in that you can have 9 versions of the same, and the binary sizes don't really go down :-)
13:31:39 <poe> sshc: yes, the polymorphism you need is available through the use of type classes in Haskell
13:32:18 <dcoutts> sshc: however it's not a good use of type classes to give the same name to String -> Int and Int -> String
13:32:47 <leimy> I suspect that in order to take advantage of massive multi-cores, we'd really want a bunch of multi-client services running on our system instead of libraries anyway.  So multiple apps could use them at once.  Then debugging a small, focused service is a lot easier than a giant app with 90 shared libs linked in :-)
13:32:51 <leimy> but maybe not! :-)
13:33:13 <poe> sorry I misread, I thought you meant a -> String and b -> String for a couple of types a and b.
13:33:33 <yitz> perhaps sshc meant the same name. but qualified differently. like Encode.convert and Decode.convert
13:33:48 <sw17ch> hey all, does any one know of a good way to kill a thread currently blocking in a foreign call?
13:33:49 <jmcarthur_work> leimy, sounds like erlang ;)
13:34:12 <leimy> jmcarthur_work: or Plan 9 :-)  Rio works that way I think.  It's a concurrent window system filesystem service thingy.
13:34:29 <leimy> Erlang is older than Plan 9 though.
13:34:36 <uzytkownik> What's wrong with line:
13:34:47 <uzytkownik> let (+*+) = liftA2 (++) :: Applicative f => f [a] -> f [a] -> f [a]
13:35:00 <leimy> jmcarthur_work: I kind of write some of my haskell that way too.  with forkIO and (ChanT a)
13:35:21 <mmorrow> leimy: otoh, shared libraries add at least one more level of indirection beyond statically linked libs, which is nothing compared to communicating with another process
13:35:58 <leimy> mmorrow: Well if the other process is communicated with through open, read, write, close, anything can talk to it.
13:36:07 <leimy> vs having to link and program an API :-)
13:36:48 <jmcarthur_work> leimy, does plan 9 have everything communicate via a text api like unix?
13:36:54 <andrewz> what library to use for downloading arbitrary files from the web that works on windows?
13:36:55 <leimy> It's nice that you can write a more or less fully featured IRC client on plan 9 in nothing but the rc shell :-)
13:37:00 <andrewz> like curl or w/e in lin
13:37:03 <Jedai> sshc: Yes it is possible, in fact it may already exist on Hackage (though I don't remember the exact package name right now, might even be Convert...)
13:37:04 <leimy> jmcarthur_work: no.
13:37:10 <mmorrow> leimy: sure, but i think that's an entirely higher level of abstraction than linking to a shared library.. where two jmp's and you're there
13:37:11 <leimy> 9p is a binary protocol for sharing anythign.
13:37:20 <leimy> you can mount a "mouse" or "screen" via 9p
13:37:21 <jmcarthur_work> leimy, ah, but it's still a stream?
13:37:40 <leimy> 9p defines messages for open read write close like behavior.
13:37:43 <leimy> so it can stream.
13:37:45 <leimy> but does not need to.
13:37:50 <leimy> there's seeking as well.
13:37:50 <jmcarthur_work> okay, messages
13:37:52 <leimy> yep
13:37:56 <jmcarthur_work> aha
13:37:58 <leimy> it's message based.
13:38:06 <bos> @src evaluate
13:38:07 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
13:38:07 <leimy> and therefore stateful.
13:38:14 <Jedai> sshc: You'll need multiparameter typeclass (an extension to Haskell98 but one that is quite accepted, has been around for a long time and is pretty stable now)
13:38:25 <leimy> a friend of mine uses 9p via Inferno to stream audio around his house :-)
13:38:29 <jmcarthur_work> leimy, have you seen tangible functional programming?
13:38:34 <leimy> but it's also a messaging protocol. :-)
13:38:39 <Jedai> sshc: (supposing you try to recode it yourself)
13:38:41 <leimy> jmcarthur_work: I don't think so.
13:39:08 <jmcarthur_work> leimy, it's something conal elliott has worked on in the past. you might find it interesting
13:39:22 <Jedai> sshc: And what I said suppose that the show/read pair isn't already doing what you want ?
13:39:32 <Jedai> > read "45" :: Int
13:39:34 <leimy> jmcarthur_work: Very likely.  I like a lot of Conal has worked on :-)
13:39:35 <lambdabot>   45
13:39:38 <Jedai> > show 45
13:39:39 <lambdabot>   "45"
13:39:45 <jmcarthur_work> leimy, it's basically unix-like, but typed data for communication
13:39:47 * leimy is on and off working on a haskell 9p implementation.
13:39:52 <andrewz> does http://hackage.haskell.org/packages/archive/download/0.3/doc/html/Network-Download.html require any additional libraries on windows?
13:39:56 <leimy> but I've had very little time for it.
13:40:06 <sw17ch> actually, is there a way to kill a thread currently in a foreign call at all?
13:40:09 <leimy> jmcarthur_work: that's pretty awesome.
13:40:09 <andrewz> after its compiled
13:40:21 <leimy> I like the idea of typed data channels
13:40:22 <jmcarthur_work> leimy, he had a rather ugly gui for it, but the idea is very awesome
13:40:30 <leimy> oh yeah
13:40:30 <leimy> TV
13:40:33 <leimy> Tangible values.
13:40:35 <leimy> I've seen it.
13:40:38 <jmcarthur_work> aha
13:40:53 <leimy> Every time I talk in here, he keeps referring me to it :-)
13:40:57 <jmcarthur_work> heh heh
13:41:00 <Jedai> andrewz: You can pretty much assume it doesn't, except when it don't install out of the box, on Windows
13:41:43 <leimy> anyway.  I don't hate shared libs.  I just think it's really nice that right now, with Haskell, if I build on linux box A, and copy to linux box B.  I basically only need libgmp on B to run it.
13:41:54 <leimy> and no one has to know it's written in haskell at all :-)
13:42:14 <leimy> And if Integer were implemented in Haskell, we wouldn't need libgmp either :-)
13:42:19 <andrewz> Jedai: ok thanks!
13:42:22 <mmorrow> sw17ch: i don't think so, save some horrific hackery with signals
13:42:30 <andrewz> http://www.anty.info/2009/07/18/how-to-compile-haskells-network-library-on-windows/ hmm hoping that wont be an issue
13:42:46 <dcoutts> leimy: you can build ghc-6.12 with or without libgmp, there's a slower pure Integer impl
13:42:46 <sw17ch> mmorrow, yeah... i was afraid of this answer
13:42:47 <hackagebot> union-find 0.1 - Efficient union and equivalence testing of sets. (ThomasSchilling)
13:42:57 <leimy> dcoutts: awesome!
13:43:01 <sw17ch> mmorrow, i think i'm stuck with reducing my foreign function to use poll :(
13:43:06 <leimy> dcoutts: I almost never use Integer in my code
13:43:12 <leimy> so i suspect I would not be impacted.
13:43:21 <mmorrow> sw17ch: :(
13:43:22 <dcoutts> leimy: that and the shared libs is something we've been working on for the IHG
13:43:36 <sw17ch> mmorrow, it makes me sad
13:43:39 <elliotstern> Is there a function which would print out the time that it takes to run something?
13:43:46 * sw17ch proposes we add murderThread to the stdlibs
13:43:53 <leimy> dcoutts: yeah.  I suppose that people would want shared libs since that's what they're used to.  But I've learned to live happily without them on other systems.
13:44:13 <dcoutts> leimy: it's primarily so they can make plugins for other apps
13:44:19 <leimy> Inferno is neat as it doesn't link anything... everything is loaded late! :-)
13:44:25 <roconnor> > 1/0 :: CReal
13:44:30 <lambdabot>   mueval-core: Prelude.read: no parse
13:44:31 <lambdabot>  mueval: ExitFailure 1
13:44:43 <leimy> dcoutts: Sure, but if things all spoke through the filesystem... anything talking to files is automatically plugged in :-)
13:44:45 <nominolo> dons: is scion's link time really an issue?
13:45:00 <ksf> sw17ch, foreign export killThread?
13:45:00 <nominolo> dons: I figured the compilation time of ghc-syb was the worst
13:45:12 <mmorrow> sw17ch: i wonder how you could implement that
13:45:15 <Jedai> andrewz: apparently he runs into some problem trying to recompile "network" (the basic network package for Haskell) but that should already be in the platform IIRC so you shouldn't need to recompile it any time soon
13:45:32 <dcoutts> leimy: dunno if that model works for things like Excel plugins
13:45:43 <sw17ch> ksf: ?
13:45:47 <leimy> It does not... because everyone hasn't drank the same Kool Aid :-)
13:45:49 <dcoutts> leimy: one often needs fairly detailed and typed interfaces
13:45:59 <sw17ch> mmorrow, i'm not entirely sure, but i'm assuming it's going to lack a certain amount of pretty
13:46:11 <mmorrow> sw17ch: maybe with ucontext, sigaltstack, and hax :)
13:46:21 <leimy> dcoutts: I don't know, I've been pretty impressed with what has been done thus far wrt filesystem based services
13:46:25 <sw17ch> mmorrow, D:
13:46:31 <leimy> the TCP/IP stack is a filesystem in Plan 9
13:46:38 <ksf> sw17ch, well, if the foreign code knows the haskell threadId and you export killThread, it should be able to kill a haskell thread.
13:46:43 <leimy> sockets is a compatibility layer on top.
13:46:57 <dcoutts> leimy: sure, but tcp is basically about streams or packets of untyped chunks of bytes
13:47:04 <sw17ch> ksf: it's more that i need to kill it from haskell space
13:47:17 <sw17ch> ksf: and killThread can't kill stuff blocking on foreign code
13:47:28 <dcoutts> leimy: so it's exactly the sort of thing that could work in the unix/p9 file model
13:47:31 <ksf> ah.
13:47:34 <Jedai> andrewz: and while network probably needs some dll on Windows, that shouldn't be a problem (if a windows don't have those dll, it can't go over the network anyway)
13:47:57 <ksf> well it gets killed after the ffi call
13:48:00 <sw17ch> the least hacky way to do this is to change my foreign code :(
13:48:02 <leimy> dcoutts: I am not saying one can get away from libraries altogether.... I just think there's a lot of libraries that could have been services.
13:48:07 * sw17ch cries
13:48:31 <dcoutts> leimy: sure, certainly there are some.
13:48:47 <leimy> I just saw two independent snmp filesystems the other day.
13:49:38 <dcoutts> leimy: I guess you end up following a REST model
13:49:56 <sw17ch> ksf: unless that's not what you were trying to get at
13:52:14 <ksf> sw17ch, I know your pain, I recently wanted to suspend a thread, also ideally inside a ffi call.
13:52:35 * sw17ch conjectures that there must be a way
13:52:51 <ksf> hacking on ghc's scheduler?
13:53:33 <mmorrow> i wonder what stack C functions called from haskell are running on
13:53:42 <leimy> dcoutts: REST is a pretty good example of a simple way to do some things yes.
13:54:57 <andrewz> is there a builtin function for this? split foo = [takewhile (/= x) foo, (dropwhile (/= x) . drop 1) foo]
13:55:23 <ksf> span.
13:55:26 <andrewz> thanks
13:55:27 <mmorrow> , break (=='.') "127.0.0.1"
13:55:28 <lunabot>  ("127",".0.0.1")
13:55:30 <ksf> but it returns a tuple
13:55:41 <ksf> :t span
13:55:44 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:55:45 <roconnor> @src break
13:55:46 <lambdabot> break p =  span (not . p)
13:56:38 <sw17ch> mmorrow, I'd be happy with a call to the pthread function to smash a thread
13:56:55 <sw17ch> killAndIDontCareWhoYouMessUpToDoIt
13:57:30 <ksf> maybe you want to make your external code a server?
13:58:10 <jethr0> heyho
13:58:45 <jethr0> @seen lemmih
13:58:46 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 55m 28s ago.
13:58:58 <randomwords> I'm trying to write to an array in paralell http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3436#a3436. Is there a way to force evaulation here - or is there some better approach?
13:59:00 <jethr0> lemmih, you here?
13:59:46 <mmorrow> sw17ch: heh, evenIfITakeHalfOfTheRtsWithMe#
14:00:19 <jethr0> anyone have much experience with the SDL bindings?
14:01:09 <jmcarthur_work> jethr0, i have some
14:01:12 <sw17ch> mmorrow, oGodWhatHaveIDone
14:01:34 <Berengal> unsafeCrashAndBurn
14:01:37 * sw17ch notes that his RTS might resemble a murder scene
14:01:44 <Martijn_> Goeienavond
14:01:54 <sw17ch> Berengal, as a note, never name a function crashAndBurn when doing flight software
14:02:27 <Berengal> sw17ch, not even the crashAndBurn function?
14:02:45 <Twey> Call it â€˜asplodeâ€™ instead
14:02:52 <pikhq> Berengal: I'd call the existence of that function a bug.
14:02:53 <sw17ch> Berengal, for some reason, the people who certify airplane software don't like anything that says "crash"
14:03:05 <sw17ch> :)
14:03:44 <Twey> Haha, seriously?
14:03:50 <Twey> You're being serious, aren't you
14:03:53 <Twey> O.O
14:04:01 <c_wraith> I can believe that.
14:04:14 <c_wraith> I worked with a military-grade AWACS simulator once.
14:04:15 <Berengal> if [[ $(grep crash $SOURCE) ]] then; echo "failed"; exit 1; else run_tests
14:04:25 <mauke> wtf
14:04:39 <c_wraith> Not that I knew how to *use* it.
14:04:42 <Twey> So what, they're afraid the pilot's going to be browsing through the source as pilots do and go â€˜OH NO IT SAYS CRASH, WE'RE ALL GOING TO DIE!!â€™?
14:04:45 <c_wraith> But I had the source!
14:04:55 <Twey> c_wraith: Haha
14:05:04 <sw17ch> Twey, it's more after the plane has crashed
14:05:14 <mauke> if grep -q crash -- "$SOURCE"; then echo failed; exit 1; else run_tests
14:05:16 <sw17ch> "hmm, the source code here says 'crash'. OMG WE FOUND THE PROBLEM"
14:05:27 <Twey> >.<
14:05:30 <jethr0> jmcarthur_work: i'm trying to figure out how to read keys.
14:05:30 * jmcarthur_work slaps his face
14:05:33 <sw17ch> :)
14:05:55 <mmorrow> hehe
14:05:55 <jethr0> it's working properly with pollEvent and waitEvent, but I really want to use getKeyState.
14:06:09 <jethr0> unfortunately it doesn't seem to be bound/ported by the SDL port ;(
14:06:12 <jjohnsson> Hello all! I'm trying to install the gnuplot package using cabal, but it says it depends on monoid-transformer >=0.0.2 && <0.1. I can only find version 0.0.1 in hackage. does anyone know what is up about this? thanks!
14:07:29 <jmcarthur_work> jethr0, ah, i have also run into a problem with things not bound in the sdl bindings. i ended up just writing a patch and giving it to Lemmih, although i'm not sure if he ever got around to integrating it
14:07:30 <jethr0> jmcarthur_work: have you done anything game-related with SDL and keyboard inputs?
14:07:43 <jmcarthur_work> jethr0, only small things
14:07:54 <Berengal> jjohnsson, clearly software ahead of it's time... I dunno, try fixing the cabal yourself and see if it builds
14:08:07 <jmcarthur_work> i used pollEvent in my case. i was making some FRP bindings at the time
14:08:20 <jjohnsson> Berengal: ok, you mean removing the >=0.02 dependency?
14:08:38 <Berengal> jjohnsson, well, at least changing it to 0.0.1
14:08:46 <jethr0> event-based keyboard handling is really annoying for games. i.e. if you keep pressing key 'a' then press 'b' and release 'b', 'a' doesn't get registered as pressed anymore...
14:08:53 <jjohnsson> Berengal: ok, I'll try that. thanks.
14:09:11 <jethr0> unless I manage state manually with keyDown and keyUp *hmmmm*
14:09:12 <Berengal> jjohnsson, perhaps fire off an email to the maintainer as well
14:09:49 <jjohnsson> Berengal: mm. first I need to figure out how to change the cabal stuff. :)
14:10:04 <jmcarthur_work> jethr0, yeah, there are some pretty dumb things that can happen
14:10:04 <jethr0> some things are a bit weird with SDL and opengl. for example, when using waitEvent instead of pollEvent, GL doesn't display anything *grumbles*
14:10:32 <jmcarthur_work> jethr0, at all, or do you just mean that it's blocked until there is an event?
14:12:07 <Berengal> jjohnsson, cabal fetch gnuplot, cd .cabal/packages/whatever, tar -xzf gnuplot
14:12:16 <jethr0> hmm, even pressing buttons didn't get any display, but maybe it was my mistake.
14:12:25 <jethr0> took a while to 'figure out' though...
14:12:42 <jmcarthur_work> i've not had such problems myself, so i suspect it's your fault in this case :)
14:12:47 <Berengal> Wait, fetch checks dependencies as well...
14:13:02 <Cale> Not to mention that keyboards themselves are really strange about what happens when multiple keys are pressed.
14:13:10 <Berengal> Is that a bug?
14:13:21 <jethr0> which is sth. that you really need when dealing with games
14:13:21 <jmcarthur_work> yeah, key event handling is really weird
14:13:44 <jmcarthur_work> it's not too bad if you just maintain state yourself
14:14:00 <Cale> If I hold down qwer and press the rest of the letter keys on my keyboard, I get: yuopshjlzxcvbnm
14:14:41 <jmcarthur_work> uiioplkjhnm
14:14:57 <jmcarthur_work> ignore the extra i, probably my fault
14:15:01 <Twey> ',.ppppppppppppppppppppppppppppppppppppppppppppppppppppppp
14:15:05 <jmcarthur_work> haha
14:15:13 <Twey> It ignores everything after the fourth keypress
14:15:14 <Cale> (It helps to turn repeat off first)
14:15:15 <jethr0> hehe, have you looked into how keyboards work? there are two contact matrices under the keys and they are actived based on a time code. by design pressing the wrong buttons at once will result in havok!
14:15:18 <roconnor> is there a haddock directive to not build the Documentation portion, and just have the synopsis?
14:15:19 <andrewz> Loading package download-0.3 ... linking ... <interactive>: /home/andrew/.cabal/lib/download-0.3/ghc-6.10.4/HSdownload-0.3.o: unknown symbol `stat64'
14:15:21 <andrewz> ghc: unable to load package `download-0.3'
14:15:22 <jjohnsson> Berengal: tried that, but there is no gnuplot file in that directory, as I thought.
14:15:37 <andrewz> what sgoing on with download?
14:15:49 <Cale> with "asdf" I get "rtyuophjlxbnm"
14:15:50 <Berengal> jjohnsson, download it manually from hackage then...
14:16:00 <jjohnsson> ok
14:16:01 <sm> andrewz: it has that weird bug.. won't work in ghci
14:16:06 <sm> or install on mac
14:16:06 <Twey> fgcrl/=dhtns-\bmwvz
14:16:14 <Twey> = ',.p
14:16:19 <jethr0> jmcarthur_work: any idea what you mean by managing key state manually?
14:16:23 <skorpan> abcdefghijkl am i doin it rite
14:16:24 <Twey> Seems pretty random
14:17:27 <sw17ch> mmorrow, omg! apparently the exceptions thrown to foreign-blocked-threads also just evaporate when they aren't caught! D:
14:20:23 <Cale> sw17ch: they don't even end up killing the thread once control returns?
14:21:07 <sw17ch> Cale: i'm double checking, but it doesn't look like that's the case...
14:21:15 <sw17ch> i'll try and come up with a simpler test case later tonight
14:21:23 <sw17ch> (that is, it it's actually the case...)
14:21:39 <sw17ch> Cale: do foreign calls call "block" before entering?
14:22:54 <Cale> sw17ch: That's a good question.
14:22:58 <sw17ch> Cale: it works when i wrap the foreign call in block
14:23:43 <sw17ch> Cale: here's the example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8751#a8751
14:23:48 <Cale> sw17ch: But the OS thread which they're running on can't switch back to the Haskell runtime system until the foreign call finishes, so no matter what happens, that OS thread is going to appear unresponsive to the other Haskell threads until control returns.
14:23:52 <sw17ch> if you take the "block" out of line 8, then it never returns
14:24:16 <sw17ch> "never returns" was wrong
14:24:22 <sw17ch> i mean, it doesn't catch the killThread
14:24:36 <sw17ch> but if i wrap it in block, then it behaves as expected
14:25:06 <Cale> Interesting.
14:25:25 <Cale> I seem to vaguely recall something about 'safe' and 'unsafe' foreign calls...
14:25:39 <Cale> which might have been related to this problem
14:25:43 * sw17ch checks how he's calling
14:26:00 <andrewz> sm:  it does the same thing in runghc
14:26:05 <andrewz> does runghc use ghci also
14:26:12 <sw17ch> Cale: i'm not specifying safe or unsafe, do you know what the default is?
14:26:32 <sm> andrewz: not sure, but I have always been able to compile with it (cabal build or ghc --make)
14:26:42 <laynor_> I'm using parsec to construct a parser, I've got the hang of it, but still didn't understand well how to make a parser fail. Any help?
14:26:43 <sm> you can do the same things by using the network lib directly, with not much work
14:27:11 <Cale> ah, that was a different thing anyway... 'safe' is for foreign calls which might call back into Haskell code.
14:27:24 <andrewz> sm thanks
14:28:02 <sw17ch> Cale: unsafe is most definitely not what i want
14:28:06 <sw17ch> :)
14:32:10 <kbp> I need help. In the book, there is an expression (P <=> R) /\ ( (P/\Q) => R) . And on next line, it is simplified to "not (P (+) R)" ((+) stands for xor). Is it right or wrong? Because at first there are 3 terms P,Q,R but when simplified it's just 2 terms left P,R. I cannot simplify it by myself.
14:32:35 <mauke> let me ask my regex
14:33:57 <randomwords> I'm trying to write to an array in paralell http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3436#a3436. Is there a way to force evaulation here - or is there some better approach?
14:34:19 <int-e> kbp: it's correct. although I'd argue that replacing (P <=> R) by not (P (+) R) is not a simplification
14:34:48 <sm> andrewz: so what's your project ?
14:35:35 <kbp> int-e so it's not a simplification??? so what did they do to get that not (P (+) R) ?
14:36:05 <int-e> kbp: the ((P/\Q) => R) term only matters if P <=> Q, in which case it becomes ((P/\Q) => P), a tautology.
14:36:19 <int-e> kbp: It's equivalent, but it obfuscates matters.
14:37:03 <int-e> kbp: sigh. P <=> R, not P <=> Q.
14:37:42 <andrewz> sm: an irc bot.  one thing is i want to tell it !download:loc|url and have it read the url as a bytestring and write to the file.  should i sue the lazy version of this, since Network.download is bugged? http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
14:38:13 <sm> aha, I'm working on one of those too
14:38:17 <andrewz> neat
14:38:18 <yitz> > and [((p && r) || (not p && not r)) && (not (p && q) || r) == (p || r) && not (p && r) | [p,q,r] <- replicateM 3 [False,True]]
14:38:19 <lambdabot>   False
14:38:22 <jjohnsson> Berengal: ok, so I found version 0.0.2 of monoid-transformer at another site, and managed to install it. It then worked to install gnuplot. thanks again.
14:39:01 <kbp> int-e: unfortunately I still can't get it (silly me) sorry im just new. I'm trying hard to understand what you said :)
14:39:07 <Berengal> jjohnsson, I was just about to send an email requesting it also be uploaded to hackage, unless you've already done that
14:39:13 <sm> I used Network.Browser.browse to fetch urls
14:39:17 <sm> (network package)
14:39:37 <sm> haven't dealt with bytestrings at all
14:39:47 <jjohnsson> Berengal: no, I didn't. I'll do it later, really need to sleep now.
14:39:51 <sw17ch> Cale: so, it now responds to killThread but not to a custom Exception type
14:39:56 <Berengal> jjohnsson, I'll do it then :)
14:39:57 <sw17ch> any way, i'm confused for now... :(
14:39:57 <yitz> kbp: check the above expression, i think it demonstrates that they're not equivalent, unless i made a mistake
14:40:02 <sw17ch> i'm going to find dinner and try again later
14:40:15 <jjohnsson> Berengal: thanks! :)
14:40:53 <int-e> yitz: you're missing a not.
14:40:57 <sm> andrewz: is your bot code available ?
14:40:58 <yitz> where?
14:41:03 <int-e> yitz: before the xor
14:41:12 <yitz> ah
14:41:25 <andrewz> sm: theres not much yet but i can pastebin for u if youd like =p
14:41:27 <yitz> > and [((p && r) || (not p && not r)) && (not (p && q) || r) == not ((p || r) && not (p && r)) | [p,q,r] <- replicateM 3 [False,True]]
14:41:29 <lambdabot>   False
14:41:34 <yitz> still false
14:41:43 <sm> thanks, maybe later then!
14:41:46 <etpace_> > (+1) &&& (+3) $ 5
14:41:48 <lambdabot>   (6,8)
14:42:43 <EvilTerran> @check \a b c -> ((a == b) == c) == (a == (b == c))
14:42:43 <etpace_> :t on
14:42:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:42:46 <lambdabot>   "OK, passed 500 tests."
14:43:25 <andrewz> sm: yay my download command works :)
14:43:37 <sm> yay
14:43:48 <sm> so what's that good for ?
14:43:50 <kbp> > and [((p && r) || (not p && not r)) && (not (p && q) || r) == not ((p || r) && (not p || not r)) | [p,q,r] <- replicateM 3 [False,True]]
14:43:51 <lambdabot>   False
14:43:57 <int-e> yitz: and the precedence of == vs. && and ||
14:44:02 * sm tries to imagine lambdabot downloading stuff..
14:44:04 <int-e> > and [(((p && r) || (not p && not r)) && (not (p && q) || r)) == not ((p || r) && not (p && r)) | [p,q,r] <- replicateM 3 [False,True]]
14:44:05 <lambdabot>   True
14:44:16 <yitz> oh ho
14:44:18 <int-e> > and [((p == r) && (not (p && q) || r)) == (p == r) | [p,q,r] <- replicateM 3 [False,True]]
14:44:19 <lambdabot>   True
14:44:34 <etpace_> @djinn (a -> a -> b) -> (c -> a) -> (c -> a) -> c
14:44:34 <lambdabot> -- f cannot be realized.
14:44:41 <kbp> yitz: :)
14:45:16 <etpace_> Is there a function like on, but takes two functions and one input instead?
14:45:24 <andrewz> sm: users in that irc channel can make the server running the bot download files to whereever they want
14:45:37 <andrewz> in the home directory
14:46:47 <EvilTerran> etpace_, er... (\f g h x -> f (g x) (h x)), do you mean?
14:47:06 <etpace_> yes
14:47:13 <EvilTerran> that'd be the (e->) instance of liftA2 (or liftM2)
14:47:15 <maxstahl> whoa holy carp there's a lot of people in here. hi everybody!
14:47:25 <benmachine> hi maxstahl
14:47:28 <lispy> maxstahl: hello and welcome!
14:47:30 <int-e> etpace_: -> b, not -> c
14:47:48 <int-e> oh wait
14:47:50 <benmachine> c -> b
14:47:51 <EvilTerran> > liftA2 (f :: Expr -> Expr -> Expr) g h x -- etpace_
14:47:51 <benmachine> surely
14:47:52 <lambdabot>   f (g x) (h x)
14:48:15 <etpace_> :t liftM2
14:48:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:48:18 <int-e> @djinn (a -> a -> b) -> (c -> a) -> c -> c -> b
14:48:18 <lambdabot> f a b c _ = a (b c) (b c)
14:48:38 <yitz> > let implies x y = not x || y; iff x y = (x `implies` y) && (y `implies` x); xor x y = (x || y) && not (x && y) in and [((p `iff` r) && ((p && q) `implies` r)) == not (p `xor` r) | [p,q,r] <- replicateM 3 [False,True]]
14:48:39 <lambdabot>   True
14:48:46 <int-e> (djinn gets it wrong, but that's the type)
14:49:12 <ksf> etpace_, applicative functors?
14:49:25 <theonewhoisone> hey folks, I'm having this issue: "a.out: Error in array index".  For once, I can understand the error message, and it makes sense.  I was wondering if there is a way to get some extra information, like say which Array is being accessed incorrectly
14:49:28 <int-e> xor = (/=)
14:49:35 <ksf> :t List.(<*>)
14:49:37 <lambdabot> Not in scope: data constructor `List'
14:49:38 <etpace_> yeah, I was thinking that <$> and <*> could be appropriate
14:49:41 <ksf> :t List (<$>)
14:49:42 <lambdabot> Not in scope: data constructor `List'
14:49:57 <ksf> :t [] (<$>)
14:49:58 <lambdabot>     Couldn't match expected type `((a -> b) -> f a -> f b) -> t'
14:49:58 <lambdabot>            against inferred type `[a1]'
14:49:58 <lambdabot>     In the expression: [] (<$>)
14:50:02 <ksf> argh
14:50:19 <benmachine> ksf: just do it manually :P
14:50:25 <benmachine> :t (<*>)
14:50:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:50:39 <benmachine> [a -> b] -> [a] -> [b]
14:50:53 <benmachine> @src <$>
14:50:53 <lambdabot> f <$> a = fmap f a
14:50:56 <ksf> > [(*2),(+3)] <*> [4]
14:50:58 <lambdabot>   [8,7]
14:51:15 <ksf> > [(*2),(+3)] <*> [4,5]
14:51:17 <lambdabot>   [8,10,7,8]
14:51:26 <ksf> ...so it's actually more general, but does what you want.
14:52:27 <byorgey> theonewhoisone: not that I know of, unfortunately.
14:52:58 <byorgey> theonewhoisone: You may want to check out the Debug.Trace module for printing trace messages.
14:53:07 <ksf> theonewhoisone, I recommend putting assertions in strategic places.
14:53:33 <ksf> ...to have explicit bounds checks you can locate.
14:54:20 <theonewhoisone> thx
14:54:27 <ksf> otoh, you could just take it as the perfect opportunity to decide that non-total functions are evil.
14:54:38 <theonewhoisone> it's a DP problem
14:54:43 <ksf> ...and use the safe array index functions.
14:55:28 <poe> theonewhoisone: there also is http://www.cse.unsw.edu.au/~dons/loch.html
14:55:47 <EvilTerran> ksf, i guess a less extemist approach would be to ensure your code's accepted by ndm's Catch
14:56:26 <EvilTerran> (well, if you're in h98; i don't think it does many extensions, if any at all...)
14:56:45 <EvilTerran> ?where catch
14:56:45 <lambdabot> http://community.haskell.org/~ndm/catch/
14:57:24 <ksf> @where+ loch http://www.cse.unsw.edu.au/~dons/loch.html
14:57:25 <lambdabot> I will remember.
14:57:29 <ksf> that's extremely useful.
14:57:49 <theonewhoisone> yes, thanks all.
14:58:29 <maxstahl> So... can someone direct me to some links or maybe explain a little about concurrent programming in haskell? like if I have a list the items of which are independently calculated, can I easily split that processing between two processors in Haskell?
14:58:45 <maxstahl> Please? I'm procrastinating over here and I need a project.
14:58:58 <dschoepe> @type parMap
14:59:00 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
14:59:07 <jmcarthur_work> :t par
14:59:08 <lambdabot> forall a b. a -> b -> b
14:59:17 <maxstahl> Got that but I couldn't figure out how the strategies work.
14:59:23 <andrewz> how do i lift this into IO? downloaded <- openURI (drop 1 url)
14:59:28 <jmcarthur_work> there's a paper somewhere
14:59:44 <andrewz> liftIO $ downloaded <- openURI (drop 1 url) looks like bad syntax
14:59:53 <jmcarthur_work> andrewz, downloaded <- liftIO $ ...
14:59:55 <Heffalump> andrewz: move the liftIO to the RHS of the <-
15:00:04 <andrewz> ah thanks all :)
15:01:48 <EvilTerran> maxstahl, the simplest way to use multiple processors in haskell is `par`
15:02:29 <maxstahl> EvilTerran: Okay. That evaluates its arguments in parallel, right? But then how to retrieve the value of the first argument?
15:02:41 <ksf> ...by acessing it.
15:02:56 <ksf> par just forces the thunk, so it's ready when you later access it.
15:02:57 <maxstahl> . . . oki.
15:03:08 <EvilTerran> maxstahl, well, it's only useful if the first argument is of the sort where it's evaluated result will be cached
15:03:15 <EvilTerran> generally, that'll mean a variable name
15:03:18 <Berengal> par doesn't force anything neccessarily
15:03:58 <dschoepe> > let x = 2^23 in x `par` 42 + x
15:03:59 <lambdabot>   8388650
15:04:09 <Makoryu> andrewz: Remember that in "foo -> bar," foo is always a pattern (as in, an argument in a function definition) and bar is a function whose return value is matched against that pattern
15:04:10 <maxstahl> So say I had two values that were declared earlier in a let or something, a and b, and I had "a `par` b", it would compute the two in parallel and the result would be "b", which I could use in another statement?
15:04:24 <Makoryu> maxstahl: Yep
15:04:27 <EvilTerran> maxstahl, so something like "let x = ...; y = ... in x `par` y `par` (x,y)" may get x and y evaluated in parallel, and because they're variable names, the computed value sticks around while the names are in (temporal) scope
15:04:45 <maxstahl> Or if I wanted to perform a filter or a map in parallel, evaluating as many terms simultaneously as I had processors to spare?
15:05:00 <maxstahl> EvilTerran: neat!
15:05:09 <pcc1> I need to be able to change a package property (specifically, libraryDirs) when I install a package using Setup.hs install.  is it possible to do this?
15:05:24 <EvilTerran> maxstahl, yep, you could do that with something involving foldr and `par` fairly easily
15:05:33 <ksf> pcc1, have a look at the .cabal file
15:05:34 <Makoryu> maxstahl: Note that the arguments of par are not necessarily evaluated in different threads. Whether or not to do that is determined by the processor loads at runtime, IIRC
15:05:45 <Berengal> maxstahl, a `par` b creates a spark, which /may/ be picked up by another thread and run. If it does, a is evaluated to whnf. If something else evaluates a first, or if a drops out of scope, the spark is discarded
15:05:47 <Makoryu> maxstahl: But that's usually what you want anyway
15:05:52 <EvilTerran> maxstahl, the details of `par` are described in http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html#id559227
15:06:19 <etpace_> Whats the function with type (a -> f b) -> f a -> f b, it's concatMap for lists I think?
15:06:25 <pcc1> ksf: do you mean the extra-lib-dirs field in the .cabal file?
15:06:42 <ksf> uhh I don't know what you want to do, but the .cabal file is the right place.
15:06:55 <int-e> @type (=<<)
15:06:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:06:56 <maxstahl> Thanks tons guys! I'm gonna go tinker for a few then maybe come back if it blows up again.
15:06:58 <Makoryu> maxstahl: Also, there are already some parallelized versions of list functions, like parMap, so you don't have to write your parallel maps by hand
15:07:10 <ksf> (or Setup.hs and files it uses if the build system is more involved, but let's not hope that)
15:07:12 <lispy> :t concatMap
15:07:14 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:07:14 <andrewz> hmmmm openURI works fine but if i make an erronous call then try a correct one again it just gives the same error
15:07:17 <pcc1> ksf: I need the library-dirs property to be set to one thing at build time and something else at install time
15:07:18 <Vanadium> Does newForeignPtr_ p cause the memory allocated at p to be garbage-collected if I stop refering to it?
15:07:25 <maxstahl> Makoryu, I saw that too and it'd be extremely useful right about now, but I've not been able to get it to work.
15:07:31 <andrewz> restarting the program fixes this
15:07:48 <Berengal> maxote, also, take a look at the monoids package. It has some pretty nifty things relevant to parallell execution
15:07:55 <Berengal> maxstahl*
15:08:20 <etpace_> thanks
15:08:31 <maxstahl> Berengal: thanks!
15:08:40 <ksf> pcc1, wth would you want to do that?
15:09:15 <pcc1> because the library-dirs do not exist at build time.  the rest of the library is built together with th haskell package
15:09:17 <Makoryu> maxstahl: parMap takes an extra parameter (a Strategy function) which you can use to fine-tune the amount of data that gets parallelized
15:09:46 <maxstahl> Makoryu: hmm. Okay. That's actually the part that'd tripped me up.
15:09:59 <Makoryu> maxstahl: RWH gives some examples of strategies
15:10:11 <randomwords> So if you do a `par` b where b does not depend on a, will a's spark ever be computed at all?
15:10:27 <randomwords> i.e. reduced to whnf
15:11:26 <int-e> randomwords: it might be, but there's not guarantee of that.
15:12:17 <randomwords> But you can force it with something like seq or pseq?
15:12:46 * ksf thinks you're trying to abuse cabal
15:13:21 <Makoryu> randomwords: You can request it with seq, and force it with pseq, IIRC
15:14:34 <pcc1> ksf: we considered a number of approaches and decided that this would be the best approach.  the haskell package is very closely coupled to the library, so it lives in the same source tree.
15:15:54 <maxstahl> Ok so I wrote a little something with `par` and it's only running on one core of my cpu.... Is there a funky command line option I'm missing when I compile or some other such nonsense?
15:15:55 <ksf> I guess you're going to have to do some manual cabal magic, then.
15:16:11 <ksf> that is, write a more elaborate Setup.hs than "simpleConfig"
15:16:14 <pcc1> nothing as ugly as "sed" on the package.conf, I hope.
15:16:32 <randomwords> So if have an expensive function f, then let r = f x in r `par` (r `pseq` f y), would garuntee that f x got computed, possibly in it's own thread?
15:16:39 <ksf> you can fine-tune about everything in this way.
15:17:08 <randomwords> maxstahl: +RTS -Nx
15:17:17 <maxstahl> !
15:17:34 <ksf> (and make your package depend quite a lot on a specific cabal version)
15:17:57 <byorgey> maxstahl: where x is the number of cores
15:18:07 <etpace_> Is there a function that when applied to type (,) e, has something like: foo f (a,b) = foo a b
15:18:09 <maxstahl> Yeah it didn't like that. What flags do I use when I compile it?
15:18:15 <etpace_> f a b*
15:18:19 <randomwords> -threaded
15:18:26 <byorgey> etpace_: curry
15:18:30 <lispy> etpace_: curry/uncurry
15:18:45 <etpace_> :t curry
15:18:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:18:47 <byorgey> > curry (\(a,b) -> a + b) 2 3
15:18:48 <pcc1> ksf: thanks. I'll look into it.  (I really think there should be built in support for this.  I imagine quite a few people may need to build packages in this way)
15:18:48 <lambdabot>   5
15:19:15 <etpace_> :t uncurry
15:19:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:19:30 <etpace_> thanks
15:20:16 <maxstahl> lol lame now it's two threads but it's not running on more than one cpu....
15:20:27 <ksf> mmmhhh... 1000 times unsafePerformIO and a lock...
15:21:03 <ksf> we don't, by any chance, have something on hackage that does the dirty work of caching IO results for me, do we?
15:21:36 <dons> almost certainly
15:21:40 <ksf> maxstahl, compile -threaded
15:21:40 <dons> everything is on hackage
15:21:50 <ksf> ...and use +RTS -N<cpus>
15:22:04 <dons> maxstahl: you'll want to compile in the SMP runtime. ghc -O2 -threaded --make Foo.hs
15:22:08 <dons> ./Foo +RTS -N4
15:22:11 <dons> if you have 4 cpus
15:22:50 <ksf> dons, you not quoting it from the back of your head makes me think it's unexistant, as I would think some type construct is impossible if oleg doesn't come up with a solution from the back of his head.
15:23:06 <Taejo> @faw can haskell do the dirty work of caching IO results for ksf?
15:23:06 <lambdabot> The answer is: Yes! Haskell can do that.
15:23:32 <Taejo> @faq can haskell know I meant FAQ when I typed FAW?
15:23:33 <lambdabot> The answer is: Yes! Haskell can do that.
15:23:34 * ksf is already failing to find the category "black magic" on haskell
15:23:45 <maxstahl> whoooooaaaa alright now I get an error /var/folders/WR/WRdMxccjFLCU3MOYqOc48k+++TU/-Tmp-//ghc11011_0/ghc11011_0.hc:1631:0:
15:23:45 <maxstahl>      warning: implicit declaration of function â€˜newSparkâ€™
15:23:46 <maxstahl> my my... maybe my ghc is messed up?
15:23:51 <dons> look for say, 'cache' or 'memo'
15:24:02 <dons> newSpark?
15:24:05 <dons> that's weird.
15:24:11 <ksf> missing --make?
15:24:11 <dons> are you using the Haskell Platform?
15:24:18 <maxstahl> GHC.
15:24:26 <maxstahl> On a mac.
15:24:42 <laynor_> how do I make a parser that recognizes any alphanumeric string but the string "foo" ?
15:24:47 <laynor_> using parsec I mean
15:25:54 <ksf> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/Acme-Time-Now.html   .oO
15:27:04 <roconnor> unsafeNOw
15:29:44 <andrewz> whats a function that gives me a RandomGen g typeclass member based on the system time not a static seed?
15:30:01 <roconnor> @hoogle randomIO
15:30:01 <lambdabot> System.Random randomIO :: Random a => IO a
15:30:05 <roconnor> :/
15:30:17 <roconnor> @hoogle random
15:30:18 <lambdabot> package random
15:30:18 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
15:30:18 <lambdabot> module System.Random
15:30:25 <EvilTerran> laynor_, i think: notFollowedBy (string "foo" >> eof)
15:30:26 <roconnor> @hoogle++
15:30:26 <lambdabot> System.Random class Random a
15:30:27 <lambdabot> package random-access-list
15:30:27 <lambdabot> package RandomDotOrg
15:30:30 <roconnor> bah
15:31:17 <roconnor> andrewz: getStdGen
15:31:18 <andrewz> @hoogle RandomGen g => IO g
15:31:18 <lambdabot> System.Exit exitFailure :: IO a
15:31:18 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
15:31:18 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
15:31:30 <andrewz> roconnor: thanks
15:31:36 <EvilTerran> laynor_, well, notFollowedBy (string "foo" >> eof) >> many (satisfy isAlphaNum)
15:31:40 <roconnor> andrewz: or maybe newStdGen
15:31:42 <Cale> There's something stupid about the type of notFollowedBy which makes that fail
15:31:49 <roconnor> depending on exactly what you want to do
15:31:50 <EvilTerran> ?hoogle notFollowedBY
15:31:50 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
15:31:50 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show t) => ParsecT s u m t -> ParsecT s u m ()
15:32:04 <Cale> It seems to require a parser which returns a value of the token type, for no good reason.
15:32:18 <Cale> It's a completely arbitrary restriction
15:32:18 <laynor_> EvilTerran: going to try using notFollowedBy :)
15:32:29 <EvilTerran> Cale, er, true; that's a little weird.
15:32:48 <Cale> If I recall correctly, if you wrote your own notFollowedBy, using the inferred type rather than the stupid type which the library has, it will work.
15:32:51 <randomwords> I've changed this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8754#a8754 to use pseq to try to force evalutation, but it still doesnt work. Any idea what's going wrong?
15:32:52 <EvilTerran> laynor_, although that only works if you're after the entire (remaining) input
15:33:02 <olsner> Cale: have you reported this bug to the maintainers? :)
15:33:05 <laynor_> that's not the case unluckily
15:33:29 <Cale> :t let notFollowedBy p = try (do{ c <- p; unexpected (show [c]) } <|> return ()) in notFollowedBy
15:33:31 <lambdabot> Not in scope: `try'
15:33:31 <lambdabot> Not in scope: `unexpected'
15:33:34 <Cale> er, right...
15:33:47 <Cale> :t let notFollowedBy p = Text.Parsec.try (do{ c <- p; Text.Parsec.unexpected (show [c]) } <|> return ()) in notFollowedBy
15:33:49 <lambdabot> Couldn't find qualified module.
15:33:51 <Cale> hmm
15:34:04 <andrewz> roconnor: hmm neither of those work, trying to generateKeyPair http://hackage.haskell.org/packages/archive/RSA/1.0.2/doc/html/Codec-Crypto-RSA.html
15:34:14 <Cale> oh, pff
15:34:25 <EvilTerran> laynor_, if you're after the maximal alphanumeric prefix of the (remaining) input, but failing if that happens to be "foo", the thing to do would be to pull off the alphanumeric prefix with many (satisfy isAlphaNum), and then fail if that string =="foo"
15:34:27 <Cale> right, it's the unexpected (show [c]) which is killing it
15:34:34 <roconnor> andrewz: I hope this isn't for serious work
15:34:45 <andrewz> roconnor: oh? why not?
15:34:58 <Cale> Er, no, that's not it.
15:35:14 <laynor_> EvilTerran: what's not clear for me is how do I cleanly fail
15:35:15 <roconnor> andrewz: hmm, I think system random is no good for security, particularly Haskell's system random.
15:35:16 <Cale>  (Show t1, Stream s m t) => ParsecT s u m t1 -> ParsecT s u m ()  is the inferred type
15:35:29 <andrewz> roconnor: its for testing, ill generate with something else in production
15:35:43 <roconnor> andrewz: that's fine
15:36:11 <roconnor> andrewz: let's use newStdGen cause it is safer. (though I think getStdGen would work for what you want).
15:36:55 <roconnor> do {gen <- newStdGen; return (generateKeyPair gen someInt)
15:36:58 <roconnor> }
15:37:05 <nominolo> Hm, is there a growable-array type?
15:37:07 <EvilTerran> laynor_, perhaps (do s <- many (satisfy isAlphaNum); if s == "foo" then unexpected "foo" else return s)?
15:37:24 <jfoutz> nominolo: bytestring?
15:37:35 <nominolo> nah, I need pointers
15:37:45 <laynor_> mhh ok, seems like unexpected is what I was looking for! Thanks :)
15:37:50 <nominolo> i.e., Array Int a
15:37:53 <roconnor> pointers!
15:38:08 <jfoutz> nominolo: hmm. i don't think so.
15:38:16 <EvilTerran> laynor_, although that on its own would be a full failure; you'd need to wrap it in try (...) if you want to be able to fall through to another alternative after a parse failure
15:38:18 <Cale> yeah, that seems to be the way to go
15:38:58 <nominolo> well, really I want a variant of DiffArray that magically resizes itself.  But the primitves are not exposed
15:39:21 <andrewz> roconnor: thanks didnt know it was in IO
15:39:33 <EvilTerran> laynor_, i found getting the knack for knowing where to put "try" to make my parsers work to be the hardest part of learning how to use parsec; the sacrifices we make for speed, eh ;)
15:40:16 <roconnor> andrewz: ah, well newStdGen definitely needs to be in IO.  whether getStdGen needs to be in IO is a topic of huge debate.
15:40:31 <laynor_> indeed :)
15:40:43 <jmcarthur_work> me too
15:40:55 <jmcarthur_work> (try)
15:41:14 <jfoutz> nominolo: i'd do the standard hash table thing, but instead of 1/2 full for grow and 1/4th for shring, just do double size on full halve size on 1/4. ammortized O(1), but that may not be good enough.
15:41:34 <jfoutz> s/shring/shrink/
15:42:31 <jmcarthur_work> nominolo, what are you indexing on? Int?
15:42:38 <nominolo> yup
15:42:38 <jmcarthur_work> nominolo, if so, take a good hard look at IntMap
15:42:49 <nominolo> well...
15:43:08 <dsturnbull> hey, anyone know how to get ghc going in snow leopard?
15:43:08 <nominolo> I'm using it for union-find on hundreds of type variables
15:43:11 <jmcarthur_work> it's essentially constant time lookup
15:43:43 <jmcarthur_work> O(min(n, W)), where W is the number if bits in Int
15:43:44 <nominolo> jmcarthur: well... not Array-constant
15:44:04 <nominolo> Yeah, I might use that for now, though
15:44:07 <andrewz> @hoogle [Char] -> ByteString
15:44:07 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
15:44:07 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
15:44:07 <lambdabot> Prelude read :: Read a => String -> a
15:44:08 <jmcarthur_work> hundred doesn't seem to be a large number to me
15:44:12 <jmcarthur_work> *hundreds
15:44:30 <copumpkin> seems like we could make an IntegerMap using pretty much the same ideas as an IntMap
15:44:40 <jmcarthur_work> nominolo, also, DiffArray performs very badly. i don't know how it compares to IntMap, but i would not be surprised if IntMap performs better
15:44:41 <copumpkin> it could even fall back on IntMap for the S# constructor
15:44:46 * Heffalump seeks out his passport for going to ICFP
15:44:58 <jmcarthur_work> copumpkin, somebody has made an EnumMap
15:45:22 <Berengal> copumpkin, do you expect needing more than maxInt - minInt keys?
15:45:24 <jmcarthur_work> not the same, but more general than IntMap
15:45:25 <copumpkin> jmcarthur_work: yeah, but Enum is a silly class that forces its elements to mappable to Ints
15:45:32 <Berengal> Or do you simply want the extra key space?
15:45:34 <jmcarthur_work> yeah :(
15:46:21 <copumpkin> Berengal: if I have a very wide range of Integers being stored in there
15:46:26 <ksf> should I use IO () instead of "withFace :: FilePath -> Integer -> (Face -> IO a) -> IO a" to prevent people from returning my alloca'd pointer?
15:46:27 <copumpkin> it'd be nice to not have to worry about it :P
15:46:32 <nominolo> Heffalump: you need a passport for that?
15:46:43 <jmcarthur_work> copumpkin, that is a nice idea. do it! :)
15:46:49 <nominolo> jmcarthur: yeah, I shouldn't try to optimise too soon
15:46:54 <copumpkin> jmcarthur_work: maybe I shall!
15:47:00 <copumpkin> IntegralMap ;)
15:47:03 <jmcarthur_work> heh
15:47:04 <Heffalump> nominolo: well, they don't even speak English up there!
15:47:14 <nominolo> lol
15:47:27 * Heffalump was trying to persuade his colleague that he needs to change his money too
15:47:46 <nominolo> Heffalump: well, I was able to understand SimonM's wife.  So I'm hopeful
15:49:36 <dons> Heffalump: how do you say 'beer' in scots?
15:49:53 <nominolo> bear?
15:49:53 <Heffalump> drink! feck! arse! girls! Oh, wait, that's Ireland.
15:50:01 <Phyx-_> :O
15:51:13 * benmachine notes mention of the british isles and starts paying attention
15:51:31 <elliottt> Heffalump: that's odd timing.  i've just been watching that whole series :)
15:52:22 * ksf is surprised he didn't get any segfaults, yet.
15:52:37 <nominolo> dons: You might want to google videos for Taggart
15:52:47 <Heffalump> nominolo: that's Glasgow. Whole different country in itself, really.
15:53:01 <nominolo> Ah, yes, I heard something like that
15:53:32 <nominolo> I've also been told that north of Glasgow the friendliness decreases quickly
15:53:42 <maxstahl> Okay so... I now feel super stupid, but all my troubles have now been solved after upgrading GHC. I'd installed it with macports so I didn't realize the version I had was ancient (6.6).
15:53:42 <Heffalump> nominolo: that's entirely untrue IME
15:54:21 <Heffalump> I guess some of the Highlands and Islands communities might be a bit anti-outsider, but the area also relies heavily on tourism
15:54:30 * EvilTerran DOH!s
15:54:51 <EvilTerran> i'm in scotland now, visiting my parents; i have to be back in the middle of england by tuesday >.<
15:54:57 <Heffalump> fule!
15:55:04 <Heffalump> come to the hack day, anyway
15:56:17 <dsturnbull> how can i pass CFLAGS to ghc during ./configure? it's complaining that: 32-bit absolute addressing is not supported for x86-64
15:56:57 <EvilTerran> Heffalump, which day's that?
15:57:01 <nominolo> dons: http://www.youtube.com/watch?v=flvJNw7heDo
15:57:31 <Heffalump> EvilTerran: Sunday
15:57:38 <Heffalump> with some wandering around Edinburgh on Saturday
15:58:44 <EvilTerran> i may not have the time, but we'll see
15:59:42 <roconnor> http://www.reddit.com/r/Coq/comments/9euhy/coqoban_a_coq_implementation_of_sokoban_the/
16:04:15 <Berengal> "ksok2coqsok.hs" - He couldn't have chosen a better name for that script?
16:05:48 <nominolo> Well, there's the theory that Coq has gotten that name just to piss of all the English-speaking people
16:05:59 <dancor> anyone know why Text.Parsec.Language.javaStyle has nestedComments = True
16:06:05 <dancor> i thought java didn't have nested comments
16:06:14 <dancor> e.g. http://en.wikibooks.org/wiki/Java_Programming/Syntax/Comments#Comments_may_not_be_nested
16:06:27 <jmcarthur_work> sounds like an oopsie?
16:06:33 <dancor> ok
16:06:33 <hrehf> http://asset.soup.io/asset/0439/7050_e015.jpeg
16:06:36 <Berengal> dancor, you can "nest" line-comments... I doubt that counts though :|
16:06:37 <hrehf> whoops
16:06:46 <hrehf> wrong channel, sorry :(
16:10:11 <jfoutz> dancor: it might be from stuff like /* // */ or // /* I'm not sure if parsec represents single line and multi line comments as the same thing.
16:13:05 <randomwords> Is there any way to make `par` play nicely with the IO monad?
16:13:17 <jmcarthur_work> randomwords, you want forkIO
16:13:26 <jmcarthur_work> par is for parallelism, forkIO is for concurrency
16:13:27 <randomwords> Ah, thanks
16:16:36 <hackagebot> hircules 0.3.92 - IRC client (JensPetersen)
16:19:36 <sm> more irc stuff
16:19:55 <ksf> how do I access a const struct in c2hs?
16:20:14 <ksf> err no not a const struct, but a const array.
16:20:15 <sm> nifty. http://haskell.org/hircules/
16:20:25 <ksf> ...of structs.
16:20:56 <jethr0> @help
16:20:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:23:15 <jethr0> @tell lemmih i'm wondering why getKeyState is not implemented in the SDL binding. should i work on a patch or was there a reason for not implementing it?
16:23:15 <lambdabot> Consider it noted.
16:23:35 <ksf> ...I can't just use a unary fun hook.
16:36:19 <Philonous> I just noticed how http://crow202.org/2009/derive_while_derive.jpg rather nicely explains automatic forward differentiation.
16:37:47 <ray> welcome to the best internet meme ever
16:37:48 <copumpkin> nominolo: why put your union find algorithm in IO and not ST?
16:38:38 <nominolo> copumpkin: I plan to add ST as well, but that's usually more fiddly with all the type annotiations at the use sites
16:39:00 <copumpkin> ah :)
16:41:02 <nominolo> The problem with both IO and ST is that you can't really go back to a previous state
16:47:46 <BMeph> byorgey++
16:47:57 <copumpkin> BMeph++
16:48:47 <BMeph> copumpkin: ?
16:49:00 <copumpkin> oh I dunno :)
16:49:10 <Heffalump> nominolo: why does ST require more type annotations than IO?
16:49:44 <hackagebot> hoauth 0.1.1 - A Haskell implementation of OAuth 1.0 protocol. (DiegoSouza)
16:49:46 <nominolo> Heffalump: Well, you always have that extra free type variable
16:49:54 <Heffalump> but that's the whole point
16:50:13 <Heffalump> you want to keep it free, and it ought to unify with other uses in the same thread automatically, shouldn't it?
16:50:28 <nominolo> Yeah, but my real problem is that neither IO nor ST gives me a safe way to make something temporarily read-only
16:50:30 <Heffalump> that said, I vaguely recall having to give some explicit type signatures with ST, but I can't think why now
16:51:00 <nominolo> Heffalump: Type inference is a bit trickier with higher-rank types
16:51:12 <Heffalump> the higher-rank type only arises at the runST use site, though
16:51:28 <Heffalump> everywhere else it's standard HM on a phantom type
16:51:34 <nominolo> right
16:51:58 <Heffalump> and since IO doesn't have a run command (obvious exception aside), the comparison doesn't really hold
16:53:28 <ksf> I want a segfault!
16:53:34 * copumpkin pulls out his inverse ackermann(a, a)
16:53:44 <ksf> It just can't be that I'm doing c-level hacking and there are _no_segfaults_whatsoever_
16:53:46 * copumpkin dives in and analyzes nominolo's code
16:53:58 <copumpkin> aha!
16:54:15 <copumpkin> ksf: add some in!
16:55:00 <nominolo> copumpkin: It ain't pretty
16:55:19 <ray> ksf: maybe you accidentally learned C
16:55:31 <copumpkin> ray: you accidentally the verb :/
16:55:41 <nominolo> Heffalump: ok, I mainly wanted to avaid to contaminate my client code with that phantom var unless I need to
16:56:04 <ksf> I can't even access that array out of bounds, as I have to pass a haskell enum to the c function...
16:56:31 <ray> copumpkin: yo dawg i heard he liked verbs so i put a verb in his sentence so he could understand what the hell i was saying
16:56:32 <Heffalump> fair enough
16:56:39 <copumpkin> lol
16:57:13 <ray> ksf: that pesky typechecker spreads its contamination of safety
16:57:22 <ksf> gnargh. I can't make that function pure 'cos I've got to peekCAString
16:57:27 <ray> solution: lots of unsafecoercing
16:57:47 <nominolo> seriously, though, safety can be annoying
16:57:55 <nominolo> or rather the proof burden
16:58:07 * jmcarthur_work has not found it annoying
16:58:09 <McManiaC> is anyone familiar with the XHB lib? why is there no disconnect-function? do i need it?
16:58:12 <ray> well, he's complaining about not having any segfaults...
16:58:49 <ksf> ...I guess the clearer way would be to make the freetype header generate a haskell list instead of a c array, but if I do that I get a lot of c stuff that ghc won't grok.
16:59:09 <ksf> *cleaner
16:59:42 <ksf> I'm quite fond of linker errors lately, though.
17:01:55 <Berengal> Proving properties can be annoying. Bugs are more annoying. There's nothing as distracting to a train of thought as code that doesn't work
17:02:32 <Berengal> Except perhaps code that relies on correct sequencing
17:03:00 <nominolo> Well, I find code that doesn't typecheck a bit more annoying
17:03:24 <Berengal> I don't write code that doesn't typecheck
17:03:37 <Berengal> Well, I do, but I always typecheck before I flush it from my mental cache
17:03:58 <ray> i accidentally the whole mental cahce
17:04:14 <ray> copumpkin: happy now? i even made a typo :(
17:04:27 <copumpkin> aw
17:04:45 <Guest94159> Vivian Vance would have been 100 years old this month.
17:05:08 <copumpkin> Guest94159: good to know
17:07:04 <nominolo> "This visage, no mere veneer of vanity, is a vestige of the vox populi, now vacant, vanished."
17:07:37 <ksf> why am I caring about error strings if I can just derive Show for my enum?
17:21:12 <ksf> does ghc have a -MM-like option?
17:26:34 <nominolo> what's that?
17:27:25 <ksf> a switch that makes gcc output a file's dependencies as a make rule.
17:27:40 <Stinger> hmm bindings-posix doesn't want to install
17:29:11 * ksf wallows in wellness
17:29:38 <ksf> the utter beauty and comfort of pkg-config is mindboggling.
17:30:29 <Stinger> it can't seem to find bindings-common which I just installed :(
17:30:48 <ksf> nowadays, you can use Makefiles for tasks that made people invent atrocities like autoconf.
17:30:58 <nominolo> ksf: ghc -M
17:31:19 <nominolo> cabal can generate a makefile, too
17:31:39 <ksf> ghc -M seems like a noop here.
17:33:06 <ksf> wtf it appends directly to the makefile...
17:33:39 <nominolo> there's an extra option where you can specify a custom file
17:33:47 <nominolo> see the user's guide
17:44:28 <ksf> it's not at all as useful as gcc's -M* family.
17:44:43 <ksf> ...there's a reason that one works filewise.
17:45:04 <ksf> and it's usual practice to sed the output further
17:45:38 <ksf> ...and then include 1000 output files into your makefile, not mess with it.
17:46:41 <ksf> ...somewhere, I should still have an oomakefile that can automagically track C dependencies, as long as your header / source files follow some sane rules.
17:47:44 <badkins> Can anyone provide some insight regarding how one might get similar utility to what you might do in Smalltalk, Ruby, etc. by asking an object if it provides a method, and if so, calling it? I expect I would have to anticipate the possibility in the type system somehow.
17:47:57 <ksf> you people made me code ocaml, just because you didn't write a haskell make, yet!
17:48:44 <roconnor> limit :: Cont CReal Integer
17:48:45 <ksf> badkins, see http://homepages.cwi.nl/~ralf/OOHaskell/
17:48:56 <ksf> (and don't be afraid of the abyss named oleg)
17:48:57 <roconnor> I see continuations everywhere, even where they shouldn't be
17:48:59 <badkins> e.g. may_modify_object?(user, object)  and inside this function, delegate to object.user_may_modify(user)
17:49:12 <jmcarthur> ksf: haskell make? like... cabal? or do you mean more general?
17:49:19 <ksf> more general.
17:49:20 <jmcarthur> isn't there something called hake inspired by rake?
17:49:22 <badkins> I'm fine with leaving my OO leanings behind :) It's not objects I'm wanting but runtime decision making.
17:49:41 <badkins> So I'm looking for the "Haskell way" even if it's fairly foreign.
17:49:41 <copumpkin> badkins: aha, that's a good attitude :) then you want typeclasses
17:49:42 <ksf> something like http://omake.metaprl.org/index.html , but pure.
17:50:22 <ksf> why is everyone else thinking about the same topics as me?
17:50:25 <badkins> In the Ruby/Smalltalk case, the "object" may not even be aware of authorization, but if it is, I would delegate to it.
17:50:36 <badkins> With Haskell, I think I'd have to anticipate the need via a typeclass, right?
17:50:55 <badkins> may_modify_value(user, anInstanceOfAType)
17:51:06 <ksf> typeclasses are interfaces, so to speak.
17:51:10 <badkins> where the 2nd arg would have to provide a function?
17:51:21 <badkins> can you have optional functions in a typeclass ?
17:51:25 <ksf> ...you implement one or more for your "object"
17:51:39 <ksf> ...just use two typeclasses.
17:51:48 <Makoryu> badkins: The advantage of typeclasses is that you define each type separately from its instance in a typeclass
17:51:57 <ksf> the thing that you don't get by default, with haskell, is inheritance in the oo sense.
17:52:02 <badkins> that's fine
17:52:04 <ksf> ...but that's a good thing, as oleg proved.
17:52:07 <badkins> yes
17:52:08 <badkins> :)
17:52:19 <elliotstern> are you allowed to refer to previously defined local variable in a where clause?  In other words, is where like Common Lisp's let, or like let*?
17:52:32 <Makoryu> badkins: Typeclasses are essentially Haskell's version of (static, assign-once) open classes
17:52:49 <Makoryu> elliotstern: It's like letrec
17:52:54 <ksf> where is, semantically, just like a let after the = of the function.
17:52:59 <ksf> it's only syntax that differs.
17:53:06 <elliotstern> Makoryu: Thanks
17:53:07 <Makoryu> elliotstern: Actually, any block of definitions is like letrec
17:53:19 <ksf> except do.
17:53:31 <badkins> Makoryu: so could I have a typeclass where some type instances provide a function and other don't, and I can determine that at runtime?
17:53:34 <Makoryu> ksf: That's not a block of definitions, though....
17:53:55 <roconnor> mdo is like letrec again :)
17:54:01 <badkins> i.e. a type that may provide a function to determine authorization in my example
17:54:06 <Makoryu> badkins: Er, no.
17:54:12 * Makoryu scrolls up to see the actual example
17:54:50 <badkins> Makoryu: example was a function that accepts a user and a "thing" and determines if the user may modify the thing. In some cases, the thing my provide a function to answer that question - if it does, it's delegated to.
17:55:23 <dibblego> class A a where may :: User -> a -> Bool
17:55:26 <bd_> badkins: You can have a typeclass where there's a _default_ implementation for some of its elements
17:55:52 <bd_> so eg class Authorizer t where isAuthorized :: t -> User -> Bool; isAuthorized _ _ = False
17:55:57 <ksf> the natural way to do authorisation with typeclasses is capability passing.
17:56:00 <dibblego> which may well be written newtype A a = A (User -> a -> Bool) without the implicit dictionary passing -- which is more like an "interface"
17:56:06 <badkins> dibblego: something like that - is it legal Haskell ?
17:56:11 <dibblego> Badger, yes
17:56:16 <dibblego> *badkins
17:56:21 <ksf> ...you "cast" down your object to a thing that only acceps that and that interface.
17:56:45 <Makoryu> badkins: You could have one of the typeclass methods be a function contained in a Maybe value. The default implementation would be "foo = Nothing" and any instance could override it to "foo = Just (\x -> whatever)"
17:56:50 <dibblego> a "default" implementation may be written: alwaysAllow = A (const . const $ True)
17:56:56 <bd_> dibblego, badkins: newtype A a = A { isAuthorized :: User -> a -> Bool }  -- better imo :)
17:57:26 <dibblego> neither is better, though one is more "like an interface" which type-classes most definitely are not
17:57:56 <ksf> you can, for example, do something like newtype NonFoldableList a = NonFoldableList [a], and then write instances for Functor and everything, just not for Foldable.
17:58:30 <ksf> therefore, you've now got an interface that can refer to any list, but doesn't implement foldable.
17:58:42 <badkins> ok, it looks like I can get there from here then - thx
17:58:54 <bd_> dibblego: typeclasses can be kinda like an interface with GADTs
17:58:59 <ksf> (which makes sense if the interface you're leaving out is CanHasLaunchMissiles)
17:59:02 <badkins> I have a couple texts I'm working through, so I should be able to understand typeclasses shortly
17:59:19 <badkins> :)
17:59:53 <Makoryu> Say, would anyone be interested in a vaguely J-like dynamic language with Haskell FFIs?
18:00:46 <elliotstern> So what is wrong with the following code?
18:00:48 <elliotstern> uniqueFactors n = if lastFactor == 1 then rest else lastFactor:rest
18:00:49 <elliotstern> 		where rest = partialUniqueFactors n
18:00:51 <elliotstern> 			  lastFactor = n `div` product rest
18:01:30 <ksf> what's the error message?
18:01:35 <ksf> (and use hpaste, please)
18:01:38 <ksf> @hpaste
18:01:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:01:44 <elliotstern> ProjectEuler.hs:87:16: parse error on input `='
18:02:06 <copumpkin> probably indentation? but we can't see it
18:02:08 <ksf> ah, you've stumbled across a mean layout rule.
18:02:13 <Gracenotes> maybe your where clauses are not indented..?
18:02:19 <ksf> lastFactor may not be indented less than rest
18:02:24 <elliotstern> they are indented
18:02:29 <Makoryu> elliotstern: Using tabs?
18:02:33 <elliotstern> yeah
18:02:34 <ksf> ...lastFactor is indented less.
18:02:38 <bd_> elliotstern: don't use tabs in haskell. :)
18:02:40 <Gracenotes> it is really annoying :/ you have to line them up, and I can't get my editor to use soft tabs...
18:02:41 <Makoryu> elliotstern: Four-space tabs?
18:02:46 <ksf> ...put rest on a new line, or indent lastFactor more.
18:02:53 <Makoryu> Gracenotes: What editor are you using?!
18:02:58 <ksf> tabs are 8 spaces in haskell.
18:03:00 <elliotstern> Thanks
18:03:11 <pr> using tabs in haskell is as evil and demonic as using unsafeLaunchWeaponsOfMassDestruction
18:03:12 <ksf> ...and will be outlawed in h'.
18:03:12 <Gracenotes> cream, on windows. I can't seem to get it right.
18:04:12 <ksf> Gracenotes, even on windoze there is vim.
18:04:18 <ksf> so where's the problem?
18:04:40 <pr> Gracenotes, even on windoze there is emacs.
18:04:43 <pr> so where's the problem?
18:04:44 <Makoryu> ksf: Cream *is* vim.... emulating Notepad
18:05:13 <Gracenotes> it is vim-based, a gui-interface to it (any sort of terminal on windows... ewch)
18:05:34 <Makoryu> Gracenotes: There's gvim on Windows, too
18:05:36 <pr> Gracenotes: than there should be sth. like .vimrc
18:05:52 <Gracenotes> it is also gvim-based, I think
18:05:57 <ksf> :set et
18:06:14 <Gracenotes> the options in the menu just aren't so clearly phrased, although I could probably fix it with 2 seconds of Googling. anyway.
18:06:16 <Gracenotes> :3
18:06:17 <ksf> :set ts=4 sw=4
18:06:21 <bd_> also :set et
18:07:25 <ksf> why spoil a perfectly good editor by making it emulate notepad?
18:07:41 <Gracenotes> huh, cream is uspposed to emulate notepad? I didn't notice
18:07:43 <bd_> ksf: Because we can.
18:08:19 <Gracenotes> comparing it to notepad seems like an insult to it...
18:23:41 <ksf> I found it!
18:23:45 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8757#a8757
18:23:54 <ksf> clearly, it's evil.
18:24:05 <ksf> ...that's why we should have a haskell make.
18:24:15 <hackagebot> moe 2009.8.28 - html with style (JinjingWang)
18:24:34 <Badger> Stylish.
18:24:56 <Makoryu> Gracenotes: Most of the interface changes in Cream are a direct result of people being annoyed that feature X or feature Y worked differently from a typical Windows app
18:26:20 <Gracenotes> the main problem I've had with it is that it doesn't seem to want to display anything CJK. Maybe it's the default font..
18:27:36 <Gracenotes> otherwise I think it's good for an easy-to-use windows text editor, and one based off gvim/vim
18:29:07 <ray> have i told you how crazy you are yet today? :)
18:29:52 <Gracenotes> I am out of my element
18:30:04 <ksf> gvim doesn't do proportional fonts.
18:30:08 <ksf> it just doesn't.
18:30:11 <ray> at least fish out of water are still in a gravity well
18:30:13 <Gracenotes> I need to adapt... to survive...
18:30:35 <ksf> how, after all, should ctrl+v work, then?
18:31:24 <ksf> btw, has yi left its sluggishness behind by now?
18:36:48 <roconnor> Design question: Should modules reexport the types that occur in the signatures of exported functions?
18:36:49 <roconnor> go
18:38:58 <Gracenotes> wouldn't said types and said functions generally be together anyway
18:39:15 <roconnor> often, but not always
18:39:33 <ray> i think so
18:39:56 <roconnor> specifically I'm thinking of my colour lib, where functions have been collected together and scattered into different modules to keep the name space cleaner.
18:40:06 <roconnor> but most functions operate on Colour
18:40:19 <zzaz> how do you declare infix functions like `mod` or `elem`?
18:40:31 <roconnor> zzaz: you don't have to any function can be made infix
18:40:34 <Gracenotes> just use backticks and the infix will come
18:41:11 <roconnor> > succ `map` [1,2,3]
18:41:12 <lambdabot>   [2,3,4]
18:41:38 <Gracenotes> unlike much of the ML family, nothing special about it.. and, note, a `f` b c == f a (b c), not f a b c...
18:42:10 <roconnor> > pred `id` 17
18:42:11 <lambdabot>   16
18:42:53 <Gracenotes> function names which contain only symbols are infix by default. function names can't mix symbols and letters/numbers
18:42:56 <ray> roconnor: actually, i take that back
18:42:57 <roconnor> ray:  someone said that I shouldn't (according to the indian-hill style manual)
18:43:00 <ray> roconnor: don't do it
18:43:01 <ray> :)
18:43:09 <roconnor> ray: current I do do it.
18:43:15 <roconnor> but I could change.
18:44:43 <roconnor> I really want to know the reasons why or why not
18:52:15 <roconnor> ray: did you have any reasons in mind?
18:53:09 <ray> sadly, no, i was just letting the neat freak and lazy bum on each of my shoulders have it out :/
18:53:41 <ray> i guess i prefer it if the type lives in one specific module
18:54:01 <roconnor> :)
19:03:17 <dons> http://hackage.haskell.org/package/hircules-0.3.92
19:03:22 <dons> yay, hircules is revived
19:03:50 <dons> irc client
19:04:09 <Makoryu> dons: Say, how does your sonic screwdriver work?
19:04:23 <sjanssen> wut?
19:04:33 <Cale> Doctor Who reference.
19:04:46 <sjanssen> ah
19:04:47 <Makoryu> Yes, I've concluded that he must be a Time Lord.
19:08:29 <SamB_XP> hmm, how does a sonic screwdriver relate to a hydrospanner?
19:13:30 <roconnor> I don't suppose anyone here knows what MetaOCaml can do that Template Haskell cannot.
19:14:55 <dons> Igloo might know.
19:15:29 <dons> well, metaocaml is multistage, isn't it? at runtime?
19:15:52 <dons> so multi-stage, like TH, but at runtime. that's the main difference
19:16:08 <roconnor> at runtime?
19:16:21 <dons> via the bytecode interpreter?
19:16:48 <roconnor> isn't runtime a bit late to be doing generative programming?
19:16:50 <dons> or maybe i'm thinking of metaml
19:16:59 * roconnor doesn't really know much about this topic.
19:17:09 <Makoryu> dons: "MetaOCaml is a compiled dialect of MetaML." <- You might be
19:17:24 <sjanssen> roconnor: MetaOCaml can manipulate OCaml code, TH can't
19:17:35 <dons> roconnor: maybe it is compile-time only.
19:17:52 <roconnor> sjanssen: you mean TH cannot manipulate OCaml code?
19:18:20 <SamB_XP> roconnor: it seems a bit unlikely!
19:18:21 <Saizan_> in MetaML the quoted code is parametrized by the type of the quoted expression
19:18:48 <roconnor> Saizan_: that sounds true
19:18:50 <sjanssen> roconnor: I think that's what I said.  Just making a dumb joke :)
19:19:09 <Saizan_> s/the quoted code/the type of the quotations/
19:19:11 <roconnor> sjanssen: just making sure.
19:19:28 <SamB_XP> but ... can MetaOCaml manipulate Haskell?
19:20:00 <roconnor> I think we are straying from the question at hand. :)
19:20:24 <Saizan_> and you can use quotations as patterns too
19:20:37 <Saizan_> but that should be doable via quasiquoting in TH
19:21:10 <SamB_XP> so ... that sounds like it involves dependant types ...?
19:21:25 <ksf> It'd be cool if I could specify a function that lets me mess with the tuple that gets returned by c2hs's peek- functionality.
19:21:42 <roconnor> SamB_XP: it does kinda sound like that, but possible not more than GADTs provide.
19:21:48 <ksf> ...as those values are either valid or invalid, depending on return type.
19:21:51 <Saizan_> (in the paper i read they also had limited higher order unification, but i don't know if it got implemented)
19:22:02 <SamB_XP> roconnor: that sounds a wee bit awkward...
19:22:46 <roconnor> Does TH have any variable capture problems?
19:23:01 <ksf> there's a name generation monad, even.
19:23:02 <SamB_XP> roconnor: what do you mean, exactly?
19:23:45 <roconnor> SamB_XP: I think this is the problem solved by hygenic macro?
19:23:54 <Saizan_> the variables bound in quotations get unique names
19:23:58 <SamB_XP> well, TH is hygenic
19:24:29 <SamB_XP> you *do* still have to watch out for self-inflicted shadowings, but I think that's basically it
19:24:36 <roconnor> Does TH ensure the code generated is both well formed and well typed?
19:24:47 <SamB_XP> roconnor: eventually, yes
19:25:17 <roconnor> is TH itself well typed?
19:25:23 <roconnor> well
19:25:24 <SamB_XP> the module gets typechecked after the splices are completed
19:25:24 <roconnor> typed
19:25:32 <SamB_XP> not really
19:25:37 <roconnor> ah
19:25:39 <roconnor> hmm
19:25:40 <Saizan_> the quotations get typechecked too
19:25:58 <Saizan_> typed in which sense?
19:26:04 <roconnor> but TH could generated code that isn't well typed.
19:26:23 <SamB_XP> I mean, the logical types of TH terms don't appear in the types of their representation ...
19:26:36 <SamB_XP> roconnor: which is why the typechecker is run over it, yes ;-)
19:26:40 <roconnor> hmm
19:26:58 <roconnor> I wonder if this is the difference with MetaOCaml that the authors are getting at.
19:27:01 <SamB_XP> in actuality, I believe TH splices are done *by* the typechecker
19:27:12 <SamB_XP> also, TH doesn't have any staging yet
19:27:17 <roconnor> oh
19:27:19 <SamB_XP> which is REALLY annoying
19:27:33 <roconnor> I don't know what staging is, but it sounds important
19:27:34 <Saizan_> staging as in?
19:27:52 <SamB_XP> it means you have to put any global TH definitions in another module
19:27:54 <Saizan_> i often get errors regarding stages :)
19:28:13 <Saizan_> ah, k
19:28:21 <SamB_XP> you can't use global functions defined in same module within splices
19:28:28 <blackdog> is it possible to catch pattern match failures at runtime?
19:28:40 <SamB_XP> so, basically, instead of stages you have to use modules
19:28:58 <Saizan_> blackdog: with Control.Exception.catch
19:29:04 <blackdog> (i know this is a terrible thing to do in haskell: i just want a catch-all case so i can signal back to ruby that something's gone horribly wrong)
19:29:07 <blackdog> ah, cheers
19:29:13 <Saizan_> blackdog: and enough strictness
19:29:37 <SamB_XP> the alternative would be to have the compiler split declarations up into seperate "stages" -- but this would be tricky to handle for top-level splices if the things they define are needed by other code in the module ...
19:30:14 <blackdog> Saizan_: if it can get through the call without breaking, i'm happy with that. iit's coming from ruby, after all.
19:30:26 <SamB_XP> any value used directly in one stages splice would have to be in a preceding stage
19:30:54 <BMeph> Just curious, but - does anyone use/has anyone used byorgey's D.L.Split module?
19:31:15 <SamB_XP> BMeph: hmm, not really, but I bet it's usefull ...
19:31:23 <SamB_XP> does it split into chunks of, say, 5?
19:31:34 <roconnor> BMeph: Required by haskell-boxes haskell-filestore haskell-googlesb haskell-hack-middleware-cleanpath haskell-hack-middleware-gzip haskell-hledger haskell-urlencoded haskell-windowslive haskell-wol haskell-xmonad-extras hledger yi
19:33:32 <BMeph> roconnor: Whoa - how'd you get that list? =8*O
19:34:03 <Saizan_> the AUR page, i guess
19:34:05 <roconnor> http://hackage.haskell.org/package/split -- click on the Arch link
19:35:13 <roconnor> @unmtl ContT r (State s) a
19:35:14 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
19:35:30 <roconnor> @unmtl StateT s (Cont r) a
19:35:30 <lambdabot> s -> (a -> s -> r) -> r
19:35:45 <roconnor> that's the one
19:35:58 <roconnor> if only I knew which effect that has.
19:37:15 <Saizan_> wrt state rollback?
19:37:31 <kbp> I need help: formula Vx,y(P(x,y) \/ P(y,x)) and if P(x,y) means "x loves y". So how can you interpret that formula? Is that "everyone loves everyone or everyone loves everyone"?
19:37:42 <roconnor> Saizan_: yes
19:38:02 <SamB_XP> kbp: there was a forall in there somewhere ?
19:38:57 <dolio> V is supposed to be forall, presumably.
19:39:00 <kbp> SamB_XP:  ????
19:39:13 <SamB_XP> kbp: anyway, I think that means "Everyone (loves or is loved by) each other person"
19:39:27 <dolio> Anyhow, it says that for every pair of people, one loves the other.
19:39:30 <maxote> hi guys, i want a ZFC simulator, i want to obtain the answer x from  2 + x = 5
19:39:59 <maxote> ZFC will try either x in { 0, 1+x' }   1+x' is succ(x')
19:40:02 <roconnor> ZFC?
19:40:12 <SamB_XP> so ... is there a name for that property of a relation?
19:40:24 <maxote> yes, logic from set theory.
19:40:41 <SamB_XP> @vera ZFC
19:40:44 <lambdabot> No match for "ZFC".
19:40:49 <SamB_XP> @dict ZFC
19:40:49 <lambdabot> Supported dictionary-lookup commands:
19:40:49 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
19:40:49 <lambdabot> Use "dict-help [cmd...]" for more.
19:40:52 <kbp> dolio: so that means the formula is valid (always true) right?
19:40:57 <SamB_XP> @all-dict ZFC
19:40:58 <lambdabot> *** "zfc" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:40:58 <lambdabot> ZFC
19:40:58 <lambdabot>  
19:40:58 <lambdabot>         <mathematics> {Zermelo Frankel set theory} plus the {Axiom of
19:40:58 <lambdabot>         Choice}.  A favourite {axiomatisation} of {set theory}.
19:41:00 <lambdabot> [3 @more lines]
19:41:07 <maxote> if x=0 is not possible then ZFC will try  2 + 1 + x' = 5 and so on until 2+1+1+1+0=5 , the solution will be x = 1+1+1+0=3
19:41:14 <SamB_XP> eww, that's my *least* favorite
19:41:22 <SamB_XP> well, the C part, anyway
19:41:34 <dolio> kbp: If no one loves anyone, then it's clearly false.
19:42:24 <SamB_XP> maxote: I don't think ZFC is a thing that can be "simulated"
19:42:36 <SamB_XP> it does not compute!
19:43:23 <maxote> ZFC is only a set of axioms for later computing with a intuitionistic logic inference engine.
19:44:08 <dolio> SamB: You could probably call it "total".
19:44:29 <kbp> thank you dolio & SamB_XP , I reckon I need more time to get them clear :)
19:44:32 <SamB_XP> I thought ZFC was a classical logic?
19:44:37 <dolio> That's the best I can come up with browsing around articles on relations.
19:44:48 <SamB_XP> dolio: ah, that sounds about right ...
19:45:05 <SamB_XP> I like to remember these things so I can find them in the Coq library ;-)
19:45:15 <dolio> Actually, wikipedia says that's the right term, I guess.
19:45:30 <SamB_XP> or if they aren't there, I can maybe find articles to support a name
19:45:33 <dolio> \all a, b \in X, aRb \/ bRa
20:20:47 <srush> isn't any type that is Enum also Ix
20:22:23 <sjanssen> srush: no
20:22:29 <sjanssen> Double is one such type
20:23:32 <SamB_XP> evilly yes
20:23:37 <SamB_XP> it shouldn't be
20:23:39 <Draconx> though Double's Enum instance is sketchy.
20:24:01 <Draconx> certainly the finite floating point numbers are enumerable, but the Enum instance doesn't even get that right.
20:24:21 <copumpkin> you need my fancy enumerable package ;)
20:24:36 <Draconx> could even fit +/- infinity easily, which leaves NaN.
20:24:57 <ray> you need copumpkin's fancy enumerable package!
20:25:09 <copumpkin> you need the package ray says you need!
20:25:12 <Draconx> This is also annoying:
20:25:19 <srush> yeah, it seems weird that double is enum
20:25:19 <Draconx> > max (0/0) 5
20:25:21 <lambdabot>   NaN
20:25:24 <Draconx> > max 5 (0/0)
20:25:25 <lambdabot>   5.0
20:25:52 <ray> floats shouldn't be instances of any class really
20:25:59 <ray> look how ridiculous they are
20:26:08 <Draconx> well, it makes sense to have Show and Read instances...
20:26:28 <srush> it seems trivial to define Ix for Enum though
20:26:36 <srush> since you can convert to ints and they are Ix
20:26:53 <SamB_XP> srush: well ... sometimes you can ...
20:27:26 <srush> you mean because of NaN?
20:27:44 <dolio> > index (2^80, 2^90) (2^85) :: Integer
20:27:45 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
20:27:56 <Draconx> well, Double's Enum instance maps NaN and +/- infinity to 0.
20:28:38 <SamB_XP> srush: no, I meant because some types it doesn't necessarily make much sense for ...
20:28:51 <dolio> > index (2^80, 2^90) (2^85 :: Integer)
20:28:52 <lambdabot>   0
20:28:57 <SamB_XP> > fromEnum (100, 1000)
20:28:58 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
20:28:59 <lambdabot>    arising from a use of `GHC.Enum....
20:29:03 <SamB_XP> hmm.
20:29:30 <SamB_XP> ... whatever
20:29:35 <dolio> > index (2^80, 2^90) (2^80 + 14 :: Integer)
20:29:36 <lambdabot>   14
20:29:55 <SamB_XP> anyway, Enum seems rather a muddle of this and that
20:30:01 <SamB_XP> with no clear idea of what it means
20:30:09 <dolio> > fromEnum (2^80 :: Integer)
20:30:11 <lambdabot>   0
20:30:12 <copumpkin> I'm not a big fan of Enum
20:30:13 <srush> these all seem like corner cases
20:30:25 <srush> it seems like if I go to the work of defining enum
20:30:30 <srush> I should get Ix for free
20:30:39 <Draconx> if Enum Foo meant "fromEnum is an injection from Foo to the integers", it would probably be fine.
20:31:07 <srush> what does it mean?
20:31:14 <SamB_XP> Draconx: of course, then I'd want fromEnum :: Emum a => a -> Integer
20:31:19 <SamB_XP> srush: not much!
20:31:34 <Draconx> maybe even a bijection from Foo to an integer interval.
20:32:00 <srush> ok
20:32:01 <Draconx> srush, it means that if a is not equal to b, then fromEnum a is not equal to fromEnum b.
20:32:01 <dolio> Anyhow, the point is academic, because it's impossible to define an 'all types in Enum are in Ix' instance that would work sensibly.
20:32:13 * BMeph thinks "the committee" missed a big step, when Naturals were not put into H98.
20:32:26 <srush> because of double?
20:32:39 <dolio> Because of type classes.
20:32:48 <dolio> They don't work like that.
20:33:23 <SamB_XP> not in Haskell, no
20:33:47 <Draconx> SamB_XP, yeah, fromEnum :: Enum a => a -> Int makes it even worse.
20:33:51 <SamB_XP> in Coq, sure, but then in Coq it's no big deal if they overlap -- you just have to be careful to disambiguate if there's a possibility of it going wrong
20:33:54 <BMeph> Draconx: "it means that if a is not equal to b, then fromEnum a is not equal to fromEnum b." Except, unfortunately, when the other IS equal... :(
20:33:59 <copumpkin> BMeph: I was thinking of trying to add an unlazy Natural type to GHC the other day
20:34:06 <dolio> You can write foldable/traversable style fooDefault functions, so all you have to do is write "instance Ix where whatever = whateverDefault".
20:34:07 <copumpkin> (just using GMP)
20:34:16 <dolio> But that's about all.
20:34:23 <gwern> I thougt we did't have naturals because of bikesheddin over partial ops like -
20:35:00 <BMeph> I prefer to bikeshed over things like excluding Gaussians... :(
20:35:03 <dolio> > infinity < 0
20:35:04 <lambdabot>   Ambiguous occurrence `infinity'
20:35:04 <lambdabot>  It could refer to either `L.infinity', def...
20:35:06 <SamB_XP> gwern: well, in most total languages I think they just saturate
20:35:08 <Draconx> gwern, well, div is partial on Integer.
20:35:12 <dolio> @type L.infinity
20:35:13 <lambdabot> forall t. (Fractional t) => t
20:35:44 <srush> ok, well thanks guys
20:35:53 <srush> I'll just patch the specific case
20:35:58 <SamB_XP> > L.infinity < 0%0
20:36:00 <lambdabot>   * Exception: Ratio.%: zero denominator
20:36:02 <SamB_XP> > L.infinity < 0%1
20:36:03 <lambdabot>   * Exception: Ratio.%: zero denominator
20:36:30 <gwern> SamB_XP: saturate?
20:36:39 <SamB_XP> gwern: just return 0
20:37:02 <SamB_XP> gwern: it's really the only sensible thing to do ...
20:37:04 <gwern> yes, I saw a PDF arguing for smal - large = 0
20:37:21 <gwern> seems a bit of a hack to me but I havent considered it in detail
20:37:32 <SamB_XP> (besides returning a Maybe :-)
20:37:41 <SamB_XP> gwern: well, it isn't too bad for proofs ...
20:38:01 <dolio> You can require a proof that the second argument is smaller.
20:38:22 <dolio> But that's probably a pain in most cases.
20:38:30 <SamB_XP> dolio: it's simpler to just need those for the equivalence lemmas
20:45:22 <monochrom> If subtraction gives a Maybe, it will be a pain in another aspect.
20:45:45 <SamB_XP> monochrom: yeah
20:50:49 <bos> is dph worth trying to use for practical code yet>
20:51:06 <bos> @seen chillix
20:51:07 <lambdabot> I saw chillix leaving #haskell, #haskell-in-depth, #ghc and #haskell-iphone 1h 53s ago, and .
20:51:10 <bos> hm
20:51:15 <SamB_XP> bos: well, the notation is nice and it shouldn't be too slow
20:51:42 <Makoryu> bos: DPH?
20:51:55 <SamB_XP> Data Parallel Haskell
20:51:57 <Makoryu> Ah, Data Parallel Haskell
20:51:58 <bos> Makoryu: data parallel haskell
20:51:58 <Makoryu> Yeah
20:52:11 <SamB_XP> wait, is that the same as NDP?
20:52:22 <bos> yes
20:52:27 <SamB_XP> ah, okay, good
20:52:48 <SamB_XP> I suddenly was like "what if it's not, then I won't have had a clue what I was talking about!"
20:55:30 <bos> @hoogle nan
20:55:30 <lambdabot> package nano-hmac
20:55:30 <lambdabot> package nano-md5
20:55:30 <lambdabot> package nanocurses
20:55:35 <bos> huh
20:55:39 <bos> @hoogle NaN
20:55:39 <lambdabot> package nano-hmac
20:55:40 <lambdabot> package nano-md5
20:55:40 <lambdabot> package nanocurses
20:55:43 <bos> bugger
20:55:49 <bos> > 1.0/0.0
20:55:51 <lambdabot>   Infinity
20:56:13 <bos> > 0.0/0.0
20:56:15 <lambdabot>   NaN
20:56:18 <bos> better.
20:57:21 <bos> > isNaN (0/0)
20:57:23 <lambdabot>   True
20:58:58 <bos> @seen copumpkin
20:58:59 <lambdabot> copumpkin is in ##logic, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah. I last heard copumpkin speak 24m 52s ago.
20:59:06 <copumpkin> allo
20:59:14 <bos> have you hacked on uvector lately?
21:00:05 <copumpkin> I have several uncommitted changes that have been waiting because 6.10.2+ broke the testsuite and I was reluctant to push something untested (and not in a rush enough to downgrade ghc)
21:00:13 <leimy> I've got a bit of an issue
21:00:17 <bos> hm.
21:00:37 <copumpkin> bos: why?
21:00:38 <leimy> I'm trying to consume input one char at a time, and compare the accumulated input string to a list of strings associated with actions.
21:00:38 <bos> i'm looking for a decent unlifted vector library that fuses and has a sort method.
21:00:59 <leimy> and only consume a new character after I'm sure the string I've accumulated hasn't matched one in my list.
21:01:01 <bos> lots of foldl' style loops over it.
21:01:06 <leimy> I'm not really sure how to write this in Haskell :-)
21:01:23 <copumpkin> bos: uvector should be pretty good for that, but for sorting you'll need dolio's uvector-algorithms
21:01:43 <copumpkin> bos: the version on hackage has a few bugs though
21:01:55 <bos> oh.
21:02:00 <bos> version of which?
21:02:04 <copumpkin> of uvector
21:02:26 <copumpkin> but if you check dons' darcs repo for it, it's newer and has some of the bugs fixed
21:02:42 <bos> ok, thanks
21:02:54 <luite> I think he already updated the hackage version in july
21:03:22 <copumpkin> aha, you're right
21:03:25 * ksf lets his mind get bend by touchForeignPtrs that are called in finalizers
21:04:06 <Saizan_> leimy: i guess you've problems with getting a single char at a time
21:04:09 <SamB_XP> ksf: I don't think that actually does anything
21:04:15 <leimy> Saizan_: actually no. :-)
21:04:21 <leimy> hGetChar is perfect for what I want.
21:04:22 <SamB_XP> I think it's just to keep the foreign pointers alive until then
21:04:25 <ksf> it must.
21:04:27 <ksf> exactly.
21:04:34 <Saizan_> ?hoogle hGetChar
21:04:35 <lambdabot> System.IO hGetChar :: Handle -> IO Char
21:04:38 <ksf> which is a hell of a side-effect.
21:04:44 <SamB_XP> I mean, I don't think it does anything except fool the compiler
21:04:46 <Saizan_> ah, right, the problem was with a single byte :)
21:04:47 <ksf> in fact, it has a side effect before it's called.
21:04:50 <Saizan_> leimy: so?
21:04:53 <leimy> In fact, for this program, all I need to do is keep trying to consume input until one of the strings matches
21:04:58 <SamB_XP> or possibly enlighten the compiler
21:05:04 <SamB_XP> depending on how you think about it
21:05:10 <leimy> I was having difficulty with the structure to use to look through the association list of stuff.
21:05:16 <leimy> but now I think I really just want Data.Map
21:05:22 <leimy> and that should fix my issue.
21:05:24 <Saizan_> yeah
21:05:24 <ksf> actually, it's there to boycot my quest on attaining segfaults.
21:06:03 <ksf> as with it, there will be no chance of the main freetype library going out of scope and moving on to destroying all those fonts haskell still has refs to.
21:07:11 <ksf> in other languages, that function would take two foreignptrs and not do a thing before it's called.
21:07:22 <dolio> The version of uvector-algorithms on hackage has bugs, too, but I can't release the new version until the new version of uvector is released, too.
21:07:58 <dolio> You should be able to get both from darcs, though.
21:08:10 <dolio> Last I checked, at least. I haven't re-gotten uvector in a while.
21:09:44 <copumpkin> maybe I should just give and test my patches on an earlier ghc
21:10:03 <copumpkin> *give in
21:10:39 <dumael> if you have something profitable, then yeah.
21:10:52 <leimy> Saizan_: I just realized my problem :-)
21:11:07 <leimy> I need to do a special matching function
21:11:49 <leimy> I need to see if the reverse of each key in the map is the prefix of the reversed accumulated string.
21:11:57 <leimy> which kind of sucks :-)
21:12:05 <leimy> but that's sort of how people write "expect" code :-)
21:12:19 <leimy> I'm trying to come up with a structure of expect, action alternatives that can match an input stream.
21:12:24 <leimy> The simple expect case is simple
21:12:47 <Saizan_> it seems like you want a trie
21:13:50 <leimy> I was thinking the hGetChar'd string should use a state monad for the accumulated string.
21:13:51 <Saizan_> i.e. nested maps that index on a single character
21:14:33 <Saizan_> it could, but it's a minor point, imo
21:15:18 <Saizan_> data Trie v = Branch (Map Char (Trie v)) | Leaf v
21:15:32 <Nafai> @shapr
21:15:32 * lambdabot will count to five...
21:15:46 <Saizan_> @get-shapr
21:15:46 <lambdabot> shapr!!
21:15:53 <Nafai> Oh yeah, thanks. :)
21:17:12 <koninkje> And if you want tries on strings, you can use the bytestring-trie package to save yourself the implementation details
21:17:55 <leimy> I'm afraid I still don't understand how the Trie is going to help me.
21:18:34 <Saizan_> http://hackage.haskell.org/packages/archive/bytestring-trie/0.1.4/doc/html/Data-Trie.html#v%3Asubmap <- leimy
21:18:57 <Saizan_> it's a fast way to make prefix searches
21:19:12 <dancor> why does haskell have such a bad conciseness rating on http://shootout.alioth.debian.org/u64q/shapes.php
21:19:16 <leimy> well in this case, I need to reverse the provided string, and do a suffix search
21:19:33 <koninkje> Did you want: \forall key \in map. reverse key `prefixOf` foo ?
21:19:37 <leimy> but I guess since I accumulate the input like a stack... it really is a prefix
21:19:38 <Saizan_> so you can avoid reversing and do a prefix one?
21:20:16 <koninkje> leimy: You can just reverse all strings before inserting them into the map (so that it's a suffix trie)
21:20:28 <Makoryu> > text "\SOHwut\SOH"
21:20:29 <lambdabot>   wut
21:20:41 <Makoryu> > ord '\SOH'
21:20:43 <lambdabot>   1
21:20:45 <Makoryu> Huh
21:21:09 <leimy> koninkje: At this point I've been staring at this too long, and am not sure what it is I want or need :-)
21:21:19 <koninkje> heh :)
21:21:34 <Saizan_> leimy: are you trying to do something like auto-completion?
21:21:37 <leimy> I can tell you in the simple case, where there's only one string to match, I just reverse the string to be matched, and consume input until it matches  or block forever.
21:21:44 <koninkje> What's the original tast/problem?
21:21:50 <leimy> Saizan_: familiar with the unix program "expect"?
21:21:56 <leimy> I'm implementing a small syntax like that.
21:22:03 <Saizan_> no
21:22:11 <leimy> well then that makes it tricky to understand :-)
21:22:53 <leimy> I've got a minimal expect syntax that currently works with runInteractiveProcess over ssh to login to a server, that is a serial port concentrator, can log into the serial channel I want, and start controlling a Raritan power strip over CLP via this syntax
21:23:06 <leimy> but I need a way to say "match one of these strings, and each string has an associated action"
21:23:16 <leimy> because in some cases, the remote site is in a state where another login is necessary.
21:23:31 <leimy> and coding that in Expect is pretty simple.... in Haskell, I'm having problems :-)
21:23:32 <idnar> holy hell
21:24:09 <djahandarie> @seen Vanadium
21:24:09 <lambdabot> Vanadium is in #gentoo-haskell and #haskell. I last heard Vanadium speak 6h 16m 50s ago.
21:24:21 <leimy> idnar: ?
21:24:47 <idnar> leimy: that's a rather impressive stack of interactions :P
21:25:11 <leimy> idnar: It's not my choice.  I've got a rather constrained environment, and I have to pull statistics from an environment
21:25:16 <leimy> this is the way folks typically do it.
21:25:22 <leimy> But I have to do many of them in parallel
21:25:26 <leimy> so forkIO to the rescue :-)
21:25:31 <idnar> heh
21:25:32 <koninkje> leimy: you can use bytestring-trie to store your map from "one of these strings" to the actions that should be performed for each
21:25:36 <Saizan_> however, if you need to match prefixes or suffixes a trie is a good way to do it, you just need to find which you want :)
21:25:50 <leimy> koninkje: that would be true if I had any confidence around what a Trie is.
21:26:38 <koninkje> leimy: just think of it as (Data.Trie a) == optimize (Data.Map ByteString a)
21:26:51 <Saizan_> where you can do fast prefix searches
21:27:20 <leimy> I can't use Data.Map or Trie as far as I can tell
21:27:26 <Saizan_> why?
21:27:37 <leimy> because I don't know the length of each prefix to check :-)
21:27:44 <koninkje> yeah, the optimization is (mainly) to do prefix sharing, so that also allows some interesting functions like "return the submap where all keys begin with 'foo'"
21:28:17 <Saizan_> leimy: ?
21:28:26 <Saizan_> leimy: that's because you need a suffix search?
21:28:30 <leimy> no...
21:28:31 <Elly> "tab-completion trees" :)
21:28:31 <koninkje> leimy: Why do you need to know the prefix length? Are you trying to maximal-munch on the whole input string?
21:28:32 <leimy> I'm doing
21:28:52 <leimy> each char prepended to the accumulated input list
21:29:00 <leimy> and the strings are provided in normal order
21:29:27 <Saizan_> except for this lowlevel ordering of chars
21:29:35 <Saizan_> what are you trying to match?
21:29:41 <Saizan_> can you give some examples?
21:29:41 <leimy> I need to check each key in the "map" reversed to be a prefix of the reversed accumulated string :-)
21:29:54 <leimy> then if it matches, run the associated action.
21:30:14 <Saizan_> can we avoid all this reversing in the explanation?:)
21:30:18 <leimy> nope
21:30:23 <Saizan_> why not?
21:30:23 <leimy> it's absolutely necessary
21:30:40 <leimy> In that when I consume a new character, it ends up being the front of the prefix
21:30:51 <leimy> and that's sort of essential to the way the algorithm currently works :-)
21:30:57 <leimy> expect looks like this
21:31:01 <Saizan_> ah, that's because you have a stream and you want to consume it until one of the strings with associated commands appear?
21:31:03 <leimy> expect "Password: "
21:31:07 <leimy> send <mypassword>
21:31:12 <leimy> but it's ok to say
21:31:17 <leimy> expect "ord: "
21:31:22 <leimy> send <mypassword>
21:31:34 <Saizan_> ok
21:31:44 <Saizan_> what i just said then
21:31:48 <leimy> I have that working for simple cases :-)
21:32:26 <koninkje> leimy: So you want to look at a variable-sized sliding window of input, and whenever looking at the next character causes the window to contain a command word, run the command?
21:32:26 <blackdog> whee, Hubris can take an integer from ruby, fiddle with it in haskell, and push it back over the border
21:32:37 <blackdog> truly i have extended the bounds of computer science
21:32:38 <leimy> koninkje: that's the problem
21:32:48 <copumpkin> blackdog: lol
21:32:50 * blackdog called it hubris for a reason
21:32:53 <koninkje> leimy: Just checking that that was what you meant
21:32:56 <leimy> I kind of want "expects [(string1, action1), (string2, action2)...]"
21:33:19 <leimy> and I'd like it to consume the input one char at a time, looking for the first match of any of the strings, and then executing the associated action :-)
21:33:30 <leimy> in this way I can write something that is a bit more advanced than what I got.
21:33:34 <Saizan_> this is like KMP but with more needles in parallel
21:33:34 <ksf> a C finalizer called back into Haskell.
21:33:34 <ksf>    This was previously allowed, but is disallowed in GHC 6.10.2 and later.
21:33:38 <ksf> I didn't!
21:33:45 <blackdog> copumpkin: hubris.rb is a pig, though - haskell, shell, ruby and c in the one file
21:33:53 <leimy> I want a sort of "select" or "alt" on matching :-)
21:33:56 <ksf> I merely did a wrapper stub and called back from there...
21:33:58 <leimy> first match wins.
21:34:04 <leimy> if none match, block forever on hGetChar :-)
21:34:09 <leimy> (until I implement timeouts
21:34:10 <leimy> )
21:34:20 <koninkje> Look at http://hackage.haskell.org/packages/archive/bytestring-trie/0.1.4/doc/html/Data-Trie.html#v%3AlookupBy
21:34:47 <Saizan_> you can still do it with a trie
21:35:35 <Saizan_> it's quite simple actually
21:36:08 <Saizan_> just take the submap at every new char you get
21:36:17 <Saizan_> until you find a match
21:36:23 <Saizan_> *perfect
21:36:34 <leimy> well to me the map is the assoc-list of strings we might match to actions
21:36:45 <leimy> and that I'd need to check those keys to be prefixes of something else
21:36:52 <leimy> which is why I don't think Trie is what I want.
21:37:14 <Saizan_> right, the submap is the part of that map that can still match after the character seen, without backtracking
21:37:23 <leimy> but again, never used or seen code that uses a Trie... so it's hard to tell by the docs that it can do what I want :-)
21:37:39 <leimy> oh I see
21:37:47 <leimy> you're saying that if I look at this like an incremental search
21:37:47 <koninkje> Let T be some trie. For each character C, use lookupBy to see if C is a valid extension for some keyword. If so, then let T' be the returned trie; else start over from the original complete trie. If lookupBy returns a match, use the value or not (depending on desired semantics)
21:37:52 <Saizan_> ..then you need to add backtracking too
21:37:54 <leimy> ... that I can eliminate chunks of my map.
21:37:57 <SamB_XP> leimy: that's exactly what tries are for ;-)
21:37:58 <Saizan_> leimy: exatcly
21:38:16 <leimy> Hmmm I'll have to check these out tomorrow, cuz I'm freaken exhausted! :-)
21:38:26 <ksf> otoh, I should be glad, getting rid of all that FunPtr punk.
21:38:28 <bos> @hoogle NominalDiffTime -> Double
21:38:28 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:38:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:38:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
21:38:41 <leimy> in the meantime I'm happy that I even have a simple version of "expect" as an EDSL in Haskell working :-)
21:38:54 <leimy> My other option is to timeout on one pattern, and try the next if I don't do this.
21:39:10 <leimy> which, honestly, would be ok :-)
21:39:24 <leimy> but this Trie thing would be a nice optimization to have
21:39:30 <koninkje> leimy: After you get some sleep, look over the algorithm I just mentioned
21:39:33 <leimy> heh
21:39:43 <leimy> well thank you all for beating some sense into me :-)
21:39:53 <koninkje> Are you familiar with finite state automata?
21:40:23 * leimy codes a lot of erlang :-)
21:40:33 <leimy> koninkje: probably.
21:40:34 <leimy> :-)
21:40:49 <leimy> I've dealt with some in a very primitive form when I wrote an assembler in college in C++ :-)
21:40:53 <koninkje> A trie can be thought of as a directed graph where each arc has one character for a label
21:41:01 <leimy> oh that's smart
21:41:16 <leimy> so like cat and catastrophe can share the same space?
21:41:19 <leimy> to an extent?
21:41:33 <leimy> It's like having a Zipper path through a set of states?
21:41:45 <leimy> mmmm zippers....
21:41:51 <koninkje> yeah: (start)--"cat"-->((1))-->"astrophe"-->((2))
21:42:00 <leimy> ok... I get it!
21:42:02 <leimy> cool
21:42:15 <leimy> you can trim out parts of the giant graph...
21:42:25 <leimy> very nice.
21:42:34 <leimy> well thanks again... and goodnight!
21:42:45 <koninkje> sure thing :)
21:42:52 <lispy> so, record updte syntax binds tighter than function application?
21:43:00 <SamB_XP> lispy: yuppers!
21:43:05 <lispy> So much for function application binding the tightest :)
21:43:10 <SamB_XP> yeah
21:47:30 <koninkje> @tell leimy If the set of keywords is (relatively) static, then you can just find the longest one to know how large a window to keep for when you go back to Start
21:47:30 <lambdabot> Consider it noted.
22:00:44 <ksf> shouldn't a ForeignPtr that cannot yet be finalized because another finalizer holds a touchForeignPtr on it stay valid if its finalized?
22:02:04 <sjanssen> ksf: actually, I think not
22:02:39 <ksf> well, I'm wondering. I _do_ get a segfault.
22:23:11 <ksf> argh touchForeignPtr doesn't seem to work
22:23:19 <ksf> ...but I might be doing stuff wrong.
22:23:51 <ksf> ...or finalizeForeigPtr is meant not to respect touchForeignPtr.
22:24:15 <sjanssen> ksf: yes, I think ForeignPtr references in finalizers are not honored
22:24:46 <ksf> well, the docs say it _should_ not be used that way, not that it _can't_.
22:24:55 <ksf> I'm perfectly happy with the described behaviour.
22:25:42 <ksf> the problem is that freetype deallocates everything if the top finalizer gets run.
22:27:39 <sshc> where does foldr start in an infinite list?
22:27:59 <koninkje> at the head (like always)
22:28:00 <sjanssen> "if the finalizer for a ForeignPtr F1 calls touchForeignPtr on a second ForeignPtr F2, then the only guarantee is that the finalizer for F2 is never started before the finalizer for F1. They might be started together if for example both F1 and F2 are otherwise unreachable, and in that case the scheduler might end up running the finalizer for F2 first. "
22:28:06 <ksf> ...and the reference to the library may get out of scope as soon as the user doesn't want to load any more fonts... it should be possible to use the fonts afterwards, though.
22:28:08 <sjanssen> ksf: that exactly describes what you're seeing, I think
22:28:14 <int-e> > foldr (:) undefined [1..]
22:28:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:28:35 <ksf> well F1 is still reachable.
22:28:40 <koninkje> sshc: the tail of the list is in a thunk and pulled on as needed, so be sure not to be strict in the recursion
22:28:55 <ksf> ...and I call finalize on F2
22:29:04 <sjanssen> ksf: F1 is reachable from where?
22:29:20 <int-e> "before" is a dangerous word to use there.
22:29:30 <ksf> ...after that, I observe that a string ref in F1's struct is suddenly NULL
22:29:36 <int-e> (what it refers to is garbage generation cycles)
22:29:39 <copumpkin> sshc: the simplest way to think of foldr is that foldr f z replaces every (:) with f and [] with z
22:29:41 <koninkje> sshc: e.g foldr f z (x:xs) ==> f x (foldr f z xs)
22:29:47 <ksf> ...from whereever I dereference that string.
22:29:59 <ksf> further down in main, to be precise.
22:30:58 <koninkje> sshc: ...and then if f is strict in its second argument then (foldr f z xs) gets expended
22:30:58 <sshc> copumpkin: doesn't foldl start at the head and end at the right of the list?
22:30:58 <bos> @src scanl
22:30:59 <lambdabot> scanl f q ls = q : case ls of
22:30:59 <lambdabot>     []   -> []
22:30:59 <lambdabot>     x:xs -> scanl f (f q x) xs
22:31:19 <copumpkin> sshc: I wouldn't think of it as starting and ending
22:31:38 * blackdog wants bytestring for jhc. and a pony.
22:31:42 <sjanssen> sshc: both start at the head of the list, but Haskell is lazy
22:33:42 <koninkje> > foldr f z [a,b,c]
22:33:43 <lambdabot>   Ambiguous occurrence `a'
22:33:43 <lambdabot>  It could refer to either `L.a', defined at <local...
22:33:51 * dolio wants most of nobench to compile for jhc. :)
22:33:55 <koninkje> bah! is that module broken?
22:34:26 <idnar> @undef
22:34:30 <idnar> > foldr f z [a,b,c]
22:34:31 <lambdabot>   f a (f b (f c z))
22:34:42 <idnar> someone @defined a conflicting definition
22:34:49 <koninkje> ah
22:34:56 <idnar> er, @let
22:34:56 <koninkje> > foldl f z [a,b,c]
22:34:58 <lambdabot>   f (f (f z a) b) c
22:35:35 <koninkje> sshc: the difference is in parenthisization, but both start at the head of the list (they must, how could you see the tail without moving past the head?)
22:36:28 <blackdog> dolio: i'm trying to keep it reasonable :)
22:36:41 <dolio> Hah.
22:38:13 <blackdog> anyway, i have integers now. people can just encode their data into an integer. it'll be fine.
22:38:18 <sshc> sjanssen: where would foldr start in [1..]?
22:38:20 * blackdog wanders blithely into the turing tarpit
22:38:42 <sshc> > foldr1 (+) [1..]
22:38:44 <lambdabot>   * Exception: stack overflow
22:39:12 <koninkje> the overflow is from (+) being strict in the second argument
22:39:31 <copumpkin> blackdog: do you do Bignum <=> Integer too?
22:39:49 <copumpkin> sshc: I still don't think it's a good idea to think of it "starting"
22:40:17 <copumpkin> what gets evaluated depends on the f you pass in
22:40:44 <sshc> what's an example of using foldr on an infinite list?
22:41:07 <blackdog> copumpkin: ... it's on the list? :)
22:41:18 <koninkje> > foldr (const . Just) Nothing [1,..]
22:41:18 <blackdog> thinking it might be easiest to go through string...
22:41:19 <lambdabot>   <no location info>: parse error on input `..'
22:41:27 <koninkje> > foldr (const . Just) Nothing [1..]
22:41:28 <lambdabot>   Just 1
22:41:29 <Makoryu> > foldr (:) [1..]
22:41:30 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
22:41:31 <lambdabot>    arising from a use ...
22:41:36 <Makoryu> Pssh
22:41:41 <Makoryu> > foldr1 (:) [1..]
22:41:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:41:53 <Makoryu> > foldr1 (flip (:)) [1..]
22:41:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:41:55 <copumpkin> lol
22:42:01 * Makoryu hangs head in shame
22:42:01 <copumpkin> Makoryu: you need a []
22:42:11 <copumpkin> the type of foldr1 is wrong
22:42:14 <copumpkin> it wants an a -> a -> a
22:42:15 <Makoryu> > foldr (:) [] [1..]
22:42:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:42:40 <Makoryu> I'm sicker than I've ever felt today
22:42:45 <Makoryu> I should not be writing code
22:42:51 <copumpkin> aw
22:43:36 <koninkje> > let myMap f = foldr (\x r -> f x : r) [] in myMap (+1) [1..]
22:43:38 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
22:44:07 <Saizan_> foldr ((:) . f) []
22:44:32 <copumpkin> sshc: one way to think of it is that foldr puts "control" in the hands of the f passed to it, whereas foldl treats f like its tool :P
22:44:41 <koninkje> well, yes (though not quite as transparent for the @pl uninitiated)
22:44:44 <copumpkin> sshc: foldr allows f to say "I've seen enough!"
22:44:57 <copumpkin> sshc: foldl forces it to watch like that scene in a clockwork orange
22:45:16 <Makoryu> > let compose = foldr ($) in compose 10 . map (+) $ [1..9]
22:45:17 <lambdabot>   55
22:48:23 <quicksilver> copumpkin: well you can devise cases where foldl short-circuits the values, but it can never short-circuit the spine.
22:48:25 <bos> @pl \o e -> outlier e `mappend` o
22:48:25 <lambdabot> flip (mappend . outlier)
22:50:53 <ksf> the touchForeignPtr isn't even honored when it's not in a finalizer.
22:51:43 <ksf> what I'd like to hear is "don't worry, finalizeForeignPtr is designed to ignore that, everything else works fine"
22:54:36 <quicksilver> I don't believe the statement 'touchForeignPtr isn't honoured when it's not in a finalizer'
22:55:01 <ksf> ...with an explicit finalizeForeignPtr.
22:55:14 <ksf> I can't test it differently, right now.
22:55:54 <quicksilver> touchForeignPtr is just a way to spuriously make something live
22:56:10 <quicksilver> its pretty simple, IIRC it just breaks down to a primitive touch#
22:56:48 <ksf> well, my guess is that finelizeForeignPtr ignores it.
22:56:49 <quicksilver> I'm afraid the set of people who understand this is in painful detail is pretty small
22:57:06 <quicksilver> are you trying to control the order than two finalizers run in?
22:57:29 <ksf> ...which isn't unlikely, but also undocumented.
22:57:59 <ksf> I'm trying to prevent the main library instance getting collected and thus collecting the rest of the objects to which I still hold refs.
22:58:09 <koninkje> wouldn't finalizeForeignPtr force the finalizer to run regardless of whether the pointer is still live afterwards? (in which case any access after 'finalization' would be dubious at best)
22:58:14 <quicksilver> finalizeForeignPtr explicitly runs the finalizer
22:58:25 <quicksilver> I don't understand in what way you'd expect that to interact with touch
22:58:28 <quicksilver> touch maintains liveness
22:58:34 <quicksilver> finalizeForeignPtr ignores liveness
22:58:50 * koninkje agrees
22:59:00 <ksf> ...well, I exepected it to ignore liveness only for the passed ForeignPtr
22:59:39 <ksf> urks.
23:00:12 <ksf> I expected it to ignore _scope_ liveness, not explicit touchForeignPtr liveness.
23:00:36 <quicksilver> no. it ignores all liveness.
23:00:39 <quicksilver> it says "run this finalizer now"
23:00:57 <quicksilver> which, typically, frees the underlying resource (but depends on the finalizer, obvbiously)
23:00:59 <koninkje> Liveness only matters because the finalizer is implicitly run at some point after the ptr is no longer live
23:01:09 <quicksilver> which then makes the foreignptr useless (typically)
23:01:14 <ksf> ...then I need to cross my fingers, develop a bit more, and see if I get the chance to test it later.
23:01:22 <koninkje> finalizeForeignPtr forces the finalizer to run earlier than that, and so liveness is irrelevant to finalizeForeignPtr
23:02:15 <Gwern-away> anyone here familiar with the details of BCC emails? I've been trying to figure out whether a BCC recipient knows/can-know it was a BCC email and not an original
23:03:22 <koninkje> I'm not too familiar, but spoofing aside, recipients can always check to see if they're in the to: or cc: fields. If not, then it's a bcc: (or a spoof)
23:04:00 * koninkje isn't sure what "an original" is exactly...
23:04:17 <ksf> ...a few putStrLns later I see what I expected: the finalizers aren't run with my short test program, at all.
23:04:24 <Gwern-away> koninkje: I don't know what the right term is - the email you receive if I put your address in to:, and nothing else
23:04:39 <koninkje> Gwern-away: I was guessing that :)
23:05:06 <quicksilver> Gwern-away: this is quite offtopic, but envelope-to (which is who the mails are actually sent to) is totally unconnected with what appears in the headers inside the mail. The headers inside the mail are free to be full of shit, or absent entirely.
23:05:31 <quicksilver> of course, some spam filters and MUA take actions based on the headers.
23:05:32 <Gwern-away> quicksilver: I'm sure gmail won't let me spoof headers
23:05:46 <ksf> Gwern-away, nope, BCC is a client feature
23:05:50 * quicksilver wouldn't be so sure.
23:05:58 <ksf> ...at least it should be.
23:06:15 <quicksilver> So, if someone is BCC'ed, typically, they will notice they don't occur in the visible headers
23:06:18 <Gwern-away> come on, it's a google property. they respect standards and emitting strictly correct stuff. (at least usually)
23:06:22 <ksf> I'm quite sure that mta's can do it, too.
23:06:25 <quicksilver> so they will be able to infer they have been bbc'ed.
23:06:28 <ksf> ...to safe bandwidth.
23:06:48 <quicksilver> a few mail systems add a visible 'bcc' header which is only seen in the copy sent to that specific person
23:06:50 <koninkje> bcc is just a way for users to tell their client to adjust the envelope-to "legitimately"
23:06:51 <quicksilver> most don't.
23:07:28 * ksf always assumed bcc gets rewritten to to
23:07:40 <quicksilver> it used to be traditional to add "To: undisclosed-recipients;" in the case that there are no visible recipient at all.
23:37:38 <Nereid_> :(
23:37:46 <copumpkin> ?
23:37:46 <Nereid_> I wish  class Functor m => Monad m
23:37:52 <copumpkin> don't we all
23:37:56 <Nereid_> indeed
23:37:59 <copumpkin> or Applicative f => Monad f
23:38:13 <Nereid_> haven't really looked at Applicative stuff
23:41:53 <dibblego> I wish there was a solution such that this kind of oversight was not a problem
23:43:47 <dmwit> -fno-implicit-prelude?
23:43:56 <dmwit> yeah, that doesn't really cut it.
23:43:58 <dmwit> Never mind.
23:44:06 <koninkje> Applicative f => Monad f would be nice. Especially if we could rename pure to return and remove return from Monad
23:44:18 <Nereid_> indeed
23:44:20 <copumpkin> why not throw pointed in there too?
23:44:26 <copumpkin> and make a nice pretty family
23:44:32 <koninkje> no reason :) I'm all for it
23:44:47 * copumpkin dreams
23:45:10 <koninkje> Functor.map => Pointed.return => Applicative.(<*>) => Monad.(>>=)
23:45:13 * koninkje sighs
23:45:27 <copumpkin> or even Monad.join
23:45:47 <copumpkin> and have (>>=) as a method with a default implementation in terms of join, that you can override for efficiency
23:45:54 <copumpkin> also, drop fail from Monad
23:46:08 <koninkje> I'd like both Monad.join and Monad.(>>=)... so folks can pick whichever is easier for the monad
23:46:13 <copumpkin> and add rmonad-style contexts to pointed, for great justice
23:46:13 <copumpkin> yeah
23:46:21 <koninkje> (drop fail from Monad)++
23:46:24 <Nereid_> copumpkin: drop fail from Monad, and make something like a MonadFail perhaps?
23:46:39 <copumpkin> yeah
23:46:46 <dmwit> ?karma Monad)
23:46:46 <lambdabot> Monad) has a karma of 1
23:46:49 <dmwit> excellent
23:46:54 <Nereid_> ha
23:47:06 <Nereid_> oops, i meant koninkje:
23:47:07 <dmwit> MonadZero ~= MonadFail
23:47:09 <Nereid_> :-)
23:47:14 <Nereid_> almost
23:47:25 <koninkje> MonadZero => MonadFail might be sensible
23:47:32 <Nereid_> yeah
23:47:32 <copumpkin> the rmonad-style contexts for pointed
23:47:36 <copumpkin> would allow Set to be a Monad
23:47:39 <Nereid_> since fail takes a String argument
23:47:54 <dmwit> class Fail f where fail :: String -> f a
23:48:04 <dmwit> No need to have any context, I would think.
23:48:08 <dibblego> newtype Fail m = Fail (String -> m a)
23:48:08 <copumpkin> true
23:48:19 <koninkje> I'd like to see typeclasses treated as kinds, in order to clean up rmonad-style contexts (and so much else)
23:48:22 <copumpkin> forall a.?
23:48:35 <copumpkin> koninkje: how so?
23:48:37 <Nereid_> copumpkin: Monad's fail is like that currently
23:48:53 <copumpkin> yeah
23:49:10 <Nereid_> koninkje: example?
23:49:39 <Saizan_> you'd need subkinding then
23:49:51 <dblhelix> koninkje: in a way type classes are like subkinds indeed
23:49:54 <koninkje> class Functor k (f :: k -> *) ...; instance Functor Ord Set ...
23:50:21 <copumpkin> oh
23:50:22 <koninkje> You could get pretty far without subkinding, though that would be nice too
23:50:28 <copumpkin> that would be very nice
23:50:59 <Nereid_> I'm confused
23:51:02 <Saizan_> koninkje: you need a type to be of many kinds
23:51:20 <koninkje> that way the rmonad-style things are still functors/monads/etc on a restricted category; rather than allowing non-functors to be easily written
23:51:44 <Saizan_> and not have a principal kind for any type..
23:51:50 <koninkje> Saizan_: we already have a kind hierarchy in GHC with *, ?, ??,...
23:52:10 <Saizan_> yeah, that's subkinding
23:52:42 <Saizan_> but you can find a principal kind for any type in that case
23:52:53 <koninkje> I'd be fine to treat typeclasses as a subset of *. The fact that Monad is a subset of Functor doesn't necessarily need to be observable from within Haskell
23:53:31 <koninkje> well, you can only get principal kinds provided that the subkinding graph has the right shape
23:54:02 <Saizan_> i think it'd be interesting to try
23:54:19 <Saizan_> at least one would find out which problems arise
23:55:41 <Saizan_> but what should :kind Int return?:)
23:55:57 <koninkje> a set of kinds ;)
23:56:59 <koninkje> of course MPTCs get really interesting once typeclasses can be treated as kinds
23:57:36 <Nereid_> I've seen ? and ?? before but I'm not sure what they are
23:57:48 <Saizan_> they'd become kinds of types' tuples?
23:58:07 <Nereid_> ?
23:58:07 <koninkje> scroll down on http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
23:58:09 <Saizan_> Nereid_: those are GHC specific kinds to deal with unboxed types
23:58:25 <Nereid_> ah
23:58:30 <Nereid_> thanks
23:58:55 <copumpkin> :k (->)
23:58:56 <lambdabot> ?? -> ? -> *
23:59:13 * copumpkin doesn't quite get how the primops return unboxed tuples given that
23:59:14 <koninkje> The boxedness kinding system of GHC (and the similar system in JHC/LHC) would be orthogonal to the idea of typeclasses as kinds
23:59:50 <Saizan_> copumpkin: ? is a superkind of (#)
