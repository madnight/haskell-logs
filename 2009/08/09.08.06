00:00:45 <Gracenotes> mwahahaha, *holds his three exponentiation operator closely*
00:00:47 <Gracenotes> s
00:00:56 <SubStack> 3 of them in the prelude at last count
00:01:03 <SubStack> indeed
00:03:11 <Gracenotes> "No language should have an operator for ignoring its inputs and saying it loves kittens"
00:03:30 <Gracenotes> (&-&) a b = trace "I love kittens" True
00:03:36 <Gracenotes> too late
00:03:51 <athos> :>
00:04:01 <Gracenotes> better name: =^-^=
00:04:59 <SubStack> awww
00:05:19 <hackagebot> persistent-map 0.3.4 - A thread-safe (STM) interface for finite map types with persistency support. (PeterRobinson)
00:05:19 <hackagebot> persistent-map 0.3.5 - A thread-safe (STM) persistency interface for finite map types. (PeterRobinson)
00:05:35 * SubStack wishes he could mix some letters into the operator definitions
00:05:49 <SubStack> would make for much more amusing ascii art
00:06:07 <athos> heh
00:06:29 <athos> at least an international obfuscated haskell contest would be much more fun
00:06:29 <athos> :)
00:06:52 <Gracenotes> I did submit an entry once
00:06:57 <Gracenotes> @quote lol
00:06:58 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
00:07:22 <kyagrd> @help
00:07:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:07:27 <kyagrd> @help help
00:07:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:07:32 <kyagrd> @help list
00:07:33 <lambdabot> list [module|command]
00:07:33 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
00:07:58 <kyagrd> @quote
00:07:58 <lambdabot> norpan says: the comonad of the No monad is the Yes monad?
00:08:16 <kyagrd> @quote ghc
00:08:16 <lambdabot> ghc says: Illegal constraint
00:08:52 <SubStack> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
00:08:53 <lambdabot>   [[0.0]]
00:08:57 <SubStack> \o/
00:09:02 <kyagrd> > [| 2 |]
00:09:03 <lambdabot>   <no location info>: parse error on input `|'
00:09:16 <kyagrd> @t [| 2 |]
00:09:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:09:24 <kyagrd> @ft [| 2 |]
00:09:26 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
00:09:50 <Gracenotes> lambdabot is available in private rooms at low fees *wink*
00:09:54 <kyagrd> @type [| 2 |]
00:09:55 <lambdabot> parse error on input `|'
00:10:04 <kyagrd> @type VarE
00:10:05 <lambdabot> Not in scope: data constructor `VarE'
00:10:19 <Gracenotes> if you'd like to play around, you can try /query lambdabot
00:10:48 <Gracenotes> lunabot tends to have the TH stuff, not really lambdabot
00:10:59 <kyagrd> , [| 2 |]
00:11:02 <lunabot>  LitE (IntegerL 2)
00:11:12 <kyagrd> Gracenotes: Thanks in double!
00:11:29 <Gracenotes> np
00:12:08 <athos> src 'VarE
00:12:11 <athos> , src 'VarE
00:12:14 <lunabot>  data Exp = ... | VarE Name | ...
00:12:14 <lunabot>  infixl 9
00:12:25 <athos> there you go
00:17:13 <ski> Peaker : .. record patterns looks like record (literal) expressions, as they should
00:17:32 <Peaker> ski: yeah, its just the only place in Haskell where a pattern appears at the right side of a =
00:17:39 <Peaker> (I think)
00:18:08 <Peaker> f G{x=y} = -- actually y was determined here, rather than x, the syntax is usually the opposite
00:18:21 <ski> yes, that's how patterns usually works
00:18:56 <ski> `f (x,y) = ...' - actually `x' and `y' was determined here, rather than used
00:19:55 * ski ponders
00:20:03 <ski>   data Either :: * -> * -> *
00:20:05 <ski>     where
00:20:17 <ski>     Left  :: forall a. a -> Either a (forall b. b)
00:20:27 <ski>     Right :: forall b. b -> Either (forall a. a) b
00:20:52 <ski> .. would that be strange ?
00:21:50 <Peaker> ski: f (x, y) = ... -- x,y are on left side of = to be determined, whereas in records they're in right side of = to be determined.. just a little nuance
00:22:29 <ski> but `y' is on the left-hand-side of the outer `=' in `f G {x = y} = ..y..' ..
00:22:42 <ski> .. but i see what you mean
00:26:46 <notsonerdysunny> This is the first program I am build in haskell.. i get a lot of linker errors ...
00:26:54 <notsonerdysunny> some of them are pasted at
00:26:56 <notsonerdysunny> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3162#a3162
00:27:22 <notsonerdysunny> The command i used  is ghc *.hs -o word
00:27:26 <kyagrd> notsonerdysunny: try ghc --make
00:27:44 <kyagrd> if your script is Main.hs you can just do ghc --make Main
00:29:27 <edwardk> woot, finally have all of the iteratee stuff working properly with parsec, automatically doing my utf8 conversion in the process and letting me slice off sections of the input bytestring
00:29:55 <edwardk> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3160#a3163
00:44:41 <notsonerdysunny> thanks kaygrd that seems to work..
00:46:27 <Peaker> someone in #python challenged me to write a breakout in Haskell, so I did, heh :)
00:46:48 <Peaker> lets make this prettier now..
00:47:16 <Nafai> Sweet
00:47:19 <mxc> peaker - nice!
00:47:38 <Nafai> It's about time I write some Haskell code again :(
00:54:08 <Peaker> my breakout ball is a square, because SDL bindings don't let me draw circles, heh
00:56:36 <hackagebot> haskgame 0.0.6 - Haskell game library. (EyalLotem)
00:56:40 <Ke> sdl-gfx?
00:56:57 <Ke> you could have done the bindings as well ;o)
01:00:15 <Peaker> Ke: Heh, yeah, I will sometime
01:00:18 <Peaker> sdl-draw I need
01:00:25 <Peaker> seems a bit of tedious work
01:02:16 <alinp> hi
01:02:22 <alinp> I need to do something like that:
01:02:31 <alinp> add :: (Int -> Int -> Int) -> Int
01:02:36 <alinp> add f = f x y
01:02:43 <alinp> and I can't figure it out how
01:03:02 <alinp> I mean, to have a function ... that receives a function as a param (f)
01:03:16 <alinp> f receives 2 params and returns an Int
01:03:40 <alinp> I think I want to do a function that calles a passed function as a param :)
01:03:40 <Peaker> my breakout game has one last flaw - hard to detect which kind of collision happened with the bricks..
01:04:13 <Peaker> alinp: add f = f x y       is fine, but what are x and y?
01:04:39 <alinp> it was just an example
01:04:44 <alinp> I don't know how to write it
01:04:55 <alinp> myf :: (Int -> Int -> Int) -> Int
01:04:55 <alinp> myf f x y = f x y
01:04:56 <Peaker> alinp: the signature you gave up must make up 2 Int values from somewhere to give to the function
01:04:57 <dufflebunk> Peaker: square balls don't bounce very well
01:05:00 <alinp> something like that I want to do
01:05:05 <Peaker> dufflebunk: heh, why not?
01:05:07 <Ferdirand> you want ($) ?
01:05:20 <Peaker> alinp: myf has 3 args, not 1
01:05:40 <alinp> so, how can I do it ?
01:05:47 <Peaker> your myf type has just 1 arg of type (Int -> Int -> Int), but you wrote 3 args like: myf f x y.  so f is (Int -> Int -> Int), what are x and y?
01:05:48 <alinp> a simple case:
01:05:59 <alinp> a function that takes a function as argument and calles that function
01:06:05 <Peaker> @src ($)
01:06:05 <lambdabot> f $ x = f x
01:06:17 <dufflebunk> Peaker: the bouncyness depends on what part of the ball impacts the surface
01:06:47 <Peaker> dufflebunk: yeah, but because of the discrete advancement, you find yourself "inside" the ball, and using the speed to compute the trajectory is complicated
01:06:57 <Peaker> dufflebunk: (more complicated than I'd like to use)
01:07:07 <Peaker> alinp:     myf f x y z = f x y z   ?
01:07:33 <alinp> ok, and what is the type for it ?
01:08:09 <dufflebunk> (a -> b -> c -> d) -> a -> b -> c -> d
01:09:12 <alinp> thanks dufflebunk
01:09:25 <alinp> but ... why I need all 4 of them after ")" ?
01:09:26 <Peaker> @pl myf f x y z = f x y z
01:09:26 <Peaker> ,pl myf f x y z = f x y z
01:09:26 <lambdabot> myf = id
01:09:27 <lunabot>  luna: parse error on input `='
01:09:43 <alinp> (a -> b -> c -> d) -> e
01:09:49 <alinp> why can't I do this ?
01:10:39 <dufflebunk> you can't apply the function without the functio nparameters...
01:11:04 <alinp> hmmm
01:11:31 <Peaker> alinp: because the (..) is your function, and in addition to the function, you want the args to apply to that function
01:11:32 <alinp> it does makes a small sense :)
01:11:49 <alinp> ok ... so I can't apply it as is
01:12:10 <alinp> in fact ... applying = f and ards
01:12:14 <alinp> *args
01:12:43 <alinp> ok, now it makes sense
01:12:51 <alinp> I got a little confused
01:12:56 <alinp> thanks for details
01:20:08 <ski> > let myf :: (Int -> Int -> Int) -> Int; myf f = f 42 17 in myf mod  -- alinp
01:20:10 <lambdabot>   8
01:21:30 <eflister> yo.  i need some help nesting lambdas to get at multiple MVars in a ReaderT.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7915
01:21:42 <eflister> it works ok when i don't have to do more than one at a time.
01:21:56 <ski> > let myf :: (Int -> Int -> Int) -> Int; myf f = f (42 + f 945 (myf (\x y -> f (x*x) (y+y)))) 17 in myf mod
01:21:57 <lambdabot>   * Exception: divide by zero
01:22:08 <Peaker> @djinn (Int -> Int -> Int) -> Int
01:22:08 <lambdabot> Error: Undefined type Int
01:22:14 <Peaker> @djinn (a -> a -> a) -> a
01:22:14 <lambdabot> -- f cannot be realized.
01:23:30 <ziman> :t fix . join
01:23:31 <lambdabot> forall a. (a -> a -> a) -> a
01:24:37 <Peaker> Every time I write a record, I write a bunch of boilerplate that should come with the record :-(
01:24:51 <Peaker> accessors that let me lift a function into a particular field
01:24:57 <mjrosenb> is there any way to find out what message is attached to an error within ghci?
01:25:23 <eflister> Peaker: was that for me?
01:25:36 <Peaker> eflister: it was a general rant :)
01:26:13 <eflister> Peaker: oh cool.  it seemed like it might be related to my q.
01:26:29 <eflister> Peaker: mind taking a quick look at it?  :)
01:26:32 <Peaker> eflister: sure
01:26:41 <Peaker> btw, here is the boilerplate Haskell really should eliminate: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3165#a3165
01:26:56 <ski> eflister : what does `putStrLn "done"' correspond to in the first snippet ?
01:27:19 <eflister> ski: it's up there, just re-indented to make room for the compiler error comment
01:27:38 <eflister> ski: oh wait did i misunderstand your q?
01:28:06 <ski> the first snippet doesn't contain a call to `putStrLn'
01:28:28 <eflister> ski: oh the very first one?  yeah.  that is just to set up the motivation
01:28:54 <ski> also, the first snippet binds `d' (for possible later use), but the next snippet doesn't bind it (it's the `_' i think)
01:28:58 <Peaker> eflister: type sigs in the paste would really help looking at it
01:29:24 <mjrosenb> so about those exceptions....
01:30:32 <eflister> ski: i guess a putStrLn would go between take and put, but that example is different anyway cuz it's not exception safe -- hence the switch to modifyMVar/withMVar in the real examples.  in this case i don't need d, so am not binding it...
01:30:58 <eflister> Peaker: ok, just for CtxtRdrT?  i don't see what else to add...
01:31:20 <ski> you get the error because you're nesting `liftIO'
01:31:56 <ski> i would define one or two helpers
01:32:47 <eflister> Peaker: ok, added CtxtRdrT's def.  (whoops, doneC = doneComposing, sorry!)
01:32:55 <eflister> ski: ok, what would that look like?
01:33:07 <ski> .. wait a moment
01:33:48 <eflister> ski: actually another thing i've been wanting to ask about is liftIO -- i don't get what it's doing
01:33:59 <ski> @type liftIO
01:34:00 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:34:21 <ski> it lifts `IO'-actions to the monad you're in (which must be based on `IO')
01:34:39 <eflister> ski: is it only singled out from all the other monads because it is one-way?
01:36:28 <ski> rather that you often want to lift `IO'-actions regardless on what monad you're in
01:36:46 <ski> but i suppose this could be related to the "sin-bin"ness and "one-way"ness of it
01:38:08 <eflister> ski: yeah i don't get why there aren't liftXXX's required for every other monad you might want to be in.  i love Reader (just learned about it) but now i have all these liftIO's all over that i hate!
01:38:43 <ski> well, there could be several `ReaderT' in a monad stack .. but only one `IO' (at least nested)
01:39:11 <eflister> ski: is IO the only singleton monad?
01:39:29 <ski> what's a "singleton monad" ?
01:39:46 <eflister> ski: my attempt to capture what you were saying, that you can only have one :)
01:40:16 <eflister> ski: or that all references are to the same item
01:40:27 <ski> there is no `IOT' monad transformer .. that's why you can't nest it in a monad transformer stack
01:40:49 <eflister> ski: ah, good point.  (chewing on why this must be so...)
01:41:24 <ski> (you could still have `IO (Foo (IO a))' or `Bar IO (Baz IO) a' .. maybe that's even useful in some circumstances)
01:41:54 <ski> anyway .. it looks like this is the monad tunneling problem
01:42:01 * ski ponders if there's a way around, here
01:42:21 <eflister> ski: that sounds exciting, i feel like i'm in star trek now.
01:43:13 <eflister> ski: i don't yet see how to conceptualize IO a.  but i am able to use non-unit IO's in practice...  i just couldn't say what it means.
01:44:18 <ski> ("non-unit IO's" ?)
01:44:36 <eflister> ski: eg "IO Bool" instead of "IO ()"
01:46:10 <ski> a value of type `IO Bool' is an action that, whenever executed, with perform some `IO'-effects, and yield a `Bool' value as result
01:46:43 * ski wonders what would be a good name
01:46:44 <eflister> ski: sounds easy enough
01:48:16 <eflister> ski: "non-trivial"?
01:48:38 <eflister> ski: i guess that makes it sound like the action isn't trivial
01:48:40 <ski> @type let asksTo sel wrap body = do mv <- asks sel; liftIO (wrap mv body) in asksTo
01:48:41 <lambdabot> forall r a t b (m :: * -> *). (MonadIO m, MonadReader r m) => (r -> a) -> (a -> t -> IO b) -> t -> m b
01:48:50 <ski> @type let asksTo sel wrap body = do mv <- asks sel; liftIO (wrap mv body) in \sel -> asksTo sel Control.Concurrent.withMVar
01:48:52 <lambdabot> forall r a b (m :: * -> *). (MonadIO m, MonadReader r m) => (r -> GHC.IOBase.MVar a) -> (a -> IO b) -> m b
01:48:56 <ski> @type let asksTo sel wrap body = do mv <- asks sel; liftIO (wrap mv body) in \sel -> asksTo sel Control.Concurrent.modifyMVar_
01:48:57 <lambdabot> forall r a (m :: * -> *). (MonadIO m, MonadReader r m) => (r -> GHC.IOBase.MVar a) -> (a -> IO a) -> m ()
01:49:16 <ski> that helps with the clutter ..
01:49:19 <ski> .. but not the nesting
01:49:57 <ski> the problem is still that `body :: a -> IO b', i.e. with the `IO'-monad, instead of `a -> m b'
01:51:32 <ski> @type let asksTo sel wrap body = do mv <- asks sel; ReaderT $ \r -> wrap mv ((`runReaderT` r) . body) in asksTo
01:51:33 <lambdabot> forall r a a1 (m :: * -> *) a2 (m1 :: * -> *) a3. (Monad m1) => (r -> a) -> (a -> (a1 -> m a2) -> m1 a3) -> (a1 -> ReaderT r m a2) -> ReaderT r m1 a3
01:51:35 <ski> @type let asksTo sel wrap body = do mv <- asks sel; ReaderT $ \r -> wrap mv ((`runReaderT` r) . body) in \sel -> asksTo sel Control.Concurrent.withMVar
01:51:36 <lambdabot> forall r a a1. (r -> GHC.IOBase.MVar a) -> (a -> ReaderT r IO a1) -> ReaderT r IO a1
01:51:39 <ski> @type let asksTo sel wrap body = do mv <- asks sel; ReaderT $ \r -> wrap mv ((`runReaderT` r) . body) in \sel -> asksTo sel Control.Concurrent.modifyMVar_
01:51:40 <lambdabot> forall r a. (r -> GHC.IOBase.MVar a) -> (a -> ReaderT r IO a) -> ReaderT r IO ()
01:52:04 <ski> that helps with the nesting, at the price of binding you to `ReaderT r IO'
01:52:39 <ski> (it might be possible to remedy this, but it would probably require making a new abstraction)
01:52:48 <ski> eflister : choose your poison
01:53:09 <ski> using the latter, your example might look something like
01:53:21 <ski>    test = do
01:53:52 <eflister> ski: having trouble parsing all the typeFu
01:54:11 <ski>     asksTo queue withMVar $ \_ -> do
01:54:30 <ski>       asksTo doneC modifyMVar_ $ \_ -> do
01:54:47 <ski>         liftIO $ putStrLn "done"
01:54:53 <ski>         return True
01:55:18 <ski> (if i'm not erring somewhere)
01:55:28 <eflister> ski: ok chewing for a bit
01:55:36 <ski> does that snippet look acceptable ?
01:57:01 <ski> hm, actually, it would possibly look nicer if you swapped the `queue' and `withMVar' (as well as `doneC' and `modifyMVar_') arguments .. and swapping the `sel' and `wrap' arguments in `asksTo' too, of course
01:57:21 <ski>       asksTo modifyMVar_ doneC $ \_ -> do
01:57:23 <ski> et.c.
01:58:25 <ski> (one could also avoid the `$ _ -> do' repeated nesting by using a `ContT o m a' monad .. but i'm not sure that is warranted here)
01:59:38 <harlekin> When using CreatePipe in CreateProcess, do I have to hClose the created handles?
02:01:10 <ski> (hrm .. that'd be `asksTo :: Monad m => (r -> a) -> (a -> ContT o m b) -> ContT o (ReaderT r m) b' .. which wouldn't work satisfactory for `modifyMVar_'
02:01:33 <ski>  but `asksTo :: Monad m => (r -> a) -> (a -> ContT2 o p m b) -> ContT2 o p (ReaderT r m) b' would ..
02:01:36 <ski> )
02:01:56 <ski>   test = do
02:02:20 <ski>     asksTo withMVar queue
02:02:34 <ski>     asksTo modifyMVar_ doneC
02:02:50 <ski>     lift $ do
02:03:00 <ski>       liftIO $ putStrLn "done"
02:03:06 <ski>       return True
02:03:37 * ski grins
02:04:43 <eflister> ski: i haven't looked at Cont yet.  got it to compile tho.  :)  playing with it now...  how come your lambdas don't need parens?  :)
02:04:45 <ski> eflister : anyway, if you're using `ReaderT Context IO' (which i gather is what `CtxtRdrT IO' is), then you can use the `asksTo' above
02:05:13 <ski> lambdas don't need brackets
02:05:22 <ski> complex arguments needs brackets
02:05:25 <eflister> ski: the ones in my example did
02:05:37 <ski> but arguments to infix operators doesn't need brackets
02:05:50 <ski> (note i used the infix operator `$')
02:06:11 <eflister> ski: $'s didn't help mine
02:06:31 <ski> that's probably because the `>>=' interacted
02:06:57 <eflister> ski: ah makes sense
02:07:24 <ski> (i.e. `foo >>= bar $ baz' is interpreted as `(foo >>= bar) baz' instead of `foo >>= bar baz')
02:08:59 <ski> well, actually the `.'s interfered here as well
02:09:36 <ski> (`foo . bar $ baz' is interpreted as `(foo . bar) $ baz' rather than `foo . (bar $ baz)')
02:09:44 <harlekin> How would I send ^D to a Handle?
02:09:59 <ski> eflister : do you get it to work ?
02:11:19 <WorkyBob> harinath: EOF is 0x0 isn't it?
02:11:27 <harlekin> 0x4
02:11:52 <harlekin> WorkyBob, oh, EOF. My bad.
02:12:15 <harlekin> I figured I can use hPutStr h "\EOT" >> hFlush h. This correct?
02:12:34 <WorkyBob> "\0" I would expect
02:12:45 <ski> > ord '\EOT'
02:12:45 <WorkyBob> I dunno if handles are terminated with EOT or EOF
02:12:46 <lambdabot>   4
02:12:57 <WorkyBob> "\NUL" too
02:13:02 <harlekin> I need to send EOT. I don't want to terminate the handle.
02:13:08 <eflister> ski: yep this is working like i want.  thanks!  so the issue is one can't have liftIO's operating on each other, and you avoid that by...
02:13:15 <WorkyBob> okay, then what you wrote is correct
02:13:18 <harlekin> But thanks. This apparently works.
02:13:20 <ski> (harlekin : `hPutChar' ?)
02:13:28 <harlekin> ski, might be better. :)
02:14:05 <eflister> ski: not having asksTo in IO?
02:14:06 <ski> eflister : i avoid it by digging into the `ReaderT' by hand .. thus you lose the `MonadReader Context m' overloading you had
02:14:57 <ski> (eflister : did you swap the `sel' and `wrap' arguments, btw ?)
02:15:25 <eflister> ski: yeah i like how that reads.  is there some currying benefit too?
02:15:49 <ski> a slight one
02:16:34 <ski> you *might* (or might not) sometimes fix the `wrap' argument .. but then i can see you rather wanting to fix the `sel' argument instead, too
02:17:38 <eflister> ski: is my "asksTo not in IO" interpretation equivalent to your "reach into ReaderT by hand" explanation?
02:17:55 <ski> eflister : btw, with this you still have the "useless identifiers like 'done'" :) .. but it's only written in one place (`mv' in `asksTo')
02:18:37 <eflister> ski: oh yeah, huh.  couldn't >>= work here?
02:18:45 <ski> sure, if you prefer
02:19:20 <ski> it doesn't matter that much, because `asksTo' is only written once, and used many times .. and the uses of `asksTo' doesn't need "useless identifiers like 'done'"
02:19:59 <eflister> ski: agreed, i was just alarmed if i didn't understand >>=
02:20:36 <ski> you wanted to be able to nest this construction, and tried doing that by nesting `liftIO', which doesn't work ..
02:22:20 <ski> using the first version of `asksTo', the whole `asksTo withMVar queue $ do ...' would have been in `CtxtRdrT IO' (or at least `(MonadReader Context m,MonadIO m) => m'), but the body `do ...' would have been in `IO', thus disallowing nesting
02:23:37 <ski> with the second version of `asksTo' the `do ...' would be in the same monad as the whole .. with the price that it was fixed to `CtxtRdrT IO' (or `ReaderT Context IO')
02:24:18 <ski> eflister : if you ever want to change the monad here, say by adding `StateT s' or something, then you will need to change the code of `asksTo' accordingly, because of the loss of overloading
02:32:04 <hackagebot> breakout 0.0.1 - A simple Breakout game implementation. (EyalLotem)
02:34:32 <eflister> ski: got it, i think, except exactly what is meant by overloading here.  also, how the 1st version would have solved the problem, since it is in MonadIO.  and what MonadIO is.  :)
02:37:58 <ski> eflister : your monad `m' get's an overloading constraint `MonadIO m', whenever you use `liftIO' in it
02:39:29 <ski> eflister : also, i was (trying to) explain why the first version would *not* have solved the problem (more specifically, it wouldn't have solved the nesting part of it)
02:40:33 <ski> just having constraints `(MonadReader Context m,MonadIO m)' would be better for modularity (i.e. if you want to change what monad you use, it is nicer to not have to change as much code)
02:41:46 <ski> if the overloading was retained, then you'd (probably) not have to change `asksTo' one bit if/when you decide to change the monad
02:42:45 <ski> (s/get's/gets/ argh)
02:43:21 <eflister> ski: did you mean "not" instead of "just"?  cuz those are the constraints of asksTo, right?
02:44:08 <eflister> ski: and i can't find where you used "get's"...
02:44:57 <ski> (no, i meant "not", not "just")
02:45:33 <eflister> ski: do you mean yes and not no?  :b  :)
02:45:58 <ski> (and no, the only constraint on (the second version of) `asksTo' is the `Monad m' constraint)
02:46:42 <eflister> ski: oh right i was looking at the wrong one
02:46:54 <ski> (the first version had `(MonadIO m, MonadReader r m)' .. but that one didn't nest)
02:50:15 <eflister> ski: so 'loss of overloading' means that instead of just a MonadReader constraint, version 2 is totally specific about being ReaderT.  i guess a MonadReader constraint isn't all that flexible either is it?  or do you mean that i would only layer on additional monads to that constraint, whereas in version 2 i'd be messing around in the body of the fcn.
02:51:01 <ski> yes, for the first point
02:51:34 <ski> `MonadReader r m => m' is more flexible than `ReaderT r n'
02:52:32 <ski> yes, in the former case, `m' would be changed, but `MonadReader r m' would be retained so (hopefully) `asksTo' wouldn't need to change
02:52:49 <ski> in the latter case, you need to change it since the type has changed
02:53:38 <ski> (from `ReaderT r IO' to `StateT s (ReaderT r IO)' or `ReaderT r (StateT s IO)' or whatever)
02:53:51 <quicksilver> As a rule I think it's discouraged to have transformers appearing explicitly in type signatures.
02:54:02 <ski> (and obviously, this point holds generally, not only for `asksTo')
02:54:06 <quicksilver> Either use a newtype for your stack (which you only have to change in one place)
02:54:13 <quicksilver> or use some typeclasses.
02:54:54 <ski> yes, .. but that still doesn't help with digging into `ReaderT' manually in the body (unless you can abstract that in some nice way) :)
02:58:47 <Peaker> quicksilver: that rule of thumb also helps keep those types a secret, muha, muhahaha
02:59:21 <Peaker> the longer Haskell looks like magic to the outside world, the longer we can defer success :)
02:59:43 <quicksilver> ski: it does help you with digging into ReaderT manually.
02:59:54 <quicksilver> ski: you dig into your newtype-stack using a function
03:00:01 <quicksilver> and only that function needs to know how the stack is composed.
03:00:06 <quicksilver> so you only change it in one place.
03:01:35 <poucet> I had a question at work from a colleague, and did not see an obvious answer
03:01:53 <poucet> What would be an efficient way to build a histogram of a VERY long list of data, bucketted by say 100 buckets.
03:02:11 <poucet> (without falling back to IO)
03:02:37 <quicksilver> intmap?
03:02:38 <mauke> Map/IntMap?
03:02:45 <mauke> ST
03:03:51 <xenoblitz> >  (sortBy (compare `on` fst).sortBy (compare `on` snd)) [(4,1),(1,2),(2,2),(2,3)]
03:03:53 <lambdabot>   [(1,2),(2,2),(2,3),(4,1)]
03:03:58 <ski> i suppose you're thinking of something like `dig :: (forall f m. (Functor f,Monad m) => ReaderT R m (f a) -> ReaderT R m (f b)) -> (Foo a -> Foo b)' ?
03:03:59 <eflister> ski: trying to grok difference btw MonadReader r m and ReaderT r n.  what's a MonadReader?  i think an example would be if i were working with multiple different context structures, right?  but isn't that the 'r' part, which i have built into my CtxtRderT type (= ReaderT Context).  so i don't see any situations where the 1st version would work where the 2nd would require changes?
03:04:17 <poucet> quicksilver: that still adds a log M where M = size of histogram
03:04:23 <ski> (quicksilver : which might be a usable such an abstraction, in some cases)
03:04:39 <dmwit> eflister: MonadReader is a class.
03:04:46 <dmwit> eflister: ReaderT is an instance of that class.
03:05:14 <dmwit> eflister: The reason the class exists is because there are also instances for the other monad transformers.
03:05:17 <Peaker> @check \xs -> (sortBy (compare `on` fst) . sortBy (compare `on snd)) xs == sortBy (compare `on` (snd &&& fst)) xs
03:05:17 <lambdabot>   Parse error at "snd))" (column 57)
03:05:23 <Peaker> @check \xs -> (sortBy (compare `on` fst) . sortBy (compare `on` snd)) xs == sortBy (compare `on` (snd &&& fst)) xs
03:05:24 <lambdabot>   "OK, passed 500 tests."
03:05:32 <Peaker> @check \(xs::[Int]) -> (sortBy (compare `on` fst) . sortBy (compare `on` snd)) xs == sortBy (compare `on` (snd &&& fst)) xs
03:05:33 <lambdabot>   Parse error in pattern at "->" (column 14)
03:05:34 <dmwit> eflister: So, even if you have a Reader deep in your stack, the class functions work without lifting.
03:05:44 <Peaker> @check \xs -> (sortBy (compare `on` fst) . sortBy (compare `on` snd)) xs == sortBy (compare `on` (snd &&& fst)) (xs::[Int])
03:05:45 <ski> eflister : `ReaderT r m' is in `MonadReader', but so is `Reader r',`StateT s (Reader r)' and `ContT o (ReaderT r (StateT s IO))'
03:05:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:06:04 <dmwit> :t asks :: MaybeT (StateT s (ReaderT e)) e -- for example
03:06:05 <lambdabot> Not in scope: type constructor or class `MaybeT'
03:06:30 <dmwit> :t asks :: EitherT String (StateT s (ReaderT e)) e -- for example
03:06:31 <lambdabot>     Not in scope: type constructor or class `EitherT'
03:06:36 <dmwit> meh
03:06:36 <eflister> dmwit and ski: ahh...  nice.  this is why we only have liftIO?  why would this not work for IO?
03:06:38 <dmwit> you get the idea
03:06:51 <ski> eflister : "this" being ?
03:06:52 <dmwit> eflister: liftIO is the same idea, it's in the MonadIO class.
03:06:55 <doserj> @check \xs -> (sortBy (compare `on` fst) . sortBy (compare `on` snd)) xs == sortBy (compare `on` (snd &&& fst)) (xs::[(Int,Int)])
03:06:56 <lambdabot>   "Falsifiable, after 6 tests:\n[(0,5),(1,3),(0,-5),(0,-3)]\n"
03:07:02 <Peaker> @check \xs -> (sortBy (compare `on` fst) . sortBy (compare `on` snd)) xs == sortBy ((compare `on` fst) `mappend` (compare `on` snd)) (xs::[(Int, Int)])
03:07:03 <lambdabot>   "OK, passed 500 tests."
03:07:38 <eflister> dmwit and ski: hmm.  i thought you had explained for me why we don't need "liftReader" the way we need "liftIO"
03:08:06 <dmwit> eflister: Oh, because the number of actions you can lift in a Reader is pretty limited, so they just defined separate functions for each "lift".
03:08:18 <dmwit> eflister: You can't enumerate all the things you want to lift quite as easily in IO.
03:08:27 <dmwit> eflister: So you just write a generic lift, and apply it.
03:08:41 <ski> eflister : in a sense `ask',`asks',`local' each contain a "liftReader" .. i.e. they require the monad `m' in question support `MonadReader r m'
03:08:47 <dmwit> eflister: However, you only have to apply liftIO once, not lift . lift . lift . lift or whatever to lift through three layers of monad stack.
03:08:56 <ski> eflister : as dmwit says
03:09:02 <quicksilver> poucet: I don't think so, no. It adds log B where B = number of buckets
03:09:15 <poucet> quicksilver: that is what I meant :)
03:09:30 <quicksilver> poucet: sure, but the number of buckets is fixed and reasonably small.
03:09:32 <ski> quicksilver : hrm, forgot to attribute my question about `dig' above to you
03:09:35 <poucet> quicksilver: M where M is size of histogram, i.o.ow buckets
03:09:41 <dmwit> :t liftIO :: IO a -> StateT s (ReaderT e) a
03:09:42 <lambdabot>     `ReaderT e' is not applied to enough type arguments
03:09:42 <lambdabot>     Expected kind `* -> *',
03:09:42 <lambdabot>     but `ReaderT e' has kind `(* -> *) -> * -> *'
03:09:48 <poucet> quicksilver: sure, but I'm wondering about how to do it performantly
03:09:52 <dmwit> :t liftIO :: IO a -> StateT s (Reader e) a
03:09:54 <lambdabot>     Could not deduce (MonadIO (Reader e)) from the context ()
03:09:54 <lambdabot>       arising from a use of `liftIO' at <interactive>:1:0-5
03:09:54 <lambdabot>     Possible fix:
03:09:56 <quicksilver> poucet: also it's arguably less than that, depending what philosophical stance you take on the complexity of IntMap.
03:10:05 <ski> :t liftIO :: IO a -> StateT s (ReaderT e IO) a
03:10:06 <lambdabot> forall a s e. IO a -> StateT s (ReaderT e IO) a
03:10:06 <dmwit> Man, I'm really striking out tonight. =P
03:10:19 <dmwit> Oh, right.
03:10:22 <dmwit> As opposed to:
03:10:45 <dmwit> :t lift . lift :: IO a -> StateT s (ReaderT e IO) a -- two lifts for two layers; more layers means more lifts, but the same simple liftIO
03:10:46 <lambdabot> forall a s e. IO a -> StateT s (ReaderT e IO) a
03:12:43 <eflister> dmwit and ski: thanks, that helps a lot!
03:13:44 <ski> np
03:13:57 * ski wants temporary types
03:14:06 <dmwit> Temporary types?
03:15:01 <ski>   foo :: Foo a -> Bar a
03:15:06 <ski>   foo (f :: Foo a) = ...
03:15:07 <ski>     where
03:15:13 <ski>     data Temp = T (..a..)
03:15:20 <poucet> locally declared types
03:15:33 <poucet> i.o.w. scoped types
03:15:42 <dmwit> Mmm, that sounds fun.
03:15:43 <ski> where `a' here is not a parameter of `Temp'
03:16:52 <ski> (so to transform it so that `Temp' is declared on top-level, we have to lambda-lift so that it gets `a' as extra parameter)
03:17:19 <ski> type variables local over a whole module might be useful sometimes, too
03:17:43 <ski> (imagine not having to write all the `s' in types in a module based on `ST')
03:17:45 <lilac> ski: would you want local instances too?
03:18:00 <lilac> local instances which can reference 'f' in your example above? :)
03:18:05 <ski> that would be nice .. if it could be done in a proper way
03:18:12 <lilac> i think that the latter is unsound
03:18:40 <lilac> because you can then have two Class Temp instances with different bodies
03:19:03 <lilac> (or once desugared, two Class (Temp a) instances)
03:19:13 <ski> one could possibly make it so that even on two calls to `foo' with the same `a' type, the resulting `Temp' type would be incompatible (not known to be same)
03:19:29 <lilac> that sounds plausible
03:19:44 <ski> (a bit similar to opening an existential box)
03:19:49 <lilac> i think Scala has a mechanism something like that
03:20:18 <lilac> it allows types to be members of values, and types with the same name which are members of different objects of the same type are different.
03:20:18 <ski>   data Showable = forall a. Show a => MkS a
03:21:03 <lilac> 'Temp' presumably can't (usefully) escape foo anyway (except as an existential)
03:21:10 <lilac> so i think you're right -- it's all OK
03:21:18 <ski>   case join (,) (MkS "foo") of (MkS x,MkS y) -> ...  -- `x' and `y' have incompatible types, here
03:21:27 <lilac> the rules for deriving Typeable might have to change, though
03:21:54 <ski> lilac : yes, the name `Temp' shouldn't escape `foo'
03:25:18 <ski> @hoogle StateT x (Reader x) a -> Reader x a
03:25:19 <lambdabot> Did you mean: StateT x (Reader x x) a -> Reader x a /count=20
03:25:19 <lambdabot> No results found
03:25:59 <ski> @hoogle ReaderT x (State x) a -> State x a
03:26:00 <lambdabot> Did you mean: ReaderT x (State x x) a -> State x a /count=20
03:26:00 <lambdabot> No results found
03:30:56 <eflister> ski: no reply from quicksilver...  am trying to understand your response to him.  what is the functor doing there, and what are Foo a/b meant to be?
03:32:50 <ski> eflister : `foo :: Foo a -> Foo b' was something else ..
03:33:51 <ski> as for `dig', i was thinking that might be a usable interface to abstract what i did in `asksTo' (or things like it)
03:34:05 <ski> (though maybe the `Functor f' should be `Monad f', instead)
03:34:15 <ski> a simpler variant of it would be
03:35:11 <ski>   dig_ :: (forall m x. Monad m => ReaderT R m x -> ReaderT R m x) -> (Foo a -> Foo a)
03:35:19 <ski> this is all assuming we have something like
03:36:08 <ski>   newtype Foo a = MkFoo ((..(ReaderT R (...))..) a)  -- a monad transformer stack, with `ReaderT R' somewhere in the middle
03:36:15 <ski> in your case, `R' would be `Context'
03:36:32 <mornfall> @src reverse
03:36:32 <lambdabot> reverse = foldl (flip (:)) []
03:37:15 <JaffaCake> malcolmw: I don't think $! needs to be changed: both definitions are semantically equivalent
03:37:31 <ski> hm, maybe something like
03:38:15 <malcolmw> JaffaCake: but not operationally equivalent, and as I keep pointing out, a lot of people think of strictness as an operational matter, not a semantic one
03:38:24 <ski>   newtype Foo a = MkFoo {unFoo :: ReaderT Context IO a}
03:38:47 <JaffaCake> malcolmw: if you want to make that change to Haskell, it's a much bigger change than just modifying $!
03:39:08 <JaffaCake> Haskell simply doesn't define an operational semantics
03:39:21 <ski>   digIO :: (forall f. Functor f => IO (f a) -> IO (f b)) -> (Foo a -> Foo b)
03:39:41 <JaffaCake> and indeed GHC will evaluate the arguments to seq in *any* order
03:40:02 <malcolmw> JaffaCake: yes, I know about the latter, and it is highly confusing
03:40:19 <JaffaCake> I disagree! the semantics are very clear
03:40:26 <ski>   digIO grovel ma = MkFoo (liftM runIdentity (grovel (liftM Identity (unFoo ma))))
03:40:38 <malcolmw> surely the name "seq" suggests sequence, yet that is exactly what ghc (and the current language definition) does not guarantee
03:41:20 <JaffaCake> ok, I won't disagree with that
03:41:27 <malcolmw> JaffaCake: so in my opinion, we should either change the name of seq, or change the definition so that it does mean sequential evaluation
03:41:52 <JaffaCake> changing the definition is not practical
03:41:57 <JaffaCake> and not desirable, IMO
03:42:11 <Philippa> doesn't the definition give a sequence, just not the one you expect?
03:42:21 <malcolmw> well, we have pseq, which does guarantee sequence
03:42:56 <JaffaCake> malcolmw: so, the proposed change to Haskell 98 is rundundant, agreed?
03:43:00 <dcoutts_> malcolmw: but also notice we never noticed that we needed to guarantee sequence until we started doing parallel evaluation
03:43:16 <JaffaCake> dcoutts_: or fixing space leaks :)
03:43:23 <dcoutts_> oh
03:43:35 <dcoutts_> why didn't we notice that previously then?
03:43:38 <malcolmw> dcoutts_: I dispute that - fixing space leaks was the whole rationale for introducing seq in the first place
03:43:51 <JaffaCake> seq is good enough, usually
03:44:04 <malcolmw> but often not good enough
03:44:15 <ski>   asksToIO :: MonadReader r Foo => (a -> (b -> IO o) -> IO p) -> (r -> a) -> (b -> Foo o) -> Foo p
03:44:18 <JaffaCake> good enough for space leaks, I mean
03:44:36 <JaffaCake> I've never encountered a space leak that I couldn't fix with seq
03:44:39 <malcolmw> no, sometimes it is not good enough for space leaks
03:44:49 <lilac> bigSpaceLeakIfNotForced `seq` restOfProgram ?
03:45:04 <JaffaCake> malcolmw: an example of that would be really interesting - do you have one?
03:45:20 <malcolmw> Colin, the space-profiling expert, has had programs that could not be fixed with seq, and needed pseq instead
03:45:59 <lilac> i certainly assumed that seq was more sequential than just 'seq !a !b = b'
03:49:39 <JaffaCake> malcolmw: so one way to look at this would be to divide Haskell into two layers: the lower layer having no evaluation order and no seq, and a layer on top mandating lazy evaluation and adding seq
03:50:05 <ski> hm .. `digIO' is not quite enough
03:50:07 <Daimonic> @src fst
03:50:08 <lambdabot> fst (x,_) =  x
03:50:17 <Daimonic> :t thd
03:50:18 <lambdabot> Not in scope: `thd'
03:50:20 <JaffaCake> lazy evaluation according to a well-specified op semantics, e.g. the Launchbury one
03:50:32 <Daimonic> let thd (_,_,z) = z
03:50:40 <Daimonic> > let thd (_,_,z) = z
03:50:41 <lambdabot>   not an expression: `let thd (_,_,z) = z'
03:51:12 <malcolmw> JaffaCake: yes, that might be reasonable (except that one usually thinks of operational semantics as being lower-level than the denotational semantics)
03:51:23 <JaffaCake> though I'm not sure it's a good idea; compilers don't really want to be tied to an evaluation order
03:52:01 <malcolmw> if the compiler can guarantee that something is already evaluated, then of course it does not need to do anything
03:52:25 <malcolmw> but on the other hand, if the user has explicitly asked for sequential evaluation, it seems wrong for the compiler to ignore that.
03:52:31 <JaffaCake> compilers want to be able to change the evaluation order - that's what strictness analysis does
03:52:43 <malcolmw> if the user only wanted strictness annotations, then they could use those instead.
03:54:02 <JaffaCake> so in x `pseq` y, not only is x required to be evaluated before y, but y is *not allowed* to be evaluated before x, even if the compiler can prove that it is giong to be evaluated eventually anyway
03:54:12 <JaffaCake> that can seriously hurt performance
03:55:54 <malcolmw> surely if y is already evaluated before we reach the expression (x`pseq`y), you can't un-evaluate y?
03:56:35 <JaffaCake> correct - but y is going to be evaluated anyway, so I could have evaluated it earlier and passed it unboxed
03:56:55 <JaffaCake> pseq stops that from happening
03:56:58 <Philippa> malcolmw: well, the implementation can throw away the result, hypothetically
03:57:24 <Philippa> you need the mandated lazy evaluation
03:58:29 <eflister> ski: hmm, not following.  so digIO would use unFoo to <what?> so that it could grovel, and then use MkFoo to <unwhat?> to cover its tracks?  the reason i write <what> instead of "get out of IO so liftIO need not be used" is because unFoo has IO in its type stack.  if liftM is replacing liftIO, then what do we need unFoo for?
04:06:21 <ski> eflister : wait a bit ..
04:07:43 <QP> @hoogle put
04:07:43 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
04:07:43 <lambdabot> Prelude putChar :: Char -> IO ()
04:07:43 <lambdabot> System.IO putChar :: Char -> IO ()
04:11:58 <lilac> does "pseq a b = case a `seq` True of True -> b" have the right operational semantics, or might the compiler optimize that to a `seq` b?
04:13:05 <Philippa> at first glance I would've thought it could
04:13:08 <QP> @hoogle pseq
04:13:09 <lambdabot> Control.Parallel pseq :: a -> b -> b
04:13:50 <lilac> semantically, this looks valid: case a `seq` b of ... => a `seq` case b of ...
04:18:41 <Daimonic> @src map
04:18:42 <lambdabot> map _ []     = []
04:18:42 <lambdabot> map f (x:xs) = f x : map f xs
04:36:58 <ski> eflister : the `liftM' there was in no way replacing `liftIO'
04:37:46 <eflister> ski: :) yeah kind of shot in the dark :b
04:38:45 <ski>   digIO :: (forall f. Functor f => IO (f a) -> IO (f b)) -> (Foo a -> Foo b)
04:38:58 <ski> is not quite enough for `asksToIO'
04:39:24 <ski>   digIO' :: (forall f. Functor f => (c -> IO (f a)) -> IO (f b)) -> ((c -> Foo a) -> Foo b)
04:39:41 <ski> would be, but i'm trying to think of a better way of abstracting that
04:41:39 <eflister> ski: i'm looking at this (top hit from googling 'monad tunneling') which looks like it may apply: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
04:42:51 <ski> yes, it's a similar problem
04:43:22 <quicksilver> dunno if you should read a long boring email from that Jules Bean joker, though. He's a total charlatan IMO.
04:44:49 <eflister> quicksilver =? jules
04:45:09 <quicksilver> oh noes! unmasked!
04:45:23 <eflister> :)
04:53:19 <cjs> "as many times as it once [sic]"?
04:54:43 <cjs> And "freez[ing] the...warmth and fuzzyness"? You cruel, cruel, man.
05:05:50 <quicksilver> cjs: hey, look, if I wanted my  grammar correcting I'd be posting to a usenet news group :P
05:07:25 <cjs> Whatever happened to alt.flames.haskell.monad.monad.monad, anyway?
05:07:33 <mauke> *corrected
05:07:35 <lilac> hey quicksilver, you put two spaces between "my" and "grammar"!!
05:08:08 <cjs> Now, lilac, to be precise, that's not a grammatical error, that's a typographical error.
05:08:43 <lilac> you mean it's not just open season on quicksilver right now? :)
05:10:02 <cjs> No, just that I feel it's incumbent upon us, if we're going to enumerate his errors, to enumerate them correctly.
05:10:11 <cjs> I know that that's a big job. :-)
05:12:19 <cjs> BTW, quicksilver, are you at ICFP this year?
05:14:43 <quicksilver> I never go to the ICFP. I can't bear the scrutiny that international conferences apply to my grammatical standards.
05:15:52 <cjs> Oh dear. I heard a rumour that mauke has been "rendered incoherent" on ##C.
05:16:11 <cjs> Do they do that? Hmm. Maybe that's why my paper was accepted.
05:16:27 <cjs> Or maybe just because I applied to the preschoolers' category. :-)
05:19:11 <ManateeLazyCat> Have an exist function that expand file name? Example expand "~/" to "/home/andy/".
05:20:23 <PeakerWork> @hoogle realName
05:20:23 <lambdabot> No results found
05:20:30 <PeakerWork> @hoogle realpath
05:20:30 <lambdabot> No results found
05:20:41 <Cale> hmm, canonicalizePath doesn't quite do it...
05:20:46 <PeakerWork> http://hackage.haskell.org/packages/archive/Unixutils/1.22/doc/html/System-Unix-FilePath.html#v:realpath
05:20:58 <Cale> But it does at least resolve relative paths into absolute ones...
05:21:12 <ManateeLazyCat> Cale: Yep, i can't understand canonicalizePath?
05:21:25 <ManateeLazyCat> Cale: Looks it use current-directory add filepath input.
05:22:51 <ManateeLazyCat> Try Unixutils....
05:23:55 <Cale> Tilde expansion is something which is usually done by the shell...
05:25:02 <Cale> (that's not to say we shouldn't have a library which does it)
05:25:11 <ManateeLazyCat> Cale: I think expansion operator should finish in System.FilePath package.
05:28:31 <ManateeLazyCat> realpath in Unixutils package can't handle symbol "~"
05:28:43 <ManateeLazyCat> it just handle ".." or "."
05:29:00 <ManateeLazyCat> Have another package expand filename?
05:29:14 <Axman6> @hoogle path
05:29:14 <lambdabot> Data.Graph path :: Graph -> Vertex -> Vertex -> Bool
05:29:14 <lambdabot> Test.HUnit.Base path :: State -> Path
05:29:14 <lambdabot> Test.HUnit.Base type Path = [Node]
05:29:20 <Axman6> @more
05:29:26 <Axman6> @hoogle+
05:29:26 <lambdabot> System.FilePath.Posix pathSeparator :: Char
05:29:26 <lambdabot> System.FilePath.Windows pathSeparator :: Char
05:29:26 <lambdabot> System.FilePath.Posix pathSeparators :: [Char]
05:29:50 <der_eq> does anyone know if the index*OffAddr operation is endian-dependend or just always little endian?
05:29:51 <ManateeLazyCat> @hoogle+
05:29:51 <lambdabot> System.FilePath.Windows pathSeparators :: [Char]
05:29:51 <lambdabot> Distribution.Simple.InstallDirs data PathTemplate
05:29:51 <lambdabot> Distribution.Simple.InstallDirs data PathTemplateVariable
05:31:10 <ManateeLazyCat> canonicalizePath do "getCurrentDirectory ++"
05:31:33 <ManateeLazyCat> @hoogle expandFileName
05:31:33 <lambdabot> No results found
05:31:42 <ManateeLazyCat> @hoogle expand
05:31:42 <lambdabot> No results found
05:32:28 <ManateeLazyCat> @hoogle canonicalize
05:32:28 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
05:32:45 <Cale> I wonder if there's a way to run bash so as to trick it into doing the expansion for you without opening up the possibility of running other commands.
05:33:43 <quicksilver> ManateeLazyCat: "~" expansion is not an OS-level service.
05:34:04 <Cale> Prelude System.Process> fmap (head . lines) (readProcess "bash" ["-c","echo ~/Downloads"] [])
05:34:04 <Cale> "/home/cale/Downloads"
05:34:12 <quicksilver> ManateeLazyCat: it's entirely specific to your shell. YOur shell might use @ or @@ for home directory and expand ~ to /etc/passwd, if it was feeling perverse.
05:34:30 <quicksilver> the only sense in which it is standard, is the sense that there is a POSIX shell standard.
05:34:49 <ManateeLazyCat> quicksilver: But it's better if it support, like `expand-file-name` in elisp.
05:35:32 <quicksilver> Sure. It would be handy.
05:35:48 <quicksilver> I'm just pointing out it's not an OS-service you can bind to.
05:36:28 <Cale> (the problem with the solution I just proposed is that it does nothing to guard against backtick expansion)
05:36:47 <der_eq> is someone here on a big-endian machine? Could you then load http://paste.lisp.org/display/84900 and tell me the value of i?
05:38:24 <ManateeLazyCat> quicksilver: Do you know anything.el in Emacs? It's like QuickSilver tools for search. :)
05:38:47 <ManateeLazyCat> quicksilver: I will develop a QuickSilver tools in my project.
05:39:17 <gwern> Cale: maybe he could use shsh to evaluate a string to a Sh AST and grovel through it looking for bad things?
05:39:29 * gwern guesses wildly that shsh can do that
05:39:57 <Cale> gwern: At that point, just writing the expansion yourself by hand is easier.
05:40:14 <gwern> ah, but you can't package up as a library writing it by hand :)
05:40:19 <ManateeLazyCat> Cale: I think i should write a function that similar `expand-file-name` in elisp for expand "~" "." ".."
05:40:30 <gwern> my idea, you could write a 'safesh' lib which provides sanitizing functions
05:42:32 <Ke> der_eq: ultrasparc III or alpha?
05:43:30 <der_eq> Ke: that doesn't matter, just wanna know if it's the same as on my x86
05:43:46 <Ke> der_eq: but what's their endianess
05:45:32 * ManateeLazyCat pasted "Manatee.Gtk.Utils" at http://paste2.org/get/360841
05:45:32 <ManateeLazyCat> Above is my gtk tools library, enjoy! :)
05:45:36 <der_eq> Ke: aren't they both big-endian?
05:50:54 <ManateeLazyCat> > let tt xs = fmap (head . lines) (readProcess "bash" ["-c","echo " ++ xs] [])
05:50:55 <lambdabot>   not an expression: `let tt xs = fmap (head . lines) (readProcess "bash" ["-...
05:51:52 <benmachine> lambdabot is unlikely to let you run processes btw
05:52:15 <benmachine> though I guess you still get a syntax check
05:53:31 <Cale> huh, that's a new error message.
05:53:40 * Cale wonders how that happened.
05:53:58 <ManateeLazyCat> Cale: In ghci okay.
05:54:14 <Cale> lambdabot just seems to randomly change its behaviour from time to time. :)
05:54:17 <benmachine> ManateeLazyCat: the let is not in anything?
05:54:42 <Cale> > let tt xs = fmap (head . lines) (readProcess "bash" ["-c","echo " ++ xs] []) in tt "~cale/lambdabot"
05:54:43 <lambdabot>   Not in scope: `readProcess'
05:54:50 <Cale> > let tt xs = fmap (head . lines) (System.Process.readProcess "bash" ["-c","echo " ++ xs] []) in tt "~cale/lambdabot"
05:54:51 <lambdabot>   Not in scope: `System.Process.readProcess'
05:54:55 <Cale> fine :)
05:55:05 <Cale> Even if it was in scope, you'd just get <IO String>
05:55:31 <Cale> lambdabot won't actually execute IO actions, because all it does is evaluation
05:56:20 <benmachine> so as long as you kept unsafePerformIO out of it there'd be no problem?
05:57:13 <Cale> benmachine: mhm, and of course limit resource usage
05:58:09 <Ke> der_eq: sorry can't help you hut sparcs are silly
05:59:00 <der_eq> Ke: thanks for trying
06:01:12 <ManateeLazyCat> Cale: "let tt xs = fmap (head . lines) (readProcess "bash" ["-c","echo " ++ xs] [])" can't work with ".." or ".", i still need write function that handle "~" ".." "."
06:02:29 <Cale> ManateeLazyCat: huh?
06:02:39 <Cale> ManateeLazyCat: It'll handle all the expansion that bash does.
06:02:54 <Cale> ManateeLazyCat: It's just that will include things like backtick expansion which are not safe at all.
06:03:25 <Cale> Prelude System.Process> fmap (head . lines) (readProcess "bash" ["-c","echo ~/Downloads"] [])
06:03:25 <Cale> "/home/cale/Downloads"
06:03:25 <Cale> Prelude System.Process> fmap (head . lines) (readProcess "bash" ["-c","echo `date`"] [])
06:03:25 <Cale> "Thu Aug 6 08:36:00 EDT 2009"
06:03:46 <ManateeLazyCat> hmmm
06:03:55 <Cale> oh, right, it doesn't expand ..
06:04:20 <Cale> .. is an actual directory entry though
06:04:26 <Cale> whereas ~ is not
06:04:55 <bakesz> hi guys!is there a bulit-in function which gives true or false about a list has exactly "n" elements or not?(sorry for my english)
06:04:55 <Cale> You shouldn't have to worry about expanding .. under normal circumstances, because the filesystem understands it
06:05:09 <ManateeLazyCat> Cale: Need use "current directory" to replace "." or ".."
06:05:43 <Cale> bakesz: no, but you can use length to get the length of a list which is known to be finite
06:06:03 <Cale> bakesz: If you want to be careful about infinite lists, then you can make use of drop and null
06:06:16 <luite> it might be better to (==[]).drop n
06:06:25 <Cale> never use (==[])
06:06:27 <Cale> use null
06:06:31 <luite> oh, good
06:06:34 <ManateeLazyCat> Cale: `doesFileExist` can't work with "~"
06:06:59 <luite> but that doesn't catch lists shorter than n
06:06:59 <ManateeLazyCat> @src doesFileExist
06:06:59 <Cale> ManateeLazyCat: The filesystem has . and .. directories in every directory.
06:07:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:07:04 <luite> @src null
06:07:04 <lambdabot> null []     = True
06:07:04 <lambdabot> null (_:_)  = False
06:07:18 <ManateeLazyCat> :t doesFileExist
06:07:20 <lambdabot> Not in scope: `doesFileExist'
06:07:24 <Cale> ManateeLazyCat: But ~ is not really a filename, it's something which the shell is reponsible for expanding.
06:07:40 <Cale> :t null
06:07:41 <lambdabot> forall a. [a] -> Bool
06:07:42 <Cale> :t (==[])
06:07:44 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:08:42 <ManateeLazyCat> Cale: So i still need expand filename before i open file.
06:08:48 <bakesz> Cale:i know length would be good,but for example if it's longer than n,then i'm not interested in how long is it,but as far as i know,the length function calculates it.Or it stops if i write "if length list >n then True else False" at nth position at length calculating?
06:08:50 <luite> ah I see
06:08:58 <luite> didn't realize that :)
06:09:00 <Cale> bakesz: right.
06:09:39 <Cale> bakesz: That's because length doesn't use a lazy natural number, but kind of stupidly uses an Int instead.
06:09:42 <QP> try take
06:10:12 <QP> so (==n).length.take n
06:10:26 <QP> ?
06:10:38 <mauke> not . null . drop n
06:10:53 <luite> mauke: what about shorter lists? :)
06:11:24 <soupdragon> (>= toNatural n) . genericLength
06:11:42 <mauke> oh, we're checking for exactly n elements
06:11:43 <ManateeLazyCat> Cale: So result is i need function to expand file name, because user will input that including "~", "..", "."
06:11:53 <mauke> ManateeLazyCat: why do you need to expand . or ..?
06:11:57 <gwern> soupdragon: wouldn't genericLength screw up on inifinite lists?
06:12:02 <Cale> @let checkLength n xs = let ys = drop (n-1) xs in (not . null $ ys) && (null . tail $ ys)
06:12:04 <lambdabot>  Defined.
06:12:10 <Cale> > checkLength 32 [1..]
06:12:12 <lambdabot>   False
06:12:21 <Cale> > checkLength 5 [1..5]
06:12:22 <ManateeLazyCat> mauke: In my project, i do "find file" module, then user input file for open it.
06:12:23 <lambdabot>   True
06:12:26 <Cale> > checkLength 3 [1..5]
06:12:28 <lambdabot>   False
06:12:31 <soupdragon> gwern, not with the Natual instance, you just have length (x:xs) = S (length xs)
06:12:38 <mauke> ManateeLazyCat: so?
06:12:38 <ManateeLazyCat> mauke: And user maybe input "~/file"
06:12:42 <mauke> ManateeLazyCat: why do you need to expand . or ..?
06:12:48 <gwern> soupdragon: but I thought the generic* functions were just Integer
06:12:55 <Philippa> bakesz: (==n) . length is about as good as it gets
06:12:55 <ManateeLazyCat> mauke: User maybe input "../file"
06:13:00 <Cale> ManateeLazyCat: You should never have to expand . or .. since those are actual files.
06:13:03 <mauke> ManateeLazyCat: and?
06:13:13 <Cale> ManateeLazyCat: Do an ls -l
06:13:26 <Cale> er, ls -la rather
06:13:28 <Philippa> > ((==2) . length ) [1,2]
06:13:29 <lambdabot>   True
06:13:36 <Cale> and you'll notice that . and .. appear in the list in any directory
06:13:37 <soupdragon> :t genericLength
06:13:39 <lambdabot> forall b i. (Num i) => [b] -> i
06:13:41 <ManateeLazyCat> Cale: Yep, i do it.
06:13:51 <Philippa> ...heh, we turned that off in the end, then?
06:13:55 * ManateeLazyCat pasted "File.hs" at http://paste2.org/get/360850
06:13:58 <ManateeLazyCat> Cale: Above
06:13:58 <Philippa> old habits die hard :-)
06:14:14 <Cale> Philippa: hm?
06:14:50 <Cale> Philippa: The problem with length is that it will compute more than necessary
06:14:59 <gwern> too strict
06:15:42 <bakesz> Cale:thanks for the checkLength function
06:15:47 <jeffwheeler> gwern: damn, that Dyre library sounds kick-ass
06:15:54 <gwern> indeed
06:15:56 <gwern> look at it yet?
06:16:14 <jeffwheeler> gwern: just a tiny bit
06:16:32 <ManateeLazyCat> Cale: I see where the problem, I just need handle "~".
06:16:37 * Philippa wonders how laggy her IRC connection's got
06:16:39 <maltem> gwern: did I interpret things correctly that dyre is an improved hconf?
06:16:44 <gwern> yes
06:16:46 <gwern> I think
06:16:53 <ManateeLazyCat> Cale: ".." and "." is actual files can pass test.
06:16:53 <maltem> ok :)
06:16:55 <jeffwheeler> gwern: HConf seems intimidating to replace, but it definitely seems important
06:17:01 <gwern> never was too clear about what hconf was
06:17:17 <maltem> gwern: what dyre is I s'pose
06:17:25 <Cale> bakesz: Of course, you should use it sparingly. Anything dealing with the length of a list or specific indices is often something to be concerned about.
06:17:27 <jeffwheeler> (And by HConf, I mean the whole mess used in Yi right now.)
06:17:27 <ManateeLazyCat> Cale: So now, i just write fucntio that filter files that match "^~*" . :)
06:17:38 <ManateeLazyCat> Cale: Thanks for help!
06:17:44 <Cale> ManateeLazyCat: no problem
06:28:38 * ManateeLazyCat pasted "functions." at http://paste2.org/get/360858
06:28:38 <ManateeLazyCat> Cale: In above, function `tryExpandBacktickFilePath` solution my problem.
06:28:42 <lilac> > genericLength [1,2,3] == (3 :: Natural)
06:28:44 <lambdabot>   True
06:28:48 <lilac> > genericLength [1..] == (3 :: Natural)
06:28:50 <lambdabot>   False
06:29:05 <lilac> > genericLength (1:2:3:undefined) == (3 :: Natural)
06:29:07 <lambdabot>   * Exception: Prelude.undefined
06:29:21 <lilac> > genericLength (1:2:3:4:undefined) == (3 :: Natural)
06:29:23 <lambdabot>   False
06:31:58 <ski> > genericLength (1:2:3:4:undefined) >= (3 :: Natural)  -- lilac
06:31:59 <lambdabot>   True
06:33:44 <lilac> > genericLength (1:2:3:undefined) >= (3 :: Natural)
06:33:46 <lambdabot>   * Exception: Prelude.undefined
06:33:52 <lilac> :(
06:34:20 <lilac> > 3 + undefined >= (3 :: Natural)
06:34:22 <lambdabot>   * Exception: Prelude.undefined
06:34:30 <lilac> onoes! a bug!
06:37:18 <ski> > succ (succ (succ undefined) >= succ (succ (succ (0 :: Natural)))
06:37:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:37:22 <lilac> > 4 + undefined > (3 :: Natural)
06:37:24 <lambdabot>   True
06:37:30 <ski> > undefined >= (0 :: Natural)
06:37:31 <lambdabot>   * Exception: Prelude.undefined
06:37:39 <ski> > (0 :: Natural) <= undefined
06:37:40 <lambdabot>   * Exception: Prelude.undefined
06:37:57 <ski> that's it
06:38:39 <ski> > undefined <= (0 :: Natural)
06:38:40 <ski> > (0 :: Natural) >= undefined
06:38:40 <lambdabot>   * Exception: Prelude.undefined
06:38:41 <lambdabot>   * Exception: Prelude.undefined
06:39:38 * ski appears to have painted himself into a corner with abstractions ..
06:41:04 <benmachine> > undefined < (0 :: Natural)
06:41:05 <lambdabot>   * Exception: Prelude.undefined
06:43:53 * ManateeLazyCat Sweet that solve backtick expansion problem.
06:45:50 <der_eq> no one here on a big-endian machine?
06:46:03 <lilac> what does it mean if 'cabal upload' says "400 Error in upload"?
06:46:21 <ManateeLazyCat> @hoogle a -> (a -> IO b) -> (b -> IO c) -> IO c
06:46:21 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
06:46:21 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:46:21 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
06:46:36 <byorgey> lilac: probably that the module fails some quality check.  Did you run 'cabal check'?
06:47:28 <byorgey> lilac: if 'cabal check' gives no errors, then try uploading through the Hackage website instead of the command line, it will show you the entire error message instead of just the first line.
06:47:30 <lilac> byorgey: i have now. well, actually, i ran 'cabal upload -c -v3'
06:47:47 <byorgey> ah, did that help?
06:47:59 <lilac> yeah. cabal check didn't report anything, though
06:48:07 <lilac> perhaps my version of cabal is too old :)
06:48:16 <byorgey> yeah, I ran into that same problem a while ago
06:48:27 * lilac wonders which versions of base are supported by this package :)
06:49:04 <byorgey> I think it's fixed in darcs cabal
06:49:26 <lilac> 6.10.3 is base 4 and 6.8.1 is base 3, right?
06:50:04 <ski> eflister : i "solved" the problem by inventing a new abstraction (which i hope is supported by enough monad transformers) .. but ran into another unexpected one; it can be avoided in your simple case, but i think it can't, more generally (such as adding `StateT s' to the stack)
06:50:43 <ski> eflister : maybe i'll continue thinking on this later
06:50:54 <byorgey> lilac: right
06:51:13 * lilac adds Build-depends: base >= 3 && < 5
06:51:26 * ski goes back to classifying `Thin' and `Thick' laws ..
06:52:51 <eflister> ski: ha ha did not expect it to lead to a night at the blackboard.  thanks for thinking about it tho!
06:52:57 <bd_> > maximumBy compare [1..1000000]
06:52:59 <lambdabot>   * Exception: stack overflow
06:53:02 <bd_> hmmm
06:53:04 <ManateeLazyCat> <=< is sweet.
06:53:16 <bd_> @src maximumBy
06:53:17 <lambdabot> Source not found. Wrong!  You cheating scum!
06:55:35 <hackagebot> numbers 2009.8.6.1 - Various number types (RichardSmith)
06:55:52 <lilac> ^^ bug with _|_ >= 0 fixed
07:00:00 <int-e> > 0/0 >= 0
07:00:01 <lambdabot>   False
07:01:04 <blueonyx> > 0/0 < 0
07:01:05 <lambdabot>   False
07:01:33 <blueonyx> > 0/0
07:01:34 <lambdabot>   NaN
07:01:34 <lilac> @tell Cale There's a new version of 'numbers' with a bigfix for (undefined :: Natural) >= 0. Might be nice to update \b if you have a moment...
07:01:35 <lambdabot> Consider it noted.
07:02:01 <lilac> > let nan = 0/0 in nan `compare` nan
07:02:03 <lambdabot>   GT
07:02:17 <lilac> > let nan = 0/0 in (nan - nan) `compare` 0
07:02:19 <lambdabot>   GT
07:02:28 <lilac> > let nan = 0/0 in (nan - nan) > 0
07:02:30 <lambdabot>   False
07:02:36 <benmachine> hah
07:02:58 <ski> > read "NaN" :: Double
07:02:59 <lambdabot>   NaN
07:03:19 <ManateeLazyCat> <=< make my code simpler, sweet.
07:03:42 <ski> i suppose `read' reads that because `show' shows it .. even though it's not valid haskell source
07:07:52 <ski> @type mfix
07:07:53 <ski> @type fix . (=<<)
07:07:53 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
07:07:54 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
07:08:26 <ski> i wonder if the latter is useful
07:09:11 <ManateeLazyCat> @hoogle (a -> m b) -> (b -> c) -> a -> m c
07:09:12 <lambdabot> No results found
07:09:26 <ManateeLazyCat> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
07:09:26 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:09:26 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:09:26 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
07:10:16 <benmachine> for the first one you have \f g a -> fmap g (f a)
07:10:19 <ray> kleisli arrow composition
07:10:25 <benmachine> @pl \f g a -> fmap g (f a)
07:10:25 <lambdabot> flip ((.) . fmap)
07:10:28 <ski> @type flip ((.) . liftM)
07:10:30 <lambdabot> forall a a1 r (m :: * -> *). (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
07:10:56 <benmachine> wait am I wrong
07:10:59 <benmachine> it seems so
07:11:09 <benmachine> @type \f g a -> fmap g (f a)
07:11:11 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> f a) -> (a -> b) -> t -> f b
07:11:20 <benmachine> erm
07:11:26 <benmachine> that works too I guess?
07:12:41 <ManateeLazyCat> ski: What's name for fucntio "flip ((.) . liftM)" ?
07:12:50 <ManateeLazyCat> flipLiftM?
07:13:00 <Botje> :t flip ((.) . liftM)
07:13:02 <lambdabot> forall a a1 r (m :: * -> *). (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
07:13:05 <ski> dunno if there is a name
07:13:24 <ray> but what's a good name?
07:13:40 <Botje> what an odd function :)
07:13:43 <ManateeLazyCat> Yep, what's good name?
07:13:53 <ski> @type (>>^)
07:13:54 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> (c -> d) -> a b d
07:14:03 <ManateeLazyCat> Botje: It's useful
07:14:07 <ray> arrows strike again
07:14:11 <ski> @type (runKleisli .) . (>>^) . Kleisli
07:14:13 <lambdabot> forall b c d (m :: * -> *). (Monad m) => (b -> m c) -> (c -> d) -> b -> m d
07:14:14 <Botje> it proabbly is
07:15:15 <ray> oh, cool, you can compose functions with arrows without arr
07:15:32 <ray> in case you don't want to be a pirate
07:15:40 <hackagebot> encoding 0.5.2 - A library for various character encodings (HenningGuenther)
07:16:00 <ski> fix . (=<<) = \f -> let m = join (liftM f m) in m
07:16:24 <ski> .. i suppose that wouldn't be useful for expression monads
07:19:18 <jmcarthur_work> :t \m f -> m >=> return . f
07:19:20 <lambdabot> forall a b b1 (m :: * -> *). (Monad m) => (a -> m b) -> (b -> b1) -> a -> m b1
07:20:10 <jmcarthur_work> @pl \m f -> m >=> return . f
07:20:10 <lambdabot> (line 1, column 22):
07:20:10 <lambdabot> unexpected "."
07:20:10 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
07:20:10 <lambdabot> ambiguous use of a right associative operator
07:21:57 <jmcarthur_work> eh it wouldn't be pretty anyway
07:22:37 <jeffwheeler> gwern: after playing with dyre for a while, the only blocker I see is that it uses Show/Read instead of Binary to store state.
07:22:58 <Saizan> @pl \m f -> m >=> (return . f)
07:22:59 <lambdabot> (. (return .)) . (>=>)
07:23:49 <jmcarthur_work> @pl \f -> m >=> (return . f)
07:23:49 <lambdabot> (m >=>) . (return .)
07:24:06 <jmcarthur_work> :t \m -> (m >=>) . fmap return
07:24:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> c) -> a -> m c
07:25:10 <jmcarthur_work> s/fmap/result/  and it's fairly readable, maybe
07:28:29 <Athas> The line 'instance Exception MyError' gives me the error "Type constructor `Exception' used as a class", yet the only 'Exception' I import is the one from Control.Exception.  What gives?
07:29:14 <mauke> Athas: which version of ghc?
07:29:27 <Athas> mauke: 6.10.1.
07:29:33 <mauke> hmm
07:29:45 <copumpkin> you compiling with cabal?
07:30:35 <mauke> works here
07:32:57 <WorkyBob> Athas: do you somehow have an old base specified
07:33:02 <WorkyBob> that looks like you're trying to use base-3
07:33:21 <Athas`> WorkyBob: possibly, I'm still on the copycat level about Cabal.
07:33:53 <Saizan> Athas`: you need to specify base == 4.* in your .cabal file
07:34:02 <WorkyBob> try cabal install blah --constraint="base==4"
07:34:08 <Saizan> Athas`: otherwise cabal-install defaults to 3
07:34:16 <Athas`> Does that mean I can remove the small_base cruft too?
07:34:19 <ManateeLazyCat> flipLiftM = flip ((.) . liftM) is very useful
07:34:43 <Saizan> Athas`: yeah, it won't work with base < 4 anyway
07:34:46 <soupdragon> :t flip ((.) . liftM)
07:34:48 <lambdabot> forall a a1 r (m :: * -> *). (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
07:34:52 <tkr> if f is a function of f(x) .. what does f(u :+ v) mean ?
07:35:02 <soupdragon> :t flip fmap
07:35:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
07:35:17 <WorkyBob> tkr: :+ is the constructor for complex numbers
07:35:23 <WorkyBob> u :+ v is u + iv
07:35:26 <soupdragon> :t flip fmap :: Monad m => (a -> m a1) -> (a1 -> r) -> a -> m r
07:35:27 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = m a1
07:35:27 <lambdabot>     In the expression:
07:35:27 <lambdabot>           flip fmap :: (Monad m) => (a -> m a1) -> (a1 -> r) -> a -> m r
07:35:28 <tkr> WorkyBob: ahh. brilliant.
07:35:56 <Axman6> > sqrt (-1) :: Complex Double
07:35:57 <lambdabot>   (-0.0) :+ 1.0
07:36:06 <Axman6> > sqrt (-1) :: Complex CReal
07:36:07 <lambdabot>   0.0 :+ 1.0
07:36:08 <tkr> WorkyBob: so if you know x, y in complex plane. you can just use them as an argument u :+ v to receive polar form?
07:36:14 <Athas`> Saizan: thanks.
07:36:26 <tkr> WorkyBob: or a complex number, that is.
07:36:55 <WorkyBob> u :+ v is not polar form no
07:37:04 <WorkyBob> it's a complex number u :+ iv
07:37:12 <WorkyBob> u + iv even
07:37:13 <dschoepe> @type polar
07:37:15 <lambdabot> forall a. (RealFloat a) => Complex a -> (a, a)
07:37:26 <WorkyBob> > polar (0 :+ 1)
07:37:28 <lambdabot>   (1.0,1.5707963267948966)
07:37:51 <WorkyBob> (0 :+ 1) is 1 unit up the line pi/2 from the origin
07:38:29 <stulli> Is there a way to override the default instances? I want a different implementation of Monoid (Map k v)
07:38:34 <tkr> WorkyBob: yes. complex number a in. a+ix as in (x,y) -> (u :+ v) = u + iv
07:39:04 <tkr> WorkyBob: can you work that backwards as handily also? is return (u -+ v) and you'd return (x,y) or something.
07:39:30 <tkr> (u :- v) # that was supposed to be my gyess.
07:39:33 <WorkyBob> @hoogle (RealFloat a) => (a,a) -> Complex a
07:39:34 <lambdabot> Prelude snd :: (a, b) -> b
07:39:34 <lambdabot> Data.Tuple snd :: (a, b) -> b
07:39:34 <lambdabot> Prelude fst :: (a, b) -> a
07:39:35 <dschoepe> stulli: You could define something like: NewMap k a = NewMap (Map k a) and define an instance for that
07:39:39 <WorkyBob> ah, bugger
07:39:42 <lilac> stulli: the normal way is to wrap it in a newtype
07:39:49 <WorkyBob> @type cartesian
07:39:51 <lambdabot> Not in scope: `cartesian'
07:39:53 <Axman6> @hoogle Complex
07:39:53 <lambdabot> module Data.Complex
07:39:54 <lambdabot> Data.Complex data RealFloat a => Complex a
07:39:54 <lambdabot> package storable-complex
07:40:07 <dschoepe> @type mkPolar
07:40:09 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:40:15 <lilac> stulli: which monoid instance do you want, incidentally?
07:40:27 <WorkyBob> > uncurry mkPolar . polar $ 0 :+ 1
07:40:28 <lambdabot>   6.123233995736766e-17 :+ 1.0
07:40:29 <stulli> dschoepe, lilac: wouldnt that mean i would need a newtype with 2 parameters? like newtype Foo k v = ...
07:40:38 <lilac> stulli: yep, it would
07:40:41 <WorkyBob> > uncurry mkPolar . polar $ 0 :+ 1 :: Complex CReal
07:40:43 <lambdabot>   0.0 :+ 1.0
07:40:54 <Axman6> :t mkPolar
07:40:55 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:41:00 <tkr> WorkyBob: what about different surfaces. can you work out a surface of geometry X that you can draw on using normal (x,y) cartesian cordinates?
07:41:00 <lilac> stulli: unless you know what one of the parameters to the Map type constructor is
07:41:12 <stulli> lilac: ghci complains when i want to do this...
07:41:23 <WorkyBob> tkr: I'm not sure I get what you mean by that
07:41:52 <stulli> lilac: basically i want to replace the default unions method of Monoid (Map k v) with unionsWith (+)
07:42:13 <lilac> stulli: you could use Map k (Sum v) i think
07:42:23 <tkr> WorkyBob: Im wondering about a bunch of (x,y) cartesian cordinates. describing, ie. a grid. I want to transfer them to complex numbers. perform transformations on them and then get back (x,y) cordinates I can plot easily.
07:42:23 <dschoepe> stulli: you would need to use data instead of newtype
07:42:34 <tkr> WorkyBob: this is what Id first like to do. :)
07:42:56 <WorkyBob> > uncurry (:+) (0,1)
07:42:58 <lambdabot>   0.0 :+ 1.0
07:43:11 <stulli> lilac, dschoepe: thanks a lot, that both sounds promising
07:43:12 <tkr> WorkyBob: ie. have a grid on flat surface. perform transformation on it so it becomes a riemann sphere on 2d.
07:43:31 <WorkyBob> tkr: sorry, you're into maths I don't know
07:43:35 <tkr> WorkyBob: then later wonder how I can map this newly formed 2d riemann surface on top of of a sphere etc.
07:43:39 <tkr> WorkyBob: ah. ok.
07:43:55 <tkr> Need to learn more Haskell, I think.
07:44:14 <tkr> been looking at HOpenGL and GLUT. Im not sure if they do what I want. maybe pixel, by pixel.
07:44:17 <Axman6> and WorkyBob needs to learn more maths :P
07:44:22 <WorkyBob> I do
07:44:27 <lilac> ugh, the default instance is Monoid (Map k v), not Monoid v => Monoid (Map k v) :(
07:44:32 <tkr> but there must be a more efficient way of handling a video memory of a window directly.
07:44:38 <lilac> so the Sum thing won't work :(
07:44:50 <WorkyBob> tkr: OpenGL lets you bind a framebuffer to draw into directly
07:45:02 <WorkyBob> there's pretty much no more efficient way to draw than with OpenGL
07:45:08 <WorkyBob> it works directly on the GPU
07:46:04 <tkr> WorkyBob: ok. then Ill use it. it has nothing ready made, Id like. but it can draw Points. :)
07:46:28 <alp2> hi. is there anything like fmap on 2-tuples, but that applies the function to the first element?
07:46:39 <mauke> yes, 'first'
07:46:48 <WorkyBob> tkr: what ready made stuff would you like?
07:46:57 <Athas`> Hmm, what's common practice for handling exceptions within a monad that isn't IO, but does wrap IO?
07:47:09 <dschoepe> alp2: "fmap first"
07:47:14 <dschoepe> @type fmap first
07:47:16 <lambdabot> forall (a :: * -> * -> *) b c d (f :: * -> *). (Arrow a, Functor f) => f (a b c) -> f (a (b, d) (c, d))
07:47:21 <alp2> thx!
07:47:25 <mauke> :t first
07:47:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:47:41 <Axman6> fmap first isn't right
07:47:46 <Axman6> just first is
07:47:59 <Axman6> :t first (f :: a -> b)
07:48:00 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
07:48:00 <lambdabot>       from the context ()
07:48:00 <lambdabot>       arising from a use of `f' at <interactive>:1:7
07:48:04 <Axman6> -_-
07:48:05 <tkr> WorkyBob: well. "I have coord [(x,y)..] .. I want to apply transformation f(z) on them (where (x,y) is behind the scenes transformed to complex numbers) and then get back coordinates I can plot.
07:48:21 <tkr> WorkyBob: I havent found an easy way to do it.
07:48:30 <Axman6> anyway, first (f :: a -> b) (x :: (a,c)) -> (b,c)
07:48:39 <tkr> WorkyBob: ie. draw a 2d grid. map it on a sphere surface using mobius.
07:48:42 <dschoepe> Axman6: Didn't he say he wanted something like fmap, so I assumed the tuple was in a Functor?
07:48:49 <mauke> :t first (?f :: a -> b) ?x
07:48:51 <lambdabot>     Could not deduce (?f::a -> b) from the context ()
07:48:51 <lambdabot>       arising from a use of implicit parameter `?f'
07:48:51 <lambdabot>                    at <interactive>:1:7-8
07:49:09 <Axman6> dschoepe: i think he wanted to map a function over the first element of a tuple
07:49:15 <mauke> dschoepe: the tuple *is* a functor
07:49:22 <WorkyBob> tkr: assuming you can describe your transform as an affine transform, you want to be setting up the model view matrix with apropriate values; putting the points in an array, and pushing them as a vertex array to draw in point mode
07:49:33 <mauke> fmap == second
07:49:34 <dschoepe> mauke: I know, I guess I misunderstood the question
07:49:40 <WorkyBob> mauke: no it doesn't
07:49:46 <WorkyBob> > fmap id undefined
07:49:48 <lambdabot>   No instance for (GHC.Show.Show (f a))
07:49:48 <lambdabot>    arising from a use of `M8214306621...
07:49:56 <WorkyBob> > fmap id undefined :: (Int,Int)
07:49:58 <lambdabot>   * Exception: Prelude.undefined
07:50:02 <WorkyBob> > second id undefined :: (Int,Int)
07:50:04 <lambdabot>   (* Exception: Prelude.undefined
07:50:05 <WorkyBob> see
07:50:08 <WorkyBob> not the same functions
07:50:22 <ski> @src (,) fmap
07:50:22 <lambdabot> fmap f (x,y) = (x, f y)
07:50:34 <WorkyBob> fmap can't be made lazy -- if it does it violates the functor laws
07:50:44 <ski> @src (->) second
07:50:45 <WorkyBob> fmap id _|_ would not be _|_
07:50:45 <lambdabot> second f = id *** f
07:51:05 <ski> @src (->) (***)
07:51:05 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
07:52:02 <Axman6> @src (->) first
07:52:02 <lambdabot> first f = f *** id
07:52:50 <tkr> WorkyBob: Im learning this only yes. But I was thinking something like having a function of drawing a grid. then transforming the (x,y)'s it returns so complex numbers. then applying any complex transformation I want on those values, and then finally turning the values back to (x,y) coordinates (with possible color attribute) to plot them easily.
07:53:06 <tkr> WorkyBob: I dunno yet what I want, I havent found it ready made. I want to learn math using haskell. :)
07:53:51 <Athas> Is there a monad transformer that encapsulates exception-like behaviour?
07:54:02 <ski> (WorkyBob : what if `(_|_,_|_) = _|_' was true ?)
07:54:24 <dschoepe> tkr: So your problem is getting them back to cartesian coordinates? You can use (realPart &&& imgPart) cmplx
07:54:32 <WorkyBob> ski: I have a blog post on that exact topic
07:54:33 <WorkyBob> >.>
07:54:36 <tkr> WorkyBob: I dunno if I should first plan a surface. have a coordinate system on it. and plot on the coordinates. or should I have a normal euclidean plane (with a grid drawn on it) and then perform transform on the whole surface.
07:54:42 <ski> (`fmap id _|_ = fmap id (_|_,_|_) = (_|_,id _|_) = (_|_,_|_) = _|_')
07:54:51 <tkr> dschoepe: hmm. interesting. :) Im butting this into my memos.
07:54:54 <WorkyBob> ski: http://noordering.wordpress.com/2009/04/19/bottoms/
07:55:00 <ski> WorkyBob : on what would happen if `(_|_,_|_) = _|_' ?
07:55:01 <ziman> Athas, i'd guess Control.Monad.Error.ErrorT
07:55:12 <dschoepe> tkr: hmm, actually it's imagPart instead of imgPart
07:55:17 <tkr> dschoepe: what is &&& ?
07:55:21 <Athas> ziman: that looks exactly like what I was thinking of.  Excellent!
07:55:23 <jeffwheeler> :t (&&&)
07:55:25 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:55:31 <WorkyBob> ski: yes, exactly that
07:55:33 <dschoepe> tkr: it applies two functions to a value and returns the results in tuple
07:55:36 <dschoepe> *a tuple
07:55:44 <dschoepe> (for functions that is)
07:55:50 <jeffwheeler> Okay, maybe not so pedagogical . . .
07:55:57 <tkr> dschoepe: this are all brilliant. with perl I would have to die for to be able to program my hobby. :)
07:56:21 <yrlnry2> I have a type constructor, Expr, and I want   something like   newtype Subst a = a -> Expr a.  So far so good.  Now I want to say that Subst is an instance of Monad.  But ghc says "Type synonym `Subst' should have 1 argument, but has been given 0"
07:56:24 <tkr> dschoepe: any further advices to me? about the surfaces, transformations, possible packages to take a look at, etc?
07:57:00 <tkr> dschoepe: http://www.cs.kent.ac.uk/projects/pivotal/cgraphics.html .. I was going to take a closer look how this is made tomorrow.
07:57:02 <yrlnry2> Excuse me, that's the error message if I try using type instead of newtype, which of course doesn't work.
07:57:15 <soupdragon> yrlnry2: You will have to use newtype
07:57:25 <dschoepe> tkr: Unfortunately I know not enough math to help you on that
07:57:30 <yrlnry2> But newtype fails too; it says that newtype 'a' is "not a constructor"'
07:57:43 <soupdragon> newtype Subst a = Subst (a -> Expr a)
07:58:03 <yrlnry2> Oh, it was complaining about *that* a.  I didn't get that.
07:58:12 <yrlnry2> No way to do it without an extra layer of constructors?
07:58:14 <dschoepe> tkr: But if you want to code all that in a more functional style, you could take a look at FRP implementations like reactive(-fieldtrip) and yampa
07:58:50 <maltem> yrlnry2: that layer will be optimized away, but it's necessary for type checking (or at least, the way newtypes work)
07:58:58 <soupdragon> yrlnry2: I do
07:59:02 <soupdragon> yrlnry2: I don't think so
07:59:05 <dschoepe> tkr: (By "all that" I mean displaying and animating the graphics etc.)
07:59:11 <tkr> dschoepe: hmm. yes. FieldTrip was in my to-take-a-look at list. Ill the the yampa also.
07:59:17 <yrlnry2> Okay, that makes sense.  Thanks.
07:59:56 <tkr> dschoepe: I dont know maths a shit. Im just little bit into complex analysis, topology, riemann surfaces etc.
08:00:02 <ski> WorkyBob : nice
08:00:21 <WorkyBob> ski: Augustus' point is well taken though
08:00:26 <WorkyBob> it does make implementation much harder
08:00:46 <ski> WorkyBob : were you present when i was pondering having tuples patterns not force anything by themselves, the other day ?
08:01:13 <WorkyBob> ski: no?
08:01:23 <WorkyBob> it sounds a little arbitrary to me straight off the bat
08:01:50 <ski> WorkyBob : assume for the sake of argument that `<a,b>' is our new kind of pair
08:01:59 * WorkyBob nods
08:02:28 <ski> WorkyBob : i would implement `f <a,b> = ..a..b..' as `f p = ..a..b.. where (a,b) = p' aka `f ~(a,b) = ..a..b..'
08:02:41 * WorkyBob nods
08:02:55 <ski> WorkyBob : however, `f <a,Nothing> = ..a..' would still be implemented as `f (a,Nothing) = ..a..'
08:02:58 * WorkyBob suggests we already have a perfectly good syntax for that kind of tuple...
08:03:04 <WorkyBob> f ~(a,Nothing)
08:03:10 <ski> no
08:03:42 <ski> i.e. a `<p0,p1>' pattern doesn't by itself force, but constructors in `p0' or `p1' will still force
08:04:04 <tkr> :t (&&&)
08:04:06 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:04:17 <WorkyBob> ski: sure, just like ~(p0,p1)
08:04:24 <ski> no
08:04:24 <tkr> I having a trouble understanding that really.
08:04:25 <WorkyBob> oh hang on
08:04:25 <yrlnry2> Oh, I remember now why I don't want the extra constructor on the Subst.  it's because I have defined Expr as a monad, so if x is an Expr and s is a Subst, I can x >>= s  and it does something sensible.  But for that to work, s must have type (a -> Expr b).  But if Subst is a constructed type, I can't use it with >>=.
08:04:30 <WorkyBob> no I see what you're saying
08:04:31 <yrlnry2> What do people usually do about this?
08:04:33 <WorkyBob> sorry, I missread
08:04:33 <WorkyBob> hmm
08:04:37 <WorkyBob> that's... interesting
08:04:56 <WorkyBob> ski: doesn't that implicitly force the (,) though?
08:05:11 <dschoepe> tkr: Well (&&&) works on arbitrary arrows, in your case the arrow is (->), i.e. normal functions
08:05:14 <WorkyBob> i.e. you have to figure out where the arguments to the constructors are to force them... which requires forcing the constructor
08:05:24 <ski> yes, the `Nothing' will need to first get the second part of the pair
08:05:39 <ski> but just matching the parts with variables will not force the pair
08:05:47 <WorkyBob> ah
08:05:51 <WorkyBob> so (a,b) will force nothing
08:05:57 <ski> this is to make `<_|_,_|_>' and `_|_' indistinguisable
08:05:58 <dschoepe> tkr: So in your case you can think of (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)
08:05:59 <WorkyBob> but (a,Nothing) will force the pair, and the Nothing
08:06:16 <ski> WorkyBob : someone mentioned one can implement this by view patterns, like `f (pair -> (a,b)) = ..a..b..' vs. `f (pair -> (a,Nothing)) = ..a..'
08:06:28 <WorkyBob> heh, cool
08:06:40 <ski> WorkyBob : assuming `newtype Pair a b = P (a,b); pair ~(a,b) = Just (a,b)'
08:06:45 <dschoepe> tkr: Arrow a => a b c, means that the arrow takes something of type b as input and produces something of type c as output
08:07:08 <tkr> dschoepe: how can I use lambdabot for my test purposes? I would like to (1,sqrt(2)) = z, perform something like ln(z*2*pi*i) and getting pack results in cartesian. (where z means a complex number)
08:07:11 <WorkyBob> hehe, cool
08:07:18 * WorkyBob must run off home and eat some foods
08:07:33 <dschoepe> > (realPart &&& imagPart) (1 :+ 2)
08:07:35 <lambdabot>   (1.0,2.0)
08:07:39 <ski> WorkyBob : anyway, the idea being that whats important about pairs is their two parts .. you can't "force" it, without using one of the parts
08:08:08 <dschoepe> tkr: just past (realPart &&& imagPart) whatever complex number you wish transformed back
08:08:28 <ski> WorkyBob : this appears to be a similar idea to Ryan Ingram's in your post, except that idea is based on unboxed pairs
08:08:43 <ski> WorkyBob : ok, ty for the link
08:09:12 <tkr> > (realPart &&& imagPart) (1 :+ sqrt(2))
08:09:14 <lambdabot>   (1.0,1.4142135623730951)
08:09:29 <tkr> > (realPart &&& imagPart) (0 :+ 1)
08:09:31 <lambdabot>   (0.0,1.0)
08:09:41 <tkr> very, very nice. is &&& standard lib?
08:09:52 <pikhq> tkr: Control.Arrow
08:10:55 <tkr> now when I just learn to built functions that provide dots on surfaces and the perform these transformations on these and plot the results, I will know math and haskell a bit better :)
08:11:39 <tkr> thanks for all who have helped this far. :)
08:13:07 <tkr> ski: ah. one more. I got (1.0 :+ sqrt(2)) how do I output the a*e^(ix) form ?
08:18:26 <djahandarie> Wait, if two power sets are equal, that means the sets themselves are equal as well, right?
08:19:18 <koala_man> yes
08:19:24 <maltem> >  let (a,b) = (1,sqrt(2)) in (sqrt(a^2 + b^2), atan(b/a))
08:19:26 <lambdabot>   (1.7320508075688774,0.9553166181245093)
08:20:50 <tkr> maltem: ay. yes of course. is it how accurate in Haskell?
08:22:54 <maltem> tkr: the floating point calculations, you mean? Well as accurate as they are in any language
08:23:04 <roconnor> >  let x = (1,sqrt(2)) in (abs x, signum x)
08:23:05 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
08:23:05 <lambdabot>    arising from a use of `GHC.Num.abs...
08:23:14 <roconnor> >  let x = (1 :+ sqrt(2)) in (abs x, signum x)
08:23:15 <lambdabot>   (1.7320508075688774 :+ 0.0,0.5773502691896257 :+ 0.816496580927726)
08:23:57 * Botje wonders if an arbitrary precision floating-point library exists
08:24:01 <roconnor> that is the pair (r, e^i(theta)), which is probaby better than (r,theta)
08:24:33 <roconnor> > tan (10^10) :: CReal
08:24:34 <lambdabot>   -0.5583496378112418465618934073186368185816
08:24:38 <roconnor> Botje: ^^
08:24:40 <maltem> (also I guess that should have been atan2, and a check for a=0 is missing too. wait, there's a complex signum?)
08:25:03 <tkr> #how do I do this: > let (1,sqrt(2)) = (u :+ v) = z; ln(z) ++ " " ++ ln(z+2*pi*i) ++ "  " ++ ln(z*4*pi*i)
08:25:09 <Botje> oh, heh :)
08:25:11 <Botje> yay!
08:25:20 <roconnor> maltem: yes, signum returns the unit complex number in that direction, which is probably more useful to you than the angle.
08:25:59 <maltem> ah good to know. so it's x / (abs x)
08:26:01 <roconnor> maltem: it has no singulairites
08:26:04 <roconnor> yes
08:26:22 <tkr> roconnor: ln(z) has infinite singularities.
08:26:25 <roconnor> I think the rules are that signum x * abs x ~~ x
08:26:36 <maltem> > signum (0 :+ 0)
08:26:37 <tkr> roconnor: so should I use something like "take 10" ? but how about the syntax?
08:26:38 <lambdabot>   0.0 :+ 0.0
08:28:08 <roconnor> > [ln (1:+sqrt(2) + i*pi*2) | i <- [0..]]
08:28:10 <lambdabot>   Not in scope: `ln'Precedence parsing error
08:28:10 <lambdabot>      cannot mix `Data.Complex.:+...
08:28:19 <roconnor> > [ln (1:+sqrt(2) + fromInteger i*pi*2) | i <- [0..]]
08:28:21 <lambdabot>   Not in scope: `ln'Precedence parsing error
08:28:21 <lambdabot>      cannot mix `Data.Complex.:+...
08:28:29 <roconnor> > [ln (1:+(sqrt(2) + fromInteger i*pi*2)) | i <- [0..]]
08:28:30 <lambdabot>   Not in scope: `ln'
08:28:36 <roconnor> > [log (1:+(sqrt(2) + fromInteger i*pi*2)) | i <- [0..]]
08:28:38 <lambdabot>   [0.5493061443340549 :+ 0.9553166181245093,2.049250865911271 :+ 1.4416058786...
08:28:50 <roconnor> er
08:29:04 <tkr> roconnor: ah. is it now multi-valued ?  nice
08:29:07 <roconnor> > [log (1:+ sqrt(2) + (0 :+ fromInteger i*pi*2))) | i <- [0..]]
08:29:08 <lambdabot>   <no location info>: parse error on input `)'
08:29:12 <roconnor> > [log (1:+ sqrt(2) + (0 :+ fromInteger i*pi*2)) | i <- [0..]]
08:29:14 <lambdabot>   Precedence parsing error
08:29:14 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `G...
08:29:19 <roconnor> > [log ((1:+ sqrt(2)) + (0 :+ fromInteger i*pi*2)) | i <- [0..]]
08:29:21 <lambdabot>   [0.5493061443340549 :+ 0.9553166181245093,2.049250865911271 :+ 1.4416058786...
08:29:41 <roconnor> but there are negative ones too
08:30:03 <roconnor> that we are missing
08:30:18 <tkr> roconnor: wait a sec. I think I got something on here.
08:30:34 <tkr> need to dig out my "Road to reality" -book :)
08:30:49 <roconnor> tkr: should I buy that book?
08:31:17 <tkr> roconnor: Im at page 200/1000, and been trying to understand it for 6-12months or so.
08:31:38 <tkr> roconnor: I dunno. (the beginning) is better then visual complex analysis, imho,
08:31:52 <roconnor> I took a course in differential geometry.  I hope that might help me
08:34:21 <yrlnry2> ping
08:34:27 <yrlnry2> thanks
08:35:29 <ski> > (magnitude &&& phase) (1 + sqrt (-2))  -- tkr
08:35:30 <lambdabot>   (1.7320508075688774,0.9553166181245093)
08:36:33 <tkr> ski: no change I could ge that as e^x instead of 1.732050.... etc?
08:36:42 <tkr> ski: s/change/chance/
08:37:32 <ManateeLazyCat> @hoogle (Monad m) => (a1 -> r) -> (a -> m a1) -> a -> m r
08:37:32 <lambdabot> No results found
08:38:08 <ski> @type realPart &&& imagPart
08:38:09 <lambdabot> forall c. (RealFloat c) => Complex c -> (c, c)
08:38:15 <PeakerWork> @hoogle (a -> b) -> (c -> m a) -> c -> m b
08:38:16 <lambdabot> No results found
08:38:18 <Beelsebob> ManateeLazyCat: not quite (<=<)
08:38:20 <PeakerWork> @hoogle (>=>)
08:38:21 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:38:56 <PeakerWork> @type (>=>) . (return.)
08:38:58 <lambdabot> forall a c b (m :: * -> *). (Monad m) => (a -> b) -> (b -> m c) -> a -> m c
08:39:02 <Philonous1> ReaderT appears to be in transformers, mtl and monadLib. Which one should I use?
08:40:42 <ski> > let (r,phi) = (magnitude &&& phase) (1 + sqrt (-2)) in (r :+ 0) * exp (0 :+ phi)
08:40:43 <lambdabot>   1.0 :+ 1.4142135623730951
08:41:44 <ski> tkr : how do you mean ?
08:43:16 <ManateeLazyCat> PeakerWork: Thanks!
08:43:32 <ski> > let (r,phi) = (magnitude &&& phase) (1 + sqrt (-2)) in exp (log r :+ phi)
08:43:33 <lambdabot>   1.0 :+ 1.4142135623730951
08:43:34 <ski> > let (r,phi) = (magnitude &&& phase) (1 + sqrt (-2)) in log r :+ phi
08:43:35 <lambdabot>   0.5493061443340549 :+ 0.9553166181245093
08:43:40 <roconnor> ski: I still think signum is better than phase
08:43:53 <tkr> ski: ie. ln(z) is not always ln(z)... ln(z) = ln(z+2*pi) :)
08:43:56 <maltem> Philonous1: there really isn't a concensus which is best
08:44:09 <ski> roconnor : for what ?
08:44:31 <ski> tkr : i'm not sure what you're after
08:44:36 <roconnor> ski: for everything except human consumption, and even that I wonder ...
08:45:04 <ski> the proper thing would be to return an element of `S_1'
08:45:18 <roconnor> unit complex numbers are S_1 :)
08:45:36 <roconnor> I suppose one could make a special newtype and smart constructor for unit complex numbers
08:45:50 <Philonous1> maltem: So neither of them is deprecating the other? OK, then I'll just stick to what I already use
08:46:10 <ski> and define `(*)' but not `(+)' ?
08:46:23 <roconnor> ski: Though signum returns 0 for 0.  I'm not sure if this is good or bad.
08:46:27 <tkr> are there quaternions in Haskell?
08:46:29 <ski> (well, in a few cases `(+)' would work ..)
08:46:32 <roconnor> ski: for the moment I say good.
08:47:16 <roconnor> tkr: not in the standard libraries
08:47:32 <ski> (tkr : and itym s/2*pi/2*pi*i/)
08:48:00 <roconnor> ski: I think some of my secret advanages in the last two ICFP contests was using unit complex numbers to represent my angles
08:48:18 <ski> any normalization ?
08:48:19 <tkr> quaternions are nice, and haskell gurus only knows, might be easy to implement and functional to use in computations :)
08:48:39 <ManateeLazyCat> @hoogle (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:48:39 <lambdabot> No results found
08:48:45 <tkr> roconnor: did the other use degrees? really?
08:48:47 <dschoepe> tkr: frag includes a module named quaternions, maybe you could reuse the code
08:48:49 <ski> tkr : have you met octonions and sedenions yet ?
08:48:52 <roconnor> ski: I don't think I did any.
08:49:01 <tkr> ski: no. never heard of.
08:49:02 <roconnor> tkr: radian's presumably
08:49:11 <ManateeLazyCat> How to implement "(Monad m) => (b -> c) -> (a -> m b) -> a -> m c" ?
08:49:44 <tkr> ski: quaternions are mathematical. first presentation of 4d calculations. funny fact is that necessarily a*b != b*a
08:49:49 <roconnor> @type fmap fmap fmap :: (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:49:50 <lambdabot>     Could not deduce (Functor m) from the context (Monad m)
08:49:50 <lambdabot>       arising from a use of `fmap' at <interactive>:1:10-13
08:49:50 <lambdabot>     Possible fix:
08:50:02 <roconnor> @type liftM liftM liftM :: (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:50:04 <lambdabot> forall b c a (m :: * -> *). (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:50:11 <roconnor> more seriously
08:50:15 <roconnor> @type liftM . liftM :: (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:50:17 <lambdabot> forall b c a (m :: * -> *). (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:50:48 <roconnor> ManateeLazyCat: the second liftM is the reader monad instance for (->) e
08:50:48 <ManateeLazyCat> Thanks!
08:50:58 <lilac> ski: (from way back in the scrollback) the view for lazier tuple matching doesn't need a newtype. just: lazy ~(a,b) = (a,b), then f (lazy -> (x,y)) = ...
08:51:11 <ski> @type flip ((runKleisli .) . (>>^) . Kleisli)
08:51:12 <lambdabot> forall b c d (m :: * -> *). (Monad m) => (c -> d) -> (b -> m c) -> b -> m d
08:51:37 * lilac imagines 'class Lazy a where lazy :: a -> a'
08:51:49 <roconnor> @type (.) . liftM :: (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:51:50 <lambdabot> forall b c a (m :: * -> *). (Monad m) => (b -> c) -> (a -> m b) -> a -> m c
08:51:57 <roconnor> @type (.) . liftM
08:51:59 <lambdabot> forall a a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> (a -> m a1) -> a -> m r
08:52:11 <ski> lilac : yes i know. i showed the `newtype' way, because then you can make the type abstract
08:52:21 <roconnor> ManateeLazyCat: `(.) . liftM' is the most specific.
08:52:34 <pikhq> Alternately: \f g x -> do a <- g x; return (f a)
08:52:58 <roconnor> ManateeLazyCat: but you don't need a monad.  A functor will do.
08:53:02 <roconnor> @type (.) . fmap
08:53:04 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
08:53:24 <ManateeLazyCat> roconnor: A funtor is better?
08:53:31 <lilac> ski: i don't see why it should be a different type of tuple just to support a differently lazy pattern match as a convenience :)
08:53:36 <ski> (lilac : was it you who showed that view pattern the other day ?)
08:53:46 <lilac> umm, i was there, but it wasn't my idea
08:53:48 <pikhq> ManateeLazyCat: More general.
08:53:56 <roconnor> ManateeLazyCat: depends on your instance.  In you case I'd guess no, but it is pretty arguable.
08:54:01 <lilac> i don't recall who it was :)
08:54:14 <tkr> > (sqrt(1), sqrt(1)) -> (u :+ v) -> Complex z; show z
08:54:15 <lambdabot>   <no location info>: parse error on input `->'
08:54:15 <ski> lilac : the point was to have a tuple type where `_|_' and `(_|_,_|_)' are indistinguishable
08:54:52 <lilac> so you'd have an ADT with a view pattern for matching but no exported constructor?
08:55:09 <ManateeLazyCat> I see, how to implement "(Functor f ) => (a -> f b) -> (b -> c) -> f c" ?
08:55:11 <lilac> that makes sense to me :)
08:55:18 <ski> yes
08:55:30 <ski> (and a function for constructing)
08:55:34 <lilac> i'm growing fond of using the module system to enforce invariants
08:56:47 <lilac> ManateeLazyCat: that can't be done. you probably want (a -> f b) -> (b -> c) -> a -> f c, i think
08:56:52 <Cynner>  New web browser based game -  http://www.lostworlds.lv/go.php?1139723800
08:56:59 <lilac> ManateeLazyCat: in which case that's flip (fmap.fmap)
08:57:13 <ski> lilac : ok, it was apparently yesterday, and it was jmcarthur_work who suggested it
08:57:22 <lilac> yeah, that sounds about right
08:58:29 <ManateeLazyCat> lilac: Yes, i want (a -> f b) -> (b -> c) -> a -> f c
08:58:48 <lilac> @type flip (fmap.fmap) :: Functor f => (a -> f b) -> (b -> c) -> (a -> f c)
08:58:50 <lambdabot> forall a (f :: * -> *) b c. (Functor f) => (a -> f b) -> (b -> c) -> a -> f c
08:58:58 * ski wonders why ManateeLazyCat wants all these combinators
08:59:18 <lilac> ManateeLazyCat: you might want to read conal's blog post on semantic editor combinators
08:59:25 <lilac> @go semantic editor combinators
08:59:26 <lambdabot> No Result Found.
08:59:58 <ManateeLazyCat> lilac: Is (a -> f b) -> (b -> c) -> a -> f c
09:00:16 <ManateeLazyCat> Not (a -> f b) -> (b -> c) -> (a -> fc)
09:00:25 <ski> ManateeLazyCat : it's the same
09:00:32 <copumpkin> :o
09:00:44 <lilac> ManateeLazyCat: http://conal.net/blog/posts/semantic-editor-combinators/
09:01:14 <ManateeLazyCat> lilac: Thanks, look it.
09:01:44 <Paczesiowa> would ghc generated code work with uclibc?
09:02:13 <lilac> ManateeLazyCat: basically, you have a function b -> c, and you have a value (a -> f b). now (a -> f b) is a b buried inside two functors, (a ->) and f
09:02:30 <ManateeLazyCat> (a -> f b) -> (b -> c) -> a -> f c same as (a -> f b) -> (b -> c) -> (a -> f c) ?
09:02:33 <lilac> ManateeLazyCat: so (fmap.fmap) will apply a function to the 'b' within (a -> f b)
09:02:52 <copumpkin> ManateeLazyCat: a -> b -> c === a -> (b -> c)
09:02:52 <lilac> ManateeLazyCat: yes, they're the same thing. -> is right-associative
09:03:06 * copumpkin designs a new -> that's commutative
09:03:29 <lilac> <-> ?
09:03:44 <lilac> that might be quite handy for views actually :)
09:03:54 <copumpkin> :P
09:03:58 <ManateeLazyCat> I see now.
09:04:00 <ManateeLazyCat> lilac: Thanks!
09:04:09 <lilac> no problem
09:04:10 <yrlnry2> I want to write \foo m1 m2 -> m1 >>= (\s1 -> case m2 of Nothing -> Nothing ; Just s2 -> foo s1 s2) without the internal 'case'.
09:04:24 <copumpkin> type (<->) a b = Isomorphism a b
09:04:29 <copumpkin> type (:<->) a b = Isomorphism a b
09:05:05 <yrlnry2> I thought I could use \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= (foo s1)), but I get the error "Ambiguous type variable `m' in the constraint:      `Monad m' arising from a use of `>>=' ..."
09:05:13 <yrlnry2> I would like to understand what is wrong here.
09:05:17 <lilac> yrlnry2: which monad are you in?
09:05:37 <lilac> (what is the type of m1?)
09:05:43 <yrlnry2> Maybe _.
09:06:06 <ski>   data Isomorphism a b = PromiseIsomorphic {fwb :: a -> b,bwd :: b -> a}
09:06:18 <copumpkin> ski: exactly! :P
09:06:28 <lilac> @type \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)
09:06:30 <ski> also
09:06:30 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
09:06:37 <lilac> yrlnry2: looks ok to me.
09:06:50 <lilac> yrlnry2: incidentally, that's liftM2 foo s1 s2
09:06:57 <ski>   data Retract a b = PromiseRetract {retraction :: a -> b,section :: b -> a}  -- restraction . section = id
09:07:03 <lilac> that is, your lambda is just liftM2
09:07:09 <yrlnry2> Yes, thanks.
09:07:34 <ski>   modifyRetract :: Retract a b -> (b -> b) -> (a -> a)
09:07:40 <lilac> yrlnry2: the problem is probably that GHC doesn't know which monad you want to work in any more (now that the Just and Nothing are gone)
09:07:55 <ski>   isoToRetract :: Iso a b -> Retract a b
09:07:57 <ski> et.c.
09:08:24 <copumpkin> I think we should make people promise harder
09:08:37 <copumpkin> could break things if they don't take it seriously enough
09:09:40 <lilac> copumpkin: data a <-> b = ITakeABloodOathTheseTwoFunctionsAreInverses (a -> b) (b -> a)
09:09:53 <copumpkin> that's more like it
09:10:12 <ski> copumpkin : Mercury has these `promise_pure' pragmas which play a somewhat similar role to `unsafePerformIO', except they are stated to be safe if the body they are applied to are (semantically / observationally) pure
09:10:15 <lilac> unsafeCheckBloodOath :: Programmer -> (a <-> b) -> Either CoverUpMurder Programmer
09:10:37 <yrlnry2> lilac: When I paste  \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1) at ghci, it can type-check it but not compile it.
09:10:38 <copumpkin> lol
09:10:57 <yrlnry2> That is, :t  \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)  produces the type I expect, but I can't actually compile the code.
09:11:07 <yrlnry2> (It gives the error message I quoted earlier.)
09:11:14 <Makoryu> @pl \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)
09:11:14 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
09:11:20 <ski> @type \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)
09:11:21 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
09:11:35 <yrlnry2> (and yes, liftM2 was what I was looking for.)
09:11:38 <ski> yrlnry2 : DMR
09:11:43 <yrlnry2> DMR?
09:11:44 <lilac> > (\foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)) replicate [1,2,3] [0,1]
09:11:46 <lambdabot>   [0,1,0,0,1,1,0,0,0,1,1,1]
09:11:50 <copumpkin> DamnedMonomorphismRestriction
09:11:52 <ski> Dreaded Monomorphism Restriction
09:11:57 <yrlnry2> Mm.
09:12:02 <yrlnry2> Okay.
09:12:03 * copumpkin failed
09:12:09 <yrlnry2> "copumpkin" is funny.
09:12:19 <ski> yrlnry2 : give it a type signature .. or move at least `foo' to the lhs of the equation
09:12:20 <copumpkin> :( fine, be sarcastic :(
09:12:31 <doublethink_work> copumpkin: no u
09:12:32 <lilac> yrlnry2: you need to turn off the monomorphism restriction or give your lambda a type signature or use it in the context where you mention it
09:12:40 <copumpkin> doublethink_work: ORLY
09:12:46 <doublethink_work> YA
09:12:50 <yrlnry2> Okay, thanks.
09:12:56 <yrlnry2> *many* thanks.
09:12:57 <lilac> ghc churlishly refuses to generalize the type of monad over which it operates
09:13:01 <copumpkin> doublethink_work: back to work or I tell the thoughtpolice
09:13:10 <ski> yrlnry2 : also, `liftM2' is not the same
09:13:11 <lilac> @seen thoughtpolice
09:13:12 <lambdabot> thoughtpolice is in #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard thoughtpolice speak 11h 38m 28s ago.
09:13:19 <ski> @type \foo m1 m2 -> m1 >>= (\s1 -> m2 >>= foo s1)
09:13:21 <ski> @type liftM2
09:13:30 <doublethink_work> lol
09:13:34 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
09:13:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:13:34 <ski> .
09:14:00 <lilac> @type (join.).liftM2
09:14:02 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
09:14:02 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
09:14:02 <lambdabot>     In the second argument of `(.)', namely `liftM2'
09:14:14 <lilac> @type (fmap.fmap.fmap) join liftM2
09:14:15 <ski> @type ((join .) .) . liftM2
09:14:16 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
09:14:17 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
09:14:29 <yrlnry2> It's the same up to the order of argmuents.
09:14:37 <ski> no
09:14:47 <EvilTerran> the type of the function parameter is different
09:14:54 <ski> `liftM2' doesn't take a function that returns `m ...'
09:14:55 <EvilTerran> liftM2 lifts a function with a pure result
09:15:04 <yrlnry2> Oh, sure.  That's fine.
09:15:11 <yrlnry2> Thanks for pointing that out.
09:15:28 <ski> yrlnry2 : one possible name for your function is `extendM2'
09:15:47 <ski> (`(=<<)' would be `extendM')
09:15:50 <yrlnry2> I just added 'import Control.Monad' so I could get liftM2, but now my definition of "join" doesn't work because uses of 'join' are ambiguous.
09:16:07 <EvilTerran> yrlnry2, "import Control.Monad hiding (join)"?
09:16:09 <yrlnry2> Can I instance Monad Foo where join ... ; return ...
09:16:12 <yrlnry2> ?
09:16:21 <ski> yrlnry2 : hide, import qualified, or rename
09:16:24 <lilac> ski: bind2?
09:16:30 <yrlnry2> and have it infer >>= from join, return, and fmap?
09:16:44 <EvilTerran> yrlnry2, alternatively, "import qualified Control.Monad as M" to get around the name collision
09:16:49 <ski> lilac : in my mind `bindM2 :: Monad m => m a -> m b -> (a -> b -> m c) -> m c'
09:16:56 <EvilTerran> (and then refer to Control.Monad.whatever as M.whatever)
09:17:12 <ski> (`(>>=)' is `bindM' and `(=<<)' is `extendM')
09:17:13 <tkr> yrlnry2: are you the dude who's book I ordered to work on the table (perl is my work)?
09:17:17 <lilac> ski: yeah, sounds reasonable :) in my mind all these functions are just called lift :)
09:17:29 <EvilTerran> yrlnry2, not with the Prelude definition of the Monad class, but you could define a Monad class where that would work
09:17:36 <yrlnry2> tkr: I don't know.  I'm Mark Dominus.  I did write a book about Perl.
09:17:43 <yrlnry2> EvilTerran: Thanks.
09:17:49 <ski> lilac : they are monadic, not just functoriadic (or applicative) ..
09:18:09 <tkr> yrlnry2: then its you. thank. without reading a copy of that book, I wouldnt understand a shit that is talked around here.
09:18:26 <tkr> yrlnry2: I just always thought you knew more maths also.
09:18:27 <yrlnry2> It's a shame that the prelude does not define Monad as a subclass of Functor.
09:18:28 <lilac> sure. but they're still all lifting operations in some sense as far as i'm concerned :)
09:18:50 <yrlnry2> tkr: You are very welcome.   I am glad you found it useful.
09:18:51 <ski> yrlnry2 : aye. woe and lamentations
09:18:59 <lilac> yrlnry2: it's a shame that that can't be fixed now without breaking code or introducing a language extension
09:19:09 <hackagebot> tagsoup-parsec 0.0.6 - Tokenizes Tag, so [ Tag ] can be used as parser input. (JohnnyMorrice)
09:19:15 <EvilTerran> yrlnry2, haskell' may sort out some or all of these things
09:19:19 <tkr> yrlnry2: I did. I read it illegal, but I asked my boss to order it to work for others to read also.
09:19:37 <yrlnry2> tkr: Did you know it is now available for free legal download?
09:19:44 <tkr> yrlnry2: you should sink more into maths and show us something that is beautiful.
09:19:50 <yrlnry2> And thanks for asking your boss to buy it.
09:19:54 <tkr> yrlnry2: no idea.
09:20:05 <yrlnry2> http://hop.perl.plover.com/book/
09:20:18 <EvilTerran> (not being able to define a monad in terms of join instead of >>=, and Functor not superclassing Monad)
09:20:23 <yrlnry2> There is no way I am going to spend years of my life writing a book about math that nobody will buy.
09:20:32 <tkr> yrlnry2: ahh. when I last looked at it it was only a beginninning "this is going to happen"
09:21:05 * EvilTerran likes class Functor, Functor => Pointed, Pointed => Applicative, Applicative => Monad
09:21:14 <yrlnry2> If I were independently wealthy, then maybe.  But I think in that case I would be more likely to write my look-dreamed book about digital information processing before 1945.
09:21:25 <tkr> yrlnry2: its not about math. it would be about abusing haskell to use maths as painting beautiful pictures and absolutely fascinating solutions to different questions w/o answers atm
09:21:33 <ski> EvilTerran : is there any uses of `Pointed' yet ?
09:21:41 <yrlnry2> tkr: Maybe you should write that book yourself.  It sounds great.
09:21:49 <EvilTerran> tkr, sounds like you should be writing this book, you seem to have some good ideas :)
09:22:15 <tkr> Wish I could. :)
09:22:36 <tkr> Im not a perl genius like Randall
09:22:58 <EvilTerran> ski, well, i've written utility functions at various times that need only pure/return, not (<*>)/ap
09:23:11 <hackagebot> shpider 0.0.6 - Web automation library in Haskell. (JohnnyMorrice)
09:23:16 <maltem> mmh, should it be Functor => Pointed, or Pointed => Functor?
09:23:17 <tkr> Maybe when Im getting close to my 60th birthday (at the end of this month is 30th)
09:23:35 <EvilTerran> maltem, definitely not the latter, there are non-pointed functors
09:23:49 <maltem> oh right
09:24:21 * ray likes Functor => Pointed, Pointed => Applicative, and Pointed => Monad
09:24:37 <tkr> yrlnry2: one more personal question. do you know (a, b, c) = (perl, maths, haskell) where a->c varies withing 1->10
09:24:42 <EvilTerran> ray, why not make Applicative a superclass of Monad, seeing as it is semantically?
09:24:49 <msteele__> yrlnry: I read your book too.  It was probably that book that prompted me to start looking into FP.
09:24:59 <yrlnry2> Sorry, I don't understand the question.
09:25:00 <lilac> is there anything of type Pointed f => F f which can't be rewritten as Functor f => Either (F f) (Identity f) ?
09:25:07 <ski> EvilTerran : yes .. but useful structures which are in `Pointed' but not in `Applicative' ?
09:25:12 <lilac> s/Identity f/f Identity/
09:25:14 <ray> i prefer instance Monad m => Pointed m
09:25:15 <yrlnry2> msteele__: That's great!  Thanks for telling me.
09:25:22 <ray> er
09:25:22 <tkr> yrlnry2: are you best in perl, haskell or maths?
09:25:29 <ray> instance Monad m => Applicative m
09:25:51 <tkr> yrlnry2: you are bad at chatting, since you dont point your answers and anyone. and a lot of people are asking questions of you.
09:26:14 <ski> ray : overlapping instances ..
09:26:53 <tkr> yrlnry2: see the "yrlnry2:" at the beginning of my sentence. if means that it was meant for you to read, the other can read it also if they are interested.
09:27:10 <ray> it supersedes the explicitly written applicative instances for monads, yes
09:27:32 <lilac> yrlnry2: i liked your recent blog on Hoare logic. i spent the rest of the day reading the links you posted :)
09:27:37 <EvilTerran> ski, well, i can't think of any off-hand. i gather from your tone that this is a common problem. ;)
09:27:42 <ski> lilac : elaborate on that `F f' ?
09:27:47 <ray> you shouldn't need to write ap for a monad, because you get it for free with join
09:27:51 <yrlnry2> tkr: My Haskell is still quite weak.  The fraction of possible Perl knowledge that I do possess is closer to 1.0 than the fraction of possible mathematics knowledge that I possess.  But I know more about math overall than I do about Perl.
09:27:59 <lilac> ski: F being some type-level function.
09:28:03 <ski> EvilTerran : not that i know .. i just haven't thought much about `Pointed'
09:28:10 <yrlnry2> lilac: There was a surprisingly good discussion about it on reddit.  Let me know if you want a link.
09:28:26 <lilac> yrlnry2: yeah, that sounds interesting :)
09:28:30 <ski> lilac : yes, but why would it be rewritten as the latter ?
09:28:48 <tkr> yrlnry2: nod nod. I know a *VERY little* about both. but I think I got an idea how to combine them.
09:29:22 <yrlnry2> lilac: http://www.reddit.com/r/programming/comments/96x11/the_universe_of_discourse_i_wanted_to_stick_to/
09:29:27 <tkr> yrlnry2: #perl people mainly ignore me. #math people (if there are competent around) like to listen and to help. and #haskell is new.
09:29:32 <lilac> ski: it shouldn't, but it's interesting to me to see how much/little power Pointed actually adds
09:29:42 <yrlnry2> #perl is a pretty dysfunctional channel.
09:29:59 <yrlnry2> #haskell is the most functional channel I've ever seen.
09:30:05 <yrlnry2> No pun intended.
09:30:09 <tkr> yrlnry2: with my 10y or perl in heart, where should I go then
09:30:16 <tkr> k. :)
09:30:41 <lilac> @remember yrlnry2 #haskell is the most functional channel I've ever seen.
09:30:42 <lambdabot> I will remember.
09:31:18 <mightybyte> lilac: It's important to have the "No pun intended." on the end of that quote.
09:31:35 <ray> i believe that pun was intended
09:31:51 <yrlnry2> ray: It truly was not.
09:32:22 <ski> lilac : i assume `f :: * -> *', so how is `f Identity' kind-correct ?
09:32:26 <tkr> yrlnry2: Im still bit wondering about these. cartesian (x,y) coordinatates -> transformed to complex numbers and transformations on them -> how on the earth to plot (x,y) back, without giving a shit about raytracing?
09:32:47 <yrlnry2> tkr: Sorry, I don't understand.
09:32:47 <maltem> It's confusing to say no pun intended when no pun was intented
09:32:59 <tkr> yrlnry2: also (didnt finish it) is also on my to-read post of of raytracing with perl. :)
09:33:17 <tkr> yrlnry2: I though you understand a lot. my mistake. pardon me.
09:33:36 <yrlnry2> tkr: I think we have a language problem.
09:33:53 <tkr> yrlnry2: what is your natural language?
09:34:16 <yrlnry2> English.  What is yours?
09:34:23 <tkr> yrlnry2: Finnish
09:34:49 <tkr> yrlnry2: I find the differences, if both got perl backgrond.
09:34:51 * maltem thinks #haskell members tend to prefer formal language.
09:35:32 <tkr> i am NOT haskell people. I am perlist who likes maths and likes to learn Haskell to make it easier.
09:35:43 <skorpan> ghc uses perl
09:35:53 <quicksilver> ssh we don't talk about that.
09:36:24 <alc> "cabal list --installed" only lists "libraries" with no "tools" (ie, happy, alex, hlint, or even cabal-install) showed
09:36:33 <quicksilver> suggesting ghc uses perl is like suggesting the british royal family is german
09:36:34 <alc> thats by design?
09:37:51 <maltem> alc, cabal only shows what cabal packages are installed
09:38:21 <g0ju> hello. i'm pretty new to haskell and currently i'm trying to solve some more or less simple problems with haskell. today i tried to solve project-euler problem nr. 3 (prime factors) and produced this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7924#a7924 could someone please take a look at it and tell me what i could do better?
09:39:07 <yrlnry2> @pl \x -> x
09:39:08 <lambdabot> id
09:39:10 <alc> maltem: I installed hlint using cabal install
09:39:21 <yrlnry2> @pl \f1 f2 x = (f1 x) >>= f2
09:39:22 <lambdabot> (line 1, column 10):
09:39:22 <lambdabot> unexpected "="
09:39:22 <lambdabot> expecting pattern or "->"
09:39:31 <yrlnry2> @pl \f1 f2 x -> (f1 x) >>= f2
09:39:32 <lambdabot> flip . ((>>=) .)
09:39:48 <yrlnry2> @pl \x f1 f2 -> (f1 x) >>= f2
09:39:48 <lambdabot> ((>>=) .) . flip id
09:40:23 <Makoryu> :t liftM2
09:40:25 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:40:41 <yrlnry2> @djinn a -> a
09:40:41 <lambdabot> f a = a
09:40:50 <alc> cabal-install version 0.6.2 using version 1.6.0.3 of the Cabal library
09:40:55 <yrlnry2> @djinn (a -> m b) -> (b -> m c) -> (a -> m c)
09:40:56 <lambdabot> -- f cannot be realized.
09:41:04 <PeakerWork> is Djinn someone's PhD thesis? :)
09:41:16 <maltem> alc, oh then I don't know. may be an actual bug then
09:41:34 <PeakerWork> @djinn Maybe a -> Maybe b -> Maybe (a, b)
09:41:34 <Paczesiowa> PeakerWork: I think augustss hacked it for fun:)
09:41:34 <lambdabot> f a b =
09:41:34 <lambdabot>     case a of
09:41:34 <lambdabot>     Nothing -> Nothing
09:41:34 <lambdabot>     Just c -> case b of
09:41:34 <lambdabot>               Nothing -> Nothing
09:41:35 <alc> "cabal list --installed hlint" shows nothing after a successful "cabal install hlint"
09:41:36 <lambdabot>               Just d -> Just (c, d)
09:41:39 <yrlnry2> Is there a standard function of type Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)  ?
09:41:47 <quicksilver> yrlnry2: >=>
09:41:47 <PeakerWork> Paczesiowa: damn, augustss does cool stuff :)
09:41:50 <yrlnry2> Thanks.
09:42:09 <quicksilver> PeakerWork: @djinn is sort of trivial. It's "just" a theorem prover for intuitionistic loic.
09:42:14 <quicksilver> standard stuff.
09:42:30 <quicksilver> it does have some relevance tweaks though which stray outside "standard stuff".
09:42:41 <stanv> how to get unique elements from list ?
09:42:50 <quicksilver> nub, although it's a bit slow.
09:42:50 <skorpan> nub
09:42:51 <Paczesiowa> PeakerWork: but it's based on some theorem prover, and you can't stick a finger in there without hitting some phd stuff
09:42:55 <skorpan> > nub [1,2,3,4,2,1]
09:42:56 <lambdabot>   [1,2,3,4]
09:42:59 <skorpan> oh, no, wait
09:43:01 <skorpan> i see what you mean
09:43:02 <yrlnry2> Peaker: Yeah, it's not as original as it might seem.
09:43:03 <Lemmih> alc: hlint isn't a package.
09:43:04 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
09:43:39 <yrlnry2> Nor as difficult as it might seem.
09:43:52 <Lemmih> PeakerWork: Excellent. Do you have a patch?
09:43:56 <Philonous1> g0ju: The limit of 10000 seem pretty arbitrary. What if one of the prime factors is > 10000?
09:44:04 <alc> Lemmih: how so
09:44:08 <Lemmih> Peaker: Excellent. Do you have a patch?
09:44:15 <PeakerWork> Lemmih: Only if you have a darcs repo for me to compare it against. Unfortunately it is at home, and I can't ssh home ATM
09:44:26 <pikhq> Philonous1: For the problem in question one of the prime factors *is* > 10000. ;)
09:44:37 <alc> Lemmih: doesnt cabal install just grabs it from http://hackage.haskell.org/package/hlint ? no?
09:44:38 <Philonous1> g0ju: primes = net [2..]  should work fine, though
09:44:57 <Lemmih> alc: Right.
09:45:03 <PeakerWork> quicksilver: I've seen people do ThD thesis's on trivial'er things
09:45:18 <g0ju> hm, that's a list of infinite lenght isn't it?
09:45:43 <mkaemmer> g0ju: yep. isn't laziness great?
09:45:54 <Philonous1> g0ju: Yes, but haskell is non-strict, so it will only ever calculate the elements it actually uses.
09:46:11 <Lemmih> alc: That package will install the 'hlint' executable. There's no library associated with it.
09:46:28 <Lemmih> alc: (The word 'package' is a bit overloaded.)
09:46:34 <quicksilver> Lemmih: that appears to contradict your earlier assertion "hlint isn't a package"
09:46:39 <Philonous1> g0ju: You just need to make sure that you will never traverse the entire list. But that shoudn't happen in your case.
09:46:44 <quicksilver> Lemmih: I think this overloading might be the source of the confusion :)
09:46:56 <alc> so thats the reason
09:46:56 <alc> but its really confusing
09:47:04 * quicksilver agrees with alc 
09:47:09 <quicksilver> I'm confused and it didn't even happen to me.
09:47:18 <Lemmih> quicksilver: The marklar is the marklar of the marklar?
09:47:29 <g0ju> is that going to speed the code up?
09:47:55 <maltem> hmph. so when cabal lists a package, it's a library package, but when it installs a package, it's a cabal package?
09:49:43 <Lemmih> maltem: Cabal will list all packages, libraries or not. But it can't detect installed executables so 'cabal list --installed' will only show libraries.
09:49:46 <yrlnry2> Why does    (Just s) = Nothing      not fail somehow?
09:50:06 <Lemmih> yrlnry2: Try printing 's'.
09:50:20 <g0ju> Philonous1: i changed it to [2..] and now it seems to calculate forever.
09:50:23 <mauke> s :: GHC.Prim.Any
09:50:24 <mauke> what
09:50:31 <quicksilver> Lemmih: quite.
09:50:35 <mauke> where did that come from
09:50:44 <yrlnry2> Lemmih: Yes, I know that I can't print s; I want to know why it doesn't fail sooner.
09:50:49 <Paczesiowa> > let Just s = Nothing in s
09:50:51 <lambdabot>   * Exception: <interactive>:1:137-152: Irrefutable pattern failed for patter...
09:51:04 <Lemmih> yrlnry2: s `seq` ()
09:51:11 <dschoepe> Hmm, can anyone explain why the scenario in the second exercise here fails to be a category? I tried simplyfing it: "(f  g)  h = f  (g  h)  id_A  h = f  id_B  h = f". Why does that contradict any laws? http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category
09:51:15 <quicksilver> yrlnry2: because it was decided that let bindings be maximally lazy.
09:51:51 <quicksilver> yrlnry2: if you do 'let s = error "I'm a lumberjack"' it's similar
09:52:01 <quicksilver> yrlnry2: that also doesn't error unless you inspect let.
09:52:02 <yrlnry2> Okay.
09:52:05 <quicksilver> inspect s.
09:52:08 <quicksilver> damn these words.
09:52:24 <mauke> quicksilver: how does this work with top-level bindings?
09:52:43 <quicksilver> top level bindings desugar to case, if they use patterns.
09:52:45 <yrlnry2> @pl \x -> maybe undefined id x
09:52:46 <lambdabot> maybe undefined id
09:52:48 <yrlnry2> Duhhh.
09:53:04 <quicksilver> if they don't use patterns they too are lazy.
09:53:24 <quicksilver> it's not quite as inconsistent as it sounds ;)
09:53:50 <mauke> I put 'Just s = Nothing' in my program and it was lazy
09:54:06 <quicksilver> yup
09:54:19 <quicksilver> but "f (Just s) = Nothing" desugars to case
09:54:23 <quicksilver> only if you call it, of course.
09:54:31 <mauke> and ghci said the type of s is GHC.Prim.Any
09:54:38 <quicksilver> it's not inconsistent but it is hard to explain.
09:54:44 <quicksilver> that's just a ghci bug
09:54:45 <alc> cabal list hlint && cabal install hlint && cabal list hlint -- still showing "    Latest version available: 1.6.5  Latest version installed: [ Not installed ]"
09:54:57 <quicksilver> forall a . a sometimes gets printed as GHC.Prim.Any
09:54:59 <quicksilver> I'm not sure why.
09:55:25 <alc> this is really confusing.  hope cabal-install has another layer processing installed pkg -- not just from 'ghc-pkg'
09:55:32 <Lemmih> alc: It can't see installed executables.
09:56:18 <alc> Lemmih: i know.  just hope it can improve it.
09:56:40 <alc> Lemmih: from a user's point of view
09:57:12 <Lemmih> alc: It's not a completely trivial thing to do. When an executable is installed is somewhat undefined.
09:58:52 <dschoepe> Can someone give me hint on how to answer the second exercise here: http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category ?
09:59:12 <alc> me thinks cabal can just jot down the info of 'cabal install' or 'cabal upgrade'-d pkg.
09:59:17 <Philonous1> g0ju: RIght, and I see why. x `elem` prime will diverge when x isn't actually in prime.
10:00:01 <g0ju> i don't get it. :<
10:00:34 <Lemmih> alc: That would be a hack. It wouldn't truly reflect what is current installed.
10:00:42 <pikhq> g0ju: elem doesn't assume a sorted list. elem will go over the *entire* list, checking to see if x is in there somewhere.
10:00:51 <g0ju> ah ok
10:00:52 <pikhq> And, obviously, prime is infinite.
10:01:08 <g0ju> so i should just remove that guard, eh?
10:01:08 <alc> it just need the info of that pkg -- it does not have to differentiate 'executables' from 'libraries': all are just pkgs
10:01:59 <pikhq> Not very clean, but: x `elem` (takeWhile (<=x) prime)
10:02:35 <mauke> x == head (dropWhile (< x) prime)
10:02:52 <pikhq> mauke: Much nicer.
10:05:23 <yrlnry2> Going for lunch now.  Thanks again to everyone who helped me.
10:05:25 <Philonous1> g0ju: Actually the second pattern is unneedet as it is covered by the third, because x `mod` x = 0
10:06:20 <Philonous1> s/pattern/guard
10:06:45 <QP> @history QP
10:06:46 <lambdabot> Unknown command, try @list
10:06:51 <QP> @list QP
10:06:52 <lambdabot> No module "QP" loaded
10:06:58 <QP> @list
10:06:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:07:21 <g0ju> Philonous1: thx. now the program runs much faster.
10:08:33 <QP> @ QP
10:08:39 <skorpan> @hoogle [a] -> Int -> [[a]]
10:08:39 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
10:08:39 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:08:39 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:08:42 <QP> @hist QP
10:08:42 <lambdabot> No module "QP" loaded
10:09:27 <QP> ok, can anyone tell me---was I just here a minute ago, asking a question about record notation?
10:09:28 <hackagebot> dyre 0.5 - Dynamic reconfiguration in Haskell (WillDonnelly)
10:09:52 <bremner> @seen QP
10:09:53 <lambdabot> QP is in #haskell. I last heard QP speak 26s ago.
10:10:10 <QP> well, i know that... :-)
10:10:22 <mauke> preflex: seen QP
10:10:22 <preflex>  QP was last seen on #haskell 12 seconds ago, saying: well, i know that... :-)
10:10:45 <QP> i suspect my client was broken---i made it myself and it is rather experimental...
10:11:18 <mauke> @localtime QP
10:11:34 <Philonous1> QP: You last spoke 4 hours before that
10:12:06 <alc> anyway, I just see it as a package installer/manager from a user's point (in a way like apt-get/port/fink/cpan/gem/..).  -- just hope cabal-install gets better =)
10:12:40 <alc> whats under the hood might be non-trivial.
10:13:10 <QP> ok, so my client stopped working for some reason... oh well... does anyone want to hear that question about record notation?
10:13:25 <alc> Lemmih: thanks for clearing that out.
10:14:30 <stanv> howto add one more module to ghc ? When I say: m Data.List -- all loaded programs go away
10:14:35 <QP> i'm wondering if there's a nice way to have polymorphic access functions---so several different types all with, say, 'name' or 'age' as one of their fields?
10:14:41 <stanv> ghci
10:14:42 <stanv> :)
10:15:00 <Lemmih> stanv: :m + Data.List
10:15:29 <mauke> import Data.List
10:15:29 <QP> stanv: i find import Data.List works
10:15:48 <stanv> Lemmih: thanks :)
10:16:10 <ceninan> hi - I was wondering what the correct way to deal with time is in haskell? I suppose I should use "new" time in Data.Time - but that seems to depend on "old-locale"
10:16:22 <ceninan> assuming I want to avoid both "old" packages, what do I do?
10:16:51 <Saizan> alc: cabal-install doesn't keep a register of what it has installed, it just asks ghc-pkg for the libraries you can find on your system, though it should so that it can support uninstallation, that's been an open ticket since a long time
10:17:25 <leimy_> Got an FFI question... I've implemented an interface in C which let's me write bytes to a buffer, but I'm not sure how to interface that with Haskell.  I see stuff like "Storable" and Ptr to data, but I don't know how to go from a Haskell string to a buffer that can be sent to C via a pointer for writing.  Anyone got an example?
10:18:09 <Saizan> @hoogle withCString
10:18:10 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
10:18:10 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
10:18:46 <Saizan> for writing?
10:20:17 <alc> Saizan: good to know. ah, uninstallation! thats right. look forward to it.
10:20:39 <leimy_> Saizan: Cool!  I suppose that would work.
10:20:42 <mauke> @hoogle alloca
10:20:42 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
10:20:42 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
10:20:42 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
10:22:35 <leimy_> Hmmm ok, now I know where to look, thank you.
10:26:15 <alex1> hi
10:26:40 <alex1> is it possible that show Double is extremely expensive?
10:27:17 <c_wraith> Is it true that Double is extremely expensive?  And compared to what, anyway?
10:27:49 <alex1> compared to show a Int
10:28:06 <dschoepe> Can someone give me hint on how to answer the second exercise here: http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category ?
10:28:13 <dschoepe> *a hint
10:28:33 <c_wraith> Why would  you use Double when Int does what you need, anyway?
10:28:42 <alex1> ok I don't have a concise benchmark yet - but in my application profiling shows that showPrec Double takes 37 % of all time
10:29:09 <alex1> nono I need Double
10:29:19 <alex1> and I need to show the Double
10:30:15 <alex1> but my application is the virtual machine from the 2009 ICFP with optimized STUArray as memory and now show Double takes 37 % of all the time
10:30:37 <LazyShrk> I'm trying to install Haskell Platform 2009.2.0.2 on Ubuntu 9.04. sudo make install gives me this error: "The mtl-1.1.0.2/Setup script does not exist or cannot be run". I've installed the libghc6-mtl-
10:30:41 <LazyShrk> * packages
10:30:47 <LazyShrk> Anyone had this problem?
10:31:15 <alex1> LazyShrk: I had the same problem - please remove the mtl package from ubuntu
10:32:42 <LazyShrk> alex1: and then?
10:32:53 <alex1> then try the make again
10:33:26 <alex1> or do the ./configure and make again - I didn't remember
10:34:03 <alex1> ah I see you have the problem at make install
10:34:07 <LazyShrk> alex1: ok.. i'll just clean out the folder and try again. both make and make install gave the same mtl error.. installed libghc6-mtl-prof to get make to work..
10:34:37 <LazyShrk> alex1: is the make install problem different?
10:34:50 <alex1> hmm one second
10:35:17 <alex1> I don't remember if I had the problem installing the platform or installing the GHC 6.11
10:36:05 <jeffwheeler> Can I require that a build dependency be built with a specific flag, from a Cabal file?
10:37:02 <dschoepe> jeffwheeler: Does cabal even store which flags a package was built with?
10:37:31 <jeffwheeler> dschoepe: I have no idea
10:37:37 <alex1> but I don't have any mtl package from jaunty installed not the dev, not prof and not doc
10:37:51 <doublethink_work> jeffwheeler: no, and AFAIK, this is part of the design of cabal
10:38:05 <jeffwheeler> doublethink_work: hmm, that's awkward
10:38:18 <doublethink_work> jeffwheeler: the underlying idea is that all packages should expose the same interface regardless of build flags
10:38:33 <jeffwheeler> doublethink_work: oh, that actually makes sense
10:38:35 <doublethink_work> and the flags should not affect the exposed API
10:38:47 <jeffwheeler> That's smart; now I have to rethink my idea. :P
10:38:53 <alex1> I followed the the instructions at: http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
10:40:08 <alex1> I had the mtl packages from the jaunty GHC 6.8.2 installed before and I remember that I had to remove them before being able to do anything useful with the platform sources
10:44:39 <alex1> can someone tell me where I can find the implementation of Show Double or any informations about?
10:46:40 <dschoepe> @src Double show
10:46:41 <lambdabot> Source not found. stty: unknown mode: doofus
10:47:00 <alex1> @src Double
10:47:00 <lambdabot> data Double = D# Double#
10:47:11 <alex1> @src Show
10:47:12 <lambdabot> class  Show a  where
10:47:12 <lambdabot>     showsPrec :: Int -> a -> ShowS
10:47:12 <lambdabot>     show      :: a   -> String
10:47:12 <lambdabot>     showList  :: [a] -> ShowS
10:47:48 <alex1> what means this D# Double#? Double# ist the unboxed type?
10:48:21 <Lemmih> @type GHC.Float.showSignedFloat
10:48:22 <lambdabot> forall a. (RealFloat a) => (a -> ShowS) -> Int -> a -> String -> String
10:48:52 <Lemmih> alex1: Check out base/GHC/Float.lhs
10:49:38 <alex1> Lemmih: Thanks I will do that
10:50:46 <alex1> base-3.x or base-4.x? what is the difference?
10:51:02 <alex1> sorry I'm new again in Haskell :-)
10:51:13 <stanv> does any body have the "craft of functional programming?" at hand ?
10:51:50 <stanv> I can't understand one exercise.
10:52:05 <doublethink_work> alex1: base-4 comes with GHC 6.10, and it contains some API-incompatable changes w.r.t. base-3.x
10:52:07 <Beelsebob> alex1: the APIs are incompatible in some ways
10:52:14 <etpace> Hmm, I'd like to try a simple problem to get to grips with AI and haskell, any tips on a problem?
10:52:21 <dons> different versions of the base library
10:52:25 <Beelsebob> mostly the exceptions stuf
10:52:35 <doublethink_work> alex1: notably the exception handling code was dramatically changed in the release of GHC 6.10
10:52:47 <alex1> thanks all
10:53:26 <alex1> ok where can I find the sources of base/GHC easily? Hackage?
10:53:48 <Lemmih> alex1: darcs.haskell.org/packages/base/GHC/Float.lhs
10:54:23 <alex1> very good :-)
10:56:14 <Taejo> is there a reason GHC *isn't* on Hackage?
10:57:30 <PeakerWork> Lemmih: btw: I wrote breakout using HaskGame which uses your SDL bindings, if you want to cabal install to try it out :)
10:57:31 <maltem> Taejo: it doesn't use cabal for building
10:57:35 <Lemmih> Taejo: Only bad reasons.
10:57:39 <PeakerWork> Lemmih: that's how I encountered the mouse button bug thingie
10:58:08 <PeakerWork> (its supposed to be trigged by left click, but middle click instead, cause of bug)
10:58:28 <Lemmih> PeakerWork: What's it called?
10:58:32 <PeakerWork> Lemmih: breakout
10:58:55 <PeakerWork> Lemmih: just a 5-hour hack or so, as a response to someone saying "You wouldn't write breakout in Haskell" in #python :)
10:59:04 <Lemmih> Ah, 'cabal update'.
10:59:10 <PeakerWork> yeah, its rather new
10:59:26 <Taejo> can't you cabalise packages that use other build systems? I've only ever used Build-type: Simple, but I assumed that's what non-Simple meant
11:03:19 <alex1> can I profile into showFloat?
11:04:34 <Lemmih> PeakerWork: That's pretty cool. Where are all the power-ups? (:
11:05:17 <LazyShrk> alex1: thanks btw.. removing mtl from ubuntu worked..
11:05:44 <mkaemmer> PeakerWork: nice work :)  I'm pretty sure most people who say "You wouldn't write __ in Haskell" suffer from lack of creativity/experience
11:05:53 <alex1> LazyShrk: nice to hear
11:11:48 <PeakerWork> Lemmih: heh, not yet there :-)
11:11:54 <PeakerWork> mkaemmer: Yeah :)
11:12:31 <PeakerWork> Lemmih: Actually I had implemented block collision detection last (It seems a tad buggy too, cause I don't take the speed into account), so before I implemented that, the "go through blocks" bonus was always on :)
11:12:46 <dschoepe> mkaemmer: You wouldn't write shellcode in Haskell :)
11:14:10 <PeakerWork> ok I found another bug :-)  All having to do with the discreteness of ball advancements
11:15:15 <msteele__> dschoepe: http://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/
11:15:40 <dschoepe> msteele__: I meant shellcode, not shell scripts: http://en.wikipedia.org/wiki/Shellcode
11:16:16 <dschoepe> But I admit it is kinda like unfair to use that example
11:25:25 <leimy_> So I'm noticing that the FFI for Haskell to C basically forces Int for array sizes where it looks like it really should have been using CSize.
11:25:39 <leimy_> as good C code working with allocated buffers should use size_t not int for sizes of buffers.
11:25:48 <therp> what haskell-ide gets xrefs right?
11:34:13 <Athas> I have a function 'translate v (w, ((x, y), d)) = (w, ((x+v,y), d))'.  Is there a way to write it in a less crummy way?
11:34:33 <Athas> It just updates a value inside a bunch of nested tuples.
11:34:39 <mauke> yeah, use less tuples
11:35:26 <Athas> Don't opress my people!
11:35:50 <mauke> :t second . first . first . (+)
11:35:51 <lambdabot> forall d d1 c d2. (Num c) => c -> (d, ((c, d2), d1)) -> (d, ((c, d2), d1))
11:36:23 <c_wraith> I thought there'd be an answer using those functions. >_>
11:36:29 <Athas> Oh yes, I wonder why I didn't think of that.
11:36:44 <Deewiant> translate v = second . first . first $ (+v) ... which indeed simplifies to that
11:37:16 <c_wraith> That answer's kinda pointy. :)
11:37:18 <Makoryu> @pl \v (w, ((x, y), d)) -> (w, ((x + v, y), d)) -- I wonder what this will do
11:37:20 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip ((.) . (.) . (.) . (,)) . ((((,) .) . (,)) .) . (+)
11:37:26 <c_wraith> hahahha
11:37:37 <Deewiant> I might write it using (>>>) though
11:37:56 <mkaemmer> c_wraith: your masterpiece--I love it!
11:38:00 <Deewiant> translate v = first >>> first >>> second $ (+v)
11:38:18 <dschoepe> @go semantic editor combinators
11:38:19 <lambdabot> No Result Found.
11:38:33 <dschoepe>  http://conal.net/blog/posts/semantic-editor-combinators/
11:38:33 <mkaemmer> c_wraith: nvm.  Meant for Makoryu
11:39:38 <Makoryu> So why doesn't @pl understand arrows, then?
11:40:03 <lilac> @type let ((w,(x,(y,z)))!) = ((w,y,z),x); (((w,y,z),x)((x,y),z)!!) = (w,(x,(y,z))); translate v w = (w!!)
11:40:05 <lambdabot> Parse error in pattern
11:40:20 <athos> @type \v -> first >>> first >>> second $ (+v)
11:40:21 <lambdabot> forall b d d1 d2. (Num b) => b -> (d2, ((b, d), d1)) -> (d2, ((b, d), d1))
11:40:33 <etpace> Is there a "pretty print" module in haskell?
11:40:55 <c_wraith> @hoogle pretty print
11:40:55 <lambdabot> module Text.PrettyPrint
11:40:55 <lambdabot> Language.Haskell.Pretty prettyPrint :: Pretty a => a -> String
11:40:55 <lambdabot> Language.Haskell.Pretty prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String
11:41:08 * jeffwheeler has fount PrettyPrint difficult to use, in the past
11:41:15 <jeffwheeler> * found
11:41:25 <c_wraith> The little bit I used it for wasn't bad.
11:41:34 <PeakerWork> Lemmih: btw, it required the middle click at yours too, right?
11:41:39 <c_wraith> But it was just formatting multiline log messages
11:41:44 <etpace> hmm
11:42:02 <Athas> Hmm, I'm getting bogus errors from GHC: Warning: Module `Control.Arrow' is imported, but nothing from it is used
11:42:10 <Athas> But I use names exported from Control.Arrow.  What gives?
11:42:19 <Athas> Err, not bogus errors, bogus warnings.
11:42:28 <c_wraith> Athas:  use 'import Control.Arrow ()'
11:42:31 <mauke> Athas: are the functions that use Control.Arrow used?
11:42:40 <lilac> @type let (!)(w,((x,y),z)) = ((w,y,z),x); (!!)((w,y,z),x) = (w,((x,y),z)); translate v w = (((v+) <$> (w!)) !!) in translate
11:42:42 <lambdabot> forall a t t1 t2. (Num a) => a -> (t, ((a, t1), t2)) -> (t, ((a, t1), t2))
11:42:47 <Saizan> Athas: maybe you're also importing the same identifiers from other modules
11:43:00 <Athas> mauke: oh right, they're not yet.  That same quirk bit me earlier too.
11:43:19 <c_wraith> Oh.  Wrote a function that's not exported and not depended on?
11:43:23 <etpace> What's the "join" function in haskell called? so join " " [1,2,3] is "1 2 3"
11:43:32 <c_wraith> etpace:  intercalate
11:43:57 <c_wraith> > intercalate " " ["foo", "bar", "baz"]
11:43:58 <lambdabot>   "foo bar baz"
11:44:42 <etpace> thanks
11:44:43 <c_wraith> I don't really know how to pronounce that, though.  Should I be saying it like interpolate, or like intercal-ate
11:44:44 <c_wraith> ?
11:45:01 <lilac> @type let (!) = uncurry ((`ap` snd) . (. fst) . (`ap` snd) . (. fst) . flip . ((flip . ((,) .)) .) . (. (,)) . (.) . (,)); (!!) = uncurry (uncurry ((`ap` snd) . (. fst) . (. (flip . ((,) .) . flip (,))) . (.) . (.) . (,))) in \v w -> (((v+)<$>(w!))!!)
11:45:03 <lambdabot> forall a a1 a2 a3. (Num a) => a -> (a1, ((a, a2), a3)) -> (a1, ((a, a2), a3))
11:45:40 <pikhq> lilac: Impressive pointless.
11:45:46 <PeakerWork> lilac: Why the crazyness
11:45:58 <maltem> > join ["foo","bar",baz"]
11:45:59 <lambdabot>   <no location info>:
11:45:59 <lambdabot>      lexical error in string/character literal at end o...
11:46:00 <mauke> c_wraith: http://www.leo.org/dict/audio_en/to_intercalate.mp3
11:46:15 <etpace> How about a string replace?
11:46:15 <maltem> > join ["foo","bar","baz"]
11:46:17 <lambdabot>   "foobarbaz"
11:46:24 <maltem> Now I see why it's called join :)
11:46:34 <PeakerWork> > join . concat $ [["hello", " wor"],["ld", " I am"], [" mr.", "jones"]]
11:46:35 <lambdabot>   "hello world I am mr.jones"
11:46:49 <PeakerWork> > concat . join $ [["hello", " wor"],["ld", " I am"], [" mr.", "jones"]]
11:46:50 <lambdabot>   "hello world I am mr.jones"
11:46:59 <PeakerWork> maltem: I think its clearer from the type
11:47:00 <PeakerWork> @type join
11:47:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:47:14 <PeakerWork> two m's are joined into one
11:47:16 <mkaemmer> > intersperse ' ' ['1','2','3']
11:47:17 <maltem> possibly
11:47:18 <lambdabot>   "1 2 3"
11:47:19 <pikhq> > join . join $ [["hello", " wor"],["ld", " I am"], [" mr.", "jones"]]
11:47:20 <lambdabot>   "hello world I am mr.jones"
11:47:32 <PeakerWork> > concat . concat $ [["hello", " wor"],["ld", " I am"], [" mr.", "jones"]]
11:47:33 <lambdabot>   "hello world I am mr.jones"
11:47:35 <pikhq> Yes, join is concat for the list monad. Whoo.
11:47:38 <etpace> > foldr (\x acc -> if x == '1' then '#':acc else x:acc) [] "5432112345"
11:47:39 <lambdabot>   "5432##2345"
11:48:32 <pikhq> > foldr (\x acc -> (if x == '1' then '#' else x):acc) [] "5432112345"
11:48:33 <lambdabot>   "5432##2345"
11:48:41 <lilac> > join (+) 21
11:48:42 <lambdabot>   42
11:48:47 <PeakerWork> lazier!
11:48:55 <pikhq> PeakerWork: Yup. :)
11:49:05 <PeakerWork> @src map
11:49:06 <lambdabot> map _ []     = []
11:49:06 <lambdabot> map f (x:xs) = f x : map f xs
11:49:13 <PeakerWork> as lazy as a map
11:52:36 <paolino> @pl \x -> zip (inits x) (tails x)
11:52:36 <lambdabot> liftM2 zip inits tails
11:53:15 <c_wraith> What monad is that?  (a ->) ?
11:53:19 <PeakerWork> c_wraith: yeah
11:53:30 <c_wraith> Well, I'm starting to recognize it, at least
11:54:12 <PeakerWork> c_wraith: being open to an arg is being in the (a->) monad. so here you're just combining inits and tails, both of which are open to an arg, so you yourself remain open to an arg
11:54:33 <paolino> etpace , I would start from there, for string replace
11:54:35 <c_wraith> That's a good description, actually.
11:54:51 <c_wraith> I'll have to think on it a while, but it sounds like a natural way to think about it.
11:55:54 <pikhq> c_wraith: Fortunately for you, the (a->) monad really doesn't do anything else.
11:56:05 <PeakerWork> return = const
11:56:33 <pikhq> Making it one of the easier monads to comprehend the usage of. (along with Maybe, [], and Identity)
11:56:34 <lilac> @type \f -> everywhere (mkT f)
11:56:36 <lambdabot> forall b a. (Data a, Typeable b) => (b -> b) -> a -> a
11:56:51 <c_wraith> @src Identity return
11:56:51 <lambdabot> return a = Identity a
11:57:21 <PeakerWork> pikhq: [] isn't easy to grasp, IMO.  Its mind boggling how something so simple does something so cool :)
11:57:44 <pikhq> PeakerWork: I found it really easy to grasp, actually.
11:58:41 <pikhq> "So... It basically is nice sugar around concat and map, and this sugar makes nondeterminism easy to express? That's pretty cool."
11:58:50 <gwern> > 6.9 / 21.5
11:58:51 <PeakerWork> pikhq: stuff like how:  filterM (const [True,False]) [1..3] took me a bit of effort to understand
11:58:52 <lambdabot>   0.32093023255813957
11:59:19 <pikhq> Okay, that's a whee bit harder to get. :)
11:59:34 <c_wraith> >_>
11:59:37 <pikhq> > filterM (const [True,False]) [1..3]
11:59:38 <c_wraith> :t filterM
11:59:39 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:59:39 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:59:44 <PeakerWork> > filterM (const [True,False]) [1..3]   -- both take and not-take each item.  I think its the most wonderful example of the list monad :)
11:59:46 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:59:50 <pikhq> Still, that's not so hard, is it? :P
11:59:57 <mauke> you're doing it wrong :-)
12:00:07 <mauke> > filterM (return [True,False]) [1,2,3]
12:00:07 <PeakerWork> mauke: doing what wrong?
12:00:08 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:00:14 <mauke> needs more return!
12:00:37 <PeakerWork> mauke: heh, but that's just confusing, as if the "return" has anything to do with the filterM's M :)
12:00:44 <mauke> YES
12:00:44 <pikhq> PeakerWork: Mmm, non-determinism.
12:01:14 <pikhq> mauke: Two monads are better than one, I guess?
12:01:59 <c_wraith> @src (a ->) return
12:01:59 <lambdabot> Source not found. I am sorry.
12:02:06 <c_wraith> but clearly, it's const. :)
12:02:08 <mauke> @src (->) return
12:02:08 <lambdabot> return = const
12:02:28 <mauke> :t fmap fix return
12:02:29 <lambdabot> forall a. a -> a
12:02:38 <ziman> > fmap fix return 3
12:02:39 <lambdabot>   3
12:03:30 <pikhq> mauke: Hahahah.
12:04:12 <PeakerWork> btw, combining ContT and [] monad has some pretty cool effects :)
12:05:31 <lilac> @type filterM (return (return True `mplus` return False)) [1,2,3] :: [[Int]]
12:05:32 <lambdabot> [[Int]]
12:05:37 <PeakerWork> you can get more modular [] generators, that allow outer code to interleave actions (in this case, lists) in the list computation. This can be seen as a "modular" list comprehension (where you jump out of the list comprehension, someone adds some guards/splits/etc, then jumps back in, etc)
12:05:40 <lilac> > filterM (return (return True `mplus` return False)) [1,2,3] :: [[Int]]
12:05:42 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:05:51 <lilac> is that enough returns?
12:06:08 <PeakerWork> @type filterM (return (return True `mplus` return False))
12:06:09 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m [a]
12:06:18 <lilac> > filterM (return (return True `mplus` return False)) [1,2,3] :: Maybe [Int]
12:06:20 <lambdabot>   Just [1,2,3]
12:06:28 <lilac> it's more general too
12:06:36 <pikhq> Okay, that's pretty spiffy.
12:06:37 <lilac> > filterM (return (return True `mplus` return False)) [1,2,3] :: IO [Int]
12:06:37 <PeakerWork> its silly though :)
12:06:39 <lambdabot>   <IO [Int]>
12:06:43 <PeakerWork> @type filterM (const (return True `mplus` return False))
12:06:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m [a]
12:06:47 <pikhq> Not that it's needed. :D
12:07:57 <gwern> dons: I wonder how much of frag's position as 12th most popular download is due to people going lolwut at a FPS in haskell?
12:08:26 <lilac> > filterM (return (return (getAll mempty) `mplus` return (getAny mempty))) [1,2,3] :: [[Int]]
12:08:27 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:09:02 <lilac> three different monoids and potentially three different monads. fun!
12:09:41 <Deewiant> > filterM (return $ on mplus return (getAll mempty) (getAny mempty)) [1,2,3] :: [[Int]]
12:09:42 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:10:24 <gwern> (also, I never expected frag to be the most popular thing I uploaded to hackage. I now feel guilty about breaking the bots in frag)
12:10:46 <PeakerWork> What's getAll/getAny?
12:10:54 <Deewiant> ?ty getAll
12:10:56 <lambdabot> All -> Bool
12:11:13 <Badger> @ty getAny
12:11:14 <PeakerWork> @index getAll
12:11:15 <lambdabot> Any -> Bool
12:11:15 <lambdabot> bzzt
12:11:19 <Badger> harr
12:11:34 <Deewiant> > getAll . mconcat . map All $ [True, True]
12:11:36 <lambdabot>   True
12:11:45 <tristes_tigres> getAny :: Girls -> Maybe Sex &
12:11:59 <bremner> Nothing
12:12:03 <c_wraith> For some reason, that always evaluates to Nothing
12:12:58 <PeakerWork> oh, cool, its a Bool newtype wrapper with a Monoid instance?
12:13:30 <PeakerWork> I guess every foldr can be implemented as a Monoid, instead?
12:13:48 <dons> gwern: you broke frag?
12:13:57 <sjanssen> PeakerWork: I don't think so
12:13:59 <gwern> I broke *part* of it
12:14:06 * dons doesn't feel good about this.
12:14:10 <PeakerWork> @type foldr
12:14:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:14:15 <dons> it should be a snapshot, unbroken, of Mun's thesis work
12:14:20 <gwern> because I couldn't figure out how the heck the bot location stuff worked
12:14:23 <PeakerWork> sjanssen: (a -> b -> b) doesn't match mappend's signature, I guess
12:14:30 <gwern> dons: unfortunately, then we can't have a Free Frag
12:14:41 <gwern> we went over this - he was using a proprietary level
12:14:41 <sjanssen> gwern: what was non-free about the original version?
12:14:49 <dons> right, so you tweaked the level files, that's fine.
12:14:55 <dons> how does that break the bots?
12:15:02 <gwern> yes, but the consequence of that was to break the little bots in it
12:15:07 <PeakerWork> I played frag and didn't see any bots
12:15:14 <PeakerWork> ah
12:15:16 <dons> oh, they're part of the level description?
12:15:19 <gwern> the location of the bots, their paths, are hardwired as xyz coordinates, or something like that
12:15:25 <dons> i see.
12:15:33 <dons> ok, makes senes.
12:15:34 <gwern> different level = different xyz coordinates for the floor/ceilings etc
12:15:35 <tkr> so what the heck is this is this foldr is this just a "stack" made of linked-lists ? and what is this Monoid ? Just a handly way of interacting with a module variable at run-time ?
12:15:42 <dons> yep, no worries.
12:15:48 <dons> i thought you'd broken the code itself in some way
12:16:14 <gwern> I tried to figure out how to put the bots into the new level, but I never figured out what the right locations were and couldn't guess them
12:16:41 <PeakerWork> tkr: foldr takes a list like  1 : 2 : 3 : []     and replaces each (:) with a function you give it, and each [] with a value you give it
12:16:54 <PeakerWork> tkr: for example,  foldr (+) 0  replaces 1 : 2 : 3 : []   with 1 + 2 + 3 + 0
12:17:19 <dons> so were there any other surprises in the download stats?
12:17:32 <PeakerWork> tkr: Monoid is a type-class, any type who is a member/instance of this type-class has an empty value and an  a -> a -> a      combinator.  For example, mempty=[] and mappend=(++) for lists
12:18:02 <gwern> dons: well, frag was pretty surprising. I was also surprised to see mazes of monads so high in the rising list
12:18:06 <gwern> since it had minimal publicity
12:18:12 <tkr> PeakerWork: what happends if the empty value is not defined, and how you should define it?
12:18:15 <dons> yeah.
12:18:19 <gwern> bloxorz I'm writing down as a onetime surge from its youtube video/reddit post
12:18:27 <PeakerWork> tkr: if the type is an instance of Monoid, then it has such an empty value
12:18:28 <dons> gwern: note how say, bloxorz or atom, which i wrote posts about, did well
12:18:32 <PeakerWork> tkr: Otherwise it wouldn't be an instance
12:18:32 <dons> people need to write about their work!!
12:18:46 <gwern> well, bloxorz is also pretty polished for a haskell game
12:18:50 <PeakerWork> dons: people only like to write about their complaints :)
12:18:52 <dons> its nice, the idea is nice.
12:18:53 <gwern> so the video looekd really nice
12:19:02 <tkr> PeakerWork: what. that sounds like a function returning undefined.
12:19:10 <PeakerWork> tkr: Why?
12:19:12 <dons> yeah, i keep thinking of officially doing weekly package reviews
12:19:20 <dons> where we review some new package each week, with video et al
12:19:26 <PeakerWork> tkr: instance Monoid [a] where mempty = [] ; mappend = (++)
12:19:28 <gwern> let's see.. also, it's a little surprising how high the development tools like happy are
12:19:40 <sjanssen> gwern: I don't think so
12:19:45 <dons> lots of developers use cabal-install
12:19:45 <gwern> you would expect that they would be fairly low, since no one cares bout them in and of themselves
12:19:51 <gwern> only as steps to, say, yi
12:19:52 <tkr> PeakerWork: ah. yes. sorry Monoid [] is still a Monoid and an array [] is still an array
12:19:54 <Deewiant> Things depend on them
12:20:06 <PeakerWork> tkr: what kind of array?
12:20:13 <gwern> and who exactly is downloading uaagc???
12:20:15 <PeakerWork> tkr: not sure what array you mean
12:20:25 <dons> i'm surprised by hslogger
12:20:25 <sjanssen> gwern: install base of happy will be the union of the installed base of all packages that use happy in their build process
12:20:25 <Ke> also might not be obvious but most utilized packages are probably distributed but distro mirrors
12:20:32 <tkr> PeakerWork: isnt there an Array []. aka a list [1,2,3,...] ?
12:20:42 <gwern> do we have like every student in the Utrecth courses downloading from hackage or something?
12:21:04 <dons> uuagc ?
12:21:05 <dons> maybe
12:21:11 * gwern finds uuagc being only slightly less popular than *pandoc* to be very odd
12:21:19 <dons> pandoc's in debian though
12:21:25 <dons> so people can use the package version
12:21:29 <dons> and note darcs from hackage on the rapid rise
12:21:43 <dons> pandoc is underappreciated
12:21:46 <tkr> PeakerWork: haskell people should know about complex transformations!
12:21:53 <dons> i thought gitit would be higher
12:21:54 <dons> and twidge
12:21:57 <gwern> dons: I know, but I assumed that it would be bouyed by things like gitit
12:21:58 <tkr> PeakerWork: s/about/more about/
12:22:10 <gwern> gitit's so nice, I wish more people would use it :(
12:22:16 <gwern> dons: maybe you could blog about gitit?
12:22:20 <dons> yeah
12:22:25 <dons> i use it, i love it. i advocate for it
12:22:27 <sjanssen> has anyone explored using gitit for Haskell.org?
12:22:33 <dons> no, its a good idea
12:22:37 <dons> we have a mediawiki parser too
12:22:45 <dons> so you could suck down haskell.org, archive it, import it into git
12:22:46 <dons> that'd be super
12:22:53 <gwern> sjanssen: I did. converting from MW wouldn't be trivial, and the performance considerations are still bad
12:22:55 <PeakerWork> tkr: is it an array or a linked list?
12:23:03 <gwern> it *might* work with a git backend, but I'm skeptical
12:23:16 <sjanssen> gwern: oh, right, darcs :(
12:23:27 <dons> i like the git part of gitit
12:23:33 <gwern> I mean, hawiki is not small, even if git is supposed to be really fast
12:23:39 <tkr> PeakerWork: what. this is unrelated to the stuff that is happening under the scenes.
12:24:00 <PeakerWork> tkr: I'm not sure what you're trying to say
12:24:04 <sjanssen> I think using a general VCS won't scale to large wikis, it just isn't the right model
12:24:10 <tkr> PeakerWork: or s/under/behind/ # I dont know how expressive english should be.
12:24:18 <gwern> dons: the popular libraries list isn't too surprising; the only one that surprises me is hslogger - I'm just not sure who or what uses it
12:24:26 <PeakerWork> tkr: In Haskell, [1,2,3] is a linked list. To get an array you have to import stufff
12:24:27 <dons> sjanssen: you almost want repos per page.
12:24:34 <dons> rather than for all pagges
12:24:42 <dons> since wikis don't really do multi-page edits
12:24:51 <gwern> sjanssen: well, the general musing is that for a small wiki, you want the whole wiki to be a vcs, but to scale, you will do per-article or per-namespace repos
12:25:00 <dons> yeah
12:25:04 <sjanssen> dons: yeah, excactly.  But one could imagine applications for batch edit "transactions" if there was a nice UI for it
12:25:11 <tkr> 22:15 < tkr> so what the heck is this is this foldr is this just a "stack" made of linked-lists ? and what is this Monoid ? Just a handly way of interacting with a module variable at run-time ?
12:25:14 <dons> right. that'd be quite cool
12:25:23 <tkr> geez. zorry, PeakerWork :) I was just trying to learn. :)
12:25:31 <dons> would make wiki gardening easier
12:25:34 <sjanssen> I bet wikipedia could make use of something like that
12:25:48 <PeakerWork> tkr: No problem, I tried to answer best I could, I just didn't understand what you were saying/asking
12:26:02 <gwern> sjanssen: consider that if all of the English wikipedia were a single repo, you would never ever be able to finish a 'darcs pull' or git whatever - because by the time you pulled down the last couple thousand edits made in the last hour, there would've been a few hundred more
12:26:26 <gwern> but if you were doing it on a per-article basis, you could at least hope to have a up-to-date repo
12:26:33 <Berengal> It's like trying to download the internet
12:26:38 <ray> http://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png <-- a foldr
12:26:59 <gwern> dons: I wonder how bookshelf compares with gitit?
12:27:04 <gwern> Berengal: not a bad analogy
12:27:04 <dons> unknown!
12:27:13 <PeakerWork> gwern: it would pull some revision from the past, and then when its done, you could pull an update
12:27:25 <PeakerWork> gwern: sure if revision data is created faster than you can download, then you can't get the entire history
12:27:45 <sjanssen> gwern: wikipedia wouldn't be able to use conventional version control, but a transactional interface should still be possible with custom software
12:27:54 <gwern> and of course, per-article repos is basically what mediawiki does right now
12:28:04 <PeakerWork> sjanssen: why couldn't wikipedia use something like git?
12:28:07 <gwern> conceptually, in the database, each article has a separate single-threaded history
12:28:27 <sjanssen> PeakerWork: I don't think anybody has tried it, but I doubt git would scale
12:28:34 <gwern> PeakerWork: well, en could never get away with calling git - too much overhead, necessarily pulls in disk IO
12:28:46 <Berengal> I wonder if it's possible to leverage gitit to make something even more powerful...
12:29:08 <sjanssen> has anybody turned gitit into blog software yet?
12:29:16 <gwern> the devs would commit collective suicide before doing it; we'd need several times the current computing resources
12:29:29 <maltem> Somebody must design concurrent git or something
12:29:43 <ray> memcached git
12:29:46 <Ke> git is concurrent isn't it
12:29:48 <gwern> PeakerWork: now, if you had some sort of in-memory git, then thigns would be different
12:30:05 <sjanssen> gwern: /dev/shm!
12:30:10 <gwern> but anything that goes to disk for basic operations couldn't fly
12:30:14 <Berengal> git is concurrent already, with a number of threads equalling the number of machines it's deployed on
12:30:24 <Ke> yes
12:30:26 <ray> lol
12:30:28 <Berengal> Distributed cvs has no need for concurrency
12:30:35 <gwern> Ke: git is distributed, but concurrent?
12:30:42 <Ke> hmm
12:30:43 <gwern> sjanssen: har har
12:30:50 <Ke> missread
12:30:51 <PeakerWork> gwern: isn't that called OS caching? :)
12:31:13 <gwern> sjanssen: what would it mean for gitit to be a blog software?
12:31:51 <sjanssen> gwern: I want to write blog entries in vi, record them in darcs and push them to some server running gitit
12:32:04 <gwern> why couldn't you do that now?
12:32:17 <gwern> vi foo; record foo; push --all etc
12:32:31 <Chimaera> Hello
12:32:40 <Berengal> Presumably because gitit is a wiki, not a blog
12:33:07 <sjanssen> gwern: does gitit support some scripting?  Ideally you would get RSS, a nice front page, dates automatically added to posts
12:33:12 <maltem> well I guess git isn't concurrent in the sense of a hundred people editing the same wiki at once
12:33:15 <dons> sjanssen: some server running happs-server you mean
12:33:21 <dons> sjanssen: i wonder if yst would work for that
12:33:28 <PeakerWork> gwern: actually, I think "push" doesn't scale, because it only supports fast-forward pushes, which might mean slower guys have to pull and retry pushing forever
12:33:30 <dons> john's non-dynamic version
12:33:47 <bremner> sjanssen: does ikiwiki support darcs?
12:33:53 <gwern> sjanssen: hm. no RSS support yet (I keep meaning to work on that - it's kind of halfdone)
12:33:55 <sjanssen> dons: that would be even nicer
12:33:57 <dons> http://hackage.haskell.org/package/yst
12:34:10 <gwern> bremner: I think I saw a half-complete or buggy darcs backend for ikiwiki once
12:34:19 <gwern> back when I was researching for filestore
12:34:35 <dons> so i think that just generates the site. you'd need a server (happstack-server + filesystem backend)
12:34:42 <Berengal> yst seems awesome, but did it fix the unicode problem?
12:34:54 <dons> depends on utf8-string
12:35:00 <Berengal> Ah
12:35:01 <sjanssen> dons: or just Apache.  happstrack means more expensive hosting that can actually run it
12:35:08 <dons> yeah
12:35:11 <dons> apache works
12:35:21 <dons> i heard there were webservers written in languages other than haskell
12:35:26 <Berengal> I'm going to use it for my resume then. It needs a rewrite
12:35:32 <anothergit> can anyone help we with calculating the time it takes a function to run?
12:35:35 <dons> Berengal: port it to Data.Text
12:35:48 <mornfall> Hm. How would you go about writing a Foldable instance for a list type that has existential witnesses attached to it?
12:35:57 <dons> anothergit: http://hackage.haskell.org/package/timeit
12:35:58 <sjanssen> @remember dons i heard there were webservers written in languages other than haskell
12:35:59 <lambdabot> I will never forget.
12:36:13 <gwern> sjanssen: as for editing the front page - there's a $DATE plugin, and I imagine you could combine that with a darcs hook - eg you could have a little binary which when called, gets the last patch, grabs the filename added, edits your Front Page.page with some string like '- filename \n "first line..." ($DATE)' and then does another record; that way, when you push, you push two patches, one addign the blog post and one adding the notice ...
12:36:20 <gwern> ... to the main page
12:36:26 <Berengal> dons: Or perhaps some custom Resume datatype?
12:36:30 <artagnon> I'm trying to learn Haskell. At the moment, static typing is driving me nuts. I've attempted to write this function in several ways using floor . sqrt etc, but sqrt requires Float, while == requires Integral :( http://pastebin.com/d36f667d4
12:36:34 <sjanssen> augustss: hey, does timeit have a darcs repo?
12:36:46 <Berengal> With utility functions for convering to Text, String, Xml, whathave you
12:36:46 <artagnon> here, / requires RealFrac but == requires Integral
12:36:50 <anothergit> dons, thanks!
12:36:53 <dons> http://hackage.haskell.org/packages/archive/timeit/0.9.0.0/doc/html/src/System-TimeIt.html#timeIt
12:36:56 <Berengal> Or perhaps I'm just overthinking the whole thing
12:36:58 <artagnon> Am I supposed to cast like in C?
12:37:01 <dons> 0.9.0.0
12:37:01 <dons> hehe
12:37:11 <mauke> artagnon: the simplified version is that there are two types of numbers, Integers and Doubles
12:37:22 <mauke> artagnon: Integer supports div and mod, Double supports / and sqrt
12:37:35 <artagnon> mauke:
12:37:40 <artagnon> so your point being?
12:37:51 <artagnon> I should use one of the two sets of functions?
12:37:51 <mauke> artagnon: to convert from Integer to Double you use fromIntegral, the other way around you use round/floor/ceiling
12:37:59 <Berengal> artagnon: fromIntegral is the magic function.
12:38:32 <artagnon> Berengal: Num -> Integral ... hm.
12:38:44 * artagnon tries
12:38:54 <gwern> sjanssen: or would such a hook be ridiculously roundabout a solution? :)
12:38:58 <Ke> gwern: apparently I fail again, no noticeable concurrency at least on clone or so
12:39:11 <gwern> \/
12:39:40 <sjanssen> gwern: from an aesthetic standpoint, I don't like generated data being stored in the repository
12:39:41 <Berengal> > (fromIntegral 5 :: Double, fromIntegral 5 :: Int, fromIntegral 5 :: CReal, fromIntegral 5 :: Rational)
12:39:42 <lambdabot>   (5.0,5,5.0,5 % 1)
12:40:20 <artagnon> mauke:
12:40:27 <gwern> sjanssen: ok, then I suppose one could have a regular gitit plugin. plugins get access to the repo, so in theory I think one could wrote a plugin to get all articles under say 'blog/', and then sort them by date
12:40:34 <artagnon> Berengal: I still haven't got it :( http://pastebin.com/d3b3e9c3d
12:40:58 * artagnon curses his Conkeror keybindings in webchat
12:41:11 <mauke> artagnon: you need to convert the other number too
12:41:25 <mauke> or use div instead of /
12:41:41 <sjanssen> gwern: I suspected that it was possible to implement, now I just want somebody to write it :)
12:41:44 <gwern> sjanssen: someone just needs to code it up, is all...
12:42:04 <Berengal> artagnon: http://pastebin.com/m61b603cf
12:42:42 <Berengal> artagnon: Although I'd rather write that as http://pastebin.com/m19d49dee
12:45:28 <artagnon> mauke: Ah, fantastic. div works :D
12:47:37 <artagnon> :p
12:47:37 <artagnon> Berengal: Thanks! I appreciate the code, but please don't spoonfeed me in future -- makes me lazy/ complacent.
12:48:04 <mauke> haskell is all about laziness
12:48:39 <PeakerWork> mauke: and purity
12:48:43 <PeakerWork> mauke: and types
12:48:51 <PeakerWork> and type-classes
12:49:48 <artagnon> Yeah, I frankly dislike static typing though. I was trying to fix this problem for several hours before asking here.
12:50:04 <artagnon> ok, what's wrong with where divisors = takeWhile (<= sqrt fromIntegral(x)) [y | y <- [2..], mod x y == 0] ?
12:50:37 <PeakerWork> artagnon: What do you dislike about static typing?
12:50:44 <Athas> What's the best and most concise way to select, from a list, the element just after a known element?
12:50:48 <PeakerWork> artagnon: Also, if you dislike static typing, its unlikely you will like Haskell
12:50:56 <PeakerWork> (though maybe they'll grow on you)
12:50:59 <Berengal> Athas: dropWhile
12:51:28 <anothergit> I got the timing program I was talking about to compile, but it doesn't print a time
12:51:34 <anothergit> do you guys think you could help me with: http://codepad.org/vU0QhKo6
12:51:43 <anothergit> I'm a little new to haskell, heh
12:51:49 <artagnon> PeakerWork: I come from the Python and Common Lisp world. I've never really bothered with types so far :( -- but you're right, I'll probably get used to it
12:52:16 <Athas> Berengal: I suppose that is a decent idea.
12:52:26 <PeakerWork> artagnon: I've programmed in Python intensively for about 7 years before switching to Haskell
12:52:40 <Berengal> I think in types even when programming python...
12:53:33 <artagnon> Sorry about the incomplete question: Real question is here: http://pastebin.com/d1ab7a409 -- I'm still trying to get the hang of types :|
12:53:53 <artagnon> PeakerWork: Types didn't bother you even a little bit when you switched?
12:55:22 <ziman> artagnon, i'd guess parenthesizing is the issue: (<= sqrt fromIntegral (x)) parses as (<= (sqrt fromIntegral) (x))
12:55:48 <mauke> also, (x) is the same as x
12:56:20 <soupdragon> ziman, I do not beleive so
12:56:25 <Berengal> artagnon: : Brackets, and not enough fromIntegral (alternatively round/ceiling etc)
12:56:30 <mauke> (<= floor (sqrt (fromIntegral x)))
12:57:17 <artagnon> ziman, Berengal , mauke: Right, paranthesizing + non-flooring issue
12:57:19 <PeakerWork> artagnon: Well, actually, I thought static types were a good idea all along, I just thought that they are only good if you actually have a *very* good type system, and I didn't think any language had it yet.  Apparently, Haskell did :)
12:57:29 <artagnon> damn, I hate operator precedence too :(
12:57:35 <artagnon> Common Lisp is too beautiful
12:57:42 <PeakerWork> artagnon: I liked Python's escape from C++'s crappy type system
12:57:45 <mauke> common lisp is fucking ugly
12:57:55 <PeakerWork> Yeah, I hate common lisp
12:57:59 <mauke> enjoy your #'
12:58:10 <soupdragon> you guys are crazy
12:58:15 <PeakerWork> Lisp-2 sucks. Every time I ask why they made that mistake, they say its because they want to name their variables "list"
12:58:18 <artagnon> mauke, PeakerWork: Takes ages to appreciate it. Seriously.
12:58:25 <Berengal> sexprs are awesome, CL fucks it up :(
12:58:28 <mauke> artagnon: meh
12:58:37 <PeakerWork> maybe they could name the function make-list instead?
12:58:37 <gwern> scheme isn't too bad though
12:58:40 <soupdragon> CL doesn't fuck it up at all
12:58:41 <Makoryu> artagnon: Just remember that function application has the highest precedence, and for the most part you'll be all set
12:58:43 <PeakerWork> Scheme is nice
12:58:49 <mauke> I already know perl, I can SEE where and how CL sucks
12:59:11 <gwern> (I find some of the equality operators a bit strange though)
12:59:14 <artagnon> Makoryu: Ok, I'll try using $ instead of () too
12:59:24 <PeakerWork> artagnon: do you like the 2 namespaces CL has?
12:59:24 <etpace> How can I change say (-5, 1) to (0, 1), and (-6, -6) to (0,0)?
12:59:46 <mauke> etpace: manually
12:59:56 <artagnon> PeakerWork: Frankly, yes. Functions and variables can have the same name
13:00:05 <Makoryu> artagnon: Yeah, ($) has the lowest precedence (not counting (,) since it's not really an operator)
13:00:18 <mauke> artagnon: but functions are variables
13:00:20 <Berengal> artagnon: Do like lisp does: throw parenthesises at expressions until you run out
13:00:37 <Berengal> Operator precedence is widely overrated
13:00:44 <etpace> hmm, sanitise (x, y) = if x < 0 && y < 0 then (0,0) else if x < 0 then (0, y) else if y < 0 then (x, 0)?
13:00:44 <mkaemmer> Berengal: blasphemy.  Lisp never runs out of parenthesis
13:00:51 <PeakerWork> artagnon: But that distinction is extremely artificial
13:00:57 <mauke> :t join (***) (max 0)
13:00:59 <lambdabot> forall c. (Num c, Ord c) => (c, c) -> (c, c)
13:01:00 <PeakerWork> artagnon: why are "functions" special? Variables can also be functions
13:01:04 <artagnon> Berengal: In Common Lisp, you don't have to type out the paranthesis. Ever.
13:01:06 <Cale> I would recommend against chaining $ though, use composition.
13:01:07 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:01:13 <Berengal> mkaemmer: That just means you need to keep throwing parens at stuff
13:01:20 <mauke> artagnon: yes, thanks to reader macros!
13:01:20 <soupdragon> mauke, if a variable denotes a function you can use it as such (without #')
13:01:27 <tkr> Cale: howdi.
13:01:36 <Cale> tkr: hello
13:01:36 <mauke> soupdragon: no, I can't, because I have to use funcall
13:01:44 <Makoryu> artagnon: Wait, could you show an example of how to get away with parenless CL code?
13:01:49 * mkaemmer throws ()))()((()()()((( at Berengal
13:01:53 <Makoryu> I have honestly never even heard of that
13:01:54 <Berengal> artagnon: That's perhaps the funniest statement I've hear about lisp in a long time, much because it's true...
13:01:54 <soupdragon> oh so it's funcall you don't like
13:01:56 <artagnon> PeakerWork, mauke: I can't really defend myself. It took me 6 months to write code that makes any sense in CL.
13:02:09 <artagnon> Makoryu: Emacs + a huge number of aiding modes :)
13:02:19 <tkr> Cale: little by little, starting to learn haskell. I think Im trying to combine my programming foo + my math foo + haskell brialliancy foo -> awesome foo. ;)
13:02:23 <artagnon> The parans are auto-added, auto-managed
13:02:26 <PeakerWork> artagnon: I think it impedes composition and creates another parameter by which certain types of code need to be duplicated
13:02:28 <Makoryu> artagnon: Bah, that's.... that's....
13:02:36 <mauke> artagnon: my first program in CL was hell world. my second program was a macro for infix expressions, containing a recursive descent parser. just for fun.
13:02:47 <mauke> er, hello world
13:02:56 <jmelesky> hellworld was a pretty awesome game :)
13:03:13 <tkr> Cale: Id like to do some graphics. ie. 2d->3d, whats the easiest way to do it. can haskell do it easier or do I have to do some raytracing?
13:03:29 <mkaemmer> mauke: heh... "hell world", the new standard for nihilistic starting programmers
13:03:40 <artagnon> CL has the extensibility that NO other programming language in the world can even hope to achieve. No, I wouldn't solve Project Euler in CL for example- it's a painful mess.
13:03:42 <mauke> mkaemmer: http://mauke.ath.cx/stuff/haskell/hell.hs
13:03:56 <mauke> artagnon: every other programming language can do that
13:04:05 <tkr> Cale: .. what about then. Im bit curious how should I do this. I got a 2d grid, that I could print in grafs, and then apply a (complex
13:04:24 <soupdragon> mauke, C and java can't
13:04:38 <tkr> ) transformation on and reprint-it. ie. a mbius transformation or something different.
13:04:40 <soupdragon> hm maybe java can
13:04:48 <Makoryu> CL is macros all the way down
13:05:14 <mauke> soupdragon: sure they can
13:05:18 <tkr> or should I first paint the Surface. and then paint the graph on the surface and just make the surface different?
13:05:25 <mauke> soupdragon: build up, not down
13:05:31 <artagnon> Imho, it's like this: CL is the crown jewel. You're supposed to look at it and appreciate its beauty. Play around with it a little bit, but not walk around wearing it.
13:05:41 <artagnon> Agreed, it's impractical for too many things.
13:05:42 <mauke> artagnon: lisp is blub
13:05:46 <soupdragon> that's ridiculous artagnon
13:05:50 <artagnon> But the design is SO fascinating.
13:05:56 <soupdragon> you must be confused if you think that it is impractical
13:07:09 <artagnon> soupdragon: See, I can write CL. I can think in CL. What I mean is that it'll probably never be a mainstream language.
13:07:15 <artagnon> Too many people find it too hard.
13:07:32 <Berengal> How can a language be hard?
13:07:34 <tkr> what is CL?
13:07:35 <mauke> I find it too stupid
13:07:39 <artagnon> Common Lisp.
13:07:41 * artagnon shrugs
13:07:53 <mauke> CL has the worst type declarations ever
13:07:53 <PeakerWork> mauke: what did you mean by build up, not build down?
13:08:04 <pikhq> People are accusing Lisp of being hard in #haskell.
13:08:04 <PeakerWork> mauke: oh, saw what you were responding to
13:08:06 <tkr> too many ()'s. I like perl way more, its easier to understand in an instant.
13:08:11 <pikhq> In #haskell.
13:08:26 <pikhq> tkr: Lies.
13:08:32 <Cale> Common Lisp is annoying because it's unduly hard to do proper functional programming in it.
13:08:39 <Berengal> Cale++
13:08:43 <soupdragon> not at all Cale
13:08:46 <pikhq> Cale++
13:08:47 <mkaemmer> tkr: "We've replaced this pearl programmer's regexs with random character sequences.  Lets see if he notices"
13:09:01 <tkr> pikhq: no. really. Im serious. especially in 20years++ .. @x is an array %x is an hash $x is a scalar.
13:09:07 <soupdragon> this is the genesis of functional programming
13:09:09 <artagnon> mauke: Just as an exercise, you might want to go through SICP. Scheme. It was taught in MIT before Python took over a few years ago.l
13:09:10 <mkaemmer> s/pearl/perl/
13:09:24 <soupdragon> if you want to do, e.g. pattern matching then you can
13:09:27 <artagnon> Structure and Interpretation of Computer Programs.
13:09:28 <Makoryu> Have you read your SICP today?
13:09:30 <mauke> artagnon: do you have a scheme implementation that doesn't suck?
13:09:44 <Berengal> Scheme /= CL
13:09:46 <Makoryu> mauke: Just download Chicken or something
13:09:54 <artagnon> Berengal: Ofcourse, I know.
13:10:02 <jmelesky> all scheme implementations don't suck, but each for a different value of "suck"
13:10:03 <Cale> soupdragon: It was perhaps one of the earlier programming languages in which functional programming was *possible*, but that doesn't mean that it's a good language for functional programming.
13:10:05 <Makoryu> mauke: Not like it matters anyway if you're working through a textbook
13:10:05 <tkr> pikhq: it will be cognitivive for your brain just easier to UNDERSTAND the code (http://www.paulgraham.com/head.html) ..
13:10:09 <jmcarthur_work> i don't think SICP is an argument for CL
13:10:10 <artagnon> mauke: For learning, Scheme is nicer. CL is more practical.
13:10:29 <mauke> Makoryu: it matters if the interpreter is pissing me off too much to get any work done
13:10:31 <SamB> CL is so big :-(
13:10:36 <SamB> and ill-organized
13:10:37 <Cale> Scheme at least doesn't make you jump through hoops to pass functions around as parameters.
13:10:43 <soupdragon> Cale, I think that it is -- but I would agree with Haskell being better at that
13:10:49 <mauke> artagnon: CL is impractical in that it makes me rage within 10 lines of code
13:10:59 <tkr> pikhq: Im desperately hungrying (and trying to learn for) all the possible features perl6 will (if it will ever) bring us.
13:11:03 <SamB> mauke: I rage sooner than that
13:11:03 <Cale> FP really got off the ground with the ML family of languages.
13:11:07 <pikhq> tkr: Perl. Readable.
13:11:15 <SamB> I rage just trying to figure out what data types to use!
13:11:20 <artagnon> Ok, I'm not defending that. Seriously.
13:11:22 <soupdragon> yeah.. and they are implemented in lisp
13:11:26 <tkr> pikhq: TIMTOADI. # readable?
13:11:29 <mkaemmer> mauke: I guess you have to finish all your programs in less than 10 lines :P
13:11:34 <Berengal> SamB: Lists
13:11:44 <tkr> I like Haskell. A lot.
13:11:46 <tkr> :)
13:11:53 <mauke> pikhq: perl is readable.
13:12:01 <Makoryu> pikhq: If Perl isn't readable enough, get an editor with good syntax highlighting. And then look at J (or better yet, TECO) for comparison
13:12:23 <tkr> mauke knows perl a lot better than me, and (s)he seems to be around here also. :)
13:12:23 * artagnon goes off to write more Haskell
13:12:35 <tkr> so let's stay in peace and learn fro each other :)
13:12:37 <Berengal> Makoryu: Apparantly, J is readable as well. It's just that one-liners are so easy in it
13:13:02 <jmelesky> i spent a decade programming perl professionally, and i'll say it's not very readable (in comparison to its immediate competitors, and in comparison to mainstream languages)
13:13:07 <artagnon> Thanks for everything, everyone. And *try* to be slightly more open-minded about Common Lisp.
13:13:15 * artagnon parts
13:13:16 <mauke> artagnon: DENIED
13:13:38 <mauke> if you meet CL on the road, KILL CL
13:13:41 <Cale> heh
13:13:57 <Berengal> CL has macros. Macros are fun...
13:13:59 <Makoryu> Berengal: I'm just saying it's actually even more terrifying at first glance than Perl is :p
13:14:00 <Cale> CL isn't bad compared to many other languages that people use every day.
13:14:31 <Cale> If I had to choose between Java and Common Lisp, you better believe I'd pick CL.
13:14:37 <erikc> CL is pretty hot if the bulk of your consists of making DSLs
13:14:44 <soupdragon> for every task ...?
13:14:45 <erikc> i just wish the commercial CLs didnt cost an arm and a leg
13:14:47 <Berengal> Cale: Who wouldn't?
13:14:51 <Berengal> Except people who only know Java...
13:14:53 * SamB would probably pick Jython
13:15:05 <Berengal> Jython is pretty nifty...
13:15:10 <tkr> If I'd had to cross-reference between #perl, #math and #haskell. I'd use perl to do it.
13:15:19 <Cale> soupdragon: For the sorts of tasks that I'm likely to perform.
13:15:22 <jmelesky> erikc: in the CL mindset, *every* task consists of making DSLs...
13:15:27 <Cale> soupdragon: and my general programming style
13:15:41 <Berengal> "Java imposes OOP as though it was the 19th century, and The First Empire of OOPia needed more colonies"
13:16:01 <mkaemmer> Berengal: XD
13:16:19 <Berengal> Except it's concept of OOP sucks :(
13:16:26 <soupdragon> no it doesn't
13:16:32 <Cale> Yeah, I was about to say, Java's OOP isn't very OOP.
13:16:40 <SamB> it sucks a bit less than C++'s
13:16:41 <tkr> I hope you have all met the <insert yoru company language here> consultants .. :)
13:16:44 <Berengal> soupdragon: I'd much rather have smalltalk/ruby
13:16:47 <Cale> SamB: indeed :)
13:16:48 <Berengal> Or even CLOS
13:16:52 <PeakerWork> soupdragon: Java interfaces are pretty limited, and using reflection for genericity sucks
13:16:52 <soupdragon> ???
13:17:16 <SamB> PeakerWork: Python doesn't have any other way to do it ;-P
13:17:17 <mkaemmer> Berengal: Cale: maybe my notion of OOP is wrong, but Java seems pretty OOP to me
13:17:21 <SamB> nor smalltalk, really
13:17:27 <SamB> it's just that it's automatic ...
13:17:41 <mkaemmer> not that I think OOP is particularly wonderful (at least in the Java sense of the phrase)
13:17:48 <mauke> mkaemmer: then why aren't classes, methods, types, ints, chars, doubles, ... objects?
13:17:57 <tkr> I would hate to be, rather smart circles, like #haskell to be infiltriated my buzzwords like java, spring, .net, core javaserver faces, etc.
13:18:01 <jmcarthur_work> OOP is vaguely defined
13:18:02 <PeakerWork> SamB: Python has good syntax for it, and in Python, it's "The" way to do it
13:18:04 <jmcarthur_work> nobody agrees on it
13:18:05 <Cale> mkaemmer: See what mauke said ;)
13:18:11 <Berengal> SamB: The automatic part is key. It's the difference between message passing and simple compile-time name-mangling
13:18:19 <jmelesky> mkaemmer: there are maybe a dozen different things which are associated with OOP, and each OOP implementation implements a different subset of them
13:18:29 <SamB> PeakerWork: yeah, that's why if I had to choose between Java and CL, I'd choose Python ;-P
13:18:30 <Cale> Smalltalk is nice for giving yourself a decent picture of what OOP is about, though I found myself continuously surprised that the entire smalltalk environment didn't just shake itself to bits.
13:18:34 <jmcarthur_work> my definition of OOP is message passing and encapsulation, period. prototype languages fit that definition better than the mainstream stuff
13:18:37 <PeakerWork> SamB: heh
13:18:50 <Berengal> mauke: Classes are objects. Methods can be reified through reflection
13:18:53 <Makoryu> jmelesky: Hell, Haskell implements enough stuff to be considered OOP
13:18:53 <SamB> but, you know, it's not just a joke, I really would
13:19:11 <jmcarthur_work> classes are counter to that end, and inheritance too
13:19:11 <SamB> Makoryu: by who?
13:19:24 <mauke> Berengal: then how do I pass a class around?
13:19:24 <Cale> You can indeed approximate OOP rather well in Haskell with little effort.
13:19:31 <jmelesky> jmcarthur_work: your definition of OOP is at odds with most of the rest of the world...
13:19:35 <Makoryu> SamB: By people who squint hard enough
13:19:36 <Berengal> mauke: <ClassName>.class
13:19:40 <tkr> cdiem: with a lot of stupid smart effort.
13:19:43 <jmcarthur_work> jmelesky, most of the rest of the world can't agree either
13:19:52 <tkr> s/cdiem/Cale/
13:19:53 <Berengal> mauke: I do it all the time
13:19:56 <SamB> jmcarthur_work: most implementations either suck at interfaces or suck at encapsulation
13:20:07 <mauke> Berengal: I'd say that's just a wrapper
13:20:07 <Cale> tkr: Oh, it doesn't require anything too smart
13:20:14 <SamB> Makoryu: I can't squint that hard
13:20:22 <Cale> tkr: If you don't care about inheritance, especially.
13:20:26 <Makoryu> SamB: That's okay, it's not very rewarding anyway
13:20:30 <SamB> Makoryu: let me know when I can implement GTK widgets in Haskell ;-P
13:20:35 <Berengal> mauke: It has methods for looking at it, like getting the name, methods, fields etc.
13:20:36 <jmelesky> jmacarthur_work: i guess i mean it's better to say "these are the important parts to me" rather than "this is the definition". the latter isn't willing to admit that other solutions are possible
13:20:50 <tkr> Cale: I didnt require any advice this time, I think. :)
13:20:59 <Berengal> mauke: It's how reflection is done
13:21:03 <Cale> tkr: hm?
13:21:33 <cdiem> tkr?
13:21:38 <tkr> Cale: anyhow. you have any pointers to people who can plot (3d) functions in a windows using haskell?
13:21:41 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell <-- this describes how I'd recommend handling situations which seem OO-ish.
13:21:45 <kyagrd> Can I run template haskell with NoMonomorphismRestriction?
13:21:45 <therp> can someone please reimplement the Haskell module system? It's broken.
13:22:09 <kyagrd> therp: about what?
13:22:10 <SamB> therp: what seems to be the problem?
13:22:10 <Cale> kyagrd: I'd hope so...
13:22:29 <SamB> kyagrd: did you have a reason to ask that question?
13:22:38 <SamB> kyagrd: i.e., did you get a funny error when you tried?
13:22:40 <Cale> kyagrd: What happens if you put {-# LANGUAGE NoMonomorphismRestriction #-} in your file?
13:23:23 <therp> kyagrd & SamB: I'm constantly annoyed about the restrictions semi-smart authors put in place by limiting their exports. for instance, I wanted to track a type error by adding additional casts to my expression. turns out I can not do that, because the type constructor isn't exported.
13:23:30 <kyagrd> when I try $something and something refers to a value that only type chekes with monomorphism restriction
13:24:01 <kyagrd> then its doomed
13:24:05 <Cale> tkr: I would be tempted to suggest FieldTrip.
13:24:15 <Cale> tkr: Though that's just a 3D graphics library.
13:24:21 <therp> I general I love the lispish module dereferencing "::" that says, "yes, you can do it but on your own risk"
13:24:34 <SamB> therp: that's pretty dumb
13:25:04 <therp> SamB: context lost. what is dumb? that I can not construct types to check, or lisp's ::
13:25:25 <tkr> Cale: nods. I got windows at my home desktop.
13:25:38 <tkr> Cale: tomorrow I will dive back in to haskell and opengl.
13:25:54 <SamB> hmm, being able to things at types that you don't export ?
13:25:54 <mauke> (let (x) (declare (integer x)) (setq x 42) (print x))  ; bonus question: what does this code do?
13:26:22 <SamB> therp: that is, that nobody exports ...
13:26:26 <tkr> Cale: probably try to avoid FieldTrip, but instead join some complex arithmetics and crazy raytracing, or (in)vulrnerability :)
13:26:28 <SamB> or at least that they DO it
13:26:37 <therp> samb: nod
13:26:39 <tkr> Cale: day by, day. you know :)
13:26:59 <kyagrd> Cale: {-# LANGUAGE NoMonomorphismRestriction #-} is already in my file and it works.  The problem is when I have q=[| ... f ... |] where f type checks because of NoMonomorphismRestriction but template haskell doesn't seem to cascade that option along with it
13:29:11 <SamB> kyagrd: you mean you have the MR inside your quasi-quotes?
13:29:17 <Berengal> hidden exports should be a warning only, or it should at least be possible to turn into valid code with --import-hidden-modules or something
13:29:47 <kyagrd> SamB: yeah
13:30:10 <kyagrd> SamB: oh no maybe not let me double check
13:30:35 <pikhq> mauke: STATE!
13:30:44 <mauke> pikhq: hmm?
13:30:54 <pikhq> EVIL EVIL setq!
13:30:57 <pikhq> :P
13:31:02 <mauke> you're missing the point
13:31:10 <pikhq> Yes, yes, yes.
13:31:43 <kyagrd> SamB: yes it seems so
13:32:09 <kyagrd> *Main> $prop_Ax2_Quote
13:32:09 <kyagrd>  
13:32:09 <kyagrd> <interactive>:1:0:
13:32:09 <kyagrd>     Ambiguous type variable `t' in the constraint:
13:32:09 <kyagrd>       `Ord t'
13:32:09 <kyagrd>         arising from a use of `prop_Ax2_Quote' at <interactive>:1:0-14
13:32:11 <kyagrd>     Probable fix: add a type signature that fixes these type variable(s)
13:32:13 <kyagrd>     In the expression: $prop_Ax2_Quote
13:32:15 <kyagrd>     In the definition of `it': it = $prop_Ax2_Quote
13:32:17 <kyagrd> *Main> :t $prop_Ax2_Quote
13:32:19 <kyagrd>  
13:32:21 <kyagrd> <interactive>:1:0:
13:32:23 <kyagrd>     Ambiguous type variable `t' in the constraint:
13:32:25 <kyagrd>       `Ord t'
13:32:27 <kyagrd>         arising from a use of `prop_Ax2_Quote' at <interactive>:1:0-14
13:32:29 <kyagrd>     Probable fix: add a type signature that fixes these type variable(s)
13:32:31 <kyagrd>     In the expression: $prop_Ax2_Quote
13:32:31 <PeakerWork> kyagrd: please don't paste here
13:32:33 <kyagrd> *Main>
13:32:35 <kyagrd> wow this was too long
13:32:44 <mauke> get a better irc client
13:32:47 <kyagrd> I should of used hpast
13:33:36 <harlekin> Does anything happen with a Handle if I write ^D (0x4) to it like getting closed or flushed?
13:34:21 <mauke> nothing happens
13:36:10 <kyagrd> The situation is stranger than I thought
13:36:40 <kyagrd> I found out a template haskell madness!!!
13:37:17 <mauke> Madness? THIS IS TEMPLATE SPARTA!
13:38:08 <kyagrd> In your script say Main.hs you have a polymorphic global definition say "pv = blah" which only type checks with the NoMonomorphismRestriction
13:40:21 <kyagrd> Then when you run template haskell it suddenly complains about that. BUT when you comment out that pv definition. It works :(
13:40:54 <kyagrd> The thing is, my quasiquote isn't even refering to that pv ...
13:40:56 <kyagrd> mystery.
13:41:00 <Berengal> kyagrd: Turn on MMR and use a type signature
13:41:09 <solidsnack> Has anyone tried the Torch unit testing framework?
13:43:06 <kyagrd> Berengal: yup, I'm minimizing NMR. had a lesson that mixing template haskell witn NMR is not a good idea.
13:43:29 <Berengal> kyagrd: It's arguably a bug though
13:44:12 <kyagrd> Berengal: I'll try to report this when I have time to make a minmal example. It is a strange behavior.
13:47:10 <doublethink_work> hm, it seems like a bug if template haskell code doesn't respect LANGUAGE pragmas - or does it just not respect NMR?
13:47:49 <doublethink_work> then again i'm not sure exactly how much allowing extensions like that would complicate the template haskell implementation, but it seems reasonable that pragmas should apply there as well
13:48:14 <harlekin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3180#a3180 Can anyone tell me why it just hangs when running with email addresses as arguments?
13:49:33 <kpreid> harlekin: no idea if this is applicable to sendmail, but you're waiting for the process to exit before reading any of its output
13:49:50 <kpreid> if it produces more than one pipe buffer's worth of output you will deadlock
13:50:32 <harlekin> kpreid, thanks for the hint. I changed it, but still it hangs.
13:50:37 <kpreid> changed it to...?
13:51:08 <kpreid> if you just removed the wait, it will still hang if it produces output on stderr first
13:51:13 <harlekin> I just moved line 26 and 27 after line 24.
13:51:41 <kpreid> that doesn't help because hGetContents is a lazy read
13:51:59 <kpreid> you need to forkIO a couple of threads which actually read both streams to completion in parallel.
13:52:51 <harlekin> So the termination of sendmail closes the handles?
13:52:51 <Phyx-> Hello
13:53:03 <kpreid> harlekin: Erm, no
13:53:21 <harlekin> kpreid, then why can't I read the data from the handles after the waitForProcess call?
13:53:32 <kpreid> Because the data is not all there yet
13:53:44 <kpreid> The process is blocked on writing to a full pipe
13:54:02 <kpreid> Lemme write a tool for you
13:54:10 <harlekin> kpreid, that'd be great. Thanks.
13:54:17 <Phyx-> I have a question about haskell-src-exts, when i put a comment, the SrcLine doesn't really seem to add up. The function is at srcline 4 and it says he comment is at 1 for instance
13:56:01 <harlekin> kpreid, ah. I just realized how the deadlock would be triggered. :) I would still appreciate the example code, though, if it isn't too much work.
13:58:39 <kpreid> harlekin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3180#a3183
13:58:49 <kpreid> (note: I have not even syntax checked this)
13:59:01 <harlekin> kpreid, that'll suffice. Thank you very much!
13:59:14 <kpreid> when working on it i realized another problem: your program would block if sendmail produced output while you were writing input!
13:59:29 <kpreid> So I put the reader threads right after creating the process.
13:59:49 <kpreid> Also, note I moved the hClose up so that you don't need a hFlush
14:00:22 <kyagrd> Is there a way to derive template haskell Lift class?
14:06:52 <kyagrd> Oh, there was th-lift thanks to hackage!
14:08:27 <mwc> I just heard John Hughes died. I had to use google news to figure out they were referring to a director.
14:08:38 <kyagrd> Waht?
14:08:41 <kyagrd> Why?
14:09:04 <Lemmih> Phew.
14:09:12 <kyagrd> Where is the source of the news?
14:10:26 <kyagrd> Ah :( it was not the one in Sewden I was surprised
14:10:47 <deech> Hi all, I am trying to test the 'retry' function of STM. But the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7942 is not behaving as expected. I  expected to see the "String is empty ..." and then "Got it ..". Instead all I see is the "String is empty .." and the program returns.
14:11:25 <deech> Could someone look at it for me?
14:11:58 <Lemmih> deech: You're ignoring the return value of 'readShared'.
14:13:04 <deech> Lemmih, but does that matter? I am still returning it. Why would it hang?
14:13:50 <Lemmih> deech: It hangs because you're retrying. You may want to put it in another thread.
14:14:49 <Lemmih> deech: forkIO $ putStrLn =<< atomically (readShared writeLock a)
14:16:06 <deech> I gettit! Thanks!@
14:17:18 <mkaemmer> okay, #haskell, I gots a challenge problem!
14:17:19 <deech> is there any way to force a threadDelay in the IO Monad?
14:17:33 <deech> I stuck a
14:17:46 <Lemmih> deech: Say again?
14:17:58 <mkaemmer> we can make a nested datatype SuperList: "data SuperList a = Nil | Cons a (SuperList (SuperList a))
14:18:20 <deech> I stuck a 'threadDelay 2000' in between the forkIO's but it doesn't get evaluated until both transactions are over.
14:18:40 <mkaemmer> and we can make an infinite instance of it like this: list = let l = Cons () (Cons l Nil) in l
14:18:56 <Lemmih> deech: Try pasting what you did.
14:19:02 <mkaemmer> is its cardinality countable?
14:19:13 <deech> Done
14:19:39 <dino-> deech: Are you sure the threadDelay isn't executing? 2000 is a tiny, tiny number of microseconds.
14:20:32 <deech> microseconds? I thought it was milliseconds!@
14:20:52 <deech> yes, it works now!
14:21:31 <Nereid_> mkaemmer: cardinality of what?
14:21:49 <Nereid_> just want to be sure
14:22:09 <Nereid_> how you define cardinality for such a thing
14:23:27 <mkaemmer> cardinality of the list.  I'm not sure particularly how to define it.  Usually by finding a bijection from the natural numbers...
14:23:37 <mkaemmer> if it's countable, that is
14:23:48 <Nereid_> it looks countable
14:24:49 <mkaemmer> Nereid_: I thought so at first... it seemed less so when I kept looking
14:24:56 <Nereid_> could you find a well-ordering of the elements, and see if you have a countable ordinal?
14:26:59 <mkaemmer> Nereid_: not clear on the definition of "countable ordinal"
14:27:14 <Nereid_> an ordinal number that is countable as a set
14:27:26 <Nereid_> not sure if that'd get you anywhere though
14:28:24 <Nereid_> I'm still not sure how you define cardinality for such a thing
14:28:46 <Nereid_> as in what the set is that you refer to
14:31:45 <mauke> who told me to get chicken?
14:31:56 <mauke> ah, Makoryu
14:31:58 <shapr> @get-chicken
14:31:59 <lambdabot> Unknown command, try @list
14:32:09 <mauke> chicken sucks because it doesn't support numbers
14:32:20 <Makoryu> mauke: Doesn't... support... numbers? O_o
14:32:32 <mauke> apparently it only does C ints and doubles
14:32:49 <mauke> no bigints or rationals
14:33:37 <Makoryu> mauke: Wow, so it does
14:33:53 <Makoryu> I honestly had no idea.
14:34:05 <Makoryu> You could use Mzscheme instead, I guess
14:34:37 <Makoryu> IIRC it supports everything you need to work through SICP
14:34:45 <Phyx-> chicken?
14:34:47 <Phyx-> kfc?
14:34:55 <Makoryu> Phyx-: Chicken Scheme
14:35:11 <Makoryu> http://www.call-with-current-continuation.org/
14:35:30 <Phyx-> oh ok
14:36:17 <mauke> meh, chicken is a toy
14:36:22 <mauke> no numbers, no unicode
14:36:44 <Makoryu> Scheme is generally shit with respect to proper encodings
14:37:19 <Botje> doesn't R6RS support unicode?
14:37:51 <Makoryu> \O_o/
14:38:13 <mauke> chicken doesn't support filenames with spaces in them
14:38:26 <Makoryu> Haha seriously
14:38:46 <mauke> http://chicken.wiki.br/man/4/faq#on-windows-source-and-or-output-filenames-with-embedded-whitespace-are-not-found
14:39:28 * yitz hates file names with spaces in them
14:40:24 <Makoryu> mauke: So then Chicken sucks
14:40:40 <Makoryu> How about Gambit?
14:40:41 <Makoryu> http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page
14:40:52 <mauke> still emerging plt-scheme
14:41:00 <Makoryu> Ah, alright
14:49:52 <Peaker> Lemmih: hey, you there?
14:50:06 <Peaker> Lemmih: I need a darcs repo to make a patch, or should I create a patch over the latest hackage?
14:55:44 <Lemmih> Peaker: http://darcs.haskell.org/~lemmih/hsSDL/hssdl/
14:56:03 <Peaker> Lemmih: thanks
14:56:13 <Peaker> any darcs command to send a patch directly to an email?
14:56:32 <Lemmih> Peaker: Yes, 'darcs send'.
14:57:01 <RayNbow> hmm, I'm looking for that graph on GHC's parallel performance where the performance dropped when using 8 (or was it 16?) threads... but can't find it...
14:57:08 <Peaker> Lemmih: ok, cool, getting and then will darcs send to you at gmail
15:04:42 <Peaker> Lemmih: btw, I get funny seg faults at exit, despite the patch being really tiny and harmless looking. Maybe you can take a look and see if its related. I suspect UB was already there
15:05:48 <doublethink_work> RayNbow: you mean like on an 8-core machine, or the RTS just uses 'N' threads where N == value passed to the '+RTS -N' option?
15:06:36 <RayNbow> doublethink_work: on an 8-core machine iirc
15:06:53 * RayNbow can't find the graph and the discussion on it
15:07:14 <doublethink_work> the threaded runtime brings with it some overhead, but if you're scaling with multiple cores I'm not sure why performance would decrease when bringing more cores in
15:07:28 <Peaker> darcs send is trying to use sendmail or something. Its not configured. How do I make a text file insteaD?
15:07:42 <doublethink_work> Peaker: darcs send -o mah_awesome_patch.dpatch
15:07:49 <doublethink_work> then just attach the file to an email
15:08:02 <Peaker> thanks
15:08:12 <doublethink_work> although the GHC team did say that there is strange 'last core slowdown' when using linux for parallel benchmarks
15:08:41 <doublethink_work> e.g. on a 4 core machine, using -N2 will bring a speedup, and similar with -N3, but using -N4 (so there is 1 thread for each core) actually causes the benchmarks to run slower
15:08:48 <doublethink_work> this doesn't appear to happen on OS X anyway
15:09:12 <doublethink_work> ugh
15:09:17 <pikhq> doublethink_work: Huh. Weird interaction with the multithreaded garbage collection or something?
15:09:27 <RayNbow> doublethink_work: I found the reddit link
15:09:29 * doublethink_work needs to dedicate this next weekend to furiously working on the 64bit OS X port of GHC
15:09:34 <doublethink_work> RayNbow: oh, link?
15:09:47 <Peaker> Lemmih: sent
15:09:49 <doublethink_work> pikhq: they're not quite sure, but it seems strange that linux suffers from the problem while OS X does not
15:10:06 <RayNbow> doublethink_work, http://www.reddit.com/r/programming/comments/8dma0/interesting_no_last_core_parallel_slowdown_on_os_x/
15:10:13 <pikhq> doublethink_work: Weird.
15:10:15 <doublethink_work> right, that one
15:10:34 <doublethink_work> pikhq: yeah, it is very strange.
15:11:03 <doublethink_work> pikhq: then again, GHC these days is the interaction between 4 ridiculously complicated parts: OS, runtime system, the compiler itself, and the underlying hardware
15:11:21 <doublethink_work> so there are about a million things that could be affecting it
15:15:30 <doublethink_work> pikhq: a-ha, Simon M as always has something to say on the subject:
15:15:33 <doublethink_work> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-April/017061.html
15:16:18 <pikhq> Hmm.
15:17:55 <Athas> Hmm, Git or Darcs...
15:18:19 <Athas> Various Haskell infrastructure things prefer the latter, right?
15:19:26 <doublethink_work> you shouldn't feel pressed to pick one or the other just because a lot of people in #haskell use it or not
15:19:47 <doublethink_work> I personally use git - as do a lot of people in the haskell community - but I also respect and like darcs a lot too. i just use git for my personal projects
15:20:46 <doublethink_work> notably darcs cherry picking is just something I'm *never* ever going to get over, because while 'git add -i' does the same thing, the interface for it just isn't as 'clean'
15:21:15 <Ycros> I think git has a pretty retarded user interface
15:21:20 <Ycros> darcs is much nicer
15:21:20 <sjanssen> Athas: darcs is preferred for a Haskell audience
15:21:45 <mauke> gambit scheme looks nice so far
15:22:01 <doublethink_work> I don't see it much differently than most other VCSs
15:22:10 <sm> hmm, a new cabal complaint. Could not find module `Control.Monad.Error':  it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2. How did this happen ?
15:22:11 <doublethink_work> I  mean it's not like I'm using 80,000,000 different commands to just do daily work
15:22:32 <sjanssen> sm: not a Cabal issue
15:22:33 <doublethink_work> I use maybe 10 commands on a frequent basis
15:22:43 <sjanssen> sm: use -package mtl if that's the one you want
15:22:44 <doublethink_work> because those are the ones you tend to use a lot :)
15:22:58 <blackdog> doublethink_work: stop being so damn reasonable
15:23:02 <doublethink_work> Ycros: but I do think that darcs pretty much has the best UI for revision control ever
15:23:10 <Athas> sjanssen: I better use Darcs then!  I don't expect non-Haskellers will be interested in my Literate Haskell program.
15:23:13 <sm> sjanssen: shouldn't it just use the one that's specified in the .cabal file ?
15:23:18 <doublethink_work> blackdog: sry :(
15:23:37 <sjanssen> sm: oh, that's more odd then
15:24:01 <sjanssen> sm: you are building with the regular Cabal build system, right?
15:24:29 <sm> yes
15:24:30 <Ycros> doublethink_work: it is very nice and interactive
15:24:36 <Ycros> doublethink_work: I do prefer bzr personally though
15:24:45 <doublethink_work> i've never tried bzr
15:25:01 <doublethink_work> I used hg for a personal project once to try it out, which was quite a while back
15:25:01 <sm> my app's .cabal specifies mtl.. I just installed monads-fd while upgrading the vty, which this app also uses.. so I guess I am pulling in both and in this situation I need to specify -package ? I haven't hit this issue before
15:25:33 <sjanssen> sm: Cabal specifies -package for you.  But are you sidestepping Cabal and using GHC or GHCI directly?
15:26:13 <sm> oh indeed you're right.. I build both ways
15:26:24 <sm> that explains it, thanks sjanssen
15:39:24 <burp> getCurrentTime >>= print
15:39:25 <burp> No instance for (Show UTCTime)
15:39:39 <skorpan> cool
15:39:47 <burp> why that? documentation says UTCTIme has Show instance
15:40:11 <burp> in Data.Time.Clock
15:40:29 <skorpan> hm, that is strange
15:40:40 <burp> can anyone confirm this?
15:40:41 <hackagebot> dyre 0.6 - Dynamic reconfiguration in Haskell (WillDonnelly)
15:40:48 <skorpan> i get the same thing
15:40:56 <mauke> the show instance is in a different module
15:41:04 <burp> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html
15:41:12 <mauke> try importing Data.Time
15:41:56 <burp> ok this works, thanks
15:42:31 <skorpan> it would be nice if this was explained in the module documentation
15:49:11 * jeffwheeler sometimes wishes cabal would automatically update when it can't find dependencies
15:50:17 <kynky> use a distro package manager ? arch and gentoo support haskell well
15:50:50 <jeffwheeler> kynky: eh, I use Cabal enough that I want up-to-the-moment packages
15:52:11 <kynky> jeffersonheard, me2, i use hackport, to get packages from hackage, it lets my package managerportage sort out dependncies
15:52:15 <kynky> life is easy
15:53:00 <jeffwheeler> hmm
15:53:00 <kynky> cabal install/uninstall not as trust worthy
15:53:11 <jeffwheeler> I trust cabal-install quite a bit.
15:53:30 <jeffwheeler> I need to restart X, though, so I'll be right back.
15:54:25 <kynky> gentoo builds in a sandbox, tracks files to install, so at uninstall just safer, so easy to spring clean
15:56:08 <jeffwheeler> Like Debian, and I expect RHEL/Fedora.
15:57:18 <kynky> well they are binary, so should be simpler
15:57:50 <kynky> but portage known for its god dependency resolution
15:57:52 <jeffwheeler> Well, yeah; I mean, that's how they work when you create the packages.
15:58:04 <kynky> good* :)
16:08:13 <Lemmih> ?tell Peaker Pushed.
16:08:13 <lambdabot> Consider it noted.
16:09:14 <Peaker> Lemmih: cool
16:09:15 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
16:09:31 <Peaker> Lemmih: did you encounter the segfault?
16:10:52 <Lemmih> No, I just applied and pushed.
16:11:15 <Lemmih> Peaker: What's button x1 and x2?
16:12:02 <Peaker> Lemmih: I am not sure, but they're exported by SDL
16:12:15 <Peaker> Lemmih: I hope the segfault isn't because of this, but some other bug exposed, it looks pretty harmless to me, my patch
16:12:21 <Peaker> Lemmih: but maybe you could review it, its pretty short
16:13:03 <mauke> crap. http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/A_Tour_of_Scheme_in_Gambit sucks.
16:13:38 <mauke> they claim 'int foo; { int bar; int foo; /* bang */ }' is invalid in C or C++ because there's already a foo defined
16:13:57 <mauke> which is obviously bogus
16:15:32 <sjanssen> mauke: well, at least it's true in Haskell
16:16:07 <mauke> the equivalent haskell code would be let { foo = _ } in let { bar = _; foo = _ } in ...
16:16:12 <mauke> which is also valid
16:17:55 <mauke> is there even a language with nested scopes that doesn't allow shadowing?
16:18:12 <porcino> hey guys
16:18:30 <porcino> there is something wrong with some code I found in a webpage
16:18:43 <porcino> http://en.literateprograms.org/Fibonacci_numbers_(Haskell) <- the second program
16:19:16 <mauke> ok?
16:20:41 <Makoryu> porcino: What's wrong with it, then? Just that it's not a complete module?
16:21:00 <porcino> Couldn't match expected type `Int' against inferred type `Integer'
16:21:13 <sjanssen> mauke: oh, I misread your paste, thought I saw "struct" in there
16:21:22 <sjanssen> mauke: was just making fun of Haskell records
16:21:22 <mauke> porcino: yeah, the type signature is wrong
16:21:52 <porcino> the signature isn't wrong
16:21:54 <Makoryu> porcino: Remove the "fibs :: Integer -> Integer" part
16:22:03 <porcino> ?
16:22:04 <Makoryu> porcino: It actually is wrong
16:22:08 <porcino> why?
16:22:14 <mauke> because !! takes an Int, not an Integer
16:22:17 <Makoryu> Because the (!!) operator wants an Int
16:22:52 <porcino> crazy
16:23:02 <sjanssen> porcino: don't just remove the type signature, though
16:23:28 <sjanssen> fib n = fibs !! fromIntegral n -- fixes it, and you can leave the type sig alone
16:23:53 <mauke> I'd rather change the type signature
16:23:56 <porcino> @src fromIntegral
16:23:57 <lambdabot> fromIntegral = fromInteger . toInteger
16:24:09 <sjanssen> mauke: to Int -> Integer?
16:24:13 <mauke> yes
16:24:20 <porcino> the point is to accept Integers and to return Integers
16:24:34 <sjanssen> mauke: it'd probably be an annoying interface to use
16:24:49 <mauke> then genericIndex
16:25:02 <sjanssen> yeah
16:25:15 <sjanssen> I suppose that avoids overflow
16:26:27 <aavogt> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! maxBound
16:26:33 <lambdabot>   mueval-core: Prelude.read: no parse
16:26:33 <lambdabot>  mueval: ExitFailure 1
16:27:09 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
16:27:11 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
16:27:15 <Makoryu> @hoogle Int -> String
16:27:16 <lambdabot> Language.Haskell.TH tupleDataName :: Int -> Name
16:27:16 <lambdabot> Language.Haskell.TH tupleTypeName :: Int -> Name
16:27:16 <lambdabot> Language.Haskell.TH.Syntax tupleDataName :: Int -> Name
16:27:20 <mauke> Makoryu: show
16:27:29 <Makoryu> Actually
16:27:31 <Makoryu> I messed up
16:27:36 <Makoryu> @hoogle Int -> Int -> String
16:27:37 <lambdabot> Distribution.Simple.Command commandShowOptions :: CommandUI flags -> flags -> [String]
16:27:38 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
16:27:38 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
16:27:42 <Makoryu> I'm looking for base conversions
16:27:52 <mauke> :t showIntAtBase
16:27:53 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:27:58 <Makoryu> D'oh
16:28:03 <Makoryu> Wait what
16:28:03 <mauke> :t showHex
16:28:05 <lambdabot> forall a. (Integral a) => a -> String -> String
16:28:31 <mauke> > showIntAtBase 11 intToDigit 999 ""
16:28:32 <lambdabot>   "829"
16:33:28 <dufflebunk> I have a function that does processing, interleaved with some putStr calls. I'd like to run that function mutiple times in parallel. Is there a handy way of doing that without having the the output get garbled?
16:33:55 <dufflebunk> ie, serialize the putStr in parallel processes
16:34:27 <mauke> yeah, pass an output pumpkin around
16:34:38 <mauke> or put your strings in a queue and have a separate thread output them
16:36:55 <copumpkin> ?
16:37:54 <dufflebunk> ?!
16:37:54 <lambdabot> Maybe you meant: . ? @ v
16:38:32 <mauke> basket <- newMVar ()
16:39:22 <mauke> withMVar basket (\pumpkin -> putStr "message")
16:40:52 <copumpkin> :o
16:40:57 * copumpkin is puzzles
16:41:00 <copumpkin> *d
16:42:00 <mauke> http://www.catb.org/~esr/jargon/html/P/patch-pumpkin.html
16:43:54 <copumpkin> zomg
16:47:17 <dufflebunk> so all processes would be passed the same MVar, the processes would then use that withMVar above, and I wouldn't need a separate process for doing the actual writes, because the MVar is still empty after running the putStr.
16:47:51 <mauke> what do you mean by "still empty"?
16:48:14 <mauke> it's full all the time except when a thread is doing some output
16:54:01 <dufflebunk> if it's full all the time, what empties it?
16:54:15 <mauke> withMVar
16:57:49 <dufflebunk> hmm, I think I get it... I'll have to play with it a little.
16:58:06 <dufflebunk> Thanks, that seems like it'll do what I need without too much trouble.
16:58:18 <mauke> for special coolness: basket <- newMVar putStr
16:58:29 <mauke> withMVar basket (\pumpkin -> pumpkin "message")
16:59:34 * dufflebunk goes home 
17:00:23 <FunctorSalad> mapM_ (\egg -> modifyMVar (egg:)) eggs
17:00:32 <FunctorSalad> mapM_ (\egg -> modifyMVar basket (egg:)) eggs
17:32:16 <ManateeLazyCat> :t (<<)
17:32:17 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
17:32:36 <ManateeLazyCat> :t <<
17:32:38 <lambdabot> parse error on input `<<'
17:32:43 <mauke> where's that coming from?
17:32:51 <mauke> @index (<<)
17:32:52 <lambdabot> Text.Html
17:33:16 <ManateeLazyCat> @hoogle (Monad m) => ma -> m b -> m b
17:33:17 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
17:33:17 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
17:33:17 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
17:33:43 <mauke> > [1,2] >> [1]
17:33:44 <lambdabot>   [1,1]
17:33:50 <mauke> > [1,2] >> [3]
17:33:52 <lambdabot>   [3,3]
17:33:58 <mauke> > [3] << [1,2]
17:34:00 <lambdabot>   [3,3]
17:34:06 <mauke> > [3] <* [1,2]
17:34:08 <lambdabot>   [3,3]
17:35:17 <mauke> > "ab" << "cd"
17:35:17 <ManateeLazyCat> @hoogle (Monad m) => m b -> m a -> m b
17:35:18 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
17:35:18 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
17:35:18 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
17:35:19 <lambdabot>   "abab"
17:35:21 <mauke> > "ab" <* "cd"
17:35:23 <lambdabot>   "aabb"
17:35:36 <dmwit> (<<) = flip (>>), I think
17:35:49 <mauke> lame
17:36:11 <dmwit> It's not that lame, considering (=<<) = flip (>>=)
17:36:26 <ManateeLazyCat> @hoogle (Monad m) => m b -> m a -> m b
17:36:26 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
17:36:27 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
17:36:27 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
17:36:35 <ManateeLazyCat> Not (<<) ?
17:36:51 <mmorrow> no
17:37:03 <ManateeLazyCat> :t (<<)
17:37:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
17:37:09 <kynky> any thoughts on eclipsefp?, just trying it out
17:37:15 <mmorrow> @undefine
17:37:21 <mmorrow> @type (<<)
17:37:22 <lambdabot> Not in scope: `<<'
17:38:25 <ManateeLazyCat> Where the (<<) ?
17:38:33 <ManateeLazyCat> @src (<<)
17:38:34 <lambdabot> Source not found. Maybe you made a typo?
17:38:36 <mmorrow> someone defined it with "@let"
17:38:44 <mmorrow> @let (<<) = flip (>>)
17:38:46 <lambdabot>  Defined.
17:38:49 <mmorrow> @type (<<)
17:38:51 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
17:39:10 <ManateeLazyCat> mmorrow: Haven't (<<) exist in standard library?
17:39:29 <ManateeLazyCat> mmorrow: Looks like that.
17:39:38 <mmorrow> ManateeLazyCat: it's in (x)html, but not as "flip (<<)"
17:39:40 <mmorrow> err
17:39:44 <ManateeLazyCat> mmorrow: hoogle can't got "(<<)"
17:39:47 <mmorrow> * .. but not as "flip (>>)"
17:39:54 <ManateeLazyCat> mmorrow: I see.
17:43:01 <pikhq> There's still <*.
17:43:14 <pikhq> Though, IIRC, that's on the functors.
17:43:17 <pikhq> @t (<*)
17:43:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:43:26 <pikhq> :t (<*)
17:43:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:43:37 <pikhq> Applicative functors.
17:44:49 <kzh> I just started learning haskell.
17:45:05 <pikhq> And?
17:45:06 <kzh> Thanks to bonus,
17:45:17 <kzh> I have a quuestion.
17:45:29 <pikhq> Don't ask to ask, just ask.
17:45:30 <kzh> on ghci...
17:46:04 <kzh> How do I get colored output like on learnyouhaskell.com
17:46:06 <pikhq> And also, the "enter" key is not the space bar. You are allowed to stick related statements on a single line in IRC.
17:46:52 <kzh> Sorry. I'm on a netbook with a small keyboard, Typing is slow while I'm getting used to it.
17:49:18 <kzh> I am running ghci on ubuntu gnu/linux.
17:49:47 <pikhq> Hmm. I'm not sure how you can get syntax highlighting from ghci.
17:51:20 <kzh> Thanks. I was admiring it on learnyouahaskell.com and was hoping I could get the same.
17:51:52 <Baughn> You can't. It would be nice, though.
17:51:52 <Baughn> You may be able to get it by using it through emacs, I don't know
18:04:09 <sjanssen> kzh: it can be done with hscolour
18:17:26 <kzh> Thanks sjanssen.
18:23:30 <ManateeLazyCat> @let unlinesExceptLast = init . unlines
18:23:31 <lambdabot>  Defined.
18:23:54 <ManateeLazyCat> > unlinesExceptLast ["abc", "def"]
18:23:56 <lambdabot>   "abc\ndef"
18:25:23 <michaelfeathers> > unlinesExceptLast []
18:25:24 <lambdabot>   "* Exception: Prelude.init: empty list
18:26:44 <ManateeLazyCat> @let unlinesExceptLast [] = ""; unlinesExceptLast = init . unlines
18:26:45 <lambdabot>  <local>:3:0:
18:26:45 <lambdabot>      Multiple declarations of `L.unlinesExceptLast'
18:26:45 <lambdabot>      Declar...
18:26:52 <ManateeLazyCat> @let unlinesExceptLast [] = "" unlinesExceptLast = init . unlines
18:26:52 <lambdabot>   Parse error
18:27:00 <michaelfeathers> > unlinesExceptLast [ "abc" ]
18:27:01 <lambdabot>   "abc"
18:28:03 * ManateeLazyCat pasted "unlinesExceptLast" at http://paste2.org/get/363706
18:28:08 <ManateeLazyCat> Above is improve version
18:28:23 <ManateeLazyCat> michaelfeathers: Thanks for [] condition.
18:30:50 * ManateeLazyCat pasted "unlinesExceptLast" at http://paste2.org/get/363737
18:31:04 <ManateeLazyCat> Oops, above is correct version.
18:35:42 <Cale> I was a bit surprised to see on Reddit: "John Hughes died." but it's not our John Hughes, it's some film director guy.
18:36:31 <eflister> i would like to define a class that is a recursive functor, meaning that it may contain an arbitrary nesting of functors.  the analog of fmap should just keep passing fmap down to the base values.  so, for example, an instance might be a Tree of Maybe Lists.  but i'm at a loss for how to do this.
18:38:17 <Cale> eflister: That's tricky because of the ambiguity in it.
18:39:12 <jrob> How do I pattern match on an empty Bytestring? http://paste2.org/get/363744
18:39:19 <eflister> Cale: wouldn't the instance declaration that gives the def of fmap' resolve any ambiguity?
18:39:50 <Cale> jrob: You don't. You can use a guard to check if it's null though.
18:40:57 <wgsilkie> @src mod
18:40:58 <lambdabot> Source not found. Just try something else.
18:41:27 <Cale> eflister: well, the problem is deciding how many levels you want to dig into the structure
18:42:34 <eflister> Cale: couldn't that be up to each instance?
18:43:52 <daz> how do i find out how many times a function recur's. e.g fx n | n==0 = ? | otherwise (n `div` 10)
18:44:15 <daz> how do i find out how many times a function recur's. e.g fx n | n==0 = ? | otherwise fx (n `div` 10)
18:44:40 <Cale> let fx n | n==0 = 0 | otherwise = 1 + fx (n `div` 10) in fx 127431294
18:44:52 <Cale> > let fx n | n==0 = 0 | otherwise = 1 + fx (n `div` 10) in fx 127431294
18:44:53 <lambdabot>   9
18:45:29 <daz> thanks Cale
18:46:04 <Saizan> eflister: so you want something like instance Functor (\x -> Tree (Maybe [x])) where .. ?
18:46:09 <Cale> eflister: suppose I give it a function like show and a Tree [Char]
18:46:13 <mmorrow> eflister:   newtype T a = T (Tree (Either (T a) a)) -- something like this?
18:46:46 <Cale> eflister: Does it apply show to each [Char] or to each Char?
18:46:50 <mmorrow> or are you not looking for an infinite type (i'm not sure what you're after)
18:47:09 <mmorrow> oh
18:47:32 <mmorrow> , (fmap . fmap . fmap) (*) (Node (Just [0..9]) [])
18:47:37 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
18:47:37 <mmorrow> , (fmap . fmap . fmap) (*1) (Node (Just [0..9]) [])
18:47:39 <lunabot>  Node {rootLabel = Just [0,1,2,3,4,5,6,7,8,9], subForest = []}
18:47:42 <mmorrow> , (fmap . fmap . fmap) (*2) (Node (Just [0..9]) [])
18:47:43 <lunabot>  Node {rootLabel = Just [0,2,4,6,8,10,12,14,16,18], subForest = []}
18:47:50 <mmorrow> like that?
18:48:20 <mmorrow> , (fmap . fmap) show (Node (Just [0..9]) [])
18:48:21 <lunabot>  Node {rootLabel = Just "[0,1,2,3,4,5,6,7,8,9]", subForest = []}
18:48:25 <mmorrow> , (fmap . fmap . fmap) show (Node (Just [0..9]) [])
18:48:26 <lunabot>  Node {rootLabel = Just ["0","1","2","3","4","5","6","7","8","9"], subFore...
18:48:30 <mmorrow> , (fmap) show (Node (Just [0..9]) [])
18:48:31 <lunabot>  Node {rootLabel = "Just [0,1,2,3,4,5,6,7,8,9]", subForest = []}
18:48:34 <eflister> i think so -- ideally i'd like some abstract def that could recognize that all the nested types were functors, and just pass fmap all the way down
18:48:42 <eflister> but i'd settle for having to write the instances myself
18:49:08 <mmorrow> so you always want to go to the very deepest you can go?
18:49:09 <Saizan> well, both are problematic
18:49:20 <mmorrow> yeah
18:49:35 <Saizan> there's oleg's DeepFunctor class
18:49:48 <eflister> yeah i'd be fine with it not working if any of the types weren't functors
18:49:50 <mmorrow> say you have ==> newtype Foo a = Foo (Tree (Maybe [a]))
18:49:56 <eflister> that sounds promising...
18:50:01 <mmorrow> what about the case of (Foo (Tree (Maybe [a]))) ?
18:50:07 <Saizan> but it generally needs some annotation to get the right instance picked
18:51:00 <ZelluX> /join #Python
18:51:01 <ZelluX>  
18:51:20 <mmorrow> eflister: you can always just newtype the type you want to have "fmap" go to "the bottom" of
18:51:24 <eflister> for Cale's example, since [] instances Functor, it would apply the show to each Char -- i don't get where there's ambiguity
18:51:52 <mmorrow> eflister: well, do you want:
18:52:03 <mmorrow> , (fmap . fmap) show (Node [0..9] [])
18:52:04 <lunabot>  Node {rootLabel = ["0","1","2","3","4","5","6","7","8","9"], subForest = []}
18:52:04 <mmorrow> or
18:52:08 <mmorrow> , (fmap) show (Node [0..9] [])
18:52:10 <lunabot>  Node {rootLabel = "[0,1,2,3,4,5,6,7,8,9]", subForest = []}
18:52:18 <Saizan> in general you can't base instance decision on the fact that some type _is not_ an instance of some class
18:52:44 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7953#a7953
18:54:36 <Saizan> http://okmij.org/ftp/Haskell/deepest-functor.lhs <- oleg's way is more complicated, but maybe requires less annotations in the end?
18:54:38 <wgsilkie> Why does this <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3193#a3193> happen?
18:54:41 <eflister> that looks great -- let me study it for a while
18:55:19 <Cale> wgsilkie: hmm, I'm not sure, but try :l EulerMath instead
18:55:41 <Botje> or :m EulerMath
18:55:51 <Botje> or :m +EulerMath
18:55:51 <Saizan> :m won't load it
18:56:20 * wgsilkie tries :l
18:56:59 <wgsilkie> OK, that works.
18:58:57 <Cale> I think import/:m generally doesn't work if :l could work. This can be confusing when there's usually a module which from most current working directories would be okay to load with :m +, but you happen to be in a directory where there's a module by the same name.
18:59:07 <Cale> I'm not sure why it happens though.
19:03:50 <inimino> I've come to the conclusion that most of "OOP" is a hack to ease the pain of working without a proper type system
19:04:48 <mike-burns> Has anyone done an OO language with a "proper type system"? (You get to fill in "proper type system" with your own definition.) Is it simply impossible?
19:04:53 <blackdog> inimino: which OOP do you mean? The agent-based approach is very different to the inheritance-based approach...
19:04:54 <soupdragon> okay you are wrong
19:05:08 <blackdog> you could argue that Erlang is OO in some sense
19:05:17 <soupdragon> mike-burns: Ocaml a
19:05:30 <mike-burns> Oh right; don't know how I forgot about OCaml.
19:05:34 <blackdog> soupdragon: no-one uses the OO features in Ocaml:) not even the designers.
19:06:05 <ray> scala?
19:06:13 <ZelluX> Maybe Scala is another choice?
19:06:26 <mike-burns> inimino: Are you complaining about C#/Java?
19:06:45 <inimino> blackdog: I mean mainly the idea of methods
19:07:13 <blackdog> inimino: so inheritance of methods, thent?
19:07:25 <inimino> mike-burns: not in particular
19:07:30 <mike-burns> inimino: Can you explain a bit further?
19:08:25 <inimino> blackdog: not even inheritance specifically (though I think that's horrifically broken generally)
19:08:41 <inimino> but if you have an object and you access a method of that object...
19:08:50 <inimino> object.foo(bar,baz)
19:09:06 <ray> it's just foo(implicit object,bar,baz)
19:09:25 <inimino> what is the main benefit of that over, say foo(obj,bar,baz)?
19:09:36 <mwc> Hahaha
19:09:40 <mwc> dons: you around?
19:09:45 <mike-burns> inimino: What's the benefit of foo(obj,bar,baz) over obj.foo(bar,baz) ?
19:09:50 <inimino> the main benefit is that, if you call obj.foo(bar,baz), you are guaranteed to be passing at least one object of the correct type
19:10:10 <mwc> just looked up Real World Haskell on amazon.ca. Here's dons's bio: Don Stewart Es graduado con honores del Seminario de Teologia Talbot y del Seminario Internacional de Teologia y Leyes de Estrasburgo, Francia. Es miembro de la sociedad nacional de honor Kappa Tau Epsilon, y pastor general de Calvary Chapel en Costa Mesa, California.
19:10:26 <ray> if only there were such a thing as type checking, right?
19:10:32 <inimino> exactly
19:10:54 <ray> architecture astronauts would probably say that's not the reason though
19:10:55 <dibblego> you don't get any additional type safety either way -- OO does not exist
19:10:56 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
19:10:59 <ray> i'm not sure what they would say
19:11:03 <ray> they are weird
19:11:22 <mike-burns> OO is more than just the syntax for calling one method.
19:11:25 <inimino> the primary benefit of OO is that it helps you connect the right functions to the right arguments
19:11:44 <blackdog> inimino: i don't think that's true at all
19:11:54 <gwern> mwc: I'm guessing that's not a correct bio...
19:12:16 <blackdog> the touted benefit is usually all about software maintenance - OO is one way of letting old code call new code
19:12:31 <blackdog> which is tricky in procedural languages, for instance
19:12:58 <mike-burns> The primary benefit of OO as I understand it is that you can add new data constructors without modifying existing code. Theorectically.
19:13:16 <mwc> gwern: my spanish sucks, but I'm pretty sure dons never attended seminary
19:13:20 <dibblego> that's called The Expression Problem and "OO" does not solve it (since it doesn't exist)
19:13:23 <gwern> you never know!
19:14:00 <mike-burns> I don't know what it means for OO to exist or to not exist. I suppose OO has as much meaning as FP, which I agree with.
19:14:22 <blackdog> mwc: he's an ordained minister of the Church of the Blessed Lambda
19:14:25 <dibblego> it means people squibble over the definition in a #haskell channel never arriving at any definition since it has none
19:14:41 <dibblego> http://apocalisp.wordpress.com/2009/04/27/a-critique-of-impure-reason/
19:14:47 <inimino> ok, s/OO/dotted method call syntax/g then
19:14:59 <dibblego> then stop talking about the benefits, since there are none
19:15:14 <blackdog> dibblego: i did try:) the original smalltalk idea had some merit in it. i still think erlang and smalltalk are much closer than typically thought...
19:15:19 <mike-burns> And likewise about the downsides.
19:15:29 <inimino> it does have a benefit, in a language without a type system
19:15:34 <dibblego> no it doesn't
19:15:37 <inimino> (as I described)
19:15:42 <mike-burns> Nah it really doesn't.
19:15:48 <Axman6> are there any languages without type systems?
19:15:48 <dibblego> you erred
19:15:58 <Baughn> Axman6: Assembly?
19:16:04 <mwc> Axman6: most ISAs
19:16:13 <blackdog> inimino: if you don't know (or have) the type of 'foo', how can foo.blah give you anything extra?
19:16:22 <Axman6> don't they distinguish between integral and floating values?
19:16:25 <inimino> well, matter of opinion
19:16:29 <mike-burns> It's a runtime exception in e.g. Ruby, Smalltalk, JavaScript. That's not useful.
19:16:40 <dibblego> no, it's a matter of fact -- there are no benefits, none, zilch
19:16:44 <inimino> blackdog: because foo doesn't have that method otherwise
19:17:08 <Baughn> Axman6: Not really. They may have special registers you need to load a value into before doing FP math on it, but there's no checking of the type of the value.
19:17:20 <mwc> Axman6: values in a register are just bits. One instruction treats them as signed, another as unsigned, one as 64 bit signed, another as 8 it unsigned.
19:18:45 <blackdog> inimino: but you don't know the type of foo, right? it could be anything. You might have read an object in from over the network, or anywhere. So how would you know if it had a method or not, unless there's some sort of type system (compile-time or runtime) sitting there?
19:19:01 <blackdog> foo.blah is just a string
19:19:27 <dibblego> "this syntax change provides some additional level of type safety" <-- how is that not obviously bogus?
19:20:08 <mike-burns> dibblego is arguing something I agree with better than I ever have, so I'll sit back and watch.
19:20:25 <inimino> blackdog: well there is /a/ type system
19:20:35 <blackdog> mike-burns: wish there was a popcorn stand in this channel
19:20:45 <inimino> blackdog: but the type system doesn't prevent you from calling ordinary functions with arguments of incorrect type
19:21:14 <mike-burns> blackdog: This place is crazy to watch from the perspective of someone who loves all programming paradigms.
19:22:23 <blackdog> inimino: which type system? you can't have this argument in a vacuum
19:22:30 <dibblego> mike-burns, I'm just fascinated by the fact that not only is the claim false, but it is so blatantly false as to be obvious -- yet it apparently isn't
19:22:31 <blackdog> in haskell, it certainly does
19:22:37 <inimino> so to the extent that there is any language-provided type safety in function inputs, it is only by foo.bar method access
19:22:40 <blackdog> in ruby it doesn't
19:23:33 <mike-burns> dibblego: But it's only obvious once you see it.
19:24:00 <dibblego> mike-burns, but is it even anything to see? "Bananas provide type safety" is just as obviously false
19:24:25 <inimino> dibblego: but you're wrong, it's not just a syntactic change
19:24:27 <blackdog> dibblego: aren't bananas a catamorphism or something?
19:24:39 <dibblego> inimino, then don't say it is (notice we are going around in circles)?
19:24:42 <mike-burns> Haha, the catamorphism was the first thing I thought of.
19:25:21 <sjanssen> ooh, what're we arguing about?
19:25:25 <inimino> dibblego: I never did say that, you may be going around in circles all by yourself
19:25:32 <dibblego> inimino, yes you did, precisely
19:25:43 <dibblego> sjanssen, x.f(y) provides additional type safety over f(x, y)
19:25:47 <dibblego> <inimino> ok, s/OO/dotted method call syntax/g then
19:26:20 <mike-burns> sjanssen: inimino makes the claim that OO, by some definition of OO, is a hack for languages with weak type safety. Some of us either disagree or don't understand what he means.
19:26:25 <inimino> dibblego: quote me
19:26:29 <dibblego> inimino, I just did
19:26:37 <inimino> dibblego: that quote doesn't even remotely make the claim that you claim I make
19:26:52 <regulate> whoa claim jumper
19:26:56 <dibblego> inimino, then what are you claiming if not a syntactic change when you say "dotted method call syntax"?
19:26:58 <soupdragon> #haskell-blah
19:27:01 <soupdragon> dibblego
19:27:15 * Axman6 agrees with soupdragon 
19:27:22 <Axman6> take it to #haskell-blah guys
19:27:23 * dibblego agrees too
19:27:30 <dibblego> no, it's too obviously false :)
19:27:49 <inimino> dibblego: foo.bar(baz) is not just a syntactic change from bar(foo,baz) because the former introduces a kind of error that the latter doesn't have
19:28:09 <dibblego> inimino, write it up in an article and I'll destroy it
19:28:15 <dibblego> inimino, we are done here
19:28:17 <mike-burns> I wish some bot in here would say "take it to #haskell-blah" as soon as someone says "OO".
19:28:25 <inimino> (namely, "bar is not a method of this object")
19:28:27 <inimino> (which is clearly a kind of type safety)
19:28:31 <dmwit> mike-burns: Take it to #haskell-blah!
19:28:35 <Axman6> inimino: #haskell-blah!
19:28:37 <mike-burns> Hahaha, well played.
19:28:40 <soupdragon> I wish I understood why people hate object so much man
19:28:45 <soupdragon> I am baffled so much hate
19:29:02 <soupdragon> nobody goes on like this about the terrible awfulness of STACK langs
19:29:02 <dmwit> soupdragon++ for both the -blah suggestion and the love
19:29:11 <lambdabot> mike-burns: "take it to #haskell-blah"
19:29:17 <Axman6> soupdragon: stacks are cool
19:29:33 <mike-burns> Oh man. Very well played.
19:29:41 <dibblego> there was never love or hate, just a false statement
19:29:49 <inimino> I didn't see any hate
19:29:55 <Axman6> -_-
19:29:56 <soupdragon> I'm talking about years
19:30:01 <soupdragon> not today really
19:30:13 <Axman6> #haskell-blah: haz u herd of et?
19:33:18 <hackagebot> yaml 0.0.2 - Support for serialising Haskell to and from Yaml. (MichaelSnoyman)
19:33:46 * inimino didn't expect so much fireworks, sorry about that
19:35:02 * Axman6 thinks the fireworks should continue, but not here
19:35:36 * soupdragon couldn't sleep because of all the loud drunk people
19:35:59 <blackdog> soupdragon: sports event?
19:36:18 <mike-burns> soupdragon: My apartment?
19:36:19 <soupdragon> no.. it's friday
19:36:43 <soupdragon> I wish the culture was not.. drinking
19:36:49 <dons> ?bug
19:36:49 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:37:09 <soupdragon> maybe if these folk were taught haskell instead of _______ in school we'd have less drunk annoying people
19:37:35 <mike-burns> Haskell programmers don't get drunk?
19:37:42 <blackdog> soupdragon: haskell drove me to drink, and you know, i never thanked her for it.
19:37:42 <soupdragon> lambda hackers don't go about banging things and knocking bins over
19:38:03 <blackdog> soupdragon: hm. i recall a conference in sweden...
19:38:20 <soupdragon> well everything is different in sweden...
19:40:26 <blackdog> don't suppose there are any jhc hackers in the house? can't find the command line args to include extra libraries
19:49:54 <ray> @faq can Haskell love?
19:49:55 <lambdabot> The answer is: Yes! Haskell can do that.
19:57:12 <andyjgill> Has anyone got OpenGLRaw working on OS X?
19:58:31 <ManateeLazyCat> @hoogle Functor f => (b -> f c) -> (a -> b) -> a -> f c
19:58:32 <lambdabot> No results found
19:58:39 <ManateeLazyCat> @hoogle Functor f => (a -> b) -> (b -> f c) -> a -> f c
19:58:40 <lambdabot> No results found
20:00:17 <ManateeLazyCat> How to implement above two functions?
20:01:33 <sjanssen> thefirstone f g x = f (g x) -- functor constraint superfluos
20:01:51 <sjanssen> thesecondone = flip thefirstone
20:04:29 <wgsilkie> > (\x -> [n | n <- [1..(floor (x/2))])
20:04:30 <lambdabot>   <no location info>: parse error on input `)'
20:04:37 <wgsilkie> > (\x -> [n | n <- [1..(floor (x/2))]) 5
20:04:39 <lambdabot>   <no location info>: parse error on input `)'
20:04:46 <wgsilkie> What's wrong with that?
20:04:49 <jaredj_> @seen sm
20:04:49 <lambdabot> sm is in #xmonad, #yi, #haskell and #darcs. I last heard sm speak 4h 38m 24s ago.
20:06:05 <sjanssen> wgsilkie: unclosed ] before the last )
20:07:13 <wgsilkie> > (\x -> [n | n <- [1..(floor (x/2))]]) 5
20:07:14 <lambdabot>   [1,2]
20:07:19 <wgsilkie> Ahhhh!
20:07:24 <wgsilkie> Thanks, sjanssen!
20:07:33 <wgsilkie> Darn brackets!
20:07:37 <wgsilkie> :)
20:10:37 <wgsilkie> > (\x -> [n | n <- [1..(floor (x/2))], x `mod` n == 0]) 5
20:10:38 <lambdabot>   Add a type signature
20:10:45 <wgsilkie> How?
20:11:10 * wgsilkie tries something.
20:12:35 <ManateeLazyCat> @let (<<=<) g h = g . h
20:12:37 <lambdabot>  Defined.
20:12:42 <ManateeLazyCat> :t <<=<
20:12:43 <lambdabot> parse error on input `<<=<'
20:12:48 <ManateeLazyCat> :t (<<=<)
20:12:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:13:07 <ManateeLazyCat> @type (<<=<)
20:13:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:13:18 <wgsilkie> What on Earth is <<=<?
20:13:27 <ManateeLazyCat> (<<=<) :: Functor f => (b -> f c) -> (a -> b) -> a -> f c
20:13:52 <gwern> wgsilkie: it's a rocket
20:13:58 <gwern> with multiple stages, on its side
20:14:04 <wgsilkie> Ah.
20:14:10 <wgsilkie> Hehe.
20:14:27 <ManateeLazyCat> (>=>>) :: Functor f => (a -> b) -> (b -> f c) -> a -> f c
20:14:30 <ManateeLazyCat> (>=>>) g h = h . g
20:16:04 <wgsilkie> How do I add a type signature to a lambda expression?
20:17:21 <dibblego> ManateeLazyCat, (Kleisli m a) has a Functor instance -- you are describing fmap
20:19:11 <dibblego> (I take that back, you're describing comap on (flip Kleisli m a))
20:19:54 <dmwit> > ((\x -> x) :: a -> a) 3 -- wgsilkie
20:19:55 <lambdabot>   3
20:20:18 <dmwit> > (\x -> x :: Int) 3 -- or you can annotate only the body of the lambda
20:20:19 <lambdabot>   3
20:20:28 <dmwit> :t \x -> x :: Int
20:20:29 <lambdabot> Int -> Int
20:20:43 <dmwit> :t \x -> x :: Int -> Int
20:20:44 <lambdabot> (Int -> Int) -> Int -> Int
20:20:46 <dmwit> :t (\x -> x) :: Int -> Int
20:20:47 <lambdabot> Int -> Int
20:20:50 <wgsilkie> dmwit: Thanks!
20:36:04 <wgsilkie> > ((\x -> [n | n <- [1..(floor (x/2))], x `mod` n == 0]) :: Int -> [Int])
20:36:05 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Types.Int)
20:36:06 <lambdabot>    arising from a use of ...
20:36:16 <wgsilkie> How do I fix that?
20:36:39 <sanders> challenge! someone improve this code to work better over very large directories: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7962#a7962
20:36:44 <dmwit> x `div` 2
20:36:50 <dmwit> or
20:36:57 <dmwit> floor (fromIntegral x / 2)
20:37:01 <wgsilkie> > ((\x -> [n | n <- [1..(floor (x `div` 2))], x `mod` n == 0]) :: Int -> [Int])
20:37:02 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Types.Int)
20:37:02 <lambdabot>    arising from a use of ...
20:37:08 <dmwit> no floor =)
20:37:30 <wgsilkie> > ((\x -> [n | n <- [1..(x `div` 2)], x `mod` n == 0]) :: Int -> [Int])
20:37:31 <lambdabot>   Overlapping instances for GHC.Show.Show
20:37:31 <lambdabot>                              (GHC.T...
20:37:39 <dmwit> apply the function to something
20:37:44 <wgsilkie> 5 `div` 2
20:37:47 <wgsilkie> > 5 `div` 2
20:37:49 <lambdabot>   2
20:38:31 <astrocub> runhaskell Setup.hs --user --prefix=$HOME
20:38:32 <astrocub> Setup.hs:3:0:
20:38:34 <astrocub>     Warning: Deprecated use of `defaultUserHooks'
20:38:35 <astrocub>              (imported from Distribution.Simple):
20:38:37 <astrocub>              Use simpleUserHooks or autoconfUserHooks, unless you need Cabal-1.2
20:38:38 <astrocub>              compatibility in which case you must stick with defaultUserHooks
20:38:40 <astrocub> unrecognised command: --user (try --help)
20:38:44 <dmwit> wgsilkie: Also, "n" is not in scope.
20:38:54 <dmwit> astrocub: In the future, please use hpaste.
20:38:58 <astrocub> help needed
20:39:00 <astrocub> alright
20:39:06 <dmwit> What package?
20:39:25 <astrocub> X11-1.4.5
20:39:40 <dmwit> Also, it's just a warning; if it builds, I recommend mailing the maintainer are very angry note and moving on with your life.
20:40:20 <astrocub> i can't build
20:40:24 <dmwit> Yeah, for X11 it wouldn't surprise me if they were trying to maintain Cabal-1.2 compatibility.
20:40:32 <dmwit> oh
20:40:36 <wgsilkie> dmwit: Yes, n is in scope.
20:40:37 <dmwit> astrocub: You forgot a command. =)
20:40:50 <wgsilkie> The problem was from no arguments to the function.
20:40:59 <wgsilkie> (The whole lambda thing, that is.)
20:41:09 <dmwit> astrocub: runhaskell Setup.hs configure --user --prefix=$HOME
20:41:17 <dmwit> astrocub: note the "configure" there =)
20:41:42 <astrocub> haha
20:41:49 <astrocub> wow
20:41:56 <astrocub> definitely time for sleep
20:42:02 <astrocub> thank you very much dmwit
20:43:00 <mmorrow> sanders: if you want results returned "as they're found", and not just pushed on the stack to wait until `find' has found _everything_, then you'll want to use unsafeInterleaveIO
20:43:57 <mmorrow> e.g. (\(x:xs) -> do y <- fooWithIO x; ys <- unsafeInterleaveIO (mapM fooWithIO xs); return (y:ys))
20:44:02 <sanders> mmorrow: that is in fact exactly what I was wanting
20:44:17 <shapr> Whoa, RIP John Hughes had me really worried for a sec
20:44:25 <mmorrow> that "e.g." is the general pattern to do that
20:46:06 <blackdog> shapr: not a breakfast club fan, then?
20:46:08 <BMeph> Haskell's gotten quite intriguing lately - I've just gotten in-depth into combinatorics, and lo and behold, HaskellForMaths and species come along. It's a good year to be a maths geek! ;)
20:46:47 <mmorrow> sanders: err, sctually the e.g. isn't a great example.. one sec
20:46:50 <mmorrow> *actually
20:47:26 <michaelfeathers> Laziness question: If I have something like drop 10 [f x  | x <- [0..]]  is it the case that f isn't evaluated until the 10th element?
20:47:45 <sanders> mmorrow: I changed line 27 of my code to: unsafeInterleaveIO $ mapM (\x->find x filters) list >>= return . concat
20:47:49 <michaelfeathers> 11th, I mean.
20:48:08 <sanders> and it did seem to give me the results I was looking for
20:48:18 <mmorrow> sanders: nice
20:48:32 <centrinia> > let f x = if x < 10 then f x else x in drop 10 [f x | x <- [0..]]
20:48:33 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
20:48:36 <dibblego> > drop 1 [undefined, 7] -- michaelfeathers ?
20:48:38 <lambdabot>   [7]
20:48:54 <aavogt> > take 10 $ drop 10 [(0,x) | x <- replicate 10 undefined ++ [11..]]
20:48:55 <lambdabot>   [(0,11),(0,12),(0,13),(0,14),(0,15),(0,16),(0,17),(0,18),(0,19),(0,20)]
20:49:25 <michaelfeathers> Thx.  Clever use of undefined.
20:49:27 <mmorrow> sanders: ok, then that example was ok:) (i second guessed myself for a minute there if the unsafeInterleaveIO would apply to each item returned by mapM individually, or you'd just end up getting the first `y' immediately, then be in the same situation for all the `ys')
20:50:06 <mmorrow> sanders: (but if that is the case, you'd just apply that strategy recursively)
20:51:24 <sanders> mmorrow: thanks for the help
20:51:29 <mmorrow> sanders: np
21:06:27 <astrocub> typo on http://www.haskell.org/cabal/   "Specifically, the Cabal describes what a Haskell package is, how these packages interact with the language, and what Haskell implementations *must to do to support *packages."
21:08:00 <sm> hi jaredj_
21:23:18 <mxc> this might be a stupid question, but Control.Concurrent.Chan is thread safe in that multiple threads can write to the same chan without having syncrhonize right?
21:23:26 <dons> yes
21:23:26 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:24:04 <mxc> ty
21:38:51 <Gracenotes> hm. xkcd is pretty good today. But it feels like a forced reference :/
21:38:59 <Gracenotes> *thumbs up anyway*
21:41:32 <peter_12> I'm just learning about ACID and thinking about it more generally than a database or stm. In a two-phase commit, if all entities agree the changes are ok and tell the coordinator that, what happens if there is a problem when the coordinator sends messages to make the commit permanent? It seems like big problems can happen at this stage
22:12:24 <bos> @seen dons
22:12:25 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 48m 49s ago.
22:29:51 <copumpkin> I don't get why that guy on haskell-cafe doesn't want to use --make
22:32:49 <Saizan> title?
22:34:41 <dons> bos:
22:34:51 <bos> hi dons
22:35:08 <dons> hey, 'sup?
22:35:24 <Saizan> copumpkin: i'm not sure if you can use --make just for linking
22:35:27 <bos> i've been tortured by jim and francesco, who have the temerity to expect an abstract out of me for my CUFP keynote
22:35:38 <dons> ah ha
22:35:56 <copumpkin> Saizan: I guess I just don't see why he's insisting on doing it the hard way when GHC can take care of all your dependencies for you
22:35:57 <bos> and keynotes are terrible things to have to write abstracts for.
22:36:31 <bos> "i will ensure that the audience is awake. i will make them laugh with some amusing stories. i will say some things that sound clever if you don't think about them too much."
22:36:40 <copumpkin> lol
22:36:45 <dons> this is good
22:37:15 <c_wraith> that sounds like a good abstract to me
22:37:22 <dons> "Overall, I learned a ton of new things from reading this book
22:37:24 <dons> even thought the material is quite challenging in places, and found myself wondering why more people don't use Haskell."
22:37:27 <dons> -- seen on powells
22:37:45 <dons> cause and effect? :}
22:38:14 <bos> i've no energy for blogging about haskell these days, but we could sure staff up on the marketing front.
22:38:59 <dons> yes, its not  the most popular activity
22:39:20 <dons> i wish more people would review and write about things on hackage
22:39:39 <dons> maybe i should try to build a blogging coalition to do that. hmm
22:40:39 * copumpkin will start up a haskell blog eventually, when the current round of deadlines is over
22:40:44 <copumpkin> all for the cause!
22:41:09 <bos> something like the python module of the week would be cool. http://www.doughellmann.com/PyMOTW/contents.html
22:41:30 <dons> 52 weeks in a year, 1500 packages. mm. that should keep us occupied
22:42:39 <dons> yes, good idea. this is a nice model
22:42:40 <bos> heck, just focusing on the stuff in the HP would be a good start.
22:42:56 <bos> then covering the rest according to people's level of interest.
22:43:00 <dons> right.
22:43:31 * dons imagines the Haskell Platform reference bible
22:44:21 <dons> the small intros on archhaskell about say, atom or bloxorz were hugely popular.
22:45:26 <bos> Oh, nice.
22:45:30 <dons> you can see the top articles are all roughly 'module of the week' style, http://archhaskell.wordpress.com/
22:46:04 <dons> well, even cheaper, just a video, or collecting and describing the package.
22:53:33 <cjs> Yay! First connection to the production market.
22:55:30 <dons> cjs: you got some system online?
22:57:12 <cjs> Yup. The order management console for our trading system, connecting to the Korean Exchange.
22:57:34 <cjs> I owe it all to Data.ByteString. :-)
22:57:44 <taruti> Is there currently a service that enables trying to compile a haskell package on various operating systems?
22:58:07 <taruti> or is the preferred way to just wait for bug reports
22:58:47 <pikhq> taruti: Virtual machines and judicious scripting of SSH.
22:59:33 <dons> cjs: :D
22:59:42 <dons> cjs: you'll be in Edinburgh, right?
23:00:01 <taruti> pikhq: so no service available? (yes I could install various OSs to virtual machines fight to get ghc installed and then try but seems like a lot of effort)
23:16:35 <cjs> Yup, I'll be there.
23:17:16 <cjs> dons: I'm hoping that we can do some production runs of the actual automated trading system itself the week before, so I'll have a very nice success to report when I give my paper.
23:18:06 <cjs> I'm giving an Experience Report at ICFP itself, and I'll also be talking a bit about my build system at the Haskell implementors' thingie.
23:18:25 <dons> ah excellent
23:18:48 <cjs> Yes, I'm pretty chuffed.
23:19:07 <cjs> I'll be even more chuffed once this makes me rich. :-)
23:24:33 <mmorrow_> cjs: congratulations
23:30:21 <cjs> Thanks.
23:30:43 <cjs> I wonder if anyone else is using Haskell to connect to a market.
23:32:14 <Ke> market?
23:32:26 <Ke> heh
23:32:32 <Saizan> cjs: do you have anything on your build system up somewhere?
23:32:36 <cjs> Electronic trading system of some sort. We're talking to the Korean Exchange.
23:32:55 <cjs> Saizan: http://www.starling-software.com/en/qam.html
23:32:56 <Ke> wasn't that erlang stuff
23:33:00 <mmorrow> cjs: yeah, i'm interested in this build system too. i didn't know you were working on such a thing.
23:33:31 <mmorrow> cjs: if you haven't heard about it, i doubt anyone is.
23:33:48 <cjs> Oh, I've had the thing for years. It's fairly primitive when it comes to the Haskell side, but it works, and it's some of the ideas in it, more than anything else, that are important. Those aren't really discussed on the web pages, though.
23:34:08 <cjs> mmorrow: Well, people in finance don't really talk about this sort of thing too much.
23:34:09 <ManateeLazyCat> Have an exist function that fill blank in filepath, example i input "/test/blank directory/" it output "/test/blank\\ directory/" ?
23:34:37 <cjs> For example, I'd bet that Jane Street might have O'Caml code that does market connectivity, but who knows.
23:34:43 <mmorrow> cjs: but i'd imagine that you'd hear /something/ about someone doing such a thing
23:35:14 <mmorrow> cjs: it seems to me that'd be something someone would want to publicize (no matter how vaguely they describe it)
23:35:53 <cjs> Yeah, you'd think so, actually. I'd guess that most of the Haskell community hangs around here and ICFP.
23:35:54 <mmorrow> cjs: i thought that they do is a known thing? (haven't read their blurb in a while though)
23:36:53 <cjs> mmorrow: Yeah, but I've never talked to them (even though they have an office a few miles from me, they don't seem to want to show up at TSAC meetings), and it's hard to know with shops that have been around for a while how much is FP and how much is C/C++.
23:37:30 <cjs> It's pretty common, from what I can tell, to use functional languages for analysis and stuff like that, but to do all the low-level-pumping-data-around kind of stuff in C or C++.
23:38:09 <cjs> So yeah, maybe I'm the first to prove that Haskell really can entirely replace C in applications like this.
23:38:47 <mmorrow> cjs: nicely done :)
23:38:58 <cjs> Cheers!
23:39:22 <cjs> Of course, it won't be quite so impressive if we blow up and lose all of our capital. :-)
23:39:53 <alc> > concatMap (\x -> case x of ' ' -> "\\ "; _ -> [x]) "/test/blank directory/"
23:39:54 <lambdabot>   "/test/blank\\ directory/"
23:41:12 <ManateeLazyCat> alc: Great! Thanks a lots!
23:41:19 <mmorrow> > concatMap (\x -> case x of ' ' -> "\\ "; _ -> [x]) "/test/blank\\ directory/"
23:41:20 <lambdabot>   "/test/blank\\\\ directory/"
23:41:24 <mmorrow> ;)
23:41:28 <mmorrow> cjs: hehe
23:41:37 <alc> np
23:41:50 <cjs> "GHC: Helping you lose money faster than ever."
23:45:06 <mmorrow> > let fixup = let go ('\\':' ':cs) = "\\ " ++ go cs; go (' ':cs) = "\\ " ++ go cs; go (c:cs) = c : go cs; go [] = [] in go in fixup "/test/blank\\  directory/"
23:45:08 <lambdabot>   "/test/blank\\ \\ directory/"
23:45:25 <mmorrow> > let fixup = let go ('\\':' ':cs) = "\\ " ++ go cs; go (' ':cs) = "\\ " ++ go cs; go (c:cs) = c : go cs; go [] = [] in go in (fixup . fixup . fixup . fixup) "/test/blank\\  directory/"
23:45:26 <lambdabot>   "/test/blank\\ \\ directory/"
23:53:22 <hackagebot> dyre 0.6.1 - Dynamic reconfiguration in Haskell (WillDonnelly)
23:56:30 <copumpkin> @hackage dyre
23:56:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dyre
23:58:23 <hackagebot> dyre 0.6.2 - Dynamic reconfiguration in Haskell (WillDonnelly)
